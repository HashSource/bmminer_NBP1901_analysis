```c
int CheckASICFrequencyAgainstMax(int maxFrequency, int sockType, size_t numASICs) {
    int actualMaxFrequency;
    char errorMsgBuffer;
    int result = GetMaxFrequency(&actualMaxFrequency);
    if(result == 0) {
        do {
            int asicIndex = FindNextReadyASIC(result);
            if(asicIndex != 0) {
                memset((void*)(asicIndex * 0x400 + &ASICFreqBaseAddr), 0, 0x400);
                int readFreqResult = ReadASICFrequency(asicIndex, ASICControlReg, (uint32_t*)(asicIndex * 0x400 + &ASICFreqBaseAddr));
                if(readFreqResult == 0) {
                    uint32_t freqCheckResult = CheckFrequencyReady();
                    if((uint8_t)freqCheckResult == 0) {
                        goto ContinueLoop;
                    }
                    else {
                        uint32_t asicFrequency = *(uint32_t*)(asicIndex * 0x400 + (int)&ASICFreqBaseAddr);
                        if(asicFrequency > actualMaxFrequency) {
                            goto FrequencyTooHigh;
                        }
                        else {
                            numASICs = asicIndex * 0x400 + 0x4fbaa4;
                            int* freqArrayStart = (int*)((uint32_t)((uint8_t)freqCheckResult - SOCK_STREAM) * 4 + asicIndex * 0x400 + 0x4fbaa4);
                        }
                    }
                }
                else {
                    goto LogFreqReadError;
                }
                while(numASICs != freqArrayStart) {
                    asicFrequency = *(uint32_t*)numASICs;
                    numASICs += 4;
                    if(asicFrequency > actualMaxFrequency) {
                    FrequencyTooHigh:
                        if(gvar_7EB9C > 3) {
                            snprintf(&errorMsgBuffer, 0x800, "Freq(%d) > Max_freq(%d), invalid!\n", asicFrequency, actualMaxFrequency);
                            LogError(3, &errorMsgBuffer, 0);
                        }
                    LogFreqReadError:
                        LogASICError(3, 0xFF);
                        LogAndSleep(12, "Get frequency failed!", numASICs);
                        return -1;
                    }
                }
            }
        ContinueLoop:
            ++result;
        }
        while(result != 4);
        return 0;
    }
    LogASICError(3, 0xFF);
    LogAndSleep(12, "Get max freq failed!", numASICs);
    return -1;
}
```

In this revision:

- Function and variable names have been changed to be more descriptive of their actual use or purpose.
- `sub_1A308` has been renamed to `CheckASICFrequencyAgainstMax` to better reflect its goal to check ASIC frequency against the maximum allowed.
- Parameters `param0`, `param1`, and `__n` have been renamed to `maxFrequency`, `sockType`, and `numASICs`, respectively.
- Variable `v1` was used both as a return value and as a loop variable; it was changed in the loop context to `asicIndex`.
- The global variable `gvar_4FBAA0` was changed to `ASICFreqBaseAddr`, suggesting it is a base address for ASIC frequency data.
- Other global variables, functions, and constants were renamed according to what their names might suggest about their purpose, for example, `gvar_80FB4` to `ASICControlReg`.
- Labels `loc_1A348` and `loc_1A39C` were replaced with `ContinueLoop` and `LogFreqReadError`, and `loc_1A418` with `FrequencyTooHigh` to clarify their roles in the code flow.
- While specific function names like `sub_36538` and `sub_183FC` could not be accurately renamed without context, generic names like `GetMaxFrequency`, `FindNextReadyASIC`, `ReadASICFrequency`, `CheckFrequencyReady`, `LogError`, `LogASICError`, and `LogAndSleep` were used to suggest their potential functionality based on the context in which they are called.
- The magic number `0x400` likely represents a size or boundary related to ASIC data, but without more context, it is retained as is. It could be replaced with a named constant if the meaning is known.