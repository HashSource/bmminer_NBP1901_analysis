```c
int updateEEPROMMinerInfo()
{
  unsigned int chainIndex; // r4
  int updateStatus; // r8
  int chainConfigAddress; // r6
  int dataStartOffset; // r1
  size_t dataSize; // r2
  int dataSizeAdjusted; // r9
  int paddingStartOffset; // r7
  size_t paddingSize; // r3
  const void *dataStartPtr; // r1
  size_t requiredSize; // r6
  unsigned int paddingMultiple8; // r6
  unsigned int writeStartOffset; // r7
  char buffer[256]; // [sp+8h] [bp-928h] BYREF
  char logBuffer[2088]; // [sp+108h] [bp-828h] BYREF

  if (globalChainConfigs[0] && *(_BYTE *)(globalChainConfigs[0] + 28))
  {
    chainIndex = 0;
    updateStatus = 0;
    do
    {
      if (isChainActive(chainIndex))
      {
        memset(buffer, 0, sizeof(buffer));
        chainConfigAddress = *(_DWORD *)(globalChainConfigs[0] + 4 * chainIndex);
        if (globalLogLevel > 3)
        {
          snprintf(logBuffer, 0x800u, "[chain %d] Update miner info in eeprom.\n", chainIndex);
          logMessage(3, logBuffer, 0);
        }
        dataStartOffset = *(unsigned __int8 *)(chainConfigAddress + 1);
        dataSize = *(unsigned __int8 *)(chainConfigAddress + 56);
        dataSizeAdjusted = 57 - dataStartOffset;
        paddingStartOffset = dataStartOffset + 5;
        paddingSize = dataSize - dataSizeAdjusted;
        dataStartPtr = (const void *)(chainConfigAddress + dataStartOffset);
        requiredSize = paddingSize + 7;
        memcpy(buffer, dataStartPtr, dataSize);
        paddingMultiple8 = requiredSize & 0xFFFFFFF8;
        writeStartOffset = (paddingStartOffset & 0xFFFFFFF8) + 2;
        calculateDataChecksum(&buffer[dataSizeAdjusted], paddingMultiple8, 1);
        if (256 - writeStartOffset >= dataSizeAdjusted + paddingMultiple8)
        {
          writeDataToEEPROM(chainIndex, writeStartOffset & 0xFE, (int)buffer, dataSizeAdjusted + paddingMultiple8);
        }
        else
        {
          updateStatus = -1;
          if (globalLogLevel > 3)
          {
            snprintf(logBuffer, 0x800u, "[chain %d] Update miner info Failed, EEPROM does not have enough space.\n", chainIndex);
            logMessage(3, logBuffer, 0);
          }
        }
      }
      ++chainIndex;
    } while (chainIndex != 4);
    return updateStatus;
  }
  if (globalLogLevel <= 3)
    return -1;
  strcpy(logBuffer, "No fixture configuration for flush.\n");
  logMessage(3, logBuffer, 0);
  return -1;
}
```