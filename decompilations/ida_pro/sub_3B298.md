```c
char *__fastcall performFrequencyTuning(int targetFrequency)
{
  int *configPtr; // r4
  char *tuningResult; // r4
  int chainIndex; // r4
  char *currentFrequency; // r8
  int frequencyStep; // r5
  int tuningStatus; // r0
  int innerIndex; // r4
  int bestPerformanceIndex; // r11
  int chainLoopIndex; // r4
  int frequencyDifference; // r9
  char **performanceArrayPtr; // r11
  char **frequencyArrayPtr; // r10
  int isChainActive; // r0
  char *bestFrequency; // r2
  char *currentFreqPointer; // r3
  int chainPerformanceIndex; // r8
  int selectedIndex; // r1
  float *performancePtr; // r2
  int innerLoopIndex; // r3
  float currentPerformance; // s12
  bool isAboveThreshold; // cc
  char *selectedFreqForChain; // r0
  float highestPerformance; // s0
  int configOffset; // r3
  char *returnBuffer[76]; // [sp+10h] [bp-980h]
  int frequencyOffset; // [sp+14h] [bp-97Ch]
  char *frequencyBuffer[76]; // [sp+28h] [bp-968h] BYREF
  char charBuffer[2040]; // [sp+158h] [bp-838h] BYREF

  if ( (unsigned int)globalLogLevel > 3 )
  {
    strcpy(charBuffer, "Do freq tuning basic.\n");
    logMessage(3, charBuffer, 0);
  }
  configPtr = (int *)minerConfigAddress;
  memset((void *)(minerConfigAddress + 4), 0, 0x30u);
  *configPtr = targetFrequency;
  initializeASICFrequency();
  synchronizeASICFrequency(**(int **)minerConfigAddress);
  tuningResult = (char *)testVoltagesAndFrequencies();
  if ( !tuningResult )
  {
    setASICClockToDefault(255, (unsigned __int8)defaultVoltage, *(unsigned __int8 *)(*(_DWORD *)minerConfigAddress + 20));
    if ( (unsigned int)globalLogLevel > 3 )
    {
      strcpy(charBuffer, "\n");
      logBufferToConsole(3, charBuffer, 0);
      if ( (unsigned int)globalLogLevel > 3 )
      {
        strcpy(charBuffer, ">>>> Do tuning in parallel.\n");
        logMessage(3, charBuffer, 0);
      }
    }
    for ( chainIndex = 0; chainIndex != 4; ++chainIndex )
    {
      if ( isChainActive(chainIndex) )
        startASIC(chainIndex, 1);
    }
    currentFrequency = *(char **)(*(_DWORD *)minerConfigAddress + 4);
    frequencyOffset = *(_DWORD *)(*(_DWORD *)minerConfigAddress + 16);
    returnBuffer = *(char **)(*(_DWORD *)minerConfigAddress + 12);
    if ( (unsigned int)globalLogLevel > 3 )
    {
      snprintf(
        charBuffer,
        0x800u,
        "freq_prev = %d, freq_start = %d, freq_step = %d, freq_min = %d\n",
        currentFrequency,
        currentFrequency,
        frequencyOffset,
        *(_DWORD *)(*(_DWORD *)minerConfigAddress + 12));
      logMessage(3, charBuffer, 0);
    }
    frequencyBuffer[0] = currentFrequency;
    if ( currentFrequency < returnBuffer )
    {
      chainPerformanceIndex = 0;
      tuningResult = 0;
    }
    else
    {
      chainPerformanceIndex = 0;
      while ( 1 )
      {
        if ( (unsigned int)globalLogLevel <= 3
          || (strcpy(charBuffer, "\n"), logBufferToConsole(3, charBuffer, 0), (unsigned int)globalLogLevel <= 3) )
        {
          tuningStatus = testASICChainPerformance();
          if ( !tuningStatus )
            goto LABEL_59;
        }
        else
        {
          snprintf(charBuffer, 0x800u, ">>>> freq_curr = %d\n", frequencyBuffer[0]);
          logMessage(3, charBuffer, 0);
          tuningStatus = testASICChainPerformance();
          if ( !tuningStatus )
          {
LABEL_59:
            tuningResult = (char *)tuningStatus;
            if ( (unsigned int)globalLogLevel > 3 )
            {
              strcpy(charBuffer, "All ready chain done, exit.\n");
              logMessage(3, charBuffer, tuningStatus);
            }
            goto LABEL_36;
          }
        }
        for ( innerIndex = 0; innerIndex != 4; ++innerIndex )
        {
          if ( isChainActive(innerIndex) && isASICWorkingProperly(innerIndex) == 1 )
            setASICFrequencyLevel(
              innerIndex,
              (unsigned __int8)defaultVoltage,
              (unsigned int)currentFrequency,
              frequencyBuffer[0],
              *(_BYTE *)(*(_DWORD *)minerConfigAddress + 21));
        }
        currentFrequency = frequencyBuffer[0];
        tuningResult = (char *)testVoltagesAndFrequencies();
        if ( tuningResult )
          break;
        testFrequencyPerformance((int)frequencyBuffer[0], optMultiVersion, 20);
        waitForStablePerformance((int)frequencyBuffer);
        bestPerformanceIndex = findBestPerformanceFactor();
        do
        {
          if ( isChainActive((int)tuningResult) && isASICWorkingProperly((int)tuningResult) == 1 )
            processASICPerformance(tuningResult, bestPerformanceIndex);
          ++tuningResult;
        }
        while ( tuningResult != (char *)4 );
        for ( chainLoopIndex = 0; chainLoopIndex != 4; ++chainLoopIndex )
        {
          if ( isChainActive(chainLoopIndex) && isASICWorkingProperly(chainLoopIndex) == 1 )
          {
            highestPerformance = *(float *)(*(_DWORD *)minerConfigAddress + 28);
            if ( isPerformanceAboveThreshold(chainLoopIndex) )
              startASIC(chainLoopIndex, 2);
            else
              *(_DWORD *)(minerConfigAddress + 4 * chainLoopIndex + 20) = 1;
            processASICPerformanceData();
            configOffset = minerConfigAddress + 4 * chainLoopIndex;
            if ( highestPerformance > *(float *)(configOffset + 36) )
              *(float *)(configOffset + 36) = highestPerformance;
          }
        }
        frequencyDifference = 0;
        performanceArrayPtr = (char **)((char *)hashrateArrayPtr + bestPerformanceIndex);
        frequencyArrayPtr = &frequencyBuffer[4 * chainPerformanceIndex + 16];
        do
        {
          isChainActive = isChainActive(frequencyDifference++);
          if ( isChainActive )
            bestFrequency = *performanceArrayPtr;
          ++frequencyArrayPtr;
          if ( isChainActive )
            currentFreqPointer = frequencyBuffer[0];
          ++performanceArrayPtr;
          if ( isChainActive )
          {
            *(frequencyArrayPtr - 1) = bestFrequency;
            frequencyBuffer[chainPerformanceIndex + 1] = currentFreqPointer;
          }
        }
        while ( frequencyDifference != 4 );
        ++chainPerformanceIndex;
        frequencyBuffer[0] -= frequencyOffset;
        if ( returnBuffer > frequencyBuffer[0] )
        {
          tuningResult = 0;
          goto LABEL_36;
        }
      }
      if ( (unsigned int)globalLogLevel > 3 )
      {
        strcpy(charBuffer, "Set voltage failed, exit.\n");
        logMessage(3, charBuffer, 0);
      }
    }
LABEL_36:
    chainPerformanceIndex = 0;
    if ( isChainActive(0) )
      goto LABEL_39;
    while ( ++chainPerformanceIndex != 4 )
    {
      if ( isChainActive(chainPerformanceIndex) )
      {
LABEL_39:
        selectedIndex = 0;
        performancePtr = (float *)&frequencyBuffer[chainPerformanceIndex + 16];
        innerLoopIndex = 0;
        while ( innerLoopIndex < chainPerformanceIndex - 1 )
        {
          currentPerformance = *performancePtr;
          if ( *performancePtr < 5.0 )
          {
            selectedIndex = innerLoopIndex;
            break;
          }
          performancePtr += 4;
          ++innerLoopIndex;
          if ( currentPerformance > *performancePtr * 1.5 )
            selectedIndex = innerLoopIndex;
        }
        isAboveThreshold = (unsigned int)globalLogLevel > 3;
        selectedFreqForChain = frequencyBuffer[selectedIndex + 1];
        *(_DWORD *)(minerConfigAddress + 4 * chainPerformanceIndex + 4) = selectedFreqForChain;
        if ( isAboveThreshold )
        {
          snprintf(charBuffer, 0x800u, "chain %d best level %d, freq %d\n", chainPerformanceIndex, selectedIndex, selectedFreqForChain);
          logMessage(3, charBuffer, 0);
        }
      }
    }
  }
  return tuningResult;
}
```