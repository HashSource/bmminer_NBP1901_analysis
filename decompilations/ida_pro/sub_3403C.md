```c
void InitializeASICChains()
{
  int currentChainIndex; // r11
  int retCode; // r0
  int *chainDataPointer; // r10
  int chainIndexCounter; // r9
  char *tempBuffer; // r11
  int pulseCode; // r0
  pthread_mutex_t *chainMutex; // r8
  int entriesLeftToProcess; // r3
  int entryCounter; // r7
  int workEntryIndex; // r5
  int workChainIndex; // r4
  unsigned int workQueueIndex; // r4
  bool isQueueIndexOverflow; // cc
  int *workEntry; // r4
  int throttleValue; // r6
  int tempScheduleVar; // r11
  int errorCode; // r0
  int lastErrorCode; // r0
  int problematicChainCounter; // r8
  int chainIdForDisplay; // r6
  int iterationStatusCode; // r0
  char iterationStatusFlag; // r8
  int currentChain; // r11
  int currentChainId; // r10
  int currentWorkCount; // r7
  int hasMissingWork; // r3
  int currentWorkIndex; // r5
  unsigned __int16 *workStatusPointer; // r4
  int currentWorkStatus; // r6
  int currentChainProcessedWork; // r8
  int initStatusCode; // r0
  int resetStatusCode; // r0
  int setFrequencyStatusCode; // r0
  int setVoltageStatusCode; // r0
  int restartStatusCode; // r0
  int clockResetStatusCode; // r0
  int clockSetStatusCode; // r0
  int finishedChainsCounter; // r5
  int problematicChainIndex; // r8
  int problematicChainFlag; // [sp+10h] [bp-880h]
  char *messageBuffer; // [sp+20h] [bp-870h]
  pthread_mutex_t *chainMutexCopy; // [sp+24h] [bp-86Ch]
  int chainCounterCopy; // [sp+24h] [bp-86Ch]
  int throttleIndex; // [sp+2Ch] [bp-864h]
  int *chainDataPointerCopy; // [sp+2Ch] [bp-864h]
  int errorCodeCopy; // [sp+30h] [bp-860h]
  int workEntryIndexCopy; // [sp+34h] [bp-85Ch]
  int tempWorkCounter; // [sp+44h] [bp-84Ch]
  _WORD *workStatusCodeArray; // [sp+48h] [bp-848h]
  __int16 hashboardInitCode; // [sp+54h] [bp-83Ch]
  char hashboardMinorCode; // [sp+56h] [bp-83Ah]
  int bufferTime[2]; // [sp+58h] [bp-838h] BYREF
  char tempBufferForMessages[2096]; // [sp+60h] [bp-830h] BYREF

  currentChainIndex = 0;
  workEntryIndexCopy = 0;
  retCode = configurePulseAndDelays();
  hashboardInitCode = retCode;
  hashboardMinorCode = BYTE2(retCode);
  InitializeASICStatusArrays();
  do
  {
    if ( !IsChainOperational(currentChainIndex) )
      goto LABEL_3;
    chainDataPointer = globalChainDataPointer;
    chainIndexCounter = currentChainIndex;
    workStatusCodeArray = &globalWorkStatusCodeArray[0x80000 * currentChainIndex];
    tempWorkCounter = 0;
    SetASICThrottle(currentChainIndex, 1, 0, (unsigned __int8)throttleSetting);
    while ( 1 )
    {
      globalIterationStatusFlag = 1;
      UpdateASICConfiguration();
      memset(workStatusCodeArray, 0, 0x100000u);
      errorCode = GetThrottleValue();
      if ( errorCode > 0 )
      {
        tempBuffer = tempBufferForMessages;
        throttleIndex = 0;
        do
        {
          pulseCode = GetPulseCode();
          chainMutex = &globalChainMutex;
          SendPulseToChain((unsigned __int8)chainIndexCounter, throttleIndex * pulseCode);
          GetCurrentTime(bufferTime);
          do
          {
            pthread_mutex_lock(chainMutex);
            entriesLeftToProcess = chainDataPointer[2];
            entryCounter = entriesLeftToProcess;
            if ( entriesLeftToProcess > 0 )
            {
              workEntryIndex = 0;
              messageBuffer = tempBuffer;
              chainMutexCopy = chainMutex;
              while ( 1 )
              {
                workChainIndex = chainDataPointer[1];
                ++workEntryIndex;
                chainDataPointer[2] = entriesLeftToProcess - 1;
                workQueueIndex = workChainIndex + 1;
                isQueueIndexOverflow = workQueueIndex > 0x1FE;
                if ( workQueueIndex <= 0x1FE )
                  chainDataPointer[1] = workQueueIndex;
                workEntry = &chainDataPointer[2 * workQueueIndex];
                if ( isQueueIndexOverflow )
                  chainDataPointer[1] = 0;
                if ( *((unsigned __int8 *)workEntry + 11) == chainIndexCounter && *((_BYTE *)workEntry + 10) == 64 )
                {
                  throttleValue = *((unsigned __int8 *)workEntry + 9);
                  tempScheduleVar = workEntry[1];
                  pulseCode = GetPulseCode();
                  errorCode = CalculatePulseValue(throttleValue, pulseCode);
                  problematicChainCounter = *((unsigned __int8 *)workEntry + 9);
                  chainIdForDisplay = *((_BYTE *)workEntry + 11) & 3;
                  globalWorkStatusCodeArray[0x80000 * (chainIndexCounter & 3) + 1 + 2048 * errorCode + 2 * (*((_WORD *)workEntry + 3) & 0x3FF)] = tempScheduleVar;
                  iterationStatusCode = GetPulseCode();
                  globalWorkStatusCodeArray[2048 * (CalculatePulseValue(problematicChainCounter, iterationStatusCode) + (chainIdForDisplay << 8)) + 2 * (*((_WORD *)workEntry + 3) & 0x3FF)] = 1;
                }
                if ( entryCounter == workEntryIndex )
                  break;
                entriesLeftToProcess = chainDataPointer[2];
              }
              tempBuffer = messageBuffer;
              chainMutex = chainMutexCopy;
            }
            pthread_mutex_unlock(chainMutex);
            usleep(0x3E8u);
            GetCurrentTime((struct timespec *)tempBuffer);
          }
          while ( (int)CompareTime(tempBuffer, bufferTime) <= 99 );
        }
        while ( errorCode != ++throttleIndex );
      }
      chainCounterCopy = GetThrottleValue();
      if ( chainCounterCopy <= 0 )
        break;
      iterationStatusFlag = 0;
      chainDataPointerCopy = chainDataPointer;
      currentChain = 0;
      currentChainId = 0;
      do
      {
        currentWorkCount = GetWorkStatus();
        if ( currentWorkCount > 0 )
        {
          hasMissingWork = 0;
          currentWorkIndex = 0;
          workStatusPointer = &globalWorkStatusCodeArray[2048 * (currentChain + workEntryIndexCopy)];
          do
          {
            currentWorkStatus = workStatusPointer[1];
            if ( !workStatusPointer[1] )
            {
              currentChainProcessedWork = *workStatusPointer;
              if ( *workStatusPointer )
              {
                if ( (unsigned int)globalLogLevel > 3 )
                {
                  snprintf(tempBufferForMessages, 0x800u, "core %8d data in asic %d is zero", currentWorkIndex, currentChain);
                  logMessage(3, tempBufferForMessages, currentWorkStatus);
                }
              }
              else if ( (unsigned int)globalLogLevel > 3 )
              {
                snprintf(tempBufferForMessages, 0x800u, "core %8d in asic %d not returned", currentWorkIndex, currentChain);
                logMessage(3, tempBufferForMessages, currentChainProcessedWork);
              }
              hasMissingWork = 1;
              ++currentChainId;
              iterationStatusFlag = 1;
            }
            ++currentWorkIndex;
            workStatusPointer += 2;
          }
          while ( currentWorkCount != currentWorkIndex );
          if ( hasMissingWork )
          {
            if ( (unsigned int)globalLogLevel > 3 )
            {
              snprintf(tempBufferForMessages, 0x800u, "reopen asic %d", currentChain);
              logMessage(3, tempBufferForMessages, 0);
            }
            initStatusCode = GetPulseCode();
            SendInitializationPulse((unsigned __int8)chainIndexCounter, currentChain * initStatusCode, 1);
            usleep(0x2710u);
            resetStatusCode = GetPulseCode();
            SendInitializationPulse((unsigned __int8)chainIndexCounter, currentChain * resetStatusCode, 0);
            usleep(0x2710u);
            setFrequencyStatusCode = GetPulseCode();
            ConfigureHashboardFrequency((unsigned __int8)chainIndexCounter, currentChain * setFrequencyStatusCode, hashboardInitCode, 0);
            UpdateChainStatus();
            setVoltageStatusCode = GetPulseCode();
            ConfigureHashboardVoltage((unsigned __int8)chainIndexCounter, currentChain * setVoltageStatusCode, SHIBYTE(hashboardInitCode), hashboardMinorCode, 0);
            restartStatusCode = GetPulseCode();
            SendRestartToHashboard((unsigned __int8)chainIndexCounter, currentChain * restartStatusCode);
            usleep(0x2710u);
            if ( (unsigned int)globalLogLevel > 3 )
            {
              snprintf(tempBufferForMessages, 0x800u, "reset clock asic %d", currentChain);
              logMessage(3, tempBufferForMessages, 0);
            }
            clockResetStatusCode = GetPulseCode();
            ResetHashboardClock((unsigned __int8)chainIndexCounter, currentChain * clockResetStatusCode, 0);
            clockSetStatusCode = GetPulseCode();
            ConfigureHashboardClock((unsigned __int8)chainIndexCounter, currentChain * clockSetStatusCode);
            usleep(0x186A0u);
            lastErrorCode = GetPulseCode();
            ResetHashboardClock((unsigned __int8)chainIndexCounter, currentChain * lastErrorCode, 1);
          }
        }
        ++currentChain;
      }
      while ( chainCounterCopy != currentChain );
      finishedChainsCounter = currentChainId;
      chainDataPointer = chainDataPointerCopy;
      if ( (unsigned int)globalLogLevel > 3 )
        goto LABEL_55;
LABEL_44:
      if ( finishedChainsCounter <= 155 )
      {
        currentChainIndex = chainIndexCounter;
        goto LABEL_51;
      }
      usleep((__useconds_t)&unk_F4240);
      if ( tempWorkCounter <= 1 )
        problematicChainIndex = iterationStatusFlag & 1;
      else
        problematicChainIndex = 0;
      if ( !problematicChainIndex )
      {
        currentChainIndex = chainIndexCounter;
        goto LABEL_3;
      }
    }
    if ( (unsigned int)globalLogLevel > 3 )
    {
      finishedChainsCounter = 0;
      iterationStatusFlag = 0;
LABEL_55:
      problematicChainFlag = tempWorkCounter++;
      snprintf(
        tempBufferForMessages,
        0x800u,
        "chain %d, bad core num %8d, rate = %.2f ========================round %d",
        chainIndexCounter,
        finishedChainsCounter,
        (float)((float)finishedChainsCounter / 12168.0),
        problematicChainFlag);
      logMessage(3, tempBufferForMessages, 0);
      goto LABEL_44;
    }
    currentChainIndex = chainIndexCounter;
    finishedChainsCounter = 0;
LABEL_51:
    if ( (unsigned int)globalLogLevel > 3 )
    {
      snprintf(tempBufferForMessages, 0x800u, "bad count is acceptable = %d", finishedChainsCounter);
      logMessage(3, tempBufferForMessages, 0);
    }
    usleep((__useconds_t)&unk_F4240);
LABEL_3:
    ++currentChainIndex;
    workEntryIndexCopy += 256;
  }
  while ( currentChainIndex != 4 );
  globalIterationStatusFlag = 0;
  FinalizeASICStatusArrays();
}
```