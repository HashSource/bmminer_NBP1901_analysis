```c
int __fastcall SendWorkToChain(int chainIndex)
{
  int sleepCount; // r7
  int chainBitMask; // r9
  int chainConfigOffset; // r4
  int bitmask; // r11
  int actualSleepCount; // r9
  _DWORD *chainWork; // r10
  char *workData; // r4
  int *workSrc; // r12
  int workTemp; // r0
  int workEntry; // r1
  char *workPtr; // lr
  int secondWorkEntry; // r2
  int thirdWorkEntry; // r3
  int jobIndex; // r5
  int jobSelector; // r0
  _DWORD *jobBasePtr; // r6
  int jobData; // r1
  int sleepCounter; // r9
  int jobValue; // r2
  _DWORD *jobOutPtr; // r12
  int jobEntryVal1; // r1
  int jobEntryVal2; // r2
  int jobEntryVal3; // r3
  char *jobBufferPtr; // r7
  _DWORD *chainJobPtr; // lr
  _DWORD *submitJobPtr; // lr
  int val1; // r1
  int val2; // r2
  int val3; // r3
  char *submitJobBuffer; // lr
  int workVal1; // r1
  int workVal2; // r2
  int workVal3; // r3
  bool isLastChain; // zf
  unsigned int jobCount; // r4
  int fourJobIndex; // r5
  int thirdJobEntry; // r3
  int someVariable; // r1
  _DWORD *workSubmitPtr; // r3
  int innerJobData; // r1
  int submitJobIndex; // lr
  int prepareWorkJob; // r0
  int thirdJobValue; // r2
  int submitWorkJob; // r0
  int submitJobValue; // r1
  int thirdSubmitJobIndex; // lr
  int doSubmitJobWork; // r0
  int startSubmitJob; // r0
  int startJobValue; // r1
  int workValue; // r3
  int jobBuffer[33]; // [sp+0h] [bp-9D0h] BYREF
  int *debugLogLevel; // [sp+88h] [bp-948h]
  _DWORD *jobBase; // [sp+8Ch] [bp-944h]
  int v55; // [sp+90h] [bp-940h]
  int jobBitMask; // [sp+94h] [bp-93Ch]
  _DWORD *chainWorkStart; // [sp+98h] [bp-938h]
  int v58; // [sp+9Ch] [bp-934h]
  int v59; // [sp+A0h] [bp-930h]
  int v60; // [sp+A4h] [bp-92Ch]
  int v61; // [sp+A8h] [bp-928h]
  _DWORD *actualChainWork; // [sp+ACh] [bp-924h]
  int v63; // [sp+B0h] [bp-920h]
  _DWORD *chainJobStart; // [sp+B4h] [bp-91Ch]
  int v65; // [sp+B8h] [bp-918h]
  int v66; // [sp+BCh] [bp-914h]
  int chainCount; // [sp+C0h] [bp-910h]
  int bitmaskCopy; // [sp+C4h] [bp-90Ch]
  void *workPointer; // [sp+C8h] [bp-908h]
  int *logLevelGlobal; // [sp+CCh] [bp-904h]
  __time_t startTimers[2]; // [sp+D0h] [bp-900h] BYREF
  __time_t endTimers[2]; // [sp+D8h] [bp-8F8h] BYREF
  char startTimerBuffer[20]; // [sp+E0h] [bp-8F0h] BYREF
  int v74; // [sp+F4h] [bp-8DCh]
  int v75; // [sp+F8h] [bp-8D8h]
  int v76; // [sp+FCh] [bp-8D4h]
  int v77; // [sp+100h] [bp-8D0h]
  int v78; // [sp+104h] [bp-8CCh]
  int v79; // [sp+108h] [bp-8C8h]
  int v80; // [sp+10Ch] [bp-8C4h]
  int v81; // [sp+110h] [bp-8C0h] BYREF
  _BYTE submitBuffer[148]; // [sp+114h] [bp-8BCh] BYREF
  char debugBuffer[2088]; // [sp+1A8h] [bp-828h] BYREF

  chainCount = chainIndex;
  logLevelGlobal = &globalLogLevel;
  sub_302A0(startTimers);
  if ( (unsigned int)globalLogLevel <= 3 || (strcpy(debugBuffer, "\n"), sub_2EA54(3, debugBuffer, 0), (unsigned int)*logLevelGlobal <= 3) )
  {
    bitmaskCopy = sub_1E0F0();
    if ( !bitmaskCopy )
    {
      goto FinishWork;
    }
  }
  else
  {
    snprintf(debugBuffer, 0x800u, ">>>> Send work for chain %d.\n", chainIndex);
    logMessage(3, debugBuffer, 0);
    bitmaskCopy = sub_1E0F0();
    if ( !bitmaskCopy )
    {
      goto FinishWork;
    }
  }

  // Initialization
  sleepCount = 0;
  jobBitMask = 0;
  chainCount = 0;
  workPointer = &unk_202A2A;
  chainJobStart = &dword_80ACAC[1664 * chainIndex];
  chainBitMask = 1 << chainIndex;

  do
  {
    chainConfigOffset = *(_DWORD *)(dword_4FCB38 + 4 * ((_DWORD)workPointer + chainCount) + 4);
    v65 = sub_1E130();
    if ( v65 )
    {
      bitmask = chainBitMask;
      actualSleepCount = sleepCount;
      actualChainWork = (_DWORD *)(chainConfigOffset + 20);
      v61 = 0;
      v63 = (unsigned __int8)~((unsigned int)~(chainIndex << 25) >> 25);
      do
      {
        chainWork = actualChainWork;
        v60 = v61 & 3;
        v55 = 0;
        do
        {
          while ( (bitmask & sub_44ED4()) == 0 )
          {
            ++actualSleepCount;
            usleep(0x3E8u);
          }
          workData = startTimerBuffer;
          workSrc = chainWork - 5;
          jobBase = chainWork - 5;
          do
          {
            workTemp = *workSrc;
            workSrc += 4;
            workEntry = *(workSrc - 3);
            workPtr = workData;
            secondWorkEntry = *(workSrc - 2);
            workData += 16;
            thirdWorkEntry = *(workSrc - 1);
            *(_DWORD *)workPtr = workTemp;
            *((_DWORD *)workPtr + 1) = workEntry;
            *((_DWORD *)workPtr + 2) = secondWorkEntry;
            *((_DWORD *)workPtr + 3) = thirdWorkEntry;
          }
          while ( workSrc != chainWork + 7 );
          jobIndex = 0;
          *(_DWORD *)workData = *workSrc;
          memset(&submitBuffer[2], 0, 0x92u);
          jobSelector = *(chainWork - 3);
          v59 = actualSleepCount;
          jobBasePtr = &chainJobStart[13 * jobBitMask];
          jobData = *(chainWork - 2);
          sleepCounter = chainBitMask;
          submitBuffer[1] = v63;
          jobValue = *(chainWork - 1);
          LOBYTE(v74) = v74 + 1;
          *(_DWORD *)&submitBuffer[8] = jobSelector;
          *(_DWORD *)&submitBuffer[12] = jobData;
          *(_DWORD *)&submitBuffer[16] = jobValue;
          debugLogLevel = &v81;
          v58 = bitmask;
          *(_DWORD *)&submitBuffer[4] = jobBitMask & 0x7F | v55;
          chainWorkStart = jobBase + 12;
          submitBuffer[0] = 1;
          do
          {
            jobOutPtr = (_DWORD *)((char *)jobBasePtr + dword_4FCB38);
            if ( jobIndex == v60 )
            {
              workSubmitPtr = &submitBuffer[32 * jobIndex + 20];
              innerJobData = chainWork[1];
              submitJobIndex = chainWork[2];
              *workSubmitPtr = *chainWork;
              prepareWorkJob = chainWork[3];
              thirdJobValue = (int)jobBase;
              workSubmitPtr[1] = innerJobData;
              workSubmitPtr[3] = prepareWorkJob;
              submitWorkJob = chainWork[4];
              workSubmitPtr[2] = submitJobIndex;
              submitJobValue = chainWork[5];
              thirdSubmitJobIndex = chainWork[6];
              workSubmitPtr[4] = submitWorkJob;
              doSubmitJobWork = chainWork[7];
              workSubmitPtr[5] = submitJobValue;
              workSubmitPtr[6] = thirdSubmitJobIndex;
              workSubmitPtr[7] = doSubmitJobWork;
              do
              {
                thirdJobEntry += 16;
                jobOutPtr += 4;
                startJobValue = *(_DWORD *)(thirdJobEntry - 12);
                someVariable = *(_DWORD *)(thirdJobEntry - 8);
                workValue = *(_DWORD *)(thirdJobEntry - 4);
                isLastChain = thirdJobEntry == (_DWORD)chainWorkStart;
                *(jobOutPtr - 4) = *(_DWORD *)(thirdJobEntry - 16);
                *(jobOutPtr - 3) = startJobValue;
                *(jobOutPtr - 2) = someVariable;
                *(jobOutPtr - 1) = workValue;
              }
              while ( !isLastChain );
              *jobOutPtr = *chainWorkStart;
            }
            else
            {
              jobEntryVal1 = v75;
              jobEntryVal2 = v76;
              jobEntryVal3 = v77;
              jobBufferPtr = startTimerBuffer;
              chainJobPtr = &submitBuffer[32 * jobIndex + 20];
              *chainJobPtr = v74;
              chainJobPtr[1] = jobEntryVal1;
              chainJobPtr[2] = jobEntryVal2;
              chainJobPtr[3] = jobEntryVal3;
              submitJobPtr = &submitBuffer[32 * jobIndex + 36];
              val1 = v79;
              val2 = v80;
              val3 = v81;
              *submitJobPtr = v78;
              submitJobPtr[1] = val1;
              submitJobPtr[2] = val2;
              submitJobPtr[3] = val3;
              do
              {
                submitJobBuffer = jobBufferPtr;
                jobBufferPtr += 16;
                jobOutPtr += 4;
                workVal1 = *((_DWORD *)submitJobBuffer + 1);
                workVal2 = *((_DWORD *)submitJobBuffer + 2);
                workVal3 = *((_DWORD *)submitJobBuffer + 3);
                isLastChain = submitJobBuffer + 16 == (char *)debugLogLevel;
                *(jobOutPtr - 4) = *(_DWORD *)submitJobBuffer;
                *(jobOutPtr - 3) = workVal1;
                *(jobOutPtr - 2) = workVal2;
                *(jobOutPtr - 1) = workVal3;
              }
              while ( !isLastChain );
              *jobOutPtr = *(_DWORD *)jobBufferPtr;
            }
            ++jobIndex;
            jobBasePtr += 13;
          }
          while ( jobIndex != 4 );
          bitmask = v58;
          chainWork += 13;
          jobCount = jobBitMask + 4;
          actualSleepCount = v59;
          memcpy(jobBuffer, &submitBuffer[16], sizeof(jobBuffer));
          fourJobIndex = v55 + 128;
          v55 += 128;
          sub_1EEB8(
            *(unsigned int *)submitBuffer,
            *(int *)&submitBuffer[4],
            *(int *)&submitBuffer[8],
            *(int *)&submitBuffer[12],
            jobBuffer[0],
            jobBuffer[1],
            jobBuffer[2],
            jobBuffer[3],
            jobBuffer[4],
            jobBuffer[5],
            jobBuffer[6],
            jobBuffer[7],
            jobBuffer[8],
            jobBuffer[9],
            jobBuffer[10],
            jobBuffer[11],
            jobBuffer[12],
            jobBuffer[13],
            jobBuffer[14],
            jobBuffer[15],
            jobBuffer[16],
            jobBuffer[17],
            jobBuffer[18],
            jobBuffer[19],
            jobBuffer[20],
            jobBuffer[21],
            jobBuffer[22],
            jobBuffer[23],
            jobBuffer[24],
            jobBuffer[25],
            jobBuffer[26],
            jobBuffer[27],
            jobBuffer[28]);
          if ( jobCount >= 0x80 )
            thirdJobEntry = 0;
          else
            thirdJobEntry = jobCount;
          jobBitMask = thirdJobEntry;
        }
        while ( fourJobIndex != 1024 );
        actualChainWork += 104;
        ++v61;
      }
      while ( v65 != v61 );
      sleepCount = actualSleepCount;
      chainBitMask = bitmask;
    }
    isLastChain = bitmaskCopy == ++chainCount;
  }
  while ( !isLastChain );

FinishWork:
  sub_302A0(endTimers);
  someVariable = endTimers[0] - startTimers[0];
  if ( endTimers[1] - startTimers[1] < 0 )
    --someVariable;
  if ( (unsigned int)*logLevelGlobal > 3 )
  {
    snprintf(debugBuffer, 0x800u, "Send work for chain %d done, time cost %lds, sleep_count = %d\n", chainIndex, someVariable, sleepCount);
    logMessage(3, debugBuffer, 0);
  }
  return 0;
}
```