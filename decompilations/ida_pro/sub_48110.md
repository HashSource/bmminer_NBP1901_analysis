```c
int __fastcall pic_read_iic(unsigned int chain_id, int slave_address, int command, void *destination, int read_length)
{
  int ret_val;
  int select_slave_ret;
  int mutex_lock_ret;
  int corrected_length;
  const char *error_msg;
  __int16 check_sum;
  int byte_number;
  unsigned int sum;
  int write_data[3]; // stored in stack, hence the [sp+10h] notation
  char read_command;
  char read_length_byte;
  char checksum_low_byte;
  char checksum_high_byte;
  int read_status; // stores the result of the read operation
  int bytes_to_read[4]; // temp buffer for data
  __int16 unknown_short; // used for checksum calculations
  char buffer[2048]; // for error and debug messages

  if ( chain_id > 0xF )
  {
    snprintf(buffer, 0x800, "%s: Bad pic param, input chain is %d\n", "pic_read_iic", chain_id);
    corrected_length = -2147483135; // Specific error code
    logMessage(0, buffer, 0);
    return corrected_length;
  }
  if ( !chain_is_open[2 * chain_id + 1] )
  {
    corrected_length = establish_pic_connection(chain_id);
    if ( corrected_length < 0 )
    {
      snprintf(buffer, 0x800, "%s: auto exec open_pic, but chain %d open eeprom failed\n", "pic_read_iic", chain_id);
      logMessage(0, buffer, 0);
      return corrected_length;
    }
  }
  ret_val = 0;
  select_slave_ret = select_iic_slave(chain_interface[2 * chain_id], slave_address, command, 0, 0);
  if ( select_slave_ret >= 0 )
  {
    usleep(10000); // 0x2710 in microseconds
    mutex_lock_ret = chain_interface[2 * chain_id];
    pthread_mutex_lock(&iic_mutex);
    if ( read_length >= 16 )
      corrected_length = 16;
    else
      corrected_length = read_length;
    read_length_byte = corrected_length;
    checksum_low_byte = corrected_length + 66 + slave_address;
    read_status = 0;
    read_command = slave_address;
    memset(bytes_to_read, 0, sizeof(bytes_to_read));
    checksum_high_byte = (unsigned __int16)(corrected_length + 66 + slave_address) >> 8;
    unknown_short = 0;
    write_data[2] = 1007069781;
    if ( pic_iic_write(mutex_lock_ret, (int)&write_data, 8) == 8 )
    {
      usleep(10000); // Wait again
      if ( corrected_length + 5 == pic_iic_read(mutex_lock_ret, &read_status, corrected_length + 5) )
      {
        check_sum = (unsigned __int8)read_status;
        if ( corrected_length + 5 == (unsigned __int8)read_status && BYTE1(read_status) == 60 && BYTE2(read_status) == 1 )
        {
          byte_number = corrected_length + 3;
          sum = 0;
          if ( corrected_length + 3 > 0 )
          {
            while ( 1 )
            {
              ret_val = (unsigned __int16)(ret_val + 1);
              sum = (unsigned __int16)(sum + check_sum);
              if ( ret_val >= byte_number )
                break;
              check_sum = *((unsigned __int8 *)&bytes_to_read[-1] + ret_val);
            }
            ret_val = sum >> 8;
          }
          if ( *((unsigned __int8 *)&bytes_to_read[-1] + byte_number) == ret_val && *((unsigned __int8 *)bytes_to_read + corrected_length) == (unsigned __int8)sum )
          {
            memcpy(destination, (char *)&read_status + 3, corrected_length);
          }
          else
          {
            snprintf(buffer, 0x800, "%s failed 2!\n", "pic_read_iic");
            corrected_length = 0;
            logMessage(0, buffer, 0);
          }
        }
        else
        {
          corrected_length = 0;
          snprintf(
            buffer,
            0x800,
            "%s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x, read_back_data[2] = 0x%02x\n\n",
            "pic_read_iic",
            (unsigned __int8)read_status,
            BYTE1(read_status),
            BYTE2(read_status));
          logMessage(0, buffer, 0);
        }
        goto LABEL_UNLOCK_MUTEX;
      }
      error_msg = "%s read iic err\n";
    }
    else
    {
      error_msg = "%s write iic err\n";
    }
    corrected_length = 0;
    snprintf(buffer, 0x800, error_msg, "pic_read_iic");
    logMessage(0, buffer, 0);
LABEL_UNLOCK_MUTEX:
    pthread_mutex_unlock(&iic_mutex);
    return corrected_length;
  }
  snprintf(buffer, 0x800, "%s: select slave: 0x%02x, reg/command: 0x%02x is failed", "pic_read_iic", slave_address, command);
  logMessage(0, buffer, 0);
  return select_slave_ret;
}
```