```c
int __fastcall checkIfStopNeeded(int chainIndex)
{
  float hwThreshold; // s0
  float nonceRateThreshold; // s1
  float nonceRateDecreaseThreshold; // s2
  int hwErrorDataAddress; // r8
  int hwErrorDataMultiplier; // r9
  int v7; // r5
  int totalChips; // r5
  unsigned int nonceCount; // s16
  int v11; // r5
  int calculationFactor; // r0
  int chainSpecificDataOffset; // r9
  unsigned int logLevel; // r3
  float currentNonceRate; // s13
  float lastNonceRate; // s12
  float maxNonceRate; // s14
  char logBuffer[2096]; // [sp+18h] [bp-830h] BYREF

  hwErrorDataAddress = getHWErrorDataAddress();
  if ( globalLogLevel > DEBUG )
  {
    snprintf(
      logBuffer,
      0x800u,
      "[DEBUG] Check if is need stop, chain = %d, hw_threshold = %.4f, nonce_rate_threshold = %.2f, nonce_rate_dec_threshold = %.2f.\n",
      chainIndex,
      hwThreshold,
      nonceRateThreshold,
      nonceRateDecreaseThreshold);
    logMessage(DEBUG, logBuffer, 0);
  }
  if ( hwErrorDataStartAddr && *(_DWORD *)(hwErrorDataStartAddr + 4) )
  {
    hwErrorDataMultiplier = 4 * chainIndex;
    v7 = 8 * getCalculationFactorOne();
    totalChips = getCalculationFactorTwo() * v7;
    if ( *(_DWORD *)(hwErrorDataAddress + 4 * chainIndex + 8431696) > (unsigned int)(float)((float)totalChips * hwThreshold) )
    {
      if ( globalLogLevel > INFO )
      {
        snprintf(
          logBuffer,
          0x800u,
          "chain = %d, hw = %d, hw_threshold = %d, too much hw.\n",
          chainIndex,
          *(_DWORD *)(hwErrorDataAddress + hwErrorDataMultiplier + 8431696),
          (unsigned int)(float)((float)totalChips * hwThreshold));
        logMessage(INFO, logBuffer, 0);
      }
      return 1;
    }
    nonceCount = *(_DWORD *)(hwErrorDataAddress + 4 * chainIndex + 8429568);
    v11 = 8 * getCalculationFactorOne();
    calculationFactor = getCalculationFactorTwo();
    chainSpecificDataOffset = hwErrorDataStartAddr + hwErrorDataMultiplier;
    logLevel = globalLogLevel;
    currentNonceRate = *(float *)(chainSpecificDataOffset + 48);
    lastNonceRate = *(float *)(chainSpecificDataOffset + 32);
    maxNonceRate = (float)nonceCount / (float)(calculationFactor * v11);
    *(float *)(chainSpecificDataOffset + 32) = maxNonceRate;
    if ( currentNonceRate < maxNonceRate )
      *(float *)(chainSpecificDataOffset + 48) = maxNonceRate;
    if ( logLevel > INFO )
    {
      snprintf(
        logBuffer,
        0x800u,
        "chain = %d, nonce_rate_curr = %.4f, nonce_rate_last = %.4f, nonce_rate_max = %.4f\n",
        chainIndex,
        maxNonceRate,
        lastNonceRate,
        *(float *)(chainSpecificDataOffset + 48));
      logMessage(INFO, logBuffer, 0);
    }
    return 0;
  }
  else
  {
    if ( globalLogLevel <= INFO )
      return 1;
    strcpy(logBuffer, "Handle is NULL.\n");
    logMessage(INFO, logBuffer, 0);
    return 1;
  }
}
```