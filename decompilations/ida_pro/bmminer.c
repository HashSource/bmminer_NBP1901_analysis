/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

int init_proc();
// int pthread_mutex_unlock(pthread_mutex_t *mutex);
// void *calloc(size_t nmemb, size_t size);
// char *strstr(const char *haystack, const char *needle);
// int fsync(int fd);
// int strcmp(const char *s1, const char *s2);
// int strtol(const char *nptr, char **endptr, int base);
// int printf(const char *format, ...);
// ssize_t read(int fd, void *buf, size_t nbytes);
// int pthread_mutex_destroy(pthread_mutex_t *mutex);
// int fflush(FILE *stream);
// void free(void *ptr);
// char *fgets(char *s, int n, FILE *stream);
// int pthread_mutex_lock(pthread_mutex_t *mutex);
// int pthread_detach(pthread_t th);
// void *memcpy(void *dest, const void *src, size_t n);
// int __fastcall mmap64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);
// time_t time(time_t *timer);
// int IO_getc(_IO_FILE *fp);
// int memcmp(const void *s1, const void *s2, size_t n);
// int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize);
// unsigned int sleep(unsigned int seconds);
// int __fastcall stpcpy(_DWORD, _DWORD); weak
// int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
// int pthread_setcancelstate(int state, int *oldstate);
// int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
// int pthread_key_create(pthread_key_t *key, void (*destr_function)(void *));
// void *realloc(void *ptr, size_t size);
// struct tm *localtime_r(const time_t *timer, struct tm *tp);
// int pthread_cond_destroy(pthread_cond_t *cond);
// int strcasecmp(const char *s1, const char *s2);
// void perror(const char *s);
// int accept(int fd, struct sockaddr *addr, socklen_t *addr_len);
// int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int usleep(__useconds_t useconds);
// char *strcpy(char *dest, const char *src);
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// int pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
// int __fastcall open64(_DWORD); weak
// char *getenv(const char *name);
// int puts(const char *s);
// int sysinfo(struct sysinfo *info);
// void *malloc(size_t size);
// char *strerror(int errnum);
// size_t strftime(char *s, size_t maxsize, const char *format, const struct tm *tp);
// struct tm *localtime(const time_t *timer);
// const unsigned __int16 **_ctype_b_loc(void);
// __pid_t getpid(void);
// unsigned int strtoul(const char *nptr, char **endptr, int base);
// size_t strlen(const char *s);
// int round(void); weak
// char *strchr(const char *s, int c);
// int fprintf(FILE *stream, const char *format, ...);
// double sqrt(double x);
// int pthread_attr_init(pthread_attr_t *attr);
// int *_errno_location(void);
// int strncasecmp(const char *s1, const char *s2, size_t n);
// int snprintf(char *s, size_t maxlen, const char *format, ...);
int __fastcall j___cxa_atexit(void (__fastcall *lpfunc)(void *), void *obj, void *lpdso_handle);
// int __fastcall _cxa_atexit(void (__fastcall *lpfunc)(void *), void *obj, void *lpdso_handle);
// int _isoc99_sscanf(_DWORD, const char *, ...); weak
// char *_strdup(const char *s);
// int bind(int fd, const struct sockaddr *addr, socklen_t len);
// int sem_init(sem_t *sem, int pshared, unsigned int value);
// void *memset(void *s, int c, size_t n);
// int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);
// char *strncpy(char *dest, const char *src, size_t n);
// int prctl(int option, ...);
// ssize_t write(int fd, const void *buf, size_t n);
// int fileno(FILE *stream);
// int fclose(FILE *stream);
// int munmap(void *addr, size_t len);
// char *strtok(char *s, const char *delim);
// int pthread_setspecific(pthread_key_t key, const void *pointer);
// int sigemptyset(sigset_t *set);
// FILE *popen(const char *command, const char *modes);
// int listen(int fd, int n);
// int vfprintf(FILE *s, const char *format, __gnuc_va_list arg);
// int fputc(int c, FILE *stream);
// void syslog(int pri, const char *fmt, ...);
// int sprintf(char *s, const char *format, ...);
// int __fastcall fopen64(_DWORD, _DWORD); weak
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// int socket(int domain, int type, int protocol);
// void pthread_testcancel(void);
// int fseek(FILE *stream, int off, int whence);
// int sem_destroy(sem_t *sem);
// int __fastcall _xstat64(_DWORD, _DWORD, _DWORD); weak
// int isatty(int fd);
// int strncmp(const char *s1, const char *s2, size_t n);
// int close(int fd);
// int __fastcall _lxstat64(_DWORD, _DWORD, _DWORD); weak
// void _assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// void *pthread_getspecific(pthread_key_t key);
// int pclose(FILE *stream);
int __fastcall main(int, char **, char **); // idb
int check_and_initialize_gmon();
int __fastcall updateFanSpeeds(unsigned int thresholdSpeed);
int __fastcall checkFanStatus(unsigned int fanFlag, int checkContinuous);
int __fastcall setFanPWM(int desired_pwm_value);
int checkFrontFanStatus();
int turnOffFrontFan();
int turnOnRearFan();
int powerOffRearFan();
int __fastcall configure_asic(int, int, int, int, unsigned __int8 *);
int check_miner_status();
int __fastcall readTemperatureSensor(int chainId, int sensorIndex, unsigned int sensorType, int sensorModel);
int __fastcall configureTemperatureSensor(int chainIndex);
int update_miner_calibration();
int initTemperatureMonitoring();
int check_and_log_temperature_uninitialized();
int __fastcall calibrateTemperatureSensors(int calibrationValue);
int __fastcall get_board_temperature(int, int);
int __fastcall calculate_temperature_adjustment(int, int);
int get_maximum_temperature();
int get_highest_temperature();
int __fastcall get_device_min_temperature(int);
int get_minimum_temp();
int __fastcall get_corrected_temperature_value(int, int);
int monitorTemperatureThread();
void initialize_miner_status();
void reset_global_counter();
int InitializeChainConfigurations();
int __fastcall logNoChipBinError(int);
int __fastcall logNoVersionError(int chainIndex);
char *__fastcall PrintBufferFormatted(char *chainIdentifier, int buffer, unsigned int bufferSize);
int __fastcall readAndDecodeChainConfig(unsigned int chainIndex, int configArrayPtr);
void check_and_initialize_chain_config();
int get_global_chain_config_byte();
int check_all_chains_ready();
size_t __fastcall GetChainSerialNumber(size_t chainIndex, char *serialNumberBuffer, size_t bufferLength);
int __fastcall getPCBVersionForChain(int chainIndex);
int __fastcall getChainBomVersion(int chainIndex);
int __fastcall getChainTemperature(int chainIndex, _DWORD *temperature);
int __fastcall getChainTestStandard(int chainIndex, _DWORD *testStandardOut);
int __fastcall get_chain_voltage(int, _DWORD *);
int __fastcall get_chain_version_string(int, char *, size_t);
int __fastcall setOptimalFrequency(int chainIndex, int mode, int *optimalFreq);
int __fastcall getVoltageLevel(int chainIndex, int modeIndex, int *voltageLevelOutput);
int __fastcall GetHashRateForMode(int chainIndex, int modeIndex, _DWORD *pHashRate);
int __fastcall setWorkModeConfiguration(int chainIndex, int workMode, int configPtr);
int logXXteaAlignmentError();
char *__fastcall process_eeprom_write(char *result, char, int);
int __fastcall decrypt_xxtea(int result, int a2, int a3);
int __fastcall relay_control(unsigned int);
int __fastcall forward_to_handler_46900(unsigned int);
bool __fastcall is_success_response(unsigned int);
int __fastcall initiatePICJumpToAppAndVerifyFirmware(int chainIndex);
int __fastcall readASICVoltage(int chainIndex);
int get_minimal_voltage();
unsigned int wait_one_second();
int MonitorFrequencyStability();
int __fastcall SetVoltageBySteps(int voltageStep);
int __fastcall ValidatePowerVoltage(int targetVoltage);
int get_global_flag();
int calculate_percentage();
int __fastcall compare_temperature_values(int, int);
int __fastcall compare_priority(int, int);
int __fastcall compare_values(_DWORD *, _DWORD *);
unsigned int *__fastcall calculate_min_max_total(unsigned int *, unsigned int *, unsigned int *, _DWORD *);
int __fastcall calculate_hash_rate(int);
int calculate_max_hash_rate();
int calculate_ideal_hash_rate();
int find_optimal_hash_rate();
int sub_1A2D8();
int __fastcall get_chain_frequency(int result);
void do_nothing_function();
void __fastcall configureASICClock(int chain_id, unsigned int freq, int higher_voltage_flag);
int __fastcall SetFrequencyStep(unsigned int testMode, unsigned int freqStart, unsigned int freqEnd);
int __fastcall SetChainFrequency(int chainIndex, unsigned int baseFrequency, unsigned int targetFrequency, char *stepFrequency, char isHigherVoltage);
unsigned int __fastcall setChipFrequencies(int control_board_address, unsigned int default_frequency, int mining_algorithm);
int __fastcall setChainFrequency(int chainIndex, unsigned int command, int freqMHz);
int initializeGlobalBuffers();
int sub_1B4AC();
int get_shared_variable();
int get_global_state_value();
int get_global_variable_value();
int get_global_value();
int get_miner_status_flag();
int get_shared_value();
int sub_1E140();
int get_embedded_system_status();
int sub_1E160();
int get_global_status();
int __fastcall get_control_status(int);
int sub_1E19C();
int __fastcall get_miner_temperature(int);
int __fastcall set_chain_status(unsigned int, int);
int get_status_flag();
int __fastcall get_global_buffer_value(int);
int initialize_global_variable();
int perform_hardware_reset();
int get_global_fan_count();
int get_active_fan_count();
int __fastcall sub_1E3D4(unsigned int, int);
int __fastcall get_fan_speed(unsigned int);
int __fastcall set_status_led_state(char);
int sub_1E4B0();
int __fastcall set_chain_buffer_timestamp(unsigned int);
int __fastcall get_chain_data_status(unsigned int);
int __fastcall process_chain_request(unsigned int);
int __fastcall set_chain_config_byte(unsigned int, int, char);
int __fastcall is_id_in_list(int);
int __fastcall scan_chip_versions(unsigned int);
int __fastcall check_global_buffer_and_process(unsigned int);
int set_uart_relay_based_on_state();
int __fastcall set_config_for_miner(int, int, char, char);
int __fastcall prepare_hash_input(unsigned int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int);
int __fastcall process_command_for_global_buffer(int, char, char, char);
int __fastcall calculate_hashrate_ratio(int, int);
int __fastcall process_command(int, int, unsigned int, unsigned int);
int __fastcall trigger_asic_operations(int, int, unsigned int, unsigned int, int, __int16);
int __fastcall check_global_buffers_and_process(int, int);
int __fastcall updateMinerChainNumber(int jsonResult);
int __fastcall updateFanSpeeds_0(int minerConfiguration);
int __fastcall updateMinerChainFrequency(int minerChain, unsigned int frequencyIndex);
int __fastcall updateMinerChainIdealRate(int minerChainStatusPtr, unsigned int chainIndex);
int __fastcall process_temperature_control(int result, unsigned int);
char __fastcall update_status_flag(char result);
char __fastcall set_fan_control_mode(char result);
char __fastcall update_miner_status_led(char result);
int __fastcall process_block(_DWORD *, unsigned int *);
int *__fastcall finalize_sha256_state(int, _BYTE *);
int *__fastcall compute_sha256_hash(unsigned int *, signed int, _BYTE *);
int __fastcall get_mining_status_description(char *, size_t, int);
int __fastcall processMinerCommand(const char *commandStr, char *responseBuffer, size_t responseBufferSize);
void *initialize_serial_number_and_command_processor();
int __fastcall handle_http_request(int);
int initializeHttpServer();
int startHttpLog();
void __noreturn MonitorASICHeartbeat();
int get_system_uptime();
int calculate_mining_effectiveness();
int calculate_hashrate_and_log();
int manage_miner_operations();
int __fastcall dump_frequency_nonce_info(int, int);
int __fastcall calculate_standard_deviation(int, int);
int adjust_frequency_and_voltage();
int optimize_frequency_tuning();
int initialize_asic_monitor_thread();
int initialize_nonce_registration_thread();
int initialize_monitor_thread();
int init_monitor_thread();
int initialize_miner_thread();
void cancel_mining_thread();
void cancel_thread_if_needed();
void terminate_worker_thread();
int __fastcall setUartBaudRate(signed int baudRate);
int initialize_uart_and_check_status();
int initialize_miner_socket();
void __noreturn fatal_error_logging(const char *, ...);
int update_api_statistics();
void __noreturn shutdown_miner_and_exit();
int __fastcall log_mutex_init_failure(const char *, int);
int __fastcall initialize_sync_primitives(int, const char *, int);
_DWORD *create_work_structure();
void load_default_miner_config();
void *__fastcall setMiningTarget(void *minerConfig);
__int64 __fastcall generateWork(int minerAddr, int workAddr);
void __fastcall clear_and_log_miner_info(void ***, const char *, const char *, int);
int __fastcall update_nonce_and_generate_work(int *, int *, int, int, __int64, unsigned int);
int __fastcall increment_hardware_errors(int);
void nullsub_1();
int updateMinerUptime();
int readMinerVersionAndSerialNumber();
int __fastcall submit_nonce_to_miner(int, const char **, int, char);
int initialize_bitmain_primary();
int __fastcall parseJobBuffer(_DWORD *jobBufDst, int jobBufSrc, int jobBufLen);
int __fastcall process_job_update(const void *, unsigned int);
void __fastcall processCommandLineArguments(int argc, const char **argv);
int wait_for_semaphore();
int reset_statistics();
int __fastcall process_chain_events(int, int);
int __fastcall ReadASICRegister(int reg, int chip, int chain);
int __fastcall handleASICCommand(int commandType, int commandValue, int chainId, int outputBuffer);
int dump_asic_nonce_count();
int __fastcall sub_2CD30(int, unsigned int);
int __fastcall get_asic_register_value(unsigned int, unsigned int);
int dump_nonce_count();
int dump_nonce_info();
int __fastcall logMessage(int, const char *, int);
int __fastcall print_error_message_with_lock(const char *, const char *, int);
char *__fastcall append_log_message(int, const char *, int);
_DWORD *__fastcall copy_firmware_version(_DWORD *result);
void *__fastcall process_input_chunk(unsigned __int8 *, char *, size_t n);
int __fastcall hash_message(char *, size_t n, _BYTE *);
int initialize_miner_system();
void *__fastcall allocate_memory_logging(size_t, const char *, const char *, int);
void *__fastcall allocate_buffers_ignore_incomplete_words(size_t, size_t, const char *, const char *, int);
_BYTE *__fastcall convert_bin_to_hex_string(int, int);
void __fastcall cleanup_resource_list(char *);
__int64 __fastcall convert_timespec_to_custom_format(__time_t *);
int __fastcall sub_30314(_DWORD *, _DWORD *, int *);
int get_next_sleep_interval();
void *__fastcall get_time_difference(_DWORD *, _DWORD *);
int __fastcall create_thread_with_logging(int, const pthread_attr_t *, void *(*)(void *), void *);
void *__fastcall safe_memcpy_with_logging(void *result, const void *, size_t, int, int, int);
int __fastcall calculate_crc16_checksum(int, int);
int __fastcall calculate_error_check_code(_BYTE *, int);
int __fastcall reverse_copy_with_byte_swap(int result, unsigned int *, unsigned int);
int __fastcall logCapabilityInformation(int loggingContext);
unsigned int get_max_voltage_from_eeprom();
int log_fix_freq_version();
int powerOffHashboard();
int get_global_variable();
int get_antminer_status_code();
unsigned int __fastcall handle_error_with_logging(unsigned int result, const char *);
int check_chip_states();
void update_chip_frequencies();
int __fastcall update_miner_frequency(int result, int, int);
int logChainVersions();
int initialize_and_log_chain_status();
int check_and_configure_miner_gpio();
int update_miner_statistics();
int InitializeChains();
int getFirmwareVersionAndMinerID();
int initialize_and_update_uptime();
int __fastcall sendJobToMiner(unsigned __int8 *jobBuffer);
unsigned int configure_and_reboot_miner();
int __fastcall copy_pool_stratum_data(int result, int);
int configurePulseAndDelays();
int update_and_process_miner_status();
int initializeMiner();
int InitializeMinerHardware();
void InitializeASICChains();
int __fastcall initializeMinerHardware(int tokenType, int tokenParam1, int tokenParam2, int tokenParam3, int tokenParam4, int tokenParam5, int tokenParam6, int tokenParam7);
int AdjustMinerVoltage();
int setFanSpeedControl();
int __fastcall generate_error_message(int, int);
int checkNonceRateAgainstThreshold();
unsigned int __fastcall sub_35C04(int);
int __fastcall update_global_value(int result);
int get_miner_status_code();
int j_get_global_flag(); // idb
int set_voltage_to_default();
int check_sweep_done();
int __fastcall initialize_sweep(int);
int __fastcall sub_36558(int result);
int send_midstate_work();
int __fastcall updateNonceCounter(int chainIndex, int asicIndex, unsigned int nonce, int memoryBaseAddr);
bool __fastcall checkIfReadRegDone(int chainIndex);
bool check_all_chips_status();
int __fastcall initializeAndConfigureASIC(int maxFreqValue, int *logLevelPointer);
int __fastcall checkDomainBalance(int chainIndex);
int __fastcall SendWorkToChain(int chainIndex);
void free_device_resources();
int __fastcall load_core_pattern(FILE **, int, int, int);
int __fastcall loadPatternFile(int patternFilePath);
int sub_388F4();
int __fastcall send_work_for_hw_sweep(int result);
int __fastcall start_mining_threads(int result);
int __fastcall sub_38B6C(int, int);
int get_stats();
int __fastcall CheckUnqualifiedChain(int chainIndex);
int __fastcall verify_nonce_recv_enough(int);
int __fastcall update_chain_status(int result, int);
int __fastcall get_chain_status(int);
int clear_statistics();
int check_asics_status();
int clear_context();
int __fastcall checkIfStopNeeded(int chainIndex);
int checkAllChainPatternTestDone();
int __fastcall InitializeBoard(int is_power_off);
char *__fastcall log_miner_chain_stats(char *result, int);
int calculate_hashrate_multiplier();
int __fastcall perform_pattern_test(int result);
int check_and_set_default_voltage();
int __fastcall sub_3AEA0(int);
void logMinerSettings();
char *__fastcall performFrequencyTuning(int targetFrequency);
unsigned int __fastcall calculate_chain_frequency_average(int, int);
unsigned int __fastcall find_minimum_frequency(int, int);
unsigned int __fastcall calculate_maximum_frequency(int, int);
int __fastcall VerifyFrequencyThreshold(int chainIndex);
unsigned int __fastcall dump_frequency_table(int, int);
int performFineFrequencyTuning();
int __fastcall update_miner_status(int result, int);
bool __fastcall initialize_and_check_status(_DWORD *, const char **, void (*)(const char *, ...));
char *__fastcall memchr(char *result, __int16, unsigned int);
unsigned int __fastcall find_minimum_period(int, unsigned int, int *);
int __fastcall search_pattern_in_buffer(int, int, void *s1, unsigned int);
char *__fastcall memmem(char *, unsigned int, unsigned __int8 *, unsigned int);
void sub_3F92C();
int __fastcall calculate_average(int result, int);
int __fastcall calculate_average_temperature(int result, int);
unsigned int initializeHashOnPlug();
int sub_3FD74();
int is_system_ready();
int __fastcall get_error_code_sum(int);
int __fastcall get_total_error_count(int);
int initializeFpgaMemoryMappings();
int check_and_init_fpga();
int __fastcall read_register_value(int, _DWORD *);
int __fastcall set_register_value(int, int);
int __fastcall subtract_pointers(_DWORD *, _DWORD *);
int get_zero();
int __fastcall control_gpio(int, unsigned int);
int __fastcall readGPIOValue(int gpioNumber, _BYTE *gpioValue);
int monitor_gpio_changes();
int __fastcall set_gpio_value(int, int);
unsigned int __fastcall increment_param_check_initialized(unsigned int);
int __fastcall sub_4110C(int, unsigned int);
int __fastcall sub_411D0(int, int);
int __fastcall get_send_address_info(int, _DWORD *, int *, int *, int *);
int __fastcall clearUartTxFifo(int chainIndex);
int check_platform_initialization();
int check_and_reset_asic_state();
int initialize_miner_setting();
int *__fastcall process_command_result(int *result, int *);
int __fastcall query_mining_status(unsigned int);
int __fastcall reportUnsupportedGpioPort(int gpioPort);
int __fastcall configureGPIOControl(unsigned int gpioPort, int operationType);
int initialize_led_status();
int enable_gpio_control();
int configure_hashboard_reset_gpio();
int configure_fan_control_gpio();
int configure_gpio_control_for_miner();
int get_fixed_number();
int sub_4301C();
int *__fastcall sub_43290(int);
_DWORD *__fastcall allocate_and_init_struct(int, int, int);
int __fastcall process_miner_data(int *, const void *, size_t, const void *, size_t);
int *__fastcall check_and_update_status(int *result, int);
_DWORD *__fastcall find_list_node_by_value(int, _DWORD *);
int *__fastcall find_predecessor_in_tree(int *, int);
int __fastcall initiate_device_communication(unsigned int);
int __fastcall writeDataToEeprom(unsigned int chainIndex, unsigned __int8 startValue, int startAddress, int length);
int __fastcall readEepromData(unsigned int chainIndex, unsigned __int8 startAddress, int offset, int length);
int disable_asic_boost_mode();
unsigned int configure_antminer_protection();
int read_asic_version();
int __fastcall set_frequency(int);
int disable_hardware_watchdog();
int __fastcall set_fan_speed_by_percentage(__int16);
int enable_feature_flag();
int disable_register_protection();
int disable_asic_boost();
int disable_register_bit();
int __fastcall format_register_values(char *, size_t);
int __fastcall set_target_frequency(int);
int __fastcall set_and_read_reg_value(int);
int __fastcall configure_register_and_read_value(int);
int sub_44CB0();
int sub_44DFC();
int __fastcall write_and_read_register(int);
int __fastcall sub_44E64(int);
int __fastcall sub_44EAC(int);
int read_chip_version();
int __fastcall configure_hashing_cores(int, int, int);
int __fastcall sub_450BC(int);
int __fastcall set_register_values_from_array(int);
int __fastcall sub_45154(int);
int __fastcall read_dual_registers(int *);
int __fastcall configure_and_read_register(unsigned __int16);
int read_chip_id();
int __fastcall set_and_read_register_value(int);
int enable_register_bit();
int __fastcall sendJobToMiner_0(int jobData);
int __fastcall enable_miner_chip(char);
int __fastcall disable_bit_in_register(char);
int initialize_miner_configuration();
int read_control_register_value();
int __fastcall get_i2c_bus_handle(unsigned int);
int __fastcall get_pic_version(unsigned int);
int __fastcall reset_pic(unsigned int);
int __fastcall start_app_on_chain(unsigned int);
int __fastcall write_pic_i2c_data(int, __int16, __int16, int, int);
int __fastcall check_pic_i2c_connection(int);
int __fastcall dump_memory_data(unsigned __int8 *, int);
int __fastcall readVoltageFromPIC(unsigned int chainIndex, _DWORD *voltageValues, int voltageType);
int __fastcall writeToFlash(unsigned int chainIndex, __int16 command, __int16 subCommand, int dataArray, int dataSize);
int __fastcall readDataFromEEPROM(unsigned int chain_id, __int16 eeprom_addr_high, __int16 eeprom_addr_low, void *destination_buffer, int data_length);
int __fastcall upgradePIC(unsigned int chainIndex, const char *firmwarePath);
int __fastcall pic_read_iic(unsigned int chain_id, int slave_address, int command, void *destination, int read_length);
int __fastcall SendPowerCommandWithRetries(int a1, unsigned __int8 *a2, unsigned int a3, unsigned __int8 *responseBuffer, unsigned int responseLength);
int getPowerVersion();
int check_power_version();
int check_log_context_initialized();
int checkMinerPowerStatus();
int set_voltage_and_send_power_control();
int __fastcall ReadVoltageDacValue(__int16 chipID, int targetBuffer, int dataLength);
int __fastcall initiateI2CTransfer(int i2cTransactionParams);
int __fastcall i2c_write_with_mutex(int, _BYTE *, int);
int __fastcall i2c_transfer_with_lock(int, int, int);
int __fastcall perform_i2c_transaction(int, unsigned __int8 *, int, int, int);
int __fastcall i2c_transaction_wrapper(int, unsigned __int8 *, int, int, int);
int __fastcall compare_version_numbers(_DWORD *, _DWORD *);
int sub_49904();
int __fastcall handle_i2c_communication(int);
int __fastcall configure_i2c_device(int, int, int);
int __fastcall set_i2c_register(int, int);
int __fastcall compare_strings(const char **, const char **);
int __fastcall write_escaped_json_string(char *, int, int (__fastcall *)(char *, int, int), int, unsigned int);
int __fastcall write_padding(char, int, int, int (__fastcall *)(__int16 *, int, int), int);
int __fastcall process_address_and_add_task(int *, const void *, char *s);
int __fastcall serialize_json(_DWORD *, int, int, int *, int (__fastcall *)(__int16 *, int, int), int);
int __fastcall remove_named_task(_DWORD *, char *s);
int __fastcall get_next_element(int);
int __fastcall check_matching_values(int, int);
int __fastcall calculate_offset(int);
int __fastcall get_status_register(int);
int format_error_message(int result, _DWORD *, int, const char *, ...);
unsigned int __fastcall scan_json_token(_DWORD *, int);
_DWORD *__fastcall sub_4CDE4(int, int, int);
_DWORD *__fastcall update_miner_status_from_config(char *, int, char *);
int __fastcall check_and_process_result(int result);
int __fastcall check_and_perform_action(int result);
int __fastcall format_float_to_string(char *, size_t);
int __fastcall update_status_data(int);
_DWORD *__fastcall process_input_data(_BYTE *, size_t, int);
_DWORD *get_miner_status_and_init();
_DWORD *__fastcall get_error_or_success_code_pointer(_DWORD *result);
int __fastcall initiate_task_if_ready(_DWORD *, char *);
int __fastcall is_empty_and_get_next_element(_DWORD *);
int __fastcall is_value_nonzero_and_matches(_DWORD *, int);
int __fastcall check_and_calculate_offset(int);
int __fastcall get_status_if_non_zero(int);
_DWORD *get_asic_status();
_DWORD *__fastcall get_associated_pointer_or_null(_DWORD *result);
_DWORD *__fastcall get_task_by_index(_DWORD *result, unsigned int);
_DWORD *__fastcall parse_command(_BYTE *, size_t);
const char *__fastcall sanitize_utf8_string(const char *result);
_DWORD *__fastcall get_second_element_if_ready(_DWORD *result);
_DWORD *__fastcall get_config_address(_DWORD *result);
int __fastcall init_asic_task(__int64);
__int64 __fastcall get_hardware_status(int);
int process_double_value();
void sub_4EA70();
void *get_miner_hardware_info_pointer();
void *get_unk_7F578_address();
void *get_miner_config_pointer();
_DWORD *__fastcall handle_task(_DWORD *result);
int __fastcall add_task_if_possible(_DWORD *, char *, _DWORD *);
int __fastcall process_task_if_valid(_DWORD *, char *, _DWORD *);
int __fastcall add_to_buffer(_DWORD *, _DWORD *);
_DWORD *__fastcall handle_miner_commands(int);
int __fastcall forward_to_hardware_initialization(unsigned int); // idb
int __fastcall hash_board_command_send(int, int, char, char);
int __fastcall initialize_miner_with_parameters(unsigned int, int, unsigned __int16);
int __fastcall CalculateFrequencyDividers(int dividerConfigPtr, _BYTE *updateFlagPtr, float *calculatedFreqPtr);
int __fastcall initialize_mining_with_config(unsigned int, unsigned int, char);
int sub_508DC();
int __fastcall set_register_bit(unsigned int, unsigned int, int);
int __fastcall set_reset_chip_flag(unsigned int, int);
int __fastcall configure_asic_hashrate(unsigned int, unsigned int, int);
int __fastcall initialize_miner_with_delay(unsigned int, unsigned int);
int __fastcall init_asic(unsigned int, unsigned int, char);
int __fastcall initialize_miner_frequency_voltage(unsigned int, unsigned int);
int __fastcall enable_asic_boost_mode(unsigned int);
int __fastcall initialize_asics_with_parameters(unsigned int, int);
int __fastcall initialize_specific_asic_miner(unsigned int, char);
int __fastcall enable_chip_mining(unsigned int);
int __fastcall sub_51590(int);
int __fastcall send_reset_command_to_board(int);
int __fastcall initialize_mining_task(unsigned int, unsigned int, char, char);
int __fastcall initialize_miner_with_defaults(unsigned int, unsigned int, char, char, char);
int __fastcall sub_516F8(int, char);
int __fastcall init_asic_mining_with_params(unsigned int, unsigned int);
int __fastcall initialize_asic_with_frequency(unsigned int, unsigned int, int);
int get_invalid_return_value();
int return_minus_one();
int __fastcall initialize_chip_frequency(unsigned int, unsigned int, char);
unsigned int __fastcall get_high_byte(unsigned int);
int __fastcall get_voltage_status(int, unsigned int);
int __fastcall GetRegisterCacheValue(int cache_level, unsigned int chain_index, unsigned int asic_index, unsigned int register_address, _DWORD *cached_value);
int __fastcall setRegisterValue(int registerLevel, unsigned int chainIndex, unsigned int asicIndex, unsigned int registerAddress, int value);
int sub_52BD8();
void release_thread_specific_data();
int shutdown_miner_threads();
int __fastcall sub_52DCC(const char *);
int __fastcall initialize_logging(const char *);
int __fastcall reload_zlog_configuration(const char *);
int shutdown_logging_system();
_DWORD *__fastcall get_logging_category(const char *);
int check_zlog_initialization();
int __fastcall log_to_miner(int result, int, int, int, int, int, int, int);
int __fastcall log_message_to_system(int result, int, int, int, int, int, int, int);
int log_event(int result, const char *, int, int, int, int, int, int, ...);
int process_log_message(const char *, int, int, int, int, int, int, ...);
int __fastcall update_miner_configurations(int, int);
_DWORD *create_category_hashtable();
int __fastcall parse_config_file(int);
int __fastcall initialize_zlog_configuration(const char *);
_DWORD *__fastcall fill_miner_config_buffer(_DWORD *result, int, int, int, int, int, int, int, int, int, int);
_DWORD *__fastcall populate_miner_config(_DWORD *result, int, int, int, int, int, int, int, int, int, int);
void __fastcall delete_format(_DWORD *);
char *__fastcall parse_format_string(const char *, const char **);
int __fastcall check_condition_and_execute(int, int);
int __fastcall set_log_level_from_config(int, const char *);
int __fastcall getASICChipLevel(int *levelListPtr, int chipIndex);
_DWORD *__fastcall get_subsystem_status(_DWORD **);
_DWORD *create_record_table();
pthread_mutex_t *__fastcall initialize_mutex_and_open_file(const char *);
int __fastcall rotate_log_files(int, const char *, unsigned int, const char *, int, int);
int __fastcall process_rule(int, int);
int __fastcall write_log_to_file(int, int);
void __fastcall release_rule_resources(_DWORD *);
unsigned __int8 *__fastcall parse_configuration_line(const char *, _DWORD *, int, __int64 *, int, int, const char **);
int __fastcall execute_custom_function(int, int);
int __fastcall call_custom_function(int, int);
int __fastcall invoke_device_operation(int, int);
int __fastcall transmit_data(int, int, int); // idb
int __fastcall format_percentage(int, int, int); // idb
int __fastcall perform_custom_operation(int, int, int); // idb
int __fastcall forward_command_to_miner(int, int, int); // idb
int __fastcall send_status_to_controller(int, int, int); // idb
int __fastcall send_miner_command(int, int, int); // idb
int __fastcall calculation_result(int, int, int); // idb
int __fastcall trigger_event_with_parameters(int, int, int); // idb
int __fastcall calculate_chip_performance(int, int, int);
int __fastcall calculate_asics_performance(int, int, int);
int __fastcall initialize_process_id(int, int, int); // idb
int __fastcall extract_and_forward_device_info(int, int, int);
int __fastcall process_debug_output(int, int, int); // idb
int __fastcall extract_last_path_segment(int, int, int);
int __fastcall update_miner_timestamp(int, int, int);
int __fastcall initialize_miner_timer(int, int, int);
int __fastcall get_mdc_value_for_key(int, int, int);
int __fastcall update_log_timestamp(int, int, int);
int __fastcall get_function_description(int, int, int); // idb
int __fastcall log_file_info(int, int, int); // idb
int __fastcall update_firmware(int, int);
int __fastcall process_data_chunk(int, int);
int __fastcall process_gen_buf(int, int);
int __fastcall log_specific_information(const char **, int);
void __fastcall delete_logging_specification(void *);
const char **__fastcall parse_log_format(const char *, char **, const char **);
void __fastcall release_thread_resources(_DWORD *);
_DWORD *__fastcall initialize_logging_thread(int, size_t, unsigned int, size_t);
int __fastcall rebuild_buffer_if_needed(int, size_t, unsigned int arg);
int __fastcall allocate_event_memory(int, size_t);
int __fastcall invoke_custom_subroutine(int, int);
size_t __fastcall format_current_time(char *);
int sub_5DF98(int, const char *, int, const char *, ...);
int __fastcall parse_size_in_bytes(const char *);
int __fastcall resize_buffer(int, unsigned int);
void *__fastcall calculate_copy_destination(void **);
int __fastcall format_number_to_buffer(int, unsigned int, char *);
unsigned int __fastcall calculate_bit_difficulty(unsigned int result, unsigned int);
unsigned int __fastcall calculate_difficulty_ratio(unsigned int, unsigned int);
int __fastcall call_external_function_with_check(int, unsigned int);
int __fastcall normalize_exponent_sign(__int64);
int __fastcall handle_divide_by_zero(unsigned __int64, unsigned __int64);
unsigned int __fastcall calculate_normalized_hashrate(double);
int __fastcall init(int, int, int);
int __fastcall register_cleanup_function(void (__fastcall *)(void *));
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_186A0; // weak
_UNKNOWN loc_600C4; // weak
char aReadSensorOnAs[20] = "read_sensor_on_asic"; // weak
_UNKNOWN dword_60DE4; // weak
char *off_666C0[18] =
{
  "STATUS_INIT",
  "STATUS_INITED",
  "STATUS_OKAY",
  "WARN_NET_LOST",
  "ERROR_SOC_INIT",
  "ERROR_REOPEN_CORE",
  "ERROR_NET_LOST",
  "ERROR_FAN_LOST",
  "ERROR_PIC_LOST",
  "ERROR_POWER_LOST",
  "ERROR_ASIC_NUM",
  "ERROR_UNBALANCE",
  "ERROR_EEPROM_INFO",
  "ERROR_TEMP_LOST_1ST",
  "ERROR_TEMP_LOST",
  "ERROR_TEMP_TOO_HIGH",
  "ERROR_TEMP_TOO_LOW",
  "ERROR_UNKOWN_STATUS"
}; // weak
const char aSSet1704FlashP_0[] = "%s: set 1704 flash pointer err!\n"; // idb
__int16 word_6A02C = 10; // weak
const char asc_6BB30[] = "[ %[^] \t"; // idb
__int16 word_6BB38 = 93; // weak
void *off_7DF00 = (void *)0x13CDD; // weak
int dword_7E2EC = -1; // weak
char *off_7E618 = "--version-file"; // weak
_UNKNOWN unk_7EAB0; // weak
_UNKNOWN unk_7EAB4; // weak
int dword_7EAB8 = 2; // weak
char *off_7EAC0 = "--config|-c"; // weak
int dword_7EB4C = 550; // weak
int dword_7EB50 = 1800; // weak
int optMultiVersion = 1; // weak
char optBitmainAB = '\x01'; // weak
int dword_7EB68 = 5; // weak
int dword_7EB6C = 10; // weak
char byte_7EB78 = '\x01'; // weak
char byte_7EB79 = '\x01'; // weak
int globalLogLevel = 4; // weak
int loggingThreshold = 5; // weak
int (__fastcall *off_7ECC4)(_DWORD) = &initialize_miner_system; // weak
int minerOperationMode = 1; // weak
int dword_7EDCC = 50; // weak
_UNKNOWN unk_7EDD0; // weak
int versionThreshold = -1; // weak
int maskThreshold = -1; // weak
void *pulseModeConfig = (void *)0x10101; // weak
__int16 lastRecordedVoltageDiff = 255; // weak
int dword_7EDE8 = 255; // weak
int stderr; // weak
int stdin; // weak
int dword_7F7A4; // weak
int dword_7F7A8; // weak
int dword_7F7AC; // weak
int calibrationFactor; // weak
int dword_7F7B4; // weak
int dword_7F7B8; // weak
int dword_7F7BC; // weak
pthread_mutex_t stru_7F7C0; // idb
int dword_7F7D8; // weak
int dword_7F7DC; // weak
int dword_7F7E0; // weak
pthread_t newthread; // idb
int dword_7F7E8; // weak
pthread_mutex_t stru_7F7EC; // weak
int dword_7F804; // weak
int dword_7F808; // weak
int dword_7F80C; // weak
int dword_7F810; // weak
int globalChainConfigs[]; // weak
int dword_7F81C; // weak
int dword_7F8BC; // weak
int dword_7F8C0; // weak
_DWORD ChainFrequencyBoundary[4]; // weak
int dword_7F8D4; // weak
int dword_7F8D8; // weak
int dword_7F8DC; // weak
_DWORD dword_7F8E0[4]; // weak
char byte_7F8F8; // weak
char terminate_flag; // weak
int dword_7FA00[]; // weak
int dword_7FA3C; // weak
int dword_7FA40; // weak
pthread_mutex_t stru_7FA44; // idb
int dword_7FA5C; // weak
_UNKNOWN unk_7FA60; // weak
int dword_7FBA0; // weak
int dword_7FBC0; // weak
int dword_7FBE0[]; // weak
int dword_7FBE4; // weak
int dword_7FBE8; // weak
int dword_7FBEC; // weak
int dword_7FBF0[]; // weak
int dword_7FBF4; // weak
int dword_7FBF8; // weak
int dword_7FBFC; // weak
__int64 qword_7FC00; // weak
_UNKNOWN unk_7FC08; // weak
int dword_80748; // weak
_UNKNOWN dword_8074C; // weak
char byte_80768[512]; // weak
int dword_80968; // weak
int dword_8096C; // weak
int minerVersionFilename; // weak
int dword_80B94; // weak
int dword_80B98; // weak
int dword_80B9C; // weak
char minerVersion[256]; // idb
char minerType[256]; // idb
char serialNumber; // idb
_UNKNOWN unk_80F18; // weak
_UNKNOWN unk_80F1C; // weak
pthread_mutex_t mutex; // idb
int dword_80F38; // weak
int dword_80F3C; // weak
sem_t sem; // idb
_UNKNOWN unk_80F50; // weak
int dword_80F58; // weak
int dword_80F5C; // weak
char byte_80F64; // weak
int dword_80F68; // weak
__int64 qword_80F78; // weak
int dword_80F80; // weak
int dword_80F84; // weak
char algn_80F88[8]; // weak
int dword_80F90; // weak
int dword_80F94; // weak
int jobBitMask; // weak
char byte_80FA4; // weak
int pwthSel; // weak
int ccdlySel; // weak
char byte_80FB0; // weak
int optBitmainWorkMode; // weak
char byte_80FB8[16]; // weak
_UNKNOWN unk_80FC8; // weak
char byte_80FDC[256]; // weak
pthread_mutex_t stru_810DC; // weak
pthread_mutex_t stru_810F4; // idb
char byte_8110C; // weak
_UNKNOWN unk_81114; // weak
_UNKNOWN unk_81124; // weak
_UNKNOWN unk_81128; // weak
_UNKNOWN unk_F4240; // weak
_UNKNOWN unk_202806; // weak
_UNKNOWN unk_202A2A; // weak
_UNKNOWN unk_2DC6C0; // weak
_UNKNOWN unk_408FFC; // weak
int dword_48212C; // weak
char byte_482130; // weak
int dword_482134; // weak
__int16 word_482138; // weak
char byte_482158[256]; // weak
char loggingVerbose; // weak
char logEnabled; // weak
int dword_482A64; // weak
int dword_482A68; // weak
int dword_482A6C; // weak
char byte_482A70; // weak
char isSerialNumberValid; // weak
__time_t dword_482A74[3]; // weak
char byte_482A88; // weak
char chipStatusInitialized; // weak
int dword_482A8C; // weak
__int16 word_482A90; // weak
int dword_482A94; // weak
int dword_482A98; // weak
int dword_482A9C; // weak
_UNKNOWN unk_482AA0; // weak
pthread_mutex_t stru_4FCAD0; // weak
int dword_4FCB28; // weak
int dword_4FCB30; // weak
int dword_4FCB34; // weak
int dword_4FCB38; // weak
int dword_4FCB3C; // weak
int minerConfigAddress; // weak
int dword_4FCB44; // weak
int globalHashChainConfig[73]; // weak
int dword_504C8C; // weak
int dword_504C90; // weak
int dword_504C94; // weak
int dword_504C98; // weak
int dword_504C9C; // weak
int dword_504CA0; // weak
int dword_504CA4; // weak
int dword_504CA8; // weak
pthread_mutex_t stru_504CAC; // idb
int dword_504CC4; // weak
pthread_mutex_t stru_504CC8; // idb
int dword_504CE0; // weak
char algn_504CE4[4]; // weak
_UNKNOWN unk_504CE8; // weak
pthread_mutex_t stru_504FEC; // idb
int dword_505004; // weak
_DWORD dword_505088[32]; // weak
int dword_50510C; // weak
int dword_505110; // weak
int dword_505114; // weak
int dword_505118; // weak
pthread_mutex_t stru_50514C; // weak
pthread_mutex_t stru_505164; // weak
int dword_50517C; // weak
int global_logContext; // weak
int dword_505184; // weak
pthread_mutex_t stru_505188; // weak
int dword_5051A0; // weak
int dword_5051A4; // weak
pthread_mutex_t stru_5051A8; // idb
_DWORD dword_5051C8[512]; // weak
pthread_mutex_t stru_5059C8; // idb
_DWORD dword_5059E0[32768]; // weak
_UNKNOWN unk_5259E0; // weak
int dword_58DE08; // weak
int dword_58DE0C; // weak
int dword_58DE10; // weak
int dword_58DE14; // weak
int dword_58DE18; // weak
pthread_rwlock_t stru_58DE1C; // idb
int dword_58DE3C; // weak
int dword_58DE40; // weak
int dword_58DE44; // weak
int dword_58DE48; // weak
int dword_58DE4C; // weak
int dword_58DFB8; // weak
int globalChainCount; // weak
int dword_58DFC0; // weak
int dword_58DFC4; // weak
int dword_58DFC8; // weak
int dword_58DFCC; // weak
int dword_58DFD0; // weak
int dword_58DFD4; // weak
int dword_58DFD8; // weak
int dword_58DFDC; // weak
int dword_58DFE0; // weak
int dword_58DFE4; // weak
int dword_58DFE8; // weak
int dword_58DFEC; // weak
int dword_58DFF0; // weak
int dword_58DFF4; // weak
int dword_58DFF8; // weak
int dword_58DFFC; // weak
int dword_58E000; // weak
int globalFanCount; // weak
int globalInitializationFlag; // weak
int globalChainBufferPtr; // weak
char byte_58E01D; // weak
int dword_58E020; // weak
int dword_58E038; // weak
int dword_58E03C; // weak
int dword_58E344; // weak
_UNKNOWN dword_58E348; // weak
int dword_58E34C; // weak
char byte_58E350; // weak
int dword_58E354; // weak
struct sigaction unk_58E35C; // idb
int dword_5903F8; // weak
int dword_590400; // weak
char loggingDebug; // weak
pthread_mutex_t stru_590408; // weak
pthread_rwlock_t rwlock; // idb
int dword_592460; // weak
struct sigaction unk_592464; // idb
struct sigaction unk_594524; // idb
int dword_5945B4; // weak
int dword_5945B8[]; // weak
int dword_5945BC; // weak
int dword_5945C0; // weak
int dword_5955C8[]; // weak
int dword_5955CC; // weak
int dword_5955D0; // weak
_WORD word_59CD98[57332]; // weak
_UNKNOWN unk_808FFC; // weak
_DWORD dword_80A894[4]; // weak
_DWORD dword_80ACAC[6656]; // weak
_UNKNOWN unk_8114AC; // weak
_QWORD qword_99CD98[1024]; // weak
_DWORD dword_99ED98[8]; // weak
char globalTokenBuffer; // weak
char globalTokenBuffer1; // weak
_UNKNOWN globalTokenParam2Buffer; // weak
char byte_99EDC2; // weak
__int16 globalTokenParam3Buffer; // weak
__int16 word_99EDC6; // weak
_UNKNOWN globalTokenParam4Buffer; // weak
_UNKNOWN globalTokenParam5Buffer; // weak
_UNKNOWN globalTokenParam6Buffer; // weak
_UNKNOWN globalTokenParam7Buffer; // weak
__int16 word_99EDD6; // weak
int dword_99EDD8; // weak
int dword_99EDDC; // weak
char byte_99EDE0[32]; // weak
__int64 qword_99EE08; // weak
_DWORD dword_99EE48[32]; // weak
int dword_99EEC8; // weak


//----- (00011E84) --------------------------------------------------------
int init_proc()
{
  return check_and_initialize_gmon();
}

//----- (00011E90) --------------------------------------------------------
void exit_immediately()
{
  JUMPOUT(0);
}
// 11E9C: control flows out of bounds to 0

//----- (0001230C) --------------------------------------------------------
// attributes: thunk
int __fastcall j___cxa_atexit(void (__fastcall *lpfunc)(void *), void *obj, void *lpdso_handle)
{
  return _cxa_atexit(lpfunc, obj, lpdso_handle);
}

//----- (00012620) --------------------------------------------------------
int __fastcall main(int a1, char **a2, char **a3)
{
  char *v4; // r7
  FILE *v5; // r8
  size_t v6; // r0
  size_t v7; // r5
  int v8; // r6
  int *v9; // r8
  size_t i; // r4
  const unsigned __int16 **v11; // r0
  int v12; // t1
  int v13; // r3
  void *v14; // r5
  _DWORD *v15; // r4
  _DWORD *v16; // r0
  int v17; // r4
  char *v18; // r10
  char *v19; // r5
  int v20; // r4
  int v21; // r2
  int v22; // r8
  int v23; // r6
  __int64 v24; // r10
  int v25; // r7
  int v26; // r3
  unsigned int *p_count; // r4
  int v28; // r2
  int v29; // r1
  int v30; // r0
  int v31; // r0
  int v32; // r6
  void **v33; // r10
  __int64 v34; // r0
  __int64 v35; // r6
  int v36; // r1
  int v37; // r0
  unsigned __int64 v38; // r2
  __int64 v39; // r0
  __int64 v40; // r6
  int v41; // r1
  int v42; // r0
  unsigned __int64 v43; // r2
  int v44; // r1
  int v45; // r2
  int v46; // r3
  int v47; // r1
  int v48; // r2
  int v49; // r3
  int v50; // r1
  int v51; // r2
  int *v52; // r2
  void ***v53; // r1
  unsigned int v54; // t1
  unsigned __int64 v55; // r2
  int *v56; // r3
  int v58; // r0
  int voltage_status; // r6
  unsigned int high_byte; // r0
  char v61; // r0
  unsigned int v62; // r1
  int *v64; // r0
  int *v65; // r0
  int *v66; // r0
  int *v67; // r0
  int v69; // [sp+20h] [bp-A88h]
  unsigned int v70; // [sp+28h] [bp-A80h]
  double v71; // [sp+28h] [bp-A80h]
  double v72; // [sp+28h] [bp-A80h]
  pthread_mutex_t *v73; // [sp+34h] [bp-A74h]
  int *v74; // [sp+3Ch] [bp-A6Ch]
  __int64 v75; // [sp+40h] [bp-A68h]
  unsigned int v76; // [sp+4Ch] [bp-A5Ch]
  __int64 v77; // [sp+58h] [bp-A50h]
  void **v78; // [sp+68h] [bp-A40h] BYREF
  int v79[6]; // [sp+6Ch] [bp-A3Ch] BYREF
  unsigned int v80; // [sp+84h] [bp-A24h]
  int v81; // [sp+88h] [bp-A20h] BYREF
  char dest[32]; // [sp+8Ch] [bp-A1Ch] BYREF
  char command[64]; // [sp+ACh] [bp-9FCh] BYREF
  struct sigaction v84; // [sp+ECh] [bp-9BCh] BYREF
  int s[64]; // [sp+178h] [bp-930h] BYREF
  int v86[510]; // [sp+278h] [bp-830h] BYREF

  v84.sa_handler = (__sighandler_t)shutdown_miner_and_exit;
  v84.sa_flags = 0;
  sigemptyset(&v84.sa_mask);
  sigaction(15, &v84, &unk_592464);
  sigaction(2, &v84, &unk_594524);
  sigaction(6, &v84, &unk_58E35C);
  sem_init(&sem, 0, 0);
  initialize_sync_primitives((int)&stru_590408, "main", 2771);
  v4 = *a2;
  memset(s, 0, sizeof(s));
  memset(command, 0, sizeof(command));
  snprintf(command, 64u, "pidof %s", v4);
  v5 = popen(command, "r");
  if ( v5 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        do
        {
          if ( !fgets((char *)s, 256, v5) )
          {
            v7 = 0;
            v8 = 0;
            pclose(v5);
            v9 = s;
            for ( i = 1; strlen((const char *)s) >= i; ++i )
            {
              memset(dest, 0, sizeof(dest));
              v11 = _ctype_b_loc();
              v12 = *(unsigned __int8 *)v9;
              v9 = (int *)((char *)v9 + 1);
              if ( ((*v11)[v12] & 0x2000) != 0 )
              {
                strncpy(dest, (const char *)s + v7, i - v7 - 1);
                v13 = strtol(dest, 0, 10);
                if ( v13 > 0 && (++v8, logEnabled) && (loggingDebug || loggingVerbose || loggingThreshold > 6) )
                {
                  snprintf((char *)v86, 2048u, "Parsed proc id is: %d\n", v13);
                  v7 = i;
                  logMessage(7, (const char *)v86, 0);
                }
                else
                {
                  v7 = i;
                }
              }
            }
            if ( v8 )
            {
              if ( loggingDebug || loggingVerbose || loggingThreshold > 2 )
              {
                snprintf((char *)v86, 2048u, " %d instance of %s is  already Running on this machine", v8, v4);
                logMessage(3, (const char *)v86, 0);
              }
              if ( v8 != 1 )
              {
                snprintf((char *)v86, 2048u, "%s is forbidden to start twice, will exit immediately!", *a2);
                logMessage(3, (const char *)v86, 1);
              }
            }
            goto LABEL_30;
          }
        }
        while ( !logEnabled );
        if ( loggingDebug || loggingVerbose || loggingThreshold > 6 )
          break;
LABEL_9:
        if ( loggingVerbose || loggingThreshold > 6 )
        {
LABEL_11:
          v6 = strlen((const char *)s);
          snprintf((char *)v86, 2048u, "strlen is: %d\n", v6);
          logMessage(7, (const char *)v86, 0);
        }
      }
      snprintf((char *)v86, 2048u, "pidof %s command result is: %s\n", v4, (const char *)s);
      logMessage(7, (const char *)v86, 0);
      if ( logEnabled )
      {
        if ( loggingDebug )
          goto LABEL_11;
        goto LABEL_9;
      }
    }
  }
  if ( logEnabled && (loggingDebug || loggingVerbose || loggingThreshold > 6) )
  {
    snprintf((char *)v86, 2048u, " app-service:%s Not Found!!!", v4);
    logMessage(7, (const char *)v86, 0);
  }
LABEL_30:
  initialize_logging("/etc/bitmain_category.conf");
  v14 = calloc(1u, 5732u);
  dword_592460 = (int)v14;
  v15 = calloc(1u, 392u);
  dword_58E354 = (int)v15;
  v16 = calloc(1u, 64u);
  v16[9] = v15;
  v15[5] = v14;
  dword_58E34C = (int)v16;
  processCommandLineArguments(a1, (const char **)a2);
  initialize_bitmain_primary();
  if ( initialize_miner_socket() )
    handle_error_with_logging(4u, "socket init failed!");
  if ( initializeMiner() )
    handle_error_with_logging(4u, "basic init failed!");
  dword_590400 = (int)calloc(1u, 64u);
  pthread_attr_init((pthread_attr_t *)command);
  pthread_attr_setstacksize((pthread_attr_t *)command, 2097152u);
  if ( create_thread_with_logging(
         dword_590400,
         (const pthread_attr_t *)command,
         (void *(*)(void *))update_api_statistics,
         (void *)dword_590400)
    && (loggingDebug || loggingVerbose || loggingThreshold > 2) )
  {
    snprintf((char *)v86, 2048u, "%s: create thread for get api status failed\n", "main");
    logMessage(3, (const char *)v86, 0);
  }
  pthread_detach(*(_DWORD *)(dword_590400 + 12));
  v17 = *(_DWORD *)(*(_DWORD *)(dword_58E34C + 36) + 20);
  if ( pthread_mutex_init((pthread_mutex_t *)(v17 + 112), 0) )
    log_mutex_init_failure("bitmain_soc_prepare", 1933);
  initialize_sync_primitives(v17, "bitmain_soc_prepare", 1934);
  initialize_sync_primitives(v17 + 384, "bitmain_soc_prepare", 1935);
  initialize_sync_primitives(v17 + 2232, "bitmain_soc_prepare", 1936);
  initialize_sync_primitives(v17 + 4080, "bitmain_soc_prepare", 1937);
  memset(v86, 0, 32u);
  HIWORD(v86[0]) = 26;
  LOBYTE(v86[0]) = 81;
  BYTE1(v86[1]) |= 7u;
  LOBYTE(v86[1]) = ~(~((v86[1] & 0xFD | (2 * (byte_80F64 & 1u))) << 30) >> 30);
  LOWORD(v86[2]) = 13833;
  BYTE2(v86[2]) = dword_80F68;
  HIBYTE(v86[2]) = 80;
  LOWORD(v86[4]) = 2570;
  LOWORD(v86[3]) = dword_7EB4C;
  HIWORD(v86[6]) = 400;
  LOWORD(v86[7]) = 600;
  HIWORD(v86[3]) = dword_7EB50;
  LOBYTE(v86[6]) = 4;
  HIWORD(v86[7]) = calculate_crc16_checksum((int)v86, 30);
  if ( !initializeMinerHardware(v86[0], v86[1], v86[2], v86[3], v86[4], v86[5], v86[6], v86[7]) )
    handle_error_with_logging(4u, "soc init failed!");
  handle_error_with_logging(2u, 0);
  pthread_mutex_lock(&mutex);
  if ( dword_80F38 )
  {
    if ( (unsigned int)globalLogLevel > 3 )
    {
      strcpy((char *)v86, "start the cached job");
      logMessage(3, (const char *)v86, 0);
    }
    process_job_update((const void *)dword_80F3C, dword_80F38);
  }
  pthread_mutex_unlock(&mutex);
  initialize_and_update_uptime();
  v18 = byte_80768;
  while ( 2 )
  {
    v19 = v18;
LABEL_49:
    if ( !*(_BYTE *)(dword_58E354 + 364) )
    {
      v74 = (int *)dword_58E34C;
      v20 = *(_DWORD *)(*(_DWORD *)(dword_58E34C + 36) + 20);
      v73 = (pthread_mutex_t *)v20;
      pthread_mutex_lock(&stru_4FCAD0);
      if ( pthread_mutex_lock((pthread_mutex_t *)v20) )
      {
        v65 = _errno_location();
        snprintf(
          (char *)v86,
          2048u,
          "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
          *v65,
          "bmminer.c",
          "bitmain_c5_scanhash",
          2063);
        logMessage(3, (const char *)v86, 1);
      }
      if ( pthread_rwlock_rdlock((pthread_rwlock_t *)(v20 + 24)) )
      {
        v67 = _errno_location();
        snprintf(
          (char *)v86,
          2048u,
          "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
          *v67,
          "bmminer.c",
          "bitmain_c5_scanhash",
          2063);
        logMessage(3, (const char *)v86, 1);
      }
      if ( pthread_mutex_unlock((pthread_mutex_t *)v20) )
      {
        v66 = _errno_location();
        snprintf(
          (char *)v86,
          2048u,
          "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
          *v66,
          "bmminer.c",
          "bitmain_c5_scanhash",
          2063);
        logMessage(3, (const char *)v86, 1);
      }
      v75 = 0LL;
LABEL_57:
      if ( !dword_5955D0 )
      {
LABEL_85:
        qword_99EE08 += v75;
        v31 = pthread_rwlock_unlock((pthread_rwlock_t *)&v73[1]);
        if ( v31 )
        {
          v64 = _errno_location();
          snprintf(
            (char *)v86,
            2048u,
            "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
            *v64,
            "bmminer.c",
            "bitmain_c5_scanhash",
            2156);
          v31 = logMessage(3, (const char *)v86, 1);
        }
        off_7ECC4(v31);
        pthread_mutex_unlock(&stru_4FCAD0);
        get_next_sleep_interval();
        if ( v75 )
        {
          v18 = v19;
          v77 = 4294967295LL * v75;
          if ( logEnabled && (loggingDebug || loggingVerbose || loggingThreshold > 6) )
          {
            snprintf((char *)v86, 2048u, "%s: hashes %llu ...\n", "bitmain_c5_scanhash", v77);
            logMessage(7, (const char *)v86, 0);
          }
          if ( v77 )
            unk_80F50 = ((double (__fastcall *)(int, _DWORD, int, unsigned int))loc_600C4)(
                          -(int)v75,
                          (unsigned __int64)(4294967295LL * v75) >> 32,
                          -(int)v75,
                          -(int)v75 | (unsigned int)((unsigned __int64)(4294967295LL * v75) >> 32))
                      / 1000000000.0
                      + unk_80F50;
          continue;
        }
        goto LABEL_49;
      }
      while ( 1 )
      {
        v21 = 0;
        v22 = dword_5955C8[15 * dword_5955CC + 8];
        v23 = dword_5955C8[15 * dword_5955CC + 3];
        v24 = *(_QWORD *)&dword_5955C8[15 * dword_5955CC + 6];
        v69 = dword_5955C8[15 * dword_5955CC + 9];
        v25 = dword_5955C8[15 * dword_5955CC + 4];
        v70 = (dword_5955C8[15 * dword_5955CC + 5] << 24) | HIBYTE(dword_5955C8[15 * dword_5955CC + 5]) | ((unsigned int)dword_5955C8[15 * dword_5955CC + 5] >> 8) & 0xFF00 | (dword_5955C8[15 * dword_5955CC + 5] << 8) & 0xFF0000;
        do
          ++v21;
        while ( v21 != 32 );
        if ( logEnabled && (loggingDebug || loggingVerbose || loggingThreshold > 6) )
        {
          snprintf(
            (char *)v86,
            2048u,
            "%s: job_id:0x%x   work_id:0x%x   nonce2:0x%llx nonce3:0x%x   version:0x%x\n",
            "bitmain_c5_scanhash",
            v23,
            v25,
            v24,
            v22,
            v70);
          logMessage(7, (const char *)v86, 0);
        }
        if ( (unsigned int)dword_5955CC > 509 )
          v26 = 0;
        else
          v26 = dword_5955CC;
        p_count = &v73[7].__count;
        if ( (unsigned int)dword_5955CC <= 509 )
          ++v26;
        dword_5955CC = v26;
        v28 = *((_DWORD *)v19 + 513);
        --dword_5955D0;
        if ( v22 != v28 || v25 != *((_DWORD *)v19 + 514) )
          break;
        if ( get_global_buffer_value(v69) != 1 )
          goto LABEL_57;
        if ( logEnabled && (loggingDebug || loggingVerbose || loggingThreshold > 6) )
        {
          strcpy((char *)v86, "reepat nonce error");
          logMessage(7, (const char *)v86, 0);
        }
LABEL_84:
        increment_hardware_errors((int)v74);
        process_chain_request(v69);
        if ( !dword_5955D0 )
          goto LABEL_85;
      }
      *((_DWORD *)v19 + 513) = v22;
      *((_DWORD *)v19 + 514) = v25;
      if ( logEnabled )
      {
        if ( !loggingDebug && !loggingVerbose && loggingThreshold <= 6 )
        {
          v29 = dword_7EAB8;
          v30 = dword_7EAB8 - v23;
          goto LABEL_76;
        }
        snprintf((char *)v86, 2048u, "%s: Chain ID J%d ...\n", "bitmain_c5_scanhash", v69 + 1);
        logMessage(7, (const char *)v86, 0);
        if ( logEnabled )
        {
          v29 = dword_7EAB8;
          v30 = dword_7EAB8 - v23;
          if ( loggingDebug )
          {
LABEL_95:
            snprintf(
              (char *)v86,
              2048u,
              "%s: given_id:%d job_id:%d switch:%d  ...\n",
              "bitmain_c5_scanhash",
              v29,
              v23,
              v30);
            logMessage(7, (const char *)v86, 0);
            goto LABEL_96;
          }
LABEL_76:
          if ( !loggingVerbose && loggingThreshold <= 6 )
          {
            switch ( v30 )
            {
              case 1:
                goto LABEL_141;
              case 0:
                goto LABEL_100;
              case 2:
LABEL_99:
                p_count = &v73[161].__count;
                goto LABEL_100;
            }
            goto LABEL_81;
          }
          goto LABEL_95;
        }
      }
LABEL_96:
      v32 = dword_7EAB8 - v23;
      switch ( v32 )
      {
        case 1:
LABEL_141:
          p_count = &v73[84].__count;
LABEL_100:
          update_nonce_and_generate_work(v74, (int *)&v78, (int)p_count, (int)p_count, v24, v70);
          v33 = v78;
          v76 = *p_count;
          v71 = *((double *)v78 + 39);
          LODWORD(v34) = calculate_normalized_hashrate(v71);
          v35 = v34;
          if ( v34 != qword_80F78 )
          {
            v36 = 0;
            v37 = 0;
            qword_80F78 = v35;
            dword_80F80 = 0;
            dword_80F84 = 0;
            if ( v35 )
            {
              v38 = v35;
              while ( 1 )
              {
                v38 >>= 1;
                if ( !v38 )
                  break;
                v37 = (__PAIR64__(v37, v36++) + 1) >> 32;
              }
            }
            else
            {
              v36 = -1;
              v37 = -1;
            }
            dword_80F80 = v36;
            dword_80F84 = v37;
            if ( logEnabled )
            {
              if ( loggingDebug || loggingVerbose || loggingThreshold > 6 )
              {
                snprintf(
                  (char *)v86,
                  2048u,
                  "%s: pool_diff:%lld work_diff:%f pool_diff_bit:%lld ...\n",
                  "hashtest_submit",
                  v35,
                  v71,
                  __PAIR64__(v37, v36));
                logMessage(7, (const char *)v86, 0);
              }
            }
          }
          v72 = unk_7EAB0;
          LODWORD(v39) = calculate_normalized_hashrate(unk_7EAB0);
          v40 = v39;
          if ( v39 != *(_QWORD *)algn_80F88 )
          {
            v41 = 0;
            *(_QWORD *)algn_80F88 = v40;
            v42 = 0;
            if ( v40 )
            {
              v43 = v40;
              while ( 1 )
              {
                v43 >>= 1;
                if ( !v43 )
                  break;
                v42 = (__PAIR64__(v42, v41++) + 1) >> 32;
              }
            }
            else
            {
              v41 = -1;
              v42 = -1;
            }
            dword_80F90 = v41;
            dword_80F94 = v42;
            if ( logEnabled )
            {
              if ( loggingDebug || loggingVerbose || loggingThreshold > 6 )
              {
                snprintf(
                  (char *)v86,
                  2048u,
                  "%s:net_diff:%lld current_diff:%f net_diff_bit %lld ...\n",
                  "hashtest_submit",
                  v40,
                  v72,
                  __PAIR64__(v42, v41));
                logMessage(7, (const char *)v86, 0);
              }
            }
          }
          v44 = (int)v33[33];
          v45 = (int)v33[34];
          v46 = (int)v33[35];
          s[2] = (int)v33[32];
          s[3] = v44;
          s[4] = v45;
          s[5] = v46;
          v47 = (int)v33[37];
          v48 = (int)v33[38];
          v49 = (int)v33[39];
          s[6] = (int)v33[36];
          s[7] = v47;
          s[8] = v48;
          s[9] = v49;
          s[0] = 80;
          s[1] = 0;
          v50 = (int)v33[17];
          v51 = (int)v33[18];
          v79[0] = (int)v33[16];
          v79[1] = v50;
          v79[2] = v51;
          reverse_copy_with_byte_swap((int)&s[10], (unsigned int *)v79, 12u);
          v79[0] = v22;
          reverse_copy_with_byte_swap((int)&s[13], (unsigned int *)v79, 4u);
          finalize_sha256_state((int)s, v79);
          memset(s, 0, 232u);
          compute_sha256_hash((unsigned int *)v79, 32, dest);
          v52 = &v81;
          v53 = &v78;
          do
          {
            v54 = v52[1];
            ++v52;
            v53[1] = (void **)bswap32(v54);
            ++v53;
          }
          while ( &dest[28] != (char *)v52 );
          LODWORD(v55) = v81;
          if ( v81 )
          {
            if ( get_global_buffer_value(v69) == 1 )
            {
              if ( logEnabled && (loggingDebug || loggingVerbose || loggingThreshold > 6) )
              {
                strcpy((char *)v86, "hash2_32 error");
                logMessage(7, (const char *)v86, 0);
              }
              increment_hardware_errors((int)v74);
              process_chain_request(v69);
            }
            if ( logEnabled && (loggingDebug || loggingVerbose || loggingThreshold > 6) )
            {
              snprintf((char *)v86, 2048u, "%s: HASH2_32[7] != 0", "hashtest_submit");
              logMessage(7, (const char *)v86, 0);
            }
          }
          else
          {
            v56 = &v81;
            while ( !*--v56 )
            {
              LODWORD(v55) = v55 + 1;
              if ( (_DWORD)v55 == 7 )
              {
                v55 = 7LL;
                goto LABEL_128;
              }
            }
            v55 = (int)v55;
LABEL_128:
            if ( *(_QWORD *)&dword_80F80 >> 5 <= v55 )
            {
              v58 = sub_1E160();
              voltage_status = get_voltage_status(v22, v58);
              high_byte = get_high_byte(v22);
              if ( logEnabled && (loggingDebug || loggingVerbose || loggingThreshold > 6) )
              {
                snprintf(
                  (char *)v86,
                  2048u,
                  "%s: chain %d which_asic_nonce %d which_core_nonce %d",
                  "hashtest_submit",
                  v69,
                  voltage_status,
                  high_byte);
                logMessage(7, (const char *)v86, 0);
              }
              v61 = dword_80F80;
              v62 = *(&v80 - (*(__int64 *)&dword_80F80 >> 5));
              ++qword_99CD98[256 * v69 + voltage_status];
              if ( bswap32(v62) < 4294967295u >> (v61 & 0x1F) )
              {
                *(_QWORD *)&dword_99ED98[2 * v69] += 256LL;
                submit_nonce_to_miner((int)v74, (const char **)v33, v22, v76);
                v75 += 256LL;
              }
              else if ( bswap32(v80) <= 16777214 )
              {
                *(_QWORD *)&dword_99ED98[2 * v69] += 256LL;
                v75 += 256LL;
              }
            }
          }
          clear_and_log_miner_info(&v78, "bmminer.c", "bitmain_c5_scanhash", 2153);
          goto LABEL_57;
        case 0:
          goto LABEL_100;
        case 2:
          goto LABEL_99;
      }
      if ( loggingDebug || loggingVerbose )
      {
LABEL_82:
        snprintf((char *)v86, 2048u, "%s: job_id non't found ...\n", "bitmain_c5_scanhash");
        logMessage(3, (const char *)v86, 0);
LABEL_83:
        if ( get_global_buffer_value(v69) != 1 )
          goto LABEL_57;
        goto LABEL_84;
      }
LABEL_81:
      if ( loggingThreshold <= 2 )
        goto LABEL_83;
      goto LABEL_82;
    }
    break;
  }
  sem_destroy(&sem);
  wait_one_second();
  shutdown_logging_system();
  return 0;
}
// 13278: variable 'v34' is possibly undefined
// 13388: variable 'v39' is possibly undefined
// 7EAB8: using guessed type int dword_7EAB8;
// 7EB4C: using guessed type int dword_7EB4C;
// 7EB50: using guessed type int dword_7EB50;
// 7EB9C: using guessed type int globalLogLevel;
// 7EBA0: using guessed type int loggingThreshold;
// 7ECC4: using guessed type int (__fastcall *off_7ECC4)(_DWORD);
// 80F38: using guessed type int dword_80F38;
// 80F3C: using guessed type int dword_80F3C;
// 80F64: using guessed type char byte_80F64;
// 80F68: using guessed type int dword_80F68;
// 80F78: using guessed type __int64 qword_80F78;
// 80F80: using guessed type int dword_80F80;
// 80F84: using guessed type int dword_80F84;
// 80F90: using guessed type int dword_80F90;
// 80F94: using guessed type int dword_80F94;
// 482A5C: using guessed type char loggingVerbose;
// 482A5D: using guessed type char logEnabled;
// 4FCAD0: using guessed type pthread_mutex_t stru_4FCAD0;
// 58E34C: using guessed type int dword_58E34C;
// 58E354: using guessed type int dword_58E354;
// 590400: using guessed type int dword_590400;
// 590404: using guessed type char loggingDebug;
// 590408: using guessed type pthread_mutex_t stru_590408;
// 592460: using guessed type int dword_592460;
// 5955C8: using guessed type int dword_5955C8[];
// 5955CC: using guessed type int dword_5955CC;
// 5955D0: using guessed type int dword_5955D0;
// 99CD98: using guessed type _QWORD qword_99CD98[1024];
// 99ED98: using guessed type _DWORD dword_99ED98[8];
// 99EE08: using guessed type __int64 qword_99EE08;
// 12620: using guessed type unsigned int var_A3C[6];

//----- (00013C20) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __noreturn start(void (*a1)(void), int a2, int a3, int a4, ...)
{
  int v4; // [sp-4h] [bp-4h]
  va_list va; // [sp+0h] [bp+0h] BYREF

  va_start(va, a4);
  _libc_start_main(main, v4, (char **)va, (void (*)(void))init, nullsub_16, a1, va);
  abort();
}
// 13C2A: positive sp value 4 has been found
// 13C3C: variable 'v4' is possibly undefined

//----- (00013C50) --------------------------------------------------------
int check_and_initialize_gmon()
{
  int initialization_status; // r0

  if ( &__gmon_start__ )
    return _gmon_start__();
  return initialization_status;
}
// 1221C: using guessed type int _gmon_start__(void);

//----- (00013C74) --------------------------------------------------------
void *get_unk_7F78C_ptr()
{
  return &unk_7F78C;
}

//----- (00013C98) --------------------------------------------------------
__int64 get_memory_address()
{
  __int64 memory_address; // r0

  LODWORD(memory_address) = &unk_7F78C;
  HIDWORD(memory_address) = 0;
  return memory_address;
}

//----- (00013CC4) --------------------------------------------------------
void *initialize_once()
{
  void *initialization_result; // r0

  if ( !byte_7F7A0 )
  {
    initialization_result = get_unk_7F78C_ptr();
    byte_7F7A0 = 1;
  }
  return initialization_result;
}
// 7F7A0: using guessed type char byte_7F7A0;

//----- (00013CE0) --------------------------------------------------------
int __fastcall updateFanSpeeds(unsigned int thresholdSpeed)
{
  unsigned int fanIndex; // r4
  int isFanSpeedValid; // r1
  unsigned int fanSpeed; // r0
  bool hasMoreFans; // cc
  int result; // r0
  int readFanSpeed; // r0
  int actualFanSpeed; // r6
  char logBuffer[2080]; // [sp+8h] [bp-820h] BYREF

  for ( fanIndex = 0; ; ++fanIndex )
  {
    hasMoreFans = get_global_fan_count() > fanIndex;
    result = (unsigned __int8)fanIndex;
    if ( !hasMoreFans )
      break;
    readFanSpeed = get_scaled_frequency((unsigned __int8)fanIndex);
    actualFanSpeed = readFanSpeed;
    if ( readFanSpeed >= 0 )
    {
      if ( (unsigned int)globalLogLevel > 4 )
      {
        snprintf(logBuffer, 2048u, "fan[%u] speed[%u]\n", (unsigned __int8)fanIndex, readFanSpeed);
        logMessage(4, logBuffer, 0);
      }
      sub_1E3D4((unsigned __int8)fanIndex, actualFanSpeed);
      if ( actualFanSpeed > 9999
        || (isFanSpeedValid = 1, fanSpeed = (unsigned __int8)fanIndex, thresholdSpeed > actualFanSpeed) )
      {
        fanSpeed = (unsigned __int8)fanIndex;
        isFanSpeedValid = 0;
      }
      set_fan_speed(fanSpeed, isFanSpeedValid);
    }
  }
  return result;
}
// 7EB9C: using guessed type int globalLogLevel;

//----- (00013DA4) --------------------------------------------------------
int __fastcall checkFanStatus(unsigned int fanFlag, int checkContinuous)
{
  int continuousCheckCounter; // r4
  int remainingCheckAttempts; // r4
  int currentFanSpeed; // r5
  int lastFanSpeed; // r4
  int totalActiveFans; // r5
  int *fanCheckCounter; // r6
  int activeFanIndex; // r5
  int fanID; // r9
  int fanSpeed; // r0
  int detectedFanSpeed; // r4
  int errorFanSpeed; // r4
  int fanErrorCode; // r0
  int fanCounter; // r4
  int fanIndex; // r5
  int measuredFanSpeed; // r0
  char logBuffer[2080]; // [sp+8h] [bp-820h] BYREF

  continuousCheckCounter = checkContinuous;
  if ( checkContinuous )
  {
    remainingCheckAttempts = 10;
    do
    {
      updateFanSpeeds(fanFlag);
      currentFanSpeed = get_active_fan_count();
      if ( currentFanSpeed >= get_global_fan_count() )
        break;
      get_next_sleep_interval();
      --remainingCheckAttempts;
    }
    while ( remainingCheckAttempts );
    lastFanSpeed = get_active_fan_count();
    if ( lastFanSpeed >= get_global_fan_count() )
    {
LABEL_6:
      update_status_flag(0);
      return 0;
    }
  }
  else
  {
    updateFanSpeeds(fanFlag);
    totalActiveFans = get_active_fan_count();
    LOWORD(fanCheckCounter) = (unsigned __int16)&dword_7F7A4;
    if ( totalActiveFans < get_global_fan_count() )
    {
      HIWORD(fanCheckCounter) = (unsigned int)&dword_7F7A4 >> 16;
      ++*fanCheckCounter;
      while ( 1 )
      {
        activeFanIndex = (unsigned __int8)continuousCheckCounter++;
        if ( activeFanIndex >= get_global_fan_count() )
          break;
        if ( (unsigned int)globalLogLevel > 3 )
        {
          fanID = *fanCheckCounter;
          fanSpeed = get_fan_speed(activeFanIndex);
          snprintf(
            logBuffer,
            2048u,
            "conti_check_count:%d, fan_id = %d, fan_speed = %d\n",
            fanID,
            activeFanIndex,
            fanSpeed);
          logMessage(3, logBuffer, 0);
        }
      }
    }
    else
    {
      HIWORD(fanCheckCounter) = 7;
      *fanCheckCounter = 0;
    }
    detectedFanSpeed = get_active_fan_count();
    if ( detectedFanSpeed >= get_global_fan_count() || (unsigned int)*fanCheckCounter <= 9 )
      goto LABEL_6;
  }
  if ( (unsigned int)globalLogLevel > 1 )
  {
    errorFanSpeed = get_active_fan_count();
    fanErrorCode = get_global_fan_count();
    snprintf(logBuffer, 2048u, "Error, fan lost, only find %d (< %d)\n", errorFanSpeed, fanErrorCode);
    logMessage(1, logBuffer, 0);
  }
  fanCounter = 0;
  while ( 1 )
  {
    fanIndex = (unsigned __int8)fanCounter++;
    if ( fanIndex >= get_global_fan_count() )
      break;
    if ( (unsigned int)globalLogLevel > 3 )
    {
      measuredFanSpeed = get_fan_speed(fanIndex);
      snprintf(logBuffer, 2048u, "fan_id = %d, fan_speed = %d\n", fanIndex, measuredFanSpeed);
      logMessage(3, logBuffer, 0);
    }
  }
  generate_error_message(10, 255);
  update_status_flag(1);
  handle_error_with_logging(7u, "fan lost");
  return -1;
}
// 7EB9C: using guessed type int globalLogLevel;
// 7F7A4: using guessed type int dword_7F7A4;

//----- (00013FB0) --------------------------------------------------------
int __fastcall setFanPWM(int desired_pwm_value)
{
  int result; // r0
  char logBuffer[2064]; // [sp+0h] [bp-810h] BYREF

  result = dword_7F7A8;
  if ( !dword_7F7A8 )
  {
    result = increment_param_check_initialized(dword_7F7A8);
    dword_7F7A8 = result;
  }
  if ( result < 0 )
  {
    if ( loggingDebug || loggingVerbose || loggingThreshold > 2 )
    {
      strcpy(logBuffer, "pwm for fan init error");
      return logMessage(3, logBuffer, 0);
    }
  }
  else if ( desired_pwm_value != dword_7F7AC )
  {
    if ( (unsigned int)globalLogLevel > 4 )
    {
      snprintf(logBuffer, 2048u, "set pwm = %d", desired_pwm_value);
      logMessage(4, logBuffer, 0);
      result = dword_7F7A8;
    }
    sub_4110C(result, desired_pwm_value);
    result = set_status_led_state(desired_pwm_value);
    dword_7F7AC = desired_pwm_value;
  }
  return result;
}
// 7EB9C: using guessed type int globalLogLevel;
// 7EBA0: using guessed type int loggingThreshold;
// 7F7A8: using guessed type int dword_7F7A8;
// 7F7AC: using guessed type int dword_7F7AC;
// 482A5C: using guessed type char loggingVerbose;
// 590404: using guessed type char loggingDebug;

//----- (000140E4) --------------------------------------------------------
int checkFrontFanStatus()
{
  char logBuffer[2056]; // [sp+0h] [bp-808h] BYREF

  if ( (unsigned int)globalLogLevel > 3 )
  {
    strcpy(logBuffer, "Note: front fan is power on!\n");
    logMessage(3, logBuffer, 0);
  }
  return get_error_code_sum(0);
}
// 7EB9C: using guessed type int globalLogLevel;

//----- (00014148) --------------------------------------------------------
int turnOffFrontFan()
{
  char logBuffer[2056]; // [sp+0h] [bp-808h] BYREF

  if ( (unsigned int)globalLogLevel > 3 )
  {
    strcpy(logBuffer, "Note: front fan is power off!\n");
    logMessage(3, logBuffer, 0);
  }
  return get_total_error_count(0);
}
// 7EB9C: using guessed type int globalLogLevel;

//----- (000141B4) --------------------------------------------------------
int turnOnRearFan()
{
  char logBuffer[2056]; // [sp+0h] [bp-808h] BYREF

  if ( (unsigned int)globalLogLevel > 3 )
  {
    strcpy(logBuffer, "Note: rear fan is power on!\n");
    logMessage(3, logBuffer, 0);
  }
  return get_error_code_sum(1);
}
// 7EB9C: using guessed type int globalLogLevel;

//----- (00014218) --------------------------------------------------------
int powerOffRearFan()
{
  char logBuffer[2056]; // [sp+0h] [bp-808h] BYREF

  if ( (unsigned int)globalLogLevel > 3 )
  {
    strcpy(logBuffer, "Note: rear fan is power off!\n");
    logMessage(3, logBuffer, 0);
  }
  return get_total_error_count(1);
}
// 7EB9C: using guessed type int globalLogLevel;

//----- (0001427C) --------------------------------------------------------
int __fastcall sub_1427C(int a1, int a2)
{
  int v4; // r4
  int ASICRegister; // r5

  v4 = 8;
  do
  {
    ASICRegister = ReadASICRegister(28, a1, a2);
    if ( ASICRegister )
      break;
    usleep(1000u);
    --v4;
  }
  while ( v4 );
  return ASICRegister;
}

//----- (000142BC) --------------------------------------------------------
int __fastcall sub_142BC(int a1, int a2, int a3, int a4, unsigned __int8 *a5)
{
  int v5; // r6
  int j; // r8
  __int16 v10; // r10
  bool v11; // zf
  int v13; // r11
  int i; // r10
  __int16 v15; // r8

  v5 = a4;
  if ( a4 )
  {
    v13 = 2;
    for ( i = 0; ; i = 1 )
    {
      wait_for_asic_ready(a2, a1);
      select_function(152u, a3, *a5, 1, a2, a1);
      wait_for_asic_ready(a2, a1);
      usleep(1000u);
      wait_for_asic_ready(a2, a1);
      select_function(152u, a3, 0, 0, a2, a1);
      v15 = wait_for_asic_ready(a2, a1);
      usleep(1000u);
      if ( HIBYTE(v15) == a3 || (unsigned __int8)v15 == *a5 )
        break;
      v11 = v13 == 1;
      v13 = 1;
      if ( v11 )
        return 0;
    }
    if ( !i )
      return v5;
    return 0;
  }
  for ( j = 2; ; j = 1 )
  {
    wait_for_asic_ready(a2, a1);
    select_function(152u, a3, 0, 0, a2, a1);
    usleep(1000u);
    v10 = wait_for_asic_ready(a2, a1);
    usleep(1000u);
    if ( HIBYTE(v10) == a3 )
      break;
    v11 = j == 1;
    v5 = 1;
    if ( v11 )
      return 0;
  }
  if ( v5 || !(_BYTE)v10 )
    return 0;
  *a5 = v10;
  return 1;
}

//----- (00014434) --------------------------------------------------------
int check_miner_status()
{
  if ( get_global_status() )
    return get_global_status();
  else
    return sub_1E19C();
}

//----- (00014454) --------------------------------------------------------
int __fastcall readTemperatureSensor(int chainId, int sensorIndex, unsigned int sensorType, int sensorModel)
{
  int sensorRegister; // r5
  char *sensorInfo; // r3
  unsigned __int8 temperature; // [sp+17h] [bp-821h] BYREF
  char logContext[2080]; // [sp+18h] [bp-820h] BYREF

  if ( calibrationFactor )
  {
    if ( get_global_buffer_value(chainId) )
    {
      sensorRegister = get_global_status();
      if ( sensorRegister )
      {
        if ( sensorIndex >= check_miner_status() || sensorType > 1 )
        {
          if ( (unsigned int)globalLogLevel > 3 )
          {
            snprintf(
              logContext,
              2048u,
              "%s invalid param. index = %d, type = %d, model = %d on chain %d",
              "read_sensor_on_asic",
              sensorIndex,
              sensorModel,
              sensorType,
              chainId);
            logMessage(3, logContext, 0);
            return 255;
          }
        }
        else
        {
          temperature = -1;
          sensorInfo = &aReadSensorOnAs[16 * sensorType];
          if ( !sensorModel )
            sensorRegister = (unsigned __int8)sensorInfo[29];
          if ( sensorModel )
            sensorRegister = (unsigned __int8)sensorInfo[30];
          if ( configure_asic(
                 chainId,
                 (unsigned __int8)(*(_DWORD *)(dword_7F7B4 + 4 * sensorIndex) * calibrationFactor),
                 sensorRegister,
                 0,
                 &temperature) )
          {
            return temperature - 64;
          }
          if ( (unsigned int)globalLogLevel > 3 )
          {
            snprintf(
              logContext,
              2048u,
              "read temp sensor failed: chain = %d, sensor pos = %d, address = %d, reg = %d\n",
              chainId,
              *(_DWORD *)(dword_7F7B4 + 4 * sensorIndex),
              calibrationFactor * *(_DWORD *)(dword_7F7B4 + 4 * sensorIndex),
              sensorRegister);
            logMessage(3, logContext, 0);
          }
        }
      }
      else if ( (unsigned int)globalLogLevel > 3 )
      {
        snprintf(logContext, 2048u, "%s chain %d ,index %d not connected", "read_sensor_on_asic", chainId, sensorIndex);
        logMessage(3, logContext, 0);
        return 255;
      }
    }
    else if ( (unsigned int)globalLogLevel > 4 )
    {
      snprintf(logContext, 2048u, "%s chain %d not pluged", "read_sensor_on_asic", chainId);
      logMessage(4, logContext, 0);
      return 255;
    }
  }
  else if ( (unsigned int)globalLogLevel > 3 )
  {
    strcpy(logContext, "can not read temp by asic before calibration");
    logMessage(3, logContext, calibrationFactor);
    return 255;
  }
  return 255;
}
// 7EB9C: using guessed type int globalLogLevel;
// 7F7B0: using guessed type int calibrationFactor;
// 7F7B4: using guessed type int dword_7F7B4;

//----- (000146C8) --------------------------------------------------------
int __fastcall configureTemperatureSensor(int chainIndex)
{
  int v2; // r7
  int v3; // r4
  unsigned int v4; // r5
  int v5; // r6
  unsigned int v7; // r5
  unsigned int v8; // r3
  int v9; // r6
  int v10; // r4
  char TemperatureSensor; // r4
  char v12; // r0
  int v13; // [sp+Ch] [bp-84Ch]
  int v14; // [sp+10h] [bp-848h]
  int v15; // [sp+14h] [bp-844h]
  const char *v16; // [sp+24h] [bp-834h]
  unsigned __int8 v17; // [sp+2Eh] [bp-82Ah] BYREF
  unsigned __int8 v18; // [sp+2Fh] [bp-829h] BYREF
  char logBuffer[2088]; // [sp+30h] [bp-828h] BYREF

  v2 = 0;
  v14 = 4 * chainIndex;
  v16 = 0;
LABEL_2:
  if ( check_miner_status() <= v2 )
  {
    v8 = globalLogLevel;
    goto LABEL_29;
  }
  v15 = 4 * v2;
  v3 = 4;
  v4 = (unsigned __int8)(*(_DWORD *)(dword_7F7B4 + 4 * v2) * calibrationFactor);
  initialize_mining_with_config((unsigned __int8)chainIndex, v4, 0);
  usleep(10000u);
  while ( 1 )
  {
    logBuffer[0] = 0;
    configure_asic(chainIndex, v4, 254, 0, (unsigned __int8 *)logBuffer);
    if ( logBuffer[0] == 26 )
      break;
    if ( !--v3 )
    {
      v5 = 4;
      do
      {
        logBuffer[0] = 0;
        configure_asic(chainIndex, v4, 254, 0, (unsigned __int8 *)logBuffer);
        if ( logBuffer[0] == 85 )
        {
          v7 = 1;
          v16 = "TMP451";
          goto LABEL_13;
        }
        --v5;
      }
      while ( v5 );
      if ( (unsigned int)globalLogLevel > 3 )
      {
        snprintf(
          logBuffer,
          2048u,
          "sensor %d @ chain %d manufacture id unknown",
          *(_DWORD *)(dword_7F7B4 + 4 * v2),
          chainIndex);
        logMessage(3, logBuffer, 0);
      }
      return -1;
    }
  }
  v7 = 0;
  v16 = "NCT218";
LABEL_13:
  if ( (unsigned int)globalLogLevel > 3 )
  {
    snprintf(logBuffer, 2048u, "sensor %d @ chain %d is %s", *(_DWORD *)(dword_7F7B4 + 4 * v2), chainIndex, v16);
    logMessage(3, logBuffer, 0);
  }
  v17 = 4;
  if ( calibrationFactor )
  {
    if ( !get_global_status() )
    {
      if ( (unsigned int)globalLogLevel <= 3 )
        return 0;
      snprintf(logBuffer, 2048u, "%s chain %d ,index %d not connected", "set_ext_mode", chainIndex, v2);
      logMessage(3, logBuffer, 0);
      goto LABEL_22;
    }
    if ( !configure_asic(
            chainIndex,
            (unsigned __int8)(*(_DWORD *)(dword_7F7B4 + 4 * v2) * calibrationFactor),
            (unsigned __int8)aReadSensorOnAs[16 * v7 + 31],
            1,
            &v17) )
    {
      if ( (unsigned int)globalLogLevel <= 3 )
        return 0;
      snprintf(
        logBuffer,
        2048u,
        "set ext mode failed for senser %d @ chain %d",
        *(_DWORD *)(dword_7F7B4 + 4 * v2),
        chainIndex);
      logMessage(3, logBuffer, 0);
      goto LABEL_22;
    }
    v9 = 6 * v2;
    LOBYTE(v13) = 11;
    while ( 1 )
    {
      TemperatureSensor = readTemperatureSensor(chainIndex, v2, v7, 0);
      *(_WORD *)(*(_DWORD *)(*(_DWORD *)(dword_7F7B8 + v14) + 4) + v9 + 2) = TemperatureSensor;
      v12 = readTemperatureSensor(chainIndex, v2, v7, 1);
      v10 = (char)(TemperatureSensor - v12);
      *(_WORD *)(*(_DWORD *)(*(_DWORD *)(dword_7F7B8 + v14) + 8) + v9 + 2) = v12;
      if ( (unsigned __int8)(v10 + 2) <= 4u )
      {
        if ( (unsigned int)globalLogLevel <= 4 )
        {
LABEL_46:
          ++v2;
          goto LABEL_2;
        }
        ++v2;
        snprintf(
          logBuffer,
          2048u,
          "sensor %d @ chain %d chip_temp_offset less than 2, no need to set offset",
          *(_DWORD *)(dword_7F7B4 + v15),
          chainIndex);
        logMessage(4, logBuffer, 0);
        goto LABEL_2;
      }
      v18 = v10;
      if ( calibrationFactor )
      {
        if ( get_global_status() )
        {
          if ( configure_asic(
                 chainIndex,
                 (unsigned __int8)(*(_DWORD *)(dword_7F7B4 + 4 * v2) * calibrationFactor),
                 (unsigned __int8)aReadSensorOnAs[16 * v7 + 32],
                 1,
                 &v18) )
          {
            if ( (unsigned int)globalLogLevel > 3 )
            {
              snprintf(
                logBuffer,
                2048u,
                "sensor %d @ chain %d, offset = %d",
                *(_DWORD *)(dword_7F7B4 + 4 * v2),
                chainIndex,
                (char)v10);
LABEL_43:
              logMessage(3, logBuffer, 0);
              if ( (v10 & 128u) != 0 )
                v10 = -(char)v10;
              if ( v10 <= 2 )
                goto LABEL_46;
              goto LABEL_37;
            }
          }
          else if ( (unsigned int)globalLogLevel > 3 )
          {
            snprintf(
              logBuffer,
              2048u,
              "set offset failed for senser %d @ chain %d",
              *(_DWORD *)(dword_7F7B4 + 4 * v2),
              chainIndex);
            logMessage(3, logBuffer, 0);
          }
        }
        else if ( (unsigned int)globalLogLevel > 3 )
        {
          snprintf(logBuffer, 2048u, "%s chain %d ,index %d not connected", "set_sensor_offset", chainIndex, v2);
          goto LABEL_43;
        }
      }
      else if ( (unsigned int)globalLogLevel > 3 )
      {
        strcpy(logBuffer, "can not set ext mode before calibration");
        logMessage(3, logBuffer, 0);
      }
      if ( (v10 & 128u) != 0 )
        v10 = -(char)v10;
      if ( v10 <= 2 )
        goto LABEL_46;
LABEL_37:
      v13 = (unsigned __int8)(v13 - 1);
      if ( !v13 )
        goto LABEL_46;
    }
  }
  if ( (unsigned int)globalLogLevel <= 3 )
    return 0;
  strcpy(logBuffer, "can not set ext mode before calibration");
  logMessage(3, logBuffer, 0);
LABEL_22:
  if ( (unsigned int)globalLogLevel <= 3 )
    return 0;
  snprintf(
    logBuffer,
    2048u,
    "sensor %d @ chain %d fail to set to ext mode",
    *(_DWORD *)(dword_7F7B4 + 4 * v2),
    chainIndex);
  logMessage(3, logBuffer, 0);
  v8 = globalLogLevel;
LABEL_29:
  if ( v8 > 3 )
  {
    snprintf(logBuffer, 2048u, "chain %d temp sensor %s\n", chainIndex, v16);
    logMessage(3, logBuffer, 0);
  }
  return 0;
}
// 7EB9C: using guessed type int globalLogLevel;
// 7F7B0: using guessed type int calibrationFactor;
// 7F7B4: using guessed type int dword_7F7B4;
// 7F7B8: using guessed type int dword_7F7B8;

//----- (00014CC0) --------------------------------------------------------
int __fastcall get_temperature(int asic_index, int sensor_group, int sensor_index)
{
  int temperature; // r4

  if ( sensor_group )
  {
    if ( !get_global_status() || check_miner_status() <= sensor_index || !dword_7F7BC )
      return 255;
  }
  else if ( sub_1E19C() <= sensor_index )
  {
    return 255;
  }
  if ( !dword_7F7B8 )
    return 255;
  pthread_mutex_lock(&stru_7F7C0);
  temperature = *(__int16 *)(*(_DWORD *)(*(_DWORD *)(dword_7F7B8 + 4 * asic_index) + 4 * sensor_group)
                           + 6 * sensor_index
                           + 2);
  pthread_mutex_unlock(&stru_7F7C0);
  return temperature;
}
// 7F7B8: using guessed type int dword_7F7B8;
// 7F7BC: using guessed type int dword_7F7BC;

//----- (00014D60) --------------------------------------------------------
int __fastcall sub_14D60(int a1, int a2, int a3)
{
  int v6; // r0
  int v7; // r4

  pthread_mutex_lock(&stru_7F7C0);
  if ( a2 )
    v6 = check_miner_status();
  else
    v6 = sub_1E19C();
  if ( a1 > 3 || a3 >= v6 )
    v7 = 0;
  else
    v7 = *(__int16 *)(*(_DWORD *)(*(_DWORD *)(dword_7F7B8 + 4 * a1) + 4 * a2) + 6 * a3 + 4);
  pthread_mutex_unlock(&stru_7F7C0);
  return v7;
}
// 7F7B8: using guessed type int dword_7F7B8;

//----- (00014DD8) --------------------------------------------------------
int __fastcall get_hardware_error_code(int miner_index, int error_type, int threshold)
{
  unsigned int is_not_eligible; // r0
  int error_code; // r4

  if ( get_global_buffer_value(miner_index) )
    is_not_eligible = (unsigned int)threshold >> 31;
  else
    is_not_eligible = 1;
  if ( !is_not_eligible )
  {
    if ( error_type == 1 )
    {
      if ( check_miner_status() > threshold )
      {
LABEL_9:
        pthread_mutex_lock(&stru_7F7C0);
        error_code = *(__int16 *)(*(_DWORD *)(*(_DWORD *)(dword_7F7B8 + 4 * miner_index) + 4 * error_type)
                                + 6 * threshold
                                + 2);
        pthread_mutex_unlock(&stru_7F7C0);
        return error_code;
      }
    }
    else if ( error_type == 2 )
    {
      if ( check_miner_status() > threshold && get_global_status() )
        goto LABEL_9;
    }
    else if ( error_type || sub_1E19C() > threshold )
    {
      goto LABEL_9;
    }
  }
  return 255;
}
// 7F7B8: using guessed type int dword_7F7B8;

//----- (00014E90) --------------------------------------------------------
const char *__fastcall get_thermometer_type(int sensor_board_index, int sensor_index)
{
  if ( sensor_index )
    return *(const char **)&aReadSensorOnAs[16
                                          * **(__int16 **)(*(_DWORD *)(dword_7F7B8 + 4 * sensor_board_index)
                                                         + 4 * sensor_index)
                                          + 20];
  else
    return "LM75A";
}
// 7F7B8: using guessed type int dword_7F7B8;

//----- (00014ED0) --------------------------------------------------------
int __fastcall is_device_id_active(int device_id)
{
  int current_index; // r4
  int current_device_id; // r3

  current_index = 0;
  while ( check_miner_status() > current_index )
  {
    current_device_id = *(_DWORD *)(dword_7F7B4 + 4 * current_index++);
    if ( current_device_id == device_id && get_global_status() )
      return 1;
  }
  return 0;
}
// 7F7B4: using guessed type int dword_7F7B4;

//----- (00014F20) --------------------------------------------------------
int update_miner_calibration()
{
  int miner_index; // r5
  int i; // r4

  for ( miner_index = 0; miner_index != 4; ++miner_index )
  {
    if ( get_global_buffer_value(miner_index) )
    {
      for ( i = 0; check_miner_status() > i; ++i )
      {
        if ( get_global_status() )
        {
          initialize_miner_register(
            (unsigned __int8)miner_index,
            (unsigned __int8)(*(_DWORD *)(dword_7F7B4 + 4 * i) * calibrationFactor));
          usleep(10000u);
        }
      }
    }
  }
  return 0;
}
// 7F7B0: using guessed type int calibrationFactor;
// 7F7B4: using guessed type int dword_7F7B4;

//----- (00014FA4) --------------------------------------------------------
int initTemperatureMonitoring()
{
  int sensorCount; // r4
  int maxSensorCount; // r6
  int adjustedSize; // r8
  char *dynamicBuffer1; // r9
  _DWORD *dynamicBuffer2; // r4
  char *sensorDataArray; // r0
  _DWORD *tempBuffer; // r3
  int index; // r2
  char *bufferOffset; // r4
  _DWORD *tempIter; // r6
  char *currentSensorData; // r1
  int dataSize; // r12
  int i; // r4
  int sensorReading; // r0
  int sensorIdx; // r6
  int sensorInfoCount; // r0
  int j; // r4
  pthread_attr_t threadAttributes[57]; // [sp+0h] [bp-820h] BYREF

  sensorCount = check_miner_status();
  if ( sensorCount <= sub_1E19C() )
    maxSensorCount = sub_1E19C();
  else
    maxSensorCount = check_miner_status();
  if ( (unsigned int)globalLogLevel > 3 )
  {
    snprintf(threadAttributes[0].__size, 2048u, "max sensor num = %d", maxSensorCount);
    logMessage(3, threadAttributes[0].__size, 0);
  }
  adjustedSize = 72 * maxSensorCount;
  dynamicBuffer1 = (char *)malloc(16u);
  dword_7F7B8 = (int)dynamicBuffer1;
  dynamicBuffer2 = malloc(48u);
  sensorDataArray = (char *)calloc(72 * maxSensorCount, 1u);
  tempBuffer = dynamicBuffer2;
  index = 6 * maxSensorCount;
  bufferOffset = dynamicBuffer1 - 4;
  tempIter = tempBuffer + 12;
  currentSensorData = sensorDataArray;
  do
  {
    *((_DWORD *)bufferOffset + 1) = tempBuffer;
    bufferOffset += 4;
    dataSize = (int)&currentSensorData[index + index];
    *tempBuffer = currentSensorData;
    tempBuffer[1] = &currentSensorData[index];
    tempBuffer[2] = dataSize;
    tempBuffer += 3;
    currentSensorData = (char *)(index + dataSize);
  }
  while ( tempIter != tempBuffer );
  i = 0;
  dword_7F7D8 = (int)&sensorDataArray[adjustedSize];
  sensorReading = check_miner_status();
  dword_7F7B4 = (int)malloc(4 * sensorReading);
  while ( check_miner_status() > i )
  {
    sensorIdx = dword_7F7B4;
    *(_DWORD *)(sensorIdx + 4 * i) = get_control_status(i);
    ++i;
  }
  sensorInfoCount = sub_1E19C();
  j = 0;
  dword_7F7DC = (int)malloc(sensorInfoCount);
  while ( sub_1E19C() > j )
  {
    *(_BYTE *)(dword_7F7DC + j) = get_miner_temperature(j);
    ++j;
  }
  pthread_attr_init(threadAttributes);
  pthread_attr_setstacksize(threadAttributes, 1048576u);
  dword_7F7E0 = 1;
  pthread_create(&newthread, threadAttributes, (void *(*)(void *))monitorTemperatureThread, 0);
  return pthread_detach(newthread);
}
// 7EB9C: using guessed type int globalLogLevel;
// 7F7B4: using guessed type int dword_7F7B4;
// 7F7B8: using guessed type int dword_7F7B8;
// 7F7D8: using guessed type int dword_7F7D8;
// 7F7DC: using guessed type int dword_7F7DC;
// 7F7E0: using guessed type int dword_7F7E0;

//----- (00015150) --------------------------------------------------------
int check_and_log_temperature_uninitialized()
{
  int uninitialized_temp_info_result; // r0
  char log_buffer[2064]; // [sp+0h] [bp-810h] BYREF

  if ( dword_7F7E0 )
  {
    if ( (unsigned int)globalLogLevel > 3 )
    {
      strcpy(log_buffer, "uninit_temp_info");
      uninitialized_temp_info_result = logMessage(3, log_buffer, 0);
      dword_7F7E0 = 0;
      if ( (unsigned int)globalLogLevel > 3 )
      {
        strcpy(log_buffer, "do not read temp anymore...");
        return logMessage(3, log_buffer, 0);
      }
    }
    else
    {
      dword_7F7E0 = 0;
    }
  }
  return uninitialized_temp_info_result;
}
// 7EB9C: using guessed type int globalLogLevel;
// 7F7E0: using guessed type int dword_7F7E0;

//----- (00015210) --------------------------------------------------------
int __fastcall calibrateTemperatureSensors(int calibrationValue)
{
  int result; // r0
  int chainIndex; // r4
  char logBuffer[2064]; // [sp+0h] [bp-810h] BYREF

  result = get_global_status();
  if ( result )
  {
    chainIndex = 0;
    pthread_mutex_lock(&stru_7F7C0);
    calibrationFactor = calibrationValue;
    update_miner_calibration();
    while ( !get_global_buffer_value(chainIndex) || !configureTemperatureSensor(chainIndex) )
    {
      if ( ++chainIndex == 4 )
      {
        dword_7F7BC = 1;
        pthread_mutex_unlock(&stru_7F7C0);
        return 0;
      }
    }
    if ( (unsigned int)globalLogLevel > 3 )
    {
      snprintf(logBuffer, 2048u, "calibration sensor on chain %d failed", chainIndex);
      logMessage(3, logBuffer, 0);
    }
    dword_7F7BC = 1;
    pthread_mutex_unlock(&stru_7F7C0);
    return -1;
  }
  return result;
}
// 7EB9C: using guessed type int globalLogLevel;
// 7F7B0: using guessed type int calibrationFactor;
// 7F7BC: using guessed type int dword_7F7BC;

//----- (000152F0) --------------------------------------------------------
int __fastcall get_board_temperature(int sensor_index, int temperature_ptr)
{
  const char *shared_variable; // r0
  const char *shared_value2; // r0

  shared_variable = (const char *)get_shared_variable();
  if ( !strcmp(shared_variable, "BHB28601") )
    return get_temperature(sensor_index, 1, temperature_ptr);
  shared_value2 = (const char *)get_shared_variable();
  if ( !strcmp(shared_value2, "BHB28501") )
    return get_temperature(sensor_index, 1, temperature_ptr);
  else
    return get_temperature(sensor_index, 0, temperature_ptr);
}

//----- (00015354) --------------------------------------------------------
int __fastcall calculate_temperature_adjustment(int sensor_index, int some_parameter)
{
  int temperature_adjustment; // r0

  if ( get_global_status() )
    return get_temperature(sensor_index, 1, some_parameter);
  temperature_adjustment = get_board_temperature(sensor_index, some_parameter);
  if ( temperature_adjustment != 255 )
    return (__int16)(temperature_adjustment + 10);
  return temperature_adjustment;
}

//----- (000153A0) --------------------------------------------------------
int __fastcall get_adjusted_temperature(int sensor_id, int temperature_unit)
{
  int temperature_reading; // r0

  if ( get_global_status() )
    return get_temperature(sensor_id, 2, temperature_unit);
  temperature_reading = get_board_temperature(sensor_id, temperature_unit);
  if ( temperature_reading != 255 )
    return (__int16)(temperature_reading + 15);
  return temperature_reading;
}

//----- (000153EC) --------------------------------------------------------
int __fastcall get_max_sensor_value(int sensor_array, unsigned int mode)
{
  int invalid_conditions; // r0
  int max_value; // r5
  int sensor_count; // r8
  int sensor_index; // r4
  int adjusted_temperature; // r0

  invalid_conditions = get_global_buffer_value(sensor_array) == 0;
  if ( mode > 2 )
    invalid_conditions |= 1u;
  if ( invalid_conditions )
    return 255;
  sensor_count = mode ? check_miner_status() : sub_1E19C();
  if ( sensor_count <= 0 )
    return 255;
  max_value = 255;
  for ( sensor_index = 0; sensor_index != sensor_count; ++sensor_index )
  {
    if ( mode )
    {
      if ( mode == 1 )
        adjusted_temperature = calculate_temperature_adjustment(sensor_array, (unsigned __int8)sensor_index);
      else
        adjusted_temperature = get_adjusted_temperature(sensor_array, (unsigned __int8)sensor_index);
    }
    else
    {
      adjusted_temperature = get_board_temperature(sensor_array, (unsigned __int8)sensor_index);
    }
    if ( adjusted_temperature != 255 )
    {
      if ( max_value == 255 )
      {
        max_value = adjusted_temperature;
      }
      else if ( max_value < adjusted_temperature )
      {
        max_value = adjusted_temperature;
      }
    }
  }
  return max_value;
}

//----- (000154A8) --------------------------------------------------------
int __fastcall get_sensor_max_value_based_on_hw_version(int sensor_index)
{
  const char *shared_variable; // r0
  const char *hardware_version_second; // r0

  shared_variable = (const char *)get_shared_variable();
  if ( !strcmp(shared_variable, "BHB28601") )
    return (__int16)get_max_sensor_value(sensor_index, 1u);
  hardware_version_second = (const char *)get_shared_variable();
  if ( !strcmp(hardware_version_second, "BHB28501") )
    return (__int16)get_max_sensor_value(sensor_index, 1u);
  else
    return (__int16)get_max_sensor_value(sensor_index, 0);
}

//----- (00015508) --------------------------------------------------------
int get_maximum_temperature()
{
  int temperature_index; // r4
  int max_temperature; // r5
  int current_temperature; // r0

  temperature_index = 0;
  max_temperature = 255;
  do
  {
    current_temperature = get_sensor_max_value_based_on_hw_version(temperature_index);
    if ( current_temperature != 255 )
    {
      if ( max_temperature == 255 )
      {
        max_temperature = current_temperature;
      }
      else
      {
        if ( current_temperature >= max_temperature )
          LOWORD(max_temperature) = current_temperature;
        max_temperature = (__int16)max_temperature;
      }
    }
    ++temperature_index;
  }
  while ( temperature_index != 4 );
  return max_temperature;
}

//----- (00015550) --------------------------------------------------------
int __fastcall get_sensor_max_value(int sensor_id)
{
  return (__int16)get_max_sensor_value(sensor_id, 1u);
}

//----- (00015564) --------------------------------------------------------
int get_highest_temp_sensor_value()
{
  int sensor_index; // r4
  int highest_temp; // r5
  __int16 max_sensor_value; // r0

  sensor_index = 0;
  highest_temp = 255;
  do
  {
    max_sensor_value = get_max_sensor_value(sensor_index, 1u);
    if ( max_sensor_value != 255 )
    {
      if ( highest_temp == 255 )
      {
        highest_temp = max_sensor_value;
      }
      else if ( max_sensor_value >= highest_temp )
      {
        highest_temp = max_sensor_value;
      }
    }
    ++sensor_index;
  }
  while ( sensor_index != 4 );
  return highest_temp;
}

//----- (000155B0) --------------------------------------------------------
int __fastcall get_max_sensor_short_value(int sensor_index)
{
  return (__int16)get_max_sensor_value(sensor_index, 2u);
}

//----- (000155C4) --------------------------------------------------------
int get_highest_temperature()
{
  int sensor_index; // r4
  int highest_temperature; // r5
  __int16 max_sensor_value; // r0

  sensor_index = 0;
  highest_temperature = 255;
  do
  {
    max_sensor_value = get_max_sensor_value(sensor_index, 2u);
    if ( max_sensor_value != 255 )
    {
      if ( highest_temperature == 255 )
      {
        highest_temperature = max_sensor_value;
      }
      else if ( max_sensor_value >= highest_temperature )
      {
        highest_temperature = max_sensor_value;
      }
    }
    ++sensor_index;
  }
  while ( sensor_index != 4 );
  return highest_temperature;
}

//----- (00015610) --------------------------------------------------------
int __fastcall sub_15610(int a1, unsigned int a2)
{
  int v4; // r0
  int v5; // r5
  int v7; // r8
  int i; // r4
  int adjusted_temperature; // r0

  v4 = get_global_buffer_value(a1) == 0;
  if ( a2 > 2 )
    v4 |= 1u;
  if ( v4 )
    return 255;
  v7 = a2 ? check_miner_status() : sub_1E19C();
  if ( v7 <= 0 )
    return 255;
  v5 = 255;
  for ( i = 0; i != v7; ++i )
  {
    if ( a2 )
    {
      if ( a2 == 1 )
        adjusted_temperature = calculate_temperature_adjustment(a1, (unsigned __int8)i);
      else
        adjusted_temperature = get_adjusted_temperature(a1, (unsigned __int8)i);
    }
    else
    {
      adjusted_temperature = get_board_temperature(a1, (unsigned __int8)i);
    }
    if ( adjusted_temperature != 255 )
    {
      if ( v5 == 255 )
      {
        v5 = adjusted_temperature;
      }
      else if ( v5 >= adjusted_temperature )
      {
        v5 = adjusted_temperature;
      }
    }
  }
  return v5;
}

//----- (000156CC) --------------------------------------------------------
int __fastcall get_device_min_temperature(int device_id)
{
  const char *shared_variable; // r0
  const char *shared_variable_value2; // r0

  shared_variable = (const char *)get_shared_variable();
  if ( !strcmp(shared_variable, "BHB28601") )
    return (__int16)get_min_temperature(device_id, 1u);
  shared_variable_value2 = (const char *)get_shared_variable();
  if ( !strcmp(shared_variable_value2, "BHB28501") )
    return (__int16)get_min_temperature(device_id, 1u);
  else
    return (__int16)get_min_temperature(device_id, 0);
}

//----- (0001572C) --------------------------------------------------------
int get_minimum_temp()
{
  int sensor_index; // r5
  int min_temp; // r4
  int current_index; // r0
  int current_temp; // r0

  sensor_index = 0;
  min_temp = 255;
  do
  {
    current_index = sensor_index++;
    current_temp = get_device_min_temperature(current_index);
    if ( current_temp < min_temp )
      LOWORD(min_temp) = current_temp;
    min_temp = (__int16)min_temp;
  }
  while ( sensor_index != 4 );
  return (__int16)min_temp;
}

//----- (00015760) --------------------------------------------------------
int __fastcall get_miner_min_temperature(int miner_index)
{
  return (__int16)get_min_temperature(miner_index, 1u);
}

//----- (00015774) --------------------------------------------------------
int get_min_chip_temperature()
{
  int sensor_index; // r4
  int min_temperature; // r5
  __int16 current_temperature; // r0

  sensor_index = 0;
  min_temperature = 255;
  do
  {
    current_temperature = get_min_temperature(sensor_index++, 1u);
    if ( current_temperature < min_temperature )
      min_temperature = current_temperature;
  }
  while ( sensor_index != 4 );
  return min_temperature;
}

//----- (000157AC) --------------------------------------------------------
int __fastcall get_lowest_temp_from_miner(int miner_index)
{
  return (__int16)get_min_temperature(miner_index, 2u);
}

//----- (000157C0) --------------------------------------------------------
int get_min_device_temperature()
{
  int device_index; // r4
  int min_temperature; // r5
  __int16 current_temperature; // r0

  device_index = 0;
  min_temperature = 255;
  do
  {
    current_temperature = get_min_temperature(device_index++, 2u);
    if ( current_temperature < min_temperature )
      min_temperature = current_temperature;
  }
  while ( device_index != 4 );
  return min_temperature;
}

//----- (000157F8) --------------------------------------------------------
int __fastcall get_corrected_temperature_value(int sensor_index, int correction_flag)
{
  const char *model_identifier; // r0
  const char *rechecked_model_identifier; // r0

  model_identifier = (const char *)get_shared_variable();
  if ( !strcmp(model_identifier, "BHB28601") )
    return get_temperature_value(sensor_index, 1, correction_flag);
  rechecked_model_identifier = (const char *)get_shared_variable();
  if ( !strcmp(rechecked_model_identifier, "BHB28501") )
    return get_temperature_value(sensor_index, 1, correction_flag);
  else
    return get_temperature_value(sensor_index, 0, correction_flag);
}

//----- (0001585C) --------------------------------------------------------
int monitorTemperatureThread()
{
  int v0; // r9
  int v1; // r4
  const char *shared_variable; // r0
  _BOOL4 v3; // r5
  int v4; // r4
  int v5; // r6
  int v6; // r5
  int v7; // r12
  int v8; // r3
  __int64 v9; // r0
  int v10; // r2
  const char *v11; // r3
  int v12; // r12
  int v13; // r2
  int v14; // r8
  int v15; // r0
  int v16; // r7
  int v17; // r6
  int v18; // r5
  int v19; // r4
  int v20; // r8
  int v21; // r2
  int v22; // r5
  int v23; // r4
  const char *v24; // r0
  const char *v25; // r12
  _DWORD *logging_category; // r0
  int v27; // r5
  int v28; // r6
  int maximum_temperature; // r7
  int v30; // r4
  int highest_temperature; // r8
  char v32; // r0
  int v33; // r5
  char v34; // r0
  const char *v35; // r0
  int v36; // r6
  const char *v38; // r0
  int v39; // r3
  int v40; // r4
  size_t v41; // r0
  int v42; // r4
  size_t v43; // r0
  const char *v44; // r0
  int antminer_status_code; // r0
  bool v46; // zf
  int v47; // r4
  int v48; // r6
  int v49; // r0
  int device_min_temperature; // r0
  bool v51; // nf
  int v52; // r3
  int v53; // r12
  int chainIndex; // [sp+1Ch] [bp-86Ch]
  int v55; // [sp+20h] [bp-868h]
  int v56; // [sp+20h] [bp-868h]
  int TemperatureSensor; // [sp+2Ch] [bp-85Ch]
  __time_t v58; // [sp+40h] [bp-848h] BYREF
  int v59; // [sp+44h] [bp-844h]
  __time_t v60; // [sp+48h] [bp-840h] BYREF
  int v61; // [sp+4Ch] [bp-83Ch]
  _DWORD v62[4]; // [sp+50h] [bp-838h] BYREF
  char logBuffer[2088]; // [sp+60h] [bp-828h] BYREF

  prctl(15, "temp_mtr", 0, 0, 0);
  if ( (unsigned int)globalLogLevel > 3 )
  {
    strcpy(logBuffer, "temperature_monitor_thread start...");
    logMessage(3, logBuffer, 0);
    if ( dword_7F7E0 )
      goto startMonitoring;
exitMonitoring:
    if ( (unsigned int)globalLogLevel > 3 )
    {
      strcpy(logBuffer, "temp monitor thread exit");
      logMessage(3, logBuffer, 0);
    }
  }
  else if ( dword_7F7E0 )
  {
startMonitoring:
    TemperatureSensor = 0;
    while ( 1 )
    {
      for ( chainIndex = 0; chainIndex != 4; ++chainIndex )
      {
        if ( !get_global_buffer_value(chainIndex) )
          continue;
        v0 = 0;
        while ( 2 )
        {
          v1 = check_miner_status();
          if ( v1 > sub_1E19C() )
          {
            if ( v0 >= check_miner_status() )
              goto LABEL_36;
LABEL_9:
            shared_variable = (const char *)get_shared_variable();
            if ( !strcmp(shared_variable, "BHB28601") )
            {
              v3 = 1;
            }
            else
            {
              v38 = (const char *)get_shared_variable();
              v3 = strcmp(v38, "BHB28501") == 0;
            }
            v4 = v3 + 1;
            v5 = v3;
            v46 = !v3;
            v6 = 4 * v3;
            v55 = 6 * v0;
            if ( !v46 )
            {
LABEL_13:
              if ( !dword_7F7BC )
                goto LABEL_29;
LABEL_14:
              if ( !dword_7F7E8 && check_miner_status() > v0 )
              {
                pthread_mutex_lock(&stru_7F7EC);
                convert_timespec_to_custom_format(&v58);
                if ( v5 == 1 )
                {
                  TemperatureSensor = readTemperatureSensor(
                                        chainIndex,
                                        v0,
                                        *(__int16 *)(*(_DWORD *)(*(_DWORD *)(dword_7F7B8 + 4 * chainIndex) + 4) + 6 * v0),
                                        0);
                }
                else if ( v5 == 2 )
                {
                  TemperatureSensor = readTemperatureSensor(
                                        chainIndex,
                                        v0,
                                        *(__int16 *)(*(_DWORD *)(*(_DWORD *)(dword_7F7B8 + 4 * chainIndex) + 8) + 6 * v0),
                                        1);
                }
                convert_timespec_to_custom_format(&v60);
                v7 = v60 - v58;
                v8 = v61 - v59;
                if ( v61 - v59 < 0 )
                {
                  --v7;
                  v8 += 1000000;
                }
                if ( (unsigned int)globalLogLevel > 4 )
                {
                  v9 = 274877907LL * v8;
                  v10 = v8 >> 31;
                  v11 = "pcb";
                  v12 = (SHIDWORD(v9) >> 6) - v10 + 1000 * v7;
                  if ( v5 != 1 )
                    v11 = "chp";
                  snprintf(logBuffer, 2048u, "%s read %d on chain %d takes %ldms\n", v11, v0, chainIndex, v12);
                  logMessage(4, logBuffer, 0);
                }
                pthread_mutex_unlock(&stru_7F7EC);
                goto LABEL_26;
              }
              goto LABEL_29;
            }
            while ( 2 )
            {
              if ( sub_1E19C() <= v0 )
              {
                if ( dword_7F7BC )
                  goto LABEL_14;
LABEL_30:
                ++v4;
                v6 += 4;
                v5 = v4 - 1;
                if ( v4 != 1 )
                  goto LABEL_13;
                continue;
              }
              break;
            }
            convert_timespec_to_custom_format(&v58);
            if ( !get_global_buffer_value(chainIndex) )
            {
              if ( (unsigned int)globalLogLevel <= 4 )
                goto LABEL_98;
              snprintf(logBuffer, 2048u, "%s chain %d not pluged", "read_sensor_on_pic", chainIndex);
              TemperatureSensor = 255;
              logMessage(4, logBuffer, 0);
LABEL_99:
              convert_timespec_to_custom_format(&v60);
              v52 = v61 - v59 + (v61 - v59 < 0 ? 999424 : 0);
              v53 = v60 - v58;
              if ( v61 - v59 < 0 )
              {
                --v53;
                v52 += 576;
              }
              if ( (unsigned int)globalLogLevel > 4 )
              {
                snprintf(
                  logBuffer,
                  2048u,
                  "pic read %d on chain %d takes %ldms\n",
                  v0,
                  chainIndex,
                  v52 / 1000 + 1000 * v53);
                logMessage(4, logBuffer, 0);
              }
LABEL_26:
              pthread_mutex_lock(&stru_7F7C0);
              if ( TemperatureSensor == 255 )
              {
                v39 = *(_DWORD *)(*(_DWORD *)(dword_7F7B8 + 4 * chainIndex) + v6) + v55;
                ++*(_WORD *)(v39 + 4);
              }
              else
              {
                v13 = dword_7F7B8;
                *(_WORD *)(*(_DWORD *)(*(_DWORD *)(dword_7F7B8 + 4 * chainIndex) + v6) + v55 + 2) = TemperatureSensor;
                *(_WORD *)(*(_DWORD *)(*(_DWORD *)(v13 + 4 * chainIndex) + v6) + v55 + 4) = 0;
              }
              pthread_mutex_unlock(&stru_7F7C0);
LABEL_29:
              if ( v4 == 3 )
              {
                ++v0;
                continue;
              }
              goto LABEL_30;
            }
            if ( v0 < sub_1E19C() )
            {
              if ( pic_read_iic((unsigned __int8)chainIndex, *(unsigned __int8 *)(dword_7F7DC + v0), v5, v62, 2) == 2 )
              {
                TemperatureSensor = SLOBYTE(v62[0]);
                goto LABEL_99;
              }
              if ( (unsigned int)globalLogLevel > 3 )
              {
                TemperatureSensor = 255;
                snprintf(logBuffer, 2048u, "fail to read pic temp for chain %d", chainIndex);
                logMessage(3, logBuffer, v5);
                goto LABEL_99;
              }
            }
            else if ( (unsigned int)globalLogLevel > 3 )
            {
              TemperatureSensor = 255;
              snprintf(logBuffer, 2048u, "%s invalid index = %d on chain %d", "read_sensor_on_pic", v0, chainIndex);
              logMessage(3, logBuffer, v5);
              goto LABEL_99;
            }
LABEL_98:
            TemperatureSensor = 255;
            goto LABEL_99;
          }
          break;
        }
        if ( v0 < sub_1E19C() )
          goto LABEL_9;
LABEL_36:
        v62[0] = "pic";
        v62[1] = "pcb";
        v62[2] = "chp";
        v62[3] = "max";
        memset(logBuffer, 0, 256u);
        if ( !dword_7F804 )
        {
          v42 = check_miner_status();
          if ( v42 <= sub_1E19C() )
            v43 = 4 * sub_1E19C() + 1;
          else
            v43 = 4 * check_miner_status() + 1;
          dword_7F804 = (int)malloc(v43);
        }
        if ( !dword_7F808 )
        {
          v40 = check_miner_status();
          if ( v40 <= sub_1E19C() )
            v41 = 4 * sub_1E19C() + 1;
          else
            v41 = 4 * check_miner_status() + 1;
          dword_7F808 = (int)malloc(v41);
        }
        v14 = 0;
        pthread_mutex_lock(&stru_7F7C0);
        do
        {
          if ( v14 )
          {
            if ( !calibrationFactor )
              break;
            v15 = check_miner_status();
          }
          else
          {
            v15 = sub_1E19C();
          }
          if ( v15 <= 0 )
          {
            v23 = -1;
            v22 = -1;
          }
          else
          {
            v16 = 0;
            v17 = 4 * v14;
            v56 = v14;
            v18 = 0;
            v19 = 0;
            v20 = 6 * v15;
            do
            {
              v19 += sprintf(
                       (char *)(dword_7F804 + v19),
                       "%03d-",
                       *(__int16 *)(*(_DWORD *)(*(_DWORD *)(dword_7F7B8 + 4 * chainIndex) + v17) + v16 + 2));
              v21 = *(_DWORD *)(*(_DWORD *)(dword_7F7B8 + 4 * chainIndex) + v17) + v16;
              v16 += 6;
              v18 += sprintf((char *)(dword_7F808 + v18), "%03d-", *(__int16 *)(v21 + 4));
            }
            while ( v20 != v16 );
            v14 = v56;
            v22 = v18 - 1;
            v23 = v19 - 1;
          }
          v24 = (const char *)dword_7F808;
          v25 = (const char *)dword_7F804;
          *(_BYTE *)(dword_7F808 + v22) = 32;
          v25[v23] = 32;
          sprintf(logBuffer, "chain %d %s temp: %s, failure:%s", chainIndex, (const char *)v62[v14], v25, v24);
          logging_category = (_DWORD *)dword_7F80C;
          if ( !dword_7F80C )
          {
            logging_category = get_logging_category("bmminer_temp");
            dword_7F80C = (int)logging_category;
          }
          ++v14;
          log_event(
            (int)logging_category,
            "temperature/temperature.c",
            25,
            (int)"dump_temp_info",
            14,
            539,
            20,
            (int)"%s",
            logBuffer);
        }
        while ( v14 != 3 );
        pthread_mutex_unlock(&stru_7F7C0);
      }
      v27 = 0;
      v28 = 0;
      maximum_temperature = get_maximum_temperature();
      v30 = 0;
      highest_temperature = get_highest_temperature();
      do
      {
        if ( get_global_buffer_value(v30) )
        {
          v28 = (unsigned __int8)(v28 + 1);
          v32 = check_miner_status();
          v33 = get_corrected_temperature_value(v30, (unsigned __int8)(v32 - 1)) + v27;
          v34 = check_miner_status();
          v27 = get_corrected_temperature_value(v30, (unsigned __int8)(v34 - 2)) + v33;
        }
        ++v30;
      }
      while ( v30 != 4 );
      v35 = (const char *)get_shared_variable();
      if ( !strcmp(v35, "BHB28601") || (v44 = (const char *)get_shared_variable(), !strcmp(v44, "BHB28501")) )
      {
        if ( !dword_7F7BC )
          goto LABEL_62;
        v36 = 2 * v28;
        if ( maximum_temperature <= 80 )
          goto LABEL_79;
LABEL_58:
        set_fan_control_mode(1);
        if ( v27 >= v36 )
          goto LABEL_80;
        update_miner_status_led(0);
LABEL_60:
        if ( (unsigned int)globalLogLevel > 3 )
          goto LABEL_81;
        goto LABEL_61;
      }
      v36 = 2 * v28;
      if ( maximum_temperature > 80 )
        goto LABEL_58;
LABEL_79:
      set_fan_control_mode(0);
      if ( v27 < v36 )
      {
        update_miner_status_led(0);
        antminer_status_code = get_antminer_status_code();
        v46 = maximum_temperature == 0;
        if ( !maximum_temperature )
          v46 = antminer_status_code == 2;
        if ( !v46 )
          goto LABEL_62;
        v47 = 255;
        v48 = 0;
        do
        {
          v49 = v48++;
          device_min_temperature = get_device_min_temperature(v49);
          if ( device_min_temperature < v47 )
            LOWORD(v47) = device_min_temperature;
          v47 = (__int16)v47;
        }
        while ( v48 != 4 );
        if ( (_WORD)v47 )
          goto LABEL_62;
        v51 = dword_7F810 - 9 < 0;
        ++dword_7F810;
        if ( v51 ^ __OFSUB__(dword_7F810, 10) | (dword_7F810 == 10) )
          goto LABEL_62;
        goto LABEL_60;
      }
LABEL_80:
      update_miner_status_led(1);
      if ( (unsigned int)globalLogLevel > 3 )
      {
LABEL_81:
        snprintf(
          logBuffer,
          2048u,
          "over max temp, pcb temp %d (max %d), chip temp %d(max %d) pcb temp rise %d chip temp rise %d, total_exit_failure %d\n",
          maximum_temperature,
          80,
          highest_temperature,
          95,
          0,
          0,
          v27);
        logMessage(3, logBuffer, 0);
      }
LABEL_61:
      handle_error_with_logging(15u, "over max temp");
LABEL_62:
      checkFanStatus(400u, 0);
      if ( get_global_variable() && optBitmainWorkMode != 1 )
        setFanSpeedControl();
      usleep(10000u);
      if ( !dword_7F7E0 )
        goto exitMonitoring;
    }
  }
  return 0;
}
// 7EB9C: using guessed type int globalLogLevel;
// 7F7B0: using guessed type int calibrationFactor;
// 7F7B8: using guessed type int dword_7F7B8;
// 7F7BC: using guessed type int dword_7F7BC;
// 7F7DC: using guessed type int dword_7F7DC;
// 7F7E0: using guessed type int dword_7F7E0;
// 7F7E8: using guessed type int dword_7F7E8;
// 7F7EC: using guessed type pthread_mutex_t stru_7F7EC;
// 7F804: using guessed type int dword_7F804;
// 7F808: using guessed type int dword_7F808;
// 7F80C: using guessed type int dword_7F80C;
// 7F810: using guessed type int dword_7F810;
// 80FB4: using guessed type int optBitmainWorkMode;

//----- (00016284) --------------------------------------------------------
int __fastcall get_chip_temperature(int chip_id, int temperature_offset)
{
  return get_temperature_value(chip_id, 1, temperature_offset);
}

//----- (00016290) --------------------------------------------------------
int __fastcall read_temperature_sensor(int sensor_id, int output_buffer)
{
  return get_temperature_value(sensor_id, 2, output_buffer);
}

//----- (0001629C) --------------------------------------------------------
void initialize_miner_status()
{
  dword_7F7E8 = 1;
}
// 7F7E8: using guessed type int dword_7F7E8;

//----- (000162B0) --------------------------------------------------------
void reset_global_counter()
{
  dword_7F7E8 = 0;
}
// 7F7E8: using guessed type int dword_7F7E8;

//----- (000162C4) --------------------------------------------------------
int __fastcall configure_all_asics(
        int config_register,
        int use_default_timing,
        int unused_param,
        unsigned __int8 default_timing_value)
{
  int miner_index; // r4
  char miner_timing; // r5
  char global_timing; // r0
  bool has_next_miner; // cc
  int last_configured_miner; // r0
  unsigned __int8 timing_value; // [sp+Fh] [bp-19h] BYREF

  if ( !use_default_timing )
    default_timing_value = 4;
  if ( use_default_timing )
    default_timing_value = 68;
  timing_value = default_timing_value;
  miner_index = 0;
  while ( 1 )
  {
    has_next_miner = check_miner_status() <= miner_index;
    last_configured_miner = miner_index++;
    if ( has_next_miner )
      break;
    miner_timing = get_control_status(last_configured_miner);
    global_timing = sub_1E160();
    configure_asic(config_register, (unsigned __int8)(miner_timing * global_timing), 9, 1, &timing_value);
  }
  return last_configured_miner;
}

//----- (00016330) --------------------------------------------------------
int __fastcall check_and_configure_asics(int configuration_value)
{
  int asic_index; // r4
  int operation_result; // r0
  int unused_param1; // r2
  unsigned __int8 unused_param2; // r3

  asic_index = 0;
  operation_result = get_global_buffer_value(0);
  if ( operation_result )
    goto LABEL_4;
  while ( ++asic_index != 4 )
  {
    operation_result = get_global_buffer_value(asic_index);
    if ( operation_result )
LABEL_4:
      operation_result = configure_all_asics(asic_index, configuration_value, unused_param1, unused_param2);
  }
  return operation_result;
}
// 16370: variable 'unused_param1' is possibly undefined
// 16370: variable 'unused_param2' is possibly undefined

//----- (00016378) --------------------------------------------------------
int InitializeChainConfigurations()
{
  int chainIndex; // r4
  _DWORD *chainConfigurations; // r6
  int resultCode; // r0
  void *chainConfig; // r8
  int chainCount; // r0
  int singleConfig; // r8
  _DWORD *chainConfigPtr; // r4
  _BYTE *configMemoryArea; // r3
  _BYTE *tempPtr; // t1
  _BYTE *memoryLocation; // r3
  char logBuffer[2072]; // [sp+0h] [bp-818h] BYREF

  if ( !globalChainConfigs[0] )
  {
    globalChainConfigs[0] = (int)calloc(1u, 32u);
    if ( !globalChainConfigs[0] )
    {
      if ( (unsigned int)globalLogLevel > 3 )
      {
        strcpy(logBuffer, "No memory for configuraion.\n");
        logMessage(3, logBuffer, 0);
        chainConfigurations = (_DWORD *)globalChainConfigs[0];
        goto CLEANUP_CONFIGS;
      }
      return -1;
    }
  }
  chainIndex = 0;
  while ( 1 )
  {
    if ( !get_global_buffer_value(chainIndex) )
      goto CHECK_NEXT_CHAIN;
    chainConfigurations = (_DWORD *)globalChainConfigs[0];
    if ( *(_DWORD *)(globalChainConfigs[0] + 4 * chainIndex) )
      goto CHECK_NEXT_CHAIN;
    chainConfig = calloc(1u, 72u);
    chainConfigurations[chainIndex] = chainConfig;
    if ( !chainConfig )
      break;
    chainCount = get_global_variable_value();
    chainConfigurations = (_DWORD *)globalChainConfigs[0];
    singleConfig = *(_DWORD *)(globalChainConfigs[0] + 4 * chainIndex);
    *(_DWORD *)(singleConfig + 63) = calloc(chainCount, 1u);
    if ( !*(_DWORD *)(chainConfigurations[chainIndex] + 63) )
    {
      if ( (unsigned int)globalLogLevel <= 3 )
        goto CLEANUP_CONFIGS;
      goto LOG_MEMORY_ERROR;
    }
CHECK_NEXT_CHAIN:
    if ( ++chainIndex == 4 )
      return 0;
  }
  if ( (unsigned int)globalLogLevel > 3 )
  {
LOG_MEMORY_ERROR:
    snprintf(logBuffer, 2048u, "No memory for configuraion for chain %d.\n", chainIndex);
    logMessage(3, logBuffer, 0);
    chainConfigurations = (_DWORD *)globalChainConfigs[0];
  }
CLEANUP_CONFIGS:
  if ( !chainConfigurations )
    return -1;
  chainConfigPtr = chainConfigurations - 1;
  do
  {
    tempPtr = (_BYTE *)chainConfigPtr[1];
    ++chainConfigPtr;
    configMemoryArea = tempPtr;
    if ( tempPtr )
    {
      if ( *(_DWORD *)(configMemoryArea + 63) )
      {
        free(*(void **)(configMemoryArea + 63));
        memoryLocation = (_BYTE *)*chainConfigPtr;
        memoryLocation[63] = 0;
        memoryLocation[64] = 0;
        memoryLocation[65] = 0;
        memoryLocation[66] = 0;
        configMemoryArea = (_BYTE *)*chainConfigPtr;
      }
      free(configMemoryArea);
      *chainConfigPtr = 0;
    }
  }
  while ( chainConfigPtr != chainConfigurations + 3 );
  free(chainConfigurations);
  resultCode = -1;
  globalChainConfigs[0] = 0;
  return resultCode;
}
// 7EB9C: using guessed type int globalLogLevel;
// 7F814: using guessed type int globalChainConfigs[];

//----- (00016580) --------------------------------------------------------
int load_voltage_frequency_config()
{
  unsigned int index; // r4
  _DWORD *updated; // r0
  _DWORD *config_status; // r5
  int return_code; // r4
  _DWORD *miner_task_result; // r0
  _DWORD *miner_task_status; // r8
  unsigned int current_log_level; // r3
  const char *log_message_format; // r2
  const char *miner_type_str; // r0
  char *type_match_pos; // r7
  const char *type_compared_str; // r0
  const char *miner_type_parameter; // r0
  _DWORD *levels_task_result; // r0
  _DWORD *levels_task_status; // r8
  int config_index; // r9
  unsigned int task_counter; // r7
  _DWORD *task_pointer; // r0
  unsigned int task_index; // r1
  _BOOL4 task_valid; // r3
  _DWORD *current_task_pointer; // r0
  _DWORD *current_task_status; // r6
  _DWORD *frequency_task_result; // r0
  int *chain_config_ptr; // r4
  _DWORD *voltage_task_result; // r0
  int chain_index; // r7
  int frequency_value; // r2
  int config_position; // r3
  int *chain_config_ref; // r3
  int voltage_value; // r3
  unsigned int *config_status_ptr; // r3
  unsigned int status_value; // r2
  unsigned int updated_status_value; // r2
  char json_config_buffer[252]; // [sp+1Ch] [bp-924h] BYREF
  char log_buffer[2088]; // [sp+118h] [bp-828h] BYREF

  for ( index = 0; index != 4; ++index )
  {
    if ( get_global_buffer_value(index) )
    {
      initiate_device_communication(index);
      get_next_sleep_interval();
    }
  }
  memset(dword_7F818, 0, 160u);
  updated = update_miner_status_from_config("/etc/levels.json", 0, json_config_buffer);
  config_status = updated;
  if ( !updated || *updated )
  {
    if ( (unsigned int)globalLogLevel > 3 )
    {
      snprintf(log_buffer, 2048u, "load vol-freq config file %s failed\n", "/etc/levels.json");
      logMessage(3, log_buffer, 0);
      return -1;
    }
    return -1;
  }
  miner_task_result = (_DWORD *)initiate_task_if_ready(updated, "miner");
  miner_task_status = miner_task_result;
  if ( miner_task_result )
  {
    current_log_level = globalLogLevel;
    if ( *miner_task_result == 2 )
    {
      if ( (unsigned int)globalLogLevel > 4 )
      {
        miner_type_parameter = (const char *)get_second_element_if_ready(miner_task_result);
        snprintf(log_buffer, 2048u, "miner type in %s is %s", "/etc/levels.json", miner_type_parameter);
        logMessage(4, log_buffer, 0);
      }
      miner_type_str = (const char *)get_second_element_if_ready(miner_task_status);
      type_match_pos = strstr(minerType, miner_type_str);
      if ( !type_match_pos
        || (type_compared_str = (const char *)get_second_element_if_ready(miner_task_status),
            strcasecmp(type_match_pos, type_compared_str)) )
      {
        return_code = -3;
        if ( (unsigned int)globalLogLevel > 3 )
        {
          strcpy(log_buffer, "miner type not match");
          logMessage(3, log_buffer, 0);
        }
        return return_code;
      }
      levels_task_result = (_DWORD *)initiate_task_if_ready(config_status, "levels");
      levels_task_status = levels_task_result;
      if ( levels_task_result && *levels_task_result == 1 )
      {
        config_index = 0;
        task_counter = 0;
        while ( 1 )
        {
          task_pointer = get_associated_pointer_or_null(levels_task_status);
          task_index = task_counter;
          task_valid = (unsigned int)task_pointer > task_counter;
          if ( config_index > 19 )
            task_valid = 0;
          ++task_counter;
          if ( !task_valid )
            break;
          current_task_pointer = get_task_by_index(levels_task_status, task_index);
          current_task_status = current_task_pointer;
          if ( !*config_status )
          {
            frequency_task_result = (_DWORD *)initiate_task_if_ready(current_task_pointer, "frequency");
            if ( frequency_task_result )
            {
              if ( *frequency_task_result == 3 )
              {
                chain_config_ptr = &globalChainConfigs[2 * config_index];
                chain_config_ptr[2] = get_hardware_status((int)frequency_task_result);
                voltage_task_result = (_DWORD *)initiate_task_if_ready(current_task_status, "voltage");
                if ( voltage_task_result )
                {
                  if ( *voltage_task_result == 3 )
                  {
                    ++config_index;
                    chain_config_ptr[1] = get_hardware_status((int)voltage_task_result);
                  }
                }
              }
            }
          }
        }
        return_code = 0;
        chain_index = 0;
        do
        {
          frequency_value = dword_7F818[2 * chain_index];
          config_position = 2 * chain_index++;
          chain_config_ref = &dword_7F818[config_position];
          if ( frequency_value )
          {
            voltage_value = chain_config_ref[1];
            if ( voltage_value )
            {
              if ( (unsigned int)globalLogLevel > 4 )
              {
                snprintf(
                  log_buffer,
                  2048u,
                  "level %d, voltage = %d frequency = %d",
                  chain_index,
                  frequency_value,
                  voltage_value);
                logMessage(4, log_buffer, 0);
              }
            }
          }
        }
        while ( chain_index != 20 );
        if ( config_status[1] != -1 )
        {
          config_status_ptr = config_status + 1;
          __dmb(11u);
          do
          {
            status_value = __ldrex(config_status_ptr);
            updated_status_value = status_value - 1;
          }
          while ( __strex(updated_status_value, config_status_ptr) );
          if ( !updated_status_value )
            handle_task(config_status);
        }
        return return_code;
      }
      if ( (unsigned int)globalLogLevel <= 4 )
        return -2;
      log_message_format = "failed to get levels in %s\n";
LABEL_17:
      return_code = -2;
      snprintf(log_buffer, 2048u, log_message_format, "/etc/levels.json");
      logMessage(4, log_buffer, 0);
      return return_code;
    }
  }
  else
  {
    current_log_level = globalLogLevel;
  }
  if ( current_log_level > 4 )
  {
    log_message_format = "failed to get miner type in %s\n";
    goto LABEL_17;
  }
  return -2;
}
// 7EB9C: using guessed type int globalLogLevel;
// 7F814: using guessed type int globalChainConfigs[];
// 7F818: using guessed type int dword_7F818[];
// 16580: using guessed type char var_924[252];

//----- (0001697C) --------------------------------------------------------
int __fastcall logNoChipBinError(int a1)
{
  char logBuffer[2056]; // [sp+0h] [bp-808h] BYREF

  snprintf(logBuffer, 2048u, "No chip bin, chain = %d\n", a1);
  logMessage(3, logBuffer, 0);
  return -1;
}

//----- (000169C0) --------------------------------------------------------
int __fastcall logNoVersionError(int chainIndex)
{
  char logBuffer[2056]; // [sp+0h] [bp-808h] BYREF

  snprintf(logBuffer, 2048u, "No ft ver, chain = %d\n", chainIndex);
  logMessage(3, logBuffer, 0);
  return -1;
}

//----- (00016A04) --------------------------------------------------------
int update_eeprom_miner_info()
{
  unsigned int chain_index; // r4
  int update_status; // r8
  int chain_config_addr; // r6
  int eeprom_offset; // r1
  size_t data_length; // r2
  int data_adjusted_len; // r9
  int data_with_offset; // r7
  size_t write_length; // r3
  const void *data_to_copy; // r1
  size_t buffer_size; // r6
  unsigned int aligned_buffer_size; // r6
  unsigned int eeprom_write_addr; // r7
  char eeprom_data_buffer[256]; // [sp+8h] [bp-928h] BYREF
  char log_buffer[2088]; // [sp+108h] [bp-828h] BYREF

  if ( globalChainConfigs[0] && *(_BYTE *)(globalChainConfigs[0] + 28) )
  {
    chain_index = 0;
    update_status = 0;
    do
    {
      if ( get_global_buffer_value(chain_index) )
      {
        memset(eeprom_data_buffer, 0, sizeof(eeprom_data_buffer));
        chain_config_addr = *(_DWORD *)(globalChainConfigs[0] + 4 * chain_index);
        if ( (unsigned int)globalLogLevel > 3 )
        {
          snprintf(log_buffer, 2048u, "[chain %d] Update miner info in eeprom.\n", chain_index);
          logMessage(3, log_buffer, 0);
        }
        eeprom_offset = *(unsigned __int8 *)(chain_config_addr + 1);
        data_length = *(unsigned __int8 *)(chain_config_addr + 56);
        data_adjusted_len = 57 - eeprom_offset;
        data_with_offset = eeprom_offset + 5;
        write_length = data_length - (57 - eeprom_offset);
        data_to_copy = (const void *)(chain_config_addr + eeprom_offset);
        buffer_size = write_length + 7;
        memcpy(eeprom_data_buffer, data_to_copy, data_length);
        aligned_buffer_size = buffer_size & 0xFFFFFFF8;
        eeprom_write_addr = (data_with_offset & 0xFFFFFFF8) + 2;
        process_eeprom_write(&eeprom_data_buffer[data_adjusted_len], aligned_buffer_size, 1);
        if ( (int)(256 - eeprom_write_addr) >= (int)(data_adjusted_len + aligned_buffer_size) )
        {
          writeDataToEeprom(
            chain_index,
            eeprom_write_addr & 0xFE,
            (int)eeprom_data_buffer,
            data_adjusted_len + aligned_buffer_size);
        }
        else
        {
          update_status = -1;
          if ( (unsigned int)globalLogLevel > 3 )
          {
            snprintf(
              log_buffer,
              2048u,
              "[chain %d] Update miner info Failed, EEPROM does not have enough space.\n",
              chain_index);
            logMessage(3, log_buffer, 0);
          }
        }
      }
      ++chain_index;
    }
    while ( chain_index != 4 );
    return update_status;
  }
  if ( (unsigned int)globalLogLevel <= 3 )
    return -1;
  strcpy(log_buffer, "No fixture configuration for flush.\n");
  logMessage(3, log_buffer, 0);
  return -1;
}
// 7EB9C: using guessed type int globalLogLevel;
// 7F814: using guessed type int globalChainConfigs[];
// 16A04: using guessed type char s[256];

//----- (00016BD8) --------------------------------------------------------
_BYTE *__fastcall log_mining_board_info(_BYTE *log_result)
{
  _BYTE *mining_board_data; // r5
  char log_buffer[2]; // [sp+10h] [bp-810h] BYREF

  if ( (unsigned int)globalLogLevel > 3 )
  {
    mining_board_data = log_result;
    snprintf(log_buffer, 2048u, "%-30s : 0x%04x\n", "key_version", *log_result & 0xF);
    log_result = (_BYTE *)logMessage(3, log_buffer, 0);
    if ( (unsigned int)globalLogLevel > 3 )
    {
      snprintf(log_buffer, 2048u, "%-30s : 0x%04x\n", "algorithm_code", (unsigned __int8)*mining_board_data >> 4);
      log_result = (_BYTE *)logMessage(3, log_buffer, 0);
      if ( (unsigned int)globalLogLevel <= 3 )
        return log_result;
      snprintf(log_buffer, 2048u, "%-30s : 0x%04x\n", "fixture_info_len", (unsigned __int8)mining_board_data[1]);
      log_result = (_BYTE *)logMessage(3, log_buffer, 0);
      if ( (unsigned int)globalLogLevel <= 3 )
        goto LABEL_11;
      snprintf(log_buffer, 2048u, "%-30s : 0x%04x\n", "fixture_standard", (unsigned __int8)mining_board_data[45]);
      log_result = (_BYTE *)logMessage(3, log_buffer, 0);
      if ( (unsigned int)globalLogLevel <= 3 )
        return log_result;
      snprintf(log_buffer, 2048u, "%-30s : 0x%04x\n", "test_standard", (unsigned __int8)mining_board_data[46]);
      log_result = (_BYTE *)logMessage(3, log_buffer, 0);
    }
    if ( (unsigned int)globalLogLevel <= 3 )
      goto LABEL_14;
    snprintf(log_buffer, 2048u, "%-30s : %s\n", "chip_technology", *(const char **)(mining_board_data + 31));
    log_result = (_BYTE *)logMessage(3, log_buffer, 0);
    if ( (unsigned int)globalLogLevel <= 3 )
      return log_result;
    snprintf(log_buffer, 2048u, "%-30s : 0x%02x\n", "fixture_fmt_version", (unsigned __int8)mining_board_data[2]);
    log_result = (_BYTE *)logMessage(3, log_buffer, 0);
LABEL_11:
    if ( (unsigned int)globalLogLevel <= 3 )
      goto LABEL_17;
    snprintf(log_buffer, 2048u, "%-30s : %s\n", "SN", *(const char **)(mining_board_data + 3));
    log_result = (_BYTE *)logMessage(3, log_buffer, 0);
    if ( (unsigned int)globalLogLevel <= 3 )
      return log_result;
    snprintf(
      log_buffer,
      2048u,
      "%-30s : 0x%02x-%02x\n",
      "pcb",
      (unsigned __int8)mining_board_data[27],
      (unsigned __int8)mining_board_data[28]);
    log_result = (_BYTE *)logMessage(3, log_buffer, 0);
LABEL_14:
    if ( (unsigned int)globalLogLevel <= 3 )
      goto LABEL_20;
    snprintf(
      log_buffer,
      2048u,
      "%-30s : 0x%02x-%02x\n",
      "bom",
      (unsigned __int8)mining_board_data[29],
      (unsigned __int8)mining_board_data[30]);
    log_result = (_BYTE *)logMessage(3, log_buffer, 0);
    if ( (unsigned int)globalLogLevel <= 3 )
      return log_result;
    snprintf(log_buffer, 2048u, "%-30s : %u\n", "hash_board_voltage", *(unsigned __int16 *)(mining_board_data + 35));
    log_result = (_BYTE *)logMessage(3, log_buffer, 0);
LABEL_17:
    if ( (unsigned int)globalLogLevel <= 3 )
      goto LABEL_23;
    snprintf(log_buffer, 2048u, "%-30s : %u\n", "hash_board_freq", *(unsigned __int16 *)(mining_board_data + 37));
    log_result = (_BYTE *)logMessage(3, log_buffer, 0);
    if ( (unsigned int)globalLogLevel <= 3 )
      return log_result;
    snprintf(log_buffer, 2048u, "%-30s : %.2f\n", "nonce_response_rate", *(float *)(mining_board_data + 39));
    log_result = (_BYTE *)logMessage(3, log_buffer, 0);
LABEL_20:
    if ( (unsigned int)globalLogLevel <= 3 )
      goto LABEL_26;
    snprintf(log_buffer, 2048u, "%-30s : %u\n", "inlet_temperature", (unsigned __int8)mining_board_data[43]);
    log_result = (_BYTE *)logMessage(3, log_buffer, 0);
    if ( (unsigned int)globalLogLevel <= 3 )
      return log_result;
    snprintf(log_buffer, 2048u, "%-30s : %u\n", "outlet_temperature", (unsigned __int8)mining_board_data[44]);
    log_result = (_BYTE *)logMessage(3, log_buffer, 0);
LABEL_23:
    if ( (unsigned int)globalLogLevel <= 3 )
      goto LABEL_29;
    snprintf(
      log_buffer,
      2048u,
      "%-30s : 0x%02x-%02x\n",
      "asic sensor",
      (unsigned __int8)mining_board_data[20] >> 7,
      mining_board_data[20] & 0x7F);
    log_result = (_BYTE *)logMessage(3, log_buffer, 0);
    if ( (unsigned int)globalLogLevel <= 3 )
      return log_result;
    snprintf(
      log_buffer,
      2048u,
      "%-30s : 0x%02x-%02x-%02x-%02x\n",
      "asic sensor addr",
      **(unsigned __int8 **)(mining_board_data + 21),
      *(unsigned __int8 *)(*(_DWORD *)(mining_board_data + 21) + 1),
      *(unsigned __int8 *)(*(_DWORD *)(mining_board_data + 21) + 2),
      *(unsigned __int8 *)(*(_DWORD *)(mining_board_data + 21) + 3));
    log_result = (_BYTE *)logMessage(3, log_buffer, 0);
LABEL_26:
    if ( (unsigned int)globalLogLevel <= 3 )
      goto LABEL_32;
    snprintf(
      log_buffer,
      2048u,
      "%-30s : 0x%02x-%02x\n",
      "pic sensor",
      (unsigned __int8)mining_board_data[25] >> 7,
      mining_board_data[25] & 0x7F);
    log_result = (_BYTE *)logMessage(3, log_buffer, 0);
    if ( (unsigned int)globalLogLevel <= 3 )
      return log_result;
    snprintf(log_buffer, 2048u, "%-30s : 0x%02x\n", "pic sensor addr", (unsigned __int8)mining_board_data[26]);
    log_result = (_BYTE *)logMessage(3, log_buffer, 0);
LABEL_29:
    if ( (unsigned int)globalLogLevel <= 3 )
      goto LABEL_35;
    snprintf(log_buffer, 2048u, "%-30s : bin%d\n", "chip_bin", (unsigned __int8)mining_board_data[15]);
    log_result = (_BYTE *)logMessage(3, log_buffer, 0);
    if ( (unsigned int)globalLogLevel <= 3 )
      return log_result;
    snprintf(log_buffer, 2048u, "%-30s : %s\n", "FT", *((const char **)mining_board_data + 4));
    log_result = (_BYTE *)logMessage(3, log_buffer, 0);
LABEL_32:
    if ( (unsigned int)globalLogLevel <= 3 )
      return log_result;
    snprintf(log_buffer, 2048u, "%-30s : %s\n", "chip_die", *(const char **)(mining_board_data + 7));
    log_result = (_BYTE *)logMessage(3, log_buffer, 0);
    if ( (unsigned int)globalLogLevel <= 3 )
      return log_result;
    snprintf(log_buffer, 2048u, "%-30s : %s\n", "chip_marking", *(const char **)(mining_board_data + 11));
    log_result = (_BYTE *)logMessage(3, log_buffer, 0);
LABEL_35:
    if ( (unsigned int)globalLogLevel > 3 )
    {
      strcpy(log_buffer, "\n");
      return (_BYTE *)logMessage(3, log_buffer, 0);
    }
  }
  return log_result;
}
// 7EB9C: using guessed type int globalLogLevel;

//----- (00017244) --------------------------------------------------------
char *__fastcall PrintBufferFormatted(char *chainIdentifier, int buffer, unsigned int bufferSize)
{
  unsigned int currentLogLevel; // r1
  unsigned int v5; // r4
  int byteGroup; // r5
  char logBuffer[2088]; // [sp+8h] [bp-828h] BYREF

  currentLogLevel = globalLogLevel;
  if ( (unsigned int)globalLogLevel > 3 )
  {
    snprintf(logBuffer, 2048u, "[chain %d]\n", chainIdentifier);
    chainIdentifier = (char *)logMessage(3, logBuffer, 0);
    currentLogLevel = globalLogLevel;
    if ( bufferSize )
      goto LABEL_3;
LABEL_15:
    if ( currentLogLevel > 3 )
    {
      strcpy(logBuffer, "\n");
      return append_log_message(3, logBuffer, 0);
    }
  }
  else if ( bufferSize )
  {
LABEL_3:
    v5 = 0;
    while ( 1 )
    {
      while ( 1 )
      {
        byteGroup = v5 & 0xF;
        if ( (v5 & 0xF) != 0 )
          break;
        if ( currentLogLevel > 3 )
        {
          snprintf(logBuffer, 2048u, "0x%04X ", v5);
          chainIdentifier = append_log_message(3, logBuffer, v5 & 0xF);
          currentLogLevel = globalLogLevel;
        }
LABEL_6:
        if ( currentLogLevel > 3 )
          goto LABEL_12;
LABEL_7:
        if ( bufferSize <= ++v5 )
          goto LABEL_15;
      }
      if ( byteGroup != 8 )
        goto LABEL_6;
      if ( currentLogLevel <= 3 )
        goto LABEL_7;
      strcpy(logBuffer, "  ");
      chainIdentifier = append_log_message(3, logBuffer, 0);
      currentLogLevel = globalLogLevel;
      if ( (unsigned int)globalLogLevel <= 3 )
        goto LABEL_7;
LABEL_12:
      snprintf(logBuffer, 2048u, "%02X ", *(unsigned __int8 *)(buffer + v5));
      chainIdentifier = append_log_message(3, logBuffer, 0);
      currentLogLevel = globalLogLevel;
      if ( byteGroup != 15 || (unsigned int)globalLogLevel <= 3 )
        goto LABEL_7;
      ++v5;
      strcpy(logBuffer, "\n");
      chainIdentifier = append_log_message(3, logBuffer, 0);
      currentLogLevel = globalLogLevel;
      if ( bufferSize <= v5 )
        goto LABEL_15;
    }
  }
  return chainIdentifier;
}
// 173A4: conditional instruction was optimized away because r5.4==0
// 7EB9C: using guessed type int globalLogLevel;

//----- (0001740C) --------------------------------------------------------
int __fastcall readAndDecodeChainConfig(unsigned int chainIndex, int configArrayPtr)
{
  int configPtr; // r9
  int retryCount; // r6
  int readStatus; // r7
  size_t dataSize; // r4
  _BOOL4 dataConsistencyCheck; // r12
  unsigned int logLevel; // r3
  int v11; // r2
  bool v12; // zf
  char v13; // r6
  char v14; // r3
  int v15; // r3
  unsigned int v16; // r2
  size_t v17; // r10
  int v18; // r3
  int v19; // r11
  int v20; // r4
  _DWORD *v21; // r12
  int v22; // r6
  int v23; // lr
  int v24; // r2
  _WORD *v25; // r12
  _DWORD *v26; // r12
  int v27; // r2
  int v28; // r1
  int v29; // r3
  bool v30; // cf
  void *v31; // r12
  _DWORD *v32; // r12
  _WORD *v33; // r12
  float v34; // s12
  _DWORD *v35; // r0
  _DWORD *v36; // r12
  bool v37; // zf
  int v38; // r1
  char v39; // r2
  int v40; // r0
  int v41; // r3
  char *v42; // r0
  char *v43; // r8
  int v44; // r1
  char v46; // [sp+14h] [bp-B6Ch]
  int v47; // [sp+14h] [bp-B6Ch]
  int v48; // [sp+18h] [bp-B68h]
  int v49; // [sp+1Ch] [bp-B64h]
  int v50; // [sp+20h] [bp-B60h]
  int v51; // [sp+24h] [bp-B5Ch]
  int v52; // [sp+28h] [bp-B58h]
  int v53; // [sp+2Ch] [bp-B54h]
  int v54; // [sp+30h] [bp-B50h]
  int v55; // [sp+34h] [bp-B4Ch]
  int v56; // [sp+38h] [bp-B48h]
  int v57; // [sp+3Ch] [bp-B44h]
  int v58; // [sp+40h] [bp-B40h]
  int v59; // [sp+44h] [bp-B3Ch]
  int v60; // [sp+48h] [bp-B38h]
  int v61; // [sp+4Ch] [bp-B34h]
  int v62; // [sp+50h] [bp-B30h]
  __int16 s[128]; // [sp+58h] [bp-B28h] BYREF
  _DWORD dataBuffer[64]; // [sp+158h] [bp-A28h] BYREF
  int dest[64]; // [sp+258h] [bp-928h] BYREF
  char logBuffer[2040]; // [sp+358h] [bp-828h] BYREF

  memset(s, 0, sizeof(s));
  memset(dataBuffer, 0, sizeof(dataBuffer));
  configPtr = *(_DWORD *)(configArrayPtr + 4 * chainIndex);
  retryCount = 3;
  while ( 1 )
  {
    readStatus = readEepromData(chainIndex, 0, (int)s, 256);
    if ( readStatus )
    {
      if ( (unsigned int)globalLogLevel > 3 )
      {
        snprintf(logBuffer, 2048u, "Read configuration fail for chain %d.\n", chainIndex);
        logMessage(3, logBuffer, 0);
      }
      return readStatus;
    }
    PrintBufferFormatted((char *)chainIndex, (int)s, 256u);
    memset(dest, 0, sizeof(dest));
    dataSize = HIBYTE(s[0]) - 2;
    dataConsistencyCheck = (int)((HIBYTE(s[0]) + 5) & 0xFFFFFFF8) > 254;
    if ( (unsigned __int8)dataSize > 253u )
      dataConsistencyCheck = 1;
    if ( !dataConsistencyCheck )
      break;
    if ( (unsigned int)globalLogLevel > 3 )
    {
      strcpy(logBuffer, "EEPROM info error!, -1");
      logMessage(3, logBuffer, 0);
      goto LABEL_20;
    }
RETRY_READ:
    usleep(500000u);
    if ( !--retryCount )
    {
      logLevel = globalLogLevel;
      goto LOG_ERROR;
    }
  }
  v11 = LOBYTE(s[0]) >> 4;
  v12 = v11 == 1;
  if ( v11 == 1 )
    v12 = (s[0] & 0xF) == 1;
  if ( !v12 )
  {
    if ( (unsigned int)globalLogLevel <= 3 )
      goto RETRY_READ;
    strcpy(logBuffer, "EEPROM info error!, -2");
    logMessage(3, logBuffer, 0);
LABEL_20:
    if ( (unsigned int)globalLogLevel > 3 )
    {
      snprintf(logBuffer, 2048u, "Data decode fail for chain %d.\n", chainIndex);
      logMessage(3, logBuffer, 0);
    }
    goto RETRY_READ;
  }
  v46 = (HIBYTE(s[0]) + 5) & 0xF8;
  memcpy(dest, &s[1], (HIBYTE(s[0]) + 5) & 0xFFFFFFF8);
  process_eeprom_write((char *)dest, v46, 0);
  LOWORD(dataBuffer[0]) = s[0];
  v13 = LOBYTE(s[0]) >> 4;
  memcpy((char *)dataBuffer + 2, dest, dataSize);
  v14 = *(_BYTE *)configPtr & 0xF | (16 * (v13 & 0xF));
  *(_BYTE *)configPtr = v14;
  *(_BYTE *)configPtr = v14 & 0xF0 | dataBuffer[0] & 0xF;
  *(_BYTE *)(configPtr + 1) = BYTE1(dataBuffer[0]);
  v15 = BYTE2(dataBuffer[0]);
  v16 = BYTE2(dataBuffer[0]) - 1;
  *(_BYTE *)(configPtr + 2) = BYTE2(dataBuffer[0]);
  if ( v16 <= 1 )
  {
    v56 = 61;
    v57 = 62;
    v54 = 59;
    v55 = 60;
    v17 = 4;
    v52 = 55;
    v53 = 57;
    v19 = 40;
    v50 = 51;
    v51 = 53;
    v20 = 1;
    v48 = 49;
    v49 = 50;
    v62 = 65;
    v58 = 47;
    v59 = 46;
    v47 = 48;
    v60 = 41;
    v61 = 45;
  }
  else
  {
    if ( v15 != 3 )
    {
      if ( v15 == 4 )
      {
        v17 = 9;
        v18 = 81;
        goto LABEL_52;
      }
      if ( (unsigned int)globalLogLevel > 3 )
      {
        strcpy(logBuffer, "This FMT is not supported\n");
        logMessage(3, logBuffer, 0);
        logLevel = globalLogLevel;
        goto LOG_ERROR;
      }
      return -1;
    }
    v17 = 9;
    v18 = 73;
LABEL_52:
    v56 = 66;
    v57 = 67;
    v62 = v18;
    v54 = 64;
    v55 = 65;
    v52 = 60;
    v53 = 62;
    v47 = 53;
    v50 = 56;
    v51 = 58;
    v19 = 45;
    v48 = 54;
    v49 = 55;
    v20 = 1;
    v58 = 52;
    v59 = 51;
    v60 = 46;
    v61 = 50;
  }
  v21 = calloc(18u, 1u);
  *(_DWORD *)(configPtr + 3) = v21;
  if ( !v21 )
  {
    v20 = 0;
    if ( (unsigned int)globalLogLevel > 3 )
    {
      strcpy(logBuffer, "Decode SN OOM\n");
      logMessage(3, logBuffer, 0);
      v21 = *(_DWORD **)(configPtr + 3);
    }
  }
  v22 = *(_DWORD *)((char *)&dataBuffer[1] + 3);
  v23 = *(_DWORD *)((char *)&dataBuffer[2] + 3);
  v24 = *(_DWORD *)((char *)&dataBuffer[3] + 3);
  *v21 = *(_DWORD *)((char *)dataBuffer + 3);
  v21[1] = v22;
  v21[2] = v23;
  v21[3] = v24;
  *((_BYTE *)v21 + 16) = HIBYTE(dataBuffer[4]);
  v25 = calloc(3u, 1u);
  *(_DWORD *)(configPtr + 7) = v25;
  if ( !v25 )
  {
    v20 = 0;
    if ( (unsigned int)globalLogLevel > 3 )
    {
      strcpy(logBuffer, "Decode Chip Die OOM\n");
      logMessage(3, logBuffer, 0);
      v25 = *(_WORD **)(configPtr + 7);
    }
  }
  *v25 = dataBuffer[5];
  v26 = calloc(14u, 1u);
  *(_DWORD *)(configPtr + 11) = v26;
  if ( !v26 )
  {
    v20 = 0;
    if ( (unsigned int)globalLogLevel > 3 )
    {
      strcpy(logBuffer, "Decode Chip Marking OOM\n");
      logMessage(3, logBuffer, 0);
      v26 = *(_DWORD **)(configPtr + 11);
    }
  }
  v27 = *(_DWORD *)((char *)&dataBuffer[7] + 2);
  v28 = *(_DWORD *)((char *)&dataBuffer[6] + 2);
  *v26 = *(_DWORD *)((char *)&dataBuffer[5] + 2);
  v26[2] = v27;
  v26[1] = v28;
  *((_BYTE *)v26 + 12) = BYTE2(dataBuffer[8]);
  v29 = *(unsigned __int8 *)(configPtr + 2) - 1;
  v30 = *(_BYTE *)(configPtr + 2) != 1;
  *(_BYTE *)(configPtr + 15) = HIBYTE(dataBuffer[8]);
  if ( v29 != 1 && v30 )
  {
    v31 = calloc(v17 + 1, 1u);
    *(_DWORD *)(configPtr + 16) = v31;
    if ( !v31 )
    {
      v20 = 0;
      if ( (unsigned int)globalLogLevel > 3 )
      {
        strcpy(logBuffer, "Decode Chip FT Program Version OOM\n");
        logMessage(3, logBuffer, 0);
        v31 = *(void **)(configPtr + 16);
      }
    }
    memcpy(v31, &dataBuffer[9], v17);
  }
  else
  {
    memset(dest, 0, 16);
    v42 = (char *)calloc(v17 + 6, 1u);
    v43 = v42;
    *(_DWORD *)(configPtr + 16) = v42;
    if ( !v42 )
    {
      v20 = 0;
      if ( (unsigned int)globalLogLevel > 3 )
      {
        strcpy(logBuffer, "Decode Chip FT Program Version OOM\n");
        logMessage(3, logBuffer, 0);
        v43 = *(char **)(configPtr + 16);
      }
    }
    memcpy(dest, &dataBuffer[9], v17);
    snprintf(v43, v17 + 6, "F%dV%02dB%dC%d", LOBYTE(dest[0]), BYTE1(dest[0]), BYTE2(dest[0]), HIBYTE(dest[0]));
  }
  *(_BYTE *)(configPtr + 20) = *(_BYTE *)(configPtr + 20) & 0x80 | *((_BYTE *)dataBuffer + v19) & 0x7F;
  *(_BYTE *)(configPtr + 20) = *(_BYTE *)(configPtr + 20) & 0x7F | (*((_BYTE *)dataBuffer + v19) >> 7 << 7);
  v32 = calloc(5u, 1u);
  *(_DWORD *)(configPtr + 21) = v32;
  if ( !v32 )
  {
    v20 = 0;
    if ( (unsigned int)globalLogLevel > 3 )
    {
      strcpy(logBuffer, "Decode asic sendor addr OOM\n");
      logMessage(3, logBuffer, 0);
      v32 = *(_DWORD **)(configPtr + 21);
    }
  }
  *v32 = *(_DWORD *)((char *)dataBuffer + v60);
  *(_BYTE *)(configPtr + 25) = *(_BYTE *)(configPtr + 25) & 0x80 | *((_BYTE *)dataBuffer + v61) & 0x7F;
  *(_BYTE *)(configPtr + 25) = *(_BYTE *)(configPtr + 25) & 0x7F | (*((_BYTE *)dataBuffer + v61) >> 7 << 7);
  *(_BYTE *)(configPtr + 26) = *((_BYTE *)dataBuffer + v59);
  *(_BYTE *)(configPtr + 27) = *((_BYTE *)dataBuffer + v58);
  *(_BYTE *)(configPtr + 28) = *((_BYTE *)dataBuffer + v47);
  *(_BYTE *)(configPtr + 29) = *((_BYTE *)dataBuffer + v48);
  *(_BYTE *)(configPtr + 30) = *((_BYTE *)dataBuffer + v49);
  v33 = calloc(3u, 1u);
  *(_DWORD *)(configPtr + 31) = v33;
  if ( !v33 )
  {
    v20 = 0;
    if ( (unsigned int)globalLogLevel > 3 )
    {
      strcpy(logBuffer, "Decode Chip Technology OOM\n");
      logMessage(3, logBuffer, 0);
      v33 = *(_WORD **)(configPtr + 31);
    }
  }
  *v33 = *(_WORD *)((char *)dataBuffer + v50);
  *(_WORD *)(configPtr + 35) = __rev16(*(unsigned __int16 *)((char *)dataBuffer + v51));
  *(_WORD *)(configPtr + 37) = __rev16(*(unsigned __int16 *)((char *)dataBuffer + v52));
  v34 = (double)(unsigned __int16)__rev16(*(unsigned __int16 *)((char *)dataBuffer + v53)) / 100.0;
  *(float *)(configPtr + 39) = v34;
  *(_BYTE *)(configPtr + 43) = *((_BYTE *)dataBuffer + v54);
  *(_BYTE *)(configPtr + 44) = *((_BYTE *)dataBuffer + v55);
  *(_BYTE *)(configPtr + 45) = *((_BYTE *)dataBuffer + v56);
  *(_BYTE *)(configPtr + 46) = *((_BYTE *)dataBuffer + v57);
  v35 = calloc(9u, 1u);
  v36 = v35;
  *(_DWORD *)(configPtr + 47) = v35;
  if ( !v35 )
  {
    v20 = (int)&globalLogLevel;
    if ( (unsigned int)globalLogLevel > 3 )
    {
      strcpy(logBuffer, "Decode miner type OOM\n");
      logMessage(3, logBuffer, 0);
      v36 = *(_DWORD **)(configPtr + 47);
    }
    v44 = dataBuffer[18];
    *v36 = dataBuffer[17];
    v36[1] = v44;
    *(_BYTE *)(configPtr + 55) = *((_BYTE *)dataBuffer + v62);
    goto LABEL_48;
  }
  v37 = v20 == 0;
  if ( !v20 )
    v20 = (unsigned __int16)&globalLogLevel;
  v38 = dataBuffer[18];
  if ( v37 )
    HIWORD(v20) = (unsigned int)&globalLogLevel >> 16;
  v39 = *((_BYTE *)dataBuffer + v62);
  *v35 = dataBuffer[17];
  v35[1] = v38;
  *(_BYTE *)(configPtr + 55) = v39;
  if ( !v37 )
  {
    v40 = calculate_error_check_code(dataBuffer, 8 * (*(unsigned __int8 *)(configPtr + 1) - 1));
    v41 = *(unsigned __int8 *)(configPtr + 55);
    if ( v40 != v41 )
    {
      v20 = (int)&globalLogLevel;
      if ( (unsigned int)globalLogLevel <= 3 )
        return -1;
      snprintf(
        logBuffer,
        2048u,
        "Fixture CRC check fail.fixture_crc = 0x%x, len = 0x%x, crc = 0x%x\n",
        v41,
        *(unsigned __int8 *)(configPtr + 1),
        v40);
      logMessage(3, logBuffer, 0);
      goto LABEL_48;
    }
    *(_BYTE *)(configArrayPtr + chainIndex + 16) = 1;
    return readStatus;
  }
LABEL_48:
  logLevel = *(_DWORD *)v20;
LOG_ERROR:
  if ( logLevel <= 3 )
    return -1;
  snprintf(logBuffer, 2048u, "Data load fail for chain %d.\n", chainIndex);
  logMessage(3, logBuffer, 0);
  return -1;
}
// 7EB9C: using guessed type int globalLogLevel;

//----- (00017EF8) --------------------------------------------------------
void check_and_initialize_chain_config()
{
  unsigned int chain_index; // r4
  int config_update_status; // r6

  if ( globalChainConfigs[0] )
  {
    if ( *(_BYTE *)(globalChainConfigs[0] + 28) )
      return;
  }
  else if ( InitializeChainConfigurations() )
  {
    return;
  }
  chain_index = 0;
  config_update_status = 0;
  load_voltage_frequency_config();
  do
  {
    if ( get_global_buffer_value(chain_index) )
      config_update_status |= readAndDecodeChainConfig(chain_index, globalChainConfigs[0]);
    ++chain_index;
  }
  while ( chain_index != 4 );
  if ( !config_update_status )
    *(_BYTE *)(globalChainConfigs[0] + 28) = 1;
}
// 7F814: using guessed type int globalChainConfigs[];

//----- (00017F7C) --------------------------------------------------------
int get_global_chain_config_byte()
{
  return *(unsigned __int8 *)(globalChainConfigs[0] + 28);
}
// 7F814: using guessed type int globalChainConfigs[];

//----- (00017F90) --------------------------------------------------------
int check_all_chains_ready()
{
  int chain_index; // r4
  int is_ready; // r0

  chain_index = 0;
  while ( 1 )
  {
    if ( get_global_buffer_value(chain_index) )
    {
      is_ready = *(unsigned __int8 *)(globalChainConfigs[0] + chain_index + 20);
      if ( !*(_BYTE *)(globalChainConfigs[0] + chain_index + 20) )
        break;
    }
    if ( ++chain_index == 4 )
      return 1;
  }
  return is_ready;
}
// 7F814: using guessed type int globalChainConfigs[];

//----- (00017FD8) --------------------------------------------------------
size_t __fastcall GetChainSerialNumber(size_t chainIndex, char *serialNumberBuffer, size_t bufferLength)
{
  const char *serialNumber; // r6
  char logBuffer[2064]; // [sp+0h] [bp-810h] BYREF

  if ( globalChainConfigs[0] && *(_BYTE *)(globalChainConfigs[0] + 28) )
  {
    if ( serialNumberBuffer )
    {
      serialNumber = *(const char **)(*(_DWORD *)(globalChainConfigs[0] + 4 * chainIndex) + 3);
      chainIndex = strlen(serialNumber) + 1;
      if ( chainIndex <= bufferLength )
        return snprintf(serialNumberBuffer, bufferLength, "%s", serialNumber);
    }
  }
  else if ( (unsigned int)globalLogLevel > 3 )
  {
    snprintf(logBuffer, 2048u, "No hash board sn, chain = %d.\n", chainIndex);
    return logMessage(3, logBuffer, 0);
  }
  return chainIndex;
}
// 7EB9C: using guessed type int globalLogLevel;
// 7F814: using guessed type int globalChainConfigs[];

//----- (00018094) --------------------------------------------------------
int __fastcall getPCBVersionForChain(int chainIndex)
{
  char logBuffer[2056]; // [sp-808h] [bp-808h] BYREF

  if ( globalChainConfigs[0] && *(_BYTE *)(globalChainConfigs[0] + 28) )
    return *(unsigned __int8 *)(*(_DWORD *)(globalChainConfigs[0] + 4 * chainIndex) + 28) | (*(unsigned __int8 *)(*(_DWORD *)(globalChainConfigs[0] + 4 * chainIndex) + 27) << 8);
  if ( (unsigned int)globalLogLevel > 3 )
  {
    snprintf(logBuffer, 2048u, "No pcb version, chain = %d.\n", chainIndex);
    logMessage(3, logBuffer, 0);
  }
  return 65535;
}
// 7EB9C: using guessed type int globalLogLevel;
// 7F814: using guessed type int globalChainConfigs[];

//----- (00018128) --------------------------------------------------------
int __fastcall getChainBomVersion(int chainIndex)
{
  char logBuffer[2056]; // [sp-808h] [bp-808h] BYREF

  if ( globalChainConfigs[0] && *(_BYTE *)(globalChainConfigs[0] + 28) )
    return *(unsigned __int8 *)(*(_DWORD *)(globalChainConfigs[0] + 4 * chainIndex) + 30) | (*(unsigned __int8 *)(*(_DWORD *)(globalChainConfigs[0] + 4 * chainIndex) + 29) << 8);
  if ( (unsigned int)globalLogLevel > 3 )
  {
    snprintf(logBuffer, 2048u, "No bom version, chain = %d.\n", chainIndex);
    logMessage(3, logBuffer, 0);
  }
  return 65535;
}
// 7EB9C: using guessed type int globalLogLevel;
// 7F814: using guessed type int globalChainConfigs[];

//----- (000181BC) --------------------------------------------------------
int initialize_miner()
{
  return 0;
}

//----- (000181C4) --------------------------------------------------------
int __fastcall getChainTemperature(int chainIndex, _DWORD *temperature)
{
  int result; // r0
  int chainConfigOffset; // r3
  char logBuffer[2056]; // [sp-808h] [bp-808h] BYREF

  if ( globalChainConfigs[0] && *(_BYTE *)(globalChainConfigs[0] + 28) )
  {
    chainConfigOffset = *(_DWORD *)(globalChainConfigs[0] + 4 * chainIndex);
    result = 0;
    *temperature = *(unsigned __int8 *)(chainConfigOffset + 43);
  }
  else
  {
    if ( (unsigned int)globalLogLevel > 4 )
    {
      snprintf(logBuffer, 2048u, "No temp, chain = %d.\n", chainIndex);
      logMessage(4, logBuffer, 0);
    }
    return -1;
  }
  return result;
}
// 7EB9C: using guessed type int globalLogLevel;
// 7F814: using guessed type int globalChainConfigs[];

//----- (00018258) --------------------------------------------------------
int __fastcall getChainTestStandard(int chainIndex, _DWORD *testStandardOut)
{
  int chainConfigOffset; // r3
  int result; // r0
  char logBuffer[2056]; // [sp-808h] [bp-808h] BYREF

  if ( globalChainConfigs[0] && *(_BYTE *)(globalChainConfigs[0] + 28) )
  {
    if ( testStandardOut )
    {
      chainConfigOffset = *(_DWORD *)(globalChainConfigs[0] + 4 * chainIndex);
      result = 0;
      *testStandardOut = *(unsigned __int8 *)(chainConfigOffset + 46);
    }
    else
    {
      return -2;
    }
  }
  else
  {
    if ( (unsigned int)globalLogLevel > 3 )
    {
      snprintf(logBuffer, 2048u, "No test standard, chain = %d.\n", chainIndex);
      logMessage(3, logBuffer, 0);
    }
    return -1;
  }
  return result;
}
// 7EB9C: using guessed type int globalLogLevel;
// 7F814: using guessed type int globalChainConfigs[];

//----- (000182FC) --------------------------------------------------------
int __fastcall get_chain_voltage(int chain_index, _DWORD *voltage_ptr)
{
  int chain_config; // r3
  int status; // r0

  if ( globalChainConfigs[0] && *(_BYTE *)(globalChainConfigs[0] + 28) )
  {
    if ( voltage_ptr )
    {
      chain_config = *(_DWORD *)(globalChainConfigs[0] + 4 * chain_index);
      status = 0;
      *voltage_ptr = *(unsigned __int8 *)(chain_config + 15);
    }
    else
    {
      return -2;
    }
  }
  else if ( (unsigned int)globalLogLevel > 3 )
  {
    return logNoChipBinError(chain_index);
  }
  else
  {
    return -1;
  }
  return status;
}
// 7EB9C: using guessed type int globalLogLevel;
// 7F814: using guessed type int globalChainConfigs[];

//----- (00018360) --------------------------------------------------------
int __fastcall get_chain_version_string(int chain_index, char *version_buffer, size_t buffer_length)
{
  const char *version_string; // r6

  if ( globalChainConfigs[0] && *(_BYTE *)(globalChainConfigs[0] + 28) )
  {
    if ( version_buffer )
    {
      version_string = *(const char **)(*(_DWORD *)(globalChainConfigs[0] + 4 * chain_index) + 16);
      if ( strlen(version_string) >= buffer_length )
      {
        return -2;
      }
      else
      {
        snprintf(version_buffer, buffer_length, "%s", version_string);
        return 0;
      }
    }
    else
    {
      return -2;
    }
  }
  else if ( (unsigned int)globalLogLevel > 3 )
  {
    return logNoVersionError(chain_index);
  }
  else
  {
    return -1;
  }
}
// 7EB9C: using guessed type int globalLogLevel;
// 7F814: using guessed type int globalChainConfigs[];

//----- (000183FC) --------------------------------------------------------
int __fastcall setOptimalFrequency(int chainIndex, int mode, int *optimalFreq)
{
  int workModeValue; // r2
  int freqCodeValue; // r3
  int *freqCodeTablePtr; // r4
  __int64 freqCode; // r6
  int currentFreqCode; // r0
  bool isFreqMatch; // r2
  const char *chipType; // r0
  int chipTypeCompare; // r0
  int workModeCode; // r2
  bool isExactFreqMatch; // zf
  unsigned int upper32BitDiff; // r0
  unsigned int conditionCheck; // r0
  int unknownValue; // [sp+Ch] [bp-834h]
  int workModeState; // [sp+14h] [bp-82Ch] BYREF
  char logBuffer[2088]; // [sp+18h] [bp-828h] BYREF

  if ( globalChainConfigs[0] && *(_BYTE *)(globalChainConfigs[0] + 28) )
  {
    workModeValue = *(_DWORD *)(globalChainConfigs[0] + 4 * chainIndex);
    freqCodeValue = 1127301685;
    freqCodeTablePtr = &dword_7F81C;
    HIDWORD(freqCode) = *(unsigned __int16 *)(workModeValue + 35);
    LODWORD(freqCode) = *(unsigned __int16 *)(workModeValue + 37);
    while ( 1 )
    {
      currentFreqCode = *(freqCodeTablePtr - 1);
      if ( currentFreqCode )
      {
        isFreqMatch = currentFreqCode == HIDWORD(freqCode);
        if ( !*freqCodeTablePtr )
          isFreqMatch = 0;
        if ( *freqCodeTablePtr == (_DWORD)freqCode && isFreqMatch )
          break;
      }
LABEL_11:
      freqCodeTablePtr += 2;
      if ( &dword_7F8BC == freqCodeTablePtr )
      {
        if ( (unsigned int)globalLogLevel > 4 )
        {
          strcpy(logBuffer, "freq level not match");
          logMessage(4, logBuffer, 0);
        }
        return -2;
      }
    }
    unknownValue = freqCodeValue;
    chipType = (const char *)get_shared_variable();
    chipTypeCompare = strcmp(chipType, "NBS2003");
    freqCodeValue = unknownValue;
    if ( !chipTypeCompare )
    {
      memset(logBuffer, 0, 16);
      workModeState = 0;
      get_chain_version_string(chainIndex, logBuffer, 16u);
      get_chain_voltage(chainIndex, &workModeState);
      freqCodeValue = unknownValue;
      if ( *(_DWORD *)logBuffer == 810955078
        && *(_DWORD *)&logBuffer[4] == unknownValue
        && logBuffer[8] == 49
        && (unsigned int)(workModeState - 3) <= 1 )
      {
        isExactFreqMatch = (_DWORD)freqCode == 650;
        if ( (_DWORD)freqCode == 650 )
          isExactFreqMatch = HIDWORD(freqCode) == 1280;
        if ( isExactFreqMatch )
        {
          workModeCode = 600;
          goto LABEL_20;
        }
        workModeCode = 625;
        upper32BitDiff = __clz(freqCode - 625);
        if ( freqCode == 5583457485425LL )
          workModeCode = 575;
        conditionCheck = upper32BitDiff >> 5;
        if ( freqCode == 5583457485425LL )
        {
LABEL_20:
          if ( optimalFreq )
          {
            *optimalFreq = workModeCode;
            return 0;
          }
          goto LABEL_11;
        }
        if ( ((HIDWORD(freqCode) == 1280) & (unsigned __int8)conditionCheck) != 0 )
        {
          workModeCode = 575;
          if ( (_DWORD)freqCode == 650 )
            workModeCode = 600;
          goto LABEL_20;
        }
      }
    }
    workModeCode = freqCode;
    goto LABEL_20;
  }
  if ( (unsigned int)globalLogLevel > 4 )
  {
    snprintf(logBuffer, 2048u, "No work mode freq, chain = %d, mode = %d.\n", chainIndex, mode);
    logMessage(4, logBuffer, 0);
  }
  return -1;
}
// 7EB9C: using guessed type int globalLogLevel;
// 7F814: using guessed type int globalChainConfigs[];
// 7F81C: using guessed type int dword_7F81C;
// 7F8BC: using guessed type int dword_7F8BC;

//----- (00018654) --------------------------------------------------------
int __fastcall getVoltageLevel(int chainIndex, int modeIndex, int *voltageLevelOutput)
{
  int currentVoltage; // r2
  int knownVoltageCode; // r3
  int *voltageMap; // r4
  __int64 voltageFromConfig; // r6
  int registeredVoltage; // r0
  bool voltageMatch; // r2
  const char *chipModelName; // r0
  int chipModelComparisonResult; // r0
  int adjustedVoltage; // r2
  bool isVoltage7800Series; // r2
  int reportedResult; // [sp+Ch] [bp-834h]
  int voltageReading; // [sp+14h] [bp-82Ch] BYREF
  char logBuffer[2088]; // [sp+18h] [bp-828h] BYREF

  if ( globalChainConfigs[0] && *(_BYTE *)(globalChainConfigs[0] + 28) )
  {
    currentVoltage = *(_DWORD *)(globalChainConfigs[0] + 4 * chainIndex);
    knownVoltageCode = 1127301685;
    voltageMap = &dword_7F81C;
    LODWORD(voltageFromConfig) = *(unsigned __int16 *)(currentVoltage + 35);
    HIDWORD(voltageFromConfig) = *(unsigned __int16 *)(currentVoltage + 37);
    do
    {
      registeredVoltage = *(voltageMap - 1);
      if ( registeredVoltage )
      {
        voltageMatch = registeredVoltage == (_DWORD)voltageFromConfig;
        if ( !*voltageMap )
          voltageMatch = 0;
        if ( *voltageMap == HIDWORD(voltageFromConfig) && voltageMatch )
        {
          reportedResult = knownVoltageCode;
          chipModelName = (const char *)get_shared_variable();
          chipModelComparisonResult = strcmp(chipModelName, "NBS2003");
          knownVoltageCode = reportedResult;
          if ( chipModelComparisonResult )
            goto LABEL_19;
          memset(logBuffer, 0, 16);
          voltageReading = 0;
          get_chain_version_string(chainIndex, logBuffer, 16u);
          get_chain_voltage(chainIndex, &voltageReading);
          knownVoltageCode = reportedResult;
          if ( *(_DWORD *)logBuffer != 810955078
            || *(_DWORD *)&logBuffer[4] != reportedResult
            || logBuffer[8] != 49
            || (unsigned int)(voltageReading - 3) > 1 )
          {
            goto LABEL_19;
          }
          isVoltage7800Series = (_DWORD)voltageFromConfig == 1280;
          if ( voltageFromConfig == 2791728743680LL )
            goto LABEL_33;
          if ( (_DWORD)voltageFromConfig == 1300 )
            isVoltage7800Series = 1;
          if ( HIDWORD(voltageFromConfig) == 625 && isVoltage7800Series )
          {
LABEL_33:
            adjustedVoltage = 1260;
            if ( voltageReading != 3 )
              adjustedVoltage = 1240;
          }
          else
          {
LABEL_19:
            adjustedVoltage = voltageFromConfig;
          }
          if ( voltageLevelOutput )
          {
            *voltageLevelOutput = adjustedVoltage;
            return 0;
          }
        }
      }
      voltageMap += 2;
    }
    while ( &dword_7F8BC != voltageMap );
    if ( (unsigned int)globalLogLevel > 4 )
    {
      strcpy(logBuffer, "voltage level not match");
      logMessage(4, logBuffer, 0);
    }
    return -2;
  }
  else
  {
    if ( (unsigned int)globalLogLevel > 4 )
    {
      snprintf(logBuffer, 2048u, "No work mode voltage, chain = %d, mode = %d.\n", chainIndex, modeIndex);
      logMessage(4, logBuffer, 0);
    }
    return -1;
  }
}
// 7EB9C: using guessed type int globalLogLevel;
// 7F814: using guessed type int globalChainConfigs[];
// 7F81C: using guessed type int dword_7F81C;
// 7F8BC: using guessed type int dword_7F8BC;

//----- (000188A0) --------------------------------------------------------
int __fastcall GetHashRateForMode(int chainIndex, int modeIndex, _DWORD *pHashRate)
{
  int chainConfigOffset; // r3
  int result; // r0
  char logBuffer[2056]; // [sp+8h] [bp-808h] BYREF

  if ( globalChainConfigs[0] && *(_BYTE *)(globalChainConfigs[0] + 28) )
  {
    if ( pHashRate )
    {
      chainConfigOffset = *(_DWORD *)(globalChainConfigs[0] + 4 * chainIndex);
      result = 0;
      *pHashRate = *(unsigned __int16 *)(chainConfigOffset + 60);
    }
    else
    {
      return 0;
    }
  }
  else
  {
    if ( (unsigned int)globalLogLevel > 3 )
    {
      snprintf(logBuffer, 2048u, "No work mode hash rate, chain = %d, mode = %d.\n", chainIndex, modeIndex);
      logMessage(3, logBuffer, 0);
    }
    return 65535;
  }
  return result;
}
// 7EB9C: using guessed type int globalLogLevel;
// 7F814: using guessed type int globalChainConfigs[];

//----- (00018948) --------------------------------------------------------
int __fastcall setWorkModeConfiguration(int chainIndex, int workMode, int configPtr)
{
  int status; // r0
  int chainConfigAddr; // r3
  int configValue; // r12
  char logBuffer[2056]; // [sp+8h] [bp-808h] BYREF

  if ( globalChainConfigs[0]
    && *(_BYTE *)(globalChainConfigs[0] + 28)
    && (chainConfigAddr = *(_DWORD *)(globalChainConfigs[0] + 4 * chainIndex)) != 0 )
  {
    configValue = *(_DWORD *)(configPtr + 4);
    status = 0;
    *(_DWORD *)(chainConfigAddr + 58) = *(_DWORD *)configPtr;
    *(_DWORD *)(chainConfigAddr + 62) = configValue;
    *(_BYTE *)(chainConfigAddr + 66) = *(_BYTE *)(configPtr + 8);
  }
  else
  {
    if ( (unsigned int)globalLogLevel > 3 )
    {
      snprintf(
        logBuffer,
        2048u,
        "Can't set work mode conf, configuration is not loaded, chain = %d, mode = %d.\n",
        chainIndex,
        workMode);
      logMessage(3, logBuffer, 0);
    }
    return -1;
  }
  return status;
}
// 7EB9C: using guessed type int globalLogLevel;
// 7F814: using guessed type int globalChainConfigs[];

//----- (00018A0C) --------------------------------------------------------
int return_zero()
{
  return 0;
}

//----- (00018B30) --------------------------------------------------------
int __fastcall is_chain_config_active(unsigned int chain_id)
{
  unsigned int chain_config_offset; // r3
  int is_active; // r0

  if ( !globalChainConfigs[0] || chain_id > 4 )
    return 0;
  chain_config_offset = globalChainConfigs[0] + chain_id;
  is_active = *(unsigned __int8 *)(globalChainConfigs[0] + chain_id + 16);
  if ( *(_BYTE *)(chain_config_offset + 16) )
    return 1;
  return is_active;
}
// 7F814: using guessed type int globalChainConfigs[];

//----- (00018B68) --------------------------------------------------------
int logXXteaAlignmentError()
{
  char *errorMessage; // r12
  char logBuffer; // [sp+0h] [bp-808h] BYREF

  strcpy(errorMessage, "XXTEA requires the input as 64-bit aligned, fail to encode!\n");
  return logMessage(3, &logBuffer, 0);
}
// 18B84: variable 'errorMessage' is possibly undefined

//----- (00018BC0) --------------------------------------------------------
int check_xxtea_alignment_and_log_error()
{
  char *error_message_ptr; // r12
  char stack_buffer; // [sp+0h] [bp-808h] BYREF

  strcpy(error_message_ptr, "XXTEA requires the input as 64-bit aligned, fail to decode!\n");
  return logMessage(3, &stack_buffer, 0);
}
// 18BDC: variable 'error_message_ptr' is possibly undefined

//----- (00018C18) --------------------------------------------------------
_DWORD *__fastcall sub_18C18(_DWORD *result, _DWORD *a2, int a3)
{
  _DWORD *v3; // r2

  if ( a3 > 0 )
  {
    v3 = &result[a3];
    do
      *result++ ^= *a2;
    while ( result != v3 );
  }
  return result;
}

//----- (00018C40) --------------------------------------------------------
char *__fastcall get_encryption_key_reference(int data_type)
{
  char log_buffer[2056]; // [sp+0h] [bp-808h] BYREF

  if ( data_type == 3 && (unsigned int)globalLogLevel > 3 )
  {
    strcpy(log_buffer, "enc/dec undefined data type, use default key!\n");
    logMessage(3, log_buffer, 0);
  }
  if ( dword_7E298 == 2 )
    return (char *)&unk_7E2AC + 16 * data_type;
  if ( dword_7E298 == 3 )
    return (char *)&unk_7E29C + 4 * data_type;
  return 0;
}
// 7E298: using guessed type int dword_7E298;
// 7EB9C: using guessed type int globalLogLevel;

//----- (00018CE8) --------------------------------------------------------
char *__fastcall decrypt_data_block(_DWORD *data_buffer, int data_size, int key)
{
  char *decrypted_data; // r0
  int num_elements; // r5
  _DWORD *end_buffer; // r5
  _DWORD *current_element; // r3

  decrypted_data = get_encryption_key_reference(key);
  if ( dword_7E298 == 2 )
  {
    if ( (data_size & 7) != 0 )
    {
      if ( (unsigned int)globalLogLevel > 3 )
        return (char *)logXXteaAlignmentError();
    }
    else
    {
      return (char *)xxtea_encode((int)data_buffer, data_size / 4, (int)decrypted_data);
    }
  }
  else if ( dword_7E298 == 3 )
  {
    num_elements = data_size / 4;
    if ( num_elements > 0 )
    {
      end_buffer = &data_buffer[num_elements];
      current_element = data_buffer;
      do
        *current_element++ ^= *(_DWORD *)decrypted_data;
      while ( current_element != end_buffer );
    }
  }
  return decrypted_data;
}
// 7E298: using guessed type int dword_7E298;
// 7EB9C: using guessed type int globalLogLevel;

//----- (00018D98) --------------------------------------------------------
char *__fastcall process_encryption(_DWORD *input_data, int data_size, int encryption_key)
{
  char *encryption_result; // r0
  int block_count; // r5
  _DWORD *end_block_ptr; // r5
  _DWORD *current_block_ptr; // r3

  encryption_result = get_encryption_key_reference(encryption_key);
  if ( dword_7E298 == 2 )
  {
    if ( (data_size & 7) != 0 )
    {
      if ( (unsigned int)globalLogLevel > 3 )
        return (char *)check_xxtea_alignment_and_log_error();
    }
    else
    {
      return (char *)decrypt_xxtea((int)input_data, data_size / 4, (int)encryption_result);
    }
  }
  else if ( dword_7E298 == 3 )
  {
    block_count = data_size / 4;
    if ( block_count > 0 )
    {
      end_block_ptr = &input_data[block_count];
      current_block_ptr = input_data;
      do
        *current_block_ptr++ ^= *(_DWORD *)encryption_result;
      while ( current_block_ptr != end_block_ptr );
    }
  }
  return encryption_result;
}
// 7E298: using guessed type int dword_7E298;
// 7EB9C: using guessed type int globalLogLevel;

//----- (00018E48) --------------------------------------------------------
char *__fastcall process_eeprom_write(char *eeprom_buffer, char write_flags, int is_decrypt)
{
  char error_message[2056]; // [sp+0h] [bp-808h] BYREF

  if ( (write_flags & 3) != 0 )
  {
    if ( (unsigned int)globalLogLevel > 3 )
    {
      strcpy(error_message, "EEPROM write data is not 32-bit aligned, FAIL ENC/DEC!\n");
      return (char *)logMessage(3, error_message, 0);
    }
  }
  else if ( is_decrypt )
  {
    return decrypt_data_block(eeprom_buffer, write_flags, 1);
  }
  else
  {
    return process_encryption(eeprom_buffer, write_flags, 1);
  }
  return eeprom_buffer;
}
// 7EB9C: using guessed type int globalLogLevel;

//----- (00018EF0) --------------------------------------------------------
int __fastcall set_global_variable(int new_value)
{
  dword_7E298 = new_value;
  return new_value;
}
// 7E298: using guessed type int dword_7E298;

//----- (00018F00) --------------------------------------------------------
int get_global_status_flag()
{
  return dword_7E298;
}
// 7E298: using guessed type int dword_7E298;

//----- (00018F10) --------------------------------------------------------
int __fastcall xxtea_encode(int encoded_data, int data_count, int key_ptr)
{
  unsigned int *start_value_ptr; // r7
  unsigned int *last_value_ptr; // r8
  unsigned int cur_value; // r4
  int rounds; // r11
  unsigned int delta_sum; // r10
  unsigned int *value_ptr; // r5
  int index; // lr
  unsigned int temp_delta; // r9
  int temp_value; // r3
  int decode_delta_sum; // [sp+0h] [bp-830h]
  char log_buffer[2088]; // [sp+8h] [bp-828h] BYREF

  if ( data_count <= 1 )
  {
    if ( (unsigned int)globalLogLevel > 3 )
    {
      strcpy(log_buffer, "XXTEA encode failes, N <= 1 found.\n");
      return logMessage(3, log_buffer, 0);
    }
  }
  else
  {
    start_value_ptr = (unsigned int *)encoded_data;
    last_value_ptr = (unsigned int *)(encoded_data + 4 * (data_count + 1073741823));
    cur_value = *last_value_ptr;
    rounds = data_count - 1;
    delta_sum = 0;
    decode_delta_sum = -1253254570 - 1640531527 * call_external_function_with_check(52, data_count);
    do
    {
      value_ptr = start_value_ptr;
      index = 0;
      delta_sum -= 1640531527;
      temp_delta = delta_sum >> 2;
      do
      {
        temp_value = *(_DWORD *)(key_ptr + 4 * (((unsigned __int8)temp_delta ^ (unsigned __int8)index++) & 3));
        cur_value = (((temp_value ^ cur_value) + (delta_sum ^ value_ptr[1])) ^ (((4 * value_ptr[1]) ^ (cur_value >> 5))
                                                                              + ((16 * cur_value) ^ (value_ptr[1] >> 3))))
                  + *value_ptr;
        *value_ptr++ = cur_value;
      }
      while ( index != rounds );
      encoded_data = (16 * cur_value) ^ (*start_value_ptr >> 3);
      cur_value = (((cur_value ^ *(_DWORD *)(key_ptr + 4 * (((unsigned __int8)temp_delta ^ (unsigned __int8)rounds) & 3)))
                  + (delta_sum ^ *start_value_ptr)) ^ (((4 * *start_value_ptr) ^ (cur_value >> 5)) + encoded_data))
                + *last_value_ptr;
      *last_value_ptr = cur_value;
    }
    while ( delta_sum != decode_delta_sum );
  }
  return encoded_data;
}
// 7EB9C: using guessed type int globalLogLevel;

//----- (00019074) --------------------------------------------------------
int __fastcall decrypt_xxtea(int input_data, int input_data_len, int encryption_key)
{
  unsigned int *input_data_ptr; // r7
  int cycle_count; // r0
  unsigned int delta_sum; // r2
  unsigned int previous_value; // r3
  unsigned int *last_data_ptr; // r10
  int initial_sum; // r11
  int current_cycles; // r5
  unsigned int delta_sum_shifted; // r9
  unsigned int *current_data_ptr; // r6
  unsigned int current_value; // t1
  int key_part; // r4
  int value_xor_delta; // r4
  int last_index; // [sp+0h] [bp-830h]
  char log_message_buffer[2088]; // [sp+8h] [bp-828h] BYREF

  if ( input_data_len <= 1 )
  {
    if ( (unsigned int)globalLogLevel > 3 )
    {
      strcpy(log_message_buffer, "XXTEA decode failes, N <= 1 found.\n");
      return logMessage(3, log_message_buffer, 0);
    }
  }
  else
  {
    input_data_ptr = (unsigned int *)input_data;
    cycle_count = call_external_function_with_check(52, input_data_len);
    delta_sum = -1640531527 * (cycle_count + 6);
    last_index = input_data_len - 1;
    previous_value = *input_data_ptr;
    last_data_ptr = &input_data_ptr[input_data_len - 1];
    initial_sum = delta_sum + 1640531527 * cycle_count + 1253254570;
    do
    {
      current_cycles = last_index;
      delta_sum_shifted = delta_sum >> 2;
      current_data_ptr = last_data_ptr;
      do
      {
        current_value = *--current_data_ptr;
        key_part = *(_DWORD *)(encryption_key
                             + 4 * (((unsigned __int8)delta_sum_shifted ^ (unsigned __int8)current_cycles--) & 3));
        previous_value = current_data_ptr[1]
                       - (((current_value ^ key_part) + (delta_sum ^ previous_value)) ^ (((4 * previous_value) ^ (current_value >> 5))
                                                                                       + ((16 * current_value) ^ (previous_value >> 3))));
        current_data_ptr[1] = previous_value;
      }
      while ( current_cycles );
      value_xor_delta = previous_value ^ delta_sum;
      delta_sum += 1640531527;
      input_data = (4 * previous_value) ^ (*last_data_ptr >> 5);
      previous_value = *input_data_ptr
                     - ((input_data + ((16 * *last_data_ptr) ^ (previous_value >> 3))) ^ ((*last_data_ptr ^ *(_DWORD *)(encryption_key + 4 * (delta_sum_shifted & 3)))
                                                                                        + value_xor_delta));
      *input_data_ptr = previous_value;
    }
    while ( delta_sum != initial_sum );
  }
  return input_data;
}
// 7EB9C: using guessed type int globalLogLevel;

//----- (000191DC) --------------------------------------------------------
bool __fastcall is_chip_disabled(unsigned int chip_id)
{
  return (unsigned __int8)reset_pic(chip_id) == 0;
}

//----- (000191FC) --------------------------------------------------------
bool __fastcall is_success_response(unsigned int status_code)
{
  return (unsigned __int8)send_pic_heartbeat(status_code) == 0;
}

//----- (00019214) --------------------------------------------------------
int __fastcall initiatePICJumpToAppAndVerifyFirmware(int chainIndex)
{
  int firmwareVersion; // r0
  char logBuffer[2064]; // [sp+8h] [bp-810h] BYREF

  if ( (unsigned int)globalLogLevel > 3 )
  {
    snprintf(logBuffer, 2048u, "chain[%d] PIC jump to app\n", chainIndex);
    logMessage(3, logBuffer, 0);
  }
  start_app_on_chain((unsigned __int8)chainIndex);
  usleep(500000u);
  firmwareVersion = get_pic_version((unsigned __int8)chainIndex);
  if ( (unsigned int)globalLogLevel > 3 )
  {
    snprintf(logBuffer, 2048u, "Check chain[%d] PIC fw version=0x%02x\n", chainIndex, firmwareVersion);
    return logMessage(3, logBuffer, 0);
  }
  return firmwareVersion;
}
// 7EB9C: using guessed type int globalLogLevel;

//----- (000192C8) --------------------------------------------------------
int __fastcall readASICVoltage(int chainIndex)
{
  int status; // r0
  unsigned int logLevel; // r2
  double voltage; // d8
  int rawVoltageData[3]; // [sp+Ch] [bp-83Ch] BYREF
  char logBuffer[2096]; // [sp+18h] [bp-830h] BYREF

  memset(rawVoltageData, 0, sizeof(rawVoltageData));
  status = readVoltageFromPIC((unsigned __int8)chainIndex, rawVoltageData, 1);
  if ( (_BYTE)status )
  {
    logLevel = globalLogLevel;
    voltage = (double)rawVoltageData[0] * 3.3 * 0.0009765625 * 7.6;
    if ( (unsigned int)globalLogLevel > 5 )
    {
      snprintf(logBuffer, 2048u, "an0 = %f.\n", (double)rawVoltageData[0] * 3.3 * 0.0009765625 * 7.6);
      status = logMessage(5, logBuffer, 0);
      logLevel = globalLogLevel;
      voltage = (double)rawVoltageData[0] * 3.3 * 0.0009765625 * 7.6;
    }
  }
  else
  {
    voltage = 0.0;
    logLevel = globalLogLevel;
  }
  if ( logLevel > 4 )
  {
    snprintf(logBuffer, 2048u, "chain = %d, voltage = %f\n", chainIndex, voltage);
    return logMessage(4, logBuffer, 0);
  }
  return status;
}
// 7EB9C: using guessed type int globalLogLevel;

//----- (000193F8) --------------------------------------------------------
int get_minimal_voltage()
{
  double voltage_reading; // d0
  int asic_index; // r4
  double minimal_voltage; // d8
  int last_result; // r0
  char log_buffer[2072]; // [sp+8h] [bp-818h] BYREF

  asic_index = 0;
  minimal_voltage = 0.0;
  do
  {
    last_result = get_global_buffer_value(asic_index);
    if ( last_result )
    {
      last_result = readASICVoltage(asic_index);
      if ( voltage_reading > 0.1 )
      {
        if ( voltage_reading >= minimal_voltage )
        {
          if ( minimal_voltage < 0.1 )
            minimal_voltage = voltage_reading;
        }
        else
        {
          minimal_voltage = voltage_reading;
        }
      }
    }
    ++asic_index;
  }
  while ( asic_index != 4 );
  if ( (unsigned int)globalLogLevel > 4 )
  {
    snprintf(log_buffer, 2048u, "the minimal voltage = %.2f", minimal_voltage);
    return logMessage(4, log_buffer, 0);
  }
  return last_result;
}
// 19490: variable 'voltage_reading' is possibly undefined
// 7EB9C: using guessed type int globalLogLevel;

//----- (000194C8) --------------------------------------------------------
unsigned int initialize_and_sleep()
{
  check_and_reset_asic_state();
  return sleep(1u);
}

//----- (000194DC) --------------------------------------------------------
unsigned int wait_one_second()
{
  initialize_miner_setting();
  return sleep(1u);
}

//----- (000194F0) --------------------------------------------------------
int MonitorFrequencyStability()
{
  int elapsedSeconds; // r4
  int stableFrequency; // r5
  int result; // r0
  int frequencyDifference; // r3
  int currentFrequency; // r5
  int currentResult; // r0
  int currentDifference; // r3
  char logBuffer[2064]; // [sp+8h] [bp-810h] BYREF

  elapsedSeconds = 1;
  sleep(1u);
  do
  {
    do
    {
      ++elapsedSeconds;
      sleep(1u);
    }
    while ( elapsedSeconds <= 29 );
    stableFrequency = get_maximum_temperature();
    result = get_minimum_temp();
    frequencyDifference = stableFrequency - result;
    if ( stableFrequency - result < 0 )
      frequencyDifference = result - stableFrequency;
  }
  while ( frequencyDifference > 5 && elapsedSeconds != 180 );
  if ( (unsigned int)globalLogLevel > 3 )
  {
    currentFrequency = get_maximum_temperature();
    currentResult = get_minimum_temp();
    currentDifference = currentFrequency - currentResult;
    if ( currentFrequency - currentResult < 0 )
      currentDifference = currentResult - currentFrequency;
    snprintf(logBuffer, 2048u, "Slept %d seconds, diff = %d.\n", elapsedSeconds, currentDifference);
    return logMessage(3, logBuffer, 0);
  }
  return result;
}
// 7EB9C: using guessed type int globalLogLevel;

//----- (000195A8) --------------------------------------------------------
int __fastcall SetVoltageBySteps(int voltageStep)
{
  int result; // r0
  char logBuffer[2064]; // [sp+8h] [bp-810h] BYREF

  if ( (unsigned int)globalLogLevel > 3 )
  {
    snprintf(logBuffer, 2048u, "%s to %d.\n", "set_voltage_by_steps", voltageStep);
    logMessage(3, logBuffer, 0);
  }
  if ( set_voltage_and_send_power_control() < 0 )
  {
    if ( (unsigned int)globalLogLevel > 3 )
    {
      strcpy(logBuffer, "bitmain_set_voltage failed");
      logMessage(3, logBuffer, 0);
    }
    return -1;
  }
  else
  {
    result = 0;
    dword_7F8BC = voltageStep;
    dword_7F8C0 = voltageStep;
  }
  return result;
}
// 7EB9C: using guessed type int globalLogLevel;
// 7F8BC: using guessed type int dword_7F8BC;
// 7F8C0: using guessed type int dword_7F8C0;

//----- (00019698) --------------------------------------------------------
int __fastcall ValidatePowerVoltage(int targetVoltage)
{
  double measuredVoltage; // d0
  int powerVersion; // r5
  int v4; // r6
  int sleepCounter; // r5
  double adjustedVoltage; // d7
  unsigned int checkCounter; // r5
  int stabilityCounter; // r5
  char *v10; // r3
  int v11; // [sp+4h] [bp-83Ch]
  char logBuffer[2096]; // [sp+10h] [bp-830h] BYREF

  powerVersion = getPowerVersion();
  if ( (unsigned int)globalLogLevel > 3 )
  {
    snprintf(logBuffer, 2048u, "power type version: 0x%04x\n", powerVersion);
    logMessage(3, logBuffer, 0);
  }
  if ( is_id_in_list((unsigned __int16)powerVersion) )
  {
    if ( (unsigned int)globalLogLevel > 3 )
    {
      strcpy(logBuffer, "Enter sleep to make sure power release finish.\n");
      logMessage(3, logBuffer, 0);
    }
    initialize_miner_setting();
    sleep(1u);
    MonitorFrequencyStability();
    v4 = SetVoltageBySteps(targetVoltage);
    if ( v4 < 0 )
    {
      if ( (unsigned int)globalLogLevel > 3 )
      {
        snprintf(logBuffer, 2048u, "%s power iic error.\n", "power_init");
        logMessage(3, logBuffer, 0);
      }
      return v4;
    }
    check_and_reset_asic_state();
    sleep(1u);
    if ( (unsigned int)(powerVersion - 117) <= 3 )
    {
      sleepCounter = 3;
      while ( 1 )
      {
        sleep(1u);
        readASICVoltage(0);
        if ( measuredVoltage < 0.0 )
          break;
        measuredVoltage = measuredVoltage * 100.0;
        adjustedVoltage = (double)targetVoltage;
        if ( measuredVoltage <= (double)targetVoltage * 1.1 && measuredVoltage >= adjustedVoltage * 0.9 )
        {
          v4 = 0;
          goto LABEL_18;
        }
        if ( (unsigned int)globalLogLevel > 3 )
        {
          v10 = measuredVoltage - adjustedVoltage <= 0.0 ? "drop" : "rise";
          snprintf(logBuffer, 2048u, "chain avg vol %s from %d to %.2f", v10, targetVoltage, v11, measuredVoltage);
          logMessage(3, logBuffer, 0);
          if ( (unsigned int)globalLogLevel > 3 )
          {
            strcpy(logBuffer, "power voltage can not meet the target");
            logMessage(3, logBuffer, 0);
          }
        }
        if ( !--sleepCounter )
        {
          v4 = -1;
          goto LABEL_18;
        }
      }
      if ( (unsigned int)globalLogLevel > 3 )
      {
        strcpy(logBuffer, "read_feedback_voltage failed!");
        logMessage(3, logBuffer, 0);
      }
      v4 = 0;
      handle_error_with_logging(9u, "power voltage read failed, pls check!");
LABEL_18:
      checkCounter = 0;
      while ( 1 )
      {
        ++checkCounter;
        if ( !checkMinerPowerStatus() )
          break;
        if ( checkCounter == 5 * (checkCounter / 5) && (unsigned int)globalLogLevel > 3 )
        {
          strcpy(logBuffer, "bitmain_get_power_status failed!");
          logMessage(3, logBuffer, checkCounter % 5);
        }
        sleep(3u);
        if ( checkCounter == 20 )
          return -1;
      }
      return v4;
    }
    stabilityCounter = 3;
    while ( 1 )
    {
      sleep(1u);
      get_minimal_voltage();
      if ( measuredVoltage >= (double)targetVoltage * 0.75 / 100.0 )
        break;
      if ( (unsigned int)globalLogLevel > 3 )
      {
        strcpy(logBuffer, "power voltage can not meet the target");
        logMessage(3, logBuffer, 0);
      }
      if ( !--stabilityCounter )
        return -1;
    }
    return 0;
  }
  else
  {
    if ( (unsigned int)globalLogLevel <= 3 )
      return -1;
    strcpy(logBuffer, "power type version error\n");
    logMessage(3, logBuffer, 0);
    return -1;
  }
}
// 197A4: variable 'measuredVoltage' is possibly undefined
// 19988: variable 'v11' is possibly undefined
// 7EB9C: using guessed type int globalLogLevel;

//----- (00019AB4) --------------------------------------------------------
int get_global_flag()
{
  return dword_7F8BC;
}
// 7F8BC: using guessed type int dword_7F8BC;

//----- (00019AC4) --------------------------------------------------------
int calculate_percentage()
{
  double percentage_value; // d0

  sub_48F9C();
  return (int)(percentage_value * 100.0);
}
// 19AD4: variable 'percentage_value' is possibly undefined

//----- (00019D40) --------------------------------------------------------
int __fastcall compare_temperature_values(int temperature_info1, int temperature_info2)
{
  return *(_DWORD *)(temperature_info1 + 4) - *(_DWORD *)(temperature_info2 + 4);
}

//----- (00019D50) --------------------------------------------------------
int __fastcall compare_priority(int task1_ptr, int task2_ptr)
{
  return *(_DWORD *)(task2_ptr + 4) - *(_DWORD *)(task1_ptr + 4);
}

//----- (00019D60) --------------------------------------------------------
int __fastcall compare_values(_DWORD *value_ptr_1, _DWORD *value_ptr_2)
{
  return *value_ptr_1 - *value_ptr_2;
}

//----- (00019D70) --------------------------------------------------------
unsigned int *__fastcall calculate_min_max_total(
        unsigned int *input_array,
        unsigned int *min_value,
        unsigned int *max_value,
        _DWORD *total)
{
  unsigned int *final_result; // r0
  unsigned int *elements_count; // r6
  int sum; // r5
  unsigned int *end_ptr; // r6
  unsigned int max_local; // lr
  unsigned int min_local; // r4
  unsigned int current_value; // r12
  unsigned int temp_value; // t1

  final_result = (unsigned int *)get_global_variable_value();
  elements_count = final_result;
  if ( (int)final_result <= 0 )
  {
    sum = 0;
    min_local = 16777215;
    max_local = 0;
  }
  else
  {
    sum = 0;
    final_result = input_array;
    end_ptr = &input_array[(_DWORD)elements_count];
    max_local = 0;
    min_local = 16777215;
    do
    {
      temp_value = *final_result++;
      current_value = temp_value;
      sum += temp_value;
      if ( max_local < temp_value )
        max_local = current_value;
      if ( min_local >= current_value )
        min_local = current_value;
    }
    while ( final_result != end_ptr );
  }
  *min_value = min_local;
  *max_value = max_local;
  *total = sum;
  return final_result;
}

//----- (00019DE4) --------------------------------------------------------
int __fastcall calculate_hash_rate(int chain_index)
{
  int frequency_boundary; // r4
  int scaled_hash_rate; // r4
  int hash_rate; // [sp+4h] [bp-Ch] BYREF

  hash_rate = 0;
  if ( minerOperationMode == 2 )
  {
    frequency_boundary = ChainFrequencyBoundary[chain_index];
    scaled_hash_rate = get_global_variable_value() * frequency_boundary;
    return get_shared_value() * scaled_hash_rate / 1000 + hash_rate;
  }
  else
  {
    GetHashRateForMode(chain_index, (unsigned __int8)optBitmainWorkMode, &hash_rate);
    return hash_rate;
  }
}
// 7EDC8: using guessed type int minerOperationMode;
// 7F8C4: using guessed type _DWORD ChainFrequencyBoundary[4];
// 80FB4: using guessed type int optBitmainWorkMode;

//----- (00019E68) --------------------------------------------------------
int calculate_max_hash_rate()
{
  int global_variable_value; // r0
  int *variables_array; // r7
  int accumulated_hash_rate; // r4
  int chain_index; // r5
  int hash_rate_high_bits; // r1
  __int64 max_hash_rate; // r4
  int chain_iterator; // r5
  int chain_frequency_boundary; // r8
  int hash_rate_multiplier; // r8
  int current_variable_count; // r0
  int *variables_array_end; // r9
  int *current_variable_ptr; // r6
  int current_variable_value; // t1
  char log_buffer[2080]; // [sp+0h] [bp-820h] BYREF

  global_variable_value = get_global_variable_value();
  variables_array = (int *)calloc(global_variable_value, 4u);
  if ( variables_array )
  {
    accumulated_hash_rate = 0;
    if ( minerOperationMode == 2 )
    {
      chain_iterator = 0;
      if ( get_global_buffer_value(0) )
        goto LABEL_14;
      while ( ++chain_iterator != 4 )
      {
        if ( get_global_buffer_value(chain_iterator) )
        {
LABEL_14:
          chain_frequency_boundary = ChainFrequencyBoundary[chain_iterator];
          hash_rate_multiplier = get_global_variable_value() * chain_frequency_boundary;
          accumulated_hash_rate += get_shared_value() * hash_rate_multiplier;
        }
      }
    }
    else
    {
      for ( chain_index = 0; chain_index != 4; ++chain_index )
      {
        if ( get_global_buffer_value(chain_index) )
        {
          setOptimalFrequency(chain_index, (unsigned __int8)optBitmainWorkMode, variables_array);
          current_variable_count = get_global_variable_value();
          if ( current_variable_count > 0 )
          {
            variables_array_end = &variables_array[current_variable_count];
            current_variable_ptr = variables_array;
            do
            {
              current_variable_value = *current_variable_ptr++;
              accumulated_hash_rate += current_variable_value * get_shared_value();
            }
            while ( current_variable_ptr != variables_array_end );
          }
        }
      }
    }
    hash_rate_high_bits = accumulated_hash_rate >> 31;
    max_hash_rate = 274877907LL * accumulated_hash_rate;
    LODWORD(max_hash_rate) = (SHIDWORD(max_hash_rate) >> 6) - hash_rate_high_bits;
    dword_7F8D4 = max_hash_rate;
    if ( (unsigned int)globalLogLevel > 4 )
    {
      snprintf(log_buffer, 2048u, "max_hash_rate = %d\n", (SHIDWORD(max_hash_rate) >> 6) - hash_rate_high_bits);
      logMessage(4, log_buffer, 0);
      LODWORD(max_hash_rate) = dword_7F8D4;
    }
    free(variables_array);
  }
  else
  {
    LODWORD(max_hash_rate) = 0;
    if ( (unsigned int)globalLogLevel > 3 )
    {
      strcpy(log_buffer, "malloc buf failed!\n");
      logMessage(3, log_buffer, 0);
    }
  }
  return max_hash_rate;
}
// 7EB9C: using guessed type int globalLogLevel;
// 7EDC8: using guessed type int minerOperationMode;
// 7F8C4: using guessed type _DWORD ChainFrequencyBoundary[4];
// 7F8D4: using guessed type int dword_7F8D4;
// 80FB4: using guessed type int optBitmainWorkMode;

//----- (0001A014) --------------------------------------------------------
int calculate_ideal_hash_rate()
{
  unsigned int lowest_freq_value; // r6
  int chain_index; // r4
  int ideal_hash_rate_accum; // r4
  int i; // r5
  int chain_buffer_value; // r0
  int ideal_hash_rate_kHps; // r0
  int chain_hash_rate; // r7
  int chain_count; // r5
  int freq_boundary; // r7
  int hash_rate_multiplier; // r7
  unsigned int opt_freq_value; // [sp+4h] [bp-824h] BYREF
  char log_buffer[2080]; // [sp+8h] [bp-820h] BYREF

  if ( minerOperationMode == 2 )
  {
    ideal_hash_rate_accum = 0;
    chain_count = 0;
    if ( get_global_buffer_value(0) )
      goto LABEL_21;
    while ( ++chain_count != 4 )
    {
      if ( get_global_buffer_value(chain_count) )
      {
LABEL_21:
        freq_boundary = ChainFrequencyBoundary[chain_count];
        hash_rate_multiplier = get_global_variable_value() * freq_boundary;
        ideal_hash_rate_accum += get_shared_value() * hash_rate_multiplier;
      }
    }
  }
  else
  {
    lowest_freq_value = 0;
    for ( chain_index = 0; chain_index != 4; ++chain_index )
    {
      if ( get_global_buffer_value(chain_index)
        && !setOptimalFrequency(chain_index, (unsigned __int8)optBitmainWorkMode, (int *)&opt_freq_value) )
      {
        if ( lowest_freq_value )
        {
          if ( lowest_freq_value >= opt_freq_value )
            lowest_freq_value = opt_freq_value;
        }
        else
        {
          lowest_freq_value = opt_freq_value;
        }
      }
    }
    ideal_hash_rate_accum = 0;
    for ( i = 0; i != 4; ++i )
    {
      chain_buffer_value = i;
      if ( get_global_buffer_value(chain_buffer_value) )
      {
        chain_hash_rate = lowest_freq_value * get_global_variable_value();
        ideal_hash_rate_accum += get_shared_value() * chain_hash_rate;
      }
    }
  }
  ideal_hash_rate_kHps = ideal_hash_rate_accum / 1000;
  dword_7F8D8 = ideal_hash_rate_kHps;
  if ( (unsigned int)globalLogLevel > 4 )
  {
    snprintf(log_buffer, 2048u, "ideal_hash_rate = %d\n", ideal_hash_rate_accum / 1000);
    logMessage(4, log_buffer, 0);
    return dword_7F8D8;
  }
  return ideal_hash_rate_kHps;
}
// 7EB9C: using guessed type int globalLogLevel;
// 7EDC8: using guessed type int minerOperationMode;
// 7F8C4: using guessed type _DWORD ChainFrequencyBoundary[4];
// 7F8D8: using guessed type int dword_7F8D8;
// 80FB4: using guessed type int optBitmainWorkMode;

//----- (0001A18C) --------------------------------------------------------
int find_optimal_hash_rate()
{
  int current_hash_rate; // r6
  int optimal_hash_rate; // r4
  char *hash_rate_options_ptr; // r5
  unsigned int hash_rate_option_value; // t1
  int new_hash_rate; // r0
  unsigned int current_log_level; // r3
  int log_buffer; // [sp+0h] [bp-818h] BYREF
  int hash_rate_options[7]; // [sp+4h] [bp-814h] BYREF
  char hash_rate_options_end_marker; // [sp+20h] [bp-7F8h] BYREF

  current_hash_rate = calculate_ideal_hash_rate();
  log_buffer = 110000;
  hash_rate_options[0] = 105000;
  hash_rate_options[1] = 95000;
  hash_rate_options[2] = 90000;
  optimal_hash_rate = 110000;
  hash_rate_options[3] = (int)get_min_device_temperature;
  hash_rate_options[4] = 84000;
  hash_rate_options[5] = 81000;
  hash_rate_options[6] = 77000;
  if ( !call_external_function_with_check(current_hash_rate, 110000u) )
  {
    hash_rate_options_ptr = (char *)hash_rate_options;
    while ( 1 )
    {
      hash_rate_option_value = *(_DWORD *)hash_rate_options_ptr;
      hash_rate_options_ptr += 4;
      optimal_hash_rate = hash_rate_option_value;
      if ( call_external_function_with_check(current_hash_rate, hash_rate_option_value) )
        break;
      if ( hash_rate_options_ptr == &hash_rate_options_end_marker )
      {
        optimal_hash_rate = calculate_ideal_hash_rate();
        goto LABEL_6;
      }
    }
  }
  dword_7F8DC = optimal_hash_rate;
  new_hash_rate = calculate_ideal_hash_rate();
  if ( optimal_hash_rate )
  {
    current_log_level = globalLogLevel;
  }
  else
  {
    optimal_hash_rate = new_hash_rate;
LABEL_6:
    if ( (unsigned int)globalLogLevel <= 4 )
    {
      dword_7F8DC = optimal_hash_rate;
      return optimal_hash_rate;
    }
    snprintf((char *)&log_buffer, 2048u, "format sale hash failed %d\n", optimal_hash_rate);
    logMessage(4, (const char *)&log_buffer, 0);
    current_log_level = globalLogLevel;
  }
  dword_7F8DC = optimal_hash_rate;
  if ( current_log_level <= 4 )
    return optimal_hash_rate;
  snprintf((char *)&log_buffer, 2048u, "sale_hash_rate = %d\n", optimal_hash_rate);
  logMessage(4, (const char *)&log_buffer, 0);
  return dword_7F8DC;
}
// 7EB9C: using guessed type int globalLogLevel;
// 7F8DC: using guessed type int dword_7F8DC;
// 1A18C: using guessed type _DWORD var_814[7];

//----- (0001A2D8) --------------------------------------------------------
int sub_1A2D8()
{
  return 0;
}

//----- (0001A2E0) --------------------------------------------------------
int __fastcall get_chain_frequency(int chain_index)
{
  _DWORD *chain_frequency_ptr; // r3

  chain_frequency_ptr = ChainFrequencyBoundary;
  if ( minerOperationMode == 2 )
    chain_index = ChainFrequencyBoundary[chain_index];
  else
    chain_frequency_ptr = &ChainFrequencyBoundary[chain_index];
  if ( minerOperationMode != 2 )
    return chain_frequency_ptr[7];
  return chain_index;
}
// 7EDC8: using guessed type int minerOperationMode;
// 7F8C4: using guessed type _DWORD ChainFrequencyBoundary[4];

//----- (0001A470) --------------------------------------------------------
void __fastcall configureASICClock(int chain_id, unsigned int freq, int higher_voltage_flag)
{
  float v3; // s0
  const char *flag_str; // r3
  unsigned int post_div1; // r11
  unsigned int v6; // r8
  unsigned int v7; // r2
  unsigned int v8; // r6
  unsigned int v9; // r5
  _QWORD *v10; // r4
  int v11; // r7
  _QWORD *v12; // r4
  unsigned __int8 *v13; // r6
  int log_index; // r5
  int v15; // lr
  int v16; // r3
  int v17; // r1
  int v18; // r0
  int v19; // r12
  int post_div_index; // r6
  char v21; // r3
  char v22; // r1
  char v23; // r2
  unsigned int freq_result; // r3
  size_t nmemb; // [sp+14h] [bp-9E4h]
  int v26; // [sp+18h] [bp-9E0h]
  unsigned int new_post_div1; // [sp+24h] [bp-9D4h]
  char v30[4]; // [sp+34h] [bp-9C4h] BYREF
  __int64 div_values; // [sp+38h] [bp-9C0h] BYREF
  _QWORD div_combinations[49]; // [sp+40h] [bp-9B8h] BYREF
  char logBuffer[2096]; // [sp+1C8h] [bp-830h] BYREF

  if ( (unsigned int)globalLogLevel > 3 )
  {
    flag_str = "false";
    if ( higher_voltage_flag )
      flag_str = "true";
    snprintf(logBuffer, 2048u, "chain = %d, freq = %g, is_higher_voltage = %s\n", chain_id, v3, flag_str);
    logMessage(3, logBuffer, 0);
  }
  process_command(chain_id, 1, 0, freq);
  div_values = 0LL;
  memset(div_combinations, 0, sizeof(div_combinations));
  CalculateFrequencyDividers((int)&div_values, v30, 0);
  post_div1 = (unsigned __int8)v30[0];
  BYTE6(div_values) = v30[0];
  new_post_div1 = BYTE1(div_values);
  if ( (unsigned __int8)div_values > 7u )
  {
    nmemb = 0;
    v7 = globalLogLevel;
  }
  else
  {
    v26 = (unsigned __int8)div_values;
    v6 = (unsigned __int8)div_values;
    nmemb = 0;
    v7 = globalLogLevel;
    do
    {
      if ( new_post_div1 <= v6 )
      {
        v8 = new_post_div1;
        do
        {
          if ( post_div1 <= 1 )
          {
            v9 = post_div1;
            v10 = &div_combinations[nmemb];
            v11 = v8 * v26 * post_div1;
            do
            {
              *(_BYTE *)v10 = v6;
              *((_BYTE *)v10 + 1) = v8;
              *((_BYTE *)v10 + 2) = v9;
              *((_DWORD *)v10 + 1) = v11;
              if ( v7 > 4 )
              {
                snprintf(
                  logBuffer,
                  2048u,
                  "post_div1 = %d, post_div2 = %d, user_div = %d, div_ret = %d\n",
                  v26,
                  v8,
                  v9,
                  v11);
                logMessage(4, logBuffer, 0);
                v7 = globalLogLevel;
              }
              ++v9;
              ++v10;
              v11 += v8 * v26;
            }
            while ( (unsigned __int8)v9 <= 1u );
            nmemb += (unsigned __int8)(1 - post_div1) + 1;
          }
          v8 = (unsigned __int8)(v8 + 1);
        }
        while ( v8 <= v6 );
      }
      v6 = (unsigned __int8)++v26;
    }
    while ( (unsigned __int8)v26 <= 7u );
  }
  if ( v7 > 4 )
  {
    strcpy(logBuffer, "\n");
    logMessage(4, logBuffer, 0);
    if ( (unsigned int)globalLogLevel > 4 )
    {
      strcpy(logBuffer, "sorted\n");
      logMessage(4, logBuffer, 0);
    }
  }
  qsort(div_combinations, nmemb, 8u, (__compar_fn_t)compare_priority);
  if ( nmemb )
  {
    v12 = div_combinations;
    v13 = (unsigned __int8 *)div_combinations;
    log_index = 0;
    do
    {
      while ( (unsigned int)globalLogLevel <= 4 )
      {
        ++log_index;
        v13 += 8;
        if ( log_index == nmemb )
          goto LABEL_24;
      }
      v15 = *((_DWORD *)v13 + 1);
      v16 = log_index;
      v17 = v13[2];
      v18 = v13[1];
      ++log_index;
      v19 = *v13;
      v13 += 8;
      snprintf(
        logBuffer,
        2048u,
        "[%d] post_div1 = %d, post_div2 = %d, user_div = %d, div_ret = %d\n",
        v16,
        v19,
        v18,
        v17,
        v15);
      logMessage(4, logBuffer, 0);
    }
    while ( log_index != nmemb );
LABEL_24:
    post_div_index = 0;
    do
    {
      v21 = *((_BYTE *)v12++ + 2);
      v22 = *((_BYTE *)v12 - 8);
      v23 = *((_BYTE *)v12 - 7);
      BYTE6(div_values) = v21;
      LOBYTE(div_values) = v22;
      BYTE1(div_values) = v23;
      freq_result = calculate_hashrate_ratio(div_values, SHIDWORD(div_values));
      if ( dword_7EDCC < freq_result )
      {
        if ( (unsigned int)globalLogLevel > 3 )
        {
          snprintf(
            logBuffer,
            2048u,
            "[%d] _POSTDIV1 = %d, _POSTDIV2 = %d, USER_DIV = %d, freq = %d\n",
            post_div_index,
            (unsigned __int8)div_values,
            BYTE1(div_values),
            BYTE6(div_values),
            freq_result);
          logMessage(3, logBuffer, 0);
        }
        trigger_asic_operations(chain_id, 1, 0, freq, div_values, SWORD2(div_values));
        usleep((__useconds_t)&unk_F4240);
      }
      ++post_div_index;
    }
    while ( post_div_index != log_index );
  }
}
// 1A4D8: variable 'v3' is possibly undefined
// 7EB9C: using guessed type int globalLogLevel;
// 7EDCC: using guessed type int dword_7EDCC;
// 1A470: using guessed type char var_9C4[4];

//----- (0001A870) --------------------------------------------------------
int __fastcall SetFrequencyStep(unsigned int testMode, unsigned int freqStart, unsigned int freqEnd)
{
  float v3; // s0
  int i; // r4
  unsigned int v6; // r3
  unsigned int v7; // r6
  float v8; // s19
  float v9; // s17
  float v10; // s15
  float v11; // s16
  int j; // r4
  int k; // r4
  int result; // r0
  unsigned int v17; // [sp+1Ch] [bp-84Ch]
  char v18[4]; // [sp+24h] [bp-844h] BYREF
  int v19; // [sp+28h] [bp-840h] BYREF
  int v20; // [sp+2Ch] [bp-83Ch]
  char logBuffer[2104]; // [sp+30h] [bp-838h] BYREF

  if ( (unsigned int)globalLogLevel > 4 )
  {
    snprintf(logBuffer, 2048u, "fixed step freq_start = %d, freq_end = %d, freq_step = %.2f\n", freqStart, freqEnd, v3);
    logMessage(4, logBuffer, 0);
  }
  for ( i = 0; i != 4; ++i )
  {
    if ( get_global_buffer_value(i) )
      process_command(i, 1, 0, testMode);
  }
  if ( freqStart < freqEnd )
    v6 = freqEnd - freqStart;
  else
    v6 = freqStart;
  if ( freqStart >= freqEnd )
    v6 -= freqEnd;
  v17 = (unsigned int)(((float)((float)v6 + v3) - 0.01) / v3);
  if ( v17 )
  {
    v7 = 1;
    v8 = (float)freqStart;
    v9 = (float)freqEnd;
    do
    {
      v10 = (float)v7;
      v19 = 0;
      v20 = 0;
      if ( freqStart >= freqEnd )
      {
        v11 = v8 - (float)(v10 * v3);
        if ( v9 > v11 )
          v11 = (float)freqEnd;
      }
      else
      {
        v11 = v8 + (float)(v10 * v3);
        if ( v9 < v11 )
          v11 = (float)freqEnd;
      }
      for ( j = 0; j != 4; ++j )
      {
        if ( get_global_buffer_value(j) )
        {
          CalculateFrequencyDividers((int)&v19, v18, 0);
          BYTE2(v20) = v18[0];
          trigger_asic_operations(j, 1, 0, testMode, v19, v20);
          if ( (unsigned int)globalLogLevel > 4 )
          {
            snprintf(logBuffer, 2048u, "chain = %d set freq to %.2f", j, v11);
            logMessage(4, logBuffer, 0);
          }
          ChainFrequencyBoundary[j] = (int)v11;
          dword_7F8E0[j] = (int)v11;
        }
      }
      ++v7;
      usleep((__useconds_t)&loc_186A0);
    }
    while ( v17 >= v7 );
  }
  for ( k = 0; k != 4; ++k )
  {
    result = get_global_buffer_value(k);
    if ( result )
    {
      ChainFrequencyBoundary[k] = freqEnd;
      dword_7F8E0[k] = freqEnd;
    }
  }
  return result;
}
// 1AABC: variable 'v3' is possibly undefined
// 7EB9C: using guessed type int globalLogLevel;
// 7F8C4: using guessed type _DWORD ChainFrequencyBoundary[4];
// 7F8E0: using guessed type _DWORD dword_7F8E0[4];
// 1A870: using guessed type char var_844[4];

//----- (0001AAE4) --------------------------------------------------------
int __fastcall SetChainFrequency(
        int chainIndex,
        unsigned int baseFrequency,
        unsigned int targetFrequency,
        char *stepFrequency,
        char isHigherVoltage)
{
  float stepFreqValue; // s0
  char *endFrequency; // r7
  float frequencyStep; // s18
  const char *boolToStr; // r3
  int result; // r0
  unsigned int stepCount; // r3
  float startFreq; // s17
  float currentFrequency; // s19
  unsigned int currentStep; // r4
  float targetFreqAsFloat; // s16
  float newFrequency; // s0
  unsigned int iterations; // [sp+1Ch] [bp-854h]
  char *frequencyBuffer; // [sp+20h] [bp-850h]
  char stepResultBuffer[4]; // [sp+2Ch] [bp-844h] BYREF
  int stepResult; // [sp+30h] [bp-840h]
  char frequencyHasBeenSet; // [sp+36h] [bp-83Ah]
  char logBuffer[2104]; // [sp+38h] [bp-838h] BYREF

  endFrequency = stepFrequency;
  frequencyStep = stepFreqValue;
  if ( (unsigned int)globalLogLevel <= 4 )
    stepFrequency = logBuffer;
  if ( (unsigned int)globalLogLevel > 4 )
  {
    boolToStr = "false";
    if ( isHigherVoltage )
      boolToStr = "true";
    frequencyBuffer = logBuffer;
    snprintf(
      logBuffer,
      2048u,
      "fixed step chain = %d, freq_start = %d, freq_end = %d, freq_step = %.2f, is_higher_voltage = %s\n",
      chainIndex,
      targetFrequency,
      endFrequency,
      stepFreqValue,
      boolToStr);
    logMessage(4, logBuffer, 0);
  }
  else
  {
    frequencyBuffer = stepFrequency;
  }
  result = process_command(chainIndex, 1, 0, baseFrequency);
  *((_DWORD *)frequencyBuffer - 1) = 0;
  stepResult = 0;
  if ( targetFrequency >= (unsigned int)endFrequency )
    stepCount = targetFrequency - (_DWORD)endFrequency;
  else
    stepCount = (unsigned int)&endFrequency[-targetFrequency];
  iterations = (unsigned int)(((float)((float)stepCount + stepFreqValue) - 0.01) / stepFreqValue);
  if ( iterations )
  {
    startFreq = (float)(unsigned int)endFrequency;
    currentFrequency = (float)targetFrequency;
    currentStep = 1;
    do
    {
      newFrequency = (float)currentStep * frequencyStep;
      if ( targetFrequency < (unsigned int)endFrequency )
      {
        targetFreqAsFloat = newFrequency + currentFrequency;
        if ( (float)(newFrequency + currentFrequency) > startFreq )
          targetFreqAsFloat = (float)(unsigned int)endFrequency;
      }
      else
      {
        targetFreqAsFloat = currentFrequency - newFrequency;
        if ( (float)(currentFrequency - newFrequency) < startFreq )
          targetFreqAsFloat = (float)(unsigned int)endFrequency;
      }
      CalculateFrequencyDividers((int)(frequencyBuffer - 8), stepResultBuffer, 0);
      ++currentStep;
      frequencyHasBeenSet = stepResultBuffer[0];
      trigger_asic_operations(
        chainIndex,
        1,
        0,
        baseFrequency,
        *((_DWORD *)frequencyBuffer - 2),
        *((_DWORD *)frequencyBuffer - 1));
      if ( (unsigned int)globalLogLevel > 4 )
      {
        snprintf(frequencyBuffer, 2048u, "chain = %d set freq to %.2f", chainIndex, targetFreqAsFloat);
        logMessage(4, frequencyBuffer, 0);
      }
      result = usleep((__useconds_t)&loc_186A0);
    }
    while ( iterations >= currentStep );
  }
  ChainFrequencyBoundary[chainIndex] = endFrequency;
  ChainFrequencyBoundary[chainIndex + 7] = endFrequency;
  return result;
}
// 1AB10: variable 'stepFreqValue' is possibly undefined
// 7EB9C: using guessed type int globalLogLevel;
// 7F8C4: using guessed type _DWORD ChainFrequencyBoundary[4];
// 1AAE4: using guessed type char stepResultBuffer[4];

//----- (0001AD08) --------------------------------------------------------
unsigned int __fastcall setChipFrequencies(
        int control_board_address,
        unsigned int default_frequency,
        int mining_algorithm)
{
  float v3; // s0
  size_t chip_index; // r7
  int chain_id; // r4
  unsigned int *v7; // r5
  int i; // r6
  int j; // r4
  char *v10; // r3
  int k; // r10
  int v12; // r0
  _DWORD *v13; // r7
  int v14; // r4
  char *v15; // r5
  int global_state_value; // r11
  int global_value; // r6
  int m; // r10
  int v19; // r0
  int v20; // r6
  char *v21; // r6
  int v22; // r0
  int v23; // r0
  float v24; // s14
  char *v25; // r3
  unsigned int v26; // s15
  float v27; // s15
  float v28; // s16
  int n; // r6
  int v30; // r8
  int ii; // r4
  int v32; // r5
  float v33; // s15
  char v34; // r0
  unsigned int *v36; // r5
  unsigned int v37; // r2
  char *v38; // r3
  int global_variable_value; // r0
  unsigned int *v40; // r2
  int v41; // r1
  char *v42; // r6
  unsigned int v43; // t1
  unsigned int v44; // r5
  int v45; // r0
  int v48; // [sp+18h] [bp-1890h]
  int v49; // [sp+18h] [bp-1890h]
  unsigned int sorted_asic_index; // [sp+20h] [bp-1888h]
  unsigned int last_stable_frequency; // [sp+24h] [bp-1884h]
  unsigned int total_valid_asic; // [sp+30h] [bp-1878h] BYREF
  char temp_buffer[4]; // [sp+34h] [bp-1874h] BYREF
  int v54; // [sp+38h] [bp-1870h]
  int v55; // [sp+3Ch] [bp-186Ch]
  int frequency_offsets[4]; // [sp+40h] [bp-1868h] BYREF
  int adjusted_frequencies[4]; // [sp+50h] [bp-1858h] BYREF
  int frequency_bases[4]; // [sp+60h] [bp-1848h] BYREF
  int logBuffer[512]; // [sp+70h] [bp-1838h] BYREF
  char chain_frequencies[4152]; // [sp+870h] [bp-1038h] BYREF

  chip_index = 0;
  chain_id = 0;
  last_stable_frequency = 0;
  total_valid_asic = 0;
  memset(chain_frequencies, 0, 4096u);
  memset(adjusted_frequencies, 0, sizeof(adjusted_frequencies));
  memset(frequency_bases, 0, sizeof(frequency_bases));
  v54 = 0;
  v55 = 0;
  memset(frequency_offsets, 255, sizeof(frequency_offsets));
  do
  {
    if ( get_global_buffer_value(chain_id) )
    {
      v36 = (unsigned int *)(control_board_address + (chain_id << 10));
      calculate_min_max_total(
        v36,
        (unsigned int *)&frequency_offsets[chain_id],
        (unsigned int *)&adjusted_frequencies[chain_id],
        &total_valid_asic);
      v37 = adjusted_frequencies[chain_id];
      v38 = &chain_frequencies[4 * chip_index++];
      if ( last_stable_frequency >= v37 )
        v37 = last_stable_frequency;
      *((_DWORD *)v38 - 516) = frequency_offsets[chain_id];
      last_stable_frequency = v37;
      global_variable_value = get_global_variable_value();
      if ( global_variable_value )
      {
        v40 = &v36[global_variable_value];
        v41 = frequency_offsets[chain_id];
        v42 = &chain_frequencies[1024 * chain_id];
        do
        {
          v43 = *v36++;
          *(_DWORD *)v42 = v43 - v41;
          v42 += 4;
        }
        while ( v36 != v40 );
      }
      if ( minerOperationMode == 2 )
        ChainFrequencyBoundary[chain_id] = dword_482A6C;
      v44 = total_valid_asic;
      v45 = get_global_variable_value();
      dword_7F8E0[chain_id] = calculate_bit_difficulty(v44, v45);
    }
    ++chain_id;
  }
  while ( chain_id != 4 );
  qsort(frequency_bases, chip_index, 4u, (__compar_fn_t)compare_values);
  configureASICClock(255, default_frequency, mining_algorithm);
  if ( frequency_bases[0] != last_stable_frequency )
  {
    if ( chip_index > 1 )
    {
      v7 = (unsigned int *)frequency_bases;
      for ( i = 1; i != chip_index; ++i )
      {
        for ( j = 0; j != 4; ++j )
        {
          if ( get_global_buffer_value(j) )
          {
            v10 = (char *)v7[1];
            if ( frequency_offsets[j] >= (unsigned int)v10 )
              SetChainFrequency(j, default_frequency, *v7, v10, mining_algorithm);
          }
        }
        ++v7;
      }
    }
    for ( k = 0; k != 4; ++k )
    {
      if ( get_global_buffer_value(k) && frequency_offsets[k] != adjusted_frequencies[k] )
      {
        if ( (unsigned int)globalLogLevel > 3 )
        {
          snprintf((char *)logBuffer, 2048u, "chain = %d, start = %d, freq_step = %.2f\n", k, frequency_offsets[k], v3);
          logMessage(3, (const char *)logBuffer, 0);
        }
        v12 = get_global_variable_value();
        v13 = calloc(v12, 8u);
        if ( v13 )
        {
          v14 = 0;
          v15 = &chain_frequencies[1024 * k];
          logBuffer[0] = 0;
          logBuffer[1] = 0;
          global_state_value = get_global_state_value();
          if ( global_state_value )
          {
            v48 = k;
            do
            {
              global_value = get_global_value();
              if ( global_value )
              {
                for ( m = 0; m != global_value; ++m )
                {
                  v19 = m + v14 * get_global_value();
                  v13[2 * v19 + 1] = *(_DWORD *)&v15[4 * v19];
                  v13[2 * v19] = v19;
                }
              }
              v20 = 8 * v14++;
              v21 = (char *)v13 + get_global_value() * v20;
              v22 = get_global_value();
              qsort(v21, v22, 8u, (__compar_fn_t)compare_temperature_values);
            }
            while ( global_state_value != v14 );
            k = v48;
          }
          v23 = get_global_variable_value();
          v24 = 0.0;
          if ( v23 )
          {
            v25 = &v15[4 * v23];
            do
            {
              v26 = *(_DWORD *)v15;
              v15 += 4;
              v27 = (float)v26;
              if ( v27 > v24 )
                v24 = v27;
            }
            while ( v25 != v15 );
          }
          if ( (unsigned int)(float)((float)((float)(v3 + v24) - 1.0) / v3) )
          {
            sorted_asic_index = 0;
            do
            {
              ++sorted_asic_index;
              v49 = get_global_value();
              v28 = (float)sorted_asic_index * v3;
              if ( v49 )
              {
                for ( n = 0; n != v49; ++n )
                {
                  v30 = get_global_state_value();
                  if ( v30 )
                  {
                    for ( ii = 0; ii != v30; ++ii )
                    {
                      v32 = v13[2 * n + 2 * ii * get_global_value()];
                      v33 = (float)(unsigned int)v13[2 * n + 1 + 2 * ii * get_global_value()];
                      if ( v28 <= v33 || v3 > (float)(v28 - v33) )
                      {
                        CalculateFrequencyDividers((int)logBuffer, temp_buffer, 0);
                        BYTE2(logBuffer[1]) = temp_buffer[0];
                        v34 = sub_1E160();
                        trigger_asic_operations(
                          k,
                          0,
                          (unsigned __int8)(v34 * v32),
                          default_frequency,
                          logBuffer[0],
                          logBuffer[1]);
                      }
                    }
                  }
                  usleep((__useconds_t)&loc_186A0);
                }
              }
            }
            while ( (unsigned int)(float)((float)((float)(v3 + v24) - 1.0) / v3) != sorted_asic_index );
          }
          free(v13);
        }
        else if ( (unsigned int)globalLogLevel > 3 )
        {
          strcpy((char *)logBuffer, "failed alloc memory!\n");
          logMessage(3, (const char *)logBuffer, 0);
        }
      }
    }
  }
  return last_stable_frequency;
}
// 1AEC0: variable 'v3' is possibly undefined
// 7EB9C: using guessed type int globalLogLevel;
// 7EDC8: using guessed type int minerOperationMode;
// 7F8C4: using guessed type _DWORD ChainFrequencyBoundary[4];
// 7F8E0: using guessed type _DWORD dword_7F8E0[4];
// 482A6C: using guessed type int dword_482A6C;
// 1AD08: using guessed type char temp_buffer[4];

//----- (0001B248) --------------------------------------------------------
int __fastcall setChainFrequency(int chainIndex, unsigned int command, int freqMHz)
{
  char messageBuffer[4]; // [sp+14h] [bp-81Ch] BYREF
  char logBuffer[4]; // [sp+18h] [bp-818h] BYREF
  int parameterValue; // [sp+1Ch] [bp-814h]

  if ( (unsigned int)globalLogLevel > 3 )
  {
    snprintf(logBuffer, 2048u, "chain = %d, freq = %d\n", chainIndex, freqMHz);
    logMessage(3, logBuffer, 0);
  }
  *(_DWORD *)logBuffer = 0;
  parameterValue = 0;
  CalculateFrequencyDividers((int)logBuffer, messageBuffer, 0);
  BYTE2(parameterValue) = messageBuffer[0];
  return trigger_asic_operations(chainIndex, 1, 0, command, *(int *)logBuffer, parameterValue);
}
// 7EB9C: using guessed type int globalLogLevel;
// 1B248: using guessed type char messageBuffer[4];

//----- (0001B2FC) --------------------------------------------------------
int get_max_temperature()
{
  unsigned int max_temperature; // r5
  int chain_index; // r4
  int operation_temperature; // r5
  unsigned int min_temperature; // [sp+4h] [bp-1Ch] BYREF
  unsigned int current_max_temperature; // [sp+8h] [bp-18h] BYREF
  int total_temp_accumulated; // [sp+Ch] [bp-14h] BYREF

  if ( minerOperationMode == 2 )
  {
    operation_temperature = dword_482A6C;
    if ( (unsigned int)dword_482A6C < 50 )
      return 50;
    return operation_temperature;
  }
  else
  {
    max_temperature = 50;
    for ( chain_index = 0; chain_index != 4; ++chain_index )
    {
      if ( get_global_buffer_value(chain_index) )
      {
        calculate_min_max_total(
          &dword_4FBAA0[256 * chain_index],
          &min_temperature,
          &current_max_temperature,
          &total_temp_accumulated);
        if ( max_temperature < current_max_temperature )
          max_temperature = current_max_temperature;
      }
    }
    return max_temperature;
  }
}
// 7EDC8: using guessed type int minerOperationMode;
// 482A6C: using guessed type int dword_482A6C;
// 4FBAA0: using guessed type unsigned int dword_4FBAA0[1024];

//----- (0001B398) --------------------------------------------------------
int initializeGlobalBuffers()
{
  int numberOfChains; // r6
  size_t numberOfFans; // r7
  void *chainBuffer; // r5
  void *fanBuffer; // r0
  int initializationResult; // r3
  int fanBufferPointer; // r6
  char logBuffer[2072]; // [sp+0h] [bp-818h] BYREF

  numberOfChains = globalChainCount;
  numberOfFans = globalFanCount;
  chainBuffer = calloc(globalChainCount, 528u);
  globalChainBufferPtr = (int)chainBuffer;
  if ( chainBuffer )
  {
    fanBuffer = calloc(numberOfFans, 8u);
    fanBufferPointer = (int)fanBuffer;
    if ( fanBuffer )
      initializationResult = 1;
    dword_58E020 = (int)fanBuffer;
    if ( fanBuffer )
    {
      globalInitializationFlag = initializationResult;
      return 0;
    }
    else
    {
      if ( (unsigned int)globalLogLevel > 3 )
      {
        snprintf(logBuffer, 2048u, "malloc %d runtime_fan failed\n", numberOfFans);
        logMessage(3, logBuffer, fanBufferPointer);
        chainBuffer = (void *)globalChainBufferPtr;
      }
      free(chainBuffer);
      return -2147482624;
    }
  }
  else
  {
    if ( (unsigned int)globalLogLevel > 3 )
    {
      snprintf(logBuffer, 2048u, "malloc %d runtime_chain failed\n", numberOfChains);
      logMessage(3, logBuffer, 0);
    }
    return -2147482624;
  }
}
// 1B3E8: variable 'initializationResult' is possibly undefined
// 7EB9C: using guessed type int globalLogLevel;
// 58DFBC: using guessed type int globalChainCount;
// 58E004: using guessed type int globalFanCount;
// 58E010: using guessed type int globalInitializationFlag;
// 58E018: using guessed type int globalChainBufferPtr;
// 58E020: using guessed type int dword_58E020;

//----- (0001B4AC) --------------------------------------------------------
int sub_1B4AC()
{
  char *updated; // r0
  char *v1; // r4
  int v2; // r6
  _DWORD *v3; // r0
  _DWORD *v4; // r7
  unsigned int v5; // r3
  unsigned int *v6; // r3
  unsigned int v7; // r2
  unsigned int v8; // r2
  const char *v10; // r7
  size_t v11; // r0
  char *v12; // r0
  const char *v13; // r6
  _DWORD *v14; // r0
  unsigned int v15; // r3
  const char *v16; // lr
  int v17; // r0
  int v18; // r1
  int v19; // r2
  int v20; // r3
  _DWORD *v21; // lr
  int v22; // r1
  const char *second_element_if_ready; // r0
  _DWORD *v24; // r0
  unsigned int v25; // r3
  const char *v26; // r0
  const char *v27; // r0
  _DWORD *v28; // r0
  _DWORD *v29; // r6
  unsigned int v30; // r3
  _DWORD *v31; // r0
  unsigned int v32; // r3
  const char *v33; // r0
  _DWORD *v34; // r0
  _DWORD *v35; // r6
  unsigned int v36; // r3
  _DWORD *v37; // r0
  unsigned int v38; // r3
  const char *v39; // r12
  int v40; // r0
  int v41; // r1
  int v42; // r2
  int v43; // r3
  int v44; // r12
  const char *v45; // r12
  int v46; // r0
  int v47; // r1
  int v48; // r2
  int v49; // r3
  int v50; // r12
  const char *v51; // r0
  _DWORD *v52; // r0
  _DWORD *v53; // r9
  _DWORD *associated_pointer_or_null; // r7
  signed int v55; // r7
  _DWORD *task_by_index; // r0
  __int16 hardware_status; // r0
  int v58; // r3
  _DWORD *v59; // r0
  _DWORD *v60; // r0
  int v61; // r0
  int v62; // r0
  _DWORD *v63; // r0
  _DWORD *v64; // r8
  unsigned int v65; // r3
  unsigned int v66; // r6
  const char *v67; // r7
  const char *v68; // r9
  _DWORD *v69; // r0
  _DWORD *v70; // r9
  _DWORD *v71; // r0
  _DWORD *v72; // r7
  const char *v73; // r0
  _DWORD *v74; // r0
  _DWORD *v75; // r7
  _DWORD *v76; // r0
  int v77; // r0
  const char *v78; // r0
  _DWORD *v79; // r0
  _DWORD *v80; // r6
  unsigned int v81; // r3
  _DWORD *v82; // r0
  const char *v83; // r0
  _DWORD *v84; // r0
  _DWORD *v85; // r7
  const char *v86; // r0
  int v87; // r0
  const char *v88; // lr
  int v89; // r0
  int v90; // r1
  int v91; // r2
  int v92; // r3
  _DWORD *v93; // lr
  int v94; // r1
  int v95; // r2
  _DWORD *v96; // r0
  int v97; // r7
  const char *v98; // r0
  int v99; // r0
  _DWORD *v100; // r0
  int v101; // r7
  const char *v102; // r12
  int v103; // r0
  int v104; // r1
  int v105; // r2
  int v106; // r3
  _DWORD *v107; // r12
  int v108; // r1
  int v109; // r2
  int v110; // r3
  int v111; // r0
  _DWORD *v112; // r0
  int v113; // r7
  int v114; // r0
  _DWORD *v115; // r0
  int v116; // r7
  int v117; // r0
  _DWORD *v118; // r0
  int v119; // r6
  int v120; // r0
  _DWORD *v121; // r0
  int v122; // r6
  const char *v123; // r12
  int v124; // r0
  int v125; // r1
  int v126; // r2
  int v127; // r3
  _DWORD *v128; // r12
  int v129; // r1
  _DWORD *v130; // r0
  int v131; // r6
  int v132; // r0
  int v133; // r0
  _DWORD *v134; // r0
  int v135; // r6
  int v136; // r0
  _DWORD *v137; // r0
  int v138; // r6
  int v139; // r0
  _DWORD *v140; // r0
  int v141; // r6
  const char *v142; // lr
  int v143; // r0
  int v144; // r1
  int v145; // r2
  int v146; // r3
  _DWORD *v147; // lr
  int v148; // r1
  int v149; // r2
  int v150; // r0
  _DWORD *v151; // r0
  int v152; // r6
  int v153; // r0
  int v154; // r0
  int v155; // r8
  signed int v156; // r7
  int v157; // r6
  size_t v158; // r10
  signed int v159; // r9
  signed int v160; // r6
  int v161; // r8
  int v162; // r8
  void *v163; // r0
  void *v164; // r0
  int v165; // r0
  signed int i; // r3
  int v167; // r2
  int v168; // r2
  _DWORD *v169; // r0
  _DWORD *v170; // r6
  _DWORD *v171; // r0
  const char *v172; // r0
  _DWORD *v173; // r0
  int v174; // r0
  _DWORD *v175; // r0
  _DWORD *v176; // r8
  const char *v177; // r6
  _DWORD *v178; // r0
  unsigned int j; // r7
  _DWORD *v180; // r0
  _DWORD *v181; // r9
  _DWORD *v182; // r0
  int v183; // r10
  int v184; // r0
  int v185; // r6
  int v186; // r6
  _DWORD *v187; // r0
  const char *v188; // r0
  _DWORD *v189; // r0
  int v190; // r10
  int v191; // r0
  _DWORD *v192; // r0
  _DWORD *v193; // r10
  const char *v194; // r0
  const char *v195; // r0
  int v196; // r0
  char v197; // r3
  _DWORD *v198; // r0
  _DWORD *v199; // r0
  _DWORD *v200; // r6
  _DWORD *v201; // r0
  const char *v202; // r0
  _DWORD *v203; // r0
  int v204; // r0
  _DWORD *v205; // r0
  _DWORD *v206; // r7
  _DWORD *v207; // r0
  unsigned int k; // r6
  _DWORD *v209; // r0
  _DWORD *v210; // r9
  _DWORD *v211; // r0
  int v212; // r8
  int v213; // r0
  int v214; // r10
  int v215; // r8
  _DWORD *v216; // r0
  const char *v217; // r0
  _DWORD *v218; // r0
  int v219; // r9
  int v220; // r0
  _DWORD *v221; // r0
  unsigned int v222; // r7
  _DWORD *v223; // r0
  _DWORD *v224; // r4
  _DWORD *v225; // r0
  int v226; // r0
  _DWORD *v227; // r0
  _DWORD *v228; // r6
  int v229; // r6
  const void *v230; // r7
  int v231; // r3
  unsigned int m; // r10
  _DWORD *v233; // r0
  _DWORD *v234; // r4
  _DWORD *v235; // r0
  int v236; // r8
  int v237; // r0
  int v238; // r2
  _DWORD *v239; // r0
  int v240; // r4
  int v241; // r4
  _DWORD *v242; // r0
  _DWORD *v243; // r8
  _DWORD *v244; // r0
  int v245; // r9
  int v246; // r0
  _DWORD *v247; // r0
  int v248; // r8
  int v249; // r0
  int n; // r9
  int v251; // r6
  int v252; // r7
  char v253; // r3
  char *v254; // [sp+10h] [bp-940h]
  char *v255; // [sp+10h] [bp-940h]
  char *format; // [sp+14h] [bp-93Ch]
  char *formata; // [sp+14h] [bp-93Ch]
  char formatb; // [sp+14h] [bp-93Ch]
  char *v259; // [sp+18h] [bp-938h]
  int v260; // [sp+20h] [bp-930h]
  char v261[252]; // [sp+2Ch] [bp-924h] BYREF
  char s[2088]; // [sp+128h] [bp-828h] BYREF

  updated = (char *)update_miner_status_from_config("/etc/topol.conf", 0, v261);
  v1 = updated;
  if ( updated && !*(_DWORD *)updated )
  {
    v3 = (_DWORD *)initiate_task_if_ready(updated, "machine");
    v4 = v3;
    if ( !v3 )
    {
      v5 = globalLogLevel;
      goto LABEL_9;
    }
    v5 = globalLogLevel;
    if ( *v3 != 2 )
    {
LABEL_9:
      if ( v5 <= 3 )
        goto LABEL_10;
      strcpy(s, "get machine failed\n");
      logMessage(3, s, 0);
LABEL_18:
      if ( (unsigned int)globalLogLevel > 3 )
      {
        v2 = -1;
        strcpy(s, "parse machine failed\n");
        logMessage(3, s, 0);
        goto LABEL_11;
      }
      goto LABEL_10;
    }
    if ( (unsigned int)globalLogLevel > 3 )
    {
      second_element_if_ready = (const char *)get_second_element_if_ready(v3);
      snprintf(s, 2048u, "load machine %s conf\n", second_element_if_ready);
      logMessage(3, s, 0);
    }
    v10 = (const char *)get_second_element_if_ready(v4);
    v11 = strlen(v10);
    v12 = (char *)calloc(v11 + 1, 1u);
    v13 = v12;
    dword_58DFB8 = (int)v12;
    if ( !v12 )
    {
      if ( (unsigned int)globalLogLevel <= 3 )
        goto LABEL_10;
      strcpy(s, "get machine failed, Cannot allocate space\n");
      logMessage(3, s, 0);
      goto LABEL_18;
    }
    strcpy(v12, v10);
    if ( (unsigned int)globalLogLevel > 3 )
    {
      snprintf(s, 2048u, "machine : %s \n", v13);
      logMessage(3, s, 0);
    }
    v14 = (_DWORD *)initiate_task_if_ready(v1, "hw_version");
    if ( !v14 )
    {
      v15 = globalLogLevel;
LABEL_28:
      if ( v15 <= 3 )
        goto LABEL_10;
      v16 = "get hw_version failed\n";
LABEL_31:
      v17 = *(_DWORD *)v16;
      v18 = *((_DWORD *)v16 + 1);
      v19 = *((_DWORD *)v16 + 2);
      v20 = *((_DWORD *)v16 + 3);
      v21 = v16 + 16;
      *(_DWORD *)s = v17;
      *(_DWORD *)&s[4] = v18;
      *(_DWORD *)&s[8] = v19;
      *(_DWORD *)&s[12] = v20;
      v22 = v21[1];
      *(_DWORD *)&s[16] = *v21;
      *(_WORD *)&s[20] = v22;
      s[22] = BYTE2(v22);
      logMessage(3, s, 0);
      goto LABEL_18;
    }
    v15 = globalLogLevel;
    if ( *v14 != 2 )
      goto LABEL_28;
    if ( (unsigned int)globalLogLevel > 4 )
    {
      v26 = (const char *)get_second_element_if_ready(v14);
      snprintf(s, 2048u, "hw_version: %s\n", v26);
      logMessage(4, s, 0);
    }
    v24 = (_DWORD *)initiate_task_if_ready(v1, "sw_version");
    if ( !v24 )
    {
      v25 = globalLogLevel;
LABEL_39:
      if ( v25 <= 3 )
        goto LABEL_10;
      v16 = "get sw_version failed\n";
      goto LABEL_31;
    }
    v25 = globalLogLevel;
    if ( *v24 != 2 )
      goto LABEL_39;
    if ( (unsigned int)globalLogLevel > 4 )
    {
      v27 = (const char *)get_second_element_if_ready(v24);
      snprintf(s, 2048u, "sw_version: %s\n", v27);
      logMessage(4, s, 0);
    }
    v28 = (_DWORD *)initiate_task_if_ready(v1, "processor");
    v29 = v28;
    if ( !v28 )
    {
      v30 = globalLogLevel;
LABEL_55:
      if ( v30 <= 3 )
        goto LABEL_10;
      strcpy(s, "get processor failed\n");
      logMessage(3, s, 0);
      goto LABEL_53;
    }
    v30 = globalLogLevel;
    if ( *v28 )
      goto LABEL_55;
    if ( (unsigned int)globalLogLevel > 4 )
    {
      strcpy(s, "processor:\n");
      logMessage(4, s, 0);
    }
    v31 = (_DWORD *)initiate_task_if_ready(v29, "type");
    if ( !v31 )
    {
      v32 = globalLogLevel;
LABEL_51:
      if ( v32 <= 3 )
        goto LABEL_10;
      strcpy(s, "get type failed\n");
      logMessage(3, s, 0);
LABEL_53:
      if ( (unsigned int)globalLogLevel > 3 )
      {
        v2 = -1;
        strcpy(s, "parse processor failed\n");
        logMessage(3, s, 0);
        goto LABEL_11;
      }
      goto LABEL_10;
    }
    v32 = globalLogLevel;
    if ( *v31 != 2 )
      goto LABEL_51;
    if ( (unsigned int)globalLogLevel > 4 )
    {
      v33 = (const char *)get_second_element_if_ready(v31);
      snprintf(s, 2048u, "type: %s\n", v33);
      logMessage(4, s, 0);
    }
    v34 = (_DWORD *)initiate_task_if_ready(v1, "power");
    v35 = v34;
    if ( !v34 )
    {
      v36 = globalLogLevel;
LABEL_74:
      if ( v36 <= 3 )
        goto LABEL_10;
      strcpy(s, "get power failed\n");
      logMessage(3, s, 0);
      goto LABEL_71;
    }
    v36 = globalLogLevel;
    if ( *v34 )
      goto LABEL_74;
    if ( (unsigned int)globalLogLevel > 4 )
    {
      strcpy(s, "power:\n");
      logMessage(4, s, 0);
    }
    v37 = (_DWORD *)initiate_task_if_ready(v35, "type");
    if ( !v37 )
    {
      v38 = globalLogLevel;
LABEL_67:
      if ( v38 <= 3 )
        goto LABEL_10;
      v39 = "get type failed\n";
LABEL_70:
      v40 = *(_DWORD *)v39;
      v41 = *((_DWORD *)v39 + 1);
      v42 = *((_DWORD *)v39 + 2);
      v43 = *((_DWORD *)v39 + 3);
      v44 = *((_DWORD *)v39 + 4);
      *(_DWORD *)s = v40;
      *(_DWORD *)&s[4] = v41;
      *(_DWORD *)&s[8] = v42;
      *(_DWORD *)&s[12] = v43;
      s[16] = v44;
      logMessage(3, s, 0);
LABEL_71:
      if ( (unsigned int)globalLogLevel <= 3 )
        goto LABEL_10;
      v45 = "parse power failed\n";
      goto LABEL_73;
    }
    v38 = globalLogLevel;
    if ( *v37 != 2 )
      goto LABEL_67;
    if ( (unsigned int)globalLogLevel > 4 )
    {
      v51 = (const char *)get_second_element_if_ready(v37);
      snprintf(s, 2048u, "type: %s\n", v51);
      logMessage(4, s, 0);
    }
    v52 = (_DWORD *)initiate_task_if_ready(v35, "version");
    v53 = v52;
    if ( !v52 || *v52 != 1 )
    {
      if ( (unsigned int)globalLogLevel <= 3 )
        goto LABEL_10;
      strcpy(s, "get version array failed\n");
      logMessage(3, s, 0);
      goto LABEL_71;
    }
    associated_pointer_or_null = get_associated_pointer_or_null(v52);
    dword_58E038 = (int)associated_pointer_or_null;
    dword_58E03C = (int)calloc((size_t)associated_pointer_or_null, 2u);
    if ( (int)associated_pointer_or_null > 0 )
    {
      v55 = 0;
      do
      {
        task_by_index = get_task_by_index(v53, v55);
        hardware_status = get_hardware_status((int)task_by_index);
        v58 = 2 * v55++;
        *(_WORD *)(dword_58E03C + v58) = hardware_status;
        if ( (unsigned int)globalLogLevel > 4 )
        {
          snprintf(s, 2048u, "psu version = 0x%x", *(unsigned __int16 *)(dword_58E03C + v58));
          logMessage(4, s, 0);
        }
      }
      while ( v55 < dword_58E038 );
    }
    v59 = (_DWORD *)initiate_task_if_ready(v35, "i2c_addr");
    if ( !v59 || *v59 != 3 )
    {
      if ( (unsigned int)globalLogLevel <= 3 )
        goto LABEL_10;
      strcpy(s, "get i2c_addr failed\n");
      logMessage(3, s, 0);
      goto LABEL_71;
    }
    if ( (unsigned int)globalLogLevel > 4 )
    {
      v61 = get_hardware_status((int)v59);
      snprintf(s, 2048u, "i2c_addr: %d\n", v61);
      logMessage(4, s, 0);
    }
    v60 = (_DWORD *)initiate_task_if_ready(v35, "gpio");
    if ( !v60 || *v60 != 3 )
    {
      if ( (unsigned int)globalLogLevel <= 3 )
        goto LABEL_10;
      v39 = "get gpio failed\n";
      goto LABEL_70;
    }
    if ( (unsigned int)globalLogLevel > 4 )
    {
      v62 = get_hardware_status((int)v60);
      snprintf(s, 2048u, "gpio: %d\n", v62);
      logMessage(4, s, 0);
    }
    v63 = (_DWORD *)initiate_task_if_ready(v1, "fan");
    v64 = v63;
    if ( !v63 )
    {
      v65 = globalLogLevel;
LABEL_102:
      if ( v65 <= 3 )
        goto LABEL_10;
      strcpy(s, "get fan failed\n");
      logMessage(3, s, 0);
      goto LABEL_104;
    }
    v65 = globalLogLevel;
    if ( *v63 != 1 )
      goto LABEL_102;
    if ( (unsigned int)globalLogLevel > 4 )
    {
      strcpy(s, "fan:\n");
      logMessage(4, s, 0);
    }
    v66 = 0;
    v67 = 0;
    v68 = 0;
    while ( v66 < (unsigned int)get_associated_pointer_or_null(v64) )
    {
      v74 = get_task_by_index(v64, v66);
      v75 = v74;
      if ( !v74 || *v74 )
      {
        if ( (unsigned int)globalLogLevel <= 3 )
          goto LABEL_10;
        snprintf(s, 2048u, "get array %d failed\n", v66);
LABEL_127:
        logMessage(3, s, 0);
LABEL_104:
        if ( (unsigned int)globalLogLevel > 3 )
        {
          v2 = -1;
          strcpy(s, "parse fan failed\n");
          logMessage(3, s, 0);
          goto LABEL_11;
        }
        goto LABEL_10;
      }
      v76 = (_DWORD *)initiate_task_if_ready(v74, "id");
      if ( !v76 || *v76 != 3 )
      {
        if ( (unsigned int)globalLogLevel <= 3 )
          goto LABEL_10;
        snprintf(s, 2048u, "get arrya %d id failed\n", v66);
        goto LABEL_127;
      }
      if ( (unsigned int)globalLogLevel > 4 )
      {
        v77 = get_hardware_status((int)v76);
        snprintf(s, 2048u, "id: %d\n", v77);
        logMessage(4, s, 0);
      }
      v69 = (_DWORD *)initiate_task_if_ready(v75, "position");
      v70 = v69;
      if ( !v69 || *v69 != 2 )
      {
        if ( (unsigned int)globalLogLevel <= 3 )
          goto LABEL_10;
        snprintf(s, 2048u, "get arrya %d position failed\n", v66);
        goto LABEL_127;
      }
      if ( (unsigned int)globalLogLevel > 4 )
      {
        v78 = (const char *)get_second_element_if_ready(v69);
        snprintf(s, 2048u, "position: %s\n", v78);
        logMessage(4, s, 0);
      }
      v68 = (const char *)get_second_element_if_ready(v70);
      v71 = (_DWORD *)initiate_task_if_ready(v75, "direction");
      v72 = v71;
      if ( !v71 || *v71 != 2 )
      {
        if ( (unsigned int)globalLogLevel <= 3 )
          goto LABEL_10;
        snprintf(s, 2048u, "get arrya%d direction failed\n", v66);
        goto LABEL_127;
      }
      if ( (unsigned int)globalLogLevel > 4 )
      {
        v73 = (const char *)get_second_element_if_ready(v71);
        snprintf(s, 2048u, "direction: %s\n", v73);
        logMessage(4, s, 0);
      }
      ++v66;
      v67 = (const char *)get_second_element_if_ready(v72);
      ++globalFanCount;
    }
    if ( !strncmp(v68, "right", 5u) )
    {
      if ( strncmp(v67, "in", 2u) )
      {
        if ( strncmp(v68, "left", 4u) )
        {
          if ( strncmp(v67, "out", 2u) )
          {
LABEL_138:
            if ( (unsigned int)globalLogLevel <= 3 )
              goto LABEL_10;
            snprintf(s, 2048u, "unkonwn wind position %s, direction %s\n", v68, v67);
            logMessage(3, s, 0);
            goto LABEL_104;
          }
          goto LABEL_143;
        }
        if ( strncmp(v67, "out", 2u) )
          goto LABEL_138;
      }
    }
    else
    {
      if ( strncmp(v68, "left", 4u) )
        goto LABEL_138;
      if ( strncmp(v67, "out", 2u) )
      {
        if ( strncmp(v67, "in", 2u) )
          goto LABEL_138;
LABEL_143:
        dword_58E000 = 1;
LABEL_144:
        v79 = (_DWORD *)initiate_task_if_ready(v1, "asic");
        v80 = v79;
        if ( !v79 )
        {
          v81 = globalLogLevel;
LABEL_155:
          if ( v81 <= 3 )
            goto LABEL_10;
          strcpy(s, "get asic failed\n");
          logMessage(3, s, 0);
          goto LABEL_153;
        }
        v81 = globalLogLevel;
        if ( *v79 )
          goto LABEL_155;
        if ( (unsigned int)globalLogLevel > 4 )
        {
          strcpy(s, "asic:\n");
          logMessage(4, s, 0);
        }
        v82 = (_DWORD *)initiate_task_if_ready(v80, "asic_id");
        if ( !v82 || *v82 != 2 )
        {
          if ( (unsigned int)globalLogLevel <= 3 )
            goto LABEL_10;
          strcpy(s, "get asic_id failed\n");
          logMessage(3, s, 0);
LABEL_153:
          if ( (unsigned int)globalLogLevel > 3 )
          {
            v2 = -1;
            strcpy(s, "parse asic failed\n");
            logMessage(3, s, 0);
            goto LABEL_11;
          }
          goto LABEL_10;
        }
        if ( (unsigned int)globalLogLevel > 4 )
        {
          v83 = (const char *)get_second_element_if_ready(v82);
          snprintf(s, 2048u, "asic_id: %s\n", v83);
          logMessage(4, s, 0);
        }
        v84 = (_DWORD *)initiate_task_if_ready(v80, "asic_addr");
        v85 = v84;
        if ( !v84 || *v84 != 2 )
        {
          if ( (unsigned int)globalLogLevel <= 3 )
            goto LABEL_10;
          strcpy(s, "get asic_addr failed\n");
          logMessage(3, s, 0);
          goto LABEL_153;
        }
        if ( (unsigned int)globalLogLevel > 4 )
        {
          v98 = (const char *)get_second_element_if_ready(v84);
          snprintf(s, 2048u, "asic_addr : %s\n", v98);
          logMessage(4, s, 0);
        }
        v86 = (const char *)get_second_element_if_ready(v85);
        v87 = strtol(v86, 0, 0);
        dword_58DFD8 = v87;
        if ( !v87 )
        {
          if ( (unsigned int)globalLogLevel <= 3 )
            goto LABEL_10;
          v88 = "convert asic_addr failed\n";
          goto LABEL_168;
        }
        if ( (unsigned int)globalLogLevel > 4 )
        {
          snprintf(s, 2048u, "asic_addr 0x%x\n", v87);
          logMessage(4, s, 0);
        }
        v96 = (_DWORD *)initiate_task_if_ready(v80, "asic_core_num");
        v97 = (int)v96;
        if ( !v96 || *v96 != 3 )
        {
          if ( (unsigned int)globalLogLevel <= 3 )
            goto LABEL_10;
          v88 = "get asic_core_num failed\n";
LABEL_168:
          v89 = *(_DWORD *)v88;
          v90 = *((_DWORD *)v88 + 1);
          v91 = *((_DWORD *)v88 + 2);
          v92 = *((_DWORD *)v88 + 3);
          v93 = v88 + 16;
          *(_DWORD *)s = v89;
          *(_DWORD *)&s[4] = v90;
          *(_DWORD *)&s[8] = v91;
          *(_DWORD *)&s[12] = v92;
          v94 = v93[1];
          v95 = v93[2];
          *(_DWORD *)&s[16] = *v93;
          *(_DWORD *)&s[20] = v94;
          *(_WORD *)&s[24] = v95;
          logMessage(3, s, 0);
          goto LABEL_153;
        }
        if ( (unsigned int)globalLogLevel > 4 )
        {
          v99 = get_hardware_status((int)v96);
          snprintf(s, 2048u, "asic_core_num: %d\n", v99);
          logMessage(4, s, 0);
        }
        dword_58DFDC = get_hardware_status(v97);
        v100 = (_DWORD *)initiate_task_if_ready(v80, "asic_small_core_num");
        v101 = (int)v100;
        if ( !v100 || *v100 != 3 )
        {
          if ( (unsigned int)globalLogLevel <= 3 )
            goto LABEL_10;
          v102 = "get asic_small_core_num failed\n";
          goto LABEL_183;
        }
        if ( (unsigned int)globalLogLevel > 4 )
        {
          v111 = get_hardware_status((int)v100);
          snprintf(s, 2048u, "asic_small_core_num: %d\n", v111);
          logMessage(4, s, 0);
        }
        dword_58DFE0 = get_hardware_status(v101);
        v112 = (_DWORD *)initiate_task_if_ready(v80, "core_small_core_num");
        v113 = (int)v112;
        if ( !v112 || *v112 != 3 )
        {
          if ( (unsigned int)globalLogLevel <= 3 )
            goto LABEL_10;
          v102 = "get core_small_core_num failed\n";
LABEL_183:
          v103 = *(_DWORD *)v102;
          v104 = *((_DWORD *)v102 + 1);
          v105 = *((_DWORD *)v102 + 2);
          v106 = *((_DWORD *)v102 + 3);
          v107 = v102 + 16;
          *(_DWORD *)s = v103;
          *(_DWORD *)&s[4] = v104;
          *(_DWORD *)&s[8] = v105;
          *(_DWORD *)&s[12] = v106;
          v108 = v107[1];
          v109 = v107[2];
          v110 = v107[3];
          *(_DWORD *)&s[16] = *v107;
          *(_DWORD *)&s[20] = v108;
          *(_DWORD *)&s[24] = v109;
          *(_DWORD *)&s[28] = v110;
          logMessage(3, s, 0);
          goto LABEL_153;
        }
        if ( (unsigned int)globalLogLevel > 4 )
        {
          v114 = get_hardware_status((int)v112);
          snprintf(s, 2048u, "core_small_core_num: %d\n", v114);
          logMessage(4, s, 0);
        }
        dword_58DFE4 = get_hardware_status(v113);
        v115 = (_DWORD *)initiate_task_if_ready(v80, "asic_domain_num");
        v116 = (int)v115;
        if ( !v115 || *v115 != 3 )
        {
          if ( (unsigned int)globalLogLevel <= 3 )
            goto LABEL_10;
          strcpy(s, "get asic_domain_num failed\n");
          logMessage(3, s, 0);
          goto LABEL_153;
        }
        if ( (unsigned int)globalLogLevel > 4 )
        {
          v117 = get_hardware_status((int)v115);
          snprintf(s, 2048u, "asic_domain_num : %d\n", v117);
          logMessage(4, s, 0);
        }
        dword_58DFE8 = get_hardware_status(v116);
        v118 = (_DWORD *)initiate_task_if_ready(v80, "asic_addr_interval");
        v119 = (int)v118;
        if ( !v118 || *v118 != 3 )
        {
          if ( (unsigned int)globalLogLevel <= 3 )
            goto LABEL_10;
          strcpy(s, "get asic_addr_interval failed\n");
          logMessage(3, s, 0);
          goto LABEL_153;
        }
        if ( (unsigned int)globalLogLevel > 4 )
        {
          v120 = get_hardware_status((int)v118);
          snprintf(s, 2048u, "asic_addr_interval : %d\n", v120);
          logMessage(4, s, 0);
        }
        dword_58DFEC = get_hardware_status(v119);
        v254 = (char *)initiate_task_if_ready(v1, "chain");
        if ( !v254 || *(_DWORD *)v254 )
        {
          if ( (unsigned int)globalLogLevel <= 3 )
            goto LABEL_10;
          strcpy(s, "get chain failed\n");
          logMessage(3, s, 0);
          goto LABEL_213;
        }
        if ( (unsigned int)globalLogLevel > 4 )
        {
          strcpy(s, "chain:\n");
          logMessage(4, s, 0);
        }
        v121 = (_DWORD *)initiate_task_if_ready(v254, "chain_num");
        v122 = (int)v121;
        if ( !v121 || *v121 != 3 )
        {
          if ( (unsigned int)globalLogLevel <= 3 )
            goto LABEL_10;
          v123 = "get chain_num failed\n";
          goto LABEL_212;
        }
        if ( (unsigned int)globalLogLevel > 4 )
        {
          v132 = get_hardware_status((int)v121);
          snprintf(s, 2048u, "chain_num : %d\n", v132);
          logMessage(4, s, 0);
        }
        globalChainCount = get_hardware_status(v122);
        v130 = (_DWORD *)initiate_task_if_ready(v254, "chain_row");
        v131 = (int)v130;
        if ( !v130 || *v130 != 3 )
        {
          if ( (unsigned int)globalLogLevel <= 3 )
            goto LABEL_10;
          v123 = "get chain_row failed\n";
LABEL_212:
          v124 = *(_DWORD *)v123;
          v125 = *((_DWORD *)v123 + 1);
          v126 = *((_DWORD *)v123 + 2);
          v127 = *((_DWORD *)v123 + 3);
          v128 = v123 + 16;
          *(_DWORD *)s = v124;
          *(_DWORD *)&s[4] = v125;
          *(_DWORD *)&s[8] = v126;
          *(_DWORD *)&s[12] = v127;
          v129 = v128[1];
          *(_DWORD *)&s[16] = *v128;
          *(_WORD *)&s[20] = v129;
          logMessage(3, s, 0);
          goto LABEL_213;
        }
        if ( (unsigned int)globalLogLevel > 4 )
        {
          v133 = get_hardware_status((int)v130);
          snprintf(s, 2048u, "chain_row: %d\n", v133);
          logMessage(4, s, 0);
        }
        dword_58DFC0 = get_hardware_status(v131);
        v134 = (_DWORD *)initiate_task_if_ready(v254, "chain_column");
        v135 = (int)v134;
        if ( !v134 || *v134 != 3 )
        {
          if ( (unsigned int)globalLogLevel <= 3 )
            goto LABEL_10;
          strcpy(s, "get chain_column failed\n");
          logMessage(3, s, 0);
          goto LABEL_213;
        }
        if ( (unsigned int)globalLogLevel > 4 )
        {
          v136 = get_hardware_status((int)v134);
          snprintf(s, 2048u, "chain_column: %d\n", v136);
          logMessage(4, s, 0);
        }
        dword_58DFC4 = get_hardware_status(v135);
        v137 = (_DWORD *)initiate_task_if_ready(v254, "chain_domain_num");
        v138 = (int)v137;
        if ( !v137 || *v137 != 3 )
        {
          if ( (unsigned int)globalLogLevel <= 3 )
            goto LABEL_10;
          strcpy(s, "get chain_domain_num failed\n");
          logMessage(3, s, 0);
          goto LABEL_213;
        }
        if ( (unsigned int)globalLogLevel > 4 )
        {
          v139 = get_hardware_status((int)v137);
          snprintf(s, 2048u, "chain_domain_num : %d\n", v139);
          logMessage(4, s, 0);
        }
        dword_58DFC8 = get_hardware_status(v138);
        v140 = (_DWORD *)initiate_task_if_ready(v254, "chain_asic_num");
        v141 = (int)v140;
        if ( !v140 || *v140 != 3 )
        {
          if ( (unsigned int)globalLogLevel <= 3 )
            goto LABEL_10;
          v142 = "get chain_asic_num failed\n";
          goto LABEL_241;
        }
        if ( (unsigned int)globalLogLevel > 4 )
        {
          v150 = get_hardware_status((int)v140);
          snprintf(s, 2048u, "chain_asic_num : %d\n", v150);
          logMessage(4, s, 0);
        }
        dword_58DFCC = get_hardware_status(v141);
        v151 = (_DWORD *)initiate_task_if_ready(v254, "domain_asic_num");
        v152 = (int)v151;
        if ( !v151 || *v151 != 3 )
        {
          if ( (unsigned int)globalLogLevel <= 3 )
            goto LABEL_10;
          strcpy(s, "get domain_asic_num failed\n");
          logMessage(3, s, 0);
          goto LABEL_213;
        }
        if ( (unsigned int)globalLogLevel > 4 )
        {
          v153 = get_hardware_status((int)v151);
          snprintf(s, 2048u, "domain_asic_num : %d\n", v153);
          logMessage(4, s, 0);
        }
        v154 = get_hardware_status(v152);
        v155 = v154;
        dword_58DFD0 = v154;
        v156 = globalChainCount;
        v157 = dword_58DFC8;
        v158 = dword_58DFCC;
        if ( (unsigned int)globalLogLevel > 3 )
        {
          snprintf(
            s,
            2048u,
            "chain_num %d, chain_domain_num %d, chain_asic_num %d, domain_asic_num %d\n",
            globalChainCount,
            dword_58DFC8,
            dword_58DFCC,
            v154);
          logMessage(3, s, 0);
        }
        dword_58DFF0 = (int)calloc(v156, 20u);
        if ( !dword_58DFF0 )
        {
          if ( (unsigned int)globalLogLevel <= 3 )
            goto LABEL_10;
          snprintf(s, 2048u, "malloc %d chain_t failed\n", v156);
          goto LABEL_262;
        }
        v159 = v157;
        format = (char *)(28 * v155);
        v160 = 0;
        v259 = (char *)(-28 * v155);
        while ( v156 > v160 )
        {
          v161 = dword_58DFF0;
          *(_DWORD *)(dword_58DFF0 + 20 * v160) = v160;
          v162 = v161 + 20 * v160;
          v163 = calloc(v159, 8u);
          *(_DWORD *)(v162 + 12) = v163;
          if ( !v163 )
          {
            if ( (unsigned int)globalLogLevel <= 3 )
              goto LABEL_10;
            snprintf(s, 2048u, "malloc %d domain_t failed\n", v159);
LABEL_262:
            logMessage(3, s, 0);
            if ( (unsigned int)globalLogLevel <= 3 )
              goto LABEL_10;
            strcpy(s, "alloc topol failed\n");
            logMessage(3, s, 0);
            goto LABEL_213;
          }
          v164 = calloc(v158, 28u);
          *(_DWORD *)(v162 + 8) = v164;
          if ( !v164 )
          {
            if ( (unsigned int)globalLogLevel <= 3 )
              goto LABEL_10;
            snprintf(s, 2048u, "malloc %d asic_t failed\n", v158);
            goto LABEL_262;
          }
          v165 = 0;
          for ( i = 0; ; ++i )
          {
            v165 += (int)format;
            if ( v159 <= i )
              break;
            v167 = *(_DWORD *)(v162 + 12);
            *(_DWORD *)(v167 + 8 * i) = i;
            v168 = v167 + 8 * i;
            *(_DWORD *)(v168 + 4) = &v259[v165 + *(_DWORD *)(v162 + 8)];
          }
          ++v160;
        }
        v169 = (_DWORD *)initiate_task_if_ready(v254, "pic");
        v170 = v169;
        if ( !v169 || *v169 )
        {
          if ( (unsigned int)globalLogLevel <= 3 )
            goto LABEL_10;
          strcpy(s, "get pic failed\n");
          logMessage(3, s, 0);
          goto LABEL_273;
        }
        if ( (unsigned int)globalLogLevel > 4 )
        {
          strcpy(s, "pic:\n");
          logMessage(4, s, 0);
        }
        v171 = (_DWORD *)initiate_task_if_ready(v170, "type");
        if ( !v171 || *v171 != 2 )
        {
          if ( (unsigned int)globalLogLevel <= 3 )
            goto LABEL_10;
          strcpy(s, "get type failed\n");
          logMessage(3, s, 0);
          goto LABEL_273;
        }
        if ( (unsigned int)globalLogLevel > 4 )
        {
          v172 = (const char *)get_second_element_if_ready(v171);
          snprintf(s, 2048u, "type: %s\n", v172);
          logMessage(4, s, 0);
        }
        v173 = (_DWORD *)initiate_task_if_ready(v170, "i2c_addr");
        if ( !v173 || *v173 != 3 )
        {
          if ( (unsigned int)globalLogLevel <= 3 )
            goto LABEL_10;
          strcpy(s, "get i2c_addr failed\n");
          logMessage(3, s, 0);
          goto LABEL_273;
        }
        if ( (unsigned int)globalLogLevel > 4 )
        {
          v174 = get_hardware_status((int)v173);
          snprintf(s, 2048u, "i2c_addr: %d\n", v174);
          logMessage(4, s, 0);
        }
        v175 = (_DWORD *)initiate_task_if_ready(v170, "sensor");
        v176 = v175;
        if ( v175 && *v175 == 1 )
        {
          if ( (unsigned int)globalLogLevel > 4 )
          {
            strcpy(s, "pic sensor:\n");
            logMessage(4, s, 0);
          }
          dword_58DFF8 = (int)get_associated_pointer_or_null(v176);
          v178 = get_associated_pointer_or_null(v176);
          dword_58DFFC = (int)calloc((size_t)v178, 12u);
          if ( dword_58DFFC )
          {
            for ( j = 0; ; ++j )
            {
              if ( j >= (unsigned int)get_associated_pointer_or_null(v176) )
                goto LABEL_338;
              v180 = get_task_by_index(v176, j);
              v181 = v180;
              if ( !v180 || *v180 )
              {
                if ( (unsigned int)globalLogLevel <= 3 )
                  goto LABEL_10;
                snprintf(s, 2048u, "get array %d failed\n", j);
                goto LABEL_327;
              }
              v182 = (_DWORD *)initiate_task_if_ready(v180, "index");
              v183 = (int)v182;
              if ( !v182 || *v182 != 3 )
              {
                if ( (unsigned int)globalLogLevel <= 3 )
                  goto LABEL_10;
                snprintf(s, 2048u, "get array %d index failed\n", j);
                goto LABEL_327;
              }
              if ( (unsigned int)globalLogLevel > 4 )
              {
                v184 = get_hardware_status((int)v182);
                snprintf(s, 2048u, "index: %d\n", v184);
                logMessage(4, s, 0);
              }
              v260 = dword_58DFFC;
              v185 = 12 * get_hardware_status(v183);
              *(_DWORD *)(v260 + v185) = get_hardware_status(v183);
              v186 = v260 + v185;
              v187 = (_DWORD *)initiate_task_if_ready(v181, "type");
              if ( !v187 || *v187 != 2 )
              {
                if ( (unsigned int)globalLogLevel <= 3 )
                  goto LABEL_10;
                snprintf(s, 2048u, "get array %d type failed\n", j);
                goto LABEL_327;
              }
              if ( (unsigned int)globalLogLevel > 4 )
              {
                v188 = (const char *)get_second_element_if_ready(v187);
                snprintf(s, 2048u, "type: %s\n", v188);
                logMessage(4, s, 0);
              }
              v189 = (_DWORD *)initiate_task_if_ready(v181, "iic");
              v190 = (int)v189;
              if ( !v189 || *v189 != 3 )
              {
                if ( (unsigned int)globalLogLevel <= 3 )
                  goto LABEL_10;
                snprintf(s, 2048u, "get array %d bind_asic failed\n", j);
                goto LABEL_327;
              }
              if ( (unsigned int)globalLogLevel > 4 )
              {
                v191 = get_hardware_status((int)v189);
                snprintf(s, 2048u, "iic: %d\n", v191);
                logMessage(4, s, 0);
              }
              *(_DWORD *)(v186 + 4) = get_hardware_status(v190);
              v192 = (_DWORD *)initiate_task_if_ready(v181, "x");
              v193 = v192;
              if ( !v192 || *v192 != 2 )
                break;
              if ( (unsigned int)globalLogLevel > 4 )
              {
                v194 = (const char *)get_second_element_if_ready(v192);
                snprintf(s, 2048u, "x: %s\n", v194);
                logMessage(4, s, 0);
              }
              if ( !dword_58E000 )
              {
                v195 = (const char *)get_second_element_if_ready(v193);
                v196 = strncasecmp(v195, "right", 5u);
                if ( v196 )
                  *(_BYTE *)(v186 + 8) = 0;
                else
                  v197 = 1;
                if ( !v196 )
                  *(_BYTE *)(v186 + 8) = v197;
              }
            }
            if ( (unsigned int)globalLogLevel <= 3 )
              goto LABEL_10;
            snprintf(s, 2048u, "get array %d x failed\n", j);
LABEL_327:
            logMessage(3, s, 0);
          }
          else
          {
            if ( (unsigned int)globalLogLevel <= 3 )
              goto LABEL_10;
            v198 = get_associated_pointer_or_null(v176);
            snprintf(s, 2048u, "malloc %d sensor_t failed\n", v198);
            logMessage(3, s, 0);
          }
LABEL_273:
          if ( (unsigned int)globalLogLevel <= 3 )
            goto LABEL_10;
          strcpy(s, "parse chain pic failed\n");
          logMessage(3, s, 0);
          goto LABEL_213;
        }
        v177 = (const char *)dword_58DFB8;
        if ( strcmp((const char *)dword_58DFB8, "BHB28601") && strcmp(v177, "BHB28501") )
        {
          if ( (unsigned int)globalLogLevel <= 3 )
            goto LABEL_10;
          strcpy(s, "get pic sensor failed\n");
          logMessage(3, s, 0);
          goto LABEL_273;
        }
LABEL_338:
        v199 = (_DWORD *)initiate_task_if_ready(v254, "eeprom");
        v200 = v199;
        if ( !v199 || *v199 )
        {
          if ( (unsigned int)globalLogLevel <= 3 )
            goto LABEL_10;
          strcpy(s, "get eeprom failed\n");
          logMessage(3, s, 0);
          goto LABEL_342;
        }
        if ( (unsigned int)globalLogLevel > 4 )
        {
          strcpy(s, "eeprom:\n");
          logMessage(4, s, 0);
        }
        v201 = (_DWORD *)initiate_task_if_ready(v200, "type");
        if ( !v201 || *v201 != 2 )
        {
          if ( (unsigned int)globalLogLevel <= 3 )
            goto LABEL_10;
          strcpy(s, "get type failed\n");
          logMessage(3, s, 0);
          goto LABEL_342;
        }
        if ( (unsigned int)globalLogLevel > 4 )
        {
          v202 = (const char *)get_second_element_if_ready(v201);
          snprintf(s, 2048u, "type: %s\n", v202);
          logMessage(4, s, 0);
        }
        v203 = (_DWORD *)initiate_task_if_ready(v200, "i2c_addr");
        if ( !v203 || *v203 != 3 )
        {
          if ( (unsigned int)globalLogLevel <= 3 )
            goto LABEL_10;
          strcpy(s, "get i2c_addr failed\n");
          logMessage(3, s, 0);
LABEL_342:
          if ( (unsigned int)globalLogLevel <= 3 )
            goto LABEL_10;
          v142 = "parse chain eeprom failed\n";
          goto LABEL_241;
        }
        if ( (unsigned int)globalLogLevel > 4 )
        {
          v204 = get_hardware_status((int)v203);
          snprintf(s, 2048u, "i2c_addr: %d\n", v204);
          logMessage(4, s, 0);
        }
        v205 = (_DWORD *)initiate_task_if_ready(v254, "sensor");
        v206 = v205;
        if ( !v205 || *v205 != 1 )
        {
          if ( (unsigned int)globalLogLevel <= 3 )
            goto LABEL_10;
          strcpy(s, "get sensor failed\n");
          logMessage(3, s, 0);
          goto LABEL_362;
        }
        if ( (unsigned int)globalLogLevel > 4 )
        {
          strcpy(s, "sensor:\n");
          logMessage(4, s, 0);
        }
        dword_58DFD4 = (int)get_associated_pointer_or_null(v206);
        v207 = get_associated_pointer_or_null(v206);
        dword_58DFF4 = (int)calloc((size_t)v207, 12u);
        if ( !dword_58DFF4 )
        {
          if ( (unsigned int)globalLogLevel <= 3 )
            goto LABEL_10;
          v221 = get_associated_pointer_or_null(v206);
          snprintf(s, 2048u, "malloc %d sensor_t failed\n", v221);
          logMessage(3, s, 0);
          goto LABEL_362;
        }
        for ( k = 0; k < (unsigned int)get_associated_pointer_or_null(v206); ++k )
        {
          v209 = get_task_by_index(v206, k);
          v210 = v209;
          if ( !v209 || *v209 )
          {
            if ( (unsigned int)globalLogLevel <= 3 )
              goto LABEL_10;
            snprintf(s, 2048u, "get array %d failed\n", k);
            goto LABEL_386;
          }
          v211 = (_DWORD *)initiate_task_if_ready(v209, "index");
          v212 = (int)v211;
          if ( !v211 || *v211 != 3 )
          {
            if ( (unsigned int)globalLogLevel <= 3 )
              goto LABEL_10;
            snprintf(s, 2048u, "get array %d index failed\n", k);
LABEL_386:
            logMessage(3, s, 0);
LABEL_362:
            if ( (unsigned int)globalLogLevel <= 3 )
              goto LABEL_10;
            v142 = "parse chain sensor failed\n";
LABEL_241:
            v143 = *(_DWORD *)v142;
            v144 = *((_DWORD *)v142 + 1);
            v145 = *((_DWORD *)v142 + 2);
            v146 = *((_DWORD *)v142 + 3);
            v147 = v142 + 16;
            *(_DWORD *)s = v143;
            *(_DWORD *)&s[4] = v144;
            *(_DWORD *)&s[8] = v145;
            *(_DWORD *)&s[12] = v146;
            v148 = v147[1];
            v149 = v147[2];
            *(_DWORD *)&s[16] = *v147;
            *(_DWORD *)&s[20] = v148;
            *(_WORD *)&s[24] = v149;
            s[26] = BYTE2(v149);
            logMessage(3, s, 0);
LABEL_213:
            if ( (unsigned int)globalLogLevel <= 3 )
              goto LABEL_10;
            v45 = "parse chain failed\n";
LABEL_73:
            v46 = *(_DWORD *)v45;
            v47 = *((_DWORD *)v45 + 1);
            v48 = *((_DWORD *)v45 + 2);
            v49 = *((_DWORD *)v45 + 3);
            v2 = -1;
            v50 = *((_DWORD *)v45 + 4);
            *(_DWORD *)s = v46;
            *(_DWORD *)&s[4] = v47;
            *(_DWORD *)&s[8] = v48;
            *(_DWORD *)&s[12] = v49;
            *(_DWORD *)&s[16] = v50;
            logMessage(3, s, 0);
            goto LABEL_11;
          }
          if ( (unsigned int)globalLogLevel > 4 )
          {
            v213 = get_hardware_status((int)v211);
            snprintf(s, 2048u, "index: %d\n", v213);
            logMessage(4, s, 0);
          }
          v214 = dword_58DFF4;
          v215 = v214 + 12 * get_hardware_status(v212);
          v216 = (_DWORD *)initiate_task_if_ready(v210, "type");
          if ( !v216 || *v216 != 2 )
          {
            if ( (unsigned int)globalLogLevel > 3 )
            {
              snprintf(s, 2048u, "get array %d type failed\n", k);
              goto LABEL_386;
            }
            goto LABEL_10;
          }
          if ( (unsigned int)globalLogLevel > 4 )
          {
            v217 = (const char *)get_second_element_if_ready(v216);
            snprintf(s, 2048u, "type: %s\n", v217);
            logMessage(4, s, 0);
          }
          v218 = (_DWORD *)initiate_task_if_ready(v210, "bind_asic");
          v219 = (int)v218;
          if ( !v218 || *v218 != 3 )
          {
            if ( (unsigned int)globalLogLevel > 3 )
            {
              snprintf(s, 2048u, "get array %d bind_asic failed\n", k);
              goto LABEL_386;
            }
            goto LABEL_10;
          }
          if ( (unsigned int)globalLogLevel > 4 )
          {
            v220 = get_hardware_status((int)v218);
            snprintf(s, 2048u, "bind_asic: %d\n", v220);
            logMessage(4, s, 0);
          }
          *(_DWORD *)(v215 + 4) = get_hardware_status(v219);
        }
        formata = (char *)initiate_task_if_ready(v254, "domain");
        if ( !formata || *(_DWORD *)formata != 1 )
        {
          if ( (unsigned int)globalLogLevel <= 3 )
            goto LABEL_10;
          strcpy(s, "get domain failed\n");
          logMessage(3, s, 0);
          goto LABEL_397;
        }
        if ( (unsigned int)globalLogLevel > 4 )
        {
          strcpy(s, "domain:\n");
          logMessage(4, s, 0);
        }
        v222 = 0;
        v255 = v1;
LABEL_404:
        if ( v222 < (unsigned int)get_associated_pointer_or_null(formata) )
        {
          v223 = get_task_by_index(formata, v222);
          v224 = v223;
          if ( !v223 || *v223 )
          {
            v1 = v255;
            if ( (unsigned int)globalLogLevel <= 3 )
              goto LABEL_10;
            snprintf(s, 2048u, "get array %d failed\n", v222);
          }
          else
          {
            v225 = (_DWORD *)initiate_task_if_ready(v223, "index");
            if ( v225 && *v225 == 3 )
            {
              if ( (unsigned int)globalLogLevel > 4 )
              {
                v226 = get_hardware_status((int)v225);
                snprintf(s, 2048u, "index: %d\n", v226);
                logMessage(4, s, 0);
              }
              v227 = (_DWORD *)initiate_task_if_ready(v224, "asic");
              v228 = v227;
              if ( v227 && *v227 == 1 )
              {
                if ( (unsigned int)globalLogLevel > 4 )
                {
                  strcpy(s, "asic:\n");
                  logMessage(4, s, 0);
                }
                for ( m = 0; ; ++m )
                {
                  if ( m >= (unsigned int)get_associated_pointer_or_null(v228) )
                  {
                    ++v222;
                    goto LABEL_404;
                  }
                  v233 = get_task_by_index(v228, m);
                  v234 = v233;
                  if ( !v233 || *v233 )
                  {
                    v1 = v255;
                    if ( (unsigned int)globalLogLevel > 3 )
                    {
                      snprintf(s, 2048u, "get array %d failed\n", m);
                      goto LABEL_448;
                    }
                    goto LABEL_10;
                  }
                  v235 = (_DWORD *)initiate_task_if_ready(v233, "index");
                  v236 = (int)v235;
                  if ( !v235 || *v235 != 3 )
                  {
                    v1 = v255;
                    if ( (unsigned int)globalLogLevel > 3 )
                    {
                      snprintf(s, 2048u, "get array %d index failed\n", m);
                      goto LABEL_448;
                    }
                    goto LABEL_10;
                  }
                  if ( (unsigned int)globalLogLevel > 4 )
                  {
                    v237 = get_hardware_status((int)v235);
                    snprintf(s, 2048u, "index: %d\n", v237);
                    logMessage(4, s, 0);
                  }
                  v238 = get_hardware_status(v236);
                  v239 = v234;
                  v240 = *(_DWORD *)(dword_58DFF0 + 8);
                  *(_DWORD *)(v240 + 28 * v238) = v238;
                  v241 = v240 + 28 * v238;
                  v242 = (_DWORD *)initiate_task_if_ready(v239, "coordinate");
                  v243 = v242;
                  if ( !v242 || *v242 != 1 )
                    break;
                  v244 = get_task_by_index(v242, 0);
                  v245 = (int)v244;
                  if ( !v244 || *v244 != 3 )
                  {
                    v1 = v255;
                    if ( (unsigned int)globalLogLevel > 3 )
                    {
                      snprintf(s, 2048u, "get array %d coordinate x failed\n", m);
LABEL_448:
                      logMessage(3, s, 0);
                      goto LABEL_415;
                    }
                    goto LABEL_10;
                  }
                  if ( (unsigned int)globalLogLevel > 4 )
                  {
                    v246 = get_hardware_status((int)v244);
                    snprintf(s, 2048u, "x: %d\n", v246);
                    logMessage(4, s, 0);
                  }
                  *(_DWORD *)(v241 + 4) = get_hardware_status(v245);
                  v247 = get_task_by_index(v243, 1u);
                  v248 = (int)v247;
                  if ( !v247 || *v247 != 3 )
                  {
                    v1 = v255;
                    if ( (unsigned int)globalLogLevel <= 3 )
                      goto LABEL_10;
                    snprintf(s, 2048u, "get array %d coordinate y failed\n", m);
                    goto LABEL_448;
                  }
                  if ( (unsigned int)globalLogLevel > 4 )
                  {
                    v249 = get_hardware_status((int)v247);
                    snprintf(s, 2048u, "y: %d\n", v249);
                    logMessage(4, s, 0);
                  }
                  *(_DWORD *)(v241 + 8) = get_hardware_status(v248);
                }
                v1 = v255;
                if ( (unsigned int)globalLogLevel > 3 )
                {
                  snprintf(s, 2048u, "get array %d coordinate failed\n", m);
                  goto LABEL_448;
                }
                goto LABEL_10;
              }
              v1 = v255;
              if ( (unsigned int)globalLogLevel <= 3 )
                goto LABEL_10;
              strcpy(s, "get asic failed\n");
              logMessage(3, s, 0);
LABEL_415:
              if ( (unsigned int)globalLogLevel <= 3 )
              {
LABEL_10:
                v2 = -1;
                goto LABEL_11;
              }
              snprintf(s, 2048u, "parse arrry %d asic failed\n", v222);
              logMessage(3, s, 0);
              goto LABEL_397;
            }
            v1 = v255;
            if ( (unsigned int)globalLogLevel <= 3 )
              goto LABEL_10;
            snprintf(s, 2048u, "get array %d index failed\n", v222);
          }
          logMessage(3, s, 0);
LABEL_397:
          if ( (unsigned int)globalLogLevel <= 3 )
            goto LABEL_10;
          v142 = "parse chain domain failed\n";
          goto LABEL_241;
        }
        v229 = 1;
        v1 = v255;
        v230 = *(const void **)(dword_58DFF0 + 8);
        while ( v229 < globalChainCount )
        {
          v231 = dword_58DFF0 + 20 * v229++;
          memcpy(*(void **)(v231 + 8), v230, 28 * dword_58DFCC);
        }
        for ( n = 0; ; ++n )
        {
          if ( n >= dword_58DFD4 )
          {
            v2 = initializeGlobalBuffers();
            if ( v2 && (unsigned int)globalLogLevel > 3 )
            {
              strcpy(s, "init topol runtime failed\n");
              logMessage(3, s, 0);
            }
LABEL_11:
            if ( *((_DWORD *)v1 + 1) != -1 )
            {
              v6 = (unsigned int *)(v1 + 4);
              __dmb(11u);
              do
              {
                v7 = __ldrex(v6);
                v8 = v7 - 1;
              }
              while ( __strex(v8, v6) );
              if ( !v8 )
                handle_task(v1);
            }
            return v2;
          }
          v251 = dword_58DFF4 + 12 * n;
          v252 = *(_DWORD *)(dword_58DFF0 + 8) + 28 * *(_DWORD *)(v251 + 4);
          if ( (unsigned int)globalLogLevel > 3 )
          {
            snprintf(s, 2048u, "asic %d, wind %d, y %d\n");
            logMessage(3, s, 0);
          }
          v253 = dword_58E000;
          if ( dword_58E000 != 1 )
            break;
          if ( *(_DWORD *)(v252 + 8) > dword_58DFC4 / 3 )
            goto LABEL_472;
          if ( (unsigned int)globalLogLevel > 3 )
          {
            formatb = dword_58E000;
            strcpy(s, "air in\n");
            logMessage(3, s, 0);
            v253 = formatb;
          }
LABEL_468:
          *(_BYTE *)(v251 + 8) = v253;
        }
        if ( !dword_58E000 && *(_DWORD *)(v252 + 8) >= 2 * dword_58DFC4 / 3 )
        {
          if ( (unsigned int)globalLogLevel > 3 )
          {
            strcpy(s, "air in\n");
            logMessage(3, s, dword_58E000);
          }
          v253 = 1;
          goto LABEL_468;
        }
LABEL_472:
        if ( (unsigned int)globalLogLevel > 3 )
        {
          strcpy(s, "air out\n");
          logMessage(3, s, 0);
        }
        v253 = 0;
        goto LABEL_468;
      }
    }
    dword_58E000 = 0;
    goto LABEL_144;
  }
  if ( (unsigned int)globalLogLevel <= 3 )
    return -1;
  snprintf(s, 2048u, "load topol config file %s failed\n", "/etc/topol.conf");
  logMessage(3, s, 0);
  return -1;
}
// 1D310: variable 'v197' is possibly undefined
// 7EB9C: using guessed type int globalLogLevel;
// 58DFB8: using guessed type int dword_58DFB8;
// 58DFBC: using guessed type int globalChainCount;
// 58DFC0: using guessed type int dword_58DFC0;
// 58DFC4: using guessed type int dword_58DFC4;
// 58DFC8: using guessed type int dword_58DFC8;
// 58DFCC: using guessed type int dword_58DFCC;
// 58DFD0: using guessed type int dword_58DFD0;
// 58DFD4: using guessed type int dword_58DFD4;
// 58DFD8: using guessed type int dword_58DFD8;
// 58DFDC: using guessed type int dword_58DFDC;
// 58DFE0: using guessed type int dword_58DFE0;
// 58DFE4: using guessed type int dword_58DFE4;
// 58DFE8: using guessed type int dword_58DFE8;
// 58DFEC: using guessed type int dword_58DFEC;
// 58DFF0: using guessed type int dword_58DFF0;
// 58DFF4: using guessed type int dword_58DFF4;
// 58DFF8: using guessed type int dword_58DFF8;
// 58DFFC: using guessed type int dword_58DFFC;
// 58E000: using guessed type int dword_58E000;
// 58E004: using guessed type int globalFanCount;
// 58E038: using guessed type int dword_58E038;
// 58E03C: using guessed type int dword_58E03C;
// 1B4AC: using guessed type char var_924[252];

//----- (0001E0C0) --------------------------------------------------------
int get_shared_variable()
{
  return dword_58DFB8;
}
// 58DFB8: using guessed type int dword_58DFB8;

//----- (0001E0D0) --------------------------------------------------------
int get_global_chain_count()
{
  return globalChainCount;
}
// 58DFBC: using guessed type int globalChainCount;

//----- (0001E0E0) --------------------------------------------------------
int get_global_state_value()
{
  return dword_58DFC8;
}
// 58DFC8: using guessed type int dword_58DFC8;

//----- (0001E0F0) --------------------------------------------------------
int get_global_variable_value()
{
  return dword_58DFCC;
}
// 58DFCC: using guessed type int dword_58DFCC;

//----- (0001E100) --------------------------------------------------------
int get_global_value()
{
  return dword_58DFD0;
}
// 58DFD0: using guessed type int dword_58DFD0;

//----- (0001E110) --------------------------------------------------------
int get_global_flag_value()
{
  return dword_58DFD8;
}
// 58DFD8: using guessed type int dword_58DFD8;

//----- (0001E120) --------------------------------------------------------
int get_miner_status_flag()
{
  return dword_58DFDC;
}
// 58DFDC: using guessed type int dword_58DFDC;

//----- (0001E130) --------------------------------------------------------
int get_shared_value()
{
  return dword_58DFE0;
}
// 58DFE0: using guessed type int dword_58DFE0;

//----- (0001E140) --------------------------------------------------------
int sub_1E140()
{
  return dword_58DFE4;
}
// 58DFE4: using guessed type int dword_58DFE4;

//----- (0001E150) --------------------------------------------------------
int get_embedded_system_status()
{
  return dword_58DFE8;
}
// 58DFE8: using guessed type int dword_58DFE8;

//----- (0001E160) --------------------------------------------------------
int sub_1E160()
{
  return dword_58DFEC;
}
// 58DFEC: using guessed type int dword_58DFEC;

//----- (0001E170) --------------------------------------------------------
int get_global_status()
{
  return dword_58DFD4;
}
// 58DFD4: using guessed type int dword_58DFD4;

//----- (0001E180) --------------------------------------------------------
int __fastcall get_control_status(int control_index)
{
  return *(_DWORD *)(dword_58DFF4 + 12 * control_index + 4);
}
// 58DFF4: using guessed type int dword_58DFF4;

//----- (0001E19C) --------------------------------------------------------
int sub_1E19C()
{
  return dword_58DFF8;
}
// 58DFF8: using guessed type int dword_58DFF8;

//----- (0001E1AC) --------------------------------------------------------
int __fastcall get_miner_temperature(int miner_index)
{
  return *(_DWORD *)(dword_58DFFC + 12 * miner_index + 4);
}
// 58DFFC: using guessed type int dword_58DFFC;

//----- (0001E1C8) --------------------------------------------------------
int __fastcall get_asic_miner_temperature(int asic_index)
{
  return *(unsigned __int8 *)(dword_58DFFC + 12 * asic_index + 8);
}
// 58DFFC: using guessed type int dword_58DFFC;

//----- (0001E1E4) --------------------------------------------------------
int __fastcall get_miner_status(int miner_index)
{
  return *(unsigned __int8 *)(dword_58DFF4 + 12 * miner_index + 8);
}
// 58DFF4: using guessed type int dword_58DFF4;

//----- (0001E200) --------------------------------------------------------
int __fastcall set_chain_status(unsigned int chain_index, int status)
{
  unsigned int is_index_out_of_range; // r3
  int set_status_result; // r0
  unsigned int chain_offset; // r4
  char adjusted_global_chain_active_count; // r3

  is_index_out_of_range = chain_index >> 31;
  if ( globalChainCount <= (int)chain_index )
    is_index_out_of_range = 1;
  if ( is_index_out_of_range )
    return -2147482623;
  if ( globalInitializationFlag )
  {
    set_status_result = 0;
  }
  else
  {
    set_status_result = initializeGlobalBuffers();
    if ( set_status_result < 0 )
      return set_status_result;
  }
  chain_offset = 528 * chain_index;
  if ( *(unsigned __int8 *)(globalChainBufferPtr + chain_offset) != status )
  {
    *(_BYTE *)(globalChainBufferPtr + chain_offset) = status;
    if ( status )
      adjusted_global_chain_active_count = byte_58E014 + 1;
    else
      adjusted_global_chain_active_count = byte_58E014 - 1;
    byte_58E014 = adjusted_global_chain_active_count;
  }
  return set_status_result;
}
// 58DFBC: using guessed type int globalChainCount;
// 58E010: using guessed type int globalInitializationFlag;
// 58E014: using guessed type char byte_58E014;
// 58E018: using guessed type int globalChainBufferPtr;

//----- (0001E28C) --------------------------------------------------------
int get_status_flag()
{
  return (unsigned __int8)byte_58E014;
}
// 58E014: using guessed type char byte_58E014;

//----- (0001E29C) --------------------------------------------------------
int __fastcall get_global_buffer_value(int buffer_index)
{
  return *(unsigned __int8 *)(globalChainBufferPtr + 528 * buffer_index);
}
// 58E018: using guessed type int globalChainBufferPtr;

//----- (0001E2B4) --------------------------------------------------------
int initialize_global_variable()
{
  __int64 initial_value; // d0
  int status; // r0

  status = 0;
  unk_58E028 = initial_value;
  return status;
}
// 1E2C0: variable 'initial_value' is possibly undefined

//----- (0001E2C8) --------------------------------------------------------
void sub_1E2C8()
{
  ;
}

//----- (0001E2D8) --------------------------------------------------------
int perform_hardware_reset()
{
  __int64 reset_value; // d0
  int reset_status; // r0

  reset_status = 0;
  unk_58E030 = reset_value;
  return reset_status;
}
// 1E2E4: variable 'reset_value' is possibly undefined

//----- (0001E2EC) --------------------------------------------------------
void sub_1E2EC()
{
  ;
}

//----- (0001E2FC) --------------------------------------------------------
int get_global_fan_count()
{
  return globalFanCount;
}
// 58E004: using guessed type int globalFanCount;

//----- (0001E30C) --------------------------------------------------------
int get_active_fan_count()
{
  int active_fan_count; // r0
  int fan_index; // r3

  if ( globalFanCount <= 0 )
    return 0;
  active_fan_count = 0;
  fan_index = 0;
  do
  {
    if ( *(unsigned __int8 *)(dword_58E020 + 8 * fan_index++) )
      ++active_fan_count;
  }
  while ( fan_index != globalFanCount );
  return active_fan_count;
}
// 58E004: using guessed type int globalFanCount;
// 58E020: using guessed type int dword_58E020;

//----- (0001E350) --------------------------------------------------------
int __fastcall sub_1E350(unsigned int a1, int a2)
{
  unsigned int v2; // r3
  int result; // r0
  char v6; // r3

  v2 = a1 >> 31;
  if ( globalFanCount <= (int)a1 )
    v2 = 1;
  if ( v2 )
    return -2147482623;
  if ( globalInitializationFlag )
  {
    result = 0;
  }
  else
  {
    result = initializeGlobalBuffers();
    if ( result < 0 )
      return result;
  }
  if ( *(unsigned __int8 *)(dword_58E020 + 8 * a1) != a2 )
  {
    *(_BYTE *)(dword_58E020 + 8 * a1) = a2;
    if ( a2 )
      v6 = byte_58E01C + 1;
    else
      v6 = byte_58E01C - 1;
    byte_58E01C = v6;
  }
  return result;
}
// 58E004: using guessed type int globalFanCount;
// 58E010: using guessed type int globalInitializationFlag;
// 58E01C: using guessed type char byte_58E01C;
// 58E020: using guessed type int dword_58E020;

//----- (0001E3D4) --------------------------------------------------------
int __fastcall sub_1E3D4(unsigned int fan_index, int speed_value)
{
  unsigned int is_invalid_fan_index; // r3
  int status; // r0

  is_invalid_fan_index = fan_index >> 31;
  if ( globalFanCount <= (int)fan_index )
    is_invalid_fan_index = 1;
  if ( is_invalid_fan_index )
    return -2147482623;
  if ( globalInitializationFlag )
  {
    status = 0;
LABEL_7:
    *(_DWORD *)(dword_58E020 + 8 * fan_index + 4) = speed_value;
    return status;
  }
  status = initializeGlobalBuffers();
  if ( status >= 0 )
    goto LABEL_7;
  return status;
}
// 58E004: using guessed type int globalFanCount;
// 58E010: using guessed type int globalInitializationFlag;
// 58E020: using guessed type int dword_58E020;

//----- (0001E43C) --------------------------------------------------------
int __fastcall get_fan_speed(unsigned int fan_index)
{
  int fan_speed_or_error; // r0

  if ( (globalFanCount <= (int)fan_index) | (fan_index >> 31) )
    return -2147482623;
  if ( globalInitializationFlag )
    return *(_DWORD *)(dword_58E020 + 8 * fan_index + 4);
  fan_speed_or_error = initializeGlobalBuffers();
  if ( fan_speed_or_error >= 0 )
    return *(_DWORD *)(dword_58E020 + 8 * fan_index + 4);
  return fan_speed_or_error;
}
// 58E004: using guessed type int globalFanCount;
// 58E010: using guessed type int globalInitializationFlag;
// 58E020: using guessed type int dword_58E020;

//----- (0001E49C) --------------------------------------------------------
int __fastcall set_status_led_state(char new_state)
{
  byte_58E01D = new_state;
  return 0;
}
// 58E01D: using guessed type char byte_58E01D;

//----- (0001E4B0) --------------------------------------------------------
int sub_1E4B0()
{
  return (unsigned __int8)byte_58E01D;
}
// 58E01D: using guessed type char byte_58E01D;

//----- (0001E4C0) --------------------------------------------------------
int __fastcall set_chain_buffer_timestamp(unsigned int chain_index)
{
  __int64 timestamp; // d0
  unsigned int invalid_chain_flag; // r3
  int status; // r0

  invalid_chain_flag = chain_index >> 31;
  if ( globalChainCount <= (int)chain_index )
    invalid_chain_flag = 1;
  if ( invalid_chain_flag )
    return -2147482623;
  if ( globalInitializationFlag )
  {
    status = 0;
LABEL_7:
    *(_QWORD *)(globalChainBufferPtr + 528 * chain_index + 8) = timestamp;
    return status;
  }
  status = initializeGlobalBuffers();
  if ( status >= 0 )
    goto LABEL_7;
  return status;
}
// 1E508: variable 'timestamp' is possibly undefined
// 58DFBC: using guessed type int globalChainCount;
// 58E010: using guessed type int globalInitializationFlag;
// 58E018: using guessed type int globalChainBufferPtr;

//----- (0001E52C) --------------------------------------------------------
int __fastcall get_chain_buffer_ptr(int chain_index)
{
  int verified_chain_index; // r4

  if ( !((globalChainCount <= chain_index) | ((unsigned int)chain_index >> 31)) )
  {
    verified_chain_index = chain_index;
    if ( globalInitializationFlag )
      return globalChainBufferPtr + 528 * verified_chain_index;
    chain_index = initializeGlobalBuffers();
    if ( chain_index >= 0 )
      return globalChainBufferPtr + 528 * verified_chain_index;
  }
  return chain_index;
}
// 58DFBC: using guessed type int globalChainCount;
// 58E010: using guessed type int globalInitializationFlag;
// 58E018: using guessed type int globalChainBufferPtr;

//----- (0001E5A0) --------------------------------------------------------
int __fastcall process_chain_index(unsigned int chain_index)
{
  unsigned int index_valid; // r3
  int status_code; // r0

  index_valid = chain_index >> 31;
  if ( globalChainCount <= (int)chain_index )
    index_valid = 1;
  if ( index_valid )
    return -2147482623;
  if ( globalInitializationFlag )
  {
    status_code = 0;
LABEL_7:
    ++*(_BYTE *)(globalChainBufferPtr + 528 * chain_index + 1);
    return status_code;
  }
  status_code = initializeGlobalBuffers();
  if ( status_code >= 0 )
    goto LABEL_7;
  return status_code;
}
// 58DFBC: using guessed type int globalChainCount;
// 58E010: using guessed type int globalInitializationFlag;
// 58E018: using guessed type int globalChainBufferPtr;

//----- (0001E610) --------------------------------------------------------
int __fastcall write_to_chain_buffer(unsigned int chain_index, char data)
{
  unsigned int is_invalid_index; // r3
  int status; // r0

  is_invalid_index = chain_index >> 31;
  if ( globalChainCount <= (int)chain_index )
    is_invalid_index = 1;
  if ( is_invalid_index )
    return -2147482623;
  if ( globalInitializationFlag )
  {
    status = 0;
LABEL_7:
    *(_BYTE *)(globalChainBufferPtr + 528 * chain_index + 1) = data;
    return status;
  }
  status = initializeGlobalBuffers();
  if ( status >= 0 )
    goto LABEL_7;
  return status;
}
// 58DFBC: using guessed type int globalChainCount;
// 58E010: using guessed type int globalInitializationFlag;
// 58E018: using guessed type int globalChainBufferPtr;

//----- (0001E67C) --------------------------------------------------------
int __fastcall get_chain_data_status(unsigned int chain_index)
{
  int status; // r0

  if ( (globalChainCount <= (int)chain_index) | (chain_index >> 31) )
    return -2147482623;
  if ( globalInitializationFlag )
    return *(unsigned __int8 *)(globalChainBufferPtr + 528 * chain_index + 1);
  status = initializeGlobalBuffers();
  if ( status >= 0 )
    return *(unsigned __int8 *)(globalChainBufferPtr + 528 * chain_index + 1);
  return status;
}
// 58DFBC: using guessed type int globalChainCount;
// 58E010: using guessed type int globalInitializationFlag;
// 58E018: using guessed type int globalChainBufferPtr;

//----- (0001E6E0) --------------------------------------------------------
int __fastcall process_chain_request(unsigned int chain_index)
{
  unsigned int invalid_chain_flag; // r3
  int status; // r0

  invalid_chain_flag = chain_index >> 31;
  if ( globalChainCount <= (int)chain_index )
    invalid_chain_flag = 1;
  if ( invalid_chain_flag )
    return -2147482623;
  if ( globalInitializationFlag )
  {
    status = 0;
LABEL_7:
    ++*(_DWORD *)(globalChainBufferPtr + 528 * chain_index + 4);
    return status;
  }
  status = initializeGlobalBuffers();
  if ( status >= 0 )
    goto LABEL_7;
  return status;
}
// 58DFBC: using guessed type int globalChainCount;
// 58E010: using guessed type int globalInitializationFlag;
// 58E018: using guessed type int globalChainBufferPtr;

//----- (0001E750) --------------------------------------------------------
int __fastcall set_chain_config(unsigned int chain_index, int config_value)
{
  unsigned int is_chain_out_of_range; // r3
  int status; // r0

  is_chain_out_of_range = chain_index >> 31;
  if ( globalChainCount <= (int)chain_index )
    is_chain_out_of_range = 1;
  if ( is_chain_out_of_range )
    return -2147482623;
  if ( globalInitializationFlag )
  {
    status = 0;
LABEL_7:
    *(_DWORD *)(globalChainBufferPtr + 528 * chain_index + 4) = config_value;
    return status;
  }
  status = initializeGlobalBuffers();
  if ( status >= 0 )
    goto LABEL_7;
  return status;
}
// 58DFBC: using guessed type int globalChainCount;
// 58E010: using guessed type int globalInitializationFlag;
// 58E018: using guessed type int globalChainBufferPtr;

//----- (0001E7BC) --------------------------------------------------------
int __fastcall get_chain_buffer_status(unsigned int chain_index)
{
  int status_code; // r0

  if ( (globalChainCount <= (int)chain_index) | (chain_index >> 31) )
    return -2147482623;
  if ( globalInitializationFlag )
    return *(_DWORD *)(globalChainBufferPtr + 528 * chain_index + 4);
  status_code = initializeGlobalBuffers();
  if ( status_code >= 0 )
    return *(_DWORD *)(globalChainBufferPtr + 528 * chain_index + 4);
  return status_code;
}
// 58DFBC: using guessed type int globalChainCount;
// 58E010: using guessed type int globalInitializationFlag;
// 58E018: using guessed type int globalChainBufferPtr;

//----- (0001E820) --------------------------------------------------------
int __fastcall set_chain_config_byte(unsigned int chain_index, int config_offset, char config_value)
{
  unsigned int is_chain_index_invalid; // r3
  int operation_status; // r0

  is_chain_index_invalid = chain_index >> 31;
  if ( globalChainCount <= (int)chain_index )
    is_chain_index_invalid = 1;
  if ( is_chain_index_invalid )
    return -2147482623;
  if ( globalInitializationFlag )
  {
    operation_status = 0;
LABEL_7:
    *(_BYTE *)(globalChainBufferPtr + 528 * chain_index + config_offset + 16) = config_value;
    return operation_status;
  }
  operation_status = initializeGlobalBuffers();
  if ( operation_status >= 0 )
    goto LABEL_7;
  return operation_status;
}
// 58DFBC: using guessed type int globalChainCount;
// 58E010: using guessed type int globalInitializationFlag;
// 58E018: using guessed type int globalChainBufferPtr;

//----- (0001E894) --------------------------------------------------------
int __fastcall get_miner_chain_status_info(unsigned int chain_index, char *status_buffer)
{
  unsigned int error_or_success; // r5
  int init_result; // r0

  if ( globalChainCount <= (int)chain_index )
    return -2147482623;
  error_or_success = (status_buffer == 0) | (chain_index >> 31);
  if ( error_or_success )
    return -2147482623;
  if ( globalInitializationFlag
    || (init_result = initializeGlobalBuffers(), error_or_success = init_result, init_result >= 0) )
  {
    snprintf(status_buffer, 512u, "%s", (const char *)(globalChainBufferPtr + 528 * chain_index + 16));
    return error_or_success;
  }
  return init_result;
}
// 58DFBC: using guessed type int globalChainCount;
// 58E010: using guessed type int globalInitializationFlag;
// 58E018: using guessed type int globalChainBufferPtr;

//----- (0001E91C) --------------------------------------------------------
int __fastcall is_id_in_list(int search_id)
{
  unsigned __int16 *current_id_ptr; // r3
  int current_id; // t1

  if ( dword_58E038 <= 0 )
    return 0;
  if ( *(unsigned __int16 *)dword_58E03C != search_id )
  {
    for ( current_id_ptr = (unsigned __int16 *)(dword_58E03C + 2);
          current_id_ptr != (unsigned __int16 *)(dword_58E03C + 2 * dword_58E038);
          ++current_id_ptr )
    {
      current_id = *current_id_ptr;
      if ( current_id == search_id )
        return 1;
    }
    return 0;
  }
  return 1;
}
// 58E038: using guessed type int dword_58E038;
// 58E03C: using guessed type int dword_58E03C;

//----- (0001E970) --------------------------------------------------------
int check_global_buffer_and_reset()
{
  int buffer_index; // r4
  int operation_result; // r0

  buffer_index = 0;
  operation_result = get_global_buffer_value(0);
  if ( operation_result )
    goto LABEL_4;
  while ( ++buffer_index != 4 )
  {
    operation_result = get_global_buffer_value(buffer_index);
    if ( operation_result )
LABEL_4:
      operation_result = set_asic_mining_mode((unsigned __int8)buffer_index, 0);
  }
  return operation_result;
}

//----- (0001E9B4) --------------------------------------------------------
int __fastcall forward_to_specific_func(unsigned int arg_one, unsigned int arg_two)
{
  return configure_asic_regulator(arg_one, arg_two, 1);
}

//----- (0001E9BC) --------------------------------------------------------
int __fastcall calculate_hashrate(unsigned int hash_count, unsigned int elapsed_time)
{
  return configure_asic_regulator(hash_count, elapsed_time, 0);
}

//----- (0001E9C4) --------------------------------------------------------
int __fastcall set_antminer_frequency(unsigned int frequency)
{
  return set_mining_mode(frequency, 1);
}

//----- (0001E9CC) --------------------------------------------------------
int __fastcall scan_chip_versions(unsigned int version_info)
{
  int chip_index; // r4
  int is_version_found; // r0

  chip_index = 0;
  is_version_found = get_global_buffer_value(0);
  if ( is_version_found )
    goto LABEL_4;
  while ( ++chip_index != 4 )
  {
    is_version_found = get_global_buffer_value(chip_index);
    if ( is_version_found )
LABEL_4:
      is_version_found = configure_voltage_and_timing((unsigned __int8)chip_index, version_info);
  }
  return is_version_found;
}

//----- (0001EA18) --------------------------------------------------------
int __fastcall update_miner_config(int miner_id, unsigned int config_value, int flag, char restart_flag)
{
  int current_index; // r4
  int operation_result; // r0
  bool is_target_miner; // zf

  for ( current_index = 0; current_index != 4; ++current_index )
  {
    operation_result = get_global_buffer_value(current_index);
    if ( operation_result )
    {
      is_target_miner = miner_id == 255;
      if ( miner_id != 255 )
        is_target_miner = miner_id == (unsigned __int8)current_index;
      if ( is_target_miner )
      {
        if ( flag )
          operation_result = initialize_asic_for_mining((unsigned __int8)current_index, restart_flag);
        else
          operation_result = initialize_mining_with_config((unsigned __int8)current_index, config_value, restart_flag);
      }
    }
  }
  return operation_result;
}

//----- (0001EA84) --------------------------------------------------------
int __fastcall process_miner_status(int target_status_code)
{
  int status_index; // r4
  int current_status_index; // r0
  unsigned int status_code; // r5
  int operation_result; // r0
  bool is_target_status; // zf

  status_index = 0;
  do
  {
    while ( 1 )
    {
      current_status_index = status_index;
      status_code = (unsigned __int8)status_index++;
      operation_result = get_global_buffer_value(current_status_index);
      if ( operation_result )
      {
        is_target_status = target_status_code == 255;
        if ( target_status_code != 255 )
          is_target_status = target_status_code == status_code;
        if ( is_target_status )
          break;
      }
      if ( status_index == 4 )
        return operation_result;
    }
    operation_result = disable_asic_heartbeat_and_start_mining(status_code);
  }
  while ( status_index != 4 );
  return operation_result;
}

//----- (0001EAD4) --------------------------------------------------------
int __fastcall check_global_buffer_and_process(unsigned int input_value)
{
  int buffer_index; // r4
  int current_index; // r0
  unsigned int global_buffer_index; // r5
  int process_result; // r0

  buffer_index = 0;
  do
  {
    while ( 1 )
    {
      current_index = buffer_index;
      global_buffer_index = (unsigned __int8)buffer_index++;
      process_result = get_global_buffer_value(current_index);
      if ( process_result )
        break;
      if ( buffer_index == 4 )
        return process_result;
    }
    process_result = configure_asic_for_mining(global_buffer_index, input_value);
  }
  while ( buffer_index != 4 );
  return process_result;
}

//----- (0001EB1C) --------------------------------------------------------
int __fastcall reset_buffers_if_needed(__int16 buffer_version)
{
  int buffer_index; // r4
  int buffer_value; // r0
  unsigned int buffer_seq_num; // r5
  int operation_result; // r0

  buffer_index = 0;
  do
  {
    while ( 1 )
    {
      buffer_value = buffer_index;
      buffer_seq_num = (unsigned __int8)buffer_index++;
      operation_result = get_global_buffer_value(buffer_value);
      if ( operation_result )
        break;
      if ( buffer_index == 4 )
        return operation_result;
    }
    operation_result = configure_asic_frequency(buffer_seq_num, 1, (unsigned __int8)optMultiVersion, buffer_version);
  }
  while ( buffer_index != 4 );
  return operation_result;
}
// 7EB58: using guessed type int optMultiVersion;

//----- (0001EB74) --------------------------------------------------------
int set_uart_relay_based_on_state()
{
  int relay_set_result; // r0
  int state_index; // r6
  int multiplier_base; // r0
  int buffer_index; // r4
  unsigned int calculated_value; // r5
  unsigned int unsigned_buffer_index; // r7
  __int16 state_offset; // r9
  __int16 multiplier_adjustment; // r0
  char log_message[2080]; // [sp+8h] [bp-820h] BYREF

  relay_set_result = get_global_state_value();
  if ( relay_set_result > 9 )
  {
    relay_set_result = get_global_state_value();
    for ( state_index = relay_set_result - 3; state_index >= 0; state_index -= 3 )
    {
      multiplier_base = get_global_value();
      buffer_index = 0;
      calculated_value = sub_1E160() * (multiplier_base + state_index * multiplier_base - 1);
      do
      {
        unsigned_buffer_index = (unsigned __int8)buffer_index;
        relay_set_result = get_global_buffer_value(buffer_index++);
        if ( relay_set_result )
        {
          state_offset = get_global_state_value() - state_index;
          multiplier_adjustment = get_global_value();
          relay_set_result = initialize_chip(
                               unsigned_buffer_index,
                               calculated_value,
                               multiplier_adjustment * state_offset + 14,
                               1,
                               1);
        }
      }
      while ( buffer_index != 4 );
    }
  }
  else if ( (unsigned int)globalLogLevel > 4 )
  {
    strcpy(log_message, "no need to set uart relay\n");
    return logMessage(4, log_message, 0);
  }
  return relay_set_result;
}
// 7EB9C: using guessed type int globalLogLevel;

//----- (0001EC84) --------------------------------------------------------
int __fastcall set_config_for_miner(
        int target_miner_id,
        int config_parameter,
        char config_value_byte1,
        char config_value_byte2)
{
  int current_miner_id; // r4
  int last_operation_result; // r0
  bool is_current_target_miner; // zf

  for ( current_miner_id = 0; current_miner_id != 4; ++current_miner_id )
  {
    last_operation_result = get_global_buffer_value(current_miner_id);
    if ( last_operation_result )
    {
      is_current_target_miner = target_miner_id == current_miner_id;
      if ( target_miner_id != current_miner_id )
        is_current_target_miner = target_miner_id == 255;
      last_operation_result = (unsigned __int8)current_miner_id;
      if ( is_current_target_miner )
        last_operation_result = hash_board_command_send(
                                  (unsigned __int8)current_miner_id,
                                  config_parameter,
                                  config_value_byte1,
                                  config_value_byte2);
    }
  }
  return last_operation_result;
}

//----- (0001ECDC) --------------------------------------------------------
int __fastcall select_function(
        unsigned __int8 param1,
        unsigned __int8 param2,
        unsigned __int8 param3,
        int conditional_flag,
        unsigned __int8 param4,
        unsigned __int8 param5)
{
  if ( conditional_flag )
    return configure_asic_miner(param5, param4, param1, param2, param3);
  else
    return initialize_mining_config(param5, param4, param1, param2);
}

//----- (0001ED08) --------------------------------------------------------
int log_and_process_commands()
{
  int chip_index; // r4
  unsigned __int8 command_interval; // r0
  char log_buffer[2064]; // [sp+0h] [bp-810h] BYREF

  if ( logEnabled && (loggingDebug || loggingVerbose || loggingThreshold > 6) )
  {
    snprintf(log_buffer, 2048u, "--- %s\n", "dhash_chip_set_addr_all");
    logMessage(7, log_buffer, 0);
  }
  for ( chip_index = 0; chip_index != 4; ++chip_index )
  {
    if ( get_global_buffer_value(chip_index) )
    {
      j_calculate_result((unsigned __int8)chip_index);
      get_next_sleep_interval();
      command_interval = sub_1E160();
      process_commands_in_interval((unsigned __int8)chip_index, command_interval);
    }
  }
  return get_next_sleep_interval();
}
// 7EBA0: using guessed type int loggingThreshold;
// 482A5C: using guessed type char loggingVerbose;
// 482A5D: using guessed type char logEnabled;
// 590404: using guessed type char loggingDebug;

//----- (0001EDF0) --------------------------------------------------------
int __fastcall sub_1EDF0(unsigned int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  unsigned int *v9; // r2
  unsigned __int8 *v10; // r1
  int v11; // r12
  int v12; // r3
  int *v13; // r1
  int v14; // r3
  int v16[17]; // [sp+4h] [bp-54h] BYREF
  unsigned int v17; // [sp+48h] [bp-10h] BYREF
  int v18; // [sp+4Ch] [bp-Ch]
  int v19; // [sp+50h] [bp-8h]
  int v20; // [sp+54h] [bp-4h]

  v17 = a1;
  v18 = a2;
  v19 = a3;
  v20 = a4;
  memset(&v16[2], 0, 44u);
  v9 = &v17;
  v10 = (unsigned __int8 *)&v17;
  v11 = 2;
  v16[0] = bswap32(v17);
  v16[1] = v18;
  do
  {
    v12 = v10[9];
    v10 += 4;
    v16[v11++] = (v12 << 16) | (v10[4] << 24) | v10[7] | (v10[6] << 8);
  }
  while ( v11 != 5 );
  v13 = &v16[5];
  do
  {
    v14 = *((unsigned __int8 *)v9++ + 21);
    *v13++ = (v14 << 16) | (*((unsigned __int8 *)v9 + 16) << 24) | *((unsigned __int8 *)v9 + 19) | (*((unsigned __int8 *)v9 + 18) << 8);
  }
  while ( v9 != (unsigned int *)&a9 );
  return set_registers_from_buffer(v16, 52u);
}

//----- (0001EEB8) --------------------------------------------------------
int __fastcall prepare_hash_input(
        unsigned int input1,
        int input2,
        int input3,
        int input4,
        int input5,
        int input6,
        int input7,
        int input8,
        int input9,
        int input10,
        int input11,
        int input12,
        int input13,
        int input14,
        int input15,
        int input16,
        int input17,
        int input18,
        int input19,
        int input20,
        int input21,
        int input22,
        int input23,
        int input24,
        int input25,
        int input26,
        int input27,
        int input28,
        int input29,
        int input30,
        int input31,
        int input32,
        int input33)
{
  unsigned int *current_input_word_ptr; // r2
  unsigned __int8 *current_input_byte_ptr; // r1
  int input_index; // r12
  int temp_value; // r3
  int *output_ptr; // r6
  unsigned int *next_input_chunk; // r5
  int *current_output_word_ptr; // r1
  int chunk_value; // r3
  int input_buffer[43]; // [sp+4h] [bp-BCh] BYREF
  unsigned int first_input_word; // [sp+B0h] [bp-10h] BYREF
  int second_input_word; // [sp+B4h] [bp-Ch]
  int third_input_word; // [sp+B8h] [bp-8h]
  int fourth_input_word; // [sp+BCh] [bp-4h]

  first_input_word = input1;
  second_input_word = input2;
  third_input_word = input3;
  fourth_input_word = input4;
  memset(&input_buffer[2], 0, 140u);
  current_input_word_ptr = &first_input_word;
  current_input_byte_ptr = (unsigned __int8 *)&first_input_word;
  input_index = 2;
  input_buffer[0] = bswap32(first_input_word);
  input_buffer[1] = second_input_word;
  do
  {
    temp_value = current_input_byte_ptr[9];
    current_input_byte_ptr += 4;
    input_buffer[input_index++] = (temp_value << 16) | (current_input_byte_ptr[4] << 24) | current_input_byte_ptr[7] | (current_input_byte_ptr[6] << 8);
  }
  while ( input_index != 5 );
  output_ptr = &input_buffer[5];
  do
  {
    next_input_chunk = current_input_word_ptr + 8;
    current_output_word_ptr = output_ptr;
    do
    {
      chunk_value = *((unsigned __int8 *)current_input_word_ptr++ + 21);
      *current_output_word_ptr++ = (chunk_value << 16) | (*((unsigned __int8 *)current_input_word_ptr + 16) << 24) | *((unsigned __int8 *)current_input_word_ptr + 19) | (*((unsigned __int8 *)current_input_word_ptr + 18) << 8);
    }
    while ( current_input_word_ptr != next_input_chunk );
    output_ptr += 8;
  }
  while ( current_input_word_ptr != (unsigned int *)&input33 );
  return set_registers_from_buffer(input_buffer, 148u);
}

//----- (0001EF94) --------------------------------------------------------
int __fastcall process_buffer(int param_1, char flag)
{
  int buffer_index; // r4
  int status; // r0

  buffer_index = 0;
  status = get_global_buffer_value(0);
  if ( status )
    goto LABEL_4;
  while ( ++buffer_index != 4 )
  {
    status = get_global_buffer_value(buffer_index);
    if ( status )
LABEL_4:
      status = initialize_chip_with_config((unsigned __int8)buffer_index, flag, 0);
  }
  return status;
}

//----- (0001EFE0) --------------------------------------------------------
int __fastcall process_command_for_global_buffer(
        int unused_param,
        char command_param1,
        char command_param2,
        char command_param3)
{
  int buffer_index; // r4
  int processing_result; // r0

  buffer_index = 0;
  processing_result = get_global_buffer_value(0);
  if ( processing_result )
    goto LABEL_4;
  while ( ++buffer_index != 4 )
  {
    processing_result = get_global_buffer_value(buffer_index);
    if ( processing_result )
LABEL_4:
      processing_result = initialize_specific_miner(
                            (unsigned __int8)buffer_index,
                            command_param1,
                            command_param2,
                            command_param3);
  }
  return processing_result;
}

//----- (0001F038) --------------------------------------------------------
int __fastcall reset_buffer_if_condition_met(int target_buffer)
{
  int buffer_index; // r4
  int last_reset_result; // r0
  bool should_reset; // zf

  for ( buffer_index = 0; buffer_index != 4; ++buffer_index )
  {
    last_reset_result = get_global_buffer_value(buffer_index);
    if ( last_reset_result )
    {
      should_reset = target_buffer == buffer_index;
      if ( target_buffer != buffer_index )
        should_reset = target_buffer == 255;
      last_reset_result = (unsigned __int8)buffer_index;
      if ( should_reset )
        last_reset_result = initialize_mining((unsigned __int8)buffer_index, 1);
    }
  }
  return last_reset_result;
}

//----- (0001F080) --------------------------------------------------------
int __fastcall calculate_hashrate_ratio(int miner_current_data, int miner_previous_data)
{
  return (int)(float)((float)((float)(25.0 / (float)BYTE2(miner_current_data))
                            * (float)(unsigned __int16)miner_previous_data)
                    / (float)(BYTE2(miner_previous_data)
                            * (unsigned __int8)miner_current_data
                            * BYTE1(miner_current_data)));
}

//----- (0001F0E0) --------------------------------------------------------
int __fastcall process_command(
        int command_type,
        int is_write_operation,
        unsigned int read_data,
        unsigned int write_data)
{
  int buffer_index; // r4
  int operation_result; // r0
  bool is_target_buffer; // zf

  for ( buffer_index = 0; buffer_index != 4; ++buffer_index )
  {
    operation_result = get_global_buffer_value(buffer_index);
    if ( operation_result )
    {
      is_target_buffer = command_type == 255;
      if ( command_type != 255 )
        is_target_buffer = buffer_index == command_type;
      if ( is_target_buffer )
      {
        if ( is_write_operation )
          operation_result = set_pll_frequency((unsigned __int8)buffer_index, write_data, 0);
        else
          operation_result = set_asic_mining_frequency((unsigned __int8)buffer_index, read_data, write_data, 0);
      }
    }
  }
  return operation_result;
}

//----- (0001F164) --------------------------------------------------------
int __fastcall trigger_asic_operations(
        int target_chain_id,
        int use_second_function,
        unsigned int param_for_second_function,
        unsigned int common_param_1,
        int common_param_2,
        __int16 common_param_3)
{
  int chain_index; // r4
  int operation_result; // r0
  bool use_target_chain; // zf

  for ( chain_index = 0; chain_index != 4; ++chain_index )
  {
    operation_result = get_global_buffer_value(chain_index);
    if ( operation_result )
    {
      use_target_chain = target_chain_id == 255;
      if ( target_chain_id != 255 )
        use_target_chain = chain_index == target_chain_id;
      if ( use_target_chain )
      {
        if ( use_second_function )
          operation_result = delegate_control_command(
                               (unsigned __int8)chain_index,
                               common_param_1,
                               common_param_2,
                               common_param_3);
        else
          operation_result = submit_mining_share(
                               (unsigned __int8)chain_index,
                               param_for_second_function,
                               common_param_1,
                               common_param_2,
                               common_param_3);
      }
    }
  }
  return operation_result;
}

//----- (0001F1EC) --------------------------------------------------------
int __fastcall check_global_buffers_and_process(int maybe_unused_param, int should_invoke_sub_50ED0)
{
  int buffer_index; // r4
  int buffer_value; // r0

  buffer_index = 0;
  buffer_value = get_global_buffer_value(0);
  if ( buffer_value )
    goto LABEL_4;
  while ( ++buffer_index != 4 )
  {
    buffer_value = get_global_buffer_value(buffer_index);
    if ( buffer_value )
    {
LABEL_4:
      sub_508DC();
      if ( should_invoke_sub_50ED0 )
        buffer_value = enable_mining_on_asic((unsigned __int8)buffer_index);
      else
        buffer_value = initialize_asic_chip((unsigned __int8)buffer_index);
    }
  }
  return buffer_value;
}

//----- (0001F24C) --------------------------------------------------------
int __fastcall check_global_buffers_and_execute(int input_param)
{
  int buffer_index; // r4
  int execution_result; // r0

  buffer_index = 0;
  execution_result = get_global_buffer_value(0);
  if ( execution_result )
    goto LABEL_4;
  while ( ++buffer_index != 4 )
  {
    execution_result = get_global_buffer_value(buffer_index);
    if ( execution_result )
LABEL_4:
      execution_result = initialize_single_asic_miner((unsigned __int8)buffer_index, input_param);
  }
  return execution_result;
}

//----- (0001F294) --------------------------------------------------------
int __fastcall forward_request_to_handler(unsigned __int8 request_id, unsigned int request_data)
{
  return initialize_miner_with_delay(request_id, request_data);
}

//----- (0001F29C) --------------------------------------------------------
int __fastcall check_global_buffers_and_update(char update_value)
{
  int buffer_index; // r4
  int current_index; // r0
  unsigned int buffer_value; // r5
  int update_result; // r0

  buffer_index = 0;
  do
  {
    while ( 1 )
    {
      current_index = buffer_index;
      buffer_value = (unsigned __int8)buffer_index++;
      update_result = get_global_buffer_value(current_index);
      if ( update_result )
        break;
      if ( buffer_index == 4 )
        return update_result;
    }
    update_result = set_chip_frequency(buffer_value, update_value);
  }
  while ( buffer_index != 4 );
  return update_result;
}

//----- (0001F2E8) --------------------------------------------------------
void sub_1F2E8()
{
  ;
}

//----- (0001F320) --------------------------------------------------------
int calculate_time_difference()
{
  return dword_5903F8 - dword_58E344;
}
// 58E344: using guessed type int dword_58E344;
// 5903F8: using guessed type int dword_5903F8;

//----- (0001F340) --------------------------------------------------------
int __fastcall sub_1F340(int result)
{
  _DWORD *v1; // r4
  __int64 v2; // r0
  _DWORD *inited; // r0
  char v4[2056]; // [sp+0h] [bp-808h] BYREF

  v1 = (_DWORD *)result;
  if ( result )
  {
    v2 = (unsigned int)get_global_variable();
    inited = (_DWORD *)init_asic_task(v2);
    return process_task_if_valid(v1, "inited", inited);
  }
  else if ( loggingDebug || loggingVerbose || loggingThreshold > 2 )
  {
    snprintf(v4, 2048u, "%s: input bad json param\n", "api_miner_inited");
    return logMessage(3, v4, 0);
  }
  return result;
}
// 7EBA0: using guessed type int loggingThreshold;
// 482A5C: using guessed type char loggingVerbose;
// 590404: using guessed type char loggingDebug;

//----- (0001F3E8) --------------------------------------------------------
int __fastcall updateMinerChainNumber(int jsonResult)
{
  _DWORD *minerData; // r4
  int configData; // r0
  _DWORD *chainNumberData; // r0
  char logBuffer[2056]; // [sp+0h] [bp-808h] BYREF

  minerData = (_DWORD *)jsonResult;
  if ( jsonResult )
  {
    configData = get_status_flag();
    chainNumberData = (_DWORD *)init_asic_task(configData);
    return process_task_if_valid(minerData, "chain_num", chainNumberData);
  }
  else if ( loggingDebug || loggingVerbose || loggingThreshold > 2 )
  {
    snprintf(logBuffer, 2048u, "%s: input bad json param\n", "api_miner_chain_num");
    return logMessage(3, logBuffer, 0);
  }
  return jsonResult;
}
// 7EBA0: using guessed type int loggingThreshold;
// 482A5C: using guessed type char loggingVerbose;
// 590404: using guessed type char loggingDebug;

//----- (0001F490) --------------------------------------------------------
int __fastcall calculate_5s_hash_rate(int is_task_valid)
{
  double hash_rate; // d0
  _DWORD *task_ptr; // r4
  char *sanitized_hash_rate_str; // r0
  char hash_rate_buffer[4]; // [sp+8h] [bp-818h] BYREF
  int unused1; // [sp+Ch] [bp-814h]
  int unused2; // [sp+10h] [bp-810h]
  int unused3; // [sp+14h] [bp-80Ch]
  char log_buffer[2056]; // [sp+18h] [bp-808h] BYREF

  task_ptr = (_DWORD *)is_task_valid;
  *(_DWORD *)hash_rate_buffer = 0;
  unused1 = 0;
  unused2 = 0;
  unused3 = 0;
  if ( is_task_valid )
  {
    sub_1E2C8();
    snprintf(hash_rate_buffer, 16u, "%.2f", hash_rate);
    sanitized_hash_rate_str = (char *)sanitize_utf8_string(hash_rate_buffer);
    return process_task_if_valid(task_ptr, "rate_5s", sanitized_hash_rate_str);
  }
  else if ( loggingDebug || loggingVerbose || loggingThreshold > 2 )
  {
    snprintf(log_buffer, 2048u, "%s: input bad json param\n", "api_miner_rate_5s");
    return logMessage(3, log_buffer, 0);
  }
  return is_task_valid;
}
// 1F52C: variable 'hash_rate' is possibly undefined
// 7EBA0: using guessed type int loggingThreshold;
// 482A5C: using guessed type char loggingVerbose;
// 590404: using guessed type char loggingDebug;

//----- (0001F574) --------------------------------------------------------
int __fastcall update_miner_30m_rate(int status)
{
  double hashrate_30m; // d0
  _DWORD *task_ptr; // r4
  char *sanitized_rate_str; // r0
  char rate_str[4]; // [sp+8h] [bp-818h] BYREF
  int rate_str_unused1; // [sp+Ch] [bp-814h]
  int rate_str_unused2; // [sp+10h] [bp-810h]
  int rate_str_unused3; // [sp+14h] [bp-80Ch]
  char log_buffer[2056]; // [sp+18h] [bp-808h] BYREF

  task_ptr = (_DWORD *)status;
  *(_DWORD *)rate_str = 0;
  rate_str_unused1 = 0;
  rate_str_unused2 = 0;
  rate_str_unused3 = 0;
  if ( status )
  {
    sub_1E2EC();
    if ( hashrate_30m < 0.01 )
      hashrate_30m = unk_80F50 / ((double)dword_5903F8 - (double)dword_58E344);
    snprintf(rate_str, 16u, "%.2lf", hashrate_30m);
    sanitized_rate_str = (char *)sanitize_utf8_string(rate_str);
    return process_task_if_valid(task_ptr, "rate_30m", sanitized_rate_str);
  }
  else if ( loggingDebug || loggingVerbose || loggingThreshold > 2 )
  {
    snprintf(log_buffer, 2048u, "%s: input bad json param\n", "api_miner_rate_30m");
    return logMessage(3, log_buffer, 0);
  }
  return status;
}
// 1F5AC: variable 'hashrate_30m' is possibly undefined
// 7EBA0: using guessed type int loggingThreshold;
// 482A5C: using guessed type char loggingVerbose;
// 58E344: using guessed type int dword_58E344;
// 5903F8: using guessed type int dword_5903F8;
// 590404: using guessed type char loggingDebug;

//----- (0001F6AC) --------------------------------------------------------
int __fastcall calculate_average_hashrate(int task_id)
{
  _DWORD *task_struct; // r4
  char *sanitized_string; // r0
  char hashrate_str[4]; // [sp+8h] [bp-818h] BYREF
  int unused1; // [sp+Ch] [bp-814h]
  int unused2; // [sp+10h] [bp-810h]
  int unused3; // [sp+14h] [bp-80Ch]
  char debug_message[2056]; // [sp+18h] [bp-808h] BYREF

  task_struct = (_DWORD *)task_id;
  *(_DWORD *)hashrate_str = 0;
  unused1 = 0;
  unused2 = 0;
  unused3 = 0;
  if ( task_id )
  {
    snprintf(hashrate_str, 16u, "%.2lf", unk_80F50 / ((double)dword_5903F8 - (double)dword_58E344));
    sanitized_string = (char *)sanitize_utf8_string(hashrate_str);
    return process_task_if_valid(task_struct, "rate_avg", sanitized_string);
  }
  else if ( loggingDebug || loggingVerbose || loggingThreshold > 2 )
  {
    snprintf(debug_message, 2048u, "%s: input bad json param\n", "api_miner_rate_avg");
    return logMessage(3, debug_message, 0);
  }
  return task_id;
}
// 7EBA0: using guessed type int loggingThreshold;
// 482A5C: using guessed type char loggingVerbose;
// 58E344: using guessed type int dword_58E344;
// 5903F8: using guessed type int dword_5903F8;
// 590404: using guessed type char loggingDebug;

//----- (0001F7C4) --------------------------------------------------------
int __fastcall get_optimal_hash_rate_json(int json_input)
{
  _DWORD *json_result_ptr; // r4
  int optimal_hash_rate; // r0
  char *sanitized_rate_str; // r0
  char rate_str_buf[4]; // [sp+8h] [bp-818h] BYREF
  int unused1; // [sp+Ch] [bp-814h]
  int unused2; // [sp+10h] [bp-810h]
  int unused3; // [sp+14h] [bp-80Ch]
  char log_buffer[2056]; // [sp+18h] [bp-808h] BYREF

  json_result_ptr = (_DWORD *)json_input;
  *(_DWORD *)rate_str_buf = 0;
  unused1 = 0;
  unused2 = 0;
  unused3 = 0;
  if ( json_input )
  {
    optimal_hash_rate = find_optimal_hash_rate();
    snprintf(rate_str_buf, 16u, "%.2lf", (double)optimal_hash_rate);
    sanitized_rate_str = (char *)sanitize_utf8_string(rate_str_buf);
    return process_task_if_valid(json_result_ptr, "rate_ideal", sanitized_rate_str);
  }
  else if ( loggingDebug || loggingVerbose || loggingThreshold > 2 )
  {
    snprintf(log_buffer, 2048u, "%s: input bad json param\n", "api_miner_rate_ideal");
    return logMessage(3, log_buffer, 0);
  }
  return json_input;
}
// 7EBA0: using guessed type int loggingThreshold;
// 482A5C: using guessed type char loggingVerbose;
// 590404: using guessed type char loggingDebug;

//----- (0001F8B0) --------------------------------------------------------
int __fastcall process_miner_rate_unit(int task_result)
{
  _DWORD *task_ptr; // r4
  char *sanitized_string; // r0
  int prefix_buffer; // [sp+4h] [bp-80Ch] BYREF
  char log_message_buffer[2056]; // [sp+8h] [bp-808h] BYREF

  task_ptr = (_DWORD *)task_result;
  prefix_buffer = 0;
  if ( task_result )
  {
    strcpy((char *)&prefix_buffer, "GH");
    sanitized_string = (char *)sanitize_utf8_string((const char *)&prefix_buffer);
    return process_task_if_valid(task_ptr, "rate_unit", sanitized_string);
  }
  else if ( loggingDebug || loggingVerbose || loggingThreshold > 2 )
  {
    snprintf(log_message_buffer, 2048u, "%s: input bad json param\n", "api_miner_rate_unit");
    return logMessage(3, log_message_buffer, 0);
  }
  return task_result;
}
// 7EBA0: using guessed type int loggingThreshold;
// 482A5C: using guessed type char loggingVerbose;
// 590404: using guessed type char loggingDebug;

//----- (0001F984) --------------------------------------------------------
int __fastcall process_fan_num_request(int json_result)
{
  _DWORD *request_data_pointer; // r4
  int active_fan_count; // r0
  _DWORD *inited; // r0
  char log_message_buffer[2056]; // [sp+0h] [bp-808h] BYREF

  request_data_pointer = (_DWORD *)json_result;
  if ( json_result )
  {
    active_fan_count = get_active_fan_count();
    inited = (_DWORD *)init_asic_task(active_fan_count);
    return process_task_if_valid(request_data_pointer, "fan_num", inited);
  }
  else if ( loggingDebug || loggingVerbose || loggingThreshold > 2 )
  {
    snprintf(log_message_buffer, 2048u, "%s: input bad json param\n", "api_miner_fan_num");
    return logMessage(3, log_message_buffer, 0);
  }
  return json_result;
}
// 7EBA0: using guessed type int loggingThreshold;
// 482A5C: using guessed type char loggingVerbose;
// 590404: using guessed type char loggingDebug;

//----- (0001FA2C) --------------------------------------------------------
int __fastcall updateFanSpeeds_0(int minerConfiguration)
{
  _DWORD *fanSpeedsArray; // r7
  _DWORD *firmwareInfo; // r5
  int numberOfFans; // r6
  unsigned int fanIndex; // r4
  unsigned int fanSpeedValue; // r0
  int retrievedSpeed; // r0
  _DWORD *fanSpeedPointer; // r0
  char logBuffer[2072]; // [sp+0h] [bp-818h] BYREF

  fanSpeedsArray = (_DWORD *)minerConfiguration;
  if ( minerConfiguration )
  {
    firmwareInfo = get_asic_status();
    numberOfFans = get_global_fan_count();
    if ( numberOfFans > 0 )
    {
      fanIndex = 0;
      do
      {
        fanSpeedValue = fanIndex++;
        retrievedSpeed = get_fan_speed(fanSpeedValue);
        fanSpeedPointer = (_DWORD *)init_asic_task(retrievedSpeed);
        add_to_buffer(firmwareInfo, fanSpeedPointer);
      }
      while ( numberOfFans != fanIndex );
    }
    return process_task_if_valid(fanSpeedsArray, "fan", firmwareInfo);
  }
  else if ( loggingDebug || loggingVerbose || loggingThreshold > 2 )
  {
    snprintf(logBuffer, 2048u, "%s: input bad json param\n", "api_miner_fan_speed");
    return logMessage(3, logBuffer, 0);
  }
  return minerConfiguration;
}
// 7EBA0: using guessed type int loggingThreshold;
// 482A5C: using guessed type char loggingVerbose;
// 590404: using guessed type char loggingDebug;

//----- (0001FB14) --------------------------------------------------------
int __fastcall updateMinerChainFrequency(int minerChain, unsigned int frequencyIndex)
{
  _BOOL4 isInvalidFrequency; // r3
  _DWORD *minerChainPtr; // r4
  int apiCommandResult; // r0
  _DWORD *frequencyValuePtr; // r0
  char logBuffer[2056]; // [sp+0h] [bp-808h] BYREF

  isInvalidFrequency = frequencyIndex > 3;
  if ( !minerChain )
    isInvalidFrequency = 1;
  if ( isInvalidFrequency )
  {
    if ( loggingDebug || loggingVerbose || loggingThreshold > 2 )
    {
      snprintf(logBuffer, 2048u, "%s: input bad param\n", "api_miner_chain_frequency");
      return logMessage(3, logBuffer, 0);
    }
  }
  else
  {
    minerChainPtr = (_DWORD *)minerChain;
    apiCommandResult = get_chain_frequency(frequencyIndex);
    frequencyValuePtr = (_DWORD *)init_asic_task(apiCommandResult);
    return process_task_if_valid(minerChainPtr, "freq_avg", frequencyValuePtr);
  }
  return minerChain;
}
// 7EBA0: using guessed type int loggingThreshold;
// 482A5C: using guessed type char loggingVerbose;
// 590404: using guessed type char loggingDebug;

//----- (0001FBD8) --------------------------------------------------------
int __fastcall updateMinerChainIdealRate(int minerChainStatusPtr, unsigned int chainIndex)
{
  _BOOL4 isInvalidChainIndex; // r2
  _DWORD *statusPtr; // r4
  int idealRateValue; // r0
  char *idealRateString; // r0
  int buffer[4]; // [sp+0h] [bp-818h] BYREF
  char logBuffer[2056]; // [sp+10h] [bp-808h] BYREF

  isInvalidChainIndex = chainIndex > 3;
  if ( !minerChainStatusPtr )
    isInvalidChainIndex = 1;
  memset(buffer, 0, sizeof(buffer));
  if ( isInvalidChainIndex )
  {
    if ( loggingDebug || loggingVerbose || loggingThreshold > 2 )
    {
      snprintf(logBuffer, 2048u, "%s: input bad param\n", "api_miner_chain_rate_ideal");
      return logMessage(3, logBuffer, 0);
    }
  }
  else
  {
    statusPtr = (_DWORD *)minerChainStatusPtr;
    idealRateValue = calculate_hash_rate(chainIndex);
    snprintf((char *)buffer, 16u, "%d", idealRateValue);
    idealRateString = (char *)sanitize_utf8_string((const char *)buffer);
    return process_task_if_valid(statusPtr, "rate_ideal", idealRateString);
  }
  return minerChainStatusPtr;
}
// 7EBA0: using guessed type int loggingThreshold;
// 482A5C: using guessed type char loggingVerbose;
// 590404: using guessed type char loggingDebug;

//----- (0001FCD0) --------------------------------------------------------
int __fastcall check_and_process_chain_rate(int status, unsigned int chain_index)
{
  double rate_real_value; // d0
  _BOOL4 is_invalid_condition; // r2
  _DWORD *status_pointer; // r4
  char *processed_rate_real_value; // r0
  char rate_real_str[4]; // [sp+8h] [bp-818h] BYREF
  int padding1; // [sp+Ch] [bp-814h]
  int padding2; // [sp+10h] [bp-810h]
  int padding3; // [sp+14h] [bp-80Ch]
  char log_buffer[2056]; // [sp+18h] [bp-808h] BYREF

  is_invalid_condition = chain_index > 3;
  if ( !status )
    is_invalid_condition = 1;
  *(_DWORD *)rate_real_str = 0;
  padding1 = 0;
  padding2 = 0;
  padding3 = 0;
  if ( is_invalid_condition )
  {
    if ( loggingDebug || loggingVerbose || loggingThreshold > 2 )
    {
      snprintf(log_buffer, 2048u, "%s: input bad param\n", "api_miner_chain_rate_real");
      return logMessage(3, log_buffer, 0);
    }
  }
  else
  {
    status_pointer = (_DWORD *)status;
    get_chain_buffer_ptr(chain_index);
    snprintf(rate_real_str, 16u, "%.2f", rate_real_value);
    processed_rate_real_value = (char *)sanitize_utf8_string(rate_real_str);
    return process_task_if_valid(status_pointer, "rate_real", processed_rate_real_value);
  }
  return status;
}
// 1FDA8: variable 'rate_real_value' is possibly undefined
// 7EBA0: using guessed type int loggingThreshold;
// 482A5C: using guessed type char loggingVerbose;
// 590404: using guessed type char loggingDebug;

//----- (0001FDD8) --------------------------------------------------------
int __fastcall process_chain_task_result(int task_result, unsigned int chain_index)
{
  _BOOL4 is_task_invalid; // r3
  _DWORD *task_ptr; // r4
  int chain_data_status; // r0
  _DWORD *asic_task_initialized; // r0
  char error_message[2056]; // [sp+0h] [bp-808h] BYREF

  is_task_invalid = chain_index > 3;
  if ( !task_result )
    is_task_invalid = 1;
  if ( is_task_invalid )
  {
    if ( loggingDebug || loggingVerbose || loggingThreshold > 2 )
    {
      snprintf(error_message, 2048u, "%s: input bad param\n", "api_miner_chain_asic_num");
      return logMessage(3, error_message, 0);
    }
  }
  else
  {
    task_ptr = (_DWORD *)task_result;
    chain_data_status = get_chain_data_status(chain_index);
    asic_task_initialized = (_DWORD *)init_asic_task(chain_data_status);
    return process_task_if_valid(task_ptr, "asic_num", asic_task_initialized);
  }
  return task_result;
}
// 7EBA0: using guessed type int loggingThreshold;
// 482A5C: using guessed type char loggingVerbose;
// 590404: using guessed type char loggingDebug;

//----- (0001FE9C) --------------------------------------------------------
void *__fastcall get_asic_status_or_log_error(_DWORD *task_info, unsigned int chain_id)
{
  void *status; // r0
  _BOOL4 is_invalid_param; // r3
  char *sanitized_status_info; // r0
  char raw_status_info[512]; // [sp+0h] [bp-A10h] BYREF
  char log_message_buffer[2064]; // [sp+200h] [bp-810h] BYREF

  status = memset(raw_status_info, 0, sizeof(raw_status_info));
  is_invalid_param = chain_id > 3;
  if ( !task_info )
    is_invalid_param = 1;
  if ( is_invalid_param )
  {
    if ( loggingDebug || loggingVerbose || loggingThreshold > 2 )
    {
      snprintf(log_message_buffer, 2048u, "%s: input bad param\n", "api_miner_chain_asic_status");
      return (void *)logMessage(3, log_message_buffer, 0);
    }
  }
  else
  {
    get_miner_chain_status_info(chain_id, raw_status_info);
    sanitized_status_info = (char *)sanitize_utf8_string(raw_status_info);
    return (void *)process_task_if_valid(task_info, "asic", sanitized_status_info);
  }
  return status;
}
// 7EBA0: using guessed type int loggingThreshold;
// 482A5C: using guessed type char loggingVerbose;
// 590404: using guessed type char loggingDebug;

//----- (0001FF90) --------------------------------------------------------
int __fastcall handle_temperature_request(int chain_index, unsigned int command)
{
  _BOOL4 is_invalid_param; // r3
  _DWORD *chain_data_ptr; // r6
  _DWORD *task_buffer_ptr; // r7
  const char *shared_variable; // r0
  const char *model_number; // r0
  int board_status; // r8
  int board_index; // r4
  int board_idx; // r1
  __int16 board_temperature; // r0
  _DWORD *inited; // r0
  char log_message_buffer[2072]; // [sp+0h] [bp-818h] BYREF

  is_invalid_param = command > 3;
  if ( !chain_index )
    is_invalid_param = 1;
  if ( is_invalid_param )
  {
    if ( loggingDebug || loggingVerbose || loggingThreshold > 2 )
    {
      snprintf(log_message_buffer, 2048u, "%s: input bad param\n", "api_miner_chain_temp_pic");
      return logMessage(3, log_message_buffer, 0);
    }
  }
  else
  {
    chain_data_ptr = (_DWORD *)chain_index;
    task_buffer_ptr = get_asic_status();
    shared_variable = (const char *)get_shared_variable();
    if ( !strcmp(shared_variable, "BHB28601")
      || (model_number = (const char *)get_shared_variable(), !strcmp(model_number, "BHB28501")) )
    {
      board_status = check_miner_status();
    }
    else
    {
      board_status = sub_1E19C();
    }
    if ( board_status > 0 )
    {
      board_index = 0;
      do
      {
        board_idx = (unsigned __int8)board_index++;
        board_temperature = get_board_temperature(command, board_idx);
        inited = (_DWORD *)init_asic_task(board_temperature);
        add_to_buffer(task_buffer_ptr, inited);
      }
      while ( board_status != board_index );
    }
    return process_task_if_valid(chain_data_ptr, "temp_pic", task_buffer_ptr);
  }
  return chain_index;
}
// 7EBA0: using guessed type int loggingThreshold;
// 482A5C: using guessed type char loggingVerbose;
// 590404: using guessed type char loggingDebug;

//----- (000200D0) --------------------------------------------------------
int __fastcall process_temperature_monitoring(int monitoring_active, unsigned int chain_index)
{
  int is_invalid; // r4
  _DWORD *monitoring_ptr; // r6
  _DWORD *task_buffer_ptr; // r7
  __int16 adjusted_temperature; // r0
  _DWORD *asic_task_ptr; // r0
  bool has_reached_limit; // cc
  int current_index; // r1
  __int16 board_temperature; // r0
  _DWORD *inited; // r0
  char log_buffer[2072]; // [sp+0h] [bp-818h] BYREF

  is_invalid = chain_index > 3;
  if ( !monitoring_active )
    is_invalid = 1;
  if ( is_invalid )
  {
    if ( loggingDebug || loggingVerbose || loggingThreshold > 2 )
    {
      snprintf(log_buffer, 2048u, "%s: input bad param\n", "api_miner_chain_temp_chip");
      return logMessage(3, log_buffer, 0);
    }
  }
  else
  {
    monitoring_ptr = (_DWORD *)monitoring_active;
    task_buffer_ptr = get_asic_status();
    if ( optBitmainWorkMode == 1 || dword_482A8C <= 0 )
    {
      while ( sub_1E19C() > is_invalid )
      {
        board_temperature = get_board_temperature(chain_index, (unsigned __int8)is_invalid++);
        inited = (_DWORD *)init_asic_task(board_temperature);
        add_to_buffer(task_buffer_ptr, inited);
      }
    }
    else
    {
      while ( 1 )
      {
        has_reached_limit = check_miner_status() <= is_invalid;
        current_index = (unsigned __int8)is_invalid++;
        if ( has_reached_limit )
          break;
        adjusted_temperature = get_adjusted_temperature(chain_index, current_index);
        asic_task_ptr = (_DWORD *)init_asic_task(adjusted_temperature);
        add_to_buffer(task_buffer_ptr, asic_task_ptr);
      }
    }
    return process_task_if_valid(monitoring_ptr, "temp_chip", task_buffer_ptr);
  }
  return monitoring_active;
}
// 7EBA0: using guessed type int loggingThreshold;
// 80FB4: using guessed type int optBitmainWorkMode;
// 482A5C: using guessed type char loggingVerbose;
// 482A8C: using guessed type int dword_482A8C;
// 590404: using guessed type char loggingDebug;

//----- (00020234) --------------------------------------------------------
int __fastcall process_temperature_control(int is_valid_param, unsigned int a2)
{
  int v2; // r4
  _DWORD *v4; // r6
  _DWORD *asic_status; // r7
  __int16 v6; // r0
  _DWORD *v7; // r0
  bool v8; // cc
  int v9; // r1
  __int16 board_temperature; // r0
  _DWORD *inited; // r0
  char v12[2072]; // [sp+0h] [bp-818h] BYREF

  v2 = a2 > 3;
  if ( !is_valid_param )
    v2 = 1;
  if ( v2 )
  {
    if ( loggingDebug || loggingVerbose || loggingThreshold > 2 )
    {
      snprintf(v12, 2048u, "%s: input bad param\n", "api_miner_chain_temp_pcb");
      return logMessage(3, v12, 0);
    }
  }
  else
  {
    v4 = (_DWORD *)is_valid_param;
    asic_status = get_asic_status();
    if ( optBitmainWorkMode == 1 || dword_482A8C <= 0 )
    {
      while ( sub_1E19C() > v2 )
      {
        board_temperature = get_board_temperature(a2, (unsigned __int8)v2++);
        inited = (_DWORD *)init_asic_task(board_temperature);
        add_to_buffer(asic_status, inited);
      }
    }
    else
    {
      while ( 1 )
      {
        v8 = check_miner_status() <= v2;
        v9 = (unsigned __int8)v2++;
        if ( v8 )
          break;
        v6 = calculate_temperature_adjustment(a2, v9);
        v7 = (_DWORD *)init_asic_task(v6);
        add_to_buffer(asic_status, v7);
      }
    }
    return process_task_if_valid(v4, "temp_pcb", asic_status);
  }
  return is_valid_param;
}
// 7EBA0: using guessed type int loggingThreshold;
// 80FB4: using guessed type int optBitmainWorkMode;
// 482A5C: using guessed type char loggingVerbose;
// 482A8C: using guessed type int dword_482A8C;
// 590404: using guessed type char loggingDebug;

//----- (00020398) --------------------------------------------------------
int __fastcall update_miner_chain_rate(int chain_index, unsigned int rate_index)
{
  unsigned int is_invalid_param; // r6
  _DWORD *chain_data; // r8
  _DWORD *rate_task_buffer; // r5
  double *temperature_array; // r4
  double temperature_value; // t1
  __int64 temperature_result; // r0
  _DWORD *asic_task_ptr; // r0
  unsigned int roll_count; // r10
  unsigned int roll_limit; // r9
  unsigned int array_index; // r3
  __int64 temperature_calc_result; // r0
  _DWORD *inited; // r0
  char log_message_buffer[2080]; // [sp+8h] [bp-820h] BYREF

  is_invalid_param = rate_index > 3;
  if ( !chain_index )
    is_invalid_param = 1;
  if ( is_invalid_param )
  {
    if ( loggingDebug || loggingVerbose || loggingThreshold > 2 )
    {
      snprintf(log_message_buffer, 2048u, "%s: input bad param\n", "api_miner_chain_rate_array");
      return logMessage(3, log_message_buffer, 0);
    }
  }
  else
  {
    chain_data = (_DWORD *)chain_index;
    rate_task_buffer = get_asic_status();
    if ( (unsigned int)dword_7F8F0 > 23 )
    {
      roll_count = dword_7F8F0 % 24u;
      roll_limit = dword_7F8F0 % 24u + 24;
      do
      {
        array_index = roll_count % 24;
        ++roll_count;
        LODWORD(temperature_calc_result) = calculate_temperature(dbl_58E040[24 * rate_index + array_index]);
        inited = (_DWORD *)init_asic_task(temperature_calc_result);
        add_to_buffer(rate_task_buffer, inited);
      }
      while ( roll_limit != roll_count );
    }
    else if ( dword_7F8F0 )
    {
      temperature_array = &dbl_58E040[24 * rate_index];
      do
      {
        temperature_value = *temperature_array++;
        ++is_invalid_param;
        LODWORD(temperature_result) = calculate_temperature(temperature_value);
        asic_task_ptr = (_DWORD *)init_asic_task(temperature_result);
        add_to_buffer(rate_task_buffer, asic_task_ptr);
      }
      while ( is_invalid_param < dword_7F8F0 );
    }
    return process_task_if_valid(chain_data, "rate_array", rate_task_buffer);
  }
  return chain_index;
}
// 2047C: variable 'temperature_result' is possibly undefined
// 20508: variable 'temperature_calc_result' is possibly undefined
// 7EBA0: using guessed type int loggingThreshold;
// 7F8F0: using guessed type int dword_7F8F0;
// 482A5C: using guessed type char loggingVerbose;
// 58E040: using guessed type double dbl_58E040[96];
// 590404: using guessed type char loggingDebug;

//----- (00020528) --------------------------------------------------------
int __fastcall check_parameters_and_process_task(int status_code, unsigned int chain_index)
{
  _BOOL4 is_invalid_param; // r3
  _DWORD *task_status_ptr; // r4
  int chain_buffer_status; // r0
  _DWORD *inited; // r0
  char log_buffer[2056]; // [sp+0h] [bp-808h] BYREF

  is_invalid_param = chain_index > 3;
  if ( !status_code )
    is_invalid_param = 1;
  if ( is_invalid_param )
  {
    if ( loggingDebug || loggingVerbose || loggingThreshold > 2 )
    {
      snprintf(log_buffer, 2048u, "%s: input bad param\n", "api_miner_chain_hw");
      return logMessage(3, log_buffer, 0);
    }
  }
  else
  {
    task_status_ptr = (_DWORD *)status_code;
    chain_buffer_status = get_chain_buffer_status(chain_index);
    inited = (_DWORD *)init_asic_task(chain_buffer_status);
    return process_task_if_valid(task_status_ptr, "hw", inited);
  }
  return status_code;
}
// 7EBA0: using guessed type int loggingThreshold;
// 482A5C: using guessed type char loggingVerbose;
// 590404: using guessed type char loggingDebug;

//----- (000205EC) --------------------------------------------------------
int __fastcall check_and_process_nonce_task(int task_data_ptr, unsigned int chain_index)
{
  _BOOL4 is_invalid_param; // r3
  _DWORD *task_data; // r4
  _DWORD *inited; // r0
  char log_buffer[2056]; // [sp+0h] [bp-808h] BYREF

  is_invalid_param = chain_index > 3;
  if ( !task_data_ptr )
    is_invalid_param = 1;
  if ( is_invalid_param )
  {
    if ( loggingDebug || loggingVerbose || loggingThreshold > 2 )
    {
      snprintf(log_buffer, 2048u, "%s: input bad param\n", "api_miner_chain_nonce");
      return logMessage(3, log_buffer, 0);
    }
  }
  else
  {
    task_data = (_DWORD *)task_data_ptr;
    inited = (_DWORD *)init_asic_task(dword_81118[chain_index]);
    return process_task_if_valid(task_data, "nonce", inited);
  }
  return task_data_ptr;
}
// 7EBA0: using guessed type int loggingThreshold;
// 81118: using guessed type int dword_81118[3];
// 482A5C: using guessed type char loggingVerbose;
// 590404: using guessed type char loggingDebug;

//----- (000206B4) --------------------------------------------------------
int __fastcall check_and_process_chain_eeprom_task(int task_status_code, unsigned int chain_index)
{
  _BOOL4 is_chain_invalid; // r3
  _DWORD *task_data_pointer; // r4
  _DWORD *hardware_info_ptr; // r2
  char error_message_buffer[2056]; // [sp+0h] [bp-808h] BYREF

  is_chain_invalid = chain_index > 3;
  if ( !task_status_code )
    is_chain_invalid = 1;
  if ( is_chain_invalid )
  {
    if ( loggingDebug || loggingVerbose || loggingThreshold > 2 )
    {
      snprintf(error_message_buffer, 2048u, "%s: input bad param\n", "api_miner_chain_eeprom");
      return logMessage(3, error_message_buffer, 0);
    }
  }
  else
  {
    task_data_pointer = (_DWORD *)task_status_code;
    if ( is_chain_config_active(chain_index) )
      hardware_info_ptr = get_miner_hardware_info_pointer();
    else
      hardware_info_ptr = get_unk_7F578_address();
    return process_task_if_valid(task_data_pointer, "eeprom", hardware_info_ptr);
  }
  return task_status_code;
}
// 7EBA0: using guessed type int loggingThreshold;
// 482A5C: using guessed type char loggingVerbose;
// 590404: using guessed type char loggingDebug;

//----- (00020788) --------------------------------------------------------
void *__fastcall process_chain_serial_number(_DWORD *task, size_t chain_index)
{
  void *task_result; // r0
  _BOOL4 is_invalid_parameter; // r3
  char *sanitized_serial_number; // r0
  char serial_number_buffer[32]; // [sp+0h] [bp-830h] BYREF
  char log_buffer[2064]; // [sp+20h] [bp-810h] BYREF

  task_result = memset(serial_number_buffer, 0, sizeof(serial_number_buffer));
  is_invalid_parameter = chain_index > 3;
  if ( !task )
    is_invalid_parameter = 1;
  if ( is_invalid_parameter )
  {
    if ( loggingDebug || loggingVerbose || loggingThreshold > 2 )
    {
      snprintf(log_buffer, 2048u, "%s: input bad param\n", "api_miner_chain_sn");
      return (void *)logMessage(3, log_buffer, 0);
    }
  }
  else
  {
    GetChainSerialNumber(chain_index, serial_number_buffer, 32u);
    sanitized_serial_number = (char *)sanitize_utf8_string(serial_number_buffer);
    return (void *)process_task_if_valid(task, "sn", sanitized_serial_number);
  }
  return task_result;
}
// 7EBA0: using guessed type int loggingThreshold;
// 482A5C: using guessed type char loggingVerbose;
// 590404: using guessed type char loggingDebug;

//----- (00020880) --------------------------------------------------------
int __fastcall process_voltage_level_task(_DWORD *task_struct, int asic_index)
{
  _DWORD *inited; // r0
  unsigned int voltage_level; // [sp+4h] [bp-14h] BYREF

  voltage_level = 0;
  getVoltageLevel(asic_index, 2, (int *)&voltage_level);
  inited = (_DWORD *)init_asic_task(voltage_level);
  return process_task_if_valid(task_struct, "eeprom_vol", inited);
}

//----- (000208CC) --------------------------------------------------------
int __fastcall configure_eeprom_frequency(_DWORD *task_results, int chip_frequency)
{
  _DWORD *inited; // r0
  unsigned int optimal_frequency; // [sp+4h] [bp-14h] BYREF

  optimal_frequency = 0;
  setOptimalFrequency(chip_frequency, 2, (int *)&optimal_frequency);
  inited = (_DWORD *)init_asic_task(optimal_frequency);
  return process_task_if_valid(task_results, "eeprom_freq", inited);
}

//----- (00020918) --------------------------------------------------------
int __fastcall process_eeprom_task(_DWORD *task_ptr, int chain_index)
{
  _DWORD *inited; // r0
  unsigned int chain_voltage; // [sp+4h] [bp-14h] BYREF

  chain_voltage = 0;
  get_chain_voltage(chain_index, &chain_voltage);
  inited = (_DWORD *)init_asic_task(chain_voltage);
  return process_task_if_valid(task_ptr, "eeprom_bin", inited);
}

//----- (00020964) --------------------------------------------------------
int __fastcall process_eeprom_ft_task(_DWORD *task_struct_pointer, int chain_index)
{
  char *sanitized_string; // r0
  int version_buffer[6]; // [sp+0h] [bp-18h] BYREF

  memset(version_buffer, 0, 16);
  get_chain_version_string(chain_index, (char *)version_buffer, 16u);
  sanitized_string = (char *)sanitize_utf8_string((const char *)version_buffer);
  return process_task_if_valid(task_struct_pointer, "eeprom_ft", sanitized_string);
}

//----- (000209BC) --------------------------------------------------------
int __fastcall sub_209BC(_DWORD *a1, int a2)
{
  _DWORD *inited; // r0
  unsigned int v5; // [sp+4h] [bp-14h] BYREF

  v5 = 0;
  getChainTestStandard(a2, &v5);
  inited = (_DWORD *)init_asic_task(v5);
  return process_task_if_valid(a1, "eeprom_code", inited);
}

//----- (00020A08) --------------------------------------------------------
char __fastcall update_status_flag(char flag)
{
  LOBYTE(dword_7F8F4) = dword_7F8F4 & 0xFE | flag & 1;
  return flag;
}
// 7F8F4: using guessed type int dword_7F8F4;

//----- (00020A20) --------------------------------------------------------
char __fastcall set_fan_control_mode(char control_mode)
{
  LOBYTE(dword_7F8F4) = dword_7F8F4 & 0xFD | (2 * (control_mode & 1));
  return control_mode;
}
// 7F8F4: using guessed type int dword_7F8F4;

//----- (00020A38) --------------------------------------------------------
char __fastcall update_miner_status_led(char status_led_state)
{
  LOBYTE(dword_7F8F4) = dword_7F8F4 & 0xFB | (4 * (status_led_state & 1));
  return status_led_state;
}
// 7F8F4: using guessed type int dword_7F8F4;

//----- (00020A50) --------------------------------------------------------
int __fastcall handle_error_code_task(_DWORD *task_data)
{
  int error_code; // r4
  _DWORD *asic_task_inited; // r0
  char log_buffer[2064]; // [sp+0h] [bp-810h] BYREF

  error_code = dword_7F8F4;
  if ( (unsigned int)globalLogLevel > 4 )
  {
    snprintf(log_buffer, 2048u, "error_code = %d\n", dword_7F8F4);
    logMessage(4, log_buffer, 0);
  }
  asic_task_inited = (_DWORD *)init_asic_task(error_code);
  return process_task_if_valid(task_data, "error_code", asic_task_inited);
}
// 7EB9C: using guessed type int globalLogLevel;
// 7F8F4: using guessed type int dword_7F8F4;

//----- (00020AD4) --------------------------------------------------------
int __fastcall process_miner_version_request(int request)
{
  _DWORD *task_ptr; // r4
  char *sanitized_version; // r0
  char log_buffer[2056]; // [sp+0h] [bp-808h] BYREF

  task_ptr = (_DWORD *)request;
  if ( request )
  {
    sanitized_version = (char *)sanitize_utf8_string(byte_80FDC);
    return process_task_if_valid(task_ptr, "miner_version", sanitized_version);
  }
  else if ( loggingDebug || loggingVerbose || loggingThreshold > 2 )
  {
    snprintf(log_buffer, 2048u, "%s: input bad json param\n", "api_miner_version");
    return logMessage(3, log_buffer, 0);
  }
  return request;
}
// 7EBA0: using guessed type int loggingThreshold;
// 482A5C: using guessed type char loggingVerbose;
// 590404: using guessed type char loggingDebug;

//----- (00020B7C) --------------------------------------------------------
int __fastcall process_total_hash_json(int json_result)
{
  _DWORD *json_data; // r4
  _DWORD *processed_value; // r0
  char log_message[2056]; // [sp+0h] [bp-808h] BYREF

  json_data = (_DWORD *)json_result;
  if ( json_result )
  {
    processed_value = (_DWORD *)process_double_value();
    return process_task_if_valid(json_data, "total_hash", processed_value);
  }
  else if ( loggingDebug || loggingVerbose || loggingThreshold > 2 )
  {
    snprintf(log_message, 2048u, "%s: input bad json param\n", "api_total_hash");
    return logMessage(3, log_message, 0);
  }
  return json_result;
}
// 7EBA0: using guessed type int loggingThreshold;
// 482A5C: using guessed type char loggingVerbose;
// 590404: using guessed type char loggingDebug;

//----- (00020C28) --------------------------------------------------------
int __fastcall process_miner_id_request(int request_result)
{
  _DWORD *task_pointer; // r4
  char *sanitized_miner_id; // r0
  char error_message[2056]; // [sp+0h] [bp-808h] BYREF

  task_pointer = (_DWORD *)request_result;
  if ( request_result )
  {
    sanitized_miner_id = (char *)sanitize_utf8_string(byte_99EDE0);
    return process_task_if_valid(task_pointer, "miner_id", sanitized_miner_id);
  }
  else if ( loggingDebug || loggingVerbose || loggingThreshold > 2 )
  {
    snprintf(error_message, 2048u, "%s: input bad json param\n", "api_miner_id");
    return logMessage(3, error_message, 0);
  }
  return request_result;
}
// 7EBA0: using guessed type int loggingThreshold;
// 482A5C: using guessed type char loggingVerbose;
// 590404: using guessed type char loggingDebug;

//----- (00020CD0) --------------------------------------------------------
_DWORD *__fastcall initialize_sha256_state(_DWORD *sha256_state)
{
  sha256_state[2] = 1779033703;
  sha256_state[3] = -1150833019;
  sha256_state[4] = 1013904242;
  sha256_state[5] = -1521486534;
  sha256_state[6] = 1359893119;
  sha256_state[7] = -1694144372;
  sha256_state[8] = 528734635;
  sha256_state[9] = 1541459225;
  *sha256_state = 0;
  sha256_state[1] = 0;
  return sha256_state;
}

//----- (00020D44) --------------------------------------------------------
int __fastcall process_block(_DWORD *block, unsigned int *words)
{
  int hash2; // r7
  int hash4; // r8
  int hash5; // r1
  int hash6; // r9
  unsigned int word0; // r5
  unsigned int t1; // r3
  int sum1; // r6
  unsigned int t2; // r12
  int new_a; // r3
  int new_e; // r0
  int new_f; // r5
  int new_a2; // r3
  int new_e2; // r2
  int new_f2; // r4
  int new_g; // lr
  int new_e3; // r3
  int sum0; // r11
  int new_g2; // r6
  unsigned int v21; // r12
  int v22; // r10
  int v23; // r6
  int v24; // r0
  int v25; // r6
  int v26; // r8
  int v27; // r5
  int v28; // r2
  int v29; // r9
  int v30; // r3
  int v31; // r9
  int v32; // r11
  int v33; // r10
  int v34; // r11
  int v35; // r12
  int v36; // r6
  int v37; // r7
  int v38; // r12
  int v39; // r5
  int v40; // lr
  int v41; // r12
  int v42; // r2
  int v43; // r9
  int v44; // r10
  int v45; // r4
  int v46; // r11
  int v47; // r6
  int v48; // r7
  int v49; // r0
  int v50; // r5
  int v51; // r6
  int v52; // lr
  int v53; // r9
  int v54; // r2
  int v55; // r11
  int v56; // r9
  int v57; // r3
  unsigned int v58; // r10
  int v59; // r1
  int v60; // r4
  int v61; // r12
  int v62; // lr
  int v63; // r6
  int v64; // r0
  int v65; // r2
  int v66; // r1
  int v67; // r5
  int v68; // r9
  int v69; // lr
  int v70; // r2
  int v71; // r4
  int v72; // r12
  int v73; // r3
  int v74; // r4
  int v75; // r0
  int v76; // r4
  int v77; // r8
  int v78; // r1
  int v79; // r9
  unsigned int v80; // r10
  int v81; // r7
  int v82; // r2
  int v83; // r7
  int v84; // r6
  int v85; // r12
  int v86; // r3
  int v87; // r6
  int v88; // r4
  int v89; // r0
  int v90; // r6
  int v91; // r1
  int v92; // r9
  int v93; // r5
  int v94; // r7
  int v95; // r5
  int v96; // lr
  int v97; // r12
  int v98; // r3
  int v99; // lr
  int v100; // r0
  int v101; // r4
  int v102; // lr
  int v103; // r9
  int v104; // r1
  int v105; // lr
  int v106; // r8
  int v107; // r5
  int v108; // r11
  int v109; // r6
  int v110; // r3
  int v111; // r10
  int v112; // r1
  int v113; // r4
  int v114; // r8
  int v115; // r1
  int v116; // r6
  int v117; // r2
  int v118; // r5
  int v119; // r0
  int v120; // r12
  int v121; // lr
  int v122; // r7
  int v123; // r3
  int v124; // r9
  int v125; // r1
  int v126; // r4
  int v127; // r5
  int v128; // r9
  int v129; // r10
  int v130; // r5
  int v131; // r12
  int v132; // r2
  int v133; // r8
  int v134; // r3
  int v135; // r0
  int v136; // r7
  int v137; // r11
  int v138; // r1
  int v139; // r10
  int v140; // r8
  int v141; // r5
  int v142; // r2
  int v143; // r9
  int v144; // r5
  int v145; // r0
  int v146; // r12
  int v147; // r7
  int v148; // r11
  int v149; // r3
  int v150; // r7
  int v151; // r10
  int v152; // lr
  int v153; // r7
  int v154; // r9
  int v155; // r8
  int v156; // r6
  int v157; // r5
  int v158; // r12
  int v159; // r0
  int v160; // r3
  int v161; // r0
  int v162; // r11
  int v163; // lr
  int v164; // r11
  int v165; // r10
  int v166; // r8
  int v167; // r10
  int v168; // r9
  int v169; // r5
  int v170; // r9
  int v171; // r12
  int v172; // r0
  int v173; // r12
  int v174; // r7
  int v175; // r11
  int v176; // r3
  unsigned int v177; // r6
  unsigned int v178; // r1
  int v179; // lr
  int v180; // r2
  int v181; // r3
  unsigned int v182; // r7
  int v183; // r4
  int v184; // r12
  int v185; // r4
  unsigned int v186; // r10
  int v187; // r1
  int v188; // r8
  int v189; // lr
  int v190; // r10
  unsigned int v191; // r7
  int v192; // r6
  int v193; // r1
  int v194; // r2
  unsigned int v195; // r8
  int v196; // r9
  int v197; // r3
  int v198; // r0
  int v199; // r6
  int v200; // r5
  int v201; // r4
  int v202; // r12
  int v203; // r9
  int result; // r0
  unsigned int *v205; // [sp+4h] [bp-9Ch]
  unsigned int v206; // [sp+4h] [bp-9Ch]
  unsigned int v207; // [sp+4h] [bp-9Ch]
  int v208; // [sp+4h] [bp-9Ch]
  unsigned int v209; // [sp+8h] [bp-98h]
  unsigned int v210; // [sp+8h] [bp-98h]
  unsigned int v211; // [sp+8h] [bp-98h]
  unsigned int v212; // [sp+Ch] [bp-94h]
  unsigned int v213; // [sp+Ch] [bp-94h]
  unsigned int v214; // [sp+Ch] [bp-94h]
  unsigned int v215; // [sp+10h] [bp-90h]
  unsigned int v216; // [sp+10h] [bp-90h]
  unsigned int v217; // [sp+10h] [bp-90h]
  unsigned int v218; // [sp+14h] [bp-8Ch]
  unsigned int v219; // [sp+14h] [bp-8Ch]
  unsigned int v220; // [sp+14h] [bp-8Ch]
  unsigned int v221; // [sp+18h] [bp-88h]
  unsigned int v222; // [sp+18h] [bp-88h]
  unsigned int v223; // [sp+18h] [bp-88h]
  unsigned int v224; // [sp+18h] [bp-88h]
  unsigned int v225; // [sp+1Ch] [bp-84h]
  unsigned int v226; // [sp+1Ch] [bp-84h]
  unsigned int v227; // [sp+1Ch] [bp-84h]
  int v228; // [sp+1Ch] [bp-84h]
  int v229; // [sp+1Ch] [bp-84h]
  unsigned int v230; // [sp+20h] [bp-80h]
  unsigned int v231; // [sp+20h] [bp-80h]
  unsigned int v232; // [sp+20h] [bp-80h]
  unsigned int v233; // [sp+20h] [bp-80h]
  unsigned int v234; // [sp+24h] [bp-7Ch]
  int v235; // [sp+24h] [bp-7Ch]
  unsigned int v236; // [sp+24h] [bp-7Ch]
  unsigned int v237; // [sp+24h] [bp-7Ch]
  unsigned int v238; // [sp+24h] [bp-7Ch]
  unsigned int v239; // [sp+28h] [bp-78h]
  unsigned int v240; // [sp+28h] [bp-78h]
  unsigned int v241; // [sp+28h] [bp-78h]
  int v242; // [sp+28h] [bp-78h]
  unsigned int v243; // [sp+2Ch] [bp-74h]
  unsigned int v244; // [sp+2Ch] [bp-74h]
  unsigned int v245; // [sp+2Ch] [bp-74h]
  int v246; // [sp+2Ch] [bp-74h]
  unsigned int v247; // [sp+30h] [bp-70h]
  unsigned int v248; // [sp+30h] [bp-70h]
  unsigned int v249; // [sp+30h] [bp-70h]
  unsigned int v250; // [sp+34h] [bp-6Ch]
  unsigned int v251; // [sp+34h] [bp-6Ch]
  unsigned int v252; // [sp+34h] [bp-6Ch]
  unsigned int v253; // [sp+34h] [bp-6Ch]
  unsigned int v254; // [sp+38h] [bp-68h]
  unsigned int v255; // [sp+38h] [bp-68h]
  unsigned int v256; // [sp+38h] [bp-68h]
  unsigned int v257; // [sp+3Ch] [bp-64h]
  unsigned int v258; // [sp+3Ch] [bp-64h]
  unsigned int v259; // [sp+3Ch] [bp-64h]
  unsigned int v260; // [sp+40h] [bp-60h]
  unsigned int v261; // [sp+40h] [bp-60h]
  unsigned int v262; // [sp+40h] [bp-60h]
  unsigned int v263; // [sp+40h] [bp-60h]
  unsigned int v264; // [sp+44h] [bp-5Ch]
  unsigned int v265; // [sp+44h] [bp-5Ch]
  unsigned int v266; // [sp+44h] [bp-5Ch]
  unsigned int v267; // [sp+44h] [bp-5Ch]
  unsigned int v268; // [sp+48h] [bp-58h]
  unsigned int v269; // [sp+48h] [bp-58h]
  unsigned int v270; // [sp+48h] [bp-58h]
  int v271; // [sp+4Ch] [bp-54h]
  unsigned int v272; // [sp+50h] [bp-50h]
  unsigned int v273; // [sp+54h] [bp-4Ch]
  int v274; // [sp+58h] [bp-48h]
  int v275; // [sp+5Ch] [bp-44h]
  int v276; // [sp+60h] [bp-40h]
  int v277; // [sp+64h] [bp-3Ch]
  int v278; // [sp+68h] [bp-38h]
  int v279; // [sp+6Ch] [bp-34h]
  int v280; // [sp+70h] [bp-30h]

  hash2 = block[2];
  hash4 = block[6];
  hash5 = block[8];
  hash6 = block[7];
  v205 = words;
  v275 = block[3];
  v277 = block[5];
  v280 = block[9];
  word0 = bswap32(*words);
  v276 = block[4];
  t1 = (__ROR4__(hash4, 11) ^ __ROR4__(hash4, 6) ^ __ROR4__(hash4, 25))
     + v280
     + 1116352408
     + ((hash6 ^ hash5) & hash4 ^ hash5)
     + word0;
  v225 = word0;
  sum1 = v277 + t1;
  t2 = (__ROR4__(hash2, 13) ^ __ROR4__(hash2, 2) ^ __ROR4__(hash2, 22)) + ((hash2 | v275) & v276 | hash2 & v275) + t1;
  v209 = bswap32(words[1]);
  v274 = hash2;
  v279 = hash5;
  new_a = ((hash4 ^ hash6) & (v277 + t1) ^ hash6)
        + hash5
        + 1899447441
        + v209
        + (__ROR4__(v277 + t1, 11) ^ __ROR4__(v277 + t1, 6) ^ __ROR4__(v277 + t1, 25));
  v271 = hash4;
  new_e = (__ROR4__(t2, 13) ^ __ROR4__(t2, 2) ^ __ROR4__(t2, 22)) + ((hash2 | t2) & v275 | hash2 & t2) + new_a;
  new_f = v276 + new_a;
  v278 = hash6;
  v260 = bswap32(words[2]);
  new_a2 = ((v271 ^ sum1) & (v276 + new_a) ^ v271)
         + hash6
         - 1245643825
         + v260
         + (__ROR4__(v276 + new_a, 11) ^ __ROR4__(v276 + new_a, 6) ^ __ROR4__(v276 + new_a, 25));
  new_e2 = (__ROR4__(new_e, 13) ^ __ROR4__(new_e, 2) ^ __ROR4__(new_e, 22))
         + ((t2 | new_e) & hash2 | t2 & new_e)
         + new_a2;
  new_f2 = v275 + new_a2;
  v230 = bswap32(words[3]);
  new_g = ((sum1 ^ new_f) & new_f2 ^ sum1)
        + hash4
        - 373957723
        + v230
        + (__ROR4__(v275 + new_a2, 11) ^ __ROR4__(new_f2, 6) ^ __ROR4__(new_f2, 25));
  new_e3 = (__ROR4__(new_e2, 13) ^ __ROR4__(new_e2, 2) ^ __ROR4__(new_e2, 22))
         + ((new_e | new_e2) & t2 | new_e & new_e2)
         + new_g;
  sum0 = hash2 + new_g;
  v221 = words[8];
  v264 = bswap32(words[4]);
  new_g2 = ((new_f ^ new_f2) & (v274 + new_g) ^ new_f)
         + v264
         + 961987163
         + sum1
         + (__ROR4__(sum0, 11) ^ __ROR4__(sum0, 6) ^ __ROR4__(v274 + new_g, 25));
  v21 = t2 + new_g2;
  v234 = words[9];
  v250 = words[10];
  v22 = (__ROR4__(new_e3, 13) ^ __ROR4__(new_e3, 2) ^ __ROR4__(new_e3, 22))
      + ((new_e2 | new_e3) & new_e | new_e2 & new_e3)
      + new_g2;
  v239 = bswap32(v205[5]);
  v23 = ((new_f2 ^ (hash2 + new_g)) & v21 ^ new_f2)
      + v239
      + 1508970993
      + new_f
      + (__ROR4__(v21, 11) ^ __ROR4__(v21, 6) ^ __ROR4__(v21, 25));
  v24 = new_e + v23;
  v25 = (__ROR4__(v22, 13) ^ __ROR4__(v22, 2) ^ __ROR4__(v22, 22)) + ((new_e3 | v22) & new_e2 | new_e3 & v22) + v23;
  v257 = bswap32(v205[6]);
  v26 = ((sum0 ^ v21) & v24 ^ sum0)
      + v257
      - 1841331548
      + new_f2
      + (__ROR4__(v24, 11) ^ __ROR4__(v24, 6) ^ __ROR4__(v24, 25));
  v27 = (__ROR4__(v25, 13) ^ __ROR4__(v25, 2) ^ __ROR4__(v25, 22)) + ((v22 | v25) & new_e3 | v22 & v25) + v26;
  v28 = new_e2 + v26;
  v243 = bswap32(v205[7]);
  v29 = ((v21 ^ v24) & v28 ^ v21)
      + v243
      - 1424204075
      + hash2
      + new_g
      + (__ROR4__(v28, 11) ^ __ROR4__(v28, 6) ^ __ROR4__(v28, 25));
  v30 = new_e3 + v29;
  v247 = bswap32(v221);
  v212 = bswap32(v234);
  v31 = (__ROR4__(v27, 13) ^ __ROR4__(v27, 2) ^ __ROR4__(v27, 22)) + ((v25 | v27) & v22 | v25 & v27) + v29;
  v215 = bswap32(v250);
  v218 = bswap32(v205[11]);
  v32 = ((v24 ^ v28) & v30 ^ v24) + v247 - 670586216 + v21 + (__ROR4__(v30, 11) ^ __ROR4__(v30, 6) ^ __ROR4__(v30, 25));
  v33 = v22 + v32;
  v251 = bswap32(v205[12]);
  v34 = (__ROR4__(v31, 13) ^ __ROR4__(v31, 2) ^ __ROR4__(v31, 22)) + ((v27 | v31) & v25 | v27 & v31) + v32;
  v35 = ((v28 ^ v30) & v33 ^ v28) + v212 + 310598401 + v24 + (__ROR4__(v33, 11) ^ __ROR4__(v33, 6) ^ __ROR4__(v33, 25));
  v36 = v25 + v35;
  v254 = bswap32(v205[13]);
  v37 = (__ROR4__(v34, 13) ^ __ROR4__(v34, 2) ^ __ROR4__(v34, 22)) + ((v31 | v34) & v27 | v31 & v34) + v35;
  v222 = bswap32(v205[14]);
  v38 = ((v30 ^ v33) & v36 ^ v30) + v215 + 607225278 + v28 + (__ROR4__(v36, 11) ^ __ROR4__(v36, 6) ^ __ROR4__(v36, 25));
  v206 = bswap32(v205[15]);
  v39 = v27 + v38;
  v40 = (__ROR4__(v37, 13) ^ __ROR4__(v37, 2) ^ __ROR4__(v37, 22)) + ((v34 | v37) & v31 | v34 & v37) + v38;
  v268 = v209 + v215;
  v41 = ((v33 ^ v36) & v39 ^ v33) + v218 + 1426881987 + v30 + (__ROR4__(v39, 11) ^ __ROR4__(v39, 6) ^ __ROR4__(v39, 25));
  v42 = (__ROR4__(v40, 13) ^ __ROR4__(v40, 2) ^ __ROR4__(v40, 22)) + ((v37 | v40) & v34 | v37 & v40) + v41;
  v43 = v31 + v41;
  v44 = ((v36 ^ v39) & v43 ^ v36) + v251 + 1925078388 + v33 + (__ROR4__(v43, 11) ^ __ROR4__(v43, 6) ^ __ROR4__(v43, 25));
  v45 = (__ROR4__(v42, 13) ^ __ROR4__(v42, 2) ^ __ROR4__(v42, 22)) + ((v40 | v42) & v37 | v40 & v42) + v44;
  v46 = v34 + v44;
  v47 = ((v39 ^ v43) & v46 ^ v39) + v254 - 2132889090 + v36 + (__ROR4__(v46, 11) ^ __ROR4__(v46, 6) ^ __ROR4__(v46, 25));
  v48 = v37 + v47;
  v49 = (__ROR4__(v45, 13) ^ __ROR4__(v45, 2) ^ __ROR4__(v45, 22)) + ((v42 | v45) & v40 | v42 & v45) + v47;
  v50 = ((v43 ^ v46) & v48 ^ v43) + v222 - 1680079193 + v39 + (__ROR4__(v48, 11) ^ __ROR4__(v48, 6) ^ __ROR4__(v48, 25));
  v51 = (__ROR4__(v49, 13) ^ __ROR4__(v49, 2) ^ __ROR4__(v49, 22)) + ((v45 | v49) & v42 | v45 & v49) + v50;
  v52 = v40 + v50;
  v53 = ((v46 ^ v48) & v52 ^ v46) + v206 - 1046744716 + v43 + (__ROR4__(v52, 11) ^ __ROR4__(v52, 6) ^ __ROR4__(v52, 25));
  v54 = v42 + v53;
  v210 = (__ROR4__(v222, 19) ^ __ROR4__(v222, 17) ^ (v222 >> 10))
       + v225
       + v212
       + (__ROR4__(v209, 18) ^ __ROR4__(v209, 7) ^ (v209 >> 3));
  v235 = (__ROR4__(v51, 13) ^ __ROR4__(v51, 2) ^ __ROR4__(v51, 22)) + ((v49 | v51) & v45 | v49 & v51) + v53;
  v55 = ((v48 ^ v52) & v54 ^ v48) + v210 - 459576895 + v46 + (__ROR4__(v54, 11) ^ __ROR4__(v54, 6) ^ __ROR4__(v54, 25));
  v56 = v45 + v55;
  v57 = (__ROR4__(v235, 13) ^ __ROR4__(v235, 2) ^ __ROR4__(v235, 22)) + ((v51 | v235) & v49 | v51 & v235) + v55;
  v58 = (__ROR4__(v206, 19) ^ __ROR4__(v206, 17) ^ (v206 >> 10))
      + v268
      + (__ROR4__(v260, 18) ^ __ROR4__(v260, 7) ^ (v260 >> 3));
  v59 = ((v52 ^ v54) & (v45 + v55) ^ v52)
      + v58
      - 272742522
      + v48
      + (__ROR4__(v45 + v55, 11) ^ __ROR4__(v45 + v55, 6) ^ __ROR4__(v45 + v55, 25));
  v60 = v49 + v59;
  v61 = (__ROR4__(v57, 13) ^ __ROR4__(v57, 2) ^ __ROR4__(v57, 22)) + ((v235 | v57) & v51 | v235 & v57) + v59;
  v226 = (__ROR4__(v230, 18) ^ __ROR4__(v230, 7) ^ (v230 >> 3))
       + v260
       + v218
       + (__ROR4__(v210, 19) ^ __ROR4__(v210, 17) ^ (v210 >> 10));
  v62 = ((v54 ^ v56) & v60 ^ v54)
      + v226
      + 264347078
      + v52
      + (__ROR4__(v49 + v59, 11) ^ __ROR4__(v60, 6) ^ __ROR4__(v60, 25));
  v63 = v51 + v62;
  v64 = (__ROR4__(v61, 13) ^ __ROR4__(v61, 2) ^ __ROR4__(v61, 22)) + ((v57 | v61) & v235 | v57 & v61) + v62;
  v261 = v58;
  v231 = (__ROR4__(v264, 18) ^ __ROR4__(v264, 7) ^ (v264 >> 3))
       + v230
       + v251
       + (__ROR4__(v58, 19) ^ __ROR4__(v58, 17) ^ (v58 >> 10));
  v65 = ((v56 ^ v60) & v63 ^ v56) + v231 + 604807628 + v54 + (__ROR4__(v63, 11) ^ __ROR4__(v63, 6) ^ __ROR4__(v63, 25));
  v66 = (__ROR4__(v64, 13) ^ __ROR4__(v64, 2) ^ __ROR4__(v64, 22)) + ((v61 | v64) & v57 | v61 & v64) + v65;
  v67 = v235 + v65;
  v236 = (__ROR4__(v239, 18) ^ __ROR4__(v239, 7) ^ (v239 >> 3))
       + v264
       + v254
       + (__ROR4__(v226, 19) ^ __ROR4__(v226, 17) ^ (v226 >> 10));
  v68 = ((v60 ^ v63) & v67 ^ v60) + v236 + 770255983 + v56 + (__ROR4__(v67, 11) ^ __ROR4__(v67, 6) ^ __ROR4__(v67, 25));
  v69 = v57 + v68;
  v70 = (__ROR4__(v66, 13) ^ __ROR4__(v66, 2) ^ __ROR4__(v66, 22)) + ((v64 | v66) & v61 | v64 & v66) + v68;
  v240 = (__ROR4__(v257, 18) ^ __ROR4__(v257, 7) ^ (v257 >> 3))
       + v239
       + v222
       + (__ROR4__(v231, 19) ^ __ROR4__(v231, 17) ^ (v231 >> 10));
  v71 = ((v63 ^ v67) & (v57 + v68) ^ v63)
      + v240
      + 1249150122
      + v60
      + (__ROR4__(v69, 11) ^ __ROR4__(v69, 6) ^ __ROR4__(v69, 25));
  v72 = v61 + v71;
  v73 = (__ROR4__(v70, 13) ^ __ROR4__(v70, 2) ^ __ROR4__(v70, 22)) + ((v66 | v70) & v64 | v66 & v70) + v71;
  v265 = (__ROR4__(v243, 18) ^ __ROR4__(v243, 7) ^ (v243 >> 3))
       + v257
       + v206
       + (__ROR4__(v236, 19) ^ __ROR4__(v236, 17) ^ (v236 >> 10));
  v74 = ((v67 ^ v69) & v72 ^ v67) + v265 + 1555081692 + v63 + (__ROR4__(v72, 11) ^ __ROR4__(v72, 6) ^ __ROR4__(v72, 25));
  v75 = v64 + v74;
  v76 = (__ROR4__(v73, 13) ^ __ROR4__(v73, 2) ^ __ROR4__(v73, 22)) + ((v70 | v73) & v66 | v70 & v73) + v74;
  v244 = (__ROR4__(v247, 18) ^ __ROR4__(v247, 7) ^ (v247 >> 3))
       + v243
       + v210
       + (__ROR4__(v240, 19) ^ __ROR4__(v240, 17) ^ (v240 >> 10));
  v77 = ((v69 ^ v72) & v75 ^ v69) + v244 + 1996064986 + v67 + (__ROR4__(v75, 11) ^ __ROR4__(v75, 6) ^ __ROR4__(v75, 25));
  v78 = v66 + v77;
  v79 = (__ROR4__(v76, 13) ^ __ROR4__(v76, 2) ^ __ROR4__(v76, 22)) + ((v73 | v76) & v70 | v73 & v76) + v77;
  v80 = (__ROR4__(v212, 18) ^ __ROR4__(v212, 7) ^ (v212 >> 3))
      + v247
      + v58
      + (__ROR4__(v265, 19) ^ __ROR4__(v265, 17) ^ (v265 >> 10));
  v81 = ((v72 ^ v75) & v78 ^ v72) + v80 - 1740746414 + v69 + (__ROR4__(v78, 11) ^ __ROR4__(v78, 6) ^ __ROR4__(v78, 25));
  v82 = v70 + v81;
  v83 = (__ROR4__(v79, 13) ^ __ROR4__(v79, 2) ^ __ROR4__(v79, 22)) + ((v76 | v79) & v73 | v76 & v79) + v81;
  v248 = (__ROR4__(v215, 18) ^ __ROR4__(v215, 7) ^ (v215 >> 3))
       + v212
       + v226
       + (__ROR4__(v244, 19) ^ __ROR4__(v244, 17) ^ (v244 >> 10));
  v269 = v80;
  v84 = ((v75 ^ v78) & v82 ^ v75) + v248 - 1473132947 + v72 + (__ROR4__(v82, 11) ^ __ROR4__(v82, 6) ^ __ROR4__(v82, 25));
  v85 = (__ROR4__(v83, 13) ^ __ROR4__(v83, 2) ^ __ROR4__(v83, 22)) + ((v79 | v83) & v76 | v79 & v83) + v84;
  v86 = v73 + v84;
  v216 = (__ROR4__(v218, 18) ^ __ROR4__(v218, 7) ^ (v218 >> 3))
       + v215
       + v231
       + (__ROR4__(v80, 19) ^ __ROR4__(v80, 17) ^ (v80 >> 10));
  v87 = ((v78 ^ v82) & v86 ^ v78) + v216 - 1341970488 + v75 + (__ROR4__(v86, 11) ^ __ROR4__(v86, 6) ^ __ROR4__(v86, 25));
  v88 = v76 + v87;
  v89 = (__ROR4__(v85, 13) ^ __ROR4__(v85, 2) ^ __ROR4__(v85, 22)) + ((v83 | v85) & v79 | v83 & v85) + v87;
  v219 = (__ROR4__(v251, 18) ^ __ROR4__(v251, 7) ^ (v251 >> 3))
       + v218
       + v236
       + (__ROR4__(v248, 19) ^ __ROR4__(v248, 17) ^ (v248 >> 10));
  v90 = ((v82 ^ v86) & v88 ^ v82) + v219 - 1084653625 + v78 + (__ROR4__(v88, 11) ^ __ROR4__(v88, 6) ^ __ROR4__(v88, 25));
  v91 = (__ROR4__(v89, 13) ^ __ROR4__(v89, 2) ^ __ROR4__(v89, 22)) + ((v85 | v89) & v83 | v85 & v89) + v90;
  v92 = v79 + v90;
  v252 = (__ROR4__(v254, 18) ^ __ROR4__(v254, 7) ^ (v254 >> 3))
       + v251
       + v240
       + (__ROR4__(v216, 19) ^ __ROR4__(v216, 17) ^ (v216 >> 10));
  v93 = ((v86 ^ v88) & v92 ^ v86) + v252 - 958395405 + v82 + (__ROR4__(v92, 11) ^ __ROR4__(v92, 6) ^ __ROR4__(v92, 25));
  v94 = v83 + v93;
  v95 = (__ROR4__(v91, 13) ^ __ROR4__(v91, 2) ^ __ROR4__(v91, 22)) + ((v89 | v91) & v85 | v89 & v91) + v93;
  v213 = (__ROR4__(v222, 18) ^ __ROR4__(v222, 7) ^ (v222 >> 3))
       + v254
       + v265
       + (__ROR4__(v219, 19) ^ __ROR4__(v219, 17) ^ (v219 >> 10));
  v96 = ((v88 ^ v92) & v94 ^ v88) + v213 - 710438585 + v86 + (__ROR4__(v94, 11) ^ __ROR4__(v94, 6) ^ __ROR4__(v94, 25));
  v97 = v85 + v96;
  v98 = (__ROR4__(v95, 13) ^ __ROR4__(v95, 2) ^ __ROR4__(v95, 22)) + ((v91 | v95) & v89 | v91 & v95) + v96;
  v223 = (__ROR4__(v206, 18) ^ __ROR4__(v206, 7) ^ (v206 >> 3))
       + v222
       + v244
       + (__ROR4__(v252, 19) ^ __ROR4__(v252, 17) ^ (v252 >> 10));
  v99 = ((v92 ^ v94) & v97 ^ v92) + v223 + 113926993 + v88 + (__ROR4__(v97, 11) ^ __ROR4__(v97, 6) ^ __ROR4__(v97, 25));
  v100 = v89 + v99;
  v101 = (__ROR4__(v98, 13) ^ __ROR4__(v98, 2) ^ __ROR4__(v98, 22)) + ((v95 | v98) & v91 | v95 & v98) + v99;
  v255 = (__ROR4__(v210, 18) ^ __ROR4__(v210, 7) ^ (v210 >> 3))
       + v206
       + v80
       + (__ROR4__(v213, 19) ^ __ROR4__(v213, 17) ^ (v213 >> 10));
  v102 = ((v94 ^ v97) & v100 ^ v94)
       + v255
       + 338241895
       + v92
       + (__ROR4__(v100, 11) ^ __ROR4__(v100, 6) ^ __ROR4__(v100, 25));
  v103 = v91 + v102;
  v104 = __ROR4__(v91 + v102, 11);
  v105 = (__ROR4__(v101, 13) ^ __ROR4__(v101, 2) ^ __ROR4__(v101, 22)) + ((v98 | v101) & v95 | v98 & v101) + v102;
  v258 = (__ROR4__(v261, 18) ^ __ROR4__(v261, 7) ^ (v261 >> 3))
       + v210
       + v248
       + (__ROR4__(v223, 19) ^ __ROR4__(v223, 17) ^ (v223 >> 10));
  v106 = ((v97 ^ v100) & v103 ^ v97) + v258 + 666307205 + v94 + (v104 ^ __ROR4__(v103, 6) ^ __ROR4__(v103, 25));
  v107 = v95 + v106;
  v108 = (__ROR4__(v105, 13) ^ __ROR4__(v105, 2) ^ __ROR4__(v105, 22)) + ((v101 | v105) & v98 | v101 & v105) + v106;
  v262 = (__ROR4__(v226, 18) ^ __ROR4__(v226, 7) ^ (v226 >> 3))
       + v261
       + v216
       + (__ROR4__(v255, 19) ^ __ROR4__(v255, 17) ^ (v255 >> 10));
  v109 = ((v100 ^ v103) & v107 ^ v100)
       + v262
       + 773529912
       + v97
       + (__ROR4__(v107, 11) ^ __ROR4__(v107, 6) ^ __ROR4__(v107, 25));
  v110 = v98 + v109;
  v111 = (__ROR4__(v108, 13) ^ __ROR4__(v108, 2) ^ __ROR4__(v108, 22)) + ((v105 | v108) & v101 | v105 & v108) + v109;
  v227 = (__ROR4__(v231, 18) ^ __ROR4__(v231, 7) ^ (v231 >> 3))
       + v226
       + v219
       + (__ROR4__(v258, 19) ^ __ROR4__(v258, 17) ^ (v258 >> 10));
  v112 = ((v103 ^ v107) & v110 ^ v103)
       + v227
       + 1294757372
       + v100
       + (__ROR4__(v110, 11) ^ __ROR4__(v110, 6) ^ __ROR4__(v110, 25));
  v113 = v101 + v112;
  v114 = (__ROR4__(v111, 13) ^ __ROR4__(v111, 2) ^ __ROR4__(v111, 22)) + ((v108 | v111) & v105 | v108 & v111) + v112;
  v232 = (__ROR4__(v236, 18) ^ __ROR4__(v236, 7) ^ (v236 >> 3))
       + v231
       + v252
       + (__ROR4__(v262, 19) ^ __ROR4__(v262, 17) ^ (v262 >> 10));
  v115 = ((v107 ^ v110) & v113 ^ v107)
       + v232
       + 1396182291
       + v103
       + (__ROR4__(v113, 11) ^ __ROR4__(v113, 6) ^ __ROR4__(v113, 25));
  v116 = v105 + v115;
  v117 = (__ROR4__(v114, 13) ^ __ROR4__(v114, 2) ^ __ROR4__(v114, 22)) + ((v111 | v114) & v108 | v111 & v114) + v115;
  v237 = (__ROR4__(v240, 18) ^ __ROR4__(v240, 7) ^ (v240 >> 3))
       + v236
       + v213
       + (__ROR4__(v227, 19) ^ __ROR4__(v227, 17) ^ (v227 >> 10));
  v118 = ((v110 ^ v113) & v116 ^ v110)
       + v237
       + 1695183700
       + v107
       + (__ROR4__(v105 + v115, 11) ^ __ROR4__(v105 + v115, 6) ^ __ROR4__(v116, 25));
  v119 = v108 + v118;
  v120 = (__ROR4__(v117, 13) ^ __ROR4__(v117, 2) ^ __ROR4__(v117, 22)) + ((v114 | v117) & v111 | v114 & v117) + v118;
  v241 = (__ROR4__(v265, 18) ^ __ROR4__(v265, 7) ^ (v265 >> 3))
       + v240
       + v223
       + (__ROR4__(v232, 19) ^ __ROR4__(v232, 17) ^ (v232 >> 10));
  v121 = ((v113 ^ (v105 + v115)) & (v108 + v118) ^ v113)
       + v241
       + 1986661051
       + v110
       + (__ROR4__(v108 + v118, 11) ^ __ROR4__(v108 + v118, 6) ^ __ROR4__(v108 + v118, 25));
  v122 = v111 + v121;
  v123 = (__ROR4__(v120, 13) ^ __ROR4__(v120, 2) ^ __ROR4__(v120, 22)) + ((v117 | v120) & v114 | v117 & v120) + v121;
  v266 = (__ROR4__(v244, 18) ^ __ROR4__(v244, 7) ^ (v244 >> 3))
       + v265
       + v255
       + (__ROR4__(v237, 19) ^ __ROR4__(v237, 17) ^ (v237 >> 10));
  v124 = ((v116 ^ (v108 + v118)) & v122 ^ v116)
       + v266
       - 2117940946
       + v113
       + (__ROR4__(v111 + v121, 11) ^ __ROR4__(v122, 6) ^ __ROR4__(v122, 25));
  v125 = v114 + v124;
  v126 = (__ROR4__(v123, 13) ^ __ROR4__(v123, 2) ^ __ROR4__(v123, 22)) + ((v120 | v123) & v117 | v120 & v123) + v124;
  v245 = (__ROR4__(v269, 18) ^ __ROR4__(v269, 7) ^ (v269 >> 3))
       + v244
       + v258
       + (__ROR4__(v241, 19) ^ __ROR4__(v241, 17) ^ (v241 >> 10));
  v127 = ((v119 ^ (v111 + v121)) & v125 ^ v119)
       + v245
       - 1838011259
       + v116
       + (__ROR4__(v114 + v124, 11) ^ __ROR4__(v114 + v124, 6) ^ __ROR4__(v125, 25));
  v128 = (__ROR4__(v126, 13) ^ __ROR4__(v126, 2) ^ __ROR4__(v126, 22)) + ((v123 | v126) & v120 | v123 & v126) + v127;
  v129 = v117 + v127;
  v270 = (__ROR4__(v248, 18) ^ __ROR4__(v248, 7) ^ (v248 >> 3))
       + v269
       + v262
       + (__ROR4__(v266, 19) ^ __ROR4__(v266, 17) ^ (v266 >> 10));
  v130 = ((v122 ^ v125) & (v117 + v127) ^ v122)
       + v270
       - 1564481375
       + v119
       + (__ROR4__(v117 + v127, 11) ^ __ROR4__(v117 + v127, 6) ^ __ROR4__(v117 + v127, 25));
  v131 = v120 + v130;
  v132 = (__ROR4__(v128, 13) ^ __ROR4__(v128, 2) ^ __ROR4__(v128, 22)) + ((v126 | v128) & v123 | v126 & v128) + v130;
  v207 = (__ROR4__(v216, 18) ^ __ROR4__(v216, 7) ^ (v216 >> 3))
       + v248
       + v227
       + (__ROR4__(v245, 19) ^ __ROR4__(v245, 17) ^ (v245 >> 10));
  v133 = ((v125 ^ v129) & v131 ^ v125)
       + v207
       - 1474664885
       + v122
       + (__ROR4__(v131, 11) ^ __ROR4__(v131, 6) ^ __ROR4__(v131, 25));
  v134 = v123 + v133;
  v135 = (__ROR4__(v132, 13) ^ __ROR4__(v132, 2) ^ __ROR4__(v132, 22)) + ((v128 | v132) & v126 | v128 & v132) + v133;
  v249 = (__ROR4__(v219, 18) ^ __ROR4__(v219, 7) ^ (v219 >> 3))
       + v216
       + v232
       + (__ROR4__(v270, 19) ^ __ROR4__(v270, 17) ^ (v270 >> 10));
  v136 = ((v129 ^ v131) & v134 ^ v129)
       + v249
       - 1035236496
       + v125
       + (__ROR4__(v134, 11) ^ __ROR4__(v134, 6) ^ __ROR4__(v134, 25));
  v137 = (__ROR4__(v135, 13) ^ __ROR4__(v135, 2) ^ __ROR4__(v135, 22)) + ((v132 | v135) & v128 | v132 & v135) + v136;
  v220 = (__ROR4__(v252, 18) ^ __ROR4__(v252, 7) ^ (v252 >> 3))
       + v219
       + v237
       + (__ROR4__(v207, 19) ^ __ROR4__(v207, 17) ^ (v207 >> 10));
  v138 = ((v131 ^ v134) & (v126 + v136) ^ v131)
       + v220
       - 949202525
       + v129
       + (__ROR4__(v126 + v136, 11) ^ __ROR4__(v126 + v136, 6) ^ __ROR4__(v126 + v136, 25));
  v139 = (__ROR4__(v137, 13) ^ __ROR4__(v137, 2) ^ __ROR4__(v137, 22)) + ((v135 | v137) & v132 | v135 & v137) + v138;
  v140 = v128 + v138;
  v211 = (__ROR4__(v213, 18) ^ __ROR4__(v213, 7) ^ (v213 >> 3))
       + v252
       + v241
       + (__ROR4__(v249, 19) ^ __ROR4__(v249, 17) ^ (v249 >> 10));
  v141 = ((v134 ^ (v126 + v136)) & v140 ^ v134)
       + v211
       - 778901479
       + v131
       + (__ROR4__(v128 + v138, 11) ^ __ROR4__(v128 + v138, 6) ^ __ROR4__(v140, 25));
  v142 = v132 + v141;
  v143 = (__ROR4__(v139, 13) ^ __ROR4__(v139, 2) ^ __ROR4__(v139, 22)) + ((v137 | v139) & v135 | v137 & v139) + v141;
  v214 = (__ROR4__(v223, 18) ^ __ROR4__(v223, 7) ^ (v223 >> 3))
       + v213
       + v266
       + (__ROR4__(v220, 19) ^ __ROR4__(v220, 17) ^ (v220 >> 10));
  v144 = (((v126 + v136) ^ v140) & v142 ^ (v126 + v136))
       + v214
       - 694614492
       + v134
       + (__ROR4__(v142, 11) ^ __ROR4__(v142, 6) ^ __ROR4__(v142, 25));
  v145 = v135 + v144;
  v146 = (__ROR4__(v143, 13) ^ __ROR4__(v143, 2) ^ __ROR4__(v143, 22)) + ((v139 | v143) & v137 | v139 & v143) + v144;
  v224 = (__ROR4__(v255, 18) ^ __ROR4__(v255, 7) ^ (v255 >> 3))
       + v223
       + v245
       + (__ROR4__(v211, 19) ^ __ROR4__(v211, 17) ^ (v211 >> 10));
  v147 = ((v140 ^ v142) & v145 ^ v140)
       + v224
       - 200395387
       + v126
       + v136
       + (__ROR4__(v145, 11) ^ __ROR4__(v145, 6) ^ __ROR4__(v145, 25));
  v148 = v137 + v147;
  v149 = (__ROR4__(v146, 13) ^ __ROR4__(v146, 2) ^ __ROR4__(v146, 22)) + ((v143 | v146) & v139 | v143 & v146) + v147;
  v217 = (__ROR4__(v258, 18) ^ __ROR4__(v258, 7) ^ (v258 >> 3))
       + v255
       + v270
       + (__ROR4__(v214, 19) ^ __ROR4__(v214, 17) ^ (v214 >> 10));
  v150 = ((v142 ^ v145) & v148 ^ v142)
       + v217
       + 275423344
       + v140
       + (__ROR4__(v148, 11) ^ __ROR4__(v148, 6) ^ __ROR4__(v148, 25));
  v151 = v139 + v150;
  v152 = (__ROR4__(v149, 13) ^ __ROR4__(v149, 2) ^ __ROR4__(v149, 22)) + ((v146 | v149) & v143 | v146 & v149) + v150;
  v253 = (__ROR4__(v262, 18) ^ __ROR4__(v262, 7) ^ (v262 >> 3))
       + v258
       + v207
       + (__ROR4__(v224, 19) ^ __ROR4__(v224, 17) ^ (v224 >> 10));
  v153 = ((v145 ^ v148) & v151 ^ v145)
       + v253
       + 430227734
       + v142
       + (__ROR4__(v151, 11) ^ __ROR4__(v151, 6) ^ __ROR4__(v151, 25));
  v154 = v143 + v153;
  v155 = (__ROR4__(v152, 13) ^ __ROR4__(v152, 2) ^ __ROR4__(v152, 22)) + ((v149 | v152) & v146 | v149 & v152) + v153;
  v256 = (__ROR4__(v227, 18) ^ __ROR4__(v227, 7) ^ (v227 >> 3))
       + v262
       + v249
       + (__ROR4__(v217, 19) ^ __ROR4__(v217, 17) ^ (v217 >> 10));
  v156 = ((v148 ^ v151) & v154 ^ v148)
       + v256
       + 506948616
       + v145
       + (__ROR4__(v154, 11) ^ __ROR4__(v154, 6) ^ __ROR4__(v154, 25));
  v157 = (__ROR4__(v155, 13) ^ __ROR4__(v155, 2) ^ __ROR4__(v155, 22)) + ((v152 | v155) & v149 | v152 & v155) + v156;
  v158 = v146 + v156;
  v259 = (__ROR4__(v232, 18) ^ __ROR4__(v232, 7) ^ (v232 >> 3))
       + v227
       + v220
       + (__ROR4__(v253, 19) ^ __ROR4__(v253, 17) ^ (v253 >> 10));
  v159 = ((v151 ^ v154) & v158 ^ v151)
       + v259
       + 659060556
       + v148
       + (__ROR4__(v158, 11) ^ __ROR4__(v158, 6) ^ __ROR4__(v158, 25));
  v160 = v149 + v159;
  v161 = (__ROR4__(v157, 13) ^ __ROR4__(v157, 2) ^ __ROR4__(v157, 22)) + ((v155 | v157) & v152 | v155 & v157) + v159;
  v263 = (__ROR4__(v237, 18) ^ __ROR4__(v237, 7) ^ (v237 >> 3))
       + v232
       + v211
       + (__ROR4__(v256, 19) ^ __ROR4__(v256, 17) ^ (v256 >> 10));
  v162 = ((v154 ^ v158) & v160 ^ v154)
       + v263
       + 883997877
       + v151
       + (__ROR4__(v160, 11) ^ __ROR4__(v160, 6) ^ __ROR4__(v160, 25));
  v163 = v152 + v162;
  v164 = (__ROR4__(v161, 13) ^ __ROR4__(v161, 2) ^ __ROR4__(v161, 22)) + ((v157 | v161) & v155 | v157 & v161) + v162;
  v272 = (__ROR4__(v241, 18) ^ __ROR4__(v241, 7) ^ (v241 >> 3))
       + v237
       + v214
       + (__ROR4__(v259, 19) ^ __ROR4__(v259, 17) ^ (v259 >> 10));
  v165 = ((v158 ^ v160) & v163 ^ v158)
       + v272
       + 958139571
       + v154
       + (__ROR4__(v163, 11) ^ __ROR4__(v163, 6) ^ __ROR4__(v163, 25));
  v166 = v155 + v165;
  v167 = (__ROR4__(v164, 13) ^ __ROR4__(v164, 2) ^ __ROR4__(v164, 22)) + ((v161 | v164) & v157 | v161 & v164) + v165;
  v273 = (__ROR4__(v266, 18) ^ __ROR4__(v266, 7) ^ (v266 >> 3))
       + v241
       + v224
       + (__ROR4__(v263, 19) ^ __ROR4__(v263, 17) ^ (v263 >> 10));
  v168 = ((v160 ^ v163) & v166 ^ v160)
       + v273
       + 1322822218
       + v158
       + (__ROR4__(v166, 11) ^ __ROR4__(v166, 6) ^ __ROR4__(v166, 25));
  v169 = v157 + v168;
  v170 = (__ROR4__(v167, 13) ^ __ROR4__(v167, 2) ^ __ROR4__(v167, 22)) + ((v164 | v167) & v161 | v164 & v167) + v168;
  v267 = (__ROR4__(v245, 18) ^ __ROR4__(v245, 7) ^ (v245 >> 3))
       + v266
       + v217
       + (__ROR4__(v272, 19) ^ __ROR4__(v272, 17) ^ (v272 >> 10));
  v171 = ((v163 ^ v166) & v169 ^ v163)
       + v267
       + 1537002063
       + v160
       + (__ROR4__(v169, 11) ^ __ROR4__(v169, 6) ^ __ROR4__(v169, 25));
  v172 = v161 + v171;
  v173 = (__ROR4__(v170, 13) ^ __ROR4__(v170, 2) ^ __ROR4__(v170, 22)) + ((v167 | v170) & v164 | v167 & v170) + v171;
  v233 = (__ROR4__(v270, 18) ^ __ROR4__(v270, 7) ^ (v270 >> 3))
       + v245
       + v253
       + (__ROR4__(v273, 19) ^ __ROR4__(v273, 17) ^ (v273 >> 10));
  v174 = ((v166 ^ v169) & v172 ^ v166)
       + v233
       + 1747873779
       + v163
       + (__ROR4__(v172, 11) ^ __ROR4__(v172, 6) ^ __ROR4__(v172, 25));
  v175 = v164 + v174;
  v228 = (__ROR4__(v173, 13) ^ __ROR4__(v173, 2) ^ __ROR4__(v173, 22)) + ((v170 | v173) & v167 | v170 & v173) + v174;
  v238 = (__ROR4__(v207, 18) ^ __ROR4__(v207, 7) ^ (v207 >> 3))
       + v270
       + v256
       + (__ROR4__(v267, 19) ^ __ROR4__(v267, 17) ^ (v267 >> 10));
  v176 = ((v169 ^ v172) & v175 ^ v169)
       + v238
       + 1955562222
       + v166
       + (__ROR4__(v175, 11) ^ __ROR4__(v175, 6) ^ __ROR4__(v175, 25));
  v177 = (__ROR4__(v249, 18) ^ __ROR4__(v249, 7) ^ (v249 >> 3)) + v207;
  v208 = (__ROR4__(v228, 13) ^ __ROR4__(v228, 2) ^ __ROR4__(v228, 22)) + ((v173 | v228) & v170 | v173 & v228) + v176;
  v178 = v177 + v259 + (__ROR4__(v233, 19) ^ __ROR4__(v233, 17) ^ (v233 >> 10));
  v242 = v167 + v176;
  v179 = ((v172 ^ v175) & v242 ^ v172)
       + v178
       + 2024104815
       + v169
       + (__ROR4__(v242, 11) ^ __ROR4__(v242, 6) ^ __ROR4__(v242, 25));
  v180 = v170 + v179;
  v181 = (__ROR4__(v208, 13) ^ __ROR4__(v208, 2) ^ __ROR4__(v208, 22)) + ((v228 | v208) & v173 | v228 & v208) + v179;
  v182 = (__ROR4__(v220, 18) ^ __ROR4__(v220, 7) ^ (v220 >> 3))
       + v249
       + v263
       + (__ROR4__(v238, 19) ^ __ROR4__(v238, 17) ^ (v238 >> 10));
  v183 = ((v175 ^ v242) & (v170 + v179) ^ v175)
       + v182
       - 2067236844
       + v172
       + (__ROR4__(v170 + v179, 11) ^ __ROR4__(v170 + v179, 6) ^ __ROR4__(v170 + v179, 25));
  v184 = v173 + v183;
  v185 = (__ROR4__(v181, 13) ^ __ROR4__(v181, 2) ^ __ROR4__(v181, 22)) + ((v208 | v181) & v228 | v208 & v181) + v183;
  v186 = (__ROR4__(v211, 18) ^ __ROR4__(v211, 7) ^ (v211 >> 3))
       + v220
       + v272
       + (__ROR4__(v178, 19) ^ __ROR4__(v178, 17) ^ (v178 >> 10));
  v187 = ((v242 ^ (v170 + v179)) & v184 ^ v242)
       + v186
       - 1933114872
       + v175
       + (__ROR4__(v184, 11) ^ __ROR4__(v184, 6) ^ __ROR4__(v184, 25));
  v246 = __ROR4__(v186, 19) ^ __ROR4__(v186, 17) ^ (v186 >> 10);
  v188 = v228;
  v189 = (__ROR4__(v185, 13) ^ __ROR4__(v185, 2) ^ __ROR4__(v185, 22)) + ((v181 | v185) & v208 | v181 & v185) + v187;
  v229 = v180;
  v190 = v188 + v187;
  v191 = (__ROR4__(v214, 18) ^ __ROR4__(v214, 7) ^ (v214 >> 3))
       + v211
       + v273
       + (__ROR4__(v182, 19) ^ __ROR4__(v182, 17) ^ (v182 >> 10));
  v192 = ((v180 ^ v184) & v190 ^ v180)
       + v191
       - 1866530822
       + v242
       + (__ROR4__(v190, 11) ^ __ROR4__(v190, 6) ^ __ROR4__(v190, 25));
  v193 = (__ROR4__(v189, 13) ^ __ROR4__(v189, 2) ^ __ROR4__(v189, 22)) + ((v185 | v189) & v181 | v185 & v189) + v192;
  v194 = v208 + v192;
  v195 = (__ROR4__(v224, 18) ^ __ROR4__(v224, 7) ^ (v224 >> 3)) + v214 + v267 + v246;
  v196 = ((v184 ^ v190) & v194 ^ v184)
       + v195
       - 1538233109
       + v229
       + (__ROR4__(v194, 11) ^ __ROR4__(v194, 6) ^ __ROR4__(v194, 25));
  v197 = v181 + v196;
  v198 = (__ROR4__(v193, 13) ^ __ROR4__(v193, 2) ^ __ROR4__(v193, 22)) + ((v189 | v193) & v185 | v189 & v193) + v196;
  v199 = (__ROR4__(v217, 18) ^ __ROR4__(v217, 7) ^ (v217 >> 3))
       + v224
       - 1090935817
       + v233
       + (__ROR4__(v191, 19) ^ __ROR4__(v191, 17) ^ (v191 >> 10))
       + v184
       + ((v190 ^ (v208 + v192)) & v197 ^ v190)
       + (__ROR4__(v197, 11) ^ __ROR4__(v197, 6) ^ __ROR4__(v197, 25));
  v200 = (__ROR4__(v198, 13) ^ __ROR4__(v198, 2) ^ __ROR4__(v198, 22)) + ((v193 | v198) & v189 | v193 & v198) + v199;
  v201 = v185 + v199;
  v202 = (__ROR4__(v253, 18) ^ __ROR4__(v253, 7) ^ (v253 >> 3))
       + v217
       - 965641998
       + v238
       + (__ROR4__(v195, 19) ^ __ROR4__(v195, 17) ^ (v195 >> 10))
       + v190
       + ((v194 ^ v197) & v201 ^ v194)
       + (__ROR4__(v201, 11) ^ __ROR4__(v201, 6) ^ __ROR4__(v201, 25));
  v203 = (__ROR4__(v200, 13) ^ __ROR4__(v200, 2) ^ __ROR4__(v200, 22))
       + ((v198 | v200) & v193 | v198 & v200)
       + v274
       + v202;
  result = v276 + v198;
  block[9] = v280 + v194;
  block[5] = v277 + v193;
  block[8] = v279 + v197;
  block[4] = result;
  block[3] = v275 + v200;
  block[7] = v278 + v201;
  block[2] = v203;
  block[6] = v271 + v189 + v202;
  return result;
}

//----- (000231A4) --------------------------------------------------------
int *__fastcall update_hash_buffer(int *hash_buffer_ptr, unsigned int *input_data, signed int input_length)
{
  signed int remaining_length; // r5
  int first_block_value; // r3
  int *hash_buffer_ptr_copy; // r6
  unsigned int *input_data_current; // r4
  bool carry_flag; // cf
  int new_buffer_length; // r2
  int current_buffer_offset; // r8
  signed int space_in_block; // r7
  _BOOL4 can_copy_directly; // r3
  unsigned int remaining_blocks_length; // r5
  unsigned int *end_data_block_pointer; // r7
  unsigned int *current_data_block; // r1
  unsigned int *start_of_buffer; // r9

  remaining_length = input_length;
  first_block_value = *hash_buffer_ptr;
  hash_buffer_ptr_copy = hash_buffer_ptr;
  input_data_current = input_data;
  carry_flag = __CFADD__(*hash_buffer_ptr, input_length);
  new_buffer_length = *hash_buffer_ptr + input_length;
  current_buffer_offset = *hash_buffer_ptr & 0x3F;
  if ( carry_flag )
    first_block_value = hash_buffer_ptr[1];
  space_in_block = 64 - current_buffer_offset;
  *hash_buffer_ptr = new_buffer_length;
  if ( carry_flag )
    hash_buffer_ptr[1] = first_block_value + 1;
  can_copy_directly = space_in_block <= remaining_length;
  if ( !current_buffer_offset )
    can_copy_directly = 0;
  if ( can_copy_directly )
  {
    start_of_buffer = (unsigned int *)(hash_buffer_ptr + 10);
    remaining_length -= space_in_block;
    memcpy((char *)hash_buffer_ptr + current_buffer_offset + 40, input_data, 64 - current_buffer_offset);
    input_data_current = (unsigned int *)((char *)input_data_current + space_in_block);
    current_buffer_offset = 0;
    hash_buffer_ptr = (int *)process_block(hash_buffer_ptr_copy, start_of_buffer);
  }
  if ( remaining_length > 63 )
  {
    remaining_blocks_length = remaining_length - 64;
    end_data_block_pointer = &input_data_current[16 * (remaining_blocks_length >> 6) + 16];
    do
    {
      current_data_block = input_data_current;
      input_data_current += 16;
      hash_buffer_ptr = (int *)process_block(hash_buffer_ptr_copy, current_data_block);
    }
    while ( input_data_current != end_data_block_pointer );
    remaining_length = remaining_blocks_length - (remaining_blocks_length >> 6 << 6);
  }
  if ( remaining_length > 0 )
    return (int *)memcpy(
                    (char *)hash_buffer_ptr_copy + current_buffer_offset + 40,
                    input_data_current,
                    remaining_length);
  return hash_buffer_ptr;
}

//----- (00023270) --------------------------------------------------------
int *__fastcall check_and_update_hash_buffer(int *hash_buffer, unsigned int *input_data, signed int data_length)
{
  if ( data_length > 0 )
    return update_hash_buffer(hash_buffer, input_data, data_length);
  return hash_buffer;
}

//----- (0002327C) --------------------------------------------------------
int *__fastcall finalize_sha256_state(int sha256_state, _BYTE *hash_output)
{
  unsigned int current_length; // r2
  int length_shifted; // r1
  unsigned int length_bits; // r3
  unsigned int high_length_bits; // r0
  unsigned int middle_length_bits; // r3
  signed int padding_length; // r2
  int *update_hash_result; // r0
  unsigned int length_buffer; // [sp+0h] [bp-18h] BYREF
  char length_buffer_byte1; // [sp+4h] [bp-14h]
  char length_buffer_byte2; // [sp+5h] [bp-13h]
  char length_buffer_byte3; // [sp+6h] [bp-12h]
  char length_buffer_byte4; // [sp+7h] [bp-11h]

  current_length = *(_DWORD *)sha256_state & 0x3F;
  length_shifted = *(_QWORD *)sha256_state >> 29;
  length_bits = 8 * *(_DWORD *)sha256_state;
  length_buffer_byte4 = 8 * *(_BYTE *)sha256_state;
  length_buffer_byte1 = HIBYTE(length_bits);
  HIBYTE(length_buffer) = length_shifted;
  BYTE1(length_buffer) = BYTE2(length_shifted);
  high_length_bits = HIWORD(length_bits);
  middle_length_bits = length_bits >> 8;
  BYTE2(length_buffer) = BYTE1(length_shifted);
  length_buffer_byte2 = high_length_bits;
  if ( current_length > 55 )
    padding_length = 120 - current_length;
  else
    padding_length = 56 - current_length;
  length_buffer_byte3 = middle_length_bits;
  LOBYTE(length_buffer) = HIBYTE(length_shifted);
  update_hash_buffer((int *)sha256_state, dword_62768, padding_length);
  update_hash_result = update_hash_buffer((int *)sha256_state, &length_buffer, 8);
  *hash_output = *(_BYTE *)(sha256_state + 11);
  hash_output[1] = *(_WORD *)(sha256_state + 10);
  hash_output[2] = BYTE1(*(_DWORD *)(sha256_state + 8));
  hash_output[3] = *(_DWORD *)(sha256_state + 8);
  hash_output[4] = *(_BYTE *)(sha256_state + 15);
  hash_output[5] = *(_WORD *)(sha256_state + 14);
  hash_output[6] = BYTE1(*(_DWORD *)(sha256_state + 12));
  hash_output[7] = *(_DWORD *)(sha256_state + 12);
  hash_output[8] = *(_BYTE *)(sha256_state + 19);
  hash_output[9] = *(_WORD *)(sha256_state + 18);
  hash_output[10] = BYTE1(*(_DWORD *)(sha256_state + 16));
  hash_output[11] = *(_DWORD *)(sha256_state + 16);
  hash_output[12] = *(_BYTE *)(sha256_state + 23);
  hash_output[13] = *(_WORD *)(sha256_state + 22);
  hash_output[14] = BYTE1(*(_DWORD *)(sha256_state + 20));
  hash_output[15] = *(_DWORD *)(sha256_state + 20);
  hash_output[16] = *(_BYTE *)(sha256_state + 27);
  hash_output[17] = *(_WORD *)(sha256_state + 26);
  hash_output[18] = BYTE1(*(_DWORD *)(sha256_state + 24));
  hash_output[19] = *(_DWORD *)(sha256_state + 24);
  hash_output[20] = *(_BYTE *)(sha256_state + 31);
  hash_output[21] = *(_WORD *)(sha256_state + 30);
  hash_output[22] = BYTE1(*(_DWORD *)(sha256_state + 28));
  hash_output[23] = *(_DWORD *)(sha256_state + 28);
  hash_output[24] = *(_BYTE *)(sha256_state + 35);
  hash_output[25] = *(_WORD *)(sha256_state + 34);
  hash_output[26] = BYTE1(*(_DWORD *)(sha256_state + 32));
  hash_output[27] = *(_DWORD *)(sha256_state + 32);
  hash_output[28] = *(_BYTE *)(sha256_state + 39);
  hash_output[29] = *(_WORD *)(sha256_state + 38);
  hash_output[30] = BYTE1(*(_DWORD *)(sha256_state + 36));
  hash_output[31] = *(_DWORD *)(sha256_state + 36);
  return update_hash_result;
}
// 62768: using guessed type unsigned int dword_62768[16];

//----- (00023430) --------------------------------------------------------
int *__fastcall compute_sha256_hash(unsigned int *input_buffer, signed int input_length, _BYTE *output_hash)
{
  int hash_state[62]; // [sp+0h] [bp-F8h] BYREF

  hash_state[2] = 1779033703;
  hash_state[4] = 1013904242;
  hash_state[5] = -1521486534;
  hash_state[6] = 1359893119;
  hash_state[7] = -1694144372;
  hash_state[3] = -1150833019;
  hash_state[8] = 528734635;
  hash_state[9] = 1541459225;
  hash_state[0] = 0;
  hash_state[1] = 0;
  if ( input_length > 0 )
    update_hash_buffer(hash_state, input_buffer, input_length);
  return finalize_sha256_state((int)hash_state, output_hash);
}

//----- (000234D8) --------------------------------------------------------
int __fastcall get_mining_status_description(char *buffer, size_t buffer_size, int status_code)
{
  int mining_status; // r0
  int *global_config_pointer; // r0

  mining_status = get_global_state_flag();
  if ( mining_status )
  {
    if ( mining_status == 1 )
    {
      global_config_pointer = get_global_config_pointer();
      snprintf(buffer, buffer_size, "%s:%s", "searchfailed", (const char *)global_config_pointer);
    }
    else
    {
      snprintf(buffer, buffer_size, "searching");
    }
    return 0;
  }
  else
  {
    snprintf(buffer, buffer_size, "%d", status_code);
    return 0;
  }
}

//----- (00023574) --------------------------------------------------------
int __fastcall processMinerCommand(const char *commandStr, char *responseBuffer, size_t responseBufferSize)
{
  double tempValue; // d0
  char *parsedCommand; // r9
  int v8; // r4
  int logFlag; // r0
  int tempRead; // r0
  int r0; // r0
  int chainIndex; // r8
  int i; // r4
  int nonceChainCount; // r9
  int coreIndex; // r11
  unsigned int chainCount; // r8
  int responseLen; // r5
  char *token; // r0
  int r10_1; // r10
  char *coreRegToken; // r0
  int regValue; // r9
  char *endPtr; // r0
  int resetCoreResult; // r0
  int resetChain; // r7
  int resetAsic; // r0
  int resetToken; // r0
  char *asicNum; // r0
  int chainId; // r9
  char *remainingSize; // r0
  int r10; // r10
  char *v32; // r0
  int v33; // r0
  int v34; // r11
  int v35; // r8
  char *v36; // r0
  int v37; // r7
  char *v38; // r0
  int v39; // r0
  int v40; // r9
  size_t remainingBytes; // r1
  char *respPtr; // r0
  int tokenInt; // r10
  unsigned int asicIndex; // r4
  unsigned int v45; // r6
  int asic_register_value; // r0
  int v47; // r7
  int global_value; // r0
  int v49; // r1
  int v50; // r1
  unsigned int v51; // r0
  int v52; // r7
  size_t v53; // r1
  char *v54; // r0
  int j; // r7
  char *k; // r9
  int v57; // r0
  int v58; // [sp+0h] [bp-CB0h]
  char *v59; // [sp+0h] [bp-CB0h]
  int v60; // [sp+4h] [bp-CACh]
  char *global_variable_value; // [sp+3Ch] [bp-C74h]
  char *miner_status_flag; // [sp+3Ch] [bp-C74h]
  char *flushPtr; // [sp+40h] [bp-C70h]
  size_t adcResponseLen; // [sp+44h] [bp-C6Ch]
  __int16 v65; // [sp+5Ch] [bp-C54h] BYREF
  _DWORD delim[256]; // [sp+60h] [bp-C50h] BYREF
  int logBuffer[512]; // [sp+460h] [bp-850h] BYREF

  parsedCommand = (char *)(commandStr + 4);
  v8 = strncmp(commandStr + 4, "/rate", 5u);
  if ( !v8 )
  {
    if ( logEnabled && (loggingDebug || loggingVerbose || loggingThreshold > 6) )
    {
      strcpy((char *)logBuffer, "cmd : get rate");
      logMessage(7, (const char *)logBuffer, 0);
    }
    logFlag = find_optimal_hash_rate();
    get_mining_status_description(responseBuffer, responseBufferSize, logFlag);
    return v8;
  }
  v8 = strncmp(parsedCommand, "/ideal_rate", 11u);
  if ( !v8 )
  {
    if ( logEnabled && (loggingDebug || loggingVerbose || loggingThreshold > 6) )
    {
      strcpy((char *)logBuffer, "cmd : get ideal rate");
      logMessage(7, (const char *)logBuffer, 0);
    }
    tempRead = calculate_ideal_hash_rate();
    get_mining_status_description(responseBuffer, responseBufferSize, tempRead);
    return v8;
  }
  v8 = strncmp(parsedCommand, "/max_rate", 9u);
  if ( !v8 )
  {
    if ( logEnabled && (loggingDebug || loggingVerbose || loggingThreshold > 6) )
    {
      strcpy((char *)logBuffer, "cmd : get max rate");
      logMessage(7, (const char *)logBuffer, 0);
    }
    r0 = calculate_max_hash_rate();
    get_mining_status_description(responseBuffer, responseBufferSize, r0);
    return v8;
  }
  v8 = strncmp(parsedCommand, "/miner_status", 13u);
  if ( !v8 )
  {
    if ( logEnabled && (loggingDebug || loggingVerbose || loggingThreshold > 6) )
    {
      strcpy((char *)logBuffer, "cmd : get miner status");
      logMessage(7, (const char *)logBuffer, 0);
      return v8;
    }
    return 0;
  }
  v8 = strncmp(parsedCommand, "/productName", 12u);
  if ( v8 )
  {
    v8 = strncmp(parsedCommand, "/get_sn", 7u);
    if ( !v8 )
    {
      if ( logEnabled && (loggingDebug || loggingVerbose || loggingThreshold > 6) )
      {
        strcpy((char *)logBuffer, "cmd : get miner sn");
        logMessage(7, (const char *)logBuffer, 0);
      }
      if ( byte_7F8F8 )
        snprintf(responseBuffer, 256u, "%s", &byte_7F8F8);
      else
        strcpy(responseBuffer, "no miner sn stored on board");
      return v8;
    }
    v8 = strncmp(parsedCommand, "/set_sn", 7u);
    if ( !v8 )
    {
      if ( loggingDebug || loggingVerbose || loggingThreshold > 4 )
      {
        strcpy((char *)logBuffer, "cmd : set miner sn, doesn't spport");
        logMessage(5, (const char *)logBuffer, 0);
      }
      snprintf(responseBuffer, 20u, "doesn't support sn set in Release mode");
      return v8;
    }
    v8 = strncmp(parsedCommand, "/readreg", 8u);
    if ( v8 )
    {
      v8 = strncmp(parsedCommand, "/readcorereg", 12u);
      if ( v8 )
      {
        v8 = strncmp(parsedCommand, "/resetcore", 10u);
        if ( v8 )
        {
          if ( !strncmp(parsedCommand, "/nonce", 6u) )
          {
            nonceChainCount = 0;
            coreIndex = 0;
            memset(logBuffer, 0, 256u);
            chainCount = 0;
            flushPtr = responseBuffer;
            responseLen = 0;
            adcResponseLen = responseBufferSize;
            do
            {
              if ( get_global_buffer_value(chainCount) )
              {
                remainingBytes = adcResponseLen - responseLen;
                respPtr = &flushPtr[responseLen];
                responseLen += 36;
                snprintf(respPtr, remainingBytes, "\n asic nonce number for chain[%d]...\n", chainCount);
                tokenInt = get_global_variable_value();
                if ( tokenInt )
                {
                  asicIndex = 0;
                  do
                  {
                    coreIndex += get_asic_register_value(chainCount, asicIndex);
                    v45 = asicIndex + 1;
                    asic_register_value = get_asic_register_value(chainCount, asicIndex);
                    v47 = snprintf(
                            (char *)logBuffer + nonceChainCount,
                            256 - nonceChainCount,
                            "asic[%03d]=%-8d ",
                            asicIndex,
                            asic_register_value);
                    global_value = get_global_value();
                    calculate_difficulty_ratio(asicIndex + 1, global_value);
                    nonceChainCount += v47;
                    if ( !v49 )
                    {
                      v50 = get_global_value();
                      v51 = calculate_bit_difficulty(asicIndex, v50);
                      v60 = coreIndex;
                      coreIndex = 0;
                      nonceChainCount = 0;
                      responseLen += snprintf(
                                       &flushPtr[responseLen],
                                       adcResponseLen - responseLen,
                                       "domain %02d %s total=%-8u\n",
                                       v51,
                                       logBuffer,
                                       v60);
                    }
                    ++asicIndex;
                  }
                  while ( v45 != tokenInt );
                }
              }
              ++chainCount;
            }
            while ( chainCount != 4 );
            return 0;
          }
          if ( !strncmp(parsedCommand, "/adc", 4u) )
          {
            chainIndex = 0;
            for ( i = 0; i != 4; ++i )
            {
              if ( get_global_buffer_value(i) )
              {
                v53 = responseBufferSize - chainIndex;
                v54 = &responseBuffer[chainIndex];
                chainIndex += 23;
                snprintf(v54, v53, "\t\t\td0\td1\td2\td3\tsum\tavg\n");
                global_variable_value = (char *)get_global_variable_value();
                if ( global_variable_value )
                {
                  for ( j = 0; (char *)j != global_variable_value; ++j )
                  {
                    sub_3F92C();
                    sub_3F92C();
                    sub_3F92C();
                    sub_3F92C();
                    calculate_average(i, j);
                    calculate_average_temperature(i, j);
                    v58 = j;
                    chainIndex += snprintf(
                                    &responseBuffer[chainIndex],
                                    responseBufferSize - chainIndex,
                                    "chain %2d asic %03d adc:\t%.2f\t%.2f\t%.2f\t%.2f\t%.2f\t%.2f\n",
                                    i,
                                    v58,
                                    tempValue,
                                    tempValue,
                                    tempValue,
                                    tempValue,
                                    tempValue,
                                    tempValue);
                  }
                }
              }
            }
            return 0;
          }
          v8 = strncmp(parsedCommand, "/flush", 6u);
          if ( !v8 )
          {
            enable_register_bit();
            return v8;
          }
          v8 = strncmp(parsedCommand, "/power", 6u);
          if ( v8 )
            return -1;
          logBuffer[0] = 0;
          if ( _isoc99_sscanf(parsedCommand, "/power-%d", logBuffer) == 1 )
          {
            v52 = logBuffer[0];
            if ( logBuffer[0] <= 3 )
            {
              readASICVoltage(logBuffer[0]);
              snprintf(responseBuffer, responseBufferSize, "chain %d power is %.2f", v52, tempValue);
              return v8;
            }
          }
LABEL_74:
          snprintf(responseBuffer, responseBufferSize, "404 not found");
          return v8;
        }
        strcpy((char *)delim, "-");
        if ( !strtok(parsedCommand, (const char *)delim) )
          goto LABEL_74;
        v36 = strtok(0, (const char *)delim);
        if ( !v36 )
          goto LABEL_74;
        v37 = strtol(v36, 0, 10);
        v38 = strtok(0, (const char *)delim);
        if ( !v38 )
          goto LABEL_74;
        v39 = strtol(v38, 0, 10);
        v40 = v39;
        if ( loggingDebug || loggingVerbose || loggingThreshold > 4 )
        {
          snprintf((char *)logBuffer, 2048u, "recvBuf = %s, chain = %d, asic = %d\n", commandStr, v37, v39);
          logMessage(5, (const char *)logBuffer, 0);
        }
        snprintf(responseBuffer, responseBufferSize, "reset chain %d asic %d core success!!!.", v37, v40);
      }
      else
      {
        v65 = 45;
        memset(delim, 0, sizeof(delim));
        if ( !strtok(parsedCommand, (const char *)&v65) )
          goto LABEL_74;
        asicNum = strtok(0, (const char *)&v65);
        if ( !asicNum )
          goto LABEL_74;
        chainId = strtol(asicNum, 0, 10);
        remainingSize = strtok(0, (const char *)&v65);
        if ( !remainingSize )
          goto LABEL_74;
        r10 = strtol(remainingSize, 0, 10);
        v32 = strtok(0, (const char *)&v65);
        if ( !v32 )
          goto LABEL_74;
        v33 = strtol(v32, 0, 16);
        v34 = v33;
        if ( loggingDebug || loggingVerbose || loggingThreshold > 4 )
        {
          snprintf(
            (char *)logBuffer,
            2048u,
            "recvBuf = %s, chain = %d, asic = %d, reg = 0x%x\n",
            commandStr,
            chainId,
            r10,
            v33);
          logMessage(5, (const char *)logBuffer, 0);
        }
        v35 = handleASICCommand(v34, r10, chainId, (int)delim);
        if ( v35 )
        {
          snprintf(responseBuffer, responseBufferSize, "500 server error");
        }
        else
        {
          miner_status_flag = (char *)get_miner_status_flag();
          if ( (int)miner_status_flag > 0 )
          {
            for ( k = 0; k != miner_status_flag; ++k )
            {
              v57 = delim[(_DWORD)k];
              v59 = k;
              v35 += snprintf(
                       &responseBuffer[v35],
                       responseBufferSize - v35,
                       "asic\t%03d\tcore\t%03d\treg\t0x%02x\tval\t0x%08x\n",
                       r10,
                       v59,
                       v34,
                       v57);
            }
          }
        }
      }
    }
    else
    {
      strcpy((char *)delim, "-");
      if ( !strtok(parsedCommand, (const char *)delim) )
        goto LABEL_74;
      token = strtok(0, (const char *)delim);
      if ( !token )
        goto LABEL_74;
      r10_1 = strtol(token, 0, 10);
      coreRegToken = strtok(0, (const char *)delim);
      if ( !coreRegToken )
        goto LABEL_74;
      regValue = strtol(coreRegToken, 0, 10);
      endPtr = strtok(0, (const char *)delim);
      if ( !endPtr )
        goto LABEL_74;
      resetCoreResult = strtol(endPtr, 0, 16);
      resetChain = resetCoreResult;
      if ( loggingDebug || loggingVerbose || loggingThreshold > 4 )
      {
        snprintf(
          (char *)logBuffer,
          2048u,
          "recvBuf = %s, chain = %d, asic = %d, reg = 0x%x\n",
          commandStr,
          r10_1,
          regValue,
          resetCoreResult);
        logMessage(5, (const char *)logBuffer, 0);
      }
      resetAsic = sub_1E160();
      resetToken = ReadASICRegister(resetChain, regValue * resetAsic, r10_1);
      snprintf(
        responseBuffer,
        responseBufferSize,
        "reg 0x%08x of asic %2d @ chain %2d, val = 0x%08x",
        resetChain,
        regValue,
        r10_1,
        resetToken);
    }
  }
  else
  {
    if ( logEnabled && (loggingDebug || loggingVerbose || loggingThreshold > 6) )
    {
      strcpy((char *)logBuffer, "cmd : get miner type");
      logMessage(7, (const char *)logBuffer, 0);
    }
    snprintf(responseBuffer, 256u, "%s", minerType);
  }
  return v8;
}
// 24020: variable 'v49' is possibly undefined
// 2410C: variable 'tempValue' is possibly undefined
// 1231C: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);
// 7EBA0: using guessed type int loggingThreshold;
// 7F8F8: using guessed type char byte_7F8F8;
// 482A5C: using guessed type char loggingVerbose;
// 482A5D: using guessed type char logEnabled;
// 590404: using guessed type char loggingDebug;

//----- (00024264) --------------------------------------------------------
int __fastcall format_chain_data(char *output_buffer)
{
  int active_chain_count; // r7
  int buffer_offset; // r5
  int chain_index; // r4
  char *current_position; // r8
  int temp_chain_index; // r0
  char *final_position; // r0
  int chain_voltage_length; // r5
  int chain_voladded_length; // r5
  int chain_basefreq_length; // r5
  int global_flag; // [sp+4h] [bp-2Ch]

  active_chain_count = 0;
  buffer_offset = 0;
  chain_index = 0;
  current_position = output_buffer;
  global_flag = get_global_flag();
  do
  {
    temp_chain_index = chain_index++;
    if ( get_global_buffer_value(temp_chain_index) )
    {
      chain_voltage_length = sprintf(current_position, "chain%d_voltage=%d;", chain_index, global_flag) + buffer_offset;
      ++active_chain_count;
      chain_voladded_length = chain_voltage_length
                            + sprintf(&output_buffer[chain_voltage_length], "chain%d_voladded=%d;", chain_index, 0);
      chain_basefreq_length = chain_voladded_length
                            + sprintf(&output_buffer[chain_voladded_length], "chain%d_basefreq=%d;", chain_index, 300);
      buffer_offset = chain_basefreq_length
                    + sprintf(&output_buffer[chain_basefreq_length], "chain%d_badcore=%d;", chain_index, 0);
      current_position = &output_buffer[buffer_offset];
    }
  }
  while ( chain_index != 4 );
  final_position = &output_buffer[buffer_offset + sprintf(current_position, "chainnum=%d;", active_chain_count)];
  return sprintf(final_position, "version=%s;", minerVersion);
}

//----- (00024364) --------------------------------------------------------
void *initialize_serial_number_and_command_processor()
{
  void *copy_result; // r0

  copy_result = memcpy(&byte_7F8F8, &serialNumber, 256u);
  dword_7F9FC = (int)processMinerCommand;
  return copy_result;
}
// 7F8F8: using guessed type char byte_7F8F8;
// 7F9FC: using guessed type int dword_7F9FC;

//----- (00024398) --------------------------------------------------------
int __fastcall sub_24398(int a1)
{
  int v1; // r6
  char *v3; // r7
  char *v4; // r8
  ssize_t v5; // r3
  const char *v7; // lr
  int v8; // r0
  int v9; // r1
  int v10; // r2
  int v11; // r3
  _DWORD *v12; // lr
  int v13; // r1
  int v14; // r2
  int v15; // r3
  int v16; // r8
  int v17; // r10
  int v18; // r10
  int v19; // r10
  int v20; // r10
  int v21; // r10
  int v22; // r0
  size_t v23; // r0
  unsigned int v24; // r10
  ssize_t v25; // r0
  ssize_t v26; // r10
  signed int v27; // [sp+Ch] [bp-585Ch]
  char v28[4]; // [sp+18h] [bp-5850h] BYREF
  socklen_t addr_len; // [sp+1Ch] [bp-584Ch] BYREF
  char needle[8]; // [sp+20h] [bp-5848h] BYREF
  int optval[2]; // [sp+28h] [bp-5840h] BYREF
  struct sockaddr addr; // [sp+30h] [bp-5838h] BYREF
  char v33[2048]; // [sp+40h] [bp-5828h] BYREF
  char s[10240]; // [sp+840h] [bp-5028h] BYREF
  _DWORD v35[2570]; // [sp+3040h] [bp-2828h] BYREF

  v1 = 0;
  optval[0] = 3;
  optval[1] = 0;
  v3 = (char *)calloc(1u, 24576u);
  strcpy(v28, "\r\n");
  v4 = s;
  addr_len = 0;
  strcpy(needle, "\r\n\r\n");
  memset(s, 0, sizeof(s));
  do
  {
    if ( terminate_flag )
      goto LABEL_6;
    v5 = recvfrom(a1, v4, 10239 - v1, (unsigned __int8)terminate_flag, &addr, &addr_len);
    v1 += v5;
    if ( v5 <= 0 )
    {
      close(a1);
      if ( logEnabled && (loggingDebug || loggingVerbose || loggingThreshold > 6) )
      {
        strcpy((char *)v35, ":statusServiceThread recvfrom<=0");
        logMessage(7, (const char *)v35, 0);
      }
      goto LABEL_18;
    }
    v4 = &s[v1];
    if ( v1 > 10238 )
    {
      close(a1);
      if ( logEnabled && (loggingDebug || loggingVerbose || loggingThreshold > 6) )
      {
        strcpy((char *)v35, "BUFSIZE is too small!");
        logMessage(7, (const char *)v35, 0);
      }
      goto LABEL_18;
    }
  }
  while ( !strstr(s, needle) );
  if ( logEnabled )
  {
    if ( loggingDebug || loggingVerbose || loggingThreshold > 6 )
    {
      strcpy((char *)v35, "find http request end flag!");
      logMessage(7, (const char *)v35, 0);
LABEL_6:
      if ( logEnabled )
      {
        if ( !loggingDebug )
          goto LABEL_8;
LABEL_10:
        snprintf((char *)v35, 2048u, "get http=%s", s);
        logMessage(7, (const char *)v35, 0);
      }
    }
    else
    {
LABEL_8:
      if ( loggingVerbose || loggingThreshold > 6 )
        goto LABEL_10;
    }
  }
  if ( s[0] != 71 || s[1] != 69 || s[2] != 84 || s[3] != 32 )
  {
    close(a1);
    if ( logEnabled && (loggingDebug || loggingVerbose || loggingThreshold > 6) )
    {
      strcpy((char *)v35, "statusServiceThread not support http command");
      logMessage(7, (const char *)v35, 0);
    }
    goto LABEL_18;
  }
  if ( setsockopt(a1, 1, 21, optval, 8u) )
  {
    close(a1);
    if ( logEnabled && (loggingDebug || loggingVerbose || loggingThreshold > 6) )
    {
      v7 = "setsockopt SO_SNDTIMEO failed";
      goto LABEL_41;
    }
    goto LABEL_18;
  }
  v16 = setsockopt(a1, 1, 20, optval, 8u);
  if ( v16 )
  {
    close(a1);
    if ( logEnabled && (loggingDebug || loggingVerbose || loggingThreshold > 6) )
    {
      v7 = "setsockopt SO_RCVTIMEO failed";
LABEL_41:
      v8 = *(_DWORD *)v7;
      v9 = *((_DWORD *)v7 + 1);
      v10 = *((_DWORD *)v7 + 2);
      v11 = *((_DWORD *)v7 + 3);
      v12 = v7 + 16;
      v35[0] = v8;
      v35[1] = v9;
      v35[2] = v10;
      v35[3] = v11;
      v13 = v12[1];
      v14 = v12[2];
      v15 = v12[3];
      v35[4] = *v12;
      v35[5] = v13;
      v35[6] = v14;
      LOWORD(v35[7]) = v15;
      logMessage(7, (const char *)v35, 0);
    }
LABEL_18:
    if ( v3 )
      goto LABEL_19;
    return 0;
  }
  if ( dword_7F9FC )
  {
    if ( ((int (__fastcall *)(char *, char *, int))dword_7F9FC)(s, v3, 24576) )
    {
      close(a1);
      if ( logEnabled && (loggingDebug || loggingVerbose || loggingThreshold > 6) )
      {
        strcpy((char *)v35, "statusServiceThread exit for Error cmd!");
        logMessage(7, (const char *)v35, 0);
      }
      goto LABEL_18;
    }
  }
  else if ( logEnabled && (loggingDebug || loggingVerbose || loggingThreshold > 6) )
  {
    strcpy((char *)v35, "No 6060 test case found.");
    logMessage(7, (const char *)v35, 0);
  }
  v27 = strlen(v3);
  v17 = sprintf((char *)v35, "HTTP/1.0  200  OK%s", v28);
  v18 = v17 + sprintf((char *)v35 + v17, "Server: SearchFreqServer%s", v28);
  v19 = v18 + sprintf((char *)v35 + v18, "Cache-Control: no-cache%s", v28);
  v20 = v19 + sprintf((char *)v35 + v19, "Pragma: no-cache%s", v28);
  v21 = v20 + sprintf((char *)v35 + v20, "Content-Type: text/plain%s", v28);
  v22 = sprintf((char *)v35 + v21, "Content-Length: %d%s", v27, v28);
  sprintf((char *)v35 + v21 + v22, "Connection: Keep-Alive%s", needle);
  if ( !logEnabled )
  {
    if ( terminate_flag )
      goto LABEL_73;
    goto LABEL_56;
  }
  if ( loggingDebug || loggingVerbose || loggingThreshold > 6 )
  {
    strcpy(v33, "send http response...\n");
    logMessage(7, v33, 0);
    if ( !terminate_flag )
      goto LABEL_56;
LABEL_69:
    if ( !logEnabled )
      goto LABEL_73;
LABEL_113:
    if ( loggingDebug || loggingVerbose || loggingThreshold > 6 )
    {
      strcpy(v33, "send http data...");
      logMessage(7, v33, 0);
    }
    while ( 1 )
    {
LABEL_73:
      v26 = send(a1, &v3[v16], v27 - v16, 0);
      if ( logEnabled && (loggingDebug || loggingVerbose || loggingThreshold > 6) )
      {
        snprintf(v33, 2048u, "send http data ret=%d", v26);
        logMessage(7, v33, 0);
      }
      if ( v26 <= 0 )
        break;
      v16 += v26;
      if ( v27 <= v16 || terminate_flag )
        goto LABEL_84;
    }
    if ( !logEnabled )
      goto LABEL_89;
    if ( loggingDebug || loggingVerbose || loggingThreshold > 6 )
    {
      strcpy(v33, "statusServiceThread send http data error");
      logMessage(7, v33, 0);
LABEL_84:
      if ( !logEnabled )
        goto LABEL_89;
      if ( loggingDebug )
        goto LABEL_88;
    }
    if ( loggingVerbose || loggingThreshold > 6 )
    {
LABEL_88:
      strcpy(v33, "one client disconnected!");
      logMessage(7, v33, 0);
    }
LABEL_89:
    close(a1);
    free(v3);
    return v16;
  }
  if ( terminate_flag )
    goto LABEL_113;
LABEL_56:
  v23 = strlen((const char *)v35);
  v24 = 0;
  while ( 1 )
  {
    v25 = send(a1, (char *)v35 + v24, v23 - v24, 0);
    if ( v25 == -1 )
      break;
    if ( v25 <= 0 )
      goto LABEL_63;
    v24 += v25;
LABEL_59:
    v23 = strlen((const char *)v35);
    if ( v23 <= v24 || terminate_flag )
      goto LABEL_69;
  }
  if ( *_errno_location() == 11 )
  {
    if ( logEnabled && (loggingDebug || loggingVerbose || loggingThreshold > 6) )
    {
      strcpy(v33, "statusServiceThread send http timeout, try again...");
      logMessage(7, v33, 0);
    }
    usleep((__useconds_t)&loc_186A0);
    goto LABEL_59;
  }
LABEL_63:
  close(a1);
  if ( logEnabled && (loggingDebug || loggingVerbose || loggingThreshold > 6) )
  {
    strcpy(v33, "statusServiceThread send http response error");
    logMessage(7, v33, 0);
  }
LABEL_19:
  free(v3);
  return 0;
}
// 7EBA0: using guessed type int loggingThreshold;
// 7F9F8: using guessed type char terminate_flag;
// 7F9FC: using guessed type int dword_7F9FC;
// 482A5C: using guessed type char loggingVerbose;
// 482A5D: using guessed type char logEnabled;
// 590404: using guessed type char loggingDebug;

//----- (00024F04) --------------------------------------------------------
int initializeHttpServer()
{
  int socket_fd; // r0
  int client_fd; // r0
  int client_sock; // r4
  int result; // r0
  socklen_t client_addr_len; // [sp+Ch] [bp-84Ch] BYREF
  struct sockaddr server_addr; // [sp+10h] [bp-848h] BYREF
  struct sockaddr client_addr; // [sp+20h] [bp-838h] BYREF
  char logBuffer[2088]; // [sp+30h] [bp-828h] BYREF

  prctl(15, "http", 0);
  do
  {
    socket_fd = socket(2, 1, 6);
    dword_7E2EC = socket_fd;
    if ( socket_fd < 0 )
    {
      if ( loggingDebug || loggingVerbose || loggingThreshold > 4 )
      {
        strcpy(logBuffer, "socket creating failed, try again after 10s...");
        logMessage(5, logBuffer, 0);
      }
      sleep(10u);
    }
    else
    {
      *(_DWORD *)&server_addr.sa_family = -1407778814;
      memset(&server_addr.sa_data[2], 0, 12);
      if ( bind(socket_fd, &server_addr, 16u) < 0 )
      {
        if ( loggingDebug || loggingVerbose || loggingThreshold > 4 )
        {
          strcpy(logBuffer, "http port bind failed! try again after 10s...");
          logMessage(5, logBuffer, 0);
        }
      }
      else
      {
        if ( listen(dword_7E2EC, 100) >= 0 )
          break;
        if ( loggingDebug || loggingVerbose || loggingThreshold > 4 )
        {
          strcpy(logBuffer, "http listen failed! try again after 10s...");
          logMessage(5, logBuffer, 0);
        }
      }
      close(dword_7E2EC);
      dword_7E2EC = -1;
      sleep(10u);
    }
  }
  while ( !terminate_flag );
  if ( loggingDebug || loggingVerbose || loggingThreshold > 4 )
  {
    strcpy(logBuffer, "start listen on 6060 ...");
    logMessage(5, logBuffer, 0);
  }
  if ( !terminate_flag )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        usleep(10000u);
        client_addr_len = 16;
        client_fd = accept(dword_7E2EC, &client_addr, &client_addr_len);
        client_sock = client_fd;
        if ( client_fd != -1 )
          break;
        if ( terminate_flag )
          goto cleanup_and_exit;
      }
      if ( terminate_flag )
        break;
      if ( logEnabled && (loggingDebug || loggingVerbose || loggingThreshold > 6) )
      {
        snprintf(logBuffer, 2048u, "one client connected sock=%d", client_fd);
        logMessage(7, logBuffer, 0);
      }
      handle_http_request(client_sock);
      if ( terminate_flag )
        goto cleanup_and_exit;
    }
    close(client_fd);
  }
cleanup_and_exit:
  close(dword_7E2EC);
  result = 0;
  dword_7E2EC = -1;
  return result;
}
// 7E2EC: using guessed type int dword_7E2EC;
// 7EBA0: using guessed type int loggingThreshold;
// 7F9F8: using guessed type char terminate_flag;
// 482A5C: using guessed type char loggingVerbose;
// 482A5D: using guessed type char logEnabled;
// 590404: using guessed type char loggingDebug;

//----- (00025284) --------------------------------------------------------
int startHttpLog()
{
  int result; // r0
  pthread_t httpListenThreadId; // [sp+0h] [bp-830h] BYREF
  pthread_attr_t threadAttr; // [sp+4h] [bp-82Ch] BYREF
  char logBuffer[2056]; // [sp+28h] [bp-808h] BYREF

  if ( loggingDebug || loggingVerbose || loggingThreshold > 4 )
  {
    strcpy(logBuffer, "start the http log.\n");
    logMessage(5, logBuffer, 0);
  }
  pthread_attr_init(&threadAttr);
  pthread_attr_setstacksize(&threadAttr, 2097152u);
  result = pthread_create(&httpListenThreadId, &threadAttr, (void *(*)(void *))initializeHttpServer, 0);
  if ( loggingDebug || loggingVerbose || loggingThreshold > 4 )
  {
    snprintf(logBuffer, 2048u, "httpListenThread start ret=%d", result);
    return logMessage(5, logBuffer, 0);
  }
  return result;
}
// 7EBA0: using guessed type int loggingThreshold;
// 482A5C: using guessed type char loggingVerbose;
// 590404: using guessed type char loggingDebug;

//----- (000253A0) --------------------------------------------------------
char *__fastcall get_http_response(const char *url)
{
  const char *url_without_http; // r4
  char *slash_position; // r6
  size_t url_length; // r0
  size_t hostname_length; // r5
  size_t path_length; // r8
  size_t hostname_size; // r5
  int next_char; // r3
  char *colon_position; // r0
  int port; // r6
  struct hostent *host_info; // r3
  int socket_descriptor; // r0
  int socket_fd; // r5
  int set_sock_result; // r4
  signed int get_request_length; // r6
  ssize_t num_bytes_sent; // r0
  const char *error_message; // r12
  int log_msg_first_dword; // r0
  int log_msg_second_dword; // r1
  int log_msg_third_dword; // r2
  int log_msg_fourth_dword; // r3
  _DWORD *error_message_offset; // r12
  char *response_buffer; // r4
  int log_msg_second_int; // r1
  char *http_header_start; // r0
  char *http_header_end; // r0
  char *content_start; // r5
  size_t content_length; // r0
  char *allocated_response; // r0
  int sockopt_timeval[2]; // [sp+8h] [bp-2020h] BYREF
  char hostname_buffer[1024]; // [sp+10h] [bp-2018h] BYREF
  char path_buffer[1024]; // [sp+410h] [bp-1C18h] BYREF
  struct sockaddr sockaddr_data[127]; // [sp+810h] [bp-1818h] BYREF
  char http_request_buffer[4120]; // [sp+1010h] [bp-1018h] BYREF

  memset(http_request_buffer, 0, 4096u);
  memset(hostname_buffer, 0, sizeof(hostname_buffer));
  memset(path_buffer, 0, sizeof(path_buffer));
  if ( !url )
  {
    if ( loggingDebug || loggingVerbose || loggingThreshold > 4 )
    {
      response_buffer = 0;
      strcpy((char *)sockaddr_data, "url is null!\n");
      logMessage(5, (const char *)sockaddr_data, 0);
      return response_buffer;
    }
    return 0;
  }
  if ( !strncmp(url, "http://", 7u) )
  {
    url_without_http = url + 7;
    slash_position = strchr(url_without_http, 47);
    url_length = strlen(url_without_http);
    hostname_length = url_length;
    if ( slash_position )
    {
      path_length = strlen(slash_position);
      hostname_size = hostname_length - path_length;
      memcpy(hostname_buffer, url_without_http, hostname_size);
      next_char = (unsigned __int8)slash_position[1];
      hostname_buffer[hostname_size] = 0;
      if ( next_char )
      {
        memcpy(path_buffer, slash_position + 1, path_length - 1);
        hostname_buffer[path_length + 1023] = 0;
      }
    }
    else
    {
      memcpy(hostname_buffer, url_without_http, url_length);
      hostname_buffer[hostname_length] = 0;
    }
    colon_position = strchr(hostname_buffer, 58);
    if ( colon_position )
    {
      *colon_position = 0;
      port = strtol(colon_position + 1, 0, 10);
    }
    else
    {
      port = 80;
    }
    host_info = gethostbyname(hostname_buffer);
    if ( !host_info )
      goto LABEL_37;
    *(_WORD *)sockaddr_data[0].sa_data = __rev16(port);
    sockaddr_data[0].sa_family = 2;
    *(_DWORD *)&sockaddr_data[0].sa_data[2] = **(_DWORD **)host_info->h_addr_list;
    socket_descriptor = socket(2, 1, 0);
    socket_fd = socket_descriptor;
    if ( socket_descriptor == -1
      || (sockopt_timeval[0] = 10, sockopt_timeval[1] = 0, setsockopt(socket_descriptor, 1, 21, sockopt_timeval, 8u))
      || (set_sock_result = setsockopt(socket_fd, 1, 20, sockopt_timeval, 8u)) != 0
      || connect(socket_fd, sockaddr_data, 16u) == -1
      || socket_fd < 0 )
    {
LABEL_37:
      if ( loggingDebug || loggingVerbose || loggingThreshold > 4 )
      {
        response_buffer = 0;
        strcpy((char *)sockaddr_data, "tcp client create failed\n");
        logMessage(5, (const char *)sockaddr_data, 0);
        return response_buffer;
      }
    }
    else
    {
      sprintf(
        http_request_buffer,
        "GET /%s HTTP/1.1\r\nHOST: %s:%d\r\nAccept: */*\r\n\r\n",
        path_buffer,
        hostname_buffer,
        port);
      get_request_length = strlen(http_request_buffer);
      if ( get_request_length )
      {
        while ( 1 )
        {
          num_bytes_sent = send(
                             socket_fd,
                             &http_request_buffer[set_sock_result],
                             get_request_length - set_sock_result,
                             0);
          set_sock_result += num_bytes_sent;
          if ( num_bytes_sent == -1 )
            break;
          if ( get_request_length <= set_sock_result )
            goto LABEL_39;
        }
        if ( loggingDebug || loggingVerbose || loggingThreshold > 4 )
        {
          error_message = "tcp client send failed\n";
LABEL_23:
          log_msg_first_dword = *(_DWORD *)error_message;
          log_msg_second_dword = *((_DWORD *)error_message + 1);
          log_msg_third_dword = *((_DWORD *)error_message + 2);
          log_msg_fourth_dword = *((_DWORD *)error_message + 3);
          error_message_offset = error_message + 16;
          response_buffer = 0;
          *(_DWORD *)&sockaddr_data[0].sa_family = log_msg_first_dword;
          *(_DWORD *)&sockaddr_data[0].sa_data[2] = log_msg_second_dword;
          *(_DWORD *)&sockaddr_data[0].sa_data[6] = log_msg_third_dword;
          *(_DWORD *)&sockaddr_data[0].sa_data[10] = log_msg_fourth_dword;
          log_msg_second_int = error_message_offset[1];
          *(_DWORD *)&sockaddr_data[1].sa_family = *error_message_offset;
          *(_DWORD *)&sockaddr_data[1].sa_data[2] = log_msg_second_int;
          logMessage(5, (const char *)sockaddr_data, 0);
          return response_buffer;
        }
      }
      else
      {
LABEL_39:
        if ( recv(socket_fd, http_request_buffer, 4096u, 0) > 0 )
        {
          close(socket_fd);
          http_header_start = strstr(http_request_buffer, "HTTP/1.1");
          if ( http_header_start )
          {
            if ( strtol(http_header_start + 9, 0, 10) == 200 )
            {
              http_header_end = strstr(http_request_buffer, "\r\n\r\n");
              content_start = http_header_end;
              if ( http_header_end )
              {
                content_length = strlen(http_header_end);
                allocated_response = (char *)malloc(content_length + 1);
                response_buffer = allocated_response;
                if ( allocated_response )
                  strcpy(allocated_response, content_start + 4);
                return response_buffer;
              }
            }
          }
        }
        else if ( loggingDebug || loggingVerbose || loggingThreshold > 4 )
        {
          error_message = "tcp client recv failed\n";
          goto LABEL_23;
        }
      }
    }
    return 0;
  }
  if ( !loggingDebug && !loggingVerbose && loggingThreshold <= 4 )
    return 0;
  strcpy((char *)sockaddr_data, "parse url failed!\n");
  logMessage(5, (const char *)sockaddr_data, 0);
  return 0;
}
// 7EBA0: using guessed type int loggingThreshold;
// 482A5C: using guessed type char loggingVerbose;
// 590404: using guessed type char loggingDebug;

//----- (000258C8) --------------------------------------------------------
int __fastcall get_device_ip_address(char *out_ip_address)
{
  int socket_fd; // r0
  int local_socket; // r6
  int v4; // r9
  unsigned int interface_count; // r5
  struct in_addr *current_interface_addr; // r4
  char *ip_address_str; // r1
  int interface_req[2]; // [sp+0h] [bp-228h] BYREF
  _OWORD interface_buffer[34]; // [sp+8h] [bp-220h] BYREF

  socket_fd = socket(2, 2, 0);
  local_socket = socket_fd;
  if ( socket_fd < 0 )
    return -1;
  interface_req[0] = 512;
  interface_req[1] = (int)interface_buffer;
  if ( ioctl(socket_fd, 35090u, interface_req) )
  {
    v4 = -1;
  }
  else
  {
    v4 = -1;
    interface_count = (unsigned int)interface_req[0] >> 5;
    for ( current_interface_addr = (struct in_addr *)&interface_buffer[2 * ((unsigned int)interface_req[0] >> 5) - 2];
          interface_count-- != 0;
          current_interface_addr -= 8 )
    {
      if ( !ioctl(local_socket, 35093u, current_interface_addr) )
      {
        ip_address_str = inet_ntoa(current_interface_addr[5]);
        if ( ip_address_str )
        {
          strcpy(out_ip_address, ip_address_str);
          v4 = strcmp("127.0.0.1", out_ip_address);
          if ( v4 )
          {
            v4 = 0;
            break;
          }
        }
      }
    }
  }
  close(local_socket);
  return v4;
}

//----- (000259A8) --------------------------------------------------------
void __noreturn MonitorASICHeartbeat()
{
  double currentVoltage; // d0
  double averageVoltage; // d9
  int chainIndex; // r4
  double totalVoltage; // d8
  double thresholdVoltage; // d7
  const char *voltageChangeType; // r3
  bool isVerbosityHigh; // cc
  int failureCount; // r12
  int failureCounts[4]; // [sp+10h] [bp-848h] BYREF
  char logBuffer[2104]; // [sp+20h] [bp-838h] BYREF

  memset(failureCounts, 0, sizeof(failureCounts));
  averageVoltage = -1.0;
  prctl(15, "heart_beat", 0, 0, 0);
  while ( 1 )
  {
    chainIndex = 0;
    totalVoltage = 0.0;
    pthread_setcancelstate(1, 0);
    do
    {
      if ( get_global_buffer_value(chainIndex) )
      {
        get_next_sleep_interval();
        if ( is_success_response((unsigned __int8)chainIndex) )
        {
          failureCounts[chainIndex] = 0;
        }
        else
        {
          isVerbosityHigh = (unsigned int)globalLogLevel > 1;
          failureCount = failureCounts[chainIndex] + 1;
          failureCounts[chainIndex] = failureCount;
          if ( isVerbosityHigh )
          {
            snprintf(logBuffer, 2048u, "chain[%d] heart beat fail %d times.\n", chainIndex, failureCount);
            logMessage(1, logBuffer, 0);
          }
        }
        get_next_sleep_interval();
        readASICVoltage(chainIndex);
        totalVoltage = totalVoltage + currentVoltage;
      }
      ++chainIndex;
    }
    while ( chainIndex != 4 );
    if ( get_status_flag() )
      totalVoltage = totalVoltage / (double)get_status_flag();
    if ( averageVoltage < -0.1 )
      averageVoltage = totalVoltage;
    if ( (unsigned int)globalLogLevel > 4 )
    {
      snprintf(logBuffer, 2048u, "last avg = %.2f, current voltage = %.2f", averageVoltage, totalVoltage);
      logMessage(4, logBuffer, 0);
    }
    thresholdVoltage = (double)(dword_482A8C / 100) * 0.75;
    if ( (thresholdVoltage < averageVoltage && averageVoltage * 0.75 > totalVoltage
       || thresholdVoltage < totalVoltage && totalVoltage * 0.75 > averageVoltage)
      && (unsigned int)globalLogLevel > 3 )
    {
      voltageChangeType = "drop";
      if ( totalVoltage - averageVoltage > 0.0 )
        voltageChangeType = "rise";
      snprintf(logBuffer, 2048u, "chain avg vol %s to %.2f", voltageChangeType, totalVoltage);
      logMessage(3, logBuffer, 0);
    }
    averageVoltage = totalVoltage;
    pthread_setcancelstate(0, 0);
    pthread_testcancel();
    sleep(10u);
  }
}
// 25B84: variable 'currentVoltage' is possibly undefined
// 7EB9C: using guessed type int globalLogLevel;
// 482A8C: using guessed type int dword_482A8C;

//----- (00025C08) --------------------------------------------------------
int check_miner_balance()
{
  int global_state_value; // r6
  int scaled_global_state; // r6
  int allocated_memory; // r0
  unsigned int *buf_ptr; // r7
  int miner_index; // r5
  unsigned int *current_value_ptr; // r8
  unsigned __int64 total_value; // r10
  unsigned int value_counter; // r4
  int current_value; // r0
  unsigned __int64 average_value; // r0
  unsigned __int64 threshold_value; // r0
  unsigned int *check_ptr; // lr
  int compare_counter; // r12
  unsigned int next_value; // t1
  char log_message_buffer[2080]; // [sp+0h] [bp-820h] BYREF

  global_state_value = get_global_state_value();
  scaled_global_state = get_embedded_system_status() * global_state_value;
  allocated_memory = (int)malloc(4 * scaled_global_state);
  buf_ptr = (unsigned int *)allocated_memory;
  if ( allocated_memory )
  {
    miner_index = 0;
    while ( 1 )
    {
      if ( get_global_buffer_value(miner_index) )
      {
        if ( scaled_global_state )
        {
          current_value_ptr = buf_ptr - 1;
          total_value = 0LL;
          value_counter = 0;
          do
          {
            current_value = sub_2CD30(miner_index, value_counter++);
            total_value += (unsigned int)current_value;
            current_value_ptr[1] = current_value;
            ++current_value_ptr;
          }
          while ( scaled_global_state != value_counter );
          LODWORD(average_value) = handle_divide_by_zero(total_value, (unsigned int)scaled_global_state);
          if ( average_value > 4999 )
          {
            threshold_value = average_value >> 1;
            if ( *buf_ptr < threshold_value )
            {
LABEL_16:
              if ( (unsigned int)globalLogLevel > 3 )
              {
                strcpy(log_message_buffer, "Domain unbalance happened!\n");
                logMessage(3, log_message_buffer, 0);
              }
              free(buf_ptr);
              return 1;
            }
            check_ptr = buf_ptr;
            compare_counter = 0;
            while ( ++compare_counter != value_counter )
            {
              next_value = check_ptr[1];
              ++check_ptr;
              if ( next_value < threshold_value )
                goto LABEL_16;
            }
          }
        }
      }
      if ( ++miner_index == 4 )
      {
        free(buf_ptr);
        return 0;
      }
    }
  }
  if ( (unsigned int)globalLogLevel > 3 )
  {
    strcpy(log_message_buffer, "failed alloc memory!\n");
    logMessage(3, log_message_buffer, 0);
    return 0;
  }
  return allocated_memory;
}
// 25CC4: variable 'average_value' is possibly undefined
// 7EB9C: using guessed type int globalLogLevel;

//----- (00025DB0) --------------------------------------------------------
int check_network_status()
{
  int operation_result; // r0
  bool connection_status_empty; // zf
  int time_diff; // r2
  int status_code; // r0
  unsigned int status; // r0
  __time_t current_time; // [sp+0h] [bp-820h] BYREF
  unsigned int previous_seed; // [sp+4h] [bp-81Ch]
  char log_buffer[2072]; // [sp+8h] [bp-818h] BYREF

  convert_timespec_to_custom_format(&current_time);
  operation_result = (int)dword_482A74;
  connection_status_empty = dword_482A74[0] == 0;
  if ( !dword_482A74[0] )
    connection_status_empty = dword_482A74[1] == 0;
  if ( connection_status_empty )
    return convert_timespec_to_custom_format(dword_482A74);
  time_diff = current_time - dword_482A74[0];
  if ( (int)(previous_seed - dword_482A74[1]) < 0 )
    --time_diff;
  if ( time_diff <= 300 )
  {
    if ( dword_7FA04 )
    {
      if ( (unsigned int)globalLogLevel > 3 )
      {
        strcpy(log_buffer, "network connection resume, restart");
        logMessage(3, log_buffer, 0);
      }
      operation_result = handle_error_with_logging(6u, "network connection resume, restart...");
      dword_7FA04 = 0;
      dword_7FA00[0] = 0;
    }
    else if ( dword_7FA00[0] )
    {
      if ( (unsigned int)globalLogLevel > 3 )
      {
        strcpy(log_buffer, "network connection resume");
        logMessage(3, log_buffer, 0);
      }
      status_code = get_antminer_status_code();
      operation_result = handle_error_with_logging(status_code, 0);
      dword_7FA00[0] = 0;
    }
  }
  else if ( dword_7FA00[0] )
  {
    if ( dword_7FA00[0] + 299 < time_diff && !dword_7FA04 )
    {
      if ( (unsigned int)globalLogLevel > 3 )
      {
        snprintf(log_buffer, 2048u, "network connection lost for 5 min + %d seconds, power off...", dword_7FA00[0]);
        logMessage(3, log_buffer, 0);
      }
      operation_result = wait_one_second();
      dword_7FA04 = 1;
    }
  }
  else
  {
    handle_error_with_logging(3u, "network connection lost");
    status = get_status();
    if ( !status )
      status = previous_seed;
    srandom(status);
    operation_result = random();
    dword_7FA00[0] = operation_result % 300 + 1;
    if ( (unsigned int)globalLogLevel > 3 )
    {
      snprintf(log_buffer, 2048u, "will power off in %d seconds in case not resume", operation_result % 300 + 1);
      return logMessage(3, log_buffer, 0);
    }
  }
  return operation_result;
}
// 7EB9C: using guessed type int globalLogLevel;
// 7FA00: using guessed type int dword_7FA00[];
// 7FA04: using guessed type int dword_7FA04;
// 482A74: using guessed type __time_t dword_482A74[3];

//----- (0002600C) --------------------------------------------------------
void __noreturn nonce_registration_loop()
{
  int chip_id; // r0
  unsigned int half_temperature; // r5
  int nonce_count; // r4
  _QWORD register_values[4]; // [sp+8h] [bp-20h] BYREF

  chip_id = read_chip_id();
  set_and_read_register_value(chip_id | 0x10000);
  prctl(15, "nonce_reg_process", 0);
  while ( 1 )
  {
    half_temperature = (unsigned int)read_chip_temperature() >> 1;
    if ( half_temperature )
    {
      for ( nonce_count = 0; nonce_count != half_temperature; ++nonce_count )
      {
        while ( 1 )
        {
          get_register_values(register_values);
          if ( (register_values[0] & 0x80000000LL) != 0 )
            break;
          ++nonce_count;
          handle_register_read_result((int)register_values);
          if ( half_temperature == nonce_count )
            goto LABEL_7;
        }
        process_nonce_data(register_values);
      }
    }
LABEL_7:
    get_next_sleep_interval();
  }
}

//----- (00026094) --------------------------------------------------------
time_t get_current_time()
{
  int errno_value; // r4
  char *error_message; // r0
  char log_buffer[2056]; // [sp+8h] [bp-808h] BYREF

  if ( (unsigned int)globalLogLevel > 3 )
  {
    errno_value = *_errno_location();
    error_message = strerror(errno_value);
    snprintf(log_buffer, 2048u, "Failed to get sysinfo, errno = %u, reason = %s.\n", errno_value, error_message);
    logMessage(3, log_buffer, 0);
  }
  return time(0);
}
// 7EB9C: using guessed type int globalLogLevel;

//----- (00026104) --------------------------------------------------------
int get_system_uptime()
{
  struct sysinfo system_info; // [sp+0h] [bp-48h] BYREF

  if ( sysinfo(&system_info) )
    return get_current_time();
  else
    return system_info.uptime;
}

//----- (00026134) --------------------------------------------------------
int calculate_mining_effectiveness()
{
  int system_uptime; // r0
  __int64 previous_total_hashes; // r6
  int previous_uptime; // r8
  int uptime_difference; // r8
  double new_hash_rate; // r0
  int recent_result; // r0
  char log_message_buffer[2072]; // [sp+10h] [bp-818h] BYREF

  system_uptime = get_system_uptime();
  previous_total_hashes = qword_99EE08;
  previous_uptime = dword_7FA08;
  dword_7FA08 = system_uptime;
  uptime_difference = system_uptime - previous_uptime;
  LODWORD(new_hash_rate) = normalize_exponent_sign(qword_99EE08 - qword_7FA10);
  qword_7FA10 = previous_total_hashes;
  unk_99EE00 = new_hash_rate * 4294967300.0 / 1000000000.0 / (double)uptime_difference;
  recent_result = find_optimal_hash_rate();
  if ( (double)recent_result * 0.75 > unk_99EE00 && (unsigned int)globalLogLevel > 3 )
  {
    snprintf(
      log_message_buffer,
      2048u,
      "avg rate is lower than ideal rate, %0.2f in %ld mins\n",
      unk_99EE00,
      uptime_difference / 60);
    return logMessage(3, log_message_buffer, 0);
  }
  return recent_result;
}
// 26194: variable 'new_hash_rate' is possibly undefined
// 7EB9C: using guessed type int globalLogLevel;
// 7FA08: using guessed type int dword_7FA08;
// 7FA10: using guessed type __int64 qword_7FA10;
// 99EE08: using guessed type __int64 qword_99EE08;

//----- (00026250) --------------------------------------------------------
int calculate_hashrate_and_log()
{
  int current_uptime; // r0
  int previous_uptime; // r7
  int uptime_delta; // r7
  int *previous_uptime_pair; // r6
  int asic_chain_index; // r5
  bool is_hash_zero; // zf
  int logging_result; // r0
  int previous_hash_count; // r9
  int previous_time_high; // r11
  unsigned int hash_period_counter; // r4
  unsigned __int64 temp_hash_calc; // r0
  __int64 temp_hash_rate; // r0
  double temporary_hash_rate; // r0
  double hash_rate; // d5
  char hashrate_log_buffer[2088]; // [sp+28h] [bp-828h] BYREF

  if ( dword_80F60 == 1 )
  {
    memset(&dword_7FA18, 0, 32u);
    dword_80F60 = 0;
  }
  current_uptime = get_system_uptime();
  previous_uptime = dword_7FA38;
  dword_7FA38 = current_uptime;
  uptime_delta = current_uptime - previous_uptime;
  previous_uptime_pair = &dword_7FA18;
  for ( asic_chain_index = 0; asic_chain_index != 4; ++asic_chain_index )
  {
    while ( 1 )
    {
      is_hash_zero = get_global_buffer_value(asic_chain_index) == 0;
      logging_result = (int)&dword_99ED98[2 * asic_chain_index];
      if ( !is_hash_zero )
      {
        previous_hash_count = dword_99ED98[2 * asic_chain_index];
        previous_time_high = *(_DWORD *)(logging_result + 4);
        hash_period_counter = dword_7F8F0;
        LODWORD(temp_hash_calc) = handle_divide_by_zero(
                                    -4294967297LL
                                  * (__PAIR64__(previous_time_high, previous_hash_count)
                                   - *(_QWORD *)previous_uptime_pair),
                                    uptime_delta);
        LODWORD(temp_hash_rate) = handle_divide_by_zero(temp_hash_calc, 1000000000uLL);
        LODWORD(temporary_hash_rate) = normalize_exponent_sign(temp_hash_rate);
        hash_rate = temporary_hash_rate;
        *previous_uptime_pair = previous_hash_count;
        previous_uptime_pair[1] = previous_time_high;
        dbl_58E040[24 * asic_chain_index + hash_period_counter % 24] = temporary_hash_rate;
        logging_result = 24 * asic_chain_index + (hash_period_counter - 1) % 24;
        if ( hash_period_counter > 1
          && hash_rate < dbl_58E040[logging_result] * 0.75
          && (unsigned int)globalLogLevel > 3 )
        {
          break;
        }
      }
      ++asic_chain_index;
      previous_uptime_pair += 2;
      if ( asic_chain_index == 4 )
        goto LABEL_9;
    }
    snprintf(
      hashrate_log_buffer,
      2048u,
      "chain %d hash rate %.2f low in %ld mins",
      asic_chain_index,
      hash_rate,
      uptime_delta / 60);
    logging_result = logMessage(3, hashrate_log_buffer, 0);
    previous_uptime_pair += 2;
  }
LABEL_9:
  ++dword_7F8F0;
  return logging_result;
}
// 26340: variable 'temp_hash_calc' is possibly undefined
// 26344: variable 'temp_hash_rate' is possibly undefined
// 26348: variable 'temporary_hash_rate' is possibly undefined
// 7EB9C: using guessed type int globalLogLevel;
// 7F8F0: using guessed type int dword_7F8F0;
// 7FA18: using guessed type int dword_7FA18;
// 7FA38: using guessed type int dword_7FA38;
// 80F60: using guessed type int dword_80F60;
// 58E040: using guessed type double dbl_58E040[96];
// 99ED98: using guessed type _DWORD dword_99ED98[8];

//----- (0002647C) --------------------------------------------------------
void __noreturn check_system_status_thread()
{
  const char *shared_variable; // r0
  int system_uptime; // r5
  unsigned int uptime_diff; // r0
  unsigned int loop_counter; // r5
  int index; // r4
  int value_to_pass; // r0

  prctl(15, "chk_sys", 0);
  shared_variable = (const char *)get_shared_variable();
  if ( strcmp(shared_variable, "BHB28601") )
    get_shared_variable();
  system_uptime = get_system_uptime();
  while ( 1 )
  {
    if ( get_global_variable() == 2 )
    {
      uptime_diff = get_system_uptime() - system_uptime;
      if ( qword_99EE08 || uptime_diff > 1800 )
        break;
    }
    get_next_sleep_interval();
  }
  dword_7FA3C = get_system_uptime();
  dword_7FA08 = dword_7FA3C;
  dword_7FA40 = dword_7FA3C;
  dword_7FA38 = dword_7FA3C;
  loop_counter = 1;
  pthread_setcancelstate(1, 0);
  while ( 1 )
  {
    do
    {
      if ( !pthread_mutex_trylock(&stru_7FA44) )
      {
        if ( byte_7EB78 )
          AdjustMinerVoltage();
        pthread_mutex_unlock(&stru_7FA44);
      }
      ++loop_counter;
      pthread_setcancelstate(0, 0);
      pthread_testcancel();
      get_next_sleep_interval();
      pthread_setcancelstate(1, 0);
      index = loop_counter % 30;
    }
    while ( loop_counter != 30 * (loop_counter / 30) );
    if ( get_global_buffer_value(loop_counter % 30) )
    {
LABEL_17:
      value_to_pass = sub_1E160();
      measure_asic_voltages(index, value_to_pass);
    }
    while ( ++index != 4 )
    {
      if ( get_global_buffer_value(index) )
        goto LABEL_17;
    }
  }
}
// 7EB78: using guessed type char byte_7EB78;
// 7FA08: using guessed type int dword_7FA08;
// 7FA38: using guessed type int dword_7FA38;
// 7FA3C: using guessed type int dword_7FA3C;
// 7FA40: using guessed type int dword_7FA40;
// 99EE08: using guessed type __int64 qword_99EE08;

//----- (000265F4) --------------------------------------------------------
int update_last_uptime()
{
  int last_uptime; // r0

  last_uptime = get_system_uptime();
  dword_7FA3C = last_uptime;
  dword_7FA08 = last_uptime;
  dword_7FA40 = last_uptime;
  dword_7FA38 = last_uptime;
  return last_uptime;
}
// 7FA08: using guessed type int dword_7FA08;
// 7FA38: using guessed type int dword_7FA38;
// 7FA3C: using guessed type int dword_7FA3C;
// 7FA40: using guessed type int dword_7FA40;

//----- (00026618) --------------------------------------------------------
int check_psu_balance_and_reboot()
{
  int balance_status; // r0

  balance_status = find_optimal_hash_rate();
  if ( (double)balance_status * 0.95 > unk_99EE00 )
  {
    balance_status = check_miner_balance();
    if ( balance_status )
      return handle_error_with_logging(11u, "Unbalance happened, reboot!\n");
  }
  return balance_status;
}

//----- (00026670) --------------------------------------------------------
int manage_miner_operations()
{
  int current_tick; // r3
  int tick_divisor; // r2
  int next_tick; // r3
  int next_tick_divisor; // r1
  int current_system_uptime; // r0
  int *current_asic_diff; // r10
  double total_mhash; // d8
  int *current_asic_sum_diff; // r9
  unsigned int asic_index; // r5
  int time_difference; // s24
  int current_diff_value; // lr
  int current_point; // r1
  unsigned int buffer_index; // r0
  int incremented_point; // r1
  int temp_calc; // r2
  int point_counter; // r7
  int *chain_buffer_pointer; // r0
  int current_sum_diff_value; // r4
  int next_point_mod; // r6
  int previous_diff_value; // r1
  int previous_asic_diff_next; // r2
  int previous_asic_diff_current; // r3
  int current_asic_sum_diff_next; // r12
  __int64 chain_diff; // r0
  double normalized_chain_diff; // r0
  double calculated_mhash; // d6
  int minute_counter; // r4
  int system_uptime; // r0
  int previous_system_uptime; // r7
  int uptime_difference; // r7
  double normalized_hashrate; // r0
  double hashrate_divider; // d7
  int buffer_write_position; // r12
  double *hashrate_buffer; // r3
  double current_hashrate; // d6
  __int64 buffer_index_calculation; // r0
  int incremented_write_position; // r2
  int *buffer_write_pointer; // r1
  double cumulative_hashrate; // d7
  double buffered_hashrate; // d6
  double average_hashrate_divider; // d6

  check_and_configure_miner_gpio();
  current_tick = dword_7FA5C;
  tick_divisor = dword_7FA5C >> 31;
  if ( !(dword_7FA5C % 5) )
  {
    if ( dword_80F58 == 1 )
    {
      memset(&unk_7FA60, 0, 320u);
      memset(&dword_7FBA0, 0, 32u);
      memset(&dword_7FBC0, 0, 32u);
      dword_7FBE0[0] = 0;
      dword_7FBF0[0] = 0;
      dword_80F58 = 0;
      dword_7FBE4 = 0;
      dword_7FBE8 = 0;
      dword_7FBEC = 0;
      dword_7FBF4 = 0;
      dword_7FBF8 = 0;
      dword_7FBFC = 0;
    }
    current_system_uptime = get_system_uptime();
    current_asic_diff = &dword_7FBA0;
    total_mhash = 0.0;
    current_asic_sum_diff = &dword_7FBC0;
    asic_index = 0;
    time_difference = current_system_uptime - dword_7FA3C;
    dword_7FA3C = current_system_uptime;
    do
    {
      if ( get_global_buffer_value(asic_index) )
      {
        current_diff_value = dword_99ED98[2 * asic_index + 1];
        current_point = dword_7FBE0[asic_index];
        buffer_index = 10 * asic_index + current_point;
        incremented_point = current_point + 1;
        temp_calc = 1717986919 * incremented_point;
        point_counter = dword_7FBF0[asic_index];
        chain_buffer_pointer = &dword_7FA00[2 * buffer_index];
        if ( point_counter <= 9 )
          temp_calc = (int)dword_7FBF0;
        current_sum_diff_value = *current_asic_sum_diff;
        if ( point_counter <= 9 )
          *(_DWORD *)(temp_calc + 4 * asic_index) = ++point_counter;
        next_point_mod = incremented_point % 10;
        previous_diff_value = dword_99ED98[2 * asic_index];
        previous_asic_diff_next = current_asic_diff[1];
        dword_7FBE0[asic_index] = next_point_mod;
        previous_asic_diff_current = *current_asic_diff;
        current_asic_sum_diff_next = current_asic_sum_diff[1];
        *current_asic_diff = previous_diff_value;
        current_asic_diff[1] = current_diff_value;
        *((_QWORD *)chain_buffer_pointer + 12) = __PAIR64__(current_diff_value, previous_diff_value)
                                               - __PAIR64__(previous_asic_diff_next, previous_asic_diff_current);
        *current_asic_sum_diff = previous_diff_value - previous_asic_diff_current + current_sum_diff_value;
        chain_diff = __PAIR64__(current_diff_value, previous_diff_value)
                   - __PAIR64__(previous_asic_diff_next, previous_asic_diff_current)
                   + __PAIR64__(current_asic_sum_diff_next, current_sum_diff_value);
        current_asic_sum_diff[1] = HIDWORD(chain_diff);
        LODWORD(normalized_chain_diff) = normalize_exponent_sign(chain_diff);
        calculated_mhash = normalized_chain_diff * 4294967300.0 / (double)point_counter / (double)time_difference;
        set_chain_buffer_timestamp(asic_index);
        total_mhash = total_mhash + calculated_mhash / 1000000000.0;
        *(_QWORD *)current_asic_sum_diff -= *(_QWORD *)&dword_7FA00[20 * asic_index + 24 + 2 * next_point_mod];
      }
      ++asic_index;
      current_asic_diff += 2;
      current_asic_sum_diff += 2;
    }
    while ( asic_index != 4 );
    minute_counter = 0;
    initialize_global_variable();
    sprintf(byte_80FB8, "%.2f", total_mhash);
    if ( dword_80F5C == 1 )
    {
      qword_7FC00 = 0LL;
      memset(&unk_7FC08, 0, 2880u);
      dword_80748 = 0;
      dword_80F5C = 0;
    }
    system_uptime = get_system_uptime();
    previous_system_uptime = dword_7FA40;
    dword_7FA40 = system_uptime;
    if ( qword_99EE08 )
    {
      uptime_difference = system_uptime - previous_system_uptime;
      LODWORD(normalized_hashrate) = normalize_exponent_sign(4294967295LL * (qword_99EE08 - qword_7FC00));
      hashrate_divider = 1000000000.0;
      buffer_write_position = dword_80748;
      hashrate_buffer = (double *)&unk_7FC08;
      current_hashrate = normalized_hashrate / 1000000000.0;
      if ( uptime_difference )
        hashrate_divider = (double)uptime_difference;
      buffer_index_calculation = 381774871LL * ((unsigned int)dword_80748 >> 3);
      incremented_write_position = ++dword_80748;
      buffer_write_pointer = &dword_7FA00[2 * (buffer_write_position - 360 * (HIDWORD(buffer_index_calculation) >> 2))];
      if ( uptime_difference )
        current_hashrate = current_hashrate / hashrate_divider;
      cumulative_hashrate = 0.0;
      *((double *)buffer_write_pointer + 65) = current_hashrate;
      do
      {
        if ( incremented_write_position == minute_counter++ )
          goto LABEL_36;
        buffered_hashrate = *hashrate_buffer++;
        cumulative_hashrate = cumulative_hashrate + buffered_hashrate;
      }
      while ( minute_counter != 360 );
      if ( (unsigned int)incremented_write_position < 360 )
      {
LABEL_36:
        average_hashrate_divider = (double)incremented_write_position;
        goto LABEL_37;
      }
      average_hashrate_divider = 360.0;
LABEL_37:
      unk_80FC8 = cumulative_hashrate / average_hashrate_divider;
      perform_hardware_reset();
      current_tick = dword_7FA5C;
      tick_divisor = dword_7FA5C >> 31;
      qword_7FC00 = qword_99EE08;
    }
    else
    {
      current_tick = dword_7FA5C;
      tick_divisor = dword_7FA5C >> 31;
    }
  }
  if ( current_tick == 10 * (((int)((unsigned __int64)(1717986919LL * current_tick) >> 32) >> 2) - tick_divisor) )
  {
    if ( get_global_variable() == 2 )
      dump_nonce_info();
    current_tick = dword_7FA5C;
  }
  next_tick = current_tick + 1;
  next_tick_divisor = next_tick >> 31;
  dword_7FA5C = next_tick;
  if ( next_tick == 60 * (next_tick / 60) )
  {
    update_miner_statistics();
    next_tick = dword_7FA5C;
    next_tick_divisor = dword_7FA5C >> 31;
    if ( dword_7FA5C % 1800 )
      goto LABEL_10;
  }
  else if ( next_tick != 1800 * (next_tick / 1800) )
  {
    goto LABEL_5;
  }
  calculate_mining_effectiveness();
  next_tick = dword_7FA5C;
  next_tick_divisor = dword_7FA5C >> 31;
LABEL_10:
  if ( next_tick == 60 * (((int)((unsigned __int64)(2290649225LL * next_tick) >> 32) >> 5) - next_tick_divisor) )
  {
    dump_asic_nonce_count();
    dump_nonce_count();
    next_tick = dword_7FA5C;
    next_tick_divisor = dword_7FA5C >> 31;
  }
LABEL_5:
  if ( next_tick == 900 * (((int)((unsigned __int64)(2443359173LL * next_tick) >> 32) >> 9) - next_tick_divisor) )
    calculate_hashrate_and_log();
  return 0;
}
// 26900: variable 'normalized_chain_diff' is possibly undefined
// 26A1C: variable 'normalized_hashrate' is possibly undefined
// 7FA00: using guessed type int dword_7FA00[];
// 7FA3C: using guessed type int dword_7FA3C;
// 7FA40: using guessed type int dword_7FA40;
// 7FA5C: using guessed type int dword_7FA5C;
// 7FBA0: using guessed type int dword_7FBA0;
// 7FBC0: using guessed type int dword_7FBC0;
// 7FBE0: using guessed type int dword_7FBE0[];
// 7FBE4: using guessed type int dword_7FBE4;
// 7FBE8: using guessed type int dword_7FBE8;
// 7FBEC: using guessed type int dword_7FBEC;
// 7FBF0: using guessed type int dword_7FBF0[];
// 7FBF4: using guessed type int dword_7FBF4;
// 7FBF8: using guessed type int dword_7FBF8;
// 7FBFC: using guessed type int dword_7FBFC;
// 7FC00: using guessed type __int64 qword_7FC00;
// 80748: using guessed type int dword_80748;
// 80F58: using guessed type int dword_80F58;
// 80F5C: using guessed type int dword_80F5C;
// 99ED98: using guessed type _DWORD dword_99ED98[8];
// 99EE08: using guessed type __int64 qword_99EE08;

//----- (00026B80) --------------------------------------------------------
void __noreturn monitor_status_loop()
{
  prctl(15, "chk_status", 0);
  while ( 1 )
  {
    do
    {
      check_network_status();
      manage_miner_operations();
      get_next_sleep_interval();
    }
    while ( dword_7F7E0 );
    checkFanStatus(400u, 0);
  }
}
// 7F7E0: using guessed type int dword_7F7E0;

//----- (00026BD4) --------------------------------------------------------
int __fastcall dump_frequency_nonce_info(int current_frequency, int nonce_buffer_start)
{
  _DWORD *logging_category; // r0
  _DWORD *logging_cat_unused; // r0
  int formatted_str_length; // r4
  int chain_index; // r8
  int func_result; // r0
  _DWORD *logging_cat_inner; // r0
  int total_asics_count; // r9
  int asic_index; // r5
  int nonce_buffer_offset; // r7
  int nonce_count; // t1
  int next_asic_index; // r6
  int snprintf_result; // r8
  int nonces_mod_value_unused; // r0
  int nonces_mod_result; // r1
  _DWORD *logging_cat_mod_zero; // r8
  int domain_index; // r0
  _DWORD *logging_cat_new_line; // r0
  _DWORD *logging_cat_summary; // r0
  int chain_index_backup; // [sp+28h] [bp-130h]
  char formatted_nonce_counts[296]; // [sp+30h] [bp-128h] BYREF

  memset(formatted_nonce_counts, 0, 256u);
  logging_category = (_DWORD *)dword_8074C;
  if ( !dword_8074C )
  {
    logging_category = get_logging_category("bmminer_tuning");
    dword_8074C = (int)logging_category;
  }
  log_event(
    (int)logging_category,
    "thread.c",
    8,
    (int)"_tuning_freq_dump_nonce_info",
    28,
    611,
    20,
    (int)"\n current freq: %d\n",
    current_frequency);
  logging_cat_unused = (_DWORD *)dword_8074C;
  if ( !dword_8074C )
  {
    logging_cat_unused = get_logging_category("bmminer_tuning");
    dword_8074C = (int)logging_cat_unused;
  }
  formatted_str_length = 0;
  log_event(
    (int)logging_cat_unused,
    "thread.c",
    8,
    (int)"_tuning_freq_dump_nonce_info",
    28,
    612,
    20,
    (int)"\n dump asic nonce number...\n");
  for ( chain_index = 0; chain_index != 4; ++chain_index )
  {
    func_result = get_global_buffer_value(chain_index);
    if ( func_result )
    {
      logging_cat_inner = (_DWORD *)dword_8074C;
      if ( !dword_8074C )
      {
        logging_cat_inner = get_logging_category("bmminer_tuning");
        dword_8074C = (int)logging_cat_inner;
      }
      log_event(
        (int)logging_cat_inner,
        "thread.c",
        8,
        (int)"_tuning_freq_dump_nonce_info",
        28,
        616,
        20,
        (int)"Chain[%d] nonce:\n",
        chain_index);
      total_asics_count = get_global_variable_value();
      if ( total_asics_count > 0 )
      {
        asic_index = 0;
        chain_index_backup = chain_index;
        nonce_buffer_offset = nonce_buffer_start - 4 + (chain_index << 10);
        do
        {
          nonce_count = *(_DWORD *)(nonce_buffer_offset + 4);
          nonce_buffer_offset += 4;
          next_asic_index = asic_index + 1;
          snprintf_result = snprintf(
                              &formatted_nonce_counts[formatted_str_length],
                              256 - formatted_str_length,
                              "asic[%03d]=%-8d",
                              asic_index,
                              nonce_count);
          nonces_mod_value_unused = get_global_value();
          calculate_modulo(asic_index + 1, nonces_mod_value_unused);
          formatted_str_length += snprintf_result;
          if ( !nonces_mod_result )
          {
            formatted_str_length = 0;
            logging_cat_mod_zero = (_DWORD *)dword_8074C;
            if ( !dword_8074C )
            {
              logging_cat_mod_zero = get_logging_category("bmminer_tuning");
              dword_8074C = (int)logging_cat_mod_zero;
            }
            domain_index = call_external_function_with_check(asic_index, total_asics_count);
            log_event(
              (int)logging_cat_mod_zero,
              "thread.c",
              8,
              (int)"_tuning_freq_dump_nonce_info",
              28,
              625,
              20,
              (int)"domain %02d %s",
              domain_index,
              formatted_nonce_counts);
          }
          ++asic_index;
        }
        while ( next_asic_index != total_asics_count );
        chain_index = chain_index_backup;
      }
      logging_cat_new_line = (_DWORD *)dword_8074C;
      if ( !dword_8074C )
      {
        logging_cat_new_line = get_logging_category("bmminer_tuning");
        dword_8074C = (int)logging_cat_new_line;
      }
      log_event(
        (int)logging_cat_new_line,
        "thread.c",
        8,
        (int)"_tuning_freq_dump_nonce_info",
        28,
        630,
        20,
        (int)"Chain[%d] total nonce number = %d\n",
        chain_index,
        0);
      logging_cat_summary = (_DWORD *)dword_8074C;
      if ( !dword_8074C )
      {
        logging_cat_summary = get_logging_category("bmminer_tuning");
        dword_8074C = (int)logging_cat_summary;
      }
      func_result = log_event(
                      (int)logging_cat_summary,
                      "thread.c",
                      8,
                      (int)"_tuning_freq_dump_nonce_info",
                      28,
                      631,
                      20,
                      (int)&word_6A02C);
    }
  }
  return func_result;
}
// 26D94: variable 'nonces_mod_result' is possibly undefined
// 6A02C: using guessed type __int16 word_6A02C;
// 8074C: using guessed type int dword_8074C;
// 26BD4: using guessed type char s[296];

//----- (00026F34) --------------------------------------------------------
int __fastcall calculate_checksum(int block_number, int start_address)
{
  int global_variable_value; // r12
  int checksum; // r0
  int current_block; // r3
  int current_address; // r1
  int current_value; // t1

  global_variable_value = get_global_variable_value();
  if ( global_variable_value <= 0 )
    return 0;
  checksum = 0;
  current_block = 0;
  current_address = start_address + (block_number << 10) - 4;
  do
  {
    ++current_block;
    current_value = *(_DWORD *)(current_address + 4);
    current_address += 4;
    checksum += current_value;
  }
  while ( global_variable_value != current_block );
  return checksum;
}

//----- (00026F7C) --------------------------------------------------------
int __fastcall calculate_standard_deviation(int section_index, int base_address)
{
  int number_of_entries; // r0
  int sum_of_values; // r5
  int entry_counter; // r3
  int current_address; // r2
  int current_value; // t1
  int global_variable_value; // r0
  int average_value; // r5
  int number_of_entries_third_time; // r0
  int adjusted_base_address; // r1
  int sum_of_squared_diffs; // r4
  int diff_counter; // r2
  int diff_address; // r1
  int diff_value; // t1
  int number_of_diff_entries; // r0
  double std_dev_square_root; // r0

  number_of_entries = get_global_variable_value();
  if ( number_of_entries > 0 )
  {
    sum_of_values = 0;
    entry_counter = 0;
    current_address = base_address + (section_index << 10) - 4;
    do
    {
      ++entry_counter;
      current_value = *(_DWORD *)(current_address + 4);
      current_address += 4;
      sum_of_values += current_value;
    }
    while ( number_of_entries != entry_counter );
  }
  else
  {
    sum_of_values = 0;
  }
  global_variable_value = get_global_variable_value();
  average_value = call_external_function_with_check(sum_of_values, global_variable_value);
  number_of_entries_third_time = get_global_variable_value();
  if ( number_of_entries_third_time <= 0 )
    return get_global_variable_value();
  adjusted_base_address = base_address + (section_index << 10);
  sum_of_squared_diffs = 0;
  diff_counter = 0;
  diff_address = adjusted_base_address - 4;
  do
  {
    diff_value = *(_DWORD *)(diff_address + 4);
    diff_address += 4;
    ++diff_counter;
    sum_of_squared_diffs += (diff_value - average_value) * (diff_value - average_value);
  }
  while ( number_of_entries_third_time != diff_counter );
  number_of_diff_entries = get_global_variable_value();
  LODWORD(std_dev_square_root) = call_external_function_with_check(sum_of_squared_diffs, number_of_diff_entries);
  if ( (double)SLODWORD(std_dev_square_root) < 0.0 )
    std_dev_square_root = sqrt(std_dev_square_root);
  return LODWORD(std_dev_square_root);
}
// 2704C: variable 'std_dev_square_root' is possibly undefined

//----- (00027058) --------------------------------------------------------
int adjust_frequency_and_voltage()
{
  unsigned int initial_frequency; // r6
  int chain_index; // r4
  int global_flag; // r6
  int target_voltage; // r0
  unsigned int voltage_difference; // r2
  unsigned int voltage_step_count; // r8
  int adjusted_voltage; // r5
  int step_index; // r4
  int interim_step_value; // r5
  int unused_variable; // r3

  initial_frequency = dword_482A6C;
  chain_index = 0;
  dword_482A8C = 10 * ((dword_7EB70 * (dword_482A8C - dword_7EB60) / 100 + dword_7EB60) / 10);
  dword_482A6C = 5 * ((dword_7EB64 + dword_7EB70 * (dword_482A6C - dword_7EB64) / 100u) / 5);
  do
  {
    if ( get_global_buffer_value(chain_index) )
      SetChainFrequency(chain_index, (unsigned __int8)byte_482A70, initial_frequency, (char *)dword_482A6C, 0);
    ++chain_index;
  }
  while ( chain_index != 4 );
  global_flag = get_global_flag();
  target_voltage = dword_482A8C;
  voltage_difference = dword_482A8C - global_flag;
  if ( dword_482A8C - global_flag < 0 )
    voltage_difference = global_flag - dword_482A8C;
  voltage_step_count = voltage_difference / 20;
  if ( voltage_difference / 20 > 1 )
  {
    step_index = 1;
    do
    {
      interim_step_value = 5 * step_index++;
      unused_variable = interim_step_value;
      adjusted_voltage = global_flag - 4 * interim_step_value;
      if ( target_voltage > global_flag )
        adjusted_voltage = global_flag + 4 * unused_variable;
      SetVoltageBySteps(adjusted_voltage);
      usleep((__useconds_t)&loc_30D40);
      target_voltage = dword_482A8C;
    }
    while ( voltage_step_count != step_index );
  }
  else
  {
    adjusted_voltage = 0;
  }
  if ( target_voltage != adjusted_voltage )
    SetVoltageBySteps(target_voltage);
  return check_global_buffer_and_process(15u);
}
// 7EB60: using guessed type int dword_7EB60;
// 7EB64: using guessed type int dword_7EB64;
// 7EB70: using guessed type int dword_7EB70;
// 482A6C: using guessed type int dword_482A6C;
// 482A70: using guessed type char byte_482A70;
// 482A8C: using guessed type int dword_482A8C;

//----- (000271E8) --------------------------------------------------------
int optimize_frequency_tuning()
{
  float chain_nonce_stdev; // s0
  char previous_state; // r2
  unsigned int frequency_index; // r9
  int frequency_value; // r7
  int tuning_level; // r5
  int chain_index; // r4
  int chain_iter; // r8
  int frequency_iter; // r8
  int chain_idx; // r4
  int nonce_sum; // r4
  int shared_nonce_count; // r0
  __int64 calc_product1; // r2
  unsigned __int64 calc_product2; // r10
  int calc_temp_result; // r4
  double calc_adjusted_nonce_sum; // r0
  bool is_log_level_high; // cc
  int ideal_nonce_num; // s16
  int acceptable_chain_count; // r4
  int stats_offset; // r11
  int chain_counter; // r10
  int next_frequency_value; // r8
  int chain_idx_inner; // r0
  int nonce_count; // r0
  int total_nonce_count; // r1
  int nonce_iter; // r3
  char *nonce_array_ptr; // r2
  int current_nonce_value; // t1
  int global_variable_value; // r0
  char *end_nonce_array_ptr; // lr
  char *start_nonce_array_ptr; // r1
  char *ref_nonce_array_ptr; // r12
  char *target_buffer_ptr; // r0
  int nonce_difference; // r2
  int start_nonce_value; // t1
  int ref_nonce_value; // t1
  int final_tuning_level; // r4
  int chain_iter_final; // r9
  char *best_nonce_stats_ptr; // r5
  _BYTE *best_std_dev_ptr; // r8
  int best_level; // r12
  int min_std_dev; // r1
  _BYTE *std_dev_ptr; // r3
  int current_std_dev; // r2
  int current_std_dev_value; // t1
  _BYTE *best_std_dev_iter_ptr; // r0
  int level_counter; // r3
  int std_dev_inner; // r2
  int best_std_dev_value; // t1
  char *optimal_frequency_value; // r7
  int frequency_step_index; // [sp+8h] [bp-2A90h]
  unsigned int optimized_frequency_index; // [sp+8h] [bp-2A90h]
  char previous_state_store; // [sp+30h] [bp-2A68h]
  int ideal_nonce_nums[14]; // [sp+3Ch] [bp-2A5Ch]
  _BYTE chain_std_devs[36]; // [sp+74h] [bp-2A24h] BYREF
  char chain_nonce_counts[240]; // [sp+168h] [bp-2930h] BYREF
  char log_buffer[2040]; // [sp+258h] [bp-2840h] BYREF
  char nonce_info_buffer[4096]; // [sp+A58h] [bp-2040h] BYREF
  char frequency_info_buffer[4160]; // [sp+1A58h] [bp-1040h] BYREF

  prctl(15, "tuning_freq", 0);
  while ( get_global_variable() != 2 )
    get_next_sleep_interval();
  while ( 1 )
  {
    pthread_mutex_lock(&stru_7FA44);
    if ( get_global_flag() == dword_482A8C )
      break;
    pthread_mutex_unlock(&stru_7FA44);
    get_next_sleep_interval();
  }
  previous_state = byte_7EB78;
  byte_7EB78 = 0;
  previous_state_store = previous_state;
  pthread_mutex_unlock(&stru_7FA44);
  get_next_sleep_interval();
  if ( (unsigned int)globalLogLevel > 3 )
  {
    strcpy(frequency_info_buffer, "tuning freq start\n");
    logMessage(3, frequency_info_buffer, 0);
  }
  adjust_frequency_and_voltage();
  frequency_index = dword_482A6C;
  if ( dword_7EB68 <= 0 )
  {
    frequency_value = dword_482A6C;
    final_tuning_level = 0;
  }
  else
  {
    frequency_step_index = 0;
    frequency_value = dword_482A6C;
    tuning_level = 0;
    if ( (unsigned int)globalLogLevel > 3 )
      goto LABEL_32;
    while ( 1 )
    {
      for ( chain_index = 0; chain_index != 4; ++chain_index )
      {
        if ( get_global_buffer_value(chain_index) )
        {
          chain_nonce_stdev = unk_7EDD0;
          SetChainFrequency(chain_index, (unsigned __int8)byte_482A70, frequency_index, (char *)frequency_value, 0);
        }
      }
      chain_iter = 0;
      memcpy(nonce_info_buffer, &unk_81128, sizeof(nonce_info_buffer));
      get_next_sleep_interval();
      do
      {
        if ( get_global_buffer_value(chain_iter) )
        {
          global_variable_value = get_global_variable_value();
          if ( global_variable_value > 0 )
          {
            end_nonce_array_ptr = &nonce_info_buffer[1024 * chain_iter + 4 * global_variable_value];
            start_nonce_array_ptr = &nonce_info_buffer[1024 * chain_iter];
            ref_nonce_array_ptr = (char *)&unk_81124 + 1024 * chain_iter;
            target_buffer_ptr = &frequency_info_buffer[1024 * chain_iter];
            do
            {
              start_nonce_value = *(_DWORD *)start_nonce_array_ptr;
              start_nonce_array_ptr += 4;
              nonce_difference = start_nonce_value;
              ref_nonce_value = *((_DWORD *)ref_nonce_array_ptr + 1);
              ref_nonce_array_ptr += 4;
              *(_DWORD *)target_buffer_ptr = ref_nonce_value - nonce_difference;
              target_buffer_ptr += 4;
            }
            while ( start_nonce_array_ptr != end_nonce_array_ptr );
          }
        }
        ++chain_iter;
      }
      while ( chain_iter != 4 );
      frequency_iter = frequency_step_index;
      chain_idx = 0;
      dump_frequency_nonce_info(frequency_value, (int)frequency_info_buffer);
      do
      {
        if ( get_global_buffer_value(chain_idx) )
        {
          calculate_standard_deviation(chain_idx, (int)frequency_info_buffer);
          *(_DWORD *)&chain_std_devs[frequency_iter + 4] = (int)chain_nonce_stdev;
          nonce_count = get_global_variable_value();
          if ( nonce_count > 0 )
          {
            total_nonce_count = 0;
            nonce_iter = 0;
            nonce_array_ptr = &nonce_info_buffer[1024 * chain_idx + 4092];
            do
            {
              ++nonce_iter;
              current_nonce_value = *((_DWORD *)nonce_array_ptr + 1);
              nonce_array_ptr += 4;
              total_nonce_count += current_nonce_value;
            }
            while ( nonce_count != nonce_iter );
          }
          else
          {
            total_nonce_count = 0;
          }
          is_log_level_high = (unsigned int)globalLogLevel > 3;
          *(_DWORD *)&chain_nonce_counts[frequency_iter] = total_nonce_count;
          if ( is_log_level_high )
          {
            snprintf(
              log_buffer,
              2048u,
              "chain %d, nonce_stdev %d, nonce_num %d\n",
              chain_idx,
              (int)chain_nonce_stdev,
              total_nonce_count);
            logMessage(3, log_buffer, 0);
          }
        }
        ++chain_idx;
        frequency_iter += 60;
      }
      while ( chain_idx != 4 );
      nonce_sum = get_global_variable_value();
      shared_nonce_count = get_shared_value();
      calc_product1 = 180000000LL * frequency_value;
      calc_product2 = (unsigned int)calc_product1 * (unsigned __int64)(unsigned int)nonce_sum;
      calc_temp_result = calc_product1 * (nonce_sum >> 31) + nonce_sum * HIDWORD(calc_product1);
      LODWORD(calc_product1) = calc_product2 * shared_nonce_count;
      HIDWORD(calc_product2) += calc_temp_result;
      HIDWORD(calc_product1) = (calc_product2 * shared_nonce_count) >> 32;
      LODWORD(calc_adjusted_nonce_sum) = normalize_exponent_sign(calc_product1);
      is_log_level_high = (unsigned int)globalLogLevel > 3;
      ideal_nonce_num = (int)(calc_adjusted_nonce_sum * 1.45519152e-11);
      ideal_nonce_nums[tuning_level] = ideal_nonce_num;
      if ( is_log_level_high )
      {
        snprintf(log_buffer, 2048u, "ideal_nonce_num %d\n", ideal_nonce_num);
        logMessage(3, log_buffer, 0);
      }
      acceptable_chain_count = 0;
      stats_offset = frequency_step_index;
      chain_counter = 0;
      next_frequency_value = frequency_value - dword_7EB6C;
      do
      {
        chain_idx_inner = chain_counter++;
        if ( get_global_buffer_value(chain_idx_inner)
          && *(int *)&chain_std_devs[stats_offset + 4] <= 39
          && (double)*(int *)&chain_nonce_counts[stats_offset] > (double)ideal_nonce_num * 0.98 )
        {
          ++acceptable_chain_count;
        }
        stats_offset += 60;
      }
      while ( chain_counter != 4 );
      ++tuning_level;
      if ( get_status_flag() <= acceptable_chain_count )
        break;
      if ( dword_7EB68 <= tuning_level
        || (frequency_index = frequency_value, frequency_step_index += 4, tuning_level == 15) )
      {
        final_tuning_level = tuning_level;
        goto LABEL_45;
      }
      frequency_value = next_frequency_value;
      if ( (unsigned int)globalLogLevel > 3 )
      {
LABEL_32:
        snprintf(
          log_buffer,
          2048u,
          "level %d, freq_curr %d, freq_next %d\n",
          tuning_level,
          frequency_index,
          frequency_value);
        logMessage(3, log_buffer, 0);
      }
    }
    final_tuning_level = tuning_level;
    if ( (unsigned int)globalLogLevel > 3 )
    {
      strcpy(log_buffer, "all chain tuing done\n");
      logMessage(3, log_buffer, 0);
    }
  }
LABEL_45:
  chain_iter_final = 0;
  best_nonce_stats_ptr = chain_nonce_counts;
  best_std_dev_ptr = chain_std_devs;
  check_global_buffer_and_process(255u);
  optimized_frequency_index = frequency_value;
  do
  {
    if ( get_global_buffer_value(chain_iter_final) )
    {
      best_level = final_tuning_level - 1;
      if ( final_tuning_level > 0 )
      {
        min_std_dev = 2147483647;
        std_dev_ptr = best_std_dev_ptr;
        do
        {
          current_std_dev_value = *((_DWORD *)std_dev_ptr + 1);
          std_dev_ptr += 4;
          current_std_dev = current_std_dev_value;
          if ( min_std_dev >= current_std_dev_value )
            min_std_dev = current_std_dev;
        }
        while ( std_dev_ptr != &best_std_dev_ptr[4 * final_tuning_level] );
        best_std_dev_iter_ptr = best_std_dev_ptr;
        level_counter = 0;
        while ( 1 )
        {
          best_std_dev_value = *((_DWORD *)best_std_dev_iter_ptr + 1);
          best_std_dev_iter_ptr += 4;
          std_dev_inner = best_std_dev_value;
          if ( best_std_dev_value <= 39
            && (double)*(int *)&best_nonce_stats_ptr[4 * level_counter] > (double)ideal_nonce_nums[level_counter] * 0.98 )
          {
            break;
          }
          if ( (double)std_dev_inner < (double)min_std_dev * 1.25
            && (double)*(int *)&best_nonce_stats_ptr[4 * level_counter] > (double)ideal_nonce_nums[level_counter] * 0.98 )
          {
            break;
          }
          if ( final_tuning_level == ++level_counter )
            goto LABEL_62;
        }
        best_level = level_counter;
      }
LABEL_62:
      optimal_frequency_value = (char *)(dword_482A6C - dword_7EB6C * best_level);
      if ( (unsigned int)globalLogLevel > 3 )
      {
        snprintf(
          log_buffer,
          2048u,
          "chain %d best level %d, best freq %d\n",
          chain_iter_final,
          best_level,
          dword_482A6C - dword_7EB6C * best_level);
        logMessage(3, log_buffer, 0);
      }
      SetChainFrequency(
        chain_iter_final,
        (unsigned __int8)byte_482A70,
        optimized_frequency_index,
        optimal_frequency_value,
        0);
    }
    ++chain_iter_final;
    best_nonce_stats_ptr += 60;
    best_std_dev_ptr += 60;
  }
  while ( chain_iter_final != 4 );
  byte_7EB78 = previous_state_store;
  if ( (unsigned int)globalLogLevel > 3 )
  {
    strcpy(log_buffer, "tuning freq end\n");
    logMessage(3, log_buffer, 0);
  }
  return 0;
}
// 2743C: variable 'calc_adjusted_nonce_sum' is possibly undefined
// 27578: variable 'chain_nonce_stdev' is possibly undefined
// 7EB68: using guessed type int dword_7EB68;
// 7EB6C: using guessed type int dword_7EB6C;
// 7EB78: using guessed type char byte_7EB78;
// 7EB9C: using guessed type int globalLogLevel;
// 482A6C: using guessed type int dword_482A6C;
// 482A70: using guessed type char byte_482A70;
// 482A8C: using guessed type int dword_482A8C;
// 271E8: using guessed type _DWORD var_2A5C[14];
// 271E8: using guessed type char anonymous_0[4160];

//----- (00027940) --------------------------------------------------------
int initialize_asic_monitor_thread()
{
  int initial_thread_state; // r6
  pthread_attr_t thread_attributes; // [sp+4h] [bp-834h] BYREF
  char log_buffer[2064]; // [sp+28h] [bp-810h] BYREF

  initial_thread_state = dword_80750;
  if ( dword_80750 )
    return 0;
  pthread_attr_init(&thread_attributes);
  pthread_attr_setstacksize(&thread_attributes, 1048576u);
  dword_80750 = (int)calloc(1u, 64u);
  if ( create_thread_with_logging(
         dword_80750,
         &thread_attributes,
         (void *(*)(void *))MonitorASICHeartbeat,
         (void *)dword_80750) )
  {
    if ( (unsigned int)globalLogLevel > 3 )
    {
      strcpy(log_buffer, "create thread failed\n");
      logMessage(3, log_buffer, initial_thread_state);
    }
    return -1;
  }
  else
  {
    pthread_detach(*(_DWORD *)(dword_80750 + 12));
    if ( (unsigned int)globalLogLevel <= 3 )
      return 0;
    strcpy(log_buffer, "create thread\n");
    logMessage(3, log_buffer, 0);
    return 0;
  }
}
// 7EB9C: using guessed type int globalLogLevel;
// 80750: using guessed type int dword_80750;

//----- (00027A58) --------------------------------------------------------
int initialize_nonce_registration_thread()
{
  int old_global_thread_handle; // r6
  pthread_attr_t thread_attributes; // [sp+4h] [bp-834h] BYREF
  char log_buffer[2064]; // [sp+28h] [bp-810h] BYREF

  old_global_thread_handle = dword_80754;
  if ( dword_80754 )
    return 0;
  pthread_attr_init(&thread_attributes);
  pthread_attr_setstacksize(&thread_attributes, 8388608u);
  dword_80754 = (int)calloc(1u, 64u);
  if ( create_thread_with_logging(
         dword_80754,
         &thread_attributes,
         (void *(*)(void *))nonce_registration_loop,
         (void *)dword_80754) )
  {
    if ( (unsigned int)globalLogLevel > 3 )
    {
      strcpy(log_buffer, "create thread failed\n");
      logMessage(3, log_buffer, old_global_thread_handle);
    }
    return -1;
  }
  else
  {
    pthread_detach(*(_DWORD *)(dword_80754 + 12));
    if ( (unsigned int)globalLogLevel <= 3 )
      return 0;
    strcpy(log_buffer, "create thread\n");
    logMessage(3, log_buffer, 0);
    return 0;
  }
}
// 7EB9C: using guessed type int globalLogLevel;
// 80754: using guessed type int dword_80754;

//----- (00027B70) --------------------------------------------------------
int initialize_monitor_thread()
{
  int current_log_level; // r6
  pthread_attr_t thread_attr; // [sp+4h] [bp-834h] BYREF
  char log_buffer[2064]; // [sp+28h] [bp-810h] BYREF

  current_log_level = dword_80758;
  if ( dword_80758 )
    return 0;
  pthread_attr_init(&thread_attr);
  pthread_attr_setstacksize(&thread_attr, 2097152u);
  dword_80758 = (int)calloc(1u, 64u);
  if ( create_thread_with_logging(
         dword_80758,
         &thread_attr,
         (void *(*)(void *))check_system_status_thread,
         (void *)dword_80758) )
  {
    if ( (unsigned int)globalLogLevel > 3 )
    {
      strcpy(log_buffer, "create thread failed\n");
      logMessage(3, log_buffer, current_log_level);
    }
    return -1;
  }
  else
  {
    pthread_detach(*(_DWORD *)(dword_80758 + 12));
    if ( (unsigned int)globalLogLevel <= 3 )
      return 0;
    strcpy(log_buffer, "create thread\n");
    logMessage(3, log_buffer, 0);
    return 0;
  }
}
// 7EB9C: using guessed type int globalLogLevel;
// 80758: using guessed type int dword_80758;

//----- (00027C88) --------------------------------------------------------
int init_monitor_thread()
{
  int previous_thread_state; // r6
  pthread_attr_t thread_attributes; // [sp+4h] [bp-834h] BYREF
  char log_buffer[2064]; // [sp+28h] [bp-810h] BYREF

  previous_thread_state = dword_8075C;
  if ( dword_8075C )
    return 0;
  pthread_attr_init(&thread_attributes);
  pthread_attr_setstacksize(&thread_attributes, 2097152u);
  dword_8075C = (int)calloc(1u, 64u);
  if ( create_thread_with_logging(
         dword_8075C,
         &thread_attributes,
         (void *(*)(void *))monitor_status_loop,
         (void *)dword_8075C) )
  {
    if ( (unsigned int)globalLogLevel > 3 )
    {
      strcpy(log_buffer, "create thread failed\n");
      logMessage(3, log_buffer, previous_thread_state);
    }
    return -1;
  }
  else
  {
    pthread_detach(*(_DWORD *)(dword_8075C + 12));
    if ( (unsigned int)globalLogLevel <= 3 )
      return 0;
    strcpy(log_buffer, "create thread\n");
    logMessage(3, log_buffer, 0);
    return 0;
  }
}
// 7EB9C: using guessed type int globalLogLevel;
// 8075C: using guessed type int dword_8075C;

//----- (00027DA0) --------------------------------------------------------
int initialize_miner_thread()
{
  int is_initialized; // r6
  pthread_attr_t thread_attr; // [sp+4h] [bp-834h] BYREF
  char log_msg[2064]; // [sp+28h] [bp-810h] BYREF

  is_initialized = dword_80760;
  if ( dword_80760 )
    return 0;
  pthread_attr_init(&thread_attr);
  pthread_attr_setstacksize(&thread_attr, 2097152u);
  dword_80760 = (int)calloc(1u, 64u);
  if ( create_thread_with_logging(
         dword_80760,
         &thread_attr,
         (void *(*)(void *))optimize_frequency_tuning,
         (void *)dword_80760) )
  {
    if ( (unsigned int)globalLogLevel > 3 )
    {
      strcpy(log_msg, "create thread failed\n");
      logMessage(3, log_msg, is_initialized);
    }
    return -1;
  }
  else
  {
    pthread_detach(*(_DWORD *)(dword_80760 + 12));
    if ( (unsigned int)globalLogLevel <= 3 )
      return 0;
    strcpy(log_msg, "create thread\n");
    logMessage(3, log_msg, 0);
    return 0;
  }
}
// 7EB9C: using guessed type int globalLogLevel;
// 80760: using guessed type int dword_80760;

//----- (00027EB8) --------------------------------------------------------
void cancel_mining_thread()
{
  int mining_thread_data; // r5
  char log_message_buffer[2064]; // [sp+0h] [bp-810h] BYREF

  mining_thread_data = dword_80750;
  if ( dword_80750 && *(_DWORD *)(mining_thread_data + 12) != pthread_self() )
  {
    if ( (unsigned int)globalLogLevel > 3 )
    {
      strcpy(log_message_buffer, "cancel thread\n");
      logMessage(3, log_message_buffer, 0);
      mining_thread_data = dword_80750;
    }
    destroy_thread_and_semaphore(mining_thread_data);
    free((void *)dword_80750);
    dword_80750 = 0;
  }
}
// 7EB9C: using guessed type int globalLogLevel;
// 80750: using guessed type int dword_80750;

//----- (00027F58) --------------------------------------------------------
void cancel_thread_if_needed()
{
  int thread_data_ptr; // r5
  char log_buffer[2064]; // [sp+0h] [bp-810h] BYREF

  thread_data_ptr = dword_80754;
  if ( dword_80754 && *(_DWORD *)(thread_data_ptr + 12) != pthread_self() )
  {
    if ( (unsigned int)globalLogLevel > 3 )
    {
      strcpy(log_buffer, "cancel thread\n");
      logMessage(3, log_buffer, 0);
      thread_data_ptr = dword_80754;
    }
    destroy_thread_and_semaphore(thread_data_ptr);
    free((void *)dword_80754);
    dword_80754 = 0;
  }
}
// 7EB9C: using guessed type int globalLogLevel;
// 80754: using guessed type int dword_80754;

//----- (00027FF8) --------------------------------------------------------
void terminate_worker_thread()
{
  int worker_thread_struct; // r5
  char log_message_buffer[2064]; // [sp+0h] [bp-810h] BYREF

  worker_thread_struct = dword_80758;
  if ( dword_80758 && *(_DWORD *)(worker_thread_struct + 12) != pthread_self() )
  {
    if ( (unsigned int)globalLogLevel > 3 )
    {
      strcpy(log_message_buffer, "cancel thread\n");
      logMessage(3, log_message_buffer, 0);
      worker_thread_struct = dword_80758;
    }
    destroy_thread_and_semaphore(worker_thread_struct);
    free((void *)dword_80758);
    dword_80758 = 0;
  }
}
// 7EB9C: using guessed type int globalLogLevel;
// 80758: using guessed type int dword_80758;

//----- (00028098) --------------------------------------------------------
void shutdown_miner_thread()
{
  int active_thread_id; // r5
  char log_buffer[2064]; // [sp+0h] [bp-810h] BYREF

  active_thread_id = dword_8075C;
  if ( dword_8075C && *(_DWORD *)(active_thread_id + 12) != pthread_self() )
  {
    if ( (unsigned int)globalLogLevel > 3 )
    {
      strcpy(log_buffer, "cancel thread\n");
      logMessage(3, log_buffer, 0);
      active_thread_id = dword_8075C;
    }
    destroy_thread_and_semaphore(active_thread_id);
    free((void *)dword_8075C);
    dword_8075C = 0;
  }
}
// 7EB9C: using guessed type int globalLogLevel;
// 8075C: using guessed type int dword_8075C;

//----- (00028138) --------------------------------------------------------
int __fastcall setUartBaudRate(signed int baudRate)
{
  char logBuffer[2056]; // [sp+0h] [bp-808h] BYREF

  if ( baudRate > (int)&unk_2DC6C0 )
  {
    set_uart_relay_based_on_state();
    get_next_sleep_interval();
  }
  if ( (unsigned int)globalLogLevel > 3 )
  {
    snprintf(logBuffer, 2048u, "set UART baud to %d\n", baudRate);
    logMessage(3, logBuffer, 0);
  }
  scan_chip_versions(baudRate);
  sub_1E160();
  return update_miner_calibration();
}
// 7EB9C: using guessed type int globalLogLevel;

//----- (000281B8) --------------------------------------------------------
int initialize_uart_and_check_status()
{
  setUartBaudRate(12000000);
  return get_next_sleep_interval();
}

//----- (000281D4) --------------------------------------------------------
int __fastcall submit_work_to_bitmain(const void *work_data, size_t work_size)
{
  int submit_result; // [sp+Ch] [bp-Ch] BYREF

  return send_and_receive_data((int)aBitmainSubmitN, work_data, work_size, &submit_result);
}

//----- (00028208) --------------------------------------------------------
int __fastcall send_api_status(const void *data_buffer, size_t data_size)
{
  int response_code; // [sp+Ch] [bp-Ch] BYREF

  return send_and_receive_data((int)aBitmainApiStat, data_buffer, data_size, &response_code);
}

//----- (0002823C) --------------------------------------------------------
int initialize_miner_socket()
{
  puts("bmminer_socket_init");
  while ( setup_network_server((int)&off_7E3F8, 4) )
    sleep(3u);
  puts("regist ..");
  while ( 1 )
  {
    initialize_miner_connection((int)aBitmainSubmitN);
    if ( !initialize_miner_connection((int)aBitmainApiStat) )
      break;
    sleep(3u);
  }
  puts("regist done!");
  return 0;
}
// 7E3F8: using guessed type int (*off_7E3F8)();

//----- (000282C8) --------------------------------------------------------
int __fastcall set_verbose_logging(_BYTE *verbose_flag_pointer)
{
  *verbose_flag_pointer = 1;
  loggingVerbose = 1;
  return 0;
}
// 482A5C: using guessed type char loggingVerbose;

//----- (000282E4) --------------------------------------------------------
void __noreturn fatal_error_logging(const char *format, ...)
{
  va_list args_list; // [sp+14h] [bp-Ch] BYREF

  va_start(args_list, format);
  vsnprintf(byte_80768, 512u, format, args_list);
  logMessage(3, byte_80768, 1);
  exit(1);
}

//----- (0002832C) --------------------------------------------------------
int __fastcall initialize_miner_communication(int communication_handle)
{
  set_value(communication_handle, &dword_80968);
  return 0;
}
// 80968: using guessed type int dword_80968;

//----- (00028344) --------------------------------------------------------
int __fastcall set_default_value(int default_value)
{
  set_value(default_value, &dword_8096C);
  return 0;
}
// 8096C: using guessed type int dword_8096C;

//----- (0002835C) --------------------------------------------------------
int __fastcall initialize_miner_version(int version_code)
{
  set_value(version_code, &minerVersionFilename);
  return 0;
}
// 80970: using guessed type int minerVersionFilename;

//----- (00028374) --------------------------------------------------------
int __fastcall initialize_hardware(int hardware_id)
{
  set_value(hardware_id, &dword_58E3F0);
  return 0;
}
// 58E3F0: using guessed type int dword_58E3F0;

//----- (0002838C) --------------------------------------------------------
void __fastcall __noreturn print_mining_support_message(const char *additional_message)
{
  char *final_message; // r0

  printf("%s\nBuilt with bitmain_c5 mining support.\n", byte_80974);
  final_message = generate_help_message((const char *)dword_99EE20, additional_message);
  printf("%s", final_message);
  fflush((FILE *)stdout);
  exit(0);
}
// 7F79C: using guessed type int stdout;
// 99EE20: using guessed type int dword_99EE20;

//----- (000283E4) --------------------------------------------------------
int update_api_statistics()
{
  int errno_value; // r4
  char *error_str; // r0
  _DWORD *miner_status_and_init; // r8
  __int64 chain_index; // r4
  _DWORD *temp_buffer; // r10
  const char *cmd_result; // r0
  char *result_str; // r4
  size_t result_len; // r0
  size_t send_len; // r0
  unsigned int *reference_counter; // r3
  unsigned int current_count; // r2
  unsigned int updated_count; // r2
  _DWORD *miner_status_local; // r7
  _DWORD *inited; // r0
  struct sysinfo sys_info; // [sp+18h] [bp-868h] BYREF
  char log_buffer[2088]; // [sp+58h] [bp-828h] BYREF

  prctl(15, "api", 0);
  while ( !*(_BYTE *)(dword_58E354 + 364) )
  {
    pthread_mutex_lock(&stru_80A74);
    pthread_cond_wait(&cond, &stru_80A74);
    if ( sysinfo(&sys_info) )
    {
      if ( loggingDebug || loggingVerbose || loggingThreshold > 5 )
      {
        errno_value = *_errno_location();
        error_str = strerror(errno_value);
        snprintf(log_buffer, 2048u, "Failed to get sysinfo, errno:%u, reason:%s\n", errno_value, error_str);
        logMessage(6, log_buffer, 0);
      }
      dword_5903F8 = time(0);
    }
    else
    {
      dword_5903F8 = sys_info.uptime;
    }
    miner_status_and_init = get_miner_status_and_init();
    process_initialization_status((int)miner_status_and_init);
    chain_index = 0LL;
    updateMinerChainNumber((int)miner_status_and_init);
    calculate_5s_hash_rate((int)miner_status_and_init);
    update_miner_30m_rate((int)miner_status_and_init);
    calculate_average_hashrate((int)miner_status_and_init);
    get_optimal_hash_rate_json((int)miner_status_and_init);
    process_miner_rate_unit((int)miner_status_and_init);
    process_fan_num_request((int)miner_status_and_init);
    updateFanSpeeds_0((int)miner_status_and_init);
    temp_buffer = get_asic_status();
    do
    {
      if ( get_global_buffer_value(chain_index) )
      {
        miner_status_local = get_miner_status_and_init();
        if ( logEnabled && (loggingDebug || loggingVerbose || loggingThreshold > 6) )
        {
          snprintf(log_buffer, 2048u, "%s: now i = %d", "bitmain_update_api_stats", (_DWORD)chain_index);
          logMessage(7, log_buffer, 0);
        }
        inited = (_DWORD *)init_asic_task(chain_index);
        process_task_if_valid(miner_status_local, "index", inited);
        updateMinerChainFrequency((int)miner_status_local, chain_index);
        updateMinerChainIdealRate((int)miner_status_local, chain_index);
        check_and_process_chain_rate((int)miner_status_local, chain_index);
        process_chain_task_result((int)miner_status_local, chain_index);
        get_asic_status_or_log_error(miner_status_local, chain_index);
        handle_temperature_request((int)miner_status_local, chain_index);
        process_temperature_control((int)miner_status_local, chain_index);
        process_temperature_monitoring((int)miner_status_local, chain_index);
        check_parameters_and_process_task((int)miner_status_local, chain_index);
        update_miner_chain_rate((int)miner_status_local, chain_index);
        check_and_process_nonce_task((int)miner_status_local, chain_index);
        check_and_process_chain_eeprom_task((int)miner_status_local, chain_index);
        process_chain_serial_number(miner_status_local, chain_index);
        process_voltage_level_task(miner_status_local, chain_index);
        configure_eeprom_frequency(miner_status_local, chain_index);
        process_eeprom_task(miner_status_local, chain_index);
        process_eeprom_ft_task(miner_status_local, chain_index);
        process_eeprom_code_task(miner_status_local, chain_index);
        add_to_buffer(temp_buffer, miner_status_local);
      }
      ++chain_index;
    }
    while ( chain_index != 4 );
    process_task_if_valid(miner_status_and_init, "chain", temp_buffer);
    process_miner_version_request((int)miner_status_and_init);
    process_total_hash_json((int)miner_status_and_init);
    process_miner_id_request((int)miner_status_and_init);
    handle_error_code_task(miner_status_and_init);
    cmd_result = initialize_and_process_command(miner_status_and_init, 0);
    result_str = (char *)cmd_result;
    if ( cmd_result )
    {
      if ( logEnabled && (loggingDebug || loggingVerbose || loggingThreshold > 6) )
      {
        result_len = strlen(cmd_result);
        snprintf(log_buffer, 2048u, "%s(%d) : %s", "bitmain_update_api_stats", result_len + 1, result_str);
        logMessage(7, log_buffer, 0);
      }
      send_len = strlen(result_str);
      send_api_status(result_str, send_len + 1);
      free(result_str);
    }
    if ( miner_status_and_init )
    {
      if ( miner_status_and_init[1] != -1 )
      {
        reference_counter = miner_status_and_init + 1;
        __dmb(11u);
        do
        {
          current_count = __ldrex(reference_counter);
          updated_count = current_count - 1;
        }
        while ( __strex(updated_count, reference_counter) );
        if ( !updated_count )
          handle_task(miner_status_and_init);
      }
    }
    pthread_mutex_unlock(&stru_80A74);
  }
  return 0;
}
// 7EBA0: using guessed type int loggingThreshold;
// 482A5C: using guessed type char loggingVerbose;
// 482A5D: using guessed type char logEnabled;
// 58E354: using guessed type int dword_58E354;
// 5903F8: using guessed type int dword_5903F8;
// 590404: using guessed type char loggingDebug;

//----- (00028878) --------------------------------------------------------
void __noreturn shutdown_miner_and_exit()
{
  sigaction(15, &unk_592464, 0);
  sigaction(2, &unk_594524, 0);
  sigaction(6, &unk_58E35C, 0);
  powerOffHashboard();
  exit(0);
}

//----- (000288C4) --------------------------------------------------------
char *__fastcall json_file_load_error(char *file_path)
{
  bool is_negative_flag; // nf
  _DWORD *json_decode_result; // r0
  size_t file_path_length; // r6
  size_t error_message_length; // r6
  char *memory_logging; // r4
  char unused_buffer[92]; // [sp+Ch] [bp-114h] BYREF
  char error_detail_buffer[184]; // [sp+68h] [bp-B8h] BYREF

  if ( !dword_80AC0 )
    dword_80AC0 = (int)_strdup(file_path);
  is_negative_flag = dword_80AC4 - 9 < 0;
  ++dword_80AC4;
  if ( !(is_negative_flag ^ __OFSUB__(dword_80AC4, 10) | (dword_80AC4 == 10)) )
    return "Too many levels of JSON includes (limit 10) or a loop";
  json_decode_result = update_miner_status_from_config(file_path, 0, unused_buffer);
  if ( json_decode_result && !*json_decode_result )
    return parse_config_options(json_decode_result, 1);
  file_path_length = strlen(file_path);
  error_message_length = file_path_length + strlen(error_detail_buffer) + 35;
  memory_logging = (char *)allocate_memory_logging(error_message_length, "bmminer.c", "load_config", 902);
  snprintf(memory_logging, error_message_length, "JSON decode of file '%s' failed\n %s", file_path, error_detail_buffer);
  return memory_logging;
}
// 80AC0: using guessed type int dword_80AC0;
// 80AC4: using guessed type int dword_80AC4;
// 288C4: using guessed type char var_114[92];

//----- (000289B8) --------------------------------------------------------
char *__fastcall parse_config_options(_DWORD *config_task, int is_user_config)
{
  char **option_entry; // r4
  char *option_type; // r3
  const char *option_name; // r0
  char *option_values; // r10
  char *current_value; // r5
  _DWORD *config_option_task; // r0
  int option_attribute; // r1
  int task_type; // r3
  char *error_message; // r3
  _DWORD *include_task; // r0
  char *include_file_name; // r0
  _BYTE *flag_pointer; // r0
  int flag_set_result; // r0
  _DWORD *array_element_task; // r10
  unsigned int array_index; // r5
  _DWORD *sub_task; // r0
  int sub_task_result; // r0
  _DWORD *task_arg2; // [sp+10h] [bp-838h]
  char *option_values_backup; // [sp+10h] [bp-838h]
  char *flag_set_result_backup; // [sp+14h] [bp-834h]
  char *current_value_backup; // [sp+14h] [bp-834h]
  _DWORD *second_element_if_ready; // [sp+18h] [bp-830h]
  char *sub_task_result_backup; // [sp+1Ch] [bp-82Ch]
  char error_buffer[2088]; // [sp+20h] [bp-828h] BYREF

  if ( is_user_config && !dword_80B90 )
    dword_80B90 = 1;
  if ( dword_7E61C == 16 )
    goto LABEL_28;
  if ( (dword_7E61C & 8) != 0 )
LABEL_53:
    _assert_fail("!(opt->type & OPT_SUBTABLE)", "bmminer.c", 734u, "parse_config");
  option_entry = &off_7E634;
  while ( 1 )
  {
    option_name = *(option_entry - 7);
    if ( !option_name )
    {
      option_type = option_entry[1];
      if ( option_type == (char *)16 )
        break;
      goto LABEL_8;
    }
    option_values = _strdup(option_name);
    current_value = strtok(option_values, "|");
    if ( !current_value )
      goto LABEL_27;
    while ( 2 )
    {
      if ( current_value[1] != 45 )
        goto LABEL_12;
      config_option_task = (_DWORD *)initiate_task_if_ready(config_task, current_value + 2);
      if ( !config_option_task )
        goto LABEL_12;
      option_attribute = (int)*(option_entry - 6);
      task_type = *config_option_task;
      if ( (option_attribute & 6) == 0 )
      {
LABEL_18:
        if ( (unsigned int)(task_type - 5) > 1 )
        {
          error_message = "Invalid value";
          goto LABEL_21;
        }
        flag_pointer = *(option_entry - 2);
        if ( (option_attribute & 1) == 0 )
        {
          if ( task_type == 5 )
            set_flag_to_true(flag_pointer);
          else
            reset_first_byte(flag_pointer);
          goto LABEL_12;
        }
        error_message = (char *)((int (__fastcall *)(_BYTE *))*(option_entry - 5))(flag_pointer);
        goto LABEL_33;
      }
      if ( task_type == 2 )
      {
        task_arg2 = get_second_element_if_ready(config_option_task);
        flag_set_result = ((int (__fastcall *)(_DWORD *, _DWORD))*(option_entry - 4))(task_arg2, *(option_entry - 2));
        error_message = (char *)flag_set_result;
        if ( *(option_entry - 6) == (char *)4 )
        {
          flag_set_result_backup = (char *)flag_set_result;
          set_value((int)task_arg2, *(option_entry - 2));
          error_message = flag_set_result_backup;
        }
LABEL_33:
        if ( !error_message )
          goto LABEL_12;
        if ( is_user_config )
          goto LABEL_22;
LABEL_35:
        snprintf(s, 200u, "Parsing JSON option %s: %s", current_value, error_message);
        return s;
      }
      if ( task_type != 1 )
        goto LABEL_18;
      option_values_backup = option_values;
      array_element_task = config_option_task;
      current_value_backup = current_value;
      array_index = 0;
      if ( !get_associated_pointer_or_null(config_option_task) )
      {
LABEL_46:
        option_values = option_values_backup;
        goto LABEL_12;
      }
      while ( 1 )
      {
        sub_task = get_task_by_index(array_element_task, array_index);
        if ( !sub_task )
          goto LABEL_46;
        if ( *sub_task == 2 )
          break;
        if ( !*sub_task )
        {
          error_message = parse_config_options(sub_task, 0);
          goto LABEL_49;
        }
LABEL_45:
        if ( (unsigned int)get_associated_pointer_or_null(array_element_task) <= ++array_index )
          goto LABEL_46;
      }
      second_element_if_ready = get_second_element_if_ready(sub_task);
      sub_task_result = ((int (__fastcall *)(_DWORD *, _DWORD))*(option_entry - 4))(
                          second_element_if_ready,
                          *(option_entry - 2));
      error_message = (char *)sub_task_result;
      if ( *(option_entry - 6) == (char *)4 )
      {
        sub_task_result_backup = (char *)sub_task_result;
        set_value((int)second_element_if_ready, *(option_entry - 2));
        error_message = sub_task_result_backup;
      }
LABEL_49:
      if ( !error_message )
        goto LABEL_45;
      option_values = option_values_backup;
      current_value = current_value_backup;
LABEL_21:
      if ( !is_user_config )
        goto LABEL_35;
LABEL_22:
      if ( loggingDebug || loggingVerbose || loggingThreshold > 2 )
      {
        snprintf(error_buffer, 2048u, "Invalid config option %s: %s", current_value, error_message);
        logMessage(3, error_buffer, 0);
      }
      dword_80B90 = -1;
LABEL_12:
      current_value = strtok(0, "|");
      if ( current_value )
        continue;
      break;
    }
LABEL_27:
    free(option_values);
    option_type = option_entry[1];
    if ( option_type == (char *)16 )
      break;
LABEL_8:
    option_entry += 7;
    if ( ((unsigned __int8)option_type & 8) != 0 )
      goto LABEL_53;
  }
LABEL_28:
  include_task = (_DWORD *)initiate_task_if_ready(config_task, "include");
  if ( !include_task || *include_task != 2 )
    return 0;
  include_file_name = (char *)get_second_element_if_ready(include_task);
  return json_file_load_error(include_file_name);
}
// 7E61C: using guessed type int dword_7E61C;
// 7E634: using guessed type char *off_7E634;
// 7EBA0: using guessed type int loggingThreshold;
// 80B90: using guessed type int dword_80B90;
// 482A5C: using guessed type char loggingVerbose;
// 590404: using guessed type char loggingDebug;

//----- (00028D40) --------------------------------------------------------
char *__fastcall check_integer_within_range(const char *input_string, _DWORD *parsed_number)
{
  char *error_message; // r0

  error_message = parse_integer(input_string, parsed_number);
  if ( !error_message && *parsed_number > 9999u )
    return "Value out of range";
  return error_message;
}

//----- (00028D70) --------------------------------------------------------
char *__fastcall check_user_input_value(const char *input_string, _DWORD *parsed_value)
{
  char *parse_result; // r0

  parse_result = parse_integer(input_string, parsed_value);
  if ( !parse_result && *parsed_value > 100u )
    return "Value out of range";
  return parse_result;
}

//----- (00028D9C) --------------------------------------------------------
char *__fastcall validate_number_string(const char *number_string, _DWORD *output_integer)
{
  char *parse_status; // r0

  parse_status = parse_integer(number_string, output_integer);
  if ( !parse_status && (unsigned int)(*output_integer - 1) > 65534 )
    return "Value out of range";
  return parse_status;
}

//----- (00028DD0) --------------------------------------------------------
int __fastcall log_null_work_message(const char *function_name, const char *file_name, int line_number)
{
  char log_message_buffer[2056]; // [sp+8h] [bp-808h] BYREF

  snprintf(
    log_message_buffer,
    2048u,
    "Free work called with NULL work from %s %s:%d",
    function_name,
    file_name,
    line_number);
  return logMessage(3, log_message_buffer, 0);
}

//----- (00028E18) --------------------------------------------------------
int __fastcall report_rwlock_error(const char *function_name, int line_number)
{
  int *errno_ptr; // r0
  char error_message[2064]; // [sp+10h] [bp-810h] BYREF

  errno_ptr = _errno_location();
  snprintf(
    error_message,
    2048u,
    "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
    *errno_ptr,
    "bmminer.c",
    function_name,
    line_number);
  return logMessage(3, error_message, 1);
}

//----- (00028E74) --------------------------------------------------------
int __fastcall initialize_rwlock(pthread_rwlock_t *rwlock_ptr, const char *function_name, int line_number)
{
  int init_result; // r0
  int *errno_ptr; // r0
  char error_message_buffer[2064]; // [sp+10h] [bp-810h] BYREF

  init_result = pthread_rwlock_init(rwlock_ptr, 0);
  if ( init_result )
  {
    errno_ptr = _errno_location();
    snprintf(
      error_message_buffer,
      2048u,
      "Failed to pthread_rwlock_init errno=%d in %s %s():%d",
      *errno_ptr,
      "bmminer.c",
      function_name,
      line_number);
    return logMessage(3, error_message_buffer, 1);
  }
  return init_result;
}

//----- (00028EE8) --------------------------------------------------------
int __fastcall write_lock_with_error_logging(pthread_rwlock_t *rwlock, const char *function_name, int line_number)
{
  int lock_result; // r0
  int *errno_ptr; // r0
  char error_message_buffer[2064]; // [sp+10h] [bp-810h] BYREF

  lock_result = pthread_rwlock_wrlock(rwlock);
  if ( lock_result )
  {
    errno_ptr = _errno_location();
    snprintf(
      error_message_buffer,
      2048u,
      "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *errno_ptr,
      "bmminer.c",
      function_name,
      line_number);
    return logMessage(3, error_message_buffer, 1);
  }
  return lock_result;
}

//----- (00028F5C) --------------------------------------------------------
int __fastcall log_mutex_error_unlock(const char *function_name, int line_number)
{
  int *errno_pointer; // r0
  char error_message_buffer[2064]; // [sp+10h] [bp-810h] BYREF

  errno_pointer = _errno_location();
  snprintf(
    error_message_buffer,
    2048u,
    "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
    *errno_pointer,
    "bmminer.c",
    function_name,
    line_number);
  return logMessage(3, error_message_buffer, 1);
}

//----- (00028FB8) --------------------------------------------------------
int __fastcall log_mutex_init_failure(const char *function_name, int line_number)
{
  int *errno_pointer; // r0
  char error_message[2064]; // [sp+10h] [bp-810h] BYREF

  errno_pointer = _errno_location();
  snprintf(
    error_message,
    2048u,
    "Failed to pthread_mutex_init errno=%d in %s %s():%d",
    *errno_pointer,
    "bmminer.c",
    function_name,
    line_number);
  return logMessage(3, error_message, 1);
}

//----- (00029014) --------------------------------------------------------
int __fastcall log_mutex_error(const char *function_name, int line_number)
{
  int *errno_ptr; // r0
  char error_msg[2064]; // [sp+10h] [bp-810h] BYREF

  errno_ptr = _errno_location();
  snprintf(
    error_msg,
    2048u,
    "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
    *errno_ptr,
    "bmminer.c",
    function_name,
    line_number);
  return logMessage(3, error_msg, 1);
}

//----- (00029070) --------------------------------------------------------
int __fastcall initialize_sync_primitives(int sync_struct_ptr, const char *error_message, int error_code)
{
  if ( pthread_mutex_init((pthread_mutex_t *)sync_struct_ptr, 0) )
    log_mutex_init_failure(error_message, error_code);
  return initialize_rwlock((pthread_rwlock_t *)(sync_struct_ptr + 24), error_message, error_code);
}

//----- (000290B4) --------------------------------------------------------
_DWORD *create_work_structure()
{
  _DWORD *work_buffer; // r4
  int total_work_counter; // r5
  int unlock_result; // r0
  _DWORD *result; // r0
  int *v4; // r0
  int *v5; // r0
  int *v6; // r0
  int *v7; // r0
  char s[2064]; // [sp+10h] [bp-810h] BYREF

  work_buffer = allocate_buffers_ignore_incomplete_words(1u, 448u, "bmminer.c", "make_work", 1368);
  if ( !work_buffer )
  {
    strcpy(s, "Failed to calloc work in make_work");
    logMessage(3, s, 1);
  }
  if ( pthread_mutex_lock(&stru_590408) )
  {
    v4 = _errno_location();
    snprintf(s, 2048u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v4, "bmminer.c", "total_work_inc", 1359);
    logMessage(3, s, 1);
    if ( !pthread_rwlock_wrlock(&rwlock) )
      goto LABEL_5;
  }
  else if ( !pthread_rwlock_wrlock(&rwlock) )
  {
    goto LABEL_5;
  }
  v5 = _errno_location();
  snprintf(s, 2048u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v5, "bmminer.c", "total_work_inc", 1359);
  logMessage(3, s, 1);
LABEL_5:
  total_work_counter = dword_80B94++;
  if ( pthread_rwlock_unlock(&rwlock) )
  {
    v6 = _errno_location();
    snprintf(s, 2048u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v6, "bmminer.c", "total_work_inc", 1361);
    logMessage(3, s, 1);
  }
  unlock_result = pthread_mutex_unlock(&stru_590408);
  if ( unlock_result )
  {
    v7 = _errno_location();
    snprintf(s, 2048u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v7, "bmminer.c", "total_work_inc", 1361);
    unlock_result = logMessage(3, s, 1);
  }
  off_7ECC4(unlock_result);
  result = work_buffer;
  work_buffer[85] = total_work_counter;
  return result;
}
// 7ECC4: using guessed type int (__fastcall *off_7ECC4)(_DWORD);
// 80B94: using guessed type int dword_80B94;
// 590408: using guessed type pthread_mutex_t stru_590408;

//----- (000292E0) --------------------------------------------------------
char *__fastcall validate_integer_within_range(const char *input_str, _DWORD *parsed_int, int min_value, int max_value)
{
  char *parse_result; // r0
  _BOOL4 is_less_than_min; // r4
  int range_check_result; // r3

  parse_result = parse_integer(input_str, parsed_int);
  if ( !parse_result )
  {
    is_less_than_min = *parsed_int < min_value;
    if ( *parsed_int > max_value )
      range_check_result = is_less_than_min | 1;
    else
      range_check_result = is_less_than_min;
    if ( range_check_result )
      return "Value out of range";
  }
  return parse_result;
}

//----- (0002932C) --------------------------------------------------------
int __fastcall parse_range(const char *range_str, _DWORD *start, _DWORD *end)
{
  int parsed_count; // r0

  parsed_count = sscanf(range_str, "%d-%d", start, end);
  if ( parsed_count == 1 )
    *end = *start;
  return parsed_count;
}

//----- (0002935C) --------------------------------------------------------
char *__fastcall get_config_file_path(char *output_buffer)
{
  size_t initial_path_length; // r0
  char *conf_file_path; // r12
  size_t buffer_offset; // lr
  char *final_path; // r0
  char *home_env_value; // r0

  if ( dword_58E3F0 && *(_BYTE *)dword_58E3F0 )
    return strcpy(output_buffer, (const char *)dword_58E3F0);
  if ( getenv("HOME") && *getenv("HOME") )
  {
    home_env_value = getenv("HOME");
    strcpy((char *)stpcpy(output_buffer, home_env_value), "/");
  }
  else
  {
    *output_buffer = 0;
  }
  strcat(output_buffer, ".bmminer/");
  mkdir(output_buffer, 511u);
  initial_path_length = strlen(output_buffer);
  conf_file_path = &output_buffer[initial_path_length];
  buffer_offset = initial_path_length;
  final_path = *(char **)"bmminer.conf";
  *(_DWORD *)&output_buffer[buffer_offset] = *(_DWORD *)"bmminer.conf";
  strcpy(conf_file_path + 4, "ner.conf");
  return final_path;
}
// 1203C: using guessed type int __fastcall stpcpy(_DWORD, _DWORD);
// 58E3F0: using guessed type int dword_58E3F0;

//----- (00029458) --------------------------------------------------------
void load_default_miner_config()
{
  dword_80AC0 = (int)allocate_memory_logging(4096u, "bmminer.c", "load_default_config", 950);
  get_config_file_path((char *)dword_80AC0);
  if ( access((const char *)dword_80AC0, 4) )
  {
    free((void *)dword_80AC0);
    dword_80AC0 = 0;
  }
  else
  {
    json_file_load_error((char *)dword_80AC0);
  }
}
// 80AC0: using guessed type int dword_80AC0;

//----- (000294B8) --------------------------------------------------------
void *__fastcall setMiningTarget(void *minerConfig)
{
  double targetValueReciprocal; // d0
  __int64 highTargetBits; // r0
  __int64 tmpHighTargetBits; // r6
  double lowPartTarget; // r0
  double adjustedLowPartTarget; // d8
  __int64 lowTargetBits; // r0
  int highBitsOfLowTarget; // r10
  int lowBitsOfLowTarget; // r11
  double midPartTarget; // r0
  double adjustedMidPartTarget; // d8
  __int64 midTargetBits; // r0
  int highBitsOfMidTarget; // r8
  int lowBitsOfMidTarget; // r9
  double finalPartTarget; // r0
  unsigned int finalTargetBits; // r0
  int highBitsOfFinalTarget; // r1
  char *hexTargetString; // r6
  _DWORD targetBitsArray[6]; // [sp+8h] [bp-850h] BYREF
  __int64 high64TargetBits; // [sp+20h] [bp-838h]
  char logBuffer[2096]; // [sp+28h] [bp-830h] BYREF

  if ( targetValueReciprocal == 0.0 )
  {
    if ( loggingDebug || loggingVerbose || loggingThreshold > 2 )
    {
      tmpHighTargetBits = 4294901760LL;
      strcpy(logBuffer, "Diff zero passed to set_target");
      logMessage(3, logBuffer, 0);
      finalTargetBits = 0;
      highBitsOfFinalTarget = 0;
      lowBitsOfMidTarget = 0;
      lowBitsOfLowTarget = 0;
      highBitsOfMidTarget = 0;
      highBitsOfLowTarget = 0;
    }
    else
    {
      finalTargetBits = 0;
      tmpHighTargetBits = 4294901760LL;
      highBitsOfFinalTarget = 0;
      lowBitsOfMidTarget = 0;
      lowBitsOfLowTarget = 0;
      highBitsOfMidTarget = 0;
      highBitsOfLowTarget = 0;
    }
  }
  else
  {
    LODWORD(highTargetBits) = calculate_normalized_hashrate(2.69595353e67 / targetValueReciprocal * 1.59309191e-58);
    tmpHighTargetBits = highTargetBits;
    LODWORD(lowPartTarget) = normalize_exponent_sign(highTargetBits);
    adjustedLowPartTarget = 2.69595353e67 / targetValueReciprocal - lowPartTarget * 6.27710174e57;
    LODWORD(lowTargetBits) = calculate_normalized_hashrate(adjustedLowPartTarget * 2.93873588e-39);
    highBitsOfLowTarget = HIDWORD(lowTargetBits);
    lowBitsOfLowTarget = lowTargetBits;
    LODWORD(midPartTarget) = normalize_exponent_sign(lowTargetBits);
    adjustedMidPartTarget = adjustedLowPartTarget - midPartTarget * 3.40282367e38;
    LODWORD(midTargetBits) = calculate_normalized_hashrate(adjustedMidPartTarget * 5.42101086e-20);
    highBitsOfMidTarget = HIDWORD(midTargetBits);
    lowBitsOfMidTarget = midTargetBits;
    LODWORD(finalPartTarget) = normalize_exponent_sign(midTargetBits);
    finalTargetBits = calculate_normalized_hashrate(adjustedMidPartTarget - finalPartTarget * 1.84467441e19);
  }
  high64TargetBits = tmpHighTargetBits;
  targetBitsArray[4] = lowBitsOfLowTarget;
  targetBitsArray[5] = highBitsOfLowTarget;
  targetBitsArray[2] = lowBitsOfMidTarget;
  targetBitsArray[3] = highBitsOfMidTarget;
  targetBitsArray[0] = finalTargetBits;
  targetBitsArray[1] = highBitsOfFinalTarget;
  if ( logEnabled )
  {
    hexTargetString = convert_bin_to_hex_string((int)targetBitsArray, 32);
    if ( logEnabled && (loggingDebug || loggingVerbose || loggingThreshold > 6) )
    {
      snprintf(logBuffer, 2048u, "Generated target %s", hexTargetString);
      logMessage(7, logBuffer, 0);
    }
    free(hexTargetString);
  }
  return safe_memcpy_with_logging(minerConfig, targetBitsArray, 32u, (int)"bmminer.c", (int)"set_target", 1124);
}
// 294D4: variable 'targetValueReciprocal' is possibly undefined
// 294F0: variable 'highTargetBits' is possibly undefined
// 29508: variable 'lowPartTarget' is possibly undefined
// 2951C: variable 'lowTargetBits' is possibly undefined
// 29530: variable 'midPartTarget' is possibly undefined
// 29544: variable 'midTargetBits' is possibly undefined
// 29554: variable 'finalPartTarget' is possibly undefined
// 29584: variable 'highBitsOfFinalTarget' is possibly undefined
// 7EBA0: using guessed type int loggingThreshold;
// 482A5C: using guessed type char loggingVerbose;
// 482A5D: using guessed type char logEnabled;
// 590404: using guessed type char loggingDebug;

//----- (0002974C) --------------------------------------------------------
__int64 __fastcall generateWork(int minerAddr, int workAddr)
{
  pthread_mutex_t *minerMutex; // r9
  int workDataSize; // lr
  int offset; // r3
  size_t iteration; // r2
  int highOrder; // r3
  int lowOrder; // r2
  int branchIndex; // r6
  const void *branchSource; // r1
  char *srcIterator; // r2
  char *destination; // r0
  unsigned int swappedData; // t1
  int unlockResult; // r0
  int workStartOffset; // r1
  char *nonceIterator; // r2
  unsigned int nonceSwapped; // t1
  double difficultyFactor; // d8
  unsigned __int64 adjustedNonce; // r0
  int baseWorkOffset; // r6
  char *hashratePostfix; // r6
  int nonceDivisionResult_2; // r0
  double hashrateCalculated; // d7
  double hashrateEstimated_1; // d7
  double hashrateCalculated_1; // d7
  double divisionResult; // r0
  double hashrateTarget; // d8
  double doubleWorkAdj; // r0
  double poolDifficulty; // d8
  double doubleNonceAdj; // r0
  double hashrateEstimated; // d8
  double lastDifficulty; // r0
  double hashrateProcessed; // d7
  int nonceDivisionResult; // r0
  int nonceDivisionResult_1; // r0
  char *merkleString; // r10
  const char *headerString; // r0
  char *headerStringPtr; // r11
  int nonceToKStringResult; // r0
  int *lockLocation; // r0
  int *unlockLocation; // r0
  int *v44; // r0
  int *errorLocation; // r0
  int *v46; // r0
  int *initLocation2; // r0
  int nonceDivisionResult_3; // r0
  __int64 tempVar; // [sp+18h] [bp-8D8h] BYREF
  char v50[28]; // [sp+20h] [bp-8D0h] BYREF
  char tempNonce; // [sp+3Ch] [bp-8B4h] BYREF
  char v52[28]; // [sp+40h] [bp-8B0h] BYREF
  int tempNonceValue; // [sp+5Ch] [bp-894h] BYREF
  char v54[28]; // [sp+60h] [bp-890h] BYREF
  char nonceBuff; // [sp+7Ch] [bp-874h] BYREF
  char v56[60]; // [sp+80h] [bp-870h] BYREF
  int nonceVal; // [sp+BCh] [bp-834h] BYREF
  char logBuffer[136]; // [sp+C0h] [bp-830h] BYREF
  int v59; // [sp+148h] [bp-7A8h] BYREF

  minerMutex = (pthread_mutex_t *)(minerAddr + 212);
  if ( pthread_mutex_lock((pthread_mutex_t *)(minerAddr + 212)) )
  {
    lockLocation = _errno_location();
    snprintf(
      logBuffer,
      2048u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *lockLocation,
      "bmminer.c",
      "gen_stratum_work",
      1268);
    logMessage(3, logBuffer, 1);
  }
  if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(minerAddr + 236)) )
  {
    unlockLocation = _errno_location();
    snprintf(
      logBuffer,
      2048u,
      "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *unlockLocation,
      "bmminer.c",
      "gen_stratum_work",
      1268);
    logMessage(3, logBuffer, 1);
  }
  workDataSize = *(_DWORD *)(minerAddr + 1568);
  offset = *(_DWORD *)(minerAddr + 1576);
  iteration = *(_DWORD *)(minerAddr + 632);
  tempVar = *(_QWORD *)(minerAddr + 624);
  safe_memcpy_with_logging(
    (void *)(workDataSize + offset),
    &tempVar,
    iteration,
    (int)"bmminer.c",
    (int)"gen_stratum_work",
    1273);
  highOrder = *(_DWORD *)(minerAddr + 624);
  lowOrder = *(_DWORD *)(minerAddr + 628);
  *(_DWORD *)(minerAddr + 624) = highOrder + 1;
  *(_DWORD *)(minerAddr + 628) = __CFADD__(highOrder, 1) + lowOrder;
  *(_DWORD *)(workAddr + 296) = highOrder;
  *(_DWORD *)(workAddr + 300) = lowOrder;
  *(_DWORD *)(workAddr + 304) = *(_DWORD *)(minerAddr + 632);
  if ( !pthread_rwlock_unlock((pthread_rwlock_t *)(minerAddr + 236)) )
  {
    if ( !pthread_rwlock_rdlock((pthread_rwlock_t *)(minerAddr + 236)) )
      goto LABEL_7;
LABEL_62:
    errorLocation = _errno_location();
    snprintf(
      logBuffer,
      2048u,
      "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *errorLocation,
      "bmminer.c",
      "gen_stratum_work",
      1279);
    logMessage(3, logBuffer, 1);
    if ( !pthread_mutex_unlock(minerMutex) )
      goto LABEL_8;
    goto LABEL_63;
  }
  v44 = _errno_location();
  snprintf(
    logBuffer,
    2048u,
    "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
    *v44,
    "bmminer.c",
    "gen_stratum_work",
    1279);
  logMessage(3, logBuffer, 1);
  if ( pthread_rwlock_rdlock((pthread_rwlock_t *)(minerAddr + 236)) )
    goto LABEL_62;
LABEL_7:
  if ( !pthread_mutex_unlock(minerMutex) )
    goto LABEL_8;
LABEL_63:
  v46 = _errno_location();
  snprintf(
    logBuffer,
    2048u,
    "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
    *v46,
    "bmminer.c",
    "gen_stratum_work",
    1279);
  logMessage(3, logBuffer, 1);
LABEL_8:
  hash_message(*(char **)(minerAddr + 1568), *(_DWORD *)(minerAddr + 1572), logBuffer);
  hash_message(logBuffer, 32u, v50);
  safe_memcpy_with_logging(v52, v50, 32u, (int)"bmminer.c", (int)"gen_stratum_work", 1283);
  if ( *(int *)(minerAddr + 1708) > 0 )
  {
    branchIndex = 0;
    do
    {
      branchSource = *(const void **)(*(_DWORD *)(minerAddr + 676) + 4 * branchIndex++);
      safe_memcpy_with_logging(v54, branchSource, 32u, (int)"bmminer.c", (int)"gen_stratum_work", 1287);
      hash_message(v52, 64u, logBuffer);
      hash_message(logBuffer, 32u, v50);
      safe_memcpy_with_logging(v52, v50, 32u, (int)"bmminer.c", (int)"gen_stratum_work", 1289);
    }
    while ( *(_DWORD *)(minerAddr + 1708) > branchIndex );
  }
  srcIterator = &tempNonce;
  destination = (char *)&tempVar + 4;
  do
  {
    swappedData = *((_DWORD *)srcIterator + 1);
    srcIterator += 4;
    *((_DWORD *)destination + 1) = bswap32(swappedData);
    destination += 4;
  }
  while ( &tempNonceValue != (int *)srcIterator );
  safe_memcpy_with_logging(
    (void *)workAddr,
    (const void *)(minerAddr + 1580),
    112u,
    (int)"bmminer.c",
    (int)"gen_stratum_work",
    1298);
  safe_memcpy_with_logging((void *)(workAddr + 36), v50, 32u, (int)"bmminer.c", (int)"gen_stratum_work", 1299);
  *(_QWORD *)(workAddr + 312) = *(_QWORD *)(minerAddr + 1824);
  *(_DWORD *)(workAddr + 288) = _strdup(*(const char **)(minerAddr + 672));
  *(_DWORD *)(workAddr + 320) = _strdup(*(const char **)(minerAddr + 612));
  *(_DWORD *)(workAddr + 308) = _strdup((const char *)(minerAddr + 1804));
  unlockResult = pthread_rwlock_unlock((pthread_rwlock_t *)(minerAddr + 236));
  if ( unlockResult )
  {
    initLocation2 = _errno_location();
    snprintf(
      logBuffer,
      2048u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *initLocation2,
      "bmminer.c",
      "gen_stratum_work",
      1310);
    unlockResult = logMessage(3, logBuffer, 1);
  }
  off_7ECC4(unlockResult);
  if ( logEnabled )
  {
    merkleString = convert_bin_to_hex_string(workAddr, 112);
    headerString = convert_bin_to_hex_string((int)v50, 32);
    headerStringPtr = (char *)headerString;
    if ( logEnabled )
    {
      if ( !loggingDebug && !loggingVerbose && loggingThreshold <= 6 )
        goto LABEL_52;
      snprintf(logBuffer, 2048u, "Generated stratum merkle %s", headerString);
      logMessage(7, logBuffer, 0);
      if ( !logEnabled )
        goto LABEL_58;
      if ( !loggingDebug )
      {
LABEL_52:
        if ( !loggingVerbose && loggingThreshold <= 6 )
          goto LABEL_55;
      }
      snprintf(logBuffer, 2048u, "Generated stratum header %s", merkleString);
      logMessage(7, logBuffer, 0);
      if ( logEnabled )
      {
        if ( loggingDebug )
        {
LABEL_57:
          snprintf(
            logBuffer,
            2048u,
            "Work job_id %s nonce2 %llu ntime %s",
            *(const char **)(workAddr + 288),
            *(_QWORD *)(workAddr + 296),
            *(const char **)(workAddr + 308));
          logMessage(7, logBuffer, 0);
          goto LABEL_58;
        }
LABEL_55:
        if ( !loggingVerbose && loggingThreshold <= 6 )
          goto LABEL_58;
        goto LABEL_57;
      }
    }
LABEL_58:
    free(merkleString);
    free(headerStringPtr);
  }
  workStartOffset = workAddr - 4;
  nonceIterator = &nonceBuff;
  do
  {
    nonceSwapped = *(_DWORD *)(workStartOffset + 4);
    workStartOffset += 4;
    *((_DWORD *)nonceIterator + 1) = bswap32(nonceSwapped);
    nonceIterator += 4;
  }
  while ( &nonceVal != (int *)nonceIterator );
  copy_firmware_version(logBuffer);
  process_input_chunk((unsigned __int8 *)logBuffer, v56, 64u);
  safe_memcpy_with_logging((void *)(workAddr + 128), &v59, 32u, (int)"bmminer.c", (int)"calc_midstate", 1029);
  setMiningTarget((void *)(workAddr + 160));
  ++dword_5945B4;
  if ( time(0) - dword_80B98 > 5 )
  {
    dword_80B98 = time(0);
    dword_80B9C = dword_5945B4;
  }
  difficultyFactor = *(double *)(workAddr + 312);
  *(_BYTE *)(workAddr + 284) = 1;
  *(_DWORD *)(workAddr + 260) = minerAddr;
  *(_DWORD *)(workAddr + 248) = 0;
  *(_BYTE *)(workAddr + 280) = 0;
  *(_DWORD *)(workAddr + 336) = 0;
  *(_BYTE *)(workAddr + 440) = 83;
  *(_DWORD *)(workAddr + 244) = 60;
  if ( difficultyFactor == 0.0 )
  {
    LODWORD(divisionResult) = normalize_exponent_sign(*(_QWORD *)(workAddr + 184));
    hashrateTarget = divisionResult * 6.27710174e57;
    LODWORD(doubleWorkAdj) = normalize_exponent_sign(*(_QWORD *)(workAddr + 176));
    poolDifficulty = hashrateTarget + doubleWorkAdj * 3.40282367e38;
    LODWORD(doubleNonceAdj) = normalize_exponent_sign(*(_QWORD *)(workAddr + 168));
    hashrateEstimated = poolDifficulty + doubleNonceAdj * 1.84467441e19;
    LODWORD(lastDifficulty) = normalize_exponent_sign(*(_QWORD *)(workAddr + 160));
    hashrateProcessed = lastDifficulty + hashrateEstimated;
    if ( lastDifficulty + hashrateEstimated == 0.0 )
    {
      difficultyFactor = 2.69595353e67;
      adjustedNonce = -1LL;
    }
    else
    {
      difficultyFactor = 2.69595353e67 / hashrateProcessed;
      round();
      LODWORD(adjustedNonce) = calculate_normalized_hashrate(2.69595353e67 / hashrateProcessed);
    }
    *(double *)(workAddr + 376) = difficultyFactor;
  }
  else
  {
    *(double *)(workAddr + 376) = difficultyFactor;
    round();
    LODWORD(adjustedNonce) = calculate_normalized_hashrate(difficultyFactor);
  }
  *(double *)(minerAddr + 480) = difficultyFactor;
  baseWorkOffset = *(_DWORD *)(workAddr + 260);
  *(_WORD *)logBuffer = 0;
  hashratePostfix = (char *)(baseWorkOffset + 48);
  if ( adjustedNonce > 999999999999999999LL )
  {
    nonceDivisionResult_2 = handle_divide_by_zero(adjustedNonce, 1000000000000000uLL);
    strcpy(logBuffer, "E");
    hashrateCalculated = (double)nonceDivisionResult_2 / 1000.0;
LABEL_24:
    snprintf(hashratePostfix, 8u, "%.3g%s", hashrateCalculated, logBuffer);
    goto LABEL_25;
  }
  if ( adjustedNonce > 999999999999999LL )
  {
    nonceDivisionResult = handle_divide_by_zero(adjustedNonce, 1000000000000uLL);
    strcpy(logBuffer, "P");
    hashrateCalculated = (double)nonceDivisionResult / 1000.0;
    goto LABEL_24;
  }
  if ( adjustedNonce > 999999999999LL )
  {
    nonceToKStringResult = handle_divide_by_zero(adjustedNonce, 1000000000uLL);
    strcpy(logBuffer, "T");
    hashrateCalculated = (double)nonceToKStringResult / 1000.0;
    goto LABEL_24;
  }
  if ( adjustedNonce > 999999999 )
  {
    nonceDivisionResult_1 = handle_divide_by_zero(adjustedNonce, (unsigned int)&unk_F4240);
    strcpy(logBuffer, "G");
    hashrateCalculated = (double)nonceDivisionResult_1 / 1000.0;
    goto LABEL_24;
  }
  if ( adjustedNonce > 999999 )
  {
    nonceDivisionResult_3 = handle_divide_by_zero(adjustedNonce, 1000uLL);
    strcpy(logBuffer, "M");
    hashrateCalculated = (double)nonceDivisionResult_3 / 1000.0;
    goto LABEL_24;
  }
  if ( adjustedNonce > 999 )
  {
    strcpy(logBuffer, "K");
    hashrateCalculated = (double)(int)adjustedNonce / 1000.0;
    goto LABEL_24;
  }
  snprintf(hashratePostfix, 8u, "%d%s", (_DWORD)adjustedNonce, logBuffer);
LABEL_25:
  hashrateEstimated_1 = *(double *)(minerAddr + 464);
  if ( hashrateEstimated_1 == difficultyFactor )
  {
    ++*(_DWORD *)(minerAddr + 488);
    goto LABEL_27;
  }
  if ( hashrateEstimated_1 <= difficultyFactor )
  {
    if ( hashrateEstimated_1 != 0.0 )
    {
LABEL_27:
      hashrateCalculated_1 = *(double *)(minerAddr + 472);
      if ( hashrateCalculated_1 != difficultyFactor )
        goto LABEL_28;
LABEL_37:
      ++*(_DWORD *)(minerAddr + 492);
      return convert_timespec_to_custom_format((__time_t *)(workAddr + 264));
    }
    *(double *)(minerAddr + 464) = difficultyFactor;
    *(_DWORD *)(minerAddr + 488) = 1;
  }
  else
  {
    *(double *)(minerAddr + 464) = difficultyFactor;
    *(_DWORD *)(minerAddr + 488) = 1;
  }
  hashrateCalculated_1 = *(double *)(minerAddr + 472);
  if ( hashrateCalculated_1 == difficultyFactor )
    goto LABEL_37;
LABEL_28:
  if ( hashrateCalculated_1 < difficultyFactor )
  {
    *(double *)(minerAddr + 472) = difficultyFactor;
    *(_DWORD *)(minerAddr + 492) = 1;
  }
  return convert_timespec_to_custom_format((__time_t *)(workAddr + 264));
}
// 29B10: variable 'adjustedNonce' is possibly undefined
// 29BC0: variable 'divisionResult' is possibly undefined
// 29BD4: variable 'doubleWorkAdj' is possibly undefined
// 29BE8: variable 'doubleNonceAdj' is possibly undefined
// 29BF4: variable 'lastDifficulty' is possibly undefined
// 12294: using guessed type int round(void);
// 7EBA0: using guessed type int loggingThreshold;
// 7ECC4: using guessed type int (__fastcall *off_7ECC4)(_DWORD);
// 80B98: using guessed type int dword_80B98;
// 80B9C: using guessed type int dword_80B9C;
// 482A5C: using guessed type char loggingVerbose;
// 482A5D: using guessed type char logEnabled;
// 590404: using guessed type char loggingDebug;
// 5945B4: using guessed type int dword_5945B4;
// 2974C: using guessed type char var_890[28];
// 2974C: using guessed type char var_870[60];

//----- (0002A1A4) --------------------------------------------------------
void *__fastcall clear_miner_data(void **miner_data_pointer)
{
  free(miner_data_pointer[72]);
  free(miner_data_pointer[77]);
  free(miner_data_pointer[82]);
  free(miner_data_pointer[80]);
  return memset(miner_data_pointer, 0, 448u);
}

//----- (0002A1E0) --------------------------------------------------------
void __fastcall clear_and_log_miner_info(
        void ***miner_info_ptr,
        const char *log_context,
        const char *log_message,
        int log_level)
{
  void **miner_data; // r5

  miner_data = *miner_info_ptr;
  if ( *miner_info_ptr )
  {
    clear_miner_data(*miner_info_ptr);
    free(miner_data);
    *miner_info_ptr = 0;
  }
  else if ( loggingDebug || loggingVerbose || loggingThreshold > 2 )
  {
    log_null_work_message(log_context, log_message, log_level);
  }
}
// 7EBA0: using guessed type int loggingThreshold;
// 482A5C: using guessed type char loggingVerbose;
// 590404: using guessed type char loggingDebug;

//----- (0002A264) --------------------------------------------------------
int __fastcall update_nonce_and_generate_work(
        int *worker_index_ptr,
        int *work_info_ptr,
        int worker_struct_base,
        int unknown_param,
        __int64 nonces_64,
        unsigned int nonce)
{
  pthread_mutex_t *worker_mutex; // r7
  int worker_index; // r9
  unsigned int byte_swapped_nonce; // r2
  int unlock_result; // r0
  int update_success; // r0
  unsigned int work_nonce; // r1

  worker_mutex = (pthread_mutex_t *)(worker_struct_base + 212);
  *work_info_ptr = (int)create_work_structure();
  worker_index = *worker_index_ptr;
  if ( pthread_mutex_lock(worker_mutex) )
    log_mutex_error("get_work_by_nonce2", 1423);
  write_lock_with_error_logging((pthread_rwlock_t *)(worker_struct_base + 236), "get_work_by_nonce2", 1423);
  byte_swapped_nonce = bswap32(nonce);
  *(_QWORD *)(worker_struct_base + 624) = nonces_64;
  nonce = byte_swapped_nonce;
  safe_memcpy_with_logging(
    (void *)(worker_struct_base + 1580),
    &nonce,
    4u,
    (int)"bmminer.c",
    (int)"get_work_by_nonce2",
    1426);
  if ( pthread_rwlock_unlock((pthread_rwlock_t *)(worker_struct_base + 236)) )
  {
    report_rwlock_error("get_work_by_nonce2", 1427);
    unlock_result = pthread_mutex_unlock(worker_mutex);
    if ( !unlock_result )
      goto LABEL_5;
LABEL_7:
    unlock_result = log_mutex_error_unlock("get_work_by_nonce2", 1427);
    goto LABEL_5;
  }
  unlock_result = pthread_mutex_unlock(worker_mutex);
  if ( unlock_result )
    goto LABEL_7;
LABEL_5:
  off_7ECC4(unlock_result);
  generateWork(worker_struct_base, *work_info_ptr);
  update_success = 1;
  work_nonce = nonce;
  *(_DWORD *)(*work_info_ptr + 260) = unknown_param;
  *(_DWORD *)(*work_info_ptr + 256) = worker_index;
  *(_DWORD *)(*work_info_ptr + 336) = 0;
  ++*(_DWORD *)(*(_DWORD *)(*work_info_ptr + 260) + 68);
  *(_BYTE *)(*work_info_ptr + 272) = 1;
  *(_DWORD *)(*work_info_ptr + 444) = work_nonce;
  return update_success;
}
// 7ECC4: using guessed type int (__fastcall *off_7ECC4)(_DWORD);

//----- (0002A3C4) --------------------------------------------------------
int __fastcall increment_hardware_errors(int miner_status)
{
  int miner_stat_pointer; // r12
  int new_hw_errors_count; // r2
  int unlock_result; // r0
  int final_result; // r0
  int (__fastcall *status_update_callback)(int); // r3
  int *errno_address_lock; // r0
  int *errno_address_unlock; // r0
  char log_buffer[2056]; // [sp+10h] [bp-808h] BYREF

  if ( logEnabled && (loggingDebug || loggingVerbose || loggingThreshold > 6) )
  {
    snprintf(
      log_buffer,
      2048u,
      "%s %d: invalid nonce - HW error",
      *(const char **)(*(_DWORD *)(*(_DWORD *)(miner_status + 36) + 4) + 8),
      *(_DWORD *)(*(_DWORD *)(miner_status + 36) + 8));
    logMessage(7, log_buffer, 0);
  }
  if ( pthread_mutex_lock(&stru_5944F4) )
  {
    errno_address_lock = _errno_location();
    snprintf(
      log_buffer,
      2048u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *errno_address_lock,
      "bmminer.c",
      "inc_hw_errors",
      1446);
    logMessage(3, log_buffer, 1);
  }
  miner_stat_pointer = *(_DWORD *)(miner_status + 36);
  new_hw_errors_count = *(_DWORD *)(miner_stat_pointer + 44) + 1;
  ++dword_58E348;
  *(_DWORD *)(miner_stat_pointer + 44) = new_hw_errors_count;
  unlock_result = pthread_mutex_unlock(&stru_5944F4);
  if ( unlock_result )
  {
    errno_address_unlock = _errno_location();
    snprintf(
      log_buffer,
      2048u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *errno_address_unlock,
      "bmminer.c",
      "inc_hw_errors",
      1449);
    unlock_result = logMessage(3, log_buffer, 1);
  }
  final_result = off_7ECC4(unlock_result);
  status_update_callback = *(int (__fastcall **)(int))(*(_DWORD *)(*(_DWORD *)(miner_status + 36) + 4) + 84);
  if ( status_update_callback )
    return status_update_callback(miner_status);
  return final_result;
}
// 7EBA0: using guessed type int loggingThreshold;
// 7ECC4: using guessed type int (__fastcall *off_7ECC4)(_DWORD);
// 482A5C: using guessed type char loggingVerbose;
// 482A5D: using guessed type char logEnabled;
// 58E348: using guessed type int dword_58E348;
// 590404: using guessed type char loggingDebug;
// 5944F4: using guessed type pthread_mutex_t stru_5944F4;

//----- (0002A578) --------------------------------------------------------
int updateMinerUptime()
{
  int result; // r0
  int errorNumber; // r4
  char *errorString; // r0
  struct sysinfo systemInfo; // [sp+0h] [bp-948h] BYREF
  char logBuffer[256]; // [sp+40h] [bp-908h] BYREF
  char verboseLogBuffer[2056]; // [sp+140h] [bp-808h] BYREF

  if ( sysinfo(&systemInfo) )
  {
    errorNumber = *_errno_location();
    errorString = strerror(errorNumber);
    sprintf(logBuffer, "Failed to get sysinfo, errno:%u, reason:%s\n", errorNumber, errorString);
    result = time(0);
    dword_58E344 = result;
    dword_5903F8 = result + 1;
  }
  else
  {
    dword_58E344 = systemInfo.uptime;
    dword_5903F8 = systemInfo.uptime + 1;
    result = sprintf(
               logBuffer,
               "set_start_time_point total_tv_start_sys=%ld total_tv_end_sys=%ld\n",
               systemInfo.uptime,
               systemInfo.uptime + 1);
    if ( loggingDebug || loggingVerbose || loggingThreshold > 4 )
    {
      snprintf(verboseLogBuffer, 2048u, "%s", logBuffer);
      return logMessage(5, verboseLogBuffer, 0);
    }
  }
  return result;
}
// 7EBA0: using guessed type int loggingThreshold;
// 482A5C: using guessed type char loggingVerbose;
// 58E344: using guessed type int dword_58E344;
// 5903F8: using guessed type int dword_5903F8;
// 590404: using guessed type char loggingDebug;

//----- (0002A688) --------------------------------------------------------
int readMinerVersionAndSerialNumber()
{
  FILE *minerVersionFile; // r6
  signed int readResult; // r0
  char *newlinePos; // r0
  char *secondLineStart; // r6
  int secondLineLen; // r6
  char *secondNewlinePos; // r0
  size_t trimmedLen; // r0
  int charToCheck; // r3
  size_t serialTrimmedLen; // r0
  int serialCharToCheck; // r3
  bool isCarriageReturn; // zf
  int verbosityFlag; // r6
  FILE *serialNumberFile; // r7
  signed int serialReadResult; // r0
  char *serialNewlinePos; // r0
  int v15; // r7
  int result; // r0
  int lastChar; // r3
  char minerVersionStr[256]; // [sp+8h] [bp-918h] BYREF
  char logBuffer[2072]; // [sp+108h] [bp-818h] BYREF

  minerVersionFile = (FILE *)fopen64(minerVersionFilename, "rb");
  memset(minerVersionStr, 0, sizeof(minerVersionStr));
  if ( minerVersionFile )
  {
    readResult = fread(minerVersionStr, 1u, 256u, minerVersionFile);
    if ( readResult <= 0 )
    {
      verbosityFlag = (int)&loggingDebug;
      if ( loggingDebug || loggingVerbose || loggingThreshold > 2 )
      {
        snprintf(
          logBuffer,
          2048u,
          "Read miner version file %s error %d",
          (const char *)minerVersionFilename,
          readResult);
        logMessage(3, logBuffer, 0);
      }
    }
    else
    {
      newlinePos = strchr(minerVersionStr, 10);
      secondLineStart = newlinePos;
      if ( newlinePos )
      {
        safe_memcpy_with_logging(
          minerVersion,
          minerVersionStr,
          newlinePos - minerVersionStr,
          (int)"bmminer.c",
          (int)"read_version_file",
          1515);
        secondLineLen = stpcpy(minerVersionStr, secondLineStart + 1);
        secondNewlinePos = strchr(minerVersionStr, 10);
        if ( secondNewlinePos )
          safe_memcpy_with_logging(
            minerType,
            minerVersionStr,
            secondNewlinePos - minerVersionStr,
            (int)"bmminer.c",
            (int)"read_version_file",
            1524);
        else
          memcpy(minerType, minerVersionStr, secondLineLen - (_DWORD)minerVersionStr + 1);
      }
      else
      {
        strcpy(minerVersion, minerVersionStr);
      }
      trimmedLen = strlen(minerVersion) - 1;
      charToCheck = (unsigned __int8)byte_80768[trimmedLen + 1080];
      if ( charToCheck == 10 )
      {
        byte_80768[trimmedLen + 1080] = 0;
        trimmedLen = strlen(minerVersion) - 1;
        charToCheck = (unsigned __int8)byte_80768[trimmedLen + 1080];
      }
      if ( charToCheck == 13 )
        byte_80768[trimmedLen + 1080] = 0;
      serialTrimmedLen = strlen(minerType) - 1;
      serialCharToCheck = (unsigned __int8)byte_80768[serialTrimmedLen + 1336];
      if ( serialCharToCheck == 10 )
      {
        byte_80768[serialTrimmedLen + 1336] = 0;
        serialTrimmedLen = strlen(minerType) - 1;
        serialCharToCheck = (unsigned __int8)byte_80768[serialTrimmedLen + 1336];
      }
      isCarriageReturn = serialCharToCheck == 13;
      verbosityFlag = 1028;
      if ( serialCharToCheck == 13 )
      {
        serialTrimmedLen += (size_t)byte_80768;
        LOBYTE(serialCharToCheck) = 0;
      }
      else
      {
        HIWORD(verbosityFlag) = 89;
      }
      if ( isCarriageReturn )
      {
        HIWORD(verbosityFlag) = 89;
        *(_BYTE *)(serialTrimmedLen + 1336) = serialCharToCheck;
      }
    }
  }
  else
  {
    verbosityFlag = (int)&loggingDebug;
    if ( loggingDebug || loggingVerbose || loggingThreshold > 2 )
    {
      snprintf(logBuffer, 2048u, "Open miner version file %s error", (const char *)minerVersionFilename);
      logMessage(3, logBuffer, 0);
    }
  }
  serialNumberFile = (FILE *)fopen64("/config/sn", "rb");
  if ( serialNumberFile )
  {
    memset(minerVersionStr, 0, sizeof(minerVersionStr));
    serialReadResult = fread(minerVersionStr, 1u, 250u, serialNumberFile);
    if ( serialReadResult <= 0 )
    {
      if ( *(_BYTE *)verbosityFlag || loggingVerbose || loggingThreshold > 2 )
      {
        snprintf(logBuffer, 2048u, "Read miner sn file %s error %d", "/config/sn", serialReadResult);
        logMessage(3, logBuffer, 0);
      }
    }
    else
    {
      serialNewlinePos = strstr(minerVersionStr, "\r\n");
      if ( serialNewlinePos )
        safe_memcpy_with_logging(
          &serialNumber,
          minerVersionStr,
          serialNewlinePos - minerVersionStr,
          (int)"bmminer.c",
          (int)"read_version_file",
          1572);
      else
        strcpy(&serialNumber, minerVersionStr);
    }
    fclose(serialNumberFile);
    v15 = *(unsigned __int8 *)verbosityFlag;
  }
  else if ( *(_BYTE *)verbosityFlag || (v15 = (unsigned __int8)loggingVerbose, loggingVerbose) || loggingThreshold > 2 )
  {
    snprintf(logBuffer, 2048u, "Open miner sn file %s error", "/config/sn");
    logMessage(3, logBuffer, 0);
    v15 = *(unsigned __int8 *)verbosityFlag;
  }
  result = strlen(&serialNumber) - 1;
  lastChar = (unsigned __int8)byte_80768[result + 1592];
  if ( lastChar == 10 )
  {
    byte_80768[result + 1592] = 0;
    result = strlen(&serialNumber) - 1;
    lastChar = (unsigned __int8)byte_80768[result + 1592];
  }
  if ( lastChar == 13 )
    byte_80768[result + 1592] = 0;
  if ( v15 || loggingVerbose || loggingThreshold > 2 )
  {
    snprintf(logBuffer, 2048u, "Miner compile time: %s type: %s sn :%s", minerVersion, minerType, &serialNumber);
    return logMessage(3, logBuffer, 0);
  }
  return result;
}
// 1203C: using guessed type int __fastcall stpcpy(_DWORD, _DWORD);
// 124E4: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 7EBA0: using guessed type int loggingThreshold;
// 80970: using guessed type int minerVersionFilename;
// 482A5C: using guessed type char loggingVerbose;
// 590404: using guessed type char loggingDebug;

//----- (0002AB48) --------------------------------------------------------
char *__fastcall create_formatted_data_buffer(
        size_t *data_buffer_size,
        const char **string_values,
        int int_value,
        char char_value)
{
  const char *string_value_72; // r11
  const char *string_value_77; // r10
  size_t string_72_length; // r4
  const char *string_value_80; // r8
  size_t partial_buffer_size; // r4
  size_t final_buffer_size; // r4
  char *allocated_buffer; // r0
  char *formatted_buffer; // r5
  size_t string_72_incl_null_size; // r7
  size_t string_77_incl_null_size; // r2
  size_t current_buffer_offset; // r6
  size_t string_80_incl_null_size; // r7
  char log_message_buffer[2088]; // [sp+10h] [bp-828h] BYREF

  string_value_72 = string_values[72];
  string_value_77 = string_values[77];
  string_72_length = strlen(string_value_72);
  string_value_80 = string_values[80];
  partial_buffer_size = string_72_length + strlen(string_values[77]) + 459;
  final_buffer_size = partial_buffer_size + strlen(string_value_80);
  allocated_buffer = (char *)calloc(1u, final_buffer_size);
  formatted_buffer = allocated_buffer;
  if ( allocated_buffer )
  {
    *(_DWORD *)(allocated_buffer + 1) = int_value;
    *allocated_buffer = char_value;
    memcpy(allocated_buffer + 5, string_values, 448u);
    string_72_incl_null_size = (unsigned __int8)(strlen(string_value_72) + 1);
    formatted_buffer[453] = string_72_incl_null_size;
    memcpy(formatted_buffer + 454, string_value_72, string_72_incl_null_size);
    string_77_incl_null_size = (unsigned __int8)(strlen(string_value_77) + 1);
    formatted_buffer[string_72_incl_null_size + 454] = string_77_incl_null_size;
    current_buffer_offset = string_77_incl_null_size + string_72_incl_null_size + 455;
    memcpy(&formatted_buffer[string_72_incl_null_size + 455], string_value_77, string_77_incl_null_size);
    string_80_incl_null_size = (unsigned __int8)(strlen(string_value_80) + 1);
    formatted_buffer[current_buffer_offset] = string_80_incl_null_size;
    memcpy(&formatted_buffer[current_buffer_offset + 1], string_value_80, string_80_incl_null_size);
    if ( logEnabled && (loggingDebug || loggingVerbose || loggingThreshold > 6) )
    {
      snprintf(
        log_message_buffer,
        2048u,
        "need data size:%d, actual size:%d\n",
        final_buffer_size,
        string_80_incl_null_size + current_buffer_offset + 1);
      logMessage(7, log_message_buffer, 0);
    }
    *data_buffer_size = final_buffer_size;
  }
  return formatted_buffer;
}
// 7EBA0: using guessed type int loggingThreshold;
// 482A5C: using guessed type char loggingVerbose;
// 482A5D: using guessed type char logEnabled;
// 590404: using guessed type char loggingDebug;

//----- (0002ACEC) --------------------------------------------------------
int __fastcall submit_nonce_to_miner(int nonce_id, const char **nonce_data, int nonce_size, char nonce_flag)
{
  char *formatted_data_buffer; // r4
  size_t formatted_data_size; // [sp+4h] [bp-80Ch] BYREF
  char log_message_buffer[2056]; // [sp+8h] [bp-808h] BYREF

  formatted_data_buffer = create_formatted_data_buffer(&formatted_data_size, nonce_data, nonce_size, nonce_flag);
  if ( submit_work_to_bitmain(formatted_data_buffer, formatted_data_size)
    && (loggingDebug || loggingVerbose || loggingThreshold > 2) )
  {
    strcpy(log_message_buffer, "cgminer return err for this nonce!\n");
    logMessage(3, log_message_buffer, 0);
  }
  free(formatted_data_buffer);
  return 1;
}
// 7EBA0: using guessed type int loggingThreshold;
// 482A5C: using guessed type char loggingVerbose;
// 590404: using guessed type char loggingDebug;

//----- (0002ADA0) --------------------------------------------------------
int __fastcall check_authentication(const char *expected_hash)
{
  int attempt_count; // r4
  int adjusted_time; // r3
  struct tm *time_info; // r0
  int current_time[2]; // [sp+1Ch] [bp-CCh] BYREF
  char calculated_hash[32]; // [sp+24h] [bp-C4h] BYREF
  char intermediate_hash[32]; // [sp+44h] [bp-A4h] BYREF
  char formatted_time[40]; // [sp+64h] [bp-84h] BYREF
  char message_to_hash[92]; // [sp+8Ch] [bp-5Ch] BYREF

  memset(calculated_hash, 0, sizeof(calculated_hash));
  memset(intermediate_hash, 0, sizeof(intermediate_hash));
  memset(formatted_time, 0, sizeof(formatted_time));
  memset(message_to_hash, 0, 59u);
  attempt_count = 0;
  convert_timespec_to_custom_format(current_time);
  while ( 1 )
  {
    adjusted_time = current_time[0] - attempt_count++;
    current_time[0] = adjusted_time;
    time_info = localtime(current_time);
    snprintf(
      formatted_time,
      40u,
      "[%d-%02d-%02d %02d:%02d:%02d]",
      time_info->tm_year + 1900,
      time_info->tm_mon + 1,
      time_info->tm_mday,
      time_info->tm_hour,
      time_info->tm_min,
      time_info->tm_sec);
    snprintf(message_to_hash, 59u, "%s%s", "BITMAIN_OPENSOURCE", formatted_time);
    hash_message(message_to_hash, 59u, intermediate_hash);
    hash_message(intermediate_hash, 32u, calculated_hash);
    if ( !strncmp(calculated_hash, expected_hash, 32u) )
      break;
    if ( attempt_count == 4 )
      return 0;
  }
  puts("socket auth pass!!!!!!!!!!!!!!!!!!!!");
  return 1;
}
// 2ADA0: using guessed type time_t timer[2];

//----- (0002AEF4) --------------------------------------------------------
int initialize_bitmain_primary()
{
  _DWORD *bitmain_info_ptr; // r4
  int allocated_memory_ptr; // r3
  _DWORD *status_info_ptr; // r3
  int function_result; // r0
  char error_message[2064]; // [sp+0h] [bp-810h] BYREF

  bitmain_info_ptr = (_DWORD *)dword_58E354;
  if ( !dword_58E354 )
    _assert_fail("cgpu", "bmminer.c", 2026u, "bitmain_primary_init");
  allocated_memory_ptr = dword_592460;
  *(_DWORD *)(dword_58E354 + 32) = 0;
  bitmain_info_ptr[1] = &unk_80EA0;
  bitmain_info_ptr[5] = allocated_memory_ptr;
  bitmain_info_ptr[37] = 1;
  if ( !allocated_memory_ptr )
  {
    strcpy(error_message, "Failed to calloc cgpu_info data");
    logMessage(3, error_message, 1);
    allocated_memory_ptr = bitmain_info_ptr[5];
  }
  status_info_ptr = (_DWORD *)(allocated_memory_ptr + 4096);
  function_result = 0;
  status_info_ptr[405] = 0;
  status_info_ptr[406] = 1;
  status_info_ptr[407] = 2;
  return function_result;
}
// 58E354: using guessed type int dword_58E354;
// 592460: using guessed type int dword_592460;

//----- (0002AFC4) --------------------------------------------------------
int __fastcall verify_hash_size(const char *hash_input, int hash_size)
{
  char logging_buffer[2056]; // [sp+0h] [bp-808h] BYREF

  if ( hash_size != 32 && (loggingDebug || loggingVerbose || loggingThreshold > 2) )
  {
    snprintf(logging_buffer, 2048u, "invald hash size %d\n", hash_size);
    logMessage(3, logging_buffer, 0);
  }
  byte_482A88 = check_authentication(hash_input);
  return 0;
}
// 7EBA0: using guessed type int loggingThreshold;
// 482A5C: using guessed type char loggingVerbose;
// 482A88: using guessed type char byte_482A88;
// 590404: using guessed type char loggingDebug;

//----- (0002B05C) --------------------------------------------------------
int __fastcall parseJobBuffer(_DWORD *jobBufDst, int jobBufSrc, int jobBufLen)
{
  size_t merkleSize; // r7
  size_t merkleDataOffset; // r4
  void *merkleRootDst; // r0
  void *copiedMerkleRoot; // r3
  int merkleCount; // r0
  _DWORD *merkleBinArray; // r0
  int merkleBinCount; // r3
  size_t localMerkleOffset; // r10
  _DWORD *localMerkleBinPtr; // r8
  size_t nextLocalMerkleOffset; // r7
  int *srcMerkleChart; // r4
  int merkleIndex; // r5
  _DWORD *localMerkleBin; // r3
  int srcMerkleData; // r12
  int v19; // r0
  int v20; // r1
  int v21; // r2
  int v22; // r0
  int v23; // r1
  int v24; // r2
  char *coinbase1; // r4
  size_t coinbase1Len; // r0
  size_t nextOffset; // r10
  char *coinbase2; // r4
  size_t finalOffset; // r10
  _DWORD *versionAndTime; // r2
  int nBits; // r1
  int *nonceAndNTime; // r9
  size_t parsedDataLen; // r10
  int result; // r0
  int nTime; // r1
  char logBuffer[2088]; // [sp+8h] [bp-828h] BYREF

  memcpy(jobBufDst, (const void *)jobBufSrc, 1848u);
  merkleSize = jobBufDst[393];
  merkleDataOffset = merkleSize + 1848;
  merkleRootDst = calloc(1u, merkleSize);
  copiedMerkleRoot = memcpy(merkleRootDst, (const void *)(jobBufSrc + 1848), merkleSize);
  merkleCount = jobBufDst[427];
  jobBufDst[392] = copiedMerkleRoot;
  merkleBinArray = allocate_memory_logging(4 * merkleCount + 1, "bmminer.c", "parse_job_buf", 2190);
  merkleBinCount = jobBufDst[427];
  jobBufDst[169] = merkleBinArray;
  if ( merkleBinCount > 0 )
  {
    localMerkleBinPtr = merkleBinArray;
    nextLocalMerkleOffset = merkleSize + 1880;
    srcMerkleChart = (int *)(jobBufSrc + merkleDataOffset);
    merkleIndex = 0;
    while ( 1 )
    {
      localMerkleBinPtr[merkleIndex] = allocate_memory_logging(32u, "bmminer.c", "parse_job_buf", 2193);
      localMerkleOffset = nextLocalMerkleOffset + 32 * merkleIndex;
      localMerkleBin = *(_DWORD **)(jobBufDst[169] + 4 * merkleIndex);
      if ( !localMerkleBin )
      {
        strcpy(logBuffer, "Failed to malloc local merkle_bin");
        logMessage(3, logBuffer, 1);
        localMerkleBin = *(_DWORD **)(jobBufDst[169] + 4 * merkleIndex);
      }
      srcMerkleData = *srcMerkleChart;
      ++merkleIndex;
      v19 = srcMerkleChart[1];
      srcMerkleChart += 8;
      v20 = *(srcMerkleChart - 6);
      v21 = *(srcMerkleChart - 5);
      *localMerkleBin = srcMerkleData;
      localMerkleBin[1] = v19;
      localMerkleBin[2] = v20;
      localMerkleBin[3] = v21;
      v22 = *(srcMerkleChart - 3);
      v23 = *(srcMerkleChart - 2);
      v24 = *(srcMerkleChart - 1);
      localMerkleBin[4] = *(srcMerkleChart - 4);
      localMerkleBin[5] = v22;
      localMerkleBin[6] = v23;
      localMerkleBin[7] = v24;
      if ( jobBufDst[427] <= merkleIndex )
        break;
      localMerkleBinPtr = (_DWORD *)jobBufDst[169];
    }
  }
  else
  {
    localMerkleOffset = merkleSize + 1848;
  }
  coinbase1 = _strdup((const char *)(jobBufSrc + localMerkleOffset));
  coinbase1Len = strlen(coinbase1);
  jobBufDst[168] = coinbase1;
  nextOffset = coinbase1Len + 1 + localMerkleOffset;
  coinbase2 = _strdup((const char *)(jobBufSrc + nextOffset));
  finalOffset = nextOffset + strlen(coinbase2);
  jobBufDst[153] = coinbase2;
  versionAndTime = (_DWORD *)(jobBufSrc + finalOffset + 1);
  nBits = versionAndTime[1];
  nonceAndNTime = (int *)(jobBufSrc + finalOffset + 9);
  parsedDataLen = finalOffset + 17;
  unk_80F18 = *versionAndTime;
  unk_80F1C = nBits;
  result = *nonceAndNTime;
  nTime = nonceAndNTime[1];
  unk_7EAB0 = *nonceAndNTime;
  unk_7EAB4 = nTime;
  if ( logEnabled && (loggingDebug || loggingVerbose || loggingThreshold > 6) )
  {
    snprintf(logBuffer, 2048u, "parse job buf len:%d\n", parsedDataLen);
    result = logMessage(7, logBuffer, 0);
  }
  if ( parsedDataLen != jobBufLen )
  {
    strcpy(logBuffer, "ERR: data trans/recv unmathced!");
    return logMessage(3, logBuffer, 1);
  }
  return result;
}
// 7EBA0: using guessed type int loggingThreshold;
// 482A5C: using guessed type char loggingVerbose;
// 482A5D: using guessed type char logEnabled;
// 590404: using guessed type char loggingDebug;

//----- (0002B2F4) --------------------------------------------------------
unsigned int get_status()
{
  unsigned int status; // r4

  pthread_mutex_lock(&mutex);
  status = calculate_crc_checksum((char *)dword_80F3C, dword_80F38);
  pthread_mutex_unlock(&mutex);
  return status;
}
// 80F38: using guessed type int dword_80F38;
// 80F3C: using guessed type int dword_80F3C;

//----- (0002B330) --------------------------------------------------------
int __fastcall process_job_update(const void *job_data, unsigned int job_size)
{
  int global_data; // r4
  _DWORD *parsed_job; // r5
  int new_job_id; // r2
  int unlock_result; // r0
  int final_unlock_result; // r0
  int free_index; // r4
  void *free_pointer; // r0
  void *reallocated_memory; // r0
  int *write_lock_errno_location; // r0
  int *unlock_err_location; // r0
  int *mutex_unlock_errno_location; // r0
  int *final_mutex_unlock_errno_location; // r0
  int *lock_err_location; // r0
  int *mutex_lock_errno_location; // r0
  void *miner_job_buf; // [sp+14h] [bp-82Ch] BYREF
  char log_buffer[2088]; // [sp+18h] [bp-828h] BYREF

  global_data = dword_592460;
  miner_job_buf = 0;
  if ( logEnabled && (loggingDebug || loggingVerbose || loggingThreshold > 6) )
  {
    snprintf(log_buffer, 2048u, "%s, rec job data %p size: %d\n", "bitmain_update_job_cb", job_data, job_size);
    logMessage(7, log_buffer, 0);
  }
  if ( (unsigned int)get_global_variable() <= 1 )
  {
    pthread_mutex_lock(&mutex);
    reallocated_memory = (void *)dword_80F3C;
    if ( !dword_80F3C || dword_80F38 < job_size )
    {
      reallocated_memory = realloc((void *)dword_80F3C, job_size);
      dword_80F3C = (int)reallocated_memory;
    }
    memcpy(reallocated_memory, job_data, job_size);
    dword_80F38 = job_size;
    pthread_mutex_unlock(&mutex);
    return 0;
  }
  else
  {
    if ( pthread_mutex_lock((pthread_mutex_t *)(global_data + 112)) )
    {
      lock_err_location = _errno_location();
      snprintf(
        log_buffer,
        2048u,
        "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
        *lock_err_location,
        "bmminer.c",
        "bitmain_update_job_cb",
        2250);
      logMessage(3, log_buffer, 1);
    }
    parsed_job = calloc(1u, 1848u);
    parseJobBuffer(parsed_job, (int)job_data, job_size);
    if ( !*((_BYTE *)parsed_job + 640) )
    {
      strcpy(log_buffer, "Bitmain S9 has to use stratum pools");
      logMessage(3, log_buffer, 1);
    }
    if ( pthread_mutex_lock((pthread_mutex_t *)global_data) )
    {
      mutex_lock_errno_location = _errno_location();
      snprintf(
        log_buffer,
        2048u,
        "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
        *mutex_lock_errno_location,
        "bmminer.c",
        "bitmain_update_job_cb",
        2261);
      logMessage(3, log_buffer, 1);
    }
    if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(global_data + 24)) )
    {
      write_lock_errno_location = _errno_location();
      snprintf(
        log_buffer,
        2048u,
        "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
        *write_lock_errno_location,
        "bmminer.c",
        "bitmain_update_job_cb",
        2261);
      logMessage(3, log_buffer, 1);
    }
    *(_DWORD *)(global_data + 168) = *parsed_job;
    copy_pool_stratum_data(global_data + 3868, global_data + 2020);
    *(_DWORD *)(global_data + 5724) = *(_DWORD *)(global_data + 5720);
    copy_pool_stratum_data(global_data + 2020, global_data + 172);
    *(_DWORD *)(global_data + 5720) = *(_DWORD *)(global_data + 5716);
    copy_pool_stratum_data(global_data + 172, (int)parsed_job);
    new_job_id = dword_7EAB8 + 1;
    *(_DWORD *)(global_data + 5716) = dword_7EAB8 + 1;
    dword_7EAB8 = new_job_id;
    if ( pthread_rwlock_unlock((pthread_rwlock_t *)(global_data + 24)) )
    {
      unlock_err_location = _errno_location();
      snprintf(
        log_buffer,
        2048u,
        "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *unlock_err_location,
        "bmminer.c",
        "bitmain_update_job_cb",
        2273);
      logMessage(3, log_buffer, 1);
    }
    unlock_result = pthread_mutex_unlock((pthread_mutex_t *)global_data);
    if ( unlock_result )
    {
      mutex_unlock_errno_location = _errno_location();
      snprintf(
        log_buffer,
        2048u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *mutex_unlock_errno_location,
        "bmminer.c",
        "bitmain_update_job_cb",
        2273);
      unlock_result = logMessage(3, log_buffer, 1);
    }
    off_7ECC4(unlock_result);
    copy_miner_data(&miner_job_buf, (int)parsed_job, *(_DWORD *)(global_data + 5716));
    pthread_mutex_lock(stru_4FCAA0);
    sendJobToMiner((unsigned __int8 *)miner_job_buf);
    pthread_mutex_unlock(stru_4FCAA0);
    free(miner_job_buf);
    final_unlock_result = pthread_mutex_unlock((pthread_mutex_t *)(global_data + 112));
    if ( final_unlock_result )
    {
      final_mutex_unlock_errno_location = _errno_location();
      snprintf(
        log_buffer,
        2048u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *final_mutex_unlock_errno_location,
        "bmminer.c",
        "bitmain_update_job_cb",
        2283);
      final_unlock_result = logMessage(3, log_buffer, 1);
    }
    off_7ECC4(final_unlock_result);
    if ( (int)parsed_job[427] > 0 )
    {
      free_index = 0;
      do
      {
        free_pointer = *(void **)(parsed_job[169] + 4 * free_index++);
        free(free_pointer);
      }
      while ( parsed_job[427] > free_index );
    }
    free((void *)parsed_job[169]);
    free((void *)parsed_job[392]);
    free((void *)parsed_job[168]);
    free((void *)parsed_job[153]);
    free(parsed_job);
    return 0;
  }
}
// 7EAB8: using guessed type int dword_7EAB8;
// 7EBA0: using guessed type int loggingThreshold;
// 7ECC4: using guessed type int (__fastcall *off_7ECC4)(_DWORD);
// 80F38: using guessed type int dword_80F38;
// 80F3C: using guessed type int dword_80F3C;
// 482A5C: using guessed type char loggingVerbose;
// 482A5D: using guessed type char logEnabled;
// 4FCAA0: using guessed type pthread_mutex_t stru_4FCAA0[2];
// 590404: using guessed type char loggingDebug;
// 592460: using guessed type int dword_592460;

//----- (0002B800) --------------------------------------------------------
size_t __fastcall get_data_type_size(int *data_type_info)
{
  int data_type; // r3
  size_t size; // r0
  char error_message[2056]; // [sp+0h] [bp-808h] BYREF

  data_type = *data_type_info;
  switch ( *data_type_info )
  {
    case 0:
    case 1:
    case 2:
      size = strlen((const char *)data_type_info[2]) + 1;
      break;
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 16:
    case 19:
    case 22:
    case 26:
      size = 4;
      break;
    case 10:
    case 11:
    case 12:
    case 13:
    case 15:
    case 17:
    case 18:
    case 20:
    case 21:
    case 23:
    case 24:
    case 25:
      size = 8;
      break;
    case 14:
      size = 1;
      break;
    default:
      if ( loggingDebug || (size = (unsigned __int8)loggingVerbose, loggingVerbose) || loggingThreshold > 2 )
      {
        snprintf(error_message, 2048u, "Should not happen for unknown data type %d", data_type);
        logMessage(3, error_message, 0);
        size = 0;
      }
      break;
  }
  return size;
}
// 2B818: control flows out of bounds to 2B81C
// 7EBA0: using guessed type int loggingThreshold;
// 482A5C: using guessed type char loggingVerbose;
// 590404: using guessed type char loggingDebug;

//----- (0002B944) --------------------------------------------------------
int __fastcall handle_message_command(const char *message, size_t message_length)
{
  int status_code; // r0
  int received_freq_level; // r3
  char log_buffer[2072]; // [sp+0h] [bp-818h] BYREF

  if ( message_length == 1 )
  {
    pthread_mutex_lock(&stru_80A74);
    pthread_cond_signal(&cond);
    pthread_mutex_unlock(&stru_80A74);
    return 0;
  }
  if ( message_length == 4 )
  {
    received_freq_level = *(_DWORD *)message;
    dword_7EABC = *(_DWORD *)message;
    if ( (unsigned int)globalLogLevel > 3 )
    {
      snprintf(log_buffer, 2048u, "freq_level = %d\n", received_freq_level);
      logMessage(3, log_buffer, 0);
      return 0;
    }
    return 0;
  }
  if ( message_length != 2 )
    return 0;
  if ( !strncmp(message, "go", 2u) )
  {
    if ( (unsigned int)globalLogLevel > 3 )
    {
      strcpy(log_buffer, "start to init...\n");
      logMessage(3, log_buffer, 0);
    }
    sem_post(&sem);
  }
  if ( strncmp(message, "re", 2u) )
    return 0;
  if ( (unsigned int)globalLogLevel > 3 )
  {
    strcpy(log_buffer, "reload pool, need recalculate\n");
    logMessage(3, log_buffer, 0);
  }
  update_last_uptime();
  unk_80F50 = 0LL;
  *(_QWORD *)dword_99ED98 = 0LL;
  *(_QWORD *)&dword_99ED98[2] = 0LL;
  *(_QWORD *)&dword_99ED98[4] = 0LL;
  *(_QWORD *)&dword_99ED98[6] = 0LL;
  qword_99EE08 = 0LL;
  initialize_and_update_uptime();
  status_code = 0;
  dword_80F58 = 1;
  dword_80F5C = 1;
  dword_80F60 = 1;
  return status_code;
}
// 7EABC: using guessed type int dword_7EABC;
// 7EB9C: using guessed type int globalLogLevel;
// 80F58: using guessed type int dword_80F58;
// 80F5C: using guessed type int dword_80F5C;
// 80F60: using guessed type int dword_80F60;
// 99ED98: using guessed type _DWORD dword_99ED98[8];
// 99EDA0: using guessed type _DWORD;
// 99EDA8: using guessed type _DWORD;
// 99EDB0: using guessed type _DWORD;
// 99EE08: using guessed type __int64 qword_99EE08;

//----- (0002BB44) --------------------------------------------------------
int __fastcall shutdown_miner(int shutdown_reason_code, int shutdown_additional_info)
{
  int shutdown_result; // r0
  char log_buffer[2056]; // [sp+8h] [bp-808h] BYREF

  if ( loggingDebug || loggingVerbose || loggingThreshold > 4 )
  {
    snprintf(log_buffer, 2048u, "%s %d\n", "bitmain_shutdown_cb", shutdown_additional_info);
    logMessage(5, log_buffer, 0);
  }
  powerOffHashboard();
  destroy_thread_and_semaphore(dword_80758);
  destroy_thread_and_semaphore(dword_80754);
  destroy_thread_and_semaphore(dword_80750);
  destroy_thread_and_semaphore(dword_590400);
  disable_asics();
  shutdown_result = 0;
  *(_BYTE *)(dword_58E354 + 364) = 1;
  return shutdown_result;
}
// 7EBA0: using guessed type int loggingThreshold;
// 80750: using guessed type int dword_80750;
// 80754: using guessed type int dword_80754;
// 80758: using guessed type int dword_80758;
// 482A5C: using guessed type char loggingVerbose;
// 58E354: using guessed type int dword_58E354;
// 590400: using guessed type int dword_590400;
// 590404: using guessed type char loggingDebug;

//----- (0002BC2C) --------------------------------------------------------
void __fastcall processCommandLineArguments(int argc, const char **argv)
{
  int actualArgumentCount; // [sp+Ch] [bp-80Ch] BYREF
  char logBuffer[2056]; // [sp+10h] [bp-808h] BYREF

  actualArgumentCount = argc;
  update_miner_status((int)&off_7E618, (int)"Options for both config file and command line");
  update_miner_status((int)&off_7EAC0, (int)"Options for command line only");
  initialize_and_check_status(&actualArgumentCount, argv, (void (*)(const char *, ...))fatal_error_logging);
  if ( actualArgumentCount != 1 )
  {
    strcpy(logBuffer, "Unexpected extra commandline arguments");
    logMessage(3, logBuffer, 1);
  }
  load_default_miner_config();
  if ( minerVersionFilename )
    readMinerVersionAndSerialNumber();
  if ( dword_80968 )
  {
    byte_482130 = 1;
    strcpy(byte_482158, (const char *)dword_80968);
    if ( dword_8096C )
      strcpy((char *)&word_482138, (const char *)dword_8096C);
    else
      strcpy((char *)&word_482138, "a+");
    if ( loggingDebug || loggingVerbose || loggingThreshold > 2 )
    {
      snprintf(logBuffer, 2048u, "Log file path: %s Open flag: %s", byte_482158, (const char *)&word_482138);
      logMessage(3, logBuffer, 0);
    }
  }
}
// 7E618: using guessed type char *off_7E618;
// 7EAC0: using guessed type char *off_7EAC0;
// 7EBA0: using guessed type int loggingThreshold;
// 80968: using guessed type int dword_80968;
// 8096C: using guessed type int dword_8096C;
// 80970: using guessed type int minerVersionFilename;
// 482130: using guessed type char byte_482130;
// 482138: using guessed type __int16 word_482138;
// 482A5C: using guessed type char loggingVerbose;
// 590404: using guessed type char loggingDebug;

//----- (0002BDC4) --------------------------------------------------------
int wait_for_semaphore()
{
  return sem_wait(&sem);
}

//----- (0002BDD0) --------------------------------------------------------
int reset_statistics()
{
  pthread_mutex_lock(&stru_810DC);
  dword_5945B8[0] = 0;
  dword_5945BC = 0;
  dword_5945C0 = 0;
  return pthread_mutex_unlock(&stru_810DC);
}
// 810DC: using guessed type pthread_mutex_t stru_810DC;
// 5945B8: using guessed type int dword_5945B8[];
// 5945BC: using guessed type int dword_5945BC;
// 5945C0: using guessed type int dword_5945C0;

//----- (0002BE08) --------------------------------------------------------
int reset_error_counters()
{
  pthread_mutex_lock(&stru_4FCAD0);
  dword_5955C8[0] = 0;
  dword_5955CC = 0;
  dword_5955D0 = 0;
  return pthread_mutex_unlock(&stru_4FCAD0);
}
// 4FCAD0: using guessed type pthread_mutex_t stru_4FCAD0;
// 5955C8: using guessed type int dword_5955C8[];
// 5955CC: using guessed type int dword_5955CC;
// 5955D0: using guessed type int dword_5955D0;

//----- (0002BE40) --------------------------------------------------------
int __fastcall process_chain_events(int chain_index, int should_reset)
{
  int is_chain_exist; // r0
  int processed_events; // r7
  int retry_count; // r10
  int temp_event_count; // r1
  int total_events; // r11
  int local_event_count; // r10
  int next_event_index; // r3
  int *current_event_ptr; // r12
  int event_chain_id; // r1
  int event_data; // r0
  bool is_current_chain_event; // zf
  int global_variable_value; // r10
  int max_event_threshold; // r11
  int chain_data_status; // r11
  unsigned int event_global_flag; // [sp+0h] [bp-830h]
  int remaining_events; // [sp+0h] [bp-830h]
  char log_buffer[2088]; // [sp+8h] [bp-828h] BYREF

  is_chain_exist = get_global_buffer_value(chain_index);
  if ( !is_chain_exist )
  {
    if ( (unsigned int)globalLogLevel > 3 )
    {
      snprintf(log_buffer, 2048u, "Chain %d is not exist.\n", chain_index);
      logMessage(3, log_buffer, 0);
      return 0;
    }
    return is_chain_exist;
  }
  if ( !should_reset )
    write_to_chain_buffer(chain_index, 0);
  processed_events = 0;
  reset_statistics();
  retry_count = 0;
  set_config_for_miner((unsigned __int8)chain_index, 1, 0, should_reset);
LABEL_8:
  while ( 2 )
  {
    get_next_sleep_interval();
    pthread_mutex_lock(&stru_810DC);
    temp_event_count = dword_5945C0;
    processed_events += dword_5945C0;
    total_events = dword_5945C0;
    if ( dword_5945C0 > 0 )
    {
      local_event_count = 0;
      while ( 1 )
      {
        dword_5945C0 = temp_event_count - 1;
        ++local_event_count;
        next_event_index = dword_5945BC + 1;
        current_event_ptr = &dword_5945B8[2 * dword_5945BC + 2];
        if ( (unsigned int)(dword_5945BC + 1) > 510 )
          next_event_index = 0;
        event_chain_id = *((unsigned __int8 *)current_event_ptr + 10);
        event_data = *((unsigned __int8 *)current_event_ptr + 11);
        dword_5945BC = next_event_index;
        is_current_chain_event = event_data == chain_index;
        if ( event_data == chain_index )
          is_current_chain_event = event_chain_id == 0;
        if ( is_current_chain_event
          && (event_global_flag = current_event_ptr[1], get_global_flag_value() == HIWORD(event_global_flag)) )
        {
          process_chain_index(chain_index);
          if ( total_events == local_event_count )
          {
LABEL_20:
            global_variable_value = get_global_variable_value();
            if ( processed_events > 5 * get_status_flag() * global_variable_value )
              goto LABEL_21;
            retry_count = 0;
            pthread_mutex_unlock(&stru_810DC);
            goto LABEL_8;
          }
        }
        else if ( total_events == local_event_count )
        {
          goto LABEL_20;
        }
        temp_event_count = dword_5945C0;
      }
    }
    remaining_events = dword_5945C0;
    max_event_threshold = get_global_variable_value();
    if ( processed_events > 5 * get_status_flag() * max_event_threshold )
      goto LABEL_21;
    if ( remaining_events )
    {
      if ( should_reset
        || (chain_data_status = get_global_variable_value(), chain_data_status != get_chain_data_status(chain_index)) )
      {
        pthread_mutex_unlock(&stru_810DC);
        continue;
      }
LABEL_21:
      pthread_mutex_unlock(&stru_810DC);
      return 1;
    }
    else
    {
      ++retry_count;
      get_next_sleep_interval();
      pthread_mutex_unlock(&stru_810DC);
      if ( retry_count != 4 )
        continue;
      return 1;
    }
  }
}
// 7EB9C: using guessed type int globalLogLevel;
// 810DC: using guessed type pthread_mutex_t stru_810DC;
// 5945B8: using guessed type int dword_5945B8[];
// 5945BC: using guessed type int dword_5945BC;
// 5945C0: using guessed type int dword_5945C0;

//----- (0002C06C) --------------------------------------------------------
int __fastcall ReadASICRegister(int reg, int chip, int chain)
{
  int currentCount; // r2
  int totalCount; // r9
  int iteration; // r5
  unsigned int index; // r3
  int *dataPointer; // r1
  int dataValue; // r4
  int *resultPointer; // [sp+1Ch] [bp-844h]
  char regLocal; // [sp+24h] [bp-83Ch]
  char chipLocal; // [sp+28h] [bp-838h]
  int chainLocal; // [sp+2Ch] [bp-834h]
  int retryCount; // [sp+30h] [bp-830h]
  int readAttempts; // [sp+34h] [bp-82Ch]
  char logBuffer[2088]; // [sp+38h] [bp-828h] BYREF

  regLocal = reg;
  chipLocal = chip;
  chainLocal = (unsigned __int8)chain;
  readAttempts = 5;
  pthread_mutex_lock(&stru_810F4);
  while ( 2 )
  {
    retryCount = 8;
    reset_statistics();
    set_config_for_miner(chainLocal, 0, chipLocal, regLocal);
    do
    {
      get_next_sleep_interval();
      pthread_mutex_lock(&stru_810DC);
      currentCount = dword_5945C0;
      if ( dword_5945C0 )
      {
        totalCount = dword_5945C0;
        iteration = 0;
        while ( 1 )
        {
          ++iteration;
          dword_5945C0 = currentCount - 1;
          index = dword_5945BC + 1;
          if ( (unsigned int)(dword_5945BC + 1) > 510 )
            dword_5945BC = 0;
          dataPointer = &dword_5945B8[2 * index];
          if ( index <= 510 )
            dword_5945BC = index;
          if ( *((unsigned __int8 *)dataPointer + 11) == chain
            && *((unsigned __int8 *)dataPointer + 9) == chip
            && *((unsigned __int8 *)dataPointer + 10) == reg )
          {
            break;
          }
          if ( (unsigned int)globalLogLevel > 3 )
          {
            snprintf(
              logBuffer,
              2048u,
              "read asic reg error: expect chain = %d, chip = %d, reg = %d, got chain = %d, chip = %d, reg = %d\n",
              chain,
              chip,
              reg,
              *((unsigned __int8 *)dataPointer + 11),
              BYTE1(dword_5945B8[2 * index + 2]),
              BYTE2(dword_5945B8[2 * index + 2]));
            logMessage(3, logBuffer, 0);
            if ( totalCount == iteration )
              goto LABEL_20;
          }
          else if ( totalCount == iteration )
          {
            goto LABEL_20;
          }
          currentCount = dword_5945C0;
        }
        if ( reg == 28 )
        {
          dataValue = dataPointer[1];
          if ( (dataValue & 0xE0000000) != 0 )
            dataValue = 0;
          pthread_mutex_unlock(&stru_810DC);
          reset_statistics();
          pthread_mutex_unlock(&stru_810F4);
          return dataValue;
        }
        else
        {
          resultPointer = &dword_5945B8[2 * index];
          pthread_mutex_unlock(&stru_810DC);
          reset_statistics();
          pthread_mutex_unlock(&stru_810F4);
          return resultPointer[1];
        }
      }
LABEL_20:
      pthread_mutex_unlock(&stru_810DC);
      --retryCount;
    }
    while ( retryCount );
    if ( --readAttempts )
      continue;
    break;
  }
  if ( (unsigned int)globalLogLevel > 4 )
  {
    snprintf(logBuffer, 2048u, "read asic reg timeout: expect chain = %d, chip = %d, reg = %d\n", chain, chip, reg);
    logMessage(4, logBuffer, 0);
  }
  reset_statistics();
  pthread_mutex_unlock(&stru_810F4);
  return 0;
}
// 7EB9C: using guessed type int globalLogLevel;
// 810DC: using guessed type pthread_mutex_t stru_810DC;
// 5945B8: using guessed type int dword_5945B8[];
// 5945BC: using guessed type int dword_5945BC;
// 5945C0: using guessed type int dword_5945C0;

//----- (0002C2E8) --------------------------------------------------------
int __fastcall handleASICCommand(int commandType, int commandValue, int chainId, int outputBuffer)
{
  int v7; // r0
  pthread_mutex_t *v8; // r10
  int v9; // r6
  int v10; // r8
  int v11; // r5
  int v12; // r3
  int *v13; // r6
  int v14; // r2
  int v15; // r10
  int v16; // r0
  int v17; // r0
  int v18; // r1
  unsigned int v19; // r6
  int miner_status_flag; // r0
  int v21; // r1
  int v22; // r0
  int v23; // r0
  pthread_mutex_t *mutex; // [sp+Ch] [bp-854h]
  int v27; // [sp+18h] [bp-848h]
  unsigned int v28; // [sp+1Ch] [bp-844h]
  int v29; // [sp+20h] [bp-840h]
  int v30; // [sp+28h] [bp-838h] BYREF
  int v31[2]; // [sp+30h] [bp-830h] BYREF
  char logBuffer[2088]; // [sp+38h] [bp-828h] BYREF

  if ( get_global_buffer_value(chainId) )
  {
    pthread_mutex_lock(&stru_810F4);
    initialize_miner_status();
    byte_8110C = 1;
    reset_statistics();
    if ( commandType == 2 )
    {
      v22 = sub_1E160();
      init_asic((unsigned __int8)chainId, commandValue * v22, 2);
    }
    else
    {
      v7 = sub_1E160();
      if ( commandType == 6 )
        initialize_miner_with_delay((unsigned __int8)chainId, commandValue * v7);
      else
        initialize_chip_frequency((unsigned __int8)chainId, commandValue * v7, commandType);
    }
    v8 = &stru_810DC;
    v27 = 0;
    v29 = 0;
    usleep((__useconds_t)&loc_186A0);
    do
    {
      pthread_mutex_lock(v8);
      v9 = dword_5945C0;
      v10 = dword_5945C0;
      if ( dword_5945C0 > 0 )
      {
        v11 = 0;
        mutex = v8;
        while ( 1 )
        {
          dword_5945C0 = v9 - 1;
          ++v11;
          v12 = dword_5945BC + 1;
          v13 = &dword_5945B8[2 * dword_5945BC + 2];
          if ( (unsigned int)(dword_5945BC + 1) > 510 )
            v12 = 0;
          v14 = *((unsigned __int8 *)v13 + 11);
          dword_5945BC = v12;
          if ( v14 == chainId
            && *((_BYTE *)v13 + 10) == 64
            && (v15 = *((unsigned __int8 *)v13 + 9),
                v16 = sub_1E160(),
                call_external_function_with_check(v15, v16) == commandValue)
            && (v28 = *((unsigned __int16 *)v13 + 3),
                ++v27,
                v17 = get_miner_status_flag(),
                calculate_difficulty_ratio(v28, v17),
                !*(_DWORD *)(outputBuffer + 4 * v18)) )
          {
            v19 = v13[1];
            ++v29;
            miner_status_flag = get_miner_status_flag();
            calculate_difficulty_ratio(HIWORD(v19), miner_status_flag);
            *(_DWORD *)(outputBuffer + 4 * v21) = (unsigned __int16)v19;
            if ( v10 == v11 )
            {
LABEL_20:
              v8 = mutex;
              pthread_mutex_unlock(mutex);
              goto LABEL_21;
            }
          }
          else if ( v10 == v11 )
          {
            goto LABEL_20;
          }
          v9 = dword_5945C0;
        }
      }
      pthread_mutex_unlock(v8);
      if ( !v9 )
        usleep(1000u);
LABEL_21:
      convert_timespec_to_custom_format(v31);
    }
    while ( (int)get_time_difference(v31, &v30) <= 199 );
    if ( v29 != get_miner_status_flag() && (unsigned int)globalLogLevel > 3 )
    {
      v23 = get_miner_status_flag();
      snprintf(
        logBuffer,
        2048u,
        "recv core response not enough!!!, total recv::%d, valid::%d, need::%d.\n",
        v27,
        v29,
        v23);
      logMessage(3, logBuffer, 0);
    }
    byte_8110C = 0;
    reset_global_counter();
    pthread_mutex_unlock(&stru_810F4);
    return 0;
  }
  else
  {
    if ( (unsigned int)globalLogLevel > 3 )
    {
      snprintf(logBuffer, 2048u, "chain::%d don't exist!!!\n", chainId);
      logMessage(3, logBuffer, 0);
    }
    return -1;
  }
}
// 2C4A4: variable 'v18' is possibly undefined
// 2C4DC: variable 'v21' is possibly undefined
// 7EB9C: using guessed type int globalLogLevel;
// 810DC: using guessed type pthread_mutex_t stru_810DC;
// 8110C: using guessed type char byte_8110C;
// 5945B8: using guessed type int dword_5945B8[];
// 5945BC: using guessed type int dword_5945BC;
// 5945C0: using guessed type int dword_5945C0;
// 2C2E8: using guessed type __time_t var_830[2];

//----- (0002C5E8) --------------------------------------------------------
_BYTE *__fastcall process_nonce_data(_BYTE *nonce_data)
{
  _BYTE *data_ptr; // r4
  int nonce_queue_index; // r11
  int queue_offset; // r7
  int block_version; // r8
  int *queue_entry; // r10
  int value_from_offset; // r0
  unsigned int current_log_level; // r3
  int adjusted_offset; // r7
  int *adjusted_queue_entry; // r4
  int nonce_value; // r5
  int chain_index; // r4
  unsigned int high_byte; // r8
  int voltage_status; // r0
  unsigned int chip_status; // r7
  unsigned int next_queue_index; // r3
  bool queue_limit_reached; // cc
  unsigned int higher_byte_boundary; // r0
  bool is_within_boundary; // cf
  unsigned int error_count_index; // r3
  unsigned int nonce_count_index; // r2
  int previous_nonce_count; // r0
  int previous_error_count; // r12
  char log_message_buffer[2088]; // [sp+8h] [bp-828h] BYREF

  if ( chipStatusInitialized )
  {
    data_ptr = nonce_data;
    if ( (*nonce_data & 0x80) != 0 )
    {
      if ( (*nonce_data & 0x40) != 0 )
      {
        if ( (unsigned int)globalLogLevel > 3 )
        {
          strcpy(log_message_buffer, "!!! nonce crc error\n");
          nonce_data = (_BYTE *)logMessage(3, log_message_buffer, 0);
        }
        ++dword_5955C0;
      }
      else
      {
        pthread_mutex_lock(&stru_4FCAD0);
        if ( (unsigned int)dword_5955D0 <= 510 )
        {
          nonce_queue_index = dword_5955C8[0];
          queue_offset = 16 * dword_5955C8[0];
          block_version = *((_WORD *)data_ptr + 1) & 0x7FFF;
          queue_entry = &dword_5955C8[15 * dword_5955C8[0]];
          queue_entry[4] = block_version;
          queue_entry[8] = *((_DWORD *)data_ptr + 1);
          queue_entry[9] = *data_ptr & 0xF;
          value_from_offset = get_value_from_offset(block_version);
          current_log_level = globalLogLevel;
          queue_entry[3] = value_from_offset;
          if ( current_log_level > 4 )
          {
            snprintf(log_message_buffer, 2048u, "blk ver = 0x%x\n", *(unsigned __int16 *)(data_ptr + 9));
            logMessage(4, log_message_buffer, 0);
          }
          adjusted_offset = queue_offset - nonce_queue_index;
          adjusted_queue_entry = &dword_5955C8[adjusted_offset];
          adjusted_queue_entry[5] = get_value_from_table(block_version);
          *((_QWORD *)adjusted_queue_entry + 3) = get_hashrate_value(block_version);
          copy_memory_region(block_version, (int)&dword_5955C8[adjusted_offset + 10], 32);
          nonce_value = dword_5955C8[adjusted_offset + 8];
          chain_index = dword_5955C8[adjusted_offset + 9];
          high_byte = get_high_byte(nonce_value);
          voltage_status = sub_1E160();
          chip_status = get_voltage_status(nonce_value, voltage_status);
          if ( chain_index > 3 || chip_status >= get_global_variable_value() )
            goto LABEL_34;
          higher_byte_boundary = get_miner_status_flag();
          is_within_boundary = 1;
          if ( nonce_value )
            is_within_boundary = high_byte >= higher_byte_boundary;
          if ( is_within_boundary )
          {
LABEL_34:
            if ( (unsigned int)globalLogLevel > 4 )
            {
              snprintf(log_message_buffer, 2048u, "buf [%x] is error!\n", nonce_value);
              logMessage(4, log_message_buffer, 0);
              if ( (unsigned int)globalLogLevel > 4 )
              {
                snprintf(
                  log_message_buffer,
                  2048u,
                  "chain = %d, chip = %d, core = %d\n",
                  chain_index,
                  chip_status,
                  high_byte);
                logMessage(4, log_message_buffer, 0);
              }
            }
          }
          else
          {
            error_count_index = chip_status + (chain_index << 8);
            nonce_count_index = high_byte + (error_count_index << 10);
            error_count_index += 4;
            nonce_count_index += 1028;
            previous_nonce_count = dword_81118[nonce_count_index];
            previous_error_count = dword_81118[error_count_index] + 1;
            ++dword_81118[chain_index];
            dword_81118[error_count_index] = previous_error_count;
            dword_81118[nonce_count_index] = previous_nonce_count + 1;
          }
          next_queue_index = dword_5955C8[0] + 1;
          queue_limit_reached = (unsigned int)(dword_5955C8[0] + 1) > 510;
          dword_5955C8[0] = next_queue_index;
          if ( next_queue_index > 510 )
            next_queue_index = 0;
          if ( queue_limit_reached )
            dword_5955C8[0] = next_queue_index;
          ++dword_5955D0;
          dword_81110 = 0;
        }
        else if ( !dword_81110 )
        {
          if ( (unsigned int)globalLogLevel > 3 )
          {
            strcpy(log_message_buffer, "nonce_read_out buffer is full!\n");
            logMessage(3, log_message_buffer, dword_81110);
          }
          dword_81110 = 1;
        }
        return (_BYTE *)pthread_mutex_unlock(&stru_4FCAD0);
      }
    }
    else if ( (unsigned int)globalLogLevel > 3 )
    {
      strcpy(log_message_buffer, "!!! nonce invalid\n");
      return (_BYTE *)logMessage(3, log_message_buffer, 0);
    }
  }
  return nonce_data;
}
// 7EB9C: using guessed type int globalLogLevel;
// 81110: using guessed type int dword_81110;
// 81118: using guessed type int dword_81118[3];
// 482A89: using guessed type char chipStatusInitialized;
// 4FCAD0: using guessed type pthread_mutex_t stru_4FCAD0;
// 5955C0: using guessed type int dword_5955C0;
// 5955C8: using guessed type int dword_5955C8[];
// 5955D0: using guessed type int dword_5955D0;

//----- (0002C96C) --------------------------------------------------------
int __fastcall handle_register_read_result(int read_result)
{
  int read_result_copy; // r5
  int reg_value_index; // r2
  int reg_read_status; // r4
  unsigned int new_reg_value_index; // r0
  int *reg_value_ptr; // r1
  int reg_control_byte; // lr
  char log_buffer[2064]; // [sp+0h] [bp-810h] BYREF

  if ( (*(_BYTE *)read_result & 0x40) != 0 )
  {
    if ( (unsigned int)globalLogLevel > 3 )
    {
      strcpy(log_buffer, "!!! reg crc error\n");
      read_result = logMessage(3, log_buffer, 0);
    }
    ++dword_5955BC;
  }
  else
  {
    read_result_copy = read_result;
    if ( (*(_BYTE *)(read_result + 3) & 0x60) != 0 )
    {
      if ( (unsigned int)globalLogLevel > 3 )
      {
        snprintf(log_buffer, 2048u, "!!! REG_TYPE = 1. %u\n", *(_DWORD *)read_result);
        return logMessage(3, log_buffer, 0);
      }
    }
    else
    {
      pthread_mutex_lock(&stru_810DC);
      reg_value_index = dword_5945C0;
      if ( (unsigned int)dword_5945C0 > 510 )
      {
        if ( (unsigned int)globalLogLevel > 3 )
        {
          strcpy(log_buffer, "reg_value_buf buffer is full!\n");
          logMessage(3, log_buffer, 0);
        }
      }
      else
      {
        reg_read_status = (unsigned __int8)byte_8110C;
        new_reg_value_index = dword_5945B8[0] + 1;
        reg_value_ptr = &dword_5945B8[2 * dword_5945B8[0] + 2];
        reg_value_ptr[1] = *(_DWORD *)(read_result_copy + 4);
        *((_BYTE *)reg_value_ptr + 8) = *(_BYTE *)(read_result_copy + 3) & 0x1F;
        *((_BYTE *)reg_value_ptr + 9) = *(_BYTE *)(read_result_copy + 2);
        reg_control_byte = *(unsigned __int8 *)(read_result_copy + 1);
        if ( reg_control_byte != 64 )
          reg_read_status |= 1u;
        *((_BYTE *)reg_value_ptr + 10) = reg_control_byte;
        *((_BYTE *)reg_value_ptr + 11) = *(_BYTE *)read_result_copy & 0xF;
        if ( reg_read_status )
        {
          dword_5945B8[0] = new_reg_value_index;
          dword_5945C0 = reg_value_index + 1;
          if ( new_reg_value_index > 510 )
            dword_5945B8[0] = 0;
        }
      }
      return pthread_mutex_unlock(&stru_810DC);
    }
  }
  return read_result;
}
// 7EB9C: using guessed type int globalLogLevel;
// 810DC: using guessed type pthread_mutex_t stru_810DC;
// 8110C: using guessed type char byte_8110C;
// 5945B8: using guessed type int dword_5945B8[];
// 5945C0: using guessed type int dword_5945C0;
// 5955BC: using guessed type int dword_5955BC;

//----- (0002CB2C) --------------------------------------------------------
int dump_asic_nonce_count()
{
  int nonce_offset; // r7
  int chain_index; // r6
  int log_result; // r0
  int chain_global_count; // r10
  int total_nonce_count; // r8
  int ic_index; // r4
  int nonce_count_for_ic; // r0
  int sum_nonces; // r2
  char *nonce_data_ptr; // r3
  char *nonce_data_end; // r0
  int current_nonce; // t1
  int ic_mod_value; // r0
  int calculation_result; // r1
  char message_buffer[2088]; // [sp+10h] [bp-828h] BYREF

  if ( (unsigned int)globalLogLevel > 4 )
  {
    strcpy(message_buffer, "\n dump asic nonce number...\n");
    logMessage(4, message_buffer, 0);
  }
  nonce_offset = 0;
  for ( chain_index = 0; chain_index != 4; ++chain_index )
  {
    log_result = get_global_buffer_value(chain_index);
    if ( log_result )
    {
      if ( (unsigned int)globalLogLevel > 4 )
      {
        snprintf(message_buffer, 2048u, "Chain[%d]:\n", chain_index);
        logMessage(4, message_buffer, 0);
      }
      log_result = get_global_variable_value();
      chain_global_count = log_result;
      total_nonce_count = 0;
      if ( log_result > 0 )
      {
        ic_index = 0;
        do
        {
          nonce_count_for_ic = get_miner_status_flag();
          if ( nonce_count_for_ic > 0 )
          {
            sum_nonces = 0;
            nonce_data_ptr = (char *)&unk_82124 + 4096 * (ic_index + nonce_offset);
            nonce_data_end = (char *)&unk_82124 + 4096 * (ic_index + nonce_offset) + 4 * nonce_count_for_ic;
            do
            {
              current_nonce = *((_DWORD *)nonce_data_ptr + 1);
              nonce_data_ptr += 4;
              sum_nonces += current_nonce;
            }
            while ( nonce_data_ptr != nonce_data_end );
            total_nonce_count += sum_nonces;
          }
          else
          {
            sum_nonces = 0;
          }
          if ( (unsigned int)globalLogLevel > 4 )
          {
            snprintf(message_buffer, 2048u, "IC[%03d] = %-10d ", ic_index, sum_nonces);
            logMessage(4, message_buffer, 0);
          }
          ++ic_index;
          ic_mod_value = get_global_value();
          log_result = calculate_modulo(ic_index, ic_mod_value);
          if ( !calculation_result && (unsigned int)globalLogLevel > 4 )
          {
            strcpy(message_buffer, "\n");
            log_result = logMessage(4, message_buffer, 0);
          }
        }
        while ( ic_index != chain_global_count );
      }
      if ( (unsigned int)globalLogLevel > 4 )
      {
        snprintf(message_buffer, 2048u, "Chain[%d] total nonce number = %d\n", chain_index, total_nonce_count);
        log_result = logMessage(4, message_buffer, 0);
        if ( (unsigned int)globalLogLevel > 4 )
        {
          strcpy(message_buffer, "\n");
          log_result = logMessage(4, message_buffer, 0);
        }
      }
    }
    nonce_offset += 256;
  }
  return log_result;
}
// 2CC14: variable 'calculation_result' is possibly undefined
// 7EB9C: using guessed type int globalLogLevel;

//----- (0002CD30) --------------------------------------------------------
int __fastcall sub_2CD30(int block_index, unsigned int data_length)
{
  int miner_status_flag; // r4
  int system_status; // r0
  int difficulty_multiplier; // r5
  int retrieved_status; // r0
  unsigned int adjusted_difficulty; // r4
  unsigned int checksum_start_index; // r4
  int latest_system_status; // r0
  int unused_parameter; // r1
  unsigned int length_adjusted_by_difficulty; // r6
  int checksum_increment; // r0
  unsigned int checksum_end_index; // r1
  unsigned int total_adjusted_length; // r7
  int data_offset_multiplier; // r5
  int checksum_accumulator; // r0
  char *base_memory_address; // lr
  char *current_memory_address; // r3
  int current_data_value; // t1

  miner_status_flag = get_miner_status_flag();
  system_status = get_embedded_system_status();
  difficulty_multiplier = call_external_function_with_check(miner_status_flag, system_status);
  retrieved_status = get_embedded_system_status();
  adjusted_difficulty = calculate_bit_difficulty(data_length, retrieved_status);
  checksum_start_index = adjusted_difficulty * get_global_value();
  latest_system_status = get_embedded_system_status();
  calculate_difficulty_ratio(data_length, latest_system_status);
  length_adjusted_by_difficulty = difficulty_multiplier * unused_parameter;
  checksum_increment = get_global_value();
  checksum_end_index = checksum_increment + checksum_start_index;
  total_adjusted_length = difficulty_multiplier + length_adjusted_by_difficulty;
  if ( checksum_start_index >= checksum_increment + checksum_start_index )
    return 0;
  data_offset_multiplier = 4 * difficulty_multiplier;
  checksum_accumulator = 0;
  base_memory_address = (char *)&unk_81114
                      + 4096 * (checksum_start_index + (block_index << 8))
                      + 4 * length_adjusted_by_difficulty
                      + 4112;
  do
  {
    if ( length_adjusted_by_difficulty < total_adjusted_length )
    {
      current_memory_address = base_memory_address;
      do
      {
        current_data_value = *((_DWORD *)current_memory_address + 1);
        current_memory_address += 4;
        checksum_accumulator += current_data_value;
      }
      while ( current_memory_address != &base_memory_address[data_offset_multiplier] );
    }
    ++checksum_start_index;
    base_memory_address += 4096;
  }
  while ( checksum_end_index != checksum_start_index );
  return checksum_accumulator;
}
// 2CD84: variable 'unused_parameter' is possibly undefined

//----- (0002CDFC) --------------------------------------------------------
int __fastcall get_asic_register_value(unsigned int asic_index, unsigned int register_offset)
{
  bool is_offset_valid; // cc

  is_offset_valid = register_offset > 255;
  if ( register_offset <= 255 )
    is_offset_valid = asic_index > 3;
  if ( is_offset_valid )
    return 0;
  else
    return dword_81118[256 * asic_index + 4 + register_offset];
}
// 81118: using guessed type int dword_81118[3];

//----- (0002CE20) --------------------------------------------------------
int dump_nonce_count()
{
  int chain_index; // r5
  int status; // r0
  int accumulated_nonce_count; // r7
  unsigned int i; // r4
  int embedded_system_status; // r0
  int undefined_2; // r1
  int global_state_value; // r6
  int total_nonces; // r3
  int nonce_count; // r0
  char log_buffer[2088]; // [sp+10h] [bp-828h] BYREF

  if ( (unsigned int)globalLogLevel > 4 )
  {
    strcpy(log_buffer, "\n dump domain nonce number...\n");
    logMessage(4, log_buffer, 0);
  }
  for ( chain_index = 0; chain_index != 4; ++chain_index )
  {
    status = get_global_buffer_value(chain_index);
    if ( status )
    {
      if ( (unsigned int)globalLogLevel > 4 )
      {
        snprintf(log_buffer, 2048u, "Chain[%d]:\n", chain_index);
        logMessage(4, log_buffer, 0);
      }
      accumulated_nonce_count = 0;
      for ( i = 0; ; ++i )
      {
        global_state_value = get_global_state_value();
        total_nonces = get_embedded_system_status() * global_state_value;
        status = chain_index;
        if ( total_nonces <= (int)i )
          break;
        nonce_count = sub_2CD30(chain_index, i);
        accumulated_nonce_count += nonce_count;
        if ( (unsigned int)globalLogLevel > 4 )
        {
          snprintf(log_buffer, 2048u, "D[%02d]:%-10d ", i, nonce_count);
          logMessage(4, log_buffer, 0);
        }
        embedded_system_status = get_embedded_system_status();
        calculate_modulo(i + 1, embedded_system_status);
        if ( !undefined_2 )
        {
          if ( (unsigned int)globalLogLevel > 4 )
          {
            snprintf(log_buffer, 2048u, "D_BIG[%02d]:%-10d\n", i >> 2, accumulated_nonce_count);
            accumulated_nonce_count = 0;
            logMessage(4, log_buffer, 0);
          }
          else
          {
            accumulated_nonce_count = 0;
          }
        }
      }
      if ( (unsigned int)globalLogLevel > 4 )
      {
        strcpy(log_buffer, "\n");
        status = logMessage(4, log_buffer, 0);
      }
    }
  }
  return status;
}
// 2CEB4: variable 'undefined_2' is possibly undefined
// 7EB9C: using guessed type int globalLogLevel;

//----- (0002CFEC) --------------------------------------------------------
char *get_firmware_version_pointer()
{
  return off_7EB98;
}
// 7EB98: using guessed type char *off_7EB98;

//----- (0002CFFC) --------------------------------------------------------
int __fastcall print_asic_nonce_numbers(int chain_index, int asic_index)
{
  int asic_count; // r0
  int validated_asic_count; // r6
  unsigned int current_log_level; // r12
  int asic_address_offset; // r7
  unsigned int nonce_index; // r4
  int formatted_nonce_index; // r3
  int asic_nonce_data_offset; // r1
  char log_buffer[2]; // [sp+8h] [bp-820h] BYREF

  if ( (unsigned int)globalLogLevel > 3 )
  {
    snprintf(log_buffer, 2048u, "\n asic nonce number for chain[%d] asic[%d]...\n", chain_index, asic_index);
    append_log_message(3, log_buffer, 0);
    asic_count = get_miner_status_flag();
    validated_asic_count = asic_count;
    if ( asic_count > 0 )
      goto LABEL_3;
  }
  else
  {
    asic_count = get_miner_status_flag();
    validated_asic_count = asic_count;
    if ( asic_count > 0 )
    {
LABEL_3:
      current_log_level = globalLogLevel;
      asic_address_offset = (asic_index + (chain_index << 8)) << 12;
      nonce_index = 0;
      while ( 1 )
      {
        if ( current_log_level > 3 )
        {
          formatted_nonce_index = nonce_index;
          asic_nonce_data_offset = asic_address_offset + 4 * nonce_index++ + 4112;
          snprintf(
            log_buffer,
            2048u,
            "core[%03d]=%-8d",
            formatted_nonce_index,
            *(int *)((char *)dword_81118 + asic_nonce_data_offset));
          append_log_message(3, log_buffer, 0);
          asic_count = 3;
          current_log_level = globalLogLevel;
          if ( nonce_index != 10 * (nonce_index / 10) || (unsigned int)globalLogLevel <= 3 )
            goto LABEL_4;
          strcpy(log_buffer, "\n");
          asic_count = (int)append_log_message(3, log_buffer, nonce_index % 10);
          current_log_level = globalLogLevel;
          if ( validated_asic_count == nonce_index )
            goto LABEL_10;
        }
        else
        {
          ++nonce_index;
LABEL_4:
          if ( validated_asic_count == nonce_index )
            goto LABEL_10;
        }
      }
    }
  }
  current_log_level = globalLogLevel;
LABEL_10:
  if ( current_log_level > 3 )
  {
    strcpy(log_buffer, "\n");
    return (int)append_log_message(3, log_buffer, 0);
  }
  return asic_count;
}
// 7EB9C: using guessed type int globalLogLevel;
// 81118: using guessed type int dword_81118[3];

//----- (0002D158) --------------------------------------------------------
int dump_nonce_info()
{
  int current_string_offset; // r4
  int chain_index; // r11
  int nonce_count_for_chain; // r6
  int result; // r0
  _DWORD *logger_instance; // r0
  int asic_index; // r5
  char *chain_nonce_data; // r8
  int nonce_number; // t1
  int next_asic_index; // r7
  int chars_written; // r9
  int num_asic_per_chain; // r0
  int modulo_result; // r1
  _DWORD *logger_instance_checked; // r9
  int chain_domain; // r0
  int domain_index; // r0
  int total_nonce_count; // [sp+18h] [bp-148h]
  int total_asics; // [sp+24h] [bp-13Ch]
  char nonce_info_string[296]; // [sp+38h] [bp-128h] BYREF

  current_string_offset = 0;
  chain_index = 0;
  nonce_count_for_chain = 0;
  memset(nonce_info_string, 0, 256u);
  do
  {
    result = get_global_buffer_value(chain_index);
    if ( result )
    {
      logger_instance = (_DWORD *)unk_81114;
      if ( !unk_81114 )
      {
        logger_instance = get_logging_category("bmminer_nonce");
        unk_81114 = logger_instance;
      }
      log_event(
        (int)logger_instance,
        "asic_response.c",
        15,
        (int)"dump_nonce_info_all_core",
        24,
        538,
        20,
        (int)"\n asic nonce number for chain[%d]...\n",
        chain_index);
      result = get_global_variable_value();
      total_asics = result;
      if ( result > 0 )
      {
        asic_index = 0;
        chain_nonce_data = (char *)&unk_81124 + 1024 * chain_index;
        do
        {
          nonce_number = *((_DWORD *)chain_nonce_data + 1);
          chain_nonce_data += 4;
          next_asic_index = asic_index + 1;
          nonce_count_for_chain += nonce_number;
          chars_written = snprintf(
                            &nonce_info_string[current_string_offset],
                            256 - current_string_offset,
                            "asic[%03d]=%-8d",
                            asic_index,
                            nonce_number);
          num_asic_per_chain = get_global_value();
          result = calculate_modulo(asic_index + 1, num_asic_per_chain);
          current_string_offset += chars_written;
          if ( !modulo_result )
          {
            logger_instance_checked = (_DWORD *)unk_81114;
            if ( !unk_81114 )
            {
              logger_instance_checked = get_logging_category("bmminer_nonce");
              unk_81114 = logger_instance_checked;
            }
            chain_domain = get_global_value();
            total_nonce_count = nonce_count_for_chain;
            nonce_count_for_chain = 0;
            current_string_offset = 0;
            domain_index = call_external_function_with_check(asic_index, chain_domain);
            result = log_event(
                       (int)logger_instance_checked,
                       "asic_response.c",
                       15,
                       (int)"dump_nonce_info_all_core",
                       24,
                       544,
                       20,
                       (int)"domain %02d %s total=%-8u",
                       domain_index,
                       nonce_info_string,
                       total_nonce_count);
          }
          ++asic_index;
        }
        while ( next_asic_index != total_asics );
      }
    }
    ++chain_index;
  }
  while ( chain_index != 4 );
  return result;
}
// 2D280: variable 'modulo_result' is possibly undefined
// 2D158: using guessed type char s[296];

//----- (0002D340) --------------------------------------------------------
void __fastcall expand_list_storage(
        const char **list,
        const char *caller_filename,
        const char *caller_function_name,
        int caller_line_number)
{
  const char *current_limit; // r3
  const char *current_ptr; // r2
  signed int new_items_count; // r6
  char *item_pointers; // r0
  const char *updated_count; // r1
  const char *realloced_pointers; // r0
  char *new_item; // r5
  const char *current_items_ptr; // r3
  const char *list_name; // r1
  __int64 item_ptr_pair; // r2
  int is_last_item; // r0
  int last_item_offset; // r3
  int pre_last_item_offset; // r2
  char *last_item_ptr; // r3
  char *data_pointers; // r0
  const char *new_data_count; // r1
  const char *realloced_data_pointers; // r0
  void *new_data_ptr; // r0
  char error_message_buffer[2072]; // [sp+20h] [bp-818h] BYREF

  if ( *((_BYTE *)list + 4) )
  {
    snprintf(
      error_message_buffer,
      2048u,
      "List %s store can't %s() - from %s %s() line %d in %s %s():%d",
      *list,
      "k_alloc_items",
      caller_filename,
      caller_function_name,
      caller_line_number,
      "klist.c",
      "k_alloc_items",
      19);
    logMessage(3, error_message_buffer, 1);
    nullsub_1();
  }
  current_limit = list[10];
  if ( (int)current_limit <= 0 )
  {
    new_items_count = (signed int)list[9];
  }
  else
  {
    current_ptr = list[6];
    if ( (int)current_limit <= (int)current_ptr )
      return;
    new_items_count = (signed int)list[9];
    if ( (int)current_limit < (int)&current_ptr[new_items_count] )
      new_items_count = current_limit - current_ptr;
  }
  item_pointers = (char *)list[13];
  updated_count = list[12] + 1;
  list[12] = updated_count;
  realloced_pointers = (const char *)realloc(item_pointers, 4 * (_DWORD)updated_count);
  list[13] = realloced_pointers;
  if ( !realloced_pointers )
  {
    snprintf(
      error_message_buffer,
      2048u,
      "List %s item_memory failed to realloc count=%d in %s %s():%d",
      *list,
      list[12],
      "klist.c",
      "k_alloc_items",
      33);
    logMessage(3, error_message_buffer, 1);
    nullsub_1();
  }
  new_item = (char *)calloc(new_items_count, 16u);
  if ( !new_item )
  {
    snprintf(
      error_message_buffer,
      2048u,
      "List %s failed to calloc %d new items - total was %d, limit was %d in %s %s():%d",
      *list,
      new_items_count,
      list[6],
      list[10],
      "klist.c",
      "k_alloc_items",
      38);
    logMessage(3, error_message_buffer, 1);
    nullsub_1();
  }
  *(_DWORD *)&list[13][4 * (_DWORD)(list[12] + 1073741823)] = new_item;
  current_items_ptr = list[6];
  list_name = *list;
  list[7] = (const char *)new_items_count;
  list[8] = (const char *)new_items_count;
  list[6] = &current_items_ptr[new_items_count];
  *(_DWORD *)new_item = list_name;
  *((_DWORD *)new_item + 1) = 0;
  *((_DWORD *)new_item + 2) = new_item + 16;
  if ( new_items_count > 2 )
  {
    HIDWORD(item_ptr_pair) = new_item + 32;
    do
    {
      LODWORD(item_ptr_pair) = HIDWORD(item_ptr_pair) - 32;
      *(_DWORD *)(HIDWORD(item_ptr_pair) - 16) = list_name;
      *(_QWORD *)(HIDWORD(item_ptr_pair) - 12) = item_ptr_pair;
      HIDWORD(item_ptr_pair) += 16;
    }
    while ( (char *)HIDWORD(item_ptr_pair) != &new_item[16 * new_items_count] );
  }
  is_last_item = *((unsigned __int8 *)list + 44);
  last_item_offset = 16 * (new_items_count + 268435455);
  *(_DWORD *)&new_item[last_item_offset] = list_name;
  list[3] = new_item;
  pre_last_item_offset = last_item_offset - 16;
  last_item_ptr = &new_item[last_item_offset];
  *((_DWORD *)last_item_ptr + 1) = &new_item[pre_last_item_offset];
  *((_DWORD *)last_item_ptr + 2) = 0;
  if ( is_last_item )
    list[4] = last_item_ptr;
  do
  {
    data_pointers = (char *)list[15];
    new_data_count = list[14] + 1;
    list[14] = new_data_count;
    realloced_data_pointers = (const char *)realloc(data_pointers, 4 * (_DWORD)new_data_count);
    list[15] = realloced_data_pointers;
    if ( !realloced_data_pointers )
    {
      snprintf(
        error_message_buffer,
        2048u,
        "List %s data_memory failed to realloc count=%d in %s %s():%d",
        *list,
        list[14],
        "klist.c",
        "k_alloc_items",
        69);
      logMessage(3, error_message_buffer, 1);
      nullsub_1();
    }
    new_data_ptr = calloc(1u, (size_t)list[5]);
    *((_DWORD *)new_item + 3) = new_data_ptr;
    if ( !new_data_ptr )
    {
      snprintf(
        error_message_buffer,
        2048u,
        "List %s failed to calloc item data in %s %s():%d",
        *list,
        "klist.c",
        "k_alloc_items",
        73);
      logMessage(3, error_message_buffer, 1);
      nullsub_1();
      new_data_ptr = (void *)*((_DWORD *)new_item + 3);
    }
    *(_DWORD *)&list[15][4 * (_DWORD)(list[14] + 1073741823)] = new_data_ptr;
    new_item = (char *)*((_DWORD *)new_item + 2);
  }
  while ( new_item );
}

//----- (0002D724) --------------------------------------------------------
_BYTE *__fastcall initialize_list(
        const char *list_name,
        int unknown_param,
        int allocation_count,
        int limit_param,
        char flag_param,
        const char *init_string_one,
        const char *init_string_two,
        int init_param)
{
  _BYTE *list_ptr; // r4
  char *lock_ptr; // r5
  int *errno_ptr_init_rwlock; // r0
  int *errno_ptr_init_mutex; // r0
  char error_message[2080]; // [sp+10h] [bp-820h] BYREF

  if ( allocation_count <= 0 )
  {
    snprintf(
      error_message,
      2048u,
      "Invalid new list %s with allocate %d must be > 0 in %s %s():%d",
      list_name,
      allocation_count,
      "klist.c",
      "_k_new_list",
      100);
    logMessage(3, error_message, 1);
    nullsub_1();
    if ( limit_param >= 0 )
      goto LABEL_3;
  }
  else if ( limit_param >= 0 )
  {
    goto LABEL_3;
  }
  snprintf(
    error_message,
    2048u,
    "Invalid new list %s with limit %d must be >= 0 in %s %s():%d",
    list_name,
    limit_param,
    "klist.c",
    "_k_new_list",
    103);
  logMessage(3, error_message, 1);
  nullsub_1();
LABEL_3:
  list_ptr = calloc(1u, 64u);
  if ( !list_ptr )
  {
    snprintf(error_message, 2048u, "Failed to calloc list %s in %s %s():%d", list_name, "klist.c", "_k_new_list", 107);
    logMessage(3, error_message, 1);
    nullsub_1();
  }
  list_ptr[4] = 0;
  lock_ptr = (char *)calloc(1u, 56u);
  *((_DWORD *)list_ptr + 2) = lock_ptr;
  if ( !lock_ptr )
  {
    snprintf(
      error_message,
      2048u,
      "Failed to calloc lock for list %s in %s %s():%d",
      list_name,
      "klist.c",
      "_k_new_list",
      113);
    logMessage(3, error_message, 1);
    nullsub_1();
    lock_ptr = (char *)*((_DWORD *)list_ptr + 2);
  }
  if ( pthread_mutex_init((pthread_mutex_t *)lock_ptr, 0) )
  {
    errno_ptr_init_mutex = _errno_location();
    snprintf(
      error_message,
      2048u,
      "Failed to pthread_mutex_init errno=%d in %s %s():%d",
      *errno_ptr_init_mutex,
      "klist.c",
      "_k_new_list",
      115);
    logMessage(3, error_message, 1);
    nullsub_1();
  }
  if ( pthread_rwlock_init((pthread_rwlock_t *)(lock_ptr + 24), 0) )
  {
    errno_ptr_init_rwlock = _errno_location();
    snprintf(
      error_message,
      2048u,
      "Failed to pthread_rwlock_init errno=%d in %s %s():%d",
      *errno_ptr_init_rwlock,
      "klist.c",
      "_k_new_list",
      115);
    logMessage(3, error_message, 1);
    nullsub_1();
  }
  *(_DWORD *)list_ptr = list_name;
  *((_DWORD *)list_ptr + 5) = unknown_param;
  *((_DWORD *)list_ptr + 9) = allocation_count;
  *((_DWORD *)list_ptr + 10) = limit_param;
  list_ptr[44] = flag_param;
  expand_list_storage((const char **)list_ptr, init_string_one, init_string_two, init_param);
  return list_ptr;
}

//----- (0002D9D4) --------------------------------------------------------
int __fastcall pop_task_from_queue(int queue, const char *task_data, const char *task_identifier, int priority)
{
  int next_task; // r12
  int next_task_next; // r3
  int popped_task; // r0

  next_task = *(_DWORD *)(queue + 12);
  if ( !next_task )
  {
    if ( *(_BYTE *)(queue + 4) )
      return 0;
    expand_list_storage((const char **)queue, task_data, task_identifier, priority);
    next_task = *(_DWORD *)(queue + 12);
    if ( !next_task )
      return 0;
  }
  next_task_next = *(_DWORD *)(next_task + 8);
  *(_DWORD *)(queue + 12) = next_task_next;
  if ( next_task_next )
  {
    *(_DWORD *)(next_task_next + 4) = 0;
  }
  else if ( *(_BYTE *)(queue + 44) )
  {
    *(_DWORD *)(queue + 16) = 0;
  }
  popped_task = next_task;
  *(_DWORD *)(next_task + 8) = 0;
  *(_DWORD *)(next_task + 4) = 0;
  --*(_DWORD *)(queue + 28);
  return popped_task;
}

//----- (0002DA5C) --------------------------------------------------------
int __fastcall clear_task_memory(int queue_handle, const char *param_2, const char *param_3, int param_4)
{
  int task_ptr; // r0
  int task_memory_cleared; // r4

  task_ptr = pop_task_from_queue(queue_handle, param_2, param_3, param_4);
  task_memory_cleared = task_ptr;
  if ( task_ptr )
    memset(*(void **)(task_ptr + 12), 0, *(_DWORD *)(queue_handle + 20));
  return task_memory_cleared;
}

//----- (0002DA88) --------------------------------------------------------
int __fastcall unlink_tail_from_list(
        int list_ptr,
        const char *caller_filename,
        const char *caller_function_name,
        int caller_line_number)
{
  int tail_element; // r0
  int new_tail; // r3
  char log_buffer[2064]; // [sp+20h] [bp-810h] BYREF

  if ( !*(_BYTE *)(list_ptr + 44) )
  {
    snprintf(
      log_buffer,
      2048u,
      "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d",
      *(const char **)list_ptr,
      "_k_unlink_tail",
      caller_filename,
      caller_function_name,
      caller_line_number,
      "klist.c",
      "_k_unlink_tail",
      181);
    logMessage(3, log_buffer, 1);
    nullsub_1();
  }
  tail_element = *(_DWORD *)(list_ptr + 16);
  if ( tail_element )
  {
    new_tail = *(_DWORD *)(tail_element + 4);
    *(_DWORD *)(list_ptr + 16) = new_tail;
    if ( new_tail )
      caller_function_name = 0;
    else
      *(_DWORD *)(list_ptr + 12) = 0;
    if ( new_tail )
      *(_DWORD *)(new_tail + 8) = caller_function_name;
    *(_DWORD *)(tail_element + 8) = 0;
    *(_DWORD *)(tail_element + 4) = 0;
    --*(_DWORD *)(list_ptr + 28);
  }
  return tail_element;
}
// 2DAC4: variable 'caller_function_name' is possibly undefined

//----- (0002DB50) --------------------------------------------------------
void __fastcall add_item_to_list(
        int list_header_ptr,
        int new_item_ptr,
        const char *caller_filename,
        const char *caller_function,
        int caller_line_number)
{
  int next_item_ptr; // r3
  int is_list_initialized; // r3
  __int64 item_count; // r2
  char error_message[2064]; // [sp+20h] [bp-810h] BYREF

  if ( *(_DWORD *)new_item_ptr != *(_DWORD *)list_header_ptr )
  {
    snprintf(
      error_message,
      2048u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      *(const char **)list_header_ptr,
      "_k_add_head",
      *(const char **)new_item_ptr,
      caller_filename,
      caller_function,
      caller_line_number,
      "klist.c",
      "_k_add_head",
      205);
    logMessage(3, error_message, 1);
    nullsub_1();
  }
  *(_DWORD *)(new_item_ptr + 4) = 0;
  *(_DWORD *)(new_item_ptr + 8) = *(_DWORD *)(list_header_ptr + 12);
  next_item_ptr = *(_DWORD *)(list_header_ptr + 12);
  if ( next_item_ptr )
    *(_DWORD *)(next_item_ptr + 4) = new_item_ptr;
  is_list_initialized = *(unsigned __int8 *)(list_header_ptr + 44);
  *(_DWORD *)(list_header_ptr + 12) = new_item_ptr;
  if ( is_list_initialized && !*(_DWORD *)(list_header_ptr + 16) )
    *(_DWORD *)(list_header_ptr + 16) = new_item_ptr;
  item_count = *(_QWORD *)(list_header_ptr + 28);
  LODWORD(item_count) = item_count + 1;
  ++HIDWORD(item_count);
  *(_QWORD *)(list_header_ptr + 28) = item_count;
}

//----- (0002DC24) --------------------------------------------------------
void __fastcall sub_2DC24(const char **result, int a2, const char *a3, const char *a4, int a5)
{
  const char *v7; // r1
  const char *v10; // r3
  const char *v11; // r3
  const char *v12; // r3
  bool v13; // zf
  __int64 v14; // r2
  char s[2072]; // [sp+20h] [bp-818h] BYREF

  v7 = *(const char **)a2;
  if ( v7 != *result )
  {
    snprintf(
      s,
      2048u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      *result,
      "_k_add_tail",
      v7,
      a3,
      a4,
      a5,
      "klist.c",
      "_k_add_tail",
      236);
    logMessage(3, s, 1);
    nullsub_1();
  }
  if ( !*((_BYTE *)result + 44) )
  {
    snprintf(
      s,
      2048u,
      "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d",
      *result,
      "_k_add_tail",
      a3,
      a4,
      a5,
      "klist.c",
      "_k_add_tail",
      241);
    logMessage(3, s, 1);
    nullsub_1();
  }
  v10 = result[4];
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 4) = v10;
  v11 = result[4];
  if ( v11 )
    *((_DWORD *)v11 + 2) = a2;
  v12 = result[3];
  result[4] = (const char *)a2;
  v13 = v12 == 0;
  v14 = *(_QWORD *)(result + 7);
  if ( v13 )
    result[3] = (const char *)a2;
  LODWORD(v14) = v14 + 1;
  ++HIDWORD(v14);
  *(_QWORD *)(result + 7) = v14;
}

//----- (0002DD70) --------------------------------------------------------
void __fastcall insert_item_in_list(
        const char **list_pointer,
        int item_to_insert,
        int insertion_point,
        const char *source_file_name,
        const char *function_name,
        int line_number)
{
  const char *inserted_item_label; // r1
  int previous_item; // r3
  __int64 item_count; // r2
  char error_message[2072]; // [sp+20h] [bp-818h] BYREF

  inserted_item_label = *(const char **)item_to_insert;
  if ( inserted_item_label != *list_pointer )
  {
    snprintf(
      error_message,
      2048u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      *list_pointer,
      "_k_insert_before",
      inserted_item_label,
      source_file_name,
      function_name,
      line_number,
      "klist.c",
      "_k_insert_before",
      262);
    logMessage(3, error_message, 1);
    nullsub_1();
  }
  if ( !insertion_point )
  {
    snprintf(
      error_message,
      2048u,
      "%s() (%s) can't before a null item - from %s %s() line %d in %s %s():%d",
      "_k_insert_before",
      *list_pointer,
      source_file_name,
      function_name,
      line_number,
      "klist.c",
      "_k_insert_before",
      267);
    logMessage(3, error_message, 1);
    nullsub_1();
  }
  *(_DWORD *)(item_to_insert + 8) = insertion_point;
  *(_DWORD *)(item_to_insert + 4) = *(_DWORD *)(insertion_point + 4);
  previous_item = *(_DWORD *)(insertion_point + 4);
  if ( previous_item )
    *(_DWORD *)(previous_item + 8) = item_to_insert;
  else
    list_pointer[3] = (const char *)item_to_insert;
  *(_DWORD *)(insertion_point + 4) = item_to_insert;
  item_count = *(_QWORD *)(list_pointer + 7);
  LODWORD(item_count) = item_count + 1;
  ++HIDWORD(item_count);
  *(_QWORD *)(list_pointer + 7) = item_count;
}

//----- (0002DEB8) --------------------------------------------------------
void __fastcall insert_after_in_klist(
        const char **target_list,
        int new_item_pointer,
        int previous_item_pointer,
        const char *file_name,
        const char *function_name,
        int line_number)
{
  const char *current_item_value; // r1
  int next_item_pointer_value; // r3
  __int64 item_count; // r2
  char log_buffer[2072]; // [sp+20h] [bp-818h] BYREF

  current_item_value = *(const char **)new_item_pointer;
  if ( current_item_value != *target_list )
  {
    snprintf(
      log_buffer,
      2048u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      *target_list,
      "_k_insert_after",
      current_item_value,
      file_name,
      function_name,
      line_number,
      "klist.c",
      "_k_insert_after",
      286);
    logMessage(3, log_buffer, 1);
    nullsub_1();
  }
  if ( !previous_item_pointer )
  {
    snprintf(
      log_buffer,
      2048u,
      "%s() (%s) can't after a null item - from %s %s() line %d in %s %s():%d",
      "_k_insert_after",
      *target_list,
      file_name,
      function_name,
      line_number,
      "klist.c",
      "_k_insert_after",
      291);
    logMessage(3, log_buffer, 1);
    nullsub_1();
  }
  *(_DWORD *)(new_item_pointer + 4) = previous_item_pointer;
  *(_DWORD *)(new_item_pointer + 8) = *(_DWORD *)(previous_item_pointer + 8);
  next_item_pointer_value = *(_DWORD *)(previous_item_pointer + 8);
  if ( next_item_pointer_value )
  {
    *(_DWORD *)(next_item_pointer_value + 4) = new_item_pointer;
  }
  else if ( *((_BYTE *)target_list + 44) )
  {
    target_list[4] = (const char *)new_item_pointer;
  }
  *(_DWORD *)(previous_item_pointer + 8) = new_item_pointer;
  item_count = *(_QWORD *)(target_list + 7);
  LODWORD(item_count) = item_count + 1;
  ++HIDWORD(item_count);
  *(_QWORD *)(target_list + 7) = item_count;
}

//----- (0002E00C) --------------------------------------------------------
void __fastcall verify_and_remove_klist_item(
        int klist_ptr,
        int item_ptr,
        const char *file_name,
        const char *function_name,
        int line_number)
{
  __int64 item_links; // r2
  char error_message[2064]; // [sp+20h] [bp-810h] BYREF

  if ( *(_DWORD *)item_ptr != *(_DWORD *)klist_ptr )
  {
    snprintf(
      error_message,
      2048u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      *(const char **)klist_ptr,
      "_k_unlink_item",
      *(const char **)item_ptr,
      file_name,
      function_name,
      line_number,
      "klist.c",
      "_k_unlink_item",
      312);
    logMessage(3, error_message, 1);
    nullsub_1();
  }
  item_links = *(_QWORD *)(item_ptr + 4);
  if ( (_DWORD)item_links )
  {
    *(_DWORD *)(item_links + 8) = HIDWORD(item_links);
    HIDWORD(item_links) = *(_DWORD *)(item_ptr + 8);
  }
  if ( HIDWORD(item_links) )
    *(_DWORD *)(HIDWORD(item_links) + 4) = *(_DWORD *)(item_ptr + 4);
  if ( *(_DWORD *)(klist_ptr + 12) == item_ptr )
    *(_DWORD *)(klist_ptr + 12) = *(_DWORD *)(item_ptr + 8);
  if ( *(_BYTE *)(klist_ptr + 44) && *(_DWORD *)(klist_ptr + 16) == item_ptr )
    *(_DWORD *)(klist_ptr + 16) = *(_DWORD *)(item_ptr + 4);
  *(_DWORD *)(item_ptr + 8) = 0;
  *(_DWORD *)(item_ptr + 4) = 0;
  --*(_DWORD *)(klist_ptr + 28);
}

//----- (0002E0F8) --------------------------------------------------------
void __fastcall handle_list_transfer_to_head(
        const char **source_list,
        int target_list_ptr,
        const char *source_file,
        const char *source_function,
        int source_line)
{
  const char *source_list_head; // r0
  const char *target_list_head; // r1
  int last_element_ptr; // r2
  const char *next_element_ptr; // r3
  const char *num_moved_elements; // r1
  char log_message_buffer[2072]; // [sp+20h] [bp-818h] BYREF

  source_list_head = *source_list;
  target_list_head = *(const char **)target_list_ptr;
  if ( source_list_head != target_list_head )
  {
    snprintf(
      log_message_buffer,
      2048u,
      "List %s can't %s() to a %s list - from %s %s() line %d in %s %s():%d",
      source_list_head,
      "_k_list_transfer_to_head",
      target_list_head,
      source_file,
      source_function,
      source_line,
      "klist.c",
      "_k_list_transfer_to_head",
      338);
    logMessage(3, log_message_buffer, 1);
    nullsub_1();
  }
  if ( !*((_BYTE *)source_list + 44) )
  {
    snprintf(
      log_message_buffer,
      2048u,
      "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d",
      *source_list,
      "_k_list_transfer_to_head",
      source_file,
      source_function,
      source_line,
      "klist.c",
      "_k_list_transfer_to_head",
      343);
    logMessage(3, log_message_buffer, 1);
    nullsub_1();
  }
  if ( source_list[3] )
  {
    last_element_ptr = *(_DWORD *)(target_list_ptr + 12);
    next_element_ptr = source_list[4];
    if ( last_element_ptr )
      *(_DWORD *)(last_element_ptr + 4) = next_element_ptr;
    else
      *(_DWORD *)(target_list_ptr + 16) = next_element_ptr;
    if ( last_element_ptr )
      last_element_ptr = *(_DWORD *)(target_list_ptr + 12);
    *((_DWORD *)source_list[4] + 2) = last_element_ptr;
    *(_DWORD *)(target_list_ptr + 12) = source_list[3];
    source_list[4] = 0;
    num_moved_elements = source_list[7];
    source_list[3] = 0;
    *(_DWORD *)(target_list_ptr + 28) += num_moved_elements;
    source_list[7] = 0;
    *(_DWORD *)(target_list_ptr + 32) += source_list[8];
    source_list[8] = 0;
  }
}

//----- (0002E268) --------------------------------------------------------
void __fastcall validate_and_transfer_queue(
        const char **source_queue,
        int destination_queue_ptr,
        const char *file_name,
        const char *function_name,
        int line_number)
{
  const char *source_queue_name; // r0
  const char *destination_queue_name; // r1
  const char *next_node; // r3
  int destination_next_ptr; // r2
  const char *node_data_length; // r1
  char log_message_buffer[2072]; // [sp+20h] [bp-818h] BYREF

  source_queue_name = *source_queue;
  destination_queue_name = *(const char **)destination_queue_ptr;
  if ( source_queue_name != destination_queue_name )
  {
    snprintf(
      log_message_buffer,
      2048u,
      "List %s can't %s() to a %s list - from %s %s() line %d in %s %s():%d",
      source_queue_name,
      "_k_list_transfer_to_tail",
      destination_queue_name,
      file_name,
      function_name,
      line_number,
      "klist.c",
      "_k_list_transfer_to_tail",
      368);
    logMessage(3, log_message_buffer, 1);
    nullsub_1();
  }
  if ( !*((_BYTE *)source_queue + 44) )
  {
    snprintf(
      log_message_buffer,
      2048u,
      "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d",
      *source_queue,
      "_k_list_transfer_to_tail",
      file_name,
      function_name,
      line_number,
      "klist.c",
      "_k_list_transfer_to_tail",
      373);
    logMessage(3, log_message_buffer, 1);
    nullsub_1();
  }
  next_node = source_queue[3];
  if ( next_node )
  {
    destination_next_ptr = *(_DWORD *)(destination_queue_ptr + 16);
    if ( destination_next_ptr )
      *(_DWORD *)(destination_next_ptr + 8) = next_node;
    else
      *(_DWORD *)(destination_queue_ptr + 12) = next_node;
    if ( destination_next_ptr )
      destination_next_ptr = *(_DWORD *)(destination_queue_ptr + 16);
    *((_DWORD *)source_queue[3] + 1) = destination_next_ptr;
    *(_DWORD *)(destination_queue_ptr + 16) = source_queue[4];
    source_queue[4] = 0;
    node_data_length = source_queue[7];
    source_queue[3] = 0;
    *(_DWORD *)(destination_queue_ptr + 28) += node_data_length;
    source_queue[7] = 0;
    *(_DWORD *)(destination_queue_ptr + 32) += source_queue[8];
    source_queue[8] = 0;
  }
}

//----- (0002E3D4) --------------------------------------------------------
int __fastcall release_memory_resources(
        const char **resource_tracker,
        const char *caller_filename,
        const char *caller_function_name,
        int caller_line_number)
{
  int index1; // r5
  void *ptr_to_free1; // r0
  int index2; // r5
  void *ptr_to_free2; // r0
  char *rwlock_ptr; // r5
  char log_message_buffer[2064]; // [sp+20h] [bp-810h] BYREF

  if ( *((_BYTE *)resource_tracker + 4) )
  {
    snprintf(
      log_message_buffer,
      2048u,
      "List %s can't %s() a store - from %s %s() line %d in %s %s():%d",
      *resource_tracker,
      "_k_free_list",
      caller_filename,
      caller_function_name,
      caller_line_number,
      "klist.c",
      "_k_free_list",
      400);
    logMessage(3, log_message_buffer, 1);
    nullsub_1();
  }
  if ( (int)resource_tracker[12] > 0 )
  {
    index1 = 0;
    do
    {
      ptr_to_free1 = *(void **)&resource_tracker[13][4 * index1++];
      free(ptr_to_free1);
    }
    while ( (int)resource_tracker[12] > index1 );
  }
  free((void *)resource_tracker[13]);
  if ( (int)resource_tracker[14] > 0 )
  {
    index2 = 0;
    do
    {
      ptr_to_free2 = *(void **)&resource_tracker[15][4 * index2++];
      free(ptr_to_free2);
    }
    while ( (int)resource_tracker[14] > index2 );
  }
  free((void *)resource_tracker[15]);
  rwlock_ptr = (char *)resource_tracker[2];
  pthread_rwlock_destroy((pthread_rwlock_t *)(rwlock_ptr + 24));
  pthread_mutex_destroy((pthread_mutex_t *)rwlock_ptr);
  free((void *)resource_tracker[2]);
  free(resource_tracker);
  return 0;
}

//----- (0002E4F0) --------------------------------------------------------
int __fastcall release_memory(
        void *memory_pointer,
        const char *caller_filename,
        const char *caller_function,
        int caller_line_number)
{
  char log_message_buffer[2064]; // [sp+20h] [bp-810h] BYREF

  if ( !*((_BYTE *)memory_pointer + 4) )
  {
    snprintf(
      log_message_buffer,
      2048u,
      "Store %s can't %s() the list - from %s %s() line %d in %s %s():%d",
      *(const char **)memory_pointer,
      "_k_free_store",
      caller_filename,
      caller_function,
      caller_line_number,
      "klist.c",
      "_k_free_store",
      424);
    logMessage(3, log_message_buffer, 1);
    nullsub_1();
  }
  free(memory_pointer);
  return 0;
}

//----- (0002E584) --------------------------------------------------------
int __fastcall logMessage(int a1, const char *a2, int a3)
{
  _DWORD *logging_category; // r0
  int result; // r0
  int v8; // r4
  struct tm *v9; // r0
  int v10; // r0
  FILE *v11; // r6
  size_t v12; // r0
  size_t v13; // r0
  _DWORD *v14; // r0
  int v15; // r7
  time_t timer; // [sp+1Ch] [bp-6Ch] BYREF
  __time_t v17; // [sp+20h] [bp-68h] BYREF
  int v18; // [sp+24h] [bp-64h]
  char s[96]; // [sp+28h] [bp-60h] BYREF

  if ( loggingDebug )
  {
    syslog(a1 | 0x80, "%s", a2);
    logging_category = (_DWORD *)dword_48212C;
    if ( !dword_48212C )
    {
      logging_category = get_logging_category("bmminer_miner");
      dword_48212C = (int)logging_category;
    }
    return log_event((int)logging_category, "logging.c", 9, (int)"_applog", 7, 71, 60, (int)"%s", a2);
  }
  else
  {
    v17 = (unsigned __int8)loggingDebug;
    v18 = (unsigned __int8)loggingDebug;
    convert_timespec_to_custom_format(&v17);
    timer = v17;
    v8 = v18 / 1000;
    v9 = localtime(&timer);
    snprintf(
      s,
      64u,
      " [%d-%02d-%02d %02d:%02d:%02d.%03d] ",
      v9->tm_year + 1900,
      v9->tm_mon + 1,
      v9->tm_mday,
      v9->tm_hour,
      v9->tm_min,
      v9->tm_sec,
      v8);
    v10 = fileno((FILE *)stderr);
    if ( !isatty(v10) )
    {
      fprintf((FILE *)stderr, "%s%s\n", s, a2);
      fflush((FILE *)stderr);
    }
    if ( byte_482130 )
    {
      v11 = (FILE *)dword_482134;
      if ( dword_482134 || (v11 = (FILE *)fopen64(byte_482158, &word_482138), (dword_482134 = (int)v11) != 0) )
      {
        v12 = strlen(s);
        fwrite(s, v12, 1u, v11);
        v13 = strlen(a2);
        fwrite(a2, v13, 1u, (FILE *)dword_482134);
        fwrite(&word_6A02C, 1u, 1u, (FILE *)dword_482134);
        fflush((FILE *)dword_482134);
      }
    }
    v14 = (_DWORD *)dword_48212C;
    if ( !dword_48212C )
    {
      v14 = get_logging_category("bmminer_miner");
      dword_48212C = (int)v14;
    }
    result = log_event((int)v14, "logging.c", 9, (int)"_applog", 7, 117, 60, (int)"%s", a2);
    if ( a1 == 3 )
      v15 = 0;
    else
      v15 = byte_58E350 & 1;
    if ( !v15 )
      return print_error_message_with_lock(s, a2, a3);
  }
  return result;
}
// 124E4: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 6A02C: using guessed type __int16 word_6A02C;
// 7F790: using guessed type int stderr;
// 48212C: using guessed type int dword_48212C;
// 482130: using guessed type char byte_482130;
// 482134: using guessed type int dword_482134;
// 482138: using guessed type __int16 word_482138;
// 58E350: using guessed type char byte_58E350;
// 590404: using guessed type char loggingDebug;

//----- (0002E828) --------------------------------------------------------
void __fastcall unlock_logging_mutex(int line_number)
{
  int *errno_ptr; // r0
  char error_message_buffer[2056]; // [sp+10h] [bp-808h] BYREF

  if ( pthread_mutex_unlock(&stru_59450C) )
  {
    errno_ptr = _errno_location();
    snprintf(
      error_message_buffer,
      2048u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *errno_ptr,
      "logging.c",
      "my_log_curses",
      line_number);
    logMessage(3, error_message_buffer, 1);
    nullsub_1();
  }
}
// 59450C: using guessed type pthread_mutex_t stru_59450C;

//----- (0002E8A4) --------------------------------------------------------
void lock_logging_mutex()
{
  int *errno_pointer; // r0
  char error_message[2056]; // [sp+10h] [bp-808h] BYREF

  if ( pthread_mutex_lock(&stru_59450C) )
  {
    errno_pointer = _errno_location();
    snprintf(
      error_message,
      2048u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *errno_pointer,
      "logging.c",
      "my_log_curses",
      53);
    logMessage(3, error_message, 1);
    nullsub_1();
  }
}
// 59450C: using guessed type pthread_mutex_t stru_59450C;

//----- (0002E92C) --------------------------------------------------------
int __fastcall print_error_message_with_lock(const char *error_location, const char *error_message, int should_unlock)
{
  int mutex_trylock_result; // r0

  if ( should_unlock )
  {
    pthread_mutex_trylock(&stru_59450C);
    unlock_logging_mutex(42);
    off_7ECC4(mutex_trylock_result);
  }
  lock_logging_mutex();
  printf("%s%s%s", error_location, error_message, "                    \n");
  unlock_logging_mutex(55);
  return ((int (__fastcall *)())off_7ECC4)();
}
// 2E99C: variable 'mutex_trylock_result' is possibly undefined
// 7ECC4: using guessed type int (__fastcall *off_7ECC4)(_DWORD);
// 59450C: using guessed type pthread_mutex_t stru_59450C;

//----- (0002E9A4) --------------------------------------------------------
void __fastcall log_message(int priority_level, const char *message, int message_len)
{
  int stderror_fd; // r0
  int is_daemon_active; // r0

  if ( loggingDebug )
  {
    syslog(priority_level | 0x80, "%s", message);
  }
  else
  {
    stderror_fd = fileno((FILE *)stderr);
    if ( !isatty(stderror_fd) )
    {
      fprintf((FILE *)stderr, "%s\n", message);
      fflush((FILE *)stderr);
    }
    if ( priority_level == 3 )
      is_daemon_active = 0;
    else
      is_daemon_active = byte_58E350 & 1;
    if ( !is_daemon_active )
      print_error_message_with_lock("", message, message_len);
  }
}
// 7F790: using guessed type int stderr;
// 58E350: using guessed type char byte_58E350;
// 590404: using guessed type char loggingDebug;

//----- (0002EA54) --------------------------------------------------------
char *__fastcall append_log_message(int log_priority, const char *message, int error_code)
{
  size_t current_length; // r5
  _DWORD *logging_category; // r0
  char *final_result; // r0
  char *msg_ptr; // r2
  int char_value; // r3
  int next_char; // t1
  bool is_newline_terminator; // zf
  _DWORD *log_category_check; // r0
  int file_descriptor; // r0
  FILE *log_file; // r5
  size_t message_length; // r0
  _DWORD *log_category_final; // r0
  int is_error_handling_enabled; // r7
  int stderr_file_descriptor; // r0
  FILE *external_log_file; // r5
  size_t external_message_length; // r0
  _DWORD *log_category_secondary; // r0
  int external_log_enabled; // r3

  current_length = strlen(&ptr);
  if ( current_length + strlen(message) + 1 >= 2048 )
  {
    if ( loggingDebug )
    {
      syslog(log_priority | 0x80, "%s", &ptr);
      logging_category = (_DWORD *)dword_482A58;
      if ( !dword_482A58 )
      {
        logging_category = get_logging_category("bmminer_miner");
        dword_482A58 = (int)logging_category;
      }
      log_event((int)logging_category, "logging.c", 9, (int)"_applawlog", 10, 167, 60, (int)"%s", &ptr);
    }
    else
    {
      stderr_file_descriptor = fileno((FILE *)stderr);
      if ( !isatty(stderr_file_descriptor) )
      {
        fputs(&ptr, (FILE *)stderr);
        fflush((FILE *)stderr);
      }
      if ( byte_482130 )
      {
        external_log_file = (FILE *)dword_482134;
        if ( dword_482134
          || (external_log_file = (FILE *)fopen64(byte_482158, &word_482138),
              (dword_482134 = (int)external_log_file) != 0) )
        {
          external_message_length = strlen(&ptr);
          fwrite(&ptr, external_message_length, 1u, external_log_file);
          fflush((FILE *)dword_482134);
        }
      }
      log_category_secondary = (_DWORD *)dword_482A58;
      if ( !dword_482A58 )
      {
        log_category_secondary = get_logging_category("bmminer_miner");
        dword_482A58 = (int)log_category_secondary;
      }
      log_event((int)log_category_secondary, "logging.c", 9, (int)"_applawlog", 10, 195, 60, (int)"%s", &ptr);
      if ( log_priority == 3 )
        external_log_enabled = 0;
      else
        external_log_enabled = byte_58E350 & 1;
      if ( !external_log_enabled )
        print_error_message_with_lock("", &ptr, error_code);
    }
    ptr = 0;
  }
  final_result = strcat(&ptr, message);
  msg_ptr = &ptr;
  while ( 1 )
  {
    next_char = (unsigned __int8)*msg_ptr++;
    char_value = next_char;
    is_newline_terminator = next_char == 13;
    if ( next_char != 13 )
      is_newline_terminator = char_value == 10;
    if ( is_newline_terminator )
      break;
    if ( !char_value )
      return final_result;
  }
  if ( loggingDebug )
  {
    syslog(log_priority | 0x80, "%s", &ptr);
    log_category_check = (_DWORD *)dword_482A58;
    if ( !dword_482A58 )
    {
      log_category_check = get_logging_category("bmminer_miner");
      dword_482A58 = (int)log_category_check;
    }
    final_result = (char *)log_event(
                             (int)log_category_check,
                             "logging.c",
                             9,
                             (int)"_applawlog",
                             10,
                             205,
                             60,
                             (int)"%s",
                             &ptr);
  }
  else
  {
    file_descriptor = fileno((FILE *)stderr);
    if ( !isatty(file_descriptor) )
    {
      fputs(&ptr, (FILE *)stderr);
      fflush((FILE *)stderr);
    }
    if ( byte_482130 )
    {
      log_file = (FILE *)dword_482134;
      if ( dword_482134 || (log_file = (FILE *)fopen64(byte_482158, &word_482138), (dword_482134 = (int)log_file) != 0) )
      {
        message_length = strlen(&ptr);
        fwrite(&ptr, message_length, 1u, log_file);
        fflush((FILE *)dword_482134);
      }
    }
    log_category_final = (_DWORD *)dword_482A58;
    if ( !dword_482A58 )
    {
      log_category_final = get_logging_category("bmminer_miner");
      dword_482A58 = (int)log_category_final;
    }
    final_result = (char *)log_event(
                             (int)log_category_final,
                             "logging.c",
                             9,
                             (int)"_applawlog",
                             10,
                             233,
                             60,
                             (int)"%s",
                             &ptr);
    if ( log_priority == 3 )
      is_error_handling_enabled = 0;
    else
      is_error_handling_enabled = byte_58E350 & 1;
    if ( !is_error_handling_enabled )
      final_result = (char *)print_error_message_with_lock("", &ptr, error_code);
  }
  ptr = 0;
  return final_result;
}
// 124E4: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 7F790: using guessed type int stderr;
// 482130: using guessed type char byte_482130;
// 482134: using guessed type int dword_482134;
// 482138: using guessed type __int16 word_482138;
// 482A58: using guessed type int dword_482A58;
// 58E350: using guessed type char byte_58E350;
// 590404: using guessed type char loggingDebug;

//----- (0002EE28) --------------------------------------------------------
int __fastcall process_hash_blocks(int hash_value, unsigned __int8 *input_blocks, int num_blocks)
{
  unsigned __int8 *input_block_ptr; // r0
  int *tmp_block_ptr; // lr
  int *message_schedule_array; // r12
  int byte1; // r3
  int byte2; // r4
  int byte3; // r1
  int byte0; // t1
  unsigned int word_temp1; // lr
  int *schedule_ptr; // r3
  unsigned int word_temp2; // t1
  int intermediate_hash_ptr; // r0
  int *intermediate_hash_ptr_copy; // r3
  int *final_hash_ptr; // r2
  int hash_val_tmp; // t1
  int round_index; // r6
  int a; // r3
  int e; // r4
  int f; // r10
  int d; // r9
  int b; // r5
  int c; // r8
  int g; // r7
  int h; // r11
  int t1; // r2
  int k_value; // r12
  int sum1; // r3
  int sum0; // lr
  int maj; // r1
  int *hash_ptr; // r1
  int *final_hash_update_ptr; // r3
  int intermediate_val; // t1
  bool is_final_block; // zf
  unsigned __int8 *current_input_block_ptr; // [sp+4h] [bp-164h]
  int *final_hash_ptr_end; // [sp+8h] [bp-160h]
  unsigned __int8 *input_blocks_end; // [sp+14h] [bp-154h]
  int hash_value_offset_a; // [sp+18h] [bp-150h]
  int intermediate_hash_value_start; // [sp+1Ch] [bp-14Ch] BYREF
  int updated_hash_b; // [sp+20h] [bp-148h]
  int updated_hash_c; // [sp+24h] [bp-144h]
  int updated_hash_g; // [sp+28h] [bp-140h]
  int updated_hash_h; // [sp+2Ch] [bp-13Ch]
  int updated_hash_e; // [sp+30h] [bp-138h]
  int updated_hash_f; // [sp+34h] [bp-134h]
  int updated_hash_d; // [sp+38h] [bp-130h]
  int buffer_for_block_expansion; // [sp+3Ch] [bp-12Ch] BYREF
  int expanded_block[15]; // [sp+40h] [bp-128h] BYREF
  char end_buffer_for_block_expansion; // [sp+7Ch] [bp-ECh] BYREF
  char end_expanded_block; // [sp+100h] [bp-68h] BYREF

  if ( num_blocks > 0 )
  {
    hash_value_offset_a = hash_value + 136;
    current_input_block_ptr = input_blocks;
    input_blocks_end = &input_blocks[64 * num_blocks];
    intermediate_hash_value_start = hash_value + 168;
    do
    {
      input_block_ptr = current_input_block_ptr;
      tmp_block_ptr = &buffer_for_block_expansion;
      message_schedule_array = expanded_block;
      do
      {
        byte1 = input_block_ptr[1];
        byte2 = input_block_ptr[2];
        byte3 = input_block_ptr[3];
        byte0 = *input_block_ptr;
        input_block_ptr += 4;
        tmp_block_ptr[1] = (byte1 << 16) | (byte2 << 8) | byte3 | (byte0 << 24);
        ++tmp_block_ptr;
      }
      while ( &end_buffer_for_block_expansion != (char *)tmp_block_ptr );
      do
      {
        word_temp1 = message_schedule_array[14];
        schedule_ptr = message_schedule_array;
        word_temp2 = message_schedule_array[1];
        ++message_schedule_array;
        message_schedule_array[15] = (__ROR4__(word_temp1, 19) ^ __ROR4__(word_temp1, 17) ^ (word_temp1 >> 10))
                                   + schedule_ptr[9]
                                   + *schedule_ptr
                                   + (__ROR4__(word_temp2, 18) ^ __ROR4__(word_temp2, 7) ^ (word_temp2 >> 3));
      }
      while ( &end_expanded_block != (char *)message_schedule_array );
      intermediate_hash_ptr = intermediate_hash_value_start;
      intermediate_hash_ptr_copy = &intermediate_hash_value_start;
      final_hash_ptr = (int *)hash_value_offset_a;
      do
      {
        hash_val_tmp = *final_hash_ptr++;
        intermediate_hash_ptr_copy[1] = hash_val_tmp;
        ++intermediate_hash_ptr_copy;
      }
      while ( (int *)intermediate_hash_ptr != final_hash_ptr );
      final_hash_ptr_end = final_hash_ptr;
      round_index = 0;
      a = buffer_for_block_expansion;
      e = updated_hash_e;
      f = updated_hash_f;
      d = updated_hash_d;
      b = updated_hash_b;
      c = updated_hash_c;
      g = updated_hash_g;
      h = updated_hash_h;
      while ( 1 )
      {
        t1 = (__ROR4__(e, 11) ^ __ROR4__(e, 6) ^ __ROR4__(e, 25)) + (d & ~e ^ f & e) + expanded_block[round_index];
        k_value = dword_7EBA4[round_index++];
        sum1 = t1 + k_value + a;
        sum0 = h + sum1;
        maj = (__ROR4__(b, 13) ^ __ROR4__(b, 2) ^ __ROR4__(b, 22)) + ((g ^ c) & b ^ g & c) + sum1;
        h = g;
        a = d;
        if ( round_index == 64 )
          break;
        g = c;
        d = f;
        c = b;
        f = e;
        b = maj;
        e = sum0;
      }
      updated_hash_b = maj;
      hash_ptr = &intermediate_hash_value_start;
      final_hash_update_ptr = (int *)hash_value_offset_a;
      buffer_for_block_expansion = d;
      updated_hash_e = sum0;
      updated_hash_f = e;
      updated_hash_d = f;
      updated_hash_c = b;
      updated_hash_g = c;
      updated_hash_h = g;
      do
      {
        hash_value = *final_hash_update_ptr;
        intermediate_val = hash_ptr[1];
        ++hash_ptr;
        *final_hash_update_ptr++ += intermediate_val;
      }
      while ( final_hash_ptr_end != final_hash_update_ptr );
      is_final_block = input_blocks_end == current_input_block_ptr + 64;
      current_input_block_ptr += 64;
    }
    while ( !is_final_block );
  }
  return hash_value;
}
// 7EBA4: using guessed type _DWORD dword_7EBA4[63];
// 2EE28: using guessed type _DWORD var_128[15];

//----- (0002F024) --------------------------------------------------------
_DWORD *__fastcall copy_firmware_version(_DWORD *firmware_data)
{
  _DWORD *source_pointer; // r2
  _DWORD *destination_pointer; // r3
  int current_value; // t1

  source_pointer = &unk_7ECA0;
  destination_pointer = firmware_data + 34;
  do
  {
    current_value = source_pointer[1];
    ++source_pointer;
    *destination_pointer++ = current_value;
  }
  while ( destination_pointer != firmware_data + 42 );
  firmware_data[1] = 0;
  *firmware_data = 0;
  return firmware_data;
}

//----- (0002F054) --------------------------------------------------------
void *__fastcall process_input_chunk(unsigned __int8 *hash_state, char *input_data, size_t input_length)
{
  int current_length; // r0
  size_t remaining_space; // r2
  unsigned __int8 *buffer_ptr; // r0
  size_t copy_length; // r6
  void *copy_result; // r0
  size_t new_length; // r3
  size_t remaining_length; // r5
  unsigned __int8 *remaining_input; // r6
  int total_length; // r3

  current_length = *((_DWORD *)hash_state + 1);
  remaining_space = 64 - current_length;
  buffer_ptr = &hash_state[current_length + 8];
  if ( remaining_space >= input_length )
    copy_length = input_length;
  else
    copy_length = remaining_space;
  copy_result = memcpy(buffer_ptr, input_data, copy_length);
  new_length = input_length + *((_DWORD *)hash_state + 1);
  if ( new_length > 63 )
  {
    remaining_length = input_length - copy_length;
    remaining_input = (unsigned __int8 *)&input_data[copy_length];
    process_hash_blocks((int)hash_state, hash_state + 8, 1);
    process_hash_blocks((int)hash_state, remaining_input, remaining_length >> 6);
    copy_result = memcpy(hash_state + 8, &remaining_input[remaining_length & 0xFFFFFFC0], remaining_length & 0x3F);
    total_length = *(_DWORD *)hash_state;
    *((_DWORD *)hash_state + 1) = remaining_length & 0x3F;
    *(_DWORD *)hash_state = total_length + (((remaining_length >> 6) + 1) << 6);
  }
  else
  {
    *((_DWORD *)hash_state + 1) = new_length;
  }
  return copy_result;
}

//----- (0002F100) --------------------------------------------------------
int __fastcall prepare_and_process_hash(_DWORD *hash_context, _BYTE *output_hash)
{
  int index_60; // r8
  int index_61; // r9
  int index_62; // r10
  int additional_blocks; // r11
  int current_length_mod_64; // r3
  unsigned __int8 *current_block; // r6
  bool is_length_greater_eq_56; // cf
  int padding_start; // r2
  int total_length; // r7
  size_t zero_padding_len; // r2
  unsigned __int8 *zero_padding_start; // r0
  int index_60_or_124; // r3
  int bit_length; // r7
  int hash_result; // r0
  int *hash_value_iterator; // r3
  int *hash_value_end; // r5
  int current_hash_value; // t1
  int index_56_or_60; // [sp+4h] [bp-2Ch]

  current_length_mod_64 = hash_context[1];
  current_block = (unsigned __int8 *)(hash_context + 2);
  is_length_greater_eq_56 = (current_length_mod_64 & 0x3Fu) >= 56;
  if ( (current_length_mod_64 & 0x3Fu) >= 56 )
    padding_start = 128;
  else
    padding_start = 64;
  total_length = current_length_mod_64 + *hash_context;
  zero_padding_len = padding_start - current_length_mod_64;
  zero_padding_start = &current_block[current_length_mod_64];
  if ( (current_length_mod_64 & 0x3Fu) >= 56 )
    index_60_or_124 = 124;
  else
    index_60_or_124 = 60;
  bit_length = 8 * total_length;
  if ( !is_length_greater_eq_56 )
    index_60 = 61;
  index_56_or_60 = index_60_or_124;
  if ( is_length_greater_eq_56 )
    index_60 = 125;
  else
    index_61 = 62;
  if ( is_length_greater_eq_56 )
    index_61 = 126;
  else
    index_62 = 63;
  if ( is_length_greater_eq_56 )
    index_62 = 127;
  else
    additional_blocks = 1;
  if ( is_length_greater_eq_56 )
    additional_blocks = 2;
  memset(zero_padding_start, 0, zero_padding_len);
  *((_BYTE *)hash_context + hash_context[1] + 8) = -128;
  current_block[index_62] = bit_length;
  current_block[index_61] = BYTE1(bit_length);
  current_block[index_60] = BYTE2(bit_length);
  current_block[index_56_or_60] = HIBYTE(bit_length);
  hash_result = process_hash_blocks((int)hash_context, current_block, additional_blocks);
  hash_value_iterator = hash_context + 34;
  hash_value_end = hash_context + 42;
  do
  {
    output_hash[3] = *hash_value_iterator;
    current_hash_value = *hash_value_iterator++;
    output_hash[2] = BYTE1(current_hash_value);
    output_hash[1] = *((_WORD *)hash_value_iterator - 1);
    *output_hash = *((_BYTE *)hash_value_iterator - 1);
    output_hash += 4;
  }
  while ( hash_value_end != hash_value_iterator );
  return hash_result;
}
// 2F194: variable 'index_62' is possibly undefined
// 2F19C: variable 'index_61' is possibly undefined
// 2F1A0: variable 'index_60' is possibly undefined
// 2F1AC: variable 'additional_blocks' is possibly undefined

//----- (0002F1EC) --------------------------------------------------------
int __fastcall hash_message(char *message, size_t message_length, _BYTE *output_hash)
{
  _DWORD *hash_state_ptr; // r3
  char *hash_state_byte_ptr; // r2
  int temp_hash_state_value; // t1
  _DWORD hash_state[34]; // [sp+0h] [bp-B8h] BYREF
  char initial_hash_value; // [sp+88h] [bp-30h] BYREF

  hash_state_ptr = &unk_7ECA0;
  hash_state_byte_ptr = &initial_hash_value;
  do
  {
    temp_hash_state_value = hash_state_ptr[1];
    ++hash_state_ptr;
    *(_DWORD *)hash_state_byte_ptr = temp_hash_state_value;
    hash_state_byte_ptr += 4;
  }
  while ( hash_state_ptr != (_DWORD *)&unk_7ECC0 );
  hash_state[0] = 0;
  hash_state[1] = 0;
  process_input_chunk((unsigned __int8 *)hash_state, message, message_length);
  return prepare_and_process_hash(hash_state, output_hash);
}

//----- (0002F250) --------------------------------------------------------
int initialize_miner_system()
{
  return 0;
}

//----- (0002F258) --------------------------------------------------------
void __fastcall log_semaphore_post_failure(
        const void *semaphore,
        const char *filename,
        const char *function_name,
        int line_number)
{
  int *errno_location; // r0
  char error_message[2072]; // [sp+10h] [bp-818h] BYREF

  errno_location = _errno_location();
  snprintf(
    error_message,
    2048u,
    "Failed to sem_post errno=%d cgsem=0x%p in %s %s():%d",
    *errno_location,
    semaphore,
    filename,
    function_name,
    line_number);
  logMessage(3, error_message, 1);
  nullsub_1();
}

//----- (0002F2C0) --------------------------------------------------------
void __fastcall log_mutex_unlock_error(pthread_mutex_t *mutex, const char *function_name, int line_number)
{
  int *error_number_ptr; // r0
  char error_message[2064]; // [sp+10h] [bp-810h] BYREF

  if ( pthread_mutex_unlock(mutex) )
  {
    error_number_ptr = _errno_location();
    snprintf(
      error_message,
      2048u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *error_number_ptr,
      "util.c",
      function_name,
      line_number);
    logMessage(3, error_message, 1);
    nullsub_1();
  }
}

//----- (0002F33C) --------------------------------------------------------
void __fastcall report_mutex_error(const char *function_name, int line_number)
{
  int *errno_ptr; // r0
  char error_message[2064]; // [sp+10h] [bp-810h] BYREF

  errno_ptr = _errno_location();
  snprintf(
    error_message,
    2048u,
    "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
    *errno_ptr,
    "util.c",
    function_name,
    line_number);
  logMessage(3, error_message, 1);
  nullsub_1();
}

//----- (0002F3A0) --------------------------------------------------------
int __fastcall set_task_queue_state(int task_queue_ptr, char new_state)
{
  pthread_mutex_t *mutex_ptr; // r5
  int lock_result; // r0

  mutex_ptr = (pthread_mutex_t *)(task_queue_ptr + 12);
  if ( pthread_mutex_lock((pthread_mutex_t *)(task_queue_ptr + 12)) )
    report_mutex_error("tq_freezethaw", 1108);
  *(_BYTE *)(task_queue_ptr + 8) = new_state;
  pthread_cond_signal((pthread_cond_t *)(task_queue_ptr + 40));
  log_mutex_unlock_error(mutex_ptr, "tq_freezethaw", 1111);
  return off_7ECC4(lock_result);
}
// 2F3F0: variable 'lock_result' is possibly undefined
// 7ECC4: using guessed type int (__fastcall *off_7ECC4)(_DWORD);

//----- (0002F408) --------------------------------------------------------
void *__fastcall allocate_memory_logging(
        size_t initial_size,
        const char *function_name,
        const char *file_name,
        int line_number)
{
  size_t adjusted_size; // r4
  void *allocated_memory; // r0
  char log_message_buffer[2072]; // [sp+10h] [bp-818h] BYREF

  adjusted_size = initial_size;
  if ( (initial_size & 3) != 0 )
    adjusted_size = (initial_size & 0xFFFFFFFC) + 4;
  allocated_memory = malloc(adjusted_size);
  if ( !allocated_memory )
  {
    snprintf(
      log_message_buffer,
      2048u,
      "Failed to malloc size %d from %s %s:%d",
      adjusted_size,
      function_name,
      file_name,
      line_number);
    logMessage(3, log_message_buffer, 1);
    nullsub_1();
    return 0;
  }
  return allocated_memory;
}

//----- (0002F490) --------------------------------------------------------
void *__fastcall allocate_buffers_ignore_incomplete_words(
        size_t num_elements,
        size_t element_size,
        const char *caller_filename,
        const char *caller_function_name,
        int caller_line_number)
{
  size_t element_size_aligned; // r4
  void *allocated_memory; // r0
  char log_buffer[2072]; // [sp+10h] [bp-818h] BYREF

  element_size_aligned = element_size;
  if ( (element_size & 3) != 0 )
    element_size_aligned = (element_size & 0xFFFFFFFC) + 4;
  allocated_memory = calloc(num_elements, element_size_aligned);
  if ( !allocated_memory )
  {
    snprintf(
      log_buffer,
      2048u,
      "Failed to calloc memb %d size %d from %s %s:%d",
      num_elements,
      element_size_aligned,
      caller_filename,
      caller_function_name,
      caller_line_number);
    logMessage(3, log_buffer, 1);
    nullsub_1();
    return 0;
  }
  return allocated_memory;
}

//----- (0002F520) --------------------------------------------------------
void *__fastcall realloc_wrapper(
        void *original_memory,
        size_t original_size,
        const char *function_name,
        const char *file_name,
        int line_number)
{
  size_t adjusted_size; // r4
  void *new_memory; // r0
  char error_message[2072]; // [sp+10h] [bp-818h] BYREF

  adjusted_size = original_size;
  if ( (original_size & 3) != 0 )
    adjusted_size = (original_size & 0xFFFFFFFC) + 4;
  new_memory = realloc(original_memory, adjusted_size);
  if ( !new_memory )
  {
    snprintf(
      error_message,
      2048u,
      "Failed to realloc size %d from %s %s:%d",
      adjusted_size,
      function_name,
      file_name,
      line_number);
    logMessage(3, error_message, 1);
    nullsub_1();
    return 0;
  }
  return new_memory;
}

//----- (0002F670) --------------------------------------------------------
_BYTE *__fastcall convert_bin_to_hex_string(int binary_data, int data_length)
{
  int hex_str_length; // r5
  int adjusted_length_with_null; // r0
  int alignment_offset; // r12
  _BYTE *hex_string; // r0
  _BYTE *hex_str_end; // r5
  _BYTE *binary_data_ptr; // r2
  _BYTE *hex_string_ptr; // r12
  unsigned int current_byte; // t1

  hex_str_length = 2 * data_length;
  adjusted_length_with_null = 2 * data_length + 1;
  alignment_offset = adjusted_length_with_null & 3;
  if ( adjusted_length_with_null <= 0 )
    alignment_offset = -(-adjusted_length_with_null & 3);
  hex_string = allocate_buffers_ignore_incomplete_words(
                 4 - alignment_offset + adjusted_length_with_null,
                 1u,
                 "util.c",
                 "bin2hex",
                 789);
  if ( data_length > 0 )
  {
    binary_data_ptr = (_BYTE *)(binary_data - 1);
    hex_string_ptr = hex_string + 2;
    do
    {
      current_byte = (unsigned __int8)*++binary_data_ptr;
      hex_string_ptr += 2;
      *(hex_string_ptr - 4) = aTqFreezethaw[(current_byte >> 4) + 72];
      *(hex_string_ptr - 3) = aTqFreezethaw[(*binary_data_ptr & 0xF) + 72];
    }
    while ( binary_data_ptr != (_BYTE *)(binary_data - 1 + data_length) );
    hex_str_end = &hex_string[hex_str_length];
  }
  else
  {
    hex_str_end = hex_string;
  }
  *hex_str_end = 0;
  return hex_string;
}

//----- (0002F724) --------------------------------------------------------
unsigned int __fastcall hex_to_bin(_BYTE *binary_buffer, unsigned __int8 *hex_string, int max_binary_length)
{
  unsigned int low_nibble_value; // r3
  unsigned int high_nibble_value; // lr
  unsigned int conversion_valid; // r0
  unsigned __int8 *current_hex_pointer; // r1
  int lower_hex_character; // r3
  bool is_terminator_detected; // zf
  char *lower_hex_lookup; // r3
  int upper_hex_character; // r12
  char *upper_hex_lookup; // r12
  char log_buffer[2064]; // [sp-810h] [bp-810h] BYREF

  if ( !*hex_string )
    return !max_binary_length;
  if ( !max_binary_length )
    return 0;
  if ( !hex_string[1] )
  {
LABEL_16:
    if ( loggingDebug || loggingVerbose || loggingThreshold > 2 )
    {
      strcpy(log_buffer, "hex2bin str truncated");
      logMessage(3, log_buffer, 0);
    }
    return 0;
  }
  low_nibble_value = *(_DWORD *)&aTqFreezethaw[4 * hex_string[1] + 96];
  high_nibble_value = *(_DWORD *)&aTqFreezethaw[4 * *hex_string + 96];
  conversion_valid = (low_nibble_value >> 31) | (high_nibble_value >> 31);
  if ( !conversion_valid )
  {
    current_hex_pointer = hex_string + 4;
    while ( 1 )
    {
      --max_binary_length;
      *binary_buffer++ = low_nibble_value | (16 * high_nibble_value);
      lower_hex_character = *(current_hex_pointer - 2);
      is_terminator_detected = lower_hex_character == 0;
      lower_hex_lookup = &aTqFreezethaw[4 * lower_hex_character];
      if ( is_terminator_detected )
        break;
      if ( !max_binary_length )
        return conversion_valid;
      upper_hex_character = *(current_hex_pointer - 1);
      current_hex_pointer += 2;
      is_terminator_detected = upper_hex_character == 0;
      upper_hex_lookup = &aTqFreezethaw[4 * upper_hex_character];
      if ( is_terminator_detected )
        goto LABEL_16;
      high_nibble_value = *((_DWORD *)lower_hex_lookup + 24);
      low_nibble_value = *((_DWORD *)upper_hex_lookup + 24);
      if ( ((high_nibble_value | low_nibble_value) & 2147483648) != 0 )
        goto LABEL_11;
    }
    return !max_binary_length;
  }
LABEL_11:
  if ( !loggingDebug && !loggingVerbose && loggingThreshold <= 2 )
    return 0;
  strcpy(log_buffer, "hex2bin scan failed");
  logMessage(3, log_buffer, 0);
  return 0;
}
// 7EBA0: using guessed type int loggingThreshold;
// 482A5C: using guessed type char loggingVerbose;
// 590404: using guessed type char loggingDebug;

//----- (0002F8E8) --------------------------------------------------------
size_t __fastcall decrypt_chip_id(_BYTE *output_buffer, char *encrypted_id)
{
  size_t final_result; // r0
  char initial_value; // r1
  char *current_char_ptr; // r7
  int accumulator; // r12
  char *end_ptr; // r6
  int current_char_value; // t1
  int *calc_ptr; // r2
  unsigned int char_value_multiply_result; // r3
  _DWORD *output_dword_ptr; // r3
  int *input_dword_ptr; // r2
  _BYTE *output_buffer_end; // r5
  unsigned int next_dword_value; // t1
  int temp_accumulator; // [sp+0h] [bp-38h] BYREF
  int initial_accumulator; // [sp+4h] [bp-34h]
  int intermediate_results[5]; // [sp+8h] [bp-30h] BYREF
  int multiplier_result; // [sp+1Ch] [bp-1Ch] BYREF

  memset(intermediate_results, 0, sizeof(intermediate_results));
  initial_accumulator = 0;
  multiplier_result = 0;
  final_result = strlen(encrypted_id);
  if ( final_result )
  {
    current_char_ptr = encrypted_id - 1;
    accumulator = 0;
    end_ptr = &current_char_ptr[final_result];
    while ( 1 )
    {
      current_char_value = (unsigned __int8)*++current_char_ptr;
      calc_ptr = &multiplier_result;
      char_value_multiply_result = *(_DWORD *)&aTqFreezethaw[4 * current_char_value + 1120];
      while ( 1 )
      {
        *calc_ptr-- = 58 * accumulator + char_value_multiply_result;
        char_value_multiply_result = (58LL * (unsigned int)accumulator + (unsigned __int64)char_value_multiply_result) >> 32;
        if ( &temp_accumulator == calc_ptr )
          break;
        accumulator = *calc_ptr;
      }
      if ( end_ptr == current_char_ptr )
        break;
      accumulator = multiplier_result;
    }
    initial_value = initial_accumulator;
    final_result = bswap32(intermediate_results[0]);
  }
  else
  {
    initial_value = 0;
  }
  output_dword_ptr = output_buffer + 1;
  input_dword_ptr = intermediate_results;
  *output_buffer = initial_value;
  output_buffer_end = output_buffer + 25;
  while ( 1 )
  {
    *output_dword_ptr++ = final_result;
    if ( output_dword_ptr == (_DWORD *)output_buffer_end )
      break;
    next_dword_value = input_dword_ptr[1];
    ++input_dword_ptr;
    final_result = bswap32(next_dword_value);
  }
  return final_result;
}

//----- (0002F9C0) --------------------------------------------------------
int __fastcall calculate_error_code_and_level(int output_buffer, int error_code)
{
  char error_level; // r2
  int error_group; // r0
  int upper_threshold; // r2

  if ( error_code > 127 )
  {
    upper_threshold = (unsigned __int16)&unk_20407F;
    if ( error_code > upper_threshold )
    {
      HIWORD(upper_threshold) = (unsigned int)&unk_20407F >> 16;
      if ( error_code <= upper_threshold )
        error_group = 4;
      else
        error_group = 5;
      if ( error_code <= upper_threshold )
        error_level = 3;
      else
        error_level = 4;
    }
    else
    {
      error_group = 3;
      error_level = 2;
    }
  }
  else
  {
    error_level = 1;
    error_group = 2;
  }
  *(_DWORD *)(output_buffer + 1) = error_code;
  *(_BYTE *)output_buffer = error_level;
  return error_group;
}

//----- (0002FBFC) --------------------------------------------------------
char *create_task_queue()
{
  char *buffers_ignore_incomplete_words; // r4

  buffers_ignore_incomplete_words = (char *)allocate_buffers_ignore_incomplete_words(1u, 88u, "util.c", "tq_new", 1077);
  *(_DWORD *)buffers_ignore_incomplete_words = buffers_ignore_incomplete_words;
  *((_DWORD *)buffers_ignore_incomplete_words + 1) = buffers_ignore_incomplete_words;
  pthread_mutex_init((pthread_mutex_t *)(buffers_ignore_incomplete_words + 12), 0);
  pthread_cond_init((pthread_cond_t *)(buffers_ignore_incomplete_words + 40), 0);
  return buffers_ignore_incomplete_words;
}

//----- (0002FC58) --------------------------------------------------------
void __fastcall cleanup_resource_list(char *resource_list_head)
{
  int next_element_offset; // r2
  _DWORD *current_element; // r0
  _DWORD *next_element; // r4
  _DWORD *next_of_next_element; // r3
  bool is_end_of_list; // zf

  if ( resource_list_head )
  {
    next_element_offset = **(_DWORD **)resource_list_head;
    current_element = (_DWORD *)(*(_DWORD *)resource_list_head - 4);
    next_element = (_DWORD *)(next_element_offset - 4);
    if ( resource_list_head != *(char **)resource_list_head )
    {
      do
      {
        next_of_next_element = (_DWORD *)current_element[2];
        *(_DWORD *)(next_element_offset + 4) = next_of_next_element;
        *next_of_next_element = next_element_offset;
        free(current_element);
        current_element = next_element;
        next_element_offset = next_element[1];
        is_end_of_list = next_element + 1 == (_DWORD *)resource_list_head;
        next_element = (_DWORD *)(next_element_offset - 4);
      }
      while ( !is_end_of_list );
    }
    pthread_cond_destroy((pthread_cond_t *)(resource_list_head + 40));
    pthread_mutex_destroy((pthread_mutex_t *)(resource_list_head + 12));
    free(resource_list_head);
  }
}

//----- (0002FCC0) --------------------------------------------------------
int __fastcall enable_task_queue(int task_queue_id)
{
  return set_task_queue_state(task_queue_id, 1);
}

//----- (0002FCC8) --------------------------------------------------------
int __fastcall sub_2FCC8(int a1)
{
  return set_task_queue_state(a1, 0);
}

//----- (0002FCD0) --------------------------------------------------------
int __fastcall sub_2FCD0(int a1, int a2)
{
  _DWORD *buffers_ignore_incomplete_words; // r6
  _DWORD *v5; // r4
  _DWORD *v6; // r3
  int v7; // r8
  int v8; // r0

  buffers_ignore_incomplete_words = allocate_buffers_ignore_incomplete_words(1u, 12u, "util.c", "tq_push", 1129);
  *buffers_ignore_incomplete_words = a2;
  v5 = buffers_ignore_incomplete_words + 1;
  buffers_ignore_incomplete_words[1] = buffers_ignore_incomplete_words + 1;
  buffers_ignore_incomplete_words[2] = buffers_ignore_incomplete_words + 1;
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 12)) )
    report_mutex_error("tq_push", 1133);
  if ( *(_BYTE *)(a1 + 8) )
  {
    v7 = 0;
    free(buffers_ignore_incomplete_words);
  }
  else
  {
    v6 = *(_DWORD **)(a1 + 4);
    v7 = 1;
    *(_DWORD *)(a1 + 4) = v5;
    buffers_ignore_incomplete_words[1] = a1;
    buffers_ignore_incomplete_words[2] = v6;
    *v6 = v5;
  }
  pthread_cond_signal((pthread_cond_t *)(a1 + 40));
  log_mutex_unlock_error((pthread_mutex_t *)(a1 + 12), "tq_push", 1146);
  off_7ECC4(v8);
  return v7;
}
// 2FD70: variable 'v8' is possibly undefined
// 7ECC4: using guessed type int (__fastcall *off_7ECC4)(_DWORD);

//----- (0002FDA4) --------------------------------------------------------
int __fastcall pop_task_queue(int queue_ptr, const struct timespec *timeout_spec)
{
  pthread_mutex_t *mutex_ptr; // r6
  int *current_task_ptr; // r4
  _DWORD *next_task_ptr; // r2
  int current_task_value; // r1
  int v8; // r5
  int unlock_result; // r0
  pthread_cond_t *condition_ptr; // r0
  int wait_result; // r0

  mutex_ptr = (pthread_mutex_t *)(queue_ptr + 12);
  if ( pthread_mutex_lock((pthread_mutex_t *)(queue_ptr + 12)) )
    report_mutex_error("tq_pop", 1158);
  current_task_ptr = *(int **)queue_ptr;
  if ( queue_ptr == *(_DWORD *)queue_ptr )
  {
    condition_ptr = (pthread_cond_t *)(queue_ptr + 40);
    if ( timeout_spec )
      wait_result = pthread_cond_timedwait(condition_ptr, mutex_ptr, timeout_spec);
    else
      wait_result = pthread_cond_wait(condition_ptr, mutex_ptr);
    if ( wait_result )
    {
      v8 = 0;
      goto LABEL_5;
    }
    if ( current_task_ptr == *(int **)queue_ptr )
    {
      v8 = 0;
      goto LABEL_5;
    }
    current_task_ptr = *(int **)queue_ptr;
  }
  next_task_ptr = (_DWORD *)current_task_ptr[1];
  current_task_value = *current_task_ptr;
  v8 = *(current_task_ptr - 1);
  *(_DWORD *)(current_task_value + 4) = next_task_ptr;
  *next_task_ptr = current_task_value;
  *current_task_ptr = 0;
  current_task_ptr[1] = 0;
  free(current_task_ptr - 1);
LABEL_5:
  log_mutex_unlock_error(mutex_ptr, "tq_pop", 1184);
  off_7ECC4(unlock_result);
  return v8;
}
// 2FE14: variable 'unlock_result' is possibly undefined
// 7ECC4: using guessed type int (__fastcall *off_7ECC4)(_DWORD);

//----- (0002FE84) --------------------------------------------------------
int __fastcall destroy_thread_and_semaphore(int thread_structure)
{
  int thread_structure_copy; // r4
  pthread_t thread_id; // r0
  sem_t *semaphore_pointer; // r0

  thread_structure_copy = thread_structure;
  if ( thread_structure )
  {
    thread_id = *(_DWORD *)(thread_structure + 12);
    if ( thread_id )
    {
      pthread_cancel(thread_id);
      semaphore_pointer = (sem_t *)(thread_structure_copy + 16);
      *(_DWORD *)(thread_structure_copy + 12) = 0;
    }
    else
    {
      semaphore_pointer = (sem_t *)(thread_structure_copy + 16);
    }
    return sem_destroy(semaphore_pointer);
  }
  return thread_structure;
}

//----- (0002FEC0) --------------------------------------------------------
_DWORD *__fastcall update_time_difference(_DWORD *current_time, int *prev_time)
{
  int prev_time_seconds; // r12
  int time_diff_microseconds; // r2
  int time_diff_seconds; // r3
  __int64 adjusted_time_diff; // r2

  prev_time_seconds = prev_time[1];
  time_diff_microseconds = *current_time - *prev_time;
  *prev_time = time_diff_microseconds;
  time_diff_seconds = current_time[1] - prev_time_seconds;
  prev_time[1] = time_diff_seconds;
  if ( time_diff_seconds < 0 )
  {
    LODWORD(adjusted_time_diff) = time_diff_microseconds - 1;
    HIDWORD(adjusted_time_diff) = time_diff_seconds + 1000000;
    *(_QWORD *)prev_time = adjusted_time_diff;
  }
  return current_time;
}

//----- (0002FEF4) --------------------------------------------------------
_DWORD *__fastcall update_time_values(_DWORD *time_values, int *delta_values)
{
  int delta_seconds; // lr
  int new_microseconds; // r2
  int new_seconds; // r3
  __int64 adjusted_time; // r2

  delta_seconds = delta_values[1];
  new_microseconds = *time_values + *delta_values;
  *delta_values = new_microseconds;
  new_seconds = time_values[1] + delta_seconds;
  delta_values[1] = new_seconds;
  if ( new_seconds > (int)&unk_F423F )
  {
    LODWORD(adjusted_time) = new_microseconds + 1;
    HIDWORD(adjusted_time) = new_seconds - 1000000;
    *(_QWORD *)delta_values = adjusted_time;
  }
  return time_values;
}

//----- (0002FF38) --------------------------------------------------------
bool __fastcall compare_hash_rate(_DWORD *first_miner_data, _DWORD *second_miner_data)
{
  if ( *first_miner_data == *second_miner_data )
    return first_miner_data[1] > second_miner_data[1];
  else
    return *first_miner_data > *second_miner_data;
}

//----- (0002FF6C) --------------------------------------------------------
bool __fastcall compare_task_priority(_DWORD *first_task_priority, _DWORD *second_task_priority)
{
  if ( *first_task_priority == *second_task_priority )
    return first_task_priority[1] < second_task_priority[1];
  else
    return *first_task_priority < *second_task_priority;
}

//----- (0002FFA0) --------------------------------------------------------
_DWORD *__fastcall convert_hashrate(_DWORD *hashrate_info, _DWORD *raw_data)
{
  *hashrate_info = *raw_data;
  hashrate_info[1] = raw_data[1] / 1000;
  return hashrate_info;
}

//----- (0002FFD0) --------------------------------------------------------
_DWORD *__fastcall copy_and_scale_values(_DWORD *destination, _DWORD *source)
{
  *destination = *source;
  destination[1] = 1000 * source[1];
  return destination;
}

//----- (0002FFEC) --------------------------------------------------------
int __fastcall calculate_long_division_result(_QWORD *division_result_pair)
{
  int operation_status; // r0
  int local_division_data[8]; // [sp+8h] [bp-20h] BYREF

  operation_status = lldiv(local_division_data);
  *division_result_pair = __PAIR64__(local_division_data[2], local_division_data[0]);
  return operation_status;
}
// 12478: using guessed type int __fastcall lldiv(_DWORD);

//----- (00030024) --------------------------------------------------------
int __fastcall calculate_uptime(_QWORD *uptime_out)
{
  int operation_result; // r0
  __int64 uptime; // r2
  int uptime_parts[8]; // [sp+8h] [bp-20h] BYREF

  operation_result = lldiv(uptime_parts);
  LODWORD(uptime) = uptime_parts[0];
  HIDWORD(uptime) = 1000 * uptime_parts[2];
  *uptime_out = uptime;
  return operation_result;
}
// 12478: using guessed type int __fastcall lldiv(_DWORD);

//----- (00030064) --------------------------------------------------------
int __fastcall calculate_hashrate_division(_QWORD *hashrate_result)
{
  int division_result; // r0
  __int64 hashrate_value_64; // r2
  int division_output[8]; // [sp+8h] [bp-20h] BYREF

  division_result = lldiv(division_output);
  LODWORD(hashrate_value_64) = division_output[0];
  HIDWORD(hashrate_value_64) = (_DWORD)&unk_F4240 * division_output[2];
  *hashrate_result = hashrate_value_64;
  return division_result;
}
// 12478: using guessed type int __fastcall lldiv(_DWORD);

//----- (000300A4) --------------------------------------------------------
int __fastcall sub_300A4(_QWORD *uptime_out)
{
  int lldiv_result; // r0
  __int64 uptime; // r2
  int lldiv_args[8]; // [sp+8h] [bp-20h] BYREF

  lldiv_result = lldiv(lldiv_args);
  LODWORD(uptime) = lldiv_args[0];
  HIDWORD(uptime) = 1000 * lldiv_args[2];
  *uptime_out = uptime;
  return lldiv_result;
}
// 12478: using guessed type int __fastcall lldiv(_DWORD);

//----- (000300E0) --------------------------------------------------------
_DWORD *__fastcall add_large_numbers(_DWORD *result_ptr, _DWORD *addend_ptr)
{
  int result_high; // r3
  __int64 combined_sum; // r2
  int updated_low; // lr
  int updated_high; // r1

  result_high = result_ptr[1];
  LODWORD(combined_sum) = *result_ptr + *addend_ptr;
  *result_ptr = combined_sum;
  HIDWORD(combined_sum) = result_high + addend_ptr[1];
  result_ptr[1] = HIDWORD(combined_sum);
  if ( SHIDWORD(combined_sum) <= 999999999 )
  {
    if ( combined_sum < 0 )
    {
      do
      {
        HIDWORD(combined_sum) += 1000000000;
        LODWORD(combined_sum) = combined_sum - 1;
      }
      while ( combined_sum < 0 );
      *(_QWORD *)result_ptr = combined_sum;
    }
  }
  else
  {
    updated_low = combined_sum + 1;
    updated_high = HIDWORD(combined_sum) - 1000000000;
    if ( HIDWORD(combined_sum) - 1000000000 > 999999999 )
    {
      updated_high = -2000000000;
      updated_low = combined_sum + 2;
    }
    *result_ptr = updated_low;
    if ( HIDWORD(combined_sum) - 1000000000 > 999999999 )
      updated_high += HIDWORD(combined_sum);
    result_ptr[1] = updated_high;
  }
  return result_ptr;
}

//----- (00030258) --------------------------------------------------------
const char *__fastcall split_string_at_delimiters(const char **p_input_str, const char *delimiters)
{
  const char *orig_str; // r4
  char *next_delimiter_ptr; // r0
  const char *split_segment; // r0

  orig_str = *p_input_str;
  if ( *p_input_str && (next_delimiter_ptr = strpbrk(*p_input_str, delimiters)) != 0 )
  {
    *next_delimiter_ptr = 0;
    *p_input_str = next_delimiter_ptr + 1;
    return orig_str;
  }
  else
  {
    split_segment = orig_str;
    *p_input_str = 0;
  }
  return split_segment;
}

//----- (000302A0) --------------------------------------------------------
__int64 __fastcall convert_timespec_to_custom_format(__time_t *output_custom_time)
{
  __int64 scaled_nsec; // r0
  int shifted_nsec; // r3
  struct timespec current_time; // [sp+0h] [bp-10h] BYREF

  clock_gettime(1, &current_time);
  scaled_nsec = 274877907LL * current_time.tv_nsec;
  shifted_nsec = current_time.tv_nsec >> 31;
  *output_custom_time = current_time.tv_sec;
  output_custom_time[1] = (SHIDWORD(scaled_nsec) >> 6) - shifted_nsec;
  return scaled_nsec;
}

//----- (000302E4) --------------------------------------------------------
int __fastcall calculate_total_hash_rate(_DWORD *hash_rate_parts)
{
  return hash_rate_parts[1] / 1000000 + 1000 * *hash_rate_parts;
}

//----- (00030314) --------------------------------------------------------
int __fastcall sub_30314(_DWORD *start_time, _DWORD *end_time, int *time_difference)
{
  int seconds_difference; // r3
  int nanoseconds_offset; // r1
  int nanoseconds_difference; // r0

  seconds_difference = *start_time - *end_time;
  *time_difference = seconds_difference;
  nanoseconds_offset = end_time[1];
  nanoseconds_difference = start_time[1] - nanoseconds_offset;
  if ( nanoseconds_difference >= 0 )
  {
    time_difference[1] = nanoseconds_difference;
  }
  else
  {
    nanoseconds_offset = 1000000000;
    --seconds_difference;
  }
  if ( nanoseconds_difference < 0 )
  {
    *time_difference = seconds_difference;
    time_difference[1] = nanoseconds_difference + nanoseconds_offset;
  }
  return nanoseconds_difference;
}

//----- (00030350) --------------------------------------------------------
int __fastcall get_monotonic_time(struct timespec *timespec_struct)
{
  return clock_gettime(1, timespec_struct);
}

//----- (0003035C) --------------------------------------------------------
int __fastcall calculate_next_sleep_interval(int *starting_time)
{
  int start_seconds; // r1
  int corrected_nsec; // r3
  __time_t calculated_seconds; // r2
  __time_t adjusted_seconds; // r12
  int temp_nsec; // r1
  int sleep_result; // r0
  struct timespec timespec_interval[2]; // [sp+0h] [bp-10h] BYREF

  calculate_hashrate_division(timespec_interval);
  start_seconds = *starting_time;
  timespec_interval[0].tv_nsec += starting_time[1];
  corrected_nsec = timespec_interval[0].tv_nsec;
  calculated_seconds = timespec_interval[0].tv_sec + start_seconds;
  timespec_interval[0].tv_sec += start_seconds;
  if ( timespec_interval[0].tv_nsec <= 999999999 )
  {
    if ( timespec_interval[0].tv_nsec < 0 )
    {
      do
      {
        corrected_nsec += 1000000000;
        --calculated_seconds;
      }
      while ( corrected_nsec < 0 );
      timespec_interval[0].tv_sec = calculated_seconds;
      timespec_interval[0].tv_nsec = corrected_nsec;
    }
  }
  else
  {
    adjusted_seconds = calculated_seconds + 1;
    temp_nsec = timespec_interval[0].tv_nsec - 1000000000;
    if ( timespec_interval[0].tv_nsec - 1000000000 > 999999999 )
    {
      temp_nsec = -2000000000;
      adjusted_seconds = calculated_seconds + 2;
    }
    timespec_interval[0].tv_sec = adjusted_seconds;
    if ( timespec_interval[0].tv_nsec - 1000000000 > 999999999 )
      temp_nsec += timespec_interval[0].tv_nsec;
    timespec_interval[0].tv_nsec = temp_nsec;
  }
  do
    sleep_result = clock_nanosleep(1, 1, timespec_interval, 0);
  while ( sleep_result == 4 );
  return sleep_result;
}

//----- (0003041C) --------------------------------------------------------
int __fastcall adjust_and_sleep(int *time_params)
{
  int initial_seconds; // r1
  int adjusted_nanoseconds; // r3
  __time_t updated_seconds; // r2
  __time_t incremented_seconds; // r12
  int overflow_nanoseconds; // r1
  int sleep_result; // r0
  struct timespec timespec_arr[2]; // [sp+0h] [bp-10h] BYREF

  calculate_uptime(timespec_arr);
  initial_seconds = *time_params;
  timespec_arr[0].tv_nsec += time_params[1];
  adjusted_nanoseconds = timespec_arr[0].tv_nsec;
  updated_seconds = timespec_arr[0].tv_sec + initial_seconds;
  timespec_arr[0].tv_sec += initial_seconds;
  if ( timespec_arr[0].tv_nsec <= 999999999 )
  {
    if ( timespec_arr[0].tv_nsec < 0 )
    {
      do
      {
        adjusted_nanoseconds += 1000000000;
        --updated_seconds;
      }
      while ( adjusted_nanoseconds < 0 );
      timespec_arr[0].tv_sec = updated_seconds;
      timespec_arr[0].tv_nsec = adjusted_nanoseconds;
    }
  }
  else
  {
    incremented_seconds = updated_seconds + 1;
    overflow_nanoseconds = timespec_arr[0].tv_nsec - 1000000000;
    if ( timespec_arr[0].tv_nsec - 1000000000 > 999999999 )
    {
      overflow_nanoseconds = -2000000000;
      incremented_seconds = updated_seconds + 2;
    }
    timespec_arr[0].tv_sec = incremented_seconds;
    if ( timespec_arr[0].tv_nsec - 1000000000 > 999999999 )
      overflow_nanoseconds += timespec_arr[0].tv_nsec;
    timespec_arr[0].tv_nsec = overflow_nanoseconds;
  }
  do
    sleep_result = clock_nanosleep(1, 1, timespec_arr, 0);
  while ( sleep_result == 4 );
  return sleep_result;
}

//----- (000304D4) --------------------------------------------------------
int get_next_sleep_interval()
{
  struct timespec current_time_spec; // [sp+0h] [bp-10h] BYREF

  clock_gettime(1, &current_time_spec);
  return calculate_next_sleep_interval(&current_time_spec.tv_sec);
}

//----- (00030534) --------------------------------------------------------
_DWORD *__fastcall check_time_difference(_DWORD *current_time, _DWORD *reference_time)
{
  if ( *current_time - *reference_time <= 60 )
    return &unk_F4240;
  return current_time;
}

//----- (00030578) --------------------------------------------------------
void *__fastcall get_time_difference(_DWORD *timestamp_one, _DWORD *timestamp_two)
{
  int delta_seconds; // r2

  delta_seconds = *timestamp_one - *timestamp_two;
  if ( delta_seconds > 3600 )
    return &unk_36EE80;
  else
    return (void *)((timestamp_one[1] - timestamp_two[1]) / 1000 + 1000 * delta_seconds);
}

//----- (000305CC) --------------------------------------------------------
void sub_305CC()
{
  ;
}

//----- (00030610) --------------------------------------------------------
int __fastcall parse_url(const char *url, _DWORD *host, char **port)
{
  const char *cleaned_url; // r4
  char *double_slash_ptr; // r0
  char *open_bracket_ptr; // r6
  char *close_bracket_ptr; // r0
  char has_port; // r5
  int valid_brackets; // r5
  char *colon_ptr; // r6
  size_t url_length; // r0
  int host_length; // r3
  int port_length; // r7
  char *end_of_port_ptr; // r0
  char port_buffer[8]; // [sp+8h] [bp-128h] BYREF
  char host_buffer[288]; // [sp+10h] [bp-120h] BYREF

  cleaned_url = url;
  *host = url;
  double_slash_ptr = strstr(url, "//");
  if ( double_slash_ptr )
    cleaned_url = double_slash_ptr + 2;
  open_bracket_ptr = strchr(cleaned_url, 91);
  close_bracket_ptr = strchr(cleaned_url, 93);
  has_port = (char)close_bracket_ptr;
  if ( close_bracket_ptr )
    has_port = 1;
  if ( !open_bracket_ptr )
    has_port = 0;
  if ( open_bracket_ptr < close_bracket_ptr )
    valid_brackets = has_port & 1;
  else
    valid_brackets = 0;
  if ( !valid_brackets )
    close_bracket_ptr = (char *)cleaned_url;
  colon_ptr = strchr(close_bracket_ptr, 58);
  url_length = strlen(cleaned_url);
  if ( colon_ptr )
  {
    host_length = colon_ptr - cleaned_url;
    port_length = ~(colon_ptr - cleaned_url) + url_length;
    if ( port_length <= 0 )
      return 0;
    ++colon_ptr;
  }
  else
  {
    host_length = url_length;
    port_length = 0;
  }
  if ( host_length <= 0 )
    return 0;
  if ( valid_brackets )
  {
    ++cleaned_url;
    host_length -= 2;
  }
  snprintf(host_buffer, 254u, "%.*s", host_length, cleaned_url);
  if ( port_length )
  {
    snprintf(port_buffer, 6u, "%.*s", port_length, colon_ptr);
    end_of_port_ptr = strpbrk(port_buffer, "/#");
    if ( end_of_port_ptr )
      *end_of_port_ptr = 0;
  }
  else
  {
    strcpy(port_buffer, "80");
  }
  *port = _strdup(port_buffer);
  *host = _strdup(host_buffer);
  return 1;
}

//----- (00030784) --------------------------------------------------------
char *__fastcall improve_url_format(char *url, int context)
{
  const char *current_protocol; // r4
  int protocol_index; // r5
  size_t protocol_length; // r6
  char *separator_position; // r0
  char *temp_position; // r8
  char *memory_logging; // r0
  const char *url_start_position; // r1

  current_protocol = "http:";
  protocol_index = 0;
  protocol_length = 5;
  *(_DWORD *)(context + 184) = 0;
  while ( strncmp(url, current_protocol, protocol_length) )
  {
    ++protocol_index;
    current_protocol = (&off_654CC)[2 * protocol_index];
    if ( !current_protocol )
      return url;
    protocol_length = strlen((&off_654CC)[2 * protocol_index]);
  }
  separator_position = strchr(url, 124);
  temp_position = separator_position;
  if ( separator_position )
  {
    *separator_position = 0;
    memory_logging = (char *)allocate_memory_logging(
                               1 - protocol_length + separator_position - url,
                               "util.c",
                               "get_proxy",
                               750);
    url_start_position = &url[protocol_length];
    *(_DWORD *)(context + 184) = memory_logging;
    url = temp_position + 1;
    strcpy(memory_logging, url_start_position);
    parse_url(*(const char **)(context + 184), (_DWORD *)(context + 604), (char **)(context + 608));
    *(_DWORD *)(context + 180) = *(_DWORD *)&aTqFreezethaw[8 * protocol_index + 20];
  }
  return url;
}
// 654CC: using guessed type char *off_654CC;

//----- (00030860) --------------------------------------------------------
char *__fastcall append_strings_with_padding(char *existing_string, char *string_to_append)
{
  size_t append_len; // r0
  const char *file_and_line_info; // r1
  char *memory_logging; // r4
  size_t total_len_with_null; // r4
  size_t padded_len; // r0
  char *allocated_string; // r4

  append_len = strlen(string_to_append);
  if ( !append_len )
    return existing_string;
  total_len_with_null = append_len + 1;
  if ( existing_string )
  {
    padded_len = strlen(existing_string) + total_len_with_null;
    if ( (padded_len & 3) != 0 )
      padded_len = (padded_len & 0xFFFFFFFC) + 4;
    memory_logging = (char *)allocate_memory_logging(padded_len, "util.c", "realloc_strcat", 3382);
    sprintf(memory_logging, "%s%s", existing_string, string_to_append);
    free(existing_string);
    return memory_logging;
  }
  if ( (total_len_with_null & 3) != 0 )
    append_len = total_len_with_null & 0xFFFFFFFC;
  else
    LOWORD(file_and_line_info) = 25564;
  if ( (total_len_with_null & 3) != 0 )
    LOWORD(file_and_line_info) = 25564;
  else
    append_len = total_len_with_null;
  if ( (total_len_with_null & 3) != 0 )
    append_len += 4;
  HIWORD(file_and_line_info) = 6;
  allocated_string = (char *)allocate_memory_logging(append_len, file_and_line_info, "realloc_strcat", 3382);
  strcpy(allocated_string, string_to_append);
  return allocated_string;
}
// 3090C: variable 'file_and_line_info' is possibly undefined

//----- (00030934) --------------------------------------------------------
char *__fastcall convert_string_to_printable_format(const char *input_string)
{
  size_t input_length; // r0
  const char *input_ptr; // r5
  char *memory_logging; // r7
  char *formatted_ptr; // r4
  char current_char_copy; // r3
  char current_char; // r2
  int next_char; // t1
  char *final_string; // r0
  char *null_string; // r2
  char log_message_buffer[2072]; // [sp+8h] [bp-818h] BYREF

  if ( !input_string )
  {
    null_string = (char *)malloc(7u);
    if ( null_string )
    {
      strcpy(null_string, "(null)");
    }
    else
    {
      snprintf(log_message_buffer, 2048u, "Failed to malloc null in %s %s():%d", "util.c", "str_text", 3407);
      logMessage(3, log_message_buffer, 1);
      nullsub_1();
    }
  }
  input_length = strlen(input_string);
  input_ptr = input_string - 1;
  memory_logging = (char *)allocate_memory_logging(4 * input_length + 5, "util.c", "str_text", 3412);
  formatted_ptr = memory_logging;
  do
  {
    while ( 1 )
    {
      next_char = *(unsigned __int8 *)++input_ptr;
      current_char = next_char;
      if ( (unsigned int)(next_char - 32) <= 94 )
        break;
      sprintf(formatted_ptr, "0x%02x");
      current_char_copy = *input_ptr;
      formatted_ptr += 4;
      if ( !*input_ptr )
        goto LABEL_7;
    }
    *formatted_ptr++ = current_char;
    current_char_copy = *input_ptr;
  }
  while ( *input_ptr );
LABEL_7:
  final_string = memory_logging;
  *formatted_ptr = current_char_copy;
  return final_string;
}

//----- (00030A54) --------------------------------------------------------
int __fastcall set_thread_name(const char *thread_name_suffix)
{
  char thread_name_buffer[24]; // [sp+8h] [bp-18h] BYREF

  snprintf(thread_name_buffer, 16u, "cg@%s", thread_name_suffix);
  return prctl(15, thread_name_buffer, 0);
}

//----- (00030A94) --------------------------------------------------------
void __fastcall initialize_semaphore_and_log_error(
        sem_t *semaphore,
        const char *file_name,
        const char *function_name,
        int line_number)
{
  int init_result; // r4
  int *errno_ptr; // r0
  char log_buffer[2072]; // [sp+10h] [bp-818h] BYREF

  init_result = sem_init(semaphore, 0, 0);
  if ( init_result )
  {
    errno_ptr = _errno_location();
    snprintf(
      log_buffer,
      2048u,
      "Failed to sem_init ret=%d errno=%d in %s %s():%d",
      init_result,
      *errno_ptr,
      file_name,
      function_name,
      line_number);
    logMessage(3, log_buffer, 1);
    nullsub_1();
  }
}

//----- (00030B10) --------------------------------------------------------
int __fastcall create_thread_with_logging(
        int thread_info_base_address,
        const pthread_attr_t *thread_attributes,
        void *(*start_routine)(void *),
        void *arg_for_start_routine)
{
  initialize_semaphore_and_log_error((sem_t *)(thread_info_base_address + 16), "util.c", "thr_info_create", 1191);
  return pthread_create(
           (pthread_t *)(thread_info_base_address + 12),
           thread_attributes,
           start_routine,
           arg_for_start_routine);
}

//----- (00030B58) --------------------------------------------------------
void __fastcall post_semaphore(sem_t *semaphore, const char *file_name, const char *function_name, int line_number)
{
  if ( sem_post(semaphore) )
    log_semaphore_post_failure(semaphore, file_name, function_name, line_number);
}

//----- (00030B90) --------------------------------------------------------
int __fastcall completion_thread_function(int completion_thread_args)
{
  pthread_setcanceltype(1, 0);
  (*(void (__fastcall **)(_DWORD))(completion_thread_args + 16))(*(_DWORD *)(completion_thread_args + 20));
  post_semaphore((sem_t *)completion_thread_args, "util.c", "completion_thread", 3638);
  return 0;
}

//----- (00030C54) --------------------------------------------------------
int __fastcall wait_with_timeout(
        sem_t *semaphore,
        int timeout_ms,
        const char *caller_filename,
        const char *caller_function_name,
        int caller_line_number)
{
  __time_t current_seconds; // r10
  int current_nanoseconds; // r5
  int total_nanoseconds; // r3
  __time_t total_seconds; // r2
  bool nano_underflow; // cc
  int adjusted_nanoseconds; // r1
  __time_t adjusted_seconds; // r0
  int wait_result; // r0
  struct timespec wait_deadline; // [sp+18h] [bp-830h] BYREF
  struct timespec current_time; // [sp+20h] [bp-828h] BYREF

  clock_gettime(1, &current_time);
  current_seconds = current_time.tv_sec;
  current_nanoseconds = 1000 * (current_time.tv_nsec / 1000);
  calculate_hashrate_division(&wait_deadline);
  while ( 1 )
  {
    total_nanoseconds = current_nanoseconds + wait_deadline.tv_nsec;
    total_seconds = current_seconds + wait_deadline.tv_sec;
    nano_underflow = current_nanoseconds + wait_deadline.tv_nsec <= 999999999;
    wait_deadline.tv_sec += current_seconds;
    wait_deadline.tv_nsec += current_nanoseconds;
    if ( nano_underflow )
    {
      if ( total_nanoseconds < 0 )
      {
        do
        {
          total_nanoseconds += 1000000000;
          --total_seconds;
        }
        while ( total_nanoseconds < 0 );
        wait_deadline.tv_sec = total_seconds;
        wait_deadline.tv_nsec = total_nanoseconds;
      }
    }
    else
    {
      adjusted_nanoseconds = total_nanoseconds - 1000000000;
      adjusted_seconds = total_seconds + 1;
      if ( total_nanoseconds - 1000000000 > 999999999 )
      {
        adjusted_nanoseconds = total_nanoseconds - 2000000000;
        adjusted_seconds = total_seconds + 2;
      }
      wait_deadline.tv_sec = adjusted_seconds;
      wait_deadline.tv_nsec = adjusted_nanoseconds;
    }
    wait_result = sem_timedwait(semaphore, &wait_deadline);
    if ( !wait_result )
      break;
    wait_result = *_errno_location();
    if ( wait_result == 110 )
      break;
    if ( wait_result != 4 )
    {
      snprintf(
        (char *)&current_time,
        2048u,
        "Failed to sem_timedwait errno=%d cgsem=0x%p in %s %s():%d",
        wait_result,
        semaphore,
        caller_filename,
        caller_function_name,
        caller_line_number);
      logMessage(3, (const char *)&current_time, 1);
      nullsub_1();
      return 0;
    }
  }
  return wait_result;
}

//----- (00030DA4) --------------------------------------------------------
int *__fastcall try_lock_semaphore(sem_t *semaphore)
{
  int *lock_result_or_errno; // r0

  do
  {
    while ( 1 )
    {
      lock_result_or_errno = (int *)sem_trywait(semaphore);
      if ( (int)lock_result_or_errno < 0 )
        break;
      if ( lock_result_or_errno )
        return lock_result_or_errno;
    }
    lock_result_or_errno = _errno_location();
  }
  while ( *lock_result_or_errno == 4 );
  return lock_result_or_errno;
}

//----- (00030DDC) --------------------------------------------------------
bool __fastcall sub_30DDC(int a1, int a2, int a3)
{
  sem_t *memory_logging; // r4
  int v7; // r5
  pthread_t newthread; // [sp+Ch] [bp-1Ch] BYREF

  memory_logging = (sem_t *)allocate_memory_logging(24u, "util.c", "cg_completion_timeout", 3649);
  initialize_semaphore_and_log_error(memory_logging, "util.c", "cg_completion_timeout", 3650);
  memory_logging[1].__align = a1;
  *(&memory_logging[1].__align + 1) = a2;
  pthread_create(&newthread, 0, (void *(*)(void *))completion_thread_function, memory_logging);
  v7 = wait_with_timeout(memory_logging, a3, "util.c", "cg_completion_timeout", 3656);
  if ( v7 )
  {
    pthread_cancel(newthread);
    return v7 == 0;
  }
  else
  {
    pthread_join(newthread, 0);
    free(memory_logging);
    return 1;
  }
}

//----- (00030EA8) --------------------------------------------------------
void *__fastcall safe_memcpy_with_logging(
        void *destination,
        const void *source,
        size_t num_bytes,
        int file_name,
        int function_name,
        int line_number)
{
  char error_message[2064]; // [sp+10h] [bp-810h] BYREF

  if ( (int)(num_bytes - 1) < 0 )
  {
    if ( !loggingDebug && !loggingVerbose && loggingThreshold <= 2 )
      return destination;
    snprintf(
      error_message,
      2048u,
      "ERR: Asked to memcpy %u bytes from %s %s():%d",
      num_bytes,
      file_name,
      function_name,
      line_number);
    return (void *)logMessage(3, error_message, 0);
  }
  if ( !destination )
  {
    if ( !loggingDebug && !loggingVerbose && loggingThreshold <= 2 )
      return destination;
    snprintf(
      error_message,
      2048u,
      "ERR: Asked to memcpy %u bytes to NULL from %s %s():%d",
      num_bytes,
      file_name,
      function_name,
      line_number);
    return (void *)logMessage(3, error_message, 0);
  }
  if ( source )
    return memcpy(destination, source, num_bytes);
  if ( loggingDebug || loggingVerbose || loggingThreshold > 2 )
  {
    snprintf(
      error_message,
      2048u,
      "ERR: Asked to memcpy %u bytes from NULL from %s %s():%d",
      num_bytes,
      file_name,
      function_name,
      line_number);
    return (void *)logMessage(3, error_message, 0);
  }
  return destination;
}
// 7EBA0: using guessed type int loggingThreshold;
// 482A5C: using guessed type char loggingVerbose;
// 590404: using guessed type char loggingDebug;

//----- (000311B8) --------------------------------------------------------
void *__fastcall copy_time_fields(void *destination, const void *source)
{
  return safe_memcpy_with_logging(destination, source, 8u, (int)"util.c", (int)"copy_time", 1236);
}

//----- (00031268) --------------------------------------------------------
_BYTE *__fastcall reverse_memory_block(_BYTE *destination_ptr, int num_elements)
{
  _BYTE *read_ptr; // r12
  unsigned int index; // r3
  char temp_front_value; // lr
  char read_value; // t1
  char temp_back_value; // t1

  if ( num_elements != 1 )
  {
    read_ptr = destination_ptr - 1;
    index = 0;
    destination_ptr += num_elements;
    do
    {
      ++index;
      read_value = *++read_ptr;
      temp_front_value = read_value;
      temp_back_value = *--destination_ptr;
      *read_ptr = temp_back_value;
      *destination_ptr = temp_front_value;
    }
    while ( index < ~index + num_elements );
  }
  return destination_ptr;
}

//----- (00031590) --------------------------------------------------------
int __fastcall calculate_crc16_checksum(int data_start, int data_len)
{
  int crc_low; // r3
  int data_end; // r1
  int current_index; // r2
  int crc_high; // r12
  int current_byte; // t1
  char *crc_lookup_ptr; // r0

  if ( !data_len )
    return 65535;
  crc_low = 255;
  data_end = data_start + (unsigned __int16)(data_len - 1);
  current_index = data_start - 1;
  crc_high = 255;
  do
  {
    current_byte = *(unsigned __int8 *)++current_index;
    crc_lookup_ptr = &aTqFreezethaw[crc_low ^ current_byte];
    crc_low = (unsigned __int8)crc_lookup_ptr[2280] ^ crc_high;
    crc_high = (unsigned __int8)crc_lookup_ptr[2536];
  }
  while ( data_end != current_index );
  return crc_low | (crc_high << 8);
}

//----- (000315EC) --------------------------------------------------------
int __fastcall calculate_error_check_code(_BYTE *input_buffer, int buffer_length)
{
  unsigned __int8 bitwise_xor_result; // r3
  int bit_index; // r12
  int previous_state; // r6
  int current_state; // r8
  int two_steps_back_state; // r5
  int three_steps_back_state; // r7
  int processed_length; // r4
  unsigned int current_bit_mask; // lr
  unsigned int current_bit_value; // r2
  int bit_parity; // r9
  int state_transition_xor; // r2
  int error_check_code; // r0

  if ( !buffer_length )
  {
    bit_parity = 1;
    error_check_code = 28;
LABEL_21:
    error_check_code |= 2u;
    goto LABEL_17;
  }
  bitwise_xor_result = 1;
  bit_index = 0;
  previous_state = 1;
  current_state = 1;
  two_steps_back_state = 1;
  three_steps_back_state = 1;
  processed_length = 0;
  current_bit_mask = 128;
  while ( 1 )
  {
    ++bit_index;
    ++processed_length;
    current_bit_value = *input_buffer & current_bit_mask;
    current_bit_mask >>= 1;
    if ( current_bit_value )
      bitwise_xor_result ^= 1u;
    bit_parity = bitwise_xor_result;
    if ( bit_index == 8 )
    {
      ++input_buffer;
      bit_index = 0;
      current_bit_mask = 128;
    }
    state_transition_xor = (unsigned __int8)(bitwise_xor_result ^ two_steps_back_state);
    bitwise_xor_result = previous_state;
    if ( buffer_length == processed_length )
      break;
    previous_state = current_state;
    two_steps_back_state = three_steps_back_state;
    current_state = state_transition_xor;
    three_steps_back_state = bit_parity;
  }
  if ( previous_state )
    error_check_code = 16;
  else
    error_check_code = 0;
  if ( current_state )
    error_check_code |= 8u;
  if ( bit_parity != two_steps_back_state )
    error_check_code |= 4u;
  if ( three_steps_back_state )
    goto LABEL_21;
LABEL_17:
  if ( bit_parity )
    return error_check_code | 1;
  return error_check_code;
}

//----- (000316B0) --------------------------------------------------------
int __fastcall reverse_copy_with_byte_swap(int destination, unsigned int *source, unsigned int num_bytes)
{
  unsigned int num_dwords; // r2
  unsigned int *end_source; // r2
  unsigned int current_dword; // t1

  num_dwords = num_bytes >> 2;
  if ( num_dwords )
  {
    end_source = &source[num_dwords];
    destination -= 4;
    do
    {
      current_dword = *source++;
      *(_DWORD *)(destination + 4) = bswap32(current_dword);
      destination += 4;
    }
    while ( source != end_source );
  }
  return destination;
}

//----- (000316D8) --------------------------------------------------------
unsigned int __fastcall calculate_crc_checksum(char *input_data, int data_length)
{
  char *data_end_ptr; // r1
  unsigned int crc_checksum; // r2
  char curr_char; // t1

  if ( !data_length )
    return 0;
  data_end_ptr = &input_data[data_length];
  crc_checksum = -1;
  do
  {
    curr_char = *input_data++;
    crc_checksum = *(_DWORD *)&aTqFreezethaw[4 * (unsigned __int8)(curr_char ^ crc_checksum) + 2792] ^ (crc_checksum >> 8);
  }
  while ( input_data != data_end_ptr );
  return ~crc_checksum;
}

//----- (00031720) --------------------------------------------------------
int __fastcall logCapabilityInformation(int loggingContext)
{
  unsigned int *capabilityInfo; // r10
  int loggingLevel; // r3
  unsigned int *currentBoardInfo; // r5
  unsigned int boardIndex; // r8
  unsigned int chainCount; // r2
  unsigned int chainIndex; // r4
  int currentChainId; // r3
  char logBuffer[2088]; // [sp+8h] [bp-828h] BYREF

  capabilityInfo = (unsigned int *)loggingContext;
  if ( loggingDebug || loggingVerbose || loggingThreshold > 4 )
  {
    strcpy(logBuffer, "==========================capability start==========================\n");
    loggingContext = logMessage(5, logBuffer, 0);
    if ( loggingDebug || loggingVerbose || loggingThreshold > 4 )
    {
      snprintf(logBuffer, 2048u, "board num = %d\n", *capabilityInfo);
      loggingContext = logMessage(5, logBuffer, 0);
    }
  }
  loggingLevel = (unsigned __int8)loggingDebug;
  if ( *capabilityInfo )
  {
    currentBoardInfo = capabilityInfo;
    boardIndex = 0;
    do
    {
      if ( loggingLevel || (loggingLevel = (unsigned __int8)loggingVerbose, loggingVerbose) || loggingThreshold > 4 )
      {
        snprintf(logBuffer, 2048u, "board id = %d, chain num = %d\n", currentBoardInfo[1], currentBoardInfo[2]);
        loggingContext = logMessage(5, logBuffer, 0);
        loggingLevel = (unsigned __int8)loggingDebug;
      }
      chainCount = currentBoardInfo[2];
      if ( chainCount )
      {
        chainIndex = 0;
        do
        {
          if ( !loggingLevel )
          {
            while ( 1 )
            {
              loggingLevel = (unsigned __int8)loggingVerbose;
              if ( loggingVerbose || loggingThreshold > 4 )
                break;
              if ( chainCount <= ++chainIndex )
                goto LABEL_17;
            }
          }
          currentChainId = currentBoardInfo[chainIndex++ + 3];
          snprintf(logBuffer, 2048u, "\tchain id = %d\n", currentChainId);
          loggingContext = logMessage(5, logBuffer, 0);
          chainCount = currentBoardInfo[2];
          loggingLevel = (unsigned __int8)loggingDebug;
        }
        while ( chainCount > chainIndex );
      }
LABEL_17:
      ++boardIndex;
      currentBoardInfo += 18;
    }
    while ( *capabilityInfo > boardIndex );
  }
  if ( loggingLevel || loggingVerbose || loggingThreshold > 4 )
  {
    strcpy(logBuffer, "==========================capability end============================\n");
    return logMessage(5, logBuffer, 0);
  }
  return loggingContext;
}
// 7EBA0: using guessed type int loggingThreshold;
// 482A5C: using guessed type char loggingVerbose;
// 590404: using guessed type char loggingDebug;

//----- (00031980) --------------------------------------------------------
char *__fastcall format_hashrate_data(char *output_buffer, int time_offset)
{
  int chain_index; // r6
  int next_chain_index; // r8
  char *data_end_pointer; // r0
  int total_hashes; // r3
  int current_time_index; // r2
  int target_time_index; // r0
  int adjusted_time_index; // r1
  int asic_index; // r5
  int asic_data_offset; // r6
  int asic_hash_count; // r3
  int time_iteration_index; // r2
  int time_iteration_target; // r0
  int adjusted_iteration_index; // r1
  char *destination_ptr; // [sp+8h] [bp-848h]
  char temp_string[4]; // [sp+14h] [bp-83Ch] BYREF
  int unused1; // [sp+18h] [bp-838h]
  int unused2; // [sp+1Ch] [bp-834h]
  int unused3; // [sp+20h] [bp-830h]
  int unused4; // [sp+24h] [bp-82Ch]
  int chain_buffer[522]; // [sp+28h] [bp-828h] BYREF

  chain_index = 0;
  do
  {
    next_chain_index = chain_index + 1;
    if ( get_global_buffer_value(chain_index) )
    {
      chain_buffer[0] = 123;
      memset(&chain_buffer[1], 0, 2044u);
      *(_DWORD *)temp_string = 0;
      unused1 = 0;
      unused2 = 0;
      unused3 = 0;
      unused4 = 0;
      sprintf(temp_string, "Chain%d:{", chain_index + 1);
      destination_ptr = (char *)stpcpy((char *)chain_buffer + 1, temp_string);
      total_hashes = 0;
      current_time_index = dword_482A60 % 60 - 1;
      target_time_index = current_time_index - time_offset;
      do
      {
        adjusted_time_index = current_time_index + (current_time_index < 0 ? 60 : 0);
        --current_time_index;
        total_hashes += dword_483AA0[30720 * chain_index + 2 * adjusted_time_index];
      }
      while ( current_time_index != target_time_index );
      sprintf(temp_string, "N%d=%d", 0, total_hashes);
      strcpy(destination_ptr, temp_string);
      asic_index = 1;
      asic_data_offset = 15360 * chain_index;
      while ( get_global_variable_value() > asic_index )
      {
        asic_hash_count = 0;
        time_iteration_index = dword_482A60 % 60 - 1;
        time_iteration_target = time_iteration_index - time_offset;
        do
        {
          adjusted_iteration_index = time_iteration_index + (time_iteration_index < 0 ? 60 : 0);
          --time_iteration_index;
          asic_hash_count += dword_483AA0[120 * asic_index + 2 * asic_data_offset + 2 * adjusted_iteration_index];
        }
        while ( time_iteration_target != time_iteration_index );
        sprintf(temp_string, ",N%d=%d", asic_index++, asic_hash_count);
        strcat((char *)chain_buffer, temp_string);
      }
      strcat((char *)chain_buffer, "},");
      strcat(output_buffer, (const char *)chain_buffer);
    }
    chain_index = next_chain_index;
  }
  while ( next_chain_index != 4 );
  data_end_pointer = &output_buffer[strlen(output_buffer)];
  *(data_end_pointer - 1) = 0;
  return data_end_pointer;
}
// 1203C: using guessed type int __fastcall stpcpy(_DWORD, _DWORD);
// 482A60: using guessed type int dword_482A60;
// 483AA0: using guessed type _DWORD dword_483AA0[122880];

//----- (00031BAC) --------------------------------------------------------
unsigned int get_max_voltage_from_eeprom()
{
  unsigned int max_voltage; // r5
  int eeprom_index; // r4
  unsigned int eeprom_voltage_value; // [sp+4h] [bp-814h] BYREF
  char log_message_buffer[2064]; // [sp+8h] [bp-810h] BYREF

  max_voltage = 0;
  for ( eeprom_index = 0; eeprom_index != 4; ++eeprom_index )
  {
    if ( get_global_buffer_value(eeprom_index)
      && !getVoltageLevel(eeprom_index, (unsigned __int8)optBitmainWorkMode, (int *)&eeprom_voltage_value)
      && max_voltage < eeprom_voltage_value )
    {
      max_voltage = eeprom_voltage_value;
    }
  }
  if ( (unsigned int)globalLogLevel > 4 )
  {
    snprintf(log_message_buffer, 2048u, "max voltage in eeprom = %d\n", max_voltage);
    logMessage(4, log_message_buffer, 0);
  }
  if ( max_voltage )
    return max_voltage;
  else
    return -1;
}
// 7EB9C: using guessed type int globalLogLevel;
// 80FB4: using guessed type int optBitmainWorkMode;

//----- (00031C64) --------------------------------------------------------
int log_fix_freq_version()
{
  char *message_buffer; // r12
  char stack_buffer; // [sp+0h] [bp-808h] BYREF

  strcpy(message_buffer, "This is fix-freq version\n");
  return logMessage(3, &stack_buffer, 0);
}
// 31C80: variable 'message_buffer' is possibly undefined

//----- (00031CAC) --------------------------------------------------------
int powerOffHashboard()
{
  int boardIndex; // r4
  char logBuffer[2056]; // [sp+0h] [bp-808h] BYREF

  if ( (unsigned int)globalLogLevel > 3 )
  {
    strcpy(logBuffer, "****power off hashboard****\n");
    logMessage(3, logBuffer, 0);
  }
  for ( boardIndex = 0; boardIndex != 4; ++boardIndex )
  {
    if ( get_global_buffer_value(boardIndex) )
      forward_to_handler_46900((unsigned __int8)boardIndex);
  }
  wait_one_second();
  return disable_hardware_watchdog();
}
// 7EB9C: using guessed type int globalLogLevel;

//----- (00031D38) --------------------------------------------------------
int get_global_variable()
{
  return dword_482A64;
}
// 482A64: using guessed type int dword_482A64;

//----- (00031D48) --------------------------------------------------------
int get_antminer_status_code()
{
  return dword_482A68;
}
// 482A68: using guessed type int dword_482A68;

//----- (00031D58) --------------------------------------------------------
unsigned int __fastcall handle_error_with_logging(unsigned int error_code, const char *a2)
{
  unsigned int v3; // r5
  int v4; // r3
  unsigned int v5; // r3
  char s[2072]; // [sp+8h] [bp-818h] BYREF

  v3 = error_code;
  dword_482A64 = error_code;
  v4 = globalLogLevel;
  if ( a2 )
  {
    if ( (unsigned int)globalLogLevel > 3 )
    {
      if ( error_code <= 17 )
        v4 = (unsigned __int16)off_666C0;
      if ( error_code <= 17 )
        HIWORD(v4) = (unsigned int)off_666C0 >> 16;
      if ( error_code <= 17 )
        v4 = *(_DWORD *)(v4 + 4 * error_code);
      if ( error_code > 17 )
        v4 = 0;
      snprintf(s, 2048u, "%s: %s\n", v4, a2);
      error_code = logMessage(3, s, 0);
      goto LABEL_12;
    }
  }
  else if ( (unsigned int)globalLogLevel > 3 )
  {
    if ( error_code <= 17 )
      LOWORD(v4) = (unsigned __int16)off_666C0;
    if ( error_code > 17 )
      v4 = 0;
    else
      HIWORD(v4) = (unsigned int)off_666C0 >> 16;
    if ( error_code <= 17 )
      v4 = *(_DWORD *)(v4 + 4 * error_code);
    snprintf(s, 2048u, "%s\n", v4);
    error_code = logMessage(3, s, 0);
LABEL_12:
    v5 = dword_482A64;
    if ( v3 == 3 )
      goto LABEL_14;
    goto LABEL_13;
  }
  if ( error_code == 3 )
    return error_code;
  v5 = error_code;
LABEL_13:
  dword_482A68 = v3;
LABEL_14:
  switch ( v5 )
  {
    case 4u:
    case 5u:
    case 7u:
    case 8u:
    case 9u:
    case 10u:
    case 12u:
    case 14u:
    case 15u:
    case 16u:
    case 17u:
      if ( (unsigned int)globalLogLevel > 1 )
      {
        snprintf(s, 2048u, "%s: %s\n", "stop_mining", a2);
        logMessage(1, s, 0);
      }
      check_and_log_temperature_uninitialized();
      terminate_worker_thread();
      cancel_thread_if_needed();
      cancel_mining_thread();
      powerOffHashboard();
      enable_gpio_control();
      error_code = configure_gpio_control_for_miner();
      break;
    case 6u:
    case 11u:
    case 13u:
      if ( (unsigned int)globalLogLevel > 1 )
      {
        snprintf(s, 2048u, "%s: %s\n", "stop_mining_and_restart", a2);
        logMessage(1, s, 0);
      }
      check_and_log_temperature_uninitialized();
      terminate_worker_thread();
      cancel_thread_if_needed();
      cancel_mining_thread();
      powerOffHashboard();
      enable_gpio_control();
      configure_gpio_control_for_miner();
      strcpy(s, "restart\n");
      logMessage(0, s, 0);
      _assert_fail("0", "driver-btm-api.c", 152u, "stop_mining_and_restart");
      return error_code;
    default:
      return error_code;
  }
  return error_code;
}
// 31DEC: control flows out of bounds to 31DF0
// 666C0: using guessed type char *off_666C0[18];
// 7EB9C: using guessed type int globalLogLevel;
// 482A64: using guessed type int dword_482A64;
// 482A68: using guessed type int dword_482A68;

//----- (00031F90) --------------------------------------------------------
int __fastcall reset_pic_and_log_error(int chain_index)
{
  char log_buffer[2056]; // [sp+0h] [bp-808h] BYREF

  if ( (unsigned int)globalLogLevel > 3 )
  {
    snprintf(log_buffer, 2048u, "Chain %d PIC reset failed.\n", chain_index);
    logMessage(3, log_buffer, 0);
  }
  set_chain_status(chain_index, 0);
  generate_error_message(4, chain_index);
  handle_error_with_logging(8u, "PIC reset failed.\n");
  return -1;
}
// 7EB9C: using guessed type int globalLogLevel;

//----- (00032010) --------------------------------------------------------
int __fastcall process_chip_state(int chip_id)
{
  unsigned int chip_id_unsigned; // r5

  chip_id_unsigned = (unsigned __int8)chip_id;
  if ( !is_chip_disabled((unsigned __int8)chip_id) )
    return reset_pic_and_log_error(chip_id);
  initiatePICJumpToAppAndVerifyFirmware(chip_id);
  forward_to_handler_46900(chip_id_unsigned);
  return 0;
}

//----- (0003204C) --------------------------------------------------------
int check_chip_states()
{
  int chip_index; // r4
  int result_flags; // r5

  chip_index = 0;
  result_flags = 0;
  do
  {
    if ( get_global_buffer_value(chip_index) )
      result_flags |= process_chip_state(chip_index);
    ++chip_index;
  }
  while ( chip_index != 4 );
  return result_flags;
}

//----- (0003208C) --------------------------------------------------------
void update_chip_frequencies()
{
  float frequency_update_period; // s0
  int buffer_index; // r4
  int global_variable_value; // r0
  int frequency_value; // r2
  unsigned int *frequency_buffer_start; // r3
  unsigned int *frequency_buffer_end; // r0

  if ( minerOperationMode != 2 )
  {
    frequency_update_period = unk_7EB74;
    goto LABEL_3;
  }
  for ( buffer_index = 0; buffer_index != 4; ++buffer_index )
  {
    if ( get_global_buffer_value(buffer_index) )
    {
      global_variable_value = get_global_variable_value();
      if ( global_variable_value > 0 )
      {
        frequency_value = dword_482A6C;
        frequency_buffer_start = &dword_4FBAA0[256 * buffer_index];
        frequency_buffer_end = &dword_4FBAA0[256 * buffer_index + global_variable_value];
        do
          *frequency_buffer_start++ = frequency_value;
        while ( frequency_buffer_start != frequency_buffer_end );
      }
    }
  }
  frequency_update_period = unk_7EB74;
  if ( unk_7EB74 <= 0.0 )
  {
LABEL_3:
    if ( frequency_update_period > 0.0 )
      return;
LABEL_10:
    dword_482A6C = setChipFrequencies((int)dword_4FBAA0, (unsigned __int8)byte_482A70, 1);
    return;
  }
  SetFrequencyStep((unsigned __int8)byte_482A70, dword_7EDCC, dword_482A6C);
  if ( unk_7EB74 <= 0.0 )
    goto LABEL_10;
}
// 7EDC8: using guessed type int minerOperationMode;
// 7EDCC: using guessed type int dword_7EDCC;
// 482A6C: using guessed type int dword_482A6C;
// 482A70: using guessed type char byte_482A70;
// 4FBAA0: using guessed type unsigned int dword_4FBAA0[1024];

//----- (000321B8) --------------------------------------------------------
int __fastcall update_miner_frequency(int update_status, int target_hash_count, int frequency_percentage)
{
  int initial_frequency; // r5
  int clock_cycle_count; // r7
  unsigned int clock_cycle_divisor; // r3
  int adjusted_clock_cycle; // r0
  unsigned int divisor_mask; // r1
  int calculated_frequency; // r8
  int adjusted_clock_cycle_count; // r9
  unsigned int adjusted_cycle_divisor; // r0
  int new_clock_cycle; // r9
  unsigned int i; // r1
  int final_hash_count; // r0
  char log_buffer[2080]; // [sp+10h] [bp-820h] BYREF

  initial_frequency = update_status;
  if ( update_status && (update_status = sub_1E160()) != 0 && (update_status = get_miner_status_flag()) != 0 )
  {
    clock_cycle_count = sub_1E160();
    clock_cycle_divisor = get_shared_value();
    if ( !clock_cycle_divisor )
      goto LABEL_23;
    adjusted_clock_cycle = clock_cycle_count << 24;
    if ( clock_cycle_divisor != 1 )
    {
      for ( divisor_mask = 1; divisor_mask < clock_cycle_divisor; divisor_mask *= 2 )
        ;
      adjusted_clock_cycle = call_external_function_with_check(adjusted_clock_cycle, divisor_mask);
    }
    calculated_frequency = call_external_function_with_check(
                             frequency_percentage * adjusted_clock_cycle * target_hash_count / 100,
                             initial_frequency);
    dword_99EDDC = calculated_frequency;
    adjusted_clock_cycle_count = sub_1E160();
    adjusted_cycle_divisor = get_shared_value();
    if ( !adjusted_cycle_divisor )
LABEL_23:
      __und(0);
    new_clock_cycle = adjusted_clock_cycle_count << 24;
    if ( adjusted_cycle_divisor != 1 )
    {
      for ( i = 1; i < adjusted_cycle_divisor; i *= 2 )
        ;
      new_clock_cycle = call_external_function_with_check(new_clock_cycle, i);
    }
    if ( (globalTokenBuffer1 & 4) != 0 && word_99EDCA )
      dword_99EDDC = HIBYTE(word_99EDCA) + 1000 * (unsigned __int8)word_99EDCA;
    update_status = configure_register_and_read_value(calculated_frequency);
    if ( (unsigned int)globalLogLevel > 3 )
    {
      final_hash_count = call_external_function_with_check(25 * new_clock_cycle, initial_frequency);
      snprintf(
        log_buffer,
        2048u,
        "freq = %d, percent = %d, hcn = %d, timeout = %d\n",
        initial_frequency,
        frequency_percentage,
        target_hash_count * final_hash_count,
        calculated_frequency);
      return logMessage(3, log_buffer, 0);
    }
  }
  else
  {
    if ( (unsigned int)globalLogLevel > 3 )
    {
      strcpy(log_buffer, "Note: addrInterval or corenum is not initialized.\n");
      update_status = logMessage(3, log_buffer, 0);
    }
    dword_99EDDC = (int)&loc_1FFFC + 3;
  }
  return update_status;
}
// 7EB9C: using guessed type int globalLogLevel;
// 99EDBC: using guessed type char globalTokenBuffer1;
// 99EDCA: using guessed type __int16 word_99EDCA;
// 99EDDC: using guessed type int dword_99EDDC;

//----- (000323A4) --------------------------------------------------------
int initialize_mining_operation()
{
  int initial_log_level; // r0

  initial_log_level = globalLogLevel;
  minerOperationMode = 2;
  isSerialNumberValid = 1;
  if ( (unsigned int)globalLogLevel > 3 )
    return log_fix_freq_version();
  return initial_log_level;
}
// 7EB9C: using guessed type int globalLogLevel;
// 7EDC8: using guessed type int minerOperationMode;
// 482A71: using guessed type char isSerialNumberValid;

//----- (000323DC) --------------------------------------------------------
int logChainVersions()
{
  int chainIndex; // r4
  int result; // r0
  int ChainPcbVersion; // r0
  int ChainBomVersion; // r0
  char logBuffer[2072]; // [sp+8h] [bp-818h] BYREF

  for ( chainIndex = 0; chainIndex != 4; ++chainIndex )
  {
    result = get_global_buffer_value(chainIndex);
    if ( result && (unsigned int)globalLogLevel > 3 )
    {
      ChainPcbVersion = getPCBVersionForChain(chainIndex);
      snprintf(logBuffer, 2048u, "Chain [%d] PCB Version: 0x%04x\n", chainIndex, ChainPcbVersion);
      logMessage(3, logBuffer, 0);
      result = chainIndex;
      if ( (unsigned int)globalLogLevel > 3 )
      {
        ChainBomVersion = getChainBomVersion(chainIndex);
        snprintf(logBuffer, 2048u, "Chain [%d] BOM Version: 0x%04x\n", chainIndex, ChainBomVersion);
        result = logMessage(3, logBuffer, 0);
      }
    }
  }
  return result;
}
// 7EB9C: using guessed type int globalLogLevel;

//----- (000324A8) --------------------------------------------------------
int initialize_and_log_chain_status()
{
  int last_operation_result; // r0
  unsigned int chain_count; // r3
  int *current_chain_ptr; // r6
  unsigned int current_chain_index; // r7
  int *current_chain_component_ptr; // r5
  unsigned int current_component_index; // r4
  unsigned int current_component_id; // t1
  int config_array[79]; // [sp+4h] [bp-13Ch] BYREF

  initialize_and_copy_hash_chain_config(config_array);
  last_operation_result = logCapabilityInformation((int)config_array);
  chain_count = config_array[0];
  if ( config_array[0] )
  {
    current_chain_ptr = config_array;
    current_chain_index = 0;
    do
    {
      if ( current_chain_ptr[2] )
      {
        current_chain_component_ptr = current_chain_ptr + 2;
        current_component_index = 0;
        do
        {
          current_component_id = current_chain_component_ptr[1];
          ++current_chain_component_ptr;
          last_operation_result = set_chain_status(current_component_id, 1);
          ++current_component_index;
        }
        while ( current_chain_ptr[2] > current_component_index );
        chain_count = config_array[0];
      }
      ++current_chain_index;
      current_chain_ptr += 18;
    }
    while ( chain_count > current_chain_index );
  }
  return last_operation_result;
}

//----- (00032520) --------------------------------------------------------
int initialize_fan_control()
{
  enable_gpio_control();
  return configure_fan_control_gpio();
}

//----- (00032530) --------------------------------------------------------
int check_and_configure_miner_gpio()
{
  int gpio_config_result; // r0
  int flag_state_after_toggle_1; // r3
  int flag_state_after_toggle_2; // r3
  int flag_state_after_toggle_3; // r3
  int flag_state_after_toggle_4; // r3

  gpio_config_result = get_global_state_flag();
  if ( minerOperationMode )
  {
    switch ( dword_482A64 )
    {
      case 0:
      case 1:
        return gpio_config_result;
      case 2:
        goto LABEL_9;
      case 17:
        goto LABEL_13;
      default:
        flag_state_after_toggle_4 = (unsigned __int8)byte_7EDD4 ^ 1;
        byte_7EDD4 ^= 1u;
        if ( flag_state_after_toggle_4 )
          goto LABEL_13;
        configure_hashboard_reset_gpio();
        return configure_gpio_control_for_miner();
    }
  }
  if ( !gpio_config_result )
  {
LABEL_13:
    enable_gpio_control();
    return configure_gpio_control_for_miner();
  }
  if ( gpio_config_result != 1 )
  {
LABEL_9:
    configure_hashboard_reset_gpio();
    flag_state_after_toggle_3 = (unsigned __int8)byte_7EDD4 ^ 1;
    byte_7EDD4 ^= 1u;
    if ( flag_state_after_toggle_3 )
      return configure_fan_control_gpio();
    return configure_gpio_control_for_miner();
  }
  flag_state_after_toggle_1 = (unsigned __int8)byte_7EDD4 ^ 1;
  byte_7EDD4 ^= 1u;
  if ( flag_state_after_toggle_1 )
    enable_gpio_control();
  else
    configure_hashboard_reset_gpio();
  flag_state_after_toggle_2 = (unsigned __int8)byte_7EDD4 ^ 1;
  byte_7EDD4 ^= 1u;
  if ( !flag_state_after_toggle_2 )
    return configure_gpio_control_for_miner();
  return configure_fan_control_gpio();
}
// 325A4: control flows out of bounds to 325A8
// 7EDC8: using guessed type int minerOperationMode;
// 7EDD4: using guessed type char byte_7EDD4;
// 482A64: using guessed type int dword_482A64;

//----- (0003264C) --------------------------------------------------------
int update_miner_statistics()
{
  int chain_index; // r4
  unsigned int chain_id; // r5
  char *config_base_ptr; // r10
  int final_result; // r0
  int failed_chip_count; // r6
  unsigned int chip_index; // r4
  _QWORD *asic_index; // r10
  int log_index_offset; // r12
  int chain_chip_index; // r11
  int chip_status; // r0
  int is_chip_failed; // r1
  int incremented_chip_index; // r1
  __int64 *chain_nonce_ptr; // r6
  unsigned int i; // r5
  bool is_log_level_high; // cc
  __int64 nonce_count; // r0
  __int64 current_nonce_count; // t1
  char *config_ptr; // [sp+20h] [bp-830h]
  char log_buffer[2088]; // [sp+28h] [bp-828h] BYREF

  for ( chain_index = 0; chain_index != 4; ++chain_index )
  {
    if ( get_global_buffer_value(chain_index) )
    {
      get_global_variable_value();
      chain_nonce_ptr = &qword_99CD98[256 * chain_index];
      for ( i = 0; get_global_variable_value() > i; ++i )
      {
        is_log_level_high = (unsigned int)globalLogLevel > 4;
        current_nonce_count = *chain_nonce_ptr++;
        nonce_count = current_nonce_count;
        *(_QWORD *)&dword_483AA0[30720 * chain_index + 120 * i + 2 * (dword_482A60 % 60)] = current_nonce_count;
        if ( is_log_level_high )
        {
          snprintf(log_buffer, 2048u, "chain %u asic %u asic_nonce_num %llu\n", chain_index, i, nonce_count);
          logMessage(4, log_buffer, 0);
        }
      }
    }
  }
  ++dword_482A60;
  memset(byte_5924F4, 0, sizeof(byte_5924F4));
  memset(byte_590440, 0, 8192u);
  memset(byte_58E3F8, 0, sizeof(byte_58E3F8));
  format_hashrate_data(byte_5924F4, 10);
  format_hashrate_data(byte_590440, 30);
  chain_id = 0;
  config_base_ptr = (char *)&unk_482AA0;
  format_hashrate_data(byte_58E3F8, 60);
  do
  {
    final_result = get_global_buffer_value(chain_id);
    if ( final_result )
    {
      failed_chip_count = 0;
      config_ptr = config_base_ptr;
      chip_index = 0;
      for ( asic_index = &qword_99CD98[256 * chain_id]; ; ++asic_index )
      {
        chain_chip_index = failed_chip_count + chip_index;
        if ( get_global_variable_value() <= chip_index )
          break;
        chip_status = get_global_value();
        calculate_difficulty_ratio(chip_index, chip_status);
        if ( !is_chip_failed )
        {
          ++failed_chip_count;
          incremented_chip_index = chain_chip_index;
          chain_chip_index = failed_chip_count + chip_index;
          set_chain_config_byte(chain_id, incremented_chip_index, 32);
        }
        log_index_offset = dword_482A60 % 60 - 1;
        if ( log_index_offset < 0 )
          log_index_offset = dword_482A60 % 60 + 59;
        if ( (int)dword_483AA0[30720 * chain_id + 120 * chip_index + 2 * log_index_offset] <= 1 )
        {
          set_chain_config_byte(chain_id, chain_chip_index, 120);
          ++*(_DWORD *)&config_ptr[4 * chip_index];
        }
        else
        {
          set_chain_config_byte(chain_id, chain_chip_index, 111);
        }
        ++chip_index;
        *asic_index = 0LL;
      }
      config_base_ptr = config_ptr;
      final_result = set_chain_config_byte(chain_id, failed_chip_count + chip_index, 0);
    }
    ++chain_id;
    config_base_ptr += 1024;
  }
  while ( chain_id != 4 );
  return final_result;
}
// 3282C: variable 'is_chip_failed' is possibly undefined
// 7EB9C: using guessed type int globalLogLevel;
// 482A60: using guessed type int dword_482A60;
// 483AA0: using guessed type _DWORD dword_483AA0[122880];
// 99CD98: using guessed type _QWORD qword_99CD98[1024];

//----- (000329DC) --------------------------------------------------------
int InitializeChains()
{
  unsigned int chainIndex; // r4
  int attemptCount; // r5
  int foundASICs; // r8
  int finalASICCount; // r5
  int initializationResult; // [sp+Ch] [bp-82Ch]
  char logBuffer[2088]; // [sp+10h] [bp-828h] BYREF

  chainIndex = 0;
  initializationResult = 0;
  do
  {
    if ( get_global_buffer_value(chainIndex) )
    {
      attemptCount = 0;
      do
      {
        enable_miner_chip(chainIndex);
        sleep(3u);
        relay_control((unsigned __int8)chainIndex);
        get_next_sleep_interval();
        if ( byte_80FB0 )
        {
          if ( (unsigned int)globalLogLevel > 3 )
          {
            snprintf(logBuffer, 2048u, "pic enabled for chain %d, press anykey to continue...", chainIndex);
            logMessage(3, logBuffer, 0);
          }
          IO_getc((_IO_FILE *)stdin);
        }
        disable_bit_in_register(chainIndex);
        get_next_sleep_interval();
        enable_miner_chip(chainIndex);
        sleep(1u);
        disable_bit_in_register(chainIndex);
        get_next_sleep_interval();
        process_chain_events(chainIndex, 0);
        foundASICs = get_chain_data_status(chainIndex);
        if ( (unsigned int)globalLogLevel > 3 )
        {
          snprintf(logBuffer, 2048u, "Chain[%d]: find %d asic, times %d\n", chainIndex, foundASICs, attemptCount);
          logMessage(3, logBuffer, 0);
        }
        ++attemptCount;
        if ( foundASICs == get_global_variable_value() )
          break;
        forward_to_handler_46900((unsigned __int8)chainIndex);
      }
      while ( attemptCount != 3 );
      finalASICCount = get_chain_data_status(chainIndex);
      if ( get_global_variable_value() != finalASICCount )
      {
        if ( (unsigned int)globalLogLevel > 3 )
        {
          snprintf(
            logBuffer,
            2048u,
            "Chain %d only find %d asic, will power off hash board %d\n",
            chainIndex,
            finalASICCount,
            chainIndex);
          logMessage(3, logBuffer, 0);
        }
        initializationResult = -1;
        forward_to_handler_46900((unsigned __int8)chainIndex);
        set_chain_status(chainIndex, 0);
      }
    }
    ++chainIndex;
  }
  while ( chainIndex != 4 );
  return initializationResult;
}
// 7EB9C: using guessed type int globalLogLevel;
// 7F798: using guessed type int stdin;
// 80FB0: using guessed type char byte_80FB0;

//----- (00032BD0) --------------------------------------------------------
int getFirmwareVersionAndMinerID()
{
  int firmwareVersion; // r0
  int minorRevision; // r5
  int majorRevision; // r4
  char logBuffer[2064]; // [sp+8h] [bp-810h] BYREF

  format_register_values(byte_99EDE0, 32u);
  if ( (unsigned int)globalLogLevel > 3 )
  {
    snprintf(logBuffer, 2048u, "miner ID : %s\n", byte_99EDE0);
    logMessage(3, logBuffer, 0);
  }
  firmwareVersion = read_control_register_value();
  minorRevision = BYTE2(firmwareVersion);
  majorRevision = (unsigned __int8)firmwareVersion;
  if ( (unsigned int)globalLogLevel > 3 )
  {
    snprintf(logBuffer, 2048u, "FPGA Version = 0x%04X\n", (unsigned __int16)firmwareVersion);
    logMessage(3, logBuffer, 0);
  }
  return sprintf(byte_80FDC, "%d.%d.%d.%d", majorRevision, minorRevision, 1, 3);
}
// 7EB9C: using guessed type int globalLogLevel;

//----- (00032CA8) --------------------------------------------------------
int initialize_and_update_uptime()
{
  convert_timespec_to_custom_format(dword_482A74);
  return updateMinerUptime();
}
// 482A74: using guessed type __time_t dword_482A74[3];

//----- (00032CC0) --------------------------------------------------------
size_t __fastcall sub_32CC0(_DWORD *a1, int a2, int a3)
{
  char v4; // r1
  int v5; // r2
  int v6; // r3
  int v7; // r0
  char *v8; // r9
  size_t v9; // r4
  size_t v10; // r2
  int v11; // r1
  __int64 v12; // r6
  int v13; // r10
  size_t v14; // r11
  size_t v15; // r7
  char *v16; // r6
  _DWORD **v17; // lr
  char *v18; // r4
  _DWORD **v19; // r3
  _DWORD *v20; // t1
  int v21; // r12
  int v22; // r0
  int v23; // r1
  int v24; // r12
  int v25; // r0
  int v26; // r1
  __int16 v27; // r0
  __int64 v28; // kr00_8
  void *v29; // r0
  __int64 src; // [sp+8h] [bp-890h] BYREF
  int v33[24]; // [sp+10h] [bp-888h] BYREF
  char v34[2088]; // [sp+70h] [bp-828h] BYREF

  v4 = *(_BYTE *)(a2 + 680);
  v33[3] = a3;
  BYTE1(v33[2]) = BYTE1(v33[2]) & 0xFE | v4 & 1 | 2;
  LOBYTE(v33[2]) = qword_482A80;
  LOWORD(v33[0]) = 82;
  src = 0LL;
  BYTE2(v33[2]) = 15;
  if ( byte_482A88 )
  {
    v5 = *(_DWORD *)(a2 + 648);
    v6 = *(_DWORD *)(a2 + 652);
    LOBYTE(v33[20]) = *(_BYTE *)(a2 + 644);
    v33[21] = v5;
    v33[22] = v6;
  }
  hex_to_bin(&v33[4], (unsigned __int8 *)(a2 + 1780), 4);
  hex_to_bin(&v33[5], (unsigned __int8 *)(a2 + 1712), 32);
  hex_to_bin(&v33[14], (unsigned __int8 *)(a2 + 1792), 4);
  hex_to_bin(&v33[13], (unsigned __int8 *)(a2 + 1804), 4);
  v7 = *(_DWORD *)(a2 + 1576);
  v8 = *(char **)(a2 + 1568);
  v9 = *(_DWORD *)(a2 + 1572);
  v10 = *(_DWORD *)(a2 + 632);
  HIWORD(v33[15]) = v7;
  LOWORD(v33[15]) = v9;
  LOWORD(v33[16]) = v10;
  v11 = *(_DWORD *)&v8[v7 + 4];
  v12 = *(_QWORD *)(a2 + 624);
  v33[18] = *(_DWORD *)&v8[v7];
  v33[19] = v11;
  src = v12;
  memcpy(&v33[18], &src, v10);
  v13 = *(_DWORD *)(a2 + 1708);
  HIWORD(v33[16]) = v13;
  v14 = v9 + 32 * v13;
  v15 = v14 + 98;
  v16 = (char *)malloc(v14 + 98);
  if ( !v16 )
  {
    strcpy(v34, "Failed to malloc tmp_buf");
    logMessage(3, v34, 1);
    nullsub_1();
    v13 = *(_DWORD *)(a2 + 1708);
    v8 = *(char **)(a2 + 1568);
    v9 = *(_DWORD *)(a2 + 1572);
  }
  v33[1] = v14 + 90;
  memset(v16, 0, v14 + 98);
  memcpy(v16, v33, 96u);
  memcpy(v16 + 96, v8, v9);
  if ( v13 > 0 )
  {
    v17 = *(_DWORD ***)(a2 + 676);
    v18 = &v16[v9 + 96];
    v19 = &v17[v13];
    do
    {
      v20 = *v17++;
      v18 += 32;
      v21 = v20[1];
      v22 = v20[2];
      v23 = v20[3];
      *((_DWORD *)v18 - 8) = *v20;
      *((_DWORD *)v18 - 7) = v21;
      *((_DWORD *)v18 - 6) = v22;
      *((_DWORD *)v18 - 5) = v23;
      v24 = v20[5];
      v25 = v20[6];
      v26 = v20[7];
      *((_DWORD *)v18 - 4) = v20[4];
      *((_DWORD *)v18 - 3) = v24;
      *((_DWORD *)v18 - 2) = v25;
      *((_DWORD *)v18 - 1) = v26;
    }
    while ( v17 != v19 );
  }
  v27 = calculate_crc16_checksum((int)v16, (unsigned __int16)(v14 + 96));
  v28 = qword_482A80;
  *(_WORD *)&v16[v14 + 96] = v27;
  qword_482A80 = v28 + 1;
  v29 = malloc(v15);
  *a1 = v29;
  memcpy(v29, v16, v15);
  free(v16);
  return v14 + 98;
}
// 482A80: using guessed type __int64 qword_482A80;
// 482A88: using guessed type char byte_482A88;

//----- (00032F40) --------------------------------------------------------
int __fastcall sendJobToMiner(unsigned __int8 *jobBuffer)
{
  int jobLength; // r8
  size_t bufferSize; // r8
  unsigned __int8 *buffer; // r0
  unsigned __int8 *allocatedBuffer; // r6
  int versionNumber; // r2
  int currentVersion; // r1
  int jobVersion; // r3
  int maskNumber; // r2
  int globalBitMask; // r3
  unsigned __int8 jobControlByte; // r2
  int jobDataOffset; // r1
  int jobStartIndex; // r0
  int chipParameter; // r3
  int jobEndIndex; // r0
  int chipCommand; // r3
  int jobCommandParam; // r0
  int paramLength; // lr
  __int64 rollingTime; // r2
  int checksum; // r0
  int timestamp; // r0
  int anotherParam; // r0
  int additionalData[16]; // [sp+10h] [bp-878h] BYREF
  __int64 additionalTime; // [sp+50h] [bp-838h]
  int additionalIndex; // [sp+58h] [bp-830h]
  int additionalChipParam; // [sp+5Ch] [bp-82Ch]
  char logBuffer[2088]; // [sp+60h] [bp-828h] BYREF

  if ( *jobBuffer != 82 )
  {
    if ( !logEnabled || !loggingDebug && !loggingVerbose && loggingThreshold <= 6 )
      return -1;
    snprintf(logBuffer, 2048u, "%s: SEND_JOB_TYPE is wrong : 0x%x\n", "dhash_chip_send_job", *jobBuffer);
    logMessage(7, logBuffer, 0);
    return -1;
  }
  jobLength = *((_DWORD *)jobBuffer + 1);
  if ( logEnabled && (loggingDebug || loggingVerbose || loggingThreshold > 6) )
  {
    snprintf(logBuffer, 2048u, "%s: len = 0x%x\n", "dhash_chip_send_job", *((_DWORD *)jobBuffer + 1));
    logMessage(7, logBuffer, 0);
  }
  bufferSize = jobLength + 8;
  buffer = (unsigned __int8 *)calloc(bufferSize, 1u);
  allocatedBuffer = buffer;
  if ( !buffer )
  {
    if ( !logEnabled || !loggingDebug && !loggingVerbose && loggingThreshold <= 6 )
      return -2;
    snprintf(logBuffer, 2048u, "%s: malloc buffer failed.\n", "dhash_chip_send_job");
    logMessage(7, logBuffer, 0);
    return -2;
  }
  memcpy(buffer, jobBuffer, bufferSize);
  if ( !byte_482A88 )
  {
    if ( (unsigned int)globalLogLevel > 3 )
    {
      strcpy(logBuffer, "only support asic boost");
      logMessage(3, logBuffer, (unsigned __int8)byte_482A88);
    }
    goto FreeBufferAndExit;
  }
  versionNumber = allocatedBuffer[80];
  currentVersion = versionThreshold;
  if ( allocatedBuffer[80] )
  {
    maskNumber = *((_DWORD *)allocatedBuffer + 22);
    optMultiVersion = *((_DWORD *)allocatedBuffer + 21);
    jobVersion = optMultiVersion;
    jobBitMask = maskNumber;
    if ( optMultiVersion == versionThreshold )
      goto VersionCheck;
  }
  else
  {
    jobVersion = 1;
    optMultiVersion = 1;
    jobBitMask = versionNumber;
    if ( versionThreshold == 1 )
      goto FreeBufferAndExit;
  }
  if ( (unsigned int)globalLogLevel > 3 )
  {
    snprintf(logBuffer, 2048u, "Version num %d\n", jobVersion);
    logMessage(3, logBuffer, 0);
  }
  currentVersion = optMultiVersion;
  versionThreshold = optMultiVersion;
VersionCheck:
  if ( ((currentVersion - 4) & 0xFFFFFFFB) != 0 )
  {
FreeBufferAndExit:
    free(allocatedBuffer);
    return 0;
  }
  globalBitMask = jobBitMask;
  if ( maskThreshold != jobBitMask )
  {
    if ( (unsigned int)globalLogLevel > 3 )
    {
      snprintf(logBuffer, 2048u, "Mask num 0x%x\n", jobBitMask);
      logMessage(3, logBuffer, 0);
      globalBitMask = jobBitMask;
      currentVersion = optMultiVersion;
    }
    maskThreshold = globalBitMask;
    update_miner_frequency(dword_482A6C, currentVersion, 90);
  }
  jobControlByte = allocatedBuffer[9];
  if ( (jobControlByte & 2) != 0 )
  {
    write_and_read_register(allocatedBuffer[10]);
    jobControlByte = allocatedBuffer[9];
  }
  jobDataOffset = *((unsigned __int16 *)allocatedBuffer + 30);
  additionalIndex = dword_99EDDC;
  jobStartIndex = *((_DWORD *)allocatedBuffer + 3);
  additionalData[4] = (int)&jobBuffer[jobDataOffset + 96];
  chipParameter = *((unsigned __int16 *)allocatedBuffer + 33);
  additionalData[8] = jobStartIndex;
  jobEndIndex = *((_DWORD *)allocatedBuffer + 14);
  additionalData[5] = chipParameter;
  chipCommand = *((unsigned __int16 *)allocatedBuffer + 32);
  additionalData[7] = jobEndIndex;
  jobCommandParam = *((unsigned __int16 *)allocatedBuffer + 31);
  additionalChipParam = jobControlByte & 1;
  additionalData[10] = jobBitMask;
  additionalData[14] = chipCommand;
  paramLength = *((_DWORD *)allocatedBuffer + 4);
  additionalData[11] = (int)(allocatedBuffer + 20);
  additionalData[13] = jobCommandParam;
  rollingTime = *((_QWORD *)allocatedBuffer + 9);
  checksum = *((_DWORD *)allocatedBuffer + 13);
  additionalData[1] = optMultiVersion;
  additionalData[3] = jobDataOffset;
  additionalData[2] = (int)(jobBuffer + 96);
  additionalData[9] = paramLength;
  additionalTime = rollingTime;
  additionalData[12] = 32;
  additionalData[6] = checksum;
  additionalData[0] = 0;
  if ( !chipStatusInitialized )
  {
    timestamp = read_chip_id();
    set_and_read_register_value(timestamp | 0x10000);
    anotherParam = read_asic_version();
    set_frequency(anotherParam | 0x80);
    chipStatusInitialized = 1;
  }
  if ( (unsigned int)globalLogLevel > 4 )
  {
    snprintf(logBuffer, 2048u, "start to send job, mid_auto_gen = %d", additionalData[0]);
    logMessage(4, logBuffer, 0);
  }
  sendJobToMiner_0((int)additionalData);
  free(allocatedBuffer);
  if ( logEnabled && (loggingDebug || loggingVerbose || loggingThreshold > 6) )
  {
    snprintf(logBuffer, 2048u, "--- %s end\n", "dhash_chip_send_job");
    logMessage(7, logBuffer, 0);
  }
  convert_timespec_to_custom_format(dword_482A74);
  get_next_sleep_interval();
  return 0;
}
// 7EB58: using guessed type int optMultiVersion;
// 7EB9C: using guessed type int globalLogLevel;
// 7EBA0: using guessed type int loggingThreshold;
// 7EDD8: using guessed type int versionThreshold;
// 7EDDC: using guessed type int maskThreshold;
// 80F98: using guessed type int jobBitMask;
// 482A5C: using guessed type char loggingVerbose;
// 482A5D: using guessed type char logEnabled;
// 482A6C: using guessed type int dword_482A6C;
// 482A74: using guessed type __time_t dword_482A74[3];
// 482A88: using guessed type char byte_482A88;
// 482A89: using guessed type char chipStatusInitialized;
// 590404: using guessed type char loggingDebug;
// 99EDDC: using guessed type int dword_99EDDC;

//----- (0003345C) --------------------------------------------------------
unsigned int configure_and_reboot_miner()
{
  disable_boost_mode_and_sleep();
  set_control_register_and_reboot(15);
  return sleep(2u);
}

//----- (00033478) --------------------------------------------------------
int __fastcall copy_pool_stratum_data(int copy_result, int source)
{
  pthread_mutex_t *mutex_ptr; // r8
  int destination; // r4
  int source_merkle_count; // r7
  size_t coinbase_size; // r5
  void *coinbase_alloc_ptr; // r0
  int merkle_index; // r5
  void *merkle_bin_ptr; // r0
  int source_pool_id_length; // lr
  int source_username_length; // r12
  int unlock_result; // r0
  _DWORD *destination_merkle_array; // r11
  int merkle_copy_index; // r5
  int offset; // r10
  _DWORD *destination_merkle_ptr; // r3
  _DWORD *source_merkle_ptr; // r2
  int merkle_data_1; // r12
  int merkle_data_2; // r0
  int merkle_data_3; // r1
  int merkle_data_5; // r12
  int merkle_data_6; // r0
  int merkle_data_7; // r1
  int *unlock_errno_ptr; // r0
  int *lock_errno_ptr; // r0
  int *wrlock_errno_ptr; // r0
  int *rwunlock_errno_ptr; // r0
  char log_buffer[2088]; // [sp+10h] [bp-828h] BYREF

  if ( *(_DWORD *)(source + 672) )
  {
    mutex_ptr = (pthread_mutex_t *)(copy_result + 212);
    destination = copy_result;
    source_merkle_count = *(_DWORD *)(source + 1708);
    coinbase_size = *(_DWORD *)(source + 1572);
    if ( pthread_mutex_lock((pthread_mutex_t *)(copy_result + 212)) )
    {
      lock_errno_ptr = _errno_location();
      snprintf(
        log_buffer,
        2048u,
        "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
        *lock_errno_ptr,
        "driver-btm-api.c",
        "copy_pool_stratum",
        1140);
      logMessage(3, log_buffer, 1);
      nullsub_1();
    }
    if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(destination + 236)) )
    {
      wrlock_errno_ptr = _errno_location();
      snprintf(
        log_buffer,
        2048u,
        "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
        *wrlock_errno_ptr,
        "driver-btm-api.c",
        "copy_pool_stratum",
        1140);
      logMessage(3, log_buffer, 1);
      nullsub_1();
    }
    free(*(void **)(destination + 672));
    free(*(void **)(destination + 612));
    free(*(void **)(destination + 1568));
    if ( (coinbase_size & 3) != 0 )
      coinbase_size = (coinbase_size & 0xFFFFFFFC) + 4;
    coinbase_alloc_ptr = calloc(coinbase_size, 1u);
    *(_DWORD *)(destination + 1568) = coinbase_alloc_ptr;
    if ( !coinbase_alloc_ptr )
    {
      strcpy(log_buffer, "Failed to calloc pool_stratum coinbase in c5");
      logMessage(3, log_buffer, 1);
      nullsub_1();
      coinbase_alloc_ptr = *(void **)(destination + 1568);
    }
    memcpy(coinbase_alloc_ptr, *(const void **)(source + 1568), coinbase_size);
    if ( *(int *)(destination + 1708) > 0 )
    {
      merkle_index = 0;
      do
      {
        merkle_bin_ptr = *(void **)(*(_DWORD *)(destination + 676) + 4 * merkle_index++);
        free(merkle_bin_ptr);
      }
      while ( *(_DWORD *)(destination + 1708) > merkle_index );
    }
    if ( source_merkle_count )
    {
      destination_merkle_array = realloc(*(void **)(destination + 676), 4 * source_merkle_count + 1);
      *(_DWORD *)(destination + 676) = destination_merkle_array;
      if ( source_merkle_count > 0 )
      {
        merkle_copy_index = 0;
        while ( 1 )
        {
          offset = 4 * merkle_copy_index;
          destination_merkle_array[merkle_copy_index] = malloc(32u);
          destination_merkle_ptr = *(_DWORD **)(*(_DWORD *)(destination + 676) + 4 * merkle_copy_index);
          if ( !destination_merkle_ptr )
          {
            strcpy(log_buffer, "Failed to malloc pool_stratum swork merkle_bin");
            logMessage(3, log_buffer, 1);
            nullsub_1();
            destination_merkle_ptr = *(_DWORD **)(*(_DWORD *)(destination + 676) + 4 * merkle_copy_index);
          }
          ++merkle_copy_index;
          source_merkle_ptr = *(_DWORD **)(*(_DWORD *)(source + 676) + offset);
          merkle_data_1 = source_merkle_ptr[1];
          merkle_data_2 = source_merkle_ptr[2];
          merkle_data_3 = source_merkle_ptr[3];
          *destination_merkle_ptr = *source_merkle_ptr;
          destination_merkle_ptr[1] = merkle_data_1;
          destination_merkle_ptr[2] = merkle_data_2;
          destination_merkle_ptr[3] = merkle_data_3;
          merkle_data_5 = source_merkle_ptr[5];
          merkle_data_6 = source_merkle_ptr[6];
          merkle_data_7 = source_merkle_ptr[7];
          destination_merkle_ptr[4] = source_merkle_ptr[4];
          destination_merkle_ptr[5] = merkle_data_5;
          destination_merkle_ptr[6] = merkle_data_6;
          destination_merkle_ptr[7] = merkle_data_7;
          if ( source_merkle_count == merkle_copy_index )
            break;
          destination_merkle_array = *(_DWORD **)(destination + 676);
        }
      }
    }
    *(_DWORD *)destination = *(_DWORD *)source;
    *(_QWORD *)(destination + 1824) = *(_QWORD *)(source + 1824);
    *(_DWORD *)(destination + 1572) = *(_DWORD *)(source + 1572);
    *(_DWORD *)(destination + 1576) = *(_DWORD *)(source + 1576);
    *(_DWORD *)(destination + 632) = *(_DWORD *)(source + 632);
    *(_DWORD *)(destination + 1708) = *(_DWORD *)(source + 1708);
    *(_DWORD *)(destination + 672) = _strdup(*(const char **)(source + 672));
    *(_DWORD *)(destination + 612) = _strdup(*(const char **)(source + 612));
    source_pool_id_length = *(_DWORD *)(source + 1808);
    source_username_length = *(_DWORD *)(source + 1812);
    *(_DWORD *)(destination + 1804) = *(_DWORD *)(source + 1804);
    *(_DWORD *)(destination + 1808) = source_pool_id_length;
    *(_DWORD *)(destination + 1812) = source_username_length;
    memcpy((void *)(destination + 1580), (const void *)(source + 1580), 128u);
    if ( pthread_rwlock_unlock((pthread_rwlock_t *)(destination + 236)) )
    {
      rwunlock_errno_ptr = _errno_location();
      snprintf(
        log_buffer,
        2048u,
        "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *rwunlock_errno_ptr,
        "driver-btm-api.c",
        "copy_pool_stratum",
        1178);
      logMessage(3, log_buffer, 1);
      nullsub_1();
    }
    unlock_result = pthread_mutex_unlock(mutex_ptr);
    if ( unlock_result )
    {
      unlock_errno_ptr = _errno_location();
      snprintf(
        log_buffer,
        2048u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *unlock_errno_ptr,
        "driver-btm-api.c",
        "copy_pool_stratum",
        1178);
      logMessage(3, log_buffer, 1);
      nullsub_1();
    }
    return off_7ECC4(unlock_result);
  }
  return copy_result;
}
// 335F8: variable 'unlock_result' is possibly undefined
// 7ECC4: using guessed type int (__fastcall *off_7ECC4)(_DWORD);

//----- (0003388C) --------------------------------------------------------
int configurePulseAndDelays()
{
  char logBuffer; // [sp+8h] [bp-810h] BYREF

  BYTE2(pulseModeConfig) = ccdlySel;
  BYTE1(pulseModeConfig) = pwthSel;
  if ( (unsigned int)globalLogLevel > 3 )
  {
    snprintf(
      &logBuffer,
      2048u,
      "pulse_mode = %d, ccdly_sel = %d, pwth_sel = %d\n",
      (unsigned __int8)pulseModeConfig,
      (unsigned __int8)ccdlySel,
      (unsigned __int8)pwthSel);
    logMessage(3, &logBuffer, 0);
  }
  return (unsigned __int8)pulseModeConfig | (unsigned __int16)(BYTE1(pulseModeConfig) << 8) | (BYTE2(pulseModeConfig) << 16);
}
// 7EB9C: using guessed type int globalLogLevel;
// 7EDE0: using guessed type void *pulseModeConfig;
// 80FA8: using guessed type int pwthSel;
// 80FAC: using guessed type int ccdlySel;

//----- (00033950) --------------------------------------------------------
int update_and_process_miner_status()
{
  int combined_config_data; // r0
  __int16 pulse_delay_setting; // [sp+4h] [bp-Ch]
  char frequency_setting; // [sp+6h] [bp-Ah]

  combined_config_data = configurePulseAndDelays();
  frequency_setting = BYTE2(combined_config_data);
  pulse_delay_setting = combined_config_data;
  check_global_buffer_and_reset();
  get_next_sleep_interval();
  log_and_process_commands();
  get_next_sleep_interval();
  process_buffer(255, pulse_delay_setting);
  get_next_sleep_interval();
  process_command_for_global_buffer(255, SHIBYTE(pulse_delay_setting), frequency_setting, 0);
  get_next_sleep_interval();
  check_global_buffer_and_process(255u);
  get_next_sleep_interval();
  update_miner_config(255, 0, 1, 3);
  return process_miner_status(255);
}

//----- (000339EC) --------------------------------------------------------
int initializeMiner()
{
  unsigned int logLevel; // r2
  int operationStatus; // r5
  int chainCount; // r0
  int i; // r6
  int chainIndex; // r0
  unsigned int chainId; // r7
  char logBuffer[2072]; // [sp+8h] [bp-818h] BYREF

  logLevel = globalLogLevel;
  minerOperationMode = 2;
  isSerialNumberValid = 1;
  if ( (unsigned int)globalLogLevel <= 3
    || (log_fix_freq_version(), logLevel = globalLogLevel, (unsigned int)globalLogLevel <= 3) )
  {
    if ( serialNumber )
      goto LABEL_3;
  }
  else
  {
    snprintf(logBuffer, 2048u, "Miner compile time: %s type: %s\n", minerVersion, minerType);
    logMessage(3, logBuffer, 0);
    logLevel = globalLogLevel;
    if ( serialNumber )
    {
      if ( (unsigned int)globalLogLevel <= 3 )
        goto LABEL_3;
      snprintf(logBuffer, 2048u, "Miner sn: %s\n", &serialNumber);
      logMessage(3, logBuffer, 0);
      logLevel = globalLogLevel;
    }
  }
  if ( logLevel > 3 )
  {
    strcpy(logBuffer, "commit version: dd076742 2022-10-27 22:42:25, build by: jenkins 2022-12-06 16:28:38\n");
    logMessage(3, logBuffer, 0);
    if ( (unsigned int)globalLogLevel > 3 )
    {
      snprintf(logBuffer, 2048u, "opt_multi_version     = %d\n", optMultiVersion);
      logMessage(3, logBuffer, 0);
      if ( (unsigned int)globalLogLevel > 3 )
      {
        snprintf(logBuffer, 2048u, "opt_bitmain_ab        = %d\n", (unsigned __int8)optBitmainAB);
        logMessage(3, logBuffer, 0);
        if ( (unsigned int)globalLogLevel > 3 )
        {
          snprintf(logBuffer, 2048u, "mid_auto_gen          = %d\n", 0);
          logMessage(3, logBuffer, 0);
          if ( (unsigned int)globalLogLevel > 3 )
          {
            snprintf(logBuffer, 2048u, "opt_bitmain_work_mode = %d\n", optBitmainWorkMode);
            logMessage(3, logBuffer, 0);
            if ( sub_3FD74() )
              return 0;
            goto LABEL_16;
          }
        }
      }
    }
  }
LABEL_3:
  if ( sub_3FD74() )
    return 0;
LABEL_16:
  checkFrontFanStatus();
  turnOnRearFan();
  enable_gpio_control();
  configure_fan_control_gpio();
  optBitmainAB = 1;
  initialize_serial_number_and_command_processor();
  startHttpLog();
  if ( sub_1B4AC() )
    return 0;
  configure_and_reboot_miner();
  setFanPWM(100);
  getFirmwareVersionAndMinerID();
  initialize_miner_configuration();
  initialize_and_log_chain_status();
  if ( get_status_flag() )
  {
    if ( loggingDebug || loggingVerbose || loggingThreshold > 4 )
    {
      chainCount = get_status_flag();
      snprintf(logBuffer, 2048u, "chain num = %d", chainCount);
      logMessage(5, logBuffer, 0);
    }
    for ( i = 0; i != 4; ++i )
    {
      chainIndex = i;
      chainId = (unsigned __int8)i;
      if ( get_global_buffer_value(chainIndex) )
        forward_to_hardware_initialization(chainId);
    }
    check_and_initialize_chain_config();
    if ( get_global_chain_config_byte() )
      goto CHECK_CHAIN_ERROR;
    if ( minerOperationMode != 1 )
    {
      generate_error_message(3, 255);
      if ( (unsigned int)globalLogLevel > 3 )
      {
FAILURE_LOAD_FIXTURE:
        strcpy(logBuffer, "Fixture data load failed, exit.\n");
        logMessage(3, logBuffer, 0);
      }
CHECK_CHAIN_ERROR:
      operationStatus = minerOperationMode;
      if ( !minerOperationMode && check_sweep_done() && !check_all_chains_ready() && (unsigned int)globalLogLevel > 3 )
      {
        strcpy(logBuffer, "Miner data load failed, exit.\n");
        logMessage(3, logBuffer, 0);
        return operationStatus;
      }
      return 0;
    }
    if ( (unsigned int)globalLogLevel > 3 )
      goto FAILURE_LOAD_FIXTURE;
    return 0;
  }
  operationStatus = -1;
  if ( (unsigned int)globalLogLevel > 3 )
  {
    strcpy(logBuffer, "No chain exist, exit.\n");
    logMessage(3, logBuffer, 0);
  }
  return operationStatus;
}
// 7EB58: using guessed type int optMultiVersion;
// 7EB5C: using guessed type char optBitmainAB;
// 7EB9C: using guessed type int globalLogLevel;
// 7EBA0: using guessed type int loggingThreshold;
// 7EDC8: using guessed type int minerOperationMode;
// 80FB4: using guessed type int optBitmainWorkMode;
// 482A5C: using guessed type char loggingVerbose;
// 482A71: using guessed type char isSerialNumberValid;
// 590404: using guessed type char loggingDebug;

//----- (00033E34) --------------------------------------------------------
int InitializeMinerHardware()
{
  int status; // r4
  int voltage; // r0
  int minTemp; // r0
  const char *hwVersion; // r0
  char logBuffer[2064]; // [sp+0h] [bp-810h] BYREF

  logChainVersions();
  configure_antminer_protection();
  status = checkFanStatus(4000u, 1);
  if ( status )
    return status;
  if ( (unsigned int)globalLogLevel > 3 )
  {
    strcpy(logBuffer, "Fan check passed.\n");
    logMessage(3, logBuffer, 0);
    status = check_chip_states();
    if ( !status )
      goto LABEL_4;
  }
  else
  {
    status = check_chip_states();
    if ( !status )
      goto LABEL_4;
  }
  if ( !get_status_flag() || !minerOperationMode )
    return status;
LABEL_4:
  initialize_asic_monitor_thread();
  initTemperatureMonitoring();
  if ( byte_7EB79 )
  {
    hwVersion = (const char *)get_shared_variable();
    if ( !strcmp(hwVersion, "BHB28601") )
      voltage = 1900;
    else
      voltage = 1500;
LABEL_18:
    status = ValidatePowerVoltage(voltage);
    if ( status )
    {
      generate_error_message(12, 0);
      handle_error_with_logging(9u, "get power type version failed!");
      return status;
    }
    goto LABEL_6;
  }
  voltage = dword_482A8C;
  if ( dword_482A8C > 0 )
    goto LABEL_18;
LABEL_6:
  if ( (unsigned int)globalLogLevel > 3 )
  {
    minTemp = get_minimum_temp();
    snprintf(logBuffer, 2048u, "start up min temp by 75a = %d", minTemp);
    logMessage(3, logBuffer, 0);
  }
  enable_feature_flag();
  disable_asic_boost();
  disable_register_bit();
  get_next_sleep_interval();
  setUartBaudRate(115200);
  get_next_sleep_interval();
  status = InitializeChains();
  if ( !status || get_status_flag() && minerOperationMode )
  {
    update_and_process_miner_status();
    status = 0;
    dword_7F8D4 = 0;
    dword_7F8DC = 0;
    dword_7F8D8 = 0;
  }
  return status;
}
// 7EB79: using guessed type char byte_7EB79;
// 7EB9C: using guessed type int globalLogLevel;
// 7EDC8: using guessed type int minerOperationMode;
// 7F8D4: using guessed type int dword_7F8D4;
// 7F8D8: using guessed type int dword_7F8D8;
// 7F8DC: using guessed type int dword_7F8DC;
// 482A8C: using guessed type int dword_482A8C;

//----- (0003403C) --------------------------------------------------------
void InitializeASICChains()
{
  int v0; // r11
  int v1; // r0
  int *v2; // r10
  int v3; // r9
  char *v4; // r11
  int v5; // r0
  pthread_mutex_t *v6; // r8
  int v7; // r3
  int v8; // r7
  int v9; // r5
  int v10; // r4
  unsigned int v11; // r4
  bool v12; // cc
  int *v13; // r4
  int v14; // r6
  int v15; // r11
  int v16; // r0
  int v17; // r0
  int v18; // r8
  int v19; // r6
  int v20; // r0
  char v22; // r8
  int v23; // r11
  int v24; // r10
  int miner_status_flag; // r7
  int v26; // r3
  int v27; // r5
  unsigned __int16 *v28; // r4
  int v29; // r6
  int v30; // r8
  int v31; // r0
  int v32; // r0
  int v33; // r0
  int v34; // r0
  int v35; // r0
  int v36; // r0
  int v37; // r0
  int v38; // r0
  int v39; // r5
  int v40; // r8
  int v41; // [sp+10h] [bp-880h]
  char *format; // [sp+20h] [bp-870h]
  pthread_mutex_t *v43; // [sp+24h] [bp-86Ch]
  int v44; // [sp+24h] [bp-86Ch]
  int v45; // [sp+2Ch] [bp-864h]
  int *v46; // [sp+2Ch] [bp-864h]
  int global_variable_value; // [sp+30h] [bp-860h]
  int v48; // [sp+34h] [bp-85Ch]
  int v49; // [sp+44h] [bp-84Ch]
  _WORD *s; // [sp+48h] [bp-848h]
  __int16 v51; // [sp+54h] [bp-83Ch]
  char v52; // [sp+56h] [bp-83Ah]
  int v53[2]; // [sp+58h] [bp-838h] BYREF
  char v54[2096]; // [sp+60h] [bp-830h] BYREF

  v0 = 0;
  v48 = 0;
  v1 = configurePulseAndDelays();
  v51 = v1;
  v52 = BYTE2(v1);
  initialize_miner_status();
  do
  {
    if ( !get_global_buffer_value(v0) )
      goto LABEL_3;
    v2 = dword_5945B8;
    v3 = v0;
    s = &word_59CD98[524288 * v0];
    v49 = 0;
    process_command(v0, 1, 0, (unsigned __int8)byte_482A70);
    while ( 1 )
    {
      byte_8110C = 1;
      reset_statistics();
      memset(s, 0, 1048576u);
      global_variable_value = get_global_variable_value();
      if ( global_variable_value > 0 )
      {
        v4 = v54;
        v45 = 0;
        do
        {
          v5 = sub_1E160();
          v6 = &stru_810DC;
          initialize_miner_with_delay((unsigned __int8)v3, v45 * v5);
          convert_timespec_to_custom_format(v53);
          do
          {
            pthread_mutex_lock(v6);
            v7 = v2[2];
            v8 = v7;
            if ( v7 > 0 )
            {
              v9 = 0;
              format = v4;
              v43 = v6;
              while ( 1 )
              {
                v10 = v2[1];
                ++v9;
                v2[2] = v7 - 1;
                v11 = v10 + 1;
                v12 = v11 > 510;
                if ( v11 <= 510 )
                  v2[1] = v11;
                v13 = &v2[2 * v11];
                if ( v12 )
                  v2[1] = 0;
                if ( *((unsigned __int8 *)v13 + 11) == v3 && *((_BYTE *)v13 + 10) == 64 )
                {
                  v14 = *((unsigned __int8 *)v13 + 9);
                  v15 = v13[1];
                  v16 = sub_1E160();
                  v17 = call_external_function_with_check(v14, v16);
                  v18 = *((unsigned __int8 *)v13 + 9);
                  v19 = *((_BYTE *)v13 + 11) & 3;
                  word_59CD98[524288 * (v3 & 3) + 1 + 2048 * v17 + 2 * (*((_WORD *)v13 + 3) & 0x3FF)] = v15;
                  v20 = sub_1E160();
                  word_59CD98[2048 * (call_external_function_with_check(v18, v20) + (v19 << 8))
                            + 2 * (*((_WORD *)v13 + 3) & 0x3FF)] = 1;
                }
                if ( v8 == v9 )
                  break;
                v7 = v2[2];
              }
              v4 = format;
              v6 = v43;
            }
            pthread_mutex_unlock(v6);
            usleep(1000u);
            convert_timespec_to_custom_format((__time_t *)v4);
          }
          while ( (int)get_time_difference(v4, v53) <= 99 );
        }
        while ( global_variable_value != ++v45 );
      }
      v44 = get_global_variable_value();
      if ( v44 <= 0 )
        break;
      v22 = 0;
      v46 = v2;
      v23 = 0;
      v24 = 0;
      do
      {
        miner_status_flag = get_miner_status_flag();
        if ( miner_status_flag > 0 )
        {
          v26 = 0;
          v27 = 0;
          v28 = &word_59CD98[2048 * (v23 + v48)];
          do
          {
            v29 = v28[1];
            if ( !v28[1] )
            {
              v30 = *v28;
              if ( *v28 )
              {
                if ( (unsigned int)globalLogLevel > 3 )
                {
                  snprintf(v54, 2048u, "core %8d data in asic %d is zero", v27, v23);
                  logMessage(3, v54, v29);
                }
              }
              else if ( (unsigned int)globalLogLevel > 3 )
              {
                snprintf(v54, 2048u, "core %8d in asic %d not returned", v27, v23);
                logMessage(3, v54, v30);
              }
              v26 = 1;
              ++v24;
              v22 = 1;
            }
            ++v27;
            v28 += 2;
          }
          while ( miner_status_flag != v27 );
          if ( v26 )
          {
            if ( (unsigned int)globalLogLevel > 3 )
            {
              snprintf(v54, 2048u, "reopen asic %d", v23);
              logMessage(3, v54, 0);
            }
            v31 = sub_1E160();
            configure_asic_hashrate((unsigned __int8)v3, v23 * v31, 1);
            usleep(10000u);
            v32 = sub_1E160();
            configure_asic_hashrate((unsigned __int8)v3, v23 * v32, 0);
            usleep(10000u);
            v33 = sub_1E160();
            initialize_mining_task((unsigned __int8)v3, v23 * v33, v51, 0);
            get_next_sleep_interval();
            v34 = sub_1E160();
            initialize_miner_with_defaults((unsigned __int8)v3, v23 * v34, SHIBYTE(v51), v52, 0);
            v35 = sub_1E160();
            initialize_miner_frequency_voltage((unsigned __int8)v3, v23 * v35);
            usleep(10000u);
            if ( (unsigned int)globalLogLevel > 3 )
            {
              snprintf(v54, 2048u, "reset clock asic %d", v23);
              logMessage(3, v54, 0);
            }
            v36 = sub_1E160();
            initialize_asic_with_frequency((unsigned __int8)v3, v23 * v36, 0);
            v37 = sub_1E160();
            init_asic_mining_with_params((unsigned __int8)v3, v23 * v37);
            usleep(100000u);
            v38 = sub_1E160();
            initialize_asic_with_frequency((unsigned __int8)v3, v23 * v38, 1);
          }
        }
        ++v23;
      }
      while ( v44 != v23 );
      v39 = v24;
      v2 = v46;
      if ( (unsigned int)globalLogLevel > 3 )
        goto LABEL_55;
LABEL_44:
      if ( v39 <= 155 )
      {
        v0 = v3;
        goto LABEL_51;
      }
      usleep((__useconds_t)&unk_F4240);
      if ( v49 <= 1 )
        v40 = v22 & 1;
      else
        v40 = 0;
      if ( !v40 )
      {
        v0 = v3;
        goto LABEL_3;
      }
    }
    if ( (unsigned int)globalLogLevel > 3 )
    {
      v39 = 0;
      v22 = 0;
LABEL_55:
      v41 = v49++;
      snprintf(
        v54,
        2048u,
        "chain %d, bad core num %8d, rate = %.2f ========================round %d",
        v3,
        v39,
        (float)((float)v39 / 12168.0),
        v41);
      logMessage(3, v54, 0);
      goto LABEL_44;
    }
    v0 = v3;
    v39 = 0;
LABEL_51:
    if ( (unsigned int)globalLogLevel > 3 )
    {
      snprintf(v54, 2048u, "bad count is acceptable = %d", v39);
      logMessage(3, v54, 0);
    }
    usleep((__useconds_t)&unk_F4240);
LABEL_3:
    ++v0;
    v48 += 256;
  }
  while ( v0 != 4 );
  byte_8110C = 0;
  reset_global_counter();
}
// 7EB9C: using guessed type int globalLogLevel;
// 810DC: using guessed type pthread_mutex_t stru_810DC;
// 8110C: using guessed type char byte_8110C;
// 482A70: using guessed type char byte_482A70;
// 5945B8: using guessed type int dword_5945B8[];
// 59CD98: using guessed type _WORD word_59CD98[57332];
// 3403C: using guessed type __time_t var_838[2];

//----- (00034680) --------------------------------------------------------
int perform_soft_open_core()
{
  int core_index; // r4
  int operation_result; // r0
  char log_message_buffer[2072]; // [sp+0h] [bp-818h] BYREF

  if ( (unsigned int)globalLogLevel > 3 )
  {
    strcpy(log_message_buffer, "soft open core");
    logMessage(3, log_message_buffer, 0);
  }
  for ( core_index = 0; core_index != 4; ++core_index )
  {
    operation_result = get_global_buffer_value(core_index);
    if ( operation_result )
    {
      set_asic_mining_mode((unsigned __int8)core_index, 1);
      usleep((__useconds_t)&loc_30D40);
      set_asic_mining_mode((unsigned __int8)core_index, 0);
      usleep((__useconds_t)"version array failed\n");
      initialize_miner_with_default_config((unsigned __int8)core_index);
      operation_result = usleep((__useconds_t)&loc_30D40);
    }
  }
  return operation_result;
}
// 7EB9C: using guessed type int globalLogLevel;

//----- (00034818) --------------------------------------------------------
unsigned int get_temperature_sensor_type()
{
  return handle_error_with_logging(14u, "Can't get temperature sensor type!");
}

//----- (00034828) --------------------------------------------------------
int __fastcall initializeMinerHardware(
        int tokenType,
        int tokenParam1,
        int tokenParam2,
        int tokenParam3,
        int tokenParam4,
        int tokenParam5,
        int tokenParam6,
        int tokenParam7)
{
  int crcResult; // r0
  int boardIndex; // r5
  int hardwareInitStatus; // r8
  int bcrcCalculated; // r0
  unsigned int frequency; // r7
  signed int voltageCalculated; // r0
  unsigned int minFrequency; // r3
  int finalVoltage; // r3
  int eepromReadResult; // r0
  unsigned __int8 temperatureSensorType; // r0
  unsigned int bringUpTemperature; // r5
  int temperatureSensorStatus; // r0
  int pwmValue; // r10
  unsigned int bitIndex; // r6
  _QWORD *hashBoardPointer; // r11
  int optimalVoltage; // r7
  int socTypeResult; // r0
  int socTypeId; // r1
  int socTypeIdDuplicate; // r1
  int hardwareTypeAdjustedVoltage; // r6
  const char *hardwareName; // r0
  float voltageAdjustmentFactor; // s15
  int v31; // r3
  int v32; // r2
  __int64 adcVoltageCalculation; // r0
  int i; // r5
  int v35; // r0
  unsigned int minEepromFrequency; // r6
  int v37; // r0
  int finalFrequencyAdjust; // r0
  int tempSensorCalibration; // r0
  int voltageAdjustment; // r3
  int newVoltage; // r0
  int adjustedVoltage; // r6
  int optimalFrequency; // r8
  const char *socName; // r0
  const char *socNameDuplicate1; // r0
  const char *socNameDuplicate2; // r0
  float voltageAdjustmentFactorDuplicate; // s15
  int newVoltageDuplicate; // r2
  unsigned int minEepromFrequencyDuplicate; // r6
  int voltageAdjustedForTemperature; // r2
  int finalVoltageAdjusted; // r7
  const char *hardwareType; // r0
  unsigned int crcCalculationContext; // [sp+14h] [bp-85Ch] BYREF
  int TokenType; // [sp+18h] [bp-858h]
  int TokenParam1; // [sp+1Ch] [bp-854h]
  int TokenParam2; // [sp+20h] [bp-850h]
  int TokenParam3; // [sp+24h] [bp-84Ch]
  int TokenParam4; // [sp+28h] [bp-848h]
  int TokenParam5; // [sp+2Ch] [bp-844h]
  int TokenParam6; // [sp+30h] [bp-840h]
  int TokenParam7; // [sp+34h] [bp-83Ch]
  char s[2088]; // [sp+38h] [bp-838h] BYREF
  int tokenTypeBuffer; // [sp+860h] [bp-10h]
  int tokenParam1Buffer; // [sp+864h] [bp-Ch]
  int tokenParam2Buffer; // [sp+868h] [bp-8h]
  int tokenParam3Buffer; // [sp+86Ch] [bp-4h]

  tokenTypeBuffer = tokenType;
  tokenParam1Buffer = tokenParam1;
  tokenParam2Buffer = tokenParam2;
  tokenParam3Buffer = tokenParam3;
  TokenType = tokenType;
  TokenParam1 = tokenParam1;
  TokenParam2 = tokenParam2;
  TokenParam3 = tokenParam3;
  TokenParam4 = tokenParam4;
  TokenParam5 = tokenParam5;
  TokenParam6 = tokenParam6;
  TokenParam7 = tokenParam7;
  *(_DWORD *)&globalTokenBuffer = tokenType;
  *(_DWORD *)&globalTokenBuffer1 = tokenParam1;
  globalTokenParam2Buffer = tokenParam2;
  *(_DWORD *)&globalTokenParam3Buffer = tokenParam3;
  globalTokenParam4Buffer = tokenParam4;
  globalTokenParam5Buffer = tokenParam5;
  globalTokenParam6Buffer = tokenParam6;
  globalTokenParam7Buffer = tokenParam7;
  if ( (unsigned __int8)tokenType != 81 )
  {
    if ( (unsigned int)globalLogLevel <= 4 )
      return 0;
    snprintf(s, 2048u, "config_parameter.token_type != 0x%x, it is 0x%x\n", 81, (unsigned __int8)TokenType);
LABEL_5:
    logMessage(4, s, 0);
    return 0;
  }
  crcResult = calculate_crc16_checksum((int)&globalTokenBuffer, 30);
  if ( crcResult != (unsigned __int16)word_99EDD6 )
  {
    if ( (unsigned int)globalLogLevel <= 4 )
      return 0;
    snprintf(
      s,
      2048u,
      "config_parameter.crc = 0x%x, but we calculate it as 0x%x\n",
      (unsigned __int16)word_99EDD6,
      crcResult);
    goto LABEL_5;
  }
  if ( (unsigned int)globalLogLevel > 3 )
  {
    snprintf(
      s,
      2048u,
      "fan_eft : %d  fan_pwm : %d\n",
      ((unsigned __int8)globalTokenBuffer1 >> 1) & 1,
      (unsigned __int8)byte_99EDC2);
    logMessage(3, s, 0);
  }
  boardIndex = minerOperationMode;
  if ( !minerOperationMode )
  {
    hardwareInitStatus = (unsigned __int8)initialize_sweep(161);
    do
    {
      bcrcCalculated = boardIndex;
      frequency = (unsigned __int8)boardIndex++;
      if ( get_global_buffer_value(bcrcCalculated) )
        forward_to_hardware_initialization(frequency);
    }
    while ( boardIndex != 4 );
    if ( hardwareInitStatus )
      return 0;
  }
  if ( (unsigned __int8)initialize_nonce_registration_thread() )
    return 0;
  if ( isSerialNumberValid && (globalTokenBuffer1 & 0x10) != 0 )
  {
    dword_482A8C = (unsigned __int16)word_99EDC6;
    dword_482A8C = get_max_voltage_from_eeprom();
LABEL_22:
    if ( (unsigned int)globalLogLevel > 3 )
    {
      snprintf(s, 2048u, "fixed working voltage = %d\n", dword_482A8C);
      logMessage(3, s, 0);
    }
    goto LABEL_24;
  }
  voltageCalculated = get_max_voltage_from_eeprom();
  if ( voltageCalculated > 0 )
  {
    dword_482A8C = voltageCalculated;
    goto LABEL_22;
  }
  if ( (_BYTE)voltageCalculated )
    return 0;
LABEL_24:
  if ( (unsigned __int8)InitializeMinerHardware() )
    return 0;
  if ( isSerialNumberValid && (globalTokenBuffer1 & 8) != 0 )
  {
    adjustedVoltage = 0;
    optimalFrequency = 0;
    dword_482A6C = (unsigned __int16)globalTokenParam3Buffer;
    do
    {
      if ( get_global_buffer_value(optimalFrequency)
        && !setOptimalFrequency(optimalFrequency, (unsigned __int8)optBitmainWorkMode, (int *)&crcCalculationContext) )
      {
        if ( adjustedVoltage )
        {
          if ( adjustedVoltage >= crcCalculationContext )
            adjustedVoltage = crcCalculationContext;
        }
        else
        {
          adjustedVoltage = crcCalculationContext;
        }
      }
      ++optimalFrequency;
    }
    while ( optimalFrequency != 4 );
    minFrequency = globalLogLevel;
    if ( (unsigned int)globalLogLevel > 3 )
    {
      snprintf(s, 2048u, "min freq in eeprom = %d\n", adjustedVoltage);
      logMessage(3, s, 0);
      minFrequency = globalLogLevel;
    }
    if ( adjustedVoltage && adjustedVoltage > 0 )
    {
      dword_482A6C = adjustedVoltage;
    }
    else
    {
      if ( minFrequency > 3 )
      {
        strcpy(s, "failed to load freq in eeprom, using default");
        logMessage(3, s, 0);
      }
      minFrequency = globalLogLevel;
      dword_482A6C = 200;
    }
  }
  else
  {
    minFrequency = globalLogLevel;
    dword_482A6C = 200;
  }
  if ( minFrequency > 3 )
  {
    snprintf(s, 2048u, "fixed frequency is %d\n", dword_482A6C);
    logMessage(3, s, 0);
  }
  finalVoltage = optBitmainWorkMode;
  if ( optBitmainWorkMode == 3 )
  {
    hardwareTypeAdjustedVoltage = dword_482A8C;
    hardwareName = (const char *)get_shared_variable();
    if ( !strcmp(hardwareName, "NBS1902")
      || (socName = (const char *)get_shared_variable(), !strcmp(socName, "NBS1902L"))
      || (socNameDuplicate1 = (const char *)get_shared_variable(), !strcmp(socNameDuplicate1, "NBT1903")) )
    {
      voltageAdjustmentFactor = (float)dword_482A8C * 0.91;
      if ( voltageAdjustmentFactor < 1200.0 )
        v31 = 1200;
      else
        v31 = (int)voltageAdjustmentFactor;
      v32 = (hardwareTypeAdjustedVoltage - v31) >> 31;
      adcVoltageCalculation = 1717986919LL * (hardwareTypeAdjustedVoltage - v31);
      dword_482A8C = v31;
      finalVoltage = optBitmainWorkMode;
      dword_482A6C = (unsigned int)((double)(unsigned int)dword_482A6C
                                  - (double)((SHIDWORD(adcVoltageCalculation) >> 2) - v32) * 12.5);
    }
    else
    {
      socNameDuplicate2 = (const char *)get_shared_variable();
      if ( !strcmp(socNameDuplicate2, "NBP1901")
        || (hardwareType = (const char *)get_shared_variable(), !strcmp(hardwareType, "NBP1901L")) )
      {
        voltageAdjustmentFactorDuplicate = (float)dword_482A8C * 0.91;
        if ( voltageAdjustmentFactorDuplicate >= 1200.0 )
          newVoltageDuplicate = (int)voltageAdjustmentFactorDuplicate;
        else
          newVoltageDuplicate = 1200;
        dword_482A8C = newVoltageDuplicate;
        finalVoltage = optBitmainWorkMode;
        dword_482A6C -= 10 * ((hardwareTypeAdjustedVoltage - newVoltageDuplicate) / 10);
      }
      else
      {
        finalVoltage = optBitmainWorkMode;
      }
    }
  }
  if ( finalVoltage == 1 || dword_482A8C <= 0 )
  {
    wait_one_second();
    setFanPWM(0);
    get_next_sleep_interval();
  }
  else
  {
    temperatureSensorStatus = sub_1E160();
    if ( (unsigned __int8)calibrateTemperatureSensors(temperatureSensorStatus) )
    {
      update_miner_status_led(1);
      handle_error_with_logging(14u, "Can't get temperature sensor type!");
    }
    else
    {
      update_miner_status_led(0);
    }
  }
  eepromReadResult = get_minimum_temp();
  dword_99EDD8 = eepromReadResult;
  if ( (unsigned int)globalLogLevel > 3 )
  {
    snprintf(s, 2048u, "Bring up temperature is %d\n", eepromReadResult);
    logMessage(3, s, 0);
    if ( !byte_80FB0 )
      goto LABEL_36;
    if ( (unsigned int)globalLogLevel > 3 )
    {
      strcpy(s, "press any key to start rising frequency...");
      logMessage(3, s, 0);
    }
  }
  else if ( !byte_80FB0 )
  {
    goto LABEL_36;
  }
  IO_getc((_IO_FILE *)stdin);
LABEL_36:
  pthread_mutex_lock(&stru_7F7EC);
  setUartBaudRate(12000000);
  pthread_mutex_unlock(&stru_7F7EC);
  if ( byte_7EB79 )
  {
    if ( dword_482A8C > 0 && get_global_flag() != dword_482A8C )
    {
      tempSensorCalibration = get_minimum_temp();
      if ( tempSensorCalibration <= 19 )
        voltageAdjustment = byte_7EB78 & 1;
      else
        voltageAdjustment = 0;
      if ( voltageAdjustment )
      {
        minEepromFrequencyDuplicate = 100;
        voltageAdjustedForTemperature = 100 * (20 - tempSensorCalibration);
        if ( voltageAdjustedForTemperature < 4000 )
          minEepromFrequencyDuplicate = voltageAdjustedForTemperature / 40u;
        finalVoltageAdjusted = minEepromFrequencyDuplicate + dword_482A8C;
        if ( finalVoltageAdjusted > calculate_percentage() )
          newVoltage = calculate_percentage();
        else
          newVoltage = minEepromFrequencyDuplicate + dword_482A8C;
      }
      else
      {
        newVoltage = dword_482A8C;
      }
      SetVoltageBySteps(newVoltage);
      get_next_sleep_interval();
    }
  }
  else
  {
    InitializeASICChains();
  }
  get_next_sleep_interval();
  if ( get_global_value() == 2 )
  {
    for ( i = 0; i != 4; ++i )
    {
      v35 = i;
      minEepromFrequency = (unsigned __int8)i;
      if ( get_global_buffer_value(v35) )
      {
        v37 = sub_1E160();
        set_register_bit(minEepromFrequency, 19 * v37, 0);
        finalFrequencyAdjust = sub_1E160();
        set_register_bit(minEepromFrequency, 55 * finalFrequencyAdjust, 0);
      }
    }
  }
  handle_error_with_logging(1u, "soc init done!");
  temperatureSensorType = init_monitor_thread();
  bringUpTemperature = temperatureSensorType;
  if ( temperatureSensorType )
    return 0;
  do
  {
    if ( get_global_buffer_value(bringUpTemperature) )
    {
      pwmValue = 0;
      bitIndex = 0;
      for ( hashBoardPointer = &qword_99CD98[256 * bringUpTemperature]; ; ++hashBoardPointer )
      {
        optimalVoltage = bitIndex + pwmValue;
        if ( bitIndex >= get_chain_data_status(bringUpTemperature) )
          break;
        socTypeResult = get_global_value();
        calculate_difficulty_ratio(bitIndex, socTypeResult);
        if ( !socTypeId )
        {
          ++pwmValue;
          socTypeIdDuplicate = optimalVoltage;
          optimalVoltage = bitIndex + pwmValue;
          set_chain_config_byte(bringUpTemperature, socTypeIdDuplicate, 32);
        }
        ++bitIndex;
        set_chain_config_byte(bringUpTemperature, optimalVoltage, 111);
        *hashBoardPointer = 0LL;
      }
      set_chain_config_byte(bringUpTemperature, bitIndex + pwmValue, 111);
    }
    ++bringUpTemperature;
  }
  while ( bringUpTemperature != 4 );
  if ( (unsigned __int8)initialize_monitor_thread() )
    return 0;
  if ( byte_80FA4 )
    initialize_miner_thread();
  wait_for_semaphore();
  update_chip_frequencies();
  get_next_sleep_interval();
  if ( (unsigned int)globalLogLevel > 3 )
  {
    strcpy(s, "Init done!\n");
    logMessage(3, s, 0);
  }
  return 1;
}
// 34D54: variable 'socTypeId' is possibly undefined
// 7EB78: using guessed type char byte_7EB78;
// 7EB79: using guessed type char byte_7EB79;
// 7EB9C: using guessed type int globalLogLevel;
// 7EDC8: using guessed type int minerOperationMode;
// 7F798: using guessed type int stdin;
// 7F7EC: using guessed type pthread_mutex_t stru_7F7EC;
// 80FA4: using guessed type char byte_80FA4;
// 80FB0: using guessed type char byte_80FB0;
// 80FB4: using guessed type int optBitmainWorkMode;
// 482A6C: using guessed type int dword_482A6C;
// 482A71: using guessed type char isSerialNumberValid;
// 482A8C: using guessed type int dword_482A8C;
// 99CD98: using guessed type _QWORD qword_99CD98[1024];
// 99EDB8: using guessed type char globalTokenBuffer;
// 99EDBC: using guessed type char globalTokenBuffer1;
// 99EDC2: using guessed type char byte_99EDC2;
// 99EDC4: using guessed type __int16 globalTokenParam3Buffer;
// 99EDC6: using guessed type __int16 word_99EDC6;
// 99EDD6: using guessed type __int16 word_99EDD6;
// 99EDD8: using guessed type int dword_99EDD8;

//----- (000350E8) --------------------------------------------------------
int AdjustMinerVoltage()
{
  unsigned __int16 currentVoltage; // r0
  int voltageDiff; // r5
  int recentVoltageDiff; // r7
  int initVoltage; // r0
  int adjustedVoltage; // r8
  int voltageOffset; // r2
  int targetVoltage; // r7
  int incrementStep; // r0
  int voltageDifference; // r3
  int finalVoltageAdjustment; // r10
  bool voltageCheck; // cc
  int newTargetVoltage; // r7
  const char *chipModel; // r0
  int absVoltageDifference; // r12
  char logBuffer[2080]; // [sp+10h] [bp-820h] BYREF

  currentVoltage = get_minimum_temp();
  voltageDiff = (__int16)(currentVoltage - 10);
  recentVoltageDiff = voltageDiff;
  if ( lastRecordedVoltageDiff == 255 )
  {
    lastRecordedVoltageDiff = voltageDiff;
LABEL_25:
    word_482A90 = 0;
    goto LABEL_5;
  }
  if ( lastRecordedVoltageDiff - voltageDiff <= 5 )
    goto LABEL_25;
  ++word_482A90;
LABEL_5:
  if ( dword_482A8C > 0 && optBitmainWorkMode != 1 )
  {
    if ( voltageDiff <= 19 || word_482A90 > 1 && (unsigned int)currentVoltage - 21 <= 8 )
    {
      initVoltage = get_global_flag();
      adjustedVoltage = 100;
      voltageOffset = 100 * (20 - voltageDiff);
      targetVoltage = initVoltage;
      if ( voltageOffset < 4000 )
        adjustedVoltage = voltageOffset / 40;
      if ( (unsigned int)globalLogLevel > 4 )
      {
        absVoltageDifference = initVoltage - dword_482A8C + adjustedVoltage;
        if ( absVoltageDifference < 0 )
          absVoltageDifference = -absVoltageDifference;
        snprintf(
          logBuffer,
          2048u,
          "curr_vol = %d, g_voltage = %d,compensate_voltage = %d, abs = %d",
          initVoltage,
          dword_482A8C,
          adjustedVoltage,
          absVoltageDifference);
        logMessage(4, logBuffer, 0);
      }
      incrementStep = adjustedVoltage + dword_482A8C;
      voltageDifference = targetVoltage - (adjustedVoltage + dword_482A8C);
      if ( voltageDifference < 0 )
        voltageDifference = incrementStep - targetVoltage;
      if ( voltageDifference <= 19 )
        goto UpdateVoltageDone;
      finalVoltageAdjustment = targetVoltage + 49;
      if ( targetVoltage + 49 < incrementStep )
      {
        while ( 1 )
        {
          voltageCheck = calculate_percentage() <= finalVoltageAdjustment;
          finalVoltageAdjustment += 20;
          if ( voltageCheck )
            break;
          targetVoltage += 20;
          SetVoltageBySteps(targetVoltage);
          usleep(200000u);
          incrementStep = adjustedVoltage + dword_482A8C;
          if ( adjustedVoltage + dword_482A8C <= finalVoltageAdjustment )
            goto UpdateVoltageEnd;
        }
        incrementStep = adjustedVoltage + dword_482A8C;
      }
UpdateVoltageEnd:
      if ( targetVoltage == incrementStep )
        goto UpdateVoltageDone;
SetVoltage:
      SetVoltageBySteps(incrementStep);
      lastRecordedVoltageDiff = voltageDiff;
      return 0;
    }
    if ( (unsigned int)currentVoltage - 30 > 21 )
    {
      chipModel = (const char *)get_shared_variable();
      if ( strcmp(chipModel, "NBS1902L") )
        recentVoltageDiff = voltageDiff + 10;
      if ( recentVoltageDiff > 49 && dword_482A8C - 20 != get_global_flag() )
      {
        incrementStep = dword_482A8C - 20;
        goto SetVoltage;
      }
    }
    else
    {
      newTargetVoltage = get_global_flag();
      for ( incrementStep = dword_482A8C; dword_482A8C < newTargetVoltage - 19; incrementStep = dword_482A8C )
      {
        newTargetVoltage -= 20;
        SetVoltageBySteps(newTargetVoltage);
        usleep(200000u);
      }
      if ( incrementStep != newTargetVoltage )
        goto SetVoltage;
    }
UpdateVoltageDone:
    lastRecordedVoltageDiff = voltageDiff;
  }
  return 0;
}
// 7EB9C: using guessed type int globalLogLevel;
// 7EDE4: using guessed type __int16 lastRecordedVoltageDiff;
// 80FB4: using guessed type int optBitmainWorkMode;
// 482A8C: using guessed type int dword_482A8C;
// 482A90: using guessed type __int16 word_482A90;

//----- (00035344) --------------------------------------------------------
int setFanSpeedControl()
{
  int minPicTemp; // r7
  int maxPicTemp; // r5
  int maxChipTemp; // r6
  int result; // r0
  int tempDiff; // r2
  int fanSpeedAdjustCount; // r2
  int adjustThreshold; // r3
  int lastDiffContinuousTime; // r8
  bool condition; // cc
  int logValue; // r0
  unsigned __int8 increasePwm; // r4
  int newFanSpeed; // r4
  int logValue2; // r0
  unsigned __int8 decreasePwm; // r4
  int logValue3; // r0
  char logBuffer[2080]; // [sp+18h] [bp-820h] BYREF

  if ( (globalTokenBuffer1 & 2) != 0 && (unsigned __int8)byte_99EDC2 <= 100u )
  {
    result = setFanPWM((unsigned __int8)byte_99EDC2);
    if ( !dword_482A94 )
    {
      if ( (unsigned int)globalLogLevel > 3 )
      {
        snprintf(logBuffer, 2048u, "fan_etf: Set fixed fan speed=%d\n", (unsigned __int8)byte_99EDC2);
        result = logMessage(3, logBuffer, 0);
      }
      dword_482A94 = 1;
    }
    return result;
  }
  minPicTemp = get_minimum_temp();
  maxPicTemp = get_maximum_temperature();
  maxChipTemp = get_highest_temperature();
  result = maxPicTemp - get_minimum_temp();
  if ( dword_7EDE8 == 255 )
  {
    fanSpeedAdjustCount = dword_482A98;
LABEL_25:
    dword_482A9C = fanSpeedAdjustCount > 1;
    dword_482A98 = (fanSpeedAdjustCount - 1) & ~((fanSpeedAdjustCount - 1) >> 31);
    goto LABEL_10;
  }
  tempDiff = dword_7EDE8 - minPicTemp;
  if ( dword_7EDE8 - minPicTemp < 0 )
    tempDiff = minPicTemp - dword_7EDE8;
  condition = tempDiff <= 4;
  fanSpeedAdjustCount = dword_482A98;
  if ( condition )
    goto LABEL_25;
  adjustThreshold = dword_482A98 + 1;
  if ( dword_482A98 + 1 >= 2 )
    adjustThreshold = 2;
  dword_482A98 = adjustThreshold;
  dword_482A9C = fanSpeedAdjustCount > 0;
LABEL_10:
  dword_7EDE8 = minPicTemp;
  if ( maxPicTemp > 72 )
    goto LABEL_14;
  lastDiffContinuousTime = abs32(result);
  condition = lastDiffContinuousTime <= 32;
  if ( lastDiffContinuousTime <= 32 )
    condition = minPicTemp <= 50;
  if ( !condition || dword_482A9C )
  {
LABEL_14:
    if ( !dword_482A94 )
    {
      if ( (unsigned int)globalLogLevel > 4 )
      {
        snprintf(
          logBuffer,
          2048u,
          "min pic temp = %d max pic temp = %d pic diff = %d, max chip temp = %d, last diff continuous_time = %d",
          minPicTemp,
          maxPicTemp,
          result,
          maxChipTemp,
          dword_482A98);
        logMessage(4, logBuffer, 0);
      }
      dword_482A94 = 1;
    }
    return setFanPWM(100);
  }
  else
  {
    dword_482A94 = 0;
    if ( lastDiffContinuousTime > 27 )
    {
      increasePwm = (unsigned int)(float)((float)((float)((float)lastDiffContinuousTime - 25.0) / 25.0) * 10.0);
      if ( increasePwm + sub_1E4B0() <= 99 )
        newFanSpeed = (unsigned __int8)(increasePwm + sub_1E4B0());
      else
        newFanSpeed = 100;
      if ( (unsigned int)globalLogLevel > 4 )
      {
        logValue2 = sub_1E4B0();
        snprintf(
          logBuffer,
          2048u,
          "max temp = %04d, diff = %04d, + pwm form %04d to %04d\n",
          maxPicTemp,
          lastDiffContinuousTime,
          logValue2,
          newFanSpeed);
        logMessage(4, logBuffer, 0);
      }
      return setFanPWM(newFanSpeed);
    }
    if ( lastDiffContinuousTime > 22 )
    {
      if ( (unsigned int)globalLogLevel > 4 )
      {
        logValue = sub_1E4B0();
        snprintf(
          logBuffer,
          2048u,
          "max temp = %04d, diff = %04d, = pwm %04d\n",
          maxPicTemp,
          lastDiffContinuousTime,
          logValue);
        return logMessage(4, logBuffer, 0);
      }
      return result;
    }
    decreasePwm = (unsigned int)(float)((float)((float)(25.0 - (float)lastDiffContinuousTime) / 25.0) * 10.0);
    result = sub_1E4B0() - decreasePwm;
    if ( result > 39 )
    {
      result = sub_1E4B0();
      newFanSpeed = (unsigned __int8)(result - decreasePwm);
    }
    else
    {
      newFanSpeed = 40;
    }
    if ( (unsigned int)globalLogLevel > 4 )
    {
      logValue3 = sub_1E4B0();
      snprintf(
        logBuffer,
        2048u,
        "max temp = %04d, diff = %04d, - pwm form %04d to %04d\n",
        maxPicTemp,
        lastDiffContinuousTime,
        logValue3,
        newFanSpeed);
      result = logMessage(4, logBuffer, 0);
    }
    if ( maxPicTemp <= 67 )
      return setFanPWM(newFanSpeed);
  }
  return result;
}
// 7EB9C: using guessed type int globalLogLevel;
// 7EDE8: using guessed type int dword_7EDE8;
// 482A94: using guessed type int dword_482A94;
// 482A98: using guessed type int dword_482A98;
// 482A9C: using guessed type int dword_482A9C;
// 99EDBC: using guessed type char globalTokenBuffer1;
// 99EDC2: using guessed type char byte_99EDC2;

//----- (000356C4) --------------------------------------------------------
int __fastcall generate_error_message(int error_code, int parameter_value)
{
  int output; // r0
  char error_buffer[2056]; // [sp+0h] [bp-808h] BYREF

  switch ( error_code )
  {
    case 0:
      snprintf((char *)dword_4FCAE8, 64u, "J%d:1", parameter_value);
      break;
    case 1:
      snprintf((char *)dword_4FCAE8, 64u, "J%d:2", parameter_value);
      break;
    case 2:
      snprintf((char *)dword_4FCAE8, 64u, "J%d:8", parameter_value);
      break;
    case 3:
      snprintf((char *)dword_4FCAE8, 64u, "J%d:4", parameter_value);
      break;
    case 4:
      snprintf((char *)dword_4FCAE8, 64u, "J%d:5", parameter_value);
      break;
    case 5:
      dword_4FCAE8[0] = (int)&unk_313A52;
      break;
    case 6:
      dword_4FCAE8[0] = (int)&unk_323A52;
      break;
    case 7:
      snprintf((char *)dword_4FCAE8, 64u, "T:%d", parameter_value);
      break;
    case 8:
      dword_4FCAE8[0] = (int)&unk_313A50;
      break;
    case 9:
      dword_4FCAE8[0] = (int)&unk_323A50;
      break;
    case 10:
      dword_4FCAE8[0] = (int)&unk_313A46;
      break;
    case 11:
      snprintf((char *)dword_4FCAE8, 64u, "J%d:6", parameter_value);
      break;
    case 12:
      dword_4FCAE8[0] = (int)&unk_313A56;
      break;
    case 13:
      dword_4FCAE8[0] = (int)&unk_313A4D;
      break;
    case 14:
      dword_4FCAE8[0] = (int)&unk_313A4E;
      break;
    case 15:
      dword_4FCAE8[0] = (int)&unk_343A50;
      break;
    case 17:
      dword_4FCAE8[0] = (int)&unk_333A52;
      break;
    case 18:
      dword_4FCAE8[0] = (int)&unk_313A43;
      break;
    case 19:
      dword_4FCAE8[0] = (int)&unk_323A4E;
      break;
    case 20:
      dword_4FCAE8[0] = (int)&unk_303A53;
      break;
    case 21:
      dword_4FCAE8[0] = (int)&unk_333A4E;
      break;
    case 22:
      dword_4FCAE8[0] = (int)&unk_353A50;
      break;
    default:
      strcpy((char *)dword_4FCAE8, "unknown");
      break;
  }
  output = sub_36558(1);
  if ( (unsigned int)globalLogLevel > 3 )
  {
    snprintf(error_buffer, 2048u, "Sweep error string = %s.\n", (const char *)dword_4FCAE8);
    return logMessage(3, error_buffer, 0);
  }
  return output;
}
// 356D8: control flows out of bounds to 356DC
// 7EB9C: using guessed type int globalLogLevel;
// 4FCAE8: using guessed type int dword_4FCAE8[16];

//----- (000359EC) --------------------------------------------------------
int *get_global_config_pointer()
{
  return dword_4FCAE8;
}
// 4FCAE8: using guessed type int dword_4FCAE8[16];

//----- (000359F8) --------------------------------------------------------
int __fastcall calculate_frequency_base(int input_frequency)
{
  return 3000 * ((input_frequency - 2000) / 3000) + 2000;
}

//----- (00035A28) --------------------------------------------------------
void __noreturn main_mining_loop()
{
  int chip_id; // r0
  unsigned int chip_temperature; // r0
  int temperature_threshold; // r8
  int reset_counter; // r4
  _QWORD register_data[259]; // [sp+0h] [bp-818h] BYREF

  if ( (unsigned int)globalLogLevel > 4 )
  {
    strcpy((char *)register_data, "[DEBUG] Recv nonce and register.\n");
    logMessage(4, (const char *)register_data, 0);
  }
  chip_id = read_chip_id();
  set_and_read_register_value(chip_id | 0x10000);
  reset_statistics();
  while ( 1 )
  {
    chip_temperature = read_chip_temperature();
    temperature_threshold = (unsigned __int8)(chip_temperature >> 1);
    if ( (unsigned __int8)(chip_temperature >> 1) )
      break;
LABEL_12:
    usleep(1000u);
  }
  reset_counter = 0;
  while ( 1 )
  {
    get_register_values(register_data);
    if ( (register_data[0] & 0x80000000LL) != 0 )
      break;
    if ( (unsigned int)dword_5945C0 <= 510 && dword_5945B8[0] <= 510u )
    {
      process_incoming_data((int)register_data);
LABEL_7:
      if ( temperature_threshold == ++reset_counter )
        goto LABEL_12;
    }
    else
    {
      ++reset_counter;
      reset_statistics();
      if ( temperature_threshold == reset_counter )
        goto LABEL_12;
    }
  }
  check_asics_communication();
  goto LABEL_7;
}
// 7EB9C: using guessed type int globalLogLevel;
// 5945B8: using guessed type int dword_5945B8[];
// 5945C0: using guessed type int dword_5945C0;

//----- (00035B1C) --------------------------------------------------------
int checkNonceRateAgainstThreshold()
{
  int nonceRateUnderThreshold; // r8
  int chainIndex; // r5
  int chainDataOffset; // r4
  int nonceRateMemoryLocation; // r2
  float nonceRate; // s12
  float nonceRateThreshold; // s14
  char logBuffer[2080]; // [sp+10h] [bp-820h] BYREF

  nonceRateUnderThreshold = 0;
  for ( chainIndex = 0; chainIndex != 4; ++chainIndex )
  {
    chainDataOffset = 4 * (chainIndex + 1032);
    if ( get_global_buffer_value(chainIndex) )
    {
      nonceRateMemoryLocation = dword_4FCB28;
      nonceRate = *(float *)(dword_4FCB28 + chainDataOffset);
      nonceRateThreshold = *(float *)(*(_DWORD *)(dword_4FCB28 + 8) + 20);
      if ( (unsigned int)globalLogLevel > 3 )
      {
        snprintf(
          logBuffer,
          2048u,
          "chain = %d, nonce_rate_max = %.4f, nonce_rate_threshold = %.4f\n",
          chainIndex,
          nonceRate,
          nonceRateThreshold);
        logMessage(3, logBuffer, 0);
        nonceRateMemoryLocation = dword_4FCB28;
        nonceRate = *(float *)(dword_4FCB28 + chainDataOffset);
        nonceRateThreshold = *(float *)(*(_DWORD *)(dword_4FCB28 + 8) + 20);
      }
      if ( nonceRate < nonceRateThreshold )
      {
        nonceRateUnderThreshold = 1;
        *(_DWORD *)(nonceRateMemoryLocation + 4 * (chainIndex + 1040)) = 1;
      }
    }
  }
  return nonceRateUnderThreshold;
}
// 7EB9C: using guessed type int globalLogLevel;
// 4FCB28: using guessed type int dword_4FCB28;

//----- (00035C04) --------------------------------------------------------
unsigned int __fastcall sub_35C04(int initial_address)
{
  unsigned int checksum; // r6
  int base_address; // r10
  int section_index; // r4
  int section_length; // r9
  int current_address; // r7
  int iteration_index; // r5
  int current_value; // t1

  checksum = 0;
  base_address = initial_address - 4;
  for ( section_index = 0; section_index != 4; ++section_index )
  {
    if ( get_global_buffer_value(section_index) )
    {
      section_length = get_global_variable_value();
      if ( section_length )
      {
        current_address = base_address + (section_index << 10);
        for ( iteration_index = 0; iteration_index != section_length; ++iteration_index )
        {
          current_value = *(_DWORD *)(current_address + 4);
          current_address += 4;
          checksum += current_value * get_shared_value();
        }
      }
    }
  }
  return checksum / 1000;
}

//----- (00035C74) --------------------------------------------------------
void cleanup_sweep_operation()
{
  char debug_message_buffer[2056]; // [sp+0h] [bp-808h] BYREF

  if ( (unsigned int)globalLogLevel > 4 )
  {
    strcpy(debug_message_buffer, "[DEBUG] Sweep exit.\n");
    logMessage(4, debug_message_buffer, 0);
    if ( (unsigned int)globalLogLevel > 4 )
    {
      strcpy(debug_message_buffer, "[DEBUG] Free memory for sweep.\n");
      logMessage(4, debug_message_buffer, 0);
    }
  }
  if ( dword_4FCB28 )
  {
    free((void *)dword_4FCB28);
    dword_4FCB28 = 0;
  }
}
// 7EB9C: using guessed type int globalLogLevel;
// 4FCB28: using guessed type int dword_4FCB28;

//----- (00035D24) --------------------------------------------------------
int __fastcall sub_35D24(int **board_info, int board_index, int round_number)
{
  int init_status; // r8
  int voltage_set_result; // r0
  int *board_info_ptr; // r3
  int frequency_current; // r12
  int frequency_max; // r2
  int board_config_ptr; // r3
  unsigned int frequency_min_observed; // r9
  int chain_index; // r5
  int global_variable_value; // r0
  int config_end_ptr; // r0
  int config_current_ptr; // r3
  unsigned int frequency_value; // r2
  unsigned int frequency_value_temp; // t1
  unsigned int frequency_max_observed; // r5
  int i; // r10
  int config_value_cnt; // r0
  int config_end_pointer; // r0
  int config_current_pointer; // r3
  unsigned int current_frequency_value; // r2
  unsigned int temp_frequency_value; // t1
  int chain_id; // r10
  char *chain_idx_char; // r9
  int stats; // r5
  char *stats_data_ptr; // r10
  int chain_iter; // r5
  int hash_rate; // r0
  int config_end_pos; // lr
  int config_current_pos; // r1
  char *stats_current_ptr; // r12
  int frequency_actual; // r3
  int frequency_temp; // t1
  int stats_value; // t1
  bool is_log_level_high; // cc
  int total_ideal_hash_rate; // [sp+Ch] [bp-834h]
  unsigned int observed_frequency_max; // [sp+14h] [bp-82Ch] BYREF
  char log_buffer[2088]; // [sp+18h] [bp-828h] BYREF

  if ( (unsigned int)globalLogLevel > 3 )
  {
    strcpy(log_buffer, "\n");
    append_log_message(3, log_buffer, 0);
    if ( (unsigned int)globalLogLevel > 3 )
    {
      snprintf(log_buffer, 2048u, ">>>> Get ideal hash rate, round %d.\n", round_number);
      logMessage(3, log_buffer, 0);
    }
  }
  init_status = InitializeBoard(board_index);
  if ( init_status )
  {
    if ( (unsigned int)globalLogLevel <= 3 )
      return init_status;
    strcpy(log_buffer, "Board init failed.\n");
    logMessage(3, log_buffer, 0);
    return init_status;
  }
  else
  {
    clear_context();
    board_info_ptr = *board_info;
    frequency_current = **board_info;
    frequency_max = (*board_info)[4];
    if ( frequency_current > frequency_max )
      *board_info_ptr = frequency_max;
    if ( frequency_current > frequency_max )
      board_info_ptr = *board_info;
    if ( frequency_current > frequency_max )
      frequency_current = *board_info_ptr;
    board_config_ptr = *(_DWORD *)(dword_4FCB28 + 8);
    dword_4FCB2C = frequency_current;
    setChipFrequencies(dword_4FCB28 + 12, (unsigned __int8)byte_482A70, *(unsigned __int8 *)(board_config_ptr + 8));
    if ( get_global_flag() == dword_4FCB2C || (voltage_set_result = SetVoltageBySteps(dword_4FCB2C)) == 0 )
    {
      frequency_min_observed = 16777215;
      for ( chain_index = 0; chain_index != 4; ++chain_index )
      {
        if ( get_global_buffer_value(chain_index) )
        {
          global_variable_value = get_global_variable_value();
          if ( global_variable_value )
          {
            config_end_ptr = dword_4FCB28 + 8 + 4 * (global_variable_value + (chain_index << 8));
            config_current_ptr = dword_4FCB28 + (chain_index << 10) + 8;
            do
            {
              frequency_value_temp = *(_DWORD *)(config_current_ptr + 4);
              config_current_ptr += 4;
              frequency_value = frequency_value_temp;
              if ( frequency_min_observed >= frequency_value_temp )
                frequency_min_observed = frequency_value;
            }
            while ( config_current_ptr != config_end_ptr );
          }
        }
      }
      if ( (unsigned int)globalLogLevel > 3 )
      {
        snprintf(log_buffer, 2048u, "chain = %d, freq_min = %d\n", 255, frequency_min_observed);
        logMessage(3, log_buffer, 0);
      }
      frequency_max_observed = 0;
      for ( i = 0; i != 4; ++i )
      {
        if ( get_global_buffer_value(i) )
        {
          config_value_cnt = get_global_variable_value();
          if ( config_value_cnt )
          {
            config_end_pointer = dword_4FCB28 + 8 + 4 * (config_value_cnt + (i << 8));
            config_current_pointer = dword_4FCB28 + (i << 10) + 8;
            do
            {
              temp_frequency_value = *(_DWORD *)(config_current_pointer + 4);
              config_current_pointer += 4;
              current_frequency_value = temp_frequency_value;
              if ( frequency_max_observed < temp_frequency_value )
                frequency_max_observed = current_frequency_value;
            }
            while ( config_current_pointer != config_end_pointer );
          }
        }
      }
      if ( (unsigned int)globalLogLevel > 3 )
      {
        snprintf(log_buffer, 2048u, "chain = %d, freq_max = %d\n", 255, frequency_max_observed);
        logMessage(3, log_buffer, 0);
      }
      chain_id = 0;
      observed_frequency_max = frequency_max_observed;
      update_miner_frequency(frequency_min_observed, optMultiVersion, 20);
      do
      {
        if ( get_global_buffer_value(chain_id) )
          update_chain_status(chain_id, 1);
        ++chain_id;
      }
      while ( chain_id != 4 );
      chain_idx_char = 0;
      perform_pattern_test((int)&observed_frequency_max);
      stats = get_stats();
      do
      {
        if ( get_global_buffer_value((int)chain_idx_char) )
          log_miner_chain_stats(chain_idx_char, stats);
        ++chain_idx_char;
      }
      while ( chain_idx_char != (char *)4 );
      stats_data_ptr = (char *)&unk_808FFC + stats;
      chain_iter = 0;
      total_ideal_hash_rate = 0;
      do
      {
        if ( get_global_buffer_value(chain_iter) )
        {
          hash_rate = get_global_variable_value();
          if ( hash_rate )
          {
            config_end_pos = dword_4FCB28 + 8 + 4 * (hash_rate + (chain_iter << 8));
            hash_rate = 0;
            config_current_pos = dword_4FCB28 + (chain_iter << 10) + 8;
            stats_current_ptr = &stats_data_ptr[1024 * chain_iter];
            do
            {
              frequency_temp = *(_DWORD *)(config_current_pos + 4);
              config_current_pos += 4;
              frequency_actual = frequency_temp;
              stats_value = *((_DWORD *)stats_current_ptr + 1);
              stats_current_ptr += 4;
              hash_rate += stats_value * frequency_actual / 8000u;
            }
            while ( config_end_pos != config_current_pos );
            total_ideal_hash_rate += hash_rate;
          }
          is_log_level_high = (unsigned int)globalLogLevel > 3;
          *(_DWORD *)(dword_4FCB28 + 4 * (chain_iter + 1026) + 4) = hash_rate;
          if ( is_log_level_high )
          {
            snprintf(log_buffer, 2048u, "chain = %d, ideal_hash_rate_GH = %d\n", chain_iter, hash_rate);
            logMessage(3, log_buffer, 0);
          }
        }
        ++chain_iter;
      }
      while ( chain_iter != 4 );
      if ( (unsigned int)globalLogLevel > 3 )
      {
        snprintf(log_buffer, 2048u, "hash_rate_total_GH = %d\n", total_ideal_hash_rate);
        logMessage(3, log_buffer, 0);
      }
      return init_status;
    }
  }
  return voltage_set_result;
}
// 7EB58: using guessed type int optMultiVersion;
// 7EB9C: using guessed type int globalLogLevel;
// 482A70: using guessed type char byte_482A70;
// 4FCB28: using guessed type int dword_4FCB28;
// 4FCB2C: using guessed type int dword_4FCB2C;

//----- (00036174) --------------------------------------------------------
_DWORD *__fastcall set_default_miner_vals(_DWORD *miner_values)
{
  char log_buffer[2056]; // [sp+0h] [bp-808h] BYREF

  generate_error_message(15, 255);
  if ( (unsigned int)globalLogLevel > 3 )
  {
    snprintf(log_buffer, 2048u, "Unknown miner type(%d).\n", 2);
    logMessage(3, log_buffer, 0);
  }
  *miner_values = 3000;
  miner_values[1] = 2000;
  miner_values[2] = 219640;
  return miner_values;
}
// 7EB9C: using guessed type int globalLogLevel;

//----- (000361E4) --------------------------------------------------------
int __fastcall update_global_value(int global_value)
{
  dword_4FCB2C = global_value;
  return global_value;
}
// 4FCB2C: using guessed type int dword_4FCB2C;

//----- (000361F4) --------------------------------------------------------
int get_miner_status_code()
{
  return dword_4FCB2C;
}
// 4FCB2C: using guessed type int dword_4FCB2C;

//----- (00036208) --------------------------------------------------------
int set_voltage_to_default()
{
  return SetVoltageBySteps(dword_4FCB2C);
}
// 4FCB2C: using guessed type int dword_4FCB2C;

//----- (00036218) --------------------------------------------------------
int check_sweep_done()
{
  FILE *config_file; // r4
  int is_done; // r0
  char debug_message[2056]; // [sp+0h] [bp-808h] BYREF

  config_file = (FILE *)fopen64("/config/scanfreqdone", "r");
  if ( (unsigned int)globalLogLevel > 4 )
  {
    strcpy(debug_message, "[DEBUG] Check if sweep is already done.\n");
    logMessage(4, debug_message, 0);
  }
  is_done = (int)config_file;
  if ( config_file )
  {
    fclose(config_file);
    return 1;
  }
  return is_done;
}
// 124E4: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 7EB9C: using guessed type int globalLogLevel;

//----- (000362A0) --------------------------------------------------------
int __fastcall initialize_sweep(int sweep_type)
{
  int status; // r0
  unsigned int sweep_type_offset; // r8
  _DWORD *sweep_context; // r8
  int global_buffer_index; // r7
  char *error_message_tail; // lr
  char *log_message_buffer_tail; // r12
  int char_1; // r0
  int char_2; // r1
  int char_3; // r2
  int char_4; // r3
  _DWORD *error_message_tail_ptr; // lr
  char *log_message_buffer; // r12
  int char_2_copy; // r1
  int char_3_copy; // r2
  int global_variable_value; // r0
  int end_address; // r2
  int current_address; // r3
  int local_buffer[2]; // [sp+0h] [bp-820h] BYREF
  char s[2072]; // [sp+8h] [bp-818h] BYREF

  if ( !check_sweep_done() )
  {
    convert_timespec_to_custom_format(local_buffer);
    sweep_type_offset = sweep_type - 160;
    dword_4FCB30 = 2;
    if ( (unsigned int)globalLogLevel > 4 )
    {
      snprintf(s, 2048u, "[DEBUG] Sweep init, sweep_type = 0x%X.\n", sweep_type);
      logMessage(4, s, 0);
      if ( sweep_type_offset > 1 )
        goto LABEL_7;
      if ( (unsigned int)globalLogLevel > 4 )
      {
        strcpy(s, "[DEBUG] Allocate memory for sweep.\n");
        logMessage(4, s, 0);
      }
    }
    else if ( sweep_type_offset > 1 )
    {
LABEL_7:
      generate_error_message(20, 255);
      if ( (unsigned int)globalLogLevel <= 3 )
        goto LABEL_8;
      error_message_tail = "Sweep type error, exit.\n";
      log_message_buffer_tail = s;
      goto LABEL_19;
    }
    sweep_context = (_DWORD *)dword_4FCB28;
    if ( dword_4FCB28 || (sweep_context = calloc(4220u, 1u), (dword_4FCB28 = (int)sweep_context) != 0) )
    {
      *sweep_context = sweep_type;
      global_buffer_index = 0;
      sweep_context[1] = 1199570688;
      do
      {
        if ( get_global_buffer_value(global_buffer_index) )
        {
          global_variable_value = get_global_variable_value();
          if ( global_variable_value > 0 )
          {
            end_address = dword_4FCB28 + 8 + 4 * (global_variable_value + (global_buffer_index << 8));
            current_address = dword_4FCB28 + (global_buffer_index << 10) + 8;
            do
            {
              *(_DWORD *)(current_address + 4) = 300;
              current_address += 4;
            }
            while ( current_address != end_address );
          }
        }
        ++global_buffer_index;
      }
      while ( global_buffer_index != 4 );
      generate_error_message(15, 255);
      if ( (unsigned int)globalLogLevel > 3 )
      {
        snprintf(s, 2048u, "Unknown miner type(%d).\n", 2);
        logMessage(3, s, 0);
      }
      goto LABEL_8;
    }
    generate_error_message(13, 255);
    if ( (unsigned int)globalLogLevel <= 3 )
    {
LABEL_8:
      status = -1;
      dword_4FCB30 = 1;
      return status;
    }
    error_message_tail = " memory for sweep ctxt.\n";
    qmemcpy(s, "Fail to allocate", 16);
    log_message_buffer_tail = &s[16];
LABEL_19:
    char_1 = *(_DWORD *)error_message_tail;
    char_2 = *((_DWORD *)error_message_tail + 1);
    char_3 = *((_DWORD *)error_message_tail + 2);
    char_4 = *((_DWORD *)error_message_tail + 3);
    error_message_tail_ptr = error_message_tail + 16;
    *(_DWORD *)log_message_buffer_tail = char_1;
    *((_DWORD *)log_message_buffer_tail + 1) = char_2;
    *((_DWORD *)log_message_buffer_tail + 2) = char_3;
    *((_DWORD *)log_message_buffer_tail + 3) = char_4;
    log_message_buffer = log_message_buffer_tail + 16;
    char_2_copy = error_message_tail_ptr[1];
    char_3_copy = error_message_tail_ptr[2];
    *(_DWORD *)log_message_buffer = *error_message_tail_ptr;
    *((_DWORD *)log_message_buffer + 1) = char_2_copy;
    log_message_buffer[8] = char_3_copy;
    logMessage(3, s, 0);
    goto LABEL_8;
  }
  if ( (unsigned int)globalLogLevel > 3 )
  {
    strcpy(s, "Sweep already done, exit.\n");
    logMessage(3, s, 0);
  }
  return 0;
}
// 7EB9C: using guessed type int globalLogLevel;
// 4FCB28: using guessed type int dword_4FCB28;
// 4FCB30: using guessed type int dword_4FCB30;
// 362A0: using guessed type __time_t anonymous_0[2];

//----- (00036538) --------------------------------------------------------
int __fastcall set_default_timeout_value(_DWORD *timeout_value_ptr)
{
  *timeout_value_ptr = 1000;
  return 0;
}

//----- (00036548) --------------------------------------------------------
int get_global_state_flag()
{
  return dword_4FCB30;
}
// 4FCB30: using guessed type int dword_4FCB30;

//----- (00036558) --------------------------------------------------------
int __fastcall sub_36558(int new_value)
{
  dword_4FCB30 = new_value;
  return new_value;
}
// 4FCB30: using guessed type int dword_4FCB30;

//----- (0003656C) --------------------------------------------------------
int get_miner_stats_offset()
{
  char debug_message[2056]; // [sp-808h] [bp-808h] BYREF

  if ( (unsigned int)globalLogLevel > 4 )
  {
    strcpy(debug_message, "[DEBUG] Get stats.\n");
    logMessage(4, debug_message, 0);
  }
  return dword_4FCB34 + 8;
}
// 7EB9C: using guessed type int globalLogLevel;
// 4FCB34: using guessed type int dword_4FCB34;

//----- (000365E8) --------------------------------------------------------
bool __fastcall is_nonce_count_sufficient(int chain_index)
{
  unsigned int nonce_count; // r5
  int nonce_target_factor; // r4
  char debug_message[2064]; // [sp+0h] [bp-810h] BYREF

  if ( (unsigned int)globalLogLevel > 4 )
  {
    snprintf(debug_message, 2048u, "[DEBUG] Check if is recv nonce enough, chain = %d.\n", chain_index);
    logMessage(4, debug_message, 0);
  }
  nonce_count = *(_DWORD *)(dword_4FCB34 + 4 * ((_DWORD)&unk_202802 + chain_index));
  nonce_target_factor = 8 * get_shared_value();
  return nonce_count >= get_global_variable_value() * nonce_target_factor;
}
// 7EB9C: using guessed type int globalLogLevel;
// 4FCB34: using guessed type int dword_4FCB34;

//----- (00036680) --------------------------------------------------------
int __fastcall check_chain_balance(int chain_index)
{
  int global_variable_value; // r9
  int is_unbalanced; // r7
  int asic_index; // r4
  char *asic_address; // r11
  unsigned int asic_hashrate; // r10
  unsigned int asic_hashrate_low_check; // s16
  int log_asic_index; // [sp+0h] [bp-850h]
  char log_buffer[2104]; // [sp+18h] [bp-838h] BYREF

  if ( (unsigned int)globalLogLevel > 4 )
  {
    snprintf(log_buffer, 2048u, "[DEBUG] Check if is unbalanche happen, chain = %d\n", chain_index);
    logMessage(4, log_buffer, 0);
  }
  global_variable_value = get_global_variable_value();
  if ( global_variable_value )
  {
    asic_index = 0;
    is_unbalanced = 0;
    while ( 1 )
    {
      asic_address = (char *)&unk_202402 + 256 * chain_index + asic_index;
      asic_hashrate = *(_DWORD *)(dword_4FCB34 + 4 * (_DWORD)asic_address);
      if ( asic_hashrate > 8 * get_shared_value() )
      {
        is_unbalanced = 1;
        if ( (unsigned int)globalLogLevel <= 3 )
          goto LABEL_7;
LABEL_11:
        log_asic_index = asic_index++;
        snprintf(log_buffer, 2048u, "Unbalance happened: chain = %d, asic = %d\n", chain_index, log_asic_index);
        is_unbalanced = 1;
        logMessage(3, log_buffer, 0);
        if ( global_variable_value == asic_index )
          return is_unbalanced;
      }
      else
      {
        asic_hashrate_low_check = *(_DWORD *)(dword_4FCB34 + 4 * (_DWORD)asic_address);
        if ( (double)asic_hashrate_low_check < (double)(8 * get_shared_value()) * 0.75 )
        {
          is_unbalanced = 1;
          if ( (unsigned int)globalLogLevel > 3 )
            goto LABEL_11;
        }
LABEL_7:
        if ( global_variable_value == ++asic_index )
          return is_unbalanced;
      }
    }
  }
  return 0;
}
// 7EB9C: using guessed type int globalLogLevel;
// 4FCB34: using guessed type int dword_4FCB34;

//----- (000367E4) --------------------------------------------------------
int reset_hardware_and_set_frequency()
{
  int asic_index; // r4
  int asic_version_value; // r0
  char debug_message_buffer[2056]; // [sp+0h] [bp-808h] BYREF

  if ( (unsigned int)globalLogLevel > 4 )
  {
    strcpy(debug_message_buffer, "[DEBUG] HW sweep reset.\n");
    logMessage(4, debug_message_buffer, 0);
  }
  asic_index = 0;
  check_global_buffers_and_process(255, 0);
  do
  {
    if ( get_global_buffer_value(asic_index) )
      enable_asic_boost_mode((unsigned __int8)asic_index);
    ++asic_index;
  }
  while ( asic_index != 4 );
  asic_version_value = read_asic_version();
  return set_frequency(asic_version_value & 0xFFFF70FF | 0x8400);
}
// 7EB9C: using guessed type int globalLogLevel;

//----- (00036884) --------------------------------------------------------
void *clear_hardware_stats()
{
  char debug_message[2056]; // [sp+0h] [bp-808h] BYREF

  if ( (unsigned int)globalLogLevel > 4 )
  {
    strcpy(debug_message, "[DEBUG] HW sweep clear stats.\n");
    logMessage(4, debug_message, 0);
  }
  return memset((void *)(dword_4FCB34 + 8), 0, (size_t)&unk_80A8A4);
}
// 7EB9C: using guessed type int globalLogLevel;
// 4FCB34: using guessed type int dword_4FCB34;

//----- (00036908) --------------------------------------------------------
int send_midstate_work()
{
  int chip_index; // r4
  int operation_result; // r0
  unsigned int debug_buffer[518]; // [sp+28h] [bp-818h] BYREF

  if ( (unsigned int)globalLogLevel > 4 )
  {
    strcpy((char *)debug_buffer, "[DEBUG] Send 1-midstate work.\n");
    logMessage(4, (const char *)debug_buffer, 0);
  }
  chip_index = 0;
  memset(debug_buffer, 0, 52u);
  LOBYTE(debug_buffer[0]) = 1;
  do
  {
    operation_result = get_global_buffer_value(chip_index);
    if ( operation_result )
    {
      while ( (read_chip_version() & (1 << chip_index)) == 0 )
        get_next_sleep_interval();
      BYTE1(debug_buffer[0]) = chip_index | 0x80;
      transform_input_data(
        debug_buffer[0],
        debug_buffer[1],
        debug_buffer[2],
        debug_buffer[3],
        debug_buffer[4],
        debug_buffer[5],
        debug_buffer[6],
        debug_buffer[7],
        debug_buffer[8]);
      operation_result = get_next_sleep_interval();
    }
    ++chip_index;
  }
  while ( chip_index != 4 );
  return operation_result;
}
// 7EB9C: using guessed type int globalLogLevel;

//----- (00036A0C) --------------------------------------------------------
void free_hardware_sweep_memory()
{
  void *temp_pointer; // r0
  char log_buffer[2056]; // [sp+0h] [bp-808h] BYREF

  if ( (unsigned int)globalLogLevel > 4 )
  {
    strcpy(log_buffer, "[DEBUG] Free memory for hw sweep.\n");
    logMessage(4, log_buffer, 0);
  }
  temp_pointer = (void *)dword_4FCB34;
  if ( dword_4FCB34 )
  {
    if ( *(_DWORD *)(dword_4FCB34 + 4) )
    {
      free(*(void **)(dword_4FCB34 + 4));
      temp_pointer = (void *)dword_4FCB34;
    }
    free(temp_pointer);
    dword_4FCB34 = 0;
  }
}
// 7EB9C: using guessed type int globalLogLevel;
// 4FCB34: using guessed type int dword_4FCB34;

//----- (00036AA8) --------------------------------------------------------
void hardware_sweep_exit()
{
  char debug_message[2056]; // [sp+0h] [bp-808h] BYREF

  if ( (unsigned int)globalLogLevel > 4 )
  {
    strcpy(debug_message, "[DEBUG] HW sweep exit.\n");
    logMessage(4, debug_message, 0);
  }
  free_hardware_sweep_memory();
}
// 7EB9C: using guessed type int globalLogLevel;

//----- (00036B04) --------------------------------------------------------
int initialize_hardware_sweep()
{
  _DWORD *sweep_memory_ptr; // r6
  void *private_data_ptr; // r5
  char log_buffer[2064]; // [sp+0h] [bp-810h] BYREF

  if ( (unsigned int)globalLogLevel > 4 )
  {
    strcpy(log_buffer, "[DEBUG] HW sweep init.\n");
    logMessage(4, log_buffer, 0);
    if ( (unsigned int)globalLogLevel > 4 )
    {
      strcpy(log_buffer, "[DEBUG] Allocate memory for hw sweep.\n");
      logMessage(4, log_buffer, 0);
    }
  }
  if ( dword_4FCB34 )
    return 0;
  sweep_memory_ptr = calloc((size_t)&unk_8114AC, 1u);
  dword_4FCB34 = (int)sweep_memory_ptr;
  if ( !sweep_memory_ptr )
  {
    generate_error_message(13, 255);
    if ( (unsigned int)globalLogLevel > 3 )
    {
      strcpy(log_buffer, "Fail to allocate memory for hw sweep ctxt.\n");
      logMessage(3, log_buffer, 0);
      return -1;
    }
    return -1;
  }
  private_data_ptr = malloc(1024u);
  sweep_memory_ptr[1] = private_data_ptr;
  if ( !private_data_ptr )
  {
    free_hardware_sweep_memory();
    generate_error_message(13, 255);
    if ( (unsigned int)globalLogLevel > 3 )
    {
      strcpy(log_buffer, "Fail to allocate memory for hw sweep private data.\n");
      logMessage(3, log_buffer, 0);
    }
    return -1;
  }
  return 0;
}
// 7EB9C: using guessed type int globalLogLevel;
// 4FCB34: using guessed type int dword_4FCB34;

//----- (00036CA8) --------------------------------------------------------
int __fastcall updateNonceCounter(int chainIndex, int asicIndex, unsigned int nonce, int memoryBaseAddr)
{
  int chainMemoryOffset; // r9
  signed int nNonceCount; // r6
  int specificMemoryAddr; // r5
  unsigned __int16 completeNonce; // r11
  int globalMemoryAddr; // r10
  int currentNonceRate; // r0
  int rateIndex; // r1
  int *rateMemoryAddr; // r2
  int addrOffset; // r3
  int localAddrOffset; // r3
  int localAddrOffset2; // r3
  int localAddrOffset3; // r3
  int rateWorkMemoryAddr; // r9
  int result; // r0
  char logBuffer[2088]; // [sp+10h] [bp-828h] BYREF

  chainMemoryOffset = chainIndex << 8;
  nNonceCount = HIWORD(nonce);
  specificMemoryAddr = memoryBaseAddr + 4 * ((chainIndex << 8) + asicIndex) + 8388608;
  completeNonce = nonce;
  globalMemoryAddr = *(_DWORD *)(dword_4FCB34 + 4);
  *(_DWORD *)(memoryBaseAddr + 4 * ((chainIndex << 8) + asicIndex) + 8425472) += HIWORD(nonce);
  currentNonceRate = get_shared_value();
  addrOffset = 4 * chainIndex;
  if ( nNonceCount <= 8 * currentNonceRate )
    rateMemoryAddr = (int *)(memoryBaseAddr + addrOffset);
  localAddrOffset = memoryBaseAddr + addrOffset;
  if ( nNonceCount <= 8 * currentNonceRate )
    rateMemoryAddr += 2097152;
  localAddrOffset2 = localAddrOffset + 8388608;
  if ( nNonceCount <= 8 * currentNonceRate )
    rateMemoryAddr += 10240;
  localAddrOffset3 = localAddrOffset2 + 40960;
  if ( nNonceCount <= 8 * currentNonceRate )
    rateIndex = *rateMemoryAddr;
  rateWorkMemoryAddr = globalMemoryAddr + chainMemoryOffset;
  if ( nNonceCount <= 8 * currentNonceRate )
    *rateMemoryAddr = rateIndex + nNonceCount;
  *(_DWORD *)(localAddrOffset3 + 2144) += completeNonce - nNonceCount;
  *(_BYTE *)(rateWorkMemoryAddr + asicIndex) = 1;
  result = get_shared_value();
  if ( nNonceCount > 8 * result && (unsigned int)globalLogLevel > 3 )
  {
    snprintf(
      logBuffer,
      2048u,
      "Nonce counter overflow: chain = %d, asic = %d, nonce_return = %d, nonce_match = %d, nonce_accumulate = %d\n",
      chainIndex,
      asicIndex,
      completeNonce,
      nNonceCount,
      *(_DWORD *)(specificMemoryAddr + 36864));
    return logMessage(3, logBuffer, 0);
  }
  return result;
}
// 36D10: variable 'rateMemoryAddr' is possibly undefined
// 36D2C: variable 'rateIndex' is possibly undefined
// 7EB9C: using guessed type int globalLogLevel;
// 4FCB34: using guessed type int dword_4FCB34;

//----- (00036DBC) --------------------------------------------------------
char *__fastcall parse_miner_message(int message)
{
  int command_id; // r6
  unsigned int chip_id; // r5
  int unknown_value; // r0
  char *final_result; // r0
  unsigned int processed_value; // r7
  int message_type; // r8
  unsigned int calculated_offset; // r6

  command_id = *(unsigned __int8 *)(message + 2);
  chip_id = *(_BYTE *)message & 0xF;
  unknown_value = sub_1E160();
  if ( chip_id > 3 )
    return process_data_packet((char *)message);
  processed_value = unknown_value;
  message_type = *(unsigned __int8 *)(message + 1);
  if ( !get_global_buffer_value(chip_id) )
    return process_data_packet((char *)message);
  calculated_offset = call_external_function_with_check(command_id, processed_value);
  final_result = (char *)get_global_variable_value();
  if ( (unsigned int)final_result <= calculated_offset )
    return process_data_packet((char *)message);
  if ( message_type != 144 )
  {
    if ( message_type == 224 )
      return (char *)updateNonceCounter(chip_id, calculated_offset, *(_DWORD *)(message + 4), dword_4FCB34 + 8);
    return process_data_packet((char *)message);
  }
  if ( (*(_DWORD *)(message + 4) & 0x88) != 0 )
    *(_BYTE *)(*(_DWORD *)(dword_4FCB34 + 4) + (chip_id << 8) + calculated_offset) = 1;
  return final_result;
}
// 4FCB34: using guessed type int dword_4FCB34;

//----- (00036E7C) --------------------------------------------------------
bool __fastcall checkIfReadRegDone(int chainIndex)
{
  int baseAddress; // r4
  int totalCount; // r5
  unsigned __int8 *currentBytePtr; // r0
  unsigned __int8 *endPtr; // r2
  char logBuffer[2064]; // [sp+8h] [bp-810h] BYREF

  baseAddress = *(_DWORD *)(dword_4FCB34 + 4);
  if ( (unsigned int)globalLogLevel > 4 )
  {
    snprintf(logBuffer, 2048u, "[DEBUG] Check if read reg done, chain = %d, done_threshold = %d.\n", chainIndex, 1);
    logMessage(4, logBuffer, 0);
  }
  totalCount = get_global_variable_value();
  if ( totalCount )
  {
    currentBytePtr = (unsigned __int8 *)(baseAddress + (chainIndex << 8));
    endPtr = &currentBytePtr[totalCount];
    totalCount = 0;
    do
    {
      if ( *currentBytePtr++ )
        ++totalCount;
    }
    while ( currentBytePtr != endPtr );
  }
  return get_global_variable_value() == totalCount;
}
// 7EB9C: using guessed type int globalLogLevel;
// 4FCB34: using guessed type int dword_4FCB34;

//----- (00036F2C) --------------------------------------------------------
bool check_all_chips_status()
{
  int chip_index; // r4
  _BOOL4 is_ready; // r0

  chip_index = 0;
  while ( 1 )
  {
    if ( get_global_buffer_value(chip_index) )
    {
      is_ready = checkIfReadRegDone(chip_index);
      if ( !is_ready )
        break;
    }
    if ( ++chip_index == 4 )
      return 1;
  }
  return is_ready;
}

//----- (00036F6C) --------------------------------------------------------
int __fastcall initializeAndConfigureASIC(int maxFreqValue, int *logLevelPointer)
{
  int v3; // r0
  unsigned int logLevelGlobal; // r3
  int v5; // r1
  int v6; // r10
  int chipIndex; // r6
  char *debugMsgPtr; // r8
  int asic_version; // r0
  int chainIndex; // r4
  int v11; // r4
  int v12; // r0
  char v13; // r10
  int i; // r4
  int v15; // r4
  signed int v16; // r5
  int j; // r8
  __useconds_t v18; // r5
  int v19; // r6
  int k; // r4
  char *v21; // r7
  int v22; // r4
  int v23; // r9
  char *v24; // r11
  int m; // r4
  char *v27; // r4
  int global_variable_value; // r7
  char *v29; // r6
  int n; // r5
  int v31; // t1
  char v32; // r0
  char *v33; // r5
  char *v34; // r12
  int v35[34]; // [sp+0h] [bp-8C8h] BYREF
  unsigned int *v36; // [sp+88h] [bp-840h]
  char *debugString; // [sp+8Ch] [bp-83Ch]
  int v38; // [sp+90h] [bp-838h]
  int startupNonceOffsetCopy; // [sp+94h] [bp-834h]
  __int16 v40; // [sp+9Ch] [bp-82Ch]
  char v41; // [sp+9Eh] [bp-82Ah]
  char debugBuffer[16]; // [sp+A0h] [bp-828h] BYREF
  char src[132]; // [sp+B0h] [bp-818h] BYREF

  v3 = configurePulseAndDelays();
  logLevelGlobal = globalLogLevel;
  v5 = *logLevelPointer;
  v6 = BYTE2(v3);
  v40 = v3;
  v36 = (unsigned int *)BYTE1(v3);
  v38 = v5;
  v41 = BYTE2(v3);
  debugString = debugBuffer;
  if ( (unsigned int)globalLogLevel > 4 )
  {
    snprintf(debugBuffer, 2048u, "[DEBUG] Send work, max_freq = %d\n", v38);
    logMessage(4, debugBuffer, 0);
    logLevelGlobal = globalLogLevel;
  }
  chipIndex = 3;
  startupNonceOffsetCopy = v6;
  debugMsgPtr = debugString;
  if ( logLevelGlobal > 4 )
    goto LABEL_15;
  while ( 1 )
  {
    set_register_value(24, 0);
    asic_version = read_asic_version();
    chainIndex = 0;
    set_frequency(asic_version & 0xFFFF70FF | 0x8400);
    do
    {
      if ( get_global_buffer_value(chainIndex) )
        initialize_miner_with_parameters((unsigned __int8)chainIndex, 1, 0);
      ++chainIndex;
    }
    while ( chainIndex != 4 );
    if ( (unsigned int)globalLogLevel > 4 )
    {
      strcpy(debugMsgPtr, "[DEBUG] Send null work.\n");
      logMessage(4, debugMsgPtr, 0);
    }
    v11 = 0;
    memset(debugMsgPtr, 0, 148u);
    debugBuffer[0] = 1;
    do
    {
      if ( get_global_buffer_value(v11) )
      {
        while ( (read_chip_version() & (1 << v11)) == 0 )
          get_next_sleep_interval();
        debugBuffer[1] = v11 | 0x80;
        memcpy(v35, src, 132u);
        prepare_hash_input(
          *(_DWORD *)debugMsgPtr,
          *((_DWORD *)debugMsgPtr + 1),
          *((_DWORD *)debugMsgPtr + 2),
          *((_DWORD *)debugMsgPtr + 3),
          v35[0],
          v35[1],
          v35[2],
          v35[3],
          v35[4],
          v35[5],
          v35[6],
          v35[7],
          v35[8],
          v35[9],
          v35[10],
          v35[11],
          v35[12],
          v35[13],
          v35[14],
          v35[15],
          v35[16],
          v35[17],
          v35[18],
          v35[19],
          v35[20],
          v35[21],
          v35[22],
          v35[23],
          v35[24],
          v35[25],
          v35[26],
          v35[27],
          v35[28]);
        get_next_sleep_interval();
      }
      ++v11;
    }
    while ( v11 != 4 );
    sleep(1u);
    v12 = read_asic_version();
    set_frequency(v12 & 0xFFFF70FF | 0x8100);
    usleep((__useconds_t)&loc_186A0);
    if ( !--chipIndex )
      break;
    if ( (unsigned int)globalLogLevel > 4 )
    {
LABEL_15:
      strcpy(debugMsgPtr, "[DEBUG] Set start nonce offset invalid.\n");
      logMessage(4, debugMsgPtr, 0);
    }
  }
  v13 = startupNonceOffsetCopy;
  check_global_buffers_and_process(255, 1);
  process_command_for_global_buffer(255, (char)v36, v13, 1);
  send_midstate_work();
  usleep(100000u);
  send_midstate_work();
  usleep(100000u);
  send_midstate_work();
  usleep(100000u);
  do
  {
    if ( get_global_buffer_value(chipIndex) )
      set_reset_chip_flag((unsigned __int8)chipIndex, 0);
    ++chipIndex;
  }
  while ( chipIndex != 4 );
  for ( i = 0; i != 4; ++i )
  {
    if ( get_global_buffer_value(i) )
      enable_asic_boost_mode((unsigned __int8)i);
  }
  v15 = 3;
  v16 = 30000 - (v38 - 250) / 20u;
  do
  {
    for ( j = 0; j != 4; ++j )
    {
      if ( get_global_buffer_value(j) )
        initialize_asics_with_parameters((unsigned __int8)j, v16 / 333);
    }
    usleep((__useconds_t)&loc_186A0);
    --v15;
  }
  while ( v15 );
  do
  {
    if ( get_global_buffer_value(v15) )
      initialize_specific_asic_miner((unsigned __int8)v15, 8);
    ++v15;
  }
  while ( v15 != 4 );
  v18 = v16 + 1000;
  v19 = 8;
  do
  {
    for ( k = 0; k != 4; ++k )
    {
      if ( get_global_buffer_value(k) )
        enable_chip_mining((unsigned __int8)k);
    }
    usleep(v18);
    --v19;
  }
  while ( v19 );
  send_midstate_work();
  usleep(100000u);
  send_midstate_work();
  usleep(100000u);
  send_midstate_work();
  usleep(100000u);
  process_command_for_global_buffer(255, (char)v36, v13, 0);
  if ( (unsigned int)globalLogLevel > 4 )
  {
    v33 = debugString;
    v34 = debugString;
    *(_DWORD *)debugString = *(_DWORD *)"[DEBUG] Get nonce counter, chain.\n";
    strcpy(v34 + 4, "UG] Get nonce counter, chain.\n");
    logMessage(4, v33, 0);
    v21 = *(char **)(dword_4FCB34 + 4);
    if ( (unsigned int)globalLogLevel > 4 )
    {
      snprintf(v33, 2048u, "[DEBUG] Read reg and wait done, reg = %d, done_threshold = %d.\n", 224, 1);
      logMessage(4, v33, 0);
    }
  }
  else
  {
    v21 = *(char **)(dword_4FCB34 + 4);
  }
  memset(v21, 0, 1024u);
  v22 = 5;
  set_config_for_miner(255, 1, 0, 224);
  while ( !check_all_chips_status() )
  {
    usleep((__useconds_t)&loc_186A0);
    if ( !--v22 )
    {
      v36 = (unsigned int *)&globalLogLevel;
      v23 = 95;
      v24 = v21;
      while ( 1 )
      {
        for ( m = 0; m != 4; ++m )
        {
          if ( get_global_buffer_value(m) )
          {
            global_variable_value = get_global_variable_value();
            if ( global_variable_value )
            {
              v29 = &v24[256 * m];
              for ( n = 0; n != global_variable_value; ++n )
              {
                v31 = (unsigned __int8)*v29++;
                if ( v31 != 1 )
                {
                  v32 = sub_1E160();
                  set_config_for_miner((unsigned __int8)m, 0, v32 * n, 224);
                }
              }
            }
          }
        }
        usleep((__useconds_t)&loc_186A0);
        if ( check_all_chips_status() )
          break;
        if ( !--v23 )
        {
          if ( *v36 > 3 )
          {
            v27 = debugString;
            snprintf(debugString, 2048u, "Read REG[0x%X] done failed.\n", 224);
            logMessage(3, v27, 0);
          }
          return -1;
        }
      }
      return 0;
    }
  }
  return 0;
}
// 7EB9C: using guessed type int globalLogLevel;
// 4FCB34: using guessed type int dword_4FCB34;
// 36F6C: using guessed type int var_8C8[34];

//----- (00037574) --------------------------------------------------------
char **get_hardware_operations()
{
  char debug_message[2056]; // [sp-808h] [bp-808h] BYREF

  if ( (unsigned int)globalLogLevel > 4 )
  {
    strcpy(debug_message, "[DEBUG] Get hw ops.\n");
    logMessage(4, debug_message, 0);
  }
  return &off_7EDF0;
}
// 7EB9C: using guessed type int globalLogLevel;
// 7EDF0: using guessed type char *off_7EDF0;

//----- (000375E8) --------------------------------------------------------
int get_next_element_offset()
{
  return dword_4FCB38 + 8;
}
// 4FCB38: using guessed type int dword_4FCB38;

//----- (000375FC) --------------------------------------------------------
bool __fastcall is_recv_nonce_enough(int chain_index)
{
  unsigned int recv_nonce_count; // r5
  int expected_nonce_count; // r4
  char debug_log_buffer[2064]; // [sp+0h] [bp-810h] BYREF

  if ( (unsigned int)globalLogLevel > 4 )
  {
    snprintf(debug_log_buffer, 2048u, "[DEBUG] Check if is recv nonce enough, chain = %d.\n", chain_index);
    logMessage(4, debug_log_buffer, 0);
  }
  recv_nonce_count = *(_DWORD *)(dword_4FCB38 + 4 * ((_DWORD)&unk_202802 + chain_index));
  expected_nonce_count = 8 * get_shared_value();
  return recv_nonce_count >= get_global_variable_value() * expected_nonce_count;
}
// 7EB9C: using guessed type int globalLogLevel;
// 4FCB38: using guessed type int dword_4FCB38;

//----- (00037694) --------------------------------------------------------
int __fastcall checkDomainBalance(int chainIndex)
{
  unsigned int averageNonceCount; // r4
  int timeInterval1; // r0
  unsigned int adjustedNonceCount; // r4
  int timeInterval2; // r0
  unsigned int thresholdNonceCount; // r7
  int totalTimeInterval; // r10
  int i; // r5
  unsigned int j; // r4
  unsigned int currentDomainIndex; // r2
  int isUnbalanced; // [sp+14h] [bp-82Ch]
  char logBuffer[2088]; // [sp+18h] [bp-828h] BYREF

  averageNonceCount = *(_DWORD *)(dword_4FCB38 + 4 * (chainIndex + 2107394));
  timeInterval1 = get_global_state_value();
  adjustedNonceCount = calculate_bit_difficulty(averageNonceCount, timeInterval1);
  timeInterval2 = get_embedded_system_status();
  thresholdNonceCount = calculate_bit_difficulty(adjustedNonceCount, timeInterval2) >> 1;
  isUnbalanced = get_global_state_value();
  if ( !isUnbalanced )
    return 0;
  totalTimeInterval = 0;
  for ( i = 0; i != isUnbalanced; ++i )
  {
    for ( j = 0; get_embedded_system_status() > j; ++j )
    {
      currentDomainIndex = j + i * get_embedded_system_status();
      if ( *(_DWORD *)(dword_4FCB38 + 4 * ((_DWORD)&unk_202806 + 64 * chainIndex + currentDomainIndex)) < thresholdNonceCount )
      {
        totalTimeInterval = 1;
        if ( (unsigned int)globalLogLevel > 3 )
        {
          snprintf(
            logBuffer,
            2048u,
            "Domain unbalance happen, chain = %d, domain = %d, nonce_num_domain = %d, threshold = %d.\n",
            chainIndex,
            currentDomainIndex,
            *(_DWORD *)(dword_4FCB38 + 4 * ((_DWORD)&unk_202806 + 64 * chainIndex + currentDomainIndex)),
            thresholdNonceCount);
          logMessage(3, logBuffer, 0);
        }
      }
    }
  }
  return totalTimeInterval;
}
// 7EB9C: using guessed type int globalLogLevel;
// 4FCB38: using guessed type int dword_4FCB38;

//----- (000377B8) --------------------------------------------------------
void *clear_control_data()
{
  return memset((void *)(dword_4FCB38 + 8), 0, (size_t)&unk_80A8A4);
}
// 4FCB38: using guessed type int dword_4FCB38;

//----- (000377D8) --------------------------------------------------------
int __fastcall SendWorkToChain(int chainIndex)
{
  int v1; // r7
  int v2; // r9
  int v3; // r4
  int v4; // r11
  int v5; // r9
  _DWORD *v6; // r10
  char *v7; // r4
  int *v8; // r12
  int v9; // r0
  int v10; // r1
  char *v11; // lr
  int v12; // r2
  int v13; // r3
  int v14; // r5
  int v15; // r0
  _DWORD *v16; // r6
  int v17; // r1
  int v18; // r9
  int v19; // r2
  _DWORD *v20; // r12
  int v21; // r1
  int v22; // r2
  int v23; // r3
  char *v24; // r7
  _DWORD *v25; // lr
  _DWORD *v26; // lr
  int v27; // r1
  int v28; // r2
  int v29; // r3
  char *v30; // lr
  int v31; // r1
  int v32; // r2
  int v33; // r3
  bool v34; // zf
  unsigned int v35; // r4
  int v36; // r5
  int v37; // r3
  int v38; // r1
  _DWORD *v40; // r3
  int v41; // r1
  int v42; // lr
  int v43; // r0
  int v44; // r2
  int v45; // r0
  int v46; // r1
  int v47; // lr
  int v48; // r0
  int v49; // r0
  int v50; // r1
  int v51; // r3
  int v52[33]; // [sp+0h] [bp-9D0h] BYREF
  int *v53; // [sp+88h] [bp-948h]
  _DWORD *v54; // [sp+8Ch] [bp-944h]
  int v55; // [sp+90h] [bp-940h]
  int v56; // [sp+94h] [bp-93Ch]
  _DWORD *v57; // [sp+98h] [bp-938h]
  int v58; // [sp+9Ch] [bp-934h]
  int v59; // [sp+A0h] [bp-930h]
  int v60; // [sp+A4h] [bp-92Ch]
  int v61; // [sp+A8h] [bp-928h]
  _DWORD *v62; // [sp+ACh] [bp-924h]
  int v63; // [sp+B0h] [bp-920h]
  _DWORD *v64; // [sp+B4h] [bp-91Ch]
  int shared_value; // [sp+B8h] [bp-918h]
  int v66; // [sp+BCh] [bp-914h]
  int v67; // [sp+C0h] [bp-910h]
  int global_variable_value; // [sp+C4h] [bp-90Ch]
  void *v69; // [sp+C8h] [bp-908h]
  int *v70; // [sp+CCh] [bp-904h]
  __time_t v71[2]; // [sp+D0h] [bp-900h] BYREF
  __time_t v72[2]; // [sp+D8h] [bp-8F8h] BYREF
  char v73[20]; // [sp+E0h] [bp-8F0h] BYREF
  int v74; // [sp+F4h] [bp-8DCh]
  int v75; // [sp+F8h] [bp-8D8h]
  int v76; // [sp+FCh] [bp-8D4h]
  int v77; // [sp+100h] [bp-8D0h]
  int v78; // [sp+104h] [bp-8CCh]
  int v79; // [sp+108h] [bp-8C8h]
  int v80; // [sp+10Ch] [bp-8C4h]
  int v81; // [sp+110h] [bp-8C0h] BYREF
  _BYTE v82[148]; // [sp+114h] [bp-8BCh] BYREF
  char s[2088]; // [sp+1A8h] [bp-828h] BYREF

  v67 = chainIndex;
  v70 = &globalLogLevel;
  convert_timespec_to_custom_format(v71);
  if ( (unsigned int)globalLogLevel <= 3 || (strcpy(s, "\n"), append_log_message(3, s, 0), (unsigned int)*v70 <= 3) )
  {
    global_variable_value = get_global_variable_value();
    if ( !global_variable_value )
    {
LABEL_37:
      v1 = global_variable_value;
      goto LABEL_26;
    }
  }
  else
  {
    snprintf(s, 2048u, ">>>> Send work for chain %d.\n", v67);
    logMessage(3, s, 0);
    global_variable_value = get_global_variable_value();
    if ( !global_variable_value )
      goto LABEL_37;
  }
  v1 = 0;
  v56 = 0;
  v66 = 0;
  v69 = &unk_202A2A;
  v64 = &dword_80ACAC[1664 * v67];
  v2 = 1 << v67;
  do
  {
    v3 = *(_DWORD *)(dword_4FCB38 + 4 * ((_DWORD)v69 + v66) + 4);
    shared_value = get_shared_value();
    if ( shared_value )
    {
      v4 = v2;
      v5 = v1;
      v62 = (_DWORD *)(v3 + 20);
      v61 = 0;
      v63 = (unsigned __int8)~((unsigned int)~(v67 << 25) >> 25);
      do
      {
        v6 = v62;
        v60 = v61 & 3;
        v55 = 0;
        do
        {
          while ( (v4 & read_chip_version()) == 0 )
          {
            ++v5;
            usleep(1000u);
          }
          v7 = v73;
          v8 = v6 - 5;
          v54 = v6 - 5;
          do
          {
            v9 = *v8;
            v8 += 4;
            v10 = *(v8 - 3);
            v11 = v7;
            v12 = *(v8 - 2);
            v7 += 16;
            v13 = *(v8 - 1);
            *(_DWORD *)v11 = v9;
            *((_DWORD *)v11 + 1) = v10;
            *((_DWORD *)v11 + 2) = v12;
            *((_DWORD *)v11 + 3) = v13;
          }
          while ( v8 != v6 + 7 );
          v14 = 0;
          *(_DWORD *)v7 = *v8;
          memset(&v82[2], 0, 146u);
          v15 = *(v6 - 3);
          v59 = v5;
          v16 = &v64[13 * v56];
          v17 = *(v6 - 2);
          v18 = v60;
          v82[1] = v63;
          v19 = *(v6 - 1);
          LOBYTE(v74) = v74 + 1;
          *(_DWORD *)&v82[8] = v15;
          *(_DWORD *)&v82[12] = v17;
          *(_DWORD *)&v82[16] = v19;
          v53 = &v81;
          v58 = v4;
          *(_DWORD *)&v82[4] = v56 & 0x7F | v55;
          v57 = v54 + 12;
          v82[0] = 1;
          do
          {
            v20 = (_DWORD *)((char *)v16 + dword_4FCB38);
            if ( v14 == v18 )
            {
              v40 = &v82[32 * v14 + 20];
              v41 = v6[1];
              v42 = v6[2];
              *v40 = *v6;
              v43 = v6[3];
              v44 = (int)v54;
              v40[1] = v41;
              v40[3] = v43;
              v45 = v6[4];
              v40[2] = v42;
              v46 = v6[5];
              v47 = v6[6];
              v40[4] = v45;
              v48 = v6[7];
              v40[5] = v46;
              v40[6] = v47;
              v40[7] = v48;
              do
              {
                v44 += 16;
                v20 += 4;
                v49 = *(_DWORD *)(v44 - 12);
                v50 = *(_DWORD *)(v44 - 8);
                v51 = *(_DWORD *)(v44 - 4);
                v34 = v44 == (_DWORD)v57;
                *(v20 - 4) = *(_DWORD *)(v44 - 16);
                *(v20 - 3) = v49;
                *(v20 - 2) = v50;
                *(v20 - 1) = v51;
              }
              while ( !v34 );
              *v20 = *v57;
            }
            else
            {
              v21 = v75;
              v22 = v76;
              v23 = v77;
              v24 = v73;
              v25 = &v82[32 * v14 + 20];
              *v25 = v74;
              v25[1] = v21;
              v25[2] = v22;
              v25[3] = v23;
              v26 = &v82[32 * v14 + 36];
              v27 = v79;
              v28 = v80;
              v29 = v81;
              *v26 = v78;
              v26[1] = v27;
              v26[2] = v28;
              v26[3] = v29;
              do
              {
                v30 = v24;
                v24 += 16;
                v20 += 4;
                v31 = *((_DWORD *)v30 + 1);
                v32 = *((_DWORD *)v30 + 2);
                v33 = *((_DWORD *)v30 + 3);
                v34 = v30 + 16 == (char *)v53;
                *(v20 - 4) = *(_DWORD *)v30;
                *(v20 - 3) = v31;
                *(v20 - 2) = v32;
                *(v20 - 1) = v33;
              }
              while ( !v34 );
              *v20 = *(_DWORD *)v24;
            }
            ++v14;
            v16 += 13;
          }
          while ( v14 != 4 );
          v4 = v58;
          v6 += 13;
          v35 = v56 + 4;
          v5 = v59;
          memcpy(v52, &v82[16], sizeof(v52));
          v36 = v55 + 128;
          v55 += 128;
          prepare_hash_input(
            *(unsigned int *)v82,
            *(int *)&v82[4],
            *(int *)&v82[8],
            *(int *)&v82[12],
            v52[0],
            v52[1],
            v52[2],
            v52[3],
            v52[4],
            v52[5],
            v52[6],
            v52[7],
            v52[8],
            v52[9],
            v52[10],
            v52[11],
            v52[12],
            v52[13],
            v52[14],
            v52[15],
            v52[16],
            v52[17],
            v52[18],
            v52[19],
            v52[20],
            v52[21],
            v52[22],
            v52[23],
            v52[24],
            v52[25],
            v52[26],
            v52[27],
            v52[28]);
          if ( v35 >= 128 )
            v37 = 0;
          else
            v37 = v35;
          v56 = v37;
        }
        while ( v36 != 1024 );
        v62 += 104;
        ++v61;
      }
      while ( shared_value != v61 );
      v1 = v5;
      v2 = v4;
    }
    v34 = global_variable_value == ++v66;
  }
  while ( !v34 );
LABEL_26:
  convert_timespec_to_custom_format(v72);
  v38 = v72[0] - v71[0];
  if ( v72[1] - v71[1] < 0 )
    --v38;
  if ( (unsigned int)*v70 > 3 )
  {
    snprintf(s, 2048u, "Send work for chain %d done, time cost %lds, sleep_count = %d\n", v67, v38, v1);
    logMessage(3, s, 0);
  }
  return 0;
}
// 7EB9C: using guessed type int globalLogLevel;
// 4FCB38: using guessed type int dword_4FCB38;
// 80ACAC: using guessed type _DWORD dword_80ACAC[6656];

//----- (00037C4C) --------------------------------------------------------
unsigned int __fastcall process_chip_status(int data_buffer)
{
  unsigned int asic_chip_status; // r7
  int timestamp; // r0
  unsigned int asic_voltage_status; // r8
  unsigned int chip_index; // r4
  int work_id_flags; // r6
  unsigned int nonce_high_byte; // r10
  unsigned int process_result; // r0
  unsigned int shared_buffer_value; // r9
  int work_id_upper; // r5
  unsigned int calculated_nonce_value; // r9
  _BOOL4 nonce_threshold_exceeded; // r3
  int status_base_address; // r2
  int count_address; // r2
  int incremented_count; // r2
  unsigned int status_buffer_offset; // r3
  int work_id_mask; // r5
  int work_status_address; // r1
  int current_work_status; // r12

  asic_chip_status = *(_DWORD *)(data_buffer + 4);
  timestamp = sub_1E160();
  asic_voltage_status = get_voltage_status(asic_chip_status, timestamp);
  chip_index = *(_BYTE *)data_buffer & 0xF;
  work_id_flags = *(_WORD *)(data_buffer + 2) & 0x7FFF;
  nonce_high_byte = get_high_byte(asic_chip_status);
  process_result = sub_1E140();
  if ( chip_index <= 3
    && (shared_buffer_value = process_result, (process_result = get_global_buffer_value(chip_index)) != 0) )
  {
    if ( (*(_BYTE *)data_buffer & 0x20) != 0 )
    {
      ++*(_DWORD *)(dword_4FCB38 + 4 * chip_index + 8431656);
    }
    else if ( (*(_BYTE *)data_buffer & 0x40) != 0 )
    {
      ++*(_DWORD *)(dword_4FCB38 + 4 * chip_index + 8431672);
    }
    else if ( (*(_BYTE *)data_buffer & 0x80) != 0 )
    {
      process_result = get_global_variable_value();
      if ( process_result > asic_voltage_status )
      {
        work_id_upper = work_id_flags >> 7;
        calculated_nonce_value = (work_id_flags & 3) + shared_buffer_value * nonce_high_byte;
        process_result = get_shared_value();
        nonce_threshold_exceeded = work_id_flags >> 7 > 7;
        if ( process_result <= calculated_nonce_value )
          nonce_threshold_exceeded = 1;
        if ( nonce_threshold_exceeded )
        {
          ++*(_DWORD *)(dword_4FCB38 + 4 * chip_index + 8431720);
        }
        else
        {
          process_result = 52;
          status_base_address = dword_4FCB38;
          if ( *(_DWORD *)(*(_DWORD *)(dword_4FCB38 + 4 * ((_DWORD)&unk_202A2A + asic_voltage_status) + 4)
                         + 52 * work_id_upper
                         + 416 * calculated_nonce_value
                         + 4) == asic_chip_status )
          {
            status_buffer_offset = asic_voltage_status + (chip_index << 8);
            work_id_mask = 1 << work_id_upper;
            work_status_address = dword_4FCB38 + 4 * (calculated_nonce_value + (status_buffer_offset << 10));
            current_work_status = *(_DWORD *)(work_status_address + 8);
            if ( (current_work_status & work_id_mask) != 0 )
            {
              ++*(_DWORD *)(dword_4FCB38 + 4 * chip_index + 8431640);
            }
            else
            {
              process_result = work_status_address + 4231168;
              *(_DWORD *)(work_status_address + 8) = current_work_status | work_id_mask;
              ++*(_DWORD *)(work_status_address + 4231176);
              ++*(_DWORD *)(status_base_address + 4 * status_buffer_offset + 8425480);
              ++*(_DWORD *)(status_base_address + 4 * chip_index + 8429576);
            }
          }
          else
          {
            process_result = calculate_miner_hash(
                               (_DWORD *)((char *)&dword_80ACAC[1664 * chip_index + 13 * (work_id_flags & 0x7F)]
                                        + dword_4FCB38),
                               asic_chip_status);
            if ( process_result )
              count_address = *(_DWORD *)(dword_4FCB38 + 4 * chip_index + 8431704);
            else
              count_address = *(_DWORD *)(dword_4FCB38 + 4 * chip_index + 8431720);
            incremented_count = count_address + 1;
            if ( process_result )
              *(_DWORD *)(dword_4FCB38 + 4 * chip_index + 8431704) = incremented_count;
            else
              *(_DWORD *)(dword_4FCB38 + 4 * chip_index + 8431720) = incremented_count;
          }
        }
      }
      else
      {
        ++*(_DWORD *)(dword_4FCB38 + 4 * chip_index + 8431756);
      }
    }
    else
    {
      ++*(_DWORD *)(dword_4FCB38 + 4 * chip_index + 8431688);
    }
  }
  else
  {
    ++*(_DWORD *)(dword_4FCB38 + 8431752);
  }
  return process_result;
}
// 4FCB38: using guessed type int dword_4FCB38;
// 80ACAC: using guessed type _DWORD dword_80ACAC[6656];

//----- (00037F08) --------------------------------------------------------
void free_device_resources()
{
  void **resource_table_ptr; // r6
  int device_count; // r9
  int device_index; // r5
  char *resource_entry; // r2
  char *resource_offset; // r4
  int resource_ptr_index; // r4

  LOWORD(resource_table_ptr) = (unsigned __int16)&dword_4FCB38;
  device_count = get_global_variable_value();
  if ( device_count )
  {
    HIWORD(resource_table_ptr) = (unsigned int)&dword_4FCB38 >> 16;
    device_index = 0;
    resource_entry = (char *)*resource_table_ptr;
    do
    {
      resource_offset = (char *)&unk_202A2A + device_index++;
      resource_ptr_index = 4 * (_DWORD)resource_offset;
      if ( *(_DWORD *)&resource_entry[resource_ptr_index + 4] )
      {
        free(*(void **)&resource_entry[resource_ptr_index + 4]);
        resource_entry = (char *)*resource_table_ptr;
        *(_DWORD *)((char *)*resource_table_ptr + resource_ptr_index + 4) = 0;
      }
    }
    while ( device_count != device_index );
  }
  else
  {
    HIWORD(resource_table_ptr) = (unsigned int)&dword_4FCB38 >> 16;
    resource_entry = (char *)*resource_table_ptr;
  }
  free(resource_entry);
  *resource_table_ptr = 0;
}
// 4FCB38: using guessed type int dword_4FCB38;

//----- (00037F88) --------------------------------------------------------
void check_and_free_device_resources()
{
  if ( dword_4FCB38 )
    free_device_resources();
}
// 4FCB38: using guessed type int dword_4FCB38;

//----- (00037FA0) --------------------------------------------------------
int __fastcall load_core_pattern(FILE **file_stream, int chip_index, int core_group, int core_count)
{
  int core_offset; // r6
  int current_core; // r7
  int temp_var_1; // r1
  int temp_var_2; // r2
  int temp_var_3; // r3
  int temp_var_4; // r1
  int temp_var_5; // r2
  int temp_var_6; // r3
  int temp_var_7; // r0
  int temp_var_8; // r1
  int temp_var_9; // r2
  int core_id; // r5
  int core_data_base_addr; // r8
  _DWORD *core_data_ptr; // r4
  int chip_data_offset; // [sp+4h] [bp-864h]
  _DWORD core_data_buffer[12]; // [sp+10h] [bp-858h] BYREF
  char error_message[2088]; // [sp+40h] [bp-828h] BYREF

  if ( core_count )
  {
    core_offset = 52 * core_group * core_count;
    chip_data_offset = 4 * ((_DWORD)&unk_202A2A + chip_index);
    current_core = 0;
    while ( 1 )
    {
      core_id = current_core++;
      core_data_base_addr = *(_DWORD *)(dword_4FCB38 + chip_data_offset + 4);
      core_data_ptr = (_DWORD *)(core_data_base_addr + core_offset);
      if ( fread(core_data_buffer, 1u, 48u, *file_stream) != 48 )
        break;
      core_data_ptr[1] = core_data_buffer[0];
      temp_var_1 = core_data_buffer[5];
      temp_var_2 = core_data_buffer[6];
      temp_var_3 = core_data_buffer[7];
      core_data_ptr[5] = core_data_buffer[4];
      *(_DWORD *)(core_data_base_addr + core_offset + 24) = temp_var_1;
      *(_DWORD *)(core_data_base_addr + core_offset + 28) = temp_var_2;
      *(_DWORD *)(core_data_base_addr + core_offset + 32) = temp_var_3;
      temp_var_4 = core_data_buffer[9];
      temp_var_5 = core_data_buffer[10];
      temp_var_6 = core_data_buffer[11];
      *(_DWORD *)(core_data_base_addr + core_offset + 36) = core_data_buffer[8];
      *(_DWORD *)(core_data_base_addr + core_offset + 40) = temp_var_4;
      *(_DWORD *)(core_data_base_addr + core_offset + 44) = temp_var_5;
      temp_var_7 = core_data_buffer[1];
      temp_var_8 = core_data_buffer[2];
      temp_var_9 = core_data_buffer[3];
      *(_DWORD *)(core_data_base_addr + core_offset + 48) = temp_var_6;
      core_data_ptr[2] = temp_var_7;
      *(_DWORD *)(core_data_base_addr + core_offset + 12) = temp_var_8;
      *(_DWORD *)(core_data_base_addr + core_offset + 16) = temp_var_9;
      *(_DWORD *)(core_data_base_addr + core_offset) = core_id;
      core_offset += 52;
      if ( current_core == core_count )
        return current_core;
    }
    if ( (unsigned int)globalLogLevel <= 3 )
      return core_id;
    strcpy(error_message, "Load core pattern failed!\n");
    logMessage(3, error_message, 0);
    return core_id;
  }
  else
  {
    return 0;
  }
}
// 7EB9C: using guessed type int globalLogLevel;
// 4FCB38: using guessed type int dword_4FCB38;

//----- (00038110) --------------------------------------------------------
int __fastcall loadPatternFile(int patternFilePath)
{
  int *v2; // r10
  const char *v3; // r5
  int v4; // r9
  int v5; // r6
  int v6; // r7
  unsigned int v7; // r5
  int i; // r4
  int v9; // r2
  int v10; // r4
  int global_variable_value; // r9
  int *v13; // r11
  int shared_value; // r0
  void *v15; // r0
  int *v16; // r3
  int v17; // r3
  int v18; // r0
  FILE *stream; // [sp+Ch] [bp-82Ch] BYREF
  char s[2088]; // [sp+10h] [bp-828h] BYREF

  if ( (unsigned int)globalLogLevel > 4 )
  {
    strcpy(s, "[DEBUG] Free memory for sw sweep.\n");
    logMessage(4, s, 0);
  }
  v2 = (int *)dword_4FCB38;
  if ( !dword_4FCB38 )
  {
    dword_4FCB38 = (int)calloc((size_t)&unk_8114AC, 1u);
    if ( dword_4FCB38 )
    {
      global_variable_value = get_global_variable_value();
      if ( !global_variable_value )
      {
        v2 = (int *)dword_4FCB38;
        goto LABEL_4;
      }
      v13 = v2;
      while ( 1 )
      {
        shared_value = get_shared_value();
        v2 = (int *)dword_4FCB38;
        v15 = malloc(416 * shared_value);
        v16 = &v2[(int)&unk_202A2A + (_DWORD)v13];
        v13 = (int *)((char *)v13 + 1);
        v16[1] = (int)v15;
        if ( !v15 )
          break;
        if ( (int *)global_variable_value == v13 )
          goto LABEL_4;
      }
      if ( (unsigned int)globalLogLevel <= 3 )
      {
LABEL_27:
        free_device_resources();
LABEL_28:
        generate_error_message(13, 255);
        return -1;
      }
      strcpy(s, "Fail to allocate memory for works.\n");
      logMessage(3, s, 0);
      v17 = dword_4FCB38;
    }
    else
    {
      if ( (unsigned int)globalLogLevel <= 3 )
        goto LABEL_28;
      strcpy(s, "Fail to allocate memory for sw sweep ctxt.\n");
      logMessage(3, s, 0);
      v17 = dword_4FCB38;
    }
    if ( !v17 )
      goto LABEL_28;
    goto LABEL_27;
  }
LABEL_4:
  *v2 = patternFilePath;
  v3 = *(const char **)dword_4FCB38;
  stream = (FILE *)fopen64(*(_DWORD *)dword_4FCB38, "r");
  if ( !stream )
  {
    if ( (unsigned int)globalLogLevel > 3 )
    {
      snprintf(s, 2048u, "Fail to open pattern file %s.\n", v3);
      logMessage(3, s, 0);
    }
LABEL_16:
    generate_error_message(22, 255);
    v10 = -1;
    if ( (unsigned int)globalLogLevel > 3 )
    {
      strcpy(s, "Load pattern file failed.\n");
      logMessage(3, s, 0);
    }
    goto LABEL_18;
  }
  v4 = get_global_variable_value();
  if ( v4 )
  {
    v5 = 0;
    while ( 1 )
    {
      v6 = get_shared_value();
      if ( v6 )
      {
        v7 = 0;
        for ( i = 0; i != v6; ++i )
        {
          v9 = i;
          v7 += load_core_pattern(&stream, v5, v9, 8);
        }
      }
      else
      {
        v7 = 0;
      }
      if ( v7 < 8 * get_shared_value() )
        break;
      if ( v4 == ++v5 )
        goto LABEL_13;
    }
    if ( (unsigned int)globalLogLevel > 3 )
    {
      v18 = get_shared_value();
      snprintf(s, 2048u, "No enough work, asic = %d, work_count = %d, work_count_target = %d.\n", v5, v7, 8 * v18);
      logMessage(3, s, 0);
    }
    fclose(stream);
    goto LABEL_16;
  }
LABEL_13:
  v10 = 0;
  fclose(stream);
LABEL_18:
  disable_register_protection();
  set_fan_speed_by_percentage(4);
  return v10;
}
// 124E4: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 7EB9C: using guessed type int globalLogLevel;
// 4FCB38: using guessed type int dword_4FCB38;

//----- (00038450) --------------------------------------------------------
char **get_software_operations()
{
  char debug_message[2056]; // [sp-808h] [bp-808h] BYREF

  if ( (unsigned int)globalLogLevel > 4 )
  {
    strcpy(debug_message, "[DEBUG] Get sw ops.\n");
    logMessage(4, debug_message, 0);
  }
  return &off_7EE1C;
}
// 7EB9C: using guessed type int globalLogLevel;
// 7EE1C: using guessed type char *off_7EE1C;

//----- (000384C0) --------------------------------------------------------
int __fastcall log_input_value_error(int input_value)
{
  char error_message[2056]; // [sp-808h] [bp-808h] BYREF

  if ( (unsigned int)globalLogLevel > 1 )
  {
    snprintf(error_message, 2048u, "input value error: %c\n", input_value);
    logMessage(1, error_message, 0);
  }
  return 255;
}
// 7EB9C: using guessed type int globalLogLevel;

//----- (00038520) --------------------------------------------------------
int __fastcall hex_char_to_int(int input_char)
{
  int upper_char; // r3

  if ( (unsigned int)(input_char - 48) <= 9 )
    return input_char & 0xF;
  upper_char = input_char & 0xDF;
  switch ( upper_char )
  {
    case 'A':
      return 10;
    case 'B':
      return 11;
    case 'C':
      return 12;
    case 'D':
      return 13;
    case 'E':
      return 14;
    case 'F':
      return 15;
  }
  return log_input_value_error(input_char);
}

//----- (0003859C) --------------------------------------------------------
int __fastcall convert_hex_to_bin(_BYTE *bin_buffer, unsigned __int8 *hex_string, int hex_string_len)
{
  bool is_invalid; // cc
  int is_invalid_or_no_source; // r3
  int num_full_bytes; // r7
  unsigned __int8 *end_ptr; // r8
  unsigned __int8 *current_hex_ptr; // r4
  _BYTE *current_bin_ptr; // r11
  int next_hex_char; // r6
  int current_hex_char; // t1
  char current_bin_nibble; // r5
  char last_bin_nibble; // r4
  int has_remaining_nibble; // [sp+Ch] [bp-82Ch]
  char log_buffer[2088]; // [sp+10h] [bp-828h] BYREF

  is_invalid = (int)bin_buffer <= 0;
  if ( bin_buffer )
    is_invalid = hex_string_len <= 0;
  is_invalid_or_no_source = is_invalid;
  if ( !hex_string )
    is_invalid_or_no_source = 1;
  if ( is_invalid_or_no_source )
  {
    if ( (unsigned int)globalLogLevel > 4 )
    {
      snprintf(
        log_buffer,
        2048u,
        "s2hex para error dst(%p), src(%p), inlen(%d)\n",
        bin_buffer,
        hex_string,
        hex_string_len);
      logMessage(4, log_buffer, 0);
    }
    return -1;
  }
  else
  {
    num_full_bytes = hex_string_len >> 1;
    has_remaining_nibble = hex_string_len & 1;
    if ( hex_string_len >> 1 )
    {
      end_ptr = &hex_string[2 * num_full_bytes];
      current_hex_ptr = hex_string;
      current_bin_ptr = bin_buffer - 1;
      do
      {
        next_hex_char = current_hex_ptr[1];
        current_hex_char = *current_hex_ptr;
        current_hex_ptr += 2;
        current_bin_nibble = hex_char_to_int(current_hex_char);
        *++current_bin_ptr = hex_char_to_int(next_hex_char) ^ (16 * current_bin_nibble);
      }
      while ( current_hex_ptr != end_ptr );
    }
    if ( has_remaining_nibble )
    {
      last_bin_nibble = hex_char_to_int(hex_string[2 * num_full_bytes]);
      bin_buffer[num_full_bytes] = log_input_value_error(0) ^ (16 * last_bin_nibble);
    }
    return num_full_bytes + has_remaining_nibble;
  }
}
// 7EB9C: using guessed type int globalLogLevel;

//----- (000386BC) --------------------------------------------------------
unsigned int __fastcall calculate_miner_hash(_DWORD *input_data, unsigned int nonce)
{
  unsigned int hash_success; // r0
  int param6; // r1
  int param7; // r2
  int param8; // r3
  int param10; // r1
  int param11; // r2
  int param12; // r3
  _DWORD *input_data_offset; // r4
  unsigned int input_data_value; // t1
  unsigned int input_data_next_value; // r1
  unsigned int input_data_third_value; // r2
  unsigned int *hash_word_ptr; // r2
  unsigned int *hashed_data_ptr; // r1
  unsigned int word_to_swap; // t1
  unsigned int hash_buffer[8]; // [sp+0h] [bp-138h] BYREF
  char calculated_hash[32]; // [sp+20h] [bp-118h] BYREF
  int sha256_state[62]; // [sp+40h] [bp-F8h] BYREF

  memset(hash_buffer, 0, sizeof(hash_buffer));
  memset(calculated_hash, 0, sizeof(calculated_hash));
  if ( !input_data )
    return 0;
  param6 = input_data[6];
  param7 = input_data[7];
  param8 = input_data[8];
  sha256_state[2] = input_data[5];
  sha256_state[3] = param6;
  sha256_state[4] = param7;
  sha256_state[5] = param8;
  param10 = input_data[10];
  param11 = input_data[11];
  param12 = input_data[12];
  sha256_state[6] = input_data[9];
  sha256_state[7] = param10;
  sha256_state[8] = param11;
  sha256_state[9] = param12;
  reverse_memory_block(&sha256_state[2], 32);
  input_data_value = input_data[2];
  input_data_offset = input_data + 2;
  sha256_state[0] = 80;
  sha256_state[1] = 0;
  input_data_next_value = input_data_offset[1];
  input_data_third_value = input_data_offset[2];
  hash_buffer[0] = input_data_value;
  hash_buffer[1] = input_data_next_value;
  hash_buffer[2] = input_data_third_value;
  reverse_memory_block(hash_buffer, 12);
  reverse_copy_with_byte_swap((int)&sha256_state[10], hash_buffer, 12u);
  hash_buffer[0] = bswap32(nonce);
  reverse_memory_block(hash_buffer, 4);
  reverse_copy_with_byte_swap((int)&sha256_state[13], hash_buffer, 4u);
  finalize_sha256_state((int)sha256_state, hash_buffer);
  memset(sha256_state, 0, 232u);
  compute_sha256_hash(hash_buffer, 32, calculated_hash);
  hash_word_ptr = &hash_buffer[7];
  hashed_data_ptr = &hash_buffer[-1];
  do
  {
    word_to_swap = hash_word_ptr[1];
    ++hash_word_ptr;
    hashed_data_ptr[1] = bswap32(word_to_swap);
    ++hashed_data_ptr;
  }
  while ( hash_word_ptr != (unsigned int *)&calculated_hash[28] );
  hash_success = hash_buffer[7];
  if ( hash_buffer[7] )
    return 1;
  return hash_success;
}

//----- (000387F8) --------------------------------------------------------
int log_null_handle_error()
{
  char error_message[2056]; // [sp+0h] [bp-808h] BYREF

  strcpy(error_message, "Handle is NULL.\n");
  return logMessage(3, error_message, 0);
}

//----- (0003883C) --------------------------------------------------------
int __fastcall send_work_to_chain(_DWORD *chain_info)
{
  int stm32_handle; // r3
  char debug_message[2064]; // [sp+0h] [bp-810h] BYREF

  if ( (unsigned int)globalLogLevel > 4 )
  {
    snprintf(debug_message, 2048u, "[DEBUG] Send work one chain, chain = %d.\n", *chain_info);
    logMessage(4, debug_message, 0);
  }
  if ( dword_4FCB3C )
  {
    stm32_handle = *(_DWORD *)(dword_4FCB3C + 4);
    if ( stm32_handle )
    {
      (*(void (__fastcall **)(_DWORD, _DWORD))(stm32_handle + 28))(*chain_info, chain_info[2]);
      chain_info[1] = 1;
      return 0;
    }
  }
  if ( (unsigned int)globalLogLevel <= 3 )
    return 0;
  log_null_handle_error();
  return 0;
}
// 7EB9C: using guessed type int globalLogLevel;
// 4FCB3C: using guessed type int dword_4FCB3C;

//----- (000388F4) --------------------------------------------------------
int sub_388F4()
{
  char null_handle_message[2056]; // [sp+0h] [bp-808h] BYREF

  strcpy(null_handle_message, "Handle is NULL.\n");
  logMessage(3, null_handle_message, 0);
  return 1;
}

//----- (0003893C) --------------------------------------------------------
int __fastcall send_work_for_hw_sweep(int status)
{
  int hardware_identifier; // r5
  int sweep_function_pointer; // r3
  char debug_message[2064]; // [sp+0h] [bp-810h] BYREF

  hardware_identifier = status;
  if ( (unsigned int)globalLogLevel > 4 )
  {
    strcpy(debug_message, "[DEBUG] Send work for hw sweep.\n");
    status = logMessage(4, debug_message, 0);
  }
  if ( dword_4FCB3C )
  {
    sweep_function_pointer = *(_DWORD *)(dword_4FCB3C + 4);
    if ( sweep_function_pointer )
      return (*(int (__fastcall **)(int, int))(sweep_function_pointer + 28))(255, hardware_identifier);
  }
  if ( (unsigned int)globalLogLevel > 3 )
    return log_null_handle_error();
  return status;
}
// 7EB9C: using guessed type int globalLogLevel;
// 4FCB3C: using guessed type int dword_4FCB3C;

//----- (000389F0) --------------------------------------------------------
int __fastcall start_mining_threads(int chain_index)
{
  char *thread_arg; // r6
  int initial_chain_value; // r8
  int chain_id; // r4
  int chain_counter; // r4
  int thread_ids[4]; // [sp+0h] [bp-830h] BYREF
  char thread_args_buffer[2080]; // [sp+10h] [bp-820h] BYREF

  if ( dword_4FCB3C && *(_DWORD *)(dword_4FCB3C + 4) )
  {
    thread_arg = thread_args_buffer;
    initial_chain_value = chain_index;
    chain_id = 0;
    memset(thread_ids, 0, sizeof(thread_ids));
    memset(thread_args_buffer, 0, 48u);
    do
    {
      if ( get_global_buffer_value(chain_id) && *(_DWORD *)(dword_4FCB3C + 4 * (chain_id + 2)) == 1 )
      {
        *(_DWORD *)thread_arg = chain_id;
        *((_DWORD *)thread_arg + 1) = 0;
        *((_DWORD *)thread_arg + 2) = initial_chain_value;
        pthread_create((pthread_t *)&thread_ids[chain_id], 0, (void *(*)(void *))send_work_to_chain, thread_arg);
        pthread_detach(thread_ids[chain_id]);
      }
      ++chain_id;
      thread_arg += 12;
    }
    while ( chain_id != 4 );
    for ( chain_counter = 0; chain_counter != 4; ++chain_counter )
    {
      while ( 1 )
      {
        chain_index = get_global_buffer_value(chain_counter);
        if ( !chain_index || !thread_ids[chain_counter] || *(_DWORD *)&thread_args_buffer[12 * chain_counter + 4] )
          break;
        chain_counter = 0;
        usleep((__useconds_t)&loc_186A0);
      }
    }
  }
  else if ( (unsigned int)globalLogLevel > 3 )
  {
    strcpy(thread_args_buffer, "Handle is NULL.\n");
    return logMessage(3, thread_args_buffer, 0);
  }
  return chain_index;
}
// 7EB9C: using guessed type int globalLogLevel;
// 4FCB3C: using guessed type int dword_4FCB3C;

//----- (00038B6C) --------------------------------------------------------
int __fastcall sub_38B6C(int data_index, int data_offset)
{
  int number_of_elements; // r0
  int sum_of_elements; // r4
  char *end_pointer; // r0
  char *current_pointer; // r3
  int current_element; // t1
  int global_average; // r0
  int computed_average; // r5
  int global_standard_deviation_count; // r0
  char *square_difference_pointer; // r2
  int sum_of_square_differences; // r4
  int element_difference; // t1
  int global_calculated_value; // r0
  double standard_deviation; // r0

  number_of_elements = get_global_variable_value();
  if ( number_of_elements > 0 )
  {
    end_pointer = (char *)&unk_808FFC + 1024 * data_index + 4 * number_of_elements + data_offset;
    current_pointer = (char *)&unk_808FFC + 1024 * data_index + data_offset;
    sum_of_elements = 0;
    do
    {
      current_element = *((_DWORD *)current_pointer + 1);
      current_pointer += 4;
      sum_of_elements += current_element;
    }
    while ( current_pointer != end_pointer );
  }
  else
  {
    sum_of_elements = 0;
  }
  global_average = get_global_variable_value();
  computed_average = call_external_function_with_check(sum_of_elements, global_average);
  global_standard_deviation_count = get_global_variable_value();
  if ( global_standard_deviation_count <= 0 )
    return get_global_variable_value();
  square_difference_pointer = (char *)&unk_808FFC + 1024 * data_index + data_offset;
  sum_of_square_differences = 0;
  do
  {
    element_difference = *((_DWORD *)square_difference_pointer + 1);
    square_difference_pointer += 4;
    sum_of_square_differences += (element_difference - computed_average) * (element_difference - computed_average);
  }
  while ( square_difference_pointer != (char *)&unk_808FFC
                                     + 1024 * data_index
                                     + 4 * global_standard_deviation_count
                                     + data_offset );
  global_calculated_value = get_global_variable_value();
  LODWORD(standard_deviation) = call_external_function_with_check(sum_of_square_differences, global_calculated_value);
  if ( (double)SLODWORD(standard_deviation) < 0.0 )
    standard_deviation = sqrt(standard_deviation);
  return LODWORD(standard_deviation);
}
// 38C64: variable 'standard_deviation' is possibly undefined

//----- (00038C70) --------------------------------------------------------
int __fastcall set_operation_mode(int sweep_type, const char *pattern_file_path)
{
  unsigned int adjusted_sweep_type; // r6
  _DWORD *operation_context_ptr; // r8
  _DWORD *new_context; // r0
  char log_buffer[2072]; // [sp+8h] [bp-818h] BYREF

  adjusted_sweep_type = sweep_type - 160;
  if ( (unsigned int)globalLogLevel > 4 )
  {
    snprintf(log_buffer, 2048u, "[DEBUG] sweep_type = 0x%X, pattern_file_path = %s\n", sweep_type, pattern_file_path);
    logMessage(4, log_buffer, 0);
    if ( adjusted_sweep_type > 1 )
      goto LABEL_3;
    if ( (unsigned int)globalLogLevel > 4 )
    {
      strcpy(log_buffer, "[DEBUG] allocate memory for pattern test.\n");
      logMessage(4, log_buffer, 0);
    }
  }
  else if ( adjusted_sweep_type > 1 )
  {
LABEL_3:
    generate_error_message(20, 255);
    if ( (unsigned int)globalLogLevel <= 3 )
      return -1;
    snprintf(log_buffer, 2048u, "Invalid sweep type 0x%X\n", sweep_type);
LABEL_13:
    logMessage(3, log_buffer, 0);
    return -1;
  }
  operation_context_ptr = (_DWORD *)dword_4FCB3C;
  if ( !dword_4FCB3C )
  {
    new_context = calloc(68u, 1u);
    operation_context_ptr = new_context;
    dword_4FCB3C = (int)new_context;
    if ( !new_context )
    {
      generate_error_message(13, 255);
      if ( (unsigned int)globalLogLevel <= 3 )
        return -1;
      strcpy(log_buffer, "Fail to allocate memory for send work context.\n");
      goto LABEL_13;
    }
    new_context[2] = 0;
    new_context[3] = 0;
    new_context[4] = 0;
    new_context[5] = 0;
  }
  *operation_context_ptr = sweep_type;
  if ( sweep_type == 160 )
    operation_context_ptr[1] = get_software_operations();
  else
    operation_context_ptr[1] = get_hardware_operations();
  return (*(int (__fastcall **)(const char *))(*(_DWORD *)(dword_4FCB3C + 4) + 4))(pattern_file_path);
}
// 7EB9C: using guessed type int globalLogLevel;
// 4FCB3C: using guessed type int dword_4FCB3C;

//----- (00038E40) --------------------------------------------------------
void exit_pattern_test()
{
  _DWORD *pattern_test_ptr; // r0
  int pattern_test_destructor; // r3
  char debug_message_buffer[2064]; // [sp+0h] [bp-810h] BYREF

  if ( (unsigned int)globalLogLevel > 4 )
  {
    strcpy(debug_message_buffer, "[DEBUG] Pattern test exit.\n");
    logMessage(4, debug_message_buffer, 0);
    pattern_test_ptr = (_DWORD *)dword_4FCB3C;
    if ( !dword_4FCB3C )
    {
      if ( (unsigned int)globalLogLevel <= 4 )
        return;
      goto LABEL_9;
    }
  }
  else
  {
    pattern_test_ptr = (_DWORD *)dword_4FCB3C;
    if ( !dword_4FCB3C )
      return;
  }
  pattern_test_destructor = pattern_test_ptr[1];
  if ( pattern_test_destructor )
  {
    (*(void (**)(void))(pattern_test_destructor + 8))();
    if ( (unsigned int)globalLogLevel <= 4 )
      goto LABEL_5;
    goto LABEL_9;
  }
  if ( (unsigned int)globalLogLevel > 4 )
  {
LABEL_9:
    strcpy(debug_message_buffer, "[DEBUG] Free memory for pattern test.\n");
    logMessage(4, debug_message_buffer, 0);
LABEL_5:
    pattern_test_ptr = (_DWORD *)dword_4FCB3C;
    if ( !dword_4FCB3C )
      return;
  }
  free(pattern_test_ptr);
  dword_4FCB3C = 0;
}
// 7EB9C: using guessed type int globalLogLevel;
// 4FCB3C: using guessed type int dword_4FCB3C;

//----- (00038F58) --------------------------------------------------------
int reset_pattern_test()
{
  int test_handle_offset; // r3
  int reset_result; // r0
  char debug_message_buffer[2056]; // [sp+0h] [bp-808h] BYREF

  if ( (unsigned int)globalLogLevel > 4 )
  {
    strcpy(debug_message_buffer, "[DEBUG] Pattern test reset.\n");
    reset_result = logMessage(4, debug_message_buffer, 0);
  }
  if ( dword_4FCB3C )
  {
    test_handle_offset = *(_DWORD *)(dword_4FCB3C + 4);
    if ( test_handle_offset )
      return (*(int (**)(void))(test_handle_offset + 16))();
  }
  if ( (unsigned int)globalLogLevel > 3 )
  {
    strcpy(debug_message_buffer, "Handle is NULL.\n");
    return logMessage(3, debug_message_buffer, 0);
  }
  return reset_result;
}
// 7EB9C: using guessed type int globalLogLevel;
// 4FCB3C: using guessed type int dword_4FCB3C;

//----- (00039018) --------------------------------------------------------
int check_asics_communication()
{
  int communication_function_ptr; // r2
  int communication_status; // r0
  char error_message[2056]; // [sp+0h] [bp-808h] BYREF

  if ( dword_4FCB3C && (communication_function_ptr = *(_DWORD *)(dword_4FCB3C + 4)) != 0 )
  {
    if ( *(_DWORD *)(dword_4FCB3C + 64) )
      return (*(int (**)(void))(communication_function_ptr + 20))();
  }
  else if ( (unsigned int)globalLogLevel > 3 )
  {
    strcpy(error_message, "Handle is NULL.\n");
    return logMessage(3, error_message, 0);
  }
  return communication_status;
}
// 7EB9C: using guessed type int globalLogLevel;
// 4FCB3C: using guessed type int dword_4FCB3C;

//----- (000390B0) --------------------------------------------------------
char *__fastcall process_data_packet(char *data_packet)
{
  int next_entry_index; // r12
  bool is_buffer_full; // cc
  int *current_entry_ptr; // r2
  char first_data_byte; // r1
  int processed_packets_counter; // r2

  next_entry_index = dword_5945B8[0] + 1;
  is_buffer_full = dword_5945B8[0] > 509u;
  current_entry_ptr = &dword_5945B8[2 * dword_5945B8[0] + 2];
  current_entry_ptr[1] = *((_DWORD *)data_packet + 1);
  *((_BYTE *)current_entry_ptr + 8) = data_packet[3] & 0x1F;
  *((_BYTE *)current_entry_ptr + 9) = data_packet[2];
  *((_BYTE *)current_entry_ptr + 10) = data_packet[1];
  first_data_byte = *data_packet;
  if ( !is_buffer_full )
    dword_5945B8[0] = next_entry_index;
  *((_BYTE *)current_entry_ptr + 11) = first_data_byte & 0xF;
  if ( is_buffer_full )
    dword_5945B8[0] = 0;
  if ( (unsigned int)dword_5945C0 > 510 )
    processed_packets_counter = 511;
  else
    processed_packets_counter = dword_5945C0 + 1;
  dword_5945C0 = processed_packets_counter;
  return data_packet;
}
// 5945B8: using guessed type int dword_5945B8[];
// 5945C0: using guessed type int dword_5945C0;

//----- (00039128) --------------------------------------------------------
int __fastcall process_incoming_data(int data_pointer)
{
  char *data_to_process; // r5
  char log_message_buffer[2064]; // [sp+0h] [bp-810h] BYREF

  if ( dword_4FCB3C && *(_DWORD *)(dword_4FCB3C + 4) )
  {
    data_to_process = (char *)data_pointer;
    pthread_mutex_lock(&stru_810DC);
    if ( *(_DWORD *)(dword_4FCB3C + 64) )
      (*(void (__fastcall **)(char *))(*(_DWORD *)(dword_4FCB3C + 4) + 24))(data_to_process);
    else
      process_data_packet(data_to_process);
    return pthread_mutex_unlock(&stru_810DC);
  }
  else if ( (unsigned int)globalLogLevel > 3 )
  {
    strcpy(log_message_buffer, "Handle is NULL.\n");
    return logMessage(3, log_message_buffer, 0);
  }
  return data_pointer;
}
// 7EB9C: using guessed type int globalLogLevel;
// 810DC: using guessed type pthread_mutex_t stru_810DC;
// 4FCB3C: using guessed type int dword_4FCB3C;

//----- (000391F4) --------------------------------------------------------
int get_stats()
{
  int handle_value; // r3
  char debug_message_buffer[2056]; // [sp+0h] [bp-808h] BYREF

  if ( (unsigned int)globalLogLevel > 4 )
  {
    strcpy(debug_message_buffer, "[DEBUG] Get stats.\n");
    logMessage(4, debug_message_buffer, 0);
  }
  if ( dword_4FCB3C )
  {
    handle_value = *(_DWORD *)(dword_4FCB3C + 4);
    if ( handle_value )
      return (*(int (**)(void))(handle_value + 32))();
  }
  if ( (unsigned int)globalLogLevel > 3 )
  {
    strcpy(debug_message_buffer, "Handle is NULL.\n");
    logMessage(3, debug_message_buffer, 0);
  }
  return 0;
}
// 7EB9C: using guessed type int globalLogLevel;
// 4FCB3C: using guessed type int dword_4FCB3C;

//----- (000392B8) --------------------------------------------------------
int __fastcall check_unbalance_chain(int chain_index)
{
  int chain_check_func_ptr; // r3
  char log_message_buffer[2064]; // [sp+0h] [bp-810h] BYREF

  if ( (unsigned int)globalLogLevel > 4 )
  {
    snprintf(log_message_buffer, 2048u, "[DEBUG] Check if chain is unbalance happen, chain = %d.\n", chain_index);
    logMessage(4, log_message_buffer, 0);
  }
  if ( dword_4FCB3C )
  {
    chain_check_func_ptr = *(_DWORD *)(dword_4FCB3C + 4);
    if ( chain_check_func_ptr )
      return (*(int (__fastcall **)(int))(chain_check_func_ptr + 36))(chain_index);
  }
  if ( (unsigned int)globalLogLevel > 3 )
    return sub_388F4();
  return 1;
}
// 7EB9C: using guessed type int globalLogLevel;
// 4FCB3C: using guessed type int dword_4FCB3C;

//----- (00039360) --------------------------------------------------------
int check_unbalance()
{
  int asic_index; // r4
  char debug_message[2056]; // [sp+0h] [bp-808h] BYREF

  if ( (unsigned int)globalLogLevel > 4 )
  {
    strcpy(debug_message, "[DEBUG] Check if is unbalance happen.\n");
    logMessage(4, debug_message, 0);
  }
  asic_index = 0;
  while ( !get_global_buffer_value(asic_index) || !check_unbalance_chain(asic_index) )
  {
    if ( ++asic_index == 4 )
      return 0;
  }
  return 1;
}
// 7EB9C: using guessed type int globalLogLevel;

//----- (00039404) --------------------------------------------------------
int __fastcall CheckUnqualifiedChain(int chainIndex)
{
  float nonceRateThreshold; // s0
  int result; // r0
  char logBuffer[2072]; // [sp+8h] [bp-818h] BYREF

  if ( (unsigned int)globalLogLevel > 4 )
  {
    snprintf(
      logBuffer,
      2048u,
      "[DEBUG] Check if chain is unqualified happen, chain = %d, nonce_rate_threshold = %.2f\n",
      chainIndex,
      nonceRateThreshold);
    logMessage(4, logBuffer, 0);
  }
  if ( dword_4FCB3C && *(_DWORD *)(dword_4FCB3C + 4) )
  {
    if ( *(float *)(dword_4FCB3C + 4 * chainIndex + 48) < nonceRateThreshold )
    {
      result = 1;
      *(_BYTE *)(dword_4FCB3C + chainIndex + 28) = 1;
    }
    else
    {
      return 0;
    }
  }
  else if ( (unsigned int)globalLogLevel > 3 )
  {
    return sub_388F4();
  }
  else
  {
    return 1;
  }
  return result;
}
// 394BC: variable 'nonceRateThreshold' is possibly undefined
// 7EB9C: using guessed type int globalLogLevel;
// 4FCB3C: using guessed type int dword_4FCB3C;

//----- (000394D8) --------------------------------------------------------
int check_unqualified_chain()
{
  int chain_index; // r4
  char debug_message[2064]; // [sp+0h] [bp-810h] BYREF

  if ( (unsigned int)globalLogLevel > 4 )
  {
    strcpy(debug_message, "[DEBUG] check if is unqualified happen.\n");
    logMessage(4, debug_message, 0);
  }
  chain_index = 0;
  while ( !get_global_buffer_value(chain_index) || !CheckUnqualifiedChain(chain_index) )
  {
    if ( ++chain_index == 4 )
      return 0;
  }
  return 1;
}
// 7EB9C: using guessed type int globalLogLevel;

//----- (00039584) --------------------------------------------------------
int __fastcall verify_nonce_recv_enough(int chain_index)
{
  int logging_function_ptr; // r3
  char debug_message[2064]; // [sp+0h] [bp-810h] BYREF

  if ( (unsigned int)globalLogLevel > 4 )
  {
    snprintf(debug_message, 2048u, "[DEBUG] Check if recv nonce enough, chain = %d.\n", chain_index);
    logMessage(4, debug_message, 0);
  }
  if ( dword_4FCB3C )
  {
    logging_function_ptr = *(_DWORD *)(dword_4FCB3C + 4);
    if ( logging_function_ptr )
      return (*(int (__fastcall **)(int))(logging_function_ptr + 40))(chain_index);
  }
  if ( (unsigned int)globalLogLevel > 3 )
    return sub_388F4();
  return 1;
}
// 7EB9C: using guessed type int globalLogLevel;
// 4FCB3C: using guessed type int dword_4FCB3C;

//----- (0003962C) --------------------------------------------------------
int __fastcall update_chain_status(int status_update_result, int status_code)
{
  int chain_id; // r6
  const char *status_message; // r3
  int chain_index; // r4
  char log_buffer[2072]; // [sp+8h] [bp-818h] BYREF

  chain_id = status_update_result;
  if ( (unsigned int)globalLogLevel > 3 )
  {
    if ( status_code )
    {
      if ( status_code == 1 )
      {
        status_message = "READY";
      }
      else
      {
        status_message = "DONE";
        if ( status_code != 2 )
          status_message = "UNKNOWN";
      }
    }
    else
    {
      status_message = "BLOCK";
    }
    snprintf(log_buffer, 2048u, "chain = %d, status = %s\n", status_update_result, status_message);
    status_update_result = logMessage(3, log_buffer, 0);
    if ( !dword_4FCB3C || !*(_DWORD *)(dword_4FCB3C + 4) )
    {
      if ( (unsigned int)globalLogLevel > 3 )
      {
        strcpy(log_buffer, "Handle is NULL.\n");
        return logMessage(3, log_buffer, 0);
      }
      return status_update_result;
    }
LABEL_12:
    chain_index = 0;
    while ( 1 )
    {
      status_update_result = get_global_buffer_value(chain_index);
      if ( status_update_result )
      {
        if ( chain_id == 255 )
        {
          *(_DWORD *)(dword_4FCB3C + 4 * (chain_index + 2)) = status_code;
        }
        else if ( chain_id == chain_index )
        {
          *(_DWORD *)(dword_4FCB3C + 4 * (chain_id + 2)) = status_code;
          return status_update_result;
        }
      }
      if ( ++chain_index == 4 )
        return status_update_result;
    }
  }
  if ( dword_4FCB3C && *(_DWORD *)(dword_4FCB3C + 4) )
    goto LABEL_12;
  return status_update_result;
}
// 7EB9C: using guessed type int globalLogLevel;
// 4FCB3C: using guessed type int dword_4FCB3C;

//----- (000397A0) --------------------------------------------------------
int __fastcall get_chain_status(int chain_index)
{
  int status_base_ptr; // r2
  int chain_status_code; // r2
  const char *status_string; // r3
  char debug_message[2064]; // [sp+8h] [bp-810h] BYREF

  status_base_ptr = dword_4FCB3C;
  if ( (unsigned int)globalLogLevel > 4 )
  {
    chain_status_code = *(_DWORD *)(dword_4FCB3C + 4 * (chain_index + 2));
    if ( chain_status_code )
    {
      if ( chain_status_code == 1 )
      {
        status_string = "READY";
      }
      else
      {
        status_string = "UNKNOWN";
        if ( chain_status_code == 2 )
          status_string = "DONE";
      }
    }
    else
    {
      status_string = "BLOCK";
    }
    snprintf(debug_message, 2048u, "[DEBUG] chain = %d, status = %s\n", chain_index, status_string);
    logMessage(4, debug_message, 0);
    status_base_ptr = dword_4FCB3C;
  }
  if ( status_base_ptr && *(_DWORD *)(status_base_ptr + 4) )
    return *(_DWORD *)(status_base_ptr + 4 * (chain_index + 2));
  if ( (unsigned int)globalLogLevel > 3 )
  {
    strcpy(debug_message, "Handle is NULL.\n");
    logMessage(3, debug_message, 0);
  }
  return 2;
}
// 7EB9C: using guessed type int globalLogLevel;
// 4FCB3C: using guessed type int dword_4FCB3C;

//----- (000398BC) --------------------------------------------------------
int clear_statistics()
{
  int stat_function_ptr; // r3
  int log_result; // r0
  char debug_message_buffer[2056]; // [sp+0h] [bp-808h] BYREF

  if ( (unsigned int)globalLogLevel > 4 )
  {
    strcpy(debug_message_buffer, "[DEBUG] Clear stats.\n");
    log_result = logMessage(4, debug_message_buffer, 0);
  }
  if ( dword_4FCB3C )
  {
    stat_function_ptr = *(_DWORD *)(dword_4FCB3C + 4);
    if ( stat_function_ptr )
      return (*(int (**)(void))(stat_function_ptr + 12))();
  }
  if ( (unsigned int)globalLogLevel > 3 )
    return log_null_handle_error();
  return log_result;
}
// 7EB9C: using guessed type int globalLogLevel;
// 4FCB3C: using guessed type int dword_4FCB3C;

//----- (00039954) --------------------------------------------------------
int check_all_channels_status()
{
  int channel_index; // r4

  channel_index = 0;
  while ( !get_global_buffer_value(channel_index) || get_chain_status(channel_index) )
  {
    if ( ++channel_index == 4 )
      return 0;
  }
  return 1;
}

//----- (00039998) --------------------------------------------------------
int check_asics_status()
{
  int asic_index; // r4
  int asic_status; // r0

  asic_index = 0;
  while ( 1 )
  {
    if ( get_global_buffer_value(asic_index) )
    {
      asic_status = get_chain_status(asic_index);
      if ( asic_status == 1 )
        break;
    }
    if ( ++asic_index == 4 )
      return 0;
  }
  return asic_status;
}

//----- (000399D8) --------------------------------------------------------
int __fastcall set_chain_serial(unsigned int chain_serial_count)
{
  unsigned int initialized_count; // r5
  int chain_index; // r4
  bool is_chain_uninitialized; // zf
  int current_chain_status; // r0
  char debug_message[2064]; // [sp+0h] [bp-810h] BYREF

  if ( (unsigned int)globalLogLevel > 4 )
  {
    snprintf(debug_message, 2048u, "[DEBUG] Set chain serial, chain_serial_count = %d.\n", chain_serial_count);
    logMessage(4, debug_message, 0);
  }
  initialized_count = 0;
  for ( chain_index = 0; chain_index != 4; ++chain_index )
  {
    is_chain_uninitialized = get_global_buffer_value(chain_index) == 0;
    current_chain_status = chain_index;
    if ( !is_chain_uninitialized )
    {
      if ( chain_serial_count <= initialized_count )
        return current_chain_status;
      current_chain_status = get_chain_status(chain_index);
      if ( !current_chain_status )
      {
        ++initialized_count;
        current_chain_status = update_chain_status(chain_index, 1);
      }
    }
  }
  return current_chain_status;
}
// 7EB9C: using guessed type int globalLogLevel;

//----- (00039A7C) --------------------------------------------------------
int clear_context()
{
  _DWORD *context_ptr; // r3
  int log_result; // r0
  char debug_message[2056]; // [sp+0h] [bp-808h] BYREF

  if ( (unsigned int)globalLogLevel > 4 )
  {
    strcpy(debug_message, "[DEBUG] Clear ctxt.\n");
    log_result = logMessage(4, debug_message, 0);
  }
  context_ptr = (_DWORD *)dword_4FCB3C;
  if ( dword_4FCB3C && *(_DWORD *)(dword_4FCB3C + 4) )
  {
    *(_DWORD *)(dword_4FCB3C + 24) = 0;
    context_ptr[7] = 0;
    context_ptr[8] = 0;
    context_ptr[9] = 0;
    context_ptr[10] = 0;
    context_ptr[11] = 0;
    context_ptr[12] = 0;
    context_ptr[13] = 0;
    context_ptr[14] = 0;
    context_ptr[15] = 0;
  }
  else if ( (unsigned int)globalLogLevel > 3 )
  {
    strcpy(debug_message, "Handle is NULL.\n");
    return logMessage(3, debug_message, 0);
  }
  return log_result;
}
// 7EB9C: using guessed type int globalLogLevel;
// 4FCB3C: using guessed type int dword_4FCB3C;

//----- (00039B60) --------------------------------------------------------
int __fastcall checkIfStopNeeded(int chainIndex)
{
  float hwThreshold; // s0
  float nonceRateThreshold; // s1
  float nonceRateDecreaseThreshold; // s2
  int hwErrorDataAddress; // r8
  int hwErrorDataMultiplier; // r9
  int v7; // r5
  int totalChips; // r5
  unsigned int nonceCount; // s16
  int v11; // r5
  int calculationFactor; // r0
  int chainSpecificDataOffset; // r9
  unsigned int logLevel; // r3
  float currentNonceRate; // s13
  float lastNonceRate; // s12
  float maxNonceRate; // s14
  char logBuffer[2096]; // [sp+18h] [bp-830h] BYREF

  hwErrorDataAddress = get_stats();
  if ( (unsigned int)globalLogLevel > 4 )
  {
    snprintf(
      logBuffer,
      2048u,
      "[DEBUG] Check if is need stop, chain = %d, hw_threshold = %.4f, nonce_rate_threshold = %.2f, nonce_rate_dec_threshold = %.2f.\n",
      chainIndex,
      hwThreshold,
      nonceRateThreshold,
      nonceRateDecreaseThreshold);
    logMessage(4, logBuffer, 0);
  }
  if ( dword_4FCB3C && *(_DWORD *)(dword_4FCB3C + 4) )
  {
    hwErrorDataMultiplier = 4 * chainIndex;
    v7 = 8 * get_shared_value();
    totalChips = get_global_variable_value() * v7;
    if ( *(_DWORD *)(hwErrorDataAddress + 4 * chainIndex + 8431696) > (unsigned int)(float)((float)totalChips
                                                                                          * hwThreshold) )
    {
      if ( (unsigned int)globalLogLevel > 3 )
      {
        snprintf(
          logBuffer,
          2048u,
          "chain = %d, hw = %d, hw_threshold = %d, too much hw.\n",
          chainIndex,
          *(_DWORD *)(hwErrorDataAddress + hwErrorDataMultiplier + 8431696),
          (unsigned int)(float)((float)totalChips * hwThreshold));
        logMessage(3, logBuffer, 0);
      }
      return 1;
    }
    nonceCount = *(_DWORD *)(hwErrorDataAddress + 4 * chainIndex + 8429568);
    v11 = 8 * get_shared_value();
    calculationFactor = get_global_variable_value();
    chainSpecificDataOffset = dword_4FCB3C + hwErrorDataMultiplier;
    logLevel = globalLogLevel;
    currentNonceRate = *(float *)(chainSpecificDataOffset + 48);
    lastNonceRate = *(float *)(chainSpecificDataOffset + 32);
    maxNonceRate = (float)nonceCount / (float)(calculationFactor * v11);
    *(float *)(chainSpecificDataOffset + 32) = maxNonceRate;
    if ( currentNonceRate < maxNonceRate )
      *(float *)(chainSpecificDataOffset + 48) = maxNonceRate;
    if ( logLevel > 3 )
    {
      snprintf(
        logBuffer,
        2048u,
        "chain = %d, nonce_rate_curr = %.4f, nonce_rate_last = %.4f, nonce_rate_max = %.4f\n",
        chainIndex,
        maxNonceRate,
        lastNonceRate,
        *(float *)(chainSpecificDataOffset + 48));
      logMessage(3, logBuffer, 0);
    }
    return 0;
  }
  else
  {
    if ( (unsigned int)globalLogLevel <= 3 )
      return 1;
    strcpy(logBuffer, "Handle is NULL.\n");
    logMessage(3, logBuffer, 0);
    return 1;
  }
}
// 39C90: variable 'hwThreshold' is possibly undefined
// 39C94: variable 'nonceRateThreshold' is possibly undefined
// 39C8C: variable 'nonceRateDecreaseThreshold' is possibly undefined
// 7EB9C: using guessed type int globalLogLevel;
// 4FCB3C: using guessed type int dword_4FCB3C;

//----- (00039D88) --------------------------------------------------------
int check_all_chains_pattern_test_done()
{
  int chain_index; // r4
  int global_buffer_value; // r0
  int dword_offset; // r3
  char log_buffer[2064]; // [sp+0h] [bp-810h] BYREF

  if ( (unsigned int)globalLogLevel > 4 )
  {
    strcpy(log_buffer, "[DEBUG] Check if all chain pattern test done.\n");
    logMessage(4, log_buffer, 0);
  }
  if ( dword_4FCB3C && *(_DWORD *)(dword_4FCB3C + 4) )
  {
    chain_index = 0;
    while ( 1 )
    {
      global_buffer_value = get_global_buffer_value(chain_index);
      dword_offset = chain_index + 2;
      ++chain_index;
      if ( global_buffer_value )
      {
        if ( *(_DWORD *)(dword_4FCB3C + 4 * dword_offset) != 2 )
          break;
      }
      if ( chain_index == 4 )
        return 1;
    }
    return 0;
  }
  else if ( (unsigned int)globalLogLevel <= 3 )
  {
    return 1;
  }
  else
  {
    strcpy(log_buffer, "Handle is NULL.\n");
    logMessage(3, log_buffer, 0);
    return 1;
  }
}
// 7EB9C: using guessed type int globalLogLevel;
// 4FCB3C: using guessed type int dword_4FCB3C;

//----- (00039EA0) --------------------------------------------------------
int checkAllChainPatternTestDone()
{
  int v0; // r4
  int global_buffer_value; // r0
  int v2; // r3
  char logBuffer[2064]; // [sp+0h] [bp-810h] BYREF

  if ( (unsigned int)globalLogLevel > 4 )
  {
    strcpy(logBuffer, "[DEBUG] Check if all chain pattern test done except block.\n");
    logMessage(4, logBuffer, 0);
  }
  if ( dword_4FCB3C && *(_DWORD *)(dword_4FCB3C + 4) )
  {
    v0 = 0;
    while ( 1 )
    {
      global_buffer_value = get_global_buffer_value(v0);
      v2 = v0 + 2;
      ++v0;
      if ( global_buffer_value )
      {
        if ( (*(_DWORD *)(dword_4FCB3C + 4 * v2) & 0xFFFFFFFD) != 0 )
          break;
      }
      if ( v0 == 4 )
        return 1;
    }
    return 0;
  }
  else if ( (unsigned int)globalLogLevel <= 3 )
  {
    return 1;
  }
  else
  {
    strcpy(logBuffer, "Handle is NULL.\n");
    logMessage(3, logBuffer, 0);
    return 1;
  }
}
// 7EB9C: using guessed type int globalLogLevel;
// 4FCB3C: using guessed type int dword_4FCB3C;

//----- (00039FB4) --------------------------------------------------------
int __fastcall InitializeBoard(int is_power_off)
{
  int boardIndex; // r4
  int status; // r4
  char logBuffer[2056]; // [sp+0h] [bp-808h] BYREF

  if ( (unsigned int)globalLogLevel > 4 )
  {
    snprintf(logBuffer, 2048u, "[DEBUG] Board init, is_power_off = %d.\n", is_power_off);
    logMessage(4, logBuffer, 0);
  }
  for ( boardIndex = 0; boardIndex != 4; ++boardIndex )
  {
    if ( get_global_buffer_value(boardIndex) )
      forward_to_hardware_initialization((unsigned __int8)boardIndex);
  }
  configure_and_reboot_miner();
  status = InitializeMinerHardware();
  get_next_sleep_interval();
  initialize_uart_and_check_status();
  get_next_sleep_interval();
  return status;
}
// 7EB9C: using guessed type int globalLogLevel;

//----- (0003A054) --------------------------------------------------------
char *__fastcall log_miner_chain_stats(char *output, int stats_base_address)
{
  char *chain_index_str; // r7
  char *expected_ic_count_str; // r8
  unsigned int current_log_level; // r3
  unsigned int asic_index; // r4
  int nonce_count; // r0
  int calculation_result; // r1
  unsigned int domain_index; // r8
  int domain_offset; // r10
  unsigned int asic_in_domain_index; // r4
  int shared_value; // r4
  int send_nonce_factor; // r0
  unsigned int recv_nonces; // s16
  int multiplier_value_2; // r4
  int global_variable_value; // r0
  char log_msg_buffer[2096]; // [sp+18h] [bp-830h] BYREF

  if ( !dword_4FCB3C || !*(_DWORD *)(dword_4FCB3C + 4) )
  {
    if ( (unsigned int)globalLogLevel > 3 )
    {
      strcpy(log_msg_buffer, "Handle is NULL.\n");
      return (char *)logMessage(3, log_msg_buffer, 0);
    }
    return output;
  }
  chain_index_str = output;
  if ( (unsigned int)globalLogLevel > 3 )
  {
    snprintf(log_msg_buffer, 2048u, "chain %d stats:\n", output);
    append_log_message(3, log_msg_buffer, 0);
    if ( (unsigned int)globalLogLevel > 3 )
    {
      shared_value = get_shared_value();
      send_nonce_factor = get_global_variable_value();
      snprintf(log_msg_buffer, 2048u, "%-30s : %d\n", "send_nonce_num", send_nonce_factor * 8 * shared_value);
      append_log_message(3, log_msg_buffer, 0);
      if ( (unsigned int)globalLogLevel <= 3 )
        goto LABEL_4;
      snprintf(
        log_msg_buffer,
        2048u,
        "%-30s : %d\n",
        "recv_nonce_num",
        *(_DWORD *)(stats_base_address + 4 * (_DWORD)(chain_index_str + 2107392)));
      append_log_message(3, log_msg_buffer, 0);
      if ( (unsigned int)globalLogLevel <= 3 )
        goto LABEL_39;
      recv_nonces = *(_DWORD *)(stats_base_address + 4 * (_DWORD)(chain_index_str + 2107392));
      multiplier_value_2 = get_shared_value();
      global_variable_value = get_global_variable_value();
      snprintf(
        log_msg_buffer,
        2048u,
        "%-30s : %f\n",
        "nonce_return_rate",
        (float)((float)recv_nonces / (float)(global_variable_value * 8 * multiplier_value_2)));
      append_log_message(3, log_msg_buffer, 0);
      if ( (unsigned int)globalLogLevel <= 3 )
        goto LABEL_4;
      snprintf(
        log_msg_buffer,
        2048u,
        "%-30s : %d\n",
        "nonce_num_repeated",
        *(_DWORD *)(stats_base_address + 4 * ((int)&unk_202A04 + (_DWORD)chain_index_str)));
      append_log_message(3, log_msg_buffer, 0);
    }
    if ( (unsigned int)globalLogLevel <= 3 )
      goto LABEL_42;
    snprintf(
      log_msg_buffer,
      2048u,
      "%-30s : %d\n",
      "nonce_num_top_check_fail",
      *(_DWORD *)(stats_base_address + 4 * ((int)&unk_202A08 + (_DWORD)chain_index_str)));
    append_log_message(3, log_msg_buffer, 0);
    if ( (unsigned int)globalLogLevel <= 3 )
      goto LABEL_4;
    snprintf(
      log_msg_buffer,
      2048u,
      "%-30s : %d\n",
      "nonce_num_crc_err",
      *(_DWORD *)(stats_base_address + 4 * ((int)&unk_202A0C + (_DWORD)chain_index_str)));
    append_log_message(3, log_msg_buffer, 0);
LABEL_39:
    if ( (unsigned int)globalLogLevel <= 3 )
      goto LABEL_45;
    snprintf(
      log_msg_buffer,
      2048u,
      "%-30s : %d\n",
      "nonce_num_invalid",
      *(_DWORD *)(stats_base_address + 4 * ((int)&unk_202A10 + (_DWORD)chain_index_str)));
    append_log_message(3, log_msg_buffer, 0);
    if ( (unsigned int)globalLogLevel <= 3 )
      goto LABEL_4;
    snprintf(
      log_msg_buffer,
      2048u,
      "%-30s : %d\n",
      "nonce_num_hw",
      *(_DWORD *)(stats_base_address + 4 * ((int)&unk_202A14 + (_DWORD)chain_index_str)));
    append_log_message(3, log_msg_buffer, 0);
LABEL_42:
    if ( (unsigned int)globalLogLevel <= 3 )
      goto LABEL_48;
    snprintf(
      log_msg_buffer,
      2048u,
      "%-30s : %d\n",
      "nonce_num_extra",
      *(_DWORD *)(stats_base_address + 4 * ((int)&unk_202A18 + (_DWORD)chain_index_str)));
    append_log_message(3, log_msg_buffer, 0);
    if ( (unsigned int)globalLogLevel <= 3 )
      goto LABEL_4;
    snprintf(
      log_msg_buffer,
      2048u,
      "%-30s : %d\n",
      "nonce_num_unknown_err",
      *(_DWORD *)(stats_base_address + 4 * ((int)&unk_202A1C + (_DWORD)chain_index_str)));
    append_log_message(3, log_msg_buffer, 0);
LABEL_45:
    if ( (unsigned int)globalLogLevel <= 3 )
      goto LABEL_51;
    snprintf(
      log_msg_buffer,
      2048u,
      "%-30s : %d\n",
      "invalid_asic_num",
      *(_DWORD *)(stats_base_address + 4 * ((int)&unk_202A20 + (_DWORD)chain_index_str) + 4));
    append_log_message(3, log_msg_buffer, 0);
    if ( (unsigned int)globalLogLevel <= 3 )
      goto LABEL_4;
    snprintf(log_msg_buffer, 2048u, "%-30s : %d\n", "invalid_chain_num", *(_DWORD *)(stats_base_address + 8431744));
    append_log_message(3, log_msg_buffer, 0);
LABEL_48:
    if ( (unsigned int)globalLogLevel <= 3 )
      goto LABEL_4;
    snprintf(
      log_msg_buffer,
      2048u,
      "%-30s : %.2f\n",
      "stddev",
      *(float *)(stats_base_address + 4 * ((int)&unk_202A24 + (_DWORD)chain_index_str) + 4));
    append_log_message(3, log_msg_buffer, 0);
    if ( (unsigned int)globalLogLevel <= 3 )
      goto LABEL_4;
    strcpy(log_msg_buffer, "\n");
    append_log_message(3, log_msg_buffer, 0);
LABEL_51:
    if ( (unsigned int)globalLogLevel > 3 )
    {
      snprintf(log_msg_buffer, 2048u, "Chain %d nonce:\n", chain_index_str);
      logMessage(3, log_msg_buffer, 0);
    }
  }
LABEL_4:
  output = (char *)get_global_variable_value();
  expected_ic_count_str = output;
  current_log_level = globalLogLevel;
  if ( output )
  {
    asic_index = 0;
    do
    {
      if ( current_log_level > 3 )
      {
        snprintf(
          log_msg_buffer,
          2048u,
          "IC[%03d]:%04d ",
          asic_index,
          *(_DWORD *)(stats_base_address + ((_DWORD)chain_index_str << 10) + 4 * asic_index + 8425472));
        append_log_message(3, log_msg_buffer, 0);
      }
      ++asic_index;
      nonce_count = get_global_value();
      output = (char *)calculate_difficulty_ratio(asic_index, nonce_count);
      current_log_level = globalLogLevel;
      if ( !calculation_result && (unsigned int)globalLogLevel > 3 )
      {
        strcpy(log_msg_buffer, "\n");
        output = append_log_message(3, log_msg_buffer, 0);
        current_log_level = globalLogLevel;
      }
    }
    while ( (char *)asic_index != expected_ic_count_str );
  }
  if ( current_log_level > 3 )
  {
    strcpy(log_msg_buffer, "\n");
    output = append_log_message(3, log_msg_buffer, 0);
    if ( *(_DWORD *)dword_4FCB3C == 161 )
      return output;
    if ( (unsigned int)globalLogLevel > 3 )
    {
      snprintf(log_msg_buffer, 2048u, "Chain %d domain:\n", chain_index_str);
      append_log_message(3, log_msg_buffer, 0);
    }
  }
  else if ( *(_DWORD *)dword_4FCB3C == 161 )
  {
    return output;
  }
  domain_index = 0;
  output = (char *)get_global_state_value();
  if ( output )
  {
    while ( 1 )
    {
      domain_offset = domain_index * get_embedded_system_status();
      for ( asic_in_domain_index = 0; get_embedded_system_status() > asic_in_domain_index; ++asic_in_domain_index )
      {
        if ( (unsigned int)globalLogLevel > 3 )
        {
          snprintf(
            log_msg_buffer,
            2048u,
            "D[%02d]:%04d ",
            asic_in_domain_index + domain_offset,
            *(_DWORD *)((char *)&dword_80A010[64 * (_DWORD)chain_index_str + domain_offset + asic_in_domain_index]
                      + stats_base_address));
          append_log_message(3, log_msg_buffer, 0);
        }
      }
      if ( get_embedded_system_status() <= 1 )
        goto LABEL_28;
      if ( (unsigned int)globalLogLevel > 3 )
        break;
LABEL_24:
      ++domain_index;
      output = (char *)get_global_state_value();
      if ( (unsigned int)output <= domain_index )
        goto LABEL_25;
    }
    snprintf(
      log_msg_buffer,
      2048u,
      "D_BIG[%02d]:%05d",
      domain_index,
      *(_DWORD *)((char *)&dword_80A410[64 * (_DWORD)chain_index_str + domain_index] + stats_base_address));
    append_log_message(3, log_msg_buffer, 0);
LABEL_28:
    if ( (unsigned int)globalLogLevel > 3 )
    {
      strcpy(log_msg_buffer, "\n");
      append_log_message(3, log_msg_buffer, 0);
    }
    goto LABEL_24;
  }
LABEL_25:
  if ( (unsigned int)globalLogLevel > 3 )
  {
    strcpy(log_msg_buffer, "\n\n");
    return append_log_message(3, log_msg_buffer, 0);
  }
  return output;
}
// 3A0E0: variable 'calculation_result' is possibly undefined
// 7EB9C: using guessed type int globalLogLevel;
// 4FCB3C: using guessed type int dword_4FCB3C;
// 80A010: using guessed type _DWORD dword_80A010[256];
// 80A410: using guessed type _DWORD dword_80A410[289];

//----- (0003A828) --------------------------------------------------------
int calculate_hashrate_multiplier()
{
  int hashrate_base_multiplier; // r4

  hashrate_base_multiplier = 8 * get_shared_value();
  return get_global_variable_value() * hashrate_base_multiplier;
}

//----- (0003A86C) --------------------------------------------------------
int __fastcall perform_pattern_test(int final_result)
{
  int chip_id; // s0
  int input_result; // r4
  int read_chip_id_result; // r0
  int dword_at_handle_base; // r2
  int i; // r4
  int v6; // r11
  int stats; // r7
  int v8; // r3
  int v9; // r5
  int global_value; // r0
  unsigned int v11; // r9
  int shared_value; // r10
  int v13; // r5
  char *v14; // r11
  int v15; // r4
  unsigned int v16; // r8
  int v17; // r0
  unsigned int v18; // r0
  int v19; // t1
  int v20; // r0
  int v22; // r0
  int v23; // r12
  int v24; // lr
  _DWORD *v25; // r3
  int v26; // [sp+0h] [bp-868h]
  unsigned int v27; // [sp+8h] [bp-860h]
  int global_variable_value; // [sp+10h] [bp-858h]
  int v29; // [sp+14h] [bp-854h]
  int v30; // [sp+1Ch] [bp-84Ch]
  __time_t v31; // [sp+30h] [bp-838h] BYREF
  int v32; // [sp+34h] [bp-834h]
  __time_t v33[2]; // [sp+38h] [bp-830h] BYREF
  char v34[2088]; // [sp+40h] [bp-828h] BYREF

  if ( dword_4FCB3C && *(_DWORD *)(dword_4FCB3C + 4) )
  {
    input_result = final_result;
    if ( (unsigned int)globalLogLevel > 3 )
    {
      strcpy(v34, "Pattern test start...\n");
      logMessage(3, v34, 0);
    }
    convert_timespec_to_custom_format(&v31);
    clear_statistics();
    read_chip_id_result = read_chip_id();
    set_and_read_register_value(read_chip_id_result | 0x10000);
    dword_at_handle_base = *(_DWORD *)dword_4FCB3C;
    *(_DWORD *)(dword_4FCB3C + 64) = 1;
    if ( dword_at_handle_base == 161 )
      send_work_for_hw_sweep(input_result);
    else
      start_mining_threads(input_result);
    for ( i = 0; i != 4; ++i )
    {
      if ( get_global_buffer_value(i) && *(_DWORD *)(dword_4FCB3C + 4 * (i + 2)) == 1 )
      {
        v9 = 3;
        do
        {
          if ( verify_nonce_recv_enough(i) )
            break;
          usleep((__useconds_t)&loc_186A0);
          --v9;
        }
        while ( v9 );
      }
    }
    v6 = 0;
    *(_DWORD *)(dword_4FCB3C + 64) = 0;
    stats = get_stats();
    do
    {
      if ( get_global_buffer_value(v6) && *(_DWORD *)(dword_4FCB3C + 4 * (v6 + 2)) == 1 )
      {
        global_variable_value = get_global_variable_value();
        if ( global_variable_value )
        {
          v29 = v6;
          v30 = v6 << 8;
          v26 = v6 << 6;
          v27 = 0;
          do
          {
            global_value = get_global_value();
            v11 = calculate_bit_difficulty(v27, global_value);
            shared_value = get_shared_value();
            if ( shared_value )
            {
              v13 = 0;
              v14 = (char *)&unk_408FFC + 4096 * (v27 + v30) + stats;
              do
              {
                v15 = v11 * get_embedded_system_status();
                v16 = v13 * get_embedded_system_status();
                ++v13;
                v17 = get_shared_value();
                v18 = calculate_bit_difficulty(v16, v17);
                v19 = *((_DWORD *)v14 + 1);
                v14 += 4;
                v20 = stats + 4 * (v18 + v15 + v26) + 8429568;
                *(_DWORD *)(v20 + 16) += v19;
                *(_DWORD *)(stats + 4 * (v11 + v26) + 8430608) += v19;
                ++*(_DWORD *)(stats + 4 * (9 * v27 + 2304 * v29 + v19) + 4194304);
              }
              while ( shared_value != v13 );
            }
          }
          while ( global_variable_value != ++v27 );
          v6 = v29;
        }
        v22 = get_global_variable_value();
        if ( v22 )
        {
          v23 = stats + 4194304 + 9216 * v6;
          v24 = v23 + 36 * v22;
          do
          {
            v25 = (_DWORD *)v23;
            do
            {
              v25[1] += *v25;
              ++v25;
            }
            while ( v25 != (_DWORD *)(v23 + 32) );
            v23 += 36;
          }
          while ( v23 != v24 );
        }
        sub_38B6C(v6, stats);
        *(_DWORD *)((char *)&dword_80A894[v6] + stats) = chip_id;
      }
      ++v6;
    }
    while ( v6 != 4 );
    convert_timespec_to_custom_format(v33);
    final_result = v32;
    v8 = v33[0] - v31;
    if ( v33[1] - v32 < 0 )
      --v8;
    if ( (unsigned int)globalLogLevel > 3 )
    {
      snprintf(v34, 2048u, "Pattern test done, time cost %lds\n", v8);
      return logMessage(3, v34, 0);
    }
  }
  else if ( (unsigned int)globalLogLevel > 3 )
  {
    strcpy(v34, "Handle is NULL.\n");
    return logMessage(3, v34, 0);
  }
  return final_result;
}
// 3ABE4: variable 'chip_id' is possibly undefined
// 7EB9C: using guessed type int globalLogLevel;
// 4FCB3C: using guessed type int dword_4FCB3C;
// 80A894: using guessed type _DWORD dword_80A894[4];

//----- (0003AC6C) --------------------------------------------------------
int check_and_set_default_voltage()
{
  int current_global_flag; // r4

  current_global_flag = j_get_global_flag();
  if ( current_global_flag == get_miner_status_code() )
    return 0;
  else
    return set_voltage_to_default();
}

//----- (0003AC94) --------------------------------------------------------
int initialize_frequency_tuning()
{
  char debug_message_buffer[2072]; // [sp+0h] [bp-818h] BYREF

  if ( (unsigned int)globalLogLevel > 4 )
  {
    strcpy(debug_message_buffer, "[DEBUG] Freq tuning basic init.\n");
    logMessage(4, debug_message_buffer, 0);
    if ( (unsigned int)globalLogLevel > 4 )
    {
      strcpy(debug_message_buffer, "[DEBUG] Allocate memory for freq tuning basic.\n");
      logMessage(4, debug_message_buffer, 0);
    }
  }
  if ( minerConfigAddress )
    return 0;
  minerConfigAddress = (int)calloc(52u, 1u);
  if ( minerConfigAddress )
    return 0;
  generate_error_message(13, 255);
  if ( (unsigned int)globalLogLevel > 3 )
  {
    strcpy(debug_message_buffer, "Fail to allocate memory for freq tuning basic context.\n");
    logMessage(3, debug_message_buffer, 0);
  }
  return -1;
}
// 7EB9C: using guessed type int globalLogLevel;
// 4FCB40: using guessed type int minerConfigAddress;

//----- (0003ADCC) --------------------------------------------------------
void log_freq_tuning_exit()
{
  char log_buffer[2056]; // [sp+0h] [bp-808h] BYREF

  if ( (unsigned int)globalLogLevel > 4 )
  {
    strcpy(log_buffer, "[DEBUG] Freq tuning basic exit.\n");
    logMessage(4, log_buffer, 0);
    if ( (unsigned int)globalLogLevel > 4 )
    {
      strcpy(log_buffer, "[DEBUG] Free memory for freq tuning basic.\n");
      logMessage(4, log_buffer, 0);
    }
  }
  if ( minerConfigAddress )
  {
    free((void *)minerConfigAddress);
    minerConfigAddress = 0;
  }
}
// 7EB9C: using guessed type int globalLogLevel;
// 4FCB40: using guessed type int minerConfigAddress;

//----- (0003AE88) --------------------------------------------------------
int __fastcall get_miner_config_value(int config_index)
{
  return *(_DWORD *)(minerConfigAddress + 4 * config_index + 20);
}
// 4FCB40: using guessed type int minerConfigAddress;

//----- (0003AEA0) --------------------------------------------------------
int __fastcall sub_3AEA0(int chain_index)
{
  char debug_message[2056]; // [sp+0h] [bp-808h] BYREF

  if ( (unsigned int)globalLogLevel > 4 )
  {
    snprintf(debug_message, 2048u, "[DEBUG] Get freq result, chain = %d.\n", chain_index);
    logMessage(4, debug_message, 0);
  }
  return *(_DWORD *)(minerConfigAddress + 4 * chain_index + 4);
}
// 7EB9C: using guessed type int globalLogLevel;
// 4FCB40: using guessed type int minerConfigAddress;

//----- (0003AF04) --------------------------------------------------------
int __fastcall get_miner_config_offset(int config_index)
{
  return minerConfigAddress + 4 * config_index;
}
// 4FCB40: using guessed type int minerConfigAddress;

//----- (0003AF1C) --------------------------------------------------------
void logMinerSettings()
{
  unsigned int v0; // r3
  const char *v1; // r6
  const char *v2; // r12
  char logBuffer[2072]; // [sp+8h] [bp-818h] BYREF

  if ( (unsigned int)globalLogLevel <= 3 )
    return;
  snprintf(logBuffer, 2048u, "%-40s : %d\n", "voltage", **(_DWORD **)minerConfigAddress);
  append_log_message(3, logBuffer, 0);
  if ( (unsigned int)globalLogLevel > 3 )
  {
    snprintf(logBuffer, 2048u, "%-40s : %d\n", "freq_base", *(_DWORD *)(*(_DWORD *)minerConfigAddress + 4));
    append_log_message(3, logBuffer, 0);
    if ( (unsigned int)globalLogLevel <= 3 )
      return;
    snprintf(logBuffer, 2048u, "%-40s : %d\n", "freq_threshold", *(_DWORD *)(*(_DWORD *)minerConfigAddress + 8));
    append_log_message(3, logBuffer, 0);
    if ( (unsigned int)globalLogLevel <= 3 )
      goto LABEL_16;
    snprintf(logBuffer, 2048u, "%-40s : %d\n", "freq_serial_threshold", *(_DWORD *)(*(_DWORD *)minerConfigAddress + 12));
    append_log_message(3, logBuffer, 0);
    if ( (unsigned int)globalLogLevel <= 3 )
      return;
    snprintf(logBuffer, 2048u, "%-40s : %d\n", "freq_step", *(_DWORD *)(*(_DWORD *)minerConfigAddress + 16));
    append_log_message(3, logBuffer, 0);
  }
  v0 = globalLogLevel;
  if ( (unsigned int)globalLogLevel <= 3 )
  {
LABEL_19:
    if ( v0 > 3 )
    {
      snprintf(
        logBuffer,
        2048u,
        "%-40s : %.2f\n",
        "nonce_rate_threshold",
        *(float *)(*(_DWORD *)minerConfigAddress + 32));
      append_log_message(3, logBuffer, 0);
      if ( (unsigned int)globalLogLevel > 3 )
      {
        snprintf(
          logBuffer,
          2048u,
          "%-40s : %.2f\n",
          "nonce_rate_dec_threshold",
          *(float *)(*(_DWORD *)minerConfigAddress + 36));
        append_log_message(3, logBuffer, 0);
      }
    }
    return;
  }
  v1 = "false";
  if ( *(_BYTE *)(*(_DWORD *)minerConfigAddress + 20) )
    v2 = "true";
  else
    v2 = "false";
  snprintf(logBuffer, 2048u, "%-40s : %s\n", "is_inc_freq_with_high_vol", v2);
  append_log_message(3, logBuffer, 0);
  if ( (unsigned int)globalLogLevel > 3 )
  {
    if ( *(_BYTE *)(*(_DWORD *)minerConfigAddress + 21) )
      v1 = "true";
    snprintf(logBuffer, 2048u, "%-40s : %s\n", "is_inc_freq_with_high_vol_runtime", v1);
    append_log_message(3, logBuffer, 0);
LABEL_16:
    if ( (unsigned int)globalLogLevel <= 3 )
      return;
    snprintf(
      logBuffer,
      2048u,
      "%-40s : %d\n",
      "is_board_init_with_power_off",
      *(_DWORD *)(*(_DWORD *)minerConfigAddress + 24));
    append_log_message(3, logBuffer, 0);
    if ( (unsigned int)globalLogLevel <= 3 )
      return;
    snprintf(logBuffer, 2048u, "%-40s : %.4f\n", "hw_threshold", *(float *)(*(_DWORD *)minerConfigAddress + 28));
    append_log_message(3, logBuffer, 0);
    v0 = globalLogLevel;
    goto LABEL_19;
  }
}
// 7EB9C: using guessed type int globalLogLevel;
// 4FCB40: using guessed type int minerConfigAddress;

//----- (0003B298) --------------------------------------------------------
char *__fastcall performFrequencyTuning(int targetFrequency)
{
  int *configPtr; // r4
  char *tuningResult; // r4
  int chainIndex; // r4
  char *currentFrequency; // r8
  int frequencyStep; // r5
  int tuningStatus; // r0
  int innerIndex; // r4
  int bestPerformanceIndex; // r11
  int chainLoopIndex; // r4
  int frequencyDifference; // r9
  char **performanceArrayPtr; // r11
  char **frequencyArrayPtr; // r10
  int isChainActive; // r0
  char *bestFrequency; // r2
  char *currentFreqPointer; // r3
  int chainPerformanceIndex; // r8
  int selectedIndex; // r1
  float *performancePtr; // r2
  int innerLoopIndex; // r3
  float currentPerformance; // s12
  bool isAboveThreshold; // cc
  char *selectedFreqForChain; // r0
  float highestPerformance; // s0
  int configOffset; // r3
  char *returnBuffer; // [sp+10h] [bp-980h]
  int frequencyOffset; // [sp+14h] [bp-97Ch]
  char *frequencyBuffer[76]; // [sp+28h] [bp-968h] BYREF
  char logBuffer[2040]; // [sp+158h] [bp-838h] BYREF

  if ( (unsigned int)globalLogLevel > 3 )
  {
    strcpy(logBuffer, "Do freq tuning basic.\n");
    logMessage(3, logBuffer, 0);
  }
  configPtr = (int *)minerConfigAddress;
  memset((void *)(minerConfigAddress + 4), 0, 48u);
  *configPtr = targetFrequency;
  clear_context();
  update_global_value(**(_DWORD **)minerConfigAddress);
  tuningResult = (char *)check_and_set_default_voltage();
  if ( !tuningResult )
  {
    configureASICClock(255, (unsigned __int8)byte_482A70, *(unsigned __int8 *)(*(_DWORD *)minerConfigAddress + 20));
    if ( (unsigned int)globalLogLevel > 3 )
    {
      strcpy(logBuffer, "\n");
      append_log_message(3, logBuffer, 0);
      if ( (unsigned int)globalLogLevel > 3 )
      {
        strcpy(logBuffer, ">>>> Do tuning parallel.\n");
        logMessage(3, logBuffer, 0);
      }
    }
    for ( chainIndex = 0; chainIndex != 4; ++chainIndex )
    {
      if ( get_global_buffer_value(chainIndex) )
        update_chain_status(chainIndex, 1);
    }
    currentFrequency = *(char **)(*(_DWORD *)minerConfigAddress + 4);
    frequencyOffset = *(_DWORD *)(*(_DWORD *)minerConfigAddress + 16);
    returnBuffer = *(char **)(*(_DWORD *)minerConfigAddress + 12);
    if ( (unsigned int)globalLogLevel > 3 )
    {
      snprintf(
        logBuffer,
        2048u,
        "freq_prev = %d, freq_start = %d, freq_step = %d, freq_min = %d\n",
        currentFrequency,
        currentFrequency,
        frequencyOffset,
        *(_DWORD *)(*(_DWORD *)minerConfigAddress + 12));
      logMessage(3, logBuffer, 0);
    }
    frequencyBuffer[0] = currentFrequency;
    if ( currentFrequency < returnBuffer )
    {
      frequencyStep = 0;
      tuningResult = 0;
    }
    else
    {
      frequencyStep = 0;
      while ( 1 )
      {
        if ( (unsigned int)globalLogLevel <= 3
          || (strcpy(logBuffer, "\n"), append_log_message(3, logBuffer, 0), (unsigned int)globalLogLevel <= 3) )
        {
          tuningStatus = check_asics_status();
          if ( !tuningStatus )
            goto LABEL_59;
        }
        else
        {
          snprintf(logBuffer, 2048u, ">>>> freq_curr = %d\n", frequencyBuffer[0]);
          logMessage(3, logBuffer, 0);
          tuningStatus = check_asics_status();
          if ( !tuningStatus )
          {
LABEL_59:
            tuningResult = (char *)tuningStatus;
            if ( (unsigned int)globalLogLevel > 3 )
            {
              strcpy(logBuffer, "All ready chain done, exit.\n");
              logMessage(3, logBuffer, tuningStatus);
            }
            goto LABEL_36;
          }
        }
        for ( innerIndex = 0; innerIndex != 4; ++innerIndex )
        {
          if ( get_global_buffer_value(innerIndex) && get_chain_status(innerIndex) == 1 )
            SetChainFrequency(
              innerIndex,
              (unsigned __int8)byte_482A70,
              (unsigned int)currentFrequency,
              frequencyBuffer[0],
              *(_BYTE *)(*(_DWORD *)minerConfigAddress + 21));
        }
        currentFrequency = frequencyBuffer[0];
        tuningResult = (char *)check_and_set_default_voltage();
        if ( tuningResult )
          break;
        update_miner_frequency((int)frequencyBuffer[0], optMultiVersion, 20);
        perform_pattern_test((int)frequencyBuffer);
        bestPerformanceIndex = get_stats();
        do
        {
          if ( get_global_buffer_value((int)tuningResult) && get_chain_status((int)tuningResult) == 1 )
            log_miner_chain_stats(tuningResult, bestPerformanceIndex);
          ++tuningResult;
        }
        while ( tuningResult != (char *)4 );
        for ( chainLoopIndex = 0; chainLoopIndex != 4; ++chainLoopIndex )
        {
          if ( get_global_buffer_value(chainLoopIndex) && get_chain_status(chainLoopIndex) == 1 )
          {
            highestPerformance = *(float *)(*(_DWORD *)minerConfigAddress + 28);
            if ( checkIfStopNeeded(chainLoopIndex) )
              update_chain_status(chainLoopIndex, 2);
            else
              *(_DWORD *)(minerConfigAddress + 4 * chainLoopIndex + 20) = 1;
            calculate_hashrate_multiplier();
            configOffset = minerConfigAddress + 4 * chainLoopIndex;
            if ( highestPerformance > *(float *)(configOffset + 36) )
              *(float *)(configOffset + 36) = highestPerformance;
          }
        }
        frequencyDifference = 0;
        performanceArrayPtr = (char **)((char *)dword_80A894 + bestPerformanceIndex);
        frequencyArrayPtr = &frequencyBuffer[4 * frequencyStep + 16];
        do
        {
          isChainActive = get_global_buffer_value(frequencyDifference++);
          if ( isChainActive )
            currentFreqPointer = *performanceArrayPtr;
          ++frequencyArrayPtr;
          if ( isChainActive )
            bestFrequency = frequencyBuffer[0];
          ++performanceArrayPtr;
          if ( isChainActive )
          {
            *(frequencyArrayPtr - 1) = currentFreqPointer;
            frequencyBuffer[frequencyStep + 1] = bestFrequency;
          }
        }
        while ( frequencyDifference != 4 );
        ++frequencyStep;
        frequencyBuffer[0] -= frequencyOffset;
        if ( returnBuffer > frequencyBuffer[0] )
        {
          tuningResult = 0;
          goto LABEL_36;
        }
      }
      if ( (unsigned int)globalLogLevel > 3 )
      {
        strcpy(logBuffer, "Set voltage failed, exit.\n");
        logMessage(3, logBuffer, 0);
      }
    }
LABEL_36:
    chainPerformanceIndex = 0;
    if ( get_global_buffer_value(0) )
      goto LABEL_39;
    while ( ++chainPerformanceIndex != 4 )
    {
      if ( get_global_buffer_value(chainPerformanceIndex) )
      {
LABEL_39:
        selectedIndex = 0;
        performancePtr = (float *)&frequencyBuffer[chainPerformanceIndex + 16];
        innerLoopIndex = 0;
        while ( innerLoopIndex < frequencyStep - 1 )
        {
          currentPerformance = *performancePtr;
          if ( *performancePtr < 5.0 )
          {
            selectedIndex = innerLoopIndex;
            break;
          }
          performancePtr += 4;
          ++innerLoopIndex;
          if ( currentPerformance > *performancePtr * 1.5 )
            selectedIndex = innerLoopIndex;
        }
        isAboveThreshold = (unsigned int)globalLogLevel > 3;
        selectedFreqForChain = frequencyBuffer[selectedIndex + 1];
        *(_DWORD *)(minerConfigAddress + 4 * chainPerformanceIndex + 4) = selectedFreqForChain;
        if ( isAboveThreshold )
        {
          snprintf(
            logBuffer,
            2048u,
            "chain %d best level %d, freq %d\n",
            chainPerformanceIndex,
            selectedIndex,
            selectedFreqForChain);
          logMessage(3, logBuffer, 0);
        }
      }
    }
  }
  return tuningResult;
}
// 3B4AC: variable 'currentFreqPointer' is possibly undefined
// 3B4B0: variable 'bestFrequency' is possibly undefined
// 7EB58: using guessed type int optMultiVersion;
// 7EB9C: using guessed type int globalLogLevel;
// 482A70: using guessed type char byte_482A70;
// 4FCB40: using guessed type int minerConfigAddress;
// 80A894: using guessed type _DWORD dword_80A894[4];

//----- (0003B8A0) --------------------------------------------------------
unsigned int __fastcall calculate_chain_frequency_average(int chain_index, int freq_array_offset)
{
  int global_variable_value; // r0
  unsigned int frequency_sum; // r4
  int array_start; // r1
  int iteration_count; // r3
  int current_element_ptr; // r1
  int current_element_value; // t1
  int global_variable2; // r0
  unsigned int difficulty; // r0
  unsigned int frequency_average; // r4
  char debug_message[2064]; // [sp+8h] [bp-810h] BYREF

  global_variable_value = get_global_variable_value();
  if ( global_variable_value )
  {
    array_start = freq_array_offset + (chain_index << 10);
    frequency_sum = 0;
    iteration_count = 0;
    current_element_ptr = array_start - 4;
    do
    {
      ++iteration_count;
      current_element_value = *(_DWORD *)(current_element_ptr + 4);
      current_element_ptr += 4;
      frequency_sum += current_element_value;
    }
    while ( global_variable_value != iteration_count );
  }
  else
  {
    frequency_sum = 0;
  }
  global_variable2 = get_global_variable_value();
  difficulty = calculate_bit_difficulty(frequency_sum, global_variable2);
  frequency_average = difficulty;
  if ( (unsigned int)globalLogLevel > 4 )
  {
    snprintf(debug_message, 2048u, "chain = %d, freq_avg = %d\n", chain_index, difficulty);
    logMessage(4, debug_message, 0);
  }
  return frequency_average;
}
// 7EB9C: using guessed type int globalLogLevel;

//----- (0003B94C) --------------------------------------------------------
unsigned int __fastcall find_minimum_frequency(int chain_id, int offset)
{
  int adjusted_offset; // r8
  unsigned int minimum_frequency; // r6
  int chain_index; // r4
  bool selected_chain; // zf
  int global_variable_value; // r0
  int data_offset; // r1
  int i; // r3
  unsigned int current_frequency; // r2
  unsigned int next_frequency; // t1
  char log_buffer[2072]; // [sp+8h] [bp-818h] BYREF

  adjusted_offset = offset - 4;
  minimum_frequency = 16777215;
  for ( chain_index = 0; chain_index != 4; ++chain_index )
  {
    if ( get_global_buffer_value(chain_index) )
    {
      selected_chain = chain_id == 255;
      if ( chain_id != 255 )
        selected_chain = chain_id == chain_index;
      if ( selected_chain )
      {
        global_variable_value = get_global_variable_value();
        if ( global_variable_value )
        {
          data_offset = adjusted_offset + (chain_index << 10);
          for ( i = 0; i != global_variable_value; ++i )
          {
            next_frequency = *(_DWORD *)(data_offset + 4);
            data_offset += 4;
            current_frequency = next_frequency;
            if ( minimum_frequency >= next_frequency )
              minimum_frequency = current_frequency;
          }
        }
      }
    }
  }
  if ( (unsigned int)globalLogLevel > 4 )
  {
    snprintf(log_buffer, 2048u, "chain = %d, freq_min = %d\n", chain_id, minimum_frequency);
    logMessage(4, log_buffer, 0);
  }
  return minimum_frequency;
}
// 7EB9C: using guessed type int globalLogLevel;

//----- (0003BA18) --------------------------------------------------------
unsigned int __fastcall calculate_maximum_frequency(int chain_index, int buffer_offset)
{
  unsigned int max_frequency; // r5
  int adjusted_offset; // r8
  int current_chain; // r4
  bool is_target_chain; // zf
  int global_variable_value; // r0
  int calculation_offset; // r1
  int i; // r3
  unsigned int current_frequency; // r2
  unsigned int next_frequency; // t1
  char log_buffer[2072]; // [sp+8h] [bp-818h] BYREF

  max_frequency = 0;
  adjusted_offset = buffer_offset - 4;
  for ( current_chain = 0; current_chain != 4; ++current_chain )
  {
    if ( get_global_buffer_value(current_chain) )
    {
      is_target_chain = chain_index == 255;
      if ( chain_index != 255 )
        is_target_chain = chain_index == current_chain;
      if ( is_target_chain )
      {
        global_variable_value = get_global_variable_value();
        if ( global_variable_value )
        {
          calculation_offset = adjusted_offset + (current_chain << 10);
          for ( i = 0; i != global_variable_value; ++i )
          {
            next_frequency = *(_DWORD *)(calculation_offset + 4);
            calculation_offset += 4;
            current_frequency = next_frequency;
            if ( max_frequency < next_frequency )
              max_frequency = current_frequency;
          }
        }
      }
    }
  }
  if ( (unsigned int)globalLogLevel > 4 )
  {
    snprintf(log_buffer, 2048u, "chain = %d, freq_max = %d\n", chain_index, max_frequency);
    logMessage(4, log_buffer, 0);
  }
  return max_frequency;
}
// 7EB9C: using guessed type int globalLogLevel;

//----- (0003BAE4) --------------------------------------------------------
int __fastcall VerifyFrequencyThreshold(int chainIndex)
{
  unsigned int avgFrequency; // r6
  unsigned int minFrequency; // r8
  unsigned int maxFrequency; // r7
  unsigned int maxRuntimeFreq; // r0
  int freqConfigPointer; // r3
  unsigned int freqThreshold; // r1
  char logBuffer[2072]; // [sp+10h] [bp-818h] BYREF

  avgFrequency = calculate_chain_frequency_average(chainIndex, dword_4FCB44 + 4);
  minFrequency = find_minimum_frequency(chainIndex, dword_4FCB44 + 4);
  maxFrequency = calculate_maximum_frequency(chainIndex, dword_4FCB44 + 4);
  maxRuntimeFreq = calculate_maximum_frequency(chainIndex, dword_4FCB44 + 4116);
  freqConfigPointer = *(_DWORD *)dword_4FCB44;
  freqThreshold = *(_DWORD *)(*(_DWORD *)dword_4FCB44 + 20);
  if ( freqThreshold > avgFrequency )
  {
    if ( *(_DWORD *)(freqConfigPointer + 28) > maxFrequency - minFrequency )
    {
      if ( freqThreshold >= maxRuntimeFreq )
        return 0;
      if ( (unsigned int)globalLogLevel <= 3 )
        return 1;
      snprintf(
        logBuffer,
        2048u,
        "chain = %d, freq_max_runtime = %d, freq_threshold = %d, max freq enough\n",
        chainIndex,
        maxRuntimeFreq,
        freqThreshold);
    }
    else
    {
      if ( (unsigned int)globalLogLevel <= 3 )
        return 1;
      snprintf(
        logBuffer,
        2048u,
        "chain = %d, freq_max = %d, freq_min = %d, freq_diff = %d, freq_diff_threshold = %d, freq diff enough\n",
        chainIndex,
        maxFrequency,
        minFrequency,
        maxFrequency - minFrequency,
        *(_DWORD *)(freqConfigPointer + 28));
    }
LABEL_13:
    logMessage(3, logBuffer, 0);
    return 1;
  }
  if ( (unsigned int)globalLogLevel > 3 )
  {
    snprintf(
      logBuffer,
      2048u,
      "chain = %d, freq_avg = %d, freq_threshold = %d, avg freq enough\n",
      chainIndex,
      avgFrequency,
      freqThreshold);
    goto LABEL_13;
  }
  return 1;
}
// 7EB9C: using guessed type int globalLogLevel;
// 4FCB44: using guessed type int dword_4FCB44;

//----- (0003BC48) --------------------------------------------------------
unsigned int __fastcall dump_frequency_table(int chain_index, int frequency_table_ptr)
{
  int current_chain; // r5
  unsigned int return_value; // r0
  bool is_target_chain; // zf
  int log_specific_chain; // r4
  unsigned int buffer_value; // r8
  unsigned int current_log_level; // r3
  unsigned int frequency_index; // r4
  int difficulty_value; // r0
  int difficulty_ratio; // r1
  char log_message_buffer[4]; // [sp+10h] [bp-828h] BYREF

  if ( (unsigned int)globalLogLevel > 4 )
  {
    snprintf(log_message_buffer, 2048u, "[DEBUG] Dump freq table, chain = %d.\n", chain_index);
    logMessage(4, log_message_buffer, 0);
  }
  for ( current_chain = 0; current_chain != 4; ++current_chain )
  {
    return_value = get_global_buffer_value(current_chain);
    if ( return_value )
    {
      is_target_chain = chain_index == 255;
      if ( chain_index != 255 )
        is_target_chain = chain_index == current_chain;
      log_specific_chain = !is_target_chain;
      if ( is_target_chain )
      {
        if ( (unsigned int)globalLogLevel > 3 )
        {
          snprintf(log_message_buffer, 2048u, "chain = %d\n", current_chain);
          append_log_message(3, log_message_buffer, log_specific_chain);
        }
        return_value = get_global_variable_value();
        buffer_value = return_value;
        current_log_level = globalLogLevel;
        if ( return_value )
        {
          frequency_index = 0;
          do
          {
            if ( current_log_level > 3 )
            {
              snprintf(
                log_message_buffer,
                2048u,
                "[%3d]:%-3d",
                frequency_index,
                *(_DWORD *)(frequency_table_ptr + (current_chain << 10) + 4 * frequency_index));
              append_log_message(3, log_message_buffer, 0);
              if ( (unsigned int)globalLogLevel > 3 )
              {
                *(_DWORD *)log_message_buffer = &unk_202020;
                append_log_message(3, log_message_buffer, 0);
              }
            }
            ++frequency_index;
            difficulty_value = get_global_value();
            return_value = calculate_difficulty_ratio(frequency_index, difficulty_value);
            current_log_level = globalLogLevel;
            if ( !difficulty_ratio && (unsigned int)globalLogLevel > 3 )
            {
              strcpy(log_message_buffer, "\n");
              return_value = (unsigned int)append_log_message(3, log_message_buffer, 0);
              current_log_level = globalLogLevel;
            }
          }
          while ( buffer_value != frequency_index );
        }
        if ( current_log_level > 3 )
        {
          strcpy(log_message_buffer, "\n");
          return_value = (unsigned int)append_log_message(3, log_message_buffer, 0);
        }
      }
    }
  }
  return return_value;
}
// 3BCF0: variable 'difficulty_ratio' is possibly undefined
// 7EB9C: using guessed type int globalLogLevel;

//----- (0003BE08) --------------------------------------------------------
void log_freq_tuning_exit_and_free_memory()
{
  char log_buffer[2056]; // [sp+0h] [bp-808h] BYREF

  if ( (unsigned int)globalLogLevel > 4 )
  {
    strcpy(log_buffer, "[DEBUG] freq tuning fine exit.\n");
    logMessage(4, log_buffer, 0);
    if ( (unsigned int)globalLogLevel > 4 )
    {
      strcpy(log_buffer, "[DEBUG] Free memory for pm grade.\n");
      logMessage(4, log_buffer, 0);
    }
  }
  if ( dword_4FCB44 )
  {
    free((void *)dword_4FCB44);
    dword_4FCB44 = 0;
  }
}
// 7EB9C: using guessed type int globalLogLevel;
// 4FCB44: using guessed type int dword_4FCB44;

//----- (0003BEC4) --------------------------------------------------------
int __fastcall get_temperature_sensor_value(int sensor_index)
{
  return *(_DWORD *)(dword_4FCB44 + 4 * (sensor_index + 1024) + 4);
}
// 4FCB44: using guessed type int dword_4FCB44;

//----- (0003BEE0) --------------------------------------------------------
int __fastcall get_frequency_results(int chain_index, _DWORD *result_buffer)
{
  int return_value; // r0
  _DWORD *end_ptr; // r2
  _DWORD *copy_ptr; // r1
  int copied_data; // t1
  char debug_message[2064]; // [sp+0h] [bp-810h] BYREF

  if ( (unsigned int)globalLogLevel > 4 )
  {
    snprintf(debug_message, 2048u, "[DEBUG] Get freq result, chain = %d.\n", chain_index);
    logMessage(4, debug_message, 0);
  }
  return_value = get_global_variable_value();
  if ( return_value )
  {
    end_ptr = &result_buffer[return_value];
    copy_ptr = result_buffer;
    return_value = dword_4FCB44 + (chain_index << 10);
    do
    {
      copied_data = *(_DWORD *)(return_value + 4);
      return_value += 4;
      *copy_ptr++ = copied_data;
    }
    while ( copy_ptr != end_ptr );
  }
  return return_value;
}
// 7EB9C: using guessed type int globalLogLevel;
// 4FCB44: using guessed type int dword_4FCB44;

//----- (0003BF74) --------------------------------------------------------
int __fastcall calculate_memory_offset(int index)
{
  return dword_4FCB44 + 4 * (index + 3084);
}
// 4FCB44: using guessed type int dword_4FCB44;

//----- (0003BF94) --------------------------------------------------------
char *log_antminer_config()
{
  int index; // r4
  char *log_result; // r0
  unsigned int current_log_level; // r3
  const char *increment_frequency_flag_str; // r6
  const char *is_inc_freq_with_high_vol_str; // r12
  char log_message_buffer[2]; // [sp+8h] [bp-818h] BYREF

  if ( (unsigned int)globalLogLevel > 3 )
  {
    snprintf(log_message_buffer, 2048u, "%-40s : %d\n", "voltage", **(_DWORD **)dword_4FCB44);
    append_log_message(3, log_message_buffer, 0);
    if ( (unsigned int)globalLogLevel > 3 )
    {
      snprintf(log_message_buffer, 2048u, "%-40s : ", "freq_base");
      append_log_message(3, log_message_buffer, 0);
    }
  }
  for ( index = 0; index != 4; ++index )
  {
    log_result = (char *)get_global_buffer_value(index);
    if ( log_result && (unsigned int)globalLogLevel > 3 )
    {
      snprintf(log_message_buffer, 2048u, "[%d] = %d ", index, *(_DWORD *)(*(_DWORD *)dword_4FCB44 + 4 * index + 4));
      log_result = append_log_message(3, log_message_buffer, 0);
    }
  }
  if ( (unsigned int)globalLogLevel > 3 )
  {
    strcpy(log_message_buffer, "\n");
    log_result = append_log_message(3, log_message_buffer, 0);
    if ( (unsigned int)globalLogLevel > 3 )
    {
      snprintf(log_message_buffer, 2048u, "%-40s : %d\n", "freq_threshold", *(_DWORD *)(*(_DWORD *)dword_4FCB44 + 20));
      log_result = append_log_message(3, log_message_buffer, 0);
      if ( (unsigned int)globalLogLevel <= 3 )
        return log_result;
      snprintf(
        log_message_buffer,
        2048u,
        "%-40s : %d\n",
        "freq_serial_threshold",
        *(_DWORD *)(*(_DWORD *)dword_4FCB44 + 24));
      log_result = append_log_message(3, log_message_buffer, 0);
      if ( (unsigned int)globalLogLevel <= 3 )
        goto LABEL_24;
      snprintf(
        log_message_buffer,
        2048u,
        "%-40s : %d\n",
        "freq_diff_threshold",
        *(_DWORD *)(*(_DWORD *)dword_4FCB44 + 28));
      log_result = append_log_message(3, log_message_buffer, 0);
      if ( (unsigned int)globalLogLevel <= 3 )
        return log_result;
      snprintf(log_message_buffer, 2048u, "%-40s : %d\n", "freq_step", *(_DWORD *)(*(_DWORD *)dword_4FCB44 + 32));
      log_result = append_log_message(3, log_message_buffer, 0);
    }
    current_log_level = globalLogLevel;
    if ( (unsigned int)globalLogLevel <= 3 )
    {
LABEL_27:
      if ( current_log_level > 3 )
      {
        snprintf(
          log_message_buffer,
          2048u,
          "%-40s : %.2f\n",
          "nonce_rate_threshold",
          *(float *)(*(_DWORD *)dword_4FCB44 + 48));
        log_result = append_log_message(3, log_message_buffer, 0);
        if ( (unsigned int)globalLogLevel > 3 )
        {
          snprintf(
            log_message_buffer,
            2048u,
            "%-40s : %.2f\n",
            "nonce_rate_dec_threshold",
            *(float *)(*(_DWORD *)dword_4FCB44 + 52));
          log_result = append_log_message(3, log_message_buffer, 0);
          if ( (unsigned int)globalLogLevel > 3 )
          {
            snprintf(
              log_message_buffer,
              2048u,
              "%-40s : %d\n",
              "freq_tuning_fine_step",
              *(_DWORD *)(*(_DWORD *)dword_4FCB44 + 56));
            log_result = append_log_message(3, log_message_buffer, 0);
            if ( (unsigned int)globalLogLevel > 3 )
            {
              snprintf(
                log_message_buffer,
                2048u,
                "%-40s : %d\n",
                "freq_tuning_fine_count",
                *(_DWORD *)(*(_DWORD *)dword_4FCB44 + 60));
              return append_log_message(3, log_message_buffer, 0);
            }
          }
        }
      }
      return log_result;
    }
    increment_frequency_flag_str = "false";
    if ( *(_BYTE *)(*(_DWORD *)dword_4FCB44 + 36) )
      is_inc_freq_with_high_vol_str = "true";
    else
      is_inc_freq_with_high_vol_str = "false";
    snprintf(log_message_buffer, 2048u, "%-40s : %s\n", "is_inc_freq_with_high_vol", is_inc_freq_with_high_vol_str);
    log_result = append_log_message(3, log_message_buffer, 0);
    if ( (unsigned int)globalLogLevel <= 3 )
      return log_result;
    if ( *(_BYTE *)(*(_DWORD *)dword_4FCB44 + 37) )
      increment_frequency_flag_str = "true";
    snprintf(
      log_message_buffer,
      2048u,
      "%-40s : %s\n",
      "is_inc_freq_with_high_vol_runtime",
      increment_frequency_flag_str);
    log_result = append_log_message(3, log_message_buffer, 0);
LABEL_24:
    if ( (unsigned int)globalLogLevel <= 3 )
      return log_result;
    snprintf(
      log_message_buffer,
      2048u,
      "%-40s : %d\n",
      "is_board_init_with_power_off",
      *(_DWORD *)(*(_DWORD *)dword_4FCB44 + 40));
    log_result = append_log_message(3, log_message_buffer, 0);
    if ( (unsigned int)globalLogLevel <= 3 )
      return log_result;
    snprintf(log_message_buffer, 2048u, "%-40s : %.4f\n", "hw_threshold", *(float *)(*(_DWORD *)dword_4FCB44 + 44));
    log_result = append_log_message(3, log_message_buffer, 0);
    current_log_level = globalLogLevel;
    goto LABEL_27;
  }
  return log_result;
}
// 7EB9C: using guessed type int globalLogLevel;
// 4FCB44: using guessed type int dword_4FCB44;

//----- (0003C490) --------------------------------------------------------
int __fastcall init_freq_tuning_fine(int initial_frequency)
{
  _DWORD *pm_grade_memory; // r6
  char log_buffer[2072]; // [sp+0h] [bp-818h] BYREF

  if ( (unsigned int)globalLogLevel > 4 )
  {
    strcpy(log_buffer, "[DEBUG] freq tuning fine init.\n");
    logMessage(4, log_buffer, 0);
    if ( (unsigned int)globalLogLevel > 4 )
    {
      strcpy(log_buffer, "[DEBUG] Allocate memory for pm grade.\n");
      logMessage(4, log_buffer, 0);
    }
  }
  pm_grade_memory = (_DWORD *)dword_4FCB44;
  if ( dword_4FCB44 || (pm_grade_memory = calloc(12356u, 1u), (dword_4FCB44 = (int)pm_grade_memory) != 0) )
  {
    *pm_grade_memory = initial_frequency;
    log_antminer_config();
    return 0;
  }
  else
  {
    generate_error_message(13, 255);
    if ( (unsigned int)globalLogLevel > 3 )
    {
      strcpy(log_buffer, "Fail to allocate memory for pm grade context.\n");
      logMessage(3, log_buffer, 0);
    }
    return -1;
  }
}
// 7EB9C: using guessed type int globalLogLevel;
// 4FCB44: using guessed type int dword_4FCB44;

//----- (0003C5DC) --------------------------------------------------------
int performFineFrequencyTuning()
{
  int i; // r4
  int j; // r4
  int *v2; // r8
  int k; // r4
  int v4; // r5
  int *v5; // r9
  _DWORD *v7; // r3
  int v8; // r4
  int global_flag; // r4
  float v10; // s0
  int m; // r4
  int v12; // r4
  int n; // r5
  char *v14; // r5
  int minimum_frequency; // r0
  int stats; // r6
  int v17; // r4
  int v18; // r5
  int v19; // r0
  int v20; // r6
  char *v21; // r7
  int *v22; // r4
  int v23; // r8
  int v24; // r6
  unsigned int v25; // t1
  int shared_value; // r0
  int v27; // r2
  double v28; // d8
  int v29; // r1
  int v30; // r3
  double v31; // d7
  int v32; // r0
  int v33; // r2
  int v34; // r0
  int v35; // r3
  int v36; // t1
  int v37; // r0
  int v38; // r12
  int v39; // r0
  int v40; // r3
  int v41; // r2
  int v42; // t1
  int v43; // r12
  bool v44; // cc
  int v45; // r5
  int v46; // r0
  unsigned int v47; // r6
  int v48; // r12
  int v49; // r0
  _DWORD *v50; // r3
  int v51; // r2
  int v52; // r1
  int v53; // t1
  int v54; // r7
  int v55; // r1
  unsigned __int8 v56; // r2
  unsigned int v57; // r12
  int v58; // r0
  int v59; // r0
  int v60; // r1
  int v61; // r0
  char *v62; // r3
  char *v63; // r1
  unsigned int v64; // r3
  bool v65; // zf
  int v66; // r1
  int v67; // r0
  int v68; // r0
  int v69; // r3
  char *v70; // r2
  int v71; // r0
  int v72; // t1
  int global_variable_value; // r0
  int v74; // r1
  int v75; // r3
  int v76; // r0
  int v77; // r0
  int v78; // r3
  char *v79; // r2
  int v80; // r0
  int v81; // t1
  char *v82; // [sp+Ch] [bp-1064h]
  char *v83; // [sp+10h] [bp-1060h]
  unsigned int v84; // [sp+28h] [bp-1048h] BYREF
  char v85[4]; // [sp+2Ch] [bp-1044h] BYREF
  int v86; // [sp+30h] [bp-1040h] BYREF
  __int16 v87; // [sp+34h] [bp-103Ch]
  char v88; // [sp+36h] [bp-103Ah]
  char logBuffer[4152]; // [sp+38h] [bp-1038h] BYREF

  if ( (unsigned int)globalLogLevel > 3 )
  {
    strcpy(logBuffer, "Do freq tuning fine.\n");
    logMessage(3, logBuffer, 0);
  }
  for ( i = 0; i != 4; ++i )
  {
    if ( get_global_buffer_value(i) )
    {
      global_variable_value = get_global_variable_value();
      if ( global_variable_value )
      {
        v74 = dword_4FCB44 + 4 * (global_variable_value + (i << 8));
        v75 = dword_4FCB44 + (i << 10);
        v76 = *(_DWORD *)dword_4FCB44 + 4 * i;
        do
        {
          *(_DWORD *)(v75 + 4) = *(_DWORD *)(v76 + 4);
          v75 += 4;
        }
        while ( v75 != v74 );
      }
    }
  }
  update_global_value(**(_DWORD **)dword_4FCB44);
  memcpy((void *)(dword_4FCB44 + 4116), (const void *)(dword_4FCB44 + 4), 4096u);
  if ( (unsigned int)globalLogLevel > 3 )
  {
    strcpy(logBuffer, "\n");
    append_log_message(3, logBuffer, 0);
    if ( (unsigned int)globalLogLevel > 3 )
    {
      strcpy(logBuffer, ">>>> Do freq tuning fine parallel.\n");
      logMessage(3, logBuffer, 0);
    }
  }
  for ( j = 0; j != 4; ++j )
  {
    if ( get_global_buffer_value(j) )
    {
      v65 = VerifyFrequencyThreshold(j) == 0;
      v66 = 2;
      v67 = j;
      if ( v65 )
      {
        v66 = 1;
        v67 = j;
      }
      update_chain_status(v67, v66);
    }
  }
  v2 = &dword_4FCB44;
LABEL_11:
  while ( 2 )
  {
    if ( !check_asics_status() )
    {
      v4 = 0;
      v5 = v2;
      goto LABEL_142;
    }
    if ( (unsigned int)globalLogLevel > 3 )
    {
      snprintf(logBuffer, 2048u, "is_need_serial = %d\n", 0);
      logMessage(3, logBuffer, 0);
      if ( (unsigned int)globalLogLevel > 3 )
      {
        strcpy(logBuffer, "\n");
        append_log_message(3, logBuffer, 0);
        if ( (unsigned int)globalLogLevel > 3 )
        {
          strcpy(logBuffer, ">>>> Do single grade tuning.\n");
          logMessage(3, logBuffer, 0);
        }
      }
    }
    for ( k = 0; k != 4; ++k )
    {
      if ( get_global_buffer_value(k) && get_chain_status(k) == 1 && (unsigned int)globalLogLevel > 3 )
      {
        snprintf(logBuffer, 2048u, "chain = %d, grade = %d\n", k, *(_DWORD *)(*v2 + 4 * (k + 3076) + 4));
        logMessage(3, logBuffer, 0);
      }
    }
    if ( (unsigned int)globalLogLevel > 3 )
    {
      strcpy(logBuffer, "Board init start.\n");
      logMessage(3, logBuffer, 0);
    }
    v4 = InitializeBoard(*(_DWORD *)(*(_DWORD *)*v2 + 40));
    if ( !v4 )
    {
      clear_context();
      v7 = (_DWORD *)*v2;
      v8 = 0;
      v7[3081] = 0;
      v7 += 3081;
      v7[1] = 0;
      v7[2] = 0;
      v7[3] = 0;
      memset(logBuffer, 0, 4096u);
      do
      {
        if ( get_global_buffer_value(v8) )
        {
          if ( get_chain_status(v8) == 1 )
          {
            v77 = get_global_variable_value();
            if ( v77 )
            {
              v78 = *v2 + (v8 << 10);
              v79 = &logBuffer[1024 * v8];
              v80 = *v2 + 4 * (v77 + (v8 << 8));
              do
              {
                v81 = *(_DWORD *)(v78 + 4);
                v78 += 4;
                *(_DWORD *)v79 = v81;
                v79 += 4;
              }
              while ( v78 != v80 );
            }
          }
          else if ( calculate_chain_frequency_average(v8, *v2 + 4) <= *(_DWORD *)(*(_DWORD *)*v2 + 24) )
          {
            v68 = get_global_variable_value();
            if ( v68 )
            {
              v69 = *v2 + (v8 << 10);
              v70 = &logBuffer[1024 * v8];
              v71 = *v2 + 4 * (v68 + (v8 << 8));
              do
              {
                v72 = *(_DWORD *)(v69 + 4);
                v69 += 4;
                *(_DWORD *)v70 = v72;
                v70 += 4;
              }
              while ( v69 != v71 );
            }
          }
          else
          {
            v59 = get_global_variable_value();
            if ( v59 )
            {
              v60 = v59 + (v8 << 8);
              v61 = *v2;
              v62 = &logBuffer[1024 * v8];
              v63 = &logBuffer[4 * v60];
              do
              {
                *(_DWORD *)v62 = *(_DWORD *)(*(_DWORD *)v61 + 24);
                v62 += 4;
              }
              while ( v62 != v63 );
            }
          }
        }
        ++v8;
      }
      while ( v8 != 4 );
      global_flag = j_get_global_flag();
      if ( global_flag == get_miner_status_code() )
      {
        v10 = (float)unk_7EDD0;
        setChipFrequencies((int)logBuffer, (unsigned __int8)byte_482A70, *(unsigned __int8 *)(*(_DWORD *)*v2 + 36));
      }
      else
      {
        v4 = set_voltage_to_default();
        v10 = (float)unk_7EDD0;
        setChipFrequencies((int)logBuffer, (unsigned __int8)byte_482A70, *(unsigned __int8 *)(*(_DWORD *)*v2 + 36));
        if ( v4 )
        {
          v5 = v2;
          v64 = globalLogLevel;
          goto LABEL_122;
        }
      }
      while ( check_asics_status() )
      {
        for ( m = 0; m != 4; ++m )
        {
          if ( get_global_buffer_value(m) )
          {
            if ( get_chain_status(m) == 1 )
            {
              v57 = calculate_chain_frequency_average(m, *v2 + 4116);
              if ( (unsigned int)globalLogLevel > 3 )
              {
                snprintf(
                  logBuffer,
                  2048u,
                  "chain = %d, freq_avg = %d, freq_threshold = %d\n",
                  m,
                  v57,
                  *(_DWORD *)(*(_DWORD *)*v2 + 24));
                logMessage(3, logBuffer, 0);
              }
            }
          }
        }
        v12 = 1;
        for ( n = 0; n != 4; ++n )
        {
          if ( get_global_buffer_value(n) && get_chain_status(n) == 1 )
          {
            v58 = *(_DWORD *)(*v2 + 4 * n + 12324);
            if ( (unsigned int)globalLogLevel > 3 )
            {
              snprintf(
                logBuffer,
                2048u,
                "chain = %d, grade_curr = %d, is_grade_curr_done = %d\n",
                n,
                *(_DWORD *)(*v2 + 4 * n + 12308),
                *(_DWORD *)(*v2 + 4 * n + 12324));
              logMessage(3, logBuffer, 0);
              v58 = *(_DWORD *)(*v2 + 4 * (n + 3080) + 4);
            }
            if ( !v58 )
              v12 = 0;
          }
        }
        if ( (unsigned int)globalLogLevel > 3 )
          goto LABEL_113;
LABEL_40:
        if ( v12 )
          goto LABEL_11;
        do
        {
          if ( get_global_buffer_value(v12) )
          {
            if ( get_chain_status(v12) == 1 )
            {
              v45 = *(_DWORD *)(*v2 + 4 * (v12 + 3080) + 4);
              if ( !v45 )
              {
                v46 = get_global_variable_value();
                v47 = v46;
                if ( v46 )
                {
                  v47 = 0;
                  v48 = *(_DWORD *)*v2;
                  v49 = *v2 + 4 * (v46 + (v12 << 8));
                  v50 = (_DWORD *)(*v2 + (v12 << 10) + 4116);
                  v51 = *v2 + (v12 << 10);
                  do
                  {
                    v53 = *(_DWORD *)(v51 + 4);
                    v51 += 4;
                    v52 = v53;
                    *v50++ = v53;
                    if ( v50[1023] == 1 )
                    {
                      v47 = v52 - *(_DWORD *)(v48 + 32);
                      *(v50 - 1) = v47;
                    }
                  }
                  while ( v51 != v49 );
                }
                else
                {
                  v48 = *(_DWORD *)*v2;
                }
                if ( *(_BYTE *)(v48 + 37) )
                  do_nothing_function();
                v10 = (float)v47;
                CalculateFrequencyDividers((int)&v86, v85, 0);
                v88 = v85[0];
                if ( (unsigned int)globalLogLevel > 3 )
                {
                  snprintf(
                    logBuffer,
                    2048u,
                    "chain = %d, grade_curr = %d, freq_target = %d\n",
                    v12,
                    *(_DWORD *)(*v2 + 4 * (v12 + 3076) + 4),
                    v47);
                  logMessage(3, logBuffer, 0);
                }
                v54 = get_global_variable_value();
                v55 = *v2;
                if ( v54 )
                {
                  do
                  {
                    while ( *(_DWORD *)(v55 + 4 * ((v12 << 8) + v45 + 1028) + 4) != v47 )
                    {
                      if ( v54 == ++v45 )
                        goto LABEL_101;
                    }
                    if ( (unsigned int)globalLogLevel > 3 )
                    {
                      snprintf(logBuffer, 2048u, "chain = %d, asic = %d, freq = %d\n", v12, v45, v47);
                      logMessage(3, logBuffer, 0);
                    }
                    v56 = sub_1E160() * v45++;
                    trigger_asic_operations(v12, 0, v56, (unsigned __int8)byte_482A70, v86, v87);
                    usleep((__useconds_t)&unk_F4240);
                    v55 = *v2;
                  }
                  while ( v54 != v45 );
                }
LABEL_101:
                dump_frequency_table(v12, v55 + 4116);
              }
            }
          }
          ++v12;
        }
        while ( v12 != 4 );
        v14 = 0;
        minimum_frequency = find_minimum_frequency(255, *v2 + 4116);
        update_miner_frequency(minimum_frequency, optMultiVersion, 20);
        v84 = calculate_maximum_frequency(255, *v2 + 4116);
        perform_pattern_test((int)&v84);
        stats = get_stats();
        do
        {
          if ( get_global_buffer_value((int)v14)
            && get_chain_status((int)v14) == 1
            && !*(_DWORD *)(*v2 + 4 * (_DWORD)(v14 + 3080) + 4) )
          {
            log_miner_chain_stats(v14, stats);
          }
          ++v14;
        }
        while ( v14 != (char *)4 );
        v17 = 0;
        v82 = (char *)&unk_808FFC + stats;
        if ( get_global_buffer_value(0) )
        {
LABEL_49:
          if ( get_chain_status(v17) == 1 )
          {
            v18 = *(_DWORD *)(*v2 + 4 * (v17 + 3080) + 4);
            if ( !v18 )
            {
              v19 = get_global_variable_value();
              if ( v19 > 0 )
              {
                v20 = v17 << 8;
                v83 = (char *)v17;
                v21 = &v82[1024 * v17];
                v22 = v2;
                v23 = v20;
                v24 = v19;
                do
                {
                  v25 = *((_DWORD *)v21 + 1);
                  v21 += 4;
                  shared_value = get_shared_value();
                  v28 = (double)v25;
                  v29 = v23 + v18++ + 2052;
                  v30 = v29;
                  v31 = (double)(8 * shared_value) * 0.98;
                  if ( (double)v25 <= v31 )
                    v30 = *v22;
                  else
                    v27 = 0;
                  if ( v28 <= v31 )
                    v30 += 4 * v29;
                  else
                    v29 = *v22;
                  if ( v28 <= v31 )
                    *(_DWORD *)(v30 + 4) = 1;
                  else
                    v30 = v29 + 4 * v30;
                  if ( v28 > v31 )
                    *(_DWORD *)(v30 + 4) = v27;
                }
                while ( v24 != v18 );
                v2 = v22;
                v17 = (int)v83;
              }
              v32 = get_global_variable_value();
              if ( v32 <= 0 )
                goto LABEL_120;
              v33 = 0;
              v34 = *v2 + 8208 + 4 * (v32 + (v17 << 8));
              v35 = *v2 + (v17 << 10) + 8208;
              do
              {
                v36 = *(_DWORD *)(v35 + 4);
                v35 += 4;
                v33 += v36;
              }
              while ( v34 != v35 );
              if ( !v33 )
LABEL_120:
                update_chain_status(v17, 2);
              v37 = get_global_variable_value();
              v38 = *v2;
              if ( v37 )
              {
                v39 = v38 + 4 * (v37 + (v17 << 8));
                v40 = v38 + (v17 << 10);
                v41 = v38 + (v17 << 10) + 4112;
                do
                {
                  v42 = *(_DWORD *)(v41 + 4);
                  v41 += 4;
                  *(_DWORD *)(v40 + 4) = v42;
                  v40 += 4;
                }
                while ( v40 != v39 );
              }
              v43 = v38 + 4 * v17;
              v44 = (unsigned int)globalLogLevel > 3;
              *(_DWORD *)(v43 + 4100) = 1;
              if ( v44 )
              {
                snprintf(
                  logBuffer,
                  2048u,
                  "Update freq result of high grade, chain = %d, grade_curr = %d.\n",
                  v17,
                  *(_DWORD *)(v43 + 12308));
                logMessage(3, logBuffer, 0);
              }
              calculate_hashrate_multiplier();
              if ( v10 > *(float *)(*v2 + 4 * v17 + 12340) )
                *(float *)(*v2 + 4 * v17 + 12340) = v10;
              if ( VerifyFrequencyThreshold(v17) )
                update_chain_status(v17, 2);
            }
          }
        }
        while ( ++v17 != 4 )
        {
          if ( get_global_buffer_value(v17) )
            goto LABEL_49;
        }
      }
      if ( (unsigned int)globalLogLevel <= 3 )
        continue;
      v12 = 1;
LABEL_113:
      snprintf(logBuffer, 2048u, "is_single_grade_done = %d\n", v12);
      logMessage(3, logBuffer, 0);
      goto LABEL_40;
    }
    break;
  }
  v5 = v2;
  if ( (unsigned int)globalLogLevel <= 3 )
    goto LABEL_20;
  strcpy(logBuffer, "Board init failed, exit.\n");
  logMessage(3, logBuffer, 0);
  v64 = globalLogLevel;
LABEL_122:
  if ( v64 <= 3 )
    goto LABEL_20;
  strcpy(logBuffer, "Parallel tuning failed, exit.\n");
  logMessage(3, logBuffer, 0);
LABEL_142:
  if ( (unsigned int)globalLogLevel > 3 )
  {
    strcpy(logBuffer, "Dump freq tuning fine result:\n");
    logMessage(3, logBuffer, 0);
  }
LABEL_20:
  dump_frequency_table(255, *v5 + 4);
  return v4;
}
// 3CB04: variable 'v27' is possibly undefined
// 7EB58: using guessed type int optMultiVersion;
// 7EB9C: using guessed type int globalLogLevel;
// 482A70: using guessed type char byte_482A70;
// 4FCB44: using guessed type int dword_4FCB44;
// 3C5DC: using guessed type char logBuffer[4152];
// 3C5DC: using guessed type char anonymous_2[4];

//----- (0003D2B4) --------------------------------------------------------
char *__fastcall create_formatted_string(const char *format_string, const char *argument_string)
{
  size_t format_string_length; // r5
  size_t argument_string_length; // r0
  char *formatted_output; // r5

  format_string_length = strlen(format_string);
  argument_string_length = strlen(argument_string);
  formatted_output = (char *)malloc(format_string_length + argument_string_length);
  sprintf(formatted_output, format_string, argument_string);
  return formatted_output;
}

//----- (0003D2F0) --------------------------------------------------------
int __fastcall set_flag_to_true(_BYTE *flag_pointer)
{
  *flag_pointer = 1;
  return 0;
}

//----- (0003D300) --------------------------------------------------------
int __fastcall reset_first_byte(_BYTE *byte_pointer)
{
  *byte_pointer = 0;
  return 0;
}

//----- (0003D310) --------------------------------------------------------
int __fastcall clear_byte_buffer(_BYTE *buffer)
{
  *buffer = 0;
  return 0;
}

//----- (0003D320) --------------------------------------------------------
char *__fastcall parse_boolean_value(const char *input_str, _BYTE *output_bool)
{
  char *function_result; // r0

  if ( !strcasecmp(input_str, "yes") || !strcasecmp(input_str, "true") )
  {
    function_result = 0;
    *output_bool = 1;
  }
  else if ( !strcasecmp(input_str, "no") || !strcasecmp(input_str, "false") )
  {
    function_result = 0;
    *output_bool = 0;
  }
  else
  {
    return format_invalid_argument_message(input_str);
  }
  return function_result;
}

//----- (0003D3B4) --------------------------------------------------------
char *__fastcall validate_and_toggle_status(const char *input_string, _BYTE *status_flag)
{
  char *validation_result; // r0

  validation_result = parse_boolean_value(input_string, status_flag);
  if ( !validation_result )
    *status_flag ^= 1u;
  return validation_result;
}

//----- (0003D3D4) --------------------------------------------------------
int __fastcall set_value(int value, _DWORD *pointer_to_value)
{
  *pointer_to_value = value;
  return 0;
}

//----- (0003D468) --------------------------------------------------------
char *__fastcall parse_int_from_string(const char *input_string, int *output_int)
{
  int *errno_ptr; // r5
  int parsed_number; // r0
  char *end_pointer; // r3
  char *function_result; // r0
  char *end_pointer_ref; // [sp+4h] [bp-14h] BYREF

  errno_ptr = _errno_location();
  *errno_ptr = 0;
  parsed_number = strtol(input_string, &end_pointer_ref, 0);
  end_pointer = end_pointer_ref;
  *output_int = parsed_number;
  if ( *end_pointer || !*input_string )
    return create_formatted_string("'%s' is not a number", input_string);
  function_result = (char *)*errno_ptr;
  if ( *errno_ptr )
    return create_formatted_string("'%s' is out of range", input_string);
  return function_result;
}

//----- (0003D4F0) --------------------------------------------------------
char *__fastcall parse_integer(const char *input_str, _DWORD *output_int)
{
  char *parse_result; // r0
  int parsed_value; // [sp+4h] [bp-Ch] BYREF

  parse_result = parse_int_from_string(input_str, &parsed_value);
  if ( !parse_result )
    *output_int = parsed_value;
  return parse_result;
}

//----- (0003D5B8) --------------------------------------------------------
int __fastcall increment_counter(_DWORD *counter_ptr)
{
  int status; // r0

  status = 0;
  ++*counter_ptr;
  return status;
}

//----- (0003D5D0) --------------------------------------------------------
void __fastcall __noreturn terminate_with_message(const char *message)
{
  puts(message);
  fflush((FILE *)stdout);
  exit(0);
}
// 7F79C: using guessed type int stdout;

//----- (0003D5F0) --------------------------------------------------------
void __fastcall __noreturn print_message_and_exit(const char *message)
{
  char *formatted_message; // r0

  formatted_message = generate_help_message((const char *)dword_99EE20, message);
  printf("%s", formatted_message);
  fflush((FILE *)stdout);
  exit(0);
}
// 7F79C: using guessed type int stdout;
// 99EE20: using guessed type int dword_99EE20;

//----- (0003D630) --------------------------------------------------------
char *__fastcall copy_boolean_to_string(char *destination_buffer, unsigned __int8 *boolean_value)
{
  int boolean_int; // r12
  const char *boolean_string; // r1

  boolean_int = *boolean_value;
  boolean_string = "true";
  if ( !boolean_int )
    boolean_string = "false";
  return strncpy(destination_buffer, boolean_string, 80u);
}

//----- (0003D654) --------------------------------------------------------
char *__fastcall convert_bool_to_string(char *destination_buffer, unsigned __int8 *boolean_value_ptr)
{
  int bool_value; // r12
  const char *boolean_string; // r1

  bool_value = *boolean_value_ptr;
  boolean_string = "false";
  if ( !bool_value )
    boolean_string = "true";
  return strncpy(destination_buffer, boolean_string, 80u);
}

//----- (0003D678) --------------------------------------------------------
char *__fastcall format_string_to_limit_with_quotes(_BYTE *output_buffer, const char **input_string_ptr)
{
  size_t input_length; // r0
  bool is_over_limit; // cc
  size_t adjusted_length; // r5
  char *output_write_ptr; // r0
  const char *input_string; // r1
  _BYTE *output_end_ptr; // r4
  char *formatted_string; // r0

  input_length = strlen(*input_string_ptr);
  is_over_limit = input_length > 78;
  adjusted_length = input_length;
  *output_buffer = 34;
  output_write_ptr = output_buffer + 1;
  input_string = *input_string_ptr;
  if ( is_over_limit )
  {
    formatted_string = strncpy(output_write_ptr, input_string, 78u);
    output_buffer[79] = 34;
  }
  else
  {
    output_end_ptr = &output_buffer[adjusted_length];
    formatted_string = strncpy(output_write_ptr, input_string, adjusted_length);
    output_end_ptr[1] = 34;
    if ( adjusted_length != 78 )
      output_end_ptr[2] = 0;
  }
  return formatted_string;
}

//----- (0003D6D8) --------------------------------------------------------
int __fastcall format_integer_to_string(char *output_buffer, _DWORD *integer_value)
{
  return snprintf(output_buffer, 80u, "%i", *integer_value);
}

//----- (0003D6EC) --------------------------------------------------------
int __fastcall format_single_temperature(char *destination_buffer, float *temperature_value)
{
  return snprintf(destination_buffer, 80u, "%.1f", *temperature_value);
}

//----- (0003D718) --------------------------------------------------------
int __fastcall format_unsigned_integer_to_string(char *output_buffer, _DWORD *unsigned_integer)
{
  return snprintf(output_buffer, 80u, "%u", *unsigned_integer);
}

//----- (0003D72C) --------------------------------------------------------
int __fastcall format_long_integer_to_string(char *buffer, _DWORD *long_integer)
{
  return snprintf(buffer, 80u, "%li", *long_integer);
}

//----- (0003D740) --------------------------------------------------------
int __fastcall format_uptime(char *output_buffer, _DWORD *uptime_ptr)
{
  return snprintf(output_buffer, 80u, "%lu", *uptime_ptr);
}

//----- (0003D754) --------------------------------------------------------
const char *__fastcall get_device_info_string(unsigned int *current_device_index, size_t *info_string_length)
{
  _DWORD *device_info_ptr; // r12
  const char *info_string; // r4
  int device_info_offset; // r4
  unsigned int device_index; // lr

  *current_device_index = 0;
  if ( !dword_99EE24 )
    return 0;
  device_info_ptr = (_DWORD *)dword_99EE1C;
  if ( *(_DWORD *)(dword_99EE1C + 4) == 8 )
  {
    device_info_offset = 28;
    device_index = 1;
    do
    {
      *current_device_index = device_index;
      if ( dword_99EE24 <= device_index++ )
        return 0;
      device_info_ptr = (_DWORD *)(dword_99EE1C + device_info_offset);
      device_info_offset += 28;
    }
    while ( device_info_ptr[1] == 8 );
  }
  info_string = (const char *)(*device_info_ptr + 1);
  *info_string_length = strcspn(info_string, (const char *)&off_68A48);
  return info_string;
}
// 68A48: using guessed type void *off_68A48;
// 99EE1C: using guessed type int dword_99EE1C;
// 99EE24: using guessed type int dword_99EE24;

//----- (0003D7F4) --------------------------------------------------------
size_t __fastcall parse_next_token(int buffer_start, size_t *token_length)
{
  int current_char; // r3
  size_t current_position; // r0
  bool is_delimiter; // zf
  size_t next_position; // r4

  current_char = *(unsigned __int8 *)(buffer_start + *token_length);
  current_position = buffer_start + *token_length;
  is_delimiter = (current_char & 0xDF) == 0;
  if ( (current_char & 0xDF) != 0 )
    is_delimiter = current_char == 61;
  if ( is_delimiter )
    return 0;
  next_position = current_position + 2;
  *token_length = strcspn((const char *)(current_position + 2), (const char *)&off_68A48);
  return next_position;
}
// 68A48: using guessed type void *off_68A48;

//----- (0003D83C) --------------------------------------------------------
const char *__fastcall get_next_string(const char *input_string, unsigned int *index_pointer, size_t *length_pointer)
{
  unsigned int current_index; // r3
  _DWORD *current_entry_ptr; // r2
  const char *result_string; // r0
  const char *output_string; // r4

  current_index = *index_pointer;
  if ( *index_pointer >= dword_99EE24 )
    return 0;
  while ( 1 )
  {
    current_entry_ptr = (_DWORD *)(dword_99EE1C + 28 * current_index);
    if ( current_entry_ptr[1] != 8 )
      break;
LABEL_6:
    *index_pointer = ++current_index;
    if ( current_index >= dword_99EE24 )
      return 0;
  }
  if ( input_string )
  {
    result_string = (const char *)parse_next_token((int)input_string, length_pointer);
    input_string = result_string;
    if ( result_string )
      return result_string;
    current_index = *index_pointer;
    goto LABEL_6;
  }
  output_string = (const char *)(*current_entry_ptr + 1);
  *length_pointer = strcspn(output_string, (const char *)&off_68A48);
  return output_string;
}
// 68A48: using guessed type void *off_68A48;
// 99EE1C: using guessed type int dword_99EE1C;
// 99EE24: using guessed type int dword_99EE24;

//----- (0003D8F4) --------------------------------------------------------
_BYTE *__fastcall parse_command_line_option(const char **options)
{
  __int64 combined_option_string; // r2
  bool entry_type_condition; // cc
  _BYTE *option_char_ptr; // r4
  int option_length; // r0
  const char *current_option_type; // r12
  unsigned int long_option_count_increment; // r3
  int next_char_of_option; // r3
  bool is_argument_separator; // zf
  _BYTE *next_token_ptr; // r0
  int parse_status; // [sp+Ch] [bp-1Ch] BYREF

  combined_option_string = *(_QWORD *)options;
  entry_type_condition = (unsigned int)options[1] > 4;
  if ( options[1] != (const char *)4 )
    entry_type_condition = (unsigned int)(options[1] - 1) > 1;
  if ( entry_type_condition )
    errx(1, "Option %s: unknown entry type %u", (const char *)combined_option_string, HIDWORD(combined_option_string));
  if ( !options[6] )
    errx(1, "Option %s: description cannot be NULL", (const char *)combined_option_string);
  if ( *(_BYTE *)combined_option_string != 45 )
    errx(1, "Option %s: does not begin with '-'", (const char *)combined_option_string);
  option_char_ptr = (_BYTE *)(combined_option_string + 1);
  option_length = strcspn((const char *)(combined_option_string + 1), (const char *)&off_68A48);
  for ( parse_status = option_length; ; option_length = parse_status )
  {
    if ( *option_char_ptr == 45 )
    {
      if ( option_length == 1 )
        errx(1, "Option %s: invalid long option '--'", *options);
      current_option_type = options[1];
      ++dword_99EE14;
    }
    else
    {
      if ( option_length != 1 )
        errx(1, "Option %s: invalid short option '%.*s'", *options, option_length + 1, option_char_ptr - 1);
      current_option_type = options[1];
      long_option_count_increment = (unsigned int)(current_option_type - 2) & 0xFFFFFFFD;
      if ( !long_option_count_increment )
        long_option_count_increment = dword_99EE10;
      ++dword_99EE18;
      if ( ((unsigned int)(current_option_type - 2) & 0xFFFFFFFD) == 0 )
        dword_99EE10 = long_option_count_increment + 1;
    }
    if ( current_option_type == (const char *)1 )
    {
      next_char_of_option = (unsigned __int8)option_char_ptr[option_length];
      is_argument_separator = next_char_of_option == 61;
      if ( next_char_of_option != 61 )
        is_argument_separator = next_char_of_option == 32;
      if ( is_argument_separator )
        errx(1, "Option %s: does not take arguments '%s'", *options, &option_char_ptr[option_length + 1]);
    }
    next_token_ptr = (_BYTE *)parse_next_token((int)option_char_ptr, (size_t *)&parse_status);
    option_char_ptr = next_token_ptr;
    if ( !next_token_ptr )
      break;
  }
  return next_token_ptr;
}
// 68A48: using guessed type void *off_68A48;
// 99EE10: using guessed type int dword_99EE10;
// 99EE14: using guessed type int dword_99EE14;
// 99EE18: using guessed type int dword_99EE18;

//----- (0003DA68) --------------------------------------------------------
int __fastcall add_miner_info(int *miner_info)
{
  char *reallocation_result; // r0
  int current_miner_count; // r3
  int *miner_info_ptr; // lr
  char *new_miner_storage; // r12
  int miner_index_offset; // r4
  int miner_id; // r0
  int miner_hashrate; // r1
  int miner_hardware_errors; // r2
  int miner_uptime; // r3
  int *miner_storage_ptr; // r12
  int add_result; // r0
  int miner_fan_speed; // r1
  int miner_temperature; // r2

  reallocation_result = (char *)realloc((void *)dword_99EE1C, 28 * (dword_99EE24 + 1));
  current_miner_count = dword_99EE24;
  miner_info_ptr = miner_info;
  new_miner_storage = reallocation_result;
  dword_99EE1C = (int)reallocation_result;
  ++dword_99EE24;
  miner_index_offset = 7 * current_miner_count;
  miner_id = *miner_info_ptr;
  miner_hashrate = miner_info_ptr[1];
  miner_hardware_errors = miner_info_ptr[2];
  miner_uptime = miner_info_ptr[3];
  miner_info_ptr += 4;
  miner_storage_ptr = (int *)&new_miner_storage[4 * miner_index_offset];
  *miner_storage_ptr = miner_id;
  miner_storage_ptr[1] = miner_hashrate;
  miner_storage_ptr[2] = miner_hardware_errors;
  miner_storage_ptr[3] = miner_uptime;
  miner_storage_ptr += 4;
  add_result = *miner_info_ptr;
  miner_fan_speed = miner_info_ptr[1];
  miner_temperature = miner_info_ptr[2];
  *miner_storage_ptr = *miner_info_ptr;
  miner_storage_ptr[1] = miner_fan_speed;
  miner_storage_ptr[2] = miner_temperature;
  return add_result;
}
// 99EE1C: using guessed type int dword_99EE1C;
// 99EE24: using guessed type int dword_99EE24;

//----- (0003DACC) --------------------------------------------------------
const char *__fastcall parse_until_dash(unsigned int *data_buffer, size_t *buffer_length)
{
  const char *current_position; // r0
  const char *next_position; // r0

  current_position = get_device_info_string(data_buffer, buffer_length);
  if ( !current_position )
    return 0;
  while ( *current_position != 45 )
  {
    current_position = get_next_string(current_position, data_buffer, buffer_length);
    if ( !current_position )
      return 0;
  }
  next_position = current_position + 1;
  --*buffer_length;
  return next_position;
}

//----- (0003DB24) --------------------------------------------------------
_BYTE *__fastcall find_next_dash_after_string(
        const char *input_string,
        unsigned int *unknown_parameter,
        size_t *remaining_length)
{
  const char *current_position; // r0
  _BYTE *next_position_after_dash; // r0

  current_position = get_next_string(input_string, unknown_parameter, remaining_length);
  if ( !current_position )
    return 0;
  while ( *current_position != 45 )
  {
    current_position = get_next_string(current_position, unknown_parameter, remaining_length);
    if ( !current_position )
      return 0;
  }
  next_position_after_dash = current_position + 1;
  --*remaining_length;
  return next_position_after_dash;
}

//----- (0003DB7C) --------------------------------------------------------
const char *__fastcall parse_negative_sign(unsigned int *num)
{
  const char *current_char_ptr; // r0
  size_t num_length_ref; // [sp+4h] [bp-14h] BYREF

  num_length_ref = 0;
  current_char_ptr = get_device_info_string(num, &num_length_ref);
  if ( !current_char_ptr )
    return 0;
  while ( *current_char_ptr == 45 )
  {
    current_char_ptr = get_next_string(current_char_ptr, num, &num_length_ref);
    if ( !current_char_ptr )
      return 0;
  }
  return current_char_ptr;
}

//----- (0003DBDC) --------------------------------------------------------
const char *__fastcall check_and_skip_negatives(const char *input_string, unsigned int *processed_length)
{
  const char *current_char_ptr; // r0
  size_t single_character_skip; // [sp+4h] [bp-14h] BYREF

  single_character_skip = 1;
  current_char_ptr = get_next_string(input_string, processed_length, &single_character_skip);
  if ( !current_char_ptr )
    return 0;
  while ( *current_char_ptr == 45 )
  {
    current_char_ptr = get_next_string(current_char_ptr, processed_length, &single_character_skip);
    if ( !current_char_ptr )
      return 0;
  }
  return current_char_ptr;
}

//----- (0003DC3C) --------------------------------------------------------
int __fastcall execute_miner_command(
        const char *command,
        const char *param1,
        const char *param2,
        const char *param3,
        const char *param4,
        const char *param5,
        const char *param6)
{
  const char *command_params[9]; // [sp+4h] [bp-24h] BYREF

  command_params[1] = param1;
  command_params[0] = command;
  command_params[2] = param2;
  command_params[3] = param3;
  command_params[4] = param4;
  command_params[5] = param5;
  command_params[6] = param6;
  parse_command_line_option(command_params);
  return add_miner_info((int *)command_params);
}

//----- (0003DC80) --------------------------------------------------------
int __fastcall update_miner_status(int current_status_ptr, int status_update_flag)
{
  int *status_entry; // r4
  int global_miner_index; // r6
  int status_code; // r3
  int local_miner_info[13]; // [sp+4h] [bp-34h] BYREF

  status_entry = (int *)current_status_ptr;
  global_miner_index = dword_99EE24;
  if ( status_update_flag )
  {
    local_miner_info[0] = 0;
    memset(&local_miner_info[2], 0, 16);
    local_miner_info[6] = status_update_flag;
    local_miner_info[1] = 8;
    add_miner_info(local_miner_info);
    status_code = status_entry[1];
    if ( status_code == 16 )
    {
LABEL_7:
      current_status_ptr = 7 * global_miner_index;
      *(_DWORD *)(dword_99EE1C + 28 * global_miner_index + 20) = dword_99EE24 - global_miner_index;
      return current_status_ptr;
    }
  }
  else
  {
    status_code = *(_DWORD *)(current_status_ptr + 4);
    if ( status_code == 16 )
      return current_status_ptr;
  }
  do
  {
    if ( status_code == 8 )
    {
      current_status_ptr = update_miner_status(*status_entry, status_entry[6]);
    }
    else
    {
      parse_command_line_option((const char **)status_entry);
      current_status_ptr = add_miner_info(status_entry);
    }
    status_entry += 7;
    status_code = status_entry[1];
  }
  while ( status_code != 16 );
  if ( status_update_flag )
    goto LABEL_7;
  return current_status_ptr;
}
// 99EE1C: using guessed type int dword_99EE1C;
// 99EE24: using guessed type int dword_99EE24;

//----- (0003DD54) --------------------------------------------------------
bool __fastcall initialize_and_check_status(
        _DWORD *status_register,
        const char **message_pointer,
        void (*log_function)(const char *, ...))
{
  int check_result; // r0
  int init_counter; // [sp+4h] [bp-1Ch] BYREF

  dword_99EE20 = (int)*message_pointer;
  init_counter = 0;
  do
    check_result = parse_option(status_register, message_pointer, &init_counter, log_function);
  while ( check_result == 1 );
  return check_result == 0;
}
// 99EE20: using guessed type int dword_99EE20;

//----- (0003DDB0) --------------------------------------------------------
void free_miner_resource()
{
  free((void *)dword_99EE1C);
  dword_99EE1C = 0;
}
// 99EE1C: using guessed type int dword_99EE1C;

//----- (0003DDD0) --------------------------------------------------------
int print_error_message(const char *format, ...)
{
  va_list args_list; // [sp+14h] [bp-Ch] BYREF

  va_start(args_list, format);
  vfprintf((FILE *)stderr, format, args_list);
  return fputc(10, (FILE *)stderr);
}
// 7F790: using guessed type int stderr;

//----- (0003DE18) --------------------------------------------------------
void __noreturn fatal_error(const char *format, ...)
{
  va_list args; // [sp+14h] [bp-Ch] BYREF

  va_start(args, format);
  vfprintf((FILE *)stderr, format, args);
  fputc(10, (FILE *)stderr);
  exit(1);
}
// 7F790: using guessed type int stderr;

//----- (0003DE58) --------------------------------------------------------
char *__fastcall format_invalid_argument_message(const char *argument)
{
  size_t argument_length; // r0
  char *error_message; // r4

  argument_length = strlen(argument);
  error_message = (char *)malloc(argument_length + 22);
  sprintf(error_message, "Invalid argument '%s'", argument);
  return error_message;
}

//----- (0003DE88) --------------------------------------------------------
void *__fastcall remove_element_from_array(_DWORD *element_count, int array_ptr, int element_index)
{
  void *memmove_result; // r0

  memmove_result = memmove(
                     (void *)(array_ptr + 4 * element_index),
                     (const void *)(array_ptr + 4 * element_index + 4),
                     4 * (*element_count - element_index));
  --*element_count;
  return memmove_result;
}

//----- (0003DEC0) --------------------------------------------------------
int __fastcall parse_option(
        _DWORD *options_array,
        const char **args,
        int *option_offset,
        void (*error_callback)(const char *, ...))
{
  bool is_posixly_correct; // zf
  int arg_value; // r0
  const char **current_arg; // r6
  const char **arg_iter; // r3
  int arg_index; // r4
  int next_arg; // t1
  const char *option_string; // r0
  int index_after_prefix; // lr
  unsigned int option_index; // r12
  int option_data_offset; // r1
  int option_data; // r3
  const char *arg_option_value; // r10
  int global_option_data_offset; // r3
  int current_option_data; // r1
  char *err_msg; // r11
  int terminator_value; // r10
  const char *possible_long_option; // r0
  int *int_pointer; // r3
  const char *next_option_string; // r7
  int *offset_pointer; // r11
  const char *current_long_option; // r10
  size_t option_length; // r4
  size_t index_after_option; // lr
  int *a3_backup; // r3
  const char *next_dash_option_string; // r11
  size_t current_arg_length; // r0
  int *option_offset_pointer; // r2
  const char *next_option_dash_string; // r11
  const char *current_long_arg; // r3
  size_t index_value_after_equals; // r10
  const char *error_display_string; // [sp+8h] [bp-38h]
  int arg_number; // [sp+Ch] [bp-34h]
  unsigned int parsed_index; // [sp+10h] [bp-30h] BYREF
  size_t match_length_array[11]; // [sp+14h] [bp-2Ch] BYREF

  is_posixly_correct = getenv("POSIXLY_CORRECT") == 0;
  arg_value = (int)args[1];
  if ( !is_posixly_correct )
  {
    current_arg = args + 1;
    if ( !arg_value )
      return arg_value;
    if ( *(_BYTE *)arg_value != 45 )
      return 0;
    arg_index = 1;
    if ( *(_BYTE *)(arg_value + 1) == 45 )
      goto LABEL_23;
LABEL_15:
    option_string = parse_negative_sign(&parsed_index);
    if ( option_string )
    {
      index_after_prefix = *option_offset + 1;
      if ( *(unsigned __int8 *)option_string == (unsigned __int8)(*current_arg)[index_after_prefix] )
      {
LABEL_17:
        option_index = parsed_index;
        error_display_string = option_string - 1;
        *option_offset = index_after_prefix;
        match_length_array[0] = 2;
        option_data_offset = 28 * option_index;
        option_data = dword_99EE1C + 28 * option_index;
        if ( *(_DWORD *)(option_data + 4) != 1 )
        {
LABEL_18:
          if ( index_after_prefix )
          {
            arg_option_value = &(*current_arg)[index_after_prefix + 1];
            if ( *arg_option_value )
            {
              *option_offset = 0;
              goto LABEL_20;
            }
          }
          arg_option_value = args[arg_index + 1];
          if ( arg_option_value )
            goto LABEL_20;
          error_callback("%s: %.*s: %s", *args, match_length_array[0], error_display_string, "requires an argument");
          return -1;
        }
LABEL_37:
        arg_option_value = 0;
        err_msg = (char *)(*(int (__fastcall **)(_DWORD))(option_data + 8))(*(_DWORD *)(option_data + 20));
        goto LABEL_38;
      }
      while ( 1 )
      {
        option_string = check_and_skip_negatives(option_string, &parsed_index);
        if ( !option_string )
          break;
        index_after_prefix = *option_offset + 1;
        if ( (unsigned __int8)(*current_arg)[index_after_prefix] == *(unsigned __int8 *)option_string )
          goto LABEL_17;
      }
    }
LABEL_36:
    current_arg_length = strlen(*current_arg);
    error_callback("%s: %.*s: %s", *args, current_arg_length, *current_arg, "unrecognized option");
    return -1;
  }
  if ( !arg_value )
    return arg_value;
  if ( *(_BYTE *)arg_value == 45 )
  {
    current_arg = args + 1;
    arg_index = 1;
  }
  else
  {
    arg_iter = args + 2;
    arg_index = 1;
    do
    {
      current_arg = arg_iter;
      next_arg = (int)*arg_iter++;
      arg_value = next_arg;
      ++arg_index;
      if ( !next_arg )
        return arg_value;
    }
    while ( *(_BYTE *)arg_value != 45 );
  }
  if ( *(_BYTE *)(arg_value + 1) != 45 )
    goto LABEL_15;
LABEL_23:
  terminator_value = *(unsigned __int8 *)(arg_value + 2);
  if ( !*(_BYTE *)(arg_value + 2) )
  {
    remove_element_from_array(options_array, (int)args, arg_index);
    return terminator_value;
  }
  if ( *option_offset )
    _assert_fail("*offset == 0", "ccan/opt/parse.c", 59u, "parse_one");
  possible_long_option = parse_until_dash(&parsed_index, match_length_array);
  if ( !possible_long_option )
    goto LABEL_36;
  int_pointer = option_offset;
  next_option_string = possible_long_option;
  offset_pointer = int_pointer;
  arg_number = arg_index;
  while ( 1 )
  {
    current_long_option = *current_arg;
    option_length = match_length_array[0];
    if ( strncmp(*current_arg + 2, next_option_string, match_length_array[0]) )
      goto LABEL_35;
    index_after_option = option_length + 2;
    if ( current_long_option[option_length + 2] == 61 )
      break;
    if ( !current_long_option[option_length + 2] )
    {
      option_index = parsed_index;
      a3_backup = offset_pointer;
      next_dash_option_string = next_option_string;
      option_offset = a3_backup;
      arg_index = arg_number;
      error_display_string = next_dash_option_string - 2;
      option_data_offset = 28 * parsed_index;
      match_length_array[0] = index_after_option;
      option_data = dword_99EE1C + 28 * parsed_index;
      if ( *(_DWORD *)(option_data + 4) == 1 )
        goto LABEL_37;
      goto LABEL_34;
    }
LABEL_35:
    next_option_string = find_next_dash_after_string(next_option_string, &parsed_index, match_length_array);
    if ( !next_option_string )
      goto LABEL_36;
  }
  option_index = parsed_index;
  option_offset_pointer = offset_pointer;
  next_option_dash_string = next_option_string;
  option_offset = option_offset_pointer;
  current_long_arg = current_long_option;
  index_value_after_equals = option_length + 3;
  arg_index = arg_number;
  option_data_offset = 28 * parsed_index;
  arg_option_value = &current_long_arg[index_value_after_equals];
  match_length_array[0] = index_after_option;
  error_display_string = next_option_dash_string - 2;
  option_data = dword_99EE1C + 28 * parsed_index;
  if ( *(_DWORD *)(option_data + 4) == 1 )
  {
    if ( arg_option_value )
    {
      error_callback("%s: %.*s: %s", *args, index_after_option, error_display_string, "doesn't allow an argument");
      return -1;
    }
    goto LABEL_37;
  }
  if ( !arg_option_value )
  {
LABEL_34:
    index_after_prefix = *option_offset;
    goto LABEL_18;
  }
LABEL_20:
  global_option_data_offset = dword_99EE1C;
  current_option_data = dword_99EE1C + option_data_offset;
  if ( *(_DWORD *)(current_option_data + 4) == 4 )
  {
    set_value((int)arg_option_value, *(_DWORD **)(current_option_data + 20));
    option_index = parsed_index;
    global_option_data_offset = dword_99EE1C;
  }
  err_msg = (char *)(*(int (__fastcall **)(const char *, _DWORD))(global_option_data_offset + 28 * option_index + 12))(
                      arg_option_value,
                      *(_DWORD *)(global_option_data_offset + 28 * option_index + 20));
LABEL_38:
  if ( err_msg )
  {
    error_callback("%s: %.*s: %s", *args, match_length_array[0], error_display_string, err_msg);
    free(err_msg);
    return -1;
  }
  else
  {
    if ( *option_offset )
    {
      if ( !(*current_arg)[*option_offset + 1] )
      {
        *option_offset = 0;
        goto LABEL_42;
      }
    }
    else
    {
LABEL_42:
      remove_element_from_array(options_array, (int)args, arg_index);
      if ( arg_option_value )
      {
        if ( *current_arg == arg_option_value )
          remove_element_from_array(options_array, (int)args, arg_index);
      }
    }
    return 1;
  }
}
// 99EE1C: using guessed type int dword_99EE1C;

//----- (0003E370) --------------------------------------------------------
char *__fastcall generate_help_message(const char *program_name, const char *help_message_part)
{
  size_t message_length; // r7
  int option_index; // r4
  unsigned int option_count; // r8
  size_t option_name_length; // r7
  size_t intermediate_length; // r0
  size_t option_line_length; // r7
  size_t base_message_length; // r5
  const char *option_name; // r11
  char *help_message_buffer; // r0
  char *message_ptr; // r4
  int sprintf_result; // r0
  char *temp_ptr; // r1
  char *curr_position; // r4
  char *options_start_ptr; // r7
  const char *negatives_parser; // r12
  int negatives_counter; // r8
  int additional_length; // r0
  int total_option_count; // r2
  char *option_line_ptr; // r5
  int option_offset; // r7
  unsigned int processed_options; // r8
  int padding_length; // r2
  unsigned int current_length; // r4
  unsigned int total_length; // r4
  char *line_ending_ptr; // r3
  int option_entry_ptr; // r3
  const char *option_usage; // r2
  int argument_name_length; // r0
  unsigned int arg_length_with_padding; // r4
  char *arg_padding_ptr; // r3
  char *space_char_ptr; // r0
  char *equals_char_ptr; // r0
  int temp_var_1; // r2
  int temp_var_2; // r3
  __int16 *line_ending; // [sp+0h] [bp-98h]
  const char *help_message; // [sp+4h] [bp-94h]
  char *option_argument; // [sp+8h] [bp-90h]
  char *arg_ptr; // [sp+10h] [bp-88h]
  char *help_message_output; // [sp+14h] [bp-84h]
  unsigned int option_info_buffer[31]; // [sp+1Ch] [bp-7Ch] BYREF

  message_length = dword_99EE18 + 20 + strlen(program_name);
  if ( help_message_part )
  {
    message_length += strlen(help_message_part);
    if ( !dword_99EE24 )
      goto LABEL_13;
    option_index = dword_99EE1C;
  }
  else
  {
    if ( !dword_99EE24 )
    {
      help_message_part = "";
      goto LABEL_13;
    }
    temp_var_1 = 0;
    option_index = dword_99EE1C;
    temp_var_2 = dword_99EE1C;
    do
    {
      ++temp_var_1;
      if ( *(void (__fastcall __noreturn **)(const char *))(temp_var_2 + 8) == print_message_and_exit )
      {
        help_message_part = *(const char **)(temp_var_2 + 20);
        if ( help_message_part )
        {
          message_length += strlen(*(const char **)(temp_var_2 + 20));
          goto LABEL_4;
        }
      }
      temp_var_2 += 28;
    }
    while ( temp_var_1 != dword_99EE24 );
    help_message_part = "";
  }
LABEL_4:
  option_count = 0;
  help_message = help_message_part;
  do
  {
    while ( 1 )
    {
      base_message_length = message_length + 6;
      option_name = *(const char **)(option_index + 24);
      if ( *(_DWORD *)(option_index + 4) != 8 )
        break;
      ++option_count;
      message_length += strlen(*(const char **)(option_index + 24)) + 3;
      option_index += 28;
      if ( option_count >= dword_99EE24 )
        goto LABEL_12;
    }
    if ( option_name != (const char *)&unk_99EE28 )
    {
      option_name_length = strlen(*(const char **)option_index);
      intermediate_length = option_name_length + base_message_length + strlen(option_name);
      option_line_length = intermediate_length + 118;
      if ( !*(_DWORD *)(option_index + 16) )
        option_line_length = intermediate_length + 21;
      message_length = option_line_length + 1;
    }
    ++option_count;
    option_index += 28;
  }
  while ( option_count < dword_99EE24 );
LABEL_12:
  help_message_part = help_message;
LABEL_13:
  help_message_buffer = (char *)malloc(message_length);
  message_ptr = help_message_buffer;
  help_message_output = help_message_buffer;
  if ( help_message_buffer )
  {
    sprintf_result = sprintf(help_message_buffer, "Usage: %s", program_name);
    temp_ptr = message_ptr;
    curr_position = &message_ptr[sprintf_result];
    options_start_ptr = curr_position + 3;
    *(_DWORD *)&temp_ptr[sprintf_result] = &unk_2D5B20;
    negatives_parser = parse_negative_sign(option_info_buffer);
    if ( negatives_parser )
    {
      negatives_counter = 0;
      do
      {
        if ( *(_UNKNOWN **)(dword_99EE1C + 28 * option_info_buffer[0] + 24) != &unk_99EE28 )
          options_start_ptr[negatives_counter++] = *negatives_parser;
        negatives_parser = check_and_skip_negatives(negatives_parser, option_info_buffer);
      }
      while ( negatives_parser );
      if ( negatives_counter )
      {
        curr_position = &options_start_ptr[negatives_counter + 1];
        *(_WORD *)&options_start_ptr[negatives_counter] = 93;
      }
    }
    additional_length = sprintf(curr_position, " %s", help_message_part);
    total_option_count = dword_99EE24;
    line_ending = &word_6A02C;
    option_line_ptr = &curr_position[additional_length + 1];
    *(_WORD *)&curr_position[additional_length] = 10;
    if ( total_option_count )
    {
      option_offset = 0;
      processed_options = 0;
      do
      {
        option_entry_ptr = dword_99EE1C + option_offset;
        option_usage = *(const char **)(dword_99EE1C + option_offset + 24);
        if ( option_usage != (const char *)&unk_99EE28 )
        {
          if ( *(_DWORD *)(option_entry_ptr + 4) == 8 )
          {
            option_line_ptr += sprintf(option_line_ptr, "%s:\n", option_usage);
          }
          else
          {
            argument_name_length = sprintf(option_line_ptr, "%s", *(const char **)option_entry_ptr);
            arg_length_with_padding = argument_name_length;
            arg_padding_ptr = &option_line_ptr[argument_name_length];
            if ( *(_DWORD *)(dword_99EE1C + option_offset + 4) == 2 )
            {
              arg_ptr = &option_line_ptr[argument_name_length];
              option_argument = *(char **)(dword_99EE1C + option_offset);
              space_char_ptr = strchr(option_argument, 32);
              arg_padding_ptr = arg_ptr;
              if ( !space_char_ptr )
              {
                equals_char_ptr = strchr(option_argument, 61);
                arg_padding_ptr = arg_ptr;
                if ( !equals_char_ptr )
                {
                  arg_length_with_padding += 6;
                  strcpy(arg_ptr, " <arg>");
                  arg_padding_ptr = &option_line_ptr[arg_length_with_padding];
                }
              }
            }
            if ( arg_length_with_padding > 19 )
              padding_length = 1;
            else
              padding_length = 20 - arg_length_with_padding;
            current_length = sprintf(arg_padding_ptr, "%.*s", padding_length, "                    ", line_ending)
                           + arg_length_with_padding;
            total_length = sprintf(
                             &option_line_ptr[current_length],
                             "%s",
                             *(const char **)(dword_99EE1C + option_offset + 24))
                         + current_length;
            line_ending_ptr = &option_line_ptr[total_length];
            if ( *(_DWORD *)(dword_99EE1C + option_offset + 16) )
            {
              option_info_buffer[20] = (unsigned int)&unk_2E2E2E;
              (*(void (__fastcall **)(unsigned int *, _DWORD))(dword_99EE1C + option_offset + 16))(
                option_info_buffer,
                *(_DWORD *)(dword_99EE1C + option_offset + 20));
              line_ending_ptr = &option_line_ptr[sprintf(
                                                   &option_line_ptr[total_length],
                                                   " (default: %s)",
                                                   (const char *)option_info_buffer)
                                               + total_length];
            }
            *(_WORD *)line_ending_ptr = *line_ending;
            option_line_ptr = line_ending_ptr + 1;
          }
        }
        ++processed_options;
        option_offset += 28;
      }
      while ( dword_99EE24 > processed_options );
    }
    *option_line_ptr = 0;
  }
  return help_message_output;
}
// 3E59C: variable 'line_ending' is possibly undefined
// 6A02C: using guessed type __int16 word_6A02C;
// 99EE18: using guessed type int dword_99EE18;
// 99EE1C: using guessed type int dword_99EE1C;
// 99EE24: using guessed type int dword_99EE24;

//----- (0003E7B4) --------------------------------------------------------
char *__fastcall memchr(char *result, __int16 a2, unsigned int a3)
{
  char *v3; // r3
  int v5; // r4
  char *v6; // r12
  char *v7; // r2
  char *v8; // r3

  if ( !a3 )
    return 0;
  if ( ((unsigned __int8)result & 3) != 0 )
  {
    if ( (unsigned __int8)*result == (unsigned __int8)a2 )
      return result;
    v3 = result + 1;
    while ( 1 )
    {
      --a3;
      result = v3;
      if ( !a3 )
        return 0;
      if ( ((unsigned __int8)v3++ & 3) == 0 )
        break;
      if ( (unsigned __int8)*result == (unsigned __int8)a2 )
        return result;
    }
  }
  v5 = (unsigned __int16)(a2 << 8) | (unsigned __int8)a2 | (((unsigned __int16)(a2 << 8) | (unsigned __int8)a2) << 16);
  if ( a3 > 3 && (((*(_DWORD *)result ^ v5) - 16843009) & ~(*(_DWORD *)result ^ v5) & 0x80808080) == 0 )
  {
    v6 = result + 4;
    while ( 1 )
    {
      a3 -= 4;
      result = v6;
      v6 += 4;
      if ( a3 <= 3 )
        break;
      if ( (((*(_DWORD *)result ^ v5) - 16843009) & ~(*(_DWORD *)result ^ v5) & 0x80808080) != 0 )
        goto LABEL_16;
    }
    if ( !a3 )
      return 0;
  }
LABEL_16:
  if ( (unsigned __int8)*result != (unsigned __int8)a2 )
  {
    v7 = &result[a3];
    v8 = result + 1;
    while ( 1 )
    {
      result = v8++;
      if ( result == v7 )
        break;
      if ( (unsigned __int8)*result == (unsigned __int8)a2 )
        return result;
    }
    return 0;
  }
  return result;
}

//----- (0003E8C8) --------------------------------------------------------
unsigned int __fastcall find_minimum_period(int data, unsigned int data_length, int *period_output)
{
  int min_period; // r6
  int current_index; // r12
  unsigned int period_start; // r4
  int adjustment_offset; // lr
  unsigned int candidate_end; // r3
  int comparison_start_ptr; // r5
  unsigned int comparison_start_value; // r5
  unsigned int candidate_end_value; // r7
  int max_period; // r8
  unsigned int reverse_period_start; // r4
  int reverse_current_index; // r12
  int reverse_adjustment_offset; // r5
  unsigned int reverse_candidate_end; // r3
  int reverse_comparison_start_ptr; // r6
  unsigned int reverse_comparison_start_value; // r6
  unsigned int reverse_candidate_end_value; // r7
  unsigned int min_period_plus_one; // r0
  unsigned int max_period_plus_one; // r5
  bool is_period_found; // zf

  min_period = 1;
  current_index = 1;
  period_start = 0;
  adjustment_offset = -1;
  while ( 1 )
  {
    candidate_end = current_index + period_start;
    comparison_start_ptr = data + adjustment_offset;
    if ( current_index + period_start >= data_length )
      break;
    while ( 1 )
    {
      comparison_start_value = *(unsigned __int8 *)(comparison_start_ptr + current_index);
      candidate_end_value = *(unsigned __int8 *)(data + candidate_end);
      if ( candidate_end_value >= comparison_start_value )
        break;
      period_start = candidate_end;
      current_index = 1;
      min_period = candidate_end - adjustment_offset;
      ++candidate_end;
      comparison_start_ptr = data + adjustment_offset;
      if ( candidate_end >= data_length )
        goto LABEL_5;
    }
    if ( candidate_end_value == comparison_start_value )
    {
      is_period_found = current_index++ == min_period;
      if ( is_period_found )
      {
        period_start = candidate_end;
        current_index = 1;
      }
    }
    else
    {
      min_period = 1;
      adjustment_offset = period_start;
      current_index = 1;
      ++period_start;
    }
  }
LABEL_5:
  max_period = 1;
  reverse_period_start = 0;
  reverse_current_index = 1;
  reverse_adjustment_offset = -1;
  *period_output = min_period;
  while ( 1 )
  {
    reverse_candidate_end = reverse_current_index + reverse_period_start;
    reverse_comparison_start_ptr = data + reverse_adjustment_offset;
    if ( data_length <= reverse_current_index + reverse_period_start )
      break;
    while ( 1 )
    {
      reverse_comparison_start_value = *(unsigned __int8 *)(reverse_comparison_start_ptr + reverse_current_index);
      reverse_candidate_end_value = *(unsigned __int8 *)(data + reverse_candidate_end);
      if ( reverse_candidate_end_value <= reverse_comparison_start_value )
        break;
      reverse_period_start = reverse_candidate_end;
      reverse_current_index = 1;
      max_period = reverse_candidate_end - reverse_adjustment_offset;
      ++reverse_candidate_end;
      reverse_comparison_start_ptr = data + reverse_adjustment_offset;
      if ( data_length <= reverse_candidate_end )
        goto LABEL_9;
    }
    if ( reverse_candidate_end_value == reverse_comparison_start_value )
    {
      is_period_found = reverse_current_index++ == max_period;
      if ( is_period_found )
      {
        reverse_period_start = reverse_candidate_end;
        reverse_current_index = 1;
      }
    }
    else
    {
      max_period = 1;
      reverse_adjustment_offset = reverse_period_start;
      reverse_current_index = 1;
      ++reverse_period_start;
    }
  }
LABEL_9:
  min_period_plus_one = adjustment_offset + 1;
  max_period_plus_one = reverse_adjustment_offset + 1;
  if ( max_period_plus_one >= adjustment_offset + 1 )
  {
    *period_output = max_period;
    return max_period_plus_one;
  }
  return min_period_plus_one;
}

//----- (0003E9D8) --------------------------------------------------------
int __fastcall search_pattern_in_buffer(int buffer, int buffer_length, void *pattern, unsigned int pattern_length)
{
  unsigned int last_index; // r4
  unsigned int minimum_period; // r6
  int *shift_table_ptr; // r3
  char *pattern_ptr; // r1
  int index; // r3
  int current_char; // t1
  unsigned int comparison_result; // r0
  unsigned int shift_amount; // r3
  bool has_more; // cf
  unsigned int shift_value; // r1
  unsigned int max_shift; // r1
  char *scan_ptr; // lr
  unsigned __int8 *buffer_ptr; // r12
  int pattern_char; // r9
  int pattern_byte; // t1
  int buffer_byte; // t1
  unsigned int search_index; // lr
  unsigned __int8 *buffer_char_ptr; // r1
  char *pattern_char_ptr; // r8
  int matched_char; // r10
  int pattern_cur_char; // t1
  int buffer_cur_char; // t1
  int matching_position; // r0
  unsigned int shift_end; // r3
  unsigned int backtrack_index; // r2
  unsigned int search_area_length; // r10
  unsigned int buffer_index; // r9
  int shift_table_value; // r3
  unsigned __int8 *next_buffer_char_ptr; // r1
  unsigned int current_shift; // r3
  char *next_pattern_char_ptr; // r12
  int expected_char; // r8
  int next_pattern_byte; // t1
  int next_buffer_byte; // t1
  unsigned __int8 *rev_buffer_char_ptr; // r3
  char *rev_pattern_char_ptr; // r1
  int pattern_char_rev; // lr
  int pattern_byte_rev; // t1
  int buffer_byte_rev; // t1
  unsigned int remaining_length; // [sp+0h] [bp-448h]
  unsigned int initial_shift; // [sp+4h] [bp-444h]
  int next_shift; // [sp+4h] [bp-444h]
  unsigned int max_shift_minus_period; // [sp+Ch] [bp-43Ch]
  int shift_table[253]; // [sp+1Ch] [bp-42Ch] BYREF
  int last_shift_table_value; // [sp+41Ch] [bp-2Ch] BYREF

  last_index = pattern_length - 1;
  if ( pattern_length > 2 )
  {
    minimum_period = find_minimum_period((int)pattern, pattern_length, shift_table);
    initial_shift = shift_table[0];
  }
  else
  {
    minimum_period = pattern_length - 1;
    initial_shift = 1;
    shift_table[0] = 1;
  }
  shift_table_ptr = shift_table;
  do
  {
    shift_table_ptr[1] = pattern_length;
    ++shift_table_ptr;
  }
  while ( shift_table_ptr != &last_shift_table_value );
  if ( pattern_length )
  {
    pattern_ptr = (char *)pattern - 1;
    index = last_index;
    do
    {
      current_char = (unsigned __int8)*++pattern_ptr;
      shift_table[current_char + 1] = index;
      has_more = index-- != 0;
    }
    while ( has_more );
  }
  comparison_result = memcmp(pattern, (char *)pattern + initial_shift, minimum_period);
  if ( !comparison_result )
  {
    remaining_length = buffer_length - pattern_length;
    max_shift_minus_period = pattern_length - initial_shift;
    shift_amount = 0;
    while ( 1 )
    {
      while ( 1 )
      {
        shift_value = shift_table[*(unsigned __int8 *)(buffer + shift_amount + last_index) + 1];
        if ( shift_value )
        {
          has_more = 1;
          if ( comparison_result )
            has_more = shift_value >= initial_shift;
          comparison_result = 0;
          if ( !has_more )
            shift_value = max_shift_minus_period;
          shift_amount += shift_value;
          goto LABEL_15;
        }
        max_shift = minimum_period < comparison_result ? comparison_result : minimum_period;
        if ( max_shift < last_index )
          break;
LABEL_25:
        search_index = minimum_period - 1;
        if ( minimum_period > comparison_result
          && (buffer_char_ptr = (unsigned __int8 *)(buffer + minimum_period - 1 + shift_amount),
              *((unsigned __int8 *)pattern + minimum_period - 1) == *buffer_char_ptr) )
        {
          pattern_char_ptr = (char *)pattern + minimum_period - 1;
          while ( search_index - 1 != comparison_result - 1 )
          {
            pattern_cur_char = (unsigned __int8)*--pattern_char_ptr;
            matched_char = pattern_cur_char;
            buffer_cur_char = *--buffer_char_ptr;
            if ( matched_char != buffer_cur_char )
              break;
            --search_index;
          }
        }
        else
        {
          search_index = minimum_period;
        }
        if ( comparison_result + 1 > search_index )
          return buffer + shift_amount;
        comparison_result = max_shift_minus_period;
        shift_amount += initial_shift;
        if ( remaining_length < shift_amount )
          return 0;
      }
      scan_ptr = (char *)pattern + max_shift;
      buffer_ptr = (unsigned __int8 *)(buffer + max_shift + shift_amount);
      if ( *buffer_ptr == *((unsigned __int8 *)pattern + max_shift) )
      {
        while ( ++max_shift < last_index )
        {
          pattern_byte = (unsigned __int8)*++scan_ptr;
          pattern_char = pattern_byte;
          buffer_byte = *++buffer_ptr;
          if ( pattern_char != buffer_byte )
            goto LABEL_35;
        }
        goto LABEL_25;
      }
LABEL_35:
      comparison_result = 0;
      shift_amount += max_shift + 1 - minimum_period;
LABEL_15:
      if ( remaining_length < shift_amount )
        return 0;
    }
  }
  shift_end = pattern_length - minimum_period;
  backtrack_index = minimum_period - 1;
  search_area_length = buffer_length - pattern_length;
  if ( pattern_length - minimum_period < minimum_period )
    shift_end = minimum_period;
  buffer_index = 0;
  next_shift = shift_end + 1;
  while ( 1 )
  {
    matching_position = buffer + buffer_index;
    shift_table_value = shift_table[*(unsigned __int8 *)(buffer + buffer_index + last_index) + 1];
    if ( !shift_table_value )
      break;
LABEL_52:
    buffer_index += shift_table_value;
LABEL_53:
    if ( buffer_index > search_area_length )
      return 0;
  }
  if ( minimum_period < last_index )
  {
    next_buffer_char_ptr = (unsigned __int8 *)(buffer + minimum_period + buffer_index);
    if ( *next_buffer_char_ptr != *((unsigned __int8 *)pattern + minimum_period) )
    {
      current_shift = minimum_period;
LABEL_55:
      buffer_index += current_shift + 1 - minimum_period;
      goto LABEL_53;
    }
    next_pattern_char_ptr = (char *)pattern + minimum_period;
    current_shift = minimum_period;
    while ( ++current_shift < last_index )
    {
      next_pattern_byte = (unsigned __int8)*++next_pattern_char_ptr;
      expected_char = next_pattern_byte;
      next_buffer_byte = *++next_buffer_char_ptr;
      if ( expected_char != next_buffer_byte )
        goto LABEL_55;
    }
  }
  if ( !minimum_period )
    return matching_position;
  rev_buffer_char_ptr = (unsigned __int8 *)(buffer + backtrack_index + buffer_index);
  if ( *rev_buffer_char_ptr != *((unsigned __int8 *)pattern + backtrack_index) )
  {
LABEL_51:
    shift_table_value = next_shift;
    goto LABEL_52;
  }
  rev_pattern_char_ptr = (char *)pattern + backtrack_index;
  while ( rev_pattern_char_ptr != pattern )
  {
    pattern_byte_rev = (unsigned __int8)*--rev_pattern_char_ptr;
    pattern_char_rev = pattern_byte_rev;
    buffer_byte_rev = *--rev_buffer_char_ptr;
    if ( pattern_char_rev != buffer_byte_rev )
      goto LABEL_51;
  }
  return matching_position;
}

//----- (0003ED04) --------------------------------------------------------
char *__fastcall memmem(char *a1, unsigned int a2, unsigned __int8 *a3, unsigned int a4)
{
  char *v6; // r5
  char *v9; // r0
  _BOOL4 v10; // r3
  unsigned int v11; // r7
  unsigned int minimum_period; // r6
  unsigned int v13; // r0
  unsigned int v14; // r2
  unsigned int v15; // r12
  unsigned int v16; // r3
  unsigned __int8 *v17; // lr
  char *v18; // r1
  int v19; // r8
  int v20; // t1
  int v21; // t1
  unsigned int v22; // lr
  char *v23; // r3
  unsigned __int8 *v24; // r7
  int v25; // r9
  int v26; // t1
  int v27; // t1
  unsigned int v29; // r3
  unsigned int v30; // r9
  unsigned int v31; // r0
  unsigned int v32; // r7
  char *v33; // r2
  unsigned int v34; // r3
  unsigned __int8 *v35; // r1
  int v36; // lr
  int v37; // t1
  int v38; // t1
  char *v39; // r3
  unsigned __int8 *v40; // r2
  int v41; // r12
  int v42; // t1
  int v43; // t1
  int v44; // [sp+4h] [bp-44h]
  int v45; // [sp+8h] [bp-40h]
  int v46; // [sp+1Ch] [bp-2Ch] BYREF

  if ( !a4 )
    return a1;
  if ( a4 > a2 )
    return 0;
  if ( a4 > 31 )
    return (char *)search_pattern_in_buffer((int)a1, a2, a3, a4);
  v9 = memchr(a1, *a3, a2);
  v6 = v9;
  v10 = a4 == 1;
  if ( !v9 )
    v10 = 1;
  if ( v10 )
    return v6;
  v11 = a2 - (v9 - a1);
  if ( a4 > v11 )
    return 0;
  if ( a4 > 2 )
  {
    minimum_period = find_minimum_period((int)a3, a4, &v46);
    v45 = v46;
  }
  else
  {
    minimum_period = a4 - 1;
    v45 = 1;
    v46 = 1;
  }
  v13 = memcmp(a3, &a3[v45], minimum_period);
  if ( !v13 )
  {
    v14 = v11 - a4;
    v15 = 0;
    while ( 1 )
    {
      if ( minimum_period < v15 )
        v16 = v15;
      else
        v16 = minimum_period;
      if ( a4 > v16 )
      {
        v17 = &a3[v16];
        v18 = &v6[v16 + v13];
        if ( a3[v16] != (unsigned __int8)*v18 )
        {
LABEL_32:
          v15 = 0;
          v13 += 1 - minimum_period + v16;
          goto LABEL_29;
        }
        while ( a4 != ++v16 )
        {
          v20 = *++v17;
          v19 = v20;
          v21 = (unsigned __int8)*++v18;
          if ( v19 != v21 )
            goto LABEL_32;
        }
      }
      v22 = minimum_period - 1;
      if ( minimum_period > v15
        && (v23 = &v6[minimum_period - 1 + v13], a3[minimum_period - 1] == (unsigned __int8)*v23) )
      {
        v24 = &a3[minimum_period - 1];
        while ( v22 - 1 != v15 - 1 )
        {
          v26 = *--v24;
          v25 = v26;
          v27 = (unsigned __int8)*--v23;
          if ( v25 != v27 )
            break;
          --v22;
        }
      }
      else
      {
        v22 = minimum_period;
      }
      if ( v15 + 1 > v22 )
      {
        v6 += v13;
        return v6;
      }
      v15 = a4 - v45;
      v13 += v45;
LABEL_29:
      if ( v14 < v13 )
        return 0;
    }
  }
  v29 = a4 - minimum_period;
  v30 = minimum_period - 1;
  v31 = v11 - a4;
  if ( a4 - minimum_period < minimum_period )
    v29 = minimum_period;
  v32 = 0;
  v44 = v29 + 1;
  while ( 1 )
  {
    if ( a4 > minimum_period )
    {
      v33 = &v6[minimum_period + v32];
      if ( (unsigned __int8)*v33 != a3[minimum_period] )
      {
        v34 = minimum_period;
LABEL_49:
        v32 += 1 - minimum_period + v34;
        goto LABEL_50;
      }
      v35 = &a3[minimum_period];
      v34 = minimum_period;
      while ( a4 != ++v34 )
      {
        v37 = *++v35;
        v36 = v37;
        v38 = (unsigned __int8)*++v33;
        if ( v36 != v38 )
          goto LABEL_49;
      }
    }
    if ( !minimum_period )
      return &v6[v32];
    v39 = &v6[v30 + v32];
    if ( (unsigned __int8)*v39 == a3[v30] )
      break;
LABEL_52:
    v32 += v44;
LABEL_50:
    if ( v31 < v32 )
      return 0;
  }
  v40 = &a3[v30];
  while ( v40 != a3 )
  {
    v42 = *--v40;
    v41 = v42;
    v43 = (unsigned __int8)*--v39;
    if ( v41 != v43 )
      goto LABEL_52;
  }
  return &v6[v32];
}

//----- (0003EFF0) --------------------------------------------------------
int __fastcall measure_asic_voltages(int asic_id, int asic_increment)
{
  const char *hardware_version; // r0
  const char *shared_variable; // r0
  int domain_index; // r7
  int domain_count; // r8
  int asic_index_within_domain; // r6
  _DWORD *logging_category; // r0
  int asic_global_index; // r4
  int asic_base_address; // r5
  int register_value; // r11
  unsigned int register_raw_data1; // r11
  unsigned int register_raw_data2; // r0
  double *voltages_array_ptr; // r3
  double *asic_voltage_data; // r4
  double voltage_domain_0; // d3
  double voltage_domain_1; // d4
  double voltage_domain_2; // d6
  double voltage_domain_3; // d5
  int dump_loop_index; // r11
  _DWORD *log_category; // r0
  int domain_count_again; // r10
  unsigned int asic_index_within_domain_again; // r4
  _DWORD *log_category_for_dump; // r0
  unsigned int asic_global_index_again; // r5
  int domain_count_third; // r0
  bool is_bit_difficulty_one; // zf
  double *voltages_array_ptr_again; // r12
  int global_variable_count; // r8
  unsigned int asic_incremented_value; // r5
  int asic_activation_loop_index; // r4
  _QWORD *double_array_ptr; // r6
  int device_active_status; // r0
  int global_state_loop_index; // r7
  int asic_count_per_domain; // r11
  int internal_asic_index; // r4
  _DWORD *log_category_ptr; // r0
  int asic_global_idx; // r5
  int asic_address_offset; // r8
  int asic_control_register; // r9
  unsigned int ASICRegister; // r9
  unsigned int asic_register2_data; // r0
  double *asic_voltages_ptr; // r12
  _DWORD *log_category_ptr_again; // r0
  char *domain_string_idx; // r6
  int formatted_string_length; // r5
  int asic_count; // r8
  int i; // r4
  int formatted_string_arg; // r3
  _DWORD *logging_category_ptr; // r0
  double asic_voltage_d0; // [sp+0h] [bp-3110h]
  double asic_voltage_d1; // [sp+8h] [bp-3108h]
  double asic_voltage_d2; // [sp+10h] [bp-3100h]
  double asic_voltage_d3; // [sp+18h] [bp-30F8h]
  double asic_voltage_average; // [sp+28h] [bp-30E8h]
  char *global_state_value_str; // [sp+38h] [bp-30D8h]
  char *format; // [sp+38h] [bp-30D8h]
  char *asic_id_str; // [sp+40h] [bp-30D0h]
  char *global_state_value_first; // [sp+40h] [bp-30D0h]
  int global_state_value; // [sp+44h] [bp-30CCh]
  unsigned int asic_id_byte; // [sp+4Ch] [bp-30C4h]
  char log_buffer[128]; // [sp+50h] [bp-30C0h] BYREF
  _QWORD asic_voltage_storage[510]; // [sp+D0h] [bp-3040h] BYREF
  _OWORD voltages_large_array[516]; // [sp+10D0h] [bp-2040h] BYREF

  memset(voltages_large_array, 0, 8192u);
  hardware_version = (const char *)get_shared_variable();
  if ( strcmp(hardware_version, "BHB28601") )
  {
    shared_variable = (const char *)get_shared_variable();
    if ( strcmp(shared_variable, "BHB28701") )
    {
      global_variable_count = get_global_variable_value();
      if ( global_variable_count )
      {
        asic_incremented_value = 0;
        asic_activation_loop_index = 0;
        double_array_ptr = asic_voltage_storage;
        do
        {
          device_active_status = asic_activation_loop_index++;
          if ( !is_device_id_active(device_active_status) )
          {
            initialize_asic_wrapper((unsigned __int8)asic_id, asic_incremented_value);
            usleep(5000u);
            init_asic_mining_with_options((unsigned __int8)asic_id, asic_incremented_value);
            usleep(10000u);
            *double_array_ptr = 0LL;
          }
          asic_incremented_value += asic_increment;
          ++double_array_ptr;
        }
        while ( global_variable_count != asic_activation_loop_index );
      }
      usleep(100000u);
      global_state_value_first = (char *)get_global_state_value();
      if ( !global_state_value_first )
      {
LABEL_50:
        format = (char *)get_global_state_value();
        if ( format )
        {
          for ( domain_string_idx = 0; domain_string_idx != format; ++domain_string_idx )
          {
            formatted_string_length = sprintf(log_buffer, "domain %2d:", domain_string_idx);
            asic_count = get_global_value();
            if ( asic_count )
            {
              for ( i = 0; i != asic_count; ++i )
              {
                formatted_string_arg = i + (_DWORD)domain_string_idx * get_global_value();
                formatted_string_length += sprintf(
                                             &log_buffer[formatted_string_length],
                                             "\t%.2f",
                                             *(double *)&asic_voltage_storage[formatted_string_arg]);
              }
            }
            logging_category_ptr = (_DWORD *)dword_4FCB48;
            if ( !dword_4FCB48 )
            {
              logging_category_ptr = get_logging_category("bmminer_adc");
              dword_4FCB48 = (int)logging_category_ptr;
            }
            log_event(
              (int)logging_category_ptr,
              "log/adc_sample.c",
              16,
              (int)"check_adc_voltage",
              17,
              169,
              20,
              (int)"chain %2d %s",
              asic_id,
              log_buffer);
          }
        }
        goto LABEL_30;
      }
      global_state_loop_index = 0;
      while ( 1 )
      {
        asic_count_per_domain = get_global_value();
        if ( asic_count_per_domain )
          break;
LABEL_49:
        if ( global_state_value_first == (char *)++global_state_loop_index )
          goto LABEL_50;
      }
      internal_asic_index = 0;
      while ( 1 )
      {
        while ( 1 )
        {
          asic_global_idx = internal_asic_index + global_state_loop_index * get_global_value();
          if ( !is_device_id_active(asic_global_idx) )
            break;
LABEL_43:
          if ( asic_count_per_domain == ++internal_asic_index )
            goto LABEL_49;
        }
        asic_address_offset = asic_global_idx * asic_increment;
        memset(log_buffer, 0, sizeof(log_buffer));
        asic_control_register = ReadASICRegister(176, asic_global_idx * asic_increment, asic_id);
        if ( (asic_control_register & 4) == 0 )
        {
          log_category_ptr = (_DWORD *)dword_4FCB48;
          if ( !dword_4FCB48 )
          {
            log_category_ptr = get_logging_category("bmminer_adc");
            dword_4FCB48 = (int)log_category_ptr;
          }
          log_event(
            (int)log_category_ptr,
            "log/adc_sample.c",
            16,
            (int)"check_adc_voltage",
            17,
            141,
            20,
            (int)"chain::%d, asic::%d adc control vm sample not ready %08x.\n",
            asic_id,
            asic_global_idx,
            asic_control_register);
          goto LABEL_43;
        }
        ASICRegister = ReadASICRegister(180, asic_address_offset, asic_id);
        asic_register2_data = ReadASICRegister(184, asic_address_offset, asic_id);
        asic_voltages_ptr = (double *)&voltages_large_array[2 * asic_global_idx];
        asic_voltage_d0 = (float)((float)(ASICRegister & 0xFFF) * 0.00048828) * 1.18800008 - 1.18800008;
        asic_voltage_d1 = (float)((float)(HIWORD(ASICRegister) & 0xFFF) * 0.00048828) * 1.18800008 - 1.18800008;
        asic_voltage_d2 = (float)((float)(asic_register2_data & 0xFFF) * 0.00048828) * 1.18800008 - 1.18800008;
        asic_voltage_d3 = (float)((float)(HIWORD(asic_register2_data) & 0xFFF) * 0.00048828) * 1.18800008 - 1.18800008;
        asic_voltages_ptr[3] = asic_voltage_d3;
        *asic_voltages_ptr = asic_voltage_d0;
        asic_voltages_ptr[1] = asic_voltage_d1;
        asic_voltages_ptr[2] = asic_voltage_d2;
        asic_voltage_average = (asic_voltage_d0 + asic_voltage_d1 + asic_voltage_d2 + asic_voltage_d3) * 0.25;
        *(double *)&asic_voltage_storage[asic_global_idx] = asic_voltage_average;
        sprintf(
          log_buffer,
          "chain %2d asic %03d adc:\t%.2f\t%.2f\t%.2f\t%.2f\t%.2f\t%.2f",
          asic_id,
          asic_global_idx,
          asic_voltage_d0,
          asic_voltage_d1,
          asic_voltage_d2,
          asic_voltage_d3,
          asic_voltage_d0 + asic_voltage_d1 + asic_voltage_d2 + asic_voltage_d3,
          asic_voltage_average);
        log_category_ptr_again = (_DWORD *)dword_4FCB48;
        if ( !dword_4FCB48 )
        {
          log_category_ptr_again = get_logging_category("bmminer_adc");
          dword_4FCB48 = (int)log_category_ptr_again;
        }
        ++internal_asic_index;
        log_event(
          (int)log_category_ptr_again,
          "log/adc_sample.c",
          16,
          (int)"check_adc_voltage",
          17,
          157,
          20,
          (int)"asic adc:%s",
          log_buffer);
        if ( asic_count_per_domain == internal_asic_index )
          goto LABEL_49;
      }
    }
  }
  asic_id_byte = (unsigned __int8)asic_id;
  pthread_mutex_lock(&stru_7F7EC);
  check_and_configure_asics(1);
  usleep(20000u);
  initialize_single_asic((unsigned __int8)asic_id);
  usleep(20000u);
  enable_asic_hashing((unsigned __int8)asic_id);
  usleep(20000u);
  global_state_value_str = (char *)get_global_state_value();
  if ( global_state_value_str )
  {
    domain_index = 0;
    while ( 1 )
    {
      domain_count = get_global_value();
      if ( domain_count )
        break;
LABEL_14:
      if ( global_state_value_str == (char *)++domain_index )
        goto LABEL_15;
    }
    asic_index_within_domain = 0;
    while ( 1 )
    {
      while ( 1 )
      {
        asic_global_index = asic_index_within_domain + domain_index * get_global_value();
        asic_base_address = asic_global_index * sub_1E160();
        if ( !is_device_id_active(asic_global_index) )
          break;
LABEL_10:
        if ( domain_count == ++asic_index_within_domain )
          goto LABEL_14;
      }
      register_value = ReadASICRegister(176, asic_base_address, asic_id);
      if ( (register_value & 4) == 0 )
      {
        logging_category = (_DWORD *)dword_4FCB48;
        if ( !dword_4FCB48 )
        {
          logging_category = get_logging_category("bmminer_adc");
          dword_4FCB48 = (int)logging_category;
        }
        log_event(
          (int)logging_category,
          "log/adc_sample.c",
          16,
          (int)"get_adc_data_with_addr",
          22,
          45,
          20,
          (int)"chain::%d, asic::%d adc control vm sample not ready %08x.\n",
          asic_id,
          asic_global_index,
          register_value);
        goto LABEL_10;
      }
      register_raw_data1 = ReadASICRegister(180, asic_base_address, asic_id);
      register_raw_data2 = ReadASICRegister(184, asic_base_address, asic_id);
      ++asic_index_within_domain;
      voltages_array_ptr = (double *)&voltages_large_array[512] + asic_global_index;
      asic_voltage_data = (double *)&voltages_large_array[2 * asic_global_index];
      voltage_domain_0 = (double)(register_raw_data1 & 0xFFF) * 1.6 * 0.00048828125 - 1.6;
      voltage_domain_1 = (double)(HIWORD(register_raw_data1) & 0xFFF) * 1.6 * 0.00048828125 - 1.6;
      voltage_domain_2 = (double)(HIWORD(register_raw_data2) & 0xFFF) * 1.6 * 0.00048828125 - 1.6;
      *asic_voltage_data = voltage_domain_0;
      voltage_domain_3 = (double)(register_raw_data2 & 0xFFF) * 1.6 * 0.00048828125 - 1.6;
      *(voltages_array_ptr - 1280) = voltage_domain_2;
      asic_voltage_data[1] = voltage_domain_1 - voltage_domain_0;
      asic_voltage_data[2] = voltage_domain_3 - voltage_domain_1;
      asic_voltage_data[3] = voltage_domain_2 - voltage_domain_3;
      if ( domain_count == asic_index_within_domain )
        goto LABEL_14;
    }
  }
LABEL_15:
  global_state_value = get_global_state_value();
  if ( !global_state_value )
    goto LABEL_29;
  dump_loop_index = 0;
  asic_id_str = (char *)asic_id;
  do
  {
    log_category = (_DWORD *)dword_4FCB48;
    if ( !dword_4FCB48 )
    {
      log_category = get_logging_category("bmminer_adc");
      dword_4FCB48 = (int)log_category;
    }
    log_event(
      (int)log_category,
      "log/adc_sample.c",
      16,
      (int)"dump_adc_voltage",
      16,
      67,
      20,
      (int)"[C: %d], [D: %d]",
      asic_id_str,
      dump_loop_index);
    domain_count_again = get_global_value();
    if ( domain_count_again )
    {
      asic_index_within_domain_again = 0;
      do
      {
        memset(asic_voltage_storage, 0, 256u);
        asic_global_index_again = asic_index_within_domain_again + dump_loop_index * get_global_value();
        domain_count_third = get_global_value();
        is_bit_difficulty_one = calculate_bit_difficulty(asic_index_within_domain_again, domain_count_third - 1) == 1;
        voltages_array_ptr_again = (double *)&voltages_large_array[2 * asic_global_index_again];
        if ( is_bit_difficulty_one )
        {
          ++asic_index_within_domain_again;
          snprintf(
            (char *)asic_voltage_storage,
            256u,
            "{I} %2d: d0 %.3f, d1 %.3f, d2 %.3f, d3 %.3f, sum = %f\n",
            asic_global_index_again,
            *(_DWORD *)voltages_array_ptr_again,
            *((_DWORD *)voltages_array_ptr_again + 1),
            *((_DWORD *)voltages_array_ptr_again + 2),
            *((_DWORD *)voltages_array_ptr_again + 3),
            *((_DWORD *)voltages_array_ptr_again + 4),
            *((_DWORD *)voltages_array_ptr_again + 5),
            *((_DWORD *)voltages_array_ptr_again + 6),
            *((_DWORD *)voltages_array_ptr_again + 7),
            LODWORD(asic_voltage_storage[asic_global_index_again + 256]),
            HIDWORD(asic_voltage_storage[asic_global_index_again + 256]));
          log_category_for_dump = (_DWORD *)dword_4FCB48;
          if ( !dword_4FCB48 )
          {
LABEL_26:
            log_category_for_dump = get_logging_category("bmminer_adc");
            dword_4FCB48 = (int)log_category_for_dump;
          }
        }
        else
        {
          ++asic_index_within_domain_again;
          snprintf(
            (char *)asic_voltage_storage,
            256u,
            "{I} %2d: d0 %.3f, d1 %.3f, d2 %.3f, d3 %.3f, sum = %f",
            asic_global_index_again,
            *voltages_array_ptr_again,
            voltages_array_ptr_again[1],
            voltages_array_ptr_again[2],
            voltages_array_ptr_again[3],
            *(double *)&asic_voltage_storage[asic_global_index_again + 256]);
          log_category_for_dump = (_DWORD *)dword_4FCB48;
          if ( !dword_4FCB48 )
            goto LABEL_26;
        }
        log_event(
          (int)log_category_for_dump,
          "log/adc_sample.c",
          16,
          (int)"dump_adc_voltage",
          16,
          81,
          20,
          (int)"%s",
          (const char *)asic_voltage_storage);
      }
      while ( domain_count_again != asic_index_within_domain_again );
    }
    ++dump_loop_index;
  }
  while ( global_state_value != dump_loop_index );
  asic_id = (int)asic_id_str;
LABEL_29:
  disable_asic_heartbeat_and_start_mining(asic_id_byte);
  usleep(20000u);
  check_and_configure_asics(0);
  usleep(20000u);
  pthread_mutex_unlock(&stru_7F7EC);
LABEL_30:
  pthread_mutex_lock(&stru_4FCB4C);
  memcpy((char *)&unk_4FCB68 + 8192 * asic_id, voltages_large_array, 8192u);
  pthread_mutex_unlock(&stru_4FCB4C);
  return 0;
}
// 7F7EC: using guessed type pthread_mutex_t stru_7F7EC;
// 4FCB48: using guessed type int dword_4FCB48;
// 3EFF0: using guessed type char var_30C0[128];

//----- (0003F92C) --------------------------------------------------------
void sub_3F92C()
{
  ;
}

//----- (0003F970) --------------------------------------------------------
int __fastcall calculate_average(int chip_index, int data_index)
{
  bool is_valid_index; // cc
  int chip_offset; // r5
  double sum; // d0
  double *data_ptr; // r1
  int count_down; // r3
  double current_value; // d7

  is_valid_index = chip_index <= 3;
  if ( chip_index <= 3 )
    is_valid_index = data_index <= 255;
  if ( is_valid_index )
  {
    chip_offset = chip_index;
    pthread_mutex_lock(&stru_4FCB4C);
    sum = 0.0;
    data_ptr = (double *)((char *)&unk_4FCB68 + 8192 * chip_offset + 32 * data_index);
    count_down = 4;
    do
    {
      current_value = *data_ptr++;
      --count_down;
      sum = sum + current_value;
    }
    while ( count_down );
    return pthread_mutex_unlock(&stru_4FCB4C);
  }
  return chip_index;
}

//----- (0003F9EC) --------------------------------------------------------
int __fastcall calculate_average_temperature(int sensor_id, int chip_id)
{
  bool within_valid_range; // cc
  int target_sensor_id; // r5
  double temperature_sum; // d8
  double *temperature_ptr; // r1
  int temperature_count; // r3
  double current_temperature; // d7

  within_valid_range = sensor_id <= 3;
  if ( sensor_id <= 3 )
    within_valid_range = chip_id <= 255;
  if ( within_valid_range )
  {
    target_sensor_id = sensor_id;
    pthread_mutex_lock(&stru_4FCB4C);
    temperature_sum = 0.0;
    temperature_ptr = (double *)((char *)&unk_4FCB68 + 8192 * target_sensor_id + 32 * chip_id);
    temperature_count = 4;
    do
    {
      current_temperature = *temperature_ptr++;
      --temperature_count;
      temperature_sum = temperature_sum + current_temperature;
    }
    while ( temperature_count );
    return pthread_mutex_unlock(&stru_4FCB4C);
  }
  return sensor_id;
}

//----- (0003FB58) --------------------------------------------------------
unsigned int initializeHashOnPlug()
{
  unsigned int status; // r0
  int totalPluggedIn; // r12
  int plugIndex; // r1
  int chainIndex; // lr
  int minerIndex; // r3
  int *hashChainArray; // r2
  int nextAvailablePosition; // r5
  unsigned int hashOnPlugValue; // r2
  int *cfgArray; // r3
  unsigned int logMessageValue; // [sp+4h] [bp-82Ch] BYREF
  char logBuffer[2088]; // [sp+8h] [bp-828h] BYREF

  logMessageValue = 0;
  memset(globalHashChainConfig, 0, sizeof(globalHashChainConfig));
  read_register_value(2, &logMessageValue);
  if ( !logMessageValue )
  {
    strcpy(logBuffer, "Cannot Find Any Plug In!\r\n");
    return logMessage(0, logBuffer, 0);
  }
  if ( (logMessageValue & 2147483648) != 0 )
  {
    logMessageValue >>= 24;
    dword_504C8C = 1;
    snprintf(logBuffer, 2048u, "HASH_ON_PLUG T9 = 0x%x\n", logMessageValue);
    status = logMessage(2, logBuffer, 0);
    hashOnPlugValue = logMessageValue;
    if ( !logMessageValue )
      return status;
    totalPluggedIn = globalHashChainConfig[0];
    plugIndex = 0;
    status = 0;
    do
    {
      cfgArray = &globalHashChainConfig[18 * totalPluggedIn];
      if ( (hashOnPlugValue & 1) != 0 )
      {
        cfgArray[1] = status;
        if ( status == 1 )
        {
          cfgArray[3] = 2;
          cfgArray[4] = 10;
          cfgArray[5] = 11;
          cfgArray[2] = 3;
        }
        else if ( status )
        {
          if ( status == 2 )
          {
            cfgArray[3] = 3;
            cfgArray[4] = 12;
            cfgArray[5] = 13;
            cfgArray[2] = 3;
          }
        }
        else
        {
          cfgArray[3] = 1;
          cfgArray[4] = 8;
          cfgArray[5] = 9;
          cfgArray[2] = 3;
        }
        ++totalPluggedIn;
        plugIndex = 1;
      }
      hashOnPlugValue >>= 1;
      ++status;
    }
    while ( hashOnPlugValue );
  }
  else
  {
    dword_504C8C = 0;
    logMessageValue = (unsigned __int16)logMessageValue;
    snprintf(logBuffer, 2048u, "HASH_ON_PLUG V9 = 0x%x\n", (unsigned __int16)logMessageValue);
    logMessage(2, logBuffer, 0);
    status = logMessageValue;
    if ( !logMessageValue )
      return status;
    totalPluggedIn = globalHashChainConfig[0];
    plugIndex = 0;
    chainIndex = 0;
    do
    {
      minerIndex = 9 * totalPluggedIn;
      hashChainArray = &globalHashChainConfig[18 * totalPluggedIn];
      if ( (status & 1) != 0 )
      {
        nextAvailablePosition = hashChainArray[2];
        plugIndex = 1;
        ++totalPluggedIn;
        hashChainArray[1] = chainIndex;
        hashChainArray[2] = nextAvailablePosition + 1;
        globalHashChainConfig[2 * minerIndex + 3 + nextAvailablePosition] = chainIndex;
      }
      status >>= 1;
      ++chainIndex;
    }
    while ( status );
  }
  if ( plugIndex )
    globalHashChainConfig[0] = totalPluggedIn;
  return status;
}
// 504B68: using guessed type int globalHashChainConfig[73];
// 504C8C: using guessed type int dword_504C8C;

//----- (0003FD74) --------------------------------------------------------
int sub_3FD74()
{
  int logging_enabled; // r6
  int init_result; // r5
  char init_error_message[2072]; // [sp+0h] [bp-818h] BYREF

  logging_enabled = dword_504C90;
  if ( dword_504C90 )
    return 0;
  if ( check_and_init_fpga() )
  {
    init_result = -1;
    strcpy(init_error_message, "fpga init failed\n");
    logMessage(logging_enabled, init_error_message, logging_enabled);
    return init_result;
  }
  if ( get_zero() )
  {
    init_result = -2;
    strcpy(init_error_message, "gpio init failed\n");
    logMessage(0, init_error_message, 0);
    return init_result;
  }
  memset(globalHashChainConfig, 0, sizeof(globalHashChainConfig));
  initializeHashOnPlug();
  dword_504C90 = 1;
  is_system_ready();
  initialize_led_status();
  check_platform_initialization();
  return 0;
}
// 504B68: using guessed type int globalHashChainConfig[73];
// 504C90: using guessed type int dword_504C90;

//----- (0003FE60) --------------------------------------------------------
void check_and_perform_system_reset()
{
  if ( dword_504C90 )
  {
    nullsub_12();
    unmap_memory_and_close_files();
    nullsub_10();
    nullsub_13();
    do_nothing();
    dword_504C90 = 0;
  }
}
// 504C90: using guessed type int dword_504C90;

//----- (0003FE98) --------------------------------------------------------
void *__fastcall initialize_and_copy_hash_chain_config(void *destination)
{
  void *config_copy; // r4

  config_copy = destination;
  if ( destination )
  {
    initializeHashOnPlug();
    return memcpy(config_copy, globalHashChainConfig, 292u);
  }
  return destination;
}
// 504B68: using guessed type int globalHashChainConfig[73];

//----- (0003FEFC) --------------------------------------------------------
int is_system_ready()
{
  return 0;
}

//----- (0003FF08) --------------------------------------------------------
int __fastcall get_scaled_frequency(int target_divider)
{
  int retry_count; // r4
  unsigned int register_value; // [sp+0h] [bp-18h] BYREF
  int register_status; // [sp+4h] [bp-14h] BYREF

  register_value = 0;
  retry_count = 6;
  read_register_value(0, &register_status);
  register_status = (unsigned __int16)register_status;
  while ( 1 )
  {
    read_register_value(1, &register_value);
    if ( ((register_value >> 8) & 7) == target_divider )
      break;
    usleep(10000u);
    if ( !--retry_count )
      return -1;
  }
  if ( register_status == 45093 )
    return 240 * (unsigned __int8)register_value;
  else
    return 120 * (unsigned __int8)register_value;
}

//----- (0003FF90) --------------------------------------------------------
int get_fixed_value()
{
  return 6;
}

//----- (0003FF98) --------------------------------------------------------
int always_return_negative_one()
{
  return -1;
}

//----- (0003FFA0) --------------------------------------------------------
int __fastcall get_error_code_sum(int error_type)
{
  int first_error_code; // r4

  if ( !error_type )
    return set_gpio_value(954, 1);
  if ( error_type == 1 )
    return set_gpio_value(955, 1);
  first_error_code = set_gpio_value(954, 1);
  return first_error_code + set_gpio_value(955, 1);
}

//----- (0003FFEC) --------------------------------------------------------
int __fastcall get_total_error_count(int error_type)
{
  int error_code; // r0
  int total_error_count; // r4

  if ( !error_type )
  {
    error_code = 954;
    return set_gpio_value(error_code, 0);
  }
  if ( error_type == 1 )
  {
    error_code = 955;
    return set_gpio_value(error_code, 0);
  }
  total_error_count = set_gpio_value(954, 0);
  return total_error_count + set_gpio_value(955, 0);
}

//----- (00040038) --------------------------------------------------------
int initializeFpgaMemoryMappings()
{
  int fileDescriptorAxi; // r0
  int fileDescriptorFpgaMem; // r0
  int fpgaMemAddr; // r0
  int result; // r0
  char logBuffer[2072]; // [sp+10h] [bp-818h] BYREF

  fileDescriptorAxi = open64("/dev/axi_fpga_dev");
  dword_504C94 = fileDescriptorAxi;
  if ( fileDescriptorAxi < 0 )
  {
    snprintf(logBuffer, 2048u, "/dev/axi_fpga_dev open failed. fd = %d\n", fileDescriptorAxi);
    logMessage(0, logBuffer, 0);
    return -1;
  }
  else
  {
    dword_504C98 = mmap64(0, 4608, 3, 1, fileDescriptorAxi);
    if ( dword_504C98 )
    {
      fileDescriptorFpgaMem = open64("/dev/fpga_mem");
      dword_504C9C = fileDescriptorFpgaMem;
      if ( fileDescriptorFpgaMem < 0 )
      {
        snprintf(logBuffer, 2048u, "/dev/fpga_mem open failed. fd_fpga_mem_hal = %d\n", fileDescriptorFpgaMem);
        logMessage(0, logBuffer, 0);
        perror("open");
        munmap((void *)dword_504C98, 4608u);
        close(dword_504C94);
        return -1;
      }
      else
      {
        fpgaMemAddr = mmap64(0, 16777216, 3, 1, fileDescriptorFpgaMem);
        dword_504CA0 = fpgaMemAddr;
        if ( fpgaMemAddr )
        {
          snprintf(logBuffer, 2048u, "mmap fpga_mem_addr_hal = 0x%x\n", fpgaMemAddr);
          logMessage(3, logBuffer, 0);
          result = 0;
          dword_504CA4 = 1;
        }
        else
        {
          snprintf(logBuffer, 2048u, "mmap fpga_mem_addr_hal failed. fpga_mem_addr_hal = 0x%x\n", 0);
          logMessage(0, logBuffer, 0);
          munmap((void *)dword_504C98, 4608u);
          close(dword_504C94);
          close(dword_504C9C);
          return -1;
        }
      }
    }
    else
    {
      snprintf(logBuffer, 2048u, "mmap axi_fpga_addr failed. axi_fpga_addr = %p\n", 0);
      logMessage(0, logBuffer, 0);
      close(dword_504C94);
      return -2;
    }
  }
  return result;
}
// 12198: using guessed type int __fastcall open64(_DWORD);
// 504C94: using guessed type int dword_504C94;
// 504C98: using guessed type int dword_504C98;
// 504C9C: using guessed type int dword_504C9C;
// 504CA0: using guessed type int dword_504CA0;
// 504CA4: using guessed type int dword_504CA4;

//----- (00040228) --------------------------------------------------------
int check_and_init_fpga()
{
  if ( dword_504CA4 )
    return 0;
  else
    return initializeFpgaMemoryMappings();
}
// 504CA4: using guessed type int dword_504CA4;

//----- (00040248) --------------------------------------------------------
void unmap_memory_and_close_files()
{
  char error_message[2056]; // [sp+0h] [bp-808h] BYREF

  if ( dword_504CA4 )
  {
    if ( munmap((void *)dword_504C98, 4608u) < 0 )
    {
      strcpy(error_message, "munmap failed!\n");
      logMessage(0, error_message, 0);
    }
    if ( munmap((void *)dword_504CA0, 16777216u) < 0 )
    {
      strcpy(error_message, "munmap fpga_mem_addr_hal failed!\n");
      logMessage(0, error_message, 0);
    }
    dword_504CA4 = 0;
    close(dword_504C94);
    close(dword_504C9C);
  }
}
// 504C94: using guessed type int dword_504C94;
// 504C98: using guessed type int dword_504C98;
// 504C9C: using guessed type int dword_504C9C;
// 504CA0: using guessed type int dword_504CA0;
// 504CA4: using guessed type int dword_504CA4;

//----- (00040314) --------------------------------------------------------
int __fastcall read_register_value(int register_index, _DWORD *register_value_ptr)
{
  int offset_index; // r3
  int read_result; // r0

  if ( !dword_504CA4 && initializeFpgaMemoryMappings() )
    return -1;
  if ( dword_504C8C )
    offset_index = dword_7EE48[register_index];
  else
    offset_index = dword_7EE48[register_index + 186];
  read_result = 0;
  *register_value_ptr = *(_DWORD *)(dword_504C98 + 4 * offset_index);
  return read_result;
}
// 7EE48: using guessed type _DWORD dword_7EE48[372];
// 504C8C: using guessed type int dword_504C8C;
// 504C98: using guessed type int dword_504C98;
// 504CA4: using guessed type int dword_504CA4;

//----- (00040390) --------------------------------------------------------
int __fastcall set_register_value(int register_index, int value)
{
  int mapped_index; // r3

  if ( !dword_504CA4 && initializeFpgaMemoryMappings() )
    return -1;
  if ( dword_504C8C )
    mapped_index = dword_7EE48[register_index];
  else
    mapped_index = dword_7EE48[register_index + 186];
  *(_DWORD *)(dword_504C98 + 4 * mapped_index) = value;
  return 0;
}
// 7EE48: using guessed type _DWORD dword_7EE48[372];
// 504C8C: using guessed type int dword_504C8C;
// 504C98: using guessed type int dword_504C98;
// 504CA4: using guessed type int dword_504CA4;

//----- (00040408) --------------------------------------------------------
int check_fpga_initialized()
{
  int initial_state; // r5

  initial_state = dword_504CA4;
  if ( dword_504CA4 || !initializeFpgaMemoryMappings() )
    return dword_504CA0;
  else
    return initial_state;
}
// 504CA0: using guessed type int dword_504CA0;
// 504CA4: using guessed type int dword_504CA4;

//----- (0004043C) --------------------------------------------------------
int __fastcall subtract_pointers(_DWORD *pointer_a, _DWORD *pointer_b)
{
  return *pointer_a - *pointer_b;
}

//----- (0004044C) --------------------------------------------------------
int get_zero()
{
  return 0;
}

//----- (00040458) --------------------------------------------------------
int __fastcall control_gpio(int gpio_request_code, unsigned int gpio_value_flag)
{
  pthread_mutexattr_t *v3; // r5
  int v5; // [sp+Ch] [bp-81Ch] BYREF
  pthread_attr_t v6[57]; // [sp+10h] [bp-818h] BYREF

  v5 = gpio_request_code;
  if ( gpio_value_flag )
  {
    v3 = (pthread_mutexattr_t *)dword_504CA8;
    if ( !dword_504CA8 )
    {
      pthread_mutex_init(&stru_504CAC, (const pthread_mutexattr_t *)dword_504CA8);
      dword_504CC4 = (int)allocate_and_init_struct((int)subtract_pointers, (int)v3, (int)v3);
      pthread_mutex_init(&stru_504CC8, v3);
      dword_504CE0 = 1;
      pthread_attr_init(v6);
      pthread_attr_setstacksize(v6, 2097152u);
      pthread_create((pthread_t *)algn_504CE4, v6, (void *(*)(void *))monitor_gpio_changes, v3);
      dword_504CA8 = 1;
    }
    if ( pthread_mutex_lock(&stru_504CAC) )
    {
      strcpy(v6[0].__size, "fail to lock gpio ctrl mutex\n");
      logMessage(0, v6[0].__size, 0);
      return -1;
    }
    else
    {
      if ( !check_and_update_status((int *)dword_504CC4, (int)&v5) )
      {
        *(_QWORD *)v6[0].__size = gpio_value_flag | 0xFFFFFFFF00000000LL;
        process_miner_data((int *)dword_504CC4, &v5, 4u, v6, 8u);
      }
      pthread_mutex_unlock(&stru_504CAC);
      return 0;
    }
  }
  else
  {
    strcpy(v6[0].__size, "bad param\n");
    logMessage(0, v6[0].__size, 0);
    return -1;
  }
}
// 504CA8: using guessed type int dword_504CA8;
// 504CC4: using guessed type int dword_504CC4;
// 504CE0: using guessed type int dword_504CE0;
// 40458: using guessed type pthread_attr_t var_818[57];

//----- (000405CC) --------------------------------------------------------
int __fastcall handle_gpio_control(int gpio_value, int is_valid_param)
{
  int gpio_value_copy; // [sp+4h] [bp-814h] BYREF
  char message_buffer[2064]; // [sp+8h] [bp-810h] BYREF

  gpio_value_copy = gpio_value;
  if ( is_valid_param )
  {
    if ( pthread_mutex_lock(&stru_504CAC) )
    {
      strcpy(message_buffer, "fail to lock gpio ctrl mutex\n");
      logMessage(0, message_buffer, 0);
      return -1;
    }
    else
    {
      if ( check_and_update_status((int *)dword_504CC4, (int)&gpio_value_copy) == (int *)1 )
      {
        handle_network_packet((int *)dword_504CC4, (int)&gpio_value_copy);
      }
      else
      {
        strcpy(message_buffer, "callback function not registered before\n");
        logMessage(1, message_buffer, 0);
      }
      pthread_mutex_unlock(&stru_504CAC);
      return 0;
    }
  }
  else
  {
    strcpy(message_buffer, "bad param\n");
    logMessage(0, message_buffer, 0);
    return -1;
  }
}
// 504CC4: using guessed type int dword_504CC4;

//----- (000406E4) --------------------------------------------------------
int __fastcall check_gpio_access(int gpio_number)
{
  char buffer[2064]; // [sp+0h] [bp-810h] BYREF

  if ( pthread_mutex_lock(&stru_504CC8) )
  {
    strcpy(buffer, "failed to api lock\n");
    logMessage(0, buffer, 0);
    return -1;
  }
  else
  {
    snprintf(buffer, 64u, "/sys/class/gpio/gpio%d", gpio_number);
    if ( access(buffer, 0) )
    {
      pthread_mutex_unlock(&stru_504CC8);
      return 0;
    }
    else
    {
      pthread_mutex_unlock(&stru_504CC8);
      return 1;
    }
  }
}

//----- (00040794) --------------------------------------------------------
int __fastcall export_gpio(int gpio_number)
{
  int export_fd; // r6
  int num_written; // r0
  char gpio_path[64]; // [sp+0h] [bp-850h] BYREF
  char error_message[2064]; // [sp+40h] [bp-810h] BYREF

  if ( pthread_mutex_lock(&stru_504CC8) )
  {
    strcpy(error_message, "failed to api lock\n");
    logMessage(0, error_message, 0);
    return -1;
  }
  else
  {
    snprintf(gpio_path, 64u, "/sys/class/gpio/gpio%d", gpio_number);
    if ( access(gpio_path, 0) )
    {
      export_fd = open64("/sys/class/gpio/export");
      if ( export_fd < 0 )
      {
        strcpy(error_message, "Failed to open export for writing!\n");
        logMessage(0, error_message, 0);
        pthread_mutex_unlock(&stru_504CC8);
        return -2;
      }
      else
      {
        num_written = snprintf(gpio_path, 64u, "%d", gpio_number);
        if ( write(export_fd, gpio_path, num_written) < 0 )
        {
          snprintf(error_message, 2048u, "Failed to export gpio %d!", gpio_number);
          logMessage(0, error_message, 0);
          close(export_fd);
          pthread_mutex_unlock(&stru_504CC8);
          return -3;
        }
        else
        {
          close(export_fd);
          pthread_mutex_unlock(&stru_504CC8);
          return 0;
        }
      }
    }
    else
    {
      pthread_mutex_unlock(&stru_504CC8);
      return 0;
    }
  }
}
// 12198: using guessed type int __fastcall open64(_DWORD);

//----- (00040AD8) --------------------------------------------------------
int __fastcall set_gpio_direction(int gpio_number, int direction)
{
  int gpio_dir_fd; // r0
  size_t direction_str_len; // r2
  int direction_file_descriptor; // r7
  bool is_input_direction; // zf
  const char *direction_str; // r4
  char gpio_direction_path[64]; // [sp+8h] [bp-858h] BYREF
  char error_message[2072]; // [sp+48h] [bp-818h] BYREF

  if ( pthread_mutex_lock(&stru_504CC8) )
  {
    strcpy(error_message, "failed to api lock\n");
    logMessage(0, error_message, 0);
    return -1;
  }
  else
  {
    snprintf(gpio_direction_path, 64u, "/sys/class/gpio/gpio%d/direction", gpio_number);
    gpio_dir_fd = open64(gpio_direction_path);
    direction_file_descriptor = gpio_dir_fd;
    if ( gpio_dir_fd < 0 )
    {
      snprintf(error_message, 2048u, "Failed to open gpio %d direction for writing!\n", gpio_number);
      logMessage(0, error_message, 0);
      pthread_mutex_unlock(&stru_504CC8);
      return -2;
    }
    else
    {
      is_input_direction = direction == 0;
      if ( !direction )
        direction_str_len = 2;
      direction_str = "out";
      if ( is_input_direction )
        direction_str = "in";
      else
        direction_str_len = 3;
      if ( write(gpio_dir_fd, direction_str, direction_str_len) < 0 )
      {
        snprintf(error_message, 2048u, "Failed to set gpio %d direction %s !\n", gpio_number, direction_str);
        logMessage(0, error_message, 0);
        close(direction_file_descriptor);
        pthread_mutex_unlock(&stru_504CC8);
        return -3;
      }
      else
      {
        close(direction_file_descriptor);
        pthread_mutex_unlock(&stru_504CC8);
        return 0;
      }
    }
  }
}
// 40B48: variable 'direction_str_len' is possibly undefined
// 12198: using guessed type int __fastcall open64(_DWORD);

//----- (00040C28) --------------------------------------------------------
int __fastcall readGPIOValue(int gpioNumber, _BYTE *gpioValue)
{
  int v4; // r4
  int openResult; // r0
  int fileDescriptor; // r5
  int buffer; // [sp+Ch] [bp-85Ch] BYREF
  char gpioPath[64]; // [sp+10h] [bp-858h] BYREF
  char logBuffer[2072]; // [sp+50h] [bp-818h] BYREF

  buffer = 0;
  v4 = pthread_mutex_lock(&stru_504CC8);
  if ( v4 )
  {
    v4 = -1;
    strcpy(logBuffer, "failed to api lock\n");
    logMessage(0, logBuffer, 0);
  }
  else
  {
    snprintf(gpioPath, 64u, "/sys/class/gpio/gpio%d/value", gpioNumber);
    openResult = open64(gpioPath);
    fileDescriptor = openResult;
    if ( openResult < 0 )
    {
      snprintf(logBuffer, 2048u, "Failed to open gpio %d value for reading!\n", gpioNumber);
      v4 = -2;
      logMessage(0, logBuffer, 0);
      pthread_mutex_unlock(&stru_504CC8);
    }
    else if ( read(openResult, &buffer, 4u) < 0 )
    {
      strcpy(logBuffer, "Failed to read value!\n");
      v4 = -3;
      logMessage(0, logBuffer, 0);
      close(fileDescriptor);
      pthread_mutex_unlock(&stru_504CC8);
    }
    else
    {
      close(fileDescriptor);
      pthread_mutex_unlock(&stru_504CC8);
      *gpioValue = strtol((const char *)&buffer, 0, 10);
    }
  }
  return v4;
}
// 12198: using guessed type int __fastcall open64(_DWORD);

//----- (00040D90) --------------------------------------------------------
int monitor_gpio_changes()
{
  _DWORD *worker_struct; // r4
  void (__fastcall *process_gpio_event)(_DWORD *, int *, int); // r3
  int worker_data; // r6
  void (**gpio_event)(void); // r5
  int gpio_number; // r6
  unsigned __int8 current_gpio_value; // [sp+Fh] [bp-29h] BYREF
  int event_data[10]; // [sp+10h] [bp-28h] BYREF

  prctl(15, "gpio", 0);
  while ( dword_504CE0 )
  {
    if ( !pthread_mutex_lock(&stru_504CAC) )
    {
      worker_struct = create_worker_struct(dword_504CC4);
      if ( ((int (*)(void))*worker_struct)() )
      {
        while ( 1 )
        {
          worker_data = worker_struct[5];
          gpio_event = (void (**)(void))((int (*)(void))worker_struct[2])();
          gpio_number = ***(_DWORD ***)(worker_data + 16);
          current_gpio_value = 0;
          if ( readGPIOValue(gpio_number, &current_gpio_value) )
            break;
          if ( gpio_event[1] != (void (*)(void))current_gpio_value )
          {
            (*gpio_event)();
            process_gpio_event = (void (__fastcall *)(_DWORD *, int *, int))worker_struct[1];
            event_data[0] = (int)*gpio_event;
            event_data[1] = current_gpio_value;
            process_gpio_event(worker_struct, event_data, 8);
          }
          free(gpio_event);
          if ( !((int (__fastcall *)(_DWORD *))*worker_struct)(worker_struct) )
            goto LABEL_12;
        }
        free(gpio_event);
      }
LABEL_12:
      j_free(worker_struct);
      pthread_mutex_unlock(&stru_504CAC);
    }
    usleep(200000u);
  }
  return 0;
}
// 504CC4: using guessed type int dword_504CC4;
// 504CE0: using guessed type int dword_504CE0;

//----- (00040ED4) --------------------------------------------------------
int __fastcall set_gpio_value(int gpio_number, int set_high)
{
  int gpio_file_descriptor; // r0
  int file_descriptor; // r5
  char *value_to_write; // r1
  char gpio_path_buffer[64]; // [sp+0h] [bp-850h] BYREF
  char message_buffer[2064]; // [sp+40h] [bp-810h] BYREF

  if ( pthread_mutex_lock(&stru_504CC8) )
  {
    strcpy(message_buffer, "failed to api lock\n");
    logMessage(0, message_buffer, 0);
    return -1;
  }
  else
  {
    snprintf(gpio_path_buffer, 64u, "/sys/class/gpio/gpio%d/value", gpio_number);
    gpio_file_descriptor = open64(gpio_path_buffer);
    file_descriptor = gpio_file_descriptor;
    if ( gpio_file_descriptor < 0 )
    {
      strcpy(message_buffer, "Failed to open gpio value for writing!\n");
      logMessage(0, message_buffer, 0);
      pthread_mutex_unlock(&stru_504CC8);
      return -2;
    }
    else
    {
      value_to_write = "01";
      if ( set_high )
        value_to_write = "1";
      if ( write(gpio_file_descriptor, value_to_write, 1u) < 0 )
      {
        strcpy(message_buffer, "Failed to write value!\n");
        logMessage(0, message_buffer, 0);
        close(file_descriptor);
        pthread_mutex_unlock(&stru_504CC8);
        return -3;
      }
      else
      {
        close(file_descriptor);
        pthread_mutex_unlock(&stru_504CC8);
        return 0;
      }
    }
  }
}
// 12198: using guessed type int __fastcall open64(_DWORD);

//----- (0004101C) --------------------------------------------------------
unsigned int __fastcall increment_param_check_initialized(unsigned int param_value)
{
  char message_buffer[2056]; // [sp+0h] [bp-808h] BYREF

  if ( dword_504C90 )
  {
    if ( param_value > 1 )
    {
      strcpy(message_buffer, "bad param\n");
      logMessage(0, message_buffer, 0);
      return -3;
    }
    else
    {
      return param_value + 1;
    }
  }
  else
  {
    strcpy(message_buffer, "please init platform first!!\n");
    logMessage(dword_504C90, message_buffer, dword_504C90);
    return -2;
  }
}
// 504C90: using guessed type int dword_504C90;

//----- (000410BC) --------------------------------------------------------
int __fastcall check_and_log_error(int param_check_result)
{
  char error_message[2056]; // [sp-808h] [bp-808h] BYREF

  if ( param_check_result > 2 )
  {
    strcpy(error_message, "bad param\n");
    return logMessage(0, error_message, 0);
  }
  return param_check_result;
}

//----- (0004110C) --------------------------------------------------------
int __fastcall sub_4110C(int fan_type, unsigned int speed_setting_percent)
{
  int fan_index; // r4
  int pwm_value; // r5
  char log_message_buffer[2064]; // [sp+0h] [bp-810h] BYREF

  if ( fan_type > 2 )
  {
    strcpy(log_message_buffer, "bad param\n");
    logMessage(0, log_message_buffer, 0);
    return -3;
  }
  else
  {
    fan_index = fan_type - 1;
    if ( fan_type == 1 )
    {
      if ( speed_setting_percent >= 100 )
        speed_setting_percent = 100;
      pwm_value = (100 - speed_setting_percent) | (speed_setting_percent << 16);
      set_register_value(19, pwm_value);
      set_register_value(23, pwm_value);
      return fan_index;
    }
    else
    {
      snprintf(log_message_buffer, 2048u, "pwm type %d not supported\n", fan_type - 1);
      logMessage(0, log_message_buffer, 0);
      return 0;
    }
  }
}

//----- (000411D0) --------------------------------------------------------
int __fastcall sub_411D0(int command_id, int data_ptr)
{
  int response_code; // r4
  char error_msg[2064]; // [sp+0h] [bp-810h] BYREF

  if ( command_id > 2 )
  {
    response_code = -3;
    strcpy(error_msg, "bad param\n");
    logMessage(0, error_msg, 0);
  }
  else
  {
    response_code = command_id - 1;
    if ( command_id == 1 )
    {
      read_register_value(19, (_DWORD *)data_ptr);
      *(_DWORD *)data_ptr = *(unsigned __int16 *)(data_ptr + 2);
    }
    else
    {
      return -5;
    }
  }
  return response_code;
}

//----- (00041250) --------------------------------------------------------
int __fastcall get_send_address_info(
        int uart_index,
        _DWORD *address_length_ptr,
        int *tx_length_ptr,
        int *tx_delay_ptr,
        int *rx_delay_ptr)
{
  int tx_length; // r0
  int tx_delay; // r12
  int rx_delay; // r1
  int status_code; // r0
  char error_message[2056]; // [sp+8h] [bp-808h] BYREF

  switch ( uart_index )
  {
    case 0:
      tx_length = 64;
      *address_length_ptr = 24;
      tx_delay = 68;
      rx_delay = 69;
      goto LABEL_3;
    case 1:
      tx_length = 64;
      *address_length_ptr = 16;
      tx_delay = 70;
      rx_delay = 71;
      goto LABEL_3;
    case 2:
      tx_length = 64;
      *address_length_ptr = 8;
      tx_delay = 72;
      rx_delay = 73;
      goto LABEL_3;
    case 3:
      status_code = 0;
      *address_length_ptr = 0;
      *tx_length_ptr = 64;
      *tx_delay_ptr = 74;
      *rx_delay_ptr = 75;
      return status_code;
    case 4:
      tx_length = 65;
      *address_length_ptr = 24;
      tx_delay = 76;
      rx_delay = 77;
      goto LABEL_3;
    case 5:
      tx_length = 65;
      *address_length_ptr = 16;
      tx_delay = 78;
      rx_delay = 79;
      goto LABEL_3;
    case 6:
      tx_length = 65;
      *address_length_ptr = 8;
      tx_delay = 80;
      rx_delay = 81;
      goto LABEL_3;
    case 7:
      status_code = 0;
      *address_length_ptr = 0;
      *tx_length_ptr = 65;
      *tx_delay_ptr = 82;
      *rx_delay_ptr = 83;
      return status_code;
    case 8:
      tx_length = 66;
      *address_length_ptr = 24;
      tx_delay = 84;
      rx_delay = 85;
      goto LABEL_3;
    case 9:
      tx_length = 66;
      *address_length_ptr = 16;
      tx_delay = 86;
      rx_delay = 87;
      goto LABEL_3;
    case 10:
      tx_length = 66;
      *address_length_ptr = 8;
      tx_delay = 115;
      rx_delay = 116;
      goto LABEL_3;
    case 11:
      status_code = 0;
      *address_length_ptr = 0;
      *tx_length_ptr = 66;
      *tx_delay_ptr = 117;
      *rx_delay_ptr = 118;
      return status_code;
    case 12:
      tx_length = 67;
      *address_length_ptr = 24;
      tx_delay = 119;
      rx_delay = 120;
      goto LABEL_3;
    case 13:
      tx_length = 67;
      *address_length_ptr = 16;
      tx_delay = 121;
      rx_delay = 122;
LABEL_3:
      *tx_length_ptr = tx_length;
      status_code = 0;
      *tx_delay_ptr = tx_delay;
      *rx_delay_ptr = rx_delay;
      break;
    default:
      snprintf(error_message, 2048u, "%s: The uart %d is not supported!!!\n", "get_send_address_info", uart_index);
      logMessage(0, error_message, 0);
      status_code = -1;
      break;
  }
  return status_code;
}
// 41264: control flows out of bounds to 41268

//----- (00041474) --------------------------------------------------------
unsigned int __fastcall get_uart_buffer_status(int uart_index)
{
  unsigned int buffer_status; // r0
  unsigned int register_value; // [sp+Ch] [bp-80Ch] BYREF
  char log_message_buffer[2056]; // [sp+10h] [bp-808h] BYREF

  register_value = 0;
  switch ( uart_index )
  {
    case 0:
      read_register_value(88, &register_value);
      buffer_status = HIWORD(register_value) & 0x3FF;
      break;
    case 1:
      read_register_value(88, &register_value);
      buffer_status = register_value & 0x3FF;
      break;
    case 2:
      read_register_value(89, &register_value);
      buffer_status = HIWORD(register_value) & 0x3FF;
      break;
    case 3:
      read_register_value(89, &register_value);
      buffer_status = register_value & 0x3FF;
      break;
    case 4:
      read_register_value(90, &register_value);
      buffer_status = HIWORD(register_value) & 0x3FF;
      break;
    case 5:
      read_register_value(90, &register_value);
      buffer_status = register_value & 0x3FF;
      break;
    case 6:
      read_register_value(91, &register_value);
      buffer_status = HIWORD(register_value) & 0x3FF;
      break;
    case 7:
      read_register_value(91, &register_value);
      buffer_status = register_value & 0x3FF;
      break;
    case 8:
      read_register_value(92, &register_value);
      buffer_status = HIWORD(register_value) & 0x3FF;
      break;
    case 9:
      read_register_value(92, &register_value);
      buffer_status = register_value & 0x3FF;
      break;
    case 10:
      read_register_value(93, &register_value);
      buffer_status = HIWORD(register_value) & 0x3FF;
      break;
    case 11:
      read_register_value(93, &register_value);
      buffer_status = register_value & 0x3FF;
      break;
    case 12:
      read_register_value(94, &register_value);
      buffer_status = HIWORD(register_value) & 0x3FF;
      break;
    case 13:
      read_register_value(94, &register_value);
      buffer_status = register_value & 0x3FF;
      break;
    default:
      snprintf(
        log_message_buffer,
        2048u,
        "%s: The uart%d is not supported!!!\n",
        "check_how_many_uart_data_in_fpga",
        uart_index);
      logMessage(0, log_message_buffer, 0);
      buffer_status = 0;
      break;
  }
  return buffer_status;
}
// 41490: control flows out of bounds to 41494

//----- (0004165C) --------------------------------------------------------
int __fastcall clearUartTxFifo(int chainIndex)
{
  pthread_mutex_t *chain_mutex; // r7
  int send_fifo_space; // r4
  unsigned int send_fifo; // r3
  int uart_status_reg; // [sp+Ch] [bp-82Ch] BYREF
  int tx_control_reg; // [sp+10h] [bp-828h] BYREF
  int tx_fifo_reg; // [sp+14h] [bp-824h] BYREF
  unsigned int tx_fifo_space_mask; // [sp+18h] [bp-820h] BYREF
  int tx_fifo_bitpos; // [sp+1Ch] [bp-81Ch] BYREF
  char logBuffer[2072]; // [sp+20h] [bp-818h] BYREF

  chain_mutex = (pthread_mutex_t *)((char *)&unk_504CE8 + 24 * chainIndex);
  uart_status_reg = 0;
  tx_control_reg = 0;
  tx_fifo_reg = 0;
  tx_fifo_space_mask = 0;
  tx_fifo_bitpos = 0;
  pthread_mutex_lock(chain_mutex);
  if ( get_send_address_info(chainIndex, &tx_fifo_bitpos, &uart_status_reg, &tx_control_reg, &tx_fifo_reg) )
  {
    snprintf(logBuffer, 2048u, "get_send_address_info error, chain_id = %d\n", chainIndex);
  }
  else
  {
    send_fifo_space = 21;
    do
    {
      read_register_value(uart_status_reg, &tx_fifo_space_mask);
      send_fifo = (unsigned __int8)(tx_fifo_space_mask >> tx_fifo_bitpos);
      tx_fifo_space_mask = send_fifo;
      if ( send_fifo == 255 )
        return pthread_mutex_unlock(chain_mutex);
      printf("%s: waiting fpga uart%d clear send fifo space ...\n", "clear_uart_tx_fifo", chainIndex);
      set_register_value(tx_control_reg, tx_fifo_space_mask | 0x80000000);
      usleep(3000u);
      --send_fifo_space;
    }
    while ( send_fifo_space );
    snprintf(
      logBuffer,
      2048u,
      "%s: uart%d always dose not has enough send fifo space, break\n",
      "clear_uart_tx_fifo",
      chainIndex);
  }
  logMessage(0, logBuffer, 0);
  return pthread_mutex_unlock(chain_mutex);
}

//----- (00041794) --------------------------------------------------------
unsigned int __fastcall read_register_data(int chain_id, int output_buffer, unsigned int data_length)
{
  unsigned int actual_read_length; // r5
  int command_register; // r6
  int set_data_register; // r0
  unsigned int remaining_full_blocks; // r9
  int output_offset; // r4
  unsigned int data_block; // r3
  unsigned int remaining_partial_block; // r4
  int final_offset; // r3
  unsigned int high_word; // r1
  unsigned int third_byte; // r2
  unsigned int second_byte; // r2
  unsigned int read_data; // [sp+Ch] [bp-824h] BYREF
  char error_message[2080]; // [sp+10h] [bp-820h] BYREF

  read_data = 0;
  switch ( chain_id )
  {
    case 0:
      command_register = 96;
      set_data_register = 95;
      goto LABEL_5;
    case 1:
      command_register = 98;
      set_data_register = 97;
      goto LABEL_5;
    case 2:
      command_register = 100;
      set_data_register = 99;
      goto LABEL_5;
    case 3:
      command_register = 102;
      set_data_register = 101;
      goto LABEL_5;
    case 4:
      command_register = 104;
      set_data_register = 103;
      goto LABEL_5;
    case 5:
      command_register = 106;
      set_data_register = 105;
      goto LABEL_5;
    case 6:
      command_register = 108;
      set_data_register = 107;
      goto LABEL_5;
    case 7:
      command_register = 110;
      set_data_register = 109;
      goto LABEL_5;
    case 8:
      command_register = 112;
      set_data_register = 111;
      goto LABEL_5;
    case 9:
      command_register = 114;
      set_data_register = 113;
      goto LABEL_5;
    case 10:
      command_register = 124;
      set_data_register = 123;
      goto LABEL_5;
    case 11:
      command_register = 126;
      set_data_register = 125;
      goto LABEL_5;
    case 12:
      command_register = 128;
      set_data_register = 127;
      goto LABEL_5;
    case 13:
      command_register = 130;
      set_data_register = 129;
LABEL_5:
      set_register_value(set_data_register, data_length & 0x3FF | 0x80000000);
      remaining_full_blocks = data_length >> 2;
      if ( data_length >> 2 )
      {
        output_offset = output_buffer;
        do
        {
          output_offset += 4;
          read_register_value(command_register, &read_data);
          data_block = read_data;
          *(_BYTE *)(output_offset - 1) = read_data;
          *(_BYTE *)(output_offset - 4) = HIBYTE(data_block);
          *(_BYTE *)(output_offset - 3) = BYTE2(data_block);
          *(_BYTE *)(output_offset - 2) = BYTE1(data_block);
        }
        while ( output_buffer + 4 * remaining_full_blocks != output_offset );
      }
      remaining_partial_block = data_length & 3;
      actual_read_length = data_length & 0xFFFFFFFC;
      if ( remaining_partial_block )
      {
        read_register_value(command_register, &read_data);
        final_offset = output_buffer + 4 * remaining_full_blocks;
        if ( remaining_partial_block == 2 )
        {
          actual_read_length += 2;
          second_byte = HIWORD(read_data);
          *(_BYTE *)(output_buffer + 4 * remaining_full_blocks) = HIBYTE(read_data);
          *(_BYTE *)(final_offset + 1) = second_byte;
        }
        else if ( remaining_partial_block == 3 )
        {
          actual_read_length += 3;
          high_word = HIWORD(read_data);
          third_byte = read_data >> 8;
          *(_BYTE *)(output_buffer + 4 * remaining_full_blocks) = HIBYTE(read_data);
          *(_BYTE *)(final_offset + 1) = high_word;
          *(_BYTE *)(final_offset + 2) = third_byte;
        }
        else
        {
          ++actual_read_length;
          *(_BYTE *)(output_buffer + 4 * remaining_full_blocks) = HIBYTE(read_data);
        }
      }
      break;
    default:
      actual_read_length = 0;
      snprintf(error_message, 2048u, "%s: The uart%d is not supported!!!\n", "get_read_address_info", chain_id);
      logMessage(0, error_message, 0);
      snprintf(error_message, 2048u, "get_read_address_info error, chain_id = %d\n", chain_id);
      logMessage(0, error_message, 0);
      break;
  }
  return actual_read_length;
}
// 417B8: control flows out of bounds to 417BC

//----- (000419D8) --------------------------------------------------------
int check_platform_initialization()
{
  char error_message[2056]; // [sp-808h] [bp-808h] BYREF

  if ( dword_504C90 )
    return 0;
  strcpy(error_message, "please init platform first!!\n");
  logMessage(dword_504C90, error_message, dword_504C90);
  return -1;
}
// 504C90: using guessed type int dword_504C90;

//----- (00041C88) --------------------------------------------------------
unsigned int __fastcall fetch_min_chips_count(int chip_index, int option_flag, unsigned int max_chips_requested)
{
  pthread_mutex_t *chip_mutex; // r5
  unsigned int available_chips; // r0
  unsigned int chips_fetched; // r4

  chip_mutex = (pthread_mutex_t *)((char *)&unk_504E68 + 24 * chip_index);
  pthread_mutex_lock(chip_mutex);
  available_chips = get_uart_buffer_status((unsigned __int8)chip_index);
  if ( available_chips < max_chips_requested )
    max_chips_requested = available_chips;
  if ( max_chips_requested )
  {
    chips_fetched = read_register_data(chip_index, option_flag, max_chips_requested);
    pthread_mutex_unlock(chip_mutex);
    return chips_fetched;
  }
  else
  {
    pthread_mutex_unlock(chip_mutex);
    return 0;
  }
}

//----- (00041CFC) --------------------------------------------------------
int __fastcall set_miner_config(int miner_id, int config_type, int *config_value_ptr)
{
  pthread_mutex_t *config_mutex; // r4
  char log_message_buffer[2064]; // [sp+0h] [bp-810h] BYREF

  if ( !config_value_ptr )
    return -3;
  config_mutex = (pthread_mutex_t *)((char *)&unk_504CE8 + 24 * miner_id);
  pthread_mutex_lock(config_mutex);
  if ( config_type )
  {
    snprintf(log_message_buffer, 2048u, "unknown set config type = %d\n", config_type);
    logMessage(1, log_message_buffer, 0);
  }
  else
  {
    set_register_value(15, *config_value_ptr);
  }
  pthread_mutex_unlock(config_mutex);
  return -5;
}

//----- (00041D80) --------------------------------------------------------
int __fastcall sub_41D80(int a1, int a2, _DWORD *a3, int a4)
{
  _BOOL4 v4; // r3
  int v5; // r6
  pthread_mutex_t *v6; // r4
  int v10[512]; // [sp+0h] [bp-818h] BYREF

  v4 = a4 != 0;
  if ( a3 )
    v5 = v4;
  else
    v5 = 1;
  if ( v5 )
    return -3;
  v6 = (pthread_mutex_t *)((char *)&unk_504CE8 + 24 * a1);
  pthread_mutex_lock(v6);
  if ( !a2 )
  {
    v10[0] = 0;
    read_register_value(15, v10);
    *a3 = v10[0];
    MEMORY[0] = 0;
    __und(0);
  }
  snprintf((char *)v10, 2048u, "unknown set config type = %d\n", a2);
  logMessage(1, (const char *)v10, 0);
  pthread_mutex_unlock(v6);
  return -5;
}

//----- (00041E38) --------------------------------------------------------
int __fastcall configure_miner(int miner_index, int config_type, _DWORD *config_value_ptr)
{
  pthread_mutex_t *mutex_ptr; // r4
  char log_buffer[2064]; // [sp+0h] [bp-810h] BYREF

  if ( !config_value_ptr )
    return -3;
  mutex_ptr = (pthread_mutex_t *)((char *)&unk_504CE8 + 24 * miner_index);
  pthread_mutex_lock(mutex_ptr);
  if ( config_type )
  {
    snprintf(log_buffer, 2048u, "unknown set config type = %d\n", config_type);
    logMessage(1, log_buffer, 0);
  }
  else
  {
    set_register_value(15, *config_value_ptr << 16);
  }
  pthread_mutex_unlock(mutex_ptr);
  return -5;
}

//----- (00041EC0) --------------------------------------------------------
int __fastcall set_config(int config_type, int config_sub_type, unsigned int *config_value_out, int check_sub_type)
{
  _BOOL4 sub_type_present; // r3
  int valid_args; // r6
  pthread_mutex_t *config_mutex; // r4
  int local_buffer[512]; // [sp+0h] [bp-818h] BYREF

  sub_type_present = check_sub_type != 0;
  if ( config_value_out )
    valid_args = sub_type_present;
  else
    valid_args = 1;
  if ( valid_args )
    return -3;
  config_mutex = (pthread_mutex_t *)((char *)&unk_504CE8 + 24 * config_type);
  pthread_mutex_lock(config_mutex);
  if ( !config_sub_type )
  {
    local_buffer[0] = 0;
    read_register_value(15, local_buffer);
    *config_value_out = HIWORD(local_buffer[0]) & 0x3F;
    MEMORY[0] = 0;
    __und(0);
  }
  snprintf((char *)local_buffer, 2048u, "unknown set config type = %d\n", config_sub_type);
  logMessage(1, (const char *)local_buffer, 0);
  pthread_mutex_unlock(config_mutex);
  return -5;
}

//----- (00041F7C) --------------------------------------------------------
int __fastcall clear_uart_rx_fifo(int uart_channel)
{
  pthread_mutex_t *uart_mutex; // r4
  unsigned int buffer_status; // r0
  unsigned int buffer_length; // r6
  void *buffer_ptr; // r0
  void *buffer; // r7
  unsigned int read_bytes; // r0
  char log_msg[2072]; // [sp+10h] [bp-818h] BYREF

  uart_mutex = (pthread_mutex_t *)((char *)&unk_504E68 + 24 * uart_channel);
  pthread_mutex_lock(uart_mutex);
  buffer_status = get_uart_buffer_status((unsigned __int8)uart_channel);
  buffer_length = buffer_status;
  if ( !buffer_status )
    return pthread_mutex_unlock(uart_mutex);
  buffer_ptr = malloc(buffer_status);
  buffer = buffer_ptr;
  if ( buffer_ptr )
  {
    read_bytes = read_register_data(uart_channel, (int)buffer_ptr, buffer_length);
    if ( buffer_length != read_bytes )
    {
      snprintf(
        log_msg,
        2048u,
        "%s: uart%d clear rx fifo error. nbytes = %d, len = %d\n",
        "clear_uart_rx_fifo",
        uart_channel,
        buffer_length,
        read_bytes);
      logMessage(0, log_msg, 0);
    }
    free(buffer);
    usleep(10000u);
    return pthread_mutex_unlock(uart_mutex);
  }
  snprintf(log_msg, 2048u, "%s: uart%d malloc buffer error\n", "clear_uart_rx_fifo", uart_channel);
  logMessage(0, log_msg, 0);
  usleep(500000u);
  return pthread_mutex_unlock(uart_mutex);
}

//----- (00042080) --------------------------------------------------------
int __fastcall initialize_uart_communication(int uart_descriptor)
{
  clear_uart_rx_fifo(uart_descriptor);
  usleep(10000u);
  clearUartTxFifo(uart_descriptor);
  return 0;
}

//----- (000420A4) --------------------------------------------------------
int __fastcall clear_uart_tx_fifo_wrapper(int uart_base_address)
{
  clearUartTxFifo(uart_base_address);
  return 0;
}

//----- (000420B4) --------------------------------------------------------
int __fastcall clear_miner_uart_rx_fifo(int miner_id)
{
  clear_uart_rx_fifo(miner_id);
  return 0;
}

//----- (000420C4) --------------------------------------------------------
unsigned int __fastcall hashrate_monitor(int miner_index)
{
  unsigned __int8 miner_id; // r5
  pthread_mutex_t *hashrate_mutex; // r4
  unsigned int hashrate; // r5

  miner_id = miner_index;
  hashrate_mutex = (pthread_mutex_t *)((char *)&unk_504E68 + 24 * miner_index);
  pthread_mutex_lock(hashrate_mutex);
  hashrate = get_uart_buffer_status(miner_id);
  pthread_mutex_unlock(hashrate_mutex);
  return hashrate;
}

//----- (00042100) --------------------------------------------------------
int check_and_reset_asic_state()
{
  if ( !check_gpio_access(907) )
  {
    export_gpio(907);
    set_gpio_direction(907, 1);
  }
  return set_gpio_value(907, 0);
}

//----- (00042138) --------------------------------------------------------
int initialize_miner_setting()
{
  if ( !check_gpio_access(907) )
  {
    export_gpio(907);
    set_gpio_direction(907, 1);
  }
  return set_gpio_value(907, 1);
}

//----- (00042170) --------------------------------------------------------
int __fastcall subtract_integers(_DWORD *first_integer, _DWORD *second_integer)
{
  return *first_integer - *second_integer;
}

//----- (00042180) --------------------------------------------------------
int *__fastcall process_command_result(int *command_result, int *command_args)
{
  int response_buffer[3]; // [sp+4h] [bp-Ch] BYREF

  response_buffer[0] = (int)command_result;
  if ( command_args )
  {
    command_result = check_and_update_status(command_args, (int)response_buffer);
    if ( command_result == (int *)1 )
      return (int *)handle_network_packet(command_args, (int)response_buffer);
  }
  return command_result;
}

//----- (000421C4) --------------------------------------------------------
int mine_worker_main_loop()
{
  _DWORD *worker_struct; // r5
  int job_id; // r2
  int job_state; // r0
  int calculated_difficulty; // r3
  int *job_buffer; // r0
  int job_difficulty; // r3
  int *job_data; // r4
  int job_results[9]; // [sp+Ch] [bp-24h] BYREF

  prctl(15, "ui", 0);
  while ( dword_504FE8[0] )
  {
    if ( !pthread_mutex_lock(&stru_504FEC) )
    {
      worker_struct = create_worker_struct(dword_505004);
      if ( ((int (*)(void))*worker_struct)() )
      {
        do
        {
          job_buffer = (int *)((int (*)(void))worker_struct[2])();
          job_difficulty = job_buffer[1];
          job_data = job_buffer;
          if ( job_difficulty )
          {
            job_id = *job_buffer;
            job_state = job_buffer[2];
          }
          else
          {
            set_gpio_value(***(_DWORD ***)(worker_struct[5] + 16), *((unsigned __int8 *)job_buffer + 8));
            job_difficulty = *job_data;
            job_state = job_data[2] != 1;
            job_id = *job_data;
            job_data[2] = job_state;
          }
          calculated_difficulty = job_difficulty - 200;
          job_results[0] = job_id;
          job_data[1] = calculated_difficulty;
          job_results[1] = calculated_difficulty;
          job_results[2] = job_state;
          ((void (__fastcall *)(_DWORD *, int *))worker_struct[1])(worker_struct, job_results);
          free(job_data);
        }
        while ( ((int (__fastcall *)(_DWORD *))*worker_struct)(worker_struct) );
      }
      j_free(worker_struct);
      pthread_mutex_unlock(&stru_504FEC);
    }
    usleep((__useconds_t)&loc_30D40);
  }
  return 0;
}
// 504FE8: using guessed type int dword_504FE8[];
// 505004: using guessed type int dword_505004;

//----- (00042308) --------------------------------------------------------
int __fastcall check_port_mapping(int port_number)
{
  char log_buffer[2056]; // [sp+0h] [bp-808h] BYREF

  if ( get_static_value() == port_number )
    return 256;
  if ( sub_4301C() == port_number )
    return 257;
  snprintf(log_buffer, 2048u, "unmaped port = %d\n", port_number);
  logMessage(0, log_buffer, 0);
  return 258;
}

//----- (00042368) --------------------------------------------------------
int check_hardware_status()
{
  if ( get_fixed_value_941() >= 0 )
    return get_fixed_value_941();
  else
    return 0;
}

//----- (00042388) --------------------------------------------------------
int __fastcall query_mining_status(unsigned int status_code)
{
  if ( status_code == 2 )
  {
    if ( get_fixed_number() < 0 )
      return 0;
    return get_fixed_number();
  }
  else if ( status_code <= 2 )
  {
    if ( status_code != 1 )
      return 0;
    return check_hardware_status();
  }
  else
  {
    if ( status_code != 256 )
    {
      if ( status_code == 257 && sub_4301C() >= 0 )
        return sub_4301C();
      return 0;
    }
    if ( get_static_value() < 0 )
      return 0;
    return get_static_value();
  }
}

//----- (00042400) --------------------------------------------------------
int initialize_miner_threading()
{
  int init_result; // r0
  pthread_attr_t thread_attributes; // [sp+4h] [bp-34h] BYREF

  pthread_mutex_init(&stru_504FEC, 0);
  dword_505008 = 0;
  dword_50500C = 0;
  dword_505010 = 0;
  dword_505014 = 0;
  dword_505018 = 0;
  dword_505004 = (int)allocate_and_init_struct((int)subtract_integers, 0, 0);
  pthread_attr_init(&thread_attributes);
  pthread_attr_setstacksize(&thread_attributes, 2097152u);
  init_result = pthread_create(
                  (pthread_t *)algn_50501C,
                  &thread_attributes,
                  (void *(*)(void *))mine_worker_main_loop,
                  0);
  dword_504FE8[0] = 1;
  return init_result;
}
// 504FE8: using guessed type int dword_504FE8[];
// 505004: using guessed type int dword_505004;
// 505008: using guessed type int dword_505008;
// 50500C: using guessed type int dword_50500C;
// 505010: using guessed type int dword_505010;
// 505014: using guessed type int dword_505014;
// 505018: using guessed type int dword_505018;

//----- (00042488) --------------------------------------------------------
int __fastcall reportUnsupportedGpioPort(int gpioPort)
{
  char logBuffer[2056]; // [sp+0h] [bp-808h] BYREF

  snprintf(logBuffer, 2048u, "gpio port %d is not a supported key\n", gpioPort);
  return logMessage(1, logBuffer, 0);
}

//----- (000424C8) --------------------------------------------------------
int __fastcall set_gpio_port_value(int gpio_port, int value)
{
  int gpio_port_status; // r0
  char *gpio_handler_ptr; // r4
  int effective_gpio_port; // r5
  int (__fastcall *gpio_handler_func)(int, int); // r3
  int (__fastcall *current_handler_func)(int, int); // t1
  int operation_result; // r0
  int normalized_value; // r1

  gpio_port_status = check_port_mapping(gpio_port);
  if ( gpio_port_status == 258 )
    return reportUnsupportedGpioPort(gpio_port);
  gpio_handler_ptr = (char *)&dword_505008;
  effective_gpio_port = gpio_port_status;
  do
  {
    current_handler_func = *(int (__fastcall **)(int, int))gpio_handler_ptr;
    gpio_handler_ptr += 4;
    gpio_handler_func = current_handler_func;
    operation_result = effective_gpio_port;
    if ( current_handler_func )
    {
      normalized_value = value;
      if ( value )
        normalized_value = 1;
      operation_result = gpio_handler_func(effective_gpio_port, normalized_value);
    }
  }
  while ( gpio_handler_ptr != algn_50501C );
  return operation_result;
}
// 505008: using guessed type int dword_505008;

//----- (00042528) --------------------------------------------------------
int __fastcall configureGPIOControl(unsigned int gpioPort, int operationType)
{
  int *gpioConfigPtr; // r6
  int *globalConfig; // r4
  int operationStatus; // r5
  int *configBufferPtr; // [sp+Ch] [bp-81Ch] BYREF
  _DWORD logBuffer[518]; // [sp+10h] [bp-818h] BYREF

  gpioConfigPtr = (int *)query_mining_status(gpioPort);
  if ( gpioConfigPtr )
  {
    if ( pthread_mutex_lock(&stru_504FEC) )
    {
      operationStatus = -1;
      strcpy((char *)logBuffer, "failed to api lock\n");
      logMessage(0, (const char *)logBuffer, 0);
    }
    else
    {
      globalConfig = (int *)dword_505004;
      if ( operationType == 1 )
      {
        process_command_result(gpioConfigPtr, (int *)dword_505004);
        operationStatus = set_gpio_value((int)gpioConfigPtr, 0);
      }
      else if ( operationType == 2 )
      {
        configBufferPtr = gpioConfigPtr;
        if ( dword_505004 && !check_and_update_status((int *)dword_505004, (int)&configBufferPtr) )
        {
          logBuffer[1] = 0;
          operationStatus = -1;
          logBuffer[0] = 200;
          logBuffer[2] = 1;
          process_miner_data(globalConfig, &configBufferPtr, 4u, logBuffer, 12u);
        }
        else
        {
          operationStatus = -1;
        }
      }
      else
      {
        process_command_result(gpioConfigPtr, (int *)dword_505004);
        operationStatus = set_gpio_value((int)gpioConfigPtr, 1);
      }
      pthread_mutex_unlock(&stru_504FEC);
    }
  }
  else
  {
    operationStatus = -1;
    strcpy((char *)logBuffer, "unsuported gpio port\n");
    logMessage(0, (const char *)logBuffer, 0);
  }
  return operationStatus;
}
// 505004: using guessed type int dword_505004;

//----- (00042694) --------------------------------------------------------
int initialize_led_status()
{
  int is_initialized; // r5
  int green_led_gpio; // r0
  int red_led_gpio; // r0
  int network_led_gpio; // r0
  int network_led_direction; // r0
  int hardware_led_gpio; // r0
  int hardware_led_direction; // r0
  int fault_led_gpio; // r0
  int fault_led_direction; // r0

  is_initialized = dword_505020;
  if ( !dword_505020 )
  {
    green_led_gpio = check_hardware_status();
    export_gpio(green_led_gpio);
    red_led_gpio = check_hardware_status();
    set_gpio_direction(red_led_gpio, 1);
    network_led_gpio = query_mining_status(2u);
    export_gpio(network_led_gpio);
    network_led_direction = query_mining_status(2u);
    set_gpio_direction(network_led_direction, 1);
    hardware_led_gpio = query_mining_status(256u);
    export_gpio(hardware_led_gpio);
    hardware_led_direction = query_mining_status(256u);
    set_gpio_direction(hardware_led_direction, is_initialized);
    fault_led_gpio = query_mining_status(257u);
    export_gpio(fault_led_gpio);
    fault_led_direction = query_mining_status(257u);
    set_gpio_direction(fault_led_direction, is_initialized);
    dword_505020 = 1;
  }
  return 0;
}
// 505020: using guessed type int dword_505020;

//----- (00042728) --------------------------------------------------------
int enable_gpio_control()
{
  return configureGPIOControl(1u, 0);
}

//----- (00042734) --------------------------------------------------------
int configure_hashboard_reset_gpio()
{
  return configureGPIOControl(1u, 1);
}

//----- (00042740) --------------------------------------------------------
int configure_gpio_and_initialize_threading()
{
  if ( !dword_504FE8[0] )
    initialize_miner_threading();
  return configureGPIOControl(1u, 2);
}
// 504FE8: using guessed type int dword_504FE8[];

//----- (00042778) --------------------------------------------------------
int configure_fan_control_gpio()
{
  return configureGPIOControl(2u, 0);
}

//----- (00042784) --------------------------------------------------------
int configure_gpio_control_for_miner()
{
  return configureGPIOControl(2u, 1);
}

//----- (00042790) --------------------------------------------------------
int initialize_and_configure_gpio()
{
  if ( !dword_504FE8[0] )
    initialize_miner_threading();
  return configureGPIOControl(2u, 2);
}
// 504FE8: using guessed type int dword_504FE8[];

//----- (000427C8) --------------------------------------------------------
int configure_temperature_sensor_gpio()
{
  return configureGPIOControl(16u, 0);
}

//----- (000427D4) --------------------------------------------------------
int configure_chip_reset_gpio()
{
  return configureGPIOControl(16u, 1);
}

//----- (000427E0) --------------------------------------------------------
int initialize_miner_hardware()
{
  if ( !dword_504FE8[0] )
    initialize_miner_threading();
  return configureGPIOControl(16u, 2);
}
// 504FE8: using guessed type int dword_504FE8[];

//----- (00042818) --------------------------------------------------------
int __fastcall initialize_miner_listener(int listener_socket)
{
  int lock_result; // r5
  int *current_listener_ptr; // r2
  int listener_count; // r3
  int mining_status; // r0
  int status_query_b; // r0
  char error_message[2064]; // [sp+0h] [bp-810h] BYREF

  lock_result = pthread_mutex_lock(&stru_504FEC);
  if ( lock_result )
  {
    lock_result = -1;
    strcpy(error_message, "failed to api lock\n");
    logMessage(0, error_message, 0);
  }
  else
  {
    if ( !dword_505024 )
    {
      mining_status = query_mining_status(256u);
      control_gpio(mining_status, (unsigned int)set_gpio_port_value);
      status_query_b = query_mining_status(257u);
      control_gpio(status_query_b, (unsigned int)set_gpio_port_value);
      dword_505024 = 1;
    }
    current_listener_ptr = &dword_505008;
    listener_count = 0;
    while ( *current_listener_ptr++ )
    {
      if ( ++listener_count == 5 )
      {
        lock_result = -2;
        strcpy(error_message, "no more listener available\n");
        logMessage(0, error_message, 0);
        goto LABEL_8;
      }
    }
    dword_504FE8[listener_count + 8] = listener_socket;
LABEL_8:
    pthread_mutex_unlock(&stru_504FEC);
  }
  return lock_result;
}
// 504FE8: using guessed type int dword_504FE8[];
// 505008: using guessed type int dword_505008;
// 505024: using guessed type int dword_505024;

//----- (00042928) --------------------------------------------------------
int __fastcall sub_42928(int a1)
{
  int v2; // r0
  int *v3; // r3
  int v4; // t1
  char v6[2064]; // [sp+0h] [bp-810h] BYREF

  v2 = pthread_mutex_lock(&stru_504FEC);
  if ( v2 )
  {
    strcpy(v6, "failed to api lock\n");
    logMessage(0, v6, 0);
    return -1;
  }
  else
  {
    v3 = &dword_505008;
    while ( 1 )
    {
      v4 = *v3++;
      if ( v4 == a1 )
        break;
      if ( ++v2 == 5 )
      {
        strcpy(v6, "listener not registered before\n");
        logMessage(1, v6, 0);
        goto LABEL_7;
      }
    }
    dword_504FE8[v2 + 8] = 0;
LABEL_7:
    pthread_mutex_unlock(&stru_504FEC);
    return 0;
  }
}
// 504FE8: using guessed type int dword_504FE8[];
// 505008: using guessed type int dword_505008;

//----- (00042BE0) --------------------------------------------------------
int acquire_api_lock_and_process()
{
  char buffer[2056]; // [sp+0h] [bp-808h] BYREF

  if ( pthread_mutex_lock(&stru_504FEC) )
  {
    strcpy(buffer, "failed to api lock\n");
    return logMessage(0, buffer, 0);
  }
  else
  {
    if ( dword_7F418 > 0 )
      clear_lcd_display(dword_7F418);
    return pthread_mutex_unlock(&stru_504FEC);
  }
}
// 7F418: using guessed type int dword_7F418;

//----- (00042C68) --------------------------------------------------------
int __fastcall initialize_lcd(int lcd_device_path)
{
  int unused_variable; // r5
  int file_descriptor; // r0
  char log_buffer[2064]; // [sp+0h] [bp-810h] BYREF

  unused_variable = dword_505028;
  if ( dword_505028 )
    return 0;
  if ( lcd_device_path )
  {
    file_descriptor = open64(lcd_device_path);
    dword_50502C = file_descriptor;
    if ( file_descriptor < 0 )
    {
      strcpy(log_buffer, "open lcd failed!!!\n");
      logMessage(unused_variable, log_buffer, unused_variable);
      return -1;
    }
    else
    {
      dword_505028 = 1;
    }
  }
  else
  {
    strcpy(log_buffer, "bad param\n");
    logMessage(0, log_buffer, 0);
    return -3;
  }
  return file_descriptor;
}
// 12198: using guessed type int __fastcall open64(_DWORD);
// 505028: using guessed type int dword_505028;
// 50502C: using guessed type int dword_50502C;

//----- (00042D2C) --------------------------------------------------------
int __fastcall update_lcd_buffer(int lcd_file_descriptor, int block_number, int data_source, unsigned int data_length)
{
  int current_block; // r7
  unsigned int remaining_data_size; // r4
  bool is_invalid_data; // cc
  int is_invalid_param; // r5
  int lock_result_or_copy_size; // r11
  unsigned __int8 next_block; // r5
  size_t copy_size; // r6
  const void *current_data_ptr; // r1
  char error_message[2088]; // [sp+0h] [bp-828h] BYREF

  current_block = block_number;
  if ( !dword_505028 )
    return -2;
  remaining_data_size = data_length;
  if ( dword_50502C != lcd_file_descriptor )
    goto LABEL_18;
  is_invalid_data = data_length > 64;
  if ( data_length <= 64 )
    is_invalid_data = (unsigned __int8)block_number > 3u;
  is_invalid_param = is_invalid_data;
  if ( is_invalid_data )
  {
LABEL_18:
    strcpy(error_message, "bad param\n");
    logMessage(1, error_message, 0);
    return -3;
  }
  else
  {
    lock_result_or_copy_size = pthread_mutex_lock(&stru_505030);
    if ( lock_result_or_copy_size )
    {
      strcpy(error_message, "failed to lcd lock\n");
      logMessage(is_invalid_param, error_message, is_invalid_param);
      return -4;
    }
    else
    {
      do
      {
        next_block = current_block + 1;
        if ( remaining_data_size >= 16 )
          copy_size = 16;
        else
          copy_size = remaining_data_size;
        current_data_ptr = (const void *)(data_source + lock_result_or_copy_size);
        lock_result_or_copy_size += copy_size;
        memcpy((char *)&unk_505048 + 16 * current_block, current_data_ptr, copy_size);
        remaining_data_size -= copy_size;
        current_block = (char)next_block;
      }
      while ( next_block <= 3u && remaining_data_size != 0 );
      write(dword_50502C, &unk_505048, 64u);
      pthread_mutex_unlock(&stru_505030);
      return 0;
    }
  }
}
// 505028: using guessed type int dword_505028;
// 50502C: using guessed type int dword_50502C;

//----- (00042E80) --------------------------------------------------------
int always_return_zero()
{
  return 0;
}

//----- (00042E88) --------------------------------------------------------
int __fastcall clear_lcd_display(int lcd_device_fd)
{
  int lcd_fd; // r6
  int lcd_start_pos; // r1
  char error_message[2064]; // [sp+8h] [bp-810h] BYREF

  if ( !dword_505028 )
    return -2;
  if ( dword_50502C == lcd_device_fd )
  {
    if ( pthread_mutex_lock(&stru_505030) )
    {
      strcpy(error_message, "failed to lcd lock\n");
      logMessage(0, error_message, 0);
      return -4;
    }
    else
    {
      memset(&unk_505048, 32, 64u);
      lcd_fd = dword_50502C;
      lseek64(dword_50502C, lcd_start_pos, 0, 0, 0);
      write(lcd_fd, &unk_505048, 64u);
      pthread_mutex_unlock(&stru_505030);
      return 0;
    }
  }
  else
  {
    strcpy(error_message, "bad param\n");
    logMessage(1, error_message, 0);
    return -3;
  }
}
// 42EE8: variable 'lcd_start_pos' is possibly undefined
// 12120: using guessed type int __fastcall lseek64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 505028: using guessed type int dword_505028;
// 50502C: using guessed type int dword_50502C;

//----- (00042F88) --------------------------------------------------------
int __fastcall close_lcd_file_descriptor(int file_descriptor)
{
  int close_result; // r0
  char error_message[2056]; // [sp+0h] [bp-808h] BYREF

  if ( !dword_505028 )
    return dword_505028;
  close_result = close(file_descriptor);
  if ( close_result )
  {
    strcpy(error_message, "lcd close failed!!!\n");
    logMessage(0, error_message, 0);
    close_result = -1;
  }
  dword_505028 = 0;
  return close_result;
}
// 505028: using guessed type int dword_505028;

//----- (00043004) --------------------------------------------------------
int get_fixed_value_941()
{
  return 941;
}

//----- (0004300C) --------------------------------------------------------
int get_fixed_number()
{
  return 942;
}

//----- (00043014) --------------------------------------------------------
int get_static_value()
{
  return 921;
}

//----- (0004301C) --------------------------------------------------------
int sub_4301C()
{
  return 943;
}

//----- (00043024) --------------------------------------------------------
int __fastcall get_temperature_code(int temperature)
{
  int current_value; // r2
  int index; // r3

  current_value = 0;
  for ( index = 0; ; current_value = dword_695A8[4 * index] )
  {
    if ( current_value == temperature )
      return dword_695A8[4 * index + 1];
    if ( ++index == 16 )
      break;
  }
  return -2;
}
// 695A8: using guessed type _DWORD dword_695A8[4];

//----- (0004306C) --------------------------------------------------------
int __fastcall get_fan_speed_index(int fan_speed)
{
  int current_speed; // r2
  int index; // r3

  current_speed = 0;
  for ( index = 0; ; current_speed = dword_695A8[4 * index] )
  {
    if ( current_speed == fan_speed )
      return dword_695A8[4 * index + 2];
    if ( ++index == 16 )
      break;
  }
  return -2;
}
// 695A8: using guessed type _DWORD dword_695A8[4];

//----- (000430B4) --------------------------------------------------------
int __fastcall get_assembler_value(int input_value)
{
  int current_value; // r2
  int index; // r3

  current_value = 0;
  for ( index = 0; ; current_value = dword_695A8[4 * index] )
  {
    if ( current_value == input_value )
      return dword_695A8[4 * index + 3];
    if ( ++index == 16 )
      break;
  }
  return -2;
}
// 695A8: using guessed type _DWORD dword_695A8[4];

//----- (000430FC) --------------------------------------------------------
int check_full_byte_blocks()
{
  _DWORD *memory_pointer; // r3
  int block_count; // r0
  int first_byte; // t1

  memory_pointer = dword_695A8;
  block_count = 0;
  while ( ++block_count != 16 )
  {
    first_byte = memory_pointer[4];
    memory_pointer += 4;
    if ( first_byte == 255 && memory_pointer[1] == 255 && memory_pointer[2] == 255 && memory_pointer[3] == 255 )
      break;
  }
  return block_count;
}
// 695A8: using guessed type _DWORD dword_695A8[4];

//----- (00043148) --------------------------------------------------------
int __fastcall get_error_message(int error_code)
{
  if ( !error_code || error_code == 1 || error_code == 2 || error_code == 3 || error_code == 4 || error_code == 5 )
    return dword_695A8[3 * error_code + 65];
  else
    return -2;
}
// 695A8: using guessed type _DWORD dword_695A8[4];

//----- (00043198) --------------------------------------------------------
int __fastcall get_temperature_range(int temperature_code)
{
  if ( !temperature_code
    || temperature_code == 1
    || temperature_code == 2
    || temperature_code == 3
    || temperature_code == 4
    || temperature_code == 5 )
  {
    return dword_695A8[3 * temperature_code + 66];
  }
  else
  {
    return -1;
  }
}
// 695A8: using guessed type _DWORD dword_695A8[4];

//----- (000431E8) --------------------------------------------------------
int count_valid_entries()
{
  _DWORD *current_entry; // r3
  int status; // r2
  int valid_entries_count; // r0
  int next_status; // t1

  current_entry = &unk_696A8;
  status = 0;
  valid_entries_count = 0;
  while ( 1 )
  {
    if ( status != -1 )
      ++valid_entries_count;
    if ( current_entry == (_DWORD *)&unk_696E4 )
      break;
    next_status = current_entry[3];
    current_entry += 3;
    status = next_status;
  }
  return valid_entries_count;
}

//----- (00043214) --------------------------------------------------------
int __fastcall sub_43214(int a1)
{
  int v2; // [sp+4h] [bp-Ch] BYREF

  read_buffer(a1, &v2);
  return v2;
}

//----- (00043230) --------------------------------------------------------
void *__fastcall process_data(int miner_handle, const void *data_buffer, size_t data_size)
{
  int control_block_ptr; // r5
  int io_context; // r0
  int callback_id; // [sp+4h] [bp-1Ch] BYREF

  control_block_ptr = *(_DWORD *)(miner_handle + 12);
  io_context = *(_DWORD *)(miner_handle + 20);
  if ( *(_DWORD *)(*(_DWORD *)control_block_ptr + 32) )
  {
    read_buffer(io_context, &callback_id);
    (*(void (__fastcall **)(int))(*(_DWORD *)control_block_ptr + 32))(callback_id);
    io_context = *(_DWORD *)(miner_handle + 20);
  }
  return allocate_and_copy(*(void ***)(io_context + 20), data_buffer, data_size);
}

//----- (00043290) --------------------------------------------------------
int *__fastcall sub_43290(int command_pointer)
{
  int data_length; // r1
  int *data_pointer; // r0
  int *processing_result; // r0

  data_length = *(_DWORD *)(command_pointer + 20);
  data_pointer = **(int ***)(command_pointer + 12);
  if ( data_length )
    processing_result = find_predecessor_in_tree(data_pointer, data_length);
  else
    processing_result = find_list_node_by_value((int)data_pointer, (_DWORD *)*data_pointer);
  *(_DWORD *)(command_pointer + 20) = processing_result;
  if ( processing_result )
    return (int *)processing_result[5];
  return processing_result;
}

//----- (000432D0) --------------------------------------------------------
_DWORD *__fastcall sub_432D0(int a1, int a2, int a3)
{
  _DWORD *v6; // r4
  _DWORD *v7; // r0

  v6 = malloc(4u);
  if ( v6 && (v7 = create_context(a1, a2, a3), (*v6 = v7) != 0) )
    return v6;
  else
    return 0;
}

//----- (00043320) --------------------------------------------------------
int __fastcall process_miner_data(
        int *miner_config_ptr,
        const void *input_data1,
        size_t input_length1,
        const void *input_data2,
        size_t input_length2)
{
  if ( miner_config_ptr )
    return insert_in_ordered_linked_list(*miner_config_ptr, input_data1, input_length1, input_data2, input_length2);
  else
    return 501;
}

//----- (00043338) --------------------------------------------------------
int *__fastcall check_and_update_status(int *status_pointer, int update_value)
{
  if ( status_pointer )
    return (int *)(find_matching_element(*status_pointer, update_value) != 0);
  return status_pointer;
}

//----- (00043358) --------------------------------------------------------
int __fastcall handle_network_packet(int *packet_buffer, int packet_length)
{
  int *processed_packet; // r0
  int *cleaned_packet; // r4
  void *freeable_memory[3]; // [sp+4h] [bp-Ch] BYREF

  if ( !packet_buffer )
    return 501;
  processed_packet = remove_element_from_list(*packet_buffer, packet_length);
  cleaned_packet = processed_packet;
  if ( !processed_packet )
    return 0;
  read_buffer(processed_packet[4], freeable_memory);
  free(freeable_memory[0]);
  free_double_pointer((void **)cleaned_packet[4]);
  read_buffer(cleaned_packet[5], freeable_memory);
  free(freeable_memory[0]);
  free_double_pointer((void **)cleaned_packet[5]);
  free(cleaned_packet);
  return 0;
}

//----- (000433D0) --------------------------------------------------------
int __fastcall process_command_and_read_response(int *command_buffer, int command_length, _DWORD *response_buffer)
{
  _DWORD *matched_command_element; // r0

  if ( !command_buffer )
    return 0;
  matched_command_element = find_matching_element(*command_buffer, command_length);
  if ( !matched_command_element )
    return 0;
  read_buffer(matched_command_element[5], response_buffer);
  return 1;
}

//----- (00043414) --------------------------------------------------------
int __fastcall free_and_process_pointer(void **pointer)
{
  int process_result; // r5

  if ( !pointer )
    return 0;
  process_result = cleanup_linked_list(*pointer);
  free(pointer);
  return process_result;
}

//----- (00043440) --------------------------------------------------------
_DWORD *__fastcall create_worker_struct(int input_value)
{
  _DWORD *worker_struct; // r0

  worker_struct = malloc(24u);
  worker_struct[3] = input_value;
  *worker_struct = sub_43290;
  worker_struct[2] = read_integer_from_buffer;
  worker_struct[1] = process_data;
  worker_struct[4] = 0;
  worker_struct[5] = 0;
  return worker_struct;
}

//----- (0004348C) --------------------------------------------------------
int **__fastcall update_linked_list(int **current_node, int *target_node)
{
  int *next_node; // r3
  int *next_pointer; // r12
  int next_value; // r2
  bool is_next_current; // zf
  int previous_value; // r2

  next_node = (int *)target_node[1];
  next_pointer = (int *)(current_node + 1);
  next_value = *next_node;
  is_next_current = *next_node == (_DWORD)(current_node + 1);
  target_node[1] = *next_node;
  if ( !is_next_current )
    *(_DWORD *)(next_value + 8) = target_node;
  previous_value = target_node[2];
  if ( next_pointer != next_node )
  {
    next_node[2] = previous_value;
    previous_value = target_node[2];
  }
  if ( previous_value )
  {
    current_node = *(int ***)previous_value;
    if ( *(int **)previous_value == target_node )
      *(_DWORD *)previous_value = next_node;
    else
      *(_DWORD *)(previous_value + 4) = next_node;
  }
  else
  {
    *current_node = next_node;
  }
  *next_node = (int)target_node;
  if ( next_pointer != target_node )
    target_node[2] = (int)next_node;
  return current_node;
}

//----- (000434E0) --------------------------------------------------------
_DWORD *__fastcall remove_list_element(_DWORD *list_head, _DWORD *element)
{
  _DWORD *prev_element; // r3
  _DWORD *next_head; // r12
  _DWORD *next_element; // r2
  int prev_element_ptr_val; // r2

  prev_element = (_DWORD *)*element;
  next_head = list_head + 1;
  next_element = *(_DWORD **)(*element + 4);
  *element = next_element;
  if ( next_element != list_head + 1 )
    next_element[2] = element;
  prev_element_ptr_val = element[2];
  if ( next_head != prev_element )
  {
    prev_element[2] = prev_element_ptr_val;
    prev_element_ptr_val = element[2];
  }
  if ( prev_element_ptr_val )
  {
    list_head = *(_DWORD **)(prev_element_ptr_val + 4);
    if ( list_head == element )
      *(_DWORD *)(prev_element_ptr_val + 4) = prev_element;
    else
      *(_DWORD *)prev_element_ptr_val = prev_element;
  }
  else
  {
    *list_head = prev_element;
  }
  prev_element[1] = element;
  if ( next_head != element )
    element[2] = prev_element;
  return list_head;
}

//----- (00043534) --------------------------------------------------------
int __fastcall verify_rb_tree_properties(int result, _DWORD *node)
{
  int tree_end; // r5
  int tree_root; // r6
  _DWORD *current_node; // r4

  tree_end = result + 4;
  if ( node != (_DWORD *)(result + 4) )
  {
    tree_root = result;
    current_node = node;
    do
    {
      if ( current_node[3] > 1u )
        _assert_fail(
          "debug_node_color(pTree,n) == clib_red || debug_node_color(pTree,n) == clib_black",
          "3rdparty/cstl/src/c_rb.c",
          479u,
          "debug_verify_property_1");
      result = verify_rb_tree_properties(tree_root, (_DWORD *)*current_node);
      current_node = (_DWORD *)current_node[1];
    }
    while ( current_node != (_DWORD *)tree_end );
  }
  return result;
}

//----- (00043594) --------------------------------------------------------
int __fastcall validate_rb_tree_properties(int initial_node, _DWORD *current_node)
{
  int root_node; // r6
  _DWORD *root_node_next; // r5
  _DWORD *next_node; // r1
  _DWORD *right_node; // r3
  _DWORD *parent_node; // r2

  root_node = initial_node;
  root_node_next = (_DWORD *)(initial_node + 4);
  while ( 2 )
  {
    if ( current_node != root_node_next )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          next_node = (_DWORD *)*current_node;
          if ( current_node[3] == 1 )
            break;
          current_node = (_DWORD *)current_node[1];
LABEL_4:
          initial_node = validate_rb_tree_properties(root_node, next_node);
          if ( current_node == root_node_next )
            return initial_node;
        }
        if ( next_node != root_node_next && next_node[3] )
          _assert_fail(
            "debug_node_color(pTree,n->left) == clib_black",
            "3rdparty/cstl/src/c_rb.c",
            495u,
            "debug_verify_property_4");
        right_node = (_DWORD *)current_node[1];
        if ( right_node == root_node_next )
          break;
        if ( right_node[3] )
          _assert_fail(
            "debug_node_color(pTree,n->right) == clib_black",
            "3rdparty/cstl/src/c_rb.c",
            496u,
            "debug_verify_property_4");
        parent_node = (_DWORD *)current_node[2];
        if ( parent_node != root_node_next )
          goto LABEL_12;
        current_node = (_DWORD *)current_node[1];
        initial_node = validate_rb_tree_properties(root_node, next_node);
      }
      parent_node = (_DWORD *)current_node[2];
      if ( parent_node == root_node_next )
      {
        current_node = (_DWORD *)*current_node;
        continue;
      }
LABEL_12:
      if ( parent_node[3] )
        _assert_fail(
          "debug_node_color(pTree,n->parent) == clib_black",
          "3rdparty/cstl/src/c_rb.c",
          497u,
          "debug_verify_property_4");
      current_node = (_DWORD *)current_node[1];
      goto LABEL_4;
    }
    return initial_node;
  }
}

//----- (0004369C) --------------------------------------------------------
int __fastcall verify_black_property_helper(int result, _DWORD *node, int black_count, _DWORD *path_black_count)
{
  _DWORD *current_node; // r4
  int end; // r8
  int start; // r9
  int updated_black_count; // r5
  int next_black_count; // r6

  current_node = node;
  end = result + 4;
  start = result;
  updated_black_count = black_count;
  for ( next_black_count = black_count + 1; current_node != (_DWORD *)end; current_node = (_DWORD *)current_node[1] )
  {
    if ( !current_node[3] )
      updated_black_count = next_black_count++;
    result = verify_black_property_helper(start, (_DWORD *)*current_node, updated_black_count, path_black_count);
  }
  if ( *path_black_count == -1 )
  {
    *path_black_count = next_black_count;
  }
  else if ( *path_black_count != next_black_count )
  {
    _assert_fail("black_count == *path_black_count", "3rdparty/cstl/src/c_rb.c", 517u, "debug_verify_property_5_helper");
  }
  return result;
}

//----- (0004372C) --------------------------------------------------------
int __fastcall verify_black_properties(_DWORD **root_node)
{
  _DWORD *root; // r4
  _DWORD **next_node; // r5
  int black_count; // [sp+4h] [bp-14h] BYREF

  next_node = root_node + 1;
  root = *root_node;
  verify_rb_tree_properties((int)root_node, *root_node);
  if ( root != next_node && root[3] )
    _assert_fail(
      "debug_node_color(pTree,root) == clib_black",
      "3rdparty/cstl/src/c_rb.c",
      486u,
      "debug_verify_property_2");
  validate_rb_tree_properties((int)root_node, root);
  black_count = -1;
  return verify_black_property_helper((int)root_node, root, 0, &black_count);
}

//----- (000437AC) --------------------------------------------------------
_DWORD *__fastcall create_context(int init_param1, int init_param2, int init_param3)
{
  _DWORD *context; // r0

  context = malloc(40u);
  if ( context )
  {
    context[5] = 0;
    context[6] = 0;
    context[3] = 0;
    context[4] = 0;
    context[9] = init_param1;
    context[7] = init_param2;
    context[8] = init_param3;
    *context = context + 1;
    context[1] = context + 1;
    context[2] = context + 1;
  }
  return context;
}

//----- (00043804) --------------------------------------------------------
_DWORD *__fastcall find_matching_element(int list_head, int search_value)
{
  _DWORD *current_element; // r4
  _DWORD *end_marker; // r7
  _DWORD *previous_element; // r3
  int comparison_result; // r5
  void *temp_data; // [sp+4h] [bp-1Ch] BYREF

  end_marker = (_DWORD *)(list_head + 4);
  current_element = *(_DWORD **)list_head;
  if ( *(_DWORD *)list_head == list_head + 4 )
    return 0;
  while ( 1 )
  {
    read_buffer(current_element[4], &temp_data);
    comparison_result = (*(int (__fastcall **)(int, void *))(list_head + 36))(search_value, temp_data);
    free(temp_data);
    if ( !comparison_result )
      break;
    previous_element = (_DWORD *)*current_element;
    current_element = (_DWORD *)current_element[1];
    if ( comparison_result < 0 )
      current_element = previous_element;
    if ( current_element == end_marker )
      return 0;
  }
  return current_element;
}

//----- (00043884) --------------------------------------------------------
int __fastcall insert_in_ordered_linked_list(
        int list_head,
        const void *data,
        size_t data_len,
        const void *extra_data,
        size_t extra_data_len)
{
  int *new_node; // r5
  int list_head_next; // r8
  int *current_node; // r4
  __int64 comparison_result; // r2
  int compare_status_first; // r7
  int compare_status_last; // r7
  int *previous_node; // r4
  int parent_node; // r3
  int *grandparent_node; // r7
  int uncle_node; // r0
  int *new_root_node; // r2
  void *data_copy; // [sp+0h] [bp-28h] BYREF
  void *new_data_copy[9]; // [sp+4h] [bp-24h] BYREF

  new_node = (int *)malloc(24u);
  if ( !new_node )
    return 2;
  list_head_next = list_head + 4;
  *new_node = list_head + 4;
  new_node[1] = list_head + 4;
  new_node[3] = 1;
  new_node[4] = (int)allocate_and_copy_data(data, data_len);
  if ( extra_data )
    new_node[5] = (int)allocate_and_copy_data(extra_data, extra_data_len);
  else
    new_node[5] = 0;
  current_node = *(int **)list_head;
  if ( list_head_next == *(_DWORD *)list_head )
  {
    *(_DWORD *)list_head = new_node;
    new_node[2] = 0;
    new_root_node = new_node;
  }
  else
  {
    while ( 1 )
    {
      read_buffer(current_node[4], &data_copy);
      read_buffer(new_node[4], new_data_copy);
      compare_status_first = (*(int (__fastcall **)(void *, void *))(list_head + 36))(new_data_copy[0], data_copy);
      free(data_copy);
      free(new_data_copy[0]);
      if ( !compare_status_first )
        return 401;
      comparison_result = *(_QWORD *)current_node;
      if ( compare_status_first < 0 )
        HIDWORD(comparison_result) = *current_node;
      if ( list_head_next == HIDWORD(comparison_result) )
        break;
      current_node = (int *)HIDWORD(comparison_result);
    }
    new_node[2] = (int)current_node;
    read_buffer(current_node[4], &data_copy);
    read_buffer(new_node[4], new_data_copy);
    compare_status_last = (*(int (__fastcall **)(void *, void *))(list_head + 36))(new_data_copy[0], data_copy);
    free(data_copy);
    free(new_data_copy[0]);
    new_root_node = *(int **)list_head;
    if ( compare_status_last >= 0 )
      current_node[1] = (int)new_node;
    else
      *current_node = (int)new_node;
LABEL_17:
    if ( new_node != new_root_node )
    {
      do
      {
        previous_node = (int *)new_node[2];
        if ( previous_node[3] != 1 )
          break;
        parent_node = previous_node[2];
        grandparent_node = *(int **)parent_node;
        if ( previous_node == *(int **)parent_node )
        {
          uncle_node = *(_DWORD *)(parent_node + 4);
          if ( *(_DWORD *)(uncle_node + 12) == 1 )
          {
            previous_node[3] = 0;
            new_node = (int *)parent_node;
            *(_DWORD *)(uncle_node + 12) = 0;
            *(_DWORD *)(parent_node + 12) = 1;
          }
          else
          {
            if ( (int *)grandparent_node[1] == new_node )
            {
              update_linked_list((int **)list_head, *(int **)parent_node);
              grandparent_node = (int *)grandparent_node[2];
              new_node = previous_node;
              parent_node = grandparent_node[2];
            }
            grandparent_node[3] = 0;
            *(_DWORD *)(parent_node + 12) = 1;
            remove_list_element((_DWORD *)list_head, (_DWORD *)parent_node);
            new_root_node = *(int **)list_head;
          }
          goto LABEL_17;
        }
        if ( grandparent_node[3] == 1 )
        {
          previous_node[3] = 0;
          new_node = (int *)parent_node;
          grandparent_node[3] = 0;
          *(_DWORD *)(parent_node + 12) = 1;
          goto LABEL_17;
        }
        if ( new_node == (int *)*previous_node )
        {
          remove_list_element((_DWORD *)list_head, (_DWORD *)new_node[2]);
          new_node = previous_node;
          parent_node = *(_DWORD *)(previous_node[2] + 8);
          previous_node = (int *)previous_node[2];
        }
        previous_node[3] = 0;
        *(_DWORD *)(parent_node + 12) = 1;
        update_linked_list((int **)list_head, (int *)parent_node);
        new_root_node = *(int **)list_head;
      }
      while ( new_node != *(int **)list_head );
    }
  }
  new_root_node[3] = 0;
  verify_black_properties((_DWORD **)list_head);
  return 0;
}

//----- (00043AE8) --------------------------------------------------------
int *__fastcall sub_43AE8(int a1, int a2)
{
  int *v2; // r4
  int *v3; // r7
  int v6; // r5
  int *v7; // r3
  int *v8; // r5
  int *v9; // r7
  int **v10; // r3
  int v11; // r1
  int v12; // r3
  int v13; // r2
  int *v15; // r3
  int *v16; // r2
  int *v17; // r3
  int v18; // r1
  int v19; // r12
  int v20; // r0
  int v21; // r12
  int v22; // r0
  void *ptr; // [sp+4h] [bp-1Ch] BYREF

  v3 = (int *)(a1 + 4);
  v2 = *(int **)a1;
  if ( a1 + 4 == *(_DWORD *)a1 )
    return 0;
  while ( 1 )
  {
    read_buffer(v2[4], &ptr);
    v6 = (*(int (__fastcall **)(int, void *))(a1 + 36))(a2, ptr);
    free(ptr);
    v7 = (int *)*v2;
    if ( !v6 )
      break;
    v2 = (int *)v2[1];
    if ( v6 < 0 )
      v2 = v7;
    if ( v2 == v3 )
      return 0;
  }
  v8 = (int *)v2[1];
  if ( v3 != v7 )
  {
    if ( v3 != v8 )
    {
      while ( v3 != (int *)*v8 )
        v8 = (int *)*v8;
      v9 = v8;
      v8 = (int *)v8[1];
      goto LABEL_14;
    }
    v8 = (int *)*v2;
  }
  v9 = v2;
LABEL_14:
  v8[2] = v9[2];
  v10 = (int **)v9[2];
  if ( v10 )
  {
    if ( v9 == *v10 )
      *v10 = v8;
    else
      v10[1] = v8;
  }
  else
  {
    *(_DWORD *)a1 = v8;
  }
  if ( v9 != v2 )
  {
    v11 = v2[4];
    v12 = v2[5];
    v13 = v9[5];
    v2[4] = v9[4];
    v9[4] = v11;
    v2[5] = v13;
    v9[5] = v12;
  }
  if ( !v9[3] )
  {
    v15 = *(int **)a1;
LABEL_25:
    if ( v8 != v15 )
    {
      while ( !v8[3] )
      {
        v16 = (int *)v8[2];
        v17 = (int *)*v16;
        if ( v8 == (int *)*v16 )
        {
          v17 = (int *)v16[1];
          if ( v17[3] == 1 )
          {
            v17[3] = 0;
            v16[3] = 1;
            update_linked_list((int **)a1, v16);
            v16 = (int *)v8[2];
            v17 = (int *)v16[1];
          }
          v21 = v17[1];
          v22 = *(_DWORD *)(v21 + 12);
          if ( *(_DWORD *)(*v17 + 12) )
          {
            if ( v22 )
            {
              v8 = v16;
            }
            else
            {
              *(_DWORD *)(*v17 + 12) = 0;
              v17[3] = 1;
              remove_list_element((_DWORD *)a1, v17);
              v8 = (int *)v8[2];
              v17 = (int *)v8[1];
              v21 = v17[1];
            }
LABEL_42:
            v17[3] = v8[3];
            v8[3] = 0;
            *(_DWORD *)(v21 + 12) = 0;
            update_linked_list((int **)a1, v8);
            v8 = *(int **)a1;
            v15 = *(int **)a1;
            goto LABEL_25;
          }
          v8 = v16;
          if ( v22 )
            goto LABEL_42;
        }
        else
        {
          if ( v17[3] == 1 )
          {
            v17[3] = 0;
            v16[3] = 1;
            remove_list_element((_DWORD *)a1, v16);
            v16 = (int *)v8[2];
            v17 = (int *)*v16;
          }
          v18 = v17[1];
          v19 = *v17;
          v20 = *(_DWORD *)(*v17 + 12);
          if ( *(_DWORD *)(v18 + 12) )
          {
            if ( v20 )
            {
              v8 = v16;
            }
            else
            {
              *(_DWORD *)(v18 + 12) = 0;
              v17[3] = 1;
              update_linked_list((int **)a1, v17);
              v8 = (int *)v8[2];
              v17 = (int *)*v8;
              v19 = *(_DWORD *)*v8;
            }
LABEL_37:
            v17[3] = v8[3];
            v8[3] = 0;
            *(_DWORD *)(v19 + 12) = 0;
            remove_list_element((_DWORD *)a1, v8);
            v8 = *(int **)a1;
            v15 = *(int **)a1;
            goto LABEL_25;
          }
          v8 = v16;
          if ( v20 )
            goto LABEL_37;
        }
        v17[3] = 1;
        if ( v8 == *(int **)a1 )
          break;
      }
    }
    v8[3] = 0;
  }
  verify_black_properties((_DWORD **)a1);
  return v9;
}

//----- (00043D9C) --------------------------------------------------------
int __fastcall cleanup_linked_list(void *list_head)
{
  char *current_node; // r4
  char *list_tail; // r5
  char *next_node; // r7
  void **on_before_free_callback_arg; // r0
  void **on_after_free_callback_arg; // r0
  int second_last_node; // r8
  char *old_next_node; // r0
  char *node_to_free; // r0
  int pre_free_callback_arg_value; // [sp+0h] [bp-20h] BYREF
  int post_free_callback_arg_value; // [sp+4h] [bp-1Ch] BYREF

  list_tail = (char *)list_head + 4;
  current_node = *(char **)list_head;
  while ( current_node != list_tail )
  {
    if ( *(char **)current_node == list_tail )
    {
      next_node = (char *)*((_DWORD *)current_node + 1);
      if ( list_tail == next_node )
      {
        on_before_free_callback_arg = (void **)*((_DWORD *)current_node + 4);
        if ( *((_DWORD *)list_head + 7) )
        {
          read_buffer((int)on_before_free_callback_arg, &pre_free_callback_arg_value);
          (*((void (__fastcall **)(int))list_head + 7))(pre_free_callback_arg_value);
          on_before_free_callback_arg = (void **)*((_DWORD *)current_node + 4);
        }
        free_double_pointer(on_before_free_callback_arg);
        on_after_free_callback_arg = (void **)*((_DWORD *)current_node + 5);
        if ( on_after_free_callback_arg )
        {
          if ( *((_DWORD *)list_head + 8) )
          {
            read_buffer((int)on_after_free_callback_arg, &post_free_callback_arg_value);
            (*((void (__fastcall **)(int))list_head + 8))(post_free_callback_arg_value);
            on_after_free_callback_arg = (void **)*((_DWORD *)current_node + 5);
          }
          free_double_pointer(on_after_free_callback_arg);
        }
        second_last_node = *((_DWORD *)current_node + 2);
        if ( second_last_node )
        {
          if ( next_node == *(char **)second_last_node )
          {
            old_next_node = *(char **)(second_last_node + 4);
            current_node = (char *)*((_DWORD *)current_node + 2);
            if ( next_node != old_next_node )
            {
              free(old_next_node);
              *(_DWORD *)(second_last_node + 4) = next_node;
            }
          }
          else
          {
            free(*(void **)second_last_node);
            current_node = (char *)second_last_node;
            *(_DWORD *)second_last_node = next_node;
          }
        }
        else
        {
          node_to_free = current_node;
          current_node = next_node;
          free(node_to_free);
        }
      }
      else
      {
        current_node = (char *)*((_DWORD *)current_node + 1);
      }
    }
    else
    {
      current_node = *(char **)current_node;
    }
  }
  free(list_head);
  return 0;
}

//----- (00043EA4) --------------------------------------------------------
_DWORD *__fastcall find_list_node_by_value(int base_value, _DWORD *current_node)
{
  int target_value; // r0

  target_value = base_value + 4;
  while ( *current_node != target_value )
    current_node = (_DWORD *)*current_node;
  return current_node;
}

//----- (00043EC4) --------------------------------------------------------
int __fastcall find_node(int input_node, int start_node)
{
  int target_value; // r0

  target_value = input_node + 4;
  while ( *(_DWORD *)(start_node + 4) != target_value )
    start_node = *(_DWORD *)(start_node + 4);
  return start_node;
}

//----- (00043EE4) --------------------------------------------------------
bool __fastcall is_first_element_not_equal_to_second_pointer_incremented(_DWORD *pointer_to_elements)
{
  return *pointer_to_elements != (_DWORD)(pointer_to_elements + 1);
}

//----- (00043EF8) --------------------------------------------------------
int *__fastcall find_predecessor_in_tree(int *node, int target)
{
  int *current; // r3
  int *next_node; // r12
  int root_node; // r2
  int parent_node; // r2
  bool is_left_child; // zf

  current = *(int **)(target + 4);
  next_node = node + 1;
  if ( current != node + 1 )
  {
    while ( next_node != (int *)*current )
      current = (int *)*current;
    return current;
  }
  for ( root_node = *node; next_node != *(int **)(root_node + 4); root_node = *(_DWORD *)(root_node + 4) )
    ;
  if ( target == root_node )
    return 0;
  parent_node = *(_DWORD *)(target + 8);
  if ( next_node == (int *)parent_node )
    return node + 1;
  if ( target != *(_DWORD *)(parent_node + 4) )
    return *(int **)(target + 8);
  while ( 1 )
  {
    current = *(int **)(parent_node + 8);
    if ( next_node == current )
      break;
    is_left_child = current[1] == parent_node;
    parent_node = *(_DWORD *)(parent_node + 8);
    if ( !is_left_child )
      return current;
  }
  return *(int **)(parent_node + 8);
}

//----- (00043FA4) --------------------------------------------------------
_DWORD *__fastcall allocate_and_copy_data(const void *source_data, size_t data_size)
{
  _DWORD *allocated_memory_pair; // r0
  _DWORD *result_pair; // r4
  void *allocated_data; // r0
  void *temp_pointer; // r0

  allocated_memory_pair = malloc(8u);
  result_pair = allocated_memory_pair;
  if ( allocated_memory_pair )
  {
    allocated_memory_pair[1] = data_size;
    allocated_data = malloc(data_size);
    *result_pair = allocated_data;
    if ( allocated_data )
    {
      memcpy(allocated_data, source_data, data_size);
    }
    else
    {
      temp_pointer = result_pair;
      result_pair = 0;
      free(temp_pointer);
    }
  }
  return result_pair;
}

//----- (00044000) --------------------------------------------------------
int __fastcall read_buffer(int source_ptr, _DWORD *dest_buffer_ptr)
{
  size_t buffer_size; // r5
  void *allocated_buffer; // r0

  buffer_size = *(_DWORD *)(source_ptr + 4);
  allocated_buffer = malloc(buffer_size);
  *dest_buffer_ptr = allocated_buffer;
  if ( !allocated_buffer )
    return 3;
  memcpy(allocated_buffer, *(const void **)source_ptr, buffer_size);
  return 0;
}

//----- (00044040) --------------------------------------------------------
void *__fastcall allocate_and_copy(void **destination, const void *source, size_t size)
{
  void *new_memory; // r0

  free(*destination);
  new_memory = malloc(size);
  *destination = new_memory;
  return memcpy(new_memory, source, size);
}

//----- (00044074) --------------------------------------------------------
void __fastcall free_double_pointer(void **double_ptr)
{
  if ( double_ptr )
  {
    free(*double_ptr);
    free(double_ptr);
  }
}

//----- (00044098) --------------------------------------------------------
int __fastcall log_bad_eeprom_param(int input_chain_id)
{
  char error_message[2056]; // [sp+8h] [bp-808h] BYREF

  snprintf(error_message, 2048u, "%s: Bad eeprom param, input chain is %d\n", "eeprom_open", input_chain_id);
  logMessage(0, error_message, 0);
  return -2147483391;
}

//----- (000440E8) --------------------------------------------------------
int __fastcall initiate_device_communication(unsigned int device_id)
{
  int communication_result; // r0
  unsigned int i2c_transfer_data; // [sp+0h] [bp-18h] BYREF
  __int16 zero_padding; // [sp+4h] [bp-14h]
  char i2c_bus_number; // [sp+6h] [bp-12h]
  char device_id_copy; // [sp+7h] [bp-11h]

  if ( device_id > 15 )
    return log_bad_eeprom_param(device_id);
  communication_result = dword_505088[2 * device_id];
  if ( !communication_result || !dword_505088[2 * device_id + 1] )
  {
    zero_padding = 0;
    i2c_bus_number = 10;
    i2c_transfer_data = device_id;
    device_id_copy = device_id;
    communication_result = initiateI2CTransfer((int)&i2c_transfer_data);
    if ( communication_result >= 0 )
    {
      dword_505088[2 * device_id] = communication_result;
      dword_505088[2 * device_id + 1] = 1;
    }
  }
  return communication_result;
}
// 505088: using guessed type _DWORD dword_505088[32];

//----- (00044164) --------------------------------------------------------
int __fastcall close_eeprom(unsigned int chain_index)
{
  unsigned int double_chain_index; // r6
  int close_result; // r0
  char error_message[2064]; // [sp+8h] [bp-810h] BYREF

  if ( chain_index > 15 )
  {
    snprintf(error_message, 2048u, "%s: Bad eeprom param, input chain is %d\n", "eeprom_close", chain_index);
    return logMessage(0, error_message, 0);
  }
  else
  {
    double_chain_index = 2 * chain_index;
    close_result = dword_505088[2 * chain_index];
    if ( close_result || dword_505088[double_chain_index + 1] )
    {
      close_result = attempt_i2c_operation(close_result);
      dword_505088[double_chain_index + 1] = 0;
      dword_505088[2 * chain_index] = 0;
    }
  }
  return close_result;
}
// 505088: using guessed type _DWORD dword_505088[32];

//----- (00044200) --------------------------------------------------------
int __fastcall writeDataToEeprom(unsigned int chainIndex, unsigned __int8 startValue, int startAddress, int length)
{
  int v8; // r8
  int v9; // r3
  int v10; // r0
  int v11; // r9
  unsigned __int8 v13; // [sp+Fh] [bp-821h] BYREF
  char logBuffer[2080]; // [sp+10h] [bp-820h] BYREF

  if ( chainIndex > 15 )
  {
    snprintf(logBuffer, 2048u, "%s: Bad eeprom param, input chain is %d\n", "eeprom_write", chainIndex);
    v11 = -2147483391;
    logMessage(0, logBuffer, 0);
    return v11;
  }
  if ( !dword_505088[2 * chainIndex + 1] )
  {
    v11 = initiate_device_communication(chainIndex);
    if ( v11 < 0 )
    {
      snprintf(
        logBuffer,
        2048u,
        "%s: auto exec eeprom_open, but chain %d open eeprom failed\n",
        "eeprom_write",
        chainIndex);
      logMessage(0, logBuffer, 0);
      return v11;
    }
  }
  if ( length )
  {
    v8 = startAddress + length;
    while ( 1 )
    {
      v9 = startAddress;
      v10 = dword_505088[2 * chainIndex];
      ++startAddress;
      v13 = startValue++;
      if ( i2c_transaction_wrapper(v10, &v13, 1, v9, 1) != 1 )
        break;
      if ( v8 == startAddress )
        goto LABEL_10;
    }
    v11 = -2147483392;
    snprintf(logBuffer, 2048u, "fail to write eeprom by iic, chain:%d, addr: %d", chainIndex, v13);
    logMessage(0, logBuffer, 0);
    return v11;
  }
LABEL_10:
  sleep(1u);
  return 0;
}
// 505088: using guessed type _DWORD dword_505088[32];

//----- (00044358) --------------------------------------------------------
int __fastcall readEepromData(unsigned int chainIndex, unsigned __int8 startAddress, int offset, int length)
{
  int finalOffset; // r8
  int temporaryOffset; // r3
  int fileDescriptor; // r0
  int readResult; // r9
  unsigned __int8 currentAddress; // [sp+Fh] [bp-821h] BYREF
  char logBuffer[2080]; // [sp+10h] [bp-820h] BYREF

  if ( chainIndex > 15 )
  {
    snprintf(logBuffer, 2048u, "%s: Bad eeprom param, input chain is %d\n", "eeprom_read", chainIndex);
    readResult = -2147483391;
    logMessage(0, logBuffer, 0);
    return readResult;
  }
  if ( !dword_505088[2 * chainIndex + 1] )
  {
    readResult = initiate_device_communication(chainIndex);
    if ( readResult < 0 )
    {
      snprintf(
        logBuffer,
        2048u,
        "%s: auto exec eeprom_open, but chain %d open eeprom failed\n",
        "eeprom_read",
        chainIndex);
      logMessage(0, logBuffer, 0);
      return readResult;
    }
  }
  if ( length )
  {
    finalOffset = offset + length;
    while ( 1 )
    {
      temporaryOffset = offset;
      fileDescriptor = dword_505088[2 * chainIndex];
      ++offset;
      currentAddress = startAddress++;
      if ( perform_i2c_transaction(fileDescriptor, &currentAddress, 1, temporaryOffset, 1) != 1 )
        break;
      if ( finalOffset == offset )
        goto LABEL_10;
    }
    readResult = -2147483392;
    snprintf(logBuffer, 2048u, "fail to read eeprom by iic, chain: %d, addr: %d\n", chainIndex, currentAddress);
    logMessage(0, logBuffer, 0);
    return readResult;
  }
LABEL_10:
  usleep(500000u);
  return 0;
}
// 505088: using guessed type _DWORD dword_505088[32];

//----- (000444B8) --------------------------------------------------------
int disable_asic_boost_mode()
{
  int retry_count; // r4
  int final_result; // r0
  int reg_value; // [sp+4h] [bp-14h] BYREF

  retry_count = 10;
  reg_value = 0;
  read_register_value(35, &reg_value);
  set_register_value(35, reg_value & 0xFFFFFFBF);
  do
  {
    usleep(1000u);
    reg_value = 0;
    read_register_value(35, &reg_value);
    final_result = 35;
    if ( (reg_value & 0x40) == 0 )
      break;
    reg_value = 0;
    read_register_value(35, &reg_value);
    final_result = set_register_value(35, reg_value & 0xFFFFFFBF);
    --retry_count;
  }
  while ( retry_count );
  return final_result;
}

//----- (00044540) --------------------------------------------------------
int __fastcall get_baud_rate_code(int baud_rate)
{
  if ( baud_rate == 115200 )
    return 26;
  if ( (double)baud_rate == 1500000.0 )
    return 1;
  if ( (_UNKNOWN *)baud_rate == &unk_2DC6C0 )
    return 0;
  if ( (_UNKNOWN *)baud_rate == &unk_5B8D80 )
    return 3;
  if ( baud_rate == 12000000 )
    return 4;
  if ( baud_rate == 25000000 )
    return 5;
  return baud_rate;
}

//----- (000445E0) --------------------------------------------------------
int __fastcall set_and_wait_for_register_value(int register_value)
{
  int retry_count; // r4
  int operation_result; // r0
  int value_buffer[3]; // [sp+4h] [bp-Ch] BYREF

  set_register_value(27, register_value);
  if ( register_value >= 0 )
    return read_register_value(27, value_buffer);
  retry_count = 3001;
  do
  {
    read_register_value(27, value_buffer);
    operation_result = 1000;
    if ( value_buffer[0] >= 0 )
      break;
    operation_result = usleep(1000u);
    --retry_count;
  }
  while ( retry_count );
  return operation_result;
}

//----- (0004464C) --------------------------------------------------------
int initialize_system()
{
  return 0;
}

//----- (00044654) --------------------------------------------------------
__int64 __fastcall get_hashrate_value(int miner_index)
{
  return *(_QWORD *)(dword_505108 + (miner_index << 6) + 8);
}
// 505108: using guessed type int dword_505108;

//----- (0004466C) --------------------------------------------------------
int __fastcall get_value_from_offset(int index)
{
  return *(_DWORD *)(dword_505108 + (index << 6));
}
// 505108: using guessed type int dword_505108;

//----- (00044680) --------------------------------------------------------
int __fastcall get_value_from_table(int index)
{
  return *(_DWORD *)(dword_505108 + (index << 6) + 4);
}
// 505108: using guessed type int dword_505108;

//----- (00044698) --------------------------------------------------------
int __fastcall sub_44698(int a1, int a2, int a3)
{
  int v3; // r0
  int v4; // r0
  int v5; // r2
  int v6; // r1
  char v7; // t1

  v3 = a1 << 6;
  if ( a3 )
  {
    v4 = dword_505108 + v3 + 31;
    v5 = a2 + a3 - 1;
    v6 = a2 - 1;
    do
    {
      v7 = *(_BYTE *)++v4;
      *(_BYTE *)++v6 = v7;
    }
    while ( v6 != v5 );
  }
  return 0;
}
// 505108: using guessed type int dword_505108;

//----- (000446DC) --------------------------------------------------------
unsigned int configure_antminer_protection()
{
  unsigned int protection_reg_value; // [sp+4h] [bp-Ch] BYREF

  protection_reg_value = 0;
  read_register_value(13, &protection_reg_value);
  protection_reg_value = ~(~HIWORD(protection_reg_value) << 16);
  set_register_value(13, protection_reg_value);
  return sleep(2u);
}

//----- (00044724) --------------------------------------------------------
unsigned int wait_for_operational_state()
{
  unsigned int status_register_value; // [sp+4h] [bp-Ch] BYREF

  status_register_value = 0;
  read_register_value(13, &status_register_value);
  status_register_value = HIWORD(status_register_value) << 16;
  set_register_value(13, status_register_value);
  return sleep(2u);
}

//----- (0004476C) --------------------------------------------------------
int read_asic_version()
{
  int asic_version; // [sp+4h] [bp-Ch] BYREF

  asic_version = 0;
  read_register_value(35, &asic_version);
  return asic_version;
}

//----- (00044794) --------------------------------------------------------
int __fastcall set_frequency(int frequency)
{
  return set_register_value(35, frequency);
}

//----- (000447D8) --------------------------------------------------------
int disable_hardware_watchdog()
{
  int watchdog_register_value; // [sp+4h] [bp-Ch] BYREF

  watchdog_register_value = 0;
  read_register_value(35, &watchdog_register_value);
  set_register_value(35, watchdog_register_value & 0xFFFFFFBF);
  return 0;
}

//----- (00044880) --------------------------------------------------------
int __fastcall set_fan_speed_by_percentage(__int16 fan_speed_percentage)
{
  __int16 fan_speed_value; // r4
  int current_register_value; // [sp+4h] [bp-14h] BYREF

  current_register_value = 0;
  fan_speed_value = fan_speed_percentage << 8;
  read_register_value(35, &current_register_value);
  set_register_value(35, fan_speed_value & 0xF00 | current_register_value & 0xFFFFF0FF);
  return 0;
}

//----- (000448C8) --------------------------------------------------------
int enable_feature_flag()
{
  int current_reg_value; // [sp+4h] [bp-Ch] BYREF

  current_reg_value = 0;
  read_register_value(35, &current_reg_value);
  set_register_value(35, current_reg_value | 0x8000);
  return 0;
}

//----- (00044970) --------------------------------------------------------
int disable_register_protection()
{
  int register_value; // [sp+4h] [bp-Ch] BYREF

  register_value = 0;
  read_register_value(35, &register_value);
  set_register_value(35, register_value & 0xFFFFFFDF);
  return 0;
}

//----- (000449E0) --------------------------------------------------------
int disable_asic_boost()
{
  int register_value; // [sp+4h] [bp-Ch] BYREF

  register_value = 0;
  read_register_value(35, &register_value);
  set_register_value(35, register_value & 0xFFFFBFFF);
  return 0;
}

//----- (00044A50) --------------------------------------------------------
int disable_register_bit()
{
  int register_value; // [sp+4h] [bp-Ch] BYREF

  register_value = 0;
  read_register_value(35, &register_value);
  set_register_value(35, register_value & 0xFFFFDFFF);
  return 0;
}

//----- (00044A88) --------------------------------------------------------
int disable_asics()
{
  int asic_status_register; // [sp+0h] [bp-10h] BYREF
  int asic_control_register; // [sp+4h] [bp-Ch] BYREF

  asic_status_register = 0;
  read_register_value(27, &asic_status_register);
  asic_status_register &= ~0x400000u;
  set_register_value(27, asic_status_register);
  asic_control_register = 0;
  read_register_value(35, &asic_control_register);
  return set_register_value(35, asic_control_register & 0xFFFFFFBF);
}

//----- (00044AE4) --------------------------------------------------------
int disable_boost_mode_and_sleep()
{
  unsigned int current_reg_value; // [sp+4h] [bp-Ch] BYREF

  current_reg_value = 0;
  read_register_value(13, &current_reg_value);
  set_register_value(13, ~(~HIWORD(current_reg_value) << 16));
  sleep(3u);
  read_register_value(13, &current_reg_value);
  set_register_value(13, HIWORD(current_reg_value) << 16);
  sleep(1u);
  return disable_asic_boost_mode();
}

//----- (00044B54) --------------------------------------------------------
int __fastcall format_register_values(char *output_buffer, size_t buffer_size)
{
  int low_register_value; // [sp+8h] [bp-18h] BYREF
  int high_register_value; // [sp+Ch] [bp-14h] BYREF

  low_register_value = 0;
  high_register_value = 0;
  read_register_value(31, &low_register_value);
  read_register_value(32, &high_register_value);
  return snprintf(output_buffer, buffer_size, "%08x%08x", high_register_value, low_register_value);
}

//----- (00044BB0) --------------------------------------------------------
int __fastcall set_target_frequency(int frequency)
{
  return set_register_value(0, frequency);
}

//----- (00044BBC) --------------------------------------------------------
int get_register_41_value()
{
  int register_value; // [sp+4h] [bp-Ch] BYREF

  read_register_value(41, &register_value);
  return register_value;
}

//----- (00044BDC) --------------------------------------------------------
int __fastcall set_and_read_reg_value(int reg_value)
{
  int read_reg_value; // [sp+4h] [bp-Ch] BYREF

  set_register_value(41, reg_value);
  return read_register_value(41, &read_reg_value);
}

//----- (00044C04) --------------------------------------------------------
int get_register_value()
{
  int register_value; // [sp+4h] [bp-Ch] BYREF

  read_register_value(39, &register_value);
  return register_value;
}

//----- (00044C24) --------------------------------------------------------
int __fastcall sub_44C24(int a1)
{
  int v3[3]; // [sp+4h] [bp-Ch] BYREF

  read_register_value(39, v3);
  set_register_value(39, a1);
  return read_register_value(39, v3);
}
// 44C24: using guessed type _DWORD var_C[3];

//----- (00044C5C) --------------------------------------------------------
int __fastcall set_and_read_register_20(int register_value)
{
  int read_value; // [sp+4h] [bp-Ch] BYREF

  set_register_value(20, register_value);
  return read_register_value(20, &read_value);
}

//----- (00044C84) --------------------------------------------------------
int __fastcall configure_register_and_read_value(int input_value)
{
  int output_value; // [sp+4h] [bp-Ch] BYREF

  set_register_value(20, input_value & 0x1FFFF | 0x80000000);
  return read_register_value(20, &output_value);
}

//----- (00044CB0) --------------------------------------------------------
int sub_44CB0()
{
  int chip_temperature; // [sp+4h] [bp-Ch] BYREF

  read_register_value(22, &chip_temperature);
  return chip_temperature;
}

//----- (00044CD0) --------------------------------------------------------
int __fastcall set_and_read_register(int register_value)
{
  int read_value; // [sp+4h] [bp-Ch] BYREF

  set_register_value(22, register_value);
  return read_register_value(22, &read_value);
}

//----- (00044CF8) --------------------------------------------------------
int init_asic_miner()
{
  return set_register_value(33, 196608);
}

//----- (00044D04) --------------------------------------------------------
int set_control_register()
{
  return set_register_value(33, 65536);
}

//----- (00044D10) --------------------------------------------------------
int read_hardware_version()
{
  int hardware_version; // [sp+4h] [bp-Ch] BYREF

  read_register_value(33, &hardware_version);
  return (unsigned __int16)hardware_version;
}

//----- (00044D30) --------------------------------------------------------
int disable_asic()
{
  return set_register_value(33, 0);
}

//----- (00044D3C) --------------------------------------------------------
int read_chip_temperature()
{
  int temperature_raw; // [sp+4h] [bp-Ch] BYREF

  read_register_value(6, &temperature_raw);
  return temperature_raw & 0x7FFF;
}

//----- (00044D94) --------------------------------------------------------
__int64 __fastcall get_register_values(_QWORD *out_values)
{
  __int64 first_register_value; // r0
  __int64 second_register_value; // r2
  __int64 combined_register_value; // [sp+0h] [bp-18h] BYREF
  __int64 separate_register_values[2]; // [sp+8h] [bp-10h] BYREF

  combined_register_value = 0LL;
  separate_register_values[0] = 0LL;
  read_register_value(4, &combined_register_value);
  read_register_value(5, (_DWORD *)&combined_register_value + 1);
  read_register_value(4, separate_register_values);
  read_register_value(5, (_DWORD *)separate_register_values + 1);
  first_register_value = combined_register_value;
  second_register_value = separate_register_values[0];
  *out_values = combined_register_value;
  out_values[1] = second_register_value;
  return first_register_value;
}

//----- (00044DFC) --------------------------------------------------------
int sub_44DFC()
{
  int temperature; // [sp+4h] [bp-Ch] BYREF

  read_register_value(21, &temperature);
  return temperature;
}

//----- (00044E1C) --------------------------------------------------------
int __fastcall write_and_read_register(int register_value_to_write)
{
  int read_register_value; // [sp+4h] [bp-Ch] BYREF

  set_register_value(21, register_value_to_write);
  return ::read_register_value(21, &read_register_value);
}

//----- (00044E44) --------------------------------------------------------
int get_register_44_value()
{
  int register_value; // [sp+4h] [bp-Ch] BYREF

  read_register_value(44, &register_value);
  return register_value;
}

//----- (00044E64) --------------------------------------------------------
int __fastcall sub_44E64(int desired_register_value)
{
  int actual_register_value; // [sp+4h] [bp-Ch] BYREF

  set_register_value(44, desired_register_value);
  return read_register_value(44, &actual_register_value);
}

//----- (00044E8C) --------------------------------------------------------
int get_register_42_value()
{
  int register_value; // [sp+4h] [bp-Ch] BYREF

  read_register_value(42, &register_value);
  return register_value;
}

//----- (00044EAC) --------------------------------------------------------
int __fastcall sub_44EAC(int value_to_set)
{
  int read_value; // [sp+4h] [bp-Ch] BYREF

  set_register_value(42, value_to_set);
  return read_register_value(42, &read_value);
}

//----- (00044ED4) --------------------------------------------------------
int read_chip_version()
{
  int chip_version; // [sp+4h] [bp-Ch] BYREF

  read_register_value(3, &chip_version);
  return chip_version;
}

//----- (00044F28) --------------------------------------------------------
int read_asic_chip_version()
{
  int asic_chip_version; // [sp+4h] [bp-Ch] BYREF

  read_register_value(45, &asic_chip_version);
  return asic_chip_version;
}

//----- (00044F48) --------------------------------------------------------
int __fastcall sub_44F48(int a1, int a2, int a3)
{
  unsigned int v3; // r3
  int v5; // r0
  bool v6; // zf
  _BOOL4 v7; // r12
  int v8; // r7
  int v9; // r8
  int v10; // r6
  int v11; // r5
  int v13; // r6
  int v14; // r5
  int v15[2]; // [sp+0h] [bp-20h]

  v3 = 0;
  v5 = 0;
  v15[0] = 0;
  v15[1] = 0;
  do
  {
    v6 = (a3 & (1 << v3)) == 0;
    if ( (a3 & (1 << v3)) != 0 )
      *((_BYTE *)v15 + v5) = v3;
    ++v3;
    if ( !v6 )
      ++v5;
    v7 = v3 <= 31;
    if ( v5 > 7 )
      v7 = 0;
  }
  while ( v7 );
  if ( a2 == 4 )
  {
    set_register_value(45, a1);
    v13 = a1 | (1 << SLOBYTE(v15[0]));
    set_register_value(57, v13);
    v14 = 1 << SBYTE1(v15[0]);
    set_register_value(58, (1 << SBYTE1(v15[0])) | a1);
    return set_register_value(59, v13 | v14);
  }
  else if ( a2 == 8 )
  {
    set_register_value(45, a1);
    v8 = a1 | (1 << SLOBYTE(v15[0]));
    set_register_value(57, v8);
    v9 = (1 << SBYTE1(v15[0])) | a1;
    v10 = v8 | (1 << SBYTE1(v15[0]));
    set_register_value(58, v9);
    v11 = 1 << SBYTE2(v15[0]);
    set_register_value(59, (1 << SBYTE2(v15[0])) | a1);
    set_register_value(60, v10);
    set_register_value(61, v8 | v11);
    set_register_value(62, v9 | v11);
    return set_register_value(63, v11 | v10);
  }
  else
  {
    return set_register_value(45, a1);
  }
}

//----- (0004509C) --------------------------------------------------------
int read_asic_temperature()
{
  int temperature_value; // [sp+4h] [bp-Ch] BYREF

  read_register_value(46, &temperature_value);
  return temperature_value;
}

//----- (000450BC) --------------------------------------------------------
int __fastcall sub_450BC(int register_value)
{
  int read_back_value; // [sp+4h] [bp-Ch] BYREF

  set_register_value(46, register_value);
  return read_register_value(46, &read_back_value);
}

//----- (000450E4) --------------------------------------------------------
int get_register_47_value()
{
  int register_value; // [sp+4h] [bp-Ch] BYREF

  read_register_value(47, &register_value);
  return register_value;
}

//----- (00045104) --------------------------------------------------------
int __fastcall write_and_read_back_register(int register_value)
{
  int read_back_value; // [sp+4h] [bp-Ch] BYREF

  set_register_value(47, register_value);
  return read_register_value(47, &read_back_value);
}

//----- (0004512C) --------------------------------------------------------
int __fastcall set_register_values_from_array(int input_array_ptr)
{
  int array_ptr; // r5
  int register_index; // r4
  int current_register; // r0
  int value_to_set; // t1
  int last_set_result; // r0

  array_ptr = input_array_ptr - 4;
  register_index = 48;
  do
  {
    current_register = register_index++;
    value_to_set = *(_DWORD *)(array_ptr + 4);
    array_ptr += 4;
    last_set_result = set_register_value(current_register, value_to_set);
  }
  while ( register_index != 56 );
  return last_set_result;
}

//----- (00045154) --------------------------------------------------------
int __fastcall sub_45154(int register_value)
{
  int read_value; // [sp+4h] [bp-Ch] BYREF

  set_register_value(36, register_value);
  return read_register_value(36, &read_value);
}

//----- (00045244) --------------------------------------------------------
int __fastcall read_dual_registers(int *register_values)
{
  int readback_buffer[3]; // [sp+4h] [bp-Ch] BYREF

  set_register_value(37, *register_values);
  set_register_value(38, register_values[1]);
  read_register_value(37, readback_buffer);
  return read_register_value(38, readback_buffer);
}
// 45244: using guessed type _DWORD var_C[3];

//----- (00045288) --------------------------------------------------------
int __fastcall configure_and_read_register(unsigned __int16 register_value)
{
  int read_value; // [sp+4h] [bp-Ch] BYREF

  set_register_value(40, register_value);
  return read_register_value(40, &read_value);
}

//----- (000452B0) --------------------------------------------------------
int read_chip_id()
{
  int chip_id; // [sp+4h] [bp-Ch] BYREF

  read_register_value(7, &chip_id);
  return chip_id;
}

//----- (000452D0) --------------------------------------------------------
int __fastcall sub_452D0(int a1)
{
  int v2; // [sp+4h] [bp-Ch] BYREF

  set_register_value(7, a1);
  return read_register_value(7, &v2);
}

//----- (000452F8) --------------------------------------------------------
int enable_register_bit()
{
  int register_value[3]; // [sp+4h] [bp-Ch] BYREF

  read_register_value(7, register_value);
  set_register_value(7, register_value[0] | 0x10000);
  read_register_value(7, register_value);
  return 0;
}

//----- (00045334) --------------------------------------------------------
int __fastcall sendJobToMiner_0(int jobData)
{
  size_t v2; // r5
  unsigned int v3; // r7
  size_t v4; // r7
  _BYTE *v5; // r0
  _BYTE *v6; // r6
  _BYTE *v7; // r3
  char *v8; // r8
  char *v9; // r0
  char *v10; // r3
  int v11; // r6
  int v12; // r2
  char v13; // t1
  int v14; // r5
  size_t v15; // r7
  int v16; // r12
  int v17; // t1
  int v18; // lr
  int v19; // t1
  unsigned int v20; // r1
  size_t v21; // r2
  _DWORD *v22; // r3
  int v23; // lr
  int v24; // r12
  int v25; // r0
  int v26; // lr
  int v27; // r12
  int v28; // r0
  int v29; // r1
  int v30; // r1
  int v31; // r0
  int *v32; // r12
  int v33; // lr
  int v34; // r3
  int v35; // r3
  unsigned int v36; // r1
  int v37; // r7
  int v38; // r6
  _BOOL4 v39; // r3
  int v40; // r4
  int result; // r0
  int v42; // [sp+Ch] [bp-5Ch]
  void *ptr; // [sp+10h] [bp-58h]
  size_t v44; // [sp+14h] [bp-54h]
  int v45; // [sp+1Ch] [bp-4Ch] BYREF
  int v46[18]; // [sp+20h] [bp-48h] BYREF

  memset(v46, 0, 32u);
  v2 = *(_DWORD *)(jobData + 12);
  v42 = dword_50510C;
  v3 = v2 & 0xFFFFFFC0;
  if ( dword_50510C == dword_505110 )
    v42 = dword_505114;
  if ( (*(_DWORD *)(jobData + 12) & 0x3Fu) <= 55 )
    v4 = v3 + 64;
  else
    v4 = v3 + 128;
  v5 = calloc(v4, 1u);
  v6 = v5;
  ptr = v5;
  if ( !v5 )
    return -4;
  memcpy(v5, *(const void **)(jobData + 8), v2);
  v7 = &v6[v4];
  v6[v2] = -128;
  *((_DWORD *)v7 - 2) = 0;
  *((_DWORD *)v7 - 1) = bswap32(8 * v2);
  if ( v4 )
  {
    v8 = v6 - 1;
    v9 = &v6[v4 - 1];
    v10 = v6 - 1;
    v11 = v42 - 1;
    v12 = v42 - 1;
    do
    {
      v13 = *++v10;
      *(_BYTE *)++v12 = v13;
    }
    while ( v9 != v10 );
    v44 = v4;
    v14 = 0;
    v15 = v42 - 1 + v4;
    do
    {
      v17 = *(unsigned __int8 *)++v11;
      v16 = v17;
      v19 = (unsigned __int8)*++v8;
      v18 = v19;
      if ( v16 != v19 )
        printf(
          "%s: coinbase_padding_in_ddr[%d] = 0x%x, but *(coinbase_padding + %d) = 0x%x",
          "dhash_send_job",
          v14,
          v16,
          v14,
          v18);
      ++v14;
    }
    while ( v15 != v11 );
    v4 = v44;
  }
  if ( *(_DWORD *)(jobData + 20) )
  {
    v20 = 0;
    v21 = v42 + v4;
    do
    {
      v21 += 32;
      v22 = (_DWORD *)(*(_DWORD *)(jobData + 16) + 32 * v20++);
      v23 = v22[1];
      v24 = v22[2];
      v25 = v22[3];
      *(_DWORD *)(v21 - 32) = *v22;
      *(_DWORD *)(v21 - 28) = v23;
      *(_DWORD *)(v21 - 24) = v24;
      *(_DWORD *)(v21 - 20) = v25;
      v26 = v22[5];
      v27 = v22[6];
      v28 = v22[7];
      *(_DWORD *)(v21 - 16) = v22[4];
      *(_DWORD *)(v21 - 12) = v26;
      *(_DWORD *)(v21 - 8) = v27;
      *(_DWORD *)(v21 - 4) = v28;
    }
    while ( *(_DWORD *)(jobData + 20) > v20 );
  }
  disable_asic_boost_mode();
  if ( v42 == dword_50510C )
    v29 = dword_505118 + 2097152;
  else
    v29 = dword_505118 + 2162688;
  set_register_value(41, v29);
  read_register_value(41, &v45);
  set_register_value(44, *(_DWORD *)(jobData + 32));
  read_register_value(44, &v45);
  if ( *(_DWORD *)jobData )
    v30 = 1;
  else
    v30 = *(_DWORD *)(jobData + 4);
  configure_hashing_cores(*(_DWORD *)(jobData + 36), v30, *(_DWORD *)(jobData + 40));
  memset(v46, 0, 32u);
  v31 = *(_DWORD *)(jobData + 44);
  v32 = &v45;
  v33 = v31 + 32;
  do
  {
    v34 = *(unsigned __int8 *)(v31 + 2);
    v31 += 4;
    v32[1] = (v34 << 16) | (*(unsigned __int8 *)(v31 - 1) << 24) | *(unsigned __int8 *)(v31 - 4) | (*(unsigned __int8 *)(v31 - 3) << 8);
    ++v32;
  }
  while ( v31 != v33 );
  set_register_values_from_array((int)v46);
  set_register_value(46, *(_DWORD *)(jobData + 24));
  read_register_value(46, &v45);
  set_register_value(47, *(_DWORD *)(jobData + 28));
  read_register_value(47, &v45);
  set_register_value(
    36,
    (unsigned __int16)(*(_WORD *)(jobData + 56) << 8) | (*(_DWORD *)(jobData + 52) << 16) | (unsigned __int8)(v4 >> 6));
  read_register_value(36, &v45);
  v35 = *(_DWORD *)(jobData + 68);
  v46[0] = *(_DWORD *)(jobData + 64);
  v46[1] = v35;
  read_dual_registers(v46);
  configure_and_read_register(*(_DWORD *)(jobData + 20));
  set_register_value(42, (unsigned __int16)(v4 + 32 * *(_WORD *)(jobData + 20)));
  read_register_value(42, &v45);
  usleep(1000u);
  set_register_value(20, *(_DWORD *)(jobData + 72) & 0x1FFFF | 0x80000000);
  read_register_value(20, &v45);
  v36 = *(_DWORD *)(jobData + 4);
  v37 = *(_DWORD *)jobData;
  v38 = *(_DWORD *)(jobData + 76);
  v39 = v36 > 1;
  if ( *(_DWORD *)jobData )
    v39 = 0;
  if ( v39 )
  {
    v37 = 0;
    v40 = (v36 << 8) & 0xF00;
  }
  else
  {
    v40 = 256;
    if ( v37 )
      v37 = 16384;
  }
  if ( v38 )
  {
    v38 = 128;
    enable_register_bit();
  }
  v45 = 0;
  read_register_value(35, &v45);
  set_register_value(35, v45 & 0xFFFF709F | 0x8060 | v37 | v40 | v38);
  free(ptr);
  result = 0;
  dword_505110 = v42;
  return result;
}
// 50510C: using guessed type int dword_50510C;
// 505110: using guessed type int dword_505110;
// 505114: using guessed type int dword_505114;
// 505118: using guessed type int dword_505118;
// 45334: using guessed type int var_48[18];

//----- (00045734) --------------------------------------------------------
int __fastcall set_mining_frequency(char frequency)
{
  int frequency_masked; // r4
  int register_value; // [sp+4h] [bp-14h] BYREF

  frequency_masked = frequency & 0x3F;
  pthread_mutex_lock(&stru_50511C);
  usleep(50000u);
  read_register_value(27, &register_value);
  set_and_wait_for_register_value(register_value & 0xFFFFFFC0 | frequency_masked);
  return pthread_mutex_unlock(&stru_50511C);
}

//----- (00045788) --------------------------------------------------------
int __fastcall set_frequency_modifier(int frequency_modifier, int enable_fan)
{
  int modified_value; // r0
  int current_value; // [sp+4h] [bp-14h] BYREF

  pthread_mutex_lock(&stru_50511C);
  read_register_value(27, &current_value);
  if ( enable_fan )
    modified_value = current_value & 0xFFF0FFFF | (frequency_modifier << 16) | 0xC00000;
  else
    modified_value = current_value & 0xFFB0FFFF | (frequency_modifier << 16) & 0xFFBFFFFF;
  if ( !enable_fan )
    modified_value |= 8388608u;
  set_and_wait_for_register_value(modified_value);
  return pthread_mutex_unlock(&stru_50511C);
}

//----- (000457E0) --------------------------------------------------------
int __fastcall configure_machine_state(int *register_values, int status_code)
{
  int response_buffer[5]; // [sp+4h] [bp-14h] BYREF

  pthread_mutex_lock(&stru_50511C);
  set_register_value(28, *register_values);
  set_register_value(29, register_values[1]);
  set_register_value(30, register_values[2]);
  read_register_value(28, response_buffer);
  read_register_value(29, response_buffer);
  read_register_value(30, response_buffer);
  read_register_value(27, response_buffer);
  set_and_wait_for_register_value(response_buffer[0] & 0x7F70FFFF | 0x80800000 | (status_code << 16));
  return pthread_mutex_unlock(&stru_50511C);
}

//----- (0004587C) --------------------------------------------------------
int __fastcall set_registers_from_buffer(int *buffer, unsigned int buffer_size)
{
  unsigned int num_registers; // r5
  int *buffer_end; // r5
  int register_index; // r0
  int register_value; // t1

  pthread_mutex_lock(&stru_505134);
  num_registers = buffer_size >> 2;
  if ( num_registers )
  {
    buffer_end = &buffer[num_registers];
    register_index = 16;
    do
    {
      register_value = *buffer++;
      set_register_value(register_index, register_value);
      register_index = 17;
    }
    while ( buffer != buffer_end );
  }
  return pthread_mutex_unlock(&stru_505134);
}

//----- (000458C4) --------------------------------------------------------
int read_chip_register_value()
{
  int register_value; // [sp+4h] [bp-Ch] BYREF

  read_register_value(18, &register_value);
  return register_value;
}

//----- (000458E4) --------------------------------------------------------
int __fastcall set_control_register_and_reboot(int control_value)
{
  set_register_value(18, control_value | 0x80808000);
  dword_505110 = dword_50510C;
  return update_register_39(dword_505118);
}
// 50510C: using guessed type int dword_50510C;
// 505110: using guessed type int dword_505110;
// 505118: using guessed type int dword_505118;

//----- (00045918) --------------------------------------------------------
int read_antminer_version()
{
  int antminer_version; // [sp+4h] [bp-Ch] BYREF

  antminer_version = 0;
  read_register_value(15, &antminer_version);
  return antminer_version;
}

//----- (00045940) --------------------------------------------------------
int __fastcall set_chip_status_register(int status_value)
{
  return set_register_value(15, status_value);
}

//----- (0004594C) --------------------------------------------------------
int __fastcall enable_miner_chip(char chip_index)
{
  int current_register_value; // [sp+4h] [bp-Ch] BYREF

  current_register_value = 0;
  read_register_value(13, &current_register_value);
  return set_register_value(13, current_register_value | (1 << chip_index));
}

//----- (00045990) --------------------------------------------------------
int __fastcall disable_bit_in_register(char bit_position)
{
  int current_register_value; // [sp+4h] [bp-Ch] BYREF

  current_register_value = 0;
  read_register_value(13, &current_register_value);
  return set_register_value(13, current_register_value & ~(1 << bit_position));
}

//----- (000459D4) --------------------------------------------------------
int __fastcall initialize_miner_chip(char chip_id)
{
  enable_miner_chip(chip_id);
  usleep(100000u);
  return disable_bit_in_register(chip_id);
}

//----- (000459F8) --------------------------------------------------------
int sleep_for_100_milliseconds()
{
  return usleep(100000u);
}

//----- (00045A0C) --------------------------------------------------------
unsigned int get_top_bit_of_register()
{
  unsigned int register_value; // [sp+4h] [bp-Ch] BYREF

  register_value = 0;
  read_register_value(0, &register_value);
  return register_value >> 31;
}

//----- (00045ACC) --------------------------------------------------------
int disable_watchdog_timer()
{
  int watchdog_register_value; // [sp+4h] [bp-Ch] BYREF

  watchdog_register_value = 0;
  read_register_value(0, &watchdog_register_value);
  set_register_value(0, watchdog_register_value & 0xDFFFFFFF);
  return 0;
}

//----- (00045B0C) --------------------------------------------------------
unsigned int get_asictemperature_shutdown_status()
{
  unsigned int temperature_shutdown_bitfield; // [sp+4h] [bp-Ch] BYREF

  temperature_shutdown_bitfield = 0;
  read_register_value(0, &temperature_shutdown_bitfield);
  return (temperature_shutdown_bitfield >> 29) & 1;
}

//----- (00045B34) --------------------------------------------------------
int initialize_asic_miner()
{
  int register_value; // [sp+4h] [bp-Ch] BYREF

  register_value = 0;
  read_register_value(0, &register_value);
  set_register_value(0, register_value | 0x40000000);
  return 0;
}

//----- (00045B74) --------------------------------------------------------
int initialize_miner_configuration()
{
  int fpga_init_status; // r0
  int memory_offset; // r5
  int asic_memory_value; // r0
  int default_memory_setting; // r3
  int register_value; // [sp+4h] [bp-54h] BYREF
  struct sysinfo system_info; // [sp+8h] [bp-50h] BYREF

  fpga_init_status = check_fpga_initialized();
  memory_offset = fpga_init_status + 2097152;
  dword_505108 = fpga_init_status;
  dword_50510C = fpga_init_status + 2097152;
  dword_505114 = fpga_init_status + 2162688;
  asic_memory_value = sysinfo(&system_info);
  if ( system_info.totalram <= 1000000000 )
  {
    if ( system_info.totalram <= 500000000 )
    {
      default_memory_setting = 200000000;
      if ( system_info.totalram > 200000000 )
        asic_memory_value = 251658240;
      else
        default_memory_setting = 117440512;
      if ( system_info.totalram > 200000000 )
        dword_505118 = asic_memory_value;
      else
        asic_memory_value = default_memory_setting;
      if ( system_info.totalram <= 200000000 )
        dword_505118 = default_memory_setting;
    }
    else
    {
      asic_memory_value = 520093696;
      dword_505118 = 520093696;
    }
  }
  else
  {
    asic_memory_value = 1056964608;
    dword_505118 = 1056964608;
  }
  dword_505110 = memory_offset;
  update_register_39(asic_memory_value);
  set_register_value(41, dword_505118 + 2097152);
  read_register_value(41, &register_value);
  disable_watchdog_timer();
  initialize_asic_miner();
  return 0;
}
// 505108: using guessed type int dword_505108;
// 50510C: using guessed type int dword_50510C;
// 505110: using guessed type int dword_505110;
// 505114: using guessed type int dword_505114;
// 505118: using guessed type int dword_505118;

//----- (00045C70) --------------------------------------------------------
unsigned int get_chip_status()
{
  unsigned int status_register_value; // [sp+4h] [bp-Ch] BYREF

  status_register_value = 0;
  read_register_value(0, &status_register_value);
  return (status_register_value >> 30) & 1;
}

//----- (00045C98) --------------------------------------------------------
int read_control_register_value()
{
  int control_register_value; // [sp+4h] [bp-Ch] BYREF

  control_register_value = 0;
  read_register_value(0, &control_register_value);
  return control_register_value;
}

//----- (00045CBC) --------------------------------------------------------
int __fastcall update_register_with_masked_value(int masking_option, int input_value)
{
  char masked_input; // r5
  int updated_register_value; // r1
  int current_register_value; // [sp+4h] [bp-14h] BYREF

  masked_input = get_baud_rate_code(input_value);
  current_register_value = 0;
  read_register_value(15, &current_register_value);
  updated_register_value = current_register_value;
  if ( masking_option )
  {
    switch ( masking_option )
    {
      case 1:
        updated_register_value = current_register_value & 0xFFFFC0FF | ((masked_input & 0x3F) << 8);
        break;
      case 2:
        updated_register_value = current_register_value & 0xFFC0FFFF | ((masked_input & 0x3F) << 16);
        break;
      case 3:
        updated_register_value = current_register_value & 0xC0FFFFFF | ((masked_input & 0x3F) << 24);
        break;
    }
  }
  else
  {
    updated_register_value = current_register_value & 0xFFFFFFC0 | masked_input & 0x3F;
  }
  set_register_value(15, updated_register_value);
  return 0;
}

//----- (00045E80) --------------------------------------------------------
int __fastcall log_bad_pic_param(int input_chain)
{
  char log_message_buffer[2056]; // [sp+8h] [bp-808h] BYREF

  snprintf(log_message_buffer, 2048u, "%s: Bad pic param, input chain is %d\n", "open_pic", input_chain);
  logMessage(0, log_message_buffer, 0);
  return -2147483135;
}

//----- (00045ED0) --------------------------------------------------------
int __fastcall dump_memory_contents(unsigned __int8 *memory_address, unsigned int data_length)
{
  unsigned int byte_index; // r4
  int current_byte; // r3
  unsigned int print_index; // r4
  int printable_char; // r3
  char output_buffer[4]; // [sp+8h] [bp-818h] BYREF

  snprintf(output_buffer, 2048u, "Dumping %u %s bytes from %p:\n", data_length, "read return data", memory_address);
  byte_index = 0;
  logMessage(2, output_buffer, 0);
  do
  {
    while ( data_length > byte_index )
    {
      current_byte = memory_address[byte_index++];
      snprintf(output_buffer, 2048u, "%02x ", current_byte);
      logMessage(2, output_buffer, 0);
      if ( byte_index == 16 )
        goto LABEL_5;
    }
    ++byte_index;
    *(_DWORD *)output_buffer = &unk_202020;
    logMessage(2, output_buffer, 0);
  }
  while ( byte_index != 16 );
LABEL_5:
  print_index = 0;
  do
  {
    while ( data_length <= print_index )
    {
      ++print_index;
      strcpy(output_buffer, " ");
      logMessage(2, output_buffer, 0);
      if ( print_index == 16 )
        goto LABEL_11;
    }
    printable_char = memory_address[print_index++];
    if ( (unsigned int)(printable_char - 32) > 94 )
      printable_char = 46;
    snprintf(output_buffer, 2048u, "%c", printable_char);
    logMessage(2, output_buffer, 0);
  }
  while ( print_index != 16 );
LABEL_11:
  strcpy(output_buffer, "\n");
  return logMessage(2, output_buffer, 0);
}

//----- (00046024) --------------------------------------------------------
int __fastcall sub_46024(unsigned int a1)
{
  int v2; // r6
  unsigned int v4; // [sp+0h] [bp-18h] BYREF
  __int16 v5; // [sp+4h] [bp-14h]
  char v6; // [sp+6h] [bp-12h]
  char v7; // [sp+7h] [bp-11h]

  if ( a1 > 15 )
    return log_bad_pic_param(a1);
  v2 = dword_99EE48[2 * a1];
  if ( !v2 || !dword_99EE48[2 * a1 + 1] )
  {
    v5 = 0;
    v6 = 4;
    v4 = a1;
    v7 = a1;
    pthread_mutex_lock(&stru_50514C);
    v2 = initiateI2CTransfer((int)&v4);
    pthread_mutex_unlock(&stru_50514C);
    if ( v2 >= 0 )
    {
      dword_99EE48[2 * a1] = v2;
      dword_99EE48[2 * a1 + 1] = 1;
    }
  }
  return v2;
}
// 50514C: using guessed type pthread_mutex_t stru_50514C;
// 99EE48: using guessed type _DWORD dword_99EE48[32];

//----- (000460C4) --------------------------------------------------------
unsigned int __fastcall close_pic_handler(unsigned int chain_index)
{
  unsigned int validated_chain_index; // r5
  unsigned int pic_index_offset; // r6
  char error_message[2064]; // [sp+8h] [bp-810h] BYREF

  validated_chain_index = chain_index;
  if ( chain_index > 15 )
  {
    snprintf(error_message, 2048u, "%s: Bad pic param, input chain is %d\n", "close_pic", chain_index);
    return logMessage(0, error_message, 0);
  }
  else
  {
    pic_index_offset = 2 * chain_index;
    if ( dword_99EE48[2 * chain_index] || dword_99EE48[pic_index_offset + 1] )
    {
      pthread_mutex_lock(&stru_50514C);
      attempt_i2c_operation(dword_99EE48[2 * validated_chain_index]);
      dword_99EE48[pic_index_offset + 1] = 0;
      return pthread_mutex_unlock(&stru_50514C);
    }
  }
  return chain_index;
}
// 50514C: using guessed type pthread_mutex_t stru_50514C;
// 99EE48: using guessed type _DWORD dword_99EE48[32];

//----- (00046178) --------------------------------------------------------
int __fastcall sub_46178(unsigned int a1)
{
  int v2; // r5
  int i2c_bus_handle; // r4
  unsigned int v4; // r3
  int v6; // [sp+8h] [bp-830h] BYREF
  unsigned __int8 v7; // [sp+Ch] [bp-82Ch]
  int v8[4]; // [sp+10h] [bp-828h] BYREF
  char s[2072]; // [sp+20h] [bp-818h] BYREF

  if ( a1 > 15 )
  {
    snprintf(s, 2048u, "%s: Bad pic param, input chain is %d\n", "get_pic_version", a1);
    i2c_bus_handle = -2147483135;
    logMessage(0, s, 0);
    return i2c_bus_handle;
  }
  if ( !dword_99EE48[2 * a1 + 1] )
  {
    i2c_bus_handle = get_i2c_bus_handle(a1);
    if ( i2c_bus_handle < 0 )
    {
      snprintf(s, 2048u, "%s: auto exec open_pic, but chain %d open eeprom failed\n", "get_pic_version", a1);
      logMessage(0, s, 0);
      return i2c_bus_handle;
    }
  }
  v2 = dword_99EE48[2 * a1];
  pthread_mutex_lock(&stru_50514C);
  v8[1] = 6912;
  v8[0] = 386181717;
  v8[2] = 0;
  v8[3] = 0;
  v6 = 0;
  v7 = 0;
  if ( i2c_transfer_with_lock(v2, (int)v8, 6) != 6 )
  {
    snprintf(s, 2048u, "%s write iic err\n", "_bitmain_pic_get_sw_ver_common");
LABEL_15:
    logMessage(0, s, 0);
    goto LABEL_16;
  }
  usleep(300000u);
  if ( i2c_write_with_mutex(v2, &v6, 5) != 5 )
  {
    snprintf(s, 2048u, "%s read iic err\n", "_bitmain_pic_get_sw_ver_common");
    goto LABEL_15;
  }
  if ( BYTE1(v6) == 23 && (unsigned __int8)v6 == 5 )
  {
    i2c_bus_handle = BYTE2(v6);
    v4 = BYTE2(v6) + 28;
    if ( HIBYTE(v6) == v4 >> 8 && v7 == (unsigned __int8)v4 )
      goto LABEL_10;
    snprintf(s, 2048u, "%s failed 2!\n", "_bitmain_pic_get_sw_ver_common");
  }
  else
  {
    snprintf(s, 2048u, "%s failed!\n", "_bitmain_pic_get_sw_ver_common");
  }
  logMessage(0, s, 0);
  dump_memory_contents((unsigned __int8 *)&v6, 5u);
LABEL_16:
  i2c_bus_handle = -2147483136;
LABEL_10:
  pthread_mutex_unlock(&stru_50514C);
  return i2c_bus_handle;
}
// 50514C: using guessed type pthread_mutex_t stru_50514C;
// 99EE48: using guessed type _DWORD dword_99EE48[32];

//----- (0004637C) --------------------------------------------------------
int __fastcall reset_pic(unsigned int input_chain)
{
  int i2c_bus_handle; // r6
  int result_code; // r4
  __int16 i2c_status; // [sp+Ch] [bp-82Ch] BYREF
  int i2c_data_buffer[4]; // [sp+10h] [bp-828h] BYREF
  char log_buffer[2072]; // [sp+20h] [bp-818h] BYREF

  if ( input_chain > 15 )
  {
    snprintf(log_buffer, 2048u, "%s: Bad pic param, input chain is %d\n", "reset_pic", input_chain);
    result_code = -2147483135;
    logMessage(0, log_buffer, 0);
    return result_code;
  }
  if ( !dword_99EE48[2 * input_chain + 1] )
  {
    result_code = get_i2c_bus_handle(input_chain);
    if ( result_code < 0 )
    {
      snprintf(log_buffer, 2048u, "%s: auto exec open_pic, but chain %d open eeprom failed\n", "reset_pic", input_chain);
      logMessage(0, log_buffer, 0);
      return result_code;
    }
  }
  i2c_bus_handle = dword_99EE48[2 * input_chain];
  result_code = 0;
  pthread_mutex_lock(&stru_50514C);
  i2c_data_buffer[1] = 2816;
  i2c_data_buffer[0] = 117746261;
  i2c_data_buffer[2] = 0;
  i2c_data_buffer[3] = 0;
  i2c_status = 0;
  if ( i2c_transfer_with_lock(i2c_bus_handle, (int)i2c_data_buffer, 6) != 6 )
  {
    snprintf(log_buffer, 2048u, "%s write iic err\n", "_bitmain_pic_reset_common");
LABEL_13:
    logMessage(0, log_buffer, 0);
    goto LABEL_14;
  }
  usleep(300000u);
  if ( i2c_write_with_mutex(i2c_bus_handle, &i2c_status, 2) != 2 )
  {
    snprintf(log_buffer, 2048u, "%s read iic err\n", "_bitmain_pic_reset_common");
    goto LABEL_13;
  }
  if ( (unsigned __int8)i2c_status == 7 && HIBYTE(i2c_status) == 1 )
    goto LABEL_8;
  snprintf(
    log_buffer,
    2048u,
    "%s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
    "_bitmain_pic_reset_common",
    (unsigned __int8)i2c_status,
    HIBYTE(i2c_status));
  logMessage(0, log_buffer, 0);
LABEL_14:
  result_code = -2147483136;
LABEL_8:
  pthread_mutex_unlock(&stru_50514C);
  usleep(500000u);
  return result_code;
}
// 50514C: using guessed type pthread_mutex_t stru_50514C;
// 99EE48: using guessed type _DWORD dword_99EE48[32];

//----- (00046554) --------------------------------------------------------
int __fastcall start_app_on_chain(unsigned int chain_index)
{
  int i2c_bus_handle; // r6
  int v3; // r4
  __int16 read_back_data; // [sp+Ch] [bp-82Ch] BYREF
  int i2c_transaction_data[4]; // [sp+10h] [bp-828h] BYREF
  char error_message_buffer[2072]; // [sp+20h] [bp-818h] BYREF

  if ( chain_index > 15 )
  {
    snprintf(
      error_message_buffer,
      2048u,
      "%s: Bad pic param, input chain is %d\n",
      "jump_from_loader_to_app",
      chain_index);
    v3 = -2147483135;
    logMessage(0, error_message_buffer, 0);
    return v3;
  }
  if ( !dword_99EE48[2 * chain_index + 1] )
  {
    v3 = get_i2c_bus_handle(chain_index);
    if ( v3 < 0 )
    {
      snprintf(
        error_message_buffer,
        2048u,
        "%s: auto exec open_pic, but chain %d open eeprom failed\n",
        "jump_from_loader_to_app",
        chain_index);
      logMessage(0, error_message_buffer, 0);
      return v3;
    }
  }
  i2c_bus_handle = dword_99EE48[2 * chain_index];
  v3 = 0;
  pthread_mutex_lock(&stru_50514C);
  i2c_transaction_data[1] = 2560;
  i2c_transaction_data[0] = 100969045;
  i2c_transaction_data[2] = 0;
  i2c_transaction_data[3] = 0;
  read_back_data = 0;
  if ( i2c_transfer_with_lock(i2c_bus_handle, (int)i2c_transaction_data, 6) != 6 )
  {
    snprintf(error_message_buffer, 2048u, "%s write iic err\n", "_bitmain_pic_start_app_common");
LABEL_13:
    logMessage(0, error_message_buffer, 0);
    goto LABEL_14;
  }
  usleep(300000u);
  if ( i2c_write_with_mutex(i2c_bus_handle, &read_back_data, 2) != 2 )
  {
    snprintf(error_message_buffer, 2048u, "%s read iic err\n", "_bitmain_pic_start_app_common");
    goto LABEL_13;
  }
  usleep(300000u);
  if ( (unsigned __int8)read_back_data == 6 && HIBYTE(read_back_data) == 1 )
    goto LABEL_8;
  snprintf(
    error_message_buffer,
    2048u,
    "%s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
    "_bitmain_pic_start_app_common",
    (unsigned __int8)read_back_data,
    HIBYTE(read_back_data));
  logMessage(0, error_message_buffer, 0);
LABEL_14:
  v3 = -2147483136;
LABEL_8:
  pthread_mutex_unlock(&stru_50514C);
  return v3;
}
// 50514C: using guessed type pthread_mutex_t stru_50514C;
// 99EE48: using guessed type _DWORD dword_99EE48[32];

//----- (0004672C) --------------------------------------------------------
int __fastcall enable_dc_dc_for_chain(unsigned int chain_index)
{
  int i2c_bus_handle; // r6
  int v3; // r4
  __int16 read_back_data; // [sp+Ch] [bp-82Ch] BYREF
  int i2c_write_data[4]; // [sp+10h] [bp-828h] BYREF
  char log_message_buffer[2072]; // [sp+20h] [bp-818h] BYREF

  if ( chain_index > 15 )
  {
    snprintf(log_message_buffer, 2048u, "%s: Bad pic param, input chain is %d\n", "enable_dc_dc", chain_index);
    v3 = -2147483135;
    logMessage(0, log_message_buffer, 0);
    return v3;
  }
  if ( !dword_99EE48[2 * chain_index + 1] )
  {
    v3 = get_i2c_bus_handle(chain_index);
    if ( v3 < 0 )
    {
      snprintf(
        log_message_buffer,
        2048u,
        "%s: auto exec open_pic, but chain %d open eeprom failed\n",
        "enable_dc_dc",
        chain_index);
      logMessage(0, log_message_buffer, 0);
      return v3;
    }
  }
  i2c_bus_handle = dword_99EE48[2 * chain_index];
  v3 = 0;
  pthread_mutex_lock(&stru_50514C);
  i2c_write_data[1] = 1769473;
  i2c_write_data[0] = 352692821;
  i2c_write_data[2] = 0;
  i2c_write_data[3] = 0;
  read_back_data = 0;
  if ( i2c_transfer_with_lock(i2c_bus_handle, (int)i2c_write_data, 7) != 7 )
  {
    snprintf(log_message_buffer, 2048u, "%s write iic err\n", "_bitmain_pic_enable_dc_dc_common");
LABEL_13:
    logMessage(0, log_message_buffer, 0);
    goto LABEL_14;
  }
  usleep(300000u);
  if ( i2c_write_with_mutex(i2c_bus_handle, &read_back_data, 2) != 2 )
  {
    snprintf(log_message_buffer, 2048u, "%s read iic err\n", "_bitmain_pic_enable_dc_dc_common");
    goto LABEL_13;
  }
  if ( (unsigned __int8)read_back_data == 21 && HIBYTE(read_back_data) == 1 )
    goto LABEL_8;
  snprintf(
    log_message_buffer,
    2048u,
    "%s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
    "_bitmain_pic_enable_dc_dc_common",
    (unsigned __int8)read_back_data,
    HIBYTE(read_back_data));
  logMessage(0, log_message_buffer, 0);
LABEL_14:
  v3 = -2147483136;
LABEL_8:
  pthread_mutex_unlock(&stru_50514C);
  return v3;
}
// 50514C: using guessed type pthread_mutex_t stru_50514C;
// 99EE48: using guessed type _DWORD dword_99EE48[32];

//----- (00046900) --------------------------------------------------------
int __fastcall disable_dc_dc_for_chain(unsigned int chain_index)
{
  int i2c_bus_handle; // r6
  int v3; // r4
  __int16 read_back_data; // [sp+Ch] [bp-82Ch] BYREF
  int i2c_transfer_data[4]; // [sp+10h] [bp-828h] BYREF
  char log_buffer[2072]; // [sp+20h] [bp-818h] BYREF

  if ( chain_index > 15 )
  {
    snprintf(log_buffer, 2048u, "%s: Bad pic param, input chain is %d\n", "disable_dc_dc", chain_index);
    v3 = -2147483135;
    logMessage(0, log_buffer, 0);
    return v3;
  }
  if ( !dword_99EE48[2 * chain_index + 1] )
  {
    v3 = get_i2c_bus_handle(chain_index);
    if ( v3 < 0 )
    {
      snprintf(
        log_buffer,
        2048u,
        "%s: auto exec open_pic, but chain %d open eeprom failed\n",
        "disable_dc_dc",
        chain_index);
      logMessage(0, log_buffer, 0);
      return v3;
    }
  }
  i2c_bus_handle = dword_99EE48[2 * chain_index];
  v3 = 0;
  pthread_mutex_lock(&stru_50514C);
  i2c_transfer_data[1] = 1703936;
  i2c_transfer_data[0] = 352692821;
  i2c_transfer_data[2] = 0;
  i2c_transfer_data[3] = 0;
  read_back_data = 0;
  if ( i2c_transfer_with_lock(i2c_bus_handle, (int)i2c_transfer_data, 7) != 7 )
  {
    snprintf(log_buffer, 2048u, "%s write iic err\n", "_bitmain_pic_disable_dc_dc_common");
LABEL_13:
    logMessage(0, log_buffer, 0);
    goto LABEL_14;
  }
  usleep(300000u);
  if ( i2c_write_with_mutex(i2c_bus_handle, &read_back_data, 2) != 2 )
  {
    snprintf(log_buffer, 2048u, "%s read iic err\n", "_bitmain_pic_disable_dc_dc_common");
    goto LABEL_13;
  }
  if ( (unsigned __int8)read_back_data == 21 && HIBYTE(read_back_data) == 1 )
    goto LABEL_8;
  snprintf(
    log_buffer,
    2048u,
    "%s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
    "_bitmain_pic_disable_dc_dc_common",
    (unsigned __int8)read_back_data,
    HIBYTE(read_back_data));
  logMessage(0, log_buffer, 0);
LABEL_14:
  v3 = -2147483136;
LABEL_8:
  pthread_mutex_unlock(&stru_50514C);
  return v3;
}
// 50514C: using guessed type pthread_mutex_t stru_50514C;
// 99EE48: using guessed type _DWORD dword_99EE48[32];

//----- (00046ACC) --------------------------------------------------------
int __fastcall send_pic_heartbeat(unsigned int chain_index)
{
  int i2c_bus_handler; // r5
  int i2c_bus_handle; // r4
  int i2c_data_buffer; // [sp+8h] [bp-830h] BYREF
  __int16 heartbeat_sequence_id; // [sp+Ch] [bp-82Ch]
  int i2c_command[4]; // [sp+10h] [bp-828h] BYREF
  char log_buffer[2072]; // [sp+20h] [bp-818h] BYREF

  if ( chain_index > 15 )
  {
    snprintf(log_buffer, 2048u, "%s: Bad pic param, input chain is %d\n", "send_pic_heart_beat", chain_index);
    i2c_bus_handle = -2147483135;
    logMessage(0, log_buffer, 0);
    return i2c_bus_handle;
  }
  if ( !dword_99EE48[2 * chain_index + 1] )
  {
    i2c_bus_handle = get_i2c_bus_handle(chain_index);
    if ( i2c_bus_handle < 0 )
    {
      snprintf(
        log_buffer,
        2048u,
        "%s: auto exec open_pic, but chain %d open eeprom failed\n",
        "send_pic_heart_beat",
        chain_index);
      logMessage(0, log_buffer, 0);
      return i2c_bus_handle;
    }
  }
  i2c_bus_handler = dword_99EE48[2 * chain_index];
  i2c_bus_handle = 0;
  pthread_mutex_lock(&stru_50514C);
  i2c_command[1] = 6656;
  i2c_command[0] = 369404501;
  i2c_command[2] = 0;
  i2c_command[3] = 0;
  i2c_data_buffer = 0;
  heartbeat_sequence_id = 0;
  if ( i2c_transfer_with_lock(i2c_bus_handler, (int)i2c_command, 6) != 6 )
  {
    snprintf(log_buffer, 2048u, "%s write iic err\n", "_bitmain_pic_heart_beat_common");
LABEL_13:
    logMessage(0, log_buffer, 0);
    goto LABEL_14;
  }
  usleep(300000u);
  if ( i2c_write_with_mutex(i2c_bus_handler, &i2c_data_buffer, 6) != 6 )
  {
    snprintf(log_buffer, 2048u, "%s read iic err\n", "_bitmain_pic_heart_beat_common");
    goto LABEL_13;
  }
  if ( BYTE1(i2c_data_buffer) == 22 && BYTE2(i2c_data_buffer) == 1 )
    goto LABEL_8;
  snprintf(log_buffer, 2048u, "%s failed!\n", "_bitmain_pic_heart_beat_common");
  logMessage(0, log_buffer, 0);
  dump_memory_contents((unsigned __int8 *)&i2c_data_buffer, 6u);
LABEL_14:
  i2c_bus_handle = -2147483136;
LABEL_8:
  pthread_mutex_unlock(&stru_50514C);
  return i2c_bus_handle;
}
// 50514C: using guessed type pthread_mutex_t stru_50514C;
// 99EE48: using guessed type _DWORD dword_99EE48[32];

//----- (00046CA0) --------------------------------------------------------
int __fastcall write_pic_i2c_data(
        int i2c_device_address,
        __int16 command,
        __int16 data_length,
        int data_buffer,
        int data_count)
{
  int data_position; // lr
  __int16 checksum_start; // r12
  int v11; // r4
  int data_index; // r0
  __int16 checksum; // r12
  __int16 current_data_byte; // r3
  int expected_transfer_length; // r6
  int low_checksum_byte_index; // lr
  int transfer_length; // r2
  int high_checksum_byte_index; // r1
  const char *error_message_format; // r2
  __int16 read_back_data; // [sp+Ch] [bp-834h] BYREF
  __int16 i2c_data_buffer; // [sp+10h] [bp-830h] BYREF
  char total_data_with_command_length; // [sp+12h] [bp-82Eh]
  char i2c_start_command; // [sp+13h] [bp-82Dh]
  char i2c_command; // [sp+14h] [bp-82Ch]
  char i2c_data_length; // [sp+15h] [bp-82Bh]
  int pad_byte_1; // [sp+16h] [bp-82Ah]
  int pad_byte_2; // [sp+1Ah] [bp-826h]
  int pad_byte_3; // [sp+1Eh] [bp-822h]
  int pad_byte_4; // [sp+22h] [bp-81Eh]
  __int16 pad_byte_5; // [sp+26h] [bp-81Ah]
  char log_buffer[2040]; // [sp+28h] [bp-818h] BYREF

  pthread_mutex_lock(&stru_50514C);
  checksum_start = data_length + 59 + command;
  i2c_command = command;
  if ( data_count >= 16 )
    v11 = 16;
  else
    v11 = data_count;
  data_index = 0;
  checksum = checksum_start + (unsigned __int8)(data_count + 6);
  total_data_with_command_length = data_count + 6;
  i2c_data_length = data_length;
  i2c_data_buffer = -21931;
  if ( data_count > 0 )
    data_position = 6;
  pad_byte_2 = 0;
  pad_byte_3 = 0;
  pad_byte_4 = 0;
  pad_byte_5 = 0;
  pad_byte_1 = 0;
  read_back_data = 0;
  i2c_start_command = 59;
  if ( data_count > 0 )
  {
    while ( 1 )
    {
      current_data_byte = *(unsigned __int8 *)(data_buffer + data_index);
      data_index = (unsigned __int16)(data_index + 1);
      *((_BYTE *)&i2c_data_buffer + data_position) = current_data_byte;
      checksum += current_data_byte;
      high_checksum_byte_index = (unsigned __int16)(data_position + 1);
      if ( data_index >= v11 )
        break;
      data_position = (unsigned __int16)(data_position + 1);
    }
    transfer_length = (unsigned __int16)(data_position + 3);
    low_checksum_byte_index = (unsigned __int16)(data_position + 2);
    expected_transfer_length = transfer_length;
  }
  else
  {
    expected_transfer_length = 8;
    low_checksum_byte_index = 7;
    transfer_length = 8;
    high_checksum_byte_index = 6;
  }
  *((_BYTE *)&i2c_data_buffer + high_checksum_byte_index) = HIBYTE(checksum);
  *((_BYTE *)&i2c_data_buffer + low_checksum_byte_index) = checksum;
  if ( i2c_transfer_with_lock(i2c_device_address, (int)&i2c_data_buffer, transfer_length) != expected_transfer_length )
  {
    error_message_format = "%s write iic err\n";
LABEL_18:
    v11 = -2147483136;
    snprintf(log_buffer, 2048u, error_message_format, "_pic_write_iic");
    logMessage(0, log_buffer, 0);
    goto LABEL_15;
  }
  usleep(10000u);
  if ( i2c_write_with_mutex(i2c_device_address, &read_back_data, 2) != 2 )
  {
    error_message_format = "%s read iic err\n";
    goto LABEL_18;
  }
  if ( (unsigned __int8)read_back_data != 59 || HIBYTE(read_back_data) != 1 )
  {
    snprintf(
      log_buffer,
      2048u,
      "%s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "_pic_write_iic",
      (unsigned __int8)read_back_data,
      HIBYTE(read_back_data));
    v11 = -2147483136;
    logMessage(0, log_buffer, 0);
  }
LABEL_15:
  pthread_mutex_unlock(&stru_50514C);
  return v11;
}
// 46D58: variable 'data_position' is possibly undefined
// 50514C: using guessed type pthread_mutex_t stru_50514C;

//----- (00046EB4) --------------------------------------------------------
int __fastcall sub_46EB4(int a1)
{
  int v2; // r5
  __int16 v4; // [sp+Ch] [bp-824h] BYREF
  int v5[4]; // [sp+10h] [bp-820h] BYREF
  char s[2064]; // [sp+20h] [bp-810h] BYREF

  pthread_mutex_lock(&stru_50514C);
  v5[1] = 218103814;
  v5[3] = 0;
  v5[2] = 0;
  v5[0] = 17214037;
  v4 = 0;
  if ( i2c_transfer_with_lock(a1, (int)v5, 8) != 8 )
  {
    snprintf(s, 2048u, "%s write iic err\n", "_bitmain_pic_seek_1704");
LABEL_10:
    v2 = -2147483136;
    logMessage(0, s, 0);
    goto LABEL_8;
  }
  usleep(300000u);
  if ( i2c_write_with_mutex(a1, &v4, 2) != 2 )
  {
    snprintf(s, 2048u, "%s read iic err\n", "_bitmain_pic_seek_1704");
    goto LABEL_10;
  }
  if ( (unsigned __int8)v4 == 1 && HIBYTE(v4) == 1 )
  {
    v2 = 0;
  }
  else
  {
    v2 = -2147483136;
    snprintf(
      s,
      2048u,
      "%s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "_bitmain_pic_seek_1704",
      (unsigned __int8)v4,
      HIBYTE(v4));
    logMessage(0, s, 0);
  }
LABEL_8:
  pthread_mutex_unlock(&stru_50514C);
  return v2;
}
// 50514C: using guessed type pthread_mutex_t stru_50514C;

//----- (00046FE8) --------------------------------------------------------
int __fastcall dump_memory_data(unsigned __int8 *memory_ptr, int data_length)
{
  int remaining_bytes; // r5
  unsigned __int8 *current_pointer; // r6
  int log_result; // r0
  unsigned int byte_index; // r4
  int byte_value; // r3
  unsigned int char_index; // r4
  int char_value; // r3
  char output_buffer[4]; // [sp+8h] [bp-820h] BYREF

  remaining_bytes = data_length;
  current_pointer = memory_ptr;
  snprintf(output_buffer, 2048u, "Dumping %u %s bytes from %p:\n", data_length, "read return data", memory_ptr);
  log_result = logMessage(2, output_buffer, 0);
  if ( remaining_bytes > 0 )
  {
    while ( 1 )
    {
      for ( byte_index = 0; byte_index != 16; ++byte_index )
      {
        while ( remaining_bytes > byte_index )
        {
          byte_value = current_pointer[byte_index++];
          snprintf(output_buffer, 2048u, "%02x ", byte_value);
          logMessage(2, output_buffer, 0);
          if ( byte_index == 16 )
            goto LABEL_6;
        }
        *(_DWORD *)output_buffer = &unk_202020;
        logMessage(2, output_buffer, 0);
      }
LABEL_6:
      char_index = 0;
      do
      {
        while ( remaining_bytes <= char_index )
        {
          ++char_index;
          strcpy(output_buffer, " ");
          logMessage(2, output_buffer, 0);
          if ( char_index == 16 )
            goto LABEL_12;
        }
        char_value = current_pointer[char_index++];
        if ( (unsigned int)(char_value - 32) > 94 )
          char_value = 46;
        snprintf(output_buffer, 2048u, "%c", char_value);
        logMessage(2, output_buffer, 0);
      }
      while ( char_index != 16 );
LABEL_12:
      strcpy(output_buffer, "\n");
      current_pointer += 16;
      log_result = logMessage(2, output_buffer, 0);
      if ( remaining_bytes <= 16 )
        break;
      remaining_bytes -= 16;
    }
  }
  return log_result;
}

//----- (00047158) --------------------------------------------------------
int __fastcall readVoltageFromPIC(unsigned int chainIndex, _DWORD *voltageValues, int voltageType)
{
  int lockResult; // r5
  int i2c_bus_handle; // r5
  unsigned int checksum; // r3
  unsigned __int16 value16; // r2
  int readResult; // r5
  __int16 firstValue; // r1
  int *valueIterator; // r2
  unsigned int tempChecksum; // r3
  __int16 nextValue; // t1
  unsigned __int16 revValue1; // r2
  unsigned __int16 revValue2; // r3
  int cmdFrameStart; // [sp+14h] [bp-834h] BYREF
  char commandCode; // [sp+18h] [bp-830h]
  char targetCommand; // [sp+19h] [bp-82Fh]
  int commandBuffer[3]; // [sp+1Ch] [bp-82Ch] BYREF
  char logBuffer[2080]; // [sp+28h] [bp-820h] BYREF

  if ( chainIndex > 15 )
  {
    snprintf(logBuffer, 2048u, "%s: Bad pic param, input chain is %d\n", "pic_get_voltage", chainIndex);
    i2c_bus_handle = -2147483135;
    logMessage(0, logBuffer, 0);
    return i2c_bus_handle;
  }
  if ( !dword_99EE48[2 * chainIndex + 1] )
  {
    i2c_bus_handle = get_i2c_bus_handle(chainIndex);
    if ( i2c_bus_handle < 0 )
    {
      snprintf(
        logBuffer,
        2048u,
        "%s: auto exec open_pic, but chain %d open eeprom failed\n",
        "pic_get_voltage",
        chainIndex);
      logMessage(0, logBuffer, 0);
      return i2c_bus_handle;
    }
  }
  if ( voltageType == 3 )
  {
    pthread_mutex_lock(&stru_50514C);
    readResult = dword_99EE48[2 * chainIndex];
    commandCode = 0;
    cmdFrameStart = 923052629;
    memset(commandBuffer, 0, 11);
    targetCommand = 59;
    if ( i2c_transfer_with_lock(readResult, (int)&cmdFrameStart, 6) != 6 )
    {
      snprintf(logBuffer, 2048u, "%s write iic err\n", "_read_an_voltage");
      goto HandleError;
    }
    usleep(300000u);
    i2c_bus_handle = i2c_write_with_mutex(readResult, commandBuffer, 11);
    if ( i2c_bus_handle != 11 )
    {
      snprintf(logBuffer, 2048u, "%s read iic err\n", "_read_an_voltage");
      goto HandleError;
    }
    firstValue = LOBYTE(commandBuffer[0]);
    if ( LOBYTE(commandBuffer[0]) != 11 || BYTE1(commandBuffer[0]) != 55 )
    {
      snprintf(
        logBuffer,
        2048u,
        "%s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
        "_read_an_voltage",
        LOBYTE(commandBuffer[0]),
        BYTE1(commandBuffer[0]));
      i2c_bus_handle = -1;
      logMessage(0, logBuffer, 0);
      goto ReleaseLock;
    }
    valueIterator = commandBuffer;
    LOWORD(tempChecksum) = 0;
    while ( 1 )
    {
      tempChecksum = (unsigned __int16)(tempChecksum + firstValue);
      if ( valueIterator == &commandBuffer[2] )
        break;
      nextValue = *((unsigned __int8 *)valueIterator + 1);
      valueIterator = (int *)((char *)valueIterator + 1);
      firstValue = nextValue;
    }
    if ( BYTE1(commandBuffer[2]) != tempChecksum >> 8 || BYTE2(commandBuffer[2]) != (unsigned __int8)tempChecksum )
    {
      snprintf(logBuffer, 2048u, "%s failed 2!\n", "_read_an_voltage");
      goto HandleError;
    }
    revValue1 = __rev16(*(unsigned __int16 *)((char *)&commandBuffer[1] + 1));
    revValue2 = __rev16(*(unsigned __int16 *)((char *)&commandBuffer[1] + 3));
    *voltageValues = (unsigned __int16)__rev16(*(unsigned __int16 *)((char *)commandBuffer + 3));
    voltageValues[1] = revValue1;
    voltageValues[2] = revValue2;
  }
  else
  {
    if ( voltageType != 1 )
    {
      i2c_bus_handle = -2147483135;
      snprintf(logBuffer, 2048u, "%s failed: parameters error!\n", "pic_get_voltage");
      logMessage(0, logBuffer, 0);
      return i2c_bus_handle;
    }
    pthread_mutex_lock(&stru_50514C);
    lockResult = dword_99EE48[2 * chainIndex];
    commandCode = 0;
    commandBuffer[0] = 0;
    cmdFrameStart = 973384277;
    *(int *)((char *)commandBuffer + 3) = 0;
    targetCommand = 62;
    if ( i2c_transfer_with_lock(lockResult, (int)&cmdFrameStart, 6) != 6 )
    {
      snprintf(logBuffer, 2048u, "%s write iic err\n", "_read_an6_voltage");
HandleError:
      i2c_bus_handle = -1;
      logMessage(0, logBuffer, 0);
      goto ReleaseLock;
    }
    usleep(300000u);
    i2c_bus_handle = i2c_write_with_mutex(lockResult, commandBuffer, 7);
    if ( i2c_bus_handle != 7 )
    {
      snprintf(logBuffer, 2048u, "%s read iic err\n", "_read_an6_voltage");
      goto HandleError;
    }
    if ( LOBYTE(commandBuffer[0]) != 7 || BYTE1(commandBuffer[0]) != 58 || BYTE2(commandBuffer[0]) != 1 )
    {
      snprintf(
        logBuffer,
        2048u,
        "%s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x, read_back_data[2] = 0x%02x\n\n",
        "_read_an6_voltage",
        LOBYTE(commandBuffer[0]),
        BYTE1(commandBuffer[0]),
        BYTE2(commandBuffer[0]));
      i2c_bus_handle = -1;
      logMessage(0, logBuffer, 0);
      goto ReleaseLock;
    }
    checksum = HIBYTE(commandBuffer[0]) + LOBYTE(commandBuffer[1]) + 66;
    value16 = __rev16(*(unsigned __int16 *)((char *)commandBuffer + 3));
    if ( BYTE1(commandBuffer[1]) != checksum >> 8 || BYTE2(commandBuffer[1]) != (unsigned __int8)checksum )
    {
      snprintf(logBuffer, 2048u, "%s failed 2!\n", "_read_an6_voltage");
      goto HandleError;
    }
    *voltageValues = value16;
  }
ReleaseLock:
  pthread_mutex_unlock(&stru_50514C);
  return i2c_bus_handle;
}
// 50514C: using guessed type pthread_mutex_t stru_50514C;
// 99EE48: using guessed type _DWORD dword_99EE48[32];

//----- (0004752C) --------------------------------------------------------
int __fastcall writeToFlash(unsigned int chainIndex, __int16 command, __int16 subCommand, int dataArray, int dataSize)
{
  int v9; // r10
  int v10; // r4
  int status; // r7
  __int16 v12; // r5
  unsigned __int8 *v13; // r6
  char *v14; // r2
  unsigned int v15; // r3
  unsigned int v16; // t1
  __int16 v18; // [sp+Ch] [bp-84Ch] BYREF
  __int16 v19; // [sp+10h] [bp-848h] BYREF
  char v20; // [sp+12h] [bp-846h]
  char v21; // [sp+13h] [bp-845h]
  char v22; // [sp+14h] [bp-844h]
  char v23; // [sp+15h] [bp-843h]
  int v24; // [sp+16h] [bp-842h]
  int v25; // [sp+1Ah] [bp-83Eh]
  int v26; // [sp+1Eh] [bp-83Ah]
  int v27; // [sp+22h] [bp-836h]
  int v28; // [sp+26h] [bp-832h]
  int v29; // [sp+2Ah] [bp-82Eh]
  __int16 v30; // [sp+2Eh] [bp-82Ah]
  char logBuffer[2048]; // [sp+30h] [bp-828h] BYREF

  if ( chainIndex > 15 )
  {
    snprintf(logBuffer, 2048u, "%s: Bad pic param, input chain is %d\n", "app_write_data_into_flash", chainIndex);
    status = -2147483135;
    logMessage(0, logBuffer, 0);
    return status;
  }
  if ( !dword_99EE48[2 * chainIndex + 1] )
  {
    status = get_i2c_bus_handle(chainIndex);
    if ( status < 0 )
    {
      snprintf(
        logBuffer,
        2048u,
        "%s: auto exec open_pic, but chain %d open eeprom failed\n",
        "app_write_data_into_flash",
        chainIndex);
      logMessage(0, logBuffer, 0);
      return status;
    }
  }
  v9 = dword_99EE48[2 * chainIndex];
  v10 = 0;
  pthread_mutex_lock(&stru_50514C);
  if ( dataSize >= 16 )
    status = 16;
  else
    status = dataSize;
  v23 = subCommand;
  v20 = dataSize + 6;
  v22 = command;
  v12 = (unsigned __int8)(dataSize + 6) + subCommand + 53 + command;
  v19 = -21931;
  v18 = 0;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  v28 = 0;
  v29 = 0;
  v30 = 0;
  v21 = 53;
  if ( dataSize > 0 )
  {
    v13 = (unsigned __int8 *)(dataArray - 1);
    do
    {
      v16 = *++v13;
      v15 = v16;
      if ( (v10 & 1) == 0 && v15 > 63 )
      {
        snprintf(logBuffer, 2048u, "%s: the data[%d] must less than 0x3f\n", "_app_write_data_into_flash_1704_v8", v10);
        logMessage(v10 & 1, logBuffer, v10 & 1);
        LOWORD(v15) = *v13;
      }
      v14 = (char *)&v19 + v10++;
      v14[6] = v15;
      v12 += v15;
    }
    while ( status > v10 );
  }
  *((_BYTE *)&v19 + (unsigned __int16)(status + 6)) = HIBYTE(v12);
  *((_BYTE *)&v19 + (unsigned __int16)(status + 7)) = v12;
  if ( i2c_transfer_with_lock(v9, (int)&v19, (unsigned __int16)(status + 8)) == (unsigned __int16)(status + 8) )
  {
    usleep(300000u);
    if ( i2c_write_with_mutex(v9, &v18, 2) == 2 )
    {
      if ( (unsigned __int8)v18 != 53 || HIBYTE(v18) != 1 )
      {
        status = 0;
        snprintf(
          logBuffer,
          2048u,
          "%s failed 2! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
          "_app_write_data_into_flash_1704_v8",
          (unsigned __int8)v18,
          HIBYTE(v18));
        logMessage(0, logBuffer, 0);
      }
      goto END_WRITE;
    }
    snprintf(logBuffer, 2048u, "%s read iic 2 err\n", "_app_write_data_into_flash_1704_v8");
  }
  else
  {
    snprintf(logBuffer, 2048u, "%s write iic 2 err\n", "_app_write_data_into_flash_1704_v8");
  }
  status = 0;
  logMessage(0, logBuffer, 0);
END_WRITE:
  pthread_mutex_unlock(&stru_50514C);
  return status;
}
// 50514C: using guessed type pthread_mutex_t stru_50514C;
// 99EE48: using guessed type _DWORD dword_99EE48[32];

//----- (000477EC) --------------------------------------------------------
int __fastcall readDataFromEEPROM(
        unsigned int chain_id,
        __int16 eeprom_addr_high,
        __int16 eeprom_addr_low,
        void *destination_buffer,
        int data_length)
{
  int return_code; // r7
  int read_data_len; // r8
  unsigned __int8 *read_buffer; // r0
  int address_field; // r2
  int read_actual_length; // r4
  unsigned __int8 *allocated_buffer; // r6
  const char *error_message; // r2
  int read_byte; // r3
  int calculated_checksum; // r8
  __int16 first_byte; // r0
  unsigned int checksum_high; // r3
  unsigned int checksum_low; // r2
  int checksum; // r3
  unsigned __int8 *checksum_position; // r7
  int header_buffer; // [sp+14h] [bp-834h] BYREF
  char hardware_address_code; // [sp+18h] [bp-830h]
  char eeprom_high_byte; // [sp+19h] [bp-82Fh]
  char eeprom_low_byte; // [sp+1Ah] [bp-82Eh]
  char data_length_byte; // [sp+1Bh] [bp-82Dh]
  char command_code; // [sp+1Ch] [bp-82Ch]
  char logBuffer[2088]; // [sp+20h] [bp-828h] BYREF

  if ( chain_id > 15 )
  {
    snprintf(logBuffer, 2048u, "%s: Bad pic param, input chain is %d\n", "app_read_data_from_flash", chain_id);
    read_actual_length = -2147483135;
    logMessage(0, logBuffer, 0);
    return read_actual_length;
  }
  if ( !dword_99EE48[2 * chain_id + 1] )
  {
    read_actual_length = get_i2c_bus_handle(chain_id);
    if ( read_actual_length < 0 )
    {
      snprintf(
        logBuffer,
        2048u,
        "%s: auto exec open_pic, but chain %d open eeprom failed\n",
        "app_read_data_from_flash",
        chain_id);
      logMessage(0, logBuffer, 0);
      return read_actual_length;
    }
  }
  return_code = data_length + 5;
  read_data_len = dword_99EE48[2 * chain_id];
  pthread_mutex_lock(&stru_50514C);
  read_buffer = (unsigned __int8 *)malloc(data_length + 5);
  LOWORD(address_field) = -21931;
  if ( data_length >= 16 )
    read_actual_length = 16;
  else
    read_actual_length = data_length;
  HIWORD(address_field) = 13831;
  header_buffer = address_field;
  allocated_buffer = read_buffer;
  hardware_address_code = eeprom_addr_high;
  eeprom_high_byte = eeprom_addr_low;
  eeprom_low_byte = read_actual_length;
  command_code = read_actual_length + 61 + eeprom_addr_low + eeprom_addr_high;
  data_length_byte = (unsigned __int16)(read_actual_length + 61 + eeprom_addr_low + eeprom_addr_high) >> 8;
  if ( i2c_transfer_with_lock(read_data_len, (int)&header_buffer, 9) == 9 )
  {
    usleep(300000u);
    if ( return_code == i2c_write_with_mutex(read_data_len, allocated_buffer, data_length + 5) )
    {
      read_byte = allocated_buffer[1];
      calculated_checksum = *allocated_buffer;
      first_byte = *allocated_buffer;
      if ( read_byte == 54 && allocated_buffer[2] == 1 && return_code == calculated_checksum )
      {
        if ( data_length + 3 > 0 )
        {
          LOWORD(checksum_low) = 0;
          LOWORD(checksum) = 0;
          while ( 1 )
          {
            checksum = (unsigned __int16)(checksum + 1);
            checksum_low = (unsigned __int16)(checksum_low + first_byte);
            if ( checksum >= data_length + 3 )
              break;
            first_byte = allocated_buffer[checksum];
          }
          checksum_high = checksum_low >> 8;
        }
        else
        {
          checksum_high = 0;
          LOBYTE(checksum_low) = 0;
        }
        checksum_position = &allocated_buffer[return_code];
        if ( *(checksum_position - 2) == checksum_high && *(checksum_position - 1) == (unsigned __int8)checksum_low )
        {
          memcpy(destination_buffer, allocated_buffer + 3, read_actual_length);
        }
        else
        {
          read_actual_length = 0;
          snprintf(logBuffer, 2048u, "%s failed 2!\n", "_app_read_data_from_flash_1704_v8");
          logMessage(0, logBuffer, 0);
          dump_memory_data(allocated_buffer, calculated_checksum);
        }
      }
      else
      {
        snprintf(
          logBuffer,
          2048u,
          "%s failed !\n read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x\n",
          "_app_read_data_from_flash_1704_v8",
          calculated_checksum,
          read_byte,
          allocated_buffer[2]);
        read_actual_length = 0;
        logMessage(0, logBuffer, 0);
        dump_memory_data(allocated_buffer, data_length + 5);
      }
      goto LABEL_9;
    }
    error_message = "%s read iic 2 err\n";
  }
  else
  {
    error_message = "%s write iic 2 err\n";
  }
  read_actual_length = 0;
  snprintf(logBuffer, 2048u, error_message, "_app_read_data_from_flash_1704_v8");
  logMessage(0, logBuffer, 0);
LABEL_9:
  free(allocated_buffer);
  pthread_mutex_unlock(&stru_50514C);
  return read_actual_length;
}
// 50514C: using guessed type pthread_mutex_t stru_50514C;
// 99EE48: using guessed type _DWORD dword_99EE48[32];

//----- (00047AC4) --------------------------------------------------------
int __fastcall upgradePIC(unsigned int chainIndex, const char *firmwarePath)
{
  int i2c_bus_handle; // r4
  int v5; // r5
  FILE *v6; // r0
  FILE *v7; // r6
  _OWORD *v8; // r4
  __int16 v9; // r0
  int v10; // r4
  int *v11; // r3
  int v12; // r0
  int v13; // r1
  int v14; // r2
  int v15; // r3
  int *v16; // r0
  int *v17; // r2
  __int16 v18; // r3
  __int16 v19; // t1
  __int16 v21; // [sp+Ch] [bp-1BE4h] BYREF
  char v22[4]; // [sp+10h] [bp-1BE0h] BYREF
  char v23; // [sp+14h] [bp-1BDCh]
  char v24; // [sp+17h] [bp-1BD9h] BYREF
  int v25; // [sp+18h] [bp-1BD8h]
  int v26; // [sp+1Ch] [bp-1BD4h]
  int v27; // [sp+20h] [bp-1BD0h]
  int v28; // [sp+24h] [bp-1BCCh] BYREF
  int v29; // [sp+28h] [bp-1BC8h] BYREF
  int v30[4]; // [sp+2Ch] [bp-1BC4h] BYREF
  char v31; // [sp+3Ch] [bp-1BB4h]
  char v32; // [sp+3Dh] [bp-1BB3h]
  int v33; // [sp+3Eh] [bp-1BB2h]
  int v34; // [sp+42h] [bp-1BAEh]
  __int16 v35; // [sp+46h] [bp-1BAAh]
  char s[8]; // [sp+48h] [bp-1BA8h] BYREF
  _OWORD v37[314]; // [sp+848h] [bp-13A8h] BYREF

  if ( chainIndex > 15 )
  {
    v10 = -2147483135;
    snprintf((char *)v37, 2048u, "%s: Bad pic param, input chain is %d\n", "upgrade_pic", chainIndex);
    logMessage(0, (const char *)v37, 0);
    return v10;
  }
  if ( !dword_99EE48[2 * chainIndex + 1] )
  {
    i2c_bus_handle = get_i2c_bus_handle(chainIndex);
    if ( i2c_bus_handle < 0 )
    {
      snprintf(
        (char *)v37,
        2048u,
        "%s: auto exec open_pic, but chain %d open eeprom failed\n",
        "upgrade_pic",
        chainIndex);
      logMessage(0, (const char *)v37, 0);
      return i2c_bus_handle;
    }
  }
  memset(v37, 0, 5000u);
  v26 = 0;
  v27 = 0;
  v28 = 0;
  v5 = dword_99EE48[2 * chainIndex];
  v25 = 0;
  *(_DWORD *)v22 = 0;
  v23 = 0;
  snprintf(s, 2048u, "%s\n", "_update_pic_app_program_1704");
  logMessage(2, s, 0);
  v6 = (FILE *)fopen64(firmwarePath, "r");
  v7 = v6;
  if ( !v6 )
  {
    snprintf(s, 2048u, "%s: open %s failed\n", "_update_pic_app_program_1704", firmwarePath);
    v10 = -2147483136;
    logMessage(0, s, 0);
    return v10;
  }
  fseek(v6, 0, 0);
  v8 = v37;
  memset(v37, 0, 5000u);
  snprintf(s, 2048u, "%s: pic_flash_length = %d\n", "_update_pic_app_program_1704", 2432);
  logMessage(2, s, 0);
  do
  {
    v8 = (_OWORD *)((char *)v8 + 2);
    fgets(v22, 1023, v7);
    v9 = strtoul(v22, 0, 16);
    *((_BYTE *)v8 - 1) = v9;
    *((_BYTE *)v8 - 2) = HIBYTE(v9);
  }
  while ( &v37[304] != v8 );
  fclose(v7);
  v10 = reset_pic(chainIndex);
  if ( v10 )
  {
LABEL_30:
    snprintf(s, 2048u, "%s: reset pic error!\n\n", "_update_pic_app_program_1704");
LABEL_32:
    logMessage(0, s, 0);
    return v10;
  }
  v10 = check_pic_i2c_connection(v5);
  if ( v10 )
  {
    snprintf(s, 2048u, "%s set 1704 flash pointer err\n", "_erase_pic_app");
    logMessage(0, s, 0);
    snprintf(s, 2048u, "%s: erase app flash error!\n\n", "_update_pic_app_program_1704");
    goto LABEL_32;
  }
  pthread_mutex_lock(&stru_50514C);
  v29 = 67414613;
  LOWORD(v30[0]) = 2048;
  v21 = 0;
  if ( i2c_transfer_with_lock(v5, (int)&v29, 6) != 6 )
  {
    snprintf(s, 2048u, "%s write iic err\n", "_bitmain_pic_erase_1704");
    goto LABEL_41;
  }
  usleep(300000u);
  if ( i2c_write_with_mutex(v5, &v21, 2) != 2 )
  {
    snprintf(s, 2048u, "%s read iic err\n", "_bitmain_pic_erase_1704");
    goto LABEL_41;
  }
  usleep(300000u);
  if ( (unsigned __int8)v21 != 4 || HIBYTE(v21) != 1 )
  {
    snprintf(
      s,
      2048u,
      "%s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "_bitmain_pic_erase_1704",
      (unsigned __int8)v21,
      HIBYTE(v21));
LABEL_41:
    logMessage(0, s, 0);
  }
  pthread_mutex_unlock(&stru_50514C);
  v10 = check_pic_i2c_connection(v5);
  if ( v10 )
  {
    snprintf(s, 2048u, aSSet1704FlashP_0, "_update_pic_app_program_1704");
    goto LABEL_32;
  }
  do
  {
    v11 = (int *)&v37[v10];
    v12 = *v11;
    v13 = v11[1];
    v14 = v11[2];
    v15 = v11[3];
    v25 = v12;
    v26 = v13;
    v27 = v14;
    v28 = v15;
    snprintf(s, 2048u, "send pic program time: %d", v10);
    logMessage(2, s, 0);
    pthread_mutex_lock(&stru_50514C);
    v16 = v30;
    v17 = (int *)&v24;
    v18 = 22;
    v33 = 0;
    v21 = 0;
    v34 = 0;
    v35 = 0;
    memset(v30, 0, sizeof(v30));
    v29 = 34908757;
    do
    {
      v19 = *((unsigned __int8 *)v17 + 1);
      v17 = (int *)((char *)v17 + 1);
      v18 += v19;
      *(_BYTE *)v16 = v19;
      v16 = (int *)((char *)v16 + 1);
    }
    while ( (int *)((char *)&v28 + 3) != v17 );
    v31 = HIBYTE(v18);
    v32 = v18;
    if ( i2c_transfer_with_lock(v5, (int)&v29, 22) == 22 )
    {
      usleep(300000u);
      if ( i2c_write_with_mutex(v5, &v21, 2) == 2 )
      {
        if ( (unsigned __int8)v21 == 2 && HIBYTE(v21) == 1 )
        {
          v29 = 84191829;
          LOWORD(v30[0]) = 2304;
          if ( i2c_transfer_with_lock(v5, (int)&v29, 6) == 6 )
          {
            usleep(300000u);
            if ( i2c_write_with_mutex(v5, &v21, 2) == 2 )
            {
              if ( (unsigned __int8)v21 == 5 && HIBYTE(v21) == 1 )
              {
                snprintf(s, 2048u, "%s  success write to pic flash\n", "_bitmain_pic_write_1704");
                logMessage(2, s, 0);
                goto LABEL_28;
              }
              snprintf(
                s,
                2048u,
                "%s failed 2! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
                "_bitmain_pic_write_1704",
                (unsigned __int8)v21,
                HIBYTE(v21));
            }
            else
            {
              snprintf(s, 2048u, "%s read iic 2 err\n", "_bitmain_pic_write_1704");
            }
          }
          else
          {
            snprintf(s, 2048u, "%s write iic 2 err\n", "_bitmain_pic_write_1704");
          }
        }
        else
        {
          snprintf(
            s,
            2048u,
            "%s failed 1! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
            "_bitmain_pic_write_1704",
            (unsigned __int8)v21,
            HIBYTE(v21));
        }
      }
      else
      {
        snprintf(s, 2048u, "%s read iic 1 err\n", "_bitmain_pic_write_1704");
      }
    }
    else
    {
      snprintf(s, 2048u, "%s write iic 1 err\n", "_bitmain_pic_write_1704");
    }
    logMessage(0, s, 0);
LABEL_28:
    ++v10;
    pthread_mutex_unlock(&stru_50514C);
  }
  while ( v10 != 304 );
  v10 = reset_pic(chainIndex);
  if ( v10 )
    goto LABEL_30;
  return v10;
}
// 124E4: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 50514C: using guessed type pthread_mutex_t stru_50514C;
// 99EE48: using guessed type _DWORD dword_99EE48[32];

//----- (00048110) --------------------------------------------------------
int __fastcall pic_read_iic(unsigned int chain_id, int slave_address, int command, void *destination, int read_length)
{
  int ret_val; // r4
  int select_slave_ret; // r6
  int mutex_lock_ret; // r5
  int corrected_length; // r6
  const char *error_msg; // r2
  __int16 check_sum; // r3
  int byte_number; // r1
  unsigned int sum; // r2
  int write_data; // [sp+10h] [bp-848h] BYREF
  char read_command; // [sp+14h] [bp-844h]
  char read_length_byte; // [sp+15h] [bp-843h]
  char checksum_low_byte; // [sp+16h] [bp-842h]
  char checksum_high_byte; // [sp+17h] [bp-841h]
  int read_status; // [sp+18h] [bp-840h] BYREF
  int bytes_to_read[4]; // [sp+1Ch] [bp-83Ch] BYREF
  __int16 unknown_short; // [sp+2Ch] [bp-82Ch]
  char logBuffer[2048]; // [sp+30h] [bp-828h] BYREF

  if ( chain_id > 15 )
  {
    snprintf(logBuffer, 2048u, "%s: Bad pic param, input chain is %d\n", "pic_read_iic", chain_id);
    corrected_length = -2147483135;
    logMessage(0, logBuffer, 0);
    return corrected_length;
  }
  if ( !dword_99EE48[2 * chain_id + 1] )
  {
    corrected_length = get_i2c_bus_handle(chain_id);
    if ( corrected_length < 0 )
    {
      snprintf(logBuffer, 2048u, "%s: auto exec open_pic, but chain %d open eeprom failed\n", "pic_read_iic", chain_id);
      logMessage(0, logBuffer, 0);
      return corrected_length;
    }
  }
  ret_val = 0;
  select_slave_ret = write_pic_i2c_data(dword_99EE48[2 * chain_id], slave_address, command, 0, 0);
  if ( select_slave_ret >= 0 )
  {
    usleep(10000u);
    mutex_lock_ret = dword_99EE48[2 * chain_id];
    pthread_mutex_lock(&stru_50514C);
    if ( read_length >= 16 )
      corrected_length = 16;
    else
      corrected_length = read_length;
    read_length_byte = corrected_length;
    checksum_high_byte = corrected_length + 66 + slave_address;
    read_status = 0;
    read_command = slave_address;
    memset(bytes_to_read, 0, sizeof(bytes_to_read));
    checksum_low_byte = (unsigned __int16)(corrected_length + 66 + slave_address) >> 8;
    unknown_short = 0;
    write_data = 1007069781;
    if ( i2c_transfer_with_lock(mutex_lock_ret, (int)&write_data, 8) == 8 )
    {
      usleep(10000u);
      if ( corrected_length + 5 == i2c_write_with_mutex(mutex_lock_ret, &read_status, corrected_length + 5) )
      {
        check_sum = (unsigned __int8)read_status;
        if ( corrected_length + 5 == (unsigned __int8)read_status && BYTE1(read_status) == 60 && BYTE2(read_status) == 1 )
        {
          byte_number = corrected_length + 3;
          LOWORD(sum) = 0;
          if ( corrected_length + 3 > 0 )
          {
            while ( 1 )
            {
              ret_val = (unsigned __int16)(ret_val + 1);
              sum = (unsigned __int16)(sum + check_sum);
              if ( ret_val >= byte_number )
                break;
              check_sum = *((unsigned __int8 *)&bytes_to_read[-1] + ret_val);
            }
            ret_val = sum >> 8;
          }
          if ( *((unsigned __int8 *)&bytes_to_read[-1] + byte_number) == ret_val
            && *((unsigned __int8 *)bytes_to_read + corrected_length) == (unsigned __int8)sum )
          {
            memcpy(destination, (char *)&read_status + 3, corrected_length);
          }
          else
          {
            snprintf(logBuffer, 2048u, "%s failed 2!\n", "_pic_read_iic");
            corrected_length = 0;
            logMessage(0, logBuffer, 0);
          }
        }
        else
        {
          corrected_length = 0;
          snprintf(
            logBuffer,
            2048u,
            "%s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x, read_back_data[2] = 0x%02x\n\n",
            "_pic_read_iic",
            (unsigned __int8)read_status,
            BYTE1(read_status),
            BYTE2(read_status));
          logMessage(0, logBuffer, 0);
        }
        goto UNLOCK_MUTEX;
      }
      error_msg = "%s read iic err\n";
    }
    else
    {
      error_msg = "%s write iic err\n";
    }
    corrected_length = 0;
    snprintf(logBuffer, 2048u, error_msg, "_pic_read_iic");
    logMessage(0, logBuffer, 0);
UNLOCK_MUTEX:
    pthread_mutex_unlock(&stru_50514C);
    return corrected_length;
  }
  snprintf(
    logBuffer,
    2048u,
    "%s: select slave: 0x%02x, reg/command: 0x%02x is failed",
    "pic_read_iic",
    slave_address,
    command);
  logMessage(0, logBuffer, 0);
  return select_slave_ret;
}
// 50514C: using guessed type pthread_mutex_t stru_50514C;
// 99EE48: using guessed type _DWORD dword_99EE48[32];

//----- (00048438) --------------------------------------------------------
int __fastcall write_pic_via_i2c(
        unsigned int chain_index,
        __int16 i2c_address,
        __int16 register_address,
        int data_length,
        int data_buffer)
{
  int i2c_bus_handle; // r6
  char error_message[2080]; // [sp+8h] [bp-820h] BYREF

  if ( chain_index > 15 )
  {
    snprintf(error_message, 2048u, "%s: Bad pic param, input chain is %d\n", "pic_write_iic", chain_index);
    i2c_bus_handle = -2147483135;
    logMessage(0, error_message, 0);
  }
  else
  {
    if ( dword_99EE48[2 * chain_index + 1] )
      return write_pic_i2c_data(dword_99EE48[2 * chain_index], i2c_address, register_address, data_length, data_buffer);
    i2c_bus_handle = get_i2c_bus_handle(chain_index);
    if ( i2c_bus_handle >= 0 )
    {
      return write_pic_i2c_data(dword_99EE48[2 * chain_index], i2c_address, register_address, data_length, data_buffer);
    }
    else
    {
      snprintf(
        error_message,
        2048u,
        "%s: auto exec open_pic, but chain %d open eeprom failed\n",
        "pic_write_iic",
        chain_index);
      logMessage(0, error_message, 0);
    }
  }
  return i2c_bus_handle;
}
// 99EE48: using guessed type _DWORD dword_99EE48[32];

//----- (00048520) --------------------------------------------------------
int __fastcall SendPowerCommandWithRetries(
        int a1,
        unsigned __int8 *a2,
        unsigned int a3,
        unsigned __int8 *responseBuffer,
        unsigned int responseLength)
{
  unsigned int byteIndex; // r4
  unsigned int commandIndex; // r3
  unsigned int byteIndex_1; // r4
  unsigned int crcCalcIndex; // r3
  unsigned __int8 *crcPtr; // r1
  int computedCrc; // r3
  __int16 v13; // t1
  unsigned __int8 *responseIter; // r4
  int responseByteIndex; // r5
  int readValue; // t1
  int responseByte; // r3
  int status; // r4
  int logMsgLen; // [sp+0h] [bp-830h]
  int retryCount; // [sp+10h] [bp-820h]
  unsigned __int8 *responseCrcHighByte; // [sp+20h] [bp-810h]
  unsigned __int8 *responseBufferEnd; // [sp+24h] [bp-80Ch]
  unsigned __int8 *responseBodyStart; // [sp+2Ch] [bp-804h]
  unsigned __int8 controlByte; // [sp+37h] [bp-7F9h] BYREF
  char logBuffer[2052]; // [sp+38h] [bp-7F8h] BYREF

  responseBodyStart = responseBuffer + 1;
  controlByte = 17;
  pthread_mutex_lock(&stru_505164);
  responseBufferEnd = &responseBuffer[responseLength - 2];
  responseCrcHighByte = &responseBuffer[responseLength - 1];
  retryCount = 0;
  while ( 1 )
  {
    LOBYTE(byteIndex) = 0;
    commandIndex = 0;
    do
    {
      byteIndex = (unsigned __int8)(byteIndex + 1);
      i2c_transaction_wrapper(a1, &controlByte, 1, (int)&a2[commandIndex], 1);
      commandIndex = byteIndex;
    }
    while ( byteIndex < a3 );
    LOBYTE(byteIndex_1) = 0;
    usleep((__useconds_t)"version array failed\n");
    crcCalcIndex = 0;
    do
    {
      byteIndex_1 = (unsigned __int8)(byteIndex_1 + 1);
      perform_i2c_transaction(a1, &controlByte, 1, (int)&responseBuffer[crcCalcIndex], 1);
      crcCalcIndex = byteIndex_1;
    }
    while ( byteIndex_1 < responseLength );
    usleep(100000u);
    crcPtr = responseBodyStart;
    LOWORD(computedCrc) = 0;
    do
    {
      v13 = *++crcPtr;
      computedCrc = (unsigned __int16)(computedCrc + v13);
    }
    while ( &responseBuffer[responseLength - 3] != crcPtr );
    if ( computedCrc != (unsigned __int16)(*responseBufferEnd + (*responseCrcHighByte << 8)) )
    {
      snprintf(
        logBuffer,
        2048u,
        "power reply the bad crc, crc = 0x%04x, crc_read = 0x%04x\n",
        computedCrc,
        (unsigned __int16)(*responseBufferEnd + (*responseCrcHighByte << 8)));
      logMessage(0, logBuffer, 0);
      goto Retry;
    }
    if ( *a2 == *responseBuffer
      && a2[1] == responseBuffer[1]
      && a2[3] == responseBuffer[3]
      && responseLength == responseBuffer[2] + 2 )
    {
      break;
    }
    strcpy(logBuffer, "power reply the bad data\n");
    logMessage(0, logBuffer, 0);
Retry:
    responseIter = responseBuffer - 1;
    responseByteIndex = 0;
    do
    {
      readValue = *++responseIter;
      responseByte = responseByteIndex++;
      snprintf(logBuffer, 2048u, "read_back_data[%d] = 0x%02x", responseByte, readValue);
      logMessage(0, logBuffer, 0);
    }
    while ( &responseBuffer[responseLength - 1] != responseIter );
    logMsgLen = retryCount++;
    snprintf(logBuffer, 2048u, "Send power cmd(0x%02x) failed, retry %d\n", a2[3], logMsgLen);
    logMessage(0, logBuffer, 0);
    if ( retryCount == 3 )
    {
      status = -2147482880;
      goto End;
    }
  }
  status = 0;
End:
  pthread_mutex_unlock(&stru_505164);
  return status;
}
// 505164: using guessed type pthread_mutex_t stru_505164;

//----- (000487E8) --------------------------------------------------------
int log_da_conversion_failure()
{
  char error_message[2056]; // [sp+0h] [bp-808h] BYREF

  strcpy(error_message, "set DA conversion N failed\n");
  logMessage(0, error_message, 0);
  return -2147482880;
}

//----- (00048834) --------------------------------------------------------
int __fastcall send_power_control_command(int device_id, __int16 power_command)
{
  int send_buffer; // [sp+8h] [bp-18h] BYREF
  __int16 power_command_byte; // [sp+Ch] [bp-14h]
  __int16 augmented_power_command; // [sp+Eh] [bp-12h]
  int response_buffer; // [sp+10h] [bp-10h] BYREF
  int received_value; // [sp+14h] [bp-Ch]

  send_buffer = -2096715179;
  augmented_power_command = power_command + 137;
  response_buffer = 0;
  power_command_byte = (unsigned __int8)power_command;
  received_value = 0;
  if ( SendPowerCommandWithRetries(
         device_id,
         (unsigned __int8 *)&send_buffer,
         8u,
         (unsigned __int8 *)&response_buffer,
         8u) )
  {
    return log_da_conversion_failure();
  }
  else
  {
    return (unsigned __int16)received_value;
  }
}

//----- (000488A4) --------------------------------------------------------
int initialize_logging_system()
{
  pthread_mutex_lock(&stru_505164);
  attempt_i2c_operation(dword_50517C);
  global_logContext = 0;
  dword_505184 = 0;
  return pthread_mutex_unlock(&stru_505164);
}
// 505164: using guessed type pthread_mutex_t stru_505164;
// 50517C: using guessed type int dword_50517C;
// 505180: using guessed type int global_logContext;
// 505184: using guessed type int dword_505184;

//----- (000488D8) --------------------------------------------------------
int initialize_global_log_if_necessary()
{
  if ( dword_50517C && global_logContext )
    return 0;
  initialize_logging_system();
  return 0;
}
// 50517C: using guessed type int dword_50517C;
// 505180: using guessed type int global_logContext;

//----- (00048910) --------------------------------------------------------
int getPowerVersion()
{
  int powerInitialized; // r5
  int statusCode; // r4
  int i2cFileDesc; // r7
  int retryCount; // r4
  int productionVersion; // r6
  int powerCode; // [sp+8h] [bp-830h] BYREF
  __int16 versionResponse; // [sp+Ch] [bp-82Ch]
  int readRequest; // [sp+10h] [bp-828h] BYREF
  int versionResponseHigh; // [sp+14h] [bp-824h]
  char logBuffer[2080]; // [sp+18h] [bp-820h] BYREF

  powerInitialized = global_logContext;
  if ( global_logContext || (statusCode = check_log_context_initialized(), statusCode >= 0) )
  {
    i2cFileDesc = dword_50517C;
    retryCount = 10;
    do
    {
      LOBYTE(powerCode) = -1;
      LOBYTE(readRequest) = 0;
      pthread_mutex_lock(&stru_505164);
      if ( perform_i2c_transaction(i2cFileDesc, (unsigned __int8 *)&readRequest, 1, (int)&powerCode, 1) == 1 )
      {
        productionVersion = (unsigned __int8)powerCode;
        pthread_mutex_unlock(&stru_505164);
        if ( productionVersion == 245 )
          break;
      }
      else
      {
        snprintf(logBuffer, 2048u, "%s: iic read is failed\n", "_bitmain_get_power_code_version");
        logMessage(0, logBuffer, 0);
        pthread_mutex_unlock(&stru_505164);
      }
      usleep(100000u);
      --retryCount;
    }
    while ( retryCount );
    powerCode = 33860181;
    readRequest = 0;
    versionResponseHigh = 0;
    versionResponse = 6;
    if ( SendPowerCommandWithRetries(
           i2cFileDesc,
           (unsigned __int8 *)&powerCode,
           6u,
           (unsigned __int8 *)&readRequest,
           8u) )
    {
      statusCode = -2147482880;
      strcpy(logBuffer, "get power version failed\n");
      logMessage(0, logBuffer, 0);
    }
    else
    {
      statusCode = (unsigned __int16)versionResponseHigh;
      if ( (_WORD)versionResponseHigh )
        dword_505184 = (unsigned __int16)versionResponseHigh;
    }
  }
  else
  {
    snprintf(logBuffer, 2048u, "%s: auto exec bitmain_power_open, but open power failed\n", "bitmain_power_version");
    logMessage(powerInitialized, logBuffer, powerInitialized);
  }
  return statusCode;
}
// 505164: using guessed type pthread_mutex_t stru_505164;
// 50517C: using guessed type int dword_50517C;
// 505180: using guessed type int global_logContext;
// 505184: using guessed type int dword_505184;

//----- (00048ABC) --------------------------------------------------------
int check_power_version()
{
  int v0; // r5
  int power_version; // r0
  int i2c_data[6]; // [sp+0h] [bp-18h] BYREF

  i2c_data[1] = (int)&loc_20000;
  i2c_data[0] = 0;
  pthread_mutex_lock(&stru_505164);
  v0 = initiateI2CTransfer((int)i2c_data);
  pthread_mutex_unlock(&stru_505164);
  if ( v0 < 0 )
    return v0;
  dword_50517C = v0;
  global_logContext = 1;
  power_version = getPowerVersion();
  v0 = power_version;
  if ( power_version >= 0 )
  {
    dword_505184 = power_version;
    return 0;
  }
  if ( dword_50517C && global_logContext )
    return v0;
  initialize_logging_system();
  return v0;
}
// 505164: using guessed type pthread_mutex_t stru_505164;
// 50517C: using guessed type int dword_50517C;
// 505180: using guessed type int global_logContext;
// 505184: using guessed type int dword_505184;

//----- (00048B58) --------------------------------------------------------
int check_log_context_initialized()
{
  int is_initialized; // r0

  is_initialized = dword_50517C;
  if ( !dword_50517C || !global_logContext )
    return check_power_version();
  return is_initialized;
}
// 50517C: using guessed type int dword_50517C;
// 505180: using guessed type int global_logContext;

//----- (00048B7C) --------------------------------------------------------
int checkMinerPowerStatus()
{
  int isLoggingEnabled; // r5
  int openPowerStatus; // r6
  int powerStatusRequestData; // [sp+8h] [bp-820h] BYREF
  __int16 powerStatusRequestSize; // [sp+Ch] [bp-81Ch]
  int powerStatusResponseData; // [sp+10h] [bp-818h] BYREF
  int powerStatusResponseSize; // [sp+14h] [bp-814h]
  char logBuffer[2064]; // [sp+18h] [bp-810h] BYREF

  isLoggingEnabled = global_logContext;
  if ( global_logContext || (openPowerStatus = check_power_version(), openPowerStatus >= 0) )
  {
    powerStatusResponseSize = 0;
    powerStatusResponseData = 0;
    powerStatusRequestData = 168077909;
    powerStatusRequestSize = 14;
    if ( SendPowerCommandWithRetries(
           dword_50517C,
           (unsigned __int8 *)&powerStatusRequestData,
           6u,
           (unsigned __int8 *)&powerStatusResponseData,
           8u) )
    {
      strcpy(logBuffer, "get power status failed\n");
      logMessage(0, logBuffer, 0);
      strcpy(logBuffer, "can nont get power status\n");
      logMessage(0, logBuffer, 0);
      return -2147482880;
    }
    return (unsigned __int16)powerStatusResponseSize;
  }
  else
  {
    snprintf(logBuffer, 2048u, "%s: auto exec bitmain_power_open, but open power failed\n", "bitmain_get_power_status");
    logMessage(isLoggingEnabled, logBuffer, isLoggingEnabled);
  }
  return openPowerStatus;
}
// 50517C: using guessed type int dword_50517C;
// 505180: using guessed type int global_logContext;

//----- (00048CB8) --------------------------------------------------------
int __fastcall set_miner_voltage(__int16 voltage_setting)
{
  int log_context; // r6
  int power_version_check; // r5
  char log_message_buffer[2072]; // [sp+0h] [bp-818h] BYREF

  log_context = global_logContext;
  if ( global_logContext )
    return send_power_control_command(dword_50517C, voltage_setting);
  power_version_check = check_power_version();
  if ( power_version_check >= 0 )
    return send_power_control_command(dword_50517C, voltage_setting);
  snprintf(
    log_message_buffer,
    2048u,
    "%s: auto exec bitmain_power_open, but open power failed\n",
    "bitmain_set_voltage_by_n");
  logMessage(log_context, log_message_buffer, log_context);
  return power_version_check;
}
// 50517C: using guessed type int dword_50517C;
// 505180: using guessed type int global_logContext;

//----- (00048D38) --------------------------------------------------------
int calculate_performance_metric()
{
  double multiplier; // d0
  int performance_metric; // r0
  int intermediate_result; // [sp+4h] [bp-4h]

  switch ( dword_505184 )
  {
    case 'A':
    case 'B':
      performance_metric = (int)(765.411764 - multiplier * 35.833333);
      break;
    case 'C':
      performance_metric = (int)(933.240365 - multiplier * 59.806034);
      break;
    case 'q':
    case 'r':
    case 'u':
    case 'w':
      intermediate_result = (int)(1190.93534 - multiplier * 78.742588);
      goto LABEL_3;
    case 't':
    case 'v':
      performance_metric = (int)(1156.10758 - multiplier * 76.090494);
      break;
    default:
      intermediate_result = -1;
LABEL_3:
      performance_metric = intermediate_result;
      break;
  }
  return performance_metric;
}
// 48D54: control flows out of bounds to 48D58
// 48E3C: variable 'multiplier' is possibly undefined
// 505184: using guessed type int dword_505184;

//----- (00048F00) --------------------------------------------------------
int set_voltage_and_send_power_control()
{
  int log_context; // r6
  unsigned int voltage_value; // r0
  int power_version_check_result; // r5
  char log_buffer[2064]; // [sp+8h] [bp-810h] BYREF

  log_context = global_logContext;
  if ( global_logContext || (power_version_check_result = check_power_version(), power_version_check_result >= 0) )
  {
    voltage_value = calculate_performance_metric();
    if ( voltage_value > 255 )
      return -2147482879;
    else
      return send_power_control_command(dword_50517C, (unsigned __int8)voltage_value);
  }
  else
  {
    snprintf(log_buffer, 2048u, "%s: auto exec bitmain_power_open, but open power failed\n", "bitmain_set_voltage");
    logMessage(log_context, log_buffer, log_context);
  }
  return power_version_check_result;
}
// 50517C: using guessed type int dword_50517C;
// 505180: using guessed type int global_logContext;

//----- (00048F9C) --------------------------------------------------------
void sub_48F9C()
{
  ;
}
// 48FBC: control flows out of bounds to 48FC0

//----- (00049168) --------------------------------------------------------
void get_adc_conversion()
{
  int log_context; // r6
  int power_command_payload; // [sp+8h] [bp-820h] BYREF
  __int16 power_command_code; // [sp+Ch] [bp-81Ch]
  int power_command_response[2]; // [sp+10h] [bp-818h] BYREF
  char log_message_buffer[2064]; // [sp+18h] [bp-810h] BYREF

  log_context = global_logContext;
  if ( global_logContext || check_power_version() >= 0 )
  {
    power_command_response[1] = 0;
    power_command_response[0] = 0;
    power_command_payload = 50637397;
    power_command_code = 7;
    if ( SendPowerCommandWithRetries(
           dword_50517C,
           (unsigned __int8 *)&power_command_payload,
           6u,
           (unsigned __int8 *)power_command_response,
           8u) )
    {
      strcpy(log_message_buffer, "get AD conversion N failed\n");
      logMessage(0, log_message_buffer, 0);
      strcpy(log_message_buffer, "can nont get voltage\n");
      logMessage(0, log_message_buffer, 0);
    }
    else
    {
      sub_48F9C();
    }
  }
  else
  {
    snprintf(
      log_message_buffer,
      2048u,
      "%s: auto exec bitmain_power_open, but open power failed\n",
      "bitmain_get_voltage");
    logMessage(log_context, log_message_buffer, log_context);
  }
}
// 50517C: using guessed type int dword_50517C;
// 505180: using guessed type int global_logContext;

//----- (000492A4) --------------------------------------------------------
int __fastcall ReadVoltageDacValue(__int16 chipID, int targetBuffer, int dataLength)
{
  int logContext; // r8
  int readResult; // r5
  char *sourcePtr; // r0
  int bufferIndex; // r3
  int bufferEnd; // r4
  char bufferByte; // t1
  int initialDacValue; // [sp+Ch] [bp-82Ch] BYREF
  char dacMSB; // [sp+10h] [bp-828h]
  char dacLSB; // [sp+11h] [bp-827h]
  __int16 extendedDacValue; // [sp+12h] [bp-826h]
  int readDacValue; // [sp+14h] [bp-824h] BYREF
  int voltageSettings[2]; // [sp+18h] [bp-820h] BYREF
  char logBuffer[2072]; // [sp+20h] [bp-818h] BYREF

  logContext = global_logContext;
  readResult = 0;
  dacMSB = chipID;
  dacLSB = dataLength;
  extendedDacValue = dataLength + 12 + chipID;
  voltageSettings[0] = 0;
  voltageSettings[1] = 0;
  readDacValue = 0;
  initialDacValue = 101100117;
  if ( global_logContext || (readResult = check_power_version(), readResult >= 0) )
  {
    if ( SendPowerCommandWithRetries(
           dword_50517C,
           (unsigned __int8 *)&initialDacValue,
           8u,
           (unsigned __int8 *)&readDacValue,
           dataLength + 7) )
    {
      readResult = -2147482880;
      strcpy(logBuffer, "set DA conversion N failed\n");
      logMessage(0, logBuffer, 0);
    }
    else if ( dataLength )
    {
      sourcePtr = (char *)voltageSettings + 1;
      bufferIndex = targetBuffer - 1;
      bufferEnd = targetBuffer + (unsigned __int8)(dataLength - 1);
      do
      {
        bufferByte = *sourcePtr++;
        *(_BYTE *)++bufferIndex = bufferByte;
      }
      while ( bufferIndex != bufferEnd );
    }
  }
  else
  {
    snprintf(logBuffer, 2048u, "%s: auto exec bitmain_power_open, but open power failed\n", "bitmain_power_read");
    logMessage(logContext, logBuffer, logContext);
  }
  return readResult;
}
// 50517C: using guessed type int dword_50517C;
// 505180: using guessed type int global_logContext;

//----- (000493D0) --------------------------------------------------------
int __fastcall initiateI2CTransfer(int i2cTransactionParams)
{
  int i2cHandle; // r0
  int v3; // r5
  int unlockResult; // r0
  char logBuffer[2072]; // [sp+0h] [bp-818h] BYREF

  if ( pthread_mutex_lock(&stru_505188) )
  {
    v3 = -4;
    strcpy(logBuffer, "failed to iic lock\n");
    logMessage(0, logBuffer, 0);
    return v3;
  }
  if ( i2cTransactionParams )
  {
    i2cHandle = sub_49904();
    v3 = i2cHandle;
    if ( i2cHandle < 0 )
    {
      v3 = -1;
      strcpy(logBuffer, "failed to i2c_init\n");
      logMessage(0, logBuffer, 0);
    }
    else
    {
      if ( set_i2c_register(i2cHandle, *(unsigned __int16 *)(i2cTransactionParams + 4)) )
      {
        strcpy(logBuffer, "failed to i2c_select\n");
        logMessage(0, logBuffer, 0);
        goto LABEL_6;
      }
      if ( configure_i2c_device(
             v3,
             1795,
             (2 * *(unsigned __int8 *)(i2cTransactionParams + 7)) | (16 * *(unsigned __int8 *)(i2cTransactionParams + 6))) )
      {
        strcpy(logBuffer, "failed to i2c_ioctl\n");
        logMessage(0, logBuffer, 0);
LABEL_6:
        if ( v3 )
        {
          unlockResult = v3;
          v3 = -1;
          handle_i2c_communication(unlockResult);
        }
        else
        {
          v3 = -1;
        }
      }
    }
  }
  else
  {
    v3 = -3;
    strcpy(logBuffer, "bad param\n");
    logMessage(0, logBuffer, 0);
  }
  pthread_mutex_unlock(&stru_505188);
  return v3;
}
// 505188: using guessed type pthread_mutex_t stru_505188;

//----- (00049574) --------------------------------------------------------
int __fastcall attempt_i2c_operation(int i2c_device_id)
{
  char error_message[2056]; // [sp+0h] [bp-808h] BYREF

  if ( pthread_mutex_lock(&stru_505188) )
  {
    strcpy(error_message, "failed to i2c lock\n");
    return logMessage(0, error_message, 0);
  }
  else
  {
    handle_i2c_communication(i2c_device_id);
    return pthread_mutex_unlock(&stru_505188);
  }
}
// 505188: using guessed type pthread_mutex_t stru_505188;

//----- (000495E4) --------------------------------------------------------
int __fastcall i2c_write_with_mutex(int file_descriptor, _BYTE *data_buffer, int data_length)
{
  int write_result; // r4
  char error_message[2064]; // [sp+0h] [bp-810h] BYREF

  if ( pthread_mutex_lock(&stru_505188) )
  {
    write_result = -4;
    strcpy(error_message, "failed to i2c lock\n");
    logMessage(0, error_message, 0);
  }
  else
  {
    write_result = read_i2c_data(file_descriptor, data_buffer, data_length);
    pthread_mutex_unlock(&stru_505188);
  }
  return write_result;
}
// 505188: using guessed type pthread_mutex_t stru_505188;

//----- (0004966C) --------------------------------------------------------
int __fastcall i2c_transfer_with_lock(int bus, int address, int data)
{
  int v6; // r4
  char error_message[2064]; // [sp+0h] [bp-810h] BYREF

  if ( pthread_mutex_lock(&stru_505188) )
  {
    v6 = -4;
    strcpy(error_message, "failed to i2c lock\n");
    logMessage(0, error_message, 0);
  }
  else
  {
    v6 = write_i2c_data(bus, address, data);
    pthread_mutex_unlock(&stru_505188);
  }
  return v6;
}
// 505188: using guessed type pthread_mutex_t stru_505188;

//----- (000496F4) --------------------------------------------------------
int __fastcall perform_i2c_transaction(
        int device_address,
        unsigned __int8 *data_buffer,
        int data_length,
        int register_address,
        int flags)
{
  int transaction_result; // r4
  char error_message[2072]; // [sp+8h] [bp-818h] BYREF

  if ( pthread_mutex_lock(&stru_505188) )
  {
    transaction_result = -4;
    strcpy(error_message, "failed to i2c lock\n");
    logMessage(0, error_message, 0);
  }
  else
  {
    transaction_result = i2c_read_registers(device_address, data_buffer, data_length, register_address, flags);
    pthread_mutex_unlock(&stru_505188);
  }
  return transaction_result;
}
// 505188: using guessed type pthread_mutex_t stru_505188;

//----- (00049794) --------------------------------------------------------
int __fastcall i2c_transaction_wrapper(
        int device_address,
        unsigned __int8 *transfer_buffer,
        int transfer_length,
        int sub_command_register,
        int sub_command_length)
{
  int result_status; // r4
  char log_buffer[2072]; // [sp+8h] [bp-818h] BYREF

  if ( pthread_mutex_lock(&stru_505188) )
  {
    result_status = -4;
    strcpy(log_buffer, "failed to i2c lock\n");
    logMessage(0, log_buffer, 0);
  }
  else
  {
    result_status = write_i2c_register(
                      device_address,
                      transfer_buffer,
                      transfer_length,
                      sub_command_register,
                      sub_command_length);
    pthread_mutex_unlock(&stru_505188);
  }
  return result_status;
}
// 505188: using guessed type pthread_mutex_t stru_505188;

//----- (00049834) --------------------------------------------------------
int __fastcall compare_version_numbers(_DWORD *version1, _DWORD *version2)
{
  return *version1 - *version2;
}

//----- (00049844) --------------------------------------------------------
unsigned int check_asic_ready()
{
  int retries; // r4
  unsigned int register_value; // [sp+4h] [bp-14h] BYREF

  retries = 601;
  register_value = 0;
  do
  {
    read_register_value(12, &register_value);
    if ( (register_value & 2147483648) != 0 )
      return register_value >> 31;
    usleep(5000u);
    --retries;
  }
  while ( retries );
  return 0;
}

//----- (000498A0) --------------------------------------------------------
unsigned int __fastcall poll_register_for_completion(_BYTE *output_value)
{
  int timeout_counter; // r4
  unsigned int completion_status; // r0
  unsigned int register_value; // [sp+4h] [bp-14h] BYREF

  timeout_counter = 601;
  register_value = 0;
  do
  {
    read_register_value(12, &register_value);
    if ( (register_value & 2147483648) != 0 )
    {
      completion_status = register_value >> 31;
      *output_value = register_value;
      return completion_status;
    }
    usleep(5000u);
    --timeout_counter;
  }
  while ( timeout_counter );
  return 0;
}

//----- (00049904) --------------------------------------------------------
int sub_49904()
{
  const pthread_mutexattr_t *mutex_attr; // r4
  int *initialization_ptr; // r6
  int init_status; // [sp+Ch] [bp-814h] BYREF
  _DWORD init_message[516]; // [sp+10h] [bp-810h] BYREF

  init_status = -1;
  if ( dword_504C90 )
  {
    mutex_attr = (const pthread_mutexattr_t *)dword_5051A0;
    if ( dword_5051A0 )
    {
      initialization_ptr = (int *)dword_5051A4;
    }
    else
    {
      initialization_ptr = allocate_and_init_struct((int)compare_version_numbers, dword_5051A0, dword_5051A0);
      dword_5051A4 = (int)initialization_ptr;
      pthread_mutex_init(&stru_5051A8, mutex_attr);
      mutex_attr = (const pthread_mutexattr_t *)dword_5051A0;
    }
    dword_5051A0 = (int)mutex_attr + 1;
    init_status = (int)mutex_attr + 1;
    init_message[0] = 0;
    init_message[1] = 0;
    process_miner_data(initialization_ptr, &init_status, 4u, init_message, 8u);
    return init_status;
  }
  else
  {
    strcpy((char *)init_message, "please init platform first!!\n");
    logMessage(dword_504C90, (const char *)init_message, dword_504C90);
    return -2;
  }
}
// 504C90: using guessed type int dword_504C90;
// 5051A0: using guessed type int dword_5051A0;
// 5051A4: using guessed type int dword_5051A4;

//----- (000499E8) --------------------------------------------------------
int __fastcall handle_i2c_communication(int context_id)
{
  _DWORD *worker_struct; // r4
  int operation_result; // r0
  int context_id_copy; // [sp+4h] [bp-814h] BYREF
  char log_buffer[2064]; // [sp+8h] [bp-810h] BYREF

  context_id_copy = context_id;
  if ( pthread_mutex_lock(&stru_5051A8) )
  {
    strcpy(log_buffer, "failed to i2c lock\n");
    return logMessage(0, log_buffer, 0);
  }
  else
  {
    if ( check_and_update_status((int *)dword_5051A4, (int)&context_id_copy) == (int *)1 )
    {
      handle_network_packet((int *)dword_5051A4, (int)&context_id_copy);
    }
    else
    {
      snprintf(log_buffer, 2048u, "ctx(%d) is not inited\n", context_id_copy);
      logMessage(1, log_buffer, 0);
    }
    worker_struct = create_worker_struct(dword_5051A4);
    if ( ((int (*)(void))*worker_struct)() )
    {
      while ( ((int (__fastcall *)(_DWORD *))*worker_struct)(worker_struct) )
        ;
      j_free(worker_struct);
      return pthread_mutex_unlock(&stru_5051A8);
    }
    else
    {
      j_free(worker_struct);
      pthread_mutex_unlock(&stru_5051A8);
      dword_5051A0 = 0;
      operation_result = free_and_process_pointer((void **)dword_5051A4);
      dword_5051A4 = 0;
    }
  }
  return operation_result;
}
// 5051A0: using guessed type int dword_5051A0;
// 5051A4: using guessed type int dword_5051A4;

//----- (00049B10) --------------------------------------------------------
int __fastcall read_i2c_data(int i2c_context, _BYTE *data_buffer, int data_length)
{
  void *received_data; // r0
  int i2c_control_value; // r5
  _BYTE *data_buffer_end; // r8
  _BYTE *current_data_byte; // r0
  int i2c_context_local; // [sp+4h] [bp-824h] BYREF
  void *received_data_ptr; // [sp+Ch] [bp-81Ch] BYREF
  char log_buf[2072]; // [sp+10h] [bp-818h] BYREF

  i2c_context_local = i2c_context;
  if ( pthread_mutex_lock(&stru_5051A8) )
  {
    strcpy(log_buf, "failed to i2c lock\n");
    logMessage(0, log_buf, 0);
    return -1;
  }
  else
  {
    received_data_ptr = 0;
    if ( process_command_and_read_response((int *)dword_5051A4, (int)&i2c_context_local, &received_data_ptr) == 1 )
    {
      received_data = received_data_ptr;
      i2c_control_value = (*(_DWORD *)received_data_ptr << 26) | 0x2000000 | (*((_DWORD *)received_data_ptr + 1) >> 4 << 20) | (*((_DWORD *)received_data_ptr + 1) << 15) & 0x70000;
      if ( data_length )
      {
        data_buffer_end = &data_buffer[data_length];
        while ( 1 )
        {
          if ( !check_asic_ready() )
          {
            free(received_data_ptr);
            strcpy(log_buf, "iic not ready 4 read1\n");
            logMessage(0, log_buf, 0);
            pthread_mutex_unlock(&stru_5051A8);
            return -2;
          }
          set_register_value(12, i2c_control_value);
          current_data_byte = data_buffer++;
          if ( !poll_register_for_completion(current_data_byte) )
            break;
          if ( data_buffer == data_buffer_end )
          {
            received_data = received_data_ptr;
            goto LABEL_10;
          }
        }
        free(received_data_ptr);
        strcpy(log_buf, "iic not ready 4 read2\n");
        logMessage(0, log_buf, 0);
        pthread_mutex_unlock(&stru_5051A8);
        return -3;
      }
      else
      {
LABEL_10:
        free(received_data);
        pthread_mutex_unlock(&stru_5051A8);
        return data_length;
      }
    }
    else
    {
      snprintf(log_buf, 2048u, "ctx %d not inited\n", i2c_context_local);
      logMessage(0, log_buf, 0);
      pthread_mutex_unlock(&stru_5051A8);
      return -2;
    }
  }
}
// 5051A4: using guessed type int dword_5051A4;

//----- (00049CFC) --------------------------------------------------------
int __fastcall write_i2c_data(int context_id, int start_address, int num_bytes)
{
  _DWORD *data_buffer_ptr; // r8
  int end_address; // r6
  int current_address; // r5
  int final_address; // r6
  int current_byte; // t1
  int register_value; // r4
  int ctx_id; // [sp+4h] [bp-824h] BYREF
  void *data_buffer; // [sp+Ch] [bp-81Ch] BYREF
  char log_message_buffer[2072]; // [sp+10h] [bp-818h] BYREF

  ctx_id = context_id;
  if ( pthread_mutex_lock(&stru_5051A8) )
  {
    strcpy(log_message_buffer, "failed to i2c lock\n");
    logMessage(0, log_message_buffer, 0);
    return -1;
  }
  else
  {
    data_buffer = 0;
    if ( process_command_and_read_response((int *)dword_5051A4, (int)&ctx_id, &data_buffer) == 1 )
    {
      data_buffer_ptr = data_buffer;
      if ( num_bytes )
      {
        end_address = start_address + num_bytes;
        current_address = start_address - 1;
        final_address = end_address - 1;
        do
        {
          current_byte = *(unsigned __int8 *)++current_address;
          register_value = current_byte | (data_buffer_ptr[1] >> 4 << 20) | (*data_buffer_ptr << 26) | (data_buffer_ptr[1] << 15) & 0x70000;
          if ( !check_asic_ready() )
          {
            free(data_buffer);
            strcpy(log_message_buffer, "iic not ready 4 write\n");
            logMessage(0, log_message_buffer, 0);
            pthread_mutex_unlock(&stru_5051A8);
            return -2;
          }
          set_register_value(12, register_value);
        }
        while ( final_address != current_address );
        data_buffer_ptr = data_buffer;
      }
      free(data_buffer_ptr);
      pthread_mutex_unlock(&stru_5051A8);
      return num_bytes;
    }
    else
    {
      snprintf(log_message_buffer, 2048u, "ctx %d not inited\n", ctx_id);
      logMessage(0, log_message_buffer, 0);
      pthread_mutex_unlock(&stru_5051A8);
      return -2;
    }
  }
}
// 5051A4: using guessed type int dword_5051A4;

//----- (00049E8C) --------------------------------------------------------
int __fastcall i2c_read_registers(
        int i2c_context,
        unsigned __int8 *register_address,
        int register_address_length,
        int read_buffer,
        int bytes_to_read)
{
  int mutex_lock_result; // r5
  _DWORD *i2c_data_pointer; // r9
  _BYTE *current_byte_pointer; // r0
  int i2c_read_command; // r4
  int i2c_context_reference; // [sp+4h] [bp-82Ch] BYREF
  void *i2c_buffer_pointer; // [sp+Ch] [bp-824h] BYREF
  char log_message_buffer[2080]; // [sp+10h] [bp-820h] BYREF

  i2c_context_reference = i2c_context;
  if ( register_address_length == 1 )
  {
    mutex_lock_result = pthread_mutex_lock(&stru_5051A8);
    if ( mutex_lock_result )
    {
      strcpy(log_message_buffer, "failed to i2c lock\n");
      logMessage(0, log_message_buffer, 0);
      return -1;
    }
    else
    {
      i2c_buffer_pointer = 0;
      if ( process_command_and_read_response((int *)dword_5051A4, (int)&i2c_context_reference, &i2c_buffer_pointer) == 1 )
      {
        i2c_data_pointer = i2c_buffer_pointer;
        if ( bytes_to_read )
        {
          while ( 1 )
          {
            i2c_read_command = (*i2c_data_pointer << 26) | 0x3000000 | (i2c_data_pointer[1] >> 4 << 20) | (i2c_data_pointer[1] << 15) & 0x70000 | ((*register_address + mutex_lock_result) << 8);
            if ( !check_asic_ready() )
            {
              strcpy(log_message_buffer, "iic not ready 4 read1\n");
              logMessage(0, log_message_buffer, 0);
              free(i2c_buffer_pointer);
              pthread_mutex_unlock(&stru_5051A8);
              return -2;
            }
            set_register_value(12, i2c_read_command);
            current_byte_pointer = (_BYTE *)(read_buffer + mutex_lock_result++);
            if ( !poll_register_for_completion(current_byte_pointer) )
              break;
            if ( bytes_to_read == mutex_lock_result )
            {
              i2c_data_pointer = i2c_buffer_pointer;
              goto LABEL_11;
            }
          }
          strcpy(log_message_buffer, "iic failed to read data\n");
          logMessage(0, log_message_buffer, 0);
          free(i2c_buffer_pointer);
          pthread_mutex_unlock(&stru_5051A8);
          return -3;
        }
        else
        {
LABEL_11:
          free(i2c_data_pointer);
          pthread_mutex_unlock(&stru_5051A8);
          return bytes_to_read;
        }
      }
      else
      {
        snprintf(log_message_buffer, 2048u, "ctx %d not inited\n", i2c_context_reference);
        logMessage(0, log_message_buffer, 0);
        pthread_mutex_unlock(&stru_5051A8);
        return -2;
      }
    }
  }
  else
  {
    strcpy(log_message_buffer, "more than one byte reg address is not supported\n");
    logMessage(0, log_message_buffer, 0);
    return -3;
  }
}
// 5051A4: using guessed type int dword_5051A4;

//----- (0004A0DC) --------------------------------------------------------
int __fastcall write_i2c_register(
        int register_address,
        unsigned __int8 *data_buffer,
        int register_address_size,
        int data_size,
        int data_count)
{
  int lock_result; // r8
  _DWORD *register_pointer; // r9
  int data_index; // r5
  int current_data_byte; // t1
  int masked_data; // r1
  int register_value; // r4
  int scoped_register_address; // [sp+4h] [bp-82Ch] BYREF
  void *register_data_ptr; // [sp+Ch] [bp-824h] BYREF
  char log_buffer[2080]; // [sp+10h] [bp-820h] BYREF

  scoped_register_address = register_address;
  if ( register_address_size == 1 )
  {
    lock_result = pthread_mutex_lock(&stru_5051A8);
    if ( lock_result )
    {
      strcpy(log_buffer, "failed to i2c lock\n");
      logMessage(0, log_buffer, 0);
      return -1;
    }
    else
    {
      register_data_ptr = 0;
      if ( process_command_and_read_response((int *)dword_5051A4, (int)&scoped_register_address, &register_data_ptr) == 1 )
      {
        register_pointer = register_data_ptr;
        if ( data_count )
        {
          data_index = data_size - 1;
          do
          {
            current_data_byte = *(unsigned __int8 *)++data_index;
            masked_data = *data_buffer + lock_result++;
            register_value = (*register_pointer << 26) | 0x1000000 | (register_pointer[1] >> 4 << 20) | current_data_byte | (register_pointer[1] << 15) & 0x70000 | (masked_data << 8);
            if ( !check_asic_ready() )
            {
              strcpy(log_buffer, "iic not ready 4 write\n");
              logMessage(0, log_buffer, 0);
              free(register_data_ptr);
              pthread_mutex_unlock(&stru_5051A8);
              return -2;
            }
            set_register_value(12, register_value);
          }
          while ( data_count != lock_result );
          register_pointer = register_data_ptr;
        }
        free(register_pointer);
        pthread_mutex_unlock(&stru_5051A8);
        return data_count;
      }
      else
      {
        snprintf(log_buffer, 2048u, "ctx %d not inited\n", scoped_register_address);
        logMessage(0, log_buffer, 0);
        pthread_mutex_unlock(&stru_5051A8);
        return -2;
      }
    }
  }
  else
  {
    strcpy(log_buffer, "more than one byte reg address is not supported\n");
    logMessage(0, log_buffer, 0);
    return -3;
  }
}
// 5051A4: using guessed type int dword_5051A4;

//----- (0004A2D8) --------------------------------------------------------
int __fastcall configure_i2c_device(int device_id, int config_type, int config_value)
{
  _DWORD *worker_struct; // r4
  int *device_data_ptr; // r0
  int *device_data; // r5
  int device_address; // r12
  void (__fastcall *send_config)(_DWORD *, _DWORD *, int); // r3
  _DWORD config_buffer[518]; // [sp+0h] [bp-818h] BYREF

  if ( pthread_mutex_lock(&stru_5051A8) )
  {
    strcpy((char *)config_buffer, "failed to i2c lock\n");
    logMessage(0, (const char *)config_buffer, 0);
    return -4;
  }
  else
  {
    worker_struct = create_worker_struct(dword_5051A4);
    if ( ((int (*)(void))*worker_struct)() )
    {
      while ( ***(_DWORD ***)(worker_struct[5] + 16) != device_id )
      {
        if ( !((int (__fastcall *)(_DWORD *))*worker_struct)(worker_struct) )
          goto LABEL_8;
      }
      device_data_ptr = (int *)((int (*)(void))worker_struct[2])();
      device_data = device_data_ptr;
      if ( config_type == 1795 )
      {
        device_address = *device_data_ptr;
        send_config = (void (__fastcall *)(_DWORD *, _DWORD *, int))worker_struct[1];
        config_buffer[1] = config_value;
        config_buffer[0] = device_address;
        send_config(worker_struct, config_buffer, 8);
        free(device_data);
      }
    }
LABEL_8:
    j_free(worker_struct);
    pthread_mutex_unlock(&stru_5051A8);
    return 0;
  }
}
// 5051A4: using guessed type int dword_5051A4;

//----- (0004A3EC) --------------------------------------------------------
int __fastcall set_i2c_register(int register_address, int register_value)
{
  _DWORD *worker_struct; // r4
  _DWORD *read_buffer; // r5
  void (__fastcall *write_function)(_DWORD *, _DWORD *, int); // r3
  int read_value; // r12
  _DWORD write_data[516]; // [sp+0h] [bp-810h] BYREF

  if ( pthread_mutex_lock(&stru_5051A8) )
  {
    strcpy((char *)write_data, "failed to i2c lock\n");
    logMessage(0, (const char *)write_data, 0);
    return -4;
  }
  else
  {
    worker_struct = create_worker_struct(dword_5051A4);
    if ( ((int (*)(void))*worker_struct)() )
    {
      while ( ***(_DWORD ***)(worker_struct[5] + 16) != register_address )
      {
        if ( !((int (__fastcall *)(_DWORD *))*worker_struct)(worker_struct) )
          goto LABEL_7;
      }
      read_buffer = (_DWORD *)((int (*)(void))worker_struct[2])();
      write_function = (void (__fastcall *)(_DWORD *, _DWORD *, int))worker_struct[1];
      read_value = read_buffer[1];
      write_data[0] = register_value;
      write_data[1] = read_value;
      write_function(worker_struct, write_data, 8);
      free(read_buffer);
    }
LABEL_7:
    j_free(worker_struct);
    pthread_mutex_unlock(&stru_5051A8);
    return 0;
  }
}
// 5051A4: using guessed type int dword_5051A4;

//----- (0004A4E8) --------------------------------------------------------
int __fastcall copy_memory(void *source, size_t num_bytes, const void **destination)
{
  return copy_data_to_buffer(destination, source, num_bytes);
}

//----- (0004A4FC) --------------------------------------------------------
int __fastcall copy_data(void *source, size_t size, _DWORD *state)
{
  int current_offset; // r12
  size_t new_offset; // r3

  current_offset = state[1];
  new_offset = current_offset + size;
  if ( current_offset + size <= *state )
  {
    memcpy((void *)(state[2] + current_offset), source, size);
    new_offset = size + state[1];
  }
  state[1] = new_offset;
  return 0;
}

//----- (0004A540) --------------------------------------------------------
size_t __fastcall write_to_file(const void *buffer, size_t size, FILE *file_stream)
{
  size_t write_result; // r0

  write_result = fwrite(buffer, size, 1u, file_stream) - 1;
  if ( write_result )
    return -1;
  return write_result;
}

//----- (0004A55C) --------------------------------------------------------
size_t __fastcall write_full_buffer(void *buffer, size_t size, int *file_descriptor)
{
  size_t bytes_left; // r0

  bytes_left = size - write(*file_descriptor, buffer, size);
  if ( bytes_left )
    return -1;
  return bytes_left;
}

//----- (0004A584) --------------------------------------------------------
int __fastcall compare_strings(const char **first_string_ptr, const char **second_string_ptr)
{
  return strcmp(*first_string_ptr, *second_string_ptr);
}

//----- (0004A590) --------------------------------------------------------
int __fastcall write_escaped_json_string(
        char *input_string,
        int length,
        int (__fastcall *output_function)(char *, int, int),
        int output_arg,
        unsigned int flags)
{
  char *input_string_end; // r8
  char *current_position; // r10
  char *next_position; // r5
  bool is_quote_or_backslash; // zf
  int should_escape; // r1
  char *escape_sequence; // r0
  int escape_sequence_length; // r1
  unsigned int high_surrogate; // r3
  int low_surrogate; // [sp+0h] [bp-50h]
  int current_char; // [sp+14h] [bp-3Ch] BYREF
  char escape_buffer[56]; // [sp+18h] [bp-38h] BYREF

  current_char = 0;
  if ( output_function("\"", 1, output_arg) )
    return -1;
  input_string_end = &input_string[length];
  for ( current_position = input_string; current_position < input_string_end; current_position = next_position )
  {
    next_position = extract_chip_temperature_info(current_position, input_string_end - current_position, &current_char);
    if ( !next_position )
      return -1;
    is_quote_or_backslash = current_char == 34;
    if ( current_char != 34 )
      is_quote_or_backslash = current_char == 92;
    should_escape = is_quote_or_backslash;
    if ( current_char <= 31 )
      should_escape |= 1u;
    if ( !should_escape && ((current_char == 47) & (flags >> 10)) == 0 && ((current_char > 127) & (flags >> 6)) == 0 )
      continue;
    if ( input_string != current_position && output_function(input_string, current_position - input_string, output_arg) )
      return -1;
    if ( current_position == next_position )
      return output_function("\"", 1, output_arg);
    if ( current_char == 12 )
    {
      escape_sequence_length = 2;
      escape_sequence = "\\f";
      goto LABEL_26;
    }
    if ( current_char <= 12 )
    {
      switch ( current_char )
      {
        case 9:
          escape_sequence = "\\t";
          escape_sequence_length = 2;
          goto LABEL_26;
        case 10:
          escape_sequence = "\\n";
          escape_sequence_length = 2;
          goto LABEL_26;
        case 8:
          escape_sequence = "\\b";
          escape_sequence_length = 2;
          goto LABEL_26;
      }
LABEL_32:
      if ( current_char >= 65536 )
      {
        high_surrogate = ((unsigned int)(current_char - 65536) >> 10) & 0x3FF | 0xD800;
        low_surrogate = (current_char - 65536) & 0x3FF | 0xDC00;
        current_char -= 65536;
        snprintf(escape_buffer, 13u, "\\u%04X\\u%04X", high_surrogate, low_surrogate);
        escape_sequence = escape_buffer;
        escape_sequence_length = 12;
        goto LABEL_26;
      }
LABEL_33:
      snprintf(escape_buffer, 13u, "\\u%04X");
      escape_sequence = escape_buffer;
      escape_sequence_length = 6;
      goto LABEL_26;
    }
    if ( current_char == 34 )
    {
      escape_sequence = "\\\"";
      escape_sequence_length = 2;
      goto LABEL_26;
    }
    if ( current_char <= 34 )
    {
      if ( current_char == 13 )
      {
        escape_sequence = "\\r";
        escape_sequence_length = 2;
        goto LABEL_26;
      }
      goto LABEL_33;
    }
    if ( current_char == 47 )
    {
      escape_sequence = "\\/";
      escape_sequence_length = 2;
      goto LABEL_26;
    }
    if ( current_char != 92 )
      goto LABEL_32;
    escape_sequence = "\\\\";
    escape_sequence_length = 2;
LABEL_26:
    if ( output_function(escape_sequence, escape_sequence_length, output_arg) )
      return -1;
    input_string = next_position;
  }
  if ( input_string == current_position || !output_function(input_string, current_position - input_string, output_arg) )
    return output_function("\"", 1, output_arg);
  return -1;
}
// 4A730: conditional instruction was optimized away because %var_3C.4 is in (E..21)

//----- (0004A818) --------------------------------------------------------
int __fastcall write_padding(
        char flags,
        int block_size,
        int unused_param,
        int (__fastcall *write_function)(__int16 *, int, int),
        int write_arg)
{
  unsigned int total_bytes_to_write; // r4
  int chunk_size; // r5

  if ( (flags & 0x1F) != 0 )
  {
    total_bytes_to_write = (flags & 0x1F) * block_size;
    if ( write_function(&word_6A02C, 1, write_arg) )
      return -1;
    if ( total_bytes_to_write )
    {
      while ( 1 )
      {
        chunk_size = total_bytes_to_write >= 32 ? 32 : total_bytes_to_write;
        if ( write_function((__int16 *)"                                ", chunk_size, write_arg) )
          break;
        total_bytes_to_write -= chunk_size;
        if ( !total_bytes_to_write )
          return 0;
      }
      return -1;
    }
    return 0;
  }
  if ( !unused_param || (flags & 0x20) != 0 )
    return 0;
  return write_function((__int16 *)" ", 1, write_arg);
}
// 6A02C: using guessed type __int16 word_6A02C;

//----- (0004A8C8) --------------------------------------------------------
int __fastcall process_address_and_add_task(int *task_list, const void *address, char *address_str)
{
  void *miner_config_pointer; // r0

  snprintf(address_str, 11u, "%p", address);
  if ( calculate_hash_and_find_task((int)task_list, address_str) )
    return -1;
  miner_config_pointer = get_miner_config_pointer();
  return add_task_with_name(task_list, address_str, (int)miner_config_pointer);
}

//----- (0004A920) --------------------------------------------------------
int __fastcall serialize_json(
        _DWORD *config_data,
        int flags,
        int indent_level,
        int *task_list,
        int (__fastcall *write_callback)(__int16 *, int, int),
        int callback_arg)
{
  int *task_list_local; // r5
  int is_compact_mode; // r8
  unsigned int flags_without_compact_flag; // r7
  char flags_copy; // r9
  char *separator; // r3
  int separator_length; // r3
  int v14; // r6
  char *second_element_info; // r5
  _DWORD *config_buffer; // r0
  __int64 hardware_status; // r0
  int chars_written; // r0
  int float_conversion_result; // r1
  int indent_next_level; // r8
  int next_element_index; // r6
  int separator_length_local; // r11
  int next_non_zero_status; // r9
  char *offset_str; // r10
  int offset_strlen; // r0
  _DWORD *status; // r0
  unsigned int element_index; // r9
  int next_indent_level; // r8
  _DWORD *current_element_ptr; // r3
  _DWORD *end_element_ptr; // r11
  unsigned int pre_last_element_index; // r10
  _DWORD *current_element_data; // r0
  int sorted_base_ptr; // r0
  int current_sorted_ptr; // r9
  unsigned int element_count; // r7
  int current_element_info; // r5
  int current_sort_index; // r8
  int sort_indent_level; // r11
  unsigned int sorted_index; // r6
  char *sorted_element_str; // r10
  char *temp_sorted_str; // t1
  _DWORD *sorted_data_ptr; // r9
  int sorted_data_strlen; // r0
  int compact_flag_state; // r8
  __int16 *colon_separator; // [sp+Ch] [bp-BCh]
  _DWORD *assoc_pointer_or_null; // [sp+Ch] [bp-BCh]
  int initial_indent_level; // [sp+Ch] [bp-BCh]
  int colon_separator_length; // [sp+10h] [bp-B8h]
  int initial_indent_level_copy; // [sp+10h] [bp-B8h]
  int is_list_empty; // [sp+14h] [bp-B4h]
  int is_compact_mode_copy; // [sp+14h] [bp-B4h]
  size_t element_count_sorted; // [sp+18h] [bp-B0h]
  int base_indent_level; // [sp+1Ch] [bp-ACh]
  int compact_mode_state; // [sp+20h] [bp-A8h]
  void *sort_base; // [sp+24h] [bp-A4h]
  _DWORD *error_success_code_ptr; // [sp+28h] [bp-A0h]
  int compact_flag_state_local; // [sp+28h] [bp-A0h]
  int sort_base_ptr_offset; // [sp+2Ch] [bp-9Ch]
  unsigned int flags_without_compact_mode; // [sp+30h] [bp-98h]
  int *task_list_param; // [sp+34h] [bp-94h]
  __int16 s[70]; // [sp+3Ch] [bp-8Ch] BYREF

  if ( !config_data )
    return -1;
  task_list_local = task_list;
  is_compact_mode = flags & 0x10000;
  flags_without_compact_flag = flags & 0xFFFEFFFF;
  flags_copy = flags;
  switch ( *config_data )
  {
    case 0:
      separator = ":";
      if ( (flags & 0x20) == 0 )
        separator = ": ";
      colon_separator = (__int16 *)separator;
      if ( (flags & 0x20) != 0 )
        separator_length = 1;
      else
        separator_length = 2;
      colon_separator_length = separator_length;
      v14 = process_address_and_add_task(task_list_local, config_data, (char *)s);
      if ( v14 )
        return -1;
      is_list_empty = is_empty_and_get_next_element(config_data);
      if ( is_compact_mode )
      {
        if ( !is_list_empty )
          goto LABEL_45;
      }
      else
      {
        if ( write_callback((__int16 *)"{", 1, callback_arg) )
          return -1;
        if ( !is_list_empty )
        {
          remove_named_task(task_list_local, (char *)s);
          return write_callback((__int16 *)"}", 1, callback_arg);
        }
      }
      if ( write_padding(flags_without_compact_flag, indent_level + 1, 0, write_callback, callback_arg) )
        return -1;
      if ( (flags_copy & 0x80) == 0 )
      {
        compact_mode_state = is_compact_mode;
        indent_next_level = indent_level + 1;
        next_element_index = is_list_empty;
        separator_length_local = colon_separator_length;
        initial_indent_level_copy = indent_level;
        while ( 1 )
        {
          next_non_zero_status = is_value_nonzero_and_matches(config_data, next_element_index);
          offset_str = (char *)check_and_calculate_offset(next_element_index);
          offset_strlen = strlen(offset_str);
          write_escaped_json_string(
            offset_str,
            offset_strlen,
            (int (__fastcall *)(char *, int, int))write_callback,
            callback_arg,
            flags_without_compact_flag);
          if ( write_callback(colon_separator, separator_length_local, callback_arg) )
            return -1;
          status = (_DWORD *)get_status_if_non_zero(next_element_index);
          if ( serialize_json(
                 status,
                 flags_without_compact_flag,
                 indent_next_level,
                 task_list_local,
                 write_callback,
                 callback_arg) )
          {
            return -1;
          }
          if ( !next_non_zero_status )
          {
            compact_flag_state = compact_mode_state;
            v14 = 0;
            if ( write_padding(flags_without_compact_flag, initial_indent_level_copy, 0, write_callback, callback_arg) )
              return -1;
            goto LABEL_68;
          }
          if ( !write_callback((__int16 *)",", 1, callback_arg) )
          {
            next_element_index = next_non_zero_status;
            if ( !write_padding(flags_without_compact_flag, indent_next_level, 1, write_callback, callback_arg) )
              continue;
          }
          return -1;
        }
      }
      error_success_code_ptr = get_error_or_success_code_pointer(config_data);
      sorted_base_ptr = check_and_process_result(4 * (_DWORD)error_success_code_ptr);
      sort_base = (void *)sorted_base_ptr;
      if ( !sorted_base_ptr )
        return -1;
      flags_without_compact_mode = flags_without_compact_flag;
      task_list_param = task_list_local;
      current_sorted_ptr = sorted_base_ptr - 4;
      sort_base_ptr_offset = sorted_base_ptr - 4;
      element_count = 0;
      current_element_info = is_list_empty;
      while ( 1 )
      {
        *(_DWORD *)(current_sorted_ptr + 4) = check_and_calculate_offset(current_element_info);
        current_sorted_ptr += 4;
        current_element_info = is_value_nonzero_and_matches(config_data, current_element_info);
        if ( !current_element_info )
          break;
        ++element_count;
      }
      element_count_sorted = element_count + 1;
      task_list_local = task_list_param;
      if ( error_success_code_ptr != (_DWORD *)(element_count + 1) )
        _assert_fail("i == size", "dump.c", 352u, "do_dump");
      qsort(sort_base, element_count_sorted, 4u, (__compar_fn_t)compare_strings);
      compact_flag_state_local = is_compact_mode;
      current_sort_index = sort_base_ptr_offset;
      sort_indent_level = indent_level + 1;
      sorted_index = 0;
      base_indent_level = indent_level;
      do
      {
        temp_sorted_str = *(char **)(current_sort_index + 4);
        current_sort_index += 4;
        sorted_element_str = temp_sorted_str;
        sorted_data_ptr = (_DWORD *)initiate_task_if_ready(config_data, temp_sorted_str);
        if ( !sorted_data_ptr )
          _assert_fail("value", "dump.c", 363u, "do_dump");
        sorted_data_strlen = strlen(sorted_element_str);
        write_escaped_json_string(
          sorted_element_str,
          sorted_data_strlen,
          (int (__fastcall *)(char *, int, int))write_callback,
          callback_arg,
          flags_without_compact_mode);
        if ( write_callback(colon_separator, colon_separator_length, callback_arg)
          || serialize_json(
               sorted_data_ptr,
               flags_without_compact_mode,
               sort_indent_level,
               task_list_param,
               write_callback,
               callback_arg) )
        {
LABEL_64:
          v14 = -1;
          check_and_perform_action((int)sort_base);
          return v14;
        }
        if ( sorted_index < element_count )
        {
          if ( write_callback((__int16 *)",", 1, callback_arg)
            || write_padding(flags_without_compact_mode, sort_indent_level, 1, write_callback, callback_arg) )
          {
            goto LABEL_64;
          }
        }
        else if ( write_padding(flags_without_compact_mode, base_indent_level, 0, write_callback, callback_arg) )
        {
          goto LABEL_64;
        }
        ++sorted_index;
      }
      while ( sorted_index != element_count_sorted );
      compact_flag_state = compact_flag_state_local;
      v14 = 0;
      check_and_perform_action((int)sort_base);
LABEL_68:
      remove_named_task(task_list_local, (char *)s);
      if ( !compact_flag_state )
        return write_callback((__int16 *)"}", 1, callback_arg);
      return v14;
    case 1:
      v14 = process_address_and_add_task(task_list, config_data, (char *)s);
      if ( v14 )
        return -1;
      assoc_pointer_or_null = get_associated_pointer_or_null(config_data);
      if ( is_compact_mode )
      {
        if ( !assoc_pointer_or_null )
        {
LABEL_45:
          remove_named_task(task_list_local, (char *)s);
          return v14;
        }
      }
      else
      {
        if ( write_callback((__int16 *)"[", 1, callback_arg) )
          return -1;
        if ( !assoc_pointer_or_null )
        {
          remove_named_task(task_list_local, (char *)s);
          return write_callback(&word_6BB38, 1, callback_arg);
        }
      }
      element_index = write_padding(flags_without_compact_flag, indent_level + 1, 0, write_callback, callback_arg);
      if ( element_index )
        return -1;
      is_compact_mode_copy = is_compact_mode;
      next_indent_level = indent_level + 1;
      current_element_ptr = assoc_pointer_or_null;
      initial_indent_level = indent_level;
      end_element_ptr = current_element_ptr;
      pre_last_element_index = (unsigned int)current_element_ptr - 1;
      break;
    case 2:
      second_element_info = (char *)get_second_element_if_ready(config_data);
      config_buffer = get_config_address(config_data);
      return write_escaped_json_string(
               second_element_info,
               (int)config_buffer,
               (int (__fastcall *)(char *, int, int))write_callback,
               callback_arg,
               flags_without_compact_flag);
    case 3:
      hardware_status = get_hardware_status((int)config_data);
      chars_written = snprintf((char *)s, 100u, "%lld", hardware_status);
      return write_callback(s, chars_written, callback_arg);
    case 4:
      sub_4EA70();
      float_conversion_result = format_float_to_string((char *)s, 100u);
      if ( float_conversion_result < 0 )
        return -1;
      return write_callback(s, float_conversion_result, callback_arg);
    case 5:
      return write_callback((__int16 *)"true", 4, callback_arg);
    case 6:
      return write_callback((__int16 *)"false", 5, callback_arg);
    case 7:
      return write_callback((__int16 *)"null", 4, callback_arg);
    default:
      return -1;
  }
  do
  {
    current_element_data = get_task_by_index(config_data, element_index);
    v14 = serialize_json(
            current_element_data,
            flags_without_compact_flag,
            next_indent_level,
            task_list_local,
            write_callback,
            callback_arg);
    if ( v14 )
      return -1;
    if ( pre_last_element_index <= element_index )
    {
      if ( write_padding(flags_without_compact_flag, initial_indent_level, 0, write_callback, callback_arg) )
        return -1;
    }
    else if ( write_callback((__int16 *)",", 1, callback_arg)
           || write_padding(flags_without_compact_flag, next_indent_level, 1, write_callback, callback_arg) )
    {
      return -1;
    }
    ++element_index;
  }
  while ( end_element_ptr != (_DWORD *)element_index );
  remove_named_task(task_list_local, (char *)s);
  if ( !is_compact_mode_copy )
    return write_callback(&word_6BB38, 1, callback_arg);
  return v14;
}
// 4A950: control flows out of bounds to 4A954
// 6BB38: using guessed type __int16 word_6BB38;
// 4A920: using guessed type __int16 s[70];

//----- (0004B130) --------------------------------------------------------
int __fastcall process_miner_command(
        _DWORD *command_args,
        int (__fastcall *callback)(__int16 *, int, int),
        int callback_arg,
        int command_flags)
{
  int v8; // r4
  int miner_data[13]; // [sp+Ch] [bp-34h] BYREF

  if ( (command_flags & 0x200) == 0 && (!command_args || *command_args > 1u) || initialize_miner_queue(miner_data) )
    return -1;
  v8 = serialize_json(command_args, command_flags, 0, miner_data, callback, callback_arg);
  update_counters_and_check_status((int)miner_data);
  return v8;
}
// 4B130: using guessed type int var_34[13];

//----- (0004B1A8) --------------------------------------------------------
_BYTE *__fastcall initialize_and_process_command(_DWORD *command_parameters, int unknown_parameter)
{
  _BYTE *result_or_null; // r4
  const char *memory_data_as_string; // r0
  int memory_buffer[7]; // [sp+4h] [bp-1Ch] BYREF

  result_or_null = (_BYTE *)initialize_command_buffer(memory_buffer);
  if ( result_or_null )
    return 0;
  if ( !process_miner_command(
          command_parameters,
          (int (__fastcall *)(__int16 *, int, int))copy_memory,
          (int)memory_buffer,
          unknown_parameter) )
  {
    memory_data_as_string = (const char *)get_first_dword_from_address((int)memory_buffer);
    result_or_null = copy_input_string(memory_data_as_string);
  }
  perform_maintenance_and_reset(memory_buffer);
  return result_or_null;
}
// 4B1A8: using guessed type int var_1C[7];

//----- (0004B250) --------------------------------------------------------
int __fastcall process_command_and_write_to_file(
        _DWORD *command_buffer_ptr,
        int write_file_param2,
        int write_file_param3)
{
  return process_miner_command(
           command_buffer_ptr,
           (int (__fastcall *)(__int16 *, int, int))write_to_file,
           write_file_param2,
           write_file_param3);
}

//----- (0004B264) --------------------------------------------------------
int __fastcall save_command_to_file(_DWORD *command_data, int file_path, int command_length)
{
  FILE *file_handle; // r4
  int write_result; // r5

  file_handle = (FILE *)fopen64(file_path, "w");
  if ( !file_handle )
    return -1;
  write_result = process_miner_command(
                   command_data,
                   (int (__fastcall *)(__int16 *, int, int))write_to_file,
                   (int)file_handle,
                   command_length);
  if ( fclose(file_handle) )
    return -1;
  return write_result;
}
// 124E4: using guessed type int __fastcall fopen64(_DWORD, _DWORD);

//----- (0004B2C8) --------------------------------------------------------
int __fastcall process_full_buffer_command(_DWORD *command_buffer, int write_command_id, int write_command_param)
{
  int write_id_ref; // [sp+4h] [bp-Ch] BYREF

  write_id_ref = write_command_id;
  return process_miner_command(
           command_buffer,
           (int (__fastcall *)(__int16 *, int, int))write_full_buffer,
           (int)&write_id_ref,
           write_command_param);
}

//----- (0004B2F4) --------------------------------------------------------
int __fastcall calculate_hash(unsigned __int16 *input_data, unsigned int data_len, int initial_value)
{
  unsigned int hash_value; // r12
  unsigned __int16 *data_ptr; // r4
  int partial_hash_a; // r3
  int partial_hash_b; // lr
  int data_val_1; // r6
  int data_val_2; // r5
  int data_val_3; // r3
  int sum_val_1; // lr
  int xor_val_1; // r2
  int sum_val_2; // r3
  int sum_val_3; // r5
  int xor_val_2; // r2
  int sum_val_4; // r12
  int xor_val_3; // r2
  int sum_val_5; // lr
  int xor_val_4; // r3
  int sub_val_1; // r2
  int xor_val_5; // r2
  int sub_val_2; // r3
  unsigned __int16 *word_data_ptr; // r4
  int word_val_1; // r6
  int word_val_2; // r5
  int word_val_3; // r7
  int word_val_4; // r2
  int sum_word_val_1; // r3
  int xor_word_val_1; // r12
  int sum_word_val_2; // lr
  int sub_word_val_1; // r2
  int sum_word_val_3; // lr
  int xor_word_val_2; // r3
  int sum_word_val_4; // r12
  int xor_word_val_3; // r2
  int sum_word_val_5; // r5
  int xor_word_val_4; // r2
  int sub_word_val_2; // r3
  int xor_word_val_5; // r2
  unsigned __int16 *byte_data_ptr; // r4
  int byte_val_1; // r6
  int byte_val_2; // r2
  int byte_val_3; // r7
  int byte_val_4; // r8
  int sum_byte_val_1; // r3
  int xor_byte_val_1; // r12
  int sum_byte_val_2; // lr
  int sub_byte_val_1; // r2
  int sum_byte_val_3; // lr
  int xor_byte_val_2; // r3
  int sum_byte_val_4; // r12
  int xor_byte_val_3; // r2
  int sum_byte_val_5; // r5
  int xor_byte_val_4; // r2
  int sub_byte_val_2; // r3
  int xor_byte_val_5; // r2
  int final_val; // r12
  int final_xor_1; // r3
  int final_xor_2; // r12
  int final_xor_3; // lr
  int final_xor_4; // r3
  int final_xor_5; // r12
  int final_xor_6; // r12
  int extra_val; // r4

  hash_value = initial_value - 559038737 + data_len;
  if ( ((unsigned __int8)input_data & 3) == 0 )
  {
    if ( data_len <= 12 )
    {
      partial_hash_a = initial_value - 559038737 + data_len;
      partial_hash_b = partial_hash_a;
    }
    else
    {
      data_ptr = input_data + 6;
      partial_hash_a = initial_value - 559038737 + data_len;
      partial_hash_b = partial_hash_a;
      do
      {
        data_len -= 12;
        data_val_1 = *((_DWORD *)data_ptr - 3);
        data_val_2 = *((_DWORD *)data_ptr - 2);
        input_data = data_ptr;
        data_val_3 = partial_hash_a + *((_DWORD *)data_ptr - 1);
        data_ptr += 6;
        sum_val_1 = partial_hash_b + data_val_2;
        xor_val_1 = (data_val_1 - data_val_3 + hash_value) ^ __ROR4__(data_val_3, 28);
        sum_val_2 = sum_val_1 + data_val_3;
        sum_val_3 = xor_val_1 + sum_val_2;
        xor_val_2 = (sum_val_1 - xor_val_1) ^ __ROR4__(xor_val_1, 26);
        sum_val_4 = xor_val_2 + sum_val_3;
        xor_val_3 = (sum_val_2 - xor_val_2) ^ __ROR4__(xor_val_2, 24);
        sum_val_5 = xor_val_3 + sum_val_4;
        xor_val_4 = (sum_val_3 - xor_val_3) ^ __ROR4__(xor_val_3, 16);
        sub_val_1 = sum_val_4 - xor_val_4;
        hash_value = xor_val_4 + sum_val_5;
        xor_val_5 = sub_val_1 ^ __ROR4__(xor_val_4, 13);
        sub_val_2 = sum_val_5 - xor_val_5;
        partial_hash_b = xor_val_5 + hash_value;
        partial_hash_a = sub_val_2 ^ __ROR4__(xor_val_5, 28);
      }
      while ( data_len > 12 );
    }
    switch ( data_len )
    {
      case 1u:
        goto LABEL_27;
      case 2u:
        goto LABEL_32;
      case 3u:
        final_val = (*(_DWORD *)input_data & 0xFFFFFF) + hash_value;
        goto LABEL_28;
      case 4u:
        final_val = hash_value + *(_DWORD *)input_data;
        goto LABEL_28;
      case 5u:
        partial_hash_b += *((unsigned __int8 *)input_data + 4);
        final_val = hash_value + *(_DWORD *)input_data;
        goto LABEL_28;
      case 6u:
        partial_hash_b += input_data[2];
        final_val = hash_value + *(_DWORD *)input_data;
        goto LABEL_28;
      case 7u:
        final_val = hash_value + *(_DWORD *)input_data;
        partial_hash_b += *((_DWORD *)input_data + 1) & 0xFFFFFF;
        goto LABEL_28;
      case 8u:
        partial_hash_b += *((_DWORD *)input_data + 1);
        final_val = hash_value + *(_DWORD *)input_data;
        goto LABEL_28;
      case 9u:
        extra_val = *((unsigned __int8 *)input_data + 8);
        goto LABEL_35;
      case 10u:
        extra_val = input_data[4];
        goto LABEL_35;
      case 11u:
        partial_hash_a += *((_DWORD *)input_data + 2) & 0xFFFFFF;
        partial_hash_b += *((_DWORD *)input_data + 1);
        final_val = hash_value + *(_DWORD *)input_data;
        goto LABEL_28;
      case 12u:
        extra_val = *((_DWORD *)input_data + 2);
LABEL_35:
        partial_hash_a += extra_val;
        partial_hash_b += *((_DWORD *)input_data + 1);
        final_val = hash_value + *(_DWORD *)input_data;
        goto LABEL_28;
      default:
        return partial_hash_a;
    }
  }
  if ( ((unsigned __int8)input_data & 1) == 0 )
  {
    if ( data_len <= 12 )
    {
      partial_hash_a = initial_value - 559038737 + data_len;
      partial_hash_b = partial_hash_a;
    }
    else
    {
      word_data_ptr = input_data + 6;
      partial_hash_a = initial_value - 559038737 + data_len;
      partial_hash_b = partial_hash_a;
      do
      {
        word_val_1 = *(word_data_ptr - 1);
        data_len -= 12;
        word_val_2 = *(word_data_ptr - 2);
        word_val_3 = *(word_data_ptr - 5);
        input_data = word_data_ptr;
        word_val_4 = *(word_data_ptr - 6);
        word_data_ptr += 6;
        sum_word_val_1 = word_val_2 + (word_val_1 << 16) + partial_hash_a;
        xor_word_val_1 = (word_val_4 + (word_val_3 << 16) - sum_word_val_1 + hash_value) ^ __ROR4__(sum_word_val_1, 28);
        sum_word_val_2 = *(word_data_ptr - 10) + (*(word_data_ptr - 9) << 16) + partial_hash_b;
        sub_word_val_1 = sum_word_val_2 - xor_word_val_1;
        sum_word_val_3 = sum_word_val_2 + sum_word_val_1;
        xor_word_val_2 = sub_word_val_1 ^ __ROR4__(xor_word_val_1, 26);
        sum_word_val_4 = xor_word_val_1 + sum_word_val_3;
        xor_word_val_3 = (sum_word_val_3 - xor_word_val_2) ^ __ROR4__(xor_word_val_2, 24);
        sum_word_val_5 = xor_word_val_3 + xor_word_val_2 + sum_word_val_4;
        xor_word_val_4 = (sum_word_val_4 - xor_word_val_3) ^ __ROR4__(xor_word_val_3, 16);
        sub_word_val_2 = xor_word_val_2 + sum_word_val_4 - xor_word_val_4;
        hash_value = xor_word_val_4 + sum_word_val_5;
        xor_word_val_5 = sub_word_val_2 ^ __ROR4__(xor_word_val_4, 13);
        partial_hash_b = xor_word_val_5 + hash_value;
        partial_hash_a = (sum_word_val_5 - xor_word_val_5) ^ __ROR4__(xor_word_val_5, 28);
      }
      while ( data_len > 12 );
    }
    switch ( data_len )
    {
      case 1u:
        goto LABEL_27;
      case 2u:
        goto LABEL_32;
      case 3u:
        hash_value += *((unsigned __int8 *)input_data + 2) << 16;
LABEL_32:
        final_val = *input_data + hash_value;
        goto LABEL_28;
      case 4u:
        goto LABEL_50;
      case 5u:
        partial_hash_b += *((unsigned __int8 *)input_data + 4);
LABEL_50:
        final_val = *input_data + hash_value + (input_data[1] << 16);
        goto LABEL_28;
      case 6u:
        goto LABEL_44;
      case 7u:
        partial_hash_b += *((unsigned __int8 *)input_data + 6) << 16;
LABEL_44:
        final_val = *input_data + hash_value + (input_data[1] << 16);
        partial_hash_b += input_data[2];
        goto LABEL_28;
      case 8u:
        goto LABEL_46;
      case 9u:
        partial_hash_a += *((unsigned __int8 *)input_data + 8);
LABEL_46:
        partial_hash_b += input_data[2] + (input_data[3] << 16);
        final_val = *input_data + hash_value + (input_data[1] << 16);
        goto LABEL_28;
      case 10u:
        goto LABEL_48;
      case 11u:
        partial_hash_a += *((unsigned __int8 *)input_data + 10) << 16;
LABEL_48:
        partial_hash_b += input_data[2] + (input_data[3] << 16);
        final_val = *input_data + hash_value + (input_data[1] << 16);
        partial_hash_a += input_data[4];
        goto LABEL_28;
      case 12u:
        partial_hash_a += input_data[4] + (input_data[5] << 16);
        partial_hash_b += input_data[2] + (input_data[3] << 16);
        final_val = *input_data + hash_value + (input_data[1] << 16);
        goto LABEL_28;
      default:
        return partial_hash_a;
    }
  }
  if ( data_len > 12 )
  {
    byte_data_ptr = input_data + 6;
    partial_hash_a = initial_value - 559038737 + data_len;
    partial_hash_b = partial_hash_a;
    do
    {
      byte_val_1 = *((unsigned __int8 *)byte_data_ptr - 2);
      data_len -= 12;
      byte_val_2 = *((unsigned __int8 *)byte_data_ptr - 10);
      byte_val_3 = *((unsigned __int8 *)byte_data_ptr - 3);
      input_data = byte_data_ptr;
      byte_val_4 = *((unsigned __int8 *)byte_data_ptr - 11);
      byte_data_ptr += 6;
      sum_byte_val_1 = (byte_val_1 << 16)
                     + (byte_val_3 << 8)
                     + *((unsigned __int8 *)byte_data_ptr - 16)
                     + (*((unsigned __int8 *)byte_data_ptr - 13) << 24)
                     + partial_hash_a;
      xor_byte_val_1 = ((byte_val_2 << 16)
                      + (byte_val_4 << 8)
                      + *((unsigned __int8 *)byte_data_ptr - 24)
                      + (*((unsigned __int8 *)byte_data_ptr - 21) << 24)
                      - sum_byte_val_1
                      + hash_value) ^ __ROR4__(sum_byte_val_1, 28);
      sum_byte_val_2 = (*((unsigned __int8 *)byte_data_ptr - 18) << 16)
                     + (*((unsigned __int8 *)byte_data_ptr - 19) << 8)
                     + *((unsigned __int8 *)byte_data_ptr - 20)
                     + (*((unsigned __int8 *)byte_data_ptr - 17) << 24)
                     + partial_hash_b;
      sub_byte_val_1 = sum_byte_val_2 - xor_byte_val_1;
      sum_byte_val_3 = sum_byte_val_2 + sum_byte_val_1;
      xor_byte_val_2 = sub_byte_val_1 ^ __ROR4__(xor_byte_val_1, 26);
      sum_byte_val_4 = xor_byte_val_1 + sum_byte_val_3;
      xor_byte_val_3 = (sum_byte_val_3 - xor_byte_val_2) ^ __ROR4__(xor_byte_val_2, 24);
      sum_byte_val_5 = xor_byte_val_3 + xor_byte_val_2 + sum_byte_val_4;
      xor_byte_val_4 = (sum_byte_val_4 - xor_byte_val_3) ^ __ROR4__(xor_byte_val_3, 16);
      sub_byte_val_2 = xor_byte_val_2 + sum_byte_val_4 - xor_byte_val_4;
      hash_value = xor_byte_val_4 + sum_byte_val_5;
      xor_byte_val_5 = sub_byte_val_2 ^ __ROR4__(xor_byte_val_4, 13);
      partial_hash_b = xor_byte_val_5 + hash_value;
      partial_hash_a = (sum_byte_val_5 - xor_byte_val_5) ^ __ROR4__(xor_byte_val_5, 28);
    }
    while ( data_len > 12 );
  }
  else
  {
    partial_hash_a = initial_value - 559038737 + data_len;
    partial_hash_b = partial_hash_a;
  }
  switch ( data_len )
  {
    case 1u:
      goto LABEL_27;
    case 2u:
      goto LABEL_26;
    case 3u:
      goto LABEL_25;
    case 4u:
      goto LABEL_24;
    case 5u:
      goto LABEL_23;
    case 6u:
      goto LABEL_22;
    case 7u:
      goto LABEL_21;
    case 8u:
      goto LABEL_20;
    case 9u:
      goto LABEL_19;
    case 10u:
      goto LABEL_18;
    case 11u:
      goto LABEL_17;
    case 12u:
      partial_hash_a += *((unsigned __int8 *)input_data + 11) << 24;
LABEL_17:
      partial_hash_a += *((unsigned __int8 *)input_data + 10) << 16;
LABEL_18:
      partial_hash_a += *((unsigned __int8 *)input_data + 9) << 8;
LABEL_19:
      partial_hash_a += *((unsigned __int8 *)input_data + 8);
LABEL_20:
      partial_hash_b += *((unsigned __int8 *)input_data + 7) << 24;
LABEL_21:
      partial_hash_b += *((unsigned __int8 *)input_data + 6) << 16;
LABEL_22:
      partial_hash_b += *((unsigned __int8 *)input_data + 5) << 8;
LABEL_23:
      partial_hash_b += *((unsigned __int8 *)input_data + 4);
LABEL_24:
      hash_value += *((unsigned __int8 *)input_data + 3) << 24;
LABEL_25:
      hash_value += *((unsigned __int8 *)input_data + 2) << 16;
LABEL_26:
      hash_value += *((unsigned __int8 *)input_data + 1) << 8;
LABEL_27:
      final_val = *(unsigned __int8 *)input_data + hash_value;
LABEL_28:
      final_xor_1 = (partial_hash_a ^ partial_hash_b) - __ROR4__(partial_hash_b, 18);
      final_xor_2 = (final_val ^ final_xor_1) - __ROR4__(final_xor_1, 21);
      final_xor_3 = (partial_hash_b ^ final_xor_2) - __ROR4__(final_xor_2, 7);
      final_xor_4 = (final_xor_1 ^ final_xor_3) - __ROR4__(final_xor_3, 16);
      final_xor_5 = (final_xor_2 ^ final_xor_4) - __ROR4__(final_xor_4, 28);
      final_xor_6 = (final_xor_3 ^ final_xor_5) - __ROR4__(final_xor_5, 18);
      partial_hash_a = (final_xor_4 ^ final_xor_6) - __ROR4__(final_xor_6, 8);
      break;
    default:
      return partial_hash_a;
  }
  return partial_hash_a;
}
// 4B3A4: control flows out of bounds to 4B3A8
// 4B48C: control flows out of bounds to 4B490
// 4B5B0: control flows out of bounds to 4B5B4

//----- (0004B838) --------------------------------------------------------
int __fastcall find_task_by_id_and_name(
        int first_task_pointer_offset,
        int *current_task_ptr_addr,
        char *searched_task_name,
        int searched_task_id)
{
  int current_task; // r4

  current_task = *current_task_ptr_addr;
  if ( *current_task_ptr_addr == first_task_pointer_offset + 12 && current_task == current_task_ptr_addr[1] )
    return 0;
  while ( *(_DWORD *)(current_task + 16) != searched_task_id
       || strcmp((const char *)(current_task + 24), searched_task_name) )
  {
    if ( current_task_ptr_addr[1] == current_task )
      return 0;
    current_task = *(_DWORD *)(current_task + 4);
  }
  return current_task;
}

//----- (0004B8AC) --------------------------------------------------------
int __fastcall update_reference_counters(int list_head)
{
  int initial_node; // r6
  int current_node; // r4
  _DWORD *node_data; // r0
  int next_node; // r5
  unsigned int *ref_counter_ptr; // r3
  unsigned int current_count; // r2
  unsigned int new_count; // r2
  int node_to_release; // r0

  initial_node = list_head + 12;
  current_node = *(_DWORD *)(list_head + 16);
  if ( current_node != list_head + 12 )
  {
    do
    {
      node_data = *(_DWORD **)(current_node + 20);
      next_node = *(_DWORD *)(current_node + 4);
      if ( node_data )
      {
        ref_counter_ptr = node_data + 1;
        if ( node_data[1] != -1 )
        {
          __dmb(11u);
          do
          {
            current_count = __ldrex(ref_counter_ptr);
            new_count = current_count - 1;
          }
          while ( __strex(new_count, ref_counter_ptr) );
          if ( !new_count )
            handle_task(node_data);
        }
      }
      node_to_release = current_node;
      current_node = next_node;
      list_head = check_and_perform_action(node_to_release);
    }
    while ( next_node != initial_node );
  }
  return list_head;
}

//----- (0004B91C) --------------------------------------------------------
int __fastcall initialize_miner_queue(_DWORD *miner_queue)
{
  _DWORD *queue_buffer; // r0
  int queue_size_shift; // r12
  _DWORD *initial_head_ptr; // r3
  _DWORD *buffer_end_ptr; // r2

  *miner_queue = 0;
  miner_queue[2] = 3;
  queue_buffer = (_DWORD *)check_and_process_result(64);
  miner_queue[1] = queue_buffer;
  if ( !queue_buffer )
    return -1;
  queue_size_shift = miner_queue[2];
  initial_head_ptr = miner_queue + 3;
  miner_queue[4] = miner_queue + 3;
  miner_queue[3] = miner_queue + 3;
  miner_queue[6] = miner_queue + 5;
  miner_queue[5] = miner_queue + 5;
  if ( 1 << queue_size_shift )
  {
    buffer_end_ptr = (_DWORD *)((char *)queue_buffer + (8 << queue_size_shift));
    do
    {
      queue_buffer[1] = initial_head_ptr;
      *queue_buffer = initial_head_ptr;
      queue_buffer += 2;
    }
    while ( queue_buffer != buffer_end_ptr );
  }
  return 0;
}

//----- (0004B998) --------------------------------------------------------
int __fastcall update_counters_and_check_status(int device_handle)
{
  update_reference_counters(device_handle);
  return check_and_perform_action(*(_DWORD *)(device_handle + 4));
}

//----- (0004B9B0) --------------------------------------------------------
int __fastcall add_task_with_name(int *task_list, char *task_name, int task_data)
{
  int current_size_power; // r8
  int new_size_power; // r8
  int new_task_storage; // r5
  int *end_marker_ptr; // r1
  int **task_storage_iter; // r3
  int *current_task_ptr; // r3
  int size_mask; // r8
  int task_prev_ptr; // lr
  int *task_next_ptr; // r12
  int task_index; // r0
  int *current_storage_pos; // r2
  int **storage_slot_ptr; // r0
  int first_task_ptr; // r2
  unsigned int task_name_length; // r10
  int task_hash; // r9
  int *hash_table_slot_ptr; // r5
  int task_by_id_and_name; // r0
  int task_location; // r8
  _DWORD *task_ref_count_ptr; // r0
  unsigned int *ref_count; // r3
  unsigned int current_ref_count; // r2
  unsigned int updated_ref_count; // r2
  int operation_result; // r0
  int new_task_ptr; // r0
  int *new_task_struct; // r8
  int *hash_table_first_task_ptr; // r3
  int new_task_next_ptr; // r2
  int task_list_last_element_ptr; // r1
  int task_count; // r3

  current_size_power = task_list[2];
  if ( (unsigned int)*task_list >> current_size_power )
  {
    new_size_power = current_size_power + 1;
    new_task_storage = check_and_process_result(8 << new_size_power);
    if ( !new_task_storage )
      return -1;
    check_and_perform_action(task_list[1]);
    task_list[1] = new_task_storage;
    task_list[2] = new_size_power;
    end_marker_ptr = task_list + 3;
    if ( 1 << new_size_power )
    {
      task_storage_iter = (int **)new_task_storage;
      do
      {
        task_storage_iter[1] = end_marker_ptr;
        *task_storage_iter = end_marker_ptr;
        task_storage_iter += 2;
      }
      while ( (int **)((8 << new_size_power) + new_task_storage) != task_storage_iter );
    }
    current_task_ptr = (int *)task_list[4];
    task_list[3] = (int)end_marker_ptr;
    size_mask = ~(-1 << new_size_power);
    task_list[4] = (int)end_marker_ptr;
    if ( current_task_ptr != end_marker_ptr )
    {
      do
      {
        while ( 1 )
        {
          task_next_ptr = (int *)current_task_ptr[1];
          task_index = current_task_ptr[4] & size_mask;
          current_storage_pos = *(int **)(new_task_storage + 8 * task_index);
          storage_slot_ptr = (int **)(new_task_storage + 8 * task_index);
          if ( current_storage_pos == end_marker_ptr && end_marker_ptr == storage_slot_ptr[1] )
            break;
          task_prev_ptr = *current_storage_pos;
          current_task_ptr[1] = (int)current_storage_pos;
          *current_task_ptr = task_prev_ptr;
          *(_DWORD *)(*current_storage_pos + 4) = current_task_ptr;
          *current_storage_pos = (int)current_task_ptr;
          *storage_slot_ptr = current_task_ptr;
          current_task_ptr = task_next_ptr;
          if ( task_next_ptr == end_marker_ptr )
            goto LABEL_12;
        }
        first_task_ptr = task_list[3];
        current_task_ptr[1] = (int)end_marker_ptr;
        *current_task_ptr = first_task_ptr;
        *(_DWORD *)(task_list[3] + 4) = current_task_ptr;
        task_list[3] = (int)current_task_ptr;
        storage_slot_ptr[1] = current_task_ptr;
        *storage_slot_ptr = current_task_ptr;
        current_task_ptr = task_next_ptr;
      }
      while ( task_next_ptr != end_marker_ptr );
LABEL_12:
      new_task_storage = task_list[1];
      size_mask = ~(-1 << task_list[2]);
    }
  }
  else
  {
    new_task_storage = task_list[1];
    size_mask = ~(-1 << current_size_power);
  }
  task_name_length = strlen(task_name);
  task_hash = calculate_hash((unsigned __int16 *)task_name, task_name_length, dword_5051C0);
  hash_table_slot_ptr = (int *)(new_task_storage + 8 * (size_mask & task_hash));
  task_by_id_and_name = find_task_by_id_and_name((int)task_list, hash_table_slot_ptr, task_name, task_hash);
  task_location = task_by_id_and_name;
  if ( task_by_id_and_name )
  {
    task_ref_count_ptr = *(_DWORD **)(task_by_id_and_name + 20);
    if ( task_ref_count_ptr && task_ref_count_ptr[1] != -1 )
    {
      ref_count = task_ref_count_ptr + 1;
      __dmb(11u);
      do
      {
        current_ref_count = __ldrex(ref_count);
        updated_ref_count = current_ref_count - 1;
      }
      while ( __strex(updated_ref_count, ref_count) );
      if ( !updated_ref_count )
        handle_task(task_ref_count_ptr);
    }
    *(_DWORD *)(task_location + 20) = task_data;
    return 0;
  }
  new_task_ptr = check_and_process_result(task_name_length + 25);
  new_task_struct = (int *)new_task_ptr;
  if ( !new_task_ptr )
    return -1;
  *(_DWORD *)(new_task_ptr + 16) = task_hash;
  strncpy((char *)(new_task_ptr + 24), task_name, task_name_length + 1);
  hash_table_first_task_ptr = (int *)*hash_table_slot_ptr;
  new_task_next_ptr = (int)(new_task_struct + 2);
  new_task_struct[5] = task_data;
  new_task_struct[1] = (int)new_task_struct;
  *new_task_struct = (int)new_task_struct;
  new_task_struct[3] = (int)(new_task_struct + 2);
  new_task_struct[2] = (int)(new_task_struct + 2);
  if ( hash_table_first_task_ptr == task_list + 3 && hash_table_first_task_ptr == (int *)hash_table_slot_ptr[1] )
  {
    *new_task_struct = task_list[3];
    new_task_struct[1] = (int)hash_table_first_task_ptr;
    *(_DWORD *)(task_list[3] + 4) = new_task_struct;
    task_list[3] = (int)new_task_struct;
    hash_table_slot_ptr[1] = (int)new_task_struct;
    *hash_table_slot_ptr = (int)new_task_struct;
  }
  else
  {
    *new_task_struct = *hash_table_first_task_ptr;
    new_task_struct[1] = (int)hash_table_first_task_ptr;
    *(_DWORD *)(*hash_table_first_task_ptr + 4) = new_task_struct;
    *hash_table_first_task_ptr = (int)new_task_struct;
    *hash_table_slot_ptr = (int)new_task_struct;
  }
  task_list_last_element_ptr = task_list[5];
  task_count = *task_list;
  operation_result = 0;
  new_task_struct[3] = (int)(task_list + 5);
  new_task_struct[2] = task_list_last_element_ptr;
  *(_DWORD *)(task_list[5] + 4) = new_task_next_ptr;
  task_list[5] = new_task_next_ptr;
  *task_list = task_count + 1;
  return operation_result;
}
// 5051C0: using guessed type int dword_5051C0;

//----- (0004BC44) --------------------------------------------------------
int __fastcall calculate_hash_and_find_task(int task_structure, char *task_name)
{
  unsigned int name_length; // r0
  int name_hash; // r0
  int task_info_pointer; // r0

  name_length = strlen(task_name);
  name_hash = calculate_hash((unsigned __int16 *)task_name, name_length, dword_5051C0);
  task_info_pointer = find_task_by_id_and_name(
                        task_structure,
                        (int *)(*(_DWORD *)(task_structure + 4)
                              + 8 * (name_hash & ~(-1 << *(_DWORD *)(task_structure + 8)))),
                        task_name,
                        name_hash);
  if ( task_info_pointer )
    return *(_DWORD *)(task_info_pointer + 20);
  return task_info_pointer;
}
// 5051C0: using guessed type int dword_5051C0;

//----- (0004BCA4) --------------------------------------------------------
int __fastcall remove_named_task(_DWORD *task_list, char *task_name)
{
  unsigned int name_length; // r0
  int hashed_name; // r0
  int task_array_base; // r9
  int task_index; // r5
  int *task_array_entry; // r7
  int *task_by_id_and_name; // r0
  int task_struct_base; // r4
  int *next_task_ptr; // r1
  int next_task_struct; // r2
  int prev_task_struct; // r3
  int *update_ptr; // r1
  int task_data; // r2
  _DWORD *reference_counter; // r0
  int task_data_struct; // r3
  int removal_result; // r0
  unsigned int *ref_counter_ptr; // r3
  unsigned int ref_count_val; // r2
  unsigned int updated_ref_count; // r2
  bool is_single_task; // zf

  name_length = strlen(task_name);
  hashed_name = calculate_hash((unsigned __int16 *)task_name, name_length, dword_5051C0);
  task_array_base = task_list[1];
  task_index = hashed_name & ~(-1 << task_list[2]);
  task_array_entry = (int *)(task_array_base + 8 * task_index);
  task_by_id_and_name = (int *)find_task_by_id_and_name((int)task_list, task_array_entry, task_name, hashed_name);
  task_struct_base = (int)task_by_id_and_name;
  if ( !task_by_id_and_name )
    return -1;
  next_task_ptr = (int *)task_array_entry[1];
  next_task_struct = task_by_id_and_name[1];
  prev_task_struct = *task_by_id_and_name;
  if ( task_by_id_and_name == *(int **)(task_array_base + 8 * task_index) )
  {
    is_single_task = task_by_id_and_name == next_task_ptr;
    if ( task_by_id_and_name == next_task_ptr )
      next_task_ptr = task_list + 3;
    else
      *(_DWORD *)(task_array_base + 8 * task_index) = next_task_struct;
    if ( is_single_task )
    {
      task_array_entry[1] = (int)next_task_ptr;
      *(_DWORD *)(task_array_base + 8 * task_index) = next_task_ptr;
    }
  }
  else if ( task_by_id_and_name == next_task_ptr )
  {
    task_array_entry[1] = prev_task_struct;
  }
  *(_DWORD *)(prev_task_struct + 4) = next_task_struct;
  update_ptr = (int *)task_by_id_and_name[1];
  task_data = task_by_id_and_name[3];
  reference_counter = (_DWORD *)task_by_id_and_name[5];
  *update_ptr = prev_task_struct;
  task_data_struct = *(_DWORD *)(task_struct_base + 8);
  *(_DWORD *)(task_data_struct + 4) = task_data;
  **(_DWORD **)(task_struct_base + 12) = task_data_struct;
  if ( reference_counter && reference_counter[1] != -1 )
  {
    ref_counter_ptr = reference_counter + 1;
    __dmb(11u);
    do
    {
      ref_count_val = __ldrex(ref_counter_ptr);
      updated_ref_count = ref_count_val - 1;
    }
    while ( __strex(updated_ref_count, ref_counter_ptr) );
    if ( !updated_ref_count )
      handle_task(reference_counter);
  }
  check_and_perform_action(task_struct_base);
  removal_result = 0;
  --*task_list;
  return removal_result;
}
// 5051C0: using guessed type int dword_5051C0;

//----- (0004BDC4) --------------------------------------------------------
int __fastcall initialize_data_structures(_DWORD *data_structure)
{
  _DWORD *element_ptr; // r2
  int size_factor; // r0
  _DWORD *iter_ptr; // r3
  _DWORD *end_ptr; // r1

  update_reference_counters((int)data_structure);
  element_ptr = data_structure + 3;
  size_factor = data_structure[2];
  if ( 1 << size_factor )
  {
    iter_ptr = (_DWORD *)data_structure[1];
    end_ptr = (_DWORD *)((char *)iter_ptr + (8 << size_factor));
    do
    {
      iter_ptr[1] = element_ptr;
      *iter_ptr = element_ptr;
      iter_ptr += 2;
    }
    while ( iter_ptr != end_ptr );
  }
  data_structure[4] = element_ptr;
  data_structure[3] = element_ptr;
  data_structure[6] = data_structure + 5;
  data_structure[5] = data_structure + 5;
  *data_structure = 0;
  return size_factor;
}

//----- (0004BE20) --------------------------------------------------------
int __fastcall get_next_element(int base_address)
{
  if ( *(_DWORD *)(base_address + 24) == base_address + 20 )
    return 0;
  else
    return *(_DWORD *)(base_address + 24);
}

//----- (0004BE38) --------------------------------------------------------
int __fastcall get_task_info_by_string_hash(int task_list_base, char *input_string)
{
  unsigned int input_strlen; // r0
  int string_hash; // r0
  int task_info_offset; // r0

  input_strlen = strlen(input_string);
  string_hash = calculate_hash((unsigned __int16 *)input_string, input_strlen, dword_5051C0);
  task_info_offset = find_task_by_id_and_name(
                       task_list_base,
                       (int *)(*(_DWORD *)(task_list_base + 4)
                             + 8 * (string_hash & ~(-1 << *(_DWORD *)(task_list_base + 8)))),
                       input_string,
                       string_hash);
  if ( task_info_offset )
    task_info_offset += 8;
  return task_info_offset;
}
// 5051C0: using guessed type int dword_5051C0;

//----- (0004BE98) --------------------------------------------------------
int __fastcall check_matching_values(int expected_value_offset, int value_ptr)
{
  if ( *(_DWORD *)(value_ptr + 4) == expected_value_offset + 20 )
    return 0;
  else
    return *(_DWORD *)(value_ptr + 4);
}

//----- (0004BEB0) --------------------------------------------------------
int __fastcall calculate_offset(int base_address)
{
  return base_address + 16;
}

//----- (0004BEB8) --------------------------------------------------------
int __fastcall get_status_register(int status_register_ptr)
{
  return *(_DWORD *)(status_register_ptr + 12);
}

//----- (0004BEC0) --------------------------------------------------------
_DWORD *__fastcall update_reference_count(int object_ptr, int new_value)
{
  _DWORD *current_object; // r0
  unsigned int *ref_count_ptr; // r3
  unsigned int current_count; // r2
  unsigned int new_count; // r2

  current_object = *(_DWORD **)(object_ptr + 12);
  if ( !current_object )
    goto LABEL_6;
  if ( current_object[1] == -1 )
    goto LABEL_6;
  ref_count_ptr = current_object + 1;
  __dmb(11u);
  do
  {
    current_count = __ldrex(ref_count_ptr);
    new_count = current_count - 1;
  }
  while ( __strex(new_count, ref_count_ptr) );
  if ( new_count )
  {
LABEL_6:
    *(_DWORD *)(object_ptr + 12) = new_value;
  }
  else
  {
    current_object = handle_task(current_object);
    *(_DWORD *)(object_ptr + 12) = new_value;
  }
  return current_object;
}

//----- (0004BF2C) --------------------------------------------------------
int __fastcall initialize_random_seed(int random_seed)
{
  int seed_value; // r1
  unsigned __int8 lock_state; // r2
  int is_seed_initialized; // r3
  int urandom_file_descriptor; // r0
  int urandom_fd; // r5
  ssize_t bytes_read; // r7
  int microseconds_xor_seconds; // r5
  struct timeval timeval_struct; // [sp+0h] [bp-20h] BYREF

  if ( !dword_5051C0 )
  {
    seed_value = random_seed;
    random_seed = 1;
    do
      lock_state = __ldrex((unsigned __int8 *)algn_5051C4);
    while ( __strex(1u, (unsigned __int8 *)algn_5051C4) );
    if ( lock_state )
    {
      do
      {
        random_seed = sched_yield();
        is_seed_initialized = dword_5051C0;
        __dmb(11u);
      }
      while ( !is_seed_initialized );
    }
    else
    {
      if ( !seed_value )
      {
        urandom_file_descriptor = open64("/dev/urandom");
        urandom_fd = urandom_file_descriptor;
        if ( urandom_file_descriptor == -1
          || (bytes_read = read(urandom_file_descriptor, &timeval_struct, 4u), close(urandom_fd), bytes_read != 4) )
        {
          gettimeofday(&timeval_struct, 0);
          microseconds_xor_seconds = timeval_struct.tv_usec ^ timeval_struct.tv_sec;
          random_seed = getpid();
          seed_value = random_seed ^ microseconds_xor_seconds;
        }
        else
        {
          random_seed = LOBYTE(timeval_struct.tv_sec);
          seed_value = HIBYTE(timeval_struct.tv_sec) | ((BYTE2(timeval_struct.tv_sec) | ((BYTE1(timeval_struct.tv_sec) | (LOBYTE(timeval_struct.tv_sec) << 8)) << 8)) << 8);
        }
        if ( !seed_value )
          seed_value = 1;
      }
      __dmb(11u);
      dword_5051C0 = seed_value;
    }
  }
  return random_seed;
}
// 12198: using guessed type int __fastcall open64(_DWORD);
// 5051C0: using guessed type int dword_5051C0;

//----- (0004C028) --------------------------------------------------------
int __fastcall read_next_byte(_DWORD *buffer)
{
  int current_position; // r2
  int next_byte; // r3
  bool is_end_of_data; // zf

  current_position = buffer[1];
  next_byte = *(unsigned __int8 *)(*buffer + current_position);
  is_end_of_data = next_byte == 0;
  if ( *(_BYTE *)(*buffer + current_position) )
    ++current_position;
  else
    next_byte = -1;
  if ( !is_end_of_data )
    buffer[1] = current_position;
  return next_byte;
}

//----- (0004C04C) --------------------------------------------------------
int __fastcall get_next_value(int buffer_struct_ptr)
{
  __int64 value_pair; // r2

  value_pair = *(_QWORD *)(buffer_struct_ptr + 4);
  if ( HIDWORD(value_pair) >= (unsigned int)value_pair )
    return -1;
  LODWORD(value_pair) = HIDWORD(value_pair) + 1;
  HIDWORD(value_pair) = *(unsigned __int8 *)(*(_DWORD *)buffer_struct_ptr + HIDWORD(value_pair));
  *(_DWORD *)(buffer_struct_ptr + 8) = value_pair;
  return HIDWORD(value_pair);
}

//----- (0004C070) --------------------------------------------------------
int __fastcall read_byte_from_buffer(_DWORD *buffer_struct)
{
  unsigned int current_index; // r3
  int (__fastcall *refresh_buffer_callback)(_DWORD *, int, _DWORD); // r3
  int bytes_read; // r0
  int byte_to_return; // r0

  current_index = buffer_struct[257];
  if ( current_index < buffer_struct[256] )
    goto LABEL_4;
  refresh_buffer_callback = (int (__fastcall *)(_DWORD *, int, _DWORD))buffer_struct[258];
  buffer_struct[257] = 0;
  bytes_read = refresh_buffer_callback(buffer_struct, 1024, buffer_struct[259]);
  buffer_struct[256] = bytes_read;
  if ( (unsigned int)(bytes_read - 1) <= 4294967293 )
  {
    current_index = buffer_struct[257];
LABEL_4:
    byte_to_return = *((unsigned __int8 *)buffer_struct + current_index);
    buffer_struct[257] = current_index + 1;
    return byte_to_return;
  }
  return -1;
}

//----- (0004C0CC) --------------------------------------------------------
int format_error_message(int buffer_output, _DWORD *error_info, int error_code, const char *format, ...)
{
  int buffer; // r6
  const char *source_file_name; // r0
  int line_number; // r8
  int column_number; // r7
  int position_offset; // r9
  char *final_message; // r3
  char formatted_message_buffer[160]; // [sp+18h] [bp-168h] BYREF
  char extended_message_buffer[159]; // [sp+B8h] [bp-C8h] BYREF
  char null_terminator; // [sp+157h] [bp-29h]
  const char *format_arg; // [sp+17Ch] [bp-4h]
  va_list varargs; // [sp+180h] [bp+0h] BYREF

  va_start(varargs, format);
  format_arg = format;
  buffer = buffer_output;
  if ( buffer_output )
  {
    vsnprintf(formatted_message_buffer, 160u, format_arg, varargs);
    formatted_message_buffer[159] = 0;
    if ( error_info )
    {
      source_file_name = (const char *)get_first_dword_from_address((int)(error_info + 10));
      line_number = error_info[6];
      column_number = error_info[7];
      position_offset = error_info[9];
      if ( source_file_name && *source_file_name )
      {
        if ( error_info[11] <= 20u )
        {
          snprintf(extended_message_buffer, 160u, "%s near '%s'", formatted_message_buffer, source_file_name);
          final_message = extended_message_buffer;
          null_terminator = 0;
          return copy_formatted_message_to_buffer(
                   buffer,
                   line_number,
                   column_number,
                   position_offset,
                   error_code,
                   "%s",
                   final_message);
        }
      }
      else
      {
        if ( error_code == 8 )
          error_code = 6;
        if ( error_info[5] != -2 )
        {
          snprintf(extended_message_buffer, 160u, "%s near end of file", formatted_message_buffer);
          final_message = extended_message_buffer;
          null_terminator = 0;
          return copy_formatted_message_to_buffer(
                   buffer,
                   line_number,
                   column_number,
                   position_offset,
                   error_code,
                   "%s",
                   final_message);
        }
      }
      final_message = formatted_message_buffer;
    }
    else
    {
      column_number = -1;
      final_message = formatted_message_buffer;
      position_offset = 0;
      line_number = -1;
    }
    return copy_formatted_message_to_buffer(
             buffer,
             line_number,
             column_number,
             position_offset,
             error_code,
             "%s",
             final_message);
  }
  return buffer_output;
}

//----- (0004C1FC) --------------------------------------------------------
int __fastcall check_and_reset_buffer(int *buffer_info)
{
  if ( buffer_info[15] != 256 )
    return perform_maintenance_and_reset(buffer_info + 10);
  check_and_perform_action(buffer_info[16]);
  buffer_info[16] = 0;
  buffer_info[17] = 0;
  return perform_maintenance_and_reset(buffer_info + 10);
}

//----- (0004C23C) --------------------------------------------------------
int __fastcall read_single_byte(int *file_descriptor_pointer)
{
  unsigned __int8 byte_buffer; // [sp+7h] [bp-9h] BYREF

  if ( read(*file_descriptor_pointer, &byte_buffer, 1u) == 1 )
    return byte_buffer;
  else
    return -1;
}

//----- (0004C268) --------------------------------------------------------
int __fastcall decode_unicode_escape(_BYTE *str)
{
  _BYTE *current_char_ptr; // r3
  int unicode_value; // r0
  _BYTE *end_ptr; // lr
  int current_char; // r2
  int temp_char; // t1
  int shifted_value; // r0
  int numeric_value; // r1

  if ( *str != 117 )
    _assert_fail("str[0] == 'u'", "load.c", 309u, "decode_unicode_escape");
  current_char_ptr = str;
  unicode_value = 0;
  end_ptr = current_char_ptr + 4;
  while ( 1 )
  {
    temp_char = (unsigned __int8)*++current_char_ptr;
    current_char = temp_char;
    shifted_value = 16 * unicode_value;
    numeric_value = temp_char - 48;
    if ( (unsigned __int8)(temp_char - 48) > 9u )
      break;
    unicode_value = numeric_value + shifted_value;
LABEL_10:
    if ( current_char_ptr == end_ptr )
      return unicode_value;
  }
  if ( (unsigned int)(current_char - 97) <= 25 )
  {
    unicode_value = current_char - 87 + shifted_value;
    goto LABEL_10;
  }
  if ( (unsigned int)(current_char - 65) <= 25 )
  {
    unicode_value = current_char - 55 + shifted_value;
    goto LABEL_10;
  }
  return -1;
}

//----- (0004C2FC) --------------------------------------------------------
_DWORD *__fastcall stream_unget_char(_DWORD *stream, int unget_char)
{
  _DWORD *local_stream; // r4
  int previous_value; // r2
  int buffer_position; // r3
  int new_buffer_position; // r3

  if ( (unsigned int)(unget_char + 2) > 1 )
  {
    local_stream = stream;
    --stream[9];
    if ( unget_char == 10 )
    {
      previous_value = stream[8];
      --stream[6];
      stream[7] = previous_value;
    }
    else
    {
      stream = (_DWORD *)check_temperature_range((unsigned __int8)unget_char);
      if ( stream )
        --local_stream[7];
    }
    buffer_position = local_stream[4];
    if ( !buffer_position )
      _assert_fail("stream->buffer_pos > 0", "load.c", 238u, "stream_unget");
    new_buffer_position = buffer_position - 1;
    local_stream[4] = new_buffer_position;
    if ( *((unsigned __int8 *)local_stream + new_buffer_position + 8) != unget_char )
      _assert_fail("stream->buffer[stream->buffer_pos] == c", "load.c", 240u, "stream_unget");
  }
  return stream;
}

//----- (0004C3B8) --------------------------------------------------------
int __fastcall parse_next_byte(int context, int error_output)
{
  int offset; // r2
  int context_offset_address; // r3
  int next_byte; // r6
  int new_offset; // r1
  int read_result; // r0
  int parsed_byte; // r5
  int return_code; // r0
  int line_count; // r3
  int current_line_length; // r2
  unsigned int utf8_byte_count; // r0
  unsigned int verified_byte_count; // r8
  _BYTE *write_ptr; // r6
  _BYTE *end_ptr; // r9
  int updated_offset; // r2
  int failed_byte; // [sp+0h] [bp-28h]

  offset = *(_DWORD *)(context + 16);
  context_offset_address = context + offset;
  next_byte = *(unsigned __int8 *)(context + offset + 8);
  if ( *(_BYTE *)(context + offset + 8) )
  {
    new_offset = offset + 1;
    goto LABEL_8;
  }
  read_result = (*(int (__fastcall **)(_DWORD))context)(*(_DWORD *)(context + 4));
  parsed_byte = read_result;
  if ( read_result == -1 )
  {
    *(_DWORD *)(context + 20) = -1;
    return parsed_byte;
  }
  *(_DWORD *)(context + 16) = next_byte;
  *(_BYTE *)(context + 8) = read_result;
  if ( (unsigned int)(read_result - 128) <= 127 )
  {
    utf8_byte_count = check_temperature_range((unsigned __int8)read_result);
    verified_byte_count = utf8_byte_count;
    if ( !utf8_byte_count )
      goto LABEL_20;
    if ( utf8_byte_count <= 1 )
      _assert_fail("count >= 2", "load.c", 189u, "stream_get");
    write_ptr = (_BYTE *)(context + 9);
    end_ptr = (_BYTE *)(context + 8 + utf8_byte_count);
    do
      *write_ptr++ = (*(int (__fastcall **)(_DWORD))context)(*(_DWORD *)(context + 4));
    while ( end_ptr != write_ptr );
    if ( !validate_utf8_encoding((char *)(context + 8), verified_byte_count, 0) )
    {
LABEL_20:
      failed_byte = parsed_byte;
      parsed_byte = -2;
      *(_DWORD *)(context + 20) = -2;
      format_error_message(error_output, (_DWORD *)context, 5, "unable to decode byte 0x%x", failed_byte);
      return parsed_byte;
    }
    *(_BYTE *)(context + verified_byte_count + 8) = 0;
    updated_offset = *(_DWORD *)(context + 16);
    new_offset = updated_offset + 1;
    context_offset_address = context + updated_offset;
  }
  else
  {
    new_offset = 1;
    context_offset_address = context;
    *(_BYTE *)(context + 9) = next_byte;
  }
LABEL_8:
  *(_DWORD *)(context + 16) = new_offset;
  parsed_byte = *(unsigned __int8 *)(context_offset_address + 8);
  ++*(_DWORD *)(context + 36);
  if ( parsed_byte != 10 )
  {
    if ( check_temperature_range(parsed_byte) )
      ++*(_DWORD *)(context + 28);
    return parsed_byte;
  }
  line_count = *(_DWORD *)(context + 24);
  current_line_length = *(_DWORD *)(context + 28);
  return_code = 10;
  *(_DWORD *)(context + 28) = 0;
  *(_DWORD *)(context + 24) = line_count + 1;
  *(_DWORD *)(context + 32) = current_line_length;
  return return_code;
}

//----- (0004C540) --------------------------------------------------------
int __fastcall get_result_code(int context, int parameter)
{
  int result_code; // r4

  result_code = *(_DWORD *)(context + 20);
  if ( !result_code )
    result_code = parse_next_byte(context, parameter);
  if ( (unsigned int)(result_code + 2) > 1 )
    write_single_char_to_buffer((const void **)(context + 40), result_code);
  return result_code;
}

//----- (0004C580) --------------------------------------------------------
_DWORD *__fastcall put_char_back_to_buffer(_DWORD *current_position, _DWORD *char_to_put_back)
{
  _DWORD *buffer; // r5
  char unused1; // r1
  int unused2; // r2

  if ( (unsigned int)char_to_put_back + 2 > 1 )
  {
    buffer = current_position;
    stream_unget_char(current_position, (int)char_to_put_back);
    current_position = (_DWORD *)pop_byte_from_buffer(buffer + 10, unused1, unused2);
    if ( current_position != char_to_put_back )
      _assert_fail("c == d", "load.c", 282u, "lex_unget_unsave");
  }
  return current_position;
}
// 4C5A0: variable 'unused1' is possibly undefined
// 4C5A0: variable 'unused2' is possibly undefined

//----- (0004C5CC) --------------------------------------------------------
unsigned int __fastcall sub_4C5CC(_DWORD *a1, int a2)
{
  const void **v2; // r7
  unsigned int byte; // r4
  bool v6; // cc
  int v7; // r3
  int v8; // r4
  bool v9; // zf
  _BOOL4 v10; // r2
  bool v11; // cc
  int v12; // r0
  const char *v13; // r4
  unsigned int result; // r0
  int v15; // r1
  _DWORD *v16; // r0
  unsigned int v17; // r4
  int v18; // r0
  bool v19; // zf
  int v20; // r0
  bool v21; // zf
  const char *first_dword_from_address; // r4
  int *v23; // r7
  __int64 v24; // r0
  char i; // r1
  int v26; // r3
  int v27; // r2
  double v28; // r2
  int v29; // r8
  unsigned int v30; // r3
  unsigned int v31; // r4
  bool v32; // cc
  int v33; // r1
  _BYTE *v34; // r8
  unsigned __int8 *j; // r4
  int v36; // r3
  unsigned int v37; // r3
  int v38; // r0
  int v39; // r11
  int v40; // r0
  _DWORD *v41; // r1
  int result_code; // r0
  int v43; // r2
  const char *v44; // r3
  const char *v45; // r3
  unsigned __int8 *arg; // [sp+0h] [bp-40h]
  int v47; // [sp+Ch] [bp-34h]
  double endptr[6]; // [sp+10h] [bp-30h] BYREF

  v2 = (const void **)(a1 + 10);
  reset_buffer((int)(a1 + 10));
  if ( a1[15] == 256 )
  {
    check_and_perform_action(a1[16]);
    a1[16] = 0;
    a1[17] = 0;
  }
  do
  {
    byte = a1[5];
    if ( !byte )
      byte = parse_next_byte((int)a1, a2);
    v6 = byte > 32;
    if ( byte != 32 )
      v6 = byte - 9 > 1;
    v7 = !v6;
  }
  while ( !v6 || byte == 13 );
  if ( byte == -1 )
  {
    a1[15] = v7;
    return v7;
  }
  if ( byte == -2 )
    goto LABEL_35;
  write_single_char_to_buffer(v2, byte);
  if ( (((byte & 0xFFFFFFDF) - 91) & 0xFFFFFFFD) == 0 )
    goto LABEL_38;
  v9 = byte == 44;
  if ( byte != 44 )
    v9 = byte == 58;
  v10 = v9;
  if ( v9 )
    goto LABEL_38;
  if ( byte != 34 )
  {
    v11 = byte > 45;
    if ( byte != 45 )
      v11 = byte - 48 > 9;
    if ( !v11 )
    {
      a1[15] = -1;
      if ( byte == 45 )
      {
        result_code = get_result_code((int)a1, a2);
        v41 = (_DWORD *)result_code;
        if ( result_code != 48 )
        {
          if ( (unsigned int)(result_code - 48) > 9 )
            goto LABEL_118;
          goto LABEL_58;
        }
      }
      else if ( byte != 48 )
      {
        do
LABEL_58:
          v20 = get_result_code((int)a1, a2);
        while ( (unsigned int)(v20 - 48) <= 9 );
        goto LABEL_59;
      }
      v20 = get_result_code((int)a1, a2);
      if ( (unsigned int)(v20 - 48) <= 9 )
      {
LABEL_117:
        v41 = (_DWORD *)v20;
LABEL_118:
        put_char_back_to_buffer(a1, v41);
        return a1[15];
      }
LABEL_59:
      if ( (a1[13] & 8) != 0 )
        goto LABEL_70;
      v21 = v20 == 46;
      if ( v20 != 46 )
        v21 = v20 == 69;
      if ( v21 )
      {
LABEL_70:
        if ( v20 == 46 )
        {
          v33 = a1[5];
          if ( !v33 )
            v33 = parse_next_byte((int)a1, a2);
          if ( (unsigned int)(v33 - 48) > 9 )
          {
            stream_unget_char(a1, v33);
            return a1[15];
          }
          write_single_char_to_buffer(v2, v33);
          do
            v20 = get_result_code((int)a1, a2);
          while ( (unsigned int)(v20 - 48) <= 9 );
        }
        if ( (v20 & 0xFFFFFFDF) != 69 )
          goto LABEL_72;
      }
      else if ( v20 != 101 )
      {
        put_char_back_to_buffer(a1, (_DWORD *)v20);
        first_dword_from_address = (const char *)get_first_dword_from_address((int)v2);
        v23 = _errno_location();
        *v23 = 0;
        v24 = strtoll(first_dword_from_address, (char **)endptr, 10);
        if ( *v23 == 34 )
        {
          if ( v24 >= 0 )
            LOWORD(v45) = -22764;
          else
            LOWORD(v45) = -22792;
          HIWORD(v45) = 6;
          format_error_message(a2, a1, 15, v45);
          return a1[15];
        }
        else
        {
          if ( (const char *)LODWORD(endptr[0]) != &first_dword_from_address[a1[11]] )
            _assert_fail("end == saved_text + lex->saved_text.length", "load.c", 541u, "lex_scan_number");
          v8 = 257;
          *((_QWORD *)a1 + 8) = v24;
          a1[15] = 257;
        }
        return v8;
      }
      v20 = get_result_code((int)a1, a2);
      if ( ((v20 - 43) & 0xFFFFFFFD) == 0 )
        v20 = get_result_code((int)a1, a2);
      if ( (unsigned int)(v20 - 48) <= 9 )
      {
        do
          v20 = get_result_code((int)a1, a2);
        while ( (unsigned int)(v20 - 48) <= 9 );
LABEL_72:
        put_char_back_to_buffer(a1, (_DWORD *)v20);
        if ( parse_decimal_string((int)v2, endptr) )
        {
          format_error_message(a2, a1, 15, "real number overflow");
          return a1[15];
        }
        else
        {
          v28 = endptr[0];
          v8 = 258;
          a1[15] = 258;
          *((double *)a1 + 8) = v28;
        }
        return v8;
      }
      goto LABEL_117;
    }
    if ( (byte & 0xFFFFFFDF) - 65 <= 25 )
    {
      do
        v12 = get_result_code((int)a1, a2);
      while ( (v12 & 0xFFFFFFDF) - 65 <= 25 );
      put_char_back_to_buffer(a1, (_DWORD *)v12);
      v13 = (const char *)get_first_dword_from_address((int)v2);
      if ( !strcmp(v13, "true") )
      {
        v8 = 259;
        a1[15] = 259;
        return v8;
      }
      if ( strcmp(v13, "false") )
      {
        if ( !strcmp(v13, "null") )
        {
          v8 = 261;
          a1[15] = 261;
          return v8;
        }
        goto LABEL_35;
      }
      byte = 260;
LABEL_38:
      result = byte;
      a1[15] = byte;
      return result;
    }
    for ( i = *((_BYTE *)a1 + a1[4] + 8); i; i = *((_BYTE *)a1 + v26 + 8) )
    {
      write_single_char_to_buffer(v2, i);
      v26 = a1[4] + 1;
      v27 = a1[9] + 1;
      a1[4] = v26;
      a1[9] = v27;
    }
LABEL_35:
    v8 = -1;
    a1[15] = -1;
    return v8;
  }
  a1[16] = v10;
  a1[15] = -1;
LABEL_40:
  v15 = a2;
  v16 = a1;
  while ( 1 )
  {
    v17 = get_result_code((int)v16, v15);
LABEL_42:
    if ( v17 == 34 )
    {
      v34 = (_BYTE *)check_and_process_result(a1[11] + 1);
      if ( !v34 )
        goto LABEL_55;
      a1[16] = v34;
      for ( j = (unsigned __int8 *)(get_first_dword_from_address((int)v2) + 1); ; j += 2 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            v36 = *j;
            if ( v36 == 34 )
            {
              *v34 = 0;
              v8 = 256;
              v43 = a1[16];
              a1[15] = 256;
              a1[17] = &v34[-v43];
              return v8;
            }
            if ( v36 == 92 )
              break;
            *v34 = v36;
            ++j;
            ++v34;
          }
          v37 = j[1];
          if ( v37 != 117 )
            break;
          v38 = decode_unicode_escape(j + 1);
          v39 = v38;
          if ( v38 < 0 )
          {
            LOWORD(v44) = (unsigned __int16)"invalid Unicode escape '%.6s'";
            arg = j;
LABEL_138:
            HIWORD(v44) = (unsigned int)"invalid Unicode escape '%.6s'" >> 16;
            format_error_message(a2, a1, 8, v44, arg);
            goto LABEL_55;
          }
          v47 = v38 - 55296;
          if ( (unsigned int)(v38 - 55296) >= 1024 )
          {
            if ( (unsigned int)(v38 - 56320) < 1024 )
              goto LABEL_142;
            j += 6;
          }
          else
          {
            if ( j[6] != 92 || j[7] != 117 )
            {
LABEL_142:
              format_error_message(a2, a1, 8, "invalid Unicode '\\u%04X'", v38);
              goto LABEL_55;
            }
            v40 = decode_unicode_escape(j + 7);
            if ( v40 < 0 )
            {
              LOWORD(v44) = -22884;
              arg = j + 6;
              goto LABEL_138;
            }
            j += 12;
            if ( (unsigned int)(v40 - 56320) >= 1024 )
            {
              format_error_message(a2, a1, 8, "invalid Unicode '\\u%04X\\u%04X'", v39, v40);
              goto LABEL_55;
            }
            v39 = v40 - 56320 + (v47 << 10) + 65536;
          }
          if ( encode_utf8_char(v39, v34, endptr) )
            _assert_fail("0", "load.c", 452u, "lex_scan_string");
          v34 += LODWORD(endptr[0]);
        }
        if ( v37 == 98 )
        {
          *v34 = 8;
        }
        else
        {
          if ( v37 <= 98 )
          {
            if ( v37 != 47 && v37 != 92 && v37 != 34 )
LABEL_130:
              _assert_fail("0", "load.c", 464u, "lex_scan_string");
            goto LABEL_125;
          }
          if ( v37 == 110 )
          {
            *v34 = 10;
          }
          else
          {
            if ( v37 <= 110 )
            {
              if ( v37 != 102 )
                goto LABEL_130;
              LOBYTE(v37) = 12;
LABEL_125:
              *v34 = v37;
              goto LABEL_106;
            }
            if ( v37 == 114 )
            {
              *v34 = 13;
            }
            else
            {
              if ( v37 != 116 )
                goto LABEL_130;
              *v34 = 9;
            }
          }
        }
LABEL_106:
        ++v34;
      }
    }
    if ( v17 == -2 )
      goto LABEL_55;
    if ( v17 == -1 )
    {
      format_error_message(a2, a1, 6, "premature end of input");
      goto LABEL_55;
    }
    if ( v17 <= 31 )
      break;
    v15 = a2;
    v16 = a1;
    if ( v17 == 92 )
    {
      v18 = get_result_code((int)a1, a2);
      if ( v18 == 117 )
      {
        v29 = 4;
        v17 = get_result_code((int)a1, a2);
        while ( 1 )
        {
          v30 = v17 & 0xFFFFFFDF;
          v31 = v17 - 48;
          v30 -= 65;
          v32 = v30 > 5;
          if ( v30 > 5 )
            v32 = v31 > 9;
          if ( v32 )
            break;
          --v29;
          v17 = get_result_code((int)a1, a2);
          if ( !v29 )
            goto LABEL_42;
        }
LABEL_54:
        format_error_message(a2, a1, 8, "invalid escape");
        goto LABEL_55;
      }
      v19 = v18 == 92;
      if ( v18 != 92 )
        v19 = (v18 & 0xFFFFFFBF) == 34;
      if ( !v19 && v18 != 47 && (v18 & 0xFFFFFFF7) != 102 && ((v18 - 114) & 0xFFFFFFFD) != 0 )
        goto LABEL_54;
      goto LABEL_40;
    }
  }
  put_char_back_to_buffer(a1, (_DWORD *)v17);
  if ( v17 == 10 )
    format_error_message(a2, a1, 8, "unexpected newline");
  else
    format_error_message(a2, a1, 8, "control character 0x%x", v17);
LABEL_55:
  check_and_perform_action(a1[16]);
  v8 = a1[15];
  a1[16] = 0;
  a1[17] = 0;
  return v8;
}

//----- (0004CDE4) --------------------------------------------------------
_DWORD *__fastcall sub_4CDE4(int json_parser_state, int parser_flags, int error_handler)
{
  unsigned int parsing_depth; // r3
  int current_token; // r3
  _DWORD *parsed_value; // r6
  _BYTE *string_buffer; // r7
  size_t string_length; // r9
  int object_token; // r3
  char *object_key; // r7
  unsigned int object_key_length; // r2
  _DWORD *object_value; // r2
  int comma_or_end_object_token; // r3
  unsigned int *ref_counter_pointer; // r3
  unsigned int ref_count; // r2
  unsigned int updated_ref_count; // r2
  int end_array_token; // r3
  int comma_or_end_array_token; // r3
  _DWORD *array_element_value; // r1
  unsigned int *array_ref_counter_pointer; // r3
  unsigned int array_ref_count; // r2
  _DWORD *finalized_value; // r0

  parsing_depth = *(_DWORD *)(json_parser_state + 56) + 1;
  *(_DWORD *)(json_parser_state + 56) = parsing_depth;
  if ( parsing_depth > 2048 )
  {
    parsed_value = 0;
    format_error_message(error_handler, (_DWORD *)json_parser_state, 2, "maximum parsing depth reached");
    return parsed_value;
  }
  current_token = *(_DWORD *)(json_parser_state + 60);
  if ( current_token == 257 )
  {
    parsed_value = (_DWORD *)init_asic_task(*(_QWORD *)(json_parser_state + 64));
    goto LABEL_9;
  }
  if ( current_token <= 257 )
  {
    if ( current_token == 91 )
    {
      parsed_value = get_asic_status();
      if ( !parsed_value )
        return 0;
      scan_json_token((_DWORD *)json_parser_state, error_handler);
      end_array_token = *(_DWORD *)(json_parser_state + 60);
      if ( end_array_token == 93 )
        goto LABEL_10;
      if ( end_array_token )
      {
        while ( 1 )
        {
          array_element_value = sub_4CDE4(json_parser_state, parser_flags, error_handler);
          if ( !array_element_value || add_to_buffer(parsed_value, array_element_value) )
            break;
          scan_json_token((_DWORD *)json_parser_state, error_handler);
          comma_or_end_array_token = *(_DWORD *)(json_parser_state + 60);
          if ( comma_or_end_array_token != 44 )
          {
            if ( comma_or_end_array_token == 93 )
              goto LABEL_10;
            goto LABEL_62;
          }
          scan_json_token((_DWORD *)json_parser_state, error_handler);
          if ( !*(_DWORD *)(json_parser_state + 60) )
            goto LABEL_62;
        }
      }
      else
      {
LABEL_62:
        format_error_message(error_handler, (_DWORD *)json_parser_state, 8, "']' expected");
      }
      if ( parsed_value[1] == -1 )
        return 0;
      array_ref_counter_pointer = parsed_value + 1;
      __dmb(11u);
      do
      {
        array_ref_count = __ldrex(array_ref_counter_pointer);
        updated_ref_count = array_ref_count - 1;
      }
      while ( __strex(updated_ref_count, array_ref_counter_pointer) );
    }
    else
    {
      if ( current_token <= 91 )
      {
        if ( current_token == -1 )
        {
          parsed_value = 0;
          format_error_message(error_handler, (_DWORD *)json_parser_state, 8, "invalid token");
          return parsed_value;
        }
        goto LABEL_57;
      }
      if ( current_token != 123 )
      {
        if ( current_token != 256 )
          goto LABEL_57;
        string_buffer = *(_BYTE **)(json_parser_state + 64);
        string_length = *(_DWORD *)(json_parser_state + 68);
        if ( (parser_flags & 0x10) == 0
          && memchr(*(char **)(json_parser_state + 64), 0, *(_DWORD *)(json_parser_state + 68)) )
        {
          parsed_value = 0;
          format_error_message(
            error_handler,
            (_DWORD *)json_parser_state,
            11,
            "\\u0000 is not allowed without JSON_ALLOW_NUL");
          return parsed_value;
        }
        parsed_value = parse_command(string_buffer, string_length);
        *(_DWORD *)(json_parser_state + 64) = 0;
        *(_DWORD *)(json_parser_state + 68) = 0;
        goto LABEL_9;
      }
      parsed_value = get_miner_status_and_init();
      if ( !parsed_value )
        return 0;
      scan_json_token((_DWORD *)json_parser_state, error_handler);
      object_token = *(_DWORD *)(json_parser_state + 60);
      if ( object_token == 125 )
        goto LABEL_10;
      if ( object_token == 256 )
      {
        object_key = *(char **)(json_parser_state + 64);
        object_key_length = *(_DWORD *)(json_parser_state + 68);
        *(_DWORD *)(json_parser_state + 64) = 0;
        *(_DWORD *)(json_parser_state + 68) = 0;
        if ( !object_key )
          return 0;
        while ( 1 )
        {
          if ( memchr(object_key, 0, object_key_length) )
          {
            check_and_perform_action((int)object_key);
            format_error_message(error_handler, (_DWORD *)json_parser_state, 13, "NUL byte in object key not supported");
            goto LABEL_36;
          }
          if ( (parser_flags & 1) != 0 && initiate_task_if_ready(parsed_value, object_key) )
          {
            check_and_perform_action((int)object_key);
            format_error_message(error_handler, (_DWORD *)json_parser_state, 14, "duplicate object key");
            goto LABEL_36;
          }
          scan_json_token((_DWORD *)json_parser_state, error_handler);
          if ( *(_DWORD *)(json_parser_state + 60) != 58 )
          {
            check_and_perform_action((int)object_key);
            format_error_message(error_handler, (_DWORD *)json_parser_state, 8, "':' expected");
            goto LABEL_36;
          }
          scan_json_token((_DWORD *)json_parser_state, error_handler);
          object_value = sub_4CDE4(json_parser_state, parser_flags, error_handler);
          if ( !object_value || add_task_if_possible(parsed_value, object_key, object_value) )
          {
            check_and_perform_action((int)object_key);
            goto LABEL_36;
          }
          check_and_perform_action((int)object_key);
          scan_json_token((_DWORD *)json_parser_state, error_handler);
          comma_or_end_object_token = *(_DWORD *)(json_parser_state + 60);
          if ( comma_or_end_object_token != 44 )
            break;
          scan_json_token((_DWORD *)json_parser_state, error_handler);
          if ( *(_DWORD *)(json_parser_state + 60) != 256 )
            goto LABEL_63;
          object_key = *(char **)(json_parser_state + 64);
          object_key_length = *(_DWORD *)(json_parser_state + 68);
          *(_DWORD *)(json_parser_state + 64) = 0;
          *(_DWORD *)(json_parser_state + 68) = 0;
          if ( !object_key )
            return 0;
        }
        if ( comma_or_end_object_token == 125 )
          goto LABEL_10;
        format_error_message(error_handler, (_DWORD *)json_parser_state, 8, "'}' expected");
      }
      else
      {
LABEL_63:
        format_error_message(error_handler, (_DWORD *)json_parser_state, 8, "string or '}' expected");
      }
LABEL_36:
      if ( parsed_value[1] == -1 )
        return 0;
      ref_counter_pointer = parsed_value + 1;
      __dmb(11u);
      do
      {
        ref_count = __ldrex(ref_counter_pointer);
        updated_ref_count = ref_count - 1;
      }
      while ( __strex(updated_ref_count, ref_counter_pointer) );
    }
    if ( !updated_ref_count )
    {
      finalized_value = parsed_value;
      parsed_value = 0;
      handle_task(finalized_value);
      return parsed_value;
    }
    return 0;
  }
  if ( current_token == 259 )
  {
    parsed_value = get_miner_hardware_info_pointer();
  }
  else if ( current_token < 259 )
  {
    parsed_value = (_DWORD *)process_double_value();
  }
  else
  {
    if ( current_token != 260 )
    {
      if ( current_token == 261 )
      {
        parsed_value = get_miner_config_pointer();
        goto LABEL_9;
      }
LABEL_57:
      parsed_value = 0;
      format_error_message(error_handler, (_DWORD *)json_parser_state, 8, "unexpected token");
      return parsed_value;
    }
    parsed_value = get_unk_7F578_address();
  }
LABEL_9:
  if ( parsed_value )
  {
LABEL_10:
    --*(_DWORD *)(json_parser_state + 56);
    return parsed_value;
  }
  return 0;
}

//----- (0004D288) --------------------------------------------------------
_DWORD *__fastcall parse_json_value(_DWORD *json_state, int parse_flags, int input_buffer)
{
  _DWORD *result_json_value; // r7
  unsigned int *ref_counter_ptr; // r3
  unsigned int current_ref_count; // r2
  unsigned int decremented_ref_count; // r2
  _DWORD *json_value_to_free; // r0

  json_state[14] = 0;
  scan_json_token(json_state, input_buffer);
  result_json_value = (_DWORD *)(parse_flags & 4);
  if ( (parse_flags & 4) == 0 && (json_state[15] & 0xFFFFFFDF) != 91 )
  {
    format_error_message(input_buffer, json_state, 8, "'[' or '{' expected");
    return result_json_value;
  }
  result_json_value = sub_4CDE4((int)json_state, parse_flags, input_buffer);
  if ( result_json_value )
  {
    if ( (parse_flags & 2) != 0 || (scan_json_token(json_state, input_buffer), !json_state[15]) )
    {
      if ( input_buffer )
        *(_DWORD *)(input_buffer + 8) = json_state[9];
      return result_json_value;
    }
    format_error_message(input_buffer, json_state, 7, "end of file expected");
    if ( result_json_value[1] != -1 )
    {
      ref_counter_ptr = result_json_value + 1;
      __dmb(11u);
      do
      {
        current_ref_count = __ldrex(ref_counter_ptr);
        decremented_ref_count = current_ref_count - 1;
      }
      while ( __strex(decremented_ref_count, ref_counter_ptr) );
      if ( !decremented_ref_count )
      {
        json_value_to_free = result_json_value;
        result_json_value = 0;
        handle_task(json_value_to_free);
        return result_json_value;
      }
    }
  }
  return 0;
}

//----- (0004D38C) --------------------------------------------------------
_DWORD *__fastcall parse_config(int is_config_valid, int config_len, char *config_data)
{
  _DWORD *parsed_config; // r4
  int callback_data[2]; // [sp+0h] [bp-68h] BYREF
  int parse_context[2]; // [sp+8h] [bp-60h] BYREF
  char parse_buffer_initialization_flag; // [sp+10h] [bp-58h]
  int read_callback_param3; // [sp+18h] [bp-50h]
  int read_callback_param4; // [sp+1Ch] [bp-4Ch]
  int parse_initialization_flag; // [sp+20h] [bp-48h]
  int read_callback_param6; // [sp+24h] [bp-44h]
  int read_callback_param7; // [sp+2Ch] [bp-3Ch]
  _DWORD command_buffer[14]; // [sp+30h] [bp-38h] BYREF

  reset_miner_status(config_data, "<string>");
  if ( is_config_valid )
  {
    parsed_config = 0;
    callback_data[0] = is_config_valid;
    parse_context[0] = (int)read_next_byte;
    callback_data[1] = 0;
    parse_buffer_initialization_flag = 0;
    read_callback_param3 = 0;
    read_callback_param4 = 0;
    read_callback_param6 = 0;
    read_callback_param7 = 0;
    parse_context[1] = (int)callback_data;
    parse_initialization_flag = 1;
    if ( !initialize_command_buffer(command_buffer) )
    {
      command_buffer[3] = config_len;
      command_buffer[5] = -1;
      parsed_config = parse_json_value(parse_context, config_len, (int)config_data);
      check_and_reset_buffer(parse_context);
    }
  }
  else
  {
    parsed_config = 0;
    format_error_message((int)config_data, 0, 4, "wrong arguments");
  }
  return parsed_config;
}

//----- (0004D454) --------------------------------------------------------
_DWORD *__fastcall sub_4D454(int a1, int a2, int a3, char *a4)
{
  _DWORD *v8; // r4
  int v10[3]; // [sp+4h] [bp-6Ch] BYREF
  int v11[2]; // [sp+10h] [bp-60h] BYREF
  char v12; // [sp+18h] [bp-58h]
  int v13; // [sp+20h] [bp-50h]
  int v14; // [sp+24h] [bp-4Ch]
  int v15; // [sp+28h] [bp-48h]
  int v16; // [sp+2Ch] [bp-44h]
  int v17; // [sp+34h] [bp-3Ch]
  _DWORD v18[14]; // [sp+38h] [bp-38h] BYREF

  reset_miner_status(a4, "<buffer>");
  if ( a1 )
  {
    v8 = 0;
    v10[0] = a1;
    v10[1] = a2;
    v11[0] = (int)get_next_value;
    v10[2] = 0;
    v12 = 0;
    v13 = 0;
    v14 = 0;
    v16 = 0;
    v17 = 0;
    v11[1] = (int)v10;
    v15 = 1;
    if ( !initialize_command_buffer(v18) )
    {
      v18[3] = a3;
      v18[5] = -1;
      v8 = parse_json_value(v11, a3, (int)a4);
      check_and_reset_buffer(v11);
    }
  }
  else
  {
    v8 = 0;
    format_error_message((int)a4, 0, 4, "wrong arguments");
  }
  return v8;
}

//----- (0004D528) --------------------------------------------------------
_DWORD *__fastcall parse_miner_command_response(int input_stream, int argument_2, char *status_message_buffer)
{
  char *stream_name; // r1
  _DWORD *parsed_result_ptr; // r4
  int command_buffer_setup[2]; // [sp+0h] [bp-60h] BYREF
  char buffer_char; // [sp+8h] [bp-58h]
  int buffer_int1; // [sp+10h] [bp-50h]
  int buffer_int2; // [sp+14h] [bp-4Ch]
  int buffer_int_flag; // [sp+18h] [bp-48h]
  int buffer_int3; // [sp+1Ch] [bp-44h]
  int buffer_int4; // [sp+24h] [bp-3Ch]
  _DWORD command_buffer[14]; // [sp+28h] [bp-38h] BYREF

  if ( stdin == input_stream )
    stream_name = "<stdin>";
  else
    stream_name = "<stream>";
  reset_miner_status(status_message_buffer, stream_name);
  if ( input_stream )
  {
    parsed_result_ptr = 0;
    command_buffer_setup[1] = input_stream;
    command_buffer_setup[0] = (int)fgetc;
    buffer_char = 0;
    buffer_int1 = 0;
    buffer_int2 = 0;
    buffer_int3 = 0;
    buffer_int4 = 0;
    buffer_int_flag = 1;
    if ( !initialize_command_buffer(command_buffer) )
    {
      command_buffer[3] = argument_2;
      command_buffer[5] = -1;
      parsed_result_ptr = parse_json_value(command_buffer_setup, argument_2, (int)status_message_buffer);
      check_and_reset_buffer(command_buffer_setup);
    }
  }
  else
  {
    parsed_result_ptr = 0;
    format_error_message((int)status_message_buffer, 0, 4, "wrong arguments");
  }
  return parsed_result_ptr;
}
// 7F798: using guessed type int stdin;

//----- (0004D608) --------------------------------------------------------
_DWORD *__fastcall sub_4D608(int a1, int a2, char *a3)
{
  char *v4; // r1
  _DWORD *v6; // r4
  int v8; // [sp+4h] [bp-5Ch] BYREF
  int v9[2]; // [sp+8h] [bp-58h] BYREF
  char v10; // [sp+10h] [bp-50h]
  int v11; // [sp+18h] [bp-48h]
  int v12; // [sp+1Ch] [bp-44h]
  int v13; // [sp+20h] [bp-40h]
  int v14; // [sp+24h] [bp-3Ch]
  int v15; // [sp+2Ch] [bp-34h]
  _DWORD v16[12]; // [sp+30h] [bp-30h] BYREF

  v8 = a1;
  if ( a1 )
    v4 = "<stream>";
  else
    v4 = "<stdin>";
  reset_miner_status(a3, v4);
  if ( v8 < 0 )
  {
    v6 = 0;
    format_error_message((int)a3, 0, 4, "wrong arguments");
  }
  else
  {
    v6 = 0;
    v9[0] = (int)read_single_byte;
    v9[1] = (int)&v8;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v14 = 0;
    v15 = 0;
    v13 = 1;
    if ( !initialize_command_buffer(v16) )
    {
      v16[3] = a2;
      v16[5] = -1;
      v6 = parse_json_value(v9, a2, (int)a3);
      check_and_reset_buffer(v9);
    }
  }
  return v6;
}

//----- (0004D6E4) --------------------------------------------------------
_DWORD *__fastcall update_miner_status_from_config(
        char *config_file_path,
        int config_flags,
        char *miner_status_context)
{
  int file_descriptor; // r0
  FILE *config_file_stream; // r7
  _DWORD *update_status_result; // r6
  int *errno_address; // r0
  char *error_message; // r0

  reset_miner_status(miner_status_context, config_file_path);
  if ( config_file_path )
  {
    file_descriptor = fopen64(config_file_path, "rb");
    config_file_stream = (FILE *)file_descriptor;
    if ( file_descriptor )
    {
      update_status_result = parse_miner_command_response(file_descriptor, config_flags, miner_status_context);
      fclose(config_file_stream);
    }
    else
    {
      errno_address = _errno_location();
      update_status_result = 0;
      error_message = strerror(*errno_address);
      format_error_message((int)miner_status_context, 0, 3, "unable to open %s: %s", config_file_path, error_message);
    }
  }
  else
  {
    update_status_result = 0;
    format_error_message((int)miner_status_context, 0, 4, "wrong arguments");
  }
  return update_status_result;
}
// 124E4: using guessed type int __fastcall fopen64(_DWORD, _DWORD);

//----- (0004D880) --------------------------------------------------------
int __fastcall check_and_process_result(int result)
{
  if ( result )
    return off_7F568(result);
  return result;
}
// 7F568: using guessed type int (__fastcall *off_7F568)(_DWORD);

//----- (0004D898) --------------------------------------------------------
int __fastcall check_and_perform_action(int action_performed)
{
  if ( action_performed )
    return off_7F56C();
  return action_performed;
}
// 7F56C: using guessed type int (*off_7F56C)(void);

//----- (0004D8B0) --------------------------------------------------------
_BYTE *__fastcall copy_string_with_null_termination(const void *source, size_t length)
{
  size_t buffer_size_or_result; // r5
  void *allocated_buffer; // r0

  buffer_size_or_result = length + 1;
  if ( length != -1 )
  {
    allocated_buffer = (void *)off_7F568(length + 1);
    buffer_size_or_result = (size_t)allocated_buffer;
    if ( allocated_buffer )
    {
      memcpy(allocated_buffer, source, length);
      *(_BYTE *)(buffer_size_or_result + length) = 0;
    }
  }
  return (_BYTE *)buffer_size_or_result;
}
// 7F568: using guessed type int (__fastcall *off_7F568)(_DWORD);

//----- (0004D8FC) --------------------------------------------------------
_BYTE *__fastcall sub_4D8FC(const char *a1)
{
  size_t v2; // r1

  v2 = strlen(a1);
  return copy_string_with_null_termination(a1, v2);
}

//----- (0004D918) --------------------------------------------------------
int __fastcall set_global_value(__int64 new_global_value)
{
  *(_QWORD *)&off_7F568 = new_global_value;
  return new_global_value;
}
// 7F568: using guessed type int (__fastcall *off_7F568)(_DWORD);

//----- (0004D928) --------------------------------------------------------
_DWORD *__fastcall set_error_callbacks(_DWORD *first_callback_set, _DWORD *second_callback_set)
{
  if ( first_callback_set )
    *first_callback_set = off_7F568;
  if ( second_callback_set )
    *second_callback_set = off_7F56C;
  return first_callback_set;
}
// 7F568: using guessed type int (__fastcall *off_7F568)(_DWORD);
// 7F56C: using guessed type int (*off_7F56C)(void);

//----- (0004D954) --------------------------------------------------------
int __fastcall initialize_command_buffer(_DWORD *command_buffer)
{
  _BYTE *buffer; // r0

  command_buffer[2] = 16;
  command_buffer[1] = 0;
  buffer = (_BYTE *)check_and_process_result(16);
  *command_buffer = buffer;
  if ( !buffer )
    return -1;
  *buffer = 0;
  return 0;
}

//----- (0004D988) --------------------------------------------------------
int __fastcall perform_maintenance_and_reset(int *status_variables)
{
  int action_result; // r0

  action_result = *status_variables;
  if ( action_result )
    action_result = check_and_perform_action(action_result);
  status_variables[2] = 0;
  status_variables[1] = 0;
  *status_variables = 0;
  return action_result;
}

//----- (0004D9B4) --------------------------------------------------------
int __fastcall reset_buffer(int buffer_ptr)
{
  _BYTE *buffer; // r2

  buffer = *(_BYTE **)buffer_ptr;
  *(_DWORD *)(buffer_ptr + 4) = 0;
  *buffer = 0;
  return buffer_ptr;
}

//----- (0004D9C8) --------------------------------------------------------
int __fastcall sub_4D9C8(int a1)
{
  return *(_DWORD *)a1;
}

//----- (0004D9D0) --------------------------------------------------------
int __fastcall reset_and_return_previous_value(int *value_ptr)
{
  int previous_value; // r0

  previous_value = *value_ptr;
  *value_ptr = 0;
  return previous_value;
}

//----- (0004D9E4) --------------------------------------------------------
int __fastcall copy_data_to_buffer(const void **buffer_info, void *source_data, size_t data_length)
{
  unsigned int end_buffer_size; // r3
  _BYTE *current_position; // r0
  const void *new_buffer; // r8
  unsigned int double_buffer_size; // r3
  unsigned int required_size; // r0
  const void *new_size_or_double; // r6
  void *reallocated_buffer; // r0
  const void *base_buffer; // r2
  int return_status; // r0
  char *new_current_position; // r5

  end_buffer_size = (unsigned int)buffer_info[2];
  current_position = buffer_info[1];
  if ( end_buffer_size - (unsigned int)current_position > data_length )
  {
    new_buffer = *buffer_info;
LABEL_10:
    memcpy(&current_position[(_DWORD)new_buffer], source_data, data_length);
    base_buffer = *buffer_info;
    return_status = 0;
    new_current_position = (char *)buffer_info[1] + data_length;
    buffer_info[1] = new_current_position;
    new_current_position[(_DWORD)base_buffer] = 0;
    return return_status;
  }
  if ( !((data_length == -1) | (end_buffer_size >> 31)) && -2 - data_length >= (unsigned int)current_position )
  {
    double_buffer_size = 2 * end_buffer_size;
    required_size = (unsigned int)&current_position[data_length + 1];
    new_size_or_double = (const void *)(required_size < double_buffer_size ? double_buffer_size : required_size);
    reallocated_buffer = (void *)check_and_process_result((int)new_size_or_double);
    new_buffer = reallocated_buffer;
    if ( reallocated_buffer )
    {
      memcpy(reallocated_buffer, *buffer_info, (size_t)buffer_info[1]);
      check_and_perform_action((int)*buffer_info);
      current_position = buffer_info[1];
      *buffer_info = new_buffer;
      buffer_info[2] = new_size_or_double;
      goto LABEL_10;
    }
  }
  return -1;
}

//----- (0004DAB0) --------------------------------------------------------
int __fastcall write_single_char_to_buffer(const void **buffer_ptr, char character)
{
  char character_copy; // [sp+7h] [bp-9h] BYREF

  character_copy = character;
  return copy_data_to_buffer(buffer_ptr, &character_copy, 1u);
}

//----- (0004DAD4) --------------------------------------------------------
int __fastcall pop_byte_from_buffer(int *buffer_info, char replacement_byte, int buffer_location)
{
  int buffer_size; // r3
  bool is_buffer_empty; // zf
  int popped_byte; // r0

  buffer_size = buffer_info[1];
  is_buffer_empty = buffer_size == 0;
  if ( buffer_size )
  {
    buffer_location = *buffer_info;
    --buffer_size;
    replacement_byte = 0;
    buffer_info[1] = buffer_size;
    popped_byte = *(unsigned __int8 *)(buffer_location + buffer_size);
  }
  else
  {
    popped_byte = 0;
  }
  if ( !is_buffer_empty )
    *(_BYTE *)(buffer_location + buffer_size) = replacement_byte;
  return popped_byte;
}

//----- (0004DB00) --------------------------------------------------------
int __fastcall parse_decimal_string(int input_string_ptr, double *output_double_ptr)
{
  double parsed_double; // d0
  struct lconv *locale_info; // r0
  const char *decimal_string; // r5
  int decimal_point_char; // r6
  char *point_char_position; // r0
  int *errno_ptr; // r6
  int parse_result; // r0
  char *end_pointer; // [sp+4h] [bp-1Ch] BYREF

  locale_info = localeconv();
  decimal_string = *(const char **)input_string_ptr;
  decimal_point_char = *(unsigned __int8 *)locale_info->decimal_point;
  if ( decimal_point_char != 46 )
  {
    point_char_position = strchr(*(const char **)input_string_ptr, 46);
    if ( point_char_position )
    {
      *point_char_position = decimal_point_char;
      decimal_string = *(const char **)input_string_ptr;
    }
  }
  errno_ptr = _errno_location();
  *errno_ptr = 0;
  strtod(decimal_string, &end_pointer);
  if ( end_pointer != (char *)(*(_DWORD *)input_string_ptr + *(_DWORD *)(input_string_ptr + 4)) )
    _assert_fail("end == strbuffer->value + strbuffer->length", "strconv.c", 78u, "jsonp_strtod");
  if ( (parsed_double > 1.79769313e308 || parsed_double < -1.79769313e308) && *errno_ptr == 34 )
    return -1;
  parse_result = 0;
  *output_double_ptr = parsed_double;
  return parse_result;
}
// 4DB80: variable 'parsed_double' is possibly undefined

//----- (0004DBF0) --------------------------------------------------------
int __fastcall format_float_to_string(char *destination, size_t max_size)
{
  unsigned int formatted_length; // r0
  unsigned int final_length; // r6
  int local_decimal_point; // r1
  char *local_decimal_point_position; // r0
  char *period_position; // r5
  char *exponent_position; // r0
  unsigned __int8 *exponent_digit_pointer; // r4
  int current_exponent_digit; // r3
  _BYTE *move_destination; // r5
  int next_exponent_digit; // t1
  size_t remaining_length; // r2
  char *new_period_position; // r3

  formatted_length = snprintf(destination, max_size, "%.*g");
  if ( max_size > formatted_length )
  {
    final_length = formatted_length;
    local_decimal_point = *(unsigned __int8 *)localeconv()->decimal_point;
    if ( local_decimal_point != 46 )
    {
      local_decimal_point_position = strchr(destination, local_decimal_point);
      if ( local_decimal_point_position )
        *local_decimal_point_position = 46;
    }
    period_position = strchr(destination, 46);
    exponent_position = strchr(destination, 101);
    if ( period_position )
    {
LABEL_6:
      if ( !exponent_position )
        return final_length;
      goto LABEL_7;
    }
    if ( exponent_position )
    {
LABEL_7:
      exponent_digit_pointer = (unsigned __int8 *)(exponent_position + 2);
      current_exponent_digit = (unsigned __int8)exponent_position[2];
      if ( exponent_position[1] != 45 )
      {
        move_destination = exponent_position + 1;
        if ( current_exponent_digit != 48 )
        {
LABEL_10:
          if ( exponent_digit_pointer != move_destination )
          {
            remaining_length = final_length - (exponent_digit_pointer - (unsigned __int8 *)destination);
            final_length -= exponent_digit_pointer - move_destination;
            memmove(move_destination, exponent_digit_pointer, remaining_length);
          }
          return final_length;
        }
        do
LABEL_9:
          next_exponent_digit = *++exponent_digit_pointer;
        while ( next_exponent_digit == 48 );
        goto LABEL_10;
      }
      if ( current_exponent_digit == 48 )
      {
        move_destination = exponent_position + 2;
        goto LABEL_9;
      }
      return final_length;
    }
    if ( final_length + 3 < max_size )
    {
      destination[final_length] = 46;
      new_period_position = &destination[final_length];
      final_length += 2;
      new_period_position[1] = 48;
      destination[final_length] = 0;
      exponent_position = strchr(destination, 101);
      goto LABEL_6;
    }
  }
  return -1;
}

//----- (0004DD30) --------------------------------------------------------
int __fastcall encode_utf8_char(int input_char, _BYTE *output_buffer, _DWORD *output_size)
{
  char byte4; // r3
  int status; // r0
  char byte2; // r3
  char byte3; // r3
  unsigned int temp_byte2; // r12

  if ( input_char < 0 )
    return -1;
  if ( input_char <= 127 )
  {
    *output_buffer = input_char;
    status = 0;
    *output_size = 1;
  }
  else if ( input_char < 2048 )
  {
    byte2 = (input_char & 0x3F) + -128;
    *output_buffer = (input_char >> 6) - 64;
    status = 0;
    output_buffer[1] = byte2;
    *output_size = 2;
  }
  else if ( input_char < 65536 )
  {
    byte3 = (input_char & 0x3F) + -128;
    temp_byte2 = (((unsigned int)input_char >> 6) & 0x3F) - 128;
    *output_buffer = (input_char >> 12) - 32;
    status = 0;
    output_buffer[1] = temp_byte2;
    output_buffer[2] = byte3;
    *output_size = 3;
  }
  else if ( input_char >= 1114112 )
  {
    return -1;
  }
  else
  {
    byte4 = (input_char & 0x3F) + -128;
    *output_buffer = (input_char >> 18) - 16;
    output_buffer[1] = (((unsigned int)input_char >> 12) & 0x3F) + -128;
    output_buffer[2] = (((unsigned int)input_char >> 6) & 0x3F) + -128;
    status = 0;
    output_buffer[3] = byte4;
    *output_size = 4;
  }
  return status;
}

//----- (0004DE1C) --------------------------------------------------------
int __fastcall check_temperature_range(int temperature_code)
{
  if ( (temperature_code & 0x80) == 0 )
    return 1;
  if ( (temperature_code ^ 0x80u) <= 65 )
    return 0;
  if ( (unsigned __int8)(temperature_code + 62) <= 29u )
    return 2;
  if ( (unsigned __int8)(temperature_code + 32) <= 15u )
    return 3;
  if ( (unsigned __int8)(temperature_code + 16) <= 4u )
    return 4;
  return 0;
}

//----- (0004DE88) --------------------------------------------------------
bool __fastcall validate_utf8_encoding(char *input_string, unsigned int encoding_length, int *output_codepoint)
{
  char first_byte; // lr
  int codepoint; // lr
  _BOOL4 is_valid; // r0
  int next_byte; // r3
  char *current_ptr; // r0
  unsigned int bytes_processed; // r12
  int current_byte; // t1
  bool is_control_character; // zf
  _BOOL4 is_valid_for_encoding_3; // r3
  _BOOL4 is_valid_for_encoding_4; // r1

  first_byte = *input_string;
  switch ( encoding_length )
  {
    case 2u:
      codepoint = first_byte & 0x1F;
      break;
    case 3u:
      codepoint = first_byte & 0xF;
      break;
    case 4u:
      codepoint = first_byte & 7;
      break;
    default:
      return 0;
  }
  next_byte = (unsigned __int8)input_string[1];
  if ( (next_byte ^ 0x80u) > 63 )
    return 0;
  current_ptr = input_string + 1;
  bytes_processed = 1;
  while ( 1 )
  {
    ++bytes_processed;
    codepoint = (next_byte & 0x3F) + (codepoint << 6);
    if ( encoding_length <= bytes_processed )
      break;
    current_byte = (unsigned __int8)*++current_ptr;
    LOBYTE(next_byte) = current_byte;
    if ( (current_byte ^ 0x80u) > 63 )
      return 0;
  }
  if ( codepoint >= 1114112 || (unsigned int)(codepoint - 55296) < 2048 )
    return 0;
  is_control_character = codepoint == 127;
  if ( codepoint <= 127 )
    is_control_character = encoding_length == 2;
  is_valid = is_control_character;
  if ( is_control_character )
    return 0;
  is_valid_for_encoding_3 = encoding_length == 3;
  if ( codepoint >= 2048 )
    is_valid_for_encoding_3 = 0;
  if ( !is_valid_for_encoding_3 )
  {
    is_valid_for_encoding_4 = encoding_length == 4;
    if ( codepoint >= 65536 )
      is_valid_for_encoding_4 = 0;
    if ( !is_valid_for_encoding_4 )
    {
      is_valid = 1;
      if ( output_codepoint )
        *output_codepoint = codepoint;
      return is_valid;
    }
    return 0;
  }
  return is_valid;
}

//----- (0004DF70) --------------------------------------------------------
char *__fastcall extract_chip_temperature_info(
        char *temperature_info_string,
        int should_extract,
        _DWORD *extracted_temperature)
{
  char *temp_info_ptr; // r4
  unsigned int temp_length; // r0
  unsigned int max_length; // r1
  int temperature_value; // r2
  unsigned int adjusted_length; // r6
  int temperature; // [sp+4h] [bp-14h] BYREF

  if ( should_extract )
  {
    temp_info_ptr = temperature_info_string;
    temp_length = check_temperature_range((unsigned __int8)*temperature_info_string);
    adjusted_length = temp_length;
    if ( temp_length )
    {
      if ( temp_length == 1 )
      {
        temperature = temperature_value;
LABEL_7:
        temperature_info_string = &temp_info_ptr[adjusted_length];
        if ( extracted_temperature )
          *extracted_temperature = temperature;
        return temperature_info_string;
      }
      if ( max_length >= temp_length && validate_utf8_encoding(temp_info_ptr, temp_length, &temperature) )
        goto LABEL_7;
    }
    return 0;
  }
  return temperature_info_string;
}
// 4DFA0: variable 'temperature_value' is possibly undefined
// 4DFAC: variable 'max_length' is possibly undefined

//----- (0004DFEC) --------------------------------------------------------
int __fastcall check_valid_utf8_sequence(int string_pointer, unsigned int string_length)
{
  int current_index; // r4
  unsigned int utf8_char_length; // r5
  char *utf8_char_pointer; // r0

  if ( !string_length )
    return 1;
  current_index = 0;
  while ( 1 )
  {
    utf8_char_length = check_temperature_range(*(unsigned __int8 *)(string_pointer + current_index));
    utf8_char_pointer = (char *)(string_pointer + current_index);
    if ( !utf8_char_length )
      break;
    if ( utf8_char_length > 1 )
    {
      if ( string_length - current_index < utf8_char_length )
        break;
      current_index = utf8_char_length + current_index - 1;
      if ( !validate_utf8_encoding(utf8_char_pointer, utf8_char_length, 0) )
        break;
    }
    if ( string_length <= ++current_index )
      return 1;
  }
  return 0;
}

//----- (0004E068) --------------------------------------------------------
int __fastcall update_status_data(int current_status_ptr)
{
  __int64 data_to_copy; // r4
  int new_status_ptr; // r0

  if ( current_status_ptr && *(_DWORD *)current_status_ptr == 3 )
    data_to_copy = *(_QWORD *)(current_status_ptr + 8);
  else
    data_to_copy = 0LL;
  new_status_ptr = check_and_process_result(16);
  if ( new_status_ptr )
  {
    *(_QWORD *)(new_status_ptr + 8) = data_to_copy;
    *(_DWORD *)new_status_ptr = 3;
    *(_DWORD *)(new_status_ptr + 4) = 1;
  }
  return new_status_ptr;
}

//----- (0004E0B8) --------------------------------------------------------
const void *__fastcall extend_buffer_if_needed(_DWORD *buffer_info, int required_size, int preserve_data)
{
  unsigned int current_capacity; // r12
  const void *current_buffer; // r5
  unsigned int double_capacity; // r3
  unsigned int new_required_capacity; // r12
  unsigned int new_capacity; // r7
  void *new_buffer; // r0

  current_capacity = buffer_info[2];
  current_buffer = (const void *)buffer_info[4];
  if ( required_size + buffer_info[3] <= current_capacity )
    return current_buffer;
  double_capacity = 2 * current_capacity;
  new_required_capacity = current_capacity + required_size;
  if ( double_capacity < new_required_capacity )
    new_capacity = new_required_capacity;
  else
    new_capacity = double_capacity;
  new_buffer = (void *)check_and_process_result(4 * new_capacity);
  if ( !new_buffer )
    return 0;
  buffer_info[2] = new_capacity;
  buffer_info[4] = new_buffer;
  if ( !preserve_data )
    return current_buffer;
  memcpy(new_buffer, current_buffer, 4 * buffer_info[3]);
  check_and_perform_action((int)current_buffer);
  return (const void *)buffer_info[4];
}

//----- (0004E144) --------------------------------------------------------
_DWORD *__fastcall process_input_data(_BYTE *input_data, size_t data_size, int flag)
{
  _BYTE *processed_input; // r5
  _DWORD *result_structure; // r0

  processed_input = input_data;
  if ( !input_data )
    return 0;
  if ( !flag )
  {
    processed_input = copy_string_with_null_termination(input_data, data_size);
    if ( !processed_input )
      return 0;
  }
  result_structure = (_DWORD *)check_and_process_result(16);
  if ( result_structure )
  {
    result_structure[2] = processed_input;
    result_structure[3] = data_size;
    *result_structure = 2;
    result_structure[1] = 1;
  }
  else
  {
    check_and_perform_action((int)processed_input);
    return 0;
  }
  return result_structure;
}

//----- (0004E1B0) --------------------------------------------------------
_DWORD *get_miner_status_and_init()
{
  _DWORD *miner_status_ptr; // r4
  int status_ptr_as_int; // r0

  miner_status_ptr = (_DWORD *)check_and_process_result(36);
  if ( miner_status_ptr )
  {
    if ( !dword_5051C0 )
      initialize_random_seed(dword_5051C0);
    miner_status_ptr[1] = 1;
    *miner_status_ptr = 0;
    if ( initialize_miner_queue(miner_status_ptr + 2) )
    {
      status_ptr_as_int = (int)miner_status_ptr;
      miner_status_ptr = 0;
      check_and_perform_action(status_ptr_as_int);
    }
  }
  return miner_status_ptr;
}
// 5051C0: using guessed type int dword_5051C0;

//----- (0004E218) --------------------------------------------------------
_DWORD *__fastcall get_error_or_success_code_pointer(_DWORD *status_code_pointer)
{
  if ( status_code_pointer )
  {
    if ( *status_code_pointer )
      return 0;
    else
      return (_DWORD *)status_code_pointer[2];
  }
  return status_code_pointer;
}

//----- (0004E234) --------------------------------------------------------
int __fastcall initiate_task_if_ready(_DWORD *task_struct_pointer, char *input_data_pointer)
{
  bool is_invalid_pointer; // zf

  is_invalid_pointer = task_struct_pointer == 0;
  if ( task_struct_pointer )
    is_invalid_pointer = input_data_pointer == 0;
  if ( is_invalid_pointer || *task_struct_pointer )
    return 0;
  else
    return calculate_hash_and_find_task((int)(task_struct_pointer + 2), input_data_pointer);
}

//----- (0004E25C) --------------------------------------------------------
bool __fastcall compare_structures(int *structure_one, int *structure_two)
{
  int struct_type; // r3
  int array_length_one; // r7
  int array_length_two; // r2
  unsigned int index; // r6
  int *element_pointer_two; // r1
  bool is_null; // zf
  int *element_pointer_one; // r0
  int *current_element_pointer_one; // r8
  int current_element; // r0
  int *potential_match_two; // r1
  int offset_result; // r0
  char *offset_char_pointer; // r6
  int register_value; // r7
  int status_of_offset; // r0
  char *offset_as_char; // r1
  int *status_register_pointer; // r6
  size_t data_length_one; // r2

  struct_type = *structure_one;
  if ( *structure_one != *structure_two )
    return 0;
  if ( structure_one == structure_two )
    return 1;
  switch ( struct_type )
  {
    case 0:
      if ( structure_one[2] != structure_two[2] )
        return 0;
      current_element_pointer_one = structure_one + 2;
      current_element = get_next_element((int)(structure_one + 2));
      if ( !current_element )
        return 1;
      while ( 1 )
      {
        offset_result = calculate_offset(current_element);
        offset_char_pointer = (char *)offset_result;
        if ( !offset_result )
          break;
        register_value = offset_result - 16;
        status_of_offset = get_status_register(offset_result - 16);
        offset_as_char = offset_char_pointer;
        status_register_pointer = (int *)status_of_offset;
        if ( !status_of_offset )
          break;
        potential_match_two = (int *)initiate_task_if_ready(structure_two, offset_as_char);
        if ( !potential_match_two || !compare_structures(status_register_pointer, potential_match_two) )
          return 0;
        if ( !*structure_one )
        {
          current_element = check_matching_values((int)current_element_pointer_one, register_value);
          if ( current_element )
            continue;
        }
        return 1;
      }
      return 1;
    case 1:
      array_length_one = structure_one[3];
      if ( array_length_one != structure_two[3] )
        return 0;
      if ( !array_length_one )
        return 1;
      array_length_two = *structure_one;
      index = 0;
      break;
    case 2:
      data_length_one = structure_one[3];
      return data_length_one == structure_two[3]
          && !memcmp((const void *)structure_one[2], (const void *)structure_two[2], data_length_one);
    case 3:
      return *((_QWORD *)structure_one + 1) == *((_QWORD *)structure_two + 1);
    case 4:
      return *((double *)structure_one + 1) == *((double *)structure_two + 1);
    default:
      return 0;
  }
  while ( 1 )
  {
    if ( struct_type == 1 && structure_one[3] > index )
      element_pointer_one = *(int **)(structure_one[4] + 4 * index);
    else
      element_pointer_one = 0;
    if ( array_length_two != 1 || structure_two[3] <= index )
      return 0;
    element_pointer_two = *(int **)(structure_two[4] + 4 * index);
    is_null = element_pointer_two == 0;
    if ( element_pointer_two )
      is_null = element_pointer_one == 0;
    if ( is_null || !compare_structures(element_pointer_one, element_pointer_two) )
      return 0;
    if ( array_length_one == ++index )
      break;
    struct_type = *structure_one;
    array_length_two = *structure_two;
  }
  return 1;
}
// 4E290: control flows out of bounds to 4E294

//----- (0004E43C) --------------------------------------------------------
int __fastcall check_and_remove_task(_DWORD *task_handle_ptr, char *task_name)
{
  bool invalid_args; // zf

  invalid_args = task_handle_ptr == 0;
  if ( task_handle_ptr )
    invalid_args = task_name == 0;
  if ( invalid_args || *task_handle_ptr )
    return -1;
  else
    return remove_named_task(task_handle_ptr + 2, task_name);
}

//----- (0004E49C) --------------------------------------------------------
int __fastcall is_empty_and_get_next_element(_DWORD *element_ptr)
{
  if ( !element_ptr || *element_ptr )
    return 0;
  else
    return get_next_element((int)(element_ptr + 2));
}

//----- (0004E4C0) --------------------------------------------------------
int __fastcall check_task_info(_DWORD *task_info_address, char *string_hash)
{
  bool hashes_invalid; // zf

  hashes_invalid = task_info_address == 0;
  if ( task_info_address )
    hashes_invalid = string_hash == 0;
  if ( hashes_invalid || *task_info_address )
    return 0;
  else
    return get_task_info_by_string_hash((int)(task_info_address + 2), string_hash);
}

//----- (0004E4E8) --------------------------------------------------------
int __fastcall is_value_nonzero_and_matches(_DWORD *possible_value_ptr, int compare_value)
{
  _BOOL4 is_match_or_zero_pointer; // r3

  if ( !possible_value_ptr )
    return 0;
  is_match_or_zero_pointer = compare_value == 0;
  if ( *possible_value_ptr )
    is_match_or_zero_pointer = 1;
  if ( is_match_or_zero_pointer )
    return 0;
  else
    return check_matching_values((int)(possible_value_ptr + 2), compare_value);
}

//----- (0004E51C) --------------------------------------------------------
int __fastcall check_and_calculate_offset(int initial_value)
{
  if ( initial_value )
    return calculate_offset(initial_value);
  return initial_value;
}

//----- (0004E528) --------------------------------------------------------
int __fastcall get_status_if_non_zero(int status)
{
  if ( status )
    return get_status_register(status);
  return status;
}

//----- (0004E534) --------------------------------------------------------
int __fastcall adjust_pointer_backwards(int pointer)
{
  if ( pointer )
    pointer -= 16;
  return pointer;
}

//----- (0004E540) --------------------------------------------------------
_DWORD *get_asic_status()
{
  _DWORD *raw_status_pointer; // r0
  _DWORD *status_pointer; // r4
  int asic_processing_status; // r0
  int status_integer; // r0

  raw_status_pointer = (_DWORD *)check_and_process_result(20);
  status_pointer = raw_status_pointer;
  if ( raw_status_pointer )
  {
    *raw_status_pointer = 1;
    raw_status_pointer[1] = 1;
    raw_status_pointer[3] = 0;
    raw_status_pointer[2] = 8;
    asic_processing_status = check_and_process_result(32);
    status_pointer[4] = asic_processing_status;
    if ( !asic_processing_status )
    {
      status_integer = (int)status_pointer;
      status_pointer = 0;
      check_and_perform_action(status_integer);
    }
  }
  return status_pointer;
}

//----- (0004E5A0) --------------------------------------------------------
_DWORD *__fastcall get_associated_pointer_or_null(_DWORD *pointer)
{
  if ( pointer )
  {
    if ( *pointer == 1 )
      return (_DWORD *)pointer[3];
    else
      return 0;
  }
  return pointer;
}

//----- (0004E5BC) --------------------------------------------------------
_DWORD *__fastcall get_task_by_index(_DWORD *task_list, unsigned int task_index)
{
  if ( task_list )
  {
    if ( *task_list == 1 && task_list[3] > task_index )
      return *(_DWORD **)(task_list[4] + 4 * task_index);
    else
      return 0;
  }
  return task_list;
}

//----- (0004E5F0) --------------------------------------------------------
int __fastcall copy_and_increment_buffer_values(_DWORD *destination_buffer, _DWORD *source_buffer)
{
  _BOOL4 is_invalid_input; // r4
  __int64 source_items; // r0
  size_t items_size; // r2
  unsigned int item_index; // r3
  int source_item_pointer; // r2
  int source_item_value; // r12
  unsigned int *source_item_ref; // r2
  unsigned int incremented_value; // r1
  int copy_result; // r0

  if ( !destination_buffer )
    return -1;
  is_invalid_input = *destination_buffer != 1 || source_buffer == 0;
  if ( is_invalid_input || *source_buffer != 1 || !extend_buffer_if_needed(destination_buffer, source_buffer[3], 1) )
    return -1;
  source_items = *(_QWORD *)(source_buffer + 3);
  items_size = source_buffer[3];
  if ( (_DWORD)source_items )
  {
    item_index = 0;
    do
    {
      source_item_pointer = *(_DWORD *)(HIDWORD(source_items) + 4 * item_index);
      if ( source_item_pointer )
      {
        source_item_value = *(_DWORD *)(source_item_pointer + 4);
        source_item_ref = (unsigned int *)(source_item_pointer + 4);
        if ( source_item_value != -1 )
        {
          do
            incremented_value = __ldrex(source_item_ref);
          while ( __strex(incremented_value + 1, source_item_ref) );
          __dmb(11u);
          source_items = *(_QWORD *)(source_buffer + 3);
        }
      }
      ++item_index;
    }
    while ( (unsigned int)source_items > item_index );
    items_size = 4 * source_items;
  }
  memcpy((void *)(destination_buffer[4] + 4 * destination_buffer[3]), (const void *)HIDWORD(source_items), items_size);
  copy_result = 0;
  destination_buffer[3] += source_buffer[3];
  return copy_result;
}

//----- (0004E6C8) --------------------------------------------------------
const char *__fastcall process_input_string(const char *input_string)
{
  char *input_char_pointer; // r4
  size_t input_length; // r0

  if ( input_string )
  {
    input_char_pointer = (char *)input_string;
    input_length = strlen(input_string);
    return (const char *)process_input_data(input_char_pointer, input_length, 0);
  }
  return input_string;
}

//----- (0004E6F0) --------------------------------------------------------
_DWORD *__fastcall process_input_wrapper(_BYTE *input_data, size_t input_length)
{
  return process_input_data(input_data, input_length, 0);
}

//----- (0004E6F8) --------------------------------------------------------
_DWORD *__fastcall parse_command(_BYTE *command_buffer, size_t buffer_length)
{
  return process_input_data(command_buffer, buffer_length, 1);
}

//----- (0004E700) --------------------------------------------------------
_DWORD *__fastcall process_utf8_input(_BYTE *input_buffer, size_t buffer_size)
{
  if ( !input_buffer )
    return 0;
  if ( check_valid_utf8_sequence((int)input_buffer, buffer_size) )
    return process_input_data(input_buffer, buffer_size, 0);
  return 0;
}

//----- (0004E744) --------------------------------------------------------
const char *__fastcall sanitize_utf8_string(const char *input_string)
{
  char *non_const_input_str; // r4
  size_t input_str_length; // r0

  if ( input_string )
  {
    non_const_input_str = (char *)input_string;
    input_str_length = strlen(input_string);
    return (const char *)process_utf8_input(non_const_input_str, input_str_length);
  }
  return input_string;
}

//----- (0004E768) --------------------------------------------------------
_DWORD *__fastcall get_second_element_if_ready(_DWORD *array_pointer)
{
  if ( array_pointer )
  {
    if ( *array_pointer == 2 )
      return (_DWORD *)array_pointer[2];
    else
      return 0;
  }
  return array_pointer;
}

//----- (0004E784) --------------------------------------------------------
_DWORD *__fastcall get_config_address(_DWORD *config_ptr)
{
  if ( config_ptr )
  {
    if ( *config_ptr == 2 )
      return (_DWORD *)config_ptr[3];
    else
      return 0;
  }
  return config_ptr;
}

//----- (0004E7A0) --------------------------------------------------------
int __fastcall update_miner_configuration(_DWORD *miner_config, const void *config_data, size_t data_length)
{
  _BYTE *copied_config; // r7
  int status; // r0

  if ( !miner_config )
    return -1;
  if ( *miner_config != 2 || config_data == 0 )
    return -1;
  copied_config = copy_string_with_null_termination(config_data, data_length);
  if ( !copied_config )
    return -1;
  check_and_perform_action(miner_config[2]);
  status = 0;
  miner_config[2] = copied_config;
  miner_config[3] = data_length;
  return status;
}

//----- (0004E804) --------------------------------------------------------
int __fastcall update_miner_config_with_string(_DWORD *config_ptr, const char *config_string)
{
  size_t string_length; // r0

  if ( !config_string )
    return -1;
  string_length = strlen(config_string);
  return update_miner_configuration(config_ptr, config_string, string_length);
}

//----- (0004E838) --------------------------------------------------------
int __fastcall update_configuration_if_valid_utf8(_DWORD *config_handle, const void *utf8_data, size_t data_length)
{
  if ( utf8_data && check_valid_utf8_sequence((int)utf8_data, data_length) )
    return update_miner_configuration(config_handle, utf8_data, data_length);
  else
    return -1;
}

//----- (0004E87C) --------------------------------------------------------
int __fastcall parse_and_update_configuration(_DWORD *config_buffer, const char *config_string)
{
  size_t config_string_length; // r0

  if ( !config_string )
    return -1;
  config_string_length = strlen(config_string);
  return update_configuration_if_valid_utf8(config_buffer, config_string, config_string_length);
}

//----- (0004E8B0) --------------------------------------------------------
_DWORD *__fastcall sub_4E8B0(char *format, __gnuc_va_list arg)
{
  int v3; // r0
  size_t v4; // r4
  char *v5; // r0
  char *v6; // r7

  v3 = vsnprintf(0, 0, format, arg);
  v4 = v3;
  if ( !v3 )
    return process_utf8_input("", 0);
  v5 = (char *)check_and_process_result(v3 + 1);
  v6 = v5;
  if ( !v5 )
    return 0;
  vsnprintf(v5, v4 + 1, format, arg);
  if ( check_valid_utf8_sequence((int)v6, v4) )
    return process_input_data(v6, v4, 1);
  check_and_perform_action((int)v6);
  return 0;
}

//----- (0004E960) --------------------------------------------------------
_DWORD *process_formatted_input(char *input_string, ...)
{
  va_list args_list; // [sp+14h] [bp-Ch] BYREF

  va_start(args_list, input_string);
  return format_and_process_input(input_string, args_list);
}

//----- (0004E990) --------------------------------------------------------
int __fastcall init_asic_task(__int64 task_data)
{
  int task_ptr; // r0

  task_ptr = check_and_process_result(16);
  if ( task_ptr )
  {
    *(_QWORD *)(task_ptr + 8) = task_data;
    *(_DWORD *)task_ptr = 3;
    *(_DWORD *)(task_ptr + 4) = 1;
  }
  return task_ptr;
}

//----- (0004E9C4) --------------------------------------------------------
__int64 __fastcall get_hardware_status(int status_reg_address)
{
  if ( status_reg_address && *(_DWORD *)status_reg_address == 3 )
    return *(_QWORD *)(status_reg_address + 8);
  else
    return 0LL;
}

//----- (0004E9EC) --------------------------------------------------------
int __fastcall set_timestamp_if_valid(int data_pointer, __int64 timestamp)
{
  if ( !data_pointer || *(_DWORD *)data_pointer != 3 )
    return -1;
  *(_QWORD *)(data_pointer + 8) = timestamp;
  return 0;
}

//----- (0004EA14) --------------------------------------------------------
int process_double_value()
{
  double input_value; // d0
  int json_buffer; // r0

  if ( fabs(input_value) > 1.79769313e308 )
    return 0;
  json_buffer = check_and_process_result(16);
  if ( json_buffer )
  {
    *(double *)(json_buffer + 8) = input_value;
    *(_DWORD *)json_buffer = 4;
    *(_DWORD *)(json_buffer + 4) = 1;
  }
  return json_buffer;
}
// 4EA24: variable 'input_value' is possibly undefined

//----- (0004EA70) --------------------------------------------------------
void sub_4EA70()
{
  ;
}

//----- (0004EB48) --------------------------------------------------------
void *get_miner_hardware_info_pointer()
{
  return &unk_7F570;
}

//----- (0004EB54) --------------------------------------------------------
void *get_unk_7F578_address()
{
  return &unk_7F578;
}

//----- (0004EB60) --------------------------------------------------------
void *get_miner_config_pointer()
{
  return &unk_7F580;
}

//----- (0004EB6C) --------------------------------------------------------
_DWORD *__fastcall handle_task(_DWORD *task)
{
  _DWORD *task_pointer; // r4
  int task_data; // r0
  unsigned int num_subtasks; // r1
  unsigned int index; // r5
  _DWORD *current_subtask; // r3
  unsigned int *ref_count_pointer; // r2
  unsigned int current_reference_count; // r1
  unsigned int new_reference_count; // r1

  task_pointer = task;
  if ( task )
  {
    switch ( *task )
    {
      case 0:
        update_counters_and_check_status((int)(task + 2));
        return (_DWORD *)check_and_perform_action((int)task_pointer);
      case 1:
        num_subtasks = task[3];
        task_data = task[4];
        if ( num_subtasks )
        {
          for ( index = 0; index < num_subtasks; ++index )
          {
            current_subtask = *(_DWORD **)(task_data + 4 * index);
            if ( current_subtask )
            {
              ref_count_pointer = current_subtask + 1;
              if ( current_subtask[1] != -1 )
              {
                __dmb(11u);
                do
                {
                  current_reference_count = __ldrex(ref_count_pointer);
                  new_reference_count = current_reference_count - 1;
                }
                while ( __strex(new_reference_count, ref_count_pointer) );
                if ( !new_reference_count )
                  handle_task(current_subtask);
                task_data = task_pointer[4];
                num_subtasks = task_pointer[3];
              }
            }
          }
        }
        goto LABEL_4;
      case 2:
        task_data = task[2];
LABEL_4:
        check_and_perform_action(task_data);
        goto LABEL_5;
      case 3:
      case 4:
LABEL_5:
        task = (_DWORD *)check_and_perform_action((int)task_pointer);
        break;
      default:
        return task;
    }
  }
  return task;
}
// 4EB84: control flows out of bounds to 4EB88

//----- (0004EC38) --------------------------------------------------------
int __fastcall release_resources(_DWORD *resource_array)
{
  unsigned int resource_count; // r2
  unsigned int index; // r4
  _DWORD *resource; // r0
  unsigned int *ref_counter; // r3
  unsigned int current_count; // r2
  unsigned int new_count; // r2
  int return_code; // r0

  if ( !resource_array || *resource_array != 1 )
    return -1;
  resource_count = resource_array[3];
  if ( resource_count )
  {
    for ( index = 0; index < resource_count; ++index )
    {
      resource = *(_DWORD **)(resource_array[4] + 4 * index);
      if ( resource )
      {
        ref_counter = resource + 1;
        if ( resource[1] != -1 )
        {
          __dmb(11u);
          do
          {
            current_count = __ldrex(ref_counter);
            new_count = current_count - 1;
          }
          while ( __strex(new_count, ref_counter) );
          if ( !new_count )
            handle_task(resource);
          resource_count = resource_array[3];
        }
      }
    }
  }
  return_code = 0;
  resource_array[3] = 0;
  return return_code;
}

//----- (0004ECC8) --------------------------------------------------------
int __fastcall process_reference_count(_DWORD *check_ref, int ref_value, _DWORD *ref_counter)
{
  _BOOL4 invalid_condition; // r4
  unsigned int *counter_ptr; // r3
  unsigned int current_count; // r1
  unsigned int new_count; // r1

  if ( !check_ref || *check_ref )
    goto LABEL_8;
  if ( !ref_value )
    invalid_condition = 1;
  if ( ref_value )
    invalid_condition = ref_counter == 0;
  if ( invalid_condition )
  {
LABEL_8:
    if ( !ref_counter )
      return -1;
    if ( ref_counter[1] == -1 )
      return -1;
    counter_ptr = ref_counter + 1;
    __dmb(11u);
    do
    {
      current_count = __ldrex(counter_ptr);
      new_count = current_count - 1;
    }
    while ( __strex(new_count, counter_ptr) );
    if ( new_count )
    {
      return -1;
    }
    else
    {
      handle_task(ref_counter);
      return -1;
    }
  }
  else
  {
    update_reference_count(ref_value, (int)ref_counter);
    return 0;
  }
}
// 4ED4C: variable 'invalid_condition' is possibly undefined

//----- (0004ED60) --------------------------------------------------------
int __fastcall decrement_reference_and_remove_entry(_DWORD *entry_list, unsigned int entry_index)
{
  unsigned int current_entries_count; // r12
  unsigned int entry_offset; // r6
  _DWORD *entry_ptr; // r0
  int new_entries_count; // r3
  unsigned int *reference_counter_ptr; // r3
  unsigned int current_reference_count; // r2
  unsigned int new_reference_count; // r2

  if ( entry_list )
  {
    if ( *entry_list == 1 )
    {
      current_entries_count = entry_list[3];
      if ( current_entries_count > entry_index )
      {
        entry_offset = 4 * entry_index;
        entry_ptr = *(_DWORD **)(entry_list[4] + 4 * entry_index);
        if ( entry_ptr && entry_ptr[1] != -1 )
        {
          reference_counter_ptr = entry_ptr + 1;
          __dmb(11u);
          do
          {
            current_reference_count = __ldrex(reference_counter_ptr);
            new_reference_count = current_reference_count - 1;
          }
          while ( __strex(new_reference_count, reference_counter_ptr) );
          if ( !new_reference_count )
            handle_task(entry_ptr);
          current_entries_count = entry_list[3];
          new_entries_count = current_entries_count - 1;
          if ( current_entries_count - 1 <= entry_index )
            goto LABEL_7;
        }
        else
        {
          new_entries_count = current_entries_count - 1;
          if ( current_entries_count - 1 <= entry_index )
          {
LABEL_7:
            entry_list[3] = new_entries_count;
            return 0;
          }
        }
        memmove(
          (void *)(entry_list[4] + entry_offset),
          (const void *)(entry_list[4] + entry_offset + 4),
          4 * (~entry_index + current_entries_count));
        new_entries_count = entry_list[3] - 1;
        goto LABEL_7;
      }
    }
  }
  return -1;
}

//----- (0004EE2C) --------------------------------------------------------
int __fastcall add_task_if_possible(_DWORD *task_data, char *task_name, _DWORD *task_obj)
{
  bool is_invalid_args; // zf
  int task_add_result; // r0
  _BOOL4 is_existing_task; // r3
  unsigned int *task_ref_count_ptr; // r3
  unsigned int current_ref_count; // r2
  unsigned int new_ref_count; // r2
  unsigned int *v10; // r3
  unsigned int v11; // r2

  if ( !task_obj )
    return -1;
  is_invalid_args = task_data == 0;
  if ( task_data )
    is_invalid_args = task_name == 0;
  if ( !is_invalid_args )
  {
    is_existing_task = task_obj == task_data;
    if ( *task_data )
      is_existing_task = 1;
    if ( !is_existing_task )
    {
      task_add_result = add_task_with_name(task_data + 2, task_name, (int)task_obj);
      if ( !task_add_result )
        return task_add_result;
      if ( task_obj[1] != -1 )
      {
        task_ref_count_ptr = task_obj + 1;
        __dmb(11u);
        do
        {
          current_ref_count = __ldrex(task_ref_count_ptr);
          new_ref_count = current_ref_count - 1;
        }
        while ( __strex(new_ref_count, task_ref_count_ptr) );
        goto LABEL_18;
      }
      return -1;
    }
  }
  if ( task_obj[1] == -1 )
    return -1;
  v10 = task_obj + 1;
  __dmb(11u);
  do
  {
    v11 = __ldrex(v10);
    new_ref_count = v11 - 1;
  }
  while ( __strex(new_ref_count, v10) );
LABEL_18:
  if ( new_ref_count )
    return -1;
  handle_task(task_obj);
  return -1;
}

//----- (0004EEE8) --------------------------------------------------------
int __fastcall process_task_assignment(_DWORD *task_data_ptr, _DWORD *status_data_ptr)
{
  _BOOL4 is_invalid_state; // r3
  _DWORD *iterator; // r9
  int current_element; // r0
  unsigned int *execution_counter_ptr; // r3
  unsigned int execution_count; // r2
  int offset_result; // r0
  char *task_info; // r4
  _DWORD *status_register; // r8

  if ( !task_data_ptr )
    return -1;
  is_invalid_state = status_data_ptr == 0;
  if ( *task_data_ptr )
    is_invalid_state = 1;
  if ( is_invalid_state || *status_data_ptr )
    return -1;
  iterator = status_data_ptr + 2;
  for ( current_element = get_next_element((int)(status_data_ptr + 2));
        current_element;
        current_element = check_matching_values((int)iterator, (int)(task_info - 16)) )
  {
    offset_result = calculate_offset(current_element);
    task_info = (char *)offset_result;
    if ( !offset_result )
      break;
    status_register = (_DWORD *)get_status_register(offset_result - 16);
    if ( !status_register )
      break;
    if ( !initiate_task_if_ready(task_data_ptr, task_info) )
    {
      execution_counter_ptr = status_register + 1;
      if ( status_register[1] != -1 )
      {
        do
          execution_count = __ldrex(execution_counter_ptr);
        while ( __strex(execution_count + 1, execution_counter_ptr) );
        __dmb(11u);
      }
      add_task_if_possible(task_data_ptr, task_info, status_register);
    }
    if ( *status_data_ptr )
      break;
  }
  return 0;
}

//----- (0004EFD4) --------------------------------------------------------
int __fastcall process_task_if_valid(_DWORD *task_list, char *task_string, _DWORD *task_metadata)
{
  unsigned int task_string_length; // r0
  unsigned int *metadata_counter_ptr; // r3
  unsigned int current_count; // r2
  unsigned int new_count; // r2

  if ( task_string )
  {
    task_string_length = strlen(task_string);
    if ( check_valid_utf8_sequence((int)task_string, task_string_length) )
      return add_task_if_possible(task_list, task_string, task_metadata);
  }
  if ( !task_metadata )
    return -1;
  if ( task_metadata[1] == -1 )
    return -1;
  metadata_counter_ptr = task_metadata + 1;
  __dmb(11u);
  do
  {
    current_count = __ldrex(metadata_counter_ptr);
    new_count = current_count - 1;
  }
  while ( __strex(new_count, metadata_counter_ptr) );
  if ( new_count )
    return -1;
  handle_task(task_metadata);
  return -1;
}

//----- (0004F068) --------------------------------------------------------
int __fastcall sub_4F068(_DWORD *a1, _DWORD *a2)
{
  _BOOL4 v3; // r3
  _DWORD *v4; // r8
  int next_element; // r0
  unsigned int v8; // r1
  int v9; // r0
  char *v10; // r5
  _DWORD *status_register; // r0
  unsigned int *v12; // r3

  if ( !a1 )
    return -1;
  v3 = a2 == 0;
  if ( *a1 )
    v3 = 1;
  if ( v3 || *a2 )
    return -1;
  v4 = a2 + 2;
  next_element = get_next_element((int)(a2 + 2));
  if ( next_element )
  {
    while ( 1 )
    {
      v9 = calculate_offset(next_element);
      v10 = (char *)v9;
      if ( !v9 )
        break;
      status_register = (_DWORD *)get_status_register(v9 - 16);
      v12 = status_register + 1;
      if ( !status_register )
        return 0;
      if ( status_register[1] != -1 )
      {
        do
          v8 = __ldrex(v12);
        while ( __strex(v8 + 1, v12) );
        __dmb(11u);
      }
      if ( add_task_if_possible(a1, v10, status_register) )
        return -1;
      if ( !*a2 )
      {
        next_element = check_matching_values((int)v4, (int)(v10 - 16));
        if ( next_element )
          continue;
      }
      return 0;
    }
  }
  return 0;
}

//----- (0004F148) --------------------------------------------------------
int __fastcall process_tasks(_DWORD *task_list_head, _DWORD *task_queue)
{
  _BOOL4 should_not_process; // r3
  _DWORD *current_task_ptr; // r9
  int next_task; // r0
  unsigned int *task_counter_ptr; // r3
  unsigned int task_count; // r2
  int offset_result; // r0
  char *current_task_data; // r4
  _DWORD *status_register; // r6

  if ( !task_list_head )
    return -1;
  should_not_process = task_queue == 0;
  if ( *task_list_head )
    should_not_process = 1;
  if ( should_not_process || *task_queue )
    return -1;
  current_task_ptr = task_queue + 2;
  for ( next_task = get_next_element((int)(task_queue + 2));
        next_task;
        next_task = check_matching_values((int)current_task_ptr, (int)(current_task_data - 16)) )
  {
    offset_result = calculate_offset(next_task);
    current_task_data = (char *)offset_result;
    if ( !offset_result )
      break;
    status_register = (_DWORD *)get_status_register(offset_result - 16);
    if ( !status_register )
      break;
    if ( initiate_task_if_ready(task_list_head, current_task_data) )
    {
      task_counter_ptr = status_register + 1;
      if ( status_register[1] != -1 )
      {
        do
          task_count = __ldrex(task_counter_ptr);
        while ( __strex(task_count + 1, task_counter_ptr) );
        __dmb(11u);
      }
      add_task_if_possible(task_list_head, current_task_data, status_register);
    }
    if ( *task_queue )
      break;
  }
  return 0;
}

//----- (0004F238) --------------------------------------------------------
int __fastcall update_buffer_reference(_DWORD *source_buffer, unsigned int insert_index, _DWORD *new_item)
{
  int sanity_check_result; // r2
  int status; // r0
  unsigned int *ref_count_ptr; // r3
  unsigned int current_ref_count; // r2
  unsigned int updated_ref_count; // r2
  char *extended_buffer; // r8
  char *destination; // r0
  unsigned int offset; // r7
  int new_buffer_size; // r3
  unsigned int *ref_count_ptr_second_check; // r3
  unsigned int current_ref_count_second_check; // r2

  if ( !new_item )
    return -1;
  if ( !source_buffer )
    goto LABEL_6;
  sanity_check_result = new_item == source_buffer;
  if ( *source_buffer != 1 )
    sanity_check_result |= 1u;
  if ( sanity_check_result || source_buffer[3] < insert_index )
  {
LABEL_6:
    if ( new_item[1] == -1 )
      return -1;
    ref_count_ptr = new_item + 1;
    __dmb(11u);
    do
    {
      current_ref_count = __ldrex(ref_count_ptr);
      updated_ref_count = current_ref_count - 1;
    }
    while ( __strex(updated_ref_count, ref_count_ptr) );
LABEL_10:
    if ( !updated_ref_count )
    {
      handle_task(new_item);
      return -1;
    }
    return -1;
  }
  extended_buffer = (char *)extend_buffer_if_needed(source_buffer, 1, 0);
  if ( !extended_buffer )
  {
    if ( new_item[1] == -1 )
      return -1;
    ref_count_ptr_second_check = new_item + 1;
    __dmb(11u);
    do
    {
      current_ref_count_second_check = __ldrex(ref_count_ptr_second_check);
      updated_ref_count = current_ref_count_second_check - 1;
    }
    while ( __strex(updated_ref_count, ref_count_ptr_second_check) );
    goto LABEL_10;
  }
  destination = (char *)source_buffer[4];
  offset = 4 * (insert_index + 1);
  if ( destination == extended_buffer )
  {
    memmove(&destination[offset], &extended_buffer[offset - 4], 4 * (source_buffer[3] - insert_index));
  }
  else
  {
    memcpy(destination, extended_buffer, offset - 4);
    memcpy((void *)(source_buffer[4] + offset), &extended_buffer[offset - 4], 4 * (source_buffer[3] - insert_index));
    check_and_perform_action((int)extended_buffer);
  }
  status = 0;
  new_buffer_size = source_buffer[3] + 1;
  *(_DWORD *)(source_buffer[4] + offset - 4) = new_item;
  source_buffer[3] = new_buffer_size;
  return status;
}

//----- (0004F494) --------------------------------------------------------
int __fastcall add_to_buffer(_DWORD *buffer, _DWORD *value)
{
  _BOOL4 no_buffer_updates; // r5
  int return_code; // r0
  unsigned int *ref_counter; // r3
  unsigned int current_count; // r2
  unsigned int new_count; // r2
  int buffer_index; // r3
  unsigned int *value_ref_counter; // r3
  unsigned int value_current_count; // r2

  if ( !value )
    return -1;
  if ( !buffer )
    goto LABEL_6;
  no_buffer_updates = value == buffer;
  if ( *buffer != 1 )
    no_buffer_updates = 1;
  if ( !no_buffer_updates )
  {
    if ( extend_buffer_if_needed(buffer, 1, 1) )
    {
      buffer_index = buffer[3];
      return_code = 0;
      *(_DWORD *)(buffer[4] + 4 * buffer_index) = value;
      buffer[3] = buffer_index + 1;
      return return_code;
    }
    if ( value[1] == -1 )
      return -1;
    value_ref_counter = value + 1;
    __dmb(11u);
    do
    {
      value_current_count = __ldrex(value_ref_counter);
      new_count = value_current_count - 1;
    }
    while ( __strex(new_count, value_ref_counter) );
  }
  else
  {
LABEL_6:
    if ( value[1] == -1 )
      return -1;
    ref_counter = value + 1;
    __dmb(11u);
    do
    {
      current_count = __ldrex(ref_counter);
      new_count = current_count - 1;
    }
    while ( __strex(new_count, ref_counter) );
  }
  if ( new_count )
    return -1;
  handle_task(value);
  return -1;
}

//----- (0004F570) --------------------------------------------------------
bool __fastcall compare_pointers_and_structures(int *ptr1, int *ptr2)
{
  bool are_ptrs_null; // zf

  are_ptrs_null = ptr2 == 0;
  if ( ptr2 )
    are_ptrs_null = ptr1 == 0;
  return !are_ptrs_null && compare_structures(ptr1, ptr2);
}

//----- (0004F588) --------------------------------------------------------
_DWORD *__fastcall handle_miner_commands(int command_data)
{
  _DWORD *miner_status_and_init; // r7
  int next_element; // r0
  unsigned int increment_value; // r1
  int offset_result; // r0
  char *offset_ptr; // r5
  _DWORD *status_register; // r0
  unsigned int *status_reg_counter; // r3
  unsigned int elements_count; // r3
  unsigned int i; // r5
  _DWORD *current_element_ptr; // r1
  unsigned int *element_counter; // r2
  unsigned int v13; // r3

  if ( command_data )
  {
    switch ( *(_DWORD *)command_data )
    {
      case 0:
        miner_status_and_init = get_miner_status_and_init();
        if ( !miner_status_and_init )
          return 0;
        if ( !*(_DWORD *)command_data )
        {
          for ( next_element = get_next_element(command_data + 8);
                next_element;
                next_element = check_matching_values(command_data + 8, (int)(offset_ptr - 16)) )
          {
            offset_result = calculate_offset(next_element);
            offset_ptr = (char *)offset_result;
            if ( !offset_result )
              break;
            status_register = (_DWORD *)get_status_register(offset_result - 16);
            status_reg_counter = status_register + 1;
            if ( !status_register )
              break;
            if ( status_register[1] != -1 )
            {
              do
                increment_value = __ldrex(status_reg_counter);
              while ( __strex(increment_value + 1, status_reg_counter) );
              __dmb(11u);
            }
            add_task_if_possible(miner_status_and_init, offset_ptr, status_register);
            if ( *(_DWORD *)command_data )
              break;
          }
        }
        return miner_status_and_init;
      case 1:
        miner_status_and_init = get_asic_status();
        if ( !miner_status_and_init )
          return 0;
        if ( *(_DWORD *)command_data == 1 )
        {
          elements_count = *(_DWORD *)(command_data + 12);
          if ( elements_count )
          {
            for ( i = 0; i < elements_count; ++i )
            {
              current_element_ptr = 0;
              if ( elements_count > i )
              {
                current_element_ptr = *(_DWORD **)(*(_DWORD *)(command_data + 16) + 4 * i);
                element_counter = current_element_ptr + 1;
                if ( current_element_ptr )
                {
                  if ( current_element_ptr[1] != -1 )
                  {
                    do
                      v13 = __ldrex(element_counter);
                    while ( __strex(v13 + 1, element_counter) );
                    __dmb(11u);
                  }
                }
              }
              add_to_buffer(miner_status_and_init, current_element_ptr);
              if ( *(_DWORD *)command_data != 1 )
                break;
              elements_count = *(_DWORD *)(command_data + 12);
            }
          }
        }
        return miner_status_and_init;
      case 2:
        return process_input_data(*(_BYTE **)(command_data + 8), *(_DWORD *)(command_data + 12), 0);
      case 3:
        return (_DWORD *)update_status_data(command_data);
      case 4:
        return (_DWORD *)process_double_value();
      case 5:
      case 6:
      case 7:
        return (_DWORD *)command_data;
      default:
        return 0;
    }
  }
  return 0;
}
// 4F5A0: control flows out of bounds to 4F5A4

//----- (0004F744) --------------------------------------------------------
_DWORD *__fastcall handle_miner_command(int command_ptr)
{
  _DWORD *miner_status_and_init; // r6
  int next_element; // r5
  char *offset_ptr; // r7
  int status_register; // r0
  _DWORD *child_status_ptr; // r0
  unsigned int element_count; // r3
  unsigned int i; // r5
  int element_ptr; // r0
  _DWORD *buffer_status_ptr; // r0

  if ( command_ptr )
  {
    switch ( *(_DWORD *)command_ptr )
    {
      case 0:
        miner_status_and_init = get_miner_status_and_init();
        if ( !miner_status_and_init )
          return 0;
        if ( !*(_DWORD *)command_ptr )
        {
          for ( next_element = get_next_element(command_ptr + 8);
                next_element;
                next_element = check_matching_values(command_ptr + 8, next_element) )
          {
            offset_ptr = (char *)calculate_offset(next_element);
            status_register = get_status_register(next_element);
            child_status_ptr = handle_miner_command(status_register);
            add_task_if_possible(miner_status_and_init, offset_ptr, child_status_ptr);
            if ( *(_DWORD *)command_ptr )
              break;
          }
        }
        return miner_status_and_init;
      case 1:
        miner_status_and_init = get_asic_status();
        if ( !miner_status_and_init )
          return 0;
        if ( *(_DWORD *)command_ptr == 1 )
        {
          element_count = *(_DWORD *)(command_ptr + 12);
          if ( element_count )
          {
            for ( i = 0; i < element_count; ++i )
            {
              element_ptr = 0;
              if ( element_count > i )
                element_ptr = *(_DWORD *)(*(_DWORD *)(command_ptr + 16) + 4 * i);
              buffer_status_ptr = handle_miner_command(element_ptr);
              add_to_buffer(miner_status_and_init, buffer_status_ptr);
              if ( *(_DWORD *)command_ptr != 1 )
                break;
              element_count = *(_DWORD *)(command_ptr + 12);
            }
          }
        }
        return miner_status_and_init;
      case 2:
        return process_input_data(*(_BYTE **)(command_ptr + 8), *(_DWORD *)(command_ptr + 12), 0);
      case 3:
        return (_DWORD *)update_status_data(command_ptr);
      case 4:
        return (_DWORD *)process_double_value();
      case 5:
      case 6:
      case 7:
        return (_DWORD *)command_ptr;
      default:
        return 0;
    }
  }
  return 0;
}
// 4F75C: control flows out of bounds to 4F760

//----- (0004F8A8) --------------------------------------------------------
char *__fastcall copy_error_message(int buffer_address, char *error_message)
{
  size_t message_length; // r0

  message_length = strlen(error_message);
  if ( message_length <= 79 )
    return strncpy((char *)(buffer_address + 12), error_message, message_length + 1);
  qmemcpy((void *)(buffer_address + 12), "...", 3);
  return strncpy((char *)(buffer_address + 15), &error_message[message_length - 76], 77u);
}

//----- (0004F90C) --------------------------------------------------------
char *__fastcall reset_miner_status(char *status_buffer, char *miner_ip)
{
  if ( status_buffer )
  {
    status_buffer[92] = 0;
    *((_DWORD *)status_buffer + 2) = 0;
    *(_DWORD *)status_buffer = -1;
    *((_DWORD *)status_buffer + 1) = -1;
    if ( miner_ip )
      return copy_error_message((int)status_buffer, miner_ip);
    else
      status_buffer[12] = 0;
  }
  return status_buffer;
}

//----- (0004F94C) --------------------------------------------------------
char *__fastcall copy_string_if_not_null(char *destination, char *source)
{
  bool is_null; // zf

  is_null = source == 0;
  if ( source )
    is_null = destination == 0;
  if ( !is_null )
    return copy_error_message((int)destination, source);
  return destination;
}

//----- (0004F95C) --------------------------------------------------------
int copy_formatted_message_to_buffer(
        int buffer_pointer,
        int message_code,
        int value_1,
        int value_2,
        int end_byte,
        char *format_string,
        ...)
{
  int buffer_base_pointer; // r4
  va_list var_args; // [sp+20h] [bp+8h] BYREF

  va_start(var_args, format_string);
  buffer_base_pointer = buffer_pointer;
  if ( buffer_pointer )
  {
    if ( !*(_BYTE *)(buffer_pointer + 92) )
    {
      *(_DWORD *)buffer_pointer = message_code;
      *(_DWORD *)(buffer_pointer + 4) = value_1;
      *(_DWORD *)(buffer_pointer + 8) = value_2;
      buffer_pointer = vsnprintf((char *)(buffer_pointer + 92), 159u, format_string, var_args);
      *(_BYTE *)(buffer_base_pointer + 250) = 0;
      *(_BYTE *)(buffer_base_pointer + 251) = end_byte;
    }
  }
  return buffer_pointer;
}

//----- (0004F9C0) --------------------------------------------------------
int __fastcall format_miner_log_entry(
        int log_entry_ptr,
        int log_level,
        int timestamp,
        int some_identifier,
        int flag,
        char *format_string,
        __gnuc_va_list var_args)
{
  int entry_buffer; // r4

  entry_buffer = log_entry_ptr;
  if ( log_entry_ptr )
  {
    if ( !*(_BYTE *)(log_entry_ptr + 92) )
    {
      *(_DWORD *)log_entry_ptr = log_level;
      *(_DWORD *)(log_entry_ptr + 4) = timestamp;
      *(_DWORD *)(log_entry_ptr + 8) = some_identifier;
      log_entry_ptr = vsnprintf((char *)(log_entry_ptr + 92), 159u, format_string, var_args);
      *(_BYTE *)(entry_buffer + 250) = 0;
      *(_BYTE *)(entry_buffer + 251) = flag;
    }
  }
  return log_entry_ptr;
}

//----- (0004FA10) --------------------------------------------------------
int __fastcall initialize_asic_mining(
        unsigned int chip_id,
        int reset_flag,
        unsigned int register_address,
        unsigned int register_value,
        int mask)
{
  int initialization_status; // r10
  unsigned int current_chip_id; // r1
  unsigned int current_address; // r2
  int config_type; // r0
  char setup_buffer[44]; // [sp+Ch] [bp-2Ch] BYREF

  initialization_status = prepare_message_buffer(reset_flag, register_address, register_value, mask, setup_buffer);
  if ( initialization_status )
    return -1;
  copy_data_to_state_buffer(chip_id, (int)setup_buffer, 9u);
  if ( reset_flag == 1 )
  {
    current_chip_id = chip_id;
    current_address = 0;
    config_type = 0;
  }
  else
  {
    current_address = register_address;
    current_chip_id = chip_id;
    config_type = 1;
  }
  setRegisterValue(config_type, current_chip_id, current_address, register_value, mask);
  return initialization_status;
}

//----- (0004FA9C) --------------------------------------------------------
int __fastcall configure_miner_pll(
        unsigned int frequency,
        int voltage,
        unsigned int chip_id,
        unsigned int chain_index,
        char pll_ratio,
        char pll_bypass,
        char pll_r,
        __int16 pll_od)
{
  if ( chain_index > 3 )
    return -1;
  else
    return initialize_asic_mining(
             frequency,
             voltage,
             chip_id,
             (unsigned __int8)aDh[chain_index],
             pll_bypass & 7 | 0x40000000 | (unsigned __int8)(16 * (pll_ratio & 7)) | ((pll_r & 0x3F) << 8) | ((pll_od & 0xFFF) << 16));
}

//----- (0004FAEC) --------------------------------------------------------
int __fastcall initialize_miner_and_delay(unsigned int miner_version, int hash_rate, unsigned int time_stamp)
{
  initialize_asic_mining(miner_version, hash_rate, time_stamp, 60u, -2147449569);
  usleep(10000u);
  return initialize_asic_mining(miner_version, hash_rate, time_stamp, 60u, -2147482112);
}

//----- (0004FB64) --------------------------------------------------------
int __fastcall initialize_asic_with_settings(
        unsigned int chip_address,
        int hash_start_address,
        unsigned int hash_length,
        char configuration_bits)
{
  int asic_config_flag; // r4

  asic_config_flag = configuration_bits & 3 | 0x80008104;
  initialize_asic_mining(chip_address, hash_start_address, hash_length, 60u, asic_config_flag);
  usleep(10000u);
  return initialize_asic_mining(
           chip_address,
           hash_start_address,
           hash_length,
           60u,
           asic_config_flag & 0xFFFF70FF | 0x200);
}

//----- (0004FBDC) --------------------------------------------------------
int __fastcall init_asic_miner_with_config(
        unsigned int frequency,
        int chip_id,
        unsigned int voltage,
        unsigned __int8 settings_flag,
        unsigned __int8 timing)
{
  return initialize_asic_mining(
           frequency,
           chip_id,
           voltage,
           60u,
           (timing << 16) & 0x7FFF7B55 | 0x84AA | (settings_flag << 31));
}

//----- (0004FC14) --------------------------------------------------------
int __fastcall initialize_asic(unsigned int miner_id, int use_register_0, unsigned int chip_id)
{
  int cache_value[5]; // [sp+Ch] [bp-14h] BYREF

  initialize_asic_mining(miner_id, use_register_0, chip_id, 188u, 320);
  usleep(10000u);
  if ( use_register_0 )
    GetRegisterCacheValue(0, miner_id, 0, 176u, cache_value);
  else
    GetRegisterCacheValue(1, miner_id, chip_id, 176u, cache_value);
  cache_value[0] = 545009931;
  initialize_asic_mining(miner_id, use_register_0, chip_id, 176u, 545009931);
  usleep(10000u);
  return 0;
}

//----- (0004FCBC) --------------------------------------------------------
int __fastcall configure_chip_mining(
        unsigned int chip_id,
        int is_secondary,
        unsigned int hash_board_id,
        char config_value)
{
  int mining_config_values[7]; // [sp+Ch] [bp-1Ch] BYREF

  initialize_asic_mining(chip_id, is_secondary, hash_board_id, 188u, 504);
  usleep(10000u);
  if ( is_secondary )
    GetRegisterCacheValue(0, chip_id, 0, 176u, mining_config_values);
  else
    GetRegisterCacheValue(1, chip_id, hash_board_id, 176u, mining_config_values);
  HIBYTE(mining_config_values[0]) = HIBYTE(mining_config_values[0]) & 0x13 | 0x20;
  LOBYTE(mining_config_values[0]) = mining_config_values[0] & 0xB4 | 0x43;
  BYTE2(mining_config_values[0]) = BYTE2(mining_config_values[0]) & 0x83 | 0x78;
  BYTE1(mining_config_values[0]) = BYTE1(mining_config_values[0]) & 0xC0 | 0x31;
  initialize_asic_mining(chip_id, is_secondary, hash_board_id, 176u, mining_config_values[0]);
  usleep(10000u);
  initialize_asic_mining(chip_id, is_secondary, hash_board_id, 188u, config_value & 7 | 0x1F8);
  usleep(10000u);
  initialize_asic_mining(chip_id, is_secondary, hash_board_id, 176u, mining_config_values[0]);
  usleep(10000u);
  return 0;
}

//----- (0004FDF0) --------------------------------------------------------
int __fastcall initialize_miner_config(
        unsigned int frequency,
        int chip_id,
        unsigned int chain_id,
        char fan_speed,
        char voltage,
        char mode)
{
  unsigned __int8 config_bits; // r12

  if ( mode )
    config_bits = (16 * (fan_speed & 3)) & 0x3F | ((voltage & 3) << 6) | 1;
  else
    config_bits = (16 * (fan_speed & 3)) & 0x3E | ((voltage & 3) << 6);
  return initialize_asic_mining(frequency, chip_id, chain_id, 60u, config_bits | 0x80008000);
}

//----- (0004FE30) --------------------------------------------------------
int __fastcall init_mining_with_options(unsigned int miner_id, int frequency, unsigned int voltage, int options)
{
  if ( options )
    LOBYTE(options) = 64;
  return initialize_asic_mining(miner_id, frequency, voltage, 60u, (unsigned __int8)options | 0x80008D00);
}

//----- (0004FE70) --------------------------------------------------------
int __fastcall calculate_result(int input_value)
{
  _BYTE intermediate_buffer[16]; // [sp+0h] [bp-10h] BYREF

  if ( initialize_status_data(intermediate_buffer) )
    return -1;
  else
    return copy_data_to_state_buffer(input_value, (int)intermediate_buffer, 5u);
}

//----- (0004FEAC) --------------------------------------------------------
int __fastcall process_command_response(int socket_fd, char command)
{
  _BYTE response_buffer[16]; // [sp+0h] [bp-10h] BYREF

  if ( prepare_command_packet(command, response_buffer) )
    return -1;
  else
    return copy_data_to_state_buffer(socket_fd, (int)response_buffer, 5u);
}

//----- (0004FEF0) --------------------------------------------------------
int __fastcall hash_board_command_send(
        int command_destination,
        int command_type,
        char command_subtype,
        char command_parameter)
{
  _BYTE command_buffer[16]; // [sp+0h] [bp-10h] BYREF

  if ( initialize_header(command_type, command_subtype, command_parameter, command_buffer) )
    return -1;
  else
    return copy_data_to_state_buffer(command_destination, (int)command_buffer, 5u);
}

//----- (0004FF3C) --------------------------------------------------------
int __fastcall send_hash_board_init_command(int hash_board_id)
{
  return hash_board_command_send(hash_board_id, 1, 0, 0);
}

//----- (0004FF50) --------------------------------------------------------
int __fastcall process_commands_in_interval(int command_source, unsigned int command_interval)
{
  char interval_step; // r8
  unsigned int total_intervals; // r6
  int current_interval; // r4
  char current_step; // r5

  interval_step = command_interval;
  total_intervals = calculate_bit_difficulty(256u, command_interval);
  if ( total_intervals )
  {
    current_interval = 0;
    current_step = 0;
    do
    {
      process_command_response(command_source, current_step);
      ++current_interval;
      usleep(10000u);
      current_step += interval_step;
    }
    while ( current_interval != total_intervals );
  }
  return 0;
}

//----- (0004FFA0) --------------------------------------------------------
int __fastcall process_command_loop(int command_id, char increment_value, int loop_count)
{
  int current_iteration; // r4
  char incremented_value; // r5

  if ( loop_count )
  {
    current_iteration = 0;
    incremented_value = 0;
    do
    {
      process_command_response(command_id, incremented_value);
      ++current_iteration;
      usleep(10000u);
      incremented_value += increment_value;
    }
    while ( loop_count != current_iteration );
  }
  return 0;
}

//----- (0004FFE8) --------------------------------------------------------
int __fastcall configure_voltage_and_timing(unsigned int chip_id, unsigned int frequency)
{
  bool is_overclock_range; // cc
  unsigned int frequency_times_eight; // r1
  unsigned __int8 voltage_adjust_increment; // r7
  unsigned int voltage_decrement; // r6
  int regval_pll_config; // [sp+Ch] [bp-24h] BYREF
  int regval_hashing_config; // [sp+10h] [bp-20h] BYREF
  int regval_clock_gating; // [sp+14h] [bp-1Ch] BYREF

  is_overclock_range = frequency > (unsigned int)&unk_2DC6C0;
  frequency_times_eight = 8 * frequency;
  if ( is_overclock_range )
  {
    voltage_adjust_increment = calculate_bit_difficulty(100000000u, frequency_times_eight) - 1;
    GetRegisterCacheValue(0, chip_id, 0, 104u, &regval_hashing_config);
    GetRegisterCacheValue(0, chip_id, 0, 40u, &regval_clock_gating);
    HIBYTE(regval_hashing_config) = HIBYTE(regval_hashing_config) & 0x9F | 0x40;
    LOBYTE(regval_hashing_config) = regval_hashing_config & 0x88 | 0x11;
    BYTE1(regval_hashing_config) = BYTE1(regval_hashing_config) & 0xC0 | 1;
    HIWORD(regval_hashing_config) = HIWORD(regval_hashing_config) & 0xF000 | 0x70;
    initialize_asic_mining(chip_id, 1, 0, 104u, regval_hashing_config);
    usleep(10000u);
    initialize_asic_mining(chip_id, 1, 0, 104u, regval_hashing_config);
    usleep(10000u);
    BYTE2(regval_clock_gating) = 3;
    LOBYTE(regval_clock_gating) = 15;
    HIBYTE(regval_clock_gating) = HIBYTE(regval_clock_gating) & 0x30 | 6;
    BYTE1(regval_clock_gating) = ~((unsigned int)~(BYTE1(regval_clock_gating) << 25) >> 25) & 0x8F;
    initialize_asic_mining(chip_id, 1, 0, 40u, regval_clock_gating);
    usleep(10000u);
    GetRegisterCacheValue(0, chip_id, 0, 24u, &regval_pll_config);
    HIBYTE(regval_pll_config) = HIBYTE(regval_pll_config) & 0xF0 | (voltage_adjust_increment >> 5) & 0xF;
    BYTE1(regval_pll_config) = BYTE1(regval_pll_config) & 0xE0 | voltage_adjust_increment & 0x1F;
    BYTE2(regval_pll_config) |= 1u;
  }
  else
  {
    voltage_decrement = (unsigned __int8)(calculate_bit_difficulty(25000000u, frequency_times_eight) - 1);
    GetRegisterCacheValue(0, chip_id, 0, 24u, &regval_pll_config);
    HIBYTE(regval_pll_config) = HIBYTE(regval_pll_config) & 0xF0 | (voltage_decrement >> 5) & 0xF;
    BYTE1(regval_pll_config) = BYTE1(regval_pll_config) & 0xE0 | voltage_decrement & 0x1F;
    BYTE2(regval_pll_config) &= ~1u;
  }
  initialize_asic_mining(chip_id, 1, 0, 24u, regval_pll_config);
  usleep(50000u);
  update_register_with_masked_value(chip_id, frequency);
  return 0;
}

//----- (0005021C) --------------------------------------------------------
int __fastcall configure_asic_for_mining(unsigned int chip_id, unsigned int frequency_code)
{
  return initialize_asic_mining(
           chip_id,
           1,
           0,
           20u,
           (unsigned __int8)aDh[(unsigned __int8)frequency_code + 4] | (unsigned __int16)((unsigned __int8)aDh[BYTE1(frequency_code) + 4] << 8) | ((unsigned __int8)aDh[BYTE2(frequency_code) + 4] << 16) & 0xFFFFFF | ((unsigned __int8)aDh[HIBYTE(frequency_code) + 4] << 24));
}

//----- (00050288) --------------------------------------------------------
int __fastcall initialize_miner_with_parameters(
        unsigned int chip_address,
        int flag_enable,
        unsigned __int16 frequency_value)
{
  int config_bits; // r3

  if ( flag_enable )
    config_bits = -2147483648;
  else
    config_bits = 0;
  if ( !flag_enable )
    config_bits = config_bits & 0x7FFFFFFF | ((unsigned __int8)config_bits << 31);
  return initialize_asic_mining(chip_address, 1, 0, 12u, config_bits & 0xFFFF0000 | frequency_value);
}

//----- (000502C0) --------------------------------------------------------
int __fastcall CalculateFrequencyDividers(int dividerConfigPtr, _BYTE *updateFlagPtr, float *calculatedFreqPtr)
{
  float targetFreq; // s0
  int loopCounter; // r12
  int fbdivInteger; // r4
  int isUpdated; // r5
  int postdiv2; // r8
  int refdiv; // r2
  int fbdiv; // r9
  int postdiv1; // r11
  float minDiff; // s11
  int divLoopCounter; // r1
  float refdivFloat; // s13
  int fbdivTemp; // r0
  int postdiv1Temp; // lr
  int productTemp; // r3
  float tempFreq; // s7
  int intermediateResult; // s14
  float calculatedFreq; // s15
  float adjustedCalculatedFreq; // s15
  float comparisonFreq; // s16
  int result; // r0

  loopCounter = 2;
  fbdivInteger = 0;
  isUpdated = 0;
  postdiv2 = 0;
  refdiv = 2;
  fbdiv = 0;
  postdiv1 = 0;
  minDiff = 10.0;
  while ( 1 )
  {
    divLoopCounter = 1;
    refdivFloat = (float)refdiv;
    do
    {
      fbdivTemp = divLoopCounter * divLoopCounter;
      postdiv1Temp = (unsigned __int8)divLoopCounter;
      productTemp = divLoopCounter;
      tempFreq = (float)divLoopCounter * targetFreq;
      do
      {
        intermediateResult = (int)((float)((float)((float)((float)productTemp * tempFreq) * refdivFloat) / 25.0) + 0.5);
        if ( (unsigned int)(intermediateResult - 16) <= 234 )
        {
          calculatedFreq = (float)intermediateResult * (float)(25.0 / (float)refdiv);
          if ( (refdiv != 1 || calculatedFreq <= 3125.0) && calculatedFreq <= 3200.0 && calculatedFreq >= 2000.0 )
          {
            adjustedCalculatedFreq = fabsf(targetFreq - (float)(calculatedFreq / (float)fbdivTemp));
            if ( adjustedCalculatedFreq < minDiff )
            {
              postdiv2 = (unsigned __int8)divLoopCounter;
              fbdiv = postdiv1Temp;
              minDiff = adjustedCalculatedFreq;
              postdiv1 = refdiv;
              fbdivInteger = (int)((float)((float)((float)((float)productTemp * tempFreq) * refdivFloat) / 25.0) + 0.5);
              isUpdated = 1;
            }
          }
        }
        ++productTemp;
        fbdivTemp += divLoopCounter;
        postdiv1Temp = (unsigned __int8)productTemp;
      }
      while ( (unsigned __int8)productTemp != 8 );
      ++divLoopCounter;
    }
    while ( divLoopCounter != 8 );
    refdiv = 1;
    if ( loopCounter == 1 )
      break;
    loopCounter = 1;
  }
  if ( fbdivInteger )
  {
    comparisonFreq = (float)((float)(25.0 / (float)postdiv1) * (float)fbdivInteger)
                   / (float)(isUpdated * (__int16)fbdiv * (__int16)postdiv2);
    if ( calculatedFreqPtr )
      *calculatedFreqPtr = comparisonFreq;
    printf(
      "final refdiv: %d, fbdiv: %d, postdiv1: %d, postdiv2: %d, usr divider: %d, min diff value: %f\n",
      postdiv1,
      fbdivInteger,
      fbdiv,
      postdiv2,
      isUpdated,
      minDiff);
    printf("Want freq: %f, Real freq: %f\n", targetFreq, comparisonFreq);
    result = 0;
    *(_BYTE *)dividerConfigPtr = fbdiv;
    *(_BYTE *)(dividerConfigPtr + 1) = postdiv2;
    *(_BYTE *)(dividerConfigPtr + 2) = postdiv1;
    *(_WORD *)(dividerConfigPtr + 4) = fbdivInteger;
    *updateFlagPtr = isUpdated;
    updateFlagPtr[1] = isUpdated;
    updateFlagPtr[2] = isUpdated;
    updateFlagPtr[3] = isUpdated;
  }
  else
  {
    puts("find div fail, use default value");
    return -1;
  }
  return result;
}
// 5033C: variable 'targetFreq' is possibly undefined

//----- (000504E8) --------------------------------------------------------
int __fastcall set_pll_configuration(
        unsigned int pll_index,
        int target_freq,
        unsigned int freq_margin,
        unsigned int freq_bias,
        float voltage)
{
  char dividers_buffer[4]; // [sp+14h] [bp-24h] BYREF
  char dividers_parameters[4]; // [sp+18h] [bp-20h] BYREF
  __int16 feedback_div; // [sp+1Ch] [bp-1Ch]

  if ( CalculateFrequencyDividers((int)dividers_parameters, dividers_buffer, 0) )
    return -1;
  else
    return configure_miner_pll(
             pll_index,
             target_freq,
             freq_margin,
             freq_bias,
             dividers_parameters[0],
             dividers_parameters[1],
             dividers_parameters[2],
             feedback_div);
}
// 504E8: using guessed type char var_24[4];

//----- (00050560) --------------------------------------------------------
int __fastcall delegate_control_command(unsigned int control_id, unsigned int command, int parameter, __int16 checksum)
{
  return configure_miner_pll(control_id, 1, 0, command, parameter, SBYTE1(parameter), SBYTE2(parameter), checksum);
}

//----- (000505A4) --------------------------------------------------------
int __fastcall submit_mining_share(
        unsigned int job_id,
        unsigned int nonce,
        unsigned int ntime,
        int version_rolls,
        __int16 network_difficulty)
{
  return configure_miner_pll(
           job_id,
           0,
           nonce,
           ntime,
           version_rolls,
           SBYTE1(version_rolls),
           SBYTE2(version_rolls),
           network_difficulty);
}

//----- (000505F4) --------------------------------------------------------
int __fastcall initialize_voltage_regulator(
        unsigned int chain_index,
        unsigned int asic_index,
        unsigned int voltage_domain_index,
        char voltage_setting,
        char additional_settings)
{
  unsigned int voltage_register_address; // r8
  int register_values[7]; // [sp+Ch] [bp-1Ch] BYREF

  if ( voltage_domain_index > 3 )
    return -1;
  voltage_register_address = (unsigned __int8)aDh[voltage_domain_index];
  GetRegisterCacheValue(1, chain_index, asic_index, voltage_register_address, register_values);
  LOBYTE(register_values[0]) = register_values[0] & 0x88 | (16 * (voltage_setting & 7)) | additional_settings & 7;
  return initialize_asic_mining(chain_index, 0, asic_index, voltage_register_address, register_values[0]);
}
// 505F4: using guessed type int var_1C[7];

//----- (000506F8) --------------------------------------------------------
int __fastcall set_asic_mining_frequency(
        unsigned int asic_chain_index,
        unsigned int asic_chip_index,
        unsigned int frequency_band,
        __int16 frequency_value)
{
  char frequency_high_nibble; // r6
  char frequency_low_nibble; // r7
  unsigned int command_match; // r8
  int frequency_register_value; // [sp+14h] [bp-1Ch] BYREF

  frequency_high_nibble = HIBYTE(frequency_value);
  if ( frequency_band > 3 )
    return -1;
  frequency_low_nibble = frequency_value;
  command_match = (unsigned __int8)aDh[frequency_band + 260];
  GetRegisterCacheValue(1, asic_chain_index, asic_chip_index, command_match, &frequency_register_value);
  LOBYTE(frequency_register_value) = frequency_register_value & 0x30 | frequency_low_nibble & 0xF;
  BYTE1(frequency_register_value) = BYTE1(frequency_register_value) & 0x30 | frequency_high_nibble & 0xF;
  return initialize_asic_mining(asic_chain_index, 0, asic_chip_index, command_match, frequency_register_value);
}

//----- (00050794) --------------------------------------------------------
int __fastcall set_pll_frequency(unsigned int chip_address, unsigned int frequency_domain, __int16 frequency_value)
{
  char frequency_high_byte; // r5
  char frequency_low_byte; // r6
  unsigned int pll_register_address; // r7
  int pll_config_bits; // [sp+14h] [bp-1Ch] BYREF

  frequency_high_byte = HIBYTE(frequency_value);
  if ( frequency_domain > 3 )
    return -1;
  frequency_low_byte = frequency_value;
  pll_register_address = (unsigned __int8)aDh[frequency_domain + 260];
  GetRegisterCacheValue(0, chip_address, 0, pll_register_address, &pll_config_bits);
  LOBYTE(pll_config_bits) = pll_config_bits & 0x30 | frequency_low_byte & 0xF;
  BYTE1(pll_config_bits) = BYTE1(pll_config_bits) & 0x30 | frequency_high_byte & 0xF;
  return initialize_asic_mining(chip_address, 1, 0, pll_register_address, pll_config_bits);
}

//----- (0005082C) --------------------------------------------------------
int __fastcall set_miner_pll_config(
        unsigned int miner_id,
        unsigned int pll_freq,
        unsigned int voltage_level,
        float pll_factor)
{
  return set_pll_configuration(miner_id, 0, pll_freq, voltage_level, pll_factor);
}

//----- (00050850) --------------------------------------------------------
int __fastcall setup_miner_parameters(
        unsigned int mining_frequency,
        unsigned int voltage_level,
        float chip_temperature)
{
  return set_pll_configuration(mining_frequency, 1, 0, voltage_level, chip_temperature);
}

//----- (00050874) --------------------------------------------------------
int __fastcall initialize_mining_with_config(unsigned int frequency, unsigned int voltage, char chip_address)
{
  return initialize_asic_mining(frequency, 0, voltage, 84u, chip_address & 7);
}

//----- (000508A0) --------------------------------------------------------
int __fastcall initialize_asic_for_mining(unsigned int frequency, char chain_index)
{
  return initialize_asic_mining(frequency, 1, 0, 84u, chain_index & 7);
}

//----- (000508CC) --------------------------------------------------------
int __fastcall send_hash_board_initialization_command(int hash_board_id)
{
  return hash_board_command_send(hash_board_id, 1, 0, 72);
}

//----- (000508DC) --------------------------------------------------------
int sub_508DC()
{
  return 0;
}

//----- (000508E4) --------------------------------------------------------
int __fastcall sub_508E4(unsigned int a1, int a2, int a3, __int16 a4)
{
  char v8; // r3
  int v10; // [sp+Ch] [bp-1Ch] BYREF

  GetRegisterCacheValue(0, a1, 0, 164u, &v10);
  if ( a2 )
    v8 = HIBYTE(v10) | 0x80;
  else
    v8 = HIBYTE(v10) & 0x7F;
  HIBYTE(v10) = v8;
  switch ( a3 )
  {
    case 4:
      HIBYTE(v10) &= 207u;
      break;
    case 8:
      HIBYTE(v10) = HIBYTE(v10) & 0xCF | 0x10;
      break;
    case 12:
      HIBYTE(v10) = HIBYTE(v10) & 0xCF | 0x20;
      break;
    default:
      return -1;
  }
  LOWORD(v10) = a4;
  HIBYTE(v10) &= ~0x40u;
  return initialize_asic_mining(a1, 1, 0, 164u, v10);
}

//----- (00050A80) --------------------------------------------------------
int __fastcall set_register_bit(unsigned int chip_id, unsigned int register_address, int bit_value)
{
  char modified_bit; // r3
  int register_value; // [sp+Ch] [bp-14h] BYREF

  GetRegisterCacheValue(1, chip_id, register_address, 24u, &register_value);
  if ( bit_value )
    modified_bit = BYTE1(register_value) | 0x20;
  else
    modified_bit = BYTE1(register_value) & 0xDF;
  BYTE1(register_value) = modified_bit;
  return initialize_asic_mining(chip_id, 0, register_address, 24u, register_value);
}

//----- (00050B48) --------------------------------------------------------
int __fastcall set_chip_frequency(unsigned int chip_id, char frequency_code)
{
  int frequency_register; // [sp+Ch] [bp-14h] BYREF

  GetRegisterCacheValue(0, chip_id, 0, 88u, &frequency_register);
  BYTE1(frequency_register) = BYTE1(frequency_register) & 0xF | (16 * (frequency_code & 0xF));
  return initialize_asic_mining(chip_id, 1, 0, 88u, frequency_register);
}

//----- (00050BA4) --------------------------------------------------------
int get_error_code()
{
  return -1;
}

//----- (00050BAC) --------------------------------------------------------
int return_error()
{
  return -1;
}

//----- (00050BB4) --------------------------------------------------------
int get_error_status()
{
  return -1;
}

//----- (00050BBC) --------------------------------------------------------
int get_unsupported_feature_status()
{
  return -1;
}

//----- (00050BC4) --------------------------------------------------------
int error_return_negative_one()
{
  return -1;
}

//----- (00050BCC) --------------------------------------------------------
int get_unimplemented_status_code()
{
  return -1;
}

//----- (00050BD4) --------------------------------------------------------
int __fastcall set_reset_chip_flag(unsigned int chip_index, int reset_flag)
{
  char modified_reset_value; // r3
  int register_value; // [sp+Ch] [bp-14h] BYREF

  GetRegisterCacheValue(0, chip_index, 0, 24u, &register_value);
  if ( reset_flag )
    modified_reset_value = BYTE1(register_value) | 0x80;
  else
    modified_reset_value = BYTE1(register_value) & 0x7F;
  BYTE1(register_value) = modified_reset_value;
  return initialize_asic_mining(chip_index, 1, 0, 24u, register_value);
}

//----- (00050C38) --------------------------------------------------------
int __fastcall set_asic_mining_mode(unsigned int chip_index, int enable_flag)
{
  int register_value; // [sp+Ch] [bp-14h] BYREF

  GetRegisterCacheValue(0, chip_index, 0, 24u, &register_value);
  if ( enable_flag )
  {
    BYTE2(register_value) |= 64u;
    HIBYTE(register_value) &= 15u;
  }
  else
  {
    BYTE2(register_value) &= ~0x40u;
    HIBYTE(register_value) |= 240u;
  }
  return initialize_asic_mining(chip_index, 1, 0, 24u, register_value);
}

//----- (00050CC4) --------------------------------------------------------
int __fastcall sub_50CC4(unsigned int a1, unsigned int a2, int a3)
{
  int v7; // [sp+Ch] [bp-14h] BYREF

  GetRegisterCacheValue(1, a1, a2, 24u, &v7);
  if ( a3 )
  {
    BYTE2(v7) |= 64u;
    HIBYTE(v7) &= 15u;
  }
  else
  {
    BYTE2(v7) &= ~0x40u;
    HIBYTE(v7) |= 240u;
  }
  return initialize_asic_mining(a1, 0, a2, 24u, v7);
}

//----- (00050D54) --------------------------------------------------------
int __fastcall initialize_single_asic_miner(unsigned int asic_id, int asic_cfg_parameter)
{
  return initialize_asic_mining(asic_id, 1, 0, 16u, asic_cfg_parameter);
}

//----- (00050D78) --------------------------------------------------------
int __fastcall initialize_mining_chip(unsigned int chip_id, unsigned int frequency, int voltage)
{
  return initialize_asic_mining(chip_id, 0, frequency, 16u, voltage);
}

//----- (00050D9C) --------------------------------------------------------
int __fastcall start_miner_with_delay(unsigned int delay_duration)
{
  return initialize_miner_and_delay(delay_duration, 1, 0);
}

//----- (00050DA8) --------------------------------------------------------
int __fastcall initialize_miner_with_delay(unsigned int init_flag, unsigned int delay_duration)
{
  return initialize_miner_and_delay(init_flag, 0, delay_duration);
}

//----- (00050DB4) --------------------------------------------------------
int __fastcall initialize_asic_single_setting(unsigned int asic_id, char setting_value)
{
  return initialize_asic_with_settings(asic_id, 1, 0, setting_value);
}

//----- (00050DC4) --------------------------------------------------------
int __fastcall init_asic(unsigned int frequency, unsigned int voltage, char chain_index)
{
  return initialize_asic_with_settings(frequency, 0, voltage, chain_index);
}

//----- (00050DD4) --------------------------------------------------------
int __fastcall initialize_miner_with_default_config(unsigned int configuration_option)
{
  return init_asic_miner_with_config(configuration_option, 1, 0, 1u, 0);
}

//----- (00050DF8) --------------------------------------------------------
int __fastcall initialize_miner_frequency_voltage(unsigned int frequency, unsigned int voltage)
{
  return init_asic_miner_with_config(frequency, 0, voltage, 1u, 0);
}

//----- (00050E20) --------------------------------------------------------
int __fastcall initialize_asic_on_frequency(unsigned int frequency, unsigned __int8 asic_address)
{
  return init_asic_miner_with_config(frequency, 1, 0, 0, asic_address);
}

//----- (00050E44) --------------------------------------------------------
int __fastcall init_miner_with_parameters(unsigned int frequency, unsigned int voltage, unsigned __int8 chip_count)
{
  return init_asic_miner_with_config(frequency, 0, voltage, 0, chip_count);
}

//----- (00050E68) --------------------------------------------------------
int return_negative_one()
{
  return -1;
}

//----- (00050E70) --------------------------------------------------------
int error_return_minus_one()
{
  return -1;
}

//----- (00050E78) --------------------------------------------------------
int __fastcall enable_asic_boost_mode(unsigned int chip_index)
{
  int reg_cache_value; // [sp+Ch] [bp-Ch] BYREF

  GetRegisterCacheValue(0, chip_index, 0, 144u, &reg_cache_value);
  BYTE1(reg_cache_value) |= 8u;
  return initialize_asic_mining(chip_index, 1, 0, 144u, reg_cache_value);
}

//----- (00050ED0) --------------------------------------------------------
int __fastcall sub_50ED0(unsigned int a1)
{
  int v3; // [sp+Ch] [bp-Ch] BYREF

  GetRegisterCacheValue(0, a1, 0, 52u, &v3);
  LOBYTE(v3) = v3 | 1;
  return initialize_asic_mining(a1, 1, 0, 52u, v3);
}

//----- (00050F28) --------------------------------------------------------
int __fastcall sub_50F28(unsigned int a1)
{
  int v3; // [sp+Ch] [bp-Ch] BYREF

  GetRegisterCacheValue(0, a1, 0, 52u, &v3);
  LOBYTE(v3) = v3 & 0xFE;
  return initialize_asic_mining(a1, 1, 0, 52u, v3);
}

//----- (00050F80) --------------------------------------------------------
int __fastcall initialize_asics_with_parameters(unsigned int asic_index, int extra_parameter)
{
  return initialize_asic_mining(asic_index, 1, 0, 156u, extra_parameter);
}

//----- (00050FA4) --------------------------------------------------------
int __fastcall initialize_specific_asic_miner(unsigned int miner_id, char chip_id)
{
  return initialize_asic_mining(miner_id, 1, 0, 144u, (16 * ((chip_id - 1) & 7)) | 0x38001801);
}

//----- (00050FDC) --------------------------------------------------------
int __fastcall enable_chip_mining(unsigned int chip_id)
{
  int register_value; // [sp+Ch] [bp-Ch] BYREF

  GetRegisterCacheValue(0, chip_id, 0, 144u, &register_value);
  LOBYTE(register_value) = register_value | 0x8A;
  HIBYTE(register_value) |= 8u;
  BYTE1(register_value) &= ~8u;
  return initialize_asic_mining(chip_id, 1, 0, 144u, register_value);
}

//----- (000510C8) --------------------------------------------------------
int __fastcall send_reboot_command(int board_identifier)
{
  return hash_board_command_send(board_identifier, 1, 0, 144);
}

//----- (0005112C) --------------------------------------------------------
int __fastcall send_reset_command_to_hash_board(int hash_board_id)
{
  return hash_board_command_send(hash_board_id, 1, 0, 152);
}

//----- (0005113C) --------------------------------------------------------
int __fastcall send_restart_command(int hash_board_index)
{
  return hash_board_command_send(hash_board_index, 1, 0, 160);
}

//----- (0005114C) --------------------------------------------------------
int __fastcall send_hash_board_enable_command(int hash_board_index)
{
  return hash_board_command_send(hash_board_index, 1, 0, 224);
}

//----- (0005115C) --------------------------------------------------------
int get_unimplemented_feature_status()
{
  return -1;
}

//----- (00051164) --------------------------------------------------------
int __fastcall initialize_miner_register(unsigned int chip_address, unsigned int register_address)
{
  int register_value; // [sp+Ch] [bp-14h] BYREF

  GetRegisterCacheValue(1, chip_address, register_address, 24u, &register_value);
  BYTE1(register_value) |= 64u;
  LOBYTE(register_value) = register_value & 0x8F | 0x30;
  return initialize_asic_mining(chip_address, 0, register_address, 24u, register_value);
}

//----- (000511D0) --------------------------------------------------------
int __fastcall initialize_mining_config(
        unsigned int frequency,
        unsigned int chip_id,
        unsigned __int8 voltage_id,
        unsigned __int8 voltage_trim)
{
  return initialize_asic_mining(
           frequency,
           0,
           chip_id,
           28u,
           (unsigned __int16)(voltage_trim << 8) | (voltage_id >> 1 << 17) & 0x39FFFFFF | 0x1000000);
}

//----- (0005121C) --------------------------------------------------------
int __fastcall configure_asic_miner(
        unsigned int chip_id,
        unsigned int core_voltage,
        unsigned __int8 frequency_divider,
        int clock_source,
        unsigned __int8 misc_settings)
{
  return initialize_asic_mining(
           chip_id,
           0,
           core_voltage,
           28u,
           (misc_settings | (clock_source << 8)) & 0x3900FFFF | 0x10000 | (frequency_divider >> 1 << 17) & 0x39FFFFFF | 0x1000000);
}

//----- (00051260) --------------------------------------------------------
int __fastcall sub_51260(unsigned int a1, unsigned int a2, unsigned __int8 a3, int a4, unsigned __int8 a5)
{
  return configure_asic_miner(a1, a2, a3, a4, a5);
}

//----- (0005126C) --------------------------------------------------------
int __fastcall initialize_asic_mining_wrapper(
        unsigned int chain_index,
        unsigned int asic_count,
        unsigned __int8 freq_val_upper,
        unsigned __int8 freq_val_lower)
{
  return initialize_asic_mining(
           chain_index,
           0,
           asic_count,
           68u,
           (unsigned __int16)(freq_val_lower << 8) | (freq_val_upper << 24));
}

//----- (0005129C) --------------------------------------------------------
int __fastcall initialize_chip(
        unsigned int chip_address,
        unsigned int frequency,
        unsigned __int16 voltage,
        char chip_index,
        char reset_mode)
{
  return initialize_asic_mining(
           chip_address,
           0,
           frequency,
           44u,
           reset_mode & 1 | (unsigned __int16)(2 * (chip_index & 1)) | (voltage << 16));
}

//----- (000512CC) --------------------------------------------------------
int __fastcall set_mining_mode(unsigned int chip_id, char mining_mode)
{
  int mining_config; // [sp+Ch] [bp-14h] BYREF

  GetRegisterCacheValue(0, chip_id, 0, 24u, &mining_config);
  LOBYTE(mining_config) = mining_config & 0xF7 | (8 * (mining_mode & 1));
  return initialize_asic_mining(chip_id, 1, 0, 24u, mining_config);
}

//----- (00051328) --------------------------------------------------------
int __fastcall sub_51328(unsigned int a1, unsigned int a2, char a3)
{
  int v7; // [sp+Ch] [bp-14h] BYREF

  GetRegisterCacheValue(1, a1, a2, 24u, &v7);
  LOBYTE(v7) = v7 & 0xF7 | (8 * (a3 & 1));
  return initialize_asic_mining(a1, 0, a2, 24u, v7);
}

//----- (000513FC) --------------------------------------------------------
int __fastcall sub_513FC(unsigned int chip_id)
{
  int chip_config_value; // [sp+Ch] [bp-Ch] BYREF

  GetRegisterCacheValue(0, chip_id, 0, 176u, &chip_config_value);
  LOBYTE(chip_config_value) = chip_config_value & 0xBF;
  HIWORD(chip_config_value) &= 57339u;
  return initialize_asic_mining(chip_id, 1, 0, 176u, chip_config_value);
}

//----- (0005146C) --------------------------------------------------------
int __fastcall initialize_asic_wrapper(unsigned int chip_id, unsigned int frequency)
{
  return initialize_asic(chip_id, 0, frequency);
}

//----- (00051478) --------------------------------------------------------
int __fastcall initialize_single_asic(unsigned int asic_id)
{
  return initialize_asic(asic_id, 1, 0);
}

//----- (00051484) --------------------------------------------------------
int __fastcall forward_request_to_lower_layer(unsigned int source_id, unsigned int target_id, char request_type)
{
  return configure_chip_mining(source_id, 0, target_id, request_type);
}

//----- (00051494) --------------------------------------------------------
int __fastcall send_command_to_miner(unsigned int command_code, char command_param)
{
  return configure_chip_mining(command_code, 1, 0, command_param);
}

//----- (000514A4) --------------------------------------------------------
int __fastcall enable_asic_hashing(unsigned int chip_address)
{
  int chip_register_value; // [sp+Ch] [bp-Ch] BYREF

  GetRegisterCacheValue(0, chip_address, 0, 176u, &chip_register_value);
  LOBYTE(chip_register_value) = chip_register_value | 0x10;
  initialize_asic_mining(chip_address, 1, 0, 176u, chip_register_value);
  usleep(30000u);
  return 0;
}

//----- (00051508) --------------------------------------------------------
int __fastcall init_asic_mining_with_options(unsigned int chip_address, unsigned int chip_id)
{
  int control_register_value; // [sp+Ch] [bp-14h] BYREF

  GetRegisterCacheValue(1, chip_address, chip_id, 176u, &control_register_value);
  LOBYTE(control_register_value) = control_register_value | 0x10;
  initialize_asic_mining(chip_address, 0, chip_id, 176u, control_register_value);
  usleep(30000u);
  return 0;
}

//----- (00051570) --------------------------------------------------------
int __fastcall send_reset_hash_board_command(int hash_board_index)
{
  return hash_board_command_send(hash_board_index, 1, 0, 176);
}

//----- (00051580) --------------------------------------------------------
int __fastcall send_hash_board_reset_command(int hash_board_index, char reset_type)
{
  return hash_board_command_send(hash_board_index, 0, reset_type, 176);
}

//----- (00051590) --------------------------------------------------------
int __fastcall sub_51590(int board_index)
{
  return hash_board_command_send(board_index, 1, 0, 180);
}

//----- (000515A0) --------------------------------------------------------
int __fastcall send_reset_command(int board_id, char reset_type)
{
  return hash_board_command_send(board_id, 0, reset_type, 180);
}

//----- (000515B0) --------------------------------------------------------
int __fastcall send_reset_command_to_board(int board_index)
{
  return hash_board_command_send(board_index, 1, 0, 184);
}

//----- (000515C0) --------------------------------------------------------
int __fastcall send_hash_board_command(int hash_board_id, char command)
{
  return hash_board_command_send(hash_board_id, 0, command, 184);
}

//----- (000515D0) --------------------------------------------------------
int __fastcall initialize_mining_task(unsigned int chip_id, unsigned int task_id, char core_index, char work_flags)
{
  return initialize_asic_mining(
           chip_id,
           0,
           task_id,
           60u,
           (unsigned __int8)((16 * (core_index & 3)) | work_flags & 7) | 0x80008700);
}

//----- (0005161C) --------------------------------------------------------
int __fastcall initialize_chip_with_config(unsigned int chip_id, char config_bank, char config_settings)
{
  return initialize_asic_mining(
           chip_id,
           1,
           0,
           60u,
           (unsigned __int8)((16 * (config_bank & 3)) | config_settings & 7) | 0x80008700);
}

//----- (00051668) --------------------------------------------------------
int __fastcall initialize_miner_with_defaults(
        unsigned int chain_index,
        unsigned int chip_index,
        char frequency,
        char voltage,
        char mode)
{
  return initialize_miner_config(chain_index, 0, chip_index, frequency, voltage, mode);
}

//----- (00051694) --------------------------------------------------------
int __fastcall initialize_specific_miner(unsigned int miner_id, char option_1, char option_2, char option_3)
{
  return initialize_miner_config(miner_id, 1, 0, option_1, option_2, option_3);
}

//----- (000516BC) --------------------------------------------------------
int __fastcall init_mining_config(unsigned int chip_address, unsigned int hash_rate)
{
  return initialize_asic_mining(chip_address, 0, hash_rate, 60u, -2147483648);
}

//----- (000516F8) --------------------------------------------------------
int __fastcall sub_516F8(int hash_board_id, char reset_type)
{
  return hash_board_command_send(hash_board_id, 0, reset_type, 224);
}

//----- (00051708) --------------------------------------------------------
int __fastcall initialize_mining(unsigned int frequency_option, int mining_parameter)
{
  return init_mining_with_options(frequency_option, 1, 0, mining_parameter);
}

//----- (00051718) --------------------------------------------------------
int __fastcall initialize_chip_mining(unsigned int frequency, unsigned int chip_index, int timeout)
{
  return init_mining_with_options(frequency, 0, chip_index, timeout);
}

//----- (00051728) --------------------------------------------------------
int __fastcall initiate_mining_process(unsigned int miner_id, int config_parameter)
{
  return initialize_asic_mining(miner_id, 1, 0, 128u, config_parameter);
}

//----- (0005174C) --------------------------------------------------------
int __fastcall initialize_chip_with_frequency_and_voltage(unsigned int frequency, unsigned int voltage, int chip_id)
{
  return initialize_asic_mining(frequency, 0, voltage, 128u, chip_id);
}

//----- (00051770) --------------------------------------------------------
int __fastcall initialize_single_miner(unsigned int miner_id)
{
  return initialize_asic_mining(miner_id, 1, 0, 128u, 0);
}

//----- (00051794) --------------------------------------------------------
int __fastcall init_asic_mining_with_params(unsigned int frequency, unsigned int voltage)
{
  return initialize_asic_mining(frequency, 0, voltage, 128u, 0);
}

//----- (000517BC) --------------------------------------------------------
int __fastcall configure_mining_asics(unsigned int chip_id, int enable)
{
  int voltage_value; // r3

  if ( enable )
    voltage_value = 255;
  else
    voltage_value = 0;
  return initialize_asic_mining(chip_id, 1, 0, 32u, voltage_value);
}
// 517D4: conditional instruction was optimized away because r1.4!=0

//----- (000517F8) --------------------------------------------------------
int __fastcall initialize_asic_with_frequency(unsigned int miner_id, unsigned int frequency, int chip_id)
{
  if ( chip_id )
    LOWORD(chip_id) = 255;
  return initialize_asic_mining(miner_id, 0, frequency, 32u, (unsigned __int16)chip_id);
}

//----- (000518F8) --------------------------------------------------------
int get_invalid_return_value()
{
  return -1;
}

//----- (00051900) --------------------------------------------------------
int return_minus_one()
{
  return -1;
}

//----- (00051908) --------------------------------------------------------
int __fastcall set_asic_boost_mode(unsigned int miner_id, char boost_mode)
{
  return initialize_asic_mining(miner_id, 1, 0, 60u, ((boost_mode & 0xF) << 8) & 0x7FFF | 0x80000000);
}

//----- (0005193C) --------------------------------------------------------
int __fastcall initialize_chip_frequency(unsigned int chip_id, unsigned int frequency, char chain_index)
{
  return initialize_asic_mining(chip_id, 0, frequency, 60u, ((chain_index & 0xF) << 8) & 0x7FFF | 0x80000000);
}

//----- (00051970) --------------------------------------------------------
unsigned int __fastcall get_high_byte(unsigned int input_value)
{
  return HIBYTE(input_value);
}

//----- (00051978) --------------------------------------------------------
int __fastcall get_voltage_status(int voltage_setting, unsigned int chip_id)
{
  return (unsigned __int8)calculate_bit_difficulty(BYTE2(voltage_setting), chip_id);
}

//----- (0005198C) --------------------------------------------------------
int __fastcall initialize_hardware_buffer(unsigned int buffer_index)
{
  _DWORD *buffer_ptr; // r9
  int index; // r7
  _DWORD *block_ptr; // r4
  void *copy_target; // r0

  if ( buffer_index > 3 )
    return -1;
  buffer_ptr = &dword_5051C8[128 * buffer_index];
  for ( index = 0; index != 4; ++index )
  {
    if ( buffer_index == index )
    {
      block_ptr = &dword_5059E0[32768 * buffer_index];
      do
      {
        copy_target = block_ptr;
        block_ptr += 128;
        memcpy(copy_target, &unk_7F588, 512u);
      }
      while ( block_ptr != (_DWORD *)((char *)&unk_5259E0 + 131072 * buffer_index) );
      memcpy(buffer_ptr, &unk_7F588, 512u);
    }
  }
  return 0;
}
// 5051C8: using guessed type _DWORD dword_5051C8[512];
// 5059E0: using guessed type _DWORD dword_5059E0[32768];

//----- (00051A20) --------------------------------------------------------
int __fastcall GetRegisterCacheValue(
        int cache_level,
        unsigned int chain_index,
        unsigned int asic_index,
        unsigned int register_address,
        _DWORD *cached_value)
{
  unsigned int address_offset; // r6
  int error_code; // r10
  unsigned int combined_index_second_level; // r6
  unsigned int combined_index_first_level; // r6
  _DWORD *register_cache_ptr; // r6

  address_offset = (unsigned __int8)(register_address >> 2);
  if ( chain_index > 3 )
    return -1;
  if ( asic_index > 255 )
    return -2;
  if ( address_offset > 63 )
    return -3;
  pthread_mutex_lock(&stru_5059C8);
  if ( cache_level )
  {
    if ( cache_level != 1 )
    {
      error_code = -6;
      pthread_mutex_unlock(&stru_5059C8);
LABEL_7:
      printf(
        "[%s] level::%d, which_chain::%u, which_asic::%u, register_address::%02x failed.\r\n",
        "get_register_cache_value",
        cache_level,
        chain_index,
        asic_index,
        register_address);
      return error_code;
    }
    combined_index_second_level = address_offset + ((asic_index + (chain_index << 8)) << 6);
    if ( dword_5059E0[2 * combined_index_second_level] != register_address )
    {
      error_code = -5;
      pthread_mutex_unlock(&stru_5059C8);
      goto LABEL_7;
    }
    register_cache_ptr = &dword_5059E0[2 * combined_index_second_level];
  }
  else
  {
    combined_index_first_level = address_offset + (chain_index << 6);
    if ( dword_5051C8[2 * combined_index_first_level] != register_address )
    {
      error_code = -4;
      pthread_mutex_unlock(&stru_5059C8);
      goto LABEL_7;
    }
    register_cache_ptr = &dword_5051C8[2 * combined_index_first_level];
  }
  *cached_value = register_cache_ptr[1];
  pthread_mutex_unlock(&stru_5059C8);
  return 0;
}
// 5051C8: using guessed type _DWORD dword_5051C8[512];
// 5059E0: using guessed type _DWORD dword_5059E0[32768];

//----- (00051B44) --------------------------------------------------------
int __fastcall setRegisterValue(
        int registerLevel,
        unsigned int chainIndex,
        unsigned int asicIndex,
        unsigned int registerAddress,
        int value)
{
  unsigned int registerSlot; // r4
  int errorCode; // r4
  unsigned int cacheIndex; // r4
  unsigned int cacheAddress; // r2
  unsigned int cacheOffset; // r3
  char *startAddress; // r2
  char *endAddress; // r3

  if ( chainIndex > 3 )
    return -1;
  if ( asicIndex > 255 )
    return -2;
  registerSlot = registerAddress >> 2;
  if ( registerAddress >> 2 > 64 )
    return -3;
  pthread_mutex_lock(&stru_5059C8);
  if ( registerLevel )
  {
    if ( registerLevel != 1 )
    {
      errorCode = -6;
      pthread_mutex_unlock(&stru_5059C8);
LABEL_7:
      printf(
        "[%s] level::%d, which_chain::%u, which_asic::%u, register_address::%02x failed.\r\n",
        "set_register_cache_value",
        registerLevel,
        chainIndex,
        asicIndex,
        registerAddress);
      return errorCode;
    }
    cacheIndex = registerSlot + ((asicIndex + (chainIndex << 8)) << 6);
    if ( dword_5059E0[2 * cacheIndex] != registerAddress )
    {
      errorCode = -5;
      pthread_mutex_unlock(&stru_5059C8);
      goto LABEL_7;
    }
    dword_5059E0[2 * cacheIndex + 1] = value;
    pthread_mutex_unlock(&stru_5059C8);
    return 0;
  }
  else
  {
    cacheAddress = registerSlot + (chainIndex << 6);
    if ( dword_5051C8[2 * cacheAddress] != registerAddress )
    {
      errorCode = -4;
      pthread_mutex_unlock(&stru_5059C8);
      goto LABEL_7;
    }
    cacheOffset = 2 * (registerSlot + (chainIndex << 14));
    dword_5051C8[2 * cacheAddress + 1] = value;
    startAddress = (char *)&unk_5259E0 + cacheOffset * 4;
    endAddress = (char *)&dword_5059E0[cacheOffset];
    do
    {
      *((_DWORD *)endAddress + 1) = value;
      endAddress += 512;
    }
    while ( endAddress != startAddress );
    pthread_mutex_unlock(&stru_5059C8);
    return 0;
  }
}
// 5051C8: using guessed type _DWORD dword_5051C8[512];
// 5059E0: using guessed type _DWORD dword_5059E0[32768];

//----- (00051CAC) --------------------------------------------------------
int __fastcall prepare_message_buffer(int flag_init, char mode, char chip_id, int value, _BYTE *message_buffer)
{
  int v5; // r5

  if ( !message_buffer )
    return -1;
  v5 = 0;
  *(_DWORD *)message_buffer = 0;
  message_buffer[3] = chip_id;
  message_buffer[7] = value;
  message_buffer[2] = mode;
  message_buffer[4] = HIBYTE(value);
  message_buffer[5] = BYTE2(value);
  message_buffer[6] = BYTE1(value);
  message_buffer[8] = 0;
  *message_buffer = (16 * (flag_init != 0)) & 0x1E | 0x41;
  message_buffer[1] = 9;
  message_buffer[8] = message_buffer[8] & 0xE0 | calculate_crc(message_buffer, 64u) & 0x1F;
  return v5;
}

//----- (00051D44) --------------------------------------------------------
int __fastcall prepare_command_packet(char command_id, _BYTE *packet_buffer)
{
  int return_value; // r5

  if ( !packet_buffer )
    return -1;
  return_value = 0;
  *(_DWORD *)packet_buffer = 0;
  packet_buffer[4] = 0;
  packet_buffer[2] = command_id;
  packet_buffer[1] = 5;
  *packet_buffer = 64;
  packet_buffer[4] = packet_buffer[4] & 0xE0 | calculate_crc(packet_buffer, 32u) & 0x1F;
  return return_value;
}

//----- (00051D98) --------------------------------------------------------
int __fastcall initialize_header(int is_encrypted, char chip_address, char chain_index, _BYTE *header_buffer)
{
  int v4; // r5

  if ( !header_buffer )
    return -1;
  v4 = 0;
  *(_DWORD *)header_buffer = 0;
  header_buffer[3] = chain_index;
  header_buffer[2] = chip_address;
  header_buffer[4] = 0;
  header_buffer[1] = 5;
  *header_buffer = (16 * (is_encrypted != 0)) & 0x1D | 0x42;
  header_buffer[4] = header_buffer[4] & 0xE0 | calculate_crc(header_buffer, 32u) & 0x1F;
  return v4;
}

//----- (00051E08) --------------------------------------------------------
int __fastcall initialize_status_data(_BYTE *status_data)
{
  int v1; // r5

  if ( !status_data )
    return -1;
  v1 = 0;
  *(_DWORD *)status_data = 0;
  status_data[4] = 0;
  status_data[1] = 5;
  *status_data = 83;
  status_data[4] = status_data[4] & 0xE0 | calculate_crc(status_data, 32u) & 0x1F;
  return v1;
}

//----- (00051E54) --------------------------------------------------------
int __fastcall copy_data_to_state_buffer(int machine_state, int input_data, unsigned int data_length)
{
  int *state_buffer_ptr; // r4
  unsigned int processed_length; // lr
  int current_byte_index; // r3
  int current_buffer_value; // r12
  int current_input_byte; // r5
  int state_buffer[9]; // [sp+4h] [bp-24h] BYREF

  processed_length = 0;
  state_buffer[0] = 0;
  if ( data_length )
    state_buffer_ptr = state_buffer;
  state_buffer[1] = 0;
  state_buffer[2] = 0;
  if ( !data_length )
    goto LABEL_9;
LABEL_4:
  while ( 2 )
  {
    current_byte_index = 0;
    if ( processed_length < data_length )
    {
      do
      {
        current_buffer_value = *state_buffer_ptr;
        if ( current_byte_index )
        {
          current_input_byte = *(unsigned __int8 *)(input_data + processed_length + current_byte_index);
          if ( current_byte_index == 1 )
          {
            *state_buffer_ptr = current_buffer_value | (current_input_byte << 16);
          }
          else if ( current_byte_index == 2 )
          {
            *state_buffer_ptr = current_buffer_value | (current_input_byte << 8);
          }
          else
          {
            *state_buffer_ptr = current_input_byte | current_buffer_value;
            if ( current_byte_index == 3 )
            {
              processed_length += 4;
              ++state_buffer_ptr;
              if ( processed_length >= data_length )
                goto LABEL_9;
              goto LABEL_4;
            }
          }
        }
        else
        {
          *state_buffer_ptr = current_buffer_value | (*(unsigned __int8 *)(input_data + processed_length) << 24);
        }
        ++current_byte_index;
      }
      while ( processed_length + current_byte_index < data_length );
    }
    processed_length += 4;
    ++state_buffer_ptr;
    if ( processed_length < data_length )
      continue;
    break;
  }
LABEL_9:
  configure_machine_state(state_buffer, machine_state);
  return 0;
}
// 51E98: variable 'state_buffer_ptr' is possibly undefined

//----- (00051F28) --------------------------------------------------------
int __fastcall calculate_crc(_BYTE *data, unsigned int length)
{
  int bit_position; // r2
  char prev_crc_bit0; // r9
  unsigned int current_byte_pos; // r12
  int prev_crc_bit1; // r6
  int prev_crc_bit2; // r8
  int prev_crc_bit3; // r5
  int prev_crc_bit4; // r7
  unsigned int current_bit_mask; // r4
  unsigned int current_bit_value; // r3
  unsigned __int8 new_crc_bit0; // r3
  int new_crc_bit2; // lr
  int crc_result; // r0

  if ( !length )
    return 31;
  LOBYTE(bit_position) = 0;
  prev_crc_bit0 = 1;
  LOBYTE(current_byte_pos) = 0;
  prev_crc_bit1 = 1;
  prev_crc_bit2 = 1;
  prev_crc_bit3 = 1;
  prev_crc_bit4 = 1;
  current_bit_mask = 128;
  while ( 1 )
  {
    bit_position = (unsigned __int8)(bit_position + 1);
    current_byte_pos = (unsigned __int8)(current_byte_pos + 1);
    current_bit_value = *data & current_bit_mask;
    current_bit_mask >>= 1;
    if ( current_bit_value )
      new_crc_bit0 = prev_crc_bit0 ^ 1;
    else
      new_crc_bit0 = prev_crc_bit0;
    if ( bit_position == 8 )
    {
      ++data;
      LOBYTE(bit_position) = 0;
      current_bit_mask = 128;
    }
    new_crc_bit2 = (unsigned __int8)(new_crc_bit0 ^ prev_crc_bit3);
    prev_crc_bit0 = prev_crc_bit1;
    if ( current_byte_pos >= length )
      break;
    prev_crc_bit1 = prev_crc_bit2;
    prev_crc_bit3 = prev_crc_bit4;
    prev_crc_bit2 = new_crc_bit2;
    prev_crc_bit4 = new_crc_bit0;
  }
  if ( prev_crc_bit1 )
    crc_result = 16;
  else
    crc_result = 0;
  if ( prev_crc_bit2 )
    crc_result |= 8u;
  if ( new_crc_bit0 != prev_crc_bit3 )
    crc_result |= 4u;
  if ( prev_crc_bit4 )
    crc_result |= 2u;
  if ( new_crc_bit0 )
    return crc_result | 1;
  return crc_result;
}

//----- (00052050) --------------------------------------------------------
int __fastcall initialize_network_thread(int settings_ptr)
{
  pthread_t self_thread_id; // r0
  unsigned int port_number; // r2
  int sockfd; // r0
  int server_fd; // r4
  unsigned int current_port; // r3
  int client_fd; // r5
  size_t sent_hello_length; // r0
  size_t receive_length; // r8
  void *receive_buffer; // r6
  ssize_t received_count_initial; // r0
  ssize_t received_count; // r1
  int (__fastcall *processing_result)(void *, ssize_t); // r4
  size_t sent_ack_length; // r0
  int sockopt_value; // [sp+8h] [bp-260h] BYREF
  socklen_t client_addr_size; // [sp+Ch] [bp-25Ch] BYREF
  char thread_name[4]; // [sp+10h] [bp-258h] BYREF
  int unused1; // [sp+14h] [bp-254h]
  int unused2; // [sp+18h] [bp-250h]
  int unused3; // [sp+1Ch] [bp-24Ch]
  struct sockaddr server_addr; // [sp+20h] [bp-248h] BYREF
  struct sockaddr client_addr; // [sp+30h] [bp-238h] BYREF
  char hello_message[4]; // [sp+40h] [bp-228h] BYREF
  char unused_hello_buffer[252]; // [sp+44h] [bp-224h] BYREF
  char ack_message[4]; // [sp+140h] [bp-128h] BYREF
  char unused_ack_buffer[252]; // [sp+144h] [bp-124h] BYREF

  self_thread_id = pthread_self();
  pthread_detach(self_thread_id);
  port_number = *(_DWORD *)settings_ptr;
  *(_DWORD *)thread_name = 0;
  unused1 = 0;
  unused2 = 0;
  unused3 = 0;
  sprintf(thread_name, "ct_b/fcb/%d", port_number);
  prctl(15, thread_name);
  server_addr.sa_family = 2;
  *(_DWORD *)&server_addr.sa_data[2] = inet_addr("127.0.0.1");
  sockfd = socket(2, 1, 0);
  server_fd = sockfd;
  if ( sockfd < 0 )
  {
    perror("socket error");
    return 0;
  }
  else
  {
    sockopt_value = 1;
    if ( setsockopt(sockfd, 1, 2, &sockopt_value, 4u) < 0 )
    {
      perror("set sockopt err");
      return 0;
    }
    else
    {
      for ( current_port = *(_DWORD *)settings_ptr; ; *(_DWORD *)settings_ptr = current_port )
      {
        *(_WORD *)server_addr.sa_data = __rev16(current_port);
        if ( bind(server_fd, &server_addr, 16u) >= 0 )
          break;
        perror("bind error");
        current_port = *(_DWORD *)settings_ptr + 1;
      }
      if ( listen(server_fd, 5) < 0 )
      {
        perror("listen error");
      }
      else
      {
        client_addr_size = 16;
        *(_DWORD *)(settings_ptr + 144) = 1;
        client_fd = accept(server_fd, &client_addr, &client_addr_size);
        if ( client_fd >= 0 )
        {
          *(_DWORD *)hello_message = 0;
          memset(unused_hello_buffer, 0, sizeof(unused_hello_buffer));
          sprintf(hello_message, "%x %s\n", 63, (const char *)(settings_ptr + 16));
          sent_hello_length = strlen(hello_message);
          send(client_fd, hello_message, sent_hello_length + 1, 0);
          receive_length = *(_DWORD *)(settings_ptr + 148);
          receive_buffer = malloc(receive_length);
          received_count_initial = recv(client_fd, receive_buffer, receive_length, 0);
          if ( received_count_initial > 0 )
            *((_BYTE *)receive_buffer + received_count_initial) = 0;
          while ( 1 )
          {
            received_count = recv(client_fd, receive_buffer, *(_DWORD *)(settings_ptr + 148), 0);
            if ( received_count > 0 )
            {
              processing_result = *(int (__fastcall **)(void *, ssize_t))(settings_ptr + 12);
              if ( processing_result )
                processing_result = (int (__fastcall *)(void *, ssize_t))processing_result(
                                                                           receive_buffer,
                                                                           received_count);
            }
            else
            {
              processing_result = 0;
            }
            *(_DWORD *)ack_message = 0;
            memset(unused_ack_buffer, 0, sizeof(unused_ack_buffer));
            sprintf(ack_message, "%x %d %s %s", 63, processing_result, (const char *)(settings_ptr + 16), "OK");
            sent_ack_length = strlen(ack_message);
            send(client_fd, ack_message, sent_ack_length + 1, 0);
          }
        }
        perror("accept error");
      }
      return 0;
    }
  }
}

//----- (000522DC) --------------------------------------------------------
int __fastcall sub_522DC(int a1)
{
  pthread_t v2; // r0
  int v3; // r7
  ssize_t v4; // r0
  int v5; // r4
  int v6; // r4
  _DWORD *v7; // r0
  int v8; // r11
  _DWORD *v9; // r10
  const char *v10; // r5
  int v11; // r0
  int v12; // r3
  size_t v13; // r0
  int v14; // r10
  size_t v15; // r0
  size_t v17; // r0
  int v18; // [sp+14h] [bp-224h] BYREF
  pthread_t newthread; // [sp+18h] [bp-220h] BYREF
  char v20[8]; // [sp+1Ch] [bp-21Ch] BYREF
  int v21; // [sp+24h] [bp-214h]
  int v22; // [sp+28h] [bp-210h]
  char src[4]; // [sp+2Ch] [bp-20Ch] BYREF
  int v24; // [sp+30h] [bp-208h]
  int v25; // [sp+34h] [bp-204h]
  int v26; // [sp+38h] [bp-200h]
  int v27; // [sp+3Ch] [bp-1FCh]
  int v28; // [sp+40h] [bp-1F8h]
  int v29; // [sp+44h] [bp-1F4h]
  int v30; // [sp+48h] [bp-1F0h]
  char s1[4]; // [sp+4Ch] [bp-1ECh] BYREF
  int v32; // [sp+50h] [bp-1E8h]
  int v33; // [sp+54h] [bp-1E4h]
  int v34; // [sp+58h] [bp-1E0h]
  int v35; // [sp+5Ch] [bp-1DCh]
  int v36; // [sp+60h] [bp-1D8h]
  int v37; // [sp+64h] [bp-1D4h]
  int v38; // [sp+68h] [bp-1D0h]
  pthread_attr_t attr; // [sp+6Ch] [bp-1CCh] BYREF
  int buf[32]; // [sp+90h] [bp-1A8h] BYREF
  char v41[4]; // [sp+110h] [bp-128h] BYREF
  char v42[252]; // [sp+114h] [bp-124h] BYREF

  v2 = pthread_self();
  pthread_detach(v2);
  v22 = 0;
  qmemcpy(v20, "ct_b/mai", sizeof(v20));
  v21 = *(unsigned __int16 *)"n";
  prctl(15, v20);
  pthread_attr_init(&attr);
  pthread_attr_setstacksize(&attr, 1048576u);
  v3 = *(_DWORD *)(a1 + 8);
  while ( 1 )
  {
    memset(buf, 0, sizeof(buf));
    v4 = recv(v3, buf, 128u, 0);
    if ( v4 <= 0 )
      return 0;
    *((_BYTE *)buf + v4) = 0;
    *(_DWORD *)src = 0;
    v24 = 0;
    *(_DWORD *)s1 = 0;
    v32 = 0;
    v18 = 0;
    v25 = 0;
    v26 = 0;
    v27 = 0;
    v28 = 0;
    v29 = 0;
    v30 = 0;
    v33 = 0;
    v34 = 0;
    v35 = 0;
    v36 = 0;
    v37 = 0;
    v38 = 0;
    _isoc99_sscanf(buf, "%x%s%s", &v18, s1, src);
    v5 = strcmp(s1, "regist");
    if ( v5 )
    {
      v6 = dword_5859E0 + 1;
      memcpy((char *)&unk_585A08 + 128 * dword_5859E0, buf, 128u);
      dword_5859E0 = v6;
    }
    else
    {
      v7 = calloc(152u, 1u);
      v8 = dword_5859E4;
      v9 = v7;
      if ( !dword_5859E4 )
        goto LABEL_18;
      v10 = s2;
      while ( 1 )
      {
        v11 = strcmp(src, v10);
        v10 += 136;
        if ( !v11 )
          break;
        if ( ++v5 == v8 )
          goto LABEL_11;
      }
      v12 = *((_DWORD *)&unk_589A08 + 34 * v5 + 33);
      v9[3] = *((_DWORD *)&unk_589A08 + 34 * v5);
      v9[37] = v12;
LABEL_11:
      if ( v8 == v5 )
      {
LABEL_18:
        *(_DWORD *)v41 = 0;
        memset(v42, 0, sizeof(v42));
        sprintf(v41, "%x %d %s %s %s", 63, 0, "reg_resp", "no_name", src);
        v17 = strlen(v41);
        send(v3, v41, v17 + 1, 0);
        free(v9);
      }
      else
      {
        *v9 = dword_7F788;
        v13 = strlen(src);
        memcpy(v9 + 4, src, v13 + 1);
        v9[36] = 0;
        pthread_create(&newthread, &attr, (void *(*)(void *))initialize_network_thread, v9);
        while ( !v9[36] )
          usleep(10000u);
        v14 = *v9;
        *(_DWORD *)v41 = 0;
        if ( v14 != dword_7F788 )
          dword_7F788 = v14;
        memset(v42, 0, sizeof(v42));
        sprintf(v41, "%x %d %s %s %s", 63, v14, "reg_resp", "OK", src);
        v15 = strlen(v41);
        send(v3, v41, v15 + 1, 0);
        ++dword_7F788;
      }
    }
  }
}
// 1231C: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);
// 7F788: using guessed type int dword_7F788;
// 5859E0: using guessed type int dword_5859E0;
// 5859E4: using guessed type int dword_5859E4;

//----- (0005261C) --------------------------------------------------------
int __fastcall setup_network_server(int config_data, int entries_count)
{
  int v2; // r7
  char *config_ptr; // r4
  char *dst_ptr; // r3
  char *config_end; // r5
  char *copied_data; // r0
  int entry_data; // r2
  int socket_fd; // r0
  int server_socket; // r8
  unsigned int port; // r4
  int client_socket; // r5
  size_t hello_msg_len; // r0
  ssize_t received_bytes; // r0
  bool receive_error; // cc
  ssize_t config_bytes; // r0
  _DWORD *thread_args; // r0
  int socket_option; // [sp+8h] [bp-470h] BYREF
  socklen_t client_addr_len; // [sp+Ch] [bp-46Ch] BYREF
  pthread_t network_thread; // [sp+10h] [bp-468h] BYREF
  struct sockaddr server_addr; // [sp+14h] [bp-464h] BYREF
  struct sockaddr client_addr; // [sp+24h] [bp-454h] BYREF
  pthread_attr_t thread_attributes; // [sp+34h] [bp-444h] BYREF
  char greeting_buffer[4]; // [sp+58h] [bp-420h] BYREF
  char zero_buffer[124]; // [sp+5Ch] [bp-41Ch] BYREF
  int client_config_data[32]; // [sp+D8h] [bp-3A0h] BYREF
  char fixed_message[256]; // [sp+158h] [bp-320h] BYREF
  int receive_buffer[136]; // [sp+258h] [bp-220h] BYREF

  v2 = dword_5859E8;
  if ( dword_5859E8 )
    return -1;
  pthread_attr_init(&thread_attributes);
  pthread_attr_setstacksize(&thread_attributes, 1048576u);
  pthread_mutex_init(&stru_5859EC, (const pthread_mutexattr_t *)v2);
  dword_5859E4 = entries_count;
  if ( entries_count )
  {
    config_ptr = (char *)(config_data + 4);
    dst_ptr = s2;
    config_end = &config_ptr[136 * entries_count];
    do
    {
      copied_data = (char *)memcpy(dst_ptr, config_ptr, 128u);
      config_ptr += 136;
      entry_data = *((_DWORD *)config_ptr - 35);
      dst_ptr = copied_data + 136;
      *((_DWORD *)copied_data + 32) = *((_DWORD *)config_ptr - 2);
      *((_DWORD *)copied_data - 1) = entry_data;
    }
    while ( config_ptr != config_end );
  }
  *(_WORD *)&server_addr.sa_data[6] = 0;
  *(_DWORD *)&server_addr.sa_data[8] = 0;
  *(_WORD *)&server_addr.sa_data[12] = 0;
  *(_WORD *)server_addr.sa_data = 0;
  server_addr.sa_family = 2;
  *(_DWORD *)&server_addr.sa_data[2] = inet_addr("127.0.0.1");
  socket_option = 1;
  socket_fd = socket(2, 1, 0);
  server_socket = socket_fd;
  if ( socket_fd < 0 )
  {
    v2 = -4;
    perror("socket error");
  }
  else if ( setsockopt(socket_fd, 1, 2, &socket_option, 4u) < 0 )
  {
    v2 = -4;
    perror("set sockopt err");
  }
  else
  {
    port = 22026;
    while ( 1 )
    {
      *(_WORD *)server_addr.sa_data = __rev16(port++);
      if ( bind(server_socket, &server_addr, 16u) >= 0 )
        break;
      perror("bind error");
    }
    if ( listen(server_socket, 5) < 0 )
    {
      v2 = -4;
      perror("listen error");
    }
    else
    {
      client_addr_len = 16;
      client_socket = accept(server_socket, &client_addr, &client_addr_len);
      if ( client_socket < 0 )
      {
        v2 = -4;
        perror("accept error");
      }
      else
      {
        *(_DWORD *)greeting_buffer = 0;
        memset(zero_buffer, 0, sizeof(zero_buffer));
        sprintf(greeting_buffer, "Hello!0x%x\n", 63);
        hello_msg_len = strlen(greeting_buffer);
        send(client_socket, greeting_buffer, hello_msg_len + 1, 0);
        dword_5859E8 = 1;
        memset(receive_buffer, 0, 512);
        dword_585A04 = client_socket;
        received_bytes = recv(client_socket, receive_buffer, 1024u, 0);
        receive_error = received_bytes <= 0;
        if ( received_bytes > 0 )
          received_bytes += (ssize_t)&receive_buffer[128];
        if ( !receive_error )
          *(_BYTE *)(received_bytes - 512) = 0;
        strcpy(fixed_message, "123 456 789 abc");
        memset(&fixed_message[16], 0, 240u);
        send(client_socket, fixed_message, 16u, 0);
        memset(client_config_data, 0, sizeof(client_config_data));
        config_bytes = recv(client_socket, client_config_data, 128u, 0);
        if ( config_bytes > 0 )
          *((_BYTE *)client_config_data + config_bytes) = 0;
        thread_args = malloc(12u);
        thread_args[2] = client_socket;
        thread_args[1] = server_socket;
        pthread_create(
          &network_thread,
          &thread_attributes,
          (void *(*)(void *))initialize_antminer_connection,
          thread_args);
      }
    }
  }
  return v2;
}
// 5859E4: using guessed type int dword_5859E4;
// 5859E8: using guessed type int dword_5859E8;
// 5859EC: using guessed type pthread_mutex_t stru_5859EC;
// 585A04: using guessed type int dword_585A04;

//----- (00052930) --------------------------------------------------------
int __fastcall initialize_miner_connection(int miner_data)
{
  pthread_mutex_t *mutex_ptr; // r8
  int socket_fd; // r9
  int current_index; // r5
  size_t message_len; // r0
  int connection_socket; // r0
  int miner_socket; // r5
  ssize_t recv_bytes; // r0
  unsigned int miner_port; // r3
  int connect_result; // r0
  unsigned int port_hex; // [sp+10h] [bp-498h] BYREF
  int param_1; // [sp+14h] [bp-494h] BYREF
  struct sockaddr server_addr; // [sp+18h] [bp-490h] BYREF
  int param_2; // [sp+28h] [bp-480h] BYREF
  int param_3; // [sp+2Ch] [bp-47Ch]
  int param_4; // [sp+30h] [bp-478h]
  int param_5; // [sp+34h] [bp-474h]
  int param_6; // [sp+38h] [bp-470h]
  int param_7; // [sp+3Ch] [bp-46Ch]
  int param_8; // [sp+40h] [bp-468h]
  int param_9; // [sp+44h] [bp-464h]
  int param_10; // [sp+48h] [bp-460h] BYREF
  int param_11; // [sp+4Ch] [bp-45Ch]
  int param_12; // [sp+50h] [bp-458h]
  int param_13; // [sp+54h] [bp-454h]
  int param_14; // [sp+58h] [bp-450h]
  int param_15; // [sp+5Ch] [bp-44Ch]
  int param_16; // [sp+60h] [bp-448h]
  int param_17; // [sp+64h] [bp-444h]
  int param_18; // [sp+68h] [bp-440h] BYREF
  int param_19; // [sp+6Ch] [bp-43Ch]
  int param_20; // [sp+70h] [bp-438h]
  int param_21; // [sp+74h] [bp-434h]
  int param_22; // [sp+78h] [bp-430h]
  int param_23; // [sp+7Ch] [bp-42Ch]
  int param_24; // [sp+80h] [bp-428h]
  int param_25; // [sp+84h] [bp-424h]
  int received_data[32]; // [sp+88h] [bp-420h] BYREF
  int send_data_buffer[32]; // [sp+108h] [bp-3A0h] BYREF
  char registration_message[4]; // [sp+188h] [bp-320h] BYREF
  char zero_buffer[252]; // [sp+18Ch] [bp-31Ch] BYREF
  int recv_buffer[136]; // [sp+288h] [bp-220h] BYREF

  if ( !dword_5859E8 )
    return -1;
  mutex_ptr = (pthread_mutex_t *)malloc(36u);
  pthread_mutex_init(mutex_ptr, 0);
  socket_fd = dword_585A04;
  *(_DWORD *)registration_message = 0;
  memset(zero_buffer, 0, sizeof(zero_buffer));
  sprintf(registration_message, "%x regist %s", 63, (const char *)miner_data);
  current_index = dword_5859E0;
  message_len = strlen(registration_message);
  send(socket_fd, registration_message, message_len + 1, 0);
  memset(received_data, 0, sizeof(received_data));
  while ( dword_5859E0 == current_index )
    usleep(1000u);
  memcpy(received_data, (char *)&unk_585A08 + 128 * current_index, sizeof(received_data));
  port_hex = 0;
  param_1 = 0;
  param_2 = 0;
  param_3 = 0;
  param_10 = 0;
  param_11 = 0;
  param_18 = 0;
  param_19 = 0;
  param_4 = 0;
  param_5 = 0;
  param_6 = 0;
  param_7 = 0;
  param_8 = 0;
  param_9 = 0;
  param_12 = 0;
  param_13 = 0;
  param_14 = 0;
  param_15 = 0;
  param_16 = 0;
  param_17 = 0;
  param_20 = 0;
  param_21 = 0;
  param_22 = 0;
  param_23 = 0;
  param_24 = 0;
  param_25 = 0;
  _isoc99_sscanf(received_data, "%x%d%s%s%s", &param_1, &port_hex, &param_2, &param_10, &param_18);
  if ( !port_hex )
    return -4;
  server_addr.sa_family = 2;
  memset(server_addr.sa_data, 0, sizeof(server_addr.sa_data));
  *(_DWORD *)&server_addr.sa_data[2] = inet_addr("127.0.0.1");
  *(_WORD *)server_addr.sa_data = __rev16(port_hex);
  connection_socket = socket(2, 1, 0);
  miner_socket = connection_socket;
  if ( connection_socket < 0 )
  {
    perror("socket err:");
    return -4;
  }
  else if ( connect(connection_socket, &server_addr, 16u) < 0 )
  {
    perror("connect err:");
    return -3;
  }
  else
  {
    memset(recv_buffer, 0, 512);
    recv_bytes = recv(miner_socket, recv_buffer, 512u, 0);
    if ( recv_bytes > 0 )
      *((_BYTE *)recv_buffer + recv_bytes) = 0;
    memset(&send_data_buffer[1], 0, 124u);
    send_data_buffer[0] = (int)&unk_214B4F;
    send(miner_socket, send_data_buffer, 4u, 0);
    miner_port = port_hex;
    connect_result = 0;
    mutex_ptr[1].__owner = miner_socket;
    *(_DWORD *)(miner_data + 128) = mutex_ptr;
    mutex_ptr[1].__lock = miner_port;
  }
  return connect_result;
}
// 1231C: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);
// 5859E0: using guessed type int dword_5859E0;
// 5859E8: using guessed type int dword_5859E8;
// 585A04: using guessed type int dword_585A04;

//----- (00052BD8) --------------------------------------------------------
int sub_52BD8()
{
  return 0;
}

//----- (00052BF0) --------------------------------------------------------
int __fastcall send_and_receive_data(int device_id, const void *send_data, size_t send_length, _DWORD *response_code)
{
  pthread_mutex_t *device_mutex; // r5
  int v8; // r4
  ssize_t recv_length; // r0
  int parsed_value1; // [sp+8h] [bp-160h] BYREF
  int parsed_value2; // [sp+Ch] [bp-15Ch] BYREF
  int parsed_value3; // [sp+10h] [bp-158h] BYREF
  int unused1; // [sp+14h] [bp-154h]
  int unused2; // [sp+18h] [bp-150h]
  int unused3; // [sp+1Ch] [bp-14Ch]
  int unused4; // [sp+20h] [bp-148h]
  int unused5; // [sp+24h] [bp-144h]
  int unused6; // [sp+28h] [bp-140h]
  int unused7; // [sp+2Ch] [bp-13Ch]
  int parsed_str1; // [sp+30h] [bp-138h] BYREF
  int unused8; // [sp+34h] [bp-134h]
  int unused9; // [sp+38h] [bp-130h]
  int unused10; // [sp+3Ch] [bp-12Ch]
  int unused11; // [sp+40h] [bp-128h]
  int unused12; // [sp+44h] [bp-124h]
  int unused13; // [sp+48h] [bp-120h]
  int unused14; // [sp+4Ch] [bp-11Ch]
  int recv_buffer[70]; // [sp+50h] [bp-118h] BYREF

  if ( !dword_5859E8 )
    return -1;
  device_mutex = *(pthread_mutex_t **)(device_id + 128);
  if ( !device_mutex )
    return -2;
  v8 = pthread_mutex_trylock(*(pthread_mutex_t **)(device_id + 128));
  if ( v8 )
    return -3;
  if ( send(device_mutex[1].__owner, send_data, send_length, 0) <= 0 )
  {
    v8 = -4;
    pthread_mutex_unlock(device_mutex);
  }
  else
  {
    memset(recv_buffer, 0, 256);
    recv_length = recv(device_mutex[1].__owner, recv_buffer, 256u, 0);
    parsed_value1 = 0;
    parsed_value2 = 0;
    parsed_value3 = 0;
    unused1 = 0;
    parsed_str1 = 0;
    unused8 = 0;
    unused2 = 0;
    unused3 = 0;
    unused4 = 0;
    unused5 = 0;
    unused6 = 0;
    unused7 = 0;
    unused9 = 0;
    unused10 = 0;
    unused11 = 0;
    unused12 = 0;
    unused13 = 0;
    unused14 = 0;
    if ( recv_length > 0 )
      _isoc99_sscanf(recv_buffer, "%x%d%s%s", &parsed_value1, &parsed_value2, &parsed_value3, &parsed_str1);
    if ( response_code )
      *response_code = parsed_value2;
    pthread_mutex_unlock(device_mutex);
  }
  return v8;
}
// 1231C: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);
// 5859E8: using guessed type int dword_5859E8;

//----- (00052D3C) --------------------------------------------------------
int get_constant_zero()
{
  return 0;
}

//----- (00052D44) --------------------------------------------------------
void sub_52D44()
{
  _DWORD *v0; // r0

  v0 = pthread_getspecific(dword_58DE08);
  if ( v0 )
    release_thread_resources(v0);
}
// 58DE08: using guessed type int dword_58DE08;

//----- (00052D68) --------------------------------------------------------
int shutdown_miner_threads()
{
  int shutdown_result; // r0

  if ( dword_58DE0C )
    delete_category_table((_DWORD *)dword_58DE0C);
  dword_58DE0C = 0;
  dword_58DE10 = 0;
  if ( dword_58DE14 )
    delete_record_table((_DWORD *)dword_58DE14);
  dword_58DE14 = 0;
  shutdown_result = dword_99EEC8;
  if ( dword_99EEC8 )
    shutdown_result = delete_zlog_config((_DWORD *)dword_99EEC8);
  dword_99EEC8 = 0;
  return shutdown_result;
}
// 58DE0C: using guessed type int dword_58DE0C;
// 58DE10: using guessed type int dword_58DE10;
// 58DE14: using guessed type int dword_58DE14;
// 99EEC8: using guessed type int dword_99EEC8;

//----- (00052DCC) --------------------------------------------------------
int __fastcall sub_52DCC(const char *logging_config_file_path)
{
  int thread_key_creation_status; // r0
  int cleanup_function_registration_status; // r0

  if ( !dword_58DE18 )
  {
    thread_key_creation_status = pthread_key_create(
                                   (pthread_key_t *)&dword_58DE08,
                                   (void (*)(void *))release_thread_resources);
    if ( thread_key_creation_status )
    {
      sub_5DF98(2, "src/zlog.c", 76, "pthread_key_create fail, rc[%d]", thread_key_creation_status);
      goto LABEL_12;
    }
    cleanup_function_registration_status = register_cleanup_function((void (__fastcall *)(void *))release_thread_specific_data);
    if ( cleanup_function_registration_status )
    {
      sub_5DF98(2, "src/zlog.c", 85, "atexit fail, rc[%d]", cleanup_function_registration_status);
      goto LABEL_12;
    }
    dword_58DE18 = 1;
  }
  dword_99EEC8 = initialize_zlog_configuration(logging_config_file_path);
  if ( dword_99EEC8 )
  {
    dword_58DE0C = (int)create_category_hashtable();
    if ( dword_58DE0C )
    {
      dword_58DE14 = (int)create_record_table();
      if ( dword_58DE14 )
        return 0;
      sub_5DF98(2, "src/zlog.c", 105, "zlog_record_table_new fail");
    }
    else
    {
      sub_5DF98(2, "src/zlog.c", 99, "zlog_category_table_new fail");
    }
  }
  else
  {
    sub_5DF98(2, "src/zlog.c", 93, "zlog_conf_new[%s] fail", logging_config_file_path);
  }
LABEL_12:
  shutdown_miner_threads();
  return -1;
}
// 58DE08: using guessed type int dword_58DE08;
// 58DE0C: using guessed type int dword_58DE0C;
// 58DE14: using guessed type int dword_58DE14;
// 58DE18: using guessed type int dword_58DE18;
// 99EEC8: using guessed type int dword_99EEC8;

//----- (00052F1C) --------------------------------------------------------
int __fastcall initialize_logging(const char *config_file_path)
{
  int lock_result; // r0
  int unlock_result; // r0
  int final_result; // r0

  sub_5DF98(0, "src/zlog.c", 119, "------zlog_init start------");
  sub_5DF98(0, "src/zlog.c", 120, "------compile time[%s %s], version[%s]------", "Dec  6 2022", "16:28:36", "1.2.12");
  lock_result = pthread_rwlock_wrlock(&stru_58DE1C);
  if ( lock_result )
  {
    sub_5DF98(2, "src/zlog.c", 124, "pthread_rwlock_wrlock fail, rc[%d]", lock_result);
    return -1;
  }
  if ( dword_58DE3C )
  {
    sub_5DF98(2, "src/zlog.c", 129, "already init, use zlog_reload pls");
    goto LABEL_5;
  }
  if ( sub_52DCC(config_file_path) )
  {
    sub_5DF98(2, "src/zlog.c", 135, "zlog_init_inner[%s] fail", config_file_path);
LABEL_5:
    sub_5DF98(2, "src/zlog.c", 150, "------zlog_init fail end------");
    unlock_result = pthread_rwlock_unlock(&stru_58DE1C);
    if ( unlock_result )
      sub_5DF98(2, "src/zlog.c", 153, "pthread_rwlock_unlock fail, rc=[%d]", unlock_result);
    return -1;
  }
  dword_58DE3C = 1;
  ++dword_58DE18;
  sub_5DF98(0, "src/zlog.c", 142, "------zlog_init success end------");
  final_result = pthread_rwlock_unlock(&stru_58DE1C);
  if ( final_result )
  {
    sub_5DF98(2, "src/zlog.c", 145, "pthread_rwlock_unlock fail, rc=[%d]", final_result);
    return -1;
  }
  return final_result;
}
// 58DE18: using guessed type int dword_58DE18;
// 58DE3C: using guessed type int dword_58DE3C;

//----- (000530EC) --------------------------------------------------------
int __fastcall initialize_logger(const char *config_file_path, const char *task_category)
{
  int lock_result; // r0
  int unlock_result; // r0
  int result; // r0

  sub_5DF98(0, "src/zlog.c", 162, "------dzlog_init start------");
  sub_5DF98(0, "src/zlog.c", 164, "------compile time[%s %s], version[%s]------", "Dec  6 2022", "16:28:36", "1.2.12");
  lock_result = pthread_rwlock_wrlock(&stru_58DE1C);
  if ( lock_result )
  {
    sub_5DF98(2, "src/zlog.c", 168, "pthread_rwlock_wrlock fail, rc[%d]", lock_result);
    return -1;
  }
  if ( dword_58DE3C )
  {
    sub_5DF98(2, "src/zlog.c", 173, "already init, use zlog_reload pls");
    goto LABEL_5;
  }
  if ( sub_52DCC(config_file_path) )
  {
    sub_5DF98(2, "src/zlog.c", 178, "zlog_init_inner[%s] fail", config_file_path);
LABEL_5:
    sub_5DF98(2, "src/zlog.c", 202, "------dzlog_init fail end------");
    unlock_result = pthread_rwlock_unlock(&stru_58DE1C);
    if ( unlock_result )
      sub_5DF98(2, "src/zlog.c", 205, "pthread_rwlock_unlock fail, rc=[%d]", unlock_result);
    return -1;
  }
  dword_58DE10 = (int)add_category_to_task(dword_58DE0C, task_category, *(_DWORD **)(dword_99EEC8 + 9288));
  if ( !dword_58DE10 )
  {
    sub_5DF98(2, "src/zlog.c", 187, "zlog_category_table_fetch_category[%s] fail", task_category);
    goto LABEL_5;
  }
  ++dword_58DE18;
  dword_58DE3C = 1;
  sub_5DF98(0, "src/zlog.c", 194, "------dzlog_init success end------");
  result = pthread_rwlock_unlock(&stru_58DE1C);
  if ( result )
  {
    sub_5DF98(2, "src/zlog.c", 197, "pthread_rwlock_unlock fail, rc=[%d]", result);
    return -1;
  }
  return result;
}
// 58DE0C: using guessed type int dword_58DE0C;
// 58DE10: using guessed type int dword_58DE10;
// 58DE18: using guessed type int dword_58DE18;
// 58DE3C: using guessed type int dword_58DE3C;
// 99EEC8: using guessed type int dword_99EEC8;

//----- (00053314) --------------------------------------------------------
int __fastcall reload_zlog_configuration(const char *input_conf_file_path)
{
  int lock_status; // r0
  int v3; // r7
  const char *conf_file_path; // r0
  int category_index; // r4
  int conf_init_result; // r0
  _DWORD *new_config; // r8
  _DWORD *category_array_ptr; // r1
  int category_descriptor; // r0
  int unlock_status; // r0
  int final_unlock_status; // r0
  int final_unlock_result; // r0

  sub_5DF98(0, "src/zlog.c", 219, "------zlog_reload start------");
  lock_status = pthread_rwlock_wrlock(&stru_58DE1C);
  v3 = lock_status;
  if ( lock_status )
  {
    v3 = -1;
    sub_5DF98(2, "src/zlog.c", 222, "pthread_rwlock_wrlock fail, rc[%d]", lock_status);
    return v3;
  }
  if ( !dword_58DE3C )
  {
    sub_5DF98(2, "src/zlog.c", 227, "never call zlog_init() or dzlog_init() before");
LABEL_15:
    sub_5DF98(0, "src/zlog.c", 291, "------zlog_reload do nothing------");
    final_unlock_status = pthread_rwlock_unlock(&stru_58DE1C);
    if ( final_unlock_status )
    {
      v3 = -1;
      sub_5DF98(2, "src/zlog.c", 294, "pthread_rwlock_unlock fail, rc=[%d]", final_unlock_status);
    }
    return v3;
  }
  if ( !input_conf_file_path )
    input_conf_file_path = (const char *)dword_99EEC8;
  if ( input_conf_file_path == (const char *)-1 )
  {
    input_conf_file_path = (const char *)dword_99EEC8;
    if ( *(_DWORD *)(dword_99EEC8 + 9276) >= (unsigned int)dword_58DE40 )
      goto LABEL_15;
  }
  conf_file_path = input_conf_file_path;
  category_index = 0;
  dword_58DE40 = 0;
  conf_init_result = initialize_zlog_configuration(conf_file_path);
  new_config = (_DWORD *)conf_init_result;
  if ( !conf_init_result )
  {
    sub_5DF98(2, "src/zlog.c", 250, "zlog_conf_new fail");
    sub_5DF98(1, "src/zlog.c", 280, "zlog_reload fail, use old conf file, still working");
LABEL_11:
    sub_5DF98(2, "src/zlog.c", 283, "------zlog_reload fail, total init version[%d] ------", dword_58DE18);
    unlock_status = pthread_rwlock_unlock(&stru_58DE1C);
    v3 = -1;
    if ( unlock_status )
      sub_5DF98(2, "src/zlog.c", 286, "pthread_rwlock_unlock fail, rc=[%d]", unlock_status);
    return v3;
  }
  category_array_ptr = *(_DWORD **)(conf_init_result + 9288);
  if ( (int)category_array_ptr[1] > 0 )
  {
    do
    {
      category_descriptor = *(_DWORD *)(*category_array_ptr + 4 * category_index++);
      check_and_process_task(category_descriptor, dword_58DE14);
      category_array_ptr = (_DWORD *)new_config[2322];
    }
    while ( category_array_ptr[1] > category_index );
  }
  if ( update_rules_with_rollback(dword_58DE0C, category_array_ptr) )
  {
    sub_5DF98(2, "src/zlog.c", 260, "zlog_category_table_update fail");
    sub_5DF98(1, "src/zlog.c", 280, "zlog_reload fail, use old conf file, still working");
    delete_zlog_config(new_config);
    goto LABEL_11;
  }
  ++dword_58DE18;
  clear_categories(dword_58DE0C);
  delete_zlog_config((_DWORD *)dword_99EEC8);
  dword_99EEC8 = (int)new_config;
  sub_5DF98(0, "src/zlog.c", 271, "------zlog_reload success, total init verison[%d] ------", dword_58DE18);
  final_unlock_result = pthread_rwlock_unlock(&stru_58DE1C);
  if ( final_unlock_result )
  {
    v3 = -1;
    sub_5DF98(2, "src/zlog.c", 274, "pthread_rwlock_unlock fail, rc=[%d]", final_unlock_result);
  }
  return v3;
}
// 58DE0C: using guessed type int dword_58DE0C;
// 58DE14: using guessed type int dword_58DE14;
// 58DE18: using guessed type int dword_58DE18;
// 58DE3C: using guessed type int dword_58DE3C;
// 58DE40: using guessed type int dword_58DE40;
// 99EEC8: using guessed type int dword_99EEC8;

//----- (00053604) --------------------------------------------------------
int shutdown_logging_system()
{
  int lock_result; // r0
  int unlock_result; // r0

  sub_5DF98(0, "src/zlog.c", 304, "------zlog_fini start------");
  lock_result = pthread_rwlock_wrlock(&stru_58DE1C);
  if ( lock_result )
    return sub_5DF98(2, "src/zlog.c", 307, "pthread_rwlock_wrlock fail, rc[%d]", lock_result);
  if ( dword_58DE3C )
  {
    shutdown_miner_threads();
    dword_58DE3C = 0;
  }
  else
  {
    sub_5DF98(2, "src/zlog.c", 312, "before finish, must zlog_init() or dzlog_init() fisrt");
  }
  sub_5DF98(0, "src/zlog.c", 320, "------zlog_fini end------");
  unlock_result = pthread_rwlock_unlock(&stru_58DE1C);
  if ( unlock_result )
    return sub_5DF98(2, "src/zlog.c", 323, "pthread_rwlock_unlock fail, rc=[%d]", unlock_result);
  return unlock_result;
}
// 58DE3C: using guessed type int dword_58DE3C;

//----- (000536F4) --------------------------------------------------------
_DWORD *__fastcall get_logging_category(const char *category_name)
{
  int lock_result; // r0
  _DWORD *category; // r6
  int unlock_result; // r0
  int final_unlock_result; // r0

  if ( !category_name )
  {
    category = 0;
    sub_5DF98(2, "src/zlog.c", 334, "cname is null or 0");
    return category;
  }
  sub_5DF98(0, "src/zlog.c", 335, "------zlog_get_category[%s] start------", category_name);
  lock_result = pthread_rwlock_wrlock(&stru_58DE1C);
  if ( lock_result )
  {
    category = 0;
    sub_5DF98(2, "src/zlog.c", 338, "pthread_rwlock_wrlock fail, rc[%d]", lock_result);
    return category;
  }
  if ( dword_58DE3C )
  {
    category = add_category_to_task(dword_58DE0C, category_name, *(_DWORD **)(dword_99EEC8 + 9288));
    if ( category )
    {
      sub_5DF98(0, "src/zlog.c", 357, "------zlog_get_category[%s] success, end------ ", category_name);
      unlock_result = pthread_rwlock_unlock(&stru_58DE1C);
      if ( unlock_result )
      {
        category = 0;
        sub_5DF98(2, "src/zlog.c", 360, "pthread_rwlock_unlock fail, rc=[%d]", unlock_result);
      }
      return category;
    }
    sub_5DF98(2, "src/zlog.c", 353, "zlog_category_table_fetch_category[%s] fail", category_name);
  }
  else
  {
    sub_5DF98(2, "src/zlog.c", 343, "never call zlog_init() or dzlog_init() before");
  }
  sub_5DF98(2, "src/zlog.c", 365, "------zlog_get_category[%s] fail, end------ ", category_name);
  final_unlock_result = pthread_rwlock_unlock(&stru_58DE1C);
  category = (_DWORD *)final_unlock_result;
  if ( !final_unlock_result )
    return category;
  sub_5DF98(2, "src/zlog.c", 368, "pthread_rwlock_unlock fail, rc=[%d]", final_unlock_result);
  return 0;
}
// 58DE0C: using guessed type int dword_58DE0C;
// 58DE3C: using guessed type int dword_58DE3C;
// 99EEC8: using guessed type int dword_99EEC8;

//----- (000538C4) --------------------------------------------------------
int __fastcall set_logger_category(const char *category_name)
{
  int lock_result; // r0
  int unlock_result; // r0
  int final_result; // r0

  if ( !category_name )
  {
    sub_5DF98(2, "src/zlog.c", 377, "cname is null or 0");
    return -1;
  }
  sub_5DF98(0, "src/zlog.c", 379, "------dzlog_set_category[%s] start------", category_name);
  lock_result = pthread_rwlock_wrlock(&stru_58DE1C);
  if ( lock_result )
  {
    sub_5DF98(2, "src/zlog.c", 382, "pthread_rwlock_wrlock fail, rc[%d]", lock_result);
    return -1;
  }
  if ( !dword_58DE3C )
  {
    sub_5DF98(2, "src/zlog.c", 387, "never call zlog_init() or dzlog_init() before");
LABEL_5:
    sub_5DF98(2, "src/zlog.c", 408, "------dzlog_set_category[%s] end, fail------ ", category_name);
    unlock_result = pthread_rwlock_unlock(&stru_58DE1C);
    if ( unlock_result )
      sub_5DF98(2, "src/zlog.c", 411, "pthread_rwlock_unlock fail, rc=[%d]", unlock_result);
    return -1;
  }
  dword_58DE10 = (int)add_category_to_task(dword_58DE0C, category_name, *(_DWORD **)(dword_99EEC8 + 9288));
  if ( !dword_58DE10 )
  {
    sub_5DF98(2, "src/zlog.c", 396, "zlog_category_table_fetch_category[%s] fail", category_name);
    goto LABEL_5;
  }
  sub_5DF98(0, "src/zlog.c", 400, "------dzlog_set_category[%s] end, success------ ", category_name);
  final_result = pthread_rwlock_unlock(&stru_58DE1C);
  if ( final_result )
  {
    sub_5DF98(2, "src/zlog.c", 403, "pthread_rwlock_unlock fail, rc=[%d]", final_result);
    return -1;
  }
  return final_result;
}
// 58DE0C: using guessed type int dword_58DE0C;
// 58DE10: using guessed type int dword_58DE10;
// 58DE3C: using guessed type int dword_58DE3C;
// 99EEC8: using guessed type int dword_99EEC8;

//----- (00053A94) --------------------------------------------------------
int __fastcall set_metadata_key_value(const char *key, const char *value)
{
  int lock_result; // r0
  int unlock_result; // r0
  int final_result; // r0
  int **thread_log_info; // r6
  int global_init_flag; // r0
  int resize_result; // r0
  int **new_thread_log_info; // r0
  int set_specific_result; // r8

  if ( !key )
  {
    sub_5DF98(2, "src/zlog.c", 462, "key is null or 0");
    return -1;
  }
  if ( !value )
  {
    sub_5DF98(2, "src/zlog.c", 463, "value is null or 0");
    return -1;
  }
  lock_result = pthread_rwlock_rdlock(&stru_58DE1C);
  if ( lock_result )
  {
    sub_5DF98(2, "src/zlog.c", 467, "pthread_rwlock_wrlock fail, rc[%d]", lock_result);
    return -1;
  }
  if ( !dword_58DE3C )
  {
    sub_5DF98(2, "src/zlog.c", 472, "never call zlog_init() or dzlog_init() before");
LABEL_6:
    unlock_result = pthread_rwlock_unlock(&stru_58DE1C);
    if ( unlock_result )
      sub_5DF98(2, "src/zlog.c", 492, "pthread_rwlock_unlock fail, rc=[%d]", unlock_result);
    return -1;
  }
  thread_log_info = (int **)pthread_getspecific(dword_58DE08);
  global_init_flag = dword_58DE18;
  if ( !thread_log_info )
  {
    new_thread_log_info = (int **)initialize_logging_thread(
                                    dword_58DE18,
                                    *(_DWORD *)(dword_99EEC8 + 1052),
                                    *(_DWORD *)(dword_99EEC8 + 1056),
                                    *(_DWORD *)(dword_99EEC8 + 9292));
    thread_log_info = new_thread_log_info;
    if ( !new_thread_log_info )
    {
      sub_5DF98(2, "src/zlog.c", 476, "zlog_thread_new fail");
      goto LABEL_6;
    }
    set_specific_result = pthread_setspecific(dword_58DE08, new_thread_log_info);
    if ( set_specific_result )
    {
      release_thread_resources(thread_log_info);
      sub_5DF98(2, "src/zlog.c", 476, "pthread_setspecific fail, rd[%d]", set_specific_result);
      goto LABEL_6;
    }
    global_init_flag = dword_58DE18;
  }
  if ( *thread_log_info != (int *)global_init_flag )
  {
    resize_result = rebuild_buffer_if_needed(
                      (int)thread_log_info,
                      *(_DWORD *)(dword_99EEC8 + 1052),
                      *(_DWORD *)(dword_99EEC8 + 1056));
    if ( resize_result
      || (resize_result = allocate_event_memory((int)thread_log_info, *(_DWORD *)(dword_99EEC8 + 9292))) != 0 )
    {
      sub_5DF98(2, "src/zlog.c", 476, "zlog_thread_resize_msg_buf fail, rd[%d]", resize_result);
      goto LABEL_6;
    }
    *thread_log_info = (int *)dword_58DE18;
  }
  if ( add_metadata_to_hashtable(thread_log_info[1], key, value) )
  {
    sub_5DF98(2, "src/zlog.c", 479, "zlog_mdc_put fail, key[%s], value[%s]", key, value);
    goto LABEL_6;
  }
  final_result = pthread_rwlock_unlock(&stru_58DE1C);
  if ( final_result )
  {
    sub_5DF98(2, "src/zlog.c", 485, "pthread_rwlock_unlock fail, rc=[%d]", final_result);
    return -1;
  }
  return final_result;
}
// 58DE08: using guessed type int dword_58DE08;
// 58DE18: using guessed type int dword_58DE18;
// 58DE3C: using guessed type int dword_58DE3C;
// 99EEC8: using guessed type int dword_99EEC8;

//----- (00053D3C) --------------------------------------------------------
int __fastcall get_mdc_value(const char *key)
{
  int lock_result; // r0
  int **thread_specific_data; // r0
  int value; // r5
  int unlock_result; // r0
  int unlock_fail_result; // r0

  if ( !key )
  {
    value = 0;
    sub_5DF98(2, "src/zlog.c", 504, "key is null or 0");
    return value;
  }
  lock_result = pthread_rwlock_rdlock(&stru_58DE1C);
  if ( lock_result )
  {
    value = 0;
    sub_5DF98(2, "src/zlog.c", 508, "pthread_rwlock_rdlock fail, rc[%d]", lock_result);
    return value;
  }
  if ( dword_58DE3C )
  {
    thread_specific_data = (int **)pthread_getspecific(dword_58DE08);
    if ( thread_specific_data )
    {
      value = handle_hashtable_get(thread_specific_data[1], (int)key);
      if ( value )
      {
        unlock_result = pthread_rwlock_unlock(&stru_58DE1C);
        if ( unlock_result )
        {
          value = 0;
          sub_5DF98(2, "src/zlog.c", 531, "pthread_rwlock_unlock fail, rc=[%d]", unlock_result);
        }
        return value;
      }
      sub_5DF98(2, "src/zlog.c", 525, "key[%s] not found in mdc", key);
    }
    else
    {
      sub_5DF98(2, "src/zlog.c", 519, "thread not found, maybe not use zlog_put_mdc before");
    }
  }
  else
  {
    sub_5DF98(2, "src/zlog.c", 513, "never call zlog_init() or dzlog_init() before");
  }
  unlock_fail_result = pthread_rwlock_unlock(&stru_58DE1C);
  value = unlock_fail_result;
  if ( !unlock_fail_result )
    return value;
  sub_5DF98(2, "src/zlog.c", 538, "pthread_rwlock_unlock fail, rc=[%d]", unlock_fail_result);
  return 0;
}
// 58DE08: using guessed type int dword_58DE08;
// 58DE3C: using guessed type int dword_58DE3C;

//----- (00053EC8) --------------------------------------------------------
int __fastcall send_key_to_miner_if_initialized(const void *key)
{
  int lock_result; // r0
  int unlock_result; // r0
  _DWORD ***thread_specific_data; // r0

  if ( !key )
    return sub_5DF98(2, "src/zlog.c", 549, "key is null or 0");
  lock_result = pthread_rwlock_rdlock(&stru_58DE1C);
  if ( lock_result )
    return sub_5DF98(2, "src/zlog.c", 553, "pthread_rwlock_rdlock fail, rc[%d]", lock_result);
  if ( dword_58DE3C )
  {
    thread_specific_data = (_DWORD ***)pthread_getspecific(dword_58DE08);
    if ( thread_specific_data )
      send_to_miner(thread_specific_data[1], key);
    else
      sub_5DF98(2, "src/zlog.c", 564, "thread not found, maybe not use zlog_put_mdc before");
  }
  else
  {
    sub_5DF98(2, "src/zlog.c", 558, "never call zlog_init() or dzlog_init() before");
  }
  unlock_result = pthread_rwlock_unlock(&stru_58DE1C);
  if ( unlock_result )
    return sub_5DF98(2, "src/zlog.c", 573, "pthread_rwlock_unlock fail, rc=[%d]", unlock_result);
  return unlock_result;
}
// 58DE08: using guessed type int dword_58DE08;
// 58DE3C: using guessed type int dword_58DE3C;

//----- (00053FE0) --------------------------------------------------------
int check_zlog_initialization()
{
  int lock_result; // r0
  _DWORD ***specific_data; // r0
  int result; // r0

  lock_result = pthread_rwlock_rdlock(&stru_58DE1C);
  if ( lock_result )
    return sub_5DF98(2, "src/zlog.c", 586, "pthread_rwlock_rdlock fail, rc[%d]", lock_result);
  if ( dword_58DE3C )
  {
    specific_data = (_DWORD ***)pthread_getspecific(dword_58DE08);
    if ( specific_data )
      get_subsystem_status(specific_data[1]);
    else
      sub_5DF98(2, "src/zlog.c", 597, "thread not found, maybe not use zlog_put_mdc before");
  }
  else
  {
    sub_5DF98(2, "src/zlog.c", 591, "never call zlog_init() or dzlog_init() before");
  }
  result = pthread_rwlock_unlock(&stru_58DE1C);
  if ( result )
    return sub_5DF98(2, "src/zlog.c", 606, "pthread_rwlock_unlock fail, rc=[%d]", result);
  return result;
}
// 58DE08: using guessed type int dword_58DE08;
// 58DE3C: using guessed type int dword_58DE3C;

//----- (000540C8) --------------------------------------------------------
int __fastcall initialize_hash_buffer(int buffer, int bit_length)
{
  int hash_buffer_offset; // r5
  int relevant_bits; // r3
  int byte_offset; // r2
  bool negative_flag; // nf
  int inverted_bit_length; // r4
  int inverted_relevant_bits; // r4
  int buffer_with_offset; // r6

  hash_buffer_offset = buffer + 1032;
  memset((void *)(buffer + 1032), 0, 32u);
  LOBYTE(relevant_bits) = bit_length & 7;
  byte_offset = bit_length / 8;
  inverted_bit_length = -bit_length;
  negative_flag = inverted_bit_length < 0;
  inverted_relevant_bits = inverted_bit_length & 7;
  buffer_with_offset = buffer + byte_offset;
  if ( !negative_flag )
    relevant_bits = -inverted_relevant_bits;
  *(_BYTE *)(buffer_with_offset + 1032) |= ~(-1 << (8 - relevant_bits));
  memset((void *)(hash_buffer_offset + byte_offset + 1), 255, 31 - byte_offset);
  return 0;
}

//----- (000546C0) --------------------------------------------------------
int __fastcall log_to_miner(
        int message,
        int log_level,
        int src_line,
        int src_filename,
        int additional_message,
        int rotation_mode,
        int arg1,
        int arg2)
{
  int rotation_index; // r12
  const char *formatted_msg; // r6
  _DWORD *thread_log_buffer; // r11
  int global_buffer_version; // r0
  int event_alloc_result; // r0
  unsigned int config_reload_period; // r2
  _DWORD *new_thread_log_buffer; // r0
  int thread_specific_error; // r2
  int thread_specific_error_value; // [sp+24h] [bp-34h]

  LOBYTE(rotation_index) = rotation_mode & 7;
  if ( rotation_mode <= 0 )
    rotation_index = -(-rotation_mode & 7);
  if ( (((int)*(unsigned __int8 *)(dword_58DE10 + rotation_mode / 8 + 1032) >> (7 - rotation_index)) & 1) != 0 )
  {
    formatted_msg = (const char *)message;
    pthread_rwlock_rdlock(&stru_58DE1C);
    if ( !dword_58DE3C )
    {
      sub_5DF98(2, "src/zlog.c", 742, "never call zlog_init() or dzlog_init() before");
      return pthread_rwlock_unlock(&stru_58DE1C);
    }
    if ( dword_58DE10 )
    {
      thread_log_buffer = pthread_getspecific(dword_58DE08);
      global_buffer_version = dword_58DE18;
      if ( !thread_log_buffer )
      {
        new_thread_log_buffer = initialize_logging_thread(
                                  dword_58DE18,
                                  *(_DWORD *)(dword_99EEC8 + 1052),
                                  *(_DWORD *)(dword_99EEC8 + 1056),
                                  *(_DWORD *)(dword_99EEC8 + 9292));
        thread_log_buffer = new_thread_log_buffer;
        if ( !new_thread_log_buffer )
        {
          sub_5DF98(2, "src/zlog.c", 753, "zlog_thread_new fail");
          return pthread_rwlock_unlock(&stru_58DE1C);
        }
        thread_specific_error = pthread_setspecific(dword_58DE08, new_thread_log_buffer);
        if ( thread_specific_error )
        {
          thread_specific_error_value = thread_specific_error;
          release_thread_resources(thread_log_buffer);
          sub_5DF98(2, "src/zlog.c", 753, "pthread_setspecific fail, rd[%d]", thread_specific_error_value);
          return pthread_rwlock_unlock(&stru_58DE1C);
        }
        global_buffer_version = dword_58DE18;
      }
      if ( *thread_log_buffer != global_buffer_version )
      {
        event_alloc_result = rebuild_buffer_if_needed(
                               (int)thread_log_buffer,
                               *(_DWORD *)(dword_99EEC8 + 1052),
                               *(_DWORD *)(dword_99EEC8 + 1056));
        if ( event_alloc_result
          || (event_alloc_result = allocate_event_memory((int)thread_log_buffer, *(_DWORD *)(dword_99EEC8 + 9292))) != 0 )
        {
          sub_5DF98(2, "src/zlog.c", 753, "zlog_thread_resize_msg_buf fail, rd[%d]", event_alloc_result);
          return pthread_rwlock_unlock(&stru_58DE1C);
        }
        *thread_log_buffer = dword_58DE18;
      }
      fill_miner_config_buffer(
        (_DWORD *)thread_log_buffer[2],
        dword_58DE10,
        *(_DWORD *)(dword_58DE10 + 1028),
        (int)formatted_msg,
        log_level,
        src_line,
        src_filename,
        additional_message,
        rotation_mode,
        arg1,
        arg2);
      if ( update_miner_configurations(dword_58DE10, (int)thread_log_buffer) )
      {
        sub_5DF98(
          2,
          "src/zlog.c",
          761,
          "zlog_output fail, srcfile[%s], srcline[%ld]",
          formatted_msg,
          additional_message);
      }
      else
      {
        config_reload_period = *(_DWORD *)(dword_99EEC8 + 9276);
        if ( config_reload_period )
        {
          if ( config_reload_period < ++dword_58DE40 )
          {
            pthread_rwlock_unlock(&stru_58DE1C);
            message = reload_zlog_configuration((const char *)4294967295);
            if ( message )
              return sub_5DF98(
                       2,
                       "src/zlog.c",
                       778,
                       "reach reload-conf-period but zlog_reload fail, zlog-chk-conf [file] see detail");
            return message;
          }
        }
      }
    }
    else
    {
      sub_5DF98(
        2,
        "src/zlog.c",
        749,
        "zlog_default_category is null,dzlog_init() or dzlog_set_cateogry() is not called above");
    }
    return pthread_rwlock_unlock(&stru_58DE1C);
  }
  return message;
}
// 58DE08: using guessed type int dword_58DE08;
// 58DE10: using guessed type int dword_58DE10;
// 58DE18: using guessed type int dword_58DE18;
// 58DE3C: using guessed type int dword_58DE3C;
// 58DE40: using guessed type int dword_58DE40;
// 99EEC8: using guessed type int dword_99EEC8;

//----- (000549B8) --------------------------------------------------------
int __fastcall log_message_to_system(
        int log_return_value,
        int filename,
        int line_number,
        int message,
        int message_len,
        int thread_id,
        int category,
        int priority_level)
{
  int processed_tid; // r12
  const char *return_value_as_str; // r6
  _DWORD *thread_log_ptr; // r11
  int current_config; // r0
  int reinit_error_code; // r0
  unsigned int reload_threshold; // r2
  _DWORD *new_thread_log_ptr; // r0
  int thread_data_result; // r2
  int pthread_set_specific_error; // [sp+24h] [bp-34h]

  LOBYTE(processed_tid) = thread_id & 7;
  if ( thread_id <= 0 )
    processed_tid = -(-thread_id & 7);
  if ( (((int)*(unsigned __int8 *)(dword_58DE10 + thread_id / 8 + 1032) >> (7 - processed_tid)) & 1) != 0 )
  {
    return_value_as_str = (const char *)log_return_value;
    pthread_rwlock_rdlock(&stru_58DE1C);
    if ( !dword_58DE3C )
    {
      sub_5DF98(2, "src/zlog.c", 795, "never call zlog_init() or dzlog_init() before");
      return pthread_rwlock_unlock(&stru_58DE1C);
    }
    if ( dword_58DE10 )
    {
      thread_log_ptr = pthread_getspecific(dword_58DE08);
      current_config = dword_58DE18;
      if ( !thread_log_ptr )
      {
        new_thread_log_ptr = initialize_logging_thread(
                               dword_58DE18,
                               *(_DWORD *)(dword_99EEC8 + 1052),
                               *(_DWORD *)(dword_99EEC8 + 1056),
                               *(_DWORD *)(dword_99EEC8 + 9292));
        thread_log_ptr = new_thread_log_ptr;
        if ( !new_thread_log_ptr )
        {
          sub_5DF98(2, "src/zlog.c", 806, "zlog_thread_new fail");
          return pthread_rwlock_unlock(&stru_58DE1C);
        }
        thread_data_result = pthread_setspecific(dword_58DE08, new_thread_log_ptr);
        if ( thread_data_result )
        {
          pthread_set_specific_error = thread_data_result;
          release_thread_resources(thread_log_ptr);
          sub_5DF98(2, "src/zlog.c", 806, "pthread_setspecific fail, rd[%d]", pthread_set_specific_error);
          return pthread_rwlock_unlock(&stru_58DE1C);
        }
        current_config = dword_58DE18;
      }
      if ( *thread_log_ptr != current_config )
      {
        reinit_error_code = rebuild_buffer_if_needed(
                              (int)thread_log_ptr,
                              *(_DWORD *)(dword_99EEC8 + 1052),
                              *(_DWORD *)(dword_99EEC8 + 1056));
        if ( reinit_error_code
          || (reinit_error_code = allocate_event_memory((int)thread_log_ptr, *(_DWORD *)(dword_99EEC8 + 9292))) != 0 )
        {
          sub_5DF98(2, "src/zlog.c", 806, "zlog_thread_resize_msg_buf fail, rd[%d]", reinit_error_code);
          return pthread_rwlock_unlock(&stru_58DE1C);
        }
        *thread_log_ptr = dword_58DE18;
      }
      populate_miner_config(
        (_DWORD *)thread_log_ptr[2],
        dword_58DE10,
        *(_DWORD *)(dword_58DE10 + 1028),
        (int)return_value_as_str,
        filename,
        line_number,
        message,
        message_len,
        thread_id,
        category,
        priority_level);
      if ( update_miner_configurations(dword_58DE10, (int)thread_log_ptr) )
      {
        sub_5DF98(2, "src/zlog.c", 814, "zlog_output fail, srcfile[%s], srcline[%ld]", return_value_as_str, message_len);
      }
      else
      {
        reload_threshold = *(_DWORD *)(dword_99EEC8 + 9276);
        if ( reload_threshold )
        {
          if ( reload_threshold < ++dword_58DE40 )
          {
            pthread_rwlock_unlock(&stru_58DE1C);
            log_return_value = reload_zlog_configuration((const char *)4294967295);
            if ( log_return_value )
              return sub_5DF98(
                       2,
                       "src/zlog.c",
                       831,
                       "reach reload-conf-period but zlog_reload fail, zlog-chk-conf [file] see detail");
            return log_return_value;
          }
        }
      }
    }
    else
    {
      sub_5DF98(
        2,
        "src/zlog.c",
        802,
        "zlog_default_category is null,dzlog_init() or dzlog_set_cateogry() is not called above");
    }
    return pthread_rwlock_unlock(&stru_58DE1C);
  }
  return log_return_value;
}
// 58DE08: using guessed type int dword_58DE08;
// 58DE10: using guessed type int dword_58DE10;
// 58DE18: using guessed type int dword_58DE18;
// 58DE3C: using guessed type int dword_58DE3C;
// 58DE40: using guessed type int dword_58DE40;
// 99EEC8: using guessed type int dword_99EEC8;

//----- (00054CB0) --------------------------------------------------------
int log_event(
        int is_logging_enabled,
        const char *source_file,
        int line_number,
        int function_name_length,
        int event_timestamp_seconds,
        int event_timestamp_microseconds,
        int log_level,
        int event_message_length,
        ...)
{
  int logging_flag; // r10
  int log_level_bit_offset; // lr
  _DWORD *thread_specific_data; // r6
  int expected_category_version; // r0
  int resize_result; // r0
  unsigned int config_reload_period; // r2
  _DWORD *new_thread_data; // r0
  int set_specific_result; // r11
  va_list additional_args; // [sp+60h] [bp+10h] BYREF

  va_start(additional_args, event_message_length);
  logging_flag = is_logging_enabled;
  if ( !is_logging_enabled )
    goto LABEL_5;
  LOBYTE(log_level_bit_offset) = log_level & 7;
  if ( log_level <= 0 )
    log_level_bit_offset = -(-log_level & 7);
  if ( (((int)*(unsigned __int8 *)(is_logging_enabled + log_level / 8 + 1032) >> (7 - log_level_bit_offset)) & 1) != 0 )
  {
LABEL_5:
    pthread_rwlock_rdlock(&stru_58DE1C);
    if ( !dword_58DE3C )
    {
      sub_5DF98(2, "src/zlog.c", 850, "never call zlog_init() or dzlog_init() before");
      return pthread_rwlock_unlock(&stru_58DE1C);
    }
    thread_specific_data = pthread_getspecific(dword_58DE08);
    expected_category_version = dword_58DE18;
    if ( !thread_specific_data )
    {
      new_thread_data = initialize_logging_thread(
                          dword_58DE18,
                          *(_DWORD *)(dword_99EEC8 + 1052),
                          *(_DWORD *)(dword_99EEC8 + 1056),
                          *(_DWORD *)(dword_99EEC8 + 9292));
      thread_specific_data = new_thread_data;
      if ( !new_thread_data )
      {
        sub_5DF98(2, "src/zlog.c", 854, "zlog_thread_new fail");
        return pthread_rwlock_unlock(&stru_58DE1C);
      }
      set_specific_result = pthread_setspecific(dword_58DE08, new_thread_data);
      if ( set_specific_result )
      {
        release_thread_resources(thread_specific_data);
        sub_5DF98(2, "src/zlog.c", 854, "pthread_setspecific fail, rd[%d]", set_specific_result);
        return pthread_rwlock_unlock(&stru_58DE1C);
      }
      expected_category_version = dword_58DE18;
    }
    if ( *thread_specific_data != expected_category_version )
    {
      resize_result = rebuild_buffer_if_needed(
                        (int)thread_specific_data,
                        *(_DWORD *)(dword_99EEC8 + 1052),
                        *(_DWORD *)(dword_99EEC8 + 1056));
      if ( resize_result
        || (resize_result = allocate_event_memory((int)thread_specific_data, *(_DWORD *)(dword_99EEC8 + 9292))) != 0 )
      {
        sub_5DF98(2, "src/zlog.c", 854, "zlog_thread_resize_msg_buf fail, rd[%d]", resize_result);
        return pthread_rwlock_unlock(&stru_58DE1C);
      }
      *thread_specific_data = dword_58DE18;
    }
    fill_miner_config_buffer(
      (_DWORD *)thread_specific_data[2],
      logging_flag,
      *(_DWORD *)(logging_flag + 1028),
      (int)source_file,
      line_number,
      function_name_length,
      event_timestamp_seconds,
      event_timestamp_microseconds,
      log_level,
      event_message_length,
      (int)additional_args);
    if ( update_miner_configurations(logging_flag, (int)thread_specific_data) )
    {
      sub_5DF98(
        2,
        "src/zlog.c",
        861,
        "zlog_output fail, srcfile[%s], srcline[%ld]",
        source_file,
        event_timestamp_microseconds);
      return pthread_rwlock_unlock(&stru_58DE1C);
    }
    config_reload_period = *(_DWORD *)(dword_99EEC8 + 9276);
    if ( !config_reload_period )
      return pthread_rwlock_unlock(&stru_58DE1C);
    if ( config_reload_period >= ++dword_58DE40 )
      return pthread_rwlock_unlock(&stru_58DE1C);
    pthread_rwlock_unlock(&stru_58DE1C);
    is_logging_enabled = reload_zlog_configuration((const char *)4294967295);
    if ( is_logging_enabled )
      return sub_5DF98(
               2,
               "src/zlog.c",
               880,
               "reach reload-conf-period but zlog_reload fail, zlog-chk-conf [file] see detail");
  }
  return is_logging_enabled;
}
// 58DE08: using guessed type int dword_58DE08;
// 58DE18: using guessed type int dword_58DE18;
// 58DE3C: using guessed type int dword_58DE3C;
// 58DE40: using guessed type int dword_58DE40;
// 99EEC8: using guessed type int dword_99EEC8;

//----- (00054F58) --------------------------------------------------------
int process_log_message(
        const char *log_message,
        int log_message_length,
        int seconds_since_epoch,
        int microseconds_part,
        int thread_identifier,
        int log_level,
        int source_line_number,
        ...)
{
  int offset_log_level; // r3
  int reload_configuration_result; // r0
  _DWORD *thread_log_event_ptr; // r10
  int expected_magic_number; // r0
  int buffer_allocation_status; // r0
  unsigned int reconfiguration_interval; // r2
  _DWORD *new_thread_log_event_ptr; // r0
  int thread_specific_set_result; // r11
  va_list variable_argument_list; // [sp+5Ch] [bp+Ch] BYREF

  va_start(variable_argument_list, source_line_number);
  pthread_rwlock_rdlock(&stru_58DE1C);
  if ( !dword_58DE3C )
  {
    sub_5DF98(2, "src/zlog.c", 896, "never call zlog_init() or dzlog_init() before");
    return pthread_rwlock_unlock(&stru_58DE1C);
  }
  if ( !dword_58DE10 )
  {
    sub_5DF98(
      2,
      "src/zlog.c",
      903,
      "zlog_default_category is null,dzlog_init() or dzlog_set_cateogry() is not called above");
    return pthread_rwlock_unlock(&stru_58DE1C);
  }
  LOBYTE(offset_log_level) = log_level & 7;
  if ( log_level <= 0 )
    offset_log_level = -(-log_level & 7);
  if ( (((int)*(unsigned __int8 *)(dword_58DE10 + log_level / 8 + 1032) >> (7 - offset_log_level)) & 1) == 0 )
    return pthread_rwlock_unlock(&stru_58DE1C);
  thread_log_event_ptr = pthread_getspecific(dword_58DE08);
  expected_magic_number = dword_58DE18;
  if ( !thread_log_event_ptr )
  {
    new_thread_log_event_ptr = initialize_logging_thread(
                                 dword_58DE18,
                                 *(_DWORD *)(dword_99EEC8 + 1052),
                                 *(_DWORD *)(dword_99EEC8 + 1056),
                                 *(_DWORD *)(dword_99EEC8 + 9292));
    thread_log_event_ptr = new_thread_log_event_ptr;
    if ( !new_thread_log_event_ptr )
    {
      sub_5DF98(2, "src/zlog.c", 909, "zlog_thread_new fail");
      return pthread_rwlock_unlock(&stru_58DE1C);
    }
    thread_specific_set_result = pthread_setspecific(dword_58DE08, new_thread_log_event_ptr);
    if ( thread_specific_set_result )
    {
      release_thread_resources(thread_log_event_ptr);
      sub_5DF98(2, "src/zlog.c", 909, "pthread_setspecific fail, rd[%d]", thread_specific_set_result);
      return pthread_rwlock_unlock(&stru_58DE1C);
    }
    expected_magic_number = dword_58DE18;
  }
  if ( *thread_log_event_ptr != expected_magic_number )
  {
    buffer_allocation_status = rebuild_buffer_if_needed(
                                 (int)thread_log_event_ptr,
                                 *(_DWORD *)(dword_99EEC8 + 1052),
                                 *(_DWORD *)(dword_99EEC8 + 1056));
    if ( !buffer_allocation_status )
    {
      buffer_allocation_status = allocate_event_memory((int)thread_log_event_ptr, *(_DWORD *)(dword_99EEC8 + 9292));
      if ( !buffer_allocation_status )
      {
        *thread_log_event_ptr = dword_58DE18;
        goto LABEL_13;
      }
    }
    sub_5DF98(2, "src/zlog.c", 909, "zlog_thread_resize_msg_buf fail, rd[%d]", buffer_allocation_status);
    return pthread_rwlock_unlock(&stru_58DE1C);
  }
LABEL_13:
  fill_miner_config_buffer(
    (_DWORD *)thread_log_event_ptr[2],
    dword_58DE10,
    *(_DWORD *)(dword_58DE10 + 1028),
    (int)log_message,
    log_message_length,
    seconds_since_epoch,
    microseconds_part,
    thread_identifier,
    log_level,
    source_line_number,
    (int)variable_argument_list);
  if ( update_miner_configurations(dword_58DE10, (int)thread_log_event_ptr) )
  {
    sub_5DF98(2, "src/zlog.c", 918, "zlog_output fail, srcfile[%s], srcline[%ld]", log_message, thread_identifier);
    return pthread_rwlock_unlock(&stru_58DE1C);
  }
  reconfiguration_interval = *(_DWORD *)(dword_99EEC8 + 9276);
  if ( !reconfiguration_interval )
    return pthread_rwlock_unlock(&stru_58DE1C);
  if ( reconfiguration_interval >= ++dword_58DE40 )
    return pthread_rwlock_unlock(&stru_58DE1C);
  pthread_rwlock_unlock(&stru_58DE1C);
  reload_configuration_result = reload_zlog_configuration((const char *)4294967295);
  if ( reload_configuration_result )
    return sub_5DF98(
             2,
             "src/zlog.c",
             937,
             "reach reload-conf-period but zlog_reload fail, zlog-chk-conf [file] see detail");
  return reload_configuration_result;
}
// 58DE08: using guessed type int dword_58DE08;
// 58DE10: using guessed type int dword_58DE10;
// 58DE18: using guessed type int dword_58DE18;
// 58DE3C: using guessed type int dword_58DE3C;
// 58DE40: using guessed type int dword_58DE40;
// 99EEC8: using guessed type int dword_99EEC8;

//----- (0005521C) --------------------------------------------------------
int log_current_config_status()
{
  int lock_result; // r0
  int unlock_result; // r0

  lock_result = pthread_rwlock_rdlock(&stru_58DE1C);
  if ( lock_result )
    return sub_5DF98(2, "src/zlog.c", 948, "pthread_rwlock_wrlock fail, rc[%d]", lock_result);
  sub_5DF98(1, "src/zlog.c", 951, "------zlog_profile start------ ");
  sub_5DF98(1, "src/zlog.c", 952, "is init:[%d]", dword_58DE3C);
  sub_5DF98(1, "src/zlog.c", 953, "init version:[%d]", dword_58DE18);
  print_configuration(dword_99EEC8, 1);
  validate_and_log_records((const void *)dword_58DE14, 1);
  process_all_active_categories((const void *)dword_58DE0C, 1);
  if ( dword_58DE10 )
  {
    sub_5DF98(1, "src/zlog.c", 958, "-default_category-");
    process_category((const void **)dword_58DE10, 1);
  }
  sub_5DF98(1, "src/zlog.c", 961, "------zlog_profile end------ ");
  unlock_result = pthread_rwlock_unlock(&stru_58DE1C);
  if ( unlock_result )
    return sub_5DF98(2, "src/zlog.c", 964, "pthread_rwlock_unlock fail, rc=[%d]", unlock_result);
  return unlock_result;
}
// 58DE0C: using guessed type int dword_58DE0C;
// 58DE10: using guessed type int dword_58DE10;
// 58DE14: using guessed type int dword_58DE14;
// 58DE18: using guessed type int dword_58DE18;
// 58DE3C: using guessed type int dword_58DE3C;
// 99EEC8: using guessed type int dword_99EEC8;

//----- (00055388) --------------------------------------------------------
int __fastcall add_log_record(const char *record_name, int record_output_size)
{
  int write_lock_result; // r0
  int v5; // r6
  int unlock_result; // r0
  _DWORD *log_record_ptr; // r0
  void *log_record_instance; // r5
  _DWORD *worker_details; // r3
  int worker_index; // r5
  int task_id; // r0

  if ( record_name )
  {
    if ( record_output_size )
    {
      write_lock_result = pthread_rwlock_wrlock(&stru_58DE1C);
      if ( write_lock_result )
      {
        v5 = -1;
        sub_5DF98(2, "src/zlog.c", 983, "pthread_rwlock_rdlock fail, rd[%d]", write_lock_result);
      }
      else
      {
        v5 = dword_58DE3C;
        if ( dword_58DE3C )
        {
          log_record_ptr = create_log_record(record_name, record_output_size);
          log_record_instance = log_record_ptr;
          if ( log_record_ptr )
          {
            v5 = update_or_add_to_hashtable(dword_58DE14, (int)log_record_ptr, (int)log_record_ptr);
            if ( v5 )
            {
              delete_log_record(log_record_instance);
              sub_5DF98(2, "src/zlog.c", 1002, "zc_hashtable_put fail");
            }
            else
            {
              worker_details = *(_DWORD **)(dword_99EEC8 + 9288);
              if ( (int)worker_details[1] > 0 )
              {
                worker_index = 0;
                do
                {
                  task_id = *(_DWORD *)(*worker_details + 4 * worker_index++);
                  check_and_process_task(task_id, dword_58DE14);
                  worker_details = *(_DWORD **)(dword_99EEC8 + 9288);
                }
                while ( worker_details[1] > worker_index );
              }
            }
          }
          else
          {
            sub_5DF98(2, "src/zlog.c", 995, "zlog_record_new fail");
            v5 = -1;
          }
        }
        else
        {
          sub_5DF98(2, "src/zlog.c", 988, "never call zlog_init() or dzlog_init() before");
        }
        unlock_result = pthread_rwlock_unlock(&stru_58DE1C);
        if ( unlock_result )
        {
          v5 = -1;
          sub_5DF98(2, "src/zlog.c", 1013, "pthread_rwlock_unlock fail, rd=[%d]", unlock_result);
        }
      }
    }
    else
    {
      sub_5DF98(2, "src/zlog.c", 979, "record_output is null or 0");
      return -1;
    }
  }
  else
  {
    sub_5DF98(2, "src/zlog.c", 978, "rname is null or 0");
    return -1;
  }
  return v5;
}
// 58DE14: using guessed type int dword_58DE14;
// 58DE3C: using guessed type int dword_58DE3C;
// 99EEC8: using guessed type int dword_99EEC8;

//----- (00055568) --------------------------------------------------------
int __fastcall read_bit_from_data(int data_ptr, int bit_index)
{
  int adjusted_index; // r2
  int bit_offset; // r3
  bool negative_flag; // nf
  int negated_index; // r1
  int negated_offset; // r1
  int byte_value; // r0

  if ( data_ptr )
  {
    adjusted_index = bit_index + 7;
    if ( bit_index >= 0 )
      adjusted_index = bit_index;
    LOBYTE(bit_offset) = bit_index & 7;
    negated_index = -bit_index;
    negative_flag = negated_index < 0;
    negated_offset = negated_index & 7;
    byte_value = *(unsigned __int8 *)(data_ptr + (adjusted_index >> 3) + 1032);
    if ( !negative_flag )
      bit_offset = -negated_offset;
    return (byte_value >> (7 - bit_offset)) & 1;
  }
  return data_ptr;
}

//----- (000555A4) --------------------------------------------------------
const char *get_firmware_version()
{
  return "1.2.12";
}

//----- (000555B0) --------------------------------------------------------
int __fastcall process_matching_rules(int category_context, _DWORD *rule_ptrs, int *rule_count)
{
  _DWORD *data_ptr; // r0
  _DWORD *array_list; // r0
  int wastebin_rule; // r5
  int rule_index; // r6
  int match_count; // r10
  _BYTE *current_rule_data; // r4
  _BYTE *category_bitmap_ptr; // r3
  _BYTE *current_rule_bitmap; // r0
  char bitmap_data; // r1
  char temp_bitmap_data; // t1
  char rule_bitmap_data; // t1
  int result; // r0
  int wastebin_rule_bitmap; // r5
  _BYTE *target_bitmap_ptr; // r3
  _BYTE *target_bitmap_end; // r7
  char target_bitmap_data; // r2
  char temp_target_bitmap_data; // t1
  char wastebin_bitmap_data; // t1

  data_ptr = *(_DWORD **)(category_context + 1096);
  if ( data_ptr )
    process_and_free_resources(data_ptr);
  memset((void *)(category_context + 1032), 0, 32u);
  array_list = initialize_array_list(0);
  *(_DWORD *)(category_context + 1096) = array_list;
  if ( !array_list )
  {
    sub_5DF98(2, "src/category.c", 72, "zc_arraylist_new fail");
    return -1;
  }
  if ( *rule_count <= 0 )
    goto LABEL_23;
  wastebin_rule = 0;
  rule_index = 0;
  match_count = 0;
  do
  {
    current_rule_data = *(_BYTE **)(*rule_ptrs + 4 * rule_index);
    if ( check_matching_rule((int)current_rule_data, (char *)category_context) )
    {
      if ( invoke_custom_subroutine(*(_DWORD *)(category_context + 1096), (int)current_rule_data) )
      {
        sub_5DF98(2, "src/category.c", 81, "zc_arrylist_add fail");
LABEL_22:
        process_and_free_resources(*(_DWORD **)(category_context + 1096));
        result = -1;
        *(_DWORD *)(category_context + 1096) = 0;
        return result;
      }
      category_bitmap_ptr = (_BYTE *)(category_context + 1031);
      current_rule_bitmap = current_rule_data + 4103;
      do
      {
        temp_bitmap_data = *++category_bitmap_ptr;
        bitmap_data = temp_bitmap_data;
        rule_bitmap_data = *++current_rule_bitmap;
        *category_bitmap_ptr = bitmap_data | rule_bitmap_data;
      }
      while ( category_bitmap_ptr != (_BYTE *)(category_context + 1063) );
      ++match_count;
    }
    ++rule_index;
    if ( is_bmr_rule_valid(current_rule_data) )
      wastebin_rule = (int)current_rule_data;
  }
  while ( rule_index < *rule_count );
  if ( match_count )
    return 0;
  if ( !wastebin_rule )
  {
LABEL_23:
    sub_5DF98(
      0,
      "src/category.c",
      103,
      "category[%s], no match rules & no wastebin_rule",
      (const char *)category_context);
    return 0;
  }
  sub_5DF98(0, "src/category.c", 95, "category[%s], no match rules, use wastebin_rule", (const char *)category_context);
  if ( invoke_custom_subroutine(*(_DWORD *)(category_context + 1096), wastebin_rule) )
  {
    sub_5DF98(2, "src/category.c", 97, "zc_arrylist_add fail");
    goto LABEL_22;
  }
  wastebin_rule_bitmap = wastebin_rule + 4103;
  target_bitmap_ptr = (_BYTE *)(category_context + 1031);
  target_bitmap_end = (_BYTE *)(category_context + 1063);
  do
  {
    temp_target_bitmap_data = *++target_bitmap_ptr;
    target_bitmap_data = temp_target_bitmap_data;
    wastebin_bitmap_data = *(_BYTE *)++wastebin_rule_bitmap;
    *target_bitmap_ptr = target_bitmap_data | wastebin_bitmap_data;
  }
  while ( target_bitmap_end != target_bitmap_ptr );
  return 0;
}

//----- (000557C4) --------------------------------------------------------
int __fastcall process_category(const void **category_structure, int log_level)
{
  int result; // r0
  _DWORD *category_data; // r3
  int index; // r4
  int category_entry; // r0

  if ( !category_structure )
    return sub_5DF98(2, "src/category.c", 22, "a_category is null or 0");
  result = sub_5DF98(
             log_level,
             "src/category.c",
             26,
             "--category[%p][%s][%p]--",
             category_structure,
             (const char *)category_structure,
             category_structure[274]);
  category_data = category_structure[274];
  if ( category_data && (int)category_data[1] > 0 )
  {
    index = 0;
    do
    {
      category_entry = *(_DWORD *)(*category_data + 4 * index++);
      result = log_rule_information(category_entry, log_level);
      category_data = category_structure[274];
    }
    while ( category_data[1] > index );
  }
  return result;
}

//----- (00055870) --------------------------------------------------------
void __fastcall delete_category(_DWORD *category_ptr)
{
  _DWORD *resource_ptr; // r0

  if ( category_ptr )
  {
    resource_ptr = (_DWORD *)category_ptr[274];
    if ( resource_ptr )
      process_and_free_resources(resource_ptr);
    sub_5DF98(0, "src/category.c", 40, "zlog_category_del[%p]", category_ptr);
    free(category_ptr);
  }
  else
  {
    sub_5DF98(2, "src/category.c", 38, "a_category is null or 0");
  }
}

//----- (000558E4) --------------------------------------------------------
int __fastcall create_category(const char *name, _DWORD *rules)
{
  size_t name_length; // r6
  void *category_memory; // r0
  int category_ptr; // r4
  _DWORD *delete_target; // r0
  int *errno_ptr; // r0

  if ( name )
  {
    if ( rules )
    {
      name_length = strlen(name);
      if ( name_length > 1024 )
      {
        category_ptr = 0;
        sub_5DF98(2, "src/category.c", 124, "name[%s] too long", name);
      }
      else
      {
        category_memory = calloc(1u, 1104u);
        category_ptr = (int)category_memory;
        if ( category_memory )
        {
          memcpy(category_memory, name, name_length + 1);
          *(_DWORD *)(category_ptr + 1028) = name_length;
          if ( process_matching_rules(category_ptr, rules, rules + 1) )
          {
            sub_5DF98(2, "src/category.c", 135, "zlog_category_fit_rules fail");
            delete_target = (_DWORD *)category_ptr;
            category_ptr = 0;
            delete_category(delete_target);
          }
          else
          {
            process_category((const void **)category_ptr, 0);
          }
        }
        else
        {
          errno_ptr = _errno_location();
          sub_5DF98(2, "src/category.c", 129, "calloc fail, errno[%d]", *errno_ptr);
        }
      }
    }
    else
    {
      category_ptr = 0;
      sub_5DF98(2, "src/category.c", 120, "rules is null or 0");
    }
  }
  else
  {
    category_ptr = 0;
    sub_5DF98(2, "src/category.c", 119, "name is null or 0");
  }
  return category_ptr;
}

//----- (00055A28) --------------------------------------------------------
int __fastcall update_miner_processing_rules(_DWORD *miner_rules, _DWORD *new_rules)
{
  _DWORD *current_process_ptr; // r0
  int saved_val_259; // r7
  int saved_val_260; // r6
  int saved_val_261; // lr
  int saved_val_274; // r2
  int saved_val_262; // r0
  int saved_val_263; // r7
  int saved_val_264; // r6
  int saved_val_265; // lr
  int update_result; // r0

  if ( miner_rules )
  {
    if ( new_rules )
    {
      current_process_ptr = (_DWORD *)miner_rules[275];
      if ( current_process_ptr )
        process_and_free_resources(current_process_ptr);
      saved_val_259 = miner_rules[259];
      saved_val_260 = miner_rules[260];
      saved_val_261 = miner_rules[261];
      saved_val_274 = miner_rules[274];
      miner_rules[266] = miner_rules[258];
      miner_rules[267] = saved_val_259;
      saved_val_262 = miner_rules[262];
      miner_rules[268] = saved_val_260;
      miner_rules[269] = saved_val_261;
      saved_val_263 = miner_rules[263];
      saved_val_264 = miner_rules[264];
      saved_val_265 = miner_rules[265];
      miner_rules[275] = saved_val_274;
      miner_rules[270] = saved_val_262;
      miner_rules[274] = 0;
      miner_rules[271] = saved_val_263;
      miner_rules[272] = saved_val_264;
      miner_rules[273] = saved_val_265;
      update_result = process_matching_rules((int)miner_rules, new_rules, new_rules + 1);
      if ( update_result )
      {
        sub_5DF98(2, "src/category.c", 163, "zlog_category_obtain_rules fail");
        update_result = -1;
        miner_rules[274] = 0;
      }
    }
    else
    {
      sub_5DF98(2, "src/category.c", 151, "new_rules is null or 0");
      return -1;
    }
  }
  else
  {
    sub_5DF98(2, "src/category.c", 150, "a_category is null or 0");
    return -1;
  }
  return update_result;
}

//----- (00055B28) --------------------------------------------------------
void *__fastcall free_fit_rules_backup(int category_ptr)
{
  _DWORD *fit_rules_backup; // r0

  if ( !category_ptr )
    return (void *)sub_5DF98(2, "src/category.c", 176, "a_category is null or 0");
  fit_rules_backup = *(_DWORD **)(category_ptr + 1100);
  if ( !fit_rules_backup )
    return (void *)sub_5DF98(1, "src/category.c", 178, "a_category->fit_rules_backup is NULL, never update before");
  process_and_free_resources(fit_rules_backup);
  *(_DWORD *)(category_ptr + 1100) = 0;
  return memset((void *)(category_ptr + 1064), 0, 32u);
}

//----- (00055BA0) --------------------------------------------------------
void *__fastcall update_category_rules(_DWORD *category)
{
  int fit_rules_backup; // r3
  _DWORD *current_rules; // r0
  int temp; // r3
  int original_value_259; // r6
  int original_value_260; // r5
  int original_value_261; // lr
  int original_value_263; // r6
  int original_value_264; // r5
  int original_value_265; // lr

  if ( !category )
    return (void *)sub_5DF98(2, "src/category.c", 194, "a_category is null or 0");
  fit_rules_backup = category[275];
  if ( !fit_rules_backup )
    return (void *)sub_5DF98(1, "src/category.c", 196, "a_category->fit_rules_backup in NULL, never update before");
  current_rules = (_DWORD *)category[274];
  if ( current_rules )
  {
    process_and_free_resources(current_rules);
    temp = category[275];
    category[275] = 0;
    category[274] = temp;
  }
  else
  {
    category[274] = fit_rules_backup;
    category[275] = 0;
  }
  original_value_259 = category[267];
  original_value_260 = category[268];
  original_value_261 = category[269];
  category[258] = category[266];
  category[259] = original_value_259;
  category[260] = original_value_260;
  category[261] = original_value_261;
  original_value_263 = category[271];
  original_value_264 = category[272];
  original_value_265 = category[273];
  category[262] = category[270];
  category[263] = original_value_263;
  category[264] = original_value_264;
  category[265] = original_value_265;
  return memset(category + 266, 0, 32u);
}

//----- (00055C7C) --------------------------------------------------------
int __fastcall update_miner_configurations(int miner_device, int config_data)
{
  _DWORD *config_array_ptr; // r3
  int config_index; // r4
  int config_option; // r0
  int update_result; // r0

  config_array_ptr = *(_DWORD **)(miner_device + 1096);
  if ( (int)config_array_ptr[1] <= 0 )
    return 0;
  config_index = 0;
  do
  {
    config_option = *(_DWORD *)(*config_array_ptr + 4 * config_index++);
    update_result = check_condition(config_option, config_data);
    config_array_ptr = *(_DWORD **)(miner_device + 1096);
  }
  while ( config_array_ptr[1] > config_index );
  return update_result;
}

//----- (00055CCC) --------------------------------------------------------
int __fastcall process_all_active_categories(const void *category_table, int log_level)
{
  int current_category_id; // r0
  int iterator; // r4

  if ( !category_table )
    return sub_5DF98(2, "src/category_table.c", 21, "categories is null or 0");
  sub_5DF98(log_level, "src/category_table.c", 22, "-category_table[%p]-", category_table);
  current_category_id = get_first_non_zero_value((int)category_table);
  for ( iterator = current_category_id; current_category_id; iterator = current_category_id )
  {
    process_category(*(const void ***)(iterator + 8), log_level);
    current_category_id = get_next_active_value((int)category_table, (unsigned int *)iterator);
  }
  return current_category_id;
}

//----- (00055D5C) --------------------------------------------------------
int __fastcall delete_category_table(_DWORD *category_table)
{
  if ( !category_table )
    return sub_5DF98(2, "src/category_table.c", 34, "categories is null or 0");
  free_hashtable(category_table);
  return sub_5DF98(0, "src/category_table.c", 36, "zlog_category_table_del[%p]", category_table);
}

//----- (00055DB8) --------------------------------------------------------
_DWORD *create_category_hashtable()
{
  _DWORD *hashtable_ptr; // r0
  _DWORD *category_hashtable; // r4

  hashtable_ptr = initialize_hashtable(20u, (int)generate_hash, (int)are_strings_equal, 0, (int)delete_category);
  category_hashtable = hashtable_ptr;
  if ( hashtable_ptr )
    process_all_active_categories(hashtable_ptr, 0);
  else
    sub_5DF98(2, "src/category_table.c", 49, "zc_hashtable_new fail");
  return category_hashtable;
}

//----- (00055E24) --------------------------------------------------------
int __fastcall update_rules_with_rollback(int categories, _DWORD *rule)
{
  unsigned int first_non_zero_value; // r4

  if ( categories )
  {
    first_non_zero_value = get_first_non_zero_value(categories);
    if ( first_non_zero_value )
    {
      while ( !update_miner_processing_rules(*(_DWORD **)(first_non_zero_value + 8), rule) )
      {
        first_non_zero_value = get_next_active_value(categories, (unsigned int *)first_non_zero_value);
        if ( !first_non_zero_value )
          return 0;
      }
      sub_5DF98(2, "src/category_table.c", 66, "zlog_category_update_rules fail, try rollback");
      return -1;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    sub_5DF98(2, "src/category_table.c", 62, "categories is null or 0");
    return -1;
  }
}

//----- (00055EBC) --------------------------------------------------------
int __fastcall clear_categories(int categories_ptr)
{
  int iterator_result; // r0
  int current_category; // r4

  if ( !categories_ptr )
    return sub_5DF98(2, "src/category_table.c", 78, "categories is null or 0");
  iterator_result = get_first_non_zero_value(categories_ptr);
  for ( current_category = iterator_result; iterator_result; current_category = iterator_result )
  {
    free_fit_rules_backup(*(_DWORD *)(current_category + 8));
    iterator_result = get_next_active_value(categories_ptr, (unsigned int *)current_category);
  }
  return iterator_result;
}

//----- (00055F14) --------------------------------------------------------
int __fastcall process_category_table(int category_table)
{
  int processing_result; // r0
  int current_index; // r4

  if ( !category_table )
    return sub_5DF98(2, "src/category_table.c", 91, "categories is null or 0");
  processing_result = get_first_non_zero_value(category_table);
  for ( current_index = processing_result; processing_result; current_index = processing_result )
  {
    update_category_rules(*(_DWORD **)(current_index + 8));
    processing_result = get_next_active_value(category_table, (unsigned int *)current_index);
  }
  return processing_result;
}

//----- (00055F6C) --------------------------------------------------------
_DWORD *__fastcall add_category_to_task(int task_id, const char *category_name, _DWORD *category_data)
{
  int operation_result; // r4
  _DWORD *new_category_ptr; // r6

  if ( task_id )
  {
    operation_result = process_task(task_id, (int)category_name);
    if ( !operation_result )
    {
      new_category_ptr = (_DWORD *)create_category(category_name, category_data);
      if ( new_category_ptr )
      {
        if ( update_or_add_to_hashtable(task_id, (int)new_category_ptr, (int)new_category_ptr) )
        {
          sub_5DF98(2, "src/category_table.c", 119, "zc_hashtable_put fail");
          delete_category(new_category_ptr);
        }
        else
        {
          return new_category_ptr;
        }
      }
      else
      {
        sub_5DF98(2, "src/category_table.c", 114, "zc_category_new fail");
      }
    }
  }
  else
  {
    operation_result = 0;
    sub_5DF98(2, "src/category_table.c", 105, "categories is null or 0");
  }
  return (_DWORD *)operation_result;
}

//----- (00056030) --------------------------------------------------------
int __fastcall parse_config_file(int config_dir_path)
{
  FILE *config_file_ptr; // r7
  int config_line_number; // r4
  char *config_line; // r10
  int config_line_offset; // r5
  size_t length_last_line; // r0
  int first_char; // r11
  const unsigned __int16 **ctype_ptr; // r0
  char *iter_char_ptr; // r2
  const unsigned __int16 *ctype_array; // r9
  int next_char; // t1
  int num_spaces; // r3
  char current_char; // r1
  char *end_of_line_ptr; // r3
  char *iter_copy_ptr; // r0
  int copy_next_char; // t1
  char *line_end_ptr; // r10
  int last_char_val; // r2
  unsigned __int8 *iter_trim_ptr; // r3
  int prev_trim_char; // t1
  int line_first_char; // r3
  int quotation_mark_count; // r1
  char *line_iter_ptr; // r2
  int next_line_char; // t1
  size_t current_line_length; // r0
  unsigned __int8 *rule_ptr; // r10
  char *format_str_ptr; // r0
  char *format_ptr; // r5
  unsigned int reload_conf_period; // r3
  pthread_mutex_t *mutex_file_ptr; // r0
  char *default_format_ptr; // r0
  int compare_rotate_lock_file; // r3
  char *rotate_lock_file_ptr; // r0
  int *errno_ptr; // r0
  char *original_config_line; // [sp+0h] [bp-60F8h]
  int placeholder_var; // [sp+4h] [bp-60F4h]
  int config_section; // [sp+10h] [bp-60E8h]
  int status; // [sp+14h] [bp-60E4h]
  const char **format_list_ptr; // [sp+18h] [bp-60E0h]
  int parsed_len; // [sp+20h] [bp-60D8h] BYREF
  struct tm time_info; // [sp+24h] [bp-60D4h] BYREF
  char stat_buf[80]; // [sp+50h] [bp-60A8h] BYREF
  time_t current_time; // [sp+A0h] [bp-6058h] BYREF
  char line_buffer[4100]; // [sp+B8h] [bp-6040h] BYREF
  char parsed_name[4100]; // [sp+10BCh] [bp-503Ch] BYREF
  char key_name[4100]; // [sp+20C0h] [bp-4038h] BYREF
  char key_modifier[4100]; // [sp+30C4h] [bp-3034h] BYREF
  char key_modifier_next[4100]; // [sp+40C8h] [bp-2030h] BYREF
  char key_value_buffer[4140]; // [sp+50CCh] [bp-102Ch] BYREF

  status = _lxstat64(3, config_dir_path, stat_buf);
  if ( status )
  {
    errno_ptr = _errno_location();
    status = -1;
    sub_5DF98(2, "src/conf.c", 238, "lstat conf file[%s] fail, errno[%d]", (const char *)config_dir_path, *errno_ptr);
    return status;
  }
  localtime_r(&current_time, &time_info);
  strftime((char *)(config_dir_path + 1025), 21u, "%F %T", &time_info);
  config_file_ptr = (FILE *)fopen64(config_dir_path, "r");
  if ( !config_file_ptr )
  {
    status = -1;
    sub_5DF98(2, "src/conf.c", 245, "open configure file[%s] fail", (const char *)config_dir_path);
    return status;
  }
  config_line_number = 0;
  memset(line_buffer, 0, 4097u);
  config_line = line_buffer;
  config_line_offset = 0;
  format_list_ptr = (const char **)(config_dir_path + 9292);
  for ( config_section = 0; ; config_section = 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
LABEL_4:
        if ( !fgets(config_line, 4097 - config_line_offset, config_file_ptr) )
          goto LABEL_38;
        ++config_line_number;
        length_last_line = strlen(config_line) - 1;
        if ( config_line[length_last_line] == 10 )
          config_line[length_last_line] = 0;
        first_char = (unsigned __int8)*config_line;
        if ( *config_line )
        {
          ctype_ptr = _ctype_b_loc();
          iter_char_ptr = config_line;
          ctype_array = *ctype_ptr;
          while ( 1 )
          {
            num_spaces = ctype_array[first_char] & 0x2000;
            if ( (ctype_array[first_char] & 0x2000) == 0 )
              break;
            next_char = (unsigned __int8)*++iter_char_ptr;
            first_char = next_char;
            if ( !next_char )
              goto LABEL_4;
          }
          if ( first_char != 35 )
            break;
        }
      }
      current_char = *iter_char_ptr;
      if ( *iter_char_ptr )
      {
        iter_copy_ptr = config_line - 1;
        do
        {
          *++iter_copy_ptr = current_char;
          ++num_spaces;
          copy_next_char = (unsigned __int8)*++iter_char_ptr;
          current_char = copy_next_char;
        }
        while ( copy_next_char );
        end_of_line_ptr = &config_line[num_spaces];
      }
      else
      {
        end_of_line_ptr = config_line;
      }
      *end_of_line_ptr = 0;
      for ( line_end_ptr = &config_line[strlen(config_line) - 1]; ; --line_end_ptr )
      {
        iter_trim_ptr = (unsigned __int8 *)(line_end_ptr - 1);
        last_char_val = (unsigned __int8)*line_end_ptr;
        if ( (ctype_array[last_char_val] & 0x2000) == 0 )
          break;
      }
      if ( last_char_val != 92 || line_end_ptr - line_buffer > 4066 )
        break;
      if ( (ctype_array[(unsigned __int8)*(line_end_ptr - 1)] & 0x2000) != 0 )
      {
        do
          prev_trim_char = *--iter_trim_ptr;
        while ( (ctype_array[prev_trim_char] & 0x2000) != 0 );
      }
      config_line = (char *)(iter_trim_ptr + 1);
      config_line_offset = iter_trim_ptr + 1 - (unsigned __int8 *)line_buffer;
      iter_trim_ptr[1] = 0;
    }
    line_first_char = (unsigned __int8)line_buffer[0];
    quotation_mark_count = 0;
    line_end_ptr[1] = 0;
    if ( line_first_char )
      break;
    current_line_length = strlen(line_buffer);
    if ( current_line_length > 4096 )
      goto LABEL_97;
LABEL_35:
    switch ( config_section )
    {
      case 1:
        memset(parsed_name, 0, 4097u);
        memset(key_value_buffer, 0, 4097u);
        if ( _isoc99_sscanf(line_buffer, " %[^=]= %s ", parsed_name, key_value_buffer) != 2 )
        {
          sub_5DF98(2, "src/conf.c", 412, "sscanf [%s] fail, name or value is null", line_buffer);
          goto LABEL_37;
        }
        memset(key_name, 0, 4097u);
        memset(key_modifier, 0, 4097u);
        memset(key_modifier_next, 0, 4097u);
        parsed_len = 0;
        _isoc99_sscanf(parsed_name, "%s%n%s%s", key_name, &parsed_len, key_modifier, key_modifier_next);
        if ( !strcmp(key_name, "strict") && !strcmp(key_modifier, "init") )
        {
          if ( strcasecmp(key_value_buffer, "false") || getenv("ZLOG_STRICT_INIT") )
          {
            config_line = line_buffer;
            *(_DWORD *)(config_dir_path + 1048) = 1;
            config_line_offset = 0;
          }
          else
          {
            *(_DWORD *)(config_dir_path + 1048) = 0;
            config_line_offset = 0;
            config_line = line_buffer;
          }
          goto LABEL_4;
        }
        if ( !strcmp(key_name, "buffer") && key_modifier[0] == 109 )
        {
          if ( key_modifier[1] == 105 )
          {
            if ( key_modifier[2] == 110 )
            {
              config_line_offset = (unsigned __int8)key_modifier[3];
              if ( !key_modifier[3] )
              {
                config_line = line_buffer;
                *(_DWORD *)(config_dir_path + 1052) = parse_size_in_bytes(key_value_buffer);
                goto LABEL_4;
              }
            }
          }
          else if ( key_modifier[1] == 97 && key_modifier[2] == 120 )
          {
            config_line_offset = (unsigned __int8)key_modifier[3];
            if ( !key_modifier[3] )
            {
              config_line = line_buffer;
              *(_DWORD *)(config_dir_path + 1056) = parse_size_in_bytes(key_value_buffer);
              goto LABEL_4;
            }
          }
        }
        if ( !strcmp(key_name, "file") )
        {
          config_line_offset = strcmp(key_modifier, "perms");
          if ( !config_line_offset )
          {
            _isoc99_sscanf(key_value_buffer, "%o", config_dir_path + 9268);
            config_line = line_buffer;
            goto LABEL_4;
          }
        }
        if ( !strcmp(key_name, "rotate") && !strcmp(key_modifier, "lock") )
        {
          config_line_offset = strcmp(key_modifier_next, "file");
          if ( !config_line_offset )
          {
            compare_rotate_lock_file = strcmp(key_value_buffer, "self");
            rotate_lock_file_ptr = (char *)(config_dir_path + 1060);
            if ( compare_rotate_lock_file )
            {
              config_line = line_buffer;
              strcpy(rotate_lock_file_ptr, key_value_buffer);
            }
            else
            {
              config_line_offset = 0;
              config_line = line_buffer;
              strcpy(rotate_lock_file_ptr, (const char *)config_dir_path);
            }
            goto LABEL_4;
          }
        }
        if ( !strcmp(key_name, "default") )
        {
          config_line_offset = strcmp(key_modifier, "format");
          if ( !config_line_offset )
          {
            config_line = line_buffer;
            strcpy((char *)(config_dir_path + 5164), &line_buffer[parsed_len]);
            goto LABEL_4;
          }
        }
        if ( !strcmp(key_name, "reload") && !strcmp(key_modifier, "conf") )
        {
          config_line_offset = strcmp(key_modifier_next, "period");
          if ( !config_line_offset )
          {
            config_line = line_buffer;
            *(_DWORD *)(config_dir_path + 9276) = parse_size_in_bytes(key_value_buffer);
            goto LABEL_4;
          }
        }
        if ( !strcmp(key_name, "fsync") )
        {
          config_line_offset = strcmp(key_modifier, "period");
          if ( !config_line_offset )
          {
            config_line = line_buffer;
            *(_DWORD *)(config_dir_path + 9272) = parse_size_in_bytes(key_value_buffer);
            goto LABEL_4;
          }
        }
        sub_5DF98(2, "src/conf.c", 454, "name[%s] is not any one of global options", parsed_name);
        if ( *(_DWORD *)(config_dir_path + 1048) )
          goto LABEL_37;
        break;
      case 2:
        if ( !set_log_level_from_config(*(_DWORD *)(config_dir_path + 9280), line_buffer) )
          goto LABEL_45;
        sub_5DF98(2, "src/conf.c", 460, "zlog_level_list_set fail");
        if ( *(_DWORD *)(config_dir_path + 1048) )
          goto LABEL_37;
        config_line = line_buffer;
        config_line_offset = 0;
        goto LABEL_4;
      case 3:
        format_str_ptr = parse_format_string(line_buffer, format_list_ptr);
        format_ptr = format_str_ptr;
        if ( format_str_ptr )
        {
          if ( invoke_custom_subroutine(*(_DWORD *)(config_dir_path + 9284), (int)format_str_ptr) )
          {
            delete_format(format_ptr);
            sub_5DF98(2, "src/conf.c", 473, "zc_arraylist_add fail");
            goto LABEL_37;
          }
        }
        else
        {
          sub_5DF98(2, "src/conf.c", 467, "zlog_format_new fail [%s]", line_buffer);
          if ( *(_DWORD *)(config_dir_path + 1048) )
            goto LABEL_37;
        }
        goto LABEL_45;
      case 4:
        rule_ptr = parse_configuration_line(
                     line_buffer,
                     *(_DWORD **)(config_dir_path + 9280),
                     *(_DWORD *)(config_dir_path + 9264),
                     *(__int64 **)(config_dir_path + 9284),
                     *(_DWORD *)(config_dir_path + 9268),
                     *(_DWORD *)(config_dir_path + 9272),
                     format_list_ptr);
        if ( rule_ptr )
        {
          if ( !invoke_custom_subroutine(*(_DWORD *)(config_dir_path + 9288), (int)rule_ptr) )
            goto LABEL_42;
          release_rule_resources(rule_ptr);
          sub_5DF98(2, "src/conf.c", 493, "zc_arraylist_add fail");
        }
        else
        {
          original_config_line = line_buffer;
          sub_5DF98(2, "src/conf.c", 487, "zlog_rule_new fail [%s]");
          if ( !*(_DWORD *)(config_dir_path + 1048) )
            goto LABEL_42;
        }
        goto LABEL_37;
      default:
        sub_5DF98(2, "src/conf.c", 498, "not in any section");
        goto LABEL_37;
    }
LABEL_66:
    config_line = line_buffer;
    config_line_offset = 0;
  }
  line_iter_ptr = line_buffer;
  while ( line_first_char == 34 )
  {
    quotation_mark_count ^= 1u;
LABEL_27:
    next_line_char = (unsigned __int8)*++line_iter_ptr;
    line_first_char = next_line_char;
    if ( !next_line_char )
      goto LABEL_33;
  }
  if ( line_first_char != 35 || quotation_mark_count )
    goto LABEL_27;
  *line_iter_ptr = 0;
LABEL_33:
  current_line_length = strlen(line_buffer);
  if ( current_line_length <= 4096 )
  {
    if ( line_buffer[0] != 91 )
      goto LABEL_35;
    _isoc99_sscanf(line_buffer, asc_6BB30, parsed_name);
    if ( !strcmp(parsed_name, "global") )
    {
      if ( config_section )
        goto LABEL_115;
      goto LABEL_66;
    }
    if ( !strcmp(parsed_name, "levels") )
    {
      if ( config_section > 1 )
        goto LABEL_115;
      config_section = 2;
    }
    else
    {
      if ( strcmp(parsed_name, "formats") )
      {
        if ( strcmp(parsed_name, "rules") )
        {
          sub_5DF98(2, "src/conf.c", 363, "wrong section name[%s]", parsed_name);
          goto LABEL_37;
        }
        if ( config_section == 4 )
          goto LABEL_115;
        reload_conf_period = *(_DWORD *)(config_dir_path + 9276);
        if ( reload_conf_period && reload_conf_period <= *(_DWORD *)(config_dir_path + 9272) )
        {
          sub_5DF98(
            1,
            "src/conf.c",
            382,
            "fsync_period[%ld] >= reload_conf_period[%ld],set fsync_period to zero",
            original_config_line,
            placeholder_var);
          *(_DWORD *)(config_dir_path + 9272) = 0;
        }
        mutex_file_ptr = initialize_mutex_and_open_file((const char *)(config_dir_path + 1060));
        *(_DWORD *)(config_dir_path + 5160) = mutex_file_ptr;
        if ( !mutex_file_ptr )
        {
          sub_5DF98(2, "src/conf.c", 391, "zlog_rotater_new fail");
          goto LABEL_37;
        }
        default_format_ptr = parse_format_string((const char *)(config_dir_path + 5164), format_list_ptr);
        *(_DWORD *)(config_dir_path + 9264) = default_format_ptr;
        if ( !default_format_ptr )
        {
          sub_5DF98(2, "src/conf.c", 398, "zlog_format_new fail");
          goto LABEL_37;
        }
LABEL_42:
        config_line = line_buffer;
        config_section = 4;
        config_line_offset = 0;
        goto LABEL_4;
      }
      if ( config_section > 2 )
      {
LABEL_115:
        sub_5DF98(2, "src/conf.c", 368, "wrong sequence of section, must follow global->levels->formats->rules");
        goto LABEL_37;
      }
      config_section = 3;
    }
LABEL_45:
    config_line = line_buffer;
    config_line_offset = 0;
    goto LABEL_4;
  }
LABEL_97:
  sub_5DF98(2, "src/conf.c", 346, "line_len[%ld] > MAXLEN_CFG_LINE[%ld], may cause overflow", current_line_length, 4096);
LABEL_37:
  sub_5DF98(
    2,
    "src/conf.c",
    314,
    "parse configure file[%s]line_no[%ld] fail",
    (const char *)config_dir_path,
    config_line_number);
  status = -1;
  sub_5DF98(2, "src/conf.c", 315, "line[%s]", line_buffer);
LABEL_38:
  fclose(config_file_ptr);
  return status;
}
// 56280: control flows out of bounds to 56284
// 565D8: variable 'original_config_line' is possibly undefined
// 565D8: variable 'placeholder_var' is possibly undefined
// 1231C: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);
// 124E4: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 125D4: using guessed type int __fastcall _lxstat64(_DWORD, _DWORD, _DWORD);
// 56030: using guessed type char var_60A8[80];

//----- (00056B38) --------------------------------------------------------
char *__fastcall print_configuration(int config_ptr, int log_level)
{
  int config_offset; // r5
  int rotate_config_ptr; // r0
  char *result_str; // r0
  _DWORD *format_list_ptr; // r3
  int format_index; // r6
  int format_entry_ptr; // r0
  _DWORD *rule_list_ptr; // r3
  int rule_index; // r6
  int rule_entry_ptr; // r0

  if ( !config_ptr )
    return (char *)sub_5DF98(2, "src/conf.c", 44, "a_conf is null or 0");
  sub_5DF98(log_level, "src/conf.c", 45, "-conf[%p]-", (const void *)config_ptr);
  sub_5DF98(log_level, "src/conf.c", 46, "--global--");
  sub_5DF98(
    log_level,
    "src/conf.c",
    47,
    "---file[%s],mtime[%s]---",
    (const char *)config_ptr,
    (const char *)(config_ptr + 1025));
  sub_5DF98(log_level, "src/conf.c", 48, "---strict init[%d]---", *(_DWORD *)(config_ptr + 1048));
  sub_5DF98(log_level, "src/conf.c", 49, "---buffer min[%ld]---", *(_DWORD *)(config_ptr + 1052));
  config_offset = config_ptr + 8192;
  sub_5DF98(log_level, "src/conf.c", 50, "---buffer max[%ld]---", *(_DWORD *)(config_ptr + 1056));
  if ( *(_DWORD *)(config_ptr + 9264) )
  {
    sub_5DF98(log_level, "src/conf.c", 52, "---default_format---");
    log_format_error(*(_DWORD *)(config_ptr + 9264), log_level);
  }
  sub_5DF98(log_level, "src/conf.c", 55, "---file perms[0%o]---", *(_DWORD *)(config_ptr + 9268));
  sub_5DF98(log_level, "src/conf.c", 56, "---reload conf period[%ld]---", *(_DWORD *)(config_ptr + 9276));
  sub_5DF98(log_level, "src/conf.c", 57, "---fsync period[%ld]---", *(_DWORD *)(config_ptr + 9272));
  sub_5DF98(log_level, "src/conf.c", 59, "---rotate lock file[%s]---", (const char *)(config_ptr + 1060));
  rotate_config_ptr = *(_DWORD *)(config_ptr + 5160);
  if ( rotate_config_ptr )
    print_rotater_info(rotate_config_ptr, log_level);
  result_str = *(char **)(config_ptr + 9280);
  if ( result_str )
    result_str = (char *)print_level_list(result_str, log_level);
  if ( *(_DWORD *)(config_ptr + 9284) )
  {
    result_str = (char *)sub_5DF98(
                           log_level,
                           "src/conf.c",
                           65,
                           "--format list[%p]--",
                           *(const void **)(config_ptr + 9284));
    format_list_ptr = *(_DWORD **)(config_ptr + 9284);
    if ( (int)format_list_ptr[1] > 0 )
    {
      format_index = 0;
      do
      {
        format_entry_ptr = *(_DWORD *)(*format_list_ptr + 4 * format_index++);
        result_str = (char *)log_format_error(format_entry_ptr, log_level);
        format_list_ptr = *(_DWORD **)(config_offset + 1092);
      }
      while ( format_list_ptr[1] > format_index );
    }
  }
  if ( *(_DWORD *)(config_offset + 1096) )
  {
    result_str = (char *)sub_5DF98(
                           log_level,
                           "src/conf.c",
                           72,
                           "--rule_list[%p]--",
                           *(const void **)(config_offset + 1096));
    rule_list_ptr = *(_DWORD **)(config_offset + 1096);
    if ( (int)rule_list_ptr[1] > 0 )
    {
      rule_index = 0;
      do
      {
        rule_entry_ptr = *(_DWORD *)(*rule_list_ptr + 4 * rule_index++);
        result_str = (char *)log_rule_information(rule_entry_ptr, log_level);
        rule_list_ptr = *(_DWORD **)(config_offset + 1096);
      }
      while ( rule_list_ptr[1] > rule_index );
    }
  }
  return result_str;
}

//----- (00056E0C) --------------------------------------------------------
int __fastcall delete_zlog_config(_DWORD *config_ptr)
{
  pthread_mutex_t *logger_mutex; // r0
  _DWORD *category_table_ptr; // r0
  _DWORD *rule_table_ptr; // r0
  _DWORD *process_table_ptr; // r0
  _DWORD *thread_table_ptr; // r0

  if ( !config_ptr )
    return sub_5DF98(2, "src/conf.c", 83, "a_conf is null or 0");
  logger_mutex = (pthread_mutex_t *)config_ptr[1290];
  if ( logger_mutex )
    close_and_destroy_mutex(logger_mutex);
  category_table_ptr = (_DWORD *)config_ptr[2320];
  if ( category_table_ptr )
    delete_level_list(category_table_ptr);
  rule_table_ptr = (_DWORD *)config_ptr[2316];
  if ( rule_table_ptr )
    delete_format(rule_table_ptr);
  process_table_ptr = (_DWORD *)config_ptr[2321];
  if ( process_table_ptr )
    process_and_free_resources(process_table_ptr);
  thread_table_ptr = (_DWORD *)config_ptr[2322];
  if ( thread_table_ptr )
    process_and_free_resources(thread_table_ptr);
  free(config_ptr);
  return sub_5DF98(0, "src/conf.c", 90, "zlog_conf_del[%p]");
}

//----- (00056EB8) --------------------------------------------------------
int __fastcall sub_56EB8(const char *a1)
{
  char *v2; // r0
  int v3; // r4
  int v4; // r8
  char *v5; // r0
  unsigned int v6; // r5
  const char *v7; // r7
  int v8; // r0
  _DWORD *v9; // r0
  _DWORD *v10; // r0
  char *v12; // r0
  pthread_mutex_t *v13; // r0
  unsigned __int8 *v14; // r6
  int *v15; // r0
  int *v16; // r0

  v2 = (char *)calloc(1u, 9296u);
  v3 = (int)v2;
  if ( !v2 )
  {
    v16 = _errno_location();
    sub_5DF98(2, "src/conf.c", 105, "calloc fail, errno[%d]", *v16);
    return v3;
  }
  if ( a1 && *a1 )
  {
    v6 = snprintf(v2, 1025u, "%s", a1);
    if ( v6 <= 1024 )
      goto LABEL_6;
    goto LABEL_22;
  }
  v4 = (int)getenv("ZLOG_CONF_PATH");
  if ( v4 )
  {
    v5 = getenv("ZLOG_CONF_PATH");
    v6 = snprintf((char *)v3, 1025u, "%s", v5);
    if ( v6 <= 1024 )
    {
LABEL_6:
      v7 = (const char *)(v3 + 1060);
      *(_DWORD *)(v3 + 1048) = 1;
      *(_DWORD *)(v3 + 1052) = 1024;
      *(_DWORD *)(v3 + 1056) = 2097152;
      v4 = 1;
      strcpy((char *)(v3 + 1060), (const char *)v3);
      goto LABEL_7;
    }
LABEL_22:
    v15 = _errno_location();
    sub_5DF98(2, "src/conf.c", 120, "not enough space for path name, nwrite=[%d], errno[%d]", v6, *v15);
    goto LABEL_23;
  }
  memset((void *)v3, 0, 1025u);
  *(_DWORD *)(v3 + 1048) = 1;
  v7 = (const char *)(v3 + 1060);
  *(_DWORD *)(v3 + 1056) = 2097152;
  *(_DWORD *)(v3 + 1052) = 1024;
  strcpy((char *)(v3 + 1060), "/tmp/zlog.lock");
LABEL_7:
  strcpy((char *)(v3 + 5164), "default = \"%D %V [%p:%F:%L] %m%n\"");
  *(_DWORD *)(v3 + 9268) = 384;
  *(_DWORD *)(v3 + 9276) = 0;
  *(_DWORD *)(v3 + 9272) = 0;
  v8 = initialize_logging_levels();
  *(_DWORD *)(v3 + 9280) = v8;
  if ( v8 )
  {
    v9 = initialize_array_list((int)delete_format);
    *(_DWORD *)(v3 + 9284) = v9;
    if ( v9 )
    {
      v10 = initialize_array_list((int)release_rule_resources);
      *(_DWORD *)(v3 + 9288) = v10;
      if ( v10 )
      {
        if ( v4 )
        {
          if ( !parse_config_file(v3) )
          {
LABEL_12:
            print_configuration(v3, 0);
            return v3;
          }
          sub_5DF98(2, "src/conf.c", 160, "zlog_conf_build_with_file fail");
        }
        else
        {
          v12 = parse_format_string((const char *)(v3 + 5164), (const char **)(v3 + 9292));
          *(_DWORD *)(v3 + 9264) = v12;
          if ( v12 )
          {
            v13 = initialize_mutex_and_open_file(v7);
            *(_DWORD *)(v3 + 5160) = v13;
            if ( v13 )
            {
              v14 = parse_configuration_line(
                      "*.*        >stdout",
                      *(_DWORD **)(v3 + 9280),
                      *(_DWORD *)(v3 + 9264),
                      *(__int64 **)(v3 + 9284),
                      *(_DWORD *)(v3 + 9268),
                      *(_DWORD *)(v3 + 9272),
                      (const char **)(v3 + 9292));
              if ( v14 )
              {
                if ( !invoke_custom_subroutine(*(_DWORD *)(v3 + 9288), (int)v14) )
                  goto LABEL_12;
                release_rule_resources(v14);
                sub_5DF98(2, "src/conf.c", 209, "zc_arraylist_add fail");
              }
              else
              {
                sub_5DF98(2, "src/conf.c", 202, "zlog_rule_new fail");
              }
            }
            else
            {
              sub_5DF98(2, "src/conf.c", 189, "zlog_rotater_new fail");
            }
          }
          else
          {
            sub_5DF98(2, "src/conf.c", 183, "zlog_format_new fail");
          }
          sub_5DF98(2, "src/conf.c", 165, "zlog_conf_build_without_file fail");
        }
      }
      else
      {
        sub_5DF98(2, "src/conf.c", 154, "init rule_list fail");
      }
    }
    else
    {
      sub_5DF98(2, "src/conf.c", 148, "zc_arraylist_new fail");
    }
  }
  else
  {
    sub_5DF98(2, "src/conf.c", 142, "zlog_level_list_new fail");
  }
LABEL_23:
  delete_zlog_config((_DWORD *)v3);
  return 0;
}

//----- (0005729C) --------------------------------------------------------
int __fastcall log_event_details(const char **event_data, int severity_level)
{
  if ( event_data )
    return sub_5DF98(
             severity_level,
             "src/event.c",
             40,
             "---event[%p][%s,%s][%s(%ld),%s(%ld),%ld,%d][%p,%s][%ld,%ld][%ld,%ld][%d]---",
             event_data,
             *event_data,
             (const char *)event_data + 8,
             event_data[68],
             event_data[69],
             event_data[70],
             event_data[71],
             event_data[72],
             event_data[73],
             event_data[74],
             event_data[76],
             event_data[79],
             event_data[80],
             event_data[95],
             event_data[106],
             event_data[94]);
  else
    return sub_5DF98(2, "src/event.c", 30, "a_event is null or 0");
}

//----- (00057364) --------------------------------------------------------
void __fastcall free_event_data(_DWORD *event_data_ptr)
{
  void *event_associated_data; // r0

  if ( event_data_ptr )
  {
    event_associated_data = (void *)event_data_ptr[93];
    if ( event_associated_data )
      free(event_associated_data);
    sub_5DF98(0, "src/event.c", 50, "zlog_event_del[%p]", event_data_ptr);
    free(event_data_ptr);
  }
  else
  {
    sub_5DF98(2, "src/event.c", 48, "a_event is null or 0");
  }
}

//----- (000573D8) --------------------------------------------------------
void *__fastcall sub_573D8(size_t a1)
{
  void *v2; // r4
  void *v3; // r5
  pthread_t v4; // r0
  int v5; // r0
  int v6; // r2
  int v7; // r0
  int *v9; // r0
  _DWORD *v10; // r0
  int *v11; // r0
  int *v12; // r0
  void *v13; // r0

  v2 = calloc(1u, 540u);
  if ( v2 )
  {
    v3 = calloc(a1, 4108u);
    *((_DWORD *)v2 + 93) = v3;
    if ( v3 )
    {
      *((_DWORD *)v2 + 94) = a1;
      if ( gethostname((char *)v2 + 8, 256u) )
      {
        v9 = _errno_location();
        sub_5DF98(2, "src/event.c", 78, "gethostname fail, errno[%d]", *v9);
        v10 = v2;
        v2 = 0;
        free_event_data(v10);
      }
      else
      {
        *((_DWORD *)v2 + 67) = strlen((const char *)v2 + 8);
        v4 = pthread_self();
        *((_DWORD *)v2 + 106) = v4;
        v5 = sprintf((char *)v2 + 428, "%lu", v4);
        v6 = *((_DWORD *)v2 + 106);
        *((_DWORD *)v2 + 115) = v5;
        *((_DWORD *)v2 + 124) = sprintf((char *)v2 + 464, "%x", v6);
        v7 = syscall(224);
        *((_DWORD *)v2 + 125) = v7;
        *((_DWORD *)v2 + 134) = sprintf((char *)v2 + 504, "%u", v7);
      }
    }
    else
    {
      v12 = _errno_location();
      sub_5DF98(2, "src/event.c", 67, "calloc fail, errno[%d]", *v12);
      v13 = v2;
      v2 = 0;
      free(v13);
    }
  }
  else
  {
    v11 = _errno_location();
    sub_5DF98(2, "src/event.c", 61, "calloc fail, errno[%d]", *v11);
  }
  return v2;
}

//----- (00057540) --------------------------------------------------------
_DWORD *__fastcall fill_miner_config_buffer(
        _DWORD *config_buffer,
        int version,
        int chain_count,
        int chip_count,
        int core_count,
        int clock_speed,
        int voltage,
        int work_mode,
        int fan_speed,
        int temp_high_threshold,
        int temp_low_threshold)
{
  *config_buffer = version;
  config_buffer[1] = chain_count;
  config_buffer[68] = chip_count;
  config_buffer[69] = core_count;
  config_buffer[70] = clock_speed;
  config_buffer[71] = voltage;
  config_buffer[72] = work_mode;
  config_buffer[73] = fan_speed;
  config_buffer[76] = temp_high_threshold;
  config_buffer[77] = temp_low_threshold;
  config_buffer[78] = 0;
  config_buffer[95] = 0;
  config_buffer[79] = 0;
  return config_buffer;
}

//----- (0005759C) --------------------------------------------------------
_DWORD *__fastcall populate_miner_config(
        _DWORD *config_values,
        int asic_count,
        int hashrate,
        int power_limit,
        int fan_speed,
        int temperature_target,
        int chip_frequency,
        int voltage,
        int operating_frequency,
        int fan_control_enabled,
        int automatic_voltage_enabled)
{
  config_values[1] = hashrate;
  config_values[68] = power_limit;
  config_values[69] = fan_speed;
  *config_values = asic_count;
  config_values[70] = temperature_target;
  config_values[71] = chip_frequency;
  config_values[72] = voltage;
  config_values[73] = operating_frequency;
  config_values[78] = 1;
  config_values[74] = fan_control_enabled;
  config_values[75] = automatic_voltage_enabled;
  config_values[95] = 0;
  config_values[79] = 0;
  return config_values;
}

//----- (000575FC) --------------------------------------------------------
int __fastcall log_format_error(int format_buffer, int log_level)
{
  if ( format_buffer )
    return sub_5DF98(
             log_level,
             "src/format.c",
             29,
             "---format[%p][%s = %s(%p)]---",
             (const void *)format_buffer,
             (const char *)format_buffer,
             (const char *)(format_buffer + 4097),
             *(const void **)(format_buffer + 8196));
  else
    return sub_5DF98(2, "src/format.c", 24, "a_format is null or 0");
}

//----- (0005766C) --------------------------------------------------------
void __fastcall delete_format(_DWORD *format)
{
  _DWORD *child_resource; // r0

  if ( format )
  {
    child_resource = (_DWORD *)format[2049];
    if ( child_resource )
      process_and_free_resources(child_resource);
    sub_5DF98(0, "src/format.c", 49, "zlog_format_del[%p]", format);
    free(format);
  }
  else
  {
    sub_5DF98(2, "src/format.c", 45, "a_format is null or 0");
  }
}

//----- (000576E4) --------------------------------------------------------
char *__fastcall parse_format_string(const char *input_line, const char **environment_variables)
{
  char *allocated_buffer; // r0
  char *format_buffer; // r5
  int position_quote; // r8
  int char_value; // r4
  const unsigned __int16 **char_type_data; // r0
  char *char_ptr; // r2
  int next_char_value; // t1
  const char *pattern_start; // r8
  char *quote_end_ptr; // r0
  size_t pattern_length; // r6
  const char *env_buffer; // r4
  _DWORD *array_list_ptr; // r0
  const char **logging_specification; // r4
  int *errno_ptr; // r0
  int bytes_read; // [sp+8h] [bp-28h] BYREF
  char *next_token_ptr; // [sp+Ch] [bp-24h] BYREF

  bytes_read = 0;
  if ( !input_line )
  {
    sub_5DF98(2, "src/format.c", 65, "line is null or 0");
    return 0;
  }
  allocated_buffer = (char *)calloc(1u, 8200u);
  format_buffer = allocated_buffer;
  if ( !allocated_buffer )
  {
    errno_ptr = _errno_location();
    sub_5DF98(2, "src/format.c", 69, "calloc fail, errno[%d]", *errno_ptr);
    return 0;
  }
  memset(allocated_buffer, 0, 4097u);
  bytes_read = 0;
  if ( _isoc99_sscanf(input_line, " %[^= \t] = %n", format_buffer, &bytes_read) != 1 )
  {
    sub_5DF98(2, "src/format.c", 81, "format[%s], syntax wrong", input_line);
LABEL_20:
    delete_format(format_buffer);
    return 0;
  }
  position_quote = bytes_read;
  if ( input_line[bytes_read] != 34 )
  {
    sub_5DF98(2, "src/format.c", 86, "the 1st char of pattern is not \", line+nread[%s]", &input_line[bytes_read]);
    goto LABEL_20;
  }
  char_value = (unsigned __int8)*format_buffer;
  if ( *format_buffer )
  {
    char_type_data = _ctype_b_loc();
    char_ptr = format_buffer;
    while ( ((char_value != 95) & (((*char_type_data)[char_value] ^ 8u) >> 3)) == 0 )
    {
      next_char_value = (unsigned __int8)*++char_ptr;
      char_value = next_char_value;
      if ( !next_char_value )
        goto LABEL_9;
    }
    sub_5DF98(2, "src/format.c", 92, "a_format->name[%s] character is not in [a-Z][0-9][_]", format_buffer);
    goto LABEL_20;
  }
LABEL_9:
  pattern_start = &input_line[position_quote + 1];
  quote_end_ptr = strrchr(pattern_start, 34);
  if ( !quote_end_ptr )
  {
    sub_5DF98(2, "src/format.c", 100, "there is no \" at end of pattern, line[%s]", input_line);
    goto LABEL_20;
  }
  pattern_length = quote_end_ptr - pattern_start;
  if ( (unsigned int)(quote_end_ptr - pattern_start) > 4096 )
  {
    sub_5DF98(2, "src/format.c", 105, "pattern is too long");
    goto LABEL_20;
  }
  env_buffer = format_buffer + 4097;
  memset(format_buffer + 4097, 0, 4097u);
  memcpy(format_buffer + 4097, pattern_start, pattern_length);
  if ( replace_env_variable_in_string(format_buffer + 4097, 4097) )
  {
    sub_5DF98(2, "src/format.c", 112, "zc_str_replace_env fail");
    goto LABEL_20;
  }
  array_list_ptr = initialize_array_list((int)delete_logging_specification);
  *((_DWORD *)format_buffer + 2049) = array_list_ptr;
  if ( !array_list_ptr )
  {
    sub_5DF98(2, "src/format.c", 119, "zc_arraylist_new fail");
    goto LABEL_20;
  }
  if ( format_buffer[4097] )
  {
    while ( 1 )
    {
      logging_specification = parse_log_format(env_buffer, &next_token_ptr, environment_variables);
      if ( !logging_specification )
      {
        sub_5DF98(2, "src/format.c", 126, "zlog_spec_new fail");
        goto LABEL_20;
      }
      if ( invoke_custom_subroutine(*((_DWORD *)format_buffer + 2049), (int)logging_specification) )
        break;
      env_buffer = next_token_ptr;
      if ( !*next_token_ptr )
        goto LABEL_22;
    }
    delete_logging_specification(logging_specification);
    sub_5DF98(2, "src/format.c", 132, "zc_arraylist_add fail");
    goto LABEL_20;
  }
LABEL_22:
  log_format_error((int)format_buffer, 0);
  return format_buffer;
}
// 1231C: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);

//----- (00057A1C) --------------------------------------------------------
int __fastcall check_condition_and_execute(int base_address, int param_struct)
{
  int index; // r4
  int functions_list_base; // r6
  _DWORD *functions_list; // r3
  int number_of_functions; // r12
  int current_function_address; // r0

  functions_list_base = base_address + 8192;
  functions_list = *(_DWORD **)(base_address + 8196);
  number_of_functions = functions_list[1];
  if ( number_of_functions > 0 )
    index = 0;
  *(_DWORD *)(*(_DWORD *)(param_struct + 28) + 4) = **(_DWORD **)(param_struct + 28);
  if ( number_of_functions <= 0 )
    return 0;
  while ( 1 )
  {
    current_function_address = *(_DWORD *)(*functions_list + 4 * index++);
    if ( (*(int (**)(void))(current_function_address + 9256))() )
      break;
    functions_list = *(_DWORD **)(functions_list_base + 4);
    if ( functions_list[1] <= index )
      return 0;
  }
  return -1;
}
// 57A50: variable 'index' is possibly undefined

//----- (00057A8C) --------------------------------------------------------
const char *__fastcall print_level_list(_DWORD *level_array, int log_level)
{
  const char *log_result; // r0
  int num_levels; // r2
  int current_level_index; // r4

  if ( !level_array )
    return (const char *)sub_5DF98(2, "src/level_list.c", 25, "levels is null or 0");
  log_result = (const char *)sub_5DF98(log_level, "src/level_list.c", 26, "--level_list[%p]--", level_array);
  num_levels = level_array[1];
  if ( num_levels > 0 )
  {
    for ( current_level_index = 0; current_level_index < num_levels; ++current_level_index )
    {
      log_result = *(const char **)(*level_array + 4 * current_level_index);
      if ( log_result )
      {
        log_result = (const char *)log_level_info(log_result, log_level);
        num_levels = level_array[1];
      }
    }
  }
  return log_result;
}

//----- (00057B24) --------------------------------------------------------
int __fastcall delete_level_list(_DWORD *level_list_ptr)
{
  if ( !level_list_ptr )
    return sub_5DF98(2, "src/level_list.c", 37, "levels is null or 0");
  process_and_free_resources(level_list_ptr);
  return sub_5DF98(0, "src/level_list.c", 39, "zc_level_list_del[%p]", level_list_ptr);
}

//----- (00057B80) --------------------------------------------------------
int __fastcall set_log_level_from_config(int config_handle, const char *config_line)
{
  int *log_level; // r4
  int operation_result; // r0

  log_level = parse_log_level(config_line);
  if ( log_level )
  {
    operation_result = resize_array_list(config_handle, *log_level, (int)log_level);
    if ( operation_result )
    {
      sub_5DF98(2, "src/level_list.c", 90, "zc_arraylist_set fail");
      sub_5DF98(2, "src/level_list.c", 96, "line[%s]", config_line);
      delete_log_level(log_level);
      return -1;
    }
  }
  else
  {
    sub_5DF98(2, "src/level_list.c", 85, "zlog_level_new fail");
    return -1;
  }
  return operation_result;
}

//----- (00057C30) --------------------------------------------------------
int initialize_logging_levels()
{
  _DWORD *array_list_ptr; // r0
  int array_list_status; // r4
  _DWORD *cleanup_ptr; // r0

  array_list_ptr = initialize_array_list((int)delete_log_level);
  array_list_status = (int)array_list_ptr;
  if ( array_list_ptr )
  {
    if ( set_log_level_from_config((int)array_list_ptr, "* = 0, LOG_INFO")
      || set_log_level_from_config(array_list_status, "DEBUG = 20, LOG_DEBUG")
      || set_log_level_from_config(array_list_status, "INFO = 40, LOG_INFO")
      || set_log_level_from_config(array_list_status, "NOTICE = 60, LOG_NOTICE")
      || set_log_level_from_config(array_list_status, "WARN = 80, LOG_WARNING")
      || set_log_level_from_config(array_list_status, "ERROR = 100, LOG_ERR")
      || set_log_level_from_config(array_list_status, "FATAL = 120, LOG_ALERT")
      || set_log_level_from_config(array_list_status, "UNKNOWN = 254, LOG_ERR")
      || set_log_level_from_config(array_list_status, "! = 255, LOG_INFO") )
    {
      sub_5DF98(2, "src/level_list.c", 67, "zlog_level_set_default fail");
      cleanup_ptr = (_DWORD *)array_list_status;
      array_list_status = 0;
      process_and_free_resources(cleanup_ptr);
    }
  }
  else
  {
    sub_5DF98(2, "src/level_list.c", 62, "zc_arraylist_new fail");
  }
  return array_list_status;
}

//----- (00057D70) --------------------------------------------------------
int __fastcall getASICChipLevel(int *levelListPtr, int chipIndex)
{
  int numberOfLevels; // r3
  bool isIndexInRange; // cc
  int defaultLevelOffset; // r3

  if ( levelListPtr[1] > chipIndex && *(_DWORD *)(*levelListPtr + 4 * chipIndex) )
    return *(_DWORD *)(*levelListPtr + 4 * chipIndex);
  sub_5DF98(
    2,
    "src/level_list.c",
    119,
    "l[%d] not in (0,254), or has no level defined,see configure file define, set to UNKOWN",
    chipIndex);
  numberOfLevels = levelListPtr[1];
  isIndexInRange = numberOfLevels <= 254;
  if ( numberOfLevels <= 254 )
    defaultLevelOffset = 0;
  else
    defaultLevelOffset = *levelListPtr;
  if ( !isIndexInRange )
    return *(_DWORD *)(defaultLevelOffset + 1016);
  return defaultLevelOffset;
}

//----- (00057DE4) --------------------------------------------------------
int __fastcall find_string_index_in_array(_DWORD *array_info, const char *search_string)
{
  int array_length; // r7
  int array_start_offset; // r5
  int index; // r4
  int current_element_offset; // t1
  const char *current_element_string; // r1

  if ( search_string && *search_string )
  {
    array_length = array_info[1];
    if ( array_length <= 0 )
    {
LABEL_8:
      index = -1;
      sub_5DF98(2, "src/level_list.c", 142, "str[%s] can't found in level list", search_string);
    }
    else
    {
      array_start_offset = *array_info - 4;
      index = 0;
      while ( 1 )
      {
        current_element_offset = *(_DWORD *)(array_start_offset + 4);
        array_start_offset += 4;
        current_element_string = (const char *)(current_element_offset + 4);
        if ( current_element_offset )
        {
          if ( !strcasecmp(search_string, current_element_string) )
            break;
        }
        if ( ++index == array_length )
          goto LABEL_8;
      }
    }
  }
  else
  {
    index = -1;
    sub_5DF98(2, "src/level_list.c", 132, "str is [%s], can't find level", search_string);
  }
  return index;
}

//----- (00057E98) --------------------------------------------------------
void __fastcall remove_mdc_key_value(void *mdc_entry_ptr)
{
  sub_5DF98(0, "src/mdc.c", 44, "zlog_mdc_kv_del[%p]", mdc_entry_ptr);
  free(mdc_entry_ptr);
}

//----- (00057ED4) --------------------------------------------------------
int __fastcall print_mdc_status(int *mdc_array_ptr, int log_level)
{
  int iterator_pointer; // r0
  int current_kv_pair_ptr; // r4

  if ( !mdc_array_ptr )
    return sub_5DF98(2, "src/mdc.c", 21, "a_mdc is null or 0");
  sub_5DF98(log_level, "src/mdc.c", 22, "---mdc[%p]---", mdc_array_ptr);
  iterator_pointer = get_first_non_zero_value(*mdc_array_ptr);
  for ( current_kv_pair_ptr = iterator_pointer; iterator_pointer; current_kv_pair_ptr = iterator_pointer )
  {
    sub_5DF98(
      log_level,
      "src/mdc.c",
      28,
      "----mdc_kv[%p][%s]-[%s]----",
      *(const void **)(current_kv_pair_ptr + 8),
      *(const char **)(current_kv_pair_ptr + 8),
      (const char *)(*(_DWORD *)(current_kv_pair_ptr + 8) + 1025));
    iterator_pointer = get_next_active_value(*mdc_array_ptr, (unsigned int *)current_kv_pair_ptr);
  }
  return iterator_pointer;
}

//----- (00057F94) --------------------------------------------------------
void __fastcall delete_mdc_hashtable(_DWORD **mdc_hashtable)
{
  _DWORD *hashtable_entry; // r0

  if ( mdc_hashtable )
  {
    hashtable_entry = *mdc_hashtable;
    if ( *mdc_hashtable )
      free_hashtable(hashtable_entry);
    sub_5DF98(0, "src/mdc.c", 37, "zlog_mdc_del[%p]", mdc_hashtable);
    free(mdc_hashtable);
  }
  else
  {
    sub_5DF98(2, "src/mdc.c", 35, "a_mdc is null or 0");
  }
}

//----- (00058008) --------------------------------------------------------
_DWORD *initialize_mdc_storage()
{
  _DWORD *mdc_storage_ptr; // r4
  _DWORD *hashtable_ptr; // r5
  int *errno_ptr; // r0
  _DWORD **hashtable_to_delete; // r0

  mdc_storage_ptr = calloc(1u, 4u);
  if ( mdc_storage_ptr )
  {
    hashtable_ptr = initialize_hashtable(20u, (int)generate_hash, (int)are_strings_equal, 0, (int)remove_mdc_key_value);
    *mdc_storage_ptr = hashtable_ptr;
    if ( !hashtable_ptr )
    {
      sub_5DF98(2, "src/mdc.c", 78, "zc_hashtable_new fail");
      hashtable_to_delete = (_DWORD **)mdc_storage_ptr;
      mdc_storage_ptr = 0;
      delete_mdc_hashtable(hashtable_to_delete);
    }
  }
  else
  {
    errno_ptr = _errno_location();
    sub_5DF98(2, "src/mdc.c", 69, "calloc fail, errno[%d]", *errno_ptr);
  }
  return mdc_storage_ptr;
}

//----- (000580C0) --------------------------------------------------------
int __fastcall add_metadata_to_hashtable(int *hashtable_ptr, const char *key, const char *value)
{
  char *metadata_buffer; // r0
  int mdc_buf_ptr; // r4
  int add_result; // r0
  int *errno_ptr; // r0

  metadata_buffer = (char *)calloc(1u, 2056u);
  mdc_buf_ptr = (int)metadata_buffer;
  if ( metadata_buffer )
  {
    snprintf(metadata_buffer, 1025u, "%s", key);
    *(_DWORD *)(mdc_buf_ptr + 2052) = snprintf((char *)(mdc_buf_ptr + 1025), 1025u, "%s", value);
    add_result = update_or_add_to_hashtable(*hashtable_ptr, mdc_buf_ptr, mdc_buf_ptr);
    if ( add_result )
    {
      sub_5DF98(2, "src/mdc.c", 101, "zc_hashtable_put fail");
      remove_mdc_key_value((void *)mdc_buf_ptr);
      return -1;
    }
  }
  else
  {
    errno_ptr = _errno_location();
    sub_5DF98(2, "src/mdc.c", 54, "calloc fail, errno[%d]", *errno_ptr);
    sub_5DF98(2, "src/mdc.c", 96, "zlog_mdc_kv_new failed");
    return -1;
  }
  return add_result;
}

//----- (000581B0) --------------------------------------------------------
_DWORD *__fastcall get_subsystem_status(_DWORD **status_pointer)
{
  return release_resource_list(*status_pointer);
}

//----- (000581B8) --------------------------------------------------------
int __fastcall handle_hashtable_get(int *hash_table, int key)
{
  int get_result; // r0

  get_result = process_task(*hash_table, key);
  if ( get_result )
    return get_result + 1025;
  sub_5DF98(2, "src/mdc.c", 121, "zc_hashtable_get fail");
  return 0;
}

//----- (000581FC) --------------------------------------------------------
int __fastcall process_hashtable_get(int *task_array_pointer, int task_id)
{
  int v2; // r4

  v2 = process_task(*task_array_pointer, task_id);
  if ( !v2 )
    sub_5DF98(2, "src/mdc.c", 134, "zc_hashtable_get fail");
  return v2;
}

//----- (00058238) --------------------------------------------------------
void __fastcall send_to_miner(_DWORD **miner_handle, const void *data)
{
  remove_key_from_hashtable(*miner_handle, data);
}

//----- (00058240) --------------------------------------------------------
int __fastcall log_record_info(const void **record, int log_level)
{
  if ( record )
    return sub_5DF98(log_level, "src/record.c", 15, "--record:[%p][%s:%p]--", record, (const char *)record, record[257]);
  else
    return sub_5DF98(2, "src/record.c", 14, "a_record is null or 0");
}

//----- (000582A0) --------------------------------------------------------
void __fastcall delete_log_record(void *record)
{
  if ( record )
  {
    sub_5DF98(0, "src/record.c", 22, "zlog_record_del[%p]", record);
    free(record);
  }
  else
  {
    sub_5DF98(2, "src/record.c", 21, "a_record is null or 0");
  }
}

//----- (00058304) --------------------------------------------------------
_DWORD *__fastcall create_log_record(const char *name, int value)
{
  _DWORD *log_record; // r4
  size_t name_length; // r0
  void *log_record_tmp; // r0
  int *errno_ptr; // r0

  if ( name )
  {
    if ( value )
    {
      log_record = calloc(1u, 1032u);
      if ( log_record )
      {
        name_length = strlen(name);
        if ( name_length > 1024 )
        {
          sub_5DF98(2, "src/record.c", 41, "name[%s] is too long", name);
          log_record_tmp = log_record;
          log_record = 0;
          delete_log_record(log_record_tmp);
        }
        else
        {
          memcpy(log_record, name, name_length + 1);
          log_record[257] = value;
          log_record_info((const void **)log_record, 0);
        }
      }
      else
      {
        errno_ptr = _errno_location();
        sub_5DF98(2, "src/record.c", 36, "calloc fail, errno[%d]", *errno_ptr);
      }
    }
    else
    {
      log_record = 0;
      sub_5DF98(2, "src/record.c", 32, "output is null or 0");
    }
  }
  else
  {
    log_record = 0;
    sub_5DF98(2, "src/record.c", 31, "name is null or 0");
  }
  return log_record;
}

//----- (00058414) --------------------------------------------------------
int __fastcall validate_and_log_records(const void *records, int verbosity_level)
{
  int last_processed_index; // r0
  int current_index; // r4

  if ( !records )
    return sub_5DF98(2, "src/record_table.c", 21, "records is null or 0");
  sub_5DF98(verbosity_level, "src/record_table.c", 22, "-record_table[%p]-", records);
  last_processed_index = get_first_non_zero_value((int)records);
  for ( current_index = last_processed_index; last_processed_index; current_index = last_processed_index )
  {
    log_record_info(*(const void ***)(current_index + 8), verbosity_level);
    last_processed_index = get_next_active_value((int)records, (unsigned int *)current_index);
  }
  return last_processed_index;
}

//----- (000584A4) --------------------------------------------------------
int __fastcall delete_record_table(_DWORD *record_table)
{
  if ( !record_table )
    return sub_5DF98(2, "src/record_table.c", 34, "records is null or 0");
  free_hashtable(record_table);
  return sub_5DF98(0, "src/record_table.c", 36, "zlog_record_table_del[%p]", record_table);
}

//----- (00058500) --------------------------------------------------------
_DWORD *create_record_table()
{
  _DWORD *record_table; // r0
  _DWORD *final_record_table; // r4

  record_table = initialize_hashtable(20u, (int)generate_hash, (int)are_strings_equal, 0, (int)delete_log_record);
  final_record_table = record_table;
  if ( record_table )
    validate_and_log_records(record_table, 0);
  else
    sub_5DF98(2, "src/record_table.c", 49, "zc_hashtable_new fail");
  return final_record_table;
}

//----- (0005856C) --------------------------------------------------------
bool __fastcall is_first_greater_than_second(_DWORD *first_number, _DWORD *second_number)
{
  return *first_number > *second_number;
}

//----- (00058584) --------------------------------------------------------
void __fastcall delete_file(char *file_ptr)
{
  sub_5DF98(0, "src/rotater.c", 126, "del onefile[%p]", file_ptr);
  sub_5DF98(0, "src/rotater.c", 127, "a_file->path[%s]", file_ptr + 4);
  free(file_ptr);
}

//----- (000585E4) --------------------------------------------------------
void __fastcall reset_status_structure(_DWORD *status_structure)
{
  _DWORD *zero_buffer_start; // r0
  _DWORD *previous_buffer_pointer; // r0

  status_structure[8] = 0;
  zero_buffer_start = status_structure + 10;
  *(zero_buffer_start - 1) = 0;
  status_structure[271] = 0;
  status_structure[270] = 0;
  status_structure[269] = 0;
  status_structure[267] = 0;
  status_structure[268] = 0;
  memset(zero_buffer_start, 0, 1025u);
  previous_buffer_pointer = (_DWORD *)status_structure[272];
  if ( previous_buffer_pointer )
    process_and_free_resources(previous_buffer_pointer);
  status_structure[272] = 0;
}

//----- (00058638) --------------------------------------------------------
int __fastcall print_rotater_info(int rotater_info_ptr, int log_level)
{
  int print_result; // r0
  _DWORD *rotater_list_entry; // r3
  int rotater_list_index; // r5
  int rotater_entry; // r12

  if ( !rotater_info_ptr )
    return sub_5DF98(2, "src/rotater.c", 34, "a_rotater is null or 0");
  print_result = sub_5DF98(
                   log_level,
                   "src/rotater.c",
                   50,
                   "--rotater[%p][%p,%s,%d][%s,%s,%s,%ld,%ld,%d,%d,%d]--",
                   (const void *)rotater_info_ptr,
                   (const void *)rotater_info_ptr,
                   *(const char **)(rotater_info_ptr + 24),
                   *(_DWORD *)(rotater_info_ptr + 28),
                   *(const char **)(rotater_info_ptr + 32),
                   *(const char **)(rotater_info_ptr + 36),
                   (const char *)(rotater_info_ptr + 40),
                   *(_DWORD *)(rotater_info_ptr + 1068),
                   *(_DWORD *)(rotater_info_ptr + 1072),
                   *(_DWORD *)(rotater_info_ptr + 1076),
                   *(_DWORD *)(rotater_info_ptr + 1080),
                   *(_DWORD *)(rotater_info_ptr + 1084));
  rotater_list_entry = *(_DWORD **)(rotater_info_ptr + 1088);
  if ( rotater_list_entry && (int)rotater_list_entry[1] > 0 )
  {
    rotater_list_index = 0;
    do
    {
      rotater_entry = *(_DWORD *)(*rotater_list_entry + 4 * rotater_list_index++);
      print_result = sub_5DF98(
                       log_level,
                       "src/rotater.c",
                       55,
                       "[%s,%d]->",
                       (const char *)(rotater_entry + 4),
                       *(_DWORD *)rotater_entry);
      rotater_list_entry = *(_DWORD **)(rotater_info_ptr + 1088);
    }
    while ( rotater_list_entry[1] > rotater_list_index );
  }
  return print_result;
}

//----- (00058750) --------------------------------------------------------
void __fastcall close_and_destroy_mutex(pthread_mutex_t *mutex_ptr)
{
  int file_descriptor; // r0
  int *errno_ptr; // r0
  int *errno_ptr_2; // r0

  if ( mutex_ptr )
  {
    file_descriptor = mutex_ptr[1].__count;
    if ( file_descriptor && close(file_descriptor) )
    {
      errno_ptr = _errno_location();
      sub_5DF98(2, "src/rotater.c", 68, "close fail, errno[%d]", *errno_ptr);
    }
    if ( pthread_mutex_destroy(mutex_ptr) )
    {
      errno_ptr_2 = _errno_location();
      sub_5DF98(2, "src/rotater.c", 73, "pthread_mutex_destroy fail, errno[%d]", *errno_ptr_2);
    }
    sub_5DF98(0, "src/rotater.c", 76, "zlog_rotater_del[%p]", mutex_ptr);
    free(mutex_ptr);
  }
  else
  {
    sub_5DF98(2, "src/rotater.c", 64, "a_rotater is null or 0");
  }
}

//----- (00058834) --------------------------------------------------------
pthread_mutex_t *__fastcall initialize_mutex_and_open_file(const char *file_name)
{
  pthread_mutex_t *mutex_ptr; // r0
  pthread_mutex_t *initialized_mutex; // r4
  int file_descriptor; // r0
  int *errno_ptr_1; // r0
  pthread_mutex_t *mutex_to_free; // r0
  int *errno_ptr_2; // r0
  int *errno_ptr_3; // r0
  pthread_mutex_t *mutex_to_destroy; // r0

  if ( file_name )
  {
    mutex_ptr = (pthread_mutex_t *)calloc(1u, 1092u);
    initialized_mutex = mutex_ptr;
    if ( mutex_ptr )
    {
      if ( pthread_mutex_init(mutex_ptr, 0) )
      {
        errno_ptr_1 = _errno_location();
        sub_5DF98(2, "src/rotater.c", 95, "pthread_mutex_init fail, errno[%d]", *errno_ptr_1);
        mutex_to_free = initialized_mutex;
        initialized_mutex = 0;
        free(mutex_to_free);
      }
      else
      {
        file_descriptor = open64(file_name);
        if ( file_descriptor < 0 )
        {
          errno_ptr_3 = _errno_location();
          sub_5DF98(2, "src/rotater.c", 108, "open file[%s] fail, errno[%d]", file_name, *errno_ptr_3);
          mutex_to_destroy = initialized_mutex;
          initialized_mutex = 0;
          close_and_destroy_mutex(mutex_to_destroy);
        }
        else
        {
          initialized_mutex[1].__count = file_descriptor;
          initialized_mutex[1].__lock = (int)file_name;
        }
      }
    }
    else
    {
      errno_ptr_2 = _errno_location();
      sub_5DF98(2, "src/rotater.c", 90, "calloc fail, errno[%d]", *errno_ptr_2);
    }
  }
  else
  {
    initialized_mutex = 0;
    sub_5DF98(2, "src/rotater.c", 86, "lock_file is null or 0");
  }
  return initialized_mutex;
}
// 12198: using guessed type int __fastcall open64(_DWORD);

//----- (00058958) --------------------------------------------------------
int __fastcall sub_58958(int a1, const char *a2, unsigned int a3, const char *a4, int a5, int a6)
{
  int v10; // r0
  int *v11; // r0
  int *v12; // r6
  int v14; // r6
  int v15; // r0
  int *v16; // r0
  int *v17; // r7
  char *v18; // r0
  char *v19; // r10
  int v20; // r7
  int v21; // r3
  _BYTE *v22; // r1
  int v23; // r5
  int v24; // r0
  int v25; // r7
  _DWORD *v26; // r0
  int v27; // r0
  int v28; // r5
  int v29; // r7
  int v30; // r10
  char *v31; // r0
  char *v32; // r6
  unsigned int v33; // r5
  int v34; // r0
  int v35; // r3
  bool v36; // cf
  const char *v37; // r5
  const char *v38; // t1
  int v39; // r3
  int *v40; // r0
  unsigned int v41; // r7
  const char *v42; // r7
  _DWORD *v43; // r3
  int v44; // r5
  int v45; // r3
  int v46; // r7
  unsigned int v47; // r3
  _DWORD *v48; // r3
  int v49; // r12
  const char *v50; // r8
  int *v51; // r0
  int *v52; // r0
  _DWORD *v53; // r1
  int v54; // r3
  int i; // r5
  int v56; // r2
  int v57; // r3
  const char *v58; // r7
  int *v59; // r2
  int v60; // r3
  int v61; // r5
  unsigned int v62; // r5
  int *v63; // r0
  unsigned int v64; // r5
  int *v65; // r0
  unsigned int v66; // r11
  int *v67; // r0
  int *v68; // r0
  int *v69; // r0
  int *v70; // r0
  int *v71; // r0
  int *v72; // r0
  int *v73; // r0
  int *v74; // r0
  const char *v75; // [sp+10h] [bp-4B0h]
  int v76; // [sp+24h] [bp-49Ch] BYREF
  char v77[48]; // [sp+28h] [bp-498h] BYREF
  __int64 v78; // [sp+58h] [bp-468h]
  int s[268]; // [sp+90h] [bp-430h] BYREF

  if ( !a2 )
  {
    sub_5DF98(2, "src/rotater.c", 536, "base_path is null or 0");
    return -1;
  }
  memset(&s[2], 0, 16);
  s[0] = 1;
  v10 = pthread_mutex_trylock((pthread_mutex_t *)a1);
  if ( v10 == 16 )
  {
    sub_5DF98(1, "src/rotater.c", 481, "pthread_mutex_trylock fail, as lock_mutex is locked by other threads");
    goto LABEL_7;
  }
  if ( v10 )
  {
    sub_5DF98(2, "src/rotater.c", 484, "pthread_mutex_trylock fail, rc[%d]", v10);
    goto LABEL_7;
  }
  if ( fcntl(*(_DWORD *)(a1 + 28), 13, s) )
  {
    v11 = _errno_location();
    v12 = v11;
    if ( ((*v11 - 11) & 0xFFFFFFFD) != 0 )
    {
      sub_5DF98(2, "src/rotater.c", 495, "lock fd[%d] fail, errno[%d]", *(_DWORD *)(a1 + 28), *v11);
      if ( !pthread_mutex_unlock((pthread_mutex_t *)a1) )
      {
LABEL_7:
        sub_5DF98(1, "src/rotater.c", 539, "zlog_rotater_trylock fail, maybe lock by other process or threads");
        return 0;
      }
    }
    else
    {
      sub_5DF98(1, "src/rotater.c", 493, "fcntl lock fail, as file is lock by other process");
      if ( !pthread_mutex_unlock((pthread_mutex_t *)a1) )
        goto LABEL_7;
    }
    sub_5DF98(2, "src/rotater.c", 498, "pthread_mutex_unlock fail, errno[%d]", *v12);
    goto LABEL_7;
  }
  v14 = _xstat64(3, a2, v77);
  if ( v14 )
  {
    v16 = _errno_location();
    v14 = -1;
    sub_5DF98(2, "src/rotater.c", 545, "stat [%s] fail, errno[%d]", a2, *v16);
    goto LABEL_10;
  }
  if ( a5 >= v78 + a3 )
    goto LABEL_10;
  *(_DWORD *)(a1 + 32) = a2;
  *(_DWORD *)(a1 + 36) = a4;
  *(_DWORD *)(a1 + 1084) = a6;
  if ( *a4 )
  {
    v18 = strchr(a4, 35);
    v19 = v18;
    if ( !v18 )
    {
      sub_5DF98(2, "src/rotater.c", 374, "no # in archive_path[%s]", a4);
      goto LABEL_102;
    }
    s[0] = 0;
    _isoc99_sscanf(v18, "#%d%n", a1 + 1076, s);
    v20 = s[0];
    if ( !s[0] )
    {
      v20 = 1;
      s[0] = 1;
    }
    v21 = (unsigned __int8)v19[v20];
    if ( v21 == 114 )
    {
      *(_DWORD *)(a1 + 1080) = 1;
    }
    else
    {
      if ( v21 != 115 )
      {
        sub_5DF98(2, "src/rotater.c", 386, "#r or #s not found");
        goto LABEL_102;
      }
      *(_DWORD *)(a1 + 1080) = 2;
    }
    v22 = *(_BYTE **)(a1 + 36);
    v23 = v19 - v22;
    if ( (unsigned int)(v19 - v22) > 1024 )
    {
      sub_5DF98(2, "src/rotater.c", 393, "sizeof glob_path not enough,len[%ld]", v23);
    }
    else
    {
      v75 = (const char *)(a1 + 40);
      memcpy((void *)(a1 + 40), v22, v19 - v22);
      v24 = snprintf((char *)(a1 + 40 + v23), 1025 - v23, "*%s", &v19[v20 + 1]);
      v25 = v24;
      if ( v24 >= 0 && 1025 - v23 >= (unsigned int)v24 )
      {
        *(_DWORD *)(a1 + 1068) = v23;
        *(_DWORD *)(a1 + 1072) = v23 + 1;
        goto LABEL_31;
      }
      v69 = _errno_location();
      sub_5DF98(2, "src/rotater.c", 401, "nwirte[%d], overflow or errno[%d]", v25, *v69);
    }
LABEL_102:
    sub_5DF98(2, "src/rotater.c", 437, "zlog_rotater_parse_archive_path fail");
    goto LABEL_53;
  }
  v75 = (const char *)(a1 + 40);
  v41 = snprintf((char *)(a1 + 40), 1025u, "%s.*", a2);
  if ( v41 > 1025 )
  {
    v72 = _errno_location();
    sub_5DF98(2, "src/rotater.c", 360, "nwirte[%d], overflow or errno[%d]", v41, *v72);
    goto LABEL_102;
  }
  v42 = *(const char **)(a1 + 32);
  *(_DWORD *)(a1 + 1080) = 1;
  *(_DWORD *)(a1 + 1076) = 0;
  *(_DWORD *)(a1 + 1068) = strlen(v42) + 1;
  *(_DWORD *)(a1 + 1072) = strlen(v42) + 2;
LABEL_31:
  v26 = initialize_array_list((int)delete_file);
  *(_DWORD *)(a1 + 1088) = v26;
  if ( !v26 )
  {
    sub_5DF98(2, "src/rotater.c", 191, "zc_arraylist_new fail");
    goto LABEL_52;
  }
  v27 = glob64(v75, 7, 0, s);
  v28 = v27;
  if ( v27 != 3 )
  {
    if ( !v27 )
    {
      v29 = s[0] - 1;
      if ( s[0] )
      {
        v30 = s[1] - 4;
        while ( 1 )
        {
          v38 = *(const char **)(v30 + 4);
          v30 += 4;
          v37 = v38;
          if ( !strcmp(*(const char **)(a1 + 32), v38) || v37[strlen(v37) - 1] == 47 )
            goto LABEL_45;
          v31 = (char *)calloc(1u, 1032u);
          v32 = v31;
          if ( !v31 )
            break;
          v33 = snprintf(v31 + 4, 1025u, "%s", v37);
          if ( v33 > 1024 )
          {
            v40 = _errno_location();
            sub_5DF98(2, "src/rotater.c", 155, "snprintf fail or overflow, nwrite=[%d], errno[%d]", v33, *v40);
            goto LABEL_50;
          }
          v34 = *(_DWORD *)(a1 + 1068);
          v76 = 0;
          _isoc99_sscanf(&v32[v34 + 4], "%d%n", v32, &v76);
          v35 = *(_DWORD *)(a1 + 1076);
          if ( v35 && v35 > v76 )
          {
            sub_5DF98(1, "src/rotater.c", 164, "aa.1.log is not expect, need aa.01.log");
LABEL_50:
            free(v32);
LABEL_45:
            sub_5DF98(1, "src/rotater.c", 211, "not the expect pattern file");
            goto LABEL_42;
          }
          if ( insert_into_array(
                 *(_DWORD *)(a1 + 1088),
                 (int (__fastcall *)(_DWORD, int))is_first_greater_than_second,
                 (int)v32) )
          {
            sub_5DF98(2, "src/rotater.c", 219, "zc_arraylist_sortadd fail");
            globfree64(s);
            goto LABEL_52;
          }
LABEL_42:
          v36 = v29-- != 0;
          if ( !v36 )
          {
            v14 = 0;
            goto LABEL_46;
          }
        }
        v52 = _errno_location();
        sub_5DF98(2, "src/rotater.c", 149, "calloc fail, errno[%d]", *v52);
        goto LABEL_45;
      }
      goto LABEL_46;
    }
    v71 = _errno_location();
    sub_5DF98(2, "src/rotater.c", 200, "glob err, rc=[%d], errno[%d]", v28, *v71);
LABEL_52:
    sub_5DF98(2, "src/rotater.c", 443, "zlog_rotater_add_archive_files fail");
    goto LABEL_53;
  }
LABEL_46:
  globfree64(s);
  v39 = *(_DWORD *)(a1 + 1080);
  if ( v39 != 1 )
  {
    if ( v39 != 2 )
    {
LABEL_48:
      reset_status_structure((_DWORD *)a1);
      goto LABEL_10;
    }
    v53 = *(_DWORD **)(a1 + 1088);
    v54 = v53[1];
    if ( v54 <= 0 )
    {
LABEL_98:
      v61 = 0;
    }
    else
    {
      for ( i = 0; i < v54; ++i )
      {
        v56 = *(_DWORD *)(a1 + 1084);
        v57 = v54 - v56;
        if ( v56 > 0 && v57 > i )
        {
          v58 = (const char *)(*(_DWORD *)(*v53 + 4 * i) + 4);
          if ( unlink(v58) )
          {
            v70 = _errno_location();
            sub_5DF98(2, "src/rotater.c", 246, "unlink[%s] fail, errno[%d]", v58, *v70);
            goto LABEL_88;
          }
          v53 = *(_DWORD **)(a1 + 1088);
        }
        v54 = v53[1];
      }
      if ( v54 <= 0 )
        goto LABEL_98;
      v59 = *(int **)(*v53 + 4 * (v54 + 1073741823));
      if ( !v59 )
      {
        sub_5DF98(2, "src/rotater.c", 256, "zc_arraylist_get fail");
LABEL_88:
        sub_5DF98(2, "src/rotater.c", 456, "zlog_rotater_seq_files fail");
        goto LABEL_53;
      }
      v60 = v54 - 1;
      if ( v60 < *v59 )
        v60 = *v59;
      v61 = v60 + 1;
    }
    memset(s, 0, 1025u);
    v62 = snprintf(
            (char *)s,
            1025u,
            "%.*s%0*d%s",
            *(_DWORD *)(a1 + 1068),
            v75,
            *(_DWORD *)(a1 + 1076),
            v61,
            &v75[*(_DWORD *)(a1 + 1072)]);
    if ( v62 > 1024 )
    {
      v73 = _errno_location();
      sub_5DF98(2, "src/rotater.c", 272, "nwirte[%d], overflow or errno[%d]", v62, *v73);
    }
    else
    {
      if ( !rename(*(const char **)(a1 + 32), (const char *)s) )
        goto LABEL_48;
      v63 = _errno_location();
      sub_5DF98(
        2,
        "src/rotater.c",
        277,
        "rename[%s]->[%s] fail, errno[%d]",
        *(const char **)(a1 + 32),
        (const char *)s,
        *v63);
    }
    goto LABEL_88;
  }
  v43 = *(_DWORD **)(a1 + 1088);
  v44 = v43[1] - 1;
  if ( v44 >= 0 )
  {
    v45 = *(_DWORD *)(*v43 + 4 * v44);
    if ( !v45 )
    {
LABEL_90:
      sub_5DF98(2, "src/rotater.c", 297, "zc_arraylist_get fail");
      goto LABEL_69;
    }
    v46 = 4 * v44 - 4;
    while ( 1 )
    {
      v49 = *(_DWORD *)(a1 + 1084);
      v50 = (const char *)(v45 + 4);
      if ( v49 <= 0 || v44 < v49 - 1 )
      {
        memset(s, 0, 1025u);
        v47 = snprintf(
                (char *)s,
                1025u,
                "%.*s%0*d%s",
                *(_DWORD *)(a1 + 1068),
                v75,
                *(_DWORD *)(a1 + 1076),
                v44 + 1,
                &v75[*(_DWORD *)(a1 + 1072)]);
        if ( v47 > 1024 )
        {
          v66 = v47;
          v67 = _errno_location();
          sub_5DF98(2, "src/rotater.c", 318, "nwirte[%d], overflow or errno[%d]", v66, *v67);
          goto LABEL_69;
        }
        if ( rename(v50, (const char *)s) )
        {
          v68 = _errno_location();
          sub_5DF98(2, "src/rotater.c", 323, "rename[%s]->[%s] fail, errno[%d]", v50, (const char *)s, *v68);
          goto LABEL_69;
        }
      }
      else if ( unlink((const char *)(v45 + 4)) )
      {
        v51 = _errno_location();
        sub_5DF98(2, "src/rotater.c", 305, "unlink[%s] fail, errno[%d]", v50, *v51);
        goto LABEL_69;
      }
      v36 = v44-- != 0;
      if ( !v36 )
        break;
      v48 = *(_DWORD **)(a1 + 1088);
      if ( v48[1] > v44 )
      {
        v45 = *(_DWORD *)(*v48 + v46);
        v46 -= 4;
        if ( v45 )
          continue;
      }
      goto LABEL_90;
    }
  }
  memset(s, 0, 1025u);
  v64 = snprintf(
          (char *)s,
          1025u,
          "%.*s%0*d%s",
          *(_DWORD *)(a1 + 1068),
          v75,
          *(_DWORD *)(a1 + 1076),
          0,
          &v75[*(_DWORD *)(a1 + 1072)]);
  if ( v64 <= 1024 )
  {
    if ( rename(*(const char **)(a1 + 32), (const char *)s) )
    {
      v65 = _errno_location();
      sub_5DF98(
        2,
        "src/rotater.c",
        340,
        "rename[%s]->[%s] fail, errno[%d]",
        *(const char **)(a1 + 32),
        (const char *)s,
        *v65);
      goto LABEL_69;
    }
    goto LABEL_48;
  }
  v74 = _errno_location();
  sub_5DF98(2, "src/rotater.c", 335, "nwirte[%d], overflow or errno[%d]", v64, *v74);
LABEL_69:
  sub_5DF98(2, "src/rotater.c", 450, "zlog_rotater_roll_files fail");
LABEL_53:
  v14 = -1;
  reset_status_structure((_DWORD *)a1);
  sub_5DF98(2, "src/rotater.c", 560, "zlog_rotater_lsmv [%s] fail, return", a2);
LABEL_10:
  memset(&s[2], 0, 16);
  v15 = *(_DWORD *)(a1 + 28);
  s[0] = 2;
  if ( !fcntl(v15, 13, s) )
  {
    if ( !pthread_mutex_unlock((pthread_mutex_t *)a1) )
      return v14;
    v17 = _errno_location();
    goto LABEL_93;
  }
  v17 = _errno_location();
  sub_5DF98(2, "src/rotater.c", 518, "unlock fd[%s] fail, errno[%d]", *(const char **)(a1 + 28), *v17);
  if ( pthread_mutex_unlock((pthread_mutex_t *)a1) )
LABEL_93:
    sub_5DF98(2, "src/rotater.c", 523, "pthread_mutext_unlock fail, errno[%d]", *v17);
  sub_5DF98(2, "src/rotater.c", 569, "zlog_rotater_unlock fail");
  return v14;
}
// 1231C: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);
// 123F4: using guessed type int __fastcall glob64(_DWORD, _DWORD, _DWORD, _DWORD);
// 12490: using guessed type int __fastcall globfree64(_DWORD);
// 12574: using guessed type int __fastcall _xstat64(_DWORD, _DWORD, _DWORD);
// 58958: using guessed type char var_498[48];

//----- (000595C0) --------------------------------------------------------
int __fastcall process_rule_execution(int rule_info, int execution_context)
{
  int rule_offset_ptr; // r5
  int (__fastcall *execute_record)(int *); // r1
  __int64 buffer_start_end; // r2
  int execution_result; // r0
  int record_args[7]; // [sp+Ch] [bp-1Ch] BYREF

  rule_offset_ptr = rule_info + 8192;
  if ( *(_DWORD *)(rule_info + 8324) )
  {
    if ( check_condition_and_execute(*(_DWORD *)(rule_info + 6264), execution_context) )
    {
      sub_5DF98(2, "src/rule.c", 391, "zlog_format_gen_msg fail");
      return -1;
    }
    else
    {
      **(_BYTE **)(*(_DWORD *)(execution_context + 28) + 4) = 0;
      execute_record = *(int (__fastcall **)(int *))(rule_offset_ptr + 132);
      buffer_start_end = *(_QWORD *)*(_DWORD *)(execution_context + 28);
      record_args[2] = rule_info + 7297;
      record_args[0] = buffer_start_end;
      record_args[1] = HIDWORD(buffer_start_end) - buffer_start_end;
      execution_result = execute_record(record_args);
      if ( execution_result )
      {
        sub_5DF98(2, "src/rule.c", 401, "a_rule->record fail");
        return -1;
      }
    }
  }
  else
  {
    sub_5DF98(
      2,
      "src/rule.c",
      386,
      "user defined record funcion for [%s] not set, no output",
      (const char *)(rule_info + 6272));
    return -1;
  }
  return execution_result;
}

//----- (000596B0) --------------------------------------------------------
int __fastcall write_log_file(int log_context, int log_entry)
{
  int *log_file_descriptor; // r4
  int status; // r9
  int file_offset_pointer; // r10
  int file_descriptor; // r0
  __int64 new_file_timestamp; // r6
  unsigned int max_log_file_flushes; // r3
  unsigned int current_log_file_flushes; // r2
  int *errno_location_ptr; // r0
  int *errno_value_ptr; // r7
  int opened_file_descriptor; // r0
  int fd_to_sync; // r0
  int *fsync_errno_ptr; // r0
  int *write_errno_ptr; // r0
  __int64 file_stats[12]; // [sp+8h] [bp-90h] BYREF
  __int64 file_timestamp; // [sp+68h] [bp-30h]

  log_file_descriptor = (int *)(log_context + 4096);
  status = check_condition_and_execute(*(_DWORD *)(log_context + 6264), log_entry);
  if ( status )
  {
    sub_5DF98(2, "src/rule.c", 84, "zlog_format_gen_msg fail");
    return -1;
  }
  if ( _xstat64(3, log_context + 4144, file_stats) )
  {
    errno_location_ptr = _errno_location();
    errno_value_ptr = errno_location_ptr;
    if ( *errno_location_ptr != 2 )
    {
      sub_5DF98(
        2,
        "src/rule.c",
        91,
        "stat fail on [%s], errno[%d]",
        (const char *)(log_context + 4144),
        *errno_location_ptr);
      return -1;
    }
    close(log_file_descriptor[270]);
    opened_file_descriptor = open64(log_context + 4144);
    log_file_descriptor[270] = opened_file_descriptor;
    if ( opened_file_descriptor >= 0 )
    {
      if ( _xstat64(3, log_context + 4144, file_stats) )
      {
        status = -1;
        sub_5DF98(
          2,
          "src/rule.c",
          114,
          "stat fail on new file[%s], errno[%d]",
          (const char *)(log_context + 4144),
          *errno_value_ptr);
        return status;
      }
      file_descriptor = log_file_descriptor[270];
      file_offset_pointer = log_context + 5200;
      goto LABEL_5;
    }
LABEL_24:
    status = -1;
    sub_5DF98(
      2,
      "src/rule.c",
      107,
      "open file[%s] fail, errno[%d]",
      (const char *)(log_context + 4144),
      *errno_value_ptr);
    return status;
  }
  file_offset_pointer = log_context + 5200;
  file_descriptor = log_file_descriptor[270];
  if ( file_timestamp != *(_QWORD *)(log_context + 5192) || file_stats[0] != *(_QWORD *)(log_context + 5184) )
  {
    close(file_descriptor);
    file_descriptor = open64(log_context + 4144);
    log_file_descriptor[270] = file_descriptor;
    if ( file_descriptor >= 0 )
    {
LABEL_5:
      new_file_timestamp = file_timestamp;
      *(_QWORD *)(log_context + 5184) = file_stats[0];
      *(_QWORD *)(file_offset_pointer - 8) = new_file_timestamp;
      goto LABEL_6;
    }
    errno_value_ptr = _errno_location();
    goto LABEL_24;
  }
LABEL_6:
  if ( write(
         file_descriptor,
         **(const void ***)(log_entry + 28),
         *(_DWORD *)(*(_DWORD *)(log_entry + 28) + 4) - **(_DWORD **)(log_entry + 28)) < 0 )
  {
    write_errno_ptr = _errno_location();
    sub_5DF98(2, "src/rule.c", 125, "write fail, errno[%d]", *write_errno_ptr);
    return -1;
  }
  else
  {
    max_log_file_flushes = log_file_descriptor[538];
    if ( max_log_file_flushes )
    {
      current_log_file_flushes = log_file_descriptor[539] + 1;
      if ( max_log_file_flushes <= current_log_file_flushes )
      {
        fd_to_sync = log_file_descriptor[270];
        log_file_descriptor[539] = 0;
        if ( fsync(fd_to_sync) )
        {
          fsync_errno_ptr = _errno_location();
          sub_5DF98(2, "src/rule.c", 133, "fsync[%d] fail, errno[%d]", log_file_descriptor[270], *fsync_errno_ptr);
        }
      }
      else
      {
        log_file_descriptor[539] = current_log_file_flushes;
      }
    }
  }
  return status;
}
// 12198: using guessed type int __fastcall open64(_DWORD);
// 12574: using guessed type int __fastcall _xstat64(_DWORD, _DWORD, _DWORD);

//----- (00059954) --------------------------------------------------------
int __fastcall process_rule(int base_address, int output_address)
{
  int rule_index; // r4
  int base_address_offset; // r6
  _DWORD *rule_info_ptr; // r3
  int output_ptr_address; // r2
  int rule_count; // r0
  _BYTE *output_buffer; // r1
  int rule_function_address; // r0

  base_address_offset = base_address + 4096;
  rule_info_ptr = *(_DWORD **)(base_address + 6236);
  if ( !rule_info_ptr )
    return base_address + 5208;
  output_ptr_address = *(_DWORD *)(output_address + 20);
  rule_count = rule_info_ptr[1];
  output_buffer = *(_BYTE **)output_ptr_address;
  if ( rule_count > 0 )
    rule_index = 0;
  *(_DWORD *)(output_ptr_address + 4) = output_buffer;
  if ( rule_count > 0 )
  {
    do
    {
      rule_function_address = *(_DWORD *)(*rule_info_ptr + 4 * rule_index++);
      if ( (*(int (**)(void))(rule_function_address + 9264))() )
      {
        sub_5DF98(2, "src/rule.c", 151, "zlog_spec_gen_path fail");
        return 0;
      }
      rule_info_ptr = *(_DWORD **)(base_address_offset + 2140);
    }
    while ( rule_info_ptr[1] > rule_index );
    output_buffer = *(_BYTE **)(*(_DWORD *)(output_address + 20) + 4);
  }
  *output_buffer = 0;
  return **(_DWORD **)(output_address + 20);
}
// 599A4: variable 'rule_index' is possibly undefined

//----- (00059A0C) --------------------------------------------------------
int __fastcall sub_59A0C(int a1, int a2)
{
  int *v2; // r4
  const char *v5; // r6
  int v6; // r0
  int v7; // r9
  int v8; // r2
  size_t v9; // r5
  unsigned int v10; // r3
  int v11; // r8
  unsigned int v13; // r2
  int *v14; // r0
  int *v15; // r0
  int v16; // r0
  int v17; // r7
  const char *v18; // r0
  int *v19; // r0
  int *v20; // r0
  int *v21; // r0
  char v22[48]; // [sp+8h] [bp-88h] BYREF
  __int64 v23; // [sp+38h] [bp-58h]

  v2 = (int *)(a1 + 4096);
  if ( check_condition_and_execute(*(_DWORD *)(a1 + 6264), a2) )
  {
    sub_5DF98(2, "src/rule.c", 167, "zlog_format_gen_msg fail");
    return -1;
  }
  v5 = (const char *)(a1 + 4144);
  v6 = open64(a1 + 4144);
  v7 = v6;
  if ( v6 < 0 )
  {
    v19 = _errno_location();
    v11 = -1;
    sub_5DF98(2, "src/rule.c", 174, "open file[%s] fail, errno[%d]", (const char *)(a1 + 4144), *v19);
    return v11;
  }
  v8 = *(_DWORD *)(a2 + 28);
  v9 = *(_DWORD *)(v8 + 4) - *(_DWORD *)v8;
  if ( write(v6, *(const void **)v8, v9) < 0 )
  {
    v20 = _errno_location();
    sub_5DF98(2, "src/rule.c", 180, "write fail, errno[%d]", *v20);
    v11 = -1;
    close(v7);
    return v11;
  }
  v10 = v2[538];
  if ( v10 )
  {
    v13 = v2[539] + 1;
    if ( v10 <= v13 )
    {
      v2[539] = 0;
      if ( fsync(v7) )
      {
        v14 = _errno_location();
        sub_5DF98(2, "src/rule.c", 187, "fsync[%d] fail, errno[%d]", v7, *v14);
      }
    }
    else
    {
      v2[539] = v13;
    }
  }
  if ( close(v7) < 0 )
  {
    v21 = _errno_location();
    sub_5DF98(2, "src/rule.c", 191, "close fail, maybe cause by write, errno[%d]", *v21);
    return -1;
  }
  if ( v2[276] < v9 )
  {
    sub_5DF98(0, "src/rule.c", 197, "one msg's len[%ld] > archive_max_size[%ld], no rotate", v9, v2[276]);
    return 0;
  }
  else
  {
    if ( !_xstat64(3, a1 + 4144, v22) )
    {
      if ( v23 + v9 < v2[276] )
        return 0;
      v16 = a1;
      v17 = *(_DWORD *)(dword_99EEC8 + 5160);
      v18 = (const char *)process_rule(v16, a2);
      if ( !rotate_log_files(v17, v5, v9, v18, v2[276], v2[277]) )
        return 0;
      v11 = -1;
      sub_5DF98(2, "src/rule.c", 214, "zlog_rotater_rotate fail");
      return v11;
    }
    v15 = _errno_location();
    sub_5DF98(1, "src/rule.c", 202, "stat [%s] fail, errno[%d], maybe in rotating", (const char *)(a1 + 4144), *v15);
    return 0;
  }
}
// 12198: using guessed type int __fastcall open64(_DWORD);
// 12574: using guessed type int __fastcall _xstat64(_DWORD, _DWORD, _DWORD);
// 99EEC8: using guessed type int dword_99EEC8;
// 59A0C: using guessed type char var_88[48];

//----- (00059CD4) --------------------------------------------------------
int __fastcall sub_59CD4(int a1, int a2)
{
  int v2; // r7
  int v3; // r5
  int v4; // r2
  _DWORD *v5; // r3
  _BYTE *v7; // r0
  int v8; // r1
  int v9; // r4
  int v10; // r0
  int result; // r0
  int (__fastcall *v12)(__int64 *); // r1
  __int64 v13; // r2
  int v14; // r12
  __int64 v15; // [sp+Ch] [bp-24h] BYREF
  int v16; // [sp+14h] [bp-1Ch]

  v2 = a1 + 8192;
  if ( *(_DWORD *)(a1 + 8324) )
  {
    v3 = a1 + 4096;
    v4 = *(_DWORD *)(a2 + 16);
    v5 = *(_DWORD **)(a1 + 5172);
    v7 = *(_BYTE **)v4;
    v8 = v5[1];
    *(_DWORD *)(v4 + 4) = *(_DWORD *)v4;
    if ( v8 > 0 )
    {
      v9 = 0;
      do
      {
        v10 = *(_DWORD *)(*v5 + 4 * v9++);
        if ( (*(int (**)(void))(v10 + 9260))() )
        {
          sub_5DF98(2, "src/rule.c", 417, "zlog_spec_gen_path fail");
          return -1;
        }
        v5 = *(_DWORD **)(v3 + 1076);
      }
      while ( v9 < v5[1] );
      v7 = *(_BYTE **)(*(_DWORD *)(a2 + 16) + 4);
    }
    *v7 = 0;
    if ( check_condition_and_execute(*(_DWORD *)(v3 + 2168), a2) )
    {
      sub_5DF98(2, "src/rule.c", 420, "zlog_format_gen_msg fail");
      return -1;
    }
    else
    {
      **(_BYTE **)(*(_DWORD *)(a2 + 28) + 4) = 0;
      v12 = *(int (__fastcall **)(__int64 *))(v2 + 132);
      v13 = *(_QWORD *)*(_DWORD *)(a2 + 28);
      v14 = **(_DWORD **)(a2 + 16);
      HIDWORD(v13) -= v13;
      v15 = v13;
      v16 = v14;
      result = v12(&v15);
      if ( result )
      {
        sub_5DF98(2, "src/rule.c", 430, "a_rule->record fail");
        return -1;
      }
    }
  }
  else
  {
    sub_5DF98(
      2,
      "src/rule.c",
      413,
      "user defined record funcion for [%s] not set, no output",
      (const char *)(a1 + 6272));
    return -1;
  }
  return result;
}

//----- (00059E54) --------------------------------------------------------
int __fastcall execute_command_and_log_error(int command_struct, int error_message)
{
  int execution_result; // r4
  int *errno_ptr; // r0

  execution_result = check_condition_and_execute(*(_DWORD *)(command_struct + 6264), error_message);
  if ( execution_result )
  {
    sub_5DF98(2, "src/rule.c", 459, "zlog_format_gen_msg fail");
    return -1;
  }
  else if ( write(
              2,
              **(const void ***)(error_message + 28),
              *(_DWORD *)(*(_DWORD *)(error_message + 28) + 4) - **(_DWORD **)(error_message + 28)) < 0 )
  {
    errno_ptr = _errno_location();
    execution_result = -1;
    sub_5DF98(2, "src/rule.c", 465, "write fail, errno[%d]", *errno_ptr);
  }
  return execution_result;
}

//----- (00059EF8) --------------------------------------------------------
int __fastcall process_rule_action(int rule_engine_context, int action_context)
{
  int status; // r4
  int *errno_pointer; // r0

  status = check_condition_and_execute(*(_DWORD *)(rule_engine_context + 6264), action_context);
  if ( status )
  {
    sub_5DF98(2, "src/rule.c", 441, "zlog_format_gen_msg fail");
    return -1;
  }
  else if ( write(
              1,
              **(const void ***)(action_context + 28),
              *(_DWORD *)(*(_DWORD *)(action_context + 28) + 4) - **(_DWORD **)(action_context + 28)) < 0 )
  {
    errno_pointer = _errno_location();
    status = -1;
    sub_5DF98(2, "src/rule.c", 447, "write fail, errno[%d]", *errno_pointer);
  }
  return status;
}

//----- (00059F9C) --------------------------------------------------------
int __fastcall execute_rule_action(int rule_struct_ptr, int action_data_ptr)
{
  int rule_data_offset; // r4
  int execution_result; // r5
  int *errno_ptr; // r0

  rule_data_offset = rule_struct_ptr + 4096;
  execution_result = check_condition_and_execute(*(_DWORD *)(rule_struct_ptr + 6264), action_data_ptr);
  if ( execution_result )
  {
    sub_5DF98(2, "src/rule.c", 345, "zlog_format_gen_msg fail");
    return -1;
  }
  else if ( write(
              *(_DWORD *)(rule_data_offset + 2148),
              **(const void ***)(action_data_ptr + 28),
              *(_DWORD *)(*(_DWORD *)(action_data_ptr + 28) + 4) - **(_DWORD **)(action_data_ptr + 28)) < 0 )
  {
    errno_ptr = _errno_location();
    execution_result = -1;
    sub_5DF98(2, "src/rule.c", 352, "write fail, errno[%d]", *errno_ptr);
  }
  return execution_result;
}

//----- (0005A040) --------------------------------------------------------
int __fastcall process_asic_status(int status_data, int asic_info)
{
  int enhanced_status_offset; // r6
  int execution_result; // r5
  int asic_chip_level; // r0

  enhanced_status_offset = status_data + 4096;
  execution_result = check_condition_and_execute(*(_DWORD *)(status_data + 6264), asic_info);
  if ( execution_result )
  {
    sub_5DF98(2, "src/rule.c", 364, "zlog_format_gen_msg fail");
    return -1;
  }
  else
  {
    asic_chip_level = getASICChipLevel(*(int **)(dword_99EEC8 + 9280), *(_DWORD *)(*(_DWORD *)(asic_info + 8) + 292));
    **(_BYTE **)(*(_DWORD *)(asic_info + 28) + 4) = 0;
    syslog(
      *(_DWORD *)(enhanced_status_offset + 2164) | *(_DWORD *)(asic_chip_level + 2060),
      "%s",
      **(const char ***)(asic_info + 28));
  }
  return execution_result;
}
// 99EEC8: using guessed type int dword_99EEC8;

//----- (0005A0D4) --------------------------------------------------------
int __fastcall process_logging_event(int logging_context, int event_data)
{
  int rule_index; // r4
  _DWORD *context_pointer; // r5
  _DWORD *rule_list; // r3
  int event_pointer; // r2
  int rule_count; // r1
  _BYTE *event_str; // r0
  int current_rule; // r0
  int v10; // r4
  int file_descriptor; // r0
  int fd; // r7
  unsigned int sync_period; // r3
  unsigned int sync_counter; // r2
  int *errno_loc_close; // r0
  int *errno_loc_fsync; // r0
  int *errno_loc_open; // r0
  int *errno_loc_write; // r0

  context_pointer = (_DWORD *)(logging_context + 4096);
  rule_list = *(_DWORD **)(logging_context + 5172);
  event_pointer = *(_DWORD *)(event_data + 16);
  rule_count = rule_list[1];
  event_str = *(_BYTE **)event_pointer;
  if ( rule_count > 0 )
    rule_index = 0;
  *(_DWORD *)(event_pointer + 4) = event_str;
  if ( rule_count > 0 )
  {
    do
    {
      current_rule = *(_DWORD *)(*rule_list + 4 * rule_index++);
      if ( (*(int (**)(void))(current_rule + 9260))() )
      {
        v10 = -1;
        sub_5DF98(2, "src/rule.c", 245, "zlog_spec_gen_path fail");
        return v10;
      }
      rule_list = (_DWORD *)context_pointer[269];
    }
    while ( rule_list[1] > rule_index );
    event_str = *(_BYTE **)(*(_DWORD *)(event_data + 16) + 4);
  }
  *event_str = 0;
  v10 = check_condition_and_execute(context_pointer[542], event_data);
  if ( v10 )
  {
    sub_5DF98(2, "src/rule.c", 248, "zlog_format_output fail");
    return -1;
  }
  else
  {
    file_descriptor = open64(**(_DWORD **)(event_data + 16));
    fd = file_descriptor;
    if ( file_descriptor < 0 )
    {
      errno_loc_open = _errno_location();
      v10 = -1;
      sub_5DF98(
        2,
        "src/rule.c",
        255,
        "open file[%s] fail, errno[%d]",
        **(const char ***)(event_data + 16),
        *errno_loc_open);
    }
    else if ( write(
                file_descriptor,
                **(const void ***)(event_data + 28),
                *(_DWORD *)(*(_DWORD *)(event_data + 28) + 4) - **(_DWORD **)(event_data + 28)) < 0 )
    {
      errno_loc_write = _errno_location();
      sub_5DF98(2, "src/rule.c", 260, "write fail, errno[%d]", *errno_loc_write);
      v10 = -1;
      close(fd);
    }
    else
    {
      sync_period = context_pointer[538];
      if ( sync_period )
      {
        sync_counter = context_pointer[539] + 1;
        if ( sync_period <= sync_counter )
        {
          context_pointer[539] = 0;
          if ( fsync(fd) )
          {
            errno_loc_fsync = _errno_location();
            sub_5DF98(2, "src/rule.c", 267, "fsync[%d] fail, errno[%d]", fd, *errno_loc_fsync);
          }
        }
        else
        {
          context_pointer[539] = sync_counter;
        }
      }
      if ( close(fd) < 0 )
      {
        errno_loc_close = _errno_location();
        v10 = -1;
        sub_5DF98(2, "src/rule.c", 271, "close fail, maybe cause by write, errno[%d]", *errno_loc_close);
      }
    }
  }
  return v10;
}
// 5A120: variable 'rule_index' is possibly undefined
// 12198: using guessed type int __fastcall open64(_DWORD);

//----- (0005A30C) --------------------------------------------------------
int __fastcall write_log_to_file(int logger_instance, int log_event)
{
  int current_index; // r4
  _DWORD *logger_instance_data; // r5
  _DWORD *current_category; // r3
  int log_event_data; // r2
  int category_count; // r1
  _BYTE *log_str; // r0
  int spec_gen_func; // r0
  int v11; // r8
  const char *file_path; // r9
  int file_descriptor; // r0
  int fd; // r10
  int log_data_ptr; // r2
  size_t log_data_len; // r4
  unsigned int flush_every_n_records; // r3
  unsigned int current_record_count; // r2
  int *errno_ptr_sync; // r0
  int *errno_ptr_stat; // r0
  int log_event_arg; // r1
  int rule_processor; // r6
  const char *rotated_filename; // r0
  int *errno_ptr_close; // r0
  int *errno_ptr_open; // r0
  int *errno_ptr_write; // r0
  char stat_buf[48]; // [sp+8h] [bp-90h] BYREF
  __int64 file_size; // [sp+38h] [bp-60h]

  logger_instance_data = (_DWORD *)(logger_instance + 4096);
  current_category = *(_DWORD **)(logger_instance + 5172);
  log_event_data = *(_DWORD *)(log_event + 16);
  category_count = current_category[1];
  log_str = *(_BYTE **)log_event_data;
  if ( category_count > 0 )
    current_index = 0;
  *(_DWORD *)(log_event_data + 4) = log_str;
  if ( category_count > 0 )
  {
    do
    {
      spec_gen_func = *(_DWORD *)(*current_category + 4 * current_index++);
      if ( (*(int (**)(void))(spec_gen_func + 9260))() )
      {
        v11 = -1;
        sub_5DF98(2, "src/rule.c", 285, "zlog_spec_gen_path fail");
        return v11;
      }
      current_category = (_DWORD *)logger_instance_data[269];
    }
    while ( current_category[1] > current_index );
    log_str = *(_BYTE **)(*(_DWORD *)(log_event + 16) + 4);
  }
  *log_str = 0;
  v11 = check_condition_and_execute(logger_instance_data[542], log_event);
  if ( v11 )
  {
    sub_5DF98(2, "src/rule.c", 288, "zlog_format_output fail");
    return -1;
  }
  file_path = **(const char ***)(log_event + 16);
  file_descriptor = open64(file_path);
  fd = file_descriptor;
  if ( file_descriptor < 0 )
  {
    errno_ptr_open = _errno_location();
    v11 = -1;
    sub_5DF98(
      2,
      "src/rule.c",
      295,
      "open file[%s] fail, errno[%d]",
      **(const char ***)(log_event + 16),
      *errno_ptr_open);
    return v11;
  }
  log_data_ptr = *(_DWORD *)(log_event + 28);
  log_data_len = *(_DWORD *)(log_data_ptr + 4) - *(_DWORD *)log_data_ptr;
  if ( write(file_descriptor, *(const void **)log_data_ptr, log_data_len) < 0 )
  {
    errno_ptr_write = _errno_location();
    sub_5DF98(2, "src/rule.c", 301, "write fail, errno[%d]", *errno_ptr_write);
    v11 = -1;
    close(fd);
    return v11;
  }
  flush_every_n_records = logger_instance_data[538];
  if ( flush_every_n_records )
  {
    current_record_count = logger_instance_data[539] + 1;
    if ( flush_every_n_records <= current_record_count )
    {
      logger_instance_data[539] = 0;
      if ( fsync(fd) )
      {
        errno_ptr_sync = _errno_location();
        sub_5DF98(2, "src/rule.c", 308, "fsync[%d] fail, errno[%d]", fd, *errno_ptr_sync);
      }
    }
    else
    {
      logger_instance_data[539] = current_record_count;
    }
  }
  if ( close(fd) < 0 )
  {
    errno_ptr_close = _errno_location();
    sub_5DF98(2, "src/rule.c", 312, "write fail, maybe cause by write, errno[%d]", *errno_ptr_close);
    return -1;
  }
  if ( log_data_len > logger_instance_data[276] )
  {
    sub_5DF98(
      0,
      "src/rule.c",
      318,
      "one msg's len[%ld] > archive_max_size[%ld], no rotate",
      log_data_len,
      logger_instance_data[276]);
    return 0;
  }
  else
  {
    if ( _xstat64(3, file_path, stat_buf) )
    {
      errno_ptr_stat = _errno_location();
      sub_5DF98(1, "src/rule.c", 323, "stat [%s] fail, errno[%d], maybe in rotating", file_path, *errno_ptr_stat);
      return v11;
    }
    if ( file_size + log_data_len >= (int)logger_instance_data[276] )
    {
      log_event_arg = log_event;
      rule_processor = *(_DWORD *)(dword_99EEC8 + 5160);
      rotated_filename = (const char *)process_rule(logger_instance, log_event_arg);
      if ( rotate_log_files(
             rule_processor,
             file_path,
             log_data_len,
             rotated_filename,
             logger_instance_data[276],
             logger_instance_data[277]) )
      {
        v11 = -1;
        sub_5DF98(2, "src/rule.c", 335, "zlog_rotater_rotate fail");
        return v11;
      }
    }
    return 0;
  }
}
// 5A35C: variable 'current_index' is possibly undefined
// 12198: using guessed type int __fastcall open64(_DWORD);
// 12574: using guessed type int __fastcall _xstat64(_DWORD, _DWORD, _DWORD);
// 99EEC8: using guessed type int dword_99EEC8;
// 5A30C: using guessed type char var_90[48];

//----- (0005A66C) --------------------------------------------------------
int __fastcall parse_logging_configuration(
        const char *config_line,
        char *file_path_buffer,
        _DWORD *array_list_ptr,
        const char **env_var_list)
{
  const char *next_char_ptr; // r5
  char *quote_ptr; // r0
  int status; // r8
  _DWORD *array_list; // r5
  const char **logging_spec; // r4
  int parse_result; // r0
  const char *config_line_unmodified; // [sp+0h] [bp-28h]
  char *next_token_ptr; // [sp+Ch] [bp-1Ch] BYREF

  next_char_ptr = config_line + 1;
  quote_ptr = strrchr(config_line + 1, 34);
  next_token_ptr = quote_ptr;
  if ( !quote_ptr )
  {
    config_line_unmodified = config_line;
    status = -1;
    sub_5DF98(2, "src/rule.c", 516, "matching \" not found in conf line[%s]", config_line_unmodified);
    return status;
  }
  if ( (unsigned int)(quote_ptr - next_char_ptr) > 1024 )
  {
    status = -1;
    sub_5DF98(2, "src/rule.c", 521, "file_path too long %ld > %ld", quote_ptr - next_char_ptr, 1024);
    return status;
  }
  memcpy(file_path_buffer, next_char_ptr, quote_ptr - next_char_ptr);
  status = replace_env_variable_in_string(file_path_buffer, 1025);
  if ( status )
  {
    sub_5DF98(2, "src/rule.c", 528, "zc_str_replace_env fail");
    return -1;
  }
  if ( !strchr(file_path_buffer, 37) )
    return status;
  array_list = initialize_array_list((int)delete_logging_specification);
  if ( *file_path_buffer )
  {
    while ( 1 )
    {
      logging_spec = parse_log_format(file_path_buffer, &next_token_ptr, env_var_list);
      if ( !logging_spec )
      {
        sub_5DF98(2, "src/rule.c", 546, "zlog_spec_new fail");
        status = -1;
        if ( array_list )
          process_and_free_resources(array_list);
        return status;
      }
      if ( invoke_custom_subroutine((int)array_list, (int)logging_spec) )
        break;
      file_path_buffer = next_token_ptr;
      if ( !*next_token_ptr )
        goto LABEL_13;
    }
    sub_5DF98(2, "src/rule.c", 551, "zc_arraylist_add fail");
    if ( array_list )
      process_and_free_resources(array_list);
    delete_logging_specification(logging_spec);
    return -1;
  }
  else
  {
LABEL_13:
    parse_result = 0;
    *array_list_ptr = array_list;
  }
  return parse_result;
}

//----- (0005A850) --------------------------------------------------------
int __fastcall log_rule_information(int rule_pointer, int log_level)
{
  int adjusted_rule_pointer; // r5
  int log_result; // r0
  _DWORD *info_array_pointer; // r3
  int index; // r4
  const char **info_entry_pointer; // r0

  if ( !rule_pointer )
    return sub_5DF98(2, "src/rule.c", 39, "a_rule is null or 0");
  adjusted_rule_pointer = rule_pointer + 4096;
  log_result = sub_5DF98(
                 log_level,
                 "src/rule.c",
                 65,
                 "---rule:[%p][%s%c%d]-[%d,%d][%s,%p,%d:%ld*%d~%s][%d][%d][%s:%s:%p];[%p]---",
                 (const void *)rule_pointer,
                 (const char *)rule_pointer,
                 *(unsigned __int8 *)(rule_pointer + 4097),
                 *(_DWORD *)(rule_pointer + 4100),
                 *(_DWORD *)(rule_pointer + 4136),
                 *(_DWORD *)(rule_pointer + 4140),
                 (const char *)(rule_pointer + 4144),
                 *(const void **)(rule_pointer + 5172),
                 *(_DWORD *)(rule_pointer + 5176),
                 *(_DWORD *)(rule_pointer + 5200),
                 *(_DWORD *)(rule_pointer + 5204),
                 (const char *)(rule_pointer + 5208),
                 *(_DWORD *)(rule_pointer + 6244),
                 *(_DWORD *)(rule_pointer + 6260),
                 (const char *)(rule_pointer + 6272),
                 (const char *)(rule_pointer + 7297),
                 *(const void **)(rule_pointer + 8324),
                 *(const void **)(rule_pointer + 6264));
  info_array_pointer = *(_DWORD **)(adjusted_rule_pointer + 1076);
  if ( info_array_pointer && (int)info_array_pointer[1] > 0 )
  {
    index = 0;
    do
    {
      info_entry_pointer = *(const char ***)(*info_array_pointer + 4 * index++);
      log_result = log_specific_information(info_entry_pointer, log_level);
      info_array_pointer = *(_DWORD **)(adjusted_rule_pointer + 1076);
    }
    while ( info_array_pointer[1] > index );
  }
  return log_result;
}

//----- (0005A97C) --------------------------------------------------------
void __fastcall release_rule_resources(_DWORD *rule)
{
  _DWORD *resource_ptr_1; // r0
  int file_descriptor; // r0
  FILE *file_pointer; // r0
  _DWORD *resource_ptr_2; // r0
  int *errno_ptr_1; // r0
  int *errno_ptr_2; // r0

  if ( rule )
  {
    resource_ptr_1 = (_DWORD *)rule[1293];
    if ( resource_ptr_1 )
    {
      process_and_free_resources(resource_ptr_1);
      rule[1293] = 0;
    }
    file_descriptor = rule[1294];
    if ( file_descriptor && close(file_descriptor) )
    {
      errno_ptr_1 = _errno_location();
      sub_5DF98(2, "src/rule.c", 949, "close fail, maybe cause by write, errno[%d]", *errno_ptr_1);
    }
    file_pointer = (FILE *)rule[1560];
    if ( file_pointer && pclose(file_pointer) == -1 )
    {
      errno_ptr_2 = _errno_location();
      sub_5DF98(2, "src/rule.c", 954, "pclose fail, errno[%d]", *errno_ptr_2);
    }
    resource_ptr_2 = (_DWORD *)rule[1559];
    if ( resource_ptr_2 )
    {
      process_and_free_resources(resource_ptr_2);
      rule[1559] = 0;
    }
    sub_5DF98(0, "src/rule.c", 961, "zlog_rule_del[%p]", rule);
    free(rule);
  }
  else
  {
    sub_5DF98(2, "src/rule.c", 942, "a_rule is null or 0");
  }
}

//----- (0005AA9C) --------------------------------------------------------
unsigned __int8 *__fastcall sub_5AA9C(const char *a1, _DWORD *a2, int a3, __int64 *a4, int a5, int a6, const char **a7)
{
  unsigned __int8 *v11; // r5
  const char *v12; // r7
  int v13; // r4
  const unsigned __int16 *v14; // r0
  unsigned int v15; // r3
  char *v16; // r1
  bool v17; // zf
  int v18; // r2
  bool v19; // r3
  _BOOL4 v20; // r4
  int v21; // t1
  const char *v22; // r1
  int string_index_in_array; // r0
  int v24; // r3
  int v25; // r4
  int v26; // r0
  __int64 v27; // r8
  int v28; // r8
  int v29; // r4
  const char *v30; // r10
  const char *v31; // t1
  char *v32; // r4
  unsigned int v33; // r7
  const unsigned __int16 **v34; // r0
  char *v35; // r2
  char *v36; // r0
  const void *v37; // r7
  char *v38; // r0
  const char *v39; // r4
  _DWORD *v40; // r0
  const char **v41; // r4
  _DWORD *v42; // r0
  int v44; // r2
  int v45; // r2
  FILE *v46; // r0
  int v47; // r0
  int *v48; // r0
  const char *v49; // r0
  char *v50; // r0
  char *v51; // r0
  const char *v52; // r4
  int v53; // r3
  int v54; // r3
  int *v55; // r0
  int v56; // r3
  int v57; // r0
  __int64 v58; // r0
  int *v59; // r0
  int *v60; // r0
  int *v61; // r0
  int v62; // [sp+Ch] [bp-70B4h] BYREF
  __int64 v63[13]; // [sp+10h] [bp-70B0h] BYREF
  char s[4100]; // [sp+7Ch] [bp-7044h] BYREF
  char src[4100]; // [sp+1080h] [bp-6040h] BYREF
  _BYTE v66[4100]; // [sp+2084h] [bp-503Ch] BYREF
  char v67[4100]; // [sp+3088h] [bp-4038h] BYREF
  char v68[4100]; // [sp+408Ch] [bp-3034h] BYREF
  char v69[4100]; // [sp+5090h] [bp-2030h] BYREF
  char v70[4140]; // [sp+6094h] [bp-102Ch] BYREF

  v62 = 0;
  if ( !a1 )
  {
    v11 = 0;
    sub_5DF98(2, "src/rule.c", 592, "line is null or 0");
    return v11;
  }
  if ( !a3 )
  {
    v11 = 0;
    sub_5DF98(2, "src/rule.c", 593, "default_format is null or 0");
    return v11;
  }
  if ( !a4 )
  {
    v11 = 0;
    sub_5DF98(2, "src/rule.c", 594, "formats is null or 0");
    return v11;
  }
  v11 = (unsigned __int8 *)calloc(1u, 8328u);
  if ( !v11 )
  {
    v55 = _errno_location();
    sub_5DF98(2, "src/rule.c", 598, "calloc fail, errno[%d]", *v55);
    return v11;
  }
  *((_DWORD *)v11 + 1034) = a5;
  *((_DWORD *)v11 + 1562) = a6;
  memset(s, 0, 4097u);
  if ( _isoc99_sscanf(a1, "%s %n", s, &v62) != 1 )
  {
    sub_5DF98(2, "src/rule.c", 612, "sscanf [%s] fail, selector", a1);
    goto LABEL_61;
  }
  v12 = &a1[v62];
  memset(src, 0, 4097u);
  memset(v66, 0, 4097u);
  if ( _isoc99_sscanf(s, " %[^.].%s", src, v66) != 2 )
  {
    sub_5DF98(2, "src/rule.c", 627, "sscanf [%s] fail, category or level is null", s);
    goto LABEL_61;
  }
  v13 = (unsigned __int8)src[0];
  if ( src[0] )
  {
    v14 = *_ctype_b_loc();
    v16 = src;
    while ( 1 )
    {
      v17 = v13 == 45;
      if ( v13 != 45 )
        v17 = v13 == 95;
      if ( !v17 )
        LOBYTE(v15) = 1;
      v18 = v14[v13];
      if ( v17 )
        LOBYTE(v15) = 0;
      v19 = v13 != 42 && v15 & 1;
      v20 = v13 != 33 && v19;
      v15 = v20 & ((v18 ^ 8u) >> 3);
      if ( v15 )
        break;
      v21 = (unsigned __int8)*++v16;
      v13 = v21;
      if ( !v21 )
        goto LABEL_23;
    }
    sub_5DF98(2, "src/rule.c", 634, "category name[%s] character is not in [a-Z][0-9][_!*-]", src);
    goto LABEL_61;
  }
LABEL_23:
  strcpy((char *)v11, src);
  if ( v66[0] == 42 )
  {
    v11[4097] = 42;
    v22 = v66;
  }
  else if ( v66[0] == 61 || v66[0] == 33 )
  {
    v11[4097] = v66[0];
    v22 = &v66[1];
  }
  else
  {
    v22 = v66;
    v11[4097] = 46;
  }
  string_index_in_array = find_string_index_in_array(a2, v22);
  v24 = v11[4097];
  v25 = string_index_in_array;
  *((_DWORD *)v11 + 1025) = string_index_in_array;
  switch ( v24 )
  {
    case '!':
      memset(v11 + 4104, 255, 32u);
      LOBYTE(v44) = v25 & 7;
      if ( v25 <= 0 )
        v44 = -(-v25 & 7);
      v11[v25 / 8 + 4104] &= ~(1 << (7 - v44));
      break;
    case '*':
      memset(v11 + 4104, 255, 32u);
      break;
    case '.':
      memset(v11 + 4104, 0, 32u);
      LOBYTE(v26) = v25 & 7;
      if ( v25 <= 0 )
        v26 = -(-v25 & 7);
      v11[v25 / 8 + 4104] |= ~(-1 << (8 - v26));
      memset(&v11[v25 / 8 + 4105], 255, 31 - v25 / 8);
      break;
    case '=':
      memset(v11 + 4104, 0, 32u);
      LOBYTE(v45) = v25 & 7;
      if ( v25 <= 0 )
        v45 = -(-v25 & 7);
      v11[v25 / 8 + 4104] |= 1 << (7 - v45);
      break;
    default:
      break;
  }
  memset(v67, 0, 4097u);
  memset(v68, 0, 4097u);
  if ( _isoc99_sscanf(v12, " %[^;];%s", v67, v68) <= 0 )
  {
    sub_5DF98(2, "src/rule.c", 700, "sscanf [%s] fail", v12);
    goto LABEL_61;
  }
  if ( v68[0] )
  {
    v27 = *a4;
    if ( v27 <= 0 )
    {
LABEL_60:
      sub_5DF98(2, "src/rule.c", 722, "in conf file can't find format[%s], pls check", v68);
      goto LABEL_61;
    }
    v28 = v27 - 4;
    v29 = 0;
    while ( 1 )
    {
      v31 = *(const char **)(v28 + 4);
      v28 += 4;
      v30 = v31;
      ++v29;
      if ( !strcmp(v31, v68) )
        break;
      if ( v29 == HIDWORD(v27) )
        goto LABEL_60;
    }
    *((_DWORD *)v11 + 1566) = v30;
  }
  else
  {
    sub_5DF98(0, "src/rule.c", 706, "no format specified, use default");
    *((_DWORD *)v11 + 1566) = a3;
  }
  memset(v69, 0, 4097u);
  if ( _isoc99_sscanf(v67, " %[^,],", v69) <= 0 )
  {
    sub_5DF98(2, "src/rule.c", 734, "sscanf [%s] fail", v12);
    goto LABEL_61;
  }
  v32 = strchr(v67, 44);
  v33 = (unsigned __int8)v69[0];
  if ( v32 )
  {
    v34 = _ctype_b_loc();
    v35 = v32 + 1;
    do
      v32 = v35++;
    while ( ((*v34)[(unsigned __int8)*v32] & 0x2000) != 0 );
    if ( v33 != 45 )
    {
      if ( v33 <= 45 )
      {
        if ( v33 != 34 )
        {
          if ( v33 == 36 )
          {
            _isoc99_sscanf(&v69[1], "%s", v11 + 6272);
            v36 = strchr(v32, 34);
            if ( v36 )
            {
              v37 = v36 + 1;
              v38 = strrchr(v36 + 1, 34);
              LODWORD(v63[0]) = v38;
              if ( v38 )
              {
                if ( (unsigned int)(v38 - (_BYTE *)v37) <= 1024 )
                {
                  v39 = (const char *)(v11 + 7297);
                  memcpy(v11 + 7297, v37, v38 - (_BYTE *)v37);
                  goto LABEL_51;
                }
                sub_5DF98(2, "src/rule.c", 886, "record_path too long %ld > %ld", v38 - (_BYTE *)v37, 1024);
              }
              else
              {
                sub_5DF98(2, "src/rule.c", 881, "matching \" not found in conf line[%s]", (const char *)v37);
              }
            }
            else
            {
              sub_5DF98(2, "src/rule.c", 874, "record_path not start with \", [%s]", v32);
            }
LABEL_61:
            v42 = v11;
            v11 = 0;
            release_rule_resources(v42);
            return v11;
          }
LABEL_105:
          sub_5DF98(2, "src/rule.c", 930, "the 1st char[%c] of file_path[%s] is wrong", v33, v69);
          goto LABEL_61;
        }
        goto LABEL_106;
      }
      if ( v33 == 62 )
      {
        if ( strncmp(&v69[1], "syslog", 6u) )
          goto LABEL_83;
        if ( !strcasecmp(v32, "LOG_LOCAL0") )
        {
          *((_DWORD *)v11 + 1565) = 128;
          goto LABEL_147;
        }
        if ( !strcasecmp(v32, "LOG_LOCAL1") )
        {
          *((_DWORD *)v11 + 1565) = 136;
          goto LABEL_147;
        }
        if ( !strcasecmp(v32, "LOG_LOCAL2") )
        {
          *((_DWORD *)v11 + 1565) = 144;
          goto LABEL_147;
        }
        if ( !strcasecmp(v32, "LOG_LOCAL3") )
        {
          *((_DWORD *)v11 + 1565) = 152;
          goto LABEL_147;
        }
        if ( !strcasecmp(v32, "LOG_LOCAL4") )
        {
          *((_DWORD *)v11 + 1565) = 160;
          goto LABEL_147;
        }
        if ( !strcasecmp(v32, "LOG_LOCAL5") )
        {
          *((_DWORD *)v11 + 1565) = 168;
          goto LABEL_147;
        }
        if ( !strcasecmp(v32, "LOG_LOCAL6") )
        {
          *((_DWORD *)v11 + 1565) = 176;
          goto LABEL_147;
        }
        if ( !strcasecmp(v32, "LOG_LOCAL7") )
        {
          *((_DWORD *)v11 + 1565) = 184;
          goto LABEL_147;
        }
        if ( !strcasecmp(v32, "LOG_USER") )
        {
          *((_DWORD *)v11 + 1565) = 8;
          goto LABEL_147;
        }
        if ( strcasecmp(v32, "LOG_AUTHPRIV") )
        {
          if ( !strcasecmp(v32, "LOG_CRON") )
          {
            *((_DWORD *)v11 + 1565) = 72;
            goto LABEL_147;
          }
          if ( !strcasecmp(v32, "LOG_DAEMON") )
          {
            *((_DWORD *)v11 + 1565) = 24;
            goto LABEL_147;
          }
          if ( !strcasecmp(v32, "LOG_FTP") )
          {
            *((_DWORD *)v11 + 1565) = 88;
            goto LABEL_147;
          }
          if ( !strcasecmp(v32, "LOG_KERN") )
          {
            *((_DWORD *)v11 + 1565) = 0;
LABEL_147:
            *((_DWORD *)v11 + 1567) = process_asic_status;
            openlog(0, 25, 8);
            return v11;
          }
          if ( !strcasecmp(v32, "LOG_LPR") )
          {
            *((_DWORD *)v11 + 1565) = 48;
            goto LABEL_147;
          }
          if ( !strcasecmp(v32, "LOG_MAIL") )
          {
            *((_DWORD *)v11 + 1565) = 16;
            goto LABEL_147;
          }
          if ( !strcasecmp(v32, "LOG_NEWS") )
          {
            *((_DWORD *)v11 + 1565) = 56;
            goto LABEL_147;
          }
          if ( !strcasecmp(v32, "LOG_SYSLOG") )
          {
            *((_DWORD *)v11 + 1565) = 40;
            goto LABEL_147;
          }
        }
        *((_DWORD *)v11 + 1565) = 80;
        goto LABEL_147;
      }
LABEL_76:
      if ( v33 == 124 )
      {
        v46 = popen(&v67[1], "w");
        *((_DWORD *)v11 + 1560) = v46;
        if ( v46 )
        {
          v47 = fileno(v46);
          *((_DWORD *)v11 + 1561) = v47;
          if ( v47 >= 0 )
          {
            *((_DWORD *)v11 + 1567) = 368540;
            return v11;
          }
          v48 = _errno_location();
          sub_5DF98(2, "src/rule.c", 844, "fileno fail, errno[%d]", *v48);
        }
        else
        {
          v59 = _errno_location();
          sub_5DF98(2, "src/rule.c", 839, "popen fail, errno[%d]", *v59);
        }
        goto LABEL_61;
      }
      goto LABEL_105;
    }
  }
  else if ( v69[0] != 45 )
  {
    if ( (unsigned __int8)v69[0] <= 45u )
    {
      if ( v69[0] != 34 )
      {
        if ( v69[0] == 36 )
        {
          _isoc99_sscanf(&v69[1], "%s", v11 + 6272);
          v39 = (const char *)(v11 + 7297);
LABEL_51:
          if ( replace_env_variable_in_string(v39, 1025) )
          {
            sub_5DF98(2, "src/rule.c", 895, "zc_str_replace_env fail");
          }
          else
          {
            if ( !strchr(v39, 37) )
            {
              *((_DWORD *)v11 + 1567) = 366016;
              return v11;
            }
            *((_DWORD *)v11 + 1567) = process_log_entry;
            v40 = initialize_array_list((int)delete_logging_specification);
            *((_DWORD *)v11 + 1293) = v40;
            if ( v40 )
            {
              if ( !v11[7297] )
                return v11;
              while ( 1 )
              {
                v41 = parse_log_format(v39, (char **)v63, a7);
                if ( !v41 )
                {
                  sub_5DF98(2, "src/rule.c", 915, "zlog_spec_new fail");
                  goto LABEL_61;
                }
                if ( invoke_custom_subroutine(*((_DWORD *)v11 + 1293), (int)v41) )
                  break;
                v39 = (const char *)v63[0];
                if ( !*(_BYTE *)LODWORD(v63[0]) )
                  return v11;
              }
              delete_logging_specification(v41);
              sub_5DF98(2, "src/rule.c", 922, "zc_arraylist_add fail");
            }
            else
            {
              sub_5DF98(2, "src/rule.c", 909, "zc_arraylist_new fail");
            }
          }
          goto LABEL_61;
        }
        goto LABEL_105;
      }
LABEL_106:
      v49 = v69;
      goto LABEL_90;
    }
    if ( v69[0] == 62 )
    {
      if ( !strncmp(&v69[1], "syslog", 6u) )
      {
        sub_5DF98(2, "src/rule.c", 477, "facility is null or 0");
        *((_DWORD *)v11 + 1565) = -187;
        sub_5DF98(2, "src/rule.c", 853, "-187 get");
        goto LABEL_61;
      }
LABEL_83:
      if ( !strncmp(&v69[1], "stdout", 6u) )
      {
        *((_DWORD *)v11 + 1567) = 368376;
        return v11;
      }
      if ( !strncmp(&v69[1], "stderr", 6u) )
      {
        *((_DWORD *)v11 + 1567) = 368212;
        return v11;
      }
      sub_5DF98(2, "src/rule.c", 864, "[%s]the string after is not syslog, stdout or stderr", v67);
      goto LABEL_61;
    }
    goto LABEL_76;
  }
  if ( v69[1] != 34 )
  {
    sub_5DF98(2, "src/rule.c", 751, " - must set before a file output");
    goto LABEL_61;
  }
  v49 = &v69[1];
  *((_DWORD *)v11 + 1035) = &unk_101000;
  *((_DWORD *)v11 + 1562) = 0;
LABEL_90:
  if ( parse_logging_configuration(v49, (char *)v11 + 4144, (_DWORD *)v11 + 1293, a7) )
  {
    sub_5DF98(2, "src/rule.c", 767, "zlog_rule_parse_path fail");
    goto LABEL_61;
  }
  if ( v32 )
  {
    memset(v70, 0, 4097u);
    if ( _isoc99_sscanf(v32, " %[0-9MmKkBb] * %d ~", v70, v11 + 5204) )
      *((_DWORD *)v11 + 1300) = parse_size_in_bytes(v70);
    v50 = strchr(v32, 34);
    if ( v50 )
    {
      if ( parse_logging_configuration(v50, (char *)v11 + 5208, (_DWORD *)v11 + 1559, a7) )
      {
        sub_5DF98(2, "src/rule.c", 784, "zlog_rule_parse_path fail");
        goto LABEL_61;
      }
      v51 = strchr((const char *)v11 + 5208, 35);
      v52 = v51;
      if ( !v51 || !strchr(v51, 114) && !strchr(v52, 115) )
      {
        sub_5DF98(2, "src/rule.c", 790, "archive_path must contain #r or #s");
        goto LABEL_61;
      }
    }
  }
  v53 = *((_DWORD *)v11 + 1300);
  if ( *((_DWORD *)v11 + 1293) )
  {
    if ( v53 > 0 )
      LOWORD(v54) = -23796;
    else
      LOWORD(v54) = -24364;
    HIWORD(v54) = 5;
    *((_DWORD *)v11 + 1567) = v54;
  }
  else
  {
    if ( v53 > 0 )
      LOWORD(v56) = -26100;
    else
      LOWORD(v56) = -26960;
    HIWORD(v56) = 5;
    *((_DWORD *)v11 + 1567) = v56;
    v57 = open64(v11 + 4144);
    *((_DWORD *)v11 + 1294) = v57;
    if ( v57 < 0 )
    {
      v60 = _errno_location();
      sub_5DF98(2, "src/rule.c", 817, "open file[%s] fail, errno[%d]", (const char *)v11 + 4144, *v60);
      goto LABEL_61;
    }
    if ( _fxstat64(3, v57, v63) )
    {
      v61 = _errno_location();
      sub_5DF98(
        2,
        "src/rule.c",
        823,
        "stat [%s] fail, errno[%d], failing to open static_fd",
        (const char *)v11 + 4144,
        *v61);
      goto LABEL_61;
    }
    if ( *((int *)v11 + 1300) > 0 )
    {
      close(*((_DWORD *)v11 + 1294));
      *((_DWORD *)v11 + 1294) = -1;
    }
    v58 = v63[12];
    *((_QWORD *)v11 + 648) = v63[0];
    *((_QWORD *)v11 + 649) = v58;
  }
  return v11;
}
// 5AC64: control flows out of bounds to 5AC68
// 5ABC8: variable 'v15' is possibly undefined
// 120E4: using guessed type int __fastcall _fxstat64(_DWORD, _DWORD, _DWORD);
// 12198: using guessed type int __fastcall open64(_DWORD);
// 1231C: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);

//----- (0005BABC) --------------------------------------------------------
int __fastcall check_condition(int condition_ptr, int execution_ptr)
{
  int decision_result; // r0

  switch ( *(_BYTE *)(condition_ptr + 4097) )
  {
    case '!':
      if ( *(_DWORD *)(*(_DWORD *)(execution_ptr + 8) + 292) == *(_DWORD *)(condition_ptr + 4100) )
        goto LABEL_5;
      goto LABEL_3;
    case '*':
      goto LABEL_3;
    case '.':
      if ( *(_DWORD *)(*(_DWORD *)(execution_ptr + 8) + 292) < *(_DWORD *)(condition_ptr + 4100) )
        goto LABEL_5;
      decision_result = (*(int (**)(void))(condition_ptr + 6268))();
      break;
    case '=':
      if ( *(_DWORD *)(*(_DWORD *)(execution_ptr + 8) + 292) != *(_DWORD *)(condition_ptr + 4100) )
        goto LABEL_5;
LABEL_3:
      decision_result = (*(int (__fastcall **)(int, int))(condition_ptr + 6268))(condition_ptr, execution_ptr);
      break;
    default:
LABEL_5:
      decision_result = 0;
      break;
  }
  return decision_result;
}
// 5BAD0: control flows out of bounds to 5BAD4

//----- (0005BB9C) --------------------------------------------------------
int __fastcall is_bmr_rule_valid(_BYTE *bmr_rule)
{
  if ( bmr_rule )
  {
    return *bmr_rule == 33 && bmr_rule[1] == 0;
  }
  else
  {
    sub_5DF98(2, "src/rule.c", 1002, "a_rule is null or 0");
    return -1;
  }
}

//----- (0005BBE8) --------------------------------------------------------
int __fastcall check_matching_rule(int rule_string, char *compare_string)
{
  size_t rule_length; // r0
  size_t adjusted_length; // r7
  size_t final_length; // r6
  size_t compare_length; // r0
  size_t comparison_length; // r2

  if ( rule_string )
  {
    if ( compare_string )
    {
      if ( *(_BYTE *)rule_string == 42 && !*(_BYTE *)(rule_string + 1)
        || !strcmp((const char *)rule_string, compare_string) )
      {
        return 1;
      }
      else
      {
        rule_length = strlen((const char *)rule_string);
        adjusted_length = rule_length - 1;
        final_length = rule_length;
        if ( *(_BYTE *)(rule_string + rule_length - 1) == 95 )
        {
          compare_length = strlen(compare_string);
          if ( adjusted_length == compare_length )
            comparison_length = compare_length;
          else
            comparison_length = final_length;
          return strncmp((const char *)rule_string, compare_string, comparison_length) == 0;
        }
        else
        {
          return 0;
        }
      }
    }
    else
    {
      sub_5DF98(2, "src/rule.c", 1015, "category is null or 0");
      return -1;
    }
  }
  else
  {
    sub_5DF98(2, "src/rule.c", 1014, "a_rule is null or 0");
    return -1;
  }
}

//----- (0005BCCC) --------------------------------------------------------
int __fastcall check_and_process_task(int mining_device, int task_data)
{
  int (__fastcall *current_task_handler)(int, int); // r12
  bool is_valid_handler; // zf
  int processing_result; // r0

  current_task_handler = *(int (__fastcall **)(int, int))(mining_device + 6268);
  is_valid_handler = current_task_handler == process_rule_execution;
  if ( current_task_handler != process_rule_execution )
    is_valid_handler = current_task_handler == process_log_entry;
  if ( !is_valid_handler )
    return 0;
  processing_result = process_task(task_data, mining_device + 6272);
  if ( processing_result )
    *(_DWORD *)(mining_device + 8324) = *(_DWORD *)(processing_result + 1028);
  return 0;
}

//----- (0005BD24) --------------------------------------------------------
int __fastcall execute_custom_function(int context, int parameters)
{
  return (*(int (__fastcall **)(int, int, _DWORD))(context + 9252))(context, parameters, *(_DWORD *)(parameters + 28));
}

//----- (0005BD34) --------------------------------------------------------
int __fastcall call_custom_function(int base_address, int argument)
{
  return (*(int (__fastcall **)(int, int, _DWORD))(base_address + 9252))(
           base_address,
           argument,
           *(_DWORD *)(argument + 16));
}

//----- (0005BD44) --------------------------------------------------------
int __fastcall invoke_device_operation(int device_handle, int operation_data)
{
  return (*(int (__fastcall **)(int, int, _DWORD))(device_handle + 9252))(
           device_handle,
           operation_data,
           *(_DWORD *)(operation_data + 20));
}

//----- (0005BD54) --------------------------------------------------------
int __fastcall transmit_data(int data_packet_pointer, int unused_parameter, int socket_descriptor)
{
  return copy_to_buffer_with_resize(
           socket_descriptor,
           *(void **)data_packet_pointer,
           *(_DWORD *)(data_packet_pointer + 4));
}

//----- (0005BD64) --------------------------------------------------------
int __fastcall format_percentage(int unused_param_1, int unused_param_2, int value)
{
  return copy_to_buffer_with_resize(value, "%", 1u);
}

//----- (0005BD78) --------------------------------------------------------
int __fastcall perform_custom_operation(int unused_parameter, int context, int operation_id)
{
  return copy_to_buffer_with_resize(
           operation_id,
           (void *)(*(_DWORD *)(context + 8) + 428),
           *(_DWORD *)(*(_DWORD *)(context + 8) + 460));
}

//----- (0005BD8C) --------------------------------------------------------
int __fastcall forward_command_to_miner(int unused_param_1, int miner_data_struct, int command_id)
{
  return copy_to_buffer_with_resize(
           command_id,
           (void *)(*(_DWORD *)(miner_data_struct + 8) + 464),
           *(_DWORD *)(*(_DWORD *)(miner_data_struct + 8) + 496));
}

//----- (0005BDA0) --------------------------------------------------------
int __fastcall send_status_to_controller(int unused_param1, int unused_param2, int status_code)
{
  return copy_to_buffer_with_resize(status_code, &word_6A02C, 1u);
}
// 6A02C: using guessed type __int16 word_6A02C;

//----- (0005BDB4) --------------------------------------------------------
int __fastcall send_miner_command(int unused, int miner_info, int command_code)
{
  return copy_to_buffer_with_resize(
           command_code,
           (void *)(*(_DWORD *)(miner_info + 8) + 504),
           *(_DWORD *)(*(_DWORD *)(miner_info + 8) + 536));
}

//----- (0005BDC8) --------------------------------------------------------
int __fastcall calculation_result(int unused_param1, int context_struct_ptr, int input_value)
{
  return copy_to_buffer_with_resize(
           input_value,
           (void *)(*(_DWORD *)(context_struct_ptr + 8) + 8),
           *(_DWORD *)(*(_DWORD *)(context_struct_ptr + 8) + 268));
}

//----- (0005BDDC) --------------------------------------------------------
int __fastcall trigger_event_with_parameters(int unused_param, int event_data_ptr, int event_id)
{
  return copy_to_buffer_with_resize(
           event_id,
           **(void ***)(event_data_ptr + 8),
           *(_DWORD *)(*(_DWORD *)(event_data_ptr + 8) + 4));
}

//----- (0005BDEC) --------------------------------------------------------
int __fastcall calculate_chip_performance(int input_1, int input_2, int performance_data)
{
  int chip_level_data; // r1

  chip_level_data = getASICChipLevel(*(int **)(dword_99EEC8 + 9280), *(_DWORD *)(*(_DWORD *)(input_2 + 8) + 292));
  return copy_to_buffer_with_resize(
           performance_data,
           (void *)(chip_level_data + 4),
           *(_DWORD *)(chip_level_data + 2056));
}
// 99EEC8: using guessed type int dword_99EEC8;

//----- (0005BE2C) --------------------------------------------------------
int __fastcall calculate_asics_performance(int parameter_1, int status_data_ptr, int parameter_3)
{
  int asic_chip_status; // r3

  asic_chip_status = getASICChipLevel(
                       *(int **)(dword_99EEC8 + 9280),
                       *(_DWORD *)(*(_DWORD *)(status_data_ptr + 8) + 292));
  return copy_to_buffer_with_resize(
           parameter_3,
           (void *)(asic_chip_status + 1029),
           *(_DWORD *)(asic_chip_status + 2056));
}
// 99EEC8: using guessed type int dword_99EEC8;

//----- (0005BE70) --------------------------------------------------------
int __fastcall initialize_process_id(int unused_parameter_1, int miner_config_ptr, int output_buffer)
{
  char *config_str_ptr; // r4
  int process_id; // r2
  int written_chars; // r0
  int config_base_ptr; // r4

  config_str_ptr = *(char **)(miner_config_ptr + 8);
  if ( *((_DWORD *)config_str_ptr + 95) )
    return copy_to_buffer_with_resize(output_buffer, config_str_ptr + 388, *((_DWORD *)config_str_ptr + 105));
  *((_DWORD *)config_str_ptr + 95) = getpid();
  config_str_ptr = *(char **)(miner_config_ptr + 8);
  process_id = *((_DWORD *)config_str_ptr + 95);
  if ( process_id == *((_DWORD *)config_str_ptr + 96) )
    return copy_to_buffer_with_resize(output_buffer, config_str_ptr + 388, *((_DWORD *)config_str_ptr + 105));
  *((_DWORD *)config_str_ptr + 96) = process_id;
  written_chars = sprintf(config_str_ptr + 388, "%u", process_id);
  config_base_ptr = *(_DWORD *)(miner_config_ptr + 8);
  *(_DWORD *)(config_base_ptr + 420) = written_chars;
  return copy_to_buffer_with_resize(output_buffer, (void *)(config_base_ptr + 388), written_chars);
}

//----- (0005BEEC) --------------------------------------------------------
int __fastcall extract_and_forward_device_info(int unused_param1, int device_info_ptr, int context)
{
  return convert_integer_to_string(
           context,
           *(_DWORD *)(device_info_ptr + 8),
           *(_DWORD *)(*(_DWORD *)(device_info_ptr + 8) + 288),
           *(int *)(*(_DWORD *)(device_info_ptr + 8) + 288) >> 31,
           0);
}

//----- (0005BF18) --------------------------------------------------------
int __fastcall process_debug_output(int unknown_param_a1, int debug_data_ptr, int output_buffer)
{
  int debug_info; // r3
  int debug_type; // r2
  char *format_string; // r1
  int result_code; // r12
  int max_display_length; // r9
  int integer_to_string_param; // r1
  unsigned int current_byte_index; // r5
  unsigned int hex_data_index; // r11
  size_t copy_length; // r2
  char *copy_string; // r1
  int local_output_buffer; // r0
  int local_debug_info; // r3
  char *char_representation; // r1
  int char_output_buffer; // r0
  int char_copy_result; // r0
  int copy_without_format_result; // r0
  int char_debug_info; // r3
  int current_char; // r3
  __int64 row_index; // [sp+8h] [bp-40h]
  int space_copy_result; // [sp+14h] [bp-34h]
  unsigned __int8 current_hex_value; // [sp+1Fh] [bp-29h] BYREF

  debug_info = *(_DWORD *)(debug_data_ptr + 8);
  debug_type = *(_DWORD *)(debug_info + 312);
  if ( !debug_type )
  {
    format_string = *(char **)(debug_info + 304);
    if ( format_string )
      return format_log_message(output_buffer, format_string, *(__gnuc_va_list *)(debug_info + 308));
    return copy_to_buffer_with_resize(output_buffer, "format=(null)", 13u);
  }
  if ( debug_type != 1 )
    return 0;
  if ( !*(_DWORD *)(debug_info + 296) )
  {
    copy_without_format_result = copy_to_buffer_with_resize(output_buffer, &unk_6D1F4, 10u);
    if ( copy_without_format_result >= 0 )
    {
      if ( !copy_without_format_result )
        return 0;
LABEL_24:
      sub_5DF98(2, "src/spec.c", 339, "write hex msg, buf is full");
      return 1;
    }
LABEL_35:
    sub_5DF98(2, "src/spec.c", 336, "write hex msg fail");
    return -1;
  }
  result_code = copy_to_buffer_with_resize(
                  output_buffer,
                  "\n             0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F    0123456789ABCDEF",
                  80u);
  if ( result_code )
  {
LABEL_23:
    if ( result_code >= 0 )
      goto LABEL_24;
    goto LABEL_35;
  }
  max_display_length = 16;
  row_index = 1LL;
  do
  {
    result_code = copy_to_buffer_with_resize(output_buffer, &word_6A02C, 1u);
    if ( result_code )
      goto LABEL_23;
    result_code = convert_integer_to_string(
                    output_buffer,
                    integer_to_string_param,
                    row_index,
                    SHIDWORD(row_index),
                    (char *)10);
    if ( result_code )
      goto LABEL_23;
    result_code = copy_to_buffer_with_resize(output_buffer, "   ", 3u);
    if ( result_code )
      goto LABEL_23;
    current_byte_index = max_display_length - 16;
    hex_data_index = max_display_length - 16;
    do
    {
      local_debug_info = *(_DWORD *)(debug_data_ptr + 8);
      local_output_buffer = output_buffer;
      copy_string = "   ";
      if ( *(_DWORD *)(local_debug_info + 300) > hex_data_index )
      {
        current_hex_value = *(_BYTE *)(*(_DWORD *)(local_debug_info + 296) + hex_data_index);
        result_code = append_formatted_hex_value_to_buffer(output_buffer, current_hex_value, (char *)2);
        copy_length = 1;
        copy_string = " ";
        local_output_buffer = output_buffer;
        if ( result_code )
          goto LABEL_23;
      }
      else
      {
        copy_length = 3;
      }
      result_code = copy_to_buffer_with_resize(local_output_buffer, copy_string, copy_length);
      if ( result_code )
        goto LABEL_23;
      ++hex_data_index;
    }
    while ( hex_data_index != max_display_length );
    space_copy_result = copy_to_buffer_with_resize(output_buffer, &dword_60DE4, 2u);
    if ( space_copy_result )
    {
      result_code = space_copy_result;
      goto LABEL_23;
    }
    do
    {
      char_debug_info = *(_DWORD *)(debug_data_ptr + 8);
      if ( *(_DWORD *)(char_debug_info + 300) <= current_byte_index )
      {
        char_representation = " ";
        char_output_buffer = output_buffer;
LABEL_21:
        char_copy_result = copy_to_buffer_with_resize(char_output_buffer, char_representation, 1u);
        if ( char_copy_result )
          goto LABEL_22;
        goto LABEL_31;
      }
      char_representation = (char *)&current_hex_value;
      char_output_buffer = output_buffer;
      current_char = *(unsigned __int8 *)(*(_DWORD *)(char_debug_info + 296) + current_byte_index);
      current_hex_value = current_char;
      if ( (unsigned int)(current_char - 32) <= 94 )
        goto LABEL_21;
      char_copy_result = copy_to_buffer_with_resize(output_buffer, ".", 1u);
      if ( char_copy_result )
      {
LABEL_22:
        result_code = char_copy_result;
        goto LABEL_23;
      }
LABEL_31:
      ++current_byte_index;
    }
    while ( hex_data_index != current_byte_index );
    max_display_length += 16;
    ++row_index;
  }
  while ( hex_data_index < *(_DWORD *)(*(_DWORD *)(debug_data_ptr + 8) + 300) );
  return 0;
}
// 5BFF8: variable 'integer_to_string_param' is possibly undefined
// 60DE4: using guessed type int dword_60DE4;
// 6A02C: using guessed type __int16 word_6A02C;

//----- (0005C204) --------------------------------------------------------
int __fastcall extract_last_path_segment(int unused, int miner_info_ptr, int destination_buffer)
{
  int miner_data; // r5
  const char *file_path; // r4
  char *last_slash_ptr; // r0
  size_t file_path_len; // r2
  char *file_name_start; // r1
  int file_name_len; // r2
  int dest_buffer; // r0

  miner_data = *(_DWORD *)(miner_info_ptr + 8);
  file_path = *(const char **)(miner_data + 272);
  last_slash_ptr = strrchr(file_path, 47);
  file_path_len = *(_DWORD *)(miner_data + 276);
  if ( last_slash_ptr )
  {
    file_name_start = last_slash_ptr + 1;
    file_name_len = &file_path[file_path_len] - last_slash_ptr;
    dest_buffer = destination_buffer;
    file_path_len = file_name_len - 1;
  }
  else
  {
    file_name_start = (char *)file_path;
    dest_buffer = destination_buffer;
  }
  return copy_to_buffer_with_resize(dest_buffer, file_name_start, file_path_len);
}

//----- (0005C258) --------------------------------------------------------
int __fastcall update_miner_timestamp(int not_used, int miner_info_ptr, int value_to_pass)
{
  int miner_status_struct; // r0

  miner_status_struct = *(_DWORD *)(miner_info_ptr + 8);
  if ( !*(_DWORD *)(miner_status_struct + 316) )
  {
    gettimeofday((struct timeval *)(miner_status_struct + 316), 0);
    miner_status_struct = *(_DWORD *)(miner_info_ptr + 8);
  }
  return format_number_to_buffer(value_to_pass, *(_DWORD *)(miner_status_struct + 320), (char *)6);
}

//----- (0005C294) --------------------------------------------------------
int __fastcall initialize_miner_timer(int timer_id, int miner_data, int timeout_period)
{
  int miner_struct_ptr; // r0

  miner_struct_ptr = *(_DWORD *)(miner_data + 8);
  if ( !*(_DWORD *)(miner_struct_ptr + 316) )
  {
    gettimeofday((struct timeval *)(miner_struct_ptr + 316), 0);
    miner_struct_ptr = *(_DWORD *)(miner_data + 8);
  }
  return format_number_to_buffer(timeout_period, *(_DWORD *)(miner_struct_ptr + 320) / 1000, (char *)3);
}

//----- (0005C2E4) --------------------------------------------------------
int __fastcall get_mdc_value_for_key(int miner_context, int mdc_hashtable_ptr, int destination_buffer)
{
  const char *key; // r4
  int mdc_entry_pointer; // r5

  key = (const char *)(miner_context + 4112);
  mdc_entry_pointer = process_hashtable_get(*(int **)(mdc_hashtable_ptr + 4), miner_context + 4112);
  if ( mdc_entry_pointer )
    return copy_to_buffer_with_resize(
             destination_buffer,
             (void *)(mdc_entry_pointer + 1025),
             *(_DWORD *)(mdc_entry_pointer + 2052));
  sub_5DF98(2, "src/spec.c", 123, "zlog_mdc_get_kv key[%s] fail", key);
  return 0;
}

//----- (0005C358) --------------------------------------------------------
int __fastcall update_log_timestamp(int config_base_address, int log_entry_pointer, int output_buffer)
{
  int log_entry_base; // r0
  int log_index; // r4
  time_t current_time; // r1
  int log_entry_offset; // r3
  struct tm *time_struct_pointer; // r8
  int timestamp_buffer_start; // r4
  size_t formatted_time_length; // r0
  size_t output_length; // r2
  time_t log_entry_timestamp; // [sp+4h] [bp-1Ch] BYREF

  log_entry_base = *(_DWORD *)(log_entry_pointer + 8);
  log_index = *(_DWORD *)(config_base_address + 4108);
  log_entry_offset = *(_DWORD *)(log_entry_base + 372);
  time_struct_pointer = (struct tm *)(log_entry_base + 328);
  log_entry_timestamp = *(_DWORD *)(log_entry_base + 316);
  current_time = log_entry_timestamp;
  timestamp_buffer_start = log_entry_offset + 4108 * log_index;
  if ( !log_entry_timestamp )
  {
    gettimeofday((struct timeval *)(log_entry_base + 316), 0);
    log_entry_base = *(_DWORD *)(log_entry_pointer + 8);
    current_time = *(_DWORD *)(log_entry_base + 316);
    log_entry_timestamp = current_time;
  }
  if ( *(_DWORD *)(log_entry_base + 324) != current_time )
  {
    localtime_r(&log_entry_timestamp, time_struct_pointer);
    current_time = log_entry_timestamp;
    *(_DWORD *)(*(_DWORD *)(log_entry_pointer + 8) + 324) = log_entry_timestamp;
  }
  if ( *(_DWORD *)(timestamp_buffer_start + 4104) == current_time )
  {
    output_length = *(_DWORD *)(timestamp_buffer_start + 4100);
  }
  else
  {
    formatted_time_length = strftime(
                              (char *)timestamp_buffer_start,
                              4097u,
                              (const char *)(config_base_address + 8),
                              time_struct_pointer);
    output_length = formatted_time_length;
    *(_QWORD *)(timestamp_buffer_start + 4100) = __PAIR64__(log_entry_timestamp, formatted_time_length);
  }
  return copy_to_buffer_with_resize(output_buffer, (void *)timestamp_buffer_start, output_length);
}

//----- (0005C420) --------------------------------------------------------
int __fastcall get_function_description(int caller_id, int function_info_struct, int output_buffer)
{
  int function_info; // r3

  function_info = *(_DWORD *)(function_info_struct + 8);
  if ( *(_DWORD *)(function_info + 272) )
    return copy_to_buffer_with_resize(output_buffer, *(void **)(function_info + 280), *(_DWORD *)(function_info + 284));
  else
    return copy_to_buffer_with_resize(output_buffer, "(func=null)", 11u);
}

//----- (0005C454) --------------------------------------------------------
int __fastcall log_file_info(int unreferenced, int error_info_ptr, int log_buffer)
{
  int error_record; // r3
  char *file_name; // r1
  size_t file_name_length; // r2

  error_record = *(_DWORD *)(error_info_ptr + 8);
  file_name = *(char **)(error_record + 272);
  if ( file_name )
  {
    file_name_length = *(_DWORD *)(error_record + 276);
  }
  else
  {
    file_name = "(file=null)";
    file_name_length = 11;
  }
  return copy_to_buffer_with_resize(log_buffer, file_name, file_name_length);
}

//----- (0005C480) --------------------------------------------------------
int __fastcall update_firmware(int base_address, int firmware_info)
{
  int spec_address; // r4
  int (*validate_buffer)(void); // r6

  spec_address = base_address + 8192;
  validate_buffer = *(int (**)(void))(base_address + 9252);
  *(_DWORD *)(*(_DWORD *)(firmware_info + 12) + 4) = **(_DWORD **)(firmware_info + 12);
  if ( validate_buffer() >= 0 )
    return append_and_resize_buffer(
             *(_DWORD *)(firmware_info + 20),
             **(void ***)(firmware_info + 12),
             *(_DWORD *)(*(_DWORD *)(firmware_info + 12) + 4) - **(_DWORD **)(firmware_info + 12),
             *(_DWORD *)(spec_address + 1044),
             *(_DWORD *)(spec_address + 1048),
             *(_DWORD *)(spec_address + 1056),
             *(_DWORD *)(spec_address + 1052));
  sub_5DF98(2, "src/spec.c", 418, "a_spec->gen_buf fail");
  return -1;
}

//----- (0005C510) --------------------------------------------------------
int __fastcall process_data_chunk(int base_address, int argument_struct)
{
  int config_offset; // r4
  int (*check_data_function)(void); // r6

  config_offset = base_address + 8192;
  check_data_function = *(int (**)(void))(base_address + 9252);
  *(_DWORD *)(*(_DWORD *)(argument_struct + 12) + 4) = **(_DWORD **)(argument_struct + 12);
  if ( check_data_function() >= 0 )
    return append_and_resize_buffer(
             *(_DWORD *)(argument_struct + 16),
             **(void ***)(argument_struct + 12),
             *(_DWORD *)(*(_DWORD *)(argument_struct + 12) + 4) - **(_DWORD **)(argument_struct + 12),
             *(_DWORD *)(config_offset + 1044),
             *(_DWORD *)(config_offset + 1048),
             *(_DWORD *)(config_offset + 1056),
             *(_DWORD *)(config_offset + 1052));
  sub_5DF98(2, "src/spec.c", 392, "a_spec->gen_buf fail");
  return -1;
}

//----- (0005C5A0) --------------------------------------------------------
int __fastcall process_gen_buf(int base_address, int buf_struct_ptr)
{
  int gen_buf_offset; // r4
  int (*gen_buf_function)(void); // r6

  gen_buf_offset = base_address + 8192;
  gen_buf_function = *(int (**)(void))(base_address + 9252);
  *(_DWORD *)(*(_DWORD *)(buf_struct_ptr + 24) + 4) = **(_DWORD **)(buf_struct_ptr + 24);
  if ( gen_buf_function() >= 0 )
    return append_and_resize_buffer(
             *(_DWORD *)(buf_struct_ptr + 28),
             **(void ***)(buf_struct_ptr + 24),
             *(_DWORD *)(*(_DWORD *)(buf_struct_ptr + 24) + 4) - **(_DWORD **)(buf_struct_ptr + 24),
             *(_DWORD *)(gen_buf_offset + 1044),
             *(_DWORD *)(gen_buf_offset + 1048),
             *(_DWORD *)(gen_buf_offset + 1056),
             *(_DWORD *)(gen_buf_offset + 1052));
  sub_5DF98(2, "src/spec.c", 366, "a_spec->gen_buf fail");
  return -1;
}

//----- (0005C630) --------------------------------------------------------
int __fastcall log_specific_information(const char **spec_details, int log_level)
{
  const char *spec_valid_str; // r3

  if ( !spec_details )
    return sub_5DF98(2, "src/spec.c", 34, "a_spec is null or 0");
  spec_valid_str = "true";
  if ( !spec_details[2310] )
    spec_valid_str = "false";
  return sub_5DF98(
           log_level,
           "src/spec.c",
           41,
           "----spec[%p][%.*s][%s|%d][%s,%ld,%ld,%s][%s]----",
           spec_details,
           (int)spec_details[1],
           *spec_details,
           (const char *)spec_details + 8,
           spec_details[1027],
           (const char *)spec_details + 5137,
           spec_details[2311],
           spec_details[2312],
           spec_valid_str,
           (const char *)spec_details + 4112);
}

//----- (0005C6F4) --------------------------------------------------------
void __fastcall delete_logging_specification(void *specification_ptr)
{
  if ( specification_ptr )
  {
    sub_5DF98(0, "src/spec.c", 461, "zlog_spec_del[%p]", specification_ptr);
    free(specification_ptr);
  }
  else
  {
    sub_5DF98(2, "src/spec.c", 460, "a_spec is null or 0");
  }
}

//----- (0005C758) --------------------------------------------------------
const char **__fastcall parse_log_format(const char *pattern_start, char **pattern_next, const char **active_log_entry)
{
  _DWORD *allocated_structure; // r0
  const char **log_spec; // r4
  int first_char; // r3
  char *percent_pos; // r0
  const char *format_buffer; // r10
  const char **function_pointer_slot; // r7
  int scan_result; // r0
  int current_char; // r3
  char *current_ptr; // r5
  int compare_result; // r0
  const char *original_pattern_start; // r9
  char *new_ptr; // r5
  size_t pattern_length; // r0
  const char *log_spec_start; // r2
  const char *next_active_log_entry; // r3
  char *us_ptr; // r5
  int format_first_char; // r3
  char *dot_pos; // r0
  int decimal_count; // r3
  int sscanf_result; // r0
  int parenthesis_offset; // r3
  const char **temp_log_spec; // r0
  int format_char; // r2
  const char *current_log_entry; // r12
  int *errno_ptr; // r0
  int bytes_read; // [sp+Ch] [bp-2Ch] BYREF
  const char *width; // [sp+10h] [bp-28h] BYREF
  int precision; // [sp+14h] [bp-24h] BYREF

  bytes_read = 0;
  if ( !pattern_start )
  {
    log_spec = 0;
    sub_5DF98(2, "src/spec.c", 476, "pattern_start is null or 0");
    return log_spec;
  }
  if ( !pattern_next )
  {
    log_spec = 0;
    sub_5DF98(2, "src/spec.c", 477, "pattern_next is null or 0");
    return log_spec;
  }
  allocated_structure = calloc(1u, 9268u);
  log_spec = (const char **)allocated_structure;
  if ( !allocated_structure )
  {
    errno_ptr = _errno_location();
    sub_5DF98(2, "src/spec.c", 481, "calloc fail, errno[%d]", *errno_ptr);
    return log_spec;
  }
  first_char = *(unsigned __int8 *)pattern_start;
  *allocated_structure = pattern_start;
  if ( first_char != 37 )
  {
    percent_pos = strchr(pattern_start, 37);
    *pattern_next = percent_pos;
    if ( percent_pos )
    {
      log_spec[1] = (const char *)(percent_pos - pattern_start);
    }
    else
    {
      pattern_length = strlen(pattern_start);
      log_spec[1] = (const char *)pattern_length;
      *pattern_next = (char *)&pattern_start[pattern_length];
    }
    log_spec[2313] = (const char *)transmit_data;
    log_spec[2314] = (const char *)execute_custom_function;
    log_spec[2315] = (const char *)call_custom_function;
    log_spec[2316] = (const char *)invoke_device_operation;
    goto LABEL_8;
  }
  format_buffer = (char *)allocated_structure + 5137;
  bytes_read = 0;
  if ( _isoc99_sscanf(pattern_start, "%%%[.0-9-]%n", (char *)allocated_structure + 5137, &bytes_read) == 1 )
  {
    function_pointer_slot = log_spec + 2048;
    log_spec[2314] = (const char *)process_gen_buf;
    log_spec[2315] = (_BYTE *)process_data_chunk;
    log_spec[2316] = (const char *)update_firmware;
    format_first_char = *((unsigned __int8 *)log_spec + 5137);
    if ( format_first_char == 45 )
    {
      log_spec[2309] = (const char *)1;
      format_buffer = (char *)log_spec + 5138;
    }
    else
    {
      if ( format_first_char == 48 )
        log_spec[2310] = (const char *)1;
      log_spec[2309] = 0;
    }
    width = 0;
    precision = 0;
    _isoc99_sscanf(format_buffer, "%ld.", &width);
    dot_pos = strchr(format_buffer, 46);
    if ( dot_pos )
      _isoc99_sscanf(dot_pos, ".%ld", &precision);
    decimal_count = precision;
    scan_result = bytes_read;
    log_spec[2312] = width;
    log_spec[2311] = (const char *)decimal_count;
  }
  else
  {
    function_pointer_slot = log_spec + 2048;
    log_spec[2314] = (const char *)execute_custom_function;
    scan_result = 1;
    log_spec[2315] = (const char *)call_custom_function;
    log_spec[2316] = (const char *)invoke_device_operation;
    bytes_read = 1;
  }
  current_char = (unsigned __int8)pattern_start[scan_result];
  current_ptr = (char *)&pattern_start[scan_result];
  if ( current_char != 100 )
  {
    if ( current_char != 77 )
    {
      compare_result = strncmp(current_ptr, "ms", 2u);
      original_pattern_start = *log_spec;
      if ( compare_result )
      {
        if ( strncmp(current_ptr, "us", 2u) )
        {
          *pattern_next = current_ptr + 1;
          format_char = (unsigned __int8)*current_ptr;
          log_spec[1] = (const char *)(current_ptr - original_pattern_start + 1);
          switch ( format_char )
          {
            case '%':
              function_pointer_slot[265] = (_BYTE *)format_percentage;
              goto LABEL_8;
            case 'D':
              current_log_entry = *active_log_entry;
              strcpy((char *)log_spec + 8, "%F %T");
              *active_log_entry = current_log_entry + 1;
              log_spec[1027] = current_log_entry;
              function_pointer_slot[265] = (const char *)update_log_timestamp;
              goto LABEL_8;
            case 'F':
              function_pointer_slot[265] = (_BYTE *)log_file_info;
              goto LABEL_8;
            case 'H':
              function_pointer_slot[265] = (_BYTE *)calculation_result;
              goto LABEL_8;
            case 'L':
              function_pointer_slot[265] = (_BYTE *)extract_and_forward_device_info;
              goto LABEL_8;
            case 'T':
              function_pointer_slot[265] = (_BYTE *)perform_custom_operation;
              goto LABEL_8;
            case 'U':
              function_pointer_slot[265] = (_BYTE *)get_function_description;
              goto LABEL_8;
            case 'V':
              function_pointer_slot[265] = (_BYTE *)calculate_chip_performance;
              goto LABEL_8;
            case 'c':
              function_pointer_slot[265] = (_BYTE *)trigger_event_with_parameters;
              goto LABEL_8;
            case 'f':
              function_pointer_slot[265] = (_BYTE *)extract_last_path_segment;
              goto LABEL_8;
            case 'k':
              function_pointer_slot[265] = (_BYTE *)send_miner_command;
              goto LABEL_8;
            case 'm':
              function_pointer_slot[265] = (_BYTE *)process_debug_output;
              goto LABEL_8;
            case 'n':
              function_pointer_slot[265] = (_BYTE *)send_status_to_controller;
              goto LABEL_8;
            case 'p':
              function_pointer_slot[265] = (_BYTE *)initialize_process_id;
              goto LABEL_8;
            case 't':
              function_pointer_slot[265] = (_BYTE *)forward_command_to_miner;
              goto LABEL_8;
            case 'v':
              function_pointer_slot[265] = (_BYTE *)calculate_asics_performance;
              goto LABEL_8;
            default:
              sub_5DF98(2, "src/spec.c", 634, "str[%s] in wrong format, p[%c]", original_pattern_start, format_char);
              goto LABEL_38;
          }
        }
        us_ptr = current_ptr + 2;
        log_spec[1] = (const char *)(us_ptr - original_pattern_start);
        *pattern_next = us_ptr;
        function_pointer_slot[265] = (const char *)update_miner_timestamp;
      }
      else
      {
        new_ptr = current_ptr + 2;
        log_spec[1] = (const char *)(new_ptr - original_pattern_start);
        *pattern_next = new_ptr;
        function_pointer_slot[265] = (const char *)initialize_miner_timer;
      }
      goto LABEL_8;
    }
    bytes_read = 0;
    if ( _isoc99_sscanf(current_ptr, "M(%[^)])%n", log_spec + 1028, &bytes_read) == 1 )
    {
      current_ptr += bytes_read;
    }
    else
    {
      bytes_read = 0;
      if ( !strncmp(current_ptr, "M()", 3u) )
      {
        current_ptr += 3;
        bytes_read = 3;
      }
    }
    if ( *(current_ptr - 1) == 41 )
    {
      log_spec[1] = (const char *)(current_ptr - *log_spec);
      *pattern_next = current_ptr;
      function_pointer_slot[265] = (const char *)get_mdc_value_for_key;
      goto LABEL_8;
    }
    sub_5DF98(2, "src/spec.c", 554, "in string[%s] can't find match ')'", *log_spec);
LABEL_38:
    temp_log_spec = log_spec;
    log_spec = 0;
    delete_logging_specification(temp_log_spec);
    return log_spec;
  }
  if ( current_ptr[1] == 40 )
  {
    if ( !strncmp(current_ptr, "d()", 3u) )
    {
      current_ptr += 3;
      strcpy((char *)log_spec + 8, "%F %T");
      log_spec_start = *log_spec;
    }
    else
    {
      bytes_read = 0;
      sscanf_result = _isoc99_sscanf(current_ptr, "d(%[^)])%n", log_spec + 2, &bytes_read);
      log_spec_start = *log_spec;
      if ( sscanf_result == 1 )
        parenthesis_offset = bytes_read;
      else
        bytes_read = 0;
      if ( sscanf_result == 1 )
        current_ptr += parenthesis_offset;
      if ( *(current_ptr - 1) != 41 )
      {
        sub_5DF98(2, "src/spec.c", 529, "in string[%s] can't find match ')'", log_spec_start);
        goto LABEL_38;
      }
    }
  }
  else
  {
    ++current_ptr;
    strcpy((char *)log_spec + 8, "%F %T");
    log_spec_start = *log_spec;
  }
  next_active_log_entry = *active_log_entry;
  log_spec[1027] = *active_log_entry;
  *active_log_entry = next_active_log_entry + 1;
  function_pointer_slot[265] = (const char *)update_log_timestamp;
  *pattern_next = current_ptr;
  log_spec[1] = (const char *)(current_ptr - log_spec_start);
LABEL_8:
  log_specific_information(log_spec, 0);
  return log_spec;
}
// 5CADC: control flows out of bounds to 5CAE0
// 5CA78: variable 'parenthesis_offset' is possibly undefined
// 1231C: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);

//----- (0005CEC0) --------------------------------------------------------
int __fastcall log_thread_information(int thread_data_pointer, int log_level)
{
  if ( !thread_data_pointer )
    return sub_5DF98(2, "src/thread.c", 20, "a_thread is null or 0");
  sub_5DF98(
    log_level,
    "src/thread.c",
    29,
    "--thread[%p][%p][%p][%p,%p,%p,%p,%p]--",
    (const void *)thread_data_pointer,
    *(const void **)(thread_data_pointer + 4),
    *(const void **)(thread_data_pointer + 8),
    *(const void **)(thread_data_pointer + 12),
    *(const void **)(thread_data_pointer + 16),
    *(const void **)(thread_data_pointer + 20),
    *(const void **)(thread_data_pointer + 24),
    *(const void **)(thread_data_pointer + 28));
  print_mdc_status(*(int **)(thread_data_pointer + 4), log_level);
  log_event_details(*(const char ***)(thread_data_pointer + 8), log_level);
  format_buffer_information(*(const void ***)(thread_data_pointer + 12), log_level);
  format_buffer_information(*(const void ***)(thread_data_pointer + 16), log_level);
  format_buffer_information(*(const void ***)(thread_data_pointer + 20), log_level);
  format_buffer_information(*(const void ***)(thread_data_pointer + 24), log_level);
  return format_buffer_information(*(const void ***)(thread_data_pointer + 28), log_level);
}

//----- (0005CFA8) --------------------------------------------------------
void __fastcall release_thread_resources(_DWORD *thread_data)
{
  _DWORD **mdc_hashtable; // r0
  _DWORD *event_data; // r0
  void **buffer_1; // r0
  void **buffer_2; // r0
  void **buffer_3; // r0
  void **buffer_4; // r0
  void **buffer_5; // r0

  if ( thread_data )
  {
    mdc_hashtable = (_DWORD **)thread_data[1];
    if ( mdc_hashtable )
      delete_mdc_hashtable(mdc_hashtable);
    event_data = (_DWORD *)thread_data[2];
    if ( event_data )
      free_event_data(event_data);
    buffer_1 = (void **)thread_data[3];
    if ( buffer_1 )
      free_buffer(buffer_1);
    buffer_2 = (void **)thread_data[4];
    if ( buffer_2 )
      free_buffer(buffer_2);
    buffer_3 = (void **)thread_data[5];
    if ( buffer_3 )
      free_buffer(buffer_3);
    buffer_4 = (void **)thread_data[6];
    if ( buffer_4 )
      free_buffer(buffer_4);
    buffer_5 = (void **)thread_data[7];
    if ( buffer_5 )
      free_buffer(buffer_5);
    sub_5DF98(0, "src/thread.c", 59, "zlog_thread_del[%p]", thread_data);
    free(thread_data);
  }
  else
  {
    sub_5DF98(2, "src/thread.c", 43, "a_thread is null or 0");
  }
}

//----- (0005D07C) --------------------------------------------------------
_DWORD *__fastcall initialize_logging_thread(
        int socket_descriptor,
        size_t buffer_size,
        unsigned int block_size,
        size_t event_size)
{
  _DWORD *allocated_thread_memory; // r0
  _DWORD *thread_data; // r4
  _DWORD *mdc_storage; // r0
  void *event_data; // r0
  void **buffer_a; // r0
  void **buffer_b; // r0
  void **buffer_c; // r0
  void **input_buffer; // r0
  void **output_buffer; // r0
  int *error_num; // r0

  allocated_thread_memory = calloc(1u, 32u);
  thread_data = allocated_thread_memory;
  if ( !allocated_thread_memory )
  {
    error_num = _errno_location();
    sub_5DF98(2, "src/thread.c", 70, "calloc fail, errno[%d]", *error_num);
    return thread_data;
  }
  *allocated_thread_memory = socket_descriptor;
  mdc_storage = initialize_mdc_storage();
  thread_data[1] = mdc_storage;
  if ( mdc_storage )
  {
    event_data = initialize_event_data(event_size);
    thread_data[2] = event_data;
    if ( event_data )
    {
      buffer_a = initialize_buffer(1025u, 1025u, 0);
      thread_data[3] = buffer_a;
      if ( buffer_a )
      {
        buffer_b = initialize_buffer(1025u, 1025u, 0);
        thread_data[4] = buffer_b;
        if ( buffer_b )
        {
          buffer_c = initialize_buffer(1025u, 1025u, 0);
          thread_data[5] = buffer_c;
          if ( buffer_c )
          {
            input_buffer = initialize_buffer(buffer_size, block_size, "...\n");
            thread_data[6] = input_buffer;
            if ( input_buffer )
            {
              output_buffer = initialize_buffer(buffer_size, block_size, "...\n");
              thread_data[7] = output_buffer;
              if ( output_buffer )
                return thread_data;
              sub_5DF98(2, "src/thread.c", 114, "zlog_buf_new fail");
            }
            else
            {
              sub_5DF98(2, "src/thread.c", 108, "zlog_buf_new fail");
            }
          }
          else
          {
            sub_5DF98(2, "src/thread.c", 102, "zlog_buf_new fail");
          }
        }
        else
        {
          sub_5DF98(2, "src/thread.c", 96, "zlog_buf_new fail");
        }
      }
      else
      {
        sub_5DF98(2, "src/thread.c", 90, "zlog_buf_new fail");
      }
    }
    else
    {
      sub_5DF98(2, "src/thread.c", 84, "zlog_event_new fail");
    }
  }
  else
  {
    sub_5DF98(2, "src/thread.c", 78, "zlog_mdc_new fail");
  }
  release_thread_resources(thread_data);
  return 0;
}

//----- (0005D290) --------------------------------------------------------
int __fastcall rebuild_buffer_if_needed(int thread_ptr, size_t buffer_size, unsigned int arg_value)
{
  int thread_buffer_info; // r3
  void **new_buffer1; // r7
  void **new_buffer2; // r5
  void **old_buffer; // r0
  int rebuild_result; // r0

  if ( thread_ptr )
  {
    thread_buffer_info = *(_DWORD *)(thread_ptr + 28);
    if ( *(_DWORD *)(thread_buffer_info + 16) == buffer_size && *(_DWORD *)(thread_buffer_info + 20) == arg_value )
    {
      sub_5DF98(0, "src/thread.c", 135, "buf size not changed, no need rebuild");
      return 0;
    }
    else
    {
      new_buffer1 = initialize_buffer(buffer_size, arg_value, "...\n");
      if ( new_buffer1 )
      {
        new_buffer2 = initialize_buffer(buffer_size, arg_value, "...\n");
        if ( new_buffer2 )
        {
          free_buffer(*(void ***)(thread_ptr + 24));
          old_buffer = *(void ***)(thread_ptr + 28);
          *(_DWORD *)(thread_ptr + 24) = new_buffer1;
          free_buffer(old_buffer);
          rebuild_result = 0;
          *(_DWORD *)(thread_ptr + 28) = new_buffer2;
        }
        else
        {
          sub_5DF98(2, "src/thread.c", 147, "zlog_buf_new fail");
          free_buffer(new_buffer1);
          return -1;
        }
      }
      else
      {
        sub_5DF98(2, "src/thread.c", 141, "zlog_buf_new fail");
        return -1;
      }
    }
  }
  else
  {
    sub_5DF98(2, "src/thread.c", 131, "a_thread is null or 0");
    return -1;
  }
  return rebuild_result;
}

//----- (0005D3B0) --------------------------------------------------------
int __fastcall allocate_event_memory(int thread_handle, size_t memory_size)
{
  void *new_event_data; // r5
  int allocation_result; // r0

  if ( thread_handle )
  {
    new_event_data = initialize_event_data(memory_size);
    if ( new_event_data )
    {
      free_event_data(*(_DWORD **)(thread_handle + 8));
      allocation_result = 0;
      *(_DWORD *)(thread_handle + 8) = new_event_data;
    }
    else
    {
      sub_5DF98(2, "src/thread.c", 171, "zlog_event_new fail");
      return -1;
    }
  }
  else
  {
    sub_5DF98(2, "src/thread.c", 167, "a_thread is null or 0");
    return -1;
  }
  return allocation_result;
}

//----- (0005D428) --------------------------------------------------------
int __fastcall resize_dynamic_array(void **array_ptr, int *current_size, int min_size)
{
  void *original_array; // r0
  int new_size; // r4
  char *resized_array; // r0
  int old_size; // r3
  int resize_status; // r0
  int *errno_ptr; // r0

  original_array = *array_ptr;
  new_size = 2 * *current_size;
  if ( new_size < min_size )
    new_size = min_size;
  resized_array = (char *)realloc(original_array, 4 * new_size);
  if ( resized_array )
  {
    old_size = *current_size;
    *array_ptr = resized_array;
    if ( new_size != old_size )
      memset(&resized_array[4 * old_size], 0, 4 * (new_size - old_size));
    resize_status = 0;
    *current_size = new_size;
  }
  else
  {
    errno_ptr = _errno_location();
    sub_5DF98(2, "src/zc_arraylist.c", 67, "realloc fail, errno[%d]", *errno_ptr);
    return -1;
  }
  return resize_status;
}

//----- (0005D4C0) --------------------------------------------------------
_DWORD *__fastcall sub_5D4C0(int a1)
{
  _DWORD *v2; // r0
  _DWORD *v3; // r4
  void *v4; // r5
  int *v6; // r0
  int *v7; // r0
  void *v8; // r0

  v2 = calloc(1u, 16u);
  v3 = v2;
  if ( v2 )
  {
    v2[3] = a1;
    v2[2] = 32;
    v2[1] = 0;
    v4 = calloc(32u, 4u);
    *v3 = v4;
    if ( !v4 )
    {
      v7 = _errno_location();
      sub_5DF98(2, "src/zc_arraylist.c", 32, "calloc fail, errno[%d]", *v7);
      v8 = v3;
      v3 = 0;
      free(v8);
    }
  }
  else
  {
    v6 = _errno_location();
    sub_5DF98(2, "src/zc_arraylist.c", 22, "calloc fail, errno[%d]", *v6);
  }
  return v3;
}

//----- (0005D580) --------------------------------------------------------
void __fastcall process_and_free_resources(_DWORD *resource_ptr)
{
  _DWORD *inner_resource_array; // r2
  int resource_count; // r1
  int index; // r5
  int current_resource; // r3

  if ( resource_ptr )
  {
    inner_resource_array = (_DWORD *)*resource_ptr;
    if ( resource_ptr[3] )
    {
      resource_count = resource_ptr[1];
      if ( resource_count > 0 )
      {
        for ( index = 0; index < resource_count; ++index )
        {
          current_resource = inner_resource_array[index];
          if ( current_resource )
          {
            ((void (__fastcall *)(int))resource_ptr[3])(current_resource);
            inner_resource_array = (_DWORD *)*resource_ptr;
            resource_count = resource_ptr[1];
          }
        }
      }
    }
    if ( inner_resource_array )
      free(inner_resource_array);
    free(resource_ptr);
  }
}

//----- (0005D5F0) --------------------------------------------------------
int __fastcall resize_array_list(int array_list, int index, int new_element)
{
  _DWORD *target_element_ptr; // r3
  void (*destruction_callback)(void); // r2
  int current_size; // r2
  int resize_result; // r0

  if ( *(_DWORD *)(array_list + 8) <= index && resize_dynamic_array((void **)array_list, (int *)(array_list + 8), index) )
  {
    sub_5DF98(2, "src/zc_arraylist.c", 81, "expand_internal fail");
    return -1;
  }
  else
  {
    target_element_ptr = (_DWORD *)(*(_DWORD *)array_list + 4 * index);
    if ( *target_element_ptr )
    {
      destruction_callback = *(void (**)(void))(array_list + 12);
      if ( destruction_callback )
      {
        destruction_callback();
        target_element_ptr = (_DWORD *)(*(_DWORD *)array_list + 4 * index);
      }
    }
    current_size = *(_DWORD *)(array_list + 4);
    *target_element_ptr = new_element;
    resize_result = 0;
    if ( current_size <= index )
      *(_DWORD *)(array_list + 4) = index + 1;
  }
  return resize_result;
}

//----- (0005D694) --------------------------------------------------------
int __fastcall invoke_custom_subroutine(int first_argument, int second_argument)
{
  return resize_array_list(first_argument, *(_DWORD *)(first_argument + 4), second_argument);
}

//----- (0005D6A0) --------------------------------------------------------
int __fastcall insert_into_array(int array_ptr, int (__fastcall *compare_func)(_DWORD, int), int new_element)
{
  int array_length; // r3
  int insert_index; // r4
  int compare_result; // r0
  _DWORD *array; // r12
  int temp_index; // r7
  int func_result; // r0
  const void *insert_position; // r1
  int new_array_length; // r3

  array_length = *(_DWORD *)(array_ptr + 4);
  if ( array_length <= 0 )
  {
    insert_index = 0;
  }
  else
  {
    insert_index = 0;
    for ( compare_result = compare_func(**(_DWORD **)array_ptr, new_element);
          ;
          compare_result = compare_func(*(_DWORD *)(*(_DWORD *)array_ptr + 4 * insert_index), new_element) )
    {
      array_length = *(_DWORD *)(array_ptr + 4);
      if ( compare_result > 0 )
        break;
      if ( array_length <= ++insert_index )
        break;
    }
  }
  if ( insert_index == array_length )
    return resize_array_list(array_ptr, insert_index, new_element);
  array = *(_DWORD **)array_ptr;
  temp_index = insert_index;
  func_result = *(_DWORD *)(*(_DWORD *)array_ptr + 4 * insert_index);
  insert_position = (const void *)(*(_DWORD *)array_ptr + 4 * insert_index);
  if ( func_result )
  {
    if ( *(_DWORD *)(array_ptr + 8) > array_length )
    {
LABEL_11:
      memmove(&array[temp_index + 1], insert_position, 4 * (array_length - insert_index));
      func_result = 0;
      new_array_length = *(_DWORD *)(array_ptr + 4) + 1;
      *(_DWORD *)(*(_DWORD *)array_ptr + 4 * insert_index) = new_element;
      *(_DWORD *)(array_ptr + 4) = new_array_length;
      return func_result;
    }
    if ( !resize_dynamic_array((void **)array_ptr, (int *)(array_ptr + 8), 0) )
    {
      array = *(_DWORD **)array_ptr;
      array_length = *(_DWORD *)(array_ptr + 4);
      insert_position = (const void *)(*(_DWORD *)array_ptr + temp_index * 4);
      goto LABEL_11;
    }
    sub_5DF98(2, "src/zc_arraylist.c", 107, "expand_internal fail");
    return -1;
  }
  else
  {
    array[insert_index] = new_element;
  }
  return func_result;
}

//----- (0005D7B8) --------------------------------------------------------
_DWORD *__fastcall initialize_hashtable(
        size_t num_elements,
        int hash_func,
        int compare_func,
        int key_dup_func,
        int value_dup_func)
{
  _DWORD *hashtable; // r4
  void *buckets; // r6
  int *errno_ptr_init; // r0
  int *errno_ptr_alloc; // r0
  void *temp_hashtable; // r0

  hashtable = calloc(1u, 28u);
  if ( hashtable )
  {
    buckets = calloc(num_elements, 4u);
    hashtable[1] = buckets;
    if ( buckets )
    {
      hashtable[2] = num_elements;
      hashtable[3] = hash_func;
      hashtable[4] = compare_func;
      hashtable[5] = key_dup_func;
      hashtable[6] = value_dup_func;
      *hashtable = 0;
    }
    else
    {
      errno_ptr_alloc = _errno_location();
      sub_5DF98(2, "src/zc_hashtable.c", 44, "calloc fail, errno[%d]", *errno_ptr_alloc);
      temp_hashtable = hashtable;
      hashtable = 0;
      free(temp_hashtable);
    }
  }
  else
  {
    errno_ptr_init = _errno_location();
    sub_5DF98(2, "src/zc_hashtable.c", 38, "calloc fail, errno[%d]", *errno_ptr_init);
  }
  return hashtable;
}

//----- (0005D890) --------------------------------------------------------
void __fastcall free_hashtable(_DWORD *hashtable)
{
  _DWORD *buckets_array; // r0
  unsigned int bucket_count; // r3
  unsigned int bucket_index; // r7
  _DWORD *entry_ptr; // r4
  void (__fastcall *free_key_func)(_DWORD); // r3
  _DWORD *next_entry_ptr; // r6
  void (__fastcall *free_value_func)(_DWORD); // r3
  void *current_entry_to_free; // r0

  if ( hashtable )
  {
    buckets_array = (_DWORD *)hashtable[1];
    bucket_count = hashtable[2];
    if ( bucket_count )
    {
      for ( bucket_index = 0; bucket_index < bucket_count; ++bucket_index )
      {
        entry_ptr = (_DWORD *)buckets_array[bucket_index];
        if ( entry_ptr )
        {
          do
          {
            free_key_func = (void (__fastcall *)(_DWORD))hashtable[5];
            next_entry_ptr = (_DWORD *)entry_ptr[4];
            if ( free_key_func )
              free_key_func(entry_ptr[1]);
            free_value_func = (void (__fastcall *)(_DWORD))hashtable[6];
            if ( free_value_func )
              free_value_func(entry_ptr[2]);
            current_entry_to_free = entry_ptr;
            entry_ptr = next_entry_ptr;
            free(current_entry_to_free);
          }
          while ( next_entry_ptr );
          buckets_array = (_DWORD *)hashtable[1];
          bucket_count = hashtable[2];
        }
      }
    }
    if ( buckets_array )
      free(buckets_array);
    free(hashtable);
  }
  else
  {
    sub_5DF98(2, "src/zc_hashtable.c", 68, "a_table[%p] is NULL, just do nothing", 0);
  }
}

//----- (0005D950) --------------------------------------------------------
_DWORD *__fastcall sub_5D950(_DWORD *resources)
{
  unsigned int count; // r1
  _DWORD *handle; // r5
  int list_base; // r3
  unsigned int index; // r7
  _DWORD *current; // r4
  _DWORD *pointer; // r2
  void (__fastcall *release_func1)(_DWORD); // r3
  _DWORD *next; // r6
  void (__fastcall *release_func2)(_DWORD); // r3
  void *to_free; // r0

  count = resources[2];
  handle = resources;
  if ( count )
  {
    list_base = resources[1];
    for ( index = 0; index < count; ++index )
    {
      current = *(_DWORD **)(list_base + 4 * index);
      pointer = (_DWORD *)(list_base + 4 * index);
      if ( current )
      {
        do
        {
          release_func1 = (void (__fastcall *)(_DWORD))handle[5];
          next = (_DWORD *)current[4];
          if ( release_func1 )
            release_func1(current[1]);
          release_func2 = (void (__fastcall *)(_DWORD))handle[6];
          if ( release_func2 )
            release_func2(current[2]);
          to_free = current;
          current = next;
          free(to_free);
        }
        while ( next );
        list_base = handle[1];
        count = handle[2];
        pointer = (_DWORD *)(list_base + 4 * index);
      }
      *pointer = 0;
    }
  }
  *handle = 0;
  return resources;
}

//----- (0005D9EC) --------------------------------------------------------
int __fastcall get_matching_entry(int table_ptr, int entry_key)
{
  unsigned int hashed_key; // r0
  int hash_index; // r1
  int entry_ptr; // r4

  hashed_key = (*(int (__fastcall **)(int))(table_ptr + 12))(entry_key);
  calculate_difficulty_ratio(hashed_key, *(_DWORD *)(table_ptr + 8));
  entry_ptr = *(_DWORD *)(*(_DWORD *)(table_ptr + 4) + 4 * hash_index);
  if ( !entry_ptr )
    return 0;
  while ( !(*(int (__fastcall **)(int, _DWORD))(table_ptr + 16))(entry_key, *(_DWORD *)(entry_ptr + 4)) )
  {
    entry_ptr = *(_DWORD *)(entry_ptr + 16);
    if ( !entry_ptr )
      return 0;
  }
  return entry_ptr;
}
// 5DA10: variable 'hash_index' is possibly undefined

//----- (0005DA58) --------------------------------------------------------
int __fastcall process_task(int task_data, int input_param)
{
  unsigned int operation_result; // r0
  int index; // r1
  _DWORD *current_node; // r4

  operation_result = (*(int (__fastcall **)(int))(task_data + 12))(input_param);
  calculate_difficulty_ratio(operation_result, *(_DWORD *)(task_data + 8));
  current_node = *(_DWORD **)(*(_DWORD *)(task_data + 4) + 4 * index);
  if ( !current_node )
    return 0;
  while ( !(*(int (__fastcall **)(int, _DWORD))(task_data + 16))(input_param, current_node[1]) )
  {
    current_node = (_DWORD *)current_node[4];
    if ( !current_node )
      return 0;
  }
  return current_node[2];
}
// 5DA7C: variable 'index' is possibly undefined

//----- (0005DAC0) --------------------------------------------------------
int __fastcall sub_5DAC0(int a1, int a2, int a3)
{
  int v3; // r5
  unsigned int v5; // r0
  unsigned int v6; // r9
  int v7; // r1
  _DWORD *v8; // r4
  void (__fastcall *v9)(_DWORD); // r3
  void (__fastcall *v10)(_DWORD); // r3
  int result; // r0
  unsigned int v12; // r8
  void *v13; // r0
  void *v14; // r11
  unsigned int **v15; // r10
  _DWORD *v16; // r5
  unsigned int *v17; // r4
  unsigned int *v18; // t1
  unsigned int *v19; // r11
  unsigned int v20; // r0
  int v21; // r1
  int v22; // r3
  _DWORD *v23; // r4
  unsigned int v24; // r0
  unsigned int v25; // r1
  int v26; // r1
  int v27; // r2
  int v28; // r3
  unsigned int v29; // r3
  int *v30; // r0
  int *v31; // r0
  char *ptr; // [sp+10h] [bp-30h]
  int v34; // [sp+14h] [bp-2Ch]

  v3 = a1;
  v5 = (*(int (__fastcall **)(int))(a1 + 12))(a2);
  v6 = *(_DWORD *)(v3 + 8);
  calculate_difficulty_ratio(v5, v6);
  v8 = *(_DWORD **)(*(_DWORD *)(v3 + 4) + 4 * v7);
  if ( v8 )
  {
    while ( !(*(int (__fastcall **)(int, _DWORD))(v3 + 16))(a2, v8[1]) )
    {
      v8 = (_DWORD *)v8[4];
      if ( !v8 )
      {
        v6 = *(_DWORD *)(v3 + 8);
        goto LABEL_11;
      }
    }
    v9 = *(void (__fastcall **)(_DWORD))(v3 + 20);
    if ( v9 )
      v9(v8[1]);
    v10 = *(void (__fastcall **)(_DWORD))(v3 + 24);
    if ( v10 )
      v10(v8[2]);
    result = 0;
    v8[1] = a2;
    v8[2] = a3;
  }
  else
  {
LABEL_11:
    if ( (double)*(unsigned int *)v3 > (double)v6 * 1.3 )
    {
      v12 = 2 * v6;
      v13 = calloc(2 * v6, 4u);
      v14 = v13;
      if ( !v13 )
      {
        v30 = _errno_location();
        sub_5DF98(2, "src/zc_hashtable.c", 126, "calloc fail, errno[%d]", *v30);
        sub_5DF98(2, "src/zc_hashtable.c", 205, "rehash fail");
        return -1;
      }
      ptr = *(char **)(v3 + 4);
      if ( v6 )
      {
        v15 = *(unsigned int ***)(v3 + 4);
        v34 = v3;
        v16 = v13;
        do
        {
          v18 = *v15++;
          v17 = v18;
          if ( v18 )
          {
            do
            {
              v19 = (unsigned int *)v17[4];
              v20 = *v17;
              v17[3] = 0;
              v17[4] = 0;
              calculate_difficulty_ratio(v20, v12);
              v22 = v16[v21];
              if ( v22 )
              {
                *(_DWORD *)(v22 + 12) = v17;
                v17[4] = v16[v21];
              }
              v16[v21] = v17;
              v17 = v19;
            }
            while ( v19 );
          }
        }
        while ( &ptr[4 * v6] != (char *)v15 );
        v14 = v16;
        v3 = v34;
      }
      free(ptr);
      *(_DWORD *)(v3 + 4) = v14;
      *(_DWORD *)(v3 + 8) = v12;
    }
    v23 = calloc(1u, 20u);
    if ( v23 )
    {
      v24 = (*(int (__fastcall **)(int))(v3 + 12))(a2);
      v25 = *(_DWORD *)(v3 + 8);
      v23[4] = 0;
      v23[2] = a3;
      v23[3] = 0;
      *v23 = v24;
      v23[1] = a2;
      calculate_difficulty_ratio(v24, v25);
      v27 = *(_DWORD *)(v3 + 4);
      result = 0;
      v28 = *(_DWORD *)(v27 + 4 * v26);
      if ( v28 )
      {
        *(_DWORD *)(v28 + 12) = v23;
        v23[4] = *(_DWORD *)(v27 + 4 * v26);
      }
      v29 = *(_DWORD *)v3;
      *(_DWORD *)(v27 + 4 * v26) = v23;
      *(_DWORD *)v3 = v29 + 1;
    }
    else
    {
      v31 = _errno_location();
      sub_5DF98(2, "src/zc_hashtable.c", 212, "calloc fail, errno[%d]", *v31);
      return -1;
    }
  }
  return result;
}
// 5DAF0: variable 'v7' is possibly undefined
// 5DBEC: variable 'v21' is possibly undefined
// 5DC74: variable 'v26' is possibly undefined

//----- (0005DD28) --------------------------------------------------------
void __fastcall remove_key_from_hashtable(_DWORD *hash_table, const void *key)
{
  bool is_null_check; // zf
  unsigned int hashed_key; // r0
  int bucket_index; // r1
  unsigned int *current_entry; // r4
  void (__fastcall *free_key_function)(unsigned int); // r3
  void (__fastcall *free_value_function)(unsigned int); // r3
  unsigned int next_entry; // r6
  unsigned int previous_entry; // r3
  int bucket_index_for_free; // r1

  is_null_check = key == 0;
  if ( key )
    is_null_check = hash_table == 0;
  if ( is_null_check )
  {
    sub_5DF98(2, "src/zc_hashtable.c", 240, "a_table[%p] or a_key[%p] is NULL, just do nothing", hash_table, key);
  }
  else
  {
    hashed_key = ((int (__fastcall *)(const void *))hash_table[3])(key);
    calculate_difficulty_ratio(hashed_key, hash_table[2]);
    current_entry = *(unsigned int **)(hash_table[1] + 4 * bucket_index);
    if ( current_entry )
    {
      while ( !((int (__fastcall *)(const void *, unsigned int))hash_table[4])(key, current_entry[1]) )
      {
        current_entry = (unsigned int *)current_entry[4];
        if ( !current_entry )
          goto LABEL_18;
      }
      free_key_function = (void (__fastcall *)(unsigned int))hash_table[5];
      if ( free_key_function )
        free_key_function(current_entry[1]);
      free_value_function = (void (__fastcall *)(unsigned int))hash_table[6];
      if ( free_value_function )
        free_value_function(current_entry[2]);
      next_entry = current_entry[4];
      previous_entry = current_entry[3];
      if ( next_entry )
      {
        *(_DWORD *)(next_entry + 12) = previous_entry;
        previous_entry = current_entry[3];
      }
      if ( previous_entry )
      {
        *(_DWORD *)(previous_entry + 16) = next_entry;
      }
      else
      {
        calculate_difficulty_ratio(*current_entry, hash_table[2]);
        *(_DWORD *)(hash_table[1] + 4 * bucket_index_for_free) = next_entry;
      }
      free(current_entry);
      --*hash_table;
    }
    else
    {
LABEL_18:
      sub_5DF98(2, "src/zc_hashtable.c", 251, "p[%p] not found in hashtable", 0);
    }
  }
}
// 5DD5C: variable 'bucket_index' is possibly undefined
// 5DE30: variable 'bucket_index_for_free' is possibly undefined

//----- (0005DE60) --------------------------------------------------------
int __fastcall get_first_non_zero_value(int input_ptr)
{
  int number_of_elements; // r12
  int *values_array; // r2
  int first_non_zero; // r0
  int index; // r3
  int current_value; // r1
  int next_value; // t1

  number_of_elements = *(_DWORD *)(input_ptr + 8);
  if ( !number_of_elements )
    return 0;
  values_array = *(int **)(input_ptr + 4);
  first_non_zero = *values_array;
  if ( !*values_array )
  {
    index = 0;
    while ( ++index != number_of_elements )
    {
      next_value = values_array[1];
      ++values_array;
      current_value = next_value;
      if ( next_value )
        return current_value;
    }
  }
  return first_non_zero;
}

//----- (0005DEA8) --------------------------------------------------------
unsigned int __fastcall get_next_active_value(int array_ptr, unsigned int *value_array)
{
  unsigned int next_active_value; // r4
  unsigned int value_count; // r5
  int current_index; // r1
  unsigned int next_index; // r1
  int value_array_start; // r3
  int current_value_ptr; // r3
  int potential_active_value; // r2
  int next_value; // t1

  next_active_value = value_array[4];
  if ( !next_active_value )
  {
    value_count = *(_DWORD *)(array_ptr + 8);
    calculate_difficulty_ratio(*value_array, value_count);
    next_index = current_index + 1;
    if ( value_count > next_index )
    {
      value_array_start = *(_DWORD *)(array_ptr + 4);
      next_active_value = *(_DWORD *)(value_array_start + 4 * next_index);
      current_value_ptr = value_array_start + 4 * next_index;
      if ( !next_active_value )
      {
        while ( value_count > ++next_index )
        {
          next_value = *(_DWORD *)(current_value_ptr + 4);
          current_value_ptr += 4;
          potential_active_value = next_value;
          if ( next_value )
            return potential_active_value;
        }
      }
    }
  }
  return next_active_value;
}
// 5DED4: variable 'current_index' is possibly undefined

//----- (0005DF18) --------------------------------------------------------
int __fastcall generate_hash(_BYTE *input_string)
{
  int current_char; // r3
  int hash; // r2
  int hash_helper; // r1
  int next_char; // t1

  current_char = (unsigned __int8)*input_string;
  hash = 5381;
  if ( *input_string )
  {
    do
    {
      hash_helper = current_char + 32 * hash;
      next_char = (unsigned __int8)*++input_string;
      current_char = next_char;
      hash += hash_helper;
    }
    while ( next_char );
  }
  return hash;
}

//----- (0005DF44) --------------------------------------------------------
bool __fastcall are_strings_equal(const char *first_string, const char *second_string)
{
  return strcmp(first_string, second_string) == 0;
}

//----- (0005DF58) --------------------------------------------------------
size_t __fastcall sub_5DF58(char *a1)
{
  time_t v3; // [sp+0h] [bp-38h] BYREF
  struct tm tp; // [sp+4h] [bp-34h] BYREF

  time(&v3);
  localtime_r(&v3, &tp);
  return strftime(a1, 21u, "%m-%d %T", &tp);
}

//----- (0005DF98) --------------------------------------------------------
int sub_5DF98(int log_level, const char *source_file, int source_line, const char *message_format, ...)
{
  FILE *log_stream; // r4
  int log_file_descriptor; // r0
  __pid_t process_id_debug; // r0
  __pid_t process_id_warn; // r0
  __pid_t process_id_error; // r0
  char time_buffer[44]; // [sp+10h] [bp-30h] BYREF
  const char *final_message_format; // [sp+3Ch] [bp-4h]
  va_list varargs; // [sp+40h] [bp+0h] BYREF

  va_start(varargs, message_format);
  final_message_format = message_format;
  if ( dword_58DE44 )
  {
    if ( log_level != 1 )
    {
LABEL_3:
      if ( log_level != 2 )
      {
        if ( log_level )
        {
          log_stream = 0;
LABEL_7:
          vfprintf(log_stream, final_message_format, varargs);
          fputc(10, log_stream);
          fclose(log_stream);
          return 0;
        }
        if ( !dword_58DE48 )
          return 0;
        log_stream = (FILE *)fopen64(dword_58DE48, "a");
        if ( log_stream )
        {
          format_current_time(time_buffer);
          process_id_debug = getpid();
          fprintf(log_stream, "%s DEBUG (%d:%s:%ld) ", time_buffer, process_id_debug, source_file, source_line);
          goto LABEL_7;
        }
        return -1;
      }
      log_file_descriptor = dword_58DE4C;
      if ( dword_58DE4C )
      {
        log_stream = (FILE *)fopen64(dword_58DE4C, "a");
        if ( log_stream )
        {
          format_current_time(time_buffer);
          process_id_error = getpid();
          fprintf(log_stream, "%s ERROR (%d:%s:%ld) ", time_buffer, process_id_error, source_file, source_line);
          goto LABEL_7;
        }
        return -1;
      }
      return log_file_descriptor;
    }
  }
  else
  {
    dword_58DE44 = 1;
    dword_58DE48 = (int)getenv("ZLOG_PROFILE_DEBUG");
    dword_58DE4C = (int)getenv("ZLOG_PROFILE_ERROR");
    if ( log_level != 1 )
      goto LABEL_3;
  }
  log_file_descriptor = dword_58DE4C;
  if ( dword_58DE4C )
  {
    log_stream = (FILE *)fopen64(dword_58DE4C, "a");
    if ( log_stream )
    {
      format_current_time(time_buffer);
      process_id_warn = getpid();
      fprintf(log_stream, "%s WARN  (%d:%s:%ld) ", time_buffer, process_id_warn, source_file, source_line);
      goto LABEL_7;
    }
    return -1;
  }
  return log_file_descriptor;
}
// 124E4: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 58DE44: using guessed type int dword_58DE44;
// 58DE48: using guessed type int dword_58DE48;
// 58DE4C: using guessed type int dword_58DE4C;

//----- (0005E140) --------------------------------------------------------
int __fastcall sub_5E140(const char *a1)
{
  int v2; // r4
  char *v3; // r1
  const unsigned __int16 **v4; // r0
  const char *v5; // r3
  int v6; // t1
  size_t v7; // r6
  int v8; // r4
  char v10; // r3
  int v11; // r6
  int v12; // r3

  if ( a1 )
  {
    v2 = *(unsigned __int8 *)a1;
    if ( *a1 )
    {
      v4 = _ctype_b_loc();
      v3 = (char *)a1;
      v5 = a1;
      do
      {
        if ( ((*v4)[v2] & 0x2000) == 0 )
          *v3++ = v2;
        v6 = *(unsigned __int8 *)++v5;
        v2 = v6;
      }
      while ( v6 );
    }
    else
    {
      v3 = (char *)a1;
    }
    *v3 = 0;
    v7 = strlen(a1);
    v8 = strtol(a1, 0, 10);
    if ( v8 > 0 )
    {
      v10 = a1[v7 - 1];
      if ( (v10 & 0xDF) == 66 )
        v11 = (unsigned __int8)a1[v7 - 2];
      else
        v11 = (unsigned __int8)a1[v7 - 1];
      if ( (v10 & 0xDF) == 66 )
        v12 = 1024;
      else
        v12 = 1000;
      switch ( v11 )
      {
        case 'G':
        case 'g':
          v8 *= v12 * v12 * v12;
          break;
        case 'K':
        case 'k':
          goto LABEL_18;
        case 'M':
        case 'm':
          v12 *= v12;
LABEL_18:
          v8 *= v12;
          break;
        default:
          if ( ((*_ctype_b_loc())[v11] & 0x800) == 0 )
            sub_5DF98(2, "src/zc_util.c", 70, "Wrong suffix parsing size in bytes for string [%s], ignoring suffix", a1);
          break;
      }
      return v8;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    sub_5DF98(2, "src/zc_util.c", 27, "astring is null or 0");
    return 0;
  }
}
// 5E1E8: control flows out of bounds to 5E1EC

//----- (0005E310) --------------------------------------------------------
int __fastcall replace_env_variable_in_string(const char *input_string, int buffer_size)
{
  const char *working_ptr; // r4
  size_t input_len; // r9
  char *env_var_value; // r0
  unsigned int formatted_len; // r0
  size_t env_value_len; // r5
  size_t remaining_len; // r0
  char *percent_ptr; // r6
  int *errno_ptr; // r0
  int bytes_processed; // [sp+8h] [bp-4h] BYREF
  char format_specifier[4100]; // [sp+Ch] [bp+0h] BYREF
  char env_var_name[4100]; // [sp+1010h] [bp+1004h] BYREF
  char env_value_buffer[4104]; // [sp+2014h] [bp+2008h] BYREF

  working_ptr = input_string;
  input_len = strlen(input_string);
  while ( 1 )
  {
    do
    {
      percent_ptr = strchr(working_ptr, 37);
      working_ptr = percent_ptr + 1;
      if ( !percent_ptr )
        return 0;
      memset(format_specifier, 0, 4097u);
      memset(env_var_name, 0, 4097u);
      memset(env_value_buffer, 0, 4097u);
      bytes_processed = 0;
      if ( _isoc99_sscanf(percent_ptr + 1, "%[.0-9-]%n", &format_specifier[1], &bytes_processed) == 1 )
      {
        format_specifier[0] = 37;
        working_ptr = &percent_ptr[bytes_processed + 1];
        format_specifier[bytes_processed + 1] = 115;
      }
      else
      {
        bytes_processed = 0;
        strcpy(format_specifier, "%s");
      }
    }
    while ( !_isoc99_sscanf(working_ptr, "E(%[^)])%n", env_var_name, &bytes_processed) );
    working_ptr += bytes_processed;
    if ( *(working_ptr - 1) != 41 )
    {
      sub_5DF98(2, "src/zc_util.c", 124, "in string[%s] can't find match )", percent_ptr);
      return -1;
    }
    env_var_value = getenv(env_var_name);
    formatted_len = snprintf(env_value_buffer, 4097u, format_specifier, env_var_value);
    env_value_len = formatted_len;
    if ( formatted_len > 4096 )
    {
      errno_ptr = _errno_location();
      sub_5DF98(2, "src/zc_util.c", 131, "snprintf fail, errno[%d], evn_value_len[%d]", *errno_ptr, env_value_len);
      return -1;
    }
    input_len = input_len - (working_ptr - percent_ptr) + formatted_len;
    if ( buffer_size - 1 < input_len )
      break;
    remaining_len = strlen(working_ptr);
    memmove(&percent_ptr[env_value_len], working_ptr, remaining_len + 1);
    memcpy(percent_ptr, env_value_buffer, env_value_len);
  }
  sub_5DF98(2, "src/zc_util.c", 137, "repalce env_value[%s] cause overlap", env_value_buffer);
  return -1;
}
// 1231C: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);

//----- (0005E558) --------------------------------------------------------
int __fastcall resize_buffer(int buffer_structure_pointer, unsigned int additional_size)
{
  size_t new_size_or_real_size; // r5
  unsigned int current_max_size; // r2
  int resize_result; // r8
  int used_buffer_size; // r6
  char *new_buffer_pointer; // r0
  size_t proposed_new_size; // r2
  int *errno_pointer; // r0

  new_size_or_real_size = *(_DWORD *)(buffer_structure_pointer + 20);
  current_max_size = *(_DWORD *)(buffer_structure_pointer + 24);
  if ( new_size_or_real_size )
  {
    if ( new_size_or_real_size <= current_max_size )
    {
      sub_5DF98(
        2,
        "src/buf.c",
        169,
        "a_buf->size_real[%ld] >= a_buf->size_max[%ld]",
        *(_DWORD *)(buffer_structure_pointer + 24),
        new_size_or_real_size);
      return 1;
    }
    proposed_new_size = current_max_size + additional_size;
    if ( new_size_or_real_size < proposed_new_size )
    {
      resize_result = 1;
    }
    else
    {
      new_size_or_real_size = proposed_new_size;
      resize_result = 0;
    }
  }
  else
  {
    resize_result = 0;
    new_size_or_real_size = (unsigned int)((double)current_max_size + (double)additional_size * 1.5);
  }
  used_buffer_size = *(_DWORD *)(buffer_structure_pointer + 4) - *(_DWORD *)buffer_structure_pointer;
  new_buffer_pointer = (char *)realloc(*(void **)buffer_structure_pointer, new_size_or_real_size);
  if ( new_buffer_pointer )
  {
    *(_DWORD *)(buffer_structure_pointer + 4) = &new_buffer_pointer[used_buffer_size];
    *(_DWORD *)buffer_structure_pointer = new_buffer_pointer;
    *(_DWORD *)(buffer_structure_pointer + 12) = &new_buffer_pointer[new_size_or_real_size];
    *(_DWORD *)(buffer_structure_pointer + 8) = &new_buffer_pointer[new_size_or_real_size - 1];
    *(_DWORD *)(buffer_structure_pointer + 24) = new_size_or_real_size;
  }
  else
  {
    errno_pointer = _errno_location();
    sub_5DF98(2, "src/buf.c", 189, "realloc fail, errno[%d]", *errno_pointer);
    resize_result = -1;
    free(*(void **)buffer_structure_pointer);
    *(_DWORD *)buffer_structure_pointer = 0;
    *(_DWORD *)(buffer_structure_pointer + 4) = 0;
    *(_DWORD *)(buffer_structure_pointer + 8) = 0;
    *(_DWORD *)(buffer_structure_pointer + 12) = 0;
  }
  return resize_result;
}

//----- (0005E680) --------------------------------------------------------
void *__fastcall calculate_copy_destination(void **input_params)
{
  _BYTE *end_ptr; // r2
  void **source_ptr; // r1
  void *start_ptr; // r3
  void *destination_ptr; // r0

  end_ptr = input_params[1];
  source_ptr = input_params + 7;
  start_ptr = *input_params;
  destination_ptr = (void *)(end_ptr - (_BYTE *)input_params[264]);
  if ( destination_ptr < start_ptr )
    destination_ptr = start_ptr;
  return memcpy(destination_ptr, source_ptr, end_ptr - (_BYTE *)destination_ptr);
}

//----- (0005E6A4) --------------------------------------------------------
int __fastcall format_buffer_information(const void **buffer_info, int line_number)
{
  return sub_5DF98(
           line_number,
           "src/buf.c",
           74,
           "---buf[%p][%ld-%ld][%ld][%s][%p:%ld]---",
           buffer_info,
           buffer_info[4],
           buffer_info[5],
           buffer_info[6],
           (const char *)buffer_info + 28,
           *buffer_info,
           (_BYTE *)buffer_info[1] - (_BYTE *)*buffer_info);
}

//----- (0005E70C) --------------------------------------------------------
void __fastcall free_buffer(void **buffer_ptr)
{
  void *buffer_data; // r0

  buffer_data = *buffer_ptr;
  if ( buffer_data )
    free(buffer_data);
  sub_5DF98(0, "src/buf.c", 82, "zlog_buf_del[%p]", buffer_ptr);
  free(buffer_ptr);
}

//----- (0005E758) --------------------------------------------------------
void **__fastcall initialize_buffer(size_t initial_size, unsigned int max_size, const char *tag)
{
  bool is_invalid_size; // cc
  void **buffer_struct; // r4
  size_t tag_length; // r0
  size_t tag_size; // r8
  char *allocated_buffer; // r0
  char *buffer_end; // r5
  void **temp_buffer_struct; // r0
  int *errno_pointer1; // r0
  int *errno_pointer2; // r0

  if ( !initial_size )
  {
    buffer_struct = 0;
    sub_5DF98(2, "src/buf.c", 92, "buf_size_min == 0, not allowed");
    return buffer_struct;
  }
  is_invalid_size = max_size != 0;
  if ( max_size )
    is_invalid_size = initial_size > max_size;
  if ( is_invalid_size )
  {
    sub_5DF98(2, "src/buf.c", 98, "buf_size_max[%lu] < buf_size_min[%lu] && buf_size_max != 0", max_size, initial_size);
    return 0;
  }
  buffer_struct = (void **)calloc(1u, 1060u);
  if ( !buffer_struct )
  {
    errno_pointer1 = _errno_location();
    sub_5DF98(2, "src/buf.c", 104, "calloc fail, errno[%d]", *errno_pointer1);
    return buffer_struct;
  }
  if ( tag )
  {
    tag_length = strlen(tag);
    tag_size = tag_length;
    if ( tag_length > 1024 )
    {
      sub_5DF98(2, "src/buf.c", 110, "truncate_str[%s] overflow", tag);
LABEL_14:
      temp_buffer_struct = buffer_struct;
      buffer_struct = 0;
      free_buffer(temp_buffer_struct);
      return buffer_struct;
    }
    memcpy(buffer_struct + 7, tag, tag_length + 1);
    buffer_struct[264] = (void *)tag_size;
  }
  buffer_struct[4] = (void *)initial_size;
  buffer_struct[5] = (void *)max_size;
  buffer_struct[6] = (void *)initial_size;
  allocated_buffer = (char *)calloc(1u, initial_size);
  *buffer_struct = allocated_buffer;
  if ( !allocated_buffer )
  {
    errno_pointer2 = _errno_location();
    sub_5DF98(2, "src/buf.c", 124, "calloc fail, errno[%d]", *errno_pointer2);
    goto LABEL_14;
  }
  buffer_end = &allocated_buffer[initial_size];
  buffer_struct[1] = allocated_buffer;
  buffer_struct[3] = buffer_end;
  buffer_struct[2] = buffer_end - 1;
  return buffer_struct;
}

//----- (0005E8DC) --------------------------------------------------------
int __fastcall format_log_message(int log_buffer, char *format_str, __gnuc_va_list arg_list)
{
  size_t remaining_size; // r4
  int formatted_length; // r6
  _BOOL4 format_success; // r0
  int result_code; // r4
  int result; // r0
  int resize_result; // r0
  int resize_status; // r4
  char *current_buffer_position; // r0
  size_t new_remaining_size; // r6
  int new_formatted_length; // r7
  char *buffer_position_after_resize; // r0
  size_t post_resize_remaining_size; // r1
  size_t final_formatted_length; // r4
  int truncate_indicator; // r2
  int *errno_location_ptr_1; // r0
  int *errno_location_ptr_2; // r0
  size_t logged_remaining_size; // [sp+4h] [bp-2Ch]

  if ( !*(_DWORD *)log_buffer )
  {
    sub_5DF98(2, "src/buf.c", 214, "pre-use of zlog_buf_resize fail, so can't convert");
    return -1;
  }
  remaining_size = *(_DWORD *)(log_buffer + 12) - *(_DWORD *)(log_buffer + 4);
  formatted_length = vsnprintf(*(char **)(log_buffer + 4), remaining_size, format_str, arg_list);
  format_success = formatted_length >= 0;
  if ( formatted_length >= remaining_size )
    format_success = 0;
  if ( format_success )
  {
    result = 0;
    *(_DWORD *)(log_buffer + 4) += formatted_length;
  }
  else
  {
    if ( formatted_length < 0 )
    {
      errno_location_ptr_1 = _errno_location();
      sub_5DF98(2, "src/buf.c", 226, "vsnprintf fail, errno[%d]", *errno_location_ptr_1);
      logged_remaining_size = remaining_size;
      result_code = -1;
      sub_5DF98(
        2,
        "src/buf.c",
        227,
        "nwrite[%d], size_left[%ld], format[%s]",
        formatted_length,
        logged_remaining_size,
        format_str);
      return result_code;
    }
    if ( formatted_length < remaining_size )
      return 0;
    resize_result = resize_buffer(log_buffer, 1 - remaining_size + formatted_length);
    resize_status = resize_result;
    if ( resize_result > 0 )
    {
      sub_5DF98(2, "src/buf.c", 234, "conf limit to %ld, can't extend, so truncate", *(_DWORD *)(log_buffer + 20));
      buffer_position_after_resize = *(char **)(log_buffer + 4);
      post_resize_remaining_size = *(_DWORD *)(log_buffer + 12) - (_DWORD)buffer_position_after_resize;
      final_formatted_length = post_resize_remaining_size - 1;
      vsnprintf(buffer_position_after_resize, post_resize_remaining_size, format_str, arg_list);
      truncate_indicator = *(unsigned __int8 *)(log_buffer + 28);
      *(_DWORD *)(log_buffer + 4) += final_formatted_length;
      result_code = 1;
      if ( truncate_indicator )
        calculate_copy_destination((void **)log_buffer);
      return result_code;
    }
    if ( resize_result )
    {
      sub_5DF98(2, "src/buf.c", 243, "zlog_buf_resize fail");
      return -1;
    }
    current_buffer_position = *(char **)(log_buffer + 4);
    new_remaining_size = *(_DWORD *)(log_buffer + 12) - (_DWORD)current_buffer_position;
    new_formatted_length = vsnprintf(current_buffer_position, new_remaining_size, format_str, arg_list);
    if ( new_formatted_length < 0 )
    {
      errno_location_ptr_2 = _errno_location();
      sub_5DF98(2, "src/buf.c", 252, "vsnprintf fail, errno[%d]", *errno_location_ptr_2);
      result_code = -1;
      sub_5DF98(
        2,
        "src/buf.c",
        253,
        "nwrite[%d], size_left[%ld], format[%s]",
        new_formatted_length,
        new_remaining_size,
        format_str);
      return result_code;
    }
    result = resize_status;
    *(_DWORD *)(log_buffer + 4) += new_formatted_length;
  }
  return result;
}

//----- (0005EB48) --------------------------------------------------------
int __fastcall format_number_to_buffer(int buffer, unsigned int number, char *max_digits)
{
  char *formatted_number_end; // r4
  unsigned int next_digit; // r0
  char current_digit; // r3
  char *formatted_number_size; // r6
  char *digits_to_process; // r7
  void *buffer_ptr; // r0
  char *buffer_end; // r3
  char *new_buffer_ptr; // r9
  char *padding_size; // r8
  int result; // r0
  int v14; // r0
  void *v15; // r0
  unsigned int v16; // r6
  bool v17; // cc
  int v18; // r2
  unsigned int v19; // r6
  char v20[33]; // [sp+17h] [bp-21h] BYREF

  if ( !*(_DWORD *)buffer )
  {
    sub_5DF98(2, "src/buf.c", 276, "pre-use of zlog_buf_resize fail, so can't convert");
    return -1;
  }
  formatted_number_end = v20;
  do
  {
    next_digit = number / 10;
    current_digit = number - 10 * next_digit;
    number = next_digit;
    *--formatted_number_end = current_digit + 48;
  }
  while ( next_digit );
  formatted_number_size = (char *)(v20 - formatted_number_end);
  digits_to_process = max_digits;
  buffer_ptr = *(void **)(buffer + 4);
  buffer_end = *(char **)(buffer + 8);
  if ( (unsigned int)max_digits <= v20 - formatted_number_end )
  {
    new_buffer_ptr = &formatted_number_size[(_DWORD)buffer_ptr];
    padding_size = 0;
    if ( &formatted_number_size[(int)buffer_ptr] <= buffer_end )
    {
LABEL_9:
      memcpy(&padding_size[(_DWORD)buffer_ptr], formatted_number_end, v20 - formatted_number_end);
      result = 0;
      *(_DWORD *)(buffer + 4) = new_buffer_ptr;
      return result;
    }
    digits_to_process = (char *)(v20 - formatted_number_end);
  }
  else
  {
    new_buffer_ptr = &max_digits[(_DWORD)buffer_ptr];
    padding_size = (char *)(max_digits - formatted_number_size);
    if ( &max_digits[(int)buffer_ptr] <= buffer_end )
    {
LABEL_6:
      if ( padding_size )
      {
        memset(buffer_ptr, 48, (size_t)padding_size);
        buffer_ptr = *(void **)(buffer + 4);
      }
      goto LABEL_9;
    }
  }
  v14 = resize_buffer(buffer, (unsigned int)&digits_to_process[-(buffer_end - (_BYTE *)buffer_ptr)]);
  if ( v14 <= 0 )
  {
    if ( v14 )
    {
      sub_5DF98(2, "src/buf.c", 318, "zlog_buf_resize fail");
      return -1;
    }
    buffer_ptr = *(void **)(buffer + 4);
    new_buffer_ptr = &digits_to_process[(_DWORD)buffer_ptr];
    goto LABEL_6;
  }
  sub_5DF98(2, "src/buf.c", 302, "conf limit to %ld, can't extend, so output", *(_DWORD *)(buffer + 20));
  v15 = *(void **)(buffer + 4);
  v16 = *(_DWORD *)(buffer + 8) - (_DWORD)v15;
  v17 = v16 > (unsigned int)padding_size;
  if ( v16 > (unsigned int)padding_size )
    digits_to_process = (char *)(v16 - (_DWORD)padding_size);
  else
    padding_size = (char *)(*(_DWORD *)(buffer + 8) - (_DWORD)v15);
  if ( !v17 )
    digits_to_process = 0;
  if ( padding_size )
  {
    memset(v15, 48, (size_t)padding_size);
    v15 = *(void **)(buffer + 4);
  }
  result = (int)memcpy(&padding_size[(_DWORD)v15], formatted_number_end, (size_t)digits_to_process);
  v18 = *(unsigned __int8 *)(buffer + 28);
  v19 = *(_DWORD *)(buffer + 4) + v16;
  if ( !*(_BYTE *)(buffer + 28) )
    result = 1;
  *(_DWORD *)(buffer + 4) = v19;
  if ( v18 )
  {
    calculate_copy_destination((void **)buffer);
    return 1;
  }
  return result;
}

//----- (0005ED04) --------------------------------------------------------
int __fastcall convert_integer_to_string(
        int buffer_handle,
        int unused,
        int integer_value,
        int use_division,
        char *max_length)
{
  unsigned __int64 integer_copy; // r4
  bool should_divide; // cc
  char *number_start; // r6
  unsigned int remainder; // r3
  char *remaining_space; // r4
  size_t number_length; // r7
  __int64 current_position; // r0
  char *new_position; // r9
  char *fill_length; // r5
  int function_result; // r0
  char last_digit; // r2
  unsigned __int64 divided_value; // r0
  int resize_result; // r0
  void *destination; // r0
  unsigned int available_space; // r4
  bool space_check; // cc
  int has_finished; // r2
  unsigned int updated_position; // r4
  char number_buffer[36]; // [sp+1Ch] [bp-24h] BYREF

  HIDWORD(integer_copy) = use_division;
  if ( !*(_DWORD *)buffer_handle )
  {
    sub_5DF98(2, "src/buf.c", 342, "pre-use of zlog_buf_resize fail, so can't convert");
    return -1;
  }
  LODWORD(integer_copy) = integer_value;
  should_divide = use_division != 0;
  if ( !use_division )
    should_divide = 0;
  if ( should_divide )
  {
    number_start = number_buffer;
    do
    {
      handle_divide_by_zero(integer_copy, 10uLL);
      *--number_start = last_digit + 48;
      LODWORD(divided_value) = handle_divide_by_zero(integer_copy, 10uLL);
      integer_copy = divided_value;
    }
    while ( divided_value );
  }
  else
  {
    number_start = number_buffer;
    do
    {
      remainder = (unsigned int)integer_copy % 10;
      LODWORD(integer_copy) = (unsigned int)integer_copy / 10;
      *--number_start = remainder + 48;
    }
    while ( (_DWORD)integer_copy );
  }
  remaining_space = max_length;
  number_length = number_buffer - number_start;
  current_position = *(_QWORD *)(buffer_handle + 4);
  if ( (unsigned int)max_length <= number_buffer - number_start )
  {
    new_position = (char *)(current_position + number_length);
    if ( (unsigned int)current_position + number_length <= HIDWORD(current_position) )
    {
      fill_length = 0;
LABEL_11:
      memcpy(&fill_length[current_position], number_start, number_length);
      function_result = 0;
      *(_DWORD *)(buffer_handle + 4) = new_position;
      return function_result;
    }
    remaining_space = (char *)(number_buffer - number_start);
    fill_length = 0;
  }
  else
  {
    new_position = &max_length[current_position];
    fill_length = &max_length[-number_length];
    if ( (unsigned int)&max_length[current_position] <= HIDWORD(current_position) )
    {
LABEL_9:
      if ( fill_length )
      {
        memset((void *)current_position, 48, (size_t)fill_length);
        LODWORD(current_position) = *(_DWORD *)(buffer_handle + 4);
      }
      goto LABEL_11;
    }
  }
  resize_result = resize_buffer(
                    buffer_handle,
                    (unsigned int)&remaining_space[-(HIDWORD(current_position) - current_position)]);
  if ( resize_result <= 0 )
  {
    if ( resize_result )
    {
      sub_5DF98(2, "src/buf.c", 409, "zlog_buf_resize fail");
      return -1;
    }
    LODWORD(current_position) = *(_DWORD *)(buffer_handle + 4);
    new_position = &remaining_space[current_position];
    goto LABEL_9;
  }
  sub_5DF98(2, "src/buf.c", 393, "conf limit to %ld, can't extend, so output", *(_DWORD *)(buffer_handle + 20));
  destination = *(void **)(buffer_handle + 4);
  available_space = *(_DWORD *)(buffer_handle + 8) - (_DWORD)destination;
  space_check = available_space > (unsigned int)fill_length;
  if ( available_space > (unsigned int)fill_length )
    number_length = available_space - (_DWORD)fill_length;
  else
    fill_length = (char *)(*(_DWORD *)(buffer_handle + 8) - (_DWORD)destination);
  if ( !space_check )
    number_length = 0;
  if ( fill_length )
  {
    memset(destination, 48, (size_t)fill_length);
    destination = *(void **)(buffer_handle + 4);
  }
  function_result = (int)memcpy(&fill_length[(_DWORD)destination], number_start, number_length);
  has_finished = *(unsigned __int8 *)(buffer_handle + 28);
  updated_position = *(_DWORD *)(buffer_handle + 4) + available_space;
  if ( !*(_BYTE *)(buffer_handle + 28) )
    function_result = 1;
  *(_DWORD *)(buffer_handle + 4) = updated_position;
  if ( has_finished )
  {
    calculate_copy_destination((void **)buffer_handle);
    return 1;
  }
  return function_result;
}
// 5EDDC: variable 'last_digit' is possibly undefined
// 5EDF8: variable 'divided_value' is possibly undefined

//----- (0005EF24) --------------------------------------------------------
int __fastcall append_formatted_hex_value_to_buffer(int buffer_handle, unsigned int hex_value, char *allocated_space)
{
  char *hex_str_end; // r5
  unsigned int nibble_value; // r3
  size_t hex_str_length; // r6
  char *space_needed; // r8
  void *buffer_start_ptr; // r0
  char *buffer_current_ptr; // r3
  char *new_buffer_end_ptr; // r9
  char *padding_len_ptr; // r4
  int return_code; // r0
  int resize_result; // r0
  void *adjusted_buffer_start_ptr; // r0
  unsigned int current_data_len; // r6
  bool is_padding_needed; // cc
  int buffer_autoflush_flag; // r2
  unsigned int new_buffer_current_len; // r6
  char formatted_hex_str[33]; // [sp+17h] [bp-21h] BYREF

  if ( !*(_DWORD *)buffer_handle )
  {
    sub_5DF98(2, "src/buf.c", 434, "pre-use of zlog_buf_resize fail, so can't convert");
    return -1;
  }
  hex_str_end = formatted_hex_str;
  do
  {
    nibble_value = hex_value & 0xF;
    hex_value >>= 4;
    *--hex_str_end = a0123456789abcd[nibble_value];
  }
  while ( hex_value );
  hex_str_length = formatted_hex_str - hex_str_end;
  space_needed = allocated_space;
  buffer_start_ptr = *(void **)(buffer_handle + 4);
  buffer_current_ptr = *(char **)(buffer_handle + 8);
  if ( (unsigned int)allocated_space <= formatted_hex_str - hex_str_end )
  {
    new_buffer_end_ptr = (char *)buffer_start_ptr + hex_str_length;
    padding_len_ptr = 0;
    if ( buffer_current_ptr >= (char *)buffer_start_ptr + hex_str_length )
    {
LABEL_9:
      memcpy(&padding_len_ptr[(_DWORD)buffer_start_ptr], hex_str_end, hex_str_length);
      return_code = 0;
      *(_DWORD *)(buffer_handle + 4) = new_buffer_end_ptr;
      return return_code;
    }
    space_needed = (char *)(formatted_hex_str - hex_str_end);
  }
  else
  {
    new_buffer_end_ptr = &allocated_space[(_DWORD)buffer_start_ptr];
    padding_len_ptr = &allocated_space[-hex_str_length];
    if ( &allocated_space[(int)buffer_start_ptr] <= buffer_current_ptr )
    {
LABEL_6:
      if ( padding_len_ptr )
      {
        memset(buffer_start_ptr, 48, (size_t)padding_len_ptr);
        buffer_start_ptr = *(void **)(buffer_handle + 4);
      }
      goto LABEL_9;
    }
  }
  resize_result = resize_buffer(
                    buffer_handle,
                    (unsigned int)&space_needed[-(buffer_current_ptr - (_BYTE *)buffer_start_ptr)]);
  if ( resize_result <= 0 )
  {
    if ( resize_result )
    {
      sub_5DF98(2, "src/buf.c", 489, "zlog_buf_resize fail");
      return -1;
    }
    buffer_start_ptr = *(void **)(buffer_handle + 4);
    new_buffer_end_ptr = &space_needed[(_DWORD)buffer_start_ptr];
    goto LABEL_6;
  }
  sub_5DF98(2, "src/buf.c", 473, "conf limit to %ld, can't extend, so output", *(_DWORD *)(buffer_handle + 20));
  adjusted_buffer_start_ptr = *(void **)(buffer_handle + 4);
  current_data_len = *(_DWORD *)(buffer_handle + 8) - (_DWORD)adjusted_buffer_start_ptr;
  is_padding_needed = current_data_len > (unsigned int)padding_len_ptr;
  if ( current_data_len > (unsigned int)padding_len_ptr )
    space_needed = (char *)(current_data_len - (_DWORD)padding_len_ptr);
  else
    padding_len_ptr = (char *)(*(_DWORD *)(buffer_handle + 8) - (_DWORD)adjusted_buffer_start_ptr);
  if ( !is_padding_needed )
    space_needed = 0;
  if ( padding_len_ptr )
  {
    memset(adjusted_buffer_start_ptr, 48, (size_t)padding_len_ptr);
    adjusted_buffer_start_ptr = *(void **)(buffer_handle + 4);
  }
  return_code = (int)memcpy(&padding_len_ptr[(_DWORD)adjusted_buffer_start_ptr], hex_str_end, (size_t)space_needed);
  buffer_autoflush_flag = *(unsigned __int8 *)(buffer_handle + 28);
  new_buffer_current_len = *(_DWORD *)(buffer_handle + 4) + current_data_len;
  if ( !*(_BYTE *)(buffer_handle + 28) )
    return_code = 1;
  *(_DWORD *)(buffer_handle + 4) = new_buffer_current_len;
  if ( buffer_autoflush_flag )
  {
    calculate_copy_destination((void **)buffer_handle);
    return 1;
  }
  return return_code;
}

//----- (0005F0D4) --------------------------------------------------------
int __fastcall copy_to_buffer_with_resize(int buffer_info, void *source_data, size_t data_size)
{
  void *current_buffer_position; // r3
  size_t buffer_end; // r1
  size_t new_buffer_position; // r6
  int resize_result; // r0
  void *buffer_position_after_resize; // r0
  size_t remaining_buffer_space; // r5
  int should_calculate_destination; // r2
  size_t updated_buffer_position; // r5
  int copy_result; // r0

  current_buffer_position = *(void **)(buffer_info + 4);
  buffer_end = *(_DWORD *)(buffer_info + 8);
  new_buffer_position = (size_t)current_buffer_position + data_size;
  if ( buffer_end >= (unsigned int)current_buffer_position + data_size )
  {
LABEL_6:
    memcpy(current_buffer_position, source_data, data_size);
    copy_result = 0;
    *(_DWORD *)(buffer_info + 4) = new_buffer_position;
    return copy_result;
  }
  resize_result = resize_buffer(buffer_info, data_size - (buffer_end - (_DWORD)current_buffer_position));
  if ( resize_result <= 0 )
  {
    if ( resize_result )
    {
      sub_5DF98(2, "src/buf.c", 533, "zlog_buf_resize fail");
      return -1;
    }
    current_buffer_position = *(void **)(buffer_info + 4);
    new_buffer_position = (size_t)current_buffer_position + data_size;
    goto LABEL_6;
  }
  sub_5DF98(2, "src/buf.c", 525, "conf limit to %ld, can't extend, so output", *(_DWORD *)(buffer_info + 20));
  buffer_position_after_resize = *(void **)(buffer_info + 4);
  remaining_buffer_space = *(_DWORD *)(buffer_info + 8) - (_DWORD)buffer_position_after_resize;
  copy_result = (int)memcpy(buffer_position_after_resize, source_data, remaining_buffer_space);
  should_calculate_destination = *(unsigned __int8 *)(buffer_info + 28);
  updated_buffer_position = *(_DWORD *)(buffer_info + 4) + remaining_buffer_space;
  if ( !*(_BYTE *)(buffer_info + 28) )
    copy_result = 1;
  *(_DWORD *)(buffer_info + 4) = updated_buffer_position;
  if ( should_calculate_destination )
  {
    calculate_copy_destination((void **)buffer_info);
    return 1;
  }
  return copy_result;
}

//----- (0005F1CC) --------------------------------------------------------
int __fastcall append_and_resize_buffer(
        int buffer_info_ptr,
        void *source_data,
        size_t source_size,
        size_t copy_from_start,
        int use_zero_padding,
        int min_buffer_size,
        int desired_buffer_size)
{
  size_t remaining_space; // r9
  unsigned int new_buffer_size; // r6
  unsigned int copy_size; // r4
  _BOOL4 need_resize_condition; // r3
  __int64 buffer_pointers; // r0
  bool resize_condition; // cf
  unsigned int current_buffer_length; // r1
  int resize_result; // r0
  int resize_status; // r0
  char *destination_ptr; // r0
  unsigned int current_space_left; // r6
  int copy_trigger; // r2
  unsigned int updated_buffer_position; // r6
  int padding_char; // r1

  new_buffer_size = min_buffer_size;
  copy_size = desired_buffer_size;
  if ( !*(_DWORD *)buffer_info_ptr )
  {
    sub_5DF98(2, "src/buf.c", 562, "pre-use of zlog_buf_resize fail, so can't convert");
    return -1;
  }
  need_resize_condition = desired_buffer_size > source_size;
  if ( !desired_buffer_size )
    need_resize_condition = 1;
  buffer_pointers = *(_QWORD *)(buffer_info_ptr + 4);
  if ( need_resize_condition )
    copy_size = source_size;
  resize_condition = 1;
  if ( min_buffer_size )
    resize_condition = copy_size >= min_buffer_size;
  current_buffer_length = HIDWORD(buffer_pointers) - buffer_pointers;
  if ( resize_condition )
    new_buffer_size = copy_size;
  else
    remaining_space = min_buffer_size - copy_size;
  if ( resize_condition )
    remaining_space = 0;
  if ( current_buffer_length >= new_buffer_size )
    goto LABEL_14;
  resize_status = resize_buffer(buffer_info_ptr, new_buffer_size - current_buffer_length);
  if ( resize_status <= 0 )
  {
    if ( resize_status )
    {
      sub_5DF98(2, "src/buf.c", 624, "zlog_buf_resize fail");
      return -1;
    }
    LODWORD(buffer_pointers) = *(_DWORD *)(buffer_info_ptr + 4);
LABEL_14:
    if ( copy_from_start )
    {
      if ( remaining_space )
      {
        memset((void *)(buffer_pointers + copy_size), 32, remaining_space);
        LODWORD(buffer_pointers) = *(_DWORD *)(buffer_info_ptr + 4);
      }
      memcpy((void *)buffer_pointers, source_data, copy_size);
    }
    else
    {
      if ( remaining_space )
      {
        if ( use_zero_padding )
          HIDWORD(buffer_pointers) = 48;
        else
          HIDWORD(buffer_pointers) = 32;
        memset((void *)buffer_pointers, SHIDWORD(buffer_pointers), remaining_space);
        LODWORD(buffer_pointers) = *(_DWORD *)(buffer_info_ptr + 4);
      }
      memcpy((void *)(buffer_pointers + remaining_space), source_data, copy_size);
    }
    resize_result = 0;
    *(_DWORD *)(buffer_info_ptr + 4) += new_buffer_size;
    return resize_result;
  }
  sub_5DF98(2, "src/buf.c", 592, "conf limit to %ld, can't extend, so output", *(_DWORD *)(buffer_info_ptr + 20));
  destination_ptr = *(char **)(buffer_info_ptr + 4);
  current_space_left = *(_DWORD *)(buffer_info_ptr + 8) - (_DWORD)destination_ptr;
  if ( copy_from_start )
  {
    if ( copy_size < current_space_left )
    {
      memset(&destination_ptr[copy_size], 32, current_space_left - copy_size);
      destination_ptr = *(char **)(buffer_info_ptr + 4);
    }
    else
    {
      copy_size = *(_DWORD *)(buffer_info_ptr + 8) - (_DWORD)destination_ptr;
    }
    resize_result = (int)memcpy(destination_ptr, source_data, copy_size);
  }
  else
  {
    if ( remaining_space < current_space_left )
      copy_from_start = current_space_left - remaining_space;
    else
      remaining_space = *(_DWORD *)(buffer_info_ptr + 8) - (_DWORD)destination_ptr;
    if ( remaining_space )
    {
      if ( use_zero_padding )
        padding_char = 48;
      else
        padding_char = 32;
      memset(destination_ptr, padding_char, remaining_space);
      destination_ptr = *(char **)(buffer_info_ptr + 4);
    }
    resize_result = (int)memcpy(&destination_ptr[remaining_space], source_data, copy_from_start);
  }
  copy_trigger = *(unsigned __int8 *)(buffer_info_ptr + 28);
  updated_buffer_position = *(_DWORD *)(buffer_info_ptr + 4) + current_space_left;
  if ( !*(_BYTE *)(buffer_info_ptr + 28) )
    resize_result = 1;
  *(_DWORD *)(buffer_info_ptr + 4) = updated_buffer_position;
  if ( copy_trigger )
  {
    calculate_copy_destination((void **)buffer_info_ptr);
    return 1;
  }
  return resize_result;
}
// 5F240: variable 'remaining_space' is possibly undefined

//----- (0005F3F8) --------------------------------------------------------
int __fastcall log_level_info(const char *level_data, int log_level)
{
  if ( level_data )
    return sub_5DF98(
             log_level,
             "src/level.c",
             26,
             "---level[%p][%d,%s,%s,%d,%d]---",
             level_data,
             *(_DWORD *)level_data,
             level_data + 4,
             level_data + 1029,
             *((_DWORD *)level_data + 514),
             *((_DWORD *)level_data + 515));
  else
    return sub_5DF98(2, "src/level.c", 19, "a_level is null or 0");
}

//----- (0005F474) --------------------------------------------------------
void __fastcall delete_log_level(void *level_ptr)
{
  if ( level_ptr )
  {
    sub_5DF98(0, "src/level.c", 34, "zlog_level_del[%p]", level_ptr);
    free(level_ptr);
  }
  else
  {
    sub_5DF98(2, "src/level.c", 33, "a_level is null or 0");
  }
}

//----- (0005F4D8) --------------------------------------------------------
_DWORD *__fastcall sub_5F4D8(const char *a1)
{
  _DWORD *v2; // r5
  __int16 v3; // r4
  _DWORD *v4; // r0
  bool v5; // zf
  const __int32_t *v6; // r7
  const __int32_t *v7; // lr
  _DWORD *v8; // r3
  char *v9; // r1
  char *v10; // r0
  int v11; // r2
  int v12; // t1
  char *v13; // r3
  void *v15; // r0
  int *v16; // r0
  char v17[4]; // [sp+Ch] [bp-2024h] BYREF
  char s[4100]; // [sp+10h] [bp-2020h] BYREF
  char v19[4124]; // [sp+1014h] [bp-101Ch] BYREF

  v2 = 0;
  *(_DWORD *)v17 = 0;
  if ( !a1 )
  {
    v2 = 0;
    sub_5DF98(2, "src/level.c", 77, "line is null or 0");
    return v2;
  }
  memset(s, 0, 4097u);
  memset(v19, 0, 4097u);
  if ( _isoc99_sscanf(a1, " %[^= \t] = %d ,%s", s, v17, v19) <= 1 )
  {
    sub_5DF98(2, "src/level.c", 84, "level[%s], syntax wrong", a1);
    return v2;
  }
  if ( *(_DWORD *)v17 > 255u )
  {
    sub_5DF98(2, "src/level.c", 90, "l[%d] not in [0,255], wrong", *(_DWORD *)v17);
    return v2;
  }
  v3 = (unsigned __int8)s[0];
  if ( !s[0] )
  {
    v2 = 0;
    sub_5DF98(2, "src/level.c", 95, "str[0] = 0");
    return v2;
  }
  v4 = calloc(1u, 2064u);
  v2 = v4;
  if ( !v4 )
  {
    v16 = _errno_location();
    sub_5DF98(2, "src/level.c", 101, "calloc fail, errno[%d]", *v16);
    return v2;
  }
  v5 = v19[0] == 0;
  *v4 = *(_DWORD *)v17;
  if ( v5 )
    goto LABEL_8;
  if ( !strcasecmp(v19, "LOG_EMERG") )
  {
    v2[515] = 0;
    goto LABEL_9;
  }
  if ( !strcasecmp(v19, "LOG_ALERT") )
  {
    v2[515] = 1;
    goto LABEL_9;
  }
  if ( !strcasecmp(v19, "LOG_CRIT") )
  {
    v2[515] = 2;
    goto LABEL_9;
  }
  if ( !strcasecmp(v19, "LOG_ERR") )
  {
    v2[515] = 3;
    goto LABEL_9;
  }
  if ( !strcasecmp(v19, "LOG_WARNING") )
  {
    v2[515] = 4;
    goto LABEL_9;
  }
  if ( !strcasecmp(v19, "LOG_NOTICE") )
  {
    v2[515] = 5;
    goto LABEL_9;
  }
  if ( !strcasecmp(v19, "LOG_INFO") )
  {
    v2[515] = 6;
LABEL_9:
    v6 = *_ctype_toupper_loc();
    v7 = *_ctype_tolower_loc();
    v8 = v2 + 257;
    v9 = (char *)v2 + 3;
    v10 = s;
    v11 = 0;
    while ( 1 )
    {
      ++v11;
      *++v9 = v6[v3];
      *((_BYTE *)v8 + 1) = v7[v3];
      v8 = (_DWORD *)((char *)v8 + 1);
      if ( v11 == 1024 )
        break;
      v12 = (unsigned __int8)*++v10;
      v3 = v12;
      if ( !v12 )
        goto LABEL_12;
    }
    if ( !s[1024] )
    {
LABEL_12:
      v13 = (char *)v2 + v11;
      v13[4] = 0;
      v13[1029] = 0;
      v2[514] = v11;
      return v2;
    }
    sub_5DF98(2, "src/level.c", 126, "not enough space for str, str[%s] > %d", s, 1024);
    goto LABEL_26;
  }
  if ( !strcasecmp(v19, "LOG_DEBUG") )
  {
LABEL_8:
    v2[515] = 7;
    goto LABEL_9;
  }
  sub_5DF98(2, "src/level.c", 63, "wrong syslog level[%s]", v19);
  v2[515] = -187;
  sub_5DF98(2, "src/level.c", 113, "syslog_level_atoi fail");
LABEL_26:
  sub_5DF98(2, "src/level.c", 138, "line[%s]", a1);
  v15 = v2;
  v2 = 0;
  delete_log_level(v15);
  return v2;
}
// 1231C: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);

//----- (0005F880) --------------------------------------------------------
unsigned int __fastcall calculate_bit_difficulty(unsigned int current_difficulty, unsigned int target_difficulty)
{
  if ( target_difficulty != 1 )
  {
    if ( !target_difficulty )
      JUMPOUT(393552);
    if ( current_difficulty <= target_difficulty )
    {
      return current_difficulty == target_difficulty;
    }
    else if ( (target_difficulty & (target_difficulty - 1)) != 0 )
    {
      return ((int (*)(void))((char *)&loc_5F8B8 + 16 * (31 - (__clz(target_difficulty) - __clz(current_difficulty)))))();
    }
    else
    {
      current_difficulty >>= 31 - __clz(target_difficulty);
    }
  }
  return current_difficulty;
}
// 5FAD8: control flows out of bounds to 60150

//----- (0005FADC) --------------------------------------------------------
unsigned int __fastcall calculate_difficulty_ratio(unsigned int hash_count, unsigned int difficulty_target)
{
  if ( !difficulty_target )
    JUMPOUT(391890);
  return calculate_bit_difficulty(hash_count, difficulty_target);
}
// 5FADE: control flows out of bounds to 5FAD2

//----- (0005FAF8) --------------------------------------------------------
int __fastcall call_external_function_with_check(int first_argument, unsigned int second_argument)
{
  if ( !second_argument )
    JUMPOUT(393552);
  return calculate_remainder(first_argument, second_argument);
}
// 5FD88: control flows out of bounds to 60150

//----- (0005FAFE) --------------------------------------------------------
int __fastcall calculate_remainder(int dividend, unsigned int divisor)
{
  char negative_flag; // nf
  signed int xor_result; // r12
  unsigned int abs_dividend; // r3

  xor_result = dividend ^ divisor;
  if ( negative_flag )
    divisor = -divisor;
  if ( divisor == 1 )
  {
    if ( (xor_result ^ dividend) < 0 )
      return -dividend;
  }
  else
  {
    abs_dividend = dividend;
    if ( dividend < 0 )
      abs_dividend = -dividend;
    if ( abs_dividend <= divisor )
    {
      if ( abs_dividend < divisor )
        dividend = 0;
      if ( abs_dividend == divisor )
        return (xor_result >> 31) | 1;
    }
    else if ( (divisor & (divisor - 1)) != 0 )
    {
      return ((int (__fastcall *)(_DWORD))((char *)&loc_5FB40 + 16 * (31 - (__clz(divisor) - __clz(abs_dividend)))))(0);
    }
    else
    {
      dividend = abs_dividend >> (31 - __clz(divisor));
      if ( xor_result < 0 )
        return -dividend;
    }
  }
  return dividend;
}
// 5FB02: variable 'negative_flag' is possibly undefined

//----- (0005FD8C) --------------------------------------------------------
int __fastcall calculate_modulo(int dividend, unsigned int divisor)
{
  if ( !divisor )
    JUMPOUT(393552);
  return calculate_remainder(dividend, divisor);
}
// 5FD88: control flows out of bounds to 60150

//----- (000600B4) --------------------------------------------------------
int __fastcall sub_600B4(__int64 a1)
{
  bool v1; // cf
  int v2; // off
  int v3; // r4
  bool v4; // zf
  unsigned int v5; // r3
  int v6; // r3
  bool v7; // cc
  int v8; // r2
  unsigned int v9; // r12
  int v10; // r4
  int v11; // r4
  char v12; // r4
  int v13; // r4
  unsigned int v14; // r12
  int v15; // r2
  int v16; // r2

  if ( !a1 )
    return a1;
  v13 = 1074;
  v14 = HIDWORD(a1) >> 22;
  if ( HIDWORD(a1) >> 22 )
  {
    v15 = 3;
    if ( HIDWORD(a1) >> 25 )
      v15 = 6;
    if ( HIDWORD(a1) >> 28 )
      v15 += 3;
    v16 = v15 + (HIDWORD(a1) >> 31);
    v14 = (_DWORD)a1 << (32 - v16);
    LODWORD(a1) = ((unsigned int)a1 >> v16) | (HIDWORD(a1) << (32 - v16));
    HIDWORD(a1) >>= v16;
    v13 = v16 + 1074;
  }
  if ( HIDWORD(a1) >= 1048576 )
  {
    if ( HIDWORD(a1) >= 2097152 )
    {
      v1 = a1 & 1;
      LODWORD(a1) = a1 >> 1;
      v14 = (v14 >> 1) | (v1 << 31);
      if ( (unsigned int)((v13 + 1) << 21) >= 4290772992 )
      {
        LODWORD(a1) = 0;
        return a1;
      }
    }
    goto LABEL_11;
  }
  v1 = __CFSHL__(v14, 1);
  v14 *= 2;
  v2 = v1 + (_DWORD)a1;
  v1 = __CFADD__(v1, (_DWORD)a1) | __CFADD__((_DWORD)a1, v2);
  LODWORD(a1) = a1 + v2;
  HIDWORD(a1) += v1 + HIDWORD(a1);
  v3 = v13 - 1;
  if ( (a1 & 0x10000000000000LL) != 0 )
  {
LABEL_11:
    v1 = v14 >= 2147483648;
    if ( v14 == -2147483648 )
      v1 = a1 & 1;
    LODWORD(a1) = v1 + (_DWORD)a1;
    return a1;
  }
  v4 = HIDWORD(a1) == 0;
  if ( !HIDWORD(a1) )
  {
    HIDWORD(a1) = a1;
    LODWORD(a1) = 0;
  }
  v5 = __clz(HIDWORD(a1));
  if ( v4 )
    v5 += 32;
  v6 = v5 - 11;
  v8 = v6 - 32;
  v7 = v6 <= 32;
  if ( v6 >= 32 )
    goto LABEL_23;
  v7 = v8 <= -12;
  if ( v8 <= -12 )
  {
    LOBYTE(v8) = v6;
LABEL_23:
    if ( v7 )
      LOBYTE(v14) = 32 - v8;
    HIDWORD(a1) <<= v8;
    v9 = (unsigned int)a1 >> v14;
    if ( v7 )
    {
      HIDWORD(a1) |= v9;
      LODWORD(a1) = (_DWORD)a1 << v8;
    }
    goto LABEL_27;
  }
  LODWORD(a1) = HIDWORD(a1) << v6;
  HIDWORD(a1) >>= 32 - v6;
LABEL_27:
  v7 = v3 < v6;
  v10 = v3 - v6;
  if ( v7 )
  {
    v11 = ~v10;
    v7 = v11 < 31;
    v12 = v11 - 31;
    if ( v7 )
      LODWORD(a1) = ((unsigned int)a1 >> (v12 + 32)) | (HIDWORD(a1) << -v12);
    else
      LODWORD(a1) = HIDWORD(a1) >> v12;
  }
  return a1;
}

//----- (00060120) --------------------------------------------------------
int __fastcall handle_divide_by_zero(unsigned __int64 dividend, unsigned __int64 divisor)
{
  unsigned __int64 division_result; // [sp+8h] [bp-8h] BYREF

  if ( divisor )
    return calculate_division_remainder(dividend, divisor, &division_result);
  if ( dividend )
    HIDWORD(dividend) = -1;
  LODWORD(division_result) = HIDWORD(dividend);
  return raise(8);
}

//----- (0006015C) --------------------------------------------------------
unsigned int __fastcall calculate_temperature(double temperature_raw)
{
  if ( temperature_raw >= 0.0 )
    return calculate_normalized_hashrate(temperature_raw);
  HIDWORD(temperature_raw) ^= 2147483648;
  return -calculate_normalized_hashrate(temperature_raw);
}

//----- (00060180) --------------------------------------------------------
unsigned int __fastcall calculate_normalized_hashrate(double input_hashrate)
{
  return (unsigned int)(input_hashrate - (double)(unsigned int)(input_hashrate * 2.32830644e-10) * 4294967300.0);
}

//----- (000601C0) --------------------------------------------------------
int __fastcall calculate_division_remainder(
        unsigned __int64 dividend,
        unsigned __int64 divisor,
        unsigned __int64 *remainder)
{
  bool is_dividend_smaller; // cf
  unsigned __int64 temp_dividend; // r4
  unsigned int leading_zeros_divisor; // r12
  unsigned int leading_zeros_dividend; // r1
  unsigned int shift_amount; // r12
  char shift_amount_bits_high; // r8
  char shift_amount_bits_low; // r9
  unsigned __int64 temp_shifted_divisor; // r6
  unsigned __int64 half_shifted_divisor; // r6
  unsigned int counter; // r2
  int carry_out; // off

  is_dividend_smaller = dividend >= divisor;
  LODWORD(temp_dividend) = dividend;
  if ( dividend < divisor )
    LODWORD(dividend) = 0;
  HIDWORD(temp_dividend) = HIDWORD(dividend);
  if ( !is_dividend_smaller )
    goto LABEL_16;
  leading_zeros_divisor = __clz(HIDWORD(divisor));
  if ( HIDWORD(divisor) )
  {
    leading_zeros_dividend = __clz(HIDWORD(dividend));
    if ( HIDWORD(temp_dividend) )
      goto LABEL_7;
    goto LABEL_19;
  }
  leading_zeros_dividend = __clz(HIDWORD(dividend));
  leading_zeros_divisor = __clz(divisor) + 32;
  if ( !HIDWORD(temp_dividend) )
LABEL_19:
    leading_zeros_dividend = __clz(temp_dividend) + 32;
LABEL_7:
  shift_amount = leading_zeros_divisor - leading_zeros_dividend;
  shift_amount_bits_high = shift_amount - 32;
  shift_amount_bits_low = 32 - shift_amount;
  temp_shifted_divisor = divisor << shift_amount;
  if ( temp_dividend >= divisor << shift_amount )
  {
    LODWORD(dividend) = 1 << shift_amount;
    temp_dividend -= temp_shifted_divisor;
    HIDWORD(dividend) = (1 << shift_amount_bits_high) | (1u >> shift_amount_bits_low);
  }
  else
  {
    dividend = 0LL;
  }
  if ( shift_amount )
  {
    half_shifted_divisor = temp_shifted_divisor >> 1;
    counter = shift_amount;
    do
    {
      while ( temp_dividend >= half_shifted_divisor )
      {
        temp_dividend = 2 * (temp_dividend - half_shifted_divisor) + 1;
        if ( !--counter )
          goto LABEL_15;
      }
      carry_out = (temp_dividend + (unsigned int)temp_dividend) >> 32;
      LODWORD(temp_dividend) = 2 * temp_dividend;
      HIDWORD(temp_dividend) += carry_out;
      --counter;
    }
    while ( counter );
LABEL_15:
    is_dividend_smaller = __CFADD__((_DWORD)dividend, (_DWORD)temp_dividend);
    LODWORD(dividend) = dividend + temp_dividend;
    LODWORD(temp_dividend) = ((unsigned int)temp_dividend >> shift_amount) | (HIDWORD(temp_dividend) << shift_amount_bits_low) | (HIDWORD(temp_dividend) >> shift_amount_bits_high);
    HIDWORD(dividend) += is_dividend_smaller + HIDWORD(temp_dividend);
    HIDWORD(temp_dividend) >>= shift_amount;
    dividend -= temp_dividend << shift_amount;
  }
LABEL_16:
  if ( remainder )
    *remainder = temp_dividend;
  return dividend;
}

//----- (000602D8) --------------------------------------------------------
int __fastcall init(int a1, int a2, int a3)
{
  void **v6; // r5
  int i; // r4
  int (__fastcall *v8)(int, int, int); // t1
  int result; // r0

  init_proc();
  v6 = &off_7DF00;
  for ( i = 0; i != 1; ++i )
  {
    v8 = (int (__fastcall *)(int, int, int))*v6++;
    result = v8(a1, a2, a3);
  }
  return result;
}
// 7DF00: using guessed type void *off_7DF00;

//----- (00060318) --------------------------------------------------------
int __fastcall register_cleanup_function(void (__fastcall *cleanup_function)(void *))
{
  int *atexit_function_list_head; // r2

  atexit_function_list_head = &dword_7E294;
  if ( &dword_7E294 )
    atexit_function_list_head = (int *)dword_7E294;
  return j___cxa_atexit(cleanup_function, 0, atexit_function_list_head);
}
// 7E294: using guessed type int dword_7E294;

//----- (00060334) --------------------------------------------------------
void term_proc()
{
  ;
}

// nfuncs=1627 queued=1278 decompiled=1278 lumina nreq=0 worse=0 better=0
// ALL OK, 1278 function(s) have been successfully decompiled
