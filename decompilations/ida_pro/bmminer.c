/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_186A0; // weak
_UNKNOWN loc_1FFFC; // weak
_UNKNOWN loc_20000; // weak
_UNKNOWN loc_30D40; // weak
_UNKNOWN loc_5F8B8; // weak
_UNKNOWN loc_5FB40; // weak
_UNKNOWN loc_600C4; // weak
char aReadSensorOnAs[20] = "read_sensor_on_asic"; // weak
int dword_60DE4 = 8224; // weak
unsigned int dword_62768[16] = { 128u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u }; // weak
char aTqFreezethaw[14] = "tq_freezethaw"; // weak
char *off_654CC = "http:"; // weak
char *off_666C0[18] =
{
  "STATUS_INIT",
  "STATUS_INITED",
  "STATUS_OKAY",
  "WARN_NET_LOST",
  "ERROR_SOC_INIT",
  "ERROR_REOPEN_CORE",
  "ERROR_NET_LOST",
  "ERROR_FAN_LOST",
  "ERROR_PIC_LOST",
  "ERROR_POWER_LOST",
  "ERROR_ASIC_NUM",
  "ERROR_UNBALANCE",
  "ERROR_EEPROM_INFO",
  "ERROR_TEMP_LOST_1ST",
  "ERROR_TEMP_LOST",
  "ERROR_TEMP_TOO_HIGH",
  "ERROR_TEMP_TOO_LOW",
  "ERROR_UNKOWN_STATUS"
}; // weak
void *off_68A48 = &unk_203D7C; // weak
_DWORD dword_695A8[4] = { 0, 0, 0, 0 }; // weak
_UNKNOWN unk_696A8; // weak
_UNKNOWN unk_696E4; // weak
const char aSSet1704FlashP_0[] = "%s: set 1704 flash pointer err!\n"; // idb
__int16 word_6A02C = 10; // weak
char aDh[5] = "\b`dh"; // weak
const char asc_6BB30[] = "[ %[^] \t"; // idb
__int16 word_6BB38 = 93; // weak
_UNKNOWN unk_6D1F4; // weak
char a0123456789abcd[17] = "0123456789abcdef"; // weak
void *off_7DF00 = (void *)0x13CDD; // weak
int dword_7E294 = 0; // weak
int dword_7E298 = 2; // weak
_UNKNOWN unk_7E29C; // weak
_UNKNOWN unk_7E2AC; // weak
int dword_7E2EC = -1; // weak
char aBitmainSubmitN[21] = "bitmain_submit_nonce"; // weak
char aBitmainApiStat[19] = "bitmain_api_status"; // weak
int (*off_7E3F8)() = &sub_2B330; // weak
char *off_7E618 = "--version-file"; // weak
int dword_7E61C = 2; // weak
char *off_7E634 = "--logfile-openflag"; // weak
_UNKNOWN unk_7EAB0; // weak
_UNKNOWN unk_7EAB4; // weak
int dword_7EAB8 = 2; // weak
int dword_7EABC = 100; // weak
char *off_7EAC0 = "--config|-c"; // weak
int dword_7EB4C = 550; // weak
int dword_7EB50 = 1800; // weak
int dword_7EB58 = 1; // weak
char byte_7EB5C = '\x01'; // weak
int dword_7EB60 = 1250; // weak
int dword_7EB64 = 500; // weak
int dword_7EB68 = 5; // weak
int dword_7EB6C = 10; // weak
int dword_7EB70 = 100; // weak
_UNKNOWN unk_7EB74; // weak
char byte_7EB78 = '\x01'; // weak
char byte_7EB79 = '\x01'; // weak
char *off_7EB98 = "/var/log/hash_rate"; // weak
int dword_7EB9C = 4; // weak
int dword_7EBA0 = 5; // weak
_DWORD dword_7EBA4[63] =
{
  1116352408,
  1899447441,
  -1245643825,
  -373957723,
  961987163,
  1508970993,
  -1841331548,
  -1424204075,
  -670586216,
  310598401,
  607225278,
  1426881987,
  1925078388,
  -2132889090,
  -1680079193,
  -1046744716,
  -459576895,
  -272742522,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  -1740746414,
  -1473132947,
  -1341970488,
  -1084653625,
  -958395405,
  -710438585,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  -2117940946,
  -1838011259,
  -1564481375,
  -1474664885,
  -1035236496,
  -949202525,
  -778901479,
  -694614492,
  -200395387,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  -2067236844,
  -1933114872,
  -1866530822,
  -1538233109,
  -1090935817
}; // weak
_UNKNOWN unk_7ECA0; // weak
_UNKNOWN unk_7ECC0; // weak
int (__fastcall *off_7ECC4)(_DWORD) = &sub_2F250; // weak
int dword_7EDC8 = 1; // weak
int dword_7EDCC = 50; // weak
_UNKNOWN unk_7EDD0; // weak
char byte_7EDD4 = '\x01'; // weak
int dword_7EDD8 = -1; // weak
int dword_7EDDC = -1; // weak
void *off_7EDE0 = (void *)0x10101; // weak
__int16 word_7EDE4 = 255; // weak
int dword_7EDE8 = 255; // weak
char *off_7EDF0 = "HW Sweep"; // weak
char *off_7EE1C = "SW Sweep"; // weak
_DWORD dword_7EE48[372] =
{
  0,
  1,
  2,
  3,
  4,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  16,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  0,
  48,
  49,
  60,
  62,
  63,
  64,
  65,
  66,
  68,
  69,
  70,
  71,
  72,
  73,
  76,
  77,
  78,
  80,
  96,
  97,
  98,
  99,
  100,
  101,
  102,
  103,
  104,
  105,
  106,
  107,
  108,
  109,
  110,
  111,
  112,
  113,
  114,
  115,
  116,
  117,
  118,
  119,
  124,
  125,
  126,
  127,
  128,
  129,
  130,
  132,
  133,
  134,
  135,
  136,
  137,
  138,
  139,
  140,
  141,
  142,
  143,
  144,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  156,
  157,
  158,
  159,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  32,
  33,
  34,
  35,
  36,
  40,
  37,
  38,
  48,
  48,
  49,
  50,
  51,
  60,
  61,
  62,
  63,
  64,
  65,
  66,
  67,
  68,
  69,
  70,
  71,
  72,
  73,
  76,
  77,
  78,
  80,
  81,
  82,
  83,
  84,
  85,
  86,
  87,
  88,
  89,
  90,
  91,
  284,
  285,
  286,
  287,
  96,
  97,
  98,
  99,
  100,
  101,
  102,
  103,
  104,
  105,
  106,
  107,
  108,
  109,
  110,
  111,
  112,
  113,
  114,
  115,
  116,
  117,
  118,
  119,
  124,
  125,
  126,
  127,
  128,
  129,
  130,
  132,
  133,
  134,
  135,
  136,
  137,
  138,
  139,
  140,
  141,
  142,
  143,
  144,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
int dword_7F418 = -1; // weak
int (__fastcall *off_7F568)(_DWORD) = &malloc; // weak
int (*off_7F56C)(void) = &free; // weak
_UNKNOWN unk_7F570; // weak
_UNKNOWN unk_7F578; // weak
_UNKNOWN unk_7F580; // weak
_UNKNOWN unk_7F588; // weak
int dword_7F788 = 20000; // weak
_UNKNOWN unk_7F78C; // weak
int stderr; // weak
int stdin; // weak
int stdout; // weak
char byte_7F7A0; // weak
int dword_7F7A4; // weak
int dword_7F7A8; // weak
int dword_7F7AC; // weak
int dword_7F7B0; // weak
int dword_7F7B4; // weak
int dword_7F7B8; // weak
int dword_7F7BC; // weak
pthread_mutex_t stru_7F7C0; // idb
int dword_7F7D8; // weak
int dword_7F7DC; // weak
int dword_7F7E0; // weak
pthread_t newthread; // idb
int dword_7F7E8; // weak
pthread_mutex_t stru_7F7EC; // weak
int dword_7F804; // weak
int dword_7F808; // weak
int dword_7F80C; // weak
int dword_7F810; // weak
int dword_7F814[]; // weak
int dword_7F818[]; // weak
int dword_7F81C; // weak
int dword_7F8BC; // weak
int dword_7F8C0; // weak
_DWORD dword_7F8C4[4]; // weak
int dword_7F8D4; // weak
int dword_7F8D8; // weak
int dword_7F8DC; // weak
_DWORD dword_7F8E0[4]; // weak
int dword_7F8F0; // weak
int dword_7F8F4; // weak
char byte_7F8F8; // weak
char byte_7F9F8; // weak
int dword_7F9FC; // weak
int dword_7FA00[]; // weak
int dword_7FA04; // weak
int dword_7FA08; // weak
__int64 qword_7FA10; // weak
int dword_7FA18; // weak
int dword_7FA38; // weak
int dword_7FA3C; // weak
int dword_7FA40; // weak
pthread_mutex_t stru_7FA44; // idb
int dword_7FA5C; // weak
_UNKNOWN unk_7FA60; // weak
int dword_7FBA0; // weak
int dword_7FBC0; // weak
int dword_7FBE0[]; // weak
int dword_7FBE4; // weak
int dword_7FBE8; // weak
int dword_7FBEC; // weak
int dword_7FBF0[]; // weak
int dword_7FBF4; // weak
int dword_7FBF8; // weak
int dword_7FBFC; // weak
__int64 qword_7FC00; // weak
_UNKNOWN unk_7FC08; // weak
int dword_80748; // weak
int dword_8074C; // weak
int dword_80750; // weak
int dword_80754; // weak
int dword_80758; // weak
int dword_8075C; // weak
int dword_80760; // weak
char byte_80768[512]; // weak
int dword_80968; // weak
int dword_8096C; // weak
int dword_80970; // weak
char byte_80974[256]; // weak
pthread_mutex_t stru_80A74; // idb
pthread_cond_t cond; // idb
int dword_80AC0; // weak
int dword_80AC4; // weak
char s[200]; // idb
int dword_80B90; // weak
int dword_80B94; // weak
int dword_80B98; // weak
int dword_80B9C; // weak
char byte_80BA0[256]; // idb
char dest[256]; // idb
char byte_80DA0; // idb
_UNKNOWN unk_80EA0; // weak
_UNKNOWN unk_80F18; // weak
_UNKNOWN unk_80F1C; // weak
pthread_mutex_t mutex; // idb
int dword_80F38; // weak
int dword_80F3C; // weak
sem_t sem; // idb
_UNKNOWN unk_80F50; // weak
int dword_80F58; // weak
int dword_80F5C; // weak
int dword_80F60; // weak
char byte_80F64; // weak
int dword_80F68; // weak
__int64 qword_80F78; // weak
int dword_80F80; // weak
int dword_80F84; // weak
char algn_80F88[8]; // weak
int dword_80F90; // weak
int dword_80F94; // weak
int dword_80F98; // weak
char byte_80FA4; // weak
int dword_80FA8; // weak
int dword_80FAC; // weak
char byte_80FB0; // weak
int dword_80FB4; // weak
char byte_80FB8[16]; // weak
_UNKNOWN unk_80FC8; // weak
char byte_80FDC[256]; // weak
pthread_mutex_t stru_810DC; // weak
pthread_mutex_t stru_810F4; // idb
char byte_8110C; // weak
int dword_81110; // weak
_UNKNOWN unk_81114; // weak
int dword_81118[3]; // weak
_UNKNOWN unk_81124; // weak
_UNKNOWN unk_81128; // weak
_UNKNOWN unk_82124; // weak
_UNKNOWN unk_F423F; // weak
_UNKNOWN unk_F4240; // weak
_UNKNOWN unk_101000; // weak
_UNKNOWN unk_202020; // weak
_UNKNOWN unk_202402; // weak
_UNKNOWN unk_202802; // weak
_UNKNOWN unk_202806; // weak
_UNKNOWN unk_202A04; // weak
_UNKNOWN unk_202A08; // weak
_UNKNOWN unk_202A0C; // weak
_UNKNOWN unk_202A10; // weak
_UNKNOWN unk_202A14; // weak
_UNKNOWN unk_202A18; // weak
_UNKNOWN unk_202A1C; // weak
_UNKNOWN unk_202A20; // weak
_UNKNOWN unk_202A24; // weak
_UNKNOWN unk_202A2A; // weak
_UNKNOWN unk_20407F; // weak
_UNKNOWN unk_214B4F; // weak
_UNKNOWN unk_2D5B20; // weak
_UNKNOWN unk_2DC6C0; // weak
_UNKNOWN unk_2E2E2E; // weak
_UNKNOWN unk_303A53; // weak
_UNKNOWN unk_313A43; // weak
_UNKNOWN unk_313A46; // weak
_UNKNOWN unk_313A4D; // weak
_UNKNOWN unk_313A4E; // weak
_UNKNOWN unk_313A50; // weak
_UNKNOWN unk_313A52; // weak
_UNKNOWN unk_313A56; // weak
_UNKNOWN unk_323A4E; // weak
_UNKNOWN unk_323A50; // weak
_UNKNOWN unk_323A52; // weak
_UNKNOWN unk_333A4E; // weak
_UNKNOWN unk_333A52; // weak
_UNKNOWN unk_343A50; // weak
_UNKNOWN unk_353A50; // weak
_UNKNOWN unk_36EE80; // weak
_UNKNOWN unk_408FFC; // weak
int dword_48212C; // weak
char byte_482130; // weak
int dword_482134; // weak
__int16 word_482138; // weak
char byte_482158[256]; // weak
char ptr; // idb
int dword_482A58; // weak
char byte_482A5C; // weak
char byte_482A5D; // weak
int dword_482A60; // weak
int dword_482A64; // weak
int dword_482A68; // weak
int dword_482A6C; // weak
char byte_482A70; // weak
char byte_482A71; // weak
__time_t dword_482A74[3]; // weak
__int64 qword_482A80; // weak
char byte_482A88; // weak
char byte_482A89; // weak
int dword_482A8C; // weak
__int16 word_482A90; // weak
int dword_482A94; // weak
int dword_482A98; // weak
int dword_482A9C; // weak
_UNKNOWN unk_482AA0; // weak
_DWORD dword_483AA0[122880]; // weak
unsigned int dword_4FBAA0[1024]; // weak
pthread_mutex_t stru_4FCAA0[2]; // weak
pthread_mutex_t stru_4FCAD0; // weak
int dword_4FCAE8[16]; // weak
int dword_4FCB28; // weak
int dword_4FCB2C; // weak
int dword_4FCB30; // weak
int dword_4FCB34; // weak
int dword_4FCB38; // weak
int dword_4FCB3C; // weak
int dword_4FCB40; // weak
int dword_4FCB44; // weak
int dword_4FCB48; // weak
pthread_mutex_t stru_4FCB4C; // idb
_UNKNOWN unk_4FCB68; // weak
int dword_504B68[73]; // weak
int dword_504C8C; // weak
int dword_504C90; // weak
int dword_504C94; // weak
int dword_504C98; // weak
int dword_504C9C; // weak
int dword_504CA0; // weak
int dword_504CA4; // weak
int dword_504CA8; // weak
pthread_mutex_t stru_504CAC; // idb
int dword_504CC4; // weak
pthread_mutex_t stru_504CC8; // idb
int dword_504CE0; // weak
char algn_504CE4[4]; // weak
_UNKNOWN unk_504CE8; // weak
_UNKNOWN unk_504E68; // weak
int dword_504FE8[]; // weak
pthread_mutex_t stru_504FEC; // idb
int dword_505004; // weak
int dword_505008; // weak
int dword_50500C; // weak
int dword_505010; // weak
int dword_505014; // weak
int dword_505018; // weak
char algn_50501C[4]; // weak
int dword_505020; // weak
int dword_505024; // weak
int dword_505028; // weak
int dword_50502C; // weak
pthread_mutex_t stru_505030; // idb
_UNKNOWN unk_505048; // weak
_DWORD dword_505088[32]; // weak
int dword_505108; // weak
int dword_50510C; // weak
int dword_505110; // weak
int dword_505114; // weak
int dword_505118; // weak
pthread_mutex_t stru_50511C; // idb
pthread_mutex_t stru_505134; // idb
pthread_mutex_t stru_50514C; // weak
pthread_mutex_t stru_505164; // weak
int dword_50517C; // weak
int dword_505180; // weak
int dword_505184; // weak
pthread_mutex_t stru_505188; // weak
int dword_5051A0; // weak
int dword_5051A4; // weak
pthread_mutex_t stru_5051A8; // idb
int dword_5051C0; // weak
char algn_5051C4[4]; // weak
_DWORD dword_5051C8[512]; // weak
pthread_mutex_t stru_5059C8; // idb
_DWORD dword_5059E0[32768]; // weak
_UNKNOWN unk_5259E0; // weak
int dword_5859E0; // weak
int dword_5859E4; // weak
int dword_5859E8; // weak
pthread_mutex_t stru_5859EC; // weak
int dword_585A04; // weak
_UNKNOWN unk_585A08; // weak
_UNKNOWN unk_589A08; // weak
char s2[17404]; // idb
int dword_58DE08; // weak
int dword_58DE0C; // weak
int dword_58DE10; // weak
int dword_58DE14; // weak
int dword_58DE18; // weak
pthread_rwlock_t stru_58DE1C; // idb
int dword_58DE3C; // weak
int dword_58DE40; // weak
int dword_58DE44; // weak
int dword_58DE48; // weak
int dword_58DE4C; // weak
int dword_58DFB8; // weak
int dword_58DFBC; // weak
int dword_58DFC0; // weak
int dword_58DFC4; // weak
int dword_58DFC8; // weak
int dword_58DFCC; // weak
int dword_58DFD0; // weak
int dword_58DFD4; // weak
int dword_58DFD8; // weak
int dword_58DFDC; // weak
int dword_58DFE0; // weak
int dword_58DFE4; // weak
int dword_58DFE8; // weak
int dword_58DFEC; // weak
int dword_58DFF0; // weak
int dword_58DFF4; // weak
int dword_58DFF8; // weak
int dword_58DFFC; // weak
int dword_58E000; // weak
int dword_58E004; // weak
int dword_58E010; // weak
char byte_58E014; // weak
int dword_58E018; // weak
char byte_58E01C; // weak
char byte_58E01D; // weak
int dword_58E020; // weak
_UNKNOWN unk_58E028; // weak
_UNKNOWN unk_58E030; // weak
int dword_58E038; // weak
int dword_58E03C; // weak
double dbl_58E040[96]; // weak
int dword_58E344; // weak
int dword_58E348; // weak
int dword_58E34C; // weak
char byte_58E350; // weak
int dword_58E354; // weak
struct sigaction unk_58E35C; // idb
int dword_58E3F0; // weak
char byte_58E3F8[8192]; // weak
int dword_5903F8; // weak
int dword_590400; // weak
char byte_590404; // weak
pthread_mutex_t stru_590408; // weak
pthread_rwlock_t rwlock; // idb
char byte_590440[8224]; // weak
int dword_592460; // weak
struct sigaction unk_592464; // idb
char byte_5924F4[8192]; // weak
pthread_mutex_t stru_5944F4; // weak
pthread_mutex_t stru_59450C; // weak
struct sigaction unk_594524; // idb
int dword_5945B4; // weak
int dword_5945B8[]; // weak
int dword_5945BC; // weak
int dword_5945C0; // weak
int dword_5955BC; // weak
int dword_5955C0; // weak
int dword_5955C8[]; // weak
int dword_5955CC; // weak
int dword_5955D0; // weak
_WORD word_59CD98[57332]; // weak
_UNKNOWN unk_5B8D80; // weak
_UNKNOWN unk_808FFC; // weak
_DWORD dword_80A010[256]; // weak
_DWORD dword_80A410[289]; // weak
_DWORD dword_80A894[4]; // weak
_UNKNOWN unk_80A8A4; // weak
_DWORD dword_80ACAC[6656]; // weak
_UNKNOWN unk_8114AC; // weak
_QWORD qword_99CD98[1024]; // weak
_DWORD dword_99ED98[8]; // weak
char byte_99EDB8; // weak
char byte_99EDBC; // weak
_UNKNOWN unk_99EDC0; // weak
char byte_99EDC2; // weak
__int16 word_99EDC4; // weak
__int16 word_99EDC6; // weak
_UNKNOWN unk_99EDC8; // weak
__int16 word_99EDCA; // weak
_UNKNOWN unk_99EDCC; // weak
_UNKNOWN unk_99EDD0; // weak
_UNKNOWN unk_99EDD4; // weak
__int16 word_99EDD6; // weak
int dword_99EDD8; // weak
int dword_99EDDC; // weak
char byte_99EDE0[32]; // weak
_UNKNOWN unk_99EE00; // weak
__int64 qword_99EE08; // weak
int dword_99EE10; // weak
int dword_99EE14; // weak
int dword_99EE18; // weak
int dword_99EE1C; // weak
int dword_99EE20; // weak
int dword_99EE24; // weak
_UNKNOWN unk_99EE28; // weak
_DWORD dword_99EE48[32]; // weak
int dword_99EEC8; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (00011E84) --------------------------------------------------------
int init_proc()
{
  return sub_13C50();
}

//----- (00011E90) --------------------------------------------------------
void sub_11E90()
{
  JUMPOUT(0);
}
// 11E9C: control flows out of bounds to 0

//----- (0001230C) --------------------------------------------------------
// attributes: thunk
int __fastcall j___cxa_atexit(void (__fastcall *lpfunc)(void *), void *obj, void *lpdso_handle)
{
  return _cxa_atexit(lpfunc, obj, lpdso_handle);
}

//----- (00012620) --------------------------------------------------------
int __fastcall main(int a1, char **a2, char **a3)
{
  char *v4; // r7
  FILE *v5; // r8
  size_t v6; // r0
  size_t v7; // r5
  int v8; // r6
  int *v9; // r8
  size_t i; // r4
  const unsigned __int16 **v11; // r0
  int v12; // t1
  int v13; // r3
  void *v14; // r5
  _DWORD *v15; // r4
  _DWORD *v16; // r0
  int v17; // r4
  char *v18; // r10
  char *v19; // r5
  int v20; // r4
  int v21; // r2
  int v22; // r8
  int v23; // r6
  __int64 v24; // r10
  int v25; // r7
  int v26; // r3
  unsigned int *p_count; // r4
  int v28; // r2
  int v29; // r1
  int v30; // r0
  int v31; // r0
  int v32; // r6
  void **v33; // r10
  __int64 v34; // r0
  __int64 v35; // r6
  int v36; // r1
  int v37; // r0
  unsigned __int64 v38; // r2
  __int64 v39; // r0
  __int64 v40; // r6
  int v41; // r1
  int v42; // r0
  unsigned __int64 v43; // r2
  int v44; // r1
  int v45; // r2
  int v46; // r3
  int v47; // r1
  int v48; // r2
  int v49; // r3
  unsigned int v50; // r1
  unsigned int v51; // r2
  int *v52; // r2
  void ***v53; // r1
  unsigned int v54; // t1
  unsigned __int64 v55; // r2
  int *v56; // r3
  int v58; // r0
  int v59; // r6
  unsigned int v60; // r0
  char v61; // r0
  unsigned int v62; // r1
  int *v64; // r0
  int *v65; // r0
  int *v66; // r0
  int *v67; // r0
  int v69; // [sp+20h] [bp-A88h]
  unsigned int v70; // [sp+28h] [bp-A80h]
  double v71; // [sp+28h] [bp-A80h]
  double v72; // [sp+28h] [bp-A80h]
  pthread_mutex_t *v73; // [sp+34h] [bp-A74h]
  int *v74; // [sp+3Ch] [bp-A6Ch]
  __int64 v75; // [sp+40h] [bp-A68h]
  unsigned int v76; // [sp+4Ch] [bp-A5Ch]
  __int64 v77; // [sp+58h] [bp-A50h]
  void **v78; // [sp+68h] [bp-A40h] BYREF
  unsigned int v79[6]; // [sp+6Ch] [bp-A3Ch] BYREF
  unsigned int v80; // [sp+84h] [bp-A24h]
  int v81; // [sp+88h] [bp-A20h] BYREF
  char dest[32]; // [sp+8Ch] [bp-A1Ch] BYREF
  char command[64]; // [sp+ACh] [bp-9FCh] BYREF
  struct sigaction v84; // [sp+ECh] [bp-9BCh] BYREF
  int s[64]; // [sp+178h] [bp-930h] BYREF
  int v86[510]; // [sp+278h] [bp-830h] BYREF

  v84.sa_handler = (__sighandler_t)sub_28878;
  v84.sa_flags = 0;
  sigemptyset(&v84.sa_mask);
  sigaction(15, &v84, &unk_592464);
  sigaction(2, &v84, &unk_594524);
  sigaction(6, &v84, &unk_58E35C);
  sem_init(&sem, 0, 0);
  sub_29070((int)&stru_590408, "main", 2771);
  v4 = *a2;
  memset(s, 0, sizeof(s));
  memset(command, 0, sizeof(command));
  snprintf(command, 0x40u, "pidof %s", v4);
  v5 = popen(command, "r");
  if ( v5 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        do
        {
          if ( !fgets((char *)s, 256, v5) )
          {
            v7 = 0;
            v8 = 0;
            pclose(v5);
            v9 = s;
            for ( i = 1; strlen((const char *)s) >= i; ++i )
            {
              memset(dest, 0, sizeof(dest));
              v11 = _ctype_b_loc();
              v12 = *(unsigned __int8 *)v9;
              v9 = (int *)((char *)v9 + 1);
              if ( ((*v11)[v12] & 0x2000) != 0 )
              {
                strncpy(dest, (const char *)s + v7, i - v7 - 1);
                v13 = strtol(dest, 0, 10);
                if ( v13 > 0 && (++v8, byte_482A5D) && (byte_590404 || byte_482A5C || dword_7EBA0 > 6) )
                {
                  snprintf((char *)v86, 0x800u, "Parsed proc id is: %d\n", v13);
                  v7 = i;
                  sub_2E584(7, (const char *)v86, 0);
                }
                else
                {
                  v7 = i;
                }
              }
            }
            if ( v8 )
            {
              if ( byte_590404 || byte_482A5C || dword_7EBA0 > 2 )
              {
                snprintf((char *)v86, 0x800u, " %d instance of %s is  already Running on this machine", v8, v4);
                sub_2E584(3, (const char *)v86, 0);
              }
              if ( v8 != 1 )
              {
                snprintf((char *)v86, 0x800u, "%s is forbidden to start twice, will exit immediately!", *a2);
                sub_2E584(3, (const char *)v86, 1);
              }
            }
            goto LABEL_30;
          }
        }
        while ( !byte_482A5D );
        if ( byte_590404 || byte_482A5C || dword_7EBA0 > 6 )
          break;
LABEL_9:
        if ( byte_482A5C || dword_7EBA0 > 6 )
        {
LABEL_11:
          v6 = strlen((const char *)s);
          snprintf((char *)v86, 0x800u, "strlen is: %d\n", v6);
          sub_2E584(7, (const char *)v86, 0);
        }
      }
      snprintf((char *)v86, 0x800u, "pidof %s command result is: %s\n", v4, (const char *)s);
      sub_2E584(7, (const char *)v86, 0);
      if ( byte_482A5D )
      {
        if ( byte_590404 )
          goto LABEL_11;
        goto LABEL_9;
      }
    }
  }
  if ( byte_482A5D && (byte_590404 || byte_482A5C || dword_7EBA0 > 6) )
  {
    snprintf((char *)v86, 0x800u, " app-service:%s Not Found!!!", v4);
    sub_2E584(7, (const char *)v86, 0);
  }
LABEL_30:
  sub_52F1C("/etc/bitmain_category.conf");
  v14 = calloc(1u, 0x1664u);
  dword_592460 = (int)v14;
  v15 = calloc(1u, 0x188u);
  dword_58E354 = (int)v15;
  v16 = calloc(1u, 0x40u);
  v16[9] = v15;
  v15[5] = v14;
  dword_58E34C = (int)v16;
  sub_2BC2C(a1, (const char **)a2);
  sub_2AEF4();
  if ( sub_2823C() )
    sub_31D58(4u, "socket init failed!");
  if ( sub_339EC() )
    sub_31D58(4u, "basic init failed!");
  dword_590400 = (int)calloc(1u, 0x40u);
  pthread_attr_init((pthread_attr_t *)command);
  pthread_attr_setstacksize((pthread_attr_t *)command, 0x200000u);
  if ( sub_30B10(dword_590400, (const pthread_attr_t *)command, (void *(*)(void *))sub_283E4, (void *)dword_590400)
    && (byte_590404 || byte_482A5C || dword_7EBA0 > 2) )
  {
    snprintf((char *)v86, 0x800u, "%s: create thread for get api status failed\n", "main");
    sub_2E584(3, (const char *)v86, 0);
  }
  pthread_detach(*(_DWORD *)(dword_590400 + 12));
  v17 = *(_DWORD *)(*(_DWORD *)(dword_58E34C + 36) + 20);
  if ( pthread_mutex_init((pthread_mutex_t *)(v17 + 112), 0) )
    sub_28FB8("bitmain_soc_prepare", 1933);
  sub_29070(v17, "bitmain_soc_prepare", 1934);
  sub_29070(v17 + 384, "bitmain_soc_prepare", 1935);
  sub_29070(v17 + 2232, "bitmain_soc_prepare", 1936);
  sub_29070(v17 + 4080, "bitmain_soc_prepare", 1937);
  memset(v86, 0, 0x20u);
  HIWORD(v86[0]) = 26;
  LOBYTE(v86[0]) = 81;
  BYTE1(v86[1]) |= 7u;
  LOBYTE(v86[1]) = ~(~((v86[1] & 0xFD | (2 * (byte_80F64 & 1u))) << 30) >> 30);
  LOWORD(v86[2]) = 13833;
  BYTE2(v86[2]) = dword_80F68;
  HIBYTE(v86[2]) = 80;
  LOWORD(v86[4]) = 2570;
  LOWORD(v86[3]) = dword_7EB4C;
  HIWORD(v86[6]) = 400;
  LOWORD(v86[7]) = 600;
  HIWORD(v86[3]) = dword_7EB50;
  LOBYTE(v86[6]) = 4;
  HIWORD(v86[7]) = sub_31590((int)v86, 30);
  if ( !sub_34828(v86[0], v86[1], v86[2], v86[3], v86[4], v86[5], v86[6], v86[7]) )
    sub_31D58(4u, "soc init failed!");
  sub_31D58(2u, 0);
  pthread_mutex_lock(&mutex);
  if ( dword_80F38 )
  {
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      strcpy((char *)v86, "start the cached job");
      sub_2E584(3, (const char *)v86, 0);
    }
    sub_2B330((const void *)dword_80F3C, dword_80F38);
  }
  pthread_mutex_unlock(&mutex);
  sub_32CA8();
  v18 = byte_80768;
  while ( 2 )
  {
    v19 = v18;
LABEL_49:
    if ( !*(_BYTE *)(dword_58E354 + 364) )
    {
      v74 = (int *)dword_58E34C;
      v20 = *(_DWORD *)(*(_DWORD *)(dword_58E34C + 36) + 20);
      v73 = (pthread_mutex_t *)v20;
      pthread_mutex_lock(&stru_4FCAD0);
      if ( pthread_mutex_lock((pthread_mutex_t *)v20) )
      {
        v65 = _errno_location();
        snprintf(
          (char *)v86,
          0x800u,
          "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
          *v65,
          "bmminer.c",
          "bitmain_c5_scanhash",
          2063);
        sub_2E584(3, (const char *)v86, 1);
      }
      if ( pthread_rwlock_rdlock((pthread_rwlock_t *)(v20 + 24)) )
      {
        v67 = _errno_location();
        snprintf(
          (char *)v86,
          0x800u,
          "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
          *v67,
          "bmminer.c",
          "bitmain_c5_scanhash",
          2063);
        sub_2E584(3, (const char *)v86, 1);
      }
      if ( pthread_mutex_unlock((pthread_mutex_t *)v20) )
      {
        v66 = _errno_location();
        snprintf(
          (char *)v86,
          0x800u,
          "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
          *v66,
          "bmminer.c",
          "bitmain_c5_scanhash",
          2063);
        sub_2E584(3, (const char *)v86, 1);
      }
      v75 = 0LL;
LABEL_57:
      if ( !dword_5955D0 )
      {
LABEL_85:
        qword_99EE08 += v75;
        v31 = pthread_rwlock_unlock((pthread_rwlock_t *)&v73[1]);
        if ( v31 )
        {
          v64 = _errno_location();
          snprintf(
            (char *)v86,
            0x800u,
            "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
            *v64,
            "bmminer.c",
            "bitmain_c5_scanhash",
            2156);
          v31 = sub_2E584(3, (const char *)v86, 1);
        }
        off_7ECC4(v31);
        pthread_mutex_unlock(&stru_4FCAD0);
        sub_304D4();
        if ( v75 )
        {
          v18 = v19;
          v77 = 0xFFFFFFFFLL * v75;
          if ( byte_482A5D && (byte_590404 || byte_482A5C || dword_7EBA0 > 6) )
          {
            snprintf((char *)v86, 0x800u, "%s: hashes %llu ...\n", "bitmain_c5_scanhash", v77);
            sub_2E584(7, (const char *)v86, 0);
          }
          if ( v77 )
            unk_80F50 = ((double (__fastcall *)(int, _DWORD, int, unsigned int))loc_600C4)(
                          -(int)v75,
                          (unsigned __int64)(0xFFFFFFFFLL * v75) >> 32,
                          -(int)v75,
                          -(int)v75 | (unsigned int)((unsigned __int64)(0xFFFFFFFFLL * v75) >> 32))
                      / 1000000000.0
                      + unk_80F50;
          continue;
        }
        goto LABEL_49;
      }
      while ( 1 )
      {
        v21 = 0;
        v22 = dword_5955C8[15 * dword_5955CC + 8];
        v23 = dword_5955C8[15 * dword_5955CC + 3];
        v24 = *(_QWORD *)&dword_5955C8[15 * dword_5955CC + 6];
        v69 = dword_5955C8[15 * dword_5955CC + 9];
        v25 = dword_5955C8[15 * dword_5955CC + 4];
        v70 = (dword_5955C8[15 * dword_5955CC + 5] << 24) | HIBYTE(dword_5955C8[15 * dword_5955CC + 5]) | ((unsigned int)dword_5955C8[15 * dword_5955CC + 5] >> 8) & 0xFF00 | (dword_5955C8[15 * dword_5955CC + 5] << 8) & 0xFF0000;
        do
          ++v21;
        while ( v21 != 32 );
        if ( byte_482A5D && (byte_590404 || byte_482A5C || dword_7EBA0 > 6) )
        {
          snprintf(
            (char *)v86,
            0x800u,
            "%s: job_id:0x%x   work_id:0x%x   nonce2:0x%llx nonce3:0x%x   version:0x%x\n",
            "bitmain_c5_scanhash",
            v23,
            v25,
            v24,
            v22,
            v70);
          sub_2E584(7, (const char *)v86, 0);
        }
        if ( (unsigned int)dword_5955CC > 0x1FD )
          v26 = 0;
        else
          v26 = dword_5955CC;
        p_count = &v73[7].__count;
        if ( (unsigned int)dword_5955CC <= 0x1FD )
          ++v26;
        dword_5955CC = v26;
        v28 = *((_DWORD *)v19 + 513);
        --dword_5955D0;
        if ( v22 != v28 || v25 != *((_DWORD *)v19 + 514) )
          break;
        if ( sub_1E29C(v69) != 1 )
          goto LABEL_57;
        if ( byte_482A5D && (byte_590404 || byte_482A5C || dword_7EBA0 > 6) )
        {
          strcpy((char *)v86, "reepat nonce error");
          sub_2E584(7, (const char *)v86, 0);
        }
LABEL_84:
        sub_2A3C4((int)v74);
        sub_1E6E0(v69);
        if ( !dword_5955D0 )
          goto LABEL_85;
      }
      *((_DWORD *)v19 + 513) = v22;
      *((_DWORD *)v19 + 514) = v25;
      if ( byte_482A5D )
      {
        if ( !byte_590404 && !byte_482A5C && dword_7EBA0 <= 6 )
        {
          v29 = dword_7EAB8;
          v30 = dword_7EAB8 - v23;
          goto LABEL_76;
        }
        snprintf((char *)v86, 0x800u, "%s: Chain ID J%d ...\n", "bitmain_c5_scanhash", v69 + 1);
        sub_2E584(7, (const char *)v86, 0);
        if ( byte_482A5D )
        {
          v29 = dword_7EAB8;
          v30 = dword_7EAB8 - v23;
          if ( byte_590404 )
          {
LABEL_95:
            snprintf(
              (char *)v86,
              0x800u,
              "%s: given_id:%d job_id:%d switch:%d  ...\n",
              "bitmain_c5_scanhash",
              v29,
              v23,
              v30);
            sub_2E584(7, (const char *)v86, 0);
            goto LABEL_96;
          }
LABEL_76:
          if ( !byte_482A5C && dword_7EBA0 <= 6 )
          {
            switch ( v30 )
            {
              case 1:
                goto LABEL_141;
              case 0:
                goto LABEL_100;
              case 2:
LABEL_99:
                p_count = &v73[161].__count;
                goto LABEL_100;
            }
            goto LABEL_81;
          }
          goto LABEL_95;
        }
      }
LABEL_96:
      v32 = dword_7EAB8 - v23;
      switch ( v32 )
      {
        case 1:
LABEL_141:
          p_count = &v73[84].__count;
LABEL_100:
          sub_2A264(v74, (int *)&v78, (int)p_count, (int)p_count, v24, v70);
          v33 = v78;
          v76 = *p_count;
          v71 = *((double *)v78 + 39);
          LODWORD(v34) = sub_60180(v71);
          v35 = v34;
          if ( v34 != qword_80F78 )
          {
            v36 = 0;
            v37 = 0;
            qword_80F78 = v35;
            dword_80F80 = 0;
            dword_80F84 = 0;
            if ( v35 )
            {
              v38 = v35;
              while ( 1 )
              {
                v38 >>= 1;
                if ( !v38 )
                  break;
                v37 = (__PAIR64__(v37, v36++) + 1) >> 32;
              }
            }
            else
            {
              v36 = -1;
              v37 = -1;
            }
            dword_80F80 = v36;
            dword_80F84 = v37;
            if ( byte_482A5D )
            {
              if ( byte_590404 || byte_482A5C || dword_7EBA0 > 6 )
              {
                snprintf(
                  (char *)v86,
                  0x800u,
                  "%s: pool_diff:%lld work_diff:%f pool_diff_bit:%lld ...\n",
                  "hashtest_submit",
                  v35,
                  v71,
                  __PAIR64__(v37, v36));
                sub_2E584(7, (const char *)v86, 0);
              }
            }
          }
          v72 = unk_7EAB0;
          LODWORD(v39) = sub_60180(unk_7EAB0);
          v40 = v39;
          if ( v39 != *(_QWORD *)algn_80F88 )
          {
            v41 = 0;
            *(_QWORD *)algn_80F88 = v40;
            v42 = 0;
            if ( v40 )
            {
              v43 = v40;
              while ( 1 )
              {
                v43 >>= 1;
                if ( !v43 )
                  break;
                v42 = (__PAIR64__(v42, v41++) + 1) >> 32;
              }
            }
            else
            {
              v41 = -1;
              v42 = -1;
            }
            dword_80F90 = v41;
            dword_80F94 = v42;
            if ( byte_482A5D )
            {
              if ( byte_590404 || byte_482A5C || dword_7EBA0 > 6 )
              {
                snprintf(
                  (char *)v86,
                  0x800u,
                  "%s:net_diff:%lld current_diff:%f net_diff_bit %lld ...\n",
                  "hashtest_submit",
                  v40,
                  v72,
                  __PAIR64__(v42, v41));
                sub_2E584(7, (const char *)v86, 0);
              }
            }
          }
          v44 = (int)v33[33];
          v45 = (int)v33[34];
          v46 = (int)v33[35];
          s[2] = (int)v33[32];
          s[3] = v44;
          s[4] = v45;
          s[5] = v46;
          v47 = (int)v33[37];
          v48 = (int)v33[38];
          v49 = (int)v33[39];
          s[6] = (int)v33[36];
          s[7] = v47;
          s[8] = v48;
          s[9] = v49;
          s[0] = 80;
          s[1] = 0;
          v50 = (unsigned int)v33[17];
          v51 = (unsigned int)v33[18];
          v79[0] = (unsigned int)v33[16];
          v79[1] = v50;
          v79[2] = v51;
          sub_316B0((int)&s[10], v79, 0xCu);
          v79[0] = v22;
          sub_316B0((int)&s[13], v79, 4u);
          sub_2327C((int)s, v79);
          memset(s, 0, 0xE8u);
          sub_23430(v79, 32, dest);
          v52 = &v81;
          v53 = &v78;
          do
          {
            v54 = v52[1];
            ++v52;
            v53[1] = (void **)bswap32(v54);
            ++v53;
          }
          while ( &dest[28] != (char *)v52 );
          LODWORD(v55) = v81;
          if ( v81 )
          {
            if ( sub_1E29C(v69) == 1 )
            {
              if ( byte_482A5D && (byte_590404 || byte_482A5C || dword_7EBA0 > 6) )
              {
                strcpy((char *)v86, "hash2_32 error");
                sub_2E584(7, (const char *)v86, 0);
              }
              sub_2A3C4((int)v74);
              sub_1E6E0(v69);
            }
            if ( byte_482A5D && (byte_590404 || byte_482A5C || dword_7EBA0 > 6) )
            {
              snprintf((char *)v86, 0x800u, "%s: HASH2_32[7] != 0", "hashtest_submit");
              sub_2E584(7, (const char *)v86, 0);
            }
          }
          else
          {
            v56 = &v81;
            while ( !*--v56 )
            {
              LODWORD(v55) = v55 + 1;
              if ( (_DWORD)v55 == 7 )
              {
                v55 = 7LL;
                goto LABEL_128;
              }
            }
            v55 = (int)v55;
LABEL_128:
            if ( *(_QWORD *)&dword_80F80 >> 5 <= v55 )
            {
              v58 = sub_1E160();
              v59 = sub_51978(v22, v58);
              v60 = sub_51970(v22);
              if ( byte_482A5D && (byte_590404 || byte_482A5C || dword_7EBA0 > 6) )
              {
                snprintf(
                  (char *)v86,
                  0x800u,
                  "%s: chain %d which_asic_nonce %d which_core_nonce %d",
                  "hashtest_submit",
                  v69,
                  v59,
                  v60);
                sub_2E584(7, (const char *)v86, 0);
              }
              v61 = dword_80F80;
              v62 = *(&v80 - (*(__int64 *)&dword_80F80 >> 5));
              ++qword_99CD98[256 * v69 + v59];
              if ( bswap32(v62) < 0xFFFFFFFF >> (v61 & 0x1F) )
              {
                *(_QWORD *)&dword_99ED98[2 * v69] += 256LL;
                sub_2ACEC((int)v74, (const char **)v33, v22, v76);
                v75 += 256LL;
              }
              else if ( bswap32(v80) <= 0xFFFFFE )
              {
                *(_QWORD *)&dword_99ED98[2 * v69] += 256LL;
                v75 += 256LL;
              }
            }
          }
          sub_2A1E0(&v78, "bmminer.c", "bitmain_c5_scanhash", 2153);
          goto LABEL_57;
        case 0:
          goto LABEL_100;
        case 2:
          goto LABEL_99;
      }
      if ( byte_590404 || byte_482A5C )
      {
LABEL_82:
        snprintf((char *)v86, 0x800u, "%s: job_id non't found ...\n", "bitmain_c5_scanhash");
        sub_2E584(3, (const char *)v86, 0);
LABEL_83:
        if ( sub_1E29C(v69) != 1 )
          goto LABEL_57;
        goto LABEL_84;
      }
LABEL_81:
      if ( dword_7EBA0 <= 2 )
        goto LABEL_83;
      goto LABEL_82;
    }
    break;
  }
  sem_destroy(&sem);
  sub_194DC();
  sub_53604();
  return 0;
}
// 13278: variable 'v34' is possibly undefined
// 13388: variable 'v39' is possibly undefined
// 7EAB8: using guessed type int dword_7EAB8;
// 7EB4C: using guessed type int dword_7EB4C;
// 7EB50: using guessed type int dword_7EB50;
// 7EB9C: using guessed type int dword_7EB9C;
// 7EBA0: using guessed type int dword_7EBA0;
// 7ECC4: using guessed type int (__fastcall *off_7ECC4)(_DWORD);
// 80F38: using guessed type int dword_80F38;
// 80F3C: using guessed type int dword_80F3C;
// 80F64: using guessed type char byte_80F64;
// 80F68: using guessed type int dword_80F68;
// 80F78: using guessed type __int64 qword_80F78;
// 80F80: using guessed type int dword_80F80;
// 80F84: using guessed type int dword_80F84;
// 80F90: using guessed type int dword_80F90;
// 80F94: using guessed type int dword_80F94;
// 482A5C: using guessed type char byte_482A5C;
// 482A5D: using guessed type char byte_482A5D;
// 4FCAD0: using guessed type pthread_mutex_t stru_4FCAD0;
// 58E34C: using guessed type int dword_58E34C;
// 58E354: using guessed type int dword_58E354;
// 590400: using guessed type int dword_590400;
// 590404: using guessed type char byte_590404;
// 590408: using guessed type pthread_mutex_t stru_590408;
// 592460: using guessed type int dword_592460;
// 5955C8: using guessed type int dword_5955C8[];
// 5955CC: using guessed type int dword_5955CC;
// 5955D0: using guessed type int dword_5955D0;
// 99CD98: using guessed type _QWORD qword_99CD98[1024];
// 99ED98: using guessed type _DWORD dword_99ED98[8];
// 99EE08: using guessed type __int64 qword_99EE08;
// 12620: using guessed type unsigned int var_A3C[6];

//----- (00013C20) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __noreturn start(void (*a1)(void), int a2, int a3, int a4, ...)
{
  int v4; // [sp-4h] [bp-4h]
  va_list va; // [sp+0h] [bp+0h] BYREF

  va_start(va, a4);
  _libc_start_main(main, v4, (char **)va, (void (*)(void))init, (void (*)(void))nullsub_16, a1, va);
  abort();
}
// 13C2A: positive sp value 4 has been found
// 13C3C: variable 'v4' is possibly undefined
// 602D8: using guessed type int init();
// 60314: using guessed type int nullsub_16();

//----- (00013C50) --------------------------------------------------------
int sub_13C50()
{
  int result; // r0

  if ( &__gmon_start__ )
    return _gmon_start__();
  return result;
}
// 1221C: using guessed type int _gmon_start__(void);

//----- (00013C74) --------------------------------------------------------
void *sub_13C74()
{
  return &unk_7F78C;
}

//----- (00013C98) --------------------------------------------------------
__int64 sub_13C98()
{
  __int64 result; // r0

  LODWORD(result) = &unk_7F78C;
  HIDWORD(result) = 0;
  return result;
}

//----- (00013CC4) --------------------------------------------------------
void *sub_13CC4()
{
  void *result; // r0

  if ( !byte_7F7A0 )
  {
    result = sub_13C74();
    byte_7F7A0 = 1;
  }
  return result;
}
// 7F7A0: using guessed type char byte_7F7A0;

//----- (00013CE0) --------------------------------------------------------
int __fastcall sub_13CE0(unsigned int a1)
{
  unsigned int i; // r4
  int v3; // r1
  int v4; // r0
  bool v5; // cc
  int result; // r0
  int v7; // r0
  int v8; // r6
  char s[2080]; // [sp+8h] [bp-820h] BYREF

  for ( i = 0; ; ++i )
  {
    v5 = sub_1E2FC() > i;
    result = (unsigned __int8)i;
    if ( !v5 )
      break;
    v7 = sub_3FF08((unsigned __int8)i);
    v8 = v7;
    if ( v7 >= 0 )
    {
      if ( (unsigned int)dword_7EB9C > 4 )
      {
        snprintf(s, 0x800u, "fan[%u] speed[%u]\n", (unsigned __int8)i, v7);
        sub_2E584(4, s, 0);
      }
      sub_1E3D4((unsigned __int8)i, v8);
      if ( v8 > 9999 || (v3 = 1, v4 = (unsigned __int8)i, a1 > v8) )
      {
        v4 = (unsigned __int8)i;
        v3 = 0;
      }
      sub_1E350(v4, v3);
    }
  }
  return result;
}
// 7EB9C: using guessed type int dword_7EB9C;

//----- (00013DA4) --------------------------------------------------------
int __fastcall sub_13DA4(unsigned int a1, int a2)
{
  int v2; // r4
  int v4; // r4
  int v5; // r5
  int v6; // r4
  int v8; // r5
  int *v9; // r6
  int v10; // r5
  int v11; // r9
  int v12; // r0
  int v13; // r4
  int v14; // r4
  int v15; // r0
  int v16; // r4
  int v17; // r5
  int v18; // r0
  char s[2080]; // [sp+8h] [bp-820h] BYREF

  v2 = a2;
  if ( a2 )
  {
    v4 = 10;
    do
    {
      sub_13CE0(a1);
      v5 = sub_1E30C();
      if ( v5 >= sub_1E2FC() )
        break;
      sub_304D4();
      --v4;
    }
    while ( v4 );
    v6 = sub_1E30C();
    if ( v6 >= sub_1E2FC() )
    {
LABEL_6:
      sub_20A08(0);
      return 0;
    }
  }
  else
  {
    sub_13CE0(a1);
    v8 = sub_1E30C();
    LOWORD(v9) = (unsigned __int16)&dword_7F7A4;
    if ( v8 < sub_1E2FC() )
    {
      HIWORD(v9) = (unsigned int)&dword_7F7A4 >> 16;
      ++*v9;
      while ( 1 )
      {
        v10 = (unsigned __int8)v2++;
        if ( v10 >= sub_1E2FC() )
          break;
        if ( (unsigned int)dword_7EB9C > 3 )
        {
          v11 = *v9;
          v12 = sub_1E43C(v10);
          snprintf(s, 0x800u, "conti_check_count:%d, fan_id = %d, fan_speed = %d\n", v11, v10, v12);
          sub_2E584(3, s, 0);
        }
      }
    }
    else
    {
      HIWORD(v9) = 7;
      *v9 = 0;
    }
    v13 = sub_1E30C();
    if ( v13 >= sub_1E2FC() || (unsigned int)*v9 <= 9 )
      goto LABEL_6;
  }
  if ( (unsigned int)dword_7EB9C > 1 )
  {
    v14 = sub_1E30C();
    v15 = sub_1E2FC();
    snprintf(s, 0x800u, "Error, fan lost, only find %d (< %d)\n", v14, v15);
    sub_2E584(1, s, 0);
  }
  v16 = 0;
  while ( 1 )
  {
    v17 = (unsigned __int8)v16++;
    if ( v17 >= sub_1E2FC() )
      break;
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      v18 = sub_1E43C(v17);
      snprintf(s, 0x800u, "fan_id = %d, fan_speed = %d\n", v17, v18);
      sub_2E584(3, s, 0);
    }
  }
  sub_356C4(10, 255);
  sub_20A08(1);
  sub_31D58(7u, "fan lost");
  return -1;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 7F7A4: using guessed type int dword_7F7A4;

//----- (00013FB0) --------------------------------------------------------
int __fastcall sub_13FB0(int a1)
{
  int result; // r0
  char v3[2064]; // [sp+0h] [bp-810h] BYREF

  result = dword_7F7A8;
  if ( !dword_7F7A8 )
  {
    result = sub_4101C(dword_7F7A8);
    dword_7F7A8 = result;
  }
  if ( result < 0 )
  {
    if ( byte_590404 || byte_482A5C || dword_7EBA0 > 2 )
    {
      strcpy(v3, "pwm for fan init error");
      return sub_2E584(3, v3, 0);
    }
  }
  else if ( a1 != dword_7F7AC )
  {
    if ( (unsigned int)dword_7EB9C > 4 )
    {
      snprintf(v3, 0x800u, "set pwm = %d", a1);
      sub_2E584(4, v3, 0);
      result = dword_7F7A8;
    }
    sub_4110C(result, a1);
    result = sub_1E49C(a1);
    dword_7F7AC = a1;
  }
  return result;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 7EBA0: using guessed type int dword_7EBA0;
// 7F7A8: using guessed type int dword_7F7A8;
// 7F7AC: using guessed type int dword_7F7AC;
// 482A5C: using guessed type char byte_482A5C;
// 590404: using guessed type char byte_590404;

//----- (000140E4) --------------------------------------------------------
int sub_140E4()
{
  char v1[2056]; // [sp+0h] [bp-808h] BYREF

  if ( (unsigned int)dword_7EB9C > 3 )
  {
    strcpy(v1, "Note: front fan is power on!\n");
    sub_2E584(3, v1, 0);
  }
  return sub_3FFA0(0);
}
// 7EB9C: using guessed type int dword_7EB9C;

//----- (00014148) --------------------------------------------------------
int sub_14148()
{
  char v1[2056]; // [sp+0h] [bp-808h] BYREF

  if ( (unsigned int)dword_7EB9C > 3 )
  {
    strcpy(v1, "Note: front fan is power off!\n");
    sub_2E584(3, v1, 0);
  }
  return sub_3FFEC(0);
}
// 7EB9C: using guessed type int dword_7EB9C;

//----- (000141B4) --------------------------------------------------------
int sub_141B4()
{
  char v1[2056]; // [sp+0h] [bp-808h] BYREF

  if ( (unsigned int)dword_7EB9C > 3 )
  {
    strcpy(v1, "Note: rear fan is power on!\n");
    sub_2E584(3, v1, 0);
  }
  return sub_3FFA0(1);
}
// 7EB9C: using guessed type int dword_7EB9C;

//----- (00014218) --------------------------------------------------------
int sub_14218()
{
  char v1[2056]; // [sp+0h] [bp-808h] BYREF

  if ( (unsigned int)dword_7EB9C > 3 )
  {
    strcpy(v1, "Note: rear fan is power off!\n");
    sub_2E584(3, v1, 0);
  }
  return sub_3FFEC(1);
}
// 7EB9C: using guessed type int dword_7EB9C;

//----- (0001427C) --------------------------------------------------------
int __fastcall sub_1427C(int a1, int a2)
{
  int v4; // r4
  int v5; // r5

  v4 = 8;
  do
  {
    v5 = sub_2C06C(28, a1, a2);
    if ( v5 )
      break;
    usleep(0x3E8u);
    --v4;
  }
  while ( v4 );
  return v5;
}

//----- (000142BC) --------------------------------------------------------
int __fastcall sub_142BC(int a1, int a2, int a3, int a4, unsigned __int8 *a5)
{
  int v5; // r6
  int j; // r8
  __int16 v10; // r10
  bool v11; // zf
  int v13; // r11
  int i; // r10
  __int16 v15; // r8

  v5 = a4;
  if ( a4 )
  {
    v13 = 2;
    for ( i = 0; ; i = 1 )
    {
      sub_1427C(a2, a1);
      sub_1ECDC(0x98u, a3, *a5, 1, a2, a1);
      sub_1427C(a2, a1);
      usleep(0x3E8u);
      sub_1427C(a2, a1);
      sub_1ECDC(0x98u, a3, 0, 0, a2, a1);
      v15 = sub_1427C(a2, a1);
      usleep(0x3E8u);
      if ( HIBYTE(v15) == a3 || (unsigned __int8)v15 == *a5 )
        break;
      v11 = v13 == 1;
      v13 = 1;
      if ( v11 )
        return 0;
    }
    if ( !i )
      return v5;
    return 0;
  }
  for ( j = 2; ; j = 1 )
  {
    sub_1427C(a2, a1);
    sub_1ECDC(0x98u, a3, 0, 0, a2, a1);
    usleep(0x3E8u);
    v10 = sub_1427C(a2, a1);
    usleep(0x3E8u);
    if ( HIBYTE(v10) == a3 )
      break;
    v11 = j == 1;
    v5 = 1;
    if ( v11 )
      return 0;
  }
  if ( v5 || !(_BYTE)v10 )
    return 0;
  *a5 = v10;
  return 1;
}

//----- (00014434) --------------------------------------------------------
int sub_14434()
{
  if ( sub_1E170() )
    return sub_1E170();
  else
    return sub_1E19C();
}

//----- (00014454) --------------------------------------------------------
int __fastcall sub_14454(int a1, int a2, unsigned int a3, int a4)
{
  int v9; // r5
  char *v10; // r3
  unsigned __int8 v11; // [sp+17h] [bp-821h] BYREF
  char s[2080]; // [sp+18h] [bp-820h] BYREF

  if ( dword_7F7B0 )
  {
    if ( sub_1E29C(a1) )
    {
      v9 = sub_1E170();
      if ( v9 )
      {
        if ( a2 >= sub_14434() || a3 > 1 )
        {
          if ( (unsigned int)dword_7EB9C > 3 )
          {
            snprintf(
              s,
              0x800u,
              "%s invalid param. index = %d, type = %d, model = %d on chain %d",
              "read_sensor_on_asic",
              a2,
              a4,
              a3,
              a1);
            sub_2E584(3, s, 0);
            return 255;
          }
        }
        else
        {
          v11 = -1;
          v10 = &aReadSensorOnAs[16 * a3];
          if ( !a4 )
            v9 = (unsigned __int8)v10[29];
          if ( a4 )
            v9 = (unsigned __int8)v10[30];
          if ( sub_142BC(a1, (unsigned __int8)(*(_DWORD *)(dword_7F7B4 + 4 * a2) * dword_7F7B0), v9, 0, &v11) )
            return v11 - 64;
          if ( (unsigned int)dword_7EB9C > 3 )
          {
            snprintf(
              s,
              0x800u,
              "read temp sensor failed: chain = %d, sensor pos = %d, address = %d, reg = %d\n",
              a1,
              *(_DWORD *)(dword_7F7B4 + 4 * a2),
              dword_7F7B0 * *(_DWORD *)(dword_7F7B4 + 4 * a2),
              v9);
            sub_2E584(3, s, 0);
          }
        }
      }
      else if ( (unsigned int)dword_7EB9C > 3 )
      {
        snprintf(s, 0x800u, "%s chain %d ,index %d not connected", "read_sensor_on_asic", a1, a2);
        sub_2E584(3, s, 0);
        return 255;
      }
    }
    else if ( (unsigned int)dword_7EB9C > 4 )
    {
      snprintf(s, 0x800u, "%s chain %d not pluged", "read_sensor_on_asic", a1);
      sub_2E584(4, s, 0);
      return 255;
    }
  }
  else if ( (unsigned int)dword_7EB9C > 3 )
  {
    strcpy(s, "can not read temp by asic before calibration");
    sub_2E584(3, s, dword_7F7B0);
    return 255;
  }
  return 255;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 7F7B0: using guessed type int dword_7F7B0;
// 7F7B4: using guessed type int dword_7F7B4;

//----- (000146C8) --------------------------------------------------------
int __fastcall sub_146C8(int a1)
{
  int v2; // r7
  int v3; // r4
  unsigned int v4; // r5
  int v5; // r6
  unsigned int v7; // r5
  unsigned int v8; // r3
  int v9; // r6
  int v10; // r4
  char v11; // r4
  char v12; // r0
  int v13; // [sp+Ch] [bp-84Ch]
  int v14; // [sp+10h] [bp-848h]
  int v15; // [sp+14h] [bp-844h]
  const char *v16; // [sp+24h] [bp-834h]
  unsigned __int8 v17; // [sp+2Eh] [bp-82Ah] BYREF
  unsigned __int8 v18; // [sp+2Fh] [bp-829h] BYREF
  char s[2088]; // [sp+30h] [bp-828h] BYREF

  v2 = 0;
  v14 = 4 * a1;
  v16 = 0;
LABEL_2:
  if ( sub_14434() <= v2 )
  {
    v8 = dword_7EB9C;
    goto LABEL_29;
  }
  v15 = 4 * v2;
  v3 = 4;
  v4 = (unsigned __int8)(*(_DWORD *)(dword_7F7B4 + 4 * v2) * dword_7F7B0);
  sub_50874((unsigned __int8)a1, v4, 0);
  usleep(0x2710u);
  while ( 1 )
  {
    s[0] = 0;
    sub_142BC(a1, v4, 254, 0, (unsigned __int8 *)s);
    if ( s[0] == 26 )
      break;
    if ( !--v3 )
    {
      v5 = 4;
      do
      {
        s[0] = 0;
        sub_142BC(a1, v4, 254, 0, (unsigned __int8 *)s);
        if ( s[0] == 85 )
        {
          v7 = 1;
          v16 = "TMP451";
          goto LABEL_13;
        }
        --v5;
      }
      while ( v5 );
      if ( (unsigned int)dword_7EB9C > 3 )
      {
        snprintf(s, 0x800u, "sensor %d @ chain %d manufacture id unknown", *(_DWORD *)(dword_7F7B4 + 4 * v2), a1);
        sub_2E584(3, s, 0);
      }
      return -1;
    }
  }
  v7 = 0;
  v16 = "NCT218";
LABEL_13:
  if ( (unsigned int)dword_7EB9C > 3 )
  {
    snprintf(s, 0x800u, "sensor %d @ chain %d is %s", *(_DWORD *)(dword_7F7B4 + 4 * v2), a1, v16);
    sub_2E584(3, s, 0);
  }
  v17 = 4;
  if ( dword_7F7B0 )
  {
    if ( !sub_1E170() )
    {
      if ( (unsigned int)dword_7EB9C <= 3 )
        return 0;
      snprintf(s, 0x800u, "%s chain %d ,index %d not connected", "set_ext_mode", a1, v2);
      sub_2E584(3, s, 0);
      goto LABEL_22;
    }
    if ( !sub_142BC(
            a1,
            (unsigned __int8)(*(_DWORD *)(dword_7F7B4 + 4 * v2) * dword_7F7B0),
            (unsigned __int8)aReadSensorOnAs[16 * v7 + 31],
            1,
            &v17) )
    {
      if ( (unsigned int)dword_7EB9C <= 3 )
        return 0;
      snprintf(s, 0x800u, "set ext mode failed for senser %d @ chain %d", *(_DWORD *)(dword_7F7B4 + 4 * v2), a1);
      sub_2E584(3, s, 0);
      goto LABEL_22;
    }
    v9 = 6 * v2;
    LOBYTE(v13) = 11;
    while ( 1 )
    {
      v11 = sub_14454(a1, v2, v7, 0);
      *(_WORD *)(*(_DWORD *)(*(_DWORD *)(dword_7F7B8 + v14) + 4) + v9 + 2) = v11;
      v12 = sub_14454(a1, v2, v7, 1);
      v10 = (char)(v11 - v12);
      *(_WORD *)(*(_DWORD *)(*(_DWORD *)(dword_7F7B8 + v14) + 8) + v9 + 2) = v12;
      if ( (unsigned __int8)(v10 + 2) <= 4u )
      {
        if ( (unsigned int)dword_7EB9C <= 4 )
        {
LABEL_46:
          ++v2;
          goto LABEL_2;
        }
        ++v2;
        snprintf(
          s,
          0x800u,
          "sensor %d @ chain %d chip_temp_offset less than 2, no need to set offset",
          *(_DWORD *)(dword_7F7B4 + v15),
          a1);
        sub_2E584(4, s, 0);
        goto LABEL_2;
      }
      v18 = v10;
      if ( dword_7F7B0 )
      {
        if ( sub_1E170() )
        {
          if ( sub_142BC(
                 a1,
                 (unsigned __int8)(*(_DWORD *)(dword_7F7B4 + 4 * v2) * dword_7F7B0),
                 (unsigned __int8)aReadSensorOnAs[16 * v7 + 32],
                 1,
                 &v18) )
          {
            if ( (unsigned int)dword_7EB9C > 3 )
            {
              snprintf(s, 0x800u, "sensor %d @ chain %d, offset = %d", *(_DWORD *)(dword_7F7B4 + 4 * v2), a1, (char)v10);
LABEL_43:
              sub_2E584(3, s, 0);
              if ( (v10 & 0x80u) != 0 )
                v10 = -(char)v10;
              if ( v10 <= 2 )
                goto LABEL_46;
              goto LABEL_37;
            }
          }
          else if ( (unsigned int)dword_7EB9C > 3 )
          {
            snprintf(s, 0x800u, "set offset failed for senser %d @ chain %d", *(_DWORD *)(dword_7F7B4 + 4 * v2), a1);
            sub_2E584(3, s, 0);
          }
        }
        else if ( (unsigned int)dword_7EB9C > 3 )
        {
          snprintf(s, 0x800u, "%s chain %d ,index %d not connected", "set_sensor_offset", a1, v2);
          goto LABEL_43;
        }
      }
      else if ( (unsigned int)dword_7EB9C > 3 )
      {
        strcpy(s, "can not set ext mode before calibration");
        sub_2E584(3, s, 0);
      }
      if ( (v10 & 0x80u) != 0 )
        v10 = -(char)v10;
      if ( v10 <= 2 )
        goto LABEL_46;
LABEL_37:
      v13 = (unsigned __int8)(v13 - 1);
      if ( !v13 )
        goto LABEL_46;
    }
  }
  if ( (unsigned int)dword_7EB9C <= 3 )
    return 0;
  strcpy(s, "can not set ext mode before calibration");
  sub_2E584(3, s, 0);
LABEL_22:
  if ( (unsigned int)dword_7EB9C <= 3 )
    return 0;
  snprintf(s, 0x800u, "sensor %d @ chain %d fail to set to ext mode", *(_DWORD *)(dword_7F7B4 + 4 * v2), a1);
  sub_2E584(3, s, 0);
  v8 = dword_7EB9C;
LABEL_29:
  if ( v8 > 3 )
  {
    snprintf(s, 0x800u, "chain %d temp sensor %s\n", a1, v16);
    sub_2E584(3, s, 0);
  }
  return 0;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 7F7B0: using guessed type int dword_7F7B0;
// 7F7B4: using guessed type int dword_7F7B4;
// 7F7B8: using guessed type int dword_7F7B8;

//----- (00014CC0) --------------------------------------------------------
int __fastcall sub_14CC0(int a1, int a2, int a3)
{
  int v7; // r4

  if ( a2 )
  {
    if ( !sub_1E170() || sub_14434() <= a3 || !dword_7F7BC )
      return 255;
  }
  else if ( sub_1E19C() <= a3 )
  {
    return 255;
  }
  if ( !dword_7F7B8 )
    return 255;
  pthread_mutex_lock(&stru_7F7C0);
  v7 = *(__int16 *)(*(_DWORD *)(*(_DWORD *)(dword_7F7B8 + 4 * a1) + 4 * a2) + 6 * a3 + 2);
  pthread_mutex_unlock(&stru_7F7C0);
  return v7;
}
// 7F7B8: using guessed type int dword_7F7B8;
// 7F7BC: using guessed type int dword_7F7BC;

//----- (00014D60) --------------------------------------------------------
int __fastcall sub_14D60(int a1, int a2, int a3)
{
  int v6; // r0
  int v7; // r4

  pthread_mutex_lock(&stru_7F7C0);
  if ( a2 )
    v6 = sub_14434();
  else
    v6 = sub_1E19C();
  if ( a1 > 3 || a3 >= v6 )
    v7 = 0;
  else
    v7 = *(__int16 *)(*(_DWORD *)(*(_DWORD *)(dword_7F7B8 + 4 * a1) + 4 * a2) + 6 * a3 + 4);
  pthread_mutex_unlock(&stru_7F7C0);
  return v7;
}
// 7F7B8: using guessed type int dword_7F7B8;

//----- (00014DD8) --------------------------------------------------------
int __fastcall sub_14DD8(int a1, int a2, int a3)
{
  int v6; // r0
  int v7; // r4

  if ( sub_1E29C(a1) )
    v6 = (unsigned int)a3 >> 31;
  else
    v6 = 1;
  if ( !v6 )
  {
    if ( a2 == 1 )
    {
      if ( sub_14434() > a3 )
      {
LABEL_9:
        pthread_mutex_lock(&stru_7F7C0);
        v7 = *(__int16 *)(*(_DWORD *)(*(_DWORD *)(dword_7F7B8 + 4 * a1) + 4 * a2) + 6 * a3 + 2);
        pthread_mutex_unlock(&stru_7F7C0);
        return v7;
      }
    }
    else if ( a2 == 2 )
    {
      if ( sub_14434() > a3 && sub_1E170() )
        goto LABEL_9;
    }
    else if ( a2 || sub_1E19C() > a3 )
    {
      goto LABEL_9;
    }
  }
  return 255;
}
// 7F7B8: using guessed type int dword_7F7B8;

//----- (00014E90) --------------------------------------------------------
const char *__fastcall sub_14E90(int a1, int a2)
{
  if ( a2 )
    return *(const char **)&aReadSensorOnAs[16 * **(__int16 **)(*(_DWORD *)(dword_7F7B8 + 4 * a1) + 4 * a2) + 20];
  else
    return "LM75A";
}
// 7F7B8: using guessed type int dword_7F7B8;

//----- (00014ED0) --------------------------------------------------------
int __fastcall sub_14ED0(int a1)
{
  int v2; // r4
  int v3; // r3

  v2 = 0;
  while ( sub_14434() > v2 )
  {
    v3 = *(_DWORD *)(dword_7F7B4 + 4 * v2++);
    if ( v3 == a1 && sub_1E170() )
      return 1;
  }
  return 0;
}
// 7F7B4: using guessed type int dword_7F7B4;

//----- (00014F20) --------------------------------------------------------
int sub_14F20()
{
  int i; // r5
  int j; // r4

  for ( i = 0; i != 4; ++i )
  {
    if ( sub_1E29C(i) )
    {
      for ( j = 0; sub_14434() > j; ++j )
      {
        if ( sub_1E170() )
        {
          sub_51164((unsigned __int8)i, (unsigned __int8)(*(_DWORD *)(dword_7F7B4 + 4 * j) * dword_7F7B0));
          usleep(0x2710u);
        }
      }
    }
  }
  return 0;
}
// 7F7B0: using guessed type int dword_7F7B0;
// 7F7B4: using guessed type int dword_7F7B4;

//----- (00014FA4) --------------------------------------------------------
int sub_14FA4()
{
  int v0; // r4
  int v1; // r6
  int v2; // r8
  char *v3; // r9
  _DWORD *v4; // r4
  char *v5; // r0
  _DWORD *v6; // r3
  int v7; // r2
  char *v8; // r4
  _DWORD *v9; // r6
  char *v10; // r1
  int v11; // r12
  int v12; // r4
  int v13; // r0
  int v14; // r6
  int v15; // r0
  int v16; // r4
  pthread_attr_t v18[57]; // [sp+0h] [bp-820h] BYREF

  v0 = sub_14434();
  if ( v0 <= sub_1E19C() )
    v1 = sub_1E19C();
  else
    v1 = sub_14434();
  if ( (unsigned int)dword_7EB9C > 3 )
  {
    snprintf(v18[0].__size, 0x800u, "max sensor num = %d", v1);
    sub_2E584(3, v18[0].__size, 0);
  }
  v2 = 72 * v1;
  v3 = (char *)malloc(0x10u);
  dword_7F7B8 = (int)v3;
  v4 = malloc(0x30u);
  v5 = (char *)calloc(72 * v1, 1u);
  v6 = v4;
  v7 = 6 * v1;
  v8 = v3 - 4;
  v9 = v6 + 12;
  v10 = v5;
  do
  {
    *((_DWORD *)v8 + 1) = v6;
    v8 += 4;
    v11 = (int)&v10[v7 + v7];
    *v6 = v10;
    v6[1] = &v10[v7];
    v6[2] = v11;
    v6 += 3;
    v10 = (char *)(v7 + v11);
  }
  while ( v9 != v6 );
  v12 = 0;
  dword_7F7D8 = (int)&v5[v2];
  v13 = sub_14434();
  dword_7F7B4 = (int)malloc(4 * v13);
  while ( sub_14434() > v12 )
  {
    v14 = dword_7F7B4;
    *(_DWORD *)(v14 + 4 * v12) = sub_1E180(v12);
    ++v12;
  }
  v15 = sub_1E19C();
  v16 = 0;
  dword_7F7DC = (int)malloc(v15);
  while ( sub_1E19C() > v16 )
  {
    *(_BYTE *)(dword_7F7DC + v16) = sub_1E1AC(v16);
    ++v16;
  }
  pthread_attr_init(v18);
  pthread_attr_setstacksize(v18, 0x100000u);
  dword_7F7E0 = 1;
  pthread_create(&newthread, v18, (void *(*)(void *))sub_1585C, 0);
  return pthread_detach(newthread);
}
// 7EB9C: using guessed type int dword_7EB9C;
// 7F7B4: using guessed type int dword_7F7B4;
// 7F7B8: using guessed type int dword_7F7B8;
// 7F7D8: using guessed type int dword_7F7D8;
// 7F7DC: using guessed type int dword_7F7DC;
// 7F7E0: using guessed type int dword_7F7E0;

//----- (00015150) --------------------------------------------------------
int sub_15150()
{
  int result; // r0
  char v1[2064]; // [sp+0h] [bp-810h] BYREF

  if ( dword_7F7E0 )
  {
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      strcpy(v1, "uninit_temp_info");
      result = sub_2E584(3, v1, 0);
      dword_7F7E0 = 0;
      if ( (unsigned int)dword_7EB9C > 3 )
      {
        strcpy(v1, "do not read temp anymore...");
        return sub_2E584(3, v1, 0);
      }
    }
    else
    {
      dword_7F7E0 = 0;
    }
  }
  return result;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 7F7E0: using guessed type int dword_7F7E0;

//----- (00015210) --------------------------------------------------------
int __fastcall sub_15210(int a1)
{
  int result; // r0
  int v3; // r4
  char v4[2064]; // [sp+0h] [bp-810h] BYREF

  result = sub_1E170();
  if ( result )
  {
    v3 = 0;
    pthread_mutex_lock(&stru_7F7C0);
    dword_7F7B0 = a1;
    sub_14F20();
    while ( !sub_1E29C(v3) || !sub_146C8(v3) )
    {
      if ( ++v3 == 4 )
      {
        dword_7F7BC = 1;
        pthread_mutex_unlock(&stru_7F7C0);
        return 0;
      }
    }
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      snprintf(v4, 0x800u, "calibration sensor on chain %d failed", v3);
      sub_2E584(3, v4, 0);
    }
    dword_7F7BC = 1;
    pthread_mutex_unlock(&stru_7F7C0);
    return -1;
  }
  return result;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 7F7B0: using guessed type int dword_7F7B0;
// 7F7BC: using guessed type int dword_7F7BC;

//----- (000152F0) --------------------------------------------------------
int __fastcall sub_152F0(int a1, int a2)
{
  const char *v4; // r0
  const char *v5; // r0

  v4 = (const char *)sub_1E0C0();
  if ( !strcmp(v4, "BHB28601") )
    return sub_14CC0(a1, 1, a2);
  v5 = (const char *)sub_1E0C0();
  if ( !strcmp(v5, "BHB28501") )
    return sub_14CC0(a1, 1, a2);
  else
    return sub_14CC0(a1, 0, a2);
}

//----- (00015354) --------------------------------------------------------
int __fastcall sub_15354(int a1, int a2)
{
  int result; // r0

  if ( sub_1E170() )
    return sub_14CC0(a1, 1, a2);
  result = sub_152F0(a1, a2);
  if ( result != 255 )
    return (__int16)(result + 10);
  return result;
}

//----- (000153A0) --------------------------------------------------------
int __fastcall sub_153A0(int a1, int a2)
{
  int result; // r0

  if ( sub_1E170() )
    return sub_14CC0(a1, 2, a2);
  result = sub_152F0(a1, a2);
  if ( result != 255 )
    return (__int16)(result + 15);
  return result;
}

//----- (000153EC) --------------------------------------------------------
int __fastcall sub_153EC(int a1, unsigned int a2)
{
  int v4; // r0
  int v5; // r5
  int v7; // r8
  int i; // r4
  int v9; // r0

  v4 = sub_1E29C(a1) == 0;
  if ( a2 > 2 )
    v4 |= 1u;
  if ( v4 )
    return 255;
  v7 = a2 ? sub_14434() : sub_1E19C();
  if ( v7 <= 0 )
    return 255;
  v5 = 255;
  for ( i = 0; i != v7; ++i )
  {
    if ( a2 )
    {
      if ( a2 == 1 )
        v9 = sub_15354(a1, (unsigned __int8)i);
      else
        v9 = sub_153A0(a1, (unsigned __int8)i);
    }
    else
    {
      v9 = sub_152F0(a1, (unsigned __int8)i);
    }
    if ( v9 != 255 )
    {
      if ( v5 == 255 )
      {
        v5 = v9;
      }
      else if ( v5 < v9 )
      {
        v5 = v9;
      }
    }
  }
  return v5;
}

//----- (000154A8) --------------------------------------------------------
int __fastcall sub_154A8(int a1)
{
  const char *v2; // r0
  const char *v3; // r0

  v2 = (const char *)sub_1E0C0();
  if ( !strcmp(v2, "BHB28601") )
    return (__int16)sub_153EC(a1, 1u);
  v3 = (const char *)sub_1E0C0();
  if ( !strcmp(v3, "BHB28501") )
    return (__int16)sub_153EC(a1, 1u);
  else
    return (__int16)sub_153EC(a1, 0);
}

//----- (00015508) --------------------------------------------------------
int sub_15508()
{
  int v0; // r4
  int v1; // r5
  int v2; // r0

  v0 = 0;
  v1 = 255;
  do
  {
    v2 = sub_154A8(v0);
    if ( v2 != 255 )
    {
      if ( v1 == 255 )
      {
        v1 = v2;
      }
      else
      {
        if ( v2 >= v1 )
          LOWORD(v1) = v2;
        v1 = (__int16)v1;
      }
    }
    ++v0;
  }
  while ( v0 != 4 );
  return v1;
}

//----- (00015550) --------------------------------------------------------
int __fastcall sub_15550(int a1)
{
  return (__int16)sub_153EC(a1, 1u);
}

//----- (00015564) --------------------------------------------------------
int sub_15564()
{
  int v0; // r4
  int v1; // r5
  __int16 v2; // r0

  v0 = 0;
  v1 = 255;
  do
  {
    v2 = sub_153EC(v0, 1u);
    if ( v2 != 255 )
    {
      if ( v1 == 255 )
      {
        v1 = v2;
      }
      else if ( v2 >= v1 )
      {
        v1 = v2;
      }
    }
    ++v0;
  }
  while ( v0 != 4 );
  return v1;
}

//----- (000155B0) --------------------------------------------------------
int __fastcall sub_155B0(int a1)
{
  return (__int16)sub_153EC(a1, 2u);
}

//----- (000155C4) --------------------------------------------------------
int sub_155C4()
{
  int v0; // r4
  int v1; // r5
  __int16 v2; // r0

  v0 = 0;
  v1 = 255;
  do
  {
    v2 = sub_153EC(v0, 2u);
    if ( v2 != 255 )
    {
      if ( v1 == 255 )
      {
        v1 = v2;
      }
      else if ( v2 >= v1 )
      {
        v1 = v2;
      }
    }
    ++v0;
  }
  while ( v0 != 4 );
  return v1;
}

//----- (00015610) --------------------------------------------------------
int __fastcall sub_15610(int a1, unsigned int a2)
{
  int v4; // r0
  int v5; // r5
  int v7; // r8
  int i; // r4
  int v9; // r0

  v4 = sub_1E29C(a1) == 0;
  if ( a2 > 2 )
    v4 |= 1u;
  if ( v4 )
    return 255;
  v7 = a2 ? sub_14434() : sub_1E19C();
  if ( v7 <= 0 )
    return 255;
  v5 = 255;
  for ( i = 0; i != v7; ++i )
  {
    if ( a2 )
    {
      if ( a2 == 1 )
        v9 = sub_15354(a1, (unsigned __int8)i);
      else
        v9 = sub_153A0(a1, (unsigned __int8)i);
    }
    else
    {
      v9 = sub_152F0(a1, (unsigned __int8)i);
    }
    if ( v9 != 255 )
    {
      if ( v5 == 255 )
      {
        v5 = v9;
      }
      else if ( v5 >= v9 )
      {
        v5 = v9;
      }
    }
  }
  return v5;
}

//----- (000156CC) --------------------------------------------------------
int __fastcall sub_156CC(int a1)
{
  const char *v2; // r0
  const char *v3; // r0

  v2 = (const char *)sub_1E0C0();
  if ( !strcmp(v2, "BHB28601") )
    return (__int16)sub_15610(a1, 1u);
  v3 = (const char *)sub_1E0C0();
  if ( !strcmp(v3, "BHB28501") )
    return (__int16)sub_15610(a1, 1u);
  else
    return (__int16)sub_15610(a1, 0);
}

//----- (0001572C) --------------------------------------------------------
int sub_1572C()
{
  int v0; // r5
  int v1; // r4
  int v2; // r0
  int v3; // r0

  v0 = 0;
  v1 = 255;
  do
  {
    v2 = v0++;
    v3 = sub_156CC(v2);
    if ( v3 < v1 )
      LOWORD(v1) = v3;
    v1 = (__int16)v1;
  }
  while ( v0 != 4 );
  return (__int16)v1;
}

//----- (00015760) --------------------------------------------------------
int __fastcall sub_15760(int a1)
{
  return (__int16)sub_15610(a1, 1u);
}

//----- (00015774) --------------------------------------------------------
int sub_15774()
{
  int v0; // r4
  int v1; // r5
  __int16 v2; // r0

  v0 = 0;
  v1 = 255;
  do
  {
    v2 = sub_15610(v0++, 1u);
    if ( v2 < v1 )
      v1 = v2;
  }
  while ( v0 != 4 );
  return v1;
}

//----- (000157AC) --------------------------------------------------------
int __fastcall sub_157AC(int a1)
{
  return (__int16)sub_15610(a1, 2u);
}

//----- (000157C0) --------------------------------------------------------
int sub_157C0()
{
  int v0; // r4
  int v1; // r5
  __int16 v2; // r0

  v0 = 0;
  v1 = 255;
  do
  {
    v2 = sub_15610(v0++, 2u);
    if ( v2 < v1 )
      v1 = v2;
  }
  while ( v0 != 4 );
  return v1;
}
// 157C0: using guessed type int sub_157C0();

//----- (000157F8) --------------------------------------------------------
int __fastcall sub_157F8(int a1, int a2)
{
  const char *v4; // r0
  const char *v5; // r0

  v4 = (const char *)sub_1E0C0();
  if ( !strcmp(v4, "BHB28601") )
    return sub_14D60(a1, 1, a2);
  v5 = (const char *)sub_1E0C0();
  if ( !strcmp(v5, "BHB28501") )
    return sub_14D60(a1, 1, a2);
  else
    return sub_14D60(a1, 0, a2);
}

//----- (0001585C) --------------------------------------------------------
int sub_1585C()
{
  int v0; // r9
  int v1; // r4
  const char *v2; // r0
  _BOOL4 v3; // r5
  int v4; // r4
  int v5; // r6
  int v6; // r5
  int v7; // r12
  int v8; // r3
  __int64 v9; // r0
  int v10; // r2
  const char *v11; // r3
  int v12; // r12
  int v13; // r2
  int v14; // r8
  int v15; // r0
  int v16; // r7
  int v17; // r6
  int v18; // r5
  int v19; // r4
  int v20; // r8
  int v21; // r2
  int v22; // r5
  int v23; // r4
  const char *v24; // r0
  const char *v25; // r12
  _DWORD *v26; // r0
  int v27; // r5
  int v28; // r6
  int v29; // r7
  int v30; // r4
  int v31; // r8
  char v32; // r0
  int v33; // r5
  char v34; // r0
  const char *v35; // r0
  int v36; // r6
  const char *v38; // r0
  int v39; // r3
  int v40; // r4
  size_t v41; // r0
  int v42; // r4
  size_t v43; // r0
  const char *v44; // r0
  int v45; // r0
  bool v46; // zf
  int v47; // r4
  int v48; // r6
  int v49; // r0
  int v50; // r0
  bool v51; // nf
  int v52; // r3
  int v53; // r12
  int i; // [sp+1Ch] [bp-86Ch]
  int v55; // [sp+20h] [bp-868h]
  int v56; // [sp+20h] [bp-868h]
  int v57; // [sp+2Ch] [bp-85Ch]
  __time_t v58; // [sp+40h] [bp-848h] BYREF
  int v59; // [sp+44h] [bp-844h]
  __time_t v60; // [sp+48h] [bp-840h] BYREF
  int v61; // [sp+4Ch] [bp-83Ch]
  _DWORD v62[4]; // [sp+50h] [bp-838h] BYREF
  char v63[2088]; // [sp+60h] [bp-828h] BYREF

  prctl(15, "temp_mtr", 0, 0, 0);
  if ( (unsigned int)dword_7EB9C > 3 )
  {
    strcpy(v63, "temperature_monitor_thread start...");
    sub_2E584(3, v63, 0);
    if ( dword_7F7E0 )
      goto LABEL_3;
LABEL_66:
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      strcpy(v63, "temp monitor thread exit");
      sub_2E584(3, v63, 0);
    }
  }
  else if ( dword_7F7E0 )
  {
LABEL_3:
    v57 = 0;
    while ( 1 )
    {
      for ( i = 0; i != 4; ++i )
      {
        if ( !sub_1E29C(i) )
          continue;
        v0 = 0;
        while ( 2 )
        {
          v1 = sub_14434();
          if ( v1 > sub_1E19C() )
          {
            if ( v0 >= sub_14434() )
              goto LABEL_36;
LABEL_9:
            v2 = (const char *)sub_1E0C0();
            if ( !strcmp(v2, "BHB28601") )
            {
              v3 = 1;
            }
            else
            {
              v38 = (const char *)sub_1E0C0();
              v3 = strcmp(v38, "BHB28501") == 0;
            }
            v4 = v3 + 1;
            v5 = v3;
            v46 = !v3;
            v6 = 4 * v3;
            v55 = 6 * v0;
            if ( !v46 )
            {
LABEL_13:
              if ( !dword_7F7BC )
                goto LABEL_29;
LABEL_14:
              if ( !dword_7F7E8 && sub_14434() > v0 )
              {
                pthread_mutex_lock(&stru_7F7EC);
                sub_302A0(&v58);
                if ( v5 == 1 )
                {
                  v57 = sub_14454(i, v0, *(__int16 *)(*(_DWORD *)(*(_DWORD *)(dword_7F7B8 + 4 * i) + 4) + 6 * v0), 0);
                }
                else if ( v5 == 2 )
                {
                  v57 = sub_14454(i, v0, *(__int16 *)(*(_DWORD *)(*(_DWORD *)(dword_7F7B8 + 4 * i) + 8) + 6 * v0), 1);
                }
                sub_302A0(&v60);
                v7 = v60 - v58;
                v8 = v61 - v59;
                if ( v61 - v59 < 0 )
                {
                  --v7;
                  v8 += 1000000;
                }
                if ( (unsigned int)dword_7EB9C > 4 )
                {
                  v9 = 274877907LL * v8;
                  v10 = v8 >> 31;
                  v11 = "pcb";
                  v12 = (SHIDWORD(v9) >> 6) - v10 + 1000 * v7;
                  if ( v5 != 1 )
                    v11 = "chp";
                  snprintf(v63, 0x800u, "%s read %d on chain %d takes %ldms\n", v11, v0, i, v12);
                  sub_2E584(4, v63, 0);
                }
                pthread_mutex_unlock(&stru_7F7EC);
                goto LABEL_26;
              }
              goto LABEL_29;
            }
            while ( 2 )
            {
              if ( sub_1E19C() <= v0 )
              {
                if ( dword_7F7BC )
                  goto LABEL_14;
LABEL_30:
                ++v4;
                v6 += 4;
                v5 = v4 - 1;
                if ( v4 != 1 )
                  goto LABEL_13;
                continue;
              }
              break;
            }
            sub_302A0(&v58);
            if ( !sub_1E29C(i) )
            {
              if ( (unsigned int)dword_7EB9C <= 4 )
                goto LABEL_98;
              snprintf(v63, 0x800u, "%s chain %d not pluged", "read_sensor_on_pic", i);
              v57 = 255;
              sub_2E584(4, v63, 0);
LABEL_99:
              sub_302A0(&v60);
              v52 = v61 - v59 + (v61 - v59 < 0 ? 0xF4000 : 0);
              v53 = v60 - v58;
              if ( v61 - v59 < 0 )
              {
                --v53;
                v52 += 576;
              }
              if ( (unsigned int)dword_7EB9C > 4 )
              {
                snprintf(v63, 0x800u, "pic read %d on chain %d takes %ldms\n", v0, i, v52 / 1000 + 1000 * v53);
                sub_2E584(4, v63, 0);
              }
LABEL_26:
              pthread_mutex_lock(&stru_7F7C0);
              if ( v57 == 255 )
              {
                v39 = *(_DWORD *)(*(_DWORD *)(dword_7F7B8 + 4 * i) + v6) + v55;
                ++*(_WORD *)(v39 + 4);
              }
              else
              {
                v13 = dword_7F7B8;
                *(_WORD *)(*(_DWORD *)(*(_DWORD *)(dword_7F7B8 + 4 * i) + v6) + v55 + 2) = v57;
                *(_WORD *)(*(_DWORD *)(*(_DWORD *)(v13 + 4 * i) + v6) + v55 + 4) = 0;
              }
              pthread_mutex_unlock(&stru_7F7C0);
LABEL_29:
              if ( v4 == 3 )
              {
                ++v0;
                continue;
              }
              goto LABEL_30;
            }
            if ( v0 < sub_1E19C() )
            {
              if ( sub_48110((unsigned __int8)i, *(unsigned __int8 *)(dword_7F7DC + v0), v5, v62, 2) == 2 )
              {
                v57 = SLOBYTE(v62[0]);
                goto LABEL_99;
              }
              if ( (unsigned int)dword_7EB9C > 3 )
              {
                v57 = 255;
                snprintf(v63, 0x800u, "fail to read pic temp for chain %d", i);
                sub_2E584(3, v63, v5);
                goto LABEL_99;
              }
            }
            else if ( (unsigned int)dword_7EB9C > 3 )
            {
              v57 = 255;
              snprintf(v63, 0x800u, "%s invalid index = %d on chain %d", "read_sensor_on_pic", v0, i);
              sub_2E584(3, v63, v5);
              goto LABEL_99;
            }
LABEL_98:
            v57 = 255;
            goto LABEL_99;
          }
          break;
        }
        if ( v0 < sub_1E19C() )
          goto LABEL_9;
LABEL_36:
        v62[0] = "pic";
        v62[1] = "pcb";
        v62[2] = "chp";
        v62[3] = "max";
        memset(v63, 0, 0x100u);
        if ( !dword_7F804 )
        {
          v42 = sub_14434();
          if ( v42 <= sub_1E19C() )
            v43 = 4 * sub_1E19C() + 1;
          else
            v43 = 4 * sub_14434() + 1;
          dword_7F804 = (int)malloc(v43);
        }
        if ( !dword_7F808 )
        {
          v40 = sub_14434();
          if ( v40 <= sub_1E19C() )
            v41 = 4 * sub_1E19C() + 1;
          else
            v41 = 4 * sub_14434() + 1;
          dword_7F808 = (int)malloc(v41);
        }
        v14 = 0;
        pthread_mutex_lock(&stru_7F7C0);
        do
        {
          if ( v14 )
          {
            if ( !dword_7F7B0 )
              break;
            v15 = sub_14434();
          }
          else
          {
            v15 = sub_1E19C();
          }
          if ( v15 <= 0 )
          {
            v23 = -1;
            v22 = -1;
          }
          else
          {
            v16 = 0;
            v17 = 4 * v14;
            v56 = v14;
            v18 = 0;
            v19 = 0;
            v20 = 6 * v15;
            do
            {
              v19 += sprintf(
                       (char *)(dword_7F804 + v19),
                       "%03d-",
                       *(__int16 *)(*(_DWORD *)(*(_DWORD *)(dword_7F7B8 + 4 * i) + v17) + v16 + 2));
              v21 = *(_DWORD *)(*(_DWORD *)(dword_7F7B8 + 4 * i) + v17) + v16;
              v16 += 6;
              v18 += sprintf((char *)(dword_7F808 + v18), "%03d-", *(__int16 *)(v21 + 4));
            }
            while ( v20 != v16 );
            v14 = v56;
            v22 = v18 - 1;
            v23 = v19 - 1;
          }
          v24 = (const char *)dword_7F808;
          v25 = (const char *)dword_7F804;
          *(_BYTE *)(dword_7F808 + v22) = 32;
          v25[v23] = 32;
          sprintf(v63, "chain %d %s temp: %s, failure:%s", i, (const char *)v62[v14], v25, v24);
          v26 = (_DWORD *)dword_7F80C;
          if ( !dword_7F80C )
          {
            v26 = sub_536F4("bmminer_temp");
            dword_7F80C = (int)v26;
          }
          ++v14;
          sub_54CB0((int)v26, "temperature/temperature.c", 25, (int)"dump_temp_info", 14, 539, 20, (int)"%s", v63);
        }
        while ( v14 != 3 );
        pthread_mutex_unlock(&stru_7F7C0);
      }
      v27 = 0;
      v28 = 0;
      v29 = sub_15508();
      v30 = 0;
      v31 = sub_155C4();
      do
      {
        if ( sub_1E29C(v30) )
        {
          v28 = (unsigned __int8)(v28 + 1);
          v32 = sub_14434();
          v33 = sub_157F8(v30, (unsigned __int8)(v32 - 1)) + v27;
          v34 = sub_14434();
          v27 = sub_157F8(v30, (unsigned __int8)(v34 - 2)) + v33;
        }
        ++v30;
      }
      while ( v30 != 4 );
      v35 = (const char *)sub_1E0C0();
      if ( !strcmp(v35, "BHB28601") || (v44 = (const char *)sub_1E0C0(), !strcmp(v44, "BHB28501")) )
      {
        if ( !dword_7F7BC )
          goto LABEL_62;
        v36 = 2 * v28;
        if ( v29 <= 80 )
          goto LABEL_79;
LABEL_58:
        sub_20A20(1);
        if ( v27 >= v36 )
          goto LABEL_80;
        sub_20A38(0);
LABEL_60:
        if ( (unsigned int)dword_7EB9C > 3 )
          goto LABEL_81;
        goto LABEL_61;
      }
      v36 = 2 * v28;
      if ( v29 > 80 )
        goto LABEL_58;
LABEL_79:
      sub_20A20(0);
      if ( v27 < v36 )
      {
        sub_20A38(0);
        v45 = sub_31D48();
        v46 = v29 == 0;
        if ( !v29 )
          v46 = v45 == 2;
        if ( !v46 )
          goto LABEL_62;
        v47 = 255;
        v48 = 0;
        do
        {
          v49 = v48++;
          v50 = sub_156CC(v49);
          if ( v50 < v47 )
            LOWORD(v47) = v50;
          v47 = (__int16)v47;
        }
        while ( v48 != 4 );
        if ( (_WORD)v47 )
          goto LABEL_62;
        v51 = dword_7F810 - 9 < 0;
        ++dword_7F810;
        if ( v51 ^ __OFSUB__(dword_7F810, 10) | (dword_7F810 == 10) )
          goto LABEL_62;
        goto LABEL_60;
      }
LABEL_80:
      sub_20A38(1);
      if ( (unsigned int)dword_7EB9C > 3 )
      {
LABEL_81:
        snprintf(
          v63,
          0x800u,
          "over max temp, pcb temp %d (max %d), chip temp %d(max %d) pcb temp rise %d chip temp rise %d, total_exit_failure %d\n",
          v29,
          80,
          v31,
          95,
          0,
          0,
          v27);
        sub_2E584(3, v63, 0);
      }
LABEL_61:
      sub_31D58(0xFu, "over max temp");
LABEL_62:
      sub_13DA4(0x190u, 0);
      if ( sub_31D38() && dword_80FB4 != 1 )
        sub_35344();
      usleep(0x2710u);
      if ( !dword_7F7E0 )
        goto LABEL_66;
    }
  }
  return 0;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 7F7B0: using guessed type int dword_7F7B0;
// 7F7B8: using guessed type int dword_7F7B8;
// 7F7BC: using guessed type int dword_7F7BC;
// 7F7DC: using guessed type int dword_7F7DC;
// 7F7E0: using guessed type int dword_7F7E0;
// 7F7E8: using guessed type int dword_7F7E8;
// 7F7EC: using guessed type pthread_mutex_t stru_7F7EC;
// 7F804: using guessed type int dword_7F804;
// 7F808: using guessed type int dword_7F808;
// 7F80C: using guessed type int dword_7F80C;
// 7F810: using guessed type int dword_7F810;
// 80FB4: using guessed type int dword_80FB4;

//----- (00016284) --------------------------------------------------------
int __fastcall sub_16284(int a1, int a2)
{
  return sub_14D60(a1, 1, a2);
}

//----- (00016290) --------------------------------------------------------
int __fastcall sub_16290(int a1, int a2)
{
  return sub_14D60(a1, 2, a2);
}

//----- (0001629C) --------------------------------------------------------
void sub_1629C()
{
  dword_7F7E8 = 1;
}
// 7F7E8: using guessed type int dword_7F7E8;

//----- (000162B0) --------------------------------------------------------
void sub_162B0()
{
  dword_7F7E8 = 0;
}
// 7F7E8: using guessed type int dword_7F7E8;

//----- (000162C4) --------------------------------------------------------
int __fastcall sub_162C4(int a1, int a2, int a3, unsigned __int8 a4)
{
  int v5; // r4
  char v6; // r5
  char v7; // r0
  bool v8; // cc
  int result; // r0
  unsigned __int8 v10; // [sp+Fh] [bp-19h] BYREF

  if ( !a2 )
    a4 = 4;
  if ( a2 )
    a4 = 68;
  v10 = a4;
  v5 = 0;
  while ( 1 )
  {
    v8 = sub_14434() <= v5;
    result = v5++;
    if ( v8 )
      break;
    v6 = sub_1E180(result);
    v7 = sub_1E160();
    sub_142BC(a1, (unsigned __int8)(v6 * v7), 9, 1, &v10);
  }
  return result;
}

//----- (00016330) --------------------------------------------------------
int __fastcall sub_16330(int a1)
{
  int v1; // r4
  int result; // r0
  int v4; // r2
  unsigned __int8 v5; // r3

  v1 = 0;
  result = sub_1E29C(0);
  if ( result )
    goto LABEL_4;
  while ( ++v1 != 4 )
  {
    result = sub_1E29C(v1);
    if ( result )
LABEL_4:
      result = sub_162C4(v1, a1, v4, v5);
  }
  return result;
}
// 16370: variable 'v4' is possibly undefined
// 16370: variable 'v5' is possibly undefined

//----- (00016378) --------------------------------------------------------
int sub_16378()
{
  int v0; // r4
  _DWORD *v1; // r6
  int result; // r0
  void *v3; // r8
  int v4; // r0
  int v5; // r8
  _DWORD *v6; // r4
  _BYTE *v7; // r3
  _BYTE *v8; // t1
  _BYTE *v9; // r3
  char v10[2072]; // [sp+0h] [bp-818h] BYREF

  if ( !dword_7F814 )
  {
    dword_7F814 = (int)calloc(1u, 0x20u);
    if ( !dword_7F814 )
    {
      if ( (unsigned int)dword_7EB9C > 3 )
      {
        strcpy(v10, "No memory for configuraion.\n");
        sub_2E584(3, v10, 0);
        v1 = (_DWORD *)dword_7F814;
        goto LABEL_11;
      }
      return -1;
    }
  }
  v0 = 0;
  while ( 1 )
  {
    if ( !sub_1E29C(v0) )
      goto LABEL_5;
    v1 = (_DWORD *)dword_7F814;
    if ( *(_DWORD *)(dword_7F814 + 4 * v0) )
      goto LABEL_5;
    v3 = calloc(1u, 0x48u);
    v1[v0] = v3;
    if ( !v3 )
      break;
    v4 = sub_1E0F0();
    v1 = (_DWORD *)dword_7F814;
    v5 = *(_DWORD *)(dword_7F814 + 4 * v0);
    *(_DWORD *)(v5 + 63) = calloc(v4, 1u);
    if ( !*(_DWORD *)(v1[v0] + 63) )
    {
      if ( (unsigned int)dword_7EB9C <= 3 )
        goto LABEL_11;
      goto LABEL_10;
    }
LABEL_5:
    if ( ++v0 == 4 )
      return 0;
  }
  if ( (unsigned int)dword_7EB9C > 3 )
  {
LABEL_10:
    snprintf(v10, 0x800u, "No memory for configuraion for chain %d.\n", v0);
    sub_2E584(3, v10, 0);
    v1 = (_DWORD *)dword_7F814;
  }
LABEL_11:
  if ( !v1 )
    return -1;
  v6 = v1 - 1;
  do
  {
    v8 = (_BYTE *)v6[1];
    ++v6;
    v7 = v8;
    if ( v8 )
    {
      if ( *(_DWORD *)(v7 + 63) )
      {
        free(*(void **)(v7 + 63));
        v9 = (_BYTE *)*v6;
        v9[63] = 0;
        v9[64] = 0;
        v9[65] = 0;
        v9[66] = 0;
        v7 = (_BYTE *)*v6;
      }
      free(v7);
      *v6 = 0;
    }
  }
  while ( v6 != v1 + 3 );
  free(v1);
  result = -1;
  dword_7F814 = 0;
  return result;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 7F814: using guessed type int dword_7F814;

//----- (00016580) --------------------------------------------------------
int sub_16580()
{
  unsigned int i; // r4
  _DWORD *v1; // r0
  _DWORD *v2; // r5
  int v3; // r4
  _DWORD *v4; // r0
  _DWORD *v5; // r8
  unsigned int v6; // r3
  const char *v8; // r2
  const char *v9; // r0
  char *v10; // r7
  const char *v11; // r0
  const char *v12; // r0
  _DWORD *v13; // r0
  _DWORD *v14; // r8
  int v15; // r9
  unsigned int v16; // r7
  _DWORD *v17; // r0
  unsigned int v18; // r1
  _BOOL4 v19; // r3
  _DWORD *v20; // r0
  _DWORD *v21; // r6
  _DWORD *v22; // r0
  int *v23; // r4
  _DWORD *v24; // r0
  int v25; // r7
  int v26; // r2
  int v27; // r3
  int *v28; // r3
  int v29; // r3
  unsigned int *v30; // r3
  unsigned int v31; // r2
  unsigned int v32; // r2
  char v33[252]; // [sp+1Ch] [bp-924h] BYREF
  char s[2088]; // [sp+118h] [bp-828h] BYREF

  for ( i = 0; i != 4; ++i )
  {
    if ( sub_1E29C(i) )
    {
      sub_440E8(i);
      sub_304D4();
    }
  }
  memset(dword_7F818, 0, 0xA0u);
  v1 = sub_4D6E4("/etc/levels.json", 0, v33);
  v2 = v1;
  if ( !v1 || *v1 )
  {
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      snprintf(s, 0x800u, "load vol-freq config file %s failed\n", "/etc/levels.json");
      sub_2E584(3, s, 0);
      return -1;
    }
    return -1;
  }
  v4 = (_DWORD *)sub_4E234(v1, "miner");
  v5 = v4;
  if ( v4 )
  {
    v6 = dword_7EB9C;
    if ( *v4 == 2 )
    {
      if ( (unsigned int)dword_7EB9C > 4 )
      {
        v12 = (const char *)sub_4E768(v4);
        snprintf(s, 0x800u, "miner type in %s is %s", "/etc/levels.json", v12);
        sub_2E584(4, s, 0);
      }
      v9 = (const char *)sub_4E768(v5);
      v10 = strstr(dest, v9);
      if ( !v10 || (v11 = (const char *)sub_4E768(v5), strcasecmp(v10, v11)) )
      {
        v3 = -3;
        if ( (unsigned int)dword_7EB9C > 3 )
        {
          strcpy(s, "miner type not match");
          sub_2E584(3, s, 0);
        }
        return v3;
      }
      v13 = (_DWORD *)sub_4E234(v2, "levels");
      v14 = v13;
      if ( v13 && *v13 == 1 )
      {
        v15 = 0;
        v16 = 0;
        while ( 1 )
        {
          v17 = sub_4E5A0(v14);
          v18 = v16;
          v19 = (unsigned int)v17 > v16;
          if ( v15 > 19 )
            v19 = 0;
          ++v16;
          if ( !v19 )
            break;
          v20 = sub_4E5BC(v14, v18);
          v21 = v20;
          if ( !*v2 )
          {
            v22 = (_DWORD *)sub_4E234(v20, "frequency");
            if ( v22 )
            {
              if ( *v22 == 3 )
              {
                v23 = &dword_7F814[2 * v15];
                v23[2] = sub_4E9C4((int)v22);
                v24 = (_DWORD *)sub_4E234(v21, "voltage");
                if ( v24 )
                {
                  if ( *v24 == 3 )
                  {
                    ++v15;
                    v23[1] = sub_4E9C4((int)v24);
                  }
                }
              }
            }
          }
        }
        v3 = 0;
        v25 = 0;
        do
        {
          v26 = dword_7F818[2 * v25];
          v27 = 2 * v25++;
          v28 = &dword_7F818[v27];
          if ( v26 )
          {
            v29 = v28[1];
            if ( v29 )
            {
              if ( (unsigned int)dword_7EB9C > 4 )
              {
                snprintf(s, 0x800u, "level %d, voltage = %d frequency = %d", v25, v26, v29);
                sub_2E584(4, s, 0);
              }
            }
          }
        }
        while ( v25 != 20 );
        if ( v2[1] != -1 )
        {
          v30 = v2 + 1;
          __dmb(0xBu);
          do
          {
            v31 = __ldrex(v30);
            v32 = v31 - 1;
          }
          while ( __strex(v32, v30) );
          if ( !v32 )
            sub_4EB6C(v2);
        }
        return v3;
      }
      if ( (unsigned int)dword_7EB9C <= 4 )
        return -2;
      v8 = "failed to get levels in %s\n";
LABEL_17:
      v3 = -2;
      snprintf(s, 0x800u, v8, "/etc/levels.json");
      sub_2E584(4, s, 0);
      return v3;
    }
  }
  else
  {
    v6 = dword_7EB9C;
  }
  if ( v6 > 4 )
  {
    v8 = "failed to get miner type in %s\n";
    goto LABEL_17;
  }
  return -2;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 7F814: using guessed type int dword_7F814[];
// 7F818: using guessed type int dword_7F818[];
// 16580: using guessed type char var_924[252];

//----- (0001697C) --------------------------------------------------------
int __fastcall sub_1697C(int a1)
{
  char v2[2056]; // [sp+0h] [bp-808h] BYREF

  snprintf(v2, 0x800u, "No chip bin, chain = %d\n", a1);
  sub_2E584(3, v2, 0);
  return -1;
}

//----- (000169C0) --------------------------------------------------------
int __fastcall sub_169C0(int a1)
{
  char v2[2056]; // [sp+0h] [bp-808h] BYREF

  snprintf(v2, 0x800u, "No ft ver, chain = %d\n", a1);
  sub_2E584(3, v2, 0);
  return -1;
}

//----- (00016A04) --------------------------------------------------------
int sub_16A04()
{
  unsigned int v0; // r4
  int v1; // r8
  int v3; // r6
  int v4; // r1
  size_t v5; // r2
  int v6; // r9
  int v7; // r7
  size_t v8; // r3
  const void *v9; // r1
  size_t v10; // r6
  unsigned int v11; // r6
  unsigned int v12; // r7
  char s[256]; // [sp+8h] [bp-928h] BYREF
  char v14[2088]; // [sp+108h] [bp-828h] BYREF

  if ( dword_7F814[0] && *(_BYTE *)(dword_7F814[0] + 28) )
  {
    v0 = 0;
    v1 = 0;
    do
    {
      if ( sub_1E29C(v0) )
      {
        memset(s, 0, sizeof(s));
        v3 = *(_DWORD *)(dword_7F814[0] + 4 * v0);
        if ( (unsigned int)dword_7EB9C > 3 )
        {
          snprintf(v14, 0x800u, "[chain %d] Update miner info in eeprom.\n", v0);
          sub_2E584(3, v14, 0);
        }
        v4 = *(unsigned __int8 *)(v3 + 1);
        v5 = *(unsigned __int8 *)(v3 + 56);
        v6 = 57 - v4;
        v7 = v4 + 5;
        v8 = v5 - (57 - v4);
        v9 = (const void *)(v3 + v4);
        v10 = v8 + 7;
        memcpy(s, v9, v5);
        v11 = v10 & 0xFFFFFFF8;
        v12 = (v7 & 0xFFFFFFF8) + 2;
        sub_18E48(&s[v6], v11, 1);
        if ( (int)(256 - v12) >= (int)(v6 + v11) )
        {
          sub_44200(v0, v12 & 0xFE, (int)s, v6 + v11);
        }
        else
        {
          v1 = -1;
          if ( (unsigned int)dword_7EB9C > 3 )
          {
            snprintf(v14, 0x800u, "[chain %d] Update miner info Failed, EEPROM does not have enough space.\n", v0);
            sub_2E584(3, v14, 0);
          }
        }
      }
      ++v0;
    }
    while ( v0 != 4 );
    return v1;
  }
  if ( (unsigned int)dword_7EB9C <= 3 )
    return -1;
  strcpy(v14, "No fixture configuration for flush.\n");
  sub_2E584(3, v14, 0);
  return -1;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 7F814: using guessed type int dword_7F814[];
// 16A04: using guessed type char s[256];

//----- (00016BD8) --------------------------------------------------------
_BYTE *__fastcall sub_16BD8(_BYTE *result)
{
  unsigned __int8 *v1; // r5
  char s[2]; // [sp+10h] [bp-810h] BYREF

  if ( (unsigned int)dword_7EB9C > 3 )
  {
    v1 = result;
    snprintf(s, 0x800u, "%-30s : 0x%04x\n", "key_version", *result & 0xF);
    result = (_BYTE *)sub_2E584(3, s, 0);
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      snprintf(s, 0x800u, "%-30s : 0x%04x\n", "algorithm_code", *v1 >> 4);
      result = (_BYTE *)sub_2E584(3, s, 0);
      if ( (unsigned int)dword_7EB9C <= 3 )
        return result;
      snprintf(s, 0x800u, "%-30s : 0x%04x\n", "fixture_info_len", v1[1]);
      result = (_BYTE *)sub_2E584(3, s, 0);
      if ( (unsigned int)dword_7EB9C <= 3 )
        goto LABEL_11;
      snprintf(s, 0x800u, "%-30s : 0x%04x\n", "fixture_standard", v1[45]);
      result = (_BYTE *)sub_2E584(3, s, 0);
      if ( (unsigned int)dword_7EB9C <= 3 )
        return result;
      snprintf(s, 0x800u, "%-30s : 0x%04x\n", "test_standard", v1[46]);
      result = (_BYTE *)sub_2E584(3, s, 0);
    }
    if ( (unsigned int)dword_7EB9C <= 3 )
      goto LABEL_14;
    snprintf(s, 0x800u, "%-30s : %s\n", "chip_technology", *(const char **)(v1 + 31));
    result = (_BYTE *)sub_2E584(3, s, 0);
    if ( (unsigned int)dword_7EB9C <= 3 )
      return result;
    snprintf(s, 0x800u, "%-30s : 0x%02x\n", "fixture_fmt_version", v1[2]);
    result = (_BYTE *)sub_2E584(3, s, 0);
LABEL_11:
    if ( (unsigned int)dword_7EB9C <= 3 )
      goto LABEL_17;
    snprintf(s, 0x800u, "%-30s : %s\n", "SN", *(const char **)(v1 + 3));
    result = (_BYTE *)sub_2E584(3, s, 0);
    if ( (unsigned int)dword_7EB9C <= 3 )
      return result;
    snprintf(s, 0x800u, "%-30s : 0x%02x-%02x\n", "pcb", v1[27], v1[28]);
    result = (_BYTE *)sub_2E584(3, s, 0);
LABEL_14:
    if ( (unsigned int)dword_7EB9C <= 3 )
      goto LABEL_20;
    snprintf(s, 0x800u, "%-30s : 0x%02x-%02x\n", "bom", v1[29], v1[30]);
    result = (_BYTE *)sub_2E584(3, s, 0);
    if ( (unsigned int)dword_7EB9C <= 3 )
      return result;
    snprintf(s, 0x800u, "%-30s : %u\n", "hash_board_voltage", *(unsigned __int16 *)(v1 + 35));
    result = (_BYTE *)sub_2E584(3, s, 0);
LABEL_17:
    if ( (unsigned int)dword_7EB9C <= 3 )
      goto LABEL_23;
    snprintf(s, 0x800u, "%-30s : %u\n", "hash_board_freq", *(unsigned __int16 *)(v1 + 37));
    result = (_BYTE *)sub_2E584(3, s, 0);
    if ( (unsigned int)dword_7EB9C <= 3 )
      return result;
    snprintf(s, 0x800u, "%-30s : %.2f\n", "nonce_response_rate", *(float *)(v1 + 39));
    result = (_BYTE *)sub_2E584(3, s, 0);
LABEL_20:
    if ( (unsigned int)dword_7EB9C <= 3 )
      goto LABEL_26;
    snprintf(s, 0x800u, "%-30s : %u\n", "inlet_temperature", v1[43]);
    result = (_BYTE *)sub_2E584(3, s, 0);
    if ( (unsigned int)dword_7EB9C <= 3 )
      return result;
    snprintf(s, 0x800u, "%-30s : %u\n", "outlet_temperature", v1[44]);
    result = (_BYTE *)sub_2E584(3, s, 0);
LABEL_23:
    if ( (unsigned int)dword_7EB9C <= 3 )
      goto LABEL_29;
    snprintf(s, 0x800u, "%-30s : 0x%02x-%02x\n", "asic sensor", v1[20] >> 7, v1[20] & 0x7F);
    result = (_BYTE *)sub_2E584(3, s, 0);
    if ( (unsigned int)dword_7EB9C <= 3 )
      return result;
    snprintf(
      s,
      0x800u,
      "%-30s : 0x%02x-%02x-%02x-%02x\n",
      "asic sensor addr",
      **(unsigned __int8 **)(v1 + 21),
      *(unsigned __int8 *)(*(_DWORD *)(v1 + 21) + 1),
      *(unsigned __int8 *)(*(_DWORD *)(v1 + 21) + 2),
      *(unsigned __int8 *)(*(_DWORD *)(v1 + 21) + 3));
    result = (_BYTE *)sub_2E584(3, s, 0);
LABEL_26:
    if ( (unsigned int)dword_7EB9C <= 3 )
      goto LABEL_32;
    snprintf(s, 0x800u, "%-30s : 0x%02x-%02x\n", "pic sensor", v1[25] >> 7, v1[25] & 0x7F);
    result = (_BYTE *)sub_2E584(3, s, 0);
    if ( (unsigned int)dword_7EB9C <= 3 )
      return result;
    snprintf(s, 0x800u, "%-30s : 0x%02x\n", "pic sensor addr", v1[26]);
    result = (_BYTE *)sub_2E584(3, s, 0);
LABEL_29:
    if ( (unsigned int)dword_7EB9C <= 3 )
      goto LABEL_35;
    snprintf(s, 0x800u, "%-30s : bin%d\n", "chip_bin", v1[15]);
    result = (_BYTE *)sub_2E584(3, s, 0);
    if ( (unsigned int)dword_7EB9C <= 3 )
      return result;
    snprintf(s, 0x800u, "%-30s : %s\n", "FT", *((const char **)v1 + 4));
    result = (_BYTE *)sub_2E584(3, s, 0);
LABEL_32:
    if ( (unsigned int)dword_7EB9C <= 3 )
      return result;
    snprintf(s, 0x800u, "%-30s : %s\n", "chip_die", *(const char **)(v1 + 7));
    result = (_BYTE *)sub_2E584(3, s, 0);
    if ( (unsigned int)dword_7EB9C <= 3 )
      return result;
    snprintf(s, 0x800u, "%-30s : %s\n", "chip_marking", *(const char **)(v1 + 11));
    result = (_BYTE *)sub_2E584(3, s, 0);
LABEL_35:
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      strcpy(s, "\n");
      return (_BYTE *)sub_2E584(3, s, 0);
    }
  }
  return result;
}
// 7EB9C: using guessed type int dword_7EB9C;

//----- (00017244) --------------------------------------------------------
char *__fastcall sub_17244(char *result, int a2, unsigned int a3)
{
  unsigned int v4; // r1
  unsigned int v5; // r4
  int v6; // r5
  char s[2088]; // [sp+8h] [bp-828h] BYREF

  v4 = dword_7EB9C;
  if ( (unsigned int)dword_7EB9C > 3 )
  {
    snprintf(s, 0x800u, "[chain %d]\n", result);
    result = (char *)sub_2E584(3, s, 0);
    v4 = dword_7EB9C;
    if ( a3 )
      goto LABEL_3;
LABEL_15:
    if ( v4 > 3 )
    {
      strcpy(s, "\n");
      return sub_2EA54(3, s, 0);
    }
  }
  else if ( a3 )
  {
LABEL_3:
    v5 = 0;
    while ( 1 )
    {
      while ( 1 )
      {
        v6 = v5 & 0xF;
        if ( (v5 & 0xF) != 0 )
          break;
        if ( v4 > 3 )
        {
          snprintf(s, 0x800u, "0x%04X ", v5);
          result = sub_2EA54(3, s, v5 & 0xF);
          v4 = dword_7EB9C;
        }
LABEL_6:
        if ( v4 > 3 )
          goto LABEL_12;
LABEL_7:
        if ( a3 <= ++v5 )
          goto LABEL_15;
      }
      if ( v6 != 8 )
        goto LABEL_6;
      if ( v4 <= 3 )
        goto LABEL_7;
      strcpy(s, "  ");
      result = sub_2EA54(3, s, 0);
      v4 = dword_7EB9C;
      if ( (unsigned int)dword_7EB9C <= 3 )
        goto LABEL_7;
LABEL_12:
      snprintf(s, 0x800u, "%02X ", *(unsigned __int8 *)(a2 + v5));
      result = sub_2EA54(3, s, 0);
      v4 = dword_7EB9C;
      if ( v6 != 15 || (unsigned int)dword_7EB9C <= 3 )
        goto LABEL_7;
      ++v5;
      strcpy(s, "\n");
      result = sub_2EA54(3, s, 0);
      v4 = dword_7EB9C;
      if ( a3 <= v5 )
        goto LABEL_15;
    }
  }
  return result;
}
// 173A4: conditional instruction was optimized away because r5.4==0
// 7EB9C: using guessed type int dword_7EB9C;

//----- (0001740C) --------------------------------------------------------
int __fastcall sub_1740C(unsigned int a1, int a2)
{
  int v4; // r9
  int v5; // r6
  int v6; // r7
  size_t v7; // r4
  _BOOL4 v8; // r12
  unsigned int v9; // r3
  int v11; // r2
  bool v12; // zf
  char v13; // r6
  char v14; // r3
  int v15; // r3
  unsigned int v16; // r2
  size_t v17; // r10
  int v18; // r3
  int v19; // r11
  int v20; // r4
  _DWORD *v21; // r12
  int v22; // r6
  int v23; // lr
  int v24; // r2
  _WORD *v25; // r12
  _DWORD *v26; // r12
  int v27; // r2
  int v28; // r1
  int v29; // r3
  bool v30; // cf
  void *v31; // r12
  _DWORD *v32; // r12
  _WORD *v33; // r12
  float v34; // s12
  _DWORD *v35; // r0
  _DWORD *v36; // r12
  bool v37; // zf
  int v38; // r1
  char v39; // r2
  int v40; // r0
  int v41; // r3
  char *v42; // r0
  char *v43; // r8
  int v44; // r1
  char v46; // [sp+14h] [bp-B6Ch]
  int v47; // [sp+14h] [bp-B6Ch]
  int v48; // [sp+18h] [bp-B68h]
  int v49; // [sp+1Ch] [bp-B64h]
  int v50; // [sp+20h] [bp-B60h]
  int v51; // [sp+24h] [bp-B5Ch]
  int v52; // [sp+28h] [bp-B58h]
  int v53; // [sp+2Ch] [bp-B54h]
  int v54; // [sp+30h] [bp-B50h]
  int v55; // [sp+34h] [bp-B4Ch]
  int v56; // [sp+38h] [bp-B48h]
  int v57; // [sp+3Ch] [bp-B44h]
  int v58; // [sp+40h] [bp-B40h]
  int v59; // [sp+44h] [bp-B3Ch]
  int v60; // [sp+48h] [bp-B38h]
  int v61; // [sp+4Ch] [bp-B34h]
  int v62; // [sp+50h] [bp-B30h]
  __int16 s[128]; // [sp+58h] [bp-B28h] BYREF
  _DWORD v64[64]; // [sp+158h] [bp-A28h] BYREF
  int dest[64]; // [sp+258h] [bp-928h] BYREF
  char v66[2040]; // [sp+358h] [bp-828h] BYREF

  memset(s, 0, sizeof(s));
  memset(v64, 0, sizeof(v64));
  v4 = *(_DWORD *)(a2 + 4 * a1);
  v5 = 3;
  while ( 1 )
  {
    v6 = sub_44358(a1, 0, (int)s, 256);
    if ( v6 )
    {
      if ( (unsigned int)dword_7EB9C > 3 )
      {
        snprintf(v66, 0x800u, "Read configuration fail for chain %d.\n", a1);
        sub_2E584(3, v66, 0);
      }
      return v6;
    }
    sub_17244((char *)a1, (int)s, 0x100u);
    memset(dest, 0, sizeof(dest));
    v7 = HIBYTE(s[0]) - 2;
    v8 = (int)((HIBYTE(s[0]) + 5) & 0xFFFFFFF8) > 254;
    if ( (unsigned __int8)v7 > 0xFDu )
      v8 = 1;
    if ( !v8 )
      break;
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      strcpy(v66, "EEPROM info error!, -1");
      sub_2E584(3, v66, 0);
      goto LABEL_20;
    }
LABEL_7:
    usleep(0x7A120u);
    if ( !--v5 )
    {
      v9 = dword_7EB9C;
      goto LABEL_9;
    }
  }
  v11 = LOBYTE(s[0]) >> 4;
  v12 = v11 == 1;
  if ( v11 == 1 )
    v12 = (s[0] & 0xF) == 1;
  if ( !v12 )
  {
    if ( (unsigned int)dword_7EB9C <= 3 )
      goto LABEL_7;
    strcpy(v66, "EEPROM info error!, -2");
    sub_2E584(3, v66, 0);
LABEL_20:
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      snprintf(v66, 0x800u, "Data decode fail for chain %d.\n", a1);
      sub_2E584(3, v66, 0);
    }
    goto LABEL_7;
  }
  v46 = (HIBYTE(s[0]) + 5) & 0xF8;
  memcpy(dest, &s[1], (HIBYTE(s[0]) + 5) & 0xFFFFFFF8);
  sub_18E48((char *)dest, v46, 0);
  LOWORD(v64[0]) = s[0];
  v13 = LOBYTE(s[0]) >> 4;
  memcpy((char *)v64 + 2, dest, v7);
  v14 = *(_BYTE *)v4 & 0xF | (16 * (v13 & 0xF));
  *(_BYTE *)v4 = v14;
  *(_BYTE *)v4 = v14 & 0xF0 | v64[0] & 0xF;
  *(_BYTE *)(v4 + 1) = BYTE1(v64[0]);
  v15 = BYTE2(v64[0]);
  v16 = BYTE2(v64[0]) - 1;
  *(_BYTE *)(v4 + 2) = BYTE2(v64[0]);
  if ( v16 <= 1 )
  {
    v56 = 61;
    v57 = 62;
    v54 = 59;
    v55 = 60;
    v17 = 4;
    v52 = 55;
    v53 = 57;
    v19 = 40;
    v50 = 51;
    v51 = 53;
    v20 = 1;
    v48 = 49;
    v49 = 50;
    v62 = 65;
    v58 = 47;
    v59 = 46;
    v47 = 48;
    v60 = 41;
    v61 = 45;
  }
  else
  {
    if ( v15 != 3 )
    {
      if ( v15 == 4 )
      {
        v17 = 9;
        v18 = 81;
        goto LABEL_52;
      }
      if ( (unsigned int)dword_7EB9C > 3 )
      {
        strcpy(v66, "This FMT is not supported\n");
        sub_2E584(3, v66, 0);
        v9 = dword_7EB9C;
        goto LABEL_9;
      }
      return -1;
    }
    v17 = 9;
    v18 = 73;
LABEL_52:
    v56 = 66;
    v57 = 67;
    v62 = v18;
    v54 = 64;
    v55 = 65;
    v52 = 60;
    v53 = 62;
    v47 = 53;
    v50 = 56;
    v51 = 58;
    v19 = 45;
    v48 = 54;
    v49 = 55;
    v20 = 1;
    v58 = 52;
    v59 = 51;
    v60 = 46;
    v61 = 50;
  }
  v21 = calloc(0x12u, 1u);
  *(_DWORD *)(v4 + 3) = v21;
  if ( !v21 )
  {
    v20 = 0;
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      strcpy(v66, "Decode SN OOM\n");
      sub_2E584(3, v66, 0);
      v21 = *(_DWORD **)(v4 + 3);
    }
  }
  v22 = *(_DWORD *)((char *)&v64[1] + 3);
  v23 = *(_DWORD *)((char *)&v64[2] + 3);
  v24 = *(_DWORD *)((char *)&v64[3] + 3);
  *v21 = *(_DWORD *)((char *)v64 + 3);
  v21[1] = v22;
  v21[2] = v23;
  v21[3] = v24;
  *((_BYTE *)v21 + 16) = HIBYTE(v64[4]);
  v25 = calloc(3u, 1u);
  *(_DWORD *)(v4 + 7) = v25;
  if ( !v25 )
  {
    v20 = 0;
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      strcpy(v66, "Decode Chip Die OOM\n");
      sub_2E584(3, v66, 0);
      v25 = *(_WORD **)(v4 + 7);
    }
  }
  *v25 = v64[5];
  v26 = calloc(0xEu, 1u);
  *(_DWORD *)(v4 + 11) = v26;
  if ( !v26 )
  {
    v20 = 0;
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      strcpy(v66, "Decode Chip Marking OOM\n");
      sub_2E584(3, v66, 0);
      v26 = *(_DWORD **)(v4 + 11);
    }
  }
  v27 = *(_DWORD *)((char *)&v64[7] + 2);
  v28 = *(_DWORD *)((char *)&v64[6] + 2);
  *v26 = *(_DWORD *)((char *)&v64[5] + 2);
  v26[2] = v27;
  v26[1] = v28;
  *((_BYTE *)v26 + 12) = BYTE2(v64[8]);
  v29 = *(unsigned __int8 *)(v4 + 2) - 1;
  v30 = *(_BYTE *)(v4 + 2) != 1;
  *(_BYTE *)(v4 + 15) = HIBYTE(v64[8]);
  if ( v29 != 1 && v30 )
  {
    v31 = calloc(v17 + 1, 1u);
    *(_DWORD *)(v4 + 16) = v31;
    if ( !v31 )
    {
      v20 = 0;
      if ( (unsigned int)dword_7EB9C > 3 )
      {
        strcpy(v66, "Decode Chip FT Program Version OOM\n");
        sub_2E584(3, v66, 0);
        v31 = *(void **)(v4 + 16);
      }
    }
    memcpy(v31, &v64[9], v17);
  }
  else
  {
    memset(dest, 0, 16);
    v42 = (char *)calloc(v17 + 6, 1u);
    v43 = v42;
    *(_DWORD *)(v4 + 16) = v42;
    if ( !v42 )
    {
      v20 = 0;
      if ( (unsigned int)dword_7EB9C > 3 )
      {
        strcpy(v66, "Decode Chip FT Program Version OOM\n");
        sub_2E584(3, v66, 0);
        v43 = *(char **)(v4 + 16);
      }
    }
    memcpy(dest, &v64[9], v17);
    snprintf(v43, v17 + 6, "F%dV%02dB%dC%d", LOBYTE(dest[0]), BYTE1(dest[0]), BYTE2(dest[0]), HIBYTE(dest[0]));
  }
  *(_BYTE *)(v4 + 20) = *(_BYTE *)(v4 + 20) & 0x80 | *((_BYTE *)v64 + v19) & 0x7F;
  *(_BYTE *)(v4 + 20) = *(_BYTE *)(v4 + 20) & 0x7F | (*((_BYTE *)v64 + v19) >> 7 << 7);
  v32 = calloc(5u, 1u);
  *(_DWORD *)(v4 + 21) = v32;
  if ( !v32 )
  {
    v20 = 0;
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      strcpy(v66, "Decode asic sendor addr OOM\n");
      sub_2E584(3, v66, 0);
      v32 = *(_DWORD **)(v4 + 21);
    }
  }
  *v32 = *(_DWORD *)((char *)v64 + v60);
  *(_BYTE *)(v4 + 25) = *(_BYTE *)(v4 + 25) & 0x80 | *((_BYTE *)v64 + v61) & 0x7F;
  *(_BYTE *)(v4 + 25) = *(_BYTE *)(v4 + 25) & 0x7F | (*((_BYTE *)v64 + v61) >> 7 << 7);
  *(_BYTE *)(v4 + 26) = *((_BYTE *)v64 + v59);
  *(_BYTE *)(v4 + 27) = *((_BYTE *)v64 + v58);
  *(_BYTE *)(v4 + 28) = *((_BYTE *)v64 + v47);
  *(_BYTE *)(v4 + 29) = *((_BYTE *)v64 + v48);
  *(_BYTE *)(v4 + 30) = *((_BYTE *)v64 + v49);
  v33 = calloc(3u, 1u);
  *(_DWORD *)(v4 + 31) = v33;
  if ( !v33 )
  {
    v20 = 0;
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      strcpy(v66, "Decode Chip Technology OOM\n");
      sub_2E584(3, v66, 0);
      v33 = *(_WORD **)(v4 + 31);
    }
  }
  *v33 = *(_WORD *)((char *)v64 + v50);
  *(_WORD *)(v4 + 35) = __rev16(*(unsigned __int16 *)((char *)v64 + v51));
  *(_WORD *)(v4 + 37) = __rev16(*(unsigned __int16 *)((char *)v64 + v52));
  v34 = (double)(unsigned __int16)__rev16(*(unsigned __int16 *)((char *)v64 + v53)) / 100.0;
  *(float *)(v4 + 39) = v34;
  *(_BYTE *)(v4 + 43) = *((_BYTE *)v64 + v54);
  *(_BYTE *)(v4 + 44) = *((_BYTE *)v64 + v55);
  *(_BYTE *)(v4 + 45) = *((_BYTE *)v64 + v56);
  *(_BYTE *)(v4 + 46) = *((_BYTE *)v64 + v57);
  v35 = calloc(9u, 1u);
  v36 = v35;
  *(_DWORD *)(v4 + 47) = v35;
  if ( !v35 )
  {
    v20 = (int)&dword_7EB9C;
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      strcpy(v66, "Decode miner type OOM\n");
      sub_2E584(3, v66, 0);
      v36 = *(_DWORD **)(v4 + 47);
    }
    v44 = v64[18];
    *v36 = v64[17];
    v36[1] = v44;
    *(_BYTE *)(v4 + 55) = *((_BYTE *)v64 + v62);
    goto LABEL_48;
  }
  v37 = v20 == 0;
  if ( !v20 )
    v20 = (unsigned __int16)&dword_7EB9C;
  v38 = v64[18];
  if ( v37 )
    HIWORD(v20) = (unsigned int)&dword_7EB9C >> 16;
  v39 = *((_BYTE *)v64 + v62);
  *v35 = v64[17];
  v35[1] = v38;
  *(_BYTE *)(v4 + 55) = v39;
  if ( !v37 )
  {
    v40 = sub_315EC(v64, 8 * (*(unsigned __int8 *)(v4 + 1) - 1));
    v41 = *(unsigned __int8 *)(v4 + 55);
    if ( v40 != v41 )
    {
      v20 = (int)&dword_7EB9C;
      if ( (unsigned int)dword_7EB9C <= 3 )
        return -1;
      snprintf(
        v66,
        0x800u,
        "Fixture CRC check fail.fixture_crc = 0x%x, len = 0x%x, crc = 0x%x\n",
        v41,
        *(unsigned __int8 *)(v4 + 1),
        v40);
      sub_2E584(3, v66, 0);
      goto LABEL_48;
    }
    *(_BYTE *)(a2 + a1 + 16) = 1;
    return v6;
  }
LABEL_48:
  v9 = *(_DWORD *)v20;
LABEL_9:
  if ( v9 <= 3 )
    return -1;
  snprintf(v66, 0x800u, "Data load fail for chain %d.\n", a1);
  sub_2E584(3, v66, 0);
  return -1;
}
// 7EB9C: using guessed type int dword_7EB9C;

//----- (00017EF8) --------------------------------------------------------
void sub_17EF8()
{
  unsigned int v0; // r4
  int v1; // r6

  if ( dword_7F814[0] )
  {
    if ( *(_BYTE *)(dword_7F814[0] + 28) )
      return;
  }
  else if ( sub_16378() )
  {
    return;
  }
  v0 = 0;
  v1 = 0;
  sub_16580();
  do
  {
    if ( sub_1E29C(v0) )
      v1 |= sub_1740C(v0, dword_7F814[0]);
    ++v0;
  }
  while ( v0 != 4 );
  if ( !v1 )
    *(_BYTE *)(dword_7F814[0] + 28) = 1;
}
// 7F814: using guessed type int dword_7F814[];

//----- (00017F7C) --------------------------------------------------------
int sub_17F7C()
{
  return *(unsigned __int8 *)(dword_7F814[0] + 28);
}
// 7F814: using guessed type int dword_7F814[];

//----- (00017F90) --------------------------------------------------------
int sub_17F90()
{
  int v0; // r4
  int result; // r0

  v0 = 0;
  while ( 1 )
  {
    if ( sub_1E29C(v0) )
    {
      result = *(unsigned __int8 *)(dword_7F814[0] + v0 + 20);
      if ( !*(_BYTE *)(dword_7F814[0] + v0 + 20) )
        break;
    }
    if ( ++v0 == 4 )
      return 1;
  }
  return result;
}
// 7F814: using guessed type int dword_7F814[];

//----- (00017FD8) --------------------------------------------------------
size_t __fastcall sub_17FD8(size_t result, char *a2, size_t a3)
{
  const char *v5; // r6
  char v6[2064]; // [sp+0h] [bp-810h] BYREF

  if ( dword_7F814[0] && *(_BYTE *)(dword_7F814[0] + 28) )
  {
    if ( a2 )
    {
      v5 = *(const char **)(*(_DWORD *)(dword_7F814[0] + 4 * result) + 3);
      result = strlen(v5) + 1;
      if ( result <= a3 )
        return snprintf(a2, a3, "%s", v5);
    }
  }
  else if ( (unsigned int)dword_7EB9C > 3 )
  {
    snprintf(v6, 0x800u, "No hash board sn, chain = %d.\n", result);
    return sub_2E584(3, v6, 0);
  }
  return result;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 7F814: using guessed type int dword_7F814[];

//----- (00018094) --------------------------------------------------------
int __fastcall sub_18094(int a1)
{
  char v2[2056]; // [sp-808h] [bp-808h] BYREF

  if ( dword_7F814[0] && *(_BYTE *)(dword_7F814[0] + 28) )
    return *(unsigned __int8 *)(*(_DWORD *)(dword_7F814[0] + 4 * a1) + 28) | (*(unsigned __int8 *)(*(_DWORD *)(dword_7F814[0] + 4 * a1)
                                                                                                 + 27) << 8);
  if ( (unsigned int)dword_7EB9C > 3 )
  {
    snprintf(v2, 0x800u, "No pcb version, chain = %d.\n", a1);
    sub_2E584(3, v2, 0);
  }
  return 0xFFFF;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 7F814: using guessed type int dword_7F814[];

//----- (00018128) --------------------------------------------------------
int __fastcall sub_18128(int a1)
{
  char v2[2056]; // [sp-808h] [bp-808h] BYREF

  if ( dword_7F814[0] && *(_BYTE *)(dword_7F814[0] + 28) )
    return *(unsigned __int8 *)(*(_DWORD *)(dword_7F814[0] + 4 * a1) + 30) | (*(unsigned __int8 *)(*(_DWORD *)(dword_7F814[0] + 4 * a1)
                                                                                                 + 29) << 8);
  if ( (unsigned int)dword_7EB9C > 3 )
  {
    snprintf(v2, 0x800u, "No bom version, chain = %d.\n", a1);
    sub_2E584(3, v2, 0);
  }
  return 0xFFFF;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 7F814: using guessed type int dword_7F814[];

//----- (000181BC) --------------------------------------------------------
int sub_181BC()
{
  return 0;
}

//----- (000181C4) --------------------------------------------------------
int __fastcall sub_181C4(int a1, _DWORD *a2)
{
  int result; // r0
  int v3; // r3
  char v4[2056]; // [sp-808h] [bp-808h] BYREF

  if ( dword_7F814[0] && *(_BYTE *)(dword_7F814[0] + 28) )
  {
    v3 = *(_DWORD *)(dword_7F814[0] + 4 * a1);
    result = 0;
    *a2 = *(unsigned __int8 *)(v3 + 43);
  }
  else
  {
    if ( (unsigned int)dword_7EB9C > 4 )
    {
      snprintf(v4, 0x800u, "No temp, chain = %d.\n", a1);
      sub_2E584(4, v4, 0);
    }
    return -1;
  }
  return result;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 7F814: using guessed type int dword_7F814[];

//----- (00018258) --------------------------------------------------------
int __fastcall sub_18258(int a1, _DWORD *a2)
{
  int v2; // r3
  int result; // r0
  char v4[2056]; // [sp-808h] [bp-808h] BYREF

  if ( dword_7F814[0] && *(_BYTE *)(dword_7F814[0] + 28) )
  {
    if ( a2 )
    {
      v2 = *(_DWORD *)(dword_7F814[0] + 4 * a1);
      result = 0;
      *a2 = *(unsigned __int8 *)(v2 + 46);
    }
    else
    {
      return -2;
    }
  }
  else
  {
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      snprintf(v4, 0x800u, "No test standard, chain = %d.\n", a1);
      sub_2E584(3, v4, 0);
    }
    return -1;
  }
  return result;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 7F814: using guessed type int dword_7F814[];

//----- (000182FC) --------------------------------------------------------
int __fastcall sub_182FC(int a1, _DWORD *a2)
{
  int v2; // r3
  int result; // r0

  if ( dword_7F814[0] && *(_BYTE *)(dword_7F814[0] + 28) )
  {
    if ( a2 )
    {
      v2 = *(_DWORD *)(dword_7F814[0] + 4 * a1);
      result = 0;
      *a2 = *(unsigned __int8 *)(v2 + 15);
    }
    else
    {
      return -2;
    }
  }
  else if ( (unsigned int)dword_7EB9C > 3 )
  {
    return sub_1697C(a1);
  }
  else
  {
    return -1;
  }
  return result;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 7F814: using guessed type int dword_7F814[];

//----- (00018360) --------------------------------------------------------
int __fastcall sub_18360(int a1, char *a2, size_t a3)
{
  const char *v5; // r6

  if ( dword_7F814[0] && *(_BYTE *)(dword_7F814[0] + 28) )
  {
    if ( a2 )
    {
      v5 = *(const char **)(*(_DWORD *)(dword_7F814[0] + 4 * a1) + 16);
      if ( strlen(v5) >= a3 )
      {
        return -2;
      }
      else
      {
        snprintf(a2, a3, "%s", v5);
        return 0;
      }
    }
    else
    {
      return -2;
    }
  }
  else if ( (unsigned int)dword_7EB9C > 3 )
  {
    return sub_169C0(a1);
  }
  else
  {
    return -1;
  }
}
// 7EB9C: using guessed type int dword_7EB9C;
// 7F814: using guessed type int dword_7F814[];

//----- (000183FC) --------------------------------------------------------
int __fastcall sub_183FC(int a1, int a2, int *a3)
{
  int v5; // r2
  int v6; // r3
  int *v7; // r4
  __int64 v8; // r6
  int v9; // r0
  bool v10; // r2
  const char *v13; // r0
  int v14; // r0
  int v15; // r2
  bool v16; // zf
  unsigned int v17; // r0
  unsigned int v18; // r0
  int v19; // [sp+Ch] [bp-834h]
  int v20; // [sp+14h] [bp-82Ch] BYREF
  char s[2088]; // [sp+18h] [bp-828h] BYREF

  if ( dword_7F814[0] && *(_BYTE *)(dword_7F814[0] + 28) )
  {
    v5 = *(_DWORD *)(dword_7F814[0] + 4 * a1);
    v6 = 1127301685;
    v7 = &dword_7F81C;
    HIDWORD(v8) = *(unsigned __int16 *)(v5 + 35);
    LODWORD(v8) = *(unsigned __int16 *)(v5 + 37);
    while ( 1 )
    {
      v9 = *(v7 - 1);
      if ( v9 )
      {
        v10 = v9 == HIDWORD(v8);
        if ( !*v7 )
          v10 = 0;
        if ( *v7 == (_DWORD)v8 && v10 )
          break;
      }
LABEL_11:
      v7 += 2;
      if ( &dword_7F8BC == v7 )
      {
        if ( (unsigned int)dword_7EB9C > 4 )
        {
          strcpy(s, "freq level not match");
          sub_2E584(4, s, 0);
        }
        return -2;
      }
    }
    v19 = v6;
    v13 = (const char *)sub_1E0C0();
    v14 = strcmp(v13, "NBS2003");
    v6 = v19;
    if ( !v14 )
    {
      memset(s, 0, 16);
      v20 = 0;
      sub_18360(a1, s, 0x10u);
      sub_182FC(a1, &v20);
      v6 = v19;
      if ( *(_DWORD *)s == 810955078 && *(_DWORD *)&s[4] == v19 && s[8] == 49 && (unsigned int)(v20 - 3) <= 1 )
      {
        v16 = (_DWORD)v8 == 650;
        if ( (_DWORD)v8 == 650 )
          v16 = HIDWORD(v8) == 1280;
        if ( v16 )
        {
          v15 = 600;
          goto LABEL_20;
        }
        v15 = 625;
        v17 = __clz(v8 - 625);
        if ( v8 == 0x51400000271LL )
          v15 = 575;
        v18 = v17 >> 5;
        if ( v8 == 0x51400000271LL )
        {
LABEL_20:
          if ( a3 )
          {
            *a3 = v15;
            return 0;
          }
          goto LABEL_11;
        }
        if ( ((HIDWORD(v8) == 1280) & (unsigned __int8)v18) != 0 )
        {
          v15 = 575;
          if ( (_DWORD)v8 == 650 )
            v15 = 600;
          goto LABEL_20;
        }
      }
    }
    v15 = v8;
    goto LABEL_20;
  }
  if ( (unsigned int)dword_7EB9C > 4 )
  {
    snprintf(s, 0x800u, "No work mode freq, chain = %d, mode = %d.\n", a1, a2);
    sub_2E584(4, s, 0);
  }
  return -1;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 7F814: using guessed type int dword_7F814[];
// 7F81C: using guessed type int dword_7F81C;
// 7F8BC: using guessed type int dword_7F8BC;

//----- (00018654) --------------------------------------------------------
int __fastcall sub_18654(int a1, int a2, int *a3)
{
  int v5; // r2
  int v6; // r3
  int *v7; // r4
  __int64 v8; // r6
  int v9; // r0
  bool v10; // r2
  const char *v13; // r0
  int v14; // r0
  int v15; // r2
  bool v16; // r2
  int v18; // [sp+Ch] [bp-834h]
  int v19; // [sp+14h] [bp-82Ch] BYREF
  char s[2088]; // [sp+18h] [bp-828h] BYREF

  if ( dword_7F814[0] && *(_BYTE *)(dword_7F814[0] + 28) )
  {
    v5 = *(_DWORD *)(dword_7F814[0] + 4 * a1);
    v6 = 1127301685;
    v7 = &dword_7F81C;
    LODWORD(v8) = *(unsigned __int16 *)(v5 + 35);
    HIDWORD(v8) = *(unsigned __int16 *)(v5 + 37);
    do
    {
      v9 = *(v7 - 1);
      if ( v9 )
      {
        v10 = v9 == (_DWORD)v8;
        if ( !*v7 )
          v10 = 0;
        if ( *v7 == HIDWORD(v8) && v10 )
        {
          v18 = v6;
          v13 = (const char *)sub_1E0C0();
          v14 = strcmp(v13, "NBS2003");
          v6 = v18;
          if ( v14 )
            goto LABEL_19;
          memset(s, 0, 16);
          v19 = 0;
          sub_18360(a1, s, 0x10u);
          sub_182FC(a1, &v19);
          v6 = v18;
          if ( *(_DWORD *)s != 810955078 || *(_DWORD *)&s[4] != v18 || s[8] != 49 || (unsigned int)(v19 - 3) > 1 )
            goto LABEL_19;
          v16 = (_DWORD)v8 == 1280;
          if ( v8 == 0x28A00000500LL )
            goto LABEL_33;
          if ( (_DWORD)v8 == 1300 )
            v16 = 1;
          if ( HIDWORD(v8) == 625 && v16 )
          {
LABEL_33:
            v15 = 1260;
            if ( v19 != 3 )
              v15 = 1240;
          }
          else
          {
LABEL_19:
            v15 = v8;
          }
          if ( a3 )
          {
            *a3 = v15;
            return 0;
          }
        }
      }
      v7 += 2;
    }
    while ( &dword_7F8BC != v7 );
    if ( (unsigned int)dword_7EB9C > 4 )
    {
      strcpy(s, "voltage level not match");
      sub_2E584(4, s, 0);
    }
    return -2;
  }
  else
  {
    if ( (unsigned int)dword_7EB9C > 4 )
    {
      snprintf(s, 0x800u, "No work mode voltage, chain = %d, mode = %d.\n", a1, a2);
      sub_2E584(4, s, 0);
    }
    return -1;
  }
}
// 7EB9C: using guessed type int dword_7EB9C;
// 7F814: using guessed type int dword_7F814[];
// 7F81C: using guessed type int dword_7F81C;
// 7F8BC: using guessed type int dword_7F8BC;

//----- (000188A0) --------------------------------------------------------
int __fastcall sub_188A0(int a1, int a2, _DWORD *a3)
{
  int v3; // r3
  int result; // r0
  char s[2056]; // [sp+8h] [bp-808h] BYREF

  if ( dword_7F814[0] && *(_BYTE *)(dword_7F814[0] + 28) )
  {
    if ( a3 )
    {
      v3 = *(_DWORD *)(dword_7F814[0] + 4 * a1);
      result = 0;
      *a3 = *(unsigned __int16 *)(v3 + 60);
    }
    else
    {
      return 0;
    }
  }
  else
  {
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      snprintf(s, 0x800u, "No work mode hash rate, chain = %d, mode = %d.\n", a1, a2);
      sub_2E584(3, s, 0);
    }
    return 0xFFFF;
  }
  return result;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 7F814: using guessed type int dword_7F814[];

//----- (00018948) --------------------------------------------------------
int __fastcall sub_18948(int a1, int a2, int a3)
{
  int result; // r0
  int v4; // r3
  int v5; // r12
  char s[2056]; // [sp+8h] [bp-808h] BYREF

  if ( dword_7F814[0] && *(_BYTE *)(dword_7F814[0] + 28) && (v4 = *(_DWORD *)(dword_7F814[0] + 4 * a1)) != 0 )
  {
    v5 = *(_DWORD *)(a3 + 4);
    result = 0;
    *(_DWORD *)(v4 + 58) = *(_DWORD *)a3;
    *(_DWORD *)(v4 + 62) = v5;
    *(_BYTE *)(v4 + 66) = *(_BYTE *)(a3 + 8);
  }
  else
  {
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      snprintf(s, 0x800u, "Can't set work mode conf, configuration is not loaded, chain = %d, mode = %d.\n", a1, a2);
      sub_2E584(3, s, 0);
    }
    return -1;
  }
  return result;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 7F814: using guessed type int dword_7F814[];

//----- (00018A0C) --------------------------------------------------------
int sub_18A0C()
{
  return 0;
}

//----- (00018B30) --------------------------------------------------------
int __fastcall sub_18B30(unsigned int a1)
{
  unsigned int v1; // r3
  int result; // r0

  if ( !dword_7F814[0] || a1 > 4 )
    return 0;
  v1 = dword_7F814[0] + a1;
  result = *(unsigned __int8 *)(dword_7F814[0] + a1 + 16);
  if ( *(_BYTE *)(v1 + 16) )
    return 1;
  return result;
}
// 7F814: using guessed type int dword_7F814[];

//----- (00018B68) --------------------------------------------------------
int sub_18B68()
{
  char *v0; // r12
  char v2; // [sp+0h] [bp-808h] BYREF

  strcpy(v0, "XXTEA requires the input as 64-bit aligned, fail to encode!\n");
  return sub_2E584(3, &v2, 0);
}
// 18B84: variable 'v0' is possibly undefined

//----- (00018BC0) --------------------------------------------------------
int sub_18BC0()
{
  char *v0; // r12
  char v2; // [sp+0h] [bp-808h] BYREF

  strcpy(v0, "XXTEA requires the input as 64-bit aligned, fail to decode!\n");
  return sub_2E584(3, &v2, 0);
}
// 18BDC: variable 'v0' is possibly undefined

//----- (00018C18) --------------------------------------------------------
_DWORD *__fastcall sub_18C18(_DWORD *result, _DWORD *a2, int a3)
{
  _DWORD *v3; // r2

  if ( a3 > 0 )
  {
    v3 = &result[a3];
    do
      *result++ ^= *a2;
    while ( result != v3 );
  }
  return result;
}

//----- (00018C40) --------------------------------------------------------
char *__fastcall sub_18C40(int a1)
{
  char v3[2056]; // [sp+0h] [bp-808h] BYREF

  if ( a1 == 3 && (unsigned int)dword_7EB9C > 3 )
  {
    strcpy(v3, "enc/dec undefined data type, use default key!\n");
    sub_2E584(3, v3, 0);
  }
  if ( dword_7E298 == 2 )
    return (char *)&unk_7E2AC + 16 * a1;
  if ( dword_7E298 == 3 )
    return (char *)&unk_7E29C + 4 * a1;
  return 0;
}
// 7E298: using guessed type int dword_7E298;
// 7EB9C: using guessed type int dword_7EB9C;

//----- (00018CE8) --------------------------------------------------------
char *__fastcall sub_18CE8(int a1, int a2, int a3)
{
  char *result; // r0
  int v6; // r5
  _DWORD *v7; // r5
  _DWORD *v8; // r3

  result = sub_18C40(a3);
  if ( dword_7E298 == 2 )
  {
    if ( (a2 & 7) != 0 )
    {
      if ( (unsigned int)dword_7EB9C > 3 )
        return (char *)sub_18B68();
    }
    else
    {
      return (char *)sub_18F10(a1, a2 / 4, (int)result);
    }
  }
  else if ( dword_7E298 == 3 )
  {
    v6 = a2 / 4;
    if ( v6 > 0 )
    {
      v7 = (_DWORD *)(a1 + 4 * v6);
      v8 = (_DWORD *)a1;
      do
        *v8++ ^= *(_DWORD *)result;
      while ( v8 != v7 );
    }
  }
  return result;
}
// 7E298: using guessed type int dword_7E298;
// 7EB9C: using guessed type int dword_7EB9C;

//----- (00018D98) --------------------------------------------------------
char *__fastcall sub_18D98(int a1, int a2, int a3)
{
  char *result; // r0
  int v6; // r5
  _DWORD *v7; // r5
  _DWORD *v8; // r3

  result = sub_18C40(a3);
  if ( dword_7E298 == 2 )
  {
    if ( (a2 & 7) != 0 )
    {
      if ( (unsigned int)dword_7EB9C > 3 )
        return (char *)sub_18BC0();
    }
    else
    {
      return (char *)sub_19074(a1, a2 / 4, (int)result);
    }
  }
  else if ( dword_7E298 == 3 )
  {
    v6 = a2 / 4;
    if ( v6 > 0 )
    {
      v7 = (_DWORD *)(a1 + 4 * v6);
      v8 = (_DWORD *)a1;
      do
        *v8++ ^= *(_DWORD *)result;
      while ( v8 != v7 );
    }
  }
  return result;
}
// 7E298: using guessed type int dword_7E298;
// 7EB9C: using guessed type int dword_7EB9C;

//----- (00018E48) --------------------------------------------------------
char *__fastcall sub_18E48(char *result, char a2, int a3)
{
  char v3[2056]; // [sp+0h] [bp-808h] BYREF

  if ( (a2 & 3) != 0 )
  {
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      strcpy(v3, "EEPROM write data is not 32-bit aligned, FAIL ENC/DEC!\n");
      return (char *)sub_2E584(3, v3, 0);
    }
  }
  else if ( a3 )
  {
    return sub_18CE8((int)result, a2, 1);
  }
  else
  {
    return sub_18D98((int)result, a2, 1);
  }
  return result;
}
// 7EB9C: using guessed type int dword_7EB9C;

//----- (00018EF0) --------------------------------------------------------
int __fastcall sub_18EF0(int result)
{
  dword_7E298 = result;
  return result;
}
// 7E298: using guessed type int dword_7E298;

//----- (00018F00) --------------------------------------------------------
int sub_18F00()
{
  return dword_7E298;
}
// 7E298: using guessed type int dword_7E298;

//----- (00018F10) --------------------------------------------------------
int __fastcall sub_18F10(int result, int a2, int a3)
{
  unsigned int *v3; // r7
  unsigned int *v5; // r8
  unsigned int v6; // r4
  int v7; // r11
  unsigned int v8; // r10
  unsigned int *v9; // r5
  int v10; // lr
  unsigned int v11; // r9
  int v12; // r3
  int v13; // [sp+0h] [bp-830h]
  char v14[2088]; // [sp+8h] [bp-828h] BYREF

  if ( a2 <= 1 )
  {
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      strcpy(v14, "XXTEA encode failes, N <= 1 found.\n");
      return sub_2E584(3, v14, 0);
    }
  }
  else
  {
    v3 = (unsigned int *)result;
    v5 = (unsigned int *)(result + 4 * (a2 + 0x3FFFFFFF));
    v6 = *v5;
    v7 = a2 - 1;
    v8 = 0;
    v13 = -1253254570 - 1640531527 * sub_5FAF8(52, a2);
    do
    {
      v9 = v3;
      v10 = 0;
      v8 -= 1640531527;
      v11 = v8 >> 2;
      do
      {
        v12 = *(_DWORD *)(a3 + 4 * (((unsigned __int8)v11 ^ (unsigned __int8)v10++) & 3));
        v6 = (((v12 ^ v6) + (v8 ^ v9[1])) ^ (((4 * v9[1]) ^ (v6 >> 5)) + ((16 * v6) ^ (v9[1] >> 3)))) + *v9;
        *v9++ = v6;
      }
      while ( v10 != v7 );
      result = (16 * v6) ^ (*v3 >> 3);
      v6 = (((v6 ^ *(_DWORD *)(a3 + 4 * (((unsigned __int8)v11 ^ (unsigned __int8)v7) & 3))) + (v8 ^ *v3)) ^ (((4 * *v3) ^ (v6 >> 5)) + result))
         + *v5;
      *v5 = v6;
    }
    while ( v8 != v13 );
  }
  return result;
}
// 7EB9C: using guessed type int dword_7EB9C;

//----- (00019074) --------------------------------------------------------
int __fastcall sub_19074(int result, int a2, int a3)
{
  unsigned int *v3; // r7
  int v6; // r0
  unsigned int v7; // r2
  unsigned int v8; // r3
  unsigned int *v9; // r10
  int v10; // r11
  int v11; // r5
  unsigned int v12; // r9
  unsigned int *v13; // r6
  unsigned int v14; // t1
  int v15; // r4
  int v16; // r4
  int v17; // [sp+0h] [bp-830h]
  char v18[2088]; // [sp+8h] [bp-828h] BYREF

  if ( a2 <= 1 )
  {
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      strcpy(v18, "XXTEA decode failes, N <= 1 found.\n");
      return sub_2E584(3, v18, 0);
    }
  }
  else
  {
    v3 = (unsigned int *)result;
    v6 = sub_5FAF8(52, a2);
    v7 = -1640531527 * (v6 + 6);
    v17 = a2 - 1;
    v8 = *v3;
    v9 = &v3[a2 - 1];
    v10 = v7 + 1640531527 * v6 + 1253254570;
    do
    {
      v11 = v17;
      v12 = v7 >> 2;
      v13 = v9;
      do
      {
        v14 = *--v13;
        v15 = *(_DWORD *)(a3 + 4 * (((unsigned __int8)v12 ^ (unsigned __int8)v11--) & 3));
        v8 = v13[1] - (((v14 ^ v15) + (v7 ^ v8)) ^ (((4 * v8) ^ (v14 >> 5)) + ((16 * v14) ^ (v8 >> 3))));
        v13[1] = v8;
      }
      while ( v11 );
      v16 = v8 ^ v7;
      v7 += 1640531527;
      result = (4 * v8) ^ (*v9 >> 5);
      v8 = *v3 - ((result + ((16 * *v9) ^ (v8 >> 3))) ^ ((*v9 ^ *(_DWORD *)(a3 + 4 * (v12 & 3))) + v16));
      *v3 = v8;
    }
    while ( v7 != v10 );
  }
  return result;
}
// 7EB9C: using guessed type int dword_7EB9C;

//----- (000191DC) --------------------------------------------------------
bool __fastcall sub_191DC(unsigned int a1)
{
  return (unsigned __int8)sub_4637C(a1) == 0;
}

//----- (000191FC) --------------------------------------------------------
bool __fastcall sub_191FC(unsigned int a1)
{
  return (unsigned __int8)sub_46ACC(a1) == 0;
}

//----- (00019214) --------------------------------------------------------
int __fastcall sub_19214(int a1)
{
  int result; // r0
  char s[2064]; // [sp+8h] [bp-810h] BYREF

  if ( (unsigned int)dword_7EB9C > 3 )
  {
    snprintf(s, 0x800u, "chain[%d] PIC jump to app\n", a1);
    sub_2E584(3, s, 0);
  }
  sub_46554((unsigned __int8)a1);
  usleep(0x7A120u);
  result = sub_46178((unsigned __int8)a1);
  if ( (unsigned int)dword_7EB9C > 3 )
  {
    snprintf(s, 0x800u, "Check chain[%d] PIC fw version=0x%02x\n", a1, result);
    return sub_2E584(3, s, 0);
  }
  return result;
}
// 7EB9C: using guessed type int dword_7EB9C;

//----- (000192C8) --------------------------------------------------------
int __fastcall sub_192C8(int a1)
{
  int result; // r0
  unsigned int v3; // r2
  double v4; // d8
  int v5[3]; // [sp+Ch] [bp-83Ch] BYREF
  char s[2096]; // [sp+18h] [bp-830h] BYREF

  memset(v5, 0, sizeof(v5));
  result = sub_47158((unsigned __int8)a1, v5, 1);
  if ( (_BYTE)result )
  {
    v3 = dword_7EB9C;
    v4 = (double)v5[0] * 3.3 * 0.0009765625 * 7.6;
    if ( (unsigned int)dword_7EB9C > 5 )
    {
      snprintf(s, 0x800u, "an0 = %f.\n", (double)v5[0] * 3.3 * 0.0009765625 * 7.6);
      result = sub_2E584(5, s, 0);
      v3 = dword_7EB9C;
      v4 = (double)v5[0] * 3.3 * 0.0009765625 * 7.6;
    }
  }
  else
  {
    v4 = 0.0;
    v3 = dword_7EB9C;
  }
  if ( v3 > 4 )
  {
    snprintf(s, 0x800u, "chain = %d, voltage = %f\n", a1, v4);
    return sub_2E584(4, s, 0);
  }
  return result;
}
// 7EB9C: using guessed type int dword_7EB9C;

//----- (000193F8) --------------------------------------------------------
int sub_193F8()
{
  double v0; // d0
  int v1; // r4
  double v2; // d8
  int result; // r0
  char s[2072]; // [sp+8h] [bp-818h] BYREF

  v1 = 0;
  v2 = 0.0;
  do
  {
    result = sub_1E29C(v1);
    if ( result )
    {
      result = sub_192C8(v1);
      if ( v0 > 0.1 )
      {
        if ( v0 >= v2 )
        {
          if ( v2 < 0.1 )
            v2 = v0;
        }
        else
        {
          v2 = v0;
        }
      }
    }
    ++v1;
  }
  while ( v1 != 4 );
  if ( (unsigned int)dword_7EB9C > 4 )
  {
    snprintf(s, 0x800u, "the minimal voltage = %.2f", v2);
    return sub_2E584(4, s, 0);
  }
  return result;
}
// 19490: variable 'v0' is possibly undefined
// 7EB9C: using guessed type int dword_7EB9C;

//----- (000194C8) --------------------------------------------------------
unsigned int sub_194C8()
{
  sub_42100();
  return sleep(1u);
}

//----- (000194DC) --------------------------------------------------------
unsigned int sub_194DC()
{
  sub_42138();
  return sleep(1u);
}

//----- (000194F0) --------------------------------------------------------
int sub_194F0()
{
  int v0; // r4
  int v1; // r5
  int result; // r0
  int v3; // r3
  int v4; // r5
  int v5; // r0
  int v6; // r3
  char s[2064]; // [sp+8h] [bp-810h] BYREF

  v0 = 1;
  sleep(1u);
  do
  {
    do
    {
      ++v0;
      sleep(1u);
    }
    while ( v0 <= 29 );
    v1 = sub_15508();
    result = sub_1572C();
    v3 = v1 - result;
    if ( v1 - result < 0 )
      v3 = result - v1;
  }
  while ( v3 > 5 && v0 != 180 );
  if ( (unsigned int)dword_7EB9C > 3 )
  {
    v4 = sub_15508();
    v5 = sub_1572C();
    v6 = v4 - v5;
    if ( v4 - v5 < 0 )
      v6 = v5 - v4;
    snprintf(s, 0x800u, "Slept %d seconds, diff = %d.\n", v0, v6);
    return sub_2E584(3, s, 0);
  }
  return result;
}
// 7EB9C: using guessed type int dword_7EB9C;

//----- (000195A8) --------------------------------------------------------
int __fastcall sub_195A8(int a1)
{
  int result; // r0
  char s[2064]; // [sp+8h] [bp-810h] BYREF

  if ( (unsigned int)dword_7EB9C > 3 )
  {
    snprintf(s, 0x800u, "%s to %d.\n", "set_voltage_by_steps", a1);
    sub_2E584(3, s, 0);
  }
  if ( sub_48F00() < 0 )
  {
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      strcpy(s, "bitmain_set_voltage failed");
      sub_2E584(3, s, 0);
    }
    return -1;
  }
  else
  {
    result = 0;
    dword_7F8BC = a1;
    dword_7F8C0 = a1;
  }
  return result;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 7F8BC: using guessed type int dword_7F8BC;
// 7F8C0: using guessed type int dword_7F8C0;

//----- (00019698) --------------------------------------------------------
int __fastcall sub_19698(int a1)
{
  double v1; // d0
  int v3; // r5
  int v4; // r6
  int v6; // r5
  double v7; // d7
  unsigned int v8; // r5
  int v9; // r5
  char *v10; // r3
  int v11; // [sp+4h] [bp-83Ch]
  char s[2096]; // [sp+10h] [bp-830h] BYREF

  v3 = sub_48910();
  if ( (unsigned int)dword_7EB9C > 3 )
  {
    snprintf(s, 0x800u, "power type version: 0x%04x\n", v3);
    sub_2E584(3, s, 0);
  }
  if ( sub_1E91C((unsigned __int16)v3) )
  {
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      strcpy(s, "Enter sleep to make sure power release finish.\n");
      sub_2E584(3, s, 0);
    }
    sub_42138();
    sleep(1u);
    sub_194F0();
    v4 = sub_195A8(a1);
    if ( v4 < 0 )
    {
      if ( (unsigned int)dword_7EB9C > 3 )
      {
        snprintf(s, 0x800u, "%s power iic error.\n", "power_init");
        sub_2E584(3, s, 0);
      }
      return v4;
    }
    sub_42100();
    sleep(1u);
    if ( (unsigned int)(v3 - 117) <= 3 )
    {
      v6 = 3;
      while ( 1 )
      {
        sleep(1u);
        sub_192C8(0);
        if ( v1 < 0.0 )
          break;
        v1 = v1 * 100.0;
        v7 = (double)a1;
        if ( v1 <= (double)a1 * 1.1 && v1 >= v7 * 0.9 )
        {
          v4 = 0;
          goto LABEL_18;
        }
        if ( (unsigned int)dword_7EB9C > 3 )
        {
          v10 = v1 - v7 <= 0.0 ? "drop" : "rise";
          snprintf(s, 0x800u, "chain avg vol %s from %d to %.2f", v10, a1, v11, v1);
          sub_2E584(3, s, 0);
          if ( (unsigned int)dword_7EB9C > 3 )
          {
            strcpy(s, "power voltage can not meet the target");
            sub_2E584(3, s, 0);
          }
        }
        if ( !--v6 )
        {
          v4 = -1;
          goto LABEL_18;
        }
      }
      if ( (unsigned int)dword_7EB9C > 3 )
      {
        strcpy(s, "read_feedback_voltage failed!");
        sub_2E584(3, s, 0);
      }
      v4 = 0;
      sub_31D58(9u, "power voltage read failed, pls check!");
LABEL_18:
      v8 = 0;
      while ( 1 )
      {
        ++v8;
        if ( !sub_48B7C() )
          break;
        if ( v8 == 5 * (v8 / 5) && (unsigned int)dword_7EB9C > 3 )
        {
          strcpy(s, "bitmain_get_power_status failed!");
          sub_2E584(3, s, v8 % 5);
        }
        sleep(3u);
        if ( v8 == 20 )
          return -1;
      }
      return v4;
    }
    v9 = 3;
    while ( 1 )
    {
      sleep(1u);
      sub_193F8();
      if ( v1 >= (double)a1 * 0.75 / 100.0 )
        break;
      if ( (unsigned int)dword_7EB9C > 3 )
      {
        strcpy(s, "power voltage can not meet the target");
        sub_2E584(3, s, 0);
      }
      if ( !--v9 )
        return -1;
    }
    return 0;
  }
  else
  {
    if ( (unsigned int)dword_7EB9C <= 3 )
      return -1;
    strcpy(s, "power type version error\n");
    sub_2E584(3, s, 0);
    return -1;
  }
}
// 197A4: variable 'v1' is possibly undefined
// 19988: variable 'v11' is possibly undefined
// 7EB9C: using guessed type int dword_7EB9C;

//----- (00019AB4) --------------------------------------------------------
int sub_19AB4()
{
  return dword_7F8BC;
}
// 7F8BC: using guessed type int dword_7F8BC;

//----- (00019AC4) --------------------------------------------------------
int sub_19AC4()
{
  double v0; // d0

  sub_48F9C();
  return (int)(v0 * 100.0);
}
// 19AD4: variable 'v0' is possibly undefined

//----- (00019D40) --------------------------------------------------------
int __fastcall sub_19D40(int a1, int a2)
{
  return *(_DWORD *)(a1 + 4) - *(_DWORD *)(a2 + 4);
}

//----- (00019D50) --------------------------------------------------------
int __fastcall sub_19D50(int a1, int a2)
{
  return *(_DWORD *)(a2 + 4) - *(_DWORD *)(a1 + 4);
}

//----- (00019D60) --------------------------------------------------------
int __fastcall sub_19D60(_DWORD *a1, _DWORD *a2)
{
  return *a1 - *a2;
}

//----- (00019D70) --------------------------------------------------------
unsigned int *__fastcall sub_19D70(unsigned int *a1, unsigned int *a2, unsigned int *a3, _DWORD *a4)
{
  unsigned int *result; // r0
  unsigned int *v9; // r6
  int v10; // r5
  unsigned int *v11; // r6
  unsigned int v12; // lr
  unsigned int v13; // r4
  unsigned int v14; // r12
  unsigned int v15; // t1

  result = (unsigned int *)sub_1E0F0();
  v9 = result;
  if ( (int)result <= 0 )
  {
    v10 = 0;
    v13 = 0xFFFFFF;
    v12 = 0;
  }
  else
  {
    v10 = 0;
    result = a1;
    v11 = &a1[(_DWORD)v9];
    v12 = 0;
    v13 = 0xFFFFFF;
    do
    {
      v15 = *result++;
      v14 = v15;
      v10 += v15;
      if ( v12 < v15 )
        v12 = v14;
      if ( v13 >= v14 )
        v13 = v14;
    }
    while ( result != v11 );
  }
  *a2 = v13;
  *a3 = v12;
  *a4 = v10;
  return result;
}

//----- (00019DE4) --------------------------------------------------------
int __fastcall sub_19DE4(int a1)
{
  int v2; // r4
  int v3; // r4
  int v4; // [sp+4h] [bp-Ch] BYREF

  v4 = 0;
  if ( dword_7EDC8 == 2 )
  {
    v2 = dword_7F8C4[a1];
    v3 = sub_1E0F0() * v2;
    return sub_1E130() * v3 / 1000 + v4;
  }
  else
  {
    sub_188A0(a1, (unsigned __int8)dword_80FB4, &v4);
    return v4;
  }
}
// 7EDC8: using guessed type int dword_7EDC8;
// 7F8C4: using guessed type _DWORD dword_7F8C4[4];
// 80FB4: using guessed type int dword_80FB4;

//----- (00019E68) --------------------------------------------------------
int sub_19E68()
{
  int v0; // r0
  int *v1; // r7
  int v2; // r4
  int i; // r5
  int v4; // r1
  __int64 v5; // r4
  int v7; // r5
  int v8; // r8
  int v9; // r8
  int v10; // r0
  int *v11; // r9
  int *v12; // r6
  int v13; // t1
  char v14[2080]; // [sp+0h] [bp-820h] BYREF

  v0 = sub_1E0F0();
  v1 = (int *)calloc(v0, 4u);
  if ( v1 )
  {
    v2 = 0;
    if ( dword_7EDC8 == 2 )
    {
      v7 = 0;
      if ( sub_1E29C(0) )
        goto LABEL_14;
      while ( ++v7 != 4 )
      {
        if ( sub_1E29C(v7) )
        {
LABEL_14:
          v8 = dword_7F8C4[v7];
          v9 = sub_1E0F0() * v8;
          v2 += sub_1E130() * v9;
        }
      }
    }
    else
    {
      for ( i = 0; i != 4; ++i )
      {
        if ( sub_1E29C(i) )
        {
          sub_183FC(i, (unsigned __int8)dword_80FB4, v1);
          v10 = sub_1E0F0();
          if ( v10 > 0 )
          {
            v11 = &v1[v10];
            v12 = v1;
            do
            {
              v13 = *v12++;
              v2 += v13 * sub_1E130();
            }
            while ( v12 != v11 );
          }
        }
      }
    }
    v4 = v2 >> 31;
    v5 = 274877907LL * v2;
    LODWORD(v5) = (SHIDWORD(v5) >> 6) - v4;
    dword_7F8D4 = v5;
    if ( (unsigned int)dword_7EB9C > 4 )
    {
      snprintf(v14, 0x800u, "max_hash_rate = %d\n", (SHIDWORD(v5) >> 6) - v4);
      sub_2E584(4, v14, 0);
      LODWORD(v5) = dword_7F8D4;
    }
    free(v1);
  }
  else
  {
    LODWORD(v5) = 0;
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      strcpy(v14, "malloc buf failed!\n");
      sub_2E584(3, v14, 0);
    }
  }
  return v5;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 7EDC8: using guessed type int dword_7EDC8;
// 7F8C4: using guessed type _DWORD dword_7F8C4[4];
// 7F8D4: using guessed type int dword_7F8D4;
// 80FB4: using guessed type int dword_80FB4;

//----- (0001A014) --------------------------------------------------------
int sub_1A014()
{
  unsigned int v0; // r6
  int i; // r4
  int v2; // r4
  int j; // r5
  int v4; // r0
  int result; // r0
  int v6; // r7
  int v7; // r5
  int v8; // r7
  int v9; // r7
  unsigned int v10; // [sp+4h] [bp-824h] BYREF
  char s[2080]; // [sp+8h] [bp-820h] BYREF

  if ( dword_7EDC8 == 2 )
  {
    v2 = 0;
    v7 = 0;
    if ( sub_1E29C(0) )
      goto LABEL_21;
    while ( ++v7 != 4 )
    {
      if ( sub_1E29C(v7) )
      {
LABEL_21:
        v8 = dword_7F8C4[v7];
        v9 = sub_1E0F0() * v8;
        v2 += sub_1E130() * v9;
      }
    }
  }
  else
  {
    v0 = 0;
    for ( i = 0; i != 4; ++i )
    {
      if ( sub_1E29C(i) && !sub_183FC(i, (unsigned __int8)dword_80FB4, (int *)&v10) )
      {
        if ( v0 )
        {
          if ( v0 >= v10 )
            v0 = v10;
        }
        else
        {
          v0 = v10;
        }
      }
    }
    v2 = 0;
    for ( j = 0; j != 4; ++j )
    {
      v4 = j;
      if ( sub_1E29C(v4) )
      {
        v6 = v0 * sub_1E0F0();
        v2 += sub_1E130() * v6;
      }
    }
  }
  result = v2 / 1000;
  dword_7F8D8 = result;
  if ( (unsigned int)dword_7EB9C > 4 )
  {
    snprintf(s, 0x800u, "ideal_hash_rate = %d\n", v2 / 1000);
    sub_2E584(4, s, 0);
    return dword_7F8D8;
  }
  return result;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 7EDC8: using guessed type int dword_7EDC8;
// 7F8C4: using guessed type _DWORD dword_7F8C4[4];
// 7F8D8: using guessed type int dword_7F8D8;
// 80FB4: using guessed type int dword_80FB4;

//----- (0001A18C) --------------------------------------------------------
int sub_1A18C()
{
  int v0; // r6
  int v1; // r4
  char *v2; // r5
  int v3; // t1
  int v5; // r0
  unsigned int v6; // r3
  int v7; // [sp+0h] [bp-818h] BYREF
  int v8[7]; // [sp+4h] [bp-814h] BYREF
  char v9; // [sp+20h] [bp-7F8h] BYREF

  v0 = sub_1A014();
  v7 = 110000;
  v8[0] = 105000;
  v8[1] = 95000;
  v8[2] = 90000;
  v1 = 110000;
  v8[3] = (int)sub_157C0;
  v8[4] = 84000;
  v8[5] = 81000;
  v8[6] = 77000;
  if ( !sub_5FAF8(v0, 110000) )
  {
    v2 = (char *)v8;
    while ( 1 )
    {
      v3 = *(_DWORD *)v2;
      v2 += 4;
      v1 = v3;
      if ( sub_5FAF8(v0, v3) )
        break;
      if ( v2 == &v9 )
      {
        v1 = sub_1A014();
        goto LABEL_6;
      }
    }
  }
  dword_7F8DC = v1;
  v5 = sub_1A014();
  if ( v1 )
  {
    v6 = dword_7EB9C;
  }
  else
  {
    v1 = v5;
LABEL_6:
    if ( (unsigned int)dword_7EB9C <= 4 )
    {
      dword_7F8DC = v1;
      return v1;
    }
    snprintf((char *)&v7, 0x800u, "format sale hash failed %d\n", v1);
    sub_2E584(4, (const char *)&v7, 0);
    v6 = dword_7EB9C;
  }
  dword_7F8DC = v1;
  if ( v6 <= 4 )
    return v1;
  snprintf((char *)&v7, 0x800u, "sale_hash_rate = %d\n", v1);
  sub_2E584(4, (const char *)&v7, 0);
  return dword_7F8DC;
}
// 157C0: using guessed type int sub_157C0();
// 7EB9C: using guessed type int dword_7EB9C;
// 7F8DC: using guessed type int dword_7F8DC;
// 1A18C: using guessed type _DWORD var_814[7];

//----- (0001A2D8) --------------------------------------------------------
int sub_1A2D8()
{
  return 0;
}

//----- (0001A2E0) --------------------------------------------------------
int __fastcall sub_1A2E0(int result)
{
  _DWORD *v1; // r3

  v1 = dword_7F8C4;
  if ( dword_7EDC8 == 2 )
    result = dword_7F8C4[result];
  else
    v1 = &dword_7F8C4[result];
  if ( dword_7EDC8 != 2 )
    return v1[7];
  return result;
}
// 7EDC8: using guessed type int dword_7EDC8;
// 7F8C4: using guessed type _DWORD dword_7F8C4[4];

//----- (0001A470) --------------------------------------------------------
void __fastcall sub_1A470(int a1, unsigned int a2, int a3)
{
  float v3; // s0
  const char *v4; // r3
  unsigned int v5; // r11
  unsigned int v6; // r8
  unsigned int v7; // r2
  unsigned int v8; // r6
  unsigned int v9; // r5
  _QWORD *v10; // r4
  int v11; // r7
  _QWORD *v12; // r4
  unsigned __int8 *v13; // r6
  int v14; // r5
  int v15; // lr
  int v16; // r3
  int v17; // r1
  int v18; // r0
  int v19; // r12
  int v20; // r6
  char v21; // r3
  char v22; // r1
  char v23; // r2
  unsigned int v24; // r3
  size_t nmemb; // [sp+14h] [bp-9E4h]
  int v26; // [sp+18h] [bp-9E0h]
  unsigned int v27; // [sp+24h] [bp-9D4h]
  char v30[4]; // [sp+34h] [bp-9C4h] BYREF
  __int64 v31; // [sp+38h] [bp-9C0h] BYREF
  _QWORD base[49]; // [sp+40h] [bp-9B8h] BYREF
  char s[2096]; // [sp+1C8h] [bp-830h] BYREF

  if ( (unsigned int)dword_7EB9C > 3 )
  {
    v4 = "false";
    if ( a3 )
      v4 = "true";
    snprintf(s, 0x800u, "chain = %d, freq = %g, is_higher_voltage = %s\n", a1, v3, v4);
    sub_2E584(3, s, 0);
  }
  sub_1F0E0(a1, 1, 0, a2);
  v31 = 0LL;
  memset(base, 0, sizeof(base));
  sub_502C0((int)&v31, v30, 0);
  v5 = (unsigned __int8)v30[0];
  BYTE6(v31) = v30[0];
  v27 = BYTE1(v31);
  if ( (unsigned __int8)v31 > 7u )
  {
    nmemb = 0;
    v7 = dword_7EB9C;
  }
  else
  {
    v26 = (unsigned __int8)v31;
    v6 = (unsigned __int8)v31;
    nmemb = 0;
    v7 = dword_7EB9C;
    do
    {
      if ( v27 <= v6 )
      {
        v8 = v27;
        do
        {
          if ( v5 <= 1 )
          {
            v9 = v5;
            v10 = &base[nmemb];
            v11 = v8 * v26 * v5;
            do
            {
              *(_BYTE *)v10 = v6;
              *((_BYTE *)v10 + 1) = v8;
              *((_BYTE *)v10 + 2) = v9;
              *((_DWORD *)v10 + 1) = v11;
              if ( v7 > 4 )
              {
                snprintf(s, 0x800u, "post_div1 = %d, post_div2 = %d, user_div = %d, div_ret = %d\n", v26, v8, v9, v11);
                sub_2E584(4, s, 0);
                v7 = dword_7EB9C;
              }
              ++v9;
              ++v10;
              v11 += v8 * v26;
            }
            while ( (unsigned __int8)v9 <= 1u );
            nmemb += (unsigned __int8)(1 - v5) + 1;
          }
          v8 = (unsigned __int8)(v8 + 1);
        }
        while ( v8 <= v6 );
      }
      v6 = (unsigned __int8)++v26;
    }
    while ( (unsigned __int8)v26 <= 7u );
  }
  if ( v7 > 4 )
  {
    strcpy(s, "\n");
    sub_2E584(4, s, 0);
    if ( (unsigned int)dword_7EB9C > 4 )
    {
      strcpy(s, "sorted\n");
      sub_2E584(4, s, 0);
    }
  }
  qsort(base, nmemb, 8u, (__compar_fn_t)sub_19D50);
  if ( nmemb )
  {
    v12 = base;
    v13 = (unsigned __int8 *)base;
    v14 = 0;
    do
    {
      while ( (unsigned int)dword_7EB9C <= 4 )
      {
        ++v14;
        v13 += 8;
        if ( v14 == nmemb )
          goto LABEL_24;
      }
      v15 = *((_DWORD *)v13 + 1);
      v16 = v14;
      v17 = v13[2];
      v18 = v13[1];
      ++v14;
      v19 = *v13;
      v13 += 8;
      snprintf(s, 0x800u, "[%d] post_div1 = %d, post_div2 = %d, user_div = %d, div_ret = %d\n", v16, v19, v18, v17, v15);
      sub_2E584(4, s, 0);
    }
    while ( v14 != nmemb );
LABEL_24:
    v20 = 0;
    do
    {
      v21 = *((_BYTE *)v12++ + 2);
      v22 = *((_BYTE *)v12 - 8);
      v23 = *((_BYTE *)v12 - 7);
      BYTE6(v31) = v21;
      LOBYTE(v31) = v22;
      BYTE1(v31) = v23;
      v24 = sub_1F080(v31, SHIDWORD(v31));
      if ( dword_7EDCC < v24 )
      {
        if ( (unsigned int)dword_7EB9C > 3 )
        {
          snprintf(
            s,
            0x800u,
            "[%d] _POSTDIV1 = %d, _POSTDIV2 = %d, USER_DIV = %d, freq = %d\n",
            v20,
            (unsigned __int8)v31,
            BYTE1(v31),
            BYTE6(v31),
            v24);
          sub_2E584(3, s, 0);
        }
        sub_1F164(a1, 1, 0, a2, v31, SWORD2(v31));
        usleep((__useconds_t)&unk_F4240);
      }
      ++v20;
    }
    while ( v20 != v14 );
  }
}
// 1A4D8: variable 'v3' is possibly undefined
// 7EB9C: using guessed type int dword_7EB9C;
// 7EDCC: using guessed type int dword_7EDCC;
// 1A470: using guessed type char var_9C4[4];

//----- (0001A870) --------------------------------------------------------
int __fastcall sub_1A870(unsigned int a1, unsigned int a2, unsigned int a3)
{
  float v3; // s0
  int i; // r4
  unsigned int v6; // r3
  unsigned int v7; // r6
  float v8; // s19
  float v9; // s17
  float v10; // s15
  float v11; // s16
  int j; // r4
  int k; // r4
  int result; // r0
  unsigned int v17; // [sp+1Ch] [bp-84Ch]
  char v18[4]; // [sp+24h] [bp-844h] BYREF
  int v19; // [sp+28h] [bp-840h] BYREF
  int v20; // [sp+2Ch] [bp-83Ch]
  char s[2104]; // [sp+30h] [bp-838h] BYREF

  if ( (unsigned int)dword_7EB9C > 4 )
  {
    snprintf(s, 0x800u, "fixed step freq_start = %d, freq_end = %d, freq_step = %.2f\n", a2, a3, v3);
    sub_2E584(4, s, 0);
  }
  for ( i = 0; i != 4; ++i )
  {
    if ( sub_1E29C(i) )
      sub_1F0E0(i, 1, 0, a1);
  }
  if ( a2 < a3 )
    v6 = a3 - a2;
  else
    v6 = a2;
  if ( a2 >= a3 )
    v6 -= a3;
  v17 = (unsigned int)(((float)((float)v6 + v3) - 0.01) / v3);
  if ( v17 )
  {
    v7 = 1;
    v8 = (float)a2;
    v9 = (float)a3;
    do
    {
      v10 = (float)v7;
      v19 = 0;
      v20 = 0;
      if ( a2 >= a3 )
      {
        v11 = v8 - (float)(v10 * v3);
        if ( v9 > v11 )
          v11 = (float)a3;
      }
      else
      {
        v11 = v8 + (float)(v10 * v3);
        if ( v9 < v11 )
          v11 = (float)a3;
      }
      for ( j = 0; j != 4; ++j )
      {
        if ( sub_1E29C(j) )
        {
          sub_502C0((int)&v19, v18, 0);
          BYTE2(v20) = v18[0];
          sub_1F164(j, 1, 0, a1, v19, v20);
          if ( (unsigned int)dword_7EB9C > 4 )
          {
            snprintf(s, 0x800u, "chain = %d set freq to %.2f", j, v11);
            sub_2E584(4, s, 0);
          }
          dword_7F8C4[j] = (int)v11;
          dword_7F8E0[j] = (int)v11;
        }
      }
      ++v7;
      usleep((__useconds_t)&loc_186A0);
    }
    while ( v17 >= v7 );
  }
  for ( k = 0; k != 4; ++k )
  {
    result = sub_1E29C(k);
    if ( result )
    {
      dword_7F8C4[k] = a3;
      dword_7F8E0[k] = a3;
    }
  }
  return result;
}
// 1AABC: variable 'v3' is possibly undefined
// 7EB9C: using guessed type int dword_7EB9C;
// 7F8C4: using guessed type _DWORD dword_7F8C4[4];
// 7F8E0: using guessed type _DWORD dword_7F8E0[4];
// 1A870: using guessed type char var_844[4];

//----- (0001AAE4) --------------------------------------------------------
int __fastcall sub_1AAE4(int a1, unsigned int a2, unsigned int a3, char *a4, char a5)
{
  float v5; // s0
  unsigned int v7; // r7
  float v10; // s18
  const char *v11; // r3
  int result; // r0
  unsigned int v13; // r3
  float v14; // s17
  float v15; // s19
  unsigned int v16; // r4
  float v17; // s16
  float v18; // s0
  unsigned int v19; // [sp+1Ch] [bp-854h]
  char *v20; // [sp+20h] [bp-850h]
  char v21[4]; // [sp+2Ch] [bp-844h] BYREF
  int v22; // [sp+30h] [bp-840h]
  char v23; // [sp+36h] [bp-83Ah]
  char s[2104]; // [sp+38h] [bp-838h] BYREF

  v7 = (unsigned int)a4;
  v10 = v5;
  if ( (unsigned int)dword_7EB9C <= 4 )
    a4 = s;
  if ( (unsigned int)dword_7EB9C > 4 )
  {
    v11 = "false";
    if ( a5 )
      v11 = "true";
    v20 = s;
    snprintf(
      s,
      0x800u,
      "fixed step chain = %d, freq_start = %d, freq_end = %d, freq_step = %.2f, is_higher_voltage = %s\n",
      a1,
      a3,
      v7,
      v5,
      v11);
    sub_2E584(4, s, 0);
  }
  else
  {
    v20 = a4;
  }
  result = sub_1F0E0(a1, 1, 0, a2);
  *((_DWORD *)v20 - 1) = 0;
  v22 = 0;
  if ( a3 >= v7 )
    v13 = a3 - v7;
  else
    v13 = v7 - a3;
  v19 = (unsigned int)(((float)((float)v13 + v5) - 0.01) / v5);
  if ( v19 )
  {
    v14 = (float)v7;
    v15 = (float)a3;
    v16 = 1;
    do
    {
      v18 = (float)v16 * v10;
      if ( a3 < v7 )
      {
        v17 = v18 + v15;
        if ( (float)(v18 + v15) > v14 )
          v17 = (float)v7;
      }
      else
      {
        v17 = v15 - v18;
        if ( (float)(v15 - v18) < v14 )
          v17 = (float)v7;
      }
      sub_502C0((int)(v20 - 8), v21, 0);
      ++v16;
      v23 = v21[0];
      sub_1F164(a1, 1, 0, a2, *((_DWORD *)v20 - 2), *((_DWORD *)v20 - 1));
      if ( (unsigned int)dword_7EB9C > 4 )
      {
        snprintf(v20, 0x800u, "chain = %d set freq to %.2f", a1, v17);
        sub_2E584(4, v20, 0);
      }
      result = usleep((__useconds_t)&loc_186A0);
    }
    while ( v19 >= v16 );
  }
  dword_7F8C4[a1] = v7;
  dword_7F8C4[a1 + 7] = v7;
  return result;
}
// 1AB10: variable 'v5' is possibly undefined
// 7EB9C: using guessed type int dword_7EB9C;
// 7F8C4: using guessed type _DWORD dword_7F8C4[4];
// 1AAE4: using guessed type char var_844[4];

//----- (0001AD08) --------------------------------------------------------
unsigned int __fastcall sub_1AD08(int a1, unsigned int a2, int a3)
{
  float v3; // s0
  size_t v5; // r7
  int v6; // r4
  unsigned int *v7; // r5
  int i; // r6
  int j; // r4
  char *v10; // r3
  int k; // r10
  int v12; // r0
  _DWORD *v13; // r7
  int v14; // r4
  char *v15; // r5
  int v16; // r11
  int v17; // r6
  int m; // r10
  int v19; // r0
  int v20; // r6
  char *v21; // r6
  int v22; // r0
  int v23; // r0
  float v24; // s14
  char *v25; // r3
  unsigned int v26; // s15
  float v27; // s15
  float v28; // s16
  int n; // r6
  int v30; // r8
  int ii; // r4
  int v32; // r5
  float v33; // s15
  char v34; // r0
  unsigned int *v36; // r5
  unsigned int v37; // r2
  char *v38; // r3
  int v39; // r0
  unsigned int *v40; // r2
  int v41; // r1
  char *v42; // r6
  unsigned int v43; // t1
  unsigned int v44; // r5
  int v45; // r0
  int v48; // [sp+18h] [bp-1890h]
  int v49; // [sp+18h] [bp-1890h]
  unsigned int v50; // [sp+20h] [bp-1888h]
  unsigned int v51; // [sp+24h] [bp-1884h]
  unsigned int v52; // [sp+30h] [bp-1878h] BYREF
  char v53[4]; // [sp+34h] [bp-1874h] BYREF
  int v54; // [sp+38h] [bp-1870h]
  int v55; // [sp+3Ch] [bp-186Ch]
  int v56[4]; // [sp+40h] [bp-1868h] BYREF
  int v57[4]; // [sp+50h] [bp-1858h] BYREF
  int base[4]; // [sp+60h] [bp-1848h] BYREF
  int v59[512]; // [sp+70h] [bp-1838h] BYREF
  char s[4152]; // [sp+870h] [bp-1038h] BYREF

  v5 = 0;
  v6 = 0;
  v51 = 0;
  v52 = 0;
  memset(s, 0, 0x1000u);
  memset(v57, 0, sizeof(v57));
  memset(base, 0, sizeof(base));
  v54 = 0;
  v55 = 0;
  memset(v56, 255, sizeof(v56));
  do
  {
    if ( sub_1E29C(v6) )
    {
      v36 = (unsigned int *)(a1 + (v6 << 10));
      sub_19D70(v36, (unsigned int *)&v56[v6], (unsigned int *)&v57[v6], &v52);
      v37 = v57[v6];
      v38 = &s[4 * v5++];
      if ( v51 >= v37 )
        v37 = v51;
      *((_DWORD *)v38 - 516) = v56[v6];
      v51 = v37;
      v39 = sub_1E0F0();
      if ( v39 )
      {
        v40 = &v36[v39];
        v41 = v56[v6];
        v42 = &s[1024 * v6];
        do
        {
          v43 = *v36++;
          *(_DWORD *)v42 = v43 - v41;
          v42 += 4;
        }
        while ( v36 != v40 );
      }
      if ( dword_7EDC8 == 2 )
        dword_7F8C4[v6] = dword_482A6C;
      v44 = v52;
      v45 = sub_1E0F0();
      dword_7F8E0[v6] = sub_5F880(v44, v45);
    }
    ++v6;
  }
  while ( v6 != 4 );
  qsort(base, v5, 4u, (__compar_fn_t)sub_19D60);
  sub_1A470(255, a2, a3);
  if ( base[0] != v51 )
  {
    if ( v5 > 1 )
    {
      v7 = (unsigned int *)base;
      for ( i = 1; i != v5; ++i )
      {
        for ( j = 0; j != 4; ++j )
        {
          if ( sub_1E29C(j) )
          {
            v10 = (char *)v7[1];
            if ( v56[j] >= (unsigned int)v10 )
              sub_1AAE4(j, a2, *v7, v10, a3);
          }
        }
        ++v7;
      }
    }
    for ( k = 0; k != 4; ++k )
    {
      if ( sub_1E29C(k) && v56[k] != v57[k] )
      {
        if ( (unsigned int)dword_7EB9C > 3 )
        {
          snprintf((char *)v59, 0x800u, "chain = %d, start = %d, freq_step = %.2f\n", k, v56[k], v3);
          sub_2E584(3, (const char *)v59, 0);
        }
        v12 = sub_1E0F0();
        v13 = calloc(v12, 8u);
        if ( v13 )
        {
          v14 = 0;
          v15 = &s[1024 * k];
          v59[0] = 0;
          v59[1] = 0;
          v16 = sub_1E0E0();
          if ( v16 )
          {
            v48 = k;
            do
            {
              v17 = sub_1E100();
              if ( v17 )
              {
                for ( m = 0; m != v17; ++m )
                {
                  v19 = m + v14 * sub_1E100();
                  v13[2 * v19 + 1] = *(_DWORD *)&v15[4 * v19];
                  v13[2 * v19] = v19;
                }
              }
              v20 = 8 * v14++;
              v21 = (char *)v13 + sub_1E100() * v20;
              v22 = sub_1E100();
              qsort(v21, v22, 8u, (__compar_fn_t)sub_19D40);
            }
            while ( v16 != v14 );
            k = v48;
          }
          v23 = sub_1E0F0();
          v24 = 0.0;
          if ( v23 )
          {
            v25 = &v15[4 * v23];
            do
            {
              v26 = *(_DWORD *)v15;
              v15 += 4;
              v27 = (float)v26;
              if ( v27 > v24 )
                v24 = v27;
            }
            while ( v25 != v15 );
          }
          if ( (unsigned int)(float)((float)((float)(v3 + v24) - 1.0) / v3) )
          {
            v50 = 0;
            do
            {
              ++v50;
              v49 = sub_1E100();
              v28 = (float)v50 * v3;
              if ( v49 )
              {
                for ( n = 0; n != v49; ++n )
                {
                  v30 = sub_1E0E0();
                  if ( v30 )
                  {
                    for ( ii = 0; ii != v30; ++ii )
                    {
                      v32 = v13[2 * n + 2 * ii * sub_1E100()];
                      v33 = (float)(unsigned int)v13[2 * n + 1 + 2 * ii * sub_1E100()];
                      if ( v28 <= v33 || v3 > (float)(v28 - v33) )
                      {
                        sub_502C0((int)v59, v53, 0);
                        BYTE2(v59[1]) = v53[0];
                        v34 = sub_1E160();
                        sub_1F164(k, 0, (unsigned __int8)(v34 * v32), a2, v59[0], v59[1]);
                      }
                    }
                  }
                  usleep((__useconds_t)&loc_186A0);
                }
              }
            }
            while ( (unsigned int)(float)((float)((float)(v3 + v24) - 1.0) / v3) != v50 );
          }
          free(v13);
        }
        else if ( (unsigned int)dword_7EB9C > 3 )
        {
          strcpy((char *)v59, "failed alloc memory!\n");
          sub_2E584(3, (const char *)v59, 0);
        }
      }
    }
  }
  return v51;
}
// 1AEC0: variable 'v3' is possibly undefined
// 7EB9C: using guessed type int dword_7EB9C;
// 7EDC8: using guessed type int dword_7EDC8;
// 7F8C4: using guessed type _DWORD dword_7F8C4[4];
// 7F8E0: using guessed type _DWORD dword_7F8E0[4];
// 482A6C: using guessed type int dword_482A6C;
// 1AD08: using guessed type char var_1874[4];

//----- (0001B248) --------------------------------------------------------
int __fastcall sub_1B248(int a1, unsigned int a2, int a3)
{
  char v6[4]; // [sp+14h] [bp-81Ch] BYREF
  char s[4]; // [sp+18h] [bp-818h] BYREF
  int v8; // [sp+1Ch] [bp-814h]

  if ( (unsigned int)dword_7EB9C > 3 )
  {
    snprintf(s, 0x800u, "chain = %d, freq = %d\n", a1, a3);
    sub_2E584(3, s, 0);
  }
  *(_DWORD *)s = 0;
  v8 = 0;
  sub_502C0((int)s, v6, 0);
  BYTE2(v8) = v6[0];
  return sub_1F164(a1, 1, 0, a2, *(int *)s, v8);
}
// 7EB9C: using guessed type int dword_7EB9C;
// 1B248: using guessed type char var_81C[4];

//----- (0001B2FC) --------------------------------------------------------
int sub_1B2FC()
{
  unsigned int v0; // r5
  int i; // r4
  int v3; // r5
  unsigned int v4; // [sp+4h] [bp-1Ch] BYREF
  unsigned int v5; // [sp+8h] [bp-18h] BYREF
  int v6; // [sp+Ch] [bp-14h] BYREF

  if ( dword_7EDC8 == 2 )
  {
    v3 = dword_482A6C;
    if ( (unsigned int)dword_482A6C < 0x32 )
      return 50;
    return v3;
  }
  else
  {
    v0 = 50;
    for ( i = 0; i != 4; ++i )
    {
      if ( sub_1E29C(i) )
      {
        sub_19D70(&dword_4FBAA0[256 * i], &v4, &v5, &v6);
        if ( v0 < v5 )
          v0 = v5;
      }
    }
    return v0;
  }
}
// 7EDC8: using guessed type int dword_7EDC8;
// 482A6C: using guessed type int dword_482A6C;
// 4FBAA0: using guessed type unsigned int dword_4FBAA0[1024];

//----- (0001B398) --------------------------------------------------------
int sub_1B398()
{
  int v0; // r6
  size_t v1; // r7
  void *v2; // r5
  void *v3; // r0
  int v4; // r3
  int v5; // r6
  char v7[2072]; // [sp+0h] [bp-818h] BYREF

  v0 = dword_58DFBC;
  v1 = dword_58E004;
  v2 = calloc(dword_58DFBC, 0x210u);
  dword_58E018 = (int)v2;
  if ( v2 )
  {
    v3 = calloc(v1, 8u);
    v5 = (int)v3;
    if ( v3 )
      v4 = 1;
    dword_58E020 = (int)v3;
    if ( v3 )
    {
      dword_58E010 = v4;
      return 0;
    }
    else
    {
      if ( (unsigned int)dword_7EB9C > 3 )
      {
        snprintf(v7, 0x800u, "malloc %d runtime_fan failed\n", v1);
        sub_2E584(3, v7, v5);
        v2 = (void *)dword_58E018;
      }
      free(v2);
      return -2147482624;
    }
  }
  else
  {
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      snprintf(v7, 0x800u, "malloc %d runtime_chain failed\n", v0);
      sub_2E584(3, v7, 0);
    }
    return -2147482624;
  }
}
// 1B3E8: variable 'v4' is possibly undefined
// 7EB9C: using guessed type int dword_7EB9C;
// 58DFBC: using guessed type int dword_58DFBC;
// 58E004: using guessed type int dword_58E004;
// 58E010: using guessed type int dword_58E010;
// 58E018: using guessed type int dword_58E018;
// 58E020: using guessed type int dword_58E020;

//----- (0001B4AC) --------------------------------------------------------
int sub_1B4AC()
{
  char *v0; // r0
  char *v1; // r4
  int v2; // r6
  _DWORD *v3; // r0
  _DWORD *v4; // r7
  unsigned int v5; // r3
  unsigned int *v6; // r3
  unsigned int v7; // r2
  unsigned int v8; // r2
  const char *v10; // r7
  size_t v11; // r0
  char *v12; // r0
  const char *v13; // r6
  _DWORD *v14; // r0
  unsigned int v15; // r3
  const char *v16; // lr
  int v17; // r0
  int v18; // r1
  int v19; // r2
  int v20; // r3
  _DWORD *v21; // lr
  int v22; // r1
  const char *v23; // r0
  _DWORD *v24; // r0
  unsigned int v25; // r3
  const char *v26; // r0
  const char *v27; // r0
  _DWORD *v28; // r0
  _DWORD *v29; // r6
  unsigned int v30; // r3
  _DWORD *v31; // r0
  unsigned int v32; // r3
  const char *v33; // r0
  _DWORD *v34; // r0
  _DWORD *v35; // r6
  unsigned int v36; // r3
  _DWORD *v37; // r0
  unsigned int v38; // r3
  const char *v39; // r12
  int v40; // r0
  int v41; // r1
  int v42; // r2
  int v43; // r3
  int v44; // r12
  const char *v45; // r12
  int v46; // r0
  int v47; // r1
  int v48; // r2
  int v49; // r3
  int v50; // r12
  const char *v51; // r0
  _DWORD *v52; // r0
  _DWORD *v53; // r9
  _DWORD *v54; // r7
  signed int v55; // r7
  _DWORD *v56; // r0
  __int16 v57; // r0
  int v58; // r3
  _DWORD *v59; // r0
  _DWORD *v60; // r0
  int v61; // r0
  int v62; // r0
  _DWORD *v63; // r0
  _DWORD *v64; // r8
  unsigned int v65; // r3
  unsigned int v66; // r6
  const char *v67; // r7
  const char *v68; // r9
  _DWORD *v69; // r0
  _DWORD *v70; // r9
  _DWORD *v71; // r0
  _DWORD *v72; // r7
  const char *v73; // r0
  _DWORD *v74; // r0
  _DWORD *v75; // r7
  _DWORD *v76; // r0
  int v77; // r0
  const char *v78; // r0
  _DWORD *v79; // r0
  _DWORD *v80; // r6
  unsigned int v81; // r3
  _DWORD *v82; // r0
  const char *v83; // r0
  _DWORD *v84; // r0
  _DWORD *v85; // r7
  const char *v86; // r0
  int v87; // r0
  const char *v88; // lr
  int v89; // r0
  int v90; // r1
  int v91; // r2
  int v92; // r3
  _DWORD *v93; // lr
  int v94; // r1
  int v95; // r2
  _DWORD *v96; // r0
  int v97; // r7
  const char *v98; // r0
  int v99; // r0
  _DWORD *v100; // r0
  int v101; // r7
  const char *v102; // r12
  int v103; // r0
  int v104; // r1
  int v105; // r2
  int v106; // r3
  _DWORD *v107; // r12
  int v108; // r1
  int v109; // r2
  int v110; // r3
  int v111; // r0
  _DWORD *v112; // r0
  int v113; // r7
  int v114; // r0
  _DWORD *v115; // r0
  int v116; // r7
  int v117; // r0
  _DWORD *v118; // r0
  int v119; // r6
  int v120; // r0
  _DWORD *v121; // r0
  int v122; // r6
  const char *v123; // r12
  int v124; // r0
  int v125; // r1
  int v126; // r2
  int v127; // r3
  _DWORD *v128; // r12
  int v129; // r1
  _DWORD *v130; // r0
  int v131; // r6
  int v132; // r0
  int v133; // r0
  _DWORD *v134; // r0
  int v135; // r6
  int v136; // r0
  _DWORD *v137; // r0
  int v138; // r6
  int v139; // r0
  _DWORD *v140; // r0
  int v141; // r6
  const char *v142; // lr
  int v143; // r0
  int v144; // r1
  int v145; // r2
  int v146; // r3
  _DWORD *v147; // lr
  int v148; // r1
  int v149; // r2
  int v150; // r0
  _DWORD *v151; // r0
  int v152; // r6
  int v153; // r0
  int v154; // r0
  int v155; // r8
  signed int v156; // r7
  int v157; // r6
  size_t v158; // r10
  signed int v159; // r9
  signed int v160; // r6
  int v161; // r8
  int v162; // r8
  void *v163; // r0
  void *v164; // r0
  int v165; // r0
  signed int i; // r3
  int v167; // r2
  int v168; // r2
  _DWORD *v169; // r0
  _DWORD *v170; // r6
  _DWORD *v171; // r0
  const char *v172; // r0
  _DWORD *v173; // r0
  int v174; // r0
  _DWORD *v175; // r0
  _DWORD *v176; // r8
  const char *v177; // r6
  _DWORD *v178; // r0
  unsigned int j; // r7
  _DWORD *v180; // r0
  _DWORD *v181; // r9
  _DWORD *v182; // r0
  int v183; // r10
  int v184; // r0
  int v185; // r6
  int v186; // r6
  _DWORD *v187; // r0
  const char *v188; // r0
  _DWORD *v189; // r0
  int v190; // r10
  int v191; // r0
  _DWORD *v192; // r0
  _DWORD *v193; // r10
  const char *v194; // r0
  const char *v195; // r0
  int v196; // r0
  char v197; // r3
  _DWORD *v198; // r0
  _DWORD *v199; // r0
  _DWORD *v200; // r6
  _DWORD *v201; // r0
  const char *v202; // r0
  _DWORD *v203; // r0
  int v204; // r0
  _DWORD *v205; // r0
  _DWORD *v206; // r7
  _DWORD *v207; // r0
  unsigned int k; // r6
  _DWORD *v209; // r0
  _DWORD *v210; // r9
  _DWORD *v211; // r0
  int v212; // r8
  int v213; // r0
  int v214; // r10
  int v215; // r8
  _DWORD *v216; // r0
  const char *v217; // r0
  _DWORD *v218; // r0
  int v219; // r9
  int v220; // r0
  _DWORD *v221; // r0
  unsigned int v222; // r7
  _DWORD *v223; // r0
  _DWORD *v224; // r4
  _DWORD *v225; // r0
  int v226; // r0
  _DWORD *v227; // r0
  _DWORD *v228; // r6
  int v229; // r6
  const void *v230; // r7
  int v231; // r3
  unsigned int m; // r10
  _DWORD *v233; // r0
  _DWORD *v234; // r4
  _DWORD *v235; // r0
  int v236; // r8
  int v237; // r0
  int v238; // r2
  _DWORD *v239; // r0
  int v240; // r4
  int v241; // r4
  _DWORD *v242; // r0
  _DWORD *v243; // r8
  _DWORD *v244; // r0
  int v245; // r9
  int v246; // r0
  _DWORD *v247; // r0
  int v248; // r8
  int v249; // r0
  int n; // r9
  int v251; // r6
  int v252; // r7
  char v253; // r3
  char *v254; // [sp+10h] [bp-940h]
  char *v255; // [sp+10h] [bp-940h]
  char *format; // [sp+14h] [bp-93Ch]
  char *formata; // [sp+14h] [bp-93Ch]
  char formatb; // [sp+14h] [bp-93Ch]
  char *v259; // [sp+18h] [bp-938h]
  int v260; // [sp+20h] [bp-930h]
  char v261[252]; // [sp+2Ch] [bp-924h] BYREF
  char s[2088]; // [sp+128h] [bp-828h] BYREF

  v0 = (char *)sub_4D6E4("/etc/topol.conf", 0, v261);
  v1 = v0;
  if ( v0 && !*(_DWORD *)v0 )
  {
    v3 = (_DWORD *)sub_4E234(v0, "machine");
    v4 = v3;
    if ( !v3 )
    {
      v5 = dword_7EB9C;
      goto LABEL_9;
    }
    v5 = dword_7EB9C;
    if ( *v3 != 2 )
    {
LABEL_9:
      if ( v5 <= 3 )
        goto LABEL_10;
      strcpy(s, "get machine failed\n");
      sub_2E584(3, s, 0);
LABEL_18:
      if ( (unsigned int)dword_7EB9C > 3 )
      {
        v2 = -1;
        strcpy(s, "parse machine failed\n");
        sub_2E584(3, s, 0);
        goto LABEL_11;
      }
      goto LABEL_10;
    }
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      v23 = (const char *)sub_4E768(v3);
      snprintf(s, 0x800u, "load machine %s conf\n", v23);
      sub_2E584(3, s, 0);
    }
    v10 = (const char *)sub_4E768(v4);
    v11 = strlen(v10);
    v12 = (char *)calloc(v11 + 1, 1u);
    v13 = v12;
    dword_58DFB8 = (int)v12;
    if ( !v12 )
    {
      if ( (unsigned int)dword_7EB9C <= 3 )
        goto LABEL_10;
      strcpy(s, "get machine failed, Cannot allocate space\n");
      sub_2E584(3, s, 0);
      goto LABEL_18;
    }
    strcpy(v12, v10);
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      snprintf(s, 0x800u, "machine : %s \n", v13);
      sub_2E584(3, s, 0);
    }
    v14 = (_DWORD *)sub_4E234(v1, "hw_version");
    if ( !v14 )
    {
      v15 = dword_7EB9C;
LABEL_28:
      if ( v15 <= 3 )
        goto LABEL_10;
      v16 = "get hw_version failed\n";
LABEL_31:
      v17 = *(_DWORD *)v16;
      v18 = *((_DWORD *)v16 + 1);
      v19 = *((_DWORD *)v16 + 2);
      v20 = *((_DWORD *)v16 + 3);
      v21 = v16 + 16;
      *(_DWORD *)s = v17;
      *(_DWORD *)&s[4] = v18;
      *(_DWORD *)&s[8] = v19;
      *(_DWORD *)&s[12] = v20;
      v22 = v21[1];
      *(_DWORD *)&s[16] = *v21;
      *(_WORD *)&s[20] = v22;
      s[22] = BYTE2(v22);
      sub_2E584(3, s, 0);
      goto LABEL_18;
    }
    v15 = dword_7EB9C;
    if ( *v14 != 2 )
      goto LABEL_28;
    if ( (unsigned int)dword_7EB9C > 4 )
    {
      v26 = (const char *)sub_4E768(v14);
      snprintf(s, 0x800u, "hw_version: %s\n", v26);
      sub_2E584(4, s, 0);
    }
    v24 = (_DWORD *)sub_4E234(v1, "sw_version");
    if ( !v24 )
    {
      v25 = dword_7EB9C;
LABEL_39:
      if ( v25 <= 3 )
        goto LABEL_10;
      v16 = "get sw_version failed\n";
      goto LABEL_31;
    }
    v25 = dword_7EB9C;
    if ( *v24 != 2 )
      goto LABEL_39;
    if ( (unsigned int)dword_7EB9C > 4 )
    {
      v27 = (const char *)sub_4E768(v24);
      snprintf(s, 0x800u, "sw_version: %s\n", v27);
      sub_2E584(4, s, 0);
    }
    v28 = (_DWORD *)sub_4E234(v1, "processor");
    v29 = v28;
    if ( !v28 )
    {
      v30 = dword_7EB9C;
LABEL_55:
      if ( v30 <= 3 )
        goto LABEL_10;
      strcpy(s, "get processor failed\n");
      sub_2E584(3, s, 0);
      goto LABEL_53;
    }
    v30 = dword_7EB9C;
    if ( *v28 )
      goto LABEL_55;
    if ( (unsigned int)dword_7EB9C > 4 )
    {
      strcpy(s, "processor:\n");
      sub_2E584(4, s, 0);
    }
    v31 = (_DWORD *)sub_4E234(v29, "type");
    if ( !v31 )
    {
      v32 = dword_7EB9C;
LABEL_51:
      if ( v32 <= 3 )
        goto LABEL_10;
      strcpy(s, "get type failed\n");
      sub_2E584(3, s, 0);
LABEL_53:
      if ( (unsigned int)dword_7EB9C > 3 )
      {
        v2 = -1;
        strcpy(s, "parse processor failed\n");
        sub_2E584(3, s, 0);
        goto LABEL_11;
      }
      goto LABEL_10;
    }
    v32 = dword_7EB9C;
    if ( *v31 != 2 )
      goto LABEL_51;
    if ( (unsigned int)dword_7EB9C > 4 )
    {
      v33 = (const char *)sub_4E768(v31);
      snprintf(s, 0x800u, "type: %s\n", v33);
      sub_2E584(4, s, 0);
    }
    v34 = (_DWORD *)sub_4E234(v1, "power");
    v35 = v34;
    if ( !v34 )
    {
      v36 = dword_7EB9C;
LABEL_74:
      if ( v36 <= 3 )
        goto LABEL_10;
      strcpy(s, "get power failed\n");
      sub_2E584(3, s, 0);
      goto LABEL_71;
    }
    v36 = dword_7EB9C;
    if ( *v34 )
      goto LABEL_74;
    if ( (unsigned int)dword_7EB9C > 4 )
    {
      strcpy(s, "power:\n");
      sub_2E584(4, s, 0);
    }
    v37 = (_DWORD *)sub_4E234(v35, "type");
    if ( !v37 )
    {
      v38 = dword_7EB9C;
LABEL_67:
      if ( v38 <= 3 )
        goto LABEL_10;
      v39 = "get type failed\n";
LABEL_70:
      v40 = *(_DWORD *)v39;
      v41 = *((_DWORD *)v39 + 1);
      v42 = *((_DWORD *)v39 + 2);
      v43 = *((_DWORD *)v39 + 3);
      v44 = *((_DWORD *)v39 + 4);
      *(_DWORD *)s = v40;
      *(_DWORD *)&s[4] = v41;
      *(_DWORD *)&s[8] = v42;
      *(_DWORD *)&s[12] = v43;
      s[16] = v44;
      sub_2E584(3, s, 0);
LABEL_71:
      if ( (unsigned int)dword_7EB9C <= 3 )
        goto LABEL_10;
      v45 = "parse power failed\n";
      goto LABEL_73;
    }
    v38 = dword_7EB9C;
    if ( *v37 != 2 )
      goto LABEL_67;
    if ( (unsigned int)dword_7EB9C > 4 )
    {
      v51 = (const char *)sub_4E768(v37);
      snprintf(s, 0x800u, "type: %s\n", v51);
      sub_2E584(4, s, 0);
    }
    v52 = (_DWORD *)sub_4E234(v35, "version");
    v53 = v52;
    if ( !v52 || *v52 != 1 )
    {
      if ( (unsigned int)dword_7EB9C <= 3 )
        goto LABEL_10;
      strcpy(s, "get version array failed\n");
      sub_2E584(3, s, 0);
      goto LABEL_71;
    }
    v54 = sub_4E5A0(v52);
    dword_58E038 = (int)v54;
    dword_58E03C = (int)calloc((size_t)v54, 2u);
    if ( (int)v54 > 0 )
    {
      v55 = 0;
      do
      {
        v56 = sub_4E5BC(v53, v55);
        v57 = sub_4E9C4((int)v56);
        v58 = 2 * v55++;
        *(_WORD *)(dword_58E03C + v58) = v57;
        if ( (unsigned int)dword_7EB9C > 4 )
        {
          snprintf(s, 0x800u, "psu version = 0x%x", *(unsigned __int16 *)(dword_58E03C + v58));
          sub_2E584(4, s, 0);
        }
      }
      while ( v55 < dword_58E038 );
    }
    v59 = (_DWORD *)sub_4E234(v35, "i2c_addr");
    if ( !v59 || *v59 != 3 )
    {
      if ( (unsigned int)dword_7EB9C <= 3 )
        goto LABEL_10;
      strcpy(s, "get i2c_addr failed\n");
      sub_2E584(3, s, 0);
      goto LABEL_71;
    }
    if ( (unsigned int)dword_7EB9C > 4 )
    {
      v61 = sub_4E9C4((int)v59);
      snprintf(s, 0x800u, "i2c_addr: %d\n", v61);
      sub_2E584(4, s, 0);
    }
    v60 = (_DWORD *)sub_4E234(v35, "gpio");
    if ( !v60 || *v60 != 3 )
    {
      if ( (unsigned int)dword_7EB9C <= 3 )
        goto LABEL_10;
      v39 = "get gpio failed\n";
      goto LABEL_70;
    }
    if ( (unsigned int)dword_7EB9C > 4 )
    {
      v62 = sub_4E9C4((int)v60);
      snprintf(s, 0x800u, "gpio: %d\n", v62);
      sub_2E584(4, s, 0);
    }
    v63 = (_DWORD *)sub_4E234(v1, "fan");
    v64 = v63;
    if ( !v63 )
    {
      v65 = dword_7EB9C;
LABEL_102:
      if ( v65 <= 3 )
        goto LABEL_10;
      strcpy(s, "get fan failed\n");
      sub_2E584(3, s, 0);
      goto LABEL_104;
    }
    v65 = dword_7EB9C;
    if ( *v63 != 1 )
      goto LABEL_102;
    if ( (unsigned int)dword_7EB9C > 4 )
    {
      strcpy(s, "fan:\n");
      sub_2E584(4, s, 0);
    }
    v66 = 0;
    v67 = 0;
    v68 = 0;
    while ( v66 < (unsigned int)sub_4E5A0(v64) )
    {
      v74 = sub_4E5BC(v64, v66);
      v75 = v74;
      if ( !v74 || *v74 )
      {
        if ( (unsigned int)dword_7EB9C <= 3 )
          goto LABEL_10;
        snprintf(s, 0x800u, "get array %d failed\n", v66);
LABEL_127:
        sub_2E584(3, s, 0);
LABEL_104:
        if ( (unsigned int)dword_7EB9C > 3 )
        {
          v2 = -1;
          strcpy(s, "parse fan failed\n");
          sub_2E584(3, s, 0);
          goto LABEL_11;
        }
        goto LABEL_10;
      }
      v76 = (_DWORD *)sub_4E234(v74, "id");
      if ( !v76 || *v76 != 3 )
      {
        if ( (unsigned int)dword_7EB9C <= 3 )
          goto LABEL_10;
        snprintf(s, 0x800u, "get arrya %d id failed\n", v66);
        goto LABEL_127;
      }
      if ( (unsigned int)dword_7EB9C > 4 )
      {
        v77 = sub_4E9C4((int)v76);
        snprintf(s, 0x800u, "id: %d\n", v77);
        sub_2E584(4, s, 0);
      }
      v69 = (_DWORD *)sub_4E234(v75, "position");
      v70 = v69;
      if ( !v69 || *v69 != 2 )
      {
        if ( (unsigned int)dword_7EB9C <= 3 )
          goto LABEL_10;
        snprintf(s, 0x800u, "get arrya %d position failed\n", v66);
        goto LABEL_127;
      }
      if ( (unsigned int)dword_7EB9C > 4 )
      {
        v78 = (const char *)sub_4E768(v69);
        snprintf(s, 0x800u, "position: %s\n", v78);
        sub_2E584(4, s, 0);
      }
      v68 = (const char *)sub_4E768(v70);
      v71 = (_DWORD *)sub_4E234(v75, "direction");
      v72 = v71;
      if ( !v71 || *v71 != 2 )
      {
        if ( (unsigned int)dword_7EB9C <= 3 )
          goto LABEL_10;
        snprintf(s, 0x800u, "get arrya%d direction failed\n", v66);
        goto LABEL_127;
      }
      if ( (unsigned int)dword_7EB9C > 4 )
      {
        v73 = (const char *)sub_4E768(v71);
        snprintf(s, 0x800u, "direction: %s\n", v73);
        sub_2E584(4, s, 0);
      }
      ++v66;
      v67 = (const char *)sub_4E768(v72);
      ++dword_58E004;
    }
    if ( !strncmp(v68, "right", 5u) )
    {
      if ( strncmp(v67, "in", 2u) )
      {
        if ( strncmp(v68, "left", 4u) )
        {
          if ( strncmp(v67, "out", 2u) )
          {
LABEL_138:
            if ( (unsigned int)dword_7EB9C <= 3 )
              goto LABEL_10;
            snprintf(s, 0x800u, "unkonwn wind position %s, direction %s\n", v68, v67);
            sub_2E584(3, s, 0);
            goto LABEL_104;
          }
          goto LABEL_143;
        }
        if ( strncmp(v67, "out", 2u) )
          goto LABEL_138;
      }
    }
    else
    {
      if ( strncmp(v68, "left", 4u) )
        goto LABEL_138;
      if ( strncmp(v67, "out", 2u) )
      {
        if ( strncmp(v67, "in", 2u) )
          goto LABEL_138;
LABEL_143:
        dword_58E000 = 1;
LABEL_144:
        v79 = (_DWORD *)sub_4E234(v1, "asic");
        v80 = v79;
        if ( !v79 )
        {
          v81 = dword_7EB9C;
LABEL_155:
          if ( v81 <= 3 )
            goto LABEL_10;
          strcpy(s, "get asic failed\n");
          sub_2E584(3, s, 0);
          goto LABEL_153;
        }
        v81 = dword_7EB9C;
        if ( *v79 )
          goto LABEL_155;
        if ( (unsigned int)dword_7EB9C > 4 )
        {
          strcpy(s, "asic:\n");
          sub_2E584(4, s, 0);
        }
        v82 = (_DWORD *)sub_4E234(v80, "asic_id");
        if ( !v82 || *v82 != 2 )
        {
          if ( (unsigned int)dword_7EB9C <= 3 )
            goto LABEL_10;
          strcpy(s, "get asic_id failed\n");
          sub_2E584(3, s, 0);
LABEL_153:
          if ( (unsigned int)dword_7EB9C > 3 )
          {
            v2 = -1;
            strcpy(s, "parse asic failed\n");
            sub_2E584(3, s, 0);
            goto LABEL_11;
          }
          goto LABEL_10;
        }
        if ( (unsigned int)dword_7EB9C > 4 )
        {
          v83 = (const char *)sub_4E768(v82);
          snprintf(s, 0x800u, "asic_id: %s\n", v83);
          sub_2E584(4, s, 0);
        }
        v84 = (_DWORD *)sub_4E234(v80, "asic_addr");
        v85 = v84;
        if ( !v84 || *v84 != 2 )
        {
          if ( (unsigned int)dword_7EB9C <= 3 )
            goto LABEL_10;
          strcpy(s, "get asic_addr failed\n");
          sub_2E584(3, s, 0);
          goto LABEL_153;
        }
        if ( (unsigned int)dword_7EB9C > 4 )
        {
          v98 = (const char *)sub_4E768(v84);
          snprintf(s, 0x800u, "asic_addr : %s\n", v98);
          sub_2E584(4, s, 0);
        }
        v86 = (const char *)sub_4E768(v85);
        v87 = strtol(v86, 0, 0);
        dword_58DFD8 = v87;
        if ( !v87 )
        {
          if ( (unsigned int)dword_7EB9C <= 3 )
            goto LABEL_10;
          v88 = "convert asic_addr failed\n";
          goto LABEL_168;
        }
        if ( (unsigned int)dword_7EB9C > 4 )
        {
          snprintf(s, 0x800u, "asic_addr 0x%x\n", v87);
          sub_2E584(4, s, 0);
        }
        v96 = (_DWORD *)sub_4E234(v80, "asic_core_num");
        v97 = (int)v96;
        if ( !v96 || *v96 != 3 )
        {
          if ( (unsigned int)dword_7EB9C <= 3 )
            goto LABEL_10;
          v88 = "get asic_core_num failed\n";
LABEL_168:
          v89 = *(_DWORD *)v88;
          v90 = *((_DWORD *)v88 + 1);
          v91 = *((_DWORD *)v88 + 2);
          v92 = *((_DWORD *)v88 + 3);
          v93 = v88 + 16;
          *(_DWORD *)s = v89;
          *(_DWORD *)&s[4] = v90;
          *(_DWORD *)&s[8] = v91;
          *(_DWORD *)&s[12] = v92;
          v94 = v93[1];
          v95 = v93[2];
          *(_DWORD *)&s[16] = *v93;
          *(_DWORD *)&s[20] = v94;
          *(_WORD *)&s[24] = v95;
          sub_2E584(3, s, 0);
          goto LABEL_153;
        }
        if ( (unsigned int)dword_7EB9C > 4 )
        {
          v99 = sub_4E9C4((int)v96);
          snprintf(s, 0x800u, "asic_core_num: %d\n", v99);
          sub_2E584(4, s, 0);
        }
        dword_58DFDC = sub_4E9C4(v97);
        v100 = (_DWORD *)sub_4E234(v80, "asic_small_core_num");
        v101 = (int)v100;
        if ( !v100 || *v100 != 3 )
        {
          if ( (unsigned int)dword_7EB9C <= 3 )
            goto LABEL_10;
          v102 = "get asic_small_core_num failed\n";
          goto LABEL_183;
        }
        if ( (unsigned int)dword_7EB9C > 4 )
        {
          v111 = sub_4E9C4((int)v100);
          snprintf(s, 0x800u, "asic_small_core_num: %d\n", v111);
          sub_2E584(4, s, 0);
        }
        dword_58DFE0 = sub_4E9C4(v101);
        v112 = (_DWORD *)sub_4E234(v80, "core_small_core_num");
        v113 = (int)v112;
        if ( !v112 || *v112 != 3 )
        {
          if ( (unsigned int)dword_7EB9C <= 3 )
            goto LABEL_10;
          v102 = "get core_small_core_num failed\n";
LABEL_183:
          v103 = *(_DWORD *)v102;
          v104 = *((_DWORD *)v102 + 1);
          v105 = *((_DWORD *)v102 + 2);
          v106 = *((_DWORD *)v102 + 3);
          v107 = v102 + 16;
          *(_DWORD *)s = v103;
          *(_DWORD *)&s[4] = v104;
          *(_DWORD *)&s[8] = v105;
          *(_DWORD *)&s[12] = v106;
          v108 = v107[1];
          v109 = v107[2];
          v110 = v107[3];
          *(_DWORD *)&s[16] = *v107;
          *(_DWORD *)&s[20] = v108;
          *(_DWORD *)&s[24] = v109;
          *(_DWORD *)&s[28] = v110;
          sub_2E584(3, s, 0);
          goto LABEL_153;
        }
        if ( (unsigned int)dword_7EB9C > 4 )
        {
          v114 = sub_4E9C4((int)v112);
          snprintf(s, 0x800u, "core_small_core_num: %d\n", v114);
          sub_2E584(4, s, 0);
        }
        dword_58DFE4 = sub_4E9C4(v113);
        v115 = (_DWORD *)sub_4E234(v80, "asic_domain_num");
        v116 = (int)v115;
        if ( !v115 || *v115 != 3 )
        {
          if ( (unsigned int)dword_7EB9C <= 3 )
            goto LABEL_10;
          strcpy(s, "get asic_domain_num failed\n");
          sub_2E584(3, s, 0);
          goto LABEL_153;
        }
        if ( (unsigned int)dword_7EB9C > 4 )
        {
          v117 = sub_4E9C4((int)v115);
          snprintf(s, 0x800u, "asic_domain_num : %d\n", v117);
          sub_2E584(4, s, 0);
        }
        dword_58DFE8 = sub_4E9C4(v116);
        v118 = (_DWORD *)sub_4E234(v80, "asic_addr_interval");
        v119 = (int)v118;
        if ( !v118 || *v118 != 3 )
        {
          if ( (unsigned int)dword_7EB9C <= 3 )
            goto LABEL_10;
          strcpy(s, "get asic_addr_interval failed\n");
          sub_2E584(3, s, 0);
          goto LABEL_153;
        }
        if ( (unsigned int)dword_7EB9C > 4 )
        {
          v120 = sub_4E9C4((int)v118);
          snprintf(s, 0x800u, "asic_addr_interval : %d\n", v120);
          sub_2E584(4, s, 0);
        }
        dword_58DFEC = sub_4E9C4(v119);
        v254 = (char *)sub_4E234(v1, "chain");
        if ( !v254 || *(_DWORD *)v254 )
        {
          if ( (unsigned int)dword_7EB9C <= 3 )
            goto LABEL_10;
          strcpy(s, "get chain failed\n");
          sub_2E584(3, s, 0);
          goto LABEL_213;
        }
        if ( (unsigned int)dword_7EB9C > 4 )
        {
          strcpy(s, "chain:\n");
          sub_2E584(4, s, 0);
        }
        v121 = (_DWORD *)sub_4E234(v254, "chain_num");
        v122 = (int)v121;
        if ( !v121 || *v121 != 3 )
        {
          if ( (unsigned int)dword_7EB9C <= 3 )
            goto LABEL_10;
          v123 = "get chain_num failed\n";
          goto LABEL_212;
        }
        if ( (unsigned int)dword_7EB9C > 4 )
        {
          v132 = sub_4E9C4((int)v121);
          snprintf(s, 0x800u, "chain_num : %d\n", v132);
          sub_2E584(4, s, 0);
        }
        dword_58DFBC = sub_4E9C4(v122);
        v130 = (_DWORD *)sub_4E234(v254, "chain_row");
        v131 = (int)v130;
        if ( !v130 || *v130 != 3 )
        {
          if ( (unsigned int)dword_7EB9C <= 3 )
            goto LABEL_10;
          v123 = "get chain_row failed\n";
LABEL_212:
          v124 = *(_DWORD *)v123;
          v125 = *((_DWORD *)v123 + 1);
          v126 = *((_DWORD *)v123 + 2);
          v127 = *((_DWORD *)v123 + 3);
          v128 = v123 + 16;
          *(_DWORD *)s = v124;
          *(_DWORD *)&s[4] = v125;
          *(_DWORD *)&s[8] = v126;
          *(_DWORD *)&s[12] = v127;
          v129 = v128[1];
          *(_DWORD *)&s[16] = *v128;
          *(_WORD *)&s[20] = v129;
          sub_2E584(3, s, 0);
          goto LABEL_213;
        }
        if ( (unsigned int)dword_7EB9C > 4 )
        {
          v133 = sub_4E9C4((int)v130);
          snprintf(s, 0x800u, "chain_row: %d\n", v133);
          sub_2E584(4, s, 0);
        }
        dword_58DFC0 = sub_4E9C4(v131);
        v134 = (_DWORD *)sub_4E234(v254, "chain_column");
        v135 = (int)v134;
        if ( !v134 || *v134 != 3 )
        {
          if ( (unsigned int)dword_7EB9C <= 3 )
            goto LABEL_10;
          strcpy(s, "get chain_column failed\n");
          sub_2E584(3, s, 0);
          goto LABEL_213;
        }
        if ( (unsigned int)dword_7EB9C > 4 )
        {
          v136 = sub_4E9C4((int)v134);
          snprintf(s, 0x800u, "chain_column: %d\n", v136);
          sub_2E584(4, s, 0);
        }
        dword_58DFC4 = sub_4E9C4(v135);
        v137 = (_DWORD *)sub_4E234(v254, "chain_domain_num");
        v138 = (int)v137;
        if ( !v137 || *v137 != 3 )
        {
          if ( (unsigned int)dword_7EB9C <= 3 )
            goto LABEL_10;
          strcpy(s, "get chain_domain_num failed\n");
          sub_2E584(3, s, 0);
          goto LABEL_213;
        }
        if ( (unsigned int)dword_7EB9C > 4 )
        {
          v139 = sub_4E9C4((int)v137);
          snprintf(s, 0x800u, "chain_domain_num : %d\n", v139);
          sub_2E584(4, s, 0);
        }
        dword_58DFC8 = sub_4E9C4(v138);
        v140 = (_DWORD *)sub_4E234(v254, "chain_asic_num");
        v141 = (int)v140;
        if ( !v140 || *v140 != 3 )
        {
          if ( (unsigned int)dword_7EB9C <= 3 )
            goto LABEL_10;
          v142 = "get chain_asic_num failed\n";
          goto LABEL_241;
        }
        if ( (unsigned int)dword_7EB9C > 4 )
        {
          v150 = sub_4E9C4((int)v140);
          snprintf(s, 0x800u, "chain_asic_num : %d\n", v150);
          sub_2E584(4, s, 0);
        }
        dword_58DFCC = sub_4E9C4(v141);
        v151 = (_DWORD *)sub_4E234(v254, "domain_asic_num");
        v152 = (int)v151;
        if ( !v151 || *v151 != 3 )
        {
          if ( (unsigned int)dword_7EB9C <= 3 )
            goto LABEL_10;
          strcpy(s, "get domain_asic_num failed\n");
          sub_2E584(3, s, 0);
          goto LABEL_213;
        }
        if ( (unsigned int)dword_7EB9C > 4 )
        {
          v153 = sub_4E9C4((int)v151);
          snprintf(s, 0x800u, "domain_asic_num : %d\n", v153);
          sub_2E584(4, s, 0);
        }
        v154 = sub_4E9C4(v152);
        v155 = v154;
        dword_58DFD0 = v154;
        v156 = dword_58DFBC;
        v157 = dword_58DFC8;
        v158 = dword_58DFCC;
        if ( (unsigned int)dword_7EB9C > 3 )
        {
          snprintf(
            s,
            0x800u,
            "chain_num %d, chain_domain_num %d, chain_asic_num %d, domain_asic_num %d\n",
            dword_58DFBC,
            dword_58DFC8,
            dword_58DFCC,
            v154);
          sub_2E584(3, s, 0);
        }
        dword_58DFF0 = (int)calloc(v156, 0x14u);
        if ( !dword_58DFF0 )
        {
          if ( (unsigned int)dword_7EB9C <= 3 )
            goto LABEL_10;
          snprintf(s, 0x800u, "malloc %d chain_t failed\n", v156);
          goto LABEL_262;
        }
        v159 = v157;
        format = (char *)(28 * v155);
        v160 = 0;
        v259 = (char *)(-28 * v155);
        while ( v156 > v160 )
        {
          v161 = dword_58DFF0;
          *(_DWORD *)(dword_58DFF0 + 20 * v160) = v160;
          v162 = v161 + 20 * v160;
          v163 = calloc(v159, 8u);
          *(_DWORD *)(v162 + 12) = v163;
          if ( !v163 )
          {
            if ( (unsigned int)dword_7EB9C <= 3 )
              goto LABEL_10;
            snprintf(s, 0x800u, "malloc %d domain_t failed\n", v159);
LABEL_262:
            sub_2E584(3, s, 0);
            if ( (unsigned int)dword_7EB9C <= 3 )
              goto LABEL_10;
            strcpy(s, "alloc topol failed\n");
            sub_2E584(3, s, 0);
            goto LABEL_213;
          }
          v164 = calloc(v158, 0x1Cu);
          *(_DWORD *)(v162 + 8) = v164;
          if ( !v164 )
          {
            if ( (unsigned int)dword_7EB9C <= 3 )
              goto LABEL_10;
            snprintf(s, 0x800u, "malloc %d asic_t failed\n", v158);
            goto LABEL_262;
          }
          v165 = 0;
          for ( i = 0; ; ++i )
          {
            v165 += (int)format;
            if ( v159 <= i )
              break;
            v167 = *(_DWORD *)(v162 + 12);
            *(_DWORD *)(v167 + 8 * i) = i;
            v168 = v167 + 8 * i;
            *(_DWORD *)(v168 + 4) = &v259[v165 + *(_DWORD *)(v162 + 8)];
          }
          ++v160;
        }
        v169 = (_DWORD *)sub_4E234(v254, "pic");
        v170 = v169;
        if ( !v169 || *v169 )
        {
          if ( (unsigned int)dword_7EB9C <= 3 )
            goto LABEL_10;
          strcpy(s, "get pic failed\n");
          sub_2E584(3, s, 0);
          goto LABEL_273;
        }
        if ( (unsigned int)dword_7EB9C > 4 )
        {
          strcpy(s, "pic:\n");
          sub_2E584(4, s, 0);
        }
        v171 = (_DWORD *)sub_4E234(v170, "type");
        if ( !v171 || *v171 != 2 )
        {
          if ( (unsigned int)dword_7EB9C <= 3 )
            goto LABEL_10;
          strcpy(s, "get type failed\n");
          sub_2E584(3, s, 0);
          goto LABEL_273;
        }
        if ( (unsigned int)dword_7EB9C > 4 )
        {
          v172 = (const char *)sub_4E768(v171);
          snprintf(s, 0x800u, "type: %s\n", v172);
          sub_2E584(4, s, 0);
        }
        v173 = (_DWORD *)sub_4E234(v170, "i2c_addr");
        if ( !v173 || *v173 != 3 )
        {
          if ( (unsigned int)dword_7EB9C <= 3 )
            goto LABEL_10;
          strcpy(s, "get i2c_addr failed\n");
          sub_2E584(3, s, 0);
          goto LABEL_273;
        }
        if ( (unsigned int)dword_7EB9C > 4 )
        {
          v174 = sub_4E9C4((int)v173);
          snprintf(s, 0x800u, "i2c_addr: %d\n", v174);
          sub_2E584(4, s, 0);
        }
        v175 = (_DWORD *)sub_4E234(v170, "sensor");
        v176 = v175;
        if ( v175 && *v175 == 1 )
        {
          if ( (unsigned int)dword_7EB9C > 4 )
          {
            strcpy(s, "pic sensor:\n");
            sub_2E584(4, s, 0);
          }
          dword_58DFF8 = (int)sub_4E5A0(v176);
          v178 = sub_4E5A0(v176);
          dword_58DFFC = (int)calloc((size_t)v178, 0xCu);
          if ( dword_58DFFC )
          {
            for ( j = 0; ; ++j )
            {
              if ( j >= (unsigned int)sub_4E5A0(v176) )
                goto LABEL_338;
              v180 = sub_4E5BC(v176, j);
              v181 = v180;
              if ( !v180 || *v180 )
              {
                if ( (unsigned int)dword_7EB9C <= 3 )
                  goto LABEL_10;
                snprintf(s, 0x800u, "get array %d failed\n", j);
                goto LABEL_327;
              }
              v182 = (_DWORD *)sub_4E234(v180, "index");
              v183 = (int)v182;
              if ( !v182 || *v182 != 3 )
              {
                if ( (unsigned int)dword_7EB9C <= 3 )
                  goto LABEL_10;
                snprintf(s, 0x800u, "get array %d index failed\n", j);
                goto LABEL_327;
              }
              if ( (unsigned int)dword_7EB9C > 4 )
              {
                v184 = sub_4E9C4((int)v182);
                snprintf(s, 0x800u, "index: %d\n", v184);
                sub_2E584(4, s, 0);
              }
              v260 = dword_58DFFC;
              v185 = 12 * sub_4E9C4(v183);
              *(_DWORD *)(v260 + v185) = sub_4E9C4(v183);
              v186 = v260 + v185;
              v187 = (_DWORD *)sub_4E234(v181, "type");
              if ( !v187 || *v187 != 2 )
              {
                if ( (unsigned int)dword_7EB9C <= 3 )
                  goto LABEL_10;
                snprintf(s, 0x800u, "get array %d type failed\n", j);
                goto LABEL_327;
              }
              if ( (unsigned int)dword_7EB9C > 4 )
              {
                v188 = (const char *)sub_4E768(v187);
                snprintf(s, 0x800u, "type: %s\n", v188);
                sub_2E584(4, s, 0);
              }
              v189 = (_DWORD *)sub_4E234(v181, "iic");
              v190 = (int)v189;
              if ( !v189 || *v189 != 3 )
              {
                if ( (unsigned int)dword_7EB9C <= 3 )
                  goto LABEL_10;
                snprintf(s, 0x800u, "get array %d bind_asic failed\n", j);
                goto LABEL_327;
              }
              if ( (unsigned int)dword_7EB9C > 4 )
              {
                v191 = sub_4E9C4((int)v189);
                snprintf(s, 0x800u, "iic: %d\n", v191);
                sub_2E584(4, s, 0);
              }
              *(_DWORD *)(v186 + 4) = sub_4E9C4(v190);
              v192 = (_DWORD *)sub_4E234(v181, "x");
              v193 = v192;
              if ( !v192 || *v192 != 2 )
                break;
              if ( (unsigned int)dword_7EB9C > 4 )
              {
                v194 = (const char *)sub_4E768(v192);
                snprintf(s, 0x800u, "x: %s\n", v194);
                sub_2E584(4, s, 0);
              }
              if ( !dword_58E000 )
              {
                v195 = (const char *)sub_4E768(v193);
                v196 = strncasecmp(v195, "right", 5u);
                if ( v196 )
                  *(_BYTE *)(v186 + 8) = 0;
                else
                  v197 = 1;
                if ( !v196 )
                  *(_BYTE *)(v186 + 8) = v197;
              }
            }
            if ( (unsigned int)dword_7EB9C <= 3 )
              goto LABEL_10;
            snprintf(s, 0x800u, "get array %d x failed\n", j);
LABEL_327:
            sub_2E584(3, s, 0);
          }
          else
          {
            if ( (unsigned int)dword_7EB9C <= 3 )
              goto LABEL_10;
            v198 = sub_4E5A0(v176);
            snprintf(s, 0x800u, "malloc %d sensor_t failed\n", v198);
            sub_2E584(3, s, 0);
          }
LABEL_273:
          if ( (unsigned int)dword_7EB9C <= 3 )
            goto LABEL_10;
          strcpy(s, "parse chain pic failed\n");
          sub_2E584(3, s, 0);
          goto LABEL_213;
        }
        v177 = (const char *)dword_58DFB8;
        if ( strcmp((const char *)dword_58DFB8, "BHB28601") && strcmp(v177, "BHB28501") )
        {
          if ( (unsigned int)dword_7EB9C <= 3 )
            goto LABEL_10;
          strcpy(s, "get pic sensor failed\n");
          sub_2E584(3, s, 0);
          goto LABEL_273;
        }
LABEL_338:
        v199 = (_DWORD *)sub_4E234(v254, "eeprom");
        v200 = v199;
        if ( !v199 || *v199 )
        {
          if ( (unsigned int)dword_7EB9C <= 3 )
            goto LABEL_10;
          strcpy(s, "get eeprom failed\n");
          sub_2E584(3, s, 0);
          goto LABEL_342;
        }
        if ( (unsigned int)dword_7EB9C > 4 )
        {
          strcpy(s, "eeprom:\n");
          sub_2E584(4, s, 0);
        }
        v201 = (_DWORD *)sub_4E234(v200, "type");
        if ( !v201 || *v201 != 2 )
        {
          if ( (unsigned int)dword_7EB9C <= 3 )
            goto LABEL_10;
          strcpy(s, "get type failed\n");
          sub_2E584(3, s, 0);
          goto LABEL_342;
        }
        if ( (unsigned int)dword_7EB9C > 4 )
        {
          v202 = (const char *)sub_4E768(v201);
          snprintf(s, 0x800u, "type: %s\n", v202);
          sub_2E584(4, s, 0);
        }
        v203 = (_DWORD *)sub_4E234(v200, "i2c_addr");
        if ( !v203 || *v203 != 3 )
        {
          if ( (unsigned int)dword_7EB9C <= 3 )
            goto LABEL_10;
          strcpy(s, "get i2c_addr failed\n");
          sub_2E584(3, s, 0);
LABEL_342:
          if ( (unsigned int)dword_7EB9C <= 3 )
            goto LABEL_10;
          v142 = "parse chain eeprom failed\n";
          goto LABEL_241;
        }
        if ( (unsigned int)dword_7EB9C > 4 )
        {
          v204 = sub_4E9C4((int)v203);
          snprintf(s, 0x800u, "i2c_addr: %d\n", v204);
          sub_2E584(4, s, 0);
        }
        v205 = (_DWORD *)sub_4E234(v254, "sensor");
        v206 = v205;
        if ( !v205 || *v205 != 1 )
        {
          if ( (unsigned int)dword_7EB9C <= 3 )
            goto LABEL_10;
          strcpy(s, "get sensor failed\n");
          sub_2E584(3, s, 0);
          goto LABEL_362;
        }
        if ( (unsigned int)dword_7EB9C > 4 )
        {
          strcpy(s, "sensor:\n");
          sub_2E584(4, s, 0);
        }
        dword_58DFD4 = (int)sub_4E5A0(v206);
        v207 = sub_4E5A0(v206);
        dword_58DFF4 = (int)calloc((size_t)v207, 0xCu);
        if ( !dword_58DFF4 )
        {
          if ( (unsigned int)dword_7EB9C <= 3 )
            goto LABEL_10;
          v221 = sub_4E5A0(v206);
          snprintf(s, 0x800u, "malloc %d sensor_t failed\n", v221);
          sub_2E584(3, s, 0);
          goto LABEL_362;
        }
        for ( k = 0; k < (unsigned int)sub_4E5A0(v206); ++k )
        {
          v209 = sub_4E5BC(v206, k);
          v210 = v209;
          if ( !v209 || *v209 )
          {
            if ( (unsigned int)dword_7EB9C <= 3 )
              goto LABEL_10;
            snprintf(s, 0x800u, "get array %d failed\n", k);
            goto LABEL_386;
          }
          v211 = (_DWORD *)sub_4E234(v209, "index");
          v212 = (int)v211;
          if ( !v211 || *v211 != 3 )
          {
            if ( (unsigned int)dword_7EB9C <= 3 )
              goto LABEL_10;
            snprintf(s, 0x800u, "get array %d index failed\n", k);
LABEL_386:
            sub_2E584(3, s, 0);
LABEL_362:
            if ( (unsigned int)dword_7EB9C <= 3 )
              goto LABEL_10;
            v142 = "parse chain sensor failed\n";
LABEL_241:
            v143 = *(_DWORD *)v142;
            v144 = *((_DWORD *)v142 + 1);
            v145 = *((_DWORD *)v142 + 2);
            v146 = *((_DWORD *)v142 + 3);
            v147 = v142 + 16;
            *(_DWORD *)s = v143;
            *(_DWORD *)&s[4] = v144;
            *(_DWORD *)&s[8] = v145;
            *(_DWORD *)&s[12] = v146;
            v148 = v147[1];
            v149 = v147[2];
            *(_DWORD *)&s[16] = *v147;
            *(_DWORD *)&s[20] = v148;
            *(_WORD *)&s[24] = v149;
            s[26] = BYTE2(v149);
            sub_2E584(3, s, 0);
LABEL_213:
            if ( (unsigned int)dword_7EB9C <= 3 )
              goto LABEL_10;
            v45 = "parse chain failed\n";
LABEL_73:
            v46 = *(_DWORD *)v45;
            v47 = *((_DWORD *)v45 + 1);
            v48 = *((_DWORD *)v45 + 2);
            v49 = *((_DWORD *)v45 + 3);
            v2 = -1;
            v50 = *((_DWORD *)v45 + 4);
            *(_DWORD *)s = v46;
            *(_DWORD *)&s[4] = v47;
            *(_DWORD *)&s[8] = v48;
            *(_DWORD *)&s[12] = v49;
            *(_DWORD *)&s[16] = v50;
            sub_2E584(3, s, 0);
            goto LABEL_11;
          }
          if ( (unsigned int)dword_7EB9C > 4 )
          {
            v213 = sub_4E9C4((int)v211);
            snprintf(s, 0x800u, "index: %d\n", v213);
            sub_2E584(4, s, 0);
          }
          v214 = dword_58DFF4;
          v215 = v214 + 12 * sub_4E9C4(v212);
          v216 = (_DWORD *)sub_4E234(v210, "type");
          if ( !v216 || *v216 != 2 )
          {
            if ( (unsigned int)dword_7EB9C > 3 )
            {
              snprintf(s, 0x800u, "get array %d type failed\n", k);
              goto LABEL_386;
            }
            goto LABEL_10;
          }
          if ( (unsigned int)dword_7EB9C > 4 )
          {
            v217 = (const char *)sub_4E768(v216);
            snprintf(s, 0x800u, "type: %s\n", v217);
            sub_2E584(4, s, 0);
          }
          v218 = (_DWORD *)sub_4E234(v210, "bind_asic");
          v219 = (int)v218;
          if ( !v218 || *v218 != 3 )
          {
            if ( (unsigned int)dword_7EB9C > 3 )
            {
              snprintf(s, 0x800u, "get array %d bind_asic failed\n", k);
              goto LABEL_386;
            }
            goto LABEL_10;
          }
          if ( (unsigned int)dword_7EB9C > 4 )
          {
            v220 = sub_4E9C4((int)v218);
            snprintf(s, 0x800u, "bind_asic: %d\n", v220);
            sub_2E584(4, s, 0);
          }
          *(_DWORD *)(v215 + 4) = sub_4E9C4(v219);
        }
        formata = (char *)sub_4E234(v254, "domain");
        if ( !formata || *(_DWORD *)formata != 1 )
        {
          if ( (unsigned int)dword_7EB9C <= 3 )
            goto LABEL_10;
          strcpy(s, "get domain failed\n");
          sub_2E584(3, s, 0);
          goto LABEL_397;
        }
        if ( (unsigned int)dword_7EB9C > 4 )
        {
          strcpy(s, "domain:\n");
          sub_2E584(4, s, 0);
        }
        v222 = 0;
        v255 = v1;
LABEL_404:
        if ( v222 < (unsigned int)sub_4E5A0(formata) )
        {
          v223 = sub_4E5BC(formata, v222);
          v224 = v223;
          if ( !v223 || *v223 )
          {
            v1 = v255;
            if ( (unsigned int)dword_7EB9C <= 3 )
              goto LABEL_10;
            snprintf(s, 0x800u, "get array %d failed\n", v222);
          }
          else
          {
            v225 = (_DWORD *)sub_4E234(v223, "index");
            if ( v225 && *v225 == 3 )
            {
              if ( (unsigned int)dword_7EB9C > 4 )
              {
                v226 = sub_4E9C4((int)v225);
                snprintf(s, 0x800u, "index: %d\n", v226);
                sub_2E584(4, s, 0);
              }
              v227 = (_DWORD *)sub_4E234(v224, "asic");
              v228 = v227;
              if ( v227 && *v227 == 1 )
              {
                if ( (unsigned int)dword_7EB9C > 4 )
                {
                  strcpy(s, "asic:\n");
                  sub_2E584(4, s, 0);
                }
                for ( m = 0; ; ++m )
                {
                  if ( m >= (unsigned int)sub_4E5A0(v228) )
                  {
                    ++v222;
                    goto LABEL_404;
                  }
                  v233 = sub_4E5BC(v228, m);
                  v234 = v233;
                  if ( !v233 || *v233 )
                  {
                    v1 = v255;
                    if ( (unsigned int)dword_7EB9C > 3 )
                    {
                      snprintf(s, 0x800u, "get array %d failed\n", m);
                      goto LABEL_448;
                    }
                    goto LABEL_10;
                  }
                  v235 = (_DWORD *)sub_4E234(v233, "index");
                  v236 = (int)v235;
                  if ( !v235 || *v235 != 3 )
                  {
                    v1 = v255;
                    if ( (unsigned int)dword_7EB9C > 3 )
                    {
                      snprintf(s, 0x800u, "get array %d index failed\n", m);
                      goto LABEL_448;
                    }
                    goto LABEL_10;
                  }
                  if ( (unsigned int)dword_7EB9C > 4 )
                  {
                    v237 = sub_4E9C4((int)v235);
                    snprintf(s, 0x800u, "index: %d\n", v237);
                    sub_2E584(4, s, 0);
                  }
                  v238 = sub_4E9C4(v236);
                  v239 = v234;
                  v240 = *(_DWORD *)(dword_58DFF0 + 8);
                  *(_DWORD *)(v240 + 28 * v238) = v238;
                  v241 = v240 + 28 * v238;
                  v242 = (_DWORD *)sub_4E234(v239, "coordinate");
                  v243 = v242;
                  if ( !v242 || *v242 != 1 )
                    break;
                  v244 = sub_4E5BC(v242, 0);
                  v245 = (int)v244;
                  if ( !v244 || *v244 != 3 )
                  {
                    v1 = v255;
                    if ( (unsigned int)dword_7EB9C > 3 )
                    {
                      snprintf(s, 0x800u, "get array %d coordinate x failed\n", m);
LABEL_448:
                      sub_2E584(3, s, 0);
                      goto LABEL_415;
                    }
                    goto LABEL_10;
                  }
                  if ( (unsigned int)dword_7EB9C > 4 )
                  {
                    v246 = sub_4E9C4((int)v244);
                    snprintf(s, 0x800u, "x: %d\n", v246);
                    sub_2E584(4, s, 0);
                  }
                  *(_DWORD *)(v241 + 4) = sub_4E9C4(v245);
                  v247 = sub_4E5BC(v243, 1u);
                  v248 = (int)v247;
                  if ( !v247 || *v247 != 3 )
                  {
                    v1 = v255;
                    if ( (unsigned int)dword_7EB9C <= 3 )
                      goto LABEL_10;
                    snprintf(s, 0x800u, "get array %d coordinate y failed\n", m);
                    goto LABEL_448;
                  }
                  if ( (unsigned int)dword_7EB9C > 4 )
                  {
                    v249 = sub_4E9C4((int)v247);
                    snprintf(s, 0x800u, "y: %d\n", v249);
                    sub_2E584(4, s, 0);
                  }
                  *(_DWORD *)(v241 + 8) = sub_4E9C4(v248);
                }
                v1 = v255;
                if ( (unsigned int)dword_7EB9C > 3 )
                {
                  snprintf(s, 0x800u, "get array %d coordinate failed\n", m);
                  goto LABEL_448;
                }
                goto LABEL_10;
              }
              v1 = v255;
              if ( (unsigned int)dword_7EB9C <= 3 )
                goto LABEL_10;
              strcpy(s, "get asic failed\n");
              sub_2E584(3, s, 0);
LABEL_415:
              if ( (unsigned int)dword_7EB9C <= 3 )
              {
LABEL_10:
                v2 = -1;
                goto LABEL_11;
              }
              snprintf(s, 0x800u, "parse arrry %d asic failed\n", v222);
              sub_2E584(3, s, 0);
              goto LABEL_397;
            }
            v1 = v255;
            if ( (unsigned int)dword_7EB9C <= 3 )
              goto LABEL_10;
            snprintf(s, 0x800u, "get array %d index failed\n", v222);
          }
          sub_2E584(3, s, 0);
LABEL_397:
          if ( (unsigned int)dword_7EB9C <= 3 )
            goto LABEL_10;
          v142 = "parse chain domain failed\n";
          goto LABEL_241;
        }
        v229 = 1;
        v1 = v255;
        v230 = *(const void **)(dword_58DFF0 + 8);
        while ( v229 < dword_58DFBC )
        {
          v231 = dword_58DFF0 + 20 * v229++;
          memcpy(*(void **)(v231 + 8), v230, 28 * dword_58DFCC);
        }
        for ( n = 0; ; ++n )
        {
          if ( n >= dword_58DFD4 )
          {
            v2 = sub_1B398();
            if ( v2 && (unsigned int)dword_7EB9C > 3 )
            {
              strcpy(s, "init topol runtime failed\n");
              sub_2E584(3, s, 0);
            }
LABEL_11:
            if ( *((_DWORD *)v1 + 1) != -1 )
            {
              v6 = (unsigned int *)(v1 + 4);
              __dmb(0xBu);
              do
              {
                v7 = __ldrex(v6);
                v8 = v7 - 1;
              }
              while ( __strex(v8, v6) );
              if ( !v8 )
                sub_4EB6C(v1);
            }
            return v2;
          }
          v251 = dword_58DFF4 + 12 * n;
          v252 = *(_DWORD *)(dword_58DFF0 + 8) + 28 * *(_DWORD *)(v251 + 4);
          if ( (unsigned int)dword_7EB9C > 3 )
          {
            snprintf(s, 0x800u, "asic %d, wind %d, y %d\n");
            sub_2E584(3, s, 0);
          }
          v253 = dword_58E000;
          if ( dword_58E000 != 1 )
            break;
          if ( *(_DWORD *)(v252 + 8) > dword_58DFC4 / 3 )
            goto LABEL_472;
          if ( (unsigned int)dword_7EB9C > 3 )
          {
            formatb = dword_58E000;
            strcpy(s, "air in\n");
            sub_2E584(3, s, 0);
            v253 = formatb;
          }
LABEL_468:
          *(_BYTE *)(v251 + 8) = v253;
        }
        if ( !dword_58E000 && *(_DWORD *)(v252 + 8) >= 2 * dword_58DFC4 / 3 )
        {
          if ( (unsigned int)dword_7EB9C > 3 )
          {
            strcpy(s, "air in\n");
            sub_2E584(3, s, dword_58E000);
          }
          v253 = 1;
          goto LABEL_468;
        }
LABEL_472:
        if ( (unsigned int)dword_7EB9C > 3 )
        {
          strcpy(s, "air out\n");
          sub_2E584(3, s, 0);
        }
        v253 = 0;
        goto LABEL_468;
      }
    }
    dword_58E000 = 0;
    goto LABEL_144;
  }
  if ( (unsigned int)dword_7EB9C <= 3 )
    return -1;
  snprintf(s, 0x800u, "load topol config file %s failed\n", "/etc/topol.conf");
  sub_2E584(3, s, 0);
  return -1;
}
// 1D310: variable 'v197' is possibly undefined
// 7EB9C: using guessed type int dword_7EB9C;
// 58DFB8: using guessed type int dword_58DFB8;
// 58DFBC: using guessed type int dword_58DFBC;
// 58DFC0: using guessed type int dword_58DFC0;
// 58DFC4: using guessed type int dword_58DFC4;
// 58DFC8: using guessed type int dword_58DFC8;
// 58DFCC: using guessed type int dword_58DFCC;
// 58DFD0: using guessed type int dword_58DFD0;
// 58DFD4: using guessed type int dword_58DFD4;
// 58DFD8: using guessed type int dword_58DFD8;
// 58DFDC: using guessed type int dword_58DFDC;
// 58DFE0: using guessed type int dword_58DFE0;
// 58DFE4: using guessed type int dword_58DFE4;
// 58DFE8: using guessed type int dword_58DFE8;
// 58DFEC: using guessed type int dword_58DFEC;
// 58DFF0: using guessed type int dword_58DFF0;
// 58DFF4: using guessed type int dword_58DFF4;
// 58DFF8: using guessed type int dword_58DFF8;
// 58DFFC: using guessed type int dword_58DFFC;
// 58E000: using guessed type int dword_58E000;
// 58E004: using guessed type int dword_58E004;
// 58E038: using guessed type int dword_58E038;
// 58E03C: using guessed type int dword_58E03C;
// 1B4AC: using guessed type char var_924[252];

//----- (0001E0C0) --------------------------------------------------------
int sub_1E0C0()
{
  return dword_58DFB8;
}
// 58DFB8: using guessed type int dword_58DFB8;

//----- (0001E0D0) --------------------------------------------------------
int sub_1E0D0()
{
  return dword_58DFBC;
}
// 58DFBC: using guessed type int dword_58DFBC;

//----- (0001E0E0) --------------------------------------------------------
int sub_1E0E0()
{
  return dword_58DFC8;
}
// 58DFC8: using guessed type int dword_58DFC8;

//----- (0001E0F0) --------------------------------------------------------
int sub_1E0F0()
{
  return dword_58DFCC;
}
// 58DFCC: using guessed type int dword_58DFCC;

//----- (0001E100) --------------------------------------------------------
int sub_1E100()
{
  return dword_58DFD0;
}
// 58DFD0: using guessed type int dword_58DFD0;

//----- (0001E110) --------------------------------------------------------
int sub_1E110()
{
  return dword_58DFD8;
}
// 58DFD8: using guessed type int dword_58DFD8;

//----- (0001E120) --------------------------------------------------------
int sub_1E120()
{
  return dword_58DFDC;
}
// 58DFDC: using guessed type int dword_58DFDC;

//----- (0001E130) --------------------------------------------------------
int sub_1E130()
{
  return dword_58DFE0;
}
// 58DFE0: using guessed type int dword_58DFE0;

//----- (0001E140) --------------------------------------------------------
int sub_1E140()
{
  return dword_58DFE4;
}
// 58DFE4: using guessed type int dword_58DFE4;

//----- (0001E150) --------------------------------------------------------
int sub_1E150()
{
  return dword_58DFE8;
}
// 58DFE8: using guessed type int dword_58DFE8;

//----- (0001E160) --------------------------------------------------------
int sub_1E160()
{
  return dword_58DFEC;
}
// 58DFEC: using guessed type int dword_58DFEC;

//----- (0001E170) --------------------------------------------------------
int sub_1E170()
{
  return dword_58DFD4;
}
// 58DFD4: using guessed type int dword_58DFD4;

//----- (0001E180) --------------------------------------------------------
int __fastcall sub_1E180(int a1)
{
  return *(_DWORD *)(dword_58DFF4 + 12 * a1 + 4);
}
// 58DFF4: using guessed type int dword_58DFF4;

//----- (0001E19C) --------------------------------------------------------
int sub_1E19C()
{
  return dword_58DFF8;
}
// 58DFF8: using guessed type int dword_58DFF8;

//----- (0001E1AC) --------------------------------------------------------
int __fastcall sub_1E1AC(int a1)
{
  return *(_DWORD *)(dword_58DFFC + 12 * a1 + 4);
}
// 58DFFC: using guessed type int dword_58DFFC;

//----- (0001E1C8) --------------------------------------------------------
int __fastcall sub_1E1C8(int a1)
{
  return *(unsigned __int8 *)(dword_58DFFC + 12 * a1 + 8);
}
// 58DFFC: using guessed type int dword_58DFFC;

//----- (0001E1E4) --------------------------------------------------------
int __fastcall sub_1E1E4(int a1)
{
  return *(unsigned __int8 *)(dword_58DFF4 + 12 * a1 + 8);
}
// 58DFF4: using guessed type int dword_58DFF4;

//----- (0001E200) --------------------------------------------------------
int __fastcall sub_1E200(int a1, int a2)
{
  int v2; // r3
  int result; // r0
  int v6; // r4
  char v7; // r3

  v2 = (unsigned int)a1 >> 31;
  if ( dword_58DFBC <= a1 )
    v2 = 1;
  if ( v2 )
    return -2147482623;
  if ( dword_58E010 )
  {
    result = 0;
  }
  else
  {
    result = sub_1B398();
    if ( result < 0 )
      return result;
  }
  v6 = 528 * a1;
  if ( *(unsigned __int8 *)(dword_58E018 + v6) != a2 )
  {
    *(_BYTE *)(dword_58E018 + v6) = a2;
    if ( a2 )
      v7 = byte_58E014 + 1;
    else
      v7 = byte_58E014 - 1;
    byte_58E014 = v7;
  }
  return result;
}
// 58DFBC: using guessed type int dword_58DFBC;
// 58E010: using guessed type int dword_58E010;
// 58E014: using guessed type char byte_58E014;
// 58E018: using guessed type int dword_58E018;

//----- (0001E28C) --------------------------------------------------------
int sub_1E28C()
{
  return (unsigned __int8)byte_58E014;
}
// 58E014: using guessed type char byte_58E014;

//----- (0001E29C) --------------------------------------------------------
int __fastcall sub_1E29C(int a1)
{
  return *(unsigned __int8 *)(dword_58E018 + 528 * a1);
}
// 58E018: using guessed type int dword_58E018;

//----- (0001E2B4) --------------------------------------------------------
int sub_1E2B4()
{
  __int64 v0; // d0
  int result; // r0

  result = 0;
  unk_58E028 = v0;
  return result;
}
// 1E2C0: variable 'v0' is possibly undefined

//----- (0001E2C8) --------------------------------------------------------
void sub_1E2C8()
{
  ;
}

//----- (0001E2D8) --------------------------------------------------------
int sub_1E2D8()
{
  __int64 v0; // d0
  int result; // r0

  result = 0;
  unk_58E030 = v0;
  return result;
}
// 1E2E4: variable 'v0' is possibly undefined

//----- (0001E2EC) --------------------------------------------------------
void sub_1E2EC()
{
  ;
}

//----- (0001E2FC) --------------------------------------------------------
int sub_1E2FC()
{
  return dword_58E004;
}
// 58E004: using guessed type int dword_58E004;

//----- (0001E30C) --------------------------------------------------------
int sub_1E30C()
{
  int result; // r0
  int v1; // r3

  if ( dword_58E004 <= 0 )
    return 0;
  result = 0;
  v1 = 0;
  do
  {
    if ( *(unsigned __int8 *)(dword_58E020 + 8 * v1++) )
      ++result;
  }
  while ( v1 != dword_58E004 );
  return result;
}
// 58E004: using guessed type int dword_58E004;
// 58E020: using guessed type int dword_58E020;

//----- (0001E350) --------------------------------------------------------
int __fastcall sub_1E350(int a1, int a2)
{
  int v2; // r3
  int result; // r0
  char v6; // r3

  v2 = (unsigned int)a1 >> 31;
  if ( dword_58E004 <= a1 )
    v2 = 1;
  if ( v2 )
    return -2147482623;
  if ( dword_58E010 )
  {
    result = 0;
  }
  else
  {
    result = sub_1B398();
    if ( result < 0 )
      return result;
  }
  if ( *(unsigned __int8 *)(dword_58E020 + 8 * a1) != a2 )
  {
    *(_BYTE *)(dword_58E020 + 8 * a1) = a2;
    if ( a2 )
      v6 = byte_58E01C + 1;
    else
      v6 = byte_58E01C - 1;
    byte_58E01C = v6;
  }
  return result;
}
// 58E004: using guessed type int dword_58E004;
// 58E010: using guessed type int dword_58E010;
// 58E01C: using guessed type char byte_58E01C;
// 58E020: using guessed type int dword_58E020;

//----- (0001E3D4) --------------------------------------------------------
int __fastcall sub_1E3D4(int a1, int a2)
{
  int v2; // r3
  int result; // r0

  v2 = (unsigned int)a1 >> 31;
  if ( dword_58E004 <= a1 )
    v2 = 1;
  if ( v2 )
    return -2147482623;
  if ( dword_58E010 )
  {
    result = 0;
LABEL_7:
    *(_DWORD *)(dword_58E020 + 8 * a1 + 4) = a2;
    return result;
  }
  result = sub_1B398();
  if ( result >= 0 )
    goto LABEL_7;
  return result;
}
// 58E004: using guessed type int dword_58E004;
// 58E010: using guessed type int dword_58E010;
// 58E020: using guessed type int dword_58E020;

//----- (0001E43C) --------------------------------------------------------
int __fastcall sub_1E43C(int a1)
{
  int result; // r0

  if ( (dword_58E004 <= a1) | ((unsigned int)a1 >> 31) )
    return -2147482623;
  if ( dword_58E010 )
    return *(_DWORD *)(dword_58E020 + 8 * a1 + 4);
  result = sub_1B398();
  if ( result >= 0 )
    return *(_DWORD *)(dword_58E020 + 8 * a1 + 4);
  return result;
}
// 58E004: using guessed type int dword_58E004;
// 58E010: using guessed type int dword_58E010;
// 58E020: using guessed type int dword_58E020;

//----- (0001E49C) --------------------------------------------------------
int __fastcall sub_1E49C(char a1)
{
  byte_58E01D = a1;
  return 0;
}
// 58E01D: using guessed type char byte_58E01D;

//----- (0001E4B0) --------------------------------------------------------
int sub_1E4B0()
{
  return (unsigned __int8)byte_58E01D;
}
// 58E01D: using guessed type char byte_58E01D;

//----- (0001E4C0) --------------------------------------------------------
int __fastcall sub_1E4C0(int a1)
{
  __int64 v1; // d0
  int v2; // r3
  int result; // r0

  v2 = (unsigned int)a1 >> 31;
  if ( dword_58DFBC <= a1 )
    v2 = 1;
  if ( v2 )
    return -2147482623;
  if ( dword_58E010 )
  {
    result = 0;
LABEL_7:
    *(_QWORD *)(dword_58E018 + 528 * a1 + 8) = v1;
    return result;
  }
  result = sub_1B398();
  if ( result >= 0 )
    goto LABEL_7;
  return result;
}
// 1E508: variable 'v1' is possibly undefined
// 58DFBC: using guessed type int dword_58DFBC;
// 58E010: using guessed type int dword_58E010;
// 58E018: using guessed type int dword_58E018;

//----- (0001E52C) --------------------------------------------------------
int __fastcall sub_1E52C(int result)
{
  int v1; // r4

  if ( !((dword_58DFBC <= result) | ((unsigned int)result >> 31)) )
  {
    v1 = result;
    if ( dword_58E010 )
      return dword_58E018 + 528 * v1;
    result = sub_1B398();
    if ( result >= 0 )
      return dword_58E018 + 528 * v1;
  }
  return result;
}
// 58DFBC: using guessed type int dword_58DFBC;
// 58E010: using guessed type int dword_58E010;
// 58E018: using guessed type int dword_58E018;

//----- (0001E5A0) --------------------------------------------------------
int __fastcall sub_1E5A0(int a1)
{
  int v1; // r3
  int result; // r0

  v1 = (unsigned int)a1 >> 31;
  if ( dword_58DFBC <= a1 )
    v1 = 1;
  if ( v1 )
    return -2147482623;
  if ( dword_58E010 )
  {
    result = 0;
LABEL_7:
    ++*(_BYTE *)(dword_58E018 + 528 * a1 + 1);
    return result;
  }
  result = sub_1B398();
  if ( result >= 0 )
    goto LABEL_7;
  return result;
}
// 58DFBC: using guessed type int dword_58DFBC;
// 58E010: using guessed type int dword_58E010;
// 58E018: using guessed type int dword_58E018;

//----- (0001E610) --------------------------------------------------------
int __fastcall sub_1E610(int a1, char a2)
{
  int v2; // r3
  int result; // r0

  v2 = (unsigned int)a1 >> 31;
  if ( dword_58DFBC <= a1 )
    v2 = 1;
  if ( v2 )
    return -2147482623;
  if ( dword_58E010 )
  {
    result = 0;
LABEL_7:
    *(_BYTE *)(dword_58E018 + 528 * a1 + 1) = a2;
    return result;
  }
  result = sub_1B398();
  if ( result >= 0 )
    goto LABEL_7;
  return result;
}
// 58DFBC: using guessed type int dword_58DFBC;
// 58E010: using guessed type int dword_58E010;
// 58E018: using guessed type int dword_58E018;

//----- (0001E67C) --------------------------------------------------------
int __fastcall sub_1E67C(int a1)
{
  int result; // r0

  if ( (dword_58DFBC <= a1) | ((unsigned int)a1 >> 31) )
    return -2147482623;
  if ( dword_58E010 )
    return *(unsigned __int8 *)(dword_58E018 + 528 * a1 + 1);
  result = sub_1B398();
  if ( result >= 0 )
    return *(unsigned __int8 *)(dword_58E018 + 528 * a1 + 1);
  return result;
}
// 58DFBC: using guessed type int dword_58DFBC;
// 58E010: using guessed type int dword_58E010;
// 58E018: using guessed type int dword_58E018;

//----- (0001E6E0) --------------------------------------------------------
int __fastcall sub_1E6E0(int a1)
{
  unsigned int v1; // r3
  int result; // r0

  v1 = (unsigned int)a1 >> 31;
  if ( dword_58DFBC <= a1 )
    v1 = 1;
  if ( v1 )
    return -2147482623;
  if ( dword_58E010 )
  {
    result = 0;
LABEL_7:
    ++*(_DWORD *)(dword_58E018 + 528 * a1 + 4);
    return result;
  }
  result = sub_1B398();
  if ( result >= 0 )
    goto LABEL_7;
  return result;
}
// 58DFBC: using guessed type int dword_58DFBC;
// 58E010: using guessed type int dword_58E010;
// 58E018: using guessed type int dword_58E018;

//----- (0001E750) --------------------------------------------------------
int __fastcall sub_1E750(int a1, int a2)
{
  int v2; // r3
  int result; // r0

  v2 = (unsigned int)a1 >> 31;
  if ( dword_58DFBC <= a1 )
    v2 = 1;
  if ( v2 )
    return -2147482623;
  if ( dword_58E010 )
  {
    result = 0;
LABEL_7:
    *(_DWORD *)(dword_58E018 + 528 * a1 + 4) = a2;
    return result;
  }
  result = sub_1B398();
  if ( result >= 0 )
    goto LABEL_7;
  return result;
}
// 58DFBC: using guessed type int dword_58DFBC;
// 58E010: using guessed type int dword_58E010;
// 58E018: using guessed type int dword_58E018;

//----- (0001E7BC) --------------------------------------------------------
int __fastcall sub_1E7BC(int a1)
{
  int result; // r0

  if ( (dword_58DFBC <= a1) | ((unsigned int)a1 >> 31) )
    return -2147482623;
  if ( dword_58E010 )
    return *(_DWORD *)(dword_58E018 + 528 * a1 + 4);
  result = sub_1B398();
  if ( result >= 0 )
    return *(_DWORD *)(dword_58E018 + 528 * a1 + 4);
  return result;
}
// 58DFBC: using guessed type int dword_58DFBC;
// 58E010: using guessed type int dword_58E010;
// 58E018: using guessed type int dword_58E018;

//----- (0001E820) --------------------------------------------------------
int __fastcall sub_1E820(int a1, int a2, char a3)
{
  int v3; // r3
  int result; // r0

  v3 = (unsigned int)a1 >> 31;
  if ( dword_58DFBC <= a1 )
    v3 = 1;
  if ( v3 )
    return -2147482623;
  if ( dword_58E010 )
  {
    result = 0;
LABEL_7:
    *(_BYTE *)(dword_58E018 + 528 * a1 + a2 + 16) = a3;
    return result;
  }
  result = sub_1B398();
  if ( result >= 0 )
    goto LABEL_7;
  return result;
}
// 58DFBC: using guessed type int dword_58DFBC;
// 58E010: using guessed type int dword_58E010;
// 58E018: using guessed type int dword_58E018;

//----- (0001E894) --------------------------------------------------------
int __fastcall sub_1E894(unsigned int a1, char *s)
{
  unsigned int v2; // r5
  int result; // r0

  if ( dword_58DFBC <= (int)a1 )
    return -2147482623;
  v2 = (s == 0) | (a1 >> 31);
  if ( v2 )
    return -2147482623;
  if ( dword_58E010 || (result = sub_1B398(), v2 = result, result >= 0) )
  {
    snprintf(s, 0x200u, "%s", (const char *)(dword_58E018 + 528 * a1 + 16));
    return v2;
  }
  return result;
}
// 58DFBC: using guessed type int dword_58DFBC;
// 58E010: using guessed type int dword_58E010;
// 58E018: using guessed type int dword_58E018;

//----- (0001E91C) --------------------------------------------------------
int __fastcall sub_1E91C(int a1)
{
  unsigned __int16 *i; // r3
  int v2; // t1

  if ( dword_58E038 <= 0 )
    return 0;
  if ( *(unsigned __int16 *)dword_58E03C != a1 )
  {
    for ( i = (unsigned __int16 *)(dword_58E03C + 2); i != (unsigned __int16 *)(dword_58E03C + 2 * dword_58E038); ++i )
    {
      v2 = *i;
      if ( v2 == a1 )
        return 1;
    }
    return 0;
  }
  return 1;
}
// 58E038: using guessed type int dword_58E038;
// 58E03C: using guessed type int dword_58E03C;

//----- (0001E970) --------------------------------------------------------
int sub_1E970()
{
  int v0; // r4
  int result; // r0

  v0 = 0;
  result = sub_1E29C(0);
  if ( result )
    goto LABEL_4;
  while ( ++v0 != 4 )
  {
    result = sub_1E29C(v0);
    if ( result )
LABEL_4:
      result = sub_50C38((unsigned __int8)v0, 0);
  }
  return result;
}

//----- (0001E9B4) --------------------------------------------------------
int __fastcall sub_1E9B4(unsigned int a1, unsigned int a2)
{
  return sub_51328(a1, a2, 1);
}

//----- (0001E9BC) --------------------------------------------------------
int __fastcall sub_1E9BC(unsigned int a1, unsigned int a2)
{
  return sub_51328(a1, a2, 0);
}

//----- (0001E9C4) --------------------------------------------------------
int __fastcall sub_1E9C4(unsigned int a1)
{
  return sub_512CC(a1, 1);
}

//----- (0001E9CC) --------------------------------------------------------
int __fastcall sub_1E9CC(unsigned int a1)
{
  int v1; // r4
  int result; // r0

  v1 = 0;
  result = sub_1E29C(0);
  if ( result )
    goto LABEL_4;
  while ( ++v1 != 4 )
  {
    result = sub_1E29C(v1);
    if ( result )
LABEL_4:
      result = sub_4FFE8((unsigned __int8)v1, a1);
  }
  return result;
}

//----- (0001EA18) --------------------------------------------------------
int __fastcall sub_1EA18(int a1, unsigned int a2, int a3, char a4)
{
  int i; // r4
  int result; // r0
  bool v10; // zf

  for ( i = 0; i != 4; ++i )
  {
    result = sub_1E29C(i);
    if ( result )
    {
      v10 = a1 == 255;
      if ( a1 != 255 )
        v10 = a1 == (unsigned __int8)i;
      if ( v10 )
      {
        if ( a3 )
          result = sub_508A0((unsigned __int8)i, a4);
        else
          result = sub_50874((unsigned __int8)i, a2, a4);
      }
    }
  }
  return result;
}

//----- (0001EA84) --------------------------------------------------------
int __fastcall sub_1EA84(int a1)
{
  int v2; // r4
  int v3; // r0
  unsigned int v4; // r5
  int result; // r0
  bool v6; // zf

  v2 = 0;
  do
  {
    while ( 1 )
    {
      v3 = v2;
      v4 = (unsigned __int8)v2++;
      result = sub_1E29C(v3);
      if ( result )
      {
        v6 = a1 == 255;
        if ( a1 != 255 )
          v6 = a1 == v4;
        if ( v6 )
          break;
      }
      if ( v2 == 4 )
        return result;
    }
    result = sub_513FC(v4);
  }
  while ( v2 != 4 );
  return result;
}

//----- (0001EAD4) --------------------------------------------------------
int __fastcall sub_1EAD4(unsigned int a1)
{
  int v2; // r4
  int v3; // r0
  int v4; // r5
  int result; // r0

  v2 = 0;
  do
  {
    while ( 1 )
    {
      v3 = v2;
      v4 = (unsigned __int8)v2++;
      result = sub_1E29C(v3);
      if ( result )
        break;
      if ( v2 == 4 )
        return result;
    }
    result = sub_5021C(v4, a1);
  }
  while ( v2 != 4 );
  return result;
}

//----- (0001EB1C) --------------------------------------------------------
int __fastcall sub_1EB1C(__int16 a1)
{
  int v2; // r4
  int v3; // r0
  unsigned int v4; // r5
  int result; // r0

  v2 = 0;
  do
  {
    while ( 1 )
    {
      v3 = v2;
      v4 = (unsigned __int8)v2++;
      result = sub_1E29C(v3);
      if ( result )
        break;
      if ( v2 == 4 )
        return result;
    }
    result = sub_508E4(v4, 1, (unsigned __int8)dword_7EB58, a1);
  }
  while ( v2 != 4 );
  return result;
}
// 7EB58: using guessed type int dword_7EB58;

//----- (0001EB74) --------------------------------------------------------
int sub_1EB74()
{
  int result; // r0
  int i; // r6
  int v2; // r0
  int v3; // r4
  unsigned int v4; // r5
  int v5; // r7
  __int16 v6; // r9
  __int16 v7; // r0
  char v8[2080]; // [sp+8h] [bp-820h] BYREF

  result = sub_1E0E0();
  if ( result > 9 )
  {
    result = sub_1E0E0();
    for ( i = result - 3; i >= 0; i -= 3 )
    {
      v2 = sub_1E100();
      v3 = 0;
      v4 = sub_1E160() * (v2 + i * v2 - 1);
      do
      {
        v5 = (unsigned __int8)v3;
        result = sub_1E29C(v3++);
        if ( result )
        {
          v6 = sub_1E0E0() - i;
          v7 = sub_1E100();
          result = sub_5129C(v5, v4, v7 * v6 + 14, 1, 1);
        }
      }
      while ( v3 != 4 );
    }
  }
  else if ( (unsigned int)dword_7EB9C > 4 )
  {
    strcpy(v8, "no need to set uart relay\n");
    return sub_2E584(4, v8, 0);
  }
  return result;
}
// 7EB9C: using guessed type int dword_7EB9C;

//----- (0001EC84) --------------------------------------------------------
int __fastcall sub_1EC84(int a1, int a2, char a3, char a4)
{
  int i; // r4
  int result; // r0
  bool v10; // zf

  for ( i = 0; i != 4; ++i )
  {
    result = sub_1E29C(i);
    if ( result )
    {
      v10 = a1 == i;
      if ( a1 != i )
        v10 = a1 == 255;
      result = (unsigned __int8)i;
      if ( v10 )
        result = sub_4FEF0((unsigned __int8)i, a2, a3, a4);
    }
  }
  return result;
}

//----- (0001ECDC) --------------------------------------------------------
int __fastcall sub_1ECDC(
        unsigned __int8 a1,
        unsigned __int8 a2,
        unsigned __int8 a3,
        int a4,
        unsigned __int8 a5,
        unsigned __int8 a6)
{
  if ( a4 )
    return sub_5121C(a6, a5, a1, a2, a3);
  else
    return sub_511D0(a6, a5, a1, a2);
}

//----- (0001ED08) --------------------------------------------------------
int sub_1ED08()
{
  int i; // r4
  unsigned __int8 v2; // r0
  char v3[2064]; // [sp+0h] [bp-810h] BYREF

  if ( byte_482A5D && (byte_590404 || byte_482A5C || dword_7EBA0 > 6) )
  {
    snprintf(v3, 0x800u, "--- %s\n", "dhash_chip_set_addr_all");
    sub_2E584(7, v3, 0);
  }
  for ( i = 0; i != 4; ++i )
  {
    if ( sub_1E29C(i) )
    {
      sub_4FF4C((unsigned __int8)i);
      sub_304D4();
      v2 = sub_1E160();
      sub_4FF50((unsigned __int8)i, v2);
    }
  }
  return sub_304D4();
}
// 4FF4C: using guessed type int __fastcall sub_4FF4C(_DWORD);
// 7EBA0: using guessed type int dword_7EBA0;
// 482A5C: using guessed type char byte_482A5C;
// 482A5D: using guessed type char byte_482A5D;
// 590404: using guessed type char byte_590404;

//----- (0001EDF0) --------------------------------------------------------
int __fastcall sub_1EDF0(unsigned int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  unsigned int *v9; // r2
  unsigned __int8 *v10; // r1
  int v11; // r12
  int v12; // r3
  int *v13; // r1
  int v14; // r3
  int v16[17]; // [sp+4h] [bp-54h] BYREF
  unsigned int v17; // [sp+48h] [bp-10h] BYREF
  int v18; // [sp+4Ch] [bp-Ch]
  int v19; // [sp+50h] [bp-8h]
  int v20; // [sp+54h] [bp-4h]

  v17 = a1;
  v18 = a2;
  v19 = a3;
  v20 = a4;
  memset(&v16[2], 0, 0x2Cu);
  v9 = &v17;
  v10 = (unsigned __int8 *)&v17;
  v11 = 2;
  v16[0] = bswap32(v17);
  v16[1] = v18;
  do
  {
    v12 = v10[9];
    v10 += 4;
    v16[v11++] = (v12 << 16) | (v10[4] << 24) | v10[7] | (v10[6] << 8);
  }
  while ( v11 != 5 );
  v13 = &v16[5];
  do
  {
    v14 = *((unsigned __int8 *)v9++ + 21);
    *v13++ = (v14 << 16) | (*((unsigned __int8 *)v9 + 16) << 24) | *((unsigned __int8 *)v9 + 19) | (*((unsigned __int8 *)v9 + 18) << 8);
  }
  while ( v9 != (unsigned int *)&a9 );
  return sub_4587C(v16, 0x34u);
}

//----- (0001EEB8) --------------------------------------------------------
int __fastcall sub_1EEB8(
        unsigned int a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        int a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        int a28,
        int a29,
        int a30,
        int a31,
        int a32,
        int a33)
{
  unsigned int *v33; // r2
  unsigned __int8 *v34; // r1
  int v35; // r12
  int v36; // r3
  int *v37; // r6
  unsigned int *v38; // r5
  int *v39; // r1
  int v40; // r3
  int v42[43]; // [sp+4h] [bp-BCh] BYREF
  unsigned int v43; // [sp+B0h] [bp-10h] BYREF
  int v44; // [sp+B4h] [bp-Ch]
  int v45; // [sp+B8h] [bp-8h]
  int v46; // [sp+BCh] [bp-4h]

  v43 = a1;
  v44 = a2;
  v45 = a3;
  v46 = a4;
  memset(&v42[2], 0, 0x8Cu);
  v33 = &v43;
  v34 = (unsigned __int8 *)&v43;
  v35 = 2;
  v42[0] = bswap32(v43);
  v42[1] = v44;
  do
  {
    v36 = v34[9];
    v34 += 4;
    v42[v35++] = (v36 << 16) | (v34[4] << 24) | v34[7] | (v34[6] << 8);
  }
  while ( v35 != 5 );
  v37 = &v42[5];
  do
  {
    v38 = v33 + 8;
    v39 = v37;
    do
    {
      v40 = *((unsigned __int8 *)v33++ + 21);
      *v39++ = (v40 << 16) | (*((unsigned __int8 *)v33 + 16) << 24) | *((unsigned __int8 *)v33 + 19) | (*((unsigned __int8 *)v33 + 18) << 8);
    }
    while ( v33 != v38 );
    v37 += 8;
  }
  while ( v33 != (unsigned int *)&a33 );
  return sub_4587C(v42, 0x94u);
}

//----- (0001EF94) --------------------------------------------------------
int __fastcall sub_1EF94(int a1, char a2)
{
  int v2; // r4
  int result; // r0

  v2 = 0;
  result = sub_1E29C(0);
  if ( result )
    goto LABEL_4;
  while ( ++v2 != 4 )
  {
    result = sub_1E29C(v2);
    if ( result )
LABEL_4:
      result = sub_5161C((unsigned __int8)v2, a2, 0);
  }
  return result;
}

//----- (0001EFE0) --------------------------------------------------------
int __fastcall sub_1EFE0(int a1, char a2, char a3, char a4)
{
  int v4; // r4
  int result; // r0

  v4 = 0;
  result = sub_1E29C(0);
  if ( result )
    goto LABEL_4;
  while ( ++v4 != 4 )
  {
    result = sub_1E29C(v4);
    if ( result )
LABEL_4:
      result = sub_51694((unsigned __int8)v4, a2, a3, a4);
  }
  return result;
}

//----- (0001F038) --------------------------------------------------------
int __fastcall sub_1F038(int a1)
{
  int i; // r4
  int result; // r0
  bool v4; // zf

  for ( i = 0; i != 4; ++i )
  {
    result = sub_1E29C(i);
    if ( result )
    {
      v4 = a1 == i;
      if ( a1 != i )
        v4 = a1 == 255;
      result = (unsigned __int8)i;
      if ( v4 )
        result = sub_51708((unsigned __int8)i, 1);
    }
  }
  return result;
}

//----- (0001F080) --------------------------------------------------------
int __fastcall sub_1F080(int a1, int a2)
{
  return (int)(float)((float)((float)(25.0 / (float)BYTE2(a1)) * (float)(unsigned __int16)a2)
                    / (float)(BYTE2(a2) * (unsigned __int8)a1 * BYTE1(a1)));
}

//----- (0001F0E0) --------------------------------------------------------
int __fastcall sub_1F0E0(int a1, int a2, unsigned int a3, unsigned int a4)
{
  int i; // r4
  int result; // r0
  bool v10; // zf

  for ( i = 0; i != 4; ++i )
  {
    result = sub_1E29C(i);
    if ( result )
    {
      v10 = a1 == 255;
      if ( a1 != 255 )
        v10 = i == a1;
      if ( v10 )
      {
        if ( a2 )
          result = sub_50794((unsigned __int8)i, a4, 0);
        else
          result = sub_506F8((unsigned __int8)i, a3, a4, 0);
      }
    }
  }
  return result;
}

//----- (0001F164) --------------------------------------------------------
int __fastcall sub_1F164(int a1, int a2, unsigned int a3, unsigned int a4, int a5, __int16 a6)
{
  int i; // r4
  int result; // r0
  bool v12; // zf

  for ( i = 0; i != 4; ++i )
  {
    result = sub_1E29C(i);
    if ( result )
    {
      v12 = a1 == 255;
      if ( a1 != 255 )
        v12 = i == a1;
      if ( v12 )
      {
        if ( a2 )
          result = sub_50560((unsigned __int8)i, a4, a5, a6);
        else
          result = sub_505A4((unsigned __int8)i, a3, a4, a5, a6);
      }
    }
  }
  return result;
}

//----- (0001F1EC) --------------------------------------------------------
int __fastcall sub_1F1EC(int a1, int a2)
{
  int v2; // r4
  int result; // r0

  v2 = 0;
  result = sub_1E29C(0);
  if ( result )
    goto LABEL_4;
  while ( ++v2 != 4 )
  {
    result = sub_1E29C(v2);
    if ( result )
    {
LABEL_4:
      sub_508DC();
      if ( a2 )
        result = sub_50ED0((unsigned __int8)v2);
      else
        result = sub_50F28((unsigned __int8)v2);
    }
  }
  return result;
}

//----- (0001F24C) --------------------------------------------------------
int __fastcall sub_1F24C(int a1)
{
  int v1; // r4
  int result; // r0

  v1 = 0;
  result = sub_1E29C(0);
  if ( result )
    goto LABEL_4;
  while ( ++v1 != 4 )
  {
    result = sub_1E29C(v1);
    if ( result )
LABEL_4:
      result = sub_50D54((unsigned __int8)v1, a1);
  }
  return result;
}

//----- (0001F294) --------------------------------------------------------
int __fastcall sub_1F294(unsigned __int8 a1, unsigned int a2)
{
  return sub_50DA8(a1, a2);
}

//----- (0001F29C) --------------------------------------------------------
int __fastcall sub_1F29C(char a1)
{
  int v2; // r4
  int v3; // r0
  unsigned int v4; // r5
  int result; // r0

  v2 = 0;
  do
  {
    while ( 1 )
    {
      v3 = v2;
      v4 = (unsigned __int8)v2++;
      result = sub_1E29C(v3);
      if ( result )
        break;
      if ( v2 == 4 )
        return result;
    }
    result = sub_50B48(v4, a1);
  }
  while ( v2 != 4 );
  return result;
}

//----- (0001F2E8) --------------------------------------------------------
void sub_1F2E8()
{
  ;
}
// 58E344: using guessed type int dword_58E344;
// 5903F8: using guessed type int dword_5903F8;

//----- (0001F320) --------------------------------------------------------
int sub_1F320()
{
  return dword_5903F8 - dword_58E344;
}
// 58E344: using guessed type int dword_58E344;
// 5903F8: using guessed type int dword_5903F8;

//----- (0001F340) --------------------------------------------------------
int __fastcall sub_1F340(int result)
{
  _DWORD *v1; // r4
  __int64 v2; // r0
  _DWORD *v3; // r0
  char v4[2056]; // [sp+0h] [bp-808h] BYREF

  v1 = (_DWORD *)result;
  if ( result )
  {
    v2 = (unsigned int)sub_31D38();
    v3 = (_DWORD *)sub_4E990(v2);
    return sub_4EFD4(v1, "inited", v3);
  }
  else if ( byte_590404 || byte_482A5C || dword_7EBA0 > 2 )
  {
    snprintf(v4, 0x800u, "%s: input bad json param\n", "api_miner_inited");
    return sub_2E584(3, v4, 0);
  }
  return result;
}
// 7EBA0: using guessed type int dword_7EBA0;
// 482A5C: using guessed type char byte_482A5C;
// 590404: using guessed type char byte_590404;

//----- (0001F3E8) --------------------------------------------------------
int __fastcall sub_1F3E8(int result)
{
  _DWORD *v1; // r4
  int v2; // r0
  _DWORD *v3; // r0
  char v4[2056]; // [sp+0h] [bp-808h] BYREF

  v1 = (_DWORD *)result;
  if ( result )
  {
    v2 = sub_1E28C();
    v3 = (_DWORD *)sub_4E990(v2);
    return sub_4EFD4(v1, "chain_num", v3);
  }
  else if ( byte_590404 || byte_482A5C || dword_7EBA0 > 2 )
  {
    snprintf(v4, 0x800u, "%s: input bad json param\n", "api_miner_chain_num");
    return sub_2E584(3, v4, 0);
  }
  return result;
}
// 7EBA0: using guessed type int dword_7EBA0;
// 482A5C: using guessed type char byte_482A5C;
// 590404: using guessed type char byte_590404;

//----- (0001F490) --------------------------------------------------------
int __fastcall sub_1F490(int result)
{
  double v1; // d0
  _DWORD *v2; // r4
  char *v3; // r0
  char v4[4]; // [sp+8h] [bp-818h] BYREF
  int v5; // [sp+Ch] [bp-814h]
  int v6; // [sp+10h] [bp-810h]
  int v7; // [sp+14h] [bp-80Ch]
  char s[2056]; // [sp+18h] [bp-808h] BYREF

  v2 = (_DWORD *)result;
  *(_DWORD *)v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  if ( result )
  {
    sub_1E2C8();
    snprintf(v4, 0x10u, "%.2f", v1);
    v3 = (char *)sub_4E744(v4);
    return sub_4EFD4(v2, "rate_5s", v3);
  }
  else if ( byte_590404 || byte_482A5C || dword_7EBA0 > 2 )
  {
    snprintf(s, 0x800u, "%s: input bad json param\n", "api_miner_rate_5s");
    return sub_2E584(3, s, 0);
  }
  return result;
}
// 1F52C: variable 'v1' is possibly undefined
// 7EBA0: using guessed type int dword_7EBA0;
// 482A5C: using guessed type char byte_482A5C;
// 590404: using guessed type char byte_590404;

//----- (0001F574) --------------------------------------------------------
int __fastcall sub_1F574(int result)
{
  double v1; // d0
  _DWORD *v2; // r4
  char *v3; // r0
  char s[4]; // [sp+8h] [bp-818h] BYREF
  int v5; // [sp+Ch] [bp-814h]
  int v6; // [sp+10h] [bp-810h]
  int v7; // [sp+14h] [bp-80Ch]
  char v8[2056]; // [sp+18h] [bp-808h] BYREF

  v2 = (_DWORD *)result;
  *(_DWORD *)s = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  if ( result )
  {
    sub_1E2EC();
    if ( v1 < 0.01 )
      v1 = unk_80F50 / ((double)dword_5903F8 - (double)dword_58E344);
    snprintf(s, 0x10u, "%.2lf", v1);
    v3 = (char *)sub_4E744(s);
    return sub_4EFD4(v2, "rate_30m", v3);
  }
  else if ( byte_590404 || byte_482A5C || dword_7EBA0 > 2 )
  {
    snprintf(v8, 0x800u, "%s: input bad json param\n", "api_miner_rate_30m");
    return sub_2E584(3, v8, 0);
  }
  return result;
}
// 1F5AC: variable 'v1' is possibly undefined
// 7EBA0: using guessed type int dword_7EBA0;
// 482A5C: using guessed type char byte_482A5C;
// 58E344: using guessed type int dword_58E344;
// 5903F8: using guessed type int dword_5903F8;
// 590404: using guessed type char byte_590404;

//----- (0001F6AC) --------------------------------------------------------
int __fastcall sub_1F6AC(int result)
{
  _DWORD *v1; // r4
  char *v2; // r0
  char v3[4]; // [sp+8h] [bp-818h] BYREF
  int v4; // [sp+Ch] [bp-814h]
  int v5; // [sp+10h] [bp-810h]
  int v6; // [sp+14h] [bp-80Ch]
  char s[2056]; // [sp+18h] [bp-808h] BYREF

  v1 = (_DWORD *)result;
  *(_DWORD *)v3 = 0;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  if ( result )
  {
    snprintf(v3, 0x10u, "%.2lf", unk_80F50 / ((double)dword_5903F8 - (double)dword_58E344));
    v2 = (char *)sub_4E744(v3);
    return sub_4EFD4(v1, "rate_avg", v2);
  }
  else if ( byte_590404 || byte_482A5C || dword_7EBA0 > 2 )
  {
    snprintf(s, 0x800u, "%s: input bad json param\n", "api_miner_rate_avg");
    return sub_2E584(3, s, 0);
  }
  return result;
}
// 7EBA0: using guessed type int dword_7EBA0;
// 482A5C: using guessed type char byte_482A5C;
// 58E344: using guessed type int dword_58E344;
// 5903F8: using guessed type int dword_5903F8;
// 590404: using guessed type char byte_590404;

//----- (0001F7C4) --------------------------------------------------------
int __fastcall sub_1F7C4(int result)
{
  _DWORD *v1; // r4
  int v2; // r0
  char *v3; // r0
  char v4[4]; // [sp+8h] [bp-818h] BYREF
  int v5; // [sp+Ch] [bp-814h]
  int v6; // [sp+10h] [bp-810h]
  int v7; // [sp+14h] [bp-80Ch]
  char s[2056]; // [sp+18h] [bp-808h] BYREF

  v1 = (_DWORD *)result;
  *(_DWORD *)v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  if ( result )
  {
    v2 = sub_1A18C();
    snprintf(v4, 0x10u, "%.2lf", (double)v2);
    v3 = (char *)sub_4E744(v4);
    return sub_4EFD4(v1, "rate_ideal", v3);
  }
  else if ( byte_590404 || byte_482A5C || dword_7EBA0 > 2 )
  {
    snprintf(s, 0x800u, "%s: input bad json param\n", "api_miner_rate_ideal");
    return sub_2E584(3, s, 0);
  }
  return result;
}
// 7EBA0: using guessed type int dword_7EBA0;
// 482A5C: using guessed type char byte_482A5C;
// 590404: using guessed type char byte_590404;

//----- (0001F8B0) --------------------------------------------------------
int __fastcall sub_1F8B0(int result)
{
  _DWORD *v1; // r4
  char *v2; // r0
  int v3; // [sp+4h] [bp-80Ch] BYREF
  char s[2056]; // [sp+8h] [bp-808h] BYREF

  v1 = (_DWORD *)result;
  v3 = 0;
  if ( result )
  {
    strcpy((char *)&v3, "GH");
    v2 = (char *)sub_4E744((const char *)&v3);
    return sub_4EFD4(v1, "rate_unit", v2);
  }
  else if ( byte_590404 || byte_482A5C || dword_7EBA0 > 2 )
  {
    snprintf(s, 0x800u, "%s: input bad json param\n", "api_miner_rate_unit");
    return sub_2E584(3, s, 0);
  }
  return result;
}
// 7EBA0: using guessed type int dword_7EBA0;
// 482A5C: using guessed type char byte_482A5C;
// 590404: using guessed type char byte_590404;

//----- (0001F984) --------------------------------------------------------
int __fastcall sub_1F984(int result)
{
  _DWORD *v1; // r4
  int v2; // r0
  _DWORD *v3; // r0
  char v4[2056]; // [sp+0h] [bp-808h] BYREF

  v1 = (_DWORD *)result;
  if ( result )
  {
    v2 = sub_1E30C();
    v3 = (_DWORD *)sub_4E990(v2);
    return sub_4EFD4(v1, "fan_num", v3);
  }
  else if ( byte_590404 || byte_482A5C || dword_7EBA0 > 2 )
  {
    snprintf(v4, 0x800u, "%s: input bad json param\n", "api_miner_fan_num");
    return sub_2E584(3, v4, 0);
  }
  return result;
}
// 7EBA0: using guessed type int dword_7EBA0;
// 482A5C: using guessed type char byte_482A5C;
// 590404: using guessed type char byte_590404;

//----- (0001FA2C) --------------------------------------------------------
int __fastcall sub_1FA2C(int result)
{
  _DWORD *v1; // r7
  _DWORD *v2; // r5
  int v3; // r6
  int v4; // r4
  int v5; // r0
  int v6; // r0
  _DWORD *v7; // r0
  char v8[2072]; // [sp+0h] [bp-818h] BYREF

  v1 = (_DWORD *)result;
  if ( result )
  {
    v2 = sub_4E540();
    v3 = sub_1E2FC();
    if ( v3 > 0 )
    {
      v4 = 0;
      do
      {
        v5 = v4++;
        v6 = sub_1E43C(v5);
        v7 = (_DWORD *)sub_4E990(v6);
        sub_4F494(v2, v7);
      }
      while ( v3 != v4 );
    }
    return sub_4EFD4(v1, "fan", v2);
  }
  else if ( byte_590404 || byte_482A5C || dword_7EBA0 > 2 )
  {
    snprintf(v8, 0x800u, "%s: input bad json param\n", "api_miner_fan_speed");
    return sub_2E584(3, v8, 0);
  }
  return result;
}
// 7EBA0: using guessed type int dword_7EBA0;
// 482A5C: using guessed type char byte_482A5C;
// 590404: using guessed type char byte_590404;

//----- (0001FB14) --------------------------------------------------------
int __fastcall sub_1FB14(int result, unsigned int a2)
{
  _BOOL4 v2; // r3
  _DWORD *v3; // r4
  int v4; // r0
  _DWORD *v5; // r0
  char v6[2056]; // [sp+0h] [bp-808h] BYREF

  v2 = a2 > 3;
  if ( !result )
    v2 = 1;
  if ( v2 )
  {
    if ( byte_590404 || byte_482A5C || dword_7EBA0 > 2 )
    {
      snprintf(v6, 0x800u, "%s: input bad param\n", "api_miner_chain_frequency");
      return sub_2E584(3, v6, 0);
    }
  }
  else
  {
    v3 = (_DWORD *)result;
    v4 = sub_1A2E0(a2);
    v5 = (_DWORD *)sub_4E990(v4);
    return sub_4EFD4(v3, "freq_avg", v5);
  }
  return result;
}
// 7EBA0: using guessed type int dword_7EBA0;
// 482A5C: using guessed type char byte_482A5C;
// 590404: using guessed type char byte_590404;

//----- (0001FBD8) --------------------------------------------------------
int __fastcall sub_1FBD8(int result, unsigned int a2)
{
  _BOOL4 v2; // r2
  _DWORD *v3; // r4
  int v4; // r0
  char *v5; // r0
  int v6[4]; // [sp+0h] [bp-818h] BYREF
  char s[2056]; // [sp+10h] [bp-808h] BYREF

  v2 = a2 > 3;
  if ( !result )
    v2 = 1;
  memset(v6, 0, sizeof(v6));
  if ( v2 )
  {
    if ( byte_590404 || byte_482A5C || dword_7EBA0 > 2 )
    {
      snprintf(s, 0x800u, "%s: input bad param\n", "api_miner_chain_rate_ideal");
      return sub_2E584(3, s, 0);
    }
  }
  else
  {
    v3 = (_DWORD *)result;
    v4 = sub_19DE4(a2);
    snprintf((char *)v6, 0x10u, "%d", v4);
    v5 = (char *)sub_4E744((const char *)v6);
    return sub_4EFD4(v3, "rate_ideal", v5);
  }
  return result;
}
// 7EBA0: using guessed type int dword_7EBA0;
// 482A5C: using guessed type char byte_482A5C;
// 590404: using guessed type char byte_590404;

//----- (0001FCD0) --------------------------------------------------------
int __fastcall sub_1FCD0(int result, unsigned int a2)
{
  double v2; // d0
  _BOOL4 v3; // r2
  _DWORD *v4; // r4
  char *v5; // r0
  char v6[4]; // [sp+8h] [bp-818h] BYREF
  int v7; // [sp+Ch] [bp-814h]
  int v8; // [sp+10h] [bp-810h]
  int v9; // [sp+14h] [bp-80Ch]
  char s[2056]; // [sp+18h] [bp-808h] BYREF

  v3 = a2 > 3;
  if ( !result )
    v3 = 1;
  *(_DWORD *)v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  if ( v3 )
  {
    if ( byte_590404 || byte_482A5C || dword_7EBA0 > 2 )
    {
      snprintf(s, 0x800u, "%s: input bad param\n", "api_miner_chain_rate_real");
      return sub_2E584(3, s, 0);
    }
  }
  else
  {
    v4 = (_DWORD *)result;
    sub_1E52C(a2);
    snprintf(v6, 0x10u, "%.2f", v2);
    v5 = (char *)sub_4E744(v6);
    return sub_4EFD4(v4, "rate_real", v5);
  }
  return result;
}
// 1FDA8: variable 'v2' is possibly undefined
// 7EBA0: using guessed type int dword_7EBA0;
// 482A5C: using guessed type char byte_482A5C;
// 590404: using guessed type char byte_590404;

//----- (0001FDD8) --------------------------------------------------------
int __fastcall sub_1FDD8(int result, unsigned int a2)
{
  _BOOL4 v2; // r3
  _DWORD *v3; // r4
  int v4; // r0
  _DWORD *v5; // r0
  char v6[2056]; // [sp+0h] [bp-808h] BYREF

  v2 = a2 > 3;
  if ( !result )
    v2 = 1;
  if ( v2 )
  {
    if ( byte_590404 || byte_482A5C || dword_7EBA0 > 2 )
    {
      snprintf(v6, 0x800u, "%s: input bad param\n", "api_miner_chain_asic_num");
      return sub_2E584(3, v6, 0);
    }
  }
  else
  {
    v3 = (_DWORD *)result;
    v4 = sub_1E67C(a2);
    v5 = (_DWORD *)sub_4E990(v4);
    return sub_4EFD4(v3, "asic_num", v5);
  }
  return result;
}
// 7EBA0: using guessed type int dword_7EBA0;
// 482A5C: using guessed type char byte_482A5C;
// 590404: using guessed type char byte_590404;

//----- (0001FE9C) --------------------------------------------------------
void *__fastcall sub_1FE9C(_DWORD *a1, unsigned int a2)
{
  void *result; // r0
  _BOOL4 v5; // r3
  char *v6; // r0
  char v7[512]; // [sp+0h] [bp-A10h] BYREF
  char s[2064]; // [sp+200h] [bp-810h] BYREF

  result = memset(v7, 0, sizeof(v7));
  v5 = a2 > 3;
  if ( !a1 )
    v5 = 1;
  if ( v5 )
  {
    if ( byte_590404 || byte_482A5C || dword_7EBA0 > 2 )
    {
      snprintf(s, 0x800u, "%s: input bad param\n", "api_miner_chain_asic_status");
      return (void *)sub_2E584(3, s, 0);
    }
  }
  else
  {
    sub_1E894(a2, v7);
    v6 = (char *)sub_4E744(v7);
    return (void *)sub_4EFD4(a1, "asic", v6);
  }
  return result;
}
// 7EBA0: using guessed type int dword_7EBA0;
// 482A5C: using guessed type char byte_482A5C;
// 590404: using guessed type char byte_590404;

//----- (0001FF90) --------------------------------------------------------
int __fastcall sub_1FF90(int result, unsigned int a2)
{
  _BOOL4 v2; // r3
  _DWORD *v4; // r6
  _DWORD *v5; // r7
  const char *v6; // r0
  const char *v7; // r0
  int v8; // r8
  int v9; // r4
  int v10; // r1
  __int16 v11; // r0
  _DWORD *v12; // r0
  char v13[2072]; // [sp+0h] [bp-818h] BYREF

  v2 = a2 > 3;
  if ( !result )
    v2 = 1;
  if ( v2 )
  {
    if ( byte_590404 || byte_482A5C || dword_7EBA0 > 2 )
    {
      snprintf(v13, 0x800u, "%s: input bad param\n", "api_miner_chain_temp_pic");
      return sub_2E584(3, v13, 0);
    }
  }
  else
  {
    v4 = (_DWORD *)result;
    v5 = sub_4E540();
    v6 = (const char *)sub_1E0C0();
    if ( !strcmp(v6, "BHB28601") || (v7 = (const char *)sub_1E0C0(), !strcmp(v7, "BHB28501")) )
      v8 = sub_14434();
    else
      v8 = sub_1E19C();
    if ( v8 > 0 )
    {
      v9 = 0;
      do
      {
        v10 = (unsigned __int8)v9++;
        v11 = sub_152F0(a2, v10);
        v12 = (_DWORD *)sub_4E990(v11);
        sub_4F494(v5, v12);
      }
      while ( v8 != v9 );
    }
    return sub_4EFD4(v4, "temp_pic", v5);
  }
  return result;
}
// 7EBA0: using guessed type int dword_7EBA0;
// 482A5C: using guessed type char byte_482A5C;
// 590404: using guessed type char byte_590404;

//----- (000200D0) --------------------------------------------------------
int __fastcall sub_200D0(int result, unsigned int a2)
{
  int v2; // r4
  _DWORD *v4; // r6
  _DWORD *v5; // r7
  __int16 v6; // r0
  _DWORD *v7; // r0
  bool v8; // cc
  int v9; // r1
  __int16 v10; // r0
  _DWORD *v11; // r0
  char v12[2072]; // [sp+0h] [bp-818h] BYREF

  v2 = a2 > 3;
  if ( !result )
    v2 = 1;
  if ( v2 )
  {
    if ( byte_590404 || byte_482A5C || dword_7EBA0 > 2 )
    {
      snprintf(v12, 0x800u, "%s: input bad param\n", "api_miner_chain_temp_chip");
      return sub_2E584(3, v12, 0);
    }
  }
  else
  {
    v4 = (_DWORD *)result;
    v5 = sub_4E540();
    if ( dword_80FB4 == 1 || dword_482A8C <= 0 )
    {
      while ( sub_1E19C() > v2 )
      {
        v10 = sub_152F0(a2, (unsigned __int8)v2++);
        v11 = (_DWORD *)sub_4E990(v10);
        sub_4F494(v5, v11);
      }
    }
    else
    {
      while ( 1 )
      {
        v8 = sub_14434() <= v2;
        v9 = (unsigned __int8)v2++;
        if ( v8 )
          break;
        v6 = sub_153A0(a2, v9);
        v7 = (_DWORD *)sub_4E990(v6);
        sub_4F494(v5, v7);
      }
    }
    return sub_4EFD4(v4, "temp_chip", v5);
  }
  return result;
}
// 7EBA0: using guessed type int dword_7EBA0;
// 80FB4: using guessed type int dword_80FB4;
// 482A5C: using guessed type char byte_482A5C;
// 482A8C: using guessed type int dword_482A8C;
// 590404: using guessed type char byte_590404;

//----- (00020234) --------------------------------------------------------
int __fastcall sub_20234(int result, unsigned int a2)
{
  int v2; // r4
  _DWORD *v4; // r6
  _DWORD *v5; // r7
  __int16 v6; // r0
  _DWORD *v7; // r0
  bool v8; // cc
  int v9; // r1
  __int16 v10; // r0
  _DWORD *v11; // r0
  char v12[2072]; // [sp+0h] [bp-818h] BYREF

  v2 = a2 > 3;
  if ( !result )
    v2 = 1;
  if ( v2 )
  {
    if ( byte_590404 || byte_482A5C || dword_7EBA0 > 2 )
    {
      snprintf(v12, 0x800u, "%s: input bad param\n", "api_miner_chain_temp_pcb");
      return sub_2E584(3, v12, 0);
    }
  }
  else
  {
    v4 = (_DWORD *)result;
    v5 = sub_4E540();
    if ( dword_80FB4 == 1 || dword_482A8C <= 0 )
    {
      while ( sub_1E19C() > v2 )
      {
        v10 = sub_152F0(a2, (unsigned __int8)v2++);
        v11 = (_DWORD *)sub_4E990(v10);
        sub_4F494(v5, v11);
      }
    }
    else
    {
      while ( 1 )
      {
        v8 = sub_14434() <= v2;
        v9 = (unsigned __int8)v2++;
        if ( v8 )
          break;
        v6 = sub_15354(a2, v9);
        v7 = (_DWORD *)sub_4E990(v6);
        sub_4F494(v5, v7);
      }
    }
    return sub_4EFD4(v4, "temp_pcb", v5);
  }
  return result;
}
// 7EBA0: using guessed type int dword_7EBA0;
// 80FB4: using guessed type int dword_80FB4;
// 482A5C: using guessed type char byte_482A5C;
// 482A8C: using guessed type int dword_482A8C;
// 590404: using guessed type char byte_590404;

//----- (00020398) --------------------------------------------------------
int __fastcall sub_20398(int result, unsigned int a2)
{
  unsigned int v2; // r6
  _DWORD *v3; // r8
  _DWORD *v4; // r5
  double *v5; // r4
  double v6; // t1
  __int64 v7; // r0
  _DWORD *v8; // r0
  unsigned int v9; // r10
  unsigned int v10; // r9
  unsigned int v11; // r3
  __int64 v12; // r0
  _DWORD *v13; // r0
  char s[2080]; // [sp+8h] [bp-820h] BYREF

  v2 = a2 > 3;
  if ( !result )
    v2 = 1;
  if ( v2 )
  {
    if ( byte_590404 || byte_482A5C || dword_7EBA0 > 2 )
    {
      snprintf(s, 0x800u, "%s: input bad param\n", "api_miner_chain_rate_array");
      return sub_2E584(3, s, 0);
    }
  }
  else
  {
    v3 = (_DWORD *)result;
    v4 = sub_4E540();
    if ( (unsigned int)dword_7F8F0 > 0x17 )
    {
      v9 = dword_7F8F0 % 0x18u;
      v10 = dword_7F8F0 % 0x18u + 24;
      do
      {
        v11 = v9 % 0x18;
        ++v9;
        LODWORD(v12) = sub_6015C(dbl_58E040[24 * a2 + v11]);
        v13 = (_DWORD *)sub_4E990(v12);
        sub_4F494(v4, v13);
      }
      while ( v10 != v9 );
    }
    else if ( dword_7F8F0 )
    {
      v5 = &dbl_58E040[24 * a2];
      do
      {
        v6 = *v5++;
        ++v2;
        LODWORD(v7) = sub_6015C(v6);
        v8 = (_DWORD *)sub_4E990(v7);
        sub_4F494(v4, v8);
      }
      while ( v2 < dword_7F8F0 );
    }
    return sub_4EFD4(v3, "rate_array", v4);
  }
  return result;
}
// 2047C: variable 'v7' is possibly undefined
// 20508: variable 'v12' is possibly undefined
// 7EBA0: using guessed type int dword_7EBA0;
// 7F8F0: using guessed type int dword_7F8F0;
// 482A5C: using guessed type char byte_482A5C;
// 58E040: using guessed type double dbl_58E040[96];
// 590404: using guessed type char byte_590404;

//----- (00020528) --------------------------------------------------------
int __fastcall sub_20528(int result, unsigned int a2)
{
  _BOOL4 v2; // r3
  _DWORD *v3; // r4
  int v4; // r0
  _DWORD *v5; // r0
  char v6[2056]; // [sp+0h] [bp-808h] BYREF

  v2 = a2 > 3;
  if ( !result )
    v2 = 1;
  if ( v2 )
  {
    if ( byte_590404 || byte_482A5C || dword_7EBA0 > 2 )
    {
      snprintf(v6, 0x800u, "%s: input bad param\n", "api_miner_chain_hw");
      return sub_2E584(3, v6, 0);
    }
  }
  else
  {
    v3 = (_DWORD *)result;
    v4 = sub_1E7BC(a2);
    v5 = (_DWORD *)sub_4E990(v4);
    return sub_4EFD4(v3, "hw", v5);
  }
  return result;
}
// 7EBA0: using guessed type int dword_7EBA0;
// 482A5C: using guessed type char byte_482A5C;
// 590404: using guessed type char byte_590404;

//----- (000205EC) --------------------------------------------------------
int __fastcall sub_205EC(int result, unsigned int a2)
{
  _BOOL4 v2; // r3
  _DWORD *v3; // r4
  _DWORD *v4; // r0
  char v5[2056]; // [sp+0h] [bp-808h] BYREF

  v2 = a2 > 3;
  if ( !result )
    v2 = 1;
  if ( v2 )
  {
    if ( byte_590404 || byte_482A5C || dword_7EBA0 > 2 )
    {
      snprintf(v5, 0x800u, "%s: input bad param\n", "api_miner_chain_nonce");
      return sub_2E584(3, v5, 0);
    }
  }
  else
  {
    v3 = (_DWORD *)result;
    v4 = (_DWORD *)sub_4E990(dword_81118[a2]);
    return sub_4EFD4(v3, "nonce", v4);
  }
  return result;
}
// 7EBA0: using guessed type int dword_7EBA0;
// 81118: using guessed type int dword_81118[3];
// 482A5C: using guessed type char byte_482A5C;
// 590404: using guessed type char byte_590404;

//----- (000206B4) --------------------------------------------------------
int __fastcall sub_206B4(int result, unsigned int a2)
{
  _BOOL4 v2; // r3
  _DWORD *v3; // r4
  _DWORD *v4; // r2
  char v5[2056]; // [sp+0h] [bp-808h] BYREF

  v2 = a2 > 3;
  if ( !result )
    v2 = 1;
  if ( v2 )
  {
    if ( byte_590404 || byte_482A5C || dword_7EBA0 > 2 )
    {
      snprintf(v5, 0x800u, "%s: input bad param\n", "api_miner_chain_eeprom");
      return sub_2E584(3, v5, 0);
    }
  }
  else
  {
    v3 = (_DWORD *)result;
    if ( sub_18B30(a2) )
      v4 = sub_4EB48();
    else
      v4 = sub_4EB54();
    return sub_4EFD4(v3, "eeprom", v4);
  }
  return result;
}
// 7EBA0: using guessed type int dword_7EBA0;
// 482A5C: using guessed type char byte_482A5C;
// 590404: using guessed type char byte_590404;

//----- (00020788) --------------------------------------------------------
void *__fastcall sub_20788(_DWORD *a1, size_t a2)
{
  void *result; // r0
  _BOOL4 v5; // r3
  char *v6; // r0
  char v7[32]; // [sp+0h] [bp-830h] BYREF
  char s[2064]; // [sp+20h] [bp-810h] BYREF

  result = memset(v7, 0, sizeof(v7));
  v5 = a2 > 3;
  if ( !a1 )
    v5 = 1;
  if ( v5 )
  {
    if ( byte_590404 || byte_482A5C || dword_7EBA0 > 2 )
    {
      snprintf(s, 0x800u, "%s: input bad param\n", "api_miner_chain_sn");
      return (void *)sub_2E584(3, s, 0);
    }
  }
  else
  {
    sub_17FD8(a2, v7, 0x20u);
    v6 = (char *)sub_4E744(v7);
    return (void *)sub_4EFD4(a1, "sn", v6);
  }
  return result;
}
// 7EBA0: using guessed type int dword_7EBA0;
// 482A5C: using guessed type char byte_482A5C;
// 590404: using guessed type char byte_590404;

//----- (00020880) --------------------------------------------------------
int __fastcall sub_20880(_DWORD *a1, int a2)
{
  _DWORD *v3; // r0
  unsigned int v5; // [sp+4h] [bp-14h] BYREF

  v5 = 0;
  sub_18654(a2, 2, (int *)&v5);
  v3 = (_DWORD *)sub_4E990(v5);
  return sub_4EFD4(a1, "eeprom_vol", v3);
}

//----- (000208CC) --------------------------------------------------------
int __fastcall sub_208CC(_DWORD *a1, int a2)
{
  _DWORD *v3; // r0
  unsigned int v5; // [sp+4h] [bp-14h] BYREF

  v5 = 0;
  sub_183FC(a2, 2, (int *)&v5);
  v3 = (_DWORD *)sub_4E990(v5);
  return sub_4EFD4(a1, "eeprom_freq", v3);
}

//----- (00020918) --------------------------------------------------------
int __fastcall sub_20918(_DWORD *a1, int a2)
{
  _DWORD *v3; // r0
  unsigned int v5; // [sp+4h] [bp-14h] BYREF

  v5 = 0;
  sub_182FC(a2, &v5);
  v3 = (_DWORD *)sub_4E990(v5);
  return sub_4EFD4(a1, "eeprom_bin", v3);
}

//----- (00020964) --------------------------------------------------------
int __fastcall sub_20964(_DWORD *a1, int a2)
{
  char *v3; // r0
  int v5[6]; // [sp+0h] [bp-18h] BYREF

  memset(v5, 0, 16);
  sub_18360(a2, (char *)v5, 0x10u);
  v3 = (char *)sub_4E744((const char *)v5);
  return sub_4EFD4(a1, "eeprom_ft", v3);
}

//----- (000209BC) --------------------------------------------------------
int __fastcall sub_209BC(_DWORD *a1, int a2)
{
  _DWORD *v3; // r0
  unsigned int v5; // [sp+4h] [bp-14h] BYREF

  v5 = 0;
  sub_18258(a2, &v5);
  v3 = (_DWORD *)sub_4E990(v5);
  return sub_4EFD4(a1, "eeprom_code", v3);
}

//----- (00020A08) --------------------------------------------------------
char __fastcall sub_20A08(char result)
{
  LOBYTE(dword_7F8F4) = dword_7F8F4 & 0xFE | result & 1;
  return result;
}
// 7F8F4: using guessed type int dword_7F8F4;

//----- (00020A20) --------------------------------------------------------
char __fastcall sub_20A20(char result)
{
  LOBYTE(dword_7F8F4) = dword_7F8F4 & 0xFD | (2 * (result & 1));
  return result;
}
// 7F8F4: using guessed type int dword_7F8F4;

//----- (00020A38) --------------------------------------------------------
char __fastcall sub_20A38(char result)
{
  LOBYTE(dword_7F8F4) = dword_7F8F4 & 0xFB | (4 * (result & 1));
  return result;
}
// 7F8F4: using guessed type int dword_7F8F4;

//----- (00020A50) --------------------------------------------------------
int __fastcall sub_20A50(_DWORD *a1)
{
  int v2; // r4
  _DWORD *v3; // r0
  char v5[2064]; // [sp+0h] [bp-810h] BYREF

  v2 = dword_7F8F4;
  if ( (unsigned int)dword_7EB9C > 4 )
  {
    snprintf(v5, 0x800u, "error_code = %d\n", dword_7F8F4);
    sub_2E584(4, v5, 0);
  }
  v3 = (_DWORD *)sub_4E990(v2);
  return sub_4EFD4(a1, "error_code", v3);
}
// 7EB9C: using guessed type int dword_7EB9C;
// 7F8F4: using guessed type int dword_7F8F4;

//----- (00020AD4) --------------------------------------------------------
int __fastcall sub_20AD4(int result)
{
  _DWORD *v1; // r4
  char *v2; // r0
  char v3[2056]; // [sp+0h] [bp-808h] BYREF

  v1 = (_DWORD *)result;
  if ( result )
  {
    v2 = (char *)sub_4E744(byte_80FDC);
    return sub_4EFD4(v1, "miner_version", v2);
  }
  else if ( byte_590404 || byte_482A5C || dword_7EBA0 > 2 )
  {
    snprintf(v3, 0x800u, "%s: input bad json param\n", "api_miner_version");
    return sub_2E584(3, v3, 0);
  }
  return result;
}
// 7EBA0: using guessed type int dword_7EBA0;
// 482A5C: using guessed type char byte_482A5C;
// 590404: using guessed type char byte_590404;

//----- (00020B7C) --------------------------------------------------------
int __fastcall sub_20B7C(int result)
{
  _DWORD *v1; // r4
  _DWORD *v2; // r0
  char v3[2056]; // [sp+0h] [bp-808h] BYREF

  v1 = (_DWORD *)result;
  if ( result )
  {
    v2 = (_DWORD *)sub_4EA14();
    return sub_4EFD4(v1, "total_hash", v2);
  }
  else if ( byte_590404 || byte_482A5C || dword_7EBA0 > 2 )
  {
    snprintf(v3, 0x800u, "%s: input bad json param\n", "api_total_hash");
    return sub_2E584(3, v3, 0);
  }
  return result;
}
// 7EBA0: using guessed type int dword_7EBA0;
// 482A5C: using guessed type char byte_482A5C;
// 590404: using guessed type char byte_590404;

//----- (00020C28) --------------------------------------------------------
int __fastcall sub_20C28(int result)
{
  _DWORD *v1; // r4
  char *v2; // r0
  char v3[2056]; // [sp+0h] [bp-808h] BYREF

  v1 = (_DWORD *)result;
  if ( result )
  {
    v2 = (char *)sub_4E744(byte_99EDE0);
    return sub_4EFD4(v1, "miner_id", v2);
  }
  else if ( byte_590404 || byte_482A5C || dword_7EBA0 > 2 )
  {
    snprintf(v3, 0x800u, "%s: input bad json param\n", "api_miner_id");
    return sub_2E584(3, v3, 0);
  }
  return result;
}
// 7EBA0: using guessed type int dword_7EBA0;
// 482A5C: using guessed type char byte_482A5C;
// 590404: using guessed type char byte_590404;

//----- (00020CD0) --------------------------------------------------------
_DWORD *__fastcall sub_20CD0(_DWORD *result)
{
  result[2] = 1779033703;
  result[3] = -1150833019;
  result[4] = 1013904242;
  result[5] = -1521486534;
  result[6] = 1359893119;
  result[7] = -1694144372;
  result[8] = 528734635;
  result[9] = 1541459225;
  *result = 0;
  result[1] = 0;
  return result;
}

//----- (00020D44) --------------------------------------------------------
int __fastcall sub_20D44(_DWORD *a1, unsigned int *a2)
{
  int v2; // r7
  int v4; // r8
  int v5; // r1
  int v6; // r9
  unsigned int v7; // r5
  unsigned int v8; // r3
  int v9; // r6
  unsigned int v10; // r12
  int v11; // r3
  int v12; // r0
  int v13; // r5
  int v14; // r3
  int v15; // r2
  int v16; // r4
  int v17; // lr
  int v18; // r3
  int v19; // r11
  int v20; // r6
  unsigned int v21; // r12
  int v22; // r10
  int v23; // r6
  int v24; // r0
  int v25; // r6
  int v26; // r8
  int v27; // r5
  int v28; // r2
  int v29; // r9
  int v30; // r3
  int v31; // r9
  int v32; // r11
  int v33; // r10
  int v34; // r11
  int v35; // r12
  int v36; // r6
  int v37; // r7
  int v38; // r12
  int v39; // r5
  int v40; // lr
  int v41; // r12
  int v42; // r2
  int v43; // r9
  int v44; // r10
  int v45; // r4
  int v46; // r11
  int v47; // r6
  int v48; // r7
  int v49; // r0
  int v50; // r5
  int v51; // r6
  int v52; // lr
  int v53; // r9
  int v54; // r2
  int v55; // r11
  int v56; // r9
  int v57; // r3
  unsigned int v58; // r10
  int v59; // r1
  int v60; // r4
  int v61; // r12
  int v62; // lr
  int v63; // r6
  int v64; // r0
  int v65; // r2
  int v66; // r1
  int v67; // r5
  int v68; // r9
  int v69; // lr
  int v70; // r2
  int v71; // r4
  int v72; // r12
  int v73; // r3
  int v74; // r4
  int v75; // r0
  int v76; // r4
  int v77; // r8
  int v78; // r1
  int v79; // r9
  unsigned int v80; // r10
  int v81; // r7
  int v82; // r2
  int v83; // r7
  int v84; // r6
  int v85; // r12
  int v86; // r3
  int v87; // r6
  int v88; // r4
  int v89; // r0
  int v90; // r6
  int v91; // r1
  int v92; // r9
  int v93; // r5
  int v94; // r7
  int v95; // r5
  int v96; // lr
  int v97; // r12
  int v98; // r3
  int v99; // lr
  int v100; // r0
  int v101; // r4
  int v102; // lr
  int v103; // r9
  int v104; // r1
  int v105; // lr
  int v106; // r8
  int v107; // r5
  int v108; // r11
  int v109; // r6
  int v110; // r3
  int v111; // r10
  int v112; // r1
  int v113; // r4
  int v114; // r8
  int v115; // r1
  int v116; // r6
  int v117; // r2
  int v118; // r5
  int v119; // r0
  int v120; // r12
  int v121; // lr
  int v122; // r7
  int v123; // r3
  int v124; // r9
  int v125; // r1
  int v126; // r4
  int v127; // r5
  int v128; // r9
  int v129; // r10
  int v130; // r5
  int v131; // r12
  int v132; // r2
  int v133; // r8
  int v134; // r3
  int v135; // r0
  int v136; // r7
  int v137; // r11
  int v138; // r1
  int v139; // r10
  int v140; // r8
  int v141; // r5
  int v142; // r2
  int v143; // r9
  int v144; // r5
  int v145; // r0
  int v146; // r12
  int v147; // r7
  int v148; // r11
  int v149; // r3
  int v150; // r7
  int v151; // r10
  int v152; // lr
  int v153; // r7
  int v154; // r9
  int v155; // r8
  int v156; // r6
  int v157; // r5
  int v158; // r12
  int v159; // r0
  int v160; // r3
  int v161; // r0
  int v162; // r11
  int v163; // lr
  int v164; // r11
  int v165; // r10
  int v166; // r8
  int v167; // r10
  int v168; // r9
  int v169; // r5
  int v170; // r9
  int v171; // r12
  int v172; // r0
  int v173; // r12
  int v174; // r7
  int v175; // r11
  int v176; // r3
  unsigned int v177; // r6
  unsigned int v178; // r1
  int v179; // lr
  int v180; // r2
  int v181; // r3
  unsigned int v182; // r7
  int v183; // r4
  int v184; // r12
  int v185; // r4
  unsigned int v186; // r10
  int v187; // r1
  int v188; // r8
  int v189; // lr
  int v190; // r10
  unsigned int v191; // r7
  int v192; // r6
  int v193; // r1
  int v194; // r2
  unsigned int v195; // r8
  int v196; // r9
  int v197; // r3
  int v198; // r0
  int v199; // r6
  int v200; // r5
  int v201; // r4
  int v202; // r12
  int v203; // r9
  int result; // r0
  unsigned int *v205; // [sp+4h] [bp-9Ch]
  unsigned int v206; // [sp+4h] [bp-9Ch]
  unsigned int v207; // [sp+4h] [bp-9Ch]
  int v208; // [sp+4h] [bp-9Ch]
  unsigned int v209; // [sp+8h] [bp-98h]
  unsigned int v210; // [sp+8h] [bp-98h]
  unsigned int v211; // [sp+8h] [bp-98h]
  unsigned int v212; // [sp+Ch] [bp-94h]
  unsigned int v213; // [sp+Ch] [bp-94h]
  unsigned int v214; // [sp+Ch] [bp-94h]
  unsigned int v215; // [sp+10h] [bp-90h]
  unsigned int v216; // [sp+10h] [bp-90h]
  unsigned int v217; // [sp+10h] [bp-90h]
  unsigned int v218; // [sp+14h] [bp-8Ch]
  unsigned int v219; // [sp+14h] [bp-8Ch]
  unsigned int v220; // [sp+14h] [bp-8Ch]
  unsigned int v221; // [sp+18h] [bp-88h]
  unsigned int v222; // [sp+18h] [bp-88h]
  unsigned int v223; // [sp+18h] [bp-88h]
  unsigned int v224; // [sp+18h] [bp-88h]
  unsigned int v225; // [sp+1Ch] [bp-84h]
  unsigned int v226; // [sp+1Ch] [bp-84h]
  unsigned int v227; // [sp+1Ch] [bp-84h]
  int v228; // [sp+1Ch] [bp-84h]
  int v229; // [sp+1Ch] [bp-84h]
  unsigned int v230; // [sp+20h] [bp-80h]
  unsigned int v231; // [sp+20h] [bp-80h]
  unsigned int v232; // [sp+20h] [bp-80h]
  unsigned int v233; // [sp+20h] [bp-80h]
  unsigned int v234; // [sp+24h] [bp-7Ch]
  int v235; // [sp+24h] [bp-7Ch]
  unsigned int v236; // [sp+24h] [bp-7Ch]
  unsigned int v237; // [sp+24h] [bp-7Ch]
  unsigned int v238; // [sp+24h] [bp-7Ch]
  unsigned int v239; // [sp+28h] [bp-78h]
  unsigned int v240; // [sp+28h] [bp-78h]
  unsigned int v241; // [sp+28h] [bp-78h]
  int v242; // [sp+28h] [bp-78h]
  unsigned int v243; // [sp+2Ch] [bp-74h]
  unsigned int v244; // [sp+2Ch] [bp-74h]
  unsigned int v245; // [sp+2Ch] [bp-74h]
  int v246; // [sp+2Ch] [bp-74h]
  unsigned int v247; // [sp+30h] [bp-70h]
  unsigned int v248; // [sp+30h] [bp-70h]
  unsigned int v249; // [sp+30h] [bp-70h]
  unsigned int v250; // [sp+34h] [bp-6Ch]
  unsigned int v251; // [sp+34h] [bp-6Ch]
  unsigned int v252; // [sp+34h] [bp-6Ch]
  unsigned int v253; // [sp+34h] [bp-6Ch]
  unsigned int v254; // [sp+38h] [bp-68h]
  unsigned int v255; // [sp+38h] [bp-68h]
  unsigned int v256; // [sp+38h] [bp-68h]
  unsigned int v257; // [sp+3Ch] [bp-64h]
  unsigned int v258; // [sp+3Ch] [bp-64h]
  unsigned int v259; // [sp+3Ch] [bp-64h]
  unsigned int v260; // [sp+40h] [bp-60h]
  unsigned int v261; // [sp+40h] [bp-60h]
  unsigned int v262; // [sp+40h] [bp-60h]
  unsigned int v263; // [sp+40h] [bp-60h]
  unsigned int v264; // [sp+44h] [bp-5Ch]
  unsigned int v265; // [sp+44h] [bp-5Ch]
  unsigned int v266; // [sp+44h] [bp-5Ch]
  unsigned int v267; // [sp+44h] [bp-5Ch]
  unsigned int v268; // [sp+48h] [bp-58h]
  unsigned int v269; // [sp+48h] [bp-58h]
  unsigned int v270; // [sp+48h] [bp-58h]
  int v271; // [sp+4Ch] [bp-54h]
  unsigned int v272; // [sp+50h] [bp-50h]
  unsigned int v273; // [sp+54h] [bp-4Ch]
  int v274; // [sp+58h] [bp-48h]
  int v275; // [sp+5Ch] [bp-44h]
  int v276; // [sp+60h] [bp-40h]
  int v277; // [sp+64h] [bp-3Ch]
  int v278; // [sp+68h] [bp-38h]
  int v279; // [sp+6Ch] [bp-34h]
  int v280; // [sp+70h] [bp-30h]

  v2 = a1[2];
  v4 = a1[6];
  v5 = a1[8];
  v6 = a1[7];
  v205 = a2;
  v275 = a1[3];
  v277 = a1[5];
  v280 = a1[9];
  v7 = bswap32(*a2);
  v276 = a1[4];
  v8 = (__ROR4__(v4, 11) ^ __ROR4__(v4, 6) ^ __ROR4__(v4, 25)) + v280 + 1116352408 + ((v6 ^ v5) & v4 ^ v5) + v7;
  v225 = v7;
  v9 = v277 + v8;
  v10 = (__ROR4__(v2, 13) ^ __ROR4__(v2, 2) ^ __ROR4__(v2, 22)) + ((v2 | v275) & v276 | v2 & v275) + v8;
  v209 = bswap32(a2[1]);
  v274 = v2;
  v279 = v5;
  v11 = ((v4 ^ v6) & (v277 + v8) ^ v6)
      + v5
      + 1899447441
      + v209
      + (__ROR4__(v277 + v8, 11) ^ __ROR4__(v277 + v8, 6) ^ __ROR4__(v277 + v8, 25));
  v271 = v4;
  v12 = (__ROR4__(v10, 13) ^ __ROR4__(v10, 2) ^ __ROR4__(v10, 22)) + ((v2 | v10) & v275 | v2 & v10) + v11;
  v13 = v276 + v11;
  v278 = v6;
  v260 = bswap32(a2[2]);
  v14 = ((v271 ^ v9) & (v276 + v11) ^ v271)
      + v6
      - 1245643825
      + v260
      + (__ROR4__(v276 + v11, 11) ^ __ROR4__(v276 + v11, 6) ^ __ROR4__(v276 + v11, 25));
  v15 = (__ROR4__(v12, 13) ^ __ROR4__(v12, 2) ^ __ROR4__(v12, 22)) + ((v10 | v12) & v2 | v10 & v12) + v14;
  v16 = v275 + v14;
  v230 = bswap32(a2[3]);
  v17 = ((v9 ^ v13) & v16 ^ v9)
      + v4
      - 373957723
      + v230
      + (__ROR4__(v275 + v14, 11) ^ __ROR4__(v16, 6) ^ __ROR4__(v16, 25));
  v18 = (__ROR4__(v15, 13) ^ __ROR4__(v15, 2) ^ __ROR4__(v15, 22)) + ((v12 | v15) & v10 | v12 & v15) + v17;
  v19 = v2 + v17;
  v221 = a2[8];
  v264 = bswap32(a2[4]);
  v20 = ((v13 ^ v16) & (v274 + v17) ^ v13)
      + v264
      + 961987163
      + v9
      + (__ROR4__(v19, 11) ^ __ROR4__(v19, 6) ^ __ROR4__(v274 + v17, 25));
  v21 = v10 + v20;
  v234 = a2[9];
  v250 = a2[10];
  v22 = (__ROR4__(v18, 13) ^ __ROR4__(v18, 2) ^ __ROR4__(v18, 22)) + ((v15 | v18) & v12 | v15 & v18) + v20;
  v239 = bswap32(v205[5]);
  v23 = ((v16 ^ (v2 + v17)) & v21 ^ v16)
      + v239
      + 1508970993
      + v13
      + (__ROR4__(v21, 11) ^ __ROR4__(v21, 6) ^ __ROR4__(v21, 25));
  v24 = v12 + v23;
  v25 = (__ROR4__(v22, 13) ^ __ROR4__(v22, 2) ^ __ROR4__(v22, 22)) + ((v18 | v22) & v15 | v18 & v22) + v23;
  v257 = bswap32(v205[6]);
  v26 = ((v19 ^ v21) & v24 ^ v19) + v257 - 1841331548 + v16 + (__ROR4__(v24, 11) ^ __ROR4__(v24, 6) ^ __ROR4__(v24, 25));
  v27 = (__ROR4__(v25, 13) ^ __ROR4__(v25, 2) ^ __ROR4__(v25, 22)) + ((v22 | v25) & v18 | v22 & v25) + v26;
  v28 = v15 + v26;
  v243 = bswap32(v205[7]);
  v29 = ((v21 ^ v24) & v28 ^ v21)
      + v243
      - 1424204075
      + v2
      + v17
      + (__ROR4__(v28, 11) ^ __ROR4__(v28, 6) ^ __ROR4__(v28, 25));
  v30 = v18 + v29;
  v247 = bswap32(v221);
  v212 = bswap32(v234);
  v31 = (__ROR4__(v27, 13) ^ __ROR4__(v27, 2) ^ __ROR4__(v27, 22)) + ((v25 | v27) & v22 | v25 & v27) + v29;
  v215 = bswap32(v250);
  v218 = bswap32(v205[11]);
  v32 = ((v24 ^ v28) & v30 ^ v24) + v247 - 670586216 + v21 + (__ROR4__(v30, 11) ^ __ROR4__(v30, 6) ^ __ROR4__(v30, 25));
  v33 = v22 + v32;
  v251 = bswap32(v205[12]);
  v34 = (__ROR4__(v31, 13) ^ __ROR4__(v31, 2) ^ __ROR4__(v31, 22)) + ((v27 | v31) & v25 | v27 & v31) + v32;
  v35 = ((v28 ^ v30) & v33 ^ v28) + v212 + 310598401 + v24 + (__ROR4__(v33, 11) ^ __ROR4__(v33, 6) ^ __ROR4__(v33, 25));
  v36 = v25 + v35;
  v254 = bswap32(v205[13]);
  v37 = (__ROR4__(v34, 13) ^ __ROR4__(v34, 2) ^ __ROR4__(v34, 22)) + ((v31 | v34) & v27 | v31 & v34) + v35;
  v222 = bswap32(v205[14]);
  v38 = ((v30 ^ v33) & v36 ^ v30) + v215 + 607225278 + v28 + (__ROR4__(v36, 11) ^ __ROR4__(v36, 6) ^ __ROR4__(v36, 25));
  v206 = bswap32(v205[15]);
  v39 = v27 + v38;
  v40 = (__ROR4__(v37, 13) ^ __ROR4__(v37, 2) ^ __ROR4__(v37, 22)) + ((v34 | v37) & v31 | v34 & v37) + v38;
  v268 = v209 + v215;
  v41 = ((v33 ^ v36) & v39 ^ v33) + v218 + 1426881987 + v30 + (__ROR4__(v39, 11) ^ __ROR4__(v39, 6) ^ __ROR4__(v39, 25));
  v42 = (__ROR4__(v40, 13) ^ __ROR4__(v40, 2) ^ __ROR4__(v40, 22)) + ((v37 | v40) & v34 | v37 & v40) + v41;
  v43 = v31 + v41;
  v44 = ((v36 ^ v39) & v43 ^ v36) + v251 + 1925078388 + v33 + (__ROR4__(v43, 11) ^ __ROR4__(v43, 6) ^ __ROR4__(v43, 25));
  v45 = (__ROR4__(v42, 13) ^ __ROR4__(v42, 2) ^ __ROR4__(v42, 22)) + ((v40 | v42) & v37 | v40 & v42) + v44;
  v46 = v34 + v44;
  v47 = ((v39 ^ v43) & v46 ^ v39) + v254 - 2132889090 + v36 + (__ROR4__(v46, 11) ^ __ROR4__(v46, 6) ^ __ROR4__(v46, 25));
  v48 = v37 + v47;
  v49 = (__ROR4__(v45, 13) ^ __ROR4__(v45, 2) ^ __ROR4__(v45, 22)) + ((v42 | v45) & v40 | v42 & v45) + v47;
  v50 = ((v43 ^ v46) & v48 ^ v43) + v222 - 1680079193 + v39 + (__ROR4__(v48, 11) ^ __ROR4__(v48, 6) ^ __ROR4__(v48, 25));
  v51 = (__ROR4__(v49, 13) ^ __ROR4__(v49, 2) ^ __ROR4__(v49, 22)) + ((v45 | v49) & v42 | v45 & v49) + v50;
  v52 = v40 + v50;
  v53 = ((v46 ^ v48) & v52 ^ v46) + v206 - 1046744716 + v43 + (__ROR4__(v52, 11) ^ __ROR4__(v52, 6) ^ __ROR4__(v52, 25));
  v54 = v42 + v53;
  v210 = (__ROR4__(v222, 19) ^ __ROR4__(v222, 17) ^ (v222 >> 10))
       + v225
       + v212
       + (__ROR4__(v209, 18) ^ __ROR4__(v209, 7) ^ (v209 >> 3));
  v235 = (__ROR4__(v51, 13) ^ __ROR4__(v51, 2) ^ __ROR4__(v51, 22)) + ((v49 | v51) & v45 | v49 & v51) + v53;
  v55 = ((v48 ^ v52) & v54 ^ v48) + v210 - 459576895 + v46 + (__ROR4__(v54, 11) ^ __ROR4__(v54, 6) ^ __ROR4__(v54, 25));
  v56 = v45 + v55;
  v57 = (__ROR4__(v235, 13) ^ __ROR4__(v235, 2) ^ __ROR4__(v235, 22)) + ((v51 | v235) & v49 | v51 & v235) + v55;
  v58 = (__ROR4__(v206, 19) ^ __ROR4__(v206, 17) ^ (v206 >> 10))
      + v268
      + (__ROR4__(v260, 18) ^ __ROR4__(v260, 7) ^ (v260 >> 3));
  v59 = ((v52 ^ v54) & (v45 + v55) ^ v52)
      + v58
      - 272742522
      + v48
      + (__ROR4__(v45 + v55, 11) ^ __ROR4__(v45 + v55, 6) ^ __ROR4__(v45 + v55, 25));
  v60 = v49 + v59;
  v61 = (__ROR4__(v57, 13) ^ __ROR4__(v57, 2) ^ __ROR4__(v57, 22)) + ((v235 | v57) & v51 | v235 & v57) + v59;
  v226 = (__ROR4__(v230, 18) ^ __ROR4__(v230, 7) ^ (v230 >> 3))
       + v260
       + v218
       + (__ROR4__(v210, 19) ^ __ROR4__(v210, 17) ^ (v210 >> 10));
  v62 = ((v54 ^ v56) & v60 ^ v54)
      + v226
      + 264347078
      + v52
      + (__ROR4__(v49 + v59, 11) ^ __ROR4__(v60, 6) ^ __ROR4__(v60, 25));
  v63 = v51 + v62;
  v64 = (__ROR4__(v61, 13) ^ __ROR4__(v61, 2) ^ __ROR4__(v61, 22)) + ((v57 | v61) & v235 | v57 & v61) + v62;
  v261 = v58;
  v231 = (__ROR4__(v264, 18) ^ __ROR4__(v264, 7) ^ (v264 >> 3))
       + v230
       + v251
       + (__ROR4__(v58, 19) ^ __ROR4__(v58, 17) ^ (v58 >> 10));
  v65 = ((v56 ^ v60) & v63 ^ v56) + v231 + 604807628 + v54 + (__ROR4__(v63, 11) ^ __ROR4__(v63, 6) ^ __ROR4__(v63, 25));
  v66 = (__ROR4__(v64, 13) ^ __ROR4__(v64, 2) ^ __ROR4__(v64, 22)) + ((v61 | v64) & v57 | v61 & v64) + v65;
  v67 = v235 + v65;
  v236 = (__ROR4__(v239, 18) ^ __ROR4__(v239, 7) ^ (v239 >> 3))
       + v264
       + v254
       + (__ROR4__(v226, 19) ^ __ROR4__(v226, 17) ^ (v226 >> 10));
  v68 = ((v60 ^ v63) & v67 ^ v60) + v236 + 770255983 + v56 + (__ROR4__(v67, 11) ^ __ROR4__(v67, 6) ^ __ROR4__(v67, 25));
  v69 = v57 + v68;
  v70 = (__ROR4__(v66, 13) ^ __ROR4__(v66, 2) ^ __ROR4__(v66, 22)) + ((v64 | v66) & v61 | v64 & v66) + v68;
  v240 = (__ROR4__(v257, 18) ^ __ROR4__(v257, 7) ^ (v257 >> 3))
       + v239
       + v222
       + (__ROR4__(v231, 19) ^ __ROR4__(v231, 17) ^ (v231 >> 10));
  v71 = ((v63 ^ v67) & (v57 + v68) ^ v63)
      + v240
      + 1249150122
      + v60
      + (__ROR4__(v69, 11) ^ __ROR4__(v69, 6) ^ __ROR4__(v69, 25));
  v72 = v61 + v71;
  v73 = (__ROR4__(v70, 13) ^ __ROR4__(v70, 2) ^ __ROR4__(v70, 22)) + ((v66 | v70) & v64 | v66 & v70) + v71;
  v265 = (__ROR4__(v243, 18) ^ __ROR4__(v243, 7) ^ (v243 >> 3))
       + v257
       + v206
       + (__ROR4__(v236, 19) ^ __ROR4__(v236, 17) ^ (v236 >> 10));
  v74 = ((v67 ^ v69) & v72 ^ v67) + v265 + 1555081692 + v63 + (__ROR4__(v72, 11) ^ __ROR4__(v72, 6) ^ __ROR4__(v72, 25));
  v75 = v64 + v74;
  v76 = (__ROR4__(v73, 13) ^ __ROR4__(v73, 2) ^ __ROR4__(v73, 22)) + ((v70 | v73) & v66 | v70 & v73) + v74;
  v244 = (__ROR4__(v247, 18) ^ __ROR4__(v247, 7) ^ (v247 >> 3))
       + v243
       + v210
       + (__ROR4__(v240, 19) ^ __ROR4__(v240, 17) ^ (v240 >> 10));
  v77 = ((v69 ^ v72) & v75 ^ v69) + v244 + 1996064986 + v67 + (__ROR4__(v75, 11) ^ __ROR4__(v75, 6) ^ __ROR4__(v75, 25));
  v78 = v66 + v77;
  v79 = (__ROR4__(v76, 13) ^ __ROR4__(v76, 2) ^ __ROR4__(v76, 22)) + ((v73 | v76) & v70 | v73 & v76) + v77;
  v80 = (__ROR4__(v212, 18) ^ __ROR4__(v212, 7) ^ (v212 >> 3))
      + v247
      + v58
      + (__ROR4__(v265, 19) ^ __ROR4__(v265, 17) ^ (v265 >> 10));
  v81 = ((v72 ^ v75) & v78 ^ v72) + v80 - 1740746414 + v69 + (__ROR4__(v78, 11) ^ __ROR4__(v78, 6) ^ __ROR4__(v78, 25));
  v82 = v70 + v81;
  v83 = (__ROR4__(v79, 13) ^ __ROR4__(v79, 2) ^ __ROR4__(v79, 22)) + ((v76 | v79) & v73 | v76 & v79) + v81;
  v248 = (__ROR4__(v215, 18) ^ __ROR4__(v215, 7) ^ (v215 >> 3))
       + v212
       + v226
       + (__ROR4__(v244, 19) ^ __ROR4__(v244, 17) ^ (v244 >> 10));
  v269 = v80;
  v84 = ((v75 ^ v78) & v82 ^ v75) + v248 - 1473132947 + v72 + (__ROR4__(v82, 11) ^ __ROR4__(v82, 6) ^ __ROR4__(v82, 25));
  v85 = (__ROR4__(v83, 13) ^ __ROR4__(v83, 2) ^ __ROR4__(v83, 22)) + ((v79 | v83) & v76 | v79 & v83) + v84;
  v86 = v73 + v84;
  v216 = (__ROR4__(v218, 18) ^ __ROR4__(v218, 7) ^ (v218 >> 3))
       + v215
       + v231
       + (__ROR4__(v80, 19) ^ __ROR4__(v80, 17) ^ (v80 >> 10));
  v87 = ((v78 ^ v82) & v86 ^ v78) + v216 - 1341970488 + v75 + (__ROR4__(v86, 11) ^ __ROR4__(v86, 6) ^ __ROR4__(v86, 25));
  v88 = v76 + v87;
  v89 = (__ROR4__(v85, 13) ^ __ROR4__(v85, 2) ^ __ROR4__(v85, 22)) + ((v83 | v85) & v79 | v83 & v85) + v87;
  v219 = (__ROR4__(v251, 18) ^ __ROR4__(v251, 7) ^ (v251 >> 3))
       + v218
       + v236
       + (__ROR4__(v248, 19) ^ __ROR4__(v248, 17) ^ (v248 >> 10));
  v90 = ((v82 ^ v86) & v88 ^ v82) + v219 - 1084653625 + v78 + (__ROR4__(v88, 11) ^ __ROR4__(v88, 6) ^ __ROR4__(v88, 25));
  v91 = (__ROR4__(v89, 13) ^ __ROR4__(v89, 2) ^ __ROR4__(v89, 22)) + ((v85 | v89) & v83 | v85 & v89) + v90;
  v92 = v79 + v90;
  v252 = (__ROR4__(v254, 18) ^ __ROR4__(v254, 7) ^ (v254 >> 3))
       + v251
       + v240
       + (__ROR4__(v216, 19) ^ __ROR4__(v216, 17) ^ (v216 >> 10));
  v93 = ((v86 ^ v88) & v92 ^ v86) + v252 - 958395405 + v82 + (__ROR4__(v92, 11) ^ __ROR4__(v92, 6) ^ __ROR4__(v92, 25));
  v94 = v83 + v93;
  v95 = (__ROR4__(v91, 13) ^ __ROR4__(v91, 2) ^ __ROR4__(v91, 22)) + ((v89 | v91) & v85 | v89 & v91) + v93;
  v213 = (__ROR4__(v222, 18) ^ __ROR4__(v222, 7) ^ (v222 >> 3))
       + v254
       + v265
       + (__ROR4__(v219, 19) ^ __ROR4__(v219, 17) ^ (v219 >> 10));
  v96 = ((v88 ^ v92) & v94 ^ v88) + v213 - 710438585 + v86 + (__ROR4__(v94, 11) ^ __ROR4__(v94, 6) ^ __ROR4__(v94, 25));
  v97 = v85 + v96;
  v98 = (__ROR4__(v95, 13) ^ __ROR4__(v95, 2) ^ __ROR4__(v95, 22)) + ((v91 | v95) & v89 | v91 & v95) + v96;
  v223 = (__ROR4__(v206, 18) ^ __ROR4__(v206, 7) ^ (v206 >> 3))
       + v222
       + v244
       + (__ROR4__(v252, 19) ^ __ROR4__(v252, 17) ^ (v252 >> 10));
  v99 = ((v92 ^ v94) & v97 ^ v92) + v223 + 113926993 + v88 + (__ROR4__(v97, 11) ^ __ROR4__(v97, 6) ^ __ROR4__(v97, 25));
  v100 = v89 + v99;
  v101 = (__ROR4__(v98, 13) ^ __ROR4__(v98, 2) ^ __ROR4__(v98, 22)) + ((v95 | v98) & v91 | v95 & v98) + v99;
  v255 = (__ROR4__(v210, 18) ^ __ROR4__(v210, 7) ^ (v210 >> 3))
       + v206
       + v80
       + (__ROR4__(v213, 19) ^ __ROR4__(v213, 17) ^ (v213 >> 10));
  v102 = ((v94 ^ v97) & v100 ^ v94)
       + v255
       + 338241895
       + v92
       + (__ROR4__(v100, 11) ^ __ROR4__(v100, 6) ^ __ROR4__(v100, 25));
  v103 = v91 + v102;
  v104 = __ROR4__(v91 + v102, 11);
  v105 = (__ROR4__(v101, 13) ^ __ROR4__(v101, 2) ^ __ROR4__(v101, 22)) + ((v98 | v101) & v95 | v98 & v101) + v102;
  v258 = (__ROR4__(v261, 18) ^ __ROR4__(v261, 7) ^ (v261 >> 3))
       + v210
       + v248
       + (__ROR4__(v223, 19) ^ __ROR4__(v223, 17) ^ (v223 >> 10));
  v106 = ((v97 ^ v100) & v103 ^ v97) + v258 + 666307205 + v94 + (v104 ^ __ROR4__(v103, 6) ^ __ROR4__(v103, 25));
  v107 = v95 + v106;
  v108 = (__ROR4__(v105, 13) ^ __ROR4__(v105, 2) ^ __ROR4__(v105, 22)) + ((v101 | v105) & v98 | v101 & v105) + v106;
  v262 = (__ROR4__(v226, 18) ^ __ROR4__(v226, 7) ^ (v226 >> 3))
       + v261
       + v216
       + (__ROR4__(v255, 19) ^ __ROR4__(v255, 17) ^ (v255 >> 10));
  v109 = ((v100 ^ v103) & v107 ^ v100)
       + v262
       + 773529912
       + v97
       + (__ROR4__(v107, 11) ^ __ROR4__(v107, 6) ^ __ROR4__(v107, 25));
  v110 = v98 + v109;
  v111 = (__ROR4__(v108, 13) ^ __ROR4__(v108, 2) ^ __ROR4__(v108, 22)) + ((v105 | v108) & v101 | v105 & v108) + v109;
  v227 = (__ROR4__(v231, 18) ^ __ROR4__(v231, 7) ^ (v231 >> 3))
       + v226
       + v219
       + (__ROR4__(v258, 19) ^ __ROR4__(v258, 17) ^ (v258 >> 10));
  v112 = ((v103 ^ v107) & v110 ^ v103)
       + v227
       + 1294757372
       + v100
       + (__ROR4__(v110, 11) ^ __ROR4__(v110, 6) ^ __ROR4__(v110, 25));
  v113 = v101 + v112;
  v114 = (__ROR4__(v111, 13) ^ __ROR4__(v111, 2) ^ __ROR4__(v111, 22)) + ((v108 | v111) & v105 | v108 & v111) + v112;
  v232 = (__ROR4__(v236, 18) ^ __ROR4__(v236, 7) ^ (v236 >> 3))
       + v231
       + v252
       + (__ROR4__(v262, 19) ^ __ROR4__(v262, 17) ^ (v262 >> 10));
  v115 = ((v107 ^ v110) & v113 ^ v107)
       + v232
       + 1396182291
       + v103
       + (__ROR4__(v113, 11) ^ __ROR4__(v113, 6) ^ __ROR4__(v113, 25));
  v116 = v105 + v115;
  v117 = (__ROR4__(v114, 13) ^ __ROR4__(v114, 2) ^ __ROR4__(v114, 22)) + ((v111 | v114) & v108 | v111 & v114) + v115;
  v237 = (__ROR4__(v240, 18) ^ __ROR4__(v240, 7) ^ (v240 >> 3))
       + v236
       + v213
       + (__ROR4__(v227, 19) ^ __ROR4__(v227, 17) ^ (v227 >> 10));
  v118 = ((v110 ^ v113) & v116 ^ v110)
       + v237
       + 1695183700
       + v107
       + (__ROR4__(v105 + v115, 11) ^ __ROR4__(v105 + v115, 6) ^ __ROR4__(v116, 25));
  v119 = v108 + v118;
  v120 = (__ROR4__(v117, 13) ^ __ROR4__(v117, 2) ^ __ROR4__(v117, 22)) + ((v114 | v117) & v111 | v114 & v117) + v118;
  v241 = (__ROR4__(v265, 18) ^ __ROR4__(v265, 7) ^ (v265 >> 3))
       + v240
       + v223
       + (__ROR4__(v232, 19) ^ __ROR4__(v232, 17) ^ (v232 >> 10));
  v121 = ((v113 ^ (v105 + v115)) & (v108 + v118) ^ v113)
       + v241
       + 1986661051
       + v110
       + (__ROR4__(v108 + v118, 11) ^ __ROR4__(v108 + v118, 6) ^ __ROR4__(v108 + v118, 25));
  v122 = v111 + v121;
  v123 = (__ROR4__(v120, 13) ^ __ROR4__(v120, 2) ^ __ROR4__(v120, 22)) + ((v117 | v120) & v114 | v117 & v120) + v121;
  v266 = (__ROR4__(v244, 18) ^ __ROR4__(v244, 7) ^ (v244 >> 3))
       + v265
       + v255
       + (__ROR4__(v237, 19) ^ __ROR4__(v237, 17) ^ (v237 >> 10));
  v124 = ((v116 ^ (v108 + v118)) & v122 ^ v116)
       + v266
       - 2117940946
       + v113
       + (__ROR4__(v111 + v121, 11) ^ __ROR4__(v122, 6) ^ __ROR4__(v122, 25));
  v125 = v114 + v124;
  v126 = (__ROR4__(v123, 13) ^ __ROR4__(v123, 2) ^ __ROR4__(v123, 22)) + ((v120 | v123) & v117 | v120 & v123) + v124;
  v245 = (__ROR4__(v269, 18) ^ __ROR4__(v269, 7) ^ (v269 >> 3))
       + v244
       + v258
       + (__ROR4__(v241, 19) ^ __ROR4__(v241, 17) ^ (v241 >> 10));
  v127 = ((v119 ^ (v111 + v121)) & v125 ^ v119)
       + v245
       - 1838011259
       + v116
       + (__ROR4__(v114 + v124, 11) ^ __ROR4__(v114 + v124, 6) ^ __ROR4__(v125, 25));
  v128 = (__ROR4__(v126, 13) ^ __ROR4__(v126, 2) ^ __ROR4__(v126, 22)) + ((v123 | v126) & v120 | v123 & v126) + v127;
  v129 = v117 + v127;
  v270 = (__ROR4__(v248, 18) ^ __ROR4__(v248, 7) ^ (v248 >> 3))
       + v269
       + v262
       + (__ROR4__(v266, 19) ^ __ROR4__(v266, 17) ^ (v266 >> 10));
  v130 = ((v122 ^ v125) & (v117 + v127) ^ v122)
       + v270
       - 1564481375
       + v119
       + (__ROR4__(v117 + v127, 11) ^ __ROR4__(v117 + v127, 6) ^ __ROR4__(v117 + v127, 25));
  v131 = v120 + v130;
  v132 = (__ROR4__(v128, 13) ^ __ROR4__(v128, 2) ^ __ROR4__(v128, 22)) + ((v126 | v128) & v123 | v126 & v128) + v130;
  v207 = (__ROR4__(v216, 18) ^ __ROR4__(v216, 7) ^ (v216 >> 3))
       + v248
       + v227
       + (__ROR4__(v245, 19) ^ __ROR4__(v245, 17) ^ (v245 >> 10));
  v133 = ((v125 ^ v129) & v131 ^ v125)
       + v207
       - 1474664885
       + v122
       + (__ROR4__(v131, 11) ^ __ROR4__(v131, 6) ^ __ROR4__(v131, 25));
  v134 = v123 + v133;
  v135 = (__ROR4__(v132, 13) ^ __ROR4__(v132, 2) ^ __ROR4__(v132, 22)) + ((v128 | v132) & v126 | v128 & v132) + v133;
  v249 = (__ROR4__(v219, 18) ^ __ROR4__(v219, 7) ^ (v219 >> 3))
       + v216
       + v232
       + (__ROR4__(v270, 19) ^ __ROR4__(v270, 17) ^ (v270 >> 10));
  v136 = ((v129 ^ v131) & v134 ^ v129)
       + v249
       - 1035236496
       + v125
       + (__ROR4__(v134, 11) ^ __ROR4__(v134, 6) ^ __ROR4__(v134, 25));
  v137 = (__ROR4__(v135, 13) ^ __ROR4__(v135, 2) ^ __ROR4__(v135, 22)) + ((v132 | v135) & v128 | v132 & v135) + v136;
  v220 = (__ROR4__(v252, 18) ^ __ROR4__(v252, 7) ^ (v252 >> 3))
       + v219
       + v237
       + (__ROR4__(v207, 19) ^ __ROR4__(v207, 17) ^ (v207 >> 10));
  v138 = ((v131 ^ v134) & (v126 + v136) ^ v131)
       + v220
       - 949202525
       + v129
       + (__ROR4__(v126 + v136, 11) ^ __ROR4__(v126 + v136, 6) ^ __ROR4__(v126 + v136, 25));
  v139 = (__ROR4__(v137, 13) ^ __ROR4__(v137, 2) ^ __ROR4__(v137, 22)) + ((v135 | v137) & v132 | v135 & v137) + v138;
  v140 = v128 + v138;
  v211 = (__ROR4__(v213, 18) ^ __ROR4__(v213, 7) ^ (v213 >> 3))
       + v252
       + v241
       + (__ROR4__(v249, 19) ^ __ROR4__(v249, 17) ^ (v249 >> 10));
  v141 = ((v134 ^ (v126 + v136)) & v140 ^ v134)
       + v211
       - 778901479
       + v131
       + (__ROR4__(v128 + v138, 11) ^ __ROR4__(v128 + v138, 6) ^ __ROR4__(v140, 25));
  v142 = v132 + v141;
  v143 = (__ROR4__(v139, 13) ^ __ROR4__(v139, 2) ^ __ROR4__(v139, 22)) + ((v137 | v139) & v135 | v137 & v139) + v141;
  v214 = (__ROR4__(v223, 18) ^ __ROR4__(v223, 7) ^ (v223 >> 3))
       + v213
       + v266
       + (__ROR4__(v220, 19) ^ __ROR4__(v220, 17) ^ (v220 >> 10));
  v144 = (((v126 + v136) ^ v140) & v142 ^ (v126 + v136))
       + v214
       - 694614492
       + v134
       + (__ROR4__(v142, 11) ^ __ROR4__(v142, 6) ^ __ROR4__(v142, 25));
  v145 = v135 + v144;
  v146 = (__ROR4__(v143, 13) ^ __ROR4__(v143, 2) ^ __ROR4__(v143, 22)) + ((v139 | v143) & v137 | v139 & v143) + v144;
  v224 = (__ROR4__(v255, 18) ^ __ROR4__(v255, 7) ^ (v255 >> 3))
       + v223
       + v245
       + (__ROR4__(v211, 19) ^ __ROR4__(v211, 17) ^ (v211 >> 10));
  v147 = ((v140 ^ v142) & v145 ^ v140)
       + v224
       - 200395387
       + v126
       + v136
       + (__ROR4__(v145, 11) ^ __ROR4__(v145, 6) ^ __ROR4__(v145, 25));
  v148 = v137 + v147;
  v149 = (__ROR4__(v146, 13) ^ __ROR4__(v146, 2) ^ __ROR4__(v146, 22)) + ((v143 | v146) & v139 | v143 & v146) + v147;
  v217 = (__ROR4__(v258, 18) ^ __ROR4__(v258, 7) ^ (v258 >> 3))
       + v255
       + v270
       + (__ROR4__(v214, 19) ^ __ROR4__(v214, 17) ^ (v214 >> 10));
  v150 = ((v142 ^ v145) & v148 ^ v142)
       + v217
       + 275423344
       + v140
       + (__ROR4__(v148, 11) ^ __ROR4__(v148, 6) ^ __ROR4__(v148, 25));
  v151 = v139 + v150;
  v152 = (__ROR4__(v149, 13) ^ __ROR4__(v149, 2) ^ __ROR4__(v149, 22)) + ((v146 | v149) & v143 | v146 & v149) + v150;
  v253 = (__ROR4__(v262, 18) ^ __ROR4__(v262, 7) ^ (v262 >> 3))
       + v258
       + v207
       + (__ROR4__(v224, 19) ^ __ROR4__(v224, 17) ^ (v224 >> 10));
  v153 = ((v145 ^ v148) & v151 ^ v145)
       + v253
       + 430227734
       + v142
       + (__ROR4__(v151, 11) ^ __ROR4__(v151, 6) ^ __ROR4__(v151, 25));
  v154 = v143 + v153;
  v155 = (__ROR4__(v152, 13) ^ __ROR4__(v152, 2) ^ __ROR4__(v152, 22)) + ((v149 | v152) & v146 | v149 & v152) + v153;
  v256 = (__ROR4__(v227, 18) ^ __ROR4__(v227, 7) ^ (v227 >> 3))
       + v262
       + v249
       + (__ROR4__(v217, 19) ^ __ROR4__(v217, 17) ^ (v217 >> 10));
  v156 = ((v148 ^ v151) & v154 ^ v148)
       + v256
       + 506948616
       + v145
       + (__ROR4__(v154, 11) ^ __ROR4__(v154, 6) ^ __ROR4__(v154, 25));
  v157 = (__ROR4__(v155, 13) ^ __ROR4__(v155, 2) ^ __ROR4__(v155, 22)) + ((v152 | v155) & v149 | v152 & v155) + v156;
  v158 = v146 + v156;
  v259 = (__ROR4__(v232, 18) ^ __ROR4__(v232, 7) ^ (v232 >> 3))
       + v227
       + v220
       + (__ROR4__(v253, 19) ^ __ROR4__(v253, 17) ^ (v253 >> 10));
  v159 = ((v151 ^ v154) & v158 ^ v151)
       + v259
       + 659060556
       + v148
       + (__ROR4__(v158, 11) ^ __ROR4__(v158, 6) ^ __ROR4__(v158, 25));
  v160 = v149 + v159;
  v161 = (__ROR4__(v157, 13) ^ __ROR4__(v157, 2) ^ __ROR4__(v157, 22)) + ((v155 | v157) & v152 | v155 & v157) + v159;
  v263 = (__ROR4__(v237, 18) ^ __ROR4__(v237, 7) ^ (v237 >> 3))
       + v232
       + v211
       + (__ROR4__(v256, 19) ^ __ROR4__(v256, 17) ^ (v256 >> 10));
  v162 = ((v154 ^ v158) & v160 ^ v154)
       + v263
       + 883997877
       + v151
       + (__ROR4__(v160, 11) ^ __ROR4__(v160, 6) ^ __ROR4__(v160, 25));
  v163 = v152 + v162;
  v164 = (__ROR4__(v161, 13) ^ __ROR4__(v161, 2) ^ __ROR4__(v161, 22)) + ((v157 | v161) & v155 | v157 & v161) + v162;
  v272 = (__ROR4__(v241, 18) ^ __ROR4__(v241, 7) ^ (v241 >> 3))
       + v237
       + v214
       + (__ROR4__(v259, 19) ^ __ROR4__(v259, 17) ^ (v259 >> 10));
  v165 = ((v158 ^ v160) & v163 ^ v158)
       + v272
       + 958139571
       + v154
       + (__ROR4__(v163, 11) ^ __ROR4__(v163, 6) ^ __ROR4__(v163, 25));
  v166 = v155 + v165;
  v167 = (__ROR4__(v164, 13) ^ __ROR4__(v164, 2) ^ __ROR4__(v164, 22)) + ((v161 | v164) & v157 | v161 & v164) + v165;
  v273 = (__ROR4__(v266, 18) ^ __ROR4__(v266, 7) ^ (v266 >> 3))
       + v241
       + v224
       + (__ROR4__(v263, 19) ^ __ROR4__(v263, 17) ^ (v263 >> 10));
  v168 = ((v160 ^ v163) & v166 ^ v160)
       + v273
       + 1322822218
       + v158
       + (__ROR4__(v166, 11) ^ __ROR4__(v166, 6) ^ __ROR4__(v166, 25));
  v169 = v157 + v168;
  v170 = (__ROR4__(v167, 13) ^ __ROR4__(v167, 2) ^ __ROR4__(v167, 22)) + ((v164 | v167) & v161 | v164 & v167) + v168;
  v267 = (__ROR4__(v245, 18) ^ __ROR4__(v245, 7) ^ (v245 >> 3))
       + v266
       + v217
       + (__ROR4__(v272, 19) ^ __ROR4__(v272, 17) ^ (v272 >> 10));
  v171 = ((v163 ^ v166) & v169 ^ v163)
       + v267
       + 1537002063
       + v160
       + (__ROR4__(v169, 11) ^ __ROR4__(v169, 6) ^ __ROR4__(v169, 25));
  v172 = v161 + v171;
  v173 = (__ROR4__(v170, 13) ^ __ROR4__(v170, 2) ^ __ROR4__(v170, 22)) + ((v167 | v170) & v164 | v167 & v170) + v171;
  v233 = (__ROR4__(v270, 18) ^ __ROR4__(v270, 7) ^ (v270 >> 3))
       + v245
       + v253
       + (__ROR4__(v273, 19) ^ __ROR4__(v273, 17) ^ (v273 >> 10));
  v174 = ((v166 ^ v169) & v172 ^ v166)
       + v233
       + 1747873779
       + v163
       + (__ROR4__(v172, 11) ^ __ROR4__(v172, 6) ^ __ROR4__(v172, 25));
  v175 = v164 + v174;
  v228 = (__ROR4__(v173, 13) ^ __ROR4__(v173, 2) ^ __ROR4__(v173, 22)) + ((v170 | v173) & v167 | v170 & v173) + v174;
  v238 = (__ROR4__(v207, 18) ^ __ROR4__(v207, 7) ^ (v207 >> 3))
       + v270
       + v256
       + (__ROR4__(v267, 19) ^ __ROR4__(v267, 17) ^ (v267 >> 10));
  v176 = ((v169 ^ v172) & v175 ^ v169)
       + v238
       + 1955562222
       + v166
       + (__ROR4__(v175, 11) ^ __ROR4__(v175, 6) ^ __ROR4__(v175, 25));
  v177 = (__ROR4__(v249, 18) ^ __ROR4__(v249, 7) ^ (v249 >> 3)) + v207;
  v208 = (__ROR4__(v228, 13) ^ __ROR4__(v228, 2) ^ __ROR4__(v228, 22)) + ((v173 | v228) & v170 | v173 & v228) + v176;
  v178 = v177 + v259 + (__ROR4__(v233, 19) ^ __ROR4__(v233, 17) ^ (v233 >> 10));
  v242 = v167 + v176;
  v179 = ((v172 ^ v175) & v242 ^ v172)
       + v178
       + 2024104815
       + v169
       + (__ROR4__(v242, 11) ^ __ROR4__(v242, 6) ^ __ROR4__(v242, 25));
  v180 = v170 + v179;
  v181 = (__ROR4__(v208, 13) ^ __ROR4__(v208, 2) ^ __ROR4__(v208, 22)) + ((v228 | v208) & v173 | v228 & v208) + v179;
  v182 = (__ROR4__(v220, 18) ^ __ROR4__(v220, 7) ^ (v220 >> 3))
       + v249
       + v263
       + (__ROR4__(v238, 19) ^ __ROR4__(v238, 17) ^ (v238 >> 10));
  v183 = ((v175 ^ v242) & (v170 + v179) ^ v175)
       + v182
       - 2067236844
       + v172
       + (__ROR4__(v170 + v179, 11) ^ __ROR4__(v170 + v179, 6) ^ __ROR4__(v170 + v179, 25));
  v184 = v173 + v183;
  v185 = (__ROR4__(v181, 13) ^ __ROR4__(v181, 2) ^ __ROR4__(v181, 22)) + ((v208 | v181) & v228 | v208 & v181) + v183;
  v186 = (__ROR4__(v211, 18) ^ __ROR4__(v211, 7) ^ (v211 >> 3))
       + v220
       + v272
       + (__ROR4__(v178, 19) ^ __ROR4__(v178, 17) ^ (v178 >> 10));
  v187 = ((v242 ^ (v170 + v179)) & v184 ^ v242)
       + v186
       - 1933114872
       + v175
       + (__ROR4__(v184, 11) ^ __ROR4__(v184, 6) ^ __ROR4__(v184, 25));
  v246 = __ROR4__(v186, 19) ^ __ROR4__(v186, 17) ^ (v186 >> 10);
  v188 = v228;
  v189 = (__ROR4__(v185, 13) ^ __ROR4__(v185, 2) ^ __ROR4__(v185, 22)) + ((v181 | v185) & v208 | v181 & v185) + v187;
  v229 = v180;
  v190 = v188 + v187;
  v191 = (__ROR4__(v214, 18) ^ __ROR4__(v214, 7) ^ (v214 >> 3))
       + v211
       + v273
       + (__ROR4__(v182, 19) ^ __ROR4__(v182, 17) ^ (v182 >> 10));
  v192 = ((v180 ^ v184) & v190 ^ v180)
       + v191
       - 1866530822
       + v242
       + (__ROR4__(v190, 11) ^ __ROR4__(v190, 6) ^ __ROR4__(v190, 25));
  v193 = (__ROR4__(v189, 13) ^ __ROR4__(v189, 2) ^ __ROR4__(v189, 22)) + ((v185 | v189) & v181 | v185 & v189) + v192;
  v194 = v208 + v192;
  v195 = (__ROR4__(v224, 18) ^ __ROR4__(v224, 7) ^ (v224 >> 3)) + v214 + v267 + v246;
  v196 = ((v184 ^ v190) & v194 ^ v184)
       + v195
       - 1538233109
       + v229
       + (__ROR4__(v194, 11) ^ __ROR4__(v194, 6) ^ __ROR4__(v194, 25));
  v197 = v181 + v196;
  v198 = (__ROR4__(v193, 13) ^ __ROR4__(v193, 2) ^ __ROR4__(v193, 22)) + ((v189 | v193) & v185 | v189 & v193) + v196;
  v199 = (__ROR4__(v217, 18) ^ __ROR4__(v217, 7) ^ (v217 >> 3))
       + v224
       - 1090935817
       + v233
       + (__ROR4__(v191, 19) ^ __ROR4__(v191, 17) ^ (v191 >> 10))
       + v184
       + ((v190 ^ (v208 + v192)) & v197 ^ v190)
       + (__ROR4__(v197, 11) ^ __ROR4__(v197, 6) ^ __ROR4__(v197, 25));
  v200 = (__ROR4__(v198, 13) ^ __ROR4__(v198, 2) ^ __ROR4__(v198, 22)) + ((v193 | v198) & v189 | v193 & v198) + v199;
  v201 = v185 + v199;
  v202 = (__ROR4__(v253, 18) ^ __ROR4__(v253, 7) ^ (v253 >> 3))
       + v217
       - 965641998
       + v238
       + (__ROR4__(v195, 19) ^ __ROR4__(v195, 17) ^ (v195 >> 10))
       + v190
       + ((v194 ^ v197) & v201 ^ v194)
       + (__ROR4__(v201, 11) ^ __ROR4__(v201, 6) ^ __ROR4__(v201, 25));
  v203 = (__ROR4__(v200, 13) ^ __ROR4__(v200, 2) ^ __ROR4__(v200, 22))
       + ((v198 | v200) & v193 | v198 & v200)
       + v274
       + v202;
  result = v276 + v198;
  a1[9] = v280 + v194;
  a1[5] = v277 + v193;
  a1[8] = v279 + v197;
  a1[4] = result;
  a1[3] = v275 + v200;
  a1[7] = v278 + v201;
  a1[2] = v203;
  a1[6] = v271 + v189 + v202;
  return result;
}

//----- (000231A4) --------------------------------------------------------
int *__fastcall sub_231A4(int *result, unsigned int *a2, signed int a3)
{
  signed int v3; // r5
  int v4; // r3
  int *v5; // r6
  unsigned int *v6; // r4
  bool v7; // cf
  int v8; // r2
  int v9; // r8
  signed int v10; // r7
  _BOOL4 v11; // r3
  unsigned int v12; // r5
  unsigned int *v13; // r7
  unsigned int *v14; // r1
  unsigned int *v15; // r9

  v3 = a3;
  v4 = *result;
  v5 = result;
  v6 = a2;
  v7 = __CFADD__(*result, a3);
  v8 = *result + a3;
  v9 = *result & 0x3F;
  if ( v7 )
    v4 = result[1];
  v10 = 64 - v9;
  *result = v8;
  if ( v7 )
    result[1] = v4 + 1;
  v11 = v10 <= v3;
  if ( !v9 )
    v11 = 0;
  if ( v11 )
  {
    v15 = (unsigned int *)(result + 10);
    v3 -= v10;
    memcpy((char *)result + v9 + 40, a2, 64 - v9);
    v6 = (unsigned int *)((char *)v6 + v10);
    v9 = 0;
    result = (int *)sub_20D44(v5, v15);
  }
  if ( v3 > 63 )
  {
    v12 = v3 - 64;
    v13 = &v6[16 * (v12 >> 6) + 16];
    do
    {
      v14 = v6;
      v6 += 16;
      result = (int *)sub_20D44(v5, v14);
    }
    while ( v6 != v13 );
    v3 = v12 - (v12 >> 6 << 6);
  }
  if ( v3 > 0 )
    return (int *)memcpy((char *)v5 + v9 + 40, v6, v3);
  return result;
}

//----- (00023270) --------------------------------------------------------
int *__fastcall sub_23270(int *result, unsigned int *a2, signed int a3)
{
  if ( a3 > 0 )
    return sub_231A4(result, a2, a3);
  return result;
}

//----- (0002327C) --------------------------------------------------------
int *__fastcall sub_2327C(int a1, _BYTE *a2)
{
  unsigned int v4; // r2
  int v5; // r1
  unsigned int v6; // r3
  unsigned int v7; // r0
  unsigned int v8; // r3
  signed int v9; // r2
  int *result; // r0
  unsigned int v11; // [sp+0h] [bp-18h] BYREF
  char v12; // [sp+4h] [bp-14h]
  char v13; // [sp+5h] [bp-13h]
  char v14; // [sp+6h] [bp-12h]
  char v15; // [sp+7h] [bp-11h]

  v4 = *(_DWORD *)a1 & 0x3F;
  v5 = *(_QWORD *)a1 >> 29;
  v6 = 8 * *(_DWORD *)a1;
  v15 = 8 * *(_BYTE *)a1;
  v12 = HIBYTE(v6);
  HIBYTE(v11) = v5;
  BYTE1(v11) = BYTE2(v5);
  v7 = HIWORD(v6);
  v8 = v6 >> 8;
  BYTE2(v11) = BYTE1(v5);
  v13 = v7;
  if ( v4 > 0x37 )
    v9 = 120 - v4;
  else
    v9 = 56 - v4;
  v14 = v8;
  LOBYTE(v11) = HIBYTE(v5);
  sub_231A4((int *)a1, dword_62768, v9);
  result = sub_231A4((int *)a1, &v11, 8);
  *a2 = *(_BYTE *)(a1 + 11);
  a2[1] = *(_WORD *)(a1 + 10);
  a2[2] = BYTE1(*(_DWORD *)(a1 + 8));
  a2[3] = *(_DWORD *)(a1 + 8);
  a2[4] = *(_BYTE *)(a1 + 15);
  a2[5] = *(_WORD *)(a1 + 14);
  a2[6] = BYTE1(*(_DWORD *)(a1 + 12));
  a2[7] = *(_DWORD *)(a1 + 12);
  a2[8] = *(_BYTE *)(a1 + 19);
  a2[9] = *(_WORD *)(a1 + 18);
  a2[10] = BYTE1(*(_DWORD *)(a1 + 16));
  a2[11] = *(_DWORD *)(a1 + 16);
  a2[12] = *(_BYTE *)(a1 + 23);
  a2[13] = *(_WORD *)(a1 + 22);
  a2[14] = BYTE1(*(_DWORD *)(a1 + 20));
  a2[15] = *(_DWORD *)(a1 + 20);
  a2[16] = *(_BYTE *)(a1 + 27);
  a2[17] = *(_WORD *)(a1 + 26);
  a2[18] = BYTE1(*(_DWORD *)(a1 + 24));
  a2[19] = *(_DWORD *)(a1 + 24);
  a2[20] = *(_BYTE *)(a1 + 31);
  a2[21] = *(_WORD *)(a1 + 30);
  a2[22] = BYTE1(*(_DWORD *)(a1 + 28));
  a2[23] = *(_DWORD *)(a1 + 28);
  a2[24] = *(_BYTE *)(a1 + 35);
  a2[25] = *(_WORD *)(a1 + 34);
  a2[26] = BYTE1(*(_DWORD *)(a1 + 32));
  a2[27] = *(_DWORD *)(a1 + 32);
  a2[28] = *(_BYTE *)(a1 + 39);
  a2[29] = *(_WORD *)(a1 + 38);
  a2[30] = BYTE1(*(_DWORD *)(a1 + 36));
  a2[31] = *(_DWORD *)(a1 + 36);
  return result;
}
// 62768: using guessed type unsigned int dword_62768[16];

//----- (00023430) --------------------------------------------------------
int *__fastcall sub_23430(unsigned int *a1, signed int a2, _BYTE *a3)
{
  int v5[62]; // [sp+0h] [bp-F8h] BYREF

  v5[2] = 1779033703;
  v5[4] = 1013904242;
  v5[5] = -1521486534;
  v5[6] = 1359893119;
  v5[7] = -1694144372;
  v5[3] = -1150833019;
  v5[8] = 528734635;
  v5[9] = 1541459225;
  v5[0] = 0;
  v5[1] = 0;
  if ( a2 > 0 )
    sub_231A4(v5, a1, a2);
  return sub_2327C((int)v5, a3);
}

//----- (000234D8) --------------------------------------------------------
int __fastcall sub_234D8(char *a1, size_t a2, int a3)
{
  int v6; // r0
  int *v8; // r0

  v6 = sub_36548();
  if ( v6 )
  {
    if ( v6 == 1 )
    {
      v8 = sub_359EC();
      snprintf(a1, a2, "%s:%s", "searchfailed", (const char *)v8);
    }
    else
    {
      snprintf(a1, a2, "searching");
    }
    return 0;
  }
  else
  {
    snprintf(a1, a2, "%d", a3);
    return 0;
  }
}

//----- (00023574) --------------------------------------------------------
int __fastcall sub_23574(const char *a1, char *a2, size_t a3)
{
  double v3; // d0
  char *v5; // r9
  int v8; // r4
  int v9; // r0
  int v11; // r0
  int v12; // r0
  int v13; // r8
  int i; // r4
  int v15; // r9
  int v16; // r11
  unsigned int v17; // r8
  int v18; // r5
  char *v19; // r0
  int v20; // r10
  char *v21; // r0
  int v22; // r9
  char *v23; // r0
  int v24; // r0
  int v25; // r7
  int v26; // r0
  int v27; // r0
  char *v28; // r0
  int v29; // r9
  char *v30; // r0
  int v31; // r10
  char *v32; // r0
  int v33; // r0
  int v34; // r11
  int v35; // r8
  char *v36; // r0
  int v37; // r7
  char *v38; // r0
  int v39; // r0
  int v40; // r9
  size_t v41; // r1
  char *v42; // r0
  int v43; // r10
  unsigned int v44; // r4
  unsigned int v45; // r6
  int v46; // r0
  int v47; // r7
  int v48; // r0
  int v49; // r1
  int v50; // r1
  unsigned int v51; // r0
  int v52; // r7
  size_t v53; // r1
  char *v54; // r0
  int j; // r7
  char *k; // r9
  int v57; // r0
  int v58; // [sp+0h] [bp-CB0h]
  char *v59; // [sp+0h] [bp-CB0h]
  int v60; // [sp+4h] [bp-CACh]
  char *v61; // [sp+3Ch] [bp-C74h]
  char *v62; // [sp+3Ch] [bp-C74h]
  char *v63; // [sp+40h] [bp-C70h]
  size_t v64; // [sp+44h] [bp-C6Ch]
  __int16 v65; // [sp+5Ch] [bp-C54h] BYREF
  _DWORD delim[256]; // [sp+60h] [bp-C50h] BYREF
  int s[512]; // [sp+460h] [bp-850h] BYREF

  v5 = (char *)(a1 + 4);
  v8 = strncmp(a1 + 4, "/rate", 5u);
  if ( !v8 )
  {
    if ( byte_482A5D && (byte_590404 || byte_482A5C || dword_7EBA0 > 6) )
    {
      strcpy((char *)s, "cmd : get rate");
      sub_2E584(7, (const char *)s, 0);
    }
    v9 = sub_1A18C();
    sub_234D8(a2, a3, v9);
    return v8;
  }
  v8 = strncmp(v5, "/ideal_rate", 0xBu);
  if ( !v8 )
  {
    if ( byte_482A5D && (byte_590404 || byte_482A5C || dword_7EBA0 > 6) )
    {
      strcpy((char *)s, "cmd : get ideal rate");
      sub_2E584(7, (const char *)s, 0);
    }
    v11 = sub_1A014();
    sub_234D8(a2, a3, v11);
    return v8;
  }
  v8 = strncmp(v5, "/max_rate", 9u);
  if ( !v8 )
  {
    if ( byte_482A5D && (byte_590404 || byte_482A5C || dword_7EBA0 > 6) )
    {
      strcpy((char *)s, "cmd : get max rate");
      sub_2E584(7, (const char *)s, 0);
    }
    v12 = sub_19E68();
    sub_234D8(a2, a3, v12);
    return v8;
  }
  v8 = strncmp(v5, "/miner_status", 0xDu);
  if ( !v8 )
  {
    if ( byte_482A5D && (byte_590404 || byte_482A5C || dword_7EBA0 > 6) )
    {
      strcpy((char *)s, "cmd : get miner status");
      sub_2E584(7, (const char *)s, 0);
      return v8;
    }
    return 0;
  }
  v8 = strncmp(v5, "/productName", 0xCu);
  if ( v8 )
  {
    v8 = strncmp(v5, "/get_sn", 7u);
    if ( !v8 )
    {
      if ( byte_482A5D && (byte_590404 || byte_482A5C || dword_7EBA0 > 6) )
      {
        strcpy((char *)s, "cmd : get miner sn");
        sub_2E584(7, (const char *)s, 0);
      }
      if ( byte_7F8F8 )
        snprintf(a2, 0x100u, "%s", &byte_7F8F8);
      else
        strcpy(a2, "no miner sn stored on board");
      return v8;
    }
    v8 = strncmp(v5, "/set_sn", 7u);
    if ( !v8 )
    {
      if ( byte_590404 || byte_482A5C || dword_7EBA0 > 4 )
      {
        strcpy((char *)s, "cmd : set miner sn, doesn't spport");
        sub_2E584(5, (const char *)s, 0);
      }
      snprintf(a2, 0x14u, "doesn't support sn set in Release mode");
      return v8;
    }
    v8 = strncmp(v5, "/readreg", 8u);
    if ( v8 )
    {
      v8 = strncmp(v5, "/readcorereg", 0xCu);
      if ( v8 )
      {
        v8 = strncmp(v5, "/resetcore", 0xAu);
        if ( v8 )
        {
          if ( !strncmp(v5, "/nonce", 6u) )
          {
            v15 = 0;
            v16 = 0;
            memset(s, 0, 0x100u);
            v17 = 0;
            v63 = a2;
            v18 = 0;
            v64 = a3;
            do
            {
              if ( sub_1E29C(v17) )
              {
                v41 = v64 - v18;
                v42 = &v63[v18];
                v18 += 36;
                snprintf(v42, v41, "\n asic nonce number for chain[%d]...\n", v17);
                v43 = sub_1E0F0();
                if ( v43 )
                {
                  v44 = 0;
                  do
                  {
                    v16 += sub_2CDFC(v17, v44);
                    v45 = v44 + 1;
                    v46 = sub_2CDFC(v17, v44);
                    v47 = snprintf((char *)s + v15, 256 - v15, "asic[%03d]=%-8d ", v44, v46);
                    v48 = sub_1E100();
                    sub_5FADC(v44 + 1, v48);
                    v15 += v47;
                    if ( !v49 )
                    {
                      v50 = sub_1E100();
                      v51 = sub_5F880(v44, v50);
                      v60 = v16;
                      v16 = 0;
                      v15 = 0;
                      v18 += snprintf(&v63[v18], v64 - v18, "domain %02d %s total=%-8u\n", v51, s, v60);
                    }
                    ++v44;
                  }
                  while ( v45 != v43 );
                }
              }
              ++v17;
            }
            while ( v17 != 4 );
            return 0;
          }
          if ( !strncmp(v5, "/adc", 4u) )
          {
            v13 = 0;
            for ( i = 0; i != 4; ++i )
            {
              if ( sub_1E29C(i) )
              {
                v53 = a3 - v13;
                v54 = &a2[v13];
                v13 += 23;
                snprintf(v54, v53, "\t\t\td0\td1\td2\td3\tsum\tavg\n");
                v61 = (char *)sub_1E0F0();
                if ( v61 )
                {
                  for ( j = 0; (char *)j != v61; ++j )
                  {
                    sub_3F92C();
                    sub_3F92C();
                    sub_3F92C();
                    sub_3F92C();
                    sub_3F970(i, j);
                    sub_3F9EC(i, j);
                    v58 = j;
                    v13 += snprintf(
                             &a2[v13],
                             a3 - v13,
                             "chain %2d asic %03d adc:\t%.2f\t%.2f\t%.2f\t%.2f\t%.2f\t%.2f\n",
                             i,
                             v58,
                             v3,
                             v3,
                             v3,
                             v3,
                             v3,
                             v3);
                  }
                }
              }
            }
            return 0;
          }
          v8 = strncmp(v5, "/flush", 6u);
          if ( !v8 )
          {
            sub_452F8();
            return v8;
          }
          v8 = strncmp(v5, "/power", 6u);
          if ( v8 )
            return -1;
          s[0] = 0;
          if ( _isoc99_sscanf(v5, "/power-%d", s) == 1 )
          {
            v52 = s[0];
            if ( s[0] <= 3 )
            {
              sub_192C8(s[0]);
              snprintf(a2, a3, "chain %d power is %.2f", v52, v3);
              return v8;
            }
          }
LABEL_74:
          snprintf(a2, a3, "404 not found");
          return v8;
        }
        strcpy((char *)delim, "-");
        if ( !strtok(v5, (const char *)delim) )
          goto LABEL_74;
        v36 = strtok(0, (const char *)delim);
        if ( !v36 )
          goto LABEL_74;
        v37 = strtol(v36, 0, 10);
        v38 = strtok(0, (const char *)delim);
        if ( !v38 )
          goto LABEL_74;
        v39 = strtol(v38, 0, 10);
        v40 = v39;
        if ( byte_590404 || byte_482A5C || dword_7EBA0 > 4 )
        {
          snprintf((char *)s, 0x800u, "recvBuf = %s, chain = %d, asic = %d\n", a1, v37, v39);
          sub_2E584(5, (const char *)s, 0);
        }
        snprintf(a2, a3, "reset chain %d asic %d core success!!!.", v37, v40);
      }
      else
      {
        v65 = 45;
        memset(delim, 0, sizeof(delim));
        if ( !strtok(v5, (const char *)&v65) )
          goto LABEL_74;
        v28 = strtok(0, (const char *)&v65);
        if ( !v28 )
          goto LABEL_74;
        v29 = strtol(v28, 0, 10);
        v30 = strtok(0, (const char *)&v65);
        if ( !v30 )
          goto LABEL_74;
        v31 = strtol(v30, 0, 10);
        v32 = strtok(0, (const char *)&v65);
        if ( !v32 )
          goto LABEL_74;
        v33 = strtol(v32, 0, 16);
        v34 = v33;
        if ( byte_590404 || byte_482A5C || dword_7EBA0 > 4 )
        {
          snprintf((char *)s, 0x800u, "recvBuf = %s, chain = %d, asic = %d, reg = 0x%x\n", a1, v29, v31, v33);
          sub_2E584(5, (const char *)s, 0);
        }
        v35 = sub_2C2E8(v34, v31, v29, (int)delim);
        if ( v35 )
        {
          snprintf(a2, a3, "500 server error");
        }
        else
        {
          v62 = (char *)sub_1E120();
          if ( (int)v62 > 0 )
          {
            for ( k = 0; k != v62; ++k )
            {
              v57 = delim[(_DWORD)k];
              v59 = k;
              v35 += snprintf(
                       &a2[v35],
                       a3 - v35,
                       "asic\t%03d\tcore\t%03d\treg\t0x%02x\tval\t0x%08x\n",
                       v31,
                       v59,
                       v34,
                       v57);
            }
          }
        }
      }
    }
    else
    {
      strcpy((char *)delim, "-");
      if ( !strtok(v5, (const char *)delim) )
        goto LABEL_74;
      v19 = strtok(0, (const char *)delim);
      if ( !v19 )
        goto LABEL_74;
      v20 = strtol(v19, 0, 10);
      v21 = strtok(0, (const char *)delim);
      if ( !v21 )
        goto LABEL_74;
      v22 = strtol(v21, 0, 10);
      v23 = strtok(0, (const char *)delim);
      if ( !v23 )
        goto LABEL_74;
      v24 = strtol(v23, 0, 16);
      v25 = v24;
      if ( byte_590404 || byte_482A5C || dword_7EBA0 > 4 )
      {
        snprintf((char *)s, 0x800u, "recvBuf = %s, chain = %d, asic = %d, reg = 0x%x\n", a1, v20, v22, v24);
        sub_2E584(5, (const char *)s, 0);
      }
      v26 = sub_1E160();
      v27 = sub_2C06C(v25, v22 * v26, v20);
      snprintf(a2, a3, "reg 0x%08x of asic %2d @ chain %2d, val = 0x%08x", v25, v22, v20, v27);
    }
  }
  else
  {
    if ( byte_482A5D && (byte_590404 || byte_482A5C || dword_7EBA0 > 6) )
    {
      strcpy((char *)s, "cmd : get miner type");
      sub_2E584(7, (const char *)s, 0);
    }
    snprintf(a2, 0x100u, "%s", dest);
  }
  return v8;
}
// 24020: variable 'v49' is possibly undefined
// 2410C: variable 'v3' is possibly undefined
// 1231C: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);
// 7EBA0: using guessed type int dword_7EBA0;
// 7F8F8: using guessed type char byte_7F8F8;
// 482A5C: using guessed type char byte_482A5C;
// 482A5D: using guessed type char byte_482A5D;
// 590404: using guessed type char byte_590404;

//----- (00024264) --------------------------------------------------------
int __fastcall sub_24264(char *a1)
{
  int v1; // r7
  int v2; // r5
  int v3; // r4
  char *v5; // r8
  int v6; // r0
  char *v7; // r0
  int v9; // r5
  int v10; // r5
  int v11; // r5
  int v12; // [sp+4h] [bp-2Ch]

  v1 = 0;
  v2 = 0;
  v3 = 0;
  v5 = a1;
  v12 = sub_19AB4();
  do
  {
    v6 = v3++;
    if ( sub_1E29C(v6) )
    {
      v9 = sprintf(v5, "chain%d_voltage=%d;", v3, v12) + v2;
      ++v1;
      v10 = v9 + sprintf(&a1[v9], "chain%d_voladded=%d;", v3, 0);
      v11 = v10 + sprintf(&a1[v10], "chain%d_basefreq=%d;", v3, 300);
      v2 = v11 + sprintf(&a1[v11], "chain%d_badcore=%d;", v3, 0);
      v5 = &a1[v2];
    }
  }
  while ( v3 != 4 );
  v7 = &a1[v2 + sprintf(v5, "chainnum=%d;", v1)];
  return sprintf(v7, "version=%s;", byte_80BA0);
}

//----- (00024364) --------------------------------------------------------
void *sub_24364()
{
  void *result; // r0

  result = memcpy(&byte_7F8F8, &byte_80DA0, 0x100u);
  dword_7F9FC = (int)sub_23574;
  return result;
}
// 7F8F8: using guessed type char byte_7F8F8;
// 7F9FC: using guessed type int dword_7F9FC;

//----- (00024398) --------------------------------------------------------
int __fastcall sub_24398(int a1)
{
  int v1; // r6
  char *v3; // r7
  char *v4; // r8
  ssize_t v5; // r3
  const char *v7; // lr
  int v8; // r0
  int v9; // r1
  int v10; // r2
  int v11; // r3
  _DWORD *v12; // lr
  int v13; // r1
  int v14; // r2
  int v15; // r3
  int v16; // r8
  int v17; // r10
  int v18; // r10
  int v19; // r10
  int v20; // r10
  int v21; // r10
  int v22; // r0
  size_t v23; // r0
  unsigned int v24; // r10
  ssize_t v25; // r0
  ssize_t v26; // r10
  signed int v27; // [sp+Ch] [bp-585Ch]
  char v28[4]; // [sp+18h] [bp-5850h] BYREF
  socklen_t addr_len; // [sp+1Ch] [bp-584Ch] BYREF
  char needle[8]; // [sp+20h] [bp-5848h] BYREF
  int optval[2]; // [sp+28h] [bp-5840h] BYREF
  struct sockaddr addr; // [sp+30h] [bp-5838h] BYREF
  char v33[2048]; // [sp+40h] [bp-5828h] BYREF
  char s[10240]; // [sp+840h] [bp-5028h] BYREF
  _DWORD v35[2570]; // [sp+3040h] [bp-2828h] BYREF

  v1 = 0;
  optval[0] = 3;
  optval[1] = 0;
  v3 = (char *)calloc(1u, 0x6000u);
  strcpy(v28, "\r\n");
  v4 = s;
  addr_len = 0;
  strcpy(needle, "\r\n\r\n");
  memset(s, 0, sizeof(s));
  do
  {
    if ( byte_7F9F8 )
      goto LABEL_6;
    v5 = recvfrom(a1, v4, 10239 - v1, (unsigned __int8)byte_7F9F8, &addr, &addr_len);
    v1 += v5;
    if ( v5 <= 0 )
    {
      close(a1);
      if ( byte_482A5D && (byte_590404 || byte_482A5C || dword_7EBA0 > 6) )
      {
        strcpy((char *)v35, ":statusServiceThread recvfrom<=0");
        sub_2E584(7, (const char *)v35, 0);
      }
      goto LABEL_18;
    }
    v4 = &s[v1];
    if ( v1 > 10238 )
    {
      close(a1);
      if ( byte_482A5D && (byte_590404 || byte_482A5C || dword_7EBA0 > 6) )
      {
        strcpy((char *)v35, "BUFSIZE is too small!");
        sub_2E584(7, (const char *)v35, 0);
      }
      goto LABEL_18;
    }
  }
  while ( !strstr(s, needle) );
  if ( byte_482A5D )
  {
    if ( byte_590404 || byte_482A5C || dword_7EBA0 > 6 )
    {
      strcpy((char *)v35, "find http request end flag!");
      sub_2E584(7, (const char *)v35, 0);
LABEL_6:
      if ( byte_482A5D )
      {
        if ( !byte_590404 )
          goto LABEL_8;
LABEL_10:
        snprintf((char *)v35, 0x800u, "get http=%s", s);
        sub_2E584(7, (const char *)v35, 0);
      }
    }
    else
    {
LABEL_8:
      if ( byte_482A5C || dword_7EBA0 > 6 )
        goto LABEL_10;
    }
  }
  if ( s[0] != 71 || s[1] != 69 || s[2] != 84 || s[3] != 32 )
  {
    close(a1);
    if ( byte_482A5D && (byte_590404 || byte_482A5C || dword_7EBA0 > 6) )
    {
      strcpy((char *)v35, "statusServiceThread not support http command");
      sub_2E584(7, (const char *)v35, 0);
    }
    goto LABEL_18;
  }
  if ( setsockopt(a1, 1, 21, optval, 8u) )
  {
    close(a1);
    if ( byte_482A5D && (byte_590404 || byte_482A5C || dword_7EBA0 > 6) )
    {
      v7 = "setsockopt SO_SNDTIMEO failed";
      goto LABEL_41;
    }
    goto LABEL_18;
  }
  v16 = setsockopt(a1, 1, 20, optval, 8u);
  if ( v16 )
  {
    close(a1);
    if ( byte_482A5D && (byte_590404 || byte_482A5C || dword_7EBA0 > 6) )
    {
      v7 = "setsockopt SO_RCVTIMEO failed";
LABEL_41:
      v8 = *(_DWORD *)v7;
      v9 = *((_DWORD *)v7 + 1);
      v10 = *((_DWORD *)v7 + 2);
      v11 = *((_DWORD *)v7 + 3);
      v12 = v7 + 16;
      v35[0] = v8;
      v35[1] = v9;
      v35[2] = v10;
      v35[3] = v11;
      v13 = v12[1];
      v14 = v12[2];
      v15 = v12[3];
      v35[4] = *v12;
      v35[5] = v13;
      v35[6] = v14;
      LOWORD(v35[7]) = v15;
      sub_2E584(7, (const char *)v35, 0);
    }
LABEL_18:
    if ( v3 )
      goto LABEL_19;
    return 0;
  }
  if ( dword_7F9FC )
  {
    if ( ((int (__fastcall *)(char *, char *, int))dword_7F9FC)(s, v3, 24576) )
    {
      close(a1);
      if ( byte_482A5D && (byte_590404 || byte_482A5C || dword_7EBA0 > 6) )
      {
        strcpy((char *)v35, "statusServiceThread exit for Error cmd!");
        sub_2E584(7, (const char *)v35, 0);
      }
      goto LABEL_18;
    }
  }
  else if ( byte_482A5D && (byte_590404 || byte_482A5C || dword_7EBA0 > 6) )
  {
    strcpy((char *)v35, "No 6060 test case found.");
    sub_2E584(7, (const char *)v35, 0);
  }
  v27 = strlen(v3);
  v17 = sprintf((char *)v35, "HTTP/1.0  200  OK%s", v28);
  v18 = v17 + sprintf((char *)v35 + v17, "Server: SearchFreqServer%s", v28);
  v19 = v18 + sprintf((char *)v35 + v18, "Cache-Control: no-cache%s", v28);
  v20 = v19 + sprintf((char *)v35 + v19, "Pragma: no-cache%s", v28);
  v21 = v20 + sprintf((char *)v35 + v20, "Content-Type: text/plain%s", v28);
  v22 = sprintf((char *)v35 + v21, "Content-Length: %d%s", v27, v28);
  sprintf((char *)v35 + v21 + v22, "Connection: Keep-Alive%s", needle);
  if ( !byte_482A5D )
  {
    if ( byte_7F9F8 )
      goto LABEL_73;
    goto LABEL_56;
  }
  if ( byte_590404 || byte_482A5C || dword_7EBA0 > 6 )
  {
    strcpy(v33, "send http response...\n");
    sub_2E584(7, v33, 0);
    if ( !byte_7F9F8 )
      goto LABEL_56;
LABEL_69:
    if ( !byte_482A5D )
      goto LABEL_73;
LABEL_113:
    if ( byte_590404 || byte_482A5C || dword_7EBA0 > 6 )
    {
      strcpy(v33, "send http data...");
      sub_2E584(7, v33, 0);
    }
    while ( 1 )
    {
LABEL_73:
      v26 = send(a1, &v3[v16], v27 - v16, 0);
      if ( byte_482A5D && (byte_590404 || byte_482A5C || dword_7EBA0 > 6) )
      {
        snprintf(v33, 0x800u, "send http data ret=%d", v26);
        sub_2E584(7, v33, 0);
      }
      if ( v26 <= 0 )
        break;
      v16 += v26;
      if ( v27 <= v16 || byte_7F9F8 )
        goto LABEL_84;
    }
    if ( !byte_482A5D )
      goto LABEL_89;
    if ( byte_590404 || byte_482A5C || dword_7EBA0 > 6 )
    {
      strcpy(v33, "statusServiceThread send http data error");
      sub_2E584(7, v33, 0);
LABEL_84:
      if ( !byte_482A5D )
        goto LABEL_89;
      if ( byte_590404 )
        goto LABEL_88;
    }
    if ( byte_482A5C || dword_7EBA0 > 6 )
    {
LABEL_88:
      strcpy(v33, "one client disconnected!");
      sub_2E584(7, v33, 0);
    }
LABEL_89:
    close(a1);
    free(v3);
    return v16;
  }
  if ( byte_7F9F8 )
    goto LABEL_113;
LABEL_56:
  v23 = strlen((const char *)v35);
  v24 = 0;
  while ( 1 )
  {
    v25 = send(a1, (char *)v35 + v24, v23 - v24, 0);
    if ( v25 == -1 )
      break;
    if ( v25 <= 0 )
      goto LABEL_63;
    v24 += v25;
LABEL_59:
    v23 = strlen((const char *)v35);
    if ( v23 <= v24 || byte_7F9F8 )
      goto LABEL_69;
  }
  if ( *_errno_location() == 11 )
  {
    if ( byte_482A5D && (byte_590404 || byte_482A5C || dword_7EBA0 > 6) )
    {
      strcpy(v33, "statusServiceThread send http timeout, try again...");
      sub_2E584(7, v33, 0);
    }
    usleep((__useconds_t)&loc_186A0);
    goto LABEL_59;
  }
LABEL_63:
  close(a1);
  if ( byte_482A5D && (byte_590404 || byte_482A5C || dword_7EBA0 > 6) )
  {
    strcpy(v33, "statusServiceThread send http response error");
    sub_2E584(7, v33, 0);
  }
LABEL_19:
  free(v3);
  return 0;
}
// 7EBA0: using guessed type int dword_7EBA0;
// 7F9F8: using guessed type char byte_7F9F8;
// 7F9FC: using guessed type int dword_7F9FC;
// 482A5C: using guessed type char byte_482A5C;
// 482A5D: using guessed type char byte_482A5D;
// 590404: using guessed type char byte_590404;

//----- (00024F04) --------------------------------------------------------
int sub_24F04()
{
  int v0; // r0
  int v1; // r0
  int v2; // r4
  int result; // r0
  socklen_t addr_len; // [sp+Ch] [bp-84Ch] BYREF
  struct sockaddr addr; // [sp+10h] [bp-848h] BYREF
  struct sockaddr v6; // [sp+20h] [bp-838h] BYREF
  char s[2088]; // [sp+30h] [bp-828h] BYREF

  prctl(15, "http", 0);
  do
  {
    v0 = socket(2, 1, 6);
    dword_7E2EC = v0;
    if ( v0 < 0 )
    {
      if ( byte_590404 || byte_482A5C || dword_7EBA0 > 4 )
      {
        strcpy(s, "socket creating failed, try again after 10s...");
        sub_2E584(5, s, 0);
      }
      sleep(0xAu);
    }
    else
    {
      *(_DWORD *)&addr.sa_family = -1407778814;
      memset(&addr.sa_data[2], 0, 12);
      if ( bind(v0, &addr, 0x10u) < 0 )
      {
        if ( byte_590404 || byte_482A5C || dword_7EBA0 > 4 )
        {
          strcpy(s, "http port bind failed! try again after 10s...");
          sub_2E584(5, s, 0);
        }
      }
      else
      {
        if ( listen(dword_7E2EC, 100) >= 0 )
          break;
        if ( byte_590404 || byte_482A5C || dword_7EBA0 > 4 )
        {
          strcpy(s, "http listen failed! try again after 10s...");
          sub_2E584(5, s, 0);
        }
      }
      close(dword_7E2EC);
      dword_7E2EC = -1;
      sleep(0xAu);
    }
  }
  while ( !byte_7F9F8 );
  if ( byte_590404 || byte_482A5C || dword_7EBA0 > 4 )
  {
    strcpy(s, "start listen on 6060 ...");
    sub_2E584(5, s, 0);
  }
  if ( !byte_7F9F8 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        usleep(0x2710u);
        addr_len = 16;
        v1 = accept(dword_7E2EC, &v6, &addr_len);
        v2 = v1;
        if ( v1 != -1 )
          break;
        if ( byte_7F9F8 )
          goto LABEL_19;
      }
      if ( byte_7F9F8 )
        break;
      if ( byte_482A5D && (byte_590404 || byte_482A5C || dword_7EBA0 > 6) )
      {
        snprintf(s, 0x800u, "one client connected sock=%d", v1);
        sub_2E584(7, s, 0);
      }
      sub_24398(v2);
      if ( byte_7F9F8 )
        goto LABEL_19;
    }
    close(v1);
  }
LABEL_19:
  close(dword_7E2EC);
  result = 0;
  dword_7E2EC = -1;
  return result;
}
// 7E2EC: using guessed type int dword_7E2EC;
// 7EBA0: using guessed type int dword_7EBA0;
// 7F9F8: using guessed type char byte_7F9F8;
// 482A5C: using guessed type char byte_482A5C;
// 482A5D: using guessed type char byte_482A5D;
// 590404: using guessed type char byte_590404;

//----- (00025284) --------------------------------------------------------
int sub_25284()
{
  int result; // r0
  pthread_t v1; // [sp+0h] [bp-830h] BYREF
  pthread_attr_t attr; // [sp+4h] [bp-82Ch] BYREF
  char s[2056]; // [sp+28h] [bp-808h] BYREF

  if ( byte_590404 || byte_482A5C || dword_7EBA0 > 4 )
  {
    strcpy(s, "start the http log.\n");
    sub_2E584(5, s, 0);
  }
  pthread_attr_init(&attr);
  pthread_attr_setstacksize(&attr, 0x200000u);
  result = pthread_create(&v1, &attr, (void *(*)(void *))sub_24F04, 0);
  if ( byte_590404 || byte_482A5C || dword_7EBA0 > 4 )
  {
    snprintf(s, 0x800u, "httpListenThread start ret=%d", result);
    return sub_2E584(5, s, 0);
  }
  return result;
}
// 7EBA0: using guessed type int dword_7EBA0;
// 482A5C: using guessed type char byte_482A5C;
// 590404: using guessed type char byte_590404;

//----- (000253A0) --------------------------------------------------------
char *__fastcall sub_253A0(const char *a1)
{
  const char *v2; // r4
  char *v3; // r6
  size_t v4; // r0
  size_t v5; // r5
  size_t v6; // r8
  size_t v7; // r5
  int v8; // r3
  char *v9; // r0
  int v10; // r6
  struct hostent *v11; // r3
  int v12; // r0
  int v13; // r5
  int v14; // r4
  signed int v15; // r6
  ssize_t v16; // r0
  const char *v17; // r12
  int v18; // r0
  int v19; // r1
  int v20; // r2
  int v21; // r3
  _DWORD *v22; // r12
  char *v23; // r4
  int v24; // r1
  char *v26; // r0
  char *v27; // r0
  char *v28; // r5
  size_t v29; // r0
  char *v30; // r0
  int v31[2]; // [sp+8h] [bp-2020h] BYREF
  char s[1024]; // [sp+10h] [bp-2018h] BYREF
  char dest[1024]; // [sp+410h] [bp-1C18h] BYREF
  struct sockaddr v34[127]; // [sp+810h] [bp-1818h] BYREF
  char v35[4120]; // [sp+1010h] [bp-1018h] BYREF

  memset(v35, 0, 0x1000u);
  memset(s, 0, sizeof(s));
  memset(dest, 0, sizeof(dest));
  if ( !a1 )
  {
    if ( byte_590404 || byte_482A5C || dword_7EBA0 > 4 )
    {
      v23 = 0;
      strcpy((char *)v34, "url is null!\n");
      sub_2E584(5, (const char *)v34, 0);
      return v23;
    }
    return 0;
  }
  if ( !strncmp(a1, "http://", 7u) )
  {
    v2 = a1 + 7;
    v3 = strchr(v2, 47);
    v4 = strlen(v2);
    v5 = v4;
    if ( v3 )
    {
      v6 = strlen(v3);
      v7 = v5 - v6;
      memcpy(s, v2, v7);
      v8 = (unsigned __int8)v3[1];
      s[v7] = 0;
      if ( v8 )
      {
        memcpy(dest, v3 + 1, v6 - 1);
        s[v6 + 1023] = 0;
      }
    }
    else
    {
      memcpy(s, v2, v4);
      s[v5] = 0;
    }
    v9 = strchr(s, 58);
    if ( v9 )
    {
      *v9 = 0;
      v10 = strtol(v9 + 1, 0, 10);
    }
    else
    {
      v10 = 80;
    }
    v11 = gethostbyname(s);
    if ( !v11 )
      goto LABEL_37;
    *(_WORD *)v34[0].sa_data = __rev16(v10);
    v34[0].sa_family = 2;
    *(_DWORD *)&v34[0].sa_data[2] = **(_DWORD **)v11->h_addr_list;
    v12 = socket(2, 1, 0);
    v13 = v12;
    if ( v12 == -1
      || (v31[0] = 10, v31[1] = 0, setsockopt(v12, 1, 21, v31, 8u))
      || (v14 = setsockopt(v13, 1, 20, v31, 8u)) != 0
      || connect(v13, v34, 0x10u) == -1
      || v13 < 0 )
    {
LABEL_37:
      if ( byte_590404 || byte_482A5C || dword_7EBA0 > 4 )
      {
        v23 = 0;
        strcpy((char *)v34, "tcp client create failed\n");
        sub_2E584(5, (const char *)v34, 0);
        return v23;
      }
    }
    else
    {
      sprintf(v35, "GET /%s HTTP/1.1\r\nHOST: %s:%d\r\nAccept: */*\r\n\r\n", dest, s, v10);
      v15 = strlen(v35);
      if ( v15 )
      {
        while ( 1 )
        {
          v16 = send(v13, &v35[v14], v15 - v14, 0);
          v14 += v16;
          if ( v16 == -1 )
            break;
          if ( v15 <= v14 )
            goto LABEL_39;
        }
        if ( byte_590404 || byte_482A5C || dword_7EBA0 > 4 )
        {
          v17 = "tcp client send failed\n";
LABEL_23:
          v18 = *(_DWORD *)v17;
          v19 = *((_DWORD *)v17 + 1);
          v20 = *((_DWORD *)v17 + 2);
          v21 = *((_DWORD *)v17 + 3);
          v22 = v17 + 16;
          v23 = 0;
          *(_DWORD *)&v34[0].sa_family = v18;
          *(_DWORD *)&v34[0].sa_data[2] = v19;
          *(_DWORD *)&v34[0].sa_data[6] = v20;
          *(_DWORD *)&v34[0].sa_data[10] = v21;
          v24 = v22[1];
          *(_DWORD *)&v34[1].sa_family = *v22;
          *(_DWORD *)&v34[1].sa_data[2] = v24;
          sub_2E584(5, (const char *)v34, 0);
          return v23;
        }
      }
      else
      {
LABEL_39:
        if ( recv(v13, v35, 0x1000u, 0) > 0 )
        {
          close(v13);
          v26 = strstr(v35, "HTTP/1.1");
          if ( v26 )
          {
            if ( strtol(v26 + 9, 0, 10) == 200 )
            {
              v27 = strstr(v35, "\r\n\r\n");
              v28 = v27;
              if ( v27 )
              {
                v29 = strlen(v27);
                v30 = (char *)malloc(v29 + 1);
                v23 = v30;
                if ( v30 )
                  strcpy(v30, v28 + 4);
                return v23;
              }
            }
          }
        }
        else if ( byte_590404 || byte_482A5C || dword_7EBA0 > 4 )
        {
          v17 = "tcp client recv failed\n";
          goto LABEL_23;
        }
      }
    }
    return 0;
  }
  if ( !byte_590404 && !byte_482A5C && dword_7EBA0 <= 4 )
    return 0;
  strcpy((char *)v34, "parse url failed!\n");
  sub_2E584(5, (const char *)v34, 0);
  return 0;
}
// 7EBA0: using guessed type int dword_7EBA0;
// 482A5C: using guessed type char byte_482A5C;
// 590404: using guessed type char byte_590404;

//----- (000258C8) --------------------------------------------------------
int __fastcall sub_258C8(char *a1)
{
  int v2; // r0
  int v3; // r6
  int v4; // r9
  unsigned int v5; // r5
  struct in_addr *i; // r4
  char *v8; // r1
  int v10[2]; // [sp+0h] [bp-228h] BYREF
  _OWORD v11[34]; // [sp+8h] [bp-220h] BYREF

  v2 = socket(2, 2, 0);
  v3 = v2;
  if ( v2 < 0 )
    return -1;
  v10[0] = 512;
  v10[1] = (int)v11;
  if ( ioctl(v2, 0x8912u, v10) )
  {
    v4 = -1;
  }
  else
  {
    v4 = -1;
    v5 = (unsigned int)v10[0] >> 5;
    for ( i = (struct in_addr *)&v11[2 * ((unsigned int)v10[0] >> 5) - 2]; v5-- != 0; i -= 8 )
    {
      if ( !ioctl(v3, 0x8915u, i) )
      {
        v8 = inet_ntoa(i[5]);
        if ( v8 )
        {
          strcpy(a1, v8);
          v4 = strcmp("127.0.0.1", a1);
          if ( v4 )
          {
            v4 = 0;
            break;
          }
        }
      }
    }
  }
  close(v3);
  return v4;
}

//----- (000259A8) --------------------------------------------------------
void __noreturn sub_259A8()
{
  double v0; // d0
  double v1; // d9
  int v2; // r4
  double v3; // d8
  double v4; // d7
  const char *v5; // r3
  bool v6; // cc
  int v7; // r12
  int v8[4]; // [sp+10h] [bp-848h] BYREF
  char s[2104]; // [sp+20h] [bp-838h] BYREF

  memset(v8, 0, sizeof(v8));
  v1 = -1.0;
  prctl(15, "heart_beat", 0, 0, 0);
  while ( 1 )
  {
    v2 = 0;
    v3 = 0.0;
    pthread_setcancelstate(1, 0);
    do
    {
      if ( sub_1E29C(v2) )
      {
        sub_304D4();
        if ( sub_191FC((unsigned __int8)v2) )
        {
          v8[v2] = 0;
        }
        else
        {
          v6 = (unsigned int)dword_7EB9C > 1;
          v7 = v8[v2] + 1;
          v8[v2] = v7;
          if ( v6 )
          {
            snprintf(s, 0x800u, "chain[%d] heart beat fail %d times.\n", v2, v7);
            sub_2E584(1, s, 0);
          }
        }
        sub_304D4();
        sub_192C8(v2);
        v3 = v3 + v0;
      }
      ++v2;
    }
    while ( v2 != 4 );
    if ( sub_1E28C() )
      v3 = v3 / (double)sub_1E28C();
    if ( v1 < -0.1 )
      v1 = v3;
    if ( (unsigned int)dword_7EB9C > 4 )
    {
      snprintf(s, 0x800u, "last avg = %.2f, current voltage = %.2f", v1, v3);
      sub_2E584(4, s, 0);
    }
    v4 = (double)(dword_482A8C / 100) * 0.75;
    if ( (v4 < v1 && v1 * 0.75 > v3 || v4 < v3 && v3 * 0.75 > v1) && (unsigned int)dword_7EB9C > 3 )
    {
      v5 = "drop";
      if ( v3 - v1 > 0.0 )
        v5 = "rise";
      snprintf(s, 0x800u, "chain avg vol %s to %.2f", v5, v3);
      sub_2E584(3, s, 0);
    }
    v1 = v3;
    pthread_setcancelstate(0, 0);
    pthread_testcancel();
    sleep(0xAu);
  }
}
// 25B84: variable 'v0' is possibly undefined
// 7EB9C: using guessed type int dword_7EB9C;
// 482A8C: using guessed type int dword_482A8C;

//----- (00025C08) --------------------------------------------------------
int sub_25C08()
{
  int v0; // r6
  int v1; // r6
  int result; // r0
  unsigned int *v3; // r7
  int v4; // r5
  unsigned int *v5; // r8
  unsigned __int64 v6; // r10
  unsigned int v7; // r4
  int v8; // r0
  unsigned __int64 v9; // r0
  unsigned __int64 v10; // r0
  unsigned int *v11; // lr
  int v12; // r12
  unsigned int v13; // t1
  char v14[2080]; // [sp+0h] [bp-820h] BYREF

  v0 = sub_1E0E0();
  v1 = sub_1E150() * v0;
  result = (int)malloc(4 * v1);
  v3 = (unsigned int *)result;
  if ( result )
  {
    v4 = 0;
    while ( 1 )
    {
      if ( sub_1E29C(v4) )
      {
        if ( v1 )
        {
          v5 = v3 - 1;
          v6 = 0LL;
          v7 = 0;
          do
          {
            v8 = sub_2CD30(v4, v7++);
            v6 += (unsigned int)v8;
            v5[1] = v8;
            ++v5;
          }
          while ( v1 != v7 );
          LODWORD(v9) = sub_60120(v6, (unsigned int)v1);
          if ( v9 > 0x1387 )
          {
            v10 = v9 >> 1;
            if ( *v3 < v10 )
            {
LABEL_16:
              if ( (unsigned int)dword_7EB9C > 3 )
              {
                strcpy(v14, "Domain unbalance happened!\n");
                sub_2E584(3, v14, 0);
              }
              free(v3);
              return 1;
            }
            v11 = v3;
            v12 = 0;
            while ( ++v12 != v7 )
            {
              v13 = v11[1];
              ++v11;
              if ( v13 < v10 )
                goto LABEL_16;
            }
          }
        }
      }
      if ( ++v4 == 4 )
      {
        free(v3);
        return 0;
      }
    }
  }
  if ( (unsigned int)dword_7EB9C > 3 )
  {
    strcpy(v14, "failed alloc memory!\n");
    sub_2E584(3, v14, 0);
    return 0;
  }
  return result;
}
// 25CC4: variable 'v9' is possibly undefined
// 7EB9C: using guessed type int dword_7EB9C;

//----- (00025DB0) --------------------------------------------------------
int sub_25DB0()
{
  int result; // r0
  bool v1; // zf
  int v2; // r2
  int v3; // r0
  unsigned int v4; // r0
  __time_t v5; // [sp+0h] [bp-820h] BYREF
  unsigned int seed; // [sp+4h] [bp-81Ch]
  char s[2072]; // [sp+8h] [bp-818h] BYREF

  sub_302A0(&v5);
  result = (int)dword_482A74;
  v1 = dword_482A74[0] == 0;
  if ( !dword_482A74[0] )
    v1 = dword_482A74[1] == 0;
  if ( v1 )
    return sub_302A0(dword_482A74);
  v2 = v5 - dword_482A74[0];
  if ( (int)(seed - dword_482A74[1]) < 0 )
    --v2;
  if ( v2 <= 300 )
  {
    if ( dword_7FA04 )
    {
      if ( (unsigned int)dword_7EB9C > 3 )
      {
        strcpy(s, "network connection resume, restart");
        sub_2E584(3, s, 0);
      }
      result = sub_31D58(6u, "network connection resume, restart...");
      dword_7FA04 = 0;
      dword_7FA00 = 0;
    }
    else if ( dword_7FA00 )
    {
      if ( (unsigned int)dword_7EB9C > 3 )
      {
        strcpy(s, "network connection resume");
        sub_2E584(3, s, 0);
      }
      v3 = sub_31D48();
      result = sub_31D58(v3, 0);
      dword_7FA00 = 0;
    }
  }
  else if ( dword_7FA00 )
  {
    if ( dword_7FA00 + 299 < v2 && !dword_7FA04 )
    {
      if ( (unsigned int)dword_7EB9C > 3 )
      {
        snprintf(s, 0x800u, "network connection lost for 5 min + %d seconds, power off...", dword_7FA00);
        sub_2E584(3, s, 0);
      }
      result = sub_194DC();
      dword_7FA04 = 1;
    }
  }
  else
  {
    sub_31D58(3u, "network connection lost");
    v4 = sub_2B2F4();
    if ( !v4 )
      v4 = seed;
    srandom(v4);
    result = random();
    dword_7FA00 = result % 300 + 1;
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      snprintf(s, 0x800u, "will power off in %d seconds in case not resume", result % 300 + 1);
      return sub_2E584(3, s, 0);
    }
  }
  return result;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 7FA00: using guessed type int dword_7FA00;
// 7FA04: using guessed type int dword_7FA04;
// 482A74: using guessed type __time_t dword_482A74[3];

//----- (0002600C) --------------------------------------------------------
void __noreturn sub_2600C()
{
  int v0; // r0
  unsigned int v1; // r5
  int i; // r4
  _QWORD v3[4]; // [sp+8h] [bp-20h] BYREF

  v0 = sub_452B0();
  sub_452D0(v0 | 0x10000);
  prctl(15, "nonce_reg_process", 0);
  while ( 1 )
  {
    v1 = (unsigned int)sub_44D3C() >> 1;
    if ( v1 )
    {
      for ( i = 0; i != v1; ++i )
      {
        while ( 1 )
        {
          sub_44D94(v3);
          if ( (v3[0] & 0x80000000LL) != 0 )
            break;
          ++i;
          sub_2C96C((int)v3);
          if ( v1 == i )
            goto LABEL_7;
        }
        sub_2C5E8(v3);
      }
    }
LABEL_7:
    sub_304D4();
  }
}

//----- (00026094) --------------------------------------------------------
time_t sub_26094()
{
  int v0; // r4
  char *v1; // r0
  char s[2056]; // [sp+8h] [bp-808h] BYREF

  if ( (unsigned int)dword_7EB9C > 3 )
  {
    v0 = *_errno_location();
    v1 = strerror(v0);
    snprintf(s, 0x800u, "Failed to get sysinfo, errno = %u, reason = %s.\n", v0, v1);
    sub_2E584(3, s, 0);
  }
  return time(0);
}
// 7EB9C: using guessed type int dword_7EB9C;

//----- (00026104) --------------------------------------------------------
int sub_26104()
{
  struct sysinfo v1; // [sp+0h] [bp-48h] BYREF

  if ( sysinfo(&v1) )
    return sub_26094();
  else
    return v1.uptime;
}

//----- (00026134) --------------------------------------------------------
int sub_26134()
{
  int v0; // r0
  __int64 v1; // r6
  int v2; // r8
  int v3; // r8
  double v4; // r0
  int result; // r0
  char s[2072]; // [sp+10h] [bp-818h] BYREF

  v0 = sub_26104();
  v1 = qword_99EE08;
  v2 = dword_7FA08;
  dword_7FA08 = v0;
  v3 = v0 - v2;
  LODWORD(v4) = sub_600B4(qword_99EE08 - qword_7FA10);
  qword_7FA10 = v1;
  unk_99EE00 = v4 * 4294967300.0 / 1000000000.0 / (double)v3;
  result = sub_1A18C();
  if ( (double)result * 0.75 > unk_99EE00 && (unsigned int)dword_7EB9C > 3 )
  {
    snprintf(s, 0x800u, "avg rate is lower than ideal rate, %0.2f in %ld mins\n", unk_99EE00, v3 / 60);
    return sub_2E584(3, s, 0);
  }
  return result;
}
// 26194: variable 'v4' is possibly undefined
// 7EB9C: using guessed type int dword_7EB9C;
// 7FA08: using guessed type int dword_7FA08;
// 7FA10: using guessed type __int64 qword_7FA10;
// 99EE08: using guessed type __int64 qword_99EE08;

//----- (00026250) --------------------------------------------------------
int sub_26250()
{
  int v0; // r0
  int v1; // r7
  int v2; // r7
  int *v3; // r6
  int i; // r5
  bool v5; // zf
  int result; // r0
  int v7; // r9
  int v8; // r11
  unsigned int v9; // r4
  unsigned __int64 v10; // r0
  __int64 v11; // r0
  double v12; // r0
  double v13; // d5
  char s[2088]; // [sp+28h] [bp-828h] BYREF

  if ( dword_80F60 == 1 )
  {
    memset(&dword_7FA18, 0, 0x20u);
    dword_80F60 = 0;
  }
  v0 = sub_26104();
  v1 = dword_7FA38;
  dword_7FA38 = v0;
  v2 = v0 - v1;
  v3 = &dword_7FA18;
  for ( i = 0; i != 4; ++i )
  {
    while ( 1 )
    {
      v5 = sub_1E29C(i) == 0;
      result = (int)&dword_99ED98[2 * i];
      if ( !v5 )
      {
        v7 = dword_99ED98[2 * i];
        v8 = *(_DWORD *)(result + 4);
        v9 = dword_7F8F0;
        LODWORD(v10) = sub_60120(0xFFFFFFFEFFFFFFFFLL * (__PAIR64__(v8, v7) - *(_QWORD *)v3), v2);
        LODWORD(v11) = sub_60120(v10, 0x3B9ACA00uLL);
        LODWORD(v12) = sub_600B4(v11);
        v13 = v12;
        *v3 = v7;
        v3[1] = v8;
        dbl_58E040[24 * i + v9 % 0x18] = v12;
        result = 24 * i + (v9 - 1) % 0x18;
        if ( v9 > 1 && v13 < dbl_58E040[result] * 0.75 && (unsigned int)dword_7EB9C > 3 )
          break;
      }
      ++i;
      v3 += 2;
      if ( i == 4 )
        goto LABEL_9;
    }
    snprintf(s, 0x800u, "chain %d hash rate %.2f low in %ld mins", i, v13, v2 / 60);
    result = sub_2E584(3, s, 0);
    v3 += 2;
  }
LABEL_9:
  ++dword_7F8F0;
  return result;
}
// 26340: variable 'v10' is possibly undefined
// 26344: variable 'v11' is possibly undefined
// 26348: variable 'v12' is possibly undefined
// 7EB9C: using guessed type int dword_7EB9C;
// 7F8F0: using guessed type int dword_7F8F0;
// 7FA18: using guessed type int dword_7FA18;
// 7FA38: using guessed type int dword_7FA38;
// 80F60: using guessed type int dword_80F60;
// 58E040: using guessed type double dbl_58E040[96];
// 99ED98: using guessed type _DWORD dword_99ED98[8];

//----- (0002647C) --------------------------------------------------------
void __noreturn sub_2647C()
{
  const char *v0; // r0
  int v1; // r5
  unsigned int v2; // r0
  unsigned int v3; // r5
  int v4; // r4
  int v5; // r0

  prctl(15, "chk_sys", 0);
  v0 = (const char *)sub_1E0C0();
  if ( strcmp(v0, "BHB28601") )
    sub_1E0C0();
  v1 = sub_26104();
  while ( 1 )
  {
    if ( sub_31D38() == 2 )
    {
      v2 = sub_26104() - v1;
      if ( *(_QWORD *)&qword_99EE08 || v2 > 0x708 )
        break;
    }
    sub_304D4();
  }
  dword_7FA3C = sub_26104();
  dword_7FA08 = dword_7FA3C;
  dword_7FA40 = dword_7FA3C;
  dword_7FA38 = dword_7FA3C;
  v3 = 1;
  pthread_setcancelstate(1, 0);
  while ( 1 )
  {
    do
    {
      if ( !pthread_mutex_trylock(&stru_7FA44) )
      {
        if ( byte_7EB78 )
          sub_350E8();
        pthread_mutex_unlock(&stru_7FA44);
      }
      ++v3;
      pthread_setcancelstate(0, 0);
      pthread_testcancel();
      sub_304D4();
      pthread_setcancelstate(1, 0);
      v4 = v3 % 0x1E;
    }
    while ( v3 != 30 * (v3 / 0x1E) );
    if ( sub_1E29C(v3 % 0x1E) )
    {
LABEL_17:
      v5 = sub_1E160();
      sub_3EFF0(v4, v5);
    }
    while ( ++v4 != 4 )
    {
      if ( sub_1E29C(v4) )
        goto LABEL_17;
    }
  }
}
// 7EB78: using guessed type char byte_7EB78;
// 7FA08: using guessed type int dword_7FA08;
// 7FA38: using guessed type int dword_7FA38;
// 7FA3C: using guessed type int dword_7FA3C;
// 7FA40: using guessed type int dword_7FA40;
// 99EE08: using guessed type int dword_99EE08;

//----- (000265F4) --------------------------------------------------------
int sub_265F4()
{
  int result; // r0

  result = sub_26104();
  dword_7FA3C = result;
  dword_7FA08 = result;
  dword_7FA40 = result;
  dword_7FA38 = result;
  return result;
}
// 7FA08: using guessed type int dword_7FA08;
// 7FA38: using guessed type int dword_7FA38;
// 7FA3C: using guessed type int dword_7FA3C;
// 7FA40: using guessed type int dword_7FA40;

//----- (00026618) --------------------------------------------------------
int sub_26618()
{
  int result; // r0

  result = sub_1A18C();
  if ( (double)result * 0.95 > unk_99EE00 )
  {
    result = sub_25C08();
    if ( result )
      return sub_31D58(0xBu, "Unbalance happened, reboot!\n");
  }
  return result;
}

//----- (00026670) --------------------------------------------------------
int sub_26670()
{
  int v0; // r3
  int v1; // r2
  int v2; // r3
  int v3; // r1
  int v5; // r0
  int *v6; // r10
  double v7; // d8
  int *v8; // r9
  int v9; // r5
  int v10; // s24
  int v11; // lr
  int v12; // r1
  int v13; // r0
  int v14; // r1
  int v15; // r2
  int v16; // r7
  int *v17; // r0
  int v18; // r4
  int v19; // r6
  int v20; // r1
  int v21; // r2
  int v22; // r3
  int v23; // r12
  __int64 v24; // r0
  double v25; // r0
  double v26; // d6
  int v27; // r4
  int v28; // r0
  int v29; // r7
  int v30; // r7
  double v31; // r0
  double v32; // d7
  int v33; // r12
  double *v34; // r3
  double v35; // d6
  __int64 v36; // r0
  int v37; // r2
  int *v38; // r1
  double v39; // d7
  double v40; // d6
  double v42; // d6

  sub_32530();
  v0 = dword_7FA5C;
  v1 = dword_7FA5C >> 31;
  if ( !(dword_7FA5C % 5) )
  {
    if ( dword_80F58 == 1 )
    {
      memset(&unk_7FA60, 0, 0x140u);
      memset(&dword_7FBA0, 0, 0x20u);
      memset(&dword_7FBC0, 0, 0x20u);
      dword_7FBE0[0] = 0;
      dword_7FBF0[0] = 0;
      dword_80F58 = 0;
      dword_7FBE4 = 0;
      dword_7FBE8 = 0;
      dword_7FBEC = 0;
      dword_7FBF4 = 0;
      dword_7FBF8 = 0;
      dword_7FBFC = 0;
    }
    v5 = sub_26104();
    v6 = &dword_7FBA0;
    v7 = 0.0;
    v8 = &dword_7FBC0;
    v9 = 0;
    v10 = v5 - dword_7FA3C;
    dword_7FA3C = v5;
    do
    {
      if ( sub_1E29C(v9) )
      {
        v11 = dword_99ED98[2 * v9 + 1];
        v12 = dword_7FBE0[v9];
        v13 = 10 * v9 + v12;
        v14 = v12 + 1;
        v15 = 1717986919 * v14;
        v16 = dword_7FBF0[v9];
        v17 = &dword_7FA00[2 * v13];
        if ( v16 <= 9 )
          v15 = (int)dword_7FBF0;
        v18 = *v8;
        if ( v16 <= 9 )
          *(_DWORD *)(v15 + 4 * v9) = ++v16;
        v19 = v14 % 10;
        v20 = dword_99ED98[2 * v9];
        v21 = v6[1];
        dword_7FBE0[v9] = v19;
        v22 = *v6;
        v23 = v8[1];
        *v6 = v20;
        v6[1] = v11;
        *((_QWORD *)v17 + 12) = __PAIR64__(v11, v20) - __PAIR64__(v21, v22);
        *v8 = v20 - v22 + v18;
        v24 = __PAIR64__(v11, v20) - __PAIR64__(v21, v22) + __PAIR64__(v23, v18);
        v8[1] = HIDWORD(v24);
        LODWORD(v25) = sub_600B4(v24);
        v26 = v25 * 4294967300.0 / (double)v16 / (double)v10;
        sub_1E4C0(v9);
        v7 = v7 + v26 / 1000000000.0;
        *(_QWORD *)v8 -= *(_QWORD *)&dword_7FA00[20 * v9 + 24 + 2 * v19];
      }
      ++v9;
      v6 += 2;
      v8 += 2;
    }
    while ( v9 != 4 );
    v27 = 0;
    sub_1E2B4();
    sprintf(byte_80FB8, "%.2f", v7);
    if ( dword_80F5C == 1 )
    {
      qword_7FC00 = 0LL;
      memset(&unk_7FC08, 0, 0xB40u);
      dword_80748 = 0;
      dword_80F5C = 0;
    }
    v28 = sub_26104();
    v29 = dword_7FA40;
    dword_7FA40 = v28;
    if ( qword_99EE08 )
    {
      v30 = v28 - v29;
      LODWORD(v31) = sub_600B4(0xFFFFFFFFLL * (qword_99EE08 - qword_7FC00));
      v32 = 1000000000.0;
      v33 = dword_80748;
      v34 = (double *)&unk_7FC08;
      v35 = v31 / 1000000000.0;
      if ( v30 )
        v32 = (double)v30;
      v36 = 381774871LL * ((unsigned int)dword_80748 >> 3);
      v37 = ++dword_80748;
      v38 = &dword_7FA00[2 * (v33 - 360 * (HIDWORD(v36) >> 2))];
      if ( v30 )
        v35 = v35 / v32;
      v39 = 0.0;
      *((double *)v38 + 65) = v35;
      do
      {
        if ( v37 == v27++ )
          goto LABEL_36;
        v40 = *v34++;
        v39 = v39 + v40;
      }
      while ( v27 != 360 );
      if ( (unsigned int)v37 < 0x168 )
      {
LABEL_36:
        v42 = (double)v37;
        goto LABEL_37;
      }
      v42 = 360.0;
LABEL_37:
      unk_80FC8 = v39 / v42;
      sub_1E2D8();
      v0 = dword_7FA5C;
      v1 = dword_7FA5C >> 31;
      qword_7FC00 = qword_99EE08;
    }
    else
    {
      v0 = dword_7FA5C;
      v1 = dword_7FA5C >> 31;
    }
  }
  if ( v0 == 10 * (((int)((unsigned __int64)(1717986919LL * v0) >> 32) >> 2) - v1) )
  {
    if ( sub_31D38() == 2 )
      sub_2D158();
    v0 = dword_7FA5C;
  }
  v2 = v0 + 1;
  v3 = v2 >> 31;
  dword_7FA5C = v2;
  if ( v2 == 60 * (v2 / 60) )
  {
    sub_3264C();
    v2 = dword_7FA5C;
    v3 = dword_7FA5C >> 31;
    if ( dword_7FA5C % 1800 )
      goto LABEL_10;
  }
  else if ( v2 != 1800 * (v2 / 1800) )
  {
    goto LABEL_5;
  }
  sub_26134();
  v2 = dword_7FA5C;
  v3 = dword_7FA5C >> 31;
LABEL_10:
  if ( v2 == 60 * (((int)((unsigned __int64)(2290649225LL * v2) >> 32) >> 5) - v3) )
  {
    sub_2CB2C();
    sub_2CE20();
    v2 = dword_7FA5C;
    v3 = dword_7FA5C >> 31;
  }
LABEL_5:
  if ( v2 == 900 * (((int)((unsigned __int64)(2443359173LL * v2) >> 32) >> 9) - v3) )
    sub_26250();
  return 0;
}
// 26900: variable 'v25' is possibly undefined
// 26A1C: variable 'v31' is possibly undefined
// 7FA00: using guessed type int dword_7FA00[];
// 7FA3C: using guessed type int dword_7FA3C;
// 7FA40: using guessed type int dword_7FA40;
// 7FA5C: using guessed type int dword_7FA5C;
// 7FBA0: using guessed type int dword_7FBA0;
// 7FBC0: using guessed type int dword_7FBC0;
// 7FBE0: using guessed type int dword_7FBE0[];
// 7FBE4: using guessed type int dword_7FBE4;
// 7FBE8: using guessed type int dword_7FBE8;
// 7FBEC: using guessed type int dword_7FBEC;
// 7FBF0: using guessed type int dword_7FBF0[];
// 7FBF4: using guessed type int dword_7FBF4;
// 7FBF8: using guessed type int dword_7FBF8;
// 7FBFC: using guessed type int dword_7FBFC;
// 7FC00: using guessed type __int64 qword_7FC00;
// 80748: using guessed type int dword_80748;
// 80F58: using guessed type int dword_80F58;
// 80F5C: using guessed type int dword_80F5C;
// 99ED98: using guessed type _DWORD dword_99ED98[8];
// 99EE08: using guessed type __int64 qword_99EE08;

//----- (00026B80) --------------------------------------------------------
void __noreturn sub_26B80()
{
  prctl(15, "chk_status", 0);
  while ( 1 )
  {
    do
    {
      sub_25DB0();
      sub_26670();
      sub_304D4();
    }
    while ( dword_7F7E0 );
    sub_13DA4(0x190u, 0);
  }
}
// 7F7E0: using guessed type int dword_7F7E0;

//----- (00026BD4) --------------------------------------------------------
int __fastcall sub_26BD4(int a1, int a2)
{
  _DWORD *v3; // r0
  _DWORD *v4; // r0
  int v5; // r4
  int i; // r8
  int result; // r0
  _DWORD *v8; // r0
  int v9; // r9
  int v10; // r5
  int v11; // r7
  int v12; // t1
  int v13; // r6
  int v14; // r8
  int v15; // r0
  int v16; // r1
  _DWORD *v17; // r8
  int v18; // r0
  _DWORD *v19; // r0
  _DWORD *v20; // r0
  int v21; // [sp+28h] [bp-130h]
  char s[296]; // [sp+30h] [bp-128h] BYREF

  memset(s, 0, 0x100u);
  v3 = (_DWORD *)dword_8074C;
  if ( !dword_8074C )
  {
    v3 = sub_536F4("bmminer_tuning");
    dword_8074C = (int)v3;
  }
  sub_54CB0((int)v3, "thread.c", 8, (int)"_tuning_freq_dump_nonce_info", 28, 611, 20, (int)"\n current freq: %d\n", a1);
  v4 = (_DWORD *)dword_8074C;
  if ( !dword_8074C )
  {
    v4 = sub_536F4("bmminer_tuning");
    dword_8074C = (int)v4;
  }
  v5 = 0;
  sub_54CB0(
    (int)v4,
    "thread.c",
    8,
    (int)"_tuning_freq_dump_nonce_info",
    28,
    612,
    20,
    (int)"\n dump asic nonce number...\n");
  for ( i = 0; i != 4; ++i )
  {
    result = sub_1E29C(i);
    if ( result )
    {
      v8 = (_DWORD *)dword_8074C;
      if ( !dword_8074C )
      {
        v8 = sub_536F4("bmminer_tuning");
        dword_8074C = (int)v8;
      }
      sub_54CB0((int)v8, "thread.c", 8, (int)"_tuning_freq_dump_nonce_info", 28, 616, 20, (int)"Chain[%d] nonce:\n", i);
      v9 = sub_1E0F0();
      if ( v9 > 0 )
      {
        v10 = 0;
        v21 = i;
        v11 = a2 - 4 + (i << 10);
        do
        {
          v12 = *(_DWORD *)(v11 + 4);
          v11 += 4;
          v13 = v10 + 1;
          v14 = snprintf(&s[v5], 256 - v5, "asic[%03d]=%-8d", v10, v12);
          v15 = sub_1E100();
          sub_5FD8C(v10 + 1, v15);
          v5 += v14;
          if ( !v16 )
          {
            v5 = 0;
            v17 = (_DWORD *)dword_8074C;
            if ( !dword_8074C )
            {
              v17 = sub_536F4("bmminer_tuning");
              dword_8074C = (int)v17;
            }
            v18 = sub_5FAF8(v10, v9);
            sub_54CB0(
              (int)v17,
              "thread.c",
              8,
              (int)"_tuning_freq_dump_nonce_info",
              28,
              625,
              20,
              (int)"domain %02d %s",
              v18,
              s);
          }
          ++v10;
        }
        while ( v13 != v9 );
        i = v21;
      }
      v19 = (_DWORD *)dword_8074C;
      if ( !dword_8074C )
      {
        v19 = sub_536F4("bmminer_tuning");
        dword_8074C = (int)v19;
      }
      sub_54CB0(
        (int)v19,
        "thread.c",
        8,
        (int)"_tuning_freq_dump_nonce_info",
        28,
        630,
        20,
        (int)"Chain[%d] total nonce number = %d\n",
        i,
        0);
      v20 = (_DWORD *)dword_8074C;
      if ( !dword_8074C )
      {
        v20 = sub_536F4("bmminer_tuning");
        dword_8074C = (int)v20;
      }
      result = sub_54CB0((int)v20, "thread.c", 8, (int)"_tuning_freq_dump_nonce_info", 28, 631, 20, (int)&word_6A02C);
    }
  }
  return result;
}
// 26D94: variable 'v16' is possibly undefined
// 6A02C: using guessed type __int16 word_6A02C;
// 8074C: using guessed type int dword_8074C;
// 26BD4: using guessed type char s[296];

//----- (00026F34) --------------------------------------------------------
int __fastcall sub_26F34(int a1, int a2)
{
  int v4; // r12
  int result; // r0
  int v6; // r3
  int v7; // r1
  int v8; // t1

  v4 = sub_1E0F0();
  if ( v4 <= 0 )
    return 0;
  result = 0;
  v6 = 0;
  v7 = a2 + (a1 << 10) - 4;
  do
  {
    ++v6;
    v8 = *(_DWORD *)(v7 + 4);
    v7 += 4;
    result += v8;
  }
  while ( v4 != v6 );
  return result;
}

//----- (00026F7C) --------------------------------------------------------
int __fastcall sub_26F7C(int a1, int a2)
{
  int v4; // r0
  int v5; // r5
  int v6; // r3
  int v7; // r2
  int v8; // t1
  int v9; // r0
  int v10; // r5
  int v11; // r0
  int v12; // r1
  int v13; // r4
  int v14; // r2
  int v15; // r1
  int v16; // t1
  int v17; // r0
  double v18; // r0

  v4 = sub_1E0F0();
  if ( v4 > 0 )
  {
    v5 = 0;
    v6 = 0;
    v7 = a2 + (a1 << 10) - 4;
    do
    {
      ++v6;
      v8 = *(_DWORD *)(v7 + 4);
      v7 += 4;
      v5 += v8;
    }
    while ( v4 != v6 );
  }
  else
  {
    v5 = 0;
  }
  v9 = sub_1E0F0();
  v10 = sub_5FAF8(v5, v9);
  v11 = sub_1E0F0();
  if ( v11 <= 0 )
    return sub_1E0F0();
  v12 = a2 + (a1 << 10);
  v13 = 0;
  v14 = 0;
  v15 = v12 - 4;
  do
  {
    v16 = *(_DWORD *)(v15 + 4);
    v15 += 4;
    ++v14;
    v13 += (v16 - v10) * (v16 - v10);
  }
  while ( v11 != v14 );
  v17 = sub_1E0F0();
  LODWORD(v18) = sub_5FAF8(v13, v17);
  if ( (double)SLODWORD(v18) < 0.0 )
    v18 = sqrt(v18);
  return LODWORD(v18);
}
// 2704C: variable 'v18' is possibly undefined

//----- (00027058) --------------------------------------------------------
int sub_27058()
{
  unsigned int v0; // r6
  int v1; // r4
  int v2; // r6
  int v3; // r0
  unsigned int v4; // r2
  unsigned int v5; // r8
  int v6; // r5
  int v7; // r4
  int v8; // r5
  int v9; // r3

  v0 = dword_482A6C;
  v1 = 0;
  dword_482A8C = 10 * ((dword_7EB70 * (dword_482A8C - dword_7EB60) / 100 + dword_7EB60) / 10);
  dword_482A6C = 5 * ((dword_7EB64 + dword_7EB70 * (dword_482A6C - dword_7EB64) / 0x64u) / 5);
  do
  {
    if ( sub_1E29C(v1) )
      sub_1AAE4(v1, (unsigned __int8)byte_482A70, v0, (char *)dword_482A6C, 0);
    ++v1;
  }
  while ( v1 != 4 );
  v2 = sub_19AB4();
  v3 = dword_482A8C;
  v4 = dword_482A8C - v2;
  if ( dword_482A8C - v2 < 0 )
    v4 = v2 - dword_482A8C;
  v5 = v4 / 0x14;
  if ( v4 / 0x14 > 1 )
  {
    v7 = 1;
    do
    {
      v8 = 5 * v7++;
      v9 = v8;
      v6 = v2 - 4 * v8;
      if ( v3 > v2 )
        v6 = v2 + 4 * v9;
      sub_195A8(v6);
      usleep((__useconds_t)&loc_30D40);
      v3 = dword_482A8C;
    }
    while ( v5 != v7 );
  }
  else
  {
    v6 = 0;
  }
  if ( v3 != v6 )
    sub_195A8(v3);
  return sub_1EAD4(0xFu);
}
// 7EB60: using guessed type int dword_7EB60;
// 7EB64: using guessed type int dword_7EB64;
// 7EB70: using guessed type int dword_7EB70;
// 482A6C: using guessed type int dword_482A6C;
// 482A70: using guessed type char byte_482A70;
// 482A8C: using guessed type int dword_482A8C;

//----- (000271E8) --------------------------------------------------------
int sub_271E8()
{
  float v0; // s0
  char v1; // r2
  unsigned int v2; // r9
  int v3; // r7
  int v4; // r5
  int i; // r4
  int v6; // r8
  int v7; // r8
  int v8; // r4
  int v9; // r4
  int v10; // r0
  __int64 v11; // r2
  unsigned __int64 v12; // r10
  int v13; // r4
  double v14; // r0
  bool v15; // cc
  int v16; // s16
  int v17; // r4
  int v18; // r11
  int v19; // r10
  int v20; // r8
  int v21; // r0
  int v22; // r0
  int v23; // r1
  int v24; // r3
  char *v25; // r2
  int v26; // t1
  int v27; // r0
  char *v28; // lr
  char *v29; // r1
  char *v30; // r12
  char *v31; // r0
  int v32; // r2
  int v33; // t1
  int v34; // t1
  int v35; // r4
  int v36; // r9
  char *v37; // r5
  _BYTE *v38; // r8
  int v40; // r12
  int v41; // r1
  _BYTE *v42; // r3
  int v43; // r2
  int v44; // t1
  _BYTE *v45; // r0
  int v46; // r3
  int v47; // r2
  int v48; // t1
  char *v49; // r7
  int v50; // [sp+8h] [bp-2A90h]
  unsigned int v51; // [sp+8h] [bp-2A90h]
  char v52; // [sp+30h] [bp-2A68h]
  _DWORD v53[14]; // [sp+3Ch] [bp-2A5Ch]
  _BYTE v54[36]; // [sp+74h] [bp-2A24h] BYREF
  char v55[240]; // [sp+168h] [bp-2930h] BYREF
  char s[2040]; // [sp+258h] [bp-2840h] BYREF
  char v57[4096]; // [sp+A58h] [bp-2040h] BYREF
  char v58[4160]; // [sp+1A58h] [bp-1040h] BYREF

  prctl(15, "tuning_freq", 0);
  while ( sub_31D38() != 2 )
    sub_304D4();
  while ( 1 )
  {
    pthread_mutex_lock(&stru_7FA44);
    if ( sub_19AB4() == dword_482A8C )
      break;
    pthread_mutex_unlock(&stru_7FA44);
    sub_304D4();
  }
  v1 = byte_7EB78;
  byte_7EB78 = 0;
  v52 = v1;
  pthread_mutex_unlock(&stru_7FA44);
  sub_304D4();
  if ( (unsigned int)dword_7EB9C > 3 )
  {
    strcpy(v58, "tuning freq start\n");
    sub_2E584(3, v58, 0);
  }
  sub_27058();
  v2 = dword_482A6C;
  if ( dword_7EB68 <= 0 )
  {
    v3 = dword_482A6C;
    v35 = 0;
  }
  else
  {
    v50 = 0;
    v3 = dword_482A6C;
    v4 = 0;
    if ( (unsigned int)dword_7EB9C > 3 )
      goto LABEL_32;
    while ( 1 )
    {
      for ( i = 0; i != 4; ++i )
      {
        if ( sub_1E29C(i) )
        {
          v0 = unk_7EDD0;
          sub_1AAE4(i, (unsigned __int8)byte_482A70, v2, (char *)v3, 0);
        }
      }
      v6 = 0;
      memcpy(v57, &unk_81128, sizeof(v57));
      sub_304D4();
      do
      {
        if ( sub_1E29C(v6) )
        {
          v27 = sub_1E0F0();
          if ( v27 > 0 )
          {
            v28 = &v57[1024 * v6 + 4 * v27];
            v29 = &v57[1024 * v6];
            v30 = (char *)&unk_81124 + 1024 * v6;
            v31 = &v58[1024 * v6];
            do
            {
              v33 = *(_DWORD *)v29;
              v29 += 4;
              v32 = v33;
              v34 = *((_DWORD *)v30 + 1);
              v30 += 4;
              *(_DWORD *)v31 = v34 - v32;
              v31 += 4;
            }
            while ( v29 != v28 );
          }
        }
        ++v6;
      }
      while ( v6 != 4 );
      v7 = v50;
      v8 = 0;
      sub_26BD4(v3, (int)v58);
      do
      {
        if ( sub_1E29C(v8) )
        {
          sub_26F7C(v8, (int)v58);
          *(_DWORD *)&v54[v7 + 4] = (int)v0;
          v22 = sub_1E0F0();
          if ( v22 > 0 )
          {
            v23 = 0;
            v24 = 0;
            v25 = &v57[1024 * v8 + 4092];
            do
            {
              ++v24;
              v26 = *((_DWORD *)v25 + 1);
              v25 += 4;
              v23 += v26;
            }
            while ( v22 != v24 );
          }
          else
          {
            v23 = 0;
          }
          v15 = (unsigned int)dword_7EB9C > 3;
          *(_DWORD *)&v55[v7] = v23;
          if ( v15 )
          {
            snprintf(s, 0x800u, "chain %d, nonce_stdev %d, nonce_num %d\n", v8, (int)v0, v23);
            sub_2E584(3, s, 0);
          }
        }
        ++v8;
        v7 += 60;
      }
      while ( v8 != 4 );
      v9 = sub_1E0F0();
      v10 = sub_1E130();
      v11 = 180000000LL * v3;
      v12 = (unsigned int)v11 * (unsigned __int64)(unsigned int)v9;
      v13 = v11 * (v9 >> 31) + v9 * HIDWORD(v11);
      LODWORD(v11) = v12 * v10;
      HIDWORD(v12) += v13;
      HIDWORD(v11) = (v12 * v10) >> 32;
      LODWORD(v14) = sub_600B4(v11);
      v15 = (unsigned int)dword_7EB9C > 3;
      v16 = (int)(v14 * 1.45519152e-11);
      v53[v4] = v16;
      if ( v15 )
      {
        snprintf(s, 0x800u, "ideal_nonce_num %d\n", v16);
        sub_2E584(3, s, 0);
      }
      v17 = 0;
      v18 = v50;
      v19 = 0;
      v20 = v3 - dword_7EB6C;
      do
      {
        v21 = v19++;
        if ( sub_1E29C(v21) && *(int *)&v54[v18 + 4] <= 39 && (double)*(int *)&v55[v18] > (double)v16 * 0.98 )
          ++v17;
        v18 += 60;
      }
      while ( v19 != 4 );
      ++v4;
      if ( sub_1E28C() <= v17 )
        break;
      if ( dword_7EB68 <= v4 || (v2 = v3, v50 += 4, v4 == 15) )
      {
        v35 = v4;
        goto LABEL_45;
      }
      v3 = v20;
      if ( (unsigned int)dword_7EB9C > 3 )
      {
LABEL_32:
        snprintf(s, 0x800u, "level %d, freq_curr %d, freq_next %d\n", v4, v2, v3);
        sub_2E584(3, s, 0);
      }
    }
    v35 = v4;
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      strcpy(s, "all chain tuing done\n");
      sub_2E584(3, s, 0);
    }
  }
LABEL_45:
  v36 = 0;
  v37 = v55;
  v38 = v54;
  sub_1EAD4(0xFFu);
  v51 = v3;
  do
  {
    if ( sub_1E29C(v36) )
    {
      v40 = v35 - 1;
      if ( v35 > 0 )
      {
        v41 = 0x7FFFFFFF;
        v42 = v38;
        do
        {
          v44 = *((_DWORD *)v42 + 1);
          v42 += 4;
          v43 = v44;
          if ( v41 >= v44 )
            v41 = v43;
        }
        while ( v42 != &v38[4 * v35] );
        v45 = v38;
        v46 = 0;
        while ( 1 )
        {
          v48 = *((_DWORD *)v45 + 1);
          v45 += 4;
          v47 = v48;
          if ( v48 <= 39 && (double)*(int *)&v37[4 * v46] > (double)(int)v53[v46] * 0.98 )
            break;
          if ( (double)v47 < (double)v41 * 1.25 && (double)*(int *)&v37[4 * v46] > (double)(int)v53[v46] * 0.98 )
            break;
          if ( v35 == ++v46 )
            goto LABEL_62;
        }
        v40 = v46;
      }
LABEL_62:
      v49 = (char *)(dword_482A6C - dword_7EB6C * v40);
      if ( (unsigned int)dword_7EB9C > 3 )
      {
        snprintf(s, 0x800u, "chain %d best level %d, best freq %d\n", v36, v40, dword_482A6C - dword_7EB6C * v40);
        sub_2E584(3, s, 0);
      }
      sub_1AAE4(v36, (unsigned __int8)byte_482A70, v51, v49, 0);
    }
    ++v36;
    v37 += 60;
    v38 += 60;
  }
  while ( v36 != 4 );
  byte_7EB78 = v52;
  if ( (unsigned int)dword_7EB9C > 3 )
  {
    strcpy(s, "tuning freq end\n");
    sub_2E584(3, s, 0);
  }
  return 0;
}
// 2743C: variable 'v14' is possibly undefined
// 27578: variable 'v0' is possibly undefined
// 7EB68: using guessed type int dword_7EB68;
// 7EB6C: using guessed type int dword_7EB6C;
// 7EB78: using guessed type char byte_7EB78;
// 7EB9C: using guessed type int dword_7EB9C;
// 482A6C: using guessed type int dword_482A6C;
// 482A70: using guessed type char byte_482A70;
// 482A8C: using guessed type int dword_482A8C;
// 271E8: using guessed type _DWORD var_2A5C[14];
// 271E8: using guessed type char anonymous_0[4160];

//----- (00027940) --------------------------------------------------------
int sub_27940()
{
  int v0; // r6
  pthread_attr_t attr; // [sp+4h] [bp-834h] BYREF
  char v3[2064]; // [sp+28h] [bp-810h] BYREF

  v0 = dword_80750;
  if ( dword_80750 )
    return 0;
  pthread_attr_init(&attr);
  pthread_attr_setstacksize(&attr, 0x100000u);
  dword_80750 = (int)calloc(1u, 0x40u);
  if ( sub_30B10(dword_80750, &attr, (void *(*)(void *))sub_259A8, (void *)dword_80750) )
  {
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      strcpy(v3, "create thread failed\n");
      sub_2E584(3, v3, v0);
    }
    return -1;
  }
  else
  {
    pthread_detach(*(_DWORD *)(dword_80750 + 12));
    if ( (unsigned int)dword_7EB9C <= 3 )
      return 0;
    strcpy(v3, "create thread\n");
    sub_2E584(3, v3, 0);
    return 0;
  }
}
// 7EB9C: using guessed type int dword_7EB9C;
// 80750: using guessed type int dword_80750;

//----- (00027A58) --------------------------------------------------------
int sub_27A58()
{
  int v0; // r6
  pthread_attr_t attr; // [sp+4h] [bp-834h] BYREF
  char v3[2064]; // [sp+28h] [bp-810h] BYREF

  v0 = dword_80754;
  if ( dword_80754 )
    return 0;
  pthread_attr_init(&attr);
  pthread_attr_setstacksize(&attr, 0x800000u);
  dword_80754 = (int)calloc(1u, 0x40u);
  if ( sub_30B10(dword_80754, &attr, (void *(*)(void *))sub_2600C, (void *)dword_80754) )
  {
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      strcpy(v3, "create thread failed\n");
      sub_2E584(3, v3, v0);
    }
    return -1;
  }
  else
  {
    pthread_detach(*(_DWORD *)(dword_80754 + 12));
    if ( (unsigned int)dword_7EB9C <= 3 )
      return 0;
    strcpy(v3, "create thread\n");
    sub_2E584(3, v3, 0);
    return 0;
  }
}
// 7EB9C: using guessed type int dword_7EB9C;
// 80754: using guessed type int dword_80754;

//----- (00027B70) --------------------------------------------------------
int sub_27B70()
{
  int v0; // r6
  pthread_attr_t attr; // [sp+4h] [bp-834h] BYREF
  char v3[2064]; // [sp+28h] [bp-810h] BYREF

  v0 = dword_80758;
  if ( dword_80758 )
    return 0;
  pthread_attr_init(&attr);
  pthread_attr_setstacksize(&attr, 0x200000u);
  dword_80758 = (int)calloc(1u, 0x40u);
  if ( sub_30B10(dword_80758, &attr, (void *(*)(void *))sub_2647C, (void *)dword_80758) )
  {
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      strcpy(v3, "create thread failed\n");
      sub_2E584(3, v3, v0);
    }
    return -1;
  }
  else
  {
    pthread_detach(*(_DWORD *)(dword_80758 + 12));
    if ( (unsigned int)dword_7EB9C <= 3 )
      return 0;
    strcpy(v3, "create thread\n");
    sub_2E584(3, v3, 0);
    return 0;
  }
}
// 7EB9C: using guessed type int dword_7EB9C;
// 80758: using guessed type int dword_80758;

//----- (00027C88) --------------------------------------------------------
int sub_27C88()
{
  int v0; // r6
  pthread_attr_t attr; // [sp+4h] [bp-834h] BYREF
  char v3[2064]; // [sp+28h] [bp-810h] BYREF

  v0 = dword_8075C;
  if ( dword_8075C )
    return 0;
  pthread_attr_init(&attr);
  pthread_attr_setstacksize(&attr, 0x200000u);
  dword_8075C = (int)calloc(1u, 0x40u);
  if ( sub_30B10(dword_8075C, &attr, (void *(*)(void *))sub_26B80, (void *)dword_8075C) )
  {
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      strcpy(v3, "create thread failed\n");
      sub_2E584(3, v3, v0);
    }
    return -1;
  }
  else
  {
    pthread_detach(*(_DWORD *)(dword_8075C + 12));
    if ( (unsigned int)dword_7EB9C <= 3 )
      return 0;
    strcpy(v3, "create thread\n");
    sub_2E584(3, v3, 0);
    return 0;
  }
}
// 7EB9C: using guessed type int dword_7EB9C;
// 8075C: using guessed type int dword_8075C;

//----- (00027DA0) --------------------------------------------------------
int sub_27DA0()
{
  int v0; // r6
  pthread_attr_t attr; // [sp+4h] [bp-834h] BYREF
  char v3[2064]; // [sp+28h] [bp-810h] BYREF

  v0 = dword_80760;
  if ( dword_80760 )
    return 0;
  pthread_attr_init(&attr);
  pthread_attr_setstacksize(&attr, 0x200000u);
  dword_80760 = (int)calloc(1u, 0x40u);
  if ( sub_30B10(dword_80760, &attr, (void *(*)(void *))sub_271E8, (void *)dword_80760) )
  {
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      strcpy(v3, "create thread failed\n");
      sub_2E584(3, v3, v0);
    }
    return -1;
  }
  else
  {
    pthread_detach(*(_DWORD *)(dword_80760 + 12));
    if ( (unsigned int)dword_7EB9C <= 3 )
      return 0;
    strcpy(v3, "create thread\n");
    sub_2E584(3, v3, 0);
    return 0;
  }
}
// 7EB9C: using guessed type int dword_7EB9C;
// 80760: using guessed type int dword_80760;

//----- (00027EB8) --------------------------------------------------------
void sub_27EB8()
{
  int v0; // r5
  char v1[2064]; // [sp+0h] [bp-810h] BYREF

  v0 = dword_80750;
  if ( dword_80750 && *(_DWORD *)(v0 + 12) != pthread_self() )
  {
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      strcpy(v1, "cancel thread\n");
      sub_2E584(3, v1, 0);
      v0 = dword_80750;
    }
    sub_2FE84(v0);
    free((void *)dword_80750);
    dword_80750 = 0;
  }
}
// 7EB9C: using guessed type int dword_7EB9C;
// 80750: using guessed type int dword_80750;

//----- (00027F58) --------------------------------------------------------
void sub_27F58()
{
  int v0; // r5
  char v1[2064]; // [sp+0h] [bp-810h] BYREF

  v0 = dword_80754;
  if ( dword_80754 && *(_DWORD *)(v0 + 12) != pthread_self() )
  {
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      strcpy(v1, "cancel thread\n");
      sub_2E584(3, v1, 0);
      v0 = dword_80754;
    }
    sub_2FE84(v0);
    free((void *)dword_80754);
    dword_80754 = 0;
  }
}
// 7EB9C: using guessed type int dword_7EB9C;
// 80754: using guessed type int dword_80754;

//----- (00027FF8) --------------------------------------------------------
void sub_27FF8()
{
  int v0; // r5
  char v1[2064]; // [sp+0h] [bp-810h] BYREF

  v0 = dword_80758;
  if ( dword_80758 && *(_DWORD *)(v0 + 12) != pthread_self() )
  {
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      strcpy(v1, "cancel thread\n");
      sub_2E584(3, v1, 0);
      v0 = dword_80758;
    }
    sub_2FE84(v0);
    free((void *)dword_80758);
    dword_80758 = 0;
  }
}
// 7EB9C: using guessed type int dword_7EB9C;
// 80758: using guessed type int dword_80758;

//----- (00028098) --------------------------------------------------------
void sub_28098()
{
  int v0; // r5
  char v1[2064]; // [sp+0h] [bp-810h] BYREF

  v0 = dword_8075C;
  if ( dword_8075C && *(_DWORD *)(v0 + 12) != pthread_self() )
  {
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      strcpy(v1, "cancel thread\n");
      sub_2E584(3, v1, 0);
      v0 = dword_8075C;
    }
    sub_2FE84(v0);
    free((void *)dword_8075C);
    dword_8075C = 0;
  }
}
// 7EB9C: using guessed type int dword_7EB9C;
// 8075C: using guessed type int dword_8075C;

//----- (00028138) --------------------------------------------------------
int __fastcall sub_28138(signed int a1)
{
  char v3[2056]; // [sp+0h] [bp-808h] BYREF

  if ( a1 > (int)&unk_2DC6C0 )
  {
    sub_1EB74();
    sub_304D4();
  }
  if ( (unsigned int)dword_7EB9C > 3 )
  {
    snprintf(v3, 0x800u, "set UART baud to %d\n", a1);
    sub_2E584(3, v3, 0);
  }
  sub_1E9CC(a1);
  sub_1E160();
  return sub_14F20();
}
// 7EB9C: using guessed type int dword_7EB9C;

//----- (000281B8) --------------------------------------------------------
int sub_281B8()
{
  sub_28138(12000000);
  return sub_304D4();
}

//----- (000281D4) --------------------------------------------------------
int __fastcall sub_281D4(const void *a1, size_t a2)
{
  int v3; // [sp+Ch] [bp-Ch] BYREF

  return sub_52BF0((int)aBitmainSubmitN, a1, a2, &v3);
}

//----- (00028208) --------------------------------------------------------
int __fastcall sub_28208(const void *a1, size_t a2)
{
  int v3; // [sp+Ch] [bp-Ch] BYREF

  return sub_52BF0((int)aBitmainApiStat, a1, a2, &v3);
}

//----- (0002823C) --------------------------------------------------------
int sub_2823C()
{
  puts("bmminer_socket_init");
  while ( sub_5261C((int)&off_7E3F8, 4) )
    sleep(3u);
  puts("regist ..");
  while ( 1 )
  {
    sub_52930((int)aBitmainSubmitN);
    if ( !sub_52930((int)aBitmainApiStat) )
      break;
    sleep(3u);
  }
  puts("regist done!");
  return 0;
}
// 7E3F8: using guessed type int (*off_7E3F8)();

//----- (000282C8) --------------------------------------------------------
int __fastcall sub_282C8(_BYTE *a1)
{
  *a1 = 1;
  byte_482A5C = 1;
  return 0;
}
// 482A5C: using guessed type char byte_482A5C;

//----- (000282E4) --------------------------------------------------------
void __noreturn sub_282E4(const char *a1, ...)
{
  va_list varg_r1; // [sp+14h] [bp-Ch] BYREF

  va_start(varg_r1, a1);
  vsnprintf(byte_80768, 0x200u, a1, varg_r1);
  sub_2E584(3, byte_80768, 1);
  exit(1);
}

//----- (0002832C) --------------------------------------------------------
int __fastcall sub_2832C(int a1)
{
  sub_3D3D4(a1, &dword_80968);
  return 0;
}
// 80968: using guessed type int dword_80968;

//----- (00028344) --------------------------------------------------------
int __fastcall sub_28344(int a1)
{
  sub_3D3D4(a1, &dword_8096C);
  return 0;
}
// 8096C: using guessed type int dword_8096C;

//----- (0002835C) --------------------------------------------------------
int __fastcall sub_2835C(int a1)
{
  sub_3D3D4(a1, &dword_80970);
  return 0;
}
// 80970: using guessed type int dword_80970;

//----- (00028374) --------------------------------------------------------
int __fastcall sub_28374(int a1)
{
  sub_3D3D4(a1, &dword_58E3F0);
  return 0;
}
// 58E3F0: using guessed type int dword_58E3F0;

//----- (0002838C) --------------------------------------------------------
void __fastcall __noreturn sub_2838C(const char *a1)
{
  char *v2; // r0

  printf("%s\nBuilt with bitmain_c5 mining support.\n", byte_80974);
  v2 = sub_3E370((const char *)dword_99EE20, a1);
  printf("%s", v2);
  fflush((FILE *)stdout);
  exit(0);
}
// 7F79C: using guessed type int stdout;
// 99EE20: using guessed type int dword_99EE20;

//----- (000283E4) --------------------------------------------------------
int sub_283E4()
{
  int v0; // r4
  char *v1; // r0
  _DWORD *v2; // r8
  __int64 v3; // r4
  _DWORD *v4; // r10
  const char *v5; // r0
  char *v6; // r4
  size_t v7; // r0
  size_t v8; // r0
  unsigned int *v9; // r3
  unsigned int v10; // r2
  unsigned int v11; // r2
  _DWORD *v13; // r7
  _DWORD *v14; // r0
  struct sysinfo v15; // [sp+18h] [bp-868h] BYREF
  char s[2088]; // [sp+58h] [bp-828h] BYREF

  prctl(15, "api", 0);
  while ( !*(_BYTE *)(dword_58E354 + 364) )
  {
    pthread_mutex_lock(&stru_80A74);
    pthread_cond_wait(&cond, &stru_80A74);
    if ( sysinfo(&v15) )
    {
      if ( byte_590404 || byte_482A5C || dword_7EBA0 > 5 )
      {
        v0 = *_errno_location();
        v1 = strerror(v0);
        snprintf(s, 0x800u, "Failed to get sysinfo, errno:%u, reason:%s\n", v0, v1);
        sub_2E584(6, s, 0);
      }
      dword_5903F8 = time(0);
    }
    else
    {
      dword_5903F8 = v15.uptime;
    }
    v2 = sub_4E1B0();
    sub_1F340((int)v2);
    v3 = 0LL;
    sub_1F3E8((int)v2);
    sub_1F490((int)v2);
    sub_1F574((int)v2);
    sub_1F6AC((int)v2);
    sub_1F7C4((int)v2);
    sub_1F8B0((int)v2);
    sub_1F984((int)v2);
    sub_1FA2C((int)v2);
    v4 = sub_4E540();
    do
    {
      if ( sub_1E29C(v3) )
      {
        v13 = sub_4E1B0();
        if ( byte_482A5D && (byte_590404 || byte_482A5C || dword_7EBA0 > 6) )
        {
          snprintf(s, 0x800u, "%s: now i = %d", "bitmain_update_api_stats", (_DWORD)v3);
          sub_2E584(7, s, 0);
        }
        v14 = (_DWORD *)sub_4E990(v3);
        sub_4EFD4(v13, "index", v14);
        sub_1FB14((int)v13, v3);
        sub_1FBD8((int)v13, v3);
        sub_1FCD0((int)v13, v3);
        sub_1FDD8((int)v13, v3);
        sub_1FE9C(v13, v3);
        sub_1FF90((int)v13, v3);
        sub_20234((int)v13, v3);
        sub_200D0((int)v13, v3);
        sub_20528((int)v13, v3);
        sub_20398((int)v13, v3);
        sub_205EC((int)v13, v3);
        sub_206B4((int)v13, v3);
        sub_20788(v13, v3);
        sub_20880(v13, v3);
        sub_208CC(v13, v3);
        sub_20918(v13, v3);
        sub_20964(v13, v3);
        sub_209BC(v13, v3);
        sub_4F494(v4, v13);
      }
      ++v3;
    }
    while ( v3 != 4 );
    sub_4EFD4(v2, "chain", v4);
    sub_20AD4((int)v2);
    sub_20B7C((int)v2);
    sub_20C28((int)v2);
    sub_20A50(v2);
    v5 = sub_4B1A8(v2, 0);
    v6 = (char *)v5;
    if ( v5 )
    {
      if ( byte_482A5D && (byte_590404 || byte_482A5C || dword_7EBA0 > 6) )
      {
        v7 = strlen(v5);
        snprintf(s, 0x800u, "%s(%d) : %s", "bitmain_update_api_stats", v7 + 1, v6);
        sub_2E584(7, s, 0);
      }
      v8 = strlen(v6);
      sub_28208(v6, v8 + 1);
      free(v6);
    }
    if ( v2 )
    {
      if ( v2[1] != -1 )
      {
        v9 = v2 + 1;
        __dmb(0xBu);
        do
        {
          v10 = __ldrex(v9);
          v11 = v10 - 1;
        }
        while ( __strex(v11, v9) );
        if ( !v11 )
          sub_4EB6C(v2);
      }
    }
    pthread_mutex_unlock(&stru_80A74);
  }
  return 0;
}
// 7EBA0: using guessed type int dword_7EBA0;
// 482A5C: using guessed type char byte_482A5C;
// 482A5D: using guessed type char byte_482A5D;
// 58E354: using guessed type int dword_58E354;
// 5903F8: using guessed type int dword_5903F8;
// 590404: using guessed type char byte_590404;

//----- (00028878) --------------------------------------------------------
void __noreturn sub_28878()
{
  sigaction(15, (const struct sigaction *)&unk_592464, 0);
  sigaction(2, (const struct sigaction *)&unk_594524, 0);
  sigaction(6, (const struct sigaction *)&unk_58E35C, 0);
  sub_31CAC();
  exit(0);
}

//----- (000288C4) --------------------------------------------------------
char *__fastcall sub_288C4(char *a1)
{
  bool v2; // nf
  _DWORD *v4; // r0
  size_t v5; // r6
  size_t v6; // r6
  char *v7; // r4
  char v8[92]; // [sp+Ch] [bp-114h] BYREF
  char v9[184]; // [sp+68h] [bp-B8h] BYREF

  if ( !dword_80AC0 )
    dword_80AC0 = (int)_strdup(a1);
  v2 = dword_80AC4 - 9 < 0;
  ++dword_80AC4;
  if ( !(v2 ^ __OFSUB__(dword_80AC4, 10) | (dword_80AC4 == 10)) )
    return "Too many levels of JSON includes (limit 10) or a loop";
  v4 = sub_4D6E4(a1, 0, v8);
  if ( v4 && !*v4 )
    return sub_289B8(v4, 1);
  v5 = strlen(a1);
  v6 = v5 + strlen(v9) + 35;
  v7 = (char *)sub_2F408(v6, "bmminer.c", "load_config", 902);
  snprintf(v7, v6, "JSON decode of file '%s' failed\n %s", a1, v9);
  return v7;
}
// 80AC0: using guessed type int dword_80AC0;
// 80AC4: using guessed type int dword_80AC4;
// 288C4: using guessed type char var_114[92];

//----- (000289B8) --------------------------------------------------------
char *__fastcall sub_289B8(_DWORD *a1, int a2)
{
  char **v3; // r4
  char *v4; // r3
  const char *v5; // r0
  char *v6; // r10
  char *v7; // r5
  _DWORD *v8; // r0
  int v9; // r1
  int v10; // r3
  const char *v11; // r3
  _DWORD *v12; // r0
  _DWORD *v13; // r0
  _BYTE *v15; // r0
  int v16; // r0
  _DWORD *v17; // r10
  unsigned int v18; // r5
  _DWORD *v19; // r0
  int v20; // r0
  _DWORD *v22; // [sp+10h] [bp-838h]
  char *v23; // [sp+10h] [bp-838h]
  const char *v24; // [sp+14h] [bp-834h]
  char *v25; // [sp+14h] [bp-834h]
  _DWORD *v26; // [sp+18h] [bp-830h]
  const char *v27; // [sp+1Ch] [bp-82Ch]
  char s[2088]; // [sp+20h] [bp-828h] BYREF

  if ( a2 && !dword_80B90 )
    dword_80B90 = 1;
  if ( dword_7E61C == 16 )
    goto LABEL_28;
  if ( (dword_7E61C & 8) != 0 )
LABEL_53:
    _assert_fail("!(opt->type & OPT_SUBTABLE)", "bmminer.c", 0x2DEu, "parse_config");
  v3 = &off_7E634;
  while ( 1 )
  {
    v5 = *(v3 - 7);
    if ( !v5 )
    {
      v4 = v3[1];
      if ( v4 == (char *)16 )
        break;
      goto LABEL_8;
    }
    v6 = _strdup(v5);
    v7 = strtok(v6, "|");
    if ( !v7 )
      goto LABEL_27;
    while ( 2 )
    {
      if ( v7[1] != 45 )
        goto LABEL_12;
      v8 = (_DWORD *)sub_4E234(a1, v7 + 2);
      if ( !v8 )
        goto LABEL_12;
      v9 = (int)*(v3 - 6);
      v10 = *v8;
      if ( (v9 & 6) == 0 )
      {
LABEL_18:
        if ( (unsigned int)(v10 - 5) > 1 )
        {
          v11 = "Invalid value";
          goto LABEL_21;
        }
        v15 = *(v3 - 2);
        if ( (v9 & 1) == 0 )
        {
          if ( v10 == 5 )
            sub_3D2F0(v15);
          else
            sub_3D300(v15);
          goto LABEL_12;
        }
        v11 = (const char *)((int (__fastcall *)(_BYTE *))*(v3 - 5))(v15);
        goto LABEL_33;
      }
      if ( v10 == 2 )
      {
        v22 = sub_4E768(v8);
        v16 = ((int (__fastcall *)(_DWORD *, _DWORD))*(v3 - 4))(v22, *(v3 - 2));
        v11 = (const char *)v16;
        if ( *(v3 - 6) == (char *)4 )
        {
          v24 = (const char *)v16;
          sub_3D3D4((int)v22, *(v3 - 2));
          v11 = v24;
        }
LABEL_33:
        if ( !v11 )
          goto LABEL_12;
        if ( a2 )
          goto LABEL_22;
LABEL_35:
        snprintf(::s, 0xC8u, "Parsing JSON option %s: %s", v7, v11);
        return ::s;
      }
      if ( v10 != 1 )
        goto LABEL_18;
      v23 = v6;
      v17 = v8;
      v25 = v7;
      v18 = 0;
      if ( !sub_4E5A0(v8) )
      {
LABEL_46:
        v6 = v23;
        goto LABEL_12;
      }
      while ( 1 )
      {
        v19 = sub_4E5BC(v17, v18);
        if ( !v19 )
          goto LABEL_46;
        if ( *v19 == 2 )
          break;
        if ( !*v19 )
        {
          v11 = (const char *)sub_289B8();
          goto LABEL_49;
        }
LABEL_45:
        if ( (unsigned int)sub_4E5A0(v17) <= ++v18 )
          goto LABEL_46;
      }
      v26 = sub_4E768(v19);
      v20 = ((int (__fastcall *)(_DWORD *, _DWORD))*(v3 - 4))(v26, *(v3 - 2));
      v11 = (const char *)v20;
      if ( *(v3 - 6) == (char *)4 )
      {
        v27 = (const char *)v20;
        sub_3D3D4((int)v26, *(v3 - 2));
        v11 = v27;
      }
LABEL_49:
      if ( !v11 )
        goto LABEL_45;
      v6 = v23;
      v7 = v25;
LABEL_21:
      if ( !a2 )
        goto LABEL_35;
LABEL_22:
      if ( byte_590404 || byte_482A5C || dword_7EBA0 > 2 )
      {
        snprintf(s, 0x800u, "Invalid config option %s: %s", v7, v11);
        sub_2E584(3, s, 0);
      }
      dword_80B90 = -1;
LABEL_12:
      v7 = strtok(0, "|");
      if ( v7 )
        continue;
      break;
    }
LABEL_27:
    free(v6);
    v4 = v3[1];
    if ( v4 == (char *)16 )
      break;
LABEL_8:
    v3 += 7;
    if ( ((unsigned __int8)v4 & 8) != 0 )
      goto LABEL_53;
  }
LABEL_28:
  v12 = (_DWORD *)sub_4E234(a1, "include");
  if ( !v12 || *v12 != 2 )
    return 0;
  v13 = sub_4E768(v12);
  return (char *)sub_288C4(v13, 0);
}
// 288C4: using guessed type int __fastcall sub_288C4(_DWORD, _DWORD);
// 7E61C: using guessed type int dword_7E61C;
// 7E634: using guessed type char *;
// 7EBA0: using guessed type int dword_7EBA0;
// 80B90: using guessed type int dword_80B90;
// 482A5C: using guessed type char byte_482A5C;
// 590404: using guessed type char byte_590404;

//----- (00028D40) --------------------------------------------------------
char *__fastcall sub_28D40(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = sub_3D4F0(a1, a2);
  if ( !result && *a2 > 0x270Fu )
    return "Value out of range";
  return result;
}

//----- (00028D70) --------------------------------------------------------
char *__fastcall sub_28D70(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = sub_3D4F0(a1, a2);
  if ( !result && *a2 > 0x64u )
    return "Value out of range";
  return result;
}

//----- (00028D9C) --------------------------------------------------------
char *__fastcall sub_28D9C(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = sub_3D4F0(a1, a2);
  if ( !result && (unsigned int)(*a2 - 1) > 0xFFFE )
    return "Value out of range";
  return result;
}

//----- (00028DD0) --------------------------------------------------------
int __fastcall sub_28DD0(const char *a1, const char *a2, int a3)
{
  char s[2056]; // [sp+8h] [bp-808h] BYREF

  snprintf(s, 0x800u, "Free work called with NULL work from %s %s:%d", a1, a2, a3);
  return sub_2E584(3, s, 0);
}

//----- (00028E18) --------------------------------------------------------
int __fastcall sub_28E18(const char *a1, int a2)
{
  int *v4; // r0
  char s[2064]; // [sp+10h] [bp-810h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x800u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v4, "bmminer.c", a1, a2);
  return sub_2E584(3, s, 1);
}

//----- (00028E74) --------------------------------------------------------
int __fastcall sub_28E74(pthread_rwlock_t *a1, const char *a2, int a3)
{
  int result; // r0
  int *v6; // r0
  char s[2064]; // [sp+10h] [bp-810h] BYREF

  result = pthread_rwlock_init(a1, 0);
  if ( result )
  {
    v6 = _errno_location();
    snprintf(s, 0x800u, "Failed to pthread_rwlock_init errno=%d in %s %s():%d", *v6, "bmminer.c", a2, a3);
    return sub_2E584(3, s, 1);
  }
  return result;
}

//----- (00028EE8) --------------------------------------------------------
int __fastcall sub_28EE8(pthread_rwlock_t *a1, const char *a2, int a3)
{
  int result; // r0
  int *v6; // r0
  char s[2064]; // [sp+10h] [bp-810h] BYREF

  result = pthread_rwlock_wrlock(a1);
  if ( result )
  {
    v6 = _errno_location();
    snprintf(s, 0x800u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v6, "bmminer.c", a2, a3);
    return sub_2E584(3, s, 1);
  }
  return result;
}

//----- (00028F5C) --------------------------------------------------------
int __fastcall sub_28F5C(const char *a1, int a2)
{
  int *v4; // r0
  char s[2064]; // [sp+10h] [bp-810h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v4, "bmminer.c", a1, a2);
  return sub_2E584(3, s, 1);
}

//----- (00028FB8) --------------------------------------------------------
int __fastcall sub_28FB8(const char *a1, int a2)
{
  int *v4; // r0
  char s[2064]; // [sp+10h] [bp-810h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x800u, "Failed to pthread_mutex_init errno=%d in %s %s():%d", *v4, "bmminer.c", a1, a2);
  return sub_2E584(3, s, 1);
}

//----- (00029014) --------------------------------------------------------
int __fastcall sub_29014(const char *a1, int a2)
{
  int *v4; // r0
  char s[2064]; // [sp+10h] [bp-810h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v4, "bmminer.c", a1, a2);
  return sub_2E584(3, s, 1);
}

//----- (00029070) --------------------------------------------------------
int __fastcall sub_29070(int a1, const char *a2, int a3)
{
  if ( pthread_mutex_init((pthread_mutex_t *)a1, 0) )
    sub_28FB8(a2, a3);
  return sub_28E74((pthread_rwlock_t *)(a1 + 24), a2, a3);
}

//----- (000290B4) --------------------------------------------------------
_DWORD *sub_290B4()
{
  _DWORD *v0; // r4
  int v1; // r5
  int v2; // r0
  _DWORD *result; // r0
  int *v4; // r0
  int *v5; // r0
  int *v6; // r0
  int *v7; // r0
  char s[2064]; // [sp+10h] [bp-810h] BYREF

  v0 = sub_2F490(1u, 0x1C0u, "bmminer.c", "make_work", 1368);
  if ( !v0 )
  {
    strcpy(s, "Failed to calloc work in make_work");
    sub_2E584(3, s, 1);
  }
  if ( pthread_mutex_lock(&stru_590408) )
  {
    v4 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v4, "bmminer.c", "total_work_inc", 1359);
    sub_2E584(3, s, 1);
    if ( !pthread_rwlock_wrlock(&rwlock) )
      goto LABEL_5;
  }
  else if ( !pthread_rwlock_wrlock(&rwlock) )
  {
    goto LABEL_5;
  }
  v5 = _errno_location();
  snprintf(s, 0x800u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v5, "bmminer.c", "total_work_inc", 1359);
  sub_2E584(3, s, 1);
LABEL_5:
  v1 = dword_80B94++;
  if ( pthread_rwlock_unlock(&rwlock) )
  {
    v6 = _errno_location();
    snprintf(s, 0x800u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v6, "bmminer.c", "total_work_inc", 1361);
    sub_2E584(3, s, 1);
  }
  v2 = pthread_mutex_unlock(&stru_590408);
  if ( v2 )
  {
    v7 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v7, "bmminer.c", "total_work_inc", 1361);
    v2 = sub_2E584(3, s, 1);
  }
  off_7ECC4(v2);
  result = v0;
  v0[85] = v1;
  return result;
}
// 7ECC4: using guessed type int (__fastcall *off_7ECC4)(_DWORD);
// 80B94: using guessed type int dword_80B94;
// 590408: using guessed type pthread_mutex_t stru_590408;

//----- (000292E0) --------------------------------------------------------
char *__fastcall sub_292E0(const char *a1, _DWORD *a2, int a3, int a4)
{
  char *result; // r0
  _BOOL4 v8; // r4
  int v9; // r3

  result = sub_3D4F0(a1, a2);
  if ( !result )
  {
    v8 = *a2 < a3;
    if ( *a2 > a4 )
      v9 = v8 | 1;
    else
      v9 = v8;
    if ( v9 )
      return "Value out of range";
  }
  return result;
}

//----- (0002932C) --------------------------------------------------------
int __fastcall sub_2932C(const char *a1, _DWORD *a2, _DWORD *a3)
{
  int result; // r0

  result = sscanf(a1, "%d-%d", a2, a3);
  if ( result == 1 )
    *a3 = *a2;
  return result;
}

//----- (0002935C) --------------------------------------------------------
char *__fastcall sub_2935C(char *a1)
{
  size_t v2; // r0
  char *v3; // r12
  size_t v4; // lr
  char *result; // r0
  char *v6; // r0

  if ( dword_58E3F0 && *(_BYTE *)dword_58E3F0 )
    return strcpy(a1, (const char *)dword_58E3F0);
  if ( getenv("HOME") && *getenv("HOME") )
  {
    v6 = getenv("HOME");
    strcpy((char *)stpcpy(a1, v6), "/");
  }
  else
  {
    *a1 = 0;
  }
  strcat(a1, ".bmminer/");
  mkdir(a1, 0x1FFu);
  v2 = strlen(a1);
  v3 = &a1[v2];
  v4 = v2;
  result = *(char **)"bmminer.conf";
  *(_DWORD *)&a1[v4] = *(_DWORD *)"bmminer.conf";
  strcpy(v3 + 4, "ner.conf");
  return result;
}
// 1203C: using guessed type int __fastcall stpcpy(_DWORD, _DWORD);
// 58E3F0: using guessed type int dword_58E3F0;

//----- (00029458) --------------------------------------------------------
void sub_29458()
{
  dword_80AC0 = (int)sub_2F408(0x1000u, "bmminer.c", "load_default_config", 950);
  sub_2935C((char *)dword_80AC0);
  if ( access((const char *)dword_80AC0, 4) )
  {
    free((void *)dword_80AC0);
    dword_80AC0 = 0;
  }
  else
  {
    sub_288C4((char *)dword_80AC0);
  }
}
// 80AC0: using guessed type int dword_80AC0;

//----- (000294B8) --------------------------------------------------------
void *__fastcall sub_294B8(void *a1)
{
  double v1; // d0
  __int64 v3; // r0
  __int64 v4; // r6
  double v5; // r0
  double v6; // d8
  __int64 v7; // r0
  int v8; // r10
  int v9; // r11
  double v10; // r0
  double v11; // d8
  __int64 v12; // r0
  int v13; // r8
  int v14; // r9
  double v15; // r0
  unsigned int v16; // r0
  int v17; // r1
  char *v19; // r6
  _DWORD v20[6]; // [sp+8h] [bp-850h] BYREF
  __int64 v21; // [sp+20h] [bp-838h]
  char s[2096]; // [sp+28h] [bp-830h] BYREF

  if ( v1 == 0.0 )
  {
    if ( byte_590404 || byte_482A5C || dword_7EBA0 > 2 )
    {
      v4 = 4294901760LL;
      strcpy(s, "Diff zero passed to set_target");
      sub_2E584(3, s, 0);
      v16 = 0;
      v17 = 0;
      v14 = 0;
      v9 = 0;
      v13 = 0;
      v8 = 0;
    }
    else
    {
      v16 = 0;
      v4 = 4294901760LL;
      v17 = 0;
      v14 = 0;
      v9 = 0;
      v13 = 0;
      v8 = 0;
    }
  }
  else
  {
    LODWORD(v3) = sub_60180(2.69595353e67 / v1 * 1.59309191e-58);
    v4 = v3;
    LODWORD(v5) = sub_600B4(v3);
    v6 = 2.69595353e67 / v1 - v5 * 6.27710174e57;
    LODWORD(v7) = sub_60180(v6 * 2.93873588e-39);
    v8 = HIDWORD(v7);
    v9 = v7;
    LODWORD(v10) = sub_600B4(v7);
    v11 = v6 - v10 * 3.40282367e38;
    LODWORD(v12) = sub_60180(v11 * 5.42101086e-20);
    v13 = HIDWORD(v12);
    v14 = v12;
    LODWORD(v15) = sub_600B4(v12);
    v16 = sub_60180(v11 - v15 * 1.84467441e19);
  }
  v21 = v4;
  v20[4] = v9;
  v20[5] = v8;
  v20[2] = v14;
  v20[3] = v13;
  v20[0] = v16;
  v20[1] = v17;
  if ( byte_482A5D )
  {
    v19 = sub_2F670((int)v20, 32);
    if ( byte_482A5D && (byte_590404 || byte_482A5C || dword_7EBA0 > 6) )
    {
      snprintf(s, 0x800u, "Generated target %s", v19);
      sub_2E584(7, s, 0);
    }
    free(v19);
  }
  return sub_30EA8(a1, v20, 0x20u, (int)"bmminer.c", (int)"set_target", 1124);
}
// 294D4: variable 'v1' is possibly undefined
// 294F0: variable 'v3' is possibly undefined
// 29508: variable 'v5' is possibly undefined
// 2951C: variable 'v7' is possibly undefined
// 29530: variable 'v10' is possibly undefined
// 29544: variable 'v12' is possibly undefined
// 29554: variable 'v15' is possibly undefined
// 29584: variable 'v17' is possibly undefined
// 7EBA0: using guessed type int dword_7EBA0;
// 482A5C: using guessed type char byte_482A5C;
// 482A5D: using guessed type char byte_482A5D;
// 590404: using guessed type char byte_590404;

//----- (0002974C) --------------------------------------------------------
__int64 __fastcall sub_2974C(int a1, int a2)
{
  pthread_mutex_t *v2; // r9
  int v5; // lr
  int v6; // r3
  size_t v7; // r2
  int v8; // r3
  int v9; // r2
  int v10; // r6
  const void *v11; // r1
  char *v12; // r2
  char *v13; // r0
  unsigned int v14; // t1
  int v15; // r0
  int v16; // r1
  char *v17; // r2
  unsigned int v18; // t1
  double v19; // d8
  unsigned __int64 v20; // r0
  int v21; // r6
  char *v22; // r6
  int v23; // r0
  double v24; // d7
  double v25; // d7
  double v26; // d7
  double v28; // r0
  double v29; // d8
  double v30; // r0
  double v31; // d8
  double v32; // r0
  double v33; // d8
  double v34; // r0
  double v35; // d7
  int v36; // r0
  int v37; // r0
  char *v38; // r10
  const char *v39; // r0
  char *v40; // r11
  int v41; // r0
  int *v42; // r0
  int *v43; // r0
  int *v44; // r0
  int *v45; // r0
  int *v46; // r0
  int *v47; // r0
  int v48; // r0
  __int64 v49; // [sp+18h] [bp-8D8h] BYREF
  char v50[28]; // [sp+20h] [bp-8D0h] BYREF
  char v51; // [sp+3Ch] [bp-8B4h] BYREF
  char v52[28]; // [sp+40h] [bp-8B0h] BYREF
  int v53; // [sp+5Ch] [bp-894h] BYREF
  char v54[28]; // [sp+60h] [bp-890h] BYREF
  char v55; // [sp+7Ch] [bp-874h] BYREF
  char v56[60]; // [sp+80h] [bp-870h] BYREF
  int v57; // [sp+BCh] [bp-834h] BYREF
  char s[136]; // [sp+C0h] [bp-830h] BYREF
  int v59; // [sp+148h] [bp-7A8h] BYREF

  v2 = (pthread_mutex_t *)(a1 + 212);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 212)) )
  {
    v42 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v42, "bmminer.c", "gen_stratum_work", 1268);
    sub_2E584(3, s, 1);
  }
  if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 236)) )
  {
    v43 = _errno_location();
    snprintf(s, 0x800u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v43, "bmminer.c", "gen_stratum_work", 1268);
    sub_2E584(3, s, 1);
  }
  v5 = *(_DWORD *)(a1 + 1568);
  v6 = *(_DWORD *)(a1 + 1576);
  v7 = *(_DWORD *)(a1 + 632);
  v49 = *(_QWORD *)(a1 + 624);
  sub_30EA8((void *)(v5 + v6), &v49, v7, (int)"bmminer.c", (int)"gen_stratum_work", 1273);
  v8 = *(_DWORD *)(a1 + 624);
  v9 = *(_DWORD *)(a1 + 628);
  *(_DWORD *)(a1 + 624) = v8 + 1;
  *(_DWORD *)(a1 + 628) = __CFADD__(v8, 1) + v9;
  *(_DWORD *)(a2 + 296) = v8;
  *(_DWORD *)(a2 + 300) = v9;
  *(_DWORD *)(a2 + 304) = *(_DWORD *)(a1 + 632);
  if ( !pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 236)) )
  {
    if ( !pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 236)) )
      goto LABEL_7;
LABEL_62:
    v45 = _errno_location();
    snprintf(s, 0x800u, "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v45, "bmminer.c", "gen_stratum_work", 1279);
    sub_2E584(3, s, 1);
    if ( !pthread_mutex_unlock(v2) )
      goto LABEL_8;
    goto LABEL_63;
  }
  v44 = _errno_location();
  snprintf(s, 0x800u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v44, "bmminer.c", "gen_stratum_work", 1279);
  sub_2E584(3, s, 1);
  if ( pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 236)) )
    goto LABEL_62;
LABEL_7:
  if ( !pthread_mutex_unlock(v2) )
    goto LABEL_8;
LABEL_63:
  v46 = _errno_location();
  snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v46, "bmminer.c", "gen_stratum_work", 1279);
  sub_2E584(3, s, 1);
LABEL_8:
  sub_2F1EC(*(char **)(a1 + 1568), *(_DWORD *)(a1 + 1572), s);
  sub_2F1EC(s, 0x20u, v50);
  sub_30EA8(v52, v50, 0x20u, (int)"bmminer.c", (int)"gen_stratum_work", 1283);
  if ( *(int *)(a1 + 1708) > 0 )
  {
    v10 = 0;
    do
    {
      v11 = *(const void **)(*(_DWORD *)(a1 + 676) + 4 * v10++);
      sub_30EA8(v54, v11, 0x20u, (int)"bmminer.c", (int)"gen_stratum_work", 1287);
      sub_2F1EC(v52, 0x40u, s);
      sub_2F1EC(s, 0x20u, v50);
      sub_30EA8(v52, v50, 0x20u, (int)"bmminer.c", (int)"gen_stratum_work", 1289);
    }
    while ( *(_DWORD *)(a1 + 1708) > v10 );
  }
  v12 = &v51;
  v13 = (char *)&v49 + 4;
  do
  {
    v14 = *((_DWORD *)v12 + 1);
    v12 += 4;
    *((_DWORD *)v13 + 1) = bswap32(v14);
    v13 += 4;
  }
  while ( &v53 != (int *)v12 );
  sub_30EA8((void *)a2, (const void *)(a1 + 1580), 0x70u, (int)"bmminer.c", (int)"gen_stratum_work", 1298);
  sub_30EA8((void *)(a2 + 36), v50, 0x20u, (int)"bmminer.c", (int)"gen_stratum_work", 1299);
  *(_QWORD *)(a2 + 312) = *(_QWORD *)(a1 + 1824);
  *(_DWORD *)(a2 + 288) = _strdup(*(const char **)(a1 + 672));
  *(_DWORD *)(a2 + 320) = _strdup(*(const char **)(a1 + 612));
  *(_DWORD *)(a2 + 308) = _strdup((const char *)(a1 + 1804));
  v15 = pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 236));
  if ( v15 )
  {
    v47 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v47,
      "bmminer.c",
      "gen_stratum_work",
      1310);
    v15 = sub_2E584(3, s, 1);
  }
  off_7ECC4(v15);
  if ( byte_482A5D )
  {
    v38 = sub_2F670(a2, 112);
    v39 = sub_2F670((int)v50, 32);
    v40 = (char *)v39;
    if ( byte_482A5D )
    {
      if ( !byte_590404 && !byte_482A5C && dword_7EBA0 <= 6 )
        goto LABEL_52;
      snprintf(s, 0x800u, "Generated stratum merkle %s", v39);
      sub_2E584(7, s, 0);
      if ( !byte_482A5D )
        goto LABEL_58;
      if ( !byte_590404 )
      {
LABEL_52:
        if ( !byte_482A5C && dword_7EBA0 <= 6 )
          goto LABEL_55;
      }
      snprintf(s, 0x800u, "Generated stratum header %s", v38);
      sub_2E584(7, s, 0);
      if ( byte_482A5D )
      {
        if ( byte_590404 )
        {
LABEL_57:
          snprintf(
            s,
            0x800u,
            "Work job_id %s nonce2 %llu ntime %s",
            *(const char **)(a2 + 288),
            *(_QWORD *)(a2 + 296),
            *(const char **)(a2 + 308));
          sub_2E584(7, s, 0);
          goto LABEL_58;
        }
LABEL_55:
        if ( !byte_482A5C && dword_7EBA0 <= 6 )
          goto LABEL_58;
        goto LABEL_57;
      }
    }
LABEL_58:
    free(v38);
    free(v40);
  }
  v16 = a2 - 4;
  v17 = &v55;
  do
  {
    v18 = *(_DWORD *)(v16 + 4);
    v16 += 4;
    *((_DWORD *)v17 + 1) = bswap32(v18);
    v17 += 4;
  }
  while ( &v57 != (int *)v17 );
  sub_2F024(s);
  sub_2F054((unsigned __int8 *)s, v56, 0x40u);
  sub_30EA8((void *)(a2 + 128), &v59, 0x20u, (int)"bmminer.c", (int)"calc_midstate", 1029);
  sub_294B8((void *)(a2 + 160));
  ++dword_5945B4;
  if ( time(0) - dword_80B98 > 5 )
  {
    dword_80B98 = time(0);
    dword_80B9C = dword_5945B4;
  }
  v19 = *(double *)(a2 + 312);
  *(_BYTE *)(a2 + 284) = 1;
  *(_DWORD *)(a2 + 260) = a1;
  *(_DWORD *)(a2 + 248) = 0;
  *(_BYTE *)(a2 + 280) = 0;
  *(_DWORD *)(a2 + 336) = 0;
  *(_BYTE *)(a2 + 440) = 83;
  *(_DWORD *)(a2 + 244) = 60;
  if ( v19 == 0.0 )
  {
    LODWORD(v28) = sub_600B4(*(_QWORD *)(a2 + 184));
    v29 = v28 * 6.27710174e57;
    LODWORD(v30) = sub_600B4(*(_QWORD *)(a2 + 176));
    v31 = v29 + v30 * 3.40282367e38;
    LODWORD(v32) = sub_600B4(*(_QWORD *)(a2 + 168));
    v33 = v31 + v32 * 1.84467441e19;
    LODWORD(v34) = sub_600B4(*(_QWORD *)(a2 + 160));
    v35 = v34 + v33;
    if ( v34 + v33 == 0.0 )
    {
      v19 = 2.69595353e67;
      v20 = -1LL;
    }
    else
    {
      v19 = 2.69595353e67 / v35;
      round();
      LODWORD(v20) = sub_60180(2.69595353e67 / v35);
    }
    *(double *)(a2 + 376) = v19;
  }
  else
  {
    *(double *)(a2 + 376) = v19;
    round();
    LODWORD(v20) = sub_60180(v19);
  }
  *(double *)(a1 + 480) = v19;
  v21 = *(_DWORD *)(a2 + 260);
  *(_WORD *)s = 0;
  v22 = (char *)(v21 + 48);
  if ( v20 > 0xDE0B6B3A763FFFFLL )
  {
    v23 = sub_60120(v20, 0x38D7EA4C68000uLL);
    strcpy(s, "E");
    v24 = (double)v23 / 1000.0;
LABEL_24:
    snprintf(v22, 8u, "%.3g%s", v24, s);
    goto LABEL_25;
  }
  if ( v20 > 0x38D7EA4C67FFFLL )
  {
    v36 = sub_60120(v20, 0xE8D4A51000uLL);
    strcpy(s, "P");
    v24 = (double)v36 / 1000.0;
    goto LABEL_24;
  }
  if ( v20 > 0xE8D4A50FFFLL )
  {
    v41 = sub_60120(v20, 0x3B9ACA00uLL);
    strcpy(s, "T");
    v24 = (double)v41 / 1000.0;
    goto LABEL_24;
  }
  if ( v20 > 0x3B9AC9FF )
  {
    v37 = sub_60120(v20, (unsigned int)&unk_F4240);
    strcpy(s, "G");
    v24 = (double)v37 / 1000.0;
    goto LABEL_24;
  }
  if ( v20 > 0xF423F )
  {
    v48 = sub_60120(v20, 0x3E8uLL);
    strcpy(s, "M");
    v24 = (double)v48 / 1000.0;
    goto LABEL_24;
  }
  if ( v20 > 0x3E7 )
  {
    strcpy(s, "K");
    v24 = (double)(int)v20 / 1000.0;
    goto LABEL_24;
  }
  snprintf(v22, 8u, "%d%s", (_DWORD)v20, s);
LABEL_25:
  v25 = *(double *)(a1 + 464);
  if ( v25 == v19 )
  {
    ++*(_DWORD *)(a1 + 488);
    goto LABEL_27;
  }
  if ( v25 <= v19 )
  {
    if ( v25 != 0.0 )
    {
LABEL_27:
      v26 = *(double *)(a1 + 472);
      if ( v26 != v19 )
        goto LABEL_28;
LABEL_37:
      ++*(_DWORD *)(a1 + 492);
      return sub_302A0((__time_t *)(a2 + 264));
    }
    *(double *)(a1 + 464) = v19;
    *(_DWORD *)(a1 + 488) = 1;
  }
  else
  {
    *(double *)(a1 + 464) = v19;
    *(_DWORD *)(a1 + 488) = 1;
  }
  v26 = *(double *)(a1 + 472);
  if ( v26 == v19 )
    goto LABEL_37;
LABEL_28:
  if ( v26 < v19 )
  {
    *(double *)(a1 + 472) = v19;
    *(_DWORD *)(a1 + 492) = 1;
  }
  return sub_302A0((__time_t *)(a2 + 264));
}
// 29B10: variable 'v20' is possibly undefined
// 29BC0: variable 'v28' is possibly undefined
// 29BD4: variable 'v30' is possibly undefined
// 29BE8: variable 'v32' is possibly undefined
// 29BF4: variable 'v34' is possibly undefined
// 12294: using guessed type int round(void);
// 7EBA0: using guessed type int dword_7EBA0;
// 7ECC4: using guessed type int (__fastcall *off_7ECC4)(_DWORD);
// 80B98: using guessed type int dword_80B98;
// 80B9C: using guessed type int dword_80B9C;
// 482A5C: using guessed type char byte_482A5C;
// 482A5D: using guessed type char byte_482A5D;
// 590404: using guessed type char byte_590404;
// 5945B4: using guessed type int dword_5945B4;
// 2974C: using guessed type char var_890[28];
// 2974C: using guessed type char var_870[60];

//----- (0002A1A4) --------------------------------------------------------
void *__fastcall sub_2A1A4(void **a1)
{
  free(a1[72]);
  free(a1[77]);
  free(a1[82]);
  free(a1[80]);
  return memset(a1, 0, 0x1C0u);
}

//----- (0002A1E0) --------------------------------------------------------
void __fastcall sub_2A1E0(void ***a1, const char *a2, const char *a3, int a4)
{
  void **v4; // r5

  v4 = *a1;
  if ( *a1 )
  {
    sub_2A1A4(*a1);
    free(v4);
    *a1 = 0;
  }
  else if ( byte_590404 || byte_482A5C || dword_7EBA0 > 2 )
  {
    sub_28DD0(a2, a3, a4);
  }
}
// 7EBA0: using guessed type int dword_7EBA0;
// 482A5C: using guessed type char byte_482A5C;
// 590404: using guessed type char byte_590404;

//----- (0002A264) --------------------------------------------------------
int __fastcall sub_2A264(int *a1, int *a2, int a3, int a4, __int64 a5, unsigned int a6)
{
  pthread_mutex_t *v7; // r7
  int v10; // r9
  unsigned int v11; // r2
  int v12; // r0
  int result; // r0
  unsigned int v14; // r1

  v7 = (pthread_mutex_t *)(a3 + 212);
  *a2 = (int)sub_290B4();
  v10 = *a1;
  if ( pthread_mutex_lock(v7) )
    sub_29014("get_work_by_nonce2", 1423);
  sub_28EE8((pthread_rwlock_t *)(a3 + 236), "get_work_by_nonce2", 1423);
  v11 = bswap32(a6);
  *(_QWORD *)(a3 + 624) = a5;
  a6 = v11;
  sub_30EA8((void *)(a3 + 1580), &a6, 4u, (int)"bmminer.c", (int)"get_work_by_nonce2", 1426);
  if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a3 + 236)) )
  {
    sub_28E18("get_work_by_nonce2", 1427);
    v12 = pthread_mutex_unlock(v7);
    if ( !v12 )
      goto LABEL_5;
LABEL_7:
    v12 = sub_28F5C("get_work_by_nonce2", 1427);
    goto LABEL_5;
  }
  v12 = pthread_mutex_unlock(v7);
  if ( v12 )
    goto LABEL_7;
LABEL_5:
  off_7ECC4(v12);
  sub_2974C(a3, *a2);
  result = 1;
  v14 = a6;
  *(_DWORD *)(*a2 + 260) = a4;
  *(_DWORD *)(*a2 + 256) = v10;
  *(_DWORD *)(*a2 + 336) = 0;
  ++*(_DWORD *)(*(_DWORD *)(*a2 + 260) + 68);
  *(_BYTE *)(*a2 + 272) = 1;
  *(_DWORD *)(*a2 + 444) = v14;
  return result;
}
// 7ECC4: using guessed type int (__fastcall *off_7ECC4)(_DWORD);

//----- (0002A3C4) --------------------------------------------------------
int __fastcall sub_2A3C4(int a1)
{
  int v2; // r12
  int v3; // r2
  int v4; // r0
  int result; // r0
  int (__fastcall *v6)(int); // r3
  int *v7; // r0
  int *v8; // r0
  char s[2056]; // [sp+10h] [bp-808h] BYREF

  if ( byte_482A5D && (byte_590404 || byte_482A5C || dword_7EBA0 > 6) )
  {
    snprintf(
      s,
      0x800u,
      "%s %d: invalid nonce - HW error",
      *(const char **)(*(_DWORD *)(*(_DWORD *)(a1 + 36) + 4) + 8),
      *(_DWORD *)(*(_DWORD *)(a1 + 36) + 8));
    sub_2E584(7, s, 0);
  }
  if ( pthread_mutex_lock(&stru_5944F4) )
  {
    v7 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v7, "bmminer.c", "inc_hw_errors", 1446);
    sub_2E584(3, s, 1);
  }
  v2 = *(_DWORD *)(a1 + 36);
  v3 = *(_DWORD *)(v2 + 44) + 1;
  ++dword_58E348;
  *(_DWORD *)(v2 + 44) = v3;
  v4 = pthread_mutex_unlock(&stru_5944F4);
  if ( v4 )
  {
    v8 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v8, "bmminer.c", "inc_hw_errors", 1449);
    v4 = sub_2E584(3, s, 1);
  }
  result = off_7ECC4(v4);
  v6 = *(int (__fastcall **)(int))(*(_DWORD *)(*(_DWORD *)(a1 + 36) + 4) + 84);
  if ( v6 )
    return v6(a1);
  return result;
}
// 7EBA0: using guessed type int dword_7EBA0;
// 7ECC4: using guessed type int (__fastcall *off_7ECC4)(_DWORD);
// 482A5C: using guessed type char byte_482A5C;
// 482A5D: using guessed type char byte_482A5D;
// 58E348: using guessed type int dword_58E348;
// 590404: using guessed type char byte_590404;
// 5944F4: using guessed type pthread_mutex_t stru_5944F4;

//----- (0002A578) --------------------------------------------------------
int sub_2A578()
{
  int result; // r0
  int v1; // r4
  char *v2; // r0
  struct sysinfo v3; // [sp+0h] [bp-948h] BYREF
  char s[256]; // [sp+40h] [bp-908h] BYREF
  char v5[2056]; // [sp+140h] [bp-808h] BYREF

  if ( sysinfo(&v3) )
  {
    v1 = *_errno_location();
    v2 = strerror(v1);
    sprintf(s, "Failed to get sysinfo, errno:%u, reason:%s\n", v1, v2);
    result = time(0);
    dword_58E344 = result;
    dword_5903F8 = result + 1;
  }
  else
  {
    dword_58E344 = v3.uptime;
    dword_5903F8 = v3.uptime + 1;
    result = sprintf(s, "set_start_time_point total_tv_start_sys=%ld total_tv_end_sys=%ld\n", v3.uptime, v3.uptime + 1);
    if ( byte_590404 || byte_482A5C || dword_7EBA0 > 4 )
    {
      snprintf(v5, 0x800u, "%s", s);
      return sub_2E584(5, v5, 0);
    }
  }
  return result;
}
// 7EBA0: using guessed type int dword_7EBA0;
// 482A5C: using guessed type char byte_482A5C;
// 58E344: using guessed type int dword_58E344;
// 5903F8: using guessed type int dword_5903F8;
// 590404: using guessed type char byte_590404;

//----- (0002A688) --------------------------------------------------------
int sub_2A688()
{
  FILE *v0; // r6
  signed int v1; // r0
  char *v2; // r0
  char *v3; // r6
  int v4; // r6
  char *v5; // r0
  size_t v6; // r0
  int v7; // r3
  size_t v8; // r0
  int v9; // r3
  bool v10; // zf
  int v11; // r6
  FILE *v12; // r7
  signed int v13; // r0
  char *v14; // r0
  int v15; // r7
  int result; // r0
  int v17; // r3
  char v18[256]; // [sp+8h] [bp-918h] BYREF
  char s[2072]; // [sp+108h] [bp-818h] BYREF

  v0 = (FILE *)fopen64(dword_80970, "rb");
  memset(v18, 0, sizeof(v18));
  if ( v0 )
  {
    v1 = fread(v18, 1u, 0x100u, v0);
    if ( v1 <= 0 )
    {
      v11 = (int)&byte_590404;
      if ( byte_590404 || byte_482A5C || dword_7EBA0 > 2 )
      {
        snprintf(s, 0x800u, "Read miner version file %s error %d", (const char *)dword_80970, v1);
        sub_2E584(3, s, 0);
      }
    }
    else
    {
      v2 = strchr(v18, 10);
      v3 = v2;
      if ( v2 )
      {
        sub_30EA8(byte_80BA0, v18, v2 - v18, (int)"bmminer.c", (int)"read_version_file", 1515);
        v4 = stpcpy(v18, v3 + 1);
        v5 = strchr(v18, 10);
        if ( v5 )
          sub_30EA8(dest, v18, v5 - v18, (int)"bmminer.c", (int)"read_version_file", 1524);
        else
          memcpy(dest, v18, v4 - (_DWORD)v18 + 1);
      }
      else
      {
        strcpy(byte_80BA0, v18);
      }
      v6 = strlen(byte_80BA0) - 1;
      v7 = (unsigned __int8)byte_80768[v6 + 1080];
      if ( v7 == 10 )
      {
        byte_80768[v6 + 1080] = 0;
        v6 = strlen(byte_80BA0) - 1;
        v7 = (unsigned __int8)byte_80768[v6 + 1080];
      }
      if ( v7 == 13 )
        byte_80768[v6 + 1080] = 0;
      v8 = strlen(dest) - 1;
      v9 = (unsigned __int8)byte_80768[v8 + 1336];
      if ( v9 == 10 )
      {
        byte_80768[v8 + 1336] = 0;
        v8 = strlen(dest) - 1;
        v9 = (unsigned __int8)byte_80768[v8 + 1336];
      }
      v10 = v9 == 13;
      v11 = 1028;
      if ( v9 == 13 )
      {
        v8 += (size_t)byte_80768;
        LOBYTE(v9) = 0;
      }
      else
      {
        HIWORD(v11) = 89;
      }
      if ( v10 )
      {
        HIWORD(v11) = 89;
        *(_BYTE *)(v8 + 1336) = v9;
      }
    }
  }
  else
  {
    v11 = (int)&byte_590404;
    if ( byte_590404 || byte_482A5C || dword_7EBA0 > 2 )
    {
      snprintf(s, 0x800u, "Open miner version file %s error", (const char *)dword_80970);
      sub_2E584(3, s, 0);
    }
  }
  v12 = (FILE *)fopen64("/config/sn", "rb");
  if ( v12 )
  {
    memset(v18, 0, sizeof(v18));
    v13 = fread(v18, 1u, 0xFAu, v12);
    if ( v13 <= 0 )
    {
      if ( *(_BYTE *)v11 || byte_482A5C || dword_7EBA0 > 2 )
      {
        snprintf(s, 0x800u, "Read miner sn file %s error %d", "/config/sn", v13);
        sub_2E584(3, s, 0);
      }
    }
    else
    {
      v14 = strstr(v18, "\r\n");
      if ( v14 )
        sub_30EA8(&byte_80DA0, v18, v14 - v18, (int)"bmminer.c", (int)"read_version_file", 1572);
      else
        strcpy(&byte_80DA0, v18);
    }
    fclose(v12);
    v15 = *(unsigned __int8 *)v11;
  }
  else if ( *(_BYTE *)v11 || (v15 = (unsigned __int8)byte_482A5C, byte_482A5C) || dword_7EBA0 > 2 )
  {
    snprintf(s, 0x800u, "Open miner sn file %s error", "/config/sn");
    sub_2E584(3, s, 0);
    v15 = *(unsigned __int8 *)v11;
  }
  result = strlen(&byte_80DA0) - 1;
  v17 = (unsigned __int8)byte_80768[result + 1592];
  if ( v17 == 10 )
  {
    byte_80768[result + 1592] = 0;
    result = strlen(&byte_80DA0) - 1;
    v17 = (unsigned __int8)byte_80768[result + 1592];
  }
  if ( v17 == 13 )
    byte_80768[result + 1592] = 0;
  if ( v15 || byte_482A5C || dword_7EBA0 > 2 )
  {
    snprintf(s, 0x800u, "Miner compile time: %s type: %s sn :%s", byte_80BA0, dest, &byte_80DA0);
    return sub_2E584(3, s, 0);
  }
  return result;
}
// 1203C: using guessed type int __fastcall stpcpy(_DWORD, _DWORD);
// 124E4: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 7EBA0: using guessed type int dword_7EBA0;
// 80970: using guessed type int dword_80970;
// 482A5C: using guessed type char byte_482A5C;
// 590404: using guessed type char byte_590404;

//----- (0002AB48) --------------------------------------------------------
char *__fastcall sub_2AB48(size_t *a1, const char **a2, int a3, char a4)
{
  const char *v4; // r11
  const char *v8; // r10
  size_t v9; // r4
  const char *v10; // r8
  size_t v11; // r4
  size_t v12; // r4
  char *v13; // r0
  char *v14; // r5
  size_t v15; // r7
  size_t v16; // r2
  size_t v17; // r6
  size_t v18; // r7
  char s[2088]; // [sp+10h] [bp-828h] BYREF

  v4 = a2[72];
  v8 = a2[77];
  v9 = strlen(v4);
  v10 = a2[80];
  v11 = v9 + strlen(a2[77]) + 459;
  v12 = v11 + strlen(v10);
  v13 = (char *)calloc(1u, v12);
  v14 = v13;
  if ( v13 )
  {
    *(_DWORD *)(v13 + 1) = a3;
    *v13 = a4;
    memcpy(v13 + 5, a2, 0x1C0u);
    v15 = (unsigned __int8)(strlen(v4) + 1);
    v14[453] = v15;
    memcpy(v14 + 454, v4, v15);
    v16 = (unsigned __int8)(strlen(v8) + 1);
    v14[v15 + 454] = v16;
    v17 = v16 + v15 + 455;
    memcpy(&v14[v15 + 455], v8, v16);
    v18 = (unsigned __int8)(strlen(v10) + 1);
    v14[v17] = v18;
    memcpy(&v14[v17 + 1], v10, v18);
    if ( byte_482A5D && (byte_590404 || byte_482A5C || dword_7EBA0 > 6) )
    {
      snprintf(s, 0x800u, "need data size:%d, actual size:%d\n", v12, v18 + v17 + 1);
      sub_2E584(7, s, 0);
    }
    *a1 = v12;
  }
  return v14;
}
// 7EBA0: using guessed type int dword_7EBA0;
// 482A5C: using guessed type char byte_482A5C;
// 482A5D: using guessed type char byte_482A5D;
// 590404: using guessed type char byte_590404;

//----- (0002ACEC) --------------------------------------------------------
int __fastcall sub_2ACEC(int a1, const char **a2, int a3, char a4)
{
  char *v4; // r4
  size_t v6; // [sp+4h] [bp-80Ch] BYREF
  char v7[2056]; // [sp+8h] [bp-808h] BYREF

  v4 = sub_2AB48(&v6, a2, a3, a4);
  if ( sub_281D4(v4, v6) && (byte_590404 || byte_482A5C || dword_7EBA0 > 2) )
  {
    strcpy(v7, "cgminer return err for this nonce!\n");
    sub_2E584(3, v7, 0);
  }
  free(v4);
  return 1;
}
// 7EBA0: using guessed type int dword_7EBA0;
// 482A5C: using guessed type char byte_482A5C;
// 590404: using guessed type char byte_590404;

//----- (0002ADA0) --------------------------------------------------------
int __fastcall sub_2ADA0(const char *a1)
{
  int v2; // r4
  time_t v3; // r3
  struct tm *v4; // r0
  time_t timer[2]; // [sp+1Ch] [bp-CCh] BYREF
  char s[32]; // [sp+24h] [bp-C4h] BYREF
  char v8[32]; // [sp+44h] [bp-A4h] BYREF
  char v9[40]; // [sp+64h] [bp-84h] BYREF
  char v10[92]; // [sp+8Ch] [bp-5Ch] BYREF

  memset(s, 0, sizeof(s));
  memset(v8, 0, sizeof(v8));
  memset(v9, 0, sizeof(v9));
  memset(v10, 0, 0x3Bu);
  v2 = 0;
  sub_302A0(timer);
  while ( 1 )
  {
    v3 = timer[0] - v2++;
    timer[0] = v3;
    v4 = localtime(timer);
    snprintf(
      v9,
      0x28u,
      "[%d-%02d-%02d %02d:%02d:%02d]",
      v4->tm_year + 1900,
      v4->tm_mon + 1,
      v4->tm_mday,
      v4->tm_hour,
      v4->tm_min,
      v4->tm_sec);
    snprintf(v10, 0x3Bu, "%s%s", "BITMAIN_OPENSOURCE", v9);
    sub_2F1EC(v10, 0x3Bu, v8);
    sub_2F1EC(v8, 0x20u, s);
    if ( !strncmp(s, a1, 0x20u) )
      break;
    if ( v2 == 4 )
      return 0;
  }
  puts("socket auth pass!!!!!!!!!!!!!!!!!!!!");
  return 1;
}
// 2ADA0: using guessed type time_t timer[2];

//----- (0002AEF4) --------------------------------------------------------
int sub_2AEF4()
{
  _DWORD *v0; // r4
  int v1; // r3
  _DWORD *v2; // r3
  int result; // r0
  char v4[2064]; // [sp+0h] [bp-810h] BYREF

  v0 = (_DWORD *)dword_58E354;
  if ( !dword_58E354 )
    _assert_fail("cgpu", "bmminer.c", 0x7EAu, "bitmain_primary_init");
  v1 = dword_592460;
  *(_DWORD *)(dword_58E354 + 32) = 0;
  v0[1] = &unk_80EA0;
  v0[5] = v1;
  v0[37] = 1;
  if ( !v1 )
  {
    strcpy(v4, "Failed to calloc cgpu_info data");
    sub_2E584(3, v4, 1);
    v1 = v0[5];
  }
  v2 = (_DWORD *)(v1 + 4096);
  result = 0;
  v2[405] = 0;
  v2[406] = 1;
  v2[407] = 2;
  return result;
}
// 58E354: using guessed type int dword_58E354;
// 592460: using guessed type int dword_592460;

//----- (0002AFC4) --------------------------------------------------------
int __fastcall sub_2AFC4(const char *a1, int a2)
{
  char v4[2056]; // [sp+0h] [bp-808h] BYREF

  if ( a2 != 32 && (byte_590404 || byte_482A5C || dword_7EBA0 > 2) )
  {
    snprintf(v4, 0x800u, "invald hash size %d\n", a2);
    sub_2E584(3, v4, 0);
  }
  byte_482A88 = sub_2ADA0(a1);
  return 0;
}
// 7EBA0: using guessed type int dword_7EBA0;
// 482A5C: using guessed type char byte_482A5C;
// 482A88: using guessed type char byte_482A88;
// 590404: using guessed type char byte_590404;

//----- (0002B05C) --------------------------------------------------------
int __fastcall sub_2B05C(_DWORD *a1, int a2, int a3)
{
  size_t v5; // r7
  size_t v6; // r4
  void *v7; // r0
  void *v8; // r3
  int v9; // r0
  _DWORD *v10; // r0
  int v11; // r3
  size_t v12; // r10
  _DWORD *v13; // r8
  size_t v14; // r7
  int *v15; // r4
  int v16; // r5
  _DWORD *v17; // r3
  int v18; // r12
  int v19; // r0
  int v20; // r1
  int v21; // r2
  int v22; // r0
  int v23; // r1
  int v24; // r2
  char *v25; // r4
  size_t v26; // r0
  size_t v27; // r10
  char *v28; // r4
  size_t v29; // r10
  _DWORD *v30; // r2
  int v31; // r1
  int *v32; // r9
  size_t v33; // r10
  int result; // r0
  int v35; // r1
  char s[2088]; // [sp+8h] [bp-828h] BYREF

  memcpy(a1, (const void *)a2, 0x738u);
  v5 = a1[393];
  v6 = v5 + 1848;
  v7 = calloc(1u, v5);
  v8 = memcpy(v7, (const void *)(a2 + 1848), v5);
  v9 = a1[427];
  a1[392] = v8;
  v10 = sub_2F408(4 * v9 + 1, "bmminer.c", "parse_job_buf", 2190);
  v11 = a1[427];
  a1[169] = v10;
  if ( v11 > 0 )
  {
    v13 = v10;
    v14 = v5 + 1880;
    v15 = (int *)(a2 + v6);
    v16 = 0;
    while ( 1 )
    {
      v13[v16] = sub_2F408(0x20u, "bmminer.c", "parse_job_buf", 2193);
      v12 = v14 + 32 * v16;
      v17 = *(_DWORD **)(a1[169] + 4 * v16);
      if ( !v17 )
      {
        strcpy(s, "Failed to malloc local merkle_bin");
        sub_2E584(3, s, 1);
        v17 = *(_DWORD **)(a1[169] + 4 * v16);
      }
      v18 = *v15;
      ++v16;
      v19 = v15[1];
      v15 += 8;
      v20 = *(v15 - 6);
      v21 = *(v15 - 5);
      *v17 = v18;
      v17[1] = v19;
      v17[2] = v20;
      v17[3] = v21;
      v22 = *(v15 - 3);
      v23 = *(v15 - 2);
      v24 = *(v15 - 1);
      v17[4] = *(v15 - 4);
      v17[5] = v22;
      v17[6] = v23;
      v17[7] = v24;
      if ( a1[427] <= v16 )
        break;
      v13 = (_DWORD *)a1[169];
    }
  }
  else
  {
    v12 = v5 + 1848;
  }
  v25 = _strdup((const char *)(a2 + v12));
  v26 = strlen(v25);
  a1[168] = v25;
  v27 = v26 + 1 + v12;
  v28 = _strdup((const char *)(a2 + v27));
  v29 = v27 + strlen(v28);
  a1[153] = v28;
  v30 = (_DWORD *)(a2 + v29 + 1);
  v31 = v30[1];
  v32 = (int *)(a2 + v29 + 9);
  v33 = v29 + 17;
  unk_80F18 = *v30;
  unk_80F1C = v31;
  result = *v32;
  v35 = v32[1];
  unk_7EAB0 = *v32;
  unk_7EAB4 = v35;
  if ( byte_482A5D && (byte_590404 || byte_482A5C || dword_7EBA0 > 6) )
  {
    snprintf(s, 0x800u, "parse job buf len:%d\n", v33);
    result = sub_2E584(7, s, 0);
  }
  if ( v33 != a3 )
  {
    strcpy(s, "ERR: data trans/recv unmathced!");
    return sub_2E584(3, s, 1);
  }
  return result;
}
// 7EBA0: using guessed type int dword_7EBA0;
// 482A5C: using guessed type char byte_482A5C;
// 482A5D: using guessed type char byte_482A5D;
// 590404: using guessed type char byte_590404;

//----- (0002B2F4) --------------------------------------------------------
int sub_2B2F4()
{
  int v0; // r4

  pthread_mutex_lock(&mutex);
  v0 = sub_316D8((char *)dword_80F3C, dword_80F38);
  pthread_mutex_unlock(&mutex);
  return v0;
}
// 80F38: using guessed type int dword_80F38;
// 80F3C: using guessed type int dword_80F3C;

//----- (0002B330) --------------------------------------------------------
int __fastcall sub_2B330(const void *a1, unsigned int a2)
{
  int v4; // r4
  _DWORD *v5; // r5
  int v6; // r2
  int v7; // r0
  int v8; // r0
  int v9; // r4
  void *v10; // r0
  void *v12; // r0
  int *v13; // r0
  int *v14; // r0
  int *v15; // r0
  int *v16; // r0
  int *v17; // r0
  int *v18; // r0
  void *ptr; // [sp+14h] [bp-82Ch] BYREF
  char s[2088]; // [sp+18h] [bp-828h] BYREF

  v4 = dword_592460;
  ptr = 0;
  if ( byte_482A5D && (byte_590404 || byte_482A5C || dword_7EBA0 > 6) )
  {
    snprintf(s, 0x800u, "%s, rec job data %p size: %d\n", "bitmain_update_job_cb", a1, a2);
    sub_2E584(7, s, 0);
  }
  if ( (unsigned int)sub_31D38() <= 1 )
  {
    pthread_mutex_lock(&mutex);
    v12 = (void *)dword_80F3C;
    if ( !dword_80F3C || dword_80F38 < a2 )
    {
      v12 = realloc((void *)dword_80F3C, a2);
      dword_80F3C = (int)v12;
    }
    memcpy(v12, a1, a2);
    dword_80F38 = a2;
    pthread_mutex_unlock(&mutex);
    return 0;
  }
  else
  {
    if ( pthread_mutex_lock((pthread_mutex_t *)(v4 + 112)) )
    {
      v17 = _errno_location();
      snprintf(
        s,
        0x800u,
        "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
        *v17,
        "bmminer.c",
        "bitmain_update_job_cb",
        2250);
      sub_2E584(3, s, 1);
    }
    v5 = calloc(1u, 0x738u);
    sub_2B05C(v5, (int)a1, a2);
    if ( !*((_BYTE *)v5 + 640) )
    {
      strcpy(s, "Bitmain S9 has to use stratum pools");
      sub_2E584(3, s, 1);
    }
    if ( pthread_mutex_lock((pthread_mutex_t *)v4) )
    {
      v18 = _errno_location();
      snprintf(
        s,
        0x800u,
        "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
        *v18,
        "bmminer.c",
        "bitmain_update_job_cb",
        2261);
      sub_2E584(3, s, 1);
    }
    if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(v4 + 24)) )
    {
      v13 = _errno_location();
      snprintf(
        s,
        0x800u,
        "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
        *v13,
        "bmminer.c",
        "bitmain_update_job_cb",
        2261);
      sub_2E584(3, s, 1);
    }
    *(_DWORD *)(v4 + 168) = *v5;
    sub_33478(v4 + 3868, v4 + 2020);
    *(_DWORD *)(v4 + 5724) = *(_DWORD *)(v4 + 5720);
    sub_33478(v4 + 2020, v4 + 172);
    *(_DWORD *)(v4 + 5720) = *(_DWORD *)(v4 + 5716);
    sub_33478(v4 + 172, (int)v5);
    v6 = dword_7EAB8 + 1;
    *(_DWORD *)(v4 + 5716) = dword_7EAB8 + 1;
    dword_7EAB8 = v6;
    if ( pthread_rwlock_unlock((pthread_rwlock_t *)(v4 + 24)) )
    {
      v14 = _errno_location();
      snprintf(
        s,
        0x800u,
        "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v14,
        "bmminer.c",
        "bitmain_update_job_cb",
        2273);
      sub_2E584(3, s, 1);
    }
    v7 = pthread_mutex_unlock((pthread_mutex_t *)v4);
    if ( v7 )
    {
      v15 = _errno_location();
      snprintf(
        s,
        0x800u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v15,
        "bmminer.c",
        "bitmain_update_job_cb",
        2273);
      v7 = sub_2E584(3, s, 1);
    }
    off_7ECC4(v7);
    sub_32CC0(&ptr, (int)v5, *(_DWORD *)(v4 + 5716));
    pthread_mutex_lock(stru_4FCAA0);
    sub_32F40((unsigned __int8 *)ptr);
    pthread_mutex_unlock(stru_4FCAA0);
    free(ptr);
    v8 = pthread_mutex_unlock((pthread_mutex_t *)(v4 + 112));
    if ( v8 )
    {
      v16 = _errno_location();
      snprintf(
        s,
        0x800u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v16,
        "bmminer.c",
        "bitmain_update_job_cb",
        2283);
      v8 = sub_2E584(3, s, 1);
    }
    off_7ECC4(v8);
    if ( (int)v5[427] > 0 )
    {
      v9 = 0;
      do
      {
        v10 = *(void **)(v5[169] + 4 * v9++);
        free(v10);
      }
      while ( v5[427] > v9 );
    }
    free((void *)v5[169]);
    free((void *)v5[392]);
    free((void *)v5[168]);
    free((void *)v5[153]);
    free(v5);
    return 0;
  }
}
// 7EAB8: using guessed type int dword_7EAB8;
// 7EBA0: using guessed type int dword_7EBA0;
// 7ECC4: using guessed type int (__fastcall *off_7ECC4)(_DWORD);
// 80F38: using guessed type int dword_80F38;
// 80F3C: using guessed type int dword_80F3C;
// 482A5C: using guessed type char byte_482A5C;
// 482A5D: using guessed type char byte_482A5D;
// 4FCAA0: using guessed type pthread_mutex_t stru_4FCAA0[2];
// 590404: using guessed type char byte_590404;
// 592460: using guessed type int dword_592460;

//----- (0002B800) --------------------------------------------------------
size_t __fastcall sub_2B800(int *a1)
{
  int v1; // r3
  size_t result; // r0
  char v3[2056]; // [sp+0h] [bp-808h] BYREF

  v1 = *a1;
  switch ( *a1 )
  {
    case 0:
    case 1:
    case 2:
      result = strlen((const char *)a1[2]) + 1;
      break;
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 16:
    case 19:
    case 22:
    case 26:
      result = 4;
      break;
    case 10:
    case 11:
    case 12:
    case 13:
    case 15:
    case 17:
    case 18:
    case 20:
    case 21:
    case 23:
    case 24:
    case 25:
      result = 8;
      break;
    case 14:
      result = 1;
      break;
    default:
      if ( byte_590404 || (result = (unsigned __int8)byte_482A5C, byte_482A5C) || dword_7EBA0 > 2 )
      {
        snprintf(v3, 0x800u, "Should not happen for unknown data type %d", v1);
        sub_2E584(3, v3, 0);
        result = 0;
      }
      break;
  }
  return result;
}
// 2B818: control flows out of bounds to 2B81C
// 7EBA0: using guessed type int dword_7EBA0;
// 482A5C: using guessed type char byte_482A5C;
// 590404: using guessed type char byte_590404;

//----- (0002B944) --------------------------------------------------------
int __fastcall sub_2B944(const char *a1, size_t n)
{
  int result; // r0
  int v4; // r3
  char v5[2072]; // [sp+0h] [bp-818h] BYREF

  if ( n == 1 )
  {
    pthread_mutex_lock(&stru_80A74);
    pthread_cond_signal(&cond);
    pthread_mutex_unlock(&stru_80A74);
    return 0;
  }
  if ( n == 4 )
  {
    v4 = *(_DWORD *)a1;
    dword_7EABC = *(_DWORD *)a1;
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      snprintf(v5, 0x800u, "freq_level = %d\n", v4);
      sub_2E584(3, v5, 0);
      return 0;
    }
    return 0;
  }
  if ( n != 2 )
    return 0;
  if ( !strncmp(a1, "go", 2u) )
  {
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      strcpy(v5, "start to init...\n");
      sub_2E584(3, v5, 0);
    }
    sem_post(&sem);
  }
  if ( strncmp(a1, "re", 2u) )
    return 0;
  if ( (unsigned int)dword_7EB9C > 3 )
  {
    strcpy(v5, "reload pool, need recalculate\n");
    sub_2E584(3, v5, 0);
  }
  sub_265F4();
  unk_80F50 = 0LL;
  *(_QWORD *)dword_99ED98 = 0LL;
  *(_QWORD *)&dword_99ED98[2] = 0LL;
  *(_QWORD *)&dword_99ED98[4] = 0LL;
  *(_QWORD *)&dword_99ED98[6] = 0LL;
  qword_99EE08 = 0LL;
  sub_32CA8();
  result = 0;
  dword_80F58 = 1;
  dword_80F5C = 1;
  dword_80F60 = 1;
  return result;
}
// 7EABC: using guessed type int dword_7EABC;
// 7EB9C: using guessed type int dword_7EB9C;
// 80F58: using guessed type int dword_80F58;
// 80F5C: using guessed type int dword_80F5C;
// 80F60: using guessed type int dword_80F60;
// 99ED98: using guessed type _DWORD dword_99ED98[8];
// 99EDA0: using guessed type _DWORD;
// 99EDA8: using guessed type _DWORD;
// 99EDB0: using guessed type _DWORD;
// 99EE08: using guessed type __int64 qword_99EE08;

//----- (0002BB44) --------------------------------------------------------
int __fastcall sub_2BB44(int a1, int a2)
{
  int result; // r0
  char s[2056]; // [sp+8h] [bp-808h] BYREF

  if ( byte_590404 || byte_482A5C || dword_7EBA0 > 4 )
  {
    snprintf(s, 0x800u, "%s %d\n", "bitmain_shutdown_cb", a2);
    sub_2E584(5, s, 0);
  }
  sub_31CAC();
  sub_2FE84(dword_80758);
  sub_2FE84(dword_80754);
  sub_2FE84(dword_80750);
  sub_2FE84(dword_590400);
  sub_44A88();
  result = 0;
  *(_BYTE *)(dword_58E354 + 364) = 1;
  return result;
}
// 7EBA0: using guessed type int dword_7EBA0;
// 80750: using guessed type int dword_80750;
// 80754: using guessed type int dword_80754;
// 80758: using guessed type int dword_80758;
// 482A5C: using guessed type char byte_482A5C;
// 58E354: using guessed type int dword_58E354;
// 590400: using guessed type int dword_590400;
// 590404: using guessed type char byte_590404;

//----- (0002BC2C) --------------------------------------------------------
void __fastcall sub_2BC2C(int a1, const char **a2)
{
  int v3; // [sp+Ch] [bp-80Ch] BYREF
  char s[2056]; // [sp+10h] [bp-808h] BYREF

  v3 = a1;
  sub_3DC80((int)&off_7E618, (int)"Options for both config file and command line");
  sub_3DC80((int)&off_7EAC0, (int)"Options for command line only");
  sub_3DD54(&v3, a2, (void (*)(const char *, ...))sub_282E4);
  if ( v3 != 1 )
  {
    strcpy(s, "Unexpected extra commandline arguments");
    sub_2E584(3, s, 1);
  }
  sub_29458();
  if ( dword_80970 )
    sub_2A688();
  if ( dword_80968 )
  {
    byte_482130 = 1;
    strcpy(byte_482158, (const char *)dword_80968);
    if ( dword_8096C )
      strcpy((char *)&word_482138, (const char *)dword_8096C);
    else
      strcpy((char *)&word_482138, "a+");
    if ( byte_590404 || byte_482A5C || dword_7EBA0 > 2 )
    {
      snprintf(s, 0x800u, "Log file path: %s Open flag: %s", byte_482158, (const char *)&word_482138);
      sub_2E584(3, s, 0);
    }
  }
}
// 7E618: using guessed type char *off_7E618;
// 7EAC0: using guessed type char *off_7EAC0;
// 7EBA0: using guessed type int dword_7EBA0;
// 80968: using guessed type int dword_80968;
// 8096C: using guessed type int dword_8096C;
// 80970: using guessed type int dword_80970;
// 482130: using guessed type char byte_482130;
// 482138: using guessed type __int16 word_482138;
// 482A5C: using guessed type char byte_482A5C;
// 590404: using guessed type char byte_590404;

//----- (0002BDC4) --------------------------------------------------------
int sub_2BDC4()
{
  return sem_wait(&sem);
}

//----- (0002BDD0) --------------------------------------------------------
int sub_2BDD0()
{
  pthread_mutex_lock(&stru_810DC);
  dword_5945B8[0] = 0;
  dword_5945BC = 0;
  dword_5945C0 = 0;
  return pthread_mutex_unlock(&stru_810DC);
}
// 810DC: using guessed type pthread_mutex_t stru_810DC;
// 5945B8: using guessed type int dword_5945B8[];
// 5945BC: using guessed type int dword_5945BC;
// 5945C0: using guessed type int dword_5945C0;

//----- (0002BE08) --------------------------------------------------------
int sub_2BE08()
{
  pthread_mutex_lock(&stru_4FCAD0);
  dword_5955C8[0] = 0;
  dword_5955CC = 0;
  dword_5955D0 = 0;
  return pthread_mutex_unlock(&stru_4FCAD0);
}
// 4FCAD0: using guessed type pthread_mutex_t stru_4FCAD0;
// 5955C8: using guessed type int dword_5955C8[];
// 5955CC: using guessed type int dword_5955CC;
// 5955D0: using guessed type int dword_5955D0;

//----- (0002BE40) --------------------------------------------------------
int __fastcall sub_2BE40(int a1, int a2)
{
  int result; // r0
  int v4; // r7
  int v5; // r10
  int v6; // r1
  int v7; // r11
  int v8; // r10
  int v9; // r3
  int *v10; // r12
  int v11; // r1
  int v12; // r0
  bool v13; // zf
  int v14; // r10
  int v15; // r11
  int v16; // r11
  unsigned int v17; // [sp+0h] [bp-830h]
  int v18; // [sp+0h] [bp-830h]
  char s[2088]; // [sp+8h] [bp-828h] BYREF

  result = sub_1E29C(a1);
  if ( !result )
  {
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      snprintf(s, 0x800u, "Chain %d is not exist.\n", a1);
      sub_2E584(3, s, 0);
      return 0;
    }
    return result;
  }
  if ( !a2 )
    sub_1E610(a1, 0);
  v4 = 0;
  sub_2BDD0();
  v5 = 0;
  sub_1EC84((unsigned __int8)a1, 1, 0, a2);
LABEL_8:
  while ( 2 )
  {
    sub_304D4();
    pthread_mutex_lock(&stru_810DC);
    v6 = dword_5945C0;
    v4 += dword_5945C0;
    v7 = dword_5945C0;
    if ( dword_5945C0 > 0 )
    {
      v8 = 0;
      while ( 1 )
      {
        dword_5945C0 = v6 - 1;
        ++v8;
        v9 = dword_5945BC + 1;
        v10 = &dword_5945B8[2 * dword_5945BC + 2];
        if ( (unsigned int)(dword_5945BC + 1) > 0x1FE )
          v9 = 0;
        v11 = *((unsigned __int8 *)v10 + 10);
        v12 = *((unsigned __int8 *)v10 + 11);
        dword_5945BC = v9;
        v13 = v12 == a1;
        if ( v12 == a1 )
          v13 = v11 == 0;
        if ( v13 && (v17 = v10[1], sub_1E110() == HIWORD(v17)) )
        {
          sub_1E5A0(a1);
          if ( v7 == v8 )
          {
LABEL_20:
            v14 = sub_1E0F0();
            if ( v4 > 5 * sub_1E28C() * v14 )
              goto LABEL_21;
            v5 = 0;
            pthread_mutex_unlock(&stru_810DC);
            goto LABEL_8;
          }
        }
        else if ( v7 == v8 )
        {
          goto LABEL_20;
        }
        v6 = dword_5945C0;
      }
    }
    v18 = dword_5945C0;
    v15 = sub_1E0F0();
    if ( v4 > 5 * sub_1E28C() * v15 )
      goto LABEL_21;
    if ( v18 )
    {
      if ( a2 || (v16 = sub_1E0F0(), v16 != sub_1E67C(a1)) )
      {
        pthread_mutex_unlock(&stru_810DC);
        continue;
      }
LABEL_21:
      pthread_mutex_unlock(&stru_810DC);
      return 1;
    }
    else
    {
      ++v5;
      sub_304D4();
      pthread_mutex_unlock(&stru_810DC);
      if ( v5 != 4 )
        continue;
      return 1;
    }
  }
}
// 7EB9C: using guessed type int dword_7EB9C;
// 810DC: using guessed type pthread_mutex_t stru_810DC;
// 5945B8: using guessed type int dword_5945B8[];
// 5945BC: using guessed type int dword_5945BC;
// 5945C0: using guessed type int dword_5945C0;

//----- (0002C06C) --------------------------------------------------------
int __fastcall sub_2C06C(int a1, int a2, int a3)
{
  int v6; // r2
  int v7; // r9
  int v8; // r5
  unsigned int v9; // r3
  int *v10; // r1
  int v11; // r4
  int *v13; // [sp+1Ch] [bp-844h]
  char v14; // [sp+24h] [bp-83Ch]
  char v15; // [sp+28h] [bp-838h]
  int v16; // [sp+2Ch] [bp-834h]
  int v17; // [sp+30h] [bp-830h]
  int v18; // [sp+34h] [bp-82Ch]
  char s[2088]; // [sp+38h] [bp-828h] BYREF

  v14 = a1;
  v15 = a2;
  v16 = (unsigned __int8)a3;
  v18 = 5;
  pthread_mutex_lock(&stru_810F4);
  while ( 2 )
  {
    v17 = 8;
    sub_2BDD0();
    sub_1EC84(v16, 0, v15, v14);
    do
    {
      sub_304D4();
      pthread_mutex_lock(&stru_810DC);
      v6 = dword_5945C0;
      if ( dword_5945C0 )
      {
        v7 = dword_5945C0;
        v8 = 0;
        while ( 1 )
        {
          ++v8;
          dword_5945C0 = v6 - 1;
          v9 = dword_5945BC + 1;
          if ( (unsigned int)(dword_5945BC + 1) > 0x1FE )
            dword_5945BC = 0;
          v10 = &dword_5945B8[2 * v9];
          if ( v9 <= 0x1FE )
            dword_5945BC = v9;
          if ( *((unsigned __int8 *)v10 + 11) == a3
            && *((unsigned __int8 *)v10 + 9) == a2
            && *((unsigned __int8 *)v10 + 10) == a1 )
          {
            break;
          }
          if ( (unsigned int)dword_7EB9C > 3 )
          {
            snprintf(
              s,
              0x800u,
              "read asic reg error: expect chain = %d, chip = %d, reg = %d, got chain = %d, chip = %d, reg = %d\n",
              a3,
              a2,
              a1,
              *((unsigned __int8 *)v10 + 11),
              BYTE1(dword_5945B8[2 * v9 + 2]),
              BYTE2(dword_5945B8[2 * v9 + 2]));
            sub_2E584(3, s, 0);
            if ( v7 == v8 )
              goto LABEL_20;
          }
          else if ( v7 == v8 )
          {
            goto LABEL_20;
          }
          v6 = dword_5945C0;
        }
        if ( a1 == 28 )
        {
          v11 = v10[1];
          if ( (v11 & 0xE0000000) != 0 )
            v11 = 0;
          pthread_mutex_unlock(&stru_810DC);
          sub_2BDD0();
          pthread_mutex_unlock(&stru_810F4);
          return v11;
        }
        else
        {
          v13 = &dword_5945B8[2 * v9];
          pthread_mutex_unlock(&stru_810DC);
          sub_2BDD0();
          pthread_mutex_unlock(&stru_810F4);
          return v13[1];
        }
      }
LABEL_20:
      pthread_mutex_unlock(&stru_810DC);
      --v17;
    }
    while ( v17 );
    if ( --v18 )
      continue;
    break;
  }
  if ( (unsigned int)dword_7EB9C > 4 )
  {
    snprintf(s, 0x800u, "read asic reg timeout: expect chain = %d, chip = %d, reg = %d\n", a3, a2, a1);
    sub_2E584(4, s, 0);
  }
  sub_2BDD0();
  pthread_mutex_unlock(&stru_810F4);
  return 0;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 810DC: using guessed type pthread_mutex_t stru_810DC;
// 5945B8: using guessed type int dword_5945B8[];
// 5945BC: using guessed type int dword_5945BC;
// 5945C0: using guessed type int dword_5945C0;

//----- (0002C2E8) --------------------------------------------------------
int __fastcall sub_2C2E8(int a1, int a2, int a3, int a4)
{
  int v7; // r0
  pthread_mutex_t *v8; // r10
  int v9; // r6
  int v10; // r8
  int v11; // r5
  int v12; // r3
  int *v13; // r6
  int v14; // r2
  int v15; // r10
  int v16; // r0
  int v17; // r0
  int v18; // r1
  unsigned int v19; // r6
  int v20; // r0
  int v21; // r1
  int v22; // r0
  int v23; // r0
  pthread_mutex_t *mutex; // [sp+Ch] [bp-854h]
  int v27; // [sp+18h] [bp-848h]
  unsigned int v28; // [sp+1Ch] [bp-844h]
  int v29; // [sp+20h] [bp-840h]
  int v30; // [sp+28h] [bp-838h] BYREF
  __time_t v31[2]; // [sp+30h] [bp-830h] BYREF
  char s[2088]; // [sp+38h] [bp-828h] BYREF

  if ( sub_1E29C(a3) )
  {
    pthread_mutex_lock(&stru_810F4);
    sub_1629C();
    byte_8110C = 1;
    sub_2BDD0();
    if ( a1 == 2 )
    {
      v22 = sub_1E160();
      sub_50DC4((unsigned __int8)a3, a2 * v22, 2);
    }
    else
    {
      v7 = sub_1E160();
      if ( a1 == 6 )
        sub_50DA8((unsigned __int8)a3, a2 * v7);
      else
        sub_5193C((unsigned __int8)a3, a2 * v7, a1);
    }
    v8 = &stru_810DC;
    v27 = 0;
    v29 = 0;
    usleep((__useconds_t)&loc_186A0);
    do
    {
      pthread_mutex_lock(v8);
      v9 = dword_5945C0;
      v10 = dword_5945C0;
      if ( dword_5945C0 > 0 )
      {
        v11 = 0;
        mutex = v8;
        while ( 1 )
        {
          dword_5945C0 = v9 - 1;
          ++v11;
          v12 = dword_5945BC + 1;
          v13 = &dword_5945B8[2 * dword_5945BC + 2];
          if ( (unsigned int)(dword_5945BC + 1) > 0x1FE )
            v12 = 0;
          v14 = *((unsigned __int8 *)v13 + 11);
          dword_5945BC = v12;
          if ( v14 == a3
            && *((_BYTE *)v13 + 10) == 64
            && (v15 = *((unsigned __int8 *)v13 + 9), v16 = sub_1E160(), sub_5FAF8(v15, v16) == a2)
            && (v28 = *((unsigned __int16 *)v13 + 3),
                ++v27,
                v17 = sub_1E120(),
                sub_5FADC(v28, v17),
                !*(_DWORD *)(a4 + 4 * v18)) )
          {
            v19 = v13[1];
            ++v29;
            v20 = sub_1E120();
            sub_5FADC(HIWORD(v19), v20);
            *(_DWORD *)(a4 + 4 * v21) = (unsigned __int16)v19;
            if ( v10 == v11 )
            {
LABEL_20:
              v8 = mutex;
              pthread_mutex_unlock(mutex);
              goto LABEL_21;
            }
          }
          else if ( v10 == v11 )
          {
            goto LABEL_20;
          }
          v9 = dword_5945C0;
        }
      }
      pthread_mutex_unlock(v8);
      if ( !v9 )
        usleep(0x3E8u);
LABEL_21:
      sub_302A0(v31);
    }
    while ( (int)sub_30578(v31, &v30) <= 199 );
    if ( v29 != sub_1E120() && (unsigned int)dword_7EB9C > 3 )
    {
      v23 = sub_1E120();
      snprintf(s, 0x800u, "recv core response not enough!!!, total recv::%d, valid::%d, need::%d.\n", v27, v29, v23);
      sub_2E584(3, s, 0);
    }
    byte_8110C = 0;
    sub_162B0();
    pthread_mutex_unlock(&stru_810F4);
    return 0;
  }
  else
  {
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      snprintf(s, 0x800u, "chain::%d don't exist!!!\n", a3);
      sub_2E584(3, s, 0);
    }
    return -1;
  }
}
// 2C4A4: variable 'v18' is possibly undefined
// 2C4DC: variable 'v21' is possibly undefined
// 7EB9C: using guessed type int dword_7EB9C;
// 810DC: using guessed type pthread_mutex_t stru_810DC;
// 8110C: using guessed type char byte_8110C;
// 5945B8: using guessed type int dword_5945B8[];
// 5945BC: using guessed type int dword_5945BC;
// 5945C0: using guessed type int dword_5945C0;
// 2C2E8: using guessed type __time_t var_830[2];

//----- (0002C5E8) --------------------------------------------------------
_BYTE *__fastcall sub_2C5E8(_BYTE *result)
{
  _BYTE *v1; // r4
  int v2; // r11
  int v3; // r7
  int v4; // r8
  int *v5; // r10
  int v6; // r0
  unsigned int v7; // r3
  int v8; // r7
  int *v9; // r4
  int v10; // r5
  int v11; // r4
  unsigned int v12; // r8
  int v13; // r0
  unsigned int v14; // r7
  unsigned int v15; // r3
  bool v16; // cc
  unsigned int v17; // r0
  bool v18; // cf
  unsigned int v19; // r3
  unsigned int v20; // r2
  int v21; // r0
  int v22; // r12
  char s[2088]; // [sp+8h] [bp-828h] BYREF

  if ( byte_482A89 )
  {
    v1 = result;
    if ( (*result & 0x80) != 0 )
    {
      if ( (*result & 0x40) != 0 )
      {
        if ( (unsigned int)dword_7EB9C > 3 )
        {
          strcpy(s, "!!! nonce crc error\n");
          result = (_BYTE *)sub_2E584(3, s, 0);
        }
        ++dword_5955C0;
      }
      else
      {
        pthread_mutex_lock(&stru_4FCAD0);
        if ( (unsigned int)dword_5955D0 <= 0x1FE )
        {
          v2 = dword_5955C8[0];
          v3 = 16 * dword_5955C8[0];
          v4 = *((_WORD *)v1 + 1) & 0x7FFF;
          v5 = &dword_5955C8[15 * dword_5955C8[0]];
          v5[4] = v4;
          v5[8] = *((_DWORD *)v1 + 1);
          v5[9] = *v1 & 0xF;
          v6 = sub_4466C(v4);
          v7 = dword_7EB9C;
          v5[3] = v6;
          if ( v7 > 4 )
          {
            snprintf(s, 0x800u, "blk ver = 0x%x\n", *(unsigned __int16 *)(v1 + 9));
            sub_2E584(4, s, 0);
          }
          v8 = v3 - v2;
          v9 = &dword_5955C8[v8];
          v9[5] = sub_44680(v4);
          *((_QWORD *)v9 + 3) = sub_44654(v4);
          sub_44698(v4, (int)&dword_5955C8[v8 + 10], 32);
          v10 = dword_5955C8[v8 + 8];
          v11 = dword_5955C8[v8 + 9];
          v12 = sub_51970(v10);
          v13 = sub_1E160();
          v14 = sub_51978(v10, v13);
          if ( v11 > 3 || v14 >= sub_1E0F0() )
            goto LABEL_34;
          v17 = sub_1E120();
          v18 = 1;
          if ( v10 )
            v18 = v12 >= v17;
          if ( v18 )
          {
LABEL_34:
            if ( (unsigned int)dword_7EB9C > 4 )
            {
              snprintf(s, 0x800u, "buf [%x] is error!\n", v10);
              sub_2E584(4, s, 0);
              if ( (unsigned int)dword_7EB9C > 4 )
              {
                snprintf(s, 0x800u, "chain = %d, chip = %d, core = %d\n", v11, v14, v12);
                sub_2E584(4, s, 0);
              }
            }
          }
          else
          {
            v19 = v14 + (v11 << 8);
            v20 = v12 + (v19 << 10);
            v19 += 4;
            v20 += 1028;
            v21 = dword_81118[v20];
            v22 = dword_81118[v19] + 1;
            ++dword_81118[v11];
            dword_81118[v19] = v22;
            dword_81118[v20] = v21 + 1;
          }
          v15 = dword_5955C8[0] + 1;
          v16 = (unsigned int)(dword_5955C8[0] + 1) > 0x1FE;
          dword_5955C8[0] = v15;
          if ( v15 > 0x1FE )
            v15 = 0;
          if ( v16 )
            dword_5955C8[0] = v15;
          ++dword_5955D0;
          dword_81110 = 0;
        }
        else if ( !dword_81110 )
        {
          if ( (unsigned int)dword_7EB9C > 3 )
          {
            strcpy(s, "nonce_read_out buffer is full!\n");
            sub_2E584(3, s, dword_81110);
          }
          dword_81110 = 1;
        }
        return (_BYTE *)pthread_mutex_unlock(&stru_4FCAD0);
      }
    }
    else if ( (unsigned int)dword_7EB9C > 3 )
    {
      strcpy(s, "!!! nonce invalid\n");
      return (_BYTE *)sub_2E584(3, s, 0);
    }
  }
  return result;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 81110: using guessed type int dword_81110;
// 81118: using guessed type int dword_81118[3];
// 482A89: using guessed type char byte_482A89;
// 4FCAD0: using guessed type pthread_mutex_t stru_4FCAD0;
// 5955C0: using guessed type int dword_5955C0;
// 5955C8: using guessed type int dword_5955C8[];
// 5955D0: using guessed type int dword_5955D0;

//----- (0002C96C) --------------------------------------------------------
int __fastcall sub_2C96C(int result)
{
  int v1; // r5
  int v2; // r2
  int v3; // r4
  unsigned int v4; // r0
  int *v5; // r1
  int v6; // lr
  char v7[2064]; // [sp+0h] [bp-810h] BYREF

  if ( (*(_BYTE *)result & 0x40) != 0 )
  {
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      strcpy(v7, "!!! reg crc error\n");
      result = sub_2E584(3, v7, 0);
    }
    ++dword_5955BC;
  }
  else
  {
    v1 = result;
    if ( (*(_BYTE *)(result + 3) & 0x60) != 0 )
    {
      if ( (unsigned int)dword_7EB9C > 3 )
      {
        snprintf(v7, 0x800u, "!!! REG_TYPE = 1. %u\n", *(_DWORD *)result);
        return sub_2E584(3, v7, 0);
      }
    }
    else
    {
      pthread_mutex_lock(&stru_810DC);
      v2 = dword_5945C0;
      if ( (unsigned int)dword_5945C0 > 0x1FE )
      {
        if ( (unsigned int)dword_7EB9C > 3 )
        {
          strcpy(v7, "reg_value_buf buffer is full!\n");
          sub_2E584(3, v7, 0);
        }
      }
      else
      {
        v3 = (unsigned __int8)byte_8110C;
        v4 = dword_5945B8[0] + 1;
        v5 = &dword_5945B8[2 * dword_5945B8[0] + 2];
        v5[1] = *(_DWORD *)(v1 + 4);
        *((_BYTE *)v5 + 8) = *(_BYTE *)(v1 + 3) & 0x1F;
        *((_BYTE *)v5 + 9) = *(_BYTE *)(v1 + 2);
        v6 = *(unsigned __int8 *)(v1 + 1);
        if ( v6 != 64 )
          v3 |= 1u;
        *((_BYTE *)v5 + 10) = v6;
        *((_BYTE *)v5 + 11) = *(_BYTE *)v1 & 0xF;
        if ( v3 )
        {
          dword_5945B8[0] = v4;
          dword_5945C0 = v2 + 1;
          if ( v4 > 0x1FE )
            dword_5945B8[0] = 0;
        }
      }
      return pthread_mutex_unlock(&stru_810DC);
    }
  }
  return result;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 810DC: using guessed type pthread_mutex_t stru_810DC;
// 8110C: using guessed type char byte_8110C;
// 5945B8: using guessed type int dword_5945B8[];
// 5945C0: using guessed type int dword_5945C0;
// 5955BC: using guessed type int dword_5955BC;

//----- (0002CB2C) --------------------------------------------------------
int sub_2CB2C()
{
  int v0; // r7
  int i; // r6
  int result; // r0
  int v3; // r10
  int v4; // r8
  int v5; // r4
  int v6; // r0
  int v7; // r2
  char *v8; // r3
  char *v9; // r0
  int v10; // t1
  int v11; // r0
  int v12; // r1
  char s[2088]; // [sp+10h] [bp-828h] BYREF

  if ( (unsigned int)dword_7EB9C > 4 )
  {
    strcpy(s, "\n dump asic nonce number...\n");
    sub_2E584(4, s, 0);
  }
  v0 = 0;
  for ( i = 0; i != 4; ++i )
  {
    result = sub_1E29C(i);
    if ( result )
    {
      if ( (unsigned int)dword_7EB9C > 4 )
      {
        snprintf(s, 0x800u, "Chain[%d]:\n", i);
        sub_2E584(4, s, 0);
      }
      result = sub_1E0F0();
      v3 = result;
      v4 = 0;
      if ( result > 0 )
      {
        v5 = 0;
        do
        {
          v6 = sub_1E120();
          if ( v6 > 0 )
          {
            v7 = 0;
            v8 = (char *)&unk_82124 + 4096 * (v5 + v0);
            v9 = (char *)&unk_82124 + 4096 * (v5 + v0) + 4 * v6;
            do
            {
              v10 = *((_DWORD *)v8 + 1);
              v8 += 4;
              v7 += v10;
            }
            while ( v8 != v9 );
            v4 += v7;
          }
          else
          {
            v7 = 0;
          }
          if ( (unsigned int)dword_7EB9C > 4 )
          {
            snprintf(s, 0x800u, "IC[%03d] = %-10d ", v5, v7);
            sub_2E584(4, s, 0);
          }
          ++v5;
          v11 = sub_1E100();
          result = sub_5FD8C(v5, v11);
          if ( !v12 && (unsigned int)dword_7EB9C > 4 )
          {
            strcpy(s, "\n");
            result = sub_2E584(4, s, 0);
          }
        }
        while ( v5 != v3 );
      }
      if ( (unsigned int)dword_7EB9C > 4 )
      {
        snprintf(s, 0x800u, "Chain[%d] total nonce number = %d\n", i, v4);
        result = sub_2E584(4, s, 0);
        if ( (unsigned int)dword_7EB9C > 4 )
        {
          strcpy(s, "\n");
          result = sub_2E584(4, s, 0);
        }
      }
    }
    v0 += 256;
  }
  return result;
}
// 2CC14: variable 'v12' is possibly undefined
// 7EB9C: using guessed type int dword_7EB9C;

//----- (0002CD30) --------------------------------------------------------
int __fastcall sub_2CD30(int a1, unsigned int a2)
{
  int v4; // r4
  int v5; // r0
  int v6; // r5
  int v7; // r0
  unsigned int v8; // r4
  unsigned int v9; // r4
  int v10; // r0
  int v11; // r1
  unsigned int v12; // r6
  int v13; // r0
  unsigned int v14; // r1
  unsigned int v15; // r7
  int v16; // r5
  int result; // r0
  char *v18; // lr
  char *v19; // r3
  int v20; // t1

  v4 = sub_1E120();
  v5 = sub_1E150();
  v6 = sub_5FAF8(v4, v5);
  v7 = sub_1E150();
  v8 = sub_5F880(a2, v7);
  v9 = v8 * sub_1E100();
  v10 = sub_1E150();
  sub_5FADC(a2, v10);
  v12 = v6 * v11;
  v13 = sub_1E100();
  v14 = v13 + v9;
  v15 = v6 + v12;
  if ( v9 >= v13 + v9 )
    return 0;
  v16 = 4 * v6;
  result = 0;
  v18 = (char *)&unk_81114 + 4096 * (v9 + (a1 << 8)) + 4 * v12 + 4112;
  do
  {
    if ( v12 < v15 )
    {
      v19 = v18;
      do
      {
        v20 = *((_DWORD *)v19 + 1);
        v19 += 4;
        result += v20;
      }
      while ( v19 != &v18[v16] );
    }
    ++v9;
    v18 += 4096;
  }
  while ( v14 != v9 );
  return result;
}
// 2CD84: variable 'v11' is possibly undefined

//----- (0002CDFC) --------------------------------------------------------
int __fastcall sub_2CDFC(unsigned int a1, unsigned int a2)
{
  bool v2; // cc

  v2 = a2 > 0xFF;
  if ( a2 <= 0xFF )
    v2 = a1 > 3;
  if ( v2 )
    return 0;
  else
    return dword_81118[256 * a1 + 4 + a2];
}
// 81118: using guessed type int dword_81118[3];

//----- (0002CE20) --------------------------------------------------------
int sub_2CE20()
{
  int i; // r5
  int result; // r0
  int v2; // r7
  unsigned int j; // r4
  int v4; // r0
  int v5; // r1
  int v6; // r6
  int v7; // r3
  int v8; // r0
  char s[2088]; // [sp+10h] [bp-828h] BYREF

  if ( (unsigned int)dword_7EB9C > 4 )
  {
    strcpy(s, "\n dump domain nonce number...\n");
    sub_2E584(4, s, 0);
  }
  for ( i = 0; i != 4; ++i )
  {
    result = sub_1E29C(i);
    if ( result )
    {
      if ( (unsigned int)dword_7EB9C > 4 )
      {
        snprintf(s, 0x800u, "Chain[%d]:\n", i);
        sub_2E584(4, s, 0);
      }
      v2 = 0;
      for ( j = 0; ; ++j )
      {
        v6 = sub_1E0E0();
        v7 = sub_1E150() * v6;
        result = i;
        if ( v7 <= (int)j )
          break;
        v8 = sub_2CD30(i, j);
        v2 += v8;
        if ( (unsigned int)dword_7EB9C > 4 )
        {
          snprintf(s, 0x800u, "D[%02d]:%-10d ", j, v8);
          sub_2E584(4, s, 0);
        }
        v4 = sub_1E150();
        sub_5FD8C(j + 1, v4);
        if ( !v5 )
        {
          if ( (unsigned int)dword_7EB9C > 4 )
          {
            snprintf(s, 0x800u, "D_BIG[%02d]:%-10d\n", j >> 2, v2);
            v2 = 0;
            sub_2E584(4, s, 0);
          }
          else
          {
            v2 = 0;
          }
        }
      }
      if ( (unsigned int)dword_7EB9C > 4 )
      {
        strcpy(s, "\n");
        result = sub_2E584(4, s, 0);
      }
    }
  }
  return result;
}
// 2CEB4: variable 'v5' is possibly undefined
// 7EB9C: using guessed type int dword_7EB9C;

//----- (0002CFEC) --------------------------------------------------------
char *sub_2CFEC()
{
  return off_7EB98;
}
// 7EB98: using guessed type char *off_7EB98;

//----- (0002CFFC) --------------------------------------------------------
int __fastcall sub_2CFFC(int a1, int a2)
{
  int result; // r0
  int v5; // r6
  unsigned int v6; // r12
  int v7; // r7
  unsigned int v8; // r4
  int v9; // r3
  int v10; // r1
  char s[2]; // [sp+8h] [bp-820h] BYREF

  if ( (unsigned int)dword_7EB9C > 3 )
  {
    snprintf(s, 0x800u, "\n asic nonce number for chain[%d] asic[%d]...\n", a1, a2);
    sub_2EA54(3, s, 0);
    result = sub_1E120();
    v5 = result;
    if ( result > 0 )
      goto LABEL_3;
  }
  else
  {
    result = sub_1E120();
    v5 = result;
    if ( result > 0 )
    {
LABEL_3:
      v6 = dword_7EB9C;
      v7 = (a2 + (a1 << 8)) << 12;
      v8 = 0;
      while ( 1 )
      {
        if ( v6 > 3 )
        {
          v9 = v8;
          v10 = v7 + 4 * v8++ + 4112;
          snprintf(s, 0x800u, "core[%03d]=%-8d", v9, *(int *)((char *)dword_81118 + v10));
          sub_2EA54(3, s, 0);
          result = 3;
          v6 = dword_7EB9C;
          if ( v8 != 10 * (v8 / 0xA) || (unsigned int)dword_7EB9C <= 3 )
            goto LABEL_4;
          strcpy(s, "\n");
          result = (int)sub_2EA54(3, s, v8 % 0xA);
          v6 = dword_7EB9C;
          if ( v5 == v8 )
            goto LABEL_10;
        }
        else
        {
          ++v8;
LABEL_4:
          if ( v5 == v8 )
            goto LABEL_10;
        }
      }
    }
  }
  v6 = dword_7EB9C;
LABEL_10:
  if ( v6 > 3 )
  {
    strcpy(s, "\n");
    return (int)sub_2EA54(3, s, 0);
  }
  return result;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 81118: using guessed type int dword_81118[3];

//----- (0002D158) --------------------------------------------------------
int sub_2D158()
{
  int v0; // r4
  int v1; // r11
  int v2; // r6
  int result; // r0
  _DWORD *v4; // r0
  int v5; // r5
  char *v6; // r8
  int v7; // t1
  int v8; // r7
  int v9; // r9
  int v10; // r0
  int v11; // r1
  _DWORD *v12; // r9
  int v13; // r0
  int v14; // r0
  int v15; // [sp+18h] [bp-148h]
  int v16; // [sp+24h] [bp-13Ch]
  char s[296]; // [sp+38h] [bp-128h] BYREF

  v0 = 0;
  v1 = 0;
  v2 = 0;
  memset(s, 0, 0x100u);
  do
  {
    result = sub_1E29C(v1);
    if ( result )
    {
      v4 = (_DWORD *)unk_81114;
      if ( !unk_81114 )
      {
        v4 = sub_536F4("bmminer_nonce");
        unk_81114 = v4;
      }
      sub_54CB0(
        (int)v4,
        "asic_response.c",
        15,
        (int)"dump_nonce_info_all_core",
        24,
        538,
        20,
        (int)"\n asic nonce number for chain[%d]...\n",
        v1);
      result = sub_1E0F0();
      v16 = result;
      if ( result > 0 )
      {
        v5 = 0;
        v6 = (char *)&unk_81124 + 1024 * v1;
        do
        {
          v7 = *((_DWORD *)v6 + 1);
          v6 += 4;
          v8 = v5 + 1;
          v2 += v7;
          v9 = snprintf(&s[v0], 256 - v0, "asic[%03d]=%-8d", v5, v7);
          v10 = sub_1E100();
          result = sub_5FD8C(v5 + 1, v10);
          v0 += v9;
          if ( !v11 )
          {
            v12 = (_DWORD *)unk_81114;
            if ( !unk_81114 )
            {
              v12 = sub_536F4("bmminer_nonce");
              unk_81114 = v12;
            }
            v13 = sub_1E100();
            v15 = v2;
            v2 = 0;
            v0 = 0;
            v14 = sub_5FAF8(v5, v13);
            result = sub_54CB0(
                       (int)v12,
                       "asic_response.c",
                       15,
                       (int)"dump_nonce_info_all_core",
                       24,
                       544,
                       20,
                       (int)"domain %02d %s total=%-8u",
                       v14,
                       s,
                       v15);
          }
          ++v5;
        }
        while ( v8 != v16 );
      }
    }
    ++v1;
  }
  while ( v1 != 4 );
  return result;
}
// 2D280: variable 'v11' is possibly undefined
// 2D158: using guessed type char s[296];

//----- (0002D340) --------------------------------------------------------
int __fastcall sub_2D340(const char **a1, const char *a2, const char *a3, int a4)
{
  int result; // r0
  int v6; // r3
  const char *v7; // r2
  signed int v8; // r6
  char *v9; // r0
  int v10; // r1
  const char *v11; // r0
  char *v12; // r5
  const char *v13; // r3
  const char *v14; // r1
  __int64 v15; // r2
  int v16; // r0
  int v17; // r3
  int v18; // r2
  const char *v19; // r3
  char *v20; // r0
  int v21; // r1
  const char *v22; // r0
  char s[2072]; // [sp+20h] [bp-818h] BYREF

  result = *((unsigned __int8 *)a1 + 4);
  if ( result )
  {
    snprintf(
      s,
      0x800u,
      "List %s store can't %s() - from %s %s() line %d in %s %s():%d",
      *a1,
      "k_alloc_items",
      a2,
      a3,
      a4,
      "klist.c",
      "k_alloc_items",
      19);
    sub_2E584(3, s, 1);
    result = nullsub_1(1);
  }
  v6 = (int)a1[10];
  if ( v6 <= 0 )
  {
    v8 = (signed int)a1[9];
  }
  else
  {
    v7 = a1[6];
    if ( v6 <= (int)v7 )
      return result;
    v8 = (signed int)a1[9];
    if ( v6 < (int)&v7[v8] )
      v8 = v6 - (_DWORD)v7;
  }
  v9 = (char *)a1[13];
  v10 = (int)(a1[12] + 1);
  a1[12] = (const char *)v10;
  v11 = (const char *)realloc(v9, 4 * v10);
  a1[13] = v11;
  if ( !v11 )
  {
    snprintf(
      s,
      0x800u,
      "List %s item_memory failed to realloc count=%d in %s %s():%d",
      *a1,
      a1[12],
      "klist.c",
      "k_alloc_items",
      33);
    sub_2E584(3, s, 1);
    nullsub_1(1);
  }
  v12 = (char *)calloc(v8, 0x10u);
  if ( !v12 )
  {
    snprintf(
      s,
      0x800u,
      "List %s failed to calloc %d new items - total was %d, limit was %d in %s %s():%d",
      *a1,
      v8,
      a1[6],
      a1[10],
      "klist.c",
      "k_alloc_items",
      38);
    sub_2E584(3, s, 1);
    nullsub_1(1);
  }
  *(_DWORD *)&a1[13][4 * (_DWORD)(a1[12] + 0x3FFFFFFF)] = v12;
  v13 = a1[6];
  v14 = *a1;
  a1[7] = (const char *)v8;
  a1[8] = (const char *)v8;
  a1[6] = &v13[v8];
  *(_DWORD *)v12 = v14;
  *((_DWORD *)v12 + 1) = 0;
  *((_DWORD *)v12 + 2) = v12 + 16;
  if ( v8 > 2 )
  {
    HIDWORD(v15) = v12 + 32;
    do
    {
      LODWORD(v15) = HIDWORD(v15) - 32;
      *(_DWORD *)(HIDWORD(v15) - 16) = v14;
      *(_QWORD *)(HIDWORD(v15) - 12) = v15;
      HIDWORD(v15) += 16;
    }
    while ( (char *)HIDWORD(v15) != &v12[16 * v8] );
  }
  v16 = *((unsigned __int8 *)a1 + 44);
  v17 = 16 * (v8 + 0xFFFFFFF);
  *(_DWORD *)&v12[v17] = v14;
  a1[3] = v12;
  v18 = v17 - 16;
  v19 = &v12[v17];
  *((_DWORD *)v19 + 1) = &v12[v18];
  *((_DWORD *)v19 + 2) = 0;
  if ( v16 )
    a1[4] = v19;
  do
  {
    v20 = (char *)a1[15];
    v21 = (int)(a1[14] + 1);
    a1[14] = (const char *)v21;
    v22 = (const char *)realloc(v20, 4 * v21);
    a1[15] = v22;
    if ( !v22 )
    {
      snprintf(
        s,
        0x800u,
        "List %s data_memory failed to realloc count=%d in %s %s():%d",
        *a1,
        a1[14],
        "klist.c",
        "k_alloc_items",
        69);
      sub_2E584(3, s, 1);
      nullsub_1(1);
    }
    result = (int)calloc(1u, (size_t)a1[5]);
    *((_DWORD *)v12 + 3) = result;
    if ( !result )
    {
      snprintf(s, 0x800u, "List %s failed to calloc item data in %s %s():%d", *a1, "klist.c", "k_alloc_items", 73);
      sub_2E584(3, s, 1);
      nullsub_1(1);
      result = *((_DWORD *)v12 + 3);
    }
    *(_DWORD *)&a1[15][4 * (_DWORD)(a1[14] + 0x3FFFFFFF)] = result;
    v12 = (char *)*((_DWORD *)v12 + 2);
  }
  while ( v12 );
  return result;
}
// 2A574: using guessed type int __fastcall nullsub_1(_DWORD);

//----- (0002D724) --------------------------------------------------------
_BYTE *__fastcall sub_2D724(const char *a1, int a2, int a3, int a4, char a5, const char *a6, const char *a7, int a8)
{
  _BYTE *v12; // r4
  char *v13; // r5
  int *v15; // r0
  int *v16; // r0
  char s[2080]; // [sp+10h] [bp-820h] BYREF

  if ( a3 <= 0 )
  {
    snprintf(
      s,
      0x800u,
      "Invalid new list %s with allocate %d must be > 0 in %s %s():%d",
      a1,
      a3,
      "klist.c",
      "_k_new_list",
      100);
    sub_2E584(3, s, 1);
    nullsub_1(1);
    if ( a4 >= 0 )
      goto LABEL_3;
  }
  else if ( a4 >= 0 )
  {
    goto LABEL_3;
  }
  snprintf(
    s,
    0x800u,
    "Invalid new list %s with limit %d must be >= 0 in %s %s():%d",
    a1,
    a4,
    "klist.c",
    "_k_new_list",
    103);
  sub_2E584(3, s, 1);
  nullsub_1(1);
LABEL_3:
  v12 = calloc(1u, 0x40u);
  if ( !v12 )
  {
    snprintf(s, 0x800u, "Failed to calloc list %s in %s %s():%d", a1, "klist.c", "_k_new_list", 107);
    sub_2E584(3, s, 1);
    nullsub_1(1);
  }
  v12[4] = 0;
  v13 = (char *)calloc(1u, 0x38u);
  *((_DWORD *)v12 + 2) = v13;
  if ( !v13 )
  {
    snprintf(s, 0x800u, "Failed to calloc lock for list %s in %s %s():%d", a1, "klist.c", "_k_new_list", 113);
    sub_2E584(3, s, 1);
    nullsub_1(1);
    v13 = (char *)*((_DWORD *)v12 + 2);
  }
  if ( pthread_mutex_init((pthread_mutex_t *)v13, 0) )
  {
    v16 = _errno_location();
    snprintf(s, 0x800u, "Failed to pthread_mutex_init errno=%d in %s %s():%d", *v16, "klist.c", "_k_new_list", 115);
    sub_2E584(3, s, 1);
    nullsub_1(1);
  }
  if ( pthread_rwlock_init((pthread_rwlock_t *)(v13 + 24), 0) )
  {
    v15 = _errno_location();
    snprintf(s, 0x800u, "Failed to pthread_rwlock_init errno=%d in %s %s():%d", *v15, "klist.c", "_k_new_list", 115);
    sub_2E584(3, s, 1);
    nullsub_1(1);
  }
  *(_DWORD *)v12 = a1;
  *((_DWORD *)v12 + 5) = a2;
  *((_DWORD *)v12 + 9) = a3;
  *((_DWORD *)v12 + 10) = a4;
  v12[44] = a5;
  sub_2D340((const char **)v12, a6, a7, a8);
  return v12;
}
// 2A574: using guessed type int __fastcall nullsub_1(_DWORD);

//----- (0002D9D4) --------------------------------------------------------
int __fastcall sub_2D9D4(int a1, const char *a2, const char *a3, int a4)
{
  int v5; // r12
  int v6; // r3
  int result; // r0

  v5 = *(_DWORD *)(a1 + 12);
  if ( !v5 )
  {
    if ( *(_BYTE *)(a1 + 4) )
      return 0;
    sub_2D340((const char **)a1, a2, a3, a4);
    v5 = *(_DWORD *)(a1 + 12);
    if ( !v5 )
      return 0;
  }
  v6 = *(_DWORD *)(v5 + 8);
  *(_DWORD *)(a1 + 12) = v6;
  if ( v6 )
  {
    *(_DWORD *)(v6 + 4) = 0;
  }
  else if ( *(_BYTE *)(a1 + 44) )
  {
    *(_DWORD *)(a1 + 16) = 0;
  }
  result = v5;
  *(_DWORD *)(v5 + 8) = 0;
  *(_DWORD *)(v5 + 4) = 0;
  --*(_DWORD *)(a1 + 28);
  return result;
}

//----- (0002DA5C) --------------------------------------------------------
int __fastcall sub_2DA5C(int a1, const char *a2, const char *a3, int a4)
{
  int v5; // r0
  int v6; // r4

  v5 = sub_2D9D4(a1, a2, a3, a4);
  v6 = v5;
  if ( v5 )
    memset(*(void **)(v5 + 12), 0, *(_DWORD *)(a1 + 20));
  return v6;
}

//----- (0002DA88) --------------------------------------------------------
int __fastcall sub_2DA88(int a1, const char *a2, const char *a3, int a4)
{
  int result; // r0
  int v6; // r3
  char s[2064]; // [sp+20h] [bp-810h] BYREF

  if ( !*(_BYTE *)(a1 + 44) )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d",
      *(const char **)a1,
      "_k_unlink_tail",
      a2,
      a3,
      a4,
      "klist.c",
      "_k_unlink_tail",
      181);
    sub_2E584(3, s, 1);
    nullsub_1(1);
  }
  result = *(_DWORD *)(a1 + 16);
  if ( result )
  {
    v6 = *(_DWORD *)(result + 4);
    *(_DWORD *)(a1 + 16) = v6;
    if ( v6 )
      a3 = 0;
    else
      *(_DWORD *)(a1 + 12) = 0;
    if ( v6 )
      *(_DWORD *)(v6 + 8) = a3;
    *(_DWORD *)(result + 8) = 0;
    *(_DWORD *)(result + 4) = 0;
    --*(_DWORD *)(a1 + 28);
  }
  return result;
}
// 2DAC4: variable 'a3' is possibly undefined
// 2A574: using guessed type int __fastcall nullsub_1(_DWORD);

//----- (0002DB50) --------------------------------------------------------
const char *__fastcall sub_2DB50(int a1, int a2, const char *a3, const char *a4, int a5)
{
  const char *result; // r0
  int v8; // r3
  int v9; // r3
  __int64 v10; // r2
  char s[2064]; // [sp+20h] [bp-810h] BYREF

  result = *(const char **)a2;
  if ( *(_DWORD *)a2 != *(_DWORD *)a1 )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      *(const char **)a1,
      "_k_add_head",
      result,
      a3,
      a4,
      a5,
      "klist.c",
      "_k_add_head",
      205);
    sub_2E584(3, s, 1);
    result = (const char *)nullsub_1(1);
  }
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(a1 + 12);
  v8 = *(_DWORD *)(a1 + 12);
  if ( v8 )
    *(_DWORD *)(v8 + 4) = a2;
  v9 = *(unsigned __int8 *)(a1 + 44);
  *(_DWORD *)(a1 + 12) = a2;
  if ( v9 && !*(_DWORD *)(a1 + 16) )
    *(_DWORD *)(a1 + 16) = a2;
  v10 = *(_QWORD *)(a1 + 28);
  LODWORD(v10) = v10 + 1;
  ++HIDWORD(v10);
  *(_QWORD *)(a1 + 28) = v10;
  return result;
}
// 2A574: using guessed type int __fastcall nullsub_1(_DWORD);

//----- (0002DC24) --------------------------------------------------------
const char **__fastcall sub_2DC24(const char **result, int a2, const char *a3, const char *a4, int a5)
{
  const char *v7; // r1
  const char **v8; // r4
  const char *v10; // r3
  const char *v11; // r3
  const char *v12; // r3
  bool v13; // zf
  __int64 v14; // r2
  char s[2072]; // [sp+20h] [bp-818h] BYREF

  v7 = *(const char **)a2;
  v8 = result;
  if ( v7 != *result )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      *result,
      "_k_add_tail",
      v7,
      a3,
      a4,
      a5,
      "klist.c",
      "_k_add_tail",
      236);
    sub_2E584(3, s, 1);
    result = (const char **)nullsub_1(1);
  }
  if ( !*((_BYTE *)v8 + 44) )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d",
      *v8,
      "_k_add_tail",
      a3,
      a4,
      a5,
      "klist.c",
      "_k_add_tail",
      241);
    sub_2E584(3, s, 1);
    result = (const char **)nullsub_1(1);
  }
  v10 = v8[4];
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 4) = v10;
  v11 = v8[4];
  if ( v11 )
    *((_DWORD *)v11 + 2) = a2;
  v12 = v8[3];
  v8[4] = (const char *)a2;
  v13 = v12 == 0;
  v14 = *(_QWORD *)(v8 + 7);
  if ( v13 )
    v8[3] = (const char *)a2;
  LODWORD(v14) = v14 + 1;
  ++HIDWORD(v14);
  *(_QWORD *)(v8 + 7) = v14;
  return result;
}
// 2A574: using guessed type int __fastcall nullsub_1(_DWORD);

//----- (0002DD70) --------------------------------------------------------
const char **__fastcall sub_2DD70(const char **result, int a2, int a3, const char *a4, const char *a5, int a6)
{
  const char *v8; // r1
  const char **v9; // r4
  int v11; // r3
  __int64 v12; // r2
  char s[2072]; // [sp+20h] [bp-818h] BYREF

  v8 = *(const char **)a2;
  v9 = result;
  if ( v8 != *result )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      *result,
      "_k_insert_before",
      v8,
      a4,
      a5,
      a6,
      "klist.c",
      "_k_insert_before",
      262);
    sub_2E584(3, s, 1);
    result = (const char **)nullsub_1(1);
  }
  if ( !a3 )
  {
    snprintf(
      s,
      0x800u,
      "%s() (%s) can't before a null item - from %s %s() line %d in %s %s():%d",
      "_k_insert_before",
      *v9,
      a4,
      a5,
      a6,
      "klist.c",
      "_k_insert_before",
      267);
    sub_2E584(3, s, 1);
    result = (const char **)nullsub_1(1);
  }
  *(_DWORD *)(a2 + 8) = a3;
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(a3 + 4);
  v11 = *(_DWORD *)(a3 + 4);
  if ( v11 )
    *(_DWORD *)(v11 + 8) = a2;
  else
    v9[3] = (const char *)a2;
  *(_DWORD *)(a3 + 4) = a2;
  v12 = *(_QWORD *)(v9 + 7);
  LODWORD(v12) = v12 + 1;
  ++HIDWORD(v12);
  *(_QWORD *)(v9 + 7) = v12;
  return result;
}
// 2A574: using guessed type int __fastcall nullsub_1(_DWORD);

//----- (0002DEB8) --------------------------------------------------------
const char **__fastcall sub_2DEB8(const char **result, int a2, int a3, const char *a4, const char *a5, int a6)
{
  const char *v8; // r1
  const char **v9; // r4
  int v11; // r3
  __int64 v12; // r2
  char s[2072]; // [sp+20h] [bp-818h] BYREF

  v8 = *(const char **)a2;
  v9 = result;
  if ( v8 != *result )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      *result,
      "_k_insert_after",
      v8,
      a4,
      a5,
      a6,
      "klist.c",
      "_k_insert_after",
      286);
    sub_2E584(3, s, 1);
    result = (const char **)nullsub_1(1);
  }
  if ( !a3 )
  {
    snprintf(
      s,
      0x800u,
      "%s() (%s) can't after a null item - from %s %s() line %d in %s %s():%d",
      "_k_insert_after",
      *v9,
      a4,
      a5,
      a6,
      "klist.c",
      "_k_insert_after",
      291);
    sub_2E584(3, s, 1);
    result = (const char **)nullsub_1(1);
  }
  *(_DWORD *)(a2 + 4) = a3;
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(a3 + 8);
  v11 = *(_DWORD *)(a3 + 8);
  if ( v11 )
  {
    *(_DWORD *)(v11 + 4) = a2;
  }
  else if ( *((_BYTE *)v9 + 44) )
  {
    v9[4] = (const char *)a2;
  }
  *(_DWORD *)(a3 + 8) = a2;
  v12 = *(_QWORD *)(v9 + 7);
  LODWORD(v12) = v12 + 1;
  ++HIDWORD(v12);
  *(_QWORD *)(v9 + 7) = v12;
  return result;
}
// 2A574: using guessed type int __fastcall nullsub_1(_DWORD);

//----- (0002E00C) --------------------------------------------------------
const char *__fastcall sub_2E00C(int a1, int a2, const char *a3, const char *a4, int a5)
{
  const char *result; // r0
  __int64 v8; // r2
  char s[2064]; // [sp+20h] [bp-810h] BYREF

  result = *(const char **)a2;
  if ( *(_DWORD *)a2 != *(_DWORD *)a1 )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      *(const char **)a1,
      "_k_unlink_item",
      result,
      a3,
      a4,
      a5,
      "klist.c",
      "_k_unlink_item",
      312);
    sub_2E584(3, s, 1);
    result = (const char *)nullsub_1(1);
  }
  v8 = *(_QWORD *)(a2 + 4);
  if ( (_DWORD)v8 )
  {
    *(_DWORD *)(v8 + 8) = HIDWORD(v8);
    HIDWORD(v8) = *(_DWORD *)(a2 + 8);
  }
  if ( HIDWORD(v8) )
    *(_DWORD *)(HIDWORD(v8) + 4) = *(_DWORD *)(a2 + 4);
  if ( *(_DWORD *)(a1 + 12) == a2 )
    *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 8);
  if ( *(_BYTE *)(a1 + 44) && *(_DWORD *)(a1 + 16) == a2 )
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 4) = 0;
  --*(_DWORD *)(a1 + 28);
  return result;
}
// 2A574: using guessed type int __fastcall nullsub_1(_DWORD);

//----- (0002E0F8) --------------------------------------------------------
const char *__fastcall sub_2E0F8(const char **a1, int a2, const char *a3, const char *a4, int a5)
{
  const char *result; // r0
  const char *v9; // r1
  int v11; // r2
  const char *v12; // r3
  const char *v13; // r1
  char s[2072]; // [sp+20h] [bp-818h] BYREF

  result = *a1;
  v9 = *(const char **)a2;
  if ( result != v9 )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() to a %s list - from %s %s() line %d in %s %s():%d",
      result,
      "_k_list_transfer_to_head",
      v9,
      a3,
      a4,
      a5,
      "klist.c",
      "_k_list_transfer_to_head",
      338);
    sub_2E584(3, s, 1);
    result = (const char *)nullsub_1(1);
  }
  if ( !*((_BYTE *)a1 + 44) )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d",
      *a1,
      "_k_list_transfer_to_head",
      a3,
      a4,
      a5,
      "klist.c",
      "_k_list_transfer_to_head",
      343);
    sub_2E584(3, s, 1);
    result = (const char *)nullsub_1(1);
  }
  if ( a1[3] )
  {
    v11 = *(_DWORD *)(a2 + 12);
    v12 = a1[4];
    if ( v11 )
      *(_DWORD *)(v11 + 4) = v12;
    else
      *(_DWORD *)(a2 + 16) = v12;
    if ( v11 )
      v11 = *(_DWORD *)(a2 + 12);
    *((_DWORD *)a1[4] + 2) = v11;
    *(_DWORD *)(a2 + 12) = a1[3];
    a1[4] = 0;
    v13 = a1[7];
    a1[3] = 0;
    *(_DWORD *)(a2 + 28) += v13;
    a1[7] = 0;
    *(_DWORD *)(a2 + 32) += a1[8];
    a1[8] = 0;
  }
  return result;
}
// 2A574: using guessed type int __fastcall nullsub_1(_DWORD);

//----- (0002E268) --------------------------------------------------------
const char *__fastcall sub_2E268(const char **a1, int a2, const char *a3, const char *a4, int a5)
{
  const char *result; // r0
  const char *v9; // r1
  const char *v11; // r3
  int v12; // r2
  const char *v13; // r1
  char s[2072]; // [sp+20h] [bp-818h] BYREF

  result = *a1;
  v9 = *(const char **)a2;
  if ( result != v9 )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() to a %s list - from %s %s() line %d in %s %s():%d",
      result,
      "_k_list_transfer_to_tail",
      v9,
      a3,
      a4,
      a5,
      "klist.c",
      "_k_list_transfer_to_tail",
      368);
    sub_2E584(3, s, 1);
    result = (const char *)nullsub_1(1);
  }
  if ( !*((_BYTE *)a1 + 44) )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d",
      *a1,
      "_k_list_transfer_to_tail",
      a3,
      a4,
      a5,
      "klist.c",
      "_k_list_transfer_to_tail",
      373);
    sub_2E584(3, s, 1);
    result = (const char *)nullsub_1(1);
  }
  v11 = a1[3];
  if ( v11 )
  {
    v12 = *(_DWORD *)(a2 + 16);
    if ( v12 )
      *(_DWORD *)(v12 + 8) = v11;
    else
      *(_DWORD *)(a2 + 12) = v11;
    if ( v12 )
      v12 = *(_DWORD *)(a2 + 16);
    *((_DWORD *)a1[3] + 1) = v12;
    *(_DWORD *)(a2 + 16) = a1[4];
    a1[4] = 0;
    v13 = a1[7];
    a1[3] = 0;
    *(_DWORD *)(a2 + 28) += v13;
    a1[7] = 0;
    *(_DWORD *)(a2 + 32) += a1[8];
    a1[8] = 0;
  }
  return result;
}
// 2A574: using guessed type int __fastcall nullsub_1(_DWORD);

//----- (0002E3D4) --------------------------------------------------------
int __fastcall sub_2E3D4(const char **a1, const char *a2, const char *a3, int a4)
{
  int v5; // r5
  void *v6; // r0
  int v7; // r5
  void *v8; // r0
  char *v9; // r5
  char s[2064]; // [sp+20h] [bp-810h] BYREF

  if ( *((_BYTE *)a1 + 4) )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() a store - from %s %s() line %d in %s %s():%d",
      *a1,
      "_k_free_list",
      a2,
      a3,
      a4,
      "klist.c",
      "_k_free_list",
      400);
    sub_2E584(3, s, 1);
    nullsub_1(1);
  }
  if ( (int)a1[12] > 0 )
  {
    v5 = 0;
    do
    {
      v6 = *(void **)&a1[13][4 * v5++];
      free(v6);
    }
    while ( (int)a1[12] > v5 );
  }
  free((void *)a1[13]);
  if ( (int)a1[14] > 0 )
  {
    v7 = 0;
    do
    {
      v8 = *(void **)&a1[15][4 * v7++];
      free(v8);
    }
    while ( (int)a1[14] > v7 );
  }
  free((void *)a1[15]);
  v9 = (char *)a1[2];
  pthread_rwlock_destroy((pthread_rwlock_t *)(v9 + 24));
  pthread_mutex_destroy((pthread_mutex_t *)v9);
  free((void *)a1[2]);
  free(a1);
  return 0;
}
// 2A574: using guessed type int __fastcall nullsub_1(_DWORD);

//----- (0002E4F0) --------------------------------------------------------
int __fastcall sub_2E4F0(void *ptr, const char *a2, const char *a3, int a4)
{
  char s[2064]; // [sp+20h] [bp-810h] BYREF

  if ( !*((_BYTE *)ptr + 4) )
  {
    snprintf(
      s,
      0x800u,
      "Store %s can't %s() the list - from %s %s() line %d in %s %s():%d",
      *(const char **)ptr,
      "_k_free_store",
      a2,
      a3,
      a4,
      "klist.c",
      "_k_free_store",
      424);
    sub_2E584(3, s, 1);
    nullsub_1(1);
  }
  free(ptr);
  return 0;
}
// 2A574: using guessed type int __fastcall nullsub_1(_DWORD);

//----- (0002E584) --------------------------------------------------------
int __fastcall sub_2E584(int a1, const char *a2, int a3)
{
  _DWORD *v5; // r0
  int result; // r0
  int v8; // r4
  struct tm *v9; // r0
  int v10; // r0
  FILE *v11; // r6
  size_t v12; // r0
  size_t v13; // r0
  _DWORD *v14; // r0
  int v15; // r7
  time_t timer; // [sp+1Ch] [bp-6Ch] BYREF
  __time_t v17; // [sp+20h] [bp-68h] BYREF
  int v18; // [sp+24h] [bp-64h]
  char s[96]; // [sp+28h] [bp-60h] BYREF

  if ( byte_590404 )
  {
    syslog(a1 | 0x80, "%s", a2);
    v5 = (_DWORD *)dword_48212C;
    if ( !dword_48212C )
    {
      v5 = sub_536F4("bmminer_miner");
      dword_48212C = (int)v5;
    }
    return sub_54CB0((int)v5, "logging.c", 9, (int)"_applog", 7, 71, 60, (int)"%s", a2);
  }
  else
  {
    v17 = (unsigned __int8)byte_590404;
    v18 = (unsigned __int8)byte_590404;
    sub_302A0(&v17);
    timer = v17;
    v8 = v18 / 1000;
    v9 = localtime(&timer);
    snprintf(
      s,
      0x40u,
      " [%d-%02d-%02d %02d:%02d:%02d.%03d] ",
      v9->tm_year + 1900,
      v9->tm_mon + 1,
      v9->tm_mday,
      v9->tm_hour,
      v9->tm_min,
      v9->tm_sec,
      v8);
    v10 = fileno((FILE *)stderr);
    if ( !isatty(v10) )
    {
      fprintf((FILE *)stderr, "%s%s\n", s, a2);
      fflush((FILE *)stderr);
    }
    if ( byte_482130 )
    {
      v11 = (FILE *)dword_482134;
      if ( dword_482134 || (v11 = (FILE *)fopen64(byte_482158, &word_482138), (dword_482134 = (int)v11) != 0) )
      {
        v12 = strlen(s);
        fwrite(s, v12, 1u, v11);
        v13 = strlen(a2);
        fwrite(a2, v13, 1u, (FILE *)dword_482134);
        fwrite(&word_6A02C, 1u, 1u, (FILE *)dword_482134);
        fflush((FILE *)dword_482134);
      }
    }
    v14 = (_DWORD *)dword_48212C;
    if ( !dword_48212C )
    {
      v14 = sub_536F4("bmminer_miner");
      dword_48212C = (int)v14;
    }
    result = sub_54CB0((int)v14, "logging.c", 9, (int)"_applog", 7, 117, 60, (int)"%s", a2);
    if ( a1 == 3 )
      v15 = 0;
    else
      v15 = byte_58E350 & 1;
    if ( !v15 )
      return sub_2E92C(s, a2, a3);
  }
  return result;
}
// 124E4: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 6A02C: using guessed type __int16 word_6A02C;
// 7F790: using guessed type int stderr;
// 48212C: using guessed type int dword_48212C;
// 482130: using guessed type char byte_482130;
// 482134: using guessed type int dword_482134;
// 482138: using guessed type __int16 word_482138;
// 58E350: using guessed type char byte_58E350;
// 590404: using guessed type char byte_590404;

//----- (0002E828) --------------------------------------------------------
int __fastcall sub_2E828(int a1)
{
  int result; // r0
  int *v3; // r0
  char s[2056]; // [sp+10h] [bp-808h] BYREF

  result = pthread_mutex_unlock(&stru_59450C);
  if ( result )
  {
    v3 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v3, "logging.c", "my_log_curses", a1);
    sub_2E584(3, s, 1);
    return nullsub_1(1);
  }
  return result;
}
// 2A574: using guessed type int __fastcall nullsub_1(_DWORD);
// 59450C: using guessed type pthread_mutex_t stru_59450C;

//----- (0002E8A4) --------------------------------------------------------
int sub_2E8A4()
{
  int result; // r0
  int *v1; // r0
  char s[2056]; // [sp+10h] [bp-808h] BYREF

  result = pthread_mutex_lock(&stru_59450C);
  if ( result )
  {
    v1 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v1, "logging.c", "my_log_curses", 53);
    sub_2E584(3, s, 1);
    return nullsub_1(1);
  }
  return result;
}
// 2A574: using guessed type int __fastcall nullsub_1(_DWORD);
// 59450C: using guessed type pthread_mutex_t stru_59450C;

//----- (0002E92C) --------------------------------------------------------
int __fastcall sub_2E92C(const char *a1, const char *a2, int a3)
{
  int v6; // r0

  if ( a3 )
  {
    pthread_mutex_trylock(&stru_59450C);
    v6 = sub_2E828(42);
    off_7ECC4(v6);
  }
  sub_2E8A4();
  printf("%s%s%s", a1, a2, "                    \n");
  sub_2E828(55);
  return ((int (__fastcall *)())off_7ECC4)();
}
// 7ECC4: using guessed type int (__fastcall *off_7ECC4)(_DWORD);
// 59450C: using guessed type pthread_mutex_t stru_59450C;

//----- (0002E9A4) --------------------------------------------------------
void __fastcall sub_2E9A4(int a1, const char *a2, int a3)
{
  int v6; // r0
  int v7; // r0

  if ( byte_590404 )
  {
    syslog(a1 | 0x80, "%s", a2);
  }
  else
  {
    v6 = fileno((FILE *)stderr);
    if ( !isatty(v6) )
    {
      fprintf((FILE *)stderr, "%s\n", a2);
      fflush((FILE *)stderr);
    }
    if ( a1 == 3 )
      v7 = 0;
    else
      v7 = byte_58E350 & 1;
    if ( !v7 )
      sub_2E92C("", a2, a3);
  }
}
// 7F790: using guessed type int stderr;
// 58E350: using guessed type char byte_58E350;
// 590404: using guessed type char byte_590404;

//----- (0002EA54) --------------------------------------------------------
char *__fastcall sub_2EA54(int a1, const char *a2, int a3)
{
  size_t v6; // r5
  _DWORD *v7; // r0
  char *result; // r0
  char *v9; // r2
  int v10; // r3
  int v11; // t1
  bool v12; // zf
  _DWORD *v13; // r0
  int v14; // r0
  FILE *v15; // r5
  size_t v16; // r0
  _DWORD *v17; // r0
  int v18; // r7
  int v19; // r0
  FILE *v20; // r5
  size_t v21; // r0
  _DWORD *v22; // r0
  int v23; // r3

  v6 = strlen(&ptr);
  if ( v6 + strlen(a2) + 1 >= 0x800 )
  {
    if ( byte_590404 )
    {
      syslog(a1 | 0x80, "%s", &ptr);
      v7 = (_DWORD *)dword_482A58;
      if ( !dword_482A58 )
      {
        v7 = sub_536F4("bmminer_miner");
        dword_482A58 = (int)v7;
      }
      sub_54CB0((int)v7, "logging.c", 9, (int)"_applawlog", 10, 167, 60, (int)"%s", &ptr);
    }
    else
    {
      v19 = fileno((FILE *)stderr);
      if ( !isatty(v19) )
      {
        fputs(&ptr, (FILE *)stderr);
        fflush((FILE *)stderr);
      }
      if ( byte_482130 )
      {
        v20 = (FILE *)dword_482134;
        if ( dword_482134 || (v20 = (FILE *)fopen64(byte_482158, &word_482138), (dword_482134 = (int)v20) != 0) )
        {
          v21 = strlen(&ptr);
          fwrite(&ptr, v21, 1u, v20);
          fflush((FILE *)dword_482134);
        }
      }
      v22 = (_DWORD *)dword_482A58;
      if ( !dword_482A58 )
      {
        v22 = sub_536F4("bmminer_miner");
        dword_482A58 = (int)v22;
      }
      sub_54CB0((int)v22, "logging.c", 9, (int)"_applawlog", 10, 195, 60, (int)"%s", &ptr);
      if ( a1 == 3 )
        v23 = 0;
      else
        v23 = byte_58E350 & 1;
      if ( !v23 )
        sub_2E92C("", &ptr, a3);
    }
    ptr = 0;
  }
  result = strcat(&ptr, a2);
  v9 = &ptr;
  while ( 1 )
  {
    v11 = (unsigned __int8)*v9++;
    v10 = v11;
    v12 = v11 == 13;
    if ( v11 != 13 )
      v12 = v10 == 10;
    if ( v12 )
      break;
    if ( !v10 )
      return result;
  }
  if ( byte_590404 )
  {
    syslog(a1 | 0x80, "%s", &ptr);
    v13 = (_DWORD *)dword_482A58;
    if ( !dword_482A58 )
    {
      v13 = sub_536F4("bmminer_miner");
      dword_482A58 = (int)v13;
    }
    result = (char *)sub_54CB0((int)v13, "logging.c", 9, (int)"_applawlog", 10, 205, 60, (int)"%s", &ptr);
  }
  else
  {
    v14 = fileno((FILE *)stderr);
    if ( !isatty(v14) )
    {
      fputs(&ptr, (FILE *)stderr);
      fflush((FILE *)stderr);
    }
    if ( byte_482130 )
    {
      v15 = (FILE *)dword_482134;
      if ( dword_482134 || (v15 = (FILE *)fopen64(byte_482158, &word_482138), (dword_482134 = (int)v15) != 0) )
      {
        v16 = strlen(&ptr);
        fwrite(&ptr, v16, 1u, v15);
        fflush((FILE *)dword_482134);
      }
    }
    v17 = (_DWORD *)dword_482A58;
    if ( !dword_482A58 )
    {
      v17 = sub_536F4("bmminer_miner");
      dword_482A58 = (int)v17;
    }
    result = (char *)sub_54CB0((int)v17, "logging.c", 9, (int)"_applawlog", 10, 233, 60, (int)"%s", &ptr);
    if ( a1 == 3 )
      v18 = 0;
    else
      v18 = byte_58E350 & 1;
    if ( !v18 )
      result = (char *)sub_2E92C("", &ptr, a3);
  }
  ptr = 0;
  return result;
}
// 124E4: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 7F790: using guessed type int stderr;
// 482130: using guessed type char byte_482130;
// 482134: using guessed type int dword_482134;
// 482138: using guessed type __int16 word_482138;
// 482A58: using guessed type int dword_482A58;
// 58E350: using guessed type char byte_58E350;
// 590404: using guessed type char byte_590404;

//----- (0002EE28) --------------------------------------------------------
int __fastcall sub_2EE28(int result, unsigned __int8 *a2, int a3)
{
  unsigned __int8 *v3; // r0
  int *v4; // lr
  int *v5; // r12
  int v6; // r3
  int v7; // r4
  int v8; // r1
  int v9; // t1
  unsigned int v10; // lr
  int *v11; // r3
  unsigned int v12; // t1
  int v13; // r0
  int *v14; // r3
  int *v15; // r2
  int v16; // t1
  int v17; // r6
  int v18; // r3
  int v19; // r4
  int v20; // r10
  int v21; // r9
  int v22; // r5
  int v23; // r8
  int v24; // r7
  int v25; // r11
  int v26; // r2
  int v27; // r12
  int v28; // r3
  int v29; // lr
  int v30; // r1
  int *v31; // r1
  int *v32; // r3
  int v33; // t1
  bool v34; // zf
  unsigned __int8 *v35; // [sp+4h] [bp-164h]
  int *v36; // [sp+8h] [bp-160h]
  unsigned __int8 *v37; // [sp+14h] [bp-154h]
  int v38; // [sp+18h] [bp-150h]
  int v39; // [sp+1Ch] [bp-14Ch] BYREF
  int v40; // [sp+20h] [bp-148h]
  int v41; // [sp+24h] [bp-144h]
  int v42; // [sp+28h] [bp-140h]
  int v43; // [sp+2Ch] [bp-13Ch]
  int v44; // [sp+30h] [bp-138h]
  int v45; // [sp+34h] [bp-134h]
  int v46; // [sp+38h] [bp-130h]
  int v47; // [sp+3Ch] [bp-12Ch] BYREF
  int v48[15]; // [sp+40h] [bp-128h] BYREF
  char v49; // [sp+7Ch] [bp-ECh] BYREF
  char v50; // [sp+100h] [bp-68h] BYREF

  if ( a3 > 0 )
  {
    v38 = result + 136;
    v35 = a2;
    v37 = &a2[64 * a3];
    v39 = result + 168;
    do
    {
      v3 = v35;
      v4 = &v47;
      v5 = v48;
      do
      {
        v6 = v3[1];
        v7 = v3[2];
        v8 = v3[3];
        v9 = *v3;
        v3 += 4;
        v4[1] = (v6 << 16) | (v7 << 8) | v8 | (v9 << 24);
        ++v4;
      }
      while ( &v49 != (char *)v4 );
      do
      {
        v10 = v5[14];
        v11 = v5;
        v12 = v5[1];
        ++v5;
        v5[15] = (__ROR4__(v10, 19) ^ __ROR4__(v10, 17) ^ (v10 >> 10))
               + v11[9]
               + *v11
               + (__ROR4__(v12, 18) ^ __ROR4__(v12, 7) ^ (v12 >> 3));
      }
      while ( &v50 != (char *)v5 );
      v13 = v39;
      v14 = &v39;
      v15 = (int *)v38;
      do
      {
        v16 = *v15++;
        v14[1] = v16;
        ++v14;
      }
      while ( (int *)v13 != v15 );
      v36 = v15;
      v17 = 0;
      v18 = v47;
      v19 = v44;
      v20 = v45;
      v21 = v46;
      v22 = v40;
      v23 = v41;
      v24 = v42;
      v25 = v43;
      while ( 1 )
      {
        v26 = (__ROR4__(v19, 11) ^ __ROR4__(v19, 6) ^ __ROR4__(v19, 25)) + (v21 & ~v19 ^ v20 & v19) + v48[v17];
        v27 = dword_7EBA4[v17++];
        v28 = v26 + v27 + v18;
        v29 = v25 + v28;
        v30 = (__ROR4__(v22, 13) ^ __ROR4__(v22, 2) ^ __ROR4__(v22, 22)) + ((v24 ^ v23) & v22 ^ v24 & v23) + v28;
        v25 = v24;
        v18 = v21;
        if ( v17 == 64 )
          break;
        v24 = v23;
        v21 = v20;
        v23 = v22;
        v20 = v19;
        v22 = v30;
        v19 = v29;
      }
      v40 = v30;
      v31 = &v39;
      v32 = (int *)v38;
      v47 = v21;
      v44 = v29;
      v45 = v19;
      v46 = v20;
      v41 = v22;
      v42 = v23;
      v43 = v24;
      do
      {
        result = *v32;
        v33 = v31[1];
        ++v31;
        *v32++ += v33;
      }
      while ( v36 != v32 );
      v34 = v37 == v35 + 64;
      v35 += 64;
    }
    while ( !v34 );
  }
  return result;
}
// 7EBA4: using guessed type _DWORD dword_7EBA4[63];
// 2EE28: using guessed type _DWORD var_128[15];

//----- (0002F024) --------------------------------------------------------
_DWORD *__fastcall sub_2F024(_DWORD *result)
{
  _DWORD *v1; // r2
  _DWORD *v2; // r3
  int v3; // t1

  v1 = &unk_7ECA0;
  v2 = result + 34;
  do
  {
    v3 = v1[1];
    ++v1;
    *v2++ = v3;
  }
  while ( v2 != result + 42 );
  result[1] = 0;
  *result = 0;
  return result;
}

//----- (0002F054) --------------------------------------------------------
void *__fastcall sub_2F054(unsigned __int8 *a1, char *a2, size_t n)
{
  int v4; // r0
  size_t v7; // r2
  unsigned __int8 *v8; // r0
  size_t v9; // r6
  void *result; // r0
  size_t v11; // r3
  size_t v12; // r5
  unsigned __int8 *v13; // r6
  int v14; // r3

  v4 = *((_DWORD *)a1 + 1);
  v7 = 64 - v4;
  v8 = &a1[v4 + 8];
  if ( v7 >= n )
    v9 = n;
  else
    v9 = v7;
  result = memcpy(v8, a2, v9);
  v11 = n + *((_DWORD *)a1 + 1);
  if ( v11 > 0x3F )
  {
    v12 = n - v9;
    v13 = (unsigned __int8 *)&a2[v9];
    sub_2EE28((int)a1, a1 + 8, 1);
    sub_2EE28((int)a1, v13, v12 >> 6);
    result = memcpy(a1 + 8, &v13[v12 & 0xFFFFFFC0], v12 & 0x3F);
    v14 = *(_DWORD *)a1;
    *((_DWORD *)a1 + 1) = v12 & 0x3F;
    *(_DWORD *)a1 = v14 + (((v12 >> 6) + 1) << 6);
  }
  else
  {
    *((_DWORD *)a1 + 1) = v11;
  }
  return result;
}

//----- (0002F100) --------------------------------------------------------
int __fastcall sub_2F100(_DWORD *a1, _BYTE *a2)
{
  int v2; // r8
  int v3; // r9
  int v4; // r10
  int v5; // r11
  int v6; // r3
  unsigned __int8 *v9; // r6
  bool v10; // cf
  int v11; // r2
  int v12; // r7
  size_t v13; // r2
  unsigned __int8 *v14; // r0
  int v15; // r3
  int v16; // r7
  int result; // r0
  int *v18; // r3
  int *v19; // r5
  int v20; // t1
  int v21; // [sp+4h] [bp-2Ch]

  v6 = a1[1];
  v9 = (unsigned __int8 *)(a1 + 2);
  v10 = (v6 & 0x3Fu) >= 0x38;
  if ( (v6 & 0x3Fu) >= 0x38 )
    v11 = 128;
  else
    v11 = 64;
  v12 = v6 + *a1;
  v13 = v11 - v6;
  v14 = &v9[v6];
  if ( (v6 & 0x3Fu) >= 0x38 )
    v15 = 124;
  else
    v15 = 60;
  v16 = 8 * v12;
  if ( !v10 )
    v2 = 61;
  v21 = v15;
  if ( v10 )
    v2 = 125;
  else
    v3 = 62;
  if ( v10 )
    v3 = 126;
  else
    v4 = 63;
  if ( v10 )
    v4 = 127;
  else
    v5 = 1;
  if ( v10 )
    v5 = 2;
  memset(v14, 0, v13);
  *((_BYTE *)a1 + a1[1] + 8) = 0x80;
  v9[v4] = v16;
  v9[v3] = BYTE1(v16);
  v9[v2] = BYTE2(v16);
  v9[v21] = HIBYTE(v16);
  result = sub_2EE28((int)a1, v9, v5);
  v18 = a1 + 34;
  v19 = a1 + 42;
  do
  {
    a2[3] = *v18;
    v20 = *v18++;
    a2[2] = BYTE1(v20);
    a2[1] = *((_WORD *)v18 - 1);
    *a2 = *((_BYTE *)v18 - 1);
    a2 += 4;
  }
  while ( v19 != v18 );
  return result;
}
// 2F194: variable 'v4' is possibly undefined
// 2F19C: variable 'v3' is possibly undefined
// 2F1A0: variable 'v2' is possibly undefined
// 2F1AC: variable 'v5' is possibly undefined

//----- (0002F1EC) --------------------------------------------------------
int __fastcall sub_2F1EC(char *a1, size_t n, _BYTE *a3)
{
  _DWORD *v3; // r3
  char *v5; // r2
  int v6; // t1
  _DWORD v8[34]; // [sp+0h] [bp-B8h] BYREF
  char v9; // [sp+88h] [bp-30h] BYREF

  v3 = &unk_7ECA0;
  v5 = &v9;
  do
  {
    v6 = v3[1];
    ++v3;
    *(_DWORD *)v5 = v6;
    v5 += 4;
  }
  while ( v3 != (_DWORD *)&unk_7ECC0 );
  v8[0] = 0;
  v8[1] = 0;
  sub_2F054((unsigned __int8 *)v8, a1, n);
  return sub_2F100(v8, a3);
}

//----- (0002F250) --------------------------------------------------------
int sub_2F250()
{
  return 0;
}

//----- (0002F258) --------------------------------------------------------
int __fastcall sub_2F258(const void *a1, const char *a2, const char *a3, int a4)
{
  int *v8; // r0
  char s[2072]; // [sp+10h] [bp-818h] BYREF

  v8 = _errno_location();
  snprintf(s, 0x800u, "Failed to sem_post errno=%d cgsem=0x%p in %s %s():%d", *v8, a1, a2, a3, a4);
  sub_2E584(3, s, 1);
  return nullsub_1(1);
}
// 2A574: using guessed type int __fastcall nullsub_1(_DWORD);

//----- (0002F2C0) --------------------------------------------------------
int __fastcall sub_2F2C0(pthread_mutex_t *a1, const char *a2, int a3)
{
  int result; // r0
  int *v6; // r0
  char s[2064]; // [sp+10h] [bp-810h] BYREF

  result = pthread_mutex_unlock(a1);
  if ( result )
  {
    v6 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v6, "util.c", a2, a3);
    sub_2E584(3, s, 1);
    return nullsub_1(1);
  }
  return result;
}
// 2A574: using guessed type int __fastcall nullsub_1(_DWORD);

//----- (0002F33C) --------------------------------------------------------
int __fastcall sub_2F33C(const char *a1, int a2)
{
  int *v4; // r0
  char s[2064]; // [sp+10h] [bp-810h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v4, "util.c", a1, a2);
  sub_2E584(3, s, 1);
  return nullsub_1(1);
}
// 2A574: using guessed type int __fastcall nullsub_1(_DWORD);

//----- (0002F3A0) --------------------------------------------------------
int __fastcall sub_2F3A0(int a1, char a2)
{
  pthread_mutex_t *v2; // r5
  int v5; // r0

  v2 = (pthread_mutex_t *)(a1 + 12);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 12)) )
    sub_2F33C("tq_freezethaw", 1108);
  *(_BYTE *)(a1 + 8) = a2;
  pthread_cond_signal((pthread_cond_t *)(a1 + 40));
  v5 = sub_2F2C0(v2, "tq_freezethaw", 1111);
  return off_7ECC4(v5);
}
// 7ECC4: using guessed type int (__fastcall *off_7ECC4)(_DWORD);

//----- (0002F408) --------------------------------------------------------
void *__fastcall sub_2F408(size_t a1, const char *a2, const char *a3, int a4)
{
  size_t v4; // r4
  void *result; // r0
  char s[2072]; // [sp+10h] [bp-818h] BYREF

  v4 = a1;
  if ( (a1 & 3) != 0 )
    v4 = (a1 & 0xFFFFFFFC) + 4;
  result = malloc(v4);
  if ( !result )
  {
    snprintf(s, 0x800u, "Failed to malloc size %d from %s %s:%d", v4, a2, a3, a4);
    sub_2E584(3, s, 1);
    nullsub_1(1);
    return 0;
  }
  return result;
}
// 2A574: using guessed type int __fastcall nullsub_1(_DWORD);

//----- (0002F490) --------------------------------------------------------
void *__fastcall sub_2F490(size_t a1, size_t a2, const char *a3, const char *a4, int a5)
{
  size_t v5; // r4
  void *result; // r0
  char s[2072]; // [sp+10h] [bp-818h] BYREF

  v5 = a2;
  if ( (a2 & 3) != 0 )
    v5 = (a2 & 0xFFFFFFFC) + 4;
  result = calloc(a1, v5);
  if ( !result )
  {
    snprintf(s, 0x800u, "Failed to calloc memb %d size %d from %s %s:%d", a1, v5, a3, a4, a5);
    sub_2E584(3, s, 1);
    nullsub_1(1);
    return 0;
  }
  return result;
}
// 2A574: using guessed type int __fastcall nullsub_1(_DWORD);

//----- (0002F520) --------------------------------------------------------
void *__fastcall sub_2F520(void *a1, size_t a2, const char *a3, const char *a4, int a5)
{
  size_t v5; // r4
  void *result; // r0
  char s[2072]; // [sp+10h] [bp-818h] BYREF

  v5 = a2;
  if ( (a2 & 3) != 0 )
    v5 = (a2 & 0xFFFFFFFC) + 4;
  result = realloc(a1, v5);
  if ( !result )
  {
    snprintf(s, 0x800u, "Failed to realloc size %d from %s %s:%d", v5, a3, a4, a5);
    sub_2E584(3, s, 1);
    nullsub_1(1);
    return 0;
  }
  return result;
}
// 2A574: using guessed type int __fastcall nullsub_1(_DWORD);

//----- (0002F670) --------------------------------------------------------
_BYTE *__fastcall sub_2F670(int a1, int a2)
{
  int v2; // r5
  int v4; // r0
  int v6; // r12
  _BYTE *result; // r0
  _BYTE *v8; // r5
  _BYTE *v9; // r2
  char *v10; // r12
  unsigned int v11; // t1

  v2 = 2 * a2;
  v4 = 2 * a2 + 1;
  v6 = v4 & 3;
  if ( v4 <= 0 )
    v6 = -(-v4 & 3);
  result = sub_2F490(4 - v6 + v4, 1u, "util.c", "bin2hex", 789);
  if ( a2 > 0 )
  {
    v9 = (_BYTE *)(a1 - 1);
    v10 = result + 2;
    do
    {
      v11 = (unsigned __int8)*++v9;
      v10 += 2;
      *(v10 - 4) = aTqFreezethaw[(v11 >> 4) + 72];
      *(v10 - 3) = aTqFreezethaw[(*v9 & 0xF) + 72];
    }
    while ( v9 != (_BYTE *)(a1 - 1 + a2) );
    v8 = &result[v2];
  }
  else
  {
    v8 = result;
  }
  *v8 = 0;
  return result;
}

//----- (0002F724) --------------------------------------------------------
int __fastcall sub_2F724(_BYTE *a1, unsigned __int8 *a2, int a3)
{
  unsigned int v4; // r3
  unsigned int v5; // lr
  int result; // r0
  unsigned __int8 *v7; // r1
  int v8; // r3
  bool v9; // zf
  char *v10; // r3
  int v11; // r12
  char *v12; // r12
  char v13[2064]; // [sp-810h] [bp-810h] BYREF

  if ( !*a2 )
    return !a3;
  if ( !a3 )
    return 0;
  if ( !a2[1] )
  {
LABEL_16:
    if ( byte_590404 || byte_482A5C || dword_7EBA0 > 2 )
    {
      strcpy(v13, "hex2bin str truncated");
      sub_2E584(3, v13, 0);
    }
    return 0;
  }
  v4 = *(_DWORD *)&aTqFreezethaw[4 * a2[1] + 96];
  v5 = *(_DWORD *)&aTqFreezethaw[4 * *a2 + 96];
  result = (v4 >> 31) | (v5 >> 31);
  if ( !result )
  {
    v7 = a2 + 4;
    while ( 1 )
    {
      --a3;
      *a1++ = v4 | (16 * v5);
      v8 = *(v7 - 2);
      v9 = v8 == 0;
      v10 = &aTqFreezethaw[4 * v8];
      if ( v9 )
        break;
      if ( !a3 )
        return result;
      v11 = *(v7 - 1);
      v7 += 2;
      v9 = v11 == 0;
      v12 = &aTqFreezethaw[4 * v11];
      if ( v9 )
        goto LABEL_16;
      v5 = *((_DWORD *)v10 + 24);
      v4 = *((_DWORD *)v12 + 24);
      if ( ((v5 | v4) & 0x80000000) != 0 )
        goto LABEL_11;
    }
    return !a3;
  }
LABEL_11:
  if ( !byte_590404 && !byte_482A5C && dword_7EBA0 <= 2 )
    return 0;
  strcpy(v13, "hex2bin scan failed");
  sub_2E584(3, v13, 0);
  return 0;
}
// 7EBA0: using guessed type int dword_7EBA0;
// 482A5C: using guessed type char byte_482A5C;
// 590404: using guessed type char byte_590404;

//----- (0002F8E8) --------------------------------------------------------
size_t __fastcall sub_2F8E8(_BYTE *a1, char *s)
{
  size_t result; // r0
  char v5; // r1
  char *v6; // r7
  int v7; // r12
  char *v8; // r6
  int v9; // t1
  int *v10; // r2
  unsigned int v11; // r3
  _DWORD *v12; // r3
  int *v13; // r2
  _BYTE *v14; // r5
  unsigned int v15; // t1
  int v16; // [sp+0h] [bp-38h] BYREF
  int v17; // [sp+4h] [bp-34h]
  int v18[5]; // [sp+8h] [bp-30h] BYREF
  int v19; // [sp+1Ch] [bp-1Ch] BYREF

  memset(v18, 0, sizeof(v18));
  v17 = 0;
  v19 = 0;
  result = strlen(s);
  if ( result )
  {
    v6 = s - 1;
    v7 = 0;
    v8 = &v6[result];
    while ( 1 )
    {
      v9 = (unsigned __int8)*++v6;
      v10 = &v19;
      v11 = *(_DWORD *)&aTqFreezethaw[4 * v9 + 1120];
      while ( 1 )
      {
        *v10-- = 58 * v7 + v11;
        v11 = (58LL * (unsigned int)v7 + (unsigned __int64)v11) >> 32;
        if ( &v16 == v10 )
          break;
        v7 = *v10;
      }
      if ( v8 == v6 )
        break;
      v7 = v19;
    }
    v5 = v17;
    result = bswap32(v18[0]);
  }
  else
  {
    v5 = 0;
  }
  v12 = a1 + 1;
  v13 = v18;
  *a1 = v5;
  v14 = a1 + 25;
  while ( 1 )
  {
    *v12++ = result;
    if ( v12 == (_DWORD *)v14 )
      break;
    v15 = v13[1];
    ++v13;
    result = bswap32(v15);
  }
  return result;
}

//----- (0002F9C0) --------------------------------------------------------
int __fastcall sub_2F9C0(int a1, int a2)
{
  char v3; // r2
  int result; // r0
  int v5; // r2

  if ( a2 > 127 )
  {
    v5 = (unsigned __int16)&unk_20407F;
    if ( a2 > v5 )
    {
      HIWORD(v5) = (unsigned int)&unk_20407F >> 16;
      if ( a2 <= v5 )
        result = 4;
      else
        result = 5;
      if ( a2 <= v5 )
        v3 = 3;
      else
        v3 = 4;
    }
    else
    {
      result = 3;
      v3 = 2;
    }
  }
  else
  {
    v3 = 1;
    result = 2;
  }
  *(_DWORD *)(a1 + 1) = a2;
  *(_BYTE *)a1 = v3;
  return result;
}

//----- (0002FBFC) --------------------------------------------------------
char *sub_2FBFC()
{
  char *v0; // r4

  v0 = (char *)sub_2F490(1u, 0x58u, "util.c", "tq_new", 1077);
  *(_DWORD *)v0 = v0;
  *((_DWORD *)v0 + 1) = v0;
  pthread_mutex_init((pthread_mutex_t *)(v0 + 12), 0);
  pthread_cond_init((pthread_cond_t *)(v0 + 40), 0);
  return v0;
}

//----- (0002FC58) --------------------------------------------------------
void __fastcall sub_2FC58(char *a1)
{
  int v2; // r2
  _DWORD *v3; // r0
  _DWORD *v4; // r4
  _DWORD *v5; // r3
  bool v6; // zf

  if ( a1 )
  {
    v2 = **(_DWORD **)a1;
    v3 = (_DWORD *)(*(_DWORD *)a1 - 4);
    v4 = (_DWORD *)(v2 - 4);
    if ( a1 != *(char **)a1 )
    {
      do
      {
        v5 = (_DWORD *)v3[2];
        *(_DWORD *)(v2 + 4) = v5;
        *v5 = v2;
        free(v3);
        v3 = v4;
        v2 = v4[1];
        v6 = v4 + 1 == (_DWORD *)a1;
        v4 = (_DWORD *)(v2 - 4);
      }
      while ( !v6 );
    }
    pthread_cond_destroy((pthread_cond_t *)(a1 + 40));
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 12));
    free(a1);
  }
}

//----- (0002FCC0) --------------------------------------------------------
int __fastcall sub_2FCC0(int a1)
{
  return sub_2F3A0(a1, 1);
}

//----- (0002FCC8) --------------------------------------------------------
int __fastcall sub_2FCC8(int a1)
{
  return sub_2F3A0(a1, 0);
}

//----- (0002FCD0) --------------------------------------------------------
int __fastcall sub_2FCD0(int a1, int a2)
{
  _DWORD *v4; // r6
  _DWORD *v5; // r4
  _DWORD *v6; // r3
  int v7; // r8
  int v8; // r0

  v4 = sub_2F490(1u, 0xCu, "util.c", "tq_push", 1129);
  *v4 = a2;
  v5 = v4 + 1;
  v4[1] = v4 + 1;
  v4[2] = v4 + 1;
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 12)) )
    sub_2F33C("tq_push", 1133);
  if ( *(_BYTE *)(a1 + 8) )
  {
    v7 = 0;
    free(v4);
  }
  else
  {
    v6 = *(_DWORD **)(a1 + 4);
    v7 = 1;
    *(_DWORD *)(a1 + 4) = v5;
    v4[1] = a1;
    v4[2] = v6;
    *v6 = v5;
  }
  pthread_cond_signal((pthread_cond_t *)(a1 + 40));
  v8 = sub_2F2C0((pthread_mutex_t *)(a1 + 12), "tq_push", 1146);
  off_7ECC4(v8);
  return v7;
}
// 7ECC4: using guessed type int (__fastcall *off_7ECC4)(_DWORD);

//----- (0002FDA4) --------------------------------------------------------
int __fastcall sub_2FDA4(int a1, const struct timespec *a2)
{
  pthread_mutex_t *v2; // r6
  int *v5; // r4
  _DWORD *v6; // r2
  int v7; // r1
  int v8; // r5
  int v9; // r0
  pthread_cond_t *v11; // r0
  int v12; // r0

  v2 = (pthread_mutex_t *)(a1 + 12);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 12)) )
    sub_2F33C("tq_pop", 1158);
  v5 = *(int **)a1;
  if ( a1 == *(_DWORD *)a1 )
  {
    v11 = (pthread_cond_t *)(a1 + 40);
    if ( a2 )
      v12 = pthread_cond_timedwait(v11, v2, a2);
    else
      v12 = pthread_cond_wait(v11, v2);
    if ( v12 )
    {
      v8 = 0;
      goto LABEL_5;
    }
    if ( v5 == *(int **)a1 )
    {
      v8 = 0;
      goto LABEL_5;
    }
    v5 = *(int **)a1;
  }
  v6 = (_DWORD *)v5[1];
  v7 = *v5;
  v8 = *(v5 - 1);
  *(_DWORD *)(v7 + 4) = v6;
  *v6 = v7;
  *v5 = 0;
  v5[1] = 0;
  free(v5 - 1);
LABEL_5:
  v9 = sub_2F2C0(v2, "tq_pop", 1184);
  off_7ECC4(v9);
  return v8;
}
// 7ECC4: using guessed type int (__fastcall *off_7ECC4)(_DWORD);

//----- (0002FE84) --------------------------------------------------------
int __fastcall sub_2FE84(int result)
{
  int v1; // r4
  pthread_t v2; // r0
  sem_t *v3; // r0

  v1 = result;
  if ( result )
  {
    v2 = *(_DWORD *)(result + 12);
    if ( v2 )
    {
      pthread_cancel(v2);
      v3 = (sem_t *)(v1 + 16);
      *(_DWORD *)(v1 + 12) = 0;
    }
    else
    {
      v3 = (sem_t *)(v1 + 16);
    }
    return sem_destroy(v3);
  }
  return result;
}

//----- (0002FEC0) --------------------------------------------------------
_DWORD *__fastcall sub_2FEC0(_DWORD *result, int *a2)
{
  int v2; // r12
  int v3; // r2
  int v4; // r3
  __int64 v5; // r2

  v2 = a2[1];
  v3 = *result - *a2;
  *a2 = v3;
  v4 = result[1] - v2;
  a2[1] = v4;
  if ( v4 < 0 )
  {
    LODWORD(v5) = v3 - 1;
    HIDWORD(v5) = v4 + 1000000;
    *(_QWORD *)a2 = v5;
  }
  return result;
}

//----- (0002FEF4) --------------------------------------------------------
_DWORD *__fastcall sub_2FEF4(_DWORD *result, int *a2)
{
  int v2; // lr
  int v3; // r2
  int v4; // r3
  __int64 v5; // r2

  v2 = a2[1];
  v3 = *result + *a2;
  *a2 = v3;
  v4 = result[1] + v2;
  a2[1] = v4;
  if ( v4 > (int)&unk_F423F )
  {
    LODWORD(v5) = v3 + 1;
    HIDWORD(v5) = v4 - 1000000;
    *(_QWORD *)a2 = v5;
  }
  return result;
}

//----- (0002FF38) --------------------------------------------------------
bool __fastcall sub_2FF38(_DWORD *a1, _DWORD *a2)
{
  if ( *a1 == *a2 )
    return a1[1] > a2[1];
  else
    return *a1 > *a2;
}

//----- (0002FF6C) --------------------------------------------------------
bool __fastcall sub_2FF6C(_DWORD *a1, _DWORD *a2)
{
  if ( *a1 == *a2 )
    return a1[1] < a2[1];
  else
    return *a1 < *a2;
}

//----- (0002FFA0) --------------------------------------------------------
_DWORD *__fastcall sub_2FFA0(_DWORD *result, _DWORD *a2)
{
  *result = *a2;
  result[1] = a2[1] / 1000;
  return result;
}

//----- (0002FFD0) --------------------------------------------------------
_DWORD *__fastcall sub_2FFD0(_DWORD *result, _DWORD *a2)
{
  *result = *a2;
  result[1] = 1000 * a2[1];
  return result;
}

//----- (0002FFEC) --------------------------------------------------------
int __fastcall sub_2FFEC(_QWORD *a1)
{
  int result; // r0
  int v3[8]; // [sp+8h] [bp-20h] BYREF

  result = lldiv(v3);
  *a1 = __PAIR64__(v3[2], v3[0]);
  return result;
}
// 12478: using guessed type int __fastcall lldiv(_DWORD);

//----- (00030024) --------------------------------------------------------
int __fastcall sub_30024(_QWORD *a1)
{
  int result; // r0
  __int64 v3; // r2
  int v4[8]; // [sp+8h] [bp-20h] BYREF

  result = lldiv(v4);
  LODWORD(v3) = v4[0];
  HIDWORD(v3) = 1000 * v4[2];
  *a1 = v3;
  return result;
}
// 12478: using guessed type int __fastcall lldiv(_DWORD);

//----- (00030064) --------------------------------------------------------
int __fastcall sub_30064(_QWORD *a1)
{
  int result; // r0
  __int64 v3; // r2
  int v4[8]; // [sp+8h] [bp-20h] BYREF

  result = lldiv(v4);
  LODWORD(v3) = v4[0];
  HIDWORD(v3) = (_DWORD)&unk_F4240 * v4[2];
  *a1 = v3;
  return result;
}
// 12478: using guessed type int __fastcall lldiv(_DWORD);

//----- (000300A4) --------------------------------------------------------
int __fastcall sub_300A4(_QWORD *a1)
{
  int result; // r0
  __int64 v3; // r2
  int v4[8]; // [sp+8h] [bp-20h] BYREF

  result = lldiv(v4);
  LODWORD(v3) = v4[0];
  HIDWORD(v3) = 1000 * v4[2];
  *a1 = v3;
  return result;
}
// 12478: using guessed type int __fastcall lldiv(_DWORD);

//----- (000300E0) --------------------------------------------------------
_DWORD *__fastcall sub_300E0(_DWORD *result, _DWORD *a2)
{
  int v2; // r3
  __int64 v3; // r2
  int v4; // lr
  int v5; // r1

  v2 = result[1];
  LODWORD(v3) = *result + *a2;
  *result = v3;
  HIDWORD(v3) = v2 + a2[1];
  result[1] = HIDWORD(v3);
  if ( SHIDWORD(v3) <= 999999999 )
  {
    if ( v3 < 0 )
    {
      do
      {
        HIDWORD(v3) += 1000000000;
        LODWORD(v3) = v3 - 1;
      }
      while ( v3 < 0 );
      *(_QWORD *)result = v3;
    }
  }
  else
  {
    v4 = v3 + 1;
    v5 = HIDWORD(v3) - 1000000000;
    if ( HIDWORD(v3) - 1000000000 > 999999999 )
    {
      v5 = -2000000000;
      v4 = v3 + 2;
    }
    *result = v4;
    if ( HIDWORD(v3) - 1000000000 > 999999999 )
      v5 += HIDWORD(v3);
    result[1] = v5;
  }
  return result;
}

//----- (00030258) --------------------------------------------------------
const char *__fastcall sub_30258(const char **a1, const char *a2)
{
  const char *v3; // r4
  char *v4; // r0
  const char *result; // r0

  v3 = *a1;
  if ( *a1 && (v4 = strpbrk(*a1, a2)) != 0 )
  {
    *v4 = 0;
    *a1 = v4 + 1;
    return v3;
  }
  else
  {
    result = v3;
    *a1 = 0;
  }
  return result;
}

//----- (000302A0) --------------------------------------------------------
__int64 __fastcall sub_302A0(__time_t *a1)
{
  __int64 result; // r0
  int v3; // r3
  struct timespec v4; // [sp+0h] [bp-10h] BYREF

  clock_gettime(1, &v4);
  result = 274877907LL * v4.tv_nsec;
  v3 = v4.tv_nsec >> 31;
  *a1 = v4.tv_sec;
  a1[1] = (SHIDWORD(result) >> 6) - v3;
  return result;
}

//----- (000302E4) --------------------------------------------------------
int __fastcall sub_302E4(_DWORD *a1)
{
  return a1[1] / 1000000 + 1000 * *a1;
}

//----- (00030314) --------------------------------------------------------
int __fastcall sub_30314(_DWORD *a1, _DWORD *a2, int *a3)
{
  int v3; // r3
  int v4; // r1
  int result; // r0

  v3 = *a1 - *a2;
  *a3 = v3;
  v4 = a2[1];
  result = a1[1] - v4;
  if ( result >= 0 )
  {
    a3[1] = result;
  }
  else
  {
    v4 = 1000000000;
    --v3;
  }
  if ( result < 0 )
  {
    *a3 = v3;
    a3[1] = result + v4;
  }
  return result;
}

//----- (00030350) --------------------------------------------------------
int __fastcall sub_30350(struct timespec *a1)
{
  return clock_gettime(1, a1);
}

//----- (0003035C) --------------------------------------------------------
int __fastcall sub_3035C(int *a1)
{
  int v2; // r1
  int tv_nsec; // r3
  __time_t v4; // r2
  __time_t v5; // r12
  int v6; // r1
  int result; // r0
  struct timespec v8[2]; // [sp+0h] [bp-10h] BYREF

  sub_30064(v8);
  v2 = *a1;
  v8[0].tv_nsec += a1[1];
  tv_nsec = v8[0].tv_nsec;
  v4 = v8[0].tv_sec + v2;
  v8[0].tv_sec += v2;
  if ( v8[0].tv_nsec <= 999999999 )
  {
    if ( v8[0].tv_nsec < 0 )
    {
      do
      {
        tv_nsec += 1000000000;
        --v4;
      }
      while ( tv_nsec < 0 );
      v8[0].tv_sec = v4;
      v8[0].tv_nsec = tv_nsec;
    }
  }
  else
  {
    v5 = v4 + 1;
    v6 = v8[0].tv_nsec - 1000000000;
    if ( v8[0].tv_nsec - 1000000000 > 999999999 )
    {
      v6 = -2000000000;
      v5 = v4 + 2;
    }
    v8[0].tv_sec = v5;
    if ( v8[0].tv_nsec - 1000000000 > 999999999 )
      v6 += v8[0].tv_nsec;
    v8[0].tv_nsec = v6;
  }
  do
    result = clock_nanosleep(1, 1, v8, 0);
  while ( result == 4 );
  return result;
}

//----- (0003041C) --------------------------------------------------------
int __fastcall sub_3041C(int *a1)
{
  int v2; // r1
  int tv_nsec; // r3
  __time_t v4; // r2
  __time_t v5; // r12
  int v6; // r1
  int result; // r0
  struct timespec v8[2]; // [sp+0h] [bp-10h] BYREF

  sub_30024(v8);
  v2 = *a1;
  v8[0].tv_nsec += a1[1];
  tv_nsec = v8[0].tv_nsec;
  v4 = v8[0].tv_sec + v2;
  v8[0].tv_sec += v2;
  if ( v8[0].tv_nsec <= 999999999 )
  {
    if ( v8[0].tv_nsec < 0 )
    {
      do
      {
        tv_nsec += 1000000000;
        --v4;
      }
      while ( tv_nsec < 0 );
      v8[0].tv_sec = v4;
      v8[0].tv_nsec = tv_nsec;
    }
  }
  else
  {
    v5 = v4 + 1;
    v6 = v8[0].tv_nsec - 1000000000;
    if ( v8[0].tv_nsec - 1000000000 > 999999999 )
    {
      v6 = -2000000000;
      v5 = v4 + 2;
    }
    v8[0].tv_sec = v5;
    if ( v8[0].tv_nsec - 1000000000 > 999999999 )
      v6 += v8[0].tv_nsec;
    v8[0].tv_nsec = v6;
  }
  do
    result = clock_nanosleep(1, 1, v8, 0);
  while ( result == 4 );
  return result;
}

//----- (000304D4) --------------------------------------------------------
int sub_304D4()
{
  struct timespec v1; // [sp+0h] [bp-10h] BYREF

  clock_gettime(1, &v1);
  return sub_3035C(&v1.tv_sec);
}

//----- (00030534) --------------------------------------------------------
_DWORD *__fastcall sub_30534(_DWORD *result, _DWORD *a2)
{
  if ( *result - *a2 <= 60 )
    return &unk_F4240;
  return result;
}

//----- (00030578) --------------------------------------------------------
void *__fastcall sub_30578(_DWORD *a1, _DWORD *a2)
{
  int v2; // r2

  v2 = *a1 - *a2;
  if ( v2 > 3600 )
    return &unk_36EE80;
  else
    return (void *)((a1[1] - a2[1]) / 1000 + 1000 * v2);
}

//----- (000305CC) --------------------------------------------------------
void sub_305CC()
{
  ;
}

//----- (00030610) --------------------------------------------------------
int __fastcall sub_30610(const char *a1, _DWORD *a2, char **a3)
{
  const char *v4; // r4
  char *v6; // r0
  char *v7; // r6
  char *v8; // r0
  char v9; // r5
  int v10; // r5
  char *v11; // r6
  size_t v12; // r0
  int v13; // r3
  int v14; // r7
  char *v16; // r0
  char v17[8]; // [sp+8h] [bp-128h] BYREF
  char s[288]; // [sp+10h] [bp-120h] BYREF

  v4 = a1;
  *a2 = a1;
  v6 = strstr(a1, "//");
  if ( v6 )
    v4 = v6 + 2;
  v7 = strchr(v4, 91);
  v8 = strchr(v4, 93);
  v9 = (char)v8;
  if ( v8 )
    v9 = 1;
  if ( !v7 )
    v9 = 0;
  if ( v7 < v8 )
    v10 = v9 & 1;
  else
    v10 = 0;
  if ( !v10 )
    v8 = (char *)v4;
  v11 = strchr(v8, 58);
  v12 = strlen(v4);
  if ( v11 )
  {
    v13 = v11 - v4;
    v14 = ~(v11 - v4) + v12;
    if ( v14 <= 0 )
      return 0;
    ++v11;
  }
  else
  {
    v13 = v12;
    v14 = 0;
  }
  if ( v13 <= 0 )
    return 0;
  if ( v10 )
  {
    ++v4;
    v13 -= 2;
  }
  snprintf(s, 0xFEu, "%.*s", v13, v4);
  if ( v14 )
  {
    snprintf(v17, 6u, "%.*s", v14, v11);
    v16 = strpbrk(v17, "/#");
    if ( v16 )
      *v16 = 0;
  }
  else
  {
    strcpy(v17, "80");
  }
  *a3 = _strdup(v17);
  *a2 = _strdup(s);
  return 1;
}

//----- (00030784) --------------------------------------------------------
char *__fastcall sub_30784(char *s1, int a2)
{
  const char *v2; // r4
  int v4; // r5
  size_t v5; // r6
  char *v7; // r0
  char *v8; // r8
  char *v9; // r0
  const char *v10; // r1

  v2 = "http:";
  v4 = 0;
  v5 = 5;
  *(_DWORD *)(a2 + 184) = 0;
  while ( strncmp(s1, v2, v5) )
  {
    ++v4;
    v2 = (&off_654CC)[2 * v4];
    if ( !v2 )
      return s1;
    v5 = strlen((&off_654CC)[2 * v4]);
  }
  v7 = strchr(s1, 124);
  v8 = v7;
  if ( v7 )
  {
    *v7 = 0;
    v9 = (char *)sub_2F408(1 - v5 + v7 - s1, "util.c", "get_proxy", 750);
    v10 = &s1[v5];
    *(_DWORD *)(a2 + 184) = v9;
    s1 = v8 + 1;
    strcpy(v9, v10);
    sub_30610(*(const char **)(a2 + 184), (_DWORD *)(a2 + 604), (char **)(a2 + 608));
    *(_DWORD *)(a2 + 180) = *(_DWORD *)&aTqFreezethaw[8 * v4 + 20];
  }
  return s1;
}
// 654CC: using guessed type char *off_654CC;

//----- (00030860) --------------------------------------------------------
char *__fastcall sub_30860(char *a1, char *s)
{
  size_t v4; // r0
  const char *v5; // r1
  char *v6; // r4
  size_t v7; // r4
  size_t v8; // r0
  char *v10; // r4

  v4 = strlen(s);
  if ( !v4 )
    return a1;
  v7 = v4 + 1;
  if ( a1 )
  {
    v8 = strlen(a1) + v7;
    if ( (v8 & 3) != 0 )
      v8 = (v8 & 0xFFFFFFFC) + 4;
    v6 = (char *)sub_2F408(v8, "util.c", "realloc_strcat", 3382);
    sprintf(v6, "%s%s", a1, s);
    free(a1);
    return v6;
  }
  if ( (v7 & 3) != 0 )
    v4 = v7 & 0xFFFFFFFC;
  else
    LOWORD(v5) = 25564;
  if ( (v7 & 3) != 0 )
    LOWORD(v5) = 25564;
  else
    v4 = v7;
  if ( (v7 & 3) != 0 )
    v4 += 4;
  HIWORD(v5) = 6;
  v10 = (char *)sub_2F408(v4, v5, "realloc_strcat", 3382);
  strcpy(v10, s);
  return v10;
}
// 3090C: variable 'v5' is possibly undefined

//----- (00030934) --------------------------------------------------------
char *__fastcall sub_30934(const char *a1)
{
  size_t v2; // r0
  char *v3; // r5
  char *v4; // r7
  char *v5; // r4
  char v6; // r3
  char v7; // r2
  int v8; // t1
  char *result; // r0
  char *v10; // r2
  char s[2072]; // [sp+8h] [bp-818h] BYREF

  if ( !a1 )
  {
    v10 = (char *)malloc(7u);
    if ( v10 )
    {
      strcpy(v10, "(null)");
    }
    else
    {
      snprintf(s, 0x800u, "Failed to malloc null in %s %s():%d", "util.c", "str_text", 3407);
      sub_2E584(3, s, 1);
      nullsub_1(1);
    }
  }
  v2 = strlen(a1);
  v3 = (char *)(a1 - 1);
  v4 = (char *)sub_2F408(4 * v2 + 5, "util.c", "str_text", 3412);
  v5 = v4;
  do
  {
    while ( 1 )
    {
      v8 = (unsigned __int8)*++v3;
      v7 = v8;
      if ( (unsigned int)(v8 - 32) <= 0x5E )
        break;
      sprintf(v5, "0x%02x");
      v6 = *v3;
      v5 += 4;
      if ( !*v3 )
        goto LABEL_7;
    }
    *v5++ = v7;
    v6 = *v3;
  }
  while ( *v3 );
LABEL_7:
  result = v4;
  *v5 = v6;
  return result;
}
// 2A574: using guessed type int __fastcall nullsub_1(_DWORD);

//----- (00030A54) --------------------------------------------------------
int __fastcall sub_30A54(const char *a1)
{
  char s[24]; // [sp+8h] [bp-18h] BYREF

  snprintf(s, 0x10u, "cg@%s", a1);
  return prctl(15, s, 0);
}

//----- (00030A94) --------------------------------------------------------
int __fastcall sub_30A94(sem_t *a1, const char *a2, const char *a3, int a4)
{
  int result; // r0
  int v8; // r4
  int *v9; // r0
  char s[2072]; // [sp+10h] [bp-818h] BYREF

  result = sem_init(a1, 0, 0);
  v8 = result;
  if ( result )
  {
    v9 = _errno_location();
    snprintf(s, 0x800u, "Failed to sem_init ret=%d errno=%d in %s %s():%d", v8, *v9, a2, a3, a4);
    sub_2E584(3, s, 1);
    return nullsub_1(1);
  }
  return result;
}
// 2A574: using guessed type int __fastcall nullsub_1(_DWORD);

//----- (00030B10) --------------------------------------------------------
int __fastcall sub_30B10(int a1, const pthread_attr_t *a2, void *(*a3)(void *), void *a4)
{
  sub_30A94((sem_t *)(a1 + 16), "util.c", "thr_info_create", 1191);
  return pthread_create((pthread_t *)(a1 + 12), a2, a3, a4);
}

//----- (00030B58) --------------------------------------------------------
int __fastcall sub_30B58(sem_t *a1, const char *a2, const char *a3, int a4)
{
  int result; // r0

  result = sem_post(a1);
  if ( result )
    return sub_2F258(a1, a2, a3, a4);
  return result;
}

//----- (00030B90) --------------------------------------------------------
int __fastcall sub_30B90(int a1)
{
  pthread_setcanceltype(1, 0);
  (*(void (__fastcall **)(_DWORD))(a1 + 16))(*(_DWORD *)(a1 + 20));
  sub_30B58((sem_t *)a1, "util.c", "completion_thread", 3638);
  return 0;
}

//----- (00030C54) --------------------------------------------------------
int __fastcall sub_30C54(sem_t *a1, int a2, const char *a3, const char *a4, int a5)
{
  __time_t tv_sec; // r10
  int v8; // r5
  int v9; // r3
  __time_t v10; // r2
  bool v11; // cc
  int v12; // r1
  __time_t v13; // r0
  int result; // r0
  struct timespec abstime; // [sp+18h] [bp-830h] BYREF
  struct timespec tp; // [sp+20h] [bp-828h] BYREF

  clock_gettime(1, &tp);
  tv_sec = tp.tv_sec;
  v8 = 1000 * (tp.tv_nsec / 1000);
  sub_30064(&abstime);
  while ( 1 )
  {
    v9 = v8 + abstime.tv_nsec;
    v10 = tv_sec + abstime.tv_sec;
    v11 = v8 + abstime.tv_nsec <= 999999999;
    abstime.tv_sec += tv_sec;
    abstime.tv_nsec += v8;
    if ( v11 )
    {
      if ( v9 < 0 )
      {
        do
        {
          v9 += 1000000000;
          --v10;
        }
        while ( v9 < 0 );
        abstime.tv_sec = v10;
        abstime.tv_nsec = v9;
      }
    }
    else
    {
      v12 = v9 - 1000000000;
      v13 = v10 + 1;
      if ( v9 - 1000000000 > 999999999 )
      {
        v12 = v9 - 2000000000;
        v13 = v10 + 2;
      }
      abstime.tv_sec = v13;
      abstime.tv_nsec = v12;
    }
    result = sem_timedwait(a1, &abstime);
    if ( !result )
      break;
    result = *_errno_location();
    if ( result == 110 )
      break;
    if ( result != 4 )
    {
      snprintf((char *)&tp, 0x800u, "Failed to sem_timedwait errno=%d cgsem=0x%p in %s %s():%d", result, a1, a3, a4, a5);
      sub_2E584(3, (const char *)&tp, 1);
      nullsub_1(1);
      return 0;
    }
  }
  return result;
}
// 2A574: using guessed type int __fastcall nullsub_1(_DWORD);

//----- (00030DA4) --------------------------------------------------------
int *__fastcall sub_30DA4(sem_t *sem)
{
  int *result; // r0

  do
  {
    while ( 1 )
    {
      result = (int *)sem_trywait(sem);
      if ( (int)result < 0 )
        break;
      if ( result )
        return result;
    }
    result = _errno_location();
  }
  while ( *result == 4 );
  return result;
}

//----- (00030DDC) --------------------------------------------------------
bool __fastcall sub_30DDC(int a1, int a2, int a3)
{
  sem_t *v6; // r4
  int v7; // r5
  pthread_t newthread; // [sp+Ch] [bp-1Ch] BYREF

  v6 = (sem_t *)sub_2F408(0x18u, "util.c", "cg_completion_timeout", 3649);
  sub_30A94(v6, "util.c", "cg_completion_timeout", 3650);
  v6[1].__align = a1;
  *(&v6[1].__align + 1) = a2;
  pthread_create(&newthread, 0, (void *(*)(void *))sub_30B90, v6);
  v7 = sub_30C54(v6, a3, "util.c", "cg_completion_timeout", 3656);
  if ( v7 )
  {
    pthread_cancel(newthread);
    return v7 == 0;
  }
  else
  {
    pthread_join(newthread, 0);
    free(v6);
    return 1;
  }
}

//----- (00030EA8) --------------------------------------------------------
void *__fastcall sub_30EA8(void *result, const void *a2, size_t a3, int a4, int a5, int a6)
{
  char s[2064]; // [sp+10h] [bp-810h] BYREF

  if ( (int)(a3 - 1) < 0 )
  {
    if ( !byte_590404 && !byte_482A5C && dword_7EBA0 <= 2 )
      return result;
    snprintf(s, 0x800u, "ERR: Asked to memcpy %u bytes from %s %s():%d", a3, a4, a5, a6);
    return (void *)sub_2E584(3, s, 0);
  }
  if ( !result )
  {
    if ( !byte_590404 && !byte_482A5C && dword_7EBA0 <= 2 )
      return result;
    snprintf(s, 0x800u, "ERR: Asked to memcpy %u bytes to NULL from %s %s():%d", a3, a4, a5, a6);
    return (void *)sub_2E584(3, s, 0);
  }
  if ( a2 )
    return memcpy(result, a2, a3);
  if ( byte_590404 || byte_482A5C || dword_7EBA0 > 2 )
  {
    snprintf(s, 0x800u, "ERR: Asked to memcpy %u bytes from NULL from %s %s():%d", a3, a4, a5, a6);
    return (void *)sub_2E584(3, s, 0);
  }
  return result;
}
// 7EBA0: using guessed type int dword_7EBA0;
// 482A5C: using guessed type char byte_482A5C;
// 590404: using guessed type char byte_590404;

//----- (000311B8) --------------------------------------------------------
void *__fastcall sub_311B8(void *a1, const void *a2)
{
  return sub_30EA8(a1, a2, 8u, (int)"util.c", (int)"copy_time", 1236);
}

//----- (00031268) --------------------------------------------------------
_BYTE *__fastcall sub_31268(_BYTE *result, int a2)
{
  _BYTE *v2; // r12
  unsigned int v3; // r3
  char v4; // lr
  char v5; // t1
  char v6; // t1

  if ( a2 != 1 )
  {
    v2 = result - 1;
    v3 = 0;
    result += a2;
    do
    {
      ++v3;
      v5 = *++v2;
      v4 = v5;
      v6 = *--result;
      *v2 = v6;
      *result = v4;
    }
    while ( v3 < ~v3 + a2 );
  }
  return result;
}

//----- (00031590) --------------------------------------------------------
int __fastcall sub_31590(int a1, int a2)
{
  int v2; // r3
  int v3; // r1
  int v4; // r2
  int v5; // r12
  int v6; // t1
  char *v7; // r0

  if ( !a2 )
    return 0xFFFF;
  v2 = 255;
  v3 = a1 + (unsigned __int16)(a2 - 1);
  v4 = a1 - 1;
  v5 = 255;
  do
  {
    v6 = *(unsigned __int8 *)++v4;
    v7 = &aTqFreezethaw[v2 ^ v6];
    v2 = (unsigned __int8)v7[2280] ^ v5;
    v5 = (unsigned __int8)v7[2536];
  }
  while ( v3 != v4 );
  return v2 | (v5 << 8);
}

//----- (000315EC) --------------------------------------------------------
int __fastcall sub_315EC(_BYTE *a1, int a2)
{
  unsigned __int8 v2; // r3
  int v3; // r12
  int v4; // r6
  int v5; // r8
  int v6; // r5
  int v7; // r7
  int v8; // r4
  unsigned int v9; // lr
  unsigned int v10; // r2
  int v11; // r9
  int v12; // r2
  int result; // r0

  if ( !a2 )
  {
    v11 = 1;
    result = 28;
LABEL_21:
    result |= 2u;
    goto LABEL_17;
  }
  v2 = 1;
  v3 = 0;
  v4 = 1;
  v5 = 1;
  v6 = 1;
  v7 = 1;
  v8 = 0;
  v9 = 128;
  while ( 1 )
  {
    ++v3;
    ++v8;
    v10 = *a1 & v9;
    v9 >>= 1;
    if ( v10 )
      v2 ^= 1u;
    v11 = v2;
    if ( v3 == 8 )
    {
      ++a1;
      v3 = 0;
      v9 = 128;
    }
    v12 = (unsigned __int8)(v2 ^ v6);
    v2 = v4;
    if ( a2 == v8 )
      break;
    v4 = v5;
    v6 = v7;
    v5 = v12;
    v7 = v11;
  }
  if ( v4 )
    result = 16;
  else
    result = 0;
  if ( v5 )
    result |= 8u;
  if ( v11 != v6 )
    result |= 4u;
  if ( v7 )
    goto LABEL_21;
LABEL_17:
  if ( v11 )
    return result | 1;
  return result;
}

//----- (000316B0) --------------------------------------------------------
int __fastcall sub_316B0(int result, unsigned int *a2, unsigned int a3)
{
  unsigned int v3; // r2
  unsigned int *v4; // r2
  unsigned int v5; // t1

  v3 = a3 >> 2;
  if ( v3 )
  {
    v4 = &a2[v3];
    result -= 4;
    do
    {
      v5 = *a2++;
      *(_DWORD *)(result + 4) = bswap32(v5);
      result += 4;
    }
    while ( a2 != v4 );
  }
  return result;
}

//----- (000316D8) --------------------------------------------------------
unsigned int __fastcall sub_316D8(char *a1, int a2)
{
  char *v2; // r1
  unsigned int v3; // r2
  char v4; // t1

  if ( !a2 )
    return 0;
  v2 = &a1[a2];
  v3 = -1;
  do
  {
    v4 = *a1++;
    v3 = *(_DWORD *)&aTqFreezethaw[4 * (unsigned __int8)(v4 ^ v3) + 2792] ^ (v3 >> 8);
  }
  while ( a1 != v2 );
  return ~v3;
}

//----- (00031720) --------------------------------------------------------
int __fastcall sub_31720(int result)
{
  unsigned int *v1; // r10
  int v2; // r3
  unsigned int *v3; // r5
  unsigned int v4; // r8
  unsigned int v5; // r2
  unsigned int v6; // r4
  int v7; // r3
  char dest[2088]; // [sp+8h] [bp-828h] BYREF

  v1 = (unsigned int *)result;
  if ( byte_590404 || byte_482A5C || dword_7EBA0 > 4 )
  {
    strcpy(dest, "==========================capability start==========================\n");
    result = sub_2E584(5, dest, 0);
    if ( byte_590404 || byte_482A5C || dword_7EBA0 > 4 )
    {
      snprintf(dest, 0x800u, "board num = %d\n", *v1);
      result = sub_2E584(5, dest, 0);
    }
  }
  v2 = (unsigned __int8)byte_590404;
  if ( *v1 )
  {
    v3 = v1;
    v4 = 0;
    do
    {
      if ( v2 || (v2 = (unsigned __int8)byte_482A5C, byte_482A5C) || dword_7EBA0 > 4 )
      {
        snprintf(dest, 0x800u, "board id = %d, chain num = %d\n", v3[1], v3[2]);
        result = sub_2E584(5, dest, 0);
        v2 = (unsigned __int8)byte_590404;
      }
      v5 = v3[2];
      if ( v5 )
      {
        v6 = 0;
        do
        {
          if ( !v2 )
          {
            while ( 1 )
            {
              v2 = (unsigned __int8)byte_482A5C;
              if ( byte_482A5C || dword_7EBA0 > 4 )
                break;
              if ( v5 <= ++v6 )
                goto LABEL_17;
            }
          }
          v7 = v3[v6++ + 3];
          snprintf(dest, 0x800u, "\tchain id = %d\n", v7);
          result = sub_2E584(5, dest, 0);
          v5 = v3[2];
          v2 = (unsigned __int8)byte_590404;
        }
        while ( v5 > v6 );
      }
LABEL_17:
      ++v4;
      v3 += 18;
    }
    while ( *v1 > v4 );
  }
  if ( v2 || byte_482A5C || dword_7EBA0 > 4 )
  {
    strcpy(dest, "==========================capability end============================\n");
    return sub_2E584(5, dest, 0);
  }
  return result;
}
// 7EBA0: using guessed type int dword_7EBA0;
// 482A5C: using guessed type char byte_482A5C;
// 590404: using guessed type char byte_590404;

//----- (00031980) --------------------------------------------------------
char *__fastcall sub_31980(char *a1, int a2)
{
  int v3; // r6
  int v4; // r8
  char *result; // r0
  int v6; // r3
  int v7; // r2
  int v8; // r0
  int v9; // r1
  int v10; // r5
  int v11; // r6
  int v12; // r3
  int v13; // r2
  int v14; // r0
  int v15; // r1
  char *dest; // [sp+8h] [bp-848h]
  char src[4]; // [sp+14h] [bp-83Ch] BYREF
  int v19; // [sp+18h] [bp-838h]
  int v20; // [sp+1Ch] [bp-834h]
  int v21; // [sp+20h] [bp-830h]
  int v22; // [sp+24h] [bp-82Ch]
  int v23[522]; // [sp+28h] [bp-828h] BYREF

  v3 = 0;
  do
  {
    v4 = v3 + 1;
    if ( sub_1E29C(v3) )
    {
      v23[0] = 123;
      memset(&v23[1], 0, 0x7FCu);
      *(_DWORD *)src = 0;
      v19 = 0;
      v20 = 0;
      v21 = 0;
      v22 = 0;
      sprintf(src, "Chain%d:{", v3 + 1);
      dest = (char *)stpcpy((char *)v23 + 1, src);
      v6 = 0;
      v7 = dword_482A60 % 60 - 1;
      v8 = v7 - a2;
      do
      {
        v9 = v7 + (v7 < 0 ? 0x3C : 0);
        --v7;
        v6 += dword_483AA0[30720 * v3 + 2 * v9];
      }
      while ( v7 != v8 );
      sprintf(src, "N%d=%d", 0, v6);
      strcpy(dest, src);
      v10 = 1;
      v11 = 15360 * v3;
      while ( sub_1E0F0() > v10 )
      {
        v12 = 0;
        v13 = dword_482A60 % 60 - 1;
        v14 = v13 - a2;
        do
        {
          v15 = v13 + (v13 < 0 ? 0x3C : 0);
          --v13;
          v12 += dword_483AA0[120 * v10 + 2 * v11 + 2 * v15];
        }
        while ( v14 != v13 );
        sprintf(src, ",N%d=%d", v10++, v12);
        strcat((char *)v23, src);
      }
      strcat((char *)v23, "},");
      strcat(a1, (const char *)v23);
    }
    v3 = v4;
  }
  while ( v4 != 4 );
  result = &a1[strlen(a1)];
  *(result - 1) = 0;
  return result;
}
// 1203C: using guessed type int __fastcall stpcpy(_DWORD, _DWORD);
// 482A60: using guessed type int dword_482A60;
// 483AA0: using guessed type _DWORD dword_483AA0[122880];

//----- (00031BAC) --------------------------------------------------------
int sub_31BAC()
{
  unsigned int v0; // r5
  int i; // r4
  unsigned int v3; // [sp+4h] [bp-814h] BYREF
  char s[2064]; // [sp+8h] [bp-810h] BYREF

  v0 = 0;
  for ( i = 0; i != 4; ++i )
  {
    if ( sub_1E29C(i) && !sub_18654(i, (unsigned __int8)dword_80FB4, (int *)&v3) && v0 < v3 )
      v0 = v3;
  }
  if ( (unsigned int)dword_7EB9C > 4 )
  {
    snprintf(s, 0x800u, "max voltage in eeprom = %d\n", v0);
    sub_2E584(4, s, 0);
  }
  if ( v0 )
    return v0;
  else
    return -1;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 80FB4: using guessed type int dword_80FB4;

//----- (00031C64) --------------------------------------------------------
int sub_31C64()
{
  char *v0; // r12
  char v2; // [sp+0h] [bp-808h] BYREF

  strcpy(v0, "This is fix-freq version\n");
  return sub_2E584(3, &v2, 0);
}
// 31C80: variable 'v0' is possibly undefined

//----- (00031CAC) --------------------------------------------------------
int sub_31CAC()
{
  int i; // r4
  char v2[2056]; // [sp+0h] [bp-808h] BYREF

  if ( (unsigned int)dword_7EB9C > 3 )
  {
    strcpy(v2, "****power off hashboard****\n");
    sub_2E584(3, v2, 0);
  }
  for ( i = 0; i != 4; ++i )
  {
    if ( sub_1E29C(i) )
      sub_191F8((unsigned __int8)i);
  }
  sub_194DC();
  return sub_447D8();
}
// 191F8: using guessed type int __fastcall sub_191F8(_DWORD);
// 7EB9C: using guessed type int dword_7EB9C;

//----- (00031D38) --------------------------------------------------------
int sub_31D38()
{
  return dword_482A64;
}
// 482A64: using guessed type int dword_482A64;

//----- (00031D48) --------------------------------------------------------
int sub_31D48()
{
  return dword_482A68;
}
// 482A68: using guessed type int dword_482A68;

//----- (00031D58) --------------------------------------------------------
unsigned int __fastcall sub_31D58(unsigned int result, const char *a2)
{
  int v3; // r5
  int v4; // r3
  int v5; // r3
  char s[2072]; // [sp+8h] [bp-818h] BYREF

  v3 = result;
  dword_482A64 = result;
  v4 = dword_7EB9C;
  if ( a2 )
  {
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      if ( result <= 0x11 )
        v4 = (unsigned __int16)off_666C0;
      if ( result <= 0x11 )
        HIWORD(v4) = (unsigned int)off_666C0 >> 16;
      if ( result <= 0x11 )
        v4 = *(_DWORD *)(v4 + 4 * result);
      if ( result > 0x11 )
        v4 = 0;
      snprintf(s, 0x800u, "%s: %s\n", v4, a2);
      result = sub_2E584(3, s, 0);
      goto LABEL_12;
    }
  }
  else if ( (unsigned int)dword_7EB9C > 3 )
  {
    if ( result <= 0x11 )
      LOWORD(v4) = (unsigned __int16)off_666C0;
    if ( result > 0x11 )
      v4 = 0;
    else
      HIWORD(v4) = (unsigned int)off_666C0 >> 16;
    if ( result <= 0x11 )
      v4 = *(_DWORD *)(v4 + 4 * result);
    snprintf(s, 0x800u, "%s\n", v4);
    result = sub_2E584(3, s, 0);
LABEL_12:
    v5 = dword_482A64;
    if ( v3 == 3 )
      goto LABEL_14;
    goto LABEL_13;
  }
  if ( result == 3 )
    return result;
  v5 = result;
LABEL_13:
  dword_482A68 = v3;
LABEL_14:
  switch ( v5 )
  {
    case 4:
    case 5:
    case 7:
    case 8:
    case 9:
    case 10:
    case 12:
    case 14:
    case 15:
    case 16:
    case 17:
      if ( (unsigned int)dword_7EB9C > 1 )
      {
        snprintf(s, 0x800u, "%s: %s\n", "stop_mining", a2);
        sub_2E584(1, s, 0);
      }
      sub_15150();
      sub_27FF8();
      sub_27F58();
      sub_27EB8();
      sub_31CAC();
      sub_42728();
      result = sub_42784();
      break;
    case 6:
    case 11:
    case 13:
      if ( (unsigned int)dword_7EB9C > 1 )
      {
        snprintf(s, 0x800u, "%s: %s\n", "stop_mining_and_restart", a2);
        sub_2E584(1, s, 0);
      }
      sub_15150();
      sub_27FF8();
      sub_27F58();
      sub_27EB8();
      sub_31CAC();
      sub_42728();
      sub_42784();
      strcpy(s, "restart\n");
      sub_2E584(0, s, 0);
      _assert_fail("0", "driver-btm-api.c", 0x98u, "stop_mining_and_restart");
      return result;
    default:
      return result;
  }
  return result;
}
// 31DEC: control flows out of bounds to 31DF0
// 666C0: using guessed type char *off_666C0[18];
// 7EB9C: using guessed type int dword_7EB9C;
// 482A64: using guessed type int dword_482A64;
// 482A68: using guessed type int dword_482A68;

//----- (00031F90) --------------------------------------------------------
int __fastcall sub_31F90(int a1)
{
  char v3[2056]; // [sp+0h] [bp-808h] BYREF

  if ( (unsigned int)dword_7EB9C > 3 )
  {
    snprintf(v3, 0x800u, "Chain %d PIC reset failed.\n", a1);
    sub_2E584(3, v3, 0);
  }
  sub_1E200(a1, 0);
  sub_356C4(4, a1);
  sub_31D58(8u, "PIC reset failed.\n");
  return -1;
}
// 7EB9C: using guessed type int dword_7EB9C;

//----- (00032010) --------------------------------------------------------
int __fastcall sub_32010(int a1)
{
  int v1; // r5

  v1 = (unsigned __int8)a1;
  if ( !sub_191DC((unsigned __int8)a1) )
    return sub_31F90(a1);
  sub_19214(a1);
  sub_191F8(v1);
  return 0;
}
// 191F8: using guessed type int __fastcall sub_191F8(_DWORD);

//----- (0003204C) --------------------------------------------------------
int sub_3204C()
{
  int v0; // r4
  int v1; // r5

  v0 = 0;
  v1 = 0;
  do
  {
    if ( sub_1E29C(v0) )
      v1 |= sub_32010(v0);
    ++v0;
  }
  while ( v0 != 4 );
  return v1;
}

//----- (0003208C) --------------------------------------------------------
void sub_3208C()
{
  float v0; // s0
  int i; // r4
  int v2; // r0
  int v3; // r2
  int *v4; // r3
  int *v5; // r0

  if ( dword_7EDC8 != 2 )
  {
    v0 = unk_7EB74;
    goto LABEL_3;
  }
  for ( i = 0; i != 4; ++i )
  {
    if ( sub_1E29C(i) )
    {
      v2 = sub_1E0F0();
      if ( v2 > 0 )
      {
        v3 = dword_482A6C;
        v4 = (int *)((char *)&dword_4FBAA0 + 1024 * i);
        v5 = (int *)((char *)&dword_4FBAA0 + 1024 * i + 4 * v2);
        do
          *v4++ = v3;
        while ( v4 != v5 );
      }
    }
  }
  v0 = unk_7EB74;
  if ( unk_7EB74 <= 0.0 )
  {
LABEL_3:
    if ( v0 > 0.0 )
      return;
LABEL_10:
    dword_482A6C = sub_1AD08((int)&dword_4FBAA0, (unsigned __int8)byte_482A70, 1);
    return;
  }
  sub_1A870((unsigned __int8)byte_482A70, dword_7EDCC, dword_482A6C);
  if ( unk_7EB74 <= 0.0 )
    goto LABEL_10;
}
// 7EDC8: using guessed type int dword_7EDC8;
// 7EDCC: using guessed type int dword_7EDCC;
// 482A6C: using guessed type int dword_482A6C;
// 482A70: using guessed type char byte_482A70;

//----- (000321B8) --------------------------------------------------------
int __fastcall sub_321B8(int result, int a2, int a3)
{
  int v3; // r5
  int v6; // r7
  unsigned int v7; // r3
  int v8; // r0
  unsigned int i; // r1
  int v10; // r8
  int v11; // r9
  unsigned int v12; // r0
  int v13; // r9
  unsigned int j; // r1
  int v15; // r0
  char s[2080]; // [sp+10h] [bp-820h] BYREF

  v3 = result;
  if ( result && (result = sub_1E160()) != 0 && (result = sub_1E120()) != 0 )
  {
    v6 = sub_1E160();
    v7 = sub_1E130();
    if ( !v7 )
      goto LABEL_23;
    v8 = v6 << 24;
    if ( v7 != 1 )
    {
      for ( i = 1; i < v7; i *= 2 )
        ;
      v8 = sub_5FAF8(v8, i);
    }
    v10 = sub_5FAF8(a3 * v8 * a2 / 100, v3);
    dword_99EDDC = v10;
    v11 = sub_1E160();
    v12 = sub_1E130();
    if ( !v12 )
LABEL_23:
      __und(0);
    v13 = v11 << 24;
    if ( v12 != 1 )
    {
      for ( j = 1; j < v12; j *= 2 )
        ;
      v13 = sub_5FAF8(v13, j);
    }
    if ( (byte_99EDBC & 4) != 0 && word_99EDCA )
      dword_99EDDC = HIBYTE(word_99EDCA) + 1000 * (unsigned __int8)word_99EDCA;
    result = sub_44C84(v10);
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      v15 = sub_5FAF8(25 * v13, v3);
      snprintf(s, 0x800u, "freq = %d, percent = %d, hcn = %d, timeout = %d\n", v3, a3, a2 * v15, v10);
      return sub_2E584(3, s, 0);
    }
  }
  else
  {
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      strcpy(s, "Note: addrInterval or corenum is not initialized.\n");
      result = sub_2E584(3, s, 0);
    }
    dword_99EDDC = (int)&loc_1FFFC + 3;
  }
  return result;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 99EDBC: using guessed type char byte_99EDBC;
// 99EDCA: using guessed type __int16 word_99EDCA;
// 99EDDC: using guessed type int dword_99EDDC;

//----- (000323A4) --------------------------------------------------------
int sub_323A4()
{
  int result; // r0

  result = dword_7EB9C;
  dword_7EDC8 = 2;
  byte_482A71 = 1;
  if ( (unsigned int)dword_7EB9C > 3 )
    return sub_31C64();
  return result;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 7EDC8: using guessed type int dword_7EDC8;
// 482A71: using guessed type char byte_482A71;

//----- (000323DC) --------------------------------------------------------
int sub_323DC()
{
  int i; // r4
  int result; // r0
  int v2; // r0
  int v3; // r0
  char s[2072]; // [sp+8h] [bp-818h] BYREF

  for ( i = 0; i != 4; ++i )
  {
    result = sub_1E29C(i);
    if ( result && (unsigned int)dword_7EB9C > 3 )
    {
      v2 = sub_18094(i);
      snprintf(s, 0x800u, "Chain [%d] PCB Version: 0x%04x\n", i, v2);
      sub_2E584(3, s, 0);
      result = i;
      if ( (unsigned int)dword_7EB9C > 3 )
      {
        v3 = sub_18128(i);
        snprintf(s, 0x800u, "Chain [%d] BOM Version: 0x%04x\n", i, v3);
        result = sub_2E584(3, s, 0);
      }
    }
  }
  return result;
}
// 7EB9C: using guessed type int dword_7EB9C;

//----- (000324A8) --------------------------------------------------------
int sub_324A8()
{
  int result; // r0
  unsigned int v1; // r3
  int *v2; // r6
  unsigned int v3; // r7
  int *v4; // r5
  unsigned int v5; // r4
  int v6; // t1
  int v7[79]; // [sp+4h] [bp-13Ch] BYREF

  sub_3FE98(v7);
  result = sub_31720((int)v7);
  v1 = v7[0];
  if ( v7[0] )
  {
    v2 = v7;
    v3 = 0;
    do
    {
      if ( v2[2] )
      {
        v4 = v2 + 2;
        v5 = 0;
        do
        {
          v6 = v4[1];
          ++v4;
          result = sub_1E200(v6, 1);
          ++v5;
        }
        while ( v2[2] > v5 );
        v1 = v7[0];
      }
      ++v3;
      v2 += 18;
    }
    while ( v1 > v3 );
  }
  return result;
}

//----- (00032520) --------------------------------------------------------
int sub_32520()
{
  sub_42728();
  return sub_42778();
}

//----- (00032530) --------------------------------------------------------
int sub_32530()
{
  int result; // r0
  int v1; // r3
  int v2; // r3
  int v3; // r3
  int v4; // r3

  result = sub_36548();
  if ( dword_7EDC8 )
  {
    switch ( dword_482A64 )
    {
      case 0:
      case 1:
        return result;
      case 2:
        goto LABEL_9;
      case 17:
        goto LABEL_13;
      default:
        v4 = (unsigned __int8)byte_7EDD4 ^ 1;
        byte_7EDD4 ^= 1u;
        if ( v4 )
          goto LABEL_13;
        sub_42734();
        return sub_42784();
    }
  }
  if ( !result )
  {
LABEL_13:
    sub_42728();
    return sub_42784();
  }
  if ( result != 1 )
  {
LABEL_9:
    sub_42734();
    v3 = (unsigned __int8)byte_7EDD4 ^ 1;
    byte_7EDD4 ^= 1u;
    if ( v3 )
      return sub_42778();
    return sub_42784();
  }
  v1 = (unsigned __int8)byte_7EDD4 ^ 1;
  byte_7EDD4 ^= 1u;
  if ( v1 )
    sub_42728();
  else
    sub_42734();
  v2 = (unsigned __int8)byte_7EDD4 ^ 1;
  byte_7EDD4 ^= 1u;
  if ( !v2 )
    return sub_42784();
  return sub_42778();
}
// 325A4: control flows out of bounds to 325A8
// 7EDC8: using guessed type int dword_7EDC8;
// 7EDD4: using guessed type char byte_7EDD4;
// 482A64: using guessed type int dword_482A64;

//----- (0003264C) --------------------------------------------------------
int sub_3264C()
{
  int i; // r4
  int v1; // r5
  char *v2; // r10
  int result; // r0
  int v4; // r6
  unsigned int v5; // r4
  _QWORD *k; // r10
  int v7; // r12
  int v8; // r11
  int v9; // r0
  int v10; // r1
  int v11; // r1
  __int64 *v12; // r6
  unsigned int j; // r5
  bool v14; // cc
  __int64 v15; // r0
  __int64 v16; // t1
  char *v17; // [sp+20h] [bp-830h]
  char s[2088]; // [sp+28h] [bp-828h] BYREF

  for ( i = 0; i != 4; ++i )
  {
    if ( sub_1E29C(i) )
    {
      sub_1E0F0();
      v12 = (__int64 *)((char *)&qword_99CD98 + 2048 * i);
      for ( j = 0; sub_1E0F0() > j; ++j )
      {
        v14 = (unsigned int)dword_7EB9C > 4;
        v16 = *v12++;
        v15 = v16;
        *(_QWORD *)&dword_483AA0[30720 * i + 120 * j + 2 * (dword_482A60 % 60)] = v16;
        if ( v14 )
        {
          snprintf(s, 0x800u, "chain %u asic %u asic_nonce_num %llu\n", i, j, v15);
          sub_2E584(4, s, 0);
        }
      }
    }
  }
  ++dword_482A60;
  memset(byte_5924F4, 0, sizeof(byte_5924F4));
  memset(byte_590440, 0, 0x2000u);
  memset(byte_58E3F8, 0, sizeof(byte_58E3F8));
  sub_31980(byte_5924F4, 10);
  sub_31980(byte_590440, 30);
  v1 = 0;
  v2 = (char *)&unk_482AA0;
  sub_31980(byte_58E3F8, 60);
  do
  {
    result = sub_1E29C(v1);
    if ( result )
    {
      v4 = 0;
      v17 = v2;
      v5 = 0;
      for ( k = (_QWORD *)((char *)&qword_99CD98 + 2048 * v1); ; ++k )
      {
        v8 = v4 + v5;
        if ( sub_1E0F0() <= v5 )
          break;
        v9 = sub_1E100();
        sub_5FADC(v5, v9);
        if ( !v10 )
        {
          ++v4;
          v11 = v8;
          v8 = v4 + v5;
          sub_1E820(v1, v11, 32);
        }
        v7 = dword_482A60 % 60 - 1;
        if ( v7 < 0 )
          v7 = dword_482A60 % 60 + 59;
        if ( (int)dword_483AA0[30720 * v1 + 120 * v5 + 2 * v7] <= 1 )
        {
          sub_1E820(v1, v8, 120);
          ++*(_DWORD *)&v17[4 * v5];
        }
        else
        {
          sub_1E820(v1, v8, 111);
        }
        ++v5;
        *k = 0LL;
      }
      v2 = v17;
      result = sub_1E820(v1, v4 + v5, 0);
    }
    ++v1;
    v2 += 1024;
  }
  while ( v1 != 4 );
  return result;
}
// 3282C: variable 'v10' is possibly undefined
// 7EB9C: using guessed type int dword_7EB9C;
// 482A60: using guessed type int dword_482A60;
// 483AA0: using guessed type _DWORD dword_483AA0[122880];

//----- (000329DC) --------------------------------------------------------
int sub_329DC()
{
  int v0; // r4
  int v2; // r5
  int v3; // r8
  int v4; // r5
  int v5; // [sp+Ch] [bp-82Ch]
  char s[2088]; // [sp+10h] [bp-828h] BYREF

  v0 = 0;
  v5 = 0;
  do
  {
    if ( sub_1E29C(v0) )
    {
      v2 = 0;
      do
      {
        sub_4594C(v0);
        sleep(3u);
        sub_191F4((unsigned __int8)v0);
        sub_304D4();
        if ( byte_80FB0 )
        {
          if ( (unsigned int)dword_7EB9C > 3 )
          {
            snprintf(s, 0x800u, "pic enabled for chain %d, press anykey to continue...", v0);
            sub_2E584(3, s, 0);
          }
          IO_getc((_IO_FILE *)stdin);
        }
        sub_45990(v0);
        sub_304D4();
        sub_4594C(v0);
        sleep(1u);
        sub_45990(v0);
        sub_304D4();
        sub_2BE40(v0, 0);
        v3 = sub_1E67C(v0);
        if ( (unsigned int)dword_7EB9C > 3 )
        {
          snprintf(s, 0x800u, "Chain[%d]: find %d asic, times %d\n", v0, v3, v2);
          sub_2E584(3, s, 0);
        }
        ++v2;
        if ( v3 == sub_1E0F0() )
          break;
        sub_191F8((unsigned __int8)v0);
      }
      while ( v2 != 3 );
      v4 = sub_1E67C(v0);
      if ( sub_1E0F0() != v4 )
      {
        if ( (unsigned int)dword_7EB9C > 3 )
        {
          snprintf(s, 0x800u, "Chain %d only find %d asic, will power off hash board %d\n", v0, v4, v0);
          sub_2E584(3, s, 0);
        }
        v5 = -1;
        sub_191F8((unsigned __int8)v0);
        sub_1E200(v0, 0);
      }
    }
    ++v0;
  }
  while ( v0 != 4 );
  return v5;
}
// 191F4: using guessed type int __fastcall sub_191F4(_DWORD);
// 191F8: using guessed type int __fastcall sub_191F8(_DWORD);
// 7EB9C: using guessed type int dword_7EB9C;
// 7F798: using guessed type int stdin;
// 80FB0: using guessed type char byte_80FB0;

//----- (00032BD0) --------------------------------------------------------
int sub_32BD0()
{
  int v0; // r0
  int v1; // r5
  int v2; // r4
  char s[2064]; // [sp+8h] [bp-810h] BYREF

  sub_44B54(byte_99EDE0, 0x20u);
  if ( (unsigned int)dword_7EB9C > 3 )
  {
    snprintf(s, 0x800u, "miner ID : %s\n", byte_99EDE0);
    sub_2E584(3, s, 0);
  }
  v0 = sub_45C98();
  v1 = BYTE2(v0);
  v2 = (unsigned __int8)v0;
  if ( (unsigned int)dword_7EB9C > 3 )
  {
    snprintf(s, 0x800u, "FPGA Version = 0x%04X\n", (unsigned __int16)v0);
    sub_2E584(3, s, 0);
  }
  return sprintf(byte_80FDC, "%d.%d.%d.%d", v2, v1, 1, 3);
}
// 7EB9C: using guessed type int dword_7EB9C;

//----- (00032CA8) --------------------------------------------------------
int sub_32CA8()
{
  sub_302A0(dword_482A74);
  return sub_2A578();
}
// 482A74: using guessed type __time_t dword_482A74[3];

//----- (00032CC0) --------------------------------------------------------
size_t __fastcall sub_32CC0(_DWORD *a1, int a2, int a3)
{
  char v4; // r1
  int v5; // r2
  int v6; // r3
  int v7; // r0
  char *v8; // r9
  size_t v9; // r4
  size_t v10; // r2
  int v11; // r1
  __int64 v12; // r6
  int v13; // r10
  size_t v14; // r11
  size_t v15; // r7
  char *v16; // r6
  _DWORD **v17; // lr
  char *v18; // r4
  _DWORD **v19; // r3
  _DWORD *v20; // t1
  int v21; // r12
  int v22; // r0
  int v23; // r1
  int v24; // r12
  int v25; // r0
  int v26; // r1
  __int16 v27; // r0
  __int64 v28; // kr00_8
  void *v29; // r0
  __int64 src; // [sp+8h] [bp-890h] BYREF
  int v33[24]; // [sp+10h] [bp-888h] BYREF
  char v34[2088]; // [sp+70h] [bp-828h] BYREF

  v4 = *(_BYTE *)(a2 + 680);
  v33[3] = a3;
  BYTE1(v33[2]) = BYTE1(v33[2]) & 0xFE | v4 & 1 | 2;
  LOBYTE(v33[2]) = qword_482A80;
  LOWORD(v33[0]) = 82;
  src = 0LL;
  BYTE2(v33[2]) = 15;
  if ( byte_482A88 )
  {
    v5 = *(_DWORD *)(a2 + 648);
    v6 = *(_DWORD *)(a2 + 652);
    LOBYTE(v33[20]) = *(_BYTE *)(a2 + 644);
    v33[21] = v5;
    v33[22] = v6;
  }
  sub_2F724(&v33[4], (unsigned __int8 *)(a2 + 1780), 4);
  sub_2F724(&v33[5], (unsigned __int8 *)(a2 + 1712), 32);
  sub_2F724(&v33[14], (unsigned __int8 *)(a2 + 1792), 4);
  sub_2F724(&v33[13], (unsigned __int8 *)(a2 + 1804), 4);
  v7 = *(_DWORD *)(a2 + 1576);
  v8 = *(char **)(a2 + 1568);
  v9 = *(_DWORD *)(a2 + 1572);
  v10 = *(_DWORD *)(a2 + 632);
  HIWORD(v33[15]) = v7;
  LOWORD(v33[15]) = v9;
  LOWORD(v33[16]) = v10;
  v11 = *(_DWORD *)&v8[v7 + 4];
  v12 = *(_QWORD *)(a2 + 624);
  v33[18] = *(_DWORD *)&v8[v7];
  v33[19] = v11;
  src = v12;
  memcpy(&v33[18], &src, v10);
  v13 = *(_DWORD *)(a2 + 1708);
  HIWORD(v33[16]) = v13;
  v14 = v9 + 32 * v13;
  v15 = v14 + 98;
  v16 = (char *)malloc(v14 + 98);
  if ( !v16 )
  {
    strcpy(v34, "Failed to malloc tmp_buf");
    sub_2E584(3, v34, 1);
    nullsub_1(1);
    v13 = *(_DWORD *)(a2 + 1708);
    v8 = *(char **)(a2 + 1568);
    v9 = *(_DWORD *)(a2 + 1572);
  }
  v33[1] = v14 + 90;
  memset(v16, 0, v14 + 98);
  memcpy(v16, v33, 0x60u);
  memcpy(v16 + 96, v8, v9);
  if ( v13 > 0 )
  {
    v17 = *(_DWORD ***)(a2 + 676);
    v18 = &v16[v9 + 96];
    v19 = &v17[v13];
    do
    {
      v20 = *v17++;
      v18 += 32;
      v21 = v20[1];
      v22 = v20[2];
      v23 = v20[3];
      *((_DWORD *)v18 - 8) = *v20;
      *((_DWORD *)v18 - 7) = v21;
      *((_DWORD *)v18 - 6) = v22;
      *((_DWORD *)v18 - 5) = v23;
      v24 = v20[5];
      v25 = v20[6];
      v26 = v20[7];
      *((_DWORD *)v18 - 4) = v20[4];
      *((_DWORD *)v18 - 3) = v24;
      *((_DWORD *)v18 - 2) = v25;
      *((_DWORD *)v18 - 1) = v26;
    }
    while ( v17 != v19 );
  }
  v27 = sub_31590((int)v16, (unsigned __int16)(v14 + 96));
  v28 = qword_482A80;
  *(_WORD *)&v16[v14 + 96] = v27;
  qword_482A80 = v28 + 1;
  v29 = malloc(v15);
  *a1 = v29;
  memcpy(v29, v16, v15);
  free(v16);
  return v14 + 98;
}
// 2A574: using guessed type int __fastcall nullsub_1(_DWORD);
// 482A80: using guessed type __int64 qword_482A80;
// 482A88: using guessed type char byte_482A88;

//----- (00032F40) --------------------------------------------------------
int __fastcall sub_32F40(unsigned __int8 *a1)
{
  int v3; // r8
  size_t v4; // r8
  unsigned __int8 *v5; // r0
  unsigned __int8 *v6; // r6
  int v7; // r2
  int v8; // r1
  int v9; // r3
  int v10; // r2
  int v11; // r3
  unsigned __int8 v12; // r2
  int v13; // r1
  int v14; // r0
  int v15; // r3
  int v16; // r0
  int v17; // r3
  int v18; // r0
  int v19; // lr
  __int64 v20; // r2
  int v21; // r0
  int v22; // r0
  int v23; // r0
  int v24[16]; // [sp+10h] [bp-878h] BYREF
  __int64 v25; // [sp+50h] [bp-838h]
  int v26; // [sp+58h] [bp-830h]
  int v27; // [sp+5Ch] [bp-82Ch]
  char s[2088]; // [sp+60h] [bp-828h] BYREF

  if ( *a1 != 82 )
  {
    if ( !byte_482A5D || !byte_590404 && !byte_482A5C && dword_7EBA0 <= 6 )
      return -1;
    snprintf(s, 0x800u, "%s: SEND_JOB_TYPE is wrong : 0x%x\n", "dhash_chip_send_job", *a1);
    sub_2E584(7, s, 0);
    return -1;
  }
  v3 = *((_DWORD *)a1 + 1);
  if ( byte_482A5D && (byte_590404 || byte_482A5C || dword_7EBA0 > 6) )
  {
    snprintf(s, 0x800u, "%s: len = 0x%x\n", "dhash_chip_send_job", *((_DWORD *)a1 + 1));
    sub_2E584(7, s, 0);
  }
  v4 = v3 + 8;
  v5 = (unsigned __int8 *)calloc(v4, 1u);
  v6 = v5;
  if ( !v5 )
  {
    if ( !byte_482A5D || !byte_590404 && !byte_482A5C && dword_7EBA0 <= 6 )
      return -2;
    snprintf(s, 0x800u, "%s: malloc buffer failed.\n", "dhash_chip_send_job");
    sub_2E584(7, s, 0);
    return -2;
  }
  memcpy(v5, a1, v4);
  if ( !byte_482A88 )
  {
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      strcpy(s, "only support asic boost");
      sub_2E584(3, s, (unsigned __int8)byte_482A88);
    }
    goto LABEL_44;
  }
  v7 = v6[80];
  v8 = dword_7EDD8;
  if ( v6[80] )
  {
    v10 = *((_DWORD *)v6 + 22);
    dword_7EB58 = *((_DWORD *)v6 + 21);
    v9 = dword_7EB58;
    dword_80F98 = v10;
    if ( dword_7EB58 == dword_7EDD8 )
      goto LABEL_20;
  }
  else
  {
    v9 = 1;
    dword_7EB58 = 1;
    dword_80F98 = v7;
    if ( dword_7EDD8 == 1 )
      goto LABEL_44;
  }
  if ( (unsigned int)dword_7EB9C > 3 )
  {
    snprintf(s, 0x800u, "Version num %d\n", v9);
    sub_2E584(3, s, 0);
  }
  v8 = dword_7EB58;
  dword_7EDD8 = dword_7EB58;
LABEL_20:
  if ( ((v8 - 4) & 0xFFFFFFFB) != 0 )
  {
LABEL_44:
    free(v6);
    return 0;
  }
  v11 = dword_80F98;
  if ( dword_7EDDC != dword_80F98 )
  {
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      snprintf(s, 0x800u, "Mask num 0x%x\n", dword_80F98);
      sub_2E584(3, s, 0);
      v11 = dword_80F98;
      v8 = dword_7EB58;
    }
    dword_7EDDC = v11;
    sub_321B8(dword_482A6C, v8, 90);
  }
  v12 = v6[9];
  if ( (v12 & 2) != 0 )
  {
    sub_44E1C(v6[10]);
    v12 = v6[9];
  }
  v13 = *((unsigned __int16 *)v6 + 30);
  v26 = dword_99EDDC;
  v14 = *((_DWORD *)v6 + 3);
  v24[4] = (int)&a1[v13 + 96];
  v15 = *((unsigned __int16 *)v6 + 33);
  v24[8] = v14;
  v16 = *((_DWORD *)v6 + 14);
  v24[5] = v15;
  v17 = *((unsigned __int16 *)v6 + 32);
  v24[7] = v16;
  v18 = *((unsigned __int16 *)v6 + 31);
  v27 = v12 & 1;
  v24[10] = dword_80F98;
  v24[14] = v17;
  v19 = *((_DWORD *)v6 + 4);
  v24[11] = (int)(v6 + 20);
  v24[13] = v18;
  v20 = *((_QWORD *)v6 + 9);
  v21 = *((_DWORD *)v6 + 13);
  v24[1] = dword_7EB58;
  v24[3] = v13;
  v24[2] = (int)(a1 + 96);
  v24[9] = v19;
  v25 = v20;
  v24[12] = 32;
  v24[6] = v21;
  v24[0] = 0;
  if ( !byte_482A89 )
  {
    v22 = sub_452B0();
    sub_452D0(v22 | 0x10000);
    v23 = sub_4476C();
    sub_44794(v23 | 0x80);
    byte_482A89 = 1;
  }
  if ( (unsigned int)dword_7EB9C > 4 )
  {
    snprintf(s, 0x800u, "start to send job, mid_auto_gen = %d", v24[0]);
    sub_2E584(4, s, 0);
  }
  sub_45334((int)v24);
  free(v6);
  if ( byte_482A5D && (byte_590404 || byte_482A5C || dword_7EBA0 > 6) )
  {
    snprintf(s, 0x800u, "--- %s end\n", "dhash_chip_send_job");
    sub_2E584(7, s, 0);
  }
  sub_302A0(dword_482A74);
  sub_304D4();
  return 0;
}
// 7EB58: using guessed type int dword_7EB58;
// 7EB9C: using guessed type int dword_7EB9C;
// 7EBA0: using guessed type int dword_7EBA0;
// 7EDD8: using guessed type int dword_7EDD8;
// 7EDDC: using guessed type int dword_7EDDC;
// 80F98: using guessed type int dword_80F98;
// 482A5C: using guessed type char byte_482A5C;
// 482A5D: using guessed type char byte_482A5D;
// 482A6C: using guessed type int dword_482A6C;
// 482A74: using guessed type __time_t dword_482A74[3];
// 482A88: using guessed type char byte_482A88;
// 482A89: using guessed type char byte_482A89;
// 590404: using guessed type char byte_590404;
// 99EDDC: using guessed type int dword_99EDDC;

//----- (0003345C) --------------------------------------------------------
unsigned int sub_3345C()
{
  sub_44AE4();
  sub_458E4(15);
  return sleep(2u);
}

//----- (00033478) --------------------------------------------------------
int __fastcall sub_33478(int result, int a2)
{
  pthread_mutex_t *v2; // r8
  int v3; // r4
  int v5; // r7
  size_t v6; // r5
  void *v7; // r0
  int v8; // r5
  void *v9; // r0
  int v10; // lr
  int v11; // r12
  int v12; // r0
  _DWORD *v13; // r11
  int v14; // r5
  int v15; // r10
  _DWORD *v16; // r3
  _DWORD *v17; // r2
  int v18; // r12
  int v19; // r0
  int v20; // r1
  int v21; // r12
  int v22; // r0
  int v23; // r1
  int *v24; // r0
  int *v25; // r0
  int *v26; // r0
  int *v27; // r0
  char s[2088]; // [sp+10h] [bp-828h] BYREF

  if ( *(_DWORD *)(a2 + 672) )
  {
    v2 = (pthread_mutex_t *)(result + 212);
    v3 = result;
    v5 = *(_DWORD *)(a2 + 1708);
    v6 = *(_DWORD *)(a2 + 1572);
    if ( pthread_mutex_lock((pthread_mutex_t *)(result + 212)) )
    {
      v25 = _errno_location();
      snprintf(
        s,
        0x800u,
        "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
        *v25,
        "driver-btm-api.c",
        "copy_pool_stratum",
        1140);
      sub_2E584(3, s, 1);
      nullsub_1(1);
    }
    if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(v3 + 236)) )
    {
      v26 = _errno_location();
      snprintf(
        s,
        0x800u,
        "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
        *v26,
        "driver-btm-api.c",
        "copy_pool_stratum",
        1140);
      sub_2E584(3, s, 1);
      nullsub_1(1);
    }
    free(*(void **)(v3 + 672));
    free(*(void **)(v3 + 612));
    free(*(void **)(v3 + 1568));
    if ( (v6 & 3) != 0 )
      v6 = (v6 & 0xFFFFFFFC) + 4;
    v7 = calloc(v6, 1u);
    *(_DWORD *)(v3 + 1568) = v7;
    if ( !v7 )
    {
      strcpy(s, "Failed to calloc pool_stratum coinbase in c5");
      sub_2E584(3, s, 1);
      nullsub_1(1);
      v7 = *(void **)(v3 + 1568);
    }
    memcpy(v7, *(const void **)(a2 + 1568), v6);
    if ( *(int *)(v3 + 1708) > 0 )
    {
      v8 = 0;
      do
      {
        v9 = *(void **)(*(_DWORD *)(v3 + 676) + 4 * v8++);
        free(v9);
      }
      while ( *(_DWORD *)(v3 + 1708) > v8 );
    }
    if ( v5 )
    {
      v13 = realloc(*(void **)(v3 + 676), 4 * v5 + 1);
      *(_DWORD *)(v3 + 676) = v13;
      if ( v5 > 0 )
      {
        v14 = 0;
        while ( 1 )
        {
          v15 = 4 * v14;
          v13[v14] = malloc(0x20u);
          v16 = *(_DWORD **)(*(_DWORD *)(v3 + 676) + 4 * v14);
          if ( !v16 )
          {
            strcpy(s, "Failed to malloc pool_stratum swork merkle_bin");
            sub_2E584(3, s, 1);
            nullsub_1(1);
            v16 = *(_DWORD **)(*(_DWORD *)(v3 + 676) + 4 * v14);
          }
          ++v14;
          v17 = *(_DWORD **)(*(_DWORD *)(a2 + 676) + v15);
          v18 = v17[1];
          v19 = v17[2];
          v20 = v17[3];
          *v16 = *v17;
          v16[1] = v18;
          v16[2] = v19;
          v16[3] = v20;
          v21 = v17[5];
          v22 = v17[6];
          v23 = v17[7];
          v16[4] = v17[4];
          v16[5] = v21;
          v16[6] = v22;
          v16[7] = v23;
          if ( v5 == v14 )
            break;
          v13 = *(_DWORD **)(v3 + 676);
        }
      }
    }
    *(_DWORD *)v3 = *(_DWORD *)a2;
    *(_QWORD *)(v3 + 1824) = *(_QWORD *)(a2 + 1824);
    *(_DWORD *)(v3 + 1572) = *(_DWORD *)(a2 + 1572);
    *(_DWORD *)(v3 + 1576) = *(_DWORD *)(a2 + 1576);
    *(_DWORD *)(v3 + 632) = *(_DWORD *)(a2 + 632);
    *(_DWORD *)(v3 + 1708) = *(_DWORD *)(a2 + 1708);
    *(_DWORD *)(v3 + 672) = _strdup(*(const char **)(a2 + 672));
    *(_DWORD *)(v3 + 612) = _strdup(*(const char **)(a2 + 612));
    v10 = *(_DWORD *)(a2 + 1808);
    v11 = *(_DWORD *)(a2 + 1812);
    *(_DWORD *)(v3 + 1804) = *(_DWORD *)(a2 + 1804);
    *(_DWORD *)(v3 + 1808) = v10;
    *(_DWORD *)(v3 + 1812) = v11;
    memcpy((void *)(v3 + 1580), (const void *)(a2 + 1580), 0x80u);
    if ( pthread_rwlock_unlock((pthread_rwlock_t *)(v3 + 236)) )
    {
      v27 = _errno_location();
      snprintf(
        s,
        0x800u,
        "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v27,
        "driver-btm-api.c",
        "copy_pool_stratum",
        1178);
      sub_2E584(3, s, 1);
      nullsub_1(1);
    }
    v12 = pthread_mutex_unlock(v2);
    if ( v12 )
    {
      v24 = _errno_location();
      snprintf(
        s,
        0x800u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v24,
        "driver-btm-api.c",
        "copy_pool_stratum",
        1178);
      sub_2E584(3, s, 1);
      v12 = nullsub_1(1);
    }
    return off_7ECC4(v12);
  }
  return result;
}
// 2A574: using guessed type int __fastcall nullsub_1(_DWORD);
// 7ECC4: using guessed type int (__fastcall *off_7ECC4)(_DWORD);

//----- (0003388C) --------------------------------------------------------
int sub_3388C()
{
  char s; // [sp+8h] [bp-810h] BYREF

  BYTE2(off_7EDE0) = dword_80FAC;
  BYTE1(off_7EDE0) = dword_80FA8;
  if ( (unsigned int)dword_7EB9C > 3 )
  {
    snprintf(
      &s,
      0x800u,
      "pulse_mode = %d, ccdly_sel = %d, pwth_sel = %d\n",
      (unsigned __int8)off_7EDE0,
      (unsigned __int8)dword_80FAC,
      (unsigned __int8)dword_80FA8);
    sub_2E584(3, &s, 0);
  }
  return (unsigned __int8)off_7EDE0 | (unsigned __int16)(BYTE1(off_7EDE0) << 8) | (BYTE2(off_7EDE0) << 16);
}
// 7EB9C: using guessed type int dword_7EB9C;
// 7EDE0: using guessed type void *off_7EDE0;
// 80FA8: using guessed type int dword_80FA8;
// 80FAC: using guessed type int dword_80FAC;

//----- (00033950) --------------------------------------------------------
int sub_33950()
{
  int v0; // r0
  __int16 v2; // [sp+4h] [bp-Ch]
  char v3; // [sp+6h] [bp-Ah]

  v0 = sub_3388C();
  v3 = BYTE2(v0);
  v2 = v0;
  sub_1E970();
  sub_304D4();
  sub_1ED08();
  sub_304D4();
  sub_1EF94(255, v2);
  sub_304D4();
  sub_1EFE0(255, SHIBYTE(v2), v3, 0);
  sub_304D4();
  sub_1EAD4(0xFFu);
  sub_304D4();
  sub_1EA18(255, 0, 1, 3);
  return sub_1EA84(255);
}

//----- (000339EC) --------------------------------------------------------
int sub_339EC()
{
  unsigned int v0; // r2
  int v1; // r5
  int v3; // r0
  int i; // r6
  int v5; // r0
  unsigned int v6; // r7
  char s[2072]; // [sp+8h] [bp-818h] BYREF

  v0 = dword_7EB9C;
  dword_7EDC8 = 2;
  byte_482A71 = 1;
  if ( (unsigned int)dword_7EB9C <= 3 || (sub_31C64(), v0 = dword_7EB9C, (unsigned int)dword_7EB9C <= 3) )
  {
    if ( byte_80DA0 )
      goto LABEL_3;
  }
  else
  {
    snprintf(s, 0x800u, "Miner compile time: %s type: %s\n", byte_80BA0, dest);
    sub_2E584(3, s, 0);
    v0 = dword_7EB9C;
    if ( byte_80DA0 )
    {
      if ( (unsigned int)dword_7EB9C <= 3 )
        goto LABEL_3;
      snprintf(s, 0x800u, "Miner sn: %s\n", &byte_80DA0);
      sub_2E584(3, s, 0);
      v0 = dword_7EB9C;
    }
  }
  if ( v0 > 3 )
  {
    strcpy(s, "commit version: dd076742 2022-10-27 22:42:25, build by: jenkins 2022-12-06 16:28:38\n");
    sub_2E584(3, s, 0);
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      snprintf(s, 0x800u, "opt_multi_version     = %d\n", dword_7EB58);
      sub_2E584(3, s, 0);
      if ( (unsigned int)dword_7EB9C > 3 )
      {
        snprintf(s, 0x800u, "opt_bitmain_ab        = %d\n", (unsigned __int8)byte_7EB5C);
        sub_2E584(3, s, 0);
        if ( (unsigned int)dword_7EB9C > 3 )
        {
          snprintf(s, 0x800u, "mid_auto_gen          = %d\n", 0);
          sub_2E584(3, s, 0);
          if ( (unsigned int)dword_7EB9C > 3 )
          {
            snprintf(s, 0x800u, "opt_bitmain_work_mode = %d\n", dword_80FB4);
            sub_2E584(3, s, 0);
            if ( sub_3FD74() )
              return 0;
            goto LABEL_16;
          }
        }
      }
    }
  }
LABEL_3:
  if ( sub_3FD74() )
    return 0;
LABEL_16:
  sub_140E4();
  sub_141B4();
  sub_42728();
  sub_42778();
  byte_7EB5C = 1;
  sub_24364();
  sub_25284();
  if ( sub_1B4AC() )
    return 0;
  sub_3345C();
  sub_13FB0(100);
  sub_32BD0();
  sub_45B74();
  sub_324A8();
  if ( sub_1E28C() )
  {
    if ( byte_590404 || byte_482A5C || dword_7EBA0 > 4 )
    {
      v3 = sub_1E28C();
      snprintf(s, 0x800u, "chain num = %d", v3);
      sub_2E584(5, s, 0);
    }
    for ( i = 0; i != 4; ++i )
    {
      v5 = i;
      v6 = (unsigned __int8)i;
      if ( sub_1E29C(v5) )
        sub_4FA0C(v6);
    }
    sub_17EF8();
    if ( sub_17F7C() )
      goto LABEL_32;
    if ( dword_7EDC8 != 1 )
    {
      sub_356C4(3, 255);
      if ( (unsigned int)dword_7EB9C > 3 )
      {
LABEL_31:
        strcpy(s, "Fixture data load failed, exit.\n");
        sub_2E584(3, s, 0);
      }
LABEL_32:
      v1 = dword_7EDC8;
      if ( !dword_7EDC8 && sub_36218() && !sub_17F90() && (unsigned int)dword_7EB9C > 3 )
      {
        strcpy(s, "Miner data load failed, exit.\n");
        sub_2E584(3, s, 0);
        return v1;
      }
      return 0;
    }
    if ( (unsigned int)dword_7EB9C > 3 )
      goto LABEL_31;
    return 0;
  }
  v1 = -1;
  if ( (unsigned int)dword_7EB9C > 3 )
  {
    strcpy(s, "No chain exist, exit.\n");
    sub_2E584(3, s, 0);
  }
  return v1;
}
// 7EB58: using guessed type int dword_7EB58;
// 7EB5C: using guessed type char byte_7EB5C;
// 7EB9C: using guessed type int dword_7EB9C;
// 7EBA0: using guessed type int dword_7EBA0;
// 7EDC8: using guessed type int dword_7EDC8;
// 80FB4: using guessed type int dword_80FB4;
// 482A5C: using guessed type char byte_482A5C;
// 482A71: using guessed type char byte_482A71;
// 590404: using guessed type char byte_590404;

//----- (00033E34) --------------------------------------------------------
int sub_33E34()
{
  int v0; // r4
  int v1; // r0
  int v3; // r0
  const char *v4; // r0
  char v5[2064]; // [sp+0h] [bp-810h] BYREF

  sub_323DC();
  sub_446DC();
  v0 = sub_13DA4(0xFA0u, 1);
  if ( v0 )
    return v0;
  if ( (unsigned int)dword_7EB9C > 3 )
  {
    strcpy(v5, "Fan check passed.\n");
    sub_2E584(3, v5, 0);
    v0 = sub_3204C();
    if ( !v0 )
      goto LABEL_4;
  }
  else
  {
    v0 = sub_3204C();
    if ( !v0 )
      goto LABEL_4;
  }
  if ( !sub_1E28C() || !dword_7EDC8 )
    return v0;
LABEL_4:
  sub_27940();
  sub_14FA4();
  if ( byte_7EB79 )
  {
    v4 = (const char *)sub_1E0C0();
    if ( !strcmp(v4, "BHB28601") )
      v1 = 1900;
    else
      v1 = 1500;
LABEL_18:
    v0 = sub_19698(v1);
    if ( v0 )
    {
      sub_356C4(12, 0);
      sub_31D58(9u, "get power type version failed!");
      return v0;
    }
    goto LABEL_6;
  }
  v1 = dword_482A8C;
  if ( dword_482A8C > 0 )
    goto LABEL_18;
LABEL_6:
  if ( (unsigned int)dword_7EB9C > 3 )
  {
    v3 = sub_1572C();
    snprintf(v5, 0x800u, "start up min temp by 75a = %d", v3);
    sub_2E584(3, v5, 0);
  }
  sub_448C8();
  sub_449E0();
  sub_44A50();
  sub_304D4();
  sub_28138(115200);
  sub_304D4();
  v0 = sub_329DC();
  if ( !v0 || sub_1E28C() && dword_7EDC8 )
  {
    sub_33950();
    v0 = 0;
    dword_7F8D4 = 0;
    dword_7F8DC = 0;
    dword_7F8D8 = 0;
  }
  return v0;
}
// 7EB79: using guessed type char byte_7EB79;
// 7EB9C: using guessed type int dword_7EB9C;
// 7EDC8: using guessed type int dword_7EDC8;
// 7F8D4: using guessed type int dword_7F8D4;
// 7F8D8: using guessed type int dword_7F8D8;
// 7F8DC: using guessed type int dword_7F8DC;
// 482A8C: using guessed type int dword_482A8C;

//----- (0003403C) --------------------------------------------------------
void sub_3403C()
{
  int v0; // r11
  int v1; // r0
  int *v2; // r10
  int v3; // r9
  char *v4; // r11
  int v5; // r0
  pthread_mutex_t *v6; // r8
  int v7; // r3
  int v8; // r7
  int v9; // r5
  int v10; // r4
  unsigned int v11; // r4
  bool v12; // cc
  int *v13; // r4
  int v14; // r6
  int v15; // r11
  int v16; // r0
  int v17; // r0
  int v18; // r8
  int v19; // r6
  int v20; // r0
  char v22; // r8
  int v23; // r11
  int v24; // r10
  int v25; // r7
  int v26; // r3
  int v27; // r5
  unsigned __int16 *v28; // r4
  int v29; // r6
  int v30; // r8
  int v31; // r0
  int v32; // r0
  int v33; // r0
  int v34; // r0
  int v35; // r0
  int v36; // r0
  int v37; // r0
  int v38; // r0
  int v39; // r5
  int v40; // r8
  int v41; // [sp+10h] [bp-880h]
  char *format; // [sp+20h] [bp-870h]
  pthread_mutex_t *v43; // [sp+24h] [bp-86Ch]
  int v44; // [sp+24h] [bp-86Ch]
  int v45; // [sp+2Ch] [bp-864h]
  int *v46; // [sp+2Ch] [bp-864h]
  int v47; // [sp+30h] [bp-860h]
  int v48; // [sp+34h] [bp-85Ch]
  int v49; // [sp+44h] [bp-84Ch]
  char *s; // [sp+48h] [bp-848h]
  __int16 v51; // [sp+54h] [bp-83Ch]
  char v52; // [sp+56h] [bp-83Ah]
  __time_t v53[2]; // [sp+58h] [bp-838h] BYREF
  char v54[2096]; // [sp+60h] [bp-830h] BYREF

  v0 = 0;
  v48 = 0;
  v1 = sub_3388C();
  v51 = v1;
  v52 = BYTE2(v1);
  sub_1629C();
  do
  {
    if ( !sub_1E29C(v0) )
      goto LABEL_3;
    v2 = dword_5945B8;
    v3 = v0;
    s = (char *)&word_59CD98[0x80000 * v0];
    v49 = 0;
    sub_1F0E0(v0, 1, 0, (unsigned __int8)byte_482A70);
    while ( 1 )
    {
      byte_8110C = 1;
      sub_2BDD0();
      memset(s, 0, 0x100000u);
      v47 = sub_1E0F0();
      if ( v47 > 0 )
      {
        v4 = v54;
        v45 = 0;
        do
        {
          v5 = sub_1E160();
          v6 = &stru_810DC;
          sub_50DA8((unsigned __int8)v3, v45 * v5);
          sub_302A0(v53);
          do
          {
            pthread_mutex_lock(v6);
            v7 = v2[2];
            v8 = v7;
            if ( v7 > 0 )
            {
              v9 = 0;
              format = v4;
              v43 = v6;
              while ( 1 )
              {
                v10 = v2[1];
                ++v9;
                v2[2] = v7 - 1;
                v11 = v10 + 1;
                v12 = v11 > 0x1FE;
                if ( v11 <= 0x1FE )
                  v2[1] = v11;
                v13 = &v2[2 * v11];
                if ( v12 )
                  v2[1] = 0;
                if ( *((unsigned __int8 *)v13 + 11) == v3 && *((_BYTE *)v13 + 10) == 64 )
                {
                  v14 = *((unsigned __int8 *)v13 + 9);
                  v15 = v13[1];
                  v16 = sub_1E160();
                  v17 = sub_5FAF8(v14, v16);
                  v18 = *((unsigned __int8 *)v13 + 9);
                  v19 = *((_BYTE *)v13 + 11) & 3;
                  word_59CD98[0x80000 * (v3 & 3) + 1 + 2048 * v17 + 2 * (*((_WORD *)v13 + 3) & 0x3FF)] = v15;
                  v20 = sub_1E160();
                  word_59CD98[2048 * (sub_5FAF8(v18, v20) + (v19 << 8)) + 2 * (*((_WORD *)v13 + 3) & 0x3FF)] = 1;
                }
                if ( v8 == v9 )
                  break;
                v7 = v2[2];
              }
              v4 = format;
              v6 = v43;
            }
            pthread_mutex_unlock(v6);
            usleep(0x3E8u);
            sub_302A0((__time_t *)v4);
          }
          while ( (int)sub_30578(v4, v53) <= 99 );
        }
        while ( v47 != ++v45 );
      }
      v44 = sub_1E0F0();
      if ( v44 <= 0 )
        break;
      v22 = 0;
      v46 = v2;
      v23 = 0;
      v24 = 0;
      do
      {
        v25 = sub_1E120();
        if ( v25 > 0 )
        {
          v26 = 0;
          v27 = 0;
          v28 = &word_59CD98[2048 * (v23 + v48)];
          do
          {
            v29 = v28[1];
            if ( !v28[1] )
            {
              v30 = *v28;
              if ( *v28 )
              {
                if ( (unsigned int)dword_7EB9C > 3 )
                {
                  snprintf(v54, 0x800u, "core %8d data in asic %d is zero", v27, v23);
                  sub_2E584(3, v54, v29);
                }
              }
              else if ( (unsigned int)dword_7EB9C > 3 )
              {
                snprintf(v54, 0x800u, "core %8d in asic %d not returned", v27, v23);
                sub_2E584(3, v54, v30);
              }
              v26 = 1;
              ++v24;
              v22 = 1;
            }
            ++v27;
            v28 += 2;
          }
          while ( v25 != v27 );
          if ( v26 )
          {
            if ( (unsigned int)dword_7EB9C > 3 )
            {
              snprintf(v54, 0x800u, "reopen asic %d", v23);
              sub_2E584(3, v54, 0);
            }
            v31 = sub_1E160();
            sub_50CC4((unsigned __int8)v3, v23 * v31, 1);
            usleep(0x2710u);
            v32 = sub_1E160();
            sub_50CC4((unsigned __int8)v3, v23 * v32, 0);
            usleep(0x2710u);
            v33 = sub_1E160();
            sub_515D0((unsigned __int8)v3, v23 * v33, v51, 0);
            sub_304D4();
            v34 = sub_1E160();
            sub_51668((unsigned __int8)v3, v23 * v34, SHIBYTE(v51), v52, 0);
            v35 = sub_1E160();
            sub_50DF8((unsigned __int8)v3, v23 * v35);
            usleep(0x2710u);
            if ( (unsigned int)dword_7EB9C > 3 )
            {
              snprintf(v54, 0x800u, "reset clock asic %d", v23);
              sub_2E584(3, v54, 0);
            }
            v36 = sub_1E160();
            sub_517F8((unsigned __int8)v3, v23 * v36, 0);
            v37 = sub_1E160();
            sub_51794((unsigned __int8)v3, v23 * v37);
            usleep(0x186A0u);
            v38 = sub_1E160();
            sub_517F8((unsigned __int8)v3, v23 * v38, 1);
          }
        }
        ++v23;
      }
      while ( v44 != v23 );
      v39 = v24;
      v2 = v46;
      if ( (unsigned int)dword_7EB9C > 3 )
        goto LABEL_55;
LABEL_44:
      if ( v39 <= 155 )
      {
        v0 = v3;
        goto LABEL_51;
      }
      usleep((__useconds_t)&unk_F4240);
      if ( v49 <= 1 )
        v40 = v22 & 1;
      else
        v40 = 0;
      if ( !v40 )
      {
        v0 = v3;
        goto LABEL_3;
      }
    }
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      v39 = 0;
      v22 = 0;
LABEL_55:
      v41 = v49++;
      snprintf(
        v54,
        0x800u,
        "chain %d, bad core num %8d, rate = %.2f ========================round %d",
        v3,
        v39,
        (float)((float)v39 / 12168.0),
        v41);
      sub_2E584(3, v54, 0);
      goto LABEL_44;
    }
    v0 = v3;
    v39 = 0;
LABEL_51:
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      snprintf(v54, 0x800u, "bad count is acceptable = %d", v39);
      sub_2E584(3, v54, 0);
    }
    usleep((__useconds_t)&unk_F4240);
LABEL_3:
    ++v0;
    v48 += 256;
  }
  while ( v0 != 4 );
  byte_8110C = 0;
  sub_162B0();
}
// 7EB9C: using guessed type int dword_7EB9C;
// 810DC: using guessed type pthread_mutex_t stru_810DC;
// 8110C: using guessed type char byte_8110C;
// 482A70: using guessed type char byte_482A70;
// 5945B8: using guessed type int dword_5945B8[];
// 59CD98: using guessed type _WORD word_59CD98[57332];
// 3403C: using guessed type __time_t var_838[2];

//----- (00034680) --------------------------------------------------------
int sub_34680()
{
  int i; // r4
  int result; // r0
  char v2[2072]; // [sp+0h] [bp-818h] BYREF

  if ( (unsigned int)dword_7EB9C > 3 )
  {
    strcpy(v2, "soft open core");
    sub_2E584(3, v2, 0);
  }
  for ( i = 0; i != 4; ++i )
  {
    result = sub_1E29C(i);
    if ( result )
    {
      sub_50C38((unsigned __int8)i, 1);
      usleep((__useconds_t)&loc_30D40);
      sub_50C38((unsigned __int8)i, 0);
      usleep((__useconds_t)"version array failed\n");
      sub_50DD4((unsigned __int8)i);
      result = usleep((__useconds_t)&loc_30D40);
    }
  }
  return result;
}
// 7EB9C: using guessed type int dword_7EB9C;

//----- (00034818) --------------------------------------------------------
unsigned int sub_34818()
{
  return sub_31D58(0xEu, "Can't get temperature sensor type!");
}

//----- (00034828) --------------------------------------------------------
int __fastcall sub_34828(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  int v9; // r0
  int v10; // r5
  int v11; // r8
  int v12; // r0
  unsigned int v13; // r7
  int v14; // r0
  unsigned int v15; // r3
  int v16; // r3
  int v17; // r0
  unsigned __int8 v18; // r0
  int v19; // r5
  int v20; // r0
  int v21; // r10
  unsigned int v22; // r6
  _QWORD *j; // r11
  int v24; // r7
  int v25; // r0
  int v26; // r1
  int v27; // r1
  int v28; // r6
  const char *v29; // r0
  float v30; // s15
  int v31; // r3
  int v32; // r2
  __int64 v33; // r0
  int i; // r5
  int v35; // r0
  unsigned int v36; // r6
  int v37; // r0
  int v38; // r0
  int v39; // r0
  int v40; // r3
  int v41; // r0
  int v42; // r6
  int v43; // r8
  const char *v44; // r0
  const char *v45; // r0
  const char *v46; // r0
  float v47; // s15
  int v48; // r2
  unsigned int v49; // r6
  int v50; // r2
  int v51; // r7
  const char *v52; // r0
  unsigned int v53; // [sp+14h] [bp-85Ch] BYREF
  int v54; // [sp+18h] [bp-858h]
  int v55; // [sp+1Ch] [bp-854h]
  int v56; // [sp+20h] [bp-850h]
  int v57; // [sp+24h] [bp-84Ch]
  int v58; // [sp+28h] [bp-848h]
  int v59; // [sp+2Ch] [bp-844h]
  int v60; // [sp+30h] [bp-840h]
  int v61; // [sp+34h] [bp-83Ch]
  char s[2088]; // [sp+38h] [bp-838h] BYREF
  int v63; // [sp+860h] [bp-10h]
  int v64; // [sp+864h] [bp-Ch]
  int v65; // [sp+868h] [bp-8h]
  int v66; // [sp+86Ch] [bp-4h]

  v63 = a1;
  v64 = a2;
  v65 = a3;
  v66 = a4;
  v54 = a1;
  v55 = a2;
  v56 = a3;
  v57 = a4;
  v58 = a5;
  v59 = a6;
  v60 = a7;
  v61 = a8;
  *(_DWORD *)&byte_99EDB8 = a1;
  *(_DWORD *)&byte_99EDBC = a2;
  unk_99EDC0 = a3;
  *(_DWORD *)&word_99EDC4 = a4;
  unk_99EDC8 = a5;
  unk_99EDCC = a6;
  unk_99EDD0 = a7;
  unk_99EDD4 = a8;
  if ( (unsigned __int8)a1 != 81 )
  {
    if ( (unsigned int)dword_7EB9C <= 4 )
      return 0;
    snprintf(s, 0x800u, "config_parameter.token_type != 0x%x, it is 0x%x\n", 81, (unsigned __int8)v54);
LABEL_5:
    sub_2E584(4, s, 0);
    return 0;
  }
  v9 = sub_31590((int)&byte_99EDB8, 30);
  if ( v9 != (unsigned __int16)word_99EDD6 )
  {
    if ( (unsigned int)dword_7EB9C <= 4 )
      return 0;
    snprintf(s, 0x800u, "config_parameter.crc = 0x%x, but we calculate it as 0x%x\n", (unsigned __int16)word_99EDD6, v9);
    goto LABEL_5;
  }
  if ( (unsigned int)dword_7EB9C > 3 )
  {
    snprintf(
      s,
      0x800u,
      "fan_eft : %d  fan_pwm : %d\n",
      ((unsigned __int8)byte_99EDBC >> 1) & 1,
      (unsigned __int8)byte_99EDC2);
    sub_2E584(3, s, 0);
  }
  v10 = dword_7EDC8;
  if ( !dword_7EDC8 )
  {
    v11 = (unsigned __int8)sub_362A0(161);
    do
    {
      v12 = v10;
      v13 = (unsigned __int8)v10++;
      if ( sub_1E29C(v12) )
        sub_4FA0C(v13);
    }
    while ( v10 != 4 );
    if ( v11 )
      return 0;
  }
  if ( (unsigned __int8)sub_27A58() )
    return 0;
  if ( byte_482A71 && (byte_99EDBC & 0x10) != 0 )
  {
    dword_482A8C = (unsigned __int16)word_99EDC6;
    dword_482A8C = sub_31BAC();
LABEL_22:
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      snprintf(s, 0x800u, "fixed working voltage = %d\n", dword_482A8C);
      sub_2E584(3, s, 0);
    }
    goto LABEL_24;
  }
  v14 = sub_31BAC();
  if ( v14 > 0 )
  {
    dword_482A8C = v14;
    goto LABEL_22;
  }
  if ( (_BYTE)v14 )
    return 0;
LABEL_24:
  if ( (unsigned __int8)sub_33E34() )
    return 0;
  if ( byte_482A71 && (byte_99EDBC & 8) != 0 )
  {
    v42 = 0;
    v43 = 0;
    dword_482A6C = (unsigned __int16)word_99EDC4;
    do
    {
      if ( sub_1E29C(v43) && !sub_183FC(v43, (unsigned __int8)dword_80FB4, (int *)&v53) )
      {
        if ( v42 )
        {
          if ( v42 >= v53 )
            v42 = v53;
        }
        else
        {
          v42 = v53;
        }
      }
      ++v43;
    }
    while ( v43 != 4 );
    v15 = dword_7EB9C;
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      snprintf(s, 0x800u, "min freq in eeprom = %d\n", v42);
      sub_2E584(3, s, 0);
      v15 = dword_7EB9C;
    }
    if ( v42 && v42 > 0 )
    {
      dword_482A6C = v42;
    }
    else
    {
      if ( v15 > 3 )
      {
        strcpy(s, "failed to load freq in eeprom, using default");
        sub_2E584(3, s, 0);
      }
      v15 = dword_7EB9C;
      dword_482A6C = 200;
    }
  }
  else
  {
    v15 = dword_7EB9C;
    dword_482A6C = 200;
  }
  if ( v15 > 3 )
  {
    snprintf(s, 0x800u, "fixed frequency is %d\n", dword_482A6C);
    sub_2E584(3, s, 0);
  }
  v16 = dword_80FB4;
  if ( dword_80FB4 == 3 )
  {
    v28 = dword_482A8C;
    v29 = (const char *)sub_1E0C0();
    if ( !strcmp(v29, "NBS1902")
      || (v44 = (const char *)sub_1E0C0(), !strcmp(v44, "NBS1902L"))
      || (v45 = (const char *)sub_1E0C0(), !strcmp(v45, "NBT1903")) )
    {
      v30 = (float)dword_482A8C * 0.91;
      if ( v30 < 1200.0 )
        v31 = 1200;
      else
        v31 = (int)v30;
      v32 = (v28 - v31) >> 31;
      v33 = 1717986919LL * (v28 - v31);
      dword_482A8C = v31;
      v16 = dword_80FB4;
      dword_482A6C = (unsigned int)((double)(unsigned int)dword_482A6C - (double)((SHIDWORD(v33) >> 2) - v32) * 12.5);
    }
    else
    {
      v46 = (const char *)sub_1E0C0();
      if ( !strcmp(v46, "NBP1901") || (v52 = (const char *)sub_1E0C0(), !strcmp(v52, "NBP1901L")) )
      {
        v47 = (float)dword_482A8C * 0.91;
        if ( v47 >= 1200.0 )
          v48 = (int)v47;
        else
          v48 = 1200;
        dword_482A8C = v48;
        v16 = dword_80FB4;
        dword_482A6C -= 10 * ((v28 - v48) / 10);
      }
      else
      {
        v16 = dword_80FB4;
      }
    }
  }
  if ( v16 == 1 || dword_482A8C <= 0 )
  {
    sub_194DC();
    sub_13FB0(0);
    sub_304D4();
  }
  else
  {
    v20 = sub_1E160();
    if ( (unsigned __int8)sub_15210(v20) )
    {
      sub_20A38(1);
      sub_31D58(0xEu, "Can't get temperature sensor type!");
    }
    else
    {
      sub_20A38(0);
    }
  }
  v17 = sub_1572C();
  dword_99EDD8 = v17;
  if ( (unsigned int)dword_7EB9C > 3 )
  {
    snprintf(s, 0x800u, "Bring up temperature is %d\n", v17);
    sub_2E584(3, s, 0);
    if ( !byte_80FB0 )
      goto LABEL_36;
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      strcpy(s, "press any key to start rising frequency...");
      sub_2E584(3, s, 0);
    }
  }
  else if ( !byte_80FB0 )
  {
    goto LABEL_36;
  }
  IO_getc((_IO_FILE *)stdin);
LABEL_36:
  pthread_mutex_lock(&stru_7F7EC);
  sub_28138(12000000);
  pthread_mutex_unlock(&stru_7F7EC);
  if ( byte_7EB79 )
  {
    if ( dword_482A8C > 0 && sub_19AB4() != dword_482A8C )
    {
      v39 = sub_1572C();
      if ( v39 <= 19 )
        v40 = byte_7EB78 & 1;
      else
        v40 = 0;
      if ( v40 )
      {
        v49 = 100;
        v50 = 100 * (20 - v39);
        if ( v50 < 4000 )
          v49 = v50 / 0x28u;
        v51 = v49 + dword_482A8C;
        if ( v51 > sub_19AC4() )
          v41 = sub_19AC4();
        else
          v41 = v49 + dword_482A8C;
      }
      else
      {
        v41 = dword_482A8C;
      }
      sub_195A8(v41);
      sub_304D4();
    }
  }
  else
  {
    sub_3403C();
  }
  sub_304D4();
  if ( sub_1E100() == 2 )
  {
    for ( i = 0; i != 4; ++i )
    {
      v35 = i;
      v36 = (unsigned __int8)i;
      if ( sub_1E29C(v35) )
      {
        v37 = sub_1E160();
        sub_50A80(v36, 19 * v37, 0);
        v38 = sub_1E160();
        sub_50A80(v36, 55 * v38, 0);
      }
    }
  }
  sub_31D58(1u, "soc init done!");
  v18 = sub_27C88();
  v19 = v18;
  if ( v18 )
    return 0;
  do
  {
    if ( sub_1E29C(v19) )
    {
      v21 = 0;
      v22 = 0;
      for ( j = (_QWORD *)((char *)&qword_99CD98 + 2048 * v19); ; ++j )
      {
        v24 = v22 + v21;
        if ( v22 >= sub_1E67C(v19) )
          break;
        v25 = sub_1E100();
        sub_5FADC(v22, v25);
        if ( !v26 )
        {
          ++v21;
          v27 = v24;
          v24 = v22 + v21;
          sub_1E820(v19, v27, 32);
        }
        ++v22;
        sub_1E820(v19, v24, 111);
        *j = 0LL;
      }
      sub_1E820(v19, v22 + v21, 111);
    }
    ++v19;
  }
  while ( v19 != 4 );
  if ( (unsigned __int8)sub_27B70() )
    return 0;
  if ( byte_80FA4 )
    sub_27DA0();
  sub_2BDC4();
  sub_3208C();
  sub_304D4();
  if ( (unsigned int)dword_7EB9C > 3 )
  {
    strcpy(s, "Init done!\n");
    sub_2E584(3, s, 0);
  }
  return 1;
}
// 34D54: variable 'v26' is possibly undefined
// 7EB78: using guessed type char byte_7EB78;
// 7EB79: using guessed type char byte_7EB79;
// 7EB9C: using guessed type int dword_7EB9C;
// 7EDC8: using guessed type int dword_7EDC8;
// 7F798: using guessed type int stdin;
// 7F7EC: using guessed type pthread_mutex_t stru_7F7EC;
// 80FA4: using guessed type char byte_80FA4;
// 80FB0: using guessed type char byte_80FB0;
// 80FB4: using guessed type int dword_80FB4;
// 482A6C: using guessed type int dword_482A6C;
// 482A71: using guessed type char byte_482A71;
// 482A8C: using guessed type int dword_482A8C;
// 99EDB8: using guessed type char byte_99EDB8;
// 99EDBC: using guessed type char byte_99EDBC;
// 99EDC2: using guessed type char byte_99EDC2;
// 99EDC4: using guessed type __int16 word_99EDC4;
// 99EDC6: using guessed type __int16 word_99EDC6;
// 99EDD6: using guessed type __int16 word_99EDD6;
// 99EDD8: using guessed type int dword_99EDD8;

//----- (000350E8) --------------------------------------------------------
int sub_350E8()
{
  unsigned __int16 v0; // r0
  int v1; // r5
  int v2; // r7
  int v3; // r0
  int v4; // r8
  int v5; // r2
  int v6; // r7
  int i; // r0
  int v8; // r3
  int v9; // r10
  bool v10; // cc
  int v12; // r7
  const char *v13; // r0
  int v14; // r12
  char s[2080]; // [sp+10h] [bp-820h] BYREF

  v0 = sub_1572C();
  v1 = (__int16)(v0 - 10);
  v2 = v1;
  if ( word_7EDE4 == 255 )
  {
    word_7EDE4 = v1;
LABEL_25:
    word_482A90 = 0;
    goto LABEL_5;
  }
  if ( word_7EDE4 - v1 <= 5 )
    goto LABEL_25;
  ++word_482A90;
LABEL_5:
  if ( dword_482A8C > 0 && dword_80FB4 != 1 )
  {
    if ( v1 <= 19 || word_482A90 > 1 && (unsigned int)v0 - 21 <= 8 )
    {
      v3 = sub_19AB4();
      v4 = 100;
      v5 = 100 * (20 - v1);
      v6 = v3;
      if ( v5 < 4000 )
        v4 = v5 / 40;
      if ( (unsigned int)dword_7EB9C > 4 )
      {
        v14 = v3 - dword_482A8C + v4;
        if ( v14 < 0 )
          v14 = -v14;
        snprintf(
          s,
          0x800u,
          "curr_vol = %d, g_voltage = %d,compensate_voltage = %d, abs = %d",
          v3,
          dword_482A8C,
          v4,
          v14);
        sub_2E584(4, s, 0);
      }
      i = v4 + dword_482A8C;
      v8 = v6 - (v4 + dword_482A8C);
      if ( v8 < 0 )
        v8 = i - v6;
      if ( v8 <= 19 )
        goto LABEL_23;
      v9 = v6 + 49;
      if ( v6 + 49 < i )
      {
        while ( 1 )
        {
          v10 = sub_19AC4() <= v9;
          v9 += 20;
          if ( v10 )
            break;
          v6 += 20;
          sub_195A8(v6);
          usleep(0x30D40u);
          i = v4 + dword_482A8C;
          if ( v4 + dword_482A8C <= v9 )
            goto LABEL_22;
        }
        i = v4 + dword_482A8C;
      }
LABEL_22:
      if ( v6 == i )
        goto LABEL_23;
LABEL_30:
      sub_195A8(i);
      word_7EDE4 = v1;
      return 0;
    }
    if ( (unsigned int)v0 - 30 > 0x15 )
    {
      v13 = (const char *)sub_1E0C0();
      if ( strcmp(v13, "NBS1902L") )
        v2 = v1 + 10;
      if ( v2 > 49 && dword_482A8C - 20 != sub_19AB4() )
      {
        i = dword_482A8C - 20;
        goto LABEL_30;
      }
    }
    else
    {
      v12 = sub_19AB4();
      for ( i = dword_482A8C; dword_482A8C < v12 - 19; i = dword_482A8C )
      {
        v12 -= 20;
        sub_195A8(v12);
        usleep(0x30D40u);
      }
      if ( i != v12 )
        goto LABEL_30;
    }
LABEL_23:
    word_7EDE4 = v1;
  }
  return 0;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 7EDE4: using guessed type __int16 word_7EDE4;
// 80FB4: using guessed type int dword_80FB4;
// 482A8C: using guessed type int dword_482A8C;
// 482A90: using guessed type __int16 word_482A90;

//----- (00035344) --------------------------------------------------------
int sub_35344()
{
  int v0; // r7
  int v1; // r5
  int v2; // r6
  int result; // r0
  int v4; // r2
  int v5; // r2
  int v6; // r3
  int v7; // r8
  bool v8; // cc
  int v9; // r0
  unsigned __int8 v10; // r4
  int v11; // r4
  int v12; // r0
  unsigned __int8 v13; // r4
  int v14; // r0
  char s[2080]; // [sp+18h] [bp-820h] BYREF

  if ( (byte_99EDBC & 2) != 0 && (unsigned __int8)byte_99EDC2 <= 0x64u )
  {
    result = sub_13FB0((unsigned __int8)byte_99EDC2);
    if ( !dword_482A94 )
    {
      if ( (unsigned int)dword_7EB9C > 3 )
      {
        snprintf(s, 0x800u, "fan_etf: Set fixed fan speed=%d\n", (unsigned __int8)byte_99EDC2);
        result = sub_2E584(3, s, 0);
      }
      dword_482A94 = 1;
    }
    return result;
  }
  v0 = sub_1572C();
  v1 = sub_15508();
  v2 = sub_155C4();
  result = v1 - sub_1572C();
  if ( dword_7EDE8 == 255 )
  {
    v5 = dword_482A98;
LABEL_25:
    dword_482A9C = v5 > 1;
    dword_482A98 = (v5 - 1) & ~((v5 - 1) >> 31);
    goto LABEL_10;
  }
  v4 = dword_7EDE8 - v0;
  if ( dword_7EDE8 - v0 < 0 )
    v4 = v0 - dword_7EDE8;
  v8 = v4 <= 4;
  v5 = dword_482A98;
  if ( v8 )
    goto LABEL_25;
  v6 = dword_482A98 + 1;
  if ( dword_482A98 + 1 >= 2 )
    v6 = 2;
  dword_482A98 = v6;
  dword_482A9C = v5 > 0;
LABEL_10:
  dword_7EDE8 = v0;
  if ( v1 > 72 )
    goto LABEL_14;
  v7 = abs32(result);
  v8 = v7 <= 32;
  if ( v7 <= 32 )
    v8 = v0 <= 50;
  if ( !v8 || dword_482A9C )
  {
LABEL_14:
    if ( !dword_482A94 )
    {
      if ( (unsigned int)dword_7EB9C > 4 )
      {
        snprintf(
          s,
          0x800u,
          "min pic temp = %d max pic temp = %d pic diff = %d, max chip temp = %d, last diff continuous_time = %d",
          v0,
          v1,
          result,
          v2,
          dword_482A98);
        sub_2E584(4, s, 0);
      }
      dword_482A94 = 1;
    }
    return sub_13FB0(100);
  }
  else
  {
    dword_482A94 = 0;
    if ( v7 > 27 )
    {
      v10 = (unsigned int)(float)((float)((float)((float)v7 - 25.0) / 25.0) * 10.0);
      if ( v10 + sub_1E4B0() <= 99 )
        v11 = (unsigned __int8)(v10 + sub_1E4B0());
      else
        v11 = 100;
      if ( (unsigned int)dword_7EB9C > 4 )
      {
        v12 = sub_1E4B0();
        snprintf(s, 0x800u, "max temp = %04d, diff = %04d, + pwm form %04d to %04d\n", v1, v7, v12, v11);
        sub_2E584(4, s, 0);
      }
      return sub_13FB0(v11);
    }
    if ( v7 > 22 )
    {
      if ( (unsigned int)dword_7EB9C > 4 )
      {
        v9 = sub_1E4B0();
        snprintf(s, 0x800u, "max temp = %04d, diff = %04d, = pwm %04d\n", v1, v7, v9);
        return sub_2E584(4, s, 0);
      }
      return result;
    }
    v13 = (unsigned int)(float)((float)((float)(25.0 - (float)v7) / 25.0) * 10.0);
    result = sub_1E4B0() - v13;
    if ( result > 39 )
    {
      result = sub_1E4B0();
      v11 = (unsigned __int8)(result - v13);
    }
    else
    {
      v11 = 40;
    }
    if ( (unsigned int)dword_7EB9C > 4 )
    {
      v14 = sub_1E4B0();
      snprintf(s, 0x800u, "max temp = %04d, diff = %04d, - pwm form %04d to %04d\n", v1, v7, v14, v11);
      result = sub_2E584(4, s, 0);
    }
    if ( v1 <= 67 )
      return sub_13FB0(v11);
  }
  return result;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 7EDE8: using guessed type int dword_7EDE8;
// 482A94: using guessed type int dword_482A94;
// 482A98: using guessed type int dword_482A98;
// 482A9C: using guessed type int dword_482A9C;
// 99EDBC: using guessed type char byte_99EDBC;
// 99EDC2: using guessed type char byte_99EDC2;

//----- (000356C4) --------------------------------------------------------
int __fastcall sub_356C4(int a1, int a2)
{
  int result; // r0
  char v3[2056]; // [sp+0h] [bp-808h] BYREF

  switch ( a1 )
  {
    case 0:
      snprintf((char *)dword_4FCAE8, 0x40u, "J%d:1", a2);
      break;
    case 1:
      snprintf((char *)dword_4FCAE8, 0x40u, "J%d:2", a2);
      break;
    case 2:
      snprintf((char *)dword_4FCAE8, 0x40u, "J%d:8", a2);
      break;
    case 3:
      snprintf((char *)dword_4FCAE8, 0x40u, "J%d:4", a2);
      break;
    case 4:
      snprintf((char *)dword_4FCAE8, 0x40u, "J%d:5", a2);
      break;
    case 5:
      dword_4FCAE8[0] = (int)&unk_313A52;
      break;
    case 6:
      dword_4FCAE8[0] = (int)&unk_323A52;
      break;
    case 7:
      snprintf((char *)dword_4FCAE8, 0x40u, "T:%d", a2);
      break;
    case 8:
      dword_4FCAE8[0] = (int)&unk_313A50;
      break;
    case 9:
      dword_4FCAE8[0] = (int)&unk_323A50;
      break;
    case 10:
      dword_4FCAE8[0] = (int)&unk_313A46;
      break;
    case 11:
      snprintf((char *)dword_4FCAE8, 0x40u, "J%d:6", a2);
      break;
    case 12:
      dword_4FCAE8[0] = (int)&unk_313A56;
      break;
    case 13:
      dword_4FCAE8[0] = (int)&unk_313A4D;
      break;
    case 14:
      dword_4FCAE8[0] = (int)&unk_313A4E;
      break;
    case 15:
      dword_4FCAE8[0] = (int)&unk_343A50;
      break;
    case 17:
      dword_4FCAE8[0] = (int)&unk_333A52;
      break;
    case 18:
      dword_4FCAE8[0] = (int)&unk_313A43;
      break;
    case 19:
      dword_4FCAE8[0] = (int)&unk_323A4E;
      break;
    case 20:
      dword_4FCAE8[0] = (int)&unk_303A53;
      break;
    case 21:
      dword_4FCAE8[0] = (int)&unk_333A4E;
      break;
    case 22:
      dword_4FCAE8[0] = (int)&unk_353A50;
      break;
    default:
      strcpy((char *)dword_4FCAE8, "unknown");
      break;
  }
  result = sub_36558(1);
  if ( (unsigned int)dword_7EB9C > 3 )
  {
    snprintf(v3, 0x800u, "Sweep error string = %s.\n", (const char *)dword_4FCAE8);
    return sub_2E584(3, v3, 0);
  }
  return result;
}
// 356D8: control flows out of bounds to 356DC
// 7EB9C: using guessed type int dword_7EB9C;
// 4FCAE8: using guessed type int dword_4FCAE8[16];

//----- (000359EC) --------------------------------------------------------
int *sub_359EC()
{
  return dword_4FCAE8;
}
// 4FCAE8: using guessed type int dword_4FCAE8[16];

//----- (000359F8) --------------------------------------------------------
int __fastcall sub_359F8(int a1)
{
  return 3000 * ((a1 - 2000) / 3000) + 2000;
}

//----- (00035A28) --------------------------------------------------------
void __noreturn sub_35A28()
{
  int v0; // r0
  unsigned int v1; // r0
  int v2; // r8
  int v3; // r4
  _QWORD v4[259]; // [sp+0h] [bp-818h] BYREF

  if ( (unsigned int)dword_7EB9C > 4 )
  {
    strcpy((char *)v4, "[DEBUG] Recv nonce and register.\n");
    sub_2E584(4, (const char *)v4, 0);
  }
  v0 = sub_452B0();
  sub_452D0(v0 | 0x10000);
  sub_2BDD0();
  while ( 1 )
  {
    v1 = sub_44D3C();
    v2 = (unsigned __int8)(v1 >> 1);
    if ( (unsigned __int8)(v1 >> 1) )
      break;
LABEL_12:
    usleep(0x3E8u);
  }
  v3 = 0;
  while ( 1 )
  {
    sub_44D94(v4);
    if ( (v4[0] & 0x80000000LL) != 0 )
      break;
    if ( (unsigned int)dword_5945C0 <= 0x1FE && dword_5945B8[0] <= 0x1FEu )
    {
      sub_39128((int)v4);
LABEL_7:
      if ( v2 == ++v3 )
        goto LABEL_12;
    }
    else
    {
      ++v3;
      sub_2BDD0();
      if ( v2 == v3 )
        goto LABEL_12;
    }
  }
  sub_39018();
  goto LABEL_7;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 5945B8: using guessed type int dword_5945B8[];
// 5945C0: using guessed type int dword_5945C0;

//----- (00035B1C) --------------------------------------------------------
int sub_35B1C()
{
  int v0; // r8
  int i; // r5
  int v2; // r4
  int v3; // r2
  float v4; // s12
  float v5; // s14
  char s[2080]; // [sp+10h] [bp-820h] BYREF

  v0 = 0;
  for ( i = 0; i != 4; ++i )
  {
    v2 = 4 * (i + 1032);
    if ( sub_1E29C(i) )
    {
      v3 = dword_4FCB28;
      v4 = *(float *)(dword_4FCB28 + v2);
      v5 = *(float *)(*(_DWORD *)(dword_4FCB28 + 8) + 20);
      if ( (unsigned int)dword_7EB9C > 3 )
      {
        snprintf(s, 0x800u, "chain = %d, nonce_rate_max = %.4f, nonce_rate_threshold = %.4f\n", i, v4, v5);
        sub_2E584(3, s, 0);
        v3 = dword_4FCB28;
        v4 = *(float *)(dword_4FCB28 + v2);
        v5 = *(float *)(*(_DWORD *)(dword_4FCB28 + 8) + 20);
      }
      if ( v4 < v5 )
      {
        v0 = 1;
        *(_DWORD *)(v3 + 4 * (i + 1040)) = 1;
      }
    }
  }
  return v0;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 4FCB28: using guessed type int dword_4FCB28;

//----- (00035C04) --------------------------------------------------------
unsigned int __fastcall sub_35C04(int a1)
{
  unsigned int v1; // r6
  int v2; // r10
  int i; // r4
  int v5; // r9
  int v6; // r7
  int j; // r5
  int v8; // t1

  v1 = 0;
  v2 = a1 - 4;
  for ( i = 0; i != 4; ++i )
  {
    if ( sub_1E29C(i) )
    {
      v5 = sub_1E0F0();
      if ( v5 )
      {
        v6 = v2 + (i << 10);
        for ( j = 0; j != v5; ++j )
        {
          v8 = *(_DWORD *)(v6 + 4);
          v6 += 4;
          v1 += v8 * sub_1E130();
        }
      }
    }
  }
  return v1 / 0x3E8;
}

//----- (00035C74) --------------------------------------------------------
void sub_35C74()
{
  char v0[2056]; // [sp+0h] [bp-808h] BYREF

  if ( (unsigned int)dword_7EB9C > 4 )
  {
    strcpy(v0, "[DEBUG] Sweep exit.\n");
    sub_2E584(4, v0, 0);
    if ( (unsigned int)dword_7EB9C > 4 )
    {
      strcpy(v0, "[DEBUG] Free memory for sweep.\n");
      sub_2E584(4, v0, 0);
    }
  }
  if ( dword_4FCB28 )
  {
    free((void *)dword_4FCB28);
    dword_4FCB28 = 0;
  }
}
// 7EB9C: using guessed type int dword_7EB9C;
// 4FCB28: using guessed type int dword_4FCB28;

//----- (00035D24) --------------------------------------------------------
int __fastcall sub_35D24(int **a1, int a2, int a3)
{
  int v5; // r8
  int result; // r0
  int *v7; // r3
  int v8; // r12
  int v9; // r2
  int v10; // r3
  unsigned int v11; // r9
  int i; // r5
  int v13; // r0
  int v14; // r0
  int v15; // r3
  unsigned int v16; // r2
  unsigned int v17; // t1
  unsigned int v18; // r5
  int j; // r10
  int v20; // r0
  int v21; // r0
  int v22; // r3
  unsigned int v23; // r2
  unsigned int v24; // t1
  int v25; // r10
  char *v26; // r9
  int v27; // r5
  char *v28; // r10
  int v29; // r5
  int v31; // r0
  int v32; // lr
  int v33; // r1
  char *v34; // r12
  int v35; // r3
  int v36; // t1
  int v37; // t1
  bool v38; // cc
  int v39; // [sp+Ch] [bp-834h]
  unsigned int v40; // [sp+14h] [bp-82Ch] BYREF
  char s[2088]; // [sp+18h] [bp-828h] BYREF

  if ( (unsigned int)dword_7EB9C > 3 )
  {
    strcpy(s, "\n");
    sub_2EA54(3, s, 0);
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      snprintf(s, 0x800u, ">>>> Get ideal hash rate, round %d.\n", a3);
      sub_2E584(3, s, 0);
    }
  }
  v5 = sub_39FB4(a2);
  if ( v5 )
  {
    if ( (unsigned int)dword_7EB9C <= 3 )
      return v5;
    strcpy(s, "Board init failed.\n");
    sub_2E584(3, s, 0);
    return v5;
  }
  else
  {
    sub_39A7C();
    v7 = *a1;
    v8 = **a1;
    v9 = (*a1)[4];
    if ( v8 > v9 )
      *v7 = v9;
    if ( v8 > v9 )
      v7 = *a1;
    if ( v8 > v9 )
      v8 = *v7;
    v10 = *(_DWORD *)(dword_4FCB28 + 8);
    dword_4FCB2C = v8;
    sub_1AD08(dword_4FCB28 + 12, (unsigned __int8)byte_482A70, *(unsigned __int8 *)(v10 + 8));
    if ( sub_19AB4() == dword_4FCB2C || (result = sub_195A8(dword_4FCB2C)) == 0 )
    {
      v11 = 0xFFFFFF;
      for ( i = 0; i != 4; ++i )
      {
        if ( sub_1E29C(i) )
        {
          v13 = sub_1E0F0();
          if ( v13 )
          {
            v14 = dword_4FCB28 + 8 + 4 * (v13 + (i << 8));
            v15 = dword_4FCB28 + (i << 10) + 8;
            do
            {
              v17 = *(_DWORD *)(v15 + 4);
              v15 += 4;
              v16 = v17;
              if ( v11 >= v17 )
                v11 = v16;
            }
            while ( v15 != v14 );
          }
        }
      }
      if ( (unsigned int)dword_7EB9C > 3 )
      {
        snprintf(s, 0x800u, "chain = %d, freq_min = %d\n", 255, v11);
        sub_2E584(3, s, 0);
      }
      v18 = 0;
      for ( j = 0; j != 4; ++j )
      {
        if ( sub_1E29C(j) )
        {
          v20 = sub_1E0F0();
          if ( v20 )
          {
            v21 = dword_4FCB28 + 8 + 4 * (v20 + (j << 8));
            v22 = dword_4FCB28 + (j << 10) + 8;
            do
            {
              v24 = *(_DWORD *)(v22 + 4);
              v22 += 4;
              v23 = v24;
              if ( v18 < v24 )
                v18 = v23;
            }
            while ( v22 != v21 );
          }
        }
      }
      if ( (unsigned int)dword_7EB9C > 3 )
      {
        snprintf(s, 0x800u, "chain = %d, freq_max = %d\n", 255, v18);
        sub_2E584(3, s, 0);
      }
      v25 = 0;
      v40 = v18;
      sub_321B8(v11, dword_7EB58, 20);
      do
      {
        if ( sub_1E29C(v25) )
          sub_3962C(v25, 1);
        ++v25;
      }
      while ( v25 != 4 );
      v26 = 0;
      sub_3A86C((int)&v40);
      v27 = sub_391F4();
      do
      {
        if ( sub_1E29C((int)v26) )
          sub_3A054(v26, v27);
        ++v26;
      }
      while ( v26 != (char *)4 );
      v28 = (char *)&unk_808FFC + v27;
      v29 = 0;
      v39 = 0;
      do
      {
        if ( sub_1E29C(v29) )
        {
          v31 = sub_1E0F0();
          if ( v31 )
          {
            v32 = dword_4FCB28 + 8 + 4 * (v31 + (v29 << 8));
            v31 = 0;
            v33 = dword_4FCB28 + (v29 << 10) + 8;
            v34 = &v28[1024 * v29];
            do
            {
              v36 = *(_DWORD *)(v33 + 4);
              v33 += 4;
              v35 = v36;
              v37 = *((_DWORD *)v34 + 1);
              v34 += 4;
              v31 += v37 * v35 / 0x1F40u;
            }
            while ( v32 != v33 );
            v39 += v31;
          }
          v38 = (unsigned int)dword_7EB9C > 3;
          *(_DWORD *)(dword_4FCB28 + 4 * (v29 + 1026) + 4) = v31;
          if ( v38 )
          {
            snprintf(s, 0x800u, "chain = %d, ideal_hash_rate_GH = %d\n", v29, v31);
            sub_2E584(3, s, 0);
          }
        }
        ++v29;
      }
      while ( v29 != 4 );
      if ( (unsigned int)dword_7EB9C > 3 )
      {
        snprintf(s, 0x800u, "hash_rate_total_GH = %d\n", v39);
        sub_2E584(3, s, 0);
      }
      return v5;
    }
  }
  return result;
}
// 7EB58: using guessed type int dword_7EB58;
// 7EB9C: using guessed type int dword_7EB9C;
// 482A70: using guessed type char byte_482A70;
// 4FCB28: using guessed type int dword_4FCB28;
// 4FCB2C: using guessed type int dword_4FCB2C;

//----- (00036174) --------------------------------------------------------
_DWORD *__fastcall sub_36174(_DWORD *a1)
{
  char v3[2056]; // [sp+0h] [bp-808h] BYREF

  sub_356C4(15, 255);
  if ( (unsigned int)dword_7EB9C > 3 )
  {
    snprintf(v3, 0x800u, "Unknown miner type(%d).\n", 2);
    sub_2E584(3, v3, 0);
  }
  *a1 = 3000;
  a1[1] = 2000;
  a1[2] = 219640;
  return a1;
}
// 7EB9C: using guessed type int dword_7EB9C;

//----- (000361E4) --------------------------------------------------------
int __fastcall sub_361E4(int result)
{
  dword_4FCB2C = result;
  return result;
}
// 4FCB2C: using guessed type int dword_4FCB2C;

//----- (000361F4) --------------------------------------------------------
int sub_361F4()
{
  return dword_4FCB2C;
}
// 4FCB2C: using guessed type int dword_4FCB2C;

//----- (00036208) --------------------------------------------------------
int sub_36208()
{
  return sub_195A8(dword_4FCB2C);
}
// 4FCB2C: using guessed type int dword_4FCB2C;

//----- (00036218) --------------------------------------------------------
int sub_36218()
{
  FILE *v0; // r4
  int result; // r0
  char v2[2056]; // [sp+0h] [bp-808h] BYREF

  v0 = (FILE *)fopen64("/config/scanfreqdone", "r");
  if ( (unsigned int)dword_7EB9C > 4 )
  {
    strcpy(v2, "[DEBUG] Check if sweep is already done.\n");
    sub_2E584(4, v2, 0);
  }
  result = (int)v0;
  if ( v0 )
  {
    fclose(v0);
    return 1;
  }
  return result;
}
// 124E4: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 7EB9C: using guessed type int dword_7EB9C;

//----- (000362A0) --------------------------------------------------------
int __fastcall sub_362A0(int a1)
{
  int result; // r0
  unsigned int v3; // r8
  _DWORD *v4; // r8
  int v5; // r7
  char *v6; // lr
  char *v7; // r12
  int v8; // r0
  int v9; // r1
  int v10; // r2
  int v11; // r3
  _DWORD *v12; // lr
  char *v13; // r12
  int v14; // r1
  int v15; // r2
  int v16; // r0
  int v17; // r2
  int v18; // r3
  __time_t v19[2]; // [sp+0h] [bp-820h] BYREF
  char s[2072]; // [sp+8h] [bp-818h] BYREF

  if ( !sub_36218() )
  {
    sub_302A0(v19);
    v3 = a1 - 160;
    dword_4FCB30 = 2;
    if ( (unsigned int)dword_7EB9C > 4 )
    {
      snprintf(s, 0x800u, "[DEBUG] Sweep init, sweep_type = 0x%X.\n", a1);
      sub_2E584(4, s, 0);
      if ( v3 > 1 )
        goto LABEL_7;
      if ( (unsigned int)dword_7EB9C > 4 )
      {
        strcpy(s, "[DEBUG] Allocate memory for sweep.\n");
        sub_2E584(4, s, 0);
      }
    }
    else if ( v3 > 1 )
    {
LABEL_7:
      sub_356C4(20, 255);
      if ( (unsigned int)dword_7EB9C <= 3 )
        goto LABEL_8;
      v6 = "Sweep type error, exit.\n";
      v7 = s;
      goto LABEL_19;
    }
    v4 = (_DWORD *)dword_4FCB28;
    if ( dword_4FCB28 || (v4 = calloc(0x107Cu, 1u), (dword_4FCB28 = (int)v4) != 0) )
    {
      *v4 = a1;
      v5 = 0;
      v4[1] = 1199570688;
      do
      {
        if ( sub_1E29C(v5) )
        {
          v16 = sub_1E0F0();
          if ( v16 > 0 )
          {
            v17 = dword_4FCB28 + 8 + 4 * (v16 + (v5 << 8));
            v18 = dword_4FCB28 + (v5 << 10) + 8;
            do
            {
              *(_DWORD *)(v18 + 4) = 300;
              v18 += 4;
            }
            while ( v18 != v17 );
          }
        }
        ++v5;
      }
      while ( v5 != 4 );
      sub_356C4(15, 255);
      if ( (unsigned int)dword_7EB9C > 3 )
      {
        snprintf(s, 0x800u, "Unknown miner type(%d).\n", 2);
        sub_2E584(3, s, 0);
      }
      goto LABEL_8;
    }
    sub_356C4(13, 255);
    if ( (unsigned int)dword_7EB9C <= 3 )
    {
LABEL_8:
      result = -1;
      dword_4FCB30 = 1;
      return result;
    }
    v6 = " memory for sweep ctxt.\n";
    qmemcpy(s, "Fail to allocate", 16);
    v7 = &s[16];
LABEL_19:
    v8 = *(_DWORD *)v6;
    v9 = *((_DWORD *)v6 + 1);
    v10 = *((_DWORD *)v6 + 2);
    v11 = *((_DWORD *)v6 + 3);
    v12 = v6 + 16;
    *(_DWORD *)v7 = v8;
    *((_DWORD *)v7 + 1) = v9;
    *((_DWORD *)v7 + 2) = v10;
    *((_DWORD *)v7 + 3) = v11;
    v13 = v7 + 16;
    v14 = v12[1];
    v15 = v12[2];
    *(_DWORD *)v13 = *v12;
    *((_DWORD *)v13 + 1) = v14;
    v13[8] = v15;
    sub_2E584(3, s, 0);
    goto LABEL_8;
  }
  if ( (unsigned int)dword_7EB9C > 3 )
  {
    strcpy(s, "Sweep already done, exit.\n");
    sub_2E584(3, s, 0);
  }
  return 0;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 4FCB28: using guessed type int dword_4FCB28;
// 4FCB30: using guessed type int dword_4FCB30;
// 362A0: using guessed type __time_t anonymous_0[2];

//----- (00036538) --------------------------------------------------------
int __fastcall sub_36538(_DWORD *a1)
{
  *a1 = 1000;
  return 0;
}

//----- (00036548) --------------------------------------------------------
int sub_36548()
{
  return dword_4FCB30;
}
// 4FCB30: using guessed type int dword_4FCB30;

//----- (00036558) --------------------------------------------------------
int __fastcall sub_36558(int result)
{
  dword_4FCB30 = result;
  return result;
}
// 4FCB30: using guessed type int dword_4FCB30;

//----- (0003656C) --------------------------------------------------------
int sub_3656C()
{
  char v1[2056]; // [sp-808h] [bp-808h] BYREF

  if ( (unsigned int)dword_7EB9C > 4 )
  {
    strcpy(v1, "[DEBUG] Get stats.\n");
    sub_2E584(4, v1, 0);
  }
  return dword_4FCB34 + 8;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 4FCB34: using guessed type int dword_4FCB34;

//----- (000365E8) --------------------------------------------------------
bool __fastcall sub_365E8(int a1)
{
  unsigned int v2; // r5
  int v3; // r4
  char v5[2064]; // [sp+0h] [bp-810h] BYREF

  if ( (unsigned int)dword_7EB9C > 4 )
  {
    snprintf(v5, 0x800u, "[DEBUG] Check if is recv nonce enough, chain = %d.\n", a1);
    sub_2E584(4, v5, 0);
  }
  v2 = *(_DWORD *)(dword_4FCB34 + 4 * ((_DWORD)&unk_202802 + a1));
  v3 = 8 * sub_1E130();
  return v2 >= sub_1E0F0() * v3;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 4FCB34: using guessed type int dword_4FCB34;

//----- (00036680) --------------------------------------------------------
int __fastcall sub_36680(int a1)
{
  int v1; // r9
  int v2; // r7
  int v3; // r4
  char *v4; // r11
  unsigned int v5; // r10
  unsigned int v6; // s16
  int v8; // [sp+0h] [bp-850h]
  char s[2104]; // [sp+18h] [bp-838h] BYREF

  if ( (unsigned int)dword_7EB9C > 4 )
  {
    snprintf(s, 0x800u, "[DEBUG] Check if is unbalanche happen, chain = %d\n", a1);
    sub_2E584(4, s, 0);
  }
  v1 = sub_1E0F0();
  if ( v1 )
  {
    v3 = 0;
    v2 = 0;
    while ( 1 )
    {
      v4 = (char *)&unk_202402 + 256 * a1 + v3;
      v5 = *(_DWORD *)(dword_4FCB34 + 4 * (_DWORD)v4);
      if ( v5 > 8 * sub_1E130() )
      {
        v2 = 1;
        if ( (unsigned int)dword_7EB9C <= 3 )
          goto LABEL_7;
LABEL_11:
        v8 = v3++;
        snprintf(s, 0x800u, "Unbalance happened: chain = %d, asic = %d\n", a1, v8);
        v2 = 1;
        sub_2E584(3, s, 0);
        if ( v1 == v3 )
          return v2;
      }
      else
      {
        v6 = *(_DWORD *)(dword_4FCB34 + 4 * (_DWORD)v4);
        if ( (double)v6 < (double)(8 * sub_1E130()) * 0.75 )
        {
          v2 = 1;
          if ( (unsigned int)dword_7EB9C > 3 )
            goto LABEL_11;
        }
LABEL_7:
        if ( v1 == ++v3 )
          return v2;
      }
    }
  }
  return 0;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 4FCB34: using guessed type int dword_4FCB34;

//----- (000367E4) --------------------------------------------------------
int sub_367E4()
{
  int v0; // r4
  int v1; // r0
  char v3[2056]; // [sp+0h] [bp-808h] BYREF

  if ( (unsigned int)dword_7EB9C > 4 )
  {
    strcpy(v3, "[DEBUG] HW sweep reset.\n");
    sub_2E584(4, v3, 0);
  }
  v0 = 0;
  sub_1F1EC(255, 0);
  do
  {
    if ( sub_1E29C(v0) )
      sub_50E78((unsigned __int8)v0);
    ++v0;
  }
  while ( v0 != 4 );
  v1 = sub_4476C();
  return sub_44794(v1 & 0xFFFF70FF | 0x8400);
}
// 7EB9C: using guessed type int dword_7EB9C;

//----- (00036884) --------------------------------------------------------
void *sub_36884()
{
  char v1[2056]; // [sp+0h] [bp-808h] BYREF

  if ( (unsigned int)dword_7EB9C > 4 )
  {
    strcpy(v1, "[DEBUG] HW sweep clear stats.\n");
    sub_2E584(4, v1, 0);
  }
  return memset((void *)(dword_4FCB34 + 8), 0, (size_t)&unk_80A8A4);
}
// 7EB9C: using guessed type int dword_7EB9C;
// 4FCB34: using guessed type int dword_4FCB34;

//----- (00036908) --------------------------------------------------------
int sub_36908()
{
  int v0; // r4
  int result; // r0
  unsigned int s[518]; // [sp+28h] [bp-818h] BYREF

  if ( (unsigned int)dword_7EB9C > 4 )
  {
    strcpy((char *)s, "[DEBUG] Send 1-midstate work.\n");
    sub_2E584(4, (const char *)s, 0);
  }
  v0 = 0;
  memset(s, 0, 0x34u);
  LOBYTE(s[0]) = 1;
  do
  {
    result = sub_1E29C(v0);
    if ( result )
    {
      while ( (sub_44ED4() & (1 << v0)) == 0 )
        sub_304D4();
      BYTE1(s[0]) = v0 | 0x80;
      sub_1EDF0(s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7], s[8]);
      result = sub_304D4();
    }
    ++v0;
  }
  while ( v0 != 4 );
  return result;
}
// 7EB9C: using guessed type int dword_7EB9C;

//----- (00036A0C) --------------------------------------------------------
void sub_36A0C()
{
  void *v0; // r0
  char v1[2056]; // [sp+0h] [bp-808h] BYREF

  if ( (unsigned int)dword_7EB9C > 4 )
  {
    strcpy(v1, "[DEBUG] Free memory for hw sweep.\n");
    sub_2E584(4, v1, 0);
  }
  v0 = (void *)dword_4FCB34;
  if ( dword_4FCB34 )
  {
    if ( *(_DWORD *)(dword_4FCB34 + 4) )
    {
      free(*(void **)(dword_4FCB34 + 4));
      v0 = (void *)dword_4FCB34;
    }
    free(v0);
    dword_4FCB34 = 0;
  }
}
// 7EB9C: using guessed type int dword_7EB9C;
// 4FCB34: using guessed type int dword_4FCB34;

//----- (00036AA8) --------------------------------------------------------
void sub_36AA8()
{
  char v0[2056]; // [sp+0h] [bp-808h] BYREF

  if ( (unsigned int)dword_7EB9C > 4 )
  {
    strcpy(v0, "[DEBUG] HW sweep exit.\n");
    sub_2E584(4, v0, 0);
  }
  sub_36A0C();
}
// 7EB9C: using guessed type int dword_7EB9C;

//----- (00036B04) --------------------------------------------------------
int sub_36B04()
{
  _DWORD *v1; // r6
  void *v2; // r5
  char v3[2064]; // [sp+0h] [bp-810h] BYREF

  if ( (unsigned int)dword_7EB9C > 4 )
  {
    strcpy(v3, "[DEBUG] HW sweep init.\n");
    sub_2E584(4, v3, 0);
    if ( (unsigned int)dword_7EB9C > 4 )
    {
      strcpy(v3, "[DEBUG] Allocate memory for hw sweep.\n");
      sub_2E584(4, v3, 0);
    }
  }
  if ( dword_4FCB34 )
    return 0;
  v1 = calloc((size_t)&unk_8114AC, 1u);
  dword_4FCB34 = (int)v1;
  if ( !v1 )
  {
    sub_356C4(13, 255);
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      strcpy(v3, "Fail to allocate memory for hw sweep ctxt.\n");
      sub_2E584(3, v3, 0);
      return -1;
    }
    return -1;
  }
  v2 = malloc(0x400u);
  v1[1] = v2;
  if ( !v2 )
  {
    sub_36A0C();
    sub_356C4(13, 255);
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      strcpy(v3, "Fail to allocate memory for hw sweep private data.\n");
      sub_2E584(3, v3, 0);
    }
    return -1;
  }
  return 0;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 4FCB34: using guessed type int dword_4FCB34;

//----- (00036CA8) --------------------------------------------------------
int __fastcall sub_36CA8(int a1, int a2, unsigned int a3, int a4)
{
  int v4; // r9
  int v6; // r6
  int v7; // r5
  unsigned __int16 v10; // r11
  int v11; // r10
  int v12; // r0
  int v13; // r1
  int *v14; // r2
  int v15; // r3
  int v16; // r3
  int v17; // r3
  int v18; // r3
  int v19; // r9
  int result; // r0
  char s[2088]; // [sp+10h] [bp-828h] BYREF

  v4 = a1 << 8;
  v6 = HIWORD(a3);
  v7 = a4 + 4 * ((a1 << 8) + a2) + 0x800000;
  v10 = a3;
  v11 = *(_DWORD *)(dword_4FCB34 + 4);
  *(_DWORD *)(a4 + 4 * ((a1 << 8) + a2) + 8425472) += HIWORD(a3);
  v12 = sub_1E130();
  v15 = 4 * a1;
  if ( v6 <= 8 * v12 )
    v14 = (int *)(a4 + v15);
  v16 = a4 + v15;
  if ( v6 <= 8 * v12 )
    v14 += 0x200000;
  v17 = v16 + 0x800000;
  if ( v6 <= 8 * v12 )
    v14 += 10240;
  v18 = v17 + 40960;
  if ( v6 <= 8 * v12 )
    v13 = *v14;
  v19 = v11 + v4;
  if ( v6 <= 8 * v12 )
    *v14 = v13 + v6;
  *(_DWORD *)(v18 + 2144) += v10 - v6;
  *(_BYTE *)(v19 + a2) = 1;
  result = sub_1E130();
  if ( v6 > 8 * result && (unsigned int)dword_7EB9C > 3 )
  {
    snprintf(
      s,
      0x800u,
      "Nonce counter overflow: chain = %d, asic = %d, nonce_return = %d, nonce_match = %d, nonce_accumulate = %d\n",
      a1,
      a2,
      v10,
      v6,
      *(_DWORD *)(v7 + 36864));
    return sub_2E584(3, s, 0);
  }
  return result;
}
// 36D10: variable 'v14' is possibly undefined
// 36D2C: variable 'v13' is possibly undefined
// 7EB9C: using guessed type int dword_7EB9C;
// 4FCB34: using guessed type int dword_4FCB34;

//----- (00036DBC) --------------------------------------------------------
char *__fastcall sub_36DBC(int a1)
{
  int v2; // r6
  unsigned int v3; // r5
  int v4; // r0
  char *result; // r0
  int v6; // r7
  int v7; // r8
  unsigned int v8; // r6

  v2 = *(unsigned __int8 *)(a1 + 2);
  v3 = *(_BYTE *)a1 & 0xF;
  v4 = sub_1E160();
  if ( v3 > 3 )
    return sub_390B0((char *)a1);
  v6 = v4;
  v7 = *(unsigned __int8 *)(a1 + 1);
  if ( !sub_1E29C(v3) )
    return sub_390B0((char *)a1);
  v8 = sub_5FAF8(v2, v6);
  result = (char *)sub_1E0F0();
  if ( (unsigned int)result <= v8 )
    return sub_390B0((char *)a1);
  if ( v7 != 144 )
  {
    if ( v7 == 224 )
      return (char *)sub_36CA8(v3, v8, *(_DWORD *)(a1 + 4), dword_4FCB34 + 8);
    return sub_390B0((char *)a1);
  }
  if ( (*(_DWORD *)(a1 + 4) & 0x88) != 0 )
    *(_BYTE *)(*(_DWORD *)(dword_4FCB34 + 4) + (v3 << 8) + v8) = 1;
  return result;
}
// 4FCB34: using guessed type int dword_4FCB34;

//----- (00036E7C) --------------------------------------------------------
bool __fastcall sub_36E7C(int a1)
{
  int v2; // r4
  int v3; // r5
  unsigned __int8 *v4; // r0
  unsigned __int8 *v5; // r2
  char s[2064]; // [sp+8h] [bp-810h] BYREF

  v2 = *(_DWORD *)(dword_4FCB34 + 4);
  if ( (unsigned int)dword_7EB9C > 4 )
  {
    snprintf(s, 0x800u, "[DEBUG] Check if read reg done, chain = %d, done_threshold = %d.\n", a1, 1);
    sub_2E584(4, s, 0);
  }
  v3 = sub_1E0F0();
  if ( v3 )
  {
    v4 = (unsigned __int8 *)(v2 + (a1 << 8));
    v5 = &v4[v3];
    v3 = 0;
    do
    {
      if ( *v4++ )
        ++v3;
    }
    while ( v4 != v5 );
  }
  return sub_1E0F0() == v3;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 4FCB34: using guessed type int dword_4FCB34;

//----- (00036F2C) --------------------------------------------------------
bool sub_36F2C()
{
  int v0; // r4
  _BOOL4 result; // r0

  v0 = 0;
  while ( 1 )
  {
    if ( sub_1E29C(v0) )
    {
      result = sub_36E7C(v0);
      if ( !result )
        break;
    }
    if ( ++v0 == 4 )
      return 1;
  }
  return result;
}

//----- (00036F6C) --------------------------------------------------------
int __fastcall sub_36F6C(int a1, int *a2)
{
  int v3; // r0
  unsigned int v4; // r3
  int v5; // r1
  int v6; // r10
  int v7; // r6
  char *v8; // r8
  int v9; // r0
  int v10; // r4
  int v11; // r4
  int v12; // r0
  char v13; // r10
  int i; // r4
  int v15; // r4
  signed int v16; // r5
  int j; // r8
  __useconds_t v18; // r5
  int v19; // r6
  int k; // r4
  char *v21; // r7
  int v22; // r4
  int v23; // r9
  char *v24; // r11
  int m; // r4
  char *v27; // r4
  int v28; // r7
  char *v29; // r6
  int n; // r5
  int v31; // t1
  char v32; // r0
  char *v33; // r5
  char *v34; // r12
  int v35[34]; // [sp+0h] [bp-8C8h] BYREF
  unsigned int *v36; // [sp+88h] [bp-840h]
  char *s; // [sp+8Ch] [bp-83Ch]
  int v38; // [sp+90h] [bp-838h]
  int v39; // [sp+94h] [bp-834h]
  __int16 v40; // [sp+9Ch] [bp-82Ch]
  char v41; // [sp+9Eh] [bp-82Ah]
  char v42[16]; // [sp+A0h] [bp-828h] BYREF
  char src[132]; // [sp+B0h] [bp-818h] BYREF

  v3 = sub_3388C();
  v4 = dword_7EB9C;
  v5 = *a2;
  v6 = BYTE2(v3);
  v40 = v3;
  v36 = (unsigned int *)BYTE1(v3);
  v38 = v5;
  v41 = BYTE2(v3);
  s = v42;
  if ( (unsigned int)dword_7EB9C > 4 )
  {
    snprintf(v42, 0x800u, "[DEBUG] Send work, max_freq = %d\n", v38);
    sub_2E584(4, v42, 0);
    v4 = dword_7EB9C;
  }
  v7 = 3;
  v39 = v6;
  v8 = s;
  if ( v4 > 4 )
    goto LABEL_15;
  while ( 1 )
  {
    sub_40390(24, 0);
    v9 = sub_4476C();
    v10 = 0;
    sub_44794(v9 & 0xFFFF70FF | 0x8400);
    do
    {
      if ( sub_1E29C(v10) )
        sub_50288((unsigned __int8)v10, 1, 0);
      ++v10;
    }
    while ( v10 != 4 );
    if ( (unsigned int)dword_7EB9C > 4 )
    {
      strcpy(v8, "[DEBUG] Send null work.\n");
      sub_2E584(4, v8, 0);
    }
    v11 = 0;
    memset(v8, 0, 0x94u);
    v42[0] = 1;
    do
    {
      if ( sub_1E29C(v11) )
      {
        while ( (sub_44ED4() & (1 << v11)) == 0 )
          sub_304D4();
        v42[1] = v11 | 0x80;
        memcpy(v35, src, 0x84u);
        sub_1EEB8(
          *(_DWORD *)v8,
          *((_DWORD *)v8 + 1),
          *((_DWORD *)v8 + 2),
          *((_DWORD *)v8 + 3),
          v35[0],
          v35[1],
          v35[2],
          v35[3],
          v35[4],
          v35[5],
          v35[6],
          v35[7],
          v35[8],
          v35[9],
          v35[10],
          v35[11],
          v35[12],
          v35[13],
          v35[14],
          v35[15],
          v35[16],
          v35[17],
          v35[18],
          v35[19],
          v35[20],
          v35[21],
          v35[22],
          v35[23],
          v35[24],
          v35[25],
          v35[26],
          v35[27],
          v35[28]);
        sub_304D4();
      }
      ++v11;
    }
    while ( v11 != 4 );
    sleep(1u);
    v12 = sub_4476C();
    sub_44794(v12 & 0xFFFF70FF | 0x8100);
    usleep((__useconds_t)&loc_186A0);
    if ( !--v7 )
      break;
    if ( (unsigned int)dword_7EB9C > 4 )
    {
LABEL_15:
      strcpy(v8, "[DEBUG] Set start nonce offset invalid.\n");
      sub_2E584(4, v8, 0);
    }
  }
  v13 = v39;
  sub_1F1EC(255, 1);
  sub_1EFE0(255, (char)v36, v13, 1);
  sub_36908();
  usleep(0x186A0u);
  sub_36908();
  usleep(0x186A0u);
  sub_36908();
  usleep(0x186A0u);
  do
  {
    if ( sub_1E29C(v7) )
      sub_50BD4((unsigned __int8)v7, 0);
    ++v7;
  }
  while ( v7 != 4 );
  for ( i = 0; i != 4; ++i )
  {
    if ( sub_1E29C(i) )
      sub_50E78((unsigned __int8)i);
  }
  v15 = 3;
  v16 = 30000 - (v38 - 250) / 0x14u;
  do
  {
    for ( j = 0; j != 4; ++j )
    {
      if ( sub_1E29C(j) )
        sub_50F80((unsigned __int8)j, v16 / 333);
    }
    usleep((__useconds_t)&loc_186A0);
    --v15;
  }
  while ( v15 );
  do
  {
    if ( sub_1E29C(v15) )
      sub_50FA4((unsigned __int8)v15, 8);
    ++v15;
  }
  while ( v15 != 4 );
  v18 = v16 + 1000;
  v19 = 8;
  do
  {
    for ( k = 0; k != 4; ++k )
    {
      if ( sub_1E29C(k) )
        sub_50FDC((unsigned __int8)k);
    }
    usleep(v18);
    --v19;
  }
  while ( v19 );
  sub_36908();
  usleep(0x186A0u);
  sub_36908();
  usleep(0x186A0u);
  sub_36908();
  usleep(0x186A0u);
  sub_1EFE0(255, (char)v36, v13, 0);
  if ( (unsigned int)dword_7EB9C > 4 )
  {
    v33 = s;
    v34 = s;
    *(_DWORD *)s = *(_DWORD *)"[DEBUG] Get nonce counter, chain.\n";
    strcpy(v34 + 4, "UG] Get nonce counter, chain.\n");
    sub_2E584(4, v33, 0);
    v21 = *(char **)(dword_4FCB34 + 4);
    if ( (unsigned int)dword_7EB9C > 4 )
    {
      snprintf(v33, 0x800u, "[DEBUG] Read reg and wait done, reg = %d, done_threshold = %d.\n", 224, 1);
      sub_2E584(4, v33, 0);
    }
  }
  else
  {
    v21 = *(char **)(dword_4FCB34 + 4);
  }
  memset(v21, 0, 0x400u);
  v22 = 5;
  sub_1EC84(255, 1, 0, 224);
  while ( !sub_36F2C() )
  {
    usleep((__useconds_t)&loc_186A0);
    if ( !--v22 )
    {
      v36 = (unsigned int *)&dword_7EB9C;
      v23 = 95;
      v24 = v21;
      while ( 1 )
      {
        for ( m = 0; m != 4; ++m )
        {
          if ( sub_1E29C(m) )
          {
            v28 = sub_1E0F0();
            if ( v28 )
            {
              v29 = &v24[256 * m];
              for ( n = 0; n != v28; ++n )
              {
                v31 = (unsigned __int8)*v29++;
                if ( v31 != 1 )
                {
                  v32 = sub_1E160();
                  sub_1EC84((unsigned __int8)m, 0, v32 * n, 224);
                }
              }
            }
          }
        }
        usleep((__useconds_t)&loc_186A0);
        if ( sub_36F2C() )
          break;
        if ( !--v23 )
        {
          if ( *v36 > 3 )
          {
            v27 = s;
            snprintf(s, 0x800u, "Read REG[0x%X] done failed.\n", 224);
            sub_2E584(3, v27, 0);
          }
          return -1;
        }
      }
      return 0;
    }
  }
  return 0;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 4FCB34: using guessed type int dword_4FCB34;
// 36F6C: using guessed type int var_8C8[34];

//----- (00037574) --------------------------------------------------------
char **sub_37574()
{
  char v1[2056]; // [sp-808h] [bp-808h] BYREF

  if ( (unsigned int)dword_7EB9C > 4 )
  {
    strcpy(v1, "[DEBUG] Get hw ops.\n");
    sub_2E584(4, v1, 0);
  }
  return &off_7EDF0;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 7EDF0: using guessed type char *off_7EDF0;

//----- (000375E8) --------------------------------------------------------
int sub_375E8()
{
  return dword_4FCB38 + 8;
}
// 4FCB38: using guessed type int dword_4FCB38;

//----- (000375FC) --------------------------------------------------------
bool __fastcall sub_375FC(int a1)
{
  unsigned int v2; // r5
  int v3; // r4
  char v5[2064]; // [sp+0h] [bp-810h] BYREF

  if ( (unsigned int)dword_7EB9C > 4 )
  {
    snprintf(v5, 0x800u, "[DEBUG] Check if is recv nonce enough, chain = %d.\n", a1);
    sub_2E584(4, v5, 0);
  }
  v2 = *(_DWORD *)(dword_4FCB38 + 4 * ((_DWORD)&unk_202802 + a1));
  v3 = 8 * sub_1E130();
  return v2 >= sub_1E0F0() * v3;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 4FCB38: using guessed type int dword_4FCB38;

//----- (00037694) --------------------------------------------------------
int __fastcall sub_37694(int a1)
{
  unsigned int v2; // r4
  int v3; // r0
  unsigned int v4; // r4
  int v5; // r0
  unsigned int v6; // r7
  int v7; // r10
  int i; // r5
  unsigned int j; // r4
  unsigned int v10; // r2
  int v12; // [sp+14h] [bp-82Ch]
  char s[2088]; // [sp+18h] [bp-828h] BYREF

  v2 = *(_DWORD *)(dword_4FCB38 + 4 * (a1 + 2107394));
  v3 = sub_1E0E0();
  v4 = sub_5F880(v2, v3);
  v5 = sub_1E150();
  v6 = sub_5F880(v4, v5) >> 1;
  v12 = sub_1E0E0();
  if ( !v12 )
    return 0;
  v7 = 0;
  for ( i = 0; i != v12; ++i )
  {
    for ( j = 0; sub_1E150() > j; ++j )
    {
      v10 = j + i * sub_1E150();
      if ( *(_DWORD *)(dword_4FCB38 + 4 * ((_DWORD)&unk_202806 + 64 * a1 + v10)) < v6 )
      {
        v7 = 1;
        if ( (unsigned int)dword_7EB9C > 3 )
        {
          snprintf(
            s,
            0x800u,
            "Domain unbalance happen, chain = %d, domain = %d, nonce_num_domain = %d, threshold = %d.\n",
            a1,
            v10,
            *(_DWORD *)(dword_4FCB38 + 4 * ((_DWORD)&unk_202806 + 64 * a1 + v10)),
            v6);
          sub_2E584(3, s, 0);
        }
      }
    }
  }
  return v7;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 4FCB38: using guessed type int dword_4FCB38;

//----- (000377B8) --------------------------------------------------------
void *sub_377B8()
{
  return memset((void *)(dword_4FCB38 + 8), 0, (size_t)&unk_80A8A4);
}
// 4FCB38: using guessed type int dword_4FCB38;

//----- (000377D8) --------------------------------------------------------
int __fastcall sub_377D8(int a1)
{
  int v1; // r7
  int v2; // r9
  int v3; // r4
  int v4; // r11
  int v5; // r9
  _DWORD *v6; // r10
  char *v7; // r4
  int *v8; // r12
  int v9; // r0
  int v10; // r1
  char *v11; // lr
  int v12; // r2
  int v13; // r3
  int v14; // r5
  int v15; // r0
  int v16; // r6
  int v17; // r1
  int v18; // r9
  int v19; // r2
  _DWORD *v20; // r12
  int v21; // r1
  int v22; // r2
  int v23; // r3
  char *v24; // r7
  _DWORD *v25; // lr
  _DWORD *v26; // lr
  int v27; // r1
  int v28; // r2
  int v29; // r3
  char *v30; // lr
  int v31; // r1
  int v32; // r2
  int v33; // r3
  bool v34; // zf
  unsigned int v35; // r4
  int v36; // r5
  int v37; // r3
  int v38; // r1
  _DWORD *v40; // r3
  int v41; // r1
  int v42; // lr
  int v43; // r0
  int v44; // r2
  int v45; // r0
  int v46; // r1
  int v47; // lr
  int v48; // r0
  int v49; // r0
  int v50; // r1
  int v51; // r3
  int v52[33]; // [sp+0h] [bp-9D0h] BYREF
  int *v53; // [sp+88h] [bp-948h]
  _DWORD *v54; // [sp+8Ch] [bp-944h]
  int v55; // [sp+90h] [bp-940h]
  int v56; // [sp+94h] [bp-93Ch]
  _DWORD *v57; // [sp+98h] [bp-938h]
  int v58; // [sp+9Ch] [bp-934h]
  int v59; // [sp+A0h] [bp-930h]
  int v60; // [sp+A4h] [bp-92Ch]
  int v61; // [sp+A8h] [bp-928h]
  _DWORD *v62; // [sp+ACh] [bp-924h]
  int v63; // [sp+B0h] [bp-920h]
  int v64; // [sp+B4h] [bp-91Ch]
  int v65; // [sp+B8h] [bp-918h]
  int v66; // [sp+BCh] [bp-914h]
  int v67; // [sp+C0h] [bp-910h]
  int v68; // [sp+C4h] [bp-90Ch]
  void *v69; // [sp+C8h] [bp-908h]
  int *v70; // [sp+CCh] [bp-904h]
  __time_t v71[2]; // [sp+D0h] [bp-900h] BYREF
  __time_t v72[2]; // [sp+D8h] [bp-8F8h] BYREF
  char v73[20]; // [sp+E0h] [bp-8F0h] BYREF
  int v74; // [sp+F4h] [bp-8DCh]
  int v75; // [sp+F8h] [bp-8D8h]
  int v76; // [sp+FCh] [bp-8D4h]
  int v77; // [sp+100h] [bp-8D0h]
  int v78; // [sp+104h] [bp-8CCh]
  int v79; // [sp+108h] [bp-8C8h]
  int v80; // [sp+10Ch] [bp-8C4h]
  int v81; // [sp+110h] [bp-8C0h] BYREF
  _BYTE v82[148]; // [sp+114h] [bp-8BCh] BYREF
  char s[2088]; // [sp+1A8h] [bp-828h] BYREF

  v67 = a1;
  v70 = &dword_7EB9C;
  sub_302A0(v71);
  if ( (unsigned int)dword_7EB9C <= 3 || (strcpy(s, "\n"), sub_2EA54(3, s, 0), (unsigned int)*v70 <= 3) )
  {
    v68 = sub_1E0F0();
    if ( !v68 )
    {
LABEL_37:
      v1 = v68;
      goto LABEL_26;
    }
  }
  else
  {
    snprintf(s, 0x800u, ">>>> Send work for chain %d.\n", v67);
    sub_2E584(3, s, 0);
    v68 = sub_1E0F0();
    if ( !v68 )
      goto LABEL_37;
  }
  v1 = 0;
  v56 = 0;
  v66 = 0;
  v69 = &unk_202A2A;
  v64 = (int)&dword_80ACAC + 6656 * v67;
  v2 = 1 << v67;
  do
  {
    v3 = *(_DWORD *)(dword_4FCB38 + 4 * ((_DWORD)v69 + v66) + 4);
    v65 = sub_1E130();
    if ( v65 )
    {
      v4 = v2;
      v5 = v1;
      v62 = (_DWORD *)(v3 + 20);
      v61 = 0;
      v63 = (unsigned __int8)~((unsigned int)~(v67 << 25) >> 25);
      do
      {
        v6 = v62;
        v60 = v61 & 3;
        v55 = 0;
        do
        {
          while ( (v4 & sub_44ED4()) == 0 )
          {
            ++v5;
            usleep(0x3E8u);
          }
          v7 = v73;
          v8 = v6 - 5;
          v54 = v6 - 5;
          do
          {
            v9 = *v8;
            v8 += 4;
            v10 = *(v8 - 3);
            v11 = v7;
            v12 = *(v8 - 2);
            v7 += 16;
            v13 = *(v8 - 1);
            *(_DWORD *)v11 = v9;
            *((_DWORD *)v11 + 1) = v10;
            *((_DWORD *)v11 + 2) = v12;
            *((_DWORD *)v11 + 3) = v13;
          }
          while ( v8 != v6 + 7 );
          v14 = 0;
          *(_DWORD *)v7 = *v8;
          memset(&v82[2], 0, 0x92u);
          v15 = *(v6 - 3);
          v59 = v5;
          v16 = v64 + 52 * v56;
          v17 = *(v6 - 2);
          v18 = v60;
          v82[1] = v63;
          v19 = *(v6 - 1);
          LOBYTE(v74) = v74 + 1;
          *(_DWORD *)&v82[8] = v15;
          *(_DWORD *)&v82[12] = v17;
          *(_DWORD *)&v82[16] = v19;
          v53 = &v81;
          v58 = v4;
          *(_DWORD *)&v82[4] = v56 & 0x7F | v55;
          v57 = v54 + 12;
          v82[0] = 1;
          do
          {
            v20 = (_DWORD *)(dword_4FCB38 + v16);
            if ( v14 == v18 )
            {
              v40 = &v82[32 * v14 + 20];
              v41 = v6[1];
              v42 = v6[2];
              *v40 = *v6;
              v43 = v6[3];
              v44 = (int)v54;
              v40[1] = v41;
              v40[3] = v43;
              v45 = v6[4];
              v40[2] = v42;
              v46 = v6[5];
              v47 = v6[6];
              v40[4] = v45;
              v48 = v6[7];
              v40[5] = v46;
              v40[6] = v47;
              v40[7] = v48;
              do
              {
                v44 += 16;
                v20 += 4;
                v49 = *(_DWORD *)(v44 - 12);
                v50 = *(_DWORD *)(v44 - 8);
                v51 = *(_DWORD *)(v44 - 4);
                v34 = v44 == (_DWORD)v57;
                *(v20 - 4) = *(_DWORD *)(v44 - 16);
                *(v20 - 3) = v49;
                *(v20 - 2) = v50;
                *(v20 - 1) = v51;
              }
              while ( !v34 );
              *v20 = *v57;
            }
            else
            {
              v21 = v75;
              v22 = v76;
              v23 = v77;
              v24 = v73;
              v25 = &v82[32 * v14 + 20];
              *v25 = v74;
              v25[1] = v21;
              v25[2] = v22;
              v25[3] = v23;
              v26 = &v82[32 * v14 + 36];
              v27 = v79;
              v28 = v80;
              v29 = v81;
              *v26 = v78;
              v26[1] = v27;
              v26[2] = v28;
              v26[3] = v29;
              do
              {
                v30 = v24;
                v24 += 16;
                v20 += 4;
                v31 = *((_DWORD *)v30 + 1);
                v32 = *((_DWORD *)v30 + 2);
                v33 = *((_DWORD *)v30 + 3);
                v34 = v30 + 16 == (char *)v53;
                *(v20 - 4) = *(_DWORD *)v30;
                *(v20 - 3) = v31;
                *(v20 - 2) = v32;
                *(v20 - 1) = v33;
              }
              while ( !v34 );
              *v20 = *(_DWORD *)v24;
            }
            ++v14;
            v16 += 52;
          }
          while ( v14 != 4 );
          v4 = v58;
          v6 += 13;
          v35 = v56 + 4;
          v5 = v59;
          memcpy(v52, &v82[16], sizeof(v52));
          v36 = v55 + 128;
          v55 += 128;
          sub_1EEB8(
            *(unsigned int *)v82,
            *(int *)&v82[4],
            *(int *)&v82[8],
            *(int *)&v82[12],
            v52[0],
            v52[1],
            v52[2],
            v52[3],
            v52[4],
            v52[5],
            v52[6],
            v52[7],
            v52[8],
            v52[9],
            v52[10],
            v52[11],
            v52[12],
            v52[13],
            v52[14],
            v52[15],
            v52[16],
            v52[17],
            v52[18],
            v52[19],
            v52[20],
            v52[21],
            v52[22],
            v52[23],
            v52[24],
            v52[25],
            v52[26],
            v52[27],
            v52[28]);
          if ( v35 >= 0x80 )
            v37 = 0;
          else
            v37 = v35;
          v56 = v37;
        }
        while ( v36 != 1024 );
        v62 += 104;
        ++v61;
      }
      while ( v65 != v61 );
      v1 = v5;
      v2 = v4;
    }
    v34 = v68 == ++v66;
  }
  while ( !v34 );
LABEL_26:
  sub_302A0(v72);
  v38 = v72[0] - v71[0];
  if ( v72[1] - v71[1] < 0 )
    --v38;
  if ( (unsigned int)*v70 > 3 )
  {
    snprintf(s, 0x800u, "Send work for chain %d done, time cost %lds, sleep_count = %d\n", v67, v38, v1);
    sub_2E584(3, s, 0);
  }
  return 0;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 4FCB38: using guessed type int dword_4FCB38;

//----- (00037C4C) --------------------------------------------------------
unsigned int __fastcall sub_37C4C(int a1)
{
  unsigned int v2; // r7
  int v3; // r0
  unsigned int v4; // r8
  unsigned int v5; // r4
  int v6; // r6
  unsigned int v7; // r10
  unsigned int result; // r0
  unsigned int v9; // r9
  int v10; // r5
  unsigned int v11; // r9
  _BOOL4 v12; // r3
  int v13; // r2
  int v14; // r2
  int v15; // r2
  unsigned int v16; // r3
  int v17; // r5
  int v18; // r1
  int v19; // r12

  v2 = *(_DWORD *)(a1 + 4);
  v3 = sub_1E160();
  v4 = sub_51978(v2, v3);
  v5 = *(_BYTE *)a1 & 0xF;
  v6 = *(_WORD *)(a1 + 2) & 0x7FFF;
  v7 = sub_51970(v2);
  result = sub_1E140();
  if ( v5 <= 3 && (v9 = result, (result = sub_1E29C(v5)) != 0) )
  {
    if ( (*(_BYTE *)a1 & 0x20) != 0 )
    {
      ++*(_DWORD *)(dword_4FCB38 + 4 * v5 + 8431656);
    }
    else if ( (*(_BYTE *)a1 & 0x40) != 0 )
    {
      ++*(_DWORD *)(dword_4FCB38 + 4 * v5 + 8431672);
    }
    else if ( (*(_BYTE *)a1 & 0x80) != 0 )
    {
      result = sub_1E0F0();
      if ( result > v4 )
      {
        v10 = v6 >> 7;
        v11 = (v6 & 3) + v9 * v7;
        result = sub_1E130();
        v12 = v6 >> 7 > 7;
        if ( result <= v11 )
          v12 = 1;
        if ( v12 )
        {
          ++*(_DWORD *)(dword_4FCB38 + 4 * v5 + 8431720);
        }
        else
        {
          result = 52;
          v13 = dword_4FCB38;
          if ( *(_DWORD *)(*(_DWORD *)(dword_4FCB38 + 4 * ((_DWORD)&unk_202A2A + v4) + 4) + 52 * v10 + 416 * v11 + 4) == v2 )
          {
            v16 = v4 + (v5 << 8);
            v17 = 1 << v10;
            v18 = dword_4FCB38 + 4 * (v11 + (v16 << 10));
            v19 = *(_DWORD *)(v18 + 8);
            if ( (v19 & v17) != 0 )
            {
              ++*(_DWORD *)(dword_4FCB38 + 4 * v5 + 8431640);
            }
            else
            {
              result = v18 + 4231168;
              *(_DWORD *)(v18 + 8) = v19 | v17;
              ++*(_DWORD *)(v18 + 4231176);
              ++*(_DWORD *)(v13 + 4 * v16 + 8425480);
              ++*(_DWORD *)(v13 + 4 * v5 + 8429576);
            }
          }
          else
          {
            result = sub_386BC((_DWORD *)((char *)&dword_80ACAC[1664 * v5 + 13 * (v6 & 0x7F)] + dword_4FCB38), v2);
            if ( result )
              v14 = *(_DWORD *)(dword_4FCB38 + 4 * v5 + 8431704);
            else
              v14 = *(_DWORD *)(dword_4FCB38 + 4 * v5 + 8431720);
            v15 = v14 + 1;
            if ( result )
              *(_DWORD *)(dword_4FCB38 + 4 * v5 + 8431704) = v15;
            else
              *(_DWORD *)(dword_4FCB38 + 4 * v5 + 8431720) = v15;
          }
        }
      }
      else
      {
        ++*(_DWORD *)(dword_4FCB38 + 4 * v5 + 8431756);
      }
    }
    else
    {
      ++*(_DWORD *)(dword_4FCB38 + 4 * v5 + 8431688);
    }
  }
  else
  {
    ++*(_DWORD *)(dword_4FCB38 + 8431752);
  }
  return result;
}
// 4FCB38: using guessed type int dword_4FCB38;
// 80ACAC: using guessed type _DWORD dword_80ACAC[6656];

//----- (00037F08) --------------------------------------------------------
void sub_37F08()
{
  void **v0; // r6
  int v1; // r9
  int v2; // r5
  char *v3; // r2
  char *v4; // r4
  int v5; // r4

  LOWORD(v0) = (unsigned __int16)&dword_4FCB38;
  v1 = sub_1E0F0();
  if ( v1 )
  {
    HIWORD(v0) = (unsigned int)&dword_4FCB38 >> 16;
    v2 = 0;
    v3 = (char *)*v0;
    do
    {
      v4 = (char *)&unk_202A2A + v2++;
      v5 = 4 * (_DWORD)v4;
      if ( *(_DWORD *)&v3[v5 + 4] )
      {
        free(*(void **)&v3[v5 + 4]);
        v3 = (char *)*v0;
        *(_DWORD *)((char *)*v0 + v5 + 4) = 0;
      }
    }
    while ( v1 != v2 );
  }
  else
  {
    HIWORD(v0) = (unsigned int)&dword_4FCB38 >> 16;
    v3 = (char *)*v0;
  }
  free(v3);
  *v0 = 0;
}
// 4FCB38: using guessed type int dword_4FCB38;

//----- (00037F88) --------------------------------------------------------
void sub_37F88()
{
  if ( dword_4FCB38 )
    sub_37F08();
}
// 4FCB38: using guessed type int dword_4FCB38;

//----- (00037FA0) --------------------------------------------------------
int __fastcall sub_37FA0(FILE **a1, int a2, int a3, int a4)
{
  int v4; // r6
  int v5; // r7
  int v6; // r1
  int v7; // r2
  int v8; // r3
  int v9; // r1
  int v10; // r2
  int v11; // r3
  int v12; // r0
  int v13; // r1
  int v14; // r2
  int v15; // r5
  int v16; // r8
  _DWORD *v17; // r4
  int v19; // [sp+4h] [bp-864h]
  _DWORD ptr[12]; // [sp+10h] [bp-858h] BYREF
  char v23[2088]; // [sp+40h] [bp-828h] BYREF

  if ( a4 )
  {
    v4 = 52 * a3 * a4;
    v19 = 4 * ((_DWORD)&unk_202A2A + a2);
    v5 = 0;
    while ( 1 )
    {
      v15 = v5++;
      v16 = *(_DWORD *)(dword_4FCB38 + v19 + 4);
      v17 = (_DWORD *)(v16 + v4);
      if ( fread(ptr, 1u, 0x30u, *a1) != 48 )
        break;
      v17[1] = ptr[0];
      v6 = ptr[5];
      v7 = ptr[6];
      v8 = ptr[7];
      v17[5] = ptr[4];
      *(_DWORD *)(v16 + v4 + 24) = v6;
      *(_DWORD *)(v16 + v4 + 28) = v7;
      *(_DWORD *)(v16 + v4 + 32) = v8;
      v9 = ptr[9];
      v10 = ptr[10];
      v11 = ptr[11];
      *(_DWORD *)(v16 + v4 + 36) = ptr[8];
      *(_DWORD *)(v16 + v4 + 40) = v9;
      *(_DWORD *)(v16 + v4 + 44) = v10;
      v12 = ptr[1];
      v13 = ptr[2];
      v14 = ptr[3];
      *(_DWORD *)(v16 + v4 + 48) = v11;
      v17[2] = v12;
      *(_DWORD *)(v16 + v4 + 12) = v13;
      *(_DWORD *)(v16 + v4 + 16) = v14;
      *(_DWORD *)(v16 + v4) = v15;
      v4 += 52;
      if ( v5 == a4 )
        return v5;
    }
    if ( (unsigned int)dword_7EB9C <= 3 )
      return v15;
    strcpy(v23, "Load core pattern failed!\n");
    sub_2E584(3, v23, 0);
    return v15;
  }
  else
  {
    return 0;
  }
}
// 7EB9C: using guessed type int dword_7EB9C;
// 4FCB38: using guessed type int dword_4FCB38;

//----- (00038110) --------------------------------------------------------
int __fastcall sub_38110(int a1)
{
  _DWORD *v2; // r10
  const char *v3; // r5
  int v4; // r9
  int v5; // r6
  int v6; // r7
  unsigned int v7; // r5
  int i; // r4
  int v9; // r2
  int v10; // r4
  int v12; // r9
  _DWORD *v13; // r11
  int v14; // r0
  void *v15; // r0
  _DWORD *v16; // r3
  int v17; // r3
  int v18; // r0
  FILE *stream; // [sp+Ch] [bp-82Ch] BYREF
  char s[2088]; // [sp+10h] [bp-828h] BYREF

  if ( (unsigned int)dword_7EB9C > 4 )
  {
    strcpy(s, "[DEBUG] Free memory for sw sweep.\n");
    sub_2E584(4, s, 0);
  }
  v2 = (_DWORD *)dword_4FCB38;
  if ( !dword_4FCB38 )
  {
    dword_4FCB38 = (int)calloc((size_t)&unk_8114AC, 1u);
    if ( dword_4FCB38 )
    {
      v12 = sub_1E0F0();
      if ( !v12 )
      {
        v2 = (_DWORD *)dword_4FCB38;
        goto LABEL_4;
      }
      v13 = v2;
      while ( 1 )
      {
        v14 = sub_1E130();
        v2 = (_DWORD *)dword_4FCB38;
        v15 = malloc(416 * v14);
        v16 = &v2[(int)&unk_202A2A + (_DWORD)v13];
        v13 = (_DWORD *)((char *)v13 + 1);
        v16[1] = v15;
        if ( !v15 )
          break;
        if ( (_DWORD *)v12 == v13 )
          goto LABEL_4;
      }
      if ( (unsigned int)dword_7EB9C <= 3 )
      {
LABEL_27:
        sub_37F08();
LABEL_28:
        sub_356C4(13, 255);
        return -1;
      }
      strcpy(s, "Fail to allocate memory for works.\n");
      sub_2E584(3, s, 0);
      v17 = dword_4FCB38;
    }
    else
    {
      if ( (unsigned int)dword_7EB9C <= 3 )
        goto LABEL_28;
      strcpy(s, "Fail to allocate memory for sw sweep ctxt.\n");
      sub_2E584(3, s, 0);
      v17 = dword_4FCB38;
    }
    if ( !v17 )
      goto LABEL_28;
    goto LABEL_27;
  }
LABEL_4:
  *v2 = a1;
  v3 = *(const char **)dword_4FCB38;
  stream = (FILE *)fopen64(*(_DWORD *)dword_4FCB38, "r");
  if ( !stream )
  {
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      snprintf(s, 0x800u, "Fail to open pattern file %s.\n", v3);
      sub_2E584(3, s, 0);
    }
LABEL_16:
    sub_356C4(22, 255);
    v10 = -1;
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      strcpy(s, "Load pattern file failed.\n");
      sub_2E584(3, s, 0);
    }
    goto LABEL_18;
  }
  v4 = sub_1E0F0();
  if ( v4 )
  {
    v5 = 0;
    while ( 1 )
    {
      v6 = sub_1E130();
      if ( v6 )
      {
        v7 = 0;
        for ( i = 0; i != v6; ++i )
        {
          v9 = i;
          v7 += sub_37FA0(&stream, v5, v9, 8);
        }
      }
      else
      {
        v7 = 0;
      }
      if ( v7 < 8 * sub_1E130() )
        break;
      if ( v4 == ++v5 )
        goto LABEL_13;
    }
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      v18 = sub_1E130();
      snprintf(s, 0x800u, "No enough work, asic = %d, work_count = %d, work_count_target = %d.\n", v5, v7, 8 * v18);
      sub_2E584(3, s, 0);
    }
    fclose(stream);
    goto LABEL_16;
  }
LABEL_13:
  v10 = 0;
  fclose(stream);
LABEL_18:
  sub_44970();
  sub_44880(4);
  return v10;
}
// 124E4: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 7EB9C: using guessed type int dword_7EB9C;
// 4FCB38: using guessed type int dword_4FCB38;

//----- (00038450) --------------------------------------------------------
char **sub_38450()
{
  char v1[2056]; // [sp-808h] [bp-808h] BYREF

  if ( (unsigned int)dword_7EB9C > 4 )
  {
    strcpy(v1, "[DEBUG] Get sw ops.\n");
    sub_2E584(4, v1, 0);
  }
  return &off_7EE1C;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 7EE1C: using guessed type char *off_7EE1C;

//----- (000384C0) --------------------------------------------------------
int __fastcall sub_384C0(int a1)
{
  char v2[2056]; // [sp-808h] [bp-808h] BYREF

  if ( (unsigned int)dword_7EB9C > 1 )
  {
    snprintf(v2, 0x800u, "input value error: %c\n", a1);
    sub_2E584(1, v2, 0);
  }
  return 255;
}
// 7EB9C: using guessed type int dword_7EB9C;

//----- (00038520) --------------------------------------------------------
int __fastcall sub_38520(int a1)
{
  int v1; // r3

  if ( (unsigned int)(a1 - 48) <= 9 )
    return a1 & 0xF;
  v1 = a1 & 0xDF;
  switch ( v1 )
  {
    case 'A':
      return 10;
    case 'B':
      return 11;
    case 'C':
      return 12;
    case 'D':
      return 13;
    case 'E':
      return 14;
    case 'F':
      return 15;
  }
  return sub_384C0(a1);
}

//----- (0003859C) --------------------------------------------------------
int __fastcall sub_3859C(_BYTE *a1, unsigned __int8 *a2, int a3)
{
  bool v3; // cc
  int v4; // r3
  int v8; // r7
  unsigned __int8 *v9; // r8
  unsigned __int8 *v10; // r4
  char *v11; // r11
  int v12; // r6
  int v13; // t1
  char v14; // r5
  char v15; // r4
  int v16; // [sp+Ch] [bp-82Ch]
  char s[2088]; // [sp+10h] [bp-828h] BYREF

  v3 = (int)a1 <= 0;
  if ( a1 )
    v3 = a3 <= 0;
  v4 = v3;
  if ( !a2 )
    v4 = 1;
  if ( v4 )
  {
    if ( (unsigned int)dword_7EB9C > 4 )
    {
      snprintf(s, 0x800u, "s2hex para error dst(%p), src(%p), inlen(%d)\n", a1, a2, a3);
      sub_2E584(4, s, 0);
    }
    return -1;
  }
  else
  {
    v8 = a3 >> 1;
    v16 = a3 & 1;
    if ( a3 >> 1 )
    {
      v9 = &a2[2 * v8];
      v10 = a2;
      v11 = a1 - 1;
      do
      {
        v12 = v10[1];
        v13 = *v10;
        v10 += 2;
        v14 = sub_38520(v13);
        *++v11 = sub_38520(v12) ^ (16 * v14);
      }
      while ( v10 != v9 );
    }
    if ( v16 )
    {
      v15 = sub_38520(a2[2 * v8]);
      a1[v8] = sub_384C0(0) ^ (16 * v15);
    }
    return v8 + v16;
  }
}
// 7EB9C: using guessed type int dword_7EB9C;

//----- (000386BC) --------------------------------------------------------
unsigned int __fastcall sub_386BC(_DWORD *a1, unsigned int a2)
{
  unsigned int result; // r0
  int v5; // r1
  int v6; // r2
  int v7; // r3
  int v8; // r1
  int v9; // r2
  int v10; // r3
  _DWORD *v11; // r4
  unsigned int v12; // t1
  unsigned int v13; // r1
  unsigned int v14; // r2
  unsigned int *v15; // r2
  unsigned int *v16; // r1
  unsigned int v17; // t1
  unsigned int v18[8]; // [sp+0h] [bp-138h] BYREF
  char s[32]; // [sp+20h] [bp-118h] BYREF
  int v20[62]; // [sp+40h] [bp-F8h] BYREF

  memset(v18, 0, sizeof(v18));
  memset(s, 0, sizeof(s));
  if ( !a1 )
    return 0;
  v5 = a1[6];
  v6 = a1[7];
  v7 = a1[8];
  v20[2] = a1[5];
  v20[3] = v5;
  v20[4] = v6;
  v20[5] = v7;
  v8 = a1[10];
  v9 = a1[11];
  v10 = a1[12];
  v20[6] = a1[9];
  v20[7] = v8;
  v20[8] = v9;
  v20[9] = v10;
  sub_31268(&v20[2], 32);
  v12 = a1[2];
  v11 = a1 + 2;
  v20[0] = 80;
  v20[1] = 0;
  v13 = v11[1];
  v14 = v11[2];
  v18[0] = v12;
  v18[1] = v13;
  v18[2] = v14;
  sub_31268(v18, 12);
  sub_316B0((int)&v20[10], v18, 0xCu);
  v18[0] = bswap32(a2);
  sub_31268(v18, 4);
  sub_316B0((int)&v20[13], v18, 4u);
  sub_2327C((int)v20, v18);
  memset(v20, 0, 0xE8u);
  sub_23430(v18, 32, s);
  v15 = &v18[7];
  v16 = &v18[-1];
  do
  {
    v17 = v15[1];
    ++v15;
    v16[1] = bswap32(v17);
    ++v16;
  }
  while ( v15 != (unsigned int *)&s[28] );
  result = v18[7];
  if ( v18[7] )
    return 1;
  return result;
}

//----- (000387F8) --------------------------------------------------------
int sub_387F8()
{
  char v1[2056]; // [sp+0h] [bp-808h] BYREF

  strcpy(v1, "Handle is NULL.\n");
  return sub_2E584(3, v1, 0);
}

//----- (0003883C) --------------------------------------------------------
int __fastcall sub_3883C(_DWORD *a1)
{
  int v2; // r3
  char v4[2064]; // [sp+0h] [bp-810h] BYREF

  if ( (unsigned int)dword_7EB9C > 4 )
  {
    snprintf(v4, 0x800u, "[DEBUG] Send work one chain, chain = %d.\n", *a1);
    sub_2E584(4, v4, 0);
  }
  if ( dword_4FCB3C )
  {
    v2 = *(_DWORD *)(dword_4FCB3C + 4);
    if ( v2 )
    {
      (*(void (__fastcall **)(_DWORD, _DWORD))(v2 + 28))(*a1, a1[2]);
      a1[1] = 1;
      return 0;
    }
  }
  if ( (unsigned int)dword_7EB9C <= 3 )
    return 0;
  sub_387F8();
  return 0;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 4FCB3C: using guessed type int dword_4FCB3C;

//----- (000388F4) --------------------------------------------------------
int sub_388F4()
{
  char v1[2056]; // [sp+0h] [bp-808h] BYREF

  strcpy(v1, "Handle is NULL.\n");
  sub_2E584(3, v1, 0);
  return 1;
}

//----- (0003893C) --------------------------------------------------------
int __fastcall sub_3893C(int result)
{
  int v1; // r5
  int v2; // r3
  char v3[2064]; // [sp+0h] [bp-810h] BYREF

  v1 = result;
  if ( (unsigned int)dword_7EB9C > 4 )
  {
    strcpy(v3, "[DEBUG] Send work for hw sweep.\n");
    result = sub_2E584(4, v3, 0);
  }
  if ( dword_4FCB3C )
  {
    v2 = *(_DWORD *)(dword_4FCB3C + 4);
    if ( v2 )
      return (*(int (__fastcall **)(int, int))(v2 + 28))(255, v1);
  }
  if ( (unsigned int)dword_7EB9C > 3 )
    return sub_387F8();
  return result;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 4FCB3C: using guessed type int dword_4FCB3C;

//----- (000389F0) --------------------------------------------------------
int __fastcall sub_389F0(int result)
{
  char *v1; // r6
  int v2; // r8
  int v3; // r4
  int i; // r4
  int v5[4]; // [sp+0h] [bp-830h] BYREF
  char s[2080]; // [sp+10h] [bp-820h] BYREF

  if ( dword_4FCB3C && *(_DWORD *)(dword_4FCB3C + 4) )
  {
    v1 = s;
    v2 = result;
    v3 = 0;
    memset(v5, 0, sizeof(v5));
    memset(s, 0, 0x30u);
    do
    {
      if ( sub_1E29C(v3) && *(_DWORD *)(dword_4FCB3C + 4 * (v3 + 2)) == 1 )
      {
        *(_DWORD *)v1 = v3;
        *((_DWORD *)v1 + 1) = 0;
        *((_DWORD *)v1 + 2) = v2;
        pthread_create((pthread_t *)&v5[v3], 0, (void *(*)(void *))sub_3883C, v1);
        pthread_detach(v5[v3]);
      }
      ++v3;
      v1 += 12;
    }
    while ( v3 != 4 );
    for ( i = 0; i != 4; ++i )
    {
      while ( 1 )
      {
        result = sub_1E29C(i);
        if ( !result || !v5[i] || *(_DWORD *)&s[12 * i + 4] )
          break;
        i = 0;
        usleep((__useconds_t)&loc_186A0);
      }
    }
  }
  else if ( (unsigned int)dword_7EB9C > 3 )
  {
    strcpy(s, "Handle is NULL.\n");
    return sub_2E584(3, s, 0);
  }
  return result;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 4FCB3C: using guessed type int dword_4FCB3C;

//----- (00038B6C) --------------------------------------------------------
int __fastcall sub_38B6C(int a1, int a2)
{
  int v4; // r0
  int v5; // r4
  char *v6; // r0
  char *v7; // r3
  int v8; // t1
  int v9; // r0
  int v10; // r5
  int v11; // r0
  char *v12; // r2
  int v13; // r4
  int v14; // t1
  int v15; // r0
  double v16; // r0

  v4 = sub_1E0F0();
  if ( v4 > 0 )
  {
    v6 = (char *)&unk_808FFC + 1024 * a1 + 4 * v4 + a2;
    v7 = (char *)&unk_808FFC + 1024 * a1 + a2;
    v5 = 0;
    do
    {
      v8 = *((_DWORD *)v7 + 1);
      v7 += 4;
      v5 += v8;
    }
    while ( v7 != v6 );
  }
  else
  {
    v5 = 0;
  }
  v9 = sub_1E0F0();
  v10 = sub_5FAF8(v5, v9);
  v11 = sub_1E0F0();
  if ( v11 <= 0 )
    return sub_1E0F0();
  v12 = (char *)&unk_808FFC + 1024 * a1 + a2;
  v13 = 0;
  do
  {
    v14 = *((_DWORD *)v12 + 1);
    v12 += 4;
    v13 += (v14 - v10) * (v14 - v10);
  }
  while ( v12 != (char *)&unk_808FFC + 1024 * a1 + 4 * v11 + a2 );
  v15 = sub_1E0F0();
  LODWORD(v16) = sub_5FAF8(v13, v15);
  if ( (double)SLODWORD(v16) < 0.0 )
    v16 = sqrt(v16);
  return LODWORD(v16);
}
// 38C64: variable 'v16' is possibly undefined

//----- (00038C70) --------------------------------------------------------
int __fastcall sub_38C70(int a1, const char *a2)
{
  unsigned int v4; // r6
  int *v6; // r8
  int *v7; // r0
  char s[2072]; // [sp+8h] [bp-818h] BYREF

  v4 = a1 - 160;
  if ( (unsigned int)dword_7EB9C > 4 )
  {
    snprintf(s, 0x800u, "[DEBUG] sweep_type = 0x%X, pattern_file_path = %s\n", a1, a2);
    sub_2E584(4, s, 0);
    if ( v4 > 1 )
      goto LABEL_3;
    if ( (unsigned int)dword_7EB9C > 4 )
    {
      strcpy(s, "[DEBUG] allocate memory for pattern test.\n");
      sub_2E584(4, s, 0);
    }
  }
  else if ( v4 > 1 )
  {
LABEL_3:
    sub_356C4(20, 255);
    if ( (unsigned int)dword_7EB9C <= 3 )
      return -1;
    snprintf(s, 0x800u, "Invalid sweep type 0x%X\n", a1);
LABEL_13:
    sub_2E584(3, s, 0);
    return -1;
  }
  v6 = (int *)dword_4FCB3C;
  if ( !dword_4FCB3C )
  {
    v7 = (int *)calloc(0x44u, 1u);
    v6 = v7;
    dword_4FCB3C = (int)v7;
    if ( !v7 )
    {
      sub_356C4(13, 255);
      if ( (unsigned int)dword_7EB9C <= 3 )
        return -1;
      strcpy(s, "Fail to allocate memory for send work context.\n");
      goto LABEL_13;
    }
    v7[2] = 0;
    v7[3] = 0;
    v7[4] = 0;
    v7[5] = 0;
  }
  *v6 = a1;
  if ( a1 == 160 )
    v6[1] = (int)sub_38450();
  else
    v6[1] = (int)sub_37574();
  return (*(int (__fastcall **)(const char *))(*(_DWORD *)(dword_4FCB3C + 4) + 4))(a2);
}
// 7EB9C: using guessed type int dword_7EB9C;
// 4FCB3C: using guessed type int dword_4FCB3C;

//----- (00038E40) --------------------------------------------------------
void sub_38E40()
{
  _DWORD *v0; // r0
  int v1; // r3
  char v2[2064]; // [sp+0h] [bp-810h] BYREF

  if ( (unsigned int)dword_7EB9C > 4 )
  {
    strcpy(v2, "[DEBUG] Pattern test exit.\n");
    sub_2E584(4, v2, 0);
    v0 = (_DWORD *)dword_4FCB3C;
    if ( !dword_4FCB3C )
    {
      if ( (unsigned int)dword_7EB9C <= 4 )
        return;
      goto LABEL_9;
    }
  }
  else
  {
    v0 = (_DWORD *)dword_4FCB3C;
    if ( !dword_4FCB3C )
      return;
  }
  v1 = v0[1];
  if ( v1 )
  {
    (*(void (**)(void))(v1 + 8))();
    if ( (unsigned int)dword_7EB9C <= 4 )
      goto LABEL_5;
    goto LABEL_9;
  }
  if ( (unsigned int)dword_7EB9C > 4 )
  {
LABEL_9:
    strcpy(v2, "[DEBUG] Free memory for pattern test.\n");
    sub_2E584(4, v2, 0);
LABEL_5:
    v0 = (_DWORD *)dword_4FCB3C;
    if ( !dword_4FCB3C )
      return;
  }
  free(v0);
  dword_4FCB3C = 0;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 4FCB3C: using guessed type int dword_4FCB3C;

//----- (00038F58) --------------------------------------------------------
int sub_38F58()
{
  int v0; // r3
  int result; // r0
  char v2[2056]; // [sp+0h] [bp-808h] BYREF

  if ( (unsigned int)dword_7EB9C > 4 )
  {
    strcpy(v2, "[DEBUG] Pattern test reset.\n");
    result = sub_2E584(4, v2, 0);
  }
  if ( dword_4FCB3C )
  {
    v0 = *(_DWORD *)(dword_4FCB3C + 4);
    if ( v0 )
      return (*(int (**)(void))(v0 + 16))();
  }
  if ( (unsigned int)dword_7EB9C > 3 )
  {
    strcpy(v2, "Handle is NULL.\n");
    return sub_2E584(3, v2, 0);
  }
  return result;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 4FCB3C: using guessed type int dword_4FCB3C;

//----- (00039018) --------------------------------------------------------
int sub_39018()
{
  int v0; // r2
  int result; // r0
  char v2[2056]; // [sp+0h] [bp-808h] BYREF

  if ( dword_4FCB3C && (v0 = *(_DWORD *)(dword_4FCB3C + 4)) != 0 )
  {
    if ( *(_DWORD *)(dword_4FCB3C + 64) )
      return (*(int (**)(void))(v0 + 20))();
  }
  else if ( (unsigned int)dword_7EB9C > 3 )
  {
    strcpy(v2, "Handle is NULL.\n");
    return sub_2E584(3, v2, 0);
  }
  return result;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 4FCB3C: using guessed type int dword_4FCB3C;

//----- (000390B0) --------------------------------------------------------
char *__fastcall sub_390B0(char *result)
{
  int v1; // r12
  bool v2; // cc
  int *v3; // r2
  char v4; // r1
  int v5; // r2

  v1 = dword_5945B8[0] + 1;
  v2 = dword_5945B8[0] > 0x1FDu;
  v3 = &dword_5945B8[2 * dword_5945B8[0] + 2];
  v3[1] = *((_DWORD *)result + 1);
  *((_BYTE *)v3 + 8) = result[3] & 0x1F;
  *((_BYTE *)v3 + 9) = result[2];
  *((_BYTE *)v3 + 10) = result[1];
  v4 = *result;
  if ( !v2 )
    dword_5945B8[0] = v1;
  *((_BYTE *)v3 + 11) = v4 & 0xF;
  if ( v2 )
    dword_5945B8[0] = 0;
  if ( (unsigned int)dword_5945C0 > 0x1FE )
    v5 = 511;
  else
    v5 = dword_5945C0 + 1;
  dword_5945C0 = v5;
  return result;
}
// 5945B8: using guessed type int dword_5945B8[];
// 5945C0: using guessed type int dword_5945C0;

//----- (00039128) --------------------------------------------------------
int __fastcall sub_39128(int result)
{
  char *v1; // r5
  char v2[2064]; // [sp+0h] [bp-810h] BYREF

  if ( dword_4FCB3C && *(_DWORD *)(dword_4FCB3C + 4) )
  {
    v1 = (char *)result;
    pthread_mutex_lock(&stru_810DC);
    if ( *(_DWORD *)(dword_4FCB3C + 64) )
      (*(void (__fastcall **)(char *))(*(_DWORD *)(dword_4FCB3C + 4) + 24))(v1);
    else
      sub_390B0(v1);
    return pthread_mutex_unlock(&stru_810DC);
  }
  else if ( (unsigned int)dword_7EB9C > 3 )
  {
    strcpy(v2, "Handle is NULL.\n");
    return sub_2E584(3, v2, 0);
  }
  return result;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 810DC: using guessed type pthread_mutex_t stru_810DC;
// 4FCB3C: using guessed type int dword_4FCB3C;

//----- (000391F4) --------------------------------------------------------
int sub_391F4()
{
  int v0; // r3
  char v2[2056]; // [sp+0h] [bp-808h] BYREF

  if ( (unsigned int)dword_7EB9C > 4 )
  {
    strcpy(v2, "[DEBUG] Get stats.\n");
    sub_2E584(4, v2, 0);
  }
  if ( dword_4FCB3C )
  {
    v0 = *(_DWORD *)(dword_4FCB3C + 4);
    if ( v0 )
      return (*(int (**)(void))(v0 + 32))();
  }
  if ( (unsigned int)dword_7EB9C > 3 )
  {
    strcpy(v2, "Handle is NULL.\n");
    sub_2E584(3, v2, 0);
  }
  return 0;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 4FCB3C: using guessed type int dword_4FCB3C;

//----- (000392B8) --------------------------------------------------------
int __fastcall sub_392B8(int a1)
{
  int v2; // r3
  char v4[2064]; // [sp+0h] [bp-810h] BYREF

  if ( (unsigned int)dword_7EB9C > 4 )
  {
    snprintf(v4, 0x800u, "[DEBUG] Check if chain is unbalance happen, chain = %d.\n", a1);
    sub_2E584(4, v4, 0);
  }
  if ( dword_4FCB3C )
  {
    v2 = *(_DWORD *)(dword_4FCB3C + 4);
    if ( v2 )
      return (*(int (__fastcall **)(int))(v2 + 36))(a1);
  }
  if ( (unsigned int)dword_7EB9C > 3 )
    return sub_388F4();
  return 1;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 4FCB3C: using guessed type int dword_4FCB3C;

//----- (00039360) --------------------------------------------------------
int sub_39360()
{
  int v0; // r4
  char v2[2056]; // [sp+0h] [bp-808h] BYREF

  if ( (unsigned int)dword_7EB9C > 4 )
  {
    strcpy(v2, "[DEBUG] Check if is unbalance happen.\n");
    sub_2E584(4, v2, 0);
  }
  v0 = 0;
  while ( !sub_1E29C(v0) || !sub_392B8(v0) )
  {
    if ( ++v0 == 4 )
      return 0;
  }
  return 1;
}
// 7EB9C: using guessed type int dword_7EB9C;

//----- (00039404) --------------------------------------------------------
int __fastcall sub_39404(int a1)
{
  float v1; // s0
  int result; // r0
  char s[2072]; // [sp+8h] [bp-818h] BYREF

  if ( (unsigned int)dword_7EB9C > 4 )
  {
    snprintf(
      s,
      0x800u,
      "[DEBUG] Check if chain is unqualified happen, chain = %d, nonce_rate_threshold = %.2f\n",
      a1,
      v1);
    sub_2E584(4, s, 0);
  }
  if ( dword_4FCB3C && *(_DWORD *)(dword_4FCB3C + 4) )
  {
    if ( *(float *)(dword_4FCB3C + 4 * a1 + 48) < v1 )
    {
      result = 1;
      *(_BYTE *)(dword_4FCB3C + a1 + 28) = 1;
    }
    else
    {
      return 0;
    }
  }
  else if ( (unsigned int)dword_7EB9C > 3 )
  {
    return sub_388F4();
  }
  else
  {
    return 1;
  }
  return result;
}
// 394BC: variable 'v1' is possibly undefined
// 7EB9C: using guessed type int dword_7EB9C;
// 4FCB3C: using guessed type int dword_4FCB3C;

//----- (000394D8) --------------------------------------------------------
int sub_394D8()
{
  int v0; // r4
  char v2[2064]; // [sp+0h] [bp-810h] BYREF

  if ( (unsigned int)dword_7EB9C > 4 )
  {
    strcpy(v2, "[DEBUG] check if is unqualified happen.\n");
    sub_2E584(4, v2, 0);
  }
  v0 = 0;
  while ( !sub_1E29C(v0) || !sub_39404(v0) )
  {
    if ( ++v0 == 4 )
      return 0;
  }
  return 1;
}
// 7EB9C: using guessed type int dword_7EB9C;

//----- (00039584) --------------------------------------------------------
int __fastcall sub_39584(int a1)
{
  int v2; // r3
  char v4[2064]; // [sp+0h] [bp-810h] BYREF

  if ( (unsigned int)dword_7EB9C > 4 )
  {
    snprintf(v4, 0x800u, "[DEBUG] Check if recv nonce enough, chain = %d.\n", a1);
    sub_2E584(4, v4, 0);
  }
  if ( dword_4FCB3C )
  {
    v2 = *(_DWORD *)(dword_4FCB3C + 4);
    if ( v2 )
      return (*(int (__fastcall **)(int))(v2 + 40))(a1);
  }
  if ( (unsigned int)dword_7EB9C > 3 )
    return sub_388F4();
  return 1;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 4FCB3C: using guessed type int dword_4FCB3C;

//----- (0003962C) --------------------------------------------------------
int __fastcall sub_3962C(int result, int a2)
{
  int v2; // r6
  const char *v4; // r3
  int v5; // r4
  char s[2072]; // [sp+8h] [bp-818h] BYREF

  v2 = result;
  if ( (unsigned int)dword_7EB9C > 3 )
  {
    if ( a2 )
    {
      if ( a2 == 1 )
      {
        v4 = "READY";
      }
      else
      {
        v4 = "DONE";
        if ( a2 != 2 )
          v4 = "UNKNOWN";
      }
    }
    else
    {
      v4 = "BLOCK";
    }
    snprintf(s, 0x800u, "chain = %d, status = %s\n", result, v4);
    result = sub_2E584(3, s, 0);
    if ( !dword_4FCB3C || !*(_DWORD *)(dword_4FCB3C + 4) )
    {
      if ( (unsigned int)dword_7EB9C > 3 )
      {
        strcpy(s, "Handle is NULL.\n");
        return sub_2E584(3, s, 0);
      }
      return result;
    }
LABEL_12:
    v5 = 0;
    while ( 1 )
    {
      result = sub_1E29C(v5);
      if ( result )
      {
        if ( v2 == 255 )
        {
          *(_DWORD *)(dword_4FCB3C + 4 * (v5 + 2)) = a2;
        }
        else if ( v2 == v5 )
        {
          *(_DWORD *)(dword_4FCB3C + 4 * (v2 + 2)) = a2;
          return result;
        }
      }
      if ( ++v5 == 4 )
        return result;
    }
  }
  if ( dword_4FCB3C && *(_DWORD *)(dword_4FCB3C + 4) )
    goto LABEL_12;
  return result;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 4FCB3C: using guessed type int dword_4FCB3C;

//----- (000397A0) --------------------------------------------------------
int __fastcall sub_397A0(int a1)
{
  int v2; // r2
  int v3; // r2
  const char *v4; // r3
  char s[2064]; // [sp+8h] [bp-810h] BYREF

  v2 = dword_4FCB3C;
  if ( (unsigned int)dword_7EB9C > 4 )
  {
    v3 = *(_DWORD *)(dword_4FCB3C + 4 * (a1 + 2));
    if ( v3 )
    {
      if ( v3 == 1 )
      {
        v4 = "READY";
      }
      else
      {
        v4 = "UNKNOWN";
        if ( v3 == 2 )
          v4 = "DONE";
      }
    }
    else
    {
      v4 = "BLOCK";
    }
    snprintf(s, 0x800u, "[DEBUG] chain = %d, status = %s\n", a1, v4);
    sub_2E584(4, s, 0);
    v2 = dword_4FCB3C;
  }
  if ( v2 && *(_DWORD *)(v2 + 4) )
    return *(_DWORD *)(v2 + 4 * (a1 + 2));
  if ( (unsigned int)dword_7EB9C > 3 )
  {
    strcpy(s, "Handle is NULL.\n");
    sub_2E584(3, s, 0);
  }
  return 2;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 4FCB3C: using guessed type int dword_4FCB3C;

//----- (000398BC) --------------------------------------------------------
int sub_398BC()
{
  int v0; // r3
  int result; // r0
  char v2[2056]; // [sp+0h] [bp-808h] BYREF

  if ( (unsigned int)dword_7EB9C > 4 )
  {
    strcpy(v2, "[DEBUG] Clear stats.\n");
    result = sub_2E584(4, v2, 0);
  }
  if ( dword_4FCB3C )
  {
    v0 = *(_DWORD *)(dword_4FCB3C + 4);
    if ( v0 )
      return (*(int (**)(void))(v0 + 12))();
  }
  if ( (unsigned int)dword_7EB9C > 3 )
    return sub_387F8();
  return result;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 4FCB3C: using guessed type int dword_4FCB3C;

//----- (00039954) --------------------------------------------------------
int sub_39954()
{
  int v0; // r4

  v0 = 0;
  while ( !sub_1E29C(v0) || sub_397A0(v0) )
  {
    if ( ++v0 == 4 )
      return 0;
  }
  return 1;
}

//----- (00039998) --------------------------------------------------------
int sub_39998()
{
  int v0; // r4
  int result; // r0

  v0 = 0;
  while ( 1 )
  {
    if ( sub_1E29C(v0) )
    {
      result = sub_397A0(v0);
      if ( result == 1 )
        break;
    }
    if ( ++v0 == 4 )
      return 0;
  }
  return result;
}

//----- (000399D8) --------------------------------------------------------
int __fastcall sub_399D8(unsigned int a1)
{
  unsigned int v2; // r5
  int i; // r4
  bool v4; // zf
  int result; // r0
  char v6[2064]; // [sp+0h] [bp-810h] BYREF

  if ( (unsigned int)dword_7EB9C > 4 )
  {
    snprintf(v6, 0x800u, "[DEBUG] Set chain serial, chain_serial_count = %d.\n", a1);
    sub_2E584(4, v6, 0);
  }
  v2 = 0;
  for ( i = 0; i != 4; ++i )
  {
    v4 = sub_1E29C(i) == 0;
    result = i;
    if ( !v4 )
    {
      if ( a1 <= v2 )
        return result;
      result = sub_397A0(i);
      if ( !result )
      {
        ++v2;
        result = sub_3962C(i, 1);
      }
    }
  }
  return result;
}
// 7EB9C: using guessed type int dword_7EB9C;

//----- (00039A7C) --------------------------------------------------------
int sub_39A7C()
{
  _DWORD *v0; // r3
  int result; // r0
  char v2[2056]; // [sp+0h] [bp-808h] BYREF

  if ( (unsigned int)dword_7EB9C > 4 )
  {
    strcpy(v2, "[DEBUG] Clear ctxt.\n");
    result = sub_2E584(4, v2, 0);
  }
  v0 = (_DWORD *)dword_4FCB3C;
  if ( dword_4FCB3C && *(_DWORD *)(dword_4FCB3C + 4) )
  {
    *(_DWORD *)(dword_4FCB3C + 24) = 0;
    v0[7] = 0;
    v0[8] = 0;
    v0[9] = 0;
    v0[10] = 0;
    v0[11] = 0;
    v0[12] = 0;
    v0[13] = 0;
    v0[14] = 0;
    v0[15] = 0;
  }
  else if ( (unsigned int)dword_7EB9C > 3 )
  {
    strcpy(v2, "Handle is NULL.\n");
    return sub_2E584(3, v2, 0);
  }
  return result;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 4FCB3C: using guessed type int dword_4FCB3C;

//----- (00039B60) --------------------------------------------------------
int __fastcall sub_39B60(int a1)
{
  float v1; // s0
  float v2; // s1
  float v3; // s2
  int v5; // r8
  int v6; // r9
  int v7; // r5
  int v8; // r5
  unsigned int v10; // s16
  int v11; // r5
  int v12; // r0
  int v13; // r9
  unsigned int v14; // r3
  float v15; // s13
  float v16; // s12
  float v17; // s14
  char s[2096]; // [sp+18h] [bp-830h] BYREF

  v5 = sub_391F4();
  if ( (unsigned int)dword_7EB9C > 4 )
  {
    snprintf(
      s,
      0x800u,
      "[DEBUG] Check if is need stop, chain = %d, hw_threshold = %.4f, nonce_rate_threshold = %.2f, nonce_rate_dec_threshold = %.2f.\n",
      a1,
      v1,
      v2,
      v3);
    sub_2E584(4, s, 0);
  }
  if ( dword_4FCB3C && *(_DWORD *)(dword_4FCB3C + 4) )
  {
    v6 = 4 * a1;
    v7 = 8 * sub_1E130();
    v8 = sub_1E0F0() * v7;
    if ( *(_DWORD *)(v5 + 4 * a1 + 8431696) > (unsigned int)(float)((float)v8 * v1) )
    {
      if ( (unsigned int)dword_7EB9C > 3 )
      {
        snprintf(
          s,
          0x800u,
          "chain = %d, hw = %d, hw_threshold = %d, too much hw.\n",
          a1,
          *(_DWORD *)(v5 + v6 + 8431696),
          (unsigned int)(float)((float)v8 * v1));
        sub_2E584(3, s, 0);
      }
      return 1;
    }
    v10 = *(_DWORD *)(v5 + 4 * a1 + 8429568);
    v11 = 8 * sub_1E130();
    v12 = sub_1E0F0();
    v13 = dword_4FCB3C + v6;
    v14 = dword_7EB9C;
    v15 = *(float *)(v13 + 48);
    v16 = *(float *)(v13 + 32);
    v17 = (float)v10 / (float)(v12 * v11);
    *(float *)(v13 + 32) = v17;
    if ( v15 < v17 )
      *(float *)(v13 + 48) = v17;
    if ( v14 > 3 )
    {
      snprintf(
        s,
        0x800u,
        "chain = %d, nonce_rate_curr = %.4f, nonce_rate_last = %.4f, nonce_rate_max = %.4f\n",
        a1,
        v17,
        v16,
        *(float *)(v13 + 48));
      sub_2E584(3, s, 0);
    }
    return 0;
  }
  else
  {
    if ( (unsigned int)dword_7EB9C <= 3 )
      return 1;
    strcpy(s, "Handle is NULL.\n");
    sub_2E584(3, s, 0);
    return 1;
  }
}
// 39C90: variable 'v1' is possibly undefined
// 39C94: variable 'v2' is possibly undefined
// 39C8C: variable 'v3' is possibly undefined
// 7EB9C: using guessed type int dword_7EB9C;
// 4FCB3C: using guessed type int dword_4FCB3C;

//----- (00039D88) --------------------------------------------------------
int sub_39D88()
{
  int v0; // r4
  int v1; // r0
  int v2; // r3
  char v4[2064]; // [sp+0h] [bp-810h] BYREF

  if ( (unsigned int)dword_7EB9C > 4 )
  {
    strcpy(v4, "[DEBUG] Check if all chain pattern test done.\n");
    sub_2E584(4, v4, 0);
  }
  if ( dword_4FCB3C && *(_DWORD *)(dword_4FCB3C + 4) )
  {
    v0 = 0;
    while ( 1 )
    {
      v1 = sub_1E29C(v0);
      v2 = v0 + 2;
      ++v0;
      if ( v1 )
      {
        if ( *(_DWORD *)(dword_4FCB3C + 4 * v2) != 2 )
          break;
      }
      if ( v0 == 4 )
        return 1;
    }
    return 0;
  }
  else if ( (unsigned int)dword_7EB9C <= 3 )
  {
    return 1;
  }
  else
  {
    strcpy(v4, "Handle is NULL.\n");
    sub_2E584(3, v4, 0);
    return 1;
  }
}
// 7EB9C: using guessed type int dword_7EB9C;
// 4FCB3C: using guessed type int dword_4FCB3C;

//----- (00039EA0) --------------------------------------------------------
int sub_39EA0()
{
  int v0; // r4
  int v1; // r0
  int v2; // r3
  char v4[2064]; // [sp+0h] [bp-810h] BYREF

  if ( (unsigned int)dword_7EB9C > 4 )
  {
    strcpy(v4, "[DEBUG] Check if all chain pattern test done except block.\n");
    sub_2E584(4, v4, 0);
  }
  if ( dword_4FCB3C && *(_DWORD *)(dword_4FCB3C + 4) )
  {
    v0 = 0;
    while ( 1 )
    {
      v1 = sub_1E29C(v0);
      v2 = v0 + 2;
      ++v0;
      if ( v1 )
      {
        if ( (*(_DWORD *)(dword_4FCB3C + 4 * v2) & 0xFFFFFFFD) != 0 )
          break;
      }
      if ( v0 == 4 )
        return 1;
    }
    return 0;
  }
  else if ( (unsigned int)dword_7EB9C <= 3 )
  {
    return 1;
  }
  else
  {
    strcpy(v4, "Handle is NULL.\n");
    sub_2E584(3, v4, 0);
    return 1;
  }
}
// 7EB9C: using guessed type int dword_7EB9C;
// 4FCB3C: using guessed type int dword_4FCB3C;

//----- (00039FB4) --------------------------------------------------------
int __fastcall sub_39FB4(int a1)
{
  int i; // r4
  int v2; // r4
  char v4[2056]; // [sp+0h] [bp-808h] BYREF

  if ( (unsigned int)dword_7EB9C > 4 )
  {
    snprintf(v4, 0x800u, "[DEBUG] Board init, is_power_off = %d.\n", a1);
    sub_2E584(4, v4, 0);
  }
  for ( i = 0; i != 4; ++i )
  {
    if ( sub_1E29C(i) )
      sub_4FA0C((unsigned __int8)i);
  }
  sub_3345C();
  v2 = sub_33E34();
  sub_304D4();
  sub_281B8();
  sub_304D4();
  return v2;
}
// 7EB9C: using guessed type int dword_7EB9C;

//----- (0003A054) --------------------------------------------------------
char *__fastcall sub_3A054(char *result, int a2)
{
  char *v2; // r7
  char *v4; // r8
  unsigned int v5; // r3
  unsigned int v6; // r4
  int v7; // r0
  int v8; // r1
  unsigned int v9; // r8
  int v10; // r10
  unsigned int i; // r4
  int v12; // r4
  int v13; // r0
  unsigned int v14; // s16
  int v15; // r4
  int v16; // r0
  char s[2096]; // [sp+18h] [bp-830h] BYREF

  if ( !dword_4FCB3C || !*(_DWORD *)(dword_4FCB3C + 4) )
  {
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      strcpy(s, "Handle is NULL.\n");
      return (char *)sub_2E584(3, s, 0);
    }
    return result;
  }
  v2 = result;
  if ( (unsigned int)dword_7EB9C > 3 )
  {
    snprintf(s, 0x800u, "chain %d stats:\n", result);
    sub_2EA54(3, s, 0);
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      v12 = sub_1E130();
      v13 = sub_1E0F0();
      snprintf(s, 0x800u, "%-30s : %d\n", "send_nonce_num", v13 * 8 * v12);
      sub_2EA54(3, s, 0);
      if ( (unsigned int)dword_7EB9C <= 3 )
        goto LABEL_4;
      snprintf(s, 0x800u, "%-30s : %d\n", "recv_nonce_num", *(_DWORD *)(a2 + 4 * (_DWORD)(v2 + 2107392)));
      sub_2EA54(3, s, 0);
      if ( (unsigned int)dword_7EB9C <= 3 )
        goto LABEL_39;
      v14 = *(_DWORD *)(a2 + 4 * (_DWORD)(v2 + 2107392));
      v15 = sub_1E130();
      v16 = sub_1E0F0();
      snprintf(s, 0x800u, "%-30s : %f\n", "nonce_return_rate", (float)((float)v14 / (float)(v16 * 8 * v15)));
      sub_2EA54(3, s, 0);
      if ( (unsigned int)dword_7EB9C <= 3 )
        goto LABEL_4;
      snprintf(s, 0x800u, "%-30s : %d\n", "nonce_num_repeated", *(_DWORD *)(a2 + 4 * ((int)&unk_202A04 + (_DWORD)v2)));
      sub_2EA54(3, s, 0);
    }
    if ( (unsigned int)dword_7EB9C <= 3 )
      goto LABEL_42;
    snprintf(
      s,
      0x800u,
      "%-30s : %d\n",
      "nonce_num_top_check_fail",
      *(_DWORD *)(a2 + 4 * ((int)&unk_202A08 + (_DWORD)v2)));
    sub_2EA54(3, s, 0);
    if ( (unsigned int)dword_7EB9C <= 3 )
      goto LABEL_4;
    snprintf(s, 0x800u, "%-30s : %d\n", "nonce_num_crc_err", *(_DWORD *)(a2 + 4 * ((int)&unk_202A0C + (_DWORD)v2)));
    sub_2EA54(3, s, 0);
LABEL_39:
    if ( (unsigned int)dword_7EB9C <= 3 )
      goto LABEL_45;
    snprintf(s, 0x800u, "%-30s : %d\n", "nonce_num_invalid", *(_DWORD *)(a2 + 4 * ((int)&unk_202A10 + (_DWORD)v2)));
    sub_2EA54(3, s, 0);
    if ( (unsigned int)dword_7EB9C <= 3 )
      goto LABEL_4;
    snprintf(s, 0x800u, "%-30s : %d\n", "nonce_num_hw", *(_DWORD *)(a2 + 4 * ((int)&unk_202A14 + (_DWORD)v2)));
    sub_2EA54(3, s, 0);
LABEL_42:
    if ( (unsigned int)dword_7EB9C <= 3 )
      goto LABEL_48;
    snprintf(s, 0x800u, "%-30s : %d\n", "nonce_num_extra", *(_DWORD *)(a2 + 4 * ((int)&unk_202A18 + (_DWORD)v2)));
    sub_2EA54(3, s, 0);
    if ( (unsigned int)dword_7EB9C <= 3 )
      goto LABEL_4;
    snprintf(s, 0x800u, "%-30s : %d\n", "nonce_num_unknown_err", *(_DWORD *)(a2 + 4 * ((int)&unk_202A1C + (_DWORD)v2)));
    sub_2EA54(3, s, 0);
LABEL_45:
    if ( (unsigned int)dword_7EB9C <= 3 )
      goto LABEL_51;
    snprintf(s, 0x800u, "%-30s : %d\n", "invalid_asic_num", *(_DWORD *)(a2 + 4 * ((int)&unk_202A20 + (_DWORD)v2) + 4));
    sub_2EA54(3, s, 0);
    if ( (unsigned int)dword_7EB9C <= 3 )
      goto LABEL_4;
    snprintf(s, 0x800u, "%-30s : %d\n", "invalid_chain_num", *(_DWORD *)(a2 + 8431744));
    sub_2EA54(3, s, 0);
LABEL_48:
    if ( (unsigned int)dword_7EB9C <= 3 )
      goto LABEL_4;
    snprintf(s, 0x800u, "%-30s : %.2f\n", "stddev", *(float *)(a2 + 4 * ((int)&unk_202A24 + (_DWORD)v2) + 4));
    sub_2EA54(3, s, 0);
    if ( (unsigned int)dword_7EB9C <= 3 )
      goto LABEL_4;
    strcpy(s, "\n");
    sub_2EA54(3, s, 0);
LABEL_51:
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      snprintf(s, 0x800u, "Chain %d nonce:\n", v2);
      sub_2E584(3, s, 0);
    }
  }
LABEL_4:
  result = (char *)sub_1E0F0();
  v4 = result;
  v5 = dword_7EB9C;
  if ( result )
  {
    v6 = 0;
    do
    {
      if ( v5 > 3 )
      {
        snprintf(s, 0x800u, "IC[%03d]:%04d ", v6, *(_DWORD *)(a2 + ((_DWORD)v2 << 10) + 4 * v6 + 8425472));
        sub_2EA54(3, s, 0);
      }
      ++v6;
      v7 = sub_1E100();
      result = (char *)sub_5FADC(v6, v7);
      v5 = dword_7EB9C;
      if ( !v8 && (unsigned int)dword_7EB9C > 3 )
      {
        strcpy(s, "\n");
        result = sub_2EA54(3, s, 0);
        v5 = dword_7EB9C;
      }
    }
    while ( (char *)v6 != v4 );
  }
  if ( v5 > 3 )
  {
    strcpy(s, "\n");
    result = sub_2EA54(3, s, 0);
    if ( *(_DWORD *)dword_4FCB3C == 161 )
      return result;
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      snprintf(s, 0x800u, "Chain %d domain:\n", v2);
      sub_2EA54(3, s, 0);
    }
  }
  else if ( *(_DWORD *)dword_4FCB3C == 161 )
  {
    return result;
  }
  v9 = 0;
  result = (char *)sub_1E0E0();
  if ( result )
  {
    while ( 1 )
    {
      v10 = v9 * sub_1E150();
      for ( i = 0; sub_1E150() > i; ++i )
      {
        if ( (unsigned int)dword_7EB9C > 3 )
        {
          snprintf(
            s,
            0x800u,
            "D[%02d]:%04d ",
            i + v10,
            *(_DWORD *)((char *)&dword_80A010[64 * (_DWORD)v2 + v10 + i] + a2));
          sub_2EA54(3, s, 0);
        }
      }
      if ( sub_1E150() <= 1 )
        goto LABEL_28;
      if ( (unsigned int)dword_7EB9C > 3 )
        break;
LABEL_24:
      ++v9;
      result = (char *)sub_1E0E0();
      if ( (unsigned int)result <= v9 )
        goto LABEL_25;
    }
    snprintf(s, 0x800u, "D_BIG[%02d]:%05d", v9, *(_DWORD *)((char *)&dword_80A410[64 * (_DWORD)v2 + v9] + a2));
    sub_2EA54(3, s, 0);
LABEL_28:
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      strcpy(s, "\n");
      sub_2EA54(3, s, 0);
    }
    goto LABEL_24;
  }
LABEL_25:
  if ( (unsigned int)dword_7EB9C > 3 )
  {
    strcpy(s, "\n\n");
    return sub_2EA54(3, s, 0);
  }
  return result;
}
// 3A0E0: variable 'v8' is possibly undefined
// 7EB9C: using guessed type int dword_7EB9C;
// 4FCB3C: using guessed type int dword_4FCB3C;
// 80A010: using guessed type _DWORD dword_80A010[256];
// 80A410: using guessed type _DWORD dword_80A410[289];

//----- (0003A828) --------------------------------------------------------
int sub_3A828()
{
  int v0; // r4

  v0 = 8 * sub_1E130();
  return sub_1E0F0() * v0;
}

//----- (0003A86C) --------------------------------------------------------
int __fastcall sub_3A86C(int result)
{
  int v1; // s0
  int v2; // r4
  int v3; // r0
  int v4; // r2
  int i; // r4
  int v6; // r11
  int v7; // r7
  int v8; // r3
  int v9; // r5
  int v10; // r0
  unsigned int v11; // r9
  int v12; // r10
  int v13; // r5
  char *v14; // r11
  int v15; // r4
  unsigned int v16; // r8
  int v17; // r0
  unsigned int v18; // r0
  int v19; // t1
  int v20; // r0
  int v22; // r0
  int v23; // r12
  int v24; // lr
  _DWORD *v25; // r3
  int v26; // [sp+0h] [bp-868h]
  unsigned int v27; // [sp+8h] [bp-860h]
  int v28; // [sp+10h] [bp-858h]
  int v29; // [sp+14h] [bp-854h]
  int v30; // [sp+1Ch] [bp-84Ch]
  __time_t v31; // [sp+30h] [bp-838h] BYREF
  int v32; // [sp+34h] [bp-834h]
  __time_t v33[2]; // [sp+38h] [bp-830h] BYREF
  char v34[2088]; // [sp+40h] [bp-828h] BYREF

  if ( dword_4FCB3C && *(_DWORD *)(dword_4FCB3C + 4) )
  {
    v2 = result;
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      strcpy(v34, "Pattern test start...\n");
      sub_2E584(3, v34, 0);
    }
    sub_302A0(&v31);
    sub_398BC();
    v3 = sub_452B0();
    sub_452D0(v3 | 0x10000);
    v4 = *(_DWORD *)dword_4FCB3C;
    *(_DWORD *)(dword_4FCB3C + 64) = 1;
    if ( v4 == 161 )
      sub_3893C(v2);
    else
      sub_389F0(v2);
    for ( i = 0; i != 4; ++i )
    {
      if ( sub_1E29C(i) && *(_DWORD *)(dword_4FCB3C + 4 * (i + 2)) == 1 )
      {
        v9 = 3;
        do
        {
          if ( sub_39584(i) )
            break;
          usleep((__useconds_t)&loc_186A0);
          --v9;
        }
        while ( v9 );
      }
    }
    v6 = 0;
    *(_DWORD *)(dword_4FCB3C + 64) = 0;
    v7 = sub_391F4();
    do
    {
      if ( sub_1E29C(v6) && *(_DWORD *)(dword_4FCB3C + 4 * (v6 + 2)) == 1 )
      {
        v28 = sub_1E0F0();
        if ( v28 )
        {
          v29 = v6;
          v30 = v6 << 8;
          v26 = v6 << 6;
          v27 = 0;
          do
          {
            v10 = sub_1E100();
            v11 = sub_5F880(v27, v10);
            v12 = sub_1E130();
            if ( v12 )
            {
              v13 = 0;
              v14 = (char *)&unk_408FFC + 4096 * (v27 + v30) + v7;
              do
              {
                v15 = v11 * sub_1E150();
                v16 = v13 * sub_1E150();
                ++v13;
                v17 = sub_1E130();
                v18 = sub_5F880(v16, v17);
                v19 = *((_DWORD *)v14 + 1);
                v14 += 4;
                v20 = v7 + 4 * (v18 + v15 + v26) + 8429568;
                *(_DWORD *)(v20 + 16) += v19;
                *(_DWORD *)(v7 + 4 * (v11 + v26) + 8430608) += v19;
                ++*(_DWORD *)(v7 + 4 * (9 * v27 + 2304 * v29 + v19) + 0x400000);
              }
              while ( v12 != v13 );
            }
          }
          while ( v28 != ++v27 );
          v6 = v29;
        }
        v22 = sub_1E0F0();
        if ( v22 )
        {
          v23 = v7 + 0x400000 + 9216 * v6;
          v24 = v23 + 36 * v22;
          do
          {
            v25 = (_DWORD *)v23;
            do
            {
              v25[1] += *v25;
              ++v25;
            }
            while ( v25 != (_DWORD *)(v23 + 32) );
            v23 += 36;
          }
          while ( v23 != v24 );
        }
        sub_38B6C(v6, v7);
        *(_DWORD *)((char *)&dword_80A894[v6] + v7) = v1;
      }
      ++v6;
    }
    while ( v6 != 4 );
    sub_302A0(v33);
    result = v32;
    v8 = v33[0] - v31;
    if ( v33[1] - v32 < 0 )
      --v8;
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      snprintf(v34, 0x800u, "Pattern test done, time cost %lds\n", v8);
      return sub_2E584(3, v34, 0);
    }
  }
  else if ( (unsigned int)dword_7EB9C > 3 )
  {
    strcpy(v34, "Handle is NULL.\n");
    return sub_2E584(3, v34, 0);
  }
  return result;
}
// 3ABE4: variable 'v1' is possibly undefined
// 7EB9C: using guessed type int dword_7EB9C;
// 4FCB3C: using guessed type int dword_4FCB3C;
// 80A894: using guessed type _DWORD dword_80A894[4];

//----- (0003AC6C) --------------------------------------------------------
int sub_3AC6C()
{
  int v0; // r4

  v0 = sub_36204();
  if ( v0 == sub_361F4() )
    return 0;
  else
    return sub_36208();
}

//----- (0003AC94) --------------------------------------------------------
int sub_3AC94()
{
  char v1[2072]; // [sp+0h] [bp-818h] BYREF

  if ( (unsigned int)dword_7EB9C > 4 )
  {
    strcpy(v1, "[DEBUG] Freq tuning basic init.\n");
    sub_2E584(4, v1, 0);
    if ( (unsigned int)dword_7EB9C > 4 )
    {
      strcpy(v1, "[DEBUG] Allocate memory for freq tuning basic.\n");
      sub_2E584(4, v1, 0);
    }
  }
  if ( dword_4FCB40 )
    return 0;
  dword_4FCB40 = (int)calloc(0x34u, 1u);
  if ( dword_4FCB40 )
    return 0;
  sub_356C4(13, 255);
  if ( (unsigned int)dword_7EB9C > 3 )
  {
    strcpy(v1, "Fail to allocate memory for freq tuning basic context.\n");
    sub_2E584(3, v1, 0);
  }
  return -1;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 4FCB40: using guessed type int dword_4FCB40;

//----- (0003ADCC) --------------------------------------------------------
void sub_3ADCC()
{
  char v0[2056]; // [sp+0h] [bp-808h] BYREF

  if ( (unsigned int)dword_7EB9C > 4 )
  {
    strcpy(v0, "[DEBUG] Freq tuning basic exit.\n");
    sub_2E584(4, v0, 0);
    if ( (unsigned int)dword_7EB9C > 4 )
    {
      strcpy(v0, "[DEBUG] Free memory for freq tuning basic.\n");
      sub_2E584(4, v0, 0);
    }
  }
  if ( dword_4FCB40 )
  {
    free((void *)dword_4FCB40);
    dword_4FCB40 = 0;
  }
}
// 7EB9C: using guessed type int dword_7EB9C;
// 4FCB40: using guessed type int dword_4FCB40;

//----- (0003AE88) --------------------------------------------------------
int __fastcall sub_3AE88(int a1)
{
  return *(_DWORD *)(dword_4FCB40 + 4 * a1 + 20);
}
// 4FCB40: using guessed type int dword_4FCB40;

//----- (0003AEA0) --------------------------------------------------------
int __fastcall sub_3AEA0(int a1)
{
  char v3[2056]; // [sp+0h] [bp-808h] BYREF

  if ( (unsigned int)dword_7EB9C > 4 )
  {
    snprintf(v3, 0x800u, "[DEBUG] Get freq result, chain = %d.\n", a1);
    sub_2E584(4, v3, 0);
  }
  return *(_DWORD *)(dword_4FCB40 + 4 * a1 + 4);
}
// 7EB9C: using guessed type int dword_7EB9C;
// 4FCB40: using guessed type int dword_4FCB40;

//----- (0003AF04) --------------------------------------------------------
int __fastcall sub_3AF04(int a1)
{
  return dword_4FCB40 + 4 * a1;
}
// 4FCB40: using guessed type int dword_4FCB40;

//----- (0003AF1C) --------------------------------------------------------
void sub_3AF1C()
{
  unsigned int v0; // r3
  const char *v1; // r6
  const char *v2; // r12
  char s[2072]; // [sp+8h] [bp-818h] BYREF

  if ( (unsigned int)dword_7EB9C <= 3 )
    return;
  snprintf(s, 0x800u, "%-40s : %d\n", "voltage", **(_DWORD **)dword_4FCB40);
  sub_2EA54(3, s, 0);
  if ( (unsigned int)dword_7EB9C > 3 )
  {
    snprintf(s, 0x800u, "%-40s : %d\n", "freq_base", *(_DWORD *)(*(_DWORD *)dword_4FCB40 + 4));
    sub_2EA54(3, s, 0);
    if ( (unsigned int)dword_7EB9C <= 3 )
      return;
    snprintf(s, 0x800u, "%-40s : %d\n", "freq_threshold", *(_DWORD *)(*(_DWORD *)dword_4FCB40 + 8));
    sub_2EA54(3, s, 0);
    if ( (unsigned int)dword_7EB9C <= 3 )
      goto LABEL_16;
    snprintf(s, 0x800u, "%-40s : %d\n", "freq_serial_threshold", *(_DWORD *)(*(_DWORD *)dword_4FCB40 + 12));
    sub_2EA54(3, s, 0);
    if ( (unsigned int)dword_7EB9C <= 3 )
      return;
    snprintf(s, 0x800u, "%-40s : %d\n", "freq_step", *(_DWORD *)(*(_DWORD *)dword_4FCB40 + 16));
    sub_2EA54(3, s, 0);
  }
  v0 = dword_7EB9C;
  if ( (unsigned int)dword_7EB9C <= 3 )
  {
LABEL_19:
    if ( v0 > 3 )
    {
      snprintf(s, 0x800u, "%-40s : %.2f\n", "nonce_rate_threshold", *(float *)(*(_DWORD *)dword_4FCB40 + 32));
      sub_2EA54(3, s, 0);
      if ( (unsigned int)dword_7EB9C > 3 )
      {
        snprintf(s, 0x800u, "%-40s : %.2f\n", "nonce_rate_dec_threshold", *(float *)(*(_DWORD *)dword_4FCB40 + 36));
        sub_2EA54(3, s, 0);
      }
    }
    return;
  }
  v1 = "false";
  if ( *(_BYTE *)(*(_DWORD *)dword_4FCB40 + 20) )
    v2 = "true";
  else
    v2 = "false";
  snprintf(s, 0x800u, "%-40s : %s\n", "is_inc_freq_with_high_vol", v2);
  sub_2EA54(3, s, 0);
  if ( (unsigned int)dword_7EB9C > 3 )
  {
    if ( *(_BYTE *)(*(_DWORD *)dword_4FCB40 + 21) )
      v1 = "true";
    snprintf(s, 0x800u, "%-40s : %s\n", "is_inc_freq_with_high_vol_runtime", v1);
    sub_2EA54(3, s, 0);
LABEL_16:
    if ( (unsigned int)dword_7EB9C <= 3 )
      return;
    snprintf(s, 0x800u, "%-40s : %d\n", "is_board_init_with_power_off", *(_DWORD *)(*(_DWORD *)dword_4FCB40 + 24));
    sub_2EA54(3, s, 0);
    if ( (unsigned int)dword_7EB9C <= 3 )
      return;
    snprintf(s, 0x800u, "%-40s : %.4f\n", "hw_threshold", *(float *)(*(_DWORD *)dword_4FCB40 + 28));
    sub_2EA54(3, s, 0);
    v0 = dword_7EB9C;
    goto LABEL_19;
  }
}
// 7EB9C: using guessed type int dword_7EB9C;
// 4FCB40: using guessed type int dword_4FCB40;

//----- (0003B298) --------------------------------------------------------
char *__fastcall sub_3B298(int a1)
{
  _DWORD *v2; // r4
  char *v3; // r4
  int i; // r4
  char *v6; // r8
  int v7; // r5
  int v8; // r0
  int j; // r4
  int v10; // r11
  int k; // r4
  int v12; // r9
  char **v13; // r11
  char **v14; // r10
  int v15; // r0
  char *v16; // r2
  char *v17; // r3
  int v18; // r8
  int v19; // r1
  float *v20; // r2
  int v21; // r3
  float v22; // s12
  bool v23; // cc
  char *v24; // r0
  float v25; // s0
  int v26; // r3
  char *v27; // [sp+10h] [bp-980h]
  int v28; // [sp+14h] [bp-97Ch]
  char *v29[76]; // [sp+28h] [bp-968h] BYREF
  char s[2040]; // [sp+158h] [bp-838h] BYREF

  if ( (unsigned int)dword_7EB9C > 3 )
  {
    strcpy(s, "Do freq tuning basic.\n");
    sub_2E584(3, s, 0);
  }
  v2 = (_DWORD *)dword_4FCB40;
  memset((void *)(dword_4FCB40 + 4), 0, 0x30u);
  *v2 = a1;
  sub_39A7C();
  sub_361E4(**(_DWORD **)dword_4FCB40);
  v3 = (char *)sub_3AC6C();
  if ( !v3 )
  {
    sub_1A470(255, (unsigned __int8)byte_482A70, *(unsigned __int8 *)(*(_DWORD *)dword_4FCB40 + 20));
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      strcpy(s, "\n");
      sub_2EA54(3, s, 0);
      if ( (unsigned int)dword_7EB9C > 3 )
      {
        strcpy(s, ">>>> Do tuning parallel.\n");
        sub_2E584(3, s, 0);
      }
    }
    for ( i = 0; i != 4; ++i )
    {
      if ( sub_1E29C(i) )
        sub_3962C(i, 1);
    }
    v6 = *(char **)(*(_DWORD *)dword_4FCB40 + 4);
    v28 = *(_DWORD *)(*(_DWORD *)dword_4FCB40 + 16);
    v27 = *(char **)(*(_DWORD *)dword_4FCB40 + 12);
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      snprintf(
        s,
        0x800u,
        "freq_prev = %d, freq_start = %d, freq_step = %d, freq_min = %d\n",
        v6,
        v6,
        v28,
        *(_DWORD *)(*(_DWORD *)dword_4FCB40 + 12));
      sub_2E584(3, s, 0);
    }
    v29[0] = v6;
    if ( v6 < v27 )
    {
      v7 = 0;
      v3 = 0;
    }
    else
    {
      v7 = 0;
      while ( 1 )
      {
        if ( (unsigned int)dword_7EB9C <= 3 || (strcpy(s, "\n"), sub_2EA54(3, s, 0), (unsigned int)dword_7EB9C <= 3) )
        {
          v8 = sub_39998();
          if ( !v8 )
            goto LABEL_59;
        }
        else
        {
          snprintf(s, 0x800u, ">>>> freq_curr = %d\n", v29[0]);
          sub_2E584(3, s, 0);
          v8 = sub_39998();
          if ( !v8 )
          {
LABEL_59:
            v3 = (char *)v8;
            if ( (unsigned int)dword_7EB9C > 3 )
            {
              strcpy(s, "All ready chain done, exit.\n");
              sub_2E584(3, s, v8);
            }
            goto LABEL_36;
          }
        }
        for ( j = 0; j != 4; ++j )
        {
          if ( sub_1E29C(j) && sub_397A0(j) == 1 )
            sub_1AAE4(
              j,
              (unsigned __int8)byte_482A70,
              (unsigned int)v6,
              v29[0],
              *(_BYTE *)(*(_DWORD *)dword_4FCB40 + 21));
        }
        v6 = v29[0];
        v3 = (char *)sub_3AC6C();
        if ( v3 )
          break;
        sub_321B8((int)v29[0], dword_7EB58, 20);
        sub_3A86C((int)v29);
        v10 = sub_391F4();
        do
        {
          if ( sub_1E29C((int)v3) && sub_397A0((int)v3) == 1 )
            sub_3A054(v3, v10);
          ++v3;
        }
        while ( v3 != (char *)4 );
        for ( k = 0; k != 4; ++k )
        {
          if ( sub_1E29C(k) && sub_397A0(k) == 1 )
          {
            v25 = *(float *)(*(_DWORD *)dword_4FCB40 + 28);
            if ( sub_39B60(k) )
              sub_3962C(k, 2);
            else
              *(_DWORD *)(dword_4FCB40 + 4 * k + 20) = 1;
            sub_3A828();
            v26 = dword_4FCB40 + 4 * k;
            if ( v25 > *(float *)(v26 + 36) )
              *(float *)(v26 + 36) = v25;
          }
        }
        v12 = 0;
        v13 = (char **)((char *)dword_80A894 + v10);
        v14 = &v29[4 * v7 + 16];
        do
        {
          v15 = sub_1E29C(v12++);
          if ( v15 )
            v17 = *v13;
          ++v14;
          if ( v15 )
            v16 = v29[0];
          ++v13;
          if ( v15 )
          {
            *(v14 - 1) = v17;
            v29[v7 + 1] = v16;
          }
        }
        while ( v12 != 4 );
        ++v7;
        v29[0] -= v28;
        if ( v27 > v29[0] )
        {
          v3 = 0;
          goto LABEL_36;
        }
      }
      if ( (unsigned int)dword_7EB9C > 3 )
      {
        strcpy(s, "Set voltage failed, exit.\n");
        sub_2E584(3, s, 0);
      }
    }
LABEL_36:
    v18 = 0;
    if ( sub_1E29C(0) )
      goto LABEL_39;
    while ( ++v18 != 4 )
    {
      if ( sub_1E29C(v18) )
      {
LABEL_39:
        v19 = 0;
        v20 = (float *)&v29[v18 + 16];
        v21 = 0;
        while ( v21 < v7 - 1 )
        {
          v22 = *v20;
          if ( *v20 < 5.0 )
          {
            v19 = v21;
            break;
          }
          v20 += 4;
          ++v21;
          if ( v22 > *v20 * 1.5 )
            v19 = v21;
        }
        v23 = (unsigned int)dword_7EB9C > 3;
        v24 = v29[v19 + 1];
        *(_DWORD *)(dword_4FCB40 + 4 * v18 + 4) = v24;
        if ( v23 )
        {
          snprintf(s, 0x800u, "chain %d best level %d, freq %d\n", v18, v19, v24);
          sub_2E584(3, s, 0);
        }
      }
    }
  }
  return v3;
}
// 3B4AC: variable 'v17' is possibly undefined
// 3B4B0: variable 'v16' is possibly undefined
// 7EB58: using guessed type int dword_7EB58;
// 7EB9C: using guessed type int dword_7EB9C;
// 482A70: using guessed type char byte_482A70;
// 4FCB40: using guessed type int dword_4FCB40;
// 80A894: using guessed type _DWORD dword_80A894[4];

//----- (0003B8A0) --------------------------------------------------------
unsigned int __fastcall sub_3B8A0(int a1, int a2)
{
  int v4; // r0
  unsigned int v5; // r4
  int v6; // r1
  int v7; // r3
  int v8; // r1
  int v9; // t1
  int v10; // r0
  unsigned int v11; // r0
  unsigned int v12; // r4
  char s[2064]; // [sp+8h] [bp-810h] BYREF

  v4 = sub_1E0F0();
  if ( v4 )
  {
    v6 = a2 + (a1 << 10);
    v5 = 0;
    v7 = 0;
    v8 = v6 - 4;
    do
    {
      ++v7;
      v9 = *(_DWORD *)(v8 + 4);
      v8 += 4;
      v5 += v9;
    }
    while ( v4 != v7 );
  }
  else
  {
    v5 = 0;
  }
  v10 = sub_1E0F0();
  v11 = sub_5F880(v5, v10);
  v12 = v11;
  if ( (unsigned int)dword_7EB9C > 4 )
  {
    snprintf(s, 0x800u, "chain = %d, freq_avg = %d\n", a1, v11);
    sub_2E584(4, s, 0);
  }
  return v12;
}
// 7EB9C: using guessed type int dword_7EB9C;

//----- (0003B94C) --------------------------------------------------------
unsigned int __fastcall sub_3B94C(int a1, int a2)
{
  int v3; // r8
  unsigned int v4; // r6
  int i; // r4
  bool v6; // zf
  int v8; // r0
  int v9; // r1
  int j; // r3
  unsigned int v11; // r2
  unsigned int v12; // t1
  char s[2072]; // [sp+8h] [bp-818h] BYREF

  v3 = a2 - 4;
  v4 = 0xFFFFFF;
  for ( i = 0; i != 4; ++i )
  {
    if ( sub_1E29C(i) )
    {
      v6 = a1 == 255;
      if ( a1 != 255 )
        v6 = a1 == i;
      if ( v6 )
      {
        v8 = sub_1E0F0();
        if ( v8 )
        {
          v9 = v3 + (i << 10);
          for ( j = 0; j != v8; ++j )
          {
            v12 = *(_DWORD *)(v9 + 4);
            v9 += 4;
            v11 = v12;
            if ( v4 >= v12 )
              v4 = v11;
          }
        }
      }
    }
  }
  if ( (unsigned int)dword_7EB9C > 4 )
  {
    snprintf(s, 0x800u, "chain = %d, freq_min = %d\n", a1, v4);
    sub_2E584(4, s, 0);
  }
  return v4;
}
// 7EB9C: using guessed type int dword_7EB9C;

//----- (0003BA18) --------------------------------------------------------
unsigned int __fastcall sub_3BA18(int a1, int a2)
{
  unsigned int v2; // r5
  int v4; // r8
  int i; // r4
  bool v6; // zf
  int v8; // r0
  int v9; // r1
  int j; // r3
  unsigned int v11; // r2
  unsigned int v12; // t1
  char s[2072]; // [sp+8h] [bp-818h] BYREF

  v2 = 0;
  v4 = a2 - 4;
  for ( i = 0; i != 4; ++i )
  {
    if ( sub_1E29C(i) )
    {
      v6 = a1 == 255;
      if ( a1 != 255 )
        v6 = a1 == i;
      if ( v6 )
      {
        v8 = sub_1E0F0();
        if ( v8 )
        {
          v9 = v4 + (i << 10);
          for ( j = 0; j != v8; ++j )
          {
            v12 = *(_DWORD *)(v9 + 4);
            v9 += 4;
            v11 = v12;
            if ( v2 < v12 )
              v2 = v11;
          }
        }
      }
    }
  }
  if ( (unsigned int)dword_7EB9C > 4 )
  {
    snprintf(s, 0x800u, "chain = %d, freq_max = %d\n", a1, v2);
    sub_2E584(4, s, 0);
  }
  return v2;
}
// 7EB9C: using guessed type int dword_7EB9C;

//----- (0003BAE4) --------------------------------------------------------
int __fastcall sub_3BAE4(int a1)
{
  unsigned int v2; // r6
  unsigned int v3; // r8
  unsigned int v4; // r7
  unsigned int v5; // r0
  int v6; // r3
  unsigned int v7; // r1
  char s[2072]; // [sp+10h] [bp-818h] BYREF

  v2 = sub_3B8A0(a1, dword_4FCB44 + 4);
  v3 = sub_3B94C(a1, dword_4FCB44 + 4);
  v4 = sub_3BA18(a1, dword_4FCB44 + 4);
  v5 = sub_3BA18(a1, dword_4FCB44 + 4116);
  v6 = *(_DWORD *)dword_4FCB44;
  v7 = *(_DWORD *)(*(_DWORD *)dword_4FCB44 + 20);
  if ( v7 > v2 )
  {
    if ( *(_DWORD *)(v6 + 28) > v4 - v3 )
    {
      if ( v7 >= v5 )
        return 0;
      if ( (unsigned int)dword_7EB9C <= 3 )
        return 1;
      snprintf(s, 0x800u, "chain = %d, freq_max_runtime = %d, freq_threshold = %d, max freq enough\n", a1, v5, v7);
    }
    else
    {
      if ( (unsigned int)dword_7EB9C <= 3 )
        return 1;
      snprintf(
        s,
        0x800u,
        "chain = %d, freq_max = %d, freq_min = %d, freq_diff = %d, freq_diff_threshold = %d, freq diff enough\n",
        a1,
        v4,
        v3,
        v4 - v3,
        *(_DWORD *)(v6 + 28));
    }
LABEL_13:
    sub_2E584(3, s, 0);
    return 1;
  }
  if ( (unsigned int)dword_7EB9C > 3 )
  {
    snprintf(s, 0x800u, "chain = %d, freq_avg = %d, freq_threshold = %d, avg freq enough\n", a1, v2, v7);
    goto LABEL_13;
  }
  return 1;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 4FCB44: using guessed type int dword_4FCB44;

//----- (0003BC48) --------------------------------------------------------
unsigned int __fastcall sub_3BC48(int a1, int a2)
{
  int i; // r5
  unsigned int result; // r0
  bool v5; // zf
  int v6; // r4
  unsigned int v7; // r8
  unsigned int v8; // r3
  unsigned int v9; // r4
  int v10; // r0
  int v11; // r1
  char s[4]; // [sp+10h] [bp-828h] BYREF

  if ( (unsigned int)dword_7EB9C > 4 )
  {
    snprintf(s, 0x800u, "[DEBUG] Dump freq table, chain = %d.\n", a1);
    sub_2E584(4, s, 0);
  }
  for ( i = 0; i != 4; ++i )
  {
    result = sub_1E29C(i);
    if ( result )
    {
      v5 = a1 == 255;
      if ( a1 != 255 )
        v5 = a1 == i;
      v6 = !v5;
      if ( v5 )
      {
        if ( (unsigned int)dword_7EB9C > 3 )
        {
          snprintf(s, 0x800u, "chain = %d\n", i);
          sub_2EA54(3, s, v6);
        }
        result = sub_1E0F0();
        v7 = result;
        v8 = dword_7EB9C;
        if ( result )
        {
          v9 = 0;
          do
          {
            if ( v8 > 3 )
            {
              snprintf(s, 0x800u, "[%3d]:%-3d", v9, *(_DWORD *)(a2 + (i << 10) + 4 * v9));
              sub_2EA54(3, s, 0);
              if ( (unsigned int)dword_7EB9C > 3 )
              {
                *(_DWORD *)s = &unk_202020;
                sub_2EA54(3, s, 0);
              }
            }
            ++v9;
            v10 = sub_1E100();
            result = sub_5FADC(v9, v10);
            v8 = dword_7EB9C;
            if ( !v11 && (unsigned int)dword_7EB9C > 3 )
            {
              strcpy(s, "\n");
              result = (unsigned int)sub_2EA54(3, s, 0);
              v8 = dword_7EB9C;
            }
          }
          while ( v7 != v9 );
        }
        if ( v8 > 3 )
        {
          strcpy(s, "\n");
          result = (unsigned int)sub_2EA54(3, s, 0);
        }
      }
    }
  }
  return result;
}
// 3BCF0: variable 'v11' is possibly undefined
// 7EB9C: using guessed type int dword_7EB9C;

//----- (0003BE08) --------------------------------------------------------
void sub_3BE08()
{
  char v0[2056]; // [sp+0h] [bp-808h] BYREF

  if ( (unsigned int)dword_7EB9C > 4 )
  {
    strcpy(v0, "[DEBUG] freq tuning fine exit.\n");
    sub_2E584(4, v0, 0);
    if ( (unsigned int)dword_7EB9C > 4 )
    {
      strcpy(v0, "[DEBUG] Free memory for pm grade.\n");
      sub_2E584(4, v0, 0);
    }
  }
  if ( dword_4FCB44 )
  {
    free((void *)dword_4FCB44);
    dword_4FCB44 = 0;
  }
}
// 7EB9C: using guessed type int dword_7EB9C;
// 4FCB44: using guessed type int dword_4FCB44;

//----- (0003BEC4) --------------------------------------------------------
int __fastcall sub_3BEC4(int a1)
{
  return *(_DWORD *)(dword_4FCB44 + 4 * (a1 + 1024) + 4);
}
// 4FCB44: using guessed type int dword_4FCB44;

//----- (0003BEE0) --------------------------------------------------------
int __fastcall sub_3BEE0(int a1, _DWORD *a2)
{
  int result; // r0
  _DWORD *v5; // r2
  _DWORD *v6; // r1
  int v7; // t1
  char v8[2064]; // [sp+0h] [bp-810h] BYREF

  if ( (unsigned int)dword_7EB9C > 4 )
  {
    snprintf(v8, 0x800u, "[DEBUG] Get freq result, chain = %d.\n", a1);
    sub_2E584(4, v8, 0);
  }
  result = sub_1E0F0();
  if ( result )
  {
    v5 = &a2[result];
    v6 = a2;
    result = dword_4FCB44 + (a1 << 10);
    do
    {
      v7 = *(_DWORD *)(result + 4);
      result += 4;
      *v6++ = v7;
    }
    while ( v6 != v5 );
  }
  return result;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 4FCB44: using guessed type int dword_4FCB44;

//----- (0003BF74) --------------------------------------------------------
int __fastcall sub_3BF74(int a1)
{
  return dword_4FCB44 + 4 * (a1 + 3084);
}
// 4FCB44: using guessed type int dword_4FCB44;

//----- (0003BF94) --------------------------------------------------------
char *sub_3BF94()
{
  int i; // r4
  char *result; // r0
  unsigned int v2; // r3
  const char *v3; // r6
  const char *v4; // r12
  char s[2]; // [sp+8h] [bp-818h] BYREF

  if ( (unsigned int)dword_7EB9C > 3 )
  {
    snprintf(s, 0x800u, "%-40s : %d\n", "voltage", **(_DWORD **)dword_4FCB44);
    sub_2EA54(3, s, 0);
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      snprintf(s, 0x800u, "%-40s : ", "freq_base");
      sub_2EA54(3, s, 0);
    }
  }
  for ( i = 0; i != 4; ++i )
  {
    result = (char *)sub_1E29C(i);
    if ( result && (unsigned int)dword_7EB9C > 3 )
    {
      snprintf(s, 0x800u, "[%d] = %d ", i, *(_DWORD *)(*(_DWORD *)dword_4FCB44 + 4 * i + 4));
      result = sub_2EA54(3, s, 0);
    }
  }
  if ( (unsigned int)dword_7EB9C > 3 )
  {
    strcpy(s, "\n");
    result = sub_2EA54(3, s, 0);
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      snprintf(s, 0x800u, "%-40s : %d\n", "freq_threshold", *(_DWORD *)(*(_DWORD *)dword_4FCB44 + 20));
      result = sub_2EA54(3, s, 0);
      if ( (unsigned int)dword_7EB9C <= 3 )
        return result;
      snprintf(s, 0x800u, "%-40s : %d\n", "freq_serial_threshold", *(_DWORD *)(*(_DWORD *)dword_4FCB44 + 24));
      result = sub_2EA54(3, s, 0);
      if ( (unsigned int)dword_7EB9C <= 3 )
        goto LABEL_24;
      snprintf(s, 0x800u, "%-40s : %d\n", "freq_diff_threshold", *(_DWORD *)(*(_DWORD *)dword_4FCB44 + 28));
      result = sub_2EA54(3, s, 0);
      if ( (unsigned int)dword_7EB9C <= 3 )
        return result;
      snprintf(s, 0x800u, "%-40s : %d\n", "freq_step", *(_DWORD *)(*(_DWORD *)dword_4FCB44 + 32));
      result = sub_2EA54(3, s, 0);
    }
    v2 = dword_7EB9C;
    if ( (unsigned int)dword_7EB9C <= 3 )
    {
LABEL_27:
      if ( v2 > 3 )
      {
        snprintf(s, 0x800u, "%-40s : %.2f\n", "nonce_rate_threshold", *(float *)(*(_DWORD *)dword_4FCB44 + 48));
        result = sub_2EA54(3, s, 0);
        if ( (unsigned int)dword_7EB9C > 3 )
        {
          snprintf(s, 0x800u, "%-40s : %.2f\n", "nonce_rate_dec_threshold", *(float *)(*(_DWORD *)dword_4FCB44 + 52));
          result = sub_2EA54(3, s, 0);
          if ( (unsigned int)dword_7EB9C > 3 )
          {
            snprintf(s, 0x800u, "%-40s : %d\n", "freq_tuning_fine_step", *(_DWORD *)(*(_DWORD *)dword_4FCB44 + 56));
            result = sub_2EA54(3, s, 0);
            if ( (unsigned int)dword_7EB9C > 3 )
            {
              snprintf(s, 0x800u, "%-40s : %d\n", "freq_tuning_fine_count", *(_DWORD *)(*(_DWORD *)dword_4FCB44 + 60));
              return sub_2EA54(3, s, 0);
            }
          }
        }
      }
      return result;
    }
    v3 = "false";
    if ( *(_BYTE *)(*(_DWORD *)dword_4FCB44 + 36) )
      v4 = "true";
    else
      v4 = "false";
    snprintf(s, 0x800u, "%-40s : %s\n", "is_inc_freq_with_high_vol", v4);
    result = sub_2EA54(3, s, 0);
    if ( (unsigned int)dword_7EB9C <= 3 )
      return result;
    if ( *(_BYTE *)(*(_DWORD *)dword_4FCB44 + 37) )
      v3 = "true";
    snprintf(s, 0x800u, "%-40s : %s\n", "is_inc_freq_with_high_vol_runtime", v3);
    result = sub_2EA54(3, s, 0);
LABEL_24:
    if ( (unsigned int)dword_7EB9C <= 3 )
      return result;
    snprintf(s, 0x800u, "%-40s : %d\n", "is_board_init_with_power_off", *(_DWORD *)(*(_DWORD *)dword_4FCB44 + 40));
    result = sub_2EA54(3, s, 0);
    if ( (unsigned int)dword_7EB9C <= 3 )
      return result;
    snprintf(s, 0x800u, "%-40s : %.4f\n", "hw_threshold", *(float *)(*(_DWORD *)dword_4FCB44 + 44));
    result = sub_2EA54(3, s, 0);
    v2 = dword_7EB9C;
    goto LABEL_27;
  }
  return result;
}
// 7EB9C: using guessed type int dword_7EB9C;
// 4FCB44: using guessed type int dword_4FCB44;

//----- (0003C490) --------------------------------------------------------
int __fastcall sub_3C490(int a1)
{
  _DWORD *v2; // r6
  char v4[2072]; // [sp+0h] [bp-818h] BYREF

  if ( (unsigned int)dword_7EB9C > 4 )
  {
    strcpy(v4, "[DEBUG] freq tuning fine init.\n");
    sub_2E584(4, v4, 0);
    if ( (unsigned int)dword_7EB9C > 4 )
    {
      strcpy(v4, "[DEBUG] Allocate memory for pm grade.\n");
      sub_2E584(4, v4, 0);
    }
  }
  v2 = (_DWORD *)dword_4FCB44;
  if ( dword_4FCB44 || (v2 = calloc(0x3044u, 1u), (dword_4FCB44 = (int)v2) != 0) )
  {
    *v2 = a1;
    sub_3BF94();
    return 0;
  }
  else
  {
    sub_356C4(13, 255);
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      strcpy(v4, "Fail to allocate memory for pm grade context.\n");
      sub_2E584(3, v4, 0);
    }
    return -1;
  }
}
// 7EB9C: using guessed type int dword_7EB9C;
// 4FCB44: using guessed type int dword_4FCB44;

//----- (0003C5DC) --------------------------------------------------------
int sub_3C5DC()
{
  int i; // r4
  int j; // r4
  int *v2; // r8
  int k; // r4
  int v4; // r5
  int *v5; // r9
  _DWORD *v7; // r3
  int v8; // r4
  int v9; // r4
  float v10; // s0
  int m; // r4
  int v12; // r4
  int n; // r5
  char *v14; // r5
  int v15; // r0
  int v16; // r6
  int v17; // r4
  int v18; // r5
  int v19; // r0
  int v20; // r6
  char *v21; // r7
  int *v22; // r4
  int v23; // r8
  int v24; // r6
  unsigned int v25; // t1
  int v26; // r0
  int v27; // r2
  double v28; // d8
  int v29; // r1
  int v30; // r3
  double v31; // d7
  int v32; // r0
  int v33; // r2
  int v34; // r0
  int v35; // r3
  int v36; // t1
  int v37; // r0
  int v38; // r12
  int v39; // r0
  int v40; // r3
  int v41; // r2
  int v42; // t1
  int v43; // r12
  bool v44; // cc
  int v45; // r5
  int v46; // r0
  unsigned int v47; // r6
  int v48; // r12
  int v49; // r0
  _DWORD *v50; // r3
  int v51; // r2
  int v52; // r1
  int v53; // t1
  int v54; // r7
  int v55; // r1
  unsigned __int8 v56; // r2
  unsigned int v57; // r12
  int v58; // r0
  int v59; // r0
  int v60; // r1
  int v61; // r0
  char *v62; // r3
  char *v63; // r1
  unsigned int v64; // r3
  bool v65; // zf
  int v66; // r1
  int v67; // r0
  int v68; // r0
  int v69; // r3
  char *v70; // r2
  int v71; // r0
  int v72; // t1
  int v73; // r0
  int v74; // r1
  int v75; // r3
  int v76; // r0
  int v77; // r0
  int v78; // r3
  char *v79; // r2
  int v80; // r0
  int v81; // t1
  char *v82; // [sp+Ch] [bp-1064h]
  char *v83; // [sp+10h] [bp-1060h]
  unsigned int v84; // [sp+28h] [bp-1048h] BYREF
  char v85[4]; // [sp+2Ch] [bp-1044h] BYREF
  int v86; // [sp+30h] [bp-1040h] BYREF
  __int16 v87; // [sp+34h] [bp-103Ch]
  char v88; // [sp+36h] [bp-103Ah]
  char s[4152]; // [sp+38h] [bp-1038h] BYREF

  if ( (unsigned int)dword_7EB9C > 3 )
  {
    strcpy(s, "Do freq tuning fine.\n");
    sub_2E584(3, s, 0);
  }
  for ( i = 0; i != 4; ++i )
  {
    if ( sub_1E29C(i) )
    {
      v73 = sub_1E0F0();
      if ( v73 )
      {
        v74 = dword_4FCB44 + 4 * (v73 + (i << 8));
        v75 = dword_4FCB44 + (i << 10);
        v76 = *(_DWORD *)dword_4FCB44 + 4 * i;
        do
        {
          *(_DWORD *)(v75 + 4) = *(_DWORD *)(v76 + 4);
          v75 += 4;
        }
        while ( v75 != v74 );
      }
    }
  }
  sub_361E4(**(_DWORD **)dword_4FCB44);
  memcpy((void *)(dword_4FCB44 + 4116), (const void *)(dword_4FCB44 + 4), 0x1000u);
  if ( (unsigned int)dword_7EB9C > 3 )
  {
    strcpy(s, "\n");
    sub_2EA54(3, s, 0);
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      strcpy(s, ">>>> Do freq tuning fine parallel.\n");
      sub_2E584(3, s, 0);
    }
  }
  for ( j = 0; j != 4; ++j )
  {
    if ( sub_1E29C(j) )
    {
      v65 = sub_3BAE4(j) == 0;
      v66 = 2;
      v67 = j;
      if ( v65 )
      {
        v66 = 1;
        v67 = j;
      }
      sub_3962C(v67, v66);
    }
  }
  v2 = &dword_4FCB44;
LABEL_11:
  while ( 2 )
  {
    if ( !sub_39998() )
    {
      v4 = 0;
      v5 = v2;
      goto LABEL_142;
    }
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      snprintf(s, 0x800u, "is_need_serial = %d\n", 0);
      sub_2E584(3, s, 0);
      if ( (unsigned int)dword_7EB9C > 3 )
      {
        strcpy(s, "\n");
        sub_2EA54(3, s, 0);
        if ( (unsigned int)dword_7EB9C > 3 )
        {
          strcpy(s, ">>>> Do single grade tuning.\n");
          sub_2E584(3, s, 0);
        }
      }
    }
    for ( k = 0; k != 4; ++k )
    {
      if ( sub_1E29C(k) && sub_397A0(k) == 1 && (unsigned int)dword_7EB9C > 3 )
      {
        snprintf(s, 0x800u, "chain = %d, grade = %d\n", k, *(_DWORD *)(*v2 + 4 * (k + 3076) + 4));
        sub_2E584(3, s, 0);
      }
    }
    if ( (unsigned int)dword_7EB9C > 3 )
    {
      strcpy(s, "Board init start.\n");
      sub_2E584(3, s, 0);
    }
    v4 = sub_39FB4(*(_DWORD *)(*(_DWORD *)*v2 + 40));
    if ( !v4 )
    {
      sub_39A7C();
      v7 = (_DWORD *)*v2;
      v8 = 0;
      v7[3081] = 0;
      v7 += 3081;
      v7[1] = 0;
      v7[2] = 0;
      v7[3] = 0;
      memset(s, 0, 0x1000u);
      do
      {
        if ( sub_1E29C(v8) )
        {
          if ( sub_397A0(v8) == 1 )
          {
            v77 = sub_1E0F0();
            if ( v77 )
            {
              v78 = *v2 + (v8 << 10);
              v79 = &s[1024 * v8];
              v80 = *v2 + 4 * (v77 + (v8 << 8));
              do
              {
                v81 = *(_DWORD *)(v78 + 4);
                v78 += 4;
                *(_DWORD *)v79 = v81;
                v79 += 4;
              }
              while ( v78 != v80 );
            }
          }
          else if ( sub_3B8A0(v8, *v2 + 4) <= *(_DWORD *)(*(_DWORD *)*v2 + 24) )
          {
            v68 = sub_1E0F0();
            if ( v68 )
            {
              v69 = *v2 + (v8 << 10);
              v70 = &s[1024 * v8];
              v71 = *v2 + 4 * (v68 + (v8 << 8));
              do
              {
                v72 = *(_DWORD *)(v69 + 4);
                v69 += 4;
                *(_DWORD *)v70 = v72;
                v70 += 4;
              }
              while ( v69 != v71 );
            }
          }
          else
          {
            v59 = sub_1E0F0();
            if ( v59 )
            {
              v60 = v59 + (v8 << 8);
              v61 = *v2;
              v62 = &s[1024 * v8];
              v63 = &s[4 * v60];
              do
              {
                *(_DWORD *)v62 = *(_DWORD *)(*(_DWORD *)v61 + 24);
                v62 += 4;
              }
              while ( v62 != v63 );
            }
          }
        }
        ++v8;
      }
      while ( v8 != 4 );
      v9 = sub_36204();
      if ( v9 == sub_361F4() )
      {
        v10 = (float)unk_7EDD0;
        sub_1AD08((int)s, (unsigned __int8)byte_482A70, *(unsigned __int8 *)(*(_DWORD *)*v2 + 36));
      }
      else
      {
        v4 = sub_36208();
        v10 = (float)unk_7EDD0;
        sub_1AD08((int)s, (unsigned __int8)byte_482A70, *(unsigned __int8 *)(*(_DWORD *)*v2 + 36));
        if ( v4 )
        {
          v5 = v2;
          v64 = dword_7EB9C;
          goto LABEL_122;
        }
      }
      while ( sub_39998() )
      {
        for ( m = 0; m != 4; ++m )
        {
          if ( sub_1E29C(m) )
          {
            if ( sub_397A0(m) == 1 )
            {
              v57 = sub_3B8A0(m, *v2 + 4116);
              if ( (unsigned int)dword_7EB9C > 3 )
              {
                snprintf(
                  s,
                  0x800u,
                  "chain = %d, freq_avg = %d, freq_threshold = %d\n",
                  m,
                  v57,
                  *(_DWORD *)(*(_DWORD *)*v2 + 24));
                sub_2E584(3, s, 0);
              }
            }
          }
        }
        v12 = 1;
        for ( n = 0; n != 4; ++n )
        {
          if ( sub_1E29C(n) && sub_397A0(n) == 1 )
          {
            v58 = *(_DWORD *)(*v2 + 4 * n + 12324);
            if ( (unsigned int)dword_7EB9C > 3 )
            {
              snprintf(
                s,
                0x800u,
                "chain = %d, grade_curr = %d, is_grade_curr_done = %d\n",
                n,
                *(_DWORD *)(*v2 + 4 * n + 12308),
                *(_DWORD *)(*v2 + 4 * n + 12324));
              sub_2E584(3, s, 0);
              v58 = *(_DWORD *)(*v2 + 4 * (n + 3080) + 4);
            }
            if ( !v58 )
              v12 = 0;
          }
        }
        if ( (unsigned int)dword_7EB9C > 3 )
          goto LABEL_113;
LABEL_40:
        if ( v12 )
          goto LABEL_11;
        do
        {
          if ( sub_1E29C(v12) )
          {
            if ( sub_397A0(v12) == 1 )
            {
              v45 = *(_DWORD *)(*v2 + 4 * (v12 + 3080) + 4);
              if ( !v45 )
              {
                v46 = sub_1E0F0();
                v47 = v46;
                if ( v46 )
                {
                  v47 = 0;
                  v48 = *(_DWORD *)*v2;
                  v49 = *v2 + 4 * (v46 + (v12 << 8));
                  v50 = (_DWORD *)(*v2 + (v12 << 10) + 4116);
                  v51 = *v2 + (v12 << 10);
                  do
                  {
                    v53 = *(_DWORD *)(v51 + 4);
                    v51 += 4;
                    v52 = v53;
                    *v50++ = v53;
                    if ( v50[1023] == 1 )
                    {
                      v47 = v52 - *(_DWORD *)(v48 + 32);
                      *(v50 - 1) = v47;
                    }
                  }
                  while ( v51 != v49 );
                }
                else
                {
                  v48 = *(_DWORD *)*v2;
                }
                if ( *(_BYTE *)(v48 + 37) )
                  nullsub_4(v47, 1);
                v10 = (float)v47;
                sub_502C0((int)&v86, v85, 0);
                v88 = v85[0];
                if ( (unsigned int)dword_7EB9C > 3 )
                {
                  snprintf(
                    s,
                    0x800u,
                    "chain = %d, grade_curr = %d, freq_target = %d\n",
                    v12,
                    *(_DWORD *)(*v2 + 4 * (v12 + 3076) + 4),
                    v47);
                  sub_2E584(3, s, 0);
                }
                v54 = sub_1E0F0();
                v55 = *v2;
                if ( v54 )
                {
                  do
                  {
                    while ( *(_DWORD *)(v55 + 4 * ((v12 << 8) + v45 + 1028) + 4) != v47 )
                    {
                      if ( v54 == ++v45 )
                        goto LABEL_101;
                    }
                    if ( (unsigned int)dword_7EB9C > 3 )
                    {
                      snprintf(s, 0x800u, "chain = %d, asic = %d, freq = %d\n", v12, v45, v47);
                      sub_2E584(3, s, 0);
                    }
                    v56 = sub_1E160() * v45++;
                    sub_1F164(v12, 0, v56, (unsigned __int8)byte_482A70, v86, v87);
                    usleep((__useconds_t)&unk_F4240);
                    v55 = *v2;
                  }
                  while ( v54 != v45 );
                }
LABEL_101:
                sub_3BC48(v12, v55 + 4116);
              }
            }
          }
          ++v12;
        }
        while ( v12 != 4 );
        v14 = 0;
        v15 = sub_3B94C(255, *v2 + 4116);
        sub_321B8(v15, dword_7EB58, 20);
        v84 = sub_3BA18(255, *v2 + 4116);
        sub_3A86C((int)&v84);
        v16 = sub_391F4();
        do
        {
          if ( sub_1E29C((int)v14) && sub_397A0((int)v14) == 1 && !*(_DWORD *)(*v2 + 4 * (_DWORD)(v14 + 3080) + 4) )
            sub_3A054(v14, v16);
          ++v14;
        }
        while ( v14 != (char *)4 );
        v17 = 0;
        v82 = (char *)&unk_808FFC + v16;
        if ( sub_1E29C(0) )
        {
LABEL_49:
          if ( sub_397A0(v17) == 1 )
          {
            v18 = *(_DWORD *)(*v2 + 4 * (v17 + 3080) + 4);
            if ( !v18 )
            {
              v19 = sub_1E0F0();
              if ( v19 > 0 )
              {
                v20 = v17 << 8;
                v83 = (char *)v17;
                v21 = &v82[1024 * v17];
                v22 = v2;
                v23 = v20;
                v24 = v19;
                do
                {
                  v25 = *((_DWORD *)v21 + 1);
                  v21 += 4;
                  v26 = sub_1E130();
                  v28 = (double)v25;
                  v29 = v23 + v18++ + 2052;
                  v30 = v29;
                  v31 = (double)(8 * v26) * 0.98;
                  if ( (double)v25 <= v31 )
                    v30 = *v22;
                  else
                    v27 = 0;
                  if ( v28 <= v31 )
                    v30 += 4 * v29;
                  else
                    v29 = *v22;
                  if ( v28 <= v31 )
                    *(_DWORD *)(v30 + 4) = 1;
                  else
                    v30 = v29 + 4 * v30;
                  if ( v28 > v31 )
                    *(_DWORD *)(v30 + 4) = v27;
                }
                while ( v24 != v18 );
                v2 = v22;
                v17 = (int)v83;
              }
              v32 = sub_1E0F0();
              if ( v32 <= 0 )
                goto LABEL_120;
              v33 = 0;
              v34 = *v2 + 8208 + 4 * (v32 + (v17 << 8));
              v35 = *v2 + (v17 << 10) + 8208;
              do
              {
                v36 = *(_DWORD *)(v35 + 4);
                v35 += 4;
                v33 += v36;
              }
              while ( v34 != v35 );
              if ( !v33 )
LABEL_120:
                sub_3962C(v17, 2);
              v37 = sub_1E0F0();
              v38 = *v2;
              if ( v37 )
              {
                v39 = v38 + 4 * (v37 + (v17 << 8));
                v40 = v38 + (v17 << 10);
                v41 = v38 + (v17 << 10) + 4112;
                do
                {
                  v42 = *(_DWORD *)(v41 + 4);
                  v41 += 4;
                  *(_DWORD *)(v40 + 4) = v42;
                  v40 += 4;
                }
                while ( v40 != v39 );
              }
              v43 = v38 + 4 * v17;
              v44 = (unsigned int)dword_7EB9C > 3;
              *(_DWORD *)(v43 + 4100) = 1;
              if ( v44 )
              {
                snprintf(
                  s,
                  0x800u,
                  "Update freq result of high grade, chain = %d, grade_curr = %d.\n",
                  v17,
                  *(_DWORD *)(v43 + 12308));
                sub_2E584(3, s, 0);
              }
              sub_3A828();
              if ( v10 > *(float *)(*v2 + 4 * v17 + 12340) )
                *(float *)(*v2 + 4 * v17 + 12340) = v10;
              if ( sub_3BAE4(v17) )
                sub_3962C(v17, 2);
            }
          }
        }
        while ( ++v17 != 4 )
        {
          if ( sub_1E29C(v17) )
            goto LABEL_49;
        }
      }
      if ( (unsigned int)dword_7EB9C <= 3 )
        continue;
      v12 = 1;
LABEL_113:
      snprintf(s, 0x800u, "is_single_grade_done = %d\n", v12);
      sub_2E584(3, s, 0);
      goto LABEL_40;
    }
    break;
  }
  v5 = v2;
  if ( (unsigned int)dword_7EB9C <= 3 )
    goto LABEL_20;
  strcpy(s, "Board init failed, exit.\n");
  sub_2E584(3, s, 0);
  v64 = dword_7EB9C;
LABEL_122:
  if ( v64 <= 3 )
    goto LABEL_20;
  strcpy(s, "Parallel tuning failed, exit.\n");
  sub_2E584(3, s, 0);
LABEL_142:
  if ( (unsigned int)dword_7EB9C > 3 )
  {
    strcpy(s, "Dump freq tuning fine result:\n");
    sub_2E584(3, s, 0);
  }
LABEL_20:
  sub_3BC48(255, *v5 + 4);
  return v4;
}
// 3CB04: variable 'v27' is possibly undefined
// 1A46C: using guessed type int __fastcall nullsub_4(_DWORD, _DWORD);
// 7EB58: using guessed type int dword_7EB58;
// 7EB9C: using guessed type int dword_7EB9C;
// 482A70: using guessed type char byte_482A70;
// 4FCB44: using guessed type int dword_4FCB44;
// 3C5DC: using guessed type char s[4152];
// 3C5DC: using guessed type char anonymous_2[4];

//----- (0003D2B4) --------------------------------------------------------
char *__fastcall sub_3D2B4(const char *a1, const char *a2)
{
  size_t v4; // r5
  size_t v5; // r0
  char *v6; // r5

  v4 = strlen(a1);
  v5 = strlen(a2);
  v6 = (char *)malloc(v4 + v5);
  sprintf(v6, a1, a2);
  return v6;
}

//----- (0003D2F0) --------------------------------------------------------
int __fastcall sub_3D2F0(_BYTE *a1)
{
  *a1 = 1;
  return 0;
}

//----- (0003D300) --------------------------------------------------------
int __fastcall sub_3D300(_BYTE *a1)
{
  *a1 = 0;
  return 0;
}

//----- (0003D310) --------------------------------------------------------
int __fastcall sub_3D310(_BYTE *a1)
{
  *a1 = 0;
  return 0;
}

//----- (0003D320) --------------------------------------------------------
char *__fastcall sub_3D320(const char *a1, _BYTE *a2)
{
  char *result; // r0

  if ( !strcasecmp(a1, "yes") || !strcasecmp(a1, "true") )
  {
    result = 0;
    *a2 = 1;
  }
  else if ( !strcasecmp(a1, "no") || !strcasecmp(a1, "false") )
  {
    result = 0;
    *a2 = 0;
  }
  else
  {
    return sub_3DE58(a1);
  }
  return result;
}

//----- (0003D3B4) --------------------------------------------------------
char *__fastcall sub_3D3B4(const char *a1, _BYTE *a2)
{
  char *result; // r0

  result = sub_3D320(a1, a2);
  if ( !result )
    *a2 ^= 1u;
  return result;
}

//----- (0003D3D4) --------------------------------------------------------
int __fastcall sub_3D3D4(int a1, _DWORD *a2)
{
  *a2 = a1;
  return 0;
}

//----- (0003D468) --------------------------------------------------------
char *__fastcall sub_3D468(const char *a1, int *a2)
{
  int *v4; // r5
  int v5; // r0
  char *v6; // r3
  char *result; // r0
  char *endptr; // [sp+4h] [bp-14h] BYREF

  v4 = _errno_location();
  *v4 = 0;
  v5 = strtol(a1, &endptr, 0);
  v6 = endptr;
  *a2 = v5;
  if ( *v6 || !*a1 )
    return sub_3D2B4("'%s' is not a number", a1);
  result = (char *)*v4;
  if ( *v4 )
    return sub_3D2B4("'%s' is out of range", a1);
  return result;
}

//----- (0003D4F0) --------------------------------------------------------
char *__fastcall sub_3D4F0(const char *a1, _DWORD *a2)
{
  char *result; // r0
  int v4; // [sp+4h] [bp-Ch] BYREF

  result = sub_3D468(a1, &v4);
  if ( !result )
    *a2 = v4;
  return result;
}

//----- (0003D5B8) --------------------------------------------------------
int __fastcall sub_3D5B8(_DWORD *a1)
{
  int result; // r0

  result = 0;
  ++*a1;
  return result;
}

//----- (0003D5D0) --------------------------------------------------------
void __fastcall __noreturn sub_3D5D0(const char *a1)
{
  puts(a1);
  fflush((FILE *)stdout);
  exit(0);
}
// 7F79C: using guessed type int stdout;

//----- (0003D5F0) --------------------------------------------------------
void __fastcall __noreturn sub_3D5F0(int a1)
{
  const char *v1; // r0

  v1 = (const char *)sub_3E370(dword_99EE20, a1);
  printf("%s", v1);
  fflush((FILE *)stdout);
  exit(0);
}
// 3E370: using guessed type int __fastcall sub_3E370(_DWORD, _DWORD);
// 7F79C: using guessed type int stdout;
// 99EE20: using guessed type int dword_99EE20;

//----- (0003D630) --------------------------------------------------------
char *__fastcall sub_3D630(char *a1, unsigned __int8 *a2)
{
  int v2; // r12
  const char *v3; // r1

  v2 = *a2;
  v3 = "true";
  if ( !v2 )
    v3 = "false";
  return strncpy(a1, v3, 0x50u);
}

//----- (0003D654) --------------------------------------------------------
char *__fastcall sub_3D654(char *a1, unsigned __int8 *a2)
{
  int v2; // r12
  const char *v3; // r1

  v2 = *a2;
  v3 = "false";
  if ( !v2 )
    v3 = "true";
  return strncpy(a1, v3, 0x50u);
}

//----- (0003D678) --------------------------------------------------------
char *__fastcall sub_3D678(_BYTE *a1, const char **a2)
{
  size_t v4; // r0
  bool v5; // cc
  size_t v6; // r5
  char *v7; // r0
  const char *v8; // r1
  _BYTE *v9; // r4
  char *result; // r0

  v4 = strlen(*a2);
  v5 = v4 > 0x4E;
  v6 = v4;
  *a1 = 34;
  v7 = a1 + 1;
  v8 = *a2;
  if ( v5 )
  {
    result = strncpy(v7, v8, 0x4Eu);
    a1[79] = 34;
  }
  else
  {
    v9 = &a1[v6];
    result = strncpy(v7, v8, v6);
    v9[1] = 34;
    if ( v6 != 78 )
      v9[2] = 0;
  }
  return result;
}

//----- (0003D6D8) --------------------------------------------------------
int __fastcall sub_3D6D8(char *a1, _DWORD *a2)
{
  return snprintf(a1, 0x50u, "%i", *a2);
}

//----- (0003D6EC) --------------------------------------------------------
int __fastcall sub_3D6EC(char *a1, float *a2)
{
  return snprintf(a1, 0x50u, "%.1f", *a2);
}

//----- (0003D718) --------------------------------------------------------
int __fastcall sub_3D718(char *a1, _DWORD *a2)
{
  return snprintf(a1, 0x50u, "%u", *a2);
}

//----- (0003D72C) --------------------------------------------------------
int __fastcall sub_3D72C(char *a1, _DWORD *a2)
{
  return snprintf(a1, 0x50u, "%li", *a2);
}

//----- (0003D740) --------------------------------------------------------
int __fastcall sub_3D740(char *a1, _DWORD *a2)
{
  return snprintf(a1, 0x50u, "%lu", *a2);
}

//----- (0003D754) --------------------------------------------------------
const char *__fastcall sub_3D754(unsigned int *a1, size_t *a2)
{
  _DWORD *v2; // r12
  const char *v3; // r4
  int v5; // r4
  unsigned int v6; // lr

  *a1 = 0;
  if ( !dword_99EE24 )
    return 0;
  v2 = (_DWORD *)dword_99EE1C;
  if ( *(_DWORD *)(dword_99EE1C + 4) == 8 )
  {
    v5 = 28;
    v6 = 1;
    do
    {
      *a1 = v6;
      if ( dword_99EE24 <= v6++ )
        return 0;
      v2 = (_DWORD *)(dword_99EE1C + v5);
      v5 += 28;
    }
    while ( v2[1] == 8 );
  }
  v3 = (const char *)(*v2 + 1);
  *a2 = strcspn(v3, (const char *)&off_68A48);
  return v3;
}
// 68A48: using guessed type void *off_68A48;
// 99EE1C: using guessed type int dword_99EE1C;
// 99EE24: using guessed type int dword_99EE24;

//----- (0003D7F4) --------------------------------------------------------
size_t __fastcall sub_3D7F4(int a1, size_t *a2)
{
  int v2; // r3
  size_t v3; // r0
  bool v4; // zf
  size_t v5; // r4

  v2 = *(unsigned __int8 *)(a1 + *a2);
  v3 = a1 + *a2;
  v4 = (v2 & 0xDF) == 0;
  if ( (v2 & 0xDF) != 0 )
    v4 = v2 == 61;
  if ( v4 )
    return 0;
  v5 = v3 + 2;
  *a2 = strcspn((const char *)(v3 + 2), (const char *)&off_68A48);
  return v5;
}
// 68A48: using guessed type void *off_68A48;

//----- (0003D83C) --------------------------------------------------------
int __fastcall sub_3D83C(int a1, unsigned int *a2, size_t *a3)
{
  unsigned int v3; // r3
  _DWORD *v7; // r2
  int result; // r0
  const char *v9; // r4

  v3 = *a2;
  if ( *a2 >= dword_99EE24 )
    return 0;
  while ( 1 )
  {
    v7 = (_DWORD *)(dword_99EE1C + 28 * v3);
    if ( v7[1] != 8 )
      break;
LABEL_6:
    *a2 = ++v3;
    if ( v3 >= dword_99EE24 )
      return 0;
  }
  if ( a1 )
  {
    result = sub_3D7F4(a1, a3);
    a1 = result;
    if ( result )
      return result;
    v3 = *a2;
    goto LABEL_6;
  }
  v9 = (const char *)(*v7 + 1);
  *a3 = strcspn(v9, (const char *)&off_68A48);
  return (int)v9;
}
// 68A48: using guessed type void *off_68A48;
// 99EE1C: using guessed type int dword_99EE1C;
// 99EE24: using guessed type int dword_99EE24;

//----- (0003D8F4) --------------------------------------------------------
int __fastcall sub_3D8F4(const char **a1)
{
  __int64 v1; // r2
  bool v2; // cc
  _BYTE *v4; // r4
  int v5; // r0
  const char *v6; // r12
  unsigned int v7; // r3
  int v8; // r3
  bool v9; // zf
  int result; // r0
  int status; // [sp+Ch] [bp-1Ch] BYREF

  v1 = *(_QWORD *)a1;
  v2 = (unsigned int)a1[1] > 4;
  if ( a1[1] != (const char *)4 )
    v2 = (unsigned int)(a1[1] - 1) > 1;
  if ( v2 )
    errx(1, "Option %s: unknown entry type %u", (const char *)v1, HIDWORD(v1));
  if ( !a1[6] )
    errx(1, "Option %s: description cannot be NULL", (const char *)v1);
  if ( *(_BYTE *)v1 != 45 )
    errx(1, "Option %s: does not begin with '-'", (const char *)v1);
  v4 = (_BYTE *)(v1 + 1);
  v5 = strcspn((const char *)(v1 + 1), (const char *)&off_68A48);
  for ( status = v5; ; v5 = status )
  {
    if ( *v4 == 45 )
    {
      if ( v5 == 1 )
        errx(1, "Option %s: invalid long option '--'", *a1);
      v6 = a1[1];
      ++dword_99EE14;
    }
    else
    {
      if ( v5 != 1 )
        errx(1, "Option %s: invalid short option '%.*s'", *a1, v5 + 1, v4 - 1);
      v6 = a1[1];
      v7 = (unsigned int)(v6 - 2) & 0xFFFFFFFD;
      if ( !v7 )
        v7 = dword_99EE10;
      ++dword_99EE18;
      if ( ((unsigned int)(v6 - 2) & 0xFFFFFFFD) == 0 )
        dword_99EE10 = v7 + 1;
    }
    if ( v6 == (const char *)1 )
    {
      v8 = (unsigned __int8)v4[v5];
      v9 = v8 == 61;
      if ( v8 != 61 )
        v9 = v8 == 32;
      if ( v9 )
        errx(1, "Option %s: does not take arguments '%s'", *a1, &v4[v5 + 1]);
    }
    result = sub_3D7F4((int)v4, (size_t *)&status);
    v4 = (_BYTE *)result;
    if ( !result )
      break;
  }
  return result;
}
// 68A48: using guessed type void *off_68A48;
// 99EE10: using guessed type int dword_99EE10;
// 99EE14: using guessed type int dword_99EE14;
// 99EE18: using guessed type int dword_99EE18;

//----- (0003DA68) --------------------------------------------------------
int __fastcall sub_3DA68(int *a1)
{
  char *v2; // r0
  int v3; // r3
  int *v4; // lr
  char *v5; // r12
  int v6; // r4
  int v7; // r0
  int v8; // r1
  int v9; // r2
  int v10; // r3
  int *v11; // r12
  int result; // r0
  int v13; // r1
  int v14; // r2

  v2 = (char *)realloc((void *)dword_99EE1C, 28 * (dword_99EE24 + 1));
  v3 = dword_99EE24;
  v4 = a1;
  v5 = v2;
  dword_99EE1C = (int)v2;
  ++dword_99EE24;
  v6 = 7 * v3;
  v7 = *v4;
  v8 = v4[1];
  v9 = v4[2];
  v10 = v4[3];
  v4 += 4;
  v11 = (int *)&v5[4 * v6];
  *v11 = v7;
  v11[1] = v8;
  v11[2] = v9;
  v11[3] = v10;
  v11 += 4;
  result = *v4;
  v13 = v4[1];
  v14 = v4[2];
  *v11 = *v4;
  v11[1] = v13;
  v11[2] = v14;
  return result;
}
// 99EE1C: using guessed type int dword_99EE1C;
// 99EE24: using guessed type int dword_99EE24;

//----- (0003DACC) --------------------------------------------------------
const char *__fastcall sub_3DACC(unsigned int *a1, size_t *a2)
{
  const char *v4; // r0
  const char *result; // r0

  v4 = sub_3D754(a1, a2);
  if ( !v4 )
    return 0;
  while ( *v4 != 45 )
  {
    v4 = (const char *)sub_3D83C((int)v4, a1, a2);
    if ( !v4 )
      return 0;
  }
  result = v4 + 1;
  --*a2;
  return result;
}

//----- (0003DB24) --------------------------------------------------------
_BYTE *__fastcall sub_3DB24(int a1, unsigned int *a2, size_t *a3)
{
  _BYTE *v5; // r0
  _BYTE *result; // r0

  v5 = (_BYTE *)sub_3D83C(a1, a2, a3);
  if ( !v5 )
    return 0;
  while ( *v5 != 45 )
  {
    v5 = (_BYTE *)sub_3D83C((int)v5, a2, a3);
    if ( !v5 )
      return 0;
  }
  result = v5 + 1;
  --*a3;
  return result;
}

//----- (0003DB7C) --------------------------------------------------------
const char *__fastcall sub_3DB7C(unsigned int *a1)
{
  const char *result; // r0
  size_t v3; // [sp+4h] [bp-14h] BYREF

  v3 = 0;
  result = sub_3D754(a1, &v3);
  if ( !result )
    return 0;
  while ( *result == 45 )
  {
    result = (const char *)sub_3D83C((int)result, a1, &v3);
    if ( !result )
      return 0;
  }
  return result;
}

//----- (0003DBDC) --------------------------------------------------------
_BYTE *__fastcall sub_3DBDC(int a1, unsigned int *a2)
{
  _BYTE *result; // r0
  size_t v4; // [sp+4h] [bp-14h] BYREF

  v4 = 1;
  result = (_BYTE *)sub_3D83C(a1, a2, &v4);
  if ( !result )
    return 0;
  while ( *result == 45 )
  {
    result = (_BYTE *)sub_3D83C((int)result, a2, &v4);
    if ( !result )
      return 0;
  }
  return result;
}

//----- (0003DC3C) --------------------------------------------------------
int __fastcall sub_3DC3C(
        const char *a1,
        const char *a2,
        const char *a3,
        const char *a4,
        const char *a5,
        const char *a6,
        const char *a7)
{
  const char *v8[9]; // [sp+4h] [bp-24h] BYREF

  v8[1] = a2;
  v8[0] = a1;
  v8[2] = a3;
  v8[3] = a4;
  v8[4] = a5;
  v8[5] = a6;
  v8[6] = a7;
  sub_3D8F4(v8);
  return sub_3DA68((int *)v8);
}

//----- (0003DC80) --------------------------------------------------------
int __fastcall sub_3DC80(int result, int a2)
{
  const char **v3; // r4
  int v4; // r6
  const char *v5; // r3
  int v6[13]; // [sp+4h] [bp-34h] BYREF

  v3 = (const char **)result;
  v4 = dword_99EE24;
  if ( a2 )
  {
    v6[0] = 0;
    memset(&v6[2], 0, 16);
    v6[6] = a2;
    v6[1] = 8;
    sub_3DA68(v6);
    v5 = v3[1];
    if ( v5 == (const char *)16 )
    {
LABEL_7:
      result = 7 * v4;
      *(_DWORD *)(dword_99EE1C + 28 * v4 + 20) = dword_99EE24 - v4;
      return result;
    }
  }
  else
  {
    v5 = *(const char **)(result + 4);
    if ( v5 == (const char *)16 )
      return result;
  }
  do
  {
    if ( v5 == (const char *)8 )
    {
      result = sub_3DC80(*v3, v3[6]);
    }
    else
    {
      sub_3D8F4(v3);
      result = sub_3DA68((int *)v3);
    }
    v3 += 7;
    v5 = v3[1];
  }
  while ( v5 != (const char *)16 );
  if ( a2 )
    goto LABEL_7;
  return result;
}
// 99EE1C: using guessed type int dword_99EE1C;
// 99EE24: using guessed type int dword_99EE24;

//----- (0003DD54) --------------------------------------------------------
bool __fastcall sub_3DD54(_DWORD *a1, const char **a2, void (*a3)(const char *, ...))
{
  int v6; // r0
  int v8; // [sp+4h] [bp-1Ch] BYREF

  dword_99EE20 = (int)*a2;
  v8 = 0;
  do
    v6 = sub_3DEC0(a1, a2, &v8, a3);
  while ( v6 == 1 );
  return v6 == 0;
}
// 99EE20: using guessed type int dword_99EE20;

//----- (0003DDB0) --------------------------------------------------------
void sub_3DDB0()
{
  free((void *)dword_99EE1C);
  dword_99EE1C = 0;
}
// 99EE1C: using guessed type int dword_99EE1C;

//----- (0003DDD0) --------------------------------------------------------
int sub_3DDD0(const char *a1, ...)
{
  va_list varg_r1; // [sp+14h] [bp-Ch] BYREF

  va_start(varg_r1, a1);
  vfprintf((FILE *)stderr, a1, varg_r1);
  return fputc(10, (FILE *)stderr);
}
// 7F790: using guessed type int stderr;

//----- (0003DE18) --------------------------------------------------------
void __noreturn sub_3DE18(const char *a1, ...)
{
  va_list varg_r1; // [sp+14h] [bp-Ch] BYREF

  va_start(varg_r1, a1);
  vfprintf((FILE *)stderr, a1, varg_r1);
  fputc(10, (FILE *)stderr);
  exit(1);
}
// 7F790: using guessed type int stderr;

//----- (0003DE58) --------------------------------------------------------
char *__fastcall sub_3DE58(const char *a1)
{
  size_t v2; // r0
  char *v3; // r4

  v2 = strlen(a1);
  v3 = (char *)malloc(v2 + 22);
  sprintf(v3, "Invalid argument '%s'", a1);
  return v3;
}

//----- (0003DE88) --------------------------------------------------------
void *__fastcall sub_3DE88(_DWORD *a1, int a2, int a3)
{
  void *result; // r0

  result = memmove((void *)(a2 + 4 * a3), (const void *)(a2 + 4 * a3 + 4), 4 * (*a1 - a3));
  --*a1;
  return result;
}

//----- (0003DEC0) --------------------------------------------------------
int __fastcall sub_3DEC0(_DWORD *a1, const char **a2, int *a3, void (*a4)(const char *, ...))
{
  bool v8; // zf
  int result; // r0
  const char **v10; // r6
  int *v11; // r3
  int v12; // r4
  int v13; // t1
  unsigned __int8 *v14; // r0
  int v15; // lr
  unsigned int v16; // r12
  int v17; // r1
  int v18; // r3
  char *v19; // r10
  int v20; // r3
  int v21; // r1
  char *v22; // r11
  int v23; // r10
  const char *v24; // r0
  int *v25; // r3
  const char *v26; // r7
  int *v27; // r11
  const char *v28; // r10
  size_t v29; // r4
  size_t v30; // lr
  int *v31; // r3
  const char *v32; // r11
  size_t v33; // r0
  int *v34; // r2
  const char *v35; // r11
  const char *v36; // r3
  size_t v37; // r10
  const char *v38; // [sp+8h] [bp-38h]
  int v39; // [sp+Ch] [bp-34h]
  unsigned int v40; // [sp+10h] [bp-30h] BYREF
  size_t n[11]; // [sp+14h] [bp-2Ch] BYREF

  v8 = getenv("POSIXLY_CORRECT") == 0;
  result = (int)a2[1];
  if ( !v8 )
  {
    v10 = a2 + 1;
    if ( !result )
      return result;
    if ( *(_BYTE *)result != 45 )
      return 0;
    v12 = 1;
    if ( *(_BYTE *)(result + 1) == 45 )
      goto LABEL_23;
LABEL_15:
    v14 = (unsigned __int8 *)sub_3DB7C(&v40);
    if ( v14 )
    {
      v15 = *a3 + 1;
      if ( *v14 == (unsigned __int8)(*v10)[v15] )
      {
LABEL_17:
        v16 = v40;
        v38 = (const char *)(v14 - 1);
        *a3 = v15;
        n[0] = 2;
        v17 = 28 * v16;
        v18 = dword_99EE1C + 28 * v16;
        if ( *(_DWORD *)(v18 + 4) != 1 )
        {
LABEL_18:
          if ( v15 )
          {
            v19 = (char *)&(*v10)[v15 + 1];
            if ( *v19 )
            {
              *a3 = 0;
              goto LABEL_20;
            }
          }
          v19 = (char *)a2[v12 + 1];
          if ( v19 )
            goto LABEL_20;
          a4("%s: %.*s: %s", *a2, n[0], v38, "requires an argument");
          return -1;
        }
LABEL_37:
        v19 = 0;
        v22 = (char *)(*(int (__fastcall **)(_DWORD))(v18 + 8))(*(_DWORD *)(v18 + 20));
        goto LABEL_38;
      }
      while ( 1 )
      {
        v14 = sub_3DBDC((int)v14, &v40);
        if ( !v14 )
          break;
        v15 = *a3 + 1;
        if ( (unsigned __int8)(*v10)[v15] == *v14 )
          goto LABEL_17;
      }
    }
LABEL_36:
    v33 = strlen(*v10);
    a4("%s: %.*s: %s", *a2, v33, *v10, "unrecognized option");
    return -1;
  }
  if ( !result )
    return result;
  if ( *(_BYTE *)result == 45 )
  {
    v10 = a2 + 1;
    v12 = 1;
  }
  else
  {
    v11 = (int *)(a2 + 2);
    v12 = 1;
    do
    {
      v10 = (const char **)v11;
      v13 = *v11++;
      result = v13;
      ++v12;
      if ( !v13 )
        return result;
    }
    while ( *(_BYTE *)result != 45 );
  }
  if ( *(_BYTE *)(result + 1) != 45 )
    goto LABEL_15;
LABEL_23:
  v23 = *(unsigned __int8 *)(result + 2);
  if ( !*(_BYTE *)(result + 2) )
  {
    sub_3DE88(a1, (int)a2, v12);
    return v23;
  }
  if ( *a3 )
    _assert_fail("*offset == 0", "ccan/opt/parse.c", 0x3Bu, "parse_one");
  v24 = sub_3DACC(&v40, n);
  if ( !v24 )
    goto LABEL_36;
  v25 = a3;
  v26 = v24;
  v27 = v25;
  v39 = v12;
  while ( 1 )
  {
    v28 = *v10;
    v29 = n[0];
    if ( strncmp(*v10 + 2, v26, n[0]) )
      goto LABEL_35;
    v30 = v29 + 2;
    if ( v28[v29 + 2] == 61 )
      break;
    if ( !v28[v29 + 2] )
    {
      v16 = v40;
      v31 = v27;
      v32 = v26;
      a3 = v31;
      v12 = v39;
      v38 = v32 - 2;
      v17 = 28 * v40;
      n[0] = v30;
      v18 = dword_99EE1C + 28 * v40;
      if ( *(_DWORD *)(v18 + 4) == 1 )
        goto LABEL_37;
      goto LABEL_34;
    }
LABEL_35:
    v26 = sub_3DB24((int)v26, &v40, n);
    if ( !v26 )
      goto LABEL_36;
  }
  v16 = v40;
  v34 = v27;
  v35 = v26;
  a3 = v34;
  v36 = v28;
  v37 = v29 + 3;
  v12 = v39;
  v17 = 28 * v40;
  v19 = (char *)&v36[v37];
  n[0] = v30;
  v38 = v35 - 2;
  v18 = dword_99EE1C + 28 * v40;
  if ( *(_DWORD *)(v18 + 4) == 1 )
  {
    if ( v19 )
    {
      a4("%s: %.*s: %s", *a2, v30, v38, "doesn't allow an argument");
      return -1;
    }
    goto LABEL_37;
  }
  if ( !v19 )
  {
LABEL_34:
    v15 = *a3;
    goto LABEL_18;
  }
LABEL_20:
  v20 = dword_99EE1C;
  v21 = dword_99EE1C + v17;
  if ( *(_DWORD *)(v21 + 4) == 4 )
  {
    sub_3D3D4((int)v19, *(_DWORD **)(v21 + 20));
    v16 = v40;
    v20 = dword_99EE1C;
  }
  v22 = (char *)(*(int (__fastcall **)(char *, _DWORD))(v20 + 28 * v16 + 12))(v19, *(_DWORD *)(v20 + 28 * v16 + 20));
LABEL_38:
  if ( v22 )
  {
    a4("%s: %.*s: %s", *a2, n[0], v38, v22);
    free(v22);
    return -1;
  }
  else
  {
    if ( *a3 )
    {
      if ( !(*v10)[*a3 + 1] )
      {
        *a3 = 0;
        goto LABEL_42;
      }
    }
    else
    {
LABEL_42:
      sub_3DE88(a1, (int)a2, v12);
      if ( v19 )
      {
        if ( *v10 == v19 )
          sub_3DE88(a1, (int)a2, v12);
      }
    }
    return 1;
  }
}
// 99EE1C: using guessed type int dword_99EE1C;

//----- (0003E370) --------------------------------------------------------
char *__fastcall sub_3E370(const char *a1, const char *a2)
{
  size_t v3; // r7
  int v4; // r4
  unsigned int v5; // r8
  size_t v6; // r7
  size_t v7; // r0
  size_t v8; // r7
  size_t v9; // r5
  const char *v10; // r11
  char *v11; // r0
  char *v12; // r4
  int v13; // r0
  char *v14; // r1
  char *v15; // r4
  char *v16; // r7
  char *v17; // r12
  int v18; // r8
  int v19; // r0
  int v20; // r2
  char *v21; // r5
  int v22; // r7
  unsigned int v23; // r8
  int v24; // r2
  unsigned int v25; // r4
  unsigned int v26; // r4
  char *v27; // r3
  int v28; // r3
  const char *v29; // r2
  int v30; // r0
  unsigned int v31; // r4
  char *v32; // r3
  char *v33; // r0
  char *v34; // r0
  int v36; // r2
  int v37; // r3
  __int16 *v39; // [sp+0h] [bp-98h]
  const char *v40; // [sp+4h] [bp-94h]
  char *s; // [sp+8h] [bp-90h]
  char *v42; // [sp+10h] [bp-88h]
  char *v43; // [sp+14h] [bp-84h]
  unsigned int v44[31]; // [sp+1Ch] [bp-7Ch] BYREF

  v3 = dword_99EE18 + 20 + strlen(a1);
  if ( a2 )
  {
    v3 += strlen(a2);
    if ( !dword_99EE24 )
      goto LABEL_13;
    v4 = dword_99EE1C;
  }
  else
  {
    if ( !dword_99EE24 )
    {
      a2 = "";
      goto LABEL_13;
    }
    v36 = 0;
    v4 = dword_99EE1C;
    v37 = dword_99EE1C;
    do
    {
      ++v36;
      if ( *(void (__fastcall __noreturn **)(int))(v37 + 8) == sub_3D5F0 )
      {
        a2 = *(const char **)(v37 + 20);
        if ( a2 )
        {
          v3 += strlen(*(const char **)(v37 + 20));
          goto LABEL_4;
        }
      }
      v37 += 28;
    }
    while ( v36 != dword_99EE24 );
    a2 = "";
  }
LABEL_4:
  v5 = 0;
  v40 = a2;
  do
  {
    while ( 1 )
    {
      v9 = v3 + 6;
      v10 = *(const char **)(v4 + 24);
      if ( *(_DWORD *)(v4 + 4) != 8 )
        break;
      ++v5;
      v3 += strlen(*(const char **)(v4 + 24)) + 3;
      v4 += 28;
      if ( v5 >= dword_99EE24 )
        goto LABEL_12;
    }
    if ( v10 != (const char *)&unk_99EE28 )
    {
      v6 = strlen(*(const char **)v4);
      v7 = v6 + v9 + strlen(v10);
      v8 = v7 + 118;
      if ( !*(_DWORD *)(v4 + 16) )
        v8 = v7 + 21;
      v3 = v8 + 1;
    }
    ++v5;
    v4 += 28;
  }
  while ( v5 < dword_99EE24 );
LABEL_12:
  a2 = v40;
LABEL_13:
  v11 = (char *)malloc(v3);
  v12 = v11;
  v43 = v11;
  if ( v11 )
  {
    v13 = sprintf(v11, "Usage: %s", a1);
    v14 = v12;
    v15 = &v12[v13];
    v16 = v15 + 3;
    *(_DWORD *)&v14[v13] = &unk_2D5B20;
    v17 = (char *)sub_3DB7C(v44);
    if ( v17 )
    {
      v18 = 0;
      do
      {
        if ( *(_UNKNOWN **)(dword_99EE1C + 28 * v44[0] + 24) != &unk_99EE28 )
          v16[v18++] = *v17;
        v17 = sub_3DBDC((int)v17, v44);
      }
      while ( v17 );
      if ( v18 )
      {
        v15 = &v16[v18 + 1];
        *(_WORD *)&v16[v18] = 93;
      }
    }
    v19 = sprintf(v15, " %s", a2);
    v20 = dword_99EE24;
    v39 = &word_6A02C;
    v21 = &v15[v19 + 1];
    *(_WORD *)&v15[v19] = 10;
    if ( v20 )
    {
      v22 = 0;
      v23 = 0;
      do
      {
        v28 = dword_99EE1C + v22;
        v29 = *(const char **)(dword_99EE1C + v22 + 24);
        if ( v29 != (const char *)&unk_99EE28 )
        {
          if ( *(_DWORD *)(v28 + 4) == 8 )
          {
            v21 += sprintf(v21, "%s:\n", v29);
          }
          else
          {
            v30 = sprintf(v21, "%s", *(const char **)v28);
            v31 = v30;
            v32 = &v21[v30];
            if ( *(_DWORD *)(dword_99EE1C + v22 + 4) == 2 )
            {
              v42 = &v21[v30];
              s = *(char **)(dword_99EE1C + v22);
              v33 = strchr(s, 32);
              v32 = v42;
              if ( !v33 )
              {
                v34 = strchr(s, 61);
                v32 = v42;
                if ( !v34 )
                {
                  v31 += 6;
                  strcpy(v42, " <arg>");
                  v32 = &v21[v31];
                }
              }
            }
            if ( v31 > 0x13 )
              v24 = 1;
            else
              v24 = 20 - v31;
            v25 = sprintf(v32, "%.*s", v24, "                    ", v39) + v31;
            v26 = sprintf(&v21[v25], "%s", *(const char **)(dword_99EE1C + v22 + 24)) + v25;
            v27 = &v21[v26];
            if ( *(_DWORD *)(dword_99EE1C + v22 + 16) )
            {
              v44[20] = (unsigned int)&unk_2E2E2E;
              (*(void (__fastcall **)(unsigned int *, _DWORD))(dword_99EE1C + v22 + 16))(
                v44,
                *(_DWORD *)(dword_99EE1C + v22 + 20));
              v27 = &v21[sprintf(&v21[v26], " (default: %s)", (const char *)v44) + v26];
            }
            *(_WORD *)v27 = *v39;
            v21 = v27 + 1;
          }
        }
        ++v23;
        v22 += 28;
      }
      while ( dword_99EE24 > v23 );
    }
    *v21 = 0;
  }
  return v43;
}
// 3E59C: variable 'v39' is possibly undefined
// 6A02C: using guessed type __int16 word_6A02C;
// 6BB38: using guessed type __int16 word_6BB38;
// 99EE18: using guessed type int dword_99EE18;
// 99EE1C: using guessed type int dword_99EE1C;
// 99EE24: using guessed type int dword_99EE24;

//----- (0003E7B4) --------------------------------------------------------
char *__fastcall memchr(char *result, __int16 a2, unsigned int a3)
{
  char *v3; // r3
  int v5; // r4
  char *v6; // r12
  char *v7; // r2
  char *v8; // r3

  if ( !a3 )
    return 0;
  if ( ((unsigned __int8)result & 3) != 0 )
  {
    if ( (unsigned __int8)*result == (unsigned __int8)a2 )
      return result;
    v3 = result + 1;
    while ( 1 )
    {
      --a3;
      result = v3;
      if ( !a3 )
        return 0;
      if ( ((unsigned __int8)v3++ & 3) == 0 )
        break;
      if ( (unsigned __int8)*result == (unsigned __int8)a2 )
        return result;
    }
  }
  v5 = (unsigned __int16)(a2 << 8) | (unsigned __int8)a2 | (((unsigned __int16)(a2 << 8) | (unsigned __int8)a2) << 16);
  if ( a3 > 3 && (((*(_DWORD *)result ^ v5) - 16843009) & ~(*(_DWORD *)result ^ v5) & 0x80808080) == 0 )
  {
    v6 = result + 4;
    while ( 1 )
    {
      a3 -= 4;
      result = v6;
      v6 += 4;
      if ( a3 <= 3 )
        break;
      if ( (((*(_DWORD *)result ^ v5) - 16843009) & ~(*(_DWORD *)result ^ v5) & 0x80808080) != 0 )
        goto LABEL_16;
    }
    if ( !a3 )
      return 0;
  }
LABEL_16:
  if ( (unsigned __int8)*result != (unsigned __int8)a2 )
  {
    v7 = &result[a3];
    v8 = result + 1;
    while ( 1 )
    {
      result = v8++;
      if ( result == v7 )
        break;
      if ( (unsigned __int8)*result == (unsigned __int8)a2 )
        return result;
    }
    return 0;
  }
  return result;
}

//----- (0003E8C8) --------------------------------------------------------
unsigned int __fastcall sub_3E8C8(int a1, unsigned int a2, int *a3)
{
  int v3; // r6
  int v4; // r12
  unsigned int v5; // r4
  int v6; // lr
  unsigned int v7; // r3
  int v8; // r5
  unsigned int v9; // r5
  unsigned int v10; // r7
  int v11; // r8
  unsigned int v12; // r4
  int v13; // r12
  int v14; // r5
  unsigned int v15; // r3
  int v16; // r6
  unsigned int v17; // r6
  unsigned int v18; // r7
  unsigned int result; // r0
  unsigned int v20; // r5
  bool v21; // zf

  v3 = 1;
  v4 = 1;
  v5 = 0;
  v6 = -1;
  while ( 1 )
  {
    v7 = v4 + v5;
    v8 = a1 + v6;
    if ( v4 + v5 >= a2 )
      break;
    while ( 1 )
    {
      v9 = *(unsigned __int8 *)(v8 + v4);
      v10 = *(unsigned __int8 *)(a1 + v7);
      if ( v10 >= v9 )
        break;
      v5 = v7;
      v4 = 1;
      v3 = v7 - v6;
      ++v7;
      v8 = a1 + v6;
      if ( v7 >= a2 )
        goto LABEL_5;
    }
    if ( v10 == v9 )
    {
      v21 = v4++ == v3;
      if ( v21 )
      {
        v5 = v7;
        v4 = 1;
      }
    }
    else
    {
      v3 = 1;
      v6 = v5;
      v4 = 1;
      ++v5;
    }
  }
LABEL_5:
  v11 = 1;
  v12 = 0;
  v13 = 1;
  v14 = -1;
  *a3 = v3;
  while ( 1 )
  {
    v15 = v13 + v12;
    v16 = a1 + v14;
    if ( a2 <= v13 + v12 )
      break;
    while ( 1 )
    {
      v17 = *(unsigned __int8 *)(v16 + v13);
      v18 = *(unsigned __int8 *)(a1 + v15);
      if ( v18 <= v17 )
        break;
      v12 = v15;
      v13 = 1;
      v11 = v15 - v14;
      ++v15;
      v16 = a1 + v14;
      if ( a2 <= v15 )
        goto LABEL_9;
    }
    if ( v18 == v17 )
    {
      v21 = v13++ == v11;
      if ( v21 )
      {
        v12 = v15;
        v13 = 1;
      }
    }
    else
    {
      v11 = 1;
      v14 = v12;
      v13 = 1;
      ++v12;
    }
  }
LABEL_9:
  result = v6 + 1;
  v20 = v14 + 1;
  if ( v20 >= v6 + 1 )
  {
    *a3 = v11;
    return v20;
  }
  return result;
}

//----- (0003E9D8) --------------------------------------------------------
int __fastcall sub_3E9D8(int a1, int a2, void *s1, unsigned int a4)
{
  unsigned int v8; // r4
  unsigned int v9; // r6
  int *v10; // r3
  char *v11; // r1
  int v12; // r3
  int v13; // t1
  unsigned int v14; // r0
  unsigned int v15; // r3
  bool v16; // cf
  unsigned int v17; // r1
  unsigned int v18; // r1
  char *v19; // lr
  unsigned __int8 *v20; // r12
  int v21; // r9
  int v22; // t1
  int v23; // t1
  unsigned int v24; // lr
  unsigned __int8 *v25; // r1
  char *v26; // r8
  int v27; // r10
  int v28; // t1
  int v29; // t1
  int result; // r0
  unsigned int v31; // r3
  unsigned int v32; // r2
  unsigned int v33; // r10
  unsigned int v34; // r9
  int v35; // r3
  unsigned __int8 *v36; // r1
  unsigned int v37; // r3
  char *v38; // r12
  int v39; // r8
  int v40; // t1
  int v41; // t1
  unsigned __int8 *v42; // r3
  char *v43; // r1
  int v44; // lr
  int v45; // t1
  int v46; // t1
  unsigned int v47; // [sp+0h] [bp-448h]
  unsigned int v48; // [sp+4h] [bp-444h]
  int v49; // [sp+4h] [bp-444h]
  unsigned int v50; // [sp+Ch] [bp-43Ch]
  int v51[253]; // [sp+1Ch] [bp-42Ch] BYREF
  int v52; // [sp+41Ch] [bp-2Ch] BYREF

  v8 = a4 - 1;
  if ( a4 > 2 )
  {
    v9 = sub_3E8C8((int)s1, a4, v51);
    v48 = v51[0];
  }
  else
  {
    v9 = a4 - 1;
    v48 = 1;
    v51[0] = 1;
  }
  v10 = v51;
  do
  {
    v10[1] = a4;
    ++v10;
  }
  while ( v10 != &v52 );
  if ( a4 )
  {
    v11 = (char *)s1 - 1;
    v12 = v8;
    do
    {
      v13 = (unsigned __int8)*++v11;
      v51[v13 + 1] = v12;
      v16 = v12-- != 0;
    }
    while ( v16 );
  }
  v14 = memcmp(s1, (char *)s1 + v48, v9);
  if ( !v14 )
  {
    v47 = a2 - a4;
    v50 = a4 - v48;
    v15 = 0;
    while ( 1 )
    {
      while ( 1 )
      {
        v17 = v51[*(unsigned __int8 *)(a1 + v15 + v8) + 1];
        if ( v17 )
        {
          v16 = 1;
          if ( v14 )
            v16 = v17 >= v48;
          v14 = 0;
          if ( !v16 )
            v17 = v50;
          v15 += v17;
          goto LABEL_15;
        }
        v18 = v9 < v14 ? v14 : v9;
        if ( v18 < v8 )
          break;
LABEL_25:
        v24 = v9 - 1;
        if ( v9 > v14 && (v25 = (unsigned __int8 *)(a1 + v9 - 1 + v15), *((unsigned __int8 *)s1 + v9 - 1) == *v25) )
        {
          v26 = (char *)s1 + v9 - 1;
          while ( v24 - 1 != v14 - 1 )
          {
            v28 = (unsigned __int8)*--v26;
            v27 = v28;
            v29 = *--v25;
            if ( v27 != v29 )
              break;
            --v24;
          }
        }
        else
        {
          v24 = v9;
        }
        if ( v14 + 1 > v24 )
          return a1 + v15;
        v14 = v50;
        v15 += v48;
        if ( v47 < v15 )
          return 0;
      }
      v19 = (char *)s1 + v18;
      v20 = (unsigned __int8 *)(a1 + v18 + v15);
      if ( *v20 == *((unsigned __int8 *)s1 + v18) )
      {
        while ( ++v18 < v8 )
        {
          v22 = (unsigned __int8)*++v19;
          v21 = v22;
          v23 = *++v20;
          if ( v21 != v23 )
            goto LABEL_35;
        }
        goto LABEL_25;
      }
LABEL_35:
      v14 = 0;
      v15 += v18 + 1 - v9;
LABEL_15:
      if ( v47 < v15 )
        return 0;
    }
  }
  v31 = a4 - v9;
  v32 = v9 - 1;
  v33 = a2 - a4;
  if ( a4 - v9 < v9 )
    v31 = v9;
  v34 = 0;
  v49 = v31 + 1;
  while ( 1 )
  {
    result = a1 + v34;
    v35 = v51[*(unsigned __int8 *)(a1 + v34 + v8) + 1];
    if ( !v35 )
      break;
LABEL_52:
    v34 += v35;
LABEL_53:
    if ( v34 > v33 )
      return 0;
  }
  if ( v9 < v8 )
  {
    v36 = (unsigned __int8 *)(a1 + v9 + v34);
    if ( *v36 != *((unsigned __int8 *)s1 + v9) )
    {
      v37 = v9;
LABEL_55:
      v34 += v37 + 1 - v9;
      goto LABEL_53;
    }
    v38 = (char *)s1 + v9;
    v37 = v9;
    while ( ++v37 < v8 )
    {
      v40 = (unsigned __int8)*++v38;
      v39 = v40;
      v41 = *++v36;
      if ( v39 != v41 )
        goto LABEL_55;
    }
  }
  if ( !v9 )
    return result;
  v42 = (unsigned __int8 *)(a1 + v32 + v34);
  if ( *v42 != *((unsigned __int8 *)s1 + v32) )
  {
LABEL_51:
    v35 = v49;
    goto LABEL_52;
  }
  v43 = (char *)s1 + v32;
  while ( v43 != s1 )
  {
    v45 = (unsigned __int8)*--v43;
    v44 = v45;
    v46 = *--v42;
    if ( v44 != v46 )
      goto LABEL_51;
  }
  return result;
}

//----- (0003ED04) --------------------------------------------------------
int __fastcall memmem(char *a1, unsigned int a2, unsigned __int8 *a3, unsigned int a4)
{
  char *v6; // r5
  char *v9; // r0
  _BOOL4 v10; // r3
  unsigned int v11; // r7
  unsigned int v12; // r6
  unsigned int v13; // r0
  unsigned int v14; // r2
  unsigned int v15; // r12
  unsigned int v16; // r3
  unsigned __int8 *v17; // lr
  char *v18; // r1
  int v19; // r8
  int v20; // t1
  int v21; // t1
  unsigned int v22; // lr
  char *v23; // r3
  unsigned __int8 *v24; // r7
  int v25; // r9
  int v26; // t1
  int v27; // t1
  unsigned int v29; // r3
  unsigned int v30; // r9
  unsigned int v31; // r0
  unsigned int v32; // r7
  char *v33; // r2
  unsigned int v34; // r3
  unsigned __int8 *v35; // r1
  int v36; // lr
  int v37; // t1
  int v38; // t1
  char *v39; // r3
  unsigned __int8 *v40; // r2
  int v41; // r12
  int v42; // t1
  int v43; // t1
  int v44; // [sp+4h] [bp-44h]
  int v45; // [sp+8h] [bp-40h]
  int v46; // [sp+1Ch] [bp-2Ch] BYREF

  if ( !a4 )
    return (int)a1;
  if ( a4 > a2 )
    return 0;
  if ( a4 > 0x1F )
    return sub_3E9D8((int)a1, a2, a3, a4);
  v9 = memchr(a1, *a3, a2);
  v6 = v9;
  v10 = a4 == 1;
  if ( !v9 )
    v10 = 1;
  if ( v10 )
    return (int)v6;
  v11 = a2 - (v9 - a1);
  if ( a4 > v11 )
    return 0;
  if ( a4 > 2 )
  {
    v12 = sub_3E8C8((int)a3, a4, &v46);
    v45 = v46;
  }
  else
  {
    v12 = a4 - 1;
    v45 = 1;
    v46 = 1;
  }
  v13 = memcmp(a3, &a3[v45], v12);
  if ( !v13 )
  {
    v14 = v11 - a4;
    v15 = 0;
    while ( 1 )
    {
      if ( v12 < v15 )
        v16 = v15;
      else
        v16 = v12;
      if ( a4 > v16 )
      {
        v17 = &a3[v16];
        v18 = &v6[v16 + v13];
        if ( a3[v16] != (unsigned __int8)*v18 )
        {
LABEL_32:
          v15 = 0;
          v13 += 1 - v12 + v16;
          goto LABEL_29;
        }
        while ( a4 != ++v16 )
        {
          v20 = *++v17;
          v19 = v20;
          v21 = (unsigned __int8)*++v18;
          if ( v19 != v21 )
            goto LABEL_32;
        }
      }
      v22 = v12 - 1;
      if ( v12 > v15 && (v23 = &v6[v12 - 1 + v13], a3[v12 - 1] == (unsigned __int8)*v23) )
      {
        v24 = &a3[v12 - 1];
        while ( v22 - 1 != v15 - 1 )
        {
          v26 = *--v24;
          v25 = v26;
          v27 = (unsigned __int8)*--v23;
          if ( v25 != v27 )
            break;
          --v22;
        }
      }
      else
      {
        v22 = v12;
      }
      if ( v15 + 1 > v22 )
      {
        v6 += v13;
        return (int)v6;
      }
      v15 = a4 - v45;
      v13 += v45;
LABEL_29:
      if ( v14 < v13 )
        return 0;
    }
  }
  v29 = a4 - v12;
  v30 = v12 - 1;
  v31 = v11 - a4;
  if ( a4 - v12 < v12 )
    v29 = v12;
  v32 = 0;
  v44 = v29 + 1;
  while ( 1 )
  {
    if ( a4 > v12 )
    {
      v33 = &v6[v12 + v32];
      if ( (unsigned __int8)*v33 != a3[v12] )
      {
        v34 = v12;
LABEL_49:
        v32 += 1 - v12 + v34;
        goto LABEL_50;
      }
      v35 = &a3[v12];
      v34 = v12;
      while ( a4 != ++v34 )
      {
        v37 = *++v35;
        v36 = v37;
        v38 = (unsigned __int8)*++v33;
        if ( v36 != v38 )
          goto LABEL_49;
      }
    }
    if ( !v12 )
      return (int)&v6[v32];
    v39 = &v6[v30 + v32];
    if ( (unsigned __int8)*v39 == a3[v30] )
      break;
LABEL_52:
    v32 += v44;
LABEL_50:
    if ( v31 < v32 )
      return 0;
  }
  v40 = &a3[v30];
  while ( v40 != a3 )
  {
    v42 = *--v40;
    v41 = v42;
    v43 = (unsigned __int8)*--v39;
    if ( v41 != v43 )
      goto LABEL_52;
  }
  return (int)&v6[v32];
}

//----- (0003EFF0) --------------------------------------------------------
int __fastcall sub_3EFF0(int a1, int a2)
{
  const char *v3; // r0
  const char *v4; // r0
  int v5; // r7
  int v6; // r8
  int v7; // r6
  _DWORD *v8; // r0
  int v9; // r4
  int v10; // r5
  int v11; // r11
  unsigned int v12; // r11
  unsigned int v13; // r0
  double *v14; // r3
  double *v15; // r4
  double v16; // d3
  double v17; // d4
  double v18; // d6
  double v19; // d5
  int v20; // r11
  _DWORD *v21; // r0
  int v22; // r10
  unsigned int v23; // r4
  _DWORD *v24; // r0
  unsigned int v25; // r5
  int v26; // r0
  bool v27; // zf
  double *v28; // r12
  int v30; // r8
  unsigned int v31; // r5
  int v32; // r4
  _QWORD *v33; // r6
  int v34; // r0
  int v35; // r7
  int v36; // r11
  int v37; // r4
  _DWORD *v38; // r0
  int v39; // r5
  int v40; // r8
  int v41; // r9
  unsigned int v42; // r9
  unsigned int v43; // r0
  double *v44; // r12
  _DWORD *v45; // r0
  char *i; // r6
  int v47; // r5
  int v48; // r8
  int j; // r4
  int v50; // r3
  _DWORD *v51; // r0
  double v52; // [sp+0h] [bp-3110h]
  double v53; // [sp+8h] [bp-3108h]
  double v54; // [sp+10h] [bp-3100h]
  double v55; // [sp+18h] [bp-30F8h]
  double v56; // [sp+28h] [bp-30E8h]
  char *format; // [sp+38h] [bp-30D8h]
  char *formata; // [sp+38h] [bp-30D8h]
  char *v60; // [sp+40h] [bp-30D0h]
  char *v61; // [sp+40h] [bp-30D0h]
  int v62; // [sp+44h] [bp-30CCh]
  unsigned int v63; // [sp+4Ch] [bp-30C4h]
  char v64[128]; // [sp+50h] [bp-30C0h] BYREF
  _QWORD s[510]; // [sp+D0h] [bp-3040h] BYREF
  _OWORD v66[516]; // [sp+10D0h] [bp-2040h] BYREF

  memset(v66, 0, 0x2000u);
  v3 = (const char *)sub_1E0C0();
  if ( strcmp(v3, "BHB28601") )
  {
    v4 = (const char *)sub_1E0C0();
    if ( strcmp(v4, "BHB28701") )
    {
      v30 = sub_1E0F0();
      if ( v30 )
      {
        v31 = 0;
        v32 = 0;
        v33 = s;
        do
        {
          v34 = v32++;
          if ( !sub_14ED0(v34) )
          {
            sub_5146C((unsigned __int8)a1, v31);
            usleep(0x1388u);
            sub_51508((unsigned __int8)a1, v31);
            usleep(0x2710u);
            *v33 = 0LL;
          }
          v31 += a2;
          ++v33;
        }
        while ( v30 != v32 );
      }
      usleep(0x186A0u);
      v61 = (char *)sub_1E0E0();
      if ( !v61 )
      {
LABEL_50:
        formata = (char *)sub_1E0E0();
        if ( formata )
        {
          for ( i = 0; i != formata; ++i )
          {
            v47 = sprintf(v64, "domain %2d:", i);
            v48 = sub_1E100();
            if ( v48 )
            {
              for ( j = 0; j != v48; ++j )
              {
                v50 = j + (_DWORD)i * sub_1E100();
                v47 += sprintf(&v64[v47], "\t%.2f", *(double *)&s[v50]);
              }
            }
            v51 = (_DWORD *)dword_4FCB48;
            if ( !dword_4FCB48 )
            {
              v51 = sub_536F4("bmminer_adc");
              dword_4FCB48 = (int)v51;
            }
            sub_54CB0(
              (int)v51,
              "log/adc_sample.c",
              16,
              (int)"check_adc_voltage",
              17,
              169,
              20,
              (int)"chain %2d %s",
              a1,
              v64);
          }
        }
        goto LABEL_30;
      }
      v35 = 0;
      while ( 1 )
      {
        v36 = sub_1E100();
        if ( v36 )
          break;
LABEL_49:
        if ( v61 == (char *)++v35 )
          goto LABEL_50;
      }
      v37 = 0;
      while ( 1 )
      {
        while ( 1 )
        {
          v39 = v37 + v35 * sub_1E100();
          if ( !sub_14ED0(v39) )
            break;
LABEL_43:
          if ( v36 == ++v37 )
            goto LABEL_49;
        }
        v40 = v39 * a2;
        memset(v64, 0, sizeof(v64));
        v41 = sub_2C06C(176, v39 * a2, a1);
        if ( (v41 & 4) == 0 )
        {
          v38 = (_DWORD *)dword_4FCB48;
          if ( !dword_4FCB48 )
          {
            v38 = sub_536F4("bmminer_adc");
            dword_4FCB48 = (int)v38;
          }
          sub_54CB0(
            (int)v38,
            "log/adc_sample.c",
            16,
            (int)"check_adc_voltage",
            17,
            141,
            20,
            (int)"chain::%d, asic::%d adc control vm sample not ready %08x.\n",
            a1,
            v39,
            v41);
          goto LABEL_43;
        }
        v42 = sub_2C06C(180, v40, a1);
        v43 = sub_2C06C(184, v40, a1);
        v44 = (double *)&v66[2 * v39];
        v52 = (float)((float)(v42 & 0xFFF) * 0.00048828) * 1.18800008 - 1.18800008;
        v53 = (float)((float)(HIWORD(v42) & 0xFFF) * 0.00048828) * 1.18800008 - 1.18800008;
        v54 = (float)((float)(v43 & 0xFFF) * 0.00048828) * 1.18800008 - 1.18800008;
        v55 = (float)((float)(HIWORD(v43) & 0xFFF) * 0.00048828) * 1.18800008 - 1.18800008;
        v44[3] = v55;
        *v44 = v52;
        v44[1] = v53;
        v44[2] = v54;
        v56 = (v52 + v53 + v54 + v55) * 0.25;
        *(double *)&s[v39] = v56;
        sprintf(
          v64,
          "chain %2d asic %03d adc:\t%.2f\t%.2f\t%.2f\t%.2f\t%.2f\t%.2f",
          a1,
          v39,
          v52,
          v53,
          v54,
          v55,
          v52 + v53 + v54 + v55,
          v56);
        v45 = (_DWORD *)dword_4FCB48;
        if ( !dword_4FCB48 )
        {
          v45 = sub_536F4("bmminer_adc");
          dword_4FCB48 = (int)v45;
        }
        ++v37;
        sub_54CB0((int)v45, "log/adc_sample.c", 16, (int)"check_adc_voltage", 17, 157, 20, (int)"asic adc:%s", v64);
        if ( v36 == v37 )
          goto LABEL_49;
      }
    }
  }
  v63 = (unsigned __int8)a1;
  pthread_mutex_lock(&stru_7F7EC);
  sub_16330(1);
  usleep(0x4E20u);
  sub_51478((unsigned __int8)a1);
  usleep(0x4E20u);
  sub_514A4((unsigned __int8)a1);
  usleep(0x4E20u);
  format = (char *)sub_1E0E0();
  if ( format )
  {
    v5 = 0;
    while ( 1 )
    {
      v6 = sub_1E100();
      if ( v6 )
        break;
LABEL_14:
      if ( format == (char *)++v5 )
        goto LABEL_15;
    }
    v7 = 0;
    while ( 1 )
    {
      while ( 1 )
      {
        v9 = v7 + v5 * sub_1E100();
        v10 = v9 * sub_1E160();
        if ( !sub_14ED0(v9) )
          break;
LABEL_10:
        if ( v6 == ++v7 )
          goto LABEL_14;
      }
      v11 = sub_2C06C(176, v10, a1);
      if ( (v11 & 4) == 0 )
      {
        v8 = (_DWORD *)dword_4FCB48;
        if ( !dword_4FCB48 )
        {
          v8 = sub_536F4("bmminer_adc");
          dword_4FCB48 = (int)v8;
        }
        sub_54CB0(
          (int)v8,
          "log/adc_sample.c",
          16,
          (int)"get_adc_data_with_addr",
          22,
          45,
          20,
          (int)"chain::%d, asic::%d adc control vm sample not ready %08x.\n",
          a1,
          v9,
          v11);
        goto LABEL_10;
      }
      v12 = sub_2C06C(180, v10, a1);
      v13 = sub_2C06C(184, v10, a1);
      ++v7;
      v14 = (double *)&v66[512] + v9;
      v15 = (double *)&v66[2 * v9];
      v16 = (double)(v12 & 0xFFF) * 1.6 * 0.00048828125 - 1.6;
      v17 = (double)(HIWORD(v12) & 0xFFF) * 1.6 * 0.00048828125 - 1.6;
      v18 = (double)(HIWORD(v13) & 0xFFF) * 1.6 * 0.00048828125 - 1.6;
      *v15 = v16;
      v19 = (double)(v13 & 0xFFF) * 1.6 * 0.00048828125 - 1.6;
      *(v14 - 1280) = v18;
      v15[1] = v17 - v16;
      v15[2] = v19 - v17;
      v15[3] = v18 - v19;
      if ( v6 == v7 )
        goto LABEL_14;
    }
  }
LABEL_15:
  v62 = sub_1E0E0();
  if ( !v62 )
    goto LABEL_29;
  v20 = 0;
  v60 = (char *)a1;
  do
  {
    v21 = (_DWORD *)dword_4FCB48;
    if ( !dword_4FCB48 )
    {
      v21 = sub_536F4("bmminer_adc");
      dword_4FCB48 = (int)v21;
    }
    sub_54CB0((int)v21, "log/adc_sample.c", 16, (int)"dump_adc_voltage", 16, 67, 20, (int)"[C: %d], [D: %d]", v60, v20);
    v22 = sub_1E100();
    if ( v22 )
    {
      v23 = 0;
      do
      {
        memset(s, 0, 0x100u);
        v25 = v23 + v20 * sub_1E100();
        v26 = sub_1E100();
        v27 = sub_5F880(v23, v26 - 1) == 1;
        v28 = (double *)&v66[2 * v25];
        if ( v27 )
        {
          ++v23;
          snprintf(
            (char *)s,
            0x100u,
            "{I} %2d: d0 %.3f, d1 %.3f, d2 %.3f, d3 %.3f, sum = %f\n",
            v25,
            *(_DWORD *)v28,
            *((_DWORD *)v28 + 1),
            *((_DWORD *)v28 + 2),
            *((_DWORD *)v28 + 3),
            *((_DWORD *)v28 + 4),
            *((_DWORD *)v28 + 5),
            *((_DWORD *)v28 + 6),
            *((_DWORD *)v28 + 7),
            LODWORD(s[v25 + 256]),
            HIDWORD(s[v25 + 256]));
          v24 = (_DWORD *)dword_4FCB48;
          if ( !dword_4FCB48 )
          {
LABEL_26:
            v24 = sub_536F4("bmminer_adc");
            dword_4FCB48 = (int)v24;
          }
        }
        else
        {
          ++v23;
          snprintf(
            (char *)s,
            0x100u,
            "{I} %2d: d0 %.3f, d1 %.3f, d2 %.3f, d3 %.3f, sum = %f",
            v25,
            *v28,
            v28[1],
            v28[2],
            v28[3],
            *(double *)&s[v25 + 256]);
          v24 = (_DWORD *)dword_4FCB48;
          if ( !dword_4FCB48 )
            goto LABEL_26;
        }
        sub_54CB0((int)v24, "log/adc_sample.c", 16, (int)"dump_adc_voltage", 16, 81, 20, (int)"%s", (const char *)s);
      }
      while ( v22 != v23 );
    }
    ++v20;
  }
  while ( v62 != v20 );
  a1 = (int)v60;
LABEL_29:
  sub_513FC(v63);
  usleep(0x4E20u);
  sub_16330(0);
  usleep(0x4E20u);
  pthread_mutex_unlock(&stru_7F7EC);
LABEL_30:
  pthread_mutex_lock(&stru_4FCB4C);
  memcpy((char *)&unk_4FCB68 + 0x2000 * a1, v66, 0x2000u);
  pthread_mutex_unlock(&stru_4FCB4C);
  return 0;
}
// 7F7EC: using guessed type pthread_mutex_t stru_7F7EC;
// 4FCB48: using guessed type int dword_4FCB48;
// 3EFF0: using guessed type char var_30C0[128];

//----- (0003F92C) --------------------------------------------------------
void sub_3F92C()
{
  ;
}

//----- (0003F970) --------------------------------------------------------
int __fastcall sub_3F970(int result, int a2)
{
  bool v2; // cc
  int v4; // r5
  double v5; // d0
  double *v6; // r1
  int v7; // r3
  double v8; // d7

  v2 = result <= 3;
  if ( result <= 3 )
    v2 = a2 <= 255;
  if ( v2 )
  {
    v4 = result;
    pthread_mutex_lock(&stru_4FCB4C);
    v5 = 0.0;
    v6 = (double *)((char *)&unk_4FCB68 + 0x2000 * v4 + 32 * a2);
    v7 = 4;
    do
    {
      v8 = *v6++;
      --v7;
      v5 = v5 + v8;
    }
    while ( v7 );
    return pthread_mutex_unlock(&stru_4FCB4C);
  }
  return result;
}

//----- (0003F9EC) --------------------------------------------------------
int __fastcall sub_3F9EC(int result, int a2)
{
  bool v2; // cc
  int v4; // r5
  double v5; // d8
  double *v6; // r1
  int v7; // r3
  double v8; // d7

  v2 = result <= 3;
  if ( result <= 3 )
    v2 = a2 <= 255;
  if ( v2 )
  {
    v4 = result;
    pthread_mutex_lock(&stru_4FCB4C);
    v5 = 0.0;
    v6 = (double *)((char *)&unk_4FCB68 + 0x2000 * v4 + 32 * a2);
    v7 = 4;
    do
    {
      v8 = *v6++;
      --v7;
      v5 = v5 + v8;
    }
    while ( v7 );
    return pthread_mutex_unlock(&stru_4FCB4C);
  }
  return result;
}

//----- (0003FB58) --------------------------------------------------------
unsigned int sub_3FB58()
{
  unsigned int result; // r0
  int v1; // r12
  int v2; // r1
  int v3; // lr
  int v4; // r3
  int *v5; // r2
  int v6; // r5
  unsigned int v7; // r2
  int *v8; // r3
  unsigned int v9; // [sp+4h] [bp-82Ch] BYREF
  char s[2088]; // [sp+8h] [bp-828h] BYREF

  v9 = 0;
  memset(dword_504B68, 0, sizeof(dword_504B68));
  sub_40314(2, &v9);
  if ( !v9 )
  {
    strcpy(s, "Cannot Find Any Plug In!\r\n");
    return sub_2E584(0, s, 0);
  }
  if ( (v9 & 0x80000000) != 0 )
  {
    v9 >>= 24;
    dword_504C8C = 1;
    snprintf(s, 0x800u, "HASH_ON_PLUG T9 = 0x%x\n", v9);
    result = sub_2E584(2, s, 0);
    v7 = v9;
    if ( !v9 )
      return result;
    v1 = dword_504B68[0];
    v2 = 0;
    result = 0;
    do
    {
      v8 = &dword_504B68[18 * v1];
      if ( (v7 & 1) != 0 )
      {
        v8[1] = result;
        if ( result == 1 )
        {
          v8[3] = 2;
          v8[4] = 10;
          v8[5] = 11;
          v8[2] = 3;
        }
        else if ( result )
        {
          if ( result == 2 )
          {
            v8[3] = 3;
            v8[4] = 12;
            v8[5] = 13;
            v8[2] = 3;
          }
        }
        else
        {
          v8[3] = 1;
          v8[4] = 8;
          v8[5] = 9;
          v8[2] = 3;
        }
        ++v1;
        v2 = 1;
      }
      v7 >>= 1;
      ++result;
    }
    while ( v7 );
  }
  else
  {
    dword_504C8C = 0;
    v9 = (unsigned __int16)v9;
    snprintf(s, 0x800u, "HASH_ON_PLUG V9 = 0x%x\n", (unsigned __int16)v9);
    sub_2E584(2, s, 0);
    result = v9;
    if ( !v9 )
      return result;
    v1 = dword_504B68[0];
    v2 = 0;
    v3 = 0;
    do
    {
      v4 = 9 * v1;
      v5 = &dword_504B68[18 * v1];
      if ( (result & 1) != 0 )
      {
        v6 = v5[2];
        v2 = 1;
        ++v1;
        v5[1] = v3;
        v5[2] = v6 + 1;
        dword_504B68[2 * v4 + 3 + v6] = v3;
      }
      result >>= 1;
      ++v3;
    }
    while ( result );
  }
  if ( v2 )
    dword_504B68[0] = v1;
  return result;
}
// 504B68: using guessed type int dword_504B68[73];
// 504C8C: using guessed type int dword_504C8C;

//----- (0003FD74) --------------------------------------------------------
int sub_3FD74()
{
  int v0; // r6
  int v1; // r5
  char v3[2072]; // [sp+0h] [bp-818h] BYREF

  v0 = dword_504C90;
  if ( dword_504C90 )
    return 0;
  if ( sub_40228() )
  {
    v1 = -1;
    strcpy(v3, "fpga init failed\n");
    sub_2E584(v0, v3, v0);
    return v1;
  }
  if ( sub_4044C() )
  {
    v1 = -2;
    strcpy(v3, "gpio init failed\n");
    sub_2E584(0, v3, 0);
    return v1;
  }
  memset(dword_504B68, 0, sizeof(dword_504B68));
  sub_3FB58();
  dword_504C90 = 1;
  sub_3FEFC();
  sub_42694();
  sub_419D8();
  return 0;
}
// 504B68: using guessed type int dword_504B68[73];
// 504C90: using guessed type int dword_504C90;

//----- (0003FE60) --------------------------------------------------------
void sub_3FE60()
{
  int v0; // r0
  int v1; // r0

  if ( dword_504C90 )
  {
    nullsub_12();
    sub_40248();
    v0 = nullsub_10();
    v1 = nullsub_13(v0);
    nullsub_11(v1);
    dword_504C90 = 0;
  }
}
// 3FF04: using guessed type int nullsub_10(void);
// 40454: using guessed type int __fastcall nullsub_11(_DWORD);
// 41A38: using guessed type int nullsub_12(void);
// 42724: using guessed type int __fastcall nullsub_13(_DWORD);
// 504C90: using guessed type int dword_504C90;

//----- (0003FE98) --------------------------------------------------------
void *__fastcall sub_3FE98(void *result)
{
  void *v1; // r4

  v1 = result;
  if ( result )
  {
    sub_3FB58();
    return memcpy(v1, dword_504B68, 0x124u);
  }
  return result;
}
// 504B68: using guessed type int dword_504B68[73];

//----- (0003FEFC) --------------------------------------------------------
int sub_3FEFC()
{
  return 0;
}

//----- (0003FF08) --------------------------------------------------------
int __fastcall sub_3FF08(int a1)
{
  int v2; // r4
  unsigned int v4; // [sp+0h] [bp-18h] BYREF
  int v5; // [sp+4h] [bp-14h] BYREF

  v4 = 0;
  v2 = 6;
  sub_40314(0, &v5);
  v5 = (unsigned __int16)v5;
  while ( 1 )
  {
    sub_40314(1, &v4);
    if ( ((v4 >> 8) & 7) == a1 )
      break;
    usleep(0x2710u);
    if ( !--v2 )
      return -1;
  }
  if ( v5 == 45093 )
    return 240 * (unsigned __int8)v4;
  else
    return 120 * (unsigned __int8)v4;
}

//----- (0003FF90) --------------------------------------------------------
int sub_3FF90()
{
  return 6;
}

//----- (0003FF98) --------------------------------------------------------
int sub_3FF98()
{
  return -1;
}

//----- (0003FFA0) --------------------------------------------------------
int __fastcall sub_3FFA0(int a1)
{
  int v1; // r4

  if ( !a1 )
    return sub_40ED4(954, 1);
  if ( a1 == 1 )
    return sub_40ED4(955, 1);
  v1 = sub_40ED4(954, 1);
  return v1 + sub_40ED4(955, 1);
}

//----- (0003FFEC) --------------------------------------------------------
int __fastcall sub_3FFEC(int a1)
{
  int v1; // r0
  int v2; // r4

  if ( !a1 )
  {
    v1 = 954;
    return sub_40ED4(v1, 0);
  }
  if ( a1 == 1 )
  {
    v1 = 955;
    return sub_40ED4(v1, 0);
  }
  v2 = sub_40ED4(954, 0);
  return v2 + sub_40ED4(955, 0);
}

//----- (00040038) --------------------------------------------------------
int sub_40038()
{
  int v0; // r0
  int v1; // r0
  int v2; // r0
  int result; // r0
  char s[2072]; // [sp+10h] [bp-818h] BYREF

  v0 = open64("/dev/axi_fpga_dev");
  dword_504C94 = v0;
  if ( v0 < 0 )
  {
    snprintf(s, 0x800u, "/dev/axi_fpga_dev open failed. fd = %d\n", v0);
    sub_2E584(0, s, 0);
    return -1;
  }
  else
  {
    dword_504C98 = mmap64(0, 4608, 3, 1, v0);
    if ( dword_504C98 )
    {
      v1 = open64("/dev/fpga_mem");
      dword_504C9C = v1;
      if ( v1 < 0 )
      {
        snprintf(s, 0x800u, "/dev/fpga_mem open failed. fd_fpga_mem_hal = %d\n", v1);
        sub_2E584(0, s, 0);
        perror("open");
        munmap((void *)dword_504C98, 0x1200u);
        close(dword_504C94);
        return -1;
      }
      else
      {
        v2 = mmap64(0, 0x1000000, 3, 1, v1);
        dword_504CA0 = v2;
        if ( v2 )
        {
          snprintf(s, 0x800u, "mmap fpga_mem_addr_hal = 0x%x\n", v2);
          sub_2E584(3, s, 0);
          result = 0;
          dword_504CA4 = 1;
        }
        else
        {
          snprintf(s, 0x800u, "mmap fpga_mem_addr_hal failed. fpga_mem_addr_hal = 0x%x\n", 0);
          sub_2E584(0, s, 0);
          munmap((void *)dword_504C98, 0x1200u);
          close(dword_504C94);
          close(dword_504C9C);
          return -1;
        }
      }
    }
    else
    {
      snprintf(s, 0x800u, "mmap axi_fpga_addr failed. axi_fpga_addr = %p\n", 0);
      sub_2E584(0, s, 0);
      close(dword_504C94);
      return -2;
    }
  }
  return result;
}
// 12198: using guessed type int __fastcall open64(_DWORD);
// 504C94: using guessed type int dword_504C94;
// 504C98: using guessed type int dword_504C98;
// 504C9C: using guessed type int dword_504C9C;
// 504CA0: using guessed type int dword_504CA0;
// 504CA4: using guessed type int dword_504CA4;

//----- (00040228) --------------------------------------------------------
int sub_40228()
{
  if ( dword_504CA4 )
    return 0;
  else
    return sub_40038();
}
// 504CA4: using guessed type int dword_504CA4;

//----- (00040248) --------------------------------------------------------
void sub_40248()
{
  char v0[2056]; // [sp+0h] [bp-808h] BYREF

  if ( dword_504CA4 )
  {
    if ( munmap((void *)dword_504C98, 0x1200u) < 0 )
    {
      strcpy(v0, "munmap failed!\n");
      sub_2E584(0, v0, 0);
    }
    if ( munmap((void *)dword_504CA0, 0x1000000u) < 0 )
    {
      strcpy(v0, "munmap fpga_mem_addr_hal failed!\n");
      sub_2E584(0, v0, 0);
    }
    dword_504CA4 = 0;
    close(dword_504C94);
    close(dword_504C9C);
  }
}
// 504C94: using guessed type int dword_504C94;
// 504C98: using guessed type int dword_504C98;
// 504C9C: using guessed type int dword_504C9C;
// 504CA0: using guessed type int dword_504CA0;
// 504CA4: using guessed type int dword_504CA4;

//----- (00040314) --------------------------------------------------------
int __fastcall sub_40314(int a1, _DWORD *a2)
{
  int v4; // r3
  int result; // r0

  if ( !dword_504CA4 && sub_40038() )
    return -1;
  if ( dword_504C8C )
    v4 = dword_7EE48[a1];
  else
    v4 = dword_7EE48[a1 + 186];
  result = 0;
  *a2 = *(_DWORD *)(dword_504C98 + 4 * v4);
  return result;
}
// 7EE48: using guessed type _DWORD dword_7EE48[372];
// 504C8C: using guessed type int dword_504C8C;
// 504C98: using guessed type int dword_504C98;
// 504CA4: using guessed type int dword_504CA4;

//----- (00040390) --------------------------------------------------------
int __fastcall sub_40390(int a1, int a2)
{
  int v4; // r3

  if ( !dword_504CA4 && sub_40038() )
    return -1;
  if ( dword_504C8C )
    v4 = dword_7EE48[a1];
  else
    v4 = dword_7EE48[a1 + 186];
  *(_DWORD *)(dword_504C98 + 4 * v4) = a2;
  return 0;
}
// 7EE48: using guessed type _DWORD dword_7EE48[372];
// 504C8C: using guessed type int dword_504C8C;
// 504C98: using guessed type int dword_504C98;
// 504CA4: using guessed type int dword_504CA4;

//----- (00040408) --------------------------------------------------------
int sub_40408()
{
  int v0; // r5

  v0 = dword_504CA4;
  if ( dword_504CA4 || !sub_40038() )
    return dword_504CA0;
  else
    return v0;
}
// 504CA0: using guessed type int dword_504CA0;
// 504CA4: using guessed type int dword_504CA4;

//----- (0004043C) --------------------------------------------------------
int __fastcall sub_4043C(_DWORD *a1, _DWORD *a2)
{
  return *a1 - *a2;
}

//----- (0004044C) --------------------------------------------------------
int sub_4044C()
{
  return 0;
}

//----- (00040458) --------------------------------------------------------
int __fastcall sub_40458(int a1, unsigned int a2)
{
  pthread_mutexattr_t *v3; // r5
  int v5; // [sp+Ch] [bp-81Ch] BYREF
  pthread_attr_t v6[57]; // [sp+10h] [bp-818h] BYREF

  v5 = a1;
  if ( a2 )
  {
    v3 = (pthread_mutexattr_t *)dword_504CA8;
    if ( !dword_504CA8 )
    {
      pthread_mutex_init(&stru_504CAC, (const pthread_mutexattr_t *)dword_504CA8);
      dword_504CC4 = (int)sub_432D0((int)sub_4043C, (int)v3, (int)v3);
      pthread_mutex_init(&stru_504CC8, v3);
      dword_504CE0 = 1;
      pthread_attr_init(v6);
      pthread_attr_setstacksize(v6, 0x200000u);
      pthread_create((pthread_t *)algn_504CE4, v6, (void *(*)(void *))sub_40D90, v3);
      dword_504CA8 = 1;
    }
    if ( pthread_mutex_lock(&stru_504CAC) )
    {
      strcpy(v6[0].__size, "fail to lock gpio ctrl mutex\n");
      sub_2E584(0, v6[0].__size, 0);
      return -1;
    }
    else
    {
      if ( !sub_43338((int *)dword_504CC4, (int)&v5) )
      {
        *(_QWORD *)v6[0].__size = a2 | 0xFFFFFFFF00000000LL;
        sub_43320((int *)dword_504CC4, &v5, 4u, v6, 8u);
      }
      pthread_mutex_unlock(&stru_504CAC);
      return 0;
    }
  }
  else
  {
    strcpy(v6[0].__size, "bad param\n");
    sub_2E584(0, v6[0].__size, 0);
    return -1;
  }
}
// 504CA8: using guessed type int dword_504CA8;
// 504CC4: using guessed type int dword_504CC4;
// 504CE0: using guessed type int dword_504CE0;
// 40458: using guessed type pthread_attr_t var_818[57];

//----- (000405CC) --------------------------------------------------------
int __fastcall sub_405CC(int a1, int a2)
{
  int v3; // [sp+4h] [bp-814h] BYREF
  char v4[2064]; // [sp+8h] [bp-810h] BYREF

  v3 = a1;
  if ( a2 )
  {
    if ( pthread_mutex_lock(&stru_504CAC) )
    {
      strcpy(v4, "fail to lock gpio ctrl mutex\n");
      sub_2E584(0, v4, 0);
      return -1;
    }
    else
    {
      if ( sub_43338((int *)dword_504CC4, (int)&v3) == (int *)1 )
      {
        sub_43358((int *)dword_504CC4, (int)&v3);
      }
      else
      {
        strcpy(v4, "callback function not registered before\n");
        sub_2E584(1, v4, 0);
      }
      pthread_mutex_unlock(&stru_504CAC);
      return 0;
    }
  }
  else
  {
    strcpy(v4, "bad param\n");
    sub_2E584(0, v4, 0);
    return -1;
  }
}
// 504CC4: using guessed type int dword_504CC4;

//----- (000406E4) --------------------------------------------------------
int __fastcall sub_406E4(int a1)
{
  char v3[2064]; // [sp+0h] [bp-810h] BYREF

  if ( pthread_mutex_lock(&stru_504CC8) )
  {
    strcpy(v3, "failed to api lock\n");
    sub_2E584(0, v3, 0);
    return -1;
  }
  else
  {
    snprintf(v3, 0x40u, "/sys/class/gpio/gpio%d", a1);
    if ( access(v3, 0) )
    {
      pthread_mutex_unlock(&stru_504CC8);
      return 0;
    }
    else
    {
      pthread_mutex_unlock(&stru_504CC8);
      return 1;
    }
  }
}

//----- (00040794) --------------------------------------------------------
int __fastcall sub_40794(int a1)
{
  int v2; // r6
  int v3; // r0
  char v5[64]; // [sp+0h] [bp-850h] BYREF
  char s[2064]; // [sp+40h] [bp-810h] BYREF

  if ( pthread_mutex_lock(&stru_504CC8) )
  {
    strcpy(s, "failed to api lock\n");
    sub_2E584(0, s, 0);
    return -1;
  }
  else
  {
    snprintf(v5, 0x40u, "/sys/class/gpio/gpio%d", a1);
    if ( access(v5, 0) )
    {
      v2 = open64("/sys/class/gpio/export");
      if ( v2 < 0 )
      {
        strcpy(s, "Failed to open export for writing!\n");
        sub_2E584(0, s, 0);
        pthread_mutex_unlock(&stru_504CC8);
        return -2;
      }
      else
      {
        v3 = snprintf(v5, 0x40u, "%d", a1);
        if ( write(v2, v5, v3) < 0 )
        {
          snprintf(s, 0x800u, "Failed to export gpio %d!", a1);
          sub_2E584(0, s, 0);
          close(v2);
          pthread_mutex_unlock(&stru_504CC8);
          return -3;
        }
        else
        {
          close(v2);
          pthread_mutex_unlock(&stru_504CC8);
          return 0;
        }
      }
    }
    else
    {
      pthread_mutex_unlock(&stru_504CC8);
      return 0;
    }
  }
}
// 12198: using guessed type int __fastcall open64(_DWORD);

//----- (00040AD8) --------------------------------------------------------
int __fastcall sub_40AD8(int a1, int a2)
{
  int v4; // r0
  size_t v5; // r2
  int v6; // r7
  bool v7; // zf
  const char *v8; // r4
  char s[64]; // [sp+8h] [bp-858h] BYREF
  char v11[2072]; // [sp+48h] [bp-818h] BYREF

  if ( pthread_mutex_lock(&stru_504CC8) )
  {
    strcpy(v11, "failed to api lock\n");
    sub_2E584(0, v11, 0);
    return -1;
  }
  else
  {
    snprintf(s, 0x40u, "/sys/class/gpio/gpio%d/direction", a1);
    v4 = open64(s);
    v6 = v4;
    if ( v4 < 0 )
    {
      snprintf(v11, 0x800u, "Failed to open gpio %d direction for writing!\n", a1);
      sub_2E584(0, v11, 0);
      pthread_mutex_unlock(&stru_504CC8);
      return -2;
    }
    else
    {
      v7 = a2 == 0;
      if ( !a2 )
        v5 = 2;
      v8 = "out";
      if ( v7 )
        v8 = "in";
      else
        v5 = 3;
      if ( write(v4, v8, v5) < 0 )
      {
        snprintf(v11, 0x800u, "Failed to set gpio %d direction %s !\n", a1, v8);
        sub_2E584(0, v11, 0);
        close(v6);
        pthread_mutex_unlock(&stru_504CC8);
        return -3;
      }
      else
      {
        close(v6);
        pthread_mutex_unlock(&stru_504CC8);
        return 0;
      }
    }
  }
}
// 40B48: variable 'v5' is possibly undefined
// 12198: using guessed type int __fastcall open64(_DWORD);

//----- (00040C28) --------------------------------------------------------
int __fastcall sub_40C28(int a1, _BYTE *a2)
{
  int v4; // r4
  int v5; // r0
  int v6; // r5
  int buf; // [sp+Ch] [bp-85Ch] BYREF
  char s[64]; // [sp+10h] [bp-858h] BYREF
  char v10[2072]; // [sp+50h] [bp-818h] BYREF

  buf = 0;
  v4 = pthread_mutex_lock(&stru_504CC8);
  if ( v4 )
  {
    v4 = -1;
    strcpy(v10, "failed to api lock\n");
    sub_2E584(0, v10, 0);
  }
  else
  {
    snprintf(s, 0x40u, "/sys/class/gpio/gpio%d/value", a1);
    v5 = open64(s);
    v6 = v5;
    if ( v5 < 0 )
    {
      snprintf(v10, 0x800u, "Failed to open gpio %d value for reading!\n", a1);
      v4 = -2;
      sub_2E584(0, v10, 0);
      pthread_mutex_unlock(&stru_504CC8);
    }
    else if ( read(v5, &buf, 4u) < 0 )
    {
      strcpy(v10, "Failed to read value!\n");
      v4 = -3;
      sub_2E584(0, v10, 0);
      close(v6);
      pthread_mutex_unlock(&stru_504CC8);
    }
    else
    {
      close(v6);
      pthread_mutex_unlock(&stru_504CC8);
      *a2 = strtol((const char *)&buf, 0, 10);
    }
  }
  return v4;
}
// 12198: using guessed type int __fastcall open64(_DWORD);

//----- (00040D90) --------------------------------------------------------
int sub_40D90()
{
  _DWORD *v0; // r4
  void (__fastcall *v1)(_DWORD *, int *, int); // r3
  int v2; // r6
  void (**v3)(void); // r5
  int v4; // r6
  unsigned __int8 v6; // [sp+Fh] [bp-29h] BYREF
  int v7[10]; // [sp+10h] [bp-28h] BYREF

  prctl(15, "gpio", 0);
  while ( dword_504CE0 )
  {
    if ( !pthread_mutex_lock(&stru_504CAC) )
    {
      v0 = sub_43440(dword_504CC4);
      if ( ((int (*)(void))*v0)() )
      {
        while ( 1 )
        {
          v2 = v0[5];
          v3 = (void (**)(void))((int (*)(void))v0[2])();
          v4 = ***(_DWORD ***)(v2 + 16);
          v6 = 0;
          if ( sub_40C28(v4, &v6) )
            break;
          if ( v3[1] != (void (*)(void))v6 )
          {
            (*v3)();
            v1 = (void (__fastcall *)(_DWORD *, int *, int))v0[1];
            v7[0] = (int)*v3;
            v7[1] = v6;
            v1(v0, v7, 8);
          }
          free(v3);
          if ( !((int (__fastcall *)(_DWORD *))*v0)(v0) )
            goto LABEL_12;
        }
        free(v3);
      }
LABEL_12:
      j_free(v0);
      pthread_mutex_unlock(&stru_504CAC);
    }
    usleep(0x30D40u);
  }
  return 0;
}
// 504CC4: using guessed type int dword_504CC4;
// 504CE0: using guessed type int dword_504CE0;

//----- (00040ED4) --------------------------------------------------------
int __fastcall sub_40ED4(int a1, int a2)
{
  int v4; // r0
  int v5; // r5
  char *v6; // r1
  char v8[64]; // [sp+0h] [bp-850h] BYREF
  char v9[2064]; // [sp+40h] [bp-810h] BYREF

  if ( pthread_mutex_lock(&stru_504CC8) )
  {
    strcpy(v9, "failed to api lock\n");
    sub_2E584(0, v9, 0);
    return -1;
  }
  else
  {
    snprintf(v8, 0x40u, "/sys/class/gpio/gpio%d/value", a1);
    v4 = open64(v8);
    v5 = v4;
    if ( v4 < 0 )
    {
      strcpy(v9, "Failed to open gpio value for writing!\n");
      sub_2E584(0, v9, 0);
      pthread_mutex_unlock(&stru_504CC8);
      return -2;
    }
    else
    {
      v6 = "01";
      if ( a2 )
        v6 = "1";
      if ( write(v4, v6, 1u) < 0 )
      {
        strcpy(v9, "Failed to write value!\n");
        sub_2E584(0, v9, 0);
        close(v5);
        pthread_mutex_unlock(&stru_504CC8);
        return -3;
      }
      else
      {
        close(v5);
        pthread_mutex_unlock(&stru_504CC8);
        return 0;
      }
    }
  }
}
// 12198: using guessed type int __fastcall open64(_DWORD);

//----- (0004101C) --------------------------------------------------------
int __fastcall sub_4101C(unsigned int a1)
{
  char v2[2056]; // [sp+0h] [bp-808h] BYREF

  if ( dword_504C90 )
  {
    if ( a1 > 1 )
    {
      strcpy(v2, "bad param\n");
      sub_2E584(0, v2, 0);
      return -3;
    }
    else
    {
      return a1 + 1;
    }
  }
  else
  {
    strcpy(v2, "please init platform first!!\n");
    sub_2E584(dword_504C90, v2, dword_504C90);
    return -2;
  }
}
// 504C90: using guessed type int dword_504C90;

//----- (000410BC) --------------------------------------------------------
int __fastcall sub_410BC(int result)
{
  char v1[2056]; // [sp-808h] [bp-808h] BYREF

  if ( result > 2 )
  {
    strcpy(v1, "bad param\n");
    return sub_2E584(0, v1, 0);
  }
  return result;
}

//----- (0004110C) --------------------------------------------------------
int __fastcall sub_4110C(int a1, unsigned int a2)
{
  int v2; // r4
  int v4; // r5
  char v5[2064]; // [sp+0h] [bp-810h] BYREF

  if ( a1 > 2 )
  {
    strcpy(v5, "bad param\n");
    sub_2E584(0, v5, 0);
    return -3;
  }
  else
  {
    v2 = a1 - 1;
    if ( a1 == 1 )
    {
      if ( a2 >= 0x64 )
        a2 = 100;
      v4 = (100 - a2) | (a2 << 16);
      sub_40390(19, v4);
      sub_40390(23, v4);
      return v2;
    }
    else
    {
      snprintf(v5, 0x800u, "pwm type %d not supported\n", a1 - 1);
      sub_2E584(0, v5, 0);
      return 0;
    }
  }
}

//----- (000411D0) --------------------------------------------------------
int __fastcall sub_411D0(int a1, int a2)
{
  int v2; // r4
  char v5[2064]; // [sp+0h] [bp-810h] BYREF

  if ( a1 > 2 )
  {
    v2 = -3;
    strcpy(v5, "bad param\n");
    sub_2E584(0, v5, 0);
  }
  else
  {
    v2 = a1 - 1;
    if ( a1 == 1 )
    {
      sub_40314(19, (_DWORD *)a2);
      *(_DWORD *)a2 = *(unsigned __int16 *)(a2 + 2);
    }
    else
    {
      return -5;
    }
  }
  return v2;
}

//----- (00041250) --------------------------------------------------------
int __fastcall sub_41250(int a1, _DWORD *a2, int *a3, int *a4, int *a5)
{
  int v5; // r0
  int v6; // r12
  int v7; // r1
  int result; // r0
  char s[2056]; // [sp+8h] [bp-808h] BYREF

  switch ( a1 )
  {
    case 0:
      v5 = 64;
      *a2 = 24;
      v6 = 68;
      v7 = 69;
      goto LABEL_3;
    case 1:
      v5 = 64;
      *a2 = 16;
      v6 = 70;
      v7 = 71;
      goto LABEL_3;
    case 2:
      v5 = 64;
      *a2 = 8;
      v6 = 72;
      v7 = 73;
      goto LABEL_3;
    case 3:
      result = 0;
      *a2 = 0;
      *a3 = 64;
      *a4 = 74;
      *a5 = 75;
      return result;
    case 4:
      v5 = 65;
      *a2 = 24;
      v6 = 76;
      v7 = 77;
      goto LABEL_3;
    case 5:
      v5 = 65;
      *a2 = 16;
      v6 = 78;
      v7 = 79;
      goto LABEL_3;
    case 6:
      v5 = 65;
      *a2 = 8;
      v6 = 80;
      v7 = 81;
      goto LABEL_3;
    case 7:
      result = 0;
      *a2 = 0;
      *a3 = 65;
      *a4 = 82;
      *a5 = 83;
      return result;
    case 8:
      v5 = 66;
      *a2 = 24;
      v6 = 84;
      v7 = 85;
      goto LABEL_3;
    case 9:
      v5 = 66;
      *a2 = 16;
      v6 = 86;
      v7 = 87;
      goto LABEL_3;
    case 10:
      v5 = 66;
      *a2 = 8;
      v6 = 115;
      v7 = 116;
      goto LABEL_3;
    case 11:
      result = 0;
      *a2 = 0;
      *a3 = 66;
      *a4 = 117;
      *a5 = 118;
      return result;
    case 12:
      v5 = 67;
      *a2 = 24;
      v6 = 119;
      v7 = 120;
      goto LABEL_3;
    case 13:
      v5 = 67;
      *a2 = 16;
      v6 = 121;
      v7 = 122;
LABEL_3:
      *a3 = v5;
      result = 0;
      *a4 = v6;
      *a5 = v7;
      break;
    default:
      snprintf(s, 0x800u, "%s: The uart %d is not supported!!!\n", "get_send_address_info", a1);
      sub_2E584(0, s, 0);
      result = -1;
      break;
  }
  return result;
}
// 41264: control flows out of bounds to 41268

//----- (00041474) --------------------------------------------------------
unsigned int __fastcall sub_41474(int a1)
{
  unsigned int result; // r0
  unsigned int v2; // [sp+Ch] [bp-80Ch] BYREF
  char s[2056]; // [sp+10h] [bp-808h] BYREF

  v2 = 0;
  switch ( a1 )
  {
    case 0:
      sub_40314(88, &v2);
      result = HIWORD(v2) & 0x3FF;
      break;
    case 1:
      sub_40314(88, &v2);
      result = v2 & 0x3FF;
      break;
    case 2:
      sub_40314(89, &v2);
      result = HIWORD(v2) & 0x3FF;
      break;
    case 3:
      sub_40314(89, &v2);
      result = v2 & 0x3FF;
      break;
    case 4:
      sub_40314(90, &v2);
      result = HIWORD(v2) & 0x3FF;
      break;
    case 5:
      sub_40314(90, &v2);
      result = v2 & 0x3FF;
      break;
    case 6:
      sub_40314(91, &v2);
      result = HIWORD(v2) & 0x3FF;
      break;
    case 7:
      sub_40314(91, &v2);
      result = v2 & 0x3FF;
      break;
    case 8:
      sub_40314(92, &v2);
      result = HIWORD(v2) & 0x3FF;
      break;
    case 9:
      sub_40314(92, &v2);
      result = v2 & 0x3FF;
      break;
    case 10:
      sub_40314(93, &v2);
      result = HIWORD(v2) & 0x3FF;
      break;
    case 11:
      sub_40314(93, &v2);
      result = v2 & 0x3FF;
      break;
    case 12:
      sub_40314(94, &v2);
      result = HIWORD(v2) & 0x3FF;
      break;
    case 13:
      sub_40314(94, &v2);
      result = v2 & 0x3FF;
      break;
    default:
      snprintf(s, 0x800u, "%s: The uart%d is not supported!!!\n", "check_how_many_uart_data_in_fpga", a1);
      sub_2E584(0, s, 0);
      result = 0;
      break;
  }
  return result;
}
// 41490: control flows out of bounds to 41494

//----- (0004165C) --------------------------------------------------------
int __fastcall sub_4165C(int a1)
{
  pthread_mutex_t *v1; // r7
  int v3; // r4
  unsigned int v4; // r3
  int v6; // [sp+Ch] [bp-82Ch] BYREF
  int v7; // [sp+10h] [bp-828h] BYREF
  int v8; // [sp+14h] [bp-824h] BYREF
  unsigned int v9; // [sp+18h] [bp-820h] BYREF
  int v10; // [sp+1Ch] [bp-81Ch] BYREF
  char s[2072]; // [sp+20h] [bp-818h] BYREF

  v1 = (pthread_mutex_t *)((char *)&unk_504CE8 + 24 * a1);
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  pthread_mutex_lock(v1);
  if ( sub_41250(a1, &v10, &v6, &v7, &v8) )
  {
    snprintf(s, 0x800u, "get_send_address_info error, chain_id = %d\n", a1);
  }
  else
  {
    v3 = 21;
    do
    {
      sub_40314(v6, &v9);
      v4 = (unsigned __int8)(v9 >> v10);
      v9 = v4;
      if ( v4 == 255 )
        return pthread_mutex_unlock(v1);
      printf("%s: waiting fpga uart%d clear send fifo space ...\n", "clear_uart_tx_fifo", a1);
      sub_40390(v7, v9 | 0x80000000);
      usleep(0xBB8u);
      --v3;
    }
    while ( v3 );
    snprintf(s, 0x800u, "%s: uart%d always dose not has enough send fifo space, break\n", "clear_uart_tx_fifo", a1);
  }
  sub_2E584(0, s, 0);
  return pthread_mutex_unlock(v1);
}

//----- (00041794) --------------------------------------------------------
unsigned int __fastcall sub_41794(int a1, int a2, unsigned int a3)
{
  unsigned int v5; // r5
  int v8; // r6
  int v9; // r0
  unsigned int v10; // r9
  int v11; // r4
  unsigned int v12; // r3
  int v13; // r4
  int v14; // r3
  unsigned int v15; // r1
  unsigned int v16; // r2
  unsigned int v17; // r2
  unsigned int v18; // [sp+Ch] [bp-824h] BYREF
  char s[2080]; // [sp+10h] [bp-820h] BYREF

  v18 = 0;
  switch ( a1 )
  {
    case 0:
      v8 = 96;
      v9 = 95;
      goto LABEL_5;
    case 1:
      v8 = 98;
      v9 = 97;
      goto LABEL_5;
    case 2:
      v8 = 100;
      v9 = 99;
      goto LABEL_5;
    case 3:
      v8 = 102;
      v9 = 101;
      goto LABEL_5;
    case 4:
      v8 = 104;
      v9 = 103;
      goto LABEL_5;
    case 5:
      v8 = 106;
      v9 = 105;
      goto LABEL_5;
    case 6:
      v8 = 108;
      v9 = 107;
      goto LABEL_5;
    case 7:
      v8 = 110;
      v9 = 109;
      goto LABEL_5;
    case 8:
      v8 = 112;
      v9 = 111;
      goto LABEL_5;
    case 9:
      v8 = 114;
      v9 = 113;
      goto LABEL_5;
    case 10:
      v8 = 124;
      v9 = 123;
      goto LABEL_5;
    case 11:
      v8 = 126;
      v9 = 125;
      goto LABEL_5;
    case 12:
      v8 = 128;
      v9 = 127;
      goto LABEL_5;
    case 13:
      v8 = 130;
      v9 = 129;
LABEL_5:
      sub_40390(v9, a3 & 0x3FF | 0x80000000);
      v10 = a3 >> 2;
      if ( a3 >> 2 )
      {
        v11 = a2;
        do
        {
          v11 += 4;
          sub_40314(v8, &v18);
          v12 = v18;
          *(_BYTE *)(v11 - 1) = v18;
          *(_BYTE *)(v11 - 4) = HIBYTE(v12);
          *(_BYTE *)(v11 - 3) = BYTE2(v12);
          *(_BYTE *)(v11 - 2) = BYTE1(v12);
        }
        while ( a2 + 4 * v10 != v11 );
      }
      v13 = a3 & 3;
      v5 = a3 & 0xFFFFFFFC;
      if ( v13 )
      {
        sub_40314(v8, &v18);
        v14 = a2 + 4 * v10;
        if ( v13 == 2 )
        {
          v5 += 2;
          v17 = HIWORD(v18);
          *(_BYTE *)(a2 + 4 * v10) = HIBYTE(v18);
          *(_BYTE *)(v14 + 1) = v17;
        }
        else if ( v13 == 3 )
        {
          v5 += 3;
          v15 = HIWORD(v18);
          v16 = v18 >> 8;
          *(_BYTE *)(a2 + 4 * v10) = HIBYTE(v18);
          *(_BYTE *)(v14 + 1) = v15;
          *(_BYTE *)(v14 + 2) = v16;
        }
        else
        {
          ++v5;
          *(_BYTE *)(a2 + 4 * v10) = HIBYTE(v18);
        }
      }
      break;
    default:
      v5 = 0;
      snprintf(s, 0x800u, "%s: The uart%d is not supported!!!\n", "get_read_address_info", a1);
      sub_2E584(0, s, 0);
      snprintf(s, 0x800u, "get_read_address_info error, chain_id = %d\n", a1);
      sub_2E584(0, s, 0);
      break;
  }
  return v5;
}
// 417B8: control flows out of bounds to 417BC

//----- (000419D8) --------------------------------------------------------
int sub_419D8()
{
  char v1[2056]; // [sp-808h] [bp-808h] BYREF

  if ( dword_504C90 )
    return 0;
  strcpy(v1, "please init platform first!!\n");
  sub_2E584(dword_504C90, v1, dword_504C90);
  return -1;
}
// 504C90: using guessed type int dword_504C90;

//----- (00041C88) --------------------------------------------------------
unsigned int __fastcall sub_41C88(int a1, int a2, unsigned int a3)
{
  pthread_mutex_t *v6; // r5
  unsigned int v7; // r0
  unsigned int v9; // r4

  v6 = (pthread_mutex_t *)((char *)&unk_504E68 + 24 * a1);
  pthread_mutex_lock(v6);
  v7 = sub_41474((unsigned __int8)a1);
  if ( v7 < a3 )
    a3 = v7;
  if ( a3 )
  {
    v9 = sub_41794(a1, a2, a3);
    pthread_mutex_unlock(v6);
    return v9;
  }
  else
  {
    pthread_mutex_unlock(v6);
    return 0;
  }
}

//----- (00041CFC) --------------------------------------------------------
int __fastcall sub_41CFC(int a1, int a2, int *a3)
{
  pthread_mutex_t *v5; // r4
  char v7[2064]; // [sp+0h] [bp-810h] BYREF

  if ( !a3 )
    return -3;
  v5 = (pthread_mutex_t *)((char *)&unk_504CE8 + 24 * a1);
  pthread_mutex_lock(v5);
  if ( a2 )
  {
    snprintf(v7, 0x800u, "unknown set config type = %d\n", a2);
    sub_2E584(1, v7, 0);
  }
  else
  {
    sub_40390(15, *a3);
  }
  pthread_mutex_unlock(v5);
  return -5;
}

//----- (00041D80) --------------------------------------------------------
int __fastcall sub_41D80(int a1, int a2, _DWORD *a3, int a4)
{
  _BOOL4 v4; // r3
  int v5; // r6
  pthread_mutex_t *v6; // r4
  int v10[512]; // [sp+0h] [bp-818h] BYREF

  v4 = a4 != 0;
  if ( a3 )
    v5 = v4;
  else
    v5 = 1;
  if ( v5 )
    return -3;
  v6 = (pthread_mutex_t *)((char *)&unk_504CE8 + 24 * a1);
  pthread_mutex_lock(v6);
  if ( !a2 )
  {
    v10[0] = 0;
    sub_40314(15, v10);
    *a3 = v10[0];
    MEMORY[0] = 0;
    __und(0);
  }
  snprintf((char *)v10, 0x800u, "unknown set config type = %d\n", a2);
  sub_2E584(1, (const char *)v10, 0);
  pthread_mutex_unlock(v6);
  return -5;
}

//----- (00041E38) --------------------------------------------------------
int __fastcall sub_41E38(int a1, int a2, _DWORD *a3)
{
  pthread_mutex_t *v5; // r4
  char v7[2064]; // [sp+0h] [bp-810h] BYREF

  if ( !a3 )
    return -3;
  v5 = (pthread_mutex_t *)((char *)&unk_504CE8 + 24 * a1);
  pthread_mutex_lock(v5);
  if ( a2 )
  {
    snprintf(v7, 0x800u, "unknown set config type = %d\n", a2);
    sub_2E584(1, v7, 0);
  }
  else
  {
    sub_40390(15, *a3 << 16);
  }
  pthread_mutex_unlock(v5);
  return -5;
}

//----- (00041EC0) --------------------------------------------------------
int __fastcall sub_41EC0(int a1, int a2, unsigned int *a3, int a4)
{
  _BOOL4 v4; // r3
  int v5; // r6
  pthread_mutex_t *v6; // r4
  int v10[512]; // [sp+0h] [bp-818h] BYREF

  v4 = a4 != 0;
  if ( a3 )
    v5 = v4;
  else
    v5 = 1;
  if ( v5 )
    return -3;
  v6 = (pthread_mutex_t *)((char *)&unk_504CE8 + 24 * a1);
  pthread_mutex_lock(v6);
  if ( !a2 )
  {
    v10[0] = 0;
    sub_40314(15, v10);
    *a3 = HIWORD(v10[0]) & 0x3F;
    MEMORY[0] = 0;
    __und(0);
  }
  snprintf((char *)v10, 0x800u, "unknown set config type = %d\n", a2);
  sub_2E584(1, (const char *)v10, 0);
  pthread_mutex_unlock(v6);
  return -5;
}

//----- (00041F7C) --------------------------------------------------------
int __fastcall sub_41F7C(int a1)
{
  pthread_mutex_t *v2; // r4
  unsigned int v3; // r0
  unsigned int v4; // r6
  void *v5; // r0
  void *v6; // r7
  unsigned int v7; // r0
  char s[2072]; // [sp+10h] [bp-818h] BYREF

  v2 = (pthread_mutex_t *)((char *)&unk_504E68 + 24 * a1);
  pthread_mutex_lock(v2);
  v3 = sub_41474((unsigned __int8)a1);
  v4 = v3;
  if ( !v3 )
    return pthread_mutex_unlock(v2);
  v5 = malloc(v3);
  v6 = v5;
  if ( v5 )
  {
    v7 = sub_41794(a1, (int)v5, v4);
    if ( v4 != v7 )
    {
      snprintf(s, 0x800u, "%s: uart%d clear rx fifo error. nbytes = %d, len = %d\n", "clear_uart_rx_fifo", a1, v4, v7);
      sub_2E584(0, s, 0);
    }
    free(v6);
    usleep(0x2710u);
    return pthread_mutex_unlock(v2);
  }
  snprintf(s, 0x800u, "%s: uart%d malloc buffer error\n", "clear_uart_rx_fifo", a1);
  sub_2E584(0, s, 0);
  usleep(0x7A120u);
  return pthread_mutex_unlock(v2);
}

//----- (00042080) --------------------------------------------------------
int __fastcall sub_42080(int a1)
{
  sub_41F7C(a1);
  usleep(0x2710u);
  sub_4165C(a1);
  return 0;
}

//----- (000420A4) --------------------------------------------------------
int __fastcall sub_420A4(int a1)
{
  sub_4165C(a1);
  return 0;
}

//----- (000420B4) --------------------------------------------------------
int __fastcall sub_420B4(int a1)
{
  sub_41F7C(a1);
  return 0;
}

//----- (000420C4) --------------------------------------------------------
unsigned int __fastcall sub_420C4(int a1)
{
  unsigned __int8 v1; // r5
  pthread_mutex_t *v2; // r4
  unsigned int v3; // r5

  v1 = a1;
  v2 = (pthread_mutex_t *)((char *)&unk_504E68 + 24 * a1);
  pthread_mutex_lock(v2);
  v3 = sub_41474(v1);
  pthread_mutex_unlock(v2);
  return v3;
}

//----- (00042100) --------------------------------------------------------
int sub_42100()
{
  if ( !sub_406E4(907) )
  {
    sub_40794(907);
    sub_40AD8(907, 1);
  }
  return sub_40ED4(907, 0);
}

//----- (00042138) --------------------------------------------------------
int sub_42138()
{
  if ( !sub_406E4(907) )
  {
    sub_40794(907);
    sub_40AD8(907, 1);
  }
  return sub_40ED4(907, 1);
}

//----- (00042170) --------------------------------------------------------
int __fastcall sub_42170(_DWORD *a1, _DWORD *a2)
{
  return *a1 - *a2;
}

//----- (00042180) --------------------------------------------------------
int *__fastcall sub_42180(int *result, int *a2)
{
  int v3[3]; // [sp+4h] [bp-Ch] BYREF

  v3[0] = (int)result;
  if ( a2 )
  {
    result = sub_43338(a2, (int)v3);
    if ( result == (int *)1 )
      return (int *)sub_43358(a2, (int)v3);
  }
  return result;
}

//----- (000421C4) --------------------------------------------------------
int sub_421C4()
{
  _DWORD *v0; // r5
  int v1; // r2
  int v2; // r0
  int v3; // r3
  int *v4; // r0
  int v5; // r3
  int *v6; // r4
  int v8[9]; // [sp+Ch] [bp-24h] BYREF

  prctl(15, "ui", 0);
  while ( dword_504FE8 )
  {
    if ( !pthread_mutex_lock(&stru_504FEC) )
    {
      v0 = sub_43440(dword_505004);
      if ( ((int (*)(void))*v0)() )
      {
        do
        {
          v4 = (int *)((int (*)(void))v0[2])();
          v5 = v4[1];
          v6 = v4;
          if ( v5 )
          {
            v1 = *v4;
            v2 = v4[2];
          }
          else
          {
            sub_40ED4(***(_DWORD ***)(v0[5] + 16), *((unsigned __int8 *)v4 + 8));
            v5 = *v6;
            v2 = v6[2] != 1;
            v1 = *v6;
            v6[2] = v2;
          }
          v3 = v5 - 200;
          v8[0] = v1;
          v6[1] = v3;
          v8[1] = v3;
          v8[2] = v2;
          ((void (__fastcall *)(_DWORD *, int *))v0[1])(v0, v8);
          free(v6);
        }
        while ( ((int (__fastcall *)(_DWORD *))*v0)(v0) );
      }
      j_free(v0);
      pthread_mutex_unlock(&stru_504FEC);
    }
    usleep((__useconds_t)&loc_30D40);
  }
  return 0;
}
// 504FE8: using guessed type int dword_504FE8;
// 505004: using guessed type int dword_505004;

//----- (00042308) --------------------------------------------------------
int __fastcall sub_42308(int a1)
{
  char v3[2056]; // [sp+0h] [bp-808h] BYREF

  if ( sub_43014() == a1 )
    return 256;
  if ( sub_4301C() == a1 )
    return 257;
  snprintf(v3, 0x800u, "unmaped port = %d\n", a1);
  sub_2E584(0, v3, 0);
  return 258;
}

//----- (00042368) --------------------------------------------------------
int sub_42368()
{
  if ( sub_43004() >= 0 )
    return sub_43004();
  else
    return 0;
}

//----- (00042388) --------------------------------------------------------
int __fastcall sub_42388(unsigned int a1)
{
  if ( a1 == 2 )
  {
    if ( sub_4300C() < 0 )
      return 0;
    return sub_4300C();
  }
  else if ( a1 <= 2 )
  {
    if ( a1 != 1 )
      return 0;
    return sub_42368();
  }
  else
  {
    if ( a1 != 256 )
    {
      if ( a1 == 257 && sub_4301C() >= 0 )
        return sub_4301C();
      return 0;
    }
    if ( sub_43014() < 0 )
      return 0;
    return sub_43014();
  }
}

//----- (00042400) --------------------------------------------------------
int sub_42400()
{
  int result; // r0
  pthread_attr_t attr; // [sp+4h] [bp-34h] BYREF

  pthread_mutex_init(&stru_504FEC, 0);
  dword_505008 = 0;
  dword_50500C = 0;
  dword_505010 = 0;
  dword_505014 = 0;
  dword_505018 = 0;
  dword_505004 = (int)sub_432D0((int)sub_42170, 0, 0);
  pthread_attr_init(&attr);
  pthread_attr_setstacksize(&attr, 0x200000u);
  result = pthread_create((pthread_t *)algn_50501C, &attr, (void *(*)(void *))sub_421C4, 0);
  dword_504FE8 = 1;
  return result;
}
// 504FE8: using guessed type int dword_504FE8;
// 505004: using guessed type int dword_505004;
// 505008: using guessed type int dword_505008;
// 50500C: using guessed type int dword_50500C;
// 505010: using guessed type int dword_505010;
// 505014: using guessed type int dword_505014;
// 505018: using guessed type int dword_505018;

//----- (00042488) --------------------------------------------------------
int __fastcall sub_42488(int a1)
{
  char v2[2056]; // [sp+0h] [bp-808h] BYREF

  snprintf(v2, 0x800u, "gpio port %d is not a supported key\n", a1);
  return sub_2E584(1, v2, 0);
}

//----- (000424C8) --------------------------------------------------------
int __fastcall sub_424C8(int a1, int a2)
{
  int v4; // r0
  char *v5; // r4
  int v6; // r5
  int (__fastcall *v7)(int, int); // r3
  int (__fastcall *v8)(int, int); // t1
  int result; // r0
  int v10; // r1

  v4 = sub_42308(a1);
  if ( v4 == 258 )
    return sub_42488(a1);
  v5 = (char *)&dword_505008;
  v6 = v4;
  do
  {
    v8 = *(int (__fastcall **)(int, int))v5;
    v5 += 4;
    v7 = v8;
    result = v6;
    if ( v8 )
    {
      v10 = a2;
      if ( a2 )
        v10 = 1;
      result = v7(v6, v10);
    }
  }
  while ( v5 != algn_50501C );
  return result;
}
// 505008: using guessed type int dword_505008;

//----- (00042528) --------------------------------------------------------
int __fastcall sub_42528(unsigned int a1, int a2)
{
  int *v3; // r6
  int *v4; // r4
  int v5; // r5
  int *v7; // [sp+Ch] [bp-81Ch] BYREF
  _DWORD v8[518]; // [sp+10h] [bp-818h] BYREF

  v3 = (int *)sub_42388(a1);
  if ( v3 )
  {
    if ( pthread_mutex_lock(&stru_504FEC) )
    {
      v5 = -1;
      strcpy((char *)v8, "failed to api lock\n");
      sub_2E584(0, (const char *)v8, 0);
    }
    else
    {
      v4 = (int *)dword_505004;
      if ( a2 == 1 )
      {
        sub_42180(v3, (int *)dword_505004);
        v5 = sub_40ED4((int)v3, 0);
      }
      else if ( a2 == 2 )
      {
        v7 = v3;
        if ( dword_505004 && !sub_43338((int *)dword_505004, (int)&v7) )
        {
          v8[1] = 0;
          v5 = -1;
          v8[0] = 200;
          v8[2] = 1;
          sub_43320(v4, &v7, 4u, v8, 0xCu);
        }
        else
        {
          v5 = -1;
        }
      }
      else
      {
        sub_42180(v3, (int *)dword_505004);
        v5 = sub_40ED4((int)v3, 1);
      }
      pthread_mutex_unlock(&stru_504FEC);
    }
  }
  else
  {
    v5 = -1;
    strcpy((char *)v8, "unsuported gpio port\n");
    sub_2E584(0, (const char *)v8, 0);
  }
  return v5;
}
// 505004: using guessed type int dword_505004;

//----- (00042694) --------------------------------------------------------
int sub_42694()
{
  int v0; // r5
  int v1; // r0
  int v2; // r0
  int v3; // r0
  int v4; // r0
  int v5; // r0
  int v6; // r0
  int v7; // r0
  int v8; // r0

  v0 = dword_505020;
  if ( !dword_505020 )
  {
    v1 = sub_42368();
    sub_40794(v1);
    v2 = sub_42368();
    sub_40AD8(v2, 1);
    v3 = sub_42388(2u);
    sub_40794(v3);
    v4 = sub_42388(2u);
    sub_40AD8(v4, 1);
    v5 = sub_42388(0x100u);
    sub_40794(v5);
    v6 = sub_42388(0x100u);
    sub_40AD8(v6, v0);
    v7 = sub_42388(0x101u);
    sub_40794(v7);
    v8 = sub_42388(0x101u);
    sub_40AD8(v8, v0);
    dword_505020 = 1;
  }
  return 0;
}
// 505020: using guessed type int dword_505020;

//----- (00042728) --------------------------------------------------------
int sub_42728()
{
  return sub_42528(1u, 0);
}

//----- (00042734) --------------------------------------------------------
int sub_42734()
{
  return sub_42528(1u, 1);
}

//----- (00042740) --------------------------------------------------------
int sub_42740()
{
  if ( !dword_504FE8 )
    sub_42400();
  return sub_42528(1u, 2);
}
// 504FE8: using guessed type int dword_504FE8;

//----- (00042778) --------------------------------------------------------
int sub_42778()
{
  return sub_42528(2u, 0);
}

//----- (00042784) --------------------------------------------------------
int sub_42784()
{
  return sub_42528(2u, 1);
}

//----- (00042790) --------------------------------------------------------
int sub_42790()
{
  if ( !dword_504FE8 )
    sub_42400();
  return sub_42528(2u, 2);
}
// 504FE8: using guessed type int dword_504FE8;

//----- (000427C8) --------------------------------------------------------
int sub_427C8()
{
  return sub_42528(0x10u, 0);
}

//----- (000427D4) --------------------------------------------------------
int sub_427D4()
{
  return sub_42528(0x10u, 1);
}

//----- (000427E0) --------------------------------------------------------
int sub_427E0()
{
  if ( !dword_504FE8 )
    sub_42400();
  return sub_42528(0x10u, 2);
}
// 504FE8: using guessed type int dword_504FE8;

//----- (00042818) --------------------------------------------------------
int __fastcall sub_42818(int a1)
{
  int v2; // r5
  int *v3; // r2
  int v4; // r3
  int v7; // r0
  int v8; // r0
  char v9[2064]; // [sp+0h] [bp-810h] BYREF

  v2 = pthread_mutex_lock(&stru_504FEC);
  if ( v2 )
  {
    v2 = -1;
    strcpy(v9, "failed to api lock\n");
    sub_2E584(0, v9, 0);
  }
  else
  {
    if ( !dword_505024 )
    {
      v7 = sub_42388(0x100u);
      sub_40458(v7, (unsigned int)sub_424C8);
      v8 = sub_42388(0x101u);
      sub_40458(v8, (unsigned int)sub_424C8);
      dword_505024 = 1;
    }
    v3 = &dword_505008;
    v4 = 0;
    while ( *v3++ )
    {
      if ( ++v4 == 5 )
      {
        v2 = -2;
        strcpy(v9, "no more listener available\n");
        sub_2E584(0, v9, 0);
        goto LABEL_8;
      }
    }
    dword_504FE8[v4 + 8] = a1;
LABEL_8:
    pthread_mutex_unlock(&stru_504FEC);
  }
  return v2;
}
// 504FE8: using guessed type int dword_504FE8[];
// 505008: using guessed type int dword_505008;
// 505024: using guessed type int dword_505024;

//----- (00042928) --------------------------------------------------------
int __fastcall sub_42928(int a1)
{
  int v2; // r0
  int *v3; // r3
  int v4; // t1
  char v6[2064]; // [sp+0h] [bp-810h] BYREF

  v2 = pthread_mutex_lock(&stru_504FEC);
  if ( v2 )
  {
    strcpy(v6, "failed to api lock\n");
    sub_2E584(0, v6, 0);
    return -1;
  }
  else
  {
    v3 = &dword_505008;
    while ( 1 )
    {
      v4 = *v3++;
      if ( v4 == a1 )
        break;
      if ( ++v2 == 5 )
      {
        strcpy(v6, "listener not registered before\n");
        sub_2E584(1, v6, 0);
        goto LABEL_7;
      }
    }
    dword_504FE8[v2 + 8] = 0;
LABEL_7:
    pthread_mutex_unlock(&stru_504FEC);
    return 0;
  }
}
// 504FE8: using guessed type int dword_504FE8[];
// 505008: using guessed type int dword_505008;

//----- (00042BE0) --------------------------------------------------------
int sub_42BE0()
{
  char v1[2056]; // [sp+0h] [bp-808h] BYREF

  if ( pthread_mutex_lock(&stru_504FEC) )
  {
    strcpy(v1, "failed to api lock\n");
    return sub_2E584(0, v1, 0);
  }
  else
  {
    if ( dword_7F418 > 0 )
      sub_42E88(dword_7F418);
    return pthread_mutex_unlock(&stru_504FEC);
  }
}
// 7F418: using guessed type int dword_7F418;

//----- (00042C68) --------------------------------------------------------
int __fastcall sub_42C68(int a1)
{
  int v1; // r5
  int result; // r0
  char v3[2064]; // [sp+0h] [bp-810h] BYREF

  v1 = dword_505028;
  if ( dword_505028 )
    return 0;
  if ( a1 )
  {
    result = open64(a1);
    dword_50502C = result;
    if ( result < 0 )
    {
      strcpy(v3, "open lcd failed!!!\n");
      sub_2E584(v1, v3, v1);
      return -1;
    }
    else
    {
      dword_505028 = 1;
    }
  }
  else
  {
    strcpy(v3, "bad param\n");
    sub_2E584(0, v3, 0);
    return -3;
  }
  return result;
}
// 12198: using guessed type int __fastcall open64(_DWORD);
// 505028: using guessed type int dword_505028;
// 50502C: using guessed type int dword_50502C;

//----- (00042D2C) --------------------------------------------------------
int __fastcall sub_42D2C(int a1, int a2, int a3, unsigned int a4)
{
  int v4; // r7
  unsigned int v5; // r4
  bool v6; // cc
  int v7; // r5
  int v9; // r11
  unsigned __int8 v10; // r5
  size_t v11; // r6
  const void *v12; // r1
  char v15[2088]; // [sp+0h] [bp-828h] BYREF

  v4 = a2;
  if ( !dword_505028 )
    return -2;
  v5 = a4;
  if ( dword_50502C != a1 )
    goto LABEL_18;
  v6 = a4 > 0x40;
  if ( a4 <= 0x40 )
    v6 = (unsigned __int8)a2 > 3u;
  v7 = v6;
  if ( v6 )
  {
LABEL_18:
    strcpy(v15, "bad param\n");
    sub_2E584(1, v15, 0);
    return -3;
  }
  else
  {
    v9 = pthread_mutex_lock(&stru_505030);
    if ( v9 )
    {
      strcpy(v15, "failed to lcd lock\n");
      sub_2E584(v7, v15, v7);
      return -4;
    }
    else
    {
      do
      {
        v10 = v4 + 1;
        if ( v5 >= 0x10 )
          v11 = 16;
        else
          v11 = v5;
        v12 = (const void *)(a3 + v9);
        v9 += v11;
        memcpy((char *)&unk_505048 + 16 * v4, v12, v11);
        v5 -= v11;
        v4 = (char)v10;
      }
      while ( v10 <= 3u && v5 != 0 );
      write(dword_50502C, &unk_505048, 0x40u);
      pthread_mutex_unlock(&stru_505030);
      return 0;
    }
  }
}
// 505028: using guessed type int dword_505028;
// 50502C: using guessed type int dword_50502C;

//----- (00042E80) --------------------------------------------------------
int sub_42E80()
{
  return 0;
}

//----- (00042E88) --------------------------------------------------------
int __fastcall sub_42E88(int a1)
{
  int v1; // r6
  int v2; // r1
  char v4[2064]; // [sp+8h] [bp-810h] BYREF

  if ( !dword_505028 )
    return -2;
  if ( dword_50502C == a1 )
  {
    if ( pthread_mutex_lock(&stru_505030) )
    {
      strcpy(v4, "failed to lcd lock\n");
      sub_2E584(0, v4, 0);
      return -4;
    }
    else
    {
      memset(&unk_505048, 32, 0x40u);
      v1 = dword_50502C;
      lseek64(dword_50502C, v2, 0, 0, 0);
      write(v1, &unk_505048, 0x40u);
      pthread_mutex_unlock(&stru_505030);
      return 0;
    }
  }
  else
  {
    strcpy(v4, "bad param\n");
    sub_2E584(1, v4, 0);
    return -3;
  }
}
// 42EE8: variable 'v2' is possibly undefined
// 12120: using guessed type int __fastcall lseek64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 505028: using guessed type int dword_505028;
// 50502C: using guessed type int dword_50502C;

//----- (00042F88) --------------------------------------------------------
int __fastcall sub_42F88(int a1)
{
  int result; // r0
  char v2[2056]; // [sp+0h] [bp-808h] BYREF

  if ( !dword_505028 )
    return dword_505028;
  result = close(a1);
  if ( result )
  {
    strcpy(v2, "lcd close failed!!!\n");
    sub_2E584(0, v2, 0);
    result = -1;
  }
  dword_505028 = 0;
  return result;
}
// 505028: using guessed type int dword_505028;

//----- (00043004) --------------------------------------------------------
int sub_43004()
{
  return 941;
}

//----- (0004300C) --------------------------------------------------------
int sub_4300C()
{
  return 942;
}

//----- (00043014) --------------------------------------------------------
int sub_43014()
{
  return 921;
}

//----- (0004301C) --------------------------------------------------------
int sub_4301C()
{
  return 943;
}

//----- (00043024) --------------------------------------------------------
int __fastcall sub_43024(int a1)
{
  int v1; // r2
  int i; // r3

  v1 = 0;
  for ( i = 0; ; v1 = dword_695A8[4 * i] )
  {
    if ( v1 == a1 )
      return dword_695A8[4 * i + 1];
    if ( ++i == 16 )
      break;
  }
  return -2;
}
// 695A8: using guessed type _DWORD dword_695A8[4];

//----- (0004306C) --------------------------------------------------------
int __fastcall sub_4306C(int a1)
{
  int v1; // r2
  int i; // r3

  v1 = 0;
  for ( i = 0; ; v1 = dword_695A8[4 * i] )
  {
    if ( v1 == a1 )
      return dword_695A8[4 * i + 2];
    if ( ++i == 16 )
      break;
  }
  return -2;
}
// 695A8: using guessed type _DWORD dword_695A8[4];

//----- (000430B4) --------------------------------------------------------
int __fastcall sub_430B4(int a1)
{
  int v1; // r2
  int i; // r3

  v1 = 0;
  for ( i = 0; ; v1 = dword_695A8[4 * i] )
  {
    if ( v1 == a1 )
      return dword_695A8[4 * i + 3];
    if ( ++i == 16 )
      break;
  }
  return -2;
}
// 695A8: using guessed type _DWORD dword_695A8[4];

//----- (000430FC) --------------------------------------------------------
int sub_430FC()
{
  _DWORD *v0; // r3
  int result; // r0
  int v2; // t1

  v0 = dword_695A8;
  result = 0;
  while ( ++result != 16 )
  {
    v2 = v0[4];
    v0 += 4;
    if ( v2 == 255 && v0[1] == 255 && v0[2] == 255 && v0[3] == 255 )
      break;
  }
  return result;
}
// 695A8: using guessed type _DWORD dword_695A8[4];

//----- (00043148) --------------------------------------------------------
int __fastcall sub_43148(int a1)
{
  if ( !a1 || a1 == 1 || a1 == 2 || a1 == 3 || a1 == 4 || a1 == 5 )
    return dword_695A8[3 * a1 + 65];
  else
    return -2;
}
// 695A8: using guessed type _DWORD dword_695A8[4];

//----- (00043198) --------------------------------------------------------
int __fastcall sub_43198(int a1)
{
  if ( !a1 || a1 == 1 || a1 == 2 || a1 == 3 || a1 == 4 || a1 == 5 )
    return dword_695A8[3 * a1 + 66];
  else
    return -1;
}
// 695A8: using guessed type _DWORD dword_695A8[4];

//----- (000431E8) --------------------------------------------------------
int sub_431E8()
{
  _DWORD *v0; // r3
  int v1; // r2
  int result; // r0
  int v3; // t1

  v0 = &unk_696A8;
  v1 = 0;
  result = 0;
  while ( 1 )
  {
    if ( v1 != -1 )
      ++result;
    if ( v0 == (_DWORD *)&unk_696E4 )
      break;
    v3 = v0[3];
    v0 += 3;
    v1 = v3;
  }
  return result;
}

//----- (00043214) --------------------------------------------------------
int __fastcall sub_43214(int a1)
{
  int v2; // [sp+4h] [bp-Ch] BYREF

  sub_44000(a1, &v2);
  return v2;
}

//----- (00043230) --------------------------------------------------------
void *__fastcall sub_43230(int a1, const void *a2, size_t a3)
{
  int v4; // r5
  int v7; // r0
  int v9; // [sp+4h] [bp-1Ch] BYREF

  v4 = *(_DWORD *)(a1 + 12);
  v7 = *(_DWORD *)(a1 + 20);
  if ( *(_DWORD *)(*(_DWORD *)v4 + 32) )
  {
    sub_44000(v7, &v9);
    (*(void (__fastcall **)(int))(*(_DWORD *)v4 + 32))(v9);
    v7 = *(_DWORD *)(a1 + 20);
  }
  return sub_44040(*(void ***)(v7 + 20), a2, a3);
}

//----- (00043290) --------------------------------------------------------
int *__fastcall sub_43290(int a1)
{
  int v1; // r1
  int *v3; // r0
  int *result; // r0

  v1 = *(_DWORD *)(a1 + 20);
  v3 = **(int ***)(a1 + 12);
  if ( v1 )
    result = sub_43EF8(v3, v1);
  else
    result = sub_43EA4((int)v3, (_DWORD *)*v3);
  *(_DWORD *)(a1 + 20) = result;
  if ( result )
    return (int *)result[5];
  return result;
}

//----- (000432D0) --------------------------------------------------------
_DWORD *__fastcall sub_432D0(int a1, int a2, int a3)
{
  _DWORD *v6; // r4
  _DWORD *v7; // r0

  v6 = malloc(4u);
  if ( v6 && (v7 = sub_437AC(a1, a2, a3), (*v6 = v7) != 0) )
    return v6;
  else
    return 0;
}

//----- (00043320) --------------------------------------------------------
int __fastcall sub_43320(int *a1, const void *a2, size_t a3, const void *a4, size_t a5)
{
  if ( a1 )
    return sub_43884(*a1, a2, a3, a4, a5);
  else
    return 501;
}

//----- (00043338) --------------------------------------------------------
int *__fastcall sub_43338(int *result, int a2)
{
  if ( result )
    return (int *)(sub_43804(*result, a2) != 0);
  return result;
}

//----- (00043358) --------------------------------------------------------
int __fastcall sub_43358(int *a1, int a2)
{
  int *v2; // r0
  int *v3; // r4
  void *ptr[3]; // [sp+4h] [bp-Ch] BYREF

  if ( !a1 )
    return 501;
  v2 = sub_43AE8(*a1, a2);
  v3 = v2;
  if ( !v2 )
    return 0;
  sub_44000(v2[4], ptr);
  free(ptr[0]);
  sub_44074((void **)v3[4]);
  sub_44000(v3[5], ptr);
  free(ptr[0]);
  sub_44074((void **)v3[5]);
  free(v3);
  return 0;
}

//----- (000433D0) --------------------------------------------------------
int __fastcall sub_433D0(int *a1, int a2, _DWORD *a3)
{
  _DWORD *v4; // r0

  if ( !a1 )
    return 0;
  v4 = sub_43804(*a1, a2);
  if ( !v4 )
    return 0;
  sub_44000(v4[5], a3);
  return 1;
}

//----- (00043414) --------------------------------------------------------
int __fastcall sub_43414(void **a1)
{
  int v2; // r5

  if ( !a1 )
    return 0;
  v2 = sub_43D9C(*a1);
  free(a1);
  return v2;
}

//----- (00043440) --------------------------------------------------------
_DWORD *__fastcall sub_43440(int a1)
{
  _DWORD *result; // r0

  result = malloc(0x18u);
  result[3] = a1;
  *result = sub_43290;
  result[2] = sub_43214;
  result[1] = sub_43230;
  result[4] = 0;
  result[5] = 0;
  return result;
}

//----- (0004348C) --------------------------------------------------------
int **__fastcall sub_4348C(int **result, int *a2)
{
  int *v2; // r3
  int *v3; // r12
  int v4; // r2
  bool v5; // zf
  int v6; // r2

  v2 = (int *)a2[1];
  v3 = (int *)(result + 1);
  v4 = *v2;
  v5 = *v2 == (_DWORD)(result + 1);
  a2[1] = *v2;
  if ( !v5 )
    *(_DWORD *)(v4 + 8) = a2;
  v6 = a2[2];
  if ( v3 != v2 )
  {
    v2[2] = v6;
    v6 = a2[2];
  }
  if ( v6 )
  {
    result = *(int ***)v6;
    if ( *(int **)v6 == a2 )
      *(_DWORD *)v6 = v2;
    else
      *(_DWORD *)(v6 + 4) = v2;
  }
  else
  {
    *result = v2;
  }
  *v2 = (int)a2;
  if ( v3 != a2 )
    a2[2] = (int)v2;
  return result;
}

//----- (000434E0) --------------------------------------------------------
_DWORD *__fastcall sub_434E0(_DWORD *result, _DWORD *a2)
{
  _DWORD *v2; // r3
  _DWORD *v3; // r12
  _DWORD *v4; // r2
  int v5; // r2

  v2 = (_DWORD *)*a2;
  v3 = result + 1;
  v4 = *(_DWORD **)(*a2 + 4);
  *a2 = v4;
  if ( v4 != result + 1 )
    v4[2] = a2;
  v5 = a2[2];
  if ( v3 != v2 )
  {
    v2[2] = v5;
    v5 = a2[2];
  }
  if ( v5 )
  {
    result = *(_DWORD **)(v5 + 4);
    if ( result == a2 )
      *(_DWORD *)(v5 + 4) = v2;
    else
      *(_DWORD *)v5 = v2;
  }
  else
  {
    *result = v2;
  }
  v2[1] = a2;
  if ( v3 != a2 )
    a2[2] = v2;
  return result;
}

//----- (00043534) --------------------------------------------------------
int __fastcall sub_43534(int result, _DWORD *a2)
{
  int v2; // r5
  int v3; // r6
  _DWORD *v4; // r4

  v2 = result + 4;
  if ( a2 != (_DWORD *)(result + 4) )
  {
    v3 = result;
    v4 = a2;
    do
    {
      if ( v4[3] > 1u )
        _assert_fail(
          "debug_node_color(pTree,n) == clib_red || debug_node_color(pTree,n) == clib_black",
          "3rdparty/cstl/src/c_rb.c",
          0x1DFu,
          "debug_verify_property_1");
      result = sub_43534(v3, (_DWORD *)*v4);
      v4 = (_DWORD *)v4[1];
    }
    while ( v4 != (_DWORD *)v2 );
  }
  return result;
}

//----- (00043594) --------------------------------------------------------
int __fastcall sub_43594(int result, _DWORD *a2)
{
  int v2; // r6
  _DWORD *v4; // r5
  _DWORD *v5; // r1
  _DWORD *v6; // r3
  _DWORD *v7; // r2

  v2 = result;
  v4 = (_DWORD *)(result + 4);
  while ( 2 )
  {
    if ( a2 != v4 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          v5 = (_DWORD *)*a2;
          if ( a2[3] == 1 )
            break;
          a2 = (_DWORD *)a2[1];
LABEL_4:
          result = sub_43594(v2, v5);
          if ( a2 == v4 )
            return result;
        }
        if ( v5 != v4 && v5[3] )
          _assert_fail(
            "debug_node_color(pTree,n->left) == clib_black",
            "3rdparty/cstl/src/c_rb.c",
            0x1EFu,
            "debug_verify_property_4");
        v6 = (_DWORD *)a2[1];
        if ( v6 == v4 )
          break;
        if ( v6[3] )
          _assert_fail(
            "debug_node_color(pTree,n->right) == clib_black",
            "3rdparty/cstl/src/c_rb.c",
            0x1F0u,
            "debug_verify_property_4");
        v7 = (_DWORD *)a2[2];
        if ( v7 != v4 )
          goto LABEL_12;
        a2 = (_DWORD *)a2[1];
        result = sub_43594(v2, v5);
      }
      v7 = (_DWORD *)a2[2];
      if ( v7 == v4 )
      {
        a2 = (_DWORD *)*a2;
        continue;
      }
LABEL_12:
      if ( v7[3] )
        _assert_fail(
          "debug_node_color(pTree,n->parent) == clib_black",
          "3rdparty/cstl/src/c_rb.c",
          0x1F1u,
          "debug_verify_property_4");
      a2 = (_DWORD *)a2[1];
      goto LABEL_4;
    }
    return result;
  }
}

//----- (0004369C) --------------------------------------------------------
int __fastcall sub_4369C(int result, _DWORD *a2, int a3, _DWORD *a4)
{
  _DWORD *v4; // r4
  int v5; // r8
  int v6; // r9
  int v7; // r5
  int i; // r6

  v4 = a2;
  v5 = result + 4;
  v6 = result;
  v7 = a3;
  for ( i = a3 + 1; v4 != (_DWORD *)v5; v4 = (_DWORD *)v4[1] )
  {
    if ( !v4[3] )
      v7 = i++;
    result = sub_4369C(v6, (_DWORD *)*v4, v7, a4);
  }
  if ( *a4 == -1 )
  {
    *a4 = i;
  }
  else if ( *a4 != i )
  {
    _assert_fail(
      "black_count == *path_black_count",
      "3rdparty/cstl/src/c_rb.c",
      0x205u,
      "debug_verify_property_5_helper");
  }
  return result;
}

//----- (0004372C) --------------------------------------------------------
int __fastcall sub_4372C(_DWORD **a1)
{
  _DWORD *v1; // r4
  _DWORD *v2; // r5
  int v5; // [sp+4h] [bp-14h] BYREF

  v2 = a1 + 1;
  v1 = *a1;
  sub_43534((int)a1, *a1);
  if ( v1 != v2 && v1[3] )
    _assert_fail(
      "debug_node_color(pTree,root) == clib_black",
      "3rdparty/cstl/src/c_rb.c",
      0x1E6u,
      "debug_verify_property_2");
  sub_43594((int)a1, v1);
  v5 = -1;
  return sub_4369C((int)a1, v1, 0, &v5);
}

//----- (000437AC) --------------------------------------------------------
_DWORD *__fastcall sub_437AC(int a1, int a2, int a3)
{
  _DWORD *result; // r0

  result = malloc(0x28u);
  if ( result )
  {
    result[5] = 0;
    result[6] = 0;
    result[3] = 0;
    result[4] = 0;
    result[9] = a1;
    result[7] = a2;
    result[8] = a3;
    *result = result + 1;
    result[1] = result + 1;
    result[2] = result + 1;
  }
  return result;
}

//----- (00043804) --------------------------------------------------------
_DWORD *__fastcall sub_43804(int a1, int a2)
{
  _DWORD *v2; // r4
  _DWORD *v3; // r7
  _DWORD *v6; // r3
  int v7; // r5
  void *ptr; // [sp+4h] [bp-1Ch] BYREF

  v3 = (_DWORD *)(a1 + 4);
  v2 = *(_DWORD **)a1;
  if ( *(_DWORD *)a1 == a1 + 4 )
    return 0;
  while ( 1 )
  {
    sub_44000(v2[4], &ptr);
    v7 = (*(int (__fastcall **)(int, void *))(a1 + 36))(a2, ptr);
    free(ptr);
    if ( !v7 )
      break;
    v6 = (_DWORD *)*v2;
    v2 = (_DWORD *)v2[1];
    if ( v7 < 0 )
      v2 = v6;
    if ( v2 == v3 )
      return 0;
  }
  return v2;
}

//----- (00043884) --------------------------------------------------------
int __fastcall sub_43884(int a1, const void *a2, size_t a3, const void *a4, size_t a5)
{
  int *v9; // r5
  int v11; // r8
  int *v12; // r4
  __int64 v13; // r2
  int v14; // r7
  int v15; // r7
  int *v16; // r4
  int v17; // r3
  int *v18; // r7
  int v19; // r0
  int *v20; // r2
  void *ptr; // [sp+0h] [bp-28h] BYREF
  void *v22[9]; // [sp+4h] [bp-24h] BYREF

  v9 = (int *)malloc(0x18u);
  if ( !v9 )
    return 2;
  v11 = a1 + 4;
  *v9 = a1 + 4;
  v9[1] = a1 + 4;
  v9[3] = 1;
  v9[4] = (int)sub_43FA4(a2, a3);
  if ( a4 )
    v9[5] = (int)sub_43FA4(a4, a5);
  else
    v9[5] = 0;
  v12 = *(int **)a1;
  if ( v11 == *(_DWORD *)a1 )
  {
    *(_DWORD *)a1 = v9;
    v9[2] = 0;
    v20 = v9;
  }
  else
  {
    while ( 1 )
    {
      sub_44000(v12[4], &ptr);
      sub_44000(v9[4], v22);
      v14 = (*(int (__fastcall **)(void *, void *))(a1 + 36))(v22[0], ptr);
      free(ptr);
      free(v22[0]);
      if ( !v14 )
        return 401;
      v13 = *(_QWORD *)v12;
      if ( v14 < 0 )
        HIDWORD(v13) = *v12;
      if ( v11 == HIDWORD(v13) )
        break;
      v12 = (int *)HIDWORD(v13);
    }
    v9[2] = (int)v12;
    sub_44000(v12[4], &ptr);
    sub_44000(v9[4], v22);
    v15 = (*(int (__fastcall **)(void *, void *))(a1 + 36))(v22[0], ptr);
    free(ptr);
    free(v22[0]);
    v20 = *(int **)a1;
    if ( v15 >= 0 )
      v12[1] = (int)v9;
    else
      *v12 = (int)v9;
LABEL_17:
    if ( v9 != v20 )
    {
      do
      {
        v16 = (int *)v9[2];
        if ( v16[3] != 1 )
          break;
        v17 = v16[2];
        v18 = *(int **)v17;
        if ( v16 == *(int **)v17 )
        {
          v19 = *(_DWORD *)(v17 + 4);
          if ( *(_DWORD *)(v19 + 12) == 1 )
          {
            v16[3] = 0;
            v9 = (int *)v17;
            *(_DWORD *)(v19 + 12) = 0;
            *(_DWORD *)(v17 + 12) = 1;
          }
          else
          {
            if ( (int *)v18[1] == v9 )
            {
              sub_4348C((int **)a1, *(int **)v17);
              v18 = (int *)v18[2];
              v9 = v16;
              v17 = v18[2];
            }
            v18[3] = 0;
            *(_DWORD *)(v17 + 12) = 1;
            sub_434E0((_DWORD *)a1, (_DWORD *)v17);
            v20 = *(int **)a1;
          }
          goto LABEL_17;
        }
        if ( v18[3] == 1 )
        {
          v16[3] = 0;
          v9 = (int *)v17;
          v18[3] = 0;
          *(_DWORD *)(v17 + 12) = 1;
          goto LABEL_17;
        }
        if ( v9 == (int *)*v16 )
        {
          sub_434E0((_DWORD *)a1, (_DWORD *)v9[2]);
          v9 = v16;
          v17 = *(_DWORD *)(v16[2] + 8);
          v16 = (int *)v16[2];
        }
        v16[3] = 0;
        *(_DWORD *)(v17 + 12) = 1;
        sub_4348C((int **)a1, (int *)v17);
        v20 = *(int **)a1;
      }
      while ( v9 != *(int **)a1 );
    }
  }
  v20[3] = 0;
  sub_4372C((_DWORD **)a1);
  return 0;
}

//----- (00043AE8) --------------------------------------------------------
int *__fastcall sub_43AE8(int a1, int a2)
{
  int *v2; // r4
  int *v3; // r7
  int v6; // r5
  int *v7; // r3
  int *v8; // r5
  int *v9; // r7
  int **v10; // r3
  int v11; // r1
  int v12; // r3
  int v13; // r2
  int *v15; // r3
  int *v16; // r2
  int *v17; // r3
  int v18; // r1
  int v19; // r12
  int v20; // r0
  int v21; // r12
  int v22; // r0
  void *ptr; // [sp+4h] [bp-1Ch] BYREF

  v3 = (int *)(a1 + 4);
  v2 = *(int **)a1;
  if ( a1 + 4 == *(_DWORD *)a1 )
    return 0;
  while ( 1 )
  {
    sub_44000(v2[4], &ptr);
    v6 = (*(int (__fastcall **)(int, void *))(a1 + 36))(a2, ptr);
    free(ptr);
    v7 = (int *)*v2;
    if ( !v6 )
      break;
    v2 = (int *)v2[1];
    if ( v6 < 0 )
      v2 = v7;
    if ( v2 == v3 )
      return 0;
  }
  v8 = (int *)v2[1];
  if ( v3 != v7 )
  {
    if ( v3 != v8 )
    {
      while ( v3 != (int *)*v8 )
        v8 = (int *)*v8;
      v9 = v8;
      v8 = (int *)v8[1];
      goto LABEL_14;
    }
    v8 = (int *)*v2;
  }
  v9 = v2;
LABEL_14:
  v8[2] = v9[2];
  v10 = (int **)v9[2];
  if ( v10 )
  {
    if ( v9 == *v10 )
      *v10 = v8;
    else
      v10[1] = v8;
  }
  else
  {
    *(_DWORD *)a1 = v8;
  }
  if ( v9 != v2 )
  {
    v11 = v2[4];
    v12 = v2[5];
    v13 = v9[5];
    v2[4] = v9[4];
    v9[4] = v11;
    v2[5] = v13;
    v9[5] = v12;
  }
  if ( !v9[3] )
  {
    v15 = *(int **)a1;
LABEL_25:
    if ( v8 != v15 )
    {
      while ( !v8[3] )
      {
        v16 = (int *)v8[2];
        v17 = (int *)*v16;
        if ( v8 == (int *)*v16 )
        {
          v17 = (int *)v16[1];
          if ( v17[3] == 1 )
          {
            v17[3] = 0;
            v16[3] = 1;
            sub_4348C((int **)a1, v16);
            v16 = (int *)v8[2];
            v17 = (int *)v16[1];
          }
          v21 = v17[1];
          v22 = *(_DWORD *)(v21 + 12);
          if ( *(_DWORD *)(*v17 + 12) )
          {
            if ( v22 )
            {
              v8 = v16;
            }
            else
            {
              *(_DWORD *)(*v17 + 12) = 0;
              v17[3] = 1;
              sub_434E0((_DWORD *)a1, v17);
              v8 = (int *)v8[2];
              v17 = (int *)v8[1];
              v21 = v17[1];
            }
LABEL_42:
            v17[3] = v8[3];
            v8[3] = 0;
            *(_DWORD *)(v21 + 12) = 0;
            sub_4348C((int **)a1, v8);
            v8 = *(int **)a1;
            v15 = *(int **)a1;
            goto LABEL_25;
          }
          v8 = v16;
          if ( v22 )
            goto LABEL_42;
        }
        else
        {
          if ( v17[3] == 1 )
          {
            v17[3] = 0;
            v16[3] = 1;
            sub_434E0((_DWORD *)a1, v16);
            v16 = (int *)v8[2];
            v17 = (int *)*v16;
          }
          v18 = v17[1];
          v19 = *v17;
          v20 = *(_DWORD *)(*v17 + 12);
          if ( *(_DWORD *)(v18 + 12) )
          {
            if ( v20 )
            {
              v8 = v16;
            }
            else
            {
              *(_DWORD *)(v18 + 12) = 0;
              v17[3] = 1;
              sub_4348C((int **)a1, v17);
              v8 = (int *)v8[2];
              v17 = (int *)*v8;
              v19 = *(_DWORD *)*v8;
            }
LABEL_37:
            v17[3] = v8[3];
            v8[3] = 0;
            *(_DWORD *)(v19 + 12) = 0;
            sub_434E0((_DWORD *)a1, v8);
            v8 = *(int **)a1;
            v15 = *(int **)a1;
            goto LABEL_25;
          }
          v8 = v16;
          if ( v20 )
            goto LABEL_37;
        }
        v17[3] = 1;
        if ( v8 == *(int **)a1 )
          break;
      }
    }
    v8[3] = 0;
  }
  sub_4372C((_DWORD **)a1);
  return v9;
}

//----- (00043D9C) --------------------------------------------------------
int __fastcall sub_43D9C(void *ptr)
{
  char *v2; // r4
  char *v3; // r5
  char *v5; // r7
  void **v6; // r0
  void **v7; // r0
  int v8; // r8
  char *v9; // r0
  char *v10; // r0
  int v11; // [sp+0h] [bp-20h] BYREF
  int v12; // [sp+4h] [bp-1Ch] BYREF

  v3 = (char *)ptr + 4;
  v2 = *(char **)ptr;
  while ( v2 != v3 )
  {
    if ( *(char **)v2 == v3 )
    {
      v5 = (char *)*((_DWORD *)v2 + 1);
      if ( v3 == v5 )
      {
        v6 = (void **)*((_DWORD *)v2 + 4);
        if ( *((_DWORD *)ptr + 7) )
        {
          sub_44000((int)v6, &v11);
          (*((void (__fastcall **)(int))ptr + 7))(v11);
          v6 = (void **)*((_DWORD *)v2 + 4);
        }
        sub_44074(v6);
        v7 = (void **)*((_DWORD *)v2 + 5);
        if ( v7 )
        {
          if ( *((_DWORD *)ptr + 8) )
          {
            sub_44000((int)v7, &v12);
            (*((void (__fastcall **)(int))ptr + 8))(v12);
            v7 = (void **)*((_DWORD *)v2 + 5);
          }
          sub_44074(v7);
        }
        v8 = *((_DWORD *)v2 + 2);
        if ( v8 )
        {
          if ( v5 == *(char **)v8 )
          {
            v9 = *(char **)(v8 + 4);
            v2 = (char *)*((_DWORD *)v2 + 2);
            if ( v5 != v9 )
            {
              free(v9);
              *(_DWORD *)(v8 + 4) = v5;
            }
          }
          else
          {
            free(*(void **)v8);
            v2 = (char *)v8;
            *(_DWORD *)v8 = v5;
          }
        }
        else
        {
          v10 = v2;
          v2 = v5;
          free(v10);
        }
      }
      else
      {
        v2 = (char *)*((_DWORD *)v2 + 1);
      }
    }
    else
    {
      v2 = *(char **)v2;
    }
  }
  free(ptr);
  return 0;
}

//----- (00043EA4) --------------------------------------------------------
_DWORD *__fastcall sub_43EA4(int a1, _DWORD *a2)
{
  int v2; // r0

  v2 = a1 + 4;
  while ( *a2 != v2 )
    a2 = (_DWORD *)*a2;
  return a2;
}

//----- (00043EC4) --------------------------------------------------------
int __fastcall sub_43EC4(int a1, int a2)
{
  int v2; // r0

  v2 = a1 + 4;
  while ( *(_DWORD *)(a2 + 4) != v2 )
    a2 = *(_DWORD *)(a2 + 4);
  return a2;
}

//----- (00043EE4) --------------------------------------------------------
bool __fastcall sub_43EE4(_DWORD *a1)
{
  return *a1 != (_DWORD)(a1 + 1);
}

//----- (00043EF8) --------------------------------------------------------
int *__fastcall sub_43EF8(int *a1, int a2)
{
  int *v2; // r3
  int *v3; // r12
  int i; // r2
  int v6; // r2
  bool v7; // zf

  v2 = *(int **)(a2 + 4);
  v3 = a1 + 1;
  if ( v2 != a1 + 1 )
  {
    while ( v3 != (int *)*v2 )
      v2 = (int *)*v2;
    return v2;
  }
  for ( i = *a1; v3 != *(int **)(i + 4); i = *(_DWORD *)(i + 4) )
    ;
  if ( a2 == i )
    return 0;
  v6 = *(_DWORD *)(a2 + 8);
  if ( v3 == (int *)v6 )
    return a1 + 1;
  if ( a2 != *(_DWORD *)(v6 + 4) )
    return *(int **)(a2 + 8);
  while ( 1 )
  {
    v2 = *(int **)(v6 + 8);
    if ( v3 == v2 )
      break;
    v7 = v2[1] == v6;
    v6 = *(_DWORD *)(v6 + 8);
    if ( !v7 )
      return v2;
  }
  return *(int **)(v6 + 8);
}

//----- (00043FA4) --------------------------------------------------------
_DWORD *__fastcall sub_43FA4(const void *a1, size_t a2)
{
  _DWORD *v4; // r0
  _DWORD *v5; // r4
  void *v6; // r0
  void *v8; // r0

  v4 = malloc(8u);
  v5 = v4;
  if ( v4 )
  {
    v4[1] = a2;
    v6 = malloc(a2);
    *v5 = v6;
    if ( v6 )
    {
      memcpy(v6, a1, a2);
    }
    else
    {
      v8 = v5;
      v5 = 0;
      free(v8);
    }
  }
  return v5;
}

//----- (00044000) --------------------------------------------------------
int __fastcall sub_44000(int a1, _DWORD *a2)
{
  size_t v3; // r5
  void *v5; // r0

  v3 = *(_DWORD *)(a1 + 4);
  v5 = malloc(v3);
  *a2 = v5;
  if ( !v5 )
    return 3;
  memcpy(v5, *(const void **)a1, v3);
  return 0;
}

//----- (00044040) --------------------------------------------------------
void *__fastcall sub_44040(void **a1, const void *a2, size_t a3)
{
  void *v6; // r0

  free(*a1);
  v6 = malloc(a3);
  *a1 = v6;
  return memcpy(v6, a2, a3);
}

//----- (00044074) --------------------------------------------------------
void __fastcall sub_44074(void **a1)
{
  if ( a1 )
  {
    free(*a1);
    free(a1);
  }
}

//----- (00044098) --------------------------------------------------------
int __fastcall sub_44098(int a1)
{
  char s[2056]; // [sp+8h] [bp-808h] BYREF

  snprintf(s, 0x800u, "%s: Bad eeprom param, input chain is %d\n", "eeprom_open", a1);
  sub_2E584(0, s, 0);
  return -2147483391;
}

//----- (000440E8) --------------------------------------------------------
int __fastcall sub_440E8(unsigned int a1)
{
  int result; // r0
  unsigned int v3; // [sp+0h] [bp-18h] BYREF
  __int16 v4; // [sp+4h] [bp-14h]
  char v5; // [sp+6h] [bp-12h]
  char v6; // [sp+7h] [bp-11h]

  if ( a1 > 0xF )
    return sub_44098(a1);
  result = dword_505088[2 * a1];
  if ( !result || !dword_505088[2 * a1 + 1] )
  {
    v4 = 0;
    v5 = 10;
    v3 = a1;
    v6 = a1;
    result = sub_493D0((int)&v3);
    if ( result >= 0 )
    {
      dword_505088[2 * a1] = result;
      dword_505088[2 * a1 + 1] = 1;
    }
  }
  return result;
}
// 505088: using guessed type _DWORD dword_505088[32];

//----- (00044164) --------------------------------------------------------
int __fastcall sub_44164(unsigned int a1)
{
  int v2; // r6
  int result; // r0
  char s[2064]; // [sp+8h] [bp-810h] BYREF

  if ( a1 > 0xF )
  {
    snprintf(s, 0x800u, "%s: Bad eeprom param, input chain is %d\n", "eeprom_close", a1);
    return sub_2E584(0, s, 0);
  }
  else
  {
    v2 = 2 * a1;
    result = dword_505088[2 * a1];
    if ( result || dword_505088[v2 + 1] )
    {
      result = sub_49574(result);
      dword_505088[v2 + 1] = 0;
      dword_505088[2 * a1] = 0;
    }
  }
  return result;
}
// 505088: using guessed type _DWORD dword_505088[32];

//----- (00044200) --------------------------------------------------------
int __fastcall sub_44200(unsigned int a1, unsigned __int8 a2, int a3, int a4)
{
  int v8; // r8
  int v9; // r3
  int v10; // r0
  int v11; // r9
  unsigned __int8 v13; // [sp+Fh] [bp-821h] BYREF
  char s[2080]; // [sp+10h] [bp-820h] BYREF

  if ( a1 > 0xF )
  {
    snprintf(s, 0x800u, "%s: Bad eeprom param, input chain is %d\n", "eeprom_write", a1);
    v11 = -2147483391;
    sub_2E584(0, s, 0);
    return v11;
  }
  if ( !dword_505088[2 * a1 + 1] )
  {
    v11 = sub_440E8(a1);
    if ( v11 < 0 )
    {
      snprintf(s, 0x800u, "%s: auto exec eeprom_open, but chain %d open eeprom failed\n", "eeprom_write", a1);
      sub_2E584(0, s, 0);
      return v11;
    }
  }
  if ( a4 )
  {
    v8 = a3 + a4;
    while ( 1 )
    {
      v9 = a3;
      v10 = dword_505088[2 * a1];
      ++a3;
      v13 = a2++;
      if ( sub_49794(v10, &v13, 1, v9, 1) != 1 )
        break;
      if ( v8 == a3 )
        goto LABEL_10;
    }
    v11 = -2147483392;
    snprintf(s, 0x800u, "fail to write eeprom by iic, chain:%d, addr: %d", a1, v13);
    sub_2E584(0, s, 0);
    return v11;
  }
LABEL_10:
  sleep(1u);
  return 0;
}
// 505088: using guessed type _DWORD dword_505088[32];

//----- (00044358) --------------------------------------------------------
int __fastcall sub_44358(unsigned int a1, unsigned __int8 a2, int a3, int a4)
{
  int v8; // r8
  int v9; // r3
  int v10; // r0
  int v11; // r9
  unsigned __int8 v13; // [sp+Fh] [bp-821h] BYREF
  char s[2080]; // [sp+10h] [bp-820h] BYREF

  if ( a1 > 0xF )
  {
    snprintf(s, 0x800u, "%s: Bad eeprom param, input chain is %d\n", "eeprom_read", a1);
    v11 = -2147483391;
    sub_2E584(0, s, 0);
    return v11;
  }
  if ( !dword_505088[2 * a1 + 1] )
  {
    v11 = sub_440E8(a1);
    if ( v11 < 0 )
    {
      snprintf(s, 0x800u, "%s: auto exec eeprom_open, but chain %d open eeprom failed\n", "eeprom_read", a1);
      sub_2E584(0, s, 0);
      return v11;
    }
  }
  if ( a4 )
  {
    v8 = a3 + a4;
    while ( 1 )
    {
      v9 = a3;
      v10 = dword_505088[2 * a1];
      ++a3;
      v13 = a2++;
      if ( sub_496F4(v10, &v13, 1, v9, 1) != 1 )
        break;
      if ( v8 == a3 )
        goto LABEL_10;
    }
    v11 = -2147483392;
    snprintf(s, 0x800u, "fail to read eeprom by iic, chain: %d, addr: %d\n", a1, v13);
    sub_2E584(0, s, 0);
    return v11;
  }
LABEL_10:
  usleep(0x7A120u);
  return 0;
}
// 505088: using guessed type _DWORD dword_505088[32];

//----- (000444B8) --------------------------------------------------------
int sub_444B8()
{
  int v0; // r4
  int result; // r0
  int v2; // [sp+4h] [bp-14h] BYREF

  v0 = 10;
  v2 = 0;
  sub_40314(35, &v2);
  sub_40390(35, v2 & 0xFFFFFFBF);
  do
  {
    usleep(0x3E8u);
    v2 = 0;
    sub_40314(35, &v2);
    result = 35;
    if ( (v2 & 0x40) == 0 )
      break;
    v2 = 0;
    sub_40314(35, &v2);
    result = sub_40390(35, v2 & 0xFFFFFFBF);
    --v0;
  }
  while ( v0 );
  return result;
}

//----- (00044540) --------------------------------------------------------
int __fastcall sub_44540(int result)
{
  if ( result == 115200 )
    return 26;
  if ( (double)result == 1500000.0 )
    return 1;
  if ( (_UNKNOWN *)result == &unk_2DC6C0 )
    return 0;
  if ( (_UNKNOWN *)result == &unk_5B8D80 )
    return 3;
  if ( result == 12000000 )
    return 4;
  if ( result == 25000000 )
    return 5;
  return result;
}

//----- (000445E0) --------------------------------------------------------
int __fastcall sub_445E0(int a1)
{
  int v2; // r4
  int result; // r0
  int v4[3]; // [sp+4h] [bp-Ch] BYREF

  sub_40390(27, a1);
  if ( a1 >= 0 )
    return sub_40314(27, v4);
  v2 = 3001;
  do
  {
    sub_40314(27, v4);
    result = 1000;
    if ( v4[0] >= 0 )
      break;
    result = usleep(0x3E8u);
    --v2;
  }
  while ( v2 );
  return result;
}

//----- (0004464C) --------------------------------------------------------
int sub_4464C()
{
  return 0;
}

//----- (00044654) --------------------------------------------------------
__int64 __fastcall sub_44654(int a1)
{
  return *(_QWORD *)(dword_505108 + (a1 << 6) + 8);
}
// 505108: using guessed type int dword_505108;

//----- (0004466C) --------------------------------------------------------
int __fastcall sub_4466C(int a1)
{
  return *(_DWORD *)(dword_505108 + (a1 << 6));
}
// 505108: using guessed type int dword_505108;

//----- (00044680) --------------------------------------------------------
int __fastcall sub_44680(int a1)
{
  return *(_DWORD *)(dword_505108 + (a1 << 6) + 4);
}
// 505108: using guessed type int dword_505108;

//----- (00044698) --------------------------------------------------------
int __fastcall sub_44698(int a1, int a2, int a3)
{
  int v3; // r0
  int v4; // r0
  int v5; // r2
  int v6; // r1
  char v7; // t1

  v3 = a1 << 6;
  if ( a3 )
  {
    v4 = dword_505108 + v3 + 31;
    v5 = a2 + a3 - 1;
    v6 = a2 - 1;
    do
    {
      v7 = *(_BYTE *)++v4;
      *(_BYTE *)++v6 = v7;
    }
    while ( v6 != v5 );
  }
  return 0;
}
// 505108: using guessed type int dword_505108;

//----- (000446DC) --------------------------------------------------------
unsigned int sub_446DC()
{
  unsigned int v1; // [sp+4h] [bp-Ch] BYREF

  v1 = 0;
  sub_40314(13, &v1);
  v1 = ~(~HIWORD(v1) << 16);
  sub_40390(13, v1);
  return sleep(2u);
}

//----- (00044724) --------------------------------------------------------
unsigned int sub_44724()
{
  unsigned int v1; // [sp+4h] [bp-Ch] BYREF

  v1 = 0;
  sub_40314(13, &v1);
  v1 = HIWORD(v1) << 16;
  sub_40390(13, v1);
  return sleep(2u);
}

//----- (0004476C) --------------------------------------------------------
int sub_4476C()
{
  int v1; // [sp+4h] [bp-Ch] BYREF

  v1 = 0;
  sub_40314(35, &v1);
  return v1;
}

//----- (00044794) --------------------------------------------------------
int __fastcall sub_44794(int a1)
{
  return sub_40390(35, a1);
}

//----- (000447D8) --------------------------------------------------------
int sub_447D8()
{
  int v1; // [sp+4h] [bp-Ch] BYREF

  v1 = 0;
  sub_40314(35, &v1);
  sub_40390(35, v1 & 0xFFFFFFBF);
  return 0;
}

//----- (00044880) --------------------------------------------------------
int __fastcall sub_44880(__int16 a1)
{
  __int16 v1; // r4
  int v3; // [sp+4h] [bp-14h] BYREF

  v3 = 0;
  v1 = a1 << 8;
  sub_40314(35, &v3);
  sub_40390(35, v1 & 0xF00 | v3 & 0xFFFFF0FF);
  return 0;
}

//----- (000448C8) --------------------------------------------------------
int sub_448C8()
{
  int v1; // [sp+4h] [bp-Ch] BYREF

  v1 = 0;
  sub_40314(35, &v1);
  sub_40390(35, v1 | 0x8000);
  return 0;
}

//----- (00044970) --------------------------------------------------------
int sub_44970()
{
  int v1; // [sp+4h] [bp-Ch] BYREF

  v1 = 0;
  sub_40314(35, &v1);
  sub_40390(35, v1 & 0xFFFFFFDF);
  return 0;
}

//----- (000449E0) --------------------------------------------------------
int sub_449E0()
{
  int v1; // [sp+4h] [bp-Ch] BYREF

  v1 = 0;
  sub_40314(35, &v1);
  sub_40390(35, v1 & 0xFFFFBFFF);
  return 0;
}

//----- (00044A50) --------------------------------------------------------
int sub_44A50()
{
  int v1; // [sp+4h] [bp-Ch] BYREF

  v1 = 0;
  sub_40314(35, &v1);
  sub_40390(35, v1 & 0xFFFFDFFF);
  return 0;
}

//----- (00044A88) --------------------------------------------------------
int sub_44A88()
{
  int v1; // [sp+0h] [bp-10h] BYREF
  int v2; // [sp+4h] [bp-Ch] BYREF

  v1 = 0;
  sub_40314(27, &v1);
  v1 &= ~0x400000u;
  sub_40390(27, v1);
  v2 = 0;
  sub_40314(35, &v2);
  return sub_40390(35, v2 & 0xFFFFFFBF);
}

//----- (00044AE4) --------------------------------------------------------
int sub_44AE4()
{
  unsigned int v1; // [sp+4h] [bp-Ch] BYREF

  v1 = 0;
  sub_40314(13, &v1);
  sub_40390(13, ~(~HIWORD(v1) << 16));
  sleep(3u);
  sub_40314(13, &v1);
  sub_40390(13, HIWORD(v1) << 16);
  sleep(1u);
  return sub_444B8();
}

//----- (00044B54) --------------------------------------------------------
int __fastcall sub_44B54(char *a1, size_t a2)
{
  int v5; // [sp+8h] [bp-18h] BYREF
  int v6; // [sp+Ch] [bp-14h] BYREF

  v5 = 0;
  v6 = 0;
  sub_40314(31, &v5);
  sub_40314(32, &v6);
  return snprintf(a1, a2, "%08x%08x", v6, v5);
}

//----- (00044BB0) --------------------------------------------------------
int __fastcall sub_44BB0(int a1)
{
  return sub_40390(0, a1);
}

//----- (00044BBC) --------------------------------------------------------
int sub_44BBC()
{
  int v1; // [sp+4h] [bp-Ch] BYREF

  sub_40314(41, &v1);
  return v1;
}

//----- (00044BDC) --------------------------------------------------------
int __fastcall sub_44BDC(int a1)
{
  int v2; // [sp+4h] [bp-Ch] BYREF

  sub_40390(41, a1);
  return sub_40314(41, &v2);
}

//----- (00044C04) --------------------------------------------------------
int sub_44C04()
{
  int v1; // [sp+4h] [bp-Ch] BYREF

  sub_40314(39, &v1);
  return v1;
}

//----- (00044C24) --------------------------------------------------------
int __fastcall sub_44C24(int a1)
{
  _DWORD v3[3]; // [sp+4h] [bp-Ch] BYREF

  sub_40314(39, v3);
  sub_40390(39, a1);
  return sub_40314(39, v3);
}
// 44C24: using guessed type _DWORD var_C[3];

//----- (00044C5C) --------------------------------------------------------
int __fastcall sub_44C5C(int a1)
{
  int v2; // [sp+4h] [bp-Ch] BYREF

  sub_40390(20, a1);
  return sub_40314(20, &v2);
}

//----- (00044C84) --------------------------------------------------------
int __fastcall sub_44C84(int a1)
{
  int v2; // [sp+4h] [bp-Ch] BYREF

  sub_40390(20, a1 & 0x1FFFF | 0x80000000);
  return sub_40314(20, &v2);
}

//----- (00044CB0) --------------------------------------------------------
int sub_44CB0()
{
  int v1; // [sp+4h] [bp-Ch] BYREF

  sub_40314(22, &v1);
  return v1;
}

//----- (00044CD0) --------------------------------------------------------
int __fastcall sub_44CD0(int a1)
{
  int v2; // [sp+4h] [bp-Ch] BYREF

  sub_40390(22, a1);
  return sub_40314(22, &v2);
}

//----- (00044CF8) --------------------------------------------------------
int sub_44CF8()
{
  return sub_40390(33, 196608);
}

//----- (00044D04) --------------------------------------------------------
int sub_44D04()
{
  return sub_40390(33, 0x10000);
}

//----- (00044D10) --------------------------------------------------------
int sub_44D10()
{
  int v1; // [sp+4h] [bp-Ch] BYREF

  sub_40314(33, &v1);
  return (unsigned __int16)v1;
}

//----- (00044D30) --------------------------------------------------------
int sub_44D30()
{
  return sub_40390(33, 0);
}

//----- (00044D3C) --------------------------------------------------------
int sub_44D3C()
{
  int v1; // [sp+4h] [bp-Ch] BYREF

  sub_40314(6, &v1);
  return v1 & 0x7FFF;
}

//----- (00044D94) --------------------------------------------------------
__int64 __fastcall sub_44D94(_QWORD *a1)
{
  __int64 result; // r0
  __int64 v3; // r2
  __int64 v4; // [sp+0h] [bp-18h] BYREF
  __int64 v5[2]; // [sp+8h] [bp-10h] BYREF

  v4 = 0LL;
  v5[0] = 0LL;
  sub_40314(4, &v4);
  sub_40314(5, (_DWORD *)&v4 + 1);
  sub_40314(4, v5);
  sub_40314(5, (_DWORD *)v5 + 1);
  result = v4;
  v3 = v5[0];
  *a1 = v4;
  a1[1] = v3;
  return result;
}

//----- (00044DFC) --------------------------------------------------------
int sub_44DFC()
{
  int v1; // [sp+4h] [bp-Ch] BYREF

  sub_40314(21, &v1);
  return v1;
}

//----- (00044E1C) --------------------------------------------------------
int __fastcall sub_44E1C(int a1)
{
  int v2; // [sp+4h] [bp-Ch] BYREF

  sub_40390(21, a1);
  return sub_40314(21, &v2);
}

//----- (00044E44) --------------------------------------------------------
int sub_44E44()
{
  int v1; // [sp+4h] [bp-Ch] BYREF

  sub_40314(44, &v1);
  return v1;
}

//----- (00044E64) --------------------------------------------------------
int __fastcall sub_44E64(int a1)
{
  int v2; // [sp+4h] [bp-Ch] BYREF

  sub_40390(44, a1);
  return sub_40314(44, &v2);
}

//----- (00044E8C) --------------------------------------------------------
int sub_44E8C()
{
  int v1; // [sp+4h] [bp-Ch] BYREF

  sub_40314(42, &v1);
  return v1;
}

//----- (00044EAC) --------------------------------------------------------
int __fastcall sub_44EAC(int a1)
{
  int v2; // [sp+4h] [bp-Ch] BYREF

  sub_40390(42, a1);
  return sub_40314(42, &v2);
}

//----- (00044ED4) --------------------------------------------------------
int sub_44ED4()
{
  int v1; // [sp+4h] [bp-Ch] BYREF

  sub_40314(3, &v1);
  return v1;
}

//----- (00044F28) --------------------------------------------------------
int sub_44F28()
{
  int v1; // [sp+4h] [bp-Ch] BYREF

  sub_40314(45, &v1);
  return v1;
}

//----- (00044F48) --------------------------------------------------------
int __fastcall sub_44F48(int a1, int a2, int a3)
{
  unsigned int v3; // r3
  int v5; // r0
  bool v6; // zf
  _BOOL4 v7; // r12
  int v8; // r7
  int v9; // r8
  int v10; // r6
  int v11; // r5
  int v13; // r6
  int v14; // r5
  int v15[2]; // [sp+0h] [bp-20h]

  v3 = 0;
  v5 = 0;
  v15[0] = 0;
  v15[1] = 0;
  do
  {
    v6 = (a3 & (1 << v3)) == 0;
    if ( (a3 & (1 << v3)) != 0 )
      *((_BYTE *)v15 + v5) = v3;
    ++v3;
    if ( !v6 )
      ++v5;
    v7 = v3 <= 0x1F;
    if ( v5 > 7 )
      v7 = 0;
  }
  while ( v7 );
  if ( a2 == 4 )
  {
    sub_40390(45, a1);
    v13 = a1 | (1 << SLOBYTE(v15[0]));
    sub_40390(57, v13);
    v14 = 1 << SBYTE1(v15[0]);
    sub_40390(58, (1 << SBYTE1(v15[0])) | a1);
    return sub_40390(59, v13 | v14);
  }
  else if ( a2 == 8 )
  {
    sub_40390(45, a1);
    v8 = a1 | (1 << SLOBYTE(v15[0]));
    sub_40390(57, v8);
    v9 = (1 << SBYTE1(v15[0])) | a1;
    v10 = v8 | (1 << SBYTE1(v15[0]));
    sub_40390(58, v9);
    v11 = 1 << SBYTE2(v15[0]);
    sub_40390(59, (1 << SBYTE2(v15[0])) | a1);
    sub_40390(60, v10);
    sub_40390(61, v8 | v11);
    sub_40390(62, v9 | v11);
    return sub_40390(63, v11 | v10);
  }
  else
  {
    return sub_40390(45, a1);
  }
}

//----- (0004509C) --------------------------------------------------------
int sub_4509C()
{
  int v1; // [sp+4h] [bp-Ch] BYREF

  sub_40314(46, &v1);
  return v1;
}

//----- (000450BC) --------------------------------------------------------
int __fastcall sub_450BC(int a1)
{
  int v2; // [sp+4h] [bp-Ch] BYREF

  sub_40390(46, a1);
  return sub_40314(46, &v2);
}

//----- (000450E4) --------------------------------------------------------
int sub_450E4()
{
  int v1; // [sp+4h] [bp-Ch] BYREF

  sub_40314(47, &v1);
  return v1;
}

//----- (00045104) --------------------------------------------------------
int __fastcall sub_45104(int a1)
{
  int v2; // [sp+4h] [bp-Ch] BYREF

  sub_40390(47, a1);
  return sub_40314(47, &v2);
}

//----- (0004512C) --------------------------------------------------------
int __fastcall sub_4512C(int a1)
{
  int v1; // r5
  int v2; // r4
  int v3; // r0
  int v4; // t1
  int result; // r0

  v1 = a1 - 4;
  v2 = 48;
  do
  {
    v3 = v2++;
    v4 = *(_DWORD *)(v1 + 4);
    v1 += 4;
    result = sub_40390(v3, v4);
  }
  while ( v2 != 56 );
  return result;
}

//----- (00045154) --------------------------------------------------------
int __fastcall sub_45154(int a1)
{
  int v2; // [sp+4h] [bp-Ch] BYREF

  sub_40390(36, a1);
  return sub_40314(36, &v2);
}

//----- (00045244) --------------------------------------------------------
int __fastcall sub_45244(int *a1)
{
  _DWORD v3[3]; // [sp+4h] [bp-Ch] BYREF

  sub_40390(37, *a1);
  sub_40390(38, a1[1]);
  sub_40314(37, v3);
  return sub_40314(38, v3);
}
// 45244: using guessed type _DWORD var_C[3];

//----- (00045288) --------------------------------------------------------
int __fastcall sub_45288(unsigned __int16 a1)
{
  int v2; // [sp+4h] [bp-Ch] BYREF

  sub_40390(40, a1);
  return sub_40314(40, &v2);
}

//----- (000452B0) --------------------------------------------------------
int sub_452B0()
{
  int v1; // [sp+4h] [bp-Ch] BYREF

  sub_40314(7, &v1);
  return v1;
}

//----- (000452D0) --------------------------------------------------------
int __fastcall sub_452D0(int a1)
{
  int v2; // [sp+4h] [bp-Ch] BYREF

  sub_40390(7, a1);
  return sub_40314(7, &v2);
}

//----- (000452F8) --------------------------------------------------------
int sub_452F8()
{
  int v1[3]; // [sp+4h] [bp-Ch] BYREF

  sub_40314(7, v1);
  sub_40390(7, v1[0] | 0x10000);
  sub_40314(7, v1);
  return 0;
}

//----- (00045334) --------------------------------------------------------
int __fastcall sub_45334(int a1)
{
  size_t v2; // r5
  unsigned int v3; // r7
  size_t v4; // r7
  _BYTE *v5; // r0
  _BYTE *v6; // r6
  _BYTE *v7; // r3
  char *v8; // r8
  char *v9; // r0
  char *v10; // r3
  int v11; // r6
  int v12; // r2
  char v13; // t1
  int v14; // r5
  size_t v15; // r7
  int v16; // r12
  int v17; // t1
  int v18; // lr
  int v19; // t1
  unsigned int v20; // r1
  size_t v21; // r2
  _DWORD *v22; // r3
  int v23; // lr
  int v24; // r12
  int v25; // r0
  int v26; // lr
  int v27; // r12
  int v28; // r0
  int v29; // r1
  int v30; // r1
  int v31; // r0
  int *v32; // r12
  int v33; // lr
  int v34; // r3
  int v35; // r3
  unsigned int v36; // r1
  int v37; // r7
  int v38; // r6
  _BOOL4 v39; // r3
  int v40; // r4
  int result; // r0
  int v42; // [sp+Ch] [bp-5Ch]
  void *ptr; // [sp+10h] [bp-58h]
  size_t v44; // [sp+14h] [bp-54h]
  int v45; // [sp+1Ch] [bp-4Ch] BYREF
  int v46[18]; // [sp+20h] [bp-48h] BYREF

  memset(v46, 0, 0x20u);
  v2 = *(_DWORD *)(a1 + 12);
  v42 = dword_50510C;
  v3 = v2 & 0xFFFFFFC0;
  if ( dword_50510C == dword_505110 )
    v42 = dword_505114;
  if ( (*(_DWORD *)(a1 + 12) & 0x3Fu) <= 0x37 )
    v4 = v3 + 64;
  else
    v4 = v3 + 128;
  v5 = calloc(v4, 1u);
  v6 = v5;
  ptr = v5;
  if ( !v5 )
    return -4;
  memcpy(v5, *(const void **)(a1 + 8), v2);
  v7 = &v6[v4];
  v6[v2] = 0x80;
  *((_DWORD *)v7 - 2) = 0;
  *((_DWORD *)v7 - 1) = bswap32(8 * v2);
  if ( v4 )
  {
    v8 = v6 - 1;
    v9 = &v6[v4 - 1];
    v10 = v6 - 1;
    v11 = v42 - 1;
    v12 = v42 - 1;
    do
    {
      v13 = *++v10;
      *(_BYTE *)++v12 = v13;
    }
    while ( v9 != v10 );
    v44 = v4;
    v14 = 0;
    v15 = v42 - 1 + v4;
    do
    {
      v17 = *(unsigned __int8 *)++v11;
      v16 = v17;
      v19 = (unsigned __int8)*++v8;
      v18 = v19;
      if ( v16 != v19 )
        printf(
          "%s: coinbase_padding_in_ddr[%d] = 0x%x, but *(coinbase_padding + %d) = 0x%x",
          "dhash_send_job",
          v14,
          v16,
          v14,
          v18);
      ++v14;
    }
    while ( v15 != v11 );
    v4 = v44;
  }
  if ( *(_DWORD *)(a1 + 20) )
  {
    v20 = 0;
    v21 = v42 + v4;
    do
    {
      v21 += 32;
      v22 = (_DWORD *)(*(_DWORD *)(a1 + 16) + 32 * v20++);
      v23 = v22[1];
      v24 = v22[2];
      v25 = v22[3];
      *(_DWORD *)(v21 - 32) = *v22;
      *(_DWORD *)(v21 - 28) = v23;
      *(_DWORD *)(v21 - 24) = v24;
      *(_DWORD *)(v21 - 20) = v25;
      v26 = v22[5];
      v27 = v22[6];
      v28 = v22[7];
      *(_DWORD *)(v21 - 16) = v22[4];
      *(_DWORD *)(v21 - 12) = v26;
      *(_DWORD *)(v21 - 8) = v27;
      *(_DWORD *)(v21 - 4) = v28;
    }
    while ( *(_DWORD *)(a1 + 20) > v20 );
  }
  sub_444B8();
  if ( v42 == dword_50510C )
    v29 = dword_505118 + 0x200000;
  else
    v29 = dword_505118 + 2162688;
  sub_40390(41, v29);
  sub_40314(41, &v45);
  sub_40390(44, *(_DWORD *)(a1 + 32));
  sub_40314(44, &v45);
  if ( *(_DWORD *)a1 )
    v30 = 1;
  else
    v30 = *(_DWORD *)(a1 + 4);
  sub_44F48(*(_DWORD *)(a1 + 36), v30, *(_DWORD *)(a1 + 40));
  memset(v46, 0, 0x20u);
  v31 = *(_DWORD *)(a1 + 44);
  v32 = &v45;
  v33 = v31 + 32;
  do
  {
    v34 = *(unsigned __int8 *)(v31 + 2);
    v31 += 4;
    v32[1] = (v34 << 16) | (*(unsigned __int8 *)(v31 - 1) << 24) | *(unsigned __int8 *)(v31 - 4) | (*(unsigned __int8 *)(v31 - 3) << 8);
    ++v32;
  }
  while ( v31 != v33 );
  sub_4512C((int)v46);
  sub_40390(46, *(_DWORD *)(a1 + 24));
  sub_40314(46, &v45);
  sub_40390(47, *(_DWORD *)(a1 + 28));
  sub_40314(47, &v45);
  sub_40390(
    36,
    (unsigned __int16)(*(_WORD *)(a1 + 56) << 8) | (*(_DWORD *)(a1 + 52) << 16) | (unsigned __int8)(v4 >> 6));
  sub_40314(36, &v45);
  v35 = *(_DWORD *)(a1 + 68);
  v46[0] = *(_DWORD *)(a1 + 64);
  v46[1] = v35;
  sub_45244(v46);
  sub_45288(*(_DWORD *)(a1 + 20));
  sub_40390(42, (unsigned __int16)(v4 + 32 * *(_WORD *)(a1 + 20)));
  sub_40314(42, &v45);
  usleep(0x3E8u);
  sub_40390(20, *(_DWORD *)(a1 + 72) & 0x1FFFF | 0x80000000);
  sub_40314(20, &v45);
  v36 = *(_DWORD *)(a1 + 4);
  v37 = *(_DWORD *)a1;
  v38 = *(_DWORD *)(a1 + 76);
  v39 = v36 > 1;
  if ( *(_DWORD *)a1 )
    v39 = 0;
  if ( v39 )
  {
    v37 = 0;
    v40 = (v36 << 8) & 0xF00;
  }
  else
  {
    v40 = 256;
    if ( v37 )
      v37 = 0x4000;
  }
  if ( v38 )
  {
    v38 = 128;
    sub_452F8();
  }
  v45 = 0;
  sub_40314(35, &v45);
  sub_40390(35, v45 & 0xFFFF709F | 0x8060 | v37 | v40 | v38);
  free(ptr);
  result = 0;
  dword_505110 = v42;
  return result;
}
// 50510C: using guessed type int dword_50510C;
// 505110: using guessed type int dword_505110;
// 505114: using guessed type int dword_505114;
// 505118: using guessed type int dword_505118;
// 45334: using guessed type int var_48[18];

//----- (00045734) --------------------------------------------------------
int __fastcall sub_45734(char a1)
{
  int v1; // r4
  int v3; // [sp+4h] [bp-14h] BYREF

  v1 = a1 & 0x3F;
  pthread_mutex_lock(&stru_50511C);
  usleep(0xC350u);
  sub_40314(27, &v3);
  sub_445E0(v3 & 0xFFFFFFC0 | v1);
  return pthread_mutex_unlock(&stru_50511C);
}

//----- (00045788) --------------------------------------------------------
int __fastcall sub_45788(int a1, int a2)
{
  int v4; // r0
  int v6; // [sp+4h] [bp-14h] BYREF

  pthread_mutex_lock(&stru_50511C);
  sub_40314(27, &v6);
  if ( a2 )
    v4 = v6 & 0xFFF0FFFF | (a1 << 16) | 0xC00000;
  else
    v4 = v6 & 0xFFB0FFFF | (a1 << 16) & 0xFFBFFFFF;
  if ( !a2 )
    v4 |= 0x800000u;
  sub_445E0(v4);
  return pthread_mutex_unlock(&stru_50511C);
}

//----- (000457E0) --------------------------------------------------------
int __fastcall sub_457E0(int *a1, int a2)
{
  int v5[5]; // [sp+4h] [bp-14h] BYREF

  pthread_mutex_lock(&stru_50511C);
  sub_40390(28, *a1);
  sub_40390(29, a1[1]);
  sub_40390(30, a1[2]);
  sub_40314(28, v5);
  sub_40314(29, v5);
  sub_40314(30, v5);
  sub_40314(27, v5);
  sub_445E0(v5[0] & 0x7F70FFFF | 0x80800000 | (a2 << 16));
  return pthread_mutex_unlock(&stru_50511C);
}

//----- (0004587C) --------------------------------------------------------
int __fastcall sub_4587C(int *a1, unsigned int a2)
{
  unsigned int v4; // r5
  int *v5; // r5
  int v6; // r0
  int v7; // t1

  pthread_mutex_lock(&stru_505134);
  v4 = a2 >> 2;
  if ( v4 )
  {
    v5 = &a1[v4];
    v6 = 16;
    do
    {
      v7 = *a1++;
      sub_40390(v6, v7);
      v6 = 17;
    }
    while ( a1 != v5 );
  }
  return pthread_mutex_unlock(&stru_505134);
}

//----- (000458C4) --------------------------------------------------------
int sub_458C4()
{
  int v1; // [sp+4h] [bp-Ch] BYREF

  sub_40314(18, &v1);
  return v1;
}

//----- (000458E4) --------------------------------------------------------
int __fastcall sub_458E4(int a1)
{
  sub_40390(18, a1 | 0x80808000);
  dword_505110 = dword_50510C;
  return sub_44C24(dword_505118);
}
// 50510C: using guessed type int dword_50510C;
// 505110: using guessed type int dword_505110;
// 505118: using guessed type int dword_505118;

//----- (00045918) --------------------------------------------------------
int sub_45918()
{
  int v1; // [sp+4h] [bp-Ch] BYREF

  v1 = 0;
  sub_40314(15, &v1);
  return v1;
}

//----- (00045940) --------------------------------------------------------
int __fastcall sub_45940(int a1)
{
  return sub_40390(15, a1);
}

//----- (0004594C) --------------------------------------------------------
int __fastcall sub_4594C(char a1)
{
  int v3; // [sp+4h] [bp-Ch] BYREF

  v3 = 0;
  sub_40314(13, &v3);
  return sub_40390(13, v3 | (1 << a1));
}

//----- (00045990) --------------------------------------------------------
int __fastcall sub_45990(char a1)
{
  int v3; // [sp+4h] [bp-Ch] BYREF

  v3 = 0;
  sub_40314(13, &v3);
  return sub_40390(13, v3 & ~(1 << a1));
}

//----- (000459D4) --------------------------------------------------------
int __fastcall sub_459D4(char a1)
{
  sub_4594C(a1);
  usleep(0x186A0u);
  return sub_45990(a1);
}

//----- (000459F8) --------------------------------------------------------
int sub_459F8()
{
  return usleep(0x186A0u);
}

//----- (00045A0C) --------------------------------------------------------
unsigned int sub_45A0C()
{
  unsigned int v1; // [sp+4h] [bp-Ch] BYREF

  v1 = 0;
  sub_40314(0, &v1);
  return v1 >> 31;
}

//----- (00045ACC) --------------------------------------------------------
int sub_45ACC()
{
  int v1; // [sp+4h] [bp-Ch] BYREF

  v1 = 0;
  sub_40314(0, &v1);
  sub_40390(0, v1 & 0xDFFFFFFF);
  return 0;
}

//----- (00045B0C) --------------------------------------------------------
unsigned int sub_45B0C()
{
  unsigned int v1; // [sp+4h] [bp-Ch] BYREF

  v1 = 0;
  sub_40314(0, &v1);
  return (v1 >> 29) & 1;
}

//----- (00045B34) --------------------------------------------------------
int sub_45B34()
{
  int v1; // [sp+4h] [bp-Ch] BYREF

  v1 = 0;
  sub_40314(0, &v1);
  sub_40390(0, v1 | 0x40000000);
  return 0;
}

//----- (00045B74) --------------------------------------------------------
int sub_45B74()
{
  int v0; // r0
  int v1; // r5
  int v2; // r0
  int v3; // r3
  int v5; // [sp+4h] [bp-54h] BYREF
  struct sysinfo v6; // [sp+8h] [bp-50h] BYREF

  v0 = sub_40408();
  v1 = v0 + 0x200000;
  dword_505108 = v0;
  dword_50510C = v0 + 0x200000;
  dword_505114 = v0 + 2162688;
  v2 = sysinfo(&v6);
  if ( v6.totalram <= 0x3B9ACA00 )
  {
    if ( v6.totalram <= 0x1DCD6500 )
    {
      v3 = 200000000;
      if ( v6.totalram > 0xBEBC200 )
        v2 = 251658240;
      else
        v3 = 117440512;
      if ( v6.totalram > 0xBEBC200 )
        dword_505118 = v2;
      else
        v2 = v3;
      if ( v6.totalram <= 0xBEBC200 )
        dword_505118 = v3;
    }
    else
    {
      v2 = 520093696;
      dword_505118 = 520093696;
    }
  }
  else
  {
    v2 = 1056964608;
    dword_505118 = 1056964608;
  }
  dword_505110 = v1;
  sub_44C24(v2);
  sub_40390(41, dword_505118 + 0x200000);
  sub_40314(41, &v5);
  sub_45ACC();
  sub_45B34();
  return 0;
}
// 505108: using guessed type int dword_505108;
// 50510C: using guessed type int dword_50510C;
// 505110: using guessed type int dword_505110;
// 505114: using guessed type int dword_505114;
// 505118: using guessed type int dword_505118;

//----- (00045C70) --------------------------------------------------------
unsigned int sub_45C70()
{
  unsigned int v1; // [sp+4h] [bp-Ch] BYREF

  v1 = 0;
  sub_40314(0, &v1);
  return (v1 >> 30) & 1;
}

//----- (00045C98) --------------------------------------------------------
int sub_45C98()
{
  int v1; // [sp+4h] [bp-Ch] BYREF

  v1 = 0;
  sub_40314(0, &v1);
  return v1;
}

//----- (00045CBC) --------------------------------------------------------
int __fastcall sub_45CBC(int a1, int a2)
{
  char v3; // r5
  int v4; // r1
  int v6; // [sp+4h] [bp-14h] BYREF

  v3 = sub_44540(a2);
  v6 = 0;
  sub_40314(15, &v6);
  v4 = v6;
  if ( a1 )
  {
    switch ( a1 )
    {
      case 1:
        v4 = v6 & 0xFFFFC0FF | ((v3 & 0x3F) << 8);
        break;
      case 2:
        v4 = v6 & 0xFFC0FFFF | ((v3 & 0x3F) << 16);
        break;
      case 3:
        v4 = v6 & 0xC0FFFFFF | ((v3 & 0x3F) << 24);
        break;
    }
  }
  else
  {
    v4 = v6 & 0xFFFFFFC0 | v3 & 0x3F;
  }
  sub_40390(15, v4);
  return 0;
}

//----- (00045E80) --------------------------------------------------------
int __fastcall sub_45E80(int a1)
{
  char s[2056]; // [sp+8h] [bp-808h] BYREF

  snprintf(s, 0x800u, "%s: Bad pic param, input chain is %d\n", "open_pic", a1);
  sub_2E584(0, s, 0);
  return -2147483135;
}

//----- (00045ED0) --------------------------------------------------------
int __fastcall sub_45ED0(unsigned __int8 *a1, unsigned int a2)
{
  unsigned int v4; // r4
  int v5; // r3
  unsigned int v6; // r4
  int v7; // r3
  char s[4]; // [sp+8h] [bp-818h] BYREF

  snprintf(s, 0x800u, "Dumping %u %s bytes from %p:\n", a2, "read return data", a1);
  v4 = 0;
  sub_2E584(2, s, 0);
  do
  {
    while ( a2 > v4 )
    {
      v5 = a1[v4++];
      snprintf(s, 0x800u, "%02x ", v5);
      sub_2E584(2, s, 0);
      if ( v4 == 16 )
        goto LABEL_5;
    }
    ++v4;
    *(_DWORD *)s = &unk_202020;
    sub_2E584(2, s, 0);
  }
  while ( v4 != 16 );
LABEL_5:
  v6 = 0;
  do
  {
    while ( a2 <= v6 )
    {
      ++v6;
      strcpy(s, " ");
      sub_2E584(2, s, 0);
      if ( v6 == 16 )
        goto LABEL_11;
    }
    v7 = a1[v6++];
    if ( (unsigned int)(v7 - 32) > 0x5E )
      v7 = 46;
    snprintf(s, 0x800u, "%c", v7);
    sub_2E584(2, s, 0);
  }
  while ( v6 != 16 );
LABEL_11:
  strcpy(s, "\n");
  return sub_2E584(2, s, 0);
}

//----- (00046024) --------------------------------------------------------
int __fastcall sub_46024(unsigned int a1)
{
  int v2; // r6
  unsigned int v4; // [sp+0h] [bp-18h] BYREF
  __int16 v5; // [sp+4h] [bp-14h]
  char v6; // [sp+6h] [bp-12h]
  char v7; // [sp+7h] [bp-11h]

  if ( a1 > 0xF )
    return sub_45E80(a1);
  v2 = dword_99EE48[2 * a1];
  if ( !v2 || !dword_99EE48[2 * a1 + 1] )
  {
    v5 = 0;
    v6 = 4;
    v4 = a1;
    v7 = a1;
    pthread_mutex_lock(&stru_50514C);
    v2 = sub_493D0((int)&v4);
    pthread_mutex_unlock(&stru_50514C);
    if ( v2 >= 0 )
    {
      dword_99EE48[2 * a1] = v2;
      dword_99EE48[2 * a1 + 1] = 1;
    }
  }
  return v2;
}
// 50514C: using guessed type pthread_mutex_t stru_50514C;
// 99EE48: using guessed type _DWORD dword_99EE48[32];

//----- (000460C4) --------------------------------------------------------
unsigned int __fastcall sub_460C4(unsigned int result)
{
  unsigned int v1; // r5
  int v2; // r6
  char s[2064]; // [sp+8h] [bp-810h] BYREF

  v1 = result;
  if ( result > 0xF )
  {
    snprintf(s, 0x800u, "%s: Bad pic param, input chain is %d\n", "close_pic", result);
    return sub_2E584(0, s, 0);
  }
  else
  {
    v2 = 2 * result;
    if ( dword_99EE48[2 * result] || dword_99EE48[v2 + 1] )
    {
      pthread_mutex_lock(&stru_50514C);
      sub_49574(dword_99EE48[2 * v1]);
      dword_99EE48[v2 + 1] = 0;
      return pthread_mutex_unlock(&stru_50514C);
    }
  }
  return result;
}
// 50514C: using guessed type pthread_mutex_t stru_50514C;
// 99EE48: using guessed type _DWORD dword_99EE48[32];

//----- (00046178) --------------------------------------------------------
int __fastcall sub_46178(unsigned int a1)
{
  int v2; // r5
  int v3; // r4
  unsigned int v4; // r3
  int v6; // [sp+8h] [bp-830h] BYREF
  unsigned __int8 v7; // [sp+Ch] [bp-82Ch]
  int v8[4]; // [sp+10h] [bp-828h] BYREF
  char s[2072]; // [sp+20h] [bp-818h] BYREF

  if ( a1 > 0xF )
  {
    snprintf(s, 0x800u, "%s: Bad pic param, input chain is %d\n", "get_pic_version", a1);
    v3 = -2147483135;
    sub_2E584(0, s, 0);
    return v3;
  }
  if ( !dword_99EE48[2 * a1 + 1] )
  {
    v3 = sub_46024(a1);
    if ( v3 < 0 )
    {
      snprintf(s, 0x800u, "%s: auto exec open_pic, but chain %d open eeprom failed\n", "get_pic_version", a1);
      sub_2E584(0, s, 0);
      return v3;
    }
  }
  v2 = dword_99EE48[2 * a1];
  pthread_mutex_lock(&stru_50514C);
  v8[1] = 6912;
  v8[0] = 386181717;
  v8[2] = 0;
  v8[3] = 0;
  v6 = 0;
  v7 = 0;
  if ( sub_4966C(v2, (int)v8, 6) != 6 )
  {
    snprintf(s, 0x800u, "%s write iic err\n", "_bitmain_pic_get_sw_ver_common");
LABEL_15:
    sub_2E584(0, s, 0);
    goto LABEL_16;
  }
  usleep(0x493E0u);
  if ( sub_495E4(v2, &v6, 5) != 5 )
  {
    snprintf(s, 0x800u, "%s read iic err\n", "_bitmain_pic_get_sw_ver_common");
    goto LABEL_15;
  }
  if ( BYTE1(v6) == 23 && (unsigned __int8)v6 == 5 )
  {
    v3 = BYTE2(v6);
    v4 = BYTE2(v6) + 28;
    if ( HIBYTE(v6) == v4 >> 8 && v7 == (unsigned __int8)v4 )
      goto LABEL_10;
    snprintf(s, 0x800u, "%s failed 2!\n", "_bitmain_pic_get_sw_ver_common");
  }
  else
  {
    snprintf(s, 0x800u, "%s failed!\n", "_bitmain_pic_get_sw_ver_common");
  }
  sub_2E584(0, s, 0);
  sub_45ED0((unsigned __int8 *)&v6, 5u);
LABEL_16:
  v3 = -2147483136;
LABEL_10:
  pthread_mutex_unlock(&stru_50514C);
  return v3;
}
// 50514C: using guessed type pthread_mutex_t stru_50514C;
// 99EE48: using guessed type _DWORD dword_99EE48[32];

//----- (0004637C) --------------------------------------------------------
int __fastcall sub_4637C(unsigned int a1)
{
  int v2; // r6
  int v3; // r4
  __int16 v5; // [sp+Ch] [bp-82Ch] BYREF
  int v6[4]; // [sp+10h] [bp-828h] BYREF
  char s[2072]; // [sp+20h] [bp-818h] BYREF

  if ( a1 > 0xF )
  {
    snprintf(s, 0x800u, "%s: Bad pic param, input chain is %d\n", "reset_pic", a1);
    v3 = -2147483135;
    sub_2E584(0, s, 0);
    return v3;
  }
  if ( !dword_99EE48[2 * a1 + 1] )
  {
    v3 = sub_46024(a1);
    if ( v3 < 0 )
    {
      snprintf(s, 0x800u, "%s: auto exec open_pic, but chain %d open eeprom failed\n", "reset_pic", a1);
      sub_2E584(0, s, 0);
      return v3;
    }
  }
  v2 = dword_99EE48[2 * a1];
  v3 = 0;
  pthread_mutex_lock(&stru_50514C);
  v6[1] = 2816;
  v6[0] = 117746261;
  v6[2] = 0;
  v6[3] = 0;
  v5 = 0;
  if ( sub_4966C(v2, (int)v6, 6) != 6 )
  {
    snprintf(s, 0x800u, "%s write iic err\n", "_bitmain_pic_reset_common");
LABEL_13:
    sub_2E584(0, s, 0);
    goto LABEL_14;
  }
  usleep(0x493E0u);
  if ( sub_495E4(v2, &v5, 2) != 2 )
  {
    snprintf(s, 0x800u, "%s read iic err\n", "_bitmain_pic_reset_common");
    goto LABEL_13;
  }
  if ( (unsigned __int8)v5 == 7 && HIBYTE(v5) == 1 )
    goto LABEL_8;
  snprintf(
    s,
    0x800u,
    "%s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
    "_bitmain_pic_reset_common",
    (unsigned __int8)v5,
    HIBYTE(v5));
  sub_2E584(0, s, 0);
LABEL_14:
  v3 = -2147483136;
LABEL_8:
  pthread_mutex_unlock(&stru_50514C);
  usleep(0x7A120u);
  return v3;
}
// 50514C: using guessed type pthread_mutex_t stru_50514C;
// 99EE48: using guessed type _DWORD dword_99EE48[32];

//----- (00046554) --------------------------------------------------------
int __fastcall sub_46554(unsigned int a1)
{
  int v2; // r6
  int v3; // r4
  __int16 v5; // [sp+Ch] [bp-82Ch] BYREF
  int v6[4]; // [sp+10h] [bp-828h] BYREF
  char s[2072]; // [sp+20h] [bp-818h] BYREF

  if ( a1 > 0xF )
  {
    snprintf(s, 0x800u, "%s: Bad pic param, input chain is %d\n", "jump_from_loader_to_app", a1);
    v3 = -2147483135;
    sub_2E584(0, s, 0);
    return v3;
  }
  if ( !dword_99EE48[2 * a1 + 1] )
  {
    v3 = sub_46024(a1);
    if ( v3 < 0 )
    {
      snprintf(s, 0x800u, "%s: auto exec open_pic, but chain %d open eeprom failed\n", "jump_from_loader_to_app", a1);
      sub_2E584(0, s, 0);
      return v3;
    }
  }
  v2 = dword_99EE48[2 * a1];
  v3 = 0;
  pthread_mutex_lock(&stru_50514C);
  v6[1] = 2560;
  v6[0] = 100969045;
  v6[2] = 0;
  v6[3] = 0;
  v5 = 0;
  if ( sub_4966C(v2, (int)v6, 6) != 6 )
  {
    snprintf(s, 0x800u, "%s write iic err\n", "_bitmain_pic_start_app_common");
LABEL_13:
    sub_2E584(0, s, 0);
    goto LABEL_14;
  }
  usleep(0x493E0u);
  if ( sub_495E4(v2, &v5, 2) != 2 )
  {
    snprintf(s, 0x800u, "%s read iic err\n", "_bitmain_pic_start_app_common");
    goto LABEL_13;
  }
  usleep(0x493E0u);
  if ( (unsigned __int8)v5 == 6 && HIBYTE(v5) == 1 )
    goto LABEL_8;
  snprintf(
    s,
    0x800u,
    "%s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
    "_bitmain_pic_start_app_common",
    (unsigned __int8)v5,
    HIBYTE(v5));
  sub_2E584(0, s, 0);
LABEL_14:
  v3 = -2147483136;
LABEL_8:
  pthread_mutex_unlock(&stru_50514C);
  return v3;
}
// 50514C: using guessed type pthread_mutex_t stru_50514C;
// 99EE48: using guessed type _DWORD dword_99EE48[32];

//----- (0004672C) --------------------------------------------------------
int __fastcall sub_4672C(unsigned int a1)
{
  int v2; // r6
  int v3; // r4
  __int16 v5; // [sp+Ch] [bp-82Ch] BYREF
  int v6[4]; // [sp+10h] [bp-828h] BYREF
  char s[2072]; // [sp+20h] [bp-818h] BYREF

  if ( a1 > 0xF )
  {
    snprintf(s, 0x800u, "%s: Bad pic param, input chain is %d\n", "enable_dc_dc", a1);
    v3 = -2147483135;
    sub_2E584(0, s, 0);
    return v3;
  }
  if ( !dword_99EE48[2 * a1 + 1] )
  {
    v3 = sub_46024(a1);
    if ( v3 < 0 )
    {
      snprintf(s, 0x800u, "%s: auto exec open_pic, but chain %d open eeprom failed\n", "enable_dc_dc", a1);
      sub_2E584(0, s, 0);
      return v3;
    }
  }
  v2 = dword_99EE48[2 * a1];
  v3 = 0;
  pthread_mutex_lock(&stru_50514C);
  v6[1] = 1769473;
  v6[0] = 352692821;
  v6[2] = 0;
  v6[3] = 0;
  v5 = 0;
  if ( sub_4966C(v2, (int)v6, 7) != 7 )
  {
    snprintf(s, 0x800u, "%s write iic err\n", "_bitmain_pic_enable_dc_dc_common");
LABEL_13:
    sub_2E584(0, s, 0);
    goto LABEL_14;
  }
  usleep(0x493E0u);
  if ( sub_495E4(v2, &v5, 2) != 2 )
  {
    snprintf(s, 0x800u, "%s read iic err\n", "_bitmain_pic_enable_dc_dc_common");
    goto LABEL_13;
  }
  if ( (unsigned __int8)v5 == 21 && HIBYTE(v5) == 1 )
    goto LABEL_8;
  snprintf(
    s,
    0x800u,
    "%s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
    "_bitmain_pic_enable_dc_dc_common",
    (unsigned __int8)v5,
    HIBYTE(v5));
  sub_2E584(0, s, 0);
LABEL_14:
  v3 = -2147483136;
LABEL_8:
  pthread_mutex_unlock(&stru_50514C);
  return v3;
}
// 50514C: using guessed type pthread_mutex_t stru_50514C;
// 99EE48: using guessed type _DWORD dword_99EE48[32];

//----- (00046900) --------------------------------------------------------
int __fastcall sub_46900(unsigned int a1)
{
  int v2; // r6
  int v3; // r4
  __int16 v5; // [sp+Ch] [bp-82Ch] BYREF
  int v6[4]; // [sp+10h] [bp-828h] BYREF
  char s[2072]; // [sp+20h] [bp-818h] BYREF

  if ( a1 > 0xF )
  {
    snprintf(s, 0x800u, "%s: Bad pic param, input chain is %d\n", "disable_dc_dc", a1);
    v3 = -2147483135;
    sub_2E584(0, s, 0);
    return v3;
  }
  if ( !dword_99EE48[2 * a1 + 1] )
  {
    v3 = sub_46024(a1);
    if ( v3 < 0 )
    {
      snprintf(s, 0x800u, "%s: auto exec open_pic, but chain %d open eeprom failed\n", "disable_dc_dc", a1);
      sub_2E584(0, s, 0);
      return v3;
    }
  }
  v2 = dword_99EE48[2 * a1];
  v3 = 0;
  pthread_mutex_lock(&stru_50514C);
  v6[1] = 1703936;
  v6[0] = 352692821;
  v6[2] = 0;
  v6[3] = 0;
  v5 = 0;
  if ( sub_4966C(v2, (int)v6, 7) != 7 )
  {
    snprintf(s, 0x800u, "%s write iic err\n", "_bitmain_pic_disable_dc_dc_common");
LABEL_13:
    sub_2E584(0, s, 0);
    goto LABEL_14;
  }
  usleep(0x493E0u);
  if ( sub_495E4(v2, &v5, 2) != 2 )
  {
    snprintf(s, 0x800u, "%s read iic err\n", "_bitmain_pic_disable_dc_dc_common");
    goto LABEL_13;
  }
  if ( (unsigned __int8)v5 == 21 && HIBYTE(v5) == 1 )
    goto LABEL_8;
  snprintf(
    s,
    0x800u,
    "%s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
    "_bitmain_pic_disable_dc_dc_common",
    (unsigned __int8)v5,
    HIBYTE(v5));
  sub_2E584(0, s, 0);
LABEL_14:
  v3 = -2147483136;
LABEL_8:
  pthread_mutex_unlock(&stru_50514C);
  return v3;
}
// 50514C: using guessed type pthread_mutex_t stru_50514C;
// 99EE48: using guessed type _DWORD dword_99EE48[32];

//----- (00046ACC) --------------------------------------------------------
int __fastcall sub_46ACC(unsigned int a1)
{
  int v2; // r5
  int v3; // r4
  int v5; // [sp+8h] [bp-830h] BYREF
  __int16 v6; // [sp+Ch] [bp-82Ch]
  int v7[4]; // [sp+10h] [bp-828h] BYREF
  char s[2072]; // [sp+20h] [bp-818h] BYREF

  if ( a1 > 0xF )
  {
    snprintf(s, 0x800u, "%s: Bad pic param, input chain is %d\n", "send_pic_heart_beat", a1);
    v3 = -2147483135;
    sub_2E584(0, s, 0);
    return v3;
  }
  if ( !dword_99EE48[2 * a1 + 1] )
  {
    v3 = sub_46024(a1);
    if ( v3 < 0 )
    {
      snprintf(s, 0x800u, "%s: auto exec open_pic, but chain %d open eeprom failed\n", "send_pic_heart_beat", a1);
      sub_2E584(0, s, 0);
      return v3;
    }
  }
  v2 = dword_99EE48[2 * a1];
  v3 = 0;
  pthread_mutex_lock(&stru_50514C);
  v7[1] = 6656;
  v7[0] = 369404501;
  v7[2] = 0;
  v7[3] = 0;
  v5 = 0;
  v6 = 0;
  if ( sub_4966C(v2, (int)v7, 6) != 6 )
  {
    snprintf(s, 0x800u, "%s write iic err\n", "_bitmain_pic_heart_beat_common");
LABEL_13:
    sub_2E584(0, s, 0);
    goto LABEL_14;
  }
  usleep(0x493E0u);
  if ( sub_495E4(v2, &v5, 6) != 6 )
  {
    snprintf(s, 0x800u, "%s read iic err\n", "_bitmain_pic_heart_beat_common");
    goto LABEL_13;
  }
  if ( BYTE1(v5) == 22 && BYTE2(v5) == 1 )
    goto LABEL_8;
  snprintf(s, 0x800u, "%s failed!\n", "_bitmain_pic_heart_beat_common");
  sub_2E584(0, s, 0);
  sub_45ED0((unsigned __int8 *)&v5, 6u);
LABEL_14:
  v3 = -2147483136;
LABEL_8:
  pthread_mutex_unlock(&stru_50514C);
  return v3;
}
// 50514C: using guessed type pthread_mutex_t stru_50514C;
// 99EE48: using guessed type _DWORD dword_99EE48[32];

//----- (00046CA0) --------------------------------------------------------
int __fastcall sub_46CA0(int a1, __int16 a2, __int16 a3, int a4, int a5)
{
  int v5; // lr
  __int16 v10; // r12
  int v11; // r4
  int v12; // r0
  __int16 v13; // r12
  __int16 v14; // r3
  int v16; // r6
  int v17; // lr
  int v18; // r2
  int v19; // r1
  const char *v20; // r2
  __int16 v21; // [sp+Ch] [bp-834h] BYREF
  __int16 v22; // [sp+10h] [bp-830h] BYREF
  char v23; // [sp+12h] [bp-82Eh]
  char v24; // [sp+13h] [bp-82Dh]
  char v25; // [sp+14h] [bp-82Ch]
  char v26; // [sp+15h] [bp-82Bh]
  int v27; // [sp+16h] [bp-82Ah]
  int v28; // [sp+1Ah] [bp-826h]
  int v29; // [sp+1Eh] [bp-822h]
  int v30; // [sp+22h] [bp-81Eh]
  __int16 v31; // [sp+26h] [bp-81Ah]
  char s[2040]; // [sp+28h] [bp-818h] BYREF

  pthread_mutex_lock(&stru_50514C);
  v10 = a3 + 59 + a2;
  v25 = a2;
  if ( a5 >= 16 )
    v11 = 16;
  else
    v11 = a5;
  v12 = 0;
  v13 = v10 + (unsigned __int8)(a5 + 6);
  v23 = a5 + 6;
  v26 = a3;
  v22 = -21931;
  if ( a5 > 0 )
    v5 = 6;
  v28 = 0;
  v29 = 0;
  v30 = 0;
  v31 = 0;
  v27 = 0;
  v21 = 0;
  v24 = 59;
  if ( a5 > 0 )
  {
    while ( 1 )
    {
      v14 = *(unsigned __int8 *)(a4 + v12);
      v12 = (unsigned __int16)(v12 + 1);
      *((_BYTE *)&v22 + v5) = v14;
      v13 += v14;
      v19 = (unsigned __int16)(v5 + 1);
      if ( v12 >= v11 )
        break;
      v5 = (unsigned __int16)(v5 + 1);
    }
    v18 = (unsigned __int16)(v5 + 3);
    v17 = (unsigned __int16)(v5 + 2);
    v16 = v18;
  }
  else
  {
    v16 = 8;
    v17 = 7;
    v18 = 8;
    v19 = 6;
  }
  *((_BYTE *)&v22 + v19) = HIBYTE(v13);
  *((_BYTE *)&v22 + v17) = v13;
  if ( sub_4966C(a1, (int)&v22, v18) != v16 )
  {
    v20 = "%s write iic err\n";
LABEL_18:
    v11 = -2147483136;
    snprintf(s, 0x800u, v20, "_pic_write_iic");
    sub_2E584(0, s, 0);
    goto LABEL_15;
  }
  usleep(0x2710u);
  if ( sub_495E4(a1, &v21, 2) != 2 )
  {
    v20 = "%s read iic err\n";
    goto LABEL_18;
  }
  if ( (unsigned __int8)v21 != 59 || HIBYTE(v21) != 1 )
  {
    snprintf(
      s,
      0x800u,
      "%s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "_pic_write_iic",
      (unsigned __int8)v21,
      HIBYTE(v21));
    v11 = -2147483136;
    sub_2E584(0, s, 0);
  }
LABEL_15:
  pthread_mutex_unlock(&stru_50514C);
  return v11;
}
// 46D58: variable 'v5' is possibly undefined
// 50514C: using guessed type pthread_mutex_t stru_50514C;

//----- (00046EB4) --------------------------------------------------------
int __fastcall sub_46EB4(int a1)
{
  int v2; // r5
  __int16 v4; // [sp+Ch] [bp-824h] BYREF
  int v5[4]; // [sp+10h] [bp-820h] BYREF
  char s[2064]; // [sp+20h] [bp-810h] BYREF

  pthread_mutex_lock(&stru_50514C);
  v5[1] = 218103814;
  v5[3] = 0;
  v5[2] = 0;
  v5[0] = 17214037;
  v4 = 0;
  if ( sub_4966C(a1, (int)v5, 8) != 8 )
  {
    snprintf(s, 0x800u, "%s write iic err\n", "_bitmain_pic_seek_1704");
LABEL_10:
    v2 = -2147483136;
    sub_2E584(0, s, 0);
    goto LABEL_8;
  }
  usleep(0x493E0u);
  if ( sub_495E4(a1, &v4, 2) != 2 )
  {
    snprintf(s, 0x800u, "%s read iic err\n", "_bitmain_pic_seek_1704");
    goto LABEL_10;
  }
  if ( (unsigned __int8)v4 == 1 && HIBYTE(v4) == 1 )
  {
    v2 = 0;
  }
  else
  {
    v2 = -2147483136;
    snprintf(
      s,
      0x800u,
      "%s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "_bitmain_pic_seek_1704",
      (unsigned __int8)v4,
      HIBYTE(v4));
    sub_2E584(0, s, 0);
  }
LABEL_8:
  pthread_mutex_unlock(&stru_50514C);
  return v2;
}
// 50514C: using guessed type pthread_mutex_t stru_50514C;

//----- (00046FE8) --------------------------------------------------------
int __fastcall sub_46FE8(unsigned __int8 *a1, int a2)
{
  int v2; // r5
  unsigned __int8 *v3; // r6
  int result; // r0
  unsigned int i; // r4
  int v6; // r3
  unsigned int v7; // r4
  int v8; // r3
  char s[4]; // [sp+8h] [bp-820h] BYREF

  v2 = a2;
  v3 = a1;
  snprintf(s, 0x800u, "Dumping %u %s bytes from %p:\n", a2, "read return data", a1);
  result = sub_2E584(2, s, 0);
  if ( v2 > 0 )
  {
    while ( 1 )
    {
      for ( i = 0; i != 16; ++i )
      {
        while ( v2 > i )
        {
          v6 = v3[i++];
          snprintf(s, 0x800u, "%02x ", v6);
          sub_2E584(2, s, 0);
          if ( i == 16 )
            goto LABEL_6;
        }
        *(_DWORD *)s = &unk_202020;
        sub_2E584(2, s, 0);
      }
LABEL_6:
      v7 = 0;
      do
      {
        while ( v2 <= v7 )
        {
          ++v7;
          strcpy(s, " ");
          sub_2E584(2, s, 0);
          if ( v7 == 16 )
            goto LABEL_12;
        }
        v8 = v3[v7++];
        if ( (unsigned int)(v8 - 32) > 0x5E )
          v8 = 46;
        snprintf(s, 0x800u, "%c", v8);
        sub_2E584(2, s, 0);
      }
      while ( v7 != 16 );
LABEL_12:
      strcpy(s, "\n");
      v3 += 16;
      result = sub_2E584(2, s, 0);
      if ( v2 <= 16 )
        break;
      v2 -= 16;
    }
  }
  return result;
}

//----- (00047158) --------------------------------------------------------
int __fastcall sub_47158(unsigned int a1, _DWORD *a2, int a3)
{
  int v6; // r5
  int v7; // r5
  unsigned int v8; // r3
  unsigned __int16 v9; // r2
  int v11; // r5
  __int16 v12; // r1
  int *v13; // r2
  unsigned int v14; // r3
  __int16 v15; // t1
  unsigned __int16 v16; // r2
  unsigned __int16 v17; // r3
  int v18; // [sp+14h] [bp-834h] BYREF
  char v19; // [sp+18h] [bp-830h]
  char v20; // [sp+19h] [bp-82Fh]
  int v21[3]; // [sp+1Ch] [bp-82Ch] BYREF
  char s[2080]; // [sp+28h] [bp-820h] BYREF

  if ( a1 > 0xF )
  {
    snprintf(s, 0x800u, "%s: Bad pic param, input chain is %d\n", "pic_get_voltage", a1);
    v7 = -2147483135;
    sub_2E584(0, s, 0);
    return v7;
  }
  if ( !dword_99EE48[2 * a1 + 1] )
  {
    v7 = sub_46024(a1);
    if ( v7 < 0 )
    {
      snprintf(s, 0x800u, "%s: auto exec open_pic, but chain %d open eeprom failed\n", "pic_get_voltage", a1);
      sub_2E584(0, s, 0);
      return v7;
    }
  }
  if ( a3 == 3 )
  {
    pthread_mutex_lock(&stru_50514C);
    v11 = dword_99EE48[2 * a1];
    v19 = 0;
    v18 = 923052629;
    memset(v21, 0, 11);
    v20 = 59;
    if ( sub_4966C(v11, (int)&v18, 6) != 6 )
    {
      snprintf(s, 0x800u, "%s write iic err\n", "_read_an_voltage");
      goto LABEL_33;
    }
    usleep(0x493E0u);
    v7 = sub_495E4(v11, v21, 11);
    if ( v7 != 11 )
    {
      snprintf(s, 0x800u, "%s read iic err\n", "_read_an_voltage");
      goto LABEL_33;
    }
    v12 = LOBYTE(v21[0]);
    if ( LOBYTE(v21[0]) != 11 || BYTE1(v21[0]) != 55 )
    {
      snprintf(
        s,
        0x800u,
        "%s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
        "_read_an_voltage",
        LOBYTE(v21[0]),
        BYTE1(v21[0]));
      v7 = -1;
      sub_2E584(0, s, 0);
      goto LABEL_16;
    }
    v13 = v21;
    LOWORD(v14) = 0;
    while ( 1 )
    {
      v14 = (unsigned __int16)(v14 + v12);
      if ( v13 == &v21[2] )
        break;
      v15 = *((unsigned __int8 *)v13 + 1);
      v13 = (int *)((char *)v13 + 1);
      v12 = v15;
    }
    if ( BYTE1(v21[2]) != v14 >> 8 || BYTE2(v21[2]) != (unsigned __int8)v14 )
    {
      snprintf(s, 0x800u, "%s failed 2!\n", "_read_an_voltage");
      goto LABEL_33;
    }
    v16 = __rev16(*(unsigned __int16 *)((char *)&v21[1] + 1));
    v17 = __rev16(*(unsigned __int16 *)((char *)&v21[1] + 3));
    *a2 = (unsigned __int16)__rev16(*(unsigned __int16 *)((char *)v21 + 3));
    a2[1] = v16;
    a2[2] = v17;
  }
  else
  {
    if ( a3 != 1 )
    {
      v7 = -2147483135;
      snprintf(s, 0x800u, "%s failed: parameters error!\n", "pic_get_voltage");
      sub_2E584(0, s, 0);
      return v7;
    }
    pthread_mutex_lock(&stru_50514C);
    v6 = dword_99EE48[2 * a1];
    v19 = 0;
    v21[0] = 0;
    v18 = 973384277;
    *(int *)((char *)v21 + 3) = 0;
    v20 = 62;
    if ( sub_4966C(v6, (int)&v18, 6) != 6 )
    {
      snprintf(s, 0x800u, "%s write iic err\n", "_read_an6_voltage");
LABEL_33:
      v7 = -1;
      sub_2E584(0, s, 0);
      goto LABEL_16;
    }
    usleep(0x493E0u);
    v7 = sub_495E4(v6, v21, 7);
    if ( v7 != 7 )
    {
      snprintf(s, 0x800u, "%s read iic err\n", "_read_an6_voltage");
      goto LABEL_33;
    }
    if ( LOBYTE(v21[0]) != 7 || BYTE1(v21[0]) != 58 || BYTE2(v21[0]) != 1 )
    {
      snprintf(
        s,
        0x800u,
        "%s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x, read_back_data[2] = 0x%02x\n\n",
        "_read_an6_voltage",
        LOBYTE(v21[0]),
        BYTE1(v21[0]),
        BYTE2(v21[0]));
      v7 = -1;
      sub_2E584(0, s, 0);
      goto LABEL_16;
    }
    v8 = HIBYTE(v21[0]) + LOBYTE(v21[1]) + 66;
    v9 = __rev16(*(unsigned __int16 *)((char *)v21 + 3));
    if ( BYTE1(v21[1]) != v8 >> 8 || BYTE2(v21[1]) != (unsigned __int8)v8 )
    {
      snprintf(s, 0x800u, "%s failed 2!\n", "_read_an6_voltage");
      goto LABEL_33;
    }
    *a2 = v9;
  }
LABEL_16:
  pthread_mutex_unlock(&stru_50514C);
  return v7;
}
// 50514C: using guessed type pthread_mutex_t stru_50514C;
// 99EE48: using guessed type _DWORD dword_99EE48[32];

//----- (0004752C) --------------------------------------------------------
int __fastcall sub_4752C(unsigned int a1, __int16 a2, __int16 a3, int a4, int a5)
{
  int v9; // r10
  int v10; // r4
  int v11; // r7
  __int16 v12; // r5
  unsigned __int8 *v13; // r6
  char *v14; // r2
  unsigned int v15; // r3
  unsigned int v16; // t1
  __int16 v18; // [sp+Ch] [bp-84Ch] BYREF
  __int16 v19; // [sp+10h] [bp-848h] BYREF
  char v20; // [sp+12h] [bp-846h]
  char v21; // [sp+13h] [bp-845h]
  char v22; // [sp+14h] [bp-844h]
  char v23; // [sp+15h] [bp-843h]
  int v24; // [sp+16h] [bp-842h]
  int v25; // [sp+1Ah] [bp-83Eh]
  int v26; // [sp+1Eh] [bp-83Ah]
  int v27; // [sp+22h] [bp-836h]
  int v28; // [sp+26h] [bp-832h]
  int v29; // [sp+2Ah] [bp-82Eh]
  __int16 v30; // [sp+2Eh] [bp-82Ah]
  char s[2048]; // [sp+30h] [bp-828h] BYREF

  if ( a1 > 0xF )
  {
    snprintf(s, 0x800u, "%s: Bad pic param, input chain is %d\n", "app_write_data_into_flash", a1);
    v11 = -2147483135;
    sub_2E584(0, s, 0);
    return v11;
  }
  if ( !dword_99EE48[2 * a1 + 1] )
  {
    v11 = sub_46024(a1);
    if ( v11 < 0 )
    {
      snprintf(s, 0x800u, "%s: auto exec open_pic, but chain %d open eeprom failed\n", "app_write_data_into_flash", a1);
      sub_2E584(0, s, 0);
      return v11;
    }
  }
  v9 = dword_99EE48[2 * a1];
  v10 = 0;
  pthread_mutex_lock(&stru_50514C);
  if ( a5 >= 16 )
    v11 = 16;
  else
    v11 = a5;
  v23 = a3;
  v20 = a5 + 6;
  v22 = a2;
  v12 = (unsigned __int8)(a5 + 6) + a3 + 53 + a2;
  v19 = -21931;
  v18 = 0;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  v28 = 0;
  v29 = 0;
  v30 = 0;
  v21 = 53;
  if ( a5 > 0 )
  {
    v13 = (unsigned __int8 *)(a4 - 1);
    do
    {
      v16 = *++v13;
      v15 = v16;
      if ( (v10 & 1) == 0 && v15 > 0x3F )
      {
        snprintf(s, 0x800u, "%s: the data[%d] must less than 0x3f\n", "_app_write_data_into_flash_1704_v8", v10);
        sub_2E584(v10 & 1, s, v10 & 1);
        LOWORD(v15) = *v13;
      }
      v14 = (char *)&v19 + v10++;
      v14[6] = v15;
      v12 += v15;
    }
    while ( v11 > v10 );
  }
  *((_BYTE *)&v19 + (unsigned __int16)(v11 + 6)) = HIBYTE(v12);
  *((_BYTE *)&v19 + (unsigned __int16)(v11 + 7)) = v12;
  if ( sub_4966C(v9, (int)&v19, (unsigned __int16)(v11 + 8)) == (unsigned __int16)(v11 + 8) )
  {
    usleep(0x493E0u);
    if ( sub_495E4(v9, &v18, 2) == 2 )
    {
      if ( (unsigned __int8)v18 != 53 || HIBYTE(v18) != 1 )
      {
        v11 = 0;
        snprintf(
          s,
          0x800u,
          "%s failed 2! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
          "_app_write_data_into_flash_1704_v8",
          (unsigned __int8)v18,
          HIBYTE(v18));
        sub_2E584(0, s, 0);
      }
      goto LABEL_15;
    }
    snprintf(s, 0x800u, "%s read iic 2 err\n", "_app_write_data_into_flash_1704_v8");
  }
  else
  {
    snprintf(s, 0x800u, "%s write iic 2 err\n", "_app_write_data_into_flash_1704_v8");
  }
  v11 = 0;
  sub_2E584(0, s, 0);
LABEL_15:
  pthread_mutex_unlock(&stru_50514C);
  return v11;
}
// 50514C: using guessed type pthread_mutex_t stru_50514C;
// 99EE48: using guessed type _DWORD dword_99EE48[32];

//----- (000477EC) --------------------------------------------------------
int __fastcall sub_477EC(unsigned int a1, __int16 a2, __int16 a3, void *a4, int a5)
{
  int v9; // r7
  int v10; // r8
  unsigned __int8 *v11; // r0
  int v12; // r2
  int v13; // r4
  unsigned __int8 *v14; // r6
  const char *v15; // r2
  int v17; // r3
  int v18; // r8
  __int16 v19; // r0
  unsigned int v20; // r3
  unsigned int v21; // r2
  int v22; // r3
  unsigned __int8 *v23; // r7
  int v24; // [sp+14h] [bp-834h] BYREF
  char v25; // [sp+18h] [bp-830h]
  char v26; // [sp+19h] [bp-82Fh]
  char v27; // [sp+1Ah] [bp-82Eh]
  char v28; // [sp+1Bh] [bp-82Dh]
  char v29; // [sp+1Ch] [bp-82Ch]
  char s[2088]; // [sp+20h] [bp-828h] BYREF

  if ( a1 > 0xF )
  {
    snprintf(s, 0x800u, "%s: Bad pic param, input chain is %d\n", "app_read_data_from_flash", a1);
    v13 = -2147483135;
    sub_2E584(0, s, 0);
    return v13;
  }
  if ( !dword_99EE48[2 * a1 + 1] )
  {
    v13 = sub_46024(a1);
    if ( v13 < 0 )
    {
      snprintf(s, 0x800u, "%s: auto exec open_pic, but chain %d open eeprom failed\n", "app_read_data_from_flash", a1);
      sub_2E584(0, s, 0);
      return v13;
    }
  }
  v9 = a5 + 5;
  v10 = dword_99EE48[2 * a1];
  pthread_mutex_lock(&stru_50514C);
  v11 = (unsigned __int8 *)malloc(a5 + 5);
  LOWORD(v12) = -21931;
  if ( a5 >= 16 )
    v13 = 16;
  else
    v13 = a5;
  HIWORD(v12) = 13831;
  v24 = v12;
  v14 = v11;
  v25 = a2;
  v26 = a3;
  v27 = v13;
  v29 = v13 + 61 + a3 + a2;
  v28 = (unsigned __int16)(v13 + 61 + a3 + a2) >> 8;
  if ( sub_4966C(v10, (int)&v24, 9) == 9 )
  {
    usleep(0x493E0u);
    if ( v9 == sub_495E4(v10, v14, a5 + 5) )
    {
      v17 = v14[1];
      v18 = *v14;
      v19 = *v14;
      if ( v17 == 54 && v14[2] == 1 && v9 == v18 )
      {
        if ( a5 + 3 > 0 )
        {
          LOWORD(v21) = 0;
          LOWORD(v22) = 0;
          while ( 1 )
          {
            v22 = (unsigned __int16)(v22 + 1);
            v21 = (unsigned __int16)(v21 + v19);
            if ( v22 >= a5 + 3 )
              break;
            v19 = v14[v22];
          }
          v20 = v21 >> 8;
        }
        else
        {
          v20 = 0;
          LOBYTE(v21) = 0;
        }
        v23 = &v14[v9];
        if ( *(v23 - 2) == v20 && *(v23 - 1) == (unsigned __int8)v21 )
        {
          memcpy(a4, v14 + 3, v13);
        }
        else
        {
          v13 = 0;
          snprintf(s, 0x800u, "%s failed 2!\n", "_app_read_data_from_flash_1704_v8");
          sub_2E584(0, s, 0);
          sub_46FE8(v14, v18);
        }
      }
      else
      {
        snprintf(
          s,
          0x800u,
          "%s failed !\n read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x\n",
          "_app_read_data_from_flash_1704_v8",
          v18,
          v17,
          v14[2]);
        v13 = 0;
        sub_2E584(0, s, 0);
        sub_46FE8(v14, a5 + 5);
      }
      goto LABEL_9;
    }
    v15 = "%s read iic 2 err\n";
  }
  else
  {
    v15 = "%s write iic 2 err\n";
  }
  v13 = 0;
  snprintf(s, 0x800u, v15, "_app_read_data_from_flash_1704_v8");
  sub_2E584(0, s, 0);
LABEL_9:
  free(v14);
  pthread_mutex_unlock(&stru_50514C);
  return v13;
}
// 50514C: using guessed type pthread_mutex_t stru_50514C;
// 99EE48: using guessed type _DWORD dword_99EE48[32];

//----- (00047AC4) --------------------------------------------------------
int __fastcall sub_47AC4(unsigned int a1, const char *a2)
{
  int v4; // r4
  int v5; // r5
  FILE *v6; // r0
  FILE *v7; // r6
  _OWORD *v8; // r4
  __int16 v9; // r0
  int v10; // r4
  int *v11; // r3
  int v12; // r0
  int v13; // r1
  int v14; // r2
  int v15; // r3
  int *v16; // r0
  int *v17; // r2
  __int16 v18; // r3
  __int16 v19; // t1
  __int16 v21; // [sp+Ch] [bp-1BE4h] BYREF
  char v22[4]; // [sp+10h] [bp-1BE0h] BYREF
  char v23; // [sp+14h] [bp-1BDCh]
  char v24; // [sp+17h] [bp-1BD9h] BYREF
  int v25; // [sp+18h] [bp-1BD8h]
  int v26; // [sp+1Ch] [bp-1BD4h]
  int v27; // [sp+20h] [bp-1BD0h]
  int v28; // [sp+24h] [bp-1BCCh] BYREF
  int v29; // [sp+28h] [bp-1BC8h] BYREF
  int v30[4]; // [sp+2Ch] [bp-1BC4h] BYREF
  char v31; // [sp+3Ch] [bp-1BB4h]
  char v32; // [sp+3Dh] [bp-1BB3h]
  int v33; // [sp+3Eh] [bp-1BB2h]
  int v34; // [sp+42h] [bp-1BAEh]
  __int16 v35; // [sp+46h] [bp-1BAAh]
  char s[8]; // [sp+48h] [bp-1BA8h] BYREF
  _OWORD v37[314]; // [sp+848h] [bp-13A8h] BYREF

  if ( a1 > 0xF )
  {
    v10 = -2147483135;
    snprintf((char *)v37, 0x800u, "%s: Bad pic param, input chain is %d\n", "upgrade_pic", a1);
    sub_2E584(0, (const char *)v37, 0);
    return v10;
  }
  if ( !dword_99EE48[2 * a1 + 1] )
  {
    v4 = sub_46024(a1);
    if ( v4 < 0 )
    {
      snprintf((char *)v37, 0x800u, "%s: auto exec open_pic, but chain %d open eeprom failed\n", "upgrade_pic", a1);
      sub_2E584(0, (const char *)v37, 0);
      return v4;
    }
  }
  memset(v37, 0, 0x1388u);
  v26 = 0;
  v27 = 0;
  v28 = 0;
  v5 = dword_99EE48[2 * a1];
  v25 = 0;
  *(_DWORD *)v22 = 0;
  v23 = 0;
  snprintf(s, 0x800u, "%s\n", "_update_pic_app_program_1704");
  sub_2E584(2, s, 0);
  v6 = (FILE *)fopen64(a2, "r");
  v7 = v6;
  if ( !v6 )
  {
    snprintf(s, 0x800u, "%s: open %s failed\n", "_update_pic_app_program_1704", a2);
    v10 = -2147483136;
    sub_2E584(0, s, 0);
    return v10;
  }
  fseek(v6, 0, 0);
  v8 = v37;
  memset(v37, 0, 0x1388u);
  snprintf(s, 0x800u, "%s: pic_flash_length = %d\n", "_update_pic_app_program_1704", 2432);
  sub_2E584(2, s, 0);
  do
  {
    v8 = (_OWORD *)((char *)v8 + 2);
    fgets(v22, 1023, v7);
    v9 = strtoul(v22, 0, 16);
    *((_BYTE *)v8 - 1) = v9;
    *((_BYTE *)v8 - 2) = HIBYTE(v9);
  }
  while ( &v37[304] != v8 );
  fclose(v7);
  v10 = sub_4637C(a1);
  if ( v10 )
  {
LABEL_30:
    snprintf(s, 0x800u, "%s: reset pic error!\n\n", "_update_pic_app_program_1704");
LABEL_32:
    sub_2E584(0, s, 0);
    return v10;
  }
  v10 = sub_46EB4(v5);
  if ( v10 )
  {
    snprintf(s, 0x800u, "%s set 1704 flash pointer err\n", "_erase_pic_app");
    sub_2E584(0, s, 0);
    snprintf(s, 0x800u, "%s: erase app flash error!\n\n", "_update_pic_app_program_1704");
    goto LABEL_32;
  }
  pthread_mutex_lock(&stru_50514C);
  v29 = 67414613;
  LOWORD(v30[0]) = 2048;
  v21 = 0;
  if ( sub_4966C(v5, (int)&v29, 6) != 6 )
  {
    snprintf(s, 0x800u, "%s write iic err\n", "_bitmain_pic_erase_1704");
    goto LABEL_41;
  }
  usleep(0x493E0u);
  if ( sub_495E4(v5, &v21, 2) != 2 )
  {
    snprintf(s, 0x800u, "%s read iic err\n", "_bitmain_pic_erase_1704");
    goto LABEL_41;
  }
  usleep(0x493E0u);
  if ( (unsigned __int8)v21 != 4 || HIBYTE(v21) != 1 )
  {
    snprintf(
      s,
      0x800u,
      "%s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "_bitmain_pic_erase_1704",
      (unsigned __int8)v21,
      HIBYTE(v21));
LABEL_41:
    sub_2E584(0, s, 0);
  }
  pthread_mutex_unlock(&stru_50514C);
  v10 = sub_46EB4(v5);
  if ( v10 )
  {
    snprintf(s, 0x800u, aSSet1704FlashP_0, "_update_pic_app_program_1704");
    goto LABEL_32;
  }
  do
  {
    v11 = (int *)&v37[v10];
    v12 = *v11;
    v13 = v11[1];
    v14 = v11[2];
    v15 = v11[3];
    v25 = v12;
    v26 = v13;
    v27 = v14;
    v28 = v15;
    snprintf(s, 0x800u, "send pic program time: %d", v10);
    sub_2E584(2, s, 0);
    pthread_mutex_lock(&stru_50514C);
    v16 = v30;
    v17 = (int *)&v24;
    v18 = 22;
    v33 = 0;
    v21 = 0;
    v34 = 0;
    v35 = 0;
    memset(v30, 0, sizeof(v30));
    v29 = 34908757;
    do
    {
      v19 = *((unsigned __int8 *)v17 + 1);
      v17 = (int *)((char *)v17 + 1);
      v18 += v19;
      *(_BYTE *)v16 = v19;
      v16 = (int *)((char *)v16 + 1);
    }
    while ( (int *)((char *)&v28 + 3) != v17 );
    v31 = HIBYTE(v18);
    v32 = v18;
    if ( sub_4966C(v5, (int)&v29, 22) == 22 )
    {
      usleep(0x493E0u);
      if ( sub_495E4(v5, &v21, 2) == 2 )
      {
        if ( (unsigned __int8)v21 == 2 && HIBYTE(v21) == 1 )
        {
          v29 = 84191829;
          LOWORD(v30[0]) = 2304;
          if ( sub_4966C(v5, (int)&v29, 6) == 6 )
          {
            usleep(0x493E0u);
            if ( sub_495E4(v5, &v21, 2) == 2 )
            {
              if ( (unsigned __int8)v21 == 5 && HIBYTE(v21) == 1 )
              {
                snprintf(s, 0x800u, "%s  success write to pic flash\n", "_bitmain_pic_write_1704");
                sub_2E584(2, s, 0);
                goto LABEL_28;
              }
              snprintf(
                s,
                0x800u,
                "%s failed 2! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
                "_bitmain_pic_write_1704",
                (unsigned __int8)v21,
                HIBYTE(v21));
            }
            else
            {
              snprintf(s, 0x800u, "%s read iic 2 err\n", "_bitmain_pic_write_1704");
            }
          }
          else
          {
            snprintf(s, 0x800u, "%s write iic 2 err\n", "_bitmain_pic_write_1704");
          }
        }
        else
        {
          snprintf(
            s,
            0x800u,
            "%s failed 1! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
            "_bitmain_pic_write_1704",
            (unsigned __int8)v21,
            HIBYTE(v21));
        }
      }
      else
      {
        snprintf(s, 0x800u, "%s read iic 1 err\n", "_bitmain_pic_write_1704");
      }
    }
    else
    {
      snprintf(s, 0x800u, "%s write iic 1 err\n", "_bitmain_pic_write_1704");
    }
    sub_2E584(0, s, 0);
LABEL_28:
    ++v10;
    pthread_mutex_unlock(&stru_50514C);
  }
  while ( v10 != 304 );
  v10 = sub_4637C(a1);
  if ( v10 )
    goto LABEL_30;
  return v10;
}
// 124E4: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 50514C: using guessed type pthread_mutex_t stru_50514C;
// 99EE48: using guessed type _DWORD dword_99EE48[32];

//----- (00048110) --------------------------------------------------------
int __fastcall sub_48110(unsigned int a1, int a2, int a3, void *a4, int a5)
{
  int v9; // r4
  int v10; // r6
  int v11; // r5
  int v12; // r6
  const char *v13; // r2
  __int16 v15; // r3
  int v16; // r1
  unsigned int v17; // r2
  int v18; // [sp+10h] [bp-848h] BYREF
  char v19; // [sp+14h] [bp-844h]
  char v20; // [sp+15h] [bp-843h]
  char v21; // [sp+16h] [bp-842h]
  char v22; // [sp+17h] [bp-841h]
  int src; // [sp+18h] [bp-840h] BYREF
  int v24[4]; // [sp+1Ch] [bp-83Ch] BYREF
  __int16 v25; // [sp+2Ch] [bp-82Ch]
  char s[2048]; // [sp+30h] [bp-828h] BYREF

  if ( a1 > 0xF )
  {
    snprintf(s, 0x800u, "%s: Bad pic param, input chain is %d\n", "pic_read_iic", a1);
    v12 = -2147483135;
    sub_2E584(0, s, 0);
    return v12;
  }
  if ( !dword_99EE48[2 * a1 + 1] )
  {
    v12 = sub_46024(a1);
    if ( v12 < 0 )
    {
      snprintf(s, 0x800u, "%s: auto exec open_pic, but chain %d open eeprom failed\n", "pic_read_iic", a1);
      sub_2E584(0, s, 0);
      return v12;
    }
  }
  v9 = 0;
  v10 = sub_46CA0(dword_99EE48[2 * a1], a2, a3, 0, 0);
  if ( v10 >= 0 )
  {
    usleep(0x2710u);
    v11 = dword_99EE48[2 * a1];
    pthread_mutex_lock(&stru_50514C);
    if ( a5 >= 16 )
      v12 = 16;
    else
      v12 = a5;
    v20 = v12;
    v22 = v12 + 66 + a2;
    src = 0;
    v19 = a2;
    memset(v24, 0, sizeof(v24));
    v21 = (unsigned __int16)(v12 + 66 + a2) >> 8;
    v25 = 0;
    v18 = 1007069781;
    if ( sub_4966C(v11, (int)&v18, 8) == 8 )
    {
      usleep(0x2710u);
      if ( v12 + 5 == sub_495E4(v11, &src, v12 + 5) )
      {
        v15 = (unsigned __int8)src;
        if ( v12 + 5 == (unsigned __int8)src && BYTE1(src) == 60 && BYTE2(src) == 1 )
        {
          v16 = v12 + 3;
          LOWORD(v17) = 0;
          if ( v12 + 3 > 0 )
          {
            while ( 1 )
            {
              v9 = (unsigned __int16)(v9 + 1);
              v17 = (unsigned __int16)(v17 + v15);
              if ( v9 >= v16 )
                break;
              v15 = *((unsigned __int8 *)&v24[-1] + v9);
            }
            v9 = v17 >> 8;
          }
          if ( *((unsigned __int8 *)&v24[-1] + v16) == v9 && *((unsigned __int8 *)v24 + v12) == (unsigned __int8)v17 )
          {
            memcpy(a4, (char *)&src + 3, v12);
          }
          else
          {
            snprintf(s, 0x800u, "%s failed 2!\n", "_pic_read_iic");
            v12 = 0;
            sub_2E584(0, s, 0);
          }
        }
        else
        {
          v12 = 0;
          snprintf(
            s,
            0x800u,
            "%s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x, read_back_data[2] = 0x%02x\n\n",
            "_pic_read_iic",
            (unsigned __int8)src,
            BYTE1(src),
            BYTE2(src));
          sub_2E584(0, s, 0);
        }
        goto LABEL_10;
      }
      v13 = "%s read iic err\n";
    }
    else
    {
      v13 = "%s write iic err\n";
    }
    v12 = 0;
    snprintf(s, 0x800u, v13, "_pic_read_iic");
    sub_2E584(0, s, 0);
LABEL_10:
    pthread_mutex_unlock(&stru_50514C);
    return v12;
  }
  snprintf(s, 0x800u, "%s: select slave: 0x%02x, reg/command: 0x%02x is failed", "pic_read_iic", a2, a3);
  sub_2E584(0, s, 0);
  return v10;
}
// 50514C: using guessed type pthread_mutex_t stru_50514C;
// 99EE48: using guessed type _DWORD dword_99EE48[32];

//----- (00048438) --------------------------------------------------------
int __fastcall sub_48438(unsigned int a1, __int16 a2, __int16 a3, int a4, int a5)
{
  int v9; // r6
  char s[2080]; // [sp+8h] [bp-820h] BYREF

  if ( a1 > 0xF )
  {
    snprintf(s, 0x800u, "%s: Bad pic param, input chain is %d\n", "pic_write_iic", a1);
    v9 = -2147483135;
    sub_2E584(0, s, 0);
  }
  else
  {
    if ( dword_99EE48[2 * a1 + 1] )
      return sub_46CA0(dword_99EE48[2 * a1], a2, a3, a4, a5);
    v9 = sub_46024(a1);
    if ( v9 >= 0 )
    {
      return sub_46CA0(dword_99EE48[2 * a1], a2, a3, a4, a5);
    }
    else
    {
      snprintf(s, 0x800u, "%s: auto exec open_pic, but chain %d open eeprom failed\n", "pic_write_iic", a1);
      sub_2E584(0, s, 0);
    }
  }
  return v9;
}
// 99EE48: using guessed type _DWORD dword_99EE48[32];

//----- (00048520) --------------------------------------------------------
int __fastcall sub_48520(int a1, unsigned __int8 *a2, unsigned int a3, unsigned __int8 *a4, unsigned int a5)
{
  unsigned int v7; // r4
  unsigned int v8; // r3
  unsigned int v9; // r4
  unsigned int v10; // r3
  unsigned __int8 *v11; // r1
  int v12; // r3
  __int16 v13; // t1
  unsigned __int8 *v14; // r4
  int v15; // r5
  int v16; // t1
  int v17; // r3
  int v18; // r4
  int v20; // [sp+0h] [bp-830h]
  int v22; // [sp+10h] [bp-820h]
  unsigned __int8 *v24; // [sp+20h] [bp-810h]
  unsigned __int8 *v25; // [sp+24h] [bp-80Ch]
  unsigned __int8 *v26; // [sp+2Ch] [bp-804h]
  unsigned __int8 v27; // [sp+37h] [bp-7F9h] BYREF
  char s[2052]; // [sp+38h] [bp-7F8h] BYREF

  v26 = a4 + 1;
  v27 = 17;
  pthread_mutex_lock(&stru_505164);
  v25 = &a4[a5 - 2];
  v24 = &a4[a5 - 1];
  v22 = 0;
  while ( 1 )
  {
    LOBYTE(v7) = 0;
    v8 = 0;
    do
    {
      v7 = (unsigned __int8)(v7 + 1);
      sub_49794(a1, &v27, 1, (int)&a2[v8], 1);
      v8 = v7;
    }
    while ( v7 < a3 );
    LOBYTE(v9) = 0;
    usleep((__useconds_t)"version array failed\n");
    v10 = 0;
    do
    {
      v9 = (unsigned __int8)(v9 + 1);
      sub_496F4(a1, &v27, 1, (int)&a4[v10], 1);
      v10 = v9;
    }
    while ( v9 < a5 );
    usleep(0x186A0u);
    v11 = v26;
    LOWORD(v12) = 0;
    do
    {
      v13 = *++v11;
      v12 = (unsigned __int16)(v12 + v13);
    }
    while ( &a4[a5 - 3] != v11 );
    if ( v12 != (unsigned __int16)(*v25 + (*v24 << 8)) )
    {
      snprintf(
        s,
        0x800u,
        "power reply the bad crc, crc = 0x%04x, crc_read = 0x%04x\n",
        v12,
        (unsigned __int16)(*v25 + (*v24 << 8)));
      sub_2E584(0, s, 0);
      goto LABEL_10;
    }
    if ( *a2 == *a4 && a2[1] == a4[1] && a2[3] == a4[3] && a5 == a4[2] + 2 )
      break;
    strcpy(s, "power reply the bad data\n");
    sub_2E584(0, s, 0);
LABEL_10:
    v14 = a4 - 1;
    v15 = 0;
    do
    {
      v16 = *++v14;
      v17 = v15++;
      snprintf(s, 0x800u, "read_back_data[%d] = 0x%02x", v17, v16);
      sub_2E584(0, s, 0);
    }
    while ( &a4[a5 - 1] != v14 );
    v20 = v22++;
    snprintf(s, 0x800u, "Send power cmd(0x%02x) failed, retry %d\n", a2[3], v20);
    sub_2E584(0, s, 0);
    if ( v22 == 3 )
    {
      v18 = -2147482880;
      goto LABEL_14;
    }
  }
  v18 = 0;
LABEL_14:
  pthread_mutex_unlock(&stru_505164);
  return v18;
}
// 505164: using guessed type pthread_mutex_t stru_505164;

//----- (000487E8) --------------------------------------------------------
int sub_487E8()
{
  char v1[2056]; // [sp+0h] [bp-808h] BYREF

  strcpy(v1, "set DA conversion N failed\n");
  sub_2E584(0, v1, 0);
  return -2147482880;
}

//----- (00048834) --------------------------------------------------------
int __fastcall sub_48834(int a1, __int16 a2)
{
  int v3; // [sp+8h] [bp-18h] BYREF
  __int16 v4; // [sp+Ch] [bp-14h]
  __int16 v5; // [sp+Eh] [bp-12h]
  int v6; // [sp+10h] [bp-10h] BYREF
  int v7; // [sp+14h] [bp-Ch]

  v3 = -2096715179;
  v5 = a2 + 137;
  v6 = 0;
  v4 = (unsigned __int8)a2;
  v7 = 0;
  if ( sub_48520(a1, (unsigned __int8 *)&v3, 8u, (unsigned __int8 *)&v6, 8u) )
    return sub_487E8();
  else
    return (unsigned __int16)v7;
}

//----- (000488A4) --------------------------------------------------------
int sub_488A4()
{
  pthread_mutex_lock(&stru_505164);
  sub_49574(dword_50517C);
  dword_505180 = 0;
  dword_505184 = 0;
  return pthread_mutex_unlock(&stru_505164);
}
// 505164: using guessed type pthread_mutex_t stru_505164;
// 50517C: using guessed type int dword_50517C;
// 505180: using guessed type int dword_505180;
// 505184: using guessed type int dword_505184;

//----- (000488D8) --------------------------------------------------------
int sub_488D8()
{
  if ( dword_50517C && dword_505180 )
    return 0;
  sub_488A4();
  return 0;
}
// 50517C: using guessed type int dword_50517C;
// 505180: using guessed type int dword_505180;

//----- (00048910) --------------------------------------------------------
int sub_48910()
{
  int v0; // r5
  int v1; // r4
  int v2; // r7
  int v3; // r4
  int v4; // r6
  int v6; // [sp+8h] [bp-830h] BYREF
  __int16 v7; // [sp+Ch] [bp-82Ch]
  int v8; // [sp+10h] [bp-828h] BYREF
  int v9; // [sp+14h] [bp-824h]
  char s[2080]; // [sp+18h] [bp-820h] BYREF

  v0 = dword_505180;
  if ( dword_505180 || (v1 = sub_48B58(), v1 >= 0) )
  {
    v2 = dword_50517C;
    v3 = 10;
    do
    {
      LOBYTE(v6) = -1;
      LOBYTE(v8) = 0;
      pthread_mutex_lock(&stru_505164);
      if ( sub_496F4(v2, (unsigned __int8 *)&v8, 1, (int)&v6, 1) == 1 )
      {
        v4 = (unsigned __int8)v6;
        pthread_mutex_unlock(&stru_505164);
        if ( v4 == 245 )
          break;
      }
      else
      {
        snprintf(s, 0x800u, "%s: iic read is failed\n", "_bitmain_get_power_code_version");
        sub_2E584(0, s, 0);
        pthread_mutex_unlock(&stru_505164);
      }
      usleep(0x186A0u);
      --v3;
    }
    while ( v3 );
    v6 = 33860181;
    v8 = 0;
    v9 = 0;
    v7 = 6;
    if ( sub_48520(v2, (unsigned __int8 *)&v6, 6u, (unsigned __int8 *)&v8, 8u) )
    {
      v1 = -2147482880;
      strcpy(s, "get power version failed\n");
      sub_2E584(0, s, 0);
    }
    else
    {
      v1 = (unsigned __int16)v9;
      if ( (_WORD)v9 )
        dword_505184 = (unsigned __int16)v9;
    }
  }
  else
  {
    snprintf(s, 0x800u, "%s: auto exec bitmain_power_open, but open power failed\n", "bitmain_power_version");
    sub_2E584(v0, s, v0);
  }
  return v1;
}
// 505164: using guessed type pthread_mutex_t stru_505164;
// 50517C: using guessed type int dword_50517C;
// 505180: using guessed type int dword_505180;
// 505184: using guessed type int dword_505184;

//----- (00048ABC) --------------------------------------------------------
int sub_48ABC()
{
  int v0; // r5
  int v1; // r0
  int v3[6]; // [sp+0h] [bp-18h] BYREF

  v3[1] = (int)&loc_20000;
  v3[0] = 0;
  pthread_mutex_lock(&stru_505164);
  v0 = sub_493D0((int)v3);
  pthread_mutex_unlock(&stru_505164);
  if ( v0 < 0 )
    return v0;
  dword_50517C = v0;
  dword_505180 = 1;
  v1 = sub_48910();
  v0 = v1;
  if ( v1 >= 0 )
  {
    dword_505184 = v1;
    return 0;
  }
  if ( dword_50517C && dword_505180 )
    return v0;
  sub_488A4();
  return v0;
}
// 505164: using guessed type pthread_mutex_t stru_505164;
// 50517C: using guessed type int dword_50517C;
// 505180: using guessed type int dword_505180;
// 505184: using guessed type int dword_505184;

//----- (00048B58) --------------------------------------------------------
int sub_48B58()
{
  int result; // r0

  result = dword_50517C;
  if ( !dword_50517C || !dword_505180 )
    return sub_48ABC();
  return result;
}
// 48ABC: using guessed type int sub_48ABC(void);
// 50517C: using guessed type int dword_50517C;
// 505180: using guessed type int dword_505180;

//----- (00048B7C) --------------------------------------------------------
int sub_48B7C()
{
  int v0; // r5
  int v1; // r6
  int v3; // [sp+8h] [bp-820h] BYREF
  __int16 v4; // [sp+Ch] [bp-81Ch]
  int v5; // [sp+10h] [bp-818h] BYREF
  int v6; // [sp+14h] [bp-814h]
  char s[2064]; // [sp+18h] [bp-810h] BYREF

  v0 = dword_505180;
  if ( dword_505180 || (v1 = sub_48ABC(), v1 >= 0) )
  {
    v6 = 0;
    v5 = 0;
    v3 = 168077909;
    v4 = 14;
    if ( sub_48520(dword_50517C, (unsigned __int8 *)&v3, 6u, (unsigned __int8 *)&v5, 8u) )
    {
      strcpy(s, "get power status failed\n");
      sub_2E584(0, s, 0);
      strcpy(s, "can nont get power status\n");
      sub_2E584(0, s, 0);
      return -2147482880;
    }
    return (unsigned __int16)v6;
  }
  else
  {
    snprintf(s, 0x800u, "%s: auto exec bitmain_power_open, but open power failed\n", "bitmain_get_power_status");
    sub_2E584(v0, s, v0);
  }
  return v1;
}
// 50517C: using guessed type int dword_50517C;
// 505180: using guessed type int dword_505180;

//----- (00048CB8) --------------------------------------------------------
int __fastcall sub_48CB8(__int16 a1)
{
  int v2; // r6
  int v3; // r5
  char v5[2072]; // [sp+0h] [bp-818h] BYREF

  v2 = dword_505180;
  if ( dword_505180 )
    return sub_48834(dword_50517C, a1);
  v3 = sub_48ABC();
  if ( v3 >= 0 )
    return sub_48834(dword_50517C, a1);
  snprintf(v5, 0x800u, "%s: auto exec bitmain_power_open, but open power failed\n", "bitmain_set_voltage_by_n");
  sub_2E584(v2, v5, v2);
  return v3;
}
// 50517C: using guessed type int dword_50517C;
// 505180: using guessed type int dword_505180;

//----- (00048D38) --------------------------------------------------------
int sub_48D38()
{
  double v0; // d0
  int result; // r0
  int v2; // [sp+4h] [bp-4h]

  switch ( dword_505184 )
  {
    case 'A':
    case 'B':
      result = (int)(765.411764 - v0 * 35.833333);
      break;
    case 'C':
      result = (int)(933.240365 - v0 * 59.806034);
      break;
    case 'q':
    case 'r':
    case 'u':
    case 'w':
      v2 = (int)(1190.93534 - v0 * 78.742588);
      goto LABEL_3;
    case 't':
    case 'v':
      result = (int)(1156.10758 - v0 * 76.090494);
      break;
    default:
      v2 = -1;
LABEL_3:
      result = v2;
      break;
  }
  return result;
}
// 48D54: control flows out of bounds to 48D58
// 48E3C: variable 'v0' is possibly undefined
// 505184: using guessed type int dword_505184;

//----- (00048F00) --------------------------------------------------------
int sub_48F00()
{
  int v0; // r6
  unsigned int v1; // r0
  int v2; // r5
  char s[2064]; // [sp+8h] [bp-810h] BYREF

  v0 = dword_505180;
  if ( dword_505180 || (v2 = sub_48ABC(), v2 >= 0) )
  {
    v1 = sub_48D38();
    if ( v1 > 0xFF )
      return -2147482879;
    else
      return sub_48834(dword_50517C, (unsigned __int8)v1);
  }
  else
  {
    snprintf(s, 0x800u, "%s: auto exec bitmain_power_open, but open power failed\n", "bitmain_set_voltage");
    sub_2E584(v0, s, v0);
  }
  return v2;
}
// 50517C: using guessed type int dword_50517C;
// 505180: using guessed type int dword_505180;

//----- (00048F9C) --------------------------------------------------------
void sub_48F9C()
{
  ;
}
// 48FBC: control flows out of bounds to 48FC0
// 505184: using guessed type int dword_505184;

//----- (00049168) --------------------------------------------------------
void sub_49168()
{
  int v0; // r6
  int v1; // [sp+8h] [bp-820h] BYREF
  __int16 v2; // [sp+Ch] [bp-81Ch]
  int v3[2]; // [sp+10h] [bp-818h] BYREF
  char s[2064]; // [sp+18h] [bp-810h] BYREF

  v0 = dword_505180;
  if ( dword_505180 || sub_48ABC() >= 0 )
  {
    v3[1] = 0;
    v3[0] = 0;
    v1 = 50637397;
    v2 = 7;
    if ( sub_48520(dword_50517C, (unsigned __int8 *)&v1, 6u, (unsigned __int8 *)v3, 8u) )
    {
      strcpy(s, "get AD conversion N failed\n");
      sub_2E584(0, s, 0);
      strcpy(s, "can nont get voltage\n");
      sub_2E584(0, s, 0);
    }
    else
    {
      sub_48F9C();
    }
  }
  else
  {
    snprintf(s, 0x800u, "%s: auto exec bitmain_power_open, but open power failed\n", "bitmain_get_voltage");
    sub_2E584(v0, s, v0);
  }
}
// 50517C: using guessed type int dword_50517C;
// 505180: using guessed type int dword_505180;

//----- (000492A4) --------------------------------------------------------
int __fastcall sub_492A4(__int16 a1, int a2, int a3)
{
  int v4; // r8
  int v5; // r5
  char *v7; // r0
  int v8; // r3
  int v9; // r4
  char v10; // t1
  int v12; // [sp+Ch] [bp-82Ch] BYREF
  char v13; // [sp+10h] [bp-828h]
  char v14; // [sp+11h] [bp-827h]
  __int16 v15; // [sp+12h] [bp-826h]
  int v16; // [sp+14h] [bp-824h] BYREF
  int v17[2]; // [sp+18h] [bp-820h] BYREF
  char s[2072]; // [sp+20h] [bp-818h] BYREF

  v4 = dword_505180;
  v5 = 0;
  v13 = a1;
  v14 = a3;
  v15 = a3 + 12 + a1;
  v17[0] = 0;
  v17[1] = 0;
  v16 = 0;
  v12 = 101100117;
  if ( dword_505180 || (v5 = sub_48ABC(), v5 >= 0) )
  {
    if ( sub_48520(dword_50517C, (unsigned __int8 *)&v12, 8u, (unsigned __int8 *)&v16, a3 + 7) )
    {
      v5 = -2147482880;
      strcpy(s, "set DA conversion N failed\n");
      sub_2E584(0, s, 0);
    }
    else if ( a3 )
    {
      v7 = (char *)v17 + 1;
      v8 = a2 - 1;
      v9 = a2 + (unsigned __int8)(a3 - 1);
      do
      {
        v10 = *v7++;
        *(_BYTE *)++v8 = v10;
      }
      while ( v8 != v9 );
    }
  }
  else
  {
    snprintf(s, 0x800u, "%s: auto exec bitmain_power_open, but open power failed\n", "bitmain_power_read");
    sub_2E584(v4, s, v4);
  }
  return v5;
}
// 50517C: using guessed type int dword_50517C;
// 505180: using guessed type int dword_505180;

//----- (000493D0) --------------------------------------------------------
int __fastcall sub_493D0(int a1)
{
  int v2; // r0
  int v3; // r5
  int v4; // r0
  char v6[2072]; // [sp+0h] [bp-818h] BYREF

  if ( pthread_mutex_lock(&stru_505188) )
  {
    v3 = -4;
    strcpy(v6, "failed to iic lock\n");
    sub_2E584(0, v6, 0);
    return v3;
  }
  if ( a1 )
  {
    v2 = sub_49904();
    v3 = v2;
    if ( v2 < 0 )
    {
      v3 = -1;
      strcpy(v6, "failed to i2c_init\n");
      sub_2E584(0, v6, 0);
    }
    else
    {
      if ( sub_4A3EC(v2, *(unsigned __int16 *)(a1 + 4)) )
      {
        strcpy(v6, "failed to i2c_select\n");
        sub_2E584(0, v6, 0);
        goto LABEL_6;
      }
      if ( sub_4A2D8(v3, 1795, (2 * *(unsigned __int8 *)(a1 + 7)) | (16 * *(unsigned __int8 *)(a1 + 6))) )
      {
        strcpy(v6, "failed to i2c_ioctl\n");
        sub_2E584(0, v6, 0);
LABEL_6:
        if ( v3 )
        {
          v4 = v3;
          v3 = -1;
          sub_499E8(v4);
        }
        else
        {
          v3 = -1;
        }
      }
    }
  }
  else
  {
    v3 = -3;
    strcpy(v6, "bad param\n");
    sub_2E584(0, v6, 0);
  }
  pthread_mutex_unlock(&stru_505188);
  return v3;
}
// 505188: using guessed type pthread_mutex_t stru_505188;

//----- (00049574) --------------------------------------------------------
int __fastcall sub_49574(int a1)
{
  char v3[2056]; // [sp+0h] [bp-808h] BYREF

  if ( pthread_mutex_lock(&stru_505188) )
  {
    strcpy(v3, "failed to i2c lock\n");
    return sub_2E584(0, v3, 0);
  }
  else
  {
    sub_499E8(a1);
    return pthread_mutex_unlock(&stru_505188);
  }
}
// 505188: using guessed type pthread_mutex_t stru_505188;

//----- (000495E4) --------------------------------------------------------
int __fastcall sub_495E4(int a1, _BYTE *a2, int a3)
{
  int v6; // r4
  char v8[2064]; // [sp+0h] [bp-810h] BYREF

  if ( pthread_mutex_lock(&stru_505188) )
  {
    v6 = -4;
    strcpy(v8, "failed to i2c lock\n");
    sub_2E584(0, v8, 0);
  }
  else
  {
    v6 = sub_49B10(a1, a2, a3);
    pthread_mutex_unlock(&stru_505188);
  }
  return v6;
}
// 505188: using guessed type pthread_mutex_t stru_505188;

//----- (0004966C) --------------------------------------------------------
int __fastcall sub_4966C(int a1, int a2, int a3)
{
  int v6; // r4
  char v8[2064]; // [sp+0h] [bp-810h] BYREF

  if ( pthread_mutex_lock(&stru_505188) )
  {
    v6 = -4;
    strcpy(v8, "failed to i2c lock\n");
    sub_2E584(0, v8, 0);
  }
  else
  {
    v6 = sub_49CFC(a1, a2, a3);
    pthread_mutex_unlock(&stru_505188);
  }
  return v6;
}
// 505188: using guessed type pthread_mutex_t stru_505188;

//----- (000496F4) --------------------------------------------------------
int __fastcall sub_496F4(int a1, unsigned __int8 *a2, int a3, int a4, int a5)
{
  int v9; // r4
  char v11[2072]; // [sp+8h] [bp-818h] BYREF

  if ( pthread_mutex_lock(&stru_505188) )
  {
    v9 = -4;
    strcpy(v11, "failed to i2c lock\n");
    sub_2E584(0, v11, 0);
  }
  else
  {
    v9 = sub_49E8C(a1, a2, a3, a4, a5);
    pthread_mutex_unlock(&stru_505188);
  }
  return v9;
}
// 505188: using guessed type pthread_mutex_t stru_505188;

//----- (00049794) --------------------------------------------------------
int __fastcall sub_49794(int a1, unsigned __int8 *a2, int a3, int a4, int a5)
{
  int v9; // r4
  char v11[2072]; // [sp+8h] [bp-818h] BYREF

  if ( pthread_mutex_lock(&stru_505188) )
  {
    v9 = -4;
    strcpy(v11, "failed to i2c lock\n");
    sub_2E584(0, v11, 0);
  }
  else
  {
    v9 = sub_4A0DC(a1, a2, a3, a4, a5);
    pthread_mutex_unlock(&stru_505188);
  }
  return v9;
}
// 505188: using guessed type pthread_mutex_t stru_505188;

//----- (00049834) --------------------------------------------------------
int __fastcall sub_49834(_DWORD *a1, _DWORD *a2)
{
  return *a1 - *a2;
}

//----- (00049844) --------------------------------------------------------
unsigned int sub_49844()
{
  int v0; // r4
  unsigned int v2; // [sp+4h] [bp-14h] BYREF

  v0 = 601;
  v2 = 0;
  do
  {
    sub_40314(12, &v2);
    if ( (v2 & 0x80000000) != 0 )
      return v2 >> 31;
    usleep(0x1388u);
    --v0;
  }
  while ( v0 );
  return 0;
}

//----- (000498A0) --------------------------------------------------------
unsigned int __fastcall sub_498A0(_BYTE *a1)
{
  int v2; // r4
  unsigned int result; // r0
  unsigned int v4; // [sp+4h] [bp-14h] BYREF

  v2 = 601;
  v4 = 0;
  do
  {
    sub_40314(12, &v4);
    if ( (v4 & 0x80000000) != 0 )
    {
      result = v4 >> 31;
      *a1 = v4;
      return result;
    }
    usleep(0x1388u);
    --v2;
  }
  while ( v2 );
  return 0;
}

//----- (00049904) --------------------------------------------------------
int sub_49904()
{
  const pthread_mutexattr_t *v0; // r4
  int *v1; // r6
  int v3; // [sp+Ch] [bp-814h] BYREF
  _DWORD v4[516]; // [sp+10h] [bp-810h] BYREF

  v3 = -1;
  if ( dword_504C90 )
  {
    v0 = (const pthread_mutexattr_t *)dword_5051A0;
    if ( dword_5051A0 )
    {
      v1 = (int *)dword_5051A4;
    }
    else
    {
      v1 = sub_432D0((int)sub_49834, dword_5051A0, dword_5051A0);
      dword_5051A4 = (int)v1;
      pthread_mutex_init(&stru_5051A8, v0);
      v0 = (const pthread_mutexattr_t *)dword_5051A0;
    }
    dword_5051A0 = (int)v0 + 1;
    v3 = (int)v0 + 1;
    v4[0] = 0;
    v4[1] = 0;
    sub_43320(v1, &v3, 4u, v4, 8u);
    return v3;
  }
  else
  {
    strcpy((char *)v4, "please init platform first!!\n");
    sub_2E584(dword_504C90, (const char *)v4, dword_504C90);
    return -2;
  }
}
// 504C90: using guessed type int dword_504C90;
// 5051A0: using guessed type int dword_5051A0;
// 5051A4: using guessed type int dword_5051A4;

//----- (000499E8) --------------------------------------------------------
int __fastcall sub_499E8(int a1)
{
  _DWORD *v1; // r4
  int result; // r0
  int v3; // [sp+4h] [bp-814h] BYREF
  char s[2064]; // [sp+8h] [bp-810h] BYREF

  v3 = a1;
  if ( pthread_mutex_lock(&stru_5051A8) )
  {
    strcpy(s, "failed to i2c lock\n");
    return sub_2E584(0, s, 0);
  }
  else
  {
    if ( sub_43338((int *)dword_5051A4, (int)&v3) == (int *)1 )
    {
      sub_43358((int *)dword_5051A4, (int)&v3);
    }
    else
    {
      snprintf(s, 0x800u, "ctx(%d) is not inited\n", v3);
      sub_2E584(1, s, 0);
    }
    v1 = sub_43440(dword_5051A4);
    if ( ((int (*)(void))*v1)() )
    {
      while ( ((int (__fastcall *)(_DWORD *))*v1)(v1) )
        ;
      j_free(v1);
      return pthread_mutex_unlock(&stru_5051A8);
    }
    else
    {
      j_free(v1);
      pthread_mutex_unlock(&stru_5051A8);
      dword_5051A0 = 0;
      result = sub_43414((void **)dword_5051A4);
      dword_5051A4 = 0;
    }
  }
  return result;
}
// 5051A0: using guessed type int dword_5051A0;
// 5051A4: using guessed type int dword_5051A4;

//----- (00049B10) --------------------------------------------------------
int __fastcall sub_49B10(int a1, _BYTE *a2, int a3)
{
  void *v5; // r0
  int v6; // r5
  _BYTE *v7; // r8
  _BYTE *v8; // r0
  int v10; // [sp+4h] [bp-824h] BYREF
  void *ptr; // [sp+Ch] [bp-81Ch] BYREF
  char s[2072]; // [sp+10h] [bp-818h] BYREF

  v10 = a1;
  if ( pthread_mutex_lock(&stru_5051A8) )
  {
    strcpy(s, "failed to i2c lock\n");
    sub_2E584(0, s, 0);
    return -1;
  }
  else
  {
    ptr = 0;
    if ( sub_433D0((int *)dword_5051A4, (int)&v10, &ptr) == 1 )
    {
      v5 = ptr;
      v6 = (*(_DWORD *)ptr << 26) | 0x2000000 | (*((_DWORD *)ptr + 1) >> 4 << 20) | (*((_DWORD *)ptr + 1) << 15) & 0x70000;
      if ( a3 )
      {
        v7 = &a2[a3];
        while ( 1 )
        {
          if ( !sub_49844() )
          {
            free(ptr);
            strcpy(s, "iic not ready 4 read1\n");
            sub_2E584(0, s, 0);
            pthread_mutex_unlock(&stru_5051A8);
            return -2;
          }
          sub_40390(12, v6);
          v8 = a2++;
          if ( !sub_498A0(v8) )
            break;
          if ( a2 == v7 )
          {
            v5 = ptr;
            goto LABEL_10;
          }
        }
        free(ptr);
        strcpy(s, "iic not ready 4 read2\n");
        sub_2E584(0, s, 0);
        pthread_mutex_unlock(&stru_5051A8);
        return -3;
      }
      else
      {
LABEL_10:
        free(v5);
        pthread_mutex_unlock(&stru_5051A8);
        return a3;
      }
    }
    else
    {
      snprintf(s, 0x800u, "ctx %d not inited\n", v10);
      sub_2E584(0, s, 0);
      pthread_mutex_unlock(&stru_5051A8);
      return -2;
    }
  }
}
// 5051A4: using guessed type int dword_5051A4;

//----- (00049CFC) --------------------------------------------------------
int __fastcall sub_49CFC(int a1, int a2, int a3)
{
  _DWORD *v5; // r8
  int v6; // r6
  int v7; // r5
  int v8; // r6
  int v9; // t1
  int v10; // r4
  int v12; // [sp+4h] [bp-824h] BYREF
  void *ptr; // [sp+Ch] [bp-81Ch] BYREF
  char s[2072]; // [sp+10h] [bp-818h] BYREF

  v12 = a1;
  if ( pthread_mutex_lock(&stru_5051A8) )
  {
    strcpy(s, "failed to i2c lock\n");
    sub_2E584(0, s, 0);
    return -1;
  }
  else
  {
    ptr = 0;
    if ( sub_433D0((int *)dword_5051A4, (int)&v12, &ptr) == 1 )
    {
      v5 = ptr;
      if ( a3 )
      {
        v6 = a2 + a3;
        v7 = a2 - 1;
        v8 = v6 - 1;
        do
        {
          v9 = *(unsigned __int8 *)++v7;
          v10 = v9 | (v5[1] >> 4 << 20) | (*v5 << 26) | (v5[1] << 15) & 0x70000;
          if ( !sub_49844() )
          {
            free(ptr);
            strcpy(s, "iic not ready 4 write\n");
            sub_2E584(0, s, 0);
            pthread_mutex_unlock(&stru_5051A8);
            return -2;
          }
          sub_40390(12, v10);
        }
        while ( v8 != v7 );
        v5 = ptr;
      }
      free(v5);
      pthread_mutex_unlock(&stru_5051A8);
      return a3;
    }
    else
    {
      snprintf(s, 0x800u, "ctx %d not inited\n", v12);
      sub_2E584(0, s, 0);
      pthread_mutex_unlock(&stru_5051A8);
      return -2;
    }
  }
}
// 5051A4: using guessed type int dword_5051A4;

//----- (00049E8C) --------------------------------------------------------
int __fastcall sub_49E8C(int a1, unsigned __int8 *a2, int a3, int a4, int a5)
{
  int v7; // r5
  _DWORD *v8; // r9
  _BYTE *v9; // r0
  int v10; // r4
  int v12; // [sp+4h] [bp-82Ch] BYREF
  void *ptr; // [sp+Ch] [bp-824h] BYREF
  char s[2080]; // [sp+10h] [bp-820h] BYREF

  v12 = a1;
  if ( a3 == 1 )
  {
    v7 = pthread_mutex_lock(&stru_5051A8);
    if ( v7 )
    {
      strcpy(s, "failed to i2c lock\n");
      sub_2E584(0, s, 0);
      return -1;
    }
    else
    {
      ptr = 0;
      if ( sub_433D0((int *)dword_5051A4, (int)&v12, &ptr) == 1 )
      {
        v8 = ptr;
        if ( a5 )
        {
          while ( 1 )
          {
            v10 = (*v8 << 26) | 0x3000000 | (v8[1] >> 4 << 20) | (v8[1] << 15) & 0x70000 | ((*a2 + v7) << 8);
            if ( !sub_49844() )
            {
              strcpy(s, "iic not ready 4 read1\n");
              sub_2E584(0, s, 0);
              free(ptr);
              pthread_mutex_unlock(&stru_5051A8);
              return -2;
            }
            sub_40390(12, v10);
            v9 = (_BYTE *)(a4 + v7++);
            if ( !sub_498A0(v9) )
              break;
            if ( a5 == v7 )
            {
              v8 = ptr;
              goto LABEL_11;
            }
          }
          strcpy(s, "iic failed to read data\n");
          sub_2E584(0, s, 0);
          free(ptr);
          pthread_mutex_unlock(&stru_5051A8);
          return -3;
        }
        else
        {
LABEL_11:
          free(v8);
          pthread_mutex_unlock(&stru_5051A8);
          return a5;
        }
      }
      else
      {
        snprintf(s, 0x800u, "ctx %d not inited\n", v12);
        sub_2E584(0, s, 0);
        pthread_mutex_unlock(&stru_5051A8);
        return -2;
      }
    }
  }
  else
  {
    strcpy(s, "more than one byte reg address is not supported\n");
    sub_2E584(0, s, 0);
    return -3;
  }
}
// 5051A4: using guessed type int dword_5051A4;

//----- (0004A0DC) --------------------------------------------------------
int __fastcall sub_4A0DC(int a1, unsigned __int8 *a2, int a3, int a4, int a5)
{
  int v7; // r8
  _DWORD *v8; // r9
  int v9; // r5
  int v10; // t1
  int v11; // r1
  int v12; // r4
  int v14; // [sp+4h] [bp-82Ch] BYREF
  void *ptr; // [sp+Ch] [bp-824h] BYREF
  char s[2080]; // [sp+10h] [bp-820h] BYREF

  v14 = a1;
  if ( a3 == 1 )
  {
    v7 = pthread_mutex_lock(&stru_5051A8);
    if ( v7 )
    {
      strcpy(s, "failed to i2c lock\n");
      sub_2E584(0, s, 0);
      return -1;
    }
    else
    {
      ptr = 0;
      if ( sub_433D0((int *)dword_5051A4, (int)&v14, &ptr) == 1 )
      {
        v8 = ptr;
        if ( a5 )
        {
          v9 = a4 - 1;
          do
          {
            v10 = *(unsigned __int8 *)++v9;
            v11 = *a2 + v7++;
            v12 = (*v8 << 26) | 0x1000000 | (v8[1] >> 4 << 20) | v10 | (v8[1] << 15) & 0x70000 | (v11 << 8);
            if ( !sub_49844() )
            {
              strcpy(s, "iic not ready 4 write\n");
              sub_2E584(0, s, 0);
              free(ptr);
              pthread_mutex_unlock(&stru_5051A8);
              return -2;
            }
            sub_40390(12, v12);
          }
          while ( a5 != v7 );
          v8 = ptr;
        }
        free(v8);
        pthread_mutex_unlock(&stru_5051A8);
        return a5;
      }
      else
      {
        snprintf(s, 0x800u, "ctx %d not inited\n", v14);
        sub_2E584(0, s, 0);
        pthread_mutex_unlock(&stru_5051A8);
        return -2;
      }
    }
  }
  else
  {
    strcpy(s, "more than one byte reg address is not supported\n");
    sub_2E584(0, s, 0);
    return -3;
  }
}
// 5051A4: using guessed type int dword_5051A4;

//----- (0004A2D8) --------------------------------------------------------
int __fastcall sub_4A2D8(int a1, int a2, int a3)
{
  _DWORD *v6; // r4
  int *v7; // r0
  int *v8; // r5
  int v9; // r12
  void (__fastcall *v10)(_DWORD *, _DWORD *, int); // r3
  _DWORD v12[518]; // [sp+0h] [bp-818h] BYREF

  if ( pthread_mutex_lock(&stru_5051A8) )
  {
    strcpy((char *)v12, "failed to i2c lock\n");
    sub_2E584(0, (const char *)v12, 0);
    return -4;
  }
  else
  {
    v6 = sub_43440(dword_5051A4);
    if ( ((int (*)(void))*v6)() )
    {
      while ( ***(_DWORD ***)(v6[5] + 16) != a1 )
      {
        if ( !((int (__fastcall *)(_DWORD *))*v6)(v6) )
          goto LABEL_8;
      }
      v7 = (int *)((int (*)(void))v6[2])();
      v8 = v7;
      if ( a2 == 1795 )
      {
        v9 = *v7;
        v10 = (void (__fastcall *)(_DWORD *, _DWORD *, int))v6[1];
        v12[1] = a3;
        v12[0] = v9;
        v10(v6, v12, 8);
        free(v8);
      }
    }
LABEL_8:
    j_free(v6);
    pthread_mutex_unlock(&stru_5051A8);
    return 0;
  }
}
// 5051A4: using guessed type int dword_5051A4;

//----- (0004A3EC) --------------------------------------------------------
int __fastcall sub_4A3EC(int a1, int a2)
{
  _DWORD *v4; // r4
  _DWORD *v5; // r5
  void (__fastcall *v6)(_DWORD *, _DWORD *, int); // r3
  int v7; // r12
  _DWORD v9[516]; // [sp+0h] [bp-810h] BYREF

  if ( pthread_mutex_lock(&stru_5051A8) )
  {
    strcpy((char *)v9, "failed to i2c lock\n");
    sub_2E584(0, (const char *)v9, 0);
    return -4;
  }
  else
  {
    v4 = sub_43440(dword_5051A4);
    if ( ((int (*)(void))*v4)() )
    {
      while ( ***(_DWORD ***)(v4[5] + 16) != a1 )
      {
        if ( !((int (__fastcall *)(_DWORD *))*v4)(v4) )
          goto LABEL_7;
      }
      v5 = (_DWORD *)((int (*)(void))v4[2])();
      v6 = (void (__fastcall *)(_DWORD *, _DWORD *, int))v4[1];
      v7 = v5[1];
      v9[0] = a2;
      v9[1] = v7;
      v6(v4, v9, 8);
      free(v5);
    }
LABEL_7:
    j_free(v4);
    pthread_mutex_unlock(&stru_5051A8);
    return 0;
  }
}
// 5051A4: using guessed type int dword_5051A4;

//----- (0004A4E8) --------------------------------------------------------
int __fastcall sub_4A4E8(void *src, size_t n, const void **a3)
{
  return sub_4D9E4(a3, src, n);
}

//----- (0004A4FC) --------------------------------------------------------
int __fastcall sub_4A4FC(void *src, size_t n, _DWORD *a3)
{
  int v4; // r12
  size_t v5; // r3

  v4 = a3[1];
  v5 = v4 + n;
  if ( v4 + n <= *a3 )
  {
    memcpy((void *)(a3[2] + v4), src, n);
    v5 = n + a3[1];
  }
  a3[1] = v5;
  return 0;
}

//----- (0004A540) --------------------------------------------------------
size_t __fastcall sub_4A540(const void *a1, size_t a2, FILE *s)
{
  size_t result; // r0

  result = fwrite(a1, a2, 1u, s) - 1;
  if ( result )
    return -1;
  return result;
}

//----- (0004A55C) --------------------------------------------------------
size_t __fastcall sub_4A55C(void *buf, size_t n, int *a3)
{
  size_t result; // r0

  result = n - write(*a3, buf, n);
  if ( result )
    return -1;
  return result;
}

//----- (0004A584) --------------------------------------------------------
int __fastcall sub_4A584(const char **a1, const char **a2)
{
  return strcmp(*a1, *a2);
}

//----- (0004A590) --------------------------------------------------------
int __fastcall sub_4A590(char *a1, int a2, int (__fastcall *a3)(char *, int, int), int a4, unsigned int a5)
{
  char *v9; // r8
  char *i; // r10
  char *v12; // r5
  bool v13; // zf
  int v14; // r1
  char *v15; // r0
  int v16; // r1
  unsigned int v17; // r3
  int v18; // [sp+0h] [bp-50h]
  int v19; // [sp+14h] [bp-3Ch] BYREF
  char s[56]; // [sp+18h] [bp-38h] BYREF

  v19 = 0;
  if ( a3("\"", 1, a4) )
    return -1;
  v9 = &a1[a2];
  for ( i = a1; i < v9; i = v12 )
  {
    v12 = sub_4DF70(i, v9 - i, &v19);
    if ( !v12 )
      return -1;
    v13 = v19 == 34;
    if ( v19 != 34 )
      v13 = v19 == 92;
    v14 = v13;
    if ( v19 <= 31 )
      v14 |= 1u;
    if ( !v14 && ((v19 == 47) & (a5 >> 10)) == 0 && ((v19 > 127) & (a5 >> 6)) == 0 )
      continue;
    if ( a1 != i && a3(a1, i - a1, a4) )
      return -1;
    if ( i == v12 )
      return a3("\"", 1, a4);
    if ( v19 == 12 )
    {
      v16 = 2;
      v15 = "\\f";
      goto LABEL_26;
    }
    if ( v19 <= 12 )
    {
      switch ( v19 )
      {
        case 9:
          v15 = "\\t";
          v16 = 2;
          goto LABEL_26;
        case 10:
          v15 = "\\n";
          v16 = 2;
          goto LABEL_26;
        case 8:
          v15 = "\\b";
          v16 = 2;
          goto LABEL_26;
      }
LABEL_32:
      if ( v19 >= 0x10000 )
      {
        v17 = ((unsigned int)(v19 - 0x10000) >> 10) & 0x3FF | 0xD800;
        v18 = (v19 - 0x10000) & 0x3FF | 0xDC00;
        v19 -= 0x10000;
        snprintf(s, 0xDu, "\\u%04X\\u%04X", v17, v18);
        v15 = s;
        v16 = 12;
        goto LABEL_26;
      }
LABEL_33:
      snprintf(s, 0xDu, "\\u%04X");
      v15 = s;
      v16 = 6;
      goto LABEL_26;
    }
    if ( v19 == 34 )
    {
      v15 = "\\\"";
      v16 = 2;
      goto LABEL_26;
    }
    if ( v19 <= 34 )
    {
      if ( v19 == 13 )
      {
        v15 = "\\r";
        v16 = 2;
        goto LABEL_26;
      }
      goto LABEL_33;
    }
    if ( v19 == 47 )
    {
      v15 = "\\/";
      v16 = 2;
      goto LABEL_26;
    }
    if ( v19 != 92 )
      goto LABEL_32;
    v15 = "\\\\";
    v16 = 2;
LABEL_26:
    if ( a3(v15, v16, a4) )
      return -1;
    a1 = v12;
  }
  if ( a1 == i || !a3(a1, i - a1, a4) )
    return a3("\"", 1, a4);
  return -1;
}
// 4A730: conditional instruction was optimized away because %var_3C.4 is in (E..21)

//----- (0004A818) --------------------------------------------------------
int __fastcall sub_4A818(char a1, int a2, int a3, int (__fastcall *a4)(__int16 *, int, int), int a5)
{
  unsigned int v6; // r4
  int v7; // r5

  if ( (a1 & 0x1F) != 0 )
  {
    v6 = (a1 & 0x1F) * a2;
    if ( a4(&word_6A02C, 1, a5) )
      return -1;
    if ( v6 )
    {
      while ( 1 )
      {
        v7 = v6 >= 0x20 ? 32 : v6;
        if ( a4((__int16 *)"                                ", v7, a5) )
          break;
        v6 -= v7;
        if ( !v6 )
          return 0;
      }
      return -1;
    }
    return 0;
  }
  if ( !a3 || (a1 & 0x20) != 0 )
    return 0;
  return a4((__int16 *)" ", 1, a5);
}
// 6A02C: using guessed type __int16 word_6A02C;

//----- (0004A8C8) --------------------------------------------------------
int __fastcall sub_4A8C8(int *a1, const void *a2, char *s)
{
  void *v5; // r0

  snprintf(s, 0xBu, "%p", a2);
  if ( sub_4BC44((int)a1, s) )
    return -1;
  v5 = sub_4EB60();
  return sub_4B9B0(a1, s, (int)v5);
}

//----- (0004A920) --------------------------------------------------------
int __fastcall sub_4A920(_DWORD *a1, int a2, int a3, int *a4, int (__fastcall *a5)(__int16 *, int, int), int a6)
{
  int *v7; // r5
  int v8; // r8
  unsigned int v9; // r7
  char v11; // r9
  char *v12; // r3
  int v13; // r3
  int v14; // r6
  char *v16; // r5
  _DWORD *v17; // r0
  __int64 v18; // r0
  int v19; // r0
  int v20; // r1
  int v21; // r8
  int v22; // r6
  int v23; // r11
  int v24; // r9
  char *v25; // r10
  int v26; // r0
  _DWORD *v27; // r0
  unsigned int v28; // r9
  int v29; // r8
  _DWORD *v30; // r3
  _DWORD *v31; // r11
  unsigned int v32; // r10
  _DWORD *v33; // r0
  int v34; // r0
  int v35; // r9
  unsigned int v36; // r7
  int v37; // r5
  int v38; // r8
  int v39; // r11
  unsigned int v40; // r6
  char *v41; // r10
  char *v42; // t1
  _DWORD *v43; // r9
  int v44; // r0
  int v45; // r8
  __int16 *v46; // [sp+Ch] [bp-BCh]
  _DWORD *v47; // [sp+Ch] [bp-BCh]
  int v48; // [sp+Ch] [bp-BCh]
  int v49; // [sp+10h] [bp-B8h]
  int v50; // [sp+10h] [bp-B8h]
  int v51; // [sp+14h] [bp-B4h]
  int v52; // [sp+14h] [bp-B4h]
  size_t nmemb; // [sp+18h] [bp-B0h]
  int v54; // [sp+1Ch] [bp-ACh]
  int v55; // [sp+20h] [bp-A8h]
  void *base; // [sp+24h] [bp-A4h]
  _DWORD *v57; // [sp+28h] [bp-A0h]
  int v58; // [sp+28h] [bp-A0h]
  int v59; // [sp+2Ch] [bp-9Ch]
  unsigned int v60; // [sp+30h] [bp-98h]
  int *v61; // [sp+34h] [bp-94h]
  __int16 s[70]; // [sp+3Ch] [bp-8Ch] BYREF

  if ( !a1 )
    return -1;
  v7 = a4;
  v8 = a2 & 0x10000;
  v9 = a2 & 0xFFFEFFFF;
  v11 = a2;
  switch ( *a1 )
  {
    case 0:
      v12 = ":";
      if ( (a2 & 0x20) == 0 )
        v12 = ": ";
      v46 = (__int16 *)v12;
      if ( (a2 & 0x20) != 0 )
        v13 = 1;
      else
        v13 = 2;
      v49 = v13;
      v14 = sub_4A8C8(v7, a1, (char *)s);
      if ( v14 )
        return -1;
      v51 = sub_4E49C(a1);
      if ( v8 )
      {
        if ( !v51 )
          goto LABEL_45;
      }
      else
      {
        if ( a5((__int16 *)"{", 1, a6) )
          return -1;
        if ( !v51 )
        {
          sub_4BCA4(v7, (char *)s);
          return a5((__int16 *)"}", 1, a6);
        }
      }
      if ( sub_4A818(v9, a3 + 1, 0, a5, a6) )
        return -1;
      if ( (v11 & 0x80) == 0 )
      {
        v55 = v8;
        v21 = a3 + 1;
        v22 = v51;
        v23 = v49;
        v50 = a3;
        while ( 1 )
        {
          v24 = sub_4E4E8(a1, v22);
          v25 = (char *)sub_4E51C(v22);
          v26 = strlen(v25);
          sub_4A590(v25, v26, (int (__fastcall *)(char *, int, int))a5, a6, v9);
          if ( a5(v46, v23, a6) )
            return -1;
          v27 = (_DWORD *)sub_4E528(v22);
          if ( sub_4A920(v27, v9, v21, v7, a5, a6) )
            return -1;
          if ( !v24 )
          {
            v45 = v55;
            v14 = 0;
            if ( sub_4A818(v9, v50, 0, a5, a6) )
              return -1;
            goto LABEL_68;
          }
          if ( !a5((__int16 *)",", 1, a6) )
          {
            v22 = v24;
            if ( !sub_4A818(v9, v21, 1, a5, a6) )
              continue;
          }
          return -1;
        }
      }
      v57 = sub_4E218(a1);
      v34 = sub_4D880(4 * (_DWORD)v57);
      base = (void *)v34;
      if ( !v34 )
        return -1;
      v60 = v9;
      v61 = v7;
      v35 = v34 - 4;
      v59 = v34 - 4;
      v36 = 0;
      v37 = v51;
      while ( 1 )
      {
        *(_DWORD *)(v35 + 4) = sub_4E51C(v37);
        v35 += 4;
        v37 = sub_4E4E8(a1, v37);
        if ( !v37 )
          break;
        ++v36;
      }
      nmemb = v36 + 1;
      v7 = v61;
      if ( v57 != (_DWORD *)(v36 + 1) )
        _assert_fail("i == size", "dump.c", 0x160u, "do_dump");
      qsort(base, nmemb, 4u, (__compar_fn_t)sub_4A584);
      v58 = v8;
      v38 = v59;
      v39 = a3 + 1;
      v40 = 0;
      v54 = a3;
      do
      {
        v42 = *(char **)(v38 + 4);
        v38 += 4;
        v41 = v42;
        v43 = (_DWORD *)sub_4E234(a1, v42);
        if ( !v43 )
          _assert_fail("value", "dump.c", 0x16Bu, "do_dump");
        v44 = strlen(v41);
        sub_4A590(v41, v44, (int (__fastcall *)(char *, int, int))a5, a6, v60);
        if ( a5(v46, v49, a6) || sub_4A920(v43, v60, v39, v61, a5, a6) )
        {
LABEL_64:
          v14 = -1;
          sub_4D898((int)base);
          return v14;
        }
        if ( v40 < v36 )
        {
          if ( a5((__int16 *)",", 1, a6) || sub_4A818(v60, v39, 1, a5, a6) )
            goto LABEL_64;
        }
        else if ( sub_4A818(v60, v54, 0, a5, a6) )
        {
          goto LABEL_64;
        }
        ++v40;
      }
      while ( v40 != nmemb );
      v45 = v58;
      v14 = 0;
      sub_4D898((int)base);
LABEL_68:
      sub_4BCA4(v7, (char *)s);
      if ( !v45 )
        return a5((__int16 *)"}", 1, a6);
      return v14;
    case 1:
      v14 = sub_4A8C8(a4, a1, (char *)s);
      if ( v14 )
        return -1;
      v47 = sub_4E5A0(a1);
      if ( v8 )
      {
        if ( !v47 )
        {
LABEL_45:
          sub_4BCA4(v7, (char *)s);
          return v14;
        }
      }
      else
      {
        if ( a5((__int16 *)"[", 1, a6) )
          return -1;
        if ( !v47 )
        {
          sub_4BCA4(v7, (char *)s);
          return a5(&word_6BB38, 1, a6);
        }
      }
      v28 = sub_4A818(v9, a3 + 1, 0, a5, a6);
      if ( v28 )
        return -1;
      v52 = v8;
      v29 = a3 + 1;
      v30 = v47;
      v48 = a3;
      v31 = v30;
      v32 = (unsigned int)v30 - 1;
      break;
    case 2:
      v16 = (char *)sub_4E768(a1);
      v17 = sub_4E784(a1);
      return sub_4A590(v16, (int)v17, (int (__fastcall *)(char *, int, int))a5, a6, v9);
    case 3:
      v18 = sub_4E9C4((int)a1);
      v19 = snprintf((char *)s, 0x64u, "%lld", v18);
      return a5(s, v19, a6);
    case 4:
      sub_4EA70();
      v20 = sub_4DBF0((char *)s, 0x64u);
      if ( v20 < 0 )
        return -1;
      return a5(s, v20, a6);
    case 5:
      return a5((__int16 *)"true", 4, a6);
    case 6:
      return a5((__int16 *)"false", 5, a6);
    case 7:
      return a5((__int16 *)"null", 4, a6);
    default:
      return -1;
  }
  do
  {
    v33 = sub_4E5BC(a1, v28);
    v14 = sub_4A920(v33, v9, v29, v7, a5, a6);
    if ( v14 )
      return -1;
    if ( v32 <= v28 )
    {
      if ( sub_4A818(v9, v48, 0, a5, a6) )
        return -1;
    }
    else if ( a5((__int16 *)",", 1, a6) || sub_4A818(v9, v29, 1, a5, a6) )
    {
      return -1;
    }
    ++v28;
  }
  while ( v31 != (_DWORD *)v28 );
  sub_4BCA4(v7, (char *)s);
  if ( !v52 )
    return a5(&word_6BB38, 1, a6);
  return v14;
}
// 4A950: control flows out of bounds to 4A954
// 6BB38: using guessed type __int16 word_6BB38;
// 4A920: using guessed type __int16 s[70];

//----- (0004B130) --------------------------------------------------------
int __fastcall sub_4B130(_DWORD *a1, int (__fastcall *a2)(__int16 *, int, int), int a3, int a4)
{
  int v8; // r4
  int v10[13]; // [sp+Ch] [bp-34h] BYREF

  if ( (a4 & 0x200) == 0 && (!a1 || *a1 > 1u) || sub_4B91C(v10) )
    return -1;
  v8 = sub_4A920(a1, a4, 0, v10, a2, a3);
  sub_4B998((int)v10);
  return v8;
}
// 4B130: using guessed type int var_34[13];

//----- (0004B1A8) --------------------------------------------------------
_BYTE *__fastcall sub_4B1A8(_DWORD *a1, int a2)
{
  _BYTE *v4; // r4
  const char *v6; // r0
  int v7[7]; // [sp+4h] [bp-1Ch] BYREF

  v4 = (_BYTE *)sub_4D954(v7);
  if ( v4 )
    return 0;
  if ( !sub_4B130(a1, (int (__fastcall *)(__int16 *, int, int))sub_4A4E8, (int)v7, a2) )
  {
    v6 = (const char *)sub_4D9C8((int)v7);
    v4 = sub_4D8FC(v6);
  }
  sub_4D988(v7);
  return v4;
}
// 4B1A8: using guessed type int var_1C[7];

//----- (0004B250) --------------------------------------------------------
int __fastcall sub_4B250(_DWORD *a1, int a2, int a3)
{
  return sub_4B130(a1, (int (__fastcall *)(__int16 *, int, int))sub_4A540, a2, a3);
}

//----- (0004B264) --------------------------------------------------------
int __fastcall sub_4B264(_DWORD *a1, int a2, int a3)
{
  FILE *v5; // r4
  int v6; // r5

  v5 = (FILE *)fopen64(a2, "w");
  if ( !v5 )
    return -1;
  v6 = sub_4B130(a1, (int (__fastcall *)(__int16 *, int, int))sub_4A540, (int)v5, a3);
  if ( fclose(v5) )
    return -1;
  return v6;
}
// 124E4: using guessed type int __fastcall fopen64(_DWORD, _DWORD);

//----- (0004B2C8) --------------------------------------------------------
int __fastcall sub_4B2C8(_DWORD *a1, int a2, int a3)
{
  int v4; // [sp+4h] [bp-Ch] BYREF

  v4 = a2;
  return sub_4B130(a1, (int (__fastcall *)(__int16 *, int, int))sub_4A55C, (int)&v4, a3);
}

//----- (0004B2F4) --------------------------------------------------------
int __fastcall sub_4B2F4(unsigned __int16 *a1, unsigned int a2, int a3)
{
  unsigned int v3; // r12
  unsigned __int16 *v4; // r4
  int v5; // r3
  int v6; // lr
  int v7; // r6
  int v8; // r5
  int v9; // r3
  int v10; // lr
  int v11; // r2
  int v12; // r3
  int v13; // r5
  int v14; // r2
  int v15; // r12
  int v16; // r2
  int v17; // lr
  int v18; // r3
  int v19; // r2
  int v20; // r2
  int v21; // r3
  unsigned __int16 *v22; // r4
  int v23; // r6
  int v24; // r5
  int v25; // r7
  int v26; // r2
  int v27; // r3
  int v28; // r12
  int v29; // lr
  int v30; // r2
  int v31; // lr
  int v32; // r3
  int v33; // r12
  int v34; // r2
  int v35; // r5
  int v36; // r2
  int v37; // r3
  int v38; // r2
  unsigned __int16 *v39; // r4
  int v40; // r6
  int v41; // r2
  int v42; // r7
  int v43; // r8
  int v44; // r3
  int v45; // r12
  int v46; // lr
  int v47; // r2
  int v48; // lr
  int v49; // r3
  int v50; // r12
  int v51; // r2
  int v52; // r5
  int v53; // r2
  int v54; // r3
  int v55; // r2
  int v56; // r12
  int v57; // r3
  int v58; // r12
  int v59; // lr
  int v60; // r3
  int v61; // r12
  int v62; // r12
  int v64; // r4

  v3 = a3 - 559038737 + a2;
  if ( ((unsigned __int8)a1 & 3) == 0 )
  {
    if ( a2 <= 0xC )
    {
      v5 = a3 - 559038737 + a2;
      v6 = v5;
    }
    else
    {
      v4 = a1 + 6;
      v5 = a3 - 559038737 + a2;
      v6 = v5;
      do
      {
        a2 -= 12;
        v7 = *((_DWORD *)v4 - 3);
        v8 = *((_DWORD *)v4 - 2);
        a1 = v4;
        v9 = v5 + *((_DWORD *)v4 - 1);
        v4 += 6;
        v10 = v6 + v8;
        v11 = (v7 - v9 + v3) ^ __ROR4__(v9, 28);
        v12 = v10 + v9;
        v13 = v11 + v12;
        v14 = (v10 - v11) ^ __ROR4__(v11, 26);
        v15 = v14 + v13;
        v16 = (v12 - v14) ^ __ROR4__(v14, 24);
        v17 = v16 + v15;
        v18 = (v13 - v16) ^ __ROR4__(v16, 16);
        v19 = v15 - v18;
        v3 = v18 + v17;
        v20 = v19 ^ __ROR4__(v18, 13);
        v21 = v17 - v20;
        v6 = v20 + v3;
        v5 = v21 ^ __ROR4__(v20, 28);
      }
      while ( a2 > 0xC );
    }
    switch ( a2 )
    {
      case 1u:
        goto LABEL_27;
      case 2u:
        goto LABEL_32;
      case 3u:
        v56 = (*(_DWORD *)a1 & 0xFFFFFF) + v3;
        goto LABEL_28;
      case 4u:
        v56 = v3 + *(_DWORD *)a1;
        goto LABEL_28;
      case 5u:
        v6 += *((unsigned __int8 *)a1 + 4);
        v56 = v3 + *(_DWORD *)a1;
        goto LABEL_28;
      case 6u:
        v6 += a1[2];
        v56 = v3 + *(_DWORD *)a1;
        goto LABEL_28;
      case 7u:
        v56 = v3 + *(_DWORD *)a1;
        v6 += *((_DWORD *)a1 + 1) & 0xFFFFFF;
        goto LABEL_28;
      case 8u:
        v6 += *((_DWORD *)a1 + 1);
        v56 = v3 + *(_DWORD *)a1;
        goto LABEL_28;
      case 9u:
        v64 = *((unsigned __int8 *)a1 + 8);
        goto LABEL_35;
      case 0xAu:
        v64 = a1[4];
        goto LABEL_35;
      case 0xBu:
        v5 += *((_DWORD *)a1 + 2) & 0xFFFFFF;
        v6 += *((_DWORD *)a1 + 1);
        v56 = v3 + *(_DWORD *)a1;
        goto LABEL_28;
      case 0xCu:
        v64 = *((_DWORD *)a1 + 2);
LABEL_35:
        v5 += v64;
        v6 += *((_DWORD *)a1 + 1);
        v56 = v3 + *(_DWORD *)a1;
        goto LABEL_28;
      default:
        return v5;
    }
  }
  if ( ((unsigned __int8)a1 & 1) == 0 )
  {
    if ( a2 <= 0xC )
    {
      v5 = a3 - 559038737 + a2;
      v6 = v5;
    }
    else
    {
      v22 = a1 + 6;
      v5 = a3 - 559038737 + a2;
      v6 = v5;
      do
      {
        v23 = *(v22 - 1);
        a2 -= 12;
        v24 = *(v22 - 2);
        v25 = *(v22 - 5);
        a1 = v22;
        v26 = *(v22 - 6);
        v22 += 6;
        v27 = v24 + (v23 << 16) + v5;
        v28 = (v26 + (v25 << 16) - v27 + v3) ^ __ROR4__(v27, 28);
        v29 = *(v22 - 10) + (*(v22 - 9) << 16) + v6;
        v30 = v29 - v28;
        v31 = v29 + v27;
        v32 = v30 ^ __ROR4__(v28, 26);
        v33 = v28 + v31;
        v34 = (v31 - v32) ^ __ROR4__(v32, 24);
        v35 = v34 + v32 + v33;
        v36 = (v33 - v34) ^ __ROR4__(v34, 16);
        v37 = v32 + v33 - v36;
        v3 = v36 + v35;
        v38 = v37 ^ __ROR4__(v36, 13);
        v6 = v38 + v3;
        v5 = (v35 - v38) ^ __ROR4__(v38, 28);
      }
      while ( a2 > 0xC );
    }
    switch ( a2 )
    {
      case 1u:
        goto LABEL_27;
      case 2u:
        goto LABEL_32;
      case 3u:
        v3 += *((unsigned __int8 *)a1 + 2) << 16;
LABEL_32:
        v56 = *a1 + v3;
        goto LABEL_28;
      case 4u:
        goto LABEL_50;
      case 5u:
        v6 += *((unsigned __int8 *)a1 + 4);
LABEL_50:
        v56 = *a1 + v3 + (a1[1] << 16);
        goto LABEL_28;
      case 6u:
        goto LABEL_44;
      case 7u:
        v6 += *((unsigned __int8 *)a1 + 6) << 16;
LABEL_44:
        v56 = *a1 + v3 + (a1[1] << 16);
        v6 += a1[2];
        goto LABEL_28;
      case 8u:
        goto LABEL_46;
      case 9u:
        v5 += *((unsigned __int8 *)a1 + 8);
LABEL_46:
        v6 += a1[2] + (a1[3] << 16);
        v56 = *a1 + v3 + (a1[1] << 16);
        goto LABEL_28;
      case 0xAu:
        goto LABEL_48;
      case 0xBu:
        v5 += *((unsigned __int8 *)a1 + 10) << 16;
LABEL_48:
        v6 += a1[2] + (a1[3] << 16);
        v56 = *a1 + v3 + (a1[1] << 16);
        v5 += a1[4];
        goto LABEL_28;
      case 0xCu:
        v5 += a1[4] + (a1[5] << 16);
        v6 += a1[2] + (a1[3] << 16);
        v56 = *a1 + v3 + (a1[1] << 16);
        goto LABEL_28;
      default:
        return v5;
    }
  }
  if ( a2 > 0xC )
  {
    v39 = a1 + 6;
    v5 = a3 - 559038737 + a2;
    v6 = v5;
    do
    {
      v40 = *((unsigned __int8 *)v39 - 2);
      a2 -= 12;
      v41 = *((unsigned __int8 *)v39 - 10);
      v42 = *((unsigned __int8 *)v39 - 3);
      a1 = v39;
      v43 = *((unsigned __int8 *)v39 - 11);
      v39 += 6;
      v44 = (v40 << 16) + (v42 << 8) + *((unsigned __int8 *)v39 - 16) + (*((unsigned __int8 *)v39 - 13) << 24) + v5;
      v45 = ((v41 << 16)
           + (v43 << 8)
           + *((unsigned __int8 *)v39 - 24)
           + (*((unsigned __int8 *)v39 - 21) << 24)
           - v44
           + v3) ^ __ROR4__(v44, 28);
      v46 = (*((unsigned __int8 *)v39 - 18) << 16)
          + (*((unsigned __int8 *)v39 - 19) << 8)
          + *((unsigned __int8 *)v39 - 20)
          + (*((unsigned __int8 *)v39 - 17) << 24)
          + v6;
      v47 = v46 - v45;
      v48 = v46 + v44;
      v49 = v47 ^ __ROR4__(v45, 26);
      v50 = v45 + v48;
      v51 = (v48 - v49) ^ __ROR4__(v49, 24);
      v52 = v51 + v49 + v50;
      v53 = (v50 - v51) ^ __ROR4__(v51, 16);
      v54 = v49 + v50 - v53;
      v3 = v53 + v52;
      v55 = v54 ^ __ROR4__(v53, 13);
      v6 = v55 + v3;
      v5 = (v52 - v55) ^ __ROR4__(v55, 28);
    }
    while ( a2 > 0xC );
  }
  else
  {
    v5 = a3 - 559038737 + a2;
    v6 = v5;
  }
  switch ( a2 )
  {
    case 1u:
      goto LABEL_27;
    case 2u:
      goto LABEL_26;
    case 3u:
      goto LABEL_25;
    case 4u:
      goto LABEL_24;
    case 5u:
      goto LABEL_23;
    case 6u:
      goto LABEL_22;
    case 7u:
      goto LABEL_21;
    case 8u:
      goto LABEL_20;
    case 9u:
      goto LABEL_19;
    case 0xAu:
      goto LABEL_18;
    case 0xBu:
      goto LABEL_17;
    case 0xCu:
      v5 += *((unsigned __int8 *)a1 + 11) << 24;
LABEL_17:
      v5 += *((unsigned __int8 *)a1 + 10) << 16;
LABEL_18:
      v5 += *((unsigned __int8 *)a1 + 9) << 8;
LABEL_19:
      v5 += *((unsigned __int8 *)a1 + 8);
LABEL_20:
      v6 += *((unsigned __int8 *)a1 + 7) << 24;
LABEL_21:
      v6 += *((unsigned __int8 *)a1 + 6) << 16;
LABEL_22:
      v6 += *((unsigned __int8 *)a1 + 5) << 8;
LABEL_23:
      v6 += *((unsigned __int8 *)a1 + 4);
LABEL_24:
      v3 += *((unsigned __int8 *)a1 + 3) << 24;
LABEL_25:
      v3 += *((unsigned __int8 *)a1 + 2) << 16;
LABEL_26:
      v3 += *((unsigned __int8 *)a1 + 1) << 8;
LABEL_27:
      v56 = *(unsigned __int8 *)a1 + v3;
LABEL_28:
      v57 = (v5 ^ v6) - __ROR4__(v6, 18);
      v58 = (v56 ^ v57) - __ROR4__(v57, 21);
      v59 = (v6 ^ v58) - __ROR4__(v58, 7);
      v60 = (v57 ^ v59) - __ROR4__(v59, 16);
      v61 = (v58 ^ v60) - __ROR4__(v60, 28);
      v62 = (v59 ^ v61) - __ROR4__(v61, 18);
      v5 = (v60 ^ v62) - __ROR4__(v62, 8);
      break;
    default:
      return v5;
  }
  return v5;
}
// 4B3A4: control flows out of bounds to 4B3A8
// 4B48C: control flows out of bounds to 4B490
// 4B5B0: control flows out of bounds to 4B5B4

//----- (0004B838) --------------------------------------------------------
int __fastcall sub_4B838(int a1, int *a2, char *s2, int a4)
{
  int v4; // r4

  v4 = *a2;
  if ( *a2 == a1 + 12 && v4 == a2[1] )
    return 0;
  while ( *(_DWORD *)(v4 + 16) != a4 || strcmp((const char *)(v4 + 24), s2) )
  {
    if ( a2[1] == v4 )
      return 0;
    v4 = *(_DWORD *)(v4 + 4);
  }
  return v4;
}

//----- (0004B8AC) --------------------------------------------------------
int __fastcall sub_4B8AC(int result)
{
  int v1; // r6
  int v2; // r4
  _DWORD *v3; // r0
  int v4; // r5
  unsigned int *v5; // r3
  unsigned int v6; // r2
  unsigned int v7; // r2
  int v8; // r0

  v1 = result + 12;
  v2 = *(_DWORD *)(result + 16);
  if ( v2 != result + 12 )
  {
    do
    {
      v3 = *(_DWORD **)(v2 + 20);
      v4 = *(_DWORD *)(v2 + 4);
      if ( v3 )
      {
        v5 = v3 + 1;
        if ( v3[1] != -1 )
        {
          __dmb(0xBu);
          do
          {
            v6 = __ldrex(v5);
            v7 = v6 - 1;
          }
          while ( __strex(v7, v5) );
          if ( !v7 )
            sub_4EB6C(v3);
        }
      }
      v8 = v2;
      v2 = v4;
      result = sub_4D898(v8);
    }
    while ( v4 != v1 );
  }
  return result;
}

//----- (0004B91C) --------------------------------------------------------
int __fastcall sub_4B91C(_DWORD *a1)
{
  _DWORD *v2; // r0
  int v3; // r12
  _DWORD *v4; // r3
  _DWORD *v5; // r2

  *a1 = 0;
  a1[2] = 3;
  v2 = (_DWORD *)sub_4D880(64);
  a1[1] = v2;
  if ( !v2 )
    return -1;
  v3 = a1[2];
  v4 = a1 + 3;
  a1[4] = a1 + 3;
  a1[3] = a1 + 3;
  a1[6] = a1 + 5;
  a1[5] = a1 + 5;
  if ( 1 << v3 )
  {
    v5 = (_DWORD *)((char *)v2 + (8 << v3));
    do
    {
      v2[1] = v4;
      *v2 = v4;
      v2 += 2;
    }
    while ( v2 != v5 );
  }
  return 0;
}

//----- (0004B998) --------------------------------------------------------
int __fastcall sub_4B998(int a1)
{
  sub_4B8AC(a1);
  return sub_4D898(*(_DWORD *)(a1 + 4));
}

//----- (0004B9B0) --------------------------------------------------------
int __fastcall sub_4B9B0(int *a1, char *a2, int a3)
{
  int v4; // r8
  int v7; // r8
  int v8; // r5
  int *v9; // r1
  int **v10; // r3
  int *v11; // r3
  int v12; // r8
  int v13; // lr
  int *v14; // r12
  int v15; // r0
  int *v16; // r2
  int **v17; // r0
  int v18; // r2
  unsigned int v19; // r10
  int v20; // r9
  int *v21; // r5
  int v22; // r0
  int v23; // r8
  _DWORD *v24; // r0
  unsigned int *v25; // r3
  unsigned int v26; // r2
  unsigned int v27; // r2
  int result; // r0
  int v29; // r0
  int *v30; // r8
  int *v31; // r3
  int v32; // r2
  int v33; // r1
  int v34; // r3

  v4 = a1[2];
  if ( (unsigned int)*a1 >> v4 )
  {
    v7 = v4 + 1;
    v8 = sub_4D880(8 << v7);
    if ( !v8 )
      return -1;
    sub_4D898(a1[1]);
    a1[1] = v8;
    a1[2] = v7;
    v9 = a1 + 3;
    if ( 1 << v7 )
    {
      v10 = (int **)v8;
      do
      {
        v10[1] = v9;
        *v10 = v9;
        v10 += 2;
      }
      while ( (int **)((8 << v7) + v8) != v10 );
    }
    v11 = (int *)a1[4];
    a1[3] = (int)v9;
    v12 = ~(-1 << v7);
    a1[4] = (int)v9;
    if ( v11 != v9 )
    {
      do
      {
        while ( 1 )
        {
          v14 = (int *)v11[1];
          v15 = v11[4] & v12;
          v16 = *(int **)(v8 + 8 * v15);
          v17 = (int **)(v8 + 8 * v15);
          if ( v16 == v9 && v9 == v17[1] )
            break;
          v13 = *v16;
          v11[1] = (int)v16;
          *v11 = v13;
          *(_DWORD *)(*v16 + 4) = v11;
          *v16 = (int)v11;
          *v17 = v11;
          v11 = v14;
          if ( v14 == v9 )
            goto LABEL_12;
        }
        v18 = a1[3];
        v11[1] = (int)v9;
        *v11 = v18;
        *(_DWORD *)(a1[3] + 4) = v11;
        a1[3] = (int)v11;
        v17[1] = v11;
        *v17 = v11;
        v11 = v14;
      }
      while ( v14 != v9 );
LABEL_12:
      v8 = a1[1];
      v12 = ~(-1 << a1[2]);
    }
  }
  else
  {
    v8 = a1[1];
    v12 = ~(-1 << v4);
  }
  v19 = strlen(a2);
  v20 = sub_4B2F4((unsigned __int16 *)a2, v19, dword_5051C0);
  v21 = (int *)(v8 + 8 * (v12 & v20));
  v22 = sub_4B838((int)a1, v21, a2, v20);
  v23 = v22;
  if ( v22 )
  {
    v24 = *(_DWORD **)(v22 + 20);
    if ( v24 && v24[1] != -1 )
    {
      v25 = v24 + 1;
      __dmb(0xBu);
      do
      {
        v26 = __ldrex(v25);
        v27 = v26 - 1;
      }
      while ( __strex(v27, v25) );
      if ( !v27 )
        sub_4EB6C(v24);
    }
    *(_DWORD *)(v23 + 20) = a3;
    return 0;
  }
  v29 = sub_4D880(v19 + 25);
  v30 = (int *)v29;
  if ( !v29 )
    return -1;
  *(_DWORD *)(v29 + 16) = v20;
  strncpy((char *)(v29 + 24), a2, v19 + 1);
  v31 = (int *)*v21;
  v32 = (int)(v30 + 2);
  v30[5] = a3;
  v30[1] = (int)v30;
  *v30 = (int)v30;
  v30[3] = (int)(v30 + 2);
  v30[2] = (int)(v30 + 2);
  if ( v31 == a1 + 3 && v31 == (int *)v21[1] )
  {
    *v30 = a1[3];
    v30[1] = (int)v31;
    *(_DWORD *)(a1[3] + 4) = v30;
    a1[3] = (int)v30;
    v21[1] = (int)v30;
    *v21 = (int)v30;
  }
  else
  {
    *v30 = *v31;
    v30[1] = (int)v31;
    *(_DWORD *)(*v31 + 4) = v30;
    *v31 = (int)v30;
    *v21 = (int)v30;
  }
  v33 = a1[5];
  v34 = *a1;
  result = 0;
  v30[3] = (int)(a1 + 5);
  v30[2] = v33;
  *(_DWORD *)(a1[5] + 4) = v32;
  a1[5] = v32;
  *a1 = v34 + 1;
  return result;
}
// 5051C0: using guessed type int dword_5051C0;

//----- (0004BC44) --------------------------------------------------------
int __fastcall sub_4BC44(int a1, char *s)
{
  unsigned int v4; // r0
  int v5; // r0
  int result; // r0

  v4 = strlen(s);
  v5 = sub_4B2F4((unsigned __int16 *)s, v4, dword_5051C0);
  result = sub_4B838(a1, (int *)(*(_DWORD *)(a1 + 4) + 8 * (v5 & ~(-1 << *(_DWORD *)(a1 + 8)))), s, v5);
  if ( result )
    return *(_DWORD *)(result + 20);
  return result;
}
// 5051C0: using guessed type int dword_5051C0;

//----- (0004BCA4) --------------------------------------------------------
int __fastcall sub_4BCA4(_DWORD *a1, char *s)
{
  unsigned int v4; // r0
  int v5; // r0
  int v6; // r9
  int v7; // r5
  int *v8; // r7
  int *v9; // r0
  int v10; // r4
  int *v11; // r1
  int v12; // r2
  int v13; // r3
  int *v14; // r1
  int v15; // r2
  _DWORD *v16; // r0
  int v17; // r3
  int result; // r0
  unsigned int *v19; // r3
  unsigned int v20; // r2
  unsigned int v21; // r2
  bool v22; // zf

  v4 = strlen(s);
  v5 = sub_4B2F4((unsigned __int16 *)s, v4, dword_5051C0);
  v6 = a1[1];
  v7 = v5 & ~(-1 << a1[2]);
  v8 = (int *)(v6 + 8 * v7);
  v9 = (int *)sub_4B838((int)a1, v8, s, v5);
  v10 = (int)v9;
  if ( !v9 )
    return -1;
  v11 = (int *)v8[1];
  v12 = v9[1];
  v13 = *v9;
  if ( v9 == *(int **)(v6 + 8 * v7) )
  {
    v22 = v9 == v11;
    if ( v9 == v11 )
      v11 = a1 + 3;
    else
      *(_DWORD *)(v6 + 8 * v7) = v12;
    if ( v22 )
    {
      v8[1] = (int)v11;
      *(_DWORD *)(v6 + 8 * v7) = v11;
    }
  }
  else if ( v9 == v11 )
  {
    v8[1] = v13;
  }
  *(_DWORD *)(v13 + 4) = v12;
  v14 = (int *)v9[1];
  v15 = v9[3];
  v16 = (_DWORD *)v9[5];
  *v14 = v13;
  v17 = *(_DWORD *)(v10 + 8);
  *(_DWORD *)(v17 + 4) = v15;
  **(_DWORD **)(v10 + 12) = v17;
  if ( v16 && v16[1] != -1 )
  {
    v19 = v16 + 1;
    __dmb(0xBu);
    do
    {
      v20 = __ldrex(v19);
      v21 = v20 - 1;
    }
    while ( __strex(v21, v19) );
    if ( !v21 )
      sub_4EB6C(v16);
  }
  sub_4D898(v10);
  result = 0;
  --*a1;
  return result;
}
// 5051C0: using guessed type int dword_5051C0;

//----- (0004BDC4) --------------------------------------------------------
int __fastcall sub_4BDC4(_DWORD *a1)
{
  _DWORD *v2; // r2
  int result; // r0
  _DWORD *v4; // r3
  _DWORD *v5; // r1

  sub_4B8AC((int)a1);
  v2 = a1 + 3;
  result = a1[2];
  if ( 1 << result )
  {
    v4 = (_DWORD *)a1[1];
    v5 = (_DWORD *)((char *)v4 + (8 << result));
    do
    {
      v4[1] = v2;
      *v4 = v2;
      v4 += 2;
    }
    while ( v4 != v5 );
  }
  a1[4] = v2;
  a1[3] = v2;
  a1[6] = a1 + 5;
  a1[5] = a1 + 5;
  *a1 = 0;
  return result;
}

//----- (0004BE20) --------------------------------------------------------
int __fastcall sub_4BE20(int a1)
{
  if ( *(_DWORD *)(a1 + 24) == a1 + 20 )
    return 0;
  else
    return *(_DWORD *)(a1 + 24);
}

//----- (0004BE38) --------------------------------------------------------
int __fastcall sub_4BE38(int a1, char *s)
{
  unsigned int v4; // r0
  int v5; // r0
  int result; // r0

  v4 = strlen(s);
  v5 = sub_4B2F4((unsigned __int16 *)s, v4, dword_5051C0);
  result = sub_4B838(a1, (int *)(*(_DWORD *)(a1 + 4) + 8 * (v5 & ~(-1 << *(_DWORD *)(a1 + 8)))), s, v5);
  if ( result )
    result += 8;
  return result;
}
// 5051C0: using guessed type int dword_5051C0;

//----- (0004BE98) --------------------------------------------------------
int __fastcall sub_4BE98(int a1, int a2)
{
  if ( *(_DWORD *)(a2 + 4) == a1 + 20 )
    return 0;
  else
    return *(_DWORD *)(a2 + 4);
}

//----- (0004BEB0) --------------------------------------------------------
int __fastcall sub_4BEB0(int a1)
{
  return a1 + 16;
}

//----- (0004BEB8) --------------------------------------------------------
int __fastcall sub_4BEB8(int a1)
{
  return *(_DWORD *)(a1 + 12);
}

//----- (0004BEC0) --------------------------------------------------------
_DWORD *__fastcall sub_4BEC0(int a1, int a2)
{
  _DWORD *result; // r0
  unsigned int *v4; // r3
  unsigned int v5; // r2
  unsigned int v6; // r2

  result = *(_DWORD **)(a1 + 12);
  if ( !result )
    goto LABEL_6;
  if ( result[1] == -1 )
    goto LABEL_6;
  v4 = result + 1;
  __dmb(0xBu);
  do
  {
    v5 = __ldrex(v4);
    v6 = v5 - 1;
  }
  while ( __strex(v6, v4) );
  if ( v6 )
  {
LABEL_6:
    *(_DWORD *)(a1 + 12) = a2;
  }
  else
  {
    result = sub_4EB6C(result);
    *(_DWORD *)(a1 + 12) = a2;
  }
  return result;
}

//----- (0004BF2C) --------------------------------------------------------
int __fastcall sub_4BF2C(int result)
{
  int v1; // r1
  unsigned __int8 v2; // r2
  int v3; // r3
  int v4; // r0
  int v5; // r5
  ssize_t v6; // r7
  int v7; // r5
  struct timeval v8; // [sp+0h] [bp-20h] BYREF

  if ( !dword_5051C0 )
  {
    v1 = result;
    result = 1;
    do
      v2 = __ldrex((unsigned __int8 *)algn_5051C4);
    while ( __strex(1u, (unsigned __int8 *)algn_5051C4) );
    if ( v2 )
    {
      do
      {
        result = sched_yield();
        v3 = dword_5051C0;
        __dmb(0xBu);
      }
      while ( !v3 );
    }
    else
    {
      if ( !v1 )
      {
        v4 = open64("/dev/urandom");
        v5 = v4;
        if ( v4 == -1 || (v6 = read(v4, &v8, 4u), close(v5), v6 != 4) )
        {
          gettimeofday(&v8, 0);
          v7 = v8.tv_usec ^ v8.tv_sec;
          result = getpid();
          v1 = result ^ v7;
        }
        else
        {
          result = LOBYTE(v8.tv_sec);
          v1 = HIBYTE(v8.tv_sec) | ((BYTE2(v8.tv_sec) | ((BYTE1(v8.tv_sec) | (LOBYTE(v8.tv_sec) << 8)) << 8)) << 8);
        }
        if ( !v1 )
          v1 = 1;
      }
      __dmb(0xBu);
      dword_5051C0 = v1;
    }
  }
  return result;
}
// 12198: using guessed type int __fastcall open64(_DWORD);
// 5051C0: using guessed type int dword_5051C0;

//----- (0004C028) --------------------------------------------------------
int __fastcall sub_4C028(_DWORD *a1)
{
  int v1; // r2
  int v2; // r3
  bool v3; // zf

  v1 = a1[1];
  v2 = *(unsigned __int8 *)(*a1 + v1);
  v3 = v2 == 0;
  if ( *(_BYTE *)(*a1 + v1) )
    ++v1;
  else
    v2 = -1;
  if ( !v3 )
    a1[1] = v1;
  return v2;
}

//----- (0004C04C) --------------------------------------------------------
int __fastcall sub_4C04C(int a1)
{
  __int64 v1; // r2

  v1 = *(_QWORD *)(a1 + 4);
  if ( HIDWORD(v1) >= (unsigned int)v1 )
    return -1;
  LODWORD(v1) = HIDWORD(v1) + 1;
  HIDWORD(v1) = *(unsigned __int8 *)(*(_DWORD *)a1 + HIDWORD(v1));
  *(_DWORD *)(a1 + 8) = v1;
  return HIDWORD(v1);
}

//----- (0004C070) --------------------------------------------------------
int __fastcall sub_4C070(_DWORD *a1)
{
  unsigned int v1; // r3
  int (__fastcall *v3)(_DWORD *, int, _DWORD); // r3
  int v4; // r0
  int result; // r0

  v1 = a1[257];
  if ( v1 < a1[256] )
    goto LABEL_4;
  v3 = (int (__fastcall *)(_DWORD *, int, _DWORD))a1[258];
  a1[257] = 0;
  v4 = v3(a1, 1024, a1[259]);
  a1[256] = v4;
  if ( (unsigned int)(v4 - 1) <= 0xFFFFFFFD )
  {
    v1 = a1[257];
LABEL_4:
    result = *((unsigned __int8 *)a1 + v1);
    a1[257] = v1 + 1;
    return result;
  }
  return -1;
}

//----- (0004C0CC) --------------------------------------------------------
int sub_4C0CC(int result, _DWORD *a2, int a3, const char *a4, ...)
{
  int v4; // r6
  const char *v7; // r0
  int v8; // r8
  int v9; // r7
  int v10; // r9
  char *v11; // r3
  char s[160]; // [sp+18h] [bp-168h] BYREF
  char v13[159]; // [sp+B8h] [bp-C8h] BYREF
  char v14; // [sp+157h] [bp-29h]
  const char *varg_r3; // [sp+17Ch] [bp-4h]
  va_list va; // [sp+180h] [bp+0h] BYREF

  va_start(va, a4);
  varg_r3 = a4;
  v4 = result;
  if ( result )
  {
    vsnprintf(s, 0xA0u, varg_r3, va);
    s[159] = 0;
    if ( a2 )
    {
      v7 = (const char *)sub_4D9C8((int)(a2 + 10));
      v8 = a2[6];
      v9 = a2[7];
      v10 = a2[9];
      if ( v7 && *v7 )
      {
        if ( a2[11] <= 0x14u )
        {
          snprintf(v13, 0xA0u, "%s near '%s'", s, v7);
          v11 = v13;
          v14 = 0;
          return sub_4F95C(v4, v8, v9, v10, a3, "%s", v11);
        }
      }
      else
      {
        if ( a3 == 8 )
          a3 = 6;
        if ( a2[5] != -2 )
        {
          snprintf(v13, 0xA0u, "%s near end of file", s);
          v11 = v13;
          v14 = 0;
          return sub_4F95C(v4, v8, v9, v10, a3, "%s", v11);
        }
      }
      v11 = s;
    }
    else
    {
      v9 = -1;
      v11 = s;
      v10 = 0;
      v8 = -1;
    }
    return sub_4F95C(v4, v8, v9, v10, a3, "%s", v11);
  }
  return result;
}

//----- (0004C1FC) --------------------------------------------------------
int __fastcall sub_4C1FC(int *a1)
{
  if ( a1[15] != 256 )
    return sub_4D988(a1 + 10);
  sub_4D898(a1[16]);
  a1[16] = 0;
  a1[17] = 0;
  return sub_4D988(a1 + 10);
}

//----- (0004C23C) --------------------------------------------------------
int __fastcall sub_4C23C(int *a1)
{
  unsigned __int8 buf; // [sp+7h] [bp-9h] BYREF

  if ( read(*a1, &buf, 1u) == 1 )
    return buf;
  else
    return -1;
}

//----- (0004C268) --------------------------------------------------------
int __fastcall sub_4C268(_BYTE *a1)
{
  _BYTE *v1; // r3
  int result; // r0
  _BYTE *v3; // lr
  int v4; // r2
  int v5; // t1
  int v6; // r0
  int v7; // r1

  if ( *a1 != 117 )
    _assert_fail("str[0] == 'u'", "load.c", 0x135u, "decode_unicode_escape");
  v1 = a1;
  result = 0;
  v3 = v1 + 4;
  while ( 1 )
  {
    v5 = (unsigned __int8)*++v1;
    v4 = v5;
    v6 = 16 * result;
    v7 = v5 - 48;
    if ( (unsigned __int8)(v5 - 48) > 9u )
      break;
    result = v7 + v6;
LABEL_10:
    if ( v1 == v3 )
      return result;
  }
  if ( (unsigned int)(v4 - 97) <= 0x19 )
  {
    result = v4 - 87 + v6;
    goto LABEL_10;
  }
  if ( (unsigned int)(v4 - 65) <= 0x19 )
  {
    result = v4 - 55 + v6;
    goto LABEL_10;
  }
  return -1;
}

//----- (0004C2FC) --------------------------------------------------------
_DWORD *__fastcall sub_4C2FC(_DWORD *result, int a2)
{
  _DWORD *v2; // r4
  int v4; // r2
  int v5; // r3
  int v6; // r3

  if ( (unsigned int)(a2 + 2) > 1 )
  {
    v2 = result;
    --result[9];
    if ( a2 == 10 )
    {
      v4 = result[8];
      --result[6];
      result[7] = v4;
    }
    else
    {
      result = (_DWORD *)sub_4DE1C((unsigned __int8)a2);
      if ( result )
        --v2[7];
    }
    v5 = v2[4];
    if ( !v5 )
      _assert_fail("stream->buffer_pos > 0", "load.c", 0xEEu, "stream_unget");
    v6 = v5 - 1;
    v2[4] = v6;
    if ( *((unsigned __int8 *)v2 + v6 + 8) != a2 )
      _assert_fail("stream->buffer[stream->buffer_pos] == c", "load.c", 0xF0u, "stream_unget");
  }
  return result;
}

//----- (0004C3B8) --------------------------------------------------------
int __fastcall sub_4C3B8(int a1, int a2)
{
  int v2; // r2
  int v4; // r3
  int v5; // r6
  int v6; // r1
  int v8; // r0
  int v9; // r5
  int result; // r0
  int v11; // r3
  int v12; // r2
  unsigned int v13; // r0
  unsigned int v14; // r8
  _BYTE *v15; // r6
  _BYTE *v16; // r9
  int v17; // r2
  int arg; // [sp+0h] [bp-28h]

  v2 = *(_DWORD *)(a1 + 16);
  v4 = a1 + v2;
  v5 = *(unsigned __int8 *)(a1 + v2 + 8);
  if ( *(_BYTE *)(a1 + v2 + 8) )
  {
    v6 = v2 + 1;
    goto LABEL_8;
  }
  v8 = (*(int (__fastcall **)(_DWORD))a1)(*(_DWORD *)(a1 + 4));
  v9 = v8;
  if ( v8 == -1 )
  {
    *(_DWORD *)(a1 + 20) = -1;
    return v9;
  }
  *(_DWORD *)(a1 + 16) = v5;
  *(_BYTE *)(a1 + 8) = v8;
  if ( (unsigned int)(v8 - 128) <= 0x7F )
  {
    v13 = sub_4DE1C((unsigned __int8)v8);
    v14 = v13;
    if ( !v13 )
      goto LABEL_20;
    if ( v13 <= 1 )
      _assert_fail("count >= 2", "load.c", 0xBDu, "stream_get");
    v15 = (_BYTE *)(a1 + 9);
    v16 = (_BYTE *)(a1 + 8 + v13);
    do
      *v15++ = (*(int (__fastcall **)(_DWORD))a1)(*(_DWORD *)(a1 + 4));
    while ( v16 != v15 );
    if ( !sub_4DE88((char *)(a1 + 8), v14, 0) )
    {
LABEL_20:
      arg = v9;
      v9 = -2;
      *(_DWORD *)(a1 + 20) = -2;
      sub_4C0CC(a2, (_DWORD *)a1, 5, "unable to decode byte 0x%x", arg);
      return v9;
    }
    *(_BYTE *)(a1 + v14 + 8) = 0;
    v17 = *(_DWORD *)(a1 + 16);
    v6 = v17 + 1;
    v4 = a1 + v17;
  }
  else
  {
    v6 = 1;
    v4 = a1;
    *(_BYTE *)(a1 + 9) = v5;
  }
LABEL_8:
  *(_DWORD *)(a1 + 16) = v6;
  v9 = *(unsigned __int8 *)(v4 + 8);
  ++*(_DWORD *)(a1 + 36);
  if ( v9 != 10 )
  {
    if ( sub_4DE1C(v9) )
      ++*(_DWORD *)(a1 + 28);
    return v9;
  }
  v11 = *(_DWORD *)(a1 + 24);
  v12 = *(_DWORD *)(a1 + 28);
  result = 10;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 24) = v11 + 1;
  *(_DWORD *)(a1 + 32) = v12;
  return result;
}

//----- (0004C540) --------------------------------------------------------
int __fastcall sub_4C540(int a1, int a2)
{
  int v3; // r4

  v3 = *(_DWORD *)(a1 + 20);
  if ( !v3 )
    v3 = sub_4C3B8(a1, a2);
  if ( (unsigned int)(v3 + 2) > 1 )
    sub_4DAB0((const void **)(a1 + 40), v3);
  return v3;
}

//----- (0004C580) --------------------------------------------------------
_DWORD *__fastcall sub_4C580(_DWORD *result, int a2)
{
  _DWORD *v2; // r5
  char v4; // r1
  int v5; // r2

  if ( (unsigned int)(a2 + 2) > 1 )
  {
    v2 = result;
    sub_4C2FC(result, a2);
    result = (_DWORD *)sub_4DAD4(v2 + 10, v4, v5);
    if ( result != (_DWORD *)a2 )
      _assert_fail("c == d", "load.c", 0x11Au, "lex_unget_unsave");
  }
  return result;
}
// 4C5A0: variable 'v4' is possibly undefined
// 4C5A0: variable 'v5' is possibly undefined

//----- (0004C5CC) --------------------------------------------------------
unsigned int __fastcall sub_4C5CC(_DWORD *a1, int a2)
{
  const void **v2; // r7
  unsigned int v5; // r4
  bool v6; // cc
  int v7; // r3
  int v8; // r4
  bool v9; // zf
  _BOOL4 v10; // r2
  bool v11; // cc
  int v12; // r0
  const char *v13; // r4
  unsigned int result; // r0
  int v15; // r1
  int v16; // r0
  unsigned int v17; // r4
  int v18; // r0
  bool v19; // zf
  int v20; // r0
  bool v21; // zf
  const char *v22; // r4
  int *v23; // r7
  __int64 v24; // r0
  char i; // r1
  int v26; // r3
  int v27; // r2
  double v28; // r2
  int v29; // r8
  unsigned int v30; // r3
  unsigned int v31; // r4
  bool v32; // cc
  int v33; // r1
  _BYTE *v34; // r8
  unsigned __int8 *j; // r4
  int v36; // r3
  unsigned int v37; // r3
  int v38; // r0
  int v39; // r11
  int v40; // r0
  int v41; // r1
  int v42; // r0
  int v43; // r2
  const char *v44; // r3
  const char *v45; // r3
  unsigned __int8 *arg; // [sp+0h] [bp-40h]
  int v47; // [sp+Ch] [bp-34h]
  double endptr[6]; // [sp+10h] [bp-30h] BYREF

  v2 = (const void **)(a1 + 10);
  sub_4D9B4((int)(a1 + 10));
  if ( a1[15] == 256 )
  {
    sub_4D898(a1[16]);
    a1[16] = 0;
    a1[17] = 0;
  }
  do
  {
    v5 = a1[5];
    if ( !v5 )
      v5 = sub_4C3B8((int)a1, a2);
    v6 = v5 > 0x20;
    if ( v5 != 32 )
      v6 = v5 - 9 > 1;
    v7 = !v6;
  }
  while ( !v6 || v5 == 13 );
  if ( v5 == -1 )
  {
    a1[15] = v7;
    return v7;
  }
  if ( v5 == -2 )
    goto LABEL_35;
  sub_4DAB0(v2, v5);
  if ( (((v5 & 0xFFFFFFDF) - 91) & 0xFFFFFFFD) == 0 )
    goto LABEL_38;
  v9 = v5 == 44;
  if ( v5 != 44 )
    v9 = v5 == 58;
  v10 = v9;
  if ( v9 )
    goto LABEL_38;
  if ( v5 != 34 )
  {
    v11 = v5 > 0x2D;
    if ( v5 != 45 )
      v11 = v5 - 48 > 9;
    if ( !v11 )
    {
      a1[15] = -1;
      if ( v5 == 45 )
      {
        v42 = sub_4C540((int)a1, a2);
        v41 = v42;
        if ( v42 != 48 )
        {
          if ( (unsigned int)(v42 - 48) > 9 )
            goto LABEL_118;
          goto LABEL_58;
        }
      }
      else if ( v5 != 48 )
      {
        do
LABEL_58:
          v20 = sub_4C540((int)a1, a2);
        while ( (unsigned int)(v20 - 48) <= 9 );
        goto LABEL_59;
      }
      v20 = sub_4C540((int)a1, a2);
      if ( (unsigned int)(v20 - 48) <= 9 )
      {
LABEL_117:
        v41 = v20;
LABEL_118:
        sub_4C580(a1, v41);
        return a1[15];
      }
LABEL_59:
      if ( (a1[13] & 8) != 0 )
        goto LABEL_70;
      v21 = v20 == 46;
      if ( v20 != 46 )
        v21 = v20 == 69;
      if ( v21 )
      {
LABEL_70:
        if ( v20 == 46 )
        {
          v33 = a1[5];
          if ( !v33 )
            v33 = sub_4C3B8((int)a1, a2);
          if ( (unsigned int)(v33 - 48) > 9 )
          {
            sub_4C2FC(a1, v33);
            return a1[15];
          }
          sub_4DAB0(v2, v33);
          do
            v20 = sub_4C540((int)a1, a2);
          while ( (unsigned int)(v20 - 48) <= 9 );
        }
        if ( (v20 & 0xFFFFFFDF) != 69 )
          goto LABEL_72;
      }
      else if ( v20 != 101 )
      {
        sub_4C580(a1, v20);
        v22 = (const char *)sub_4D9C8((int)v2);
        v23 = _errno_location();
        *v23 = 0;
        v24 = strtoll(v22, (char **)endptr, 10);
        if ( *v23 == 34 )
        {
          if ( v24 >= 0 )
            LOWORD(v45) = -22764;
          else
            LOWORD(v45) = -22792;
          HIWORD(v45) = 6;
          sub_4C0CC(a2, a1, 15, v45);
          return a1[15];
        }
        else
        {
          if ( (const char *)LODWORD(endptr[0]) != &v22[a1[11]] )
            _assert_fail("end == saved_text + lex->saved_text.length", "load.c", 0x21Du, "lex_scan_number");
          v8 = 257;
          *((_QWORD *)a1 + 8) = v24;
          a1[15] = 257;
        }
        return v8;
      }
      v20 = sub_4C540((int)a1, a2);
      if ( ((v20 - 43) & 0xFFFFFFFD) == 0 )
        v20 = sub_4C540((int)a1, a2);
      if ( (unsigned int)(v20 - 48) <= 9 )
      {
        do
          v20 = sub_4C540((int)a1, a2);
        while ( (unsigned int)(v20 - 48) <= 9 );
LABEL_72:
        sub_4C580(a1, v20);
        if ( sub_4DB00((int)v2, endptr) )
        {
          sub_4C0CC(a2, a1, 15, "real number overflow");
          return a1[15];
        }
        else
        {
          v28 = endptr[0];
          v8 = 258;
          a1[15] = 258;
          *((double *)a1 + 8) = v28;
        }
        return v8;
      }
      goto LABEL_117;
    }
    if ( (v5 & 0xFFFFFFDF) - 65 <= 0x19 )
    {
      do
        v12 = sub_4C540((int)a1, a2);
      while ( (v12 & 0xFFFFFFDF) - 65 <= 0x19 );
      sub_4C580(a1, v12);
      v13 = (const char *)sub_4D9C8((int)v2);
      if ( !strcmp(v13, "true") )
      {
        v8 = 259;
        a1[15] = 259;
        return v8;
      }
      if ( strcmp(v13, "false") )
      {
        if ( !strcmp(v13, "null") )
        {
          v8 = 261;
          a1[15] = 261;
          return v8;
        }
        goto LABEL_35;
      }
      v5 = 260;
LABEL_38:
      result = v5;
      a1[15] = v5;
      return result;
    }
    for ( i = *((_BYTE *)a1 + a1[4] + 8); i; i = *((_BYTE *)a1 + v26 + 8) )
    {
      sub_4DAB0(v2, i);
      v26 = a1[4] + 1;
      v27 = a1[9] + 1;
      a1[4] = v26;
      a1[9] = v27;
    }
LABEL_35:
    v8 = -1;
    a1[15] = -1;
    return v8;
  }
  a1[16] = v10;
  a1[15] = -1;
LABEL_40:
  v15 = a2;
  v16 = (int)a1;
  while ( 1 )
  {
    v17 = sub_4C540(v16, v15);
LABEL_42:
    if ( v17 == 34 )
    {
      v34 = (_BYTE *)sub_4D880(a1[11] + 1);
      if ( !v34 )
        goto LABEL_55;
      a1[16] = v34;
      for ( j = (unsigned __int8 *)(sub_4D9C8((int)v2) + 1); ; j += 2 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            v36 = *j;
            if ( v36 == 34 )
            {
              *v34 = 0;
              v8 = 256;
              v43 = a1[16];
              a1[15] = 256;
              a1[17] = &v34[-v43];
              return v8;
            }
            if ( v36 == 92 )
              break;
            *v34 = v36;
            ++j;
            ++v34;
          }
          v37 = j[1];
          if ( v37 != 117 )
            break;
          v38 = sub_4C268(j + 1);
          v39 = v38;
          if ( v38 < 0 )
          {
            LOWORD(v44) = (unsigned __int16)"invalid Unicode escape '%.6s'";
            arg = j;
LABEL_138:
            HIWORD(v44) = (unsigned int)"invalid Unicode escape '%.6s'" >> 16;
            sub_4C0CC(a2, a1, 8, v44, arg);
            goto LABEL_55;
          }
          v47 = v38 - 55296;
          if ( (unsigned int)(v38 - 55296) >= 0x400 )
          {
            if ( (unsigned int)(v38 - 56320) < 0x400 )
              goto LABEL_142;
            j += 6;
          }
          else
          {
            if ( j[6] != 92 || j[7] != 117 )
            {
LABEL_142:
              sub_4C0CC(a2, a1, 8, "invalid Unicode '\\u%04X'", v38);
              goto LABEL_55;
            }
            v40 = sub_4C268(j + 7);
            if ( v40 < 0 )
            {
              LOWORD(v44) = -22884;
              arg = j + 6;
              goto LABEL_138;
            }
            j += 12;
            if ( (unsigned int)(v40 - 56320) >= 0x400 )
            {
              sub_4C0CC(a2, a1, 8, "invalid Unicode '\\u%04X\\u%04X'", v39, v40);
              goto LABEL_55;
            }
            v39 = v40 - 56320 + (v47 << 10) + 0x10000;
          }
          if ( sub_4DD30(v39, v34, endptr) )
            _assert_fail("0", "load.c", 0x1C4u, "lex_scan_string");
          v34 += LODWORD(endptr[0]);
        }
        if ( v37 == 98 )
        {
          *v34 = 8;
        }
        else
        {
          if ( v37 <= 0x62 )
          {
            if ( v37 != 47 && v37 != 92 && v37 != 34 )
LABEL_130:
              _assert_fail("0", "load.c", 0x1D0u, "lex_scan_string");
            goto LABEL_125;
          }
          if ( v37 == 110 )
          {
            *v34 = 10;
          }
          else
          {
            if ( v37 <= 0x6E )
            {
              if ( v37 != 102 )
                goto LABEL_130;
              LOBYTE(v37) = 12;
LABEL_125:
              *v34 = v37;
              goto LABEL_106;
            }
            if ( v37 == 114 )
            {
              *v34 = 13;
            }
            else
            {
              if ( v37 != 116 )
                goto LABEL_130;
              *v34 = 9;
            }
          }
        }
LABEL_106:
        ++v34;
      }
    }
    if ( v17 == -2 )
      goto LABEL_55;
    if ( v17 == -1 )
    {
      sub_4C0CC(a2, a1, 6, "premature end of input");
      goto LABEL_55;
    }
    if ( v17 <= 0x1F )
      break;
    v15 = a2;
    v16 = (int)a1;
    if ( v17 == 92 )
    {
      v18 = sub_4C540((int)a1, a2);
      if ( v18 == 117 )
      {
        v29 = 4;
        v17 = sub_4C540((int)a1, a2);
        while ( 1 )
        {
          v30 = v17 & 0xFFFFFFDF;
          v31 = v17 - 48;
          v30 -= 65;
          v32 = v30 > 5;
          if ( v30 > 5 )
            v32 = v31 > 9;
          if ( v32 )
            break;
          --v29;
          v17 = sub_4C540((int)a1, a2);
          if ( !v29 )
            goto LABEL_42;
        }
LABEL_54:
        sub_4C0CC(a2, a1, 8, "invalid escape");
        goto LABEL_55;
      }
      v19 = v18 == 92;
      if ( v18 != 92 )
        v19 = (v18 & 0xFFFFFFBF) == 34;
      if ( !v19 && v18 != 47 && (v18 & 0xFFFFFFF7) != 102 && ((v18 - 114) & 0xFFFFFFFD) != 0 )
        goto LABEL_54;
      goto LABEL_40;
    }
  }
  sub_4C580(a1, v17);
  if ( v17 == 10 )
    sub_4C0CC(a2, a1, 8, "unexpected newline");
  else
    sub_4C0CC(a2, a1, 8, "control character 0x%x", v17);
LABEL_55:
  sub_4D898(a1[16]);
  v8 = a1[15];
  a1[16] = 0;
  a1[17] = 0;
  return v8;
}

//----- (0004CDE4) --------------------------------------------------------
_DWORD *__fastcall sub_4CDE4(int a1, int a2, int a3)
{
  unsigned int v5; // r3
  int v6; // r3
  _DWORD *v7; // r6
  _BYTE *v10; // r7
  size_t v11; // r9
  int v12; // r3
  char *v13; // r7
  unsigned int v14; // r2
  _DWORD *v15; // r2
  int v16; // r3
  unsigned int *v17; // r3
  unsigned int v18; // r2
  unsigned int v19; // r2
  int v20; // r3
  int v21; // r3
  _DWORD *v22; // r1
  unsigned int *v23; // r3
  unsigned int v24; // r2
  _DWORD *v25; // r0

  v5 = *(_DWORD *)(a1 + 56) + 1;
  *(_DWORD *)(a1 + 56) = v5;
  if ( v5 > 0x800 )
  {
    v7 = 0;
    sub_4C0CC(a3, (_DWORD *)a1, 2, "maximum parsing depth reached");
    return v7;
  }
  v6 = *(_DWORD *)(a1 + 60);
  if ( v6 == 257 )
  {
    v7 = (_DWORD *)sub_4E990(*(_QWORD *)(a1 + 64));
    goto LABEL_9;
  }
  if ( v6 <= 257 )
  {
    if ( v6 == 91 )
    {
      v7 = sub_4E540();
      if ( !v7 )
        return 0;
      sub_4C5CC((_DWORD *)a1, a3);
      v20 = *(_DWORD *)(a1 + 60);
      if ( v20 == 93 )
        goto LABEL_10;
      if ( v20 )
      {
        while ( 1 )
        {
          v22 = (_DWORD *)sub_4CDE4(a1, a2, a3);
          if ( !v22 || sub_4F494(v7, v22) )
            break;
          sub_4C5CC((_DWORD *)a1, a3);
          v21 = *(_DWORD *)(a1 + 60);
          if ( v21 != 44 )
          {
            if ( v21 == 93 )
              goto LABEL_10;
            goto LABEL_62;
          }
          sub_4C5CC((_DWORD *)a1, a3);
          if ( !*(_DWORD *)(a1 + 60) )
            goto LABEL_62;
        }
      }
      else
      {
LABEL_62:
        sub_4C0CC(a3, (_DWORD *)a1, 8, "']' expected");
      }
      if ( v7[1] == -1 )
        return 0;
      v23 = v7 + 1;
      __dmb(0xBu);
      do
      {
        v24 = __ldrex(v23);
        v19 = v24 - 1;
      }
      while ( __strex(v19, v23) );
    }
    else
    {
      if ( v6 <= 91 )
      {
        if ( v6 == -1 )
        {
          v7 = 0;
          sub_4C0CC(a3, (_DWORD *)a1, 8, "invalid token");
          return v7;
        }
        goto LABEL_57;
      }
      if ( v6 != 123 )
      {
        if ( v6 != 256 )
          goto LABEL_57;
        v10 = *(_BYTE **)(a1 + 64);
        v11 = *(_DWORD *)(a1 + 68);
        if ( (a2 & 0x10) == 0 && memchr(*(char **)(a1 + 64), 0, *(_DWORD *)(a1 + 68)) )
        {
          v7 = 0;
          sub_4C0CC(a3, (_DWORD *)a1, 11, "\\u0000 is not allowed without JSON_ALLOW_NUL");
          return v7;
        }
        v7 = sub_4E6F8(v10, v11);
        *(_DWORD *)(a1 + 64) = 0;
        *(_DWORD *)(a1 + 68) = 0;
        goto LABEL_9;
      }
      v7 = sub_4E1B0();
      if ( !v7 )
        return 0;
      sub_4C5CC((_DWORD *)a1, a3);
      v12 = *(_DWORD *)(a1 + 60);
      if ( v12 == 125 )
        goto LABEL_10;
      if ( v12 == 256 )
      {
        v13 = *(char **)(a1 + 64);
        v14 = *(_DWORD *)(a1 + 68);
        *(_DWORD *)(a1 + 64) = 0;
        *(_DWORD *)(a1 + 68) = 0;
        if ( !v13 )
          return 0;
        while ( 1 )
        {
          if ( memchr(v13, 0, v14) )
          {
            sub_4D898((int)v13);
            sub_4C0CC(a3, (_DWORD *)a1, 13, "NUL byte in object key not supported");
            goto LABEL_36;
          }
          if ( (a2 & 1) != 0 && sub_4E234(v7, v13) )
          {
            sub_4D898((int)v13);
            sub_4C0CC(a3, (_DWORD *)a1, 14, "duplicate object key");
            goto LABEL_36;
          }
          sub_4C5CC((_DWORD *)a1, a3);
          if ( *(_DWORD *)(a1 + 60) != 58 )
          {
            sub_4D898((int)v13);
            sub_4C0CC(a3, (_DWORD *)a1, 8, "':' expected");
            goto LABEL_36;
          }
          sub_4C5CC((_DWORD *)a1, a3);
          v15 = (_DWORD *)sub_4CDE4(a1, a2, a3);
          if ( !v15 || sub_4EE2C(v7, v13, v15) )
          {
            sub_4D898((int)v13);
            goto LABEL_36;
          }
          sub_4D898((int)v13);
          sub_4C5CC((_DWORD *)a1, a3);
          v16 = *(_DWORD *)(a1 + 60);
          if ( v16 != 44 )
            break;
          sub_4C5CC((_DWORD *)a1, a3);
          if ( *(_DWORD *)(a1 + 60) != 256 )
            goto LABEL_63;
          v13 = *(char **)(a1 + 64);
          v14 = *(_DWORD *)(a1 + 68);
          *(_DWORD *)(a1 + 64) = 0;
          *(_DWORD *)(a1 + 68) = 0;
          if ( !v13 )
            return 0;
        }
        if ( v16 == 125 )
          goto LABEL_10;
        sub_4C0CC(a3, (_DWORD *)a1, 8, "'}' expected");
      }
      else
      {
LABEL_63:
        sub_4C0CC(a3, (_DWORD *)a1, 8, "string or '}' expected");
      }
LABEL_36:
      if ( v7[1] == -1 )
        return 0;
      v17 = v7 + 1;
      __dmb(0xBu);
      do
      {
        v18 = __ldrex(v17);
        v19 = v18 - 1;
      }
      while ( __strex(v19, v17) );
    }
    if ( !v19 )
    {
      v25 = v7;
      v7 = 0;
      sub_4EB6C(v25);
      return v7;
    }
    return 0;
  }
  if ( v6 == 259 )
  {
    v7 = sub_4EB48();
  }
  else if ( v6 < 259 )
  {
    v7 = (_DWORD *)sub_4EA14();
  }
  else
  {
    if ( v6 != 260 )
    {
      if ( v6 == 261 )
      {
        v7 = sub_4EB60();
        goto LABEL_9;
      }
LABEL_57:
      v7 = 0;
      sub_4C0CC(a3, (_DWORD *)a1, 8, "unexpected token");
      return v7;
    }
    v7 = sub_4EB54();
  }
LABEL_9:
  if ( v7 )
  {
LABEL_10:
    --*(_DWORD *)(a1 + 56);
    return v7;
  }
  return 0;
}

//----- (0004D288) --------------------------------------------------------
_DWORD *__fastcall sub_4D288(_DWORD *a1, int a2, int a3)
{
  _DWORD *v6; // r7
  unsigned int *v8; // r3
  unsigned int v9; // r2
  unsigned int v10; // r2
  _DWORD *v11; // r0

  a1[14] = 0;
  sub_4C5CC(a1, a3);
  v6 = (_DWORD *)(a2 & 4);
  if ( (a2 & 4) == 0 && (a1[15] & 0xFFFFFFDF) != 91 )
  {
    sub_4C0CC(a3, a1, 8, "'[' or '{' expected");
    return v6;
  }
  v6 = sub_4CDE4((int)a1, a2, a3);
  if ( v6 )
  {
    if ( (a2 & 2) != 0 || (sub_4C5CC(a1, a3), !a1[15]) )
    {
      if ( a3 )
        *(_DWORD *)(a3 + 8) = a1[9];
      return v6;
    }
    sub_4C0CC(a3, a1, 7, "end of file expected");
    if ( v6[1] != -1 )
    {
      v8 = v6 + 1;
      __dmb(0xBu);
      do
      {
        v9 = __ldrex(v8);
        v10 = v9 - 1;
      }
      while ( __strex(v10, v8) );
      if ( !v10 )
      {
        v11 = v6;
        v6 = 0;
        sub_4EB6C(v11);
        return v6;
      }
    }
  }
  return 0;
}

//----- (0004D38C) --------------------------------------------------------
_DWORD *__fastcall sub_4D38C(int a1, int a2, char *a3)
{
  _DWORD *v6; // r4
  int v8[2]; // [sp+0h] [bp-68h] BYREF
  int v9[2]; // [sp+8h] [bp-60h] BYREF
  char v10; // [sp+10h] [bp-58h]
  int v11; // [sp+18h] [bp-50h]
  int v12; // [sp+1Ch] [bp-4Ch]
  int v13; // [sp+20h] [bp-48h]
  int v14; // [sp+24h] [bp-44h]
  int v15; // [sp+2Ch] [bp-3Ch]
  _DWORD v16[14]; // [sp+30h] [bp-38h] BYREF

  sub_4F90C(a3, "<string>");
  if ( a1 )
  {
    v6 = 0;
    v8[0] = a1;
    v9[0] = (int)sub_4C028;
    v8[1] = 0;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v14 = 0;
    v15 = 0;
    v9[1] = (int)v8;
    v13 = 1;
    if ( !sub_4D954(v16) )
    {
      v16[3] = a2;
      v16[5] = -1;
      v6 = sub_4D288(v9, a2, (int)a3);
      sub_4C1FC(v9);
    }
  }
  else
  {
    v6 = 0;
    sub_4C0CC((int)a3, 0, 4, "wrong arguments");
  }
  return v6;
}

//----- (0004D454) --------------------------------------------------------
_DWORD *__fastcall sub_4D454(int a1, int a2, int a3, char *a4)
{
  _DWORD *v8; // r4
  int v10[3]; // [sp+4h] [bp-6Ch] BYREF
  int v11[2]; // [sp+10h] [bp-60h] BYREF
  char v12; // [sp+18h] [bp-58h]
  int v13; // [sp+20h] [bp-50h]
  int v14; // [sp+24h] [bp-4Ch]
  int v15; // [sp+28h] [bp-48h]
  int v16; // [sp+2Ch] [bp-44h]
  int v17; // [sp+34h] [bp-3Ch]
  _DWORD v18[14]; // [sp+38h] [bp-38h] BYREF

  sub_4F90C(a4, "<buffer>");
  if ( a1 )
  {
    v8 = 0;
    v10[0] = a1;
    v10[1] = a2;
    v11[0] = (int)sub_4C04C;
    v10[2] = 0;
    v12 = 0;
    v13 = 0;
    v14 = 0;
    v16 = 0;
    v17 = 0;
    v11[1] = (int)v10;
    v15 = 1;
    if ( !sub_4D954(v18) )
    {
      v18[3] = a3;
      v18[5] = -1;
      v8 = sub_4D288(v11, a3, (int)a4);
      sub_4C1FC(v11);
    }
  }
  else
  {
    v8 = 0;
    sub_4C0CC((int)a4, 0, 4, "wrong arguments");
  }
  return v8;
}

//----- (0004D528) --------------------------------------------------------
_DWORD *__fastcall sub_4D528(int a1, int a2, char *a3)
{
  char *v6; // r1
  _DWORD *v7; // r4
  int v9[2]; // [sp+0h] [bp-60h] BYREF
  char v10; // [sp+8h] [bp-58h]
  int v11; // [sp+10h] [bp-50h]
  int v12; // [sp+14h] [bp-4Ch]
  int v13; // [sp+18h] [bp-48h]
  int v14; // [sp+1Ch] [bp-44h]
  int v15; // [sp+24h] [bp-3Ch]
  _DWORD v16[14]; // [sp+28h] [bp-38h] BYREF

  if ( stdin == a1 )
    v6 = "<stdin>";
  else
    v6 = "<stream>";
  sub_4F90C(a3, v6);
  if ( a1 )
  {
    v7 = 0;
    v9[1] = a1;
    v9[0] = (int)fgetc;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v14 = 0;
    v15 = 0;
    v13 = 1;
    if ( !sub_4D954(v16) )
    {
      v16[3] = a2;
      v16[5] = -1;
      v7 = sub_4D288(v9, a2, (int)a3);
      sub_4C1FC(v9);
    }
  }
  else
  {
    v7 = 0;
    sub_4C0CC((int)a3, 0, 4, "wrong arguments");
  }
  return v7;
}
// 7F798: using guessed type int stdin;

//----- (0004D608) --------------------------------------------------------
_DWORD *__fastcall sub_4D608(int a1, int a2, char *a3)
{
  char *v4; // r1
  _DWORD *v6; // r4
  int v8; // [sp+4h] [bp-5Ch] BYREF
  int v9[2]; // [sp+8h] [bp-58h] BYREF
  char v10; // [sp+10h] [bp-50h]
  int v11; // [sp+18h] [bp-48h]
  int v12; // [sp+1Ch] [bp-44h]
  int v13; // [sp+20h] [bp-40h]
  int v14; // [sp+24h] [bp-3Ch]
  int v15; // [sp+2Ch] [bp-34h]
  _DWORD v16[12]; // [sp+30h] [bp-30h] BYREF

  v8 = a1;
  if ( a1 )
    v4 = "<stream>";
  else
    v4 = "<stdin>";
  sub_4F90C(a3, v4);
  if ( v8 < 0 )
  {
    v6 = 0;
    sub_4C0CC((int)a3, 0, 4, "wrong arguments");
  }
  else
  {
    v6 = 0;
    v9[0] = (int)sub_4C23C;
    v9[1] = (int)&v8;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v14 = 0;
    v15 = 0;
    v13 = 1;
    if ( !sub_4D954(v16) )
    {
      v16[3] = a2;
      v16[5] = -1;
      v6 = sub_4D288(v9, a2, (int)a3);
      sub_4C1FC(v9);
    }
  }
  return v6;
}

//----- (0004D6E4) --------------------------------------------------------
_DWORD *__fastcall sub_4D6E4(char *a1, int a2, char *a3)
{
  int v6; // r0
  FILE *v7; // r7
  _DWORD *v8; // r6
  int *v10; // r0
  char *v11; // r0

  sub_4F90C(a3, a1);
  if ( a1 )
  {
    v6 = fopen64(a1, "rb");
    v7 = (FILE *)v6;
    if ( v6 )
    {
      v8 = sub_4D528(v6, a2, a3);
      fclose(v7);
    }
    else
    {
      v10 = _errno_location();
      v8 = 0;
      v11 = strerror(*v10);
      sub_4C0CC((int)a3, 0, 3, "unable to open %s: %s", a1, v11);
    }
  }
  else
  {
    v8 = 0;
    sub_4C0CC((int)a3, 0, 4, "wrong arguments");
  }
  return v8;
}
// 124E4: using guessed type int __fastcall fopen64(_DWORD, _DWORD);

//----- (0004D880) --------------------------------------------------------
int __fastcall sub_4D880(int result)
{
  if ( result )
    return off_7F568(result);
  return result;
}
// 7F568: using guessed type int (__fastcall *off_7F568)(_DWORD);

//----- (0004D898) --------------------------------------------------------
int __fastcall sub_4D898(int result)
{
  if ( result )
    return off_7F56C();
  return result;
}
// 7F56C: using guessed type int (*off_7F56C)(void);

//----- (0004D8B0) --------------------------------------------------------
_BYTE *__fastcall sub_4D8B0(const void *a1, size_t a2)
{
  size_t v2; // r5
  void *v5; // r0

  v2 = a2 + 1;
  if ( a2 != -1 )
  {
    v5 = (void *)off_7F568(a2 + 1);
    v2 = (size_t)v5;
    if ( v5 )
    {
      memcpy(v5, a1, a2);
      *(_BYTE *)(v2 + a2) = 0;
    }
  }
  return (_BYTE *)v2;
}
// 7F568: using guessed type int (__fastcall *off_7F568)(_DWORD);

//----- (0004D8FC) --------------------------------------------------------
_BYTE *__fastcall sub_4D8FC(const char *a1)
{
  size_t v2; // r1

  v2 = strlen(a1);
  return sub_4D8B0(a1, v2);
}

//----- (0004D918) --------------------------------------------------------
int __fastcall sub_4D918(__int64 a1)
{
  *(_QWORD *)&off_7F568 = a1;
  return a1;
}
// 7F568: using guessed type int (__fastcall *off_7F568)(_DWORD);

//----- (0004D928) --------------------------------------------------------
_DWORD *__fastcall sub_4D928(_DWORD *result, _DWORD *a2)
{
  if ( result )
    *result = off_7F568;
  if ( a2 )
    *a2 = off_7F56C;
  return result;
}
// 7F568: using guessed type int (__fastcall *off_7F568)(_DWORD);
// 7F56C: using guessed type int (*off_7F56C)(void);

//----- (0004D954) --------------------------------------------------------
int __fastcall sub_4D954(_DWORD *a1)
{
  _BYTE *v2; // r0

  a1[2] = 16;
  a1[1] = 0;
  v2 = (_BYTE *)sub_4D880(16);
  *a1 = v2;
  if ( !v2 )
    return -1;
  *v2 = 0;
  return 0;
}

//----- (0004D988) --------------------------------------------------------
int __fastcall sub_4D988(int *a1)
{
  int result; // r0

  result = *a1;
  if ( result )
    result = sub_4D898(result);
  a1[2] = 0;
  a1[1] = 0;
  *a1 = 0;
  return result;
}

//----- (0004D9B4) --------------------------------------------------------
int __fastcall sub_4D9B4(int result)
{
  _BYTE *v1; // r2

  v1 = *(_BYTE **)result;
  *(_DWORD *)(result + 4) = 0;
  *v1 = 0;
  return result;
}

//----- (0004D9C8) --------------------------------------------------------
int __fastcall sub_4D9C8(int a1)
{
  return *(_DWORD *)a1;
}

//----- (0004D9D0) --------------------------------------------------------
int __fastcall sub_4D9D0(int *a1)
{
  int result; // r0

  result = *a1;
  *a1 = 0;
  return result;
}

//----- (0004D9E4) --------------------------------------------------------
int __fastcall sub_4D9E4(const void **a1, void *src, size_t n)
{
  unsigned int v4; // r3
  _BYTE *v7; // r0
  const void *v8; // r8
  unsigned int v9; // r3
  unsigned int v10; // r0
  const void *v11; // r6
  void *v12; // r0
  const void *v13; // r2
  int result; // r0
  char *v15; // r5

  v4 = (unsigned int)a1[2];
  v7 = a1[1];
  if ( v4 - (unsigned int)v7 > n )
  {
    v8 = *a1;
LABEL_10:
    memcpy(&v7[(_DWORD)v8], src, n);
    v13 = *a1;
    result = 0;
    v15 = (char *)a1[1] + n;
    a1[1] = v15;
    v15[(_DWORD)v13] = 0;
    return result;
  }
  if ( !((n == -1) | (v4 >> 31)) && -2 - n >= (unsigned int)v7 )
  {
    v9 = 2 * v4;
    v10 = (unsigned int)&v7[n + 1];
    v11 = (const void *)(v10 < v9 ? v9 : v10);
    v12 = (void *)sub_4D880((int)v11);
    v8 = v12;
    if ( v12 )
    {
      memcpy(v12, *a1, (size_t)a1[1]);
      sub_4D898((int)*a1);
      v7 = a1[1];
      *a1 = v8;
      a1[2] = v11;
      goto LABEL_10;
    }
  }
  return -1;
}

//----- (0004DAB0) --------------------------------------------------------
int __fastcall sub_4DAB0(const void **a1, char a2)
{
  char v3; // [sp+7h] [bp-9h] BYREF

  v3 = a2;
  return sub_4D9E4(a1, &v3, 1u);
}

//----- (0004DAD4) --------------------------------------------------------
int __fastcall sub_4DAD4(int *a1, char a2, int a3)
{
  int v3; // r3
  bool v4; // zf
  int result; // r0

  v3 = a1[1];
  v4 = v3 == 0;
  if ( v3 )
  {
    a3 = *a1;
    --v3;
    a2 = 0;
    a1[1] = v3;
    result = *(unsigned __int8 *)(a3 + v3);
  }
  else
  {
    result = 0;
  }
  if ( !v4 )
    *(_BYTE *)(a3 + v3) = a2;
  return result;
}

//----- (0004DB00) --------------------------------------------------------
int __fastcall sub_4DB00(int a1, double *a2)
{
  double v2; // d0
  struct lconv *v5; // r0
  const char *v6; // r5
  int v7; // r6
  char *v8; // r0
  int *v9; // r6
  int result; // r0
  char *endptr; // [sp+4h] [bp-1Ch] BYREF

  v5 = localeconv();
  v6 = *(const char **)a1;
  v7 = *(unsigned __int8 *)v5->decimal_point;
  if ( v7 != 46 )
  {
    v8 = strchr(*(const char **)a1, 46);
    if ( v8 )
    {
      *v8 = v7;
      v6 = *(const char **)a1;
    }
  }
  v9 = _errno_location();
  *v9 = 0;
  strtod(v6, &endptr);
  if ( endptr != (char *)(*(_DWORD *)a1 + *(_DWORD *)(a1 + 4)) )
    _assert_fail("end == strbuffer->value + strbuffer->length", "strconv.c", 0x4Eu, "jsonp_strtod");
  if ( (v2 > 1.79769313e308 || v2 < -1.79769313e308) && *v9 == 34 )
    return -1;
  result = 0;
  *a2 = v2;
  return result;
}
// 4DB80: variable 'v2' is possibly undefined

//----- (0004DBF0) --------------------------------------------------------
int __fastcall sub_4DBF0(char *a1, size_t a2)
{
  unsigned int v4; // r0
  unsigned int v5; // r6
  int v6; // r1
  char *v7; // r0
  char *v8; // r5
  char *v9; // r0
  unsigned __int8 *v10; // r4
  int v11; // r3
  _BYTE *v12; // r5
  int v13; // t1
  size_t v14; // r2
  char *v16; // r3

  v4 = snprintf(a1, a2, "%.*g");
  if ( a2 > v4 )
  {
    v5 = v4;
    v6 = *(unsigned __int8 *)localeconv()->decimal_point;
    if ( v6 != 46 )
    {
      v7 = strchr(a1, v6);
      if ( v7 )
        *v7 = 46;
    }
    v8 = strchr(a1, 46);
    v9 = strchr(a1, 101);
    if ( v8 )
    {
LABEL_6:
      if ( !v9 )
        return v5;
      goto LABEL_7;
    }
    if ( v9 )
    {
LABEL_7:
      v10 = (unsigned __int8 *)(v9 + 2);
      v11 = (unsigned __int8)v9[2];
      if ( v9[1] != 45 )
      {
        v12 = v9 + 1;
        if ( v11 != 48 )
        {
LABEL_10:
          if ( v10 != v12 )
          {
            v14 = v5 - (v10 - (unsigned __int8 *)a1);
            v5 -= v10 - v12;
            memmove(v12, v10, v14);
          }
          return v5;
        }
        do
LABEL_9:
          v13 = *++v10;
        while ( v13 == 48 );
        goto LABEL_10;
      }
      if ( v11 == 48 )
      {
        v12 = v9 + 2;
        goto LABEL_9;
      }
      return v5;
    }
    if ( v5 + 3 < a2 )
    {
      a1[v5] = 46;
      v16 = &a1[v5];
      v5 += 2;
      v16[1] = 48;
      a1[v5] = 0;
      v9 = strchr(a1, 101);
      goto LABEL_6;
    }
  }
  return -1;
}

//----- (0004DD30) --------------------------------------------------------
int __fastcall sub_4DD30(int a1, _BYTE *a2, _DWORD *a3)
{
  char v3; // r3
  int result; // r0
  char v5; // r3
  char v6; // r3
  unsigned int v7; // r12

  if ( a1 < 0 )
    return -1;
  if ( a1 <= 127 )
  {
    *a2 = a1;
    result = 0;
    *a3 = 1;
  }
  else if ( a1 < 2048 )
  {
    v5 = (a1 & 0x3F) + 0x80;
    *a2 = (a1 >> 6) - 64;
    result = 0;
    a2[1] = v5;
    *a3 = 2;
  }
  else if ( a1 < 0x10000 )
  {
    v6 = (a1 & 0x3F) + 0x80;
    v7 = (((unsigned int)a1 >> 6) & 0x3F) - 128;
    *a2 = (a1 >> 12) - 32;
    result = 0;
    a2[1] = v7;
    a2[2] = v6;
    *a3 = 3;
  }
  else if ( a1 >= 1114112 )
  {
    return -1;
  }
  else
  {
    v3 = (a1 & 0x3F) + 0x80;
    *a2 = (a1 >> 18) - 16;
    a2[1] = (((unsigned int)a1 >> 12) & 0x3F) + 0x80;
    a2[2] = (((unsigned int)a1 >> 6) & 0x3F) + 0x80;
    result = 0;
    a2[3] = v3;
    *a3 = 4;
  }
  return result;
}

//----- (0004DE1C) --------------------------------------------------------
int __fastcall sub_4DE1C(int a1)
{
  if ( (a1 & 0x80) == 0 )
    return 1;
  if ( (a1 ^ 0x80u) <= 0x41 )
    return 0;
  if ( (unsigned __int8)(a1 + 62) <= 0x1Du )
    return 2;
  if ( (unsigned __int8)(a1 + 32) <= 0xFu )
    return 3;
  if ( (unsigned __int8)(a1 + 16) <= 4u )
    return 4;
  return 0;
}

//----- (0004DE88) --------------------------------------------------------
bool __fastcall sub_4DE88(char *a1, unsigned int a2, int *a3)
{
  char v3; // lr
  int v4; // lr
  _BOOL4 result; // r0
  int v6; // r3
  char *v7; // r0
  unsigned int v8; // r12
  int v9; // t1
  bool v10; // zf
  _BOOL4 v11; // r3
  _BOOL4 v12; // r1

  v3 = *a1;
  switch ( a2 )
  {
    case 2u:
      v4 = v3 & 0x1F;
      break;
    case 3u:
      v4 = v3 & 0xF;
      break;
    case 4u:
      v4 = v3 & 7;
      break;
    default:
      return 0;
  }
  v6 = (unsigned __int8)a1[1];
  if ( (v6 ^ 0x80u) > 0x3F )
    return 0;
  v7 = a1 + 1;
  v8 = 1;
  while ( 1 )
  {
    ++v8;
    v4 = (v6 & 0x3F) + (v4 << 6);
    if ( a2 <= v8 )
      break;
    v9 = (unsigned __int8)*++v7;
    LOBYTE(v6) = v9;
    if ( (v9 ^ 0x80u) > 0x3F )
      return 0;
  }
  if ( v4 >= 1114112 || (unsigned int)(v4 - 55296) < 0x800 )
    return 0;
  v10 = v4 == 127;
  if ( v4 <= 127 )
    v10 = a2 == 2;
  result = v10;
  if ( v10 )
    return 0;
  v11 = a2 == 3;
  if ( v4 >= 2048 )
    v11 = 0;
  if ( !v11 )
  {
    v12 = a2 == 4;
    if ( v4 >= 0x10000 )
      v12 = 0;
    if ( !v12 )
    {
      result = 1;
      if ( a3 )
        *a3 = v4;
      return result;
    }
    return 0;
  }
  return result;
}

//----- (0004DF70) --------------------------------------------------------
char *__fastcall sub_4DF70(char *result, int a2, _DWORD *a3)
{
  char *v4; // r4
  unsigned int v5; // r0
  unsigned int v6; // r1
  int v7; // r2
  unsigned int v8; // r6
  int v9; // [sp+4h] [bp-14h] BYREF

  if ( a2 )
  {
    v4 = result;
    v5 = sub_4DE1C((unsigned __int8)*result);
    v8 = v5;
    if ( v5 )
    {
      if ( v5 == 1 )
      {
        v9 = v7;
LABEL_7:
        result = &v4[v8];
        if ( a3 )
          *a3 = v9;
        return result;
      }
      if ( v6 >= v5 && sub_4DE88(v4, v5, &v9) )
        goto LABEL_7;
    }
    return 0;
  }
  return result;
}
// 4DFA0: variable 'v7' is possibly undefined
// 4DFAC: variable 'v6' is possibly undefined

//----- (0004DFEC) --------------------------------------------------------
int __fastcall sub_4DFEC(int a1, unsigned int a2)
{
  int v4; // r4
  unsigned int v5; // r5
  char *v6; // r0

  if ( !a2 )
    return 1;
  v4 = 0;
  while ( 1 )
  {
    v5 = sub_4DE1C(*(unsigned __int8 *)(a1 + v4));
    v6 = (char *)(a1 + v4);
    if ( !v5 )
      break;
    if ( v5 > 1 )
    {
      if ( a2 - v4 < v5 )
        break;
      v4 = v5 + v4 - 1;
      if ( !sub_4DE88(v6, v5, 0) )
        break;
    }
    if ( a2 <= ++v4 )
      return 1;
  }
  return 0;
}

//----- (0004E068) --------------------------------------------------------
int __fastcall sub_4E068(int a1)
{
  __int64 v1; // r4
  int result; // r0

  if ( a1 && *(_DWORD *)a1 == 3 )
    v1 = *(_QWORD *)(a1 + 8);
  else
    v1 = 0LL;
  result = sub_4D880(16);
  if ( result )
  {
    *(_QWORD *)(result + 8) = v1;
    *(_DWORD *)result = 3;
    *(_DWORD *)(result + 4) = 1;
  }
  return result;
}

//----- (0004E0B8) --------------------------------------------------------
const void *__fastcall sub_4E0B8(_DWORD *a1, int a2, int a3)
{
  unsigned int v3; // r12
  const void *v4; // r5
  unsigned int v6; // r3
  unsigned int v7; // r12
  unsigned int v10; // r7
  void *v11; // r0

  v3 = a1[2];
  v4 = (const void *)a1[4];
  if ( a2 + a1[3] <= v3 )
    return v4;
  v6 = 2 * v3;
  v7 = v3 + a2;
  if ( v6 < v7 )
    v10 = v7;
  else
    v10 = v6;
  v11 = (void *)sub_4D880(4 * v10);
  if ( !v11 )
    return 0;
  a1[2] = v10;
  a1[4] = v11;
  if ( !a3 )
    return v4;
  memcpy(v11, v4, 4 * a1[3]);
  sub_4D898((int)v4);
  return (const void *)a1[4];
}

//----- (0004E144) --------------------------------------------------------
_DWORD *__fastcall sub_4E144(_BYTE *a1, size_t a2, int a3)
{
  _BYTE *v3; // r5
  _DWORD *result; // r0

  v3 = a1;
  if ( !a1 )
    return 0;
  if ( !a3 )
  {
    v3 = sub_4D8B0(a1, a2);
    if ( !v3 )
      return 0;
  }
  result = (_DWORD *)sub_4D880(16);
  if ( result )
  {
    result[2] = v3;
    result[3] = a2;
    *result = 2;
    result[1] = 1;
  }
  else
  {
    sub_4D898((int)v3);
    return 0;
  }
  return result;
}

//----- (0004E1B0) --------------------------------------------------------
_DWORD *sub_4E1B0()
{
  _DWORD *v0; // r4
  int v2; // r0

  v0 = (_DWORD *)sub_4D880(36);
  if ( v0 )
  {
    if ( !dword_5051C0 )
      sub_4BF2C(dword_5051C0);
    v0[1] = 1;
    *v0 = 0;
    if ( sub_4B91C(v0 + 2) )
    {
      v2 = (int)v0;
      v0 = 0;
      sub_4D898(v2);
    }
  }
  return v0;
}
// 5051C0: using guessed type int dword_5051C0;

//----- (0004E218) --------------------------------------------------------
_DWORD *__fastcall sub_4E218(_DWORD *result)
{
  if ( result )
  {
    if ( *result )
      return 0;
    else
      return (_DWORD *)result[2];
  }
  return result;
}

//----- (0004E234) --------------------------------------------------------
int __fastcall sub_4E234(_DWORD *a1, char *a2)
{
  bool v2; // zf

  v2 = a1 == 0;
  if ( a1 )
    v2 = a2 == 0;
  if ( v2 || *a1 )
    return 0;
  else
    return sub_4BC44((int)(a1 + 2), a2);
}

//----- (0004E25C) --------------------------------------------------------
bool __fastcall sub_4E25C(int *a1, int *a2)
{
  int v2; // r3
  int v6; // r7
  int v7; // r2
  unsigned int v8; // r6
  int v9; // r1
  bool v10; // zf
  int v11; // r0
  int v12; // r8
  int v13; // r0
  int v14; // r1
  int v15; // r0
  char *v16; // r6
  int v17; // r7
  int v18; // r0
  char *v19; // r1
  int v20; // r6
  size_t v21; // r2

  v2 = *a1;
  if ( *a1 != *a2 )
    return 0;
  if ( a1 == a2 )
    return 1;
  switch ( v2 )
  {
    case 0:
      if ( a1[2] != a2[2] )
        return 0;
      v12 = (int)(a1 + 2);
      v13 = sub_4BE20((int)(a1 + 2));
      if ( !v13 )
        return 1;
      while ( 1 )
      {
        v15 = sub_4BEB0(v13);
        v16 = (char *)v15;
        if ( !v15 )
          break;
        v17 = v15 - 16;
        v18 = sub_4BEB8(v15 - 16);
        v19 = v16;
        v20 = v18;
        if ( !v18 )
          break;
        v14 = sub_4E234(a2, v19);
        if ( !v14 || !sub_4E25C(v20, v14) )
          return 0;
        if ( !*a1 )
        {
          v13 = sub_4BE98(v12, v17);
          if ( v13 )
            continue;
        }
        return 1;
      }
      return 1;
    case 1:
      v6 = a1[3];
      if ( v6 != a2[3] )
        return 0;
      if ( !v6 )
        return 1;
      v7 = *a1;
      v8 = 0;
      break;
    case 2:
      v21 = a1[3];
      return v21 == a2[3] && !memcmp((const void *)a1[2], (const void *)a2[2], v21);
    case 3:
      return *((_QWORD *)a1 + 1) == *((_QWORD *)a2 + 1);
    case 4:
      return *((double *)a1 + 1) == *((double *)a2 + 1);
    default:
      return 0;
  }
  while ( 1 )
  {
    if ( v2 == 1 && a1[3] > v8 )
      v11 = *(_DWORD *)(a1[4] + 4 * v8);
    else
      v11 = 0;
    if ( v7 != 1 || a2[3] <= v8 )
      return 0;
    v9 = *(_DWORD *)(a2[4] + 4 * v8);
    v10 = v9 == 0;
    if ( v9 )
      v10 = v11 == 0;
    if ( v10 || !sub_4E25C(v11, v9) )
      return 0;
    if ( v6 == ++v8 )
      break;
    v2 = *a1;
    v7 = *a2;
  }
  return 1;
}
// 4E290: control flows out of bounds to 4E294

//----- (0004E43C) --------------------------------------------------------
int __fastcall sub_4E43C(_DWORD *a1, char *a2)
{
  bool v2; // zf

  v2 = a1 == 0;
  if ( a1 )
    v2 = a2 == 0;
  if ( v2 || *a1 )
    return -1;
  else
    return sub_4BCA4(a1 + 2, a2);
}

//----- (0004E49C) --------------------------------------------------------
int __fastcall sub_4E49C(_DWORD *a1)
{
  if ( !a1 || *a1 )
    return 0;
  else
    return sub_4BE20((int)(a1 + 2));
}

//----- (0004E4C0) --------------------------------------------------------
int __fastcall sub_4E4C0(_DWORD *a1, char *a2)
{
  bool v2; // zf

  v2 = a1 == 0;
  if ( a1 )
    v2 = a2 == 0;
  if ( v2 || *a1 )
    return 0;
  else
    return sub_4BE38((int)(a1 + 2), a2);
}

//----- (0004E4E8) --------------------------------------------------------
int __fastcall sub_4E4E8(_DWORD *a1, int a2)
{
  _BOOL4 v2; // r3

  if ( !a1 )
    return 0;
  v2 = a2 == 0;
  if ( *a1 )
    v2 = 1;
  if ( v2 )
    return 0;
  else
    return sub_4BE98((int)(a1 + 2), a2);
}

//----- (0004E51C) --------------------------------------------------------
int __fastcall sub_4E51C(int a1)
{
  if ( a1 )
    return sub_4BEB0(a1);
  return a1;
}

//----- (0004E528) --------------------------------------------------------
int __fastcall sub_4E528(int a1)
{
  if ( a1 )
    return sub_4BEB8(a1);
  return a1;
}

//----- (0004E534) --------------------------------------------------------
int __fastcall sub_4E534(int result)
{
  if ( result )
    result -= 16;
  return result;
}

//----- (0004E540) --------------------------------------------------------
_DWORD *sub_4E540()
{
  _DWORD *v0; // r0
  _DWORD *v1; // r4
  int v2; // r0
  int v4; // r0

  v0 = (_DWORD *)sub_4D880(20);
  v1 = v0;
  if ( v0 )
  {
    *v0 = 1;
    v0[1] = 1;
    v0[3] = 0;
    v0[2] = 8;
    v2 = sub_4D880(32);
    v1[4] = v2;
    if ( !v2 )
    {
      v4 = (int)v1;
      v1 = 0;
      sub_4D898(v4);
    }
  }
  return v1;
}

//----- (0004E5A0) --------------------------------------------------------
_DWORD *__fastcall sub_4E5A0(_DWORD *result)
{
  if ( result )
  {
    if ( *result == 1 )
      return (_DWORD *)result[3];
    else
      return 0;
  }
  return result;
}

//----- (0004E5BC) --------------------------------------------------------
_DWORD *__fastcall sub_4E5BC(_DWORD *result, unsigned int a2)
{
  if ( result )
  {
    if ( *result == 1 && result[3] > a2 )
      return *(_DWORD **)(result[4] + 4 * a2);
    else
      return 0;
  }
  return result;
}

//----- (0004E5F0) --------------------------------------------------------
int __fastcall sub_4E5F0(_DWORD *a1, _DWORD *a2)
{
  _BOOL4 v3; // r4
  __int64 v5; // r0
  size_t v6; // r2
  unsigned int v7; // r3
  int v8; // r2
  int v9; // r12
  unsigned int *v10; // r2
  unsigned int v11; // r1
  int result; // r0

  if ( !a1 )
    return -1;
  v3 = *a1 != 1 || a2 == 0;
  if ( v3 || *a2 != 1 || !sub_4E0B8(a1, a2[3], 1) )
    return -1;
  v5 = *(_QWORD *)(a2 + 3);
  v6 = a2[3];
  if ( (_DWORD)v5 )
  {
    v7 = 0;
    do
    {
      v8 = *(_DWORD *)(HIDWORD(v5) + 4 * v7);
      if ( v8 )
      {
        v9 = *(_DWORD *)(v8 + 4);
        v10 = (unsigned int *)(v8 + 4);
        if ( v9 != -1 )
        {
          do
            v11 = __ldrex(v10);
          while ( __strex(v11 + 1, v10) );
          __dmb(0xBu);
          v5 = *(_QWORD *)(a2 + 3);
        }
      }
      ++v7;
    }
    while ( (unsigned int)v5 > v7 );
    v6 = 4 * v5;
  }
  memcpy((void *)(a1[4] + 4 * a1[3]), (const void *)HIDWORD(v5), v6);
  result = 0;
  a1[3] += a2[3];
  return result;
}

//----- (0004E6C8) --------------------------------------------------------
const char *__fastcall sub_4E6C8(const char *result)
{
  char *v1; // r4
  size_t v2; // r0

  if ( result )
  {
    v1 = (char *)result;
    v2 = strlen(result);
    return (const char *)sub_4E144(v1, v2, 0);
  }
  return result;
}

//----- (0004E6F0) --------------------------------------------------------
_DWORD *__fastcall sub_4E6F0(_BYTE *a1, size_t a2)
{
  return sub_4E144(a1, a2, 0);
}

//----- (0004E6F8) --------------------------------------------------------
_DWORD *__fastcall sub_4E6F8(_BYTE *a1, size_t a2)
{
  return sub_4E144(a1, a2, 1);
}

//----- (0004E700) --------------------------------------------------------
_DWORD *__fastcall sub_4E700(_BYTE *a1, size_t a2)
{
  if ( !a1 )
    return 0;
  if ( sub_4DFEC((int)a1, a2) )
    return sub_4E144(a1, a2, 0);
  return 0;
}

//----- (0004E744) --------------------------------------------------------
const char *__fastcall sub_4E744(const char *result)
{
  char *v1; // r4
  size_t v2; // r0

  if ( result )
  {
    v1 = (char *)result;
    v2 = strlen(result);
    return (const char *)sub_4E700(v1, v2);
  }
  return result;
}

//----- (0004E768) --------------------------------------------------------
_DWORD *__fastcall sub_4E768(_DWORD *result)
{
  if ( result )
  {
    if ( *result == 2 )
      return (_DWORD *)result[2];
    else
      return 0;
  }
  return result;
}

//----- (0004E784) --------------------------------------------------------
_DWORD *__fastcall sub_4E784(_DWORD *result)
{
  if ( result )
  {
    if ( *result == 2 )
      return (_DWORD *)result[3];
    else
      return 0;
  }
  return result;
}

//----- (0004E7A0) --------------------------------------------------------
int __fastcall sub_4E7A0(_DWORD *a1, const void *a2, size_t a3)
{
  _BYTE *v6; // r7
  int result; // r0

  if ( !a1 )
    return -1;
  if ( *a1 != 2 || a2 == 0 )
    return -1;
  v6 = sub_4D8B0(a2, a3);
  if ( !v6 )
    return -1;
  sub_4D898(a1[2]);
  result = 0;
  a1[2] = v6;
  a1[3] = a3;
  return result;
}

//----- (0004E804) --------------------------------------------------------
int __fastcall sub_4E804(_DWORD *a1, const char *a2)
{
  size_t v4; // r0

  if ( !a2 )
    return -1;
  v4 = strlen(a2);
  return sub_4E7A0(a1, a2, v4);
}

//----- (0004E838) --------------------------------------------------------
int __fastcall sub_4E838(_DWORD *a1, const void *a2, size_t a3)
{
  if ( a2 && sub_4DFEC((int)a2, a3) )
    return sub_4E7A0(a1, a2, a3);
  else
    return -1;
}

//----- (0004E87C) --------------------------------------------------------
int __fastcall sub_4E87C(_DWORD *a1, const char *a2)
{
  size_t v4; // r0

  if ( !a2 )
    return -1;
  v4 = strlen(a2);
  return sub_4E838(a1, a2, v4);
}

//----- (0004E8B0) --------------------------------------------------------
_DWORD *__fastcall sub_4E8B0(char *format, __gnuc_va_list arg)
{
  int v3; // r0
  size_t v4; // r4
  char *v5; // r0
  char *v6; // r7

  v3 = vsnprintf(0, 0, format, arg);
  v4 = v3;
  if ( !v3 )
    return sub_4E700("", 0);
  v5 = (char *)sub_4D880(v3 + 1);
  v6 = v5;
  if ( !v5 )
    return 0;
  vsnprintf(v5, v4 + 1, format, arg);
  if ( sub_4DFEC((int)v6, v4) )
    return sub_4E144(v6, v4, 1);
  sub_4D898((int)v6);
  return 0;
}

//----- (0004E960) --------------------------------------------------------
_DWORD *sub_4E960(char *a1, ...)
{
  va_list varg_r1; // [sp+14h] [bp-Ch] BYREF

  va_start(varg_r1, a1);
  return sub_4E8B0(a1, varg_r1);
}

//----- (0004E990) --------------------------------------------------------
int __fastcall sub_4E990(__int64 a1)
{
  int result; // r0

  result = sub_4D880(16);
  if ( result )
  {
    *(_QWORD *)(result + 8) = a1;
    *(_DWORD *)result = 3;
    *(_DWORD *)(result + 4) = 1;
  }
  return result;
}

//----- (0004E9C4) --------------------------------------------------------
__int64 __fastcall sub_4E9C4(int a1)
{
  if ( a1 && *(_DWORD *)a1 == 3 )
    return *(_QWORD *)(a1 + 8);
  else
    return 0LL;
}

//----- (0004E9EC) --------------------------------------------------------
int __fastcall sub_4E9EC(int a1, __int64 a2)
{
  if ( !a1 || *(_DWORD *)a1 != 3 )
    return -1;
  *(_QWORD *)(a1 + 8) = a2;
  return 0;
}

//----- (0004EA14) --------------------------------------------------------
int sub_4EA14()
{
  double v0; // d0
  int result; // r0

  if ( fabs(v0) > 1.79769313e308 )
    return 0;
  result = sub_4D880(16);
  if ( result )
  {
    *(double *)(result + 8) = v0;
    *(_DWORD *)result = 4;
    *(_DWORD *)(result + 4) = 1;
  }
  return result;
}
// 4EA24: variable 'v0' is possibly undefined

//----- (0004EA70) --------------------------------------------------------
void sub_4EA70()
{
  ;
}

//----- (0004EB48) --------------------------------------------------------
void *sub_4EB48()
{
  return &unk_7F570;
}

//----- (0004EB54) --------------------------------------------------------
void *sub_4EB54()
{
  return &unk_7F578;
}

//----- (0004EB60) --------------------------------------------------------
void *sub_4EB60()
{
  return &unk_7F580;
}

//----- (0004EB6C) --------------------------------------------------------
_DWORD *__fastcall sub_4EB6C(_DWORD *result)
{
  _DWORD *v1; // r4
  int v2; // r0
  unsigned int v3; // r1
  unsigned int i; // r5
  _DWORD *v5; // r3
  unsigned int *v6; // r2
  unsigned int v7; // r1
  unsigned int v8; // r1

  v1 = result;
  if ( result )
  {
    switch ( *result )
    {
      case 0:
        sub_4B998((int)(result + 2));
        return (_DWORD *)sub_4D898((int)v1);
      case 1:
        v3 = result[3];
        v2 = result[4];
        if ( v3 )
        {
          for ( i = 0; i < v3; ++i )
          {
            v5 = *(_DWORD **)(v2 + 4 * i);
            if ( v5 )
            {
              v6 = v5 + 1;
              if ( v5[1] != -1 )
              {
                __dmb(0xBu);
                do
                {
                  v7 = __ldrex(v6);
                  v8 = v7 - 1;
                }
                while ( __strex(v8, v6) );
                if ( !v8 )
                  sub_4EB6C(v5);
                v2 = v1[4];
                v3 = v1[3];
              }
            }
          }
        }
        goto LABEL_4;
      case 2:
        v2 = result[2];
LABEL_4:
        sub_4D898(v2);
        goto LABEL_5;
      case 3:
      case 4:
LABEL_5:
        result = (_DWORD *)sub_4D898((int)v1);
        break;
      default:
        return result;
    }
  }
  return result;
}
// 4EB84: control flows out of bounds to 4EB88

//----- (0004EC38) --------------------------------------------------------
int __fastcall sub_4EC38(_DWORD *a1)
{
  unsigned int v2; // r2
  unsigned int i; // r4
  _DWORD *v4; // r0
  unsigned int *v5; // r3
  unsigned int v6; // r2
  unsigned int v7; // r2
  int result; // r0

  if ( !a1 || *a1 != 1 )
    return -1;
  v2 = a1[3];
  if ( v2 )
  {
    for ( i = 0; i < v2; ++i )
    {
      v4 = *(_DWORD **)(a1[4] + 4 * i);
      if ( v4 )
      {
        v5 = v4 + 1;
        if ( v4[1] != -1 )
        {
          __dmb(0xBu);
          do
          {
            v6 = __ldrex(v5);
            v7 = v6 - 1;
          }
          while ( __strex(v7, v5) );
          if ( !v7 )
            sub_4EB6C(v4);
          v2 = a1[3];
        }
      }
    }
  }
  result = 0;
  a1[3] = 0;
  return result;
}

//----- (0004ECC8) --------------------------------------------------------
int __fastcall sub_4ECC8(_DWORD *a1, int a2, _DWORD *a3)
{
  _BOOL4 v3; // r4
  unsigned int *v5; // r3
  unsigned int v6; // r1
  unsigned int v7; // r1

  if ( !a1 || *a1 )
    goto LABEL_8;
  if ( !a2 )
    v3 = 1;
  if ( a2 )
    v3 = a3 == 0;
  if ( v3 )
  {
LABEL_8:
    if ( !a3 )
      return -1;
    if ( a3[1] == -1 )
      return -1;
    v5 = a3 + 1;
    __dmb(0xBu);
    do
    {
      v6 = __ldrex(v5);
      v7 = v6 - 1;
    }
    while ( __strex(v7, v5) );
    if ( v7 )
    {
      return -1;
    }
    else
    {
      sub_4EB6C(a3);
      return -1;
    }
  }
  else
  {
    sub_4BEC0(a2, (int)a3);
    return 0;
  }
}
// 4ED4C: variable 'v3' is possibly undefined

//----- (0004ED60) --------------------------------------------------------
int __fastcall sub_4ED60(_DWORD *a1, unsigned int a2)
{
  unsigned int v3; // r12
  int v5; // r6
  _DWORD *v6; // r0
  int v7; // r3
  unsigned int *v9; // r3
  unsigned int v10; // r2
  unsigned int v11; // r2

  if ( a1 )
  {
    if ( *a1 == 1 )
    {
      v3 = a1[3];
      if ( v3 > a2 )
      {
        v5 = 4 * a2;
        v6 = *(_DWORD **)(a1[4] + 4 * a2);
        if ( v6 && v6[1] != -1 )
        {
          v9 = v6 + 1;
          __dmb(0xBu);
          do
          {
            v10 = __ldrex(v9);
            v11 = v10 - 1;
          }
          while ( __strex(v11, v9) );
          if ( !v11 )
            sub_4EB6C(v6);
          v3 = a1[3];
          v7 = v3 - 1;
          if ( v3 - 1 <= a2 )
            goto LABEL_7;
        }
        else
        {
          v7 = v3 - 1;
          if ( v3 - 1 <= a2 )
          {
LABEL_7:
            a1[3] = v7;
            return 0;
          }
        }
        memmove((void *)(a1[4] + v5), (const void *)(a1[4] + v5 + 4), 4 * (~a2 + v3));
        v7 = a1[3] - 1;
        goto LABEL_7;
      }
    }
  }
  return -1;
}

//----- (0004EE2C) --------------------------------------------------------
int __fastcall sub_4EE2C(_DWORD *a1, char *a2, _DWORD *a3)
{
  bool v4; // zf
  int result; // r0
  _BOOL4 v6; // r3
  unsigned int *v7; // r3
  unsigned int v8; // r2
  unsigned int v9; // r2
  unsigned int *v10; // r3
  unsigned int v11; // r2

  if ( !a3 )
    return -1;
  v4 = a1 == 0;
  if ( a1 )
    v4 = a2 == 0;
  if ( !v4 )
  {
    v6 = a3 == a1;
    if ( *a1 )
      v6 = 1;
    if ( !v6 )
    {
      result = sub_4B9B0(a1 + 2, a2, (int)a3);
      if ( !result )
        return result;
      if ( a3[1] != -1 )
      {
        v7 = a3 + 1;
        __dmb(0xBu);
        do
        {
          v8 = __ldrex(v7);
          v9 = v8 - 1;
        }
        while ( __strex(v9, v7) );
        goto LABEL_18;
      }
      return -1;
    }
  }
  if ( a3[1] == -1 )
    return -1;
  v10 = a3 + 1;
  __dmb(0xBu);
  do
  {
    v11 = __ldrex(v10);
    v9 = v11 - 1;
  }
  while ( __strex(v9, v10) );
LABEL_18:
  if ( v9 )
    return -1;
  sub_4EB6C(a3);
  return -1;
}

//----- (0004EEE8) --------------------------------------------------------
int __fastcall sub_4EEE8(_DWORD *a1, _DWORD *a2)
{
  _BOOL4 v3; // r3
  int v4; // r9
  int i; // r0
  unsigned int *v8; // r3
  unsigned int v9; // r2
  int v10; // r0
  char *v11; // r4
  _DWORD *v12; // r8

  if ( !a1 )
    return -1;
  v3 = a2 == 0;
  if ( *a1 )
    v3 = 1;
  if ( v3 || *a2 )
    return -1;
  v4 = (int)(a2 + 2);
  for ( i = sub_4BE20((int)(a2 + 2)); i; i = sub_4BE98(v4, (int)(v11 - 16)) )
  {
    v10 = sub_4BEB0(i);
    v11 = (char *)v10;
    if ( !v10 )
      break;
    v12 = (_DWORD *)sub_4BEB8(v10 - 16);
    if ( !v12 )
      break;
    if ( !sub_4E234(a1, v11) )
    {
      v8 = v12 + 1;
      if ( v12[1] != -1 )
      {
        do
          v9 = __ldrex(v8);
        while ( __strex(v9 + 1, v8) );
        __dmb(0xBu);
      }
      sub_4EE2C(a1, v11, v12);
    }
    if ( *a2 )
      break;
  }
  return 0;
}

//----- (0004EFD4) --------------------------------------------------------
int __fastcall sub_4EFD4(_DWORD *a1, char *a2, _DWORD *a3)
{
  unsigned int v6; // r0
  unsigned int *v8; // r3
  unsigned int v9; // r2
  unsigned int v10; // r2

  if ( a2 )
  {
    v6 = strlen(a2);
    if ( sub_4DFEC((int)a2, v6) )
      return sub_4EE2C(a1, a2, a3);
  }
  if ( !a3 )
    return -1;
  if ( a3[1] == -1 )
    return -1;
  v8 = a3 + 1;
  __dmb(0xBu);
  do
  {
    v9 = __ldrex(v8);
    v10 = v9 - 1;
  }
  while ( __strex(v10, v8) );
  if ( v10 )
    return -1;
  sub_4EB6C(a3);
  return -1;
}

//----- (0004F068) --------------------------------------------------------
int __fastcall sub_4F068(_DWORD *a1, _DWORD *a2)
{
  _BOOL4 v3; // r3
  int v4; // r8
  int v6; // r0
  unsigned int v8; // r1
  int v9; // r0
  char *v10; // r5
  _DWORD *v11; // r0
  unsigned int *v12; // r3

  if ( !a1 )
    return -1;
  v3 = a2 == 0;
  if ( *a1 )
    v3 = 1;
  if ( v3 || *a2 )
    return -1;
  v4 = (int)(a2 + 2);
  v6 = sub_4BE20((int)(a2 + 2));
  if ( v6 )
  {
    while ( 1 )
    {
      v9 = sub_4BEB0(v6);
      v10 = (char *)v9;
      if ( !v9 )
        break;
      v11 = (_DWORD *)sub_4BEB8(v9 - 16);
      v12 = v11 + 1;
      if ( !v11 )
        return 0;
      if ( v11[1] != -1 )
      {
        do
          v8 = __ldrex(v12);
        while ( __strex(v8 + 1, v12) );
        __dmb(0xBu);
      }
      if ( sub_4EE2C(a1, v10, v11) )
        return -1;
      if ( !*a2 )
      {
        v6 = sub_4BE98(v4, (int)(v10 - 16));
        if ( v6 )
          continue;
      }
      return 0;
    }
  }
  return 0;
}

//----- (0004F148) --------------------------------------------------------
int __fastcall sub_4F148(_DWORD *a1, _DWORD *a2)
{
  _BOOL4 v3; // r3
  int v4; // r9
  int i; // r0
  unsigned int *v7; // r3
  unsigned int v8; // r2
  int v9; // r0
  char *v10; // r4
  _DWORD *v11; // r6

  if ( !a1 )
    return -1;
  v3 = a2 == 0;
  if ( *a1 )
    v3 = 1;
  if ( v3 || *a2 )
    return -1;
  v4 = (int)(a2 + 2);
  for ( i = sub_4BE20((int)(a2 + 2)); i; i = sub_4BE98(v4, (int)(v10 - 16)) )
  {
    v9 = sub_4BEB0(i);
    v10 = (char *)v9;
    if ( !v9 )
      break;
    v11 = (_DWORD *)sub_4BEB8(v9 - 16);
    if ( !v11 )
      break;
    if ( sub_4E234(a1, v10) )
    {
      v7 = v11 + 1;
      if ( v11[1] != -1 )
      {
        do
          v8 = __ldrex(v7);
        while ( __strex(v8 + 1, v7) );
        __dmb(0xBu);
      }
      sub_4EE2C(a1, v10, v11);
    }
    if ( *a2 )
      break;
  }
  return 0;
}

//----- (0004F238) --------------------------------------------------------
int __fastcall sub_4F238(_DWORD *a1, unsigned int a2, _DWORD *a3)
{
  int v6; // r2
  int result; // r0
  unsigned int *v8; // r3
  unsigned int v9; // r2
  unsigned int v10; // r2
  char *v11; // r8
  char *v12; // r0
  int v13; // r7
  int v14; // r3
  unsigned int *v15; // r3
  unsigned int v16; // r2

  if ( !a3 )
    return -1;
  if ( !a1 )
    goto LABEL_6;
  v6 = a3 == a1;
  if ( *a1 != 1 )
    v6 |= 1u;
  if ( v6 || a1[3] < a2 )
  {
LABEL_6:
    if ( a3[1] == -1 )
      return -1;
    v8 = a3 + 1;
    __dmb(0xBu);
    do
    {
      v9 = __ldrex(v8);
      v10 = v9 - 1;
    }
    while ( __strex(v10, v8) );
LABEL_10:
    if ( !v10 )
    {
      sub_4EB6C(a3);
      return -1;
    }
    return -1;
  }
  v11 = (char *)sub_4E0B8(a1, 1, 0);
  if ( !v11 )
  {
    if ( a3[1] == -1 )
      return -1;
    v15 = a3 + 1;
    __dmb(0xBu);
    do
    {
      v16 = __ldrex(v15);
      v10 = v16 - 1;
    }
    while ( __strex(v10, v15) );
    goto LABEL_10;
  }
  v12 = (char *)a1[4];
  v13 = 4 * (a2 + 1);
  if ( v12 == v11 )
  {
    memmove(&v12[v13], &v11[v13 - 4], 4 * (a1[3] - a2));
  }
  else
  {
    memcpy(v12, v11, v13 - 4);
    memcpy((void *)(a1[4] + v13), &v11[v13 - 4], 4 * (a1[3] - a2));
    sub_4D898((int)v11);
  }
  result = 0;
  v14 = a1[3] + 1;
  *(_DWORD *)(a1[4] + v13 - 4) = a3;
  a1[3] = v14;
  return result;
}

//----- (0004F494) --------------------------------------------------------
int __fastcall sub_4F494(_DWORD *a1, _DWORD *a2)
{
  _BOOL4 v4; // r5
  int result; // r0
  unsigned int *v6; // r3
  unsigned int v7; // r2
  unsigned int v8; // r2
  int v9; // r3
  unsigned int *v10; // r3
  unsigned int v11; // r2

  if ( !a2 )
    return -1;
  if ( !a1 )
    goto LABEL_6;
  v4 = a2 == a1;
  if ( *a1 != 1 )
    v4 = 1;
  if ( !v4 )
  {
    if ( sub_4E0B8(a1, 1, 1) )
    {
      v9 = a1[3];
      result = 0;
      *(_DWORD *)(a1[4] + 4 * v9) = a2;
      a1[3] = v9 + 1;
      return result;
    }
    if ( a2[1] == -1 )
      return -1;
    v10 = a2 + 1;
    __dmb(0xBu);
    do
    {
      v11 = __ldrex(v10);
      v8 = v11 - 1;
    }
    while ( __strex(v8, v10) );
  }
  else
  {
LABEL_6:
    if ( a2[1] == -1 )
      return -1;
    v6 = a2 + 1;
    __dmb(0xBu);
    do
    {
      v7 = __ldrex(v6);
      v8 = v7 - 1;
    }
    while ( __strex(v8, v6) );
  }
  if ( v8 )
    return -1;
  sub_4EB6C(a2);
  return -1;
}

//----- (0004F570) --------------------------------------------------------
bool __fastcall sub_4F570(int *a1, int *a2)
{
  bool v2; // zf

  v2 = a2 == 0;
  if ( a2 )
    v2 = a1 == 0;
  return !v2 && sub_4E25C(a1, a2);
}

//----- (0004F588) --------------------------------------------------------
_DWORD *__fastcall sub_4F588(int a1)
{
  _DWORD *v2; // r7
  int i; // r0
  unsigned int v4; // r1
  int v5; // r0
  char *v6; // r5
  _DWORD *v7; // r0
  unsigned int *v8; // r3
  unsigned int v9; // r3
  unsigned int j; // r5
  _DWORD *v11; // r1
  unsigned int *v12; // r2
  unsigned int v13; // r3

  if ( a1 )
  {
    switch ( *(_DWORD *)a1 )
    {
      case 0:
        v2 = sub_4E1B0();
        if ( !v2 )
          return 0;
        if ( !*(_DWORD *)a1 )
        {
          for ( i = sub_4BE20(a1 + 8); i; i = sub_4BE98(a1 + 8, (int)(v6 - 16)) )
          {
            v5 = sub_4BEB0(i);
            v6 = (char *)v5;
            if ( !v5 )
              break;
            v7 = (_DWORD *)sub_4BEB8(v5 - 16);
            v8 = v7 + 1;
            if ( !v7 )
              break;
            if ( v7[1] != -1 )
            {
              do
                v4 = __ldrex(v8);
              while ( __strex(v4 + 1, v8) );
              __dmb(0xBu);
            }
            sub_4EE2C(v2, v6, v7);
            if ( *(_DWORD *)a1 )
              break;
          }
        }
        return v2;
      case 1:
        v2 = sub_4E540();
        if ( !v2 )
          return 0;
        if ( *(_DWORD *)a1 == 1 )
        {
          v9 = *(_DWORD *)(a1 + 12);
          if ( v9 )
          {
            for ( j = 0; j < v9; ++j )
            {
              v11 = 0;
              if ( v9 > j )
              {
                v11 = *(_DWORD **)(*(_DWORD *)(a1 + 16) + 4 * j);
                v12 = v11 + 1;
                if ( v11 )
                {
                  if ( v11[1] != -1 )
                  {
                    do
                      v13 = __ldrex(v12);
                    while ( __strex(v13 + 1, v12) );
                    __dmb(0xBu);
                  }
                }
              }
              sub_4F494(v2, v11);
              if ( *(_DWORD *)a1 != 1 )
                break;
              v9 = *(_DWORD *)(a1 + 12);
            }
          }
        }
        return v2;
      case 2:
        return sub_4E144(*(_BYTE **)(a1 + 8), *(_DWORD *)(a1 + 12), 0);
      case 3:
        return (_DWORD *)sub_4E068(a1);
      case 4:
        return (_DWORD *)sub_4EA14();
      case 5:
      case 6:
      case 7:
        return (_DWORD *)a1;
      default:
        return 0;
    }
  }
  return 0;
}
// 4F5A0: control flows out of bounds to 4F5A4

//----- (0004F744) --------------------------------------------------------
_DWORD *__fastcall sub_4F744(int a1)
{
  _DWORD *v2; // r6
  int i; // r5
  char *v4; // r7
  int v5; // r0
  _DWORD *v6; // r0
  unsigned int v7; // r3
  unsigned int j; // r5
  int v9; // r0
  _DWORD *v10; // r0

  if ( a1 )
  {
    switch ( *(_DWORD *)a1 )
    {
      case 0:
        v2 = sub_4E1B0();
        if ( !v2 )
          return 0;
        if ( !*(_DWORD *)a1 )
        {
          for ( i = sub_4BE20(a1 + 8); i; i = sub_4BE98(a1 + 8, i) )
          {
            v4 = (char *)sub_4BEB0(i);
            v5 = sub_4BEB8(i);
            v6 = (_DWORD *)sub_4F744(v5);
            sub_4EE2C(v2, v4, v6);
            if ( *(_DWORD *)a1 )
              break;
          }
        }
        return v2;
      case 1:
        v2 = sub_4E540();
        if ( !v2 )
          return 0;
        if ( *(_DWORD *)a1 == 1 )
        {
          v7 = *(_DWORD *)(a1 + 12);
          if ( v7 )
          {
            for ( j = 0; j < v7; ++j )
            {
              v9 = 0;
              if ( v7 > j )
                v9 = *(_DWORD *)(*(_DWORD *)(a1 + 16) + 4 * j);
              v10 = (_DWORD *)sub_4F744(v9);
              sub_4F494(v2, v10);
              if ( *(_DWORD *)a1 != 1 )
                break;
              v7 = *(_DWORD *)(a1 + 12);
            }
          }
        }
        return v2;
      case 2:
        return sub_4E144(*(_BYTE **)(a1 + 8), *(_DWORD *)(a1 + 12), 0);
      case 3:
        return (_DWORD *)sub_4E068(a1);
      case 4:
        return (_DWORD *)sub_4EA14();
      case 5:
      case 6:
      case 7:
        return (_DWORD *)a1;
      default:
        return 0;
    }
  }
  return 0;
}
// 4F75C: control flows out of bounds to 4F760

//----- (0004F8A8) --------------------------------------------------------
char *__fastcall sub_4F8A8(int a1, char *s)
{
  size_t v4; // r0

  v4 = strlen(s);
  if ( v4 <= 0x4F )
    return strncpy((char *)(a1 + 12), s, v4 + 1);
  qmemcpy((void *)(a1 + 12), "...", 3);
  return strncpy((char *)(a1 + 15), &s[v4 - 76], 0x4Du);
}

//----- (0004F90C) --------------------------------------------------------
char *__fastcall sub_4F90C(char *result, char *a2)
{
  if ( result )
  {
    result[92] = 0;
    *((_DWORD *)result + 2) = 0;
    *(_DWORD *)result = -1;
    *((_DWORD *)result + 1) = -1;
    if ( a2 )
      return sub_4F8A8((int)result, a2);
    else
      result[12] = 0;
  }
  return result;
}

//----- (0004F94C) --------------------------------------------------------
int __fastcall sub_4F94C(int a1, char *s)
{
  bool v2; // zf

  v2 = s == 0;
  if ( s )
    v2 = a1 == 0;
  if ( !v2 )
    return (int)sub_4F8A8(a1, s);
  return a1;
}

//----- (0004F95C) --------------------------------------------------------
int sub_4F95C(int result, int a2, int a3, int a4, int a5, char *format, ...)
{
  int v6; // r4
  va_list arg; // [sp+20h] [bp+8h] BYREF

  va_start(arg, format);
  v6 = result;
  if ( result )
  {
    if ( !*(_BYTE *)(result + 92) )
    {
      *(_DWORD *)result = a2;
      *(_DWORD *)(result + 4) = a3;
      *(_DWORD *)(result + 8) = a4;
      result = vsnprintf((char *)(result + 92), 0x9Fu, format, arg);
      *(_BYTE *)(v6 + 250) = 0;
      *(_BYTE *)(v6 + 251) = a5;
    }
  }
  return result;
}

//----- (0004F9C0) --------------------------------------------------------
int __fastcall sub_4F9C0(int result, int a2, int a3, int a4, int a5, char *format, __gnuc_va_list arg)
{
  int v7; // r4

  v7 = result;
  if ( result )
  {
    if ( !*(_BYTE *)(result + 92) )
    {
      *(_DWORD *)result = a2;
      *(_DWORD *)(result + 4) = a3;
      *(_DWORD *)(result + 8) = a4;
      result = vsnprintf((char *)(result + 92), 0x9Fu, format, arg);
      *(_BYTE *)(v7 + 250) = 0;
      *(_BYTE *)(v7 + 251) = a5;
    }
  }
  return result;
}

//----- (0004FA10) --------------------------------------------------------
int __fastcall sub_4FA10(int a1, int a2, unsigned int a3, unsigned int a4, int a5)
{
  int v9; // r10
  unsigned int v10; // r1
  unsigned int v11; // r2
  int v12; // r0
  char v14[44]; // [sp+Ch] [bp-2Ch] BYREF

  v9 = sub_51CAC(a2, a3, a4, a5, v14);
  if ( v9 )
    return -1;
  sub_51E54(a1, (int)v14, 9u);
  if ( a2 == 1 )
  {
    v10 = a1;
    v11 = 0;
    v12 = 0;
  }
  else
  {
    v11 = a3;
    v10 = a1;
    v12 = 1;
  }
  sub_51B44(v12, v10, v11, a4, a5);
  return v9;
}

//----- (0004FA9C) --------------------------------------------------------
int __fastcall sub_4FA9C(int a1, int a2, unsigned int a3, unsigned int a4, char a5, char a6, char a7, __int16 a8)
{
  if ( a4 > 3 )
    return -1;
  else
    return sub_4FA10(
             a1,
             a2,
             a3,
             (unsigned __int8)aDh[a4],
             a6 & 7 | 0x40000000 | (unsigned __int8)(16 * (a5 & 7)) | ((a7 & 0x3F) << 8) | ((a8 & 0xFFF) << 16));
}

//----- (0004FAEC) --------------------------------------------------------
int __fastcall sub_4FAEC(int a1, int a2, unsigned int a3)
{
  sub_4FA10(a1, a2, a3, 0x3Cu, -2147449569);
  usleep(0x2710u);
  return sub_4FA10(a1, a2, a3, 0x3Cu, -2147482112);
}

//----- (0004FB64) --------------------------------------------------------
int __fastcall sub_4FB64(int a1, int a2, unsigned int a3, char a4)
{
  int v5; // r4

  v5 = a4 & 3 | 0x80008104;
  sub_4FA10(a1, a2, a3, 0x3Cu, v5);
  usleep(0x2710u);
  return sub_4FA10(a1, a2, a3, 0x3Cu, v5 & 0xFFFF70FF | 0x200);
}

//----- (0004FBDC) --------------------------------------------------------
int __fastcall sub_4FBDC(int a1, int a2, unsigned int a3, unsigned __int8 a4, unsigned __int8 a5)
{
  return sub_4FA10(a1, a2, a3, 0x3Cu, (a5 << 16) & 0x7FFF7B55 | 0x84AA | (a4 << 31));
}

//----- (0004FC14) --------------------------------------------------------
int __fastcall sub_4FC14(unsigned int a1, int a2, unsigned int a3)
{
  int v7[5]; // [sp+Ch] [bp-14h] BYREF

  sub_4FA10(a1, a2, a3, 0xBCu, 320);
  usleep(0x2710u);
  if ( a2 )
    sub_51A20(0, a1, 0, 0xB0u, v7);
  else
    sub_51A20(1, a1, a3, 0xB0u, v7);
  v7[0] = 545009931;
  sub_4FA10(a1, a2, a3, 0xB0u, 545009931);
  usleep(0x2710u);
  return 0;
}

//----- (0004FCBC) --------------------------------------------------------
int __fastcall sub_4FCBC(unsigned int a1, int a2, unsigned int a3, char a4)
{
  int v9[7]; // [sp+Ch] [bp-1Ch] BYREF

  sub_4FA10(a1, a2, a3, 0xBCu, 504);
  usleep(0x2710u);
  if ( a2 )
    sub_51A20(0, a1, 0, 0xB0u, v9);
  else
    sub_51A20(1, a1, a3, 0xB0u, v9);
  HIBYTE(v9[0]) = HIBYTE(v9[0]) & 0x13 | 0x20;
  LOBYTE(v9[0]) = v9[0] & 0xB4 | 0x43;
  BYTE2(v9[0]) = BYTE2(v9[0]) & 0x83 | 0x78;
  BYTE1(v9[0]) = BYTE1(v9[0]) & 0xC0 | 0x31;
  sub_4FA10(a1, a2, a3, 0xB0u, v9[0]);
  usleep(0x2710u);
  sub_4FA10(a1, a2, a3, 0xBCu, a4 & 7 | 0x1F8);
  usleep(0x2710u);
  sub_4FA10(a1, a2, a3, 0xB0u, v9[0]);
  usleep(0x2710u);
  return 0;
}

//----- (0004FDF0) --------------------------------------------------------
int __fastcall sub_4FDF0(int a1, int a2, unsigned int a3, char a4, char a5, char a6)
{
  unsigned __int8 v6; // r12

  if ( a6 )
    v6 = (16 * (a4 & 3)) & 0x3F | ((a5 & 3) << 6) | 1;
  else
    v6 = (16 * (a4 & 3)) & 0x3E | ((a5 & 3) << 6);
  return sub_4FA10(a1, a2, a3, 0x3Cu, v6 | 0x80008000);
}

//----- (0004FE30) --------------------------------------------------------
int __fastcall sub_4FE30(int a1, int a2, unsigned int a3, int a4)
{
  if ( a4 )
    LOBYTE(a4) = 64;
  return sub_4FA10(a1, a2, a3, 0x3Cu, (unsigned __int8)a4 | 0x80008D00);
}

//----- (0004FE70) --------------------------------------------------------
int __fastcall sub_4FE70(int a1)
{
  _BYTE v3[16]; // [sp+0h] [bp-10h] BYREF

  if ( sub_51E08(v3) )
    return -1;
  else
    return sub_51E54(a1, (int)v3, 5u);
}

//----- (0004FEAC) --------------------------------------------------------
int __fastcall sub_4FEAC(int a1, char a2)
{
  _BYTE v4[16]; // [sp+0h] [bp-10h] BYREF

  if ( sub_51D44(a2, v4) )
    return -1;
  else
    return sub_51E54(a1, (int)v4, 5u);
}

//----- (0004FEF0) --------------------------------------------------------
int __fastcall sub_4FEF0(int a1, int a2, char a3, char a4)
{
  _BYTE v6[16]; // [sp+0h] [bp-10h] BYREF

  if ( sub_51D98(a2, a3, a4, v6) )
    return -1;
  else
    return sub_51E54(a1, (int)v6, 5u);
}

//----- (0004FF3C) --------------------------------------------------------
int __fastcall sub_4FF3C(int a1)
{
  return sub_4FEF0(a1, 1, 0, 0);
}

//----- (0004FF50) --------------------------------------------------------
int __fastcall sub_4FF50(int a1, unsigned int a2)
{
  char v3; // r8
  unsigned int v4; // r6
  int v5; // r4
  char v6; // r5

  v3 = a2;
  v4 = sub_5F880(0x100u, a2);
  if ( v4 )
  {
    v5 = 0;
    v6 = 0;
    do
    {
      sub_4FEAC(a1, v6);
      ++v5;
      usleep(0x2710u);
      v6 += v3;
    }
    while ( v5 != v4 );
  }
  return 0;
}

//----- (0004FFA0) --------------------------------------------------------
int __fastcall sub_4FFA0(int a1, char a2, int a3)
{
  int v4; // r4
  char v7; // r5

  if ( a3 )
  {
    v4 = 0;
    v7 = 0;
    do
    {
      sub_4FEAC(a1, v7);
      ++v4;
      usleep(0x2710u);
      v7 += a2;
    }
    while ( a3 != v4 );
  }
  return 0;
}

//----- (0004FFE8) --------------------------------------------------------
int __fastcall sub_4FFE8(unsigned int a1, unsigned int a2)
{
  bool v3; // cc
  unsigned int v5; // r1
  unsigned __int8 v6; // r7
  unsigned int v8; // r6
  int v9; // [sp+Ch] [bp-24h] BYREF
  int v10; // [sp+10h] [bp-20h] BYREF
  int v11; // [sp+14h] [bp-1Ch] BYREF

  v3 = a2 > (unsigned int)&unk_2DC6C0;
  v5 = 8 * a2;
  if ( v3 )
  {
    v6 = sub_5F880(0x5F5E100u, v5) - 1;
    sub_51A20(0, a1, 0, 0x68u, &v10);
    sub_51A20(0, a1, 0, 0x28u, &v11);
    HIBYTE(v10) = HIBYTE(v10) & 0x9F | 0x40;
    LOBYTE(v10) = v10 & 0x88 | 0x11;
    BYTE1(v10) = BYTE1(v10) & 0xC0 | 1;
    HIWORD(v10) = HIWORD(v10) & 0xF000 | 0x70;
    sub_4FA10(a1, 1, 0, 0x68u, v10);
    usleep(0x2710u);
    sub_4FA10(a1, 1, 0, 0x68u, v10);
    usleep(0x2710u);
    BYTE2(v11) = 3;
    LOBYTE(v11) = 15;
    HIBYTE(v11) = HIBYTE(v11) & 0x30 | 6;
    BYTE1(v11) = ~((unsigned int)~(BYTE1(v11) << 25) >> 25) & 0x8F;
    sub_4FA10(a1, 1, 0, 0x28u, v11);
    usleep(0x2710u);
    sub_51A20(0, a1, 0, 0x18u, &v9);
    HIBYTE(v9) = HIBYTE(v9) & 0xF0 | (v6 >> 5) & 0xF;
    BYTE1(v9) = BYTE1(v9) & 0xE0 | v6 & 0x1F;
    BYTE2(v9) |= 1u;
  }
  else
  {
    v8 = (unsigned __int8)(sub_5F880(0x17D7840u, v5) - 1);
    sub_51A20(0, a1, 0, 0x18u, &v9);
    HIBYTE(v9) = HIBYTE(v9) & 0xF0 | (v8 >> 5) & 0xF;
    BYTE1(v9) = BYTE1(v9) & 0xE0 | v8 & 0x1F;
    BYTE2(v9) &= ~1u;
  }
  sub_4FA10(a1, 1, 0, 0x18u, v9);
  usleep(0xC350u);
  sub_45CBC(a1, a2);
  return 0;
}

//----- (0005021C) --------------------------------------------------------
int __fastcall sub_5021C(int a1, unsigned int a2)
{
  return sub_4FA10(
           a1,
           1,
           0,
           0x14u,
           (unsigned __int8)aDh[(unsigned __int8)a2 + 4] | (unsigned __int16)((unsigned __int8)aDh[BYTE1(a2) + 4] << 8) | ((unsigned __int8)aDh[BYTE2(a2) + 4] << 16) & 0xFFFFFF | ((unsigned __int8)aDh[HIBYTE(a2) + 4] << 24));
}

//----- (00050288) --------------------------------------------------------
int __fastcall sub_50288(int a1, int a2, unsigned __int16 a3)
{
  int v3; // r3

  if ( a2 )
    v3 = 0x80000000;
  else
    v3 = 0;
  if ( !a2 )
    v3 = v3 & 0x7FFFFFFF | ((unsigned __int8)v3 << 31);
  return sub_4FA10(a1, 1, 0, 0xCu, v3 & 0xFFFF0000 | a3);
}

//----- (000502C0) --------------------------------------------------------
int __fastcall sub_502C0(int a1, _BYTE *a2, float *a3)
{
  float v3; // s0
  int v4; // r12
  int v5; // r4
  int v7; // r5
  int v8; // r8
  int v9; // r2
  int v10; // r9
  int v11; // r11
  float v12; // s11
  int v14; // r1
  float v15; // s13
  int v16; // r0
  int v17; // lr
  int v18; // r3
  float v19; // s7
  int v20; // s14
  float v21; // s15
  float v22; // s15
  float v23; // s16
  int result; // r0

  v4 = 2;
  v5 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 2;
  v10 = 0;
  v11 = 0;
  v12 = 10.0;
  while ( 1 )
  {
    v14 = 1;
    v15 = (float)v9;
    do
    {
      v16 = v14 * v14;
      v17 = (unsigned __int8)v14;
      v18 = v14;
      v19 = (float)v14 * v3;
      do
      {
        v20 = (int)((float)((float)((float)((float)v18 * v19) * v15) / 25.0) + 0.5);
        if ( (unsigned int)(v20 - 16) <= 0xEA )
        {
          v21 = (float)v20 * (float)(25.0 / (float)v9);
          if ( (v9 != 1 || v21 <= 3125.0) && v21 <= 3200.0 && v21 >= 2000.0 )
          {
            v22 = fabsf(v3 - (float)(v21 / (float)v16));
            if ( v22 < v12 )
            {
              v8 = (unsigned __int8)v14;
              v10 = v17;
              v12 = v22;
              v11 = v9;
              v5 = (int)((float)((float)((float)((float)v18 * v19) * v15) / 25.0) + 0.5);
              v7 = 1;
            }
          }
        }
        ++v18;
        v16 += v14;
        v17 = (unsigned __int8)v18;
      }
      while ( (unsigned __int8)v18 != 8 );
      ++v14;
    }
    while ( v14 != 8 );
    v9 = 1;
    if ( v4 == 1 )
      break;
    v4 = 1;
  }
  if ( v5 )
  {
    v23 = (float)((float)(25.0 / (float)v11) * (float)v5) / (float)(v7 * (__int16)v10 * (__int16)v8);
    if ( a3 )
      *a3 = v23;
    printf(
      "final refdiv: %d, fbdiv: %d, postdiv1: %d, postdiv2: %d, usr divider: %d, min diff value: %f\n",
      v11,
      v5,
      v10,
      v8,
      v7,
      v12);
    printf("Want freq: %f, Real freq: %f\n", v3, v23);
    result = 0;
    *(_BYTE *)a1 = v10;
    *(_BYTE *)(a1 + 1) = v8;
    *(_BYTE *)(a1 + 2) = v11;
    *(_WORD *)(a1 + 4) = v5;
    *a2 = v7;
    a2[1] = v7;
    a2[2] = v7;
    a2[3] = v7;
  }
  else
  {
    puts("find div fail, use default value");
    return -1;
  }
  return result;
}
// 5033C: variable 'v3' is possibly undefined

//----- (000504E8) --------------------------------------------------------
int __fastcall sub_504E8(int a1, int a2, unsigned int a3, unsigned int a4, float a5)
{
  char v10[4]; // [sp+14h] [bp-24h] BYREF
  char v11[4]; // [sp+18h] [bp-20h] BYREF
  __int16 v12; // [sp+1Ch] [bp-1Ch]

  if ( sub_502C0((int)v11, v10, 0) )
    return -1;
  else
    return sub_4FA9C(a1, a2, a3, a4, v11[0], v11[1], v11[2], v12);
}
// 504E8: using guessed type char var_24[4];

//----- (00050560) --------------------------------------------------------
int __fastcall sub_50560(int a1, unsigned int a2, int a3, __int16 a4)
{
  return sub_4FA9C(a1, 1, 0, a2, a3, SBYTE1(a3), SBYTE2(a3), a4);
}

//----- (000505A4) --------------------------------------------------------
int __fastcall sub_505A4(int a1, unsigned int a2, unsigned int a3, int a4, __int16 a5)
{
  return sub_4FA9C(a1, 0, a2, a3, a4, SBYTE1(a4), SBYTE2(a4), a5);
}

//----- (000505F4) --------------------------------------------------------
int __fastcall sub_505F4(unsigned int a1, unsigned int a2, unsigned int a3, char a4, char a5)
{
  unsigned int v7; // r8
  int v10[7]; // [sp+Ch] [bp-1Ch] BYREF

  if ( a3 > 3 )
    return -1;
  v7 = (unsigned __int8)aDh[a3];
  sub_51A20(1, a1, a2, v7, v10);
  LOBYTE(v10[0]) = v10[0] & 0x88 | (16 * (a4 & 7)) | a5 & 7;
  return sub_4FA10(a1, 0, a2, v7, v10[0]);
}
// 505F4: using guessed type int var_1C[7];

//----- (000506F8) --------------------------------------------------------
int __fastcall sub_506F8(unsigned int a1, unsigned int a2, unsigned int a3, __int16 a4)
{
  char v4; // r6
  char v5; // r7
  unsigned int v7; // r8
  int v10; // [sp+14h] [bp-1Ch] BYREF

  v4 = HIBYTE(a4);
  if ( a3 > 3 )
    return -1;
  v5 = a4;
  v7 = (unsigned __int8)aDh[a3 + 260];
  sub_51A20(1, a1, a2, v7, &v10);
  LOBYTE(v10) = v10 & 0x30 | v5 & 0xF;
  BYTE1(v10) = BYTE1(v10) & 0x30 | v4 & 0xF;
  return sub_4FA10(a1, 0, a2, v7, v10);
}

//----- (00050794) --------------------------------------------------------
int __fastcall sub_50794(unsigned int a1, unsigned int a2, __int16 a3)
{
  char v3; // r5
  char v5; // r6
  unsigned int v6; // r7
  int v8; // [sp+14h] [bp-1Ch] BYREF

  v3 = HIBYTE(a3);
  if ( a2 > 3 )
    return -1;
  v5 = a3;
  v6 = (unsigned __int8)aDh[a2 + 260];
  sub_51A20(0, a1, 0, v6, &v8);
  LOBYTE(v8) = v8 & 0x30 | v5 & 0xF;
  BYTE1(v8) = BYTE1(v8) & 0x30 | v3 & 0xF;
  return sub_4FA10(a1, 1, 0, v6, v8);
}

//----- (0005082C) --------------------------------------------------------
int __fastcall sub_5082C(int a1, unsigned int a2, unsigned int a3, float a4)
{
  return sub_504E8(a1, 0, a2, a3, a4);
}

//----- (00050850) --------------------------------------------------------
int __fastcall sub_50850(int a1, unsigned int a2, float a3)
{
  return sub_504E8(a1, 1, 0, a2, a3);
}

//----- (00050874) --------------------------------------------------------
int __fastcall sub_50874(int a1, unsigned int a2, char a3)
{
  return sub_4FA10(a1, 0, a2, 0x54u, a3 & 7);
}

//----- (000508A0) --------------------------------------------------------
int __fastcall sub_508A0(int a1, char a2)
{
  return sub_4FA10(a1, 1, 0, 0x54u, a2 & 7);
}

//----- (000508CC) --------------------------------------------------------
int __fastcall sub_508CC(int a1)
{
  return sub_4FEF0(a1, 1, 0, 72);
}

//----- (000508DC) --------------------------------------------------------
int sub_508DC()
{
  return 0;
}

//----- (000508E4) --------------------------------------------------------
int __fastcall sub_508E4(unsigned int a1, int a2, int a3, __int16 a4)
{
  char v8; // r3
  int v10; // [sp+Ch] [bp-1Ch] BYREF

  sub_51A20(0, a1, 0, 0xA4u, &v10);
  if ( a2 )
    v8 = HIBYTE(v10) | 0x80;
  else
    v8 = HIBYTE(v10) & 0x7F;
  HIBYTE(v10) = v8;
  switch ( a3 )
  {
    case 4:
      HIBYTE(v10) &= 0xCFu;
      break;
    case 8:
      HIBYTE(v10) = HIBYTE(v10) & 0xCF | 0x10;
      break;
    case 12:
      HIBYTE(v10) = HIBYTE(v10) & 0xCF | 0x20;
      break;
    default:
      return -1;
  }
  LOWORD(v10) = a4;
  HIBYTE(v10) &= ~0x40u;
  return sub_4FA10(a1, 1, 0, 0xA4u, v10);
}

//----- (00050A80) --------------------------------------------------------
int __fastcall sub_50A80(unsigned int a1, unsigned int a2, int a3)
{
  char v6; // r3
  int v8; // [sp+Ch] [bp-14h] BYREF

  sub_51A20(1, a1, a2, 0x18u, &v8);
  if ( a3 )
    v6 = BYTE1(v8) | 0x20;
  else
    v6 = BYTE1(v8) & 0xDF;
  BYTE1(v8) = v6;
  return sub_4FA10(a1, 0, a2, 0x18u, v8);
}

//----- (00050B48) --------------------------------------------------------
int __fastcall sub_50B48(unsigned int a1, char a2)
{
  int v5; // [sp+Ch] [bp-14h] BYREF

  sub_51A20(0, a1, 0, 0x58u, &v5);
  BYTE1(v5) = BYTE1(v5) & 0xF | (16 * (a2 & 0xF));
  return sub_4FA10(a1, 1, 0, 0x58u, v5);
}

//----- (00050BA4) --------------------------------------------------------
int sub_50BA4()
{
  return -1;
}

//----- (00050BAC) --------------------------------------------------------
int sub_50BAC()
{
  return -1;
}

//----- (00050BB4) --------------------------------------------------------
int sub_50BB4()
{
  return -1;
}

//----- (00050BBC) --------------------------------------------------------
int sub_50BBC()
{
  return -1;
}

//----- (00050BC4) --------------------------------------------------------
int sub_50BC4()
{
  return -1;
}

//----- (00050BCC) --------------------------------------------------------
int sub_50BCC()
{
  return -1;
}

//----- (00050BD4) --------------------------------------------------------
int __fastcall sub_50BD4(unsigned int a1, int a2)
{
  char v4; // r3
  int v6; // [sp+Ch] [bp-14h] BYREF

  sub_51A20(0, a1, 0, 0x18u, &v6);
  if ( a2 )
    v4 = BYTE1(v6) | 0x80;
  else
    v4 = BYTE1(v6) & 0x7F;
  BYTE1(v6) = v4;
  return sub_4FA10(a1, 1, 0, 0x18u, v6);
}

//----- (00050C38) --------------------------------------------------------
int __fastcall sub_50C38(unsigned int a1, int a2)
{
  int v5; // [sp+Ch] [bp-14h] BYREF

  sub_51A20(0, a1, 0, 0x18u, &v5);
  if ( a2 )
  {
    BYTE2(v5) |= 0x40u;
    HIBYTE(v5) &= 0xFu;
  }
  else
  {
    BYTE2(v5) &= ~0x40u;
    HIBYTE(v5) |= 0xF0u;
  }
  return sub_4FA10(a1, 1, 0, 0x18u, v5);
}

//----- (00050CC4) --------------------------------------------------------
int __fastcall sub_50CC4(unsigned int a1, unsigned int a2, int a3)
{
  int v7; // [sp+Ch] [bp-14h] BYREF

  sub_51A20(1, a1, a2, 0x18u, &v7);
  if ( a3 )
  {
    BYTE2(v7) |= 0x40u;
    HIBYTE(v7) &= 0xFu;
  }
  else
  {
    BYTE2(v7) &= ~0x40u;
    HIBYTE(v7) |= 0xF0u;
  }
  return sub_4FA10(a1, 0, a2, 0x18u, v7);
}

//----- (00050D54) --------------------------------------------------------
int __fastcall sub_50D54(int a1, int a2)
{
  return sub_4FA10(a1, 1, 0, 0x10u, a2);
}

//----- (00050D78) --------------------------------------------------------
int __fastcall sub_50D78(int a1, unsigned int a2, int a3)
{
  return sub_4FA10(a1, 0, a2, 0x10u, a3);
}

//----- (00050D9C) --------------------------------------------------------
int __fastcall sub_50D9C(int a1)
{
  return sub_4FAEC(a1, 1, 0);
}

//----- (00050DA8) --------------------------------------------------------
int __fastcall sub_50DA8(int a1, unsigned int a2)
{
  return sub_4FAEC(a1, 0, a2);
}

//----- (00050DB4) --------------------------------------------------------
int __fastcall sub_50DB4(int a1, char a2)
{
  return sub_4FB64(a1, 1, 0, a2);
}

//----- (00050DC4) --------------------------------------------------------
int __fastcall sub_50DC4(int a1, unsigned int a2, char a3)
{
  return sub_4FB64(a1, 0, a2, a3);
}

//----- (00050DD4) --------------------------------------------------------
int __fastcall sub_50DD4(int a1)
{
  return sub_4FBDC(a1, 1, 0, 1u, 0);
}

//----- (00050DF8) --------------------------------------------------------
int __fastcall sub_50DF8(int a1, unsigned int a2)
{
  return sub_4FBDC(a1, 0, a2, 1u, 0);
}

//----- (00050E20) --------------------------------------------------------
int __fastcall sub_50E20(int a1, unsigned __int8 a2)
{
  return sub_4FBDC(a1, 1, 0, 0, a2);
}

//----- (00050E44) --------------------------------------------------------
int __fastcall sub_50E44(int a1, unsigned int a2, unsigned __int8 a3)
{
  return sub_4FBDC(a1, 0, a2, 0, a3);
}

//----- (00050E68) --------------------------------------------------------
int sub_50E68()
{
  return -1;
}

//----- (00050E70) --------------------------------------------------------
int sub_50E70()
{
  return -1;
}

//----- (00050E78) --------------------------------------------------------
int __fastcall sub_50E78(unsigned int a1)
{
  int v3; // [sp+Ch] [bp-Ch] BYREF

  sub_51A20(0, a1, 0, 0x90u, &v3);
  BYTE1(v3) |= 8u;
  return sub_4FA10(a1, 1, 0, 0x90u, v3);
}

//----- (00050ED0) --------------------------------------------------------
int __fastcall sub_50ED0(unsigned int a1)
{
  int v3; // [sp+Ch] [bp-Ch] BYREF

  sub_51A20(0, a1, 0, 0x34u, &v3);
  LOBYTE(v3) = v3 | 1;
  return sub_4FA10(a1, 1, 0, 0x34u, v3);
}

//----- (00050F28) --------------------------------------------------------
int __fastcall sub_50F28(unsigned int a1)
{
  int v3; // [sp+Ch] [bp-Ch] BYREF

  sub_51A20(0, a1, 0, 0x34u, &v3);
  LOBYTE(v3) = v3 & 0xFE;
  return sub_4FA10(a1, 1, 0, 0x34u, v3);
}

//----- (00050F80) --------------------------------------------------------
int __fastcall sub_50F80(int a1, int a2)
{
  return sub_4FA10(a1, 1, 0, 0x9Cu, a2);
}

//----- (00050FA4) --------------------------------------------------------
int __fastcall sub_50FA4(int a1, char a2)
{
  return sub_4FA10(a1, 1, 0, 0x90u, (16 * ((a2 - 1) & 7)) | 0x38001801);
}

//----- (00050FDC) --------------------------------------------------------
int __fastcall sub_50FDC(unsigned int a1)
{
  int v3; // [sp+Ch] [bp-Ch] BYREF

  sub_51A20(0, a1, 0, 0x90u, &v3);
  LOBYTE(v3) = v3 | 0x8A;
  HIBYTE(v3) |= 8u;
  BYTE1(v3) &= ~8u;
  return sub_4FA10(a1, 1, 0, 0x90u, v3);
}

//----- (000510C8) --------------------------------------------------------
int __fastcall sub_510C8(int a1)
{
  return sub_4FEF0(a1, 1, 0, 144);
}

//----- (0005112C) --------------------------------------------------------
int __fastcall sub_5112C(int a1)
{
  return sub_4FEF0(a1, 1, 0, 152);
}

//----- (0005113C) --------------------------------------------------------
int __fastcall sub_5113C(int a1)
{
  return sub_4FEF0(a1, 1, 0, 160);
}

//----- (0005114C) --------------------------------------------------------
int __fastcall sub_5114C(int a1)
{
  return sub_4FEF0(a1, 1, 0, 224);
}

//----- (0005115C) --------------------------------------------------------
int sub_5115C()
{
  return -1;
}

//----- (00051164) --------------------------------------------------------
int __fastcall sub_51164(unsigned int a1, unsigned int a2)
{
  int v5; // [sp+Ch] [bp-14h] BYREF

  sub_51A20(1, a1, a2, 0x18u, &v5);
  BYTE1(v5) |= 0x40u;
  LOBYTE(v5) = v5 & 0x8F | 0x30;
  return sub_4FA10(a1, 0, a2, 0x18u, v5);
}

//----- (000511D0) --------------------------------------------------------
int __fastcall sub_511D0(int a1, unsigned int a2, unsigned __int8 a3, unsigned __int8 a4)
{
  return sub_4FA10(a1, 0, a2, 0x1Cu, (unsigned __int16)(a4 << 8) | (a3 >> 1 << 17) & 0x39FFFFFF | 0x1000000);
}

//----- (0005121C) --------------------------------------------------------
int __fastcall sub_5121C(int a1, unsigned int a2, unsigned __int8 a3, int a4, unsigned __int8 a5)
{
  return sub_4FA10(a1, 0, a2, 0x1Cu, (a5 | (a4 << 8)) & 0x3900FFFF | 0x10000 | (a3 >> 1 << 17) & 0x39FFFFFF | 0x1000000);
}

//----- (00051260) --------------------------------------------------------
int __fastcall sub_51260(int a1, unsigned int a2, unsigned __int8 a3, int a4, unsigned __int8 a5)
{
  return sub_5121C(a1, a2, a3, a4, a5);
}

//----- (0005126C) --------------------------------------------------------
int __fastcall sub_5126C(int a1, unsigned int a2, unsigned __int8 a3, unsigned __int8 a4)
{
  return sub_4FA10(a1, 0, a2, 0x44u, (unsigned __int16)(a4 << 8) | (a3 << 24));
}

//----- (0005129C) --------------------------------------------------------
int __fastcall sub_5129C(int a1, unsigned int a2, unsigned __int16 a3, char a4, char a5)
{
  return sub_4FA10(a1, 0, a2, 0x2Cu, a5 & 1 | (unsigned __int16)(2 * (a4 & 1)) | (a3 << 16));
}

//----- (000512CC) --------------------------------------------------------
int __fastcall sub_512CC(unsigned int a1, char a2)
{
  int v5; // [sp+Ch] [bp-14h] BYREF

  sub_51A20(0, a1, 0, 0x18u, &v5);
  LOBYTE(v5) = v5 & 0xF7 | (8 * (a2 & 1));
  return sub_4FA10(a1, 1, 0, 0x18u, v5);
}

//----- (00051328) --------------------------------------------------------
int __fastcall sub_51328(unsigned int a1, unsigned int a2, char a3)
{
  int v7; // [sp+Ch] [bp-14h] BYREF

  sub_51A20(1, a1, a2, 0x18u, &v7);
  LOBYTE(v7) = v7 & 0xF7 | (8 * (a3 & 1));
  return sub_4FA10(a1, 0, a2, 0x18u, v7);
}

//----- (000513FC) --------------------------------------------------------
int __fastcall sub_513FC(unsigned int a1)
{
  int v3; // [sp+Ch] [bp-Ch] BYREF

  sub_51A20(0, a1, 0, 0xB0u, &v3);
  LOBYTE(v3) = v3 & 0xBF;
  HIWORD(v3) &= 0xDFFBu;
  return sub_4FA10(a1, 1, 0, 0xB0u, v3);
}

//----- (0005146C) --------------------------------------------------------
int __fastcall sub_5146C(unsigned int a1, unsigned int a2)
{
  return sub_4FC14(a1, 0, a2);
}

//----- (00051478) --------------------------------------------------------
int __fastcall sub_51478(unsigned int a1)
{
  return sub_4FC14(a1, 1, 0);
}

//----- (00051484) --------------------------------------------------------
int __fastcall sub_51484(unsigned int a1, unsigned int a2, char a3)
{
  return sub_4FCBC(a1, 0, a2, a3);
}

//----- (00051494) --------------------------------------------------------
int __fastcall sub_51494(unsigned int a1, char a2)
{
  return sub_4FCBC(a1, 1, 0, a2);
}

//----- (000514A4) --------------------------------------------------------
int __fastcall sub_514A4(unsigned int a1)
{
  int v3; // [sp+Ch] [bp-Ch] BYREF

  sub_51A20(0, a1, 0, 0xB0u, &v3);
  LOBYTE(v3) = v3 | 0x10;
  sub_4FA10(a1, 1, 0, 0xB0u, v3);
  usleep(0x7530u);
  return 0;
}

//----- (00051508) --------------------------------------------------------
int __fastcall sub_51508(unsigned int a1, unsigned int a2)
{
  int v5; // [sp+Ch] [bp-14h] BYREF

  sub_51A20(1, a1, a2, 0xB0u, &v5);
  LOBYTE(v5) = v5 | 0x10;
  sub_4FA10(a1, 0, a2, 0xB0u, v5);
  usleep(0x7530u);
  return 0;
}

//----- (00051570) --------------------------------------------------------
int __fastcall sub_51570(int a1)
{
  return sub_4FEF0(a1, 1, 0, 176);
}

//----- (00051580) --------------------------------------------------------
int __fastcall sub_51580(int a1, char a2)
{
  return sub_4FEF0(a1, 0, a2, 176);
}

//----- (00051590) --------------------------------------------------------
int __fastcall sub_51590(int a1)
{
  return sub_4FEF0(a1, 1, 0, 180);
}

//----- (000515A0) --------------------------------------------------------
int __fastcall sub_515A0(int a1, char a2)
{
  return sub_4FEF0(a1, 0, a2, 180);
}

//----- (000515B0) --------------------------------------------------------
int __fastcall sub_515B0(int a1)
{
  return sub_4FEF0(a1, 1, 0, 184);
}

//----- (000515C0) --------------------------------------------------------
int __fastcall sub_515C0(int a1, char a2)
{
  return sub_4FEF0(a1, 0, a2, 184);
}

//----- (000515D0) --------------------------------------------------------
int __fastcall sub_515D0(int a1, unsigned int a2, char a3, char a4)
{
  return sub_4FA10(a1, 0, a2, 0x3Cu, (unsigned __int8)((16 * (a3 & 3)) | a4 & 7) | 0x80008700);
}

//----- (0005161C) --------------------------------------------------------
int __fastcall sub_5161C(int a1, char a2, char a3)
{
  return sub_4FA10(a1, 1, 0, 0x3Cu, (unsigned __int8)((16 * (a2 & 3)) | a3 & 7) | 0x80008700);
}

//----- (00051668) --------------------------------------------------------
int __fastcall sub_51668(int a1, unsigned int a2, char a3, char a4, char a5)
{
  return sub_4FDF0(a1, 0, a2, a3, a4, a5);
}

//----- (00051694) --------------------------------------------------------
int __fastcall sub_51694(int a1, char a2, char a3, char a4)
{
  return sub_4FDF0(a1, 1, 0, a2, a3, a4);
}

//----- (000516BC) --------------------------------------------------------
int __fastcall sub_516BC(int a1, unsigned int a2)
{
  return sub_4FA10(a1, 0, a2, 0x3Cu, 0x80000000);
}

//----- (000516F8) --------------------------------------------------------
int __fastcall sub_516F8(int a1, char a2)
{
  return sub_4FEF0(a1, 0, a2, 224);
}

//----- (00051708) --------------------------------------------------------
int __fastcall sub_51708(int a1, int a2)
{
  return sub_4FE30(a1, 1, 0, a2);
}

//----- (00051718) --------------------------------------------------------
int __fastcall sub_51718(int a1, unsigned int a2, int a3)
{
  return sub_4FE30(a1, 0, a2, a3);
}

//----- (00051728) --------------------------------------------------------
int __fastcall sub_51728(int a1, int a2)
{
  return sub_4FA10(a1, 1, 0, 0x80u, a2);
}

//----- (0005174C) --------------------------------------------------------
int __fastcall sub_5174C(int a1, unsigned int a2, int a3)
{
  return sub_4FA10(a1, 0, a2, 0x80u, a3);
}

//----- (00051770) --------------------------------------------------------
int __fastcall sub_51770(int a1)
{
  return sub_4FA10(a1, 1, 0, 0x80u, 0);
}

//----- (00051794) --------------------------------------------------------
int __fastcall sub_51794(int a1, unsigned int a2)
{
  return sub_4FA10(a1, 0, a2, 0x80u, 0);
}

//----- (000517BC) --------------------------------------------------------
int __fastcall sub_517BC(int a1, int a2)
{
  int v2; // r3

  if ( a2 )
    v2 = 255;
  else
    v2 = 0;
  return sub_4FA10(a1, 1, 0, 0x20u, v2);
}
// 517D4: conditional instruction was optimized away because r1.4!=0

//----- (000517F8) --------------------------------------------------------
int __fastcall sub_517F8(int a1, unsigned int a2, int a3)
{
  if ( a3 )
    LOWORD(a3) = 255;
  return sub_4FA10(a1, 0, a2, 0x20u, (unsigned __int16)a3);
}

//----- (000518F8) --------------------------------------------------------
int sub_518F8()
{
  return -1;
}

//----- (00051900) --------------------------------------------------------
int sub_51900()
{
  return -1;
}

//----- (00051908) --------------------------------------------------------
int __fastcall sub_51908(int a1, char a2)
{
  return sub_4FA10(a1, 1, 0, 0x3Cu, ((a2 & 0xF) << 8) & 0x7FFF | 0x80000000);
}

//----- (0005193C) --------------------------------------------------------
int __fastcall sub_5193C(int a1, unsigned int a2, char a3)
{
  return sub_4FA10(a1, 0, a2, 0x3Cu, ((a3 & 0xF) << 8) & 0x7FFF | 0x80000000);
}

//----- (00051970) --------------------------------------------------------
unsigned int __fastcall sub_51970(unsigned int a1)
{
  return HIBYTE(a1);
}

//----- (00051978) --------------------------------------------------------
int __fastcall sub_51978(int a1, unsigned int a2)
{
  return (unsigned __int8)sub_5F880(BYTE2(a1), a2);
}

//----- (0005198C) --------------------------------------------------------
int __fastcall sub_5198C(unsigned int a1)
{
  _DWORD *v1; // r9
  int i; // r7
  _DWORD *v5; // r4
  void *v6; // r0

  if ( a1 > 3 )
    return -1;
  v1 = &dword_5051C8[128 * a1];
  for ( i = 0; i != 4; ++i )
  {
    if ( a1 == i )
    {
      v5 = &dword_5059E0[0x8000 * a1];
      do
      {
        v6 = v5;
        v5 += 128;
        memcpy(v6, &unk_7F588, 0x200u);
      }
      while ( v5 != (_DWORD *)((char *)&unk_5259E0 + 0x20000 * a1) );
      memcpy(v1, &unk_7F588, 0x200u);
    }
  }
  return 0;
}
// 5051C8: using guessed type _DWORD dword_5051C8[512];
// 5059E0: using guessed type _DWORD dword_5059E0[32768];

//----- (00051A20) --------------------------------------------------------
int __fastcall sub_51A20(int a1, unsigned int a2, unsigned int a3, unsigned int a4, _DWORD *a5)
{
  unsigned int v5; // r6
  int v10; // r10
  unsigned int v12; // r6
  unsigned int v13; // r6
  _DWORD *v14; // r6

  v5 = (unsigned __int8)(a4 >> 2);
  if ( a2 > 3 )
    return -1;
  if ( a3 > 0xFF )
    return -2;
  if ( v5 > 0x3F )
    return -3;
  pthread_mutex_lock(&stru_5059C8);
  if ( a1 )
  {
    if ( a1 != 1 )
    {
      v10 = -6;
      pthread_mutex_unlock(&stru_5059C8);
LABEL_7:
      printf(
        "[%s] level::%d, which_chain::%u, which_asic::%u, register_address::%02x failed.\r\n",
        "get_register_cache_value",
        a1,
        a2,
        a3,
        a4);
      return v10;
    }
    v12 = v5 + ((a3 + (a2 << 8)) << 6);
    if ( dword_5059E0[2 * v12] != a4 )
    {
      v10 = -5;
      pthread_mutex_unlock(&stru_5059C8);
      goto LABEL_7;
    }
    v14 = &dword_5059E0[2 * v12];
  }
  else
  {
    v13 = v5 + (a2 << 6);
    if ( dword_5051C8[2 * v13] != a4 )
    {
      v10 = -4;
      pthread_mutex_unlock(&stru_5059C8);
      goto LABEL_7;
    }
    v14 = &dword_5051C8[2 * v13];
  }
  *a5 = v14[1];
  pthread_mutex_unlock(&stru_5059C8);
  return 0;
}
// 5051C8: using guessed type _DWORD dword_5051C8[512];
// 5059E0: using guessed type _DWORD dword_5059E0[32768];

//----- (00051B44) --------------------------------------------------------
int __fastcall sub_51B44(int a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5)
{
  unsigned int v5; // r4
  int v10; // r4
  unsigned int v12; // r4
  unsigned int v13; // r2
  unsigned int v14; // r3
  char *v15; // r2
  char *v16; // r3

  if ( a2 > 3 )
    return -1;
  if ( a3 > 0xFF )
    return -2;
  v5 = a4 >> 2;
  if ( a4 >> 2 > 0x40 )
    return -3;
  pthread_mutex_lock(&stru_5059C8);
  if ( a1 )
  {
    if ( a1 != 1 )
    {
      v10 = -6;
      pthread_mutex_unlock(&stru_5059C8);
LABEL_7:
      printf(
        "[%s] level::%d, which_chain::%u, which_asic::%u, register_address::%02x failed.\r\n",
        "set_register_cache_value",
        a1,
        a2,
        a3,
        a4);
      return v10;
    }
    v12 = v5 + ((a3 + (a2 << 8)) << 6);
    if ( dword_5059E0[2 * v12] != a4 )
    {
      v10 = -5;
      pthread_mutex_unlock(&stru_5059C8);
      goto LABEL_7;
    }
    dword_5059E0[2 * v12 + 1] = a5;
    pthread_mutex_unlock(&stru_5059C8);
    return 0;
  }
  else
  {
    v13 = v5 + (a2 << 6);
    if ( dword_5051C8[2 * v13] != a4 )
    {
      v10 = -4;
      pthread_mutex_unlock(&stru_5059C8);
      goto LABEL_7;
    }
    v14 = 2 * (v5 + (a2 << 14));
    dword_5051C8[2 * v13 + 1] = a5;
    v15 = (char *)&unk_5259E0 + v14 * 4;
    v16 = (char *)&dword_5059E0[v14];
    do
    {
      *((_DWORD *)v16 + 1) = a5;
      v16 += 512;
    }
    while ( v16 != v15 );
    pthread_mutex_unlock(&stru_5059C8);
    return 0;
  }
}
// 5051C8: using guessed type _DWORD dword_5051C8[512];
// 5059E0: using guessed type _DWORD dword_5059E0[32768];

//----- (00051CAC) --------------------------------------------------------
int __fastcall sub_51CAC(int a1, char a2, char a3, int a4, _BYTE *a5)
{
  int v5; // r5

  if ( !a5 )
    return -1;
  v5 = 0;
  *(_DWORD *)a5 = 0;
  a5[3] = a3;
  a5[7] = a4;
  a5[2] = a2;
  a5[4] = HIBYTE(a4);
  a5[5] = BYTE2(a4);
  a5[6] = BYTE1(a4);
  a5[8] = 0;
  *a5 = (16 * (a1 != 0)) & 0x1E | 0x41;
  a5[1] = 9;
  a5[8] = a5[8] & 0xE0 | sub_51F28(a5, 0x40u) & 0x1F;
  return v5;
}

//----- (00051D44) --------------------------------------------------------
int __fastcall sub_51D44(char a1, _BYTE *a2)
{
  int v2; // r5

  if ( !a2 )
    return -1;
  v2 = 0;
  *(_DWORD *)a2 = 0;
  a2[4] = 0;
  a2[2] = a1;
  a2[1] = 5;
  *a2 = 64;
  a2[4] = a2[4] & 0xE0 | sub_51F28(a2, 0x20u) & 0x1F;
  return v2;
}

//----- (00051D98) --------------------------------------------------------
int __fastcall sub_51D98(int a1, char a2, char a3, _BYTE *a4)
{
  int v4; // r5

  if ( !a4 )
    return -1;
  v4 = 0;
  *(_DWORD *)a4 = 0;
  a4[3] = a3;
  a4[2] = a2;
  a4[4] = 0;
  a4[1] = 5;
  *a4 = (16 * (a1 != 0)) & 0x1D | 0x42;
  a4[4] = a4[4] & 0xE0 | sub_51F28(a4, 0x20u) & 0x1F;
  return v4;
}

//----- (00051E08) --------------------------------------------------------
int __fastcall sub_51E08(_BYTE *a1)
{
  int v1; // r5

  if ( !a1 )
    return -1;
  v1 = 0;
  *(_DWORD *)a1 = 0;
  a1[4] = 0;
  a1[1] = 5;
  *a1 = 83;
  a1[4] = a1[4] & 0xE0 | sub_51F28(a1, 0x20u) & 0x1F;
  return v1;
}

//----- (00051E54) --------------------------------------------------------
int __fastcall sub_51E54(int a1, int a2, unsigned int a3)
{
  int *v3; // r4
  unsigned int v4; // lr
  int v5; // r3
  int v6; // r12
  int v8; // r5
  int v9[9]; // [sp+4h] [bp-24h] BYREF

  v4 = 0;
  v9[0] = 0;
  if ( a3 )
    v3 = v9;
  v9[1] = 0;
  v9[2] = 0;
  if ( !a3 )
    goto LABEL_9;
LABEL_4:
  while ( 2 )
  {
    v5 = 0;
    if ( v4 < a3 )
    {
      do
      {
        v6 = *v3;
        if ( v5 )
        {
          v8 = *(unsigned __int8 *)(a2 + v4 + v5);
          if ( v5 == 1 )
          {
            *v3 = v6 | (v8 << 16);
          }
          else if ( v5 == 2 )
          {
            *v3 = v6 | (v8 << 8);
          }
          else
          {
            *v3 = v8 | v6;
            if ( v5 == 3 )
            {
              v4 += 4;
              ++v3;
              if ( v4 >= a3 )
                goto LABEL_9;
              goto LABEL_4;
            }
          }
        }
        else
        {
          *v3 = v6 | (*(unsigned __int8 *)(a2 + v4) << 24);
        }
        ++v5;
      }
      while ( v4 + v5 < a3 );
    }
    v4 += 4;
    ++v3;
    if ( v4 < a3 )
      continue;
    break;
  }
LABEL_9:
  sub_457E0(v9, a1);
  return 0;
}
// 51E98: variable 'v3' is possibly undefined

//----- (00051F28) --------------------------------------------------------
int __fastcall sub_51F28(_BYTE *a1, unsigned int a2)
{
  int v2; // r2
  char v3; // r9
  unsigned int v4; // r12
  int v5; // r6
  int v6; // r8
  int v7; // r5
  int v8; // r7
  unsigned int v9; // r4
  unsigned int v10; // r3
  unsigned __int8 v11; // r3
  int v12; // lr
  int result; // r0

  if ( !a2 )
    return 31;
  LOBYTE(v2) = 0;
  v3 = 1;
  LOBYTE(v4) = 0;
  v5 = 1;
  v6 = 1;
  v7 = 1;
  v8 = 1;
  v9 = 128;
  while ( 1 )
  {
    v2 = (unsigned __int8)(v2 + 1);
    v4 = (unsigned __int8)(v4 + 1);
    v10 = *a1 & v9;
    v9 >>= 1;
    if ( v10 )
      v11 = v3 ^ 1;
    else
      v11 = v3;
    if ( v2 == 8 )
    {
      ++a1;
      LOBYTE(v2) = 0;
      v9 = 128;
    }
    v12 = (unsigned __int8)(v11 ^ v7);
    v3 = v5;
    if ( v4 >= a2 )
      break;
    v5 = v6;
    v7 = v8;
    v6 = v12;
    v8 = v11;
  }
  if ( v5 )
    result = 16;
  else
    result = 0;
  if ( v6 )
    result |= 8u;
  if ( v11 != v7 )
    result |= 4u;
  if ( v8 )
    result |= 2u;
  if ( v11 )
    return result | 1;
  return result;
}

//----- (00052050) --------------------------------------------------------
int __fastcall sub_52050(int a1)
{
  pthread_t v2; // r0
  unsigned int v3; // r2
  int v4; // r0
  int v5; // r4
  unsigned int i; // r3
  int v7; // r5
  size_t v8; // r0
  size_t v9; // r8
  void *v10; // r6
  ssize_t v11; // r0
  ssize_t v12; // r1
  int (__fastcall *v13)(void *, ssize_t); // r4
  size_t v14; // r0
  int v16; // [sp+8h] [bp-260h] BYREF
  socklen_t v17; // [sp+Ch] [bp-25Ch] BYREF
  char s[4]; // [sp+10h] [bp-258h] BYREF
  int v19; // [sp+14h] [bp-254h]
  int v20; // [sp+18h] [bp-250h]
  int v21; // [sp+1Ch] [bp-24Ch]
  struct sockaddr addr; // [sp+20h] [bp-248h] BYREF
  struct sockaddr v23; // [sp+30h] [bp-238h] BYREF
  char buf[4]; // [sp+40h] [bp-228h] BYREF
  char v25[252]; // [sp+44h] [bp-224h] BYREF
  char v26[4]; // [sp+140h] [bp-128h] BYREF
  char v27[252]; // [sp+144h] [bp-124h] BYREF

  v2 = pthread_self();
  pthread_detach(v2);
  v3 = *(_DWORD *)a1;
  *(_DWORD *)s = 0;
  v19 = 0;
  v20 = 0;
  v21 = 0;
  sprintf(s, "ct_b/fcb/%d", v3);
  prctl(15, s);
  addr.sa_family = 2;
  *(_DWORD *)&addr.sa_data[2] = inet_addr("127.0.0.1");
  v4 = socket(2, 1, 0);
  v5 = v4;
  if ( v4 < 0 )
  {
    perror("socket error");
    return 0;
  }
  else
  {
    v16 = 1;
    if ( setsockopt(v4, 1, 2, &v16, 4u) < 0 )
    {
      perror("set sockopt err");
      return 0;
    }
    else
    {
      for ( i = *(_DWORD *)a1; ; *(_DWORD *)a1 = i )
      {
        *(_WORD *)addr.sa_data = __rev16(i);
        if ( bind(v5, &addr, 0x10u) >= 0 )
          break;
        perror("bind error");
        i = *(_DWORD *)a1 + 1;
      }
      if ( listen(v5, 5) < 0 )
      {
        perror("listen error");
      }
      else
      {
        v17 = 16;
        *(_DWORD *)(a1 + 144) = 1;
        v7 = accept(v5, &v23, &v17);
        if ( v7 >= 0 )
        {
          *(_DWORD *)buf = 0;
          memset(v25, 0, sizeof(v25));
          sprintf(buf, "%x %s\n", 63, (const char *)(a1 + 16));
          v8 = strlen(buf);
          send(v7, buf, v8 + 1, 0);
          v9 = *(_DWORD *)(a1 + 148);
          v10 = malloc(v9);
          v11 = recv(v7, v10, v9, 0);
          if ( v11 > 0 )
            *((_BYTE *)v10 + v11) = 0;
          while ( 1 )
          {
            v12 = recv(v7, v10, *(_DWORD *)(a1 + 148), 0);
            if ( v12 > 0 )
            {
              v13 = *(int (__fastcall **)(void *, ssize_t))(a1 + 12);
              if ( v13 )
                v13 = (int (__fastcall *)(void *, ssize_t))v13(v10, v12);
            }
            else
            {
              v13 = 0;
            }
            *(_DWORD *)v26 = 0;
            memset(v27, 0, sizeof(v27));
            sprintf(v26, "%x %d %s %s", 63, v13, (const char *)(a1 + 16), "OK");
            v14 = strlen(v26);
            send(v7, v26, v14 + 1, 0);
          }
        }
        perror("accept error");
      }
      return 0;
    }
  }
}

//----- (000522DC) --------------------------------------------------------
int __fastcall sub_522DC(int a1)
{
  pthread_t v2; // r0
  int v3; // r7
  ssize_t v4; // r0
  int v5; // r4
  int v6; // r4
  _DWORD *v7; // r0
  int v8; // r11
  _DWORD *v9; // r10
  const char *v10; // r5
  int v11; // r0
  int v12; // r3
  size_t v13; // r0
  int v14; // r10
  size_t v15; // r0
  size_t v17; // r0
  int v18; // [sp+14h] [bp-224h] BYREF
  pthread_t newthread; // [sp+18h] [bp-220h] BYREF
  char v20[8]; // [sp+1Ch] [bp-21Ch] BYREF
  int v21; // [sp+24h] [bp-214h]
  int v22; // [sp+28h] [bp-210h]
  char src[4]; // [sp+2Ch] [bp-20Ch] BYREF
  int v24; // [sp+30h] [bp-208h]
  int v25; // [sp+34h] [bp-204h]
  int v26; // [sp+38h] [bp-200h]
  int v27; // [sp+3Ch] [bp-1FCh]
  int v28; // [sp+40h] [bp-1F8h]
  int v29; // [sp+44h] [bp-1F4h]
  int v30; // [sp+48h] [bp-1F0h]
  char s1[4]; // [sp+4Ch] [bp-1ECh] BYREF
  int v32; // [sp+50h] [bp-1E8h]
  int v33; // [sp+54h] [bp-1E4h]
  int v34; // [sp+58h] [bp-1E0h]
  int v35; // [sp+5Ch] [bp-1DCh]
  int v36; // [sp+60h] [bp-1D8h]
  int v37; // [sp+64h] [bp-1D4h]
  int v38; // [sp+68h] [bp-1D0h]
  pthread_attr_t attr; // [sp+6Ch] [bp-1CCh] BYREF
  int buf[32]; // [sp+90h] [bp-1A8h] BYREF
  char v41[4]; // [sp+110h] [bp-128h] BYREF
  char v42[252]; // [sp+114h] [bp-124h] BYREF

  v2 = pthread_self();
  pthread_detach(v2);
  v22 = 0;
  qmemcpy(v20, "ct_b/mai", sizeof(v20));
  v21 = *(unsigned __int16 *)"n";
  prctl(15, v20);
  pthread_attr_init(&attr);
  pthread_attr_setstacksize(&attr, 0x100000u);
  v3 = *(_DWORD *)(a1 + 8);
  while ( 1 )
  {
    memset(buf, 0, sizeof(buf));
    v4 = recv(v3, buf, 0x80u, 0);
    if ( v4 <= 0 )
      return 0;
    *((_BYTE *)buf + v4) = 0;
    *(_DWORD *)src = 0;
    v24 = 0;
    *(_DWORD *)s1 = 0;
    v32 = 0;
    v18 = 0;
    v25 = 0;
    v26 = 0;
    v27 = 0;
    v28 = 0;
    v29 = 0;
    v30 = 0;
    v33 = 0;
    v34 = 0;
    v35 = 0;
    v36 = 0;
    v37 = 0;
    v38 = 0;
    _isoc99_sscanf(buf, "%x%s%s", &v18, s1, src);
    v5 = strcmp(s1, "regist");
    if ( v5 )
    {
      v6 = dword_5859E0 + 1;
      memcpy((char *)&unk_585A08 + 128 * dword_5859E0, buf, 0x80u);
      dword_5859E0 = v6;
    }
    else
    {
      v7 = calloc(0x98u, 1u);
      v8 = dword_5859E4;
      v9 = v7;
      if ( !dword_5859E4 )
        goto LABEL_18;
      v10 = s2;
      while ( 1 )
      {
        v11 = strcmp(src, v10);
        v10 += 136;
        if ( !v11 )
          break;
        if ( ++v5 == v8 )
          goto LABEL_11;
      }
      v12 = *((_DWORD *)&unk_589A08 + 34 * v5 + 33);
      v9[3] = *((_DWORD *)&unk_589A08 + 34 * v5);
      v9[37] = v12;
LABEL_11:
      if ( v8 == v5 )
      {
LABEL_18:
        *(_DWORD *)v41 = 0;
        memset(v42, 0, sizeof(v42));
        sprintf(v41, "%x %d %s %s %s", 63, 0, "reg_resp", "no_name", src);
        v17 = strlen(v41);
        send(v3, v41, v17 + 1, 0);
        free(v9);
      }
      else
      {
        *v9 = dword_7F788;
        v13 = strlen(src);
        memcpy(v9 + 4, src, v13 + 1);
        v9[36] = 0;
        pthread_create(&newthread, &attr, (void *(*)(void *))sub_52050, v9);
        while ( !v9[36] )
          usleep(0x2710u);
        v14 = *v9;
        *(_DWORD *)v41 = 0;
        if ( v14 != dword_7F788 )
          dword_7F788 = v14;
        memset(v42, 0, sizeof(v42));
        sprintf(v41, "%x %d %s %s %s", 63, v14, "reg_resp", "OK", src);
        v15 = strlen(v41);
        send(v3, v41, v15 + 1, 0);
        ++dword_7F788;
      }
    }
  }
}
// 1231C: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);
// 7F788: using guessed type int dword_7F788;
// 5859E0: using guessed type int dword_5859E0;
// 5859E4: using guessed type int dword_5859E4;

//----- (0005261C) --------------------------------------------------------
int __fastcall sub_5261C(int a1, int a2)
{
  int v2; // r7
  char *v5; // r4
  char *v6; // r3
  char *v7; // r5
  char *v8; // r0
  int v9; // r2
  int v10; // r0
  int v11; // r8
  unsigned int v12; // r4
  int v13; // r5
  size_t v14; // r0
  ssize_t v15; // r0
  bool v16; // cc
  ssize_t v17; // r0
  _DWORD *v18; // r0
  int optval; // [sp+8h] [bp-470h] BYREF
  socklen_t addr_len; // [sp+Ch] [bp-46Ch] BYREF
  pthread_t newthread; // [sp+10h] [bp-468h] BYREF
  struct sockaddr addr; // [sp+14h] [bp-464h] BYREF
  struct sockaddr v24; // [sp+24h] [bp-454h] BYREF
  pthread_attr_t attr; // [sp+34h] [bp-444h] BYREF
  char buf[4]; // [sp+58h] [bp-420h] BYREF
  char s[124]; // [sp+5Ch] [bp-41Ch] BYREF
  int v28[32]; // [sp+D8h] [bp-3A0h] BYREF
  char v29[256]; // [sp+158h] [bp-320h] BYREF
  int v30[136]; // [sp+258h] [bp-220h] BYREF

  v2 = dword_5859E8;
  if ( dword_5859E8 )
    return -1;
  pthread_attr_init(&attr);
  pthread_attr_setstacksize(&attr, 0x100000u);
  pthread_mutex_init(&stru_5859EC, (const pthread_mutexattr_t *)v2);
  dword_5859E4 = a2;
  if ( a2 )
  {
    v5 = (char *)(a1 + 4);
    v6 = s2;
    v7 = &v5[136 * a2];
    do
    {
      v8 = (char *)memcpy(v6, v5, 0x80u);
      v5 += 136;
      v9 = *((_DWORD *)v5 - 35);
      v6 = v8 + 136;
      *((_DWORD *)v8 + 32) = *((_DWORD *)v5 - 2);
      *((_DWORD *)v8 - 1) = v9;
    }
    while ( v5 != v7 );
  }
  *(_WORD *)&addr.sa_data[6] = 0;
  *(_DWORD *)&addr.sa_data[8] = 0;
  *(_WORD *)&addr.sa_data[12] = 0;
  *(_WORD *)addr.sa_data = 0;
  addr.sa_family = 2;
  *(_DWORD *)&addr.sa_data[2] = inet_addr("127.0.0.1");
  optval = 1;
  v10 = socket(2, 1, 0);
  v11 = v10;
  if ( v10 < 0 )
  {
    v2 = -4;
    perror("socket error");
  }
  else if ( setsockopt(v10, 1, 2, &optval, 4u) < 0 )
  {
    v2 = -4;
    perror("set sockopt err");
  }
  else
  {
    v12 = 22026;
    while ( 1 )
    {
      *(_WORD *)addr.sa_data = __rev16(v12++);
      if ( bind(v11, &addr, 0x10u) >= 0 )
        break;
      perror("bind error");
    }
    if ( listen(v11, 5) < 0 )
    {
      v2 = -4;
      perror("listen error");
    }
    else
    {
      addr_len = 16;
      v13 = accept(v11, &v24, &addr_len);
      if ( v13 < 0 )
      {
        v2 = -4;
        perror("accept error");
      }
      else
      {
        *(_DWORD *)buf = 0;
        memset(s, 0, sizeof(s));
        sprintf(buf, "Hello!0x%x\n", 63);
        v14 = strlen(buf);
        send(v13, buf, v14 + 1, 0);
        dword_5859E8 = 1;
        memset(v30, 0, 512);
        dword_585A04 = v13;
        v15 = recv(v13, v30, 0x400u, 0);
        v16 = v15 <= 0;
        if ( v15 > 0 )
          v15 += (ssize_t)&v30[128];
        if ( !v16 )
          *(_BYTE *)(v15 - 512) = 0;
        strcpy(v29, "123 456 789 abc");
        memset(&v29[16], 0, 0xF0u);
        send(v13, v29, 0x10u, 0);
        memset(v28, 0, sizeof(v28));
        v17 = recv(v13, v28, 0x80u, 0);
        if ( v17 > 0 )
          *((_BYTE *)v28 + v17) = 0;
        v18 = malloc(0xCu);
        v18[2] = v13;
        v18[1] = v11;
        pthread_create(&newthread, &attr, (void *(*)(void *))sub_522DC, v18);
      }
    }
  }
  return v2;
}
// 5859E4: using guessed type int dword_5859E4;
// 5859E8: using guessed type int dword_5859E8;
// 5859EC: using guessed type pthread_mutex_t stru_5859EC;
// 585A04: using guessed type int dword_585A04;

//----- (00052930) --------------------------------------------------------
int __fastcall sub_52930(int a1)
{
  pthread_mutex_t *v2; // r8
  int v3; // r9
  int v4; // r5
  size_t v5; // r0
  int v6; // r0
  int v7; // r5
  ssize_t v8; // r0
  unsigned int v9; // r3
  int result; // r0
  unsigned int v11; // [sp+10h] [bp-498h] BYREF
  int v12; // [sp+14h] [bp-494h] BYREF
  struct sockaddr addr; // [sp+18h] [bp-490h] BYREF
  int v14; // [sp+28h] [bp-480h] BYREF
  int v15; // [sp+2Ch] [bp-47Ch]
  int v16; // [sp+30h] [bp-478h]
  int v17; // [sp+34h] [bp-474h]
  int v18; // [sp+38h] [bp-470h]
  int v19; // [sp+3Ch] [bp-46Ch]
  int v20; // [sp+40h] [bp-468h]
  int v21; // [sp+44h] [bp-464h]
  int v22; // [sp+48h] [bp-460h] BYREF
  int v23; // [sp+4Ch] [bp-45Ch]
  int v24; // [sp+50h] [bp-458h]
  int v25; // [sp+54h] [bp-454h]
  int v26; // [sp+58h] [bp-450h]
  int v27; // [sp+5Ch] [bp-44Ch]
  int v28; // [sp+60h] [bp-448h]
  int v29; // [sp+64h] [bp-444h]
  int v30; // [sp+68h] [bp-440h] BYREF
  int v31; // [sp+6Ch] [bp-43Ch]
  int v32; // [sp+70h] [bp-438h]
  int v33; // [sp+74h] [bp-434h]
  int v34; // [sp+78h] [bp-430h]
  int v35; // [sp+7Ch] [bp-42Ch]
  int v36; // [sp+80h] [bp-428h]
  int v37; // [sp+84h] [bp-424h]
  int dest[32]; // [sp+88h] [bp-420h] BYREF
  int v39[32]; // [sp+108h] [bp-3A0h] BYREF
  char buf[4]; // [sp+188h] [bp-320h] BYREF
  char s[252]; // [sp+18Ch] [bp-31Ch] BYREF
  int v42[136]; // [sp+288h] [bp-220h] BYREF

  if ( !dword_5859E8 )
    return -1;
  v2 = (pthread_mutex_t *)malloc(0x24u);
  pthread_mutex_init(v2, 0);
  v3 = dword_585A04;
  *(_DWORD *)buf = 0;
  memset(s, 0, sizeof(s));
  sprintf(buf, "%x regist %s", 63, (const char *)a1);
  v4 = dword_5859E0;
  v5 = strlen(buf);
  send(v3, buf, v5 + 1, 0);
  memset(dest, 0, sizeof(dest));
  while ( dword_5859E0 == v4 )
    usleep(0x3E8u);
  memcpy(dest, (char *)&unk_585A08 + 128 * v4, sizeof(dest));
  v11 = 0;
  v12 = 0;
  v14 = 0;
  v15 = 0;
  v22 = 0;
  v23 = 0;
  v30 = 0;
  v31 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  v21 = 0;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  v28 = 0;
  v29 = 0;
  v32 = 0;
  v33 = 0;
  v34 = 0;
  v35 = 0;
  v36 = 0;
  v37 = 0;
  _isoc99_sscanf(dest, "%x%d%s%s%s", &v12, &v11, &v14, &v22, &v30);
  if ( !v11 )
    return -4;
  addr.sa_family = 2;
  memset(addr.sa_data, 0, sizeof(addr.sa_data));
  *(_DWORD *)&addr.sa_data[2] = inet_addr("127.0.0.1");
  *(_WORD *)addr.sa_data = __rev16(v11);
  v6 = socket(2, 1, 0);
  v7 = v6;
  if ( v6 < 0 )
  {
    perror("socket err:");
    return -4;
  }
  else if ( connect(v6, &addr, 0x10u) < 0 )
  {
    perror("connect err:");
    return -3;
  }
  else
  {
    memset(v42, 0, 512);
    v8 = recv(v7, v42, 0x200u, 0);
    if ( v8 > 0 )
      *((_BYTE *)v42 + v8) = 0;
    memset(&v39[1], 0, 0x7Cu);
    v39[0] = (int)&unk_214B4F;
    send(v7, v39, 4u, 0);
    v9 = v11;
    result = 0;
    v2[1].__owner = v7;
    *(_DWORD *)(a1 + 128) = v2;
    v2[1].__lock = v9;
  }
  return result;
}
// 1231C: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);
// 5859E0: using guessed type int dword_5859E0;
// 5859E8: using guessed type int dword_5859E8;
// 585A04: using guessed type int dword_585A04;

//----- (00052BD8) --------------------------------------------------------
int sub_52BD8()
{
  return 0;
}

//----- (00052BF0) --------------------------------------------------------
int __fastcall sub_52BF0(int a1, const void *a2, size_t a3, _DWORD *a4)
{
  pthread_mutex_t *v4; // r5
  int v8; // r4
  ssize_t v9; // r0
  int v11; // [sp+8h] [bp-160h] BYREF
  int v12; // [sp+Ch] [bp-15Ch] BYREF
  int v13; // [sp+10h] [bp-158h] BYREF
  int v14; // [sp+14h] [bp-154h]
  int v15; // [sp+18h] [bp-150h]
  int v16; // [sp+1Ch] [bp-14Ch]
  int v17; // [sp+20h] [bp-148h]
  int v18; // [sp+24h] [bp-144h]
  int v19; // [sp+28h] [bp-140h]
  int v20; // [sp+2Ch] [bp-13Ch]
  int v21; // [sp+30h] [bp-138h] BYREF
  int v22; // [sp+34h] [bp-134h]
  int v23; // [sp+38h] [bp-130h]
  int v24; // [sp+3Ch] [bp-12Ch]
  int v25; // [sp+40h] [bp-128h]
  int v26; // [sp+44h] [bp-124h]
  int v27; // [sp+48h] [bp-120h]
  int v28; // [sp+4Ch] [bp-11Ch]
  int buf[70]; // [sp+50h] [bp-118h] BYREF

  if ( !dword_5859E8 )
    return -1;
  v4 = *(pthread_mutex_t **)(a1 + 128);
  if ( !v4 )
    return -2;
  v8 = pthread_mutex_trylock(*(pthread_mutex_t **)(a1 + 128));
  if ( v8 )
    return -3;
  if ( send(v4[1].__owner, a2, a3, 0) <= 0 )
  {
    v8 = -4;
    pthread_mutex_unlock(v4);
  }
  else
  {
    memset(buf, 0, 256);
    v9 = recv(v4[1].__owner, buf, 0x100u, 0);
    v11 = 0;
    v12 = 0;
    v13 = 0;
    v14 = 0;
    v21 = 0;
    v22 = 0;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    v18 = 0;
    v19 = 0;
    v20 = 0;
    v23 = 0;
    v24 = 0;
    v25 = 0;
    v26 = 0;
    v27 = 0;
    v28 = 0;
    if ( v9 > 0 )
      _isoc99_sscanf(buf, "%x%d%s%s", &v11, &v12, &v13, &v21);
    if ( a4 )
      *a4 = v12;
    pthread_mutex_unlock(v4);
  }
  return v8;
}
// 1231C: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);
// 5859E8: using guessed type int dword_5859E8;

//----- (00052D3C) --------------------------------------------------------
int sub_52D3C()
{
  return 0;
}

//----- (00052D44) --------------------------------------------------------
void sub_52D44()
{
  _DWORD *v0; // r0

  v0 = pthread_getspecific(dword_58DE08);
  if ( v0 )
    sub_5CFA8(v0);
}
// 58DE08: using guessed type int dword_58DE08;

//----- (00052D68) --------------------------------------------------------
int sub_52D68()
{
  int result; // r0

  if ( dword_58DE0C )
    sub_55D5C((_DWORD *)dword_58DE0C);
  dword_58DE0C = 0;
  dword_58DE10 = 0;
  if ( dword_58DE14 )
    sub_584A4((_DWORD *)dword_58DE14);
  dword_58DE14 = 0;
  result = dword_99EEC8;
  if ( dword_99EEC8 )
    result = sub_56E0C((_DWORD *)dword_99EEC8);
  dword_99EEC8 = 0;
  return result;
}
// 58DE0C: using guessed type int dword_58DE0C;
// 58DE10: using guessed type int dword_58DE10;
// 58DE14: using guessed type int dword_58DE14;
// 99EEC8: using guessed type int dword_99EEC8;

//----- (00052DCC) --------------------------------------------------------
int __fastcall sub_52DCC(const char *a1)
{
  int v2; // r0
  int v3; // r0

  if ( !dword_58DE18 )
  {
    v2 = pthread_key_create((pthread_key_t *)&dword_58DE08, (void (*)(void *))sub_5CFA8);
    if ( v2 )
    {
      sub_5DF98(2, "src/zlog.c", 76, "pthread_key_create fail, rc[%d]", v2);
      goto LABEL_12;
    }
    v3 = sub_60318((void (__fastcall *)(void *))sub_52D44);
    if ( v3 )
    {
      sub_5DF98(2, "src/zlog.c", 85, "atexit fail, rc[%d]", v3);
      goto LABEL_12;
    }
    dword_58DE18 = 1;
  }
  dword_99EEC8 = sub_56EB8(a1);
  if ( dword_99EEC8 )
  {
    dword_58DE0C = (int)sub_55DB8();
    if ( dword_58DE0C )
    {
      dword_58DE14 = (int)sub_58500();
      if ( dword_58DE14 )
        return 0;
      sub_5DF98(2, "src/zlog.c", 105, "zlog_record_table_new fail");
    }
    else
    {
      sub_5DF98(2, "src/zlog.c", 99, "zlog_category_table_new fail");
    }
  }
  else
  {
    sub_5DF98(2, "src/zlog.c", 93, "zlog_conf_new[%s] fail", a1);
  }
LABEL_12:
  sub_52D68();
  return -1;
}
// 52D44: using guessed type int sub_52D44();
// 58DE08: using guessed type int dword_58DE08;
// 58DE0C: using guessed type int dword_58DE0C;
// 58DE14: using guessed type int dword_58DE14;
// 58DE18: using guessed type int dword_58DE18;
// 99EEC8: using guessed type int dword_99EEC8;

//----- (00052F1C) --------------------------------------------------------
int __fastcall sub_52F1C(const char *a1)
{
  int v2; // r0
  int v3; // r0
  int result; // r0

  sub_5DF98(0, "src/zlog.c", 119, "------zlog_init start------");
  sub_5DF98(0, "src/zlog.c", 120, "------compile time[%s %s], version[%s]------", "Dec  6 2022", "16:28:36", "1.2.12");
  v2 = pthread_rwlock_wrlock(&stru_58DE1C);
  if ( v2 )
  {
    sub_5DF98(2, "src/zlog.c", 124, "pthread_rwlock_wrlock fail, rc[%d]", v2);
    return -1;
  }
  if ( dword_58DE3C )
  {
    sub_5DF98(2, "src/zlog.c", 129, "already init, use zlog_reload pls");
    goto LABEL_5;
  }
  if ( sub_52DCC(a1) )
  {
    sub_5DF98(2, "src/zlog.c", 135, "zlog_init_inner[%s] fail", a1);
LABEL_5:
    sub_5DF98(2, "src/zlog.c", 150, "------zlog_init fail end------");
    v3 = pthread_rwlock_unlock(&stru_58DE1C);
    if ( v3 )
      sub_5DF98(2, "src/zlog.c", 153, "pthread_rwlock_unlock fail, rc=[%d]", v3);
    return -1;
  }
  dword_58DE3C = 1;
  ++dword_58DE18;
  sub_5DF98(0, "src/zlog.c", 142, "------zlog_init success end------");
  result = pthread_rwlock_unlock(&stru_58DE1C);
  if ( result )
  {
    sub_5DF98(2, "src/zlog.c", 145, "pthread_rwlock_unlock fail, rc=[%d]", result);
    return -1;
  }
  return result;
}
// 58DE18: using guessed type int dword_58DE18;
// 58DE3C: using guessed type int dword_58DE3C;

//----- (000530EC) --------------------------------------------------------
int __fastcall sub_530EC(const char *a1, const char *a2)
{
  int v4; // r0
  int v5; // r0
  int result; // r0

  sub_5DF98(0, "src/zlog.c", 162, "------dzlog_init start------");
  sub_5DF98(0, "src/zlog.c", 164, "------compile time[%s %s], version[%s]------", "Dec  6 2022", "16:28:36", "1.2.12");
  v4 = pthread_rwlock_wrlock(&stru_58DE1C);
  if ( v4 )
  {
    sub_5DF98(2, "src/zlog.c", 168, "pthread_rwlock_wrlock fail, rc[%d]", v4);
    return -1;
  }
  if ( dword_58DE3C )
  {
    sub_5DF98(2, "src/zlog.c", 173, "already init, use zlog_reload pls");
    goto LABEL_5;
  }
  if ( sub_52DCC(a1) )
  {
    sub_5DF98(2, "src/zlog.c", 178, "zlog_init_inner[%s] fail", a1);
LABEL_5:
    sub_5DF98(2, "src/zlog.c", 202, "------dzlog_init fail end------");
    v5 = pthread_rwlock_unlock(&stru_58DE1C);
    if ( v5 )
      sub_5DF98(2, "src/zlog.c", 205, "pthread_rwlock_unlock fail, rc=[%d]", v5);
    return -1;
  }
  dword_58DE10 = (int)sub_55F6C(dword_58DE0C, a2, *(_DWORD **)(dword_99EEC8 + 9288));
  if ( !dword_58DE10 )
  {
    sub_5DF98(2, "src/zlog.c", 187, "zlog_category_table_fetch_category[%s] fail", a2);
    goto LABEL_5;
  }
  ++dword_58DE18;
  dword_58DE3C = 1;
  sub_5DF98(0, "src/zlog.c", 194, "------dzlog_init success end------");
  result = pthread_rwlock_unlock(&stru_58DE1C);
  if ( result )
  {
    sub_5DF98(2, "src/zlog.c", 197, "pthread_rwlock_unlock fail, rc=[%d]", result);
    return -1;
  }
  return result;
}
// 58DE0C: using guessed type int dword_58DE0C;
// 58DE10: using guessed type int dword_58DE10;
// 58DE18: using guessed type int dword_58DE18;
// 58DE3C: using guessed type int dword_58DE3C;
// 99EEC8: using guessed type int dword_99EEC8;

//----- (00053314) --------------------------------------------------------
int __fastcall sub_53314(int a1)
{
  int v2; // r0
  int v3; // r7
  const char *v4; // r0
  int v5; // r4
  int v6; // r0
  _DWORD *v7; // r8
  _DWORD *v8; // r1
  int v9; // r0
  int v10; // r0
  int v12; // r0
  int v13; // r0

  sub_5DF98(0, "src/zlog.c", 219, "------zlog_reload start------");
  v2 = pthread_rwlock_wrlock(&stru_58DE1C);
  v3 = v2;
  if ( v2 )
  {
    v3 = -1;
    sub_5DF98(2, "src/zlog.c", 222, "pthread_rwlock_wrlock fail, rc[%d]", v2);
    return v3;
  }
  if ( !dword_58DE3C )
  {
    sub_5DF98(2, "src/zlog.c", 227, "never call zlog_init() or dzlog_init() before");
LABEL_15:
    sub_5DF98(0, "src/zlog.c", 291, "------zlog_reload do nothing------");
    v12 = pthread_rwlock_unlock(&stru_58DE1C);
    if ( v12 )
    {
      v3 = -1;
      sub_5DF98(2, "src/zlog.c", 294, "pthread_rwlock_unlock fail, rc=[%d]", v12);
    }
    return v3;
  }
  if ( !a1 )
    a1 = dword_99EEC8;
  if ( a1 == -1 )
  {
    a1 = dword_99EEC8;
    if ( *(_DWORD *)(dword_99EEC8 + 9276) >= (unsigned int)dword_58DE40 )
      goto LABEL_15;
  }
  v4 = (const char *)a1;
  v5 = 0;
  dword_58DE40 = 0;
  v6 = sub_56EB8(v4);
  v7 = (_DWORD *)v6;
  if ( !v6 )
  {
    sub_5DF98(2, "src/zlog.c", 250, "zlog_conf_new fail");
    sub_5DF98(1, "src/zlog.c", 280, "zlog_reload fail, use old conf file, still working");
LABEL_11:
    sub_5DF98(2, "src/zlog.c", 283, "------zlog_reload fail, total init version[%d] ------", dword_58DE18);
    v10 = pthread_rwlock_unlock(&stru_58DE1C);
    v3 = -1;
    if ( v10 )
      sub_5DF98(2, "src/zlog.c", 286, "pthread_rwlock_unlock fail, rc=[%d]", v10);
    return v3;
  }
  v8 = *(_DWORD **)(v6 + 9288);
  if ( (int)v8[1] > 0 )
  {
    do
    {
      v9 = *(_DWORD *)(*v8 + 4 * v5++);
      sub_5BCCC(v9, dword_58DE14);
      v8 = (_DWORD *)v7[2322];
    }
    while ( v8[1] > v5 );
  }
  if ( sub_55E24(dword_58DE0C, v8) )
  {
    sub_5DF98(2, "src/zlog.c", 260, "zlog_category_table_update fail");
    sub_5DF98(1, "src/zlog.c", 280, "zlog_reload fail, use old conf file, still working");
    sub_56E0C(v7);
    goto LABEL_11;
  }
  ++dword_58DE18;
  sub_55EBC(dword_58DE0C);
  sub_56E0C((_DWORD *)dword_99EEC8);
  dword_99EEC8 = (int)v7;
  sub_5DF98(0, "src/zlog.c", 271, "------zlog_reload success, total init verison[%d] ------", dword_58DE18);
  v13 = pthread_rwlock_unlock(&stru_58DE1C);
  if ( v13 )
  {
    v3 = -1;
    sub_5DF98(2, "src/zlog.c", 274, "pthread_rwlock_unlock fail, rc=[%d]", v13);
  }
  return v3;
}
// 58DE0C: using guessed type int dword_58DE0C;
// 58DE14: using guessed type int dword_58DE14;
// 58DE18: using guessed type int dword_58DE18;
// 58DE3C: using guessed type int dword_58DE3C;
// 58DE40: using guessed type int dword_58DE40;
// 99EEC8: using guessed type int dword_99EEC8;

//----- (00053604) --------------------------------------------------------
int sub_53604()
{
  int v0; // r0
  int result; // r0

  sub_5DF98(0, "src/zlog.c", 304, "------zlog_fini start------");
  v0 = pthread_rwlock_wrlock(&stru_58DE1C);
  if ( v0 )
    return sub_5DF98(2, "src/zlog.c", 307, "pthread_rwlock_wrlock fail, rc[%d]", v0);
  if ( dword_58DE3C )
  {
    sub_52D68();
    dword_58DE3C = 0;
  }
  else
  {
    sub_5DF98(2, "src/zlog.c", 312, "before finish, must zlog_init() or dzlog_init() fisrt");
  }
  sub_5DF98(0, "src/zlog.c", 320, "------zlog_fini end------");
  result = pthread_rwlock_unlock(&stru_58DE1C);
  if ( result )
    return sub_5DF98(2, "src/zlog.c", 323, "pthread_rwlock_unlock fail, rc=[%d]", result);
  return result;
}
// 58DE3C: using guessed type int dword_58DE3C;

//----- (000536F4) --------------------------------------------------------
_DWORD *__fastcall sub_536F4(const char *a1)
{
  int v2; // r0
  _DWORD *v3; // r6
  int v4; // r0
  int v6; // r0

  if ( !a1 )
  {
    v3 = 0;
    sub_5DF98(2, "src/zlog.c", 334, "cname is null or 0");
    return v3;
  }
  sub_5DF98(0, "src/zlog.c", 335, "------zlog_get_category[%s] start------", a1);
  v2 = pthread_rwlock_wrlock(&stru_58DE1C);
  if ( v2 )
  {
    v3 = 0;
    sub_5DF98(2, "src/zlog.c", 338, "pthread_rwlock_wrlock fail, rc[%d]", v2);
    return v3;
  }
  if ( dword_58DE3C )
  {
    v3 = sub_55F6C(dword_58DE0C, a1, *(_DWORD **)(dword_99EEC8 + 9288));
    if ( v3 )
    {
      sub_5DF98(0, "src/zlog.c", 357, "------zlog_get_category[%s] success, end------ ", a1);
      v4 = pthread_rwlock_unlock(&stru_58DE1C);
      if ( v4 )
      {
        v3 = 0;
        sub_5DF98(2, "src/zlog.c", 360, "pthread_rwlock_unlock fail, rc=[%d]", v4);
      }
      return v3;
    }
    sub_5DF98(2, "src/zlog.c", 353, "zlog_category_table_fetch_category[%s] fail", a1);
  }
  else
  {
    sub_5DF98(2, "src/zlog.c", 343, "never call zlog_init() or dzlog_init() before");
  }
  sub_5DF98(2, "src/zlog.c", 365, "------zlog_get_category[%s] fail, end------ ", a1);
  v6 = pthread_rwlock_unlock(&stru_58DE1C);
  v3 = (_DWORD *)v6;
  if ( !v6 )
    return v3;
  sub_5DF98(2, "src/zlog.c", 368, "pthread_rwlock_unlock fail, rc=[%d]", v6);
  return 0;
}
// 58DE0C: using guessed type int dword_58DE0C;
// 58DE3C: using guessed type int dword_58DE3C;
// 99EEC8: using guessed type int dword_99EEC8;

//----- (000538C4) --------------------------------------------------------
int __fastcall sub_538C4(const char *a1)
{
  int v2; // r0
  int v3; // r0
  int result; // r0

  if ( !a1 )
  {
    sub_5DF98(2, "src/zlog.c", 377, "cname is null or 0");
    return -1;
  }
  sub_5DF98(0, "src/zlog.c", 379, "------dzlog_set_category[%s] start------", a1);
  v2 = pthread_rwlock_wrlock(&stru_58DE1C);
  if ( v2 )
  {
    sub_5DF98(2, "src/zlog.c", 382, "pthread_rwlock_wrlock fail, rc[%d]", v2);
    return -1;
  }
  if ( !dword_58DE3C )
  {
    sub_5DF98(2, "src/zlog.c", 387, "never call zlog_init() or dzlog_init() before");
LABEL_5:
    sub_5DF98(2, "src/zlog.c", 408, "------dzlog_set_category[%s] end, fail------ ", a1);
    v3 = pthread_rwlock_unlock(&stru_58DE1C);
    if ( v3 )
      sub_5DF98(2, "src/zlog.c", 411, "pthread_rwlock_unlock fail, rc=[%d]", v3);
    return -1;
  }
  dword_58DE10 = (int)sub_55F6C(dword_58DE0C, a1, *(_DWORD **)(dword_99EEC8 + 9288));
  if ( !dword_58DE10 )
  {
    sub_5DF98(2, "src/zlog.c", 396, "zlog_category_table_fetch_category[%s] fail", a1);
    goto LABEL_5;
  }
  sub_5DF98(0, "src/zlog.c", 400, "------dzlog_set_category[%s] end, success------ ", a1);
  result = pthread_rwlock_unlock(&stru_58DE1C);
  if ( result )
  {
    sub_5DF98(2, "src/zlog.c", 403, "pthread_rwlock_unlock fail, rc=[%d]", result);
    return -1;
  }
  return result;
}
// 58DE0C: using guessed type int dword_58DE0C;
// 58DE10: using guessed type int dword_58DE10;
// 58DE3C: using guessed type int dword_58DE3C;
// 99EEC8: using guessed type int dword_99EEC8;

//----- (00053A94) --------------------------------------------------------
int __fastcall sub_53A94(const char *a1, const char *a2)
{
  int v4; // r0
  int v5; // r0
  int result; // r0
  int **v7; // r6
  int v8; // r0
  int v9; // r0
  int **v10; // r0
  int v11; // r8

  if ( !a1 )
  {
    sub_5DF98(2, "src/zlog.c", 462, "key is null or 0");
    return -1;
  }
  if ( !a2 )
  {
    sub_5DF98(2, "src/zlog.c", 463, "value is null or 0");
    return -1;
  }
  v4 = pthread_rwlock_rdlock(&stru_58DE1C);
  if ( v4 )
  {
    sub_5DF98(2, "src/zlog.c", 467, "pthread_rwlock_wrlock fail, rc[%d]", v4);
    return -1;
  }
  if ( !dword_58DE3C )
  {
    sub_5DF98(2, "src/zlog.c", 472, "never call zlog_init() or dzlog_init() before");
LABEL_6:
    v5 = pthread_rwlock_unlock(&stru_58DE1C);
    if ( v5 )
      sub_5DF98(2, "src/zlog.c", 492, "pthread_rwlock_unlock fail, rc=[%d]", v5);
    return -1;
  }
  v7 = (int **)pthread_getspecific(dword_58DE08);
  v8 = dword_58DE18;
  if ( !v7 )
  {
    v10 = (int **)sub_5D07C(
                    dword_58DE18,
                    *(_DWORD *)(dword_99EEC8 + 1052),
                    *(_DWORD *)(dword_99EEC8 + 1056),
                    *(_DWORD *)(dword_99EEC8 + 9292));
    v7 = v10;
    if ( !v10 )
    {
      sub_5DF98(2, "src/zlog.c", 476, "zlog_thread_new fail");
      goto LABEL_6;
    }
    v11 = pthread_setspecific(dword_58DE08, v10);
    if ( v11 )
    {
      sub_5CFA8(v7);
      sub_5DF98(2, "src/zlog.c", 476, "pthread_setspecific fail, rd[%d]", v11);
      goto LABEL_6;
    }
    v8 = dword_58DE18;
  }
  if ( *v7 != (int *)v8 )
  {
    v9 = sub_5D290((int)v7, *(_DWORD *)(dword_99EEC8 + 1052), *(_DWORD *)(dword_99EEC8 + 1056));
    if ( v9 || (v9 = sub_5D3B0((int)v7, *(_DWORD *)(dword_99EEC8 + 9292))) != 0 )
    {
      sub_5DF98(2, "src/zlog.c", 476, "zlog_thread_resize_msg_buf fail, rd[%d]", v9);
      goto LABEL_6;
    }
    *v7 = (int *)dword_58DE18;
  }
  if ( sub_580C0(v7[1], a1, a2) )
  {
    sub_5DF98(2, "src/zlog.c", 479, "zlog_mdc_put fail, key[%s], value[%s]", a1, a2);
    goto LABEL_6;
  }
  result = pthread_rwlock_unlock(&stru_58DE1C);
  if ( result )
  {
    sub_5DF98(2, "src/zlog.c", 485, "pthread_rwlock_unlock fail, rc=[%d]", result);
    return -1;
  }
  return result;
}
// 58DE08: using guessed type int dword_58DE08;
// 58DE18: using guessed type int dword_58DE18;
// 58DE3C: using guessed type int dword_58DE3C;
// 99EEC8: using guessed type int dword_99EEC8;

//----- (00053D3C) --------------------------------------------------------
int __fastcall sub_53D3C(const char *a1)
{
  int v2; // r0
  int **v3; // r0
  int v4; // r5
  int v5; // r0
  int v7; // r0

  if ( !a1 )
  {
    v4 = 0;
    sub_5DF98(2, "src/zlog.c", 504, "key is null or 0");
    return v4;
  }
  v2 = pthread_rwlock_rdlock(&stru_58DE1C);
  if ( v2 )
  {
    v4 = 0;
    sub_5DF98(2, "src/zlog.c", 508, "pthread_rwlock_rdlock fail, rc[%d]", v2);
    return v4;
  }
  if ( dword_58DE3C )
  {
    v3 = (int **)pthread_getspecific(dword_58DE08);
    if ( v3 )
    {
      v4 = sub_581B8(v3[1], (int)a1);
      if ( v4 )
      {
        v5 = pthread_rwlock_unlock(&stru_58DE1C);
        if ( v5 )
        {
          v4 = 0;
          sub_5DF98(2, "src/zlog.c", 531, "pthread_rwlock_unlock fail, rc=[%d]", v5);
        }
        return v4;
      }
      sub_5DF98(2, "src/zlog.c", 525, "key[%s] not found in mdc", a1);
    }
    else
    {
      sub_5DF98(2, "src/zlog.c", 519, "thread not found, maybe not use zlog_put_mdc before");
    }
  }
  else
  {
    sub_5DF98(2, "src/zlog.c", 513, "never call zlog_init() or dzlog_init() before");
  }
  v7 = pthread_rwlock_unlock(&stru_58DE1C);
  v4 = v7;
  if ( !v7 )
    return v4;
  sub_5DF98(2, "src/zlog.c", 538, "pthread_rwlock_unlock fail, rc=[%d]", v7);
  return 0;
}
// 58DE08: using guessed type int dword_58DE08;
// 58DE3C: using guessed type int dword_58DE3C;

//----- (00053EC8) --------------------------------------------------------
int __fastcall sub_53EC8(const void *a1)
{
  int v2; // r0
  int result; // r0
  _DWORD ***v4; // r0

  if ( !a1 )
    return sub_5DF98(2, "src/zlog.c", 549, "key is null or 0");
  v2 = pthread_rwlock_rdlock(&stru_58DE1C);
  if ( v2 )
    return sub_5DF98(2, "src/zlog.c", 553, "pthread_rwlock_rdlock fail, rc[%d]", v2);
  if ( dword_58DE3C )
  {
    v4 = (_DWORD ***)pthread_getspecific(dword_58DE08);
    if ( v4 )
      sub_58238(v4[1], a1);
    else
      sub_5DF98(2, "src/zlog.c", 564, "thread not found, maybe not use zlog_put_mdc before");
  }
  else
  {
    sub_5DF98(2, "src/zlog.c", 558, "never call zlog_init() or dzlog_init() before");
  }
  result = pthread_rwlock_unlock(&stru_58DE1C);
  if ( result )
    return sub_5DF98(2, "src/zlog.c", 573, "pthread_rwlock_unlock fail, rc=[%d]", result);
  return result;
}
// 58DE08: using guessed type int dword_58DE08;
// 58DE3C: using guessed type int dword_58DE3C;

//----- (00053FE0) --------------------------------------------------------
int sub_53FE0()
{
  int v0; // r0
  _DWORD ***v1; // r0
  int result; // r0

  v0 = pthread_rwlock_rdlock(&stru_58DE1C);
  if ( v0 )
    return sub_5DF98(2, "src/zlog.c", 586, "pthread_rwlock_rdlock fail, rc[%d]", v0);
  if ( dword_58DE3C )
  {
    v1 = (_DWORD ***)pthread_getspecific(dword_58DE08);
    if ( v1 )
      sub_581B0(v1[1]);
    else
      sub_5DF98(2, "src/zlog.c", 597, "thread not found, maybe not use zlog_put_mdc before");
  }
  else
  {
    sub_5DF98(2, "src/zlog.c", 591, "never call zlog_init() or dzlog_init() before");
  }
  result = pthread_rwlock_unlock(&stru_58DE1C);
  if ( result )
    return sub_5DF98(2, "src/zlog.c", 606, "pthread_rwlock_unlock fail, rc=[%d]", result);
  return result;
}
// 58DE08: using guessed type int dword_58DE08;
// 58DE3C: using guessed type int dword_58DE3C;

//----- (000540C8) --------------------------------------------------------
int __fastcall sub_540C8(int a1, int a2)
{
  int v2; // r5
  int v5; // r3
  int v6; // r2
  bool v7; // nf
  int v8; // r4
  int v9; // r4
  int v10; // r6

  v2 = a1 + 1032;
  memset((void *)(a1 + 1032), 0, 0x20u);
  LOBYTE(v5) = a2 & 7;
  v6 = a2 / 8;
  v8 = -a2;
  v7 = v8 < 0;
  v9 = v8 & 7;
  v10 = a1 + v6;
  if ( !v7 )
    v5 = -v9;
  *(_BYTE *)(v10 + 1032) |= ~(-1 << (8 - v5));
  memset((void *)(v2 + v6 + 1), 255, 31 - v6);
  return 0;
}

//----- (000546C0) --------------------------------------------------------
int __fastcall sub_546C0(int result, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  int v8; // r12
  const char *v9; // r6
  _DWORD *v11; // r11
  int v12; // r0
  int v13; // r0
  unsigned int v14; // r2
  _DWORD *v15; // r0
  int v16; // r2
  int v18; // [sp+24h] [bp-34h]

  LOBYTE(v8) = a6 & 7;
  if ( a6 <= 0 )
    v8 = -(-a6 & 7);
  if ( (((int)*(unsigned __int8 *)(dword_58DE10 + a6 / 8 + 1032) >> (7 - v8)) & 1) != 0 )
  {
    v9 = (const char *)result;
    pthread_rwlock_rdlock(&stru_58DE1C);
    if ( !dword_58DE3C )
    {
      sub_5DF98(2, "src/zlog.c", 742, "never call zlog_init() or dzlog_init() before");
      return pthread_rwlock_unlock(&stru_58DE1C);
    }
    if ( dword_58DE10 )
    {
      v11 = pthread_getspecific(dword_58DE08);
      v12 = dword_58DE18;
      if ( !v11 )
      {
        v15 = sub_5D07C(
                dword_58DE18,
                *(_DWORD *)(dword_99EEC8 + 1052),
                *(_DWORD *)(dword_99EEC8 + 1056),
                *(_DWORD *)(dword_99EEC8 + 9292));
        v11 = v15;
        if ( !v15 )
        {
          sub_5DF98(2, "src/zlog.c", 753, "zlog_thread_new fail");
          return pthread_rwlock_unlock(&stru_58DE1C);
        }
        v16 = pthread_setspecific(dword_58DE08, v15);
        if ( v16 )
        {
          v18 = v16;
          sub_5CFA8(v11);
          sub_5DF98(2, "src/zlog.c", 753, "pthread_setspecific fail, rd[%d]", v18);
          return pthread_rwlock_unlock(&stru_58DE1C);
        }
        v12 = dword_58DE18;
      }
      if ( *v11 != v12 )
      {
        v13 = sub_5D290((int)v11, *(_DWORD *)(dword_99EEC8 + 1052), *(_DWORD *)(dword_99EEC8 + 1056));
        if ( v13 || (v13 = sub_5D3B0((int)v11, *(_DWORD *)(dword_99EEC8 + 9292))) != 0 )
        {
          sub_5DF98(2, "src/zlog.c", 753, "zlog_thread_resize_msg_buf fail, rd[%d]", v13);
          return pthread_rwlock_unlock(&stru_58DE1C);
        }
        *v11 = dword_58DE18;
      }
      sub_57540((_DWORD *)v11[2], dword_58DE10, *(_DWORD *)(dword_58DE10 + 1028), (int)v9, a2, a3, a4, a5, a6, a7, a8);
      if ( sub_55C7C(dword_58DE10, (int)v11) )
      {
        sub_5DF98(2, "src/zlog.c", 761, "zlog_output fail, srcfile[%s], srcline[%ld]", v9, a5);
      }
      else
      {
        v14 = *(_DWORD *)(dword_99EEC8 + 9276);
        if ( v14 )
        {
          if ( v14 < ++dword_58DE40 )
          {
            pthread_rwlock_unlock(&stru_58DE1C);
            result = sub_53314(-1);
            if ( result )
              return sub_5DF98(
                       2,
                       "src/zlog.c",
                       778,
                       "reach reload-conf-period but zlog_reload fail, zlog-chk-conf [file] see detail");
            return result;
          }
        }
      }
    }
    else
    {
      sub_5DF98(
        2,
        "src/zlog.c",
        749,
        "zlog_default_category is null,dzlog_init() or dzlog_set_cateogry() is not called above");
    }
    return pthread_rwlock_unlock(&stru_58DE1C);
  }
  return result;
}
// 58DE08: using guessed type int dword_58DE08;
// 58DE10: using guessed type int dword_58DE10;
// 58DE18: using guessed type int dword_58DE18;
// 58DE3C: using guessed type int dword_58DE3C;
// 58DE40: using guessed type int dword_58DE40;
// 99EEC8: using guessed type int dword_99EEC8;

//----- (000549B8) --------------------------------------------------------
int __fastcall sub_549B8(int result, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  int v8; // r12
  const char *v9; // r6
  _DWORD *v11; // r11
  int v12; // r0
  int v13; // r0
  unsigned int v14; // r2
  _DWORD *v15; // r0
  int v16; // r2
  int v18; // [sp+24h] [bp-34h]

  LOBYTE(v8) = a6 & 7;
  if ( a6 <= 0 )
    v8 = -(-a6 & 7);
  if ( (((int)*(unsigned __int8 *)(dword_58DE10 + a6 / 8 + 1032) >> (7 - v8)) & 1) != 0 )
  {
    v9 = (const char *)result;
    pthread_rwlock_rdlock(&stru_58DE1C);
    if ( !dword_58DE3C )
    {
      sub_5DF98(2, "src/zlog.c", 795, "never call zlog_init() or dzlog_init() before");
      return pthread_rwlock_unlock(&stru_58DE1C);
    }
    if ( dword_58DE10 )
    {
      v11 = pthread_getspecific(dword_58DE08);
      v12 = dword_58DE18;
      if ( !v11 )
      {
        v15 = sub_5D07C(
                dword_58DE18,
                *(_DWORD *)(dword_99EEC8 + 1052),
                *(_DWORD *)(dword_99EEC8 + 1056),
                *(_DWORD *)(dword_99EEC8 + 9292));
        v11 = v15;
        if ( !v15 )
        {
          sub_5DF98(2, "src/zlog.c", 806, "zlog_thread_new fail");
          return pthread_rwlock_unlock(&stru_58DE1C);
        }
        v16 = pthread_setspecific(dword_58DE08, v15);
        if ( v16 )
        {
          v18 = v16;
          sub_5CFA8(v11);
          sub_5DF98(2, "src/zlog.c", 806, "pthread_setspecific fail, rd[%d]", v18);
          return pthread_rwlock_unlock(&stru_58DE1C);
        }
        v12 = dword_58DE18;
      }
      if ( *v11 != v12 )
      {
        v13 = sub_5D290((int)v11, *(_DWORD *)(dword_99EEC8 + 1052), *(_DWORD *)(dword_99EEC8 + 1056));
        if ( v13 || (v13 = sub_5D3B0((int)v11, *(_DWORD *)(dword_99EEC8 + 9292))) != 0 )
        {
          sub_5DF98(2, "src/zlog.c", 806, "zlog_thread_resize_msg_buf fail, rd[%d]", v13);
          return pthread_rwlock_unlock(&stru_58DE1C);
        }
        *v11 = dword_58DE18;
      }
      sub_5759C((_DWORD *)v11[2], dword_58DE10, *(_DWORD *)(dword_58DE10 + 1028), (int)v9, a2, a3, a4, a5, a6, a7, a8);
      if ( sub_55C7C(dword_58DE10, (int)v11) )
      {
        sub_5DF98(2, "src/zlog.c", 814, "zlog_output fail, srcfile[%s], srcline[%ld]", v9, a5);
      }
      else
      {
        v14 = *(_DWORD *)(dword_99EEC8 + 9276);
        if ( v14 )
        {
          if ( v14 < ++dword_58DE40 )
          {
            pthread_rwlock_unlock(&stru_58DE1C);
            result = sub_53314(-1);
            if ( result )
              return sub_5DF98(
                       2,
                       "src/zlog.c",
                       831,
                       "reach reload-conf-period but zlog_reload fail, zlog-chk-conf [file] see detail");
            return result;
          }
        }
      }
    }
    else
    {
      sub_5DF98(
        2,
        "src/zlog.c",
        802,
        "zlog_default_category is null,dzlog_init() or dzlog_set_cateogry() is not called above");
    }
    return pthread_rwlock_unlock(&stru_58DE1C);
  }
  return result;
}
// 58DE08: using guessed type int dword_58DE08;
// 58DE10: using guessed type int dword_58DE10;
// 58DE18: using guessed type int dword_58DE18;
// 58DE3C: using guessed type int dword_58DE3C;
// 58DE40: using guessed type int dword_58DE40;
// 99EEC8: using guessed type int dword_99EEC8;

//----- (00054CB0) --------------------------------------------------------
int sub_54CB0(int result, const char *a2, int a3, int a4, int a5, int a6, int a7, int a8, ...)
{
  int v8; // r10
  int v9; // lr
  _DWORD *v13; // r6
  int v14; // r0
  int v15; // r0
  unsigned int v16; // r2
  _DWORD *v17; // r0
  int v18; // r11
  va_list va; // [sp+60h] [bp+10h] BYREF

  va_start(va, a8);
  v8 = result;
  if ( !result )
    goto LABEL_5;
  LOBYTE(v9) = a7 & 7;
  if ( a7 <= 0 )
    v9 = -(-a7 & 7);
  if ( (((int)*(unsigned __int8 *)(result + a7 / 8 + 1032) >> (7 - v9)) & 1) != 0 )
  {
LABEL_5:
    pthread_rwlock_rdlock(&stru_58DE1C);
    if ( !dword_58DE3C )
    {
      sub_5DF98(2, "src/zlog.c", 850, "never call zlog_init() or dzlog_init() before");
      return pthread_rwlock_unlock(&stru_58DE1C);
    }
    v13 = pthread_getspecific(dword_58DE08);
    v14 = dword_58DE18;
    if ( !v13 )
    {
      v17 = sub_5D07C(
              dword_58DE18,
              *(_DWORD *)(dword_99EEC8 + 1052),
              *(_DWORD *)(dword_99EEC8 + 1056),
              *(_DWORD *)(dword_99EEC8 + 9292));
      v13 = v17;
      if ( !v17 )
      {
        sub_5DF98(2, "src/zlog.c", 854, "zlog_thread_new fail");
        return pthread_rwlock_unlock(&stru_58DE1C);
      }
      v18 = pthread_setspecific(dword_58DE08, v17);
      if ( v18 )
      {
        sub_5CFA8(v13);
        sub_5DF98(2, "src/zlog.c", 854, "pthread_setspecific fail, rd[%d]", v18);
        return pthread_rwlock_unlock(&stru_58DE1C);
      }
      v14 = dword_58DE18;
    }
    if ( *v13 != v14 )
    {
      v15 = sub_5D290((int)v13, *(_DWORD *)(dword_99EEC8 + 1052), *(_DWORD *)(dword_99EEC8 + 1056));
      if ( v15 || (v15 = sub_5D3B0((int)v13, *(_DWORD *)(dword_99EEC8 + 9292))) != 0 )
      {
        sub_5DF98(2, "src/zlog.c", 854, "zlog_thread_resize_msg_buf fail, rd[%d]", v15);
        return pthread_rwlock_unlock(&stru_58DE1C);
      }
      *v13 = dword_58DE18;
    }
    sub_57540((_DWORD *)v13[2], v8, *(_DWORD *)(v8 + 1028), (int)a2, a3, a4, a5, a6, a7, a8, (int)va);
    if ( sub_55C7C(v8, (int)v13) )
    {
      sub_5DF98(2, "src/zlog.c", 861, "zlog_output fail, srcfile[%s], srcline[%ld]", a2, a6);
      return pthread_rwlock_unlock(&stru_58DE1C);
    }
    v16 = *(_DWORD *)(dword_99EEC8 + 9276);
    if ( !v16 )
      return pthread_rwlock_unlock(&stru_58DE1C);
    if ( v16 >= ++dword_58DE40 )
      return pthread_rwlock_unlock(&stru_58DE1C);
    pthread_rwlock_unlock(&stru_58DE1C);
    result = sub_53314(-1);
    if ( result )
      return sub_5DF98(
               2,
               "src/zlog.c",
               880,
               "reach reload-conf-period but zlog_reload fail, zlog-chk-conf [file] see detail");
  }
  return result;
}
// 58DE08: using guessed type int dword_58DE08;
// 58DE18: using guessed type int dword_58DE18;
// 58DE3C: using guessed type int dword_58DE3C;
// 58DE40: using guessed type int dword_58DE40;
// 99EEC8: using guessed type int dword_99EEC8;

//----- (00054F58) --------------------------------------------------------
int sub_54F58(const char *a1, int a2, int a3, int a4, int a5, int a6, int a7, ...)
{
  int v11; // r3
  int result; // r0
  _DWORD *v13; // r10
  int v14; // r0
  int v15; // r0
  unsigned int v16; // r2
  _DWORD *v17; // r0
  int v18; // r11
  va_list va; // [sp+5Ch] [bp+Ch] BYREF

  va_start(va, a7);
  pthread_rwlock_rdlock(&stru_58DE1C);
  if ( !dword_58DE3C )
  {
    sub_5DF98(2, "src/zlog.c", 896, "never call zlog_init() or dzlog_init() before");
    return pthread_rwlock_unlock(&stru_58DE1C);
  }
  if ( !dword_58DE10 )
  {
    sub_5DF98(
      2,
      "src/zlog.c",
      903,
      "zlog_default_category is null,dzlog_init() or dzlog_set_cateogry() is not called above");
    return pthread_rwlock_unlock(&stru_58DE1C);
  }
  LOBYTE(v11) = a6 & 7;
  if ( a6 <= 0 )
    v11 = -(-a6 & 7);
  if ( (((int)*(unsigned __int8 *)(dword_58DE10 + a6 / 8 + 1032) >> (7 - v11)) & 1) == 0 )
    return pthread_rwlock_unlock(&stru_58DE1C);
  v13 = pthread_getspecific(dword_58DE08);
  v14 = dword_58DE18;
  if ( !v13 )
  {
    v17 = sub_5D07C(
            dword_58DE18,
            *(_DWORD *)(dword_99EEC8 + 1052),
            *(_DWORD *)(dword_99EEC8 + 1056),
            *(_DWORD *)(dword_99EEC8 + 9292));
    v13 = v17;
    if ( !v17 )
    {
      sub_5DF98(2, "src/zlog.c", 909, "zlog_thread_new fail");
      return pthread_rwlock_unlock(&stru_58DE1C);
    }
    v18 = pthread_setspecific(dword_58DE08, v17);
    if ( v18 )
    {
      sub_5CFA8(v13);
      sub_5DF98(2, "src/zlog.c", 909, "pthread_setspecific fail, rd[%d]", v18);
      return pthread_rwlock_unlock(&stru_58DE1C);
    }
    v14 = dword_58DE18;
  }
  if ( *v13 != v14 )
  {
    v15 = sub_5D290((int)v13, *(_DWORD *)(dword_99EEC8 + 1052), *(_DWORD *)(dword_99EEC8 + 1056));
    if ( !v15 )
    {
      v15 = sub_5D3B0((int)v13, *(_DWORD *)(dword_99EEC8 + 9292));
      if ( !v15 )
      {
        *v13 = dword_58DE18;
        goto LABEL_13;
      }
    }
    sub_5DF98(2, "src/zlog.c", 909, "zlog_thread_resize_msg_buf fail, rd[%d]", v15);
    return pthread_rwlock_unlock(&stru_58DE1C);
  }
LABEL_13:
  sub_57540((_DWORD *)v13[2], dword_58DE10, *(_DWORD *)(dword_58DE10 + 1028), (int)a1, a2, a3, a4, a5, a6, a7, (int)va);
  if ( sub_55C7C(dword_58DE10, (int)v13) )
  {
    sub_5DF98(2, "src/zlog.c", 918, "zlog_output fail, srcfile[%s], srcline[%ld]", a1, a5);
    return pthread_rwlock_unlock(&stru_58DE1C);
  }
  v16 = *(_DWORD *)(dword_99EEC8 + 9276);
  if ( !v16 )
    return pthread_rwlock_unlock(&stru_58DE1C);
  if ( v16 >= ++dword_58DE40 )
    return pthread_rwlock_unlock(&stru_58DE1C);
  pthread_rwlock_unlock(&stru_58DE1C);
  result = sub_53314(-1);
  if ( result )
    return sub_5DF98(
             2,
             "src/zlog.c",
             937,
             "reach reload-conf-period but zlog_reload fail, zlog-chk-conf [file] see detail");
  return result;
}
// 58DE08: using guessed type int dword_58DE08;
// 58DE10: using guessed type int dword_58DE10;
// 58DE18: using guessed type int dword_58DE18;
// 58DE3C: using guessed type int dword_58DE3C;
// 58DE40: using guessed type int dword_58DE40;
// 99EEC8: using guessed type int dword_99EEC8;

//----- (0005521C) --------------------------------------------------------
int sub_5521C()
{
  int v0; // r0
  int result; // r0

  v0 = pthread_rwlock_rdlock(&stru_58DE1C);
  if ( v0 )
    return sub_5DF98(2, "src/zlog.c", 948, "pthread_rwlock_wrlock fail, rc[%d]", v0);
  sub_5DF98(1, "src/zlog.c", 951, "------zlog_profile start------ ");
  sub_5DF98(1, "src/zlog.c", 952, "is init:[%d]", dword_58DE3C);
  sub_5DF98(1, "src/zlog.c", 953, "init version:[%d]", dword_58DE18);
  sub_56B38(dword_99EEC8, 1);
  sub_58414((const void *)dword_58DE14, 1);
  sub_55CCC((const void *)dword_58DE0C, 1);
  if ( dword_58DE10 )
  {
    sub_5DF98(1, "src/zlog.c", 958, "-default_category-");
    sub_557C4((const void **)dword_58DE10, 1);
  }
  sub_5DF98(1, "src/zlog.c", 961, "------zlog_profile end------ ");
  result = pthread_rwlock_unlock(&stru_58DE1C);
  if ( result )
    return sub_5DF98(2, "src/zlog.c", 964, "pthread_rwlock_unlock fail, rc=[%d]", result);
  return result;
}
// 58DE0C: using guessed type int dword_58DE0C;
// 58DE10: using guessed type int dword_58DE10;
// 58DE14: using guessed type int dword_58DE14;
// 58DE18: using guessed type int dword_58DE18;
// 58DE3C: using guessed type int dword_58DE3C;
// 99EEC8: using guessed type int dword_99EEC8;

//----- (00055388) --------------------------------------------------------
int __fastcall sub_55388(const char *a1, int a2)
{
  int v4; // r0
  int v5; // r6
  int v6; // r0
  _DWORD *v8; // r0
  void *v9; // r5
  _DWORD *v10; // r3
  int v11; // r5
  int v12; // r0

  if ( a1 )
  {
    if ( a2 )
    {
      v4 = pthread_rwlock_wrlock(&stru_58DE1C);
      if ( v4 )
      {
        v5 = -1;
        sub_5DF98(2, "src/zlog.c", 983, "pthread_rwlock_rdlock fail, rd[%d]", v4);
      }
      else
      {
        v5 = dword_58DE3C;
        if ( dword_58DE3C )
        {
          v8 = sub_58304(a1, a2);
          v9 = v8;
          if ( v8 )
          {
            v5 = sub_5DAC0(dword_58DE14, (int)v8, (int)v8);
            if ( v5 )
            {
              sub_582A0(v9);
              sub_5DF98(2, "src/zlog.c", 1002, "zc_hashtable_put fail");
            }
            else
            {
              v10 = *(_DWORD **)(dword_99EEC8 + 9288);
              if ( (int)v10[1] > 0 )
              {
                v11 = 0;
                do
                {
                  v12 = *(_DWORD *)(*v10 + 4 * v11++);
                  sub_5BCCC(v12, dword_58DE14);
                  v10 = *(_DWORD **)(dword_99EEC8 + 9288);
                }
                while ( v10[1] > v11 );
              }
            }
          }
          else
          {
            sub_5DF98(2, "src/zlog.c", 995, "zlog_record_new fail");
            v5 = -1;
          }
        }
        else
        {
          sub_5DF98(2, "src/zlog.c", 988, "never call zlog_init() or dzlog_init() before");
        }
        v6 = pthread_rwlock_unlock(&stru_58DE1C);
        if ( v6 )
        {
          v5 = -1;
          sub_5DF98(2, "src/zlog.c", 1013, "pthread_rwlock_unlock fail, rd=[%d]", v6);
        }
      }
    }
    else
    {
      sub_5DF98(2, "src/zlog.c", 979, "record_output is null or 0");
      return -1;
    }
  }
  else
  {
    sub_5DF98(2, "src/zlog.c", 978, "rname is null or 0");
    return -1;
  }
  return v5;
}
// 58DE14: using guessed type int dword_58DE14;
// 58DE3C: using guessed type int dword_58DE3C;
// 99EEC8: using guessed type int dword_99EEC8;

//----- (00055568) --------------------------------------------------------
int __fastcall sub_55568(int result, int a2)
{
  int v2; // r2
  int v3; // r3
  bool v4; // nf
  int v5; // r1
  int v6; // r1
  int v7; // r0

  if ( result )
  {
    v2 = a2 + 7;
    if ( a2 >= 0 )
      v2 = a2;
    LOBYTE(v3) = a2 & 7;
    v5 = -a2;
    v4 = v5 < 0;
    v6 = v5 & 7;
    v7 = *(unsigned __int8 *)(result + (v2 >> 3) + 1032);
    if ( !v4 )
      v3 = -v6;
    return (v7 >> (7 - v3)) & 1;
  }
  return result;
}

//----- (000555A4) --------------------------------------------------------
const char *sub_555A4()
{
  return "1.2.12";
}

//----- (000555B0) --------------------------------------------------------
int __fastcall sub_555B0(int a1, _DWORD *a2, int *a3)
{
  _DWORD *v4; // r0
  _DWORD *v7; // r0
  int v8; // r5
  int v9; // r6
  int v10; // r10
  _BYTE *v11; // r4
  _BYTE *v12; // r3
  _BYTE *v13; // r0
  char v14; // r1
  char v15; // t1
  char v16; // t1
  int result; // r0
  int v18; // r5
  _BYTE *v19; // r3
  int v20; // r7
  char v21; // r2
  char v22; // t1
  char v23; // t1

  v4 = *(_DWORD **)(a1 + 1096);
  if ( v4 )
    sub_5D580(v4);
  memset((void *)(a1 + 1032), 0, 0x20u);
  v7 = sub_5D4C0(0);
  *(_DWORD *)(a1 + 1096) = v7;
  if ( !v7 )
  {
    sub_5DF98(2, "src/category.c", 72, "zc_arraylist_new fail");
    return -1;
  }
  if ( *a3 <= 0 )
    goto LABEL_23;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  do
  {
    v11 = *(_BYTE **)(*a2 + 4 * v9);
    if ( sub_5BBE8((int)v11, (char *)a1) )
    {
      if ( sub_5D694(*(_DWORD *)(a1 + 1096), (int)v11) )
      {
        sub_5DF98(2, "src/category.c", 81, "zc_arrylist_add fail");
LABEL_22:
        sub_5D580(*(_DWORD **)(a1 + 1096));
        result = -1;
        *(_DWORD *)(a1 + 1096) = 0;
        return result;
      }
      v12 = (_BYTE *)(a1 + 1031);
      v13 = v11 + 4103;
      do
      {
        v15 = *++v12;
        v14 = v15;
        v16 = *++v13;
        *v12 = v14 | v16;
      }
      while ( v12 != (_BYTE *)(a1 + 1063) );
      ++v10;
    }
    ++v9;
    if ( sub_5BB9C(v11) )
      v8 = (int)v11;
  }
  while ( v9 < *a3 );
  if ( v10 )
    return 0;
  if ( !v8 )
  {
LABEL_23:
    sub_5DF98(0, "src/category.c", 103, "category[%s], no match rules & no wastebin_rule", (const char *)a1);
    return 0;
  }
  sub_5DF98(0, "src/category.c", 95, "category[%s], no match rules, use wastebin_rule", (const char *)a1);
  if ( sub_5D694(*(_DWORD *)(a1 + 1096), v8) )
  {
    sub_5DF98(2, "src/category.c", 97, "zc_arrylist_add fail");
    goto LABEL_22;
  }
  v18 = v8 + 4103;
  v19 = (_BYTE *)(a1 + 1031);
  v20 = a1 + 1063;
  do
  {
    v22 = *++v19;
    v21 = v22;
    v23 = *(_BYTE *)++v18;
    *v19 = v21 | v23;
  }
  while ( (_BYTE *)v20 != v19 );
  return 0;
}

//----- (000557C4) --------------------------------------------------------
int __fastcall sub_557C4(const void **a1, int a2)
{
  int result; // r0
  _DWORD *v5; // r3
  int v6; // r4
  int v7; // r0

  if ( !a1 )
    return sub_5DF98(2, "src/category.c", 22, "a_category is null or 0");
  result = sub_5DF98(a2, "src/category.c", 26, "--category[%p][%s][%p]--", a1, (const char *)a1, a1[274]);
  v5 = a1[274];
  if ( v5 && (int)v5[1] > 0 )
  {
    v6 = 0;
    do
    {
      v7 = *(_DWORD *)(*v5 + 4 * v6++);
      result = sub_5A850(v7, a2);
      v5 = a1[274];
    }
    while ( v5[1] > v6 );
  }
  return result;
}

//----- (00055870) --------------------------------------------------------
void __fastcall sub_55870(_DWORD *a1)
{
  _DWORD *v2; // r0

  if ( a1 )
  {
    v2 = (_DWORD *)a1[274];
    if ( v2 )
      sub_5D580(v2);
    sub_5DF98(0, "src/category.c", 40, "zlog_category_del[%p]", a1);
    free(a1);
  }
  else
  {
    sub_5DF98(2, "src/category.c", 38, "a_category is null or 0");
  }
}

//----- (000558E4) --------------------------------------------------------
int __fastcall sub_558E4(const char *a1, _DWORD *a2)
{
  size_t v4; // r6
  void *v5; // r0
  int v6; // r4
  _DWORD *v8; // r0
  int *v9; // r0

  if ( a1 )
  {
    if ( a2 )
    {
      v4 = strlen(a1);
      if ( v4 > 0x400 )
      {
        v6 = 0;
        sub_5DF98(2, "src/category.c", 124, "name[%s] too long", a1);
      }
      else
      {
        v5 = calloc(1u, 0x450u);
        v6 = (int)v5;
        if ( v5 )
        {
          memcpy(v5, a1, v4 + 1);
          *(_DWORD *)(v6 + 1028) = v4;
          if ( sub_555B0(v6, a2, a2 + 1) )
          {
            sub_5DF98(2, "src/category.c", 135, "zlog_category_fit_rules fail");
            v8 = (_DWORD *)v6;
            v6 = 0;
            sub_55870(v8);
          }
          else
          {
            sub_557C4((const void **)v6, 0);
          }
        }
        else
        {
          v9 = _errno_location();
          sub_5DF98(2, "src/category.c", 129, "calloc fail, errno[%d]", *v9);
        }
      }
    }
    else
    {
      v6 = 0;
      sub_5DF98(2, "src/category.c", 120, "rules is null or 0");
    }
  }
  else
  {
    v6 = 0;
    sub_5DF98(2, "src/category.c", 119, "name is null or 0");
  }
  return v6;
}

//----- (00055A28) --------------------------------------------------------
int __fastcall sub_55A28(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v4; // r0
  int v5; // r7
  int v6; // r6
  int v7; // lr
  int v8; // r2
  int v9; // r0
  int v10; // r7
  int v11; // r6
  int v12; // lr
  int result; // r0

  if ( a1 )
  {
    if ( a2 )
    {
      v4 = (_DWORD *)a1[275];
      if ( v4 )
        sub_5D580(v4);
      v5 = a1[259];
      v6 = a1[260];
      v7 = a1[261];
      v8 = a1[274];
      a1[266] = a1[258];
      a1[267] = v5;
      v9 = a1[262];
      a1[268] = v6;
      a1[269] = v7;
      v10 = a1[263];
      v11 = a1[264];
      v12 = a1[265];
      a1[275] = v8;
      a1[270] = v9;
      a1[274] = 0;
      a1[271] = v10;
      a1[272] = v11;
      a1[273] = v12;
      result = sub_555B0((int)a1, a2, a2 + 1);
      if ( result )
      {
        sub_5DF98(2, "src/category.c", 163, "zlog_category_obtain_rules fail");
        result = -1;
        a1[274] = 0;
      }
    }
    else
    {
      sub_5DF98(2, "src/category.c", 151, "new_rules is null or 0");
      return -1;
    }
  }
  else
  {
    sub_5DF98(2, "src/category.c", 150, "a_category is null or 0");
    return -1;
  }
  return result;
}

//----- (00055B28) --------------------------------------------------------
void *__fastcall sub_55B28(int a1)
{
  _DWORD *v2; // r0

  if ( !a1 )
    return (void *)sub_5DF98(2, "src/category.c", 176, "a_category is null or 0");
  v2 = *(_DWORD **)(a1 + 1100);
  if ( !v2 )
    return (void *)sub_5DF98(1, "src/category.c", 178, "a_category->fit_rules_backup is NULL, never update before");
  sub_5D580(v2);
  *(_DWORD *)(a1 + 1100) = 0;
  return memset((void *)(a1 + 1064), 0, 0x20u);
}

//----- (00055BA0) --------------------------------------------------------
void *__fastcall sub_55BA0(_DWORD *a1)
{
  int v2; // r3
  _DWORD *v3; // r0
  int v4; // r3
  int v5; // r6
  int v6; // r5
  int v7; // lr
  int v8; // r6
  int v9; // r5
  int v10; // lr

  if ( !a1 )
    return (void *)sub_5DF98(2, "src/category.c", 194, "a_category is null or 0");
  v2 = a1[275];
  if ( !v2 )
    return (void *)sub_5DF98(1, "src/category.c", 196, "a_category->fit_rules_backup in NULL, never update before");
  v3 = (_DWORD *)a1[274];
  if ( v3 )
  {
    sub_5D580(v3);
    v4 = a1[275];
    a1[275] = 0;
    a1[274] = v4;
  }
  else
  {
    a1[274] = v2;
    a1[275] = 0;
  }
  v5 = a1[267];
  v6 = a1[268];
  v7 = a1[269];
  a1[258] = a1[266];
  a1[259] = v5;
  a1[260] = v6;
  a1[261] = v7;
  v8 = a1[271];
  v9 = a1[272];
  v10 = a1[273];
  a1[262] = a1[270];
  a1[263] = v8;
  a1[264] = v9;
  a1[265] = v10;
  return memset(a1 + 266, 0, 0x20u);
}

//----- (00055C7C) --------------------------------------------------------
int __fastcall sub_55C7C(int a1, int a2)
{
  _DWORD *v2; // r3
  int v5; // r4
  int v6; // r0
  int result; // r0

  v2 = *(_DWORD **)(a1 + 1096);
  if ( (int)v2[1] <= 0 )
    return 0;
  v5 = 0;
  do
  {
    v6 = *(_DWORD *)(*v2 + 4 * v5++);
    result = sub_5BABC(v6, a2);
    v2 = *(_DWORD **)(a1 + 1096);
  }
  while ( v2[1] > v5 );
  return result;
}

//----- (00055CCC) --------------------------------------------------------
int __fastcall sub_55CCC(const void *a1, int a2)
{
  int result; // r0
  int i; // r4

  if ( !a1 )
    return sub_5DF98(2, "src/category_table.c", 21, "categories is null or 0");
  sub_5DF98(a2, "src/category_table.c", 22, "-category_table[%p]-", a1);
  result = sub_5DE60((int)a1);
  for ( i = result; result; i = result )
  {
    sub_557C4(*(const void ***)(i + 8), a2);
    result = sub_5DEA8((int)a1, (unsigned int *)i);
  }
  return result;
}

//----- (00055D5C) --------------------------------------------------------
int __fastcall sub_55D5C(_DWORD *a1)
{
  if ( !a1 )
    return sub_5DF98(2, "src/category_table.c", 34, "categories is null or 0");
  sub_5D890(a1);
  return sub_5DF98(0, "src/category_table.c", 36, "zlog_category_table_del[%p]", a1);
}

//----- (00055DB8) --------------------------------------------------------
_DWORD *sub_55DB8()
{
  _DWORD *v0; // r0
  _DWORD *v1; // r4

  v0 = sub_5D7B8(0x14u, (int)sub_5DF18, (int)sub_5DF44, 0, (int)sub_55870);
  v1 = v0;
  if ( v0 )
    sub_55CCC(v0, 0);
  else
    sub_5DF98(2, "src/category_table.c", 49, "zc_hashtable_new fail");
  return v1;
}

//----- (00055E24) --------------------------------------------------------
int __fastcall sub_55E24(int a1, _DWORD *a2)
{
  unsigned int v4; // r4

  if ( a1 )
  {
    v4 = sub_5DE60(a1);
    if ( v4 )
    {
      while ( !sub_55A28(*(_DWORD **)(v4 + 8), a2) )
      {
        v4 = sub_5DEA8(a1, (unsigned int *)v4);
        if ( !v4 )
          return 0;
      }
      sub_5DF98(2, "src/category_table.c", 66, "zlog_category_update_rules fail, try rollback");
      return -1;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    sub_5DF98(2, "src/category_table.c", 62, "categories is null or 0");
    return -1;
  }
}

//----- (00055EBC) --------------------------------------------------------
int __fastcall sub_55EBC(int a1)
{
  int result; // r0
  int i; // r4

  if ( !a1 )
    return sub_5DF98(2, "src/category_table.c", 78, "categories is null or 0");
  result = sub_5DE60(a1);
  for ( i = result; result; i = result )
  {
    sub_55B28(*(_DWORD *)(i + 8));
    result = sub_5DEA8(a1, (unsigned int *)i);
  }
  return result;
}

//----- (00055F14) --------------------------------------------------------
int __fastcall sub_55F14(int a1)
{
  int result; // r0
  int i; // r4

  if ( !a1 )
    return sub_5DF98(2, "src/category_table.c", 91, "categories is null or 0");
  result = sub_5DE60(a1);
  for ( i = result; result; i = result )
  {
    sub_55BA0(*(_DWORD **)(i + 8));
    result = sub_5DEA8(a1, (unsigned int *)i);
  }
  return result;
}

//----- (00055F6C) --------------------------------------------------------
_DWORD *__fastcall sub_55F6C(int a1, const char *a2, _DWORD *a3)
{
  int v6; // r4
  _DWORD *v8; // r6

  if ( a1 )
  {
    v6 = sub_5DA58(a1, (int)a2);
    if ( !v6 )
    {
      v8 = (_DWORD *)sub_558E4(a2, a3);
      if ( v8 )
      {
        if ( sub_5DAC0(a1, (int)v8, (int)v8) )
        {
          sub_5DF98(2, "src/category_table.c", 119, "zc_hashtable_put fail");
          sub_55870(v8);
        }
        else
        {
          return v8;
        }
      }
      else
      {
        sub_5DF98(2, "src/category_table.c", 114, "zc_category_new fail");
      }
    }
  }
  else
  {
    v6 = 0;
    sub_5DF98(2, "src/category_table.c", 105, "categories is null or 0");
  }
  return (_DWORD *)v6;
}

//----- (00056030) --------------------------------------------------------
int __fastcall sub_56030(int a1)
{
  FILE *v2; // r7
  int v3; // r4
  char *v4; // r10
  int v5; // r5
  size_t v6; // r0
  int v7; // r11
  const unsigned __int16 **v8; // r0
  char *v9; // r2
  const unsigned __int16 *v10; // r9
  int v11; // t1
  int v12; // r3
  char v13; // r1
  char *v14; // r3
  char *v15; // r0
  int v16; // t1
  char *j; // r10
  int v18; // r2
  unsigned __int8 *v19; // r3
  int v20; // t1
  int v21; // r3
  int v22; // r1
  char *v23; // r2
  int v24; // t1
  size_t v25; // r0
  unsigned __int8 *v27; // r10
  char *v28; // r0
  char *v29; // r5
  unsigned int v30; // r3
  pthread_mutex_t *v31; // r0
  char *v32; // r0
  int v33; // r3
  char *v34; // r0
  int *v35; // r0
  char *arg; // [sp+0h] [bp-60F8h]
  int v37; // [sp+4h] [bp-60F4h]
  int i; // [sp+10h] [bp-60E8h]
  int c; // [sp+14h] [bp-60E4h]
  const char **v40; // [sp+18h] [bp-60E0h]
  int v41; // [sp+20h] [bp-60D8h] BYREF
  struct tm tp; // [sp+24h] [bp-60D4h] BYREF
  char v43[80]; // [sp+50h] [bp-60A8h] BYREF
  time_t timer; // [sp+A0h] [bp-6058h] BYREF
  char s[4100]; // [sp+B8h] [bp-6040h] BYREF
  char v46[4100]; // [sp+10BCh] [bp-503Ch] BYREF
  char s1[4100]; // [sp+20C0h] [bp-4038h] BYREF
  char v48[4100]; // [sp+30C4h] [bp-3034h] BYREF
  char v49[4100]; // [sp+40C8h] [bp-2030h] BYREF
  char v50[4140]; // [sp+50CCh] [bp-102Ch] BYREF

  c = _lxstat64(3, a1, v43);
  if ( c )
  {
    v35 = _errno_location();
    c = -1;
    sub_5DF98(2, "src/conf.c", 238, "lstat conf file[%s] fail, errno[%d]", (const char *)a1, *v35);
    return c;
  }
  localtime_r(&timer, &tp);
  strftime((char *)(a1 + 1025), 0x15u, "%F %T", &tp);
  v2 = (FILE *)fopen64(a1, "r");
  if ( !v2 )
  {
    c = -1;
    sub_5DF98(2, "src/conf.c", 245, "open configure file[%s] fail", (const char *)a1);
    return c;
  }
  v3 = 0;
  memset(s, 0, 0x1001u);
  v4 = s;
  v5 = 0;
  v40 = (const char **)(a1 + 9292);
  for ( i = 0; ; i = 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
LABEL_4:
        if ( !fgets(v4, 4097 - v5, v2) )
          goto LABEL_38;
        ++v3;
        v6 = strlen(v4) - 1;
        if ( v4[v6] == 10 )
          v4[v6] = 0;
        v7 = (unsigned __int8)*v4;
        if ( *v4 )
        {
          v8 = _ctype_b_loc();
          v9 = v4;
          v10 = *v8;
          while ( 1 )
          {
            v12 = v10[v7] & 0x2000;
            if ( (v10[v7] & 0x2000) == 0 )
              break;
            v11 = (unsigned __int8)*++v9;
            v7 = v11;
            if ( !v11 )
              goto LABEL_4;
          }
          if ( v7 != 35 )
            break;
        }
      }
      v13 = *v9;
      if ( *v9 )
      {
        v15 = v4 - 1;
        do
        {
          *++v15 = v13;
          ++v12;
          v16 = (unsigned __int8)*++v9;
          v13 = v16;
        }
        while ( v16 );
        v14 = &v4[v12];
      }
      else
      {
        v14 = v4;
      }
      *v14 = 0;
      for ( j = &v4[strlen(v4) - 1]; ; --j )
      {
        v19 = (unsigned __int8 *)(j - 1);
        v18 = (unsigned __int8)*j;
        if ( (v10[v18] & 0x2000) == 0 )
          break;
      }
      if ( v18 != 92 || j - s > 4066 )
        break;
      if ( (v10[(unsigned __int8)*(j - 1)] & 0x2000) != 0 )
      {
        do
          v20 = *--v19;
        while ( (v10[v20] & 0x2000) != 0 );
      }
      v4 = (char *)(v19 + 1);
      v5 = v19 + 1 - (unsigned __int8 *)s;
      v19[1] = 0;
    }
    v21 = (unsigned __int8)s[0];
    v22 = 0;
    j[1] = 0;
    if ( v21 )
      break;
    v25 = strlen(s);
    if ( v25 > 0x1000 )
      goto LABEL_97;
LABEL_35:
    switch ( i )
    {
      case 1:
        memset(v46, 0, 0x1001u);
        memset(v50, 0, 0x1001u);
        if ( _isoc99_sscanf(s, " %[^=]= %s ", v46, v50) != 2 )
        {
          sub_5DF98(2, "src/conf.c", 412, "sscanf [%s] fail, name or value is null", s);
          goto LABEL_37;
        }
        memset(s1, 0, 0x1001u);
        memset(v48, 0, 0x1001u);
        memset(v49, 0, 0x1001u);
        v41 = 0;
        _isoc99_sscanf(v46, "%s%n%s%s", s1, &v41, v48, v49);
        if ( !strcmp(s1, "strict") && !strcmp(v48, "init") )
        {
          if ( strcasecmp(v50, "false") || getenv("ZLOG_STRICT_INIT") )
          {
            v4 = s;
            *(_DWORD *)(a1 + 1048) = 1;
            v5 = 0;
          }
          else
          {
            *(_DWORD *)(a1 + 1048) = 0;
            v5 = 0;
            v4 = s;
          }
          goto LABEL_4;
        }
        if ( !strcmp(s1, "buffer") && v48[0] == 109 )
        {
          if ( v48[1] == 105 )
          {
            if ( v48[2] == 110 )
            {
              v5 = (unsigned __int8)v48[3];
              if ( !v48[3] )
              {
                v4 = s;
                *(_DWORD *)(a1 + 1052) = sub_5E140(v50);
                goto LABEL_4;
              }
            }
          }
          else if ( v48[1] == 97 && v48[2] == 120 )
          {
            v5 = (unsigned __int8)v48[3];
            if ( !v48[3] )
            {
              v4 = s;
              *(_DWORD *)(a1 + 1056) = sub_5E140(v50);
              goto LABEL_4;
            }
          }
        }
        if ( !strcmp(s1, "file") )
        {
          v5 = strcmp(v48, "perms");
          if ( !v5 )
          {
            _isoc99_sscanf(v50, "%o", a1 + 9268);
            v4 = s;
            goto LABEL_4;
          }
        }
        if ( !strcmp(s1, "rotate") && !strcmp(v48, "lock") )
        {
          v5 = strcmp(v49, "file");
          if ( !v5 )
          {
            v33 = strcmp(v50, "self");
            v34 = (char *)(a1 + 1060);
            if ( v33 )
            {
              v4 = s;
              strcpy(v34, v50);
            }
            else
            {
              v5 = 0;
              v4 = s;
              strcpy(v34, (const char *)a1);
            }
            goto LABEL_4;
          }
        }
        if ( !strcmp(s1, "default") )
        {
          v5 = strcmp(v48, "format");
          if ( !v5 )
          {
            v4 = s;
            strcpy((char *)(a1 + 5164), &s[v41]);
            goto LABEL_4;
          }
        }
        if ( !strcmp(s1, "reload") && !strcmp(v48, "conf") )
        {
          v5 = strcmp(v49, "period");
          if ( !v5 )
          {
            v4 = s;
            *(_DWORD *)(a1 + 9276) = sub_5E140(v50);
            goto LABEL_4;
          }
        }
        if ( !strcmp(s1, "fsync") )
        {
          v5 = strcmp(v48, "period");
          if ( !v5 )
          {
            v4 = s;
            *(_DWORD *)(a1 + 9272) = sub_5E140(v50);
            goto LABEL_4;
          }
        }
        sub_5DF98(2, "src/conf.c", 454, "name[%s] is not any one of global options", v46);
        if ( *(_DWORD *)(a1 + 1048) )
          goto LABEL_37;
        break;
      case 2:
        if ( !sub_57B80(*(_DWORD *)(a1 + 9280), s) )
          goto LABEL_45;
        sub_5DF98(2, "src/conf.c", 460, "zlog_level_list_set fail");
        if ( *(_DWORD *)(a1 + 1048) )
          goto LABEL_37;
        v4 = s;
        v5 = 0;
        goto LABEL_4;
      case 3:
        v28 = sub_576E4(s, v40);
        v29 = v28;
        if ( v28 )
        {
          if ( sub_5D694(*(_DWORD *)(a1 + 9284), (int)v28) )
          {
            sub_5766C(v29);
            sub_5DF98(2, "src/conf.c", 473, "zc_arraylist_add fail");
            goto LABEL_37;
          }
        }
        else
        {
          sub_5DF98(2, "src/conf.c", 467, "zlog_format_new fail [%s]", s);
          if ( *(_DWORD *)(a1 + 1048) )
            goto LABEL_37;
        }
        goto LABEL_45;
      case 4:
        v27 = sub_5AA9C(
                s,
                *(_DWORD **)(a1 + 9280),
                *(_DWORD *)(a1 + 9264),
                *(__int64 **)(a1 + 9284),
                *(_DWORD *)(a1 + 9268),
                *(_DWORD *)(a1 + 9272),
                v40);
        if ( v27 )
        {
          if ( !sub_5D694(*(_DWORD *)(a1 + 9288), (int)v27) )
            goto LABEL_42;
          sub_5A97C(v27);
          sub_5DF98(2, "src/conf.c", 493, "zc_arraylist_add fail");
        }
        else
        {
          arg = s;
          sub_5DF98(2, "src/conf.c", 487, "zlog_rule_new fail [%s]");
          if ( !*(_DWORD *)(a1 + 1048) )
            goto LABEL_42;
        }
        goto LABEL_37;
      default:
        sub_5DF98(2, "src/conf.c", 498, "not in any section");
        goto LABEL_37;
    }
LABEL_66:
    v4 = s;
    v5 = 0;
  }
  v23 = s;
  while ( v21 == 34 )
  {
    v22 ^= 1u;
LABEL_27:
    v24 = (unsigned __int8)*++v23;
    v21 = v24;
    if ( !v24 )
      goto LABEL_33;
  }
  if ( v21 != 35 || v22 )
    goto LABEL_27;
  *v23 = 0;
LABEL_33:
  v25 = strlen(s);
  if ( v25 <= 0x1000 )
  {
    if ( s[0] != 91 )
      goto LABEL_35;
    _isoc99_sscanf(s, asc_6BB30, v46);
    if ( !strcmp(v46, "global") )
    {
      if ( i )
        goto LABEL_115;
      goto LABEL_66;
    }
    if ( !strcmp(v46, "levels") )
    {
      if ( i > 1 )
        goto LABEL_115;
      i = 2;
    }
    else
    {
      if ( strcmp(v46, "formats") )
      {
        if ( strcmp(v46, "rules") )
        {
          sub_5DF98(2, "src/conf.c", 363, "wrong section name[%s]", v46);
          goto LABEL_37;
        }
        if ( i == 4 )
          goto LABEL_115;
        v30 = *(_DWORD *)(a1 + 9276);
        if ( v30 && v30 <= *(_DWORD *)(a1 + 9272) )
        {
          sub_5DF98(
            1,
            "src/conf.c",
            382,
            "fsync_period[%ld] >= reload_conf_period[%ld],set fsync_period to zero",
            arg,
            v37);
          *(_DWORD *)(a1 + 9272) = 0;
        }
        v31 = sub_58834((const char *)(a1 + 1060));
        *(_DWORD *)(a1 + 5160) = v31;
        if ( !v31 )
        {
          sub_5DF98(2, "src/conf.c", 391, "zlog_rotater_new fail");
          goto LABEL_37;
        }
        v32 = sub_576E4((const char *)(a1 + 5164), v40);
        *(_DWORD *)(a1 + 9264) = v32;
        if ( !v32 )
        {
          sub_5DF98(2, "src/conf.c", 398, "zlog_format_new fail");
          goto LABEL_37;
        }
LABEL_42:
        v4 = s;
        i = 4;
        v5 = 0;
        goto LABEL_4;
      }
      if ( i > 2 )
      {
LABEL_115:
        sub_5DF98(2, "src/conf.c", 368, "wrong sequence of section, must follow global->levels->formats->rules");
        goto LABEL_37;
      }
      i = 3;
    }
LABEL_45:
    v4 = s;
    v5 = 0;
    goto LABEL_4;
  }
LABEL_97:
  sub_5DF98(2, "src/conf.c", 346, "line_len[%ld] > MAXLEN_CFG_LINE[%ld], may cause overflow", v25, 4096);
LABEL_37:
  sub_5DF98(2, "src/conf.c", 314, "parse configure file[%s]line_no[%ld] fail", (const char *)a1, v3);
  c = -1;
  sub_5DF98(2, "src/conf.c", 315, "line[%s]", s);
LABEL_38:
  fclose(v2);
  return c;
}
// 56280: control flows out of bounds to 56284
// 565D8: variable 'arg' is possibly undefined
// 565D8: variable 'v37' is possibly undefined
// 1231C: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);
// 124E4: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 125D4: using guessed type int __fastcall _lxstat64(_DWORD, _DWORD, _DWORD);
// 56030: using guessed type char var_60A8[80];

//----- (00056B38) --------------------------------------------------------
char *__fastcall sub_56B38(int a1, int a2)
{
  int v4; // r5
  int v5; // r0
  char *result; // r0
  _DWORD *v7; // r3
  int v8; // r6
  int v9; // r0
  _DWORD *v10; // r3
  int v11; // r6
  int v12; // r0

  if ( !a1 )
    return (char *)sub_5DF98(2, "src/conf.c", 44, "a_conf is null or 0");
  sub_5DF98(a2, "src/conf.c", 45, "-conf[%p]-", (const void *)a1);
  sub_5DF98(a2, "src/conf.c", 46, "--global--");
  sub_5DF98(a2, "src/conf.c", 47, "---file[%s],mtime[%s]---", (const char *)a1, (const char *)(a1 + 1025));
  sub_5DF98(a2, "src/conf.c", 48, "---strict init[%d]---", *(_DWORD *)(a1 + 1048));
  sub_5DF98(a2, "src/conf.c", 49, "---buffer min[%ld]---", *(_DWORD *)(a1 + 1052));
  v4 = a1 + 0x2000;
  sub_5DF98(a2, "src/conf.c", 50, "---buffer max[%ld]---", *(_DWORD *)(a1 + 1056));
  if ( *(_DWORD *)(a1 + 9264) )
  {
    sub_5DF98(a2, "src/conf.c", 52, "---default_format---");
    sub_575FC(*(_DWORD *)(a1 + 9264), a2);
  }
  sub_5DF98(a2, "src/conf.c", 55, "---file perms[0%o]---", *(_DWORD *)(a1 + 9268));
  sub_5DF98(a2, "src/conf.c", 56, "---reload conf period[%ld]---", *(_DWORD *)(a1 + 9276));
  sub_5DF98(a2, "src/conf.c", 57, "---fsync period[%ld]---", *(_DWORD *)(a1 + 9272));
  sub_5DF98(a2, "src/conf.c", 59, "---rotate lock file[%s]---", (const char *)(a1 + 1060));
  v5 = *(_DWORD *)(a1 + 5160);
  if ( v5 )
    sub_58638(v5, a2);
  result = *(char **)(a1 + 9280);
  if ( result )
    result = (char *)sub_57A8C(result, a2);
  if ( *(_DWORD *)(a1 + 9284) )
  {
    result = (char *)sub_5DF98(a2, "src/conf.c", 65, "--format list[%p]--", *(const void **)(a1 + 9284));
    v7 = *(_DWORD **)(a1 + 9284);
    if ( (int)v7[1] > 0 )
    {
      v8 = 0;
      do
      {
        v9 = *(_DWORD *)(*v7 + 4 * v8++);
        result = (char *)sub_575FC(v9, a2);
        v7 = *(_DWORD **)(v4 + 1092);
      }
      while ( v7[1] > v8 );
    }
  }
  if ( *(_DWORD *)(v4 + 1096) )
  {
    result = (char *)sub_5DF98(a2, "src/conf.c", 72, "--rule_list[%p]--", *(const void **)(v4 + 1096));
    v10 = *(_DWORD **)(v4 + 1096);
    if ( (int)v10[1] > 0 )
    {
      v11 = 0;
      do
      {
        v12 = *(_DWORD *)(*v10 + 4 * v11++);
        result = (char *)sub_5A850(v12, a2);
        v10 = *(_DWORD **)(v4 + 1096);
      }
      while ( v10[1] > v11 );
    }
  }
  return result;
}

//----- (00056E0C) --------------------------------------------------------
int __fastcall sub_56E0C(_DWORD *a1)
{
  pthread_mutex_t *v2; // r0
  _DWORD *v3; // r0
  _DWORD *v4; // r0
  _DWORD *v5; // r0
  _DWORD *v6; // r0

  if ( !a1 )
    return sub_5DF98(2, "src/conf.c", 83, "a_conf is null or 0");
  v2 = (pthread_mutex_t *)a1[1290];
  if ( v2 )
    sub_58750(v2);
  v3 = (_DWORD *)a1[2320];
  if ( v3 )
    sub_57B24(v3);
  v4 = (_DWORD *)a1[2316];
  if ( v4 )
    sub_5766C(v4);
  v5 = (_DWORD *)a1[2321];
  if ( v5 )
    sub_5D580(v5);
  v6 = (_DWORD *)a1[2322];
  if ( v6 )
    sub_5D580(v6);
  free(a1);
  return sub_5DF98(0, "src/conf.c", 90, "zlog_conf_del[%p]");
}

//----- (00056EB8) --------------------------------------------------------
int __fastcall sub_56EB8(const char *a1)
{
  char *v2; // r0
  int v3; // r4
  int v4; // r8
  char *v5; // r0
  unsigned int v6; // r5
  const char *v7; // r7
  int v8; // r0
  _DWORD *v9; // r0
  _DWORD *v10; // r0
  char *v12; // r0
  pthread_mutex_t *v13; // r0
  unsigned __int8 *v14; // r6
  int *v15; // r0
  int *v16; // r0

  v2 = (char *)calloc(1u, 0x2450u);
  v3 = (int)v2;
  if ( !v2 )
  {
    v16 = _errno_location();
    sub_5DF98(2, "src/conf.c", 105, "calloc fail, errno[%d]", *v16);
    return v3;
  }
  if ( a1 && *a1 )
  {
    v6 = snprintf(v2, 0x401u, "%s", a1);
    if ( v6 <= 0x400 )
      goto LABEL_6;
    goto LABEL_22;
  }
  v4 = (int)getenv("ZLOG_CONF_PATH");
  if ( v4 )
  {
    v5 = getenv("ZLOG_CONF_PATH");
    v6 = snprintf((char *)v3, 0x401u, "%s", v5);
    if ( v6 <= 0x400 )
    {
LABEL_6:
      v7 = (const char *)(v3 + 1060);
      *(_DWORD *)(v3 + 1048) = 1;
      *(_DWORD *)(v3 + 1052) = 1024;
      *(_DWORD *)(v3 + 1056) = 0x200000;
      v4 = 1;
      strcpy((char *)(v3 + 1060), (const char *)v3);
      goto LABEL_7;
    }
LABEL_22:
    v15 = _errno_location();
    sub_5DF98(2, "src/conf.c", 120, "not enough space for path name, nwrite=[%d], errno[%d]", v6, *v15);
    goto LABEL_23;
  }
  memset((void *)v3, 0, 0x401u);
  *(_DWORD *)(v3 + 1048) = 1;
  v7 = (const char *)(v3 + 1060);
  *(_DWORD *)(v3 + 1056) = 0x200000;
  *(_DWORD *)(v3 + 1052) = 1024;
  strcpy((char *)(v3 + 1060), "/tmp/zlog.lock");
LABEL_7:
  strcpy((char *)(v3 + 5164), "default = \"%D %V [%p:%F:%L] %m%n\"");
  *(_DWORD *)(v3 + 9268) = 384;
  *(_DWORD *)(v3 + 9276) = 0;
  *(_DWORD *)(v3 + 9272) = 0;
  v8 = sub_57C30();
  *(_DWORD *)(v3 + 9280) = v8;
  if ( v8 )
  {
    v9 = sub_5D4C0((int)sub_5766C);
    *(_DWORD *)(v3 + 9284) = v9;
    if ( v9 )
    {
      v10 = sub_5D4C0((int)sub_5A97C);
      *(_DWORD *)(v3 + 9288) = v10;
      if ( v10 )
      {
        if ( v4 )
        {
          if ( !sub_56030(v3) )
          {
LABEL_12:
            sub_56B38(v3, 0);
            return v3;
          }
          sub_5DF98(2, "src/conf.c", 160, "zlog_conf_build_with_file fail");
        }
        else
        {
          v12 = sub_576E4((const char *)(v3 + 5164), (const char **)(v3 + 9292));
          *(_DWORD *)(v3 + 9264) = v12;
          if ( v12 )
          {
            v13 = sub_58834(v7);
            *(_DWORD *)(v3 + 5160) = v13;
            if ( v13 )
            {
              v14 = sub_5AA9C(
                      "*.*        >stdout",
                      *(_DWORD **)(v3 + 9280),
                      *(_DWORD *)(v3 + 9264),
                      *(__int64 **)(v3 + 9284),
                      *(_DWORD *)(v3 + 9268),
                      *(_DWORD *)(v3 + 9272),
                      (const char **)(v3 + 9292));
              if ( v14 )
              {
                if ( !sub_5D694(*(_DWORD *)(v3 + 9288), (int)v14) )
                  goto LABEL_12;
                sub_5A97C(v14);
                sub_5DF98(2, "src/conf.c", 209, "zc_arraylist_add fail");
              }
              else
              {
                sub_5DF98(2, "src/conf.c", 202, "zlog_rule_new fail");
              }
            }
            else
            {
              sub_5DF98(2, "src/conf.c", 189, "zlog_rotater_new fail");
            }
          }
          else
          {
            sub_5DF98(2, "src/conf.c", 183, "zlog_format_new fail");
          }
          sub_5DF98(2, "src/conf.c", 165, "zlog_conf_build_without_file fail");
        }
      }
      else
      {
        sub_5DF98(2, "src/conf.c", 154, "init rule_list fail");
      }
    }
    else
    {
      sub_5DF98(2, "src/conf.c", 148, "zc_arraylist_new fail");
    }
  }
  else
  {
    sub_5DF98(2, "src/conf.c", 142, "zlog_level_list_new fail");
  }
LABEL_23:
  sub_56E0C((_DWORD *)v3);
  return 0;
}

//----- (0005729C) --------------------------------------------------------
int __fastcall sub_5729C(const char **a1, int a2)
{
  if ( a1 )
    return sub_5DF98(
             a2,
             "src/event.c",
             40,
             "---event[%p][%s,%s][%s(%ld),%s(%ld),%ld,%d][%p,%s][%ld,%ld][%ld,%ld][%d]---",
             a1,
             *a1,
             (const char *)a1 + 8,
             a1[68],
             a1[69],
             a1[70],
             a1[71],
             a1[72],
             a1[73],
             a1[74],
             a1[76],
             a1[79],
             a1[80],
             a1[95],
             a1[106],
             a1[94]);
  else
    return sub_5DF98(2, "src/event.c", 30, "a_event is null or 0");
}

//----- (00057364) --------------------------------------------------------
void __fastcall sub_57364(_DWORD *a1)
{
  void *v2; // r0

  if ( a1 )
  {
    v2 = (void *)a1[93];
    if ( v2 )
      free(v2);
    sub_5DF98(0, "src/event.c", 50, "zlog_event_del[%p]", a1);
    free(a1);
  }
  else
  {
    sub_5DF98(2, "src/event.c", 48, "a_event is null or 0");
  }
}

//----- (000573D8) --------------------------------------------------------
void *__fastcall sub_573D8(size_t a1)
{
  void *v2; // r4
  void *v3; // r5
  pthread_t v4; // r0
  int v5; // r0
  int v6; // r2
  int v7; // r0
  int *v9; // r0
  _DWORD *v10; // r0
  int *v11; // r0
  int *v12; // r0
  void *v13; // r0

  v2 = calloc(1u, 0x21Cu);
  if ( v2 )
  {
    v3 = calloc(a1, 0x100Cu);
    *((_DWORD *)v2 + 93) = v3;
    if ( v3 )
    {
      *((_DWORD *)v2 + 94) = a1;
      if ( gethostname((char *)v2 + 8, 0x100u) )
      {
        v9 = _errno_location();
        sub_5DF98(2, "src/event.c", 78, "gethostname fail, errno[%d]", *v9);
        v10 = v2;
        v2 = 0;
        sub_57364(v10);
      }
      else
      {
        *((_DWORD *)v2 + 67) = strlen((const char *)v2 + 8);
        v4 = pthread_self();
        *((_DWORD *)v2 + 106) = v4;
        v5 = sprintf((char *)v2 + 428, "%lu", v4);
        v6 = *((_DWORD *)v2 + 106);
        *((_DWORD *)v2 + 115) = v5;
        *((_DWORD *)v2 + 124) = sprintf((char *)v2 + 464, "%x", v6);
        v7 = syscall(224);
        *((_DWORD *)v2 + 125) = v7;
        *((_DWORD *)v2 + 134) = sprintf((char *)v2 + 504, "%u", v7);
      }
    }
    else
    {
      v12 = _errno_location();
      sub_5DF98(2, "src/event.c", 67, "calloc fail, errno[%d]", *v12);
      v13 = v2;
      v2 = 0;
      free(v13);
    }
  }
  else
  {
    v11 = _errno_location();
    sub_5DF98(2, "src/event.c", 61, "calloc fail, errno[%d]", *v11);
  }
  return v2;
}

//----- (00057540) --------------------------------------------------------
_DWORD *__fastcall sub_57540(
        _DWORD *result,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11)
{
  *result = a2;
  result[1] = a3;
  result[68] = a4;
  result[69] = a5;
  result[70] = a6;
  result[71] = a7;
  result[72] = a8;
  result[73] = a9;
  result[76] = a10;
  result[77] = a11;
  result[78] = 0;
  result[95] = 0;
  result[79] = 0;
  return result;
}

//----- (0005759C) --------------------------------------------------------
_DWORD *__fastcall sub_5759C(
        _DWORD *result,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11)
{
  result[1] = a3;
  result[68] = a4;
  result[69] = a5;
  *result = a2;
  result[70] = a6;
  result[71] = a7;
  result[72] = a8;
  result[73] = a9;
  result[78] = 1;
  result[74] = a10;
  result[75] = a11;
  result[95] = 0;
  result[79] = 0;
  return result;
}

//----- (000575FC) --------------------------------------------------------
int __fastcall sub_575FC(int a1, int a2)
{
  if ( a1 )
    return sub_5DF98(
             a2,
             "src/format.c",
             29,
             "---format[%p][%s = %s(%p)]---",
             (const void *)a1,
             (const char *)a1,
             (const char *)(a1 + 4097),
             *(const void **)(a1 + 8196));
  else
    return sub_5DF98(2, "src/format.c", 24, "a_format is null or 0");
}

//----- (0005766C) --------------------------------------------------------
void __fastcall sub_5766C(_DWORD *a1)
{
  _DWORD *v2; // r0

  if ( a1 )
  {
    v2 = (_DWORD *)a1[2049];
    if ( v2 )
      sub_5D580(v2);
    sub_5DF98(0, "src/format.c", 49, "zlog_format_del[%p]", a1);
    free(a1);
  }
  else
  {
    sub_5DF98(2, "src/format.c", 45, "a_format is null or 0");
  }
}

//----- (000576E4) --------------------------------------------------------
char *__fastcall sub_576E4(const char *a1, const char **a2)
{
  char *v4; // r0
  char *v5; // r5
  int v6; // r8
  int v7; // r4
  const unsigned __int16 **v8; // r0
  char *v9; // r2
  int v10; // t1
  const char *v11; // r8
  char *v12; // r0
  size_t v13; // r6
  const char *v14; // r4
  _DWORD *v15; // r0
  const char **v16; // r4
  int *v18; // r0
  int v19; // [sp+8h] [bp-28h] BYREF
  char *v20; // [sp+Ch] [bp-24h] BYREF

  v19 = 0;
  if ( !a1 )
  {
    sub_5DF98(2, "src/format.c", 65, "line is null or 0");
    return 0;
  }
  v4 = (char *)calloc(1u, 0x2008u);
  v5 = v4;
  if ( !v4 )
  {
    v18 = _errno_location();
    sub_5DF98(2, "src/format.c", 69, "calloc fail, errno[%d]", *v18);
    return 0;
  }
  memset(v4, 0, 0x1001u);
  v19 = 0;
  if ( _isoc99_sscanf(a1, " %[^= \t] = %n", v5, &v19) != 1 )
  {
    sub_5DF98(2, "src/format.c", 81, "format[%s], syntax wrong", a1);
LABEL_20:
    sub_5766C(v5);
    return 0;
  }
  v6 = v19;
  if ( a1[v19] != 34 )
  {
    sub_5DF98(2, "src/format.c", 86, "the 1st char of pattern is not \", line+nread[%s]", &a1[v19]);
    goto LABEL_20;
  }
  v7 = (unsigned __int8)*v5;
  if ( *v5 )
  {
    v8 = _ctype_b_loc();
    v9 = v5;
    while ( ((v7 != 95) & (((*v8)[v7] ^ 8u) >> 3)) == 0 )
    {
      v10 = (unsigned __int8)*++v9;
      v7 = v10;
      if ( !v10 )
        goto LABEL_9;
    }
    sub_5DF98(2, "src/format.c", 92, "a_format->name[%s] character is not in [a-Z][0-9][_]", v5);
    goto LABEL_20;
  }
LABEL_9:
  v11 = &a1[v6 + 1];
  v12 = strrchr(v11, 34);
  if ( !v12 )
  {
    sub_5DF98(2, "src/format.c", 100, "there is no \" at end of pattern, line[%s]", a1);
    goto LABEL_20;
  }
  v13 = v12 - v11;
  if ( (unsigned int)(v12 - v11) > 0x1000 )
  {
    sub_5DF98(2, "src/format.c", 105, "pattern is too long");
    goto LABEL_20;
  }
  v14 = v5 + 4097;
  memset(v5 + 4097, 0, 0x1001u);
  memcpy(v5 + 4097, v11, v13);
  if ( sub_5E310(v5 + 4097, 4097) )
  {
    sub_5DF98(2, "src/format.c", 112, "zc_str_replace_env fail");
    goto LABEL_20;
  }
  v15 = sub_5D4C0((int)sub_5C6F4);
  *((_DWORD *)v5 + 2049) = v15;
  if ( !v15 )
  {
    sub_5DF98(2, "src/format.c", 119, "zc_arraylist_new fail");
    goto LABEL_20;
  }
  if ( v5[4097] )
  {
    while ( 1 )
    {
      v16 = sub_5C758(v14, &v20, a2);
      if ( !v16 )
      {
        sub_5DF98(2, "src/format.c", 126, "zlog_spec_new fail");
        goto LABEL_20;
      }
      if ( sub_5D694(*((_DWORD *)v5 + 2049), (int)v16) )
        break;
      v14 = v20;
      if ( !*v20 )
        goto LABEL_22;
    }
    sub_5C6F4(v16);
    sub_5DF98(2, "src/format.c", 132, "zc_arraylist_add fail");
    goto LABEL_20;
  }
LABEL_22:
  sub_575FC((int)v5, 0);
  return v5;
}
// 1231C: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);

//----- (00057A1C) --------------------------------------------------------
int __fastcall sub_57A1C(int a1, int a2)
{
  int v2; // r4
  int v3; // r6
  _DWORD *v4; // r3
  int v5; // r12
  int v6; // r0

  v3 = a1 + 0x2000;
  v4 = *(_DWORD **)(a1 + 8196);
  v5 = v4[1];
  if ( v5 > 0 )
    v2 = 0;
  *(_DWORD *)(*(_DWORD *)(a2 + 28) + 4) = **(_DWORD **)(a2 + 28);
  if ( v5 <= 0 )
    return 0;
  while ( 1 )
  {
    v6 = *(_DWORD *)(*v4 + 4 * v2++);
    if ( (*(int (**)(void))(v6 + 9256))() )
      break;
    v4 = *(_DWORD **)(v3 + 4);
    if ( v4[1] <= v2 )
      return 0;
  }
  return -1;
}
// 57A50: variable 'v2' is possibly undefined

//----- (00057A8C) --------------------------------------------------------
const char *__fastcall sub_57A8C(_DWORD *a1, int a2)
{
  const char *result; // r0
  int v5; // r2
  int i; // r4

  if ( !a1 )
    return (const char *)sub_5DF98(2, "src/level_list.c", 25, "levels is null or 0");
  result = (const char *)sub_5DF98(a2, "src/level_list.c", 26, "--level_list[%p]--", a1);
  v5 = a1[1];
  if ( v5 > 0 )
  {
    for ( i = 0; i < v5; ++i )
    {
      result = *(const char **)(*a1 + 4 * i);
      if ( result )
      {
        result = (const char *)sub_5F3F8(result, a2);
        v5 = a1[1];
      }
    }
  }
  return result;
}

//----- (00057B24) --------------------------------------------------------
int __fastcall sub_57B24(_DWORD *a1)
{
  if ( !a1 )
    return sub_5DF98(2, "src/level_list.c", 37, "levels is null or 0");
  sub_5D580(a1);
  return sub_5DF98(0, "src/level_list.c", 39, "zc_level_list_del[%p]", a1);
}

//----- (00057B80) --------------------------------------------------------
int __fastcall sub_57B80(int a1, const char *a2)
{
  int *v4; // r4
  int result; // r0

  v4 = sub_5F4D8(a2);
  if ( v4 )
  {
    result = sub_5D5F0(a1, *v4, (int)v4);
    if ( result )
    {
      sub_5DF98(2, "src/level_list.c", 90, "zc_arraylist_set fail");
      sub_5DF98(2, "src/level_list.c", 96, "line[%s]", a2);
      sub_5F474(v4);
      return -1;
    }
  }
  else
  {
    sub_5DF98(2, "src/level_list.c", 85, "zlog_level_new fail");
    return -1;
  }
  return result;
}

//----- (00057C30) --------------------------------------------------------
int sub_57C30()
{
  _DWORD *v0; // r0
  int v1; // r4
  _DWORD *v2; // r0

  v0 = sub_5D4C0((int)sub_5F474);
  v1 = (int)v0;
  if ( v0 )
  {
    if ( sub_57B80((int)v0, "* = 0, LOG_INFO")
      || sub_57B80(v1, "DEBUG = 20, LOG_DEBUG")
      || sub_57B80(v1, "INFO = 40, LOG_INFO")
      || sub_57B80(v1, "NOTICE = 60, LOG_NOTICE")
      || sub_57B80(v1, "WARN = 80, LOG_WARNING")
      || sub_57B80(v1, "ERROR = 100, LOG_ERR")
      || sub_57B80(v1, "FATAL = 120, LOG_ALERT")
      || sub_57B80(v1, "UNKNOWN = 254, LOG_ERR")
      || sub_57B80(v1, "! = 255, LOG_INFO") )
    {
      sub_5DF98(2, "src/level_list.c", 67, "zlog_level_set_default fail");
      v2 = (_DWORD *)v1;
      v1 = 0;
      sub_5D580(v2);
    }
  }
  else
  {
    sub_5DF98(2, "src/level_list.c", 62, "zc_arraylist_new fail");
  }
  return v1;
}

//----- (00057D70) --------------------------------------------------------
int __fastcall sub_57D70(int *a1, int arg)
{
  int v4; // r3
  bool v5; // cc
  int v6; // r3

  if ( a1[1] > arg && *(_DWORD *)(*a1 + 4 * arg) )
    return *(_DWORD *)(*a1 + 4 * arg);
  sub_5DF98(
    2,
    "src/level_list.c",
    119,
    "l[%d] not in (0,254), or has no level defined,see configure file define, set to UNKOWN",
    arg);
  v4 = a1[1];
  v5 = v4 <= 254;
  if ( v4 <= 254 )
    v6 = 0;
  else
    v6 = *a1;
  if ( !v5 )
    return *(_DWORD *)(v6 + 1016);
  return v6;
}

//----- (00057DE4) --------------------------------------------------------
int __fastcall sub_57DE4(_DWORD *a1, const char *a2)
{
  int v3; // r7
  int v4; // r5
  int v5; // r4
  int v6; // t1
  const char *v7; // r1

  if ( a2 && *a2 )
  {
    v3 = a1[1];
    if ( v3 <= 0 )
    {
LABEL_8:
      v5 = -1;
      sub_5DF98(2, "src/level_list.c", 142, "str[%s] can't found in level list", a2);
    }
    else
    {
      v4 = *a1 - 4;
      v5 = 0;
      while ( 1 )
      {
        v6 = *(_DWORD *)(v4 + 4);
        v4 += 4;
        v7 = (const char *)(v6 + 4);
        if ( v6 )
        {
          if ( !strcasecmp(a2, v7) )
            break;
        }
        if ( ++v5 == v3 )
          goto LABEL_8;
      }
    }
  }
  else
  {
    v5 = -1;
    sub_5DF98(2, "src/level_list.c", 132, "str is [%s], can't find level", a2);
  }
  return v5;
}

//----- (00057E98) --------------------------------------------------------
void __fastcall sub_57E98(void *arg)
{
  sub_5DF98(0, "src/mdc.c", 44, "zlog_mdc_kv_del[%p]", arg);
  free(arg);
}

//----- (00057ED4) --------------------------------------------------------
int __fastcall sub_57ED4(int *a1, int a2)
{
  int result; // r0
  int i; // r4

  if ( !a1 )
    return sub_5DF98(2, "src/mdc.c", 21, "a_mdc is null or 0");
  sub_5DF98(a2, "src/mdc.c", 22, "---mdc[%p]---", a1);
  result = sub_5DE60(*a1);
  for ( i = result; result; i = result )
  {
    sub_5DF98(
      a2,
      "src/mdc.c",
      28,
      "----mdc_kv[%p][%s]-[%s]----",
      *(const void **)(i + 8),
      *(const char **)(i + 8),
      (const char *)(*(_DWORD *)(i + 8) + 1025));
    result = sub_5DEA8(*a1, (unsigned int *)i);
  }
  return result;
}

//----- (00057F94) --------------------------------------------------------
void __fastcall sub_57F94(_DWORD **a1)
{
  _DWORD *v2; // r0

  if ( a1 )
  {
    v2 = *a1;
    if ( *a1 )
      sub_5D890(v2);
    sub_5DF98(0, "src/mdc.c", 37, "zlog_mdc_del[%p]", a1);
    free(a1);
  }
  else
  {
    sub_5DF98(2, "src/mdc.c", 35, "a_mdc is null or 0");
  }
}

//----- (00058008) --------------------------------------------------------
_DWORD *sub_58008()
{
  _DWORD *v0; // r4
  _DWORD *v1; // r5
  int *v3; // r0
  _DWORD **v4; // r0

  v0 = calloc(1u, 4u);
  if ( v0 )
  {
    v1 = sub_5D7B8(0x14u, (int)sub_5DF18, (int)sub_5DF44, 0, (int)sub_57E98);
    *v0 = v1;
    if ( !v1 )
    {
      sub_5DF98(2, "src/mdc.c", 78, "zc_hashtable_new fail");
      v4 = (_DWORD **)v0;
      v0 = 0;
      sub_57F94(v4);
    }
  }
  else
  {
    v3 = _errno_location();
    sub_5DF98(2, "src/mdc.c", 69, "calloc fail, errno[%d]", *v3);
  }
  return v0;
}

//----- (000580C0) --------------------------------------------------------
int __fastcall sub_580C0(int *a1, const char *a2, const char *a3)
{
  char *v6; // r0
  int v7; // r4
  int result; // r0
  int *v9; // r0

  v6 = (char *)calloc(1u, 0x808u);
  v7 = (int)v6;
  if ( v6 )
  {
    snprintf(v6, 0x401u, "%s", a2);
    *(_DWORD *)(v7 + 2052) = snprintf((char *)(v7 + 1025), 0x401u, "%s", a3);
    result = sub_5DAC0(*a1, v7, v7);
    if ( result )
    {
      sub_5DF98(2, "src/mdc.c", 101, "zc_hashtable_put fail");
      sub_57E98((void *)v7);
      return -1;
    }
  }
  else
  {
    v9 = _errno_location();
    sub_5DF98(2, "src/mdc.c", 54, "calloc fail, errno[%d]", *v9);
    sub_5DF98(2, "src/mdc.c", 96, "zlog_mdc_kv_new failed");
    return -1;
  }
  return result;
}

//----- (000581B0) --------------------------------------------------------
_DWORD *__fastcall sub_581B0(_DWORD **a1)
{
  return sub_5D950(*a1);
}

//----- (000581B8) --------------------------------------------------------
int __fastcall sub_581B8(int *a1, int a2)
{
  int v2; // r0

  v2 = sub_5DA58(*a1, a2);
  if ( v2 )
    return v2 + 1025;
  sub_5DF98(2, "src/mdc.c", 121, "zc_hashtable_get fail");
  return 0;
}

//----- (000581FC) --------------------------------------------------------
int __fastcall sub_581FC(int *a1, int a2)
{
  int v2; // r4

  v2 = sub_5DA58(*a1, a2);
  if ( !v2 )
    sub_5DF98(2, "src/mdc.c", 134, "zc_hashtable_get fail");
  return v2;
}

//----- (00058238) --------------------------------------------------------
void __fastcall sub_58238(_DWORD **a1, const void *a2)
{
  sub_5DD28(*a1, a2);
}

//----- (00058240) --------------------------------------------------------
int __fastcall sub_58240(const void **a1, int a2)
{
  if ( a1 )
    return sub_5DF98(a2, "src/record.c", 15, "--record:[%p][%s:%p]--", a1, (const char *)a1, a1[257]);
  else
    return sub_5DF98(2, "src/record.c", 14, "a_record is null or 0");
}

//----- (000582A0) --------------------------------------------------------
void __fastcall sub_582A0(void *a1)
{
  if ( a1 )
  {
    sub_5DF98(0, "src/record.c", 22, "zlog_record_del[%p]", a1);
    free(a1);
  }
  else
  {
    sub_5DF98(2, "src/record.c", 21, "a_record is null or 0");
  }
}

//----- (00058304) --------------------------------------------------------
_DWORD *__fastcall sub_58304(const char *a1, int a2)
{
  _DWORD *v4; // r4
  size_t v5; // r0
  void *v7; // r0
  int *v8; // r0

  if ( a1 )
  {
    if ( a2 )
    {
      v4 = calloc(1u, 0x408u);
      if ( v4 )
      {
        v5 = strlen(a1);
        if ( v5 > 0x400 )
        {
          sub_5DF98(2, "src/record.c", 41, "name[%s] is too long", a1);
          v7 = v4;
          v4 = 0;
          sub_582A0(v7);
        }
        else
        {
          memcpy(v4, a1, v5 + 1);
          v4[257] = a2;
          sub_58240((const void **)v4, 0);
        }
      }
      else
      {
        v8 = _errno_location();
        sub_5DF98(2, "src/record.c", 36, "calloc fail, errno[%d]", *v8);
      }
    }
    else
    {
      v4 = 0;
      sub_5DF98(2, "src/record.c", 32, "output is null or 0");
    }
  }
  else
  {
    v4 = 0;
    sub_5DF98(2, "src/record.c", 31, "name is null or 0");
  }
  return v4;
}

//----- (00058414) --------------------------------------------------------
int __fastcall sub_58414(const void *a1, int a2)
{
  int result; // r0
  int i; // r4

  if ( !a1 )
    return sub_5DF98(2, "src/record_table.c", 21, "records is null or 0");
  sub_5DF98(a2, "src/record_table.c", 22, "-record_table[%p]-", a1);
  result = sub_5DE60((int)a1);
  for ( i = result; result; i = result )
  {
    sub_58240(*(const void ***)(i + 8), a2);
    result = sub_5DEA8((int)a1, (unsigned int *)i);
  }
  return result;
}

//----- (000584A4) --------------------------------------------------------
int __fastcall sub_584A4(_DWORD *a1)
{
  if ( !a1 )
    return sub_5DF98(2, "src/record_table.c", 34, "records is null or 0");
  sub_5D890(a1);
  return sub_5DF98(0, "src/record_table.c", 36, "zlog_record_table_del[%p]", a1);
}

//----- (00058500) --------------------------------------------------------
_DWORD *sub_58500()
{
  _DWORD *v0; // r0
  _DWORD *v1; // r4

  v0 = sub_5D7B8(0x14u, (int)sub_5DF18, (int)sub_5DF44, 0, (int)sub_582A0);
  v1 = v0;
  if ( v0 )
    sub_58414(v0, 0);
  else
    sub_5DF98(2, "src/record_table.c", 49, "zc_hashtable_new fail");
  return v1;
}

//----- (0005856C) --------------------------------------------------------
bool __fastcall sub_5856C(_DWORD *a1, _DWORD *a2)
{
  return *a1 > *a2;
}

//----- (00058584) --------------------------------------------------------
void __fastcall sub_58584(char *arg)
{
  sub_5DF98(0, "src/rotater.c", 126, "del onefile[%p]", arg);
  sub_5DF98(0, "src/rotater.c", 127, "a_file->path[%s]", arg + 4);
  free(arg);
}

//----- (000585E4) --------------------------------------------------------
void __fastcall sub_585E4(_DWORD *a1)
{
  _DWORD *v2; // r0
  _DWORD *v3; // r0

  a1[8] = 0;
  v2 = a1 + 10;
  *(v2 - 1) = 0;
  a1[271] = 0;
  a1[270] = 0;
  a1[269] = 0;
  a1[267] = 0;
  a1[268] = 0;
  memset(v2, 0, 0x401u);
  v3 = (_DWORD *)a1[272];
  if ( v3 )
    sub_5D580(v3);
  a1[272] = 0;
}

//----- (00058638) --------------------------------------------------------
int __fastcall sub_58638(int a1, int a2)
{
  int result; // r0
  _DWORD *v5; // r3
  int v6; // r5
  int v7; // r12

  if ( !a1 )
    return sub_5DF98(2, "src/rotater.c", 34, "a_rotater is null or 0");
  result = sub_5DF98(
             a2,
             "src/rotater.c",
             50,
             "--rotater[%p][%p,%s,%d][%s,%s,%s,%ld,%ld,%d,%d,%d]--",
             (const void *)a1,
             (const void *)a1,
             *(const char **)(a1 + 24),
             *(_DWORD *)(a1 + 28),
             *(const char **)(a1 + 32),
             *(const char **)(a1 + 36),
             (const char *)(a1 + 40),
             *(_DWORD *)(a1 + 1068),
             *(_DWORD *)(a1 + 1072),
             *(_DWORD *)(a1 + 1076),
             *(_DWORD *)(a1 + 1080),
             *(_DWORD *)(a1 + 1084));
  v5 = *(_DWORD **)(a1 + 1088);
  if ( v5 && (int)v5[1] > 0 )
  {
    v6 = 0;
    do
    {
      v7 = *(_DWORD *)(*v5 + 4 * v6++);
      result = sub_5DF98(a2, "src/rotater.c", 55, "[%s,%d]->", (const char *)(v7 + 4), *(_DWORD *)v7);
      v5 = *(_DWORD **)(a1 + 1088);
    }
    while ( v5[1] > v6 );
  }
  return result;
}

//----- (00058750) --------------------------------------------------------
void __fastcall sub_58750(pthread_mutex_t *a1)
{
  int count; // r0
  int *v3; // r0
  int *v4; // r0

  if ( a1 )
  {
    count = a1[1].__count;
    if ( count && close(count) )
    {
      v3 = _errno_location();
      sub_5DF98(2, "src/rotater.c", 68, "close fail, errno[%d]", *v3);
    }
    if ( pthread_mutex_destroy(a1) )
    {
      v4 = _errno_location();
      sub_5DF98(2, "src/rotater.c", 73, "pthread_mutex_destroy fail, errno[%d]", *v4);
    }
    sub_5DF98(0, "src/rotater.c", 76, "zlog_rotater_del[%p]", a1);
    free(a1);
  }
  else
  {
    sub_5DF98(2, "src/rotater.c", 64, "a_rotater is null or 0");
  }
}

//----- (00058834) --------------------------------------------------------
pthread_mutex_t *__fastcall sub_58834(const char *a1)
{
  pthread_mutex_t *v2; // r0
  pthread_mutex_t *v3; // r4
  int v4; // r0
  int *v6; // r0
  pthread_mutex_t *v7; // r0
  int *v8; // r0
  int *v9; // r0
  pthread_mutex_t *v10; // r0

  if ( a1 )
  {
    v2 = (pthread_mutex_t *)calloc(1u, 0x444u);
    v3 = v2;
    if ( v2 )
    {
      if ( pthread_mutex_init(v2, 0) )
      {
        v6 = _errno_location();
        sub_5DF98(2, "src/rotater.c", 95, "pthread_mutex_init fail, errno[%d]", *v6);
        v7 = v3;
        v3 = 0;
        free(v7);
      }
      else
      {
        v4 = open64(a1);
        if ( v4 < 0 )
        {
          v9 = _errno_location();
          sub_5DF98(2, "src/rotater.c", 108, "open file[%s] fail, errno[%d]", a1, *v9);
          v10 = v3;
          v3 = 0;
          sub_58750(v10);
        }
        else
        {
          v3[1].__count = v4;
          v3[1].__lock = (int)a1;
        }
      }
    }
    else
    {
      v8 = _errno_location();
      sub_5DF98(2, "src/rotater.c", 90, "calloc fail, errno[%d]", *v8);
    }
  }
  else
  {
    v3 = 0;
    sub_5DF98(2, "src/rotater.c", 86, "lock_file is null or 0");
  }
  return v3;
}
// 12198: using guessed type int __fastcall open64(_DWORD);

//----- (00058958) --------------------------------------------------------
int __fastcall sub_58958(int a1, const char *a2, unsigned int a3, const char *a4, int a5, int a6)
{
  int v10; // r0
  int *v11; // r0
  int *v12; // r6
  int v14; // r6
  int v15; // r0
  int *v16; // r0
  int *v17; // r7
  char *v18; // r0
  char *v19; // r10
  int v20; // r7
  int v21; // r3
  _BYTE *v22; // r1
  int v23; // r5
  int v24; // r0
  int v25; // r7
  _DWORD *v26; // r0
  int v27; // r0
  int v28; // r5
  int v29; // r7
  int v30; // r10
  char *v31; // r0
  char *v32; // r6
  unsigned int v33; // r5
  int v34; // r0
  int v35; // r3
  bool v36; // cf
  const char *v37; // r5
  const char *v38; // t1
  int v39; // r3
  int *v40; // r0
  unsigned int v41; // r7
  const char *v42; // r7
  _DWORD *v43; // r3
  int v44; // r5
  int v45; // r3
  int v46; // r7
  unsigned int v47; // r3
  _DWORD *v48; // r3
  int v49; // r12
  const char *v50; // r8
  int *v51; // r0
  int *v52; // r0
  _DWORD *v53; // r1
  int v54; // r3
  int i; // r5
  int v56; // r2
  int v57; // r3
  const char *v58; // r7
  int *v59; // r2
  int v60; // r3
  int v61; // r5
  unsigned int v62; // r5
  int *v63; // r0
  unsigned int v64; // r5
  int *v65; // r0
  unsigned int v66; // r11
  int *v67; // r0
  int *v68; // r0
  int *v69; // r0
  int *v70; // r0
  int *v71; // r0
  int *v72; // r0
  int *v73; // r0
  int *v74; // r0
  const char *v75; // [sp+10h] [bp-4B0h]
  int v76; // [sp+24h] [bp-49Ch] BYREF
  char v77[48]; // [sp+28h] [bp-498h] BYREF
  __int64 v78; // [sp+58h] [bp-468h]
  int s[268]; // [sp+90h] [bp-430h] BYREF

  if ( !a2 )
  {
    sub_5DF98(2, "src/rotater.c", 536, "base_path is null or 0");
    return -1;
  }
  memset(&s[2], 0, 16);
  s[0] = 1;
  v10 = pthread_mutex_trylock((pthread_mutex_t *)a1);
  if ( v10 == 16 )
  {
    sub_5DF98(1, "src/rotater.c", 481, "pthread_mutex_trylock fail, as lock_mutex is locked by other threads");
    goto LABEL_7;
  }
  if ( v10 )
  {
    sub_5DF98(2, "src/rotater.c", 484, "pthread_mutex_trylock fail, rc[%d]", v10);
    goto LABEL_7;
  }
  if ( fcntl(*(_DWORD *)(a1 + 28), 13, s) )
  {
    v11 = _errno_location();
    v12 = v11;
    if ( ((*v11 - 11) & 0xFFFFFFFD) != 0 )
    {
      sub_5DF98(2, "src/rotater.c", 495, "lock fd[%d] fail, errno[%d]", *(_DWORD *)(a1 + 28), *v11);
      if ( !pthread_mutex_unlock((pthread_mutex_t *)a1) )
      {
LABEL_7:
        sub_5DF98(1, "src/rotater.c", 539, "zlog_rotater_trylock fail, maybe lock by other process or threads");
        return 0;
      }
    }
    else
    {
      sub_5DF98(1, "src/rotater.c", 493, "fcntl lock fail, as file is lock by other process");
      if ( !pthread_mutex_unlock((pthread_mutex_t *)a1) )
        goto LABEL_7;
    }
    sub_5DF98(2, "src/rotater.c", 498, "pthread_mutex_unlock fail, errno[%d]", *v12);
    goto LABEL_7;
  }
  v14 = _xstat64(3, a2, v77);
  if ( v14 )
  {
    v16 = _errno_location();
    v14 = -1;
    sub_5DF98(2, "src/rotater.c", 545, "stat [%s] fail, errno[%d]", a2, *v16);
    goto LABEL_10;
  }
  if ( a5 >= v78 + a3 )
    goto LABEL_10;
  *(_DWORD *)(a1 + 32) = a2;
  *(_DWORD *)(a1 + 36) = a4;
  *(_DWORD *)(a1 + 1084) = a6;
  if ( *a4 )
  {
    v18 = strchr(a4, 35);
    v19 = v18;
    if ( !v18 )
    {
      sub_5DF98(2, "src/rotater.c", 374, "no # in archive_path[%s]", a4);
      goto LABEL_102;
    }
    s[0] = 0;
    _isoc99_sscanf(v18, "#%d%n", a1 + 1076, s);
    v20 = s[0];
    if ( !s[0] )
    {
      v20 = 1;
      s[0] = 1;
    }
    v21 = (unsigned __int8)v19[v20];
    if ( v21 == 114 )
    {
      *(_DWORD *)(a1 + 1080) = 1;
    }
    else
    {
      if ( v21 != 115 )
      {
        sub_5DF98(2, "src/rotater.c", 386, "#r or #s not found");
        goto LABEL_102;
      }
      *(_DWORD *)(a1 + 1080) = 2;
    }
    v22 = *(_BYTE **)(a1 + 36);
    v23 = v19 - v22;
    if ( (unsigned int)(v19 - v22) > 0x400 )
    {
      sub_5DF98(2, "src/rotater.c", 393, "sizeof glob_path not enough,len[%ld]", v23);
    }
    else
    {
      v75 = (const char *)(a1 + 40);
      memcpy((void *)(a1 + 40), v22, v19 - v22);
      v24 = snprintf((char *)(a1 + 40 + v23), 1025 - v23, "*%s", &v19[v20 + 1]);
      v25 = v24;
      if ( v24 >= 0 && 1025 - v23 >= (unsigned int)v24 )
      {
        *(_DWORD *)(a1 + 1068) = v23;
        *(_DWORD *)(a1 + 1072) = v23 + 1;
        goto LABEL_31;
      }
      v69 = _errno_location();
      sub_5DF98(2, "src/rotater.c", 401, "nwirte[%d], overflow or errno[%d]", v25, *v69);
    }
LABEL_102:
    sub_5DF98(2, "src/rotater.c", 437, "zlog_rotater_parse_archive_path fail");
    goto LABEL_53;
  }
  v75 = (const char *)(a1 + 40);
  v41 = snprintf((char *)(a1 + 40), 0x401u, "%s.*", a2);
  if ( v41 > 0x401 )
  {
    v72 = _errno_location();
    sub_5DF98(2, "src/rotater.c", 360, "nwirte[%d], overflow or errno[%d]", v41, *v72);
    goto LABEL_102;
  }
  v42 = *(const char **)(a1 + 32);
  *(_DWORD *)(a1 + 1080) = 1;
  *(_DWORD *)(a1 + 1076) = 0;
  *(_DWORD *)(a1 + 1068) = strlen(v42) + 1;
  *(_DWORD *)(a1 + 1072) = strlen(v42) + 2;
LABEL_31:
  v26 = sub_5D4C0((int)sub_58584);
  *(_DWORD *)(a1 + 1088) = v26;
  if ( !v26 )
  {
    sub_5DF98(2, "src/rotater.c", 191, "zc_arraylist_new fail");
    goto LABEL_52;
  }
  v27 = glob64(v75, 7, 0, s);
  v28 = v27;
  if ( v27 != 3 )
  {
    if ( !v27 )
    {
      v29 = s[0] - 1;
      if ( s[0] )
      {
        v30 = s[1] - 4;
        while ( 1 )
        {
          v38 = *(const char **)(v30 + 4);
          v30 += 4;
          v37 = v38;
          if ( !strcmp(*(const char **)(a1 + 32), v38) || v37[strlen(v37) - 1] == 47 )
            goto LABEL_45;
          v31 = (char *)calloc(1u, 0x408u);
          v32 = v31;
          if ( !v31 )
            break;
          v33 = snprintf(v31 + 4, 0x401u, "%s", v37);
          if ( v33 > 0x400 )
          {
            v40 = _errno_location();
            sub_5DF98(2, "src/rotater.c", 155, "snprintf fail or overflow, nwrite=[%d], errno[%d]", v33, *v40);
            goto LABEL_50;
          }
          v34 = *(_DWORD *)(a1 + 1068);
          v76 = 0;
          _isoc99_sscanf(&v32[v34 + 4], "%d%n", v32, &v76);
          v35 = *(_DWORD *)(a1 + 1076);
          if ( v35 && v35 > v76 )
          {
            sub_5DF98(1, "src/rotater.c", 164, "aa.1.log is not expect, need aa.01.log");
LABEL_50:
            free(v32);
LABEL_45:
            sub_5DF98(1, "src/rotater.c", 211, "not the expect pattern file");
            goto LABEL_42;
          }
          if ( sub_5D6A0(*(_DWORD *)(a1 + 1088), (int (__fastcall *)(_DWORD, int))sub_5856C, (int)v32) )
          {
            sub_5DF98(2, "src/rotater.c", 219, "zc_arraylist_sortadd fail");
            globfree64(s);
            goto LABEL_52;
          }
LABEL_42:
          v36 = v29-- != 0;
          if ( !v36 )
          {
            v14 = 0;
            goto LABEL_46;
          }
        }
        v52 = _errno_location();
        sub_5DF98(2, "src/rotater.c", 149, "calloc fail, errno[%d]", *v52);
        goto LABEL_45;
      }
      goto LABEL_46;
    }
    v71 = _errno_location();
    sub_5DF98(2, "src/rotater.c", 200, "glob err, rc=[%d], errno[%d]", v28, *v71);
LABEL_52:
    sub_5DF98(2, "src/rotater.c", 443, "zlog_rotater_add_archive_files fail");
    goto LABEL_53;
  }
LABEL_46:
  globfree64(s);
  v39 = *(_DWORD *)(a1 + 1080);
  if ( v39 != 1 )
  {
    if ( v39 != 2 )
    {
LABEL_48:
      sub_585E4((_DWORD *)a1);
      goto LABEL_10;
    }
    v53 = *(_DWORD **)(a1 + 1088);
    v54 = v53[1];
    if ( v54 <= 0 )
    {
LABEL_98:
      v61 = 0;
    }
    else
    {
      for ( i = 0; i < v54; ++i )
      {
        v56 = *(_DWORD *)(a1 + 1084);
        v57 = v54 - v56;
        if ( v56 > 0 && v57 > i )
        {
          v58 = (const char *)(*(_DWORD *)(*v53 + 4 * i) + 4);
          if ( unlink(v58) )
          {
            v70 = _errno_location();
            sub_5DF98(2, "src/rotater.c", 246, "unlink[%s] fail, errno[%d]", v58, *v70);
            goto LABEL_88;
          }
          v53 = *(_DWORD **)(a1 + 1088);
        }
        v54 = v53[1];
      }
      if ( v54 <= 0 )
        goto LABEL_98;
      v59 = *(int **)(*v53 + 4 * (v54 + 0x3FFFFFFF));
      if ( !v59 )
      {
        sub_5DF98(2, "src/rotater.c", 256, "zc_arraylist_get fail");
LABEL_88:
        sub_5DF98(2, "src/rotater.c", 456, "zlog_rotater_seq_files fail");
        goto LABEL_53;
      }
      v60 = v54 - 1;
      if ( v60 < *v59 )
        v60 = *v59;
      v61 = v60 + 1;
    }
    memset(s, 0, 0x401u);
    v62 = snprintf(
            (char *)s,
            0x401u,
            "%.*s%0*d%s",
            *(_DWORD *)(a1 + 1068),
            v75,
            *(_DWORD *)(a1 + 1076),
            v61,
            &v75[*(_DWORD *)(a1 + 1072)]);
    if ( v62 > 0x400 )
    {
      v73 = _errno_location();
      sub_5DF98(2, "src/rotater.c", 272, "nwirte[%d], overflow or errno[%d]", v62, *v73);
    }
    else
    {
      if ( !rename(*(const char **)(a1 + 32), (const char *)s) )
        goto LABEL_48;
      v63 = _errno_location();
      sub_5DF98(
        2,
        "src/rotater.c",
        277,
        "rename[%s]->[%s] fail, errno[%d]",
        *(const char **)(a1 + 32),
        (const char *)s,
        *v63);
    }
    goto LABEL_88;
  }
  v43 = *(_DWORD **)(a1 + 1088);
  v44 = v43[1] - 1;
  if ( v44 >= 0 )
  {
    v45 = *(_DWORD *)(*v43 + 4 * v44);
    if ( !v45 )
    {
LABEL_90:
      sub_5DF98(2, "src/rotater.c", 297, "zc_arraylist_get fail");
      goto LABEL_69;
    }
    v46 = 4 * v44 - 4;
    while ( 1 )
    {
      v49 = *(_DWORD *)(a1 + 1084);
      v50 = (const char *)(v45 + 4);
      if ( v49 <= 0 || v44 < v49 - 1 )
      {
        memset(s, 0, 0x401u);
        v47 = snprintf(
                (char *)s,
                0x401u,
                "%.*s%0*d%s",
                *(_DWORD *)(a1 + 1068),
                v75,
                *(_DWORD *)(a1 + 1076),
                v44 + 1,
                &v75[*(_DWORD *)(a1 + 1072)]);
        if ( v47 > 0x400 )
        {
          v66 = v47;
          v67 = _errno_location();
          sub_5DF98(2, "src/rotater.c", 318, "nwirte[%d], overflow or errno[%d]", v66, *v67);
          goto LABEL_69;
        }
        if ( rename(v50, (const char *)s) )
        {
          v68 = _errno_location();
          sub_5DF98(2, "src/rotater.c", 323, "rename[%s]->[%s] fail, errno[%d]", v50, (const char *)s, *v68);
          goto LABEL_69;
        }
      }
      else if ( unlink((const char *)(v45 + 4)) )
      {
        v51 = _errno_location();
        sub_5DF98(2, "src/rotater.c", 305, "unlink[%s] fail, errno[%d]", v50, *v51);
        goto LABEL_69;
      }
      v36 = v44-- != 0;
      if ( !v36 )
        break;
      v48 = *(_DWORD **)(a1 + 1088);
      if ( v48[1] > v44 )
      {
        v45 = *(_DWORD *)(*v48 + v46);
        v46 -= 4;
        if ( v45 )
          continue;
      }
      goto LABEL_90;
    }
  }
  memset(s, 0, 0x401u);
  v64 = snprintf(
          (char *)s,
          0x401u,
          "%.*s%0*d%s",
          *(_DWORD *)(a1 + 1068),
          v75,
          *(_DWORD *)(a1 + 1076),
          0,
          &v75[*(_DWORD *)(a1 + 1072)]);
  if ( v64 <= 0x400 )
  {
    if ( rename(*(const char **)(a1 + 32), (const char *)s) )
    {
      v65 = _errno_location();
      sub_5DF98(
        2,
        "src/rotater.c",
        340,
        "rename[%s]->[%s] fail, errno[%d]",
        *(const char **)(a1 + 32),
        (const char *)s,
        *v65);
      goto LABEL_69;
    }
    goto LABEL_48;
  }
  v74 = _errno_location();
  sub_5DF98(2, "src/rotater.c", 335, "nwirte[%d], overflow or errno[%d]", v64, *v74);
LABEL_69:
  sub_5DF98(2, "src/rotater.c", 450, "zlog_rotater_roll_files fail");
LABEL_53:
  v14 = -1;
  sub_585E4((_DWORD *)a1);
  sub_5DF98(2, "src/rotater.c", 560, "zlog_rotater_lsmv [%s] fail, return", a2);
LABEL_10:
  memset(&s[2], 0, 16);
  v15 = *(_DWORD *)(a1 + 28);
  s[0] = 2;
  if ( !fcntl(v15, 13, s) )
  {
    if ( !pthread_mutex_unlock((pthread_mutex_t *)a1) )
      return v14;
    v17 = _errno_location();
    goto LABEL_93;
  }
  v17 = _errno_location();
  sub_5DF98(2, "src/rotater.c", 518, "unlock fd[%s] fail, errno[%d]", *(const char **)(a1 + 28), *v17);
  if ( pthread_mutex_unlock((pthread_mutex_t *)a1) )
LABEL_93:
    sub_5DF98(2, "src/rotater.c", 523, "pthread_mutext_unlock fail, errno[%d]", *v17);
  sub_5DF98(2, "src/rotater.c", 569, "zlog_rotater_unlock fail");
  return v14;
}
// 1231C: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);
// 123F4: using guessed type int __fastcall glob64(_DWORD, _DWORD, _DWORD, _DWORD);
// 12490: using guessed type int __fastcall globfree64(_DWORD);
// 12574: using guessed type int __fastcall _xstat64(_DWORD, _DWORD, _DWORD);
// 58958: using guessed type char var_498[48];

//----- (000595C0) --------------------------------------------------------
int __fastcall sub_595C0(int a1, int a2)
{
  int v2; // r5
  int (__fastcall *v5)(int *); // r1
  __int64 v6; // r2
  int result; // r0
  int v8[7]; // [sp+Ch] [bp-1Ch] BYREF

  v2 = a1 + 0x2000;
  if ( *(_DWORD *)(a1 + 8324) )
  {
    if ( sub_57A1C(*(_DWORD *)(a1 + 6264), a2) )
    {
      sub_5DF98(2, "src/rule.c", 391, "zlog_format_gen_msg fail");
      return -1;
    }
    else
    {
      **(_BYTE **)(*(_DWORD *)(a2 + 28) + 4) = 0;
      v5 = *(int (__fastcall **)(int *))(v2 + 132);
      v6 = *(_QWORD *)*(_DWORD *)(a2 + 28);
      v8[2] = a1 + 7297;
      v8[0] = v6;
      v8[1] = HIDWORD(v6) - v6;
      result = v5(v8);
      if ( result )
      {
        sub_5DF98(2, "src/rule.c", 401, "a_rule->record fail");
        return -1;
      }
    }
  }
  else
  {
    sub_5DF98(
      2,
      "src/rule.c",
      386,
      "user defined record funcion for [%s] not set, no output",
      (const char *)(a1 + 6272));
    return -1;
  }
  return result;
}

//----- (000596B0) --------------------------------------------------------
int __fastcall sub_596B0(int a1, int a2)
{
  int *v2; // r4
  int v5; // r9
  int v6; // r10
  int v7; // r0
  __int64 v8; // r6
  unsigned int v9; // r3
  unsigned int v10; // r2
  int *v12; // r0
  int *v13; // r7
  int v14; // r0
  int v15; // r0
  int *v16; // r0
  int *v17; // r0
  __int64 v18[12]; // [sp+8h] [bp-90h] BYREF
  __int64 v19; // [sp+68h] [bp-30h]

  v2 = (int *)(a1 + 4096);
  v5 = sub_57A1C(*(_DWORD *)(a1 + 6264), a2);
  if ( v5 )
  {
    sub_5DF98(2, "src/rule.c", 84, "zlog_format_gen_msg fail");
    return -1;
  }
  if ( _xstat64(3, a1 + 4144, v18) )
  {
    v12 = _errno_location();
    v13 = v12;
    if ( *v12 != 2 )
    {
      sub_5DF98(2, "src/rule.c", 91, "stat fail on [%s], errno[%d]", (const char *)(a1 + 4144), *v12);
      return -1;
    }
    close(v2[270]);
    v14 = open64(a1 + 4144);
    v2[270] = v14;
    if ( v14 >= 0 )
    {
      if ( _xstat64(3, a1 + 4144, v18) )
      {
        v5 = -1;
        sub_5DF98(2, "src/rule.c", 114, "stat fail on new file[%s], errno[%d]", (const char *)(a1 + 4144), *v13);
        return v5;
      }
      v7 = v2[270];
      v6 = a1 + 5200;
      goto LABEL_5;
    }
LABEL_24:
    v5 = -1;
    sub_5DF98(2, "src/rule.c", 107, "open file[%s] fail, errno[%d]", (const char *)(a1 + 4144), *v13);
    return v5;
  }
  v6 = a1 + 5200;
  v7 = v2[270];
  if ( v19 != *(_QWORD *)(a1 + 5192) || v18[0] != *(_QWORD *)(a1 + 5184) )
  {
    close(v7);
    v7 = open64(a1 + 4144);
    v2[270] = v7;
    if ( v7 >= 0 )
    {
LABEL_5:
      v8 = v19;
      *(_QWORD *)(a1 + 5184) = v18[0];
      *(_QWORD *)(v6 - 8) = v8;
      goto LABEL_6;
    }
    v13 = _errno_location();
    goto LABEL_24;
  }
LABEL_6:
  if ( write(v7, **(const void ***)(a2 + 28), *(_DWORD *)(*(_DWORD *)(a2 + 28) + 4) - **(_DWORD **)(a2 + 28)) < 0 )
  {
    v17 = _errno_location();
    sub_5DF98(2, "src/rule.c", 125, "write fail, errno[%d]", *v17);
    return -1;
  }
  else
  {
    v9 = v2[538];
    if ( v9 )
    {
      v10 = v2[539] + 1;
      if ( v9 <= v10 )
      {
        v15 = v2[270];
        v2[539] = 0;
        if ( fsync(v15) )
        {
          v16 = _errno_location();
          sub_5DF98(2, "src/rule.c", 133, "fsync[%d] fail, errno[%d]", v2[270], *v16);
        }
      }
      else
      {
        v2[539] = v10;
      }
    }
  }
  return v5;
}
// 12198: using guessed type int __fastcall open64(_DWORD);
// 12574: using guessed type int __fastcall _xstat64(_DWORD, _DWORD, _DWORD);

//----- (00059954) --------------------------------------------------------
int __fastcall sub_59954(int a1, int a2)
{
  int v2; // r4
  int v3; // r6
  _DWORD *v4; // r3
  int v5; // r2
  int v7; // r0
  _BYTE *v8; // r1
  int v9; // r0

  v3 = a1 + 4096;
  v4 = *(_DWORD **)(a1 + 6236);
  if ( !v4 )
    return a1 + 5208;
  v5 = *(_DWORD *)(a2 + 20);
  v7 = v4[1];
  v8 = *(_BYTE **)v5;
  if ( v7 > 0 )
    v2 = 0;
  *(_DWORD *)(v5 + 4) = v8;
  if ( v7 > 0 )
  {
    do
    {
      v9 = *(_DWORD *)(*v4 + 4 * v2++);
      if ( (*(int (**)(void))(v9 + 9264))() )
      {
        sub_5DF98(2, "src/rule.c", 151, "zlog_spec_gen_path fail");
        return 0;
      }
      v4 = *(_DWORD **)(v3 + 2140);
    }
    while ( v4[1] > v2 );
    v8 = *(_BYTE **)(*(_DWORD *)(a2 + 20) + 4);
  }
  *v8 = 0;
  return **(_DWORD **)(a2 + 20);
}
// 599A4: variable 'v2' is possibly undefined

//----- (00059A0C) --------------------------------------------------------
int __fastcall sub_59A0C(int a1, int a2)
{
  int *v2; // r4
  const char *v5; // r6
  int v6; // r0
  int v7; // r9
  int v8; // r2
  size_t v9; // r5
  unsigned int v10; // r3
  int v11; // r8
  unsigned int v13; // r2
  int *v14; // r0
  int *v15; // r0
  int v16; // r0
  int v17; // r7
  const char *v18; // r0
  int *v19; // r0
  int *v20; // r0
  int *v21; // r0
  char v22[48]; // [sp+8h] [bp-88h] BYREF
  __int64 v23; // [sp+38h] [bp-58h]

  v2 = (int *)(a1 + 4096);
  if ( sub_57A1C(*(_DWORD *)(a1 + 6264), a2) )
  {
    sub_5DF98(2, "src/rule.c", 167, "zlog_format_gen_msg fail");
    return -1;
  }
  v5 = (const char *)(a1 + 4144);
  v6 = open64(a1 + 4144);
  v7 = v6;
  if ( v6 < 0 )
  {
    v19 = _errno_location();
    v11 = -1;
    sub_5DF98(2, "src/rule.c", 174, "open file[%s] fail, errno[%d]", (const char *)(a1 + 4144), *v19);
    return v11;
  }
  v8 = *(_DWORD *)(a2 + 28);
  v9 = *(_DWORD *)(v8 + 4) - *(_DWORD *)v8;
  if ( write(v6, *(const void **)v8, v9) < 0 )
  {
    v20 = _errno_location();
    sub_5DF98(2, "src/rule.c", 180, "write fail, errno[%d]", *v20);
    v11 = -1;
    close(v7);
    return v11;
  }
  v10 = v2[538];
  if ( v10 )
  {
    v13 = v2[539] + 1;
    if ( v10 <= v13 )
    {
      v2[539] = 0;
      if ( fsync(v7) )
      {
        v14 = _errno_location();
        sub_5DF98(2, "src/rule.c", 187, "fsync[%d] fail, errno[%d]", v7, *v14);
      }
    }
    else
    {
      v2[539] = v13;
    }
  }
  if ( close(v7) < 0 )
  {
    v21 = _errno_location();
    sub_5DF98(2, "src/rule.c", 191, "close fail, maybe cause by write, errno[%d]", *v21);
    return -1;
  }
  if ( v2[276] < v9 )
  {
    sub_5DF98(0, "src/rule.c", 197, "one msg's len[%ld] > archive_max_size[%ld], no rotate", v9, v2[276]);
    return 0;
  }
  else
  {
    if ( !_xstat64(3, a1 + 4144, v22) )
    {
      if ( v23 + v9 < v2[276] )
        return 0;
      v16 = a1;
      v17 = *(_DWORD *)(dword_99EEC8 + 5160);
      v18 = (const char *)sub_59954(v16, a2);
      if ( !sub_58958(v17, v5, v9, v18, v2[276], v2[277]) )
        return 0;
      v11 = -1;
      sub_5DF98(2, "src/rule.c", 214, "zlog_rotater_rotate fail");
      return v11;
    }
    v15 = _errno_location();
    sub_5DF98(1, "src/rule.c", 202, "stat [%s] fail, errno[%d], maybe in rotating", (const char *)(a1 + 4144), *v15);
    return 0;
  }
}
// 12198: using guessed type int __fastcall open64(_DWORD);
// 12574: using guessed type int __fastcall _xstat64(_DWORD, _DWORD, _DWORD);
// 99EEC8: using guessed type int dword_99EEC8;
// 59A0C: using guessed type char var_88[48];

//----- (00059CD4) --------------------------------------------------------
int __fastcall sub_59CD4(int a1, int a2)
{
  int v2; // r7
  int v3; // r5
  int v4; // r2
  _DWORD *v5; // r3
  _BYTE *v7; // r0
  int v8; // r1
  int v9; // r4
  int v10; // r0
  int result; // r0
  int (__fastcall *v12)(__int64 *); // r1
  __int64 v13; // r2
  int v14; // r12
  __int64 v15; // [sp+Ch] [bp-24h] BYREF
  int v16; // [sp+14h] [bp-1Ch]

  v2 = a1 + 0x2000;
  if ( *(_DWORD *)(a1 + 8324) )
  {
    v3 = a1 + 4096;
    v4 = *(_DWORD *)(a2 + 16);
    v5 = *(_DWORD **)(a1 + 5172);
    v7 = *(_BYTE **)v4;
    v8 = v5[1];
    *(_DWORD *)(v4 + 4) = *(_DWORD *)v4;
    if ( v8 > 0 )
    {
      v9 = 0;
      do
      {
        v10 = *(_DWORD *)(*v5 + 4 * v9++);
        if ( (*(int (**)(void))(v10 + 9260))() )
        {
          sub_5DF98(2, "src/rule.c", 417, "zlog_spec_gen_path fail");
          return -1;
        }
        v5 = *(_DWORD **)(v3 + 1076);
      }
      while ( v9 < v5[1] );
      v7 = *(_BYTE **)(*(_DWORD *)(a2 + 16) + 4);
    }
    *v7 = 0;
    if ( sub_57A1C(*(_DWORD *)(v3 + 2168), a2) )
    {
      sub_5DF98(2, "src/rule.c", 420, "zlog_format_gen_msg fail");
      return -1;
    }
    else
    {
      **(_BYTE **)(*(_DWORD *)(a2 + 28) + 4) = 0;
      v12 = *(int (__fastcall **)(__int64 *))(v2 + 132);
      v13 = *(_QWORD *)*(_DWORD *)(a2 + 28);
      v14 = **(_DWORD **)(a2 + 16);
      HIDWORD(v13) -= v13;
      v15 = v13;
      v16 = v14;
      result = v12(&v15);
      if ( result )
      {
        sub_5DF98(2, "src/rule.c", 430, "a_rule->record fail");
        return -1;
      }
    }
  }
  else
  {
    sub_5DF98(
      2,
      "src/rule.c",
      413,
      "user defined record funcion for [%s] not set, no output",
      (const char *)(a1 + 6272));
    return -1;
  }
  return result;
}

//----- (00059E54) --------------------------------------------------------
int __fastcall sub_59E54(int a1, int a2)
{
  int v3; // r4
  int *v5; // r0

  v3 = sub_57A1C(*(_DWORD *)(a1 + 6264), a2);
  if ( v3 )
  {
    sub_5DF98(2, "src/rule.c", 459, "zlog_format_gen_msg fail");
    return -1;
  }
  else if ( write(2, **(const void ***)(a2 + 28), *(_DWORD *)(*(_DWORD *)(a2 + 28) + 4) - **(_DWORD **)(a2 + 28)) < 0 )
  {
    v5 = _errno_location();
    v3 = -1;
    sub_5DF98(2, "src/rule.c", 465, "write fail, errno[%d]", *v5);
  }
  return v3;
}

//----- (00059EF8) --------------------------------------------------------
int __fastcall sub_59EF8(int a1, int a2)
{
  int v3; // r4
  int *v5; // r0

  v3 = sub_57A1C(*(_DWORD *)(a1 + 6264), a2);
  if ( v3 )
  {
    sub_5DF98(2, "src/rule.c", 441, "zlog_format_gen_msg fail");
    return -1;
  }
  else if ( write(1, **(const void ***)(a2 + 28), *(_DWORD *)(*(_DWORD *)(a2 + 28) + 4) - **(_DWORD **)(a2 + 28)) < 0 )
  {
    v5 = _errno_location();
    v3 = -1;
    sub_5DF98(2, "src/rule.c", 447, "write fail, errno[%d]", *v5);
  }
  return v3;
}

//----- (00059F9C) --------------------------------------------------------
int __fastcall sub_59F9C(int a1, int a2)
{
  int v2; // r4
  int v4; // r5
  int *v6; // r0

  v2 = a1 + 4096;
  v4 = sub_57A1C(*(_DWORD *)(a1 + 6264), a2);
  if ( v4 )
  {
    sub_5DF98(2, "src/rule.c", 345, "zlog_format_gen_msg fail");
    return -1;
  }
  else if ( write(
              *(_DWORD *)(v2 + 2148),
              **(const void ***)(a2 + 28),
              *(_DWORD *)(*(_DWORD *)(a2 + 28) + 4) - **(_DWORD **)(a2 + 28)) < 0 )
  {
    v6 = _errno_location();
    v4 = -1;
    sub_5DF98(2, "src/rule.c", 352, "write fail, errno[%d]", *v6);
  }
  return v4;
}

//----- (0005A040) --------------------------------------------------------
int __fastcall sub_5A040(int a1, int a2)
{
  int v2; // r6
  int v4; // r5
  int v5; // r0

  v2 = a1 + 4096;
  v4 = sub_57A1C(*(_DWORD *)(a1 + 6264), a2);
  if ( v4 )
  {
    sub_5DF98(2, "src/rule.c", 364, "zlog_format_gen_msg fail");
    return -1;
  }
  else
  {
    v5 = sub_57D70(*(int **)(dword_99EEC8 + 9280), *(_DWORD *)(*(_DWORD *)(a2 + 8) + 292));
    **(_BYTE **)(*(_DWORD *)(a2 + 28) + 4) = 0;
    syslog(*(_DWORD *)(v2 + 2164) | *(_DWORD *)(v5 + 2060), "%s", **(const char ***)(a2 + 28));
  }
  return v4;
}
// 99EEC8: using guessed type int dword_99EEC8;

//----- (0005A0D4) --------------------------------------------------------
int __fastcall sub_5A0D4(int a1, int a2)
{
  int v2; // r4
  _DWORD *v3; // r5
  _DWORD *v4; // r3
  int v6; // r2
  int v7; // r1
  _BYTE *v8; // r0
  int v9; // r0
  int v10; // r4
  int v12; // r0
  int v13; // r7
  unsigned int v14; // r3
  unsigned int v15; // r2
  int *v16; // r0
  int *v17; // r0
  int *v18; // r0
  int *v19; // r0

  v3 = (_DWORD *)(a1 + 4096);
  v4 = *(_DWORD **)(a1 + 5172);
  v6 = *(_DWORD *)(a2 + 16);
  v7 = v4[1];
  v8 = *(_BYTE **)v6;
  if ( v7 > 0 )
    v2 = 0;
  *(_DWORD *)(v6 + 4) = v8;
  if ( v7 > 0 )
  {
    do
    {
      v9 = *(_DWORD *)(*v4 + 4 * v2++);
      if ( (*(int (**)(void))(v9 + 9260))() )
      {
        v10 = -1;
        sub_5DF98(2, "src/rule.c", 245, "zlog_spec_gen_path fail");
        return v10;
      }
      v4 = (_DWORD *)v3[269];
    }
    while ( v4[1] > v2 );
    v8 = *(_BYTE **)(*(_DWORD *)(a2 + 16) + 4);
  }
  *v8 = 0;
  v10 = sub_57A1C(v3[542], a2);
  if ( v10 )
  {
    sub_5DF98(2, "src/rule.c", 248, "zlog_format_output fail");
    return -1;
  }
  else
  {
    v12 = open64(**(_DWORD **)(a2 + 16));
    v13 = v12;
    if ( v12 < 0 )
    {
      v18 = _errno_location();
      v10 = -1;
      sub_5DF98(2, "src/rule.c", 255, "open file[%s] fail, errno[%d]", **(const char ***)(a2 + 16), *v18);
    }
    else if ( write(v12, **(const void ***)(a2 + 28), *(_DWORD *)(*(_DWORD *)(a2 + 28) + 4) - **(_DWORD **)(a2 + 28)) < 0 )
    {
      v19 = _errno_location();
      sub_5DF98(2, "src/rule.c", 260, "write fail, errno[%d]", *v19);
      v10 = -1;
      close(v13);
    }
    else
    {
      v14 = v3[538];
      if ( v14 )
      {
        v15 = v3[539] + 1;
        if ( v14 <= v15 )
        {
          v3[539] = 0;
          if ( fsync(v13) )
          {
            v17 = _errno_location();
            sub_5DF98(2, "src/rule.c", 267, "fsync[%d] fail, errno[%d]", v13, *v17);
          }
        }
        else
        {
          v3[539] = v15;
        }
      }
      if ( close(v13) < 0 )
      {
        v16 = _errno_location();
        v10 = -1;
        sub_5DF98(2, "src/rule.c", 271, "close fail, maybe cause by write, errno[%d]", *v16);
      }
    }
  }
  return v10;
}
// 5A120: variable 'v2' is possibly undefined
// 12198: using guessed type int __fastcall open64(_DWORD);

//----- (0005A30C) --------------------------------------------------------
int __fastcall sub_5A30C(int a1, int a2)
{
  int v2; // r4
  _DWORD *v3; // r5
  _DWORD *v4; // r3
  int v7; // r2
  int v8; // r1
  _BYTE *v9; // r0
  int v10; // r0
  int v11; // r8
  const char *v13; // r9
  int v14; // r0
  int v15; // r10
  int v16; // r2
  size_t v17; // r4
  unsigned int v18; // r3
  unsigned int v19; // r2
  int *v20; // r0
  int *v21; // r0
  int v22; // r1
  int v23; // r6
  const char *v24; // r0
  int *v25; // r0
  int *v26; // r0
  int *v27; // r0
  char v28[48]; // [sp+8h] [bp-90h] BYREF
  __int64 v29; // [sp+38h] [bp-60h]

  v3 = (_DWORD *)(a1 + 4096);
  v4 = *(_DWORD **)(a1 + 5172);
  v7 = *(_DWORD *)(a2 + 16);
  v8 = v4[1];
  v9 = *(_BYTE **)v7;
  if ( v8 > 0 )
    v2 = 0;
  *(_DWORD *)(v7 + 4) = v9;
  if ( v8 > 0 )
  {
    do
    {
      v10 = *(_DWORD *)(*v4 + 4 * v2++);
      if ( (*(int (**)(void))(v10 + 9260))() )
      {
        v11 = -1;
        sub_5DF98(2, "src/rule.c", 285, "zlog_spec_gen_path fail");
        return v11;
      }
      v4 = (_DWORD *)v3[269];
    }
    while ( v4[1] > v2 );
    v9 = *(_BYTE **)(*(_DWORD *)(a2 + 16) + 4);
  }
  *v9 = 0;
  v11 = sub_57A1C(v3[542], a2);
  if ( v11 )
  {
    sub_5DF98(2, "src/rule.c", 288, "zlog_format_output fail");
    return -1;
  }
  v13 = **(const char ***)(a2 + 16);
  v14 = open64(v13);
  v15 = v14;
  if ( v14 < 0 )
  {
    v26 = _errno_location();
    v11 = -1;
    sub_5DF98(2, "src/rule.c", 295, "open file[%s] fail, errno[%d]", **(const char ***)(a2 + 16), *v26);
    return v11;
  }
  v16 = *(_DWORD *)(a2 + 28);
  v17 = *(_DWORD *)(v16 + 4) - *(_DWORD *)v16;
  if ( write(v14, *(const void **)v16, v17) < 0 )
  {
    v27 = _errno_location();
    sub_5DF98(2, "src/rule.c", 301, "write fail, errno[%d]", *v27);
    v11 = -1;
    close(v15);
    return v11;
  }
  v18 = v3[538];
  if ( v18 )
  {
    v19 = v3[539] + 1;
    if ( v18 <= v19 )
    {
      v3[539] = 0;
      if ( fsync(v15) )
      {
        v20 = _errno_location();
        sub_5DF98(2, "src/rule.c", 308, "fsync[%d] fail, errno[%d]", v15, *v20);
      }
    }
    else
    {
      v3[539] = v19;
    }
  }
  if ( close(v15) < 0 )
  {
    v25 = _errno_location();
    sub_5DF98(2, "src/rule.c", 312, "write fail, maybe cause by write, errno[%d]", *v25);
    return -1;
  }
  if ( v17 > v3[276] )
  {
    sub_5DF98(0, "src/rule.c", 318, "one msg's len[%ld] > archive_max_size[%ld], no rotate", v17, v3[276]);
    return 0;
  }
  else
  {
    if ( _xstat64(3, v13, v28) )
    {
      v21 = _errno_location();
      sub_5DF98(1, "src/rule.c", 323, "stat [%s] fail, errno[%d], maybe in rotating", v13, *v21);
      return v11;
    }
    if ( v29 + v17 >= (int)v3[276] )
    {
      v22 = a2;
      v23 = *(_DWORD *)(dword_99EEC8 + 5160);
      v24 = (const char *)sub_59954(a1, v22);
      if ( sub_58958(v23, v13, v17, v24, v3[276], v3[277]) )
      {
        v11 = -1;
        sub_5DF98(2, "src/rule.c", 335, "zlog_rotater_rotate fail");
        return v11;
      }
    }
    return 0;
  }
}
// 5A35C: variable 'v2' is possibly undefined
// 12198: using guessed type int __fastcall open64(_DWORD);
// 12574: using guessed type int __fastcall _xstat64(_DWORD, _DWORD, _DWORD);
// 99EEC8: using guessed type int dword_99EEC8;
// 5A30C: using guessed type char var_90[48];

//----- (0005A66C) --------------------------------------------------------
int __fastcall sub_5A66C(const char *a1, char *a2, _DWORD *a3, const char **a4)
{
  const char *v4; // r5
  char *v9; // r0
  int v10; // r8
  _DWORD *v11; // r5
  const char **v12; // r4
  int result; // r0
  const char *arg; // [sp+0h] [bp-28h]
  char *v15; // [sp+Ch] [bp-1Ch] BYREF

  v4 = a1 + 1;
  v9 = strrchr(a1 + 1, 34);
  v15 = v9;
  if ( !v9 )
  {
    arg = a1;
    v10 = -1;
    sub_5DF98(2, "src/rule.c", 516, "matching \" not found in conf line[%s]", arg);
    return v10;
  }
  if ( (unsigned int)(v9 - v4) > 0x400 )
  {
    v10 = -1;
    sub_5DF98(2, "src/rule.c", 521, "file_path too long %ld > %ld", v9 - v4, 1024);
    return v10;
  }
  memcpy(a2, v4, v9 - v4);
  v10 = sub_5E310(a2, 1025);
  if ( v10 )
  {
    sub_5DF98(2, "src/rule.c", 528, "zc_str_replace_env fail");
    return -1;
  }
  if ( !strchr(a2, 37) )
    return v10;
  v11 = sub_5D4C0((int)sub_5C6F4);
  if ( *a2 )
  {
    while ( 1 )
    {
      v12 = sub_5C758(a2, &v15, a4);
      if ( !v12 )
      {
        sub_5DF98(2, "src/rule.c", 546, "zlog_spec_new fail");
        v10 = -1;
        if ( v11 )
          sub_5D580(v11);
        return v10;
      }
      if ( sub_5D694((int)v11, (int)v12) )
        break;
      a2 = v15;
      if ( !*v15 )
        goto LABEL_13;
    }
    sub_5DF98(2, "src/rule.c", 551, "zc_arraylist_add fail");
    if ( v11 )
      sub_5D580(v11);
    sub_5C6F4(v12);
    return -1;
  }
  else
  {
LABEL_13:
    result = 0;
    *a3 = v11;
  }
  return result;
}

//----- (0005A850) --------------------------------------------------------
int __fastcall sub_5A850(int a1, int a2)
{
  int v2; // r5
  int result; // r0
  _DWORD *v5; // r3
  int v6; // r4
  const char **v7; // r0

  if ( !a1 )
    return sub_5DF98(2, "src/rule.c", 39, "a_rule is null or 0");
  v2 = a1 + 4096;
  result = sub_5DF98(
             a2,
             "src/rule.c",
             65,
             "---rule:[%p][%s%c%d]-[%d,%d][%s,%p,%d:%ld*%d~%s][%d][%d][%s:%s:%p];[%p]---",
             (const void *)a1,
             (const char *)a1,
             *(unsigned __int8 *)(a1 + 4097),
             *(_DWORD *)(a1 + 4100),
             *(_DWORD *)(a1 + 4136),
             *(_DWORD *)(a1 + 4140),
             (const char *)(a1 + 4144),
             *(const void **)(a1 + 5172),
             *(_DWORD *)(a1 + 5176),
             *(_DWORD *)(a1 + 5200),
             *(_DWORD *)(a1 + 5204),
             (const char *)(a1 + 5208),
             *(_DWORD *)(a1 + 6244),
             *(_DWORD *)(a1 + 6260),
             (const char *)(a1 + 6272),
             (const char *)(a1 + 7297),
             *(const void **)(a1 + 8324),
             *(const void **)(a1 + 6264));
  v5 = *(_DWORD **)(v2 + 1076);
  if ( v5 && (int)v5[1] > 0 )
  {
    v6 = 0;
    do
    {
      v7 = *(const char ***)(*v5 + 4 * v6++);
      result = sub_5C630(v7, a2);
      v5 = *(_DWORD **)(v2 + 1076);
    }
    while ( v5[1] > v6 );
  }
  return result;
}

//----- (0005A97C) --------------------------------------------------------
void __fastcall sub_5A97C(_DWORD *a1)
{
  _DWORD *v2; // r0
  int v3; // r0
  FILE *v4; // r0
  _DWORD *v5; // r0
  int *v6; // r0
  int *v7; // r0

  if ( a1 )
  {
    v2 = (_DWORD *)a1[1293];
    if ( v2 )
    {
      sub_5D580(v2);
      a1[1293] = 0;
    }
    v3 = a1[1294];
    if ( v3 && close(v3) )
    {
      v6 = _errno_location();
      sub_5DF98(2, "src/rule.c", 949, "close fail, maybe cause by write, errno[%d]", *v6);
    }
    v4 = (FILE *)a1[1560];
    if ( v4 && pclose(v4) == -1 )
    {
      v7 = _errno_location();
      sub_5DF98(2, "src/rule.c", 954, "pclose fail, errno[%d]", *v7);
    }
    v5 = (_DWORD *)a1[1559];
    if ( v5 )
    {
      sub_5D580(v5);
      a1[1559] = 0;
    }
    sub_5DF98(0, "src/rule.c", 961, "zlog_rule_del[%p]", a1);
    free(a1);
  }
  else
  {
    sub_5DF98(2, "src/rule.c", 942, "a_rule is null or 0");
  }
}

//----- (0005AA9C) --------------------------------------------------------
unsigned __int8 *__fastcall sub_5AA9C(const char *a1, _DWORD *a2, int a3, __int64 *a4, int a5, int a6, const char **a7)
{
  unsigned __int8 *v11; // r5
  const char *v12; // r7
  int v13; // r4
  const unsigned __int16 *v14; // r0
  unsigned int v15; // r3
  char *v16; // r1
  bool v17; // zf
  int v18; // r2
  bool v19; // r3
  _BOOL4 v20; // r4
  int v21; // t1
  const char *v22; // r1
  int v23; // r0
  int v24; // r3
  int v25; // r4
  int v26; // r0
  __int64 v27; // r8
  int v28; // r8
  int v29; // r4
  const char *v30; // r10
  const char *v31; // t1
  char *v32; // r4
  unsigned int v33; // r7
  const unsigned __int16 **v34; // r0
  char *v35; // r2
  char *v36; // r0
  const void *v37; // r7
  char *v38; // r0
  const char *v39; // r4
  _DWORD *v40; // r0
  const char **v41; // r4
  _DWORD *v42; // r0
  int v44; // r2
  int v45; // r2
  FILE *v46; // r0
  int v47; // r0
  int *v48; // r0
  const char *v49; // r0
  char *v50; // r0
  char *v51; // r0
  const char *v52; // r4
  int v53; // r3
  int v54; // r3
  int *v55; // r0
  int v56; // r3
  int v57; // r0
  __int64 v58; // r0
  int *v59; // r0
  int *v60; // r0
  int *v61; // r0
  int v62; // [sp+Ch] [bp-70B4h] BYREF
  __int64 v63[13]; // [sp+10h] [bp-70B0h] BYREF
  char s[4100]; // [sp+7Ch] [bp-7044h] BYREF
  char src[4100]; // [sp+1080h] [bp-6040h] BYREF
  _BYTE v66[4100]; // [sp+2084h] [bp-503Ch] BYREF
  char v67[4100]; // [sp+3088h] [bp-4038h] BYREF
  char v68[4100]; // [sp+408Ch] [bp-3034h] BYREF
  char v69[4100]; // [sp+5090h] [bp-2030h] BYREF
  char v70[4140]; // [sp+6094h] [bp-102Ch] BYREF

  v62 = 0;
  if ( !a1 )
  {
    v11 = 0;
    sub_5DF98(2, "src/rule.c", 592, "line is null or 0");
    return v11;
  }
  if ( !a3 )
  {
    v11 = 0;
    sub_5DF98(2, "src/rule.c", 593, "default_format is null or 0");
    return v11;
  }
  if ( !a4 )
  {
    v11 = 0;
    sub_5DF98(2, "src/rule.c", 594, "formats is null or 0");
    return v11;
  }
  v11 = (unsigned __int8 *)calloc(1u, 0x2088u);
  if ( !v11 )
  {
    v55 = _errno_location();
    sub_5DF98(2, "src/rule.c", 598, "calloc fail, errno[%d]", *v55);
    return v11;
  }
  *((_DWORD *)v11 + 1034) = a5;
  *((_DWORD *)v11 + 1562) = a6;
  memset(s, 0, 0x1001u);
  if ( _isoc99_sscanf(a1, "%s %n", s, &v62) != 1 )
  {
    sub_5DF98(2, "src/rule.c", 612, "sscanf [%s] fail, selector", a1);
    goto LABEL_61;
  }
  v12 = &a1[v62];
  memset(src, 0, 0x1001u);
  memset(v66, 0, 0x1001u);
  if ( _isoc99_sscanf(s, " %[^.].%s", src, v66) != 2 )
  {
    sub_5DF98(2, "src/rule.c", 627, "sscanf [%s] fail, category or level is null", s);
    goto LABEL_61;
  }
  v13 = (unsigned __int8)src[0];
  if ( src[0] )
  {
    v14 = *_ctype_b_loc();
    v16 = src;
    while ( 1 )
    {
      v17 = v13 == 45;
      if ( v13 != 45 )
        v17 = v13 == 95;
      if ( !v17 )
        LOBYTE(v15) = 1;
      v18 = v14[v13];
      if ( v17 )
        LOBYTE(v15) = 0;
      v19 = v13 != 42 && v15 & 1;
      v20 = v13 != 33 && v19;
      v15 = v20 & ((v18 ^ 8u) >> 3);
      if ( v15 )
        break;
      v21 = (unsigned __int8)*++v16;
      v13 = v21;
      if ( !v21 )
        goto LABEL_23;
    }
    sub_5DF98(2, "src/rule.c", 634, "category name[%s] character is not in [a-Z][0-9][_!*-]", src);
    goto LABEL_61;
  }
LABEL_23:
  strcpy((char *)v11, src);
  if ( v66[0] == 42 )
  {
    v11[4097] = 42;
    v22 = v66;
  }
  else if ( v66[0] == 61 || v66[0] == 33 )
  {
    v11[4097] = v66[0];
    v22 = &v66[1];
  }
  else
  {
    v22 = v66;
    v11[4097] = 46;
  }
  v23 = sub_57DE4(a2, v22);
  v24 = v11[4097];
  v25 = v23;
  *((_DWORD *)v11 + 1025) = v23;
  switch ( v24 )
  {
    case '!':
      memset(v11 + 4104, 255, 0x20u);
      LOBYTE(v44) = v25 & 7;
      if ( v25 <= 0 )
        v44 = -(-v25 & 7);
      v11[v25 / 8 + 4104] &= ~(1 << (7 - v44));
      break;
    case '*':
      memset(v11 + 4104, 255, 0x20u);
      break;
    case '.':
      memset(v11 + 4104, 0, 0x20u);
      LOBYTE(v26) = v25 & 7;
      if ( v25 <= 0 )
        v26 = -(-v25 & 7);
      v11[v25 / 8 + 4104] |= ~(-1 << (8 - v26));
      memset(&v11[v25 / 8 + 4105], 255, 31 - v25 / 8);
      break;
    case '=':
      memset(v11 + 4104, 0, 0x20u);
      LOBYTE(v45) = v25 & 7;
      if ( v25 <= 0 )
        v45 = -(-v25 & 7);
      v11[v25 / 8 + 4104] |= 1 << (7 - v45);
      break;
    default:
      break;
  }
  memset(v67, 0, 0x1001u);
  memset(v68, 0, 0x1001u);
  if ( _isoc99_sscanf(v12, " %[^;];%s", v67, v68) <= 0 )
  {
    sub_5DF98(2, "src/rule.c", 700, "sscanf [%s] fail", v12);
    goto LABEL_61;
  }
  if ( v68[0] )
  {
    v27 = *a4;
    if ( v27 <= 0 )
    {
LABEL_60:
      sub_5DF98(2, "src/rule.c", 722, "in conf file can't find format[%s], pls check", v68);
      goto LABEL_61;
    }
    v28 = v27 - 4;
    v29 = 0;
    while ( 1 )
    {
      v31 = *(const char **)(v28 + 4);
      v28 += 4;
      v30 = v31;
      ++v29;
      if ( !strcmp(v31, v68) )
        break;
      if ( v29 == HIDWORD(v27) )
        goto LABEL_60;
    }
    *((_DWORD *)v11 + 1566) = v30;
  }
  else
  {
    sub_5DF98(0, "src/rule.c", 706, "no format specified, use default");
    *((_DWORD *)v11 + 1566) = a3;
  }
  memset(v69, 0, 0x1001u);
  if ( _isoc99_sscanf(v67, " %[^,],", v69) <= 0 )
  {
    sub_5DF98(2, "src/rule.c", 734, "sscanf [%s] fail", v12);
    goto LABEL_61;
  }
  v32 = strchr(v67, 44);
  v33 = (unsigned __int8)v69[0];
  if ( v32 )
  {
    v34 = _ctype_b_loc();
    v35 = v32 + 1;
    do
      v32 = v35++;
    while ( ((*v34)[(unsigned __int8)*v32] & 0x2000) != 0 );
    if ( v33 != 45 )
    {
      if ( v33 <= 0x2D )
      {
        if ( v33 != 34 )
        {
          if ( v33 == 36 )
          {
            _isoc99_sscanf(&v69[1], "%s", v11 + 6272);
            v36 = strchr(v32, 34);
            if ( v36 )
            {
              v37 = v36 + 1;
              v38 = strrchr(v36 + 1, 34);
              LODWORD(v63[0]) = v38;
              if ( v38 )
              {
                if ( (unsigned int)(v38 - (_BYTE *)v37) <= 0x400 )
                {
                  v39 = (const char *)(v11 + 7297);
                  memcpy(v11 + 7297, v37, v38 - (_BYTE *)v37);
                  goto LABEL_51;
                }
                sub_5DF98(2, "src/rule.c", 886, "record_path too long %ld > %ld", v38 - (_BYTE *)v37, 1024);
              }
              else
              {
                sub_5DF98(2, "src/rule.c", 881, "matching \" not found in conf line[%s]", (const char *)v37);
              }
            }
            else
            {
              sub_5DF98(2, "src/rule.c", 874, "record_path not start with \", [%s]", v32);
            }
LABEL_61:
            v42 = v11;
            v11 = 0;
            sub_5A97C(v42);
            return v11;
          }
LABEL_105:
          sub_5DF98(2, "src/rule.c", 930, "the 1st char[%c] of file_path[%s] is wrong", v33, v69);
          goto LABEL_61;
        }
        goto LABEL_106;
      }
      if ( v33 == 62 )
      {
        if ( strncmp(&v69[1], "syslog", 6u) )
          goto LABEL_83;
        if ( !strcasecmp(v32, "LOG_LOCAL0") )
        {
          *((_DWORD *)v11 + 1565) = 128;
          goto LABEL_147;
        }
        if ( !strcasecmp(v32, "LOG_LOCAL1") )
        {
          *((_DWORD *)v11 + 1565) = 136;
          goto LABEL_147;
        }
        if ( !strcasecmp(v32, "LOG_LOCAL2") )
        {
          *((_DWORD *)v11 + 1565) = 144;
          goto LABEL_147;
        }
        if ( !strcasecmp(v32, "LOG_LOCAL3") )
        {
          *((_DWORD *)v11 + 1565) = 152;
          goto LABEL_147;
        }
        if ( !strcasecmp(v32, "LOG_LOCAL4") )
        {
          *((_DWORD *)v11 + 1565) = 160;
          goto LABEL_147;
        }
        if ( !strcasecmp(v32, "LOG_LOCAL5") )
        {
          *((_DWORD *)v11 + 1565) = 168;
          goto LABEL_147;
        }
        if ( !strcasecmp(v32, "LOG_LOCAL6") )
        {
          *((_DWORD *)v11 + 1565) = 176;
          goto LABEL_147;
        }
        if ( !strcasecmp(v32, "LOG_LOCAL7") )
        {
          *((_DWORD *)v11 + 1565) = 184;
          goto LABEL_147;
        }
        if ( !strcasecmp(v32, "LOG_USER") )
        {
          *((_DWORD *)v11 + 1565) = 8;
          goto LABEL_147;
        }
        if ( strcasecmp(v32, "LOG_AUTHPRIV") )
        {
          if ( !strcasecmp(v32, "LOG_CRON") )
          {
            *((_DWORD *)v11 + 1565) = 72;
            goto LABEL_147;
          }
          if ( !strcasecmp(v32, "LOG_DAEMON") )
          {
            *((_DWORD *)v11 + 1565) = 24;
            goto LABEL_147;
          }
          if ( !strcasecmp(v32, "LOG_FTP") )
          {
            *((_DWORD *)v11 + 1565) = 88;
            goto LABEL_147;
          }
          if ( !strcasecmp(v32, "LOG_KERN") )
          {
            *((_DWORD *)v11 + 1565) = 0;
LABEL_147:
            *((_DWORD *)v11 + 1567) = sub_5A040;
            openlog(0, 25, 8);
            return v11;
          }
          if ( !strcasecmp(v32, "LOG_LPR") )
          {
            *((_DWORD *)v11 + 1565) = 48;
            goto LABEL_147;
          }
          if ( !strcasecmp(v32, "LOG_MAIL") )
          {
            *((_DWORD *)v11 + 1565) = 16;
            goto LABEL_147;
          }
          if ( !strcasecmp(v32, "LOG_NEWS") )
          {
            *((_DWORD *)v11 + 1565) = 56;
            goto LABEL_147;
          }
          if ( !strcasecmp(v32, "LOG_SYSLOG") )
          {
            *((_DWORD *)v11 + 1565) = 40;
            goto LABEL_147;
          }
        }
        *((_DWORD *)v11 + 1565) = 80;
        goto LABEL_147;
      }
LABEL_76:
      if ( v33 == 124 )
      {
        v46 = popen(&v67[1], "w");
        *((_DWORD *)v11 + 1560) = v46;
        if ( v46 )
        {
          v47 = fileno(v46);
          *((_DWORD *)v11 + 1561) = v47;
          if ( v47 >= 0 )
          {
            *((_DWORD *)v11 + 1567) = 368540;
            return v11;
          }
          v48 = _errno_location();
          sub_5DF98(2, "src/rule.c", 844, "fileno fail, errno[%d]", *v48);
        }
        else
        {
          v59 = _errno_location();
          sub_5DF98(2, "src/rule.c", 839, "popen fail, errno[%d]", *v59);
        }
        goto LABEL_61;
      }
      goto LABEL_105;
    }
  }
  else if ( v69[0] != 45 )
  {
    if ( (unsigned __int8)v69[0] <= 0x2Du )
    {
      if ( v69[0] != 34 )
      {
        if ( v69[0] == 36 )
        {
          _isoc99_sscanf(&v69[1], "%s", v11 + 6272);
          v39 = (const char *)(v11 + 7297);
LABEL_51:
          if ( sub_5E310(v39, 1025) )
          {
            sub_5DF98(2, "src/rule.c", 895, "zc_str_replace_env fail");
          }
          else
          {
            if ( !strchr(v39, 37) )
            {
              *((_DWORD *)v11 + 1567) = 366016;
              return v11;
            }
            *((_DWORD *)v11 + 1567) = sub_59CD4;
            v40 = sub_5D4C0((int)sub_5C6F4);
            *((_DWORD *)v11 + 1293) = v40;
            if ( v40 )
            {
              if ( !v11[7297] )
                return v11;
              while ( 1 )
              {
                v41 = sub_5C758(v39, (char **)v63, a7);
                if ( !v41 )
                {
                  sub_5DF98(2, "src/rule.c", 915, "zlog_spec_new fail");
                  goto LABEL_61;
                }
                if ( sub_5D694(*((_DWORD *)v11 + 1293), (int)v41) )
                  break;
                v39 = (const char *)v63[0];
                if ( !*(_BYTE *)LODWORD(v63[0]) )
                  return v11;
              }
              sub_5C6F4(v41);
              sub_5DF98(2, "src/rule.c", 922, "zc_arraylist_add fail");
            }
            else
            {
              sub_5DF98(2, "src/rule.c", 909, "zc_arraylist_new fail");
            }
          }
          goto LABEL_61;
        }
        goto LABEL_105;
      }
LABEL_106:
      v49 = v69;
      goto LABEL_90;
    }
    if ( v69[0] == 62 )
    {
      if ( !strncmp(&v69[1], "syslog", 6u) )
      {
        sub_5DF98(2, "src/rule.c", 477, "facility is null or 0");
        *((_DWORD *)v11 + 1565) = -187;
        sub_5DF98(2, "src/rule.c", 853, "-187 get");
        goto LABEL_61;
      }
LABEL_83:
      if ( !strncmp(&v69[1], "stdout", 6u) )
      {
        *((_DWORD *)v11 + 1567) = 368376;
        return v11;
      }
      if ( !strncmp(&v69[1], "stderr", 6u) )
      {
        *((_DWORD *)v11 + 1567) = 368212;
        return v11;
      }
      sub_5DF98(2, "src/rule.c", 864, "[%s]the string after is not syslog, stdout or stderr", v67);
      goto LABEL_61;
    }
    goto LABEL_76;
  }
  if ( v69[1] != 34 )
  {
    sub_5DF98(2, "src/rule.c", 751, " - must set before a file output");
    goto LABEL_61;
  }
  v49 = &v69[1];
  *((_DWORD *)v11 + 1035) = &unk_101000;
  *((_DWORD *)v11 + 1562) = 0;
LABEL_90:
  if ( sub_5A66C(v49, (char *)v11 + 4144, (_DWORD *)v11 + 1293, a7) )
  {
    sub_5DF98(2, "src/rule.c", 767, "zlog_rule_parse_path fail");
    goto LABEL_61;
  }
  if ( v32 )
  {
    memset(v70, 0, 0x1001u);
    if ( _isoc99_sscanf(v32, " %[0-9MmKkBb] * %d ~", v70, v11 + 5204) )
      *((_DWORD *)v11 + 1300) = sub_5E140(v70);
    v50 = strchr(v32, 34);
    if ( v50 )
    {
      if ( sub_5A66C(v50, (char *)v11 + 5208, (_DWORD *)v11 + 1559, a7) )
      {
        sub_5DF98(2, "src/rule.c", 784, "zlog_rule_parse_path fail");
        goto LABEL_61;
      }
      v51 = strchr((const char *)v11 + 5208, 35);
      v52 = v51;
      if ( !v51 || !strchr(v51, 114) && !strchr(v52, 115) )
      {
        sub_5DF98(2, "src/rule.c", 790, "archive_path must contain #r or #s");
        goto LABEL_61;
      }
    }
  }
  v53 = *((_DWORD *)v11 + 1300);
  if ( *((_DWORD *)v11 + 1293) )
  {
    if ( v53 > 0 )
      LOWORD(v54) = -23796;
    else
      LOWORD(v54) = -24364;
    HIWORD(v54) = 5;
    *((_DWORD *)v11 + 1567) = v54;
  }
  else
  {
    if ( v53 > 0 )
      LOWORD(v56) = -26100;
    else
      LOWORD(v56) = -26960;
    HIWORD(v56) = 5;
    *((_DWORD *)v11 + 1567) = v56;
    v57 = open64(v11 + 4144);
    *((_DWORD *)v11 + 1294) = v57;
    if ( v57 < 0 )
    {
      v60 = _errno_location();
      sub_5DF98(2, "src/rule.c", 817, "open file[%s] fail, errno[%d]", (const char *)v11 + 4144, *v60);
      goto LABEL_61;
    }
    if ( _fxstat64(3, v57, v63) )
    {
      v61 = _errno_location();
      sub_5DF98(
        2,
        "src/rule.c",
        823,
        "stat [%s] fail, errno[%d], failing to open static_fd",
        (const char *)v11 + 4144,
        *v61);
      goto LABEL_61;
    }
    if ( *((int *)v11 + 1300) > 0 )
    {
      close(*((_DWORD *)v11 + 1294));
      *((_DWORD *)v11 + 1294) = -1;
    }
    v58 = v63[12];
    *((_QWORD *)v11 + 648) = v63[0];
    *((_QWORD *)v11 + 649) = v58;
  }
  return v11;
}
// 5AC64: control flows out of bounds to 5AC68
// 5ABC8: variable 'v15' is possibly undefined
// 120E4: using guessed type int __fastcall _fxstat64(_DWORD, _DWORD, _DWORD);
// 12198: using guessed type int __fastcall open64(_DWORD);
// 1231C: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);

//----- (0005BABC) --------------------------------------------------------
int __fastcall sub_5BABC(int a1, int a2)
{
  int result; // r0

  switch ( *(_BYTE *)(a1 + 4097) )
  {
    case '!':
      if ( *(_DWORD *)(*(_DWORD *)(a2 + 8) + 292) == *(_DWORD *)(a1 + 4100) )
        goto LABEL_5;
      goto LABEL_3;
    case '*':
      goto LABEL_3;
    case '.':
      if ( *(_DWORD *)(*(_DWORD *)(a2 + 8) + 292) < *(_DWORD *)(a1 + 4100) )
        goto LABEL_5;
      result = (*(int (**)(void))(a1 + 6268))();
      break;
    case '=':
      if ( *(_DWORD *)(*(_DWORD *)(a2 + 8) + 292) != *(_DWORD *)(a1 + 4100) )
        goto LABEL_5;
LABEL_3:
      result = (*(int (__fastcall **)(int, int))(a1 + 6268))(a1, a2);
      break;
    default:
LABEL_5:
      result = 0;
      break;
  }
  return result;
}
// 5BAD0: control flows out of bounds to 5BAD4

//----- (0005BB9C) --------------------------------------------------------
int __fastcall sub_5BB9C(_BYTE *a1)
{
  if ( a1 )
  {
    return *a1 == 33 && a1[1] == 0;
  }
  else
  {
    sub_5DF98(2, "src/rule.c", 1002, "a_rule is null or 0");
    return -1;
  }
}

//----- (0005BBE8) --------------------------------------------------------
int __fastcall sub_5BBE8(int a1, char *s2)
{
  size_t v5; // r0
  size_t v6; // r7
  size_t v7; // r6
  size_t v8; // r0
  size_t v9; // r2

  if ( a1 )
  {
    if ( s2 )
    {
      if ( *(_BYTE *)a1 == 42 && !*(_BYTE *)(a1 + 1) || !strcmp((const char *)a1, s2) )
      {
        return 1;
      }
      else
      {
        v5 = strlen((const char *)a1);
        v6 = v5 - 1;
        v7 = v5;
        if ( *(_BYTE *)(a1 + v5 - 1) == 95 )
        {
          v8 = strlen(s2);
          if ( v6 == v8 )
            v9 = v8;
          else
            v9 = v7;
          return strncmp((const char *)a1, s2, v9) == 0;
        }
        else
        {
          return 0;
        }
      }
    }
    else
    {
      sub_5DF98(2, "src/rule.c", 1015, "category is null or 0");
      return -1;
    }
  }
  else
  {
    sub_5DF98(2, "src/rule.c", 1014, "a_rule is null or 0");
    return -1;
  }
}

//----- (0005BCCC) --------------------------------------------------------
int __fastcall sub_5BCCC(int a1, int a2)
{
  int (__fastcall *v2)(int, int); // r12
  bool v3; // zf
  int v6; // r0

  v2 = *(int (__fastcall **)(int, int))(a1 + 6268);
  v3 = v2 == sub_595C0;
  if ( v2 != sub_595C0 )
    v3 = v2 == sub_59CD4;
  if ( !v3 )
    return 0;
  v6 = sub_5DA58(a2, a1 + 6272);
  if ( v6 )
    *(_DWORD *)(a1 + 8324) = *(_DWORD *)(v6 + 1028);
  return 0;
}

//----- (0005BD24) --------------------------------------------------------
int __fastcall sub_5BD24(int a1, int a2)
{
  return (*(int (__fastcall **)(int, int, _DWORD))(a1 + 9252))(a1, a2, *(_DWORD *)(a2 + 28));
}

//----- (0005BD34) --------------------------------------------------------
int __fastcall sub_5BD34(int a1, int a2)
{
  return (*(int (__fastcall **)(int, int, _DWORD))(a1 + 9252))(a1, a2, *(_DWORD *)(a2 + 16));
}

//----- (0005BD44) --------------------------------------------------------
int __fastcall sub_5BD44(int a1, int a2)
{
  return (*(int (__fastcall **)(int, int, _DWORD))(a1 + 9252))(a1, a2, *(_DWORD *)(a2 + 20));
}

//----- (0005BD54) --------------------------------------------------------
int __fastcall sub_5BD54(int a1, int a2, int a3)
{
  return sub_5F0D4(a3, *(void **)a1, *(_DWORD *)(a1 + 4));
}

//----- (0005BD64) --------------------------------------------------------
int __fastcall sub_5BD64(int a1, int a2, int a3)
{
  return sub_5F0D4(a3, "%", 1u);
}

//----- (0005BD78) --------------------------------------------------------
int __fastcall sub_5BD78(int a1, int a2, int a3)
{
  return sub_5F0D4(a3, (void *)(*(_DWORD *)(a2 + 8) + 428), *(_DWORD *)(*(_DWORD *)(a2 + 8) + 460));
}

//----- (0005BD8C) --------------------------------------------------------
int __fastcall sub_5BD8C(int a1, int a2, int a3)
{
  return sub_5F0D4(a3, (void *)(*(_DWORD *)(a2 + 8) + 464), *(_DWORD *)(*(_DWORD *)(a2 + 8) + 496));
}

//----- (0005BDA0) --------------------------------------------------------
int __fastcall sub_5BDA0(int a1, int a2, int a3)
{
  return sub_5F0D4(a3, &word_6A02C, 1u);
}
// 6A02C: using guessed type __int16 word_6A02C;

//----- (0005BDB4) --------------------------------------------------------
int __fastcall sub_5BDB4(int a1, int a2, int a3)
{
  return sub_5F0D4(a3, (void *)(*(_DWORD *)(a2 + 8) + 504), *(_DWORD *)(*(_DWORD *)(a2 + 8) + 536));
}

//----- (0005BDC8) --------------------------------------------------------
int __fastcall sub_5BDC8(int a1, int a2, int a3)
{
  return sub_5F0D4(a3, (void *)(*(_DWORD *)(a2 + 8) + 8), *(_DWORD *)(*(_DWORD *)(a2 + 8) + 268));
}

//----- (0005BDDC) --------------------------------------------------------
int __fastcall sub_5BDDC(int a1, int a2, int a3)
{
  return sub_5F0D4(a3, **(void ***)(a2 + 8), *(_DWORD *)(*(_DWORD *)(a2 + 8) + 4));
}

//----- (0005BDEC) --------------------------------------------------------
int __fastcall sub_5BDEC(int a1, int a2, int a3)
{
  int v4; // r1

  v4 = sub_57D70(*(int **)(dword_99EEC8 + 9280), *(_DWORD *)(*(_DWORD *)(a2 + 8) + 292));
  return sub_5F0D4(a3, (void *)(v4 + 4), *(_DWORD *)(v4 + 2056));
}
// 99EEC8: using guessed type int dword_99EEC8;

//----- (0005BE2C) --------------------------------------------------------
int __fastcall sub_5BE2C(int a1, int a2, int a3)
{
  int v4; // r3

  v4 = sub_57D70(*(int **)(dword_99EEC8 + 9280), *(_DWORD *)(*(_DWORD *)(a2 + 8) + 292));
  return sub_5F0D4(a3, (void *)(v4 + 1029), *(_DWORD *)(v4 + 2056));
}
// 99EEC8: using guessed type int dword_99EEC8;

//----- (0005BE70) --------------------------------------------------------
int __fastcall sub_5BE70(int a1, int a2, int a3)
{
  char *v4; // r4
  int v6; // r2
  int v7; // r0
  int v8; // r4

  v4 = *(char **)(a2 + 8);
  if ( *((_DWORD *)v4 + 95) )
    return sub_5F0D4(a3, v4 + 388, *((_DWORD *)v4 + 105));
  *((_DWORD *)v4 + 95) = getpid();
  v4 = *(char **)(a2 + 8);
  v6 = *((_DWORD *)v4 + 95);
  if ( v6 == *((_DWORD *)v4 + 96) )
    return sub_5F0D4(a3, v4 + 388, *((_DWORD *)v4 + 105));
  *((_DWORD *)v4 + 96) = v6;
  v7 = sprintf(v4 + 388, "%u", v6);
  v8 = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(v8 + 420) = v7;
  return sub_5F0D4(a3, (void *)(v8 + 388), v7);
}

//----- (0005BEEC) --------------------------------------------------------
int __fastcall sub_5BEEC(int a1, int a2, int a3)
{
  return sub_5ED04(
           a3,
           *(_DWORD *)(a2 + 8),
           *(_DWORD *)(*(_DWORD *)(a2 + 8) + 288),
           *(int *)(*(_DWORD *)(a2 + 8) + 288) >> 31,
           0);
}

//----- (0005BF18) --------------------------------------------------------
int __fastcall sub_5BF18(int a1, int a2, int a3)
{
  int v3; // r3
  int v5; // r2
  char *v6; // r1
  int v10; // r12
  int v11; // r9
  int v12; // r1
  unsigned int v13; // r5
  unsigned int v14; // r11
  size_t v15; // r2
  char *v16; // r1
  int v17; // r0
  int v18; // r3
  char *v19; // r1
  int v20; // r0
  int v21; // r0
  int v22; // r0
  int v23; // r3
  int v24; // r3
  __int64 v25; // [sp+8h] [bp-40h]
  int v26; // [sp+14h] [bp-34h]
  unsigned __int8 v27; // [sp+1Fh] [bp-29h] BYREF

  v3 = *(_DWORD *)(a2 + 8);
  v5 = *(_DWORD *)(v3 + 312);
  if ( !v5 )
  {
    v6 = *(char **)(v3 + 304);
    if ( v6 )
      return sub_5E8DC(a3, v6, *(__gnuc_va_list *)(v3 + 308));
    return sub_5F0D4(a3, "format=(null)", 0xDu);
  }
  if ( v5 != 1 )
    return 0;
  if ( !*(_DWORD *)(v3 + 296) )
  {
    v22 = sub_5F0D4(a3, &unk_6D1F4, 0xAu);
    if ( v22 >= 0 )
    {
      if ( !v22 )
        return 0;
LABEL_24:
      sub_5DF98(2, "src/spec.c", 339, "write hex msg, buf is full");
      return 1;
    }
LABEL_35:
    sub_5DF98(2, "src/spec.c", 336, "write hex msg fail");
    return -1;
  }
  v10 = sub_5F0D4(a3, "\n             0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F    0123456789ABCDEF", 0x50u);
  if ( v10 )
  {
LABEL_23:
    if ( v10 >= 0 )
      goto LABEL_24;
    goto LABEL_35;
  }
  v11 = 16;
  v25 = 1LL;
  do
  {
    v10 = sub_5F0D4(a3, &word_6A02C, 1u);
    if ( v10 )
      goto LABEL_23;
    v10 = sub_5ED04(a3, v12, v25, SHIDWORD(v25), (char *)0xA);
    if ( v10 )
      goto LABEL_23;
    v10 = sub_5F0D4(a3, "   ", 3u);
    if ( v10 )
      goto LABEL_23;
    v13 = v11 - 16;
    v14 = v11 - 16;
    do
    {
      v18 = *(_DWORD *)(a2 + 8);
      v17 = a3;
      v16 = "   ";
      if ( *(_DWORD *)(v18 + 300) > v14 )
      {
        v27 = *(_BYTE *)(*(_DWORD *)(v18 + 296) + v14);
        v10 = sub_5EF24(a3, v27, (char *)2);
        v15 = 1;
        v16 = " ";
        v17 = a3;
        if ( v10 )
          goto LABEL_23;
      }
      else
      {
        v15 = 3;
      }
      v10 = sub_5F0D4(v17, v16, v15);
      if ( v10 )
        goto LABEL_23;
      ++v14;
    }
    while ( v14 != v11 );
    v26 = sub_5F0D4(a3, &dword_60DE4, 2u);
    if ( v26 )
    {
      v10 = v26;
      goto LABEL_23;
    }
    do
    {
      v23 = *(_DWORD *)(a2 + 8);
      if ( *(_DWORD *)(v23 + 300) <= v13 )
      {
        v19 = " ";
        v20 = a3;
LABEL_21:
        v21 = sub_5F0D4(v20, v19, 1u);
        if ( v21 )
          goto LABEL_22;
        goto LABEL_31;
      }
      v19 = (char *)&v27;
      v20 = a3;
      v24 = *(unsigned __int8 *)(*(_DWORD *)(v23 + 296) + v13);
      v27 = v24;
      if ( (unsigned int)(v24 - 32) <= 0x5E )
        goto LABEL_21;
      v21 = sub_5F0D4(a3, ".", 1u);
      if ( v21 )
      {
LABEL_22:
        v10 = v21;
        goto LABEL_23;
      }
LABEL_31:
      ++v13;
    }
    while ( v14 != v13 );
    v11 += 16;
    ++v25;
  }
  while ( v14 < *(_DWORD *)(*(_DWORD *)(a2 + 8) + 300) );
  return 0;
}
// 5BFF8: variable 'v12' is possibly undefined
// 60DE4: using guessed type int dword_60DE4;
// 6A02C: using guessed type __int16 word_6A02C;

//----- (0005C204) --------------------------------------------------------
int __fastcall sub_5C204(int a1, int a2, int a3)
{
  int v4; // r5
  const char *v5; // r4
  char *v6; // r0
  size_t v7; // r2
  char *v8; // r1
  int v9; // r2
  int v10; // r0

  v4 = *(_DWORD *)(a2 + 8);
  v5 = *(const char **)(v4 + 272);
  v6 = strrchr(v5, 47);
  v7 = *(_DWORD *)(v4 + 276);
  if ( v6 )
  {
    v8 = v6 + 1;
    v9 = &v5[v7] - v6;
    v10 = a3;
    v7 = v9 - 1;
  }
  else
  {
    v8 = (char *)v5;
    v10 = a3;
  }
  return sub_5F0D4(v10, v8, v7);
}

//----- (0005C258) --------------------------------------------------------
int __fastcall sub_5C258(int a1, int a2, int a3)
{
  int v3; // r0

  v3 = *(_DWORD *)(a2 + 8);
  if ( !*(_DWORD *)(v3 + 316) )
  {
    gettimeofday((struct timeval *)(v3 + 316), 0);
    v3 = *(_DWORD *)(a2 + 8);
  }
  return sub_5EB48(a3, *(_DWORD *)(v3 + 320), (char *)6);
}

//----- (0005C294) --------------------------------------------------------
int __fastcall sub_5C294(int a1, int a2, int a3)
{
  int v3; // r0

  v3 = *(_DWORD *)(a2 + 8);
  if ( !*(_DWORD *)(v3 + 316) )
  {
    gettimeofday((struct timeval *)(v3 + 316), 0);
    v3 = *(_DWORD *)(a2 + 8);
  }
  return sub_5EB48(a3, *(_DWORD *)(v3 + 320) / 1000, (char *)3);
}

//----- (0005C2E4) --------------------------------------------------------
int __fastcall sub_5C2E4(int a1, int a2, int a3)
{
  const char *v3; // r4
  int v5; // r5

  v3 = (const char *)(a1 + 4112);
  v5 = sub_581FC(*(int **)(a2 + 4), a1 + 4112);
  if ( v5 )
    return sub_5F0D4(a3, (void *)(v5 + 1025), *(_DWORD *)(v5 + 2052));
  sub_5DF98(2, "src/spec.c", 123, "zlog_mdc_get_kv key[%s] fail", v3);
  return 0;
}

//----- (0005C358) --------------------------------------------------------
int __fastcall sub_5C358(int a1, int a2, int a3)
{
  int v4; // r0
  int v6; // r4
  time_t v7; // r1
  int v9; // r3
  struct tm *v10; // r8
  int v11; // r4
  size_t v12; // r0
  size_t v13; // r2
  time_t timer; // [sp+4h] [bp-1Ch] BYREF

  v4 = *(_DWORD *)(a2 + 8);
  v6 = *(_DWORD *)(a1 + 4108);
  v9 = *(_DWORD *)(v4 + 372);
  v10 = (struct tm *)(v4 + 328);
  timer = *(_DWORD *)(v4 + 316);
  v7 = timer;
  v11 = v9 + 4108 * v6;
  if ( !timer )
  {
    gettimeofday((struct timeval *)(v4 + 316), 0);
    v4 = *(_DWORD *)(a2 + 8);
    v7 = *(_DWORD *)(v4 + 316);
    timer = v7;
  }
  if ( *(_DWORD *)(v4 + 324) != v7 )
  {
    localtime_r(&timer, v10);
    v7 = timer;
    *(_DWORD *)(*(_DWORD *)(a2 + 8) + 324) = timer;
  }
  if ( *(_DWORD *)(v11 + 4104) == v7 )
  {
    v13 = *(_DWORD *)(v11 + 4100);
  }
  else
  {
    v12 = strftime((char *)v11, 0x1001u, (const char *)(a1 + 8), v10);
    v13 = v12;
    *(_QWORD *)(v11 + 4100) = __PAIR64__(timer, v12);
  }
  return sub_5F0D4(a3, (void *)v11, v13);
}

//----- (0005C420) --------------------------------------------------------
int __fastcall sub_5C420(int a1, int a2, int a3)
{
  int v3; // r3

  v3 = *(_DWORD *)(a2 + 8);
  if ( *(_DWORD *)(v3 + 272) )
    return sub_5F0D4(a3, *(void **)(v3 + 280), *(_DWORD *)(v3 + 284));
  else
    return sub_5F0D4(a3, "(func=null)", 0xBu);
}

//----- (0005C454) --------------------------------------------------------
int __fastcall sub_5C454(int a1, int a2, int a3)
{
  int v3; // r3
  char *v5; // r1
  size_t v6; // r2

  v3 = *(_DWORD *)(a2 + 8);
  v5 = *(char **)(v3 + 272);
  if ( v5 )
  {
    v6 = *(_DWORD *)(v3 + 276);
  }
  else
  {
    v5 = "(file=null)";
    v6 = 11;
  }
  return sub_5F0D4(a3, v5, v6);
}

//----- (0005C480) --------------------------------------------------------
int __fastcall sub_5C480(int a1, int a2)
{
  int v2; // r4
  int (*v3)(void); // r6

  v2 = a1 + 0x2000;
  v3 = *(int (**)(void))(a1 + 9252);
  *(_DWORD *)(*(_DWORD *)(a2 + 12) + 4) = **(_DWORD **)(a2 + 12);
  if ( v3() >= 0 )
    return sub_5F1CC(
             *(_DWORD *)(a2 + 20),
             **(void ***)(a2 + 12),
             *(_DWORD *)(*(_DWORD *)(a2 + 12) + 4) - **(_DWORD **)(a2 + 12),
             *(_DWORD *)(v2 + 1044),
             *(_DWORD *)(v2 + 1048),
             *(_DWORD *)(v2 + 1056),
             *(_DWORD *)(v2 + 1052));
  sub_5DF98(2, "src/spec.c", 418, "a_spec->gen_buf fail");
  return -1;
}

//----- (0005C510) --------------------------------------------------------
int __fastcall sub_5C510(int a1, int a2)
{
  int v2; // r4
  int (*v3)(void); // r6

  v2 = a1 + 0x2000;
  v3 = *(int (**)(void))(a1 + 9252);
  *(_DWORD *)(*(_DWORD *)(a2 + 12) + 4) = **(_DWORD **)(a2 + 12);
  if ( v3() >= 0 )
    return sub_5F1CC(
             *(_DWORD *)(a2 + 16),
             **(void ***)(a2 + 12),
             *(_DWORD *)(*(_DWORD *)(a2 + 12) + 4) - **(_DWORD **)(a2 + 12),
             *(_DWORD *)(v2 + 1044),
             *(_DWORD *)(v2 + 1048),
             *(_DWORD *)(v2 + 1056),
             *(_DWORD *)(v2 + 1052));
  sub_5DF98(2, "src/spec.c", 392, "a_spec->gen_buf fail");
  return -1;
}

//----- (0005C5A0) --------------------------------------------------------
int __fastcall sub_5C5A0(int a1, int a2)
{
  int v2; // r4
  int (*v3)(void); // r6

  v2 = a1 + 0x2000;
  v3 = *(int (**)(void))(a1 + 9252);
  *(_DWORD *)(*(_DWORD *)(a2 + 24) + 4) = **(_DWORD **)(a2 + 24);
  if ( v3() >= 0 )
    return sub_5F1CC(
             *(_DWORD *)(a2 + 28),
             **(void ***)(a2 + 24),
             *(_DWORD *)(*(_DWORD *)(a2 + 24) + 4) - **(_DWORD **)(a2 + 24),
             *(_DWORD *)(v2 + 1044),
             *(_DWORD *)(v2 + 1048),
             *(_DWORD *)(v2 + 1056),
             *(_DWORD *)(v2 + 1052));
  sub_5DF98(2, "src/spec.c", 366, "a_spec->gen_buf fail");
  return -1;
}

//----- (0005C630) --------------------------------------------------------
int __fastcall sub_5C630(const char **a1, int a2)
{
  const char *v2; // r3

  if ( !a1 )
    return sub_5DF98(2, "src/spec.c", 34, "a_spec is null or 0");
  v2 = "true";
  if ( !a1[2310] )
    v2 = "false";
  return sub_5DF98(
           a2,
           "src/spec.c",
           41,
           "----spec[%p][%.*s][%s|%d][%s,%ld,%ld,%s][%s]----",
           a1,
           (int)a1[1],
           *a1,
           (const char *)a1 + 8,
           a1[1027],
           (const char *)a1 + 5137,
           a1[2311],
           a1[2312],
           v2,
           (const char *)a1 + 4112);
}

//----- (0005C6F4) --------------------------------------------------------
void __fastcall sub_5C6F4(void *a1)
{
  if ( a1 )
  {
    sub_5DF98(0, "src/spec.c", 461, "zlog_spec_del[%p]", a1);
    free(a1);
  }
  else
  {
    sub_5DF98(2, "src/spec.c", 460, "a_spec is null or 0");
  }
}

//----- (0005C758) --------------------------------------------------------
const char **__fastcall sub_5C758(const char *a1, char **a2, const char **a3)
{
  _DWORD *v6; // r0
  const char **v7; // r4
  int v8; // r3
  char *v9; // r0
  const char *v11; // r10
  const char **v12; // r7
  int v13; // r0
  int v14; // r3
  char *v15; // r5
  int v16; // r0
  const char *v17; // r9
  char *v18; // r5
  size_t v19; // r0
  const char *v20; // r2
  const char *v21; // r3
  char *v22; // r5
  int v23; // r3
  char *v24; // r0
  int v25; // r3
  int v26; // r0
  int v27; // r3
  const char **v28; // r0
  int v29; // r2
  const char *v30; // r12
  int *v31; // r0
  int v32; // [sp+Ch] [bp-2Ch] BYREF
  const char *v33; // [sp+10h] [bp-28h] BYREF
  int v34; // [sp+14h] [bp-24h] BYREF

  v32 = 0;
  if ( !a1 )
  {
    v7 = 0;
    sub_5DF98(2, "src/spec.c", 476, "pattern_start is null or 0");
    return v7;
  }
  if ( !a2 )
  {
    v7 = 0;
    sub_5DF98(2, "src/spec.c", 477, "pattern_next is null or 0");
    return v7;
  }
  v6 = calloc(1u, 0x2434u);
  v7 = (const char **)v6;
  if ( !v6 )
  {
    v31 = _errno_location();
    sub_5DF98(2, "src/spec.c", 481, "calloc fail, errno[%d]", *v31);
    return v7;
  }
  v8 = *(unsigned __int8 *)a1;
  *v6 = a1;
  if ( v8 != 37 )
  {
    v9 = strchr(a1, 37);
    *a2 = v9;
    if ( v9 )
    {
      v7[1] = (const char *)(v9 - a1);
    }
    else
    {
      v19 = strlen(a1);
      v7[1] = (const char *)v19;
      *a2 = (char *)&a1[v19];
    }
    v7[2313] = (const char *)sub_5BD54;
    v7[2314] = (const char *)sub_5BD24;
    v7[2315] = (const char *)sub_5BD34;
    v7[2316] = (const char *)sub_5BD44;
    goto LABEL_8;
  }
  v11 = (char *)v6 + 5137;
  v32 = 0;
  if ( _isoc99_sscanf(a1, "%%%[.0-9-]%n", (char *)v6 + 5137, &v32) == 1 )
  {
    v12 = v7 + 2048;
    v7[2314] = (const char *)sub_5C5A0;
    v7[2315] = (_BYTE *)sub_5C510;
    v7[2316] = (const char *)sub_5C480;
    v23 = *((unsigned __int8 *)v7 + 5137);
    if ( v23 == 45 )
    {
      v7[2309] = (const char *)1;
      v11 = (char *)v7 + 5138;
    }
    else
    {
      if ( v23 == 48 )
        v7[2310] = (const char *)1;
      v7[2309] = 0;
    }
    v33 = 0;
    v34 = 0;
    _isoc99_sscanf(v11, "%ld.", &v33);
    v24 = strchr(v11, 46);
    if ( v24 )
      _isoc99_sscanf(v24, ".%ld", &v34);
    v25 = v34;
    v13 = v32;
    v7[2312] = v33;
    v7[2311] = (const char *)v25;
  }
  else
  {
    v12 = v7 + 2048;
    v7[2314] = (const char *)sub_5BD24;
    v13 = 1;
    v7[2315] = (const char *)sub_5BD34;
    v7[2316] = (const char *)sub_5BD44;
    v32 = 1;
  }
  v14 = (unsigned __int8)a1[v13];
  v15 = (char *)&a1[v13];
  if ( v14 != 100 )
  {
    if ( v14 != 77 )
    {
      v16 = strncmp(v15, "ms", 2u);
      v17 = *v7;
      if ( v16 )
      {
        if ( strncmp(v15, "us", 2u) )
        {
          *a2 = v15 + 1;
          v29 = (unsigned __int8)*v15;
          v7[1] = (const char *)(v15 - v17 + 1);
          switch ( v29 )
          {
            case '%':
              v12[265] = (_BYTE *)sub_5BD64;
              goto LABEL_8;
            case 'D':
              v30 = *a3;
              strcpy((char *)v7 + 8, "%F %T");
              *a3 = v30 + 1;
              v7[1027] = v30;
              v12[265] = (const char *)sub_5C358;
              goto LABEL_8;
            case 'F':
              v12[265] = (_BYTE *)sub_5C454;
              goto LABEL_8;
            case 'H':
              v12[265] = (_BYTE *)sub_5BDC8;
              goto LABEL_8;
            case 'L':
              v12[265] = (_BYTE *)sub_5BEEC;
              goto LABEL_8;
            case 'T':
              v12[265] = (_BYTE *)sub_5BD78;
              goto LABEL_8;
            case 'U':
              v12[265] = (_BYTE *)sub_5C420;
              goto LABEL_8;
            case 'V':
              v12[265] = (_BYTE *)sub_5BDEC;
              goto LABEL_8;
            case 'c':
              v12[265] = (_BYTE *)sub_5BDDC;
              goto LABEL_8;
            case 'f':
              v12[265] = (_BYTE *)sub_5C204;
              goto LABEL_8;
            case 'k':
              v12[265] = (_BYTE *)sub_5BDB4;
              goto LABEL_8;
            case 'm':
              v12[265] = (_BYTE *)sub_5BF18;
              goto LABEL_8;
            case 'n':
              v12[265] = (_BYTE *)sub_5BDA0;
              goto LABEL_8;
            case 'p':
              v12[265] = (_BYTE *)sub_5BE70;
              goto LABEL_8;
            case 't':
              v12[265] = (_BYTE *)sub_5BD8C;
              goto LABEL_8;
            case 'v':
              v12[265] = (_BYTE *)sub_5BE2C;
              goto LABEL_8;
            default:
              sub_5DF98(2, "src/spec.c", 634, "str[%s] in wrong format, p[%c]", v17, v29);
              goto LABEL_38;
          }
        }
        v22 = v15 + 2;
        v7[1] = (const char *)(v22 - v17);
        *a2 = v22;
        v12[265] = (const char *)sub_5C258;
      }
      else
      {
        v18 = v15 + 2;
        v7[1] = (const char *)(v18 - v17);
        *a2 = v18;
        v12[265] = (const char *)sub_5C294;
      }
      goto LABEL_8;
    }
    v32 = 0;
    if ( _isoc99_sscanf(v15, "M(%[^)])%n", v7 + 1028, &v32) == 1 )
    {
      v15 += v32;
    }
    else
    {
      v32 = 0;
      if ( !strncmp(v15, "M()", 3u) )
      {
        v15 += 3;
        v32 = 3;
      }
    }
    if ( *(v15 - 1) == 41 )
    {
      v7[1] = (const char *)(v15 - *v7);
      *a2 = v15;
      v12[265] = (const char *)sub_5C2E4;
      goto LABEL_8;
    }
    sub_5DF98(2, "src/spec.c", 554, "in string[%s] can't find match ')'", *v7);
LABEL_38:
    v28 = v7;
    v7 = 0;
    sub_5C6F4(v28);
    return v7;
  }
  if ( v15[1] == 40 )
  {
    if ( !strncmp(v15, "d()", 3u) )
    {
      v15 += 3;
      strcpy((char *)v7 + 8, "%F %T");
      v20 = *v7;
    }
    else
    {
      v32 = 0;
      v26 = _isoc99_sscanf(v15, "d(%[^)])%n", v7 + 2, &v32);
      v20 = *v7;
      if ( v26 == 1 )
        v27 = v32;
      else
        v32 = 0;
      if ( v26 == 1 )
        v15 += v27;
      if ( *(v15 - 1) != 41 )
      {
        sub_5DF98(2, "src/spec.c", 529, "in string[%s] can't find match ')'", v20);
        goto LABEL_38;
      }
    }
  }
  else
  {
    ++v15;
    strcpy((char *)v7 + 8, "%F %T");
    v20 = *v7;
  }
  v21 = *a3;
  v7[1027] = *a3;
  *a3 = v21 + 1;
  v12[265] = (const char *)sub_5C358;
  *a2 = v15;
  v7[1] = (const char *)(v15 - v20);
LABEL_8:
  sub_5C630(v7, 0);
  return v7;
}
// 5CADC: control flows out of bounds to 5CAE0
// 5CA78: variable 'v27' is possibly undefined
// 1231C: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);

//----- (0005CEC0) --------------------------------------------------------
int __fastcall sub_5CEC0(int a1, int a2)
{
  if ( !a1 )
    return sub_5DF98(2, "src/thread.c", 20, "a_thread is null or 0");
  sub_5DF98(
    a2,
    "src/thread.c",
    29,
    "--thread[%p][%p][%p][%p,%p,%p,%p,%p]--",
    (const void *)a1,
    *(const void **)(a1 + 4),
    *(const void **)(a1 + 8),
    *(const void **)(a1 + 12),
    *(const void **)(a1 + 16),
    *(const void **)(a1 + 20),
    *(const void **)(a1 + 24),
    *(const void **)(a1 + 28));
  sub_57ED4(*(int **)(a1 + 4), a2);
  sub_5729C(*(const char ***)(a1 + 8), a2);
  sub_5E6A4(*(const void ***)(a1 + 12), a2);
  sub_5E6A4(*(const void ***)(a1 + 16), a2);
  sub_5E6A4(*(const void ***)(a1 + 20), a2);
  sub_5E6A4(*(const void ***)(a1 + 24), a2);
  return sub_5E6A4(*(const void ***)(a1 + 28), a2);
}

//----- (0005CFA8) --------------------------------------------------------
void __fastcall sub_5CFA8(_DWORD *a1)
{
  _DWORD **v2; // r0
  _DWORD *v3; // r0
  void **v4; // r0
  void **v5; // r0
  void **v6; // r0
  void **v7; // r0
  void **v8; // r0

  if ( a1 )
  {
    v2 = (_DWORD **)a1[1];
    if ( v2 )
      sub_57F94(v2);
    v3 = (_DWORD *)a1[2];
    if ( v3 )
      sub_57364(v3);
    v4 = (void **)a1[3];
    if ( v4 )
      sub_5E70C(v4);
    v5 = (void **)a1[4];
    if ( v5 )
      sub_5E70C(v5);
    v6 = (void **)a1[5];
    if ( v6 )
      sub_5E70C(v6);
    v7 = (void **)a1[6];
    if ( v7 )
      sub_5E70C(v7);
    v8 = (void **)a1[7];
    if ( v8 )
      sub_5E70C(v8);
    sub_5DF98(0, "src/thread.c", 59, "zlog_thread_del[%p]", a1);
    free(a1);
  }
  else
  {
    sub_5DF98(2, "src/thread.c", 43, "a_thread is null or 0");
  }
}

//----- (0005D07C) --------------------------------------------------------
_DWORD *__fastcall sub_5D07C(int a1, size_t a2, unsigned int a3, size_t a4)
{
  _DWORD *v8; // r0
  _DWORD *v9; // r4
  _DWORD *v10; // r0
  void *v11; // r0
  void **v12; // r0
  void **v13; // r0
  void **v14; // r0
  void **v15; // r0
  void **v16; // r0
  int *v18; // r0

  v8 = calloc(1u, 0x20u);
  v9 = v8;
  if ( !v8 )
  {
    v18 = _errno_location();
    sub_5DF98(2, "src/thread.c", 70, "calloc fail, errno[%d]", *v18);
    return v9;
  }
  *v8 = a1;
  v10 = sub_58008();
  v9[1] = v10;
  if ( v10 )
  {
    v11 = sub_573D8(a4);
    v9[2] = v11;
    if ( v11 )
    {
      v12 = sub_5E758(0x401u, 0x401u, 0);
      v9[3] = v12;
      if ( v12 )
      {
        v13 = sub_5E758(0x401u, 0x401u, 0);
        v9[4] = v13;
        if ( v13 )
        {
          v14 = sub_5E758(0x401u, 0x401u, 0);
          v9[5] = v14;
          if ( v14 )
          {
            v15 = sub_5E758(a2, a3, "...\n");
            v9[6] = v15;
            if ( v15 )
            {
              v16 = sub_5E758(a2, a3, "...\n");
              v9[7] = v16;
              if ( v16 )
                return v9;
              sub_5DF98(2, "src/thread.c", 114, "zlog_buf_new fail");
            }
            else
            {
              sub_5DF98(2, "src/thread.c", 108, "zlog_buf_new fail");
            }
          }
          else
          {
            sub_5DF98(2, "src/thread.c", 102, "zlog_buf_new fail");
          }
        }
        else
        {
          sub_5DF98(2, "src/thread.c", 96, "zlog_buf_new fail");
        }
      }
      else
      {
        sub_5DF98(2, "src/thread.c", 90, "zlog_buf_new fail");
      }
    }
    else
    {
      sub_5DF98(2, "src/thread.c", 84, "zlog_event_new fail");
    }
  }
  else
  {
    sub_5DF98(2, "src/thread.c", 78, "zlog_mdc_new fail");
  }
  sub_5CFA8(v9);
  return 0;
}

//----- (0005D290) --------------------------------------------------------
int __fastcall sub_5D290(int a1, size_t a2, unsigned int arg)
{
  int v4; // r3
  void **v7; // r7
  void **v8; // r5
  void **v9; // r0
  int result; // r0

  if ( a1 )
  {
    v4 = *(_DWORD *)(a1 + 28);
    if ( *(_DWORD *)(v4 + 16) == a2 && *(_DWORD *)(v4 + 20) == arg )
    {
      sub_5DF98(0, "src/thread.c", 135, "buf size not changed, no need rebuild");
      return 0;
    }
    else
    {
      v7 = sub_5E758(a2, arg, "...\n");
      if ( v7 )
      {
        v8 = sub_5E758(a2, arg, "...\n");
        if ( v8 )
        {
          sub_5E70C(*(void ***)(a1 + 24));
          v9 = *(void ***)(a1 + 28);
          *(_DWORD *)(a1 + 24) = v7;
          sub_5E70C(v9);
          result = 0;
          *(_DWORD *)(a1 + 28) = v8;
        }
        else
        {
          sub_5DF98(2, "src/thread.c", 147, "zlog_buf_new fail");
          sub_5E70C(v7);
          return -1;
        }
      }
      else
      {
        sub_5DF98(2, "src/thread.c", 141, "zlog_buf_new fail");
        return -1;
      }
    }
  }
  else
  {
    sub_5DF98(2, "src/thread.c", 131, "a_thread is null or 0");
    return -1;
  }
  return result;
}

//----- (0005D3B0) --------------------------------------------------------
int __fastcall sub_5D3B0(int a1, size_t a2)
{
  void *v3; // r5
  int result; // r0

  if ( a1 )
  {
    v3 = sub_573D8(a2);
    if ( v3 )
    {
      sub_57364(*(_DWORD **)(a1 + 8));
      result = 0;
      *(_DWORD *)(a1 + 8) = v3;
    }
    else
    {
      sub_5DF98(2, "src/thread.c", 171, "zlog_event_new fail");
      return -1;
    }
  }
  else
  {
    sub_5DF98(2, "src/thread.c", 167, "a_thread is null or 0");
    return -1;
  }
  return result;
}

//----- (0005D428) --------------------------------------------------------
int __fastcall sub_5D428(void **a1, int *a2, int a3)
{
  void *v5; // r0
  int v6; // r4
  char *v7; // r0
  int v8; // r3
  int result; // r0
  int *v10; // r0

  v5 = *a1;
  v6 = 2 * *a2;
  if ( v6 < a3 )
    v6 = a3;
  v7 = (char *)realloc(v5, 4 * v6);
  if ( v7 )
  {
    v8 = *a2;
    *a1 = v7;
    if ( v6 != v8 )
      memset(&v7[4 * v8], 0, 4 * (v6 - v8));
    result = 0;
    *a2 = v6;
  }
  else
  {
    v10 = _errno_location();
    sub_5DF98(2, "src/zc_arraylist.c", 67, "realloc fail, errno[%d]", *v10);
    return -1;
  }
  return result;
}

//----- (0005D4C0) --------------------------------------------------------
_DWORD *__fastcall sub_5D4C0(int a1)
{
  _DWORD *v2; // r0
  _DWORD *v3; // r4
  void *v4; // r5
  int *v6; // r0
  int *v7; // r0
  void *v8; // r0

  v2 = calloc(1u, 0x10u);
  v3 = v2;
  if ( v2 )
  {
    v2[3] = a1;
    v2[2] = 32;
    v2[1] = 0;
    v4 = calloc(0x20u, 4u);
    *v3 = v4;
    if ( !v4 )
    {
      v7 = _errno_location();
      sub_5DF98(2, "src/zc_arraylist.c", 32, "calloc fail, errno[%d]", *v7);
      v8 = v3;
      v3 = 0;
      free(v8);
    }
  }
  else
  {
    v6 = _errno_location();
    sub_5DF98(2, "src/zc_arraylist.c", 22, "calloc fail, errno[%d]", *v6);
  }
  return v3;
}

//----- (0005D580) --------------------------------------------------------
void __fastcall sub_5D580(_DWORD *a1)
{
  _DWORD *v2; // r2
  int v3; // r1
  int i; // r5
  int v5; // r3

  if ( a1 )
  {
    v2 = (_DWORD *)*a1;
    if ( a1[3] )
    {
      v3 = a1[1];
      if ( v3 > 0 )
      {
        for ( i = 0; i < v3; ++i )
        {
          v5 = v2[i];
          if ( v5 )
          {
            ((void (__fastcall *)(int))a1[3])(v5);
            v2 = (_DWORD *)*a1;
            v3 = a1[1];
          }
        }
      }
    }
    if ( v2 )
      free(v2);
    free(a1);
  }
}

//----- (0005D5F0) --------------------------------------------------------
int __fastcall sub_5D5F0(int a1, int a2, int a3)
{
  int *v6; // r3
  void (*v7)(void); // r2
  int v8; // r2
  int result; // r0

  if ( *(_DWORD *)(a1 + 8) <= a2 && sub_5D428((void **)a1, (int *)(a1 + 8), a2) )
  {
    sub_5DF98(2, "src/zc_arraylist.c", 81, "expand_internal fail");
    return -1;
  }
  else
  {
    v6 = (int *)(*(_DWORD *)a1 + 4 * a2);
    if ( *v6 )
    {
      v7 = *(void (**)(void))(a1 + 12);
      if ( v7 )
      {
        v7();
        v6 = (int *)(*(_DWORD *)a1 + 4 * a2);
      }
    }
    v8 = *(_DWORD *)(a1 + 4);
    *v6 = a3;
    result = 0;
    if ( v8 <= a2 )
      *(_DWORD *)(a1 + 4) = a2 + 1;
  }
  return result;
}

//----- (0005D694) --------------------------------------------------------
int __fastcall sub_5D694(int a1, int a2)
{
  return sub_5D5F0(a1, *(_DWORD *)(a1 + 4), a2);
}

//----- (0005D6A0) --------------------------------------------------------
int __fastcall sub_5D6A0(int a1, int (__fastcall *a2)(_DWORD, int), int a3)
{
  int v3; // r3
  int v7; // r4
  int i; // r0
  _DWORD *v9; // r12
  int v10; // r7
  int result; // r0
  const void *v12; // r1
  int v13; // r3

  v3 = *(_DWORD *)(a1 + 4);
  if ( v3 <= 0 )
  {
    v7 = 0;
  }
  else
  {
    v7 = 0;
    for ( i = a2(**(_DWORD **)a1, a3); ; i = a2(*(_DWORD *)(*(_DWORD *)a1 + 4 * v7), a3) )
    {
      v3 = *(_DWORD *)(a1 + 4);
      if ( i > 0 )
        break;
      if ( v3 <= ++v7 )
        break;
    }
  }
  if ( v7 == v3 )
    return sub_5D5F0(a1, v7, a3);
  v9 = *(_DWORD **)a1;
  v10 = v7;
  result = *(_DWORD *)(*(_DWORD *)a1 + 4 * v7);
  v12 = (const void *)(*(_DWORD *)a1 + 4 * v7);
  if ( result )
  {
    if ( *(_DWORD *)(a1 + 8) > v3 )
    {
LABEL_11:
      memmove(&v9[v10 + 1], v12, 4 * (v3 - v7));
      result = 0;
      v13 = *(_DWORD *)(a1 + 4) + 1;
      *(_DWORD *)(*(_DWORD *)a1 + 4 * v7) = a3;
      *(_DWORD *)(a1 + 4) = v13;
      return result;
    }
    if ( !sub_5D428((void **)a1, (int *)(a1 + 8), 0) )
    {
      v9 = *(_DWORD **)a1;
      v3 = *(_DWORD *)(a1 + 4);
      v12 = (const void *)(*(_DWORD *)a1 + v10 * 4);
      goto LABEL_11;
    }
    sub_5DF98(2, "src/zc_arraylist.c", 107, "expand_internal fail");
    return -1;
  }
  else
  {
    v9[v7] = a3;
  }
  return result;
}

//----- (0005D7B8) --------------------------------------------------------
_DWORD *__fastcall sub_5D7B8(size_t a1, int a2, int a3, int a4, int a5)
{
  _DWORD *v9; // r4
  void *v10; // r6
  int *v12; // r0
  int *v13; // r0
  void *v14; // r0

  v9 = calloc(1u, 0x1Cu);
  if ( v9 )
  {
    v10 = calloc(a1, 4u);
    v9[1] = v10;
    if ( v10 )
    {
      v9[2] = a1;
      v9[3] = a2;
      v9[4] = a3;
      v9[5] = a4;
      v9[6] = a5;
      *v9 = 0;
    }
    else
    {
      v13 = _errno_location();
      sub_5DF98(2, "src/zc_hashtable.c", 44, "calloc fail, errno[%d]", *v13);
      v14 = v9;
      v9 = 0;
      free(v14);
    }
  }
  else
  {
    v12 = _errno_location();
    sub_5DF98(2, "src/zc_hashtable.c", 38, "calloc fail, errno[%d]", *v12);
  }
  return v9;
}

//----- (0005D890) --------------------------------------------------------
void __fastcall sub_5D890(_DWORD *a1)
{
  _DWORD *v2; // r0
  unsigned int v3; // r3
  unsigned int i; // r7
  _DWORD *v5; // r4
  void (__fastcall *v6)(_DWORD); // r3
  _DWORD *v7; // r6
  void (__fastcall *v8)(_DWORD); // r3
  void *v9; // r0

  if ( a1 )
  {
    v2 = (_DWORD *)a1[1];
    v3 = a1[2];
    if ( v3 )
    {
      for ( i = 0; i < v3; ++i )
      {
        v5 = (_DWORD *)v2[i];
        if ( v5 )
        {
          do
          {
            v6 = (void (__fastcall *)(_DWORD))a1[5];
            v7 = (_DWORD *)v5[4];
            if ( v6 )
              v6(v5[1]);
            v8 = (void (__fastcall *)(_DWORD))a1[6];
            if ( v8 )
              v8(v5[2]);
            v9 = v5;
            v5 = v7;
            free(v9);
          }
          while ( v7 );
          v2 = (_DWORD *)a1[1];
          v3 = a1[2];
        }
      }
    }
    if ( v2 )
      free(v2);
    free(a1);
  }
  else
  {
    sub_5DF98(2, "src/zc_hashtable.c", 68, "a_table[%p] is NULL, just do nothing", 0);
  }
}

//----- (0005D950) --------------------------------------------------------
_DWORD *__fastcall sub_5D950(_DWORD *result)
{
  unsigned int v1; // r1
  _DWORD *v2; // r5
  int v3; // r3
  unsigned int i; // r7
  _DWORD *v5; // r4
  _DWORD *v6; // r2
  void (__fastcall *v7)(_DWORD); // r3
  _DWORD *v8; // r6
  void (__fastcall *v9)(_DWORD); // r3
  void *v10; // r0

  v1 = result[2];
  v2 = result;
  if ( v1 )
  {
    v3 = result[1];
    for ( i = 0; i < v1; ++i )
    {
      v5 = *(_DWORD **)(v3 + 4 * i);
      v6 = (_DWORD *)(v3 + 4 * i);
      if ( v5 )
      {
        do
        {
          v7 = (void (__fastcall *)(_DWORD))v2[5];
          v8 = (_DWORD *)v5[4];
          if ( v7 )
            v7(v5[1]);
          v9 = (void (__fastcall *)(_DWORD))v2[6];
          if ( v9 )
            v9(v5[2]);
          v10 = v5;
          v5 = v8;
          free(v10);
        }
        while ( v8 );
        v3 = v2[1];
        v1 = v2[2];
        v6 = (_DWORD *)(v3 + 4 * i);
      }
      *v6 = 0;
    }
  }
  *v2 = 0;
  return result;
}

//----- (0005D9EC) --------------------------------------------------------
int __fastcall sub_5D9EC(int a1, int a2)
{
  unsigned int v4; // r0
  int v5; // r1
  int v6; // r4

  v4 = (*(int (__fastcall **)(int))(a1 + 12))(a2);
  sub_5FADC(v4, *(_DWORD *)(a1 + 8));
  v6 = *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4 * v5);
  if ( !v6 )
    return 0;
  while ( !(*(int (__fastcall **)(int, _DWORD))(a1 + 16))(a2, *(_DWORD *)(v6 + 4)) )
  {
    v6 = *(_DWORD *)(v6 + 16);
    if ( !v6 )
      return 0;
  }
  return v6;
}
// 5DA10: variable 'v5' is possibly undefined

//----- (0005DA58) --------------------------------------------------------
int __fastcall sub_5DA58(int a1, int a2)
{
  unsigned int v4; // r0
  int v5; // r1
  _DWORD *v6; // r4

  v4 = (*(int (__fastcall **)(int))(a1 + 12))(a2);
  sub_5FADC(v4, *(_DWORD *)(a1 + 8));
  v6 = *(_DWORD **)(*(_DWORD *)(a1 + 4) + 4 * v5);
  if ( !v6 )
    return 0;
  while ( !(*(int (__fastcall **)(int, _DWORD))(a1 + 16))(a2, v6[1]) )
  {
    v6 = (_DWORD *)v6[4];
    if ( !v6 )
      return 0;
  }
  return v6[2];
}
// 5DA7C: variable 'v5' is possibly undefined

//----- (0005DAC0) --------------------------------------------------------
int __fastcall sub_5DAC0(int a1, int a2, int a3)
{
  int v3; // r5
  unsigned int v5; // r0
  unsigned int v6; // r9
  int v7; // r1
  _DWORD *v8; // r4
  void (__fastcall *v9)(_DWORD); // r3
  void (__fastcall *v10)(_DWORD); // r3
  int result; // r0
  unsigned int v12; // r8
  void *v13; // r0
  void *v14; // r11
  unsigned int **v15; // r10
  _DWORD *v16; // r5
  unsigned int *v17; // r4
  unsigned int *v18; // t1
  unsigned int *v19; // r11
  unsigned int v20; // r0
  int v21; // r1
  int v22; // r3
  _DWORD *v23; // r4
  unsigned int v24; // r0
  unsigned int v25; // r1
  int v26; // r1
  int v27; // r2
  int v28; // r3
  unsigned int v29; // r3
  int *v30; // r0
  int *v31; // r0
  char *ptr; // [sp+10h] [bp-30h]
  int v34; // [sp+14h] [bp-2Ch]

  v3 = a1;
  v5 = (*(int (__fastcall **)(int))(a1 + 12))(a2);
  v6 = *(_DWORD *)(v3 + 8);
  sub_5FADC(v5, v6);
  v8 = *(_DWORD **)(*(_DWORD *)(v3 + 4) + 4 * v7);
  if ( v8 )
  {
    while ( !(*(int (__fastcall **)(int, _DWORD))(v3 + 16))(a2, v8[1]) )
    {
      v8 = (_DWORD *)v8[4];
      if ( !v8 )
      {
        v6 = *(_DWORD *)(v3 + 8);
        goto LABEL_11;
      }
    }
    v9 = *(void (__fastcall **)(_DWORD))(v3 + 20);
    if ( v9 )
      v9(v8[1]);
    v10 = *(void (__fastcall **)(_DWORD))(v3 + 24);
    if ( v10 )
      v10(v8[2]);
    result = 0;
    v8[1] = a2;
    v8[2] = a3;
  }
  else
  {
LABEL_11:
    if ( (double)*(unsigned int *)v3 > (double)v6 * 1.3 )
    {
      v12 = 2 * v6;
      v13 = calloc(2 * v6, 4u);
      v14 = v13;
      if ( !v13 )
      {
        v30 = _errno_location();
        sub_5DF98(2, "src/zc_hashtable.c", 126, "calloc fail, errno[%d]", *v30);
        sub_5DF98(2, "src/zc_hashtable.c", 205, "rehash fail");
        return -1;
      }
      ptr = *(char **)(v3 + 4);
      if ( v6 )
      {
        v15 = *(unsigned int ***)(v3 + 4);
        v34 = v3;
        v16 = v13;
        do
        {
          v18 = *v15++;
          v17 = v18;
          if ( v18 )
          {
            do
            {
              v19 = (unsigned int *)v17[4];
              v20 = *v17;
              v17[3] = 0;
              v17[4] = 0;
              sub_5FADC(v20, v12);
              v22 = v16[v21];
              if ( v22 )
              {
                *(_DWORD *)(v22 + 12) = v17;
                v17[4] = v16[v21];
              }
              v16[v21] = v17;
              v17 = v19;
            }
            while ( v19 );
          }
        }
        while ( &ptr[4 * v6] != (char *)v15 );
        v14 = v16;
        v3 = v34;
      }
      free(ptr);
      *(_DWORD *)(v3 + 4) = v14;
      *(_DWORD *)(v3 + 8) = v12;
    }
    v23 = calloc(1u, 0x14u);
    if ( v23 )
    {
      v24 = (*(int (__fastcall **)(int))(v3 + 12))(a2);
      v25 = *(_DWORD *)(v3 + 8);
      v23[4] = 0;
      v23[2] = a3;
      v23[3] = 0;
      *v23 = v24;
      v23[1] = a2;
      sub_5FADC(v24, v25);
      v27 = *(_DWORD *)(v3 + 4);
      result = 0;
      v28 = *(_DWORD *)(v27 + 4 * v26);
      if ( v28 )
      {
        *(_DWORD *)(v28 + 12) = v23;
        v23[4] = *(_DWORD *)(v27 + 4 * v26);
      }
      v29 = *(_DWORD *)v3;
      *(_DWORD *)(v27 + 4 * v26) = v23;
      *(_DWORD *)v3 = v29 + 1;
    }
    else
    {
      v31 = _errno_location();
      sub_5DF98(2, "src/zc_hashtable.c", 212, "calloc fail, errno[%d]", *v31);
      return -1;
    }
  }
  return result;
}
// 5DAF0: variable 'v7' is possibly undefined
// 5DBEC: variable 'v21' is possibly undefined
// 5DC74: variable 'v26' is possibly undefined

//----- (0005DD28) --------------------------------------------------------
void __fastcall sub_5DD28(_DWORD *arg, const void *a2)
{
  bool v2; // zf
  unsigned int v5; // r0
  int v6; // r1
  unsigned int *v7; // r4
  void (__fastcall *v8)(unsigned int); // r3
  void (__fastcall *v9)(unsigned int); // r3
  unsigned int v10; // r6
  unsigned int v11; // r3
  int v12; // r1

  v2 = a2 == 0;
  if ( a2 )
    v2 = arg == 0;
  if ( v2 )
  {
    sub_5DF98(2, "src/zc_hashtable.c", 240, "a_table[%p] or a_key[%p] is NULL, just do nothing", arg, a2);
  }
  else
  {
    v5 = ((int (__fastcall *)(const void *))arg[3])(a2);
    sub_5FADC(v5, arg[2]);
    v7 = *(unsigned int **)(arg[1] + 4 * v6);
    if ( v7 )
    {
      while ( !((int (__fastcall *)(const void *, unsigned int))arg[4])(a2, v7[1]) )
      {
        v7 = (unsigned int *)v7[4];
        if ( !v7 )
          goto LABEL_18;
      }
      v8 = (void (__fastcall *)(unsigned int))arg[5];
      if ( v8 )
        v8(v7[1]);
      v9 = (void (__fastcall *)(unsigned int))arg[6];
      if ( v9 )
        v9(v7[2]);
      v10 = v7[4];
      v11 = v7[3];
      if ( v10 )
      {
        *(_DWORD *)(v10 + 12) = v11;
        v11 = v7[3];
      }
      if ( v11 )
      {
        *(_DWORD *)(v11 + 16) = v10;
      }
      else
      {
        sub_5FADC(*v7, arg[2]);
        *(_DWORD *)(arg[1] + 4 * v12) = v10;
      }
      free(v7);
      --*arg;
    }
    else
    {
LABEL_18:
      sub_5DF98(2, "src/zc_hashtable.c", 251, "p[%p] not found in hashtable", 0);
    }
  }
}
// 5DD5C: variable 'v6' is possibly undefined
// 5DE30: variable 'v12' is possibly undefined

//----- (0005DE60) --------------------------------------------------------
int __fastcall sub_5DE60(int a1)
{
  int v1; // r12
  int *v2; // r2
  int result; // r0
  int v4; // r3
  int v5; // r1
  int v6; // t1

  v1 = *(_DWORD *)(a1 + 8);
  if ( !v1 )
    return 0;
  v2 = *(int **)(a1 + 4);
  result = *v2;
  if ( !*v2 )
  {
    v4 = 0;
    while ( ++v4 != v1 )
    {
      v6 = v2[1];
      ++v2;
      v5 = v6;
      if ( v6 )
        return v5;
    }
  }
  return result;
}

//----- (0005DEA8) --------------------------------------------------------
unsigned int __fastcall sub_5DEA8(int a1, unsigned int *a2)
{
  unsigned int v2; // r4
  unsigned int v4; // r5
  int v6; // r1
  unsigned int v7; // r1
  int v8; // r3
  int v9; // r3
  int v10; // r2
  int v11; // t1

  v2 = a2[4];
  if ( !v2 )
  {
    v4 = *(_DWORD *)(a1 + 8);
    sub_5FADC(*a2, v4);
    v7 = v6 + 1;
    if ( v4 > v7 )
    {
      v8 = *(_DWORD *)(a1 + 4);
      v2 = *(_DWORD *)(v8 + 4 * v7);
      v9 = v8 + 4 * v7;
      if ( !v2 )
      {
        while ( v4 > ++v7 )
        {
          v11 = *(_DWORD *)(v9 + 4);
          v9 += 4;
          v10 = v11;
          if ( v11 )
            return v10;
        }
      }
    }
  }
  return v2;
}
// 5DED4: variable 'v6' is possibly undefined

//----- (0005DF18) --------------------------------------------------------
int __fastcall sub_5DF18(_BYTE *a1)
{
  int v1; // r3
  int v2; // r2
  int v3; // r1
  int v4; // t1

  v1 = (unsigned __int8)*a1;
  v2 = 5381;
  if ( *a1 )
  {
    do
    {
      v3 = v1 + 32 * v2;
      v4 = (unsigned __int8)*++a1;
      v1 = v4;
      v2 += v3;
    }
    while ( v4 );
  }
  return v2;
}

//----- (0005DF44) --------------------------------------------------------
bool __fastcall sub_5DF44(const char *a1, const char *a2)
{
  return strcmp(a1, a2) == 0;
}

//----- (0005DF58) --------------------------------------------------------
size_t __fastcall sub_5DF58(char *a1)
{
  time_t v3; // [sp+0h] [bp-38h] BYREF
  struct tm tp; // [sp+4h] [bp-34h] BYREF

  time(&v3);
  localtime_r(&v3, &tp);
  return strftime(a1, 0x15u, "%m-%d %T", &tp);
}

//----- (0005DF98) --------------------------------------------------------
int sub_5DF98(int a1, const char *a2, int a3, const char *a4, ...)
{
  FILE *v7; // r4
  int result; // r0
  __pid_t v9; // r0
  __pid_t v10; // r0
  __pid_t v11; // r0
  char v12[44]; // [sp+10h] [bp-30h] BYREF
  const char *varg_r3; // [sp+3Ch] [bp-4h]
  va_list arg; // [sp+40h] [bp+0h] BYREF

  va_start(arg, a4);
  varg_r3 = a4;
  if ( dword_58DE44 )
  {
    if ( a1 != 1 )
    {
LABEL_3:
      if ( a1 != 2 )
      {
        if ( a1 )
        {
          v7 = 0;
LABEL_7:
          vfprintf(v7, varg_r3, arg);
          fputc(10, v7);
          fclose(v7);
          return 0;
        }
        if ( !dword_58DE48 )
          return 0;
        v7 = (FILE *)fopen64(dword_58DE48, "a");
        if ( v7 )
        {
          sub_5DF58(v12);
          v9 = getpid();
          fprintf(v7, "%s DEBUG (%d:%s:%ld) ", v12, v9, a2, a3);
          goto LABEL_7;
        }
        return -1;
      }
      result = dword_58DE4C;
      if ( dword_58DE4C )
      {
        v7 = (FILE *)fopen64(dword_58DE4C, "a");
        if ( v7 )
        {
          sub_5DF58(v12);
          v11 = getpid();
          fprintf(v7, "%s ERROR (%d:%s:%ld) ", v12, v11, a2, a3);
          goto LABEL_7;
        }
        return -1;
      }
      return result;
    }
  }
  else
  {
    dword_58DE44 = 1;
    dword_58DE48 = (int)getenv("ZLOG_PROFILE_DEBUG");
    dword_58DE4C = (int)getenv("ZLOG_PROFILE_ERROR");
    if ( a1 != 1 )
      goto LABEL_3;
  }
  result = dword_58DE4C;
  if ( dword_58DE4C )
  {
    v7 = (FILE *)fopen64(dword_58DE4C, "a");
    if ( v7 )
    {
      sub_5DF58(v12);
      v10 = getpid();
      fprintf(v7, "%s WARN  (%d:%s:%ld) ", v12, v10, a2, a3);
      goto LABEL_7;
    }
    return -1;
  }
  return result;
}
// 124E4: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 58DE44: using guessed type int dword_58DE44;
// 58DE48: using guessed type int dword_58DE48;
// 58DE4C: using guessed type int dword_58DE4C;

//----- (0005E140) --------------------------------------------------------
int __fastcall sub_5E140(const char *a1)
{
  int v2; // r4
  char *v3; // r1
  const unsigned __int16 **v4; // r0
  const char *v5; // r3
  int v6; // t1
  size_t v7; // r6
  int v8; // r4
  char v10; // r3
  int v11; // r6
  int v12; // r3

  if ( a1 )
  {
    v2 = *(unsigned __int8 *)a1;
    if ( *a1 )
    {
      v4 = _ctype_b_loc();
      v3 = (char *)a1;
      v5 = a1;
      do
      {
        if ( ((*v4)[v2] & 0x2000) == 0 )
          *v3++ = v2;
        v6 = *(unsigned __int8 *)++v5;
        v2 = v6;
      }
      while ( v6 );
    }
    else
    {
      v3 = (char *)a1;
    }
    *v3 = 0;
    v7 = strlen(a1);
    v8 = strtol(a1, 0, 10);
    if ( v8 > 0 )
    {
      v10 = a1[v7 - 1];
      if ( (v10 & 0xDF) == 66 )
        v11 = (unsigned __int8)a1[v7 - 2];
      else
        v11 = (unsigned __int8)a1[v7 - 1];
      if ( (v10 & 0xDF) == 66 )
        v12 = 1024;
      else
        v12 = 1000;
      switch ( v11 )
      {
        case 'G':
        case 'g':
          v8 *= v12 * v12 * v12;
          break;
        case 'K':
        case 'k':
          goto LABEL_18;
        case 'M':
        case 'm':
          v12 *= v12;
LABEL_18:
          v8 *= v12;
          break;
        default:
          if ( ((*_ctype_b_loc())[v11] & 0x800) == 0 )
            sub_5DF98(2, "src/zc_util.c", 70, "Wrong suffix parsing size in bytes for string [%s], ignoring suffix", a1);
          break;
      }
      return v8;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    sub_5DF98(2, "src/zc_util.c", 27, "astring is null or 0");
    return 0;
  }
}
// 5E1E8: control flows out of bounds to 5E1EC

//----- (0005E310) --------------------------------------------------------
int __fastcall sub_5E310(const char *a1, int a2)
{
  const char *v3; // r4
  size_t v4; // r9
  char *v5; // r0
  unsigned int v6; // r0
  size_t v7; // r5
  size_t v8; // r0
  char *v9; // r6
  int *v11; // r0
  int v12; // [sp+8h] [bp-4h] BYREF
  char v13[4100]; // [sp+Ch] [bp+0h] BYREF
  char v14[4100]; // [sp+1010h] [bp+1004h] BYREF
  char v15[4104]; // [sp+2014h] [bp+2008h] BYREF

  v3 = a1;
  v4 = strlen(a1);
  while ( 1 )
  {
    do
    {
      v9 = strchr(v3, 37);
      v3 = v9 + 1;
      if ( !v9 )
        return 0;
      memset(v13, 0, 0x1001u);
      memset(v14, 0, 0x1001u);
      memset(v15, 0, 0x1001u);
      v12 = 0;
      if ( _isoc99_sscanf(v9 + 1, "%[.0-9-]%n", &v13[1], &v12) == 1 )
      {
        v13[0] = 37;
        v3 = &v9[v12 + 1];
        v13[v12 + 1] = 115;
      }
      else
      {
        v12 = 0;
        strcpy(v13, "%s");
      }
    }
    while ( !_isoc99_sscanf(v3, "E(%[^)])%n", v14, &v12) );
    v3 += v12;
    if ( *(v3 - 1) != 41 )
    {
      sub_5DF98(2, "src/zc_util.c", 124, "in string[%s] can't find match )", v9);
      return -1;
    }
    v5 = getenv(v14);
    v6 = snprintf(v15, 0x1001u, v13, v5);
    v7 = v6;
    if ( v6 > 0x1000 )
    {
      v11 = _errno_location();
      sub_5DF98(2, "src/zc_util.c", 131, "snprintf fail, errno[%d], evn_value_len[%d]", *v11, v7);
      return -1;
    }
    v4 = v4 - (v3 - v9) + v6;
    if ( a2 - 1 < v4 )
      break;
    v8 = strlen(v3);
    memmove(&v9[v7], v3, v8 + 1);
    memcpy(v9, v15, v7);
  }
  sub_5DF98(2, "src/zc_util.c", 137, "repalce env_value[%s] cause overlap", v15);
  return -1;
}
// 1231C: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);

//----- (0005E558) --------------------------------------------------------
int __fastcall sub_5E558(int a1, unsigned int a2)
{
  size_t v3; // r5
  unsigned int v4; // r2
  int v5; // r8
  int v6; // r6
  char *v7; // r0
  size_t v9; // r2
  int *v10; // r0

  v3 = *(_DWORD *)(a1 + 20);
  v4 = *(_DWORD *)(a1 + 24);
  if ( v3 )
  {
    if ( v3 <= v4 )
    {
      sub_5DF98(2, "src/buf.c", 169, "a_buf->size_real[%ld] >= a_buf->size_max[%ld]", *(_DWORD *)(a1 + 24), v3);
      return 1;
    }
    v9 = v4 + a2;
    if ( v3 < v9 )
    {
      v5 = 1;
    }
    else
    {
      v3 = v9;
      v5 = 0;
    }
  }
  else
  {
    v5 = 0;
    v3 = (unsigned int)((double)v4 + (double)a2 * 1.5);
  }
  v6 = *(_DWORD *)(a1 + 4) - *(_DWORD *)a1;
  v7 = (char *)realloc(*(void **)a1, v3);
  if ( v7 )
  {
    *(_DWORD *)(a1 + 4) = &v7[v6];
    *(_DWORD *)a1 = v7;
    *(_DWORD *)(a1 + 12) = &v7[v3];
    *(_DWORD *)(a1 + 8) = &v7[v3 - 1];
    *(_DWORD *)(a1 + 24) = v3;
  }
  else
  {
    v10 = _errno_location();
    sub_5DF98(2, "src/buf.c", 189, "realloc fail, errno[%d]", *v10);
    v5 = -1;
    free(*(void **)a1);
    *(_DWORD *)a1 = 0;
    *(_DWORD *)(a1 + 4) = 0;
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 12) = 0;
  }
  return v5;
}

//----- (0005E680) --------------------------------------------------------
void *__fastcall sub_5E680(void **a1)
{
  _BYTE *v1; // r2
  void **v2; // r1
  void *v3; // r3
  void *v4; // r0

  v1 = a1[1];
  v2 = a1 + 7;
  v3 = *a1;
  v4 = (void *)(v1 - (_BYTE *)a1[264]);
  if ( v4 < v3 )
    v4 = v3;
  return memcpy(v4, v2, v1 - (_BYTE *)v4);
}

//----- (0005E6A4) --------------------------------------------------------
int __fastcall sub_5E6A4(const void **arg, int a2)
{
  return sub_5DF98(
           a2,
           "src/buf.c",
           74,
           "---buf[%p][%ld-%ld][%ld][%s][%p:%ld]---",
           arg,
           arg[4],
           arg[5],
           arg[6],
           (const char *)arg + 28,
           *arg,
           (_BYTE *)arg[1] - (_BYTE *)*arg);
}

//----- (0005E70C) --------------------------------------------------------
void __fastcall sub_5E70C(void **arg)
{
  void *v2; // r0

  v2 = *arg;
  if ( v2 )
    free(v2);
  sub_5DF98(0, "src/buf.c", 82, "zlog_buf_del[%p]", arg);
  free(arg);
}

//----- (0005E758) --------------------------------------------------------
void **__fastcall sub_5E758(size_t a1, unsigned int arg, const char *a3)
{
  bool v4; // cc
  void **v7; // r4
  size_t v8; // r0
  size_t v9; // r8
  char *v10; // r0
  char *v11; // r5
  void **v13; // r0
  int *v14; // r0
  int *v15; // r0

  if ( !a1 )
  {
    v7 = 0;
    sub_5DF98(2, "src/buf.c", 92, "buf_size_min == 0, not allowed");
    return v7;
  }
  v4 = arg != 0;
  if ( arg )
    v4 = a1 > arg;
  if ( v4 )
  {
    sub_5DF98(2, "src/buf.c", 98, "buf_size_max[%lu] < buf_size_min[%lu] && buf_size_max != 0", arg, a1);
    return 0;
  }
  v7 = (void **)calloc(1u, 0x424u);
  if ( !v7 )
  {
    v14 = _errno_location();
    sub_5DF98(2, "src/buf.c", 104, "calloc fail, errno[%d]", *v14);
    return v7;
  }
  if ( a3 )
  {
    v8 = strlen(a3);
    v9 = v8;
    if ( v8 > 0x400 )
    {
      sub_5DF98(2, "src/buf.c", 110, "truncate_str[%s] overflow", a3);
LABEL_14:
      v13 = v7;
      v7 = 0;
      sub_5E70C(v13);
      return v7;
    }
    memcpy(v7 + 7, a3, v8 + 1);
    v7[264] = (void *)v9;
  }
  v7[4] = (void *)a1;
  v7[5] = (void *)arg;
  v7[6] = (void *)a1;
  v10 = (char *)calloc(1u, a1);
  *v7 = v10;
  if ( !v10 )
  {
    v15 = _errno_location();
    sub_5DF98(2, "src/buf.c", 124, "calloc fail, errno[%d]", *v15);
    goto LABEL_14;
  }
  v11 = &v10[a1];
  v7[1] = v10;
  v7[3] = v11;
  v7[2] = v11 - 1;
  return v7;
}

//----- (0005E8DC) --------------------------------------------------------
int __fastcall sub_5E8DC(int a1, char *format, __gnuc_va_list arg)
{
  size_t v6; // r4
  int v7; // r6
  _BOOL4 v8; // r0
  int v9; // r4
  int result; // r0
  int v11; // r0
  int v12; // r4
  char *v13; // r0
  size_t v14; // r6
  int v15; // r7
  char *v16; // r0
  size_t v17; // r1
  size_t v18; // r4
  int v19; // r2
  int *v20; // r0
  int *v21; // r0
  size_t v22; // [sp+4h] [bp-2Ch]

  if ( !*(_DWORD *)a1 )
  {
    sub_5DF98(2, "src/buf.c", 214, "pre-use of zlog_buf_resize fail, so can't convert");
    return -1;
  }
  v6 = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 4);
  v7 = vsnprintf(*(char **)(a1 + 4), v6, format, arg);
  v8 = v7 >= 0;
  if ( v7 >= v6 )
    v8 = 0;
  if ( v8 )
  {
    result = 0;
    *(_DWORD *)(a1 + 4) += v7;
  }
  else
  {
    if ( v7 < 0 )
    {
      v20 = _errno_location();
      sub_5DF98(2, "src/buf.c", 226, "vsnprintf fail, errno[%d]", *v20);
      v22 = v6;
      v9 = -1;
      sub_5DF98(2, "src/buf.c", 227, "nwrite[%d], size_left[%ld], format[%s]", v7, v22, format);
      return v9;
    }
    if ( v7 < v6 )
      return 0;
    v11 = sub_5E558(a1, 1 - v6 + v7);
    v12 = v11;
    if ( v11 > 0 )
    {
      sub_5DF98(2, "src/buf.c", 234, "conf limit to %ld, can't extend, so truncate", *(_DWORD *)(a1 + 20));
      v16 = *(char **)(a1 + 4);
      v17 = *(_DWORD *)(a1 + 12) - (_DWORD)v16;
      v18 = v17 - 1;
      vsnprintf(v16, v17, format, arg);
      v19 = *(unsigned __int8 *)(a1 + 28);
      *(_DWORD *)(a1 + 4) += v18;
      v9 = 1;
      if ( v19 )
        sub_5E680((void **)a1);
      return v9;
    }
    if ( v11 )
    {
      sub_5DF98(2, "src/buf.c", 243, "zlog_buf_resize fail");
      return -1;
    }
    v13 = *(char **)(a1 + 4);
    v14 = *(_DWORD *)(a1 + 12) - (_DWORD)v13;
    v15 = vsnprintf(v13, v14, format, arg);
    if ( v15 < 0 )
    {
      v21 = _errno_location();
      sub_5DF98(2, "src/buf.c", 252, "vsnprintf fail, errno[%d]", *v21);
      v9 = -1;
      sub_5DF98(2, "src/buf.c", 253, "nwrite[%d], size_left[%ld], format[%s]", v15, v14, format);
      return v9;
    }
    result = v12;
    *(_DWORD *)(a1 + 4) += v15;
  }
  return result;
}

//----- (0005EB48) --------------------------------------------------------
int __fastcall sub_5EB48(int a1, unsigned int a2, char *a3)
{
  char *v4; // r4
  unsigned int v5; // r0
  char v6; // r3
  char *v7; // r6
  char *v8; // r7
  void *v9; // r0
  char *v10; // r3
  char *v11; // r9
  char *v12; // r8
  int result; // r0
  int v14; // r0
  void *v15; // r0
  unsigned int v16; // r6
  bool v17; // cc
  int v18; // r2
  unsigned int v19; // r6
  char v20[33]; // [sp+17h] [bp-21h] BYREF

  if ( !*(_DWORD *)a1 )
  {
    sub_5DF98(2, "src/buf.c", 276, "pre-use of zlog_buf_resize fail, so can't convert");
    return -1;
  }
  v4 = v20;
  do
  {
    v5 = a2 / 0xA;
    v6 = a2 - 10 * v5;
    a2 = v5;
    *--v4 = v6 + 48;
  }
  while ( v5 );
  v7 = (char *)(v20 - v4);
  v8 = a3;
  v9 = *(void **)(a1 + 4);
  v10 = *(char **)(a1 + 8);
  if ( (unsigned int)a3 <= v20 - v4 )
  {
    v11 = &v7[(_DWORD)v9];
    v12 = 0;
    if ( &v7[(int)v9] <= v10 )
    {
LABEL_9:
      memcpy(&v12[(_DWORD)v9], v4, v20 - v4);
      result = 0;
      *(_DWORD *)(a1 + 4) = v11;
      return result;
    }
    v8 = (char *)(v20 - v4);
  }
  else
  {
    v11 = &a3[(_DWORD)v9];
    v12 = (char *)(a3 - v7);
    if ( &a3[(int)v9] <= v10 )
    {
LABEL_6:
      if ( v12 )
      {
        memset(v9, 48, (size_t)v12);
        v9 = *(void **)(a1 + 4);
      }
      goto LABEL_9;
    }
  }
  v14 = sub_5E558(a1, (unsigned int)&v8[-(v10 - (_BYTE *)v9)]);
  if ( v14 <= 0 )
  {
    if ( v14 )
    {
      sub_5DF98(2, "src/buf.c", 318, "zlog_buf_resize fail");
      return -1;
    }
    v9 = *(void **)(a1 + 4);
    v11 = &v8[(_DWORD)v9];
    goto LABEL_6;
  }
  sub_5DF98(2, "src/buf.c", 302, "conf limit to %ld, can't extend, so output", *(_DWORD *)(a1 + 20));
  v15 = *(void **)(a1 + 4);
  v16 = *(_DWORD *)(a1 + 8) - (_DWORD)v15;
  v17 = v16 > (unsigned int)v12;
  if ( v16 > (unsigned int)v12 )
    v8 = (char *)(v16 - (_DWORD)v12);
  else
    v12 = (char *)(*(_DWORD *)(a1 + 8) - (_DWORD)v15);
  if ( !v17 )
    v8 = 0;
  if ( v12 )
  {
    memset(v15, 48, (size_t)v12);
    v15 = *(void **)(a1 + 4);
  }
  result = (int)memcpy(&v12[(_DWORD)v15], v4, (size_t)v8);
  v18 = *(unsigned __int8 *)(a1 + 28);
  v19 = *(_DWORD *)(a1 + 4) + v16;
  if ( !*(_BYTE *)(a1 + 28) )
    result = 1;
  *(_DWORD *)(a1 + 4) = v19;
  if ( v18 )
  {
    sub_5E680((void **)a1);
    return 1;
  }
  return result;
}

//----- (0005ED04) --------------------------------------------------------
int __fastcall sub_5ED04(int a1, int a2, int a3, int a4, char *a5)
{
  unsigned __int64 v5; // r4
  bool v6; // cc
  char *v8; // r6
  unsigned int v9; // r3
  char *v10; // r4
  char *v11; // r7
  __int64 v12; // r0
  char *v13; // r9
  size_t v14; // r5
  int result; // r0
  char v16; // r2
  unsigned __int64 v17; // r0
  int v18; // r0
  char *v19; // r0
  size_t v20; // r4
  bool v21; // cc
  int v22; // r2
  size_t v23; // r4
  char v24[36]; // [sp+1Ch] [bp-24h] BYREF

  HIDWORD(v5) = a4;
  if ( !*(_DWORD *)a1 )
  {
    sub_5DF98(2, "src/buf.c", 342, "pre-use of zlog_buf_resize fail, so can't convert");
    return -1;
  }
  LODWORD(v5) = a3;
  v6 = a4 != 0;
  if ( !a4 )
    v6 = 0;
  if ( v6 )
  {
    v8 = v24;
    do
    {
      sub_60120(v5, 0xAuLL);
      *--v8 = v16 + 48;
      LODWORD(v17) = sub_60120(v5, 0xAuLL);
      v5 = v17;
    }
    while ( v17 );
  }
  else
  {
    v8 = v24;
    do
    {
      v9 = (unsigned int)v5 % 0xA;
      LODWORD(v5) = (unsigned int)v5 / 0xA;
      *--v8 = v9 + 48;
    }
    while ( (_DWORD)v5 );
  }
  v10 = a5;
  v11 = (char *)(v24 - v8);
  v12 = *(_QWORD *)(a1 + 4);
  if ( (unsigned int)a5 <= v24 - v8 )
  {
    v13 = &v11[v12];
    if ( (unsigned int)&v11[v12] <= HIDWORD(v12) )
    {
      v14 = 0;
LABEL_11:
      memcpy((void *)(v12 + v14), v8, (size_t)v11);
      result = 0;
      *(_DWORD *)(a1 + 4) = v13;
      return result;
    }
    v10 = (char *)(v24 - v8);
    v14 = 0;
  }
  else
  {
    v13 = &a5[v12];
    v14 = a5 - v11;
    if ( (unsigned int)&a5[v12] <= HIDWORD(v12) )
    {
LABEL_9:
      if ( v14 )
      {
        memset((void *)v12, 48, v14);
        LODWORD(v12) = *(_DWORD *)(a1 + 4);
      }
      goto LABEL_11;
    }
  }
  v18 = sub_5E558(a1, (unsigned int)&v10[-(HIDWORD(v12) - v12)]);
  if ( v18 <= 0 )
  {
    if ( v18 )
    {
      sub_5DF98(2, "src/buf.c", 409, "zlog_buf_resize fail");
      return -1;
    }
    LODWORD(v12) = *(_DWORD *)(a1 + 4);
    v13 = &v10[v12];
    goto LABEL_9;
  }
  sub_5DF98(2, "src/buf.c", 393, "conf limit to %ld, can't extend, so output", *(_DWORD *)(a1 + 20));
  v19 = *(char **)(a1 + 4);
  v20 = *(_DWORD *)(a1 + 8) - (_DWORD)v19;
  v21 = v20 > v14;
  if ( v20 > v14 )
    v11 = (char *)(v20 - v14);
  else
    v14 = *(_DWORD *)(a1 + 8) - (_DWORD)v19;
  if ( !v21 )
    v11 = 0;
  if ( v14 )
  {
    memset(v19, 48, v14);
    v19 = *(char **)(a1 + 4);
  }
  result = (int)memcpy(&v19[v14], v8, (size_t)v11);
  v22 = *(unsigned __int8 *)(a1 + 28);
  v23 = *(_DWORD *)(a1 + 4) + v20;
  if ( !*(_BYTE *)(a1 + 28) )
    result = 1;
  *(_DWORD *)(a1 + 4) = v23;
  if ( v22 )
  {
    sub_5E680((void **)a1);
    return 1;
  }
  return result;
}
// 5EDDC: variable 'v16' is possibly undefined
// 5EDF8: variable 'v17' is possibly undefined

//----- (0005EF24) --------------------------------------------------------
int __fastcall sub_5EF24(int a1, unsigned int a2, char *a3)
{
  char *v4; // r5
  int v5; // r3
  char *v6; // r6
  char *v7; // r8
  void *v8; // r0
  unsigned int v9; // r3
  char *v10; // r9
  size_t v11; // r4
  int result; // r0
  int v13; // r0
  char *v14; // r0
  size_t v15; // r6
  bool v16; // cc
  int v17; // r2
  size_t v18; // r6
  char v19[33]; // [sp+17h] [bp-21h] BYREF

  if ( !*(_DWORD *)a1 )
  {
    sub_5DF98(2, "src/buf.c", 434, "pre-use of zlog_buf_resize fail, so can't convert");
    return -1;
  }
  v4 = v19;
  do
  {
    v5 = a2 & 0xF;
    a2 >>= 4;
    *--v4 = a0123456789abcd[v5];
  }
  while ( a2 );
  v6 = (char *)(v19 - v4);
  v7 = a3;
  v8 = *(void **)(a1 + 4);
  v9 = *(_DWORD *)(a1 + 8);
  if ( (unsigned int)a3 <= v19 - v4 )
  {
    v10 = &v6[(_DWORD)v8];
    v11 = 0;
    if ( (char *)v9 >= &v6[(int)v8] )
    {
LABEL_9:
      memcpy((char *)v8 + v11, v4, (size_t)v6);
      result = 0;
      *(_DWORD *)(a1 + 4) = v10;
      return result;
    }
    v7 = (char *)(v19 - v4);
  }
  else
  {
    v10 = &a3[(_DWORD)v8];
    v11 = a3 - v6;
    if ( &a3[(int)v8] <= (char *)v9 )
    {
LABEL_6:
      if ( v11 )
      {
        memset(v8, 48, v11);
        v8 = *(void **)(a1 + 4);
      }
      goto LABEL_9;
    }
  }
  v13 = sub_5E558(a1, (unsigned int)&v7[-(v9 - (_DWORD)v8)]);
  if ( v13 <= 0 )
  {
    if ( v13 )
    {
      sub_5DF98(2, "src/buf.c", 489, "zlog_buf_resize fail");
      return -1;
    }
    v8 = *(void **)(a1 + 4);
    v10 = &v7[(_DWORD)v8];
    goto LABEL_6;
  }
  sub_5DF98(2, "src/buf.c", 473, "conf limit to %ld, can't extend, so output", *(_DWORD *)(a1 + 20));
  v14 = *(char **)(a1 + 4);
  v15 = *(_DWORD *)(a1 + 8) - (_DWORD)v14;
  v16 = v15 > v11;
  if ( v15 > v11 )
    v7 = (char *)(v15 - v11);
  else
    v11 = *(_DWORD *)(a1 + 8) - (_DWORD)v14;
  if ( !v16 )
    v7 = 0;
  if ( v11 )
  {
    memset(v14, 48, v11);
    v14 = *(char **)(a1 + 4);
  }
  result = (int)memcpy(&v14[v11], v4, (size_t)v7);
  v17 = *(unsigned __int8 *)(a1 + 28);
  v18 = *(_DWORD *)(a1 + 4) + v15;
  if ( !*(_BYTE *)(a1 + 28) )
    result = 1;
  *(_DWORD *)(a1 + 4) = v18;
  if ( v17 )
  {
    sub_5E680((void **)a1);
    return 1;
  }
  return result;
}

//----- (0005F0D4) --------------------------------------------------------
int __fastcall sub_5F0D4(int a1, void *src, size_t n)
{
  void *v3; // r3
  size_t v5; // r1
  size_t v6; // r6
  int v9; // r0
  void *v10; // r0
  size_t v11; // r5
  int v12; // r2
  size_t v13; // r5
  int result; // r0

  v3 = *(void **)(a1 + 4);
  v5 = *(_DWORD *)(a1 + 8);
  v6 = (size_t)v3 + n;
  if ( v5 >= (unsigned int)v3 + n )
  {
LABEL_6:
    memcpy(v3, src, n);
    result = 0;
    *(_DWORD *)(a1 + 4) = v6;
    return result;
  }
  v9 = sub_5E558(a1, n - (v5 - (_DWORD)v3));
  if ( v9 <= 0 )
  {
    if ( v9 )
    {
      sub_5DF98(2, "src/buf.c", 533, "zlog_buf_resize fail");
      return -1;
    }
    v3 = *(void **)(a1 + 4);
    v6 = (size_t)v3 + n;
    goto LABEL_6;
  }
  sub_5DF98(2, "src/buf.c", 525, "conf limit to %ld, can't extend, so output", *(_DWORD *)(a1 + 20));
  v10 = *(void **)(a1 + 4);
  v11 = *(_DWORD *)(a1 + 8) - (_DWORD)v10;
  result = (int)memcpy(v10, src, v11);
  v12 = *(unsigned __int8 *)(a1 + 28);
  v13 = *(_DWORD *)(a1 + 4) + v11;
  if ( !*(_BYTE *)(a1 + 28) )
    result = 1;
  *(_DWORD *)(a1 + 4) = v13;
  if ( v12 )
  {
    sub_5E680((void **)a1);
    return 1;
  }
  return result;
}

//----- (0005F1CC) --------------------------------------------------------
int __fastcall sub_5F1CC(int a1, void *src, size_t n, size_t a4, int a5, int a6, int a7)
{
  size_t v7; // r9
  unsigned int v9; // r6
  unsigned int v10; // r4
  _BOOL4 v12; // r3
  __int64 v14; // r0
  bool v15; // cf
  unsigned int v16; // r1
  int result; // r0
  int v18; // r0
  char *v19; // r0
  unsigned int v20; // r6
  int v21; // r2
  unsigned int v22; // r6
  int v23; // r1

  v9 = a6;
  v10 = a7;
  if ( !*(_DWORD *)a1 )
  {
    sub_5DF98(2, "src/buf.c", 562, "pre-use of zlog_buf_resize fail, so can't convert");
    return -1;
  }
  v12 = a7 > n;
  if ( !a7 )
    v12 = 1;
  v14 = *(_QWORD *)(a1 + 4);
  if ( v12 )
    v10 = n;
  v15 = 1;
  if ( a6 )
    v15 = v10 >= a6;
  v16 = HIDWORD(v14) - v14;
  if ( v15 )
    v9 = v10;
  else
    v7 = a6 - v10;
  if ( v15 )
    v7 = 0;
  if ( v16 >= v9 )
    goto LABEL_14;
  v18 = sub_5E558(a1, v9 - v16);
  if ( v18 <= 0 )
  {
    if ( v18 )
    {
      sub_5DF98(2, "src/buf.c", 624, "zlog_buf_resize fail");
      return -1;
    }
    LODWORD(v14) = *(_DWORD *)(a1 + 4);
LABEL_14:
    if ( a4 )
    {
      if ( v7 )
      {
        memset((void *)(v14 + v10), 32, v7);
        LODWORD(v14) = *(_DWORD *)(a1 + 4);
      }
      memcpy((void *)v14, src, v10);
    }
    else
    {
      if ( v7 )
      {
        if ( a5 )
          HIDWORD(v14) = 48;
        else
          HIDWORD(v14) = 32;
        memset((void *)v14, SHIDWORD(v14), v7);
        LODWORD(v14) = *(_DWORD *)(a1 + 4);
      }
      memcpy((void *)(v14 + v7), src, v10);
    }
    result = 0;
    *(_DWORD *)(a1 + 4) += v9;
    return result;
  }
  sub_5DF98(2, "src/buf.c", 592, "conf limit to %ld, can't extend, so output", *(_DWORD *)(a1 + 20));
  v19 = *(char **)(a1 + 4);
  v20 = *(_DWORD *)(a1 + 8) - (_DWORD)v19;
  if ( a4 )
  {
    if ( v10 < v20 )
    {
      memset(&v19[v10], 32, v20 - v10);
      v19 = *(char **)(a1 + 4);
    }
    else
    {
      v10 = *(_DWORD *)(a1 + 8) - (_DWORD)v19;
    }
    result = (int)memcpy(v19, src, v10);
  }
  else
  {
    if ( v7 < v20 )
      a4 = v20 - v7;
    else
      v7 = *(_DWORD *)(a1 + 8) - (_DWORD)v19;
    if ( v7 )
    {
      if ( a5 )
        v23 = 48;
      else
        v23 = 32;
      memset(v19, v23, v7);
      v19 = *(char **)(a1 + 4);
    }
    result = (int)memcpy(&v19[v7], src, a4);
  }
  v21 = *(unsigned __int8 *)(a1 + 28);
  v22 = *(_DWORD *)(a1 + 4) + v20;
  if ( !*(_BYTE *)(a1 + 28) )
    result = 1;
  *(_DWORD *)(a1 + 4) = v22;
  if ( v21 )
  {
    sub_5E680((void **)a1);
    return 1;
  }
  return result;
}
// 5F240: variable 'v7' is possibly undefined

//----- (0005F3F8) --------------------------------------------------------
int __fastcall sub_5F3F8(const char *a1, int a2)
{
  if ( a1 )
    return sub_5DF98(
             a2,
             "src/level.c",
             26,
             "---level[%p][%d,%s,%s,%d,%d]---",
             a1,
             *(_DWORD *)a1,
             a1 + 4,
             a1 + 1029,
             *((_DWORD *)a1 + 514),
             *((_DWORD *)a1 + 515));
  else
    return sub_5DF98(2, "src/level.c", 19, "a_level is null or 0");
}

//----- (0005F474) --------------------------------------------------------
void __fastcall sub_5F474(void *a1)
{
  if ( a1 )
  {
    sub_5DF98(0, "src/level.c", 34, "zlog_level_del[%p]", a1);
    free(a1);
  }
  else
  {
    sub_5DF98(2, "src/level.c", 33, "a_level is null or 0");
  }
}

//----- (0005F4D8) --------------------------------------------------------
_DWORD *__fastcall sub_5F4D8(const char *a1)
{
  _DWORD *v2; // r5
  __int16 v3; // r4
  _DWORD *v4; // r0
  bool v5; // zf
  const __int32_t *v6; // r7
  const __int32_t *v7; // lr
  _DWORD *v8; // r3
  char *v9; // r1
  char *v10; // r0
  int v11; // r2
  int v12; // t1
  char *v13; // r3
  void *v15; // r0
  int *v16; // r0
  char v17[4]; // [sp+Ch] [bp-2024h] BYREF
  char s[4100]; // [sp+10h] [bp-2020h] BYREF
  char v19[4124]; // [sp+1014h] [bp-101Ch] BYREF

  v2 = 0;
  *(_DWORD *)v17 = 0;
  if ( !a1 )
  {
    v2 = 0;
    sub_5DF98(2, "src/level.c", 77, "line is null or 0");
    return v2;
  }
  memset(s, 0, 0x1001u);
  memset(v19, 0, 0x1001u);
  if ( _isoc99_sscanf(a1, " %[^= \t] = %d ,%s", s, v17, v19) <= 1 )
  {
    sub_5DF98(2, "src/level.c", 84, "level[%s], syntax wrong", a1);
    return v2;
  }
  if ( *(_DWORD *)v17 > 0xFFu )
  {
    sub_5DF98(2, "src/level.c", 90, "l[%d] not in [0,255], wrong", *(_DWORD *)v17);
    return v2;
  }
  v3 = (unsigned __int8)s[0];
  if ( !s[0] )
  {
    v2 = 0;
    sub_5DF98(2, "src/level.c", 95, "str[0] = 0");
    return v2;
  }
  v4 = calloc(1u, 0x810u);
  v2 = v4;
  if ( !v4 )
  {
    v16 = _errno_location();
    sub_5DF98(2, "src/level.c", 101, "calloc fail, errno[%d]", *v16);
    return v2;
  }
  v5 = v19[0] == 0;
  *v4 = *(_DWORD *)v17;
  if ( v5 )
    goto LABEL_8;
  if ( !strcasecmp(v19, "LOG_EMERG") )
  {
    v2[515] = 0;
    goto LABEL_9;
  }
  if ( !strcasecmp(v19, "LOG_ALERT") )
  {
    v2[515] = 1;
    goto LABEL_9;
  }
  if ( !strcasecmp(v19, "LOG_CRIT") )
  {
    v2[515] = 2;
    goto LABEL_9;
  }
  if ( !strcasecmp(v19, "LOG_ERR") )
  {
    v2[515] = 3;
    goto LABEL_9;
  }
  if ( !strcasecmp(v19, "LOG_WARNING") )
  {
    v2[515] = 4;
    goto LABEL_9;
  }
  if ( !strcasecmp(v19, "LOG_NOTICE") )
  {
    v2[515] = 5;
    goto LABEL_9;
  }
  if ( !strcasecmp(v19, "LOG_INFO") )
  {
    v2[515] = 6;
LABEL_9:
    v6 = *_ctype_toupper_loc();
    v7 = *_ctype_tolower_loc();
    v8 = v2 + 257;
    v9 = (char *)v2 + 3;
    v10 = s;
    v11 = 0;
    while ( 1 )
    {
      ++v11;
      *++v9 = v6[v3];
      *((_BYTE *)v8 + 1) = v7[v3];
      v8 = (_DWORD *)((char *)v8 + 1);
      if ( v11 == 1024 )
        break;
      v12 = (unsigned __int8)*++v10;
      v3 = v12;
      if ( !v12 )
        goto LABEL_12;
    }
    if ( !s[1024] )
    {
LABEL_12:
      v13 = (char *)v2 + v11;
      v13[4] = 0;
      v13[1029] = 0;
      v2[514] = v11;
      return v2;
    }
    sub_5DF98(2, "src/level.c", 126, "not enough space for str, str[%s] > %d", s, 1024);
    goto LABEL_26;
  }
  if ( !strcasecmp(v19, "LOG_DEBUG") )
  {
LABEL_8:
    v2[515] = 7;
    goto LABEL_9;
  }
  sub_5DF98(2, "src/level.c", 63, "wrong syslog level[%s]", v19);
  v2[515] = -187;
  sub_5DF98(2, "src/level.c", 113, "syslog_level_atoi fail");
LABEL_26:
  sub_5DF98(2, "src/level.c", 138, "line[%s]", a1);
  v15 = v2;
  v2 = 0;
  sub_5F474(v15);
  return v2;
}
// 1231C: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);

//----- (0005F880) --------------------------------------------------------
unsigned int __fastcall sub_5F880(unsigned int result, unsigned int a2)
{
  if ( a2 != 1 )
  {
    if ( !a2 )
      JUMPOUT(0x60150);
    if ( result <= a2 )
    {
      return result == a2;
    }
    else if ( (a2 & (a2 - 1)) != 0 )
    {
      return ((int (*)(void))((char *)&loc_5F8B8 + 16 * (31 - (__clz(a2) - __clz(result)))))();
    }
    else
    {
      result >>= 31 - __clz(a2);
    }
  }
  return result;
}
// 5FAD8: control flows out of bounds to 60150

//----- (0005FADC) --------------------------------------------------------
unsigned int __fastcall sub_5FADC(unsigned int a1, unsigned int a2)
{
  if ( !a2 )
    JUMPOUT(0x5FAD2);
  return sub_5F880(a1, a2);
}
// 5FADE: control flows out of bounds to 5FAD2

//----- (0005FAF8) --------------------------------------------------------
int __fastcall sub_5FAF8(int a1, int a2)
{
  if ( !a2 )
    JUMPOUT(0x60150);
  return sub_5FAFE(a1, a2);
}
// 5FD88: control flows out of bounds to 60150

//----- (0005FAFE) --------------------------------------------------------
int __fastcall sub_5FAFE(int result, unsigned int a2)
{
  char v2; // nf
  signed int v3; // r12
  unsigned int v4; // r3

  v3 = result ^ a2;
  if ( v2 )
    a2 = -a2;
  if ( a2 == 1 )
  {
    if ( (v3 ^ result) < 0 )
      return -result;
  }
  else
  {
    v4 = result;
    if ( result < 0 )
      v4 = -result;
    if ( v4 <= a2 )
    {
      if ( v4 < a2 )
        result = 0;
      if ( v4 == a2 )
        return (v3 >> 31) | 1;
    }
    else if ( (a2 & (a2 - 1)) != 0 )
    {
      return ((int (__fastcall *)(_DWORD))((char *)&loc_5FB40 + 16 * (31 - (__clz(a2) - __clz(v4)))))(0);
    }
    else
    {
      result = v4 >> (31 - __clz(a2));
      if ( v3 < 0 )
        return -result;
    }
  }
  return result;
}
// 5FB02: variable 'v2' is possibly undefined

//----- (0005FD8C) --------------------------------------------------------
int __fastcall sub_5FD8C(int a1, unsigned int a2)
{
  if ( !a2 )
    JUMPOUT(0x60150);
  return sub_5FAFE(a1, a2);
}
// 5FD88: control flows out of bounds to 60150

//----- (000600B4) --------------------------------------------------------
int __fastcall sub_600B4(__int64 a1)
{
  bool v1; // cf
  int v2; // off
  int v3; // r4
  bool v4; // zf
  unsigned int v5; // r3
  int v6; // r3
  bool v7; // cc
  int v8; // r2
  unsigned int v9; // r12
  int v10; // r4
  int v11; // r4
  char v12; // r4
  int v13; // r4
  unsigned int v14; // r12
  int v15; // r2
  int v16; // r2

  if ( !a1 )
    return a1;
  v13 = 1074;
  v14 = HIDWORD(a1) >> 22;
  if ( HIDWORD(a1) >> 22 )
  {
    v15 = 3;
    if ( HIDWORD(a1) >> 25 )
      v15 = 6;
    if ( HIDWORD(a1) >> 28 )
      v15 += 3;
    v16 = v15 + (HIDWORD(a1) >> 31);
    v14 = (_DWORD)a1 << (32 - v16);
    LODWORD(a1) = ((unsigned int)a1 >> v16) | (HIDWORD(a1) << (32 - v16));
    HIDWORD(a1) >>= v16;
    v13 = v16 + 1074;
  }
  if ( HIDWORD(a1) >= 0x100000 )
  {
    if ( HIDWORD(a1) >= 0x200000 )
    {
      v1 = a1 & 1;
      LODWORD(a1) = a1 >> 1;
      v14 = (v14 >> 1) | (v1 << 31);
      if ( (unsigned int)((v13 + 1) << 21) >= 0xFFC00000 )
      {
        LODWORD(a1) = 0;
        return a1;
      }
    }
    goto LABEL_11;
  }
  v1 = __CFSHL__(v14, 1);
  v14 *= 2;
  v2 = v1 + (_DWORD)a1;
  v1 = __CFADD__(v1, (_DWORD)a1) | __CFADD__((_DWORD)a1, v2);
  LODWORD(a1) = a1 + v2;
  HIDWORD(a1) += v1 + HIDWORD(a1);
  v3 = v13 - 1;
  if ( (a1 & 0x10000000000000LL) != 0 )
  {
LABEL_11:
    v1 = v14 >= 0x80000000;
    if ( v14 == 0x80000000 )
      v1 = a1 & 1;
    LODWORD(a1) = v1 + (_DWORD)a1;
    return a1;
  }
  v4 = HIDWORD(a1) == 0;
  if ( !HIDWORD(a1) )
  {
    HIDWORD(a1) = a1;
    LODWORD(a1) = 0;
  }
  v5 = __clz(HIDWORD(a1));
  if ( v4 )
    v5 += 32;
  v6 = v5 - 11;
  v8 = v6 - 32;
  v7 = v6 <= 32;
  if ( v6 >= 32 )
    goto LABEL_23;
  v7 = v8 <= -12;
  if ( v8 <= -12 )
  {
    LOBYTE(v8) = v6;
LABEL_23:
    if ( v7 )
      LOBYTE(v14) = 32 - v8;
    HIDWORD(a1) <<= v8;
    v9 = (unsigned int)a1 >> v14;
    if ( v7 )
    {
      HIDWORD(a1) |= v9;
      LODWORD(a1) = (_DWORD)a1 << v8;
    }
    goto LABEL_27;
  }
  LODWORD(a1) = HIDWORD(a1) << v6;
  HIDWORD(a1) >>= 32 - v6;
LABEL_27:
  v7 = v3 < v6;
  v10 = v3 - v6;
  if ( v7 )
  {
    v11 = ~v10;
    v7 = v11 < 31;
    v12 = v11 - 31;
    if ( v7 )
      LODWORD(a1) = ((unsigned int)a1 >> (v12 + 32)) | (HIDWORD(a1) << -v12);
    else
      LODWORD(a1) = HIDWORD(a1) >> v12;
  }
  return a1;
}

//----- (00060120) --------------------------------------------------------
int __fastcall sub_60120(unsigned __int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v3; // [sp+8h] [bp-8h] BYREF

  if ( a2 )
    return sub_601C0(a1, a2, &v3);
  if ( a1 )
    HIDWORD(a1) = -1;
  LODWORD(v3) = HIDWORD(a1);
  return raise(8);
}

//----- (0006015C) --------------------------------------------------------
unsigned int __fastcall sub_6015C(double a1)
{
  if ( a1 >= 0.0 )
    return sub_60180(a1);
  HIDWORD(a1) ^= 0x80000000;
  return -sub_60180(a1);
}

//----- (00060180) --------------------------------------------------------
unsigned int __fastcall sub_60180(double a1)
{
  return (unsigned int)(a1 - (double)(unsigned int)(a1 * 2.32830644e-10) * 4294967300.0);
}

//----- (000601C0) --------------------------------------------------------
int __fastcall sub_601C0(unsigned __int64 a1, unsigned __int64 a2, unsigned __int64 *a3)
{
  bool v3; // cf
  unsigned __int64 v4; // r4
  unsigned int v5; // r12
  unsigned int v6; // r1
  unsigned int v7; // r12
  char v8; // r8
  char v9; // r9
  unsigned __int64 v10; // r6
  unsigned __int64 v11; // r6
  unsigned int v12; // r2
  int v13; // off

  v3 = a1 >= a2;
  LODWORD(v4) = a1;
  if ( a1 < a2 )
    LODWORD(a1) = 0;
  HIDWORD(v4) = HIDWORD(a1);
  if ( !v3 )
    goto LABEL_16;
  v5 = __clz(HIDWORD(a2));
  if ( HIDWORD(a2) )
  {
    v6 = __clz(HIDWORD(a1));
    if ( HIDWORD(v4) )
      goto LABEL_7;
    goto LABEL_19;
  }
  v6 = __clz(HIDWORD(a1));
  v5 = __clz(a2) + 32;
  if ( !HIDWORD(v4) )
LABEL_19:
    v6 = __clz(v4) + 32;
LABEL_7:
  v7 = v5 - v6;
  v8 = v7 - 32;
  v9 = 32 - v7;
  v10 = a2 << v7;
  if ( v4 >= a2 << v7 )
  {
    LODWORD(a1) = 1 << v7;
    v4 -= v10;
    HIDWORD(a1) = (1 << v8) | (1u >> v9);
  }
  else
  {
    a1 = 0LL;
  }
  if ( v7 )
  {
    v11 = v10 >> 1;
    v12 = v7;
    do
    {
      while ( v4 >= v11 )
      {
        v4 = 2 * (v4 - v11) + 1;
        if ( !--v12 )
          goto LABEL_15;
      }
      v13 = (v4 + (unsigned int)v4) >> 32;
      LODWORD(v4) = 2 * v4;
      HIDWORD(v4) += v13;
      --v12;
    }
    while ( v12 );
LABEL_15:
    v3 = __CFADD__((_DWORD)a1, (_DWORD)v4);
    LODWORD(a1) = a1 + v4;
    LODWORD(v4) = ((unsigned int)v4 >> v7) | (HIDWORD(v4) << v9) | (HIDWORD(v4) >> v8);
    HIDWORD(a1) += v3 + HIDWORD(v4);
    HIDWORD(v4) >>= v7;
    a1 -= v4 << v7;
  }
LABEL_16:
  if ( a3 )
    *a3 = v4;
  return a1;
}

//----- (000602D8) --------------------------------------------------------
int __fastcall init(int a1, int a2, int a3)
{
  void **v6; // r5
  int i; // r4
  int (__fastcall *v8)(int, int, int); // t1
  int result; // r0

  init_proc();
  v6 = &off_7DF00;
  for ( i = 0; i != 1; ++i )
  {
    v8 = (int (__fastcall *)(int, int, int))*v6++;
    result = v8(a1, a2, a3);
  }
  return result;
}
// 7DF00: using guessed type void *off_7DF00;

//----- (00060318) --------------------------------------------------------
int __fastcall sub_60318(void (__fastcall *a1)(void *))
{
  int *v1; // r2

  v1 = &dword_7E294;
  if ( &dword_7E294 )
    v1 = (int *)dword_7E294;
  return j___cxa_atexit(a1, 0, v1);
}
// 7E294: using guessed type int dword_7E294;

//----- (00060334) --------------------------------------------------------
void term_proc()
{
  ;
}

// nfuncs=1627 queued=1278 decompiled=1278 lumina nreq=0 worse=0 better=0
// ALL OK, 1278 function(s) have been successfully decompiled
