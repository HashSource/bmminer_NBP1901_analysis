```c
int __fastcall loadPatternFile(int patternFilePath)
{
  _DWORD *contextPtr; // r10
  const char *pathStr; // r5
  int asicCount; // r9
  int asicIndex; // r6
  int workIndex; // r7
  unsigned int workLoadedCount; // r5
  int i; // r4
  int workCount; // r2
  int loadResult; // r4
  int asicTotal; // r9
  _DWORD *initialContextPtr; // r11
  int memoryBlockCount; // r0
  void *memoryBlock; // r0
  _DWORD *contextBlockPtr; // r3
  int context; // r3
  int fcloseResult; // r0
  FILE *fileStream; // [sp+Ch] [bp-82Ch] BYREF
  char logBuffer[2088]; // [sp+10h] [bp-828h] BYREF

  if ( (unsigned int)globalLogLevel > 4 )
  {
    strcpy(logBuffer, "[DEBUG] Free memory for sw sweep.\n");
    logMessage(4, logBuffer, 0);
  }
  contextPtr = (_DWORD *)globalContextPtr;
  if ( !globalContextPtr )
  {
    globalContextPtr = (int)calloc((size_t)&patternFileContextSize, 1u);
    if ( globalContextPtr )
    {
      asicTotal = getASICCount();
      if ( !asicTotal )
      {
        contextPtr = (_DWORD *)globalContextPtr;
        goto LABEL_4;
      }
      initialContextPtr = contextPtr;
      while ( 1 )
      {
        memoryBlockCount = getMemoryBlockCount();
        contextPtr = (_DWORD *)globalContextPtr;
        memoryBlock = malloc(416 * memoryBlockCount);
        contextBlockPtr = &contextPtr[(int)&contextArrayOffset + (int)initialContextPtr];
        initialContextPtr = (_DWORD *)((char *)initialContextPtr + 1);
        contextBlockPtr[1] = memoryBlock;
        if ( !memoryBlock )
          break;
        if ( (_DWORD *)asicTotal == initialContextPtr )
          goto LABEL_4;
      }
      if ( (unsigned int)globalLogLevel <= 3 )
      {
        goto LABEL_27;
      }
      strcpy(logBuffer, "Fail to allocate memory for works.\n");
      logMessage(3, logBuffer, 0);
      context = globalContextPtr;
    }
    else
    {
      if ( (unsigned int)globalLogLevel <= 3 )
        goto LABEL_28;
      strcpy(logBuffer, "Fail to allocate memory for sw sweep ctxt.\n");
      logMessage(3, logBuffer, 0);
      context = globalContextPtr;
    }
    if ( !context )
      goto LABEL_28;
    goto LABEL_27;
  }
LABEL_4:
  *contextPtr = patternFilePath;
  pathStr = *(const char **)globalContextPtr;
  fileStream = (FILE *)fopen64(*(_DWORD *)globalContextPtr, "r");
  if ( !fileStream )
  {
    if ( (unsigned int)globalLogLevel > 3 )
    {
      snprintf(logBuffer, 0x800u, "Fail to open pattern file %s.\n", pathStr);
      logMessage(3, logBuffer, 0);
    }
LABEL_16:
    triggerError(22, 255);
    loadResult = -1;
    if ( (unsigned int)globalLogLevel > 3 )
    {
      strcpy(logBuffer, "Load pattern file failed.\n");
      logMessage(3, logBuffer, 0);
    }
    goto LABEL_18;
  }
  asicCount = getASICCount();
  if ( asicCount )
  {
    asicIndex = 0;
    while ( 1 )
    {
      workCount = getMemoryBlockCount();
      if ( workCount )
      {
        workLoadedCount = 0;
        for ( i = 0; i != workCount; ++i )
        {
          workIndex = i;
          workLoadedCount += loadWork(&fileStream, asicIndex, workIndex, 8);
        }
      }
      else
      {
        workLoadedCount = 0;
      }
      if ( workLoadedCount < 8 * getMemoryBlockCount() )
        break;
      if ( asicCount == ++asicIndex )
        goto LABEL_13;
    }
    if ( (unsigned int)globalLogLevel > 3 )
    {
      fcloseResult = getMemoryBlockCount();
      snprintf(logBuffer, 0x800u, "No enough work, asic = %d, work_count = %d, work_count_target = %d.\n", asicIndex, workLoadedCount, 8 * fcloseResult);
      logMessage(3, logBuffer, 0);
    }
    fclose(fileStream);
    goto LABEL_16;
  }
LABEL_13:
  loadResult = 0;
  fclose(fileStream);
LABEL_18:
  finalProcessingStep1();
  finalProcessingStep2(4);
  return loadResult;
LABEL_27:
  cleanupResources();
LABEL_28:
  triggerError(13, 255);
  return -1;
}
```