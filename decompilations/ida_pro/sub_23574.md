```c
int __fastcall processMinerCommand(const char *commandStr, char *responseBuffer, size_t responseBufferSize)
{
  double tempValue; // d0
  char *parsedCommand; // r9
  int result; // r4
  int logFlag; // r0
  int tempRead; // r0
  int chainIndex; // r8
  int i; // r4
  int parsedValue; // r9
  int coreIndex; // r11
  unsigned int chainCount; // r8
  int responseLen; // r5
  char *token; // r0
  int tokenInt; // r10
  char *coreRegToken; // r0
  int regValue; // r9
  char *endPtr; // r0
  int resetCoreResult; // r0
  int resetChain; // r7
  int resetAsic; // r0
  char *resetToken; // r0
  int asicNum; // r0
  int chainId; // r9
  size_t remainingSize; // r1
  char *respPtr; // r0
  int nonceChainCount; // r10
  unsigned int asicIndex; // r4
  unsigned int nonceCount; // r6
  int nonceReadResult; // r0
  int totalNonces; // r7
  int asicValueStrLen; // r0
  int remainingBytes; // r1
  char *adcRespPtr; // r0
  char *chainCountPtr; // r9
  int adcResult; // r0
  int adcChainIndex; // [sp+0h] [bp-CB0h]
  char *strtokPtr; // [sp+0h] [bp-CB0h]
  int adcValue; // [sp+4h] [bp-CACh]
  char *powerToken; // [sp+3Ch] [bp-C74h]
  char *resetAsicStrPtr; // [sp+3Ch] [bp-C74h]
  char *flushPtr; // [sp+40h] [bp-C70h]
  size_t adcResponseLen; // [sp+44h] [bp-C6Ch]
  __int16 dashDelimiter; // [sp+5Ch] [bp-C54h] BYREF
  _DWORD delim[256]; // [sp+60h] [bp-C50h] BYREF
  int s[512]; // [sp+460h] [bp-850h] BYREF

  parsedCommand = (char *)(commandStr + 4);
  result = strncmp(commandStr + 4, "/rate", 5u);
  if (!result)
  {
    if (logEnabled && (loggingDebug || loggingVerbose || loggingThreshold > 6))
    {
      strcpy((char *)s, "cmd : get rate");
      logMessage(7, (const char *)s, 0);
    }
    logFlag = getRate();
    formatResponse(responseBuffer, responseBufferSize, logFlag);
    return result;
  }
  result = strncmp(parsedCommand, "/ideal_rate", 0xBu);
  if (!result)
  {
    if (logEnabled && (loggingDebug || loggingVerbose || loggingThreshold > 6))
    {
      strcpy((char *)s, "cmd : get ideal rate");
      logMessage(7, (const char *)s, 0);
    }
    logFlag = getIdealRate();
    formatResponse(responseBuffer, responseBufferSize, logFlag);
    return result;
  }
  result = strncmp(parsedCommand, "/max_rate", 9u);
  if (!result)
  {
    if (logEnabled && (loggingDebug || loggingVerbose || loggingThreshold > 6))
    {
      strcpy((char *)s, "cmd : get max rate");
      logMessage(7, (const char *)s, 0);
    }
    logFlag = getMaxRate();
    formatResponse(responseBuffer, responseBufferSize, logFlag);
    return result;
  }
  result = strncmp(parsedCommand, "/miner_status", 0xDu);
  if (!result)
  {
    if (logEnabled && (loggingDebug || loggingVerbose || loggingThreshold > 6))
    {
      strcpy((char *)s, "cmd : get miner status");
      logMessage(7, (const char *)s, 0);
      return result;
    }
    return 0;
  }
  result = strncmp(parsedCommand, "/productName", 0xCu);
  if (result)
  {
    result = strncmp(parsedCommand, "/get_sn", 7u);
    if (!result)
    {
      if (logEnabled && (loggingDebug || loggingVerbose || loggingThreshold > 6))
      {
        strcpy((char *)s, "cmd : get miner sn");
        logMessage(7, (const char *)s, 0);
      }
      if (hasSerialNumber)
        snprintf(responseBuffer, 0x100u, "%s", &serialNumber);
      else
        strcpy(responseBuffer, "no miner sn stored on board");
      return result;
    }
    result = strncmp(parsedCommand, "/set_sn", 7u);
    if (!result)
    {
      if (loggingDebug || loggingVerbose || loggingThreshold > 4)
      {
        strcpy((char *)s, "cmd : set miner sn, doesn't spport");
        logMessage(5, (const char *)s, 0);
      }
      snprintf(responseBuffer, 0x14u, "doesn't support sn set in Release mode");
      return result;
    }
    result = strncmp(parsedCommand, "/readreg", 8u);
    if (result)
    {
      result = strncmp(parsedCommand, "/readcorereg", 0xCu);
      if (result)
      {
        result = strncmp(parsedCommand, "/resetcore", 0xAu);
        if (result)
        {
          if (!strncmp(parsedCommand, "/nonce", 6u))
          {
            nonceChainCount = 0;
            coreIndex = 0;
            memset(s, 0, 0x100u);
            chainCount = 0;
            flushPtr = responseBuffer;
            responseLen = 0;
            adcResponseLen = responseBufferSize;
            do
            {
              if (isChainActive(chainCount))
              {
                remainingBytes = adcResponseLen - responseLen;
                respPtr = &flushPtr[responseLen];
                responseLen += 36;
                snprintf(respPtr, remainingBytes, "\n asic nonce number for chain[%d]...\n", chainCount);
                tokenInt = getChainAsicCount();
                if (tokenInt)
                {
                  asicIndex = 0;
                  do
                  {
                    coreIndex += getAsicNonceCount(chainCount, asicIndex);
                    nonceCount = asicIndex + 1;
                    nonceReadResult = getAsicNonceCount(chainCount, asicIndex);
                    totalNonces = snprintf((char *)s + nonceChainCount, 256 - nonceChainCount, "asic[%03d]=%-8d ", asicIndex, nonceReadResult);
                    adcResult = getChainAsicSkipCount();
                    skipAsicIndices(asicIndex + 1, adcResult);
                    nonceChainCount += totalNonces;
                    if (!remainingBytes)
                    {
                      resetAsic = getChainAsicSkipCount();
                      asicNum = getAsicSkipHashchain(asicIndex, resetAsic);
                      adcValue = coreIndex;
                      coreIndex = 0;
                      nonceChainCount = 0;
                      responseLen += snprintf(&flushPtr[responseLen], adcResponseLen - responseLen, "domain %02d %s total=%-8u\n", asicNum, s, adcValue);
                    }
                    ++asicIndex;
                  } while (nonceCount != tokenInt);
                }
              }
              ++chainCount;
            } while (chainCount != 4);
            return 0;
          }
          if (!strncmp(parsedCommand, "/adc", 4u))
          {
            chainIndex = 0;
            for (i = 0; i != 4; ++i)
            {
              if (isChainActive(i))
              {
                remainingSize = responseBufferSize - chainIndex;
                adcRespPtr = &responseBuffer[chainIndex];
                chainIndex += 23;
                snprintf(adcRespPtr, remainingSize, "\t\t\td0\td1\td2\td3\tsum\tavg\n");
                chainCountPtr = (char *)getChainAsicCount();
                if (chainCountPtr)
                {
                  for (j = 0; (char *)j != chainCountPtr; ++j)
                  {
                    readAsicVoltage(i, j, 0);
                    readAsicVoltage(i, j, 1);
                    readAsicVoltage(i, j, 2);
                    readAsicVoltage(i, j, 3);
                    calculateVoltageSum(i, j);
                    calculateVoltageAverage(i, j);
                    adcChainIndex = j;
                    chainIndex += snprintf(
                                  &responseBuffer[chainIndex],
                                  responseBufferSize - chainIndex,
                                  "chain %2d asic %03d adc:\t%.2f\t%.2f\t%.2f\t%.2f\t%.2f\t%.2f\n",
                                  i,
                                  adcChainIndex,
                                  tempValue,
                                  tempValue,
                                  tempValue,
                                  tempValue,
                                  tempValue,
                                  tempValue);
                  }
                }
              }
            }
            return 0;
          }
          result = strncmp(parsedCommand, "/flush", 6u);
          if (!result)
          {
            flushNonceBuffer();
            return result;
          }
          result = strncmp(parsedCommand, "/power", 6u);
          if (result)
            return -1;
          s[0] = 0;
          if (_isoc99_sscanf(parsedCommand, "/power-%d", s) == 1)
          {
            powerToken = s[0];
            if (s[0] <= 3)
            {
              powerDownChain(s[0]);
              snprintf(responseBuffer, responseBufferSize, "chain %d power is %.2f", powerToken, tempValue);
              return result;
            }
          }
          goto handleUnknownCommand;
        }
        strcpy((char *)delim, "-");
        if(!strtok(parsedCommand, (const char *)delim))
          goto handleUnknownCommand;
        resetToken = strtok(0, (const char *)delim);
        if (!resetToken)
          goto handleUnknownCommand;
        resetChain = strtol(resetToken, 0, 10);
        resetAsicStrPtr = strtok(0, (const char *)delim);
        if (!resetAsicStrPtr)
          goto handleUnknownCommand;
        resetAsic = strtol(resetAsicStrPtr, 0, 10);
        asicNum = resetAsic;
        if (loggingDebug || loggingVerbose || loggingThreshold > 4)
        {
          snprintf((char *)s, 0x800u, "recvBuf = %s, chain = %d, asic = %d\n", commandStr, resetChain, resetAsic);
          logMessage(5, (const char *)s, 0);
        }
        snprintf(responseBuffer, responseBufferSize, "reset chain %d asic %d core success!!!.", resetChain, asicNum);
      }
      else
      {
        dashDelimiter = 45;
        memset(delim, 0, sizeof(delim));
        if (!strtok(parsedCommand, (const char *)&dashDelimiter))
          goto handleUnknownCommand;
        coreRegToken = strtok(0, (const char *)&dashDelimiter);
        if (!coreRegToken)
          goto handleUnknownCommand;
        regValue = strtol(coreRegToken, 0, 10);
        token = strtok(0, (const char *)&dashDelimiter);
        if (!token)
          goto handleUnknownCommand;
        tokenInt = strtol(token, 0, 10);
        endPtr = strtok(0, (const char *)&dashDelimiter);
        if (!endPtr)
          goto handleUnknownCommand;
        resetCoreResult = strtol(endPtr, 0, 16);
        parsedValue = resetCoreResult;
        if (loggingDebug || loggingVerbose || loggingThreshold > 4)
        {
          snprintf((char *)s, 0x800u, "recvBuf = %s, chain = %d, asic = %d, reg = 0x%x\n", commandStr, regValue, tokenInt, resetCoreResult);
          logMessage(5, (const char *)s, 0);
        }
        resetChain = readAsicCoreRegister(parsedValue, tokenInt, regValue, (int)delim);
        if (resetChain)
        {
          snprintf(responseBuffer, responseBufferSize, "500 server error");
        }
        else
        {
          resetAsicStrPtr = (char *)getChainAsicCount();
          if ((int)resetAsicStrPtr > 0)
          {
            for (strtokPtr = 0; strtokPtr != resetAsicStrPtr; ++strtokPtr)
            {
              resetAsic = delim[(_DWORD)strtokPtr];
              strtokPtr = strtokPtr;
              resetChain += snprintf(
                        &responseBuffer[resetChain],
                        responseBufferSize - resetChain,
                        "asic\t%03d\tcore\t%03d\treg\t0x%02x\tval\t0x%08x\n",
                        tokenInt,
                        strtokPtr,
                        parsedValue,
                        resetAsic);
            }
          }
        }
      }
    }
    else
    {
      strcpy((char *)delim, "-");
      if (!strtok(parsedCommand, (const char *)delim))
        goto handleUnknownCommand;
      token = strtok(0, (const char *)delim);
      if (!token)
        goto handleUnknownCommand;
      chainId = strtol(token, 0, 10);
      powerToken = strtok(0, (const char *)delim);
      if (!powerToken)
        goto handleUnknownCommand;
      asicNum = strtol(powerToken, 0, 10);
      coreRegToken = strtok(0, (const char *)delim);
      if (!coreRegToken)
        goto handleUnknownCommand;
      regValue = strtol(coreRegToken, 0, 16);
      parsedValue = regValue;
      if (loggingDebug || loggingVerbose || loggingThreshold > 4)
      {
        snprintf((char *)s, 0x800u, "recvBuf = %s, chain = %d, asic = %d, reg = 0x%x\n", commandStr, chainId, asicNum, regValue);
        logMessage(5, (const char *)s, 0);
      }
      tempRead = readAsicRegister();
      adcResult = writeAsicRegister(parsedValue, asicNum * tempRead, chainId);
      snprintf(responseBuffer, responseBufferSize, "reg 0x%08x of asic %2d @ chain %2d, val = 0x%08x", parsedValue, asicNum, chainId, adcResult);
    }
  }
  else
  {
    if (logEnabled && (loggingDebug || loggingVerbose || loggingThreshold > 6))
    {
      strcpy((char *)s, "cmd : get miner type");
      logMessage(7, (const char *)s, 0);
    }
    snprintf(responseBuffer, 0x100u, "%s", minerType);
  }
  return result;

handleUnknownCommand:
  snprintf(responseBuffer, responseBufferSize, "404 not found");
  return result;
}
```