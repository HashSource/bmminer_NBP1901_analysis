```c
int __fastcall SetFrequencyStep(unsigned int testMode, unsigned int freqStart, unsigned int freqEnd)
{
  float freqStep = 100.0; // s0 - Assuming frequency step is 100 and set statically
  int chainIndex; // r4
  unsigned int freqDiff; // r3
  unsigned int freqRangeSteps; // r6
  float currentFreq; // s19
  float targetFreq; // s17
  float stepMultiplier; // s15
  float calculatedFreq; // s16
  int result;// r0
  unsigned int numberOfSteps; // [sp+1Ch] [bp-84Ch]
  char pllConfig[4]; // [sp+24h] [bp-844h] BYREF
  int pllIndex; // [sp+28h] [bp-840h] BYREF
  int pllValue; // [sp+2Ch] [bp-83Ch]
  char logBuffer[2104]; // [sp+30h] [bp-838h] BYREF

  if ( (unsigned int)globalLogLevel > 4 )
  {
    snprintf(logBuffer, 0x800u, "fixed step freq_start = %d, freq_end = %d, freq_step = %.2f\n", freqStart, freqEnd, freqStep);
    logMessage(4, logBuffer, 0);
  }
  for ( chainIndex = 0; chainIndex != 4; ++chainIndex )
  {
    if ( IsChainPresent(chainIndex) )
      ResetAsicChain(chainIndex, 1, 0, testMode);
  }
  freqDiff = (freqStart < freqEnd) ? (freqEnd - freqStart) : (freqStart - freqEnd);
  numberOfSteps = (unsigned int)(((float)(freqDiff + freqStep) - 0.01) / freqStep);
  if ( numberOfSteps )
  {
    freqRangeSteps = 1;
    currentFreq = (float)freqStart;
    targetFreq = (float)freqEnd;
    do
    {
      stepMultiplier = (float)freqRangeSteps;
      pllIndex = 0;
      pllValue = 0;
      if (freqStart >= freqEnd)
      {
        calculatedFreq = currentFreq - (stepMultiplier * freqStep);
        calculatedFreq = (targetFreq > calculatedFreq) ? calculatedFreq : (float)freqEnd;
      }
      else
      {
        calculatedFreq = currentFreq + (stepMultiplier * freqStep);
        calculatedFreq = (targetFreq < calculatedFreq) ? calculatedFreq : (float)freqEnd;
      }
      for ( int j = 0; j != 4; ++j )
      {
        if ( IsChainPresent(j) )
        {
          ApplyPLLConfig(&pllIndex, pllConfig, 0);
          pllValue = (pllConfig[0] << 16); // As per the original casting, BYTE2 macro might be used
          SetAsicFrequency(j, 1, 0, testMode, pllIndex, pllValue);
          if ( (unsigned int)globalLogLevel > 4 )
          {
            snprintf(logBuffer, 0x800u, "chain = %d set freq to %.2f", j, calculatedFreq);
            logMessage(4, logBuffer, 0);
          }
          ChainFrequencyBoundary[j] = (int)calculatedFreq;
          ChainFrequency[j] = (int)calculatedFreq;
        }
      }
      ++freqRangeSteps;
      usleep((__useconds_t)&FreqUpdateDelay);
    }
    while ( freqRangeSteps <= numberOfSteps );
  }
  for ( chainIndex = 0; chainIndex != 4; ++chainIndex )
  {
    result = IsChainPresent(chainIndex);
    if ( result )
    {
      ChainFrequencyBoundary[chainIndex] = freqEnd;
      ChainFrequency[chainIndex] = freqEnd;
    }
  }
  return result;
}
```