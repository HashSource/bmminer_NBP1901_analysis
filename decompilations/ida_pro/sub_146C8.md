```c
int __fastcall configureTemperatureSensor(int chainIndex)
{
  int sensorIndex; // r7
  int retryCount; // r4
  unsigned int sensorAddress; // r5
  int calibratedSensorAddress; // r6
  unsigned int sensorTypeTMP451; // r5
  unsigned int logLevel; // r3
  int sensorConfigIndex; // r6
  int externalModeSet; // r4
  char temperature; // r4
  char temperatureOffset; // r0
  int retryLimit; // [sp+Ch] [bp-84Ch]
  int sensorNumber; // [sp+10h] [bp-848h]
  int chainAndSensorIndex; // [sp+14h] [bp-844h]
  const char *sensorTypeString; // [sp+24h] [bp-834h]
  unsigned __int8 writeValueTMP451; // [sp+2Eh] [bp-82Ah] BYREF
  unsigned __int8 writeValueNCT218; // [sp+2Fh] [bp-829h] BYREF
  char messageBuffer[2088]; // [sp+30h] [bp-828h] BYREF

  sensorIndex = 0;
  sensorNumber = 4 * chainIndex;
  sensorTypeString = 0;
RETRY_SENSOR_CONFIG:
  if ( getSensorCount() <= sensorIndex )
  {
    logLevel = globalLogLevel;
    goto LOG_END_MESSAGE;
  }
  chainAndSensorIndex = 4 * sensorIndex;
  retryCount = 4;
  sensorAddress = (unsigned __int8)(*(_DWORD *)(sensorBaseAddress + 4 * sensorIndex) * calibrationFactor);
  submitI2CTransaction(chainIndex, sensorAddress, 0);
  usleep(10000u); // Delay for 10ms
  while ( 1 )
  {
    messageBuffer[0] = 0;
    readSensorData(chainIndex, sensorAddress, 254, 0, (unsigned __int8 *)messageBuffer);
    if ( messageBuffer[0] == 26 )
      break;
    if ( !--retryCount )
    {
      calibratedSensorAddress = 4;
      do
      {
        messageBuffer[0] = 0;
        readSensorData(chainIndex, sensorAddress, 254, 0, (unsigned __int8 *)messageBuffer);
        if ( messageBuffer[0] == 85 )
        {
          sensorTypeTMP451 = 1;
          sensorTypeString = "TMP451";
          goto IDENTIFY_SENSOR_TYPE;
        }
        --calibratedSensorAddress;
      }
      while ( calibratedSensorAddress );
      if ( (unsigned int)globalLogLevel > 3 )
      {
        snprintf(messageBuffer, 0x800u, "sensor %d @ chain %d manufacture id unknown", *(_DWORD *)(sensorBaseAddress + 4 * sensorIndex), chainIndex);
        logMessage(3, messageBuffer, 0);
      }
      return -1;
    }
  }
  sensorTypeTMP451 = 0;
  sensorTypeString = "NCT218";
IDENTIFY_SENSOR_TYPE:
  if ( (unsigned int)globalLogLevel > 3 )
  {
    snprintf(messageBuffer, 0x800u, "sensor %d @ chain %d is %s", *(_DWORD *)(sensorBaseAddress + 4 * sensorIndex), chainIndex, sensorTypeString);
    logMessage(3, messageBuffer, 0);
  }
  writeValueTMP451 = 4;
  if ( calibrationFactor )
  {
    if ( !checkI2CConnection() )
    {
      if ( (unsigned int)globalLogLevel <= 3 )
        return 0;
      snprintf(messageBuffer, 0x800u, "%s chain %d ,index %d not connected", "set_ext_mode", chainIndex, sensorIndex);
      logMessage(3, messageBuffer, 0);
      goto LOG_FAILURE_MESSAGE;
    }
    if ( !readSensorData(
            chainIndex,
            (unsigned __int8)(*(_DWORD *)(sensorBaseAddress + 4 * sensorIndex) * calibrationFactor),
            sensorDataTypeExtendedMode[sensorTypeTMP451],
            1,
            &writeValueTMP451) )
    {
      if ( (unsigned int)globalLogLevel <= 3 )
        return 0;
      snprintf(messageBuffer, 0x800u, "set ext mode failed for sensor %d @ chain %d", *(_DWORD *)(sensorBaseAddress + 4 * sensorIndex), chainIndex);
      logMessage(3, messageBuffer, 0);
      goto LOG_FAILURE_MESSAGE;
    }
    sensorConfigIndex = 6 * sensorIndex;
    retryLimit = 11;
    while ( 1 )
    {
      temperature = readTemperature(chainIndex, sensorIndex, sensorTypeTMP451, 0);
      *(_WORD *)(*(_DWORD *)(*(_DWORD *)(sensorDataAddress + sensorNumber) + 4) + sensorConfigIndex + 2) = temperature;
      temperatureOffset = readTemperature(chainIndex, sensorIndex, sensorTypeTMP451, 1);
      externalModeSet = (char)(temperature - temperatureOffset);
      *(_WORD *)(*(_DWORD *)(*(_DWORD *)(sensorDataAddress + sensorNumber) + 8) + sensorConfigIndex + 2) = temperatureOffset;
      if ( (unsigned __int8)(externalModeSet + 2) <= 4u )
      {
        if ( (unsigned int)globalLogLevel <= 4 )
        {
          goto INCREMENT_SENSOR_INDEX;
        }
        ++sensorIndex;
        snprintf(
          messageBuffer,
          0x800u,
          "sensor %d @ chain %d chip_temp_offset less than 2, no need to set offset",
          *(_DWORD *)(sensorBaseAddress + chainAndSensorIndex),
          chainIndex);
        logMessage(4, messageBuffer, 0);
        goto RETRY_SENSOR_CONFIG;
      }
      writeValueNCT218 = externalModeSet;
      if ( calibrationFactor )
      {
        if ( checkI2CConnection() )
        {
          if ( readSensorData(
                 chainIndex,
                 (unsigned __int8)(*(_DWORD *)(sensorBaseAddress + 4 * sensorIndex) * calibrationFactor),
                 sensorDataTypeOffset[sensorTypeTMP451],
                 1,
                 &writeValueNCT218) )
          {
            if ( (unsigned int)globalLogLevel > 3 )
            {
              snprintf(messageBuffer, 0x800u, "sensor %d @ chain %d, offset = %d", *(_DWORD *)(sensorBaseAddress + 4 * sensorIndex), chainIndex, (char)externalModeSet);
              goto LOG_OFFSET_MESSAGE;
            }
          }
          else if ( (unsigned int)globalLogLevel > 3 )
          {
            snprintf(messageBuffer, 0x800u, "set offset failed for sensor %d @ chain %d", *(_DWORD *)(sensorBaseAddress + 4 * sensorIndex), chainIndex);
            logMessage(3, messageBuffer, 0);
          }
        }
        else if ( (unsigned int)globalLogLevel > 3 )
        {
          snprintf(messageBuffer, 0x800u, "%s chain %d ,index %d not connected", "set_sensor_offset", chainIndex, sensorIndex);
LOG_OFFSET_MESSAGE:
          logMessage(3, messageBuffer, 0);
          if ( (externalModeSet & 0x80u) != 0 )
            externalModeSet = -(char)externalModeSet;
          if ( externalModeSet <= 2 )
            goto INCREMENT_SENSOR_INDEX;
          goto ADJUST_OFFSET;
        }
      }
      else if ( (unsigned int)globalLogLevel > 3 )
      {
        strcpy(messageBuffer, "cannot set ext mode before calibration");
        logMessage(3, messageBuffer, 0);
      }
      if ( (externalModeSet & 0x80u) != 0 )
        externalModeSet = -(char)externalModeSet;
      if ( externalModeSet <= 2 )
        goto INCREMENT_SENSOR_INDEX;
ADJUST_OFFSET:
      retryLimit = (unsigned __int8)(retryLimit - 1);
      if ( !retryLimit )
        goto INCREMENT_SENSOR_INDEX;
    }
  }
  if ( (unsigned int)globalLogLevel <= 3 )
    return 0;
  strcpy(messageBuffer, "cannot set ext mode before calibration");
  logMessage(3, messageBuffer, 0);
LOG_FAILURE_MESSAGE:
  if ( (unsigned int)globalLogLevel <= 3 )
    return 0;
  snprintf(messageBuffer, 0x800u, "sensor %d @ chain %d fail to set to ext mode", *(_DWORD *)(sensorBaseAddress + 4 * sensorIndex), chainIndex);
  logMessage(3, messageBuffer, 0);
  logLevel = globalLogLevel;
LOG_END_MESSAGE:
  if ( logLevel > 3 )
  {
    snprintf(messageBuffer, 0x800u, "chain %d temp sensor %s\n", chainIndex, sensorTypeString);
    logMessage(3, messageBuffer, 0);
  }
  return 0;

INCREMENT_SENSOR_INDEX:
  ++sensorIndex;
  goto RETRY_SENSOR_CONFIG;
}
```

In the above code, I have renamed the function and variables to better match their purpose and use within the function. The function now appears to be configuring the temperature sensor on a Bitcoin ASIC miner by Bitmain Antminer provided with a chain index and performing certain operations using the I2C protocol. The new names reflect actions such as configuring the sensor, checking sensor count, retrying the configuration, logging messages, and iterating over the sensors in the chain. Calibration factors, sensor data types, and offsets are taken into account as well.