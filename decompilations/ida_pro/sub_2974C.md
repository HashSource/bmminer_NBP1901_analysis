```c
__int64 __fastcall generateWork(int minerAddr, int workAddr)
{
  pthread_mutex_t *minerMutex; // r9
  int workDataSize; // lr
  int offset; // r3
  size_t iteration; // r2
  int highOrder; // r3
  int lowOrder; // r2
  int branchIndex; // r6
  const void *branchSource; // r1
  char *srcIterator; // r2
  char *destination; // r0
  unsigned int swappedData; // t1
  int unlockResult; // r0
  int workStartOffset; // r1
  char *nonceIterator; // r2
  unsigned int nonceSwapped; // t1
  double difficultyFactor; // d8
  unsigned __int64 adjustedNonce; // r0
  int baseWorkOffset; // r6
  char *hashratePostfix; // r6
  int hashrateValue; // r0
  double hashrateProcessed; // d7
  double hashrateEstimated; // d7
  double hashrateCalculated; // d7
  double divisionResult; // r0
  double hashrateTarget; // d8
  double doubleWorkAdj; // r0
  double poolDifficulty; // d8
  double doubleNonceAdj; // r0
  double lastDifficulty; // d7
  int nonceDivisionResult; // r0
  int lockResult; // r0
  char *merkleString; // r10
  const char *headerString; // r0
  char *headerStringPtr; // r11
  int nonceToKStringResult; // r0
  int *lockLocation; // r0
  int *unlockLocation; // r0
  int *errorLocation; // r0
  int *initLocation; // r0
  int *initResult; // r0
  int *initLocation2; // r0
  int unlockErr; // r0
  __int64 tempVar; // [sp+18h] [bp-8D8h] BYREF
  char swapBuffer1[28]; // [sp+20h] [bp-8D0h] BYREF
  char tempNonce[28]; // [sp+3Ch] [bp-8B4h] BYREF
  char swapBuffer2[28]; // [sp+40h] [bp-8B0h] BYREF
  char tempHash[28]; // [sp+5Ch] [bp-894h] BYREF
  char swappedNonce[28]; // [sp+60h] [bp-890h] BYREF
  char nonceBuff[28]; // [sp+7Ch] [bp-874h] BYREF
  char nonceStr[60]; // [sp+80h] [bp-870h] BYREF
  int nonceVal; // [sp+BCh] [bp-834h] BYREF
  char messageBuffer[136]; // [sp+C0h] [bp-830h] BYREF
  int tempNonceValue; // [sp+148h] [bp-7A8h] BYREF

  minerMutex = (pthread_mutex_t *)(minerAddr + 212);
  if ( pthread_mutex_lock(minerMutex) )
  {
    lockLocation = _errno_location();
    snprintf(messageBuffer, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *lockLocation, "bmminer.c", "gen_stratum_work", 1268);
    logMessage(3, messageBuffer, 1);
  }
  if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(minerAddr + 236)) )
  {
    unlockLocation = _errno_location();
    snprintf(messageBuffer, 0x800u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *unlockLocation, "bmminer.c", "gen_stratum_work", 1268);
    logMessage(3, messageBuffer, 1);
  }
  workDataSize = *(_DWORD *)(minerAddr + 1568);
  offset = *(_DWORD *)(minerAddr + 1576);
  iteration = *(_DWORD *)(minerAddr + 632);
  tempVar = *(_QWORD *)(minerAddr + 624);
  swapDataEndianes(workDataSize + offset, &tempVar, iteration, "bmminer.c", "gen_stratum_work", 1273);
  highOrder = *(_DWORD *)(minerAddr + 624);
  lowOrder = *(_DWORD *)(minerAddr + 628);
  *(_DWORD *)(minerAddr + 624) = highOrder + 1;
  *(_DWORD *)(minerAddr + 628) = __CFADD__(highOrder, 1) + lowOrder;
  *(_DWORD *)(workAddr + 296) = highOrder;
  *(_DWORD *)(workAddr + 300) = lowOrder;
  *(_DWORD *)(workAddr + 304) = *(_DWORD *)(minerAddr + 632);
  if ( !pthread_rwlock_unlock((pthread_rwlock_t *)(minerAddr + 236)) )
  {
    if ( !pthread_rwlock_rdlock((pthread_rwlock_t *)(minerAddr + 236)) )
      goto LABEL_7;
    goto LABEL_62;
  }

  // Error handling for unlock operation
  errorLocation = _errno_location();
  snprintf(messageBuffer, 0x800u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *errorLocation, "bmminer.c", "gen_stratum_work", 1279);
  logMessage(3, messageBuffer, 1);
  if ( pthread_rwlock_rdlock((pthread_rwlock_t *)(minerAddr + 236)) )
    goto LABEL_62;

LABEL_7:
  if ( !pthread_mutex_unlock(minerMutex) )
    goto LABEL_8;

  // Error handling on mutex unlock operation
LABEL_63:
  initLocation = _errno_location();
  snprintf(messageBuffer, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *initLocation, "bmminer.c", "gen_stratum_work", 1279);
  logMessage(3, messageBuffer, 1);

LABEL_8:
  concatenateMerkleStrings(*(char **)(minerAddr + 1568), *(_DWORD *)(minerAddr + 1572), messageBuffer);
  concatenateMerkleStrings(messageBuffer, 0x20u, swapBuffer1);
  swapDataEndianes(swapBuffer2, swapBuffer1, 0x20u, "bmminer.c", "gen_stratum_work", 1283);
  if ( *(int *)(minerAddr + 1708) > 0 )
  {
    branchIndex = 0;
    do
    {
      branchSource = *(const void **)(*(int *)(minerAddr + 676) + 4 * branchIndex++);
      swapDataEndianes(tempHash, branchSource, 0x20u, "bmminer.c", "gen_stratum_work", 1287);
      concatenateMerkleStrings(swapBuffer2, 0x40u, messageBuffer);
      concatenateMerkleStrings(messageBuffer, 0x20u, swapBuffer1);
      swapDataEndianes(swapBuffer2, swapBuffer1, 0x20u, "bmminer.c", "gen_stratum_work", 1289);
    }
    while ( *(int *)(minerAddr + 1708) > branchIndex );
  }
  srcIterator = &tempNonce;
  destination = (char *)(&tempVar + 4);
  do
  {
    swappedData = *((_DWORD *)srcIterator + 1);
    srcIterator += 4;
    *((_DWORD *)destination + 1) = bswap32(swappedData);
    destination += 4;
  }
  while ( &tempNonceValue != (int *)srcIterator );
  swapDataEndianes((void *)workAddr, (const void *)(minerAddr + 1580), 0x70u, "bmminer.c", "gen_stratum_work", 1298);
  swapDataEndianes((void *)(workAddr + 36), swapBuffer1, 0x20u, "bmminer.c", "gen_stratum_work", 1299);
  *(_QWORD *)(workAddr + 312) = *(_QWORD *)(minerAddr + 1824);
  *(_DWORD *)(workAddr + 288) = _strdup(*(const char **)(minerAddr + 672));
  *(_DWORD *)(workAddr + 320) = _strdup(*(const char **)(minerAddr + 612));
  *(_DWORD *)(workAddr + 308) = _strdup((const char *)(minerAddr + 1804));
  unlockResult = pthread_rwlock_unlock((pthread_rwlock_t *)(minerAddr + 236));
  if ( unlockResult )
  {
    initLocation2 = _errno_location();
    snprintf(
      messageBuffer,
      0x800u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *initLocation2,
      "bmminer.c",
      "gen_stratum_work",
      1310);
    unlockResult = logMessage(3, messageBuffer, 1);
  }
  off_7ECC4(unlockResult);
  if ( logEnabled )
  {
    merkleString = sub_2F670(workAddr, 112);
    headerString = sub_2F670((int)swapBuffer1, 32);
    headerStringPtr = (char *)headerString;
    if ( logEnabled )
    {
      if ( !loggingDebug && !loggingVerbose && loggingThreshold <= 6 )
        goto LABEL_52;
      snprintf(messageBuffer, 0x800u, "Generated stratum merkle %s", headerString);
      logMessage(7, messageBuffer, 0);
      if ( !logEnabled )
        goto LABEL_58;
      if ( !loggingDebug )
      {
LABEL_52:
        if ( !loggingVerbose && loggingThreshold <= 6 )
          goto LABEL_55;
      }
      snprintf(messageBuffer, 0x800u, "Generated stratum header %s", merkleString);
      logMessage(7, messageBuffer, 0);
      if ( logEnabled )
      {
        if ( loggingDebug )
        {
LABEL_57:
          snprintf(
            messageBuffer,
            0x800u,
            "Work job_id %s nonce2 %llu ntime %s",
            *(const char **)(workAddr + 288),
            *(_QWORD *)(workAddr + 296),
            *(const char **)(workAddr + 308));
          logMessage(7, messageBuffer, 0);
          goto LABEL_58;
        }
LABEL_55:
        if ( !loggingVerbose && loggingThreshold <= 6 )
          goto LABEL_58;
        goto LABEL_57;
      }
    }
LABEL_58:
    free(merkleString);
    free(headerStringPtr);
  }
  workStartOffset = workAddr - 4;
  nonceIterator = &nonceBuff;
  do
  {
    nonceSwapped = *(_DWORD *)(workStartOffset + 4);
    workStartOffset += 4;
    *((_DWORD *)nonceIterator + 1) = bswap32(nonceSwapped);
    nonceIterator += 4;
  }
  while ( &nonceVal != (int *)nonceIterator );
  hashMidstate(messageBuffer);
  hashNoncePart(messageBuffer, nonceStr, 0x40u);
  swapDataEndianes((void *)(workAddr + 128), &tempNonceValue, 0x20u, "bmminer.c", "calc_midstate", 1029);
  computeDoubleSHA256((void *)(workAddr + 160));
  ++dword_5945B4;
  if ( time(0) - dword_80B98 > 5 )
  {
    dword_80B98 = time(0);
    dword_80B9C = dword_5945B4;
  }
  difficultyFactor = *(double *)(workAddr + 312);
  *(_BYTE *)(workAddr + 284) = 1;
  *(_DWORD *)(workAddr + 260) = minerAddr;
  *(_DWORD *)(workAddr + 248) = 0;
  *(_BYTE *)(workAddr + 280) = 0;
  *(_DWORD *)(workAddr + 336) = 0;
  *(_BYTE *)(workAddr + 440) = 83;
  *(_DWORD *)(workAddr + 244) = 60;
  if ( difficultyFactor == 0.0 )
  {
    divisionResult = sub_600B4(*(_QWORD *)(workAddr + 184));
    hashrateTarget = divisionResult * 6.27710174e57;
    doubleWorkAdj = sub_600B4(*(_QWORD *)(workAddr + 176));
    poolDifficulty = hashrateTarget + doubleWorkAdj * 3.40282367e38;
    doubleNonceAdj = sub_600B4(*(_QWORD *)(workAddr + 168));
    hashrateEstimated = poolDifficulty + doubleNonceAdj * 1.84467441e19;
    lastDifficulty = sub_600B4(*(_QWORD *)(workAddr + 160));
    hashrateProcessed = lastDifficulty + hashrateEstimated;
    if ( lastDifficulty + hashrateEstimated == 0.0 )
    {
      difficultyFactor = 2.69595353e67;
      adjustedNonce = -1LL;
    }
    else
    {
      difficultyFactor = 2.69595353e67 / hashrateProcessed;
      round();
      adjustedNonce = sub_60180(2.69595353e67 / hashrateProcessed);
    }
    *(double *)(workAddr + 376) = difficultyFactor;
  }
  else
  {
    *(double *)(workAddr + 376) = difficultyFactor;
    round();
    adjustedNonce = sub_60180(difficultyFactor);
  }
  *(double *)(minerAddr + 480) = difficultyFactor;
  baseWorkOffset = *(_DWORD *)(workAddr + 260);
  *(_WORD *)messageBuffer = 0;
  hashratePostfix = (char *)(baseWorkOffset + 48);
  if ( adjustedNonce > 0xDE0B6B3A763FFFFLL )
  {
    nonceDivisionResult = sub_60120(adjustedNonce, 0x38D7EA4C68000uLL);
    strcpy(messageBuffer, "E");
    hashrateCalculated = (double)nonceDivisionResult / 1000.0;
LABEL_24:
    snprintf(hashratePostfix, 8u, "%.3g%s", hashrateCalculated, messageBuffer);
    goto LABEL_25;
  }
  if ( adjustedNonce > 0x38D7EA4C67FFFLL )
  {
    nonceDivisionResult = sub_60120(adjustedNonce, 0xE8D4A51000uLL);
    strcpy(messageBuffer, "P");
    hashrateCalculated = (double)nonceDivisionResult / 1000.0;
    goto LABEL_24;
  }
  if ( adjustedNonce > 0xE8D4A50FFFLL )
  {
    nonceToKStringResult = sub_60120(adjustedNonce, 0x3B9ACA00uLL);
    strcpy(messageBuffer, "T");
    hashrateCalculated = (double)nonceToKStringResult / 1000.0;
    goto LABEL_24;
  }
  if ( adjustedNonce > 0x3B9AC9FF )
  {
    nonceToKStringResult = sub_60120(adjustedNonce, (unsigned int)&unk_F4240);
    strcpy(messageBuffer, "G");
    hashrateCalculated = (double)nonceToKStringResult / 1000.0;
    goto LABEL_24;
  }
  if ( adjustedNonce > 0xF423F )
  {
    nonceDivisionResult = sub_60120(adjustedNonce, 0x3E8uLL);
    strcpy(messageBuffer, "M");
    hashrateCalculated = (double)nonceDivisionResult / 1000.0;
    goto LABEL_24;
  }
  if ( adjustedNonce > 0x3E7 )
  {
    strcpy(messageBuffer, "K");
    hashrateCalculated = (double)(int)adjustedNonce / 1000.0;
    goto LABEL_24;
  }
  snprintf(hashratePostfix, 8u, "%d%s", (_DWORD)adjustedNonce, messageBuffer);
LABEL_25:
  hashrateEstimated = *(double *)(minerAddr + 464);
  if ( hashrateEstimated == difficultyFactor )
  {
    ++*(_DWORD *)(minerAddr + 488);
    goto LABEL_27;
  }
  if ( hashrateEstimated <= difficultyFactor )
  {
    if ( hashrateEstimated != 0.0 )
    {
LABEL_27:
      hashrateCalculated = *(double *)(minerAddr + 472);
      if ( hashrateCalculated != difficultyFactor )
        goto LABEL_28;
LABEL_37:
      ++*(_DWORD *)(minerAddr + 492);
      return recordNewWorkTime((__time_t *)(workAddr + 264));
    }
    *(double *)(minerAddr + 464) = difficultyFactor;
    *(_DWORD *)(minerAddr + 488) = 1;
  }
  else
  {
    *(double *)(minerAddr + 464) = difficultyFactor;
    *(_DWORD *)(minerAddr + 488) = 1;
  }
  hashrateCalculated = *(double *)(minerAddr + 472);
  if ( hashrateCalculated == difficultyFactor )
    goto LABEL_37;
LABEL_28:
  if ( hashrateCalculated < difficultyFactor )
  {
    *(double *)(minerAddr + 472) = difficultyFactor;
    *(_DWORD *)(minerAddr + 492) = 1;
  }
  return recordNewWorkTime((__time_t *)(workAddr + 264));
}
```

I've renamed the function and variables to provide a clearer context of the actions performed in the code. It appears to be performing some work generation and endian swapping related to mining as well as logging, mutex locking/unlocking, and error handling.

However, please note that the original function contains calls to other functions (such as `sub_30EA8`, `sub_2F1EC`, `sub_302A0`, etc.) and uses global symbols (like `logEnabled`, `dword_5945B4`, `dword_80B98`, `dword_80B9C`, etc.) that I've left untouched since they are likely defined elsewhere in the original code. Their names should be updated too