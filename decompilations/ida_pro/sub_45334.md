```c
int __fastcall sendJobToMiner(int jobData)
{
  size_t dataLength; // r5
  unsigned int paddedLength; // r7
  size_t tmpLength; // r7
  _BYTE *buffer; // r0
  _BYTE *paddedData; // r6
  _BYTE *dataEnd; // r3
  char *checkPos; // r8
  char *dataIter; // r0
  char *dataPtr; // r3
  int checkIndex; // r6
  int checkOffset; // r2
  char currentByte; // t1
  int position; // r5
  size_t finalLength; // r7
  int checkValue; // r12
  int byte1; // t1
  int byte2; // lr
  int byte3; // t1
  unsigned int merkleNum; // r1
  size_t registerIndex; // r2
  _DWORD *merkleData; // r3
  int dword2; // lr
  int dword3; // r12
  int dword4; // r0
  int dword5; // lr
  int dword6; // r12
  int dword7; // r0
  int someValue; // r1
  int additionalData; // r1
  int anotherValue; // r0
  int *regData; // r12
  int dataDwords; // lr
  int nextDword; // r3
  int adjustedDword; // r3
  unsigned int workCutOff; // r1
  int extraNonce2; // r7
  int delayTime; // r6
  _BOOL4 hasJobData; // r3
  int someFlag; // r4
  int result; // r0
  int tmpStorage; // [sp+Ch] [bp-5Ch]
  void *bufferAllocation; // [sp+10h] [bp-58h]
  size_t bufferSize; // [sp+14h] [bp-54h]
  int regValue; // [sp+1Ch] [bp-4Ch] BYREF
  int hashState[18]; // [sp+20h] [bp-48h] BYREF

  memset(hashState, 0, 0x20u);
  dataLength = *(_DWORD *)(jobData + 12);
  tmpStorage = globalVar1;
  paddedLength = dataLength & 0xFFFFFFC0;
  if ( globalVar1 == globalVar2 )
    tmpStorage = globalVar3;
  if ( (*(_DWORD *)(jobData + 12) & 0x3Fu) <= 0x37 )
    tmpLength = paddedLength + 64;
  else
    tmpLength = paddedLength + 128;
  buffer = calloc(tmpLength, 1u);
  paddedData = buffer;
  bufferAllocation = buffer;
  if ( !buffer )
    return -4;
  memcpy(buffer, *(const void **)(jobData + 8), dataLength);
  dataEnd = &paddedData[tmpLength];
  paddedData[dataLength] = 0x80;
  *((_DWORD *)dataEnd - 2) = 0;
  *((_DWORD *)dataEnd - 1) = bswap32(8 * dataLength);
  if ( tmpLength )
  {
    checkPos = paddedData - 1;
    dataIter = &paddedData[tmpLength - 1];
    dataPtr = paddedData - 1;
    checkIndex = tmpStorage - 1;
    checkOffset = tmpStorage - 1;
    do
    {
      currentByte = *++dataPtr;
      *(_BYTE *)++checkOffset = currentByte;
    }
    while ( dataIter != dataPtr );
    bufferSize = tmpLength;
    position = 0;
    finalLength = tmpStorage - 1 + tmpLength;
    do
    {
      byte1 = *(unsigned __int8 *)++checkIndex;
      checkValue = byte1;
      byte3 = (unsigned __int8)*++checkPos;
      byte2 = byte3;
      if ( checkValue != byte3 )
        printf(
          "%s: coinbase_padding_in_ddr[%d] = 0x%x, but *(coinbase_padding + %d) = 0x%x",
          "dhash_send_job",
          position,
          checkValue,
          position,
          byte2);
      ++position;
    }
    while ( finalLength != checkIndex );
    tmpLength = bufferSize;
  }
  if ( *(_DWORD *)(jobData + 20) )
  {
    merkleNum = 0;
    registerIndex = tmpStorage + tmpLength;
    do
    {
      registerIndex += 32;
      merkleData = (_DWORD *)(*(_DWORD *)(jobData + 16) + 32 * merkleNum++);
      dword2 = merkleData[1];
      dword3 = merkleData[2];
      dword4 = merkleData[3];
      *(_DWORD *)(registerIndex - 32) = *merkleData;
      *(_DWORD *)(registerIndex - 28) = dword2;
      *(_DWORD *)(registerIndex - 24) = dword3;
      *(_DWORD *)(registerIndex - 20) = dword4;
      dword5 = merkleData[5];
      dword6 = merkleData[6];
      dword7 = merkleData[7];
      *(_DWORD *)(registerIndex - 16) = merkleData[4];
      *(_DWORD *)(registerIndex - 12) = dword5;
      *(_DWORD *)(registerIndex - 8) = dword6;
      *(_DWORD *)(registerIndex - 4) = dword7;
    }
    while ( *(_DWORD *)(jobData + 20) > merkleNum );
  }
  setupHardware1();
  if ( tmpStorage == globalVar1 )
    someValue = globalVar4 + 0x200000;
  else
    someValue = globalVar4 + 2162688;
  writeRegister(41, someValue);
  readRegister(41, &regValue);
  writeRegister(44, *(_DWORD *)(jobData + 32));
  readRegister(44, &regValue);
  if ( *(_DWORD *)jobData )
    additionalData = 1;
  else
    additionalData = *(_DWORD *)(jobData + 4);
  updateHardware2(*(_DWORD *)(jobData + 36), additionalData, *(_DWORD *)(jobData + 40));
  memset(hashState, 0, 0x20u);
  anotherValue = *(_DWORD *)(jobData + 44);
  regData = &regValue;
  dataDwords = anotherValue + 32;
  do
  {
    nextDword = *(unsigned __int8 *)(anotherValue + 2);
    anotherValue += 4;
    regData[1] = (nextDword << 16) | (*(unsigned __int8 *)(anotherValue - 1) << 24) | *(unsigned __int8 *)(anotherValue - 4) | (*(unsigned __int8 *)(anotherValue - 3) << 8);
    ++regData;
  }
  while ( anotherValue != dataDwords );
  setupHardware3((int)hashState);
  writeRegister(46, *(_DWORD *)(jobData + 24));
  readRegister(46, &regValue);
  writeRegister(47, *(_DWORD *)(jobData + 28));
  readRegister(47, &regValue);
  writeRegister(
    36,
    (unsigned __int16)(*(_WORD *)(jobData + 56) << 8) | (*(_DWORD *)(jobData + 52) << 16) | (unsigned __int8)(tmpLength >> 6));
  readRegister(36, &regValue);
  adjustedDword = *(_DWORD *)(jobData + 68);
  hashState[0] = *(_DWORD *)(jobData + 64);
  hashState[1] = adjustedDword;
  setupHardware4(hashState);
  setupHardware5(*(_DWORD *)(jobData + 20));
  writeRegister(42, (unsigned __int16)(tmpLength + 32 * *(_WORD *)(jobData + 20)));
  readRegister(42, &regValue);
  usleep(0x3E8u);
  writeRegister(20, *(_DWORD *)(jobData + 72) & 0x1FFFF | 0x80000000);
  readRegister(20, &regValue);
  workCutOff = *(_DWORD *)(jobData + 4);
  extraNonce2 = *(_DWORD *)jobData;
  delayTime = *(_DWORD *)(jobData + 76);
  hasJobData = workCutOff > 1;
  if ( *(_DWORD *)jobData )
    hasJobData = 0;
  if ( hasJobData )
  {
    extraNonce2 = 0;
    someFlag = (workCutOff << 8) & 0xF00;
  }
  else
  {
    someFlag = 256;
    if ( extraNonce2 )
      extraNonce2 = 0x4000;
  }
  if ( delayTime )
  {
    delayTime = 128;
    setupHardWareDelay();
  }
  regValue = 0;
  readRegister(35, &regValue);
  writeRegister(35, regValue & 0xFFFF709F | 0x8060 | extraNonce2 | someFlag | delayTime);
  free(bufferAllocation);
  result = 0;
  globalVar2 = tmpStorage;
  return result;
}
```