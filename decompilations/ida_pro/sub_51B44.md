```c
int __fastcall setRegisterValue(int registerLevel, unsigned int chainIndex, unsigned int asicIndex, unsigned int registerAddress, int value)
{
  unsigned int registerSlot; // r4
  int errorCode; // r4
  unsigned int cacheIndex; // r4
  unsigned int cacheAddress; // r2
  unsigned int cacheOffset; // r3
  char *startAddress; // r2
  char *endAddress; // r3

  // Check for valid chain index
  if (chainIndex > 3)
    return -1;
  // Check for valid ASIC index
  if (asicIndex > 0xFF)
    return -2;
  // Calculate register slot and check if it's within valid range
  registerSlot = registerAddress >> 2;
  if (registerSlot > 0x40)
    return -3;
  pthread_mutex_lock(&mutexRegisterCache);
  
  if (registerLevel)
  {
    if (registerLevel != 1)
    {
      errorCode = -6; // Invalid register level
      pthread_mutex_unlock(&mutexRegisterCache);
      goto log_error;
    }
    // Calculate the cache index and verify the cached register address
    cacheIndex = registerSlot + ((asicIndex + (chainIndex << 8)) << 6);
    if (cacheL2[2 * cacheIndex] != registerAddress)
    {
      errorCode = -5;
      pthread_mutex_unlock(&mutexRegisterCache);
      goto log_error;
    }
    // Store the value into L2 cache if the register addresses match
    cacheL2[2 * cacheIndex + 1] = value;
    pthread_mutex_unlock(&mutexRegisterCache);
    return 0;
  }
  else
  {
    // Calculate the cache address and verify the cached register address
    cacheAddress = registerSlot + (chainIndex << 6);
    if (cacheL1[2 * cacheAddress] != registerAddress)
    {
      errorCode = -4;
      pthread_mutex_unlock(&mutexRegisterCache);
      goto log_error;
    }
    // Store the value into the L1 cache
    cacheOffset = 2 * (registerSlot + (chainIndex << 14));
    cacheL1[2 * cacheAddress + 1] = value;
    
    // Synchronize the value across all slots in the L2 cache that match this L1 cache slot
    startAddress = (char *)&cacheL2Shadow + cacheOffset * 4;
    endAddress = (char *)&cacheL2[cacheOffset];
    do
    {
      *((_DWORD *)endAddress + 1) = value;
      endAddress += 512; // Move to next slot
    }
    while (endAddress != startAddress);
    
    // Unlock the mutex and return successfully
    pthread_mutex_unlock(&mutexRegisterCache);
    return 0;
  }

log_error:
  printf(
    "[%s] level::%d, which_chain::%u, which_asic::%u, register_address::%02x failed.\r\n",
    "set_register_cache_value",
    registerLevel,
    chainIndex,
    asicIndex,
    registerAddress);
  return errorCode;
}
```

- Changed the function name to `setRegisterValue` for clarity.
- Renamed variables (`a1` through `a5`) to illustrate their purpose.
- Renamed `sub_51B44` to `setRegisterValue` to reflect the function's action.
- Renamed `stru_5059C8` to `mutexRegisterCache` to indicate this is a mutex for register cache.
- Renamed `dword_5059E0` to `cacheL2` and `dword_5051C8` to `cacheL1` to indicate they are level 2 and level 1 caches.
- Renamed `unk_5259E0` to `cacheL2Shadow` to suggest this is a related shadow structure for the level 2 cache.
- Renamed `v5`, `v12`, `v13`, `v14`, `v15`, and `v16` for more meaningful variable names that help understand the data they handle.
- The label `LABEL_7` has been renamed to `log_error` to improve readability.
- Added comments for clarification and understanding of what each part of the code is doing.