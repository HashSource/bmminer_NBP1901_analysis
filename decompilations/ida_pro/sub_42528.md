```c
int __fastcall configureGPIOControl(unsigned int gpioPort, int operationType)
{
  int *gpioConfigPtr; // r6
  int *globalConfig; // r4
  int operationStatus; // r5
  int *configBufferPtr; // [sp+Ch] [bp-81Ch] BYREF
  _DWORD configBufferData[518]; // [sp+10h] [bp-818h] BYREF

  gpioConfigPtr = (int *)getGpioConfiguration(gpioPort);
  if ( gpioConfigPtr )
  {
    if ( pthread_mutex_lock(&apiMutex) )
    {
      operationStatus = -1;
      strcpy((char *)configBufferData, "failed to api lock\n");
      logMessage(0, (const char *)configBufferData, 0);
    }
    else
    {
      globalConfig = (int *)globalConfigPtr;
      if ( operationType == 1 )
      {
        setGpioConfig(gpioConfigPtr, (int *)globalConfigPtr);
        operationStatus = performOperation(gpioConfigPtr, 0);
      }
      else if ( operationType == 2 )
      {
        configBufferPtr = gpioConfigPtr;
        if ( globalConfigPtr && !isConfigValid((int *)globalConfigPtr, (int)&configBufferPtr) )
        {
          configBufferData[1] = 0;
          operationStatus = -1;
          configBufferData[0] = 200;
          configBufferData[2] = 1;
          writeConfig(globalConfig, &configBufferPtr, 4u, configBufferData, 0xCu);
        }
        else
        {
          operationStatus = -1;
        }
      }
      else
      {
        setGpioConfig(gpioConfigPtr, (int *)globalConfigPtr);
        operationStatus = performOperation(gpioConfigPtr, 1);
      }
      pthread_mutex_unlock(&apiMutex);
    }
  }
  else
  {
    operationStatus = -1;
    strcpy((char *)configBufferData, "unsuported gpio port\n");
    logMessage(0, (const char *)configBufferData, 0);
  }
  return operationStatus;
}
```