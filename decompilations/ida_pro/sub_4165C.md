```c
int __fastcall clearUartTxFifo(int chain_id)
{
  pthread_mutex_t *chain_mutex; // r7
  int send_fifo_space; // r4
  unsigned int send_fifo; // r3
  int uart_status_reg; // [sp+Ch] [bp-82Ch] BYREF
  int tx_control_reg; // [sp+10h] [bp-828h] BYREF
  int tx_fifo_reg; // [sp+14h] [bp-824h] BYREF
  unsigned int tx_fifo_space_mask; // [sp+18h] [bp-820h] BYREF
  int tx_fifo_bitpos; // [sp+1Ch] [bp-81Ch] BYREF
  char log_buffer[2072]; // [sp+20h] [bp-818h] BYREF

  chain_mutex = (pthread_mutex_t *)((char *)&unk_504CE8 + 24 * chain_id);
  uart_status_reg = 0;
  tx_control_reg = 0;
  tx_fifo_reg = 0;
  tx_fifo_space_mask = 0;
  tx_fifo_bitpos = 0;
  pthread_mutex_lock(chain_mutex);
  if ( getUartSendAddressInfo(chain_id, &tx_fifo_bitpos, &uart_status_reg, &tx_control_reg, &tx_fifo_reg) )
  {
    snprintf(log_buffer, 0x800u, "get_send_address_info error, chain_id = %d\n", chain_id);
  }
  else
  {
    send_fifo_space = 21; // Retry limit
    do
    {
      readRegister(uart_status_reg, &tx_fifo_space_mask);
      send_fifo = (unsigned __int8)(tx_fifo_space_mask >> tx_fifo_bitpos);
      tx_fifo_space_mask = send_fifo;
      if ( send_fifo == 255 )
        return pthread_mutex_unlock(chain_mutex);
      printf("%s: waiting fpga uart%d clear send fifo space ...\n", "clear_uart_tx_fifo", chain_id);
      writeRegister(tx_control_reg, tx_fifo_space_mask | 0x80000000);
      usleep(0xBB8u);
      --send_fifo_space;
    }
    while ( send_fifo_space );
    snprintf(log_buffer, 0x800u, "%s: uart%d always does not have enough send fifo space, break\n", "clear_uart_tx_fifo", chain_id);
  }
  logMessage(0, log_buffer, 0);
  return pthread_mutex_unlock(chain_mutex);
}
```