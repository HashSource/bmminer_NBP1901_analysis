```c
int __fastcall sendJobToMiner(unsigned __int8 *jobBuffer)
{
  int jobLength; // r8
  size_t bufferSize; // r8
  unsigned __int8 *buffer; // r0
  unsigned __int8 *allocatedBuffer; // r6
  int versionNumber; // r2
  int currentVersion; // r1
  int jobVersion; // r3
  int maskNumber; // r2
  int globalBitMask; // r3
  unsigned __int8 jobControlByte; // r2
  int jobDataOffset; // r1
  int jobStartIndex; // r0
  int chipParameter; // r3
  int jobEndIndex; // r0
  int chipCommand; // r3
  int jobCommandParam; // r0
  int paramLength; // lr
  __int64 rollingTime; // r2
  int checksum; // r0
  int timestamp; // r0
  int anotherParam; // r0
  int additionalData[16]; // [sp+10h] [bp-878h] BYREF
  __int64 additionalTime; // [sp+50h] [bp-838h]
  int additionalIndex; // [sp+58h] [bp-830h]
  int additionalChipParam; // [sp+5Ch] [bp-82Ch]
  char message[2088]; // [sp+60h] [bp-828h] BYREF

  if ( *jobBuffer != 82 )
  {
    if ( !logEnabled || !loggingDebug && !loggingVerbose && loggingThreshold <= 6 )
      return -1;
    snprintf(message, 0x800u, "%s: SEND_JOB_TYPE is wrong : 0x%x\n", "sendJobToMiner", *jobBuffer);
    logMessage(7, message, 0);
    return -1;
  }
  jobLength = *((_DWORD *)jobBuffer + 1);
  if ( logEnabled && (loggingDebug || loggingVerbose || loggingThreshold > 6) )
  {
    snprintf(message, 0x800u, "%s: len = 0x%x\n", "sendJobToMiner", *((_DWORD *)jobBuffer + 1));
    logMessage(7, message, 0);
  }
  bufferSize = jobLength + 8;
  buffer = (unsigned __int8 *)calloc(bufferSize, 1u);
  allocatedBuffer = buffer;
  if ( !buffer )
  {
    if ( !logEnabled || !loggingDebug && !loggingVerbose && loggingThreshold <= 6 )
      return -2;
    snprintf(message, 0x800u, "%s: malloc buffer failed.\n", "sendJobToMiner");
    logMessage(7, message, 0);
    return -2;
  }
  memcpy(buffer, jobBuffer, bufferSize);
  if ( !asicBoostEnabled )
  {
    if ( (unsigned int)globalLogLevel > 3 )
    {
      strcpy(message, "only support asic boost");
      logMessage(3, message, (unsigned __int8)asicBoostEnabled);
    }
    goto LABEL_FreeBufferAndExit;
  }
  versionNumber = allocatedBuffer[80];
  currentVersion = versionThreshold;
  if ( allocatedBuffer[80] )
  {
    maskNumber = *((_DWORD *)allocatedBuffer + 22);
    jobVersion = *((_DWORD *)allocatedBuffer + 21);
    jobBitMask = maskNumber;
    if ( jobVersion == versionThreshold )
      goto LABEL_VersionCheck;
  }
  else
  {
    jobVersion = 1;
    jobVersion = 1;
    jobBitMask = versionNumber;
    if ( versionThreshold == 1 )
      goto LABEL_FreeBufferAndExit;
  }
  if ( (unsigned int)globalLogLevel > 3 )
  {
    snprintf(message, 0x800u, "Version num %d\n", jobVersion);
    logMessage(3, message, 0);
  }
  currentVersion = jobVersion;
  versionThreshold = jobVersion;
LABEL_VersionCheck:
  if ( ((currentVersion - 4) & 0xFFFFFFFB) != 0 )
  {
LABEL_FreeBufferAndExit:
    free(allocatedBuffer);
    return 0;
  }
  globalBitMask = jobBitMask;
  if ( maskThreshold != jobBitMask )
  {
    if ( (unsigned int)globalLogLevel > 3 )
    {
      snprintf(message, 0x800u, "Mask num 0x%x\n", jobBitMask);
      logMessage(3, message, 0);
      globalBitMask = jobBitMask;
      currentVersion = jobVersion;
    }
    maskThreshold = globalBitMask;
    adjustChipFrequency(globalFrequency, currentVersion, 90);
  }
  jobControlByte = allocatedBuffer[9];
  if ( (jobControlByte & 2) != 0 )
  {
    updateChipFrequency(allocatedBuffer[10]);
    jobControlByte = allocatedBuffer[9];
  }
  jobDataOffset = *((unsigned __int16 *)allocatedBuffer + 30);
  additionalIndex = globalAdditionalData;
  jobStartIndex = *((_DWORD *)allocatedBuffer + 3);
  additionalData[4] = (int)&jobBuffer[jobDataOffset + 96];
  chipParameter = *((unsigned __int16 *)allocatedBuffer + 33);
  additionalData[8] = jobStartIndex;
  jobEndIndex = *((_DWORD *)allocatedBuffer + 14);
  additionalData[5] = chipParameter;
  checksum = *((_DWORD *)allocatedBuffer + 14);
  additionalData[7] = jobEndIndex;
  anotherParam = *((unsigned __int16 *)allocatedBuffer + 32);
  additionalData[10] = jobBitMask;
  additionalData[14] = anotherParam;
  chipCommandParam = *((_DWORD *)allocatedBuffer + 4);
  additionalData[11] = (int)(allocatedBuffer + 20);
  paramLength = *((unsigned __int16 *)allocatedBuffer + 31);
  additionalChipParam = jobControlByte & 1;
  additionalData[13] = paramLength;
  rollingTime = *((_QWORD *)allocatedBuffer + 9);
  timestamp = *((_DWORD *)allocatedBuffer + 13);
  additionalData[1] = jobVersion;
  additionalData[3] = jobDataOffset;
  additionalData[2] = (int)(jobBuffer + 96);
  additionalData[9] = chipCommandParam;
  additionalTime = rollingTime;
  additionalData[12] = 32;
  additionalData[6] = timestamp;
  additionalData[0] = 0;
  if ( !chipStatusInitialized )
  {
    firmwareControl1 = initializeFirmwareControl1();
    sendFirmwareControl1(firmwareControl1 | 0x10000);
    firmwareControl2 = initializeFirmwareControl2();
    sendFirmwareControl2(firmwareControl2 | 0x80);
    chipStatusInitialized = 1;
  }
  if ( (unsigned int)globalLogLevel > 4 )
  {
    snprintf(message, 0x800u, "start to send job, mid_auto_gen = %d", additionalData[0]);
    logMessage(4, message, 0);
  }
  sendJobToASICChip((int)additionalData);
  free(allocatedBuffer);
  if ( logEnabled && (loggingDebug || loggingVerbose || loggingThreshold > 6) )
  {
    snprintf(message, 0x800u, "--- %s end\n", "sendJobToMiner");
    logMessage(7, message, 0);
  }
  cooldownChip(globalCooldownChip);
  finalizeJobSubmission();
  return 0;
}
```