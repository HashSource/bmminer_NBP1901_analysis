/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

int init_proc();
// int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);
// void abort(void);
// int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
// int memcmp(const void *s1, const void *s2, size_t n);
// int __fastcall _libc_start_main(int (__fastcall *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end);
// int __fastcall _isoc99_sscanf(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int vsnprintf(char *s, size_t maxlen, const char *format, __gnuc_va_list arg);
// char *strncpy(char *dest, const char *src, size_t n);
// ssize_t recv(int fd, void *buf, size_t n, int flags);
// void *calloc(size_t nmemb, size_t size);
// void *memset(void *s, int c, size_t n);
// int usleep(__useconds_t useconds);
// void free(void *ptr);
// int pthread_mutex_unlock(pthread_mutex_t *mutex);
// int pthread_mutex_lock(pthread_mutex_t *mutex);
// size_t strlen(const char *s);
// int pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
// void *memcpy(void *dest, const void *src, size_t n);
// int pthread_cond_signal(pthread_cond_t *cond);
// int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize);
// time_t time(time_t *timer);
// int pthread_attr_init(pthread_attr_t *attr);
// int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
// ssize_t send(int fd, const void *buf, size_t n, int flags);
// int prctl(int option, ...);
// int snprintf(char *s, size_t maxlen, const char *format, ...);
// int pthread_detach(pthread_t th);
// char *_strdup(const char *s);
// int strcmp(const char *s1, const char *s2);
// int *_errno_location(void);
// pthread_t pthread_self(void);
// int sprintf(char *s, const char *format, ...);
void __noreturn start(void (*a1)(void), int a2, int a3, int a4, ...);
int check_gmon_start();
void __fastcall log_event(int, const char *, int);
int __fastcall initialize_and_process_data(int, size_t n, int);
int return_zero();
_BYTE *__fastcall binary_to_hex_string(int, int);
__int64 __fastcall get_hardware_timestamp(__time_t *);
void __fastcall log_memcpy_error(void *, const void *, size_t, int, int, int);
int __fastcall calculate_hashrate_metrics(int);
void __fastcall calculate_midstate(int);
void __fastcall clear_miner_data_if_not_null(void ***, const char *, const char *, int);
void __fastcall process_work_discard(_DWORD *work_info, const char *a2, const char *a3, int a4);
int __fastcall calculate_target_hash(int);
void __fastcall __noreturn shutdown_miner(int, int);
__int64 __fastcall generate_stratum_work(int miner_data, int work_data);
int __fastcall check_work_staleness(int, int);
void discard_stale_shares();
char *__fastcall find_character(char *result, __int16, unsigned int);
unsigned int __fastcall find_optimal_split_index(int, unsigned int, int *);
unsigned int __fastcall find_matching_sequence(int, int, void *s1, unsigned int);
unsigned int __fastcall memmem(char *a1, unsigned int a2, unsigned __int8 *a3, unsigned int a4);
int __fastcall handle_client_connection(int);
int __fastcall initialize_network_thread(int);
int __fastcall hash_calculate(unsigned __int16 *, unsigned int, int);
int __fastcall find_target_entry(int, int *, char *s2, int);
int __fastcall insert_or_update_node(int *, char *, int);
int __fastcall get_error_description(int result);
int __fastcall check_result_and_perform_action(int result);
_DWORD *__fastcall process_bitmain_miner(_DWORD *result);
int format_log_message(int result, int, int, int, int, char *format, ...);
int __fastcall init(int a1, int a2, int a3);
void nullsub_9();
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN main;
void *off_64EE0 = (void *)0x15EB9; // weak
int dword_657B8 = 5; // weak
int (__fastcall *off_658DC)(_DWORD) = &return_zero; // weak
int dword_664C8 = 25000; // weak
int (__fastcall *off_664CC)(_DWORD) = &malloc; // weak
char byte_66640; // weak
char byte_66641; // weak
int dword_66A80; // weak
int dword_66B5C; // weak
int dword_66BEC; // weak
int dword_66BF0; // weak
int dword_66BF4; // weak
int dword_68748; // weak
int dword_6874C; // weak
_UNKNOWN unk_68770; // weak
_UNKNOWN unk_6C770; // weak
char s2[17404]; // idb
int dword_70B70; // weak
char byte_70CE8; // weak
pthread_cond_t stru_70DC0; // weak
int dword_70E6C; // weak
__int64 qword_72F60; // weak


//----- (00011EB4) --------------------------------------------------------
int init_proc()
{
  return check_gmon_start();
}

//----- (00011EC0) --------------------------------------------------------
void sub_11EC0()
{
  JUMPOUT(0);
}
// 11ECC: control flows out of bounds to 0

//----- (00012648) --------------------------------------------------------
// bad sp value at call has been detected, the output may be wrong!
void __fastcall __noreturn main(int a1, char **a2, char **a3)
{
  char *v4; // r7
  FILE *v5; // r8
  size_t v6; // r0
  size_t v7; // r5
  int v8; // r8
  unsigned __int8 *v9; // r6
  size_t i; // r4
  const unsigned __int16 **v11; // r0
  int v12; // t1
  int v13; // r3
  int v14; // r0
  int (*v15)(void); // r2
  int (**v16)(void); // r3
  bool v17; // zf
  int v18; // r0
  int v19; // r0
  int v20; // r3
  int v21; // r5
  int v22; // r6
  int v23; // r4
  char **v24; // r7
  const char *v25; // t1
  int v26; // r0
  const char *v27; // r0
  int v28; // r4
  char *v29; // r0
  char *v30; // r7
  char *v31; // r6
  char *v32; // r0
  int *v33; // lr
  int v34; // r5
  size_t v35; // r0
  const char *v36; // r10
  unsigned int v37; // r12
  int v38; // r6
  int v39; // r3
  unsigned __int8 *v40; // r9
  unsigned int v41; // r12
  unsigned __int8 *v42; // r0
  unsigned int v43; // r1
  unsigned int v44; // r2
  int v45; // r3
  unsigned int v46; // r1
  unsigned int v47; // r2
  int v48; // r3
  unsigned int v49; // r1
  unsigned int v50; // r2
  unsigned int v51; // r6
  int v52; // r3
  unsigned int v53; // r12
  unsigned int v54; // r2
  int v55; // r3
  unsigned int v56; // r1
  unsigned int v57; // r2
  unsigned int v58; // r3
  unsigned int v59; // r4
  size_t v60; // r0
  int *v61; // r3
  int v62; // r6
  int v63; // r3
  int v64; // r7
  int v65; // r3
  int v66; // r4
  int v67; // r2
  _DWORD *v68; // r2
  int v69; // r1
  int v70; // r3
  _DWORD *v71; // r7
  int v72; // r2
  int v73; // r2
  _DWORD *v74; // r0
  _DWORD *v75; // r6
  _DWORD *v76; // r8
  int v77; // r4
  char *v78; // r10
  unsigned int v79; // r3
  int v80; // r2
  int v81; // r3
  _DWORD *v82; // r3
  unsigned int v83; // r2
  unsigned int v84; // r1
  bool v85; // cc
  int v86; // r2
  int v87; // r3
  int v88; // r0
  int v89; // r0
  int v90; // r0
  int v91; // r5
  int v92; // r0
  const char **v93; // r3
  int v94; // r2
  int *v95; // r3
  int v96; // r0
  int v97; // r1
  __int16 v98; // r3
  int v99; // r3
  int v100; // r3
  char *v101; // r8
  int v102; // r4
  char *v103; // r5
  char *v104; // r0
  char *v105; // r1
  const char *v106; // r4
  const char *v107; // r1
  const char *v108; // r1
  const char *v109; // r4
  const char *v110; // r3
  int v111; // r3
  const char *v112; // r4
  int v113; // r2
  int v114; // r4
  int v115; // r1
  int v116; // r2
  int v117; // r1
  int v118; // r2
  int v119; // r1
  int v120; // r2
  int v121; // r1
  int v122; // r5
  int v123; // r0
  char *v124; // r0
  int v125; // r4
  unsigned int v126; // r5
  char *j; // r0
  const char *v128; // r0
  int v129; // r0
  bool v130; // zf
  int v131; // r0
  int v132; // r3
  int v133; // r3
  int v134; // r4
  int *v135; // r9
  int v136; // r0
  int v137; // r3
  int v138; // r3
  char *v139; // r6
  const char *v140; // r9
  int i1; // r4
  int v142; // r0
  int v143; // r3
  void *v144; // r0
  void **v145; // r8
  void *v146; // r0
  char *v147; // r12
  int *v148; // lr
  int v149; // r0
  int v150; // r1
  int v151; // r2
  int v152; // r3
  _DWORD *v153; // r12
  _DWORD *v154; // lr
  int v155; // r1
  int v156; // r0
  int v157; // r3
  int v158; // r0
  int v159; // r12
  int v160; // r1
  int v161; // r3
  int v162; // r0
  int v163; // r12
  int k; // r3
  int v165; // r2
  int v166; // r6
  int m; // r4
  int v168; // r3
  int n; // r7
  _DWORD *v170; // r3
  int v171; // r4
  int v172; // r3
  const char *v173; // r0
  size_t v174; // r5
  size_t v175; // r5
  char *v176; // r0
  const char *v177; // r3
  __sighandler_t v178; // r4
  __sighandler_t v179; // r0
  bool v180; // zf
  int v181; // r0
  int v182; // r4
  int v183; // r0
  int v184; // r5
  int v185; // r4
  int v186; // r6
  int v187; // r10
  char *v188; // r4
  char *v189; // r5
  int v190; // r0
  int v191; // r2
  char *v192; // r6
  char **v193; // r0
  char **v194; // r7
  int *v195; // r8
  int *v196; // r10
  const char *v197; // r6
  int *v198; // r0
  int v199; // r1
  int v200; // r12
  int v201; // r0
  int v202; // lr
  int v203; // r1
  int v204; // r2
  int v205; // r3
  int v206; // r1
  int v207; // r2
  int v208; // r3
  int v209; // r5
  int v210; // r7
  int v211; // r3
  int *v212; // r0
  int v213; // r2
  int v214; // r3
  int v215; // r1
  int v216; // r0
  int v217; // r7
  int v218; // r5
  int v219; // r3
  char **v220; // r4
  int v221; // r1
  char *v222; // r2
  const char *v223; // r5
  int *v224; // r4
  pthread_mutex_t *v225; // r0
  int v226; // r3
  int v227; // r0
  int v228; // r0
  int v229; // r7
  int v230; // r3
  int v231; // r1
  int v232; // r3
  int *v233; // r0
  int v234; // r0
  int v235; // r7
  int v236; // r3
  int v237; // r1
  int v238; // r3
  int *v239; // r0
  int ii; // r3
  int v241; // r12
  int v242; // r3
  int v243; // r3
  const char *v244; // r10
  int v245; // r3
  int v246; // r5
  int v247; // r1
  int v248; // r3
  int v249; // r12
  int v250; // r0
  int kk; // r3
  int v252; // r12
  int v253; // r3
  int v254; // r3
  const char *v255; // r10
  int v256; // r3
  int v257; // r5
  int v258; // r1
  int v259; // r3
  int v260; // r12
  int v261; // r0
  int jj; // r10
  int v263; // r0
  int v264; // r1
  const char *v265; // r2
  pthread_mutex_t *v266; // r10
  int v267; // r7
  const char *v268; // r1
  int *v269; // r3
  int v270; // r3
  int v271; // r3
  const char *v272; // lr
  int v273; // r0
  int v274; // r1
  int v275; // r2
  int v276; // r3
  int *v277; // lr
  int v278; // r1
  int v279; // r2
  int v280; // r1
  int mm; // r10
  int v282; // r0
  int v283; // r1
  int v284; // r1
  int v285; // r10
  int *v286; // r3
  int v287; // r3
  int v288; // r1
  int *v289; // r0
  const char *v290; // r2
  int v291; // r12
  int v292; // r3
  int v293; // r0
  int v294; // r1
  int v295; // r3
  int v296; // r12
  const char *v297; // r6
  int v298; // r3
  pthread_mutex_t *v299; // r0
  int v300; // r6
  int nn; // r5
  int *v302; // r0
  int *v303; // r0
  size_t v304; // r0
  char v305; // [sp+10h] [bp-2A60h] BYREF
  char v306[4088]; // [sp+1018h] [bp-1A58h] BYREF
  const char *v307; // [sp+2010h] [bp-A60h]
  int *v308; // [sp+2020h] [bp-A50h]
  char *v309; // [sp+2024h] [bp-A4Ch]
  char *v310; // [sp+2028h] [bp-A48h]
  int *v311; // [sp+202Ch] [bp-A44h]
  int v312; // [sp+2030h] [bp-A40h]
  int *v313; // [sp+2034h] [bp-A3Ch]
  const char **v314; // [sp+2038h] [bp-A38h]
  char *v315; // [sp+203Ch] [bp-A34h]
  char *v316; // [sp+2040h] [bp-A30h]
  const char *v317; // [sp+2044h] [bp-A2Ch]
  int *v318; // [sp+2048h] [bp-A28h]
  const char *v319; // [sp+204Ch] [bp-A24h]
  int *v320; // [sp+2050h] [bp-A20h]
  const char *v321; // [sp+2054h] [bp-A1Ch]
  char **v322; // [sp+2058h] [bp-A18h]
  int v323; // [sp+205Ch] [bp-A14h] BYREF
  int v324; // [sp+2064h] [bp-A0Ch] BYREF
  char v325[32]; // [sp+2068h] [bp-A08h] BYREF
  pthread_attr_t v326; // [sp+2088h] [bp-9E8h] BYREF
  struct sigaction v327; // [sp+20ACh] [bp-9C4h] BYREF
  _DWORD v328[64]; // [sp+2138h] [bp-938h] BYREF
  int v329[525]; // [sp+2238h] [bp-838h] BYREF

  v323 = a1;
  v322 = a2;
  v324 = 0;
  pthread_attr_init(&v326);
  v318 = (int *)&byte_66518;
  pthread_attr_setstacksize(&v326, 2097152u);
  byte_66518 = 0;
  v4 = *a2;
  memset(v328, 0, sizeof(v328));
  memset(&v327, 0, 64u);
  snprintf((char *)&v327, 64u, "pidof %s", v4);
  v5 = popen((const char *)&v327, "r");
  if ( v5 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        do
        {
          if ( !fgets((char *)v328, 256, v5) )
          {
            v7 = 0;
            pclose(v5);
            v8 = 0;
            v321 = "Parsed proc id is: %d\n";
            v9 = (unsigned __int8 *)v328;
            for ( i = 1; strlen((const char *)v328) >= i; ++i )
            {
              memset(v325, 0, sizeof(v325));
              v11 = _ctype_b_loc();
              v12 = *v9++;
              if ( ((*v11)[v12] & 0x2000) != 0 )
              {
                strncpy(v325, (const char *)v328 + v7, i - v7 - 1);
                v13 = strtol(v325, 0, 10);
                if ( v13 > 0 && (++v8, byte_66641) && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
                {
                  v7 = i;
                  v320 = v329;
                  snprintf((char *)v329, 2048u, v321, v13);
                  log_event(7, v329, 0);
                }
                else
                {
                  v7 = i;
                }
              }
            }
            if ( v8 )
            {
              if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
              {
                snprintf((char *)v329, 2048u, " %d instance of %s is  already Running on this machine", v8, v4);
                log_event(3, v329, 0);
              }
              if ( v8 != 1 )
              {
                snprintf((char *)v329, 2048u, "%s is forbidden to start twice, will exit immediately!", *v322);
                log_event(3, v329, 1);
                shutdown_miner(-1, 0);
              }
            }
            goto LABEL_34;
          }
        }
        while ( !byte_66641 );
        if ( byte_70CE8 || byte_66640 || dword_657B8 > 6 )
          break;
LABEL_9:
        if ( byte_66640 || dword_657B8 > 6 )
        {
LABEL_11:
          v6 = strlen((const char *)v328);
          snprintf((char *)v329, 2048u, "strlen is: %d\n", v6);
          log_event(7, v329, 0);
        }
      }
      snprintf((char *)v329, 2048u, "pidof %s command result is: %s\n", v4, (const char *)v328);
      log_event(7, v329, 0);
      if ( byte_66641 )
      {
        if ( byte_70CE8 )
          goto LABEL_11;
        goto LABEL_9;
      }
    }
  }
  if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
  {
    snprintf((char *)v329, 2048u, " app-service:%s Not Found!!!", v4);
    log_event(7, v329, 0);
  }
LABEL_34:
  strcpy((char *)&dword_66540, "bmminer.log");
  strcpy((char *)&word_66520, "a+");
  v317 = (const char *)&word_66520;
  v14 = sysconf(84);
  v17 = v14 == 1;
  if ( v14 == 1 )
  {
    v16 = &off_658DC;
    v15 = sched_yield;
  }
  v18 = v323 + 1;
  if ( v17 )
    *v16 = v15;
  v321 = (const char *)&byte_66648;
  v19 = safe_malloc_with_logging(4 * v18, "cgminer.c", "main", 12076);
  v20 = v323;
  v21 = v19;
  dword_66AC4 = v19;
  if ( v323 > 0 )
  {
    v22 = v19 - 4;
    v23 = 0;
    v24 = v322 - 1;
    do
    {
      v25 = v24[1];
      ++v24;
      ++v23;
      *(_DWORD *)(v22 + 4) = _strdup(v25);
      v22 += 4;
      v20 = v323;
    }
    while ( v323 > v23 );
  }
  *(_DWORD *)(v21 + 4 * v20) = 0;
  init_mutex_and_log_failure(&stru_70E30, "main", 12085);
  init_mutex_and_log_failure(&stru_73F70, "main", 12086);
  init_mutex_and_log_failure(&stru_72F3C, "main", 12087);
  initialize_synchronization_primitives(&stru_740A0, "main", 12088);
  init_mutex_and_log_failure(&stru_70CEC, "main", 12089);
  v320 = (int *)&byte_68640;
  init_mutex_and_log_failure(&stru_66BD4, "main", 12090);
  initialize_synchronization_primitives(&stru_74068, "main", 12091);
  init_mutex_and_log_failure(&stru_66BAC, "main", 12092);
  init_rwlock_with_logging(&unk_68108, "main", 12093);
  init_rwlock_with_logging(&unk_70DF4, "main", 12094);
  init_rwlock_with_logging(&stru_72EE8, "main", 12095);
  init_rwlock_with_logging(&stru_72F18, "main", 12096);
  init_mutex_and_log_failure(&mutex, "main", 12098);
  if ( pthread_cond_init(&cond, 0) )
  {
    strcpy((char *)v329, "Failed to pthread_cond_init lp_cond");
    log_event(3, v329, 1);
    shutdown_miner(1, 0);
  }
  init_mutex_and_log_failure(&stru_72EC4, "main", 12105);
  if ( pthread_cond_init(&stru_740F0, 0) )
  {
    strcpy((char *)v329, "Failed to pthread_cond_init restart_cond");
    goto LABEL_193;
  }
  if ( pthread_cond_init(&stru_70DC0, 0) )
  {
    strcpy((char *)v329, "Failed to pthread_cond_init gws_cond");
  }
  else
  {
    v26 = initialize_task_queue();
    dword_72EB8 = v26;
    if ( v26 )
    {
      v307 = "1.0.0";
      *((_DWORD *)v321 + 270) = v26 + 12;
      snprintf(s, 256u, "%s %s", "cgminer", v307);
      v327.sa_handler = (__sighandler_t)sub_2AC0C;
      v327.sa_flags = 0;
      sigemptyset(&v327.sa_mask);
      sigaction(15, &v327, &unk_70D28);
      sigaction(2, &v327, &unk_73FDC);
      sigaction(6, &v327, &unk_74190);
      strcpy(v306, "/usr/bin");
      dword_74188 = (int)v306;
      dword_73FC8 = (int)&v305;
      v27 = *v322;
      v315 = (char *)&dword_74188;
      v28 = 36;
      v316 = "/";
      v29 = _strdup(v27);
      v30 = (char *)dword_73FC8;
      v31 = v29;
      v32 = dirname(v29);
      strcpy(v30, v32);
      free(v31);
      v33 = v320;
      strcat((char *)dword_73FC8, "/");
      *(v33 - 163) = 9;
      v34 = allocate_and_log_on_fail(104, 1, "cgminer.c", "main", 12152);
      do
      {
        v35 = strlen((const char *)v34);
        --v28;
        strcpy((char *)(v34 + v35), "0");
      }
      while ( v28 );
      v36 = (const char *)(v35 + 1);
      v37 = -1640531527;
      v38 = -17973521;
      v319 = (const char *)(v35 + 1);
      v39 = -1640531527;
      if ( v35 + 1 <= 11 )
      {
        v42 = (unsigned __int8 *)v34;
        v36 = v319;
      }
      else
      {
        v40 = (unsigned __int8 *)(v34 + 12);
        do
        {
          v36 -= 12;
          v41 = (*(v40 - 6) << 16) + (*(v40 - 7) << 8) + *(v40 - 8) + (*(v40 - 5) << 24) + v37;
          v42 = v40;
          v43 = (*(v40 - 10) << 16) + (*(v40 - 11) << 8) + *(v40 - 12) + (*(v40 - 9) << 24) - v41;
          v44 = (*(v40 - 2) << 16) + (*(v40 - 3) << 8) + *(v40 - 4) + (*(v40 - 1) << 24) + v38;
          v40 += 12;
          v45 = (v43 - v44 + v39) ^ (v44 >> 13);
          v46 = (v41 - v44 - v45) ^ (v45 << 8);
          v47 = (v44 - v45 - v46) ^ (v46 >> 13);
          v48 = (v45 - v46 - v47) ^ (v47 >> 12);
          v49 = (v46 - v47 - v48) ^ (v48 << 16);
          v50 = (v47 - v48 - v49) ^ (v49 >> 5);
          v39 = (v48 - v49 - v50) ^ (v50 >> 3);
          v37 = (v49 - v50 - v39) ^ (v39 << 10);
          v38 = (v50 - v39 - v37) ^ (v37 >> 15);
        }
        while ( (unsigned int)v36 > 11 );
      }
      v51 = (unsigned int)&v319[v38];
      switch ( (unsigned int)v36 )
      {
        case 1u:
          goto LABEL_61;
        case 2u:
          goto LABEL_60;
        case 3u:
          goto LABEL_59;
        case 4u:
          goto LABEL_58;
        case 5u:
          goto LABEL_57;
        case 6u:
          goto LABEL_56;
        case 7u:
          goto LABEL_55;
        case 8u:
          goto LABEL_54;
        case 9u:
          goto LABEL_53;
        case 10u:
          goto LABEL_52;
        case 11u:
          v51 += v42[10] << 24;
LABEL_52:
          v51 += v42[9] << 16;
LABEL_53:
          v51 += v42[8] << 8;
LABEL_54:
          v37 += v42[7] << 24;
LABEL_55:
          v37 += v42[6] << 16;
LABEL_56:
          v37 += v42[5] << 8;
LABEL_57:
          v37 += v42[4];
LABEL_58:
          v39 += v42[3] << 24;
LABEL_59:
          v39 += v42[2] << 16;
LABEL_60:
          v39 += v42[1] << 8;
LABEL_61:
          v39 += *v42;
          break;
        default:
          break;
      }
      *(_DWORD *)(v34 + 88) = v34;
      v52 = (v39 - v37 - v51) ^ (v51 >> 13);
      v53 = (v37 - v51 - v52) ^ (v52 << 8);
      v54 = (v51 - v52 - v53) ^ (v53 >> 13);
      v55 = (v52 - v53 - v54) ^ (v54 >> 12);
      v56 = (v53 - v54 - v55) ^ (v55 << 16);
      v57 = (v54 - v55 - v56) ^ (v56 >> 5);
      v58 = v55 - v56 - v57;
      v59 = (v57 - (v58 ^ (v57 >> 3)) - ((v56 - v57 - (v58 ^ (v57 >> 3))) ^ ((v58 ^ (v57 >> 3)) << 10))) ^ (((v56 - v57 - (v58 ^ (v57 >> 3))) ^ ((v58 ^ (v57 >> 3)) << 10)) >> 15);
      *(_DWORD *)(v34 + 96) = v59;
      v60 = strlen((const char *)v34);
      v61 = v320;
      *(_DWORD *)(v34 + 92) = v60;
      v62 = *(v61 - 326);
      if ( v62 )
      {
        v63 = *(_DWORD *)(v62 + 68);
        *(_DWORD *)(v34 + 76) = 0;
        v64 = v34 + 68;
        *(_DWORD *)(v34 + 68) = v63;
        *(_DWORD *)(v34 + 72) = *(_DWORD *)(*(_DWORD *)(v62 + 68) + 16) - *(_DWORD *)(*(_DWORD *)(v62 + 68) + 20);
        *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v62 + 68) + 16) + 8) = v34;
        *(_DWORD *)(*(_DWORD *)(v62 + 68) + 16) = v34 + 68;
      }
      else
      {
        *(_DWORD *)(v34 + 76) = 0;
        *(_DWORD *)(v34 + 72) = 0;
        *(v61 - 326) = v34;
        v144 = malloc(44u);
        *(_DWORD *)(v34 + 68) = v144;
        if ( !v144 )
          goto LABEL_184;
        memset(v144, 0, 44u);
        v64 = v34 + 68;
        *(_DWORD *)(*(_DWORD *)(v34 + 68) + 16) = v34 + 68;
        *(_DWORD *)(*(_DWORD *)(v34 + 68) + 4) = 32;
        *(_DWORD *)(*(_DWORD *)(v34 + 68) + 8) = 5;
        *(_DWORD *)(*(_DWORD *)(v34 + 68) + 20) = 68;
        v145 = *(void ***)(v34 + 68);
        *v145 = malloc(384u);
        v146 = **(void ***)(v34 + 68);
        if ( !v146 )
          goto LABEL_184;
        memset(v146, 0, 384u);
        *(_DWORD *)(*(_DWORD *)(v34 + 68) + 40) = -1609490463;
      }
      v65 = *(v320 - 326);
      ++*(_DWORD *)(*(_DWORD *)(v65 + 68) + 12);
      v66 = 12 * (v59 & (*(_DWORD *)(*(_DWORD *)(v65 + 68) + 4) - 1));
      ++*(_DWORD *)(**(_DWORD **)(v65 + 68) + v66 + 4);
      v67 = *(_DWORD *)(**(_DWORD **)(v65 + 68) + v66);
      *(_DWORD *)(v34 + 80) = 0;
      *(_DWORD *)(v34 + 84) = v67;
      v68 = *(_DWORD **)(v65 + 68);
      v69 = *(_DWORD *)(*v68 + v66);
      if ( v69 )
      {
        *(_DWORD *)(v69 + 12) = v64;
        v68 = *(_DWORD **)(v65 + 68);
      }
      *(_DWORD *)(*v68 + v66) = v64;
      if ( *(_DWORD *)(**(_DWORD **)(v65 + 68) + v66 + 4) < (unsigned int)(10
                                                                         * *(_DWORD *)(**(_DWORD **)(v65 + 68) + v66 + 8)
                                                                         + 10)
        || (v70 = *(_DWORD *)(v34 + 68), *(_DWORD *)(v70 + 36) == 1) )
      {
LABEL_85:
        strcpy(&byte_7413C, (const char *)v34);
        dword_70E64 = (int)&dword_70E64;
        dword_70E68 = (int)&dword_70E64;
        update_miner_config(&off_659E0, "Options for both config file and command line");
        update_miner_config(&off_66164, "Options for command line only");
        v88 = validate_command_line(&v323, v322, log_error_and_exit);
        if ( v323 != 1 )
        {
          strcpy((char *)v329, "Unexpected extra commandline arguments");
          log_event(3, v329, 1);
          shutdown_miner(1, 0);
        }
        if ( !v321[808] )
          sub_29D68(v88);
        *(v320 - 162) = 8;
        v89 = allocate_and_log_on_fail(8, 64, "cgminer.c", "main", 12188);
        dword_70D18 = v89;
        v313 = &dword_70D18;
        *((_DWORD *)v321 + 290) = 1;
        v90 = create_thread(v89 + 64, &v326, initialize_api_thread);
        v312 = v90;
        if ( v90 )
        {
          strcpy((char *)v329, "API thread create failed");
          log_event(3, v329, 1);
          shutdown_miner(1, 0);
        }
        v17 = v321[1376] == 0;
        v314 = (const char **)&dword_70D08;
        if ( !v17 || dword_70D08 )
        {
          v91 = add_pool();
          v92 = safe_malloc_with_logging(255, "cgminer.c", "main", 12205);
          v93 = v314;
          v94 = v92;
          *(_DWORD *)(v91 + 164) = v92;
          if ( *v93 )
            LOWORD(v95) = 8740;
          else
            LOWORD(v95) = 8752;
          HIWORD(v95) = 5;
          v96 = *v95;
          v97 = v95[1];
          v98 = *((_WORD *)v95 + 4);
          *(_DWORD *)v94 = v96;
          *(_DWORD *)(v94 + 4) = v97;
          *(_WORD *)(v94 + 8) = v98;
          v99 = *(_DWORD *)(v91 + 164);
          *(_DWORD *)(v91 + 172) = v99;
          *(_DWORD *)(v91 + 176) = v99;
          *(_DWORD *)(v91 + 168) = v99;
          *(_DWORD *)(v91 + 600) = v99;
          strncpy((char *)(v91 + 48), "?", 7u);
          v100 = *(_DWORD *)(v91 + 100);
          *(_BYTE *)(v91 + 55) = 0;
          if ( v100 != 1 )
            increment_counter_and_set_flag(v91 + 100);
          v101 = (char *)&unk_66BF8;
          v102 = 0;
          *(_BYTE *)(v91 + 97) = 0;
          v103 = (char *)&unk_675F8;
          byte_66642 = 1;
          do
          {
            v104 = v101;
            v101 += 160;
            hex_string_to_binary(v104, &a000000029c6bf4[v102]);
            v105 = &a00000002c01f50[v102];
            v102 += 324;
            hex_string_to_binary(v103, v105);
            v103 += 160;
          }
          while ( v102 != 5184 );
          v90 = calculate_target_hash(&unk_683BC);
        }
        if ( *((_DWORD *)v321 + 132) )
          read_miner_version_file(v90);
        v106 = v321;
        v107 = (const char *)*((_DWORD *)v321 + 128);
        if ( v107 )
        {
          *(_BYTE *)v318 = 1;
          strcpy((char *)&dword_66540, v107);
          v108 = (const char *)*((_DWORD *)v106 + 131);
          if ( v108 )
            strcpy((char *)&word_66520, v108);
          if ( !byte_70CE8 )
          {
            v322 = (char **)&byte_66640;
            if ( !byte_66640 && dword_657B8 <= 2 )
            {
              v109 = (const char *)*((_DWORD *)v321 + 130);
              if ( !v109 )
              {
LABEL_109:
                if ( dword_657B8 <= 3 )
                {
                  v110 = (const char *)*((_DWORD *)v321 + 200);
                  if ( !v110 )
                    goto LABEL_120;
LABEL_111:
                  if ( dword_657B8 <= 4 )
                  {
                    v111 = *((_DWORD *)v321 + 253);
                    if ( v111 != -1 )
                      goto LABEL_113;
LABEL_207:
                    if ( !*(_BYTE *)v322 && dword_657B8 <= 3 )
                    {
                      if ( !byte_73FD2 )
                        goto LABEL_119;
                      goto LABEL_210;
                    }
LABEL_212:
                    strcpy((char *)v329, "Error in configuration file, partially loaded.");
                    log_event(4, v329, 0);
                    if ( !byte_73FD2 )
                      goto LABEL_119;
                    if ( byte_70CE8 || *(_BYTE *)v322 )
                      goto LABEL_211;
LABEL_210:
                    if ( dword_657B8 > 3 )
                    {
LABEL_211:
                      strcpy((char *)v329, "Start cgminer with -T to see what failed to load.");
                      log_event(4, v329, 0);
                    }
LABEL_119:
                    v112 = v321;
                    free(*((void **)v321 + 200));
                    *((_DWORD *)v112 + 200) = 0;
                    goto LABEL_120;
                  }
LABEL_112:
                  snprintf((char *)v329, 2048u, "Loaded configuration file %s", v110);
                  log_event(5, v329, 0);
                  v111 = *((_DWORD *)v321 + 253);
                  if ( v111 != -1 )
                  {
LABEL_113:
                    if ( !v111 )
                    {
                      if ( (byte_70CE8 || *(_BYTE *)v322 || dword_657B8 > 3)
                        && ((strcpy((char *)v329, "Fatal JSON error in configuration file."),
                             log_event(4, v329, 0),
                             byte_70CE8)
                         || *(_BYTE *)v322)
                        || dword_657B8 > 3 )
                      {
                        strcpy((char *)v329, "Configuration file could not be used.");
                        log_event(4, v329, 0);
                      }
                    }
                    goto LABEL_119;
                  }
                  if ( byte_70CE8 )
                    goto LABEL_212;
                  goto LABEL_207;
                }
LABEL_177:
                snprintf((char *)v329, 2048u, "Started %s", s);
                log_event(4, v329, 0);
                v110 = (const char *)*((_DWORD *)v321 + 200);
                if ( !v110 )
                {
LABEL_120:
                  *(_WORD *)(*(_DWORD *)v315 + strlen(*(const char **)v315)) = *(_WORD *)v316;
                  if ( byte_73F6C )
                  {
                    *(_BYTE *)v322 = 1;
                  }
                  else if ( !*(_BYTE *)v322 )
                  {
                    setlogmask(63);
                    goto LABEL_123;
                  }
                  setlogmask(255);
LABEL_123:
                  v113 = dword_66154;
                  LOWORD(v114) = (unsigned __int16)&unk_66450;
                  if ( dword_66154 < 0 )
                    v113 = 60;
                  HIWORD(v114) = (unsigned int)&unk_66450 >> 16;
                  if ( dword_66154 < 0 )
                    dword_66154 = v113;
                  initialize_miner_defaults(&unk_70BF0, &unk_70BF0, v113);
                  initialize_miner_defaults(&unk_70B78, v115, v116);
                  initialize_miner_defaults(&unk_70C68, v117, v118);
                  v318 = &dword_74180;
                  initialize_miner_defaults(v114, v119, v120);
                  (*(void (__fastcall **)(_DWORD))(v121 + 12))(0);
                  dword_70B84(0);
                  dword_70C74(0);
                  (*(void (__fastcall **)(_DWORD))(v114 + 12))(0);
                  v122 = 0;
                  dword_74180 = 0;
                  v319 = (const char *)&dword_72F38;
                  while ( dword_72F38 > v122 )
                  {
                    v123 = *(_DWORD *)(dword_72EC0 + 4 * v122++);
                    initialize_device_lock(v123);
                  }
                  if ( !dword_72F38 )
                  {
                    strcpy((char *)v329, "All devices disabled, cannot mint!");
                    log_event(3, v329, 1);
                    shutdown_miner(1, 0);
                  }
                  v124 = (char *)*((_DWORD *)v321 + 256);
                  *(v320 - 300) = dword_72F38;
                  if ( v124 )
                  {
                    v125 = 0;
                    v126 = 0;
                    for ( j = strtok(v124, (const char *)&word_4FD70); j; j = strtok(0, (const char *)&word_4FD70) )
                    {
                      if ( *(_DWORD *)v319 <= v125 )
                      {
                        strcpy((char *)v329, "Too many values passed to set temp cutoff");
                        log_event(3, v329, 1);
                        shutdown_miner(1, 1);
                      }
                      v126 = strtol(j, 0, 10);
                      if ( v126 > 200 )
                      {
                        v147 = "ssed to set temp cutoff";
                        qmemcpy(v329, "Invalid value pa", 16);
                        v148 = &v329[4];
                        goto LABEL_201;
                      }
                      if ( pthread_rwlock_rdlock(&stru_72F18) )
                        log_rdlock_error("load_temp_cutoffs", 1362);
                      *(_DWORD *)(*(_DWORD *)(dword_72EC0 + 4 * v125) + 184) = v126;
                      if ( pthread_rwlock_unlock(&stru_72F18) )
                      {
                        v212 = _errno_location();
                        snprintf(
                          (char *)v329,
                          2048u,
                          "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
                          *v212,
                          "cgminer.c",
                          "load_temp_cutoffs",
                          1364);
                        goto LABEL_202;
                      }
                      ++v125;
                      off_658DC();
                    }
                    if ( v125 <= 1 )
                    {
                      if ( pthread_rwlock_rdlock(&stru_72F18) )
                        log_rdlock_error("load_temp_cutoffs", 1385);
                      v316 = (char *)&dword_72EC0;
                      v213 = *(_DWORD *)v319;
                      v214 = dword_72EC0;
                      while ( v125 < v213 )
                      {
                        v215 = *(_DWORD *)(v214 + 4 * v125++);
                        *(_DWORD *)(v215 + 184) = v126;
                      }
                      unlock_rwlock_and_log_error(&stru_72F18, "load_temp_cutoffs", 1391);
                    }
                    else
                    {
                      v316 = (char *)&dword_72EC0;
                    }
                  }
                  else
                  {
                    v158 = pthread_rwlock_rdlock(&stru_72F18);
                    if ( v158 )
                      log_rdlock_error("load_temp_cutoffs", 1369);
                    v316 = (char *)&dword_72EC0;
                    v159 = *(_DWORD *)v319;
                    v160 = dword_72EC0;
                    while ( v158 < v159 )
                    {
                      v161 = *(_DWORD *)(v160 + 4 * v158++);
                      if ( !*(_DWORD *)(v161 + 184) )
                        *(_DWORD *)(v161 + 184) = 95;
                    }
                    unlock_rwlock_and_log_error(&stru_72F18, "load_temp_cutoffs", 1378);
                  }
                  v162 = *(_DWORD *)v319;
                  v163 = *(_DWORD *)v316;
                  for ( k = 0; v162 > k; ++k )
                  {
                    v165 = *(_DWORD *)(v163 + 4 * k);
                    *(_DWORD *)(v165 + 312) = 99999999;
                  }
                  if ( !byte_73FD0 )
                    *(v320 - 163) += *(v320 - 300);
                  v317 = (const char *)&dword_657B8;
                  while ( 1 )
                  {
                    v166 = 0;
                    for ( m = 0; m < dword_70DB8; ++m )
                    {
                      v168 = *(_DWORD *)(dword_70E5C + 4 * m);
                      if ( **(_BYTE **)(v168 + 164) )
                      {
                        if ( **(_BYTE **)(v168 + 172) )
                        {
                          ++v166;
                        }
                        else if ( byte_66641 && (byte_70CE8 || *(_BYTE *)v322 || *(int *)v317 > 6) )
                        {
                          strcpy((char *)v329, "Blank worker exists.\n");
                          log_event(7, v329, 0);
                        }
                      }
                    }
                    if ( v166 )
                      break;
                    if ( !*(v320 - 20) )
                    {
                      if ( byte_70CE8 || *(_BYTE *)v322 || *(int *)v317 > 4 )
                      {
                        strcpy((char *)v329, "No valid pools, please configure them first!\n");
                        log_event(5, v329, 0);
                      }
                      *(v320 - 20) = 1;
                    }
                    if ( byte_66641 && (byte_70CE8 || *(_BYTE *)v322 || *(int *)v317 > 6) )
                    {
                      strcpy((char *)v329, "check no pool and user retry!");
                      log_event(7, v329, 0);
                    }
                    sleep(1u);
                  }
                  if ( !dword_70DB8 )
                  {
                    if ( byte_70CE8 || *(_BYTE *)v322 || dword_657B8 > 3 )
                    {
                      strcpy((char *)v329, "Need to specify at least one pool server.");
                      log_event(4, v329, 0);
                    }
                    strcpy((char *)v329, "Pool setup failed");
                    log_event(3, v329, 1);
                    shutdown_miner(1, 0);
                  }
                  v317 = (const char *)&dword_70E5C;
                  v315 = "cgminer.c";
                  for ( n = 0; ; ++n )
                  {
                    v170 = *(_DWORD **)v317;
                    if ( dword_70DB8 <= n )
                      break;
                    v171 = v170[n];
                    v172 = *(_DWORD *)(v171 + 168);
                    *(_DWORD *)(v171 + 404) = 99999999;
                    *(_DWORD *)(v171 + 440) = 99999999;
                    if ( !v172 )
                    {
                      if ( !*(_DWORD *)(v171 + 176) )
                        *(_DWORD *)(v171 + 176) = calloc(1u, 1u);
                      v173 = *(const char **)(v171 + 172);
                      if ( !v173 )
                      {
                        snprintf(
                          (char *)v329,
                          2048u,
                          "No login credentials supplied for pool %u %s",
                          n,
                          *(const char **)(v171 + 164));
                        log_event(3, v329, 1);
                        shutdown_miner(1, 0);
                      }
                      v174 = strlen(v173);
                      v175 = v174 + strlen(*(const char **)(v171 + 176)) + 2;
                      v176 = (char *)safe_malloc_with_logging(v175, v315, "main", 12481);
                      v177 = *(const char **)(v171 + 176);
                      *(_DWORD *)(v171 + 168) = v176;
                      snprintf(v176, v175, "%s:%s", *(const char **)(v171 + 172), v177);
                    }
                  }
                  v17 = byte_70CE8 == 0;
                  *((_DWORD *)v321 + 291) = *v170;
                  if ( !v17 )
                    openlog("cgminer", 1, 8);
                  if ( *(v320 - 19) )
                  {
                    if ( pipe(v329) < 0 )
                    {
                      perror("pipe - failed to create pipe for --monitor");
                      exit(1);
                    }
                    fflush((FILE *)stderr);
                    if ( dup2(v329[1], 2) < 0 )
                    {
                      perror("dup2 - failed to alias stderr to write end of pipe for --monitor");
                      exit(1);
                    }
                    if ( close(v329[1]) < 0 )
                    {
                      perror("close - failed to close write end of pipe for --monitor");
                      exit(1);
                    }
                    v178 = signal(13, (__sighandler_t)1);
                    v179 = signal(13, (__sighandler_t)1);
                    v180 = (__sighandler_t)((char *)v178 + 1) == 0;
                    if ( v178 != (__sighandler_t)-1 )
                      v180 = (__sighandler_t)((char *)v179 + 1) == 0;
                    if ( v180 )
                    {
                      perror("signal - failed to edit signal mask for --monitor");
                      exit(1);
                    }
                    v181 = fork();
                    v182 = v181;
                    *((_DWORD *)v321 + 265) = v181;
                    if ( v181 < 0 )
                    {
                      perror("fork - failed to fork child process for --monitor");
                      exit(1);
                    }
                    if ( !v181 )
                    {
                      if ( dup2(v329[0], v181) >= 0 )
                      {
                        close(v329[0]);
                        execl("/bin/bash", "/bin/bash", "-c", *(v320 - 19), v182);
                        perror("execl - in child failed to exec user specified command for --monitor");
                        exit(1);
                      }
                      perror("dup2 - in child, failed to alias read end of pipe to stdin for --monitor");
                      exit(1);
                    }
                    if ( close(v329[0]) < 0 )
                    {
                      perror("close - failed to close read end of pipe for --monitor");
                      exit(1);
                    }
                  }
                  v183 = *v318;
                  v311 = &dword_71E78;
                  v184 = 0;
                  dword_71E78 = allocate_and_log_on_fail(v183, 4, "cgminer.c", "main", 12498);
                  while ( *v318 > v184 )
                  {
                    v185 = *v311;
                    *(_DWORD *)(v185 + 4 * v184++) = allocate_and_log_on_fail(1, 64, "cgminer.c", "main", 12502);
                  }
                  v186 = 0;
                  v315 = 0;
                  v309 = &byte_66641;
                  v308 = &dword_70DB8;
                  v310 = &byte_70CE8;
                  while ( *(_DWORD *)v319 > v186 )
                  {
                    v187 = v186;
                    v188 = 0;
                    v189 = *(char **)(*(_DWORD *)v316 + 4 * v186);
                    v190 = safe_malloc_with_logging(4 * (*((_DWORD *)v189 + 37) + 1), "cgminer.c", "main", 12511);
                    v191 = *((_DWORD *)v189 + 37);
                    *((_DWORD *)v189 + 38) = v190;
                    *(_DWORD *)(v190 + 4 * v191) = 0;
                    *((_DWORD *)v189 + 24) = 4;
                    while ( 1 )
                    {
                      v192 = &v188[(_DWORD)v315];
                      if ( *((_DWORD *)v189 + 37) <= (int)v188 )
                        break;
                      v193 = (char **)get_thread_metadata(&v188[(_DWORD)v315]);
                      *v193 = v192;
                      v194 = v193;
                      v193[9] = v189;
                      v193[1] = v188;
                      if ( (*(int (**)(void))(*((_DWORD *)v189 + 1) + 44))() )
                      {
                        if ( create_thread(v194, &v326, initialize_miner_thread) )
                        {
                          snprintf((char *)v329, 2048u, "thread %d create failed", *v194);
                          log_event(3, v329, 1);
                          shutdown_miner(1, 0);
                        }
                        *(_DWORD *)(*((_DWORD *)v189 + 38) + 4 * (_DWORD)v188) = v194;
                        if ( *((_DWORD *)v189 + 8) != 1 )
                        {
                          if ( *v309 && (*v310 || *(_BYTE *)v322 || dword_657B8 > 6) )
                          {
                            snprintf((char *)v329, 2048u, "Pushing sem post to thread %d", *v194);
                            log_event(7, v329, 0);
                          }
                          post_semaphore_and_log_failure(v194 + 4, "cgminer.c", "main", 12539);
                        }
                      }
                      ++v188;
                    }
                    v186 = v187 + 1;
                    v315 = &v188[(_DWORD)v315];
                  }
                  v195 = v308;
                  v196 = (int *)v310;
                  if ( v321[1376] || (v197 = *v314) != 0 )
                  {
LABEL_311:
                    v198 = (int *)&dbl_66AF8;
                    unk_70CE0 = 0LL;
                    do
                    {
                      *(_QWORD *)v198 = 0LL;
                      v198 += 2;
                    }
                    while ( &dword_66B58 != v198 );
                    v199 = v312;
                    v200 = *(_DWORD *)v319;
                    v201 = *(_DWORD *)v316;
                    *((_DWORD *)v321 + 324) = 0;
                    while ( v200 > v199 )
                    {
                      v202 = *(_DWORD *)(v201 + 4 * v199++);
                      *(_QWORD *)(v202 + 80) = 0LL;
                      *(_QWORD *)(v202 + 48) = 0LL;
                    }
                    get_hardware_timestamp(&dword_66A90, v199, 0, 0);
                    get_hardware_timestamp(&dword_66A88, v203, v204, v205);
                    get_hardware_timestamp(&unk_66AF0, v206, v207, v208);
                    format_timestamp_to_string(&byte_66A98, 40);
                    v209 = *v313;
                    *((_DWORD *)v321 + 288) = 3;
                    if ( create_thread(v209 + 192, &v326, monitor_mining_pool) )
                    {
                      strcpy((char *)v329, "watchpool thread create failed");
                      log_event(3, v329, 1);
                      shutdown_miner(1, 0);
                    }
                    pthread_detach(*(_DWORD *)(v209 + 204));
                    v210 = *v313;
                    *((_DWORD *)v321 + 289) = 4;
                    if ( create_thread(v210 + 256, &v326, watchdog_loop) )
                    {
                      strcpy((char *)v329, "watchdog thread create failed");
                      log_event(3, v329, 1);
                      shutdown_miner(1, 0);
                    }
                    pthread_detach(*(_DWORD *)(v210 + 268));
                    v211 = *(v320 - 162);
                    if ( v211 != 8 )
                    {
                      snprintf((char *)v329, 2048u, "incorrect total_control_threads (%d) should be 8", v211);
LABEL_193:
                      log_event(3, v329, 1);
                      shutdown_miner(1, 0);
                    }
                    if ( !nice(-10) && byte_66641 && (*(_BYTE *)v196 || *(_BYTE *)v322 || dword_657B8 > 6) )
                    {
                      strcpy((char *)v329, "Unable to set thread to high priority");
                      log_event(7, v329, 0);
                    }
                    v222 = &byte_72EBD;
                    v223 = v317;
                    v224 = v320;
                    v315 = &byte_73FC0;
                    v316 = &byte_72EBD;
                    v320 = v196;
LABEL_370:
                    while ( 2 )
                    {
                      if ( *v315 )
                      {
                        if ( *(_BYTE *)v320 || *(_BYTE *)v322 || (v292 = dword_657B8, dword_657B8 > 5) )
                        {
                          strcpy((char *)v329, "Work update message received");
                          log_event(6, v329, 0);
                        }
                        get_hardware_timestamp(&unk_66A54, v221, v222, v292);
                        v293 = pthread_rwlock_rdlock(&stru_72EE8);
                        if ( v293 )
                        {
                          v302 = _errno_location();
                          snprintf(
                            (char *)v329,
                            2048u,
                            "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
                            *v302,
                            "cgminer.c",
                            "signal_work_update",
                            5539);
                          goto LABEL_202;
                        }
                        v294 = *v318;
                        v295 = *v311;
                        while ( v293 < v294 )
                        {
                          v296 = *(_DWORD *)(v295 + 4 * v293++);
                          *(_BYTE *)(v296 + 63) = 1;
                        }
                        if ( pthread_rwlock_unlock(&stru_72EE8) )
                        {
                          v303 = _errno_location();
                          snprintf(
                            (char *)v329,
                            2048u,
                            "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
                            *v303,
                            "cgminer.c",
                            "signal_work_update",
                            5546);
LABEL_202:
                          log_event(3, v329, 1);
                          shutdown_miner(1, 1);
                        }
                        off_658DC();
                      }
                      v225 = (pthread_mutex_t *)*((_DWORD *)v321 + 270);
                      *v315 = 0;
                      if ( pthread_mutex_lock(v225) )
                      {
                        v289 = _errno_location();
                        v290 = "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d";
                        v291 = 12704;
                        goto LABEL_488;
                      }
                      v226 = *((_DWORD *)v321 + 325);
                      if ( v226
                        && *(int *)(*(_DWORD *)(v226 + 344) + 12) > 1
                        && (v297 = v321,
                            pthread_cond_wait(&stru_70DC0, *((pthread_mutex_t **)v321 + 270)),
                            (v298 = *((_DWORD *)v297 + 325)) != 0) )
                      {
                        v299 = (pthread_mutex_t *)*((_DWORD *)v297 + 270);
                        v300 = *(_DWORD *)(*(_DWORD *)(v298 + 344) + 12);
                        if ( pthread_mutex_unlock(v299) )
                        {
LABEL_487:
                          v289 = _errno_location();
                          v290 = "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d";
                          v291 = 12715;
LABEL_488:
                          snprintf((char *)v329, 2048u, v290, *v289, "cgminer.c", "main", v291);
                          goto LABEL_202;
                        }
                        v227 = off_658DC();
                        if ( v300 > 1 )
                        {
                          v324 = pop_hash(0);
                          if ( v324 )
                            process_work_discard(&v324, "cgminer.c", "main", 12727);
                          continue;
                        }
                      }
                      else
                      {
                        if ( pthread_mutex_unlock(*((pthread_mutex_t **)v321 + 270)) )
                          goto LABEL_487;
                        v227 = off_658DC();
                      }
                      break;
                    }
                    if ( v324 )
                      v227 = process_work_discard(&v324, "cgminer.c", "main", 12735);
                    v319 = (const char *)&unk_681A0;
                    v317 = "Selecting pool %d for work";
                    v324 = initialize_work(v227);
                    while ( 1 )
                    {
                      v234 = pthread_mutex_lock((pthread_mutex_t *)(v319 - 12));
                      v235 = get_current_pool_index(v234);
                      v236 = *((_DWORD *)v321 + 255);
                      if ( v236 == 4 )
                        break;
                      if ( v236 != 3 )
                        goto LABEL_379;
                      v237 = *v195;
                      v238 = 0;
                      v239 = *(int **)v223;
                      while ( v238 < v237 )
                      {
                        if ( *(_DWORD *)(v239[v238] + 64) < *(_DWORD *)(v239[v238] + 60) )
                          goto LABEL_410;
                        ++v238;
                      }
                      for ( ii = 0; v237 > ii; ++ii )
                      {
                        v241 = v239[ii];
                        *(_DWORD *)(v241 + 64) = 0;
                      }
                      v242 = *(v224 - 18) + 1;
                      if ( v237 <= v242 )
                        v242 = 0;
                      *(v224 - 18) = v242;
LABEL_410:
                      v243 = 0;
                      v244 = v223;
                      while ( 1 )
                      {
                        v246 = v243 + 1;
                        if ( v243 >= *v195 )
                          break;
                        v247 = *(_DWORD *)(*(_DWORD *)v244 + 4 * *(v224 - 18));
                        v248 = *(_DWORD *)(v247 + 64);
                        v249 = *(_DWORD *)(v247 + 60);
                        *(_DWORD *)(v247 + 64) = v248 + 1;
                        if ( v248 < v249 )
                        {
                          if ( !*(_BYTE *)(v247 + 97) && *(_DWORD *)(v247 + 100) == 1 && !check_status_flags(v247) )
                          {
                            v223 = v244;
                            v235 = v280;
                            goto LABEL_446;
                          }
                          if ( *v316 )
                          {
                            v250 = get_connection_handle_by_id(0);
                            --*(_DWORD *)(v250 + 64);
                          }
                        }
                        v245 = *(v224 - 18) + 1;
                        v85 = v245 < *v195;
                        *(v224 - 18) = v245;
                        if ( !v85 )
                          *(v224 - 18) = 0;
                        v243 = v246;
                      }
                      v223 = v244;
                      for ( jj = 0; ; ++jj )
                      {
                        if ( jj >= *v195 )
                          goto LABEL_379;
                        v263 = get_connection_handle_by_id(jj);
                        if ( !*(_BYTE *)(v263 + 97) && *(_DWORD *)(v263 + 100) == 1 && !check_status_flags(v263) )
                          break;
                      }
                      v235 = v264;
LABEL_446:
                      if ( byte_66641 )
                        goto LABEL_380;
LABEL_447:
                      if ( !check_status_flags(v235) )
                      {
                        v265 = v319;
                        *(v224 - 292) = 0;
                        v317 = 0;
                        v266 = (pthread_mutex_t *)(v265 - 12);
                        pthread_mutex_unlock((pthread_mutex_t *)(v265 - 12));
                        pthread_mutex_lock(v266);
                        if ( *(v224 - 292) == 1 )
                        {
                          *(v224 - 292) = (int)v317;
                          pthread_mutex_unlock(v266);
                        }
                        else if ( *(_BYTE *)(v235 + 640) )
                        {
                          generate_stratum_work(v235, v324);
                          if ( byte_66641 && (*(_BYTE *)v320 || *(_BYTE *)v322 || dword_657B8 > 6) )
                          {
                            strcpy((char *)v329, "Generated stratum work");
                            log_event(7, v329, 0);
                          }
                          push_work_to_hash_queue(v324);
                          v324 = 0;
                          pthread_mutex_unlock((pthread_mutex_t *)(v319 - 12));
                        }
                        else
                        {
                          pthread_mutex_unlock(v266);
                          v319 = *v314;
                          if ( v319 )
                          {
                            v285 = v324;
                            process_benchfile_entry(v324);
                            v286 = *(int **)v223;
                            *(_BYTE *)(v285 + 282) = 1;
                            v287 = *v286;
                            *(_DWORD *)(v285 + 260) = v287;
                            get_hardware_timestamp(v285 + 400, v288, 1, v287);
                            copy_system_time(v285 + 408, v285 + 400);
                            *(_BYTE *)(v285 + 440) = 66;
                            calculate_hashrate_metrics(v285);
                            if ( byte_66641 && (*(_BYTE *)v320 || *(_BYTE *)v322 || dword_657B8 > 6) )
                            {
                              v272 = "Generated benchfile work";
LABEL_457:
                              v273 = *(_DWORD *)v272;
                              v274 = *((_DWORD *)v272 + 1);
                              v275 = *((_DWORD *)v272 + 2);
                              v276 = *((_DWORD *)v272 + 3);
                              v277 = (int *)(v272 + 16);
                              v329[0] = v273;
                              v329[1] = v274;
                              v329[2] = v275;
                              v329[3] = v276;
                              v278 = v277[1];
                              v279 = v277[2];
                              v329[4] = *v277;
                              v329[5] = v278;
                              LOBYTE(v329[6]) = v279;
                              log_event(7, v329, 0);
                            }
LABEL_458:
                            push_work_to_hash_queue(v324);
                            v324 = 0;
                          }
                          else if ( v321[1376] )
                          {
                            v267 = v324;
                            *(_QWORD *)(v324 + 376) = 4629700416936869888LL;
                            log_memcpy_error(v267 + 160, &unk_683BC, 32, "cgminer.c", "get_benchmark_work", 4298);
                            v268 = v319;
                            v269 = *(int **)v223;
                            *(_BYTE *)(v267 + 282) = 1;
                            *(_DWORD *)(v267 + 244) = v268;
                            v270 = *v269;
                            *(_DWORD *)(v267 + 260) = v270;
                            get_hardware_timestamp(v267 + 400, v268, 1, v270);
                            copy_system_time(v267 + 408, v267 + 400);
                            v271 = (unsigned __int8)byte_66641;
                            *(_BYTE *)(v267 + 440) = 66;
                            if ( v271 && (*(_BYTE *)v320 || *(_BYTE *)v322 || dword_657B8 > 6) )
                            {
                              v272 = "Generated benchmark work";
                              goto LABEL_457;
                            }
                            goto LABEL_458;
                          }
                        }
                        goto LABEL_370;
                      }
LABEL_386:
                      v228 = switch_pools(0);
                      v229 = get_current_pool_index(v228);
                      v230 = *((_DWORD *)v321 + 255);
                      if ( v230 == 4 )
                      {
                        v229 = find_min_timestamp_device();
LABEL_389:
                        if ( !byte_66641 )
                          goto LABEL_394;
                        goto LABEL_390;
                      }
                      if ( v230 != 3 )
                        goto LABEL_389;
                      v231 = *v195;
                      v232 = 0;
                      v233 = *(int **)v223;
                      while ( v232 < v231 )
                      {
                        if ( *(_DWORD *)(v233[v232] + 64) < *(_DWORD *)(v233[v232] + 60) )
                          goto LABEL_429;
                        ++v232;
                      }
                      for ( kk = 0; v231 > kk; ++kk )
                      {
                        v252 = v233[kk];
                        *(_DWORD *)(v252 + 64) = 0;
                      }
                      v253 = *(v224 - 18) + 1;
                      if ( v231 <= v253 )
                        v253 = 0;
                      *(v224 - 18) = v253;
LABEL_429:
                      v254 = 0;
                      v255 = v223;
                      while ( 1 )
                      {
                        v257 = v254 + 1;
                        if ( v254 >= *v195 )
                          break;
                        v258 = *(_DWORD *)(*(_DWORD *)v255 + 4 * *(v224 - 18));
                        v259 = *(_DWORD *)(v258 + 64);
                        v260 = *(_DWORD *)(v258 + 60);
                        *(_DWORD *)(v258 + 64) = v259 + 1;
                        if ( v259 < v260 )
                        {
                          if ( !*(_BYTE *)(v258 + 97) && *(_DWORD *)(v258 + 100) == 1 && !check_status_flags(v258) )
                          {
                            v223 = v255;
                            v229 = v284;
                            goto LABEL_468;
                          }
                          if ( *v316 )
                          {
                            v261 = get_connection_handle_by_id(0);
                            --*(_DWORD *)(v261 + 64);
                          }
                        }
                        v256 = *(v224 - 18) + 1;
                        v85 = v256 < *v195;
                        *(v224 - 18) = v256;
                        if ( !v85 )
                          *(v224 - 18) = 0;
                        v254 = v257;
                      }
                      v223 = v255;
                      for ( mm = 0; ; ++mm )
                      {
                        if ( mm >= *v195 )
                          goto LABEL_389;
                        v282 = get_connection_handle_by_id(mm);
                        if ( !*(_BYTE *)(v282 + 97) && *(_DWORD *)(v282 + 100) == 1 && !check_status_flags(v282) )
                          break;
                      }
                      v229 = v283;
LABEL_468:
                      if ( byte_66641 )
                      {
LABEL_390:
                        if ( *(_BYTE *)v320 || *(_BYTE *)v322 || dword_657B8 > 6 )
                        {
                          snprintf((char *)v329, 2048u, v317, *(_DWORD *)v229);
                          log_event(7, v329, 0);
                        }
LABEL_394:
                        if ( !*(_BYTE *)(v229 + 97) && *(_DWORD *)(v229 + 100) == 1 )
                          goto LABEL_469;
LABEL_396:
                        pthread_mutex_unlock((pthread_mutex_t *)(v319 - 12));
                        get_and_update_system_time(11);
                      }
                      else
                      {
LABEL_469:
                        if ( check_status_flags(v229) )
                          goto LABEL_396;
                        pthread_mutex_unlock((pthread_mutex_t *)(v319 - 12));
                      }
                    }
                    v235 = find_min_timestamp_device();
LABEL_379:
                    if ( byte_66641 )
                    {
LABEL_380:
                      if ( *(_BYTE *)v320 || *(_BYTE *)v322 || dword_657B8 > 6 )
                      {
                        snprintf((char *)v329, 2048u, v317, *(_DWORD *)v235);
                        log_event(7, v329, 0);
                      }
                    }
                    if ( *(_BYTE *)(v235 + 97) || *(_DWORD *)(v235 + 100) != 1 )
                      goto LABEL_386;
                    goto LABEL_447;
                  }
                  v216 = pthread_mutex_lock((pthread_mutex_t *)&unk_68194);
                  while ( *v195 > (int)v197 )
                  {
                    v217 = *(_DWORD *)(*(_DWORD *)v317 + 4 * (_DWORD)v197);
                    v216 = v217 + 100;
                    if ( *(_DWORD *)(v217 + 100) != 1 )
                      v216 = increment_counter_and_set_flag(v216);
                    ++v197;
                    *(_BYTE *)(v217 + 97) = 1;
                  }
                  if ( *(_BYTE *)v196 || *(_BYTE *)v322 || dword_657B8 > 4 )
                  {
                    strcpy((char *)v329, "Probing for an alive pool");
                    v216 = log_event(5, v329, 0);
                  }
                  initialize_mining_threads(v216);
                  v218 = 0;
                  pthread_mutex_unlock((pthread_mutex_t *)&unk_68194);
                  do
                  {
                    ++v218;
                    sleep(1u);
                    if ( v218 == 180 )
                      v219 = 0;
                    else
                      v219 = (v321[796] ^ 1) & 1;
                  }
                  while ( v219 );
                  v315 = &byte_66641;
                  v220 = v322;
                  while ( 1 )
                  {
                    if ( v321[796] )
                    {
                      v328[0] = 28519;
                      if ( *v315 && (*(_BYTE *)v196 || *(_BYTE *)v322 || dword_657B8 > 6) )
                      {
                        snprintf((char *)v329, 2048u, "check success, send %s", (const char *)v328);
                        log_event(7, v329, 0);
                      }
                      v304 = strlen((const char *)v328);
                      flush_api_semaphore(v328, v304);
                      goto LABEL_311;
                    }
                    if ( v219 )
                      goto LABEL_355;
                    if ( ((*(_BYTE *)v196 || *(_BYTE *)v220 || dword_657B8 > 2)
                       && ((strcpy((char *)v329, "No servers were found that could be used to get work from."),
                            log_event(3, v329, 0),
                            *(_BYTE *)v196)
                        || *(_BYTE *)v220)
                       || dword_657B8 > 2)
                      && ((strcpy(
                             (char *)v329,
                             "Please check the details from the list below of the servers you have input"),
                           log_event(3, v329, 0),
                           *(_BYTE *)v196)
                       || *(_BYTE *)v220)
                      || dword_657B8 > 2 )
                    {
                      strcpy(
                        (char *)v329,
                        "Most likely you have input the wrong URL, forgotten to add a port, or have not set up workers");
                      log_event(3, v329, 0);
                    }
                    for ( nn = 0; *v195 > nn; ++nn )
                    {
                      if ( *(_BYTE *)v196 || *(_BYTE *)v220 || dword_657B8 > 3 )
                      {
                        snprintf(
                          (char *)v329,
                          2048u,
                          "Pool: %d  URL: %s  User: %s  Password: %s",
                          nn,
                          *(const char **)(*(_DWORD *)(*(_DWORD *)v317 + 4 * nn) + 164),
                          *(const char **)(*(_DWORD *)(*(_DWORD *)v317 + 4 * nn) + 172),
                          *(const char **)(*(_DWORD *)(*(_DWORD *)v317 + 4 * nn) + 176));
                        log_event(4, v329, 0);
                      }
                    }
                    if ( byte_73FD2 )
                      break;
LABEL_356:
                    if ( *v315 && (*(_BYTE *)v196 || *(_BYTE *)v220 || dword_657B8 > 6) )
                    {
                      strcpy((char *)v329, "No servers could be used! Exiting.");
                      log_event(7, v329, 0);
                    }
LABEL_361:
                    get_and_update_system_time(500);
                    v219 = 1;
                  }
                  if ( !*(_BYTE *)v196 && !*(_BYTE *)v220 && dword_657B8 <= 2 )
                    goto LABEL_361;
                  strcpy((char *)v329, "Press any key to exit, or cgminer will wait indefinitely for an alive pool.");
                  log_event(3, v329, 0);
LABEL_355:
                  if ( byte_73FD2 )
                    goto LABEL_361;
                  goto LABEL_356;
                }
                if ( byte_70CE8 || *(_BYTE *)v322 )
                  goto LABEL_112;
                goto LABEL_111;
              }
              goto LABEL_145;
            }
          }
          snprintf((char *)v329, 2048u, "Log file path: %s Open flag: %s", (const char *)&dword_66540, v317);
          log_event(3, v329, 0);
        }
        v109 = (const char *)*((_DWORD *)v321 + 130);
        if ( !v109 )
        {
          v322 = (char **)&byte_66640;
          goto LABEL_175;
        }
LABEL_145:
        memset(v328, 0, sizeof(v328));
        v128 = (const char *)*((_DWORD *)v321 + 129);
        if ( v128 )
        {
          if ( !*v128 )
          {
            v147 = "Log work asic num empty";
            v148 = v329;
LABEL_201:
            v149 = *(_DWORD *)v147;
            v150 = *((_DWORD *)v147 + 1);
            v151 = *((_DWORD *)v147 + 2);
            v152 = *((_DWORD *)v147 + 3);
            v153 = v147 + 16;
            *v148 = v149;
            v148[1] = v150;
            v148[2] = v151;
            v148[3] = v152;
            v154 = v148 + 4;
            v155 = v153[1];
            *v154 = *v153;
            v154[1] = v155;
            goto LABEL_202;
          }
          v129 = strtol(v128, 0, 10);
          v130 = v129 == 1;
          if ( v129 != 1 )
            v130 = ((v129 - 32) & 0xFFFFFFDF) == 0;
          *(v320 - 153) = v129;
          if ( !v130 )
          {
            strcpy((char *)v329, "Log work asic num must be 1, 32, 64");
            log_event(3, v329, 1);
            shutdown_miner(1, 1);
          }
          v322 = (char **)&byte_66640;
          if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
          {
            snprintf(
              (char *)v329,
              2048u,
              "Log work path: %s Asic num: %s",
              *((const char **)v321 + 130),
              *((const char **)v321 + 129));
            log_event(3, v329, 0);
          }
        }
        else
        {
          v322 = (char **)&byte_66640;
          if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
          {
            snprintf((char *)v329, 2048u, "Log work path: %s", v109);
            log_event(3, v329, 0);
          }
        }
        sprintf((char *)v328, "%s.txt", *((const char **)v321 + 130));
        v131 = fopen64(v328, "a+");
        v132 = (unsigned __int8)byte_70CE8;
        *(v320 - 152) = v131;
        if ( v132 || *(_BYTE *)v322 || dword_657B8 > 2 )
        {
          snprintf((char *)v329, 2048u, "Log work open file %s", (const char *)v328);
          log_event(3, v329, 0);
        }
        v133 = *(v320 - 153);
        if ( v133 == 1 )
        {
          sprintf((char *)v328, "%s%02d.txt", *((const char **)v321 + 130), 1);
          v156 = fopen64(v328, "a+");
          v157 = (unsigned __int8)byte_70CE8;
          *(v320 - 151) = v156;
          if ( v157 || *(_BYTE *)v322 || dword_657B8 > 2 )
          {
            snprintf((char *)v329, 2048u, "Log work open asic %d file %s", *(v320 - 153), (const char *)v328);
            log_event(3, v329, 0);
          }
        }
        else if ( ((v133 - 32) & 0xFFFFFFDF) == 0 )
        {
          v134 = 0;
          v135 = v320;
          while ( 1 )
          {
            v138 = *(v135 - 153);
            if ( v138 < v134 )
              break;
            sprintf((char *)v328, "%s%02d_%02d.txt", *((const char **)v321 + 130), v138, v134);
            v136 = fopen64(v328, "a+");
            v137 = (unsigned __int8)byte_70CE8;
            dword_683E4[v134] = v136;
            if ( v137 || *(_BYTE *)v322 || dword_657B8 > 2 )
            {
              snprintf((char *)v329, 2048u, "Log work open asic %d file %s", *(v135 - 153), (const char *)v328);
              log_event(3, v329, 0);
            }
            ++v134;
          }
        }
        if ( *((_BYTE *)v320 - 344) )
        {
          v139 = &byte_684E8;
          v319 = "Log work open diff file %s";
          v140 = v321;
          for ( i1 = 0; i1 != 65; ++i1 )
          {
            sprintf((char *)v328, "%s_diff_%02d.txt", *((const char **)v140 + 130), i1);
            v142 = fopen64(v328, "a+");
            v143 = (unsigned __int8)byte_70CE8;
            *((_DWORD *)v139 + 1) = v142;
            v139 += 4;
            if ( v143 || *(_BYTE *)v322 || dword_657B8 > 2 )
            {
              snprintf((char *)v329, 2048u, v319, v328);
              log_event(3, v329, 0);
            }
          }
        }
LABEL_175:
        if ( byte_70CE8 || *(_BYTE *)v322 )
          goto LABEL_177;
        goto LABEL_109;
      }
      v71 = calloc(24 * *(_DWORD *)(v70 + 4), 1u);
      if ( v71 )
      {
        v72 = *(_DWORD *)(v34 + 68);
        v319 = 0;
        *(_DWORD *)(v72 + 24) = (((2 * *(_DWORD *)(v72 + 4) - 1) & *(_DWORD *)(v72 + 12)) != 0)
                              + (*(_DWORD *)(v72 + 12) >> (*(_BYTE *)(v72 + 8) + 1));
        *(_DWORD *)(*(_DWORD *)(v34 + 68) + 28) = 0;
        v73 = *(_DWORD *)(v34 + 68);
        while ( 1 )
        {
          v74 = *(_DWORD **)v73;
          if ( *(_DWORD *)(v73 + 4) <= (unsigned int)v319 )
            break;
          v75 = (_DWORD *)v74[3 * (_DWORD)v319];
          if ( v75 )
          {
            do
            {
              v76 = (_DWORD *)v75[4];
              v77 = 3 * ((2 * *(_DWORD *)(v73 + 4) - 1) & v75[7]);
              v78 = (char *)&v71[3 * ((2 * *(_DWORD *)(v73 + 4) - 1) & v75[7])];
              v79 = *((_DWORD *)v78 + 1) + 1;
              *((_DWORD *)v78 + 1) = v79;
              v80 = *(_DWORD *)(v34 + 68);
              if ( v79 > *(_DWORD *)(v80 + 24) )
              {
                ++*(_DWORD *)(v80 + 28);
                *((_DWORD *)v78 + 2) = calculate_miner_hashrate(
                                         *((_DWORD *)v78 + 1),
                                         *(_DWORD *)(*(_DWORD *)(v34 + 68) + 24));
              }
              v75[3] = 0;
              v75[4] = v71[v77];
              v81 = v71[v77];
              if ( v81 )
                *(_DWORD *)(v81 + 12) = v75;
              v71[v77] = v75;
              v75 = v76;
              v73 = *(_DWORD *)(v34 + 68);
            }
            while ( v76 );
          }
          ++v319;
        }
        free(v74);
        *(_DWORD *)(*(_DWORD *)(v34 + 68) + 4) *= 2;
        ++*(_DWORD *)(*(_DWORD *)(v34 + 68) + 8);
        **(_DWORD **)(v34 + 68) = v71;
        v82 = *(_DWORD **)(v34 + 68);
        v83 = v82[7];
        v84 = v82[3];
        v85 = v83 > v84 >> 1;
        if ( v83 <= v84 >> 1 )
          v86 = 0;
        else
          v86 = v82[8];
        if ( v85 )
          ++v86;
        v82[8] = v86;
        v87 = *(_DWORD *)(v34 + 68);
        if ( *(_DWORD *)(v87 + 32) > 1u )
          *(_DWORD *)(v87 + 36) = 1;
        goto LABEL_85;
      }
LABEL_184:
      exit(-1);
    }
    strcpy((char *)v329, "Failed to create getq");
  }
  log_event(3, v329, 1);
  shutdown_miner(1, 0);
}
// 12FA0: control flows out of bounds to 12FA4
// 139A8: bad sp value at call
// 12B14: variable 'v15' is possibly undefined
// 12B14: variable 'v16' is possibly undefined
// 13770: variable 'v115' is possibly undefined
// 13770: variable 'v116' is possibly undefined
// 13778: variable 'v117' is possibly undefined
// 13778: variable 'v118' is possibly undefined
// 13784: variable 'v119' is possibly undefined
// 13784: variable 'v120' is possibly undefined
// 1378C: variable 'v121' is possibly undefined
// 14BC0: variable 'v203' is possibly undefined
// 14BC0: variable 'v204' is possibly undefined
// 14BC0: variable 'v205' is possibly undefined
// 14BC8: variable 'v206' is possibly undefined
// 14BC8: variable 'v207' is possibly undefined
// 14BC8: variable 'v208' is possibly undefined
// 15594: variable 'v264' is possibly undefined
// 15720: variable 'v280' is possibly undefined
// 15774: variable 'v283' is possibly undefined
// 157B8: variable 'v284' is possibly undefined
// 15810: variable 'v288' is possibly undefined
// 159F4: variable 'v221' is possibly undefined
// 159F4: variable 'v222' is possibly undefined
// 159F4: variable 'v292' is possibly undefined
// 1224C: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 1E74C: using guessed type int __fastcall sub_1E74C(_DWORD, _DWORD, _DWORD, _DWORD);
// 1E7D4: using guessed type int __fastcall sub_1E7D4(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1EA68: using guessed type int __fastcall sub_1EA68(_DWORD, _DWORD);
// 1EF20: using guessed type int sub_1EF20(void);
// 1F5C4: using guessed type int __fastcall sub_1F5C4(_DWORD, _DWORD, _DWORD, _DWORD);
// 1F7F8: using guessed type int __fastcall sub_1F7F8(_DWORD);
// 21E74: using guessed type int __fastcall sub_21E74(_DWORD, _DWORD, _DWORD);
// 21EBC: using guessed type int __fastcall sub_21EBC(_DWORD, _DWORD, _DWORD, _DWORD);
// 2220C: using guessed type int __fastcall sub_2220C(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 2251C: using guessed type int __fastcall sub_2251C(_DWORD, _DWORD);
// 26D78: using guessed type void __noreturn sub_26D78();
// 27498: using guessed type int __fastcall sub_27498(_DWORD);
// 27704: using guessed type int __fastcall sub_27704(_DWORD);
// 27834: using guessed type int sub_27834();
// 27998: using guessed type int __fastcall sub_27998(_DWORD);
// 279B8: using guessed type int __fastcall sub_279B8(_DWORD);
// 279DC: using guessed type int sub_279DC(void);
// 27AF0: using guessed type int __fastcall sub_27AF0(_DWORD);
// 28604: using guessed type int sub_28604();
// 28A64: using guessed type int __fastcall sub_28A64(_DWORD, _DWORD);
// 292F8: using guessed type int __fastcall sub_292F8(_DWORD, _DWORD, _DWORD, _DWORD);
// 29D68: using guessed type int __fastcall sub_29D68(_DWORD);
// 29DCC: using guessed type int __fastcall sub_29DCC(_DWORD);
// 2AB30: using guessed type void __fastcall __noreturn sub_2AB30(_DWORD, _DWORD);
// 2AC0C: using guessed type void __noreturn sub_2AC0C();
// 2AEA8: using guessed type int __fastcall sub_2AEA8(_DWORD);
// 2B310: using guessed type int __fastcall sub_2B310(_DWORD, _DWORD, _DWORD);
// 2B394: using guessed type int __fastcall sub_2B394(_DWORD, _DWORD, _DWORD);
// 2B3BC: using guessed type int __fastcall sub_2B3BC(_DWORD, _DWORD, _DWORD);
// 2C008: using guessed type int __fastcall sub_2C008(_DWORD, _DWORD, _DWORD);
// 2C214: using guessed type int __fastcall sub_2C214(_DWORD);
// 2C5C0: using guessed type void __fastcall __noreturn sub_2C5C0(_DWORD, _DWORD);
// 2DF8C: using guessed type int __fastcall sub_2DF8C(_DWORD);
// 2E47C: using guessed type int __fastcall sub_2E47C(_DWORD);
// 2E940: using guessed type int sub_2E940(void);
// 30264: using guessed type int __fastcall sub_30264(_DWORD);
// 30818: using guessed type int sub_30818();
// 313C0: using guessed type int __fastcall sub_313C0(_DWORD);
// 31D90: using guessed type int __fastcall sub_31D90(_DWORD, _DWORD);
// 34B18: using guessed type int sub_34B18();
// 39848: using guessed type int __fastcall sub_39848(_DWORD);
// 3ABDC: using guessed type int __fastcall sub_3ABDC(_DWORD, _DWORD, _DWORD);
// 3AE24: using guessed type int __fastcall sub_3AE24(_DWORD);
// 3C280: using guessed type int __fastcall sub_3C280(_DWORD);
// 3D658: using guessed type int __fastcall sub_3D658(_DWORD, _DWORD);
// 3D72C: using guessed type int __fastcall sub_3D72C(_DWORD, _DWORD, _DWORD);
// 40E70: using guessed type int __fastcall sub_40E70(_DWORD, _DWORD);
// 41F98: using guessed type int __fastcall sub_41F98(_DWORD);
// 48AC8: using guessed type int __fastcall sub_48AC8(_DWORD, _DWORD);
// 4FD70: using guessed type __int16 word_4FD70;
// 657B8: using guessed type int dword_657B8;
// 658DC: using guessed type int (*off_658DC)(void);
// 659E0: using guessed type char *off_659E0;
// 66154: using guessed type int dword_66154;
// 66164: using guessed type char *off_66164;
// 664F8: using guessed type int stderr;
// 66518: using guessed type char byte_66518;
// 66520: using guessed type __int16 word_66520;
// 66522: using guessed type char byte_66522;
// 66540: using guessed type int dword_66540;
// 66548: using guessed type int dword_66548;
// 66640: using guessed type char byte_66640;
// 66641: using guessed type char byte_66641;
// 66642: using guessed type char byte_66642;
// 66A88: using guessed type int dword_66A88;
// 66A90: using guessed type int dword_66A90;
// 66AC4: using guessed type int dword_66AC4;
// 66B58: using guessed type int dword_66B58;
// 683E4: using guessed type int dword_683E4[65];
// 684E8: using guessed type char byte_684E8;
// 70B84: using guessed type int (__fastcall *dword_70B84)(_DWORD);
// 70C74: using guessed type int (__fastcall *dword_70C74)(_DWORD);
// 70CE8: using guessed type char byte_70CE8;
// 70D08: using guessed type int dword_70D08;
// 70D18: using guessed type int dword_70D18;
// 70DB8: using guessed type int dword_70DB8;
// 70DC0: using guessed type pthread_cond_t stru_70DC0;
// 70E5C: using guessed type int dword_70E5C;
// 70E64: using guessed type int dword_70E64;
// 70E68: using guessed type int dword_70E68;
// 71E78: using guessed type int dword_71E78;
// 72EB8: using guessed type int dword_72EB8;
// 72EBD: using guessed type char byte_72EBD;
// 72EC0: using guessed type int dword_72EC0;
// 72EE8: using guessed type pthread_rwlock_t stru_72EE8;
// 72F18: using guessed type pthread_rwlock_t stru_72F18;
// 72F38: using guessed type int dword_72F38;
// 73F6C: using guessed type char byte_73F6C;
// 73FC0: using guessed type char byte_73FC0;
// 73FC8: using guessed type int dword_73FC8;
// 73FD0: using guessed type char byte_73FD0;
// 73FD2: using guessed type char byte_73FD2;
// 740F0: using guessed type pthread_cond_t stru_740F0;
// 7413C: using guessed type char byte_7413C;
// 74180: using guessed type int dword_74180;
// 74188: using guessed type int dword_74188;

//----- (00015DFC) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __noreturn start(void (*a1)(void), int a2, int a3, int a4, ...)
{
  int v4; // [sp-4h] [bp-4h]
  va_list va; // [sp+0h] [bp+0h] BYREF

  va_start(va, a4);
  _libc_start_main(
    (int (__fastcall *)(int, char **, char **))main,
    v4,
    (char **)va,
    (void (*)(void))init,
    nullsub_9,
    a1,
    va);
  abort();
}
// 15E06: positive sp value 4 has been found
// 15E18: variable 'v4' is possibly undefined
// 49520: using guessed type int init();

//----- (00015E2C) --------------------------------------------------------
int check_gmon_start()
{
  int result; // r0

  if ( &__gmon_start__ )
    return _gmon_start__();
  return result;
}
// 11FAC: using guessed type int _gmon_start__(void);

//----- (00015E50) --------------------------------------------------------
void *get_asic_miner_status_address()
{
  return &unk_664EC;
}

//----- (00015E74) --------------------------------------------------------
__int64 get_miner_version_info()
{
  __int64 version_info; // r0

  LODWORD(version_info) = &unk_664EC;
  HIDWORD(version_info) = 0;
  return version_info;
}

//----- (00015EA0) --------------------------------------------------------
void *get_cached_asic_miner_status()
{
  void *cached_status; // r0

  if ( !byte_664FC )
  {
    cached_status = get_asic_miner_status_address();
    byte_664FC = 1;
  }
  return cached_status;
}
// 664FC: using guessed type char byte_664FC;

//----- (00015EC0) --------------------------------------------------------
void *__fastcall get_miner_info_json(int info_flag)
{
  void *json_result; // r0
  int info_json_object; // r4
  int minor_version_value; // r0
  int compile_time_value; // r0
  int type_value; // r0
  char minor_version_buffer[64]; // [sp+0h] [bp-D0h] BYREF
  char compile_time_buffer[64]; // [sp+40h] [bp-90h] BYREF
  char type_buffer[80]; // [sp+80h] [bp-50h] BYREF

  memset(minor_version_buffer, 0, sizeof(minor_version_buffer));
  memset(compile_time_buffer, 0, sizeof(compile_time_buffer));
  json_result = memset(type_buffer, 0, 64u);
  if ( info_flag )
  {
    info_json_object = initialize_miner_error_state(json_result);
    snprintf(minor_version_buffer, 64u, "%s", byte_68628);
    minor_version_value = validate_utf8_or_return_input(minor_version_buffer);
    configure_miner_connection(info_json_object, "miner_version", minor_version_value);
    snprintf(compile_time_buffer, 64u, "%s", byte_681B4);
    compile_time_value = validate_utf8_or_return_input(compile_time_buffer);
    configure_miner_connection(info_json_object, "CompileTime", compile_time_value);
    snprintf(type_buffer, 64u, "%s", byte_682B4);
    if ( byte_7427C )
      snprintf(type_buffer, 64u, "%s", &byte_7427C);
    type_value = validate_utf8_or_return_input(type_buffer);
    configure_miner_connection(info_json_object, "type", type_value);
    return (void *)configure_miner_connection(info_flag, "INFO", info_json_object);
  }
  return json_result;
}
// 47268: using guessed type int __fastcall sub_47268(_DWORD);
// 477FC: using guessed type int __fastcall sub_477FC(_DWORD);
// 4808C: using guessed type int __fastcall sub_4808C(_DWORD, _DWORD, _DWORD);
// 7427C: using guessed type char byte_7427C;

//----- (00016000) --------------------------------------------------------
void *__fastcall log_error(int destination, int status_flag, int error_code, const char *format_string)
{
  void *final_result; // r0
  bool is_null_condition; // zf
  int log_entry; // r9
  int log_content; // r6
  __int16 status_character; // r3
  int status_value; // r0
  int timestamp_value; // r0
  int error_code_value; // r0
  const char *format_str_ref; // r2
  _DWORD *format_data; // r3
  int formatted_msg_value; // r0
  int description_value; // r0
  int id_value; // r0
  __int16 status_code; // [sp+4h] [bp-54h] BYREF
  char formatted_message[48]; // [sp+8h] [bp-50h] BYREF

  status_code = 0;
  final_result = memset(formatted_message, 0, sizeof(formatted_message));
  is_null_condition = format_string == 0;
  if ( format_string )
    is_null_condition = destination == 0;
  if ( !is_null_condition )
  {
    log_entry = initialize_error_description(final_result);
    log_content = initialize_miner_error_state(log_entry);
    if ( status_flag )
      status_character = 83;
    else
      status_character = 69;
    status_code = status_character;
    status_value = validate_utf8_or_return_input(&status_code);
    configure_miner_connection(log_content, "STATUS", status_value);
    timestamp_value = set_error_context(dword_66500, dword_66500 >> 31);
    configure_miner_connection(log_content, "When", timestamp_value);
    error_code_value = set_error_context(error_code, error_code >> 31);
    configure_miner_connection(log_content, "Code", error_code_value);
    if ( error_code == 7 )
      LOWORD(format_data) = (unsigned __int16)&dword_70DB8;
    else
      LOWORD(format_str_ref) = -19196;
    if ( error_code == 7 )
    {
      HIWORD(format_data) = (unsigned int)&dword_70DB8 >> 16;
      snprintf(formatted_message, 48u, format_string, *format_data);
    }
    else
    {
      HIWORD(format_str_ref) = 4;
      snprintf(formatted_message, 48u, format_str_ref, format_string);
    }
    formatted_msg_value = validate_utf8_or_return_input(formatted_message);
    configure_miner_connection(log_content, "Msg", formatted_msg_value);
    description_value = validate_utf8_or_return_input(off_66220);
    configure_miner_connection(log_content, "Description", description_value);
    add_buffer_to_queue(log_entry, log_content);
    final_result = (void *)configure_miner_connection(destination, "STATUS", log_entry);
    if ( !status_flag )
    {
      id_value = set_error_context(1, 0);
      return (void *)configure_miner_connection(destination, "id", id_value);
    }
  }
  return final_result;
}
// 160E4: variable 'format_data' is possibly undefined
// 160F4: variable 'format_str_ref' is possibly undefined
// 47268: using guessed type int __fastcall sub_47268(_DWORD);
// 475F8: using guessed type int __fastcall sub_475F8(_DWORD);
// 477FC: using guessed type int __fastcall sub_477FC(_DWORD);
// 47A48: using guessed type int __fastcall sub_47A48(_DWORD, _DWORD);
// 4808C: using guessed type int __fastcall sub_4808C(_DWORD, _DWORD, _DWORD);
// 4854C: using guessed type int __fastcall sub_4854C(_DWORD, _DWORD);
// 66220: using guessed type void *off_66220;
// 66500: using guessed type int dword_66500;
// 70DB8: using guessed type int dword_70DB8;

//----- (00016384) --------------------------------------------------------
int __fastcall send_status_json(int is_status, const char **parameters)
{
  bool is_null_parameter; // zf
  int status_flag; // r5
  int status_message_id; // r6
  int status_code; // r0
  int current_time; // r0
  int message_code; // r0
  int api_version_code; // r0
  int message_buffer[4]; // [sp+0h] [bp-30h] BYREF
  int api_version_buffer[8]; // [sp+10h] [bp-20h] BYREF

  is_null_parameter = parameters == 0;
  if ( parameters )
    is_null_parameter = is_status == 0;
  memset(message_buffer, 0, sizeof(message_buffer));
  memset(api_version_buffer, 0, 16);
  if ( !is_null_parameter )
  {
    status_flag = is_status;
    status_message_id = initialize_miner_error_state(is_status);
    status_code = validate_utf8_or_return_input("S");
    configure_miner_connection(status_message_id, "STATUS", status_code);
    current_time = set_error_context(dword_66500, dword_66500 >> 31);
    configure_miner_connection(status_message_id, "when", current_time);
    snprintf((char *)message_buffer, 16u, "%s", *parameters);
    message_code = validate_utf8_or_return_input(message_buffer);
    configure_miner_connection(status_message_id, "Msg", message_code);
    snprintf((char *)api_version_buffer, 16u, "%s", parameters[1]);
    api_version_code = validate_utf8_or_return_input(api_version_buffer);
    configure_miner_connection(status_message_id, "api_version", api_version_code);
    return configure_miner_connection(status_flag, "STATUS", status_message_id);
  }
  return is_status;
}
// 47268: using guessed type int __fastcall sub_47268(_DWORD);
// 477FC: using guessed type int __fastcall sub_477FC(_DWORD);
// 47A48: using guessed type int __fastcall sub_47A48(_DWORD, _DWORD);
// 4808C: using guessed type int __fastcall sub_4808C(_DWORD, _DWORD, _DWORD);
// 66500: using guessed type int dword_66500;

//----- (000164A0) --------------------------------------------------------
int __fastcall get_stats(int api_param, const char **argv)
{
  int is_input_invalid; // r4
  void *miner_info_json; // r0
  int miner_info_handle; // r7
  int miner_index; // r0
  int miner_hashrate_info; // r0
  int hashrate_info_ptr; // r3
  int (*get_hashrate_func)(void); // r3
  int hashrate; // r0
  __int16 status_code; // [sp+24h] [bp-824h] BYREF
  char log_buf[2080]; // [sp+28h] [bp-820h] BYREF

  is_input_invalid = api_param == 0;
  if ( !argv )
    is_input_invalid = 1;
  status_code = 0;
  if ( is_input_invalid )
  {
    if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
    {
      snprintf(log_buf, 2048u, "%s: input bad api param\n", "get_stats");
      log_event(3, log_buf, 0);
      return -2147483646;
    }
    else
    {
      return -2147483646;
    }
  }
  else
  {
    flush_api_semaphore(&status_code, 1);
    send_status_json(api_param, argv);
    miner_info_json = get_miner_info_json(api_param);
    miner_info_handle = initialize_error_description(miner_info_json);
    if ( dword_72F38 > 0 )
    {
      do
      {
        miner_index = is_input_invalid++;
        miner_hashrate_info = get_device_by_index(miner_index);
        if ( miner_hashrate_info )
        {
          hashrate_info_ptr = *(_DWORD *)(miner_hashrate_info + 4);
          if ( hashrate_info_ptr )
          {
            get_hashrate_func = *(int (**)(void))(hashrate_info_ptr + 28);
            if ( get_hashrate_func )
            {
              hashrate = get_hashrate_func();
              add_buffer_to_queue(miner_info_handle, hashrate);
            }
          }
        }
      }
      while ( dword_72F38 > is_input_invalid );
    }
    if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
    {
      snprintf(
        log_buf,
        2048u,
        "total_mhashes_done = %lf\n new_total_mhashes_done = %lf\n total_secs = %lf\n, new_total_secs = %lf",
        unk_70CE0,
        unk_70E28,
        *(double *)&dword_66120,
        unk_66138);
      log_event(7, log_buf, 0);
    }
    configure_miner_connection(api_param, "STATS", miner_info_handle);
    return 0;
  }
}
// 2C8F4: using guessed type int __fastcall sub_2C8F4(_DWORD);
// 40E70: using guessed type int __fastcall sub_40E70(_DWORD, _DWORD);
// 475F8: using guessed type int __fastcall sub_475F8(_DWORD);
// 4808C: using guessed type int __fastcall sub_4808C(_DWORD, _DWORD, _DWORD);
// 4854C: using guessed type int __fastcall sub_4854C(_DWORD, _DWORD);
// 657B8: using guessed type int dword_657B8;
// 66120: using guessed type int dword_66120;
// 66640: using guessed type char byte_66640;
// 66641: using guessed type char byte_66641;
// 70CE8: using guessed type char byte_70CE8;
// 72F38: using guessed type int dword_72F38;

//----- (000166AC) --------------------------------------------------------
int __fastcall sub_166AC(int a1, int a2)
{
  bool v4; // zf
  int v6; // r0
  int v7; // r0
  int v8; // r5
  unsigned int v9; // r11
  int v10; // r0
  int v11; // r0
  int v12; // r0
  int v13; // r0
  int v14; // r0
  int v15; // r0
  int v16; // r0
  int v17; // r0
  int v18; // r0
  __int64 v19; // r0
  int v20; // r0
  __int64 v21; // r0
  int v22; // r0
  __int64 v23; // r0
  int v24; // r0
  __int64 v25; // r0
  int v26; // r0
  int v27; // r3
  bool v28; // cc
  time_t v29; // r0
  unsigned int v30; // lr
  int v31; // r0
  int v32; // r8
  int v33; // r4
  int v34; // r0
  int v35; // r0
  int v36; // r0
  int v37; // r2
  bool v38; // zf
  int *v39; // r3
  int v40; // r1
  int v41; // [sp+Ch] [bp-96Ch]
  char v43[4]; // [sp+24h] [bp-954h] BYREF
  int v44; // [sp+28h] [bp-950h]
  int v45[3]; // [sp+2Ch] [bp-94Ch] BYREF
  char v46[4]; // [sp+38h] [bp-940h] BYREF
  int v47; // [sp+3Ch] [bp-93Ch]
  int v48; // [sp+40h] [bp-938h]
  int v49; // [sp+44h] [bp-934h]
  int v50; // [sp+48h] [bp-930h]
  int v51; // [sp+4Ch] [bp-92Ch]
  char s[128]; // [sp+50h] [bp-928h] BYREF
  char v53[128]; // [sp+D0h] [bp-8A8h] BYREF
  char v54[2088]; // [sp+150h] [bp-828h] BYREF

  memset(s, 0, sizeof(s));
  memset(v53, 0, sizeof(v53));
  v4 = a1 == 0;
  if ( a1 )
    v4 = a2 == 0;
  memset(v45, 0, sizeof(v45));
  *(_DWORD *)v43 = 0;
  *(_DWORD *)v46 = 0;
  v44 = 0;
  v47 = 0;
  v48 = 0;
  v49 = 0;
  v50 = 0;
  v51 = 0;
  if ( v4 )
  {
    if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
    {
      snprintf(v54, 2048u, "%s: input bad api param\n", "get_pools");
      log_event(3, v54, 0);
      return -2147483646;
    }
    else
    {
      return -2147483646;
    }
  }
  else
  {
    send_status_json(a1, a2);
    v6 = get_miner_info_json(a1);
    v41 = initialize_error_description(v6);
    if ( dword_70DB8 > 0 )
    {
      v7 = -2004318071;
      v8 = 0;
      v9 = 0;
      do
      {
        v32 = *(_DWORD *)(dword_70E5C + 4 * v8);
        if ( v32 )
        {
          v33 = initialize_miner_error_state(v7);
          v34 = set_error_context(v8, v9);
          configure_miner_connection(v33, "index", v34);
          memset(s, 0, sizeof(s));
          snprintf(s, 128u, "%s", *(const char **)(v32 + 164));
          v35 = validate_utf8_or_return_input(s);
          configure_miner_connection(v33, "url", v35);
          memset(v53, 0, sizeof(v53));
          snprintf(v53, 128u, "%s", *(const char **)(v32 + 172));
          v36 = validate_utf8_or_return_input(v53);
          configure_miner_connection(v33, "user", v36);
          v37 = *(_DWORD *)(v32 + 100);
          memset(v45, 0, sizeof(v45));
          if ( v37 == 1 )
          {
            v38 = *(_BYTE *)(v32 + 97) == 0;
            if ( *(_BYTE *)(v32 + 97) )
              LOWORD(v39) = -26616;
            else
              LOWORD(v39) = -26608;
            HIWORD(v39) = 4;
            v40 = v39[1];
            v45[0] = *v39;
            if ( v38 )
              LOWORD(v45[1]) = v40;
            else
              LOBYTE(v45[1]) = v40;
          }
          else if ( v37 )
          {
            if ( v37 == 2 )
              strcpy((char *)v45, "Rejecting");
            else
              strcpy((char *)v45, "Unknown");
          }
          else
          {
            strcpy((char *)v45, "Disabled");
          }
          v10 = validate_utf8_or_return_input(v45);
          configure_miner_connection(v33, "status", v10);
          v11 = set_error_context(*(_DWORD *)(v32 + 4), *(int *)(v32 + 4) >> 31);
          configure_miner_connection(v33, "priority", v11);
          v12 = set_error_context(*(_DWORD *)(v32 + 116), 0);
          configure_miner_connection(v33, "getworks", v12);
          v13 = set_error_context(*(_DWORD *)(v32 + 8), *(_DWORD *)(v32 + 12));
          configure_miner_connection(v33, "accepted", v13);
          v14 = set_error_context(*(_DWORD *)(v32 + 16), *(_DWORD *)(v32 + 20));
          configure_miner_connection(v33, "rejected", v14);
          v15 = set_error_context(*(_DWORD *)(v32 + 124), 0);
          configure_miner_connection(v33, "discarded", v15);
          v16 = set_error_context(*(_DWORD *)(v32 + 120), 0);
          configure_miner_connection(v33, "stale", v16);
          *(_DWORD *)v43 = 0;
          v44 = 0;
          snprintf(v43, 8u, "%s", (const char *)(v32 + 48));
          v17 = validate_utf8_or_return_input(v43);
          configure_miner_connection(v33, "diff", v17);
          v18 = set_error_context(*(_DWORD *)(v32 + 40), *(_DWORD *)(v32 + 44));
          configure_miner_connection(v33, "diff1", v18);
          v19 = calculate_hash_rate(*(_DWORD *)(v32 + 72), *(_DWORD *)(v32 + 76));
          v20 = set_error_context(v19, HIDWORD(v19));
          configure_miner_connection(v33, "diffa", v20);
          v21 = calculate_hash_rate(*(_DWORD *)(v32 + 80), *(_DWORD *)(v32 + 84));
          v22 = set_error_context(v21, HIDWORD(v21));
          configure_miner_connection(v33, "diffr", v22);
          v23 = calculate_hash_rate(*(_DWORD *)(v32 + 88), *(_DWORD *)(v32 + 92));
          v24 = set_error_context(v23, HIDWORD(v23));
          configure_miner_connection(v33, "diffs", v24);
          v25 = calculate_hash_rate(*(_DWORD *)(v32 + 360), *(_DWORD *)(v32 + 364));
          v26 = set_error_context(v25, HIDWORD(v25));
          configure_miner_connection(v33, "lsdiff", v26);
          v27 = *(_DWORD *)(v32 + 352);
          *(_DWORD *)v46 = 0;
          v47 = 0;
          v28 = v27 <= 0;
          v48 = 0;
          if ( v27 <= 0 )
            LOWORD(v27) = 48;
          v49 = 0;
          v50 = 0;
          v51 = 0;
          if ( v28 )
          {
            *(_WORD *)v46 = v27;
          }
          else
          {
            v29 = time(0);
            v30 = (v29 - *(_DWORD *)(v32 + 352)) & ~((v29 - *(_DWORD *)(v32 + 352)) >> 31);
            snprintf(v46, 24u, "%d:%02d:%02d", v30 / 3600, v30 % 3600 / 60, v30 % 3600 % 60);
          }
          v31 = validate_utf8_or_return_input(v46);
          configure_miner_connection(v33, "lstime", v31);
          v7 = add_buffer_to_queue(v41, v33);
        }
        v9 = (__PAIR64__(v9, v8++) + 1) >> 32;
      }
      while ( dword_70DB8 > v8 );
    }
    configure_miner_connection(a1, "POOLS", v41);
    return 0;
  }
}
// 15EC0: using guessed type int __fastcall sub_15EC0(_DWORD);
// 16384: using guessed type int __fastcall sub_16384(_DWORD, _DWORD);
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 47268: using guessed type int __fastcall sub_47268(_DWORD);
// 475F8: using guessed type int __fastcall sub_475F8(_DWORD);
// 477FC: using guessed type int __fastcall sub_477FC(_DWORD);
// 47A48: using guessed type int __fastcall sub_47A48(_DWORD, _DWORD);
// 4808C: using guessed type int __fastcall sub_4808C(_DWORD, _DWORD, _DWORD);
// 4854C: using guessed type int __fastcall sub_4854C(_DWORD, _DWORD);
// 493A4: using guessed type __int64 __fastcall sub_493A4(_DWORD, _DWORD);
// 657B8: using guessed type int dword_657B8;
// 66640: using guessed type char byte_66640;
// 70CE8: using guessed type char byte_70CE8;
// 70DB8: using guessed type int dword_70DB8;
// 70E5C: using guessed type int dword_70E5C;

//----- (00016C18) --------------------------------------------------------
int __fastcall sub_16C18(int a1, int a2)
{
  bool v4; // zf
  int v5; // r4
  int v7; // r0
  int v8; // r11
  unsigned int v9; // r9
  int v10; // r4
  int v11; // r6
  int v12; // r5
  int v13; // r0
  int v14; // r0
  int v15; // r3
  int v16; // r0
  int v17; // r0
  int v18; // r0
  int v19; // r0
  int v20; // r0
  int v21; // r0
  int v22; // r0
  int v23; // r0
  int v24; // r0
  int v25; // r0
  int v26; // r0
  int v27; // r0
  int v28; // r0
  int v29; // r3
  bool v30; // cc
  time_t v31; // r0
  unsigned int v32; // lr
  int v33; // r0
  int v34; // r0
  int v35; // r0
  int v36; // r0
  int v37; // r0
  char *v38; // r0
  int v39; // r0
  int v40; // r0
  double v41; // r0
  int v42; // r0
  int v43; // r0
  double v44; // r0
  int v45; // r0
  int v46; // r0
  double v47; // r0
  int v48; // r0
  int v49; // r0
  double v50; // r0
  int v51; // r0
  int v52; // r0
  int v53; // r2
  int v54; // r0
  int v55; // r2
  int v56; // r0
  int v57; // r0
  int v58; // r0
  int v59; // r2
  double v60; // r0
  int v61; // r0
  double v62; // r0
  double v63; // d5
  double v64; // d7
  int v65; // r0
  int v66; // r0
  double v67; // r0
  double v68; // d5
  double v69; // d7
  int v70; // r0
  int v71; // r0
  int v72; // r0
  int v73; // r0
  bool v74; // zf
  int *v75; // r3
  int v76; // r1
  int v78; // [sp+20h] [bp-978h]
  char v79[4]; // [sp+34h] [bp-964h] BYREF
  int v80; // [sp+38h] [bp-960h]
  int v81[3]; // [sp+3Ch] [bp-95Ch] BYREF
  char v82[4]; // [sp+48h] [bp-950h] BYREF
  int v83; // [sp+4Ch] [bp-94Ch]
  int v84; // [sp+50h] [bp-948h]
  int v85; // [sp+54h] [bp-944h]
  int v86; // [sp+58h] [bp-940h]
  int v87; // [sp+5Ch] [bp-93Ch]
  char s[128]; // [sp+60h] [bp-938h] BYREF
  char v89[128]; // [sp+E0h] [bp-8B8h] BYREF
  char v90[2104]; // [sp+160h] [bp-838h] BYREF

  memset(s, 0, sizeof(s));
  memset(v89, 0, sizeof(v89));
  v4 = a1 == 0;
  if ( a1 )
    v4 = a2 == 0;
  memset(v81, 0, sizeof(v81));
  *(_DWORD *)v79 = 0;
  *(_DWORD *)v82 = 0;
  v80 = 0;
  v83 = 0;
  v84 = 0;
  v85 = 0;
  v86 = 0;
  v87 = 0;
  if ( v4 )
  {
    if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
    {
      v5 = -2147483646;
      snprintf(v90, 2048u, "%s: input bad api param\n", "get_pools_old");
      log_event(3, v90, 0);
    }
    else
    {
      return -2147483646;
    }
  }
  else
  {
    v5 = dword_70DB8;
    if ( dword_70DB8 )
    {
      v7 = log_error(a1, 1, 7, *(_DWORD *)(a2 + 8));
      v78 = initialize_error_description(v7);
      if ( dword_70DB8 > 0 )
      {
        v8 = 0;
        v9 = 0;
        do
        {
          v10 = *(_DWORD *)(dword_70E5C + 4 * v8);
          v11 = *(unsigned __int8 *)(v10 + 105);
          if ( !*(_BYTE *)(v10 + 105) )
          {
            v12 = initialize_miner_error_state();
            v13 = set_error_context(v8, v9);
            configure_miner_connection(v12, "POOL", v13);
            memset(s, v11, sizeof(s));
            snprintf(s, 128u, "%s", *(_DWORD *)(v10 + 164));
            v14 = validate_utf8_or_return_input(s);
            configure_miner_connection(v12, "URL", v14);
            v15 = *(_DWORD *)(v10 + 100);
            v81[0] = v11;
            v81[1] = v11;
            v81[2] = v11;
            if ( v15 == 1 )
            {
              v74 = *(_BYTE *)(v10 + 97) == 0;
              if ( *(_BYTE *)(v10 + 97) )
                LOWORD(v75) = -26436;
              else
                LOWORD(v75) = -26608;
              HIWORD(v75) = 4;
              v76 = v75[1];
              v81[0] = *v75;
              if ( v74 )
                LOWORD(v81[1]) = v76;
              else
                LOBYTE(v81[1]) = v76;
            }
            else if ( v15 )
            {
              if ( v15 == 2 )
                strcpy((char *)v81, "Rejecting");
              else
                strcpy((char *)v81, "Unknown");
            }
            else
            {
              strcpy((char *)v81, "Disabled");
            }
            v16 = validate_utf8_or_return_input(v81);
            configure_miner_connection(v12, "Status", v16);
            v17 = set_error_context(*(_DWORD *)(v10 + 4), *(int *)(v10 + 4) >> 31);
            configure_miner_connection(v12, "Priority", v17);
            v18 = set_error_context(*(_DWORD *)(v10 + 56), *(int *)(v10 + 56) >> 31);
            configure_miner_connection(v12, "Quota", v18);
            if ( *(_DWORD *)(v10 + 108) )
              LOWORD(v19) = -26400;
            else
              LOWORD(v19) = -26384;
            HIWORD(v19) = 4;
            v20 = validate_utf8_or_return_input(v19);
            configure_miner_connection(v12, "Long Poll", v20);
            v21 = set_error_context(*(_DWORD *)(v10 + 116), 0);
            configure_miner_connection(v12, "Getworks", v21);
            v22 = set_error_context(*(_DWORD *)(v10 + 8), *(_DWORD *)(v10 + 12));
            configure_miner_connection(v12, "Accepted", v22);
            v23 = set_error_context(*(_DWORD *)(v10 + 16), *(_DWORD *)(v10 + 20));
            configure_miner_connection(v12, "Rejected", v23);
            v24 = set_error_context(*(_DWORD *)(v10 + 124), 0);
            configure_miner_connection(v12, "Discarded", v24);
            v25 = set_error_context(*(_DWORD *)(v10 + 120), 0);
            configure_miner_connection(v12, "Stale", v25);
            v26 = set_error_context(*(_DWORD *)(v10 + 128), 0);
            configure_miner_connection(v12, "Get Failures", v26);
            v27 = set_error_context(*(_DWORD *)(v10 + 132), 0);
            configure_miner_connection(v12, "Remote Failures", v27);
            memset(v89, 0, sizeof(v89));
            snprintf(v89, 128u, "%s", *(_DWORD *)(v10 + 172));
            v28 = validate_utf8_or_return_input(v89);
            configure_miner_connection(v12, "User", v28);
            v29 = *(_DWORD *)(v10 + 352);
            *(_DWORD *)v82 = 0;
            v83 = 0;
            v30 = v29 <= 0;
            v84 = 0;
            if ( v29 <= 0 )
              LOWORD(v29) = 48;
            v85 = 0;
            v86 = 0;
            v87 = 0;
            if ( v30 )
            {
              *(_WORD *)v82 = v29;
            }
            else
            {
              v31 = time(0);
              v32 = (v31 - *(_DWORD *)(v10 + 352)) & ~((v31 - *(_DWORD *)(v10 + 352)) >> 31);
              snprintf(v82, 24u, "%d:%02d:%02d", v32 / 3600, v32 % 3600 / 60, v32 % 3600 % 60);
            }
            v33 = validate_utf8_or_return_input(v82);
            configure_miner_connection(v12, "Last Share Time", v33);
            *(_DWORD *)v79 = 0;
            v80 = 0;
            snprintf(v79, 8u, "%s", v10 + 48);
            v34 = validate_utf8_or_return_input(v79);
            configure_miner_connection(v12, "Diff", v34);
            v35 = set_error_context(*(_DWORD *)(v10 + 40), *(_DWORD *)(v10 + 44));
            configure_miner_connection(v12, "Diff1 Shares", v35);
            if ( *(_DWORD *)(v10 + 184) )
            {
              v36 = get_protocol_type(*(_DWORD *)(v10 + 180));
              v37 = validate_utf8_or_return_input(v36);
              configure_miner_connection(v12, "Proxy Type", v37);
              v38 = *(char **)(v10 + 184);
            }
            else
            {
              v73 = validate_utf8_or_return_input("");
              configure_miner_connection(v12, "Proxy Type", v73);
              v38 = "";
            }
            v39 = validate_utf8_or_return_input(v38);
            configure_miner_connection(v12, "Proxy", v39);
            v40 = calculate_hash_rate(
                    COERCE_UNSIGNED_INT64(*(double *)(v10 + 72) * 100.0),
                    HIDWORD(COERCE_UNSIGNED_INT64(*(double *)(v10 + 72) * 100.0)));
            v41 = convert_float_to_int(v40);
            v42 = check_and_set_error_description(LODWORD(v41));
            configure_miner_connection(v12, "Difficulty Accepted", v42);
            v43 = calculate_hash_rate(
                    COERCE_UNSIGNED_INT64(*(double *)(v10 + 80) * 100.0),
                    HIDWORD(COERCE_UNSIGNED_INT64(*(double *)(v10 + 80) * 100.0)));
            v44 = convert_float_to_int(v43);
            v45 = check_and_set_error_description(LODWORD(v44));
            configure_miner_connection(v12, "Difficulty Rejected", v45);
            v46 = calculate_hash_rate(
                    COERCE_UNSIGNED_INT64(*(double *)(v10 + 88) * 100.0),
                    HIDWORD(COERCE_UNSIGNED_INT64(*(double *)(v10 + 88) * 100.0)));
            v47 = convert_float_to_int(v46);
            v48 = check_and_set_error_description(LODWORD(v47));
            configure_miner_connection(v12, "Difficulty Stale", v48);
            v49 = calculate_hash_rate(
                    COERCE_UNSIGNED_INT64(*(double *)(v10 + 360) * 100.0),
                    HIDWORD(COERCE_UNSIGNED_INT64(*(double *)(v10 + 360) * 100.0)));
            v50 = convert_float_to_int(v49);
            v51 = check_and_set_error_description(LODWORD(v50));
            v52 = configure_miner_connection(v12, "Last Share Difficulty", v51);
            if ( *(_BYTE *)(v10 + 640) )
              v53 = get_reference_to_unk_664D4(v52);
            else
              v53 = get_global_variable_address(v52);
            v54 = configure_miner_connection(v12, "Has Stratum", v53);
            if ( *(_BYTE *)(v10 + 641) )
              v55 = get_reference_to_unk_664D4(v54);
            else
              v55 = get_global_variable_address(v54);
            configure_miner_connection(v12, "Stratum Active", v55);
            if ( *(_BYTE *)(v10 + 641) )
              v56 = *(_DWORD *)(v10 + 576);
            else
              v56 = 46460;
            if ( !*(_BYTE *)(v10 + 641) )
              HIWORD(v56) = 4;
            v57 = validate_utf8_or_return_input(v56);
            v58 = configure_miner_connection(v12, "Stratum URL", v57);
            if ( *(_BYTE *)(v10 + 736) )
              v59 = get_reference_to_unk_664D4(v58);
            else
              v59 = get_global_variable_address(v58);
            configure_miner_connection(v12, "Has GBT", v59);
            v60 = convert_float_to_int(100 * *(_DWORD *)(v10 + 368));
            v61 = check_and_set_error_description(LODWORD(v60));
            LODWORD(v62) = configure_miner_connection(v12, "Best Share", v61);
            v63 = *(double *)(v10 + 80);
            v64 = v63 + *(double *)(v10 + 72) + *(double *)(v10 + 88);
            if ( v64 != 0.0 )
            {
              v65 = calculate_hash_rate(
                      COERCE_UNSIGNED_INT64(v63 / v64 * 100.0),
                      HIDWORD(COERCE_UNSIGNED_INT64(v63 / v64 * 100.0)));
              v62 = convert_float_to_int(v65);
            }
            v66 = check_and_set_error_description(LODWORD(v62));
            LODWORD(v67) = configure_miner_connection(v12, "Pool Rejected%", v66);
            v68 = *(double *)(v10 + 88);
            v69 = *(double *)(v10 + 72) + *(double *)(v10 + 80) + v68;
            if ( v69 != 0.0 )
            {
              v70 = calculate_hash_rate(
                      COERCE_UNSIGNED_INT64(v68 / v69 * 100.0),
                      HIDWORD(COERCE_UNSIGNED_INT64(v68 / v69 * 100.0)));
              v67 = convert_float_to_int(v70);
            }
            v71 = check_and_set_error_description(LODWORD(v67));
            configure_miner_connection(v12, "Pool Stale%%", v71);
            add_buffer_to_queue(v78, v12);
          }
          v9 = (__PAIR64__(v9, v8++) + 1) >> 32;
        }
        while ( dword_70DB8 > v8 );
      }
      v5 = 0;
      configure_miner_connection(a1, "POOLS", v78);
      v72 = set_error_context(1, 0);
      configure_miner_connection(a1, "id", v72);
    }
    else
    {
      log_error(a1, dword_70DB8, 8, "No pools");
    }
  }
  return v5;
}
// 16000: using guessed type int __fastcall sub_16000(_DWORD, _DWORD, _DWORD, _DWORD);
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 1E8F8: using guessed type int __fastcall sub_1E8F8(_DWORD);
// 47268: using guessed type int sub_47268(void);
// 475F8: using guessed type int __fastcall sub_475F8(_DWORD);
// 477FC: using guessed type int __fastcall sub_477FC(_DWORD);
// 47A48: using guessed type int __fastcall sub_47A48(_DWORD, _DWORD);
// 47ACC: using guessed type int __fastcall sub_47ACC(_DWORD);
// 47C00: using guessed type int __fastcall sub_47C00(_DWORD);
// 47C0C: using guessed type int __fastcall sub_47C0C(_DWORD);
// 4808C: using guessed type int __fastcall sub_4808C(_DWORD, _DWORD, _DWORD);
// 4854C: using guessed type int __fastcall sub_4854C(_DWORD, _DWORD);
// 4930C: using guessed type double __fastcall sub_4930C(_DWORD);
// 493A4: using guessed type int __fastcall sub_493A4(_DWORD, _DWORD);
// 657B8: using guessed type int dword_657B8;
// 66640: using guessed type char byte_66640;
// 70CE8: using guessed type char byte_70CE8;
// 70DB8: using guessed type int dword_70DB8;
// 70E5C: using guessed type int dword_70E5C;

//----- (0001751C) --------------------------------------------------------
int *__fastcall close_socket(int *socket_descriptor)
{
  int socket_fd; // r2
  int *socket_ptr; // r4

  socket_fd = *socket_descriptor;
  byte_66504 = 1;
  if ( socket_fd != -1 )
  {
    socket_ptr = socket_descriptor;
    shutdown(socket_fd, 2);
    socket_descriptor = (int *)close(*socket_ptr);
    *socket_ptr = -1;
  }
  return socket_descriptor;
}
// 66504: using guessed type char byte_66504;

//----- (00017560) --------------------------------------------------------
int __fastcall process_miner_command(int command_type, const char *command_name, unsigned int command_index)
{
  int function_result; // r0
  int command_match_index; // r5
  const char *current_command_option; // r1
  const char *current_command_group_option; // r1
  char **command_group_pointer; // r9
  const char *next_command_group_option; // t1
  int log_result; // r0
  char command_name_buffer[4]; // [sp+4h] [bp-94h] BYREF
  int zero_init_1; // [sp+8h] [bp-90h]
  int zero_init_2; // [sp+Ch] [bp-8Ch]
  int zero_init_3; // [sp+10h] [bp-88h]
  char response_buffer[132]; // [sp+14h] [bp-84h] BYREF

  memset(response_buffer, 0, 100u);
  if ( !command_type || command_index > 2 )
    return -2147483646;
  command_match_index = 0;
  function_result = strlen(command_name);
  zero_init_1 = 0;
  *(_DWORD *)command_name_buffer = 0;
  zero_init_2 = 0;
  zero_init_3 = 0;
  if ( (unsigned int)(function_result - 1) > 15 )
  {
    if ( command_index )
      return function_result;
    goto LABEL_22;
  }
  strncpy(command_name_buffer, command_name, function_result);
  if ( command_index )
  {
    current_command_option = off_65298;
    if ( !off_65298 )
      return (int)log_error(command_type, 0, 14, "Invalid command");
    while ( strcmp(command_name_buffer, current_command_option) )
    {
      ++command_match_index;
      current_command_option = (&off_65298)[4 * command_match_index];
      if ( !current_command_option )
        return (int)log_error(command_type, 0, 14, "Invalid command");
    }
    return ((int (__fastcall *)(int))(&off_65298)[4 * command_match_index + 3])(command_type);
  }
  current_command_group_option = off_652F8[0];
  if ( !off_652F8[0] )
  {
LABEL_19:
    snprintf(response_buffer, 100u, "not support (%s)", command_name);
    goto LABEL_18;
  }
  command_group_pointer = off_652F8;
  while ( strcmp(command_name_buffer, current_command_group_option) )
  {
    next_command_group_option = command_group_pointer[3];
    command_group_pointer += 3;
    current_command_group_option = next_command_group_option;
    ++command_index;
    if ( !next_command_group_option )
      goto LABEL_19;
  }
  function_result = ((int (__fastcall *)(int, char **))(&off_65298)[3 * command_index + 26])(
                      command_type,
                      &off_652F8[3 * command_index]);
  if ( function_result < 0 )
  {
    if ( function_result != -2147483646 )
    {
LABEL_18:
      log_result = validate_utf8_or_return_input(response_buffer);
      return configure_miner_connection(command_type, "error_message", log_result);
    }
LABEL_22:
    strcpy(response_buffer, "bad param");
    goto LABEL_18;
  }
  return function_result;
}
// 477FC: using guessed type int __fastcall sub_477FC(_DWORD);
// 4808C: using guessed type int __fastcall sub_4808C(_DWORD, _DWORD, _DWORD);
// 65298: using guessed type char *off_65298;
// 652F8: using guessed type char *off_652F8[2];

//----- (0001770C) --------------------------------------------------------
char *__fastcall format_miner_status(char *dest_buffer, int *status_code)
{
  double converted_num; // d0
  char *final_result; // r0
  int status_value; // r3
  __int64 long_status_value; // r0
  const char *string_status_value; // r0
  int formatted_status[68]; // [sp+8h] [bp-110h] BYREF

  final_result = (char *)memset(formatted_status, 0, 256u);
  if ( status_code )
  {
    status_value = *status_code;
    if ( *status_code == 6 )
    {
      strcpy((char *)formatted_status, "false");
    }
    else
    {
      switch ( status_value )
      {
        case 5:
          strcpy((char *)formatted_status, "true");
          break;
        case 3:
          long_status_value = get_linked_list_next_node(status_code);
          snprintf((char *)formatted_status, 256u, "%lld", long_status_value);
          break;
        case 4:
          sub_47B28(status_code);
          snprintf((char *)formatted_status, 256u, "%.2lf", converted_num);
          break;
        case 2:
          string_status_value = (const char *)get_linked_item_or_null(status_code);
          snprintf((char *)formatted_status, 256u, "%s", string_status_value);
          break;
      }
    }
    return strcat(dest_buffer, (const char *)formatted_status);
  }
  return final_result;
}
// 177E4: variable 'converted_num' is possibly undefined
// 47820: using guessed type int __fastcall sub_47820(_DWORD);
// 47A7C: using guessed type __int64 __fastcall sub_47A7C(_DWORD);
// 47B28: using guessed type int __fastcall sub_47B28(_DWORD);

//----- (00017810) --------------------------------------------------------
int __fastcall update_miner_status(int json_object, _DWORD *data_array, int miner_id)
{
  int data_count; // r4
  _DWORD *current_element; // r12
  int index; // r3
  int miner_id_in_element; // t1
  int json_result; // r6
  int status_result; // r0
  __int64 code_value; // r0
  int code_result; // r0
  int message_result; // r2
  int element_offset; // r5

  data_count = data_array[2];
  if ( data_count > 0 )
  {
    current_element = (_DWORD *)data_array[4];
    if ( miner_id == *current_element )
    {
      element_offset = 0;
LABEL_7:
      json_result = json_object;
      status_result = validate_utf8_or_return_input(*(_DWORD *)(data_array[3] + element_offset));
      configure_miner_connection(json_result, "status", status_result);
      code_value = *(int *)(data_array[4] + element_offset);
      code_result = set_error_context(code_value, HIDWORD(code_value));
      configure_miner_connection(json_result, "code", code_result);
      message_result = validate_utf8_or_return_input(*(_DWORD *)(data_array[5] + element_offset));
      return configure_miner_connection(json_result, "msg", message_result);
    }
    else
    {
      index = 0;
      while ( 1 )
      {
        ++index;
        element_offset = 4 * index;
        if ( index == data_count )
          break;
        miner_id_in_element = current_element[1];
        ++current_element;
        if ( miner_id_in_element == miner_id )
          goto LABEL_7;
      }
    }
  }
  return json_object;
}
// 477FC: using guessed type int __fastcall sub_477FC(_DWORD);
// 47A48: using guessed type int __fastcall sub_47A48(_DWORD, _DWORD);
// 4808C: using guessed type int __fastcall sub_4808C(_DWORD, _DWORD, _DWORD);

//----- (000178C8) --------------------------------------------------------
int __fastcall update_miner_status_if_needed(int miner_id, _DWORD *status_ptr)
{
  int status_update_flag; // r2

  if ( miner_id )
  {
    if ( (dword_75C78 & 4) != 0 )
      status_update_flag = -2;
    else
      status_update_flag = (unsigned __int8)dword_75C78 << 30 >> 31;
    if ( status_ptr )
      return update_miner_status(miner_id, status_ptr, status_update_flag);
  }
  return miner_id;
}
// 75C78: using guessed type int dword_75C78;

//----- (000178F4) --------------------------------------------------------
int __fastcall update_miner_status_if_valid(int status_code, _DWORD *status_info)
{
  if ( status_code )
  {
    if ( status_info )
      return update_miner_status(status_code, status_info, (unsigned __int8)dword_75C78 << 31 >> 31);
  }
  return status_code;
}
// 75C78: using guessed type int dword_75C78;

//----- (00017918) --------------------------------------------------------
int __fastcall update_fan_status(int status, _DWORD *miner_config)
{
  int status_copy; // r5
  int fan_status; // r2
  double target_temp; // [sp+0h] [bp-20h] BYREF
  double current_temp; // [sp+8h] [bp-18h] BYREF

  status_copy = status;
  target_temp = 0.0;
  current_temp = 0.0;
  if ( status )
  {
    sscanf(byte_7438C, "%lf", &target_temp);
    status = sscanf(byte_743AC, "%lf", &current_temp);
    if ( current_temp * 0.95 <= target_temp )
      fan_status = (unsigned __int8)dword_75C78 << 28 >> 31;
    else
      fan_status = -1;
    if ( miner_config )
      return update_miner_status(status_copy, miner_config, fan_status);
  }
  return status;
}
// 75C78: using guessed type int dword_75C78;

//----- (000179C4) --------------------------------------------------------
int reload_configuration()
{
  int compare_result; // r5
  char log_message[2064]; // [sp+0h] [bp-810h] BYREF

  if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
  {
    snprintf(log_message, 2048u, "<<<<<<<<<<<<<<<<<<<<exec %s start>>>>>>>>>>>>>>>>", "reload_config");
    log_event(7, log_message, 0);
  }
  compare_result = strcmp(s1, "127.0.0.1");
  if ( compare_result )
    return -2147483643;
  load_default_config();
  if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
  {
    snprintf(log_message, 2048u, "<<<<<<<<<<<<<<<<<<<<exec %s end>>>>>>>>>>>>>>>>>>", "reload_config");
    log_event(7, log_message, 0);
  }
  return compare_result;
}
// 657B8: using guessed type int dword_657B8;
// 66640: using guessed type char byte_66640;
// 66641: using guessed type char byte_66641;
// 70CE8: using guessed type char byte_70CE8;

//----- (00017AFC) --------------------------------------------------------
int __fastcall update_on_successful_lock(int lock_status, _DWORD *miner_data)
{
  int status_code; // r7
  int update_status; // r8
  int device_counter; // r3
  int device_list_index; // lr
  int device_ptr; // r12
  int next_device; // t1

  status_code = lock_status;
  if ( !lock_status )
    return lock_status;
  lock_status = pthread_mutex_trylock((pthread_mutex_t *)&unk_68194);
  update_status = lock_status;
  if ( lock_status )
  {
    update_status = 0;
LABEL_10:
    if ( !miner_data )
      return lock_status;
    return update_miner_status(status_code, miner_data, update_status);
  }
  if ( dword_70DB8 <= 0 )
  {
LABEL_9:
    update_status = -1;
    lock_status = pthread_mutex_unlock((pthread_mutex_t *)&unk_68194);
    goto LABEL_10;
  }
  device_counter = 0;
  device_list_index = dword_70E5C - 4;
  while ( 1 )
  {
    next_device = *(_DWORD *)(device_list_index + 4);
    device_list_index += 4;
    device_ptr = next_device;
    ++device_counter;
    if ( *(_DWORD *)(next_device + 100) )
    {
      if ( !*(_BYTE *)(device_ptr + 97) )
        break;
    }
    if ( device_counter == dword_70DB8 )
      goto LABEL_9;
  }
  lock_status = pthread_mutex_unlock((pthread_mutex_t *)&unk_68194);
  if ( miner_data )
    return update_miner_status(status_code, miner_data, update_status);
  return lock_status;
}
// 70DB8: using guessed type int dword_70DB8;
// 70E5C: using guessed type int dword_70E5C;

//----- (00017BBC) --------------------------------------------------------
void __fastcall send_data_with_retry(int *socket_fd, char *data)
{
  int retry_count; // r8
  char *current_data_ptr; // r6
  signed int remaining_bytes; // r5
  fd_set *current_fd_set_ptr; // r3
  int socket_bit_index; // r0
  int socket_bit_position; // lr
  int select_result; // r0
  ssize_t sent_bytes; // r0
  _BOOL4 should_exit; // r3
  int errno_val; // r0
  char *error_str; // r0
  signed int total_bytes; // [sp+14h] [bp-8BCh]
  struct timeval select_timeout; // [sp+20h] [bp-8B0h] BYREF
  fd_set write_fd_set; // [sp+28h] [bp-8A8h] BYREF
  char s[2040]; // [sp+A8h] [bp-828h] BYREF

  retry_count = 0;
  current_data_ptr = data;
  remaining_bytes = strlen(data) + 1;
  total_bytes = remaining_bytes;
  while ( 1 )
  {
    current_fd_set_ptr = (fd_set *)&select_timeout.tv_usec;
    select_timeout.tv_sec = 0;
    select_timeout.tv_usec = 50000;
    do
    {
      current_fd_set_ptr->__fds_bits[1] = 0;
      current_fd_set_ptr = (fd_set *)((char *)current_fd_set_ptr + 4);
    }
    while ( current_fd_set_ptr != (fd_set *)&write_fd_set.__fds_bits[31] );
    socket_bit_index = *socket_fd;
    LOBYTE(socket_bit_position) = *socket_fd & 0x1F;
    if ( *socket_fd <= 0 )
      socket_bit_position = -(-socket_bit_index & 0x1F);
    write_fd_set.__fds_bits[*socket_fd / 32] |= 1 << socket_bit_position;
    select_result = select(socket_bit_index + 1, 0, &write_fd_set, 0, &select_timeout);
    if ( select_result <= 0 )
      break;
    sent_bytes = send(*socket_fd, current_data_ptr, remaining_bytes, 0);
    if ( sent_bytes < 0 )
    {
      errno_val = *_errno_location();
      if ( errno_val != 11 )
      {
        if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
        {
          error_str = strerror(errno_val);
          snprintf(
            s,
            2048u,
            "%s: send (%d:%d) failed %s",
            "send_api_result",
            total_bytes,
            total_bytes - remaining_bytes,
            error_str);
          log_event(3, s, 0);
        }
        return;
      }
      if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
      {
        snprintf(s, 2048u, "%s: send EAGAIN ", "send_api_result");
        log_event(7, s, 0);
      }
LABEL_9:
      ++retry_count;
      goto LABEL_10;
    }
    remaining_bytes -= sent_bytes;
    current_data_ptr += sent_bytes;
    if ( !sent_bytes )
      goto LABEL_9;
LABEL_10:
    should_exit = retry_count > 2;
    if ( remaining_bytes <= 0 )
      should_exit = 1;
    if ( should_exit )
      return;
  }
  if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
  {
    snprintf(s, 2048u, "%s: send select failed, ret = %d", "send_api_result", select_result);
    log_event(3, s, 0);
  }
}
// 657B8: using guessed type int dword_657B8;
// 66640: using guessed type char byte_66640;
// 66641: using guessed type char byte_66641;
// 70CE8: using guessed type char byte_70CE8;

//----- (00017E60) --------------------------------------------------------
int __fastcall get_miner_stats(int stats_holder, int a2)
{
  bool v4; // zf
  _DWORD *v6; // r4
  const char *v7; // r0
  const char *v8; // r0
  const char *v9; // r0
  const char *v10; // r0
  int device_by_index; // r4
  _DWORD *v12; // r5
  int v13; // r0
  const char *v14; // r0
  __int64 v15; // r0
  int v16; // r0
  int v17; // r0
  int v18; // r0
  int v19; // r0
  int v20; // r0
  int v21; // r0
  int v22; // r0
  int v23; // r0
  int v24; // r0
  int v25; // r0
  int v26; // r0
  int v27; // r0
  int v28; // r0
  int v29; // r0
  _DWORD *v30; // r2
  int v31; // r3
  int v32; // r12
  int v33; // r0
  int v34; // r0
  int *v35; // r6
  int v36; // r4
  int v37; // t1
  int v38; // r0
  int v39; // r7
  int v40; // r0
  int v41; // r8
  _DWORD *v42; // r4
  int v43; // r6
  int v44; // r4
  int v45; // r6
  _DWORD *v46; // r2
  int v47; // r3
  const char *v48; // r0
  int v49; // r4
  int v50; // r6
  _DWORD *v51; // r2
  int v52; // r3
  const char *v53; // r0
  int v54; // r4
  int v55; // r6
  _DWORD *v56; // r2
  int v57; // r3
  const char *v58; // r0
  int v59; // r0
  int v60; // r0
  const char *v61; // r0
  int v62; // r0
  int v63; // r1
  _DWORD *v64; // r2
  int v65; // r3
  int v66; // r0
  _BOOL4 v67; // lr
  int v68; // r4
  int v69; // r0
  int v70; // r0
  int v71; // r0
  int v72; // r0
  int v73; // r0
  int v74; // r6
  _DWORD *v75; // r2
  int v76; // r3
  __int64 v77; // r0
  int v78; // r0
  int v79; // r4
  int v80; // r6
  _DWORD *v81; // r2
  int v82; // r3
  const char *v83; // r0
  int v84; // r4
  int v85; // r6
  _DWORD *v86; // r2
  int v87; // r3
  __int64 v88; // r0
  int v89; // r0
  int v90; // r4
  int v91; // r6
  _DWORD *v92; // r2
  int v93; // r3
  const char *v94; // r0
  const char *v95; // r0
  int v96; // r4
  int v97; // r6
  _DWORD *v98; // r2
  int v99; // r3
  __int64 v100; // r0
  int v101; // r0
  const char *v102; // r0
  const char *v103; // r0
  int v104; // r0
  int v105; // r3
  int v106; // r0
  int v107; // r0
  int v108; // r3
  int v109; // r0
  int v110; // r0
  int v111; // r3
  int v112; // r0
  int *v113; // r0
  int *v114; // r0
  int v115; // [sp+14h] [bp-A0Ch]
  __int64 i; // [sp+18h] [bp-A08h]
  int v117; // [sp+24h] [bp-9FCh]
  __int64 v118; // [sp+28h] [bp-9F8h]
  _DWORD *v119; // [sp+38h] [bp-9E8h]
  __int16 v121; // [sp+5Ch] [bp-9C4h] BYREF
  double v122; // [sp+60h] [bp-9C0h] BYREF
  double v123; // [sp+68h] [bp-9B8h] BYREF
  double v124; // [sp+70h] [bp-9B0h] BYREF
  double v125; // [sp+78h] [bp-9A8h] BYREF
  char v126[4]; // [sp+80h] [bp-9A0h] BYREF
  int v127; // [sp+84h] [bp-99Ch]
  int v128; // [sp+88h] [bp-998h]
  int v129; // [sp+8Ch] [bp-994h]
  char s[32]; // [sp+90h] [bp-990h] BYREF
  char v131[64]; // [sp+B0h] [bp-970h] BYREF
  char v132[256]; // [sp+F0h] [bp-930h] BYREF
  char v133[2096]; // [sp+1F0h] [bp-830h] BYREF

  v122 = 0.0;
  v123 = 0.0;
  v124 = 0.0;
  v125 = 0.0;
  *(_DWORD *)v126 = 0;
  v127 = 0;
  v128 = 0;
  v129 = 0;
  memset(s, 0, sizeof(s));
  memset(v132, 0, sizeof(v132));
  v121 = 0;
  memset(v131, 0, sizeof(v131));
  v4 = stats_holder == 0;
  if ( stats_holder )
    v4 = a2 == 0;
  if ( v4 )
  {
    if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
    {
      snprintf(v133, 2048u, "%s: input bad api param\n", "get_stats_old");
      log_event(3, v133, 0);
      return -2147483646;
    }
    else
    {
      return -2147483646;
    }
  }
  else
  {
    flush_api_semaphore((int)&v121, 1);
    if ( pthread_mutex_lock(&stru_74258) )
    {
      v113 = _errno_location();
      snprintf(v133, 2048u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v113, "api_new.c", "get_stats_old", 896);
      log_event(3, v133, 1);
      shutdown_miner_safely(1);
    }
    log_error(stats_holder, 1, 70, *(const char **)(a2 + 8));
    v119 = initialize_error_description();
    v6 = initialize_miner_error_state();
    v7 = validate_utf8_or_return_input("1.0.0");
    configure_miner_connection(v6, "BMMiner", v7);
    v8 = validate_utf8_or_return_input(byte_68628);
    configure_miner_connection(v6, "Miner", v8);
    v9 = validate_utf8_or_return_input(byte_681B4);
    configure_miner_connection(v6, "CompileTime", v9);
    snprintf(v131, 64u, "%s", byte_682B4);
    if ( byte_7427C )
      snprintf(v131, 64u, "%s", &byte_7427C);
    v10 = validate_utf8_or_return_input(v131);
    configure_miner_connection(v6, "Type", v10);
    add_buffer_to_queue(v119, v6);
    if ( dword_72F38 > 0 )
    {
      v117 = 0;
      v115 = 0;
      for ( i = 0LL; dword_72F38 > (int)i; ++i )
      {
        device_by_index = get_device_by_index(i);
        v12 = initialize_miner_error_state();
        v13 = set_error_context(i);
        configure_miner_connection(v12, "STATS", v13);
        snprintf(v126, 16u, "BTM_SOC%d", (_DWORD)i);
        v14 = validate_utf8_or_return_input(v126);
        configure_miner_connection(v12, "ID", v14);
        v15 = calculate_hash_rate(dword_66120, unk_66124);
        v16 = set_error_context(v15);
        configure_miner_connection(v12, "Elapsed", v16);
        v17 = set_error_context(*(unsigned int *)(device_by_index + 292));
        configure_miner_connection(v12, "Calls", v17);
        v18 = set_error_context(*(int *)(device_by_index + 296));
        configure_miner_connection(v12, "Wait", v18);
        v19 = set_error_context(*(int *)(device_by_index + 304));
        configure_miner_connection(v12, "Max", v19);
        v20 = set_error_context(*(int *)(device_by_index + 312));
        configure_miner_connection(v12, "Min", v20);
        sscanf(byte_7437C, "%lf", &v122);
        v21 = calculate_hash_rate(COERCE_UNSIGNED_INT64(v122 * 100.0), HIDWORD(COERCE_UNSIGNED_INT64(v122 * 100.0)));
        convert_float_to_int(v21);
        v22 = check_and_set_error_description();
        configure_miner_connection(v12, "GHS 5s", v22);
        sscanf(src, "%lf", &v124);
        v23 = calculate_hash_rate(COERCE_UNSIGNED_INT64(v124 * 100.0), HIDWORD(COERCE_UNSIGNED_INT64(v124 * 100.0)));
        convert_float_to_int(v23);
        v24 = check_and_set_error_description();
        configure_miner_connection(v12, "GHS av", v24);
        sscanf(byte_7438C, "%lf", &v123);
        v25 = calculate_hash_rate(COERCE_UNSIGNED_INT64(v123 * 100.0), HIDWORD(COERCE_UNSIGNED_INT64(v123 * 100.0)));
        convert_float_to_int(v25);
        v26 = check_and_set_error_description();
        configure_miner_connection(v12, "rate_30m", v26);
        v27 = set_error_context(unk_661F8);
        configure_miner_connection(v12, "Mode", v27);
        v28 = set_error_context(dword_74274);
        configure_miner_connection(v12, "miner_count", v28);
        if ( dword_74274 > 0 )
        {
          v29 = v115;
          v30 = &unk_74270;
          v31 = 0;
          do
          {
            v32 = v30[91];
            ++v31;
            v30 += 388;
            v29 += v32;
          }
          while ( v31 != dword_74274 && v31 != 4 );
          v115 = v29;
        }
        v115 = calculate_modulo_via_bitshift(v115);
        LODWORD(v118) = v115;
        v33 = set_error_context(v115);
        configure_miner_connection(v12, "frequency", v33);
        v34 = set_error_context(*(int *)&byte_743AC[24]);
        configure_miner_connection(v12, "fan_num", v34);
        if ( *(int *)&byte_743AC[24] > 0 )
        {
          v35 = &dword_743C8;
          v36 = 0;
          do
          {
            ++v36;
            memset(s, 0, sizeof(s));
            snprintf(s, 32u, "fan%d", v36);
            v37 = *v35++;
            v38 = set_error_context(v37);
            configure_miner_connection(v12, s, v38);
          }
          while ( v36 < *(int *)&byte_743AC[24] );
        }
        v39 = 0;
        v40 = set_error_context(dword_74274);
        configure_miner_connection(v12, "temp_num", v40);
        do
        {
          v41 = v39 + 1;
          if ( dword_74274 > 0 )
          {
            v42 = &unk_74270;
            v43 = 0;
            do
            {
              ++v43;
              if ( v42[90] == v39 )
              {
                memset(s, 0, sizeof(s));
                snprintf(s, 32u, "temp%d", v39 + 1);
                v105 = v42[170];
                v106 = v42[172];
                if ( v105 < v42[169] )
                  v105 = v42[169];
                if ( v105 < -255 )
                  v105 = -255;
                if ( v105 < v42[171] )
                  v105 = v42[171];
                if ( v105 >= v106 )
                  v106 = v105;
                v107 = set_error_context(v106);
                configure_miner_connection(v12, s, v107);
                memset(s, 0, sizeof(s));
                snprintf(s, 32u, "temp2_%d", v39 + 1);
                v108 = v42[174];
                v109 = v42[176];
                if ( v108 < v42[173] )
                  v108 = v42[173];
                if ( v108 < -255 )
                  v108 = -255;
                if ( v108 < v42[175] )
                  v108 = v42[175];
                if ( v108 >= v109 )
                  v109 = v108;
                v110 = set_error_context(v109);
                configure_miner_connection(v12, s, v110);
              }
              v42 += 388;
            }
            while ( dword_74274 > v43 );
          }
          ++v39;
        }
        while ( v41 != 4 );
        v44 = 0;
        do
        {
          v45 = v44 + 1;
          memset(s, 0, sizeof(s));
          memset(v132, 0, sizeof(v132));
          snprintf(s, 32u, "temp_pcb%d", v44 + 1);
          if ( dword_74274 > 0 )
          {
            if ( dword_743D8 == v44 )
            {
              v47 = 0;
LABEL_37:
              snprintf(
                v132,
                256u,
                "%d-%d-%d-%d",
                *((_DWORD *)&unk_74270 + 388 * v47 + 169),
                *((_DWORD *)&unk_74270 + 388 * v47 + 170),
                *((_DWORD *)&unk_74270 + 388 * v47 + 171),
                *((_DWORD *)&unk_74270 + 388 * v47 + 172));
              goto LABEL_38;
            }
            v46 = &unk_74270;
            v47 = 0;
            while ( 1 )
            {
              ++v47;
              v46 += 388;
              if ( dword_74274 == v47 )
                goto LABEL_130;
              if ( v47 == 4 )
                break;
              if ( v46[90] == v44 )
                goto LABEL_37;
            }
            if ( dword_74274 > 4 )
              goto LABEL_37;
          }
LABEL_130:
          strcpy(v132, "0-0-0-0");
LABEL_38:
          ++v44;
          v48 = validate_utf8_or_return_input(v132);
          configure_miner_connection(v12, s, v48);
        }
        while ( v45 != 4 );
        v49 = 0;
        do
        {
          v50 = v49 + 1;
          memset(s, 0, sizeof(s));
          memset(v132, 0, sizeof(v132));
          snprintf(s, 32u, "temp_chip%d", v49 + 1);
          if ( dword_74274 > 0 )
          {
            if ( dword_743D8 == v49 )
            {
              v52 = 0;
LABEL_46:
              snprintf(
                v132,
                256u,
                "%d-%d-%d-%d",
                *((_DWORD *)&unk_74270 + 388 * v52 + 173),
                *((_DWORD *)&unk_74270 + 388 * v52 + 174),
                *((_DWORD *)&unk_74270 + 388 * v52 + 175),
                *((_DWORD *)&unk_74270 + 388 * v52 + 176));
              goto LABEL_47;
            }
            v51 = &unk_74270;
            v52 = 0;
            while ( 1 )
            {
              ++v52;
              v51 += 388;
              if ( dword_74274 == v52 )
                goto LABEL_128;
              if ( v52 == 4 )
                break;
              if ( v51[90] == v49 )
                goto LABEL_46;
            }
            if ( dword_74274 > 4 )
              goto LABEL_46;
          }
LABEL_128:
          strcpy(v132, "0-0-0-0");
LABEL_47:
          ++v49;
          v53 = validate_utf8_or_return_input(v132);
          configure_miner_connection(v12, s, v53);
        }
        while ( v50 != 4 );
        v54 = 0;
        do
        {
          v55 = v54 + 1;
          memset(s, 0, sizeof(s));
          memset(v132, 0, sizeof(v132));
          snprintf(s, 32u, "temp_pic%d", v54 + 1);
          if ( dword_74274 > 0 )
          {
            if ( dword_743D8 == v54 )
            {
              v57 = 0;
LABEL_55:
              snprintf(
                v132,
                256u,
                "%d-%d-%d-%d",
                *((_DWORD *)&unk_74270 + 388 * v57 + 165),
                *((_DWORD *)&unk_74270 + 388 * v57 + 166),
                *((_DWORD *)&unk_74270 + 388 * v57 + 167),
                *((_DWORD *)&unk_74270 + 388 * v57 + 168));
              goto LABEL_56;
            }
            v56 = &unk_74270;
            v57 = 0;
            while ( 1 )
            {
              ++v57;
              v56 += 388;
              if ( dword_74274 == v57 )
                goto LABEL_126;
              if ( v57 == 4 )
                break;
              if ( v56[90] == v54 )
                goto LABEL_55;
            }
            if ( dword_74274 > 4 )
              goto LABEL_55;
          }
LABEL_126:
          strcpy(v132, "0-0-0-0");
LABEL_56:
          ++v54;
          v58 = validate_utf8_or_return_input(v132);
          configure_miner_connection(v12, s, v58);
        }
        while ( v55 != 4 );
        sscanf(byte_743AC, "%lf", &v125);
        v59 = calculate_hash_rate(COERCE_UNSIGNED_INT64(v125 * 100.0), HIDWORD(COERCE_UNSIGNED_INT64(v125 * 100.0)));
        convert_float_to_int(v59);
        v60 = check_and_set_error_description();
        configure_miner_connection(v12, "total_rateideal", v60);
        v61 = validate_utf8_or_return_input("GH");
        configure_miner_connection(v12, "rate_unit", v61);
        HIDWORD(v118) = v115 >> 31;
        v62 = set_error_context(v118);
        configure_miner_connection(v12, "total_freqavg", v62);
        if ( dword_74274 > 0 )
        {
          v63 = v117;
          v64 = &unk_74270;
          v65 = 0;
          do
          {
            ++v65;
            v66 = v64[100];
            v64 += 388;
            v67 = dword_74274 > v65;
            v63 += v66;
            if ( v65 > 3 )
              v67 = 0;
          }
          while ( v67 );
          v117 = v63;
        }
        v68 = 0;
        v69 = set_error_context(v117);
        configure_miner_connection(v12, "total_acn", v69);
        v70 = calculate_hash_rate(COERCE_UNSIGNED_INT64(v124 * 100.0), HIDWORD(COERCE_UNSIGNED_INT64(v124 * 100.0)));
        convert_float_to_int(v70);
        v71 = check_and_set_error_description();
        configure_miner_connection(v12, "total rate", v71);
        v72 = set_error_context(0LL);
        configure_miner_connection(v12, "temp_max", v72);
        v73 = set_error_context(dword_73FB8);
        configure_miner_connection(v12, "no_matching_work", v73);
        while ( 2 )
        {
          v74 = v68 + 1;
          memset(s, 0, sizeof(s));
          snprintf(s, 32u, "chain_acn%d", v68 + 1);
          if ( dword_74274 <= 0 )
          {
LABEL_124:
            v77 = 0LL;
          }
          else
          {
            if ( dword_743D8 == v68 )
            {
              v76 = 0;
            }
            else
            {
              v75 = &unk_74270;
              v76 = 0;
              while ( 1 )
              {
                ++v76;
                v75 += 388;
                if ( dword_74274 == v76 )
                  goto LABEL_124;
                if ( v76 == 4 )
                  break;
                if ( v75[90] == v68 )
                  goto LABEL_70;
              }
              if ( dword_74274 <= 4 )
                goto LABEL_124;
            }
LABEL_70:
            v77 = *((int *)&unk_74270 + 388 * v76 + 100);
          }
          ++v68;
          v78 = set_error_context(v77);
          configure_miner_connection(v12, s, v78);
          if ( v74 != 4 )
            continue;
          break;
        }
        v79 = 0;
        do
        {
          v80 = v79 + 1;
          memset(s, 0, sizeof(s));
          memset(v132, 0, sizeof(v132));
          snprintf(s, 32u, "chain_acs%d", v79 + 1);
          if ( dword_74274 <= 0 )
            goto LABEL_122;
          if ( dword_743D8 == v79 )
          {
            v111 = 404;
            goto LABEL_81;
          }
          v81 = &unk_74270;
          v82 = 0;
          while ( 1 )
          {
            ++v82;
            v81 += 388;
            if ( v82 == dword_74274 )
              goto LABEL_122;
            if ( v82 == 4 )
              break;
            if ( v81[90] == v79 )
            {
              v111 = 1552 * v82 + 404;
              goto LABEL_81;
            }
          }
          if ( dword_74274 > 4 )
          {
            v111 = 6612;
LABEL_81:
            snprintf(v132, 256u, "%s", (const char *)&unk_74270 + v111);
          }
          else
          {
LABEL_122:
            v132[0] = 0;
          }
          ++v79;
          v83 = validate_utf8_or_return_input(v132);
          configure_miner_connection(v12, s, v83);
        }
        while ( v80 != 4 );
        v84 = 0;
        while ( 2 )
        {
          v85 = v84 + 1;
          memset(s, 0, sizeof(s));
          snprintf(s, 32u, "chain_hw%d", v84 + 1);
          if ( dword_74274 <= 0 )
          {
LABEL_120:
            v88 = 0LL;
          }
          else
          {
            if ( dword_743D8 == v84 )
            {
              v87 = 0;
            }
            else
            {
              v86 = &unk_74270;
              v87 = 0;
              while ( 1 )
              {
                ++v87;
                v86 += 388;
                if ( dword_74274 == v87 )
                  goto LABEL_120;
                if ( v87 == 4 )
                  break;
                if ( v86[90] == v84 )
                  goto LABEL_90;
              }
              if ( dword_74274 <= 4 )
                goto LABEL_120;
            }
LABEL_90:
            v88 = *((int *)&unk_74270 + 388 * v87 + 177);
          }
          ++v84;
          v89 = set_error_context(v88);
          configure_miner_connection(v12, s, v89);
          if ( v85 != 4 )
            continue;
          break;
        }
        v90 = 0;
        do
        {
          v91 = v90 + 1;
          memset(s, 0, sizeof(s));
          snprintf(s, 32u, "chain_rate%d", v90 + 1);
          if ( dword_74274 <= 0 )
            goto LABEL_131;
          if ( dword_743D8 == v90 )
          {
            v112 = 384;
            goto LABEL_101;
          }
          v92 = &unk_74270;
          v93 = 0;
          while ( 1 )
          {
            ++v93;
            v92 += 388;
            if ( v93 == dword_74274 )
              goto LABEL_131;
            if ( v93 == 4 )
              break;
            if ( v92[90] == v90 )
            {
              v112 = 1552 * v93 + 384;
              goto LABEL_101;
            }
          }
          if ( dword_74274 <= 4 )
          {
LABEL_131:
            v94 = "";
          }
          else
          {
            v112 = 6592;
LABEL_101:
            v94 = (char *)&unk_74270 + v112;
          }
          v95 = validate_utf8_or_return_input(v94);
          ++v90;
          configure_miner_connection(v12, s, v95);
        }
        while ( v91 != 4 );
        v96 = 0;
        while ( 2 )
        {
          v97 = v96 + 1;
          memset(s, 0, sizeof(s));
          snprintf(s, 32u, "freq%d", v96 + 1);
          if ( dword_74274 <= 0 )
          {
LABEL_116:
            v100 = 0LL;
          }
          else
          {
            if ( dword_743D8 != v96 )
            {
              v98 = &unk_74270;
              v99 = 0;
              while ( 1 )
              {
                ++v99;
                v98 += 388;
                if ( v99 == dword_74274 )
                  goto LABEL_116;
                if ( v99 == 4 )
                {
                  if ( dword_74274 > 4 )
                    goto LABEL_110;
                  goto LABEL_116;
                }
                if ( v98[90] == v96 )
                  goto LABEL_110;
              }
            }
            v99 = 0;
LABEL_110:
            v100 = *((int *)&unk_74270 + 388 * v99 + 91);
          }
          ++v96;
          v101 = set_error_context(v100);
          configure_miner_connection(v12, s, v101);
          if ( v97 != 4 )
            continue;
          break;
        }
        v102 = validate_utf8_or_return_input(byte_68628);
        configure_miner_connection(v12, "miner_version", v102);
        v103 = validate_utf8_or_return_input(byte_75C50);
        configure_miner_connection(v12, "miner_id", v103);
        add_buffer_to_queue(v119, v12);
      }
    }
    configure_miner_connection(stats_holder, "STATS", v119);
    v104 = set_error_context(1LL);
    configure_miner_connection(stats_holder, "id", v104);
    if ( pthread_mutex_unlock(&stru_74258) )
    {
      v114 = _errno_location();
      snprintf(
        v133,
        2048u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v114,
        "api_new.c",
        "get_stats_old",
        1171);
      log_event(3, v133, 1);
      shutdown_miner_safely(1);
    }
    off_658DC(0);
    return 0;
  }
}
// 4808C: using guessed type int __fastcall sub_4808C(_DWORD, _DWORD, _DWORD);
// 4854C: using guessed type int __fastcall sub_4854C(_DWORD, _DWORD);
// 48D40: using guessed type int __fastcall sub_48D40(_DWORD);
// 4930C: using guessed type double __fastcall sub_4930C(_DWORD);
// 493A4: using guessed type __int64 __fastcall sub_493A4(_DWORD, _DWORD);
// 657B8: using guessed type int dword_657B8;
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);
// 66120: using guessed type int dword_66120;
// 66640: using guessed type char byte_66640;
// 70CE8: using guessed type char byte_70CE8;
// 72F38: using guessed type int dword_72F38;
// 73FB8: using guessed type int dword_73FB8;
// 74258: using guessed type pthread_mutex_t stru_74258;
// 74274: using guessed type int dword_74274;
// 7427C: using guessed type char byte_7427C;
// 743C8: using guessed type int dword_743C8;
// 743D8: using guessed type int dword_743D8;

//----- (00018FE0) --------------------------------------------------------
int __fastcall check_and_report_device_status(int output_buffer, int input_buffer)
{
  bool is_invalid_input; // zf
  int valid_devices_count; // r7
  int *device_ptr; // r3
  int current_device; // t1
  int device_status; // r2
  signed int device_index; // r6
  int status_section_start; // r0
  unsigned int overall_index; // r8
  int device_status_obj; // r5
  int current_valid_device_index; // r2
  int current_device_index; // r4
  int device_offset; // r1
  int device_base_addr; // t1
  int current_device_status; // r3
  int device_info_ptr; // r4
  int sub_call_result; // r0
  int name_result; // r0
  int id_result; // r0
  int enabled_tmp; // r0
  int enabled_result; // r0
  int status_result; // r0
  int temperature_raw; // r0
  double temperature_value; // r0
  double temperature_normalized; // d0
  int temperature_result; // r0
  double mhs_value; // d9
  int mhs_normalized_raw; // r0
  double mhs_normalized_value; // r0
  int mhs_result; // r0
  int mhs_short_raw; // r0
  double mhs_short_value; // r0
  int mhs_short_result; // r0
  int accepted_result; // r0
  int rejected_result; // r0
  int hardware_errors_result; // r0
  int utility_raw; // r0
  double utility_value; // r0
  int utility_result; // r0
  int last_share_pool_sign; // r1
  int last_share_pool_raw; // r3
  int last_share_pool_value; // r0
  int last_share_pool_result; // r0
  int last_share_time_result; // r0
  int total_mh_raw; // r0
  double total_mh_value; // r0
  int total_mh_result; // r0
  int diff1_work_result; // r0
  int difficulty_accepted_raw; // r0
  int difficulty_accepted_sign; // r1
  int difficulty_accepted_result; // r0
  int difficulty_rejected_raw; // r0
  int difficulty_rejected_sign; // r1
  int difficulty_rejected_result; // r0
  int last_share_difficulty_result; // r0
  int last_valid_work_result; // r0
  int hardware_errors; // r3
  double device_hardware_errors_percentage_raw; // r0
  double device_hardware_errors; // d9
  double device_hardware_errors_percentage_value; // r0
  int device_hardware_errors_percentage; // r0
  int device_hardware_percent_result; // r0
  double device_rejected_raw; // r0
  double device_rejected_percentage; // d0
  double device_rejected_value; // r0
  int device_rejected_percentage_raw; // r0
  int device_rejected_result; // r0
  int device_elapsed_raw; // r0
  int device_elapsed_sign; // r1
  int device_elapsed_result; // r0
  int id_result_final; // r0
  int *err_location_1; // r0
  int *err_location_2; // r0
  int *err_location_3; // r0
  int *err_location_4; // r0
  int *err_location_5; // r0
  int device_status_container; // [sp+1Ch] [bp-84Ch]
  char log_buffer[2112]; // [sp+28h] [bp-840h] BYREF

  is_invalid_input = output_buffer == 0;
  if ( output_buffer )
    is_invalid_input = input_buffer == 0;
  if ( is_invalid_input )
  {
    if ( !byte_70CE8 && !byte_66640 && dword_657B8 <= 2 )
      return -2147483646;
    snprintf(log_buffer, 2048u, "%s: input bad api param\n", "get_devs_old");
    log_event(3, log_buffer, 0);
    return -2147483646;
  }
  if ( pthread_rwlock_rdlock(&stru_72F18) )
  {
    err_location_5 = _errno_location();
    snprintf(
      log_buffer,
      2048u,
      "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *err_location_5,
      "api_new.c",
      "numascs",
      1183);
    log_event(3, log_buffer, 1);
    shutdown_miner_safely(1);
  }
  if ( dword_72F38 <= 0 )
  {
    if ( !pthread_rwlock_unlock(&stru_72F18) )
    {
      off_658DC(0);
      goto LABEL_47;
    }
LABEL_52:
    err_location_3 = _errno_location();
    snprintf(
      log_buffer,
      2048u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *err_location_3,
      "api_new.c",
      "numascs",
      1188);
    log_event(3, log_buffer, 1);
    shutdown_miner_safely(1);
  }
  valid_devices_count = 0;
  device_ptr = (int *)dword_72EC0;
  do
  {
    current_device = *device_ptr++;
    device_status = **(_DWORD **)(current_device + 4);
    if ( device_status == 2 || device_status == 3 )
      ++valid_devices_count;
  }
  while ( (int *)(dword_72EC0 + 4 * dword_72F38) != device_ptr );
  if ( pthread_rwlock_unlock(&stru_72F18) )
    goto LABEL_52;
  off_658DC(0);
  if ( !valid_devices_count )
  {
LABEL_47:
    log_error(output_buffer, 0, 10, "No ASCs");
    return 0;
  }
  device_index = 0;
  status_section_start = log_error(output_buffer, 1, 9, *(_DWORD *)(input_buffer + 8));
  overall_index = 0;
  device_status_container = initialize_error_description(status_section_start);
  do
  {
    device_status_obj = initialize_miner_error_state();
    if ( pthread_rwlock_rdlock(&stru_72F18) )
    {
      err_location_1 = _errno_location();
      snprintf(
        log_buffer,
        2048u,
        "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
        *err_location_1,
        "api_new.c",
        "ascdevice",
        1196);
      log_event(3, log_buffer, 1);
      shutdown_miner_safely(1);
    }
    if ( dword_72F38 <= 0 )
    {
LABEL_48:
      if ( pthread_rwlock_unlock(&stru_72F18) )
      {
        err_location_2 = _errno_location();
        snprintf(
          log_buffer,
          2048u,
          "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
          *err_location_2,
          "api_new.c",
          "ascdevice",
          1204);
        log_event(3, log_buffer, 1);
        shutdown_miner_safely(1);
      }
      current_device_index = -1;
      ((void (*)(void))off_658DC)();
    }
    else
    {
      current_valid_device_index = 0;
      current_device_index = 0;
      device_offset = dword_72EC0 - 4;
      while ( 1 )
      {
        device_base_addr = *(_DWORD *)(device_offset + 4);
        device_offset += 4;
        current_device_status = **(_DWORD **)(device_base_addr + 4);
        if ( current_device_status == 2 || current_device_status == 3 )
          ++current_valid_device_index;
        if ( current_valid_device_index == device_index + 1 )
          break;
        if ( ++current_device_index == dword_72F38 )
          goto LABEL_48;
      }
      if ( pthread_rwlock_unlock(&stru_72F18) )
      {
        err_location_4 = _errno_location();
        snprintf(
          log_buffer,
          2048u,
          "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
          *err_location_4,
          "api_new.c",
          "ascdevice",
          1209);
        log_event(3, log_buffer, 1);
        shutdown_miner_safely(1);
      }
      ((void (*)(void))off_658DC)();
    }
    device_info_ptr = get_device_by_index(current_device_index);
    sub_call_result = set_error_context(device_index, overall_index);
    configure_miner_connection(device_status_obj, "ASC", sub_call_result);
    name_result = validate_utf8_or_return_input(*(_DWORD *)(*(_DWORD *)(device_info_ptr + 4) + 8));
    configure_miner_connection(device_status_obj, "Name", name_result);
    id_result = set_error_context(*(_DWORD *)(device_info_ptr + 8), *(int *)(device_info_ptr + 8) >> 31);
    configure_miner_connection(device_status_obj, "ID", id_result);
    if ( *(_DWORD *)(device_info_ptr + 32) == 1 )
      LOWORD(enabled_tmp) = -26384;
    else
      LOWORD(enabled_tmp) = -26400;
    HIWORD(enabled_tmp) = 4;
    enabled_result = validate_utf8_or_return_input(enabled_tmp);
    configure_miner_connection(device_status_obj, "Enabled", enabled_result);
    status_result = validate_utf8_or_return_input("Alive");
    configure_miner_connection(device_status_obj, "Status", status_result);
    temperature_raw = calculate_hash_rate(
                        COERCE_UNSIGNED_INT64(*(double *)(device_info_ptr + 176) * 100.0),
                        HIDWORD(COERCE_UNSIGNED_INT64(*(double *)(device_info_ptr + 176) * 100.0)));
    temperature_value = convert_float_to_int(temperature_raw);
    temperature_normalized = temperature_value / 100.0;
    temperature_result = check_and_set_error_description(LODWORD(temperature_value));
    configure_miner_connection(device_status_obj, "Tenperature", temperature_result);
    mhs_value = *(double *)(device_info_ptr + 80);
    update_firmware(device_info_ptr);
    mhs_normalized_raw = calculate_hash_rate(
                           COERCE_UNSIGNED_INT64(mhs_value / temperature_normalized * 100.0),
                           HIDWORD(COERCE_UNSIGNED_INT64(mhs_value / temperature_normalized * 100.0)));
    mhs_normalized_value = convert_float_to_int(mhs_normalized_raw);
    mhs_result = check_and_set_error_description(LODWORD(mhs_normalized_value));
    configure_miner_connection(device_status_obj, "MHS av", mhs_result);
    snprintf(log_buffer, 24u, "MHS %ds", dword_66130);
    mhs_short_raw = calculate_hash_rate(
                      COERCE_UNSIGNED_INT64(*(double *)(device_info_ptr + 48) * 100.0),
                      HIDWORD(COERCE_UNSIGNED_INT64(*(double *)(device_info_ptr + 48) * 100.0)));
    mhs_short_value = convert_float_to_int(mhs_short_raw);
    mhs_short_result = check_and_set_error_description(LODWORD(mhs_short_value));
    configure_miner_connection(device_status_obj, log_buffer, mhs_short_result);
    accepted_result = set_error_context(*(_DWORD *)(device_info_ptr + 36), *(int *)(device_info_ptr + 36) >> 31);
    configure_miner_connection(device_status_obj, "Accepted", accepted_result);
    rejected_result = set_error_context(*(_DWORD *)(device_info_ptr + 40), *(int *)(device_info_ptr + 40) >> 31);
    configure_miner_connection(device_status_obj, "Rejected", rejected_result);
    hardware_errors_result = set_error_context(*(_DWORD *)(device_info_ptr + 44), *(int *)(device_info_ptr + 44) >> 31);
    configure_miner_connection(device_status_obj, "Hardware Errors", hardware_errors_result);
    utility_raw = calculate_hash_rate(
                    COERCE_UNSIGNED_INT64(*(double *)(device_info_ptr + 88) * 100.0),
                    HIDWORD(COERCE_UNSIGNED_INT64(*(double *)(device_info_ptr + 88) * 100.0)));
    utility_value = convert_float_to_int(utility_raw);
    utility_result = check_and_set_error_description(LODWORD(utility_value));
    configure_miner_connection(device_status_obj, "Utility", utility_result);
    last_share_pool_raw = *(_DWORD *)(device_info_ptr + 220);
    if ( last_share_pool_raw <= 0 )
    {
      last_share_pool_sign = -1;
      last_share_pool_value = -1;
    }
    else
    {
      last_share_pool_value = *(_DWORD *)(device_info_ptr + 216);
    }
    if ( last_share_pool_raw > 0 )
      last_share_pool_sign = last_share_pool_value >> 31;
    last_share_pool_result = set_error_context(last_share_pool_value, last_share_pool_sign);
    configure_miner_connection(device_status_obj, "Last Share Pool", last_share_pool_result);
    last_share_time_result = set_error_context(
                               *(_DWORD *)(device_info_ptr + 220),
                               *(int *)(device_info_ptr + 220) >> 31);
    configure_miner_connection(device_status_obj, "Last Share Time", last_share_time_result);
    total_mh_raw = calculate_hash_rate(
                     COERCE_UNSIGNED_INT64(*(double *)(device_info_ptr + 80) * 100.0),
                     HIDWORD(COERCE_UNSIGNED_INT64(*(double *)(device_info_ptr + 80) * 100.0)));
    total_mh_value = convert_float_to_int(total_mh_raw);
    total_mh_result = check_and_set_error_description(LODWORD(total_mh_value));
    configure_miner_connection(device_status_obj, "Total MH", total_mh_result);
    diff1_work_result = set_error_context(*(_DWORD *)(device_info_ptr + 192), *(_DWORD *)(device_info_ptr + 196));
    configure_miner_connection(device_status_obj, "Diff1 Work", diff1_work_result);
    difficulty_accepted_raw = calculate_hash_rate(
                                *(_DWORD *)(device_info_ptr + 200),
                                *(_DWORD *)(device_info_ptr + 204));
    difficulty_accepted_result = set_error_context(difficulty_accepted_raw, difficulty_accepted_sign);
    configure_miner_connection(device_status_obj, "Difficulty Accepted", difficulty_accepted_result);
    difficulty_rejected_raw = calculate_hash_rate(
                                *(_DWORD *)(device_info_ptr + 208),
                                *(_DWORD *)(device_info_ptr + 212));
    difficulty_rejected_result = set_error_context(difficulty_rejected_raw, difficulty_rejected_sign);
    configure_miner_connection(device_status_obj, "Difficulty Rejected", difficulty_rejected_result);
    last_share_difficulty_result = set_error_context(
                                     *(_DWORD *)(device_info_ptr + 232),
                                     *(int *)(device_info_ptr + 232) >> 31);
    configure_miner_connection(device_status_obj, "Last Share Difficulty", last_share_difficulty_result);
    last_valid_work_result = set_error_context(
                               *(_DWORD *)(device_info_ptr + 232),
                               *(int *)(device_info_ptr + 232) >> 31);
    configure_miner_connection(device_status_obj, "Last Valid Work", last_valid_work_result);
    hardware_errors = *(_DWORD *)(device_info_ptr + 44);
    *(_QWORD *)&device_hardware_errors_percentage_raw = *(_QWORD *)(device_info_ptr + 192) + hardware_errors;
    if ( device_hardware_errors_percentage_raw != 0.0 )
    {
      device_hardware_errors = (double)hardware_errors;
      device_hardware_errors_percentage_value = convert_float_to_int(LODWORD(device_hardware_errors_percentage_raw));
      device_hardware_errors_percentage = calculate_hash_rate(
                                            COERCE_UNSIGNED_INT64(device_hardware_errors
                                                                / device_hardware_errors_percentage_value * 100.0),
                                            HIDWORD(COERCE_UNSIGNED_INT64(device_hardware_errors
                                                                        / device_hardware_errors_percentage_value * 100.0)));
      device_hardware_errors_percentage_raw = convert_float_to_int(device_hardware_errors_percentage);
    }
    device_hardware_percent_result = check_and_set_error_description(LODWORD(device_hardware_errors_percentage_raw));
    configure_miner_connection(device_status_obj, "Device Hardware%", device_hardware_percent_result);
    device_rejected_raw = *(double *)(device_info_ptr + 192);
    if ( device_rejected_raw == 0.0 )
    {
      device_rejected_percentage = 0.0;
    }
    else
    {
      device_rejected_value = convert_float_to_int(LODWORD(device_rejected_raw));
      device_rejected_percentage_raw = calculate_hash_rate(
                                         COERCE_UNSIGNED_INT64(*(double *)(device_info_ptr + 208)
                                                             / device_rejected_value * 100.0),
                                         HIDWORD(COERCE_UNSIGNED_INT64(*(double *)(device_info_ptr + 208)
                                                                     / device_rejected_value * 100.0)));
      device_rejected_raw = convert_float_to_int(device_rejected_percentage_raw);
      device_rejected_percentage = device_rejected_raw / 100.0;
    }
    device_rejected_result = check_and_set_error_description(LODWORD(device_rejected_raw));
    configure_miner_connection(device_status_obj, "Device Rejected%", device_rejected_result);
    update_firmware(device_info_ptr);
    device_elapsed_raw = calculate_hash_rate(LODWORD(device_rejected_percentage), HIDWORD(device_rejected_percentage));
    device_elapsed_result = set_error_context(device_elapsed_raw, device_elapsed_sign);
    configure_miner_connection(device_status_obj, "Device Elapsed", device_elapsed_result);
    add_buffer_to_queue(device_status_container, device_status_obj);
    overall_index = (__PAIR64__(overall_index, device_index++) + 1) >> 32;
  }
  while ( valid_devices_count > device_index );
  configure_miner_connection(output_buffer, "DEVS", device_status_container);
  id_result_final = set_error_context(1, 0);
  configure_miner_connection(output_buffer, "id", id_result_final);
  return 0;
}
// 19448: variable 'last_share_pool_sign' is possibly undefined
// 194D8: variable 'difficulty_accepted_sign' is possibly undefined
// 194F8: variable 'difficulty_rejected_sign' is possibly undefined
// 19618: variable 'device_elapsed_sign' is possibly undefined
// 16000: using guessed type int __fastcall sub_16000(_DWORD, _DWORD, _DWORD, _DWORD);
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 1DA28: using guessed type int sub_1DA28(void);
// 29090: using guessed type int __fastcall sub_29090(_DWORD);
// 2C8F4: using guessed type int __fastcall sub_2C8F4(_DWORD);
// 3AADC: using guessed type void __fastcall __noreturn sub_3AADC(_DWORD);
// 47268: using guessed type int sub_47268(void);
// 475F8: using guessed type int __fastcall sub_475F8(_DWORD);
// 477FC: using guessed type int __fastcall sub_477FC(_DWORD);
// 47A48: using guessed type int __fastcall sub_47A48(_DWORD, _DWORD);
// 47ACC: using guessed type int __fastcall sub_47ACC(_DWORD);
// 4808C: using guessed type int __fastcall sub_4808C(_DWORD, _DWORD, _DWORD);
// 4854C: using guessed type int __fastcall sub_4854C(_DWORD, _DWORD);
// 4930C: using guessed type double __fastcall sub_4930C(_DWORD);
// 493A4: using guessed type int __fastcall sub_493A4(_DWORD, _DWORD);
// 657B8: using guessed type int dword_657B8;
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);
// 66130: using guessed type int dword_66130;
// 66640: using guessed type char byte_66640;
// 70CE8: using guessed type char byte_70CE8;
// 72EC0: using guessed type int dword_72EC0;
// 72F18: using guessed type pthread_rwlock_t stru_72F18;
// 72F38: using guessed type int dword_72F38;

//----- (000198B8) --------------------------------------------------------
int __fastcall generate_miner_rate_json(int json_response, int is_valid)
{
  int total_miners; // r4
  int max_miners_processed; // r6
  int unit_api_key; // r0
  int unit_api_result; // r0
  int x_axis_api_result; // r8
  int curr_miner_index; // r4
  int min_interval; // r5
  int prev_min_interval; // r3
  int min_interval_api_key; // r0
  int x_axis_api_key; // r0
  int series_api_result; // r0
  int *miner_data_ptr; // r7
  int miner_data_index; // r9
  int miner_api_result; // r0
  int data_index; // r4
  int chain_index; // r3
  int chain_api_result; // r8
  int name_api_key; // r0
  int name_api_result; // r0
  int data_api_result; // r5
  int *curr_miner_data_ptr; // r11
  int curr_miner_data; // t1
  int curr_data_api_result; // r0
  int *lock_err_location; // r0
  int *unlock_err_location; // r0
  int final_series_api_result; // [sp+10h] [bp-860h]
  int processed_miners; // [sp+14h] [bp-85Ch]
  int chart_api_result; // [sp+28h] [bp-848h]
  int chart_data_api_key; // [sp+2Ch] [bp-844h]
  __int16 mutex_attr; // [sp+34h] [bp-83Ch] BYREF
  char format_buffer_chunk[4]; // [sp+38h] [bp-838h] BYREF
  int format_buffer_index; // [sp+3Ch] [bp-834h]
  char unit_format_buffer[4]; // [sp+40h] [bp-830h] BYREF
  int unit_format_index; // [sp+44h] [bp-82Ch]
  char error_msg[2088]; // [sp+48h] [bp-828h] BYREF

  unit_format_index = 0;
  *(_DWORD *)format_buffer_chunk = 0;
  format_buffer_index = 0;
  *(_DWORD *)unit_format_buffer = 0;
  mutex_attr = 0;
  if ( is_valid )
  {
    flush_api_semaphore(&mutex_attr, 1);
    send_status_json(json_response, is_valid);
    get_miner_info_json(json_response);
    if ( pthread_mutex_lock(&stru_74258) )
    {
      lock_err_location = _errno_location();
      snprintf(
        error_msg,
        2048u,
        "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
        *lock_err_location,
        "api_new.c",
        "get_rate",
        555);
      log_event(3, error_msg, 1);
      shutdown_miner_safely(1);
    }
    total_miners = dword_75C74;
    processed_miners = dword_75C74;
    if ( dword_75C74 >= 24 )
      max_miners_processed = 24;
    else
      max_miners_processed = dword_75C74;
    chart_data_api_key = initialize_error_description(0);
    chart_api_result = initialize_miner_error_state(chart_data_api_key);
    snprintf(unit_format_buffer, 8u, "%s/s", &byte_743AC[16]);
    unit_api_key = validate_utf8_or_return_input(unit_format_buffer);
    unit_api_result = configure_miner_connection(chart_api_result, "unit", unit_api_key);
    x_axis_api_result = initialize_error_description(unit_api_result);
    if ( total_miners > 0 )
    {
      curr_miner_index = 0;
      min_interval = 15;
      do
      {
        prev_min_interval = min_interval;
        *(_DWORD *)format_buffer_chunk = 0;
        ++curr_miner_index;
        format_buffer_index = 0;
        min_interval += 15;
        snprintf(format_buffer_chunk, 8u, "%dmin", prev_min_interval);
        min_interval_api_key = validate_utf8_or_return_input(format_buffer_chunk);
        add_buffer_to_queue(x_axis_api_result, min_interval_api_key);
      }
      while ( curr_miner_index < max_miners_processed );
    }
    x_axis_api_key = configure_miner_connection(chart_api_result, "xAxis", x_axis_api_result);
    series_api_result = initialize_error_description(x_axis_api_key);
    final_series_api_result = series_api_result;
    if ( dword_74274 > 0 )
    {
      miner_data_ptr = &dword_74534;
      miner_data_index = 0;
      do
      {
        miner_api_result = initialize_miner_error_state(series_api_result);
        data_index = 0;
        chain_index = *(miner_data_ptr - 87);
        chain_api_result = miner_api_result;
        *(_DWORD *)format_buffer_chunk = 0;
        format_buffer_index = 0;
        snprintf(format_buffer_chunk, 8u, "chain%d", chain_index);
        name_api_key = validate_utf8_or_return_input(format_buffer_chunk);
        name_api_result = configure_miner_connection(chain_api_result, "name", name_api_key);
        data_api_result = initialize_error_description(name_api_result);
        if ( processed_miners > 0 )
        {
          curr_miner_data_ptr = miner_data_ptr;
          do
          {
            curr_miner_data = curr_miner_data_ptr[1];
            ++curr_miner_data_ptr;
            ++data_index;
            curr_data_api_result = set_error_context(curr_miner_data, curr_miner_data >> 31);
            add_buffer_to_queue(data_api_result, curr_data_api_result);
          }
          while ( max_miners_processed > data_index );
        }
        ++miner_data_index;
        configure_miner_connection(chain_api_result, "data", data_api_result);
        series_api_result = add_buffer_to_queue(final_series_api_result, chain_api_result);
        miner_data_ptr += 388;
      }
      while ( dword_74274 > miner_data_index );
    }
    configure_miner_connection(chart_api_result, "series", final_series_api_result);
    add_buffer_to_queue(chart_data_api_key, chart_api_result);
    configure_miner_connection(json_response, "RATE", chart_data_api_key);
    if ( pthread_mutex_unlock(&stru_74258) )
    {
      unlock_err_location = _errno_location();
      snprintf(
        error_msg,
        2048u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *unlock_err_location,
        "api_new.c",
        "get_rate",
        594);
      log_event(3, error_msg, 1);
      shutdown_miner_safely(1);
    }
    off_658DC(0);
    return 0;
  }
  else if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
  {
    snprintf(error_msg, 2048u, "%s: input bad api param\n", "get_rate");
    log_event(3, error_msg, 0);
    return -2147483646;
  }
  else
  {
    return -2147483646;
  }
}
// 15EC0: using guessed type int __fastcall sub_15EC0(_DWORD);
// 16384: using guessed type int __fastcall sub_16384(_DWORD, _DWORD);
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 1DA28: using guessed type int sub_1DA28(void);
// 3AADC: using guessed type void __fastcall __noreturn sub_3AADC(_DWORD);
// 40E70: using guessed type int __fastcall sub_40E70(_DWORD, _DWORD);
// 47268: using guessed type int __fastcall sub_47268(_DWORD);
// 475F8: using guessed type int __fastcall sub_475F8(_DWORD);
// 477FC: using guessed type int __fastcall sub_477FC(_DWORD);
// 47A48: using guessed type int __fastcall sub_47A48(_DWORD, _DWORD);
// 4808C: using guessed type int __fastcall sub_4808C(_DWORD, _DWORD, _DWORD);
// 4854C: using guessed type int __fastcall sub_4854C(_DWORD, _DWORD);
// 657B8: using guessed type int dword_657B8;
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);
// 66640: using guessed type char byte_66640;
// 70CE8: using guessed type char byte_70CE8;
// 74258: using guessed type pthread_mutex_t stru_74258;
// 74274: using guessed type int dword_74274;
// 74534: using guessed type int dword_74534;
// 75C74: using guessed type int dword_75C74;

//----- (00019C88) --------------------------------------------------------
int __fastcall get_summary_info(int api_info, int validate_param)
{
  int lock_res; // r0
  int root_node; // r10
  int summary_node; // r6
  __int64 elapsed_time; // r0
  int elapsed_val; // r0
  int rate_5s_res; // r0
  double rate_5s_double; // r0
  int rate_5s_val; // r0
  int rate_30m_res; // r0
  double rate_30m_double; // r0
  int rate_30m_val; // r0
  int rate_avg_res; // r0
  double rate_avg_double; // r0
  int rate_avg_val; // r0
  int rate_ideal_res; // r0
  double rate_ideal_double; // r0
  int rate_ideal_val; // r0
  int rate_unit_val; // r0
  int hw_all_val; // r0
  int bestshare_res; // r0
  int bestshare_val; // r0
  int next_node; // r0
  int status_node; // r8
  char **plugin_ptr; // r4
  int plugin_node; // r5
  int type_val; // r0
  char *next_plugin; // t1
  int *lock_errno; // r0
  int *unlock_errno; // r0
  __int16 lock_status; // [sp+14h] [bp-854h] BYREF
  double rate_5s; // [sp+18h] [bp-850h] BYREF
  double rate_30m; // [sp+20h] [bp-848h] BYREF
  double rate_avg; // [sp+28h] [bp-840h] BYREF
  double rate_ideal; // [sp+30h] [bp-838h] BYREF
  char rate_unit_buffer[4]; // [sp+38h] [bp-830h] BYREF
  int buffer_size; // [sp+3Ch] [bp-82Ch]
  char error_buffer[2088]; // [sp+40h] [bp-828h] BYREF

  rate_5s = 0.0;
  buffer_size = 0;
  *(_DWORD *)rate_unit_buffer = 0;
  lock_status = 0;
  rate_30m = 0.0;
  rate_avg = 0.0;
  rate_ideal = 0.0;
  if ( validate_param )
  {
    flush_api_semaphore(&lock_status, 1);
    send_status_json(api_info, validate_param);
    if ( pthread_mutex_lock(&stru_74258) )
    {
      lock_errno = _errno_location();
      snprintf(
        error_buffer,
        2048u,
        "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
        *lock_errno,
        "api_new.c",
        "get_summary",
        337);
      log_event(3, error_buffer, 1);
      shutdown_miner_safely(1);
    }
    lock_res = get_miner_info_json(api_info);
    root_node = initialize_error_description(lock_res);
    summary_node = initialize_miner_error_state(root_node);
    if ( dword_74278 <= 1 )
    {
      if ( dword_74278 == 1 )
        update_system_uptime();
      elapsed_time = 0LL;
    }
    else
    {
      elapsed_time = calculate_hash_rate(dword_66120, unk_66124);
    }
    elapsed_val = set_error_context(elapsed_time, HIDWORD(elapsed_time));
    configure_miner_connection(summary_node, "elapsed", elapsed_val);
    sscanf(byte_7437C, "%lf", &rate_5s);
    rate_5s_res = calculate_hash_rate(
                    COERCE_UNSIGNED_INT64(rate_5s * 100.0),
                    HIDWORD(COERCE_UNSIGNED_INT64(rate_5s * 100.0)));
    rate_5s_double = convert_float_to_int(rate_5s_res);
    rate_5s_val = check_and_set_error_description(LODWORD(rate_5s_double));
    configure_miner_connection(summary_node, "rate_5s", rate_5s_val);
    sscanf(byte_7438C, "%lf", &rate_30m);
    rate_30m_res = calculate_hash_rate(
                     COERCE_UNSIGNED_INT64(rate_30m * 100.0),
                     HIDWORD(COERCE_UNSIGNED_INT64(rate_30m * 100.0)));
    rate_30m_double = convert_float_to_int(rate_30m_res);
    rate_30m_val = check_and_set_error_description(LODWORD(rate_30m_double));
    configure_miner_connection(summary_node, "rate_30m", rate_30m_val);
    sscanf(src, "%lf", &rate_avg);
    rate_avg_res = calculate_hash_rate(
                     COERCE_UNSIGNED_INT64(rate_avg * 100.0),
                     HIDWORD(COERCE_UNSIGNED_INT64(rate_avg * 100.0)));
    rate_avg_double = convert_float_to_int(rate_avg_res);
    rate_avg_val = check_and_set_error_description(LODWORD(rate_avg_double));
    configure_miner_connection(summary_node, "rate_avg", rate_avg_val);
    sscanf(byte_743AC, "%lf", &rate_ideal);
    rate_ideal_res = calculate_hash_rate(
                       COERCE_UNSIGNED_INT64(rate_ideal * 100.0),
                       HIDWORD(COERCE_UNSIGNED_INT64(rate_ideal * 100.0)));
    rate_ideal_double = convert_float_to_int(rate_ideal_res);
    rate_ideal_val = check_and_set_error_description(LODWORD(rate_ideal_double));
    configure_miner_connection(summary_node, "rate_ideal", rate_ideal_val);
    snprintf(rate_unit_buffer, 8u, "%s/s", &byte_743AC[16]);
    rate_unit_val = validate_utf8_or_return_input(rate_unit_buffer);
    configure_miner_connection(summary_node, "rate_unit", rate_unit_val);
    hw_all_val = set_error_context(dword_73FB8, dword_73FB8 >> 31);
    configure_miner_connection(summary_node, "hw_all", hw_all_val);
    bestshare_res = set_error_context(qword_66A60, MEMORY[0x66A64]);
    bestshare_val = configure_miner_connection(summary_node, "bestshare", bestshare_res);
    next_node = initialize_error_description(bestshare_val);
    status_node = next_node;
    if ( next_node && off_65340 )
    {
      plugin_ptr = &off_65340;
      do
      {
        plugin_node = initialize_miner_error_state(next_node);
        type_val = validate_utf8_or_return_input(*plugin_ptr);
        configure_miner_connection(plugin_node, "type", type_val);
        ((void (__fastcall *)(int, char **))plugin_ptr[1])(plugin_node, plugin_ptr);
        next_node = add_buffer_to_queue(status_node, plugin_node);
        next_plugin = plugin_ptr[6];
        plugin_ptr += 6;
      }
      while ( next_plugin );
    }
    configure_miner_connection(summary_node, "status", status_node);
    add_buffer_to_queue(root_node, summary_node);
    configure_miner_connection(api_info, "SUMMARY", root_node);
    if ( pthread_mutex_unlock(&stru_74258) )
    {
      unlock_errno = _errno_location();
      snprintf(
        error_buffer,
        2048u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *unlock_errno,
        "api_new.c",
        "get_summary",
        390);
      log_event(3, error_buffer, 1);
      shutdown_miner_safely(1);
    }
    off_658DC(0);
    return 0;
  }
  else if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
  {
    snprintf(error_buffer, 2048u, "%s: input bad api param\n", "get_summary");
    log_event(3, error_buffer, 0);
    return -2147483646;
  }
  else
  {
    return -2147483646;
  }
}
// 15EC0: using guessed type int __fastcall sub_15EC0(_DWORD);
// 16384: using guessed type int __fastcall sub_16384(_DWORD, _DWORD);
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 1DA28: using guessed type int sub_1DA28(void);
// 3AADC: using guessed type void __fastcall __noreturn sub_3AADC(_DWORD);
// 3B980: using guessed type int sub_3B980(void);
// 40E70: using guessed type int __fastcall sub_40E70(_DWORD, _DWORD);
// 47268: using guessed type int __fastcall sub_47268(_DWORD);
// 475F8: using guessed type int __fastcall sub_475F8(_DWORD);
// 477FC: using guessed type int __fastcall sub_477FC(_DWORD);
// 47A48: using guessed type int __fastcall sub_47A48(_DWORD, _DWORD);
// 47ACC: using guessed type int __fastcall sub_47ACC(_DWORD);
// 4808C: using guessed type int __fastcall sub_4808C(_DWORD, _DWORD, _DWORD);
// 4854C: using guessed type int __fastcall sub_4854C(_DWORD, _DWORD);
// 4930C: using guessed type double __fastcall sub_4930C(_DWORD);
// 493A4: using guessed type __int64 __fastcall sub_493A4(_DWORD, _DWORD);
// 65340: using guessed type char *off_65340;
// 657B8: using guessed type int dword_657B8;
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);
// 66120: using guessed type int dword_66120;
// 66640: using guessed type char byte_66640;
// 66A60: using guessed type int dword_66A60;
// 66A64: using guessed type int dword_66A64;
// 70CE8: using guessed type char byte_70CE8;
// 73FB8: using guessed type int dword_73FB8;
// 74258: using guessed type pthread_mutex_t stru_74258;
// 74278: using guessed type int dword_74278;

//----- (0001A128) --------------------------------------------------------
int __fastcall sub_1A128(int a1, int a2)
{
  bool v2; // zf
  int v6; // r0
  int v7; // r4
  __int64 v8; // r0
  int v9; // r0
  int v10; // r0
  double v11; // r0
  int v12; // r0
  int v13; // r0
  double v14; // r0
  int v15; // r0
  int v16; // r0
  double v17; // r0
  int v18; // r0
  int v19; // r0
  int v20; // r0
  int v21; // r0
  int v22; // r0
  int v23; // r0
  double v24; // r0
  double v25; // d7
  int v26; // r0
  double v27; // r0
  int v28; // r0
  double v29; // r0
  int v30; // r0
  int v31; // r0
  int v32; // r0
  int v33; // r0
  int v34; // r0
  int v35; // r0
  int v36; // r0
  int v37; // r0
  double v38; // r0
  int v39; // r0
  double v40; // r0
  double v41; // d7
  int v42; // r0
  double v43; // r0
  int v44; // r0
  int v45; // r0
  double v46; // r0
  int v47; // r0
  int v48; // r0
  double v49; // r0
  int v50; // r0
  int v51; // r0
  double v52; // r0
  int v53; // r0
  int v54; // r0
  double v55; // r0
  __int64 v56; // r10
  int v57; // r0
  double v58; // r0
  double v59; // r0
  int v60; // r0
  int v61; // r0
  double v62; // r0
  double v63; // d7
  int v64; // r0
  int v65; // r0
  double v66; // r0
  double v67; // d7
  int v68; // r0
  int v69; // r0
  int v70; // r0
  int v71; // r0
  double v72; // d9
  double v73; // r0
  int v74; // r0
  int *v75; // r0
  int *v76; // r0
  int v77; // [sp+14h] [bp-85Ch]
  __int16 v78; // [sp+1Ch] [bp-854h] BYREF
  double v79; // [sp+20h] [bp-850h] BYREF
  double v80; // [sp+28h] [bp-848h] BYREF
  double v81; // [sp+30h] [bp-840h] BYREF
  char s[2104]; // [sp+38h] [bp-838h] BYREF

  v2 = a1 == 0;
  if ( a1 )
    v2 = a2 == 0;
  v79 = 0.0;
  v80 = 0.0;
  v81 = 0.0;
  v78 = 0;
  if ( v2 )
  {
    if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
    {
      snprintf(s, 2048u, "%s: input bad api param\n", "get_summary_old");
      log_event(3, s, 0);
      return -2147483646;
    }
    else
    {
      return -2147483646;
    }
  }
  else
  {
    flush_api_semaphore(&v78, 1);
    if ( pthread_mutex_lock(&stru_74258) )
    {
      v76 = _errno_location();
      snprintf(s, 2048u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v76, "api_new.c", "get_summary_old", 666);
      log_event(3, s, 1);
      shutdown_miner_safely(1);
    }
    v6 = log_error(a1, 1, 11, *(_DWORD *)(a2 + 8));
    v77 = initialize_error_description(v6);
    v7 = initialize_miner_error_state();
    v8 = calculate_hash_rate(dword_66120, unk_66124);
    v9 = set_error_context(v8, HIDWORD(v8));
    configure_miner_connection(v7, "Elapsed", v9);
    sscanf(byte_7437C, "%lf", &v79);
    v10 = calculate_hash_rate(COERCE_UNSIGNED_INT64(v79 * 100.0), HIDWORD(COERCE_UNSIGNED_INT64(v79 * 100.0)));
    v11 = convert_float_to_int(v10);
    v12 = check_and_set_error_description(LODWORD(v11));
    configure_miner_connection(v7, "GHS 5s", v12);
    sscanf(src, "%lf", &v81);
    v13 = calculate_hash_rate(COERCE_UNSIGNED_INT64(v81 * 100.0), HIDWORD(COERCE_UNSIGNED_INT64(v81 * 100.0)));
    v14 = convert_float_to_int(v13);
    v15 = check_and_set_error_description(LODWORD(v14));
    configure_miner_connection(v7, "GHS av", v15);
    sscanf(byte_7438C, "%lf", &v80);
    v16 = calculate_hash_rate(COERCE_UNSIGNED_INT64(v80 * 100.0), HIDWORD(COERCE_UNSIGNED_INT64(v80 * 100.0)));
    v17 = convert_float_to_int(v16);
    v18 = check_and_set_error_description(LODWORD(v17));
    configure_miner_connection(v7, "GHS 30m", v18);
    v19 = set_error_context(dword_73FCC, 0);
    configure_miner_connection(v7, "Found Blocks", v19);
    v20 = set_error_context(dword_72EE0, dword_72EE4);
    configure_miner_connection(v7, "Getwork", v20);
    v21 = set_error_context(qword_70E48, HIDWORD(qword_70E48));
    configure_miner_connection(v7, "Accepted", v21);
    v22 = set_error_context(qword_72F10, HIDWORD(qword_72F10));
    configure_miner_connection(v7, "Rejected", v22);
    v23 = set_error_context(dword_73FB8, dword_73FB8 >> 31);
    configure_miner_connection(v7, "Hardware Errors", v23);
    *(_QWORD *)&qword_70D20 = calculate_hash_rate(
                                COERCE_UNSIGNED_INT64(dbl_72E80 + dbl_72F08 + dbl_70E50),
                                HIDWORD(COERCE_UNSIGNED_INT64(dbl_72E80 + dbl_72F08 + dbl_70E50)));
    v24 = convert_float_to_int(qword_70E48);
    v25 = v24;
    if ( *(double *)&dword_66120 != 0.0 )
      v25 = v24 / *(double *)&dword_66120;
    v26 = calculate_hash_rate(
            COERCE_UNSIGNED_INT64(v25 * 60.0 * 100.0),
            HIDWORD(COERCE_UNSIGNED_INT64(v25 * 60.0 * 100.0)));
    v27 = convert_float_to_int(v26);
    v28 = calculate_hash_rate(
            COERCE_UNSIGNED_INT64(v27 / 100.0 * 100.0),
            HIDWORD(COERCE_UNSIGNED_INT64(v27 / 100.0 * 100.0)));
    v29 = convert_float_to_int(v28);
    v30 = check_and_set_error_description(LODWORD(v29));
    configure_miner_connection(v7, "Utility", v30);
    v31 = set_error_context(qword_72F60, MEMORY[0x72F64]);
    configure_miner_connection(v7, "Discarded", v31);
    v32 = set_error_context(qword_74220, MEMORY[0x74224]);
    configure_miner_connection(v7, "Stale", v32);
    v33 = set_error_context(dword_70E60, 0);
    configure_miner_connection(v7, "Get Failures", v33);
    v34 = set_error_context(dword_70E6C, 0);
    configure_miner_connection(v7, "Local Work", v34);
    v35 = set_error_context(dword_70D04, 0);
    configure_miner_connection(v7, "Remote Failures", v35);
    v36 = set_error_context(dword_74130, 0);
    configure_miner_connection(v7, "Network Blocks", v36);
    v37 = calculate_hash_rate(
            COERCE_UNSIGNED_INT64(unk_70CE0 * 100.0),
            HIDWORD(COERCE_UNSIGNED_INT64(unk_70CE0 * 100.0)));
    v38 = convert_float_to_int(v37);
    v39 = check_and_set_error_description(LODWORD(v38));
    configure_miner_connection(v7, "Total MH", v39);
    v40 = convert_float_to_int(qword_70D20);
    v41 = v40;
    if ( *(double *)&dword_66120 != 0.0 )
      v41 = v40 / *(double *)&dword_66120;
    v42 = calculate_hash_rate(
            COERCE_UNSIGNED_INT64(v41 * 60.0 * 100.0),
            HIDWORD(COERCE_UNSIGNED_INT64(v41 * 60.0 * 100.0)));
    v43 = convert_float_to_int(v42);
    v44 = check_and_set_error_description(LODWORD(v43));
    configure_miner_connection(v7, "Work Utility", v44);
    v45 = calculate_hash_rate(
            COERCE_UNSIGNED_INT64(dbl_72E80 * 100.0),
            HIDWORD(COERCE_UNSIGNED_INT64(dbl_72E80 * 100.0)));
    v46 = convert_float_to_int(v45);
    v47 = check_and_set_error_description(LODWORD(v46));
    configure_miner_connection(v7, "Difficulty Accepted", v47);
    v48 = calculate_hash_rate(
            COERCE_UNSIGNED_INT64(dbl_72F08 * 100.0),
            HIDWORD(COERCE_UNSIGNED_INT64(dbl_72F08 * 100.0)));
    v49 = convert_float_to_int(v48);
    v50 = check_and_set_error_description(LODWORD(v49));
    configure_miner_connection(v7, "Difficulty Rejected", v50);
    v51 = calculate_hash_rate(
            COERCE_UNSIGNED_INT64(dbl_70E50 * 100.0),
            HIDWORD(COERCE_UNSIGNED_INT64(dbl_70E50 * 100.0)));
    v52 = convert_float_to_int(v51);
    v53 = check_and_set_error_description(LODWORD(v52));
    configure_miner_connection(v7, "Difficulty Stale", v53);
    v54 = set_error_context(qword_66A60, MEMORY[0x66A64]);
    configure_miner_connection(v7, "Best Share", v54);
    LODWORD(v55) = qword_70D20;
    v56 = *(_QWORD *)&qword_70D20 + dword_73FB8;
    if ( v56 )
    {
      v72 = (double)dword_73FB8;
      v73 = convert_float_to_int(v56);
      v74 = calculate_hash_rate(
              COERCE_UNSIGNED_INT64(v72 / v73 * 100.0),
              HIDWORD(COERCE_UNSIGNED_INT64(v72 / v73 * 100.0)));
      v55 = convert_float_to_int(v74);
    }
    v57 = check_and_set_error_description(LODWORD(v55));
    configure_miner_connection(v7, "Device Hardware%", v57);
    LODWORD(v58) = qword_70D20;
    if ( *(_QWORD *)&qword_70D20 )
    {
      v59 = convert_float_to_int(qword_70D20);
      v60 = calculate_hash_rate(
              COERCE_UNSIGNED_INT64(dbl_72F08 / v59 * 100.0),
              HIDWORD(COERCE_UNSIGNED_INT64(dbl_72F08 / v59 * 100.0)));
      v58 = convert_float_to_int(v60);
    }
    v61 = check_and_set_error_description(LODWORD(v58));
    LODWORD(v62) = configure_miner_connection(v7, "Device Rejected%", v61);
    v63 = dbl_72F08 + dbl_72E80 + dbl_70E50;
    if ( v63 != 0.0 )
    {
      v64 = calculate_hash_rate(
              COERCE_UNSIGNED_INT64(dbl_72F08 / v63 * 100.0),
              HIDWORD(COERCE_UNSIGNED_INT64(dbl_72F08 / v63 * 100.0)));
      v62 = convert_float_to_int(v64);
    }
    v65 = check_and_set_error_description(LODWORD(v62));
    LODWORD(v66) = configure_miner_connection(v7, "Pool Rejected%", v65);
    v67 = dbl_72E80 + dbl_72F08 + dbl_70E50;
    if ( v67 != 0.0 )
    {
      v68 = calculate_hash_rate(
              COERCE_UNSIGNED_INT64(dbl_70E50 / v67 * 100.0),
              HIDWORD(COERCE_UNSIGNED_INT64(dbl_70E50 / v67 * 100.0)));
      v66 = convert_float_to_int(v68);
    }
    v69 = check_and_set_error_description(LODWORD(v66));
    configure_miner_connection(v7, "Pool Stale%", v69);
    v70 = set_error_context(dword_73FD8, dword_73FD8 >> 31);
    configure_miner_connection(v7, "Last getwork", v70);
    add_buffer_to_queue(v77, v7);
    configure_miner_connection(a1, "SUMMARY", v77);
    v71 = set_error_context(1, 0);
    configure_miner_connection(a1, "id", v71);
    if ( pthread_mutex_unlock(&stru_74258) )
    {
      v75 = _errno_location();
      snprintf(s, 2048u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v75, "api_new.c", "get_summary_old", 738);
      log_event(3, s, 1);
      shutdown_miner_safely(1);
    }
    off_658DC(0);
    return 0;
  }
}
// 16000: using guessed type int __fastcall sub_16000(_DWORD, _DWORD, _DWORD, _DWORD);
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 1DA28: using guessed type int sub_1DA28(void);
// 3AADC: using guessed type void __fastcall __noreturn sub_3AADC(_DWORD);
// 40E70: using guessed type int __fastcall sub_40E70(_DWORD, _DWORD);
// 47268: using guessed type int sub_47268(void);
// 475F8: using guessed type int __fastcall sub_475F8(_DWORD);
// 47A48: using guessed type int __fastcall sub_47A48(_DWORD, _DWORD);
// 47ACC: using guessed type int __fastcall sub_47ACC(_DWORD);
// 4808C: using guessed type int __fastcall sub_4808C(_DWORD, _DWORD, _DWORD);
// 4854C: using guessed type int __fastcall sub_4854C(_DWORD, _DWORD);
// 4930C: using guessed type double __fastcall sub_4930C(_DWORD);
// 493A4: using guessed type __int64 __fastcall sub_493A4(_DWORD, _DWORD);
// 657B8: using guessed type int dword_657B8;
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);
// 66120: using guessed type int dword_66120;
// 66640: using guessed type char byte_66640;
// 66A60: using guessed type int dword_66A60;
// 66A64: using guessed type int dword_66A64;
// 70CE8: using guessed type char byte_70CE8;
// 70D04: using guessed type int dword_70D04;
// 70D20: using guessed type int dword_70D20;
// 70E48: using guessed type __int64 qword_70E48;
// 70E60: using guessed type int dword_70E60;
// 70E6C: using guessed type int dword_70E6C;
// 72E80: using guessed type double dbl_72E80;
// 72EE0: using guessed type int dword_72EE0;
// 72EE4: using guessed type int dword_72EE4;
// 72F08: using guessed type double dbl_72F08;
// 72F10: using guessed type __int64 qword_72F10;
// 72F60: using guessed type int dword_72F60;
// 72F64: using guessed type int dword_72F64;
// 73FB8: using guessed type int dword_73FB8;
// 73FCC: using guessed type int dword_73FCC;
// 73FD8: using guessed type int dword_73FD8;
// 74130: using guessed type int dword_74130;
// 74220: using guessed type int dword_74220;
// 74224: using guessed type int dword_74224;
// 74258: using guessed type pthread_mutex_t stru_74258;

//----- (0001A9F4) --------------------------------------------------------
void initialize_api_socket()
{
  _DWORD *address_info; // r5
  char *addr_str; // r10
  int *flags_ptr; // r11
  _DWORD *result; // r4
  struct addrinfo *addrinfo_ptr; // r4
  struct addrinfo *addrinfo_iter; // r3
  int socket_fd; // r0
  int socket_descriptor; // r5
  time_t bind_start_time; // r7
  int *errno_location; // r0
  char *error_str; // r9
  int flags_value; // r4
  int accepted_fd; // r0
  ssize_t received_bytes; // r0
  _DWORD *json_obj; // r0
  _DWORD *top_level_json; // r5
  unsigned int *data; // r0
  unsigned int *command_json; // r6
  unsigned int new_api_flag; // r7
  unsigned int *ref_count_ptr; // r3
  unsigned int current_ref; // r2
  unsigned int updated_ref; // r2
  _DWORD *json_object; // r0
  char *response_str; // r0
  char *free_ptr; // r5
  unsigned int *api_ref_count_ptr; // r3
  unsigned int api_current_ref; // r2
  unsigned int api_updated_ref; // r2
  _DWORD *status_json; // r0
  _DWORD *status_array_obj; // r0
  _DWORD *status_entry; // r8
  int array_size; // r0
  int status_key; // r6
  size_t str_len; // r0
  int temp_result; // r0
  int next_status_key; // r0
  int next_result; // r0
  int *status_value; // r4
  char **commands_array; // r6
  int command_index; // r5
  const char *command_str; // r7
  char *current_command; // t1
  _DWORD *command_json_array; // r0
  unsigned int *cmd_api_ref_count_ptr; // r3
  unsigned int cmd_api_current_ref; // r2
  unsigned int cmd_api_updated_ref; // r2
  _DWORD *command_entry; // r0
  unsigned int *parse_ref_count_ptr; // r3
  unsigned int parse_current_ref; // r2
  unsigned int parse_updated_ref; // r2
  _DWORD *is_new_api_json; // r0
  unsigned int loop_counter; // r4
  _DWORD *api_id; // r8
  _DWORD *command_arg; // r0
  bool is_reload; // zf
  int int_val; // r2
  const char *command_string; // r0
  char *to_free; // r0
  char *v58; // r4
  unsigned int *v59; // r3
  unsigned int v60; // r2
  unsigned int top_api_ref_count_ptr; // r2
  unsigned int *top_api_current_ref; // r3
  unsigned int top_api_updated_ref; // r2
  unsigned int temp_errno_location; // r2
  int *temp_error_str; // r0
  char *json_array; // r0
  _DWORD *items_count; // r8
  _DWORD *item_index; // r9
  unsigned int item_json; // r6
  _DWORD *json_object_item; // r0
  _DWORD *temp_size; // r7
  int item_key; // r0
  int item_str_len; // r5
  size_t next_item_key; // r0
  int next_temp_result; // r0
  int next_result_item; // r0
  int next_operation; // r0
  int *command_val; // r8
  const char *new_api_json; // r0
  _DWORD *temp_fd; // r0
  int temp_protocol; // r3
  unsigned int json_ref_count_ptr; // r2
  unsigned int *json_current_ref; // r3
  unsigned int json_updated_ref; // r1
  unsigned int temp_errno_ptr; // r1
  int *temp_strerror; // r0
  char *response_flag; // r0
  unsigned int addr_valid; // [sp+14h] [bp-9564h]
  char *v89; // [sp+18h] [bp-9560h]
  int protocol; // [sp+1Ch] [bp-955Ch]
  int v91; // [sp+20h] [bp-9558h]
  const char *v92; // [sp+24h] [bp-9554h]
  _DWORD *v93; // [sp+2Ch] [bp-954Ch]
  _DWORD *v94; // [sp+30h] [bp-9548h]
  _DWORD *v95; // [sp+40h] [bp-9538h]
  int v96; // [sp+4Ch] [bp-952Ch] BYREF
  int fd; // [sp+50h] [bp-9528h] BYREF
  socklen_t addr_len; // [sp+54h] [bp-9524h] BYREF
  struct addrinfo *ai; // [sp+58h] [bp-9520h] BYREF
  int optval; // [sp+5Ch] [bp-951Ch] BYREF
  char service[12]; // [sp+60h] [bp-9518h] BYREF
  char v102[4]; // [sp+6Ch] [bp-950Ch] BYREF
  int v103; // [sp+70h] [bp-9508h]
  int v104; // [sp+74h] [bp-9504h]
  int v105; // [sp+78h] [bp-9500h]
  char s1[4]; // [sp+7Ch] [bp-94FCh] BYREF
  int v107; // [sp+80h] [bp-94F8h]
  int v108; // [sp+84h] [bp-94F4h]
  int v109; // [sp+88h] [bp-94F0h]
  _DWORD v110[5]; // [sp+8Ch] [bp-94ECh] BYREF
  struct addrinfo req; // [sp+A0h] [bp-94D8h] BYREF
  struct sockaddr addr; // [sp+C0h] [bp-94B8h] BYREF
  char v113[16]; // [sp+140h] [bp-9438h] BYREF
  char v114[252]; // [sp+23Ch] [bp-933Ch] BYREF
  char src[256]; // [sp+338h] [bp-9240h] BYREF
  struct __jmp_buf_tag v116; // [sp+438h] [bp-9140h] BYREF
  char s[2048]; // [sp+550h] [bp-9028h] BYREF
  char v118[2032]; // [sp+D50h] [bp-8828h] BYREF
  char v119[2032]; // [sp+1550h] [bp-8028h] BYREF
  char v120[2032]; // [sp+1D50h] [bp-7828h] BYREF
  char v121[2032]; // [sp+2550h] [bp-7028h] BYREF
  char v122[2032]; // [sp+2D50h] [bp-6828h] BYREF
  char v123[2032]; // [sp+3550h] [bp-6028h] BYREF
  char v124[1968]; // [sp+3D50h] [bp-5828h] BYREF
  char v125[1968]; // [sp+4550h] [bp-5028h] BYREF
  char v126[1968]; // [sp+4D50h] [bp-4828h] BYREF
  char v127[1968]; // [sp+5550h] [bp-4028h] BYREF
  char v128[2048]; // [sp+5D50h] [bp-3828h] BYREF
  char v129[4096]; // [sp+6550h] [bp-3028h] BYREF
  char v130[8232]; // [sp+7550h] [bp-2028h] BYREF

  v96 = -1;
  fd = -1;
  addr_valid = 2;
  memset(v130, 0, 8192u);
  memset(v129, 0, sizeof(v129));
  v103 = 0;
  *(_DWORD *)v102 = 0;
  v104 = 0;
  v105 = 0;
  if ( byte_70CE8 || byte_66640 || dword_657B8 > 4 )
  {
    snprintf(s, 2048u, "Start %s function\n", "api");
    log_event(5, s, 0);
  }
  result = (_DWORD *)_sigsetjmp(&v116, 0);
  if ( result )
  {
    close_socket(&v96);
    _pthread_unwind_next((__pthread_unwind_buf_t *)&v116);
    goto LABEL_179;
  }
  _pthread_register_cancel((__pthread_unwind_buf_t *)&v116);
  sprintf(service, "%d", 4028);
  memset(&req.ai_family, 0, 28);
  req.ai_flags = 1;
  protocol = getaddrinfo("0.0.0.0", service, &req, &ai);
  if ( protocol )
  {
    if ( !byte_70CE8 && !byte_66640 && dword_657B8 <= 2 )
      goto LABEL_58;
    snprintf(v123, 2048u, "%s: exec getaddrinfo() failed\n", "api_init_socket");
    log_event(3, v123, 0);
    goto LABEL_64;
  }
  addrinfo_ptr = ai;
  if ( ai )
  {
    for ( addrinfo_iter = ai; ; addrinfo_iter = ai )
    {
      socket_fd = socket(addrinfo_iter->ai_family, 1, protocol);
      if ( socket_fd > 0 )
      {
        socket_descriptor = socket_fd;
        goto LABEL_12;
      }
      addrinfo_ptr = addrinfo_ptr->ai_next;
      if ( !addrinfo_ptr )
        break;
    }
    socket_descriptor = socket_fd;
    if ( socket_fd == -1 )
    {
      if ( !byte_70CE8 && !byte_66640 && dword_657B8 <= 2 )
        goto LABEL_58;
      snprintf(v124, 2048u, "%s: exec socket() failed\n", "api_init_socket");
      log_event(3, v124, 0);
LABEL_64:
      if ( !byte_70CE8 && !byte_66640 )
        goto LABEL_58;
      goto LABEL_59;
    }
  }
  else
  {
    socket_descriptor = 0;
  }
LABEL_12:
  optval = 1;
  setsockopt(socket_descriptor, 1, 2, &optval, 4u);
  bind_start_time = time(0);
  while ( bind(socket_descriptor, addrinfo_ptr->ai_addr, addrinfo_ptr->ai_addrlen) < 0 )
  {
    errno_location = _errno_location();
    error_str = strerror(*errno_location);
    if ( time(0) - bind_start_time > 61 )
    {
      freeaddrinfo(ai);
      if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
      {
        snprintf(v126, 2048u, "api bind to port %d, failed (%s)", 4028, error_str);
        log_event(3, v126, 0);
        goto LABEL_64;
      }
LABEL_58:
      if ( dword_657B8 <= 2 )
        return;
LABEL_59:
      snprintf(v118, 2048u, "%s: init socket failed", "api");
      log_event(3, v118, 0);
      return;
    }
    if ( byte_70CE8 || byte_66640 || dword_657B8 > 3 )
    {
      snprintf(v125, 2048u, "%s: api bind to port %d failed, trying again in 30sec", "api_init_socket", 4028);
      log_event(4, v125, 0);
    }
    sleep(30u);
  }
  freeaddrinfo(ai);
  if ( listen(socket_descriptor, 100) < 0 )
  {
    if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
    {
      temp_strerror = _errno_location();
      response_flag = strerror(*temp_strerror);
      snprintf(v127, 2048u, "%s: exec listen() failed (%s)", "api_init_socket", response_flag);
      log_event(3, v127, 0);
    }
    close(socket_descriptor);
    goto LABEL_64;
  }
  if ( socket_descriptor < 0 )
    goto LABEL_64;
  flags_ptr = &dword_66500;
  v96 = socket_descriptor;
  addr_str = ::s1;
  v89 = &byte_66641;
  v92 = "=";
  while ( 1 )
  {
    flags_value = *((unsigned __int8 *)flags_ptr + 4);
    if ( *((_BYTE *)flags_ptr + 4) )
      break;
    addr_len = 128;
    accepted_fd = accept(v96, &addr, &addr_len);
    fd = accepted_fd;
    if ( accepted_fd < 0 )
    {
      if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
      {
        temp_error_str = _errno_location();
        json_array = strerror(*temp_error_str);
        snprintf(v119, 2048u, "%s: exec accept failed (%s)", "api", json_array);
        log_event(3, v119, 0);
      }
      break;
    }
    received_bytes = recv(accepted_fd, v130, 4095u, flags_value);
    if ( received_bytes < 0 )
    {
      v130[0] = flags_value;
      goto LABEL_23;
    }
    v130[received_bytes] = flags_value;
    *(_DWORD *)addr_str = flags_value;
    *((_DWORD *)addr_str + 1) = flags_value;
    *((_DWORD *)addr_str + 2) = flags_value;
    *((_DWORD *)addr_str + 3) = flags_value;
    *(_DWORD *)v102 = flags_value;
    v103 = flags_value;
    v104 = flags_value;
    v105 = flags_value;
    *flags_ptr = time((time_t *)flags_value);
    getnameinfo(&addr, 128u, addr_str, 16u, (char *)flags_value, flags_value, 1u);
    if ( *v89 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
    {
      snprintf(v120, 2048u, "connect_addr: %s", addr_str);
      log_event(7, v120, 0);
    }
    v107 = 0;
    *(_DWORD *)s1 = 0;
    v108 = 0;
    v109 = 0;
    json_obj = (_DWORD *)process_command((int)v130, 0, (int)v113);
    top_level_json = json_obj;
    if ( json_obj && !*json_obj )
    {
      data = (unsigned int *)validate_and_fetch_data(json_obj, "command");
      command_json = data;
      if ( data )
      {
        new_api_flag = *data;
        if ( *data == 1 )
        {
          is_new_api_json = (_DWORD *)validate_and_fetch_data(top_level_json, "new_api");
          if ( is_new_api_json )
            new_api_flag = *is_new_api_json != 5;
          loop_counter = protocol;
          v91 = protocol;
          api_id = initialize_miner_error_state();
          while ( (unsigned int)get_next_structure_pointer(command_json) > loop_counter )
          {
            command_arg = get_task_by_index(command_json, loop_counter);
            is_reload = command_arg == 0;
            if ( command_arg )
              is_reload = loop_counter == 11;
            int_val = is_reload;
            if ( is_reload )
              break;
            if ( *command_arg == 2 )
            {
              *(_DWORD *)s1 = int_val;
              v107 = int_val;
              v108 = int_val;
              v109 = int_val;
              command_string = (const char *)get_linked_item_or_null(command_arg);
              snprintf(s1, 16u, "%s", command_string);
              if ( strcmp(s1, "reload") | new_api_flag )
              {
                v94 = initialize_miner_error_state();
                process_miner_command((int)v94, s1, new_api_flag);
                configure_miner_connection(api_id, s1, v94);
              }
              else
              {
                v91 = 1;
              }
            }
            ++loop_counter;
          }
          to_free = (char *)generate_config_json(api_id, 24576);
          v58 = to_free;
          if ( to_free )
            send_data_with_retry(&fd, to_free);
          free(v58);
          if ( v91 == 1 )
            process_miner_command((int)api_id, "reload", 0);
          if ( api_id )
          {
            if ( api_id[1] != -1 )
            {
              v59 = api_id + 1;
              __dmb(11u);
              do
              {
                v60 = __ldrex(v59);
                top_api_ref_count_ptr = v60 - 1;
              }
              while ( __strex(top_api_ref_count_ptr, v59) );
              if ( !top_api_ref_count_ptr )
                process_bitmain_miner(api_id);
            }
          }
          if ( top_level_json[1] != -1 )
          {
            top_api_current_ref = top_level_json + 1;
            __dmb(11u);
            do
            {
              top_api_updated_ref = __ldrex(top_api_current_ref);
              temp_errno_location = top_api_updated_ref - 1;
            }
            while ( __strex(temp_errno_location, top_api_current_ref) );
            if ( !temp_errno_location )
              process_bitmain_miner(top_level_json);
          }
          goto LABEL_23;
        }
      }
      if ( top_level_json[1] != -1 )
      {
        ref_count_ptr = top_level_json + 1;
        __dmb(11u);
        do
        {
          current_ref = __ldrex(ref_count_ptr);
          updated_ref = current_ref - 1;
        }
        while ( __strex(updated_ref, ref_count_ptr) );
        if ( !updated_ref )
          process_bitmain_miner(top_level_json);
      }
    }
    result = initialize_miner_error_state();
    json_object = (_DWORD *)process_command((int)v130, 0, (int)v114);
    address_info = json_object;
    if ( !json_object || *json_object )
    {
      addr_valid = 2;
      snprintf(v102, 16u, "%s", v130);
      process_miner_command((int)result, v102, 2u);
      goto LABEL_45;
    }
    command_entry = (_DWORD *)validate_and_fetch_data(json_object, "command");
    if ( !command_entry || *command_entry != 2 )
    {
      if ( !byte_70CE8 && !byte_66640 && dword_657B8 <= 2 )
      {
        if ( address_info[1] != -1 )
          goto LABEL_98;
        goto LABEL_137;
      }
      snprintf(v128, 2048u, "%s error: format error about command\n", "parse_recv_buf");
      log_event(3, v128, 0);
      if ( address_info[1] != -1 )
      {
LABEL_98:
        parse_ref_count_ptr = address_info + 1;
        __dmb(11u);
        do
        {
          parse_current_ref = __ldrex(parse_ref_count_ptr);
          parse_updated_ref = parse_current_ref - 1;
        }
        while ( __strex(parse_updated_ref, parse_ref_count_ptr) );
        if ( !parse_updated_ref )
          process_bitmain_miner(address_info);
      }
      if ( byte_70CE8 || byte_66640 )
      {
LABEL_104:
        snprintf(v121, 2048u, "%s: input invaild param format", "api");
        log_event(3, v121, 0);
      }
      else
      {
LABEL_137:
        if ( dword_657B8 > 2 )
          goto LABEL_104;
      }
      log_error((int)result, 0, 24, "Missing JSON 'command'");
      goto LABEL_45;
    }
    new_api_json = (const char *)get_linked_item_or_null(command_entry);
    snprintf(v102, 16u, "%s", new_api_json);
    temp_fd = (_DWORD *)validate_and_fetch_data(address_info, "new_api");
    if ( !temp_fd )
    {
LABEL_179:
      temp_protocol = address_info[1];
LABEL_170:
      if ( temp_protocol == -1 )
      {
        addr_valid = 1;
        process_miner_command((int)result, v102, 1u);
        goto LABEL_45;
      }
      json_ref_count_ptr = 1;
      goto LABEL_173;
    }
    temp_protocol = address_info[1];
    if ( *temp_fd != 5 )
      goto LABEL_170;
    if ( temp_protocol == -1 )
    {
      addr_valid = protocol;
      process_miner_command((int)result, v102, protocol);
      goto LABEL_45;
    }
    json_ref_count_ptr = protocol;
LABEL_173:
    json_current_ref = address_info + 1;
    __dmb(11u);
    do
    {
      json_updated_ref = __ldrex(json_current_ref);
      temp_errno_ptr = json_updated_ref - 1;
    }
    while ( __strex(temp_errno_ptr, json_current_ref) );
    addr_valid = json_ref_count_ptr;
    if ( temp_errno_ptr )
    {
      process_miner_command((int)result, v102, json_ref_count_ptr);
    }
    else
    {
      process_bitmain_miner(address_info);
      process_miner_command((int)result, v102, addr_valid);
    }
LABEL_45:
    if ( addr_valid == 2 )
    {
      memset(v129, 0, sizeof(v129));
      if ( result )
      {
        status_json = (_DWORD *)validate_and_fetch_data(result, "STATUS");
        if ( status_json )
        {
          if ( *status_json == 1 )
          {
            status_array_obj = get_task_by_index(status_json, 0);
            status_entry = status_array_obj;
            if ( status_array_obj )
            {
              if ( !*status_array_obj )
              {
                array_size = get_next_element_if_available(status_array_obj);
                status_key = get_adjusted_temperature(array_size);
                if ( status_key )
                {
                  v93 = result;
                  do
                  {
                    next_result = adjust_result_value(status_key);
                    status_value = (int *)get_temperature_if_valid(next_result);
                    if ( !status_value )
                      break;
                    str_len = strlen(v129);
                    *(_WORD *)stpcpy(&v129[str_len], status_key) = *(_WORD *)v92;
                    format_miner_status(v129, status_value);
                    *(_WORD *)&v129[strlen(v129)] = 44;
                    temp_result = adjust_result_value(status_key);
                    next_status_key = sub_475A0(status_entry, temp_result);
                    status_key = get_adjusted_temperature(next_status_key);
                  }
                  while ( status_key );
                  result = v93;
                }
                commands_array = (char **)v110;
                v128[strlen(v129) + 2047] = 124;
                memset(src, 0, sizeof(src));
                command_index = protocol;
                v110[0] = "SUMMARY";
                v110[1] = "POOLS";
                v110[2] = "STATS";
                v110[3] = "DEVS";
                v110[4] = "VERSION";
                while ( 1 )
                {
                  current_command = *commands_array++;
                  command_str = current_command;
                  command_json_array = (_DWORD *)validate_and_fetch_data(result, current_command);
                  if ( command_json_array )
                  {
                    if ( *command_json_array == 1 )
                      break;
                  }
                  if ( ++command_index == 5 )
                    goto LABEL_86;
                }
                items_count = command_json_array;
                if ( (command_index & 0xFFFFFFFB) == 0 )
                {
                  snprintf(src, 256u, "%s,", command_str);
                  strcat(v129, src);
                }
                item_index = get_next_structure_pointer(items_count);
                if ( (int)item_index > 0 )
                {
                  item_json = protocol;
                  do
                  {
                    json_object_item = get_task_by_index(items_count, item_json);
                    temp_size = json_object_item;
                    if ( json_object_item && !*json_object_item )
                    {
                      item_key = get_next_element_if_available(json_object_item);
                      item_str_len = get_adjusted_temperature(item_key);
                      if ( item_str_len )
                      {
                        v95 = items_count;
                        do
                        {
                          next_operation = adjust_result_value(item_str_len);
                          command_val = (int *)get_temperature_if_valid(next_operation);
                          if ( !command_val )
                            break;
                          next_item_key = strlen(v129);
                          *(_WORD *)stpcpy(&v129[next_item_key], item_str_len) = *(_WORD *)v92;
                          format_miner_status(v129, command_val);
                          *(_WORD *)&v129[strlen(v129)] = 44;
                          next_temp_result = adjust_result_value(item_str_len);
                          next_result_item = sub_475A0(temp_size, next_temp_result);
                          item_str_len = get_adjusted_temperature(next_result_item);
                        }
                        while ( item_str_len );
                        items_count = v95;
                      }
                      v128[strlen(v129) + 2047] = 124;
                      if ( (_DWORD *)((char *)item_index - 1) != (_DWORD *)item_json )
                        v129[strlen(v129)] = 44;
                    }
                    ++item_json;
                  }
                  while ( item_index != (_DWORD *)item_json );
                }
              }
            }
          }
        }
      }
LABEL_86:
      send_data_with_retry(&fd, v129);
      if ( result )
      {
        if ( result[1] != -1 )
        {
          cmd_api_ref_count_ptr = result + 1;
          __dmb(11u);
          do
          {
            cmd_api_current_ref = __ldrex(cmd_api_ref_count_ptr);
            cmd_api_updated_ref = cmd_api_current_ref - 1;
          }
          while ( __strex(cmd_api_updated_ref, cmd_api_ref_count_ptr) );
          if ( !cmd_api_updated_ref )
            process_bitmain_miner(result);
        }
      }
    }
    else
    {
      response_str = (char *)generate_config_json(result, 24576);
      free_ptr = response_str;
      if ( response_str )
        send_data_with_retry(&fd, response_str);
      if ( result && result[1] != -1 )
      {
        api_ref_count_ptr = result + 1;
        __dmb(11u);
        do
        {
          api_current_ref = __ldrex(api_ref_count_ptr);
          api_updated_ref = api_current_ref - 1;
        }
        while ( __strex(api_updated_ref, api_ref_count_ptr) );
        if ( !api_updated_ref )
          process_bitmain_miner(result);
      }
      free(free_ptr);
    }
LABEL_23:
    close(fd);
  }
  _pthread_unregister_cancel((__pthread_unwind_buf_t *)&v116);
  close_socket(&v96);
  if ( byte_70CE8 || byte_66640 || dword_657B8 > 4 )
  {
    snprintf(v122, 2048u, "End %s function !!!", "api");
    log_event(5, v122, 0);
  }
  close(v96);
}
// 1ACD0: variable 'flags_ptr' is possibly undefined
// 1AD30: variable 'addr_str' is possibly undefined
// 1AD80: variable 'v89' is possibly undefined
// 1B184: variable 'v92' is possibly undefined
// 1B218: variable 'protocol' is possibly undefined
// 1B944: variable 'address_info' is possibly undefined
// 1209C: using guessed type int __fastcall stpcpy(_DWORD, _DWORD);
// 4808C: using guessed type int __fastcall sub_4808C(_DWORD, _DWORD, _DWORD);
// 657B8: using guessed type int dword_657B8;
// 66500: using guessed type int dword_66500;
// 66640: using guessed type char byte_66640;
// 66641: using guessed type char byte_66641;
// 70CE8: using guessed type char byte_70CE8;
// 1A9F4: using guessed type char var_9438[16];
// 1A9F4: using guessed type char var_933C[252];

//----- (0001BAA8) --------------------------------------------------------
void *__fastcall allocate_klist_items(
        const char **list_info,
        const char *source_file,
        const char *source_function,
        int source_line)
{
  void *allocation_result; // r0
  const char *current_list_size; // r3
  const char *current_list_ptr; // r2
  signed int desired_item_count; // r6
  char *item_memory_ptr; // r0
  const char *new_item_count; // r1
  const char *realloc_result; // r0
  char *new_item_ptr; // r5
  const char *old_list_end; // r3
  const char *list_name; // r1
  __int64 qword_helper; // r2
  int flag_val; // r0
  int last_item_offset; // r3
  int second_last_item_offset; // r2
  char *last_item_ptr; // r3
  char *data_memory_ptr; // r0
  const char *new_data_count; // r1
  const char *realloc_data_result; // r0
  char log_message[2072]; // [sp+20h] [bp-818h] BYREF

  allocation_result = (void *)*((unsigned __int8 *)list_info + 4);
  if ( allocation_result )
  {
    snprintf(
      log_message,
      2048u,
      "List %s store can't %s() - from %s %s() line %d in %s %s():%d",
      *list_info,
      "k_alloc_items",
      source_file,
      source_function,
      source_line,
      "klist.c",
      "k_alloc_items",
      19);
    log_event(3, log_message, 1);
    shutdown_miner_safely(1);
  }
  current_list_size = list_info[10];
  if ( (int)current_list_size <= 0 )
  {
    desired_item_count = (signed int)list_info[9];
  }
  else
  {
    current_list_ptr = list_info[6];
    if ( (int)current_list_size <= (int)current_list_ptr )
      return allocation_result;
    desired_item_count = (signed int)list_info[9];
    if ( (int)current_list_size < (int)&current_list_ptr[desired_item_count] )
      desired_item_count = current_list_size - current_list_ptr;
  }
  item_memory_ptr = (char *)list_info[13];
  new_item_count = list_info[12] + 1;
  list_info[12] = new_item_count;
  realloc_result = (const char *)realloc(item_memory_ptr, 4 * (_DWORD)new_item_count);
  list_info[13] = realloc_result;
  if ( !realloc_result )
  {
    snprintf(
      log_message,
      2048u,
      "List %s item_memory failed to realloc count=%d in %s %s():%d",
      *list_info,
      list_info[12],
      "klist.c",
      "k_alloc_items",
      33);
    log_event(3, log_message, 1);
    shutdown_miner_safely(1);
  }
  new_item_ptr = (char *)calloc(desired_item_count, 16u);
  if ( !new_item_ptr )
  {
    snprintf(
      log_message,
      2048u,
      "List %s failed to calloc %d new items - total was %d, limit was %d in %s %s():%d",
      *list_info,
      desired_item_count,
      list_info[6],
      list_info[10],
      "klist.c",
      "k_alloc_items",
      38);
    log_event(3, log_message, 1);
    shutdown_miner_safely(1);
  }
  *(_DWORD *)&list_info[13][4 * (_DWORD)(list_info[12] + 1073741823)] = new_item_ptr;
  old_list_end = list_info[6];
  list_name = *list_info;
  list_info[7] = (const char *)desired_item_count;
  list_info[8] = (const char *)desired_item_count;
  list_info[6] = &old_list_end[desired_item_count];
  *(_DWORD *)new_item_ptr = list_name;
  *((_DWORD *)new_item_ptr + 1) = 0;
  *((_DWORD *)new_item_ptr + 2) = new_item_ptr + 16;
  if ( desired_item_count > 2 )
  {
    HIDWORD(qword_helper) = new_item_ptr + 32;
    do
    {
      LODWORD(qword_helper) = HIDWORD(qword_helper) - 32;
      *(_DWORD *)(HIDWORD(qword_helper) - 16) = list_name;
      *(_QWORD *)(HIDWORD(qword_helper) - 12) = qword_helper;
      HIDWORD(qword_helper) += 16;
    }
    while ( (char *)HIDWORD(qword_helper) != &new_item_ptr[16 * desired_item_count] );
  }
  flag_val = *((unsigned __int8 *)list_info + 44);
  last_item_offset = 16 * (desired_item_count + 268435455);
  *(_DWORD *)&new_item_ptr[last_item_offset] = list_name;
  list_info[3] = new_item_ptr;
  second_last_item_offset = last_item_offset - 16;
  last_item_ptr = &new_item_ptr[last_item_offset];
  *((_DWORD *)last_item_ptr + 1) = &new_item_ptr[second_last_item_offset];
  *((_DWORD *)last_item_ptr + 2) = 0;
  if ( flag_val )
    list_info[4] = last_item_ptr;
  do
  {
    data_memory_ptr = (char *)list_info[15];
    new_data_count = list_info[14] + 1;
    list_info[14] = new_data_count;
    realloc_data_result = (const char *)realloc(data_memory_ptr, 4 * (_DWORD)new_data_count);
    list_info[15] = realloc_data_result;
    if ( !realloc_data_result )
    {
      snprintf(
        log_message,
        2048u,
        "List %s data_memory failed to realloc count=%d in %s %s():%d",
        *list_info,
        list_info[14],
        "klist.c",
        "k_alloc_items",
        69);
      log_event(3, log_message, 1);
      shutdown_miner_safely(1);
    }
    allocation_result = calloc(1u, (size_t)list_info[5]);
    *((_DWORD *)new_item_ptr + 3) = allocation_result;
    if ( !allocation_result )
    {
      snprintf(
        log_message,
        2048u,
        "List %s failed to calloc item data in %s %s():%d",
        *list_info,
        "klist.c",
        "k_alloc_items",
        73);
      log_event(3, log_message, 1);
      shutdown_miner_safely(1);
    }
    *(_DWORD *)&list_info[15][4 * (_DWORD)(list_info[14] + 1073741823)] = allocation_result;
    new_item_ptr = (char *)*((_DWORD *)new_item_ptr + 2);
  }
  while ( new_item_ptr );
  return allocation_result;
}
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 3AADC: using guessed type void __fastcall __noreturn sub_3AADC(_DWORD);

//----- (0001BDE4) --------------------------------------------------------
_DWORD *__fastcall allocate_and_initialize_store(int input_data_ptr)
{
  _DWORD *store_ptr; // r0
  const char *key_name; // r3
  int data_field1; // r12
  char data_field2_flag; // r1
  char log_message[2064]; // [sp+10h] [bp-810h] BYREF

  store_ptr = calloc(1u, 64u);
  key_name = *(const char **)input_data_ptr;
  if ( !store_ptr )
  {
    snprintf(log_message, 2048u, "Failed to calloc store for %s in %s %s():%d", key_name, "klist.c", "k_new_store", 85);
    log_event(3, log_message, 1);
    shutdown_miner_safely(1);
  }
  data_field1 = *(_DWORD *)(input_data_ptr + 8);
  data_field2_flag = *(_BYTE *)(input_data_ptr + 44);
  *store_ptr = key_name;
  store_ptr[2] = data_field1;
  *((_BYTE *)store_ptr + 44) = data_field2_flag;
  *((_BYTE *)store_ptr + 4) = 1;
  return store_ptr;
}
// 3AADC: using guessed type void __fastcall __noreturn sub_3AADC(_DWORD);

//----- (0001BE8C) --------------------------------------------------------
_BYTE *__fastcall initialize_klist(
        const char *list_name,
        int unk2,
        int allocate,
        int limit,
        char unk5,
        const char *item_init_data1,
        const char *item_init_data2,
        int item_init_data_size)
{
  _BYTE *allocated_list; // r0
  _BYTE *list_ptr; // r4
  pthread_mutex_t *mutex_ptr; // r0
  pthread_mutex_t *mutex_initialized; // r5
  int *init_rwlock_err; // r0
  int *init_mutex_err; // r0
  char err_msg[2080]; // [sp+10h] [bp-820h] BYREF

  if ( allocate <= 0 )
  {
    snprintf(
      err_msg,
      2048u,
      "Invalid new list %s with allocate %d must be > 0 in %s %s():%d",
      list_name,
      allocate,
      "klist.c",
      "_k_new_list",
      100);
    log_event(3, err_msg, 1);
    shutdown_miner_safely(1);
  }
  if ( limit < 0 )
  {
    snprintf(
      err_msg,
      2048u,
      "Invalid new list %s with limit %d must be >= 0 in %s %s():%d",
      list_name,
      limit,
      "klist.c",
      "_k_new_list",
      103);
    log_event(3, err_msg, 1);
    shutdown_miner_safely(1);
  }
  allocated_list = calloc(1u, 64u);
  list_ptr = allocated_list;
  if ( !allocated_list )
  {
    snprintf(err_msg, 2048u, "Failed to calloc list %s in %s %s():%d", list_name, "klist.c", "_k_new_list", 107);
    log_event(3, err_msg, 1);
    shutdown_miner_safely(1);
  }
  allocated_list[4] = 0;
  mutex_ptr = (pthread_mutex_t *)calloc(1u, 56u);
  mutex_initialized = mutex_ptr;
  *((_DWORD *)list_ptr + 2) = mutex_ptr;
  if ( !mutex_ptr )
  {
    snprintf(
      err_msg,
      2048u,
      "Failed to calloc lock for list %s in %s %s():%d",
      list_name,
      "klist.c",
      "_k_new_list",
      113);
    log_event(3, err_msg, 1);
    shutdown_miner_safely(1);
  }
  if ( pthread_mutex_init(mutex_ptr, 0) )
  {
    init_mutex_err = _errno_location();
    snprintf(
      err_msg,
      2048u,
      "Failed to pthread_mutex_init errno=%d in %s %s():%d",
      *init_mutex_err,
      "klist.c",
      "_k_new_list",
      115);
    log_event(3, err_msg, 1);
    shutdown_miner_safely(1);
  }
  if ( pthread_rwlock_init((pthread_rwlock_t *)&mutex_initialized[1], 0) )
  {
    init_rwlock_err = _errno_location();
    snprintf(
      err_msg,
      2048u,
      "Failed to pthread_rwlock_init errno=%d in %s %s():%d",
      *init_rwlock_err,
      "klist.c",
      "_k_new_list",
      115);
    log_event(3, err_msg, 1);
    shutdown_miner_safely(1);
  }
  *(_DWORD *)list_ptr = list_name;
  *((_DWORD *)list_ptr + 5) = unk2;
  *((_DWORD *)list_ptr + 9) = allocate;
  *((_DWORD *)list_ptr + 10) = limit;
  list_ptr[44] = unk5;
  allocate_klist_items((const char **)list_ptr, item_init_data1, item_init_data2, item_init_data_size);
  return list_ptr;
}
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 3AADC: using guessed type void __fastcall __noreturn sub_3AADC(_DWORD);

//----- (0001C13C) --------------------------------------------------------
int __fastcall release_klist_item(int klist_header, const char *unkStr1, const char *unkStr2, int intParam)
{
  int klist_item; // r12
  int next_item; // r3
  int released_item_ptr; // r0

  klist_item = *(_DWORD *)(klist_header + 12);
  if ( !klist_item )
  {
    if ( *(_BYTE *)(klist_header + 4) )
      return 0;
    allocate_klist_items((const char **)klist_header, unkStr1, unkStr2, intParam);
    klist_item = *(_DWORD *)(klist_header + 12);
    if ( !klist_item )
      return 0;
  }
  next_item = *(_DWORD *)(klist_item + 8);
  *(_DWORD *)(klist_header + 12) = next_item;
  if ( next_item )
  {
    *(_DWORD *)(next_item + 4) = 0;
  }
  else if ( *(_BYTE *)(klist_header + 44) )
  {
    *(_DWORD *)(klist_header + 16) = 0;
  }
  released_item_ptr = klist_item;
  *(_DWORD *)(klist_item + 8) = 0;
  *(_DWORD *)(klist_item + 4) = 0;
  --*(_DWORD *)(klist_header + 28);
  return released_item_ptr;
}

//----- (0001C1C4) --------------------------------------------------------
int __fastcall clear_item_data(int item_handle, const char *param_1, const char *param_2, int flag)
{
  int v5; // r0
  int clear_result; // r4

  v5 = release_klist_item(item_handle, param_1, param_2, flag);
  clear_result = v5;
  if ( v5 )
    memset(*(void **)(v5 + 12), 0, *(_DWORD *)(item_handle + 20));
  return clear_result;
}

//----- (0001C1F0) --------------------------------------------------------
int __fastcall unlink_tail_from_list(
        int list_ptr,
        const char *caller_filename,
        const char *caller_function_name,
        int caller_line_number)
{
  int unlinked_node_ptr; // r0
  int next_node_ptr; // r3
  char log_msg[2064]; // [sp+20h] [bp-810h] BYREF

  if ( !*(_BYTE *)(list_ptr + 44) )
  {
    snprintf(
      log_msg,
      2048u,
      "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d",
      *(const char **)list_ptr,
      "_k_unlink_tail",
      caller_filename,
      caller_function_name,
      caller_line_number,
      "klist.c",
      "_k_unlink_tail",
      181);
    log_event(3, log_msg, 1);
    shutdown_miner_safely(1);
  }
  unlinked_node_ptr = *(_DWORD *)(list_ptr + 16);
  if ( unlinked_node_ptr )
  {
    next_node_ptr = *(_DWORD *)(unlinked_node_ptr + 4);
    *(_DWORD *)(list_ptr + 16) = next_node_ptr;
    if ( next_node_ptr )
      caller_function_name = 0;
    else
      *(_DWORD *)(list_ptr + 12) = 0;
    if ( next_node_ptr )
      *(_DWORD *)(next_node_ptr + 8) = caller_function_name;
    *(_DWORD *)(unlinked_node_ptr + 8) = 0;
    *(_DWORD *)(unlinked_node_ptr + 4) = 0;
    --*(_DWORD *)(list_ptr + 28);
  }
  return unlinked_node_ptr;
}
// 3AADC: using guessed type void __fastcall __noreturn sub_3AADC(_DWORD);

//----- (0001C2B8) --------------------------------------------------------
const char *__fastcall add_list_head(
        int list_head_addr,
        int new_item_addr,
        const char *function_name,
        const char *function_param,
        int line_number)
{
  const char *item_data; // r0
  int next_item_addr; // r3
  int list_flags; // r3
  __int64 item_count; // r2
  char log_buffer[2064]; // [sp+20h] [bp-810h] BYREF

  item_data = *(const char **)new_item_addr;
  if ( *(_DWORD *)new_item_addr != *(_DWORD *)list_head_addr )
  {
    snprintf(
      log_buffer,
      2048u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      *(const char **)list_head_addr,
      "_k_add_head",
      item_data,
      function_name,
      function_param,
      line_number,
      "klist.c",
      "_k_add_head",
      205);
    log_event(3, log_buffer, 1);
    shutdown_miner_safely(1);
  }
  *(_DWORD *)(new_item_addr + 4) = 0;
  *(_DWORD *)(new_item_addr + 8) = *(_DWORD *)(list_head_addr + 12);
  next_item_addr = *(_DWORD *)(list_head_addr + 12);
  if ( next_item_addr )
    *(_DWORD *)(next_item_addr + 4) = new_item_addr;
  list_flags = *(unsigned __int8 *)(list_head_addr + 44);
  *(_DWORD *)(list_head_addr + 12) = new_item_addr;
  if ( list_flags && !*(_DWORD *)(list_head_addr + 16) )
    *(_DWORD *)(list_head_addr + 16) = new_item_addr;
  item_count = *(_QWORD *)(list_head_addr + 28);
  LODWORD(item_count) = item_count + 1;
  ++HIDWORD(item_count);
  *(_QWORD *)(list_head_addr + 28) = item_count;
  return item_data;
}
// 3AADC: using guessed type void __fastcall __noreturn sub_3AADC(_DWORD);

//----- (0001C38C) --------------------------------------------------------
const char **__fastcall add_item_to_tail(
        const char **list,
        int new_item,
        const char *file_name,
        const char *function_name,
        int line_number)
{
  const char *existing_item; // r1
  const char *last_item; // r3
  const char *updated_last_item; // r3
  const char *first_item; // r3
  bool is_first_item_null; // zf
  __int64 item_count; // r2
  char error_message[2072]; // [sp+20h] [bp-818h] BYREF

  existing_item = *(const char **)new_item;
  if ( existing_item != *list )
  {
    snprintf(
      error_message,
      2048u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      *list,
      "_k_add_tail",
      existing_item,
      file_name,
      function_name,
      line_number,
      "klist.c",
      "_k_add_tail",
      236);
    log_event(3, error_message, 1);
    shutdown_miner_safely(1);
  }
  if ( !*((_BYTE *)list + 44) )
  {
    snprintf(
      error_message,
      2048u,
      "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d",
      *list,
      "_k_add_tail",
      file_name,
      function_name,
      line_number,
      "klist.c",
      "_k_add_tail",
      241);
    log_event(3, error_message, 1);
    shutdown_miner_safely(1);
  }
  last_item = list[4];
  *(_DWORD *)(new_item + 8) = 0;
  *(_DWORD *)(new_item + 4) = last_item;
  updated_last_item = list[4];
  if ( updated_last_item )
    *((_DWORD *)updated_last_item + 2) = new_item;
  first_item = list[3];
  list[4] = (const char *)new_item;
  is_first_item_null = first_item == 0;
  item_count = *(_QWORD *)(list + 7);
  if ( is_first_item_null )
    list[3] = (const char *)new_item;
  LODWORD(item_count) = item_count + 1;
  ++HIDWORD(item_count);
  *(_QWORD *)(list + 7) = item_count;
  return list;
}
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 3AADC: using guessed type void __fastcall __noreturn sub_3AADC(_DWORD);

//----- (0001C4D8) --------------------------------------------------------
const char **__fastcall insert_before_in_list(
        const char **list,
        int new_item,
        int existing_item,
        const char *src_file,
        const char *function_name,
        int line_number)
{
  const char *new_item_value; // r1
  int existing_item_prev; // r3
  __int64 item_count_update; // r2
  char error_message[2072]; // [sp+20h] [bp-818h] BYREF

  new_item_value = *(const char **)new_item;
  if ( new_item_value != *list )
  {
    snprintf(
      error_message,
      2048u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      *list,
      "_k_insert_before",
      new_item_value,
      src_file,
      function_name,
      line_number,
      "klist.c",
      "_k_insert_before",
      262);
    log_event(3, error_message, 1);
    shutdown_miner_safely(1);
  }
  if ( !existing_item )
  {
    snprintf(
      error_message,
      2048u,
      "%s() (%s) can't before a null item - from %s %s() line %d in %s %s():%d",
      "_k_insert_before",
      *list,
      src_file,
      function_name,
      line_number,
      "klist.c",
      "_k_insert_before",
      267);
    log_event(3, error_message, 1);
    shutdown_miner_safely(1);
  }
  *(_DWORD *)(new_item + 8) = existing_item;
  *(_DWORD *)(new_item + 4) = *(_DWORD *)(existing_item + 4);
  existing_item_prev = *(_DWORD *)(existing_item + 4);
  if ( existing_item_prev )
    *(_DWORD *)(existing_item_prev + 8) = new_item;
  else
    list[3] = (const char *)new_item;
  *(_DWORD *)(existing_item + 4) = new_item;
  item_count_update = *(_QWORD *)(list + 7);
  LODWORD(item_count_update) = item_count_update + 1;
  ++HIDWORD(item_count_update);
  *(_QWORD *)(list + 7) = item_count_update;
  return list;
}
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 3AADC: using guessed type void __fastcall __noreturn sub_3AADC(_DWORD);

//----- (0001C620) --------------------------------------------------------
const char **__fastcall insert_after_list_item(
        const char **list,
        int new_item,
        int prev_item,
        const char *src_file,
        const char *function,
        int line_number)
{
  const char *item_type; // r1
  int next_item_pointer; // r3
  __int64 updated_count; // r2
  char error_message[2072]; // [sp+20h] [bp-818h] BYREF

  item_type = *(const char **)new_item;
  if ( item_type != *list )
  {
    snprintf(
      error_message,
      2048u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      *list,
      "_k_insert_after",
      item_type,
      src_file,
      function,
      line_number,
      "klist.c",
      "_k_insert_after",
      286);
    log_event(3, error_message, 1);
    shutdown_miner_safely(1);
  }
  if ( !prev_item )
  {
    snprintf(
      error_message,
      2048u,
      "%s() (%s) can't after a null item - from %s %s() line %d in %s %s():%d",
      "_k_insert_after",
      *list,
      src_file,
      function,
      line_number,
      "klist.c",
      "_k_insert_after",
      291);
    log_event(3, error_message, 1);
    shutdown_miner_safely(1);
  }
  *(_DWORD *)(new_item + 4) = prev_item;
  *(_DWORD *)(new_item + 8) = *(_DWORD *)(prev_item + 8);
  next_item_pointer = *(_DWORD *)(prev_item + 8);
  if ( next_item_pointer )
  {
    *(_DWORD *)(next_item_pointer + 4) = new_item;
  }
  else if ( *((_BYTE *)list + 44) )
  {
    list[4] = (const char *)new_item;
  }
  *(_DWORD *)(prev_item + 8) = new_item;
  updated_count = *(_QWORD *)(list + 7);
  LODWORD(updated_count) = updated_count + 1;
  ++HIDWORD(updated_count);
  *(_QWORD *)(list + 7) = updated_count;
  return list;
}
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 3AADC: using guessed type void __fastcall __noreturn sub_3AADC(_DWORD);

//----- (0001C774) --------------------------------------------------------
const char *__fastcall unlink_list_item(
        int list,
        int item,
        const char *file_name,
        const char *function_name,
        int line_number)
{
  const char *item_name; // r0
  __int64 item_links; // r2
  char error_message[2064]; // [sp+20h] [bp-810h] BYREF

  item_name = *(const char **)item;
  if ( *(_DWORD *)item != *(_DWORD *)list )
  {
    snprintf(
      error_message,
      2048u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      *(const char **)list,
      "_k_unlink_item",
      item_name,
      file_name,
      function_name,
      line_number,
      "klist.c",
      "_k_unlink_item",
      312);
    log_event(3, error_message, 1);
    shutdown_miner_safely(1);
  }
  item_links = *(_QWORD *)(item + 4);
  if ( (_DWORD)item_links )
  {
    *(_DWORD *)(item_links + 8) = HIDWORD(item_links);
    HIDWORD(item_links) = *(_DWORD *)(item + 8);
  }
  if ( HIDWORD(item_links) )
    *(_DWORD *)(HIDWORD(item_links) + 4) = *(_DWORD *)(item + 4);
  if ( *(_DWORD *)(list + 12) == item )
    *(_DWORD *)(list + 12) = *(_DWORD *)(item + 8);
  if ( *(_BYTE *)(list + 44) && *(_DWORD *)(list + 16) == item )
    *(_DWORD *)(list + 16) = *(_DWORD *)(item + 4);
  *(_DWORD *)(item + 8) = 0;
  *(_DWORD *)(item + 4) = 0;
  --*(_DWORD *)(list + 28);
  return item_name;
}
// 3AADC: using guessed type void __fastcall __noreturn sub_3AADC(_DWORD);

//----- (0001C860) --------------------------------------------------------
const char *__fastcall transfer_list_to_head(
        const char **source_list,
        int target_list_descriptor,
        const char *file_name,
        const char *function_name,
        int line_number)
{
  const char *source_list_name; // r0
  const char *target_list_name; // r1
  int target_prev_node; // r2
  const char *source_next_node; // r3
  const char *source_total_nodes; // r1
  char log_message[2072]; // [sp+20h] [bp-818h] BYREF

  source_list_name = *source_list;
  target_list_name = *(const char **)target_list_descriptor;
  if ( source_list_name != target_list_name )
  {
    snprintf(
      log_message,
      2048u,
      "List %s can't %s() to a %s list - from %s %s() line %d in %s %s():%d",
      source_list_name,
      "_k_list_transfer_to_head",
      target_list_name,
      file_name,
      function_name,
      line_number,
      "klist.c",
      "_k_list_transfer_to_head",
      338);
    log_event(3, log_message, 1);
    shutdown_miner_safely(1);
  }
  if ( !*((_BYTE *)source_list + 44) )
  {
    snprintf(
      log_message,
      2048u,
      "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d",
      *source_list,
      "_k_list_transfer_to_head",
      file_name,
      function_name,
      line_number,
      "klist.c",
      "_k_list_transfer_to_head",
      343);
    log_event(3, log_message, 1);
    shutdown_miner_safely(1);
  }
  if ( source_list[3] )
  {
    target_prev_node = *(_DWORD *)(target_list_descriptor + 12);
    source_next_node = source_list[4];
    if ( target_prev_node )
      *(_DWORD *)(target_prev_node + 4) = source_next_node;
    else
      *(_DWORD *)(target_list_descriptor + 16) = source_next_node;
    if ( target_prev_node )
      target_prev_node = *(_DWORD *)(target_list_descriptor + 12);
    *((_DWORD *)source_list[4] + 2) = target_prev_node;
    *(_DWORD *)(target_list_descriptor + 12) = source_list[3];
    source_list[4] = 0;
    source_total_nodes = source_list[7];
    source_list[3] = 0;
    *(_DWORD *)(target_list_descriptor + 28) += source_total_nodes;
    source_list[7] = 0;
    *(_DWORD *)(target_list_descriptor + 32) += source_list[8];
    source_list[8] = 0;
  }
  return source_list_name;
}
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 3AADC: using guessed type void __fastcall __noreturn sub_3AADC(_DWORD);

//----- (0001C9D0) --------------------------------------------------------
const char *__fastcall transfer_list_to_tail(
        const char **source_list,
        int dest_struct_ptr,
        const char *func_file,
        const char *func_name,
        int line_number)
{
  const char *source_list_name; // r0
  const char *dest_list_name; // r1
  const char *source_first_item; // r3
  int dest_last_item; // r2
  const char *source_items_len; // r1
  char log_msg[2072]; // [sp+20h] [bp-818h] BYREF

  source_list_name = *source_list;
  dest_list_name = *(const char **)dest_struct_ptr;
  if ( source_list_name != dest_list_name )
  {
    snprintf(
      log_msg,
      2048u,
      "List %s can't %s() to a %s list - from %s %s() line %d in %s %s():%d",
      source_list_name,
      "_k_list_transfer_to_tail",
      dest_list_name,
      func_file,
      func_name,
      line_number,
      "klist.c",
      "_k_list_transfer_to_tail",
      368);
    log_event(3, log_msg, 1);
    shutdown_miner_safely(1);
  }
  if ( !*((_BYTE *)source_list + 44) )
  {
    snprintf(
      log_msg,
      2048u,
      "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d",
      *source_list,
      "_k_list_transfer_to_tail",
      func_file,
      func_name,
      line_number,
      "klist.c",
      "_k_list_transfer_to_tail",
      373);
    log_event(3, log_msg, 1);
    shutdown_miner_safely(1);
  }
  source_first_item = source_list[3];
  if ( source_first_item )
  {
    dest_last_item = *(_DWORD *)(dest_struct_ptr + 16);
    if ( dest_last_item )
      *(_DWORD *)(dest_last_item + 8) = source_first_item;
    else
      *(_DWORD *)(dest_struct_ptr + 12) = source_first_item;
    if ( dest_last_item )
      dest_last_item = *(_DWORD *)(dest_struct_ptr + 16);
    *((_DWORD *)source_list[3] + 1) = dest_last_item;
    *(_DWORD *)(dest_struct_ptr + 16) = source_list[4];
    source_list[4] = 0;
    source_items_len = source_list[7];
    source_list[3] = 0;
    *(_DWORD *)(dest_struct_ptr + 28) += source_items_len;
    source_list[7] = 0;
    *(_DWORD *)(dest_struct_ptr + 32) += source_list[8];
    source_list[8] = 0;
  }
  return source_list_name;
}
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 3AADC: using guessed type void __fastcall __noreturn sub_3AADC(_DWORD);

//----- (0001CB3C) --------------------------------------------------------
int __fastcall free_list_and_related_resources(
        const char **list,
        const char *function_name,
        const char *function,
        int line_number)
{
  int store_index; // r5
  void *store_ptr; // r0
  int metadata_index; // r5
  void *metadata_ptr; // r0
  char *rwlock_ptr; // r5
  char log_message[2064]; // [sp+20h] [bp-810h] BYREF

  if ( *((_BYTE *)list + 4) )
  {
    snprintf(
      log_message,
      2048u,
      "List %s can't %s() a store - from %s %s() line %d in %s %s():%d",
      *list,
      "_k_free_list",
      function_name,
      function,
      line_number,
      "klist.c",
      "_k_free_list",
      400);
    log_event(3, log_message, 1);
    shutdown_miner_safely(1);
  }
  if ( (int)list[12] > 0 )
  {
    store_index = 0;
    do
    {
      store_ptr = *(void **)&list[13][4 * store_index++];
      free(store_ptr);
    }
    while ( (int)list[12] > store_index );
  }
  free((void *)list[13]);
  if ( (int)list[14] > 0 )
  {
    metadata_index = 0;
    do
    {
      metadata_ptr = *(void **)&list[15][4 * metadata_index++];
      free(metadata_ptr);
    }
    while ( (int)list[14] > metadata_index );
  }
  free((void *)list[15]);
  rwlock_ptr = (char *)list[2];
  pthread_rwlock_destroy((pthread_rwlock_t *)(rwlock_ptr + 24));
  pthread_mutex_destroy((pthread_mutex_t *)rwlock_ptr);
  free((void *)list[2]);
  free(list);
  return 0;
}
// 3AADC: using guessed type void __fastcall __noreturn sub_3AADC(_DWORD);

//----- (0001CC58) --------------------------------------------------------
int __fastcall log_free_store_failure_and_free(
        void *store_ptr,
        const char *function_name,
        const char *caller_function_name,
        int caller_line_number)
{
  char log_message[2064]; // [sp+20h] [bp-810h] BYREF

  if ( !*((_BYTE *)store_ptr + 4) )
  {
    snprintf(
      log_message,
      2048u,
      "Store %s can't %s() the list - from %s %s() line %d in %s %s():%d",
      *(const char **)store_ptr,
      "_k_free_store",
      function_name,
      caller_function_name,
      caller_line_number,
      "klist.c",
      "_k_free_store",
      424);
    log_event(3, log_message, 1);
    shutdown_miner_safely(1);
  }
  free(store_ptr);
  return 0;
}
// 3AADC: using guessed type void __fastcall __noreturn sub_3AADC(_DWORD);

//----- (0001CCEC) --------------------------------------------------------
void __fastcall log_event(int log_priority, const char *message, int ignored_param)
{
  int milliseconds; // r4
  struct tm *timestamp; // r0
  int file_descriptor; // r0
  FILE *log_file; // r5
  size_t timestamp_length; // r0
  size_t message_length; // r0
  int should_log_debug; // r7
  time_t timer_value; // [sp+1Ch] [bp-6Ch] BYREF
  time_t function_start_time; // [sp+20h] [bp-68h] BYREF
  int duration_microseconds; // [sp+24h] [bp-64h]
  char formatted_timestamp[96]; // [sp+28h] [bp-60h] BYREF

  if ( byte_70CE8 )
  {
    syslog(log_priority | 0x80, "%s", message);
  }
  else
  {
    function_start_time = (unsigned __int8)byte_70CE8;
    duration_microseconds = (unsigned __int8)byte_70CE8;
    get_hardware_timestamp(&function_start_time, message, ignored_param, (unsigned __int8)byte_70CE8);
    timer_value = function_start_time;
    milliseconds = duration_microseconds / 1000;
    timestamp = localtime(&timer_value);
    snprintf(
      formatted_timestamp,
      64u,
      " [%d-%02d-%02d %02d:%02d:%02d.%03d] ",
      timestamp->tm_year + 1900,
      timestamp->tm_mon + 1,
      timestamp->tm_mday,
      timestamp->tm_hour,
      timestamp->tm_min,
      timestamp->tm_sec,
      milliseconds);
    file_descriptor = fileno((FILE *)stderr);
    if ( !isatty(file_descriptor) )
    {
      fprintf((FILE *)stderr, "%s%s\n", formatted_timestamp, message);
      fflush((FILE *)stderr);
    }
    if ( byte_66518 )
    {
      log_file = (FILE *)dword_6651C;
      if ( dword_6651C || (log_file = (FILE *)fopen64(&dword_66540, &word_66520), (dword_6651C = (int)log_file) != 0) )
      {
        timestamp_length = strlen(formatted_timestamp);
        fwrite(formatted_timestamp, timestamp_length, 1u, log_file);
        message_length = strlen(message);
        fwrite(message, message_length, 1u, (FILE *)dword_6651C);
        fwrite("\n", 1u, 1u, (FILE *)dword_6651C);
        fflush((FILE *)dword_6651C);
      }
    }
    if ( log_priority == 3 )
      should_log_debug = 0;
    else
      should_log_debug = byte_7418C & 1;
    if ( !should_log_debug )
      print_message_with_padding(formatted_timestamp, message, ignored_param, (unsigned __int8)byte_7418C);
  }
}
// 1224C: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 1CFD8: using guessed type int __fastcall sub_1CFD8(_DWORD, _DWORD, _DWORD, _DWORD);
// 1F5C4: using guessed type int __fastcall sub_1F5C4(_DWORD, _DWORD, _DWORD, _DWORD);
// 664F8: using guessed type int stderr;
// 66518: using guessed type char byte_66518;
// 6651C: using guessed type int dword_6651C;
// 66520: using guessed type __int16 word_66520;
// 66540: using guessed type int dword_66540;
// 70CE8: using guessed type char byte_70CE8;
// 7418C: using guessed type char byte_7418C;

//----- (0001CECC) --------------------------------------------------------
int __fastcall unlock_logging_mutex(int log_line_number)
{
  int unlock_result; // r0
  int *errno_ptr; // r0
  char error_message[2056]; // [sp+10h] [bp-808h] BYREF

  unlock_result = pthread_mutex_unlock(&stru_72F3C);
  if ( unlock_result )
  {
    errno_ptr = _errno_location();
    snprintf(
      error_message,
      2048u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *errno_ptr,
      "logging.c",
      "my_log_curses",
      log_line_number);
    log_event(3, error_message, 1);
    shutdown_miner_safely(1);
  }
  return unlock_result;
}
// 3AADC: using guessed type void __fastcall __noreturn sub_3AADC(_DWORD);
// 72F3C: using guessed type pthread_mutex_t stru_72F3C;

//----- (0001CF44) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_1CF44(int a1, int a2, int a3, int a4, int a5, int a6)
{
  __asm { POP             {R4,PC} }
}
// 1CF48: positive sp value 810 has been found
// 1CF48: unbalanced stack, ignored a potential tail call

//----- (0001CF4C) --------------------------------------------------------
int lock_logging_mutex()
{
  int lock_result; // r0
  int *errno_pointer; // r0
  char error_message[2056]; // [sp+10h] [bp-808h] BYREF

  lock_result = pthread_mutex_lock(&stru_72F3C);
  if ( lock_result )
  {
    errno_pointer = _errno_location();
    snprintf(
      error_message,
      2048u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *errno_pointer,
      "logging.c",
      "my_log_curses",
      52);
    log_event(3, error_message, 1);
    shutdown_miner_safely(1);
  }
  return lock_result;
}
// 3AADC: using guessed type void __fastcall __noreturn sub_3AADC(_DWORD);
// 72F3C: using guessed type pthread_mutex_t stru_72F3C;

//----- (0001CFCC) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_1CFCC(int a1, int a2, int a3, int a4, int a5)
{
  __asm { POP             {PC} }
}
// 1CFD4: positive sp value 814 has been found
// 1CFD4: unbalanced stack, ignored a potential tail call

//----- (0001CFD8) --------------------------------------------------------
int __fastcall print_message_with_padding(const char *prefix, const char *message, int should_lock)
{
  int unlock_parameter; // r0
  int lock_parameter; // r0

  if ( should_lock )
  {
    pthread_mutex_trylock(&stru_72F3C);
    lock_parameter = unlock_logging_mutex(41);
    off_658DC(lock_parameter);
  }
  lock_logging_mutex();
  printf("%s%s%s", prefix, message, "                    \n");
  unlock_parameter = unlock_logging_mutex(54);
  return off_658DC(unlock_parameter);
}
// 1CECC: using guessed type int __fastcall sub_1CECC(_DWORD);
// 1CF4C: using guessed type int sub_1CF4C(void);
// 1DA28: using guessed type int sub_1DA28(void);
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);
// 72F3C: using guessed type pthread_mutex_t stru_72F3C;

//----- (0001D050) --------------------------------------------------------
void __fastcall log_message(int priority, const char *message, int padding_chars)
{
  int stderr_descriptor; // r0
  int use_padding; // r0

  if ( byte_70CE8 )
  {
    syslog(priority | 0x80, "%s", message);
  }
  else
  {
    stderr_descriptor = fileno((FILE *)stderr);
    if ( !isatty(stderr_descriptor) )
    {
      fprintf((FILE *)stderr, "%s\n", message);
      fflush((FILE *)stderr);
    }
    if ( priority == 3 )
      use_padding = 0;
    else
      use_padding = byte_7418C & 1;
    if ( !use_padding )
      print_message_with_padding("", message, padding_chars);
  }
}
// 664F8: using guessed type int stderr;
// 70CE8: using guessed type char byte_70CE8;
// 7418C: using guessed type char byte_7418C;

//----- (0001D1CC) --------------------------------------------------------
__int64 __fastcall get_miner_info(int miner_data_ptr, _QWORD *out_miner_status, _QWORD *out_miner_hashrate)
{
  int miner_info_ptr; // r3
  __int64 status_result; // r0

  miner_info_ptr = *(_DWORD *)(miner_data_ptr + 24);
  if ( miner_info_ptr )
  {
    *out_miner_status = *(_QWORD *)(miner_info_ptr + 16);
    status_result = *(_QWORD *)(miner_info_ptr + 24);
    *out_miner_hashrate = status_result;
  }
  else
  {
    status_result = 0LL;
    *out_miner_status = 0LL;
    *out_miner_hashrate = 0LL;
  }
  return status_result;
}

//----- (0001D604) --------------------------------------------------------
int __fastcall update_hash_state(int hash_state, unsigned __int8 *input_block, int input_length)
{
  unsigned __int8 *current_block_ptr; // r0
  int *message_schedule_array_ptr; // lr
  int *compressed_chunk_ptr; // r12
  int byte1; // r3
  int byte2; // r4
  int byte3; // r1
  int byte0; // t1
  unsigned int schedule_word; // lr
  int *schedule_chunk_ptr; // r3
  unsigned int processed_word; // t1
  int initial_hash_value; // r0
  int *tmp_hash_state_ptr; // r3
  int *hash_values_ptr; // r2
  int hash_value; // t1
  int index; // r6
  int a; // r3
  int e; // r4
  int f; // r10
  int g; // r9
  int b; // r5
  int c; // r8
  int d; // r7
  int h; // r11
  int temp1; // r2
  int constant_value; // r12
  int sum1; // r3
  int temp2; // lr
  int sum0; // r1
  int *hash_state_tmp_ptr; // r1
  int *hash_state_ptr; // r3
  int tmp_state_value; // t1
  bool is_final_block; // zf
  unsigned __int8 *input_ptr; // [sp+4h] [bp-164h]
  int *hash_state_end_ptr; // [sp+8h] [bp-160h]
  unsigned __int8 *last_block_ptr; // [sp+14h] [bp-154h]
  int initial_hash_state_ptr; // [sp+18h] [bp-150h]
  int working_hash_state_start; // [sp+1Ch] [bp-14Ch] BYREF
  int initial_a; // [sp+20h] [bp-148h]
  int initial_b; // [sp+24h] [bp-144h]
  int initial_c; // [sp+28h] [bp-140h]
  int initial_d; // [sp+2Ch] [bp-13Ch]
  int initial_e; // [sp+30h] [bp-138h]
  int initial_f; // [sp+34h] [bp-134h]
  int initial_g; // [sp+38h] [bp-130h]
  int initial_h; // [sp+3Ch] [bp-12Ch] BYREF
  int message_schedule_array[15]; // [sp+40h] [bp-128h] BYREF
  char end_schedule_chunk_ptr; // [sp+7Ch] [bp-ECh] BYREF
  char end_compressed_chunk_ptr; // [sp+100h] [bp-68h] BYREF

  if ( input_length > 0 )
  {
    initial_hash_state_ptr = hash_state + 136;
    input_ptr = input_block;
    last_block_ptr = &input_block[64 * input_length];
    working_hash_state_start = hash_state + 168;
    do
    {
      current_block_ptr = input_ptr;
      message_schedule_array_ptr = &initial_h;
      compressed_chunk_ptr = message_schedule_array;
      do
      {
        byte1 = current_block_ptr[1];
        byte2 = current_block_ptr[2];
        byte3 = current_block_ptr[3];
        byte0 = *current_block_ptr;
        current_block_ptr += 4;
        message_schedule_array_ptr[1] = (byte1 << 16) | (byte2 << 8) | byte3 | (byte0 << 24);
        ++message_schedule_array_ptr;
      }
      while ( &end_schedule_chunk_ptr != (char *)message_schedule_array_ptr );
      do
      {
        schedule_word = compressed_chunk_ptr[14];
        schedule_chunk_ptr = compressed_chunk_ptr;
        processed_word = compressed_chunk_ptr[1];
        ++compressed_chunk_ptr;
        compressed_chunk_ptr[15] = (__ROR4__(schedule_word, 19) ^ __ROR4__(schedule_word, 17) ^ (schedule_word >> 10))
                                 + schedule_chunk_ptr[9]
                                 + *schedule_chunk_ptr
                                 + (__ROR4__(processed_word, 18) ^ __ROR4__(processed_word, 7) ^ (processed_word >> 3));
      }
      while ( &end_compressed_chunk_ptr != (char *)compressed_chunk_ptr );
      initial_hash_value = working_hash_state_start;
      tmp_hash_state_ptr = &working_hash_state_start;
      hash_values_ptr = (int *)initial_hash_state_ptr;
      do
      {
        hash_value = *hash_values_ptr++;
        tmp_hash_state_ptr[1] = hash_value;
        ++tmp_hash_state_ptr;
      }
      while ( (int *)initial_hash_value != hash_values_ptr );
      hash_state_end_ptr = hash_values_ptr;
      index = 0;
      a = initial_h;
      e = initial_e;
      f = initial_f;
      g = initial_g;
      b = initial_a;
      c = initial_b;
      d = initial_c;
      h = initial_d;
      while ( 1 )
      {
        temp1 = (__ROR4__(e, 11) ^ __ROR4__(e, 6) ^ __ROR4__(e, 25)) + (g & ~e ^ f & e) + message_schedule_array[index];
        constant_value = dword_657BC[index++];
        sum1 = temp1 + constant_value + a;
        temp2 = h + sum1;
        sum0 = (__ROR4__(b, 13) ^ __ROR4__(b, 2) ^ __ROR4__(b, 22)) + ((d ^ c) & b ^ d & c) + sum1;
        h = d;
        a = g;
        if ( index == 64 )
          break;
        d = c;
        g = f;
        c = b;
        f = e;
        b = sum0;
        e = temp2;
      }
      initial_a = sum0;
      hash_state_tmp_ptr = &working_hash_state_start;
      hash_state_ptr = (int *)initial_hash_state_ptr;
      initial_h = g;
      initial_e = temp2;
      initial_f = e;
      initial_g = f;
      initial_b = b;
      initial_c = c;
      initial_d = d;
      do
      {
        hash_state = *hash_state_ptr;
        tmp_state_value = hash_state_tmp_ptr[1];
        ++hash_state_tmp_ptr;
        *hash_state_ptr++ += tmp_state_value;
      }
      while ( hash_state_end_ptr != hash_state_ptr );
      is_final_block = last_block_ptr == input_ptr + 64;
      input_ptr += 64;
    }
    while ( !is_final_block );
  }
  return hash_state;
}
// 657BC: using guessed type _DWORD dword_657BC[63];
// 1D604: using guessed type _DWORD var_128[15];

//----- (0001D800) --------------------------------------------------------
_DWORD *__fastcall reset_asic_status(_DWORD *asic_status)
{
  _DWORD *current_reading_ptr; // r2
  _DWORD *asic_status_ptr; // r3
  int temp_reading; // t1

  current_reading_ptr = &unk_658B8;
  asic_status_ptr = asic_status + 34;
  do
  {
    temp_reading = current_reading_ptr[1];
    ++current_reading_ptr;
    *asic_status_ptr++ = temp_reading;
  }
  while ( asic_status_ptr != asic_status + 42 );
  asic_status[1] = 0;
  *asic_status = 0;
  return asic_status;
}

//----- (0001D830) --------------------------------------------------------
void *__fastcall update_internal_buffer(unsigned __int8 *hash_buffer, char *input_data, size_t input_length)
{
  int remaining_space; // r0
  size_t space_to_fill; // r2
  unsigned __int8 *next_input_pos; // r0
  size_t num_bytes_to_copy_first; // r6
  void *memcpy_result; // r0
  size_t new_total_length; // r3
  size_t remaining_input_bytes; // r5
  unsigned __int8 *next_input_chunk; // r6
  int current_length; // r3

  remaining_space = *((_DWORD *)hash_buffer + 1);
  space_to_fill = 64 - remaining_space;
  next_input_pos = &hash_buffer[remaining_space + 8];
  if ( space_to_fill >= input_length )
    num_bytes_to_copy_first = input_length;
  else
    num_bytes_to_copy_first = space_to_fill;
  memcpy_result = memcpy(next_input_pos, input_data, num_bytes_to_copy_first);
  new_total_length = input_length + *((_DWORD *)hash_buffer + 1);
  if ( new_total_length > 63 )
  {
    remaining_input_bytes = input_length - num_bytes_to_copy_first;
    next_input_chunk = (unsigned __int8 *)&input_data[num_bytes_to_copy_first];
    update_hash_state((int)hash_buffer, hash_buffer + 8, 1);
    update_hash_state((int)hash_buffer, next_input_chunk, remaining_input_bytes >> 6);
    memcpy_result = memcpy(
                      hash_buffer + 8,
                      &next_input_chunk[remaining_input_bytes & 0xFFFFFFC0],
                      remaining_input_bytes & 0x3F);
    current_length = *(_DWORD *)hash_buffer;
    *((_DWORD *)hash_buffer + 1) = remaining_input_bytes & 0x3F;
    *(_DWORD *)hash_buffer = current_length + (((remaining_input_bytes >> 6) + 1) << 6);
  }
  else
  {
    *((_DWORD *)hash_buffer + 1) = new_total_length;
  }
  return memcpy_result;
}

//----- (0001D8DC) --------------------------------------------------------
int __fastcall finalize_hash_state(_DWORD *hash_state, _BYTE *output_hash)
{
  int index_end_1; // r8
  int index_end_2; // r9
  int index_end_3; // r10
  int buffer_fill_loop; // r11
  int current_length; // r3
  unsigned __int8 *current_position; // r6
  bool is_large; // cf
  int padding_length; // r2
  int total_length; // r7
  size_t zero_pad_length; // r2
  unsigned __int8 *pad_position; // r0
  int byte3_position; // r3
  int length_in_bits; // r7
  int result; // r0
  int *hash_part_start; // r3
  int *hash_part_end; // r5
  int current_hash_value; // t1
  int byte4_position; // [sp+4h] [bp-2Ch]

  current_length = hash_state[1];
  current_position = (unsigned __int8 *)(hash_state + 2);
  is_large = (current_length & 0x3Fu) >= 56;
  if ( (current_length & 0x3Fu) >= 56 )
    padding_length = 128;
  else
    padding_length = 64;
  total_length = current_length + *hash_state;
  zero_pad_length = padding_length - current_length;
  pad_position = &current_position[current_length];
  if ( (current_length & 0x3Fu) >= 56 )
    byte3_position = 124;
  else
    byte3_position = 60;
  length_in_bits = 8 * total_length;
  if ( !is_large )
    index_end_1 = 61;
  byte4_position = byte3_position;
  if ( is_large )
    index_end_1 = 125;
  else
    index_end_2 = 62;
  if ( is_large )
    index_end_2 = 126;
  else
    index_end_3 = 63;
  if ( is_large )
    index_end_3 = 127;
  else
    buffer_fill_loop = 1;
  if ( is_large )
    buffer_fill_loop = 2;
  memset(pad_position, 0, zero_pad_length);
  *((_BYTE *)hash_state + hash_state[1] + 8) = -128;
  current_position[index_end_3] = length_in_bits;
  current_position[index_end_2] = BYTE1(length_in_bits);
  current_position[index_end_1] = BYTE2(length_in_bits);
  current_position[byte4_position] = HIBYTE(length_in_bits);
  result = update_hash_state((int)hash_state, current_position, buffer_fill_loop);
  hash_part_start = hash_state + 34;
  hash_part_end = hash_state + 42;
  do
  {
    output_hash[3] = *hash_part_start;
    current_hash_value = *hash_part_start++;
    output_hash[2] = BYTE1(current_hash_value);
    output_hash[1] = *((_WORD *)hash_part_start - 1);
    *output_hash = *((_BYTE *)hash_part_start - 1);
    output_hash += 4;
  }
  while ( hash_part_end != hash_part_start );
  return result;
}
// 1D970: variable 'index_end_3' is possibly undefined
// 1D978: variable 'index_end_2' is possibly undefined
// 1D97C: variable 'index_end_1' is possibly undefined
// 1D988: variable 'buffer_fill_loop' is possibly undefined

//----- (0001D9C8) --------------------------------------------------------
int __fastcall initialize_and_process_data(int data_input, size_t data_length, int process_param)
{
  _DWORD *source_ptr; // r3
  char *dest_ptr; // r2
  int temp_data; // t1
  _DWORD processed_data[34]; // [sp+0h] [bp-B8h] BYREF
  char initial_data; // [sp+88h] [bp-30h] BYREF

  source_ptr = &unk_658B8;
  dest_ptr = &initial_data;
  do
  {
    temp_data = source_ptr[1];
    ++source_ptr;
    *(_DWORD *)dest_ptr = temp_data;
    dest_ptr += 4;
  }
  while ( source_ptr != (_DWORD *)&unk_658D8 );
  processed_data[0] = 0;
  processed_data[1] = 0;
  update_internal_buffer((int)processed_data, data_input, data_length);
  return finalize_hash_state(processed_data, process_param);
}
// 1D8DC: using guessed type int __fastcall sub_1D8DC(_DWORD, _DWORD);

//----- (0001DA28) --------------------------------------------------------
int return_zero()
{
  return 0;
}

//----- (0001DA30) --------------------------------------------------------
int __fastcall send_with_timeout(int socket_info, char *message, int message_length)
{
  int socket_fd; // r8
  int write_bit_index; // r9
  int fd_array_index; // r3
  int write_bit_mask; // r9
  int highest_fd_plus_one; // r8
  fd_set *current_tv; // r3
  int send_result; // r0
  ssize_t bytes_sent; // r0
  __int64 total_bytes_sent; // r4
  unsigned int previous_send_bytes_low; // r1
  unsigned int previous_send_bytes_high; // lr
  __int64 send_counter_incremented; // kr00_8
  unsigned int previous_total_bytes_low; // r2
  unsigned int previous_total_bytes_high; // r12
  int remaining_message_length; // [sp+Ch] [bp-844h]
  int bytes_sent_so_far; // [sp+10h] [bp-840h]
  int fd_set_index; // [sp+18h] [bp-838h]
  struct timeval send_timeout; // [sp+20h] [bp-830h] BYREF
  fd_set write_ready_fds; // [sp+28h] [bp-828h] BYREF

  socket_fd = *(_DWORD *)(socket_info + 588);
  if ( byte_70E20 && byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
  {
    snprintf((char *)&write_ready_fds, 2048u, "SEND: %s", message);
    log_event(7, (const char *)&write_ready_fds, 0);
  }
  remaining_message_length = message_length + 1;
  strcat(message, "\n");
  if ( message_length + 1 <= 0 )
  {
    total_bytes_sent = 0LL;
LABEL_17:
    send_result = 0;
    previous_send_bytes_low = *(_DWORD *)(socket_info + 504);
    previous_send_bytes_high = *(_DWORD *)(socket_info + 508);
    send_counter_incremented = *(_QWORD *)(socket_info + 496) + 1LL;
    *(_DWORD *)(socket_info + 496) = send_counter_incremented;
    previous_total_bytes_low = *(_DWORD *)(socket_info + 512);
    *(_DWORD *)(socket_info + 500) = HIDWORD(send_counter_incremented);
    previous_total_bytes_high = *(_DWORD *)(socket_info + 516);
    *(_QWORD *)(socket_info + 504) = __PAIR64__(previous_send_bytes_high, previous_send_bytes_low) + total_bytes_sent;
    *(_QWORD *)(socket_info + 512) = __PAIR64__(previous_total_bytes_high, previous_total_bytes_low) + total_bytes_sent;
  }
  else
  {
    LOBYTE(write_bit_index) = socket_fd & 0x1F;
    fd_array_index = socket_fd / 32;
    if ( socket_fd <= 0 )
      write_bit_index = -(-socket_fd & 0x1F);
    write_bit_mask = 1 << write_bit_index;
    highest_fd_plus_one = socket_fd + 1;
    fd_set_index = fd_array_index;
    bytes_sent_so_far = 0;
    do
    {
      while ( 1 )
      {
        send_timeout.tv_usec = 0;
        send_timeout.tv_sec = 1;
        while ( 1 )
        {
          current_tv = (fd_set *)&send_timeout.tv_usec;
          do
          {
            current_tv->__fds_bits[1] = 0;
            current_tv = (fd_set *)((char *)current_tv + 4);
          }
          while ( &write_ready_fds.__fds_bits[31] != (__fd_mask *)current_tv );
          write_ready_fds.__fds_bits[fd_set_index] |= write_bit_mask;
          if ( select(highest_fd_plus_one, 0, &write_ready_fds, 0, &send_timeout) > 0 )
            break;
          if ( *_errno_location() != 4 )
            return 1;
        }
        bytes_sent = send(*(_DWORD *)(socket_info + 588), &message[bytes_sent_so_far], remaining_message_length, 16384);
        if ( bytes_sent < 0 )
          break;
        bytes_sent_so_far += bytes_sent;
        remaining_message_length -= bytes_sent;
        if ( remaining_message_length <= 0 )
        {
          total_bytes_sent = bytes_sent_so_far;
          goto LABEL_17;
        }
      }
    }
    while ( *_errno_location() == 11 );
    return 2;
  }
  return send_result;
}
// 657B8: using guessed type int dword_657B8;
// 66640: using guessed type char byte_66640;
// 66641: using guessed type char byte_66641;
// 70CE8: using guessed type char byte_70CE8;
// 70E20: using guessed type char byte_70E20;

//----- (0001DC9C) --------------------------------------------------------
int __fastcall setup_proxy_connection(const char **proxy_info, int socket_fd, int use_http_1_0)
{
  const char *proxy_address; // r0
  size_t connect_request_length; // r0
  ssize_t recv_length; // r0
  int logging_enabled; // r3
  int cmp_result; // r7
  bool is_end_of_header; // zf
  int v12; // r4
  char connect_request; // [sp+10h] [bp-C20h] BYREF
  char prev_char1; // [sp+11h] [bp-C1Fh]
  char prev_char2; // [sp+12h] [bp-C1Eh]
  char prev_char3; // [sp+13h] [bp-C1Dh]
  char log_buffer[2048]; // [sp+410h] [bp-820h] BYREF

  proxy_address = proxy_info[150];
  if ( use_http_1_0 )
    snprintf(&connect_request, 1024u, "CONNECT %s:%s HTTP/1.0\r\n\r\n", proxy_address, proxy_info[146]);
  else
    snprintf(
      &connect_request,
      1024u,
      "CONNECT %s:%s HTTP/1.1\r\nHost: %s:%s\r\n\r\n",
      proxy_address,
      proxy_info[146],
      proxy_address,
      proxy_info[146]);
  if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
  {
    snprintf(log_buffer, 2048u, "Sending proxy %s:%s - %s", proxy_info[151], proxy_info[152], &connect_request);
    log_event(7, log_buffer, 0);
  }
  connect_request_length = strlen(&connect_request);
  send(socket_fd, &connect_request, connect_request_length, 0);
  recv_length = recv(socket_fd, &connect_request, 12u, 0);
  if ( recv_length > 0 )
  {
    logging_enabled = (unsigned __int8)byte_66641;
    *(&connect_request + recv_length) = 0;
    if ( logging_enabled && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
    {
      snprintf(log_buffer, 2048u, "Received from proxy %s:%s - %s", proxy_info[151], proxy_info[152], &connect_request);
      log_event(7, log_buffer, 0);
    }
    cmp_result = strcmp(&connect_request, "HTTP/1.1 200");
    if ( cmp_result && (cmp_result = strcmp(&connect_request, "HTTP/1.0 200")) != 0 )
    {
      if ( byte_70CE8 || byte_66640 || dword_657B8 > 3 )
      {
        snprintf(
          log_buffer,
          2048u,
          "HTTP Error from proxy %s:%s - %s",
          proxy_info[151],
          proxy_info[152],
          &connect_request);
        log_event(4, log_buffer, 0);
        return 0;
      }
    }
    else
    {
      while ( recv(socket_fd, log_buffer, 1u, 0) != -1 )
      {
        is_end_of_header = (unsigned __int8)log_buffer[0] == 255;
        *(&connect_request + cmp_result++) = log_buffer[0];
        if ( is_end_of_header )
          goto LABEL_27;
        if ( cmp_result == 4 )
        {
          while ( strncmp(&connect_request, "\r\n\r\n", 4u) )
          {
            connect_request = prev_char1;
            prev_char1 = prev_char2;
            prev_char2 = prev_char3;
            if ( recv(socket_fd, log_buffer, 1u, 0) == -1 )
            {
              prev_char3 = -1;
              goto LABEL_27;
            }
            prev_char3 = log_buffer[0];
            if ( (unsigned __int8)log_buffer[0] == 255 )
              goto LABEL_27;
          }
          v12 = (unsigned __int8)byte_66641;
          if ( !byte_66641 )
            return 1;
          if ( byte_70CE8 || byte_66640 || dword_657B8 > 6 )
          {
            snprintf(log_buffer, 2048u, "Success negotiating with %s:%s HTTP proxy", proxy_info[151], proxy_info[152]);
            log_event(7, log_buffer, 0);
          }
          return v12;
        }
      }
      *(&connect_request + cmp_result) = -1;
LABEL_27:
      if ( byte_70CE8 || byte_66640 || dword_657B8 > 3 )
      {
        v12 = 0;
        snprintf(log_buffer, 2048u, "Couldn't read HTTP byte from proxy %s:%s", proxy_info[151], proxy_info[152]);
        log_event(4, log_buffer, 0);
        return v12;
      }
    }
    return 0;
  }
  if ( !byte_70CE8 && !byte_66640 && dword_657B8 <= 3 )
    return 0;
  snprintf(log_buffer, 2048u, "Couldn't read from proxy %s:%s after sending CONNECT", proxy_info[151], proxy_info[152]);
  log_event(4, log_buffer, 0);
  return 0;
}
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 657B8: using guessed type int dword_657B8;
// 66640: using guessed type char byte_66640;
// 66641: using guessed type char byte_66641;
// 70CE8: using guessed type char byte_70CE8;

//----- (0001E150) --------------------------------------------------------
int __fastcall reset_network_state(int state_pointer)
{
  _BYTE *network_buffer_pointer; // r3
  int close_result; // r0

  network_buffer_pointer = *(_BYTE **)(state_pointer + 592);
  if ( network_buffer_pointer )
    *network_buffer_pointer = 0;
  close_result = *(_DWORD *)(state_pointer + 588);
  *(_BYTE *)(state_pointer + 643) = 0;
  *(_BYTE *)(state_pointer + 641) = 0;
  if ( close_result )
    close_result = close(close_result);
  *(_DWORD *)(state_pointer + 588) = 0;
  return close_result;
}

//----- (0001E190) --------------------------------------------------------
int __fastcall disable_non_block(int file_descriptor)
{
  unsigned int new_fd_flags; // r2

  new_fd_flags = fcntl(file_descriptor, 3, 0) & 0xFFFFF7FF;
  return fcntl(file_descriptor, 4, new_fd_flags);
}

//----- (0001E1B8) --------------------------------------------------------
bool __fastcall is_socket_ready(int socket_fd, int timeout_seconds)
{
  int positive_timeout; // r1
  fd_set *current_tv_usec_ptr; // r3
  int fd_bit_index; // r4
  struct timeval timeout_struct; // [sp+8h] [bp-90h] BYREF
  fd_set read_file_descriptors; // [sp+10h] [bp-88h] BYREF

  positive_timeout = timeout_seconds & ~(timeout_seconds >> 31);
  current_tv_usec_ptr = (fd_set *)&timeout_struct.tv_usec;
  do
  {
    current_tv_usec_ptr->__fds_bits[1] = 0;
    current_tv_usec_ptr = (fd_set *)((char *)current_tv_usec_ptr + 4);
  }
  while ( &read_file_descriptors.__fds_bits[31] != (__fd_mask *)current_tv_usec_ptr );
  timeout_struct.tv_usec = 0;
  timeout_struct.tv_sec = positive_timeout;
  LOBYTE(fd_bit_index) = socket_fd & 0x1F;
  if ( socket_fd <= 0 )
    fd_bit_index = -(-socket_fd & 0x1F);
  read_file_descriptors.__fds_bits[socket_fd / 32] |= 1 << fd_bit_index;
  return select(socket_fd + 1, &read_file_descriptors, 0, 0, &timeout_struct) > 0;
}

//----- (0001E24C) --------------------------------------------------------
int __fastcall check_status_and_get_info(_DWORD *status_ptr, unsigned int input_value)
{
  _DWORD *info_ptr; // r0

  if ( !status_ptr || *status_ptr != 1 )
    return 0;
  if ( get_next_structure_pointer(status_ptr) >= input_value )
  {
    info_ptr = (_DWORD *)get_task_by_index(status_ptr, input_value);
    if ( info_ptr )
    {
      if ( *info_ptr == 2 )
        return get_linked_item_or_null(info_ptr);
    }
  }
  return 0;
}
// 47658: using guessed type int __fastcall sub_47658(_DWORD);
// 47674: using guessed type int __fastcall sub_47674(_DWORD, _DWORD);
// 47820: using guessed type int __fastcall sub_47820(_DWORD);

//----- (0001E2B0) --------------------------------------------------------
char *__fastcall get_info_duplicate_if_not_null(_DWORD *status_source, unsigned int identifier)
{
  char *info_str; // r0

  info_str = (char *)check_status_and_get_info(status_source, identifier);
  if ( info_str )
    return _strdup(info_str);
  return info_str;
}

//----- (0001E2C8) --------------------------------------------------------
void __fastcall __noreturn log_semaphore_post_failure(
        const void *semaphore_address,
        const char *file_name,
        const char *function_name,
        int line_number)
{
  int *errno_location; // r0
  char log_message[2072]; // [sp+10h] [bp-818h] BYREF

  errno_location = _errno_location();
  snprintf(
    log_message,
    2048u,
    "Failed to sem_post errno=%d cgsem=0x%p in %s %s():%d",
    *errno_location,
    semaphore_address,
    file_name,
    function_name,
    line_number);
  log_event(3, log_message, 1);
  shutdown_miner_safely(1);
}
// 3AADC: using guessed type void __fastcall __noreturn sub_3AADC(_DWORD);

//----- (0001E324) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_1E324(int reg1, int reg2, int reg3, int reg4, int reg5, int reg6, int reg7, int reg8, int reg9)
{
  __asm { POP             {R4-R7,PC} }
}
// 1E32C: positive sp value 814 has been found
// 1E32C: unbalanced stack, ignored a potential tail call

//----- (0001E330) --------------------------------------------------------
int __fastcall validate_hex_string(const char *input_string, const char *function_name, int line_number)
{
  size_t input_length; // r0
  int current_char; // r3
  const char *iterator_pointer; // r2
  const char *end_pointer; // r0
  int next_char; // t1
  int validity_result; // r0
  char log_message[2064]; // [sp+10h] [bp-810h] BYREF

  if ( input_string )
  {
    input_length = strlen(input_string);
    if ( !input_length )
      return 1;
    current_char = *(unsigned __int8 *)input_string;
    if ( dword_4A880[current_char] >= 0 )
    {
      iterator_pointer = input_string;
      end_pointer = &input_string[input_length - 1];
      while ( iterator_pointer != end_pointer )
      {
        next_char = *(unsigned __int8 *)++iterator_pointer;
        current_char = next_char;
        if ( dword_4A880[next_char] < 0 )
          goto LABEL_8;
      }
      return 1;
    }
LABEL_8:
    if ( byte_70CE8 || (validity_result = (unsigned __int8)byte_66640, byte_66640) || dword_657B8 > 2 )
    {
      snprintf(
        log_message,
        2048u,
        "Invalid char 0x%x passed to valid_hex from in %s %s():%d",
        current_char,
        "util.c",
        function_name,
        line_number);
LABEL_12:
      log_event(3, log_message, 0);
      return 0;
    }
  }
  else if ( byte_70CE8 || (validity_result = (unsigned __int8)byte_66640, byte_66640) || dword_657B8 > 2 )
  {
    snprintf(
      log_message,
      2048u,
      "Null string passed to valid_hex from in %s %s():%d",
      "util.c",
      function_name,
      line_number);
    goto LABEL_12;
  }
  return validity_result;
}
// 4A880: using guessed type int dword_4A880[256];
// 657B8: using guessed type int dword_657B8;
// 66640: using guessed type char byte_66640;
// 70CE8: using guessed type char byte_70CE8;

//----- (0001E480) --------------------------------------------------------
int __fastcall write_lock_and_log_error(pthread_rwlock_t *rwlock, const char *function_name, int line_number)
{
  int lock_result; // r0
  int *errno_ptr; // r0
  char error_message[2064]; // [sp+10h] [bp-810h] BYREF

  lock_result = pthread_rwlock_wrlock(rwlock);
  if ( lock_result )
  {
    errno_ptr = _errno_location();
    snprintf(
      error_message,
      2048u,
      "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *errno_ptr,
      "util.c",
      function_name,
      line_number);
    log_event(3, error_message, 1);
    shutdown_miner_safely(1);
  }
  return lock_result;
}
// 3AADC: using guessed type void __fastcall __noreturn sub_3AADC(_DWORD);

//----- (0001E4F0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_1E4F0(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R4,R5,PC} }
}
// 1E4F8: positive sp value 814 has been found
// 1E4F8: unbalanced stack, ignored a potential tail call

//----- (0001E4FC) --------------------------------------------------------
int __fastcall unlock_rwlock_log_error(pthread_rwlock_t *rwlock_ptr, const char *function_name, int line_number)
{
  int unlock_result; // r0
  int *errno_ptr; // r0
  char error_message[2064]; // [sp+10h] [bp-810h] BYREF

  unlock_result = pthread_rwlock_unlock(rwlock_ptr);
  if ( unlock_result )
  {
    errno_ptr = _errno_location();
    snprintf(
      error_message,
      2048u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *errno_ptr,
      "util.c",
      function_name,
      line_number);
    log_event(3, error_message, 1);
    shutdown_miner_safely(1);
  }
  return unlock_result;
}
// 3AADC: using guessed type void __fastcall __noreturn sub_3AADC(_DWORD);

//----- (0001E56C) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_1E56C(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R4,R5,PC} }
}
// 1E574: positive sp value 814 has been found
// 1E574: unbalanced stack, ignored a potential tail call

//----- (0001E578) --------------------------------------------------------
int __fastcall unlock_mutex_and_log_error(pthread_mutex_t *mutex, const char *function_name, int line_number)
{
  int unlock_result; // r0
  int *err_num_ptr; // r0
  char log_msg[2064]; // [sp+10h] [bp-810h] BYREF

  unlock_result = pthread_mutex_unlock(mutex);
  if ( unlock_result )
  {
    err_num_ptr = _errno_location();
    snprintf(
      log_msg,
      2048u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *err_num_ptr,
      "util.c",
      function_name,
      line_number);
    log_event(3, log_msg, 1);
    shutdown_miner_safely(1);
  }
  return unlock_result;
}
// 3AADC: using guessed type void __fastcall __noreturn sub_3AADC(_DWORD);

//----- (0001E5E8) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall restore_context_and_return(
        int parameter_1,
        int parameter_2,
        int parameter_3,
        int parameter_4,
        int parameter_5,
        int parameter_6,
        int parameter_7)
{
  __asm { POP             {R4,R5,PC} }
}
// 1E5F0: positive sp value 814 has been found
// 1E5F0: unbalanced stack, ignored a potential tail call

//----- (0001E5F4) --------------------------------------------------------
void __fastcall __noreturn log_mutex_error_and_terminate(const char *function_name, int line_number)
{
  int *errno_ptr; // r0
  char error_message[2064]; // [sp+10h] [bp-810h] BYREF

  errno_ptr = _errno_location();
  snprintf(
    error_message,
    2048u,
    "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
    *errno_ptr,
    "util.c",
    function_name,
    line_number);
  log_event(3, error_message, 1);
  shutdown_miner_safely(1);
}
// 3AADC: using guessed type void __fastcall __noreturn sub_3AADC(_DWORD);

//----- (0001E64C) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_1E64C(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R4,R5,PC} }
}
// 1E654: positive sp value 814 has been found
// 1E654: unbalanced stack, ignored a potential tail call

//----- (0001E658) --------------------------------------------------------
int __fastcall sub_1E658(int a1)
{
  pthread_mutex_t *v1; // r5
  int v3; // r0
  int result; // r0
  _BYTE *v5; // r3

  v1 = (pthread_mutex_t *)(a1 + 704);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 704)) )
    log_mutex_error_and_terminate("clear_sock", 1788);
  while ( *(_DWORD *)(a1 + 588) && recv(*(_DWORD *)(a1 + 588), *(void **)(a1 + 592), 8188u, 0) > 0 )
    ;
  v3 = unlock_mutex_and_log_error(v1, "clear_sock", 1797);
  result = off_658DC(v3);
  v5 = *(_BYTE **)(a1 + 592);
  if ( v5 )
    *v5 = 0;
  return result;
}
// 1DA28: using guessed type int sub_1DA28(void);
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);

//----- (0001E6E8) --------------------------------------------------------
int __fastcall update_task_state(int task_descriptor, char new_state)
{
  pthread_mutex_t *mutex_ptr; // r5
  int unlock_result; // r0

  mutex_ptr = (pthread_mutex_t *)(task_descriptor + 12);
  if ( pthread_mutex_lock((pthread_mutex_t *)(task_descriptor + 12)) )
    log_mutex_error_and_terminate("tq_freezethaw", 1106);
  *(_BYTE *)(task_descriptor + 8) = new_state;
  pthread_cond_signal((pthread_cond_t *)(task_descriptor + 40));
  unlock_result = unlock_mutex_and_log_error(mutex_ptr, "tq_freezethaw", 1109);
  return off_658DC(unlock_result);
}
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);

//----- (0001E74C) --------------------------------------------------------
void *__fastcall safe_malloc_with_logging(
        size_t requested_size,
        const char *function_name,
        const char *file_name,
        int line_number)
{
  size_t aligned_size; // r4
  void *allocated_memory; // r0
  char log_message[2072]; // [sp+10h] [bp-818h] BYREF

  aligned_size = requested_size;
  if ( (requested_size & 3) != 0 )
    aligned_size = (requested_size & 0xFFFFFFFC) + 4;
  allocated_memory = malloc(aligned_size);
  if ( !allocated_memory )
  {
    snprintf(
      log_message,
      2048u,
      "Failed to malloc size %d from %s %s:%d",
      aligned_size,
      function_name,
      file_name,
      line_number);
    log_event(3, log_message, 1);
    shutdown_miner_safely(1);
  }
  return allocated_memory;
}
// 3AADC: using guessed type void __fastcall __noreturn sub_3AADC(_DWORD);

//----- (0001E7C8) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_1E7C8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10)
{
  __asm { POP             {R4-R8,PC} }
}
// 1E7D0: positive sp value 810 has been found
// 1E7D0: unbalanced stack, ignored a potential tail call

//----- (0001E7D4) --------------------------------------------------------
void *__fastcall allocate_and_log_on_fail(
        size_t num_members,
        size_t member_size,
        const char *file_name,
        const char *function_name,
        int line_number)
{
  size_t aligned_size; // r4
  void *allocated_memory; // r0
  char log_message[2072]; // [sp+10h] [bp-818h] BYREF

  aligned_size = member_size;
  if ( (member_size & 3) != 0 )
    aligned_size = (member_size & 0xFFFFFFFC) + 4;
  allocated_memory = calloc(num_members, aligned_size);
  if ( !allocated_memory )
  {
    snprintf(
      log_message,
      2048u,
      "Failed to calloc memb %d size %d from %s %s:%d",
      num_members,
      aligned_size,
      file_name,
      function_name,
      line_number);
    log_event(3, log_message, 1);
    shutdown_miner_safely(1);
  }
  return allocated_memory;
}
// 3AADC: using guessed type void __fastcall __noreturn sub_3AADC(_DWORD);

//----- (0001E858) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_1E858(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10)
{
  __asm { POP             {R4-R8,PC} }
}
// 1E860: positive sp value 810 has been found
// 1E860: unbalanced stack, ignored a potential tail call

//----- (0001E864) --------------------------------------------------------
void *__fastcall realloc_with_logging(
        void *current_ptr,
        size_t original_size,
        const char *function_name,
        const char *file_name,
        int line_number)
{
  size_t aligned_size; // r4
  void *new_ptr; // r0
  char error_message[2072]; // [sp+10h] [bp-818h] BYREF

  aligned_size = original_size;
  if ( (original_size & 3) != 0 )
    aligned_size = (original_size & 0xFFFFFFFC) + 4;
  new_ptr = realloc(current_ptr, aligned_size);
  if ( !new_ptr )
  {
    snprintf(
      error_message,
      2048u,
      "Failed to realloc size %d from %s %s:%d",
      aligned_size,
      function_name,
      file_name,
      line_number);
    log_event(3, error_message, 1);
    shutdown_miner_safely(1);
  }
  return new_ptr;
}
// 3AADC: using guessed type void __fastcall __noreturn sub_3AADC(_DWORD);

//----- (0001E8E8) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_1E8E8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  __asm { POP             {R4-R7,PC} }
}
// 1E8F4: positive sp value 814 has been found
// 1E8F4: unbalanced stack, ignored a potential tail call

//----- (0001E8F8) --------------------------------------------------------
char *__fastcall get_protocol_type(char *protocol_code)
{
  char **protocol_table; // r3
  char *protocol_name; // r0

  if ( !protocol_code )
    return "http:";
  protocol_table = &off_4AC9C;
  protocol_name = "http0:";
  while ( 1 )
  {
    protocol_table += 2;
    if ( protocol_table[1] == protocol_code )
      break;
    protocol_name = protocol_table[2];
    if ( !protocol_name )
      return "invalid";
  }
  return protocol_name;
}
// 4AC9C: using guessed type char *off_4AC9C;

//----- (0001E944) --------------------------------------------------------
_BYTE *__fastcall convert_bytes_to_hexstring(_BYTE *hexstring, int bytes, int length)
{
  int end_position; // r4
  _BYTE *current_byte_ptr; // r1
  _BYTE *hexstring_ptr; // r12
  unsigned int current_byte; // t1

  if ( length <= 0 )
  {
    *hexstring = 0;
  }
  else
  {
    end_position = bytes + length - 1;
    current_byte_ptr = (_BYTE *)(bytes - 1);
    hexstring_ptr = hexstring + 2;
    do
    {
      current_byte = (unsigned __int8)*++current_byte_ptr;
      hexstring_ptr += 2;
      *(hexstring_ptr - 4) = *((_BYTE *)&dword_4A880[277] + (current_byte >> 4));
      *(hexstring_ptr - 3) = *((_BYTE *)&dword_4A880[277] + (*current_byte_ptr & 0xF));
    }
    while ( current_byte_ptr != (_BYTE *)end_position );
    hexstring += 2 * length;
    *hexstring = 0;
  }
  return hexstring;
}
// 4A880: using guessed type int dword_4A880[256];

//----- (0001E9B4) --------------------------------------------------------
_BYTE *__fastcall binary_to_hex_string(int binary_data, int binary_length)
{
  int hex_str_length; // r5
  int adjusted_length; // r0
  int padding; // r12
  _BYTE *hex_str; // r0
  _BYTE *end_of_string; // r5
  _BYTE *data_ptr; // r2
  _BYTE *hex_ptr; // r12
  unsigned int current_byte; // t1

  hex_str_length = 2 * binary_length;
  adjusted_length = 2 * binary_length + 1;
  padding = adjusted_length & 3;
  if ( adjusted_length <= 0 )
    padding = -(-adjusted_length & 3);
  hex_str = allocate_and_log_on_fail(4 - padding + adjusted_length, 1u, "util.c", "bin2hex", 787);
  if ( binary_length > 0 )
  {
    data_ptr = (_BYTE *)(binary_data - 1);
    hex_ptr = hex_str + 2;
    do
    {
      current_byte = (unsigned __int8)*++data_ptr;
      hex_ptr += 2;
      *(hex_ptr - 4) = *((_BYTE *)&dword_4A880[277] + (current_byte >> 4));
      *(hex_ptr - 3) = *((_BYTE *)&dword_4A880[277] + (*data_ptr & 0xF));
    }
    while ( data_ptr != (_BYTE *)(binary_data - 1 + binary_length) );
    end_of_string = &hex_str[hex_str_length];
  }
  else
  {
    end_of_string = hex_str;
  }
  *end_of_string = 0;
  return hex_str;
}
// 4A880: using guessed type int dword_4A880[256];

//----- (0001EA68) --------------------------------------------------------
unsigned int __fastcall hex_string_to_binary(_BYTE *binary_out, unsigned __int8 *hex_in, int length)
{
  unsigned int nibble_1_value; // r3
  unsigned int nibble_0_value; // r12
  unsigned int is_nibble_high; // r0
  unsigned __int8 *current_hex_ptr; // r1
  int current_char_1; // r3
  int current_char_0; // r4
  char error_message[2064]; // [sp+0h] [bp-810h] BYREF

  if ( !*hex_in )
    return !length;
  if ( !length )
    return 0;
  if ( !hex_in[1] )
  {
LABEL_16:
    if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
    {
      strcpy(error_message, "hex2bin str truncated");
      log_event(3, error_message, 0);
    }
    return 0;
  }
  nibble_1_value = dword_4A880[hex_in[1]];
  nibble_0_value = dword_4A880[*hex_in];
  is_nibble_high = (nibble_1_value >> 31) | (nibble_0_value >> 31);
  if ( !is_nibble_high )
  {
    current_hex_ptr = hex_in + 4;
    do
    {
      --length;
      *binary_out++ = nibble_1_value | (16 * nibble_0_value);
      current_char_1 = *(current_hex_ptr - 2);
      if ( !*(current_hex_ptr - 2) )
        return !length;
      if ( !length )
        return is_nibble_high;
      current_char_0 = *(current_hex_ptr - 1);
      current_hex_ptr += 2;
      if ( !current_char_0 )
        goto LABEL_16;
      nibble_0_value = dword_4A880[current_char_1];
      nibble_1_value = dword_4A880[current_char_0];
    }
    while ( ((nibble_0_value | nibble_1_value) & 2147483648) == 0 );
  }
  if ( !byte_70CE8 && !byte_66640 && dword_657B8 <= 2 )
    return 0;
  strcpy(error_message, "hex2bin scan failed");
  log_event(3, error_message, 0);
  return 0;
}
// 4A880: using guessed type int dword_4A880[256];
// 657B8: using guessed type int dword_657B8;
// 66640: using guessed type char byte_66640;
// 70CE8: using guessed type char byte_70CE8;

//----- (0001EC0C) --------------------------------------------------------
size_t __fastcall sub_1EC0C(_BYTE *output_buffer, char *input_string)
{
  size_t hash_value; // r0
  char prefix_value; // r1
  char *current_char_ptr; // r7
  int accumulator; // r12
  char *end_ptr; // r6
  int current_char; // t1
  int *temp_ptr; // r2
  int intermediate_value; // r3
  _DWORD *output_ptr; // r3
  int *hash_array_ptr; // r2
  _BYTE *output_end_ptr; // r5
  unsigned int hash_value_part; // t1
  int temp_value_storage; // [sp+0h] [bp-38h] BYREF
  int prefix_storage; // [sp+4h] [bp-34h]
  int hash_array[5]; // [sp+8h] [bp-30h] BYREF
  int temp_result; // [sp+1Ch] [bp-1Ch] BYREF

  memset(hash_array, 0, sizeof(hash_array));
  prefix_storage = 0;
  temp_result = 0;
  hash_value = strlen(input_string);
  if ( hash_value )
  {
    current_char_ptr = input_string - 1;
    accumulator = 0;
    end_ptr = &current_char_ptr[hash_value];
    while ( 1 )
    {
      current_char = (unsigned __int8)*++current_char_ptr;
      temp_ptr = &temp_result;
      intermediate_value = dword_4A880[current_char + 283];
      while ( 1 )
      {
        *temp_ptr-- = 58 * accumulator + intermediate_value;
        intermediate_value = (58LL * (unsigned int)accumulator + (unsigned __int64)(unsigned int)intermediate_value) >> 32;
        if ( &temp_value_storage == temp_ptr )
          break;
        accumulator = *temp_ptr;
      }
      if ( end_ptr == current_char_ptr )
        break;
      accumulator = temp_result;
    }
    prefix_value = prefix_storage;
    hash_value = bswap32(hash_array[0]);
  }
  else
  {
    prefix_value = 0;
  }
  output_ptr = output_buffer + 1;
  hash_array_ptr = hash_array;
  *output_buffer = prefix_value;
  output_end_ptr = output_buffer + 25;
  while ( 1 )
  {
    *output_ptr++ = hash_value;
    if ( output_ptr == (_DWORD *)output_end_ptr )
      break;
    hash_value_part = hash_array_ptr[1];
    ++hash_array_ptr;
    hash_value = bswap32(hash_value_part);
  }
  return hash_value;
}
// 4A880: using guessed type int dword_4A880[256];

//----- (0001ECE4) --------------------------------------------------------
int __fastcall calculate_result_and_status(int output_params_ptr, int input_value)
{
  char status_code; // r2
  int result_value; // r0
  int upper_bound; // r2

  if ( input_value > 127 )
  {
    LOWORD(upper_bound) = 16511;
    if ( input_value > 16511 )
    {
      HIWORD(upper_bound) = 32;
      if ( input_value <= upper_bound )
        result_value = 4;
      else
        result_value = 5;
      if ( input_value <= upper_bound )
        status_code = 3;
      else
        status_code = 4;
    }
    else
    {
      result_value = 3;
      status_code = 2;
    }
  }
  else
  {
    status_code = 1;
    result_value = 2;
  }
  *(_DWORD *)(output_params_ptr + 1) = input_value;
  *(_BYTE *)output_params_ptr = status_code;
  return result_value;
}

//----- (0001ED30) --------------------------------------------------------
int __fastcall compare_hashes_and_log(unsigned int *hash1, unsigned int *hash2)
{
  unsigned int *hash1_ptr; // r3
  unsigned int *hash2_ptr; // r2
  unsigned int hash1_val; // lr
  unsigned int tmp1; // t1
  unsigned int tmp2; // t1
  bool is_greater_or_equal; // cf
  int is_hash1_smaller_or_equal; // r5
  unsigned int hash1_7; // r7
  unsigned int hash1_5; // lr
  unsigned int hash1_4; // r12
  unsigned int hash1_2; // r6
  unsigned int hash1_3; // r7
  unsigned int hash1_0; // r12
  unsigned int hash1_1; // lr
  unsigned int hash2_7; // r3
  unsigned int hash2_6; // lr
  unsigned int hash2_4; // r3
  unsigned int hash2_3; // r6
  unsigned int hash2_5_bswap; // r12
  unsigned int hash2_2; // lr
  unsigned int hash2_0; // r3
  unsigned int hash2_1; // r12
  char *hash1_str; // r7
  const char *hash2_tmp_str; // r0
  char *hash2_str; // r6
  const char *target_value_msg; // r3
  int bswap_hash1[8]; // [sp+8h] [bp-858h] BYREF
  int bswap_hash2[8]; // [sp+28h] [bp-838h] BYREF
  char log_msg[2072]; // [sp+48h] [bp-818h] BYREF

  hash1_ptr = hash1 + 8;
  hash2_ptr = hash2 + 8;
  while ( 1 )
  {
    tmp1 = *--hash1_ptr;
    hash1_val = tmp1;
    tmp2 = *--hash2_ptr;
    is_greater_or_equal = hash1_val >= tmp2;
    if ( hash1_val > tmp2 )
      break;
    if ( !is_greater_or_equal || hash1 == hash1_ptr )
    {
      is_hash1_smaller_or_equal = 1;
      goto LABEL_7;
    }
  }
  is_hash1_smaller_or_equal = 0;
LABEL_7:
  if ( !byte_66641 )
    return is_hash1_smaller_or_equal;
  hash1_7 = hash1[7];
  hash1_5 = hash1[5];
  hash1_4 = hash1[4];
  bswap_hash1[1] = bswap32(hash1[6]);
  hash1_2 = hash1[2];
  bswap_hash1[0] = bswap32(hash1_7);
  bswap_hash1[2] = bswap32(hash1_5);
  hash1_3 = hash1[3];
  bswap_hash1[3] = bswap32(hash1_4);
  hash1_0 = *hash1;
  hash1_1 = hash1[1];
  bswap_hash1[5] = bswap32(hash1_2);
  hash2_7 = hash2[7];
  bswap_hash1[6] = bswap32(hash1_1);
  hash2_6 = hash2[6];
  bswap_hash1[7] = bswap32(hash1_0);
  bswap_hash2[0] = bswap32(hash2_7);
  hash2_4 = hash2[4];
  hash2_3 = hash2[3];
  hash2_5_bswap = bswap32(hash2[5]);
  bswap_hash2[1] = bswap32(hash2_6);
  hash2_2 = hash2[2];
  bswap_hash2[2] = hash2_5_bswap;
  bswap_hash2[3] = bswap32(hash2_4);
  hash2_0 = *hash2;
  hash2_1 = hash2[1];
  bswap_hash1[4] = bswap32(hash1_3);
  bswap_hash2[4] = bswap32(hash2_3);
  bswap_hash2[6] = bswap32(hash2_1);
  bswap_hash2[7] = bswap32(hash2_0);
  bswap_hash2[5] = bswap32(hash2_2);
  hash1_str = (char *)binary_to_hex_string(bswap_hash1, 32);
  hash2_tmp_str = (const char *)binary_to_hex_string(bswap_hash2, 32);
  hash2_str = (char *)hash2_tmp_str;
  if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
  {
    target_value_msg = "YES (hash <= target)";
    if ( !is_hash1_smaller_or_equal )
      target_value_msg = "no (false positive; hash > target)";
    snprintf(log_msg, 2048u, " Proof: %s\nTarget: %s\nTrgVal? %s", hash1_str, hash2_tmp_str, target_value_msg);
    log_event(7, log_msg, 0);
  }
  free(hash1_str);
  free(hash2_str);
  return is_hash1_smaller_or_equal;
}
// 1E9B4: using guessed type int __fastcall sub_1E9B4(_DWORD, _DWORD);
// 657B8: using guessed type int dword_657B8;
// 66640: using guessed type char byte_66640;
// 66641: using guessed type char byte_66641;
// 70CE8: using guessed type char byte_70CE8;

//----- (0001EF20) --------------------------------------------------------
char *initialize_task_queue()
{
  char *task_queue; // r4

  task_queue = (char *)allocate_and_log_on_fail(1u, 88u, "util.c", "tq_new", 1075);
  *(_DWORD *)task_queue = task_queue;
  *((_DWORD *)task_queue + 1) = task_queue;
  pthread_mutex_init((pthread_mutex_t *)(task_queue + 12), 0);
  pthread_cond_init((pthread_cond_t *)(task_queue + 40), 0);
  return task_queue;
}

//----- (0001EF7C) --------------------------------------------------------
void __fastcall free_linked_list(char *list_head)
{
  int next_node_data; // r2
  _DWORD *current_node; // r0
  _DWORD *next_node; // r4
  _DWORD *next_node_next; // r3
  bool is_last_node; // zf

  if ( list_head )
  {
    next_node_data = **(_DWORD **)list_head;
    current_node = (_DWORD *)(*(_DWORD *)list_head - 4);
    next_node = (_DWORD *)(next_node_data - 4);
    if ( list_head != *(char **)list_head )
    {
      do
      {
        next_node_next = (_DWORD *)current_node[2];
        *(_DWORD *)(next_node_data + 4) = next_node_next;
        *next_node_next = next_node_data;
        free(current_node);
        current_node = next_node;
        next_node_data = next_node[1];
        is_last_node = next_node + 1 == (_DWORD *)list_head;
        next_node = (_DWORD *)(next_node_data - 4);
      }
      while ( !is_last_node );
    }
    pthread_cond_destroy((pthread_cond_t *)(list_head + 40));
    pthread_mutex_destroy((pthread_mutex_t *)(list_head + 12));
    free(list_head);
  }
}

//----- (0001EFE4) --------------------------------------------------------
int __fastcall update_task_state_to_running(int task_id)
{
  return update_task_state(task_id, 1);
}

//----- (0001EFEC) --------------------------------------------------------
int __fastcall disable_task(int task_id)
{
  return update_task_state(task_id, 0);
}

//----- (0001EFF4) --------------------------------------------------------
int __fastcall queue_push(int queue, int value)
{
  int *new_node; // r6
  _DWORD *next_node_ptr; // r4
  _DWORD *tail_node_ptr; // r3
  int push_result; // r8
  int unlock_result; // r0

  new_node = (int *)allocate_and_log_on_fail(1, 12, "util.c", "tq_push", 1127);
  *new_node = value;
  next_node_ptr = new_node + 1;
  new_node[1] = (int)(new_node + 1);
  new_node[2] = (int)(new_node + 1);
  if ( pthread_mutex_lock((pthread_mutex_t *)(queue + 12)) )
    log_mutex_error_and_terminate("tq_push", 1131);
  if ( *(_BYTE *)(queue + 8) )
  {
    push_result = 0;
    free(new_node);
  }
  else
  {
    tail_node_ptr = *(_DWORD **)(queue + 4);
    push_result = 1;
    *(_DWORD *)(queue + 4) = next_node_ptr;
    new_node[1] = queue;
    new_node[2] = (int)tail_node_ptr;
    *tail_node_ptr = next_node_ptr;
  }
  pthread_cond_signal((pthread_cond_t *)(queue + 40));
  unlock_result = unlock_mutex_and_log_error((pthread_mutex_t *)(queue + 12), "tq_push", 1144);
  off_658DC(unlock_result);
  return push_result;
}
// 1DA28: using guessed type int sub_1DA28(void);
// 1E7D4: using guessed type int __fastcall sub_1E7D4(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);

//----- (0001F0C8) --------------------------------------------------------
int __fastcall pop_task_from_queue(int queue, const struct timespec *timeout)
{
  pthread_mutex_t *queue_mutex; // r6
  int *current_task_ptr; // r4
  _DWORD *next_task; // r2
  int prev_task_addr; // r1
  int task_data; // r5
  int unlock_result; // r0
  pthread_cond_t *condition_var; // r0
  int cond_wait_result; // r0

  queue_mutex = (pthread_mutex_t *)(queue + 12);
  if ( pthread_mutex_lock((pthread_mutex_t *)(queue + 12)) )
    log_mutex_error_and_terminate("tq_pop", 1156);
  current_task_ptr = *(int **)queue;
  if ( queue == *(_DWORD *)queue )
  {
    condition_var = (pthread_cond_t *)(queue + 40);
    if ( timeout )
      cond_wait_result = pthread_cond_timedwait(condition_var, queue_mutex, timeout);
    else
      cond_wait_result = pthread_cond_wait(condition_var, queue_mutex);
    if ( cond_wait_result )
    {
      task_data = 0;
      goto LABEL_4;
    }
    if ( current_task_ptr == *(int **)queue )
    {
      task_data = 0;
      goto LABEL_4;
    }
    current_task_ptr = *(int **)queue;
  }
  next_task = (_DWORD *)current_task_ptr[1];
  prev_task_addr = *current_task_ptr;
  task_data = *(current_task_ptr - 1);
  *(_DWORD *)(prev_task_addr + 4) = next_task;
  *next_task = prev_task_addr;
  *current_task_ptr = 0;
  current_task_ptr[1] = 0;
  free(current_task_ptr - 1);
LABEL_4:
  unlock_result = unlock_mutex_and_log_error(queue_mutex, "tq_pop", 1182);
  off_658DC(unlock_result);
  return task_data;
}
// 1DA28: using guessed type int sub_1DA28(void);
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);

//----- (0001F1A8) --------------------------------------------------------
int __fastcall cancel_and_destroy_thread(int thread_info)
{
  int local_thread_info; // r4
  pthread_t thread_id; // r0
  sem_t *semaphore_ptr; // r0

  local_thread_info = thread_info;
  if ( thread_info )
  {
    thread_id = *(_DWORD *)(thread_info + 12);
    if ( thread_id )
    {
      pthread_cancel(thread_id);
      semaphore_ptr = (sem_t *)(local_thread_info + 16);
      *(_DWORD *)(local_thread_info + 12) = 0;
    }
    else
    {
      semaphore_ptr = (sem_t *)(local_thread_info + 16);
    }
    return sem_destroy(semaphore_ptr);
  }
  return thread_info;
}

//----- (0001F1E4) --------------------------------------------------------
_DWORD *__fastcall subtract_timevals(_DWORD *current_time, int *time_difference)
{
  int previous_usec; // r12
  int temp_seconds; // r2
  int temp_microseconds; // r3
  __int64 adjusted_time; // r2

  previous_usec = time_difference[1];
  temp_seconds = *current_time - *time_difference;
  *time_difference = temp_seconds;
  temp_microseconds = current_time[1] - previous_usec;
  time_difference[1] = temp_microseconds;
  if ( temp_microseconds < 0 )
  {
    LODWORD(adjusted_time) = temp_seconds - 1;
    HIDWORD(adjusted_time) = temp_microseconds + 1000000;
    *(_QWORD *)time_difference = adjusted_time;
  }
  return current_time;
}

//----- (0001F218) --------------------------------------------------------
_DWORD *__fastcall add_time_values(_DWORD *current_time, int *time_to_add)
{
  int time_to_add_seconds; // lr
  int total_microseconds; // r2
  int total_seconds; // r3
  __int64 adjusted_time; // r2

  time_to_add_seconds = time_to_add[1];
  total_microseconds = *current_time + *time_to_add;
  *time_to_add = total_microseconds;
  total_seconds = current_time[1] + time_to_add_seconds;
  time_to_add[1] = total_seconds;
  if ( total_seconds > 999999 )
  {
    LODWORD(adjusted_time) = total_microseconds + 1;
    HIDWORD(adjusted_time) = total_seconds - 1000000;
    *(_QWORD *)time_to_add = adjusted_time;
  }
  return current_time;
}

//----- (0001F25C) --------------------------------------------------------
bool __fastcall compare_priority(_DWORD *task1_params, _DWORD *task2_params)
{
  if ( *task1_params == *task2_params )
    return task1_params[1] > task2_params[1];
  else
    return *task1_params > *task2_params;
}

//----- (0001F290) --------------------------------------------------------
bool __fastcall compare_task_priorities(_DWORD *task1_priority_details, _DWORD *task2_priority_details)
{
  if ( *task1_priority_details == *task2_priority_details )
    return task1_priority_details[1] < task2_priority_details[1];
  else
    return *task1_priority_details < *task2_priority_details;
}

//----- (0001F2C4) --------------------------------------------------------
_DWORD *__fastcall convert_raw_to_readable(_DWORD *readable_data, _DWORD *raw_data)
{
  *readable_data = *raw_data;
  readable_data[1] = raw_data[1] / 1000;
  return readable_data;
}

//----- (0001F2F4) --------------------------------------------------------
_DWORD *__fastcall convert_hashrate_units(_DWORD *converted_hashrate, _DWORD *original_hashrate)
{
  *converted_hashrate = *original_hashrate;
  converted_hashrate[1] = 1000 * original_hashrate[1];
  return converted_hashrate;
}

//----- (0001F310) --------------------------------------------------------
int __fastcall calculate_division(_QWORD *result_pair)
{
  int operation_result; // r0
  int division_result[8]; // [sp+8h] [bp-20h] BYREF

  operation_result = lldiv(division_result);
  *result_pair = __PAIR64__(division_result[2], division_result[0]);
  return operation_result;
}
// 12234: using guessed type int __fastcall lldiv(_DWORD);

//----- (0001F348) --------------------------------------------------------
int __fastcall calculate_time_period(_QWORD *time_period_output)
{
  int operation_status; // r0
  __int64 calculated_time; // r2
  int time_components[8]; // [sp+8h] [bp-20h] BYREF

  operation_status = lldiv(time_components);
  LODWORD(calculated_time) = time_components[0];
  HIDWORD(calculated_time) = 1000 * time_components[2];
  *time_period_output = calculated_time;
  return operation_status;
}
// 12234: using guessed type int __fastcall lldiv(_DWORD);

//----- (0001F388) --------------------------------------------------------
int __fastcall calculate_hashrate(_QWORD *hashrate_output)
{
  int operation_result; // r0
  __int64 hashrate_value; // r2
  int div_result[8]; // [sp+8h] [bp-20h] BYREF

  operation_result = lldiv(div_result);
  LODWORD(hashrate_value) = div_result[0];
  HIDWORD(hashrate_value) = 1000000 * div_result[2];
  *hashrate_output = hashrate_value;
  return operation_result;
}
// 12234: using guessed type int __fastcall lldiv(_DWORD);

//----- (0001F3C8) --------------------------------------------------------
int __fastcall calculate_division_result(_QWORD *result_in_seconds)
{
  int division_result; // r0
  __int64 total_microseconds; // r2
  int divisor_data[8]; // [sp+8h] [bp-20h] BYREF

  division_result = lldiv(divisor_data);
  LODWORD(total_microseconds) = divisor_data[0];
  HIDWORD(total_microseconds) = 1000 * divisor_data[2];
  *result_in_seconds = total_microseconds;
  return division_result;
}
// 12234: using guessed type int __fastcall lldiv(_DWORD);

//----- (0001F404) --------------------------------------------------------
_DWORD *__fastcall add_large_integers(_DWORD *result, _DWORD *operand)
{
  int result_high; // r3
  __int64 combined_value; // r2
  int adjusted_low; // lr
  int adjusted_high; // r1

  result_high = result[1];
  LODWORD(combined_value) = *result + *operand;
  *result = combined_value;
  HIDWORD(combined_value) = result_high + operand[1];
  result[1] = HIDWORD(combined_value);
  if ( SHIDWORD(combined_value) <= 999999999 )
  {
    if ( combined_value < 0 )
    {
      do
      {
        HIDWORD(combined_value) += 1000000000;
        LODWORD(combined_value) = combined_value - 1;
      }
      while ( combined_value < 0 );
      *(_QWORD *)result = combined_value;
    }
  }
  else
  {
    adjusted_low = combined_value + 1;
    adjusted_high = HIDWORD(combined_value) - 1000000000;
    if ( HIDWORD(combined_value) - 1000000000 > 999999999 )
    {
      adjusted_high = -2000000000;
      adjusted_low = combined_value + 2;
    }
    *result = adjusted_low;
    if ( HIDWORD(combined_value) - 1000000000 > 999999999 )
      adjusted_high += HIDWORD(combined_value);
    result[1] = adjusted_high;
  }
  return result;
}

//----- (0001F57C) --------------------------------------------------------
const char *__fastcall get_token_before_delimiter(const char **string_ptr, const char *delimiters)
{
  const char *initial_str; // r4
  char *delimiter_position; // r0
  const char *token; // r0

  initial_str = *string_ptr;
  if ( *string_ptr && (delimiter_position = strpbrk(*string_ptr, delimiters)) != 0 )
  {
    *delimiter_position = 0;
    *string_ptr = delimiter_position + 1;
    return initial_str;
  }
  else
  {
    token = initial_str;
    *string_ptr = 0;
  }
  return token;
}

//----- (0001F5C4) --------------------------------------------------------
__int64 __fastcall get_hardware_timestamp(__time_t *timestamp_output)
{
  __int64 scaled_nsec; // r0
  int nsec_high_bit; // r3
  struct timespec current_time; // [sp+0h] [bp-10h] BYREF

  clock_gettime(1, &current_time);
  scaled_nsec = 274877907LL * current_time.tv_nsec;
  nsec_high_bit = current_time.tv_nsec >> 31;
  *timestamp_output = current_time.tv_sec;
  timestamp_output[1] = (SHIDWORD(scaled_nsec) >> 6) - nsec_high_bit;
  return scaled_nsec;
}

//----- (0001F608) --------------------------------------------------------
int __fastcall calculate_total_hashrate(_DWORD *hashrate_values)
{
  return hashrate_values[1] / 1000000 + 1000 * *hashrate_values;
}

//----- (0001F638) --------------------------------------------------------
int __fastcall subtract_large_numbers(_DWORD *num1, _DWORD *num2, int *result_num)
{
  int intermediate_diff; // r3
  int adjustment_value; // r1
  int final_diff; // r0

  intermediate_diff = *num1 - *num2;
  *result_num = intermediate_diff;
  adjustment_value = num2[1];
  final_diff = num1[1] - adjustment_value;
  if ( final_diff >= 0 )
  {
    result_num[1] = final_diff;
  }
  else
  {
    adjustment_value = 1000000000;
    --intermediate_diff;
  }
  if ( final_diff < 0 )
  {
    *result_num = intermediate_diff;
    result_num[1] = final_diff + adjustment_value;
  }
  return final_diff;
}

//----- (0001F674) --------------------------------------------------------
int __fastcall get_monotonic_time(struct timespec *time_spec)
{
  return clock_gettime(1, time_spec);
}

//----- (0001F680) --------------------------------------------------------
int __fastcall update_time_with_delay(int *initial_time_parts)
{
  int initial_seconds; // r1
  int updated_nanoseconds; // r3
  __time_t total_seconds; // r2
  __time_t adjusted_seconds; // r12
  int remaining_nanoseconds; // r1
  int sleep_result; // r0
  struct timespec delay_timespec[2]; // [sp+0h] [bp-10h] BYREF

  calculate_hashrate(delay_timespec);
  initial_seconds = *initial_time_parts;
  delay_timespec[0].tv_nsec += initial_time_parts[1];
  updated_nanoseconds = delay_timespec[0].tv_nsec;
  total_seconds = delay_timespec[0].tv_sec + initial_seconds;
  delay_timespec[0].tv_sec += initial_seconds;
  if ( delay_timespec[0].tv_nsec <= 999999999 )
  {
    if ( delay_timespec[0].tv_nsec < 0 )
    {
      do
      {
        updated_nanoseconds += 1000000000;
        --total_seconds;
      }
      while ( updated_nanoseconds < 0 );
      delay_timespec[0].tv_sec = total_seconds;
      delay_timespec[0].tv_nsec = updated_nanoseconds;
    }
  }
  else
  {
    adjusted_seconds = total_seconds + 1;
    remaining_nanoseconds = delay_timespec[0].tv_nsec - 1000000000;
    if ( delay_timespec[0].tv_nsec - 1000000000 > 999999999 )
    {
      remaining_nanoseconds = -2000000000;
      adjusted_seconds = total_seconds + 2;
    }
    delay_timespec[0].tv_sec = adjusted_seconds;
    if ( delay_timespec[0].tv_nsec - 1000000000 > 999999999 )
      remaining_nanoseconds += delay_timespec[0].tv_nsec;
    delay_timespec[0].tv_nsec = remaining_nanoseconds;
  }
  do
    sleep_result = clock_nanosleep(1, 1, delay_timespec, 0);
  while ( sleep_result == 4 );
  return sleep_result;
}

//----- (0001F740) --------------------------------------------------------
int __fastcall adjust_and_sleep(int *time_values)
{
  int initial_seconds; // r1
  int updated_nsec; // r3
  __time_t adjusted_seconds; // r2
  __time_t incremented_sec_adjust; // r12
  int nsec_adjustment; // r1
  int sleep_result; // r0
  struct timespec time_spec[2]; // [sp+0h] [bp-10h] BYREF

  calculate_time_period(time_spec);
  initial_seconds = *time_values;
  time_spec[0].tv_nsec += time_values[1];
  updated_nsec = time_spec[0].tv_nsec;
  adjusted_seconds = time_spec[0].tv_sec + initial_seconds;
  time_spec[0].tv_sec += initial_seconds;
  if ( time_spec[0].tv_nsec <= 999999999 )
  {
    if ( time_spec[0].tv_nsec < 0 )
    {
      do
      {
        updated_nsec += 1000000000;
        --adjusted_seconds;
      }
      while ( updated_nsec < 0 );
      time_spec[0].tv_sec = adjusted_seconds;
      time_spec[0].tv_nsec = updated_nsec;
    }
  }
  else
  {
    incremented_sec_adjust = adjusted_seconds + 1;
    nsec_adjustment = time_spec[0].tv_nsec - 1000000000;
    if ( time_spec[0].tv_nsec - 1000000000 > 999999999 )
    {
      nsec_adjustment = -2000000000;
      incremented_sec_adjust = adjusted_seconds + 2;
    }
    time_spec[0].tv_sec = incremented_sec_adjust;
    if ( time_spec[0].tv_nsec - 1000000000 > 999999999 )
      nsec_adjustment += time_spec[0].tv_nsec;
    time_spec[0].tv_nsec = nsec_adjustment;
  }
  do
    sleep_result = clock_nanosleep(1, 1, time_spec, 0);
  while ( sleep_result == 4 );
  return sleep_result;
}

//----- (0001F7F8) --------------------------------------------------------
int get_and_update_system_time()
{
  struct timespec current_time; // [sp+0h] [bp-10h] BYREF

  clock_gettime(1, &current_time);
  return update_time_with_delay(&current_time.tv_sec);
}

//----- (0001F858) --------------------------------------------------------
int __fastcall check_time_difference(int current_time, _DWORD *previous_time)
{
  if ( *(_DWORD *)current_time - *previous_time <= 60 )
    return 1000000;
  return current_time;
}

//----- (0001F8EC) --------------------------------------------------------
void sub_1F8EC()
{
  ;
}

//----- (0001F930) --------------------------------------------------------
int __fastcall parse_url(const char *url, _DWORD *hostname, char **port_string)
{
  const char *processed_url; // r4
  char *protocol_end; // r0
  char *ipv6_start; // r6
  char *ipv6_end; // r0
  char is_ipv6; // r5
  int valid_ipv6; // r5
  char *port_start; // r6
  size_t url_length; // r0
  int hostname_length; // r3
  int port_length; // r7
  char *port_end; // r0
  char port_buffer[8]; // [sp+8h] [bp-128h] BYREF
  char hostname_buffer[288]; // [sp+10h] [bp-120h] BYREF

  processed_url = url;
  *hostname = url;
  protocol_end = strstr(url, "//");
  if ( protocol_end )
    processed_url = protocol_end + 2;
  ipv6_start = strchr(processed_url, 91);
  ipv6_end = strchr(processed_url, 93);
  is_ipv6 = (char)ipv6_end;
  if ( ipv6_end )
    is_ipv6 = 1;
  if ( !ipv6_start )
    is_ipv6 = 0;
  if ( ipv6_start < ipv6_end )
    valid_ipv6 = is_ipv6 & 1;
  else
    valid_ipv6 = 0;
  if ( !valid_ipv6 )
    ipv6_end = (char *)processed_url;
  port_start = strchr(ipv6_end, 58);
  url_length = strlen(processed_url);
  if ( port_start )
  {
    hostname_length = port_start - processed_url;
    port_length = ~(port_start - processed_url) + url_length;
    if ( port_length <= 0 )
      return 0;
    ++port_start;
  }
  else
  {
    hostname_length = url_length;
    port_length = 0;
  }
  if ( hostname_length <= 0 )
    return 0;
  if ( valid_ipv6 )
  {
    ++processed_url;
    hostname_length -= 2;
  }
  snprintf(hostname_buffer, 254u, "%.*s", hostname_length, processed_url);
  if ( port_length )
  {
    snprintf(port_buffer, 6u, "%.*s", port_length, port_start);
    port_end = strpbrk(port_buffer, "/#");
    if ( port_end )
      *port_end = 0;
  }
  else
  {
    strcpy(port_buffer, "80");
  }
  *port_string = _strdup(port_buffer);
  *hostname = _strdup(hostname_buffer);
  return 1;
}

//----- (0001FAA4) --------------------------------------------------------
char *__fastcall update_proxy_settings(char *url, int config_struct)
{
  const char *protocol_prefix; // r4
  int protocol_index; // r5
  size_t prefix_length; // r6
  char *pipe_position; // r0
  char *next_section; // r10
  char *allocated_memory; // r0
  const char *url_without_protocol; // r1

  protocol_prefix = "http:";
  protocol_index = 0;
  prefix_length = 5;
  *(_DWORD *)(config_struct + 184) = 0;
  while ( strncmp(url, protocol_prefix, prefix_length) )
  {
    ++protocol_index;
    protocol_prefix = (&off_4AC9C)[2 * protocol_index];
    if ( !protocol_prefix )
      return url;
    prefix_length = strlen((&off_4AC9C)[2 * protocol_index]);
  }
  pipe_position = strchr(url, 124);
  next_section = pipe_position;
  if ( pipe_position )
  {
    *pipe_position = 0;
    allocated_memory = (char *)safe_malloc_with_logging(
                                 1 - prefix_length + pipe_position - url,
                                 "util.c",
                                 "get_proxy",
                                 748);
    url_without_protocol = &url[prefix_length];
    *(_DWORD *)(config_struct + 184) = allocated_memory;
    url = next_section + 1;
    strcpy(allocated_memory, url_without_protocol);
    parse_url(*(const char **)(config_struct + 184), (_DWORD *)(config_struct + 604), (char **)(config_struct + 608));
    *(_DWORD *)(config_struct + 180) = dword_4A880[2 * protocol_index + 264];
  }
  return url;
}
// 1E74C: using guessed type int __fastcall sub_1E74C(_DWORD, _DWORD, _DWORD, _DWORD);
// 4A880: using guessed type int dword_4A880[256];
// 4AC9C: using guessed type char *off_4AC9C;

//----- (0001FB7C) --------------------------------------------------------
bool __fastcall is_connection_ready(int connection_info)
{
  _BYTE *socket_status; // r3

  socket_status = *(_BYTE **)(connection_info + 592);
  return *socket_status || is_socket_ready(*(_DWORD *)(connection_info + 588), (unsigned __int8)*socket_status);
}

//----- (0001FB9C) --------------------------------------------------------
void **__fastcall resize_and_clear_if_needed(
        void **buffer_ptr,
        unsigned int old_size,
        size_t new_size,
        const char *file_name,
        const char *function_name,
        int line_number)
{
  void **temp_ptr; // r6

  if ( new_size != old_size )
  {
    temp_ptr = buffer_ptr;
    buffer_ptr = (void **)realloc_with_logging(*buffer_ptr, new_size, file_name, function_name, line_number);
    *temp_ptr = buffer_ptr;
    if ( new_size > old_size )
      return (void **)memset((char *)buffer_ptr + old_size, 0, new_size - old_size);
  }
  return buffer_ptr;
}

//----- (0001FC08) --------------------------------------------------------
int __fastcall map_chain_index_to_mask(int chain_index_mask, int *mapped_chain_count_ptr)
{
  unsigned int bit_index; // r3
  unsigned int mapped_bit_count; // r2
  bool loop_termination_flag; // cc
  int initial_result; // r12
  int max_mapped_chain_count; // r6
  int *current_mapped_chain; // r3
  int final_chain_mask; // r0
  char current_chain_index; // t1
  int mapped_chain_indices[4]; // [sp+0h] [bp-28h] BYREF
  int temp_storage[2]; // [sp+10h] [bp-18h]

  bit_index = 0;
  mapped_bit_count = 0;
  temp_storage[0] = 0;
  memset(mapped_chain_indices, 0, sizeof(mapped_chain_indices));
  *(int *)((char *)temp_storage + 3) = 0;
  do
  {
    if ( (chain_index_mask & (1 << bit_index)) != 0 )
      *((_BYTE *)mapped_chain_indices + mapped_bit_count++) = bit_index;
    loop_termination_flag = ++bit_index > 31;
    if ( bit_index <= 31 )
      loop_termination_flag = mapped_bit_count > 22;
    initial_result = !loop_termination_flag;
  }
  while ( !loop_termination_flag );
  max_mapped_chain_count = *mapped_chain_count_ptr;
  if ( mapped_bit_count )
  {
    if ( max_mapped_chain_count <= 0 )
    {
      final_chain_mask = initial_result;
    }
    else
    {
      current_mapped_chain = mapped_chain_indices;
      final_chain_mask = initial_result;
      do
      {
        current_chain_index = *(_BYTE *)current_mapped_chain;
        current_mapped_chain = (int *)((char *)current_mapped_chain + 1);
        final_chain_mask |= 1 << current_chain_index;
      }
      while ( (int *)((char *)mapped_chain_indices + mapped_bit_count) != current_mapped_chain
           && (int *)((char *)mapped_chain_indices + max_mapped_chain_count) != current_mapped_chain );
    }
  }
  else
  {
    final_chain_mask = 0;
  }
  if ( max_mapped_chain_count > mapped_bit_count )
    *mapped_chain_count_ptr = mapped_bit_count;
  return final_chain_mask;
}
// 1FC08: using guessed type _DWORD var_18[2];

//----- (0001FCC8) --------------------------------------------------------
int __fastcall process_mask_input(int miner_data, char *input_string)
{
  size_t input_length; // r0
  size_t padding_length; // r1
  char *input_ptr; // r2
  char *input_end_ptr; // r0
  char *target_ptr; // r1
  char temp_char; // t1
  int processed_mask; // r0
  char bit_num; // r2
  unsigned int mask; // [sp+Ch] [bp-824h] BYREF
  int bit_count; // [sp+10h] [bp-820h] BYREF
  char padded_input[12]; // [sp+14h] [bp-81Ch] BYREF
  char s[2064]; // [sp+20h] [bp-810h] BYREF

  qmemcpy(padded_input, "000000000", 9);
  input_length = strlen(input_string);
  mask = 0;
  bit_count = 3;
  if ( input_length )
  {
    padding_length = 7 - input_length;
    input_ptr = input_string - 1;
    input_end_ptr = &input_string[input_length - 1];
    target_ptr = &padded_input[padding_length];
    do
    {
      temp_char = *++input_ptr;
      *++target_ptr = temp_char;
    }
    while ( input_ptr != input_end_ptr );
  }
  padded_input[8] = 0;
  hex_string_to_binary(&mask, (unsigned __int8 *)padded_input, 4);
  if ( byte_70CE8 || byte_66640 || dword_657B8 > 5 )
  {
    snprintf(s, 2048u, "mask returned by pool is %s, swaped = 0x%x", input_string, mask);
    log_event(6, s, 0);
  }
  mask = ((mask & 0xE0FF1F) >> 8) & 0xFF00 | ((mask & 0xE0FF1F) << 8) & 0xFF0000 | ((mask & 0xE0FF1F) << 24);
  processed_mask = map_chain_index_to_mask(mask, &bit_count);
  mask = processed_mask;
  if ( byte_70CE8 || byte_66640 || dword_657B8 > 4 )
  {
    snprintf(s, 2048u, "real mask = 0x%x, bit_num = %d", processed_mask, bit_count);
    log_event(5, s, 0);
    processed_mask = mask;
    if ( !mask )
    {
      if ( byte_70CE8 || byte_66640 )
      {
LABEL_12:
        snprintf(s, 2048u, "Pool %d rolling mask do not match!", *(_DWORD *)miner_data);
        log_event(5, s, 0);
LABEL_13:
        processed_mask = mask;
        *(_BYTE *)(miner_data + 644) = 0;
        *(_DWORD *)(miner_data + 648) = 1;
        *(_DWORD *)(miner_data + 652) = processed_mask;
        return processed_mask;
      }
LABEL_17:
      if ( dword_657B8 <= 4 )
        goto LABEL_13;
      goto LABEL_12;
    }
  }
  else if ( !processed_mask )
  {
    goto LABEL_17;
  }
  bit_num = bit_count;
  *(_BYTE *)(miner_data + 644) = 1;
  *(_DWORD *)(miner_data + 652) = processed_mask;
  *(_DWORD *)(miner_data + 648) = 1 << bit_num;
  return processed_mask;
}
// 1FC08: using guessed type int __fastcall sub_1FC08(_DWORD, _DWORD);
// 657B8: using guessed type int dword_657B8;
// 66640: using guessed type char byte_66640;
// 70CE8: using guessed type char byte_70CE8;

//----- (0001FF10) --------------------------------------------------------
int __fastcall process_mining_configure_response(_DWORD *miner_config, int pool_num)
{
  int status; // r0
  int status_copy; // r5
  _DWORD *result_obj; // r7
  _DWORD *error_obj; // r0
  int res; // r6
  unsigned int *ref_counter; // r3
  unsigned int current_count; // r2
  unsigned int new_count; // r2
  int result_list; // r0
  const char *current_param; // r4
  int next_index; // r0
  int next_index_status; // r0
  int current_index; // r0
  _DWORD *current_value; // r9
  char *version_mask; // r0
  int decode_status[23]; // [sp+14h] [bp-924h] BYREF
  char error_message[160]; // [sp+70h] [bp-8C8h] BYREF
  char log_message[2088]; // [sp+110h] [bp-828h] BYREF

  status = process_command(pool_num, 0, decode_status);
  status_copy = status;
  if ( status )
  {
    result_obj = (_DWORD *)validate_and_fetch_data(status, "result");
    error_obj = (_DWORD *)validate_and_fetch_data(status_copy, "error");
    if ( result_obj
      && *result_obj != 7
      && (!error_obj || *error_obj == 7)
      && (result_list = get_next_element_if_available(result_obj),
          (current_param = (const char *)get_adjusted_temperature(result_list)) != 0) )
    {
      res = 0;
      do
      {
        current_index = adjust_result_value(current_param);
        current_value = (_DWORD *)get_temperature_if_valid(current_index);
        if ( !current_value )
          break;
        if ( !strcasecmp(current_param, "version-rolling") && strlen(current_param) == 15 )
        {
          if ( *current_value != 5 )
          {
            if ( byte_70CE8 || byte_66640 || dword_657B8 > 4 )
            {
              snprintf(log_message, 2048u, "Pool %d don't support ab!", *miner_config);
              log_event(5, log_message, 0);
            }
            *((_BYTE *)miner_config + 644) = 0;
            res = 1;
            miner_config[162] = 1;
            break;
          }
          if ( byte_70CE8 || byte_66640 || dword_657B8 > 4 )
          {
            snprintf(log_message, 2048u, "POOL %d support ab mode!", *miner_config);
            log_event(5, log_message, 0);
          }
        }
        else if ( !strcasecmp(current_param, "version-rolling.mask") && strlen(current_param) == 20 )
        {
          res = 1;
          version_mask = (char *)get_linked_item_or_null(current_value);
          process_mask_input((int)miner_config, version_mask);
        }
        else if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
        {
          snprintf(log_message, 2048u, "JSON-RPC unexpected mining.configure value: %s", current_param);
          log_event(3, log_message, 0);
        }
        next_index = adjust_result_value(current_param);
        next_index_status = sub_475A0(result_obj, next_index);
        current_param = (const char *)get_adjusted_temperature(next_index_status);
      }
      while ( current_param );
    }
    else
    {
      res = 0;
    }
    if ( *(_DWORD *)(status_copy + 4) != -1 )
    {
      ref_counter = (unsigned int *)(status_copy + 4);
      __dmb(11u);
      do
      {
        current_count = __ldrex(ref_counter);
        new_count = current_count - 1;
      }
      while ( __strex(new_count, ref_counter) );
      if ( !new_count )
        process_bitmain_miner(status_copy);
    }
    return res;
  }
  if ( !byte_70CE8 )
  {
    res = (unsigned __int8)byte_66640;
    if ( !byte_66640 && dword_657B8 <= 5 )
      return res;
  }
  snprintf(log_message, 2048u, "JSON decode failed(%d): %s", decode_status[0], error_message);
  log_event(6, log_message, 0);
  return 0;
}
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 46448: using guessed type int __fastcall sub_46448(_DWORD, _DWORD, _DWORD);
// 472EC: using guessed type int __fastcall sub_472EC(_DWORD, _DWORD);
// 47554: using guessed type int __fastcall sub_47554(_DWORD);
// 475A0: using guessed type int __fastcall sub_475A0(_DWORD, _DWORD);
// 475D4: using guessed type int __fastcall sub_475D4(_DWORD);
// 475E0: using guessed type int __fastcall sub_475E0(_DWORD);
// 475EC: using guessed type int __fastcall sub_475EC(_DWORD);
// 47820: using guessed type int __fastcall sub_47820(_DWORD);
// 47C24: using guessed type int __fastcall sub_47C24(_DWORD);
// 657B8: using guessed type int dword_657B8;
// 66640: using guessed type char byte_66640;
// 70CE8: using guessed type char byte_70CE8;
// 1FF10: using guessed type int var_924[23];
// 1FF10: using guessed type char var_8C8[160];

//----- (00020258) --------------------------------------------------------
int __fastcall close_stratum_socket(int stratum_pool_ptr)
{
  int *error_unlock; // r0
  int *error_lock; // r0
  char log_buffer[2064]; // [sp+10h] [bp-810h] BYREF

  if ( byte_70CE8 || byte_66640 || dword_657B8 > 5 )
  {
    snprintf(log_buffer, 2048u, "Closing socket for stratum pool %d", *(_DWORD *)stratum_pool_ptr);
    log_event(6, log_buffer, 0);
  }
  if ( pthread_mutex_lock((pthread_mutex_t *)(stratum_pool_ptr + 704)) )
  {
    error_lock = _errno_location();
    snprintf(
      log_buffer,
      2048u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *error_lock,
      "util.c",
      "suspend_stratum",
      3407);
    log_event(3, log_buffer, 1);
    shutdown_miner_safely(1);
  }
  reset_network_state(stratum_pool_ptr);
  if ( pthread_mutex_unlock((pthread_mutex_t *)(stratum_pool_ptr + 704)) )
  {
    error_unlock = _errno_location();
    snprintf(
      log_buffer,
      2048u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *error_unlock,
      "util.c",
      "suspend_stratum",
      3409);
    log_event(3, log_buffer, 1);
    shutdown_miner_safely(1);
  }
  return off_658DC(0);
}
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 1DA28: using guessed type int sub_1DA28(void);
// 1E150: using guessed type int __fastcall sub_1E150(_DWORD);
// 3AADC: using guessed type void __fastcall __noreturn sub_3AADC(_DWORD);
// 657B8: using guessed type int dword_657B8;
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);
// 66640: using guessed type char byte_66640;
// 70CE8: using guessed type char byte_70CE8;

//----- (000203BC) --------------------------------------------------------
int __fastcall stratum_send(int miner_id, char *message)
{
  int *mutex_unlock_errno; // r0
  int send_result; // r0
  int send_status; // r4
  int *mutex_lock_errno; // r0
  char log_message[2072]; // [sp+10h] [bp-818h] BYREF

  if ( byte_70E20 && byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
  {
    snprintf(log_message, 2048u, "SEND: %s", message);
    log_event(7, log_message, 0);
  }
  if ( pthread_mutex_lock((pthread_mutex_t *)(miner_id + 704)) )
  {
    mutex_lock_errno = _errno_location();
    snprintf(
      log_message,
      2048u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *mutex_lock_errno,
      "util.c",
      "stratum_send",
      1711);
    log_event(3, log_message, 1);
    shutdown_miner_safely(1);
  }
  if ( *(_BYTE *)(miner_id + 641) )
  {
    send_status = send_with_timeout(miner_id, message);
    if ( !pthread_mutex_unlock((pthread_mutex_t *)(miner_id + 704)) )
    {
      off_658DC(0);
      switch ( send_status )
      {
        case 2:
          if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
          {
            strcpy(log_message, "Failed to send in stratum_send");
            log_event(7, log_message, 0);
            close_stratum_socket(miner_id);
            return 0;
          }
          break;
        case 3:
          goto LABEL_12;
        case 1:
          if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
          {
            snprintf(log_message, 2048u, "Write select failed on pool %d sock", *(_DWORD *)miner_id);
            log_event(7, log_message, 0);
          }
          break;
        default:
          return send_status == 0;
      }
      close_stratum_socket(miner_id);
      return 0;
    }
LABEL_7:
    mutex_unlock_errno = _errno_location();
    snprintf(
      log_message,
      2048u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *mutex_unlock_errno,
      "util.c",
      "stratum_send",
      1717);
    log_event(3, log_message, 1);
    shutdown_miner_safely(1);
  }
  if ( pthread_mutex_unlock((pthread_mutex_t *)(miner_id + 704)) )
    goto LABEL_7;
  off_658DC(0);
LABEL_12:
  send_result = (unsigned __int8)byte_66641;
  if ( byte_66641 )
  {
    if ( byte_70CE8 || (send_result = (unsigned __int8)byte_66640, byte_66640) || dword_657B8 > 6 )
    {
      strcpy(log_message, "Stratum send failed due to no pool stratum_active");
      log_event(7, log_message, 0);
      return 0;
    }
  }
  return send_result;
}
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 1DA28: using guessed type int sub_1DA28(void);
// 20258: using guessed type int __fastcall sub_20258(_DWORD);
// 3AADC: using guessed type void __fastcall __noreturn sub_3AADC(_DWORD);
// 657B8: using guessed type int dword_657B8;
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);
// 66640: using guessed type char byte_66640;
// 66641: using guessed type char byte_66641;
// 70CE8: using guessed type char byte_70CE8;
// 70E20: using guessed type char byte_70E20;

//----- (00020770) --------------------------------------------------------
char *__fastcall receive_socket_data(int socket_struct)
{
  char *current_buffer; // r7
  signed int buffer_length; // r6
  char *line_data; // r0
  char *copied_line; // r5
  size_t copied_line_length; // r0
  size_t line_length; // r7
  unsigned int prev_bytes_sent; // lr
  __int64 incremented_msg_count; // kr08_8
  unsigned int prev_bytes_recv; // r3
  unsigned int prev_msg_count; // kr04_4
  int log_enabled; // r1
  unsigned int new_bytes_recv; // r2
  __time_t previous_seconds; // r9
  int previous_microseconds; // r5
  ssize_t received_bytes; // r6
  bool is_recv_error; // nf
  int time_difference; // r6
  char *new_buffer; // r11
  size_t recv_length; // r7
  size_t current_length; // r10
  unsigned int new_buffer_size; // r0
  unsigned int rounded_buffer_size; // r7
  int realloc_result; // r0
  struct timespec current_timespec[255]; // [sp+8h] [bp-2830h] BYREF
  struct timespec initial_timespec[1030]; // [sp+808h] [bp-2030h] BYREF

  current_buffer = *(char **)(socket_struct + 592);
  if ( !strchr(current_buffer, 10) )
  {
    clock_gettime(1, initial_timespec);
    previous_seconds = initial_timespec[0].tv_sec;
    previous_microseconds = initial_timespec[0].tv_nsec / 1000;
    if ( !is_socket_ready(*(_DWORD *)(socket_struct + 588), 60) )
    {
      if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
      {
        strcpy((char *)initial_timespec, "Timed out waiting for data on socket_full");
        log_event(7, initial_timespec, 0);
      }
      goto LABEL_29;
    }
    while ( 1 )
    {
      memset(initial_timespec, 0, 8192u);
      received_bytes = recv(*(_DWORD *)(socket_struct + 588), initial_timespec, 8188u, 0);
      if ( !received_bytes )
        break;
      clock_gettime(1, current_timespec);
      is_recv_error = received_bytes < 0;
      time_difference = (int)((double)(current_timespec[0].tv_nsec / 1000 - previous_microseconds) / 1000000.0
                            + (double)(current_timespec[0].tv_sec - previous_seconds));
      if ( is_recv_error )
      {
        if ( *_errno_location() != 11 || !is_socket_ready(*(_DWORD *)(socket_struct + 588), 60 - time_difference) )
        {
          if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
          {
            strcpy((char *)current_timespec, "Failed to recv sock in recv_line");
            log_event(7, current_timespec, 0);
          }
          goto LABEL_35;
        }
      }
      else
      {
        new_buffer = *(char **)(socket_struct + 592);
        recv_length = strlen((const char *)initial_timespec);
        current_length = strlen(new_buffer);
        new_buffer_size = recv_length + current_length + 1;
        if ( new_buffer_size >= *(_DWORD *)(socket_struct + 596) )
        {
          rounded_buffer_size = (new_buffer_size & 0xFFFFE000) + 8192;
          realloc_result = realloc_with_logging(new_buffer, rounded_buffer_size, "util.c", "recalloc_sock", 1826);
          *(_DWORD *)(socket_struct + 592) = realloc_result;
          memset((void *)(realloc_result + current_length), 0, rounded_buffer_size - current_length);
          new_buffer = *(char **)(socket_struct + 592);
          *(_DWORD *)(socket_struct + 596) = rounded_buffer_size;
        }
        strcat(new_buffer, (const char *)initial_timespec);
      }
      current_buffer = *(char **)(socket_struct + 592);
      if ( time_difference > 59 || strchr(*(const char **)(socket_struct + 592), 10) )
        goto LABEL_2;
    }
    if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
    {
      strcpy((char *)current_timespec, "Socket closed waiting in recv_line");
      log_event(7, current_timespec, 0);
    }
LABEL_35:
    close_stratum_socket(socket_struct);
    current_buffer = *(char **)(socket_struct + 592);
  }
LABEL_2:
  buffer_length = strlen(current_buffer);
  line_data = strtok(current_buffer, "\n");
  if ( !line_data )
  {
    if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
    {
      strcpy((char *)initial_timespec, "Failed to parse a \\n terminated string in recv_line");
      log_event(7, initial_timespec, 0);
    }
LABEL_29:
    copied_line = 0;
    clear_socket_buffer(socket_struct);
    return copied_line;
  }
  copied_line = _strdup(line_data);
  copied_line_length = strlen(copied_line);
  line_length = copied_line_length;
  if ( (int)(copied_line_length + 1) < buffer_length )
    memmove(
      *(void **)(socket_struct + 592),
      (const void *)(*(_DWORD *)(socket_struct + 592) + copied_line_length + 1),
      buffer_length - copied_line_length + 1);
  else
    **(_BYTE **)(socket_struct + 592) = 0;
  prev_bytes_sent = *(_DWORD *)(socket_struct + 532);
  incremented_msg_count = *(_QWORD *)(socket_struct + 520) + 1LL;
  prev_bytes_recv = *(_DWORD *)(socket_struct + 536);
  prev_msg_count = *(_DWORD *)(socket_struct + 528);
  *(_DWORD *)(socket_struct + 520) = incremented_msg_count;
  *(_QWORD *)(socket_struct + 528) = __PAIR64__(prev_bytes_sent, prev_msg_count) + line_length;
  log_enabled = (unsigned __int8)byte_70E20;
  new_bytes_recv = *(_DWORD *)(socket_struct + 540);
  *(_DWORD *)(socket_struct + 524) = HIDWORD(incremented_msg_count);
  *(_QWORD *)(socket_struct + 536) = __PAIR64__(new_bytes_recv, prev_bytes_recv) + line_length;
  if ( log_enabled && byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
  {
    snprintf((char *)initial_timespec, 2048u, "RECVD: %s", copied_line);
    log_event(7, initial_timespec, 0);
  }
  return copied_line;
}
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 1E1B8: using guessed type int __fastcall sub_1E1B8(_DWORD, _DWORD);
// 1E658: using guessed type int __fastcall sub_1E658(_DWORD);
// 1E864: using guessed type int __fastcall sub_1E864(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 20258: using guessed type int __fastcall sub_20258(_DWORD);
// 657B8: using guessed type int dword_657B8;
// 66640: using guessed type char byte_66640;
// 66641: using guessed type char byte_66641;
// 70CE8: using guessed type char byte_70CE8;
// 70E20: using guessed type char byte_70E20;

//----- (00020CFC) --------------------------------------------------------
int __fastcall initiate_stratum(_DWORD *parameters)
{
  int session_id; // r2
  _DWORD *json_response; // r7
  int v4; // r0
  int resume_success; // r8
  int n2size; // r9
  const char *previous_session_id; // r1
  size_t nonce1_len; // r3
  void *prev_buffer; // r0
  _BYTE *new_buffer; // r0
  int v12; // r2
  unsigned __int8 *nonce1_str; // r1
  int enable_new_block; // r3
  int log_enabled; // r2
  unsigned int *ref_counter; // r3
  unsigned int old_ref_value; // r2
  unsigned int new_ref_value; // r2
  char *json_raw; // r0
  char *json_raw_ptr; // r9
  _DWORD *result_obj; // r9
  _DWORD *error_obj; // r0
  char *error_message; // r8
  unsigned int *result_ref_counter; // r3
  unsigned int result_old_ref_value; // r2
  unsigned int result_new_ref_value; // r2
  int new_session_id; // r2
  int *unlock_errno; // r0
  int *unlock_errno_wr; // r0
  int *lock_errno_rw; // r0
  int *lock_errno; // r0
  _DWORD *result_array; // r0
  unsigned int i; // r8
  _DWORD *task_by_index; // r0
  _DWORD *v35; // r10
  char *info_duplicate_if_not_null; // r10
  char *v37; // r8
  int v38; // r3
  const char *v39; // r0
  _DWORD *v40; // r0
  int linked_list_next_node; // r0
  int *v42; // r0
  int *v43; // r0
  int *v44; // r0
  const char *v45; // [sp+4h] [bp-294Ch]
  unsigned int v46; // [sp+10h] [bp-2940h]
  char *v47; // [sp+10h] [bp-2940h]
  _DWORD *v48; // [sp+18h] [bp-2938h]
  int v49; // [sp+18h] [bp-2938h]
  _DWORD *next_structure_pointer; // [sp+20h] [bp-2930h]
  int v51[23]; // [sp+2Ch] [bp-2924h] BYREF
  char v52[160]; // [sp+88h] [bp-28C8h] BYREF
  char s[2040]; // [sp+128h] [bp-2828h] BYREF
  char v54[8232]; // [sp+928h] [bp-2028h] BYREF

  clear_socket_buffer((int)parameters);
  session_id = dword_70D14;
  if ( parameters[159] )
  {
    v45 = (const char *)parameters[159];
    ++dword_70D14;
    sprintf(
      v54,
      "{\"id\": %d, \"method\": \"mining.subscribe\", \"params\": [\"%s/%s\", \"%s\"]}",
      session_id,
      byte_682B4,
      byte_681B4,
      v45);
  }
  else
  {
    ++dword_70D14;
    sprintf(
      v54,
      "{\"id\": %d, \"method\": \"mining.subscribe\", \"params\": [\"%s/%s\"]}",
      session_id,
      byte_682B4,
      byte_681B4);
  }
  json_response = 0;
  v46 = 0;
  while ( 1 )
  {
    v4 = strlen(v54);
    if ( send_with_timeout((int)parameters, v54, v4) )
    {
      if ( !byte_66641 )
      {
LABEL_6:
        if ( json_response )
        {
          resume_success = 0;
          goto LABEL_36;
        }
        return 0;
      }
      if ( !byte_70CE8 && !byte_66640 && dword_657B8 <= 6 )
        goto LABEL_84;
      strcpy(s, "Failed to send s in initiate_stratum");
      log_event(7, s, 0);
      goto LABEL_45;
    }
    if ( !is_socket_ready(parameters[147], 60) )
    {
      if ( !byte_66641 )
        goto LABEL_6;
      if ( !byte_70CE8 && !byte_66640 && dword_657B8 <= 6 )
        goto LABEL_84;
      strcpy(s, "Timed out waiting for response in initiate_stratum");
      log_event(7, s, 0);
LABEL_45:
      if ( !byte_66641 )
        goto LABEL_6;
      if ( byte_70CE8 )
      {
LABEL_47:
        strcpy(s, "Initiate stratum failed");
        log_event(7, s, 0);
        goto LABEL_6;
      }
LABEL_84:
      if ( !byte_66640 && dword_657B8 <= 6 )
        goto LABEL_6;
      goto LABEL_47;
    }
    json_raw = receive_socket_data((int)parameters);
    json_raw_ptr = json_raw;
    if ( !json_raw )
      goto LABEL_45;
    json_response = (_DWORD *)process_command((int)json_raw, 0, (int)v51);
    free(json_raw_ptr);
    if ( json_response )
      break;
    v46 ^= 1u;
    if ( byte_70CE8 || byte_66640 || dword_657B8 > 5 )
    {
      snprintf(s, 2048u, "JSON decode failed(%d): %s", v51[0], v52);
      log_event(6, s, 0);
    }
LABEL_65:
    if ( !v46 )
      goto LABEL_45;
    if ( pthread_mutex_lock((pthread_mutex_t *)(parameters + 53)) )
    {
      lock_errno = _errno_location();
      snprintf(
        s,
        2048u,
        "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
        *lock_errno,
        "util.c",
        "initiate_stratum",
        3637);
      log_event(3, s, 1);
      shutdown_miner_safely(1);
    }
    if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(parameters + 59)) )
    {
      lock_errno_rw = _errno_location();
      snprintf(
        s,
        2048u,
        "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
        *lock_errno_rw,
        "util.c",
        "initiate_stratum",
        3637);
      log_event(3, s, 1);
      shutdown_miner_safely(1);
    }
    free((void *)parameters[159]);
    free((void *)parameters[153]);
    parameters[153] = 0;
    parameters[159] = 0;
    if ( pthread_rwlock_unlock((pthread_rwlock_t *)(parameters + 59)) )
    {
      unlock_errno_wr = _errno_location();
      snprintf(
        s,
        2048u,
        "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *unlock_errno_wr,
        "util.c",
        "initiate_stratum",
        3641);
      log_event(3, s, 1);
      shutdown_miner_safely(1);
    }
    if ( pthread_mutex_unlock((pthread_mutex_t *)(parameters + 53)) )
    {
      unlock_errno = _errno_location();
      snprintf(
        s,
        2048u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *unlock_errno,
        "util.c",
        "initiate_stratum",
        3641);
      log_event(3, s, 1);
      shutdown_miner_safely(1);
    }
    off_658DC(0);
    if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
    {
      strcpy(s, "Failed to resume stratum, trying afresh");
      log_event(7, s, 0);
    }
    if ( json_response )
    {
      if ( json_response[1] != -1 )
      {
        result_ref_counter = json_response + 1;
        __dmb(11u);
        do
        {
          result_old_ref_value = __ldrex(result_ref_counter);
          result_new_ref_value = result_old_ref_value - 1;
        }
        while ( __strex(result_new_ref_value, result_ref_counter) );
        if ( !result_new_ref_value )
          process_bitmain_miner(json_response);
      }
    }
    clear_socket_buffer((int)parameters);
    new_session_id = dword_70D14++;
    sprintf(v54, "{\"id\": %d, \"method\": \"mining.subscribe\", \"params\": []}", new_session_id);
  }
  result_obj = (_DWORD *)validate_and_fetch_data(json_response, "result");
  error_obj = (_DWORD *)validate_and_fetch_data(json_response, "error");
  if ( !result_obj || *result_obj == 7 )
  {
    if ( error_obj )
    {
LABEL_60:
      error_message = (char *)generate_config_json(error_obj, 3);
    }
    else
    {
      error_message = (char *)malloc(17u);
      if ( error_message )
        strcpy(error_message, "(unknown reason)");
    }
    if ( byte_70CE8 || byte_66640 || dword_657B8 > 5 )
    {
      snprintf(s, 2048u, "JSON-RPC decode failed: %s", error_message);
      log_event(6, s, 0);
    }
    v46 ^= 1u;
    free(error_message);
    goto LABEL_65;
  }
  if ( error_obj && *error_obj != 7 )
    goto LABEL_60;
  result_array = get_task_by_index(result_obj, 0);
  v48 = result_array;
  if ( result_array )
  {
    if ( *result_array == 1 )
    {
      next_structure_pointer = get_next_structure_pointer(result_array);
      if ( (int)next_structure_pointer > 0 )
      {
        for ( i = 0; next_structure_pointer != (_DWORD *)i; ++i )
        {
          task_by_index = get_task_by_index(v48, i);
          v35 = task_by_index;
          if ( !task_by_index || *task_by_index != 1 )
            break;
          v39 = (const char *)check_status_and_get_info(task_by_index, 0);
          if ( v39 && !strncasecmp(v39, "mining.notify", 13u) )
          {
            info_duplicate_if_not_null = get_info_duplicate_if_not_null(v35, 1u);
            if ( info_duplicate_if_not_null )
              goto LABEL_110;
            break;
          }
        }
      }
    }
  }
  info_duplicate_if_not_null = (char *)(unsigned __int8)byte_66641;
  if ( byte_66641 )
  {
    if ( byte_70CE8 || (info_duplicate_if_not_null = (char *)(unsigned __int8)byte_66640, byte_66640) || dword_657B8 > 6 )
    {
      info_duplicate_if_not_null = 0;
      strcpy(s, "Failed to get sessionid in initiate_stratum");
      log_event(7, s, 0);
    }
  }
LABEL_110:
  v37 = get_info_duplicate_if_not_null(result_obj, 1u);
  v38 = validate_hex_string(v37, "initiate_stratum", 3579);
  if ( !v38 )
  {
    if ( byte_70CE8 || byte_66640 || dword_657B8 > 5 )
    {
      strcpy(s, "Failed to get valid nonce1 in initiate_stratum");
      log_event(6, s, 0);
    }
    v46 ^= 1u;
    free(info_duplicate_if_not_null);
    goto LABEL_65;
  }
  v49 = v38;
  v40 = get_task_by_index(result_obj, 2u);
  linked_list_next_node = get_linked_list_next_node((int)v40);
  if ( (unsigned int)(linked_list_next_node - 2) > 14 )
  {
    if ( byte_70CE8 || byte_66640 || dword_657B8 > 5 )
    {
      strcpy(s, "Failed to get valid n2size in initiate_stratum");
      log_event(6, s, 0);
    }
    v46 ^= 1u;
    free(info_duplicate_if_not_null);
    free(v37);
    goto LABEL_65;
  }
  n2size = linked_list_next_node;
  v47 = v37;
  resume_success = v49;
  if ( info_duplicate_if_not_null )
  {
    previous_session_id = (const char *)parameters[159];
    if ( previous_session_id )
    {
      if ( !strcmp(info_duplicate_if_not_null, previous_session_id) && (byte_70CE8 || byte_66640 || dword_657B8 > 4) )
      {
        snprintf(s, 2048u, "Pool %d successfully negotiated resume with the same session ID", *parameters);
        log_event(5, s, 0);
      }
    }
  }
  if ( pthread_mutex_lock((pthread_mutex_t *)(parameters + 53)) )
    log_mutex_error_and_terminate("initiate_stratum", 3599);
  if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(parameters + 59)) )
  {
    v44 = _errno_location();
    snprintf(s, 2048u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v44, "util.c", "initiate_stratum", 3599);
    log_event(3, s, 1);
    shutdown_miner_safely(1);
  }
  free((void *)parameters[153]);
  free((void *)parameters[159]);
  parameters[159] = info_duplicate_if_not_null;
  parameters[153] = v47;
  nonce1_len = strlen(v47) >> 1;
  prev_buffer = (void *)parameters[154];
  parameters[391] = nonce1_len;
  free(prev_buffer);
  new_buffer = allocate_and_log_on_fail(parameters[391], 1u, "util.c", "initiate_stratum", 3606);
  v12 = parameters[391];
  nonce1_str = (unsigned __int8 *)parameters[153];
  parameters[154] = new_buffer;
  hex_string_to_binary(new_buffer, nonce1_str, v12);
  parameters[158] = n2size;
  if ( pthread_rwlock_unlock((pthread_rwlock_t *)(parameters + 59)) )
  {
    v43 = _errno_location();
    snprintf(s, 2048u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v43, "util.c", "initiate_stratum", 3609);
    log_event(3, s, 1);
    shutdown_miner_safely(1);
  }
  if ( pthread_mutex_unlock((pthread_mutex_t *)(parameters + 53)) )
  {
    v42 = _errno_location();
    snprintf(s, 2048u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v42, "util.c", "initiate_stratum", 3609);
    log_event(3, s, 1);
    shutdown_miner_safely(1);
  }
  off_658DC(0);
  if ( info_duplicate_if_not_null && byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
  {
    snprintf(s, 2048u, "Pool %d stratum session id: %s", *parameters, (const char *)parameters[159]);
    log_event(7, s, 0);
  }
  enable_new_block = parameters[144];
  *((_BYTE *)parameters + 641) = 1;
  if ( !enable_new_block )
    parameters[144] = parameters[150];
  log_enabled = (unsigned __int8)byte_70E20;
  *((_QWORD *)parameters + 227) = 0LL;
  *((_QWORD *)parameters + 228) = 4607182418800017408LL;
  if ( log_enabled )
  {
    resume_success = (unsigned __int8)byte_66641;
    if ( byte_66641 )
    {
      if ( byte_70CE8 || byte_66640 || dword_657B8 > 6 )
      {
        snprintf(
          s,
          2048u,
          "Pool %d confirmed mining.subscribe with extranonce1 %s extran2size %d",
          *parameters,
          (const char *)parameters[153],
          parameters[158]);
        log_event(7, s, 0);
      }
    }
    else
    {
      resume_success = log_enabled;
    }
  }
LABEL_36:
  if ( json_response[1] == -1 )
    return resume_success;
  ref_counter = json_response + 1;
  __dmb(11u);
  do
  {
    old_ref_value = __ldrex(ref_counter);
    new_ref_value = old_ref_value - 1;
  }
  while ( __strex(new_ref_value, ref_counter) );
  if ( new_ref_value )
    return resume_success;
  process_bitmain_miner(json_response);
  return resume_success;
}
// 657B8: using guessed type int dword_657B8;
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);
// 66640: using guessed type char byte_66640;
// 66641: using guessed type char byte_66641;
// 70CE8: using guessed type char byte_70CE8;
// 70D14: using guessed type int dword_70D14;
// 70E20: using guessed type char byte_70E20;
// 20CFC: using guessed type int var_2924[23];
// 20CFC: using guessed type char var_28C8[160];

//----- (00021AD4) --------------------------------------------------------
time_t __fastcall update_statistic_counters(_DWORD *counters_array, int event_type)
{
  time_t current_time; // r0

  current_time = time(0);
  counters_array[62] = event_type;
  counters_array[61] = current_time;
  switch ( event_type )
  {
    case 0:
      ++counters_array[63];
      break;
    case 1:
      ++counters_array[64];
      break;
    case 2:
      ++counters_array[65];
      break;
    case 3:
      ++counters_array[66];
      break;
    case 4:
      ++counters_array[67];
      break;
    case 5:
      ++counters_array[68];
      break;
    case 6:
      ++counters_array[69];
      break;
    case 7:
      ++counters_array[70];
      break;
    case 8:
      ++counters_array[71];
      break;
    case 9:
      ++counters_array[72];
      break;
    default:
      return current_time;
  }
  return current_time;
}
// 21AF8: control flows out of bounds to 21AFC

//----- (00021BC4) --------------------------------------------------------
char *__fastcall append_string(char *orig_str, char *append_str)
{
  size_t str_len; // r0
  int alignment_mask; // r1
  char *result_str; // r4
  size_t new_len; // r4
  unsigned int total_len; // r0
  char *new_str; // r4

  str_len = strlen(append_str);
  if ( !str_len )
    return orig_str;
  new_len = str_len + 1;
  if ( orig_str )
  {
    total_len = strlen(orig_str) + new_len;
    if ( (total_len & 3) != 0 )
      total_len = (total_len & 0xFFFFFFFC) + 4;
    result_str = (char *)safe_malloc_with_logging(total_len, "util.c", "realloc_strcat", 3735);
    sprintf(result_str, "%s%s", orig_str, append_str);
    free(orig_str);
    return result_str;
  }
  if ( (new_len & 3) != 0 )
    str_len = new_len & 0xFFFFFFFC;
  else
    LOWORD(alignment_mask) = -18972;
  if ( (new_len & 3) != 0 )
    LOWORD(alignment_mask) = -18972;
  else
    str_len = new_len;
  if ( (new_len & 3) != 0 )
    str_len += 4;
  HIWORD(alignment_mask) = 4;
  new_str = (char *)safe_malloc_with_logging(str_len, alignment_mask, "realloc_strcat", 3735);
  strcpy(new_str, append_str);
  return new_str;
}
// 21C70: variable 'alignment_mask' is possibly undefined
// 1E74C: using guessed type int __fastcall sub_1E74C(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00021C98) --------------------------------------------------------
int __fastcall convert_string_to_printable_hex(const char *input_string)
{
  size_t input_len; // r0
  const char *input_char_ptr; // r5
  int output_buffer_ptr_int; // r7
  char *output_buffer_ptr; // r4
  char current_char; // r3
  char formatted_char; // r2
  int next_char_int; // t1
  int output_buffer; // r0
  char *malloc_ptr; // r2
  char log_buffer[2072]; // [sp+8h] [bp-818h] BYREF

  if ( !input_string )
  {
    malloc_ptr = (char *)malloc(7u);
    if ( !malloc_ptr )
    {
      snprintf(log_buffer, 2048u, "Failed to malloc null in %s %s():%d", "util.c", "str_text", 3760);
      log_event(3, log_buffer, 1);
      shutdown_miner_safely(1);
    }
    strcpy(malloc_ptr, "(null)");
  }
  input_len = strlen(input_string);
  input_char_ptr = input_string - 1;
  output_buffer_ptr_int = safe_malloc_with_logging(4 * input_len + 5, "util.c", "str_text", 3765);
  output_buffer_ptr = (char *)output_buffer_ptr_int;
  do
  {
    while ( 1 )
    {
      next_char_int = *(unsigned __int8 *)++input_char_ptr;
      formatted_char = next_char_int;
      if ( (unsigned int)(next_char_int - 32) <= 94 )
        break;
      sprintf(output_buffer_ptr, "0x%02x");
      current_char = *input_char_ptr;
      output_buffer_ptr += 4;
      if ( !*input_char_ptr )
        goto LABEL_7;
    }
    *output_buffer_ptr++ = formatted_char;
    current_char = *input_char_ptr;
  }
  while ( *input_char_ptr );
LABEL_7:
  output_buffer = output_buffer_ptr_int;
  *output_buffer_ptr = current_char;
  return output_buffer;
}
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 1E74C: using guessed type int __fastcall sub_1E74C(_DWORD, _DWORD, _DWORD, _DWORD);
// 3AADC: using guessed type void __fastcall __noreturn sub_3AADC(_DWORD);

//----- (00021DB8) --------------------------------------------------------
int __fastcall set_process_name(const char *process_suffix)
{
  char new_process_name[24]; // [sp+8h] [bp-18h] BYREF

  snprintf(new_process_name, 16u, "cg@%s", process_suffix);
  return prctl(15, new_process_name, 0);
}

//----- (00021DF8) --------------------------------------------------------
int __fastcall initialize_semaphore_with_logging(
        sem_t *semaphore,
        const char *file_name,
        const char *function_name,
        int line_number)
{
  int init_result; // r0
  int init_status; // r4
  int *errno_address; // r0
  char log_message[2072]; // [sp+10h] [bp-818h] BYREF

  init_result = sem_init(semaphore, 0, 0);
  init_status = init_result;
  if ( init_result )
  {
    errno_address = _errno_location();
    snprintf(
      log_message,
      2048u,
      "Failed to sem_init ret=%d errno=%d in %s %s():%d",
      init_status,
      *errno_address,
      file_name,
      function_name,
      line_number);
    log_event(3, log_message, 1);
    shutdown_miner_safely(1);
  }
  return init_result;
}
// 3AADC: using guessed type void __fastcall __noreturn sub_3AADC(_DWORD);

//----- (00021E74) --------------------------------------------------------
int __fastcall create_thread(int thread_info, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg)
{
  initialize_semaphore_with_logging(thread_info + 16, "util.c", "thr_info_create", 1189);
  return pthread_create((pthread_t *)(thread_info + 12), attr, start_routine, arg);
}
// 21DF8: using guessed type int __fastcall sub_21DF8(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00021EBC) --------------------------------------------------------
int __fastcall post_semaphore_and_log_failure(
        sem_t *sem,
        const char *function_name,
        const char *file_name,
        int line_number)
{
  int post_result; // r0

  post_result = sem_post(sem);
  if ( post_result )
    log_semaphore_post_failure(sem, function_name, file_name, line_number);
  return post_result;
}

//----- (00021EF4) --------------------------------------------------------
int __fastcall completion_thread_function(int arg)
{
  pthread_setcanceltype(1, 0);
  (*(void (__fastcall **)(_DWORD))(arg + 16))(*(_DWORD *)(arg + 20));
  post_semaphore_and_log_failure(arg, "util.c", "completion_thread", 3991);
  return 0;
}
// 21EBC: using guessed type int __fastcall sub_21EBC(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00021F38) --------------------------------------------------------
int __fastcall wait_for_semaphore(sem_t *semaphore, const char *filename, const char *function_name, int line_number)
{
  int wait_result; // r0
  int errno_val; // r3
  char log_message[2072]; // [sp+10h] [bp-818h] BYREF

  while ( 1 )
  {
    wait_result = sem_wait(semaphore);
    if ( !wait_result )
      break;
    errno_val = *_errno_location();
    if ( errno_val != 4 )
    {
      snprintf(
        log_message,
        2048u,
        "Failed to sem_wait errno=%d cgsem=0x%p in %s %s():%d",
        errno_val,
        semaphore,
        filename,
        function_name,
        line_number);
      log_event(3, log_message, 1);
      shutdown_miner_safely(1);
    }
  }
  return wait_result;
}
// 3AADC: using guessed type void __fastcall __noreturn sub_3AADC(_DWORD);

//----- (00021FB8) --------------------------------------------------------
int __fastcall wait_for_semaphore_with_timeout(
        sem_t *semaphore,
        int timeout_ms,
        const char *file_name,
        const char *function_name,
        int line_number)
{
  __int64 timeout_ms_64; // r2
  __time_t current_seconds; // r10
  int current_nano_to_micro; // r5
  int nano_sum; // r3
  __time_t seconds_sum; // r2
  bool is_within_nano_limit; // cc
  int adjusted_nano; // r1
  __time_t adjusted_seconds; // r0
  int wait_result; // r0
  struct timespec timeout_time; // [sp+18h] [bp-830h] BYREF
  struct timespec current_time; // [sp+20h] [bp-828h] BYREF

  clock_gettime(1, &current_time);
  timeout_ms_64 = timeout_ms;
  current_seconds = current_time.tv_sec;
  current_nano_to_micro = 1000 * (current_time.tv_nsec / 1000);
  calculate_hashrate(&timeout_time, current_time.tv_nsec / 1000, timeout_ms_64, HIDWORD(timeout_ms_64));
  while ( 1 )
  {
    nano_sum = current_nano_to_micro + timeout_time.tv_nsec;
    seconds_sum = current_seconds + timeout_time.tv_sec;
    is_within_nano_limit = current_nano_to_micro + timeout_time.tv_nsec <= 999999999;
    timeout_time.tv_sec += current_seconds;
    timeout_time.tv_nsec += current_nano_to_micro;
    if ( is_within_nano_limit )
    {
      if ( nano_sum < 0 )
      {
        do
        {
          nano_sum += 1000000000;
          --seconds_sum;
        }
        while ( nano_sum < 0 );
        timeout_time.tv_sec = seconds_sum;
        timeout_time.tv_nsec = nano_sum;
      }
    }
    else
    {
      adjusted_nano = nano_sum - 1000000000;
      adjusted_seconds = seconds_sum + 1;
      if ( nano_sum - 1000000000 > 999999999 )
      {
        adjusted_nano = nano_sum - 2000000000;
        adjusted_seconds = seconds_sum + 2;
      }
      timeout_time.tv_sec = adjusted_seconds;
      timeout_time.tv_nsec = adjusted_nano;
    }
    wait_result = sem_timedwait(semaphore, &timeout_time);
    if ( !wait_result )
      break;
    wait_result = *_errno_location();
    if ( wait_result == 110 )
      break;
    if ( wait_result != 4 )
    {
      snprintf(
        (char *)&current_time,
        2048u,
        "Failed to sem_timedwait errno=%d cgsem=0x%p in %s %s():%d",
        wait_result,
        semaphore,
        file_name,
        function_name,
        line_number);
      log_event(3, (const char *)&current_time, 1);
      shutdown_miner_safely(1);
    }
  }
  return wait_result;
}
// 1F388: using guessed type int __fastcall sub_1F388(_DWORD, _DWORD, _DWORD, _DWORD);
// 3AADC: using guessed type void __fastcall __noreturn sub_3AADC(_DWORD);

//----- (00022100) --------------------------------------------------------
void sub_22100()
{
  JUMPOUT(139400);
}
// 22104: control flows out of bounds to 22088

//----- (00022108) --------------------------------------------------------
int *__fastcall try_lock_semaphore(sem_t *semaphore)
{
  int *lock_status; // r0

  do
  {
    while ( 1 )
    {
      lock_status = (int *)sem_trywait(semaphore);
      if ( (int)lock_status < 0 )
        break;
      if ( lock_status )
        return lock_status;
    }
    lock_status = _errno_location();
  }
  while ( *lock_status == 4 );
  return lock_status;
}

//----- (00022140) --------------------------------------------------------
bool __fastcall init_completion_timeout_thread(int timeout_secs, int timeout_nanosecs, int wait_time_secs)
{
  _DWORD *timeout_params; // r4
  int wait_result; // r5
  pthread_t timeout_thread; // [sp+Ch] [bp-1Ch] BYREF

  timeout_params = (_DWORD *)safe_malloc_with_logging(24, "util.c", "cg_completion_timeout", 4002);
  initialize_semaphore_with_logging(timeout_params, "util.c", "cg_completion_timeout", 4003);
  timeout_params[4] = timeout_secs;
  timeout_params[5] = timeout_nanosecs;
  pthread_create(&timeout_thread, 0, (void *(*)(void *))completion_thread_function, timeout_params);
  wait_result = wait_for_semaphore_with_timeout(timeout_params, wait_time_secs, "util.c", "cg_completion_timeout", 4009);
  if ( wait_result )
  {
    pthread_cancel(timeout_thread);
    return wait_result == 0;
  }
  else
  {
    pthread_join(timeout_thread, 0);
    free(timeout_params);
    return 1;
  }
}
// 1E74C: using guessed type int __fastcall sub_1E74C(_DWORD, _DWORD, _DWORD, _DWORD);
// 21DF8: using guessed type int __fastcall sub_21DF8(_DWORD, _DWORD, _DWORD, _DWORD);
// 21EF4: using guessed type int sub_21EF4();
// 21FB8: using guessed type int __fastcall sub_21FB8(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0002220C) --------------------------------------------------------
void __fastcall log_memcpy_error(
        void *dest,
        const void *src,
        size_t num_bytes,
        int function_name,
        int file_name,
        int line_number)
{
  char error_message[2064]; // [sp+10h] [bp-810h] BYREF

  if ( (int)(num_bytes - 1) < 0 )
  {
    if ( !byte_70CE8 && !byte_66640 && dword_657B8 <= 2 )
      return;
    snprintf(
      error_message,
      2048u,
      "ERR: Asked to memcpy %u bytes from %s %s():%d",
      num_bytes,
      function_name,
      file_name,
      line_number);
LABEL_9:
    log_event(3, error_message, 0);
    return;
  }
  if ( !dest )
  {
    if ( !byte_70CE8 && !byte_66640 && dword_657B8 <= 2 )
      return;
    snprintf(
      error_message,
      2048u,
      "ERR: Asked to memcpy %u bytes to NULL from %s %s():%d",
      num_bytes,
      function_name,
      file_name,
      line_number);
    goto LABEL_9;
  }
  if ( src )
  {
    memcpy(dest, src, num_bytes);
    return;
  }
  if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
  {
    snprintf(
      error_message,
      2048u,
      "ERR: Asked to memcpy %u bytes from NULL from %s %s():%d",
      num_bytes,
      function_name,
      file_name,
      line_number);
    goto LABEL_9;
  }
}
// 657B8: using guessed type int dword_657B8;
// 66640: using guessed type char byte_66640;
// 70CE8: using guessed type char byte_70CE8;

//----- (0002251C) --------------------------------------------------------
void __fastcall copy_system_time(void *destination, const void *source)
{
  log_memcpy_error(destination, source, 8u, (int)"util.c", (int)"copy_time", 1234);
}

//----- (00022550) --------------------------------------------------------
int __fastcall parse_notify_message(int miner_index, int message)
{
  _DWORD *job_id_data; // r0
  _DWORD *job_id_ptr; // r5
  int parse_result; // r6
  int merkle_count; // r9
  int merkle_index; // r4
  void *merkle_data; // r7
  char *error_msg; // r4
  char *error_msg_ptr; // r12
  char *job_id; // r7
  char *ntime_ptr; // r0
  int is_ntime_valid; // r3
  int clean_jobs_flag_ptr; // r0
  bool clean_jobs_flag; // r4
  signed int str_len; // r0
  char *job_id_iter; // r2
  int ascii_val; // r3
  int cur_char; // t1
  void *prev_hash_buffer; // r0
  const char *job_id_str; // r3
  double prev_difficulty; // d7
  int merkle_data_index; // r4
  char *coinbase1_length; // r1
  int coinbase2_offset; // r2
  char *coinbase2_ptr; // r3
  size_t coinbase2_length; // r1
  void *merkle_data_mem; // r0
  int coinbase_buffer; // r0
  int coinbase1_size; // r12
  int coinbase_hash_flag; // r8
  int mutex_unlock_result; // r0
  char *log_msg_prev_hash; // r7
  char *log_msg_coinbase1; // r7
  char *log_msg_coinbase2; // r5
  char *log_msg_nbit; // r7
  char *log_msg_ntime; // r7
  char *log_msg_clean; // r4
  const char *clean_status; // r3
  int prev_count; // r2
  int cur_count; // r1
  int miner_index_incremented; // r0
  const char *error_message; // r12
  int error_code1; // r0
  int error_code2; // r1
  int error_code3; // r2
  int error_code4; // r3
  int *error_message_ptr; // r12
  int error_val1; // r0
  int error_val2; // r1
  int error_val3; // r2
  int error_val4; // r3
  int error_val5; // r0
  int error_val6; // r1
  int error_val7; // r2
  int error_val8; // r3
  int error_val9; // r12
  const char *coinbase_hash; // r0
  char *coinbase_hash_str; // r5
  const char *header_error_message; // lr
  int header_error_code1; // r0
  int header_error_code2; // r1
  int header_error_code3; // r2
  int header_error_code4; // r3
  int *header_error_message_ptr; // lr
  int header_error_val1; // r0
  int header_error_val2; // r1
  int header_error_val3; // r2
  int header_error_val4; // r3
  int header_error_val5; // r0
  int header_error_val6; // r1
  int header_error_val7; // r2
  int header_error_val8; // r3
  int header_error_val9; // r1
  int merkle_data_buffer; // r0
  int merkle_index_2; // r4
  void *merkle_data_2; // r7
  int merkle_data_mem_addr; // r6
  int merkle_data_size_2; // r0
  char *log_msg; // r3
  char coinbase_buffer_val[4]; // [sp+18h] [bp-964h] BYREF
  char *byte_66641_ref; // [sp+1Ch] [bp-960h]
  const char *util_c_ref; // [sp+20h] [bp-95Ch]
  int data_offset; // [sp+24h] [bp-958h]
  int miner_data_offset_lock; // [sp+28h] [bp-954h]
  int miner_index_lock; // [sp+2Ch] [bp-950h]
  char *final_coinbase_ptr; // [sp+30h] [bp-94Ch]
  const char *nbit; // [sp+34h] [bp-948h]
  const char *ntime; // [sp+38h] [bp-944h]
  const char *bbversion; // [sp+3Ch] [bp-940h]
  const char *prev_hash; // [sp+40h] [bp-93Ch]
  char *job_id_ref; // [sp+44h] [bp-938h]
  char *byte_70E20_ref; // [sp+48h] [bp-934h]
  size_t coinbase2_length_actual; // [sp+4Ch] [bp-930h]
  struct timeval *clean_jobs_flag_tv; // [sp+50h] [bp-92Ch]
  const char *unknown; // [sp+54h] [bp-928h]
  const char *nbit_str; // [sp+58h] [bp-924h]
  const char *bbversion_str; // [sp+5Ch] [bp-920h]
  const char *prev_hash_str; // [sp+60h] [bp-91Ch]
  char *coinbase2; // [sp+64h] [bp-918h]
  void *coinbase1; // [sp+68h] [bp-914h]
  char *log_buffer; // [sp+6Ch] [bp-910h]
  timeval timeval_struct[28]; // [sp+74h] [bp-908h] BYREF
  _DWORD log_buffer_arr[9]; // [sp+158h] [bp-824h] BYREF
  int header_error_val10; // [sp+17Ch] [bp-800h]
  int header_error_val11; // [sp+180h] [bp-7FCh]
  int header_error_val12; // [sp+184h] [bp-7F8h]
  int header_error_val13; // [sp+188h] [bp-7F4h]
  __int16 header_error_val14; // [sp+18Ch] [bp-7F0h]
  char header_error_val15; // [sp+18Eh] [bp-7EEh]

  job_id_data = (_DWORD *)get_task_by_index(message, 4);
  job_id_ptr = job_id_data;
  if ( job_id_data && *job_id_data == 1 )
  {
    merkle_count = get_next_structure_pointer(job_id_data);
    if ( merkle_count > 0 )
    {
      merkle_index = 0;
      parse_result = 0;
      while ( 1 )
      {
        memset(timeval_struct, 0, 32u);
        merkle_data = (void *)get_info_duplicate_if_not_null(job_id_ptr, merkle_index);
        if ( !merkle_data )
          return parse_result;
        parse_result = hex_string_to_binary(timeval_struct, merkle_data);
        if ( !parse_result )
          break;
        ++merkle_index;
        free(merkle_data);
        if ( merkle_count == merkle_index )
          goto LABEL_21;
      }
      if ( !byte_70CE8 && !byte_66640 && dword_657B8 <= 2
        || (log_buffer = (char *)log_buffer_arr,
            snprintf((char *)log_buffer_arr, 2048u, "merkle %d: %s", merkle_index, (const char *)merkle_data),
            log_event(3, log_buffer_arr, 0),
            !byte_70CE8)
        && !byte_66640 )
      {
        if ( dword_657B8 <= 2 )
        {
LABEL_17:
          free(merkle_data);
          return parse_result;
        }
        log_buffer = (char *)log_buffer_arr;
      }
      error_msg = log_buffer;
      error_msg_ptr = log_buffer;
      *(_DWORD *)log_buffer = *(_DWORD *)"Failed to convert merkle to merkle_bin in parse_notify";
      strcpy(error_msg_ptr + 4, "ed to convert merkle to merkle_bin in parse_notify");
      log_event(3, error_msg, 0);
      goto LABEL_17;
    }
    parse_result = 0;
LABEL_21:
    job_id = (char *)get_info_duplicate_if_not_null(message, 0);
    prev_hash_str = (const char *)check_status_and_get_info(message, 1);
    coinbase1 = (void *)get_info_duplicate_if_not_null(message, 2);
    coinbase2 = (char *)get_info_duplicate_if_not_null(message, 3);
    bbversion_str = (const char *)check_status_and_get_info(message, 5);
    nbit_str = (const char *)check_status_and_get_info(message, 6);
    unknown = (const char *)check_status_and_get_info(message, 7);
    ntime_ptr = (char *)strtol(unknown, 0, 16);
    if ( ntime_ptr )
      is_ntime_valid = ((unsigned __int8)byte_68735 ^ 1) & 1;
    else
      is_ntime_valid = 0;
    if ( is_ntime_valid )
    {
      log_buffer = ntime_ptr;
      timeval_struct[0].tv_usec = 0;
      clean_jobs_flag_tv = timeval_struct;
      timeval_struct[0].tv_sec = 0;
      gettimeofday(timeval_struct, 0);
      if ( (unsigned int)log_buffer > timeval_struct[0].tv_sec )
      {
        timeval_struct[0].tv_sec = (__time_t)log_buffer;
        settimeofday(clean_jobs_flag_tv, 0);
        if ( byte_70CE8 || byte_66640 || dword_657B8 > 4 )
        {
          log_buffer = (char *)log_buffer_arr;
          strcpy((char *)log_buffer_arr, "settime notify.ntime successfuly");
          log_event(5, log_buffer_arr, 0);
        }
        byte_68735 = 1;
      }
    }
    clean_jobs_flag_ptr = get_task_by_index(message, 8);
    clean_jobs_flag = clean_jobs_flag_ptr;
    if ( clean_jobs_flag_ptr )
    {
      clean_jobs_flag = *(_DWORD *)get_task_by_index(message, 8) == 5;
      clean_jobs_flag_tv = (struct timeval *)clean_jobs_flag;
    }
    else
    {
      clean_jobs_flag_tv = 0;
    }
    if ( job_id )
    {
      str_len = strlen(job_id);
      if ( str_len )
      {
        job_id_iter = job_id;
        while ( 1 )
        {
          cur_char = (unsigned __int8)*job_id_iter++;
          ascii_val = cur_char;
          if ( (unsigned int)(cur_char - 32) > 94 )
            break;
          if ( str_len <= job_id_iter - job_id )
          {
            if ( !validate_hex_string(prev_hash_str, "parse_notify", 2027)
              || !validate_hex_string(coinbase1, "parse_notify", 2027)
              || !validate_hex_string(coinbase2, "parse_notify", 2028)
              || !validate_hex_string(bbversion_str, "parse_notify", 2028)
              || !validate_hex_string(nbit_str, "parse_notify", 2028)
              || !validate_hex_string(unknown, "parse_notify", 2029) )
            {
              goto LABEL_39;
            }
            miner_index_lock = miner_index + 212;
            if ( pthread_mutex_lock((pthread_mutex_t *)(miner_index + 212)) )
              log_mutex_error_and_terminate("parse_notify", 2038);
            miner_data_offset_lock = miner_index + 236;
            write_lock_and_log_error(miner_index + 236, "parse_notify", 2038);
            prev_hash_buffer = *(void **)(miner_index + 672);
            prev_hash = (const char *)(miner_index + 1712);
            free(prev_hash_buffer);
            job_id_str = prev_hash_str;
            *(_DWORD *)(miner_index + 672) = job_id;
            snprintf((char *)(miner_index + 1712), 65u, "%s", job_id_str);
            log_buffer = (char *)(strlen((const char *)coinbase1) >> 1);
            bbversion = (const char *)(miner_index + 1780);
            coinbase2_length_actual = strlen(coinbase2) >> 1;
            snprintf((char *)(miner_index + 1780), 9u, "%s", bbversion_str);
            ntime = (const char *)(miner_index + 1792);
            snprintf((char *)(miner_index + 1792), 9u, "%s", nbit_str);
            nbit = (const char *)(miner_index + 1804);
            snprintf((char *)(miner_index + 1804), 9u, "%s", unknown);
            *(_BYTE *)(miner_index + 680) = clean_jobs_flag;
            prev_difficulty = *(double *)(miner_index + 1816);
            merkle_data_index = 0;
            coinbase1_length = log_buffer;
            if ( prev_difficulty > 0.0 )
              *(double *)(miner_index + 1824) = prev_difficulty;
            coinbase2_offset = *(_DWORD *)(miner_index + 632);
            coinbase2_ptr = &coinbase1_length[*(_DWORD *)(miner_index + 1564)];
            coinbase2_length = coinbase2_length_actual;
            *(_DWORD *)(miner_index + 1576) = coinbase2_ptr;
            final_coinbase_ptr = &coinbase2_ptr[coinbase2_length + coinbase2_offset];
            *(_DWORD *)(miner_index + 1572) = final_coinbase_ptr;
            while ( *(_DWORD *)(miner_index + 1708) > merkle_data_index )
            {
              merkle_data_mem = *(void **)(*(_DWORD *)(miner_index + 676) + 4 * merkle_data_index++);
              free(merkle_data_mem);
            }
            if ( merkle_count )
            {
              merkle_data_buffer = realloc_with_logging(
                                     *(_DWORD *)(miner_index + 676),
                                     4 * merkle_count + 1,
                                     "util.c",
                                     "parse_notify",
                                     2059);
              byte_70E20_ref = &byte_70E20;
              merkle_index_2 = 0;
              *(_DWORD *)(miner_index + 676) = merkle_data_buffer;
              util_c_ref = "util.c";
              byte_66641_ref = &byte_66641;
              job_id_ref = job_id;
              do
              {
                data_offset = 4 * merkle_index_2;
                if ( merkle_index_2 >= merkle_count )
                {
                  job_id = job_id_ref;
                  *(_DWORD *)(miner_index + 1708) = merkle_count;
                  if ( merkle_count > 1 )
                    goto LABEL_69;
                  goto LABEL_68;
                }
                merkle_data_2 = (void *)get_info_duplicate_if_not_null(job_id_ptr, merkle_index_2);
                merkle_data_mem_addr = *(_DWORD *)(miner_index + 676);
                merkle_data_size_2 = safe_malloc_with_logging(32, util_c_ref, "parse_notify", 2064);
                log_msg = byte_70E20_ref;
                *(_DWORD *)(merkle_data_mem_addr + 4 * merkle_index_2) = merkle_data_size_2;
                if ( *log_msg && *byte_66641_ref && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
                {
                  snprintf((char *)log_buffer_arr, 2048u, "merkle %d: %s", merkle_index_2, merkle_data_2);
                  log_event(7, log_buffer_arr, 0);
                }
                ++merkle_index_2;
                parse_result = hex_string_to_binary(
                                 *(_DWORD *)(*(_DWORD *)(miner_index + 676) + data_offset),
                                 merkle_data_2);
                free(merkle_data_2);
              }
              while ( parse_result );
              job_id = job_id_ref;
              if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
              {
                header_error_message = "Failed to convert merkle to merkle_bin in parse_notify";
                goto LABEL_146;
              }
              goto LABEL_137;
            }
            *(_DWORD *)(miner_index + 1708) = 0;
            byte_70E20_ref = &byte_70E20;
LABEL_68:
            ++*(_QWORD *)(miner_index + 376);
LABEL_69:
            if ( clean_jobs_flag_tv )
              *(_QWORD *)(miner_index + 624) = 0LL;
            snprintf(
              (char *)timeval_struct,
              225u,
              "%s%s%s%s%s%s%s",
              bbversion,
              prev_hash,
              "0000000000000000000000000000000000000000000000000000000000000000",
              nbit,
              ntime,
              "00000000",
              off_661F0);
            parse_result = hex_string_to_binary(miner_index + 1580, timeval_struct);
            if ( parse_result )
            {
              parse_result = hex_string_to_binary(coinbase_buffer_val, coinbase1);
              if ( parse_result )
              {
                parse_result = hex_string_to_binary(coinbase_buffer_val, coinbase2);
                if ( parse_result )
                {
                  free(*(void **)(miner_index + 1568));
                  coinbase_buffer = allocate_and_log_on_fail(final_coinbase_ptr, 1, "util.c", "parse_notify", 2121);
                  *(_DWORD *)(miner_index + 1568) = coinbase_buffer;
                  log_memcpy_error(coinbase_buffer, coinbase_buffer_val, log_buffer, "util.c", "parse_notify", 2122);
                  coinbase1_size = *(_DWORD *)(miner_index + 1564);
                  if ( coinbase1_size )
                  {
                    log_memcpy_error(
                      &log_buffer[*(_DWORD *)(miner_index + 1568)],
                      *(_DWORD *)(miner_index + 616),
                      coinbase1_size,
                      "util.c",
                      "parse_notify",
                      2124);
                    coinbase1_size = *(_DWORD *)(miner_index + 1564);
                  }
                  log_memcpy_error(
                    &log_buffer[coinbase1_size + *(_DWORD *)(miner_index + 632) + *(_DWORD *)(miner_index + 1568)],
                    coinbase_buffer_val,
                    coinbase2_length_actual,
                    "util.c",
                    "parse_notify",
                    2125);
                  coinbase_hash_flag = (unsigned __int8)byte_66641;
                  if ( byte_66641 )
                  {
                    coinbase_hash = (const char *)binary_to_hex_string(
                                                    *(_DWORD *)(miner_index + 1568),
                                                    *(_DWORD *)(miner_index + 1572));
                    coinbase_hash_str = (char *)coinbase_hash;
                    if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
                    {
                      snprintf(
                        (char *)log_buffer_arr,
                        2048u,
                        "Pool %d coinbase %s",
                        *(_DWORD *)miner_index,
                        coinbase_hash);
                      log_event(7, log_buffer_arr, 0);
                    }
                    parse_result = coinbase_hash_flag;
                    free(coinbase_hash_str);
                  }
                  goto LABEL_77;
                }
                if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
                {
                  error_message = "Failed to convert cb2 to cb2_bin in parse_notify";
LABEL_130:
                  error_code1 = *(_DWORD *)error_message;
                  error_code2 = *((_DWORD *)error_message + 1);
                  error_code3 = *((_DWORD *)error_message + 2);
                  error_code4 = *((_DWORD *)error_message + 3);
                  error_message_ptr = (int *)(error_message + 16);
                  log_buffer_arr[0] = error_code1;
                  log_buffer_arr[1] = error_code2;
                  log_buffer_arr[2] = error_code3;
                  log_buffer_arr[3] = error_code4;
                  error_val1 = *error_message_ptr;
                  error_val2 = error_message_ptr[1];
                  error_val3 = error_message_ptr[2];
                  error_val4 = error_message_ptr[3];
                  error_message_ptr += 4;
                  log_buffer_arr[4] = error_val1;
                  log_buffer_arr[5] = error_val2;
                  log_buffer_arr[6] = error_val3;
                  log_buffer_arr[7] = error_val4;
                  error_val5 = *error_message_ptr;
                  error_val6 = error_message_ptr[1];
                  error_val7 = error_message_ptr[2];
                  error_val8 = error_message_ptr[3];
                  error_val9 = error_message_ptr[4];
                  log_buffer_arr[8] = error_val5;
                  header_error_val10 = error_val6;
                  header_error_val11 = error_val7;
                  header_error_val12 = error_val8;
                  LOBYTE(header_error_val13) = error_val9;
                  log_event(3, log_buffer_arr, 0);
                  goto LABEL_77;
                }
              }
              else if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
              {
                error_message = (const char *)&unk_4BFFC;
                goto LABEL_130;
              }
LABEL_137:
              parse_result = 0;
              goto LABEL_77;
            }
            if ( !byte_70CE8 && !byte_66640 && dword_657B8 <= 2 )
              goto LABEL_137;
            header_error_message = "Failed to convert header to header_bin in parse_notify";
LABEL_146:
            header_error_code1 = *(_DWORD *)header_error_message;
            header_error_code2 = *((_DWORD *)header_error_message + 1);
            header_error_code3 = *((_DWORD *)header_error_message + 2);
            header_error_code4 = *((_DWORD *)header_error_message + 3);
            header_error_message_ptr = (int *)(header_error_message + 16);
            log_buffer_arr[0] = header_error_code1;
            log_buffer_arr[1] = header_error_code2;
            log_buffer_arr[2] = header_error_code3;
            log_buffer_arr[3] = header_error_code4;
            header_error_val1 = *header_error_message_ptr;
            header_error_val2 = header_error_message_ptr[1];
            header_error_val3 = header_error_message_ptr[2];
            header_error_val4 = header_error_message_ptr[3];
            header_error_message_ptr += 4;
            log_buffer_arr[4] = header_error_val1;
            log_buffer_arr[5] = header_error_val2;
            log_buffer_arr[6] = header_error_val3;
            log_buffer_arr[7] = header_error_val4;
            header_error_val5 = *header_error_message_ptr;
            header_error_val6 = header_error_message_ptr[1];
            header_error_val7 = header_error_message_ptr[2];
            header_error_val8 = header_error_message_ptr[3];
            header_error_message_ptr += 4;
            log_buffer_arr[8] = header_error_val5;
            header_error_val10 = header_error_val6;
            header_error_val11 = header_error_val7;
            header_error_val12 = header_error_val8;
            header_error_val9 = header_error_message_ptr[1];
            header_error_val13 = *header_error_message_ptr;
            header_error_val14 = header_error_val9;
            header_error_val15 = BYTE2(header_error_val9);
            log_event(3, log_buffer_arr, 0);
LABEL_77:
            unlock_rwlock_log_error(miner_data_offset_lock, "parse_notify", 2134);
            mutex_unlock_result = unlock_mutex_and_log_error(miner_index_lock, "parse_notify", 2134);
            off_658DC(mutex_unlock_result);
            if ( !*byte_70E20_ref )
              goto LABEL_123;
            if ( !byte_66641 )
              goto LABEL_98;
            if ( byte_70CE8 || byte_66640 || dword_657B8 > 6 )
            {
              log_buffer = (char *)log_buffer_arr;
              snprintf((char *)log_buffer_arr, 2048u, "job_id: %s", job_id);
              log_event(7, log_buffer_arr, 0);
              if ( byte_66641 )
              {
                if ( !byte_70CE8 )
                  goto LABEL_84;
LABEL_87:
                log_msg_prev_hash = log_buffer;
                snprintf(log_buffer, 2048u, "prev_hash: %s", prev_hash_str);
                log_event(7, log_msg_prev_hash, 0);
                if ( byte_66641 )
                {
                  if ( !byte_70CE8 )
                    goto LABEL_89;
LABEL_92:
                  log_msg_coinbase1 = log_buffer;
                  snprintf(log_buffer, 2048u, "coinbase1: %s", (const char *)coinbase1);
                  log_event(7, log_msg_coinbase1, 0);
                  if ( byte_66641 )
                  {
                    if ( !byte_70CE8 )
                      goto LABEL_94;
LABEL_97:
                    log_msg_coinbase2 = log_buffer;
                    snprintf(log_buffer, 2048u, "coinbase2: %s", coinbase2);
                    log_event(7, log_msg_coinbase2, 0);
LABEL_98:
                    if ( byte_66641 )
                    {
                      if ( !byte_70CE8 )
                        goto LABEL_100;
                      goto LABEL_102;
                    }
LABEL_123:
                    free(coinbase1);
                    free(coinbase2);
                    prev_count = dword_72EE0;
                    cur_count = dword_72EE4;
                    miner_index_incremented = *(_DWORD *)(miner_index + 116) + 1;
                    *(_DWORD *)(miner_index + 116) = miner_index_incremented;
                    *(_QWORD *)&dword_72EE0 = __PAIR64__(cur_count, prev_count) + 1;
                    if ( miner_index == get_current_pool_index(miner_index_incremented) )
                      byte_73FC0 = 1;
                    return parse_result;
                  }
LABEL_115:
                  if ( !byte_66641 )
                    goto LABEL_123;
                  if ( !byte_70CE8 )
                  {
LABEL_117:
                    if ( !byte_66640 && dword_657B8 <= 6 )
                      goto LABEL_123;
                    log_buffer = (char *)log_buffer_arr;
                  }
                  log_msg_clean = log_buffer;
                  clean_status = "yes";
                  if ( !clean_jobs_flag_tv )
                    clean_status = "no";
                  snprintf(log_buffer, 2048u, "clean: %s", clean_status);
                  log_event(7, log_msg_clean, 0);
                  goto LABEL_123;
                }
LABEL_109:
                if ( !byte_66641 )
                  goto LABEL_123;
                if ( !byte_70CE8 )
                {
LABEL_111:
                  if ( !byte_66640 && dword_657B8 <= 6 )
                    goto LABEL_117;
                  log_buffer = (char *)log_buffer_arr;
                }
                log_msg_ntime = log_buffer;
                snprintf(log_buffer, 2048u, "ntime: %s", unknown);
                log_event(7, log_msg_ntime, 0);
                goto LABEL_115;
              }
LABEL_103:
              if ( !byte_66641 )
                goto LABEL_123;
              if ( !byte_70CE8 )
                goto LABEL_105;
            }
            else
            {
LABEL_84:
              if ( byte_66640 || dword_657B8 > 6 )
              {
                log_buffer = (char *)log_buffer_arr;
                goto LABEL_87;
              }
LABEL_89:
              if ( byte_66640 || dword_657B8 > 6 )
              {
                log_buffer = (char *)log_buffer_arr;
                goto LABEL_92;
              }
LABEL_94:
              if ( byte_66640 || dword_657B8 > 6 )
              {
                log_buffer = (char *)log_buffer_arr;
                goto LABEL_97;
              }
LABEL_100:
              if ( byte_66640 || dword_657B8 > 6 )
              {
LABEL_102:
                log_buffer = (char *)log_buffer_arr;
                snprintf((char *)log_buffer_arr, 2048u, "bbversion: %s", bbversion_str);
                log_event(7, log_buffer_arr, 0);
                goto LABEL_103;
              }
LABEL_105:
              if ( !byte_66640 && dword_657B8 <= 6 )
                goto LABEL_111;
              log_buffer = (char *)log_buffer_arr;
            }
            log_msg_nbit = log_buffer;
            snprintf(log_buffer, 2048u, "nbit: %s", nbit_str);
            log_event(7, log_msg_nbit, 0);
            goto LABEL_109;
          }
        }
        if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
        {
          snprintf(
            (char *)log_buffer_arr,
            2048u,
            "Invalid char 0x%x passed to valid_ascii from in %s %s():%d",
            ascii_val,
            "util.c",
            "parse_notify",
            2027);
          goto LABEL_38;
        }
        goto LABEL_39;
      }
      if ( !byte_70CE8 && !byte_66640 && dword_657B8 <= 2 )
      {
LABEL_39:
        free(job_id);
        free(coinbase1);
        free(coinbase2);
        return parse_result;
      }
      snprintf(
        (char *)log_buffer_arr,
        2048u,
        "Zero length string passed to valid_ascii from in %s %s():%d",
        "util.c",
        "parse_notify",
        2027);
    }
    else
    {
      if ( !byte_70CE8 && !byte_66640 && dword_657B8 <= 2 )
        goto LABEL_39;
      snprintf(
        (char *)log_buffer_arr,
        2048u,
        "Null string passed to valid_ascii from in %s %s():%d",
        "util.c",
        "parse_notify",
        2027);
    }
LABEL_38:
    log_event(3, log_buffer_arr, 0);
    goto LABEL_39;
  }
  return 0;
}
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 1DA28: using guessed type int sub_1DA28(void);
// 1E24C: using guessed type int __fastcall sub_1E24C(_DWORD, _DWORD);
// 1E2B0: using guessed type int __fastcall sub_1E2B0(_DWORD, _DWORD);
// 1E330: using guessed type int __fastcall sub_1E330(_DWORD, _DWORD, _DWORD);
// 1E480: using guessed type int __fastcall sub_1E480(_DWORD, _DWORD, _DWORD);
// 1E4FC: using guessed type int __fastcall sub_1E4FC(_DWORD, _DWORD, _DWORD);
// 1E578: using guessed type int __fastcall sub_1E578(_DWORD, _DWORD, _DWORD);
// 1E5F4: using guessed type void __fastcall __noreturn sub_1E5F4(_DWORD, _DWORD);
// 1E74C: using guessed type int __fastcall sub_1E74C(_DWORD, _DWORD, _DWORD, _DWORD);
// 1E7D4: using guessed type int __fastcall sub_1E7D4(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1E864: using guessed type int __fastcall sub_1E864(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1E9B4: using guessed type int __fastcall sub_1E9B4(_DWORD, _DWORD);
// 1EA68: using guessed type int __fastcall sub_1EA68(_DWORD, _DWORD);
// 2220C: using guessed type int __fastcall sub_2220C(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 2E47C: using guessed type int __fastcall sub_2E47C(_DWORD);
// 47658: using guessed type int __fastcall sub_47658(_DWORD);
// 47674: using guessed type int __fastcall sub_47674(_DWORD, _DWORD);
// 657B8: using guessed type int dword_657B8;
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);
// 661F0: using guessed type char *off_661F0;
// 66640: using guessed type char byte_66640;
// 66641: using guessed type char byte_66641;
// 68735: using guessed type char byte_68735;
// 70CE8: using guessed type char byte_70CE8;
// 70E20: using guessed type char byte_70E20;
// 72EE0: using guessed type int dword_72EE0;
// 72EE4: using guessed type int dword_72EE4;
// 73FC0: using guessed type char byte_73FC0;
// 22550: using guessed type struct timeval var_908;
// 22550: using guessed type char var_964[4];

//----- (000236B8) --------------------------------------------------------
int __fastcall perform_socks4_negotiation(const char **params, int socket_descriptor, int proxy_enable)
{
  __int16 strtol_result; // kr00_2
  unsigned int ip_address; // r10
  const char *param_ip_address; // r0
  const char *ip_address_str; // r10
  size_t ip_address_length; // r0
  int clamped_ip_length; // r8
  int dummy_recv_counter; // r4
  unsigned int addrinfo_ip; // r10
  struct addrinfo *addrinfo_ptr; // [sp+8h] [bp-A48h] BYREF
  char addrinfo_local_var; // [sp+Ch] [bp-A44h] BYREF
  __int16 socks4_req_header; // [sp+2Ch] [bp-A24h] BYREF
  char socks4_req_version; // [sp+2Eh] [bp-A22h]
  char socks4_req_command; // [sp+2Fh] [bp-A21h]
  int socks4_req_port; // [sp+30h] [bp-A20h]
  char socks4_req_userid[8]; // [sp+34h] [bp-A1Ch] BYREF
  _BYTE socks4_req_buffer[500]; // [sp+3Ch] [bp-A14h] BYREF
  struct addrinfo addrinfo_flags[64]; // [sp+230h] [bp-820h] BYREF

  socks4_req_header = 260;
  strtol_result = strtol(params[146], 0, 10);
  socks4_req_version = HIBYTE(strtol_result);
  socks4_req_command = strtol_result;
  strcpy(socks4_req_userid, "CGMINER");
  ip_address = bswap32(inet_addr(params[150]));
  if ( ip_address != -1 )
    goto LABEL_2;
  addrinfo_ptr = (struct addrinfo *)&addrinfo_local_var;
  memset(addrinfo_flags, 0, 32u);
  param_ip_address = params[150];
  addrinfo_flags[0].ai_family = 2;
  if ( !getaddrinfo(param_ip_address, 0, addrinfo_flags, &addrinfo_ptr) )
  {
    addrinfo_ip = *(_DWORD *)&addrinfo_ptr->ai_addr->sa_data[2];
    freeaddrinfo(addrinfo_ptr);
    ip_address = bswap32(addrinfo_ip);
    if ( ip_address != -1 )
    {
LABEL_2:
      HIBYTE(socks4_req_port) = ip_address;
      LOBYTE(socks4_req_port) = HIBYTE(ip_address);
      BYTE1(socks4_req_port) = BYTE2(ip_address);
      BYTE2(socks4_req_port) = BYTE1(ip_address);
      send(socket_descriptor, &socks4_req_header, 16u, 0);
      goto LABEL_3;
    }
LABEL_23:
    if ( byte_70CE8 || byte_66640 || dword_657B8 > 3 )
    {
      snprintf((char *)addrinfo_flags, 2048u, "Invalid IP address specified for socks4 proxy: %s", params[150]);
      goto LABEL_9;
    }
    return 0;
  }
  if ( !proxy_enable )
    goto LABEL_23;
  ip_address_str = params[150];
  socks4_req_port = 16777216;
  ip_address_length = strlen(ip_address_str);
  if ( ip_address_length >= 255 )
    clamped_ip_length = 255;
  else
    clamped_ip_length = ip_address_length;
  log_memcpy_error(socks4_req_buffer, ip_address_str, clamped_ip_length, "util.c", "socks4_negotiate", 2981);
  socks4_req_buffer[clamped_ip_length] = 0;
  send(socket_descriptor, &socks4_req_header, clamped_ip_length + 17, 0);
LABEL_3:
  if ( recv(socket_descriptor, addrinfo_flags, 1u, 0) == -1
    || LOBYTE(addrinfo_flags[0].ai_flags)
    || recv(socket_descriptor, addrinfo_flags, 1u, 0) == -1
    || LOBYTE(addrinfo_flags[0].ai_flags) != 90 )
  {
    if ( byte_70CE8 || byte_66640 || dword_657B8 > 3 )
    {
      snprintf((char *)addrinfo_flags, 2048u, "Bad response from %s:%s SOCKS4 server", params[151], params[152]);
LABEL_9:
      log_event(4, addrinfo_flags, 0);
      return 0;
    }
    return 0;
  }
  dummy_recv_counter = 6;
  do
  {
    recv(socket_descriptor, addrinfo_flags, 1u, 0);
    --dummy_recv_counter;
  }
  while ( dummy_recv_counter );
  return 1;
}
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 2220C: using guessed type int __fastcall sub_2220C(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 657B8: using guessed type int dword_657B8;
// 66640: using guessed type char byte_66640;
// 70CE8: using guessed type char byte_70CE8;

//----- (00023974) --------------------------------------------------------
int __fastcall sub_23974(int a1)
{
  pthread_mutex_t *v1; // r4
  int v2; // r11
  int v3; // r0
  int v4; // r3
  int v5; // r0
  struct addrinfo *v6; // r6
  int v7; // r0
  int v8; // r7
  int v9; // r0
  int *v10; // r11
  int v11; // r4
  _DWORD *v13; // r12
  int v14; // r0
  int v15; // r1
  int v16; // r2
  __int16 v17; // r3
  int v18; // r3
  _DWORD *v19; // r8
  int v20; // r10
  fd_set *p_ai_next; // r3
  int v22; // r0
  int v23; // r3
  int v24; // r5
  int v25; // r0
  int v26; // r4
  int v27; // r2
  int *v28; // r0
  int *v29; // r0
  int v30; // r0
  void *v31; // r5
  int v32; // r2
  int v33; // r2
  const char *v34; // r6
  size_t v35; // r0
  int v36; // r5
  __int16 v37; // r0
  char *v38; // r12
  int v39; // r5
  int v40; // r6
  int v41; // r5
  char *service; // [sp+20h] [bp-2870h]
  char *name; // [sp+24h] [bp-286Ch]
  int v45; // [sp+2Ch] [bp-2864h]
  struct addrinfo *pai; // [sp+34h] [bp-285Ch] BYREF
  socklen_t optlen; // [sp+38h] [bp-2858h] BYREF
  int optval; // [sp+3Ch] [bp-2854h] BYREF
  struct timeval timeout; // [sp+40h] [bp-2850h] BYREF
  struct addrinfo s; // [sp+48h] [bp-2848h] BYREF
  fd_set writefds; // [sp+68h] [bp-2828h] BYREF
  _DWORD v52[2058]; // [sp+868h] [bp-2028h] BYREF

  v1 = (pthread_mutex_t *)(a1 + 704);
  v2 = a1;
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 704)) )
  {
    v29 = _errno_location();
    snprintf(
      (char *)v52,
      2048u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v29,
      "util.c",
      "setup_stratum_socket",
      3195);
    log_event(3, v52, 1);
    shutdown_miner_safely(1);
  }
  v3 = *(_DWORD *)(v2 + 588);
  *(_BYTE *)(v2 + 641) = 0;
  if ( v3 )
    close(v3);
  *(_DWORD *)(v2 + 588) = 0;
  if ( pthread_mutex_unlock(v1) )
  {
    v28 = _errno_location();
    snprintf(
      (char *)v52,
      2048u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v28,
      "util.c",
      "setup_stratum_socket",
      3213);
    log_event(3, v52, 1);
    shutdown_miner_safely(1);
  }
  off_658DC(0);
  memset(&s, 0, sizeof(s));
  v4 = *(_DWORD *)(v2 + 184);
  s.ai_socktype = 1;
  if ( v4 )
    goto LABEL_6;
  if ( !dword_68608 )
  {
    name = *(char **)(v2 + 600);
    goto LABEL_71;
  }
  *(_DWORD *)(v2 + 184) = dword_68608;
  parse_url();
  v23 = *(_DWORD *)(v2 + 184);
  *(_DWORD *)(v2 + 180) = 3;
  name = *(char **)(v2 + 600);
  if ( !v23 )
  {
LABEL_71:
    service = *(char **)(v2 + 584);
    v5 = getaddrinfo(name, service, &s, &pai);
    goto LABEL_7;
  }
LABEL_6:
  name = *(char **)(v2 + 604);
  service = *(char **)(v2 + 608);
  v5 = getaddrinfo(name, service, &s, &pai);
LABEL_7:
  if ( v5 )
  {
    if ( *(_BYTE *)(v2 + 99) )
    {
      if ( byte_70CE8 || byte_66640 || dword_657B8 > 5 )
      {
        snprintf((char *)v52, 2048u, "Failed to getaddrinfo for %s:%s", name, service);
        log_event(6, v52, 0);
      }
    }
    else
    {
      if ( byte_70CE8 || byte_66640 || dword_657B8 > 3 )
      {
        snprintf((char *)v52, 2048u, "Failed to resolve (?wrong URL) %s:%s", name, service);
        log_event(4, v52, 0);
      }
      *(_BYTE *)(v2 + 99) = 1;
    }
    _res_init();
    goto LABEL_35;
  }
  v6 = pai;
  if ( !pai )
    goto LABEL_26;
  v45 = v2;
  do
  {
    while ( 1 )
    {
      v7 = socket(v6->ai_family, v6->ai_socktype, v6->ai_protocol);
      v8 = v7;
      if ( v7 != -1 )
        break;
      if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
      {
        v13 = v52;
        v14 = *(_DWORD *)"Failed socket";
        v15 = *(_DWORD *)"ed socket";
        v16 = *(_DWORD *)"ocket";
        v17 = *(_WORD *)"t";
        goto LABEL_43;
      }
LABEL_24:
      v6 = v6->ai_next;
      if ( !v6 )
        goto LABEL_25;
    }
    v9 = fcntl(v7, 3, 0);
    fcntl(v8, 4, v9 | 0x800);
    if ( connect(v8, v6->ai_addr, v6->ai_addrlen) != -1 )
    {
      v2 = v45;
      if ( byte_70CE8 || byte_66640 || dword_657B8 > 3 )
      {
        strcpy((char *)v52, "Succeeded immediate connect");
        log_event(4, v52, 0);
      }
LABEL_67:
      disable_non_block(v8);
      freeaddrinfo(pai);
      if ( !*(_DWORD *)(v2 + 184) )
      {
LABEL_86:
        if ( !*(_DWORD *)(v2 + 592) )
        {
          *(_DWORD *)(v2 + 592) = allocate_and_log_on_fail(8192, 1, "util.c", "setup_stratum_socket", 3351);
          *(_DWORD *)(v2 + 596) = 8192;
        }
        *(_DWORD *)(v2 + 588) = v8;
        writefds.__fds_bits[0] = 45;
        v52[0] = 30;
        timeout.tv_sec = 1;
        v25 = fcntl(v8, 3, 0);
        fcntl(v8, 4, v25 | 0x800);
        setsockopt(v8, 1, 9, &timeout, 4u);
        if ( !byte_74238 )
          fcntl(v8, 2, 1);
        setsockopt(v8, 6, 1, &timeout, 4u);
        setsockopt(v8, 6, 6, &timeout, 4u);
        setsockopt(v8, 6, 4, &writefds, 4u);
        setsockopt(v8, 6, 5, v52, 4u);
        if ( byte_66224 )
        {
          v27 = dword_70D14++;
          sprintf(
            (char *)v52,
            "{\"id\":%d, \"method\":\"mining.configure\", \"params\":[[\"version-rolling\"],{\"version-rolling.mask\":\"%"
            "08x\",\"version-rolling.min-bit-count\":%d}]}",
            v27,
            536862720,
            3);
          *(_DWORD *)(v2 + 648) = 1;
        }
        strlen((const char *)v52);
        if ( send_with_timeout(v2, (char *)v52) )
        {
          if ( !byte_66641 )
            goto LABEL_102;
          if ( !byte_70CE8 && !byte_66640 && dword_657B8 <= 6 )
            goto LABEL_97;
          strcpy((char *)&writefds, "Failed to send s in initiate_stratum");
          log_event(7, &writefds, 0);
        }
        else
        {
          v11 = is_socket_ready(*(_DWORD *)(v2 + 588), 60);
          if ( v11 )
          {
            v30 = receive_socket_data(v2);
            v31 = (void *)v30;
            if ( v30 )
            {
              process_mining_configure_response(v2, v30);
              free(v31);
              if ( !*(_DWORD *)(v2 + 576) )
                *(_DWORD *)(v2 + 576) = *(_DWORD *)(v2 + 600);
              *(_BYTE *)(v2 + 641) = 1;
              if ( byte_70E20 )
              {
                v11 = (unsigned __int8)byte_66641;
                if ( byte_66641 )
                {
                  if ( byte_70CE8 || byte_66640 || dword_657B8 > 6 )
                  {
                    snprintf(
                      (char *)&writefds,
                      2048u,
                      "Pool %d confirmed mining.subscribe with extranonce1 %s extran2size %d",
                      *(_DWORD *)v2,
                      *(const char **)(v2 + 612),
                      *(_DWORD *)(v2 + 632));
                    log_event(7, &writefds, 0);
                    return v11;
                  }
                }
                else
                {
                  return (unsigned __int8)byte_70E20;
                }
              }
              return v11;
            }
          }
          else
          {
            if ( !byte_66641 )
              goto LABEL_102;
            if ( !byte_70CE8 && !byte_66640 && dword_657B8 <= 6 )
            {
LABEL_97:
              v26 = 1;
              goto LABEL_98;
            }
            strcpy((char *)&writefds, "Timed out waiting for response in initiate_stratum");
            log_event(7, &writefds, 0);
          }
        }
        if ( !byte_66641 )
          goto LABEL_102;
        goto LABEL_97;
      }
      switch ( *(_DWORD *)(v2 + 180) )
      {
        case 0:
          v33 = 0;
          goto LABEL_144;
        case 1:
          v33 = 1;
LABEL_144:
          if ( !setup_proxy_connection(v2, v8, v33) )
            goto LABEL_35;
          goto LABEL_86;
        case 2:
          v32 = 0;
          goto LABEL_129;
        case 3:
        case 5:
          LOWORD(writefds.__fds_bits[0]) = 261;
          BYTE2(writefds.__fds_bits[0]) = 0;
          if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
          {
            snprintf(
              (char *)v52,
              2048u,
              "Attempting to negotiate with %s:%s SOCKS5 proxy",
              *(const char **)(v2 + 604),
              *(const char **)(v2 + 608));
            log_event(7, v52, 0);
          }
          send(v8, &writefds, 3u, 0);
          if ( recv(v8, v52, 1u, 0) == -1
            || LOBYTE(v52[0]) != 5
            || recv(v8, v52, 1u, 0) == -1
            || BYTE2(writefds.__fds_bits[0]) != LOBYTE(v52[0]) )
          {
            if ( !byte_70CE8 && !byte_66640 && dword_657B8 <= 3 )
            {
LABEL_106:
              if ( byte_66641 && dword_657B8 > 6 )
              {
                v26 = 0;
                goto LABEL_109;
              }
              return 0;
            }
          }
          else
          {
            v34 = *(const char **)(v2 + 600);
            writefds.__fds_bits[0] = 50331909;
            v35 = strlen(v34);
            if ( v35 >= 255 )
              v36 = 255;
            else
              v36 = v35;
            LOBYTE(writefds.__fds_bits[1]) = v36;
            log_memcpy_error((char *)&writefds.__fds_bits[1] + 1, v34, v36, "util.c", "socks5_negotiate", 2879);
            v37 = strtol(*(const char **)(v2 + 584), 0, 10);
            v38 = (char *)v52 + v36;
            *(v38 - 2042) = v37;
            *(v38 - 2043) = HIBYTE(v37);
            send(v8, &writefds, v36 + 7, 0);
            if ( recv(v8, v52, 1u, 0) != -1 && LOBYTE(v52[0]) == 5 && recv(v8, v52, 1u, 0) != -1 )
            {
              v39 = LOBYTE(v52[0]);
              if ( !LOBYTE(v52[0]) )
              {
                recv(v8, v52, 1u, 0);
                if ( recv(v8, v52, 1u, v39) != -1 )
                {
                  if ( LOBYTE(v52[0]) == 1 )
                  {
                    v24 = 4;
                    do
                    {
                      recv(v8, v52, 1u, 0);
                      --v24;
                    }
                    while ( v24 );
                    goto LABEL_81;
                  }
                  if ( LOBYTE(v52[0]) == 3 )
                  {
                    v40 = 0;
                    if ( recv(v8, v52, 1u, 0) == -1 )
                      v41 = -1;
                    else
                      v41 = LOBYTE(v52[0]);
                    while ( v40++ < v41 )
                      recv(v8, v52, 1u, 0);
LABEL_81:
                    recv(v8, v52, 1u, 0);
                    recv(v8, v52, 1u, 0);
                    if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
                    {
                      snprintf(
                        (char *)v52,
                        2048u,
                        "Success negotiating with %s:%s SOCKS5 proxy",
                        *(const char **)(v2 + 604),
                        *(const char **)(v2 + 608));
                      log_event(7, v52, 0);
                    }
                    goto LABEL_86;
                  }
                }
              }
            }
            if ( !byte_70CE8 && !byte_66640 && dword_657B8 <= 3 )
              goto LABEL_35;
          }
          snprintf(
            (char *)v52,
            2048u,
            "Bad response from %s:%s SOCKS5 server",
            *(_DWORD *)(v2 + 604),
            *(_DWORD *)(v2 + 608));
          log_event(4, v52, 0);
          goto LABEL_35;
        case 4:
          v32 = 1;
LABEL_129:
          if ( !perform_socks4_negotiation(v2, v8, v32) )
            goto LABEL_35;
          goto LABEL_86;
        default:
          if ( !byte_70CE8 && !byte_66640 && dword_657B8 <= 3 )
            goto LABEL_106;
          snprintf(
            (char *)v52,
            2048u,
            "Unsupported proxy type for %s:%s",
            *(const char **)(v2 + 604),
            *(const char **)(v2 + 608));
          log_event(4, v52, 0);
          goto LABEL_35;
      }
    }
    timeout.tv_sec = 1;
    timeout.tv_usec = 0;
    v10 = _errno_location();
    if ( *v10 != 115 )
    {
      close(v8);
      if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
      {
        strcpy((char *)v52, "Failed sock connect");
        log_event(7, v52, 0);
      }
      goto LABEL_24;
    }
    LOBYTE(v18) = v8 & 0x1F;
    if ( v8 <= 0 )
      v18 = -(-v8 & 0x1F);
    v19 = &v52[v8 / 32];
    v20 = 1 << v18;
    while ( 1 )
    {
      p_ai_next = (fd_set *)&s.ai_next;
      do
      {
        p_ai_next->__fds_bits[1] = 0;
        p_ai_next = (fd_set *)((char *)p_ai_next + 4);
      }
      while ( &writefds.__fds_bits[31] != (__fd_mask *)p_ai_next );
      *(v19 - 512) |= v20;
      v22 = select(v8 + 1, 0, &writefds, 0, &timeout);
      if ( v22 > 0 )
        break;
      if ( !v22 || *v10 != 4 )
        goto LABEL_52;
    }
    if ( (v20 & *(v19 - 512)) != 0 )
    {
      optlen = 4;
      if ( !getsockopt(v8, 1, 4, &optval, &optlen) && !optval )
      {
        v2 = v45;
        if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
        {
          strcpy((char *)v52, "Succeeded delayed connect");
          log_event(7, v52, 0);
        }
        goto LABEL_67;
      }
    }
LABEL_52:
    close(v8);
    if ( !byte_66641 || !byte_70CE8 && !byte_66640 && dword_657B8 <= 6 )
      goto LABEL_24;
    qmemcpy(v52, "Select timeout/f", 16);
    v13 = &v52[4];
    v14 = *(_DWORD *)"ailed connect";
    v15 = *(_DWORD *)"d connect";
    v16 = *(_DWORD *)"nnect";
    v17 = *(_WORD *)"t";
LABEL_43:
    *v13 = v14;
    v13[1] = v15;
    v13[2] = v16;
    *((_WORD *)v13 + 6) = v17;
    log_event(7, v52, 0);
    v6 = v6->ai_next;
  }
  while ( v6 );
LABEL_25:
  v2 = v45;
LABEL_26:
  if ( byte_70CE8 || byte_66640 || dword_657B8 > 5 )
  {
    snprintf((char *)v52, 2048u, "Failed to connect to stratum on %s:%s", name, service);
    log_event(6, v52, 0);
  }
  freeaddrinfo(pai);
LABEL_35:
  if ( !byte_66641 )
    return 0;
  v26 = 0;
LABEL_98:
  if ( byte_70CE8 || byte_66640 || dword_657B8 > 6 )
  {
LABEL_109:
    strcpy((char *)&writefds, "Initiate stratum failed");
    log_event(7, &writefds, 0);
  }
  if ( !v26 )
    return 0;
LABEL_102:
  close_stratum_socket(v2);
  return 0;
}
// 23F34: control flows out of bounds to 23F38
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 1DA28: using guessed type int sub_1DA28(void);
// 1DC9C: using guessed type int __fastcall sub_1DC9C(_DWORD, _DWORD, _DWORD);
// 1E190: using guessed type int __fastcall sub_1E190(_DWORD);
// 1E1B8: using guessed type int __fastcall sub_1E1B8(_DWORD, _DWORD);
// 1E7D4: using guessed type int __fastcall sub_1E7D4(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1F930: using guessed type int sub_1F930(void);
// 1FF10: using guessed type int __fastcall sub_1FF10(_DWORD, _DWORD);
// 20258: using guessed type int __fastcall sub_20258(_DWORD);
// 20770: using guessed type int __fastcall sub_20770(_DWORD);
// 2220C: using guessed type int __fastcall sub_2220C(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 236B8: using guessed type int __fastcall sub_236B8(_DWORD, _DWORD, _DWORD);
// 3AADC: using guessed type void __fastcall __noreturn sub_3AADC(_DWORD);
// 657B8: using guessed type int dword_657B8;
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);
// 66224: using guessed type char byte_66224;
// 66640: using guessed type char byte_66640;
// 66641: using guessed type char byte_66641;
// 68608: using guessed type int dword_68608;
// 70CE8: using guessed type char byte_70CE8;
// 70D14: using guessed type int dword_70D14;
// 70E20: using guessed type char byte_70E20;
// 74238: using guessed type char byte_74238;

//----- (00024A2C) --------------------------------------------------------
int __fastcall sub_24A2C(int a1)
{
  int v2; // r5

  if ( *(_BYTE *)(a1 + 641) )
    close_stratum_socket(a1);
  if ( setup_stratum_connection(a1)
    && initiate_stratum((_DWORD *)a1)
    && (!*(_BYTE *)(a1 + 580) || send_extranonce_subscribe((_DWORD *)a1))
    && (v2 = attempt_stratum_auth((_DWORD *)a1)) != 0 )
  {
    reset_and_resume_connection_if_signaled(a1);
  }
  else
  {
    v2 = 0;
    check_and_switch_pool(a1);
  }
  return v2;
}
// 2E888: using guessed type int __fastcall sub_2E888(_DWORD);

//----- (00024AB8) --------------------------------------------------------
int __fastcall process_stratum_reconnect(int miner_index, int pool_index)
{
  int pool_url_index; // r0
  const char *pool_url; // r6
  const char *current_pool_url; // r7
  char *current_pool_domain_pos; // r8
  char *pool_domain_pos; // r1
  int pool_port_index; // r0
  int pool_port; // r2
  char *port_str; // r5
  int new_pool_url_int; // r3
  void *old_current_pool_url_ptr; // r0
  void *old_current_pool_port_ptr; // r0
  int pool_port_index_dup; // r0
  int *lock_err_no; // r0
  int *unlock_err_no; // r0
  char port_str_buffer[264]; // [sp+10h] [bp-A2Ch] BYREF
  int new_pool_url; // [sp+118h] [bp-924h] BYREF
  int new_pool_port; // [sp+11Ch] [bp-920h] BYREF
  char reconnect_url[256]; // [sp+120h] [bp-91Ch] BYREF
  char log_message[12]; // [sp+220h] [bp-81Ch] BYREF

  memset(reconnect_url, 0, 255u);
  pool_url_index = get_task_by_index(pool_index, 0);
  pool_url = (const char *)get_linked_item_or_null(pool_url_index);
  if ( !pool_url )
  {
    pool_url = *(const char **)(miner_index + 600);
    goto LABEL_6;
  }
  current_pool_url = *(const char **)(miner_index + 600);
  current_pool_domain_pos = strchr(current_pool_url, 46);
  if ( !current_pool_domain_pos )
  {
    if ( !byte_70CE8 && !byte_66640 && dword_657B8 <= 2 )
      return 0;
    snprintf(log_message, 2048u, "Denied stratum reconnect request for pool without domain '%s'", current_pool_url);
    goto LABEL_20;
  }
  pool_domain_pos = strchr(pool_url, 46);
  if ( !pool_domain_pos )
  {
    if ( !byte_70CE8 && !byte_66640 && dword_657B8 <= 2 )
      return 0;
    snprintf(log_message, 2048u, "Denied stratum reconnect request to url without domain '%s'", pool_url);
    goto LABEL_20;
  }
  if ( strcmp(current_pool_domain_pos, pool_domain_pos) )
  {
    if ( !byte_70CE8 && !byte_66640 && dword_657B8 <= 2 )
      return 0;
    snprintf(log_message, 2048u, "Denied stratum reconnect request to non-matching domain url '%s'", current_pool_url);
LABEL_20:
    log_event(3, log_message, 0);
    return 0;
  }
LABEL_6:
  pool_port_index = get_task_by_index(pool_index, 1);
  pool_port = get_linked_list_next_node(pool_port_index);
  if ( pool_port )
  {
    port_str = port_str_buffer;
    sprintf(port_str_buffer, "%d", pool_port);
  }
  else
  {
    pool_port_index_dup = get_task_by_index(pool_index, 1);
    port_str = (char *)get_linked_item_or_null(pool_port_index_dup);
    if ( !port_str )
      port_str = *(char **)(miner_index + 584);
  }
  snprintf(reconnect_url, 254u, "%s:%s", pool_url, port_str);
  if ( !parse_url(reconnect_url, &new_pool_url, &new_pool_port) )
    return 0;
  if ( byte_70CE8 || byte_66640 || dword_657B8 > 3 )
  {
    snprintf(
      log_message,
      2048u,
      "Stratum reconnect requested from pool %d to %s",
      *(_DWORD *)miner_index,
      reconnect_url);
    log_event(4, log_message, 0);
  }
  clear_stratum_work(miner_index);
  if ( pthread_mutex_lock((pthread_mutex_t *)(miner_index + 704)) )
  {
    lock_err_no = _errno_location();
    snprintf(
      log_message,
      2048u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *lock_err_no,
      "util.c",
      "parse_reconnect",
      2452);
    log_event(3, log_message, 1);
    shutdown_miner_safely(1);
  }
  reset_network_state(miner_index);
  new_pool_url_int = new_pool_url;
  old_current_pool_url_ptr = *(void **)(miner_index + 600);
  *(_DWORD *)(miner_index + 576) = new_pool_url;
  *(_DWORD *)(miner_index + 600) = new_pool_url_int;
  free(old_current_pool_url_ptr);
  old_current_pool_port_ptr = *(void **)(miner_index + 584);
  *(_DWORD *)(miner_index + 584) = new_pool_port;
  free(old_current_pool_port_ptr);
  if ( pthread_mutex_unlock((pthread_mutex_t *)(miner_index + 704)) )
  {
    unlock_err_no = _errno_location();
    snprintf(
      log_message,
      2048u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *unlock_err_no,
      "util.c",
      "parse_reconnect",
      2461);
    log_event(3, log_message, 1);
    shutdown_miner_safely(1);
  }
  off_658DC(0);
  return reconnect_to_stratum(miner_index);
}
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 1DA28: using guessed type int sub_1DA28(void);
// 1E150: using guessed type int __fastcall sub_1E150(_DWORD);
// 1F930: using guessed type int __fastcall sub_1F930(_DWORD, _DWORD, _DWORD);
// 24A2C: using guessed type int __fastcall sub_24A2C(_DWORD);
// 2FF3C: using guessed type int __fastcall sub_2FF3C(_DWORD);
// 3AADC: using guessed type void __fastcall __noreturn sub_3AADC(_DWORD);
// 47674: using guessed type int __fastcall sub_47674(_DWORD, _DWORD);
// 47820: using guessed type int __fastcall sub_47820(_DWORD);
// 47A7C: using guessed type __int64 __fastcall sub_47A7C(_DWORD);
// 657B8: using guessed type int dword_657B8;
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);
// 66640: using guessed type char byte_66640;
// 70CE8: using guessed type char byte_70CE8;

//----- (00024E8C) --------------------------------------------------------
int __fastcall parse_miner_message(_DWORD *miner_instance, int message_data)
{
  double difficulty; // d0
  int json_message; // r0
  int json_message_copy; // r5
  int method_node; // r7
  _DWORD *error_node; // r4
  _DWORD *params_node; // r8
  const char *method_name; // r0
  const char *method_name_copy; // r7
  unsigned int method_compare_result; // r4
  _DWORD *param_counter; // r6
  bool param_count_check; // cf
  unsigned int current_param; // r1
  int param_node; // r0
  int parse_result; // r4
  unsigned int *ref_counter; // r3
  unsigned int current_ref_count; // r2
  unsigned int new_ref_count; // r2
  const char *error_message; // r4
  char *free_pointer; // r0
  int id_node_pong; // r0
  int id_value_pong; // r0
  size_t message_length_pong; // r0
  int version_mask_node; // r0
  char *version_mask_value; // r0
  int difficulty_node; // r0
  double *previous_difficulty_ptr; // r3
  double previous_difficulty; // d9
  const char *log_format; // r2
  int log_pool_id; // r3
  void *extranonce_value; // r9
  int id_node_version; // r0
  int id_value_version; // r0
  int n2size_node; // r0
  int extranonce2_node; // r0
  int show_message_node; // r0
  size_t nonce1bin_length; // r3
  void *old_nonce1bin; // r0
  int new_nonce1bin_alloc; // r0
  int unblock_after_extranonce; // r0
  int *mutex_error_code; // r0
  int *rwlock_unlock_error_code; // r0
  int *rwlock_lock_error_code; // r0
  int *final_rwunlock_error_code; // r0
  int *final_rwlock_error_code; // r0
  int log_pool_difficulty; // [sp+0h] [bp-2150h]
  int n2size_value; // [sp+14h] [bp-213Ch]
  int json_decode_result[23]; // [sp+1Ch] [bp-2134h] BYREF
  char json_decode_error_message[160]; // [sp+78h] [bp-20D8h] BYREF
  char log_buffer[8248]; // [sp+118h] [bp-2038h] BYREF

  json_message = process_command(message_data, 0, json_decode_result);
  json_message_copy = json_message;
  if ( json_message )
  {
    method_node = validate_and_fetch_data(json_message, "method");
    if ( !method_node )
      goto LABEL_14;
    error_node = (_DWORD *)validate_and_fetch_data(json_message_copy, "error");
    params_node = (_DWORD *)validate_and_fetch_data(json_message_copy, "params");
    if ( error_node && *error_node != 7 )
    {
      error_message = (const char *)generate_config_json(error_node, 3);
      if ( byte_70CE8 || byte_66640 || dword_657B8 > 5 )
      {
        snprintf(log_buffer, 2048u, "JSON-RPC method decode failed: %s", error_message);
        log_event(6, log_buffer, 0);
      }
      free_pointer = (char *)error_message;
      parse_result = 0;
      free(free_pointer);
      goto LABEL_15;
    }
    method_name = (const char *)get_linked_item_or_null(method_node);
    method_name_copy = method_name;
    if ( !method_name )
      goto LABEL_14;
    method_compare_result = strncasecmp(method_name, "mining.multi_version", 20u);
    if ( !method_compare_result )
    {
      *((_BYTE *)miner_instance + 644) = 1;
      if ( byte_70CE8 || byte_66640 || dword_657B8 > 5 )
      {
        strcpy(log_buffer, "Pool support multi version");
        log_event(6, log_buffer, 0);
      }
      for ( param_counter = miner_instance + 163; ; ++param_counter )
      {
        param_count_check = method_compare_result >= get_next_structure_pointer(params_node);
        current_param = method_compare_result++;
        if ( param_count_check )
          break;
        param_node = get_task_by_index(params_node, current_param);
        *param_counter = get_linked_list_next_node(param_node);
      }
      goto LABEL_50;
    }
    if ( !strncasecmp(method_name_copy, "mining.notify", 13u) )
    {
      parse_result = parse_notify_message(miner_instance, params_node);
      if ( parse_result )
      {
        *((_BYTE *)miner_instance + 643) = 1;
        goto LABEL_15;
      }
    }
    else
    {
      if ( strncasecmp(method_name_copy, "mining.set_version_mask", 23u) )
      {
        if ( !strncasecmp(method_name_copy, "mining.set_difficulty", 21u) )
        {
          difficulty_node = get_task_by_index(params_node, 0);
          check_and_update_double_value(difficulty_node);
          if ( difficulty == 0.0 )
            goto LABEL_14;
          if ( pthread_mutex_lock((pthread_mutex_t *)(miner_instance + 53)) )
            log_mutex_error_and_terminate("parse_diff", 2306);
          if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(miner_instance + 59)) )
          {
            rwlock_lock_error_code = _errno_location();
            snprintf(
              log_buffer,
              2048u,
              "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
              *rwlock_lock_error_code,
              "util.c",
              "parse_diff",
              2306);
            log_event(3, log_buffer, 1);
            shutdown_miner_safely(1);
          }
          previous_difficulty_ptr = (double *)(miner_instance + 456);
          previous_difficulty = *((double *)miner_instance + 227);
          *((double *)miner_instance + 227) = difficulty;
          if ( previous_difficulty <= 0.0 )
          {
            previous_difficulty = *previous_difficulty_ptr;
            *previous_difficulty_ptr = difficulty;
          }
          if ( pthread_rwlock_unlock((pthread_rwlock_t *)(miner_instance + 59)) )
          {
            rwlock_unlock_error_code = _errno_location();
            snprintf(
              log_buffer,
              2048u,
              "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
              *rwlock_unlock_error_code,
              "util.c",
              "parse_diff",
              2319);
            log_event(3, log_buffer, 1);
            shutdown_miner_safely(1);
          }
          if ( pthread_mutex_unlock((pthread_mutex_t *)(miner_instance + 53)) )
          {
            mutex_error_code = _errno_location();
            snprintf(
              log_buffer,
              2048u,
              "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
              *mutex_error_code,
              "util.c",
              "parse_diff",
              2319);
            log_event(3, log_buffer, 1);
            shutdown_miner_safely(1);
          }
          off_658DC(0);
          if ( difficulty == previous_difficulty )
          {
            parse_result = (unsigned __int8)byte_66641;
            if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
            {
              snprintf(log_buffer, 2048u, "Pool %d difficulty set to %f", *miner_instance, difficulty);
              log_event(7, log_buffer, 0);
              goto LABEL_15;
            }
            goto LABEL_50;
          }
          if ( difficulty != (double)(int)difficulty )
          {
            if ( byte_70CE8 || byte_66640 || dword_657B8 > 4 )
            {
              snprintf(log_buffer, 2048u, "Pool %d difficulty changed to %.1f", *miner_instance, difficulty);
              parse_result = 1;
              log_event(5, log_buffer, 0);
              goto LABEL_15;
            }
            goto LABEL_50;
          }
          if ( byte_70CE8 || byte_66640 || dword_657B8 > 4 )
          {
            log_pool_difficulty = (int)difficulty;
            log_format = "Pool %d difficulty changed to %d";
            log_pool_id = *miner_instance;
LABEL_65:
            parse_result = 1;
            snprintf(log_buffer, 2048u, log_format, log_pool_id, log_pool_difficulty);
            log_event(5, log_buffer, 0);
            goto LABEL_15;
          }
        }
        else
        {
          if ( !strncasecmp(method_name_copy, "mining.set_extranonce", 21u) )
          {
            extranonce_value = (void *)get_info_duplicate_if_not_null(params_node, 0);
            parse_result = validate_hex_string(extranonce_value, "parse_extranonce", 2349);
            if ( parse_result )
            {
              n2size_node = get_task_by_index(params_node, 1);
              n2size_value = get_linked_list_next_node(n2size_node);
              if ( !n2size_value )
              {
                if ( byte_70CE8 || byte_66640 || dword_657B8 > 5 )
                {
                  strcpy(log_buffer, "Failed to get valid n2size in parse_extranonce");
                  log_event(6, log_buffer, 0);
                }
                parse_result = 0;
                free(extranonce_value);
                goto LABEL_15;
              }
              if ( pthread_mutex_lock((pthread_mutex_t *)(miner_instance + 53)) )
                log_mutex_error_and_terminate("parse_extranonce", 2361);
              if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(miner_instance + 59)) )
              {
                final_rwlock_error_code = _errno_location();
                snprintf(
                  log_buffer,
                  2048u,
                  "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
                  *final_rwlock_error_code,
                  "util.c",
                  "parse_extranonce",
                  2361);
                log_event(3, log_buffer, 1);
                shutdown_miner_safely(1);
              }
              free((void *)miner_instance[153]);
              miner_instance[153] = extranonce_value;
              nonce1bin_length = strlen((const char *)extranonce_value) >> 1;
              old_nonce1bin = (void *)miner_instance[154];
              miner_instance[391] = nonce1bin_length;
              free(old_nonce1bin);
              new_nonce1bin_alloc = allocate_and_log_on_fail(miner_instance[391], 1, "util.c", "parse_extranonce", 2366);
              miner_instance[154] = new_nonce1bin_alloc;
              if ( !new_nonce1bin_alloc )
              {
                snprintf(
                  log_buffer,
                  2048u,
                  "Failed to calloc pool->nonce1bin in %s %s():%d",
                  "util.c",
                  "parse_extranonce",
                  2368);
                log_event(3, log_buffer, 1);
                shutdown_miner_safely(1);
              }
              hex_string_to_binary(miner_instance[154], miner_instance[153]);
              miner_instance[158] = n2size_value;
              if ( pthread_rwlock_unlock((pthread_rwlock_t *)(miner_instance + 59)) )
              {
                final_rwunlock_error_code = _errno_location();
                snprintf(
                  log_buffer,
                  2048u,
                  "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
                  *final_rwunlock_error_code,
                  "util.c",
                  "parse_extranonce",
                  2371);
                log_event(3, log_buffer, 1);
                shutdown_miner_safely(1);
              }
              unblock_after_extranonce = unlock_mutex_and_log_error(miner_instance + 53, "parse_extranonce", 2371);
              off_658DC(unblock_after_extranonce);
              if ( byte_70CE8 || byte_66640 || dword_657B8 > 4 )
              {
                snprintf(log_buffer, 2048u, "Pool %d extranonce change requested", *miner_instance);
                log_event(5, log_buffer, 0);
                goto LABEL_15;
              }
              goto LABEL_50;
            }
            if ( byte_70CE8 || byte_66640 || dword_657B8 > 5 )
            {
              strcpy(log_buffer, "Failed to get valid nonce1 in parse_extranonce");
              log_event(6, log_buffer, 0);
              goto LABEL_15;
            }
            goto LABEL_14;
          }
          if ( !strncasecmp(method_name_copy, "client.reconnect", 16u) )
          {
            parse_result = process_stratum_reconnect(miner_instance, params_node);
            goto LABEL_15;
          }
          if ( !strncasecmp(method_name_copy, "client.get_version", 18u) )
          {
            if ( validate_and_fetch_data(json_message_copy, "id") )
            {
              id_node_version = validate_and_fetch_data(json_message_copy, "id");
              id_value_version = get_linked_list_next_node(id_node_version);
              sprintf(log_buffer, "{\"id\": %d, \"result\": \"cgminer/1.0.0\", \"error\": null}", id_value_version);
              goto LABEL_44;
            }
LABEL_14:
            parse_result = 0;
LABEL_15:
            if ( *(_DWORD *)(json_message_copy + 4) != -1 )
            {
              ref_counter = (unsigned int *)(json_message_copy + 4);
              __dmb(11u);
              do
              {
                current_ref_count = __ldrex(ref_counter);
                new_ref_count = current_ref_count - 1;
              }
              while ( __strex(new_ref_count, ref_counter) );
              if ( !new_ref_count )
                process_bitmain_miner(json_message_copy);
            }
            return parse_result;
          }
          if ( strncasecmp(method_name_copy, "client.show_message", 19u) )
          {
            if ( !strncasecmp(method_name_copy, "mining.ping", 11u) )
            {
              if ( byte_70CE8 || byte_66640 || dword_657B8 > 5 )
              {
                snprintf(log_buffer, 2048u, "Pool %d ping", *miner_instance);
                log_event(6, log_buffer, 0);
              }
              if ( !validate_and_fetch_data(json_message_copy, "id") )
              {
                parse_result = 0;
                goto LABEL_15;
              }
              id_node_pong = validate_and_fetch_data(json_message_copy, "id");
              id_value_pong = get_linked_list_next_node(id_node_pong);
              sprintf(log_buffer, "{\"id\": %d, \"result\": \"pong\", \"error\": null}", id_value_pong);
LABEL_44:
              message_length_pong = strlen(log_buffer);
              parse_result = stratum_send(miner_instance, log_buffer, message_length_pong);
              goto LABEL_15;
            }
            goto LABEL_14;
          }
          if ( !params_node )
            goto LABEL_14;
          if ( *params_node != 1 )
            goto LABEL_14;
          extranonce2_node = get_task_by_index(params_node, 0);
          show_message_node = get_linked_item_or_null(extranonce2_node);
          if ( !show_message_node )
            goto LABEL_14;
          if ( byte_70CE8 || byte_66640 || dword_657B8 > 4 )
          {
            log_format = "Pool %d message: %s";
            log_pool_difficulty = show_message_node;
            log_pool_id = *miner_instance;
            goto LABEL_65;
          }
        }
LABEL_50:
        parse_result = 1;
        goto LABEL_15;
      }
      parse_result = 1;
      version_mask_node = get_task_by_index(params_node, 0);
      version_mask_value = (char *)get_linked_item_or_null(version_mask_node);
      process_mask_input((int)miner_instance, version_mask_value);
    }
    *((_BYTE *)miner_instance + 643) = parse_result;
    goto LABEL_15;
  }
  if ( byte_70CE8 || (parse_result = (unsigned __int8)byte_66640, byte_66640) || dword_657B8 > 5 )
  {
    parse_result = 0;
    snprintf(log_buffer, 2048u, "JSON decode failed(%d): %s", json_decode_result[0], json_decode_error_message);
    log_event(6, log_buffer, 0);
  }
  return parse_result;
}
// 25338: variable 'difficulty' is possibly undefined
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 1DA28: using guessed type int sub_1DA28(void);
// 1E2B0: using guessed type int __fastcall sub_1E2B0(_DWORD, _DWORD);
// 1E330: using guessed type int __fastcall sub_1E330(_DWORD, _DWORD, _DWORD);
// 1E578: using guessed type int __fastcall sub_1E578(_DWORD, _DWORD, _DWORD);
// 1E5F4: using guessed type void __fastcall __noreturn sub_1E5F4(_DWORD, _DWORD);
// 1E7D4: using guessed type int __fastcall sub_1E7D4(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1EA68: using guessed type int __fastcall sub_1EA68(_DWORD, _DWORD);
// 203BC: using guessed type int __fastcall sub_203BC(_DWORD, _DWORD, _DWORD);
// 22550: using guessed type int __fastcall sub_22550(_DWORD, _DWORD);
// 24AB8: using guessed type int __fastcall sub_24AB8(_DWORD, _DWORD);
// 3AADC: using guessed type void __fastcall __noreturn sub_3AADC(_DWORD);
// 44264: using guessed type int __fastcall sub_44264(_DWORD, _DWORD);
// 46448: using guessed type int __fastcall sub_46448(_DWORD, _DWORD, _DWORD);
// 472EC: using guessed type int __fastcall sub_472EC(_DWORD, _DWORD);
// 47658: using guessed type int __fastcall sub_47658(_DWORD);
// 47674: using guessed type int __fastcall sub_47674(_DWORD, _DWORD);
// 47820: using guessed type int __fastcall sub_47820(_DWORD);
// 47A7C: using guessed type int __fastcall sub_47A7C(_DWORD);
// 47BB8: using guessed type int __fastcall sub_47BB8(_DWORD);
// 47C24: using guessed type int __fastcall sub_47C24(_DWORD);
// 657B8: using guessed type int dword_657B8;
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);
// 66640: using guessed type char byte_66640;
// 66641: using guessed type char byte_66641;
// 70CE8: using guessed type char byte_70CE8;
// 24E8C: using guessed type int var_2134[23];
// 24E8C: using guessed type char var_20D8[160];

//----- (00025A68) --------------------------------------------------------
int __fastcall process_miner_message(_DWORD *message_buffer, int message_length)
{
  if ( message_length )
    return parse_miner_message(message_buffer, message_length);
  else
    return 0;
}

//----- (00025A7C) --------------------------------------------------------
int __fastcall send_extranonce_subscribe(_DWORD *miner_id)
{
  int incremented_id; // r2
  size_t message_len; // r0
  int v4; // r7
  char *socket_data; // r5
  int timeout_result; // r6
  int parsed_data; // r8
  _DWORD *result_field; // r7
  _DWORD *error_field; // r0
  _DWORD *error_field_safe; // r5
  const char *error_message; // r7
  char *formatted_reason; // r5
  unsigned int *ref_count_addr; // r3
  unsigned int current_ref_count; // r2
  unsigned int new_ref_count; // r2
  char workspace[252]; // [sp+Ch] [bp-2914h] BYREF
  char log_message[2040]; // [sp+108h] [bp-2818h] BYREF
  char subscribe_message[8216]; // [sp+908h] [bp-2018h] BYREF

  incremented_id = dword_70D14++;
  sprintf(
    subscribe_message,
    "{\"id\": %d, \"method\": \"mining.extranonce.subscribe\", \"params\": []}",
    incremented_id);
  message_len = strlen(subscribe_message);
  v4 = stratum_send(miner_id, subscribe_message, message_len);
  if ( v4 )
  {
    while ( 1 )
    {
      timeout_result = is_socket_ready(miner_id[147], 2);
      if ( !timeout_result )
      {
        if ( byte_66641 )
        {
          if ( byte_70CE8 || byte_66640 || dword_657B8 > 6 )
          {
            v4 = (unsigned __int8)byte_66641;
            strcpy(log_message, "Timed out waiting for response extranonce.subscribe");
            log_event(7, log_message, 0);
          }
          else
          {
            return (unsigned __int8)byte_66641;
          }
        }
        return v4;
      }
      socket_data = receive_socket_data((int)miner_id);
      if ( !socket_data )
        return 0;
      if ( !parse_miner_message(miner_id, (int)socket_data) )
        break;
      free(socket_data);
    }
    parsed_data = process_command(socket_data, 0, workspace);
    free(socket_data);
    result_field = (_DWORD *)validate_and_fetch_data(parsed_data, "result");
    error_field = (_DWORD *)validate_and_fetch_data(parsed_data, "error");
    error_field_safe = error_field;
    if ( !result_field || *result_field == 6 )
    {
      if ( !error_field )
      {
        formatted_reason = (char *)malloc(17u);
        if ( formatted_reason )
          strcpy(formatted_reason, "(unknown reason)");
        goto LABEL_30;
      }
    }
    else if ( !error_field || *error_field == 7 )
    {
      if ( byte_70CE8 || byte_66640 || dword_657B8 > 5 )
      {
        v4 = timeout_result;
        snprintf(log_message, 2048u, "Stratum extranonce subscribe for pool %d", *miner_id);
        log_event(6, log_message, 0);
        goto LABEL_35;
      }
LABEL_26:
      v4 = timeout_result;
LABEL_35:
      if ( parsed_data )
      {
        if ( *(_DWORD *)(parsed_data + 4) != -1 )
        {
          ref_count_addr = (unsigned int *)(parsed_data + 4);
          __dmb(11u);
          do
          {
            current_ref_count = __ldrex(ref_count_addr);
            new_ref_count = current_ref_count - 1;
          }
          while ( __strex(new_ref_count, ref_count_addr) );
          if ( !new_ref_count )
            process_bitmain_miner(parsed_data);
        }
      }
      return v4;
    }
    error_message = (const char *)check_status_and_get_info(error_field, 1);
    if ( !error_message && (error_message = (const char *)get_linked_item_or_null(error_field_safe)) == 0
      || strcmp(error_message, "Method 'subscribe' not found for service 'mining.extranonce'")
      && strcmp(error_message, "Unrecognized request provided") )
    {
      formatted_reason = (char *)generate_config_json(error_field_safe, 3);
LABEL_30:
      if ( byte_70CE8 || byte_66640 || dword_657B8 > 5 )
      {
        snprintf(log_message, 2048u, "Pool %d JSON extranonce subscribe failed: %s", *miner_id, formatted_reason);
        log_event(6, log_message, 0);
      }
      v4 = 0;
      free(formatted_reason);
      goto LABEL_35;
    }
    if ( byte_70CE8 || byte_66640 || dword_657B8 > 5 )
    {
      v4 = timeout_result;
      snprintf(log_message, 2048u, "Cannot subscribe to mining.extranonce for pool %d", *miner_id);
      log_event(6, log_message, 0);
      goto LABEL_35;
    }
    goto LABEL_26;
  }
  return v4;
}
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 1E1B8: using guessed type int __fastcall sub_1E1B8(_DWORD, _DWORD);
// 1E24C: using guessed type int __fastcall sub_1E24C(_DWORD, _DWORD);
// 203BC: using guessed type int __fastcall sub_203BC(_DWORD, _DWORD, _DWORD);
// 44264: using guessed type int __fastcall sub_44264(_DWORD, _DWORD);
// 46448: using guessed type int __fastcall sub_46448(_DWORD, _DWORD, _DWORD);
// 472EC: using guessed type int __fastcall sub_472EC(_DWORD, _DWORD);
// 47820: using guessed type int __fastcall sub_47820(_DWORD);
// 47C24: using guessed type int __fastcall sub_47C24(_DWORD);
// 657B8: using guessed type int dword_657B8;
// 66640: using guessed type char byte_66640;
// 66641: using guessed type char byte_66641;
// 70CE8: using guessed type char byte_70CE8;
// 70D14: using guessed type int dword_70D14;
// 25A7C: using guessed type char var_2914[252];

//----- (00025E74) --------------------------------------------------------
int __fastcall attempt_stratum_auth(_DWORD *connection)
{
  const char *worker_name; // r3
  int message_id; // r2
  int send_result; // r9
  int parse_result; // r6
  char *received_data; // r5
  int parsed_message; // r8
  _DWORD *result_key; // r5
  _DWORD *error_key; // r0
  char *error_message; // r5
  unsigned int *ref_count; // r3
  unsigned int current_count; // r2
  unsigned int new_count; // r2
  int suggested_difficulty; // r3
  int next_message_id; // r2
  const char *worker_password; // [sp+0h] [bp-2928h]
  char unused_buffer[252]; // [sp+Ch] [bp-291Ch] BYREF
  char log_buffer[2040]; // [sp+108h] [bp-2820h] BYREF
  char json_request[8224]; // [sp+908h] [bp-2020h] BYREF

  worker_name = (const char *)connection[43];
  message_id = dword_70D14;
  worker_password = (const char *)connection[44];
  ++dword_70D14;
  sprintf(
    json_request,
    "{\"id\": %d, \"method\": \"mining.authorize\", \"params\": [\"%s\", \"%s\"]}",
    message_id,
    worker_name,
    worker_password);
  strlen(json_request);
  send_result = stratum_send((int)connection, json_request);
  if ( send_result )
  {
    while ( 1 )
    {
      received_data = receive_socket_data((int)connection);
      if ( !received_data )
        return 0;
      parse_result = parse_miner_message(connection, (int)received_data);
      if ( !parse_result )
        break;
      free(received_data);
    }
    parsed_message = process_command(received_data, 0, unused_buffer);
    free(received_data);
    result_key = (_DWORD *)validate_and_fetch_data(parsed_message, "result");
    error_key = (_DWORD *)validate_and_fetch_data(parsed_message, "error");
    if ( !result_key || *result_key == 6 )
    {
      if ( !error_key )
      {
        error_message = (char *)malloc(17u);
        if ( error_message )
          strcpy(error_message, "(unknown reason)");
        goto LABEL_13;
      }
    }
    else if ( !error_key || *error_key == 7 )
    {
      if ( byte_70CE8 || byte_66640 || dword_657B8 > 5 )
      {
        snprintf(log_buffer, 2048u, "Stratum authorisation success for pool %d", *connection);
        log_event(6, log_buffer, 0);
      }
      suggested_difficulty = dword_74138;
      byte_66642 = 1;
      *((_BYTE *)connection + 99) = 1;
      if ( suggested_difficulty )
      {
        next_message_id = dword_70D14;
        parse_result = send_result;
        ++dword_70D14;
        sprintf(
          json_request,
          "{\"id\": %d, \"method\": \"mining.suggest_difficulty\", \"params\": [%d]}",
          next_message_id,
          suggested_difficulty);
        strlen(json_request);
        stratum_send((int)connection, json_request);
      }
      else
      {
        parse_result = send_result;
      }
      goto LABEL_17;
    }
    error_message = (char *)generate_config_json(error_key, 3);
LABEL_13:
    if ( byte_70CE8 || byte_66640 || dword_657B8 > 5 )
    {
      snprintf(log_buffer, 2048u, "pool %d JSON stratum auth failed: %s", *connection, error_message);
      log_event(6, log_buffer, 0);
    }
    free(error_message);
    close_stratum_socket(connection);
LABEL_17:
    if ( parsed_message )
    {
      if ( *(_DWORD *)(parsed_message + 4) != -1 )
      {
        ref_count = (unsigned int *)(parsed_message + 4);
        __dmb(11u);
        do
        {
          current_count = __ldrex(ref_count);
          new_count = current_count - 1;
        }
        while ( __strex(new_count, ref_count) );
        if ( !new_count )
          process_bitmain_miner(parsed_message);
      }
    }
    return parse_result;
  }
  return 0;
}
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 20258: using guessed type int __fastcall sub_20258(_DWORD);
// 44264: using guessed type int __fastcall sub_44264(_DWORD, _DWORD);
// 46448: using guessed type int __fastcall sub_46448(_DWORD, _DWORD, _DWORD);
// 472EC: using guessed type int __fastcall sub_472EC(_DWORD, _DWORD);
// 47C24: using guessed type int __fastcall sub_47C24(_DWORD);
// 657B8: using guessed type int dword_657B8;
// 66640: using guessed type char byte_66640;
// 66642: using guessed type char byte_66642;
// 70CE8: using guessed type char byte_70CE8;
// 70D14: using guessed type int dword_70D14;
// 74138: using guessed type int dword_74138;
// 25E74: using guessed type char var_291C[252];

//----- (00026164) --------------------------------------------------------
int __fastcall calculate_time_difference(int *result, _DWORD *start_time, _DWORD *end_time)
{
  int seconds_diff; // r12
  int microseconds_diff; // r3

  if ( *start_time > *end_time )
    return -1;
  if ( *start_time == *end_time && start_time[1] > end_time[1] )
    return -1;
  seconds_diff = *end_time - *start_time;
  *result = seconds_diff;
  microseconds_diff = end_time[1] - start_time[1];
  result[1] = microseconds_diff;
  if ( microseconds_diff < 0 )
  {
    *result = seconds_diff - 1;
    result[1] = microseconds_diff + 1000000;
  }
  return 0;
}

//----- (000261E0) --------------------------------------------------------
_BYTE *__fastcall reverse_bytes(_BYTE *buffer, int length)
{
  _BYTE *ptr; // r12
  unsigned int counter; // r3
  char temp1; // lr
  char byte1; // t1
  char byte2; // t1

  if ( length != 1 )
  {
    ptr = buffer - 1;
    counter = 0;
    buffer += length;
    do
    {
      ++counter;
      byte1 = *++ptr;
      temp1 = byte1;
      byte2 = *--buffer;
      *ptr = byte2;
      *buffer = temp1;
    }
    while ( counter < ~counter + length );
  }
  return buffer;
}

//----- (00026220) --------------------------------------------------------
int __fastcall get_encoding_type(int encoding_type, char input_char)
{
  unsigned int char_mask_16; // r1
  unsigned int char_mask_64; // r1
  int char_mask_4; // r1
  unsigned int char_mask_8; // r1
  unsigned int char_mask_32; // r1

  switch ( encoding_type )
  {
    case 1:
      return encoding_type;
    case 2:
      if ( (input_char & 0x80) != 128 )
        encoding_type = 1;
      break;
    case 4:
      char_mask_4 = input_char & 0xC0;
      if ( char_mask_4 == 128 )
        goto LABEL_29;
      if ( char_mask_4 != 192 )
      {
        if ( char_mask_4 == 64 )
          encoding_type = 2;
        else
          encoding_type = 1;
      }
      break;
    case 8:
      char_mask_8 = input_char & 0xE0;
      if ( char_mask_8 == 128 )
        goto LABEL_50;
      if ( char_mask_8 <= 128 )
      {
        if ( char_mask_8 == 64 )
          goto LABEL_29;
        if ( char_mask_8 == 96 )
          goto LABEL_49;
        if ( char_mask_8 != 32 )
          goto LABEL_9;
        goto LABEL_25;
      }
      if ( char_mask_8 == 192 )
        goto LABEL_48;
      if ( char_mask_8 != 224 )
      {
        if ( char_mask_8 != 160 )
          goto LABEL_9;
        goto LABEL_39;
      }
      break;
    case 16:
      char_mask_16 = input_char & 0xF0;
      if ( char_mask_16 == 128 )
      {
        encoding_type = 9;
      }
      else if ( char_mask_16 > 128 )
      {
        if ( char_mask_16 == 192 )
        {
          encoding_type = 13;
        }
        else if ( char_mask_16 <= 192 )
        {
          switch ( char_mask_16 )
          {
            case 160u:
              encoding_type = 11;
              break;
            case 176u:
              encoding_type = 12;
              break;
            case 144u:
              encoding_type = 10;
              break;
            default:
              goto LABEL_9;
          }
        }
        else if ( char_mask_16 == 224 )
        {
          encoding_type = 15;
        }
        else if ( char_mask_16 != 240 )
        {
          if ( char_mask_16 != 208 )
            goto LABEL_9;
          encoding_type = 14;
        }
      }
      else if ( char_mask_16 == 64 )
      {
LABEL_50:
        encoding_type = 5;
      }
      else if ( char_mask_16 > 64 )
      {
        switch ( char_mask_16 )
        {
          case '`':
LABEL_48:
            encoding_type = 7;
            break;
          case 'p':
            encoding_type = 8;
            break;
          case 'P':
LABEL_39:
            encoding_type = 6;
            break;
          default:
            goto LABEL_9;
        }
      }
      else
      {
        switch ( char_mask_16 )
        {
          case 32u:
LABEL_29:
            encoding_type = 3;
            break;
          case 48u:
LABEL_49:
            encoding_type = 4;
            break;
          case 16u:
LABEL_25:
            encoding_type = 2;
            break;
          default:
            goto LABEL_9;
        }
      }
      break;
    case 32:
      char_mask_32 = (unsigned __int8)((input_char & 0xF8) - 8);
      if ( char_mask_32 > 240 )
        goto LABEL_9;
      encoding_type = *((char *)&dword_4A880[501] + char_mask_32);
      break;
    case 64:
      char_mask_64 = (unsigned __int8)((input_char & 0xFC) - 4);
      if ( char_mask_64 > 248 )
LABEL_9:
        encoding_type = 1;
      else
        encoding_type = *((char *)&dword_4A880[562] + char_mask_64);
      break;
    default:
      encoding_type = 0;
      break;
  }
  return encoding_type;
}
// 2622C: control flows out of bounds to 26230
// 4A880: using guessed type int dword_4A880[256];

//----- (00026508) --------------------------------------------------------
void __fastcall process_miner_output(_DWORD *miner_data, unsigned __int8 *nonce_data, int output_flag)
{
  int initial_state_val1; // r0
  int initial_state_val2; // r1
  int initial_state_val3; // r2
  int initial_state_val4; // r3
  int final_state_val1; // r0
  int final_state_val2; // r1
  int final_state_val3; // r2
  int final_state_val4; // r3
  int *loop_counter1_ptr; // lr
  _DWORD *loop_counter2_ptr; // r12
  int half_state_val1; // r1
  int half_state_val2; // r2
  int hash_part1; // r1
  int hash_part2; // r2
  int hash_part3; // r3
  int hash_final_part1; // r1
  int hash_final_part2; // r2
  int hash_final_part3; // r3
  char temp_byte1; // r3
  char byte_fetch1; // t1
  char byte_fetch2; // t1
  int *swap_counter1; // r2
  int *swap_counter2; // r3
  char swapped_byte; // t1
  char swap_temp; // r1
  _DWORD *reverse_counter; // r3
  char *string_ptr; // r2
  char reverse_byte; // r1
  char reverse_fetch1; // t1
  char reverse_fetch2; // t1
  const char *output_prefix; // r5
  char *midstate_str; // r8
  char *data_str; // r7
  char *nonce_str; // r9
  char *hash_str; // r6
  int difficulty; // r0
  int difficulty_high; // r1
  size_t output_length; // r0
  size_t file_mode; // r4
  int file_index; // r4
  size_t file_length; // r0
  unsigned __int64 difficulty_bits; // r2
  int difficulty_num; // r4
  size_t output_str_length; // r0
  size_t output_str_length_2; // r0
  char *work_str; // [sp+20h] [bp-CA0h]
  char *nonce_str_screen; // [sp+28h] [bp-C98h]
  __int64 difficulty_long; // [sp+2Ch] [bp-C94h]
  char *flag_ptr; // [sp+34h] [bp-C8Ch] BYREF
  int chip_info[3]; // [sp+38h] [bp-C88h] BYREF
  _DWORD final_chip_state[5]; // [sp+44h] [bp-C7Ch] BYREF
  int state_data; // [sp+58h] [bp-C68h] BYREF
  _DWORD half_chip_state[2]; // [sp+5Ch] [bp-C64h] BYREF
  int encryption_data[4]; // [sp+64h] [bp-C5Ch] BYREF
  int unused_val; // [sp+74h] [bp-C4Ch] BYREF
  int hash_initial_data[3]; // [sp+78h] [bp-C48h] BYREF
  _DWORD hash_final_data[5]; // [sp+84h] [bp-C3Ch] BYREF
  char output_buffer[1024]; // [sp+98h] [bp-C28h] BYREF
  char screen_buffer[2088]; // [sp+498h] [bp-828h] BYREF

  memset(output_buffer, 0, sizeof(output_buffer));
  initial_state_val1 = miner_data[32];
  memset(encryption_data, 0, sizeof(encryption_data));
  initial_state_val2 = miner_data[33];
  initial_state_val3 = miner_data[34];
  initial_state_val4 = miner_data[35];
  chip_info[0] = initial_state_val1;
  chip_info[1] = initial_state_val2;
  chip_info[2] = initial_state_val3;
  final_chip_state[0] = initial_state_val4;
  final_state_val1 = miner_data[36];
  final_state_val2 = miner_data[37];
  final_state_val3 = miner_data[38];
  final_state_val4 = miner_data[39];
  loop_counter1_ptr = &state_data;
  unused_val = 0;
  final_chip_state[1] = final_state_val1;
  final_chip_state[2] = final_state_val2;
  final_chip_state[3] = final_state_val3;
  final_chip_state[4] = final_state_val4;
  loop_counter2_ptr = (char **)((char *)&flag_ptr + 3);
  half_state_val1 = miner_data[17];
  half_state_val2 = miner_data[18];
  state_data = miner_data[16];
  half_chip_state[0] = half_state_val1;
  half_chip_state[1] = half_state_val2;
  hash_part1 = miner_data[49];
  hash_part2 = miner_data[50];
  hash_part3 = miner_data[51];
  hash_initial_data[0] = miner_data[48];
  hash_initial_data[1] = hash_part1;
  hash_initial_data[2] = hash_part2;
  hash_final_data[0] = hash_part3;
  hash_final_part1 = miner_data[53];
  hash_final_part2 = miner_data[54];
  hash_final_part3 = miner_data[55];
  hash_final_data[1] = miner_data[52];
  hash_final_data[2] = hash_final_part1;
  hash_final_data[3] = hash_final_part2;
  hash_final_data[4] = hash_final_part3;
  do
  {
    byte_fetch1 = *((_BYTE *)loop_counter2_ptr + 1);
    loop_counter2_ptr = (_DWORD *)((char *)loop_counter2_ptr + 1);
    temp_byte1 = byte_fetch1;
    byte_fetch2 = *((_BYTE *)loop_counter1_ptr - 1);
    loop_counter1_ptr = (int *)((char *)loop_counter1_ptr - 1);
    *(_BYTE *)loop_counter2_ptr = byte_fetch2;
    *(_BYTE *)loop_counter1_ptr = temp_byte1;
  }
  while ( loop_counter2_ptr != (_DWORD *)((char *)final_chip_state + 3) );
  swap_counter1 = &state_data;
  swap_counter2 = encryption_data;
  do
  {
    swapped_byte = *((_BYTE *)swap_counter2 - 1);
    swap_counter2 = (int *)((char *)swap_counter2 - 1);
    swap_temp = *(_BYTE *)swap_counter1;
    *(_BYTE *)swap_counter1 = swapped_byte;
    swap_counter1 = (int *)((char *)swap_counter1 + 1);
    *(_BYTE *)swap_counter2 = swap_temp;
  }
  while ( (_DWORD *)((char *)half_chip_state + 2) != swap_counter2 );
  reverse_counter = (int *)((char *)&unused_val + 3);
  string_ptr = output_buffer;
  do
  {
    reverse_fetch1 = *((_BYTE *)reverse_counter + 1);
    reverse_counter = (_DWORD *)((char *)reverse_counter + 1);
    reverse_byte = reverse_fetch1;
    reverse_fetch2 = *--string_ptr;
    *(_BYTE *)reverse_counter = reverse_fetch2;
    *string_ptr = reverse_byte;
  }
  while ( reverse_counter != (_DWORD *)((char *)hash_final_data + 3) );
  work_str = (char *)binary_to_hex_string(miner_data, 128);
  output_prefix = "o";
  midstate_str = (char *)binary_to_hex_string(chip_info, 32);
  data_str = (char *)binary_to_hex_string(&state_data, 12);
  nonce_str_screen = (char *)binary_to_hex_string(nonce_data, 4);
  nonce_str = (char *)binary_to_hex_string(nonce_data, 5);
  hash_str = (char *)binary_to_hex_string(hash_initial_data, 32);
  difficulty = calculate_miner_efficiency(miner_data);
  HIDWORD(difficulty_long) = difficulty_high;
  if ( !output_flag )
    output_prefix = "x";
  LODWORD(difficulty_long) = difficulty;
  sprintf(
    output_buffer,
    "%s %08x midstate %s data %s nonce %s hash %s diff %lld",
    output_prefix,
    miner_data[85],
    midstate_str,
    data_str,
    nonce_str,
    hash_str,
    difficulty,
    difficulty_high);
  if ( !strcmp((const char *)dword_66850, "screen") )
  {
    if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
    {
      snprintf(screen_buffer, 2048u, output_buffer);
      log_event(3, screen_buffer, 0);
    }
  }
  else
  {
    flag_ptr = &byte_70CE8;
    if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
    {
      snprintf(screen_buffer, 2048u, output_buffer);
      log_event(3, screen_buffer, 0);
    }
    if ( dword_683E0 )
    {
      sprintf(
        output_buffer,
        "%s %08x work %s midstate %s data %s nonce %s hash %s diff %lld",
        output_prefix,
        miner_data[85],
        work_str,
        midstate_str,
        data_str,
        nonce_str,
        hash_str,
        difficulty_long);
      output_length = strlen(output_buffer);
      fwrite(output_buffer, output_length, 1u, (FILE *)dword_683E0);
      fwrite("\n", 1u, 1u, (FILE *)dword_683E0);
      fflush((FILE *)dword_683E0);
      if ( output_flag )
      {
        file_mode = dword_683DC;
        if ( dword_683DC == 1 )
        {
          sprintf(
            output_buffer,
            "midstate %s data %s nonce %s hash %s",
            midstate_str,
            data_str,
            nonce_str_screen,
            hash_str);
          output_str_length_2 = strlen(output_buffer);
          fwrite(output_buffer, output_str_length_2, file_mode, (FILE *)dword_683E4[0]);
          fwrite("\n", file_mode, file_mode, (FILE *)dword_683E4[0]);
          fflush((FILE *)dword_683E4[0]);
        }
        else if ( ((dword_683DC - 32) & 0xFFFFFFDF) == 0 )
        {
          sprintf(
            output_buffer,
            "midstate %s data %s nonce %s hash %s",
            midstate_str,
            data_str,
            nonce_str_screen,
            hash_str);
          file_index = get_encoding_type(dword_683DC, *nonce_data);
          file_length = strlen(output_buffer);
          fwrite(output_buffer, file_length, 1u, (FILE *)dword_683E4[file_index]);
          fwrite("\n", 1u, 1u, (FILE *)dword_683E4[file_index]);
          fflush((FILE *)dword_683E4[file_index]);
        }
        if ( byte_684E8 )
        {
          difficulty_bits = difficulty_long;
          for ( difficulty_num = 0; difficulty_num != 64; ++difficulty_num )
          {
            difficulty_bits >>= 1;
            if ( !difficulty_bits )
              break;
          }
          if ( byte_66641 && (*flag_ptr || byte_66640 || dword_657B8 > 6) )
          {
            snprintf(screen_buffer, 2048u, "work diff %lld diffnum %d", difficulty_long, difficulty_num);
            log_event(7, screen_buffer, 0);
          }
          sprintf(
            output_buffer,
            "midstate %s data %s nonce %s hash %s",
            midstate_str,
            data_str,
            nonce_str_screen,
            hash_str);
          output_str_length = strlen(output_buffer);
          fwrite(output_buffer, output_str_length, 1u, (FILE *)dword_684EC[difficulty_num]);
          fwrite("\n", 1u, 1u, (FILE *)dword_684EC[difficulty_num]);
          fflush((FILE *)dword_684EC[difficulty_num]);
        }
      }
    }
  }
  if ( work_str )
    free(work_str);
  if ( midstate_str )
    free(midstate_str);
  if ( data_str )
    free(data_str);
  if ( nonce_str_screen )
    free(nonce_str_screen);
  if ( nonce_str )
    free(nonce_str);
  if ( hash_str )
    free(hash_str);
}
// 266B0: variable 'difficulty_high' is possibly undefined
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 1E9B4: using guessed type int __fastcall sub_1E9B4(_DWORD, _DWORD);
// 26220: using guessed type int __fastcall sub_26220(_DWORD, _DWORD);
// 29244: using guessed type int __fastcall sub_29244(_DWORD);
// 657B8: using guessed type int dword_657B8;
// 66640: using guessed type char byte_66640;
// 66641: using guessed type char byte_66641;
// 66850: using guessed type int dword_66850;
// 683DC: using guessed type int dword_683DC;
// 683E0: using guessed type int dword_683E0;
// 683E4: using guessed type int dword_683E4[65];
// 684E8: using guessed type char byte_684E8;
// 684EC: using guessed type int dword_684EC[71];
// 70CE8: using guessed type char byte_70CE8;
// 26508: using guessed type _DWORD var_C88[3];
// 26508: using guessed type _DWORD var_C48[3];

//----- (00026B28) --------------------------------------------------------
void __fastcall process_if_miner_active(_DWORD *output_buffer, unsigned __int8 *input_data, int data_length)
{
  if ( dword_66850 )
    process_miner_output(output_buffer, input_data, data_length);
}
// 66850: using guessed type int dword_66850;

//----- (00026B40) --------------------------------------------------------
void __fastcall process_miner_data(_DWORD *output_buffer, int input_value, int input_length)
{
  int formatted_input_value; // [sp+0h] [bp-10h] BYREF
  char init_byte; // [sp+4h] [bp-Ch]

  if ( dword_66850 )
  {
    formatted_input_value = input_value;
    init_byte = 0;
    process_miner_output(output_buffer, (unsigned __int8 *)&formatted_input_value, input_length);
  }
}
// 66850: using guessed type int dword_66850;

//----- (00026CB0) --------------------------------------------------------
int __fastcall reverse_bytes_array(int end_pointer, unsigned int *source_array, unsigned int length)
{
  unsigned int num_words; // r2
  unsigned int *end_source; // r2
  unsigned int current_word; // t1

  num_words = length >> 2;
  if ( num_words )
  {
    end_source = &source_array[num_words];
    end_pointer -= 4;
    do
    {
      current_word = *source_array++;
      *(_DWORD *)(end_pointer + 4) = bswap32(current_word);
      end_pointer += 4;
    }
    while ( source_array != end_source );
  }
  return end_pointer;
}

//----- (00026CD8) --------------------------------------------------------
int __fastcall set_error_code(_DWORD *error_code_pointer)
{
  *error_code_pointer = 4;
  return 0;
}

//----- (00026CE8) --------------------------------------------------------
int __fastcall set_operation_mode(_DWORD *operation_mode_pointer)
{
  *operation_mode_pointer = 3;
  return 0;
}

//----- (00026CF8) --------------------------------------------------------
int __fastcall set_flag_to_true(_DWORD *flag_ptr)
{
  *flag_ptr = 1;
  return 0;
}

//----- (00026D08) --------------------------------------------------------
int __fastcall enable_miner(_BYTE *flag_ptr)
{
  *flag_ptr = 1;
  byte_66640 = 1;
  return 0;
}
// 66640: using guessed type char byte_66640;

//----- (00026D24) --------------------------------------------------------
int do_nothing()
{
  return 0;
}

//----- (00026D34) --------------------------------------------------------
int always_return_one()
{
  return 1;
}

//----- (00026D3C) --------------------------------------------------------
__int64 get_max_unsigned_int()
{
  return 4294967295LL;
}

//----- (00026D48) --------------------------------------------------------
int sub_26D48()
{
  return 1;
}

//----- (00026D54) --------------------------------------------------------
int get_static_zero()
{
  return 0;
}

//----- (00026D5C) --------------------------------------------------------
int __fastcall reset_miner_status(int status_pointer)
{
  *(_QWORD *)(status_pointer + 208) = 0LL;
  *(_DWORD *)(status_pointer + 44) = 0;
  *(_QWORD *)(status_pointer + 200) = 0LL;
  return status_pointer;
}

//----- (00026D78) --------------------------------------------------------
void __noreturn log_error_and_exit(const char *format, ...)
{
  va_list args; // [sp+14h] [bp-Ch] BYREF

  va_start(args, format);
  vsnprintf(byte_66648, 512u, format, args);
  log_event(3, byte_66648, 1);
  exit(1);
}

//----- (00026DC0) --------------------------------------------------------
int __fastcall configure_miner_settings(int config_ptr, int unused_param, int param3, int param4)
{
  set_value(config_ptr, &unk_66848, param3, param4);
  return 0;
}
// 3CDAC: using guessed type int __fastcall sub_3CDAC(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00026DD8) --------------------------------------------------------
int __fastcall init_hardware_settings(int hardware_id, int unused_param, int config_param1, int config_param2)
{
  set_value(hardware_id, &unk_6684C, config_param1, config_param2);
  return 0;
}
// 3CDAC: using guessed type int __fastcall sub_3CDAC(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00026DF0) --------------------------------------------------------
int __fastcall initialize_miner_command(int command_buffer, int unused_parameter, int command_length, int command_code)
{
  set_value(command_buffer, &dword_66850, command_length, command_code);
  return 0;
}
// 3CDAC: using guessed type int __fastcall sub_3CDAC(_DWORD, _DWORD, _DWORD, _DWORD);
// 66850: using guessed type int dword_66850;

//----- (00026E08) --------------------------------------------------------
int __fastcall init_miner_config(int config, int unused_param, int param3, int param4)
{
  set_value(config, &unk_66854, param3, param4);
  return 0;
}
// 3CDAC: using guessed type int __fastcall sub_3CDAC(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00026E20) --------------------------------------------------------
int __fastcall initialize_miner_configuration(int config, int unused_param, int config_option, int config_value)
{
  set_value(config, &dword_66858, config_option, config_value);
  return 0;
}
// 3CDAC: using guessed type int __fastcall sub_3CDAC(_DWORD, _DWORD, _DWORD, _DWORD);
// 66858: using guessed type int dword_66858;

//----- (00026E38) --------------------------------------------------------
int __fastcall set_miner_config_values(int config_handle, int unused_param, int value1, int value2)
{
  set_value(config_handle, &dword_72F54);
  return 0;
}
// 72F54: using guessed type int dword_72F54;

//----- (00027064) --------------------------------------------------------
int __fastcall escape_json_string(const char *input_string)
{
  const char *str_ptr; // r4
  size_t str_len; // r0
  int escaped_str_ptr; // r5
  int *memory_block_ptr; // r0
  int prev_memory_block; // r2
  _BYTE *write_ptr; // r2
  int current_char; // r3
  bool is_special_char; // zf
  _BYTE *write_ptr_inc; // r3
  char char_to_write; // t1
  int result_ptr; // r0

  str_ptr = input_string;
  str_len = strlen(input_string);
  escaped_str_ptr = safe_malloc_with_logging(2 * str_len + 1, "cgminer.c", "json_escape", 5960);
  memory_block_ptr = (int *)safe_malloc_with_logging(8, "cgminer.c", "json_escape", 5961);
  *memory_block_ptr = escaped_str_ptr;
  prev_memory_block = dword_66860;
  dword_66860 = (int)memory_block_ptr;
  memory_block_ptr[1] = prev_memory_block;
  write_ptr = (_BYTE *)escaped_str_ptr;
  for ( current_char = *(unsigned __int8 *)str_ptr; *str_ptr; current_char = *(unsigned __int8 *)str_ptr )
  {
    is_special_char = current_char == 34;
    if ( current_char != 34 )
      is_special_char = current_char == 92;
    write_ptr_inc = write_ptr + 1;
    if ( is_special_char )
    {
      *write_ptr = 92;
      write_ptr += 2;
    }
    else
    {
      write_ptr_inc = write_ptr++;
    }
    char_to_write = *str_ptr++;
    *write_ptr_inc = char_to_write;
  }
  result_ptr = escaped_str_ptr;
  *write_ptr = 0;
  return result_ptr;
}
// 1E74C: using guessed type int __fastcall sub_1E74C(_DWORD, _DWORD, _DWORD, _DWORD);
// 66860: using guessed type int dword_66860;

//----- (0002711C) --------------------------------------------------------
void __fastcall __noreturn print_help_and_exit(const char *program_name)
{
  char *help_message; // r0

  printf("%s\nBuilt with bitmain_c5 mining support.\n", s);
  help_message = generate_help_message((const char *)dword_74250, program_name);
  printf("%s", help_message);
  fflush((FILE *)stdout);
  exit(0);
}
// 664F4: using guessed type int stdout;
// 74250: using guessed type int dword_74250;

//----- (00027174) --------------------------------------------------------
time_t __fastcall update_timestamp_and_enable(int device_state_ptr)
{
  int device_info_ptr; // r4
  time_t current_time; // r0

  *(_BYTE *)(device_state_ptr + 61) = 1;
  get_hardware_timestamp((__time_t *)(device_state_ptr + 44));
  *(_DWORD *)(*(_DWORD *)(device_state_ptr + 36) + 96) = 0;
  device_info_ptr = *(_DWORD *)(device_state_ptr + 36);
  current_time = time(0);
  *(_DWORD *)(device_info_ptr + 240) = current_time;
  return current_time;
}

//----- (000271AC) --------------------------------------------------------
time_t __fastcall update_hardware_timestamp(int hardware_info_ptr)
{
  int hardware_inner_ptr; // r4
  time_t current_time; // r0

  *(_BYTE *)(hardware_info_ptr + 61) = 0;
  get_hardware_timestamp((__time_t *)(hardware_info_ptr + 44));
  *(_DWORD *)(*(_DWORD *)(hardware_info_ptr + 36) + 96) = 0;
  hardware_inner_ptr = *(_DWORD *)(hardware_info_ptr + 36);
  current_time = time(0);
  *(_DWORD *)(hardware_inner_ptr + 240) = current_time;
  return current_time;
}

//----- (000271E0) --------------------------------------------------------
int __fastcall format_hashrate(unsigned __int64 hashrate_raw, char *buffer, size_t buffer_size, int precision_flag)
{
  double formatted_hashrate; // d8
  int decimal_precision; // r1
  double log_result; // r0
  __int16 unit_suffix[22]; // [sp+1Ch] [bp-2Ch] BYREF

  unit_suffix[0] = 0;
  if ( hashrate_raw <= 999999999999999999LL )
  {
    if ( hashrate_raw <= 999999999999999LL )
    {
      if ( hashrate_raw > 999999999999LL )
      {
        hashrate_raw = check_and_execute(hashrate_raw, HIDWORD(hashrate_raw), 1000000000, 0);
        unit_suffix[0] = 84;
        formatted_hashrate = (double)(int)hashrate_raw / 1000.0;
        if ( !precision_flag )
          return snprintf(buffer, buffer_size, "%.3g%s", formatted_hashrate, (const char *)unit_suffix);
      }
      else if ( hashrate_raw <= 999999999 )
      {
        if ( hashrate_raw > 999999 )
        {
          hashrate_raw = check_and_execute(hashrate_raw, HIDWORD(hashrate_raw), 1000, 0);
          unit_suffix[0] = 77;
          formatted_hashrate = (double)(int)hashrate_raw / 1000.0;
          if ( !precision_flag )
            return snprintf(buffer, buffer_size, "%.3g%s", formatted_hashrate, (const char *)unit_suffix);
        }
        else
        {
          formatted_hashrate = (double)(int)hashrate_raw;
          if ( hashrate_raw <= 999 )
          {
            if ( !precision_flag )
              return snprintf(buffer, buffer_size, "%d%s", (_DWORD)hashrate_raw, (const char *)unit_suffix);
          }
          else
          {
            unit_suffix[0] = 75;
            formatted_hashrate = formatted_hashrate / 1000.0;
            if ( !precision_flag )
              return snprintf(buffer, buffer_size, "%.3g%s", formatted_hashrate, (const char *)unit_suffix);
          }
        }
      }
      else
      {
        hashrate_raw = check_and_execute(hashrate_raw, HIDWORD(hashrate_raw), 1000000, 0);
        unit_suffix[0] = 71;
        formatted_hashrate = (double)(int)hashrate_raw / 1000.0;
        if ( !precision_flag )
          return snprintf(buffer, buffer_size, "%.3g%s", formatted_hashrate, (const char *)unit_suffix);
      }
    }
    else
    {
      hashrate_raw = check_and_execute(hashrate_raw, HIDWORD(hashrate_raw), -727379968, 232);
      unit_suffix[0] = 80;
      formatted_hashrate = (double)(int)hashrate_raw / 1000.0;
      if ( !precision_flag )
        return snprintf(buffer, buffer_size, "%.3g%s", formatted_hashrate, (const char *)unit_suffix);
    }
  }
  else
  {
    hashrate_raw = check_and_execute(hashrate_raw, HIDWORD(hashrate_raw), -1530494976, 232830);
    unit_suffix[0] = 69;
    formatted_hashrate = (double)(int)hashrate_raw / 1000.0;
    if ( !precision_flag )
      return snprintf(buffer, buffer_size, "%.3g%s", formatted_hashrate, (const char *)unit_suffix);
  }
  if ( formatted_hashrate > 0.0 )
  {
    log_result = log10(*(double *)&hashrate_raw);
    floor(log_result);
    decimal_precision = (int)(3.0 - formatted_hashrate);
  }
  else
  {
    decimal_precision = 3;
  }
  return snprintf(
           buffer,
           buffer_size,
           "%*.*f%s",
           precision_flag + 1,
           decimal_precision,
           formatted_hashrate,
           (const char *)unit_suffix);
}
// 49368: using guessed type __int64 __fastcall sub_49368(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00027498) --------------------------------------------------------
int __fastcall calculate_hashrate_metrics(int hash_data)
{
  double initial_hashrate; // d0
  int metrics_pointer; // r4
  double current_hashrate; // d8
  unsigned __int64 hashed_value; // r0
  int hash_format_result; // r0
  double previous_hashrate; // d7
  double secondary_hashrate; // d7
  double hashrate_part1; // r0
  double initial_calculation; // d8
  double hashrate_part2; // r0
  double secondary_calculation; // d8
  double hashrate_part3; // r0
  double tertiary_calculation; // d8
  double hashrate_part4; // r0
  double final_hashrate_calculation; // d7

  metrics_pointer = *(_DWORD *)(hash_data + 260);
  if ( initial_hashrate == 0.0 )
  {
    LODWORD(hashrate_part1) = check_null_pointer(*(_QWORD *)(hash_data + 184));
    initial_calculation = hashrate_part1 * 6.27710174e57;
    LODWORD(hashrate_part2) = check_null_pointer(*(_QWORD *)(hash_data + 176));
    secondary_calculation = initial_calculation + hashrate_part2 * 3.40282367e38;
    LODWORD(hashrate_part3) = check_null_pointer(*(_QWORD *)(hash_data + 168));
    tertiary_calculation = secondary_calculation + hashrate_part3 * 1.84467441e19;
    LODWORD(hashrate_part4) = check_null_pointer(*(_QWORD *)(hash_data + 160));
    final_hashrate_calculation = hashrate_part4 + tertiary_calculation;
    if ( hashrate_part4 + tertiary_calculation == 0.0 )
    {
      current_hashrate = 2.69595353e67;
      hashed_value = -1LL;
    }
    else
    {
      current_hashrate = 2.69595353e67 / final_hashrate_calculation;
      round(LODWORD(hashrate_part4));
      LODWORD(hashed_value) = calculate_hash_value(2.69595353e67 / final_hashrate_calculation);
    }
    *(double *)(hash_data + 376) = current_hashrate;
  }
  else
  {
    *(double *)(hash_data + 376) = initial_hashrate;
    current_hashrate = initial_hashrate;
    round(hash_data);
    LODWORD(hashed_value) = calculate_hash_value(initial_hashrate);
  }
  *(double *)(metrics_pointer + 480) = current_hashrate;
  hash_format_result = format_hashrate(hashed_value, (char *)(*(_DWORD *)(hash_data + 260) + 48), 8u, 0);
  previous_hashrate = *(double *)(metrics_pointer + 464);
  if ( previous_hashrate == current_hashrate )
  {
    ++*(_DWORD *)(metrics_pointer + 488);
    goto LABEL_5;
  }
  if ( previous_hashrate <= current_hashrate )
  {
    if ( previous_hashrate != 0.0 )
    {
LABEL_5:
      secondary_hashrate = *(double *)(metrics_pointer + 472);
      if ( secondary_hashrate != current_hashrate )
        goto LABEL_6;
LABEL_15:
      ++*(_DWORD *)(metrics_pointer + 492);
      return hash_format_result;
    }
    *(double *)(metrics_pointer + 464) = current_hashrate;
    *(_DWORD *)(metrics_pointer + 488) = 1;
  }
  else
  {
    *(double *)(metrics_pointer + 464) = current_hashrate;
    *(_DWORD *)(metrics_pointer + 488) = 1;
  }
  secondary_hashrate = *(double *)(metrics_pointer + 472);
  if ( secondary_hashrate == current_hashrate )
    goto LABEL_15;
LABEL_6:
  if ( secondary_hashrate < current_hashrate )
  {
    *(double *)(metrics_pointer + 472) = current_hashrate;
    *(_DWORD *)(metrics_pointer + 492) = 1;
  }
  return hash_format_result;
}
// 274B4: variable 'initial_hashrate' is possibly undefined
// 274E4: variable 'hashed_value' is possibly undefined
// 27548: variable 'hashrate_part1' is possibly undefined
// 2755C: variable 'hashrate_part2' is possibly undefined
// 27570: variable 'hashrate_part3' is possibly undefined
// 2757C: variable 'hashrate_part4' is possibly undefined
// 121B0: using guessed type int __fastcall round(_DWORD);

//----- (00027638) --------------------------------------------------------
int __fastcall sub_27638(int a1)
{
  int v2; // r1
  char *v3; // r2
  unsigned int v4; // t1
  _BYTE v6[28]; // [sp+0h] [bp-78h] BYREF
  char v7; // [sp+1Ch] [bp-5Ch] BYREF
  char v8[76]; // [sp+20h] [bp-58h] BYREF
  char v9; // [sp+6Ch] [bp-Ch] BYREF

  v2 = a1 - 4;
  v3 = &v7;
  do
  {
    v4 = *(_DWORD *)(v2 + 4);
    v2 += 4;
    *((_DWORD *)v3 + 1) = bswap32(v4);
    v3 += 4;
  }
  while ( v3 != &v9 );
  initialize_and_process_data((int)v8, 80u, (int)v6);
  return initialize_and_process_data((int)v6, 32u, a1 + 192);
}
// 27638: using guessed type char var_58[76];

//----- (0002768C) --------------------------------------------------------
void __fastcall calculate_midstate(int initial_address)
{
  int adjusted_address; // r1
  int *pointer_to_hash; // r2
  unsigned int hash_part; // t1
  int first_hash_part; // [sp+4h] [bp-F4h] BYREF
  char hash_buffer[60]; // [sp+8h] [bp-F0h] BYREF
  char buffer_end; // [sp+44h] [bp-B4h] BYREF
  char midstate_buffer[136]; // [sp+48h] [bp-B0h] BYREF
  char error_buffer; // [sp+D0h] [bp-28h] BYREF

  adjusted_address = initial_address - 4;
  pointer_to_hash = &first_hash_part;
  do
  {
    hash_part = *(_DWORD *)(adjusted_address + 4);
    adjusted_address += 4;
    pointer_to_hash[1] = bswap32(hash_part);
    ++pointer_to_hash;
  }
  while ( pointer_to_hash != (int *)&buffer_end );
  reset_asic_status(midstate_buffer, adjusted_address);
  update_internal_buffer((int)midstate_buffer, (int)hash_buffer, 64u);
  log_memcpy_error((void *)(initial_address + 128), &error_buffer, 32u, (int)"cgminer.c", (int)"calc_midstate", 2289);
}
// 1D800: using guessed type int __fastcall sub_1D800(_DWORD, _DWORD);
// 2768C: using guessed type char var_F0[60];

//----- (00027704) --------------------------------------------------------
void initialize_mining_threads()
{
  int miner_index; // r4
  int miner_struct_ptr; // r3
  const pthread_attr_t *thread_attr; // r1
  char log_buffer[2080]; // [sp+0h] [bp-820h] BYREF

  if ( dword_70DB8 > 0 )
  {
    miner_index = 0;
    do
    {
      while ( 1 )
      {
        miner_struct_ptr = *(_DWORD *)(dword_70E5C + 4 * miner_index);
        if ( !*(_BYTE *)(miner_struct_ptr + 284) )
        {
          thread_attr = (const pthread_attr_t *)(unsigned __int8)byte_66964;
          if ( !byte_66964 )
          {
            *(_BYTE *)(miner_struct_ptr + 284) = 1;
            pthread_create(
              (pthread_t *)(miner_struct_ptr + 280),
              thread_attr,
              (void *(*)(void *))run_mining_thread,
              (void *)miner_struct_ptr);
            if ( byte_66641 )
            {
              if ( byte_70CE8 || byte_66640 || dword_657B8 > 6 )
                break;
            }
          }
        }
        if ( dword_70DB8 <= ++miner_index )
          return;
      }
      snprintf(log_buffer, 2048u, "create test_pool_thread pool[%d]\n");
      ++miner_index;
      log_event(7, log_buffer, 0);
    }
    while ( dword_70DB8 > miner_index );
  }
}
// 657B8: using guessed type int dword_657B8;
// 66640: using guessed type char byte_66640;
// 66641: using guessed type char byte_66641;
// 66964: using guessed type char byte_66964;
// 70CE8: using guessed type char byte_70CE8;
// 70DB8: using guessed type int dword_70DB8;
// 70E5C: using guessed type int dword_70E5C;

//----- (00027820) --------------------------------------------------------
int detach_current_thread()
{
  pthread_t current_thread_id; // r0

  current_thread_id = pthread_self();
  pthread_detach(current_thread_id);
  return 0;
}

//----- (00027834) --------------------------------------------------------
int __fastcall initialize_miner_thread(int miner_thread_struct)
{
  int miner_data; // r6
  int miner_functions; // r5
  char miner_dir[16]; // [sp+0h] [bp-820h] BYREF
  char waiting_log_message[2064]; // [sp+10h] [bp-810h] BYREF

  miner_data = *(_DWORD *)(miner_thread_struct + 36);
  miner_functions = *(_DWORD *)(miner_data + 4);
  snprintf(miner_dir, 16u, "%d/Miner", *(_DWORD *)miner_thread_struct);
  set_process_name(miner_dir);
  update_timestamp_and_enable(miner_thread_struct);
  if ( (*(int (__fastcall **)(int))(miner_functions + 52))(miner_thread_struct) )
  {
    if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
    {
      strcpy(waiting_log_message, "Waiting on sem in miner thread");
      log_event(7, waiting_log_message, 0);
    }
    wait_for_semaphore((sem_t *)(miner_thread_struct + 16));
    *(_DWORD *)(miner_data + 232) = time(0);
    (*(void (__fastcall **)(int))(miner_functions + 60))(miner_thread_struct);
    (*(void (__fastcall **)(int))(miner_functions + 88))(miner_thread_struct);
    return 0;
  }
  else
  {
    update_statistic_counters(miner_data, 0);
    return 0;
  }
}
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 21AD4: using guessed type int __fastcall sub_21AD4(_DWORD, _DWORD);
// 21DB8: using guessed type int __fastcall sub_21DB8(_DWORD);
// 27174: using guessed type int __fastcall sub_27174(_DWORD);
// 657B8: using guessed type int dword_657B8;
// 66640: using guessed type char byte_66640;
// 66641: using guessed type char byte_66641;
// 70CE8: using guessed type char byte_70CE8;

//----- (00027970) --------------------------------------------------------
void __noreturn terminate_process_after_delay()
{
  pthread_t current_thread; // r0

  current_thread = pthread_self();
  pthread_detach(current_thread);
  pthread_setcanceltype(1, 0);
  sleep(7u);
  exit(1);
}

//----- (00027998) --------------------------------------------------------
_DWORD *__fastcall increment_counter_and_set_flag(_DWORD *flag_ptr)
{
  ++dword_72E7C;
  *flag_ptr = 1;
  return flag_ptr;
}
// 72E7C: using guessed type int dword_72E7C;

//----- (000279B8) --------------------------------------------------------
int __fastcall check_status_flags(unsigned __int8 *status_flags)
{
  int first_flag; // r3

  first_flag = status_flags[640];
  if ( status_flags[640] && status_flags[641] )
    return status_flags[643] ^ 1;
  return first_flag;
}

//----- (000279DC) --------------------------------------------------------
int __fastcall find_min_timestamp_device(int current_device)
{
  int min_timestamp; // r7
  int selected_device; // r5
  int *device_ptr; // r4
  int end_ptr; // r6
  int temp_device; // r1
  int device_index; // t1
  int temp_device_again; // r1
  int result_device; // r0

  min_timestamp = *(_DWORD *)(current_device + 156);
  selected_device = current_device;
  if ( dword_70DB8 > 0 )
  {
    device_ptr = (int *)dword_70E5C;
    end_ptr = dword_70E5C + 4 * dword_70DB8;
    do
    {
      device_index = *device_ptr++;
      temp_device = device_index;
      if ( !*(_BYTE *)(device_index + 97)
        && *(_DWORD *)(temp_device + 100) == 1
        && !check_status_flags((unsigned __int8 *)temp_device)
        && *(_DWORD *)(temp_device_again + 156) < min_timestamp )
      {
        selected_device = temp_device_again;
        min_timestamp = *(_DWORD *)(temp_device_again + 156);
      }
    }
    while ( device_ptr != (int *)end_ptr );
    min_timestamp = *(_DWORD *)(selected_device + 156);
  }
  result_device = selected_device;
  *(_DWORD *)(selected_device + 156) = min_timestamp + 1;
  return result_device;
}
// 27A38: variable 'temp_device_again' is possibly undefined
// 70DB8: using guessed type int dword_70DB8;
// 70E5C: using guessed type int dword_70E5C;

//----- (00027A64) --------------------------------------------------------
int __fastcall get_miner_pool_index(int pool_index)
{
  char log_buffer[2056]; // [sp+0h] [bp-808h] BYREF

  if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
  {
    snprintf(log_buffer, 2048u, "WTF No pool %d found!", pool_index);
    log_event(3, log_buffer, 0);
  }
  return *(_DWORD *)(dword_70E5C + 4 * pool_index);
}
// 657B8: using guessed type int dword_657B8;
// 66640: using guessed type char byte_66640;
// 70CE8: using guessed type char byte_70CE8;
// 70E5C: using guessed type int dword_70E5C;

//----- (00027AF0) --------------------------------------------------------
int __fastcall get_connection_handle_by_id(int connection_id)
{
  int current_handle_ptr; // r2
  int current_handle; // r1
  int index; // r3
  int next_handle; // t1

  if ( dword_70DB8 <= 0 )
    return get_miner_pool_index(connection_id);
  current_handle_ptr = dword_70E5C;
  current_handle = *(_DWORD *)dword_70E5C;
  if ( *(_DWORD *)(*(_DWORD *)dword_70E5C + 4) != connection_id )
  {
    index = 0;
    while ( ++index != dword_70DB8 )
    {
      next_handle = *(_DWORD *)(current_handle_ptr + 4);
      current_handle_ptr += 4;
      current_handle = next_handle;
      if ( *(_DWORD *)(next_handle + 4) == connection_id )
        return current_handle;
    }
    return get_miner_pool_index(connection_id);
  }
  return current_handle;
}
// 70DB8: using guessed type int dword_70DB8;
// 70E5C: using guessed type int dword_70E5C;

//----- (00027B58) --------------------------------------------------------
const char *__fastcall validate_and_set_time(const char *time_string)
{
  const char *validation_message; // r0

  if ( sscanf(time_string, "%d:%d", &dword_72E94, &dword_72E90) != 2 )
    return "Invalid time set, should be HH:MM";
  if ( (unsigned int)dword_72E94 > 23 || (unsigned int)dword_72E90 > 59 )
    return "Invalid time set.";
  validation_message = 0;
  byte_72E88 = 1;
  return validation_message;
}
// 72E88: using guessed type char byte_72E88;
// 72E90: using guessed type int dword_72E90;
// 72E94: using guessed type int dword_72E94;

//----- (00027BC4) --------------------------------------------------------
char *__fastcall check_and_parse_json_file(const char *file_path)
{
  bool negative_flag; // nf
  _DWORD *parse_result; // r0
  size_t file_path_length; // r6
  size_t formatted_string_length; // r6
  char *error_message; // r4
  char unused_buffer[92]; // [sp+Ch] [bp-114h] BYREF
  char error_details[184]; // [sp+68h] [bp-B8h] BYREF

  if ( !dword_66968 )
    dword_66968 = (int)_strdup(file_path);
  negative_flag = dword_6696C - 9 < 0;
  ++dword_6696C;
  if ( !(negative_flag ^ __OFSUB__(dword_6696C, 10) | (dword_6696C == 10)) )
    return "Too many levels of JSON includes (limit 10) or a loop";
  parse_result = (_DWORD *)handle_file_processing(file_path, 0, unused_buffer);
  if ( parse_result && !*parse_result )
  {
    byte_66970 = 1;
    return parse_json_option((int)parse_result, 1);
  }
  else
  {
    file_path_length = strlen(file_path);
    formatted_string_length = file_path_length + strlen(error_details) + 35;
    error_message = (char *)safe_malloc_with_logging(formatted_string_length, "cgminer.c", "load_config", 2156);
    snprintf(error_message, formatted_string_length, "JSON decode of file '%s' failed\n %s", file_path, error_details);
    return error_message;
  }
}
// 1E74C: using guessed type int __fastcall sub_1E74C(_DWORD, _DWORD, _DWORD, _DWORD);
// 467A0: using guessed type int __fastcall sub_467A0(_DWORD, _DWORD, _DWORD);
// 66968: using guessed type int dword_66968;
// 6696C: using guessed type int dword_6696C;
// 66970: using guessed type char byte_66970;
// 27BC4: using guessed type char var_114[92];

//----- (00027CC0) --------------------------------------------------------
char *__fastcall parse_json_option(int json_tree, int error_flag)
{
  char **current_option; // r4
  char *option_type; // r3
  const char *option_name; // r0
  char *option_name_copy; // r10
  char *token; // r5
  _DWORD *json_value; // r0
  int option_flags; // r1
  int json_value_type; // r3
  char *error_message; // r3
  _DWORD *include_json_value; // r0
  int include_file_path; // r0
  int option_value_pointer; // r0
  int include_status; // r0
  _DWORD *array_json_value; // r10
  int array_index; // r5
  _DWORD *array_item_json_value; // r0
  int array_item_status; // r0
  int converted_value; // [sp+10h] [bp-838h]
  char *option_name_array_copy; // [sp+10h] [bp-838h]
  char *array_error_message; // [sp+14h] [bp-834h]
  char *token_array; // [sp+14h] [bp-834h]
  int array_converted_value; // [sp+18h] [bp-830h]
  char *array_item_error_message; // [sp+1Ch] [bp-82Ch]
  char error_buffer[2088]; // [sp+20h] [bp-828h] BYREF

  if ( error_flag && !dword_66A3C )
    dword_66A3C = 1;
  if ( dword_659E4 == 16 )
    goto LABEL_28;
  if ( (dword_659E4 & 8) != 0 )
LABEL_53:
    _assert_fail("!(opt->type & OPT_SUBTABLE)", "cgminer.c", 1988u, "parse_config");
  current_option = &off_659FC;
  while ( 1 )
  {
    option_name = *(current_option - 7);
    if ( !option_name )
    {
      option_type = current_option[1];
      if ( option_type == (char *)16 )
        break;
      goto LABEL_8;
    }
    option_name_copy = _strdup(option_name);
    token = strtok(option_name_copy, "|");
    if ( !token )
      goto LABEL_27;
    while ( 2 )
    {
      if ( token[1] != 45 )
        goto LABEL_12;
      json_value = (_DWORD *)validate_and_fetch_data(json_tree, token + 2);
      if ( !json_value )
        goto LABEL_12;
      option_flags = (int)*(current_option - 6);
      json_value_type = *json_value;
      if ( (option_flags & 6) == 0 )
      {
LABEL_18:
        if ( (unsigned int)(json_value_type - 5) > 1 )
        {
          error_message = "Invalid value";
          goto LABEL_21;
        }
        option_value_pointer = (int)*(current_option - 2);
        if ( (option_flags & 1) == 0 )
        {
          if ( json_value_type == 5 )
            set_flag(option_value_pointer);
          else
            reset_first_byte_to_zero(option_value_pointer);
          goto LABEL_12;
        }
        error_message = (char *)((int (__fastcall *)(int))*(current_option - 5))(option_value_pointer);
        goto LABEL_33;
      }
      if ( json_value_type == 2 )
      {
        converted_value = get_linked_item_or_null(json_value);
        include_status = ((int (__fastcall *)(int, _DWORD))*(current_option - 4))(
                           converted_value,
                           *(current_option - 2));
        error_message = (char *)include_status;
        if ( *(current_option - 6) == (char *)4 )
        {
          array_error_message = (char *)include_status;
          set_value(converted_value, *(current_option - 2), 4, include_status);
          error_message = array_error_message;
        }
LABEL_33:
        if ( !error_message )
          goto LABEL_12;
        if ( error_flag )
          goto LABEL_22;
LABEL_35:
        snprintf(byte_66974, 200u, "Parsing JSON option %s: %s", token, error_message);
        return byte_66974;
      }
      if ( json_value_type != 1 )
        goto LABEL_18;
      option_name_array_copy = option_name_copy;
      array_json_value = json_value;
      token_array = token;
      array_index = 0;
      if ( !get_next_structure_pointer(json_value) )
      {
LABEL_46:
        option_name_copy = option_name_array_copy;
        goto LABEL_12;
      }
      while ( 1 )
      {
        array_item_json_value = (_DWORD *)get_task_by_index(array_json_value, array_index);
        if ( !array_item_json_value )
          goto LABEL_46;
        if ( *array_item_json_value == 2 )
          break;
        if ( !*array_item_json_value )
        {
          error_message = parse_json_option((int)array_item_json_value, 0);
          goto LABEL_49;
        }
LABEL_45:
        if ( get_next_structure_pointer(array_json_value) <= (unsigned int)++array_index )
          goto LABEL_46;
      }
      array_converted_value = get_linked_item_or_null(array_item_json_value);
      array_item_status = ((int (__fastcall *)(int, _DWORD))*(current_option - 4))(
                            array_converted_value,
                            *(current_option - 2));
      error_message = (char *)array_item_status;
      if ( *(current_option - 6) == (char *)4 )
      {
        array_item_error_message = (char *)array_item_status;
        set_value(array_converted_value, *(current_option - 2), 4, array_item_status);
        error_message = array_item_error_message;
      }
LABEL_49:
      if ( !error_message )
        goto LABEL_45;
      option_name_copy = option_name_array_copy;
      token = token_array;
LABEL_21:
      if ( !error_flag )
        goto LABEL_35;
LABEL_22:
      if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
      {
        snprintf(error_buffer, 2048u, "Invalid config option %s: %s", token, error_message);
        log_event(3, error_buffer, 0);
      }
      dword_66A3C = -1;
LABEL_12:
      token = strtok(0, "|");
      if ( token )
        continue;
      break;
    }
LABEL_27:
    free(option_name_copy);
    option_type = current_option[1];
    if ( option_type == (char *)16 )
      break;
LABEL_8:
    current_option += 7;
    if ( ((unsigned __int8)option_type & 8) != 0 )
      goto LABEL_53;
  }
LABEL_28:
  include_json_value = (_DWORD *)validate_and_fetch_data(json_tree, "include");
  if ( !include_json_value || *include_json_value != 2 )
    return 0;
  include_file_path = get_linked_item_or_null(include_json_value);
  return (char *)check_and_parse_json_file(include_file_path, 0);
}
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 27BC4: using guessed type int __fastcall sub_27BC4(_DWORD, _DWORD);
// 3CCC8: using guessed type int __fastcall sub_3CCC8(_DWORD);
// 3CCD8: using guessed type int __fastcall sub_3CCD8(_DWORD);
// 3CDAC: using guessed type int __fastcall sub_3CDAC(_DWORD, _DWORD, _DWORD, _DWORD);
// 472EC: using guessed type int __fastcall sub_472EC(_DWORD, _DWORD);
// 47658: using guessed type int __fastcall sub_47658(_DWORD);
// 47674: using guessed type int __fastcall sub_47674(_DWORD, _DWORD);
// 47820: using guessed type int __fastcall sub_47820(_DWORD);
// 657B8: using guessed type int dword_657B8;
// 659E4: using guessed type int dword_659E4;
// 659FC: using guessed type char *off_659FC;
// 66640: using guessed type char byte_66640;
// 66A3C: using guessed type int dword_66A3C;
// 70CE8: using guessed type char byte_70CE8;

//----- (00028048) --------------------------------------------------------
int is_within_operational_time_range()
{
  struct tm *time_struct; // r0
  int hardware_timestamp_flag; // r12
  int v2; // r7
  int current_minute; // r6
  int current_hour; // r4
  int tm_hour; // r12
  _BOOL4 before_start_minute; // r7
  _BOOL4 start_time_check; // r1
  _BOOL4 end_time_check; // r5
  _BOOL4 after_end_time; // r2
  time_t current_time; // [sp+4h] [bp-24h] BYREF
  int hardware_timestamp[2]; // [sp+8h] [bp-20h] BYREF

  get_hardware_timestamp(hardware_timestamp);
  current_time = hardware_timestamp[0];
  time_struct = localtime(&current_time);
  hardware_timestamp_flag = (unsigned __int8)byte_73F88;
  if ( byte_73F88 )
  {
    v2 = (unsigned __int8)byte_72E88;
    current_minute = time_struct->tm_min;
    current_hour = time_struct->tm_hour;
    if ( byte_72E88 )
    {
      if ( dword_72E94 > dword_73F94
        || (dword_72E90 > dword_73F90 ? (start_time_check = dword_72E94 == dword_73F94) : (start_time_check = 0),
            start_time_check) )
      {
        if ( dword_72E94 > current_hour
          || (dword_72E90 > current_minute ? (v2 = dword_72E94 == current_hour) : (v2 = 0), v2) )
        {
          if ( dword_73F94 <= current_hour )
          {
            after_end_time = dword_73F90 > current_minute && dword_73F94 == current_hour;
            return !after_end_time;
          }
          else
          {
            return 0;
          }
        }
      }
      else if ( dword_73F94 > current_hour
             || (dword_73F90 > current_minute ? (end_time_check = dword_73F94 == current_hour) : (end_time_check = 0),
                 end_time_check) )
      {
        if ( dword_72E94 <= current_hour )
          return dword_72E90 > current_minute && dword_72E94 == current_hour;
      }
    }
    else if ( dword_73F94 <= current_hour && (dword_73F90 <= current_minute || dword_73F94 != current_hour) )
    {
      byte_73F88 = byte_72E88;
      return hardware_timestamp_flag;
    }
    return v2;
  }
  tm_hour = time_struct->tm_hour;
  if ( tm_hour < dword_72E94 )
    return 1;
  before_start_minute = time_struct->tm_min < dword_72E90;
  if ( tm_hour != dword_72E94 )
    return 0;
  return before_start_minute;
}
// 280B8: masking with 0x1 was optimized away because r1.4 <= 0x1
// 2815C: masking with 0x1 was optimized away because r1.4 <= 0x1
// 72E88: using guessed type char byte_72E88;
// 72E90: using guessed type int dword_72E90;
// 72E94: using guessed type int dword_72E94;
// 73F88: using guessed type char byte_73F88;
// 73F90: using guessed type int dword_73F90;
// 73F94: using guessed type int dword_73F94;
// 28048: using guessed type __time_t var_20[2];

//----- (000281D4) --------------------------------------------------------
const char *__fastcall validate_voltage_range(const char *input_string, float *voltage)
{
  const char *parse_result; // r0

  parse_result = (const char *)parse_float_from_str(input_string, voltage);
  if ( !parse_result )
  {
    if ( *voltage < 100.0 )
    {
      return "Value out of range";
    }
    else if ( *voltage > 250.0 )
    {
      return "Value out of range";
    }
  }
  return parse_result;
}

//----- (0002822C) --------------------------------------------------------
const char *__fastcall validate_frequency_value(const char *input_string, float *frequency_value)
{
  const char *parse_result; // r0

  parse_result = (const char *)parse_float_from_str(input_string, frequency_value);
  if ( !parse_result )
  {
    if ( *frequency_value < 125.0 )
    {
      return "Value out of range";
    }
    else if ( *frequency_value > 500.0 )
    {
      return "Value out of range";
    }
  }
  return parse_result;
}

//----- (00028284) --------------------------------------------------------
void *initialize_pool_change_thread()
{
  void *init_result; // r0
  char log_message[2056]; // [sp+0h] [bp-808h] BYREF

  init_result = &byte_66648;
  if ( dword_66A40 )
  {
    if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
    {
      strcpy(log_message, "config too fast, pool is changing, please wait\n");
      return (void *)log_event(3, log_message, 0);
    }
  }
  else
  {
    init_result = (void *)pthread_create(
                            (pthread_t *)&dword_66A40,
                            (const pthread_attr_t *)dword_66A40,
                            (void *(*)(void *))manage_pool_changes,
                            (void *)dword_66A40);
    if ( init_result && (byte_70CE8 || byte_66640 || dword_657B8 > 2) )
    {
      strcpy(log_message, "Failed to create pool_change_thread");
      return (void *)log_event(3, log_message, 0);
    }
  }
  return init_result;
}
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 657B8: using guessed type int dword_657B8;
// 66640: using guessed type char byte_66640;
// 66A40: using guessed type int dword_66A40;
// 70CE8: using guessed type char byte_70CE8;

//----- (000283B0) --------------------------------------------------------
int __fastcall toggle_miner_thread(int thread_info, int thread_id, int (__fastcall **callback)(int))
{
  int status_flag; // r3
  char log_message[2072]; // [sp+0h] [bp-818h] BYREF

  if ( byte_70CE8 || byte_66640 || dword_657B8 > 3 )
  {
    snprintf(log_message, 2048u, "Thread %d being disabled", thread_id);
    log_event(4, log_message, 0);
  }
  status_flag = (unsigned __int8)byte_66641;
  *(_QWORD *)(*(_DWORD *)(thread_info + 36) + 48) = 0LL;
  if ( status_flag && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
  {
    strcpy(log_message, "Waiting on sem in miner thread");
    log_event(7, log_message, 0);
  }
  wait_for_semaphore((sem_t *)(thread_info + 16));
  if ( byte_70CE8 || byte_66640 || dword_657B8 > 3 )
  {
    snprintf(log_message, 2048u, "Thread %d being re-enabled", thread_id);
    log_event(4, log_message, 0);
  }
  return (*callback)(thread_info);
}
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 657B8: using guessed type int dword_657B8;
// 66640: using guessed type char byte_66640;
// 66641: using guessed type char byte_66641;
// 70CE8: using guessed type char byte_70CE8;

//----- (00028558) --------------------------------------------------------
void log_low_priority_thread_error()
{
  char error_message[2056]; // [sp+0h] [bp-808h] BYREF

  strcpy(error_message, "Unable to set thread to low priority");
  log_event(6, error_message, 0);
}

//----- (000285A8) --------------------------------------------------------
void sub_285A8()
{
  if ( !nice(10) && (byte_70CE8 || byte_66640 || dword_657B8 > 5) )
    log_low_priority_thread_error();
}
// 657B8: using guessed type int dword_657B8;
// 66640: using guessed type char byte_66640;
// 70CE8: using guessed type char byte_70CE8;

//----- (00028604) --------------------------------------------------------
int __fastcall initialize_api_thread(int api_thread_data_pointer)
{
  pthread_t current_thread_id; // r0
  int set_name_result; // r0
  int function_result; // r0

  current_thread_id = pthread_self();
  pthread_detach(current_thread_id);
  pthread_setcanceltype(1, 0);
  set_name_result = set_process_name("API");
  sub_285A8(set_name_result);
  initialize_api_socket();
  function_result = 0;
  *(_DWORD *)(api_thread_data_pointer + 12) = 0;
  return function_result;
}
// 285A8: using guessed type int __fastcall sub_285A8(_DWORD);

//----- (00028640) --------------------------------------------------------
const char *__fastcall check_value_range(int value)
{
  const char *check_result; // r0

  dword_66A44 = 2;
  check_result = (const char *)convert_string_to_int(value, &dword_71E74);
  if ( !check_result && (unsigned int)dword_71E74 > 9999 )
    return "Value out of range";
  return check_result;
}
// 3CEC8: using guessed type int __fastcall sub_3CEC8(_DWORD, _DWORD);
// 66A44: using guessed type int dword_66A44;
// 71E74: using guessed type int dword_71E74;

//----- (00028688) --------------------------------------------------------
const char *__fastcall check_value_in_range(int input_value, _DWORD *limit)
{
  const char *validation_result; // r0

  validation_result = (const char *)convert_string_to_int(input_value, limit);
  if ( !validation_result && *limit > 9999u )
    return "Value out of range";
  return validation_result;
}
// 3CEC8: using guessed type int __fastcall sub_3CEC8(_DWORD, _DWORD);

//----- (000286B8) --------------------------------------------------------
const char *__fastcall sub_286B8(const char *value, _DWORD *range_limits)
{
  const char *conversion_result; // r0

  conversion_result = (const char *)convert_string_to_int(value, range_limits);
  if ( !conversion_result && (unsigned int)(*range_limits - 1) > 65534 )
    return "Value out of range";
  return conversion_result;
}

//----- (000286EC) --------------------------------------------------------
const char *__fastcall check_value_within_range(int param_1, _DWORD *param_2)
{
  const char *validation_result; // r0

  validation_result = (const char *)convert_string_to_int(param_1, param_2);
  if ( !validation_result && (unsigned int)(*param_2 - 42) > 20 )
    return "Value out of range";
  return validation_result;
}
// 3CEC8: using guessed type int __fastcall sub_3CEC8(_DWORD, _DWORD);

//----- (0002871C) --------------------------------------------------------
const char *__fastcall check_error_and_range(int input_param, _DWORD *error_code)
{
  const char *error_message; // r0

  error_message = (const char *)convert_string_to_int(input_param, error_code);
  if ( !error_message && (unsigned int)(*error_code - 22) > 33 )
    return "Value out of range";
  return error_message;
}
// 3CEC8: using guessed type int __fastcall sub_3CEC8(_DWORD, _DWORD);

//----- (0002874C) --------------------------------------------------------
const char *__fastcall check_int_conversion(int input_string, _DWORD *output_int)
{
  const char *result_message; // r0

  result_message = (const char *)convert_string_to_int((const char *)input_string, output_int);
  if ( !result_message && (unsigned int)(*output_int - 42) > 43 )
    return "Value out of range";
  return result_message;
}

//----- (0002877C) --------------------------------------------------------
const char *__fastcall get_error_message(int input_value, _DWORD *status_code)
{
  const char *error_message; // r0

  error_message = (const char *)convert_string_to_int((const char *)input_value, status_code);
  if ( !error_message && (unsigned int)(*status_code - 22) > 53 )
    return "Value out of range";
  return error_message;
}

//----- (000287AC) --------------------------------------------------------
const char *__fastcall validate_input_value(const char *input_value_string, _DWORD *error_code)
{
  const char *validation_result; // r0

  validation_result = (const char *)convert_string_to_int(input_value_string, error_code);
  if ( !validation_result && (unsigned int)(*error_code - 32) > 31 )
    return "Value out of range";
  return validation_result;
}

//----- (000287DC) --------------------------------------------------------
const char *__fastcall sub_287DC(const char *input_string, _DWORD *range_limits)
{
  const char *conversion_result; // r0

  conversion_result = (const char *)convert_string_to_int(input_string, range_limits);
  if ( !conversion_result && *range_limits > 4u )
    return "Value out of range";
  return conversion_result;
}

//----- (00028808) --------------------------------------------------------
const char *__fastcall validate_and_convert_input(int input_value, _DWORD *status_code)
{
  const char *conversion_result; // r0

  conversion_result = (const char *)convert_string_to_int((const char *)input_value, status_code);
  if ( !conversion_result && *status_code > 200u )
    return "Value out of range";
  return conversion_result;
}

//----- (00028834) --------------------------------------------------------
const char *__fastcall validate_value_in_range(int input_value, _DWORD *value_limit_pointer)
{
  const char *validation_result; // r0

  validation_result = (const char *)convert_string_to_int(input_value, value_limit_pointer);
  if ( !validation_result && *value_limit_pointer > 7680u )
    return "Value out of range";
  return validation_result;
}
// 3CEC8: using guessed type int __fastcall sub_3CEC8(_DWORD, _DWORD);

//----- (00028860) --------------------------------------------------------
const char *__fastcall convert_and_validate_value(int input_value, _DWORD *status_code)
{
  const char *error_msg; // r0

  error_msg = (const char *)convert_string_to_int((const char *)input_value, status_code);
  if ( !error_msg && (unsigned int)(*status_code - 1) > 254 )
    return "Value out of range";
  return error_msg;
}

//----- (00028890) --------------------------------------------------------
const char *__fastcall validate_value_within_range(int value, _DWORD *range)
{
  const char *validation_result; // r0

  validation_result = (const char *)convert_string_to_int((const char *)value, range);
  if ( !validation_result && *range > 255u )
    return "Value out of range";
  return validation_result;
}

//----- (000288BC) --------------------------------------------------------
const char *__fastcall parse_int_validate_range(const char *input_string, _DWORD *parsed_value)
{
  const char *error_message; // r0

  error_message = (const char *)convert_string_to_int(input_string, parsed_value);
  if ( !error_message && *parsed_value > 100u )
    return "Value out of range";
  return error_message;
}

//----- (000288E8) --------------------------------------------------------
const char *__fastcall convert_range_checked_string_to_int(const char *input_string, _DWORD *range_pointer)
{
  const char *converted_int_or_null; // r0

  converted_int_or_null = (const char *)convert_string_to_int(input_string, range_pointer);
  if ( !converted_int_or_null && (unsigned int)(*range_pointer - 1) > 9 )
    return "Value out of range";
  return converted_int_or_null;
}

//----- (00028918) --------------------------------------------------------
const char *__fastcall validate_numeric_value(int value, _DWORD *range_limit)
{
  const char *validation_result; // r0

  validation_result = (const char *)convert_string_to_int((const char *)value, range_limit);
  if ( !validation_result && *range_limit > 10u )
    return "Value out of range";
  return validation_result;
}

//----- (00028944) --------------------------------------------------------
void __fastcall log_free_work_null_error(const char *function_name, const char *file_name, int line_number)
{
  char log_message[2056]; // [sp+8h] [bp-808h] BYREF

  snprintf(log_message, 2048u, "Free work called with NULL work from %s %s:%d", function_name, file_name, line_number);
  log_event(3, log_message, 0);
}

//----- (0002898C) --------------------------------------------------------
double __fastcall calculate_exp_and_update_value(double input_value)
{
  double numerator; // d0
  double denominator; // d1
  double adjustment_factor; // d2
  double *value_ptr; // r4
  double exp_result; // r0

  value_ptr = (double *)LODWORD(input_value);
  exp_result = exp(input_value);
  *value_ptr = (*value_ptr + numerator / denominator * (1.0 - 1.0 / (denominator / adjustment_factor)))
             / (1.0 - 1.0 / (denominator / adjustment_factor) + 1.0);
  return exp_result;
}
// 289AC: variable 'numerator' is possibly undefined
// 289AC: variable 'denominator' is possibly undefined
// 2899C: variable 'adjustment_factor' is possibly undefined

//----- (000289DC) --------------------------------------------------------
int sub_289DC()
{
  return 1;
}

//----- (000289E4) --------------------------------------------------------
int return_one()
{
  return 1;
}

//----- (000289F8) --------------------------------------------------------
const char *__fastcall validate_time_format(const char *time_string)
{
  const char *validation_result; // r0

  if ( sscanf(time_string, "%d:%d", &dword_73F94, &dword_73F90) != 2 )
    return "Invalid time set, should be HH:MM";
  if ( (unsigned int)dword_73F94 > 23 || (unsigned int)dword_73F90 > 59 )
    return "Invalid time set.";
  validation_result = 0;
  byte_73F88 = 1;
  return validation_result;
}
// 73F88: using guessed type char byte_73F88;
// 73F90: using guessed type int dword_73F90;
// 73F94: using guessed type int dword_73F94;

//----- (00028A64) --------------------------------------------------------
int __fastcall format_timestamp_to_string(char *output_buffer, size_t buffer_size, time_t *timestamp_parts)
{
  time_t milliseconds_component; // r3
  int milliseconds; // r4
  struct tm *timestamp_struct; // r0
  time_t timestamp_seconds; // [sp+1Ch] [bp-1Ch] BYREF

  milliseconds_component = timestamp_parts[1];
  timestamp_seconds = *timestamp_parts;
  milliseconds = milliseconds_component / 1000;
  timestamp_struct = localtime(&timestamp_seconds);
  return snprintf(
           output_buffer,
           buffer_size,
           "[%d-%02d-%02d %02d:%02d:%02d.%03d]",
           timestamp_struct->tm_year + 1900,
           timestamp_struct->tm_mon + 1,
           timestamp_struct->tm_mday,
           timestamp_struct->tm_hour,
           timestamp_struct->tm_min,
           timestamp_struct->tm_sec,
           milliseconds);
}

//----- (00028AFC) --------------------------------------------------------
void update_global_quota_gcd()
{
  unsigned int gcd_value; // r4
  int *current_miner_ptr; // r7
  int *end_miner_ptr; // r5
  int temp_miner; // t1
  unsigned int current_quota; // r3
  bool is_greater_or_equal; // cf
  int *start_miner_ptr; // r8
  int temp_miner_again; // t1
  int current_miner_quota; // r6
  int quota_update_result; // r1
  int next_quota_update_result; // r1
  int global_multiplier; // r8
  _DWORD *miner_data_pointer; // t1
  char log_buffer[2080]; // [sp+0h] [bp-820h] BYREF

  if ( dword_70DB8 <= 0 )
  {
    gcd_value = 1;
  }
  else
  {
    gcd_value = -1;
    current_miner_ptr = (int *)dword_70E5C;
    end_miner_ptr = (int *)dword_70E5C;
    do
    {
      temp_miner = *end_miner_ptr++;
      current_quota = *(_DWORD *)(temp_miner + 56);
      is_greater_or_equal = 1;
      if ( current_quota )
        is_greater_or_equal = current_quota >= gcd_value;
      if ( !is_greater_or_equal )
        gcd_value = current_quota;
    }
    while ( (int *)(dword_70E5C + 4 * dword_70DB8) != end_miner_ptr );
    if ( gcd_value == -1 )
    {
      gcd_value = 1;
    }
    else
    {
      start_miner_ptr = (int *)dword_70E5C;
      do
      {
        temp_miner_again = *start_miner_ptr++;
        current_miner_quota = *(_DWORD *)(temp_miner_again + 56);
        if ( current_miner_quota )
        {
          calculate_hashrate_if_valid(current_miner_quota, gcd_value);
          if ( quota_update_result )
          {
            do
              calculate_hashrate_if_valid(current_miner_quota, --gcd_value);
            while ( next_quota_update_result );
          }
        }
      }
      while ( end_miner_ptr != start_miner_ptr );
    }
    global_multiplier = dword_66118;
    do
    {
      miner_data_pointer = (_DWORD *)*current_miner_ptr++;
      miner_data_pointer[16] = calculate_miner_hashrate(miner_data_pointer[16] * global_multiplier, gcd_value);
      miner_data_pointer[15] = calculate_miner_hashrate(miner_data_pointer[14], gcd_value);
    }
    while ( end_miner_ptr != current_miner_ptr );
  }
  dword_66118 = gcd_value;
  if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
  {
    snprintf(log_buffer, 2048u, "Global quota greatest common denominator set to %lu", gcd_value);
    log_event(7, log_buffer, 0);
  }
}
// 28B7C: variable 'quota_update_result' is possibly undefined
// 28B94: variable 'next_quota_update_result' is possibly undefined
// 48AC8: using guessed type int __fastcall sub_48AC8(_DWORD, _DWORD);
// 48D24: using guessed type int __fastcall sub_48D24(_DWORD, _DWORD);
// 657B8: using guessed type int dword_657B8;
// 66118: using guessed type int dword_66118;
// 66640: using guessed type char byte_66640;
// 66641: using guessed type char byte_66641;
// 70CE8: using guessed type char byte_70CE8;
// 70DB8: using guessed type int dword_70DB8;
// 70E5C: using guessed type int dword_70E5C;

//----- (00028C80) --------------------------------------------------------
const char *__fastcall validate_range(int configOption, _DWORD *currentValue, int minValue, int maxValue)
{
  const char *errorMessage; // r0
  _BOOL4 isBelowMin; // r4
  int rangeError; // r3

  errorMessage = (const char *)convert_string_to_int(configOption, currentValue);
  if ( !errorMessage )
  {
    isBelowMin = *currentValue < minValue;
    if ( *currentValue > maxValue )
      rangeError = isBelowMin | 1;
    else
      rangeError = isBelowMin;
    if ( rangeError )
      return "Value out of range";
  }
  return errorMessage;
}
// 3CEC8: using guessed type int __fastcall sub_3CEC8(_DWORD, _DWORD);

//----- (00028CCC) --------------------------------------------------------
int __fastcall parse_range(const char *input_string, _DWORD *start_range, _DWORD *end_range)
{
  int parsed_count; // r0

  parsed_count = sscanf(input_string, "%d-%d", start_range, end_range);
  if ( parsed_count == 1 )
    *end_range = *start_range;
  return parsed_count;
}

//----- (00028CFC) --------------------------------------------------------
int __fastcall init_stratum_connection(int context, const char *url)
{
  int parse_result; // r6
  char *url_copy; // r0
  int url_port; // r3
  int final_result; // r0

  parse_result = parse_url(url, (_DWORD *)(context + 600), (char **)(context + 584));
  if ( parse_result )
  {
    if ( !strncasecmp(url, "stratum+tcp://", 14u) )
    {
      url_copy = _strdup(url);
      url_port = *(_DWORD *)(context + 600);
      *(_DWORD *)(context + 164) = url_copy;
      final_result = parse_result;
      *(_BYTE *)(context + 640) = 1;
      *(_DWORD *)(context + 576) = url_port;
      return final_result;
    }
    return 0;
  }
  return parse_result;
}

//----- (00028D6C) --------------------------------------------------------
int __fastcall setup_miner_url(int miner_config, char *input_url)
{
  const char *cleaned_url; // r5
  int unused1; // r2
  int unused2; // r3
  char *formatted_url; // r6

  cleaned_url = (const char *)update_proxy_settings(input_url);
  if ( !init_stratum_connection(miner_config, cleaned_url) )
  {
    set_value(cleaned_url, miner_config + 164, unused1, unused2);
    if ( strncmp(cleaned_url, "http://", 7u) )
    {
      if ( strncmp(cleaned_url, "https://", 8u) )
      {
        formatted_url = (char *)safe_malloc_with_logging(256, "cgminer.c", "setup_url", 1068);
        strcpy(formatted_url, "stratum+tcp://");
        strncat(formatted_url, cleaned_url, 242u);
        init_stratum_connection(miner_config, formatted_url);
      }
    }
  }
  return *(_DWORD *)(miner_config + 164);
}
// 28DA8: variable 'unused1' is possibly undefined
// 28DA8: variable 'unused2' is possibly undefined
// 1E74C: using guessed type int __fastcall sub_1E74C(_DWORD, _DWORD, _DWORD, _DWORD);
// 28CFC: using guessed type int __fastcall sub_28CFC(_DWORD, _DWORD);
// 3CDAC: using guessed type int __fastcall sub_3CDAC(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00028E4C) --------------------------------------------------------
const char *__fastcall set_temperature_cutoff(const char *temperature_value)
{
  const char *set_result; // r0

  if ( !temperature_value || !*temperature_value )
    return "Invalid parameters for set temp cutoff";
  if ( (unsigned int)strtol(temperature_value, 0, 10) > 200 )
    return "Invalid value passed to set temp cutoff";
  set_result = 0;
  dword_66A48 = (int)temperature_value;
  return set_result;
}
// 66A48: using guessed type int dword_66A48;

//----- (00028EA8) --------------------------------------------------------
void *__fastcall clear_miner_data(void **miner_data)
{
  free(miner_data[72]);
  free(miner_data[77]);
  free(miner_data[82]);
  free(miner_data[80]);
  return memset(miner_data, 0, 448u);
}

//----- (00028EE4) --------------------------------------------------------
char *__fastcall copy_work_details(unsigned int *miner_data, int work_data, int extra_nonce)
{
  unsigned int saved_time; // r7
  const char *stratum_url; // r0
  const char *pool_username; // r0
  const char *work_id; // r0
  char *extranonce2; // r0
  unsigned int bin_extra_nonce[7]; // [sp+Ch] [bp-1Ch] BYREF

  saved_time = miner_data[85];
  clear_miner_data(miner_data);
  log_memcpy_error(miner_data, (const void *)work_data, 448u, (int)"cgminer.c", (int)"_copy_work", 4984);
  miner_data[85] = saved_time;
  stratum_url = *(const char **)(work_data + 288);
  if ( stratum_url )
    miner_data[72] = (unsigned int)_strdup(stratum_url);
  pool_username = *(const char **)(work_data + 320);
  if ( pool_username )
    miner_data[80] = (unsigned int)_strdup(pool_username);
  work_id = *(const char **)(work_data + 308);
  if ( work_id )
  {
    if ( extra_nonce )
    {
      miner_data[17] = bswap32(extra_nonce + bswap32(miner_data[17]));
      hex_string_to_binary(bin_extra_nonce, *(unsigned __int8 **)(work_data + 308), 4);
      bin_extra_nonce[0] = bswap32(extra_nonce + bswap32(bin_extra_nonce[0]));
      miner_data[77] = (unsigned int)binary_to_hex_string((int)bin_extra_nonce, 4);
    }
    else
    {
      miner_data[77] = (unsigned int)_strdup(work_id);
    }
  }
  else if ( extra_nonce )
  {
    miner_data[17] = bswap32(extra_nonce + bswap32(miner_data[17]));
  }
  extranonce2 = *(char **)(work_data + 328);
  if ( extranonce2 )
  {
    extranonce2 = _strdup(extranonce2);
    miner_data[82] = (unsigned int)extranonce2;
  }
  miner_data[111] = *(_DWORD *)(work_data + 444);
  return extranonce2;
}
// 28EA8: using guessed type int __fastcall sub_28EA8(_DWORD);

//----- (00028FFC) --------------------------------------------------------
void __fastcall clear_miner_data_if_not_null(
        void ***miner_data_ptr,
        const char *file_name,
        const char *function_name,
        int line_number)
{
  void **ptr_to_clear; // r5

  ptr_to_clear = *miner_data_ptr;
  if ( *miner_data_ptr )
  {
    clear_miner_data(*miner_data_ptr);
    free(ptr_to_clear);
    *miner_data_ptr = 0;
  }
  else if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
  {
    log_free_work_null_error(file_name, function_name, line_number);
  }
}
// 657B8: using guessed type int dword_657B8;
// 66640: using guessed type char byte_66640;
// 70CE8: using guessed type char byte_70CE8;

//----- (00029090) --------------------------------------------------------
int __fastcall update_firmware(int firmware_ptr, int firmware_data, int data_size)
{
  int firmware_version; // r3
  int firmware_base_ptr; // r4
  _BYTE encryption_buffer[16]; // [sp-10h] [bp-10h] BYREF

  firmware_version = *(_DWORD *)(firmware_ptr + 368);
  if ( firmware_version )
  {
    firmware_base_ptr = firmware_ptr;
    get_hardware_timestamp(encryption_buffer, firmware_data, data_size, firmware_version);
    return sub_1F8EC(encryption_buffer, firmware_base_ptr + 368);
  }
  return firmware_ptr;
}
// 1F5C4: using guessed type int __fastcall sub_1F5C4(_DWORD, _DWORD, _DWORD, _DWORD);
// 1F8EC: using guessed type int __fastcall sub_1F8EC(_DWORD, _DWORD);
// 66120: using guessed type int dword_66120;

//----- (000290F4) --------------------------------------------------------
int __fastcall calculate_hash(int unused_param, int input1, int input2, int input3)
{
  _BYTE hash_output[16]; // [sp+0h] [bp-10h] BYREF

  get_hardware_timestamp(hash_output, input1, input2, input3);
  return sub_1F8EC(hash_output, &unk_66A4C);
}
// 1F5C4: using guessed type int __fastcall sub_1F5C4(_DWORD, _DWORD, _DWORD, _DWORD);
// 1F8EC: using guessed type int __fastcall sub_1F8EC(_DWORD, _DWORD);

//----- (0002911C) --------------------------------------------------------
void __fastcall get_timestamp_and_check(
        int hardware_id,
        int timestamp_param1,
        int timestamp_param2,
        int timestamp_param3)
{
  __time_t v4; // [sp+0h] [bp-10h] BYREF

  get_hardware_timestamp(&v4);
  sub_1F8EC();
}

//----- (00029144) --------------------------------------------------------
void __fastcall log_benchfile_event(int work_id, unsigned int nonce)
{
  int shift_count; // r2
  int reordered_nonce; // r4
  int byte_part; // r3
  char work_str[1016]; // [sp+8h] [bp-C08h] BYREF
  char log_message[2056]; // [sp+408h] [bp-808h] BYREF

  shift_count = 4;
  reordered_nonce = 0;
  do
  {
    byte_part = (unsigned __int8)nonce;
    --shift_count;
    nonce >>= 8;
    reordered_nonce = byte_part + (reordered_nonce << 8);
  }
  while ( shift_count );
  convert_bytes_to_hexstring(work_str, work_id, 128);
  if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
  {
    snprintf(log_message, 2048u, "BENCHFILE nonce %u=0x%08x for work=%s", reordered_nonce, reordered_nonce, work_str);
    log_event(3, log_message, 0);
  }
}
// 1E944: using guessed type int __fastcall sub_1E944(_DWORD, _DWORD, _DWORD);
// 657B8: using guessed type int dword_657B8;
// 66640: using guessed type char byte_66640;
// 70CE8: using guessed type char byte_70CE8;

//----- (0002920C) --------------------------------------------------------
_BYTE *__fastcall update_miner_hashrate(_BYTE *miner_data, unsigned int hashrate)
{
  void *old_hashrate_ptr; // r3
  _BYTE *data_ptr; // r4

  old_hashrate_ptr = (void *)*((_DWORD *)miner_data + 77);
  *((_DWORD *)miner_data + 17) = bswap32(hashrate);
  if ( old_hashrate_ptr )
  {
    data_ptr = miner_data;
    free(old_hashrate_ptr);
    miner_data = binary_to_hex_string((int)(data_ptr + 68), 4);
    *((_DWORD *)data_ptr + 77) = miner_data;
  }
  return miner_data;
}

//----- (00029244) --------------------------------------------------------
unsigned int __fastcall calculate_miner_efficiency(_DWORD *miner_statistics)
{
  double first_level_readings; // r0
  double first_level_hashrate; // d8
  double second_level_readings; // r0
  double second_level_hashrate; // d8
  double third_level_readings; // r0
  double third_level_hashrate; // d8
  double total_readings; // r0
  double total_hashrate; // d8

  if ( !miner_statistics )
    return 0;
  LODWORD(first_level_readings) = check_null_pointer(*((_QWORD *)miner_statistics + 27));
  first_level_hashrate = first_level_readings * 6.27710174e57;
  LODWORD(second_level_readings) = check_null_pointer(*((_QWORD *)miner_statistics + 26));
  second_level_hashrate = first_level_hashrate + second_level_readings * 3.40282367e38;
  LODWORD(third_level_readings) = check_null_pointer(*((_QWORD *)miner_statistics + 25));
  third_level_hashrate = second_level_hashrate + third_level_readings * 1.84467441e19;
  LODWORD(total_readings) = check_null_pointer(*((_QWORD *)miner_statistics + 24));
  total_hashrate = total_readings + third_level_hashrate;
  if ( total_hashrate == 0.0 )
    return 0;
  else
    return calculate_hash_value(2.69595353e67 / total_hashrate);
}
// 29268: variable 'first_level_readings' is possibly undefined
// 2927C: variable 'second_level_readings' is possibly undefined
// 29290: variable 'third_level_readings' is possibly undefined
// 2929C: variable 'total_readings' is possibly undefined

//----- (000292F8) --------------------------------------------------------
void __fastcall process_work_discard(_DWORD *work_info, const char *a2, const char *a3, int a4)
{
  int v5; // r1
  int v9; // r3
  char s[2072]; // [sp+8h] [bp-818h] BYREF

  v5 = *work_info;
  if ( *work_info )
  {
    if ( *(_BYTE *)(v5 + 273) || *(_DWORD *)(v5 + 240) || *(_BYTE *)(v5 + 272) )
    {
      if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
      {
        strcpy(s, "Discarded cloned or rolled work");
        log_event(7, s, 0);
      }
    }
    else
    {
      v9 = *(_DWORD *)(v5 + 260);
      if ( v9 )
      {
        ++*(_DWORD *)(v9 + 124);
        --*(_DWORD *)(*(_DWORD *)(v5 + 260) + 64);
        --*(_DWORD *)(*(_DWORD *)(v5 + 260) + 68);
      }
      ++qword_72F60;
      if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
      {
        strcpy(s, "Discarded work");
        log_event(7, s, 0);
      }
    }
    clear_miner_data_if_not_null((void ***)work_info, a2, a3, a4);
  }
  else if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
  {
    snprintf(s, 2048u, "Discard work called with NULL work from %s %s:%d", a2, a3, a4);
    log_event(3, s, 0);
  }
}
// 657B8: using guessed type int dword_657B8;
// 66640: using guessed type char byte_66640;
// 66641: using guessed type char byte_66641;
// 70CE8: using guessed type char byte_70CE8;
// 72F60: using guessed type __int64 qword_72F60;

//----- (00029530) --------------------------------------------------------
int *__fastcall update_job_queue(int *job_queue_handle)
{
  int total_jobs; // r7
  int new_total_jobs; // r5
  int *current_job_ptr; // r2
  int end_ptr; // lr
  int job_id; // r1
  int temp_job_id; // t1
  int job_priority; // r3
  bool priority_check; // cc
  int new_priority; // r3
  int current_job_index; // r6
  int next_job_index; // r1
  int current_job_offset; // r2
  int previous_job_offset; // r3
  int next_job_id; // r7
  int updated_total_jobs; // r3

  total_jobs = dword_70DB8;
  new_total_jobs = dword_70DB8 - 1;
  if ( dword_70DB8 > 0 )
  {
    current_job_ptr = (int *)dword_70E5C;
    end_ptr = dword_70E5C + 4 * dword_70DB8;
    do
    {
      temp_job_id = *current_job_ptr++;
      job_id = temp_job_id;
      job_priority = *(_DWORD *)(temp_job_id + 4);
      priority_check = job_priority <= job_queue_handle[1];
      new_priority = job_priority - 1;
      if ( !priority_check )
        *(_DWORD *)(job_id + 4) = new_priority;
    }
    while ( (int *)end_ptr != current_job_ptr );
  }
  current_job_index = *job_queue_handle;
  if ( *job_queue_handle < new_total_jobs )
  {
    next_job_index = current_job_index + 1;
    current_job_offset = 4 * (current_job_index + 1);
    while ( 1 )
    {
      previous_job_offset = current_job_offset - 4;
      next_job_id = *(_DWORD *)(dword_70E5C + current_job_offset);
      current_job_offset += 4;
      *(_DWORD *)(dword_70E5C + previous_job_offset) = next_job_id;
      **(_DWORD **)(dword_70E5C + previous_job_offset) = current_job_index;
      current_job_index = next_job_index;
      if ( next_job_index == new_total_jobs )
        break;
      ++next_job_index;
    }
    total_jobs = dword_70DB8;
  }
  *job_queue_handle = total_jobs;
  updated_total_jobs = dword_70DB8;
  *((_BYTE *)job_queue_handle + 105) = 1;
  dword_70DB8 = updated_total_jobs - 1;
  return job_queue_handle;
}
// 70DB8: using guessed type int dword_70DB8;
// 70E5C: using guessed type int dword_70E5C;

//----- (000295EC) --------------------------------------------------------
void __fastcall write_config_to_file(FILE *file)
{
  int pool_index; // r6
  const char *pool_comma; // r11
  int user_start; // r0
  int password_start; // r0
  int password_start_transformed; // r0
  char *delimiter; // r2
  int quota_flag; // r3
  const char *password_transformed; // r10
  const char *url_string; // r0
  int user_transformed; // r0
  const char *password_final; // r0
  _DWORD *pool_data_raw; // r0
  _DWORD *pool_data; // r4
  const char *comma_or_empty; // r10
  int user_index_transformed; // r0
  int password_index; // r0
  const char *password_final_part; // r11
  char *delimiter_or_empty; // r3
  int password_transformed_start; // r0
  const char *url_transformed; // r0
  char **config_lines; // r4
  char *strdup_line; // r8
  char *first_token; // r11
  int (*value_handler)(); // r2
  bool is_single_value_handler; // zf
  int is_value_handler_executed; // r3
  int feature_flag; // r1
  int (*boolean_handler)(); // r2
  bool is_boolean_handler; // zf
  _DWORD *feature_value; // r3
  const char *feature_string; // r0
  int mode_flag; // r1
  int free_ptr; // r4
  int next_free_ptr; // r5
  bool is_float_handler; // zf
  int quota_int; // [sp+14h] [bp-34h]
  const char *delimiter_or_empty_b; // [sp+14h] [bp-34h]
  const char *delimiter_or_empty_a; // [sp+18h] [bp-30h]
  const char *user_transformed_b; // [sp+18h] [bp-30h]
  const char *user_transformed_a; // [sp+1Ch] [bp-2Ch]

  fwrite("{\n\"pools\" : [", 1u, 13u, file);
  if ( dword_70DB8 > 0 )
  {
    pool_index = 0;
    do
    {
      pool_data_raw = (_DWORD *)get_connection_handle_by_id(pool_index);
      quota_flag = pool_data_raw[14];
      pool_data = pool_data_raw;
      if ( quota_flag == 1 )
      {
        if ( pool_index )
          comma_or_empty = (const char *)&word_4FD70;
        else
          comma_or_empty = "";
        if ( pool_data_raw[46] )
        {
          user_index_transformed = get_protocol_type(pool_data_raw[45]);
          user_transformed_b = (const char *)escape_json_string(user_index_transformed);
          password_index = pool_data[46];
          if ( password_index )
          {
            password_transformed_start = escape_json_string(password_index);
            delimiter_or_empty = "|";
            password_final_part = (const char *)password_transformed_start;
            if ( !pool_data[46] )
              delimiter_or_empty = "";
          }
          else
          {
            password_final_part = "";
            delimiter_or_empty = "";
          }
        }
        else
        {
          password_final_part = "";
          user_transformed_b = "";
          delimiter_or_empty = "";
        }
        delimiter_or_empty_b = delimiter_or_empty;
        url_transformed = (const char *)escape_json_string(pool_data[41]);
        fprintf(
          file,
          "%s\n\t{\n\t\t\"url\" : \"%s%s%s%s\",",
          comma_or_empty,
          user_transformed_b,
          password_final_part,
          delimiter_or_empty_b,
          url_transformed);
        if ( !*((_BYTE *)pool_data + 580) )
          goto LABEL_11;
      }
      else
      {
        if ( pool_index )
          pool_comma = (const char *)&word_4FD70;
        else
          pool_comma = "";
        if ( pool_data_raw[46] )
        {
          user_start = get_protocol_type(pool_data_raw[45]);
          user_transformed_a = (const char *)escape_json_string(user_start);
          password_start = pool_data[46];
          if ( password_start )
          {
            password_start_transformed = escape_json_string(password_start);
            delimiter = "|";
            quota_flag = pool_data[14];
            password_transformed = (const char *)password_start_transformed;
            if ( !pool_data[46] )
              delimiter = "";
          }
          else
          {
            quota_flag = pool_data[14];
            password_transformed = "";
            delimiter = "";
          }
        }
        else
        {
          password_transformed = "";
          user_transformed_a = "";
          delimiter = "";
        }
        delimiter_or_empty_a = delimiter;
        quota_int = quota_flag;
        url_string = (const char *)escape_json_string(pool_data[41]);
        fprintf(
          file,
          "%s\n\t{\n\t\t\"quota\" : \"%s%s%s%d;%s\",",
          pool_comma,
          user_transformed_a,
          password_transformed,
          delimiter_or_empty_a,
          quota_int,
          url_string);
        if ( !*((_BYTE *)pool_data + 580) )
          goto LABEL_11;
      }
      fwrite("\n\t\t\"extranonce-subscribe\" : true,", 1u, 33u, file);
LABEL_11:
      ++pool_index;
      user_transformed = escape_json_string(pool_data[43]);
      fprintf(file, aUserS, user_transformed);
      password_final = (const char *)escape_json_string(pool_data[44]);
      fprintf(file, "\n\t\t\"pass\" : \"%s\"\n\t}", password_final);
    }
    while ( dword_70DB8 > pool_index );
  }
  fwrite("\n]\n", 1u, 3u, file);
  if ( dword_659E4 != 16 )
  {
    config_lines = &off_659FC;
    while ( 1 )
    {
      strdup_line = _strdup(*(config_lines - 7));
      first_token = strtok(strdup_line, "|");
      if ( first_token )
        break;
LABEL_77:
      config_lines += 7;
      free(strdup_line);
      if ( *(config_lines - 6) == (char *)16 )
        goto LABEL_78;
    }
    while ( 1 )
    {
      if ( first_token[1] == 45 && *(config_lines - 1) != (char *)&unk_74254 )
      {
        feature_flag = (int)*(config_lines - 6);
        if ( (feature_flag & 1) == 0 )
          goto LABEL_72;
        boolean_handler = (int (*)())*(config_lines - 5);
        is_boolean_handler = boolean_handler == set_flag;
        if ( boolean_handler != set_flag )
          is_boolean_handler = boolean_handler == reset_byte;
        if ( is_boolean_handler && **(config_lines - 2) == (boolean_handler == set_flag) )
        {
          fprintf(file, ",\n\"%s\" : true", first_token + 2);
        }
        else
        {
LABEL_72:
          if ( (feature_flag & 2) == 0 )
            goto LABEL_73;
          value_handler = (int (*)())*(config_lines - 4);
          is_single_value_handler = value_handler == check_value_in_range;
          if ( value_handler != check_value_in_range )
            is_single_value_handler = value_handler == convert_string_to_int;
          is_value_handler_executed = is_single_value_handler;
          if ( value_handler == sub_286B8 )
            is_value_handler_executed |= 1u;
          if ( value_handler == validate_numeric_value )
            is_value_handler_executed |= 1u;
          if ( value_handler == convert_range_checked_string_to_int )
            is_value_handler_executed |= 1u;
          if ( value_handler == parse_int_validate_range )
            is_value_handler_executed |= 1u;
          if ( value_handler == validate_value_within_range )
            is_value_handler_executed |= 1u;
          if ( value_handler == convert_and_validate_value )
            is_value_handler_executed |= 1u;
          if ( value_handler == validate_value_in_range )
            is_value_handler_executed |= 1u;
          if ( value_handler == validate_and_convert_input )
            is_value_handler_executed |= 1u;
          if ( value_handler == sub_287DC )
            is_value_handler_executed |= 1u;
          if ( value_handler == validate_input_value )
            is_value_handler_executed |= 1u;
          if ( value_handler == get_error_message )
            is_value_handler_executed |= 1u;
          if ( value_handler == check_int_conversion )
            is_value_handler_executed |= 1u;
          if ( value_handler == check_error_and_range )
            is_value_handler_executed |= 1u;
          if ( value_handler == check_value_within_range )
            is_value_handler_executed |= 1u;
          if ( is_value_handler_executed )
          {
            fprintf(file, ",\n\"%s\" : \"%d\"", first_token + 2, *(_DWORD *)*(config_lines - 2));
          }
          else
          {
            is_float_handler = value_handler == validate_frequency_value;
            if ( value_handler != validate_frequency_value )
              is_float_handler = value_handler == validate_voltage_range;
            if ( !is_float_handler )
            {
LABEL_73:
              if ( (feature_flag & 6) != 0 )
              {
                feature_value = *(config_lines - 2);
                if ( feature_value != (_DWORD *)&unk_66A5C )
                {
                  if ( *feature_value )
                  {
                    feature_string = (const char *)escape_json_string(*feature_value);
                    fprintf(file, ",\n\"%s\" : \"%s\"", first_token + 2, feature_string);
                  }
                }
              }
              goto LABEL_63;
            }
            fprintf(file, ",\n\"%s\" : \"%.1f\"", first_token + 2, *(float *)*(config_lines - 2));
          }
        }
      }
LABEL_63:
      first_token = strtok(0, "|");
      if ( !first_token )
        goto LABEL_77;
    }
  }
LABEL_78:
  mode_flag = dword_66A44;
  if ( dword_66A44 == 4 )
  {
    fwrite(",\n\"balance\" : true", 1u, 18u, file);
    mode_flag = dword_66A44;
  }
  if ( mode_flag == 3 )
  {
    fwrite(",\n\"load-balance\" : true", 1u, 23u, file);
    mode_flag = dword_66A44;
  }
  if ( mode_flag == 1 )
  {
    fwrite(",\n\"round-robin\" : true", 1u, 22u, file);
    mode_flag = dword_66A44;
  }
  if ( mode_flag == 2 )
    fprintf(file, ",\n\"rotate\" : \"%d\"", dword_71E74);
  fwrite("\n}\n", 1u, 3u, file);
  free_ptr = dword_66860;
  dword_66860 = 0;
  if ( free_ptr )
  {
    do
    {
      next_free_ptr = *(_DWORD *)(free_ptr + 4);
      free(*(void **)free_ptr);
      free((void *)free_ptr);
      free_ptr = next_free_ptr;
    }
    while ( next_free_ptr );
  }
}
// 1E8F8: using guessed type int __fastcall sub_1E8F8(_DWORD);
// 27064: using guessed type int __fastcall sub_27064(_DWORD);
// 27AF0: using guessed type int __fastcall sub_27AF0(_DWORD);
// 281D4: using guessed type int sub_281D4();
// 2822C: using guessed type int sub_2822C();
// 28688: using guessed type int sub_28688();
// 286B8: using guessed type int sub_286B8();
// 286EC: using guessed type int sub_286EC();
// 2871C: using guessed type int sub_2871C();
// 2874C: using guessed type int sub_2874C();
// 2877C: using guessed type int sub_2877C();
// 287AC: using guessed type int sub_287AC();
// 287DC: using guessed type int sub_287DC();
// 28808: using guessed type int sub_28808();
// 28834: using guessed type int sub_28834();
// 28860: using guessed type int sub_28860();
// 28890: using guessed type int sub_28890();
// 288BC: using guessed type int sub_288BC();
// 288E8: using guessed type int sub_288E8();
// 28918: using guessed type int sub_28918();
// 3CCC8: using guessed type int sub_3CCC8();
// 3CCE8: using guessed type int sub_3CCE8();
// 3CEC8: using guessed type int sub_3CEC8();
// 4FD70: using guessed type __int16 word_4FD70;
// 659E4: using guessed type int dword_659E4;
// 659FC: using guessed type char *off_659FC;
// 66860: using guessed type int dword_66860;
// 66A44: using guessed type int dword_66A44;
// 70DB8: using guessed type int dword_70DB8;
// 71E74: using guessed type int dword_71E74;

//----- (00029BD4) --------------------------------------------------------
int reset_global_statistics()
{
  int result; // r0
  int *current_element; // r2
  int end_address; // r12
  int module_address; // t1

  *(_DWORD *)dword_66128 = 0;
  dword_6612C = 0;
  qword_66A60 = 0LL;
  result = format_hashrate(0LL, dword_66128, 8u, 0);
  if ( dword_70DB8 > 0 )
  {
    result = 0;
    current_element = (int *)dword_70E5C;
    end_address = dword_70E5C + 4 * dword_70DB8;
    do
    {
      module_address = *current_element++;
      *(_DWORD *)(module_address + 368) = 0;
      *(_DWORD *)(module_address + 372) = 0;
    }
    while ( current_element != (int *)end_address );
  }
  return result;
}
// 6612C: using guessed type int dword_6612C;
// 66A60: using guessed type __int64 qword_66A60;
// 70DB8: using guessed type int dword_70DB8;
// 70E5C: using guessed type int dword_70E5C;

//----- (00029C6C) --------------------------------------------------------
char *__fastcall get_bmminer_config_path(char *config_path)
{
  size_t path_length; // r0
  char *end_of_path; // r12
  size_t path_length_dup; // lr
  char *final_result; // r0
  char *home_env; // r0

  if ( dword_72F54 && *(_BYTE *)dword_72F54 )
    return strcpy(config_path, (const char *)dword_72F54);
  if ( getenv("HOME") && *getenv("HOME") )
  {
    home_env = getenv("HOME");
    strcpy((char *)stpcpy(config_path, home_env), "/");
  }
  else
  {
    *config_path = 0;
  }
  strcat(config_path, ".bmminer/");
  mkdir(config_path, 511u);
  path_length = strlen(config_path);
  end_of_path = &config_path[path_length];
  path_length_dup = path_length;
  final_result = *(char **)"bmminer.conf";
  *(_DWORD *)&config_path[path_length_dup] = *(_DWORD *)"bmminer.conf";
  strcpy(end_of_path + 4, "ner.conf");
  return final_result;
}
// 1209C: using guessed type int __fastcall stpcpy(_DWORD, _DWORD);
// 72F54: using guessed type int dword_72F54;

//----- (00029D68) --------------------------------------------------------
void sub_29D68()
{
  dword_66968 = (int)safe_malloc_with_logging(4096u, "cgminer.c", "load_default_config", 2181);
  dword_6696C = 0;
  get_bmminer_config_path((char *)dword_66968);
  if ( access((const char *)dword_66968, 4) )
  {
    free((void *)dword_66968);
    dword_66968 = 0;
  }
  else
  {
    check_and_parse_json_file((const char *)dword_66968);
  }
}
// 66968: using guessed type int dword_66968;
// 6696C: using guessed type int dword_6696C;

//----- (00029DCC) --------------------------------------------------------
int __fastcall calculate_target_hash(int difficulty)
{
  double difficulty_double; // d0
  __int64 target_hash_high; // r6
  double remainder_high; // d8
  int calc_value_1_high; // r10
  int calc_value_1_low; // r11
  __int64 calc_value_1_raw; // kr00_8
  double remainder_mid; // d8
  int calc_value_2_high; // r8
  int calc_value_2_low; // r9
  __int64 calc_value_2_raw; // kr08_8
  double remainder_low; // r0
  __int64 target_hash_low; // r0
  char *target_string; // r6
  __int64 target_hash; // [sp+8h] [bp-850h] BYREF
  int calc_value_2_low_copy; // [sp+10h] [bp-848h]
  int calc_value_2_high_copy; // [sp+14h] [bp-844h]
  int calc_value_1_low_copy; // [sp+18h] [bp-840h]
  int calc_value_1_high_copy; // [sp+1Ch] [bp-83Ch]
  __int64 target_hash_high_copy; // [sp+20h] [bp-838h]
  char log_buffer[2096]; // [sp+28h] [bp-830h] BYREF

  if ( difficulty_double == 0.0 )
  {
    if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
    {
      target_hash_high = 4294901760LL;
      strcpy(log_buffer, "Diff zero passed to set_target");
      log_event(3, log_buffer, 0);
      target_hash_low = 0LL;
      calc_value_2_low = 0;
      calc_value_1_low = 0;
      calc_value_2_high = 0;
      calc_value_1_high = 0;
    }
    else
    {
      target_hash_low = 0LL;
      target_hash_high = 4294901760LL;
      calc_value_2_low = 0;
      calc_value_1_low = 0;
      calc_value_2_high = 0;
      calc_value_1_high = 0;
    }
  }
  else
  {
    target_hash_high = calculate_hash_value(
                         COERCE_UNSIGNED_INT64(2.69595353e67 / difficulty_double * 1.59309191e-58),
                         HIDWORD(COERCE_UNSIGNED_INT64(2.69595353e67 / difficulty_double * 1.59309191e-58)));
    remainder_high = 2.69595353e67 / difficulty_double
                   - check_null_pointer(target_hash_high, HIDWORD(target_hash_high)) * 6.27710174e57;
    calc_value_1_raw = calculate_hash_value(
                         COERCE_UNSIGNED_INT64(remainder_high * 2.93873588e-39),
                         HIDWORD(COERCE_UNSIGNED_INT64(remainder_high * 2.93873588e-39)));
    calc_value_1_high = HIDWORD(calc_value_1_raw);
    calc_value_1_low = calc_value_1_raw;
    remainder_mid = remainder_high - check_null_pointer(calc_value_1_raw, HIDWORD(calc_value_1_raw)) * 3.40282367e38;
    calc_value_2_raw = calculate_hash_value(
                         COERCE_UNSIGNED_INT64(remainder_mid * 5.42101086e-20),
                         HIDWORD(COERCE_UNSIGNED_INT64(remainder_mid * 5.42101086e-20)));
    calc_value_2_high = HIDWORD(calc_value_2_raw);
    calc_value_2_low = calc_value_2_raw;
    remainder_low = check_null_pointer(calc_value_2_raw, HIDWORD(calc_value_2_raw));
    target_hash_low = calculate_hash_value(
                        COERCE_UNSIGNED_INT64(remainder_mid - remainder_low * 1.84467441e19),
                        HIDWORD(COERCE_UNSIGNED_INT64(remainder_mid - remainder_low * 1.84467441e19)));
  }
  target_hash_high_copy = target_hash_high;
  calc_value_1_low_copy = calc_value_1_low;
  calc_value_1_high_copy = calc_value_1_high;
  calc_value_2_low_copy = calc_value_2_low;
  calc_value_2_high_copy = calc_value_2_high;
  target_hash = target_hash_low;
  if ( byte_66641 )
  {
    target_string = (char *)binary_to_hex_string(&target_hash, 32);
    if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
    {
      snprintf(log_buffer, 2048u, "Generated target %s", target_string);
      log_event(7, log_buffer, 0);
    }
    free(target_string);
  }
  return log_memcpy_error(difficulty, &target_hash, 32, "cgminer.c", "set_target", 8365);
}
// 29DE8: variable 'difficulty_double' is possibly undefined
// 1E9B4: using guessed type int __fastcall sub_1E9B4(_DWORD, _DWORD);
// 2220C: using guessed type int __fastcall sub_2220C(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 492FC: using guessed type double __fastcall sub_492FC(_DWORD, _DWORD);
// 493C8: using guessed type __int64 __fastcall sub_493C8(_DWORD, _DWORD);
// 657B8: using guessed type int dword_657B8;
// 66640: using guessed type char byte_66640;
// 66641: using guessed type char byte_66641;
// 70CE8: using guessed type char byte_70CE8;

//----- (0002A064) --------------------------------------------------------
int __fastcall calculate_remaining_space(int memory_address)
{
  return dword_73FD8 - *(_DWORD *)(memory_address + 232);
}
// 73FD8: using guessed type int dword_73FD8;

//----- (0002A07C) --------------------------------------------------------
bool __fastcall update_and_check_block_status(int block_data_pointer, int new_value)
{
  *(_DWORD *)(block_data_pointer + 76) = new_value;
  process_sha256_block(block_data_pointer);
  return *(_DWORD *)(block_data_pointer + 220) == 0;
}

//----- (0002A09C) --------------------------------------------------------
bool __fastcall update_and_process_block(int block_data_ptr, int input_value)
{
  double hash_rate; // d0

  *(_DWORD *)(block_data_ptr + 76) = input_value;
  process_sha256_block(block_data_ptr);
  return *(_QWORD *)(block_data_ptr + 216) <= (unsigned __int64)calculate_hash_value(
                                                                  COERCE_UNSIGNED_INT64(4294901760.0 / hash_rate),
                                                                  HIDWORD(COERCE_UNSIGNED_INT64(4294901760.0 / hash_rate)));
}
// 2A0BC: variable 'hash_rate' is possibly undefined
// 493C8: using guessed type __int64 __fastcall sub_493C8(_DWORD, _DWORD);

//----- (0002A0E8) --------------------------------------------------------
int __fastcall check_and_log_duplicate_share(int miner_context, int share_id)
{
  _DWORD *miner_data; // r3
  int return_value; // r0
  char log_message[2056]; // [sp+8h] [bp-808h] BYREF

  miner_data = *(_DWORD **)(miner_context + 36);
  if ( miner_data[59] == share_id )
  {
    if ( byte_70CE8 || (return_value = (unsigned __int8)byte_66640, byte_66640) || dword_657B8 > 5 )
    {
      snprintf(
        log_message,
        2048u,
        "%s %d duplicate share detected as HW error",
        *(const char **)(miner_data[1] + 8),
        miner_data[2]);
      log_event(6, log_message, 0);
      return 0;
    }
  }
  else
  {
    return_value = 1;
    miner_data[59] = share_id;
  }
  return return_value;
}
// 657B8: using guessed type int dword_657B8;
// 66640: using guessed type char byte_66640;
// 70CE8: using guessed type char byte_70CE8;

//----- (0002A18C) --------------------------------------------------------
void __fastcall write_hash_information(int *input_values, int additional_input)
{
  char *block_pointer; // r6
  int *value_pointer; // r12
  int current_value; // r0
  int prev_value; // r1
  _DWORD *working_block; // lr
  int next_value; // r2
  int value_after_next; // r3
  int value_33; // r1
  int value_34; // r2
  int value_35; // r3
  int value_37; // r1
  int value_38; // r2
  int value_39; // r3
  int next_value_1; // r1
  int next_value_2; // r2
  int value_49; // r1
  int value_51; // r3
  int value_50; // r2
  int value_53; // r1
  int value_54; // r2
  int value_55; // r3
  void *ptr_block_64; // r11
  char *midstate_str; // r8
  char *data_str; // r7
  char *nonce_str; // r6
  void *version_ptr; // r10
  void *block_32_ptr; // r9
  char *version_str; // r5
  size_t message_length; // r0
  void *block_128_ptr; // [sp+Ch] [bp-4CCh]
  int block_32_values[8]; // [sp+10h] [bp-4C8h] BYREF
  _DWORD block_12_values[8]; // [sp+30h] [bp-4A8h] BYREF
  int final_block_values[8]; // [sp+50h] [bp-488h] BYREF
  char initial_block[64]; // [sp+70h] [bp-468h] BYREF
  char log_buffer[1064]; // [sp+B0h] [bp-428h] BYREF

  if ( !dword_66A68 )
    dword_66A68 = fopen64("/nvdata/worklog.txt", "wb");
  block_pointer = initial_block;
  memset(log_buffer, 0, 1024u);
  value_pointer = input_values;
  memset(&block_12_values[3], 0, 20);
  do
  {
    current_value = *value_pointer;
    value_pointer += 4;
    prev_value = *(value_pointer - 3);
    working_block = block_pointer;
    next_value = *(value_pointer - 2);
    block_pointer += 16;
    value_after_next = *(value_pointer - 1);
    *working_block = current_value;
    working_block[1] = prev_value;
    working_block[2] = next_value;
    working_block[3] = value_after_next;
  }
  while ( value_pointer != input_values + 16 );
  value_33 = input_values[33];
  value_34 = input_values[34];
  value_35 = input_values[35];
  block_32_values[0] = input_values[32];
  block_32_values[1] = value_33;
  block_32_values[2] = value_34;
  block_32_values[3] = value_35;
  value_37 = input_values[37];
  value_38 = input_values[38];
  value_39 = input_values[39];
  block_32_values[4] = input_values[36];
  block_32_values[5] = value_37;
  block_32_values[6] = value_38;
  block_32_values[7] = value_39;
  next_value_1 = value_pointer[1];
  next_value_2 = value_pointer[2];
  block_12_values[0] = *value_pointer;
  block_12_values[1] = next_value_1;
  block_12_values[2] = next_value_2;
  value_49 = input_values[49];
  value_51 = input_values[51];
  value_50 = input_values[50];
  final_block_values[0] = input_values[48];
  final_block_values[1] = value_49;
  final_block_values[2] = value_50;
  final_block_values[3] = value_51;
  value_53 = input_values[53];
  value_54 = input_values[54];
  value_55 = input_values[55];
  final_block_values[4] = input_values[52];
  final_block_values[5] = value_53;
  final_block_values[6] = value_54;
  final_block_values[7] = value_55;
  reverse_bytes(initial_block, 64);
  reverse_bytes(block_32_values, 32);
  reverse_bytes(block_12_values, 12);
  reverse_bytes(final_block_values, 32);
  block_128_ptr = (void *)binary_to_hex_string(input_values, 128);
  ptr_block_64 = (void *)binary_to_hex_string(initial_block, 64);
  midstate_str = (char *)binary_to_hex_string(block_32_values, 32);
  data_str = (char *)binary_to_hex_string(block_12_values, 12);
  nonce_str = (char *)binary_to_hex_string(additional_input, 4);
  version_ptr = (void *)binary_to_hex_string(additional_input, 5);
  block_32_ptr = (void *)binary_to_hex_string(final_block_values, 32);
  version_str = (char *)binary_to_hex_string(input_values + 111, 4);
  sprintf(log_buffer, "midstate %s data %s nonce %s version %s \r\n", midstate_str, data_str, nonce_str, version_str);
  message_length = strlen(log_buffer);
  fwrite(log_buffer, message_length, 1u, (FILE *)dword_66A68);
  fflush((FILE *)dword_66A68);
  if ( block_128_ptr )
    free(block_128_ptr);
  if ( ptr_block_64 )
    free(ptr_block_64);
  if ( midstate_str )
    free(midstate_str);
  if ( data_str )
    free(data_str);
  if ( nonce_str )
    free(nonce_str);
  if ( version_ptr )
    free(version_ptr);
  if ( block_32_ptr )
    free(block_32_ptr);
  if ( version_str )
    free(version_str);
}
// 1224C: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 1E9B4: using guessed type int __fastcall sub_1E9B4(_DWORD, _DWORD);
// 261E0: using guessed type int __fastcall sub_261E0(_DWORD, _DWORD);
// 66A68: using guessed type int dword_66A68;
// 2A18C: using guessed type _DWORD var_4C8[8];
// 2A18C: using guessed type _DWORD var_488[8];

//----- (0002A440) --------------------------------------------------------
void __fastcall write_miner_hash(int *miner_data_ptr, unsigned int hash_data)
{
  unsigned int reversed_hash_data; // [sp+0h] [bp-10h] BYREF
  char unused_char; // [sp+4h] [bp-Ch]

  reversed_hash_data = bswap32(hash_data);
  unused_char = 0;
  write_hash_information(miner_data_ptr, (int)&reversed_hash_data);
}

//----- (0002A468) --------------------------------------------------------
int __fastcall update_and_process_hash(int *hash_data, unsigned int block_nonce)
{
  unsigned int reversed_nonce; // [sp+0h] [bp-18h] BYREF
  char unused_byte; // [sp+4h] [bp-14h]

  hash_data[19] = block_nonce;
  process_sha256_block((int)hash_data);
  if ( hash_data[55] )
    return 0;
  reversed_nonce = bswap32(block_nonce);
  unused_byte = 0;
  write_hash_information(hash_data, (int)&reversed_nonce);
  return 1;
}

//----- (0002A4B4) --------------------------------------------------------
void __fastcall update_statistics(int statistics_pointer, int data_pointer)
{
  int byte_1; // r5
  int byte_2; // r12
  int hash_init; // r1
  unsigned int hash_value_1; // r3
  unsigned int hash_value_2; // r2
  int hash_value_3; // r1
  unsigned int hash_value_4; // r3
  unsigned int hash_value_5; // r2
  int hash_value_6; // r1
  unsigned int final_hash; // r5
  int prev_node; // r6
  int prev_node_data; // r3
  int current_data_addr; // r1
  __int64 node_meta; // r2
  int hash_table_index; // r5
  int next_node_addr; // r2
  int *hash_table_entry; // r3
  __int64 entries_counts; // r2
  int current_node_data; // r4
  _DWORD *new_table; // r6
  int entry_index; // r7
  int current_node_addr; // r3
  unsigned int entries_count; // r4
  _DWORD *current_entry; // r5
  _DWORD *next_entry; // r11
  int new_table_index; // r4
  char *new_table_entry; // r8
  unsigned int new_entry_count; // r1
  int next_node_in_new_table; // r3
  _DWORD *current_node_data_ptr; // r3
  unsigned int entries_threshold; // r2
  unsigned int current_capacity; // r1
  bool should_resize; // cc
  int resize_value; // r2
  int current_data; // r3
  void *initial_block; // r0
  void **base_node; // r7
  void *hash_table_block; // r0
  unsigned int loop_index; // [sp+4h] [bp-2Ch]

  ++*(_DWORD *)(statistics_pointer + 360);
  byte_1 = *(unsigned __int8 *)(data_pointer + 340);
  byte_2 = *(unsigned __int8 *)(data_pointer + 343);
  *(_DWORD *)(data_pointer + 364) = data_pointer + 340;
  *(_DWORD *)(data_pointer + 368) = 4;
  hash_init = (byte_1
             + 17973517
             + (byte_2 << 24)
             + (*(unsigned __int8 *)(data_pointer + 342) << 16)
             + (*(unsigned __int8 *)(data_pointer + 341) << 8)) ^ 0x7F76D;
  hash_value_1 = (-1622558010 - hash_init) ^ (hash_init << 8);
  hash_value_2 = (-17973517 - hash_init - hash_value_1) ^ (hash_value_1 >> 13);
  hash_value_3 = (hash_init - hash_value_1 - hash_value_2) ^ (hash_value_2 >> 12);
  hash_value_4 = (hash_value_1 - hash_value_2 - hash_value_3) ^ (hash_value_3 << 16);
  hash_value_5 = (hash_value_2 - hash_value_3 - hash_value_4) ^ (hash_value_4 >> 5);
  hash_value_6 = (hash_value_3 - hash_value_4 - hash_value_5) ^ (hash_value_5 >> 3);
  final_hash = (hash_value_5 - hash_value_6 - ((hash_value_4 - hash_value_5 - hash_value_6) ^ (hash_value_6 << 10))) ^ (((hash_value_4 - hash_value_5 - hash_value_6) ^ (hash_value_6 << 10)) >> 15);
  *(_DWORD *)(data_pointer + 372) = final_hash;
  prev_node = *(_DWORD *)(statistics_pointer + 352);
  if ( prev_node )
  {
    prev_node_data = *(_DWORD *)(prev_node + 344);
    *(_DWORD *)(data_pointer + 352) = 0;
    current_data_addr = data_pointer + 344;
    *(_DWORD *)(data_pointer + 344) = prev_node_data;
    *(_DWORD *)(data_pointer + 348) = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(statistics_pointer + 352) + 344) + 16)
                                    - *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(statistics_pointer + 352) + 344) + 20);
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(statistics_pointer + 352) + 344) + 16) + 8) = data_pointer;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(statistics_pointer + 352) + 344) + 16) = data_pointer + 344;
  }
  else
  {
    *(_DWORD *)(data_pointer + 352) = 0;
    *(_DWORD *)(data_pointer + 348) = 0;
    *(_DWORD *)(statistics_pointer + 352) = data_pointer;
    *(_DWORD *)(data_pointer + 344) = malloc(44u);
    initial_block = *(void **)(*(_DWORD *)(statistics_pointer + 352) + 344);
    if ( !initial_block )
      goto LABEL_31;
    memset(initial_block, 0, 44u);
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(statistics_pointer + 352) + 344) + 16) = *(_DWORD *)(statistics_pointer + 352)
                                                                               + 344;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(statistics_pointer + 352) + 344) + 4) = 32;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(statistics_pointer + 352) + 344) + 8) = 5;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(statistics_pointer + 352) + 344) + 20) = 344;
    base_node = *(void ***)(*(_DWORD *)(statistics_pointer + 352) + 344);
    *base_node = malloc(384u);
    hash_table_block = **(void ***)(*(_DWORD *)(statistics_pointer + 352) + 344);
    if ( !hash_table_block )
      goto LABEL_31;
    memset(hash_table_block, 0, 384u);
    current_data_addr = data_pointer + 344;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(statistics_pointer + 352) + 344) + 40) = -1609490463;
  }
  ++*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(statistics_pointer + 352) + 344) + 12);
  node_meta = *(_QWORD *)*(_DWORD *)(*(_DWORD *)(statistics_pointer + 352) + 344);
  hash_table_index = 12 * (final_hash & (HIDWORD(node_meta) - 1));
  ++*(_DWORD *)(node_meta + hash_table_index + 4);
  HIDWORD(node_meta) = *(_DWORD *)(**(_DWORD **)(*(_DWORD *)(statistics_pointer + 352) + 344) + hash_table_index);
  *(_DWORD *)(data_pointer + 356) = 0;
  *(_DWORD *)(data_pointer + 360) = HIDWORD(node_meta);
  HIDWORD(node_meta) = **(_DWORD **)(*(_DWORD *)(statistics_pointer + 352) + 344);
  next_node_addr = *(_DWORD *)(HIDWORD(node_meta) + hash_table_index);
  hash_table_entry = (int *)(HIDWORD(node_meta) + hash_table_index);
  if ( next_node_addr )
  {
    *(_DWORD *)(next_node_addr + 12) = current_data_addr;
    hash_table_entry = (int *)(**(_DWORD **)(*(_DWORD *)(statistics_pointer + 352) + 344) + hash_table_index);
  }
  *hash_table_entry = current_data_addr;
  entries_counts = *(_QWORD *)(**(_DWORD **)(*(_DWORD *)(statistics_pointer + 352) + 344) + hash_table_index + 4);
  if ( (unsigned int)entries_counts >= 10 * (HIDWORD(entries_counts) + 1) )
  {
    current_node_data = *(_DWORD *)(data_pointer + 344);
    if ( *(_DWORD *)(current_node_data + 36) != 1 )
    {
      new_table = calloc(24 * *(_DWORD *)(current_node_data + 4), 1u);
      if ( new_table )
      {
        entry_index = 0;
        *(_DWORD *)(current_node_data + 24) = (((2 * *(_DWORD *)(current_node_data + 4) - 1) & *(_DWORD *)(current_node_data + 12)) != 0)
                                            + (*(_DWORD *)(current_node_data + 12) >> (*(_BYTE *)(current_node_data + 8)
                                                                                     + 1));
        *(_DWORD *)(*(_DWORD *)(data_pointer + 344) + 28) = 0;
        current_node_addr = *(_DWORD *)(data_pointer + 344);
        entries_count = *(_DWORD *)(current_node_addr + 4);
        if ( entries_count )
        {
          for ( loop_index = 0; loop_index < entries_count; ++loop_index )
          {
            current_entry = *(_DWORD **)(*(_DWORD *)current_node_addr + entry_index);
            if ( current_entry )
            {
              while ( 1 )
              {
                next_entry = (_DWORD *)current_entry[4];
                new_table_index = 3 * ((2 * entries_count - 1) & current_entry[7]);
                new_table_entry = (char *)&new_table[new_table_index];
                new_entry_count = *((_DWORD *)new_table_entry + 1) + 1;
                *((_DWORD *)new_table_entry + 1) = new_entry_count;
                if ( new_entry_count > *(_DWORD *)(current_node_addr + 24) )
                {
                  ++*(_DWORD *)(current_node_addr + 28);
                  *((_DWORD *)new_table_entry + 2) = calculate_miner_hashrate(
                                                       *((_DWORD *)new_table_entry + 1),
                                                       *(_DWORD *)(*(_DWORD *)(data_pointer + 344) + 24));
                }
                current_entry[3] = 0;
                current_entry[4] = new_table[new_table_index];
                next_node_in_new_table = new_table[new_table_index];
                if ( next_node_in_new_table )
                  *(_DWORD *)(next_node_in_new_table + 12) = current_entry;
                new_table[new_table_index] = current_entry;
                current_node_addr = *(_DWORD *)(data_pointer + 344);
                if ( !next_entry )
                  break;
                entries_count = *(_DWORD *)(current_node_addr + 4);
                current_entry = next_entry;
              }
              entries_count = *(_DWORD *)(current_node_addr + 4);
            }
            entry_index += 12;
          }
        }
        free(*(void **)current_node_addr);
        *(_DWORD *)(*(_DWORD *)(data_pointer + 344) + 4) *= 2;
        ++*(_DWORD *)(*(_DWORD *)(data_pointer + 344) + 8);
        **(_DWORD **)(data_pointer + 344) = new_table;
        current_node_data_ptr = *(_DWORD **)(data_pointer + 344);
        entries_threshold = current_node_data_ptr[7];
        current_capacity = current_node_data_ptr[3];
        should_resize = entries_threshold > current_capacity >> 1;
        if ( entries_threshold <= current_capacity >> 1 )
          resize_value = 0;
        else
          resize_value = current_node_data_ptr[8];
        if ( should_resize )
          ++resize_value;
        current_node_data_ptr[8] = resize_value;
        current_data = *(_DWORD *)(data_pointer + 344);
        if ( *(_DWORD *)(current_data + 32) > 1u )
          *(_DWORD *)(current_data + 36) = 1;
        return;
      }
LABEL_31:
      exit(-1);
    }
  }
}
// 48AC8: using guessed type int __fastcall sub_48AC8(_DWORD, _DWORD);

//----- (0002A8EC) --------------------------------------------------------
int __fastcall find_matching_entry(
        int head_entry,
        void *comp_buffer1,
        size_t comp_length1,
        const void *comp_buffer2,
        int offset_buffer2,
        size_t comp_length2)
{
  int current_entry; // r5
  int next_entry; // r4

  current_entry = head_entry;
  if ( head_entry )
  {
    next_entry = *(_DWORD *)(head_entry + 352);
    while ( memcmp((const void *)(current_entry + 128), comp_buffer1, comp_length1)
         || memcmp((const void *)(current_entry + offset_buffer2), comp_buffer2, comp_length2) )
    {
      current_entry = next_entry;
      if ( !next_entry )
        return next_entry;
      next_entry = *(_DWORD *)(next_entry + 352);
    }
  }
  return current_entry;
}

//----- (0002A95C) --------------------------------------------------------
int __fastcall find_linked_list_node_by_value(int head_node, int target_value)
{
  int current_node; // r3

  if ( head_node )
  {
    current_node = *(_DWORD *)(head_node + 352);
    if ( target_value != *(_DWORD *)(head_node + 340) )
    {
      if ( current_node )
      {
        head_node = *(_DWORD *)(current_node + 352);
        while ( *(_DWORD *)(current_node + 340) != target_value )
        {
          current_node = head_node;
          if ( !head_node )
            return head_node;
          head_node = *(_DWORD *)(head_node + 352);
        }
      }
      return current_node;
    }
  }
  return head_node;
}

//----- (0002A9A8) --------------------------------------------------------
void __fastcall update_hash_table(int hash_table_ptr, _DWORD *node_data)
{
  int hash_table_base_addr; // r12
  int next_node_offset; // r2
  int current_slot_addr; // lr
  _DWORD *node_base; // r12
  int offset_diff; // r3
  int new_hash_table_addr; // r4
  int next_node_status; // r3
  _DWORD *slot_ptr; // r2
  int hash_index; // r3
  int first_node_addr; // r2
  int prev_node_offset; // r2
  int next_node_ptr; // r3

  hash_table_base_addr = *(_DWORD *)(hash_table_ptr + 352);
  --*(_DWORD *)(hash_table_ptr + 360);
  next_node_offset = node_data[87];
  if ( !next_node_offset )
  {
    new_hash_table_addr = node_data[88];
    current_slot_addr = *(_DWORD *)(hash_table_base_addr + 344);
    if ( !new_hash_table_addr )
    {
      free(*(void **)current_slot_addr);
      free(*(void **)(*(_DWORD *)(hash_table_ptr + 352) + 344));
      *(_DWORD *)(hash_table_ptr + 352) = 0;
      return;
    }
    offset_diff = *(_DWORD *)(current_slot_addr + 20);
    node_base = node_data + 86;
    if ( node_data != (_DWORD *)(*(_DWORD *)(current_slot_addr + 16) - offset_diff) )
      goto LABEL_17;
    goto LABEL_13;
  }
  current_slot_addr = *(_DWORD *)(hash_table_base_addr + 344);
  node_base = node_data + 86;
  offset_diff = *(_DWORD *)(current_slot_addr + 20);
  if ( node_data == (_DWORD *)(*(_DWORD *)(current_slot_addr + 16) - offset_diff) )
  {
LABEL_13:
    *(_DWORD *)(current_slot_addr + 16) = next_node_offset + offset_diff;
    next_node_offset = node_data[87];
    if ( next_node_offset )
    {
      offset_diff = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(hash_table_ptr + 352) + 344) + 20);
      goto LABEL_3;
    }
    new_hash_table_addr = node_data[88];
LABEL_17:
    *(_DWORD *)(hash_table_ptr + 352) = new_hash_table_addr;
    goto LABEL_4;
  }
LABEL_3:
  *(_DWORD *)(next_node_offset + offset_diff + 8) = node_data[88];
  new_hash_table_addr = *(_DWORD *)(hash_table_ptr + 352);
LABEL_4:
  next_node_status = node_data[88];
  slot_ptr = *(_DWORD **)(new_hash_table_addr + 344);
  if ( next_node_status )
  {
    *(_DWORD *)(next_node_status + slot_ptr[5] + 4) = node_data[87];
    slot_ptr = *(_DWORD **)(*(_DWORD *)(hash_table_ptr + 352) + 344);
  }
  hash_index = 12 * ((slot_ptr[1] - 1) & node_data[93]);
  --*(_DWORD *)(*slot_ptr + hash_index + 4);
  first_node_addr = **(_DWORD **)(*(_DWORD *)(hash_table_ptr + 352) + 344);
  if ( *(_DWORD **)(first_node_addr + hash_index) == node_base )
    *(_DWORD *)(first_node_addr + hash_index) = node_data[90];
  prev_node_offset = node_data[89];
  next_node_ptr = node_data[90];
  if ( prev_node_offset )
  {
    *(_DWORD *)(prev_node_offset + 16) = next_node_ptr;
    next_node_ptr = node_data[90];
  }
  if ( next_node_ptr )
    *(_DWORD *)(next_node_ptr + 12) = node_data[89];
  --*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(hash_table_ptr + 352) + 344) + 12);
}

//----- (0002AB18) --------------------------------------------------------
int __fastcall check_and_perform_action(int status)
{
  if ( *(_DWORD *)(status + 32) != 1 )
    return (*(int (**)(void))(*(_DWORD *)(status + 4) + 16))();
  return status;
}

//----- (0002AB30) --------------------------------------------------------
void __fastcall __noreturn shutdown_miner(int exit_code, int should_restart)
{
  pthread_t shutdown_thread; // [sp+4h] [bp-Ch] BYREF

  if ( !pthread_create(&shutdown_thread, 0, (void *(*)(void *))terminate_process_after_delay, 0) )
  {
    if ( should_restart )
      update_and_log_system_info(0);
    if ( dword_66A6C > 0 )
    {
      kill(dword_66A6C, 15);
      dword_66A6C = 0;
    }
    pthread_cancel(shutdown_thread);
    exit(exit_code);
  }
  exit(1);
}
// 66A6C: using guessed type int dword_66A6C;

//----- (0002ABB0) --------------------------------------------------------
void __noreturn handle_shutdown_signal()
{
  char shutdown_message[2056]; // [sp+0h] [bp-808h] BYREF

  init_completion_timeout_thread((int)check_miner_status, 0, 5000);
  strcpy(shutdown_message, "Shutdown signal received.");
  log_event(3, shutdown_message, 1);
  shutdown_miner(0, 1);
}
// 2AB30: using guessed type void __fastcall __noreturn sub_2AB30(_DWORD, _DWORD);
// 2E354: using guessed type int sub_2E354();

//----- (0002AC0C) --------------------------------------------------------
void __noreturn sub_2AC0C()
{
  sigaction(15, &unk_70D28, 0);
  sigaction(2, &unk_73FDC, 0);
  sigaction(6, &unk_74190, 0);
  handle_shutdown_signal();
}

//----- (0002AC50) --------------------------------------------------------
int __fastcall format_miner_stats(char *output_buffer, size_t buffer_size, int miner_data)
{
  double unknown_float; // d0
  double work_utilization; // d8
  __int64 hashrate_per_second; // r8
  __int64 average_hashrate_per_second; // r0
  size_t current_length; // r7
  char hashrate_str[16]; // [sp+28h] [bp-8A0h] BYREF
  char avg_hashrate_str[16]; // [sp+38h] [bp-890h] BYREF
  char stat_line[64]; // [sp+48h] [bp-880h] BYREF
  char overflow_msg[2112]; // [sp+88h] [bp-840h] BYREF

  update_firmware(miner_data);
  work_utilization = convert_float_to_int(*(_DWORD *)(miner_data + 192)) / unknown_float * 60.0;
  hashrate_per_second = calculate_hash_value(
                          COERCE_UNSIGNED_INT64(*(double *)(miner_data + 48) * 1000000.0),
                          HIDWORD(COERCE_UNSIGNED_INT64(*(double *)(miner_data + 48) * 1000000.0)));
  average_hashrate_per_second = calculate_hash_value(
                                  COERCE_UNSIGNED_INT64(*(double *)(miner_data + 80) / unknown_float * 1000000.0),
                                  HIDWORD(COERCE_UNSIGNED_INT64(*(double *)(miner_data + 80) / unknown_float * 1000000.0)));
  format_hashrate(average_hashrate_per_second, SHIDWORD(average_hashrate_per_second), hashrate_str, 16u, 4);
  format_hashrate(hashrate_per_second, SHIDWORD(hashrate_per_second), avg_hashrate_str, 16u, 4);
  snprintf(
    output_buffer,
    buffer_size,
    "%s%d ",
    *(const char **)(*(_DWORD *)(miner_data + 4) + 8),
    *(_DWORD *)(miner_data + 8));
  (*(void (__fastcall **)(char *, size_t, int))(*(_DWORD *)(miner_data + 4) + 20))(
    output_buffer,
    buffer_size,
    miner_data);
  current_length = strlen(output_buffer);
  snprintf(
    stat_line,
    64u,
    "(%ds):%s (avg):%sh/s | A:%.0f R:%.0f HW:%d WU:%.1f/m",
    dword_66130,
    avg_hashrate_str,
    hashrate_str,
    *(double *)(miner_data + 200),
    *(double *)(miner_data + 208),
    *(_DWORD *)(miner_data + 44),
    work_utilization);
  if ( current_length + strlen(stat_line) >= buffer_size )
  {
    snprintf(overflow_msg, 2048u, "tailsprintf buffer overflow in %s %s line %d", "cgminer.c", "get_statline", 3151);
    log_event(3, overflow_msg, 1);
    shutdown_miner(1, 1);
  }
  strcat(output_buffer, stat_line);
  return (*(int (__fastcall **)(char *, size_t, int))(*(_DWORD *)(miner_data + 4) + 24))(
           output_buffer,
           buffer_size,
           miner_data);
}
// 2AC94: variable 'unknown_float' is possibly undefined
// 29090: using guessed type int __fastcall sub_29090(_DWORD);
// 2AB30: using guessed type void __fastcall __noreturn sub_2AB30(_DWORD, _DWORD);
// 4930C: using guessed type double __fastcall sub_4930C(_DWORD);
// 493C8: using guessed type __int64 __fastcall sub_493C8(_DWORD, _DWORD);
// 66130: using guessed type int dword_66130;

//----- (0002AE24) --------------------------------------------------------
void __noreturn log_restart_thread_creation_failure()
{
  char error_message[2056]; // [sp+0h] [bp-808h] BYREF

  strcpy(error_message, "Failed to create restart thread");
  log_event(3, error_message, 1);
  shutdown_miner(1, 1);
}
// 2AB30: using guessed type void __fastcall __noreturn sub_2AB30(_DWORD, _DWORD);

//----- (0002AE68) --------------------------------------------------------
int __fastcall init_restart_monitor_thread(int unused_param, int param1, int param2, int param3)
{
  int thread_creation_status; // r0
  pthread_t restart_thread_id; // [sp+4h] [bp-Ch] BYREF

  get_hardware_timestamp(&unk_66A4C, param1, param2, param3);
  thread_creation_status = pthread_create(&restart_thread_id, 0, (void *(*)(void *))restart_miners, 0);
  if ( thread_creation_status )
    log_restart_thread_creation_failure();
  return thread_creation_status;
}
// 1F5C4: using guessed type int __fastcall sub_1F5C4(_DWORD, _DWORD, _DWORD, _DWORD);
// 3315C: using guessed type int sub_3315C();

//----- (0002AEA8) --------------------------------------------------------
int __fastcall process_benchfile_entry(void *target_buffer)
{
  int prev_benchfile_ptr; // r4
  int file_op_result; // r4
  bool is_valid_line; // r4
  int line_number; // r5
  int result; // r0
  FILE *file_pointer; // r2
  char *line_ptr; // r0
  char **fields_ptr; // r9
  int field_count; // r11
  char *comma_ptr; // r0
  int field_index; // r1
  int field_start_offset; // r12
  char *field_expected_length; // lr
  int json_offset; // r11
  char *actual_length_ptr; // r12
  _BOOL4 is_length_mismatch; // r2
  size_t nonce_time_length; // r0
  size_t output_offset; // r10
  char *output_ptr; // r9
  const char *timestamp_part_ptr; // r5
  const char *timestamp_end_ptr; // r6
  const char *current_timestamp_part; // r2
  char *checksum_ptr; // r9
  const char *checksum_part_ptr; // r5
  const char *checksum_end_ptr; // r6
  const char *current_checksum_part; // r2
  int nonce_value; // r0
  const char *nonce_time_str; // [sp+14h] [bp-C44h]
  char *first_field_ptr; // [sp+1Ch] [bp-C3Ch] BYREF
  int checksum_start_offset; // [sp+20h] [bp-C38h]
  int timestamp_start_offset; // [sp+24h] [bp-C34h]
  char *nonce_str; // [sp+28h] [bp-C30h]
  char *nonce_time_field; // [sp+2Ch] [bp-C2Ch]
  char line_buffer[1024]; // [sp+30h] [bp-C28h] BYREF
  char output_buffer[2088]; // [sp+430h] [bp-828h] BYREF

  prev_benchfile_ptr = dword_66A70;
  if ( !dword_66A70 )
  {
    if ( !dword_70D08 )
    {
      strcpy(output_buffer, "BENCHFILE Invalid benchfile NULL");
      log_event(3, output_buffer, 1);
      shutdown_miner(1, 1);
    }
    file_pointer = (FILE *)fopen64(dword_70D08, "r");
    dword_66A70 = (int)file_pointer;
    if ( file_pointer )
    {
      dword_66A74 = prev_benchfile_ptr;
      if ( !fgets(line_buffer, 1024, file_pointer) )
      {
        snprintf(output_buffer, 2048u, "BENCHFILE Failed to read benchfile '%s'", dword_70D08);
        goto LABEL_13;
      }
      dword_66A78 = prev_benchfile_ptr;
      while ( 1 )
      {
LABEL_3:
        is_valid_line = line_buffer[0] != 35;
        if ( !line_buffer[0] )
          is_valid_line = 0;
        line_number = dword_66A74 + 1;
        file_op_result = line_buffer[0] != 47 && is_valid_line;
        ++dword_66A74;
        if ( file_op_result )
          break;
        if ( !fgets(line_buffer, 1024, (FILE *)dword_66A70) )
          goto LABEL_10;
      }
      line_ptr = line_buffer;
      fields_ptr = &first_field_ptr;
      field_count = 0;
      first_field_ptr = line_buffer;
      do
      {
        comma_ptr = strchr(line_ptr, 44);
        fields_ptr[1] = comma_ptr;
        field_index = field_count + 1;
        if ( !comma_ptr )
        {
          snprintf(
            output_buffer,
            2048u,
            "BENCHFILE Invalid input file line %d - field count is %d but should be %d",
            line_number,
            field_count + 1,
            5);
          goto LABEL_13;
        }
        field_start_offset = (int)*fields_ptr++;
        field_expected_length = (char *)dword_4CAC8[2 * field_count];
        json_offset = 8 * field_count;
        actual_length_ptr = &comma_ptr[-field_start_offset];
        is_length_mismatch = field_expected_length != actual_length_ptr;
        if ( !field_expected_length )
          is_length_mismatch = 0;
        if ( is_length_mismatch )
        {
          snprintf(
            output_buffer,
            2048u,
            "BENCHFILE Invalid input file line %d field %d (%s) length is %d but should be %d",
            line_number,
            field_index,
            *(const char **)&aJsonEscape[json_offset + 160],
            actual_length_ptr,
            field_expected_length);
          goto LABEL_13;
        }
        *comma_ptr = 0;
        line_ptr = comma_ptr + 1;
        field_count = field_index;
        *fields_ptr = line_ptr;
      }
      while ( field_index != 4 );
      nonce_time_str = nonce_time_field;
      nonce_time_length = strlen(nonce_time_field);
      if ( nonce_time_length > 9 )
      {
        sprintf(output_buffer, "0000000%c", (unsigned __int8)*first_field_ptr);
        output_offset = strlen(output_buffer);
        output_ptr = &output_buffer[output_offset];
        timestamp_part_ptr = (const char *)(timestamp_start_offset + 56);
        timestamp_end_ptr = (const char *)(timestamp_start_offset - 8);
        do
        {
          current_timestamp_part = timestamp_part_ptr;
          timestamp_part_ptr -= 8;
          sprintf(output_ptr, "%.8s", current_timestamp_part);
          output_ptr += 8;
        }
        while ( timestamp_end_ptr != timestamp_part_ptr );
        checksum_ptr = &output_buffer[output_offset + 64];
        checksum_part_ptr = (const char *)(checksum_start_offset + 56);
        checksum_end_ptr = (const char *)(checksum_start_offset - 8);
        do
        {
          current_checksum_part = checksum_part_ptr;
          checksum_part_ptr -= 8;
          sprintf(checksum_ptr, "%.8s", current_checksum_part);
          checksum_ptr += 8;
        }
        while ( checksum_end_ptr != checksum_part_ptr );
        nonce_value = strtol(nonce_time_str, 0, 10);
        sprintf(&output_buffer[output_offset + 128], "%08lx", nonce_value);
        strcpy(&output_buffer[output_offset + 136], nonce_str);
        memset(target_buffer, 0, 448u);
        hex_string_to_binary(target_buffer, output_buffer);
        calculate_midstate(target_buffer);
        result = file_op_result;
        ++dword_66A78;
        return result;
      }
      snprintf(
        output_buffer,
        2048u,
        "BENCHFILE Invalid input file line %d field %d (%s) length is %d but should be least %d",
        line_number,
        5,
        "NonceTime",
        nonce_time_length,
        10);
    }
    else
    {
      snprintf(output_buffer, 2048u, "BENCHFILE Failed to open benchfile '%s'", dword_70D08);
    }
LABEL_13:
    log_event(3, output_buffer, 1);
    shutdown_miner(1, 1);
  }
  file_op_result = (int)fgets(line_buffer, 1024, (FILE *)dword_66A70);
  if ( file_op_result )
    goto LABEL_3;
LABEL_10:
  if ( !dword_66A78 )
  {
    snprintf(output_buffer, 2048u, "BENCHFILE No work in benchfile '%s'", dword_70D08);
    goto LABEL_13;
  }
  fclose((FILE *)dword_66A70);
  dword_66A70 = file_op_result;
  return process_benchfile_entry(target_buffer);
}
// 1224C: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 1EA68: using guessed type int __fastcall sub_1EA68(_DWORD, _DWORD);
// 2768C: using guessed type int __fastcall sub_2768C(_DWORD);
// 2AB30: using guessed type void __fastcall __noreturn sub_2AB30(_DWORD, _DWORD);
// 4CAC8: using guessed type _DWORD dword_4CAC8[10];
// 66A70: using guessed type int dword_66A70;
// 66A74: using guessed type int dword_66A74;
// 66A78: using guessed type int dword_66A78;
// 70D08: using guessed type int dword_70D08;
// 2AEA8: using guessed type char var_828[2088];

//----- (0002B2B4) --------------------------------------------------------
void __fastcall __noreturn log_mutex_initialization_failure(const char *function_name, int line_number)
{
  int *errno_ptr; // r0
  char error_message[2056]; // [sp+10h] [bp-808h] BYREF

  errno_ptr = _errno_location();
  snprintf(
    error_message,
    2048u,
    "Failed to pthread_mutex_init errno=%d in %s %s():%d",
    *errno_ptr,
    "cgminer.c",
    function_name,
    line_number);
  log_event(3, error_message, 1);
  shutdown_miner(1, 1);
}
// 2AB30: using guessed type void __fastcall __noreturn sub_2AB30(_DWORD, _DWORD);

//----- (0002B310) --------------------------------------------------------
int __fastcall init_mutex_and_log_failure(pthread_mutex_t *mutex, const char *caller_name, int caller_line)
{
  int init_result; // r0

  init_result = pthread_mutex_init(mutex, 0);
  if ( init_result )
    log_mutex_initialization_failure(caller_name, caller_line);
  return init_result;
}

//----- (0002B338) --------------------------------------------------------
void __fastcall __noreturn log_rwlock_init_error(const char *function_name, int line_number)
{
  int *errno_ptr; // r0
  char error_message[2056]; // [sp+10h] [bp-808h] BYREF

  errno_ptr = _errno_location();
  snprintf(
    error_message,
    2048u,
    "Failed to pthread_rwlock_init errno=%d in %s %s():%d",
    *errno_ptr,
    "cgminer.c",
    function_name,
    line_number);
  log_event(3, error_message, 1);
  shutdown_miner(1, 1);
}
// 2AB30: using guessed type void __fastcall __noreturn sub_2AB30(_DWORD, _DWORD);

//----- (0002B394) --------------------------------------------------------
int __fastcall init_rwlock_with_logging(pthread_rwlock_t *rwlock, const char *file_name, int line_number)
{
  int init_result; // r0

  init_result = pthread_rwlock_init(rwlock, 0);
  if ( init_result )
    log_rwlock_init_error(file_name, line_number);
  return init_result;
}

//----- (0002B3BC) --------------------------------------------------------
int __fastcall initialize_synchronization_primitives(
        int sync_primitives_base_addr,
        const char *caller_info,
        int caller_info_additional)
{
  int init_result; // r0

  if ( pthread_mutex_init((pthread_mutex_t *)sync_primitives_base_addr, 0) )
    log_mutex_initialization_failure(caller_info, caller_info_additional);
  init_result = pthread_rwlock_init((pthread_rwlock_t *)(sync_primitives_base_addr + 24), 0);
  if ( init_result )
    log_rwlock_init_error(caller_info, caller_info_additional);
  return init_result;
}

//----- (0002B404) --------------------------------------------------------
void __fastcall __noreturn log_write_lock_error(const char *function_name, int line_number)
{
  int *error_number_ptr; // r0
  char error_message[2056]; // [sp+10h] [bp-808h] BYREF

  error_number_ptr = _errno_location();
  snprintf(
    error_message,
    2048u,
    "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
    *error_number_ptr,
    "cgminer.c",
    function_name,
    line_number);
  log_event(3, error_message, 1);
  shutdown_miner(1, 1);
}
// 2AB30: using guessed type void __fastcall __noreturn sub_2AB30(_DWORD, _DWORD);

//----- (0002B460) --------------------------------------------------------
void __fastcall __noreturn log_mutex_error_and_exit(const char *function_name, int line_number)
{
  int *error_number_ptr; // r0
  char error_message[2056]; // [sp+10h] [bp-808h] BYREF

  error_number_ptr = _errno_location();
  snprintf(
    error_message,
    2048u,
    "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
    *error_number_ptr,
    "cgminer.c",
    function_name,
    line_number);
  log_event(3, error_message, 1);
  shutdown_miner(1, 1);
}
// 2AB30: using guessed type void __fastcall __noreturn sub_2AB30(_DWORD, _DWORD);

//----- (0002B4BC) --------------------------------------------------------
void __fastcall __noreturn log_mutex_unlock_error(const char *function_name, int line_number)
{
  int *error_ptr; // r0
  char error_message[2056]; // [sp+10h] [bp-808h] BYREF

  error_ptr = _errno_location();
  snprintf(
    error_message,
    2048u,
    "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
    *error_ptr,
    "cgminer.c",
    function_name,
    line_number);
  log_event(3, error_message, 1);
  shutdown_miner(1, 1);
}
// 2AB30: using guessed type void __fastcall __noreturn sub_2AB30(_DWORD, _DWORD);

//----- (0002B518) --------------------------------------------------------
int __fastcall reset_thread_signal(int thread_data, _BYTE *signal_flag)
{
  int mutex_lock_ptr; // r4
  pthread_mutex_t *mutex_unlock_ptr; // r0
  int previous_signal_state; // r4

  mutex_lock_ptr = thread_data + 188;
  if ( pthread_mutex_lock((pthread_mutex_t *)(thread_data + 188)) )
    log_mutex_error_and_exit("pool_tclear", 828);
  mutex_unlock_ptr = (pthread_mutex_t *)mutex_lock_ptr;
  previous_signal_state = (unsigned __int8)*signal_flag;
  *signal_flag = 0;
  if ( pthread_mutex_unlock(mutex_unlock_ptr) )
    log_mutex_unlock_error("pool_tclear", 833);
  off_658DC(0);
  return previous_signal_state;
}
// 1DA28: using guessed type int sub_1DA28(void);
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);

//----- (0002B580) --------------------------------------------------------
int __fastcall update_device_status(int current_status, int next_status)
{
  if ( pthread_mutex_lock(&stru_70CEC) )
    log_mutex_error_and_exit("inc_dev_status", 8832);
  dword_73FBC = current_status;
  dword_74134 = next_status;
  if ( pthread_mutex_unlock(&stru_70CEC) )
    log_mutex_unlock_error("inc_dev_status", 8835);
  return off_658DC(0);
}
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);
// 70CEC: using guessed type pthread_mutex_t stru_70CEC;
// 73FBC: using guessed type int dword_73FBC;
// 74134: using guessed type int dword_74134;

//----- (0002B5FC) --------------------------------------------------------
int __fastcall set_pool_test_flag(int pool_struct, _BYTE *test_flag)
{
  int pool_test_mutex; // r4
  pthread_mutex_t *mutex_to_unlock; // r0
  int previous_test_flag_state; // r4

  pool_test_mutex = pool_struct + 188;
  if ( pthread_mutex_lock((pthread_mutex_t *)(pool_struct + 188)) )
    log_mutex_error_and_exit("pool_tset", 813);
  mutex_to_unlock = (pthread_mutex_t *)pool_test_mutex;
  previous_test_flag_state = (unsigned __int8)*test_flag;
  *test_flag = 1;
  if ( pthread_mutex_unlock(mutex_to_unlock) )
    log_mutex_unlock_error("pool_tset", 818);
  off_658DC(0);
  return previous_test_flag_state;
}
// 1DA28: using guessed type int sub_1DA28(void);
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);

//----- (0002B668) --------------------------------------------------------
int __fastcall process_mining_protocol(_DWORD *miner_data, int arg_two, int arg_three)
{
  int is_test; // r7
  int v5; // r6
  int probe_status; // r3
  int unused1; // r1
  int unused2; // r2
  int unused3; // r3
  int stratum_url; // r0
  int stratum_start_result; // r7
  const char *error_message; // r12
  int err_msg_part1; // r0
  int err_msg_part2; // r1
  int err_msg_part3; // r2
  int err_msg_part4; // r3
  int *err_msg_part_arr; // r12
  int err_msg_part5; // r0
  int err_msg_part6; // r1
  int err_msg_part7; // r2
  int err_msg_part8; // r3
  int err_msg_part9; // r12
  const char *gbt_message; // r1
  size_t gbt_msg_len; // r2
  int probe_gbt_support; // r3
  char probe_data1[8]; // [sp+Ch] [bp-84Ch] BYREF
  char probe_data2[8]; // [sp+14h] [bp-844h] BYREF
  pthread_attr_t thread_attributes; // [sp+1Ch] [bp-83Ch] BYREF
  char log_buffer[2072]; // [sp+40h] [bp-818h] BYREF

  is_test = arg_two;
  if ( *((_BYTE *)miner_data + 736) )
  {
    if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
    {
      snprintf(log_buffer, 2048u, "Retrieving block template from pool %s", (const char *)miner_data[41]);
      log_event(7, log_buffer, 0);
    }
  }
  else if ( byte_70CE8 || byte_66640 || dword_657B8 > 5 )
  {
    snprintf(log_buffer, 2048u, "Testing pool %s", (const char *)miner_data[41]);
    log_event(6, log_buffer, 0);
  }
  v5 = *((unsigned __int8 *)miner_data + 640);
  if ( *((_BYTE *)miner_data + 640) )
    goto LABEL_38;
  if ( off_66134 )
  {
    probe_status = *((unsigned __int8 *)miner_data + 99);
    if ( *((_BYTE *)miner_data + 99) )
      goto LABEL_15;
    probe_status = (unsigned __int8)byte_66641;
    if ( !byte_66641 )
    {
      *((_BYTE *)miner_data + 99) = v5;
      goto LABEL_15;
    }
    if ( byte_70CE8 || byte_66640 || dword_657B8 > 6 )
    {
      strcpy(log_buffer, "Probing for GBT support");
      log_event(7, log_buffer, 0);
      arg_three = *((unsigned __int8 *)miner_data + 736);
      arg_two = 0;
      probe_status = (unsigned __int8)byte_66641;
      *((_BYTE *)miner_data + 99) = 0;
      if ( !arg_three )
      {
        arg_three = *((unsigned __int8 *)miner_data + 900);
        if ( !*((_BYTE *)miner_data + 900) )
        {
          if ( !probe_status )
            goto LABEL_15;
          if ( byte_70CE8 )
            goto LABEL_66;
LABEL_64:
          if ( byte_66640 )
            goto LABEL_66;
          probe_status = dword_657B8;
          if ( dword_657B8 > 6 )
            goto LABEL_66;
LABEL_15:
          get_hardware_timestamp(probe_data1, arg_two, arg_three, probe_status);
          get_hardware_timestamp(probe_data2, unused1, unused2, unused3);
          stratum_url = miner_data[144];
          if ( !stratum_url || byte_66A7C )
            goto LABEL_98;
          if ( byte_70CE8 || byte_66640 || dword_657B8 > 5 )
          {
            snprintf(log_buffer, 2048u, "Testing pool %d stratum %s", *miner_data, (const char *)miner_data[144]);
            log_event(6, log_buffer, 0);
            stratum_url = miner_data[144];
          }
          if ( !parse_url(stratum_url, miner_data + 150, miner_data + 146) || !initiate_stratum(miner_data) )
          {
LABEL_98:
            if ( *((_BYTE *)miner_data + 640) || *((_BYTE *)miner_data + 900) || *((_BYTE *)miner_data + 736) )
            {
              if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
              {
                snprintf(
                  log_buffer,
                  2048u,
                  "FAILED to retrieve work from pool %u %s",
                  *miner_data,
                  (const char *)miner_data[41]);
                log_event(7, log_buffer, 0);
              }
              if ( !is_test && !*((_BYTE *)miner_data + 97) && (byte_70CE8 || byte_66640 || dword_657B8 > 3) )
              {
                snprintf(log_buffer, 2048u, "Pool %u slow/down or URL or credentials invalid", *miner_data);
                v5 = 0;
                log_event(4, log_buffer, 0);
              }
            }
            else if ( byte_70CE8 || byte_66640 || dword_657B8 > 3 )
            {
              v5 = 0;
              snprintf(
                log_buffer,
                2048u,
                "No Stratum, GBT or Solo support in pool %d %s unable to use",
                *miner_data,
                (const char *)miner_data[41]);
              log_event(4, log_buffer, 0);
            }
            return v5;
          }
          if ( byte_70CE8 || byte_66640 || dword_657B8 > 4 )
          {
            snprintf(
              log_buffer,
              2048u,
              "Switching pool %d %s to %s",
              *miner_data,
              (const char *)miner_data[41],
              (const char *)miner_data[144]);
            log_event(5, log_buffer, 0);
          }
          if ( !miner_data[41] )
            miner_data[41] = _strdup((const char *)miner_data[144]);
          *((_BYTE *)miner_data + 640) = 1;
LABEL_38:
          v5 = set_pool_test_flag(miner_data, (char *)miner_data + 642);
          if ( v5 )
            return *((unsigned __int8 *)miner_data + 641);
          if ( !setup_stratum_connection((int)miner_data)
            || *((_BYTE *)miner_data + 580) && !send_extranonce_subscribe(miner_data)
            || !initiate_stratum(miner_data)
            || (stratum_start_result = attempt_stratum_auth(miner_data)) == 0 )
          {
            reset_thread_signal(miner_data, (char *)miner_data + 642);
            return v5;
          }
          byte_7421C = 1;
          pthread_attr_init(&thread_attributes);
          pthread_attr_setstacksize(&thread_attributes, 1048576u);
          if ( pthread_create(
                 miner_data + 174,
                 &thread_attributes,
                 (void *(*)(void *))process_stratum_thread,
                 miner_data) )
          {
            error_message = (const char *)&unk_5018C;
          }
          else
          {
            if ( !pthread_create(miner_data + 175, &thread_attributes, (void *(*)(void *))stratum_thread, miner_data) )
              return stratum_start_result;
            error_message = "Failed to create stratum rthread";
          }
          err_msg_part1 = *(_DWORD *)error_message;
          err_msg_part2 = *((_DWORD *)error_message + 1);
          err_msg_part3 = *((_DWORD *)error_message + 2);
          err_msg_part4 = *((_DWORD *)error_message + 3);
          err_msg_part_arr = (int *)(error_message + 16);
          *(_DWORD *)log_buffer = err_msg_part1;
          *(_DWORD *)&log_buffer[4] = err_msg_part2;
          *(_DWORD *)&log_buffer[8] = err_msg_part3;
          *(_DWORD *)&log_buffer[12] = err_msg_part4;
          err_msg_part5 = *err_msg_part_arr;
          err_msg_part6 = err_msg_part_arr[1];
          err_msg_part7 = err_msg_part_arr[2];
          err_msg_part8 = err_msg_part_arr[3];
          err_msg_part9 = err_msg_part_arr[4];
          *(_DWORD *)&log_buffer[16] = err_msg_part5;
          *(_DWORD *)&log_buffer[20] = err_msg_part6;
          *(_DWORD *)&log_buffer[24] = err_msg_part7;
          *(_DWORD *)&log_buffer[28] = err_msg_part8;
          log_buffer[32] = err_msg_part9;
          log_event(3, log_buffer, 1);
          shutdown_miner(1, 1);
        }
        if ( !probe_status )
          goto LABEL_15;
LABEL_55:
        if ( byte_70CE8 || byte_66640 || (probe_status = dword_657B8, dword_657B8 > 6) )
        {
          gbt_message = "GBT coinbase without append found, switching to GBT solo protocol";
          gbt_msg_len = 66;
LABEL_59:
          memcpy(log_buffer, gbt_message, gbt_msg_len);
          log_event(7, log_buffer, 0);
          goto LABEL_15;
        }
        goto LABEL_15;
      }
      if ( !probe_status )
        goto LABEL_15;
    }
    else
    {
      probe_gbt_support = *((unsigned __int8 *)miner_data + 736);
      *((_BYTE *)miner_data + 99) = v5;
      if ( !probe_gbt_support )
      {
        if ( !*((_BYTE *)miner_data + 900) )
        {
          if ( byte_70CE8 )
          {
LABEL_66:
            gbt_message = "No GBT coinbase + append support found, pool unusable if it has no stratum";
            gbt_msg_len = 75;
            goto LABEL_59;
          }
          goto LABEL_64;
        }
        goto LABEL_55;
      }
    }
    if ( byte_70CE8 || byte_66640 || (probe_status = dword_657B8, dword_657B8 > 6) )
    {
      strcpy(log_buffer, "GBT coinbase + append support found, switching to GBT protocol");
      log_event(7, log_buffer, 0);
    }
    goto LABEL_15;
  }
  if ( !byte_70CE8 && !byte_66640 && dword_657B8 <= 2 )
    return v5;
  strcpy(log_buffer, "CURL initialisation failed");
  log_event(3, log_buffer, 0);
  return v5;
}
// 2B7BC: variable 'arg_two' is possibly undefined
// 2B7BC: variable 'arg_three' is possibly undefined
// 2B7BC: variable 'probe_status' is possibly undefined
// 2B7C4: variable 'unused1' is possibly undefined
// 2B7C4: variable 'unused2' is possibly undefined
// 2B7C4: variable 'unused3' is possibly undefined
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 1F5C4: using guessed type int __fastcall sub_1F5C4(_DWORD, _DWORD, _DWORD, _DWORD);
// 1F930: using guessed type int __fastcall sub_1F930(_DWORD, _DWORD, _DWORD);
// 25A7C: using guessed type int __fastcall sub_25A7C(_DWORD);
// 25E74: using guessed type int __fastcall sub_25E74(_DWORD);
// 2AB30: using guessed type void __fastcall __noreturn sub_2AB30(_DWORD, _DWORD);
// 2B518: using guessed type int __fastcall sub_2B518(_DWORD, _DWORD);
// 2B5FC: using guessed type int __fastcall sub_2B5FC(_DWORD, _DWORD);
// 657B8: using guessed type int dword_657B8;
// 66134: using guessed type char *off_66134;
// 66640: using guessed type char byte_66640;
// 66641: using guessed type char byte_66641;
// 66A7C: using guessed type char byte_66A7C;
// 70CE8: using guessed type char byte_70CE8;
// 7421C: using guessed type char byte_7421C;
// 2B668: using guessed type char var_84C[8];
// 2B668: using guessed type char var_844[8];

//----- (0002BE48) --------------------------------------------------------
int wake_global_work_softwares()
{
  if ( pthread_mutex_lock((pthread_mutex_t *)dword_66A80) )
    log_mutex_error_and_exit("wake_gws", 5401);
  pthread_cond_signal(&stru_70DC0);
  if ( pthread_mutex_unlock((pthread_mutex_t *)dword_66A80) )
    log_mutex_unlock_error("wake_gws", 5403);
  return off_658DC(0);
}
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);
// 66A80: using guessed type int dword_66A80;
// 70DC0: using guessed type pthread_cond_t stru_70DC0;

//----- (0002BEB0) --------------------------------------------------------
int __fastcall wait_for_restart_or_timeout(int restart_flag_ptr, unsigned int timeout_ms)
{
  unsigned int timeout_sec; // r4
  unsigned int remainder_ms; // r1
  __time_t adjusted_sec; // r4
  int adjusted_nsec; // r1
  int lock_result; // r4
  int current_time_secs[2]; // [sp+0h] [bp-20h] BYREF
  struct timespec adjusted_abstime; // [sp+8h] [bp-18h] BYREF

  timeout_sec = timeout_ms / 1000;
  get_hardware_timestamp(
    current_time_secs,
    timeout_ms,
    274877907 * timeout_ms,
    (274877907 * (unsigned __int64)timeout_ms) >> 32);
  remainder_ms = 1000 * timeout_ms - 1000000 * timeout_sec;
  adjusted_sec = timeout_sec + current_time_secs[0];
  adjusted_nsec = remainder_ms + current_time_secs[1];
  if ( adjusted_nsec > 999999 )
  {
    ++adjusted_sec;
    adjusted_nsec -= 1000000;
  }
  adjusted_abstime.tv_sec = adjusted_sec;
  adjusted_abstime.tv_nsec = 1000 * adjusted_nsec;
  lock_result = pthread_mutex_lock(&stru_72EC4);
  if ( lock_result )
    log_mutex_error_and_exit("restart_wait", 5454);
  if ( !*(_BYTE *)(restart_flag_ptr + 62) )
    lock_result = pthread_cond_timedwait(&stru_740F0, &stru_72EC4, &adjusted_abstime);
  if ( pthread_mutex_unlock(&stru_72EC4) )
    log_mutex_unlock_error("restart_wait", 5464);
  off_658DC(0);
  return lock_result;
}
// 1DA28: using guessed type int sub_1DA28(void);
// 1F5C4: using guessed type int __fastcall sub_1F5C4(_DWORD, _DWORD, _DWORD, _DWORD);
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);
// 72EC4: using guessed type pthread_mutex_t stru_72EC4;
// 740F0: using guessed type pthread_cond_t stru_740F0;

//----- (0002BFAC) --------------------------------------------------------
void __fastcall __noreturn log_rwlock_error_and_exit(const char *function_name, int line_number)
{
  int *errno_ptr; // r0
  char error_message[2056]; // [sp+10h] [bp-808h] BYREF

  errno_ptr = _errno_location();
  snprintf(
    error_message,
    2048u,
    "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
    *errno_ptr,
    "cgminer.c",
    function_name,
    line_number);
  log_event(3, error_message, 1);
  shutdown_miner(1, 1);
}
// 2AB30: using guessed type void __fastcall __noreturn sub_2AB30(_DWORD, _DWORD);

//----- (0002C008) --------------------------------------------------------
int __fastcall unlock_rwlock_and_log_error(pthread_rwlock_t *rwlock, const char *file_name, int line_number)
{
  if ( pthread_rwlock_unlock(rwlock) )
    log_rwlock_error_and_exit(file_name, line_number);
  return off_658DC(0);
}
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);

//----- (0002C040) --------------------------------------------------------
int increment_total_work()
{
  int previous_total_work; // r4

  if ( pthread_mutex_lock(&stru_740A0) )
    log_mutex_error_and_exit("total_work_inc", 2298);
  if ( pthread_rwlock_wrlock(&rwlock) )
    log_write_lock_error("total_work_inc", 2298);
  previous_total_work = dword_66A84++;
  if ( pthread_rwlock_unlock(&rwlock) )
    log_rwlock_error_and_exit("total_work_inc", 2300);
  if ( pthread_mutex_unlock(&stru_740A0) )
    log_mutex_unlock_error("total_work_inc", 2300);
  off_658DC(0);
  return previous_total_work;
}
// 1DA28: using guessed type int sub_1DA28(void);
// 2B404: using guessed type void __fastcall __noreturn sub_2B404(_DWORD, _DWORD);
// 2B460: using guessed type void __fastcall __noreturn sub_2B460(_DWORD, _DWORD);
// 2B4BC: using guessed type void __fastcall __noreturn sub_2B4BC(_DWORD, _DWORD);
// 2BFAC: using guessed type void __fastcall __noreturn sub_2BFAC(_DWORD, _DWORD);
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);
// 66A84: using guessed type int dword_66A84;
// 740A0: using guessed type pthread_mutex_t stru_740A0;

//----- (0002C0F0) --------------------------------------------------------
int __fastcall increment_work_package(int work_package_ptr)
{
  int prev_total_work; // r1
  bool is_initialization_complete; // zf
  unsigned int new_nonce; // r3
  int new_work_timestamp; // r0
  int extra_nonce_length; // r5
  int new_total_work; // r0
  int temp_buffer[516]; // [sp+0h] [bp-810h] BYREF

  prev_total_work = dword_70E6C;
  is_initialization_complete = byte_66641 == 0;
  new_nonce = bswap32(bswap32(*(_DWORD *)(work_package_ptr + 68)) + 1);
  new_work_timestamp = *(_DWORD *)(work_package_ptr + 240) + 1;
  *(_DWORD *)(work_package_ptr + 68) = new_nonce;
  *(_DWORD *)(work_package_ptr + 240) = new_work_timestamp;
  *(_DWORD *)(work_package_ptr + 248) = 0;
  dword_70E6C = prev_total_work + 1;
  if ( !is_initialization_complete && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
  {
    strcpy((char *)temp_buffer, "Successfully rolled work");
    log_event(7, (const char *)temp_buffer, 0);
  }
  extra_nonce_length = *(_DWORD *)(work_package_ptr + 308);
  if ( extra_nonce_length )
  {
    hex_string_to_binary(temp_buffer, *(unsigned __int8 **)(work_package_ptr + 308), 4);
    temp_buffer[0] = bswap32(bswap32(temp_buffer[0]) + 1);
    convert_bytes_to_hexstring(extra_nonce_length, temp_buffer, 4);
  }
  new_total_work = increment_total_work();
  *(_DWORD *)(work_package_ptr + 340) = new_total_work;
  return new_total_work;
}
// 1E944: using guessed type int __fastcall sub_1E944(_DWORD, _DWORD, _DWORD);
// 657B8: using guessed type int dword_657B8;
// 66640: using guessed type char byte_66640;
// 66641: using guessed type char byte_66641;
// 70CE8: using guessed type char byte_70CE8;
// 70E6C: using guessed type int dword_70E6C;
// 2C0F0: using guessed type unsigned int var_810[516];

//----- (0002C214) --------------------------------------------------------
int initialize_work()
{
  int work_ptr; // r4
  char error_msg[2056]; // [sp+8h] [bp-808h] BYREF

  work_ptr = allocate_and_log_on_fail(1, 448, "cgminer.c", "make_work", 2307);
  if ( !work_ptr )
  {
    strcpy(error_msg, "Failed to calloc work in make_work");
    log_event(3, error_msg, 1);
    shutdown_miner(1, 1);
  }
  *(_DWORD *)(work_ptr + 340) = increment_total_work();
  return work_ptr;
}
// 1E7D4: using guessed type int __fastcall sub_1E7D4(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 2AB30: using guessed type void __fastcall __noreturn sub_2AB30(_DWORD, _DWORD);
// 2C040: using guessed type int sub_2C040(void);

//----- (0002C2AC) --------------------------------------------------------
unsigned int *__fastcall init_and_copy_work_details(int work_source, int work_size)
{
  unsigned int *new_work_pointer; // r4

  new_work_pointer = (unsigned int *)initialize_work();
  copy_work_details(new_work_pointer, work_source, work_size);
  return new_work_pointer;
}

//----- (0002C2D4) --------------------------------------------------------
int __fastcall initialize_and_update_work(int work_details_src)
{
  int work_ptr; // r4
  int retry_count; // r3
  int updated_work_ptr; // r0

  work_ptr = initialize_work();
  copy_work_details((unsigned int *)work_ptr, work_details_src, 0);
  *(_BYTE *)(work_ptr + 273) = 1;
  get_hardware_timestamp((__time_t *)(work_ptr + 416));
  retry_count = *(_DWORD *)(work_ptr + 264);
  *(_BYTE *)(work_ptr + 280) = 0;
  updated_work_ptr = work_ptr;
  *(_BYTE *)(work_ptr + 282) = 0;
  *(_DWORD *)(work_ptr + 264) = retry_count - 1;
  return updated_work_ptr;
}

//----- (0002C320) --------------------------------------------------------
int __fastcall add_queued(pthread_rwlock_t *rwlock, int value)
{
  pthread_rwlock_t *write_lock; // r4

  write_lock = rwlock + 10;
  if ( pthread_rwlock_wrlock(rwlock + 10) )
    log_write_lock_error("add_queued", 9495);
  update_statistics(rwlock, value);
  if ( pthread_rwlock_unlock(write_lock) )
    log_rwlock_error_and_exit("add_queued", 9497);
  return off_658DC(0);
}
// 2A4B4: using guessed type int __fastcall sub_2A4B4(_DWORD, _DWORD);
// 2B404: using guessed type void __fastcall __noreturn sub_2B404(_DWORD, _DWORD);
// 2BFAC: using guessed type void __fastcall __noreturn sub_2BFAC(_DWORD, _DWORD);
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);

//----- (0002C38C) --------------------------------------------------------
int __fastcall update_work_stats(pthread_rwlock_t *lock, int completion_status)
{
  pthread_rwlock_t *work_lock; // r4
  int status_ref; // [sp+4h] [bp-14h] BYREF

  work_lock = lock + 10;
  status_ref = completion_status;
  if ( pthread_rwlock_wrlock(lock + 10) )
    log_write_lock_error("work_completed", 9647);
  update_hash_table(lock, status_ref);
  if ( pthread_rwlock_unlock(work_lock) )
    log_rwlock_error_and_exit("work_completed", 9649);
  off_658DC(0);
  return clear_miner_data_if_not_null(&status_ref, "cgminer.c", "work_completed", 9651);
}
// 1DA28: using guessed type int sub_1DA28(void);
// 28FFC: using guessed type int __fastcall sub_28FFC(_DWORD, _DWORD, _DWORD, _DWORD);
// 2A9A8: using guessed type int __fastcall sub_2A9A8(_DWORD, _DWORD);
// 2B404: using guessed type void __fastcall __noreturn sub_2B404(_DWORD, _DWORD);
// 2BFAC: using guessed type void __fastcall __noreturn sub_2BFAC(_DWORD, _DWORD);
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);

//----- (0002C418) --------------------------------------------------------
int __fastcall take_queued_work_by_midstate(
        pthread_rwlock_t *rwlock,
        void *arg2,
        size_t arg3,
        int arg4,
        int arg5,
        size_t arg6)
{
  pthread_rwlock_t *lock_ptr; // r5
  int v11; // r6

  lock_ptr = rwlock + 10;
  if ( pthread_rwlock_wrlock(rwlock + 10) )
    log_write_lock_error("take_queued_work_bymidstate", 9660);
  v11 = find_matching_entry(rwlock[11].__lock, arg2, arg3, arg4, arg5, arg6);
  if ( v11 )
    update_hash_table(rwlock, v11);
  if ( pthread_rwlock_unlock(lock_ptr) )
    log_rwlock_error_and_exit("take_queued_work_bymidstate", 9664);
  off_658DC(0);
  return v11;
}
// 1DA28: using guessed type int sub_1DA28(void);
// 2A9A8: using guessed type int __fastcall sub_2A9A8(_DWORD, _DWORD);
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);

//----- (0002C4C4) --------------------------------------------------------
int __fastcall update_queued_work(pthread_rwlock_t *rwlock, int param1, int param2, int param3)
{
  int current_lock; // r1
  int current_item; // r4
  int root_lock; // [sp+4h] [bp-34h]
  char work_item_data[48]; // [sp+8h] [bp-30h] BYREF

  get_hardware_timestamp(work_item_data, param1, param2, param3);
  if ( pthread_rwlock_wrlock(rwlock + 10) )
    log_write_lock_error("age_queued_work", 9626);
  root_lock = rwlock[11].__lock;
  current_lock = root_lock;
  if ( root_lock )
  {
    for ( current_item = *(_DWORD *)(root_lock + 352); ; current_item = *(_DWORD *)(current_item + 352) )
    {
      sub_1F8EC(work_item_data, current_lock + 424);
      if ( !current_item )
        break;
      current_lock = current_item;
    }
  }
  if ( pthread_rwlock_unlock(rwlock + 10) )
    log_rwlock_error_and_exit("age_queued_work", 9637);
  off_658DC(0);
  return 0;
}
// 1DA28: using guessed type int sub_1DA28(void);
// 1F5C4: using guessed type int __fastcall sub_1F5C4(_DWORD, _DWORD, _DWORD, _DWORD);
// 1F8EC: using guessed type int __fastcall sub_1F8EC(_DWORD, _DWORD);
// 28FFC: using guessed type int __fastcall sub_28FFC(_DWORD, _DWORD, _DWORD, _DWORD);
// 2A9A8: using guessed type int __fastcall sub_2A9A8(_DWORD, _DWORD);
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);

//----- (0002C5C0) --------------------------------------------------------
void __fastcall __noreturn log_rdlock_error(const char *function_name, int line_number)
{
  int *errno_location; // r0
  char error_message[2056]; // [sp+10h] [bp-808h] BYREF

  errno_location = _errno_location();
  snprintf(
    error_message,
    2048u,
    "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
    *errno_location,
    "cgminer.c",
    function_name,
    line_number);
  log_event(3, error_message, 1);
  shutdown_miner(1, 1);
}
// 2AB30: using guessed type void __fastcall __noreturn sub_2AB30(_DWORD, _DWORD);

//----- (0002C61C) --------------------------------------------------------
unsigned int *__fastcall clone_queued_work_by_id(pthread_rwlock_t *rwlock, int work_id_to_find)
{
  pthread_rwlock_t *work_queue_rwlock; // r7
  unsigned int *current_work; // r4
  int next_work; // r5

  work_queue_rwlock = rwlock + 10;
  if ( pthread_rwlock_rdlock(rwlock + 10) )
    log_rdlock_error("clone_queued_work_byid", 9600);
  current_work = (unsigned int *)rwlock[11].__lock;
  if ( current_work )
  {
    next_work = current_work[88];
    if ( work_id_to_find == current_work[85] )
    {
      next_work = (int)current_work;
    }
    else
    {
      if ( !next_work )
      {
        current_work = 0;
        goto LABEL_10;
      }
      current_work = *(unsigned int **)(next_work + 352);
      while ( work_id_to_find != *(_DWORD *)(next_work + 340) )
      {
        if ( !current_work )
          goto LABEL_10;
        next_work = (int)current_work;
        current_work = (unsigned int *)current_work[88];
      }
    }
    current_work = (unsigned int *)initialize_work();
    copy_work_details(current_work, next_work, 0);
  }
LABEL_10:
  if ( pthread_rwlock_unlock(work_queue_rwlock) )
    log_rwlock_error_and_exit("clone_queued_work_byid", 9604);
  off_658DC(0);
  return current_work;
}
// 1DA28: using guessed type int sub_1DA28(void);
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);

//----- (0002C6E8) --------------------------------------------------------
unsigned int *__fastcall sub_2C6E8(pthread_rwlock_t *a1, void *a2, size_t a3, int a4, int a5, size_t a6)
{
  pthread_rwlock_t *v6; // r4
  int v11; // r5
  unsigned int *v12; // r6

  v6 = a1 + 10;
  if ( pthread_rwlock_rdlock(a1 + 10) )
    log_rdlock_error("clone_queued_work_bymidstate", 9553);
  v11 = find_matching_entry(a1[11].__lock, a2, a3, a4, a5, a6);
  if ( v11 )
  {
    v12 = (unsigned int *)initialize_work();
    copy_work_details(v12, v11, 0);
  }
  else
  {
    v12 = 0;
  }
  if ( pthread_rwlock_unlock(v6) )
    log_rwlock_error_and_exit("clone_queued_work_bymidstate", 9557);
  off_658DC(0);
  return v12;
}
// 1DA28: using guessed type int sub_1DA28(void);
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);

//----- (0002C7A4) --------------------------------------------------------
int __fastcall find_queued_work_by_id(pthread_rwlock_t *rwlock_ptr, int work_id)
{
  pthread_rwlock_t *queue_lock; // r6
  int current_work_ptr; // r4
  int next_work_ptr; // r3

  queue_lock = rwlock_ptr + 10;
  if ( pthread_rwlock_rdlock(rwlock_ptr + 10) )
    log_rdlock_error("find_queued_work_byid", 9588);
  current_work_ptr = rwlock_ptr[11].__lock;
  if ( current_work_ptr )
  {
    next_work_ptr = *(_DWORD *)(current_work_ptr + 352);
    if ( work_id != *(_DWORD *)(current_work_ptr + 340) )
    {
      if ( next_work_ptr )
      {
        current_work_ptr = *(_DWORD *)(next_work_ptr + 352);
        while ( work_id != *(_DWORD *)(next_work_ptr + 340) )
        {
          if ( !current_work_ptr )
            goto LABEL_10;
          next_work_ptr = current_work_ptr;
          current_work_ptr = *(_DWORD *)(current_work_ptr + 352);
        }
      }
      current_work_ptr = next_work_ptr;
    }
  }
LABEL_10:
  if ( pthread_rwlock_unlock(queue_lock) )
    log_rwlock_error_and_exit("find_queued_work_byid", 9590);
  off_658DC(0);
  return current_work_ptr;
}
// 1DA28: using guessed type int sub_1DA28(void);
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);

//----- (0002C858) --------------------------------------------------------
int __fastcall find_queued_work_by_midstate(
        pthread_rwlock_t *lock_ptr,
        void *work_data,
        size_t data_length,
        int param_4,
        int param_5,
        size_t param_6)
{
  pthread_rwlock_t *extended_lock_ptr; // r4
  int work_found; // r5

  extended_lock_ptr = lock_ptr + 10;
  if ( pthread_rwlock_rdlock(lock_ptr + 10) )
    log_rdlock_error("find_queued_work_bymidstate", 9541);
  work_found = find_matching_entry(lock_ptr[11].__lock, work_data, data_length, param_4, param_5, param_6);
  if ( pthread_rwlock_unlock(extended_lock_ptr) )
    log_rwlock_error_and_exit("find_queued_work_bymidstate", 9543);
  off_658DC(0);
  return work_found;
}
// 1DA28: using guessed type int sub_1DA28(void);
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);

//----- (0002C8F4) --------------------------------------------------------
int __fastcall get_device_by_index(int device_index)
{
  int device_ptr; // r4

  if ( pthread_rwlock_rdlock(&stru_72F18) )
    log_rdlock_error("get_devices", 634);
  device_ptr = *(_DWORD *)(dword_72EC0 + 4 * device_index);
  if ( pthread_rwlock_unlock(&stru_72F18) )
    log_rwlock_error_and_exit("get_devices", 636);
  off_658DC(0);
  return device_ptr;
}
// 1DA28: using guessed type int sub_1DA28(void);
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);
// 72EC0: using guessed type int dword_72EC0;
// 72F18: using guessed type pthread_rwlock_t stru_72F18;

//----- (0002C968) --------------------------------------------------------
int display_system_summary()
{
  int time_diff_seconds; // r12
  int calculation_offset; // r2
  double start_time; // d9
  int runtime_hours; // r8
  int runtime_seconds; // r6
  int runtime_minutes; // r10
  double utility_rate; // d10
  double work_utility; // d8
  double average_hashrate; // d7
  int accepted_shares; // r6
  int rejected_shares; // r8
  double reject_ratio; // d9
  double total_shares; // r0
  int pool_index; // r8
  int pool_stat_address; // r6
  int solved_blocks; // r3
  const char *plural_suffix; // r1
  __int64 adjusted_accepted; // r10
  double adjusted_rejected_ratio; // d8
  double total_adjusted_shares; // r0
  int device_index; // r5
  int device_stat_address; // r0
  int requested_shares; // r1
  int is_error_flag_set; // r3
  double accepted_difficulty_shares; // d7
  int adjusted_rejected_shares; // [sp+14h] [bp-954h]
  char device_stats_buffer[256]; // [sp+28h] [bp-940h] BYREF
  char output_buffer[2112]; // [sp+128h] [bp-840h] BYREF

  time_diff_seconds = dword_66A88 - dword_66A90;
  LOWORD(calculation_offset) = -30583;
  if ( dword_66A8C - dword_66A94 < 0 )
    --time_diff_seconds;
  HIWORD(calculation_offset) = -30584;
  start_time = *(double *)&dword_66120;
  runtime_hours = time_diff_seconds / 3600;
  runtime_seconds = time_diff_seconds
                  - 60
                  * (((int)(time_diff_seconds
                          + ((unsigned __int64)(time_diff_seconds * (__int64)calculation_offset) >> 32)) >> 5)
                   - (time_diff_seconds >> 31));
  runtime_minutes = ((int)(time_diff_seconds % 3600
                         + ((unsigned __int64)(time_diff_seconds % 3600 * (__int64)calculation_offset) >> 32)) >> 5)
                  - ((time_diff_seconds % 3600) >> 31);
  utility_rate = convert_float_to_int(qword_70E48) / start_time * 60.0;
  work_utility = convert_float_to_int(qword_70D20) / start_time * 60.0;
  if ( !byte_70CE8 && !byte_66640 && dword_657B8 <= 3
    || (strcpy(output_buffer, "\nSummary of runtime statistics:\n"), log_event(4, output_buffer, 0), !byte_70CE8)
    && !byte_66640
    && dword_657B8 <= 3 )
  {
    if ( dword_70DB8 == 1 )
      goto LABEL_156;
LABEL_8:
    if ( byte_70CE8 || byte_66640 )
      goto LABEL_10;
    goto LABEL_137;
  }
  snprintf(output_buffer, 2048u, "Started at %s", byte_66A98);
  log_event(4, output_buffer, 0);
  if ( dword_70DB8 != 1 )
    goto LABEL_8;
  if ( byte_70CE8 || byte_66640 )
    goto LABEL_157;
LABEL_156:
  if ( dword_657B8 > 3 )
  {
LABEL_157:
    snprintf(output_buffer, 2048u, "Pool: %s", *(const char **)(*(_DWORD *)dword_70E5C + 164));
    log_event(4, output_buffer, 0);
    goto LABEL_8;
  }
LABEL_137:
  if ( dword_657B8 <= 3 )
  {
    average_hashrate = unk_70CE0 / *(double *)&dword_66120;
    goto LABEL_139;
  }
LABEL_10:
  snprintf(output_buffer, 2048u, "Runtime: %d hrs : %d mins : %d secs", runtime_hours, runtime_minutes, runtime_seconds);
  log_event(4, output_buffer, 0);
  average_hashrate = unk_70CE0 / *(double *)&dword_66120;
  if ( byte_70CE8 || byte_66640 )
  {
LABEL_12:
    snprintf(output_buffer, 2048u, "Average hashrate: %.1f Mhash/s", average_hashrate);
    log_event(4, output_buffer, 0);
    if ( byte_70CE8 || byte_66640 )
      goto LABEL_14;
    goto LABEL_189;
  }
LABEL_139:
  if ( dword_657B8 > 3 )
    goto LABEL_12;
LABEL_189:
  if ( dword_657B8 <= 3 )
    goto LABEL_190;
LABEL_14:
  snprintf(output_buffer, 2048u, "Solved blocks: %d", dword_73FCC);
  log_event(4, output_buffer, 0);
  if ( !byte_70CE8 && !byte_66640 )
  {
LABEL_190:
    if ( dword_657B8 <= 3 )
      goto LABEL_158;
  }
  snprintf(output_buffer, 2048u, "Best share difficulty: %s", dword_66128);
  log_event(4, output_buffer, 0);
  if ( byte_70CE8 || byte_66640 )
  {
LABEL_18:
    snprintf(output_buffer, 2048u, "Share submissions: %lld", qword_70E48 + qword_72F10);
    log_event(4, output_buffer, 0);
    if ( byte_70CE8 || byte_66640 )
      goto LABEL_20;
    goto LABEL_159;
  }
LABEL_158:
  if ( dword_657B8 > 3 )
    goto LABEL_18;
LABEL_159:
  if ( dword_657B8 <= 3 )
    goto LABEL_160;
LABEL_20:
  snprintf(output_buffer, 2048u, "Accepted shares: %lld", qword_70E48);
  log_event(4, output_buffer, 0);
  if ( !byte_70CE8 && !byte_66640 )
  {
LABEL_160:
    if ( dword_657B8 <= 3 )
      goto LABEL_161;
  }
  snprintf(output_buffer, 2048u, "Rejected shares: %lld", qword_72F10);
  log_event(4, output_buffer, 0);
  if ( byte_70CE8 || byte_66640 )
  {
LABEL_24:
    snprintf(output_buffer, 2048u, "Accepted difficulty shares: %1.f", dbl_72E80);
    log_event(4, output_buffer, 0);
    if ( byte_70CE8 || byte_66640 )
      goto LABEL_26;
    goto LABEL_162;
  }
LABEL_161:
  if ( dword_657B8 > 3 )
    goto LABEL_24;
LABEL_162:
  if ( dword_657B8 <= 3 )
  {
    accepted_shares = qword_70E48;
    if ( qword_70E48 )
      goto LABEL_164;
    goto LABEL_54;
  }
LABEL_26:
  snprintf(output_buffer, 2048u, "Rejected difficulty shares: %1.f", dbl_72F08);
  log_event(4, output_buffer, 0);
  accepted_shares = qword_70E48;
  if ( qword_70E48 )
  {
    if ( !byte_70CE8 )
      goto LABEL_28;
LABEL_29:
    rejected_shares = qword_72F10;
    reject_ratio = convert_float_to_int(100 * (int)qword_72F10);
    total_shares = convert_float_to_int(rejected_shares + accepted_shares);
    snprintf(output_buffer, 2048u, "Reject ratio: %.1f%%", reject_ratio / total_shares);
    log_event(4, output_buffer, 0);
LABEL_30:
    if ( byte_70CE8 || byte_66640 )
      goto LABEL_32;
    goto LABEL_145;
  }
LABEL_54:
  if ( !qword_72F10 )
    goto LABEL_30;
  accepted_shares = 0;
  if ( byte_70CE8 )
    goto LABEL_29;
LABEL_28:
  if ( byte_66640 )
    goto LABEL_29;
LABEL_164:
  if ( dword_657B8 > 3 )
    goto LABEL_29;
LABEL_145:
  if ( dword_657B8 <= 3 )
    goto LABEL_146;
LABEL_32:
  snprintf(output_buffer, 2048u, "Hardware errors: %d", dword_73FB8);
  log_event(4, output_buffer, 0);
  if ( !byte_70CE8 && !byte_66640 && dword_657B8 <= 3 )
  {
LABEL_146:
    if ( dword_657B8 <= 3 )
      goto LABEL_147;
    goto LABEL_36;
  }
  snprintf(output_buffer, 2048u, "Utility (accepted shares / min): %.2f/min", utility_rate);
  log_event(4, output_buffer, 0);
  if ( !byte_70CE8 && !byte_66640 && dword_657B8 <= 3 )
  {
LABEL_147:
    if ( dword_657B8 <= 3 )
      goto LABEL_148;
    goto LABEL_38;
  }
LABEL_36:
  snprintf(output_buffer, 2048u, "Work Utility (diff1 shares solved / min): %.2f/min\n", work_utility);
  log_event(4, output_buffer, 0);
  if ( !byte_70CE8 && !byte_66640 && dword_657B8 <= 3 )
  {
LABEL_148:
    if ( dword_657B8 <= 3 )
      goto LABEL_149;
    goto LABEL_40;
  }
LABEL_38:
  snprintf(output_buffer, 2048u, "Stale submissions discarded due to new blocks: %lld", *(_QWORD *)&qword_74220);
  log_event(4, output_buffer, 0);
  if ( !byte_70CE8 && !byte_66640 && dword_657B8 <= 3 )
  {
LABEL_149:
    if ( dword_657B8 <= 3 )
      goto LABEL_150;
    goto LABEL_42;
  }
LABEL_40:
  snprintf(output_buffer, 2048u, "Unable to get work from server occasions: %d", dword_70E60);
  log_event(4, output_buffer, 0);
  if ( !byte_70CE8 && !byte_66640 && dword_657B8 <= 3 )
  {
LABEL_150:
    if ( dword_657B8 <= 3 )
      goto LABEL_151;
    goto LABEL_44;
  }
LABEL_42:
  snprintf(output_buffer, 2048u, "Work items generated locally: %d", dword_70E6C);
  log_event(4, output_buffer, 0);
  if ( !byte_70CE8 && !byte_66640 && dword_657B8 <= 3 )
  {
LABEL_151:
    if ( dword_657B8 <= 3 )
      goto LABEL_152;
    goto LABEL_46;
  }
LABEL_44:
  snprintf(output_buffer, 2048u, "Submitting work remotely delay occasions: %d", dword_70D04);
  log_event(4, output_buffer, 0);
  if ( !byte_70CE8 && !byte_66640 && dword_657B8 <= 3 )
  {
LABEL_152:
    if ( dword_70DB8 <= 1 )
      goto LABEL_141;
    goto LABEL_47;
  }
LABEL_46:
  snprintf(output_buffer, 2048u, "New blocks detected on network: %d\n", dword_74130);
  log_event(4, output_buffer, 0);
  if ( dword_70DB8 > 1 )
  {
LABEL_47:
    pool_index = 0;
    while ( 1 )
    {
      pool_stat_address = *(_DWORD *)(dword_70E5C + 4 * pool_index);
      if ( byte_70CE8 || byte_66640 || dword_657B8 > 3 )
        break;
      solved_blocks = *(_DWORD *)(pool_stat_address + 32);
      if ( solved_blocks )
        goto LABEL_52;
LABEL_63:
      if ( !byte_66640 )
      {
LABEL_110:
        if ( dword_657B8 <= 3 )
          goto LABEL_111;
      }
LABEL_64:
      snprintf(
        output_buffer,
        2048u,
        " Share submissions: %lld",
        *(_QWORD *)(pool_stat_address + 8) + *(_QWORD *)(pool_stat_address + 16));
      log_event(4, output_buffer, 0);
      if ( byte_70CE8 || byte_66640 )
      {
LABEL_66:
        snprintf(output_buffer, 2048u, " Accepted shares: %lld", *(_QWORD *)(pool_stat_address + 8));
        log_event(4, output_buffer, 0);
        if ( byte_70CE8 || byte_66640 )
          goto LABEL_68;
        goto LABEL_112;
      }
LABEL_111:
      if ( dword_657B8 > 3 )
        goto LABEL_66;
LABEL_112:
      if ( dword_657B8 <= 3 )
        goto LABEL_113;
LABEL_68:
      snprintf(output_buffer, 2048u, " Rejected shares: %lld", *(_QWORD *)(pool_stat_address + 16));
      log_event(4, output_buffer, 0);
      if ( !byte_70CE8 && !byte_66640 )
      {
LABEL_113:
        if ( dword_657B8 <= 3 )
          goto LABEL_114;
      }
      snprintf(output_buffer, 2048u, " Accepted difficulty shares: %1.f", *(double *)(pool_stat_address + 72));
      log_event(4, output_buffer, 0);
      if ( byte_70CE8 || byte_66640 )
      {
LABEL_72:
        snprintf(output_buffer, 2048u, " Rejected difficulty shares: %1.f", *(double *)(pool_stat_address + 80));
        log_event(4, output_buffer, 0);
        adjusted_accepted = *(_QWORD *)(pool_stat_address + 8);
        if ( adjusted_accepted )
          goto LABEL_75;
        goto LABEL_73;
      }
LABEL_114:
      if ( dword_657B8 > 3 )
        goto LABEL_72;
      adjusted_accepted = *(_QWORD *)(pool_stat_address + 8);
      if ( adjusted_accepted )
      {
        if ( dword_657B8 <= 3 )
          goto LABEL_117;
        goto LABEL_77;
      }
LABEL_73:
      if ( *(_QWORD *)(pool_stat_address + 16) )
      {
        LODWORD(adjusted_accepted) = 0;
LABEL_75:
        if ( !byte_70CE8 && !byte_66640 && dword_657B8 <= 3 )
        {
LABEL_117:
          if ( dword_657B8 <= 3 )
            goto LABEL_118;
          goto LABEL_80;
        }
LABEL_77:
        adjusted_rejected_shares = *(_DWORD *)(pool_stat_address + 16);
        adjusted_rejected_ratio = convert_float_to_int(100 * adjusted_rejected_shares);
        total_adjusted_shares = convert_float_to_int(adjusted_rejected_shares + (int)adjusted_accepted);
        snprintf(output_buffer, 2048u, " Reject ratio: %.1f%%", adjusted_rejected_ratio / total_adjusted_shares);
        log_event(4, output_buffer, 0);
      }
      if ( !byte_70CE8 && !byte_66640 )
        goto LABEL_117;
LABEL_80:
      snprintf(output_buffer, 2048u, " Items worked on: %d", *(_DWORD *)(pool_stat_address + 68));
      log_event(4, output_buffer, 0);
      if ( byte_70CE8 || byte_66640 )
      {
LABEL_82:
        snprintf(
          output_buffer,
          2048u,
          " Stale submissions discarded due to new blocks: %d",
          *(_DWORD *)(pool_stat_address + 120));
        log_event(4, output_buffer, 0);
        if ( byte_70CE8 || byte_66640 )
          goto LABEL_84;
        goto LABEL_119;
      }
LABEL_118:
      if ( dword_657B8 > 3 )
        goto LABEL_82;
LABEL_119:
      if ( dword_657B8 <= 3 )
        goto LABEL_120;
LABEL_84:
      snprintf(
        output_buffer,
        2048u,
        " Unable to get work from server occasions: %d",
        *(_DWORD *)(pool_stat_address + 128));
      log_event(4, output_buffer, 0);
      if ( !byte_70CE8 && !byte_66640 )
      {
LABEL_120:
        if ( dword_657B8 <= 3 )
          goto LABEL_87;
      }
      snprintf(
        output_buffer,
        2048u,
        " Submitting work remotely delay occasions: %d\n",
        *(_DWORD *)(pool_stat_address + 132));
      log_event(4, output_buffer, 0);
LABEL_87:
      if ( dword_70DB8 <= ++pool_index )
        goto LABEL_88;
    }
    snprintf(output_buffer, 2048u, "Pool: %s", *(const char **)(pool_stat_address + 164));
    log_event(4, output_buffer, 0);
    solved_blocks = *(_DWORD *)(pool_stat_address + 32);
    if ( solved_blocks )
    {
      if ( !byte_70CE8 && !byte_66640 )
      {
LABEL_52:
        if ( dword_657B8 <= 3 )
          goto LABEL_110;
      }
      plural_suffix = "S";
      if ( solved_blocks <= 1 )
        plural_suffix = "";
      snprintf(output_buffer, 2048u, "SOLVED %d BLOCK%s!", solved_blocks, plural_suffix);
      log_event(4, output_buffer, 0);
    }
    if ( byte_70CE8 )
      goto LABEL_64;
    goto LABEL_63;
  }
LABEL_88:
  if ( byte_70CE8 || byte_66640 )
    goto LABEL_90;
LABEL_141:
  if ( dword_657B8 > 3 )
  {
LABEL_90:
    strcpy(output_buffer, "Summary of per device statistics:\n");
    log_event(4, output_buffer, 0);
  }
  if ( dword_72F38 > 0 )
  {
    device_index = 0;
    do
    {
      device_stat_address = get_device_by_index(device_index++);
      *(_DWORD *)(*(_DWORD *)(device_stat_address + 4) + 20) = nullsub_1;
      *(_DWORD *)(*(_DWORD *)(device_stat_address + 4) + 24) = nullsub_2;
      format_miner_stats(device_stats_buffer, 255, device_stat_address);
      if ( byte_70CE8 || byte_66640 || dword_657B8 > 3 )
      {
        snprintf(output_buffer, 2048u, "%s", device_stats_buffer);
        log_event(4, output_buffer, 0);
      }
    }
    while ( dword_72F38 > device_index );
  }
  requested_shares = dword_66AC0;
  is_error_flag_set = (unsigned __int8)byte_70CE8;
  if ( dword_66AC0 )
  {
    accepted_difficulty_shares = dbl_72E80;
    if ( !byte_70CE8 && !byte_66640 && dword_657B8 <= 3 )
    {
      if ( (double)dword_66AC0 <= dbl_72E80 )
        goto LABEL_143;
      goto LABEL_103;
    }
    snprintf(output_buffer, 2048u, "Mined %.0f accepted shares of %d requested\n", dbl_72E80, dword_66AC0);
    log_event(4, output_buffer, 0);
    accepted_difficulty_shares = dbl_72E80;
    requested_shares = dword_66AC0;
    is_error_flag_set = (unsigned __int8)byte_70CE8;
    if ( (double)dword_66AC0 > dbl_72E80 )
    {
      if ( byte_70CE8 )
      {
LABEL_105:
        snprintf(
          output_buffer,
          2048u,
          "WARNING - Mined only %.0f shares of %d requested.",
          accepted_difficulty_shares,
          requested_shares);
        log_event(4, output_buffer, 0);
        is_error_flag_set = (unsigned __int8)byte_70CE8;
        goto LABEL_106;
      }
LABEL_103:
      if ( !byte_66640 && dword_657B8 <= 3 )
      {
LABEL_143:
        if ( dword_657B8 <= 3 )
          goto LABEL_109;
        goto LABEL_108;
      }
      goto LABEL_105;
    }
  }
LABEL_106:
  if ( !is_error_flag_set && !byte_66640 )
    goto LABEL_143;
LABEL_108:
  strcpy(output_buffer, " ");
  log_event(4, output_buffer, 0);
LABEL_109:
  fflush((FILE *)stderr);
  return fflush((FILE *)stdout);
}
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 26D30: using guessed type int nullsub_1();
// 289D4: using guessed type int nullsub_2();
// 2AC50: using guessed type int __fastcall sub_2AC50(_DWORD, _DWORD, _DWORD);
// 2C8F4: using guessed type int __fastcall sub_2C8F4(_DWORD);
// 4930C: using guessed type double __fastcall sub_4930C(_DWORD);
// 657B8: using guessed type int dword_657B8;
// 66120: using guessed type int dword_66120;
// 664F4: using guessed type int stdout;
// 664F8: using guessed type int stderr;
// 66640: using guessed type char byte_66640;
// 66A88: using guessed type int dword_66A88;
// 66A8C: using guessed type int dword_66A8C;
// 66A90: using guessed type int dword_66A90;
// 66A94: using guessed type int dword_66A94;
// 66AC0: using guessed type int dword_66AC0;
// 70CE8: using guessed type char byte_70CE8;
// 70D04: using guessed type int dword_70D04;
// 70D20: using guessed type int dword_70D20;
// 70DB8: using guessed type int dword_70DB8;
// 70E48: using guessed type __int64 qword_70E48;
// 70E5C: using guessed type int dword_70E5C;
// 70E60: using guessed type int dword_70E60;
// 70E6C: using guessed type int dword_70E6C;
// 72E80: using guessed type double dbl_72E80;
// 72F08: using guessed type double dbl_72F08;
// 72F10: using guessed type __int64 qword_72F10;
// 72F38: using guessed type int dword_72F38;
// 73FB8: using guessed type int dword_73FB8;
// 73FCC: using guessed type int dword_73FCC;
// 74130: using guessed type int dword_74130;
// 74220: using guessed type int dword_74220;

//----- (0002DD24) --------------------------------------------------------
int __fastcall update_and_log_system_info(int force_display)
{
  int error_number; // r5
  char *error_string; // r0
  int update_result; // r0
  struct sysinfo system_info; // [sp+8h] [bp-850h] BYREF
  char error_message[2064]; // [sp+48h] [bp-810h] BYREF

  if ( !sysinfo(&system_info) )
  {
    dword_7412C = system_info.uptime;
    update_result = get_hardware_timestamp(&dword_66A88);
    if ( force_display )
      return update_result;
    goto LABEL_8;
  }
  if ( byte_70CE8 || byte_66640 || dword_657B8 > 5 )
  {
    error_number = *_errno_location();
    error_string = strerror(error_number);
    snprintf(error_message, 2048u, "Failed to get sysinfo, errno:%u, reason:%s\n", error_number, error_string);
    log_event(6, error_message, 0);
  }
  dword_7412C = time(0);
  update_result = get_hardware_timestamp(&dword_66A88);
  if ( !force_display )
  {
LABEL_8:
    if ( !byte_74128 )
    {
      if ( byte_66642 )
        return display_system_summary();
    }
  }
  return update_result;
}
// 657B8: using guessed type int dword_657B8;
// 66640: using guessed type char byte_66640;
// 66642: using guessed type char byte_66642;
// 66A88: using guessed type int dword_66A88;
// 70CE8: using guessed type char byte_70CE8;
// 74128: using guessed type char byte_74128;
// 7412C: using guessed type int dword_7412C;

//----- (0002DE4C) --------------------------------------------------------
int restart_application()
{
  int restart_status; // r0
  char log_message[2064]; // [sp+0h] [bp-810h] BYREF

  if ( byte_70CE8 || byte_66640 || dword_657B8 > 3 )
  {
    snprintf(log_message, 2048u, "Attempting to restart %s", s);
    log_event(4, log_message, 0);
  }
  init_completion_timeout_thread(check_miner_status);
  update_and_log_system_info(1);
  if ( dword_66A6C > 0 )
  {
    kill(dword_66A6C, 15);
    dword_66A6C = 0;
  }
  restart_status = execv(*(const char **)dword_66AC4, (char *const *)dword_66AC4);
  if ( byte_70CE8 || byte_66640 || dword_657B8 > 3 )
  {
    strcpy(log_message, "Failed to restart application");
    return log_event(4, log_message, 0);
  }
  return restart_status;
}
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 22140: using guessed type int __fastcall sub_22140(_DWORD);
// 2DD24: using guessed type int __fastcall sub_2DD24(_DWORD);
// 2E354: using guessed type int sub_2E354();
// 657B8: using guessed type int dword_657B8;
// 66640: using guessed type char byte_66640;
// 66A6C: using guessed type int dword_66A6C;
// 66AC4: using guessed type int dword_66AC4;
// 70CE8: using guessed type char byte_70CE8;

//----- (0002DF8C) --------------------------------------------------------
int __fastcall get_thread_metadata(int thread_id)
{
  int thread_metadata; // r4

  if ( pthread_rwlock_rdlock(&stru_72EE8) )
    log_rdlock_error("get_thread", 614);
  thread_metadata = *(_DWORD *)(dword_71E78 + 4 * thread_id);
  if ( pthread_rwlock_unlock(&stru_72EE8) )
    log_rwlock_error_and_exit("get_thread", 616);
  off_658DC(0);
  return thread_metadata;
}
// 1DA28: using guessed type int sub_1DA28(void);
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);
// 71E78: using guessed type int dword_71E78;
// 72EE8: using guessed type pthread_rwlock_t stru_72EE8;

//----- (0002E000) --------------------------------------------------------
int __fastcall get_thread_priority(int thread_id)
{
  return *(_DWORD *)(*(_DWORD *)(get_thread_metadata(thread_id) + 36) + 8);
}

//----- (0002E014) --------------------------------------------------------
int check_and_shutdown_threads()
{
  int current_thread_index; // r4
  int thread_index; // r0
  int thread_data_ptr; // r0
  int thread_shutdown_flag_ptr; // r3
  char log_message[2080]; // [sp+0h] [bp-820h] BYREF

  if ( !byte_70CE8 && !byte_66640 && dword_657B8 <= 5 )
  {
    if ( !byte_66641 )
      goto LABEL_7;
    goto LABEL_28;
  }
  strcpy(log_message, "Received kill message");
  log_event(6, log_message, 1);
  if ( byte_66641 )
  {
    if ( byte_70CE8 || byte_66640 )
    {
LABEL_6:
      strcpy(log_message, "Killing off watchpool thread");
      log_event(7, log_message, 1);
      goto LABEL_7;
    }
LABEL_28:
    if ( dword_657B8 <= 6 )
      goto LABEL_7;
    goto LABEL_6;
  }
LABEL_7:
  init_completion_timeout_thread(cancel_and_destroy_thread);
  if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
  {
    strcpy(log_message, "Killing off watchdog thread");
    log_event(7, log_message, 1);
  }
  init_completion_timeout_thread(cancel_and_destroy_thread);
  if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
  {
    strcpy(log_message, "Shutting down mining threads");
    log_event(7, log_message, 1);
  }
  if ( dword_74180 > 0 )
  {
    current_thread_index = 0;
    do
    {
      thread_index = current_thread_index++;
      thread_data_ptr = get_thread_metadata(thread_index);
      if ( thread_data_ptr )
      {
        thread_shutdown_flag_ptr = *(_DWORD *)(thread_data_ptr + 36);
        if ( thread_shutdown_flag_ptr )
          *(_BYTE *)(thread_shutdown_flag_ptr + 364) = 1;
      }
    }
    while ( current_thread_index < dword_74180 );
  }
  sleep(1u);
  init_completion_timeout_thread(shutdown_mining_threads);
  if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
  {
    strcpy(log_message, "Killing off API thread");
    log_event(7, log_message, 1);
  }
  return init_completion_timeout_thread(cancel_and_destroy_thread);
}
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 1F1A8: using guessed type int sub_1F1A8();
// 22140: using guessed type int __fastcall sub_22140(_DWORD);
// 2DF8C: using guessed type int __fastcall sub_2DF8C(_DWORD);
// 2E36C: using guessed type int sub_2E36C();
// 657B8: using guessed type int dword_657B8;
// 66640: using guessed type char byte_66640;
// 66641: using guessed type char byte_66641;
// 66AC8: using guessed type int dword_66AC8;
// 70CE8: using guessed type char byte_70CE8;
// 70D18: using guessed type int dword_70D18;
// 74180: using guessed type int dword_74180;

//----- (0002E354) --------------------------------------------------------
int check_miner_status()
{
  int status; // r0

  if ( byte_66642 )
    return check_and_shutdown_threads();
  return status;
}
// 66642: using guessed type char byte_66642;

//----- (0002E36C) --------------------------------------------------------
void shutdown_mining_threads()
{
  int thread_index; // r4
  int miner_status; // r0
  int status_ptr; // r5
  pthread_t thread_id; // r0
  char log_msg[2064]; // [sp+0h] [bp-810h] BYREF

  if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
  {
    strcpy(log_msg, "Killing off mining threads");
    log_event(7, log_msg, 1);
  }
  if ( dword_74180 > 0 )
  {
    for ( thread_index = 0; dword_74180 > thread_index; ++thread_index )
    {
      while ( 1 )
      {
        miner_status = get_thread_metadata(thread_index);
        status_ptr = miner_status;
        if ( miner_status )
        {
          if ( *(_DWORD *)(miner_status + 12) )
            break;
        }
        cancel_and_destroy_thread();
LABEL_8:
        if ( dword_74180 <= ++thread_index )
          return;
      }
      cancel_and_destroy_thread();
      thread_id = *(_DWORD *)(status_ptr + 12);
      if ( !thread_id )
        goto LABEL_8;
      pthread_join(thread_id, 0);
    }
  }
}
// 1F1A8: using guessed type int sub_1F1A8(void);
// 2DF8C: using guessed type int __fastcall sub_2DF8C(_DWORD);
// 657B8: using guessed type int dword_657B8;
// 66640: using guessed type char byte_66640;
// 66641: using guessed type char byte_66641;
// 70CE8: using guessed type char byte_70CE8;
// 74180: using guessed type int dword_74180;

//----- (0002E47C) --------------------------------------------------------
int get_current_pool_index()
{
  int current_pool_index; // r4

  if ( pthread_mutex_lock(&stru_740A0) )
    log_mutex_error_and_exit("current_pool", 843);
  if ( pthread_rwlock_rdlock(&rwlock) )
    log_rdlock_error("current_pool", 843);
  if ( pthread_mutex_unlock(&stru_740A0) )
    log_mutex_unlock_error("current_pool", 843);
  current_pool_index = dword_66AD4;
  if ( pthread_rwlock_unlock(&rwlock) )
    log_rwlock_error_and_exit("current_pool", 847);
  off_658DC(0);
  return current_pool_index;
}
// 1DA28: using guessed type int sub_1DA28(void);
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);
// 66AD4: using guessed type int dword_66AD4;
// 740A0: using guessed type pthread_mutex_t stru_740A0;

//----- (0002E524) --------------------------------------------------------
int __fastcall increment_work_statistics(int miner_data_ptr, int specific_worker_ptr, int work_increment)
{
  int worker_info_ptr; // r1
  unsigned int prev_work_done_low; // r2
  unsigned int prev_work_done_high; // r12
  int new_total_work; // r0
  int worker_info_ptr_copy; // r4
  int default_worker_ptr; // r0

  if ( pthread_mutex_lock(&stru_70CEC) )
    log_mutex_error_and_exit("inc_work_stats", 8895);
  worker_info_ptr = *(_DWORD *)(miner_data_ptr + 36);
  prev_work_done_low = *(_DWORD *)(worker_info_ptr + 192);
  prev_work_done_high = *(_DWORD *)(worker_info_ptr + 196);
  new_total_work = qword_70D20 + work_increment;
  qword_70D20 += work_increment;
  *(_QWORD *)(worker_info_ptr + 192) = __PAIR64__(prev_work_done_high, prev_work_done_low) + work_increment;
  if ( specific_worker_ptr )
  {
    *(_QWORD *)(specific_worker_ptr + 40) += work_increment;
  }
  else
  {
    default_worker_ptr = get_current_pool_index(new_total_work);
    *(_QWORD *)(default_worker_ptr + 40) += work_increment;
  }
  worker_info_ptr_copy = *(_DWORD *)(miner_data_ptr + 36);
  *(_DWORD *)(worker_info_ptr_copy + 232) = time(0);
  if ( pthread_mutex_unlock(&stru_70CEC) )
    log_mutex_unlock_error("inc_work_stats", 8909);
  return off_658DC(0);
}
// 2B460: using guessed type void __fastcall __noreturn sub_2B460(_DWORD, _DWORD);
// 2B4BC: using guessed type void __fastcall __noreturn sub_2B4BC(_DWORD, _DWORD);
// 2E47C: using guessed type int __fastcall sub_2E47C(_DWORD);
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);
// 70CEC: using guessed type pthread_mutex_t stru_70CEC;
// 70D20: using guessed type __int64 qword_70D20;

//----- (0002E614) --------------------------------------------------------
int get_control_priority()
{
  int control_priority; // r4

  if ( pthread_mutex_lock(&stru_740A0) )
    log_mutex_error_and_exit("cp_prio", 7457);
  if ( pthread_rwlock_rdlock(&rwlock) )
    log_rdlock_error("cp_prio", 7457);
  if ( pthread_mutex_unlock(&stru_740A0) )
    log_mutex_unlock_error("cp_prio", 7457);
  control_priority = *(_DWORD *)(dword_66AD4 + 4);
  if ( pthread_rwlock_unlock(&rwlock) )
    log_rwlock_error_and_exit("cp_prio", 7459);
  off_658DC(0);
  return control_priority;
}
// 1DA28: using guessed type int sub_1DA28(void);
// 2B460: using guessed type void __fastcall __noreturn sub_2B460(_DWORD, _DWORD);
// 2B4BC: using guessed type void __fastcall __noreturn sub_2B4BC(_DWORD, _DWORD);
// 2BFAC: using guessed type void __fastcall __noreturn sub_2BFAC(_DWORD, _DWORD);
// 2C5C0: using guessed type void __fastcall __noreturn sub_2C5C0(_DWORD, _DWORD);
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);
// 66AD4: using guessed type int dword_66AD4;
// 740A0: using guessed type pthread_mutex_t stru_740A0;

//----- (0002E6C0) --------------------------------------------------------
void __fastcall sub_2E6C0(_DWORD *a1)
{
  int v2; // r3
  int v3; // r5
  char s[2064]; // [sp+8h] [bp-810h] BYREF

  v2 = dword_66A44;
  a1[7] = 0;
  if ( v2 || (v3 = a1[1], v3 >= get_control_priority()) )
  {
    if ( byte_70CE8 || byte_66640 || dword_657B8 > 5 )
    {
      snprintf(s, 2048u, "Pool %d %s alive", *a1, (const char *)a1[41]);
      log_event(6, s, 0);
    }
  }
  else if ( byte_70CE8 || byte_66640 || dword_657B8 > 3 )
  {
    snprintf(s, 2048u, "Pool %d %s alive, testing stability", *a1, (const char *)a1[41]);
    log_event(4, s, 0);
  }
}
// 657B8: using guessed type int dword_657B8;
// 66640: using guessed type char byte_66640;
// 66A44: using guessed type int dword_66A44;
// 70CE8: using guessed type char byte_70CE8;

//----- (0002E7F8) --------------------------------------------------------
void __fastcall resume_stratum_connection(_DWORD *pool_id)
{
  char log_msg[2056]; // [sp+0h] [bp-808h] BYREF

  if ( byte_70CE8 || byte_66640 || dword_657B8 > 5 )
  {
    snprintf(log_msg, 2048u, "Stratum connection to pool %d resumed", *pool_id);
    log_event(6, log_msg, 0);
    log_pool_status(pool_id);
  }
  else
  {
    log_pool_status(pool_id);
  }
}
// 657B8: using guessed type int dword_657B8;
// 66640: using guessed type char byte_66640;
// 70CE8: using guessed type char byte_70CE8;

//----- (0002E888) --------------------------------------------------------
void __fastcall reset_and_resume_connection_if_signaled(int connection_handle)
{
  if ( reset_thread_signal(connection_handle, (_BYTE *)(connection_handle + 97)) )
    resume_stratum_connection((_DWORD *)connection_handle);
}

//----- (0002E8AC) --------------------------------------------------------
int __fastcall is_miner_allowed_to_mine(int miner_index)
{
  int control_priority; // r4

  if ( *(_DWORD *)(miner_index + 100) != 1 )
    return 0;
  if ( (unsigned int)(dword_66A44 - 3) <= 1 || *(_BYTE *)(miner_index + 640) && *(_BYTE *)(miner_index + 97) )
    return 1;
  if ( miner_index == get_current_pool_index() )
    return 1;
  if ( *(_DWORD *)(miner_index + 732) )
    return 1;
  if ( !dword_66A44 )
  {
    control_priority = *(_DWORD *)(miner_index + 4);
    if ( control_priority < get_control_priority() )
      return 1;
  }
  return (unsigned __int8)byte_66AD8;
}
// 66A44: using guessed type int dword_66A44;
// 66AD8: using guessed type char byte_66AD8;

//----- (0002E940) --------------------------------------------------------
int add_pool()
{
  int initial_memory_alloc; // r0
  int pool_index_global; // r12
  int alloc_pointer; // r4
  int next_pool_index; // r1
  int realloc_result; // r0
  int current_pool_index; // r2
  int function_result; // r0
  int errno_val; // r3
  int error_line_number; // r1
  int *errno_addr; // r0
  int *errno_addr_mutex; // r0
  int *errno_addr_rwlock; // r0
  int *errno_addr_mutex_704; // r0
  int *errno_addr_mutex_740; // r0
  char error_message[2080]; // [sp+10h] [bp-820h] BYREF

  initial_memory_alloc = allocate_and_log_on_fail(1848, 1, "cgminer.c", "add_pool", 767);
  pool_index_global = dword_70DB8;
  alloc_pointer = initial_memory_alloc;
  *(_DWORD *)initial_memory_alloc = dword_70DB8;
  next_pool_index = dword_70DB8;
  *(_BYTE *)(initial_memory_alloc + 644) = 0;
  *(_DWORD *)(initial_memory_alloc + 4) = pool_index_global;
  realloc_result = realloc_with_logging(dword_70E5C, 4 * (next_pool_index + 2), "cgminer.c", "add_pool", 779);
  current_pool_index = dword_70DB8;
  dword_70E5C = realloc_result;
  ++dword_70DB8;
  *(_DWORD *)(realloc_result + 4 * current_pool_index) = alloc_pointer;
  if ( pthread_mutex_init((pthread_mutex_t *)(alloc_pointer + 188), 0) )
  {
    errno_addr = _errno_location();
    snprintf(
      error_message,
      2048u,
      "Failed to pthread_mutex_init errno=%d in %s %s():%d",
      *errno_addr,
      "cgminer.c",
      "add_pool",
      782);
    goto LABEL_11;
  }
  if ( pthread_cond_init((pthread_cond_t *)(alloc_pointer + 296), 0) )
  {
    strcpy(error_message, "Failed to pthread_cond_init in add_pool");
    goto LABEL_11;
  }
  if ( pthread_mutex_init((pthread_mutex_t *)(alloc_pointer + 212), 0) )
  {
    errno_addr_mutex = _errno_location();
    snprintf(
      error_message,
      2048u,
      "Failed to pthread_mutex_init errno=%d in %s %s():%d",
      *errno_addr_mutex,
      "cgminer.c",
      "add_pool",
      789);
    goto LABEL_11;
  }
  if ( pthread_rwlock_init((pthread_rwlock_t *)(alloc_pointer + 236), 0) )
  {
    errno_addr_rwlock = _errno_location();
    error_line_number = 789;
    errno_val = *errno_addr_rwlock;
    goto LABEL_10;
  }
  if ( pthread_mutex_init((pthread_mutex_t *)(alloc_pointer + 704), 0) )
  {
    errno_addr_mutex_704 = _errno_location();
    snprintf(
      error_message,
      2048u,
      "Failed to pthread_mutex_init errno=%d in %s %s():%d",
      *errno_addr_mutex_704,
      "cgminer.c",
      "add_pool",
      790);
    goto LABEL_11;
  }
  if ( pthread_mutex_init((pthread_mutex_t *)(alloc_pointer + 740), 0) )
  {
    errno_addr_mutex_740 = _errno_location();
    snprintf(
      error_message,
      2048u,
      "Failed to pthread_mutex_init errno=%d in %s %s():%d",
      *errno_addr_mutex_740,
      "cgminer.c",
      "add_pool",
      791);
LABEL_11:
    log_event(3, error_message, 1);
    shutdown_miner(1, 1);
  }
  if ( pthread_rwlock_init((pthread_rwlock_t *)(alloc_pointer + 764), 0) )
  {
    errno_val = *_errno_location();
    error_line_number = 791;
LABEL_10:
    snprintf(
      error_message,
      2048u,
      "Failed to pthread_rwlock_init errno=%d in %s %s():%d",
      errno_val,
      "cgminer.c",
      "add_pool",
      error_line_number);
    goto LABEL_11;
  }
  *(_DWORD *)(alloc_pointer + 136) = -1;
  *(_DWORD *)(alloc_pointer + 184) = 0;
  *(_DWORD *)(alloc_pointer + 160) = "{\"method\": \"getwork\", \"params\": [], \"id\":0}\n";
  *(_DWORD *)(alloc_pointer + 344) = alloc_pointer + 344;
  *(_DWORD *)(alloc_pointer + 348) = alloc_pointer + 344;
  *(_DWORD *)(alloc_pointer + 56) = 1;
  update_global_quota_gcd();
  function_result = alloc_pointer;
  *(_BYTE *)(alloc_pointer + 580) = 0;
  return function_result;
}
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 1E7D4: using guessed type int __fastcall sub_1E7D4(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1E864: using guessed type int __fastcall sub_1E864(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 28AFC: using guessed type int sub_28AFC(void);
// 2AB30: using guessed type void __fastcall __noreturn sub_2AB30(_DWORD, _DWORD);
// 70DB8: using guessed type int dword_70DB8;
// 70E5C: using guessed type int dword_70E5C;

//----- (0002EB8C) --------------------------------------------------------
char *__fastcall parse_user_credentials(char *credentials)
{
  int next_pool_index; // r3
  int pool_structure_offset; // r6
  char *tokenized_credentials; // r4
  int unused1; // r2
  int unused2; // r3
  char *username; // r0
  char *password; // r4

  if ( dword_66ADC || dword_66AE0 )
    return "Use only user + pass or userpass, but not both";
  next_pool_index = dword_66AE4 + 1;
  dword_66AE4 = next_pool_index;
  if ( next_pool_index > dword_70DB8 )
  {
    add_pool();
    next_pool_index = dword_66AE4;
  }
  pool_structure_offset = *(_DWORD *)(dword_70E5C + 4 * (next_pool_index + 1073741823));
  tokenized_credentials = _strdup(credentials);
  set_value(credentials, pool_structure_offset + 168, unused1, unused2);
  username = strtok(tokenized_credentials, ":");
  *(_DWORD *)(pool_structure_offset + 172) = username;
  if ( !username )
    return "Failed to find : delimited user info";
  password = strtok(0, ":");
  *(_DWORD *)(pool_structure_offset + 176) = password;
  if ( password )
    return 0;
  *(_DWORD *)(pool_structure_offset + 176) = calloc(1u, 1u);
  return password;
}
// 2EBFC: variable 'unused1' is possibly undefined
// 2EBFC: variable 'unused2' is possibly undefined
// 3CDAC: using guessed type int __fastcall sub_3CDAC(_DWORD, _DWORD, _DWORD, _DWORD);
// 66ADC: using guessed type int dword_66ADC;
// 66AE0: using guessed type int dword_66AE0;
// 66AE4: using guessed type int dword_66AE4;
// 70DB8: using guessed type int dword_70DB8;
// 70E5C: using guessed type int dword_70E5C;

//----- (0002EC78) --------------------------------------------------------
const char *__fastcall validate_connection_settings(int input)
{
  int current_pool_index; // r3

  if ( dword_66AE4 )
    return "Use only user + pass or userpass, but not both";
  current_pool_index = dword_66ADC + 1;
  dword_66ADC = current_pool_index;
  if ( current_pool_index > dword_70DB8 )
  {
    add_pool();
    current_pool_index = dword_66ADC;
  }
  set_value(
    input,
    *(_DWORD *)(dword_70E5C + 4 * (current_pool_index + 1073741823)) + 172,
    dword_70E5C,
    current_pool_index + 1073741823);
  return 0;
}
// 3CDAC: using guessed type int __fastcall sub_3CDAC(_DWORD, _DWORD, _DWORD, _DWORD);
// 66ADC: using guessed type int dword_66ADC;
// 66AE4: using guessed type int dword_66AE4;
// 70DB8: using guessed type int dword_70DB8;
// 70E5C: using guessed type int dword_70E5C;

//----- (0002ECF4) --------------------------------------------------------
int increment_pool_counter()
{
  int updated_counter; // r3

  updated_counter = ++dword_66AE8;
  if ( dword_66AE8 > dword_70DB8 )
  {
    add_pool();
    updated_counter = dword_66AE8;
  }
  return *(_DWORD *)(dword_70E5C + 4 * (updated_counter + 1073741823));
}
// 66AE8: using guessed type int dword_66AE8;
// 70DB8: using guessed type int dword_70DB8;
// 70E5C: using guessed type int dword_70E5C;

//----- (0002EF5C) --------------------------------------------------------
const char *__fastcall validate_and_initialize_pool(int pool_index)
{
  int current_pool; // r3

  if ( dword_66AE4 )
    return "Use only user + pass or userpass, but not both";
  current_pool = dword_66AE0 + 1;
  dword_66AE0 = current_pool;
  if ( current_pool > dword_70DB8 )
  {
    add_pool();
    current_pool = dword_66AE0;
  }
  set_value(
    pool_index,
    *(_DWORD *)(dword_70E5C + 4 * (current_pool + 1073741823)) + 176,
    dword_70E5C,
    current_pool + 1073741823);
  return 0;
}
// 3CDAC: using guessed type int __fastcall sub_3CDAC(_DWORD, _DWORD, _DWORD, _DWORD);
// 66AE0: using guessed type int dword_66AE0;
// 66AE4: using guessed type int dword_66AE4;
// 70DB8: using guessed type int dword_70DB8;
// 70E5C: using guessed type int dword_70E5C;

//----- (0002EFD8) --------------------------------------------------------
int increment_and_log_event()
{
  int current_value; // r3
  _DWORD *target_pointer; // r4
  char log_message[2056]; // [sp+0h] [bp-808h] BYREF

  current_value = ++dword_66AEC;
  if ( dword_66AEC > dword_70DB8 )
  {
    add_pool();
    current_value = dword_66AEC;
  }
  target_pointer = *(_DWORD **)(dword_70E5C + 4 * (current_value + 1073741823));
  if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
  {
    snprintf(log_message, 2048u, "Enable extranonce subscribe on %d", *target_pointer);
    log_event(7, log_message, 0);
  }
  set_flag(target_pointer + 145);
  return 0;
}
// 3CCC8: using guessed type int __fastcall sub_3CCC8(_DWORD);
// 657B8: using guessed type int dword_657B8;
// 66640: using guessed type char byte_66640;
// 66641: using guessed type char byte_66641;
// 66AEC: using guessed type int dword_66AEC;
// 70CE8: using guessed type char byte_70CE8;
// 70DB8: using guessed type int dword_70DB8;
// 70E5C: using guessed type int dword_70E5C;

//----- (0002F0B8) --------------------------------------------------------
pthread_rwlock_t *__fastcall reset_rwlock_and_log(pthread_rwlock_t *rwlock)
{
  pthread_rwlock_t *rwlock_copy; // r4
  int original_nr_readers; // r2
  int *errno_ptr; // r0
  int stored_nr_readers; // [sp+14h] [bp-814h] BYREF
  char log_buffer[2064]; // [sp+18h] [bp-810h] BYREF

  rwlock_copy = rwlock;
  stored_nr_readers = 0;
  if ( rwlock )
  {
    rwlock = (pthread_rwlock_t *)pthread_rwlock_trywrlock(rwlock + 10);
    if ( !rwlock )
    {
      original_nr_readers = rwlock_copy[11].__nr_readers;
      rwlock_copy[11].__nr_readers = 0;
      stored_nr_readers = original_nr_readers;
      if ( pthread_rwlock_unlock(rwlock_copy + 10) )
      {
        errno_ptr = _errno_location();
        snprintf(
          log_buffer,
          2048u,
          "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
          *errno_ptr,
          "cgminer.c",
          "flush_queue",
          9687);
        log_event(3, log_buffer, 1);
        shutdown_miner(1, 1);
      }
      rwlock = (pthread_rwlock_t *)off_658DC(0);
      if ( stored_nr_readers )
      {
        rwlock = (pthread_rwlock_t *)clear_miner_data_if_not_null(&stored_nr_readers, "cgminer.c", "flush_queue", 9691);
        if ( byte_66641 )
        {
          if ( byte_70CE8 || byte_66640 || dword_657B8 > 6 )
          {
            strcpy(log_buffer, "Discarded queued work item");
            return (pthread_rwlock_t *)log_event(7, log_buffer, 0);
          }
        }
      }
    }
  }
  return rwlock;
}
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 1DA28: using guessed type int sub_1DA28(void);
// 28FFC: using guessed type int __fastcall sub_28FFC(_DWORD, _DWORD, _DWORD, _DWORD);
// 2AB30: using guessed type void __fastcall __noreturn sub_2AB30(_DWORD, _DWORD);
// 657B8: using guessed type int dword_657B8;
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);
// 66640: using guessed type char byte_66640;
// 66641: using guessed type char byte_66641;
// 70CE8: using guessed type char byte_70CE8;

//----- (0002F228) --------------------------------------------------------
int reset_miner_stats()
{
  int unused1; // r1
  int error_number; // r4
  char *error_string; // r0
  int system_uptime; // r2
  int *ptr_double_operations; // r3
  int *ptr_reset_loop; // r12
  int reset_loop_end; // lr
  int reset_target; // t1
  int final_result; // r0
  int counter; // r5
  int miner_stat_address; // r4
  int *lock_errno_location; // r0
  int *unlock_errno_location; // r0
  struct sysinfo sys_info; // [sp+10h] [bp-860h] BYREF
  char error_buffer[2080]; // [sp+50h] [bp-820h] BYREF

  if ( sysinfo(&sys_info) )
  {
    if ( byte_70CE8 || byte_66640 || dword_657B8 > 5 )
    {
      error_number = *_errno_location();
      error_string = strerror(error_number);
      snprintf(error_buffer, 2048u, "Failed to get sysinfo, errno:%u, reason:%s\n", error_number, error_string);
      log_event(6, error_buffer, 0);
    }
    dword_740EC = time(0);
  }
  else
  {
    system_uptime = sys_info.uptime;
    dword_740EC = sys_info.uptime;
  }
  get_hardware_timestamp(&dword_66A90, unused1, system_uptime, &dword_740EC);
  copy_system_time(&unk_66AF0, &dword_66A90);
  ptr_double_operations = (int *)dbl_66AF8;
  dbl_74120 = 0.0;
  dbl_74230 = 0.0;
  dbl_74228 = 0.0;
  dbl_70E18 = 0.0;
  unk_70CE0 = 0LL;
  unk_70E28 = 0LL;
  do
  {
    *(_QWORD *)ptr_double_operations = 0LL;
    ptr_double_operations += 2;
  }
  while ( ptr_double_operations != &dword_66B58 );
  dbl_66140 = 1.0;
  *(_QWORD *)&dword_66120 = 4607182418800017408LL;
  unk_66138 = 4607182418800017408LL;
  dword_73FB8 = 0;
  dword_66B58 = 0;
  dword_73FBC = 0;
  dword_74134 = 0;
  dword_70E6C = 0;
  dword_73FCC = 0;
  dword_70E60 = 0;
  dword_70D04 = 0;
  *(_QWORD *)&dword_72EE0 = 0LL;
  qword_70E48 = 0LL;
  qword_72F10 = 0LL;
  qword_74220 = 0LL;
  *(_QWORD *)&qword_72F60 = 0LL;
  *(_QWORD *)&qword_70D20 = 0LL;
  dbl_72E80 = 0.0;
  dbl_72F08 = 0.0;
  dbl_70E50 = 0LL;
  if ( dword_70DB8 > 0 )
  {
    ptr_reset_loop = (int *)dword_70E5C;
    reset_loop_end = dword_70E5C + 4 * dword_70DB8;
    do
    {
      reset_target = *ptr_reset_loop++;
      *(_DWORD *)(reset_target + 116) = 0;
      *(_QWORD *)(reset_target + 8) = 0LL;
      *(_QWORD *)(reset_target + 16) = 0LL;
      *(_DWORD *)(reset_target + 120) = 0;
      *(_DWORD *)(reset_target + 124) = 0;
      *(_DWORD *)(reset_target + 128) = 0;
      *(_DWORD *)(reset_target + 132) = 0;
      *(_DWORD *)(reset_target + 352) = 0;
      *(_QWORD *)(reset_target + 40) = 0LL;
      *(_QWORD *)(reset_target + 72) = 0LL;
      *(_QWORD *)(reset_target + 80) = 0LL;
      *(_QWORD *)(reset_target + 88) = 0LL;
      *(_DWORD *)(reset_target + 360) = 0;
      *(_DWORD *)(reset_target + 364) = 0;
    }
    while ( (int *)reset_loop_end != ptr_reset_loop );
  }
  final_result = reset_global_statistics();
  if ( dword_72F38 > 0 )
  {
    counter = 0;
    while ( 1 )
    {
      miner_stat_address = get_device_by_index(counter);
      copy_system_time(miner_stat_address + 368, &dword_66A90);
      if ( pthread_mutex_lock(&stru_70E30) )
        break;
      *(_QWORD *)(miner_stat_address + 80) = 0LL;
      *(_DWORD *)(miner_stat_address + 36) = 0;
      *(_DWORD *)(miner_stat_address + 40) = 0;
      *(_DWORD *)(miner_stat_address + 44) = 0;
      *(_QWORD *)(miner_stat_address + 88) = 0LL;
      *(_DWORD *)(miner_stat_address + 220) = 0;
      *(_QWORD *)(miner_stat_address + 200) = 0LL;
      *(_QWORD *)(miner_stat_address + 208) = 0LL;
      *(_QWORD *)(miner_stat_address + 224) = 0LL;
      *(_QWORD *)(miner_stat_address + 192) = 0LL;
      if ( pthread_mutex_unlock(&stru_70E30) )
      {
        unlock_errno_location = _errno_location();
        snprintf(
          error_buffer,
          2048u,
          "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
          *unlock_errno_location,
          "cgminer.c",
          "zero_stats",
          6227);
LABEL_19:
        log_event(3, error_buffer, 1);
        shutdown_miner(1, 1);
      }
      ++counter;
      off_658DC(0);
      final_result = (*(int (__fastcall **)(int))(*(_DWORD *)(miner_stat_address + 4) + 96))(miner_stat_address);
      if ( dword_72F38 <= counter )
        return final_result;
    }
    lock_errno_location = _errno_location();
    snprintf(
      error_buffer,
      2048u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *lock_errno_location,
      "cgminer.c",
      "zero_stats",
      6214);
    goto LABEL_19;
  }
  return final_result;
}
// 2F2D0: variable 'unused1' is possibly undefined
// 2F2D0: variable 'system_uptime' is possibly undefined
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 1DA28: using guessed type int sub_1DA28(void);
// 1F5C4: using guessed type int __fastcall sub_1F5C4(_DWORD, _DWORD, _DWORD, _DWORD);
// 2251C: using guessed type int __fastcall sub_2251C(_DWORD, _DWORD);
// 29BD4: using guessed type int sub_29BD4(void);
// 2AB30: using guessed type void __fastcall __noreturn sub_2AB30(_DWORD, _DWORD);
// 2C8F4: using guessed type int __fastcall sub_2C8F4(_DWORD);
// 657B8: using guessed type int dword_657B8;
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);
// 66120: using guessed type int dword_66120;
// 66140: using guessed type double dbl_66140;
// 66640: using guessed type char byte_66640;
// 66A90: using guessed type int dword_66A90;
// 66AF8: using guessed type double dbl_66AF8[12];
// 66B58: using guessed type int dword_66B58;
// 70CE8: using guessed type char byte_70CE8;
// 70D04: using guessed type int dword_70D04;
// 70D20: using guessed type int dword_70D20;
// 70DB8: using guessed type int dword_70DB8;
// 70E18: using guessed type double dbl_70E18;
// 70E30: using guessed type pthread_mutex_t stru_70E30;
// 70E48: using guessed type __int64 qword_70E48;
// 70E5C: using guessed type int dword_70E5C;
// 70E60: using guessed type int dword_70E60;
// 70E6C: using guessed type int dword_70E6C;
// 72E80: using guessed type double dbl_72E80;
// 72EE0: using guessed type int dword_72EE0;
// 72F08: using guessed type double dbl_72F08;
// 72F10: using guessed type __int64 qword_72F10;
// 72F38: using guessed type int dword_72F38;
// 72F60: using guessed type int dword_72F60;
// 73FB8: using guessed type int dword_73FB8;
// 73FBC: using guessed type int dword_73FBC;
// 73FCC: using guessed type int dword_73FCC;
// 740EC: using guessed type int dword_740EC;
// 74120: using guessed type double dbl_74120;
// 74134: using guessed type int dword_74134;
// 74220: using guessed type __int64 qword_74220;
// 74228: using guessed type double dbl_74228;
// 74230: using guessed type double dbl_74230;

//----- (0002F62C) --------------------------------------------------------
int __fastcall increment_hardware_errors(int miner_data_ptr)
{
  int miner_status_ptr; // r12
  int error_count; // r2
  int result; // r0
  int (__fastcall *error_handler_func)(int); // r3
  int *errno_ptr_lock; // r0
  int *errno_ptr_unlock; // r0
  char log_buffer[2056]; // [sp+10h] [bp-808h] BYREF

  if ( byte_70CE8 || byte_66640 || dword_657B8 > 5 )
  {
    snprintf(
      log_buffer,
      2048u,
      "%s %d: invalid nonce - HW error",
      *(const char **)(*(_DWORD *)(*(_DWORD *)(miner_data_ptr + 36) + 4) + 8),
      *(_DWORD *)(*(_DWORD *)(miner_data_ptr + 36) + 8));
    log_event(6, log_buffer, 0);
  }
  if ( pthread_mutex_lock(&stru_70CEC) )
  {
    errno_ptr_lock = _errno_location();
    snprintf(
      log_buffer,
      2048u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *errno_ptr_lock,
      "cgminer.c",
      "inc_hw_errors",
      8805);
    goto LABEL_12;
  }
  miner_status_ptr = *(_DWORD *)(miner_data_ptr + 36);
  error_count = *(_DWORD *)(miner_status_ptr + 44) + 1;
  ++dword_73FB8;
  *(_DWORD *)(miner_status_ptr + 44) = error_count;
  if ( pthread_mutex_unlock(&stru_70CEC) )
  {
    errno_ptr_unlock = _errno_location();
    snprintf(
      log_buffer,
      2048u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *errno_ptr_unlock,
      "cgminer.c",
      "inc_hw_errors",
      8808);
LABEL_12:
    log_event(3, log_buffer, 1);
    shutdown_miner(1, 1);
  }
  result = off_658DC(0);
  error_handler_func = *(int (__fastcall **)(int))(*(_DWORD *)(*(_DWORD *)(miner_data_ptr + 36) + 4) + 84);
  if ( error_handler_func )
    return error_handler_func(miner_data_ptr);
  return result;
}
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 1DA28: using guessed type int sub_1DA28(void);
// 2AB30: using guessed type void __fastcall __noreturn sub_2AB30(_DWORD, _DWORD);
// 657B8: using guessed type int dword_657B8;
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);
// 66640: using guessed type char byte_66640;
// 70CE8: using guessed type char byte_70CE8;
// 70CEC: using guessed type pthread_mutex_t stru_70CEC;
// 73FB8: using guessed type int dword_73FB8;

//----- (0002F7B4) --------------------------------------------------------
int __fastcall increment_hw_errors(int miner_data, int error_diff)
{
  int miner_hw_info; // r12
  int new_hw_errors; // r1
  int result; // r0
  int (__fastcall *additional_error_handler)(int); // r3
  int *errno_val_lock; // r0
  int *errno_val_unlock; // r0
  char log_buffer[2064]; // [sp+10h] [bp-810h] BYREF

  if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
  {
    snprintf(
      log_buffer,
      2048u,
      "%s%d: invalid nonce - HW error",
      *(const char **)(*(_DWORD *)(*(_DWORD *)(miner_data + 36) + 4) + 8),
      *(_DWORD *)(*(_DWORD *)(miner_data + 36) + 8));
    log_event(3, log_buffer, 0);
  }
  if ( pthread_mutex_lock(&stru_70CEC) )
  {
    errno_val_lock = _errno_location();
    snprintf(
      log_buffer,
      2048u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *errno_val_lock,
      "cgminer.c",
      "inc_hw_errors_with_diff",
      8819);
    goto LABEL_12;
  }
  miner_hw_info = *(_DWORD *)(miner_data + 36);
  new_hw_errors = *(_DWORD *)(miner_hw_info + 44) + error_diff;
  dword_73FB8 += error_diff;
  *(_DWORD *)(miner_hw_info + 44) = new_hw_errors;
  if ( pthread_mutex_unlock(&stru_70CEC) )
  {
    errno_val_unlock = _errno_location();
    snprintf(
      log_buffer,
      2048u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *errno_val_unlock,
      "cgminer.c",
      "inc_hw_errors_with_diff",
      8822);
LABEL_12:
    log_event(3, log_buffer, 1);
    shutdown_miner(1, 1);
  }
  result = off_658DC(0);
  additional_error_handler = *(int (__fastcall **)(int))(*(_DWORD *)(*(_DWORD *)(miner_data + 36) + 4) + 84);
  if ( additional_error_handler )
    return additional_error_handler(miner_data);
  return result;
}
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 1DA28: using guessed type int sub_1DA28(void);
// 2AB30: using guessed type void __fastcall __noreturn sub_2AB30(_DWORD, _DWORD);
// 657B8: using guessed type int dword_657B8;
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);
// 66640: using guessed type char byte_66640;
// 70CE8: using guessed type char byte_70CE8;
// 70CEC: using guessed type pthread_mutex_t stru_70CEC;
// 73FB8: using guessed type int dword_73FB8;

//----- (0002F948) --------------------------------------------------------
unsigned __int64 __fastcall calculate_hashrate_and_log(_DWORD *input_values)
{
  double hash_part_1; // d8
  double hash_part_2; // d8
  double hash_part_3; // d8
  double hash_part_4; // r0
  double total_hash; // d8
  unsigned __int64 normalized_hashrate; // r6
  int lock_result; // r8
  unsigned __int64 *miner_hashrate_pointer; // r3
  int *errno_val_lock; // r0
  int *errno_val_wrlock; // r0
  int *errno_val_rwunlock; // r0
  int *errno_val_mutexunlock; // r0
  char log_buffer[2080]; // [sp+10h] [bp-820h] BYREF

  hash_part_1 = check_null_pointer(input_values[54], input_values[55]) * 6.27710174e57;
  hash_part_2 = hash_part_1 + check_null_pointer(input_values[52], input_values[53]) * 3.40282367e38;
  hash_part_3 = hash_part_2 + check_null_pointer(input_values[50], input_values[51]) * 1.84467441e19;
  hash_part_4 = check_null_pointer(input_values[48], input_values[49]);
  total_hash = hash_part_4 + hash_part_3;
  if ( total_hash == 0.0 )
    total_hash = 0.0;
  round(LODWORD(hash_part_4));
  normalized_hashrate = calculate_hash_value(
                          COERCE_UNSIGNED_INT64(2.69595353e67 / total_hash),
                          HIDWORD(COERCE_UNSIGNED_INT64(2.69595353e67 / total_hash)));
  if ( pthread_mutex_lock(&stru_740A0) )
  {
    errno_val_lock = _errno_location();
    snprintf(
      log_buffer,
      2048u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *errno_val_lock,
      "cgminer.c",
      "share_diff",
      5183);
    goto LABEL_14;
  }
  lock_result = pthread_rwlock_wrlock(&rwlock);
  if ( lock_result )
  {
    errno_val_wrlock = _errno_location();
    snprintf(
      log_buffer,
      2048u,
      "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *errno_val_wrlock,
      "cgminer.c",
      "share_diff",
      5183);
    goto LABEL_14;
  }
  if ( qword_66A60 < normalized_hashrate )
  {
    qword_66A60 = normalized_hashrate;
    lock_result = 1;
    format_hashrate(normalized_hashrate, SHIDWORD(normalized_hashrate), dword_66128, 8u, 0);
  }
  miner_hashrate_pointer = (unsigned __int64 *)(input_values[65] + 368);
  if ( *miner_hashrate_pointer < normalized_hashrate )
    *miner_hashrate_pointer = normalized_hashrate;
  if ( pthread_rwlock_unlock(&rwlock) )
  {
    errno_val_rwunlock = _errno_location();
    snprintf(
      log_buffer,
      2048u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *errno_val_rwunlock,
      "cgminer.c",
      "share_diff",
      5197);
    goto LABEL_14;
  }
  if ( pthread_mutex_unlock(&stru_740A0) )
  {
    errno_val_mutexunlock = _errno_location();
    snprintf(
      log_buffer,
      2048u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *errno_val_mutexunlock,
      "cgminer.c",
      "share_diff",
      5197);
LABEL_14:
    log_event(3, log_buffer, 1);
    shutdown_miner(1, 1);
  }
  off_658DC(0);
  if ( lock_result && (byte_70CE8 || byte_66640 || dword_657B8 > 5) )
  {
    snprintf(log_buffer, 2048u, "New best share: %s", dword_66128);
    log_event(6, log_buffer, 0);
  }
  return normalized_hashrate;
}
// 121B0: using guessed type int __fastcall round(_DWORD);
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 1DA28: using guessed type int sub_1DA28(void);
// 2AB30: using guessed type void __fastcall __noreturn sub_2AB30(_DWORD, _DWORD);
// 492FC: using guessed type double __fastcall sub_492FC(_DWORD, _DWORD);
// 493C8: using guessed type __int64 __fastcall sub_493C8(_DWORD, _DWORD);
// 657B8: using guessed type int dword_657B8;
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);
// 66640: using guessed type char byte_66640;
// 66A60: using guessed type __int64 qword_66A60;
// 70CE8: using guessed type char byte_70CE8;
// 740A0: using guessed type pthread_mutex_t stru_740A0;

//----- (0002FC18) --------------------------------------------------------
int __fastcall update_miner_statistics(int *miner_data, int worker_data)
{
  double minimum_hashrate; // d8
  unsigned __int64 current_hashrate; // r0
  double hashrate_increment; // d8
  double hashrate_correction_factor; // r0
  int miner_index; // r5
  double miner_hashrate_adjustment; // r0
  int pool_data_index; // r5
  double pool_hashrate_adjustment; // r0
  int miner_data_index; // r4
  int pool_data_pointer; // r12
  int log_miner_activity_flag; // r2
  bool should_log; // zf
  int log_count_increment; // r2
  int *lock_errno_location; // r0
  int *unlock_errno_location; // r0
  char log_message[2080]; // [sp+10h] [bp-820h] BYREF

  minimum_hashrate = dbl_66148;
  current_hashrate = calculate_hashrate_and_log((_DWORD *)worker_data);
  *(_QWORD *)(worker_data + 232) = current_hashrate;
  if ( minimum_hashrate <= check_null_pointer(current_hashrate, HIDWORD(current_hashrate)) )
  {
    pool_data_pointer = *(_DWORD *)(worker_data + 260);
    log_miner_activity_flag = (unsigned __int8)byte_70CE8;
    *(_BYTE *)(worker_data + 283) = 1;
    should_log = log_miner_activity_flag == 0;
    log_count_increment = dword_73FCC + 1;
    ++*(_DWORD *)(pool_data_pointer + 32);
    dword_73FCC = log_count_increment;
    *(_BYTE *)(worker_data + 282) = 1;
    if ( !should_log || byte_66640 || dword_657B8 > 4 )
    {
      snprintf(log_message, 2048u, "Found block for pool %d!", **(_DWORD **)(worker_data + 260));
      log_event(5, log_message, 0);
    }
  }
  if ( pthread_mutex_lock(&stru_70CEC) )
  {
    lock_errno_location = _errno_location();
    snprintf(
      log_message,
      2048u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *lock_errno_location,
      "cgminer.c",
      "update_work_stats",
      8885);
    goto LABEL_10;
  }
  hashrate_increment = *(double *)(worker_data + 224);
  hashrate_correction_factor = convert_float_to_int(qword_70D20);
  *(_QWORD *)&qword_70D20 = calculate_hash_rate(
                              COERCE_UNSIGNED_INT64(hashrate_correction_factor + hashrate_increment),
                              HIDWORD(COERCE_UNSIGNED_INT64(hashrate_correction_factor + hashrate_increment)));
  miner_index = *miner_data;
  miner_hashrate_adjustment = convert_float_to_int(*(_DWORD *)(*miner_data + 192));
  *(_QWORD *)(miner_index + 192) = calculate_hash_rate(
                                     COERCE_UNSIGNED_INT64(miner_hashrate_adjustment + hashrate_increment),
                                     HIDWORD(COERCE_UNSIGNED_INT64(miner_hashrate_adjustment + hashrate_increment)));
  pool_data_index = *(_DWORD *)(worker_data + 260);
  pool_hashrate_adjustment = convert_float_to_int(*(_DWORD *)(pool_data_index + 40));
  *(_QWORD *)(pool_data_index + 40) = calculate_hash_rate(
                                        COERCE_UNSIGNED_INT64(pool_hashrate_adjustment + *(double *)(worker_data + 224)),
                                        HIDWORD(COERCE_UNSIGNED_INT64(pool_hashrate_adjustment + *(double *)(worker_data + 224))));
  miner_data_index = *miner_data;
  *(_DWORD *)(miner_data_index + 232) = time(0);
  if ( pthread_mutex_unlock(&stru_70CEC) )
  {
    unlock_errno_location = _errno_location();
    snprintf(
      log_message,
      2048u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *unlock_errno_location,
      "cgminer.c",
      "update_work_stats",
      8890);
LABEL_10:
    log_event(3, log_message, 1);
    shutdown_miner(1, 1);
  }
  return off_658DC(0);
}
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 1DA28: using guessed type int sub_1DA28(void);
// 2AB30: using guessed type void __fastcall __noreturn sub_2AB30(_DWORD, _DWORD);
// 492FC: using guessed type double __fastcall sub_492FC(_DWORD, _DWORD);
// 4930C: using guessed type double __fastcall sub_4930C(_DWORD);
// 493A4: using guessed type __int64 __fastcall sub_493A4(_DWORD, _DWORD);
// 657B8: using guessed type int dword_657B8;
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);
// 66148: using guessed type double dbl_66148;
// 66640: using guessed type char byte_66640;
// 70CE8: using guessed type char byte_70CE8;
// 70CEC: using guessed type pthread_mutex_t stru_70CEC;
// 70D20: using guessed type int dword_70D20;
// 73FCC: using guessed type int dword_73FCC;

//----- (0002FE44) --------------------------------------------------------
int __fastcall process_mining_cycle(
        int cycle_context,
        _DWORD *miner_data,
        int cycle_param,
        _DWORD *mining_cycle_result)
{
  bool is_result_null; // zf
  _DWORD *result_pointer; // r5
  int hash_comparison_result; // r4
  char log_message[2064]; // [sp+0h] [bp-810h] BYREF

  result_pointer = mining_cycle_result;
  is_result_null = mining_cycle_result == 0;
  if ( mining_cycle_result )
    mining_cycle_result = 0;
  if ( !is_result_null )
    *result_pointer = mining_cycle_result;
  miner_data[19] = cycle_param;
  process_sha256_block(miner_data);
  if ( miner_data[55] )
  {
    increment_hardware_errors(cycle_context);
    return 0;
  }
  else
  {
    update_miner_statistics((int *)(cycle_context + 36), (int)miner_data);
    hash_comparison_result = compare_hashes_and_log(miner_data + 48, miner_data + 40);
    if ( !hash_comparison_result )
    {
      if ( result_pointer )
        *result_pointer = 1;
      if ( byte_70CE8 || byte_66640 || dword_657B8 > 5 )
      {
        strcpy(log_message, "Share above target");
        log_event(6, log_message, 0);
      }
      else
      {
        return (unsigned __int8)byte_66640;
      }
    }
    return hash_comparison_result;
  }
}
// 27638: using guessed type int __fastcall sub_27638(_DWORD);
// 657B8: using guessed type int dword_657B8;
// 66640: using guessed type char byte_66640;
// 70CE8: using guessed type char byte_70CE8;

//----- (0002FF3C) --------------------------------------------------------
int __fastcall clear_stratum_work(_DWORD *pool_id)
{
  int cleared_work_count; // r7
  int current_pool; // r3
  int next_pool_id; // r4
  int prev_pool_pointer; // r10
  int global_pool_id; // r1
  int global_pool_ctl; // r0
  int ctl_offset; // r2
  int current_pool_ctl; // r12
  int current_pool_next_id; // r9
  _DWORD *pool_ctl; // r0
  int hash_index; // r2
  int hash_head; // r0
  int temp_ptr; // lr
  int prev_pool_id; // r0
  int v16; // r2
  int result; // r0
  int *lock_errno; // r0
  int *unlock_errno; // r0
  int temp_pool_id; // [sp+14h] [bp-824h] BYREF
  char error_message[2080]; // [sp+18h] [bp-820h] BYREF

  cleared_work_count = pthread_mutex_lock((pthread_mutex_t *)dword_66A80);
  if ( cleared_work_count )
  {
    lock_errno = _errno_location();
    snprintf(
      error_message,
      2048u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *lock_errno,
      "cgminer.c",
      "clear_pool_work",
      7437);
    goto LABEL_37;
  }
  current_pool = dword_66B5C;
  temp_pool_id = dword_66B5C;
  if ( !dword_66B5C )
  {
    if ( !pthread_mutex_unlock((pthread_mutex_t *)dword_66A80) )
      return off_658DC(0);
    goto LABEL_38;
  }
  next_pool_id = *(_DWORD *)(dword_66B5C + 352);
  if ( *(_DWORD **)(dword_66B5C + 260) == pool_id )
    goto LABEL_6;
LABEL_4:
  temp_pool_id = next_pool_id;
  if ( next_pool_id )
  {
    while ( 1 )
    {
      current_pool = next_pool_id;
      next_pool_id = *(_DWORD *)(next_pool_id + 352);
      if ( *(_DWORD **)(current_pool + 260) != pool_id )
        goto LABEL_4;
LABEL_6:
      prev_pool_pointer = *(_DWORD *)(current_pool + 348);
      global_pool_id = dword_66B5C;
      global_pool_ctl = *(_DWORD *)(dword_66B5C + 344);
      if ( prev_pool_pointer )
        break;
      current_pool_next_id = *(_DWORD *)(current_pool + 352);
      if ( current_pool_next_id )
      {
        ctl_offset = *(_DWORD *)(global_pool_ctl + 20);
        current_pool_ctl = current_pool + 344;
        if ( current_pool != *(_DWORD *)(global_pool_ctl + 16) - ctl_offset )
          goto LABEL_29;
LABEL_30:
        *(_DWORD *)(global_pool_ctl + 16) = prev_pool_pointer + ctl_offset;
        prev_pool_pointer = *(_DWORD *)(current_pool + 348);
        if ( prev_pool_pointer )
        {
          ctl_offset = *(_DWORD *)(*(_DWORD *)(global_pool_id + 344) + 20);
          goto LABEL_8;
        }
        current_pool_next_id = *(_DWORD *)(current_pool + 352);
LABEL_29:
        global_pool_id = current_pool_next_id;
        dword_66B5C = current_pool_next_id;
LABEL_9:
        pool_ctl = *(_DWORD **)(global_pool_id + 344);
        if ( current_pool_next_id )
        {
          *(_DWORD *)(current_pool_next_id + pool_ctl[5] + 4) = *(_DWORD *)(current_pool + 348);
          pool_ctl = *(_DWORD **)(global_pool_id + 344);
        }
        hash_index = 3 * ((pool_ctl[1] - 1) & *(_DWORD *)(current_pool + 372));
        --*(_DWORD *)(*pool_ctl + 4 * hash_index + 4);
        hash_head = **(_DWORD **)(global_pool_id + 344);
        temp_ptr = *(_DWORD *)(hash_head + 4 * hash_index);
        if ( temp_ptr == current_pool_ctl )
        {
          global_pool_id = *(_DWORD *)(current_pool + 360);
          *(_DWORD *)(hash_head + 4 * hash_index) = global_pool_id;
        }
        prev_pool_id = *(_DWORD *)(current_pool + 356);
        v16 = *(_DWORD *)(current_pool + 360);
        if ( temp_ptr == current_pool_ctl )
          global_pool_id = dword_66B5C;
        if ( prev_pool_id )
        {
          *(_DWORD *)(prev_pool_id + 16) = v16;
          v16 = *(_DWORD *)(current_pool + 360);
        }
        if ( v16 )
          *(_DWORD *)(v16 + 12) = *(_DWORD *)(current_pool + 356);
        --*(_DWORD *)(*(_DWORD *)(global_pool_id + 344) + 12);
        goto LABEL_20;
      }
      free(*(void **)global_pool_ctl);
      free(*(void **)(dword_66B5C + 344));
      dword_66B5C = 0;
LABEL_20:
      ++cleared_work_count;
      clear_miner_data_if_not_null(&temp_pool_id, "cgminer.c", "clear_pool_work", 7443);
      temp_pool_id = next_pool_id;
      if ( !next_pool_id )
        goto LABEL_21;
    }
    ctl_offset = *(_DWORD *)(global_pool_ctl + 20);
    current_pool_ctl = current_pool + 344;
    if ( current_pool == *(_DWORD *)(global_pool_ctl + 16) - ctl_offset )
      goto LABEL_30;
LABEL_8:
    *(_DWORD *)(prev_pool_pointer + ctl_offset + 8) = *(_DWORD *)(current_pool + 352);
    current_pool_next_id = *(_DWORD *)(current_pool + 352);
    goto LABEL_9;
  }
LABEL_21:
  if ( pthread_mutex_unlock((pthread_mutex_t *)dword_66A80) )
  {
LABEL_38:
    unlock_errno = _errno_location();
    snprintf(
      error_message,
      2048u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *unlock_errno,
      "cgminer.c",
      "clear_pool_work",
      7447);
LABEL_37:
    log_event(3, error_message, 1);
    shutdown_miner(1, 1);
  }
  result = off_658DC(0);
  if ( cleared_work_count && (byte_70CE8 || byte_66640 || dword_657B8 > 5) )
  {
    snprintf(
      error_message,
      2048u,
      "Cleared %d work items due to stratum disconnect on pool %d",
      cleared_work_count,
      *pool_id);
    return log_event(6, error_message, 0);
  }
  return result;
}
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 1DA28: using guessed type int sub_1DA28(void);
// 28FFC: using guessed type int __fastcall sub_28FFC(_DWORD, _DWORD, _DWORD, _DWORD);
// 2AB30: using guessed type void __fastcall __noreturn sub_2AB30(_DWORD, _DWORD);
// 657B8: using guessed type int dword_657B8;
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);
// 66640: using guessed type char byte_66640;
// 66A80: using guessed type int dword_66A80;
// 66B5C: using guessed type int dword_66B5C;
// 70CE8: using guessed type char byte_70CE8;

//----- (00030264) --------------------------------------------------------
int __fastcall sub_30264(int a1)
{
  int v2; // r9
  int v3; // r6
  int v4; // lr
  int v5; // r7
  int v6; // r11
  int v7; // r12
  int v8; // r1
  int *v9; // r2
  int v10; // r12
  int v11; // r0
  int v12; // t1
  int v13; // r3
  int v14; // r0
  _DWORD *v15; // r1
  int v16; // r5
  int v18; // r10
  int v19; // r8
  int v20; // r9
  int *v21; // r3
  int v22; // r3
  int v23; // r12
  int *v24; // r0
  int *v25; // r0
  int v26; // r3
  int v27; // r12
  char s[2088]; // [sp+10h] [bp-828h] BYREF

  if ( pthread_mutex_lock(&stru_740A0) )
  {
    v22 = *_errno_location();
    v23 = 5276;
LABEL_51:
    snprintf(s, 2048u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", v22, "cgminer.c", "switch_pools", v23);
    goto LABEL_52;
  }
  v2 = pthread_rwlock_wrlock(&rwlock);
  if ( v2 )
  {
    v24 = _errno_location();
    snprintf(s, 2048u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v24, "cgminer.c", "switch_pools", 5276);
    goto LABEL_52;
  }
  v3 = dword_66AD4;
  v4 = dword_66A44;
  v5 = *(_DWORD *)dword_66AD4;
  if ( a1 )
  {
    v6 = *(_DWORD *)(a1 + 4);
    if ( v6 )
    {
      v7 = dword_70DB8;
      if ( dword_70DB8 > 0 )
      {
        v8 = dword_70E5C;
        v9 = (int *)dword_70E5C;
        v10 = dword_70E5C + 4 * dword_70DB8;
        while ( 1 )
        {
          v12 = *v9++;
          v11 = v12;
          v13 = *(_DWORD *)(v12 + 4);
          if ( v13 < v6 )
            *(_DWORD *)(v11 + 4) = v13 + 1;
          if ( (int *)v10 == v9 )
          {
            *(_DWORD *)(a1 + 4) = 0;
            switch ( v4 )
            {
              case 0:
              case 3:
              case 4:
                goto LABEL_15;
              case 1:
              case 2:
                goto LABEL_36;
              default:
                goto LABEL_49;
            }
          }
          v6 = *(_DWORD *)(a1 + 4);
        }
      }
      *(_DWORD *)(a1 + 4) = 0;
      switch ( v4 )
      {
        case 0:
        case 3:
        case 4:
          goto LABEL_14;
        case 1:
        case 2:
          goto LABEL_35;
        default:
          goto LABEL_22;
      }
    }
    switch ( dword_66A44 )
    {
      case 0:
      case 3:
      case 4:
        goto LABEL_13;
      case 1:
      case 2:
LABEL_35:
        v8 = dword_70E5C;
LABEL_36:
        if ( *(_BYTE *)(a1 + 97) )
          goto LABEL_39;
        v16 = *(_DWORD *)(v8 + 4 * *(_DWORD *)a1);
        break;
      default:
        goto LABEL_22;
    }
  }
  else
  {
    switch ( dword_66A44 )
    {
      case 0:
      case 3:
      case 4:
LABEL_13:
        v7 = dword_70DB8;
LABEL_14:
        if ( v7 <= 0 )
          goto LABEL_22;
        do
        {
LABEL_15:
          v14 = get_connection_handle_by_id(v2);
          if ( !*(_BYTE *)(v14 + 97) && *(_DWORD *)(v14 + 100) == 1 && !check_status_flags(v14) )
          {
            v16 = *(_DWORD *)(dword_70E5C + 4 * *v15);
            goto LABEL_23;
          }
          ++v2;
        }
        while ( dword_70DB8 > v2 );
        v16 = *(_DWORD *)(dword_70E5C + 4 * v5);
        break;
      case 1:
      case 2:
        v8 = dword_70E5C;
LABEL_39:
        v18 = dword_70DB8;
        if ( dword_70DB8 <= 1 )
        {
LABEL_49:
          v16 = *(_DWORD *)(v8 + 4 * v5);
        }
        else
        {
          v19 = v5;
          v20 = 1;
          while ( 1 )
          {
            if ( ++v19 >= v18 )
            {
              v21 = (int *)v8;
              v19 = 0;
            }
            else
            {
              v21 = (int *)(v8 + 4 * v19);
            }
            v16 = *v21;
            if ( !*(_BYTE *)(*v21 + 97) && *(_DWORD *)(v16 + 100) == 1 && !check_status_flags(v16) )
              break;
            if ( ++v20 == v18 )
              goto LABEL_49;
          }
        }
        break;
      default:
LABEL_22:
        v16 = *(_DWORD *)(dword_70E5C + 4 * v5);
        break;
    }
  }
LABEL_23:
  dword_66AD4 = v16;
  if ( pthread_rwlock_unlock(&rwlock) )
  {
    v25 = _errno_location();
    snprintf(s, 2048u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v25, "cgminer.c", "switch_pools", 5357);
    goto LABEL_52;
  }
  if ( pthread_mutex_unlock(&stru_740A0) )
  {
    v26 = *_errno_location();
    v27 = 5357;
LABEL_56:
    snprintf(s, 2048u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", v26, "cgminer.c", "switch_pools", v27);
LABEL_52:
    log_event(3, s, 1);
    shutdown_miner(1, 1);
  }
  off_658DC(0);
  if ( v3 != v16 && (unsigned int)(dword_66A44 - 3) > 1 )
  {
    if ( byte_70CE8 || byte_66640 || dword_657B8 > 3 )
    {
      snprintf(s, 2048u, "Switching to pool %d %s", *(_DWORD *)v16, *(const char **)(v16 + 164));
      log_event(4, s, 0);
    }
    clear_stratum_work(v3);
  }
  if ( pthread_mutex_lock(&mutex) )
  {
    v22 = *_errno_location();
    v23 = 5365;
    goto LABEL_51;
  }
  pthread_cond_broadcast(&cond);
  if ( pthread_mutex_unlock(&mutex) )
  {
    v26 = *_errno_location();
    v27 = 5367;
    goto LABEL_56;
  }
  return off_658DC(0);
}
// 3031C: control flows out of bounds to 30320
// 3033C: control flows out of bounds to 30340
// 303D0: control flows out of bounds to 303D4
// 306C0: control flows out of bounds to 306C4
// 3039C: variable 'v15' is possibly undefined
// 30550: variable 'v8' is possibly undefined
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 1DA28: using guessed type int sub_1DA28(void);
// 279B8: using guessed type int __fastcall sub_279B8(_DWORD);
// 27AF0: using guessed type int __fastcall sub_27AF0(_DWORD);
// 2AB30: using guessed type void __fastcall __noreturn sub_2AB30(_DWORD, _DWORD);
// 2FF3C: using guessed type int __fastcall sub_2FF3C(_DWORD);
// 657B8: using guessed type int dword_657B8;
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);
// 66640: using guessed type char byte_66640;
// 66A44: using guessed type int dword_66A44;
// 66AD4: using guessed type int dword_66AD4;
// 70CE8: using guessed type char byte_70CE8;
// 70DB8: using guessed type int dword_70DB8;
// 70E5C: using guessed type int dword_70E5C;
// 740A0: using guessed type pthread_mutex_t stru_740A0;

//----- (000306E8) --------------------------------------------------------
void __fastcall sub_306E8(int a1)
{
  int v2; // r1
  int v3; // r2
  int v4; // r3
  int v5; // r0
  char s[2056]; // [sp+8h] [bp-808h] BYREF

  if ( !set_pool_test_flag(a1, a1 + 97) )
  {
    v5 = get_hardware_timestamp(a1 + 136, v2, v3, v4);
    if ( a1 == get_current_pool_index(v5) )
    {
      if ( byte_70CE8 || byte_66640 || dword_657B8 > 3 )
      {
        snprintf(s, 2048u, "Pool %d %s not responding!", *(_DWORD *)a1, *(const char **)(a1 + 164));
        log_event(4, s, 0);
      }
      switch_pools(0);
    }
    else if ( byte_70CE8 || byte_66640 || dword_657B8 > 5 )
    {
      snprintf(s, 2048u, "Pool %d %s failed to return work", *(_DWORD *)a1, *(const char **)(a1 + 164));
      log_event(6, s, 0);
    }
  }
}
// 30718: variable 'v2' is possibly undefined
// 30718: variable 'v3' is possibly undefined
// 30718: variable 'v4' is possibly undefined
// 1F5C4: using guessed type int __fastcall sub_1F5C4(_DWORD, _DWORD, _DWORD, _DWORD);
// 2B5FC: using guessed type int __fastcall sub_2B5FC(_DWORD, _DWORD);
// 2E47C: using guessed type int __fastcall sub_2E47C(_DWORD);
// 657B8: using guessed type int dword_657B8;
// 66640: using guessed type char byte_66640;
// 70CE8: using guessed type char byte_70CE8;

//----- (00030818) --------------------------------------------------------
void __noreturn monitor_mining_pool()
{
  int initial_result; // r0
  int main_loop_counter; // r11
  int unused1; // r1
  int unused2; // r2
  int *unused3_pointer; // r3
  double process_result; // r0
  int current_worker_id; // r5
  __int64 is_worker_active; // r2
  _DWORD *current_worker_data; // r4
  __int64 current_hash_count; // r6
  double previous_hashrate; // d7
  double current_hashrate; // d6
  int unused4; // r1
  int unused5; // r2
  int unused6; // r3
  int worker_frequency; // r6
  int *curl_array_ptr_old; // r12
  int curl_request_timestamp; // r7
  bool is_last_curl; // zf
  int *curl_array_ptr; // r12
  int previous_curl_node_timestamp; // r7
  int current_active_curls; // lr
  int pruned_curls_count; // r5
  int curl_node_ndelete_index; // r1
  _DWORD *next_curl_node; // r3
  _DWORD *first_curl_node; // r6
  _DWORD *next_node; // r7
  int previous_curl_node; // r0
  int **curl_data_head; // r2
  int head_curl_data; // r12
  int next_node_index; // r3
  int next_next_index; // r3
  int next_bucket_index; // r3
  int bucket_start_index; // r1
  int array_start_index; // r1
  int previous_node; // r3
  int next_node_ptr; // r3
  int num_pruned_curls; // r6
  char *plural_char; // r1
  int curl_node_ldelete_index; // r1
  int *lock_result1; // r0
  int *lock_result2; // r0
  int *lock_result3; // r0
  const char *function_name_str; // r12
  int line_number; // r1
  int unused7; // [sp+14h] [bp-86Ch]
  int pruned_shares_count; // [sp+14h] [bp-86Ch]
  pthread_mutex_t *worker_mutex_lock; // [sp+18h] [bp-868h]
  pthread_mutex_t *mutex; // [sp+18h] [bp-868h]
  void **free_memory_target; // [sp+28h] [bp-858h]
  struct timespec current_time_spec; // [sp+30h] [bp-850h] BYREF
  int start_time; // [sp+38h] [bp-848h] BYREF
  int last_active_time; // [sp+40h] [bp-840h] BYREF
  char log_buffer[2104]; // [sp+48h] [bp-838h] BYREF

  pthread_setcanceltype(1, 0);
  initial_result = set_process_name("Watchpool");
  sub_285A8(initial_result);
  main_loop_counter = 0;
  get_monotonic_time(&current_time_spec);
  unused3_pointer = &dword_70E5C;
  while ( 1 )
  {
    if ( ++main_loop_counter >= 121 )
      main_loop_counter = 0;
    LODWORD(process_result) = get_hardware_timestamp(&start_time, unused1, unused2, unused3_pointer);
    if ( dword_70DB8 > 0 )
      break;
LABEL_19:
    if ( *(_BYTE *)(get_current_pool_index(LODWORD(process_result)) + 97) )
      switch_pools(0);
    if ( dword_66A44 == 2 && start_time - dword_66BC8 > 60 * dword_71E74 )
    {
      get_hardware_timestamp(&dword_66BC8, dword_66BC8, start_time - dword_66BC8, 15 * dword_71E74);
      switch_pools(0);
    }
    update_time_with_delay(&current_time_spec, 5000);
    get_monotonic_time(&current_time_spec);
  }
  current_worker_id = 0;
  while ( 1 )
  {
    LODWORD(is_worker_active) = (unsigned __int8)byte_66BA8;
    current_worker_data = *(_DWORD **)(dword_70E5C + 4 * current_worker_id);
    if ( !byte_66BA8 && !dword_70D08 )
      break;
LABEL_13:
    if ( main_loop_counter == 120 )
    {
      current_hash_count = *((_QWORD *)current_worker_data + 5);
      process_result = convert_float_to_int((int)current_hash_count - current_worker_data[38]);
      previous_hashrate = *((double *)current_worker_data + 18);
      current_worker_data[38] = current_hash_count;
      current_hashrate = (previous_hashrate + process_result * 0.63) / 1.63;
      *((double *)current_worker_data + 18) = current_hashrate;
      current_worker_data[39] = (int)current_hashrate;
    }
    if ( current_worker_data[25] && !*((_BYTE *)current_worker_data + 284) )
    {
      if ( process_mining_protocol(current_worker_data, 1, is_worker_active) )
      {
        LODWORD(process_result) = reset_thread_signal(current_worker_data, (char *)current_worker_data + 97);
        if ( LODWORD(process_result) )
          LODWORD(process_result) = log_pool_status(current_worker_data);
      }
      else
      {
        LODWORD(process_result) = get_hardware_timestamp(current_worker_data + 34, unused4, unused5, unused6);
      }
      if ( !*((_BYTE *)current_worker_data + 97) && !dword_66A44 )
      {
        worker_frequency = current_worker_data[1];
        LODWORD(process_result) = get_control_priority(LODWORD(process_result));
        if ( worker_frequency < SLODWORD(process_result) )
        {
          HIDWORD(process_result) = dword_66150;
          if ( start_time - current_worker_data[34] > dword_66150 )
          {
            if ( byte_70CE8 || byte_66640 || dword_657B8 > 3 )
            {
              snprintf(
                log_buffer,
                2048u,
                "Pool %d %s stable for >%d seconds",
                *current_worker_data,
                (const char *)current_worker_data[41],
                dword_66150);
              log_event(4, log_buffer, 0);
            }
            LODWORD(process_result) = switch_pools(0);
          }
        }
      }
    }
    if ( dword_70DB8 <= ++current_worker_id )
      goto LABEL_19;
  }
  worker_mutex_lock = (pthread_mutex_t *)(current_worker_data + 47);
  get_hardware_timestamp(
    &last_active_time,
    HIDWORD(process_result),
    (unsigned __int8)byte_66BA8,
    current_worker_data + 47);
  if ( pthread_mutex_lock((pthread_mutex_t *)(current_worker_data + 47)) )
  {
    lock_result1 = _errno_location();
    snprintf(
      log_buffer,
      2048u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *lock_result1,
      "cgminer.c",
      "reap_curl",
      10217);
    goto LABEL_90;
  }
  curl_array_ptr_old = (int *)current_worker_data[86];
  curl_request_timestamp = *curl_array_ptr_old;
  is_last_curl = current_worker_data + 86 == curl_array_ptr_old;
  curl_array_ptr = curl_array_ptr_old - 1;
  previous_curl_node_timestamp = curl_request_timestamp - 4;
  if ( is_last_curl )
  {
    if ( pthread_mutex_unlock(worker_mutex_lock) )
      goto LABEL_96;
    ((void (*)(void))off_658DC)();
  }
  else
  {
    current_active_curls = current_worker_data[72];
    if ( current_active_curls > 1 )
    {
      unused7 = current_worker_id;
      pruned_curls_count = 0;
      while ( 1 )
      {
        if ( last_active_time - curl_array_ptr[3] > 300 )
        {
          current_worker_data[72] = current_active_curls - 1;
          ++pruned_curls_count;
          curl_node_ndelete_index = curl_array_ptr[1];
          next_curl_node = (_DWORD *)curl_array_ptr[2];
          *(_DWORD *)(curl_node_ndelete_index + 4) = next_curl_node;
          *next_curl_node = curl_node_ndelete_index;
          free(curl_array_ptr);
        }
        if ( current_worker_data + 86 == (_DWORD *)(previous_curl_node_timestamp + 4) )
          break;
        current_active_curls = current_worker_data[72];
        curl_array_ptr = (int *)previous_curl_node_timestamp;
        if ( current_active_curls <= 1 )
        {
          current_worker_id = unused7;
          goto LABEL_41;
        }
        previous_curl_node_timestamp = *(_DWORD *)(previous_curl_node_timestamp + 4) - 4;
      }
      num_pruned_curls = pruned_curls_count;
      current_worker_id = unused7;
      if ( pthread_mutex_unlock(worker_mutex_lock) )
      {
LABEL_96:
        lock_result3 = _errno_location();
        function_name_str = "reap_curl";
        line_number = 10235;
LABEL_93:
        snprintf(
          log_buffer,
          2048u,
          "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
          *lock_result3,
          "cgminer.c",
          function_name_str,
          line_number);
LABEL_90:
        log_event(3, log_buffer, 1);
        shutdown_miner(1, 1);
      }
      ((void (*)(void))off_658DC)();
      if ( num_pruned_curls && byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
      {
        plural_char = "";
        if ( num_pruned_curls != 1 )
          plural_char = "s";
        snprintf(
          log_buffer,
          2048u,
          "Reaped %d curl%s from pool %d",
          num_pruned_curls,
          plural_char,
          *current_worker_data);
        log_event(7, log_buffer, 0);
      }
    }
  }
LABEL_41:
  mutex = (pthread_mutex_t *)time(0);
  pruned_shares_count = pthread_mutex_lock(&stru_66BAC);
  if ( pruned_shares_count )
  {
    lock_result2 = _errno_location();
    snprintf(
      log_buffer,
      2048u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *lock_result2,
      "cgminer.c",
      "prune_stratum_shares",
      10253);
    goto LABEL_90;
  }
  first_curl_node = (_DWORD *)dword_66BC4;
  if ( !dword_66BC4 )
  {
    if ( pthread_mutex_unlock(&stru_66BAC) )
    {
LABEL_92:
      lock_result3 = _errno_location();
      function_name_str = "prune_stratum_shares";
      line_number = 10266;
      goto LABEL_93;
    }
    LODWORD(process_result) = ((int (*)(void))off_658DC)();
    goto LABEL_13;
  }
  next_node = *(_DWORD **)(dword_66BC4 + 8);
  if ( current_worker_data == *(_DWORD **)(*(_DWORD *)(dword_66BC4 + 36) + 260) )
    goto LABEL_46;
LABEL_44:
  if ( !next_node )
  {
LABEL_60:
    if ( pthread_mutex_unlock(&stru_66BAC) )
      goto LABEL_92;
    LODWORD(process_result) = ((int (*)(void))off_658DC)();
    if ( pruned_shares_count )
    {
      if ( byte_70CE8 || byte_66640 || dword_657B8 > 3 )
      {
        snprintf(
          log_buffer,
          2048u,
          "Lost %d shares due to no stratum share response from pool %d",
          pruned_shares_count,
          *current_worker_data);
        log_event(4, log_buffer, 0);
      }
      HIDWORD(process_result) = &qword_74220;
      is_worker_active = qword_74220;
      LODWORD(process_result) = current_worker_data[30] + pruned_shares_count;
      current_worker_data[30] = LODWORD(process_result);
      qword_74220 = is_worker_active + pruned_shares_count;
    }
    goto LABEL_13;
  }
  while ( 1 )
  {
    first_curl_node = next_node;
    next_node = (_DWORD *)next_node[2];
    if ( current_worker_data != *(_DWORD **)(first_curl_node[9] + 260) )
      goto LABEL_44;
LABEL_46:
    if ( (int)mutex <= first_curl_node[11] + 120 )
      goto LABEL_44;
    previous_curl_node = first_curl_node[1];
    curl_data_head = (int **)dword_66BC4;
    head_curl_data = *(_DWORD *)dword_66BC4;
    if ( previous_curl_node )
      break;
    curl_node_ldelete_index = first_curl_node[2];
    if ( curl_node_ldelete_index )
    {
      next_node_index = *(_DWORD *)(head_curl_data + 20);
      if ( first_curl_node != (_DWORD *)(*(_DWORD *)(head_curl_data + 16) - next_node_index) )
        goto LABEL_81;
LABEL_82:
      *(_DWORD *)(head_curl_data + 16) = previous_curl_node + next_node_index;
      previous_curl_node = first_curl_node[1];
      if ( !previous_curl_node )
      {
        curl_node_ldelete_index = first_curl_node[2];
LABEL_81:
        curl_data_head = (int **)curl_node_ldelete_index;
        dword_66BC4 = curl_node_ldelete_index;
LABEL_50:
        next_next_index = first_curl_node[2];
        if ( next_next_index )
          *(_DWORD *)(next_next_index + (*curl_data_head)[5] + 4) = first_curl_node[1];
        next_bucket_index = 3 * (((*curl_data_head)[1] - 1) & first_curl_node[7]);
        bucket_start_index = **curl_data_head + 12 * (((*curl_data_head)[1] - 1) & first_curl_node[7]);
        --*(_DWORD *)(bucket_start_index + 4);
        array_start_index = **curl_data_head;
        if ( *(_DWORD **)(array_start_index + 4 * next_bucket_index) == first_curl_node )
          *(_DWORD *)(array_start_index + 4 * next_bucket_index) = first_curl_node[4];
        previous_node = first_curl_node[3];
        if ( previous_node )
          *(_DWORD *)(previous_node + 16) = first_curl_node[4];
        next_node_ptr = first_curl_node[4];
        if ( next_node_ptr )
          *(_DWORD *)(next_node_ptr + 12) = first_curl_node[3];
        --(*curl_data_head)[3];
        goto LABEL_59;
      }
      next_node_index = (*curl_data_head)[5];
LABEL_49:
      *(_DWORD *)(previous_curl_node + next_node_index + 8) = first_curl_node[2];
      goto LABEL_50;
    }
    free_memory_target = (void **)dword_66BC4;
    free(*(void **)head_curl_data);
    free(*free_memory_target);
    dword_66BC4 = 0;
LABEL_59:
    ++pruned_shares_count;
    clear_miner_data_if_not_null(first_curl_node + 9, "cgminer.c", "prune_stratum_shares", 10260);
    free(first_curl_node);
    if ( !next_node )
      goto LABEL_60;
  }
  next_node_index = *(_DWORD *)(head_curl_data + 20);
  if ( first_curl_node == (_DWORD *)(*(_DWORD *)(head_curl_data + 16) - next_node_index) )
    goto LABEL_82;
  goto LABEL_49;
}
// 308B0: variable 'unused1' is possibly undefined
// 308B0: variable 'unused2' is possibly undefined
// 308B0: variable 'unused3_pointer' is possibly undefined
// 3098C: variable 'is_worker_active' is possibly undefined
// 3099C: variable 'unused4' is possibly undefined
// 3099C: variable 'unused5' is possibly undefined
// 3099C: variable 'unused6' is possibly undefined
// 30A88: variable 'process_result' is possibly undefined
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 1F5C4: using guessed type int __fastcall sub_1F5C4(_DWORD, _DWORD, _DWORD, _DWORD);
// 1F680: using guessed type int __fastcall sub_1F680(_DWORD, _DWORD);
// 21DB8: using guessed type int __fastcall sub_21DB8(_DWORD);
// 285A8: using guessed type int __fastcall sub_285A8(_DWORD);
// 28FFC: using guessed type int __fastcall sub_28FFC(_DWORD, _DWORD, _DWORD, _DWORD);
// 2AB30: using guessed type void __fastcall __noreturn sub_2AB30(_DWORD, _DWORD);
// 2B518: using guessed type int __fastcall sub_2B518(_DWORD, _DWORD);
// 2E47C: using guessed type int __fastcall sub_2E47C(_DWORD);
// 2E614: using guessed type int __fastcall sub_2E614(_DWORD);
// 2E6C0: using guessed type int __fastcall sub_2E6C0(_DWORD);
// 30264: using guessed type int __fastcall sub_30264(_DWORD);
// 4930C: using guessed type double __fastcall sub_4930C(_DWORD);
// 657B8: using guessed type int dword_657B8;
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);
// 66150: using guessed type int dword_66150;
// 66640: using guessed type char byte_66640;
// 66641: using guessed type char byte_66641;
// 66A44: using guessed type int dword_66A44;
// 66BA8: using guessed type char byte_66BA8;
// 66BC4: using guessed type int dword_66BC4;
// 66BC8: using guessed type int dword_66BC8;
// 70CE8: using guessed type char byte_70CE8;
// 70D08: using guessed type int dword_70D08;
// 70DB8: using guessed type int dword_70DB8;
// 70E5C: using guessed type int dword_70E5C;
// 71E74: using guessed type int dword_71E74;
// 74220: using guessed type __int64 qword_74220;

//----- (00031024) --------------------------------------------------------
__int64 *__fastcall sub_31024(int a1)
{
  int v2; // r8
  int v3; // r4
  int v4; // r5
  double v5; // d8
  int v6; // r0
  void **v7; // r11
  int v8; // r1
  __int64 v9; // r2
  int v10; // r3
  int v11; // r2
  __int64 v12; // r2
  __int64 *result; // r0
  double v14; // d6
  double v15; // d8
  __int64 v16; // r4
  int v17; // r8
  int *v18; // r0
  int *v19; // r0
  char s[2096]; // [sp+18h] [bp-830h] BYREF

  v2 = pthread_mutex_lock(&stru_66BAC);
  if ( v2 )
  {
    v18 = _errno_location();
    snprintf(
      s,
      2048u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v18,
      "cgminer.c",
      "clear_stratum_shares",
      7406);
    goto LABEL_36;
  }
  v3 = dword_66BC4;
  if ( !dword_66BC4 )
  {
    if ( !pthread_mutex_unlock(&stru_66BAC) )
      return (__int64 *)off_658DC(0);
    goto LABEL_37;
  }
  v4 = *(_DWORD *)(dword_66BC4 + 8);
  v5 = 0.0;
  if ( *(_DWORD *)(*(_DWORD *)(dword_66BC4 + 36) + 260) == a1 )
    goto LABEL_6;
LABEL_4:
  if ( v4 )
  {
    while ( 1 )
    {
      v3 = v4;
      v4 = *(_DWORD *)(v4 + 8);
      if ( *(_DWORD *)(*(_DWORD *)(v3 + 36) + 260) != a1 )
        goto LABEL_4;
LABEL_6:
      v6 = *(_DWORD *)(v3 + 4);
      v7 = (void **)dword_66BC4;
      v8 = *(_DWORD *)dword_66BC4;
      if ( v6 )
        break;
      LODWORD(v9) = *(_DWORD *)(v3 + 8);
      if ( (_DWORD)v9 )
      {
        HIDWORD(v9) = *(_DWORD *)(v8 + 20);
        if ( v3 != *(_DWORD *)(v8 + 16) - HIDWORD(v9) )
          goto LABEL_30;
LABEL_28:
        *(_DWORD *)(v8 + 16) = v6 + HIDWORD(v9);
        v6 = *(_DWORD *)(v3 + 4);
        if ( !v6 )
        {
          LODWORD(v9) = *(_DWORD *)(v3 + 8);
LABEL_30:
          HIDWORD(v9) = v9;
          v7 = (void **)v9;
          dword_66BC4 = v9;
LABEL_9:
          LODWORD(v9) = *v7;
          if ( HIDWORD(v9) )
          {
            *(_DWORD *)(HIDWORD(v9) + *(_DWORD *)(v9 + 20) + 4) = *(_DWORD *)(v3 + 4);
            LODWORD(v9) = *v7;
          }
          HIDWORD(v9) = 3 * ((*(_DWORD *)(v9 + 4) - 1) & *(_DWORD *)(v3 + 28));
          --*(_DWORD *)(*(_DWORD *)v9 + 4 * HIDWORD(v9) + 4);
          LODWORD(v9) = *(_DWORD *)*v7;
          if ( *(_DWORD *)(v9 + 4 * HIDWORD(v9)) == v3 )
            *(_DWORD *)(v11 + 4 * v10) = *(_DWORD *)(v3 + 16);
          v12 = *(_QWORD *)(v3 + 12);
          if ( (_DWORD)v12 )
          {
            *(_DWORD *)(v12 + 16) = HIDWORD(v12);
            HIDWORD(v12) = *(_DWORD *)(v3 + 16);
          }
          if ( HIDWORD(v12) )
            *(_DWORD *)(HIDWORD(v12) + 12) = *(_DWORD *)(v3 + 12);
          --*((_DWORD *)*v7 + 3);
          goto LABEL_18;
        }
        HIDWORD(v9) = *((_DWORD *)*v7 + 5);
LABEL_8:
        *(_DWORD *)(v6 + HIDWORD(v9) + 8) = *(_DWORD *)(v3 + 8);
        HIDWORD(v9) = *(_DWORD *)(v3 + 8);
        goto LABEL_9;
      }
      free(*(void **)v8);
      free(*v7);
      dword_66BC4 = 0;
LABEL_18:
      ++v2;
      v5 = v5 + *(double *)(*(_DWORD *)(v3 + 36) + 376);
      clear_miner_data_if_not_null(v3 + 36, "cgminer.c", "clear_stratum_shares", 7414);
      --*(_DWORD *)(a1 + 732);
      free((void *)v3);
      if ( !v4 )
        goto LABEL_19;
    }
    v9 = *(_QWORD *)(v8 + 16);
    if ( v3 == (_DWORD)v9 - HIDWORD(v9) )
      goto LABEL_28;
    goto LABEL_8;
  }
LABEL_19:
  if ( pthread_mutex_unlock(&stru_66BAC) )
  {
LABEL_37:
    v19 = _errno_location();
    snprintf(
      s,
      2048u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v19,
      "cgminer.c",
      "clear_stratum_shares",
      7420);
LABEL_36:
    log_event(3, s, 1);
    shutdown_miner(1, 1);
  }
  result = (__int64 *)off_658DC(0);
  if ( v2 )
  {
    if ( byte_70CE8 || byte_66640 || dword_657B8 > 3 )
    {
      snprintf(s, 2048u, "Lost %d shares due to stratum disconnect on pool %d", v2, *(_DWORD *)a1);
      log_event(4, s, 0);
    }
    result = &qword_74220;
    v14 = *(double *)(a1 + 88) + v5;
    v15 = dbl_70E50 + v5;
    v16 = qword_74220 + v2;
    v17 = *(_DWORD *)(a1 + 120) + v2;
    *(double *)(a1 + 88) = v14;
    qword_74220 = v16;
    *(_DWORD *)(a1 + 120) = v17;
    dbl_70E50 = v15;
  }
  return result;
}
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 1DA28: using guessed type int sub_1DA28(void);
// 28FFC: using guessed type int __fastcall sub_28FFC(_DWORD, _DWORD, _DWORD, _DWORD);
// 2AB30: using guessed type void __fastcall __noreturn sub_2AB30(_DWORD, _DWORD);
// 657B8: using guessed type int dword_657B8;
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);
// 66640: using guessed type char byte_66640;
// 66BC4: using guessed type int dword_66BC4;
// 70CE8: using guessed type char byte_70CE8;
// 70E50: using guessed type double dbl_70E50;
// 74220: using guessed type __int64 qword_74220;

//----- (000313C0) --------------------------------------------------------
int __fastcall pop_hash(int arg_hash_node)
{
  int unused1; // r1
  int unused2; // r2
  int temp_hash_node; // r3
  int temp_var_for_hash_node; // r2
  int hash_node_loop_counter; // r1
  int next_hash_node; // r3
  int offset; // r12
  int current_hash_node_addr; // r0
  int next_or_current_hash_node; // r1
  int v11; // r6
  _DWORD *hash_table_ptr; // r2
  int theta; // r3
  int var_theta; // r2
  int hash_bucket_addr; // r12
  int prev_hash_node; // r2
  int next_node; // r3
  int possible_next_node; // r0
  int *unlock_errno_location; // r0
  int *lock_errno_location; // r0
  struct timespec wait_time; // [sp+10h] [bp-828h] BYREF
  int timeval[2]; // [sp+18h] [bp-820h] BYREF
  char error_message[2072]; // [sp+20h] [bp-818h] BYREF

  if ( pthread_mutex_lock((pthread_mutex_t *)dword_66A80) )
  {
    unlock_errno_location = _errno_location();
    snprintf(
      error_message,
      2048u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *unlock_errno_location,
      "cgminer.c",
      "hash_pop",
      8231);
    goto LABEL_58;
  }
  temp_hash_node = dword_66B5C;
  if ( !dword_66B5C || (temp_hash_node = *(_DWORD *)(*(_DWORD *)(dword_66B5C + 344) + 12)) == 0 )
  {
    if ( !arg_hash_node )
      goto LABEL_35;
    while ( 1 )
    {
      get_hardware_timestamp(timeval, unused1, unused2, temp_hash_node);
      wait_time.tv_sec = timeval[0] + 10;
      wait_time.tv_nsec = 1000 * timeval[1];
      pthread_cond_signal(&stru_70DC0);
      if ( pthread_cond_timedwait((pthread_cond_t *)(dword_72EB8 + 40), (pthread_mutex_t *)dword_66A80, &wait_time) )
      {
        if ( !byte_66AD8 )
        {
          unused2 = 1;
          byte_66AD8 = 1;
          if ( byte_70CE8 || byte_66640 || dword_657B8 > 3 )
          {
            strcpy(error_message, "Waiting for work to be available from pools.");
            log_event(4, error_message, 0);
          }
        }
      }
      temp_hash_node = dword_66B5C;
      if ( dword_66B5C )
      {
        temp_hash_node = *(_DWORD *)(*(_DWORD *)(dword_66B5C + 344) + 12);
        if ( temp_hash_node )
          break;
      }
    }
  }
  if ( byte_66AD8 )
  {
    if ( byte_70CE8 || byte_66640 || dword_657B8 > 3 )
    {
      strcpy(error_message, "Work available from pools, resuming.");
      log_event(4, error_message, 0);
    }
    temp_var_for_hash_node = dword_66B5C;
    byte_66AD8 = 0;
    if ( !dword_66B5C )
      goto LABEL_43;
  }
  else
  {
    temp_var_for_hash_node = dword_66B5C;
  }
  hash_node_loop_counter = *(_DWORD *)(temp_var_for_hash_node + 344);
  if ( *(_DWORD *)(hash_node_loop_counter + 12) <= dword_66BD0
    || *(_BYTE *)(temp_var_for_hash_node + 273)
    || !*(_DWORD *)(temp_var_for_hash_node + 276) )
  {
    arg_hash_node = temp_var_for_hash_node;
    goto LABEL_17;
  }
  arg_hash_node = *(_DWORD *)(temp_var_for_hash_node + 352);
  if ( !arg_hash_node )
LABEL_43:
    __und(0);
  while ( !*(_BYTE *)(arg_hash_node + 273) )
  {
    possible_next_node = *(_DWORD *)(arg_hash_node + 352);
    if ( !*(_DWORD *)(arg_hash_node + 276) )
      break;
    arg_hash_node = *(_DWORD *)(arg_hash_node + 352);
    if ( !possible_next_node )
      goto LABEL_43;
  }
LABEL_17:
  next_hash_node = *(_DWORD *)(arg_hash_node + 348);
  if ( next_hash_node )
  {
    offset = *(_DWORD *)(hash_node_loop_counter + 20);
    current_hash_node_addr = arg_hash_node + 344;
    if ( arg_hash_node != *(_DWORD *)(hash_node_loop_counter + 16) - offset )
    {
LABEL_19:
      next_or_current_hash_node = dword_66B5C;
      *(_DWORD *)(next_hash_node + offset + 8) = *(_DWORD *)(arg_hash_node + 352);
      v11 = *(_DWORD *)(arg_hash_node + 352);
LABEL_20:
      hash_table_ptr = *(_DWORD **)(next_or_current_hash_node + 344);
      if ( v11 )
      {
        *(_DWORD *)(v11 + hash_table_ptr[5] + 4) = *(_DWORD *)(arg_hash_node + 348);
        hash_table_ptr = *(_DWORD **)(next_or_current_hash_node + 344);
      }
      theta = 12 * ((hash_table_ptr[1] - 1) & *(_DWORD *)(arg_hash_node + 372));
      --*(_DWORD *)(*hash_table_ptr + theta + 4);
      var_theta = **(_DWORD **)(next_or_current_hash_node + 344);
      hash_bucket_addr = *(_DWORD *)(var_theta + theta);
      if ( hash_bucket_addr == current_hash_node_addr )
      {
        next_or_current_hash_node = *(_DWORD *)(arg_hash_node + 360);
        *(_DWORD *)(var_theta + theta) = next_or_current_hash_node;
      }
      prev_hash_node = *(_DWORD *)(arg_hash_node + 356);
      next_node = *(_DWORD *)(arg_hash_node + 360);
      if ( hash_bucket_addr == current_hash_node_addr )
        next_or_current_hash_node = dword_66B5C;
      if ( prev_hash_node )
      {
        *(_DWORD *)(prev_hash_node + 16) = next_node;
        next_node = *(_DWORD *)(arg_hash_node + 360);
      }
      if ( next_node )
        *(_DWORD *)(next_node + 12) = *(_DWORD *)(arg_hash_node + 356);
      --*(_DWORD *)(*(_DWORD *)(next_or_current_hash_node + 344) + 12);
      goto LABEL_31;
    }
LABEL_47:
    *(_DWORD *)(hash_node_loop_counter + 16) = next_hash_node + offset;
    next_hash_node = *(_DWORD *)(arg_hash_node + 348);
    if ( next_hash_node )
    {
      offset = *(_DWORD *)(*(_DWORD *)(temp_var_for_hash_node + 344) + 20);
      goto LABEL_19;
    }
    v11 = *(_DWORD *)(arg_hash_node + 352);
LABEL_46:
    next_or_current_hash_node = v11;
    dword_66B5C = v11;
    goto LABEL_20;
  }
  v11 = *(_DWORD *)(arg_hash_node + 352);
  if ( v11 )
  {
    offset = *(_DWORD *)(hash_node_loop_counter + 20);
    current_hash_node_addr = arg_hash_node + 344;
    if ( arg_hash_node != *(_DWORD *)(hash_node_loop_counter + 16) - offset )
      goto LABEL_46;
    goto LABEL_47;
  }
  free(*(void **)hash_node_loop_counter);
  free(*(void **)(dword_66B5C + 344));
  dword_66B5C = 0;
LABEL_31:
  if ( !*(_BYTE *)(arg_hash_node + 273) && *(_DWORD *)(arg_hash_node + 276) )
    --dword_66BD0;
  pthread_cond_signal(&stru_70DC0);
  pthread_cond_signal((pthread_cond_t *)(dword_72EB8 + 40));
  dword_73FD8 = time(0);
LABEL_35:
  if ( pthread_mutex_unlock((pthread_mutex_t *)dword_66A80) )
  {
    lock_errno_location = _errno_location();
    snprintf(
      error_message,
      2048u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *lock_errno_location,
      "cgminer.c",
      "hash_pop",
      8303);
LABEL_58:
    log_event(3, error_message, 1);
    shutdown_miner(1, 1);
  }
  off_658DC(0);
  return arg_hash_node;
}
// 3142C: variable 'unused1' is possibly undefined
// 3142C: variable 'unused2' is possibly undefined
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 1DA28: using guessed type int sub_1DA28(void);
// 1F5C4: using guessed type int __fastcall sub_1F5C4(_DWORD, _DWORD, _DWORD, _DWORD);
// 2AB30: using guessed type void __fastcall __noreturn sub_2AB30(_DWORD, _DWORD);
// 657B8: using guessed type int dword_657B8;
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);
// 66640: using guessed type char byte_66640;
// 66A80: using guessed type int dword_66A80;
// 66AD8: using guessed type char byte_66AD8;
// 66B5C: using guessed type int dword_66B5C;
// 66BD0: using guessed type int dword_66BD0;
// 70CE8: using guessed type char byte_70CE8;
// 70DC0: using guessed type pthread_cond_t stru_70DC0;
// 72EB8: using guessed type int dword_72EB8;
// 73FD8: using guessed type int dword_73FD8;

//----- (00031858) --------------------------------------------------------
int __fastcall run_mining_thread(_DWORD *miner_instance, int arg2, int protocol_id)
{
  int pool_switch_flag; // r5
  pthread_t current_thread; // r0
  int pool_id; // r5
  int *errno_location_lock; // r0
  int *errno_location_wrlock; // r0
  int *errno_location_rwunlock; // r0
  int *errno_location_mutexunlock; // r0
  char error_message[2064]; // [sp+10h] [bp-810h] BYREF

  if ( !*((_BYTE *)miner_instance + 107) )
  {
    current_thread = pthread_self();
    pthread_detach(current_thread);
  }
  pool_switch_flag = *((unsigned __int8 *)miner_instance + 105);
  if ( *((_BYTE *)miner_instance + 105) )
    return 0;
  while ( !process_mining_protocol(miner_instance, 0, protocol_id) )
  {
    check_and_switch_pool(miner_instance);
    if ( *((_BYTE *)miner_instance + 107) )
      goto LABEL_16;
    sleep(30u);
    if ( *((_BYTE *)miner_instance + 105) )
      return 0;
  }
  reset_thread_signal(miner_instance, (char *)miner_instance + 97);
  if ( pthread_mutex_lock(&stru_740A0) )
  {
    errno_location_lock = _errno_location();
    snprintf(
      error_message,
      2048u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *errno_location_lock,
      "cgminer.c",
      "test_pool_thread",
      10836);
    goto LABEL_23;
  }
  if ( pthread_rwlock_wrlock(&rwlock) )
  {
    errno_location_wrlock = _errno_location();
    snprintf(
      error_message,
      2048u,
      "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *errno_location_wrlock,
      "cgminer.c",
      "test_pool_thread",
      10836);
    goto LABEL_23;
  }
  if ( !byte_66964 )
  {
    pool_id = *miner_instance;
    dword_66AD4 = (int)miner_instance;
    byte_66964 = 1;
    pool_switch_flag = pool_id != 0;
  }
  if ( pthread_rwlock_unlock(&rwlock) )
  {
    errno_location_rwunlock = _errno_location();
    snprintf(
      error_message,
      2048u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *errno_location_rwunlock,
      "cgminer.c",
      "test_pool_thread",
      10850);
    goto LABEL_23;
  }
  if ( pthread_mutex_unlock(&stru_740A0) )
  {
    errno_location_mutexunlock = _errno_location();
    snprintf(
      error_message,
      2048u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *errno_location_mutexunlock,
      "cgminer.c",
      "test_pool_thread",
      10850);
LABEL_23:
    log_event(3, error_message, 1);
    shutdown_miner(1, 1);
  }
  off_658DC(0);
  if ( pool_switch_flag && (byte_70CE8 || byte_66640 || dword_657B8 > 4) )
  {
    snprintf(
      error_message,
      2048u,
      "Switching to pool %d %s - first alive pool",
      *miner_instance,
      (const char *)miner_instance[41]);
    log_event(5, error_message, 0);
  }
  log_pool_status(miner_instance);
  switch_pools(0);
LABEL_16:
  *((_BYTE *)miner_instance + 284) = 0;
  return 0;
}
// 318B4: variable 'protocol_id' is possibly undefined
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 1DA28: using guessed type int sub_1DA28(void);
// 2AB30: using guessed type void __fastcall __noreturn sub_2AB30(_DWORD, _DWORD);
// 2B518: using guessed type int __fastcall sub_2B518(_DWORD, _DWORD);
// 2E6C0: using guessed type int __fastcall sub_2E6C0(_DWORD);
// 306E8: using guessed type int __fastcall sub_306E8(_DWORD);
// 657B8: using guessed type int dword_657B8;
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);
// 66640: using guessed type char byte_66640;
// 66964: using guessed type char byte_66964;
// 66AD4: using guessed type int dword_66AD4;
// 70CE8: using guessed type char byte_70CE8;
// 740A0: using guessed type pthread_mutex_t stru_740A0;

//----- (00031AE8) --------------------------------------------------------
void __fastcall log_share_info(const char *worker_name, _DWORD *share_data)
{
  int chip_status_base; // r10
  int frequency_info; // r11
  char *miner_type; // r9
  char *asic_boost; // r8
  char *hash; // r7
  int log_length; // r4
  size_t write_result; // r4
  const char *error_message; // r12
  int error_data_1; // r0
  int error_data_2; // r1
  int error_data_3; // r2
  int error_data_4; // r3
  _DWORD *error_data_ptr; // r12
  int error_data_5; // r1
  int *error_location; // r0
  int mutex_error_code; // r3
  int share_id; // [sp+20h] [bp-C30h]
  int chip_status; // [sp+24h] [bp-C2Ch]
  char log_buffer[1024]; // [sp+28h] [bp-C28h] BYREF
  _DWORD error_buffer[5]; // [sp+428h] [bp-828h] BYREF
  __int16 error_final_data; // [sp+43Ch] [bp-814h]

  if ( !dword_6685C )
    return;
  chip_status = share_data[64];
  chip_status_base = *(_DWORD *)(get_thread_metadata(chip_status) + 36);
  frequency_info = share_data[65];
  share_id = share_data[108];
  miner_type = (char *)binary_to_hex_string(share_data + 40, 32);
  asic_boost = (char *)binary_to_hex_string(share_data + 48, 32);
  hash = (char *)binary_to_hex_string(share_data, 128);
  log_length = snprintf(
                 log_buffer,
                 1024u,
                 "%lu,%s,%s,%s,%s%u,%u,%s,%s\n",
                 share_id,
                 worker_name,
                 miner_type,
                 *(const char **)(frequency_info + 164),
                 *(const char **)(*(_DWORD *)(chip_status_base + 4) + 8),
                 *(_DWORD *)(chip_status_base + 8),
                 chip_status,
                 asic_boost,
                 hash);
  free(miner_type);
  free(asic_boost);
  free(hash);
  if ( log_length >= 1024 )
  {
    log_buffer[1023] = 0;
    goto LABEL_5;
  }
  if ( log_length >= 0 )
  {
LABEL_5:
    if ( pthread_mutex_lock(&stru_66BD4) )
    {
      error_location = _errno_location();
      snprintf(
        (char *)error_buffer,
        2048u,
        "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
        *error_location,
        "cgminer.c",
        "sharelog",
        682);
    }
    else
    {
      write_result = fwrite(log_buffer, log_length, 1u, (FILE *)dword_6685C);
      fflush((FILE *)dword_6685C);
      if ( !pthread_mutex_unlock(&stru_66BD4) )
      {
        off_658DC(0);
        if ( write_result != 1 && (byte_70CE8 || byte_66640 || dword_657B8 > 2) )
        {
          error_message = "sharelog fwrite error";
LABEL_12:
          error_data_1 = *(_DWORD *)error_message;
          error_data_2 = *((_DWORD *)error_message + 1);
          error_data_3 = *((_DWORD *)error_message + 2);
          error_data_4 = *((_DWORD *)error_message + 3);
          error_data_ptr = error_message + 16;
          error_buffer[0] = error_data_1;
          error_buffer[1] = error_data_2;
          error_buffer[2] = error_data_3;
          error_buffer[3] = error_data_4;
          error_data_5 = error_data_ptr[1];
          error_buffer[4] = *error_data_ptr;
          error_final_data = error_data_5;
          log_event(3, error_buffer, 0);
          return;
        }
        return;
      }
      mutex_error_code = *_errno_location();
      snprintf(
        (char *)error_buffer,
        2048u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        mutex_error_code,
        "cgminer.c",
        "sharelog",
        685);
    }
    log_event(3, error_buffer, 1);
    shutdown_miner(1, 1);
  }
  if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
  {
    error_message = "sharelog printf error";
    goto LABEL_12;
  }
}
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 1DA28: using guessed type int sub_1DA28(void);
// 1E9B4: using guessed type int __fastcall sub_1E9B4(_DWORD, _DWORD);
// 2AB30: using guessed type void __fastcall __noreturn sub_2AB30(_DWORD, _DWORD);
// 2DF8C: using guessed type int __fastcall sub_2DF8C(_DWORD);
// 657B8: using guessed type int dword_657B8;
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);
// 66640: using guessed type char byte_66640;
// 6685C: using guessed type int dword_6685C;
// 70CE8: using guessed type char byte_70CE8;

//----- (00031D90) --------------------------------------------------------
__int64 __fastcall generate_stratum_work(int miner_data, int work_data)
{
  pthread_mutex_t *miner_mutex; // r8
  size_t shared_mem_value; // r11
  int rwlock_1_size; // lr
  int rwlock_2_size; // r0
  int shared_mem_low32; // r3
  int shared_mem_high32; // r2
  int loop_counter; // r5
  const void *data_offset; // r1
  char *src_ptr; // r2
  char *dest_ptr; // r0
  unsigned int data_value; // t1
  int last_result; // r0
  char *stratum_merkle; // r9
  const char *stratum_merkle_const; // r0
  char *stratum_header; // r8
  int *errno_lock; // r0
  const char *error_message; // r2
  int errno_value; // r3
  int *errno_wrlock; // r0
  int *errno_rwlock_unlock; // r0
  int *errno_rdlock; // r0
  int *errno_mutex_unlock; // r0
  int *errno_rwlock_rdunlock; // r0
  int error_line; // [sp+8h] [bp-8A0h]
  __int64 data_64bit; // [sp+18h] [bp-890h] BYREF
  char src_data_32bit[28]; // [sp+20h] [bp-888h] BYREF
  char some_data_array; // [sp+3Ch] [bp-86Ch] BYREF
  char calculated_data_array[28]; // [sp+40h] [bp-868h] BYREF
  int end_marker; // [sp+5Ch] [bp-84Ch] BYREF
  char v34[32]; // [sp+60h] [bp-848h] BYREF
  char s[2088]; // [sp+80h] [bp-828h] BYREF

  miner_mutex = (pthread_mutex_t *)(miner_data + 212);
  if ( pthread_mutex_lock((pthread_mutex_t *)(miner_data + 212)) )
  {
    errno_lock = _errno_location();
    error_message = "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d";
    errno_value = *errno_lock;
    error_line = 8409;
LABEL_29:
    snprintf(s, 2048u, error_message, errno_value, "cgminer.c", "gen_stratum_work", error_line);
    goto LABEL_30;
  }
  if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(miner_data + 236)) )
  {
    errno_wrlock = _errno_location();
    error_message = "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d";
    errno_value = *errno_wrlock;
    error_line = 8409;
    goto LABEL_29;
  }
  shared_mem_value = *(_DWORD *)(miner_data + 632);
  rwlock_1_size = *(_DWORD *)(miner_data + 1568);
  rwlock_2_size = *(_DWORD *)(miner_data + 1576);
  data_64bit = *(_QWORD *)(miner_data + 624);
  log_memcpy_error(
    (void *)(rwlock_1_size + rwlock_2_size),
    &data_64bit,
    shared_mem_value,
    (int)"cgminer.c",
    (int)"gen_stratum_work",
    8414);
  shared_mem_low32 = *(_DWORD *)(miner_data + 624);
  shared_mem_high32 = *(_DWORD *)(miner_data + 628);
  ++*(_QWORD *)(miner_data + 624);
  *(_DWORD *)(work_data + 296) = shared_mem_low32;
  *(_DWORD *)(work_data + 300) = shared_mem_high32;
  *(_DWORD *)(work_data + 304) = *(_DWORD *)(miner_data + 632);
  if ( pthread_rwlock_unlock((pthread_rwlock_t *)(miner_data + 236)) )
  {
    errno_rwlock_unlock = _errno_location();
    error_message = "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d";
    errno_value = *errno_rwlock_unlock;
    error_line = 8420;
    goto LABEL_29;
  }
  if ( pthread_rwlock_rdlock((pthread_rwlock_t *)(miner_data + 236)) )
  {
    errno_rdlock = _errno_location();
    error_message = "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d";
    errno_value = *errno_rdlock;
    error_line = 8420;
    goto LABEL_29;
  }
  loop_counter = pthread_mutex_unlock(miner_mutex);
  if ( loop_counter )
  {
    errno_mutex_unlock = _errno_location();
    error_message = "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d";
    errno_value = *errno_mutex_unlock;
    error_line = 8420;
    goto LABEL_29;
  }
  initialize_and_process_data(*(_DWORD *)(miner_data + 1568), *(_DWORD *)(miner_data + 1572), (int)s);
  initialize_and_process_data((int)s, 32u, (int)src_data_32bit);
  log_memcpy_error(calculated_data_array, src_data_32bit, 32u, (int)"cgminer.c", (int)"gen_stratum_work", 8424);
  if ( *(int *)(miner_data + 1708) > 0 )
  {
    do
    {
      data_offset = *(const void **)(*(_DWORD *)(miner_data + 676) + 4 * loop_counter++);
      log_memcpy_error(v34, data_offset, 32u, (int)"cgminer.c", (int)"gen_stratum_work", 8428);
      initialize_and_process_data((int)calculated_data_array, 64u, (int)s);
      initialize_and_process_data((int)s, 32u, (int)src_data_32bit);
      log_memcpy_error(calculated_data_array, src_data_32bit, 32u, (int)"cgminer.c", (int)"gen_stratum_work", 8430);
    }
    while ( *(_DWORD *)(miner_data + 1708) > loop_counter );
  }
  src_ptr = &some_data_array;
  dest_ptr = (char *)&data_64bit + 4;
  do
  {
    data_value = *((_DWORD *)src_ptr + 1);
    src_ptr += 4;
    *((_DWORD *)dest_ptr + 1) = bswap32(data_value);
    dest_ptr += 4;
  }
  while ( &end_marker != (int *)src_ptr );
  log_memcpy_error(
    (void *)work_data,
    (const void *)(miner_data + 1580),
    112u,
    (int)"cgminer.c",
    (int)"gen_stratum_work",
    8439);
  log_memcpy_error((void *)(work_data + 36), src_data_32bit, 32u, (int)"cgminer.c", (int)"gen_stratum_work", 8440);
  *(_QWORD *)(work_data + 312) = *(_QWORD *)(miner_data + 1824);
  *(_DWORD *)(work_data + 288) = _strdup(*(const char **)(miner_data + 672));
  *(_DWORD *)(work_data + 320) = _strdup(*(const char **)(miner_data + 612));
  *(_DWORD *)(work_data + 308) = _strdup((const char *)(miner_data + 1804));
  if ( pthread_rwlock_unlock((pthread_rwlock_t *)(miner_data + 236)) )
  {
    errno_rwlock_rdunlock = _errno_location();
    snprintf(
      s,
      2048u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *errno_rwlock_rdunlock,
      "cgminer.c",
      "gen_stratum_work",
      8451);
LABEL_30:
    log_event(3, s, 1);
    shutdown_miner(1, 1);
  }
  off_658DC(0);
  if ( !byte_66641 )
    goto LABEL_12;
  stratum_merkle = binary_to_hex_string(work_data, 112);
  stratum_merkle_const = binary_to_hex_string((int)src_data_32bit, 32);
  stratum_header = (char *)stratum_merkle_const;
  if ( byte_66641 )
  {
    if ( !byte_70CE8 && !byte_66640 && dword_657B8 <= 6 )
      goto LABEL_21;
    snprintf(s, 2048u, "Generated stratum merkle %s", stratum_merkle_const);
    log_event(7, s, 0);
    if ( !byte_66641 )
      goto LABEL_27;
    if ( !byte_70CE8 )
    {
LABEL_21:
      if ( !byte_66640 && dword_657B8 <= 6 )
        goto LABEL_24;
    }
    snprintf(s, 2048u, "Generated stratum header %s", stratum_merkle);
    log_event(7, s, 0);
    if ( byte_66641 )
    {
      if ( byte_70CE8 )
      {
LABEL_26:
        snprintf(
          s,
          2048u,
          "Work job_id %s nonce2 %llu ntime %s",
          *(const char **)(work_data + 288),
          *(_QWORD *)(work_data + 296),
          *(const char **)(work_data + 308));
        log_event(7, s, 0);
        goto LABEL_27;
      }
LABEL_24:
      if ( !byte_66640 && dword_657B8 <= 6 )
        goto LABEL_27;
      goto LABEL_26;
    }
  }
LABEL_27:
  free(stratum_merkle);
  free(stratum_header);
LABEL_12:
  calculate_midstate(work_data);
  calculate_target_hash(work_data + 160);
  ++dword_70E6C;
  if ( time(0) - dword_66BEC > 5 )
  {
    dword_66BEC = time(0);
    dword_66BF0 = dword_70E6C;
  }
  last_result = dword_66BF4;
  *(_BYTE *)(work_data + 284) = 1;
  *(_DWORD *)(work_data + 336) = last_result;
  *(_DWORD *)(work_data + 248) = 0;
  *(_BYTE *)(work_data + 280) = 0;
  *(_BYTE *)(work_data + 440) = 83;
  *(_DWORD *)(work_data + 244) = 60;
  *(_DWORD *)(work_data + 260) = miner_data;
  calculate_hashrate_metrics(work_data);
  return get_hardware_timestamp((__time_t *)(work_data + 264));
}
// 657B8: using guessed type int dword_657B8;
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);
// 66640: using guessed type char byte_66640;
// 66641: using guessed type char byte_66641;
// 66BEC: using guessed type int dword_66BEC;
// 66BF0: using guessed type int dword_66BF0;
// 66BF4: using guessed type int dword_66BF4;
// 70CE8: using guessed type char byte_70CE8;
// 70E6C: using guessed type int dword_70E6C;
// 31D90: using guessed type char var_848[32];

//----- (00032370) --------------------------------------------------------
int __fastcall process_mining_work(
        int *nonce,
        int *work,
        int miner_index,
        int work_id,
        __int64 nonce2,
        unsigned int nonce2_bs)
{
  pthread_mutex_t *mutex_ptr; // r6
  unsigned int nonce2_byte_swapped; // r2
  int global_delay; // r2
  int status; // r0
  unsigned int nonce2_final; // r1
  int local_nonce; // [sp+Ch] [bp-2Ch]

  mutex_ptr = (pthread_mutex_t *)(miner_index + 212);
  *work = initialize_work();
  local_nonce = *nonce;
  if ( pthread_mutex_lock(mutex_ptr) )
    log_mutex_error_and_exit("get_work_by_nonce2", 8379);
  if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(miner_index + 236)) )
    log_write_lock_error("get_work_by_nonce2", 8379);
  nonce2_byte_swapped = bswap32(nonce2_bs);
  *(_QWORD *)(miner_index + 624) = nonce2;
  nonce2_bs = nonce2_byte_swapped;
  log_memcpy_error((void *)(miner_index + 1580), &nonce2_bs, 4u, (int)"cgminer.c", (int)"get_work_by_nonce2", 8382);
  if ( pthread_rwlock_unlock((pthread_rwlock_t *)(miner_index + 236)) )
    log_rwlock_error_and_exit("get_work_by_nonce2", 8383);
  if ( pthread_mutex_unlock(mutex_ptr) )
    log_mutex_unlock_error("get_work_by_nonce2", 8383);
  off_658DC(0);
  generate_stratum_work(miner_index, *work);
  global_delay = dword_66BF4;
  status = 1;
  *(_DWORD *)(*work + 260) = work_id;
  nonce2_final = nonce2_bs;
  *(_DWORD *)(*work + 256) = local_nonce;
  *(_DWORD *)(*work + 336) = global_delay;
  ++*(_DWORD *)(*(_DWORD *)(*work + 260) + 68);
  *(_BYTE *)(*work + 272) = 1;
  *(_DWORD *)(*work + 444) = nonce2_final;
  return status;
}
// 1DA28: using guessed type int sub_1DA28(void);
// 2B404: using guessed type void __fastcall __noreturn sub_2B404(_DWORD, _DWORD);
// 2B460: using guessed type void __fastcall __noreturn sub_2B460(_DWORD, _DWORD);
// 2B4BC: using guessed type void __fastcall __noreturn sub_2B4BC(_DWORD, _DWORD);
// 2BFAC: using guessed type void __fastcall __noreturn sub_2BFAC(_DWORD, _DWORD);
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);
// 66BF4: using guessed type int dword_66BF4;

//----- (000324CC) --------------------------------------------------------
int __fastcall sub_324CC(int a1, int a2)
{
  int v2; // r5
  int v6; // r8
  int v7; // r9
  int v8; // r2
  int v9; // r3
  int v10; // r8
  int v11; // r0
  const char *v12; // lr
  int v13; // r0
  int v14; // r1
  int v15; // r2
  int v16; // r3
  int *v17; // lr
  int v18; // r0
  int v19; // r1
  int v20; // r2
  int v21; // r3
  int v22; // r1
  int v23; // r2
  int *v24; // r0
  int *v25; // r0
  int v26; // [sp+10h] [bp-830h] BYREF
  _DWORD s[10]; // [sp+18h] [bp-828h] BYREF
  __int16 v28; // [sp+40h] [bp-800h]

  v2 = (unsigned __int8)byte_66BA8;
  if ( !byte_66BA8 )
  {
    if ( dword_70D08 )
      return v2;
    if ( *(_DWORD *)(a1 + 336) != dword_66BF4 )
    {
      v2 = (unsigned __int8)byte_66641;
      if ( byte_66641 )
      {
        if ( byte_70CE8 || byte_66640 || dword_657B8 > 6 )
        {
          strcpy((char *)s, "Work stale due to block mismatch");
          log_event(7, s, 0);
        }
        return v2;
      }
      return 1;
    }
    v6 = *(_DWORD *)(a1 + 276);
    v7 = *(_DWORD *)(a1 + 260);
    v8 = dword_66154;
    if ( v6 <= dword_66154 )
      v6 = dword_66158;
    if ( !a2 && *(_BYTE *)(v7 + 640) )
    {
      if ( !*(_BYTE *)(v7 + 641) || !*(_BYTE *)(v7 + 643) )
      {
        v2 = (unsigned __int8)byte_66641;
        if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
        {
          strcpy((char *)s, "Work stale due to stratum inactive");
          log_event(7, s, 0);
          return v2;
        }
        return 1;
      }
      if ( pthread_mutex_lock((pthread_mutex_t *)(v7 + 212)) )
        log_mutex_error_and_exit("stale_work", 5122);
      if ( pthread_rwlock_rdlock((pthread_rwlock_t *)(v7 + 236)) )
        log_rdlock_error("stale_work", 5122);
      if ( pthread_mutex_unlock((pthread_mutex_t *)(v7 + 212)) )
      {
        v25 = _errno_location();
        snprintf(
          (char *)s,
          2048u,
          "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
          *v25,
          "cgminer.c",
          "stale_work",
          5122);
LABEL_56:
        log_event(3, s, 1);
        shutdown_miner(1, 1);
      }
      if ( strcmp(*(const char **)(a1 + 288), *(const char **)(v7 + 672)) )
      {
        if ( !pthread_rwlock_unlock((pthread_rwlock_t *)(v7 + 236)) )
        {
          off_658DC(0);
          v2 = (unsigned __int8)byte_66641;
          if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
          {
            v12 = "Work stale due to stratum job_id mismatch";
            goto LABEL_42;
          }
          return 1;
        }
        goto LABEL_55;
      }
      if ( pthread_rwlock_unlock((pthread_rwlock_t *)(v7 + 236)) )
      {
LABEL_55:
        v24 = _errno_location();
        snprintf(
          (char *)s,
          2048u,
          "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
          *v24,
          "cgminer.c",
          "stale_work",
          5129);
        goto LABEL_56;
      }
      off_658DC(0);
    }
    v9 = (int)(*(double *)(v7 + 448) * 5.0 + 1.0);
    v10 = v6 - v9;
    v11 = get_hardware_timestamp(&v26, a2, v8, v9);
    if ( v10 < 5 )
      v10 = 5;
    if ( v10 <= v26 - *(_DWORD *)(a1 + 264) )
    {
      v2 = (unsigned __int8)byte_66641;
      if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
      {
        strcpy((char *)s, "Work stale due to expiry");
        log_event(7, s, 0);
        return v2;
      }
      return 1;
    }
    if ( a2 | (unsigned __int8)byte_72EBD ^ 1
      || v7 == get_current_pool_index(v11)
      || *(_BYTE *)(a1 + 282)
      || (unsigned int)(dword_66A44 - 3) <= 1 )
    {
      return v2;
    }
    v2 = (unsigned __int8)byte_66641;
    if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
    {
      v12 = "Work stale due to fail only pool mismatch";
LABEL_42:
      v13 = *(_DWORD *)v12;
      v14 = *((_DWORD *)v12 + 1);
      v15 = *((_DWORD *)v12 + 2);
      v16 = *((_DWORD *)v12 + 3);
      v17 = (int *)(v12 + 16);
      s[0] = v13;
      s[1] = v14;
      s[2] = v15;
      s[3] = v16;
      v18 = *v17;
      v19 = v17[1];
      v20 = v17[2];
      v21 = v17[3];
      v17 += 4;
      s[4] = v18;
      s[5] = v19;
      s[6] = v20;
      s[7] = v21;
      v22 = v17[1];
      v23 = v17[2];
      s[8] = *v17;
      s[9] = v22;
      v28 = v23;
      log_event(7, s, 0);
      return v2;
    }
    return 1;
  }
  return 0;
}
// 326E4: variable 'a2' is possibly undefined
// 326E4: variable 'v8' is possibly undefined
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 1DA28: using guessed type int sub_1DA28(void);
// 1F5C4: using guessed type int __fastcall sub_1F5C4(_DWORD, _DWORD, _DWORD, _DWORD);
// 2AB30: using guessed type void __fastcall __noreturn sub_2AB30(_DWORD, _DWORD);
// 2B460: using guessed type void __fastcall __noreturn sub_2B460(_DWORD, _DWORD);
// 2C5C0: using guessed type void __fastcall __noreturn sub_2C5C0(_DWORD, _DWORD);
// 2E47C: using guessed type int __fastcall sub_2E47C(_DWORD);
// 657B8: using guessed type int dword_657B8;
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);
// 66154: using guessed type int dword_66154;
// 66158: using guessed type int dword_66158;
// 66640: using guessed type char byte_66640;
// 66641: using guessed type char byte_66641;
// 66A44: using guessed type int dword_66A44;
// 66BA8: using guessed type char byte_66BA8;
// 66BF4: using guessed type int dword_66BF4;
// 70CE8: using guessed type char byte_70CE8;
// 70D08: using guessed type int dword_70D08;
// 72EBD: using guessed type char byte_72EBD;

//----- (000329B4) --------------------------------------------------------
int __fastcall fetch_work_for_thread(int thread_data, int thread_id)
{
  _DWORD *worker_data; // r5
  time_t start_time; // r9
  int work_fetch_duration; // r9
  int log_condition; // r3
  int cleanup_call; // r0
  int work_pointer; // r0
  int is_benchmark_mode; // r2
  int work_index; // r3
  int final_result; // r0
  double work_difficulty; // d7
  int difficulty_index; // r2
  int benchmark_work_index; // r2
  int benchmark_rounds; // r2
  int benchmark_data_offset; // r1
  int next_round; // r2
  void *benchmark_data; // r3
  int work; // [sp+Ch] [bp-824h] BYREF
  char log_message[2080]; // [sp+10h] [bp-820h] BYREF

  work = 0;
  worker_data = *(_DWORD **)(thread_data + 36);
  update_timestamp_and_enable();
  if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
  {
    strcpy(log_message, "Popping work from get queue to get work");
    log_event(7, log_message, 0);
  }
  start_time = time(0);
  while ( !work )
  {
    work = pop_hash(1);
    if ( check_work_staleness(work, 0) )
    {
      cleanup_call = process_work_discard(&work, "cgminer.c", "get_work", 8693);
      wake_global_work_softwares(cleanup_call);
    }
  }
  work_fetch_duration = time(0) - start_time;
  log_condition = (unsigned __int8)byte_66641;
  if ( work_fetch_duration <= 0 )
  {
LABEL_16:
    if ( !log_condition )
      goto LABEL_20;
    goto LABEL_17;
  }
  if ( !byte_66641 )
  {
    worker_data[58] += work_fetch_duration;
    goto LABEL_20;
  }
  if ( byte_70CE8 || byte_66640 || dword_657B8 > 6 )
  {
    snprintf(log_message, 2048u, "Get work blocked for %ld seconds", work_fetch_duration);
    log_event(7, log_message, 0);
    log_condition = (unsigned __int8)byte_66641;
    worker_data[58] += work_fetch_duration;
    goto LABEL_16;
  }
  worker_data[58] += work_fetch_duration;
LABEL_17:
  if ( byte_70CE8 || byte_66640 || dword_657B8 > 6 )
  {
    snprintf(log_message, 2048u, "Got work from get queue to get work for thread %d", thread_id);
    log_event(7, log_message, 0);
  }
LABEL_20:
  work_pointer = work;
  is_benchmark_mode = (unsigned __int8)byte_66BA8;
  *(_DWORD *)(work + 256) = thread_id;
  if ( !is_benchmark_mode )
    goto LABEL_21;
  benchmark_work_index = worker_data[95] + worker_data[96];
  worker_data[95] = benchmark_work_index;
  if ( benchmark_work_index <= 0 )
  {
    worker_data[96] = 1;
LABEL_42:
    log_memcpy_error(
      work_pointer,
      (char *)&unk_675F8 + 160 * benchmark_work_index,
      160,
      "cgminer.c",
      "set_benchmark_work",
      8674);
    goto LABEL_21;
  }
  if ( benchmark_work_index <= 15 )
    goto LABEL_42;
  benchmark_rounds = worker_data[94];
  benchmark_data_offset = -1;
  worker_data[96] = -1;
  next_round = benchmark_rounds + 1;
  if ( next_round <= 15 )
  {
    benchmark_data_offset = 5 * next_round;
    worker_data[94] = next_round;
  }
  if ( next_round > 15 )
  {
    benchmark_data_offset = (int)&unk_66BF8;
    benchmark_data = 0;
    worker_data[94] = 0;
  }
  else
  {
    benchmark_data = &unk_66BF8;
  }
  if ( next_round <= 15 )
    benchmark_data_offset = (int)benchmark_data + 32 * benchmark_data_offset;
  log_memcpy_error(work_pointer, benchmark_data_offset, 160, "cgminer.c", "set_benchmark_work", 8670);
LABEL_21:
  update_hardware_timestamp(thread_data);
  work_index = work;
  *(_BYTE *)(work + 272) = 1;
  final_result = work_index;
  work_difficulty = *(double *)(worker_data[1] + 104);
  if ( work_difficulty > *(double *)(work_index + 376) )
    work_difficulty = *(double *)(work_index + 376);
  *(double *)(work_index + 224) = work_difficulty;
  difficulty_index = worker_data[1];
  if ( *(double *)(difficulty_index + 112) > work_difficulty )
    work_difficulty = *(double *)(difficulty_index + 112);
  *(double *)(work_index + 224) = work_difficulty;
  return final_result;
}
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 2220C: using guessed type int __fastcall sub_2220C(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 27174: using guessed type int sub_27174(void);
// 271AC: using guessed type int __fastcall sub_271AC(_DWORD);
// 292F8: using guessed type int __fastcall sub_292F8(_DWORD, _DWORD, _DWORD, _DWORD);
// 2BE48: using guessed type int __fastcall sub_2BE48(_DWORD);
// 657B8: using guessed type int dword_657B8;
// 66640: using guessed type char byte_66640;
// 66641: using guessed type char byte_66641;
// 66BA8: using guessed type char byte_66BA8;
// 70CE8: using guessed type char byte_70CE8;

//----- (00032D00) --------------------------------------------------------
int __fastcall fetch_and_queue_work(int thread_id, pthread_rwlock_t *work_queue_lock, int work_id)
{
  int work_item; // r4

  work_item = fetch_work_for_thread(thread_id, work_id);
  add_queued(work_queue_lock, work_item);
  return work_item;
}

//----- (00032D28) --------------------------------------------------------
int __fastcall process_queued_work(int miner_ptr)
{
  int queued_work_id; // r3
  int result_work_id; // r3
  int work_id; // [sp+4h] [bp-Ch] BYREF

  queued_work_id = *(_DWORD *)(miner_ptr + 356);
  if ( !queued_work_id )
    return 0;
  work_id = *(_DWORD *)(miner_ptr + 356);
  if ( check_work_staleness(queued_work_id, 0) )
  {
    process_work_discard(&work_id, "cgminer.c", "__get_queued", 9465);
    wake_global_work_softwares();
  }
  else
  {
    update_statistics(miner_ptr, work_id);
  }
  result_work_id = work_id;
  *(_DWORD *)(miner_ptr + 356) = 0;
  return result_work_id;
}
// 2A4B4: using guessed type int __fastcall sub_2A4B4(_DWORD, _DWORD);

//----- (00032DA8) --------------------------------------------------------
int __fastcall lock_and_process_queued_work(pthread_rwlock_t *rwlock)
{
  pthread_rwlock_t *lock_ptr; // r4
  int v3; // r5

  lock_ptr = rwlock + 10;
  if ( pthread_rwlock_wrlock(rwlock + 10) )
    log_write_lock_error("get_queued", 9486);
  v3 = process_queued_work((int)rwlock);
  if ( pthread_rwlock_unlock(lock_ptr) )
    log_rwlock_error_and_exit("get_queued", 9488);
  off_658DC(0);
  return v3;
}
// 1DA28: using guessed type int sub_1DA28(void);
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);

//----- (00032E14) --------------------------------------------------------
void discard_stale_shares()
{
  int stale_count; // r6
  int next_work_ptr; // r4
  _DWORD *current_work; // r3
  int head_work_ptr; // r1
  int previous_work_ptr; // r9
  int work_info_ptr; // r0
  int offset; // r2
  _DWORD *expected_work_ptr; // r12
  int new_head_work_ptr; // r8
  _DWORD *work_info_control_ptr; // r0
  int hash_slot; // r2
  int control_base_ptr; // r0
  _DWORD *hash_link_ptr; // lr
  int previous_ptr; // r0
  int next_ptr; // r2
  int work_ptr; // r0
  int *v16; // r0
  int *v17; // r0
  _DWORD *v18; // [sp+14h] [bp-824h] BYREF
  char s[2080]; // [sp+18h] [bp-820h] BYREF

  stale_count = pthread_mutex_lock((pthread_mutex_t *)dword_66A80);
  if ( stale_count )
  {
    v16 = _errno_location();
    snprintf(s, 2048u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v16, "cgminer.c", "discard_stale", 5411);
    goto LABEL_39;
  }
  v18 = (_DWORD *)dword_66B5C;
  if ( !dword_66B5C )
  {
    pthread_cond_signal(&stru_70DC0);
    if ( !pthread_mutex_unlock((pthread_mutex_t *)dword_66A80) )
    {
      off_658DC(0);
      return;
    }
    goto LABEL_41;
  }
  next_work_ptr = *(_DWORD *)(dword_66B5C + 352);
  if ( !check_work_staleness(dword_66B5C, 0) )
    goto LABEL_19;
LABEL_4:
  current_work = v18;
  head_work_ptr = dword_66B5C;
  previous_work_ptr = v18[87];
  work_info_ptr = *(_DWORD *)(dword_66B5C + 344);
  if ( previous_work_ptr )
  {
    offset = *(_DWORD *)(work_info_ptr + 20);
    expected_work_ptr = v18 + 86;
    if ( v18 != (_DWORD *)(*(_DWORD *)(work_info_ptr + 16) - offset) )
    {
LABEL_6:
      *(_DWORD *)(previous_work_ptr + offset + 8) = current_work[88];
      new_head_work_ptr = current_work[88];
LABEL_7:
      work_info_control_ptr = *(_DWORD **)(head_work_ptr + 344);
      if ( new_head_work_ptr )
      {
        *(_DWORD *)(new_head_work_ptr + work_info_control_ptr[5] + 4) = current_work[87];
        work_info_control_ptr = *(_DWORD **)(head_work_ptr + 344);
      }
      hash_slot = 3 * ((work_info_control_ptr[1] - 1) & current_work[93]);
      --*(_DWORD *)(*work_info_control_ptr + 4 * hash_slot + 4);
      control_base_ptr = **(_DWORD **)(head_work_ptr + 344);
      hash_link_ptr = *(_DWORD **)(control_base_ptr + 4 * hash_slot);
      if ( hash_link_ptr == expected_work_ptr )
      {
        head_work_ptr = current_work[90];
        *(_DWORD *)(control_base_ptr + 4 * hash_slot) = head_work_ptr;
      }
      previous_ptr = current_work[89];
      next_ptr = current_work[90];
      if ( hash_link_ptr == expected_work_ptr )
        head_work_ptr = dword_66B5C;
      if ( previous_ptr )
      {
        *(_DWORD *)(previous_ptr + 16) = next_ptr;
        next_ptr = current_work[90];
      }
      if ( next_ptr )
        *(_DWORD *)(next_ptr + 12) = current_work[89];
      --*(_DWORD *)(*(_DWORD *)(head_work_ptr + 344) + 12);
      goto LABEL_18;
    }
LABEL_25:
    *(_DWORD *)(work_info_ptr + 16) = previous_work_ptr + offset;
    previous_work_ptr = current_work[87];
    if ( previous_work_ptr )
    {
      offset = *(_DWORD *)(*(_DWORD *)(head_work_ptr + 344) + 20);
      goto LABEL_6;
    }
    new_head_work_ptr = current_work[88];
LABEL_24:
    head_work_ptr = new_head_work_ptr;
    dword_66B5C = new_head_work_ptr;
    goto LABEL_7;
  }
  new_head_work_ptr = v18[88];
  if ( new_head_work_ptr )
  {
    offset = *(_DWORD *)(work_info_ptr + 20);
    expected_work_ptr = v18 + 86;
    if ( v18 != (_DWORD *)(*(_DWORD *)(work_info_ptr + 16) - offset) )
      goto LABEL_24;
    goto LABEL_25;
  }
  free(*(void **)work_info_ptr);
  free(*(void **)(dword_66B5C + 344));
  dword_66B5C = 0;
LABEL_18:
  ++stale_count;
  process_work_discard(&v18, "cgminer.c", "discard_stale", 5418);
LABEL_19:
  while ( 1 )
  {
    v18 = (_DWORD *)next_work_ptr;
    if ( !next_work_ptr )
      break;
    work_ptr = next_work_ptr;
    next_work_ptr = *(_DWORD *)(next_work_ptr + 352);
    if ( check_work_staleness(work_ptr, 0) )
      goto LABEL_4;
  }
  pthread_cond_signal(&stru_70DC0);
  if ( pthread_mutex_unlock((pthread_mutex_t *)dword_66A80) )
  {
LABEL_41:
    v17 = _errno_location();
    snprintf(s, 2048u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v17, "cgminer.c", "discard_stale", 5424);
LABEL_39:
    log_event(3, s, 1);
    shutdown_miner(1, 1);
  }
  off_658DC(0);
  if ( stale_count && byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
  {
    snprintf(s, 2048u, "Discarded %d stales that didn't match current hash", stale_count);
    log_event(7, s, 0);
  }
}
// 657B8: using guessed type int dword_657B8;
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);
// 66640: using guessed type char byte_66640;
// 66641: using guessed type char byte_66641;
// 66A80: using guessed type int dword_66A80;
// 66B5C: using guessed type int dword_66B5C;
// 70CE8: using guessed type char byte_70CE8;
// 70DC0: using guessed type pthread_cond_t stru_70DC0;

//----- (0003315C) --------------------------------------------------------
int restart_miners()
{
  pthread_t thread_id; // r0
  int miners_count; // r8
  int current_miner; // r5
  int miner_data_ptr; // r3
  pthread_rwlock_t *miner_rwlock; // r4

  thread_id = pthread_self();
  pthread_detach(thread_id);
  discard_stale_shares();
  if ( pthread_rwlock_rdlock(&stru_72EE8) )
    log_rdlock_error("restart_thread", 5477);
  miners_count = dword_74180;
  current_miner = pthread_rwlock_unlock(&stru_72EE8);
  if ( current_miner )
    log_rwlock_error_and_exit("restart_thread", 5479);
  off_658DC(0);
  if ( miners_count > 0 )
  {
    do
    {
      miner_data_ptr = *(_DWORD *)(dword_71E78 + 4 * current_miner);
      miner_rwlock = *(pthread_rwlock_t **)(miner_data_ptr + 36);
      if ( miner_rwlock && !miner_rwlock[1].__lock )
      {
        *(_BYTE *)(miner_data_ptr + 62) = 1;
        reset_rwlock_and_log(miner_rwlock);
        if ( pthread_mutex_lock(&stru_73F70) )
          log_mutex_error_and_exit("restart_thread", 5498);
        (*(void (__fastcall **)(pthread_rwlock_t *))(miner_rwlock->__nr_readers + 76))(miner_rwlock);
        if ( pthread_mutex_unlock(&stru_73F70) )
          log_mutex_unlock_error("restart_thread", 5500);
        off_658DC(0);
      }
      ++current_miner;
    }
    while ( miners_count != current_miner );
  }
  if ( pthread_mutex_lock(&stru_72EC4) )
    log_mutex_error_and_exit("restart_thread", 5504);
  pthread_cond_broadcast(&stru_740F0);
  if ( pthread_mutex_unlock(&stru_72EC4) )
    log_mutex_unlock_error("restart_thread", 5506);
  off_658DC(0);
  return 0;
}
// 1DA28: using guessed type int sub_1DA28(void);
// 3315C: using guessed type int restart_miners();
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);
// 71E78: using guessed type int dword_71E78;
// 72EC4: using guessed type pthread_mutex_t stru_72EC4;
// 72EE8: using guessed type pthread_rwlock_t stru_72EE8;
// 73F70: using guessed type pthread_mutex_t stru_73F70;
// 740F0: using guessed type pthread_cond_t stru_740F0;
// 74180: using guessed type int dword_74180;

//----- (000332CC) --------------------------------------------------------
int __fastcall update_mining_statistics(int thread_id, __int64 hash_count)
{
  double hash_rate; // d0
  int unused1; // r1
  int unused2; // r2
  int error_number; // r4
  char *error_message; // r0
  int system_uptime; // r3
  int lock_result; // r0
  int current_time; // r5
  double previous_hash_rate; // d9
  int lock_result_or_counter; // r6
  int miner_index; // r5
  double temp_hash_rate; // d13
  double hash_increment; // d10
  int next_round_index; // r3
  int rounded_index; // r3
  int valid_rates_count; // r6
  __int64 total_hash_rate; // r0
  int *index_pointer; // r11
  double current_rate; // d8
  double added_rate; // r0
  int update_display; // r11
  int current_index; // r3
  double existing_rate; // d5
  int miner_data; // r0
  int current_miner; // r6
  double hash_per_sec; // r0
  double updated_rate; // d10
  double current_time_secs; // d6
  double last_update_time; // d7
  double last_total_secs; // d5
  double time_difference; // d7
  int unused3; // r0
  __int64 average_hash_rate; // r0
  __int64 rate_in_mh; // r0
  __int64 rate_5min_mh; // r0
  __int64 rate_15min_mh; // r0
  __int64 rate_avg_mh; // r0
  int *errno_location1; // r0
  int *errno_location2; // r0
  int lock_error_number; // r3
  int lock_error_location; // r12
  int unlock_error_number; // r3
  int unlock_error_location; // r12
  char hash_rate_str[16]; // [sp+28h] [bp-8D8h] BYREF
  char hash_rate_1min_str[16]; // [sp+38h] [bp-8C8h] BYREF
  char hash_rate_5min_str[16]; // [sp+48h] [bp-8B8h] BYREF
  char hash_rate_15min_str[16]; // [sp+58h] [bp-8A8h] BYREF
  struct sysinfo system_info; // [sp+68h] [bp-898h] BYREF
  char log_message[2136]; // [sp+A8h] [bp-858h] BYREF

  if ( sysinfo(&system_info) )
  {
    if ( byte_70CE8 || byte_66640 || dword_657B8 > 5 )
    {
      error_number = *_errno_location();
      error_message = strerror(error_number);
      snprintf(log_message, 2048u, "Failed to get sysinfo, errno:%u, reason:%s\n", error_number, error_message);
      log_event(6, log_message, 0);
    }
    dword_7412C = time(0);
  }
  else
  {
    system_uptime = system_info.uptime;
    dword_7412C = system_info.uptime;
  }
  get_hardware_timestamp(&dword_66A88, unused1, unused2, system_uptime);
  lock_result = sub_1F8EC(&dword_66A88, &unk_66AF0);
  current_time = dword_66A88;
  previous_hash_rate = hash_rate;
  if ( dword_66130 > dword_66A88 - dword_67FF8 )
  {
    if ( thread_id < 0 )
      return lock_result;
    update_display = 0;
    copy_system_time(&unk_66AF0, &dword_66A88);
  }
  else
  {
    dword_67FF8 = dword_66A88;
    copy_system_time(&unk_66AF0, &dword_66A88);
    if ( thread_id < 0 )
    {
      lock_result_or_counter = pthread_mutex_lock(&stru_70E30);
      if ( !lock_result_or_counter )
      {
        if ( dword_74180 > 0 )
        {
          do
          {
            while ( 1 )
            {
              miner_index = *(_DWORD *)(get_thread_metadata(lock_result_or_counter) + 36);
              sub_1F8EC(&dword_66A88, miner_index + 140);
              temp_hash_rate = hash_rate;
              copy_system_time(miner_index + 140, &dword_66A88);
              if ( hash_rate > 0.0 )
              {
                calculate_exp_and_update_value(miner_index + 48);
                hash_rate = 0.0;
                calculate_exp_and_update_value(miner_index + 56);
                if ( temp_hash_rate > 0.0 )
                {
                  hash_rate = 0.0;
                  calculate_exp_and_update_value(miner_index + 64);
                  if ( temp_hash_rate > 0.0 )
                    break;
                }
              }
              if ( dword_74180 <= ++lock_result_or_counter )
                goto LABEL_17;
            }
            ++lock_result_or_counter;
            hash_rate = 0.0;
            calculate_exp_and_update_value(miner_index + 72);
          }
          while ( dword_74180 > lock_result_or_counter );
        }
LABEL_17:
        if ( pthread_mutex_unlock(&stru_70E30) )
        {
          unlock_error_number = *_errno_location();
          unlock_error_location = 7145;
          goto LABEL_78;
        }
        off_658DC(0);
        if ( !pthread_mutex_lock(&stru_70E30) )
        {
          hash_increment = check_null_pointer(hash_count, HIDWORD(hash_count));
          next_round_index = dword_66B58;
          unk_70CE0 = unk_70CE0 + hash_increment;
          goto LABEL_20;
        }
LABEL_72:
        errno_location1 = _errno_location();
        snprintf(
          log_message,
          2048u,
          "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
          *errno_location1,
          "cgminer.c",
          "hashmeter",
          7148);
        goto LABEL_73;
      }
      lock_error_number = *_errno_location();
      lock_error_location = 7130;
LABEL_76:
      snprintf(
        log_message,
        2048u,
        "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
        lock_error_number,
        "cgminer.c",
        "hashmeter",
        lock_error_location);
      goto LABEL_73;
    }
    update_display = 1;
  }
  miner_data = get_thread_metadata(thread_id);
  current_miner = *(_DWORD *)(miner_data + 36);
  copy_system_time(miner_data + 44, &dword_66A88);
  *(_DWORD *)(current_miner + 240) = current_time;
  sub_1F8EC(&dword_66A88, current_miner + 140);
  copy_system_time(current_miner + 140, &dword_66A88);
  if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
  {
    hash_per_sec = check_null_pointer(hash_count, HIDWORD(hash_count));
    snprintf(
      log_message,
      2048u,
      "[thread %d: %llu hashes, %.1f mhash/sec]",
      thread_id,
      hash_count,
      hash_per_sec / hash_rate / 1000000.0);
    log_event(7, log_message, 0);
  }
  hash_count = check_and_execute(hash_count, HIDWORD(hash_count), 1000000, 0);
  if ( pthread_mutex_lock(&stru_70E30) )
  {
    lock_error_number = *_errno_location();
    lock_error_location = 7101;
    goto LABEL_76;
  }
  hash_increment = check_null_pointer(hash_count, HIDWORD(hash_count));
  *(double *)(current_miner + 80) = *(double *)(current_miner + 80) + hash_increment;
  if ( hash_rate > 0.0 )
  {
    calculate_exp_and_update_value(current_miner + 48);
    calculate_exp_and_update_value(current_miner + 56);
    if ( hash_rate > 0.0 )
    {
      calculate_exp_and_update_value(current_miner + 64);
      if ( hash_rate > 0.0 )
        calculate_exp_and_update_value(current_miner + 72);
    }
  }
  if ( pthread_mutex_unlock(&stru_70E30) )
  {
    unlock_error_number = *_errno_location();
    unlock_error_location = 7108;
    goto LABEL_78;
  }
  off_658DC(0);
  if ( ((unsigned __int8)update_display & (unsigned __int8)byte_73F6C) != 0 )
  {
    format_miner_stats(log_message, 256, current_miner);
    printf("%s          \r", log_message);
    fflush((FILE *)stdout);
    if ( pthread_mutex_lock(&stru_70E30) )
      goto LABEL_72;
    next_round_index = dword_66B58;
    unk_70CE0 = unk_70CE0 + hash_increment;
    goto LABEL_20;
  }
  if ( pthread_mutex_lock(&stru_70E30) )
    goto LABEL_72;
  next_round_index = dword_66B58;
  unk_70CE0 = unk_70CE0 + hash_increment;
  if ( update_display )
  {
LABEL_20:
    rounded_index = next_round_index + 1;
    valid_rates_count = 0;
    LODWORD(total_hash_rate) = 0;
    if ( rounded_index > 11 )
      rounded_index = 0;
    HIDWORD(total_hash_rate) = 0;
    dword_66B58 = rounded_index;
    index_pointer = (int *)dbl_66AF8;
    do
    {
      current_rate = *(double *)index_pointer;
      index_pointer += 2;
      if ( current_rate >= 0.0 )
      {
        added_rate = check_null_pointer(total_hash_rate, HIDWORD(total_hash_rate));
        ++valid_rates_count;
        total_hash_rate = calculate_hash_value(
                            COERCE_UNSIGNED_INT64(added_rate + current_rate),
                            HIDWORD(COERCE_UNSIGNED_INT64(added_rate + current_rate)));
      }
    }
    while ( index_pointer != &dword_66B58 );
    if ( valid_rates_count )
      hash_count = check_and_execute(
                     total_hash_rate,
                     HIDWORD(total_hash_rate),
                     valid_rates_count,
                     valid_rates_count >> 31);
    if ( (double)dword_66130 > 0.0 )
    {
      check_null_pointer(hash_count, HIDWORD(hash_count));
      calculate_exp_and_update_value(&dbl_74120);
      if ( previous_hash_rate <= 0.0 )
        goto LABEL_30;
    }
    else if ( previous_hash_rate <= 0.0 )
    {
LABEL_30:
      update_display = 1;
      unk_740E0 = calculate_hash_value(
                    COERCE_UNSIGNED_INT64(dbl_74120 * 1000000.0),
                    HIDWORD(COERCE_UNSIGNED_INT64(dbl_74120 * 1000000.0)));
      current_index = dword_66B58;
      existing_rate = 0.0;
      dbl_66AF8[dword_66B58] = 0.0;
      goto LABEL_45;
    }
    calculate_exp_and_update_value(&dbl_74230);
    calculate_exp_and_update_value(&dbl_74228);
    if ( previous_hash_rate > 0.0 )
      calculate_exp_and_update_value(&dbl_70E18);
    goto LABEL_30;
  }
  current_index = dword_66B58;
  existing_rate = dbl_66AF8[dword_66B58];
LABEL_45:
  updated_rate = hash_increment + existing_rate;
  current_time_secs = (double)dword_7412C;
  last_update_time = (double)dword_740EC;
  last_total_secs = dbl_66140;
  dbl_66AF8[current_index] = updated_rate;
  time_difference = current_time_secs - last_update_time;
  *(double *)&dword_66120 = time_difference;
  if ( time_difference - last_total_secs > 86400.0 )
  {
    if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
    {
      snprintf(
        log_message,
        2048u,
        "cgminer time error total_secs = %f last_total_secs = %f",
        time_difference,
        last_total_secs);
      log_event(3, log_message, 0);
    }
    if ( !pthread_mutex_unlock(&stru_70E30) )
    {
      unused3 = off_658DC(0);
      reset_miner_stats(unused3);
      if ( !pthread_mutex_lock(&stru_70E30) )
      {
        if ( !update_display )
          goto LABEL_52;
LABEL_57:
        average_hash_rate = calculate_hash_value(
                              COERCE_UNSIGNED_INT64(unk_70CE0 / *(double *)&dword_66120 * 1000000.0),
                              HIDWORD(COERCE_UNSIGNED_INT64(unk_70CE0 / *(double *)&dword_66120 * 1000000.0)));
        format_hashrate(average_hash_rate, SHIDWORD(average_hash_rate), hash_rate_str, 16u, 4);
        unk_68000 = (double)((int)dbl_74120 / 10) / 100.0;
        rate_in_mh = calculate_hash_value(
                       COERCE_UNSIGNED_INT64(dbl_74120 * 1000000.0),
                       HIDWORD(COERCE_UNSIGNED_INT64(dbl_74120 * 1000000.0)));
        format_hashrate(rate_in_mh, SHIDWORD(rate_in_mh), hash_rate_1min_str, 16u, 4);
        rate_5min_mh = calculate_hash_value(
                         COERCE_UNSIGNED_INT64(dbl_74230 * 1000000.0),
                         HIDWORD(COERCE_UNSIGNED_INT64(dbl_74230 * 1000000.0)));
        format_hashrate(rate_5min_mh, SHIDWORD(rate_5min_mh), hash_rate_5min_str, 16u, 4);
        rate_15min_mh = calculate_hash_value(
                          COERCE_UNSIGNED_INT64(dbl_74228 * 1000000.0),
                          HIDWORD(COERCE_UNSIGNED_INT64(dbl_74228 * 1000000.0)));
        format_hashrate(rate_15min_mh, SHIDWORD(rate_15min_mh), hash_rate_15min_str, 16u, 4);
        rate_avg_mh = calculate_hash_value(
                        COERCE_UNSIGNED_INT64(dbl_70E18 * 1000000.0),
                        HIDWORD(COERCE_UNSIGNED_INT64(dbl_70E18 * 1000000.0)));
        format_hashrate(rate_avg_mh, SHIDWORD(rate_avg_mh), log_message, 16u, 4);
        snprintf(
          byte_68008,
          256u,
          "(%ds):%s (1m):%s (5m):%s (15m):%s (avg):%sh/s",
          dword_66130,
          hash_rate_1min_str,
          hash_rate_5min_str,
          hash_rate_15min_str,
          log_message,
          hash_rate_str);
        if ( !pthread_mutex_unlock(&stru_70E30) )
        {
          off_658DC(0);
          printf("%s          \r", byte_68008);
          return fflush((FILE *)stdout);
        }
        goto LABEL_74;
      }
      lock_error_number = *_errno_location();
      lock_error_location = 7198;
      goto LABEL_76;
    }
    unlock_error_number = *_errno_location();
    unlock_error_location = 7196;
LABEL_78:
    snprintf(
      log_message,
      2048u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      unlock_error_number,
      "cgminer.c",
      "hashmeter",
      unlock_error_location);
LABEL_73:
    log_event(3, log_message, 1);
    shutdown_miner(1, 1);
  }
  dbl_66140 = time_difference;
  if ( update_display )
    goto LABEL_57;
LABEL_52:
  if ( pthread_mutex_unlock(&stru_70E30) )
  {
LABEL_74:
    errno_location2 = _errno_location();
    snprintf(
      log_message,
      2048u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *errno_location2,
      "cgminer.c",
      "hashmeter",
      7239);
    goto LABEL_73;
  }
  return off_658DC(0);
}
// 33398: variable 'unused1' is possibly undefined
// 33398: variable 'unused2' is possibly undefined
// 33398: variable 'system_uptime' is possibly undefined
// 333BC: variable 'hash_rate' is possibly undefined
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 1DA28: using guessed type int sub_1DA28(void);
// 1F5C4: using guessed type int __fastcall sub_1F5C4(_DWORD, _DWORD, _DWORD, _DWORD);
// 1F8EC: using guessed type int __fastcall sub_1F8EC(_DWORD, _DWORD);
// 2251C: using guessed type int __fastcall sub_2251C(_DWORD, _DWORD);
// 2898C: using guessed type int __fastcall sub_2898C(_DWORD);
// 2AB30: using guessed type void __fastcall __noreturn sub_2AB30(_DWORD, _DWORD);
// 2AC50: using guessed type int __fastcall sub_2AC50(_DWORD, _DWORD, _DWORD);
// 2DF8C: using guessed type int __fastcall sub_2DF8C(_DWORD);
// 2F228: using guessed type int __fastcall sub_2F228(_DWORD);
// 492FC: using guessed type double __fastcall sub_492FC(_DWORD, _DWORD);
// 49368: using guessed type __int64 __fastcall sub_49368(_DWORD, _DWORD, _DWORD, _DWORD);
// 493C8: using guessed type __int64 __fastcall sub_493C8(_DWORD, _DWORD);
// 657B8: using guessed type int dword_657B8;
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);
// 66120: using guessed type int dword_66120;
// 66130: using guessed type int dword_66130;
// 66140: using guessed type double dbl_66140;
// 664F4: using guessed type int stdout;
// 66640: using guessed type char byte_66640;
// 66641: using guessed type char byte_66641;
// 66A88: using guessed type int dword_66A88;
// 66AF8: using guessed type double dbl_66AF8[12];
// 66B58: using guessed type int dword_66B58;
// 67FF8: using guessed type int dword_67FF8;
// 70CE8: using guessed type char byte_70CE8;
// 70E18: using guessed type double dbl_70E18;
// 70E30: using guessed type pthread_mutex_t stru_70E30;
// 73F6C: using guessed type char byte_73F6C;
// 740EC: using guessed type int dword_740EC;
// 74120: using guessed type double dbl_74120;
// 7412C: using guessed type int dword_7412C;
// 74180: using guessed type int dword_74180;
// 74228: using guessed type double dbl_74228;
// 74230: using guessed type double dbl_74230;

//----- (00034454) --------------------------------------------------------
void __fastcall process_mining(int thread_data)
{
  int miner_data; // r8
  int scheduler_interval; // r3
  int thread_index; // r3
  __int64 work_deadline; // r0
  int arg3; // r2
  int arg4; // r3
  int arg1; // r1
  int arg2; // r2
  int v10; // r3
  int seconds_sum; // r9
  int seconds_total; // r11
  __int64 hash_count; // r6
  int v14; // r1
  int v15; // r2
  int work_index; // r3
  int miner_config_offset; // r2
  int temp_arg1; // r1
  double temp_double; // d7
  int work_pointer; // r2
  int actual_work_data; // r5
  int v22; // r1
  int v23; // r2
  int work_ptr; // r0
  int work_counter; // r3
  __int64 hashes_done; // r4
  int v27; // r1
  int v28; // r2
  int v29; // r3
  int nanosecond_diff; // r4
  int new_seconds; // r3
  int second_diff; // r1
  int second_diff_from_start; // r5
  bool negative_flag; // nf
  int raw_nanoseconds_diff; // r4
  int nanoseconds_diff; // r4
  int seconds_diff; // r3
  bool should_update_stats; // cc
  __int64 hash_count_tmp; // r2
  _BOOL4 update_stats_flag; // r1
  int pause_duration; // r3
  unsigned int max_frequency; // r0
  int min_frequency; // r0
  int temp_frequency; // r0
  int new_frequency; // r0
  int miner_offset; // [sp+Ch] [bp-88Ch]
  int temp_arg2; // [sp+10h] [bp-888h]
  int temp_arg3; // [sp+14h] [bp-884h]
  unsigned int frequency; // [sp+18h] [bp-880h]
  int waiting_threshold; // [sp+24h] [bp-874h]
  int thread_number; // [sp+28h] [bp-870h]
  int temp_seconds; // [sp+2Ch] [bp-86Ch]
  int temp_seconds_53; // [sp+2Ch] [bp-86Ch]
  int temp_seconds_54; // [sp+2Ch] [bp-86Ch]
  struct timespec *sleep_duration; // [sp+30h] [bp-868h]
  int calculated_sleep; // [sp+44h] [bp-854h]
  int work_data; // [sp+4Ch] [bp-84Ch] BYREF
  int current_time; // [sp+50h] [bp-848h] BYREF
  int current_nanoseconds; // [sp+54h] [bp-844h]
  int start_time; // [sp+58h] [bp-840h] BYREF
  int start_nanoseconds; // [sp+5Ch] [bp-83Ch]
  int start_raw[2]; // [sp+60h] [bp-838h] BYREF
  int previous_time_raw[2]; // [sp+68h] [bp-830h] BYREF
  struct timespec sleep_time; // [sp+70h] [bp-828h] BYREF

  miner_data = *(_DWORD *)(thread_data + 36);
  miner_offset = *(_DWORD *)(miner_data + 4);
  scheduler_interval = dword_66130 / 5;
  if ( (int)((unsigned __int64)(1717986919LL * dword_66130) >> 32) >> 1 == dword_66130 >> 31 )
    scheduler_interval = 1;
  waiting_threshold = scheduler_interval;
  if ( *(_DWORD *)(thread_data + 4) )
    thread_index = *(unsigned __int8 *)(thread_data + 8);
  else
    thread_index = 1;
  thread_number = *(_DWORD *)thread_data;
  sleep_duration = (struct timespec *)thread_index;
  work_deadline = ((__int64 (__fastcall *)(int))*(_DWORD *)(miner_offset + 48))(thread_data);
  frequency = work_deadline;
  get_hardware_timestamp(&current_time, HIDWORD(work_deadline), arg3, arg4);
  get_hardware_timestamp(previous_time_raw, arg1, arg2, v10);
  if ( *(_BYTE *)(miner_data + 364) )
    goto LABEL_51;
  seconds_sum = *(unsigned __int8 *)(miner_data + 364);
  seconds_total = seconds_sum;
  hash_count = 0LL;
  do
  {
    work_data = fetch_work_for_thread(thread_data, thread_number);
    *(_BYTE *)(thread_data + 62) = 0;
    *(_BYTE *)(miner_data + 172) = 1;
    get_hardware_timestamp(start_raw, v14, v15, 1);
    *(_DWORD *)(work_data + 248) = 0;
    *(_QWORD *)(miner_data + 160) = 0LL;
    if ( !(*(int (__fastcall **)(int))(miner_offset + 56))(thread_data) )
    {
      if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
      {
        snprintf((char *)&sleep_time, 2048u, "work prepare failed, exiting mining thread %d", thread_number);
        log_event(3, (const char *)&sleep_time, 0);
      }
      break;
    }
    work_index = work_data;
    miner_config_offset = miner_offset;
    temp_arg3 = miner_data + 304;
    temp_arg1 = miner_data + 312;
    temp_double = *(double *)(miner_offset + 104);
    temp_arg2 = miner_data + 312;
    if ( temp_double > *(double *)(work_data + 376) )
      temp_double = *(double *)(work_data + 376);
    *(double *)(work_data + 224) = temp_double;
    if ( *(double *)(miner_offset + 112) > temp_double )
      temp_double = *(double *)(miner_offset + 112);
    *(double *)(work_index + 224) = temp_double;
    while ( 1 )
    {
      get_hardware_timestamp(&start_time, temp_arg1, miner_config_offset, work_index);
      subtract_timevals(&start_time, &current_time);
      add_time_values(&current_time, miner_data + 296);
      if ( compare_priority(&current_time, temp_arg3) )
        copy_system_time(temp_arg3, &current_time);
      if ( compare_task_priorities(&current_time, temp_arg2) )
        copy_system_time(temp_arg2, &current_time);
      work_pointer = work_data;
      ++*(_DWORD *)(miner_data + 292);
      actual_work_data = *(_DWORD *)(work_pointer + 260);
      add_time_values(&current_time, actual_work_data + 388);
      if ( compare_priority(&current_time, actual_work_data + 396) )
        copy_system_time(actual_work_data + 396, &current_time);
      if ( compare_task_priorities(&current_time, actual_work_data + 404) )
        copy_system_time(actual_work_data + 404, &current_time);
      work_ptr = work_data;
      work_counter = *(_DWORD *)(actual_work_data + 384) + 1;
      *(_DWORD *)(actual_work_data + 384) = work_counter;
      get_hardware_timestamp(work_ptr + 424, v22, v23, work_counter);
      pthread_setcancelstate(1, 0);
      update_hardware_timestamp(thread_data);
      hashes_done = ((__int64 (__fastcall *)(int, int, unsigned int, _DWORD))*(_DWORD *)(miner_offset + 64))(
                      thread_data,
                      work_data,
                      frequency + *(_DWORD *)(work_data + 248),
                      0);
      update_timestamp_and_enable(thread_data);
      pthread_setcancelstate(0, 0);
      pthread_testcancel();
      get_hardware_timestamp(&current_time, v27, v28, v29);
      if ( hashes_done == -1 )
        break;
      hash_count += hashes_done;
      if ( *(_QWORD *)(miner_data + 160) < hashes_done )
        *(_QWORD *)(miner_data + 160) = hashes_done;
      nanosecond_diff = current_nanoseconds;
      new_seconds = current_time;
      second_diff = current_time - start_time;
      seconds_sum += current_nanoseconds
                   - start_nanoseconds
                   + (current_nanoseconds - start_nanoseconds < 0 ? 1000000 : 0);
      if ( current_nanoseconds - start_nanoseconds < 0 )
        --second_diff;
      seconds_total += second_diff;
      if ( seconds_sum > 1000000 )
      {
        ++seconds_total;
        seconds_sum -= 1000000;
      }
      second_diff_from_start = current_time - start_raw[0];
      if ( current_nanoseconds - start_raw[1] < 0 )
        --second_diff_from_start;
      if ( waiting_threshold > seconds_total )
      {
        if ( frequency == -1 )
          goto LABEL_46;
        temp_seconds = current_time;
        calculated_sleep = (calculate_modulo_via_bitshift(1000000) + 16) * waiting_threshold;
        max_frequency = calculate_miner_hashrate(-1024, calculated_sleep);
        new_seconds = temp_seconds;
        if ( max_frequency >= frequency )
          frequency = (frequency * calculated_sleep) >> 10;
        else
          frequency = -1;
      }
      else if ( waiting_threshold < seconds_total )
      {
        temp_seconds_53 = current_time;
        min_frequency = calculate_miner_hashrate(waiting_threshold * frequency, seconds_total);
        new_seconds = temp_seconds_53;
        frequency = min_frequency;
      }
      else if ( seconds_sum > (int)&loc_186A0 )
      {
        temp_seconds_54 = current_time;
        temp_frequency = calculate_modulo_via_bitshift(1000000 * waiting_threshold + seconds_sum);
        new_frequency = calculate_miner_hashrate(frequency << 10, temp_frequency);
        new_seconds = temp_seconds_54;
        frequency = new_frequency;
      }
      raw_nanoseconds_diff = nanosecond_diff - previous_time_raw[1];
      negative_flag = raw_nanoseconds_diff < 0;
      nanoseconds_diff = raw_nanoseconds_diff + (raw_nanoseconds_diff < 0 ? 999424 : 0);
      seconds_diff = new_seconds - previous_time_raw[0];
      if ( negative_flag )
      {
        --seconds_diff;
        nanoseconds_diff += 576;
      }
      if ( hash_count )
      {
        should_update_stats = seconds_diff <= 0;
        if ( seconds_diff <= 0 )
          should_update_stats = nanoseconds_diff <= 200000;
        if ( !should_update_stats )
          goto LABEL_41;
      }
      if ( dword_66130 <= seconds_diff )
      {
LABEL_41:
        hash_count_tmp = hash_count;
        hash_count = 0LL;
        update_mining_statistics(thread_number, hash_count_tmp);
        copy_system_time(previous_time_raw, &current_time);
        if ( *(_BYTE *)(thread_data + 62) )
          goto LABEL_54;
      }
      else if ( *(_BYTE *)(thread_data + 62) )
      {
LABEL_54:
        if ( !sleep_duration )
        {
          pause_duration = *(_DWORD *)(thread_data + 4);
          sleep_time.tv_sec = 0;
          sleep_time.tv_nsec = 250000000 * pause_duration;
          nanosleep(&sleep_time, 0);
        }
        goto LABEL_50;
      }
      if ( *(_BYTE *)(thread_data + 60) || (seconds_sum = *(_DWORD *)(miner_data + 32)) != 0 )
      {
        seconds_sum = 0;
        seconds_total = 0;
        toggle_miner_thread(thread_data, thread_number, (int (__fastcall **)(int))(miner_offset + 92));
      }
      else
      {
        seconds_total = 0;
      }
LABEL_46:
      update_stats_flag = *(_QWORD *)(miner_data + 160) > 4294967293uLL;
      if ( dword_66154 < second_diff_from_start )
        update_stats_flag = 1;
      if ( update_stats_flag || check_work_staleness(work_data, 0) )
        goto LABEL_50;
    }
    if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
    {
      snprintf(
        (char *)&sleep_time,
        2048u,
        "%s %d failure, disabling!",
        *(const char **)(miner_offset + 8),
        *(_DWORD *)(miner_data + 8));
      log_event(3, (const char *)&sleep_time, 0);
    }
    *(_DWORD *)(miner_data + 32) = 1;
    update_statistic_counters(miner_data, 1);
    *(_BYTE *)(miner_data + 364) = 1;
LABEL_50:
    clear_miner_data_if_not_null(&work_data, "cgminer.c", "hash_sole_work", 9397);
  }
  while ( !*(_BYTE *)(miner_data + 364) );
LABEL_51:
  *(_DWORD *)(miner_data + 32) = 1;
}
// 344D0: variable 'arg3' is possibly undefined
// 344D0: variable 'arg4' is possibly undefined
// 344D8: variable 'arg1' is possibly undefined
// 344D8: variable 'arg2' is possibly undefined
// 344D8: variable 'v10' is possibly undefined
// 34560: variable 'v14' is possibly undefined
// 34560: variable 'v15' is possibly undefined
// 345E0: variable 'temp_arg1' is possibly undefined
// 345E0: variable 'miner_config_offset' is possibly undefined
// 345E0: variable 'work_index' is possibly undefined
// 34688: variable 'v22' is possibly undefined
// 34688: variable 'v23' is possibly undefined
// 346E8: variable 'v27' is possibly undefined
// 346E8: variable 'v28' is possibly undefined
// 346E8: variable 'v29' is possibly undefined
// 1F1E4: using guessed type int __fastcall sub_1F1E4(_DWORD, _DWORD);
// 1F218: using guessed type int __fastcall sub_1F218(_DWORD, _DWORD);
// 1F25C: using guessed type int __fastcall sub_1F25C(_DWORD, _DWORD);
// 1F290: using guessed type int __fastcall sub_1F290(_DWORD, _DWORD);
// 1F5C4: using guessed type int __fastcall sub_1F5C4(_DWORD, _DWORD, _DWORD, _DWORD);
// 21AD4: using guessed type int __fastcall sub_21AD4(_DWORD, _DWORD);
// 2251C: using guessed type int __fastcall sub_2251C(_DWORD, _DWORD);
// 27174: using guessed type int __fastcall sub_27174(_DWORD);
// 271AC: using guessed type int __fastcall sub_271AC(_DWORD);
// 28FFC: using guessed type int __fastcall sub_28FFC(_DWORD, _DWORD, _DWORD, _DWORD);
// 48AC8: using guessed type int __fastcall sub_48AC8(_DWORD, _DWORD);
// 48D40: using guessed type int __fastcall sub_48D40(_DWORD);
// 657B8: using guessed type int dword_657B8;
// 66130: using guessed type int dword_66130;
// 66154: using guessed type int dword_66154;
// 66640: using guessed type char byte_66640;
// 70CE8: using guessed type char byte_70CE8;

//----- (00034B18) --------------------------------------------------------
void __noreturn watchdog_loop()
{
  int type_set_result; // r0
  int unused1; // r1
  int unused2; // r2
  int sleep_counter; // r4
  int usleep_result; // r0
  int unused3; // r1
  int unused4; // r2
  int unused5; // r3
  int check_result; // r0
  int device_index; // r5
  int should_log; // r3
  int log_type; // r2
  int log_condition; // r3
  int device_status; // r1
  int device_ptr; // r0
  int device; // r4
  int device_info_ptr; // r6
  int elapsed_time; // r3
  int restart_condition; // r3
  int dead_status; // r2
  int dead_condition; // r3
  int restart_time; // r3
  int restart_elapsed; // r2
  int *device_list_ptr; // r3
  int device_list_end; // r1
  int device_entry; // t1
  int restart_device_index; // r4
  int device_thread_ptr; // r0
  int device_thread; // r5
  int log_condition_restart; // r3
  int *rdlock_errno_location; // r0
  int *unlock_errno_location; // r0
  int monitoring_info; // [sp+28h] [bp-840h] BYREF
  char device_label[8]; // [sp+30h] [bp-838h] BYREF
  char log_message[2096]; // [sp+38h] [bp-830h] BYREF

  pthread_setcanceltype(1, 0);
  type_set_result = set_process_name("Watchdog");
  sub_285A8(type_set_result);
  get_hardware_timestamp(&dword_66BC8, unused1, unused2, 0);
LABEL_2:
  while ( 1 )
  {
    sleep_counter = 200;
    do
    {
      usleep_result = usleep(10000u);
      discard_stale_shares(usleep_result);
      --sleep_counter;
    }
    while ( sleep_counter );
    update_mining_statistics(-1, 0LL);
    check_result = get_hardware_timestamp(&monitoring_info, unused3, unused4, unused5);
    if ( unk_70DB4 )
      goto LABEL_93;
    if ( byte_73F88 || byte_72E88 )
    {
      check_result = is_within_operational_time_range(check_result);
      if ( !check_result )
      {
        if ( !byte_70CE8 && !byte_66640 && dword_657B8 <= 3 )
        {
          if ( !byte_73F88 )
            goto LABEL_87;
          goto LABEL_52;
        }
        snprintf(log_message, 2048u, "Pausing execution as per stop time %02d:%02d scheduled", dword_72E94, dword_72E90);
        log_event(4, log_message, 0);
        if ( !byte_73F88 )
        {
LABEL_87:
          strcpy(log_message, "Terminating execution as planned");
          log_event(3, log_message, 1);
          shutdown_miner(0, 1);
        }
        if ( byte_70CE8 || byte_66640 )
        {
LABEL_53:
          snprintf(log_message, 2048u, "Will restart execution as scheduled at %02d:%02d", dword_73F94, dword_73F90);
          log_event(4, log_message, 0);
        }
        else
        {
LABEL_52:
          if ( dword_657B8 > 3 )
            goto LABEL_53;
        }
        unk_70DB4 = 1;
        if ( pthread_rwlock_rdlock(&stru_72EE8) )
        {
          rdlock_errno_location = _errno_location();
          snprintf(
            log_message,
            2048u,
            "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
            *rdlock_errno_location,
            "cgminer.c",
            "watchdog_thread",
            10490);
          goto LABEL_89;
        }
        if ( dword_74180 > 0 )
        {
          device_list_ptr = (int *)dword_71E78;
          device_list_end = dword_71E78 + 4 * dword_74180;
          do
          {
            device_entry = *device_list_ptr++;
            *(_BYTE *)(device_entry + 60) = 1;
          }
          while ( (int *)device_list_end != device_list_ptr );
        }
        if ( pthread_rwlock_unlock(&stru_72EE8) )
        {
          unlock_errno_location = _errno_location();
          snprintf(
            log_message,
            2048u,
            "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
            *unlock_errno_location,
            "cgminer.c",
            "watchdog_thread",
            10497);
LABEL_89:
          log_event(3, log_message, 1);
          shutdown_miner(1, 1);
        }
        off_658DC(0);
        goto LABEL_8;
      }
      if ( unk_70DB4 )
      {
LABEL_93:
        if ( !byte_73F88 && !byte_72E88 || is_within_operational_time_range(check_result) )
          break;
      }
    }
LABEL_8:
    if ( dword_72F38 > 0 )
    {
      device_index = 0;
      while ( 1 )
      {
        device_ptr = get_device_by_index(device_index);
        device = device_ptr;
        device_info_ptr = **(_DWORD **)(device_ptr + 152);
        if ( !device_info_ptr )
          goto LABEL_22;
        (*(void (**)(void))(*(_DWORD *)(device_ptr + 4) + 32))();
        snprintf(device_label, 8u, "%s %d", *(const char **)(*(_DWORD *)(device + 4) + 8), *(_DWORD *)(device + 8));
        if ( *(_BYTE *)(device_info_ptr + 61) || *(_DWORD *)(device + 32) == 1 )
          goto LABEL_22;
        device_status = *(_DWORD *)(device + 96);
        elapsed_time = monitoring_info - *(_DWORD *)(device_info_ptr + 44);
        if ( !device_status )
        {
          if ( elapsed_time <= 120 )
            goto LABEL_22;
          should_log = (unsigned __int8)byte_70CE8;
          log_type = 1;
          *(_QWORD *)(device + 48) = 0LL;
          *(_DWORD *)(device + 96) = 1;
          if ( should_log || byte_66640 || (log_condition = dword_657B8, dword_657B8 > 2) )
          {
            snprintf(log_message, 2048u, "%s: Idle for more than 60 seconds, declaring SICK!", device_label);
            log_event(3, log_message, 0);
          }
          get_hardware_timestamp(device_info_ptr + 52, device_status, log_type, log_condition);
          update_statistic_counters(device, 3);
          if ( !byte_6615C )
            goto LABEL_22;
          if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
          {
            snprintf(log_message, 2048u, "%s: Attempting to restart", device_label);
            log_event(3, log_message, 0);
          }
LABEL_20:
          if ( *(_DWORD *)(device + 32) != 1 )
            (*(void (__fastcall **)(int))(*(_DWORD *)(device + 4) + 16))(device);
          goto LABEL_22;
        }
        if ( elapsed_time <= 119 )
        {
          if ( device_status != 4 && (byte_70CE8 || byte_66640 || dword_657B8 > 2) )
          {
            snprintf(log_message, 2048u, "%s: Recovered, declaring WELL!", device_label);
            log_event(3, log_message, 0);
          }
          *(_DWORD *)(device + 96) = 0;
          *(_DWORD *)(device + 240) = time(0);
          goto LABEL_22;
        }
        if ( device_status != 1 )
          break;
        if ( elapsed_time > 600 )
        {
          restart_condition = (unsigned __int8)byte_70CE8;
          dead_status = 2;
          *(_DWORD *)(device + 96) = 2;
          if ( restart_condition || byte_66640 || (dead_condition = dword_657B8, dword_657B8 > 2) )
          {
            snprintf(log_message, 2048u, "%s: Not responded for more than 10 minutes, declaring DEAD!", device_label);
            log_event(3, log_message, 0);
          }
          get_hardware_timestamp(device_info_ptr + 52, device_status, dead_status, dead_condition);
          update_statistic_counters(device, 4);
          goto LABEL_22;
        }
        restart_time = *(_DWORD *)(device_info_ptr + 52);
        restart_elapsed = monitoring_info - restart_time;
        if ( monitoring_info - restart_time > 60 )
          goto LABEL_43;
LABEL_22:
        if ( dword_72F38 <= ++device_index )
          goto LABEL_2;
      }
      restart_time = *(_DWORD *)(device_info_ptr + 52);
      restart_elapsed = monitoring_info - restart_time;
      if ( monitoring_info - restart_time <= 60 || device_status != 2 )
        goto LABEL_22;
LABEL_43:
      get_hardware_timestamp(device_info_ptr + 52, device_status, restart_elapsed, restart_time);
      if ( byte_6615C )
        goto LABEL_20;
      goto LABEL_22;
    }
  }
  if ( byte_70CE8 || byte_66640 || dword_657B8 > 3 )
  {
    snprintf(log_message, 2048u, "Restarting execution as per start time %02d:%02d scheduled", dword_73F94, dword_73F90);
    log_event(4, log_message, 0);
    if ( !byte_72E88 )
      goto LABEL_66;
    if ( byte_70CE8 || byte_66640 )
    {
LABEL_80:
      snprintf(log_message, 2048u, "Will pause execution as scheduled at %02d:%02d", dword_72E94, dword_72E90);
      log_event(4, log_message, 0);
LABEL_66:
      restart_device_index = 0;
      for ( unk_70DB4 = 0; dword_74180 > restart_device_index; ++restart_device_index )
      {
        device_thread_ptr = get_thread_metadata(restart_device_index);
        device_thread = device_thread_ptr;
        if ( *(_DWORD *)(*(_DWORD *)(device_thread_ptr + 36) + 32) != 1 )
        {
          log_condition_restart = (unsigned __int8)byte_66641;
          *(_BYTE *)(device_thread_ptr + 60) = 0;
          if ( log_condition_restart && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
          {
            snprintf(log_message, 2048u, "Pushing sem post to thread %d", *(_DWORD *)device_thread_ptr);
            log_event(7, log_message, 0);
          }
          post_semaphore_and_log_failure(device_thread + 16, "cgminer.c", "watchdog_thread", 10524);
        }
      }
      goto LABEL_8;
    }
  }
  else if ( !byte_72E88 )
  {
    goto LABEL_66;
  }
  if ( dword_657B8 <= 3 )
    goto LABEL_66;
  goto LABEL_80;
}
// 34B98: variable 'unused1' is possibly undefined
// 34B98: variable 'unused2' is possibly undefined
// 34BC8: variable 'unused3' is possibly undefined
// 34BC8: variable 'unused4' is possibly undefined
// 34BC8: variable 'unused5' is possibly undefined
// 34CB4: variable 'device_status' is possibly undefined
// 34CB4: variable 'log_type' is possibly undefined
// 34CB4: variable 'log_condition' is possibly undefined
// 34EC8: variable 'dead_status' is possibly undefined
// 34EC8: variable 'dead_condition' is possibly undefined
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 1DA28: using guessed type int sub_1DA28(void);
// 1F5C4: using guessed type int __fastcall sub_1F5C4(_DWORD, _DWORD, _DWORD, _DWORD);
// 21AD4: using guessed type int __fastcall sub_21AD4(_DWORD, _DWORD);
// 21DB8: using guessed type int __fastcall sub_21DB8(_DWORD);
// 21EBC: using guessed type int __fastcall sub_21EBC(_DWORD, _DWORD, _DWORD, _DWORD);
// 28048: using guessed type int __fastcall sub_28048(_DWORD);
// 285A8: using guessed type int __fastcall sub_285A8(_DWORD);
// 2AB30: using guessed type void __fastcall __noreturn sub_2AB30(_DWORD, _DWORD);
// 2C8F4: using guessed type int __fastcall sub_2C8F4(_DWORD);
// 2DF8C: using guessed type int __fastcall sub_2DF8C(_DWORD);
// 32E14: using guessed type int __fastcall sub_32E14(_DWORD);
// 657B8: using guessed type int dword_657B8;
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);
// 6615C: using guessed type char byte_6615C;
// 66640: using guessed type char byte_66640;
// 66641: using guessed type char byte_66641;
// 66BC8: using guessed type int dword_66BC8;
// 70CE8: using guessed type char byte_70CE8;
// 71E78: using guessed type int dword_71E78;
// 72E88: using guessed type char byte_72E88;
// 72E90: using guessed type int dword_72E90;
// 72E94: using guessed type int dword_72E94;
// 72EE8: using guessed type pthread_rwlock_t stru_72EE8;
// 72F38: using guessed type int dword_72F38;
// 73F88: using guessed type char byte_73F88;
// 73F90: using guessed type int dword_73F90;
// 73F94: using guessed type int dword_73F94;
// 74180: using guessed type int dword_74180;

//----- (00035370) --------------------------------------------------------
int __fastcall sub_35370(_DWORD *a1)
{
  pthread_t v2; // r0
  int v3; // r0
  int v4; // r0
  int v5; // r5
  __int64 v6; // r6
  int v7; // r0
  int v8; // r1
  __int64 v9; // r2
  bool v10; // zf
  char v11; // r4
  int v12; // r4
  void ***v13; // r6
  int v14; // r5
  time_t v15; // r0
  int v16; // r3
  int v17; // r2
  void **v18; // r8
  size_t v19; // r0
  int v20; // r3
  int v21; // r12
  int v22; // r1
  void ***v23; // r5
  int v24; // r3
  unsigned int v25; // r2
  unsigned int v26; // r1
  int v27; // r3
  unsigned int v28; // r2
  unsigned int v29; // r1
  int v30; // r3
  unsigned int v31; // r4
  void **v32; // r3
  int v33; // r2
  void **v34; // r3
  char *v35; // r3
  int v36; // r1
  void ****v37; // r3
  __int64 v38; // r2
  time_t v39; // r0
  void **v40; // r2
  int v41; // r3
  int v42; // r0
  _DWORD *v44; // r7
  void **v45; // r3
  unsigned int v46; // r4
  int v47; // r11
  _DWORD *v48; // r5
  _DWORD *v49; // r8
  int v50; // r4
  char *v51; // r9
  unsigned int v52; // r3
  int v53; // r3
  void **v54; // r3
  void *v55; // r2
  unsigned int v56; // r1
  bool v57; // cc
  char *v58; // r2
  char *v59; // lr
  char *v60; // r12
  int v61; // r0
  int v62; // r1
  int v63; // r2
  int v64; // r3
  _DWORD *v65; // lr
  char *v66; // r12
  int v67; // r1
  int v68; // r2
  int v69; // r3
  void **v70; // r0
  void **v71; // r7
  void *v72; // r0
  int *v73; // r0
  int v74; // r3
  const char *v75; // r1
  int v76; // r3
  int v77; // r3
  int v78; // r3
  int v79; // r2
  int v80; // r1
  int v81; // r3
  int v82; // r3
  int v83; // r3
  int v84; // r3
  unsigned int v85; // [sp+20h] [bp-CA0h]
  int v86; // [sp+24h] [bp-C9Ch]
  __int64 v87; // [sp+28h] [bp-C98h]
  _DWORD *v88; // [sp+4Ch] [bp-C74h]
  int v89; // [sp+54h] [bp-C6Ch] BYREF
  int v90; // [sp+58h] [bp-C68h] BYREF
  int v91; // [sp+5Ch] [bp-C64h] BYREF
  __int64 v92; // [sp+60h] [bp-C60h] BYREF
  char v93[12]; // [sp+68h] [bp-C58h] BYREF
  char s[16]; // [sp+74h] [bp-C4Ch] BYREF
  char v95[20]; // [sp+84h] [bp-C3Ch] BYREF
  char v96[1024]; // [sp+98h] [bp-C28h] BYREF
  char v97[2088]; // [sp+498h] [bp-828h] BYREF

  v2 = pthread_self();
  pthread_detach(v2);
  snprintf(s, 16u, "%d/SStratum", *a1);
  v3 = set_process_name(s);
  v4 = initialize_task_queue(v3);
  a1[182] = v4;
  if ( !v4 )
  {
    v59 = " stratum_q in stratum_sthread";
    qmemcpy(v97, "Failed to create", 16);
    v60 = &v97[16];
LABEL_85:
    v61 = *(_DWORD *)v59;
    v62 = *((_DWORD *)v59 + 1);
    v63 = *((_DWORD *)v59 + 2);
    v64 = *((_DWORD *)v59 + 3);
    v65 = v59 + 16;
    *(_DWORD *)v60 = v61;
    *((_DWORD *)v60 + 1) = v62;
    *((_DWORD *)v60 + 2) = v63;
    *((_DWORD *)v60 + 3) = v64;
    v66 = v60 + 16;
    v67 = v65[1];
    v68 = v65[2];
    v69 = v65[3];
    *(_DWORD *)v66 = *v65;
    *((_DWORD *)v66 + 1) = v67;
    *((_DWORD *)v66 + 2) = v68;
    *((_WORD *)v66 + 6) = v69;
    log_event(3, v97, 1);
    shutdown_miner(1, 1);
  }
  if ( byte_70CE8 || byte_66640 || dword_657B8 > 4 )
  {
    snprintf(v97, 2048u, "in %s , pool: %d, pool_url: %s", "stratum_sthread", *a1, (const char *)a1[41]);
    log_event(5, v97, 0);
    v4 = a1[182];
  }
  v5 = 0;
  v6 = 0LL;
  if ( *((_BYTE *)a1 + 105) )
    goto LABEL_48;
  do
  {
    v7 = pop_task_from_queue(v4);
    v90 = v7;
    if ( !v7 )
    {
      v59 = "Stratum q returned empty work";
      v60 = v97;
      goto LABEL_85;
    }
    if ( *(_DWORD *)(v7 + 304) > 8u )
    {
      if ( (byte_70CE8 || byte_66640 || dword_657B8 > 2)
        && ((snprintf(
               v97,
               2048u,
               "Pool %d asking for inappropriately long nonce2 length %d",
               *a1,
               *(_DWORD *)(v7 + 304)),
             log_event(3, v97, 0),
             byte_70CE8)
         || byte_66640)
        || dword_657B8 > 2 )
      {
        strcpy(v97, "Not attempting to submit shares");
        log_event(3, v97, 0);
      }
      clear_miner_data_if_not_null(&v90, "cgminer.c", "stratum_sthread", 7695);
      goto LABEL_47;
    }
    v8 = *(_DWORD *)(v7 + 76);
    v9 = *(_QWORD *)(v7 + 296);
    v86 = v8;
    v10 = HIDWORD(v9) == HIDWORD(v6);
    v87 = v9;
    if ( HIDWORD(v9) == HIDWORD(v6) )
      v10 = (_DWORD)v9 == (_DWORD)v6;
    v89 = *(_DWORD *)(v7 + 76);
    v11 = v10;
    if ( v8 == v5 )
      v12 = v11 & 1;
    else
      v12 = 0;
    v92 = v9;
    if ( v12 )
    {
      if ( byte_70CE8 || byte_66640 || dword_657B8 > 5 )
      {
        snprintf(v97, 2048u, "Filtering duplicate share to pool %d", *a1);
        log_event(6, v97, 0);
      }
      clear_miner_data_if_not_null(&v90, "cgminer.c", "stratum_sthread", 7707);
      goto LABEL_47;
    }
    if ( *(double *)(v7 + 312) < *((double *)a1 + 227) )
    {
      if ( byte_70CE8 || byte_66640 || dword_657B8 > 5 )
      {
        snprintf(v97, 2048u, "Filtering high hash share to pool %d", *a1);
        log_event(6, v97, 0);
      }
      clear_miner_data_if_not_null(&v90, "cgminer.c", "stratum_sthread", 7715);
      goto LABEL_47;
    }
    convert_bytes_to_hexstring(v93, &v89, 4);
    convert_bytes_to_hexstring(v95, &v92, *(_DWORD *)(v90 + 304));
    v13 = (void ***)allocate_and_log_on_fail(52, 1, "cgminer.c", "stratum_sthread", 7724);
    v14 = v90;
    v15 = time(0);
    v16 = v90;
    v13[11] = (void **)v15;
    v13[9] = (void **)v16;
    memset(v96, 0, sizeof(v96));
    if ( pthread_mutex_lock(&stru_66BAC) )
    {
      v73 = _errno_location();
      snprintf(
        v97,
        2048u,
        "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
        *v73,
        "cgminer.c",
        "stratum_sthread",
        7733);
      goto LABEL_104;
    }
    v17 = dword_70D14;
    v13[10] = (void **)dword_70D14;
    dword_70D14 = v17 + 1;
    if ( pthread_mutex_unlock(&stru_66BAC) )
    {
      v74 = *_errno_location();
      snprintf(
        v97,
        2048u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        v74,
        "cgminer.c",
        "stratum_sthread",
        7736);
      goto LABEL_104;
    }
    off_658DC(0);
    v91 = 0;
    hex_string_to_binary(&v91, a1 + 445);
    if ( *((_BYTE *)a1 + 644) )
      snprintf(
        v96,
        1024u,
        "{\"params\": [\"%s\", \"%s\", \"%s\", \"%s\", \"%s\", \"%08x\"], \"id\": %d, \"method\": \"mining.submit\"}",
        (const char *)a1[43],
        *(const char **)(v90 + 288),
        v95,
        *(const char **)(v90 + 308),
        v93,
        bswap32(*(_DWORD *)(v90 + 444) & ~v91),
        v13[10]);
    else
      snprintf(
        v96,
        1024u,
        "{\"params\": [\"%s\", \"%s\", \"%s\", \"%s\", \"%s\"], \"id\": %d, \"method\": \"mining.submit\"}",
        (const char *)a1[43],
        *(const char **)(v90 + 288),
        v95,
        *(const char **)(v90 + 308),
        v93,
        v13[10]);
    if ( byte_70CE8 || byte_66640 || dword_657B8 > 5 )
    {
      snprintf(v97, 2048u, "Submitting share %08lx to pool %d", *(_DWORD *)(v14 + 216), *a1);
      log_event(6, v97, 0);
    }
    while ( 1 )
    {
      v18 = v13[11];
      if ( (int)v18 + 119 < time(0) )
        goto LABEL_121;
      v19 = strlen(v96);
      if ( stratum_send(a1, v96, v19) )
      {
        if ( pthread_mutex_lock(&stru_66BAC) )
        {
          v76 = *_errno_location();
          snprintf(
            v97,
            2048u,
            "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
            v76,
            "cgminer.c",
            "stratum_sthread",
            7780);
          goto LABEL_104;
        }
        v20 = *((unsigned __int8 *)v13 + 40);
        v21 = *((unsigned __int8 *)v13 + 43);
        v22 = *((unsigned __int8 *)v13 + 42);
        v13[5] = (void **)(v13 + 10);
        v23 = (void ***)dword_66BC4;
        v24 = v20 + 17973517 + (v21 << 24) + (v22 << 16) + (*((unsigned __int8 *)v13 + 41) << 8);
        v13[6] = (void **)4;
        v24 ^= 522093u;
        v25 = (-1622558010 - v24) ^ (v24 << 8);
        v26 = (-17973517 - v24 - v25) ^ (v25 >> 13);
        v27 = (v24 - v25 - v26) ^ (v26 >> 12);
        v28 = (v25 - v26 - v27) ^ (v27 << 16);
        v29 = (v26 - v27 - v28) ^ (v28 >> 5);
        v30 = (v27 - v28 - v29) ^ (v29 >> 3);
        v31 = (v29 - v30 - ((v28 - v29 - v30) ^ (v30 << 10))) ^ (((v28 - v29 - v30) ^ (v30 << 10)) >> 15);
        v13[7] = (void **)v31;
        if ( v23 )
        {
          v32 = *v23;
          v13[2] = 0;
          *v13 = v32;
          v13[1] = (void **)((_BYTE *)(*v23)[4] - (_BYTE *)(*v23)[5]);
          *((_DWORD *)(*v23)[4] + 2) = v13;
          (*v23)[4] = v13;
        }
        else
        {
          v13[2] = 0;
          v13[1] = 0;
          dword_66BC4 = (int)v13;
          v70 = (void **)malloc(44u);
          *v13 = v70;
          if ( !v70 )
            goto LABEL_151;
          memset(v70, 0, 44u);
          (*v13)[4] = v13;
          (*v13)[1] = (void *)32;
          (*v13)[2] = (void *)5;
          (*v13)[5] = 0;
          v71 = *v13;
          *v71 = malloc(384u);
          v72 = **v13;
          if ( !v72 )
            goto LABEL_151;
          memset(v72, 0, 384u);
          v23 = v13;
          (*v13)[10] = (void *)-1609490463;
        }
        (*v23)[3] = (char *)(*v23)[3] + 1;
        v33 = 12 * (v31 & ((unsigned int)(*v23)[1] - 1));
        ++*(_DWORD *)((char *)**v23 + v33 + 4);
        v34 = *(void ***)((char *)**v23 + v33);
        v13[3] = 0;
        v13[4] = v34;
        v35 = (char *)**v23;
        v36 = *(_DWORD *)&v35[v33];
        v37 = (void ****)&v35[v33];
        if ( v36 )
        {
          *(_DWORD *)(v36 + 12) = v13;
          v37 = (void ****)((char *)**v23 + v33);
        }
        *v37 = v13;
        v38 = *(_QWORD *)((char *)**v23 + v33 + 4);
        if ( (unsigned int)v38 < 10 * (HIDWORD(v38) + 1) || (*v13)[9] == (void *)1 )
          goto LABEL_34;
        v44 = calloc(24 * (_DWORD)(*v13)[1], 1u);
        if ( v44 )
        {
          (*v13)[6] = (void *)((((2 * (_DWORD)(*v13)[1] - 1) & (unsigned int)(*v13)[3]) != 0)
                             + ((unsigned int)(*v13)[3] >> (*((_BYTE *)*v13 + 8) + 1)));
          (*v13)[7] = 0;
          v45 = *v13;
          v46 = (unsigned int)(*v13)[1];
          if ( v46 )
          {
            v47 = 0;
            v85 = 0;
            v88 = a1;
            do
            {
              v48 = *(_DWORD **)((char *)*v45 + v47);
              if ( v48 )
              {
                while ( 1 )
                {
                  v49 = (_DWORD *)v48[4];
                  v50 = 3 * ((2 * v46 - 1) & v48[7]);
                  v51 = (char *)&v44[v50];
                  v52 = *((_DWORD *)v51 + 1) + 1;
                  *((_DWORD *)v51 + 1) = v52;
                  if ( v52 > (unsigned int)(*v13)[6] )
                  {
                    (*v13)[7] = (char *)(*v13)[7] + 1;
                    *((_DWORD *)v51 + 2) = calculate_miner_hashrate(*((_DWORD *)v51 + 1), (*v13)[6]);
                  }
                  v48[3] = 0;
                  v48[4] = v44[v50];
                  v53 = v44[v50];
                  if ( v53 )
                    *(_DWORD *)(v53 + 12) = v48;
                  v44[v50] = v48;
                  v45 = *v13;
                  if ( !v49 )
                    break;
                  v46 = (unsigned int)v45[1];
                  v48 = v49;
                }
                v46 = (unsigned int)v45[1];
              }
              v47 += 12;
              ++v85;
            }
            while ( v85 < v46 );
            a1 = v88;
          }
          free(*v45);
          (*v13)[1] = (void *)(2 * (_DWORD)(*v13)[1]);
          (*v13)[2] = (char *)(*v13)[2] + 1;
          **v13 = v44;
          v54 = *v13;
          v55 = (*v13)[7];
          v56 = (unsigned int)(*v13)[3];
          v57 = (unsigned int)v55 > v56 >> 1;
          if ( (unsigned int)v55 <= v56 >> 1 )
            v58 = 0;
          else
            v58 = (char *)v54[8];
          if ( v57 )
            ++v58;
          v54[8] = v58;
          if ( (unsigned int)(*v13)[8] > 1 )
            (*v13)[9] = (void *)1;
LABEL_34:
          ++a1[183];
          if ( !pthread_mutex_unlock(&stru_66BAC) )
          {
            ((void (*)(void))off_658DC)();
            if ( reset_thread_signal(a1, a1 + 24) )
            {
              if ( !byte_70CE8 && !byte_66640 && dword_657B8 <= 3 )
              {
                if ( !byte_66641 )
                {
LABEL_40:
                  v39 = time(0);
                  v40 = v13[11];
                  v41 = (unsigned __int8)byte_66641;
                  v13[12] = (void **)v39;
                  v42 = v39 - (_DWORD)v40;
                  if ( v42 > 0 )
                    v41 |= 1u;
                  if ( v41 && (byte_70CE8 || byte_66640 || dword_657B8 > 5) )
                  {
                    snprintf(v97, 2048u, "Pool %d stratum share submission lag time %d seconds", *a1, v42);
                    log_event(6, v97, 0);
                  }
                  goto LABEL_46;
                }
                goto LABEL_82;
              }
              snprintf(v97, 2048u, "Pool %d communication resumed, submitting work", *a1);
              log_event(4, v97, 0);
            }
            if ( !byte_66641 )
              goto LABEL_40;
            if ( byte_70CE8 || byte_66640 )
            {
LABEL_53:
              strcpy(v97, "Successfully submitted, adding to stratum_shares db");
              log_event(7, v97, 0);
              goto LABEL_40;
            }
LABEL_82:
            if ( dword_657B8 <= 6 )
              goto LABEL_40;
            goto LABEL_53;
          }
          v77 = *_errno_location();
          snprintf(
            v97,
            2048u,
            "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
            v77,
            "cgminer.c",
            "stratum_sthread",
            7783);
LABEL_104:
          log_event(3, v97, 1);
          shutdown_miner(1, 1);
        }
LABEL_151:
        exit(-1);
      }
      if ( !set_pool_test_flag(a1, a1 + 24) && is_miner_allowed_to_mine(a1) )
      {
        if ( byte_70CE8 || byte_66640 || dword_657B8 > 3 )
        {
          snprintf(v97, 2048u, "Pool %d stratum share submission failure", *a1);
          log_event(4, v97, 0);
        }
        v81 = a1[33] + 1;
        ++dword_70D04;
        a1[33] = v81;
      }
      if ( byte_72EDC )
        break;
      if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 53)) )
      {
        v82 = *_errno_location();
        snprintf(
          v97,
          2048u,
          "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
          v82,
          "cgminer.c",
          "stratum_sthread",
          7805);
        goto LABEL_104;
      }
      if ( pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 59)) )
      {
        v83 = *_errno_location();
        snprintf(
          v97,
          2048u,
          "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
          v83,
          "cgminer.c",
          "stratum_sthread",
          7805);
        goto LABEL_104;
      }
      if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 53)) )
      {
        v84 = *_errno_location();
        snprintf(
          v97,
          2048u,
          "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
          v84,
          "cgminer.c",
          "stratum_sthread",
          7805);
        goto LABEL_104;
      }
      v75 = (const char *)a1[153];
      if ( !v75 || strcmp(*(const char **)(v90 + 320), v75) )
      {
        if ( !pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 59)) )
        {
          ((void (*)(void))off_658DC)();
          if ( byte_66641 )
          {
            if ( !byte_70CE8 && !byte_66640 && dword_657B8 <= 6 )
              goto LABEL_123;
            strcpy(v97, "No matching session id for resubmitting stratum share");
            log_event(7, v97, 0);
LABEL_121:
            if ( byte_66641 )
            {
              if ( !byte_70CE8 )
                goto LABEL_123;
              goto LABEL_125;
            }
          }
          goto LABEL_126;
        }
LABEL_120:
        v78 = *_errno_location();
        snprintf(
          v97,
          2048u,
          "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
          v78,
          "cgminer.c",
          "stratum_sthread",
          7807);
        goto LABEL_104;
      }
      if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 59)) )
        goto LABEL_120;
      ((void (*)(void))off_658DC)();
      sleep(2u);
    }
    if ( byte_66641 )
    {
      if ( byte_70CE8 || byte_66640 || dword_657B8 > 6 )
      {
        strcpy(v97, "Lowmem option prevents resubmitting stratum share");
        log_event(7, v97, 0);
        goto LABEL_121;
      }
LABEL_123:
      if ( byte_66640 || dword_657B8 > 6 )
      {
LABEL_125:
        strcpy(v97, "Failed to submit stratum share, discarding");
        log_event(7, v97, 0);
      }
    }
LABEL_126:
    clear_miner_data_if_not_null(&v90, "cgminer.c", "stratum_sthread", 7822);
    free(v13);
    v79 = qword_74220;
    v80 = MEMORY[0x74224];
    ++a1[30];
    *(_QWORD *)&qword_74220 = __PAIR64__(v80, v79) + 1;
LABEL_46:
    v5 = v86;
    v6 = v87;
LABEL_47:
    v4 = a1[182];
  }
  while ( !*((_BYTE *)a1 + 105) );
LABEL_48:
  update_task_state_to_running(v4);
  return 0;
}
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 1DA28: using guessed type int sub_1DA28(void);
// 1E7D4: using guessed type int __fastcall sub_1E7D4(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1E944: using guessed type int __fastcall sub_1E944(_DWORD, _DWORD, _DWORD);
// 1EA68: using guessed type int __fastcall sub_1EA68(_DWORD, _DWORD);
// 1EF20: using guessed type int __fastcall sub_1EF20(_DWORD);
// 1EFE4: using guessed type int __fastcall sub_1EFE4(_DWORD);
// 1F0C8: using guessed type int __fastcall sub_1F0C8(_DWORD);
// 203BC: using guessed type int __fastcall sub_203BC(_DWORD, _DWORD, _DWORD);
// 21DB8: using guessed type int __fastcall sub_21DB8(_DWORD);
// 28FFC: using guessed type int __fastcall sub_28FFC(_DWORD, _DWORD, _DWORD, _DWORD);
// 2AB30: using guessed type void __fastcall __noreturn sub_2AB30(_DWORD, _DWORD);
// 2B518: using guessed type int __fastcall sub_2B518(_DWORD, _DWORD);
// 2B5FC: using guessed type int __fastcall sub_2B5FC(_DWORD, _DWORD);
// 2E8AC: using guessed type int __fastcall sub_2E8AC(_DWORD);
// 48AC8: using guessed type int __fastcall sub_48AC8(_DWORD, _DWORD);
// 657B8: using guessed type int dword_657B8;
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);
// 66640: using guessed type char byte_66640;
// 66641: using guessed type char byte_66641;
// 66BC4: using guessed type int dword_66BC4;
// 70CE8: using guessed type char byte_70CE8;
// 70D04: using guessed type int dword_70D04;
// 70D14: using guessed type int dword_70D14;
// 72EDC: using guessed type char byte_72EDC;
// 74220: using guessed type int dword_74220;
// 74224: using guessed type int dword_74224;

//----- (00036458) --------------------------------------------------------
int __fastcall sub_36458(int a1)
{
  _DWORD *v1; // r2
  int v2; // r1
  int v3; // r4
  size_t v4; // r5
  __int64 v6; // r2
  int v7; // r6
  int v8; // r12
  int v9; // r12
  int v10; // r12
  unsigned int v11; // r7
  size_t v12; // r5
  int v13; // r3
  char *v14; // r10
  int v15; // r0
  unsigned int v16; // r11
  unsigned int v17; // r7
  unsigned __int8 *v18; // r4
  unsigned int v19; // r1
  unsigned int v20; // r3
  int v21; // r2
  unsigned int v22; // r1
  unsigned int v23; // r3
  int v24; // r2
  unsigned int v25; // r1
  unsigned int v26; // r3
  size_t v27; // r3
  int v28; // r0
  unsigned int v29; // r2
  unsigned int v30; // lr
  int v31; // r1
  unsigned int v32; // r3
  unsigned int v33; // r2
  unsigned int v34; // r1
  unsigned int v35; // r7
  _DWORD *v36; // r2
  int v37; // r4
  int v38; // r8
  int v39; // r4
  int v40; // r3
  int current_pool_index; // r0
  int v42; // r3
  int v43; // r1
  int v44; // r2
  int v45; // r3
  char *v46; // r0
  int v47; // r7
  int v48; // r4
  int v49; // r5
  int v50; // r3
  int v51; // r10
  int v52; // r9
  int v53; // r2
  int v54; // r12
  unsigned int v55; // lr
  int v56; // r3
  int v57; // r0
  int v58; // r1
  int v59; // r0
  int v60; // r8
  bool v61; // zf
  int v62; // r3
  bool v63; // zf
  bool v64; // zf
  int v65; // r11
  int v66; // r10
  int v67; // r1
  int v68; // r2
  int v69; // r0
  int v70; // r3
  int v71; // r4
  _DWORD *v72; // r2
  int v73; // r3
  int v74; // r2
  __int64 v75; // r2
  unsigned int v76; // r8
  unsigned int v77; // lr
  unsigned __int8 *v78; // r11
  int v79; // r3
  int v80; // r7
  int v81; // r4
  int v82; // r0
  unsigned __int8 *v83; // r10
  int v84; // r1
  unsigned int v85; // r2
  unsigned int v86; // r7
  int v87; // r3
  unsigned int v88; // r1
  unsigned int v89; // r2
  int v90; // r3
  unsigned int v91; // r1
  unsigned int v92; // r2
  int v93; // r1
  unsigned int v94; // r2
  size_t v95; // lr
  int v96; // r3
  unsigned int v97; // r2
  unsigned int v98; // r12
  int v99; // r3
  unsigned int v100; // r1
  unsigned int v101; // r2
  unsigned int v102; // r3
  unsigned int v103; // r4
  int v104; // r3
  int v105; // r8
  __int64 v106; // r2
  int v107; // r3
  int v108; // r1
  int *v109; // r2
  __int64 v110; // r2
  int v111; // r3
  int v112; // r0
  signed int v113; // r5
  char v114; // r1
  int v115; // r2
  __int64 v116; // r0
  double v117; // r0
  double v118; // d8
  int v119; // r5
  struct tm *v120; // r0
  int v121; // r9
  char *v122; // r3
  int v123; // t1
  int v124; // r0
  int v125; // r1
  int v126; // r2
  int v127; // r3
  const char *v128; // r2
  int v129; // r12
  char *v130; // r3
  _DWORD *v131; // r8
  int v132; // r2
  int v133; // r2
  unsigned int v134; // r4
  int v135; // r11
  _DWORD *v136; // r5
  _DWORD *v137; // r6
  int v138; // r4
  char *v139; // r9
  unsigned int v140; // r3
  int v141; // r2
  int v142; // r3
  _DWORD *v143; // r3
  unsigned int v144; // r2
  unsigned int v145; // r1
  bool v146; // cc
  int v147; // r2
  int v148; // r3
  int v149; // r4
  int *v150; // r0
  int v151; // r3
  int *v152; // r0
  const char *v153; // lr
  int v154; // r3
  int v155; // r12
  int *v156; // r0
  int *v157; // r0
  int *v158; // r0
  char *v159; // r3
  void *v160; // r0
  void **v161; // r9
  void *v162; // r0
  unsigned __int64 v163; // r0
  int *v164; // r0
  int v165; // r3
  int *v166; // r0
  _DWORD *v167; // [sp+10h] [bp-8B8h]
  int v168; // [sp+14h] [bp-8B4h]
  int v169; // [sp+1Ch] [bp-8ACh]
  size_t v170; // [sp+24h] [bp-8A4h]
  unsigned int v171; // [sp+24h] [bp-8A4h]
  char *v172; // [sp+2Ch] [bp-89Ch]
  char *v173; // [sp+2Ch] [bp-89Ch]
  int v174; // [sp+30h] [bp-898h] BYREF
  int s2[8]; // [sp+34h] [bp-894h] BYREF
  char s[12]; // [sp+54h] [bp-874h] BYREF
  char v177; // [sp+60h] [bp-868h] BYREF
  int v178[524]; // [sp+98h] [bp-830h] BYREF

  v1 = *(_DWORD **)(a1 + 260);
  v2 = *(unsigned __int8 *)(a1 + 282);
  v174 = 0;
  v3 = v1[392];
  v167 = v1;
  v168 = v2;
  v4 = *(unsigned __int8 *)(v3 + 42);
  if ( v2 )
    return v168;
  v6 = *(_QWORD *)(a1 + 28);
  v7 = a1;
  v8 = *(_DWORD *)(a1 + 24);
  s2[0] = *(_DWORD *)(a1 + 32);
  HIDWORD(v6) = *(_DWORD *)(a1 + 20);
  s2[2] = v8;
  v9 = *(_DWORD *)(a1 + 16);
  s2[3] = HIDWORD(v6);
  HIDWORD(v6) = *(_DWORD *)(a1 + 12);
  s2[4] = v9;
  v10 = *(_DWORD *)(a1 + 8);
  s2[5] = HIDWORD(v6);
  HIDWORD(v6) = *(_DWORD *)(a1 + 4);
  s2[1] = v6;
  s2[6] = v10;
  s2[7] = HIDWORD(v6);
  convert_bytes_to_hexstring(s, (int)s2, 32);
  if ( v4 <= 4 )
  {
    log_memcpy_error(&v174, (const void *)(v3 + 43), v4, (int)"cgminer.c", (int)"test_work_current", 5682);
    --v174;
  }
  if ( pthread_mutex_lock((pthread_mutex_t *)(v167 + 53)) )
  {
    v152 = _errno_location();
    snprintf(
      (char *)v178,
      2048u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v152,
      "cgminer.c",
      "test_work_current",
      5687);
    goto LABEL_204;
  }
  if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(v167 + 59)) )
  {
    v153 = "test_work_current";
    v154 = *_errno_location();
    v155 = 5687;
LABEL_223:
    snprintf((char *)v178, 2048u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", v154, "cgminer.c", v153, v155);
    goto LABEL_204;
  }
  if ( *((_BYTE *)v167 + 680) )
  {
    *((_BYTE *)v167 + 680) = 0;
    *(_BYTE *)(v7 + 280) = 1;
  }
  if ( pthread_rwlock_unlock((pthread_rwlock_t *)(v167 + 59)) )
  {
    v156 = _errno_location();
    snprintf(
      (char *)v178,
      2048u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v156,
      "cgminer.c",
      "test_work_current",
      5695);
    goto LABEL_204;
  }
  if ( pthread_mutex_unlock((pthread_mutex_t *)(v167 + 53)) )
  {
    v157 = _errno_location();
    snprintf(
      (char *)v178,
      2048u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v157,
      "cgminer.c",
      "test_work_current",
      5695);
    goto LABEL_204;
  }
  off_658DC(0);
  v169 = pthread_rwlock_wrlock((pthread_rwlock_t *)&unk_68108);
  if ( v169 )
  {
    v153 = "block_exists";
    v154 = *_errno_location();
    v155 = 5608;
    goto LABEL_223;
  }
  v11 = -1640531527;
  v12 = strlen(s);
  LOWORD(v13) = -16657;
  if ( v12 <= 11 )
  {
    HIWORD(v13) = -275;
    v15 = -1640531527;
    v16 = v12;
    v18 = (unsigned __int8 *)s;
  }
  else
  {
    v14 = &v177;
    v15 = -1640531527;
    HIWORD(v13) = -275;
    v16 = v12;
    do
    {
      v16 -= 12;
      v17 = ((unsigned __int8)*(v14 - 6) << 16)
          + ((unsigned __int8)*(v14 - 7) << 8)
          + (unsigned __int8)*(v14 - 8)
          + ((unsigned __int8)*(v14 - 5) << 24)
          + v11;
      v18 = (unsigned __int8 *)v14;
      v19 = ((unsigned __int8)*(v14 - 10) << 16)
          + ((unsigned __int8)*(v14 - 11) << 8)
          + (unsigned __int8)*(v14 - 12)
          + ((unsigned __int8)*(v14 - 9) << 24)
          - v17;
      v20 = ((unsigned __int8)*(v14 - 2) << 16)
          + ((unsigned __int8)*(v14 - 3) << 8)
          + (unsigned __int8)*(v14 - 4)
          + ((unsigned __int8)*(v14 - 1) << 24)
          + v13;
      v14 += 12;
      v21 = (v19 - v20 + v15) ^ (v20 >> 13);
      v22 = (v17 - v20 - v21) ^ (v21 << 8);
      v23 = (v20 - v21 - v22) ^ (v22 >> 13);
      v24 = (v21 - v22 - v23) ^ (v23 >> 12);
      v25 = (v22 - v23 - v24) ^ (v24 << 16);
      v26 = (v23 - v24 - v25) ^ (v25 >> 5);
      v15 = (v24 - v25 - v26) ^ (v26 >> 3);
      v11 = (v25 - v26 - v15) ^ (v15 << 10);
      v13 = (v26 - v15 - v11) ^ (v11 >> 15);
    }
    while ( v16 > 11 );
  }
  v27 = v12 + v13;
  switch ( v16 )
  {
    case 1u:
      goto LABEL_26;
    case 2u:
      goto LABEL_25;
    case 3u:
      goto LABEL_24;
    case 4u:
      goto LABEL_23;
    case 5u:
      goto LABEL_22;
    case 6u:
      goto LABEL_21;
    case 7u:
      goto LABEL_20;
    case 8u:
      goto LABEL_19;
    case 9u:
      goto LABEL_18;
    case 10u:
      goto LABEL_17;
    case 11u:
      v27 += v18[10] << 24;
LABEL_17:
      v27 += v18[9] << 16;
LABEL_18:
      v27 += v18[8] << 8;
LABEL_19:
      v11 += v18[7] << 24;
LABEL_20:
      v11 += v18[6] << 16;
LABEL_21:
      v11 += v18[5] << 8;
LABEL_22:
      v11 += v18[4];
LABEL_23:
      v15 += v18[3] << 24;
LABEL_24:
      v15 += v18[2] << 16;
LABEL_25:
      v15 += v18[1] << 8;
LABEL_26:
      v15 += *v18;
      break;
    default:
      break;
  }
  v28 = (v15 - v11 - v27) ^ (v27 >> 13);
  v29 = (v11 - v27 - v28) ^ (v28 << 8);
  v30 = (v27 - v28 - v29) ^ (v29 >> 13);
  v31 = (v28 - v29 - v30) ^ (v30 >> 12);
  v32 = (v29 - v30 - v31) ^ (v31 << 16);
  v33 = v31 - v32;
  v34 = (v30 - v31 - v32) ^ (v32 >> 5);
  v35 = (v34
       - ((v33 - v34) ^ (v34 >> 3))
       - ((v32 - v34 - ((v33 - v34) ^ (v34 >> 3))) ^ (((v33 - v34) ^ (v34 >> 3)) << 10))) ^ (((v32
                                                                                             - v34
                                                                                             - ((v33 - v34) ^ (v34 >> 3))) ^ (((v33 - v34) ^ (v34 >> 3)) << 10)) >> 15);
  if ( dword_68128 )
  {
    v36 = *(_DWORD **)(dword_68128 + 68);
    v37 = *(_DWORD *)(*v36 + 12 * ((v36[1] - 1) & v35));
    if ( v37 )
    {
      v38 = -v36[5];
      v39 = v37 - v36[5];
      if ( v39 )
      {
        while ( v35 != *(_DWORD *)(v39 + 96)
             || v12 != *(_DWORD *)(v39 + 92)
             || memcmp(*(const void **)(v39 + 88), s, v12) )
        {
          v40 = *(_DWORD *)(v39 + 84);
          if ( v40 )
          {
            v39 = v40 + v38;
            if ( v40 + v38 )
              continue;
          }
          goto LABEL_55;
        }
        if ( pthread_rwlock_unlock((pthread_rwlock_t *)&unk_68108) )
          goto LABEL_234;
        ((void (*)(void))off_658DC)();
        current_pool_index = memcmp(v167 + 136, s2, 32u);
        if ( current_pool_index )
        {
          current_pool_index = memcmp(s2, &unk_68134, 32u);
          if ( !current_pool_index )
          {
            if ( byte_70CE8 || byte_66640 || dword_657B8 > 5 )
            {
              snprintf((char *)v178, 2048u, "Pool %d now up to date at height %d", *v167, v174);
              log_event(6, (const char *)v178, 0);
            }
            v168 = 1;
            log_memcpy_error(v167 + 136, s2, 32u, (int)"cgminer.c", (int)"test_work_current", 5753);
            goto LABEL_46;
          }
          v42 = (unsigned __int8)byte_66641;
          if ( byte_66641 )
          {
            if ( byte_70CE8 || byte_66640 || dword_657B8 > 6 )
            {
              snprintf((char *)v178, 2048u, "Stale data from pool %d at height %d", *v167, v174);
              log_event(7, (const char *)v178, 0);
              goto LABEL_46;
            }
            v42 = 0;
          }
          v168 = v42;
        }
        else
        {
          v168 = 1;
        }
LABEL_46:
        if ( *(_BYTE *)(v7 + 280) )
        {
          v43 = dword_66A44 - 3;
          v146 = (unsigned int)(dword_66A44 - 3) > 1;
          *(_DWORD *)(v7 + 336) = ++dword_66BF4;
          if ( !v146
            || (v149 = *(_DWORD *)(v7 + 260), current_pool_index = get_current_pool_index(), v149 == current_pool_index) )
          {
            v44 = *(unsigned __int8 *)(v7 + 284);
            if ( *(_BYTE *)(v7 + 284) )
            {
              if ( byte_70CE8 || byte_66640 || (v45 = dword_657B8, dword_657B8 > 4) )
              {
                snprintf((char *)v178, 2048u, "Stratum from pool %d requested work restart", *v167);
                log_event(5, (const char *)v178, 0);
              }
            }
            else if ( byte_70CE8 || byte_66640 || (v45 = dword_657B8, dword_657B8 > 4) )
            {
              v159 = "";
              if ( *(_BYTE *)(v7 + 324) )
                v159 = "GBT ";
              snprintf(
                (char *)v178,
                2048u,
                "%sLONGPOLL from pool %d requested work restart",
                v159,
                **(_DWORD **)(v7 + 260));
              log_event(5, (const char *)v178, 0);
            }
            init_restart_monitor_thread(current_pool_index, v43, v44, v45);
          }
        }
        goto LABEL_54;
      }
    }
  }
LABEL_55:
  v46 = (char *)allocate_and_log_on_fail(104u, 1u, "cgminer.c", "block_exists", 5612);
  v47 = (int)v46;
  if ( !v46 )
  {
    strcpy((char *)v178, "block_exists OOM");
    log_event(3, (const char *)v178, 1);
    shutdown_miner(1, 1);
  }
  v48 = (unsigned __int16)&dword_74130;
  strcpy(v46, s);
  v49 = dword_68128;
  v50 = dword_74130;
  *(_DWORD *)(v47 + 100) = dword_74130;
  dword_74130 = v50 + 1;
  if ( !v49 || *(_DWORD *)(*(_DWORD *)(v49 + 68) + 12) <= 3u )
    goto LABEL_114;
  v51 = v49 + 68;
  v52 = 1;
  do
  {
    v53 = v51;
    v51 = 0;
    v54 = 0;
    v55 = 0;
    do
    {
      ++v55;
      if ( v52 )
      {
        v56 = *(_DWORD *)(v53 + 8);
        if ( v56 && (v57 = *(_DWORD *)(*(_DWORD *)(v49 + 68) + 20), (v56 += v57) != 0) )
        {
          v58 = 1;
          do
          {
            if ( v58 == v52 )
            {
              v59 = v58;
              goto LABEL_68;
            }
            v56 = *(_DWORD *)(v56 + 8);
            ++v58;
            if ( !v56 )
              break;
            v56 += v57;
          }
          while ( v56 );
          v59 = v52;
        }
        else
        {
          v59 = v52;
          v58 = 1;
        }
      }
      else
      {
        v56 = v53;
        v59 = 0;
        v58 = 0;
      }
LABEL_68:
      v60 = v53;
      v53 = v56;
LABEL_69:
      while ( v58 )
      {
        v64 = v53 == 0;
        if ( v53 )
          v64 = v59 == 0;
        if ( v64 )
        {
          if ( v60 )
          {
            v48 = *(_DWORD *)(v60 + 8);
            if ( v48 )
              v48 += *(_DWORD *)(*(_DWORD *)(v49 + 68) + 20);
            goto LABEL_91;
          }
        }
        else
        {
          v48 = *(_DWORD *)(*(_DWORD *)(v49 + 68) + 20);
          if ( *(_DWORD *)(v60 - v48 + 100) - *(_DWORD *)(v53 - v48 + 100) > 0 )
          {
            v62 = *(_DWORD *)(v53 + 8);
            if ( v62 )
              v62 += v48;
LABEL_78:
            --v59;
            if ( !v54 )
            {
              v54 = v53;
              v53 = v62;
              goto LABEL_206;
            }
            v48 = v53 - *(_DWORD *)(*(_DWORD *)(v49 + 68) + 20);
            *(_DWORD *)(v54 + 8) = v48;
            if ( !v53 )
            {
              v54 = 0;
              v53 = v62;
              goto LABEL_69;
            }
            goto LABEL_82;
          }
          if ( v60 )
          {
            v151 = *(_DWORD *)(v60 + 8);
            if ( v151 )
              v48 += v151;
            else
              v48 = 0;
            goto LABEL_91;
          }
        }
        v48 = v60;
LABEL_91:
        --v58;
        if ( !v54 )
        {
          v54 = v60;
          v60 = v48;
LABEL_206:
          v51 = v54;
          if ( v54 )
          {
            v48 = 0;
            goto LABEL_83;
          }
          goto LABEL_69;
        }
        if ( !v60 )
        {
          *(_DWORD *)(v54 + 8) = 0;
          v54 = 0;
          v60 = v48;
          goto LABEL_69;
        }
        v62 = v53;
        v53 = v60;
        v65 = v60 - *(_DWORD *)(*(_DWORD *)(v49 + 68) + 20);
        v60 = v48;
        *(_DWORD *)(v54 + 8) = v65;
LABEL_82:
        v48 = v54 - *(_DWORD *)(*(_DWORD *)(v49 + 68) + 20);
        v54 = v53;
        v53 = v62;
LABEL_83:
        *(_DWORD *)(v54 + 4) = v48;
      }
      v61 = v59 == 0;
      if ( v59 )
        v61 = v53 == 0;
      if ( !v61 )
      {
        v62 = *(_DWORD *)(v53 + 8);
        v63 = v62 == 0;
        if ( v62 )
          v48 = *(_DWORD *)(v49 + 68);
        else
          v62 = v58;
        if ( !v63 )
        {
          v48 = *(_DWORD *)(v48 + 20);
          v62 += v48;
        }
        goto LABEL_78;
      }
    }
    while ( v53 );
    if ( v54 )
      *(_DWORD *)(v54 + 8) = 0;
    if ( v55 <= 1 )
      goto LABEL_101;
    v52 *= 2;
  }
  while ( v51 );
  v54 = 0;
LABEL_101:
  *(_DWORD *)(*(_DWORD *)(v49 + 68) + 16) = v54;
  v66 = v51 - *(_DWORD *)(*(_DWORD *)(v49 + 68) + 20);
  v67 = *(_DWORD *)(v66 + 72);
  dword_68128 = v66;
  v169 = *(_DWORD *)(v66 + 100);
  if ( v67 )
  {
    v68 = *(_DWORD *)(v66 + 68);
    v69 = v66 + 68;
    v70 = *(_DWORD *)(v68 + 20);
    if ( v66 != *(_DWORD *)(v68 + 16) - v70 )
      goto LABEL_103;
LABEL_266:
    *(_DWORD *)(v68 + 16) = v67 + v70;
    v67 = *(_DWORD *)(v66 + 72);
    if ( !v67 )
    {
      v71 = *(_DWORD *)(v66 + 76);
      goto LABEL_269;
    }
    v70 = *(_DWORD *)(*(_DWORD *)(v66 + 68) + 20);
LABEL_103:
    v49 = v66;
    *(_DWORD *)(v67 + v70 + 8) = *(_DWORD *)(v66 + 76);
    v71 = *(_DWORD *)(v66 + 76);
LABEL_104:
    v72 = *(_DWORD **)(v49 + 68);
    if ( v71 )
    {
      *(_DWORD *)(v71 + v72[5] + 4) = *(_DWORD *)(v66 + 72);
      v72 = *(_DWORD **)(v49 + 68);
    }
    v73 = 12 * (*(_DWORD *)(v66 + 96) & (v72[1] - 1));
    --*(_DWORD *)(*v72 + v73 + 4);
    v74 = **(_DWORD **)(v49 + 68);
    if ( *(_DWORD *)(v74 + v73) == v69 )
      *(_DWORD *)(v74 + v73) = *(_DWORD *)(v66 + 84);
    v75 = *(_QWORD *)(v66 + 80);
    if ( (_DWORD)v75 )
    {
      *(_DWORD *)(v75 + 16) = HIDWORD(v75);
      HIDWORD(v75) = *(_DWORD *)(v66 + 84);
    }
    if ( HIDWORD(v75) )
      *(_DWORD *)(HIDWORD(v75) + 12) = *(_DWORD *)(v66 + 80);
    --*(_DWORD *)(*(_DWORD *)(v49 + 68) + 12);
  }
  else
  {
    v71 = *(_DWORD *)(v66 + 76);
    v68 = *(_DWORD *)(v66 + 68);
    if ( v71 )
    {
      v70 = *(_DWORD *)(v68 + 20);
      v69 = v66 + 68;
      if ( v66 == *(_DWORD *)(v68 + 16) - v70 )
        goto LABEL_266;
LABEL_269:
      v49 = v71;
      dword_68128 = v71;
      goto LABEL_104;
    }
    v49 = 0;
    free(*(void **)v68);
    free(*(void **)(v66 + 68));
    dword_68128 = 0;
  }
  free((void *)v66);
LABEL_114:
  LOWORD(v76) = 31161;
  v170 = strlen((const char *)v47);
  v77 = v170;
  if ( v170 <= 11 )
  {
    HIWORD(v76) = -25033;
    v77 = v170;
    v93 = -17973521;
    v83 = (unsigned __int8 *)v47;
    v79 = v76;
  }
  else
  {
    HIWORD(v76) = -25033;
    v78 = (unsigned __int8 *)(v47 + 12);
    v172 = (char *)v47;
    v79 = v76;
    v80 = -17973521;
    do
    {
      v77 -= 12;
      v81 = *(v78 - 1);
      v82 = (*(v78 - 10) << 16) + (*(v78 - 11) << 8) + *(v78 - 12) + (*(v78 - 9) << 24);
      v83 = v78;
      v84 = (*(v78 - 2) << 16) + (*(v78 - 3) << 8) + *(v78 - 4);
      v85 = (*(v78 - 6) << 16) + (*(v78 - 7) << 8) + *(v78 - 8) + (*(v78 - 5) << 24) + v76;
      v78 += 12;
      v86 = v84 + (v81 << 24) + v80;
      v87 = (v82 - v85 - v86 + v79) ^ (v86 >> 13);
      v88 = (v85 - v86 - v87) ^ (v87 << 8);
      v89 = (v86 - v87 - v88) ^ (v88 >> 13);
      v90 = (v87 - v88 - v89) ^ (v89 >> 12);
      v91 = (v88 - v89 - v90) ^ (v90 << 16);
      v92 = (v89 - v90 - v91) ^ (v91 >> 5);
      v79 = (v90 - v91 - v92) ^ (v92 >> 3);
      v76 = (v91 - v92 - v79) ^ (v79 << 10);
      v80 = (v92 - v79 - v76) ^ (v76 >> 15);
    }
    while ( v77 > 11 );
    v93 = (v92 - v79 - v76) ^ (v76 >> 15);
    v47 = (int)v172;
  }
  v94 = v77 - 1;
  v95 = v93 + v170;
  switch ( v94 )
  {
    case 0u:
      goto LABEL_129;
    case 1u:
      goto LABEL_128;
    case 2u:
      goto LABEL_127;
    case 3u:
      goto LABEL_126;
    case 4u:
      goto LABEL_125;
    case 5u:
      goto LABEL_124;
    case 6u:
      goto LABEL_123;
    case 7u:
      goto LABEL_122;
    case 8u:
      goto LABEL_121;
    case 9u:
      goto LABEL_120;
    case 10u:
      v95 += v83[10] << 24;
LABEL_120:
      v95 += v83[9] << 16;
LABEL_121:
      v95 += v83[8] << 8;
LABEL_122:
      v76 += v83[7] << 24;
LABEL_123:
      v76 += v83[6] << 16;
LABEL_124:
      v76 += v83[5] << 8;
LABEL_125:
      v76 += v83[4];
LABEL_126:
      v79 += v83[3] << 24;
LABEL_127:
      v79 += v83[2] << 16;
LABEL_128:
      v79 += v83[1] << 8;
LABEL_129:
      v79 += *v83;
      break;
    default:
      break;
  }
  *(_DWORD *)(v47 + 88) = v47;
  v96 = (v79 - v76 - v95) ^ (v95 >> 13);
  v97 = (v76 - v95 - v96) ^ (v96 << 8);
  v98 = (v95 - v96 - v97) ^ (v97 >> 13);
  v99 = (v96 - v97 - v98) ^ (v98 >> 12);
  v100 = (v97 - v98 - v99) ^ (v99 << 16);
  v101 = (v98 - v99 - v100) ^ (v100 >> 5);
  v102 = v99 - v100 - v101;
  v103 = (v101 - (v102 ^ (v101 >> 3)) - ((v100 - v101 - (v102 ^ (v101 >> 3))) ^ ((v102 ^ (v101 >> 3)) << 10))) ^ (((v100 - v101 - (v102 ^ (v101 >> 3))) ^ ((v102 ^ (v101 >> 3)) << 10)) >> 15);
  *(_DWORD *)(v47 + 96) = v103;
  *(_DWORD *)(v47 + 92) = strlen((const char *)v47);
  if ( v49 )
  {
    v104 = *(_DWORD *)(v49 + 68);
    *(_DWORD *)(v47 + 76) = 0;
    v105 = v47 + 68;
    *(_DWORD *)(v47 + 68) = v104;
    *(_DWORD *)(v47 + 72) = *(_DWORD *)(*(_DWORD *)(v49 + 68) + 16) - *(_DWORD *)(*(_DWORD *)(v49 + 68) + 20);
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v49 + 68) + 16) + 8) = v47;
    *(_DWORD *)(*(_DWORD *)(v49 + 68) + 16) = v47 + 68;
    goto LABEL_132;
  }
  *(_DWORD *)(v47 + 76) = 0;
  *(_DWORD *)(v47 + 72) = 0;
  dword_68128 = v47;
  v160 = malloc(44u);
  *(_DWORD *)(v47 + 68) = v160;
  if ( !v160 )
    goto LABEL_274;
  memset(v160, 0, 44u);
  v105 = v47 + 68;
  *(_DWORD *)(*(_DWORD *)(v47 + 68) + 16) = v47 + 68;
  *(_DWORD *)(*(_DWORD *)(v47 + 68) + 4) = 32;
  *(_DWORD *)(*(_DWORD *)(v47 + 68) + 8) = 5;
  *(_DWORD *)(*(_DWORD *)(v47 + 68) + 20) = 68;
  v161 = *(void ***)(v47 + 68);
  *v161 = malloc(384u);
  v162 = **(void ***)(v47 + 68);
  if ( !v162 )
    goto LABEL_274;
  memset(v162, 0, 384u);
  v49 = v47;
  *(_DWORD *)(*(_DWORD *)(v47 + 68) + 40) = -1609490463;
LABEL_132:
  ++*(_DWORD *)(*(_DWORD *)(v49 + 68) + 12);
  v106 = *(_QWORD *)*(_DWORD *)(v49 + 68);
  v107 = 12 * (v103 & (HIDWORD(v106) - 1));
  ++*(_DWORD *)(v106 + v107 + 4);
  LODWORD(v106) = *(_DWORD *)(**(_DWORD **)(v49 + 68) + v107);
  *(_DWORD *)(v47 + 80) = 0;
  *(_DWORD *)(v47 + 84) = v106;
  LODWORD(v106) = **(_DWORD **)(v49 + 68);
  v108 = *(_DWORD *)(v106 + v107);
  v109 = (int *)(v106 + v107);
  if ( v108 )
  {
    *(_DWORD *)(v108 + 12) = v105;
    v109 = (int *)(**(_DWORD **)(v49 + 68) + v107);
  }
  *v109 = v105;
  v110 = *(_QWORD *)(**(_DWORD **)(v49 + 68) + v107 + 4);
  if ( (unsigned int)v110 >= 10 * (HIDWORD(v110) + 1) )
  {
    v111 = *(_DWORD *)(v47 + 68);
    if ( *(_DWORD *)(v111 + 36) != 1 )
    {
      v131 = calloc(24 * *(_DWORD *)(v111 + 4), 1u);
      if ( v131 )
      {
        v132 = *(_DWORD *)(v47 + 68);
        *(_DWORD *)(v132 + 24) = (((2 * *(_DWORD *)(v132 + 4) - 1) & *(_DWORD *)(v132 + 12)) != 0)
                               + (*(_DWORD *)(v132 + 12) >> (*(_QWORD *)(v132 + 8) + 1));
        *(_DWORD *)(*(_DWORD *)(v47 + 68) + 28) = 0;
        v133 = *(_DWORD *)(v47 + 68);
        v134 = *(_DWORD *)(v133 + 4);
        if ( v134 )
        {
          v135 = 0;
          v171 = 0;
          v173 = (char *)v7;
          do
          {
            v136 = *(_DWORD **)(*(_DWORD *)v133 + v135);
            if ( v136 )
            {
              while ( 1 )
              {
                v137 = (_DWORD *)v136[4];
                v138 = 3 * ((2 * v134 - 1) & v136[7]);
                v139 = (char *)&v131[v138];
                v140 = *((_DWORD *)v139 + 1) + 1;
                *((_DWORD *)v139 + 1) = v140;
                v141 = *(_DWORD *)(v47 + 68);
                if ( v140 > *(_DWORD *)(v141 + 24) )
                {
                  ++*(_DWORD *)(v141 + 28);
                  *((_DWORD *)v139 + 2) = calculate_miner_hashrate(
                                            *((_DWORD *)v139 + 1),
                                            *(_DWORD *)(*(_DWORD *)(v47 + 68) + 24));
                }
                v136[3] = 0;
                v136[4] = v131[v138];
                v142 = v131[v138];
                if ( v142 )
                  *(_DWORD *)(v142 + 12) = v136;
                v131[v138] = v136;
                if ( !v137 )
                  break;
                v136 = v137;
                v134 = *(_DWORD *)(*(_DWORD *)(v47 + 68) + 4);
              }
              v133 = *(_DWORD *)(v47 + 68);
              v134 = *(_DWORD *)(v133 + 4);
            }
            v135 += 12;
            ++v171;
          }
          while ( v171 < v134 );
          v7 = (int)v173;
        }
        free(*(void **)v133);
        *(_DWORD *)(*(_DWORD *)(v47 + 68) + 4) *= 2;
        ++*(_DWORD *)(*(_DWORD *)(v47 + 68) + 8);
        **(_DWORD **)(v47 + 68) = v131;
        v143 = *(_DWORD **)(v47 + 68);
        v144 = v143[7];
        v145 = v143[3];
        v146 = v144 > v145 >> 1;
        if ( v144 <= v145 >> 1 )
          v147 = 0;
        else
          v147 = v143[8];
        if ( v146 )
          ++v147;
        v143[8] = v147;
        v148 = *(_DWORD *)(v47 + 68);
        if ( *(_DWORD *)(v148 + 32) > 1u )
          *(_DWORD *)(v148 + 36) = 1;
        goto LABEL_136;
      }
LABEL_274:
      exit(-1);
    }
  }
LABEL_136:
  v112 = 8 * (29 - *(unsigned __int8 *)(v7 + 72));
  v113 = bswap32(*(_DWORD *)(v7 + 72)) & 0xFFFFFF;
  if ( v112 < 8 )
    LOBYTE(v112) = 8;
  v114 = 32 - v112;
  v115 = 65535 << (v112 - 32);
  LODWORD(v116) = 65535 << v112;
  HIDWORD(v116) = v115 | (65535u >> v114);
  LODWORD(v117) = check_null_pointer(v116);
  v118 = v117 / (double)v113;
  if ( v118 != dbl_66148 )
  {
    LODWORD(v163) = calculate_hash_value(v118);
    format_hashrate(v163, byte_6812C, 8u, 0);
    dbl_66148 = v118;
    if ( byte_70CE8 || byte_66640 || dword_657B8 > 4 )
    {
      snprintf((char *)v178, 2048u, "Network diff set to %s", byte_6812C);
      log_event(5, (const char *)v178, 0);
    }
  }
  if ( v169 && byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
  {
    snprintf((char *)v178, 2048u, "Deleted block %d from database", v169);
    log_event(7, (const char *)v178, 0);
  }
  if ( pthread_rwlock_unlock((pthread_rwlock_t *)&unk_68108) )
  {
LABEL_234:
    v158 = _errno_location();
    snprintf(
      (char *)v178,
      2048u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v158,
      "cgminer.c",
      "block_exists",
      5646);
    goto LABEL_204;
  }
  ((void (*)(void))off_658DC)();
  if ( pthread_mutex_lock(&stru_74068) )
  {
    v164 = _errno_location();
    snprintf(
      (char *)v178,
      2048u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v164,
      "cgminer.c",
      "set_curblock",
      5553);
    goto LABEL_204;
  }
  if ( pthread_rwlock_wrlock(&stru_74080) )
  {
    v166 = _errno_location();
    snprintf(
      (char *)v178,
      2048u,
      "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v166,
      "cgminer.c",
      "set_curblock",
      5553);
LABEL_204:
    log_event(3, (const char *)v178, 1);
    shutdown_miner(1, 1);
  }
  get_hardware_timestamp(&dword_70D0C);
  strcpy(byte_7413C, s);
  log_memcpy_error(&unk_68134, s2, 32u, (int)"cgminer.c", (int)"set_curblock", 5556);
  v178[0] = dword_70D0C;
  v119 = dword_70D10 / 1000;
  v120 = localtime(v178);
  snprintf(byte_68154, 32u, "[%02d:%02d:%02d.%03d]", v120->tm_hour, v120->tm_min, v120->tm_sec, v119);
  if ( pthread_rwlock_unlock(&stru_74080) )
  {
    v150 = _errno_location();
    snprintf(
      (char *)v178,
      2048u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v150,
      "cgminer.c",
      "set_curblock",
      5558);
    goto LABEL_204;
  }
  v121 = pthread_mutex_unlock(&stru_74068);
  if ( v121 )
  {
    v165 = *_errno_location();
    snprintf(
      (char *)v178,
      2048u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      v165,
      "cgminer.c",
      "set_curblock",
      5558);
    goto LABEL_204;
  }
  ((void (*)(void))off_658DC)();
  v122 = byte_7413C;
  do
  {
    v123 = (unsigned __int8)*v122++;
    if ( v123 != 48 )
      break;
    ++v121;
  }
  while ( v121 != 57 );
  strncpy(dest, &byte_7413C[v121], 8u);
  dest[8] = 0;
  if ( byte_70CE8 || byte_66640 || dword_657B8 > 5 )
  {
    snprintf((char *)v178, 2048u, "New block: %s... diff %s", byte_7413C, byte_6812C);
    log_event(6, (const char *)v178, 0);
  }
  if ( v169 && byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
  {
    snprintf((char *)v178, 2048u, "Deleted block %d from database", v169);
    log_event(7, (const char *)v178, 0);
  }
  log_memcpy_error(v167 + 136, s2, 32u, (int)"cgminer.c", (int)"test_work_current", 5703);
  if ( dword_74130 != 1 )
  {
    v125 = *(unsigned __int8 *)(v7 + 280);
    *(_DWORD *)(v7 + 336) = ++dword_66BF4;
    if ( v125 )
    {
      v126 = *(unsigned __int8 *)(v7 + 284);
      v127 = (unsigned __int8)byte_66641;
      if ( *(_BYTE *)(v7 + 284) )
      {
        if ( byte_66641 )
        {
          if ( byte_70CE8 || byte_66640 || (v127 = dword_657B8, dword_657B8 > 6) )
          {
            v128 = "Stratum from pool %d detected new block at height %d";
            v129 = v174;
            v130 = (char *)*v167;
            goto LABEL_171;
          }
        }
      }
      else if ( byte_66641 )
      {
        if ( byte_70CE8 || byte_66640 || (v127 = dword_657B8, dword_657B8 > 6) )
        {
          v130 = "";
          v129 = **(_DWORD **)(v7 + 260);
          v128 = "%sLONGPOLL from pool %d detected new block";
          if ( *(_BYTE *)(v7 + 324) )
            v130 = "GBT ";
LABEL_171:
          snprintf((char *)v178, 2048u, v128, v130, v129);
          log_event(7, (const char *)v178, 0);
        }
      }
    }
    else
    {
      v127 = (unsigned __int8)byte_7421C;
      v126 = *((unsigned __int8 *)v167 + 900);
      if ( byte_7421C )
      {
        if ( !*((_BYTE *)v167 + 900) )
        {
          v127 = (unsigned __int8)byte_66641;
          if ( byte_66641 )
          {
            if ( byte_70CE8 || byte_66640 || (v127 = dword_657B8, dword_657B8 > 6) )
            {
              strcpy((char *)v178, "New block detected on network before pool notification");
              log_event(7, (const char *)v178, 0);
            }
          }
        }
      }
      else if ( !*((_BYTE *)v167 + 900) )
      {
        v127 = (unsigned __int8)byte_66641;
        if ( byte_66641 )
        {
          if ( byte_70CE8 || byte_66640 || (v127 = dword_657B8, dword_657B8 > 6) )
          {
            strcpy((char *)v178, "New block detected on network");
            log_event(7, (const char *)v178, 0);
          }
        }
      }
    }
    init_restart_monitor_thread(v124, v125, v126, v127);
    v168 = 1;
  }
LABEL_54:
  *(_BYTE *)(v7 + 280) = 0;
  return v168;
}
// 366BC: control flows out of bounds to 366C0
// 36E14: control flows out of bounds to 36E18
// 369A0: variable 'current_pool_index' is possibly undefined
// 369A0: variable 'v43' is possibly undefined
// 369A0: variable 'v44' is possibly undefined
// 369A0: variable 'v45' is possibly undefined
// 3705C: variable 'v117' is possibly undefined
// 37424: variable 'v124' is possibly undefined
// 37424: variable 'v125' is possibly undefined
// 37424: variable 'v126' is possibly undefined
// 37424: variable 'v127' is possibly undefined
// 37C44: variable 'v163' is possibly undefined
// 657B8: using guessed type int dword_657B8;
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);
// 66148: using guessed type double dbl_66148;
// 66640: using guessed type char byte_66640;
// 66641: using guessed type char byte_66641;
// 66A44: using guessed type int dword_66A44;
// 66BF4: using guessed type int dword_66BF4;
// 68128: using guessed type int dword_68128;
// 70CE8: using guessed type char byte_70CE8;
// 70D0C: using guessed type int dword_70D0C;
// 70D10: using guessed type int dword_70D10;
// 74068: using guessed type pthread_mutex_t stru_74068;
// 74130: using guessed type int dword_74130;
// 7421C: using guessed type char byte_7421C;
// 36458: using guessed type time_t var_830[524];

//----- (00037DB0) --------------------------------------------------------
int __fastcall sub_37DB0(_DWORD *a1)
{
  int v2; // r9
  pthread_t v3; // r0
  int v4; // r10
  _DWORD *v5; // r0
  fd_set *v6; // r3
  int v7; // r3
  int v8; // r2
  bool v9; // nf
  int v10; // r1
  _DWORD *v11; // r2
  int v12; // r0
  char *v13; // r4
  int v15; // r0
  int v16; // r3
  int v17; // r2
  int v18; // r4
  int v19; // r0
  _DWORD *v20; // r0
  int v21; // r0
  _DWORD *v22; // r0
  _DWORD *v23; // r5
  int v24; // r3
  unsigned int *v25; // r3
  unsigned int v26; // r2
  unsigned int v27; // r2
  int v28; // r0
  int v29; // r0
  char *v30; // r5
  const char *v31; // lr
  int v32; // r3
  int v33; // r12
  int *v34; // r0
  const char *v35; // lr
  int v36; // r3
  int v37; // r12
  int *v38; // r0
  int v39; // r5
  void **v40; // r11
  unsigned int v41; // r3
  unsigned int v42; // r2
  unsigned int v43; // r1
  int v44; // r3
  unsigned int v45; // r2
  unsigned int v46; // r1
  int v47; // r3
  unsigned int v48; // r3
  int v49; // r2
  int v50; // r1
  int v51; // r6
  int v52; // r7
  int v53; // r10
  _DWORD *v54; // r9
  char *v55; // r5
  unsigned int v56; // r4
  int v57; // r7
  int v58; // r3
  _DWORD *v59; // r5
  int v60; // r3
  int **v61; // r2
  bool v62; // zf
  int *v63; // r1
  int v64; // r0
  int v65; // r3
  int v66; // r1
  int v67; // r1
  int v68; // r3
  int v69; // r6
  int v70; // r5
  time_t v71; // r0
  int v72; // r3
  int v73; // r0
  unsigned __int8 *v74; // r2
  __int64 v76; // d0
  unsigned int v77; // r6
  char *v78; // r12
  _DWORD *v79; // r6
  size_t v80; // lr
  unsigned int v81; // r3
  unsigned int v82; // r12
  double v83; // d5
  unsigned int v84; // kr00_4
  int v85; // r3
  int v86; // r2
  double v87; // d7
  double v88; // d5
  double v89; // d7
  size_t v90; // r0
  double v91; // r0
  int v92; // r3
  unsigned int *v93; // r3
  unsigned int v94; // r2
  unsigned int v95; // r2
  double v96; // d8
  unsigned int v97; // r0
  __int64 v98; // kr18_8
  double v99; // d6
  double v100; // d7
  unsigned int v101; // kr08_4
  double v102; // d6
  int v103; // r3
  int v104; // r2
  double v105; // d7
  int v106; // r2
  int v107; // r3
  time_t *v108; // r0
  const char *v109; // r0
  int *v110; // r0
  int v111; // r1
  int *v112; // r0
  unsigned int v113; // kr0C_4
  int v114; // r0
  unsigned __int64 v115; // kr20_8
  double v116; // d5
  double v117; // d7
  double v118; // d5
  double v119; // d7
  int v120; // r2
  time_t v121; // r0
  int v122; // r3
  int v123; // r0
  int *v124; // r0
  int v125; // [sp+4h] [bp-AACh]
  int v126; // [sp+20h] [bp-A90h]
  _DWORD *v127; // [sp+30h] [bp-A80h]
  char *v128; // [sp+30h] [bp-A80h]
  int v129; // [sp+30h] [bp-A80h]
  time_t *timer; // [sp+34h] [bp-A7Ch]
  time_t *timera; // [sp+34h] [bp-A7Ch]
  int v132; // [sp+38h] [bp-A78h]
  __int64 v133; // [sp+38h] [bp-A78h]
  size_t v134; // [sp+38h] [bp-A78h]
  _DWORD *ptr; // [sp+40h] [bp-A70h]
  int v136; // [sp+44h] [bp-A6Ch]
  int s2; // [sp+48h] [bp-A68h] BYREF
  struct timeval timeout; // [sp+4Ch] [bp-A64h] BYREF
  char s[16]; // [sp+54h] [bp-A5Ch] BYREF
  char v140[20]; // [sp+64h] [bp-A4Ch] BYREF
  __int16 v141; // [sp+78h] [bp-A38h] BYREF
  __int16 v142; // [sp+7Ah] [bp-A36h] BYREF
  char v143[36]; // [sp+98h] [bp-A18h] BYREF
  char v144[60]; // [sp+BCh] [bp-9F4h] BYREF
  char v145; // [sp+F8h] [bp-9B8h] BYREF
  fd_set readfds; // [sp+FCh] [bp-9B4h] BYREF
  int v147[23]; // [sp+17Ch] [bp-934h] BYREF
  char v148[160]; // [sp+1D8h] [bp-8D8h] BYREF
  _DWORD v149[526]; // [sp+278h] [bp-838h] BYREF

  v2 = -1622558010;
  v3 = pthread_self();
  pthread_detach(v3);
  v4 = -17973517;
  snprintf(s, 16u, "%d/RStratum", *a1);
  set_process_name(s);
  do
  {
LABEL_2:
    v5 = a1;
    if ( *((_BYTE *)a1 + 105) )
    {
LABEL_17:
      close_stratum_socket((int)v5);
      return 0;
    }
    while ( 1 )
    {
      if ( !is_connection_ready(v5) && !is_miner_allowed_to_mine(a1) )
      {
        close_stratum_socket((int)a1);
        clear_stratum_shares((int)a1);
        clear_stratum_work(a1);
        v15 = is_miner_allowed_to_mine(a1);
        if ( v15 )
          goto LABEL_65;
        while ( !a1[25] || a1 != (_DWORD *)get_current_pool_index(v15) && (unsigned int)(dword_66A44 - 3) > 1 )
        {
          if ( pthread_mutex_lock(&mutex) )
          {
            v31 = "wait_lpcurrent";
            v32 = *_errno_location();
            v33 = 9972;
            goto LABEL_86;
          }
          pthread_cond_wait(&cond, &mutex);
          if ( pthread_mutex_unlock(&mutex) )
          {
            v35 = "wait_lpcurrent";
            v36 = *_errno_location();
            v37 = 9974;
LABEL_90:
            snprintf(
              (char *)v149,
              2048u,
              "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
              v36,
              "cgminer.c",
              v35,
              v37);
LABEL_87:
            log_event(3, (const char *)v149, 1);
            shutdown_miner(1, 1);
          }
          ((void (*)(void))off_658DC)();
          v15 = is_miner_allowed_to_mine(a1);
          if ( v15 )
            break;
        }
LABEL_65:
        while ( !reconnect_to_stratum(a1) )
        {
          check_and_switch_pool((int)a1);
          if ( *((_BYTE *)a1 + 105) )
            return 0;
          get_and_update_system_time(5000);
        }
      }
      v6 = (fd_set *)&v145;
      do
      {
        v6->__fds_bits[1] = 0;
        v6 = (fd_set *)((char *)v6 + 4);
      }
      while ( &readfds.__fds_bits[31] != (__fd_mask *)v6 );
      v7 = a1[147];
      timeout.tv_usec = 0;
      timeout.tv_sec = 90;
      v8 = v7 + 31;
      if ( v7 >= 0 )
        v8 = v7;
      v9 = -v7 < 0;
      v10 = -v7 & 0x1F;
      LOBYTE(v7) = v7 & 0x1F;
      v11 = &v149[(v8 >> 5) + 512];
      if ( !v9 )
        v7 = -v10;
      *(v11 - 607) |= 1 << v7;
      if ( !is_connection_ready(a1) )
      {
        v12 = select(a1[147] + 1, &readfds, 0, 0, &timeout);
        if ( v12 <= 0 )
        {
          v16 = (unsigned __int8)byte_70CE8;
          if ( !byte_66641 )
            goto LABEL_29;
          if ( byte_70CE8 || byte_66640 || dword_657B8 > 6 )
          {
            snprintf((char *)v149, 2048u, "Stratum select failed on pool %d with value %d", *a1, v12);
            log_event(7, (const char *)v149, 0);
            v16 = (unsigned __int8)byte_70CE8;
            goto LABEL_29;
          }
          goto LABEL_54;
        }
      }
      v13 = receive_socket_data((int)a1);
      if ( !v13 )
        break;
      reset_and_resume_connection_if_signaled(a1);
      if ( process_miner_message(a1, v13) )
        goto LABEL_14;
      v21 = process_command((int)v13, 0, (int)v147);
      v126 = v21;
      if ( v21 )
      {
        v127 = (_DWORD *)validate_and_fetch_data(v21, "result");
        timer = (time_t *)validate_and_fetch_data(v126, "error");
        v22 = (_DWORD *)validate_and_fetch_data(v126, "id");
        v23 = v22;
        if ( !v22 || *v22 == 7 )
        {
          if ( timer )
          {
            v30 = (char *)generate_config_json(timer, 3);
          }
          else
          {
            v30 = (char *)malloc(17u);
            if ( v30 )
              strcpy(v30, "(unknown reason)");
          }
          if ( byte_70CE8 || byte_66640 || dword_657B8 > 5 )
          {
            snprintf((char *)v149, 2048u, "JSON-RPC non method decode failed: %s", v30);
            log_event(6, (const char *)v149, 0);
          }
          free(v30);
          if ( *(_DWORD *)(v126 + 4) != -1 )
            goto LABEL_50;
        }
        else
        {
          if ( validate_and_fetch_data(v127, "version-rolling.mask")
            || strstr(v13, "mining.configure")
            || strstr(v13, "mining.set_version_mask") )
          {
            goto LABEL_49;
          }
          v39 = get_linked_list_next_node(v23);
          s2 = v39;
          if ( pthread_mutex_lock(&stru_66BAC) )
            log_mutex_error_and_exit("parse_stratum_response", 7331);
          v40 = (void **)dword_66BC4;
          v41 = ((v39 & 0xFF0000FF) + 17973517 + (v39 & 0xFF0000) + (v39 & 0xFF00)) ^ 0x7F76D;
          v42 = (v2 - v41) ^ (v41 << 8);
          v43 = (v4 - v41 - v42) ^ (v42 >> 13);
          v44 = (v41 - v42 - v43) ^ (v43 >> 12);
          v45 = (v42 - v43 - v44) ^ (v44 << 16);
          v46 = (v43 - v44 - v45) ^ (v45 >> 5);
          v47 = (v44 - v45 - v46) ^ (v46 >> 3);
          v48 = (v46 - v47 - ((v45 - v46 - v47) ^ (v47 << 10))) ^ (((v45 - v46 - v47) ^ (v47 << 10)) >> 15);
          if ( dword_66BC4 )
          {
            ptr = **(_DWORD ***)dword_66BC4;
            v49 = ptr[3 * ((*(_DWORD *)(*(_DWORD *)dword_66BC4 + 4) - 1) & v48)];
            if ( v49 )
            {
              v50 = *(_DWORD *)(*(_DWORD *)dword_66BC4 + 20);
              v51 = -v50;
              v136 = v50;
              v52 = v49 - v50;
              if ( v49 != v50 )
              {
                v132 = v4;
                v53 = v2;
                v54 = *(_DWORD **)dword_66BC4;
                v55 = v13;
                v56 = v48;
                while ( v56 != *(_DWORD *)(v52 + 28)
                     || *(_DWORD *)(v52 + 24) != 4
                     || memcmp(*(const void **)(v52 + 20), &s2, 4u) )
                {
                  v57 = *(_DWORD *)(v52 + 16);
                  if ( v57 )
                  {
                    v52 = v57 + v51;
                    if ( v52 )
                      continue;
                  }
                  v2 = v53;
                  v4 = v132;
                  v13 = v55;
                  goto LABEL_185;
                }
                v58 = *(_DWORD *)(v52 + 4);
                v13 = v55;
                v59 = v54;
                v2 = v53;
                v4 = v132;
                if ( v58 )
                {
                  if ( v52 != v59[4] + v51 )
                    goto LABEL_108;
LABEL_218:
                  v59[4] = v58 + v136;
                  v58 = *(_DWORD *)(v52 + 4);
                  if ( !v58 )
                  {
                    v106 = *(_DWORD *)(v52 + 8);
                    goto LABEL_215;
                  }
                  v59 = *v40;
LABEL_108:
                  *(_DWORD *)(v58 + v59[5] + 8) = *(_DWORD *)(v52 + 8);
LABEL_109:
                  v60 = *(_DWORD *)(v52 + 8);
                  v61 = (int **)dword_66BC4;
                  v62 = v60 == 0;
                  v63 = *(int **)dword_66BC4;
                  if ( v60 )
                  {
                    v64 = v63[5];
                    v63 = *(int **)(v52 + 4);
                    v60 += v64;
                  }
                  if ( !v62 )
                  {
                    *(_DWORD *)(v60 + 4) = v63;
                    v63 = *v61;
                  }
                  v65 = 12 * ((v63[1] - 1) & *(_DWORD *)(v52 + 28));
                  --*(_DWORD *)(*v63 + v65 + 4);
                  v66 = **v61;
                  if ( *(_DWORD *)(v66 + v65) == v52 )
                    *(_DWORD *)(v66 + v65) = *(_DWORD *)(v52 + 16);
                  v67 = *(_DWORD *)(v52 + 12);
                  v68 = *(_DWORD *)(v52 + 16);
                  if ( v67 )
                  {
                    *(_DWORD *)(v67 + 16) = v68;
                    v68 = *(_DWORD *)(v52 + 16);
                  }
                  if ( v68 )
                    *(_DWORD *)(v68 + 12) = *(_DWORD *)(v52 + 12);
                  --(*v61)[3];
                }
                else
                {
                  v106 = *(_DWORD *)(v52 + 8);
                  if ( v106 )
                  {
                    if ( v52 == v59[4] + v51 )
                      goto LABEL_218;
LABEL_215:
                    dword_66BC4 = v106;
                    goto LABEL_109;
                  }
                  free(ptr);
                  free(*v40);
                  dword_66BC4 = 0;
                }
                --a1[183];
                v69 = pthread_mutex_unlock(&stru_66BAC);
                if ( v69 )
                  goto LABEL_216;
                off_658DC(0);
                v70 = *(_DWORD *)(v52 + 36);
                v71 = time(0);
                v72 = (unsigned __int8)byte_66641;
                v73 = v71 - *(_DWORD *)(v52 + 48);
                if ( v73 > 0 )
                  v72 = (unsigned __int8)byte_66641 | 1;
                if ( v72 && (byte_70CE8 || byte_66640 || dword_657B8 > 5) )
                {
                  snprintf(
                    (char *)v149,
                    2048u,
                    "Pool %d stratum share result lag time %d seconds",
                    **(_DWORD **)(v70 + 260),
                    v73);
                  log_event(6, (const char *)v149, 0);
                }
                v74 = (unsigned __int8 *)v149;
                v149[0] = bswap32(*(_DWORD *)(v70 + 220));
                v149[1] = bswap32(*(_DWORD *)(v70 + 216));
                v149[2] = bswap32(*(_DWORD *)(v70 + 212));
                v149[3] = bswap32(*(_DWORD *)(v70 + 208));
                v149[4] = bswap32(*(_DWORD *)(v70 + 204));
                v149[5] = bswap32(*(_DWORD *)(v70 + 200));
                v149[6] = bswap32(*(_DWORD *)(v70 + 196));
                v149[7] = bswap32(*(_DWORD *)(v70 + 192));
                do
                {
                  if ( *v74++ )
                    break;
                  ++v69;
                }
                while ( v69 != 29 );
                v76 = *(_QWORD *)(v70 + 376);
                v77 = bswap32(*(_DWORD *)((char *)v149 + v69));
                round(v73);
                v133 = calculate_hash_value(v76, HIDWORD(v76));
                format_hashrate(*(_QWORD *)(v70 + 232), v143, 16u, 0);
                if ( *(_BYTE *)(v70 + 283) )
                  v78 = " BLOCK!";
                if ( !*(_BYTE *)(v70 + 283) )
                  v78 = "";
                snprintf(v144, 64u, "%08lx Diff %s/%llu%s", v77, v143, v125, v133, v78);
                v79 = *(_DWORD **)(v70 + 260);
                v134 = *(_DWORD *)(get_thread_metadata(*(_DWORD *)(v70 + 256)) + 36);
                if ( v127 && (*v127 == 5 || *(_BYTE *)(v70 + 324) && *v127 == 7) )
                {
                  if ( pthread_mutex_lock(&stru_70CEC) )
                  {
                    v124 = _errno_location();
                    snprintf(
                      (char *)v149,
                      2048u,
                      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
                      *v124,
                      "cgminer.c",
                      "share_result",
                      3561);
                    goto LABEL_87;
                  }
                  v113 = qword_70E48;
                  v114 = *(_DWORD *)(v134 + 36) + 1;
                  LODWORD(qword_70E48) = qword_70E48 + 1;
                  v115 = __PAIR64__(HIDWORD(qword_70E48), v113) + 1;
                  *(_DWORD *)(v134 + 36) = v114;
                  HIDWORD(qword_70E48) = HIDWORD(v115);
                  v116 = dbl_72E80;
                  ++*((_QWORD *)v79 + 1);
                  *(double *)(v134 + 200) = *(double *)(v134 + 200) + *(double *)(v70 + 376);
                  v117 = *(double *)(v70 + 376);
                  v118 = v116 + v117;
                  v119 = *((double *)v79 + 9) + v117;
                  dbl_72E80 = v118;
                  *((double *)v79 + 9) = v119;
                  if ( pthread_mutex_unlock(&stru_70CEC) )
                  {
                    v110 = _errno_location();
                    v111 = 3571;
                    goto LABEL_230;
                  }
                  ((void (*)(void))off_658DC)();
                  v120 = *v79;
                  v79[6] = 0;
                  *(_DWORD *)(v134 + 216) = v120;
                  v121 = time(0);
                  v122 = (unsigned __int8)byte_66641;
                  *(_DWORD *)(v134 + 220) = v121;
                  *(_QWORD *)(v134 + 224) = *(_QWORD *)(v70 + 376);
                  v79[88] = v121;
                  *((_QWORD *)v79 + 45) = *(_QWORD *)(v70 + 376);
                  if ( v122 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
                  {
                    strcpy((char *)v149, "PROOF OF WORK RESULT: true (yay!!!)");
                    log_event(7, (const char *)v149, 0);
                  }
                  if ( !byte_7418C && !byte_74128 )
                  {
                    if ( dword_70DB8 <= 1 )
                    {
                      if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
                      {
                        snprintf(
                          (char *)v149,
                          2048u,
                          "Accepted %s %s %d %s%s",
                          v144,
                          *(const char **)(*(_DWORD *)(v134 + 4) + 8),
                          *(_DWORD *)(v134 + 8),
                          "",
                          "");
                        log_event(7, (const char *)v149, 0);
                      }
                    }
                    else if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
                    {
                      snprintf(
                        (char *)v149,
                        2048u,
                        "Accepted %s %s %d pool %d %s%s",
                        v144,
                        *(const char **)(*(_DWORD *)(v134 + 4) + 8),
                        *(_DWORD *)(v134 + 8),
                        **(_DWORD **)(v70 + 260),
                        "",
                        "");
                      log_event(7, (const char *)v149, 0);
                    }
                  }
                  log_share_info("accept", (_DWORD *)v70);
                  if ( dword_66AC0 && (double)dword_66AC0 <= dbl_72E80 )
                  {
                    if ( byte_70CE8 || byte_66640 || dword_657B8 > 3 )
                    {
                      snprintf(
                        (char *)v149,
                        2048u,
                        "Successfully mined %d accepted shares as requested and exiting.",
                        dword_66AC0);
                      log_event(4, (const char *)v149, 0);
                    }
                    handle_shutdown_signal();
                  }
                  if ( v79[25] == 2 )
                  {
                    if ( byte_70CE8 || byte_66640 || dword_657B8 > 3 )
                    {
                      snprintf((char *)v149, 2048u, "Rejecting pool %d now accepting shares, re-enabling!", *v79);
                      log_event(4, (const char *)v149, 0);
                    }
                    if ( v79[25] != 1 )
                      increment_counter_and_set_flag(v79 + 25);
                    v123 = switch_pools(0);
                  }
                  if ( *(_BYTE *)(v70 + 283) )
                    init_restart_monitor_thread(v123);
                }
                else
                {
                  if ( pthread_mutex_lock(&stru_70CEC) )
                  {
                    v112 = _errno_location();
                    snprintf(
                      (char *)v149,
                      2048u,
                      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
                      *v112,
                      "cgminer.c",
                      "share_result",
                      3624);
                    goto LABEL_87;
                  }
                  v80 = v134;
                  v82 = HIDWORD(qword_72F10);
                  v81 = qword_72F10;
                  v83 = dbl_72F08;
                  ++*(_DWORD *)(v134 + 40);
                  v84 = v81;
                  v85 = v79[4];
                  qword_72F10 = __PAIR64__(v82, v84) + 1;
                  v86 = v79[5];
                  v79[4] = v85 + 1;
                  v79[5] = __CFADD__(v85, 1) + v86;
                  *(double *)(v134 + 208) = *(double *)(v134 + 208) + *(double *)(v70 + 376);
                  v87 = *(double *)(v70 + 376);
                  v88 = v83 + v87;
                  v89 = *((double *)v79 + 10) + v87;
                  ++v79[6];
                  dbl_72F08 = v88;
                  *((double *)v79 + 10) = v89;
                  if ( pthread_mutex_unlock(&stru_70CEC) )
                  {
                    v110 = _errno_location();
                    v111 = 3632;
LABEL_230:
                    snprintf(
                      (char *)v149,
                      2048u,
                      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
                      *v110,
                      "cgminer.c",
                      "share_result",
                      v111);
                    goto LABEL_87;
                  }
                  ((void (*)(void))off_658DC)();
                  if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
                  {
                    strcpy((char *)v149, "PROOF OF WORK RESULT: false (booooo)");
                    v80 = (size_t)&v149[9];
                    log_event(7, (const char *)v149, 0);
                  }
                  if ( !byte_7418C && !byte_74128 )
                  {
                    strcpy(v143, "reject");
                    memset(&v143[7], (unsigned __int8)byte_74128, 29u);
                    LOBYTE(v141) = byte_74128;
                    if ( dword_70DB8 > 1 )
                      snprintf(v140, 20u, "pool %d", **(_DWORD **)(v70 + 260));
                    else
                      v140[0] = byte_74128;
                    if ( !*(_BYTE *)(v70 + 324) )
                      v127 = (_DWORD *)validate_and_fetch_data(v126, "reject-reason");
                    if ( v127 )
                    {
                      timera = (time_t *)get_linked_item_or_null(v127);
                      v90 = strlen((const char *)timera);
                      if ( v90 < 28 )
                        v80 = v90;
                      if ( v90 >= 28 )
                        v80 = 28;
                      v141 = 10272;
                      v128 = (char *)&v149[512] + v80;
                      log_memcpy_error(&v142, timera, v80, (int)"cgminer.c", (int)"share_result", 3672);
                      *(v128 - 2558) = 41;
                      *(v128 - 2557) = 0;
                      log_memcpy_error(&v143[7], timera, v80, (int)"cgminer.c", (int)"share_result", 3677);
                      v143[6] = 58;
                      *(v128 - 2521) = 0;
                    }
                    else
                    {
                      if ( timer )
                        v107 = *(_BYTE *)(v70 + 284) & 1;
                      else
                        v107 = 0;
                      if ( v107 )
                      {
                        if ( *timer == 1 )
                        {
                          v108 = (time_t *)get_task_by_index(timer, 1);
                          if ( !v108 || *v108 != 2 )
                            goto LABEL_159;
                        }
                        else
                        {
                          if ( *timer != 2 )
                            goto LABEL_159;
                          v108 = timer;
                        }
                        v109 = (const char *)get_linked_item_or_null(v108);
                        snprintf((char *)&v141, 31u, " (%s)", v109);
                      }
                    }
LABEL_159:
                    if ( byte_70CE8 || byte_66640 || dword_657B8 > 4 )
                    {
                      snprintf(
                        (char *)v149,
                        2048u,
                        "Rejected %s %s %d %s%s %s%s version 0x%x",
                        v144,
                        *(const char **)(*(_DWORD *)(v134 + 4) + 8),
                        *(_DWORD *)(v134 + 8),
                        v140,
                        (const char *)&v141,
                        "",
                        "",
                        *(_DWORD *)(v70 + 444));
                      log_event(5, (const char *)v149, 0);
                    }
                    log_share_info(v143, (_DWORD *)v70);
                  }
                  v129 = v79[6];
                  if ( v129 > 10 && !*(_BYTE *)(v70 + 281) )
                  {
                    if ( byte_70DF0 )
                    {
                      if ( dword_72E7C > 1 )
                      {
                        v91 = convert_float_to_int(qword_70E48);
                        if ( (double)v129 > v91 / *(double *)&dword_66120 * 60.0 * 3.0 )
                        {
                          if ( byte_70CE8 || byte_66640 || dword_657B8 > 3 )
                          {
                            snprintf(
                              (char *)v149,
                              2048u,
                              "Pool %d rejected %d sequential shares, disabling!",
                              *v79,
                              v129);
                            log_event(4, (const char *)v149, 0);
                          }
                          if ( v79[25] == 1 )
                            --dword_72E7C;
                          v79[25] = 2;
                          if ( v79 == (_DWORD *)get_current_pool_index(LODWORD(v91)) )
                            switch_pools(0);
                          v79[6] = 0;
                        }
                      }
                    }
                  }
                }
                clear_miner_data_if_not_null(v52 + 36, "cgminer.c", "parse_stratum_response", 7384);
                free((void *)v52);
                if ( *(_DWORD *)(v126 + 4) != -1 )
                {
                  v92 = v126;
                  __dmb(11u);
                  v93 = (unsigned int *)(v92 + 4);
                  do
                  {
                    v94 = __ldrex(v93);
                    v95 = v94 - 1;
                  }
                  while ( __strex(v95, v93) );
                  if ( !v95 )
                    process_bitmain_miner(v126);
                }
                goto LABEL_14;
              }
            }
          }
LABEL_185:
          if ( pthread_mutex_unlock(&stru_66BAC) )
LABEL_216:
            log_mutex_unlock_error("parse_stratum_response", 7339);
          off_658DC(0);
          if ( !v127 )
          {
LABEL_49:
            if ( *(_DWORD *)(v126 + 4) == -1 )
              goto LABEL_59;
LABEL_50:
            v24 = v126;
            __dmb(11u);
            v25 = (unsigned int *)(v24 + 4);
            do
            {
              v26 = __ldrex(v25);
              v27 = v26 - 1;
            }
            while ( __strex(v27, v25) );
            if ( !v27 )
              process_bitmain_miner(v126);
            goto LABEL_59;
          }
          if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 53)) )
            log_mutex_error_and_exit("parse_stratum_response", 7351);
          if ( pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 59)) )
            log_rdlock_error("parse_stratum_response", 7351);
          if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 53)) )
            log_mutex_unlock_error("parse_stratum_response", 7351);
          v96 = *((double *)a1 + 228);
          unlock_rwlock_and_log_error(a1 + 59, "parse_stratum_response", 7353);
          if ( *v127 == 5 )
          {
            if ( byte_70CE8 || byte_66640 || dword_657B8 > 4 )
            {
              snprintf((char *)v149, 2048u, "Accepted untracked stratum share from pool %d", *a1);
              log_event(5, (const char *)v149, 0);
            }
            if ( pthread_mutex_lock(&stru_70CEC) )
              log_mutex_error_and_exit("parse_stratum_response", 7361);
            v102 = *((double *)a1 + 9) + v96;
            ++qword_70E48;
            v103 = a1[2];
            v104 = a1[3];
            v105 = dbl_72E80 + v96;
            *((double *)a1 + 9) = v102;
            a1[2] = v103 + 1;
            a1[3] = __CFADD__(v103, 1) + v104;
            dbl_72E80 = v105;
            if ( pthread_mutex_unlock(&stru_70CEC) )
              log_mutex_unlock_error("parse_stratum_response", 7366);
          }
          else
          {
            if ( byte_70CE8 || byte_66640 || dword_657B8 > 4 )
            {
              snprintf((char *)v149, 2048u, "Rejected untracked stratum share from pool %d", *a1);
              log_event(5, (const char *)v149, 0);
            }
            if ( pthread_mutex_lock(&stru_70CEC) )
              log_mutex_error_and_exit("parse_stratum_response", 7372);
            v97 = a1[5];
            v98 = qword_72F10 + 1;
            v99 = *((double *)a1 + 10) + v96;
            v100 = dbl_72F08 + v96;
            v101 = a1[4];
            LODWORD(qword_72F10) = qword_72F10 + 1;
            a1[4] = v101 + 1;
            *((double *)a1 + 10) = v99;
            a1[5] = (__PAIR64__(v97, v101) + 1) >> 32;
            HIDWORD(qword_72F10) = HIDWORD(v98);
            dbl_72F08 = v100;
            if ( pthread_mutex_unlock(&stru_70CEC) )
              log_mutex_unlock_error("parse_stratum_response", 7377);
          }
          ((void (*)(void))off_658DC)();
          if ( *(_DWORD *)(v126 + 4) != -1 )
            goto LABEL_50;
        }
      }
      else if ( byte_70CE8 || byte_66640 || dword_657B8 > 5 )
      {
        snprintf((char *)v149, 2048u, "JSON decode failed(%d): %s", v147[0], v148);
        log_event(6, (const char *)v149, 0);
      }
LABEL_59:
      if ( !process_mining_configure_response(a1, (int)v13) )
      {
        if ( byte_70CE8 || byte_66640 || dword_657B8 > 5 )
        {
          snprintf((char *)v149, 2048u, "Unknown stratum msg: %s", v13);
          log_event(6, (const char *)v149, 0);
        }
        goto LABEL_16;
      }
LABEL_14:
      if ( *((_BYTE *)a1 + 680) )
      {
        v28 = initialize_work();
        *((_BYTE *)a1 + 680) = 0;
        v149[0] = v28;
        generate_stratum_work((int)a1, v28);
        v29 = v149[0];
        *(_BYTE *)(v149[0] + 280) = 1;
        sub_36458(v29);
        clear_miner_data_if_not_null(v149, "cgminer.c", "stratum_rthread", 7640);
      }
LABEL_16:
      free(v13);
      v5 = a1;
      if ( *((_BYTE *)a1 + 105) )
        goto LABEL_17;
    }
    v16 = (unsigned __int8)byte_70CE8;
LABEL_29:
    if ( v16 || byte_66640 )
    {
LABEL_31:
      snprintf((char *)v149, 2048u, "Stratum connection to pool %d interrupted", *a1);
      log_event(5, (const char *)v149, 0);
      goto LABEL_32;
    }
LABEL_54:
    if ( dword_657B8 > 4 )
      goto LABEL_31;
LABEL_32:
    v17 = dword_70E60;
    ++a1[32];
    dword_70E60 = v17 + 1;
    if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 53)) )
    {
      v31 = "supports_resume";
      v32 = *_errno_location();
      v33 = 7522;
LABEL_86:
      snprintf((char *)v149, 2048u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", v32, "cgminer.c", v31, v33);
      goto LABEL_87;
    }
    if ( pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 59)) )
    {
      v34 = _errno_location();
      snprintf(
        (char *)v149,
        2048u,
        "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
        *v34,
        "cgminer.c",
        "supports_resume",
        7522);
      goto LABEL_87;
    }
    if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 53)) )
    {
      v35 = "supports_resume";
      v36 = *_errno_location();
      v37 = 7522;
      goto LABEL_90;
    }
    v18 = a1[159];
    if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 59)) )
    {
      v38 = _errno_location();
      snprintf(
        (char *)v149,
        2048u,
        "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v38,
        "cgminer.c",
        "supports_resume",
        7524);
      goto LABEL_87;
    }
    off_658DC(0);
    if ( !v18 || byte_72EDC )
      clear_stratum_shares((int)a1);
    v19 = clear_stratum_work(a1);
    v20 = (_DWORD *)get_current_pool_index(v19);
    if ( a1 == v20 )
      init_restart_monitor_thread(v20);
  }
  while ( reconnect_to_stratum(a1) );
  while ( 1 )
  {
    check_and_switch_pool((int)a1);
    if ( *((_BYTE *)a1 + 105) )
      return 0;
    get_and_update_system_time(5000);
    if ( reconnect_to_stratum(a1) )
      goto LABEL_2;
  }
}
// 389F8: variable 'v73' is possibly undefined
// 38A68: variable 'v125' is possibly undefined
// 38A68: variable 'v78' is possibly undefined
// 38F18: variable 'v91' is possibly undefined
// 396E0: variable 'v123' is possibly undefined
// 121B0: using guessed type int __fastcall round(_DWORD);
// 1DA28: using guessed type int sub_1DA28(void);
// 1F7F8: using guessed type int __fastcall sub_1F7F8(_DWORD);
// 1FB7C: using guessed type int __fastcall sub_1FB7C(_DWORD);
// 21DB8: using guessed type int __fastcall sub_21DB8(_DWORD);
// 24A2C: using guessed type int __fastcall sub_24A2C(_DWORD);
// 25A68: using guessed type int __fastcall sub_25A68(_DWORD, _DWORD);
// 27998: using guessed type int __fastcall sub_27998(_DWORD);
// 28FFC: using guessed type int __fastcall sub_28FFC(_DWORD, _DWORD, _DWORD, _DWORD);
// 2AB30: using guessed type void __fastcall __noreturn sub_2AB30(_DWORD, _DWORD);
// 2AE68: using guessed type int __fastcall sub_2AE68(_DWORD);
// 2C008: using guessed type int __fastcall sub_2C008(_DWORD, _DWORD, _DWORD);
// 2DF8C: using guessed type int __fastcall sub_2DF8C(_DWORD);
// 2E47C: using guessed type int __fastcall sub_2E47C(_DWORD);
// 2E888: using guessed type int __fastcall sub_2E888(_DWORD);
// 2E8AC: using guessed type int __fastcall sub_2E8AC(_DWORD);
// 44264: using guessed type int __fastcall sub_44264(_DWORD, _DWORD);
// 472EC: using guessed type int __fastcall sub_472EC(_DWORD, _DWORD);
// 47674: using guessed type int __fastcall sub_47674(_DWORD, _DWORD);
// 47820: using guessed type int __fastcall sub_47820(_DWORD);
// 47A7C: using guessed type __int64 __fastcall sub_47A7C(_DWORD);
// 47C24: using guessed type int __fastcall sub_47C24(_DWORD);
// 4930C: using guessed type double __fastcall sub_4930C(_DWORD);
// 493C8: using guessed type __int64 __fastcall sub_493C8(_DWORD, _DWORD);
// 657B8: using guessed type int dword_657B8;
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);
// 66120: using guessed type int dword_66120;
// 66640: using guessed type char byte_66640;
// 66641: using guessed type char byte_66641;
// 66A44: using guessed type int dword_66A44;
// 66AC0: using guessed type int dword_66AC0;
// 66BC4: using guessed type int dword_66BC4;
// 70CE8: using guessed type char byte_70CE8;
// 70CEC: using guessed type pthread_mutex_t stru_70CEC;
// 70DB8: using guessed type int dword_70DB8;
// 70DF0: using guessed type char byte_70DF0;
// 70E48: using guessed type __int64 qword_70E48;
// 70E60: using guessed type int dword_70E60;
// 72E7C: using guessed type int dword_72E7C;
// 72E80: using guessed type double dbl_72E80;
// 72EDC: using guessed type char byte_72EDC;
// 72F08: using guessed type double dbl_72F08;
// 72F10: using guessed type __int64 qword_72F10;
// 74128: using guessed type char byte_74128;
// 7418C: using guessed type char byte_7418C;
// 37DB0: using guessed type int var_934[23];
// 37DB0: using guessed type char var_8D8[160];

//----- (00039848) --------------------------------------------------------
int __fastcall sub_39848(int a1)
{
  pthread_mutex_t *v2; // r0
  int v3; // r0
  int v4; // r2
  int v5; // r4
  int v6; // r0
  unsigned int v7; // r3
  unsigned int v8; // r1
  int v9; // r0
  unsigned int v10; // r3
  unsigned int v11; // r1
  int v12; // r0
  unsigned int v13; // r5
  int v14; // r3
  int v15; // r7
  char *v16; // r8
  __int64 v17; // r2
  int v18; // r3
  int v19; // r1
  int *v20; // r2
  int v21; // r4
  __int64 v22; // r2
  int v23; // r5
  _DWORD *v24; // r7
  int v25; // r10
  int v26; // r0
  unsigned int v27; // r3
  char *v28; // r5
  unsigned int v29; // r4
  int v30; // r4
  char *v31; // r9
  unsigned int v32; // r3
  int v33; // r3
  _DWORD *v34; // r3
  unsigned int v35; // r2
  unsigned int v36; // r1
  bool v37; // cc
  int v38; // r2
  int v39; // r3
  int v40; // r6
  int v41; // r5
  char *v42; // r3
  _DWORD *v43; // r1
  unsigned int v44; // r7
  char *v45; // r12
  int v46; // lr
  int v47; // r2
  int v48; // lr
  char *v49; // r10
  bool v50; // zf
  int v51; // r12
  bool v52; // zf
  bool v53; // zf
  char *v54; // r11
  int v55; // r12
  char *v57; // r0
  void *v58; // r0
  int *v59; // r0
  int *v60; // r0
  unsigned int i; // [sp+14h] [bp-834h]
  char s[2088]; // [sp+20h] [bp-828h] BYREF

  if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
  {
    snprintf(s, 2048u, "Pushing work from pool %d to hash queue", **(_DWORD **)(a1 + 260));
    log_event(7, s, 0);
  }
  *(_DWORD *)(a1 + 336) = dword_66BF4;
  sub_36458(a1);
  v2 = (pthread_mutex_t *)dword_66A80;
  ++*(_DWORD *)(*(_DWORD *)(a1 + 260) + 68);
  if ( pthread_mutex_lock(v2) )
  {
    v60 = _errno_location();
    snprintf(s, 2048u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v60, "cgminer.c", "hash_push", 5809);
LABEL_107:
    log_event(3, s, 1);
    shutdown_miner(1, 1);
  }
  if ( !*(_BYTE *)(a1 + 273) && *(_DWORD *)(a1 + 276) )
    ++dword_66BD0;
  v3 = dword_72EB8;
  v4 = *(unsigned __int8 *)(dword_72EB8 + 8);
  if ( *(_BYTE *)(dword_72EB8 + 8) )
    goto LABEL_95;
  v5 = dword_66B5C;
  v6 = (*(unsigned __int8 *)(a1 + 340)
      + 17973517
      + (*(unsigned __int8 *)(a1 + 343) << 24)
      + (*(unsigned __int8 *)(a1 + 342) << 16)
      + (*(unsigned __int8 *)(a1 + 341) << 8)) ^ 0x7F76D;
  v7 = (-1622558010 - v6) ^ (v6 << 8);
  *(_DWORD *)(a1 + 364) = a1 + 340;
  v8 = (-17973517 - v6 - v7) ^ (v7 >> 13);
  *(_DWORD *)(a1 + 368) = 4;
  v9 = (v6 - v7 - v8) ^ (v8 >> 12);
  v10 = (v7 - v8 - v9) ^ (v9 << 16);
  v11 = (v8 - v9 - v10) ^ (v10 >> 5);
  v12 = (v9 - v10 - v11) ^ (v11 >> 3);
  v13 = (v11 - v12 - ((v10 - v11 - v12) ^ (v12 << 10))) ^ (((v10 - v11 - v12) ^ (v12 << 10)) >> 15);
  *(_DWORD *)(a1 + 372) = v13;
  if ( v5 )
  {
    v14 = *(_DWORD *)(v5 + 344);
    v15 = a1 + 344;
    *(_DWORD *)(a1 + 352) = v4;
    *(_DWORD *)(a1 + 344) = v14;
    *(_DWORD *)(a1 + 348) = *(_DWORD *)(*(_DWORD *)(v5 + 344) + 16) - *(_DWORD *)(*(_DWORD *)(v5 + 344) + 20);
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v5 + 344) + 16) + 8) = a1;
    *(_DWORD *)(*(_DWORD *)(v5 + 344) + 16) = a1 + 344;
    v16 = *(char **)(v5 + 344);
  }
  else
  {
    *(_DWORD *)(a1 + 352) = 0;
    *(_DWORD *)(a1 + 348) = 0;
    dword_66B5C = a1;
    v57 = (char *)malloc(44u);
    v16 = v57;
    *(_DWORD *)(a1 + 344) = v57;
    if ( !v57 )
      goto LABEL_109;
    memset(v57 + 12, 0, 32u);
    v15 = a1 + 344;
    *((_DWORD *)v16 + 1) = 32;
    *((_DWORD *)v16 + 4) = a1 + 344;
    *((_DWORD *)v16 + 2) = 5;
    *((_DWORD *)v16 + 5) = 344;
    v58 = calloc(384u, 1u);
    *(_DWORD *)v16 = v58;
    if ( !v58 )
      goto LABEL_109;
    v5 = a1;
    *((_DWORD *)v16 + 10) = -1609490463;
  }
  ++*((_DWORD *)v16 + 3);
  v17 = *(_QWORD *)*(_DWORD *)(v5 + 344);
  v18 = 12 * ((HIDWORD(v17) - 1) & v13);
  ++*(_DWORD *)(v17 + v18 + 4);
  LODWORD(v17) = *(_DWORD *)(**(_DWORD **)(v5 + 344) + v18);
  *(_DWORD *)(a1 + 356) = 0;
  *(_DWORD *)(a1 + 360) = v17;
  LODWORD(v17) = **(_DWORD **)(v5 + 344);
  v19 = *(_DWORD *)(v17 + v18);
  v20 = (int *)(v17 + v18);
  if ( v19 )
  {
    *(_DWORD *)(v19 + 12) = v15;
    v20 = (int *)(**(_DWORD **)(v5 + 344) + v18);
  }
  *v20 = v15;
  v21 = dword_66B5C;
  v22 = *(_QWORD *)(**(_DWORD **)(dword_66B5C + 344) + v18 + 4);
  if ( (unsigned int)v22 >= 10 * (HIDWORD(v22) + 1) )
  {
    v23 = *(_DWORD *)(a1 + 344);
    if ( *(_DWORD *)(v23 + 36) != 1 )
    {
      v24 = calloc(24 * *(_DWORD *)(v23 + 4), 1u);
      if ( v24 )
      {
        v25 = 0;
        *(_DWORD *)(v23 + 24) = (((2 * *(_DWORD *)(v23 + 4) - 1) & *(_DWORD *)(v23 + 12)) != 0)
                              + (*(_DWORD *)(v23 + 12) >> (*(_BYTE *)(v23 + 8) + 1));
        *(_DWORD *)(*(_DWORD *)(a1 + 344) + 28) = 0;
        v26 = *(_DWORD *)(a1 + 344);
        v27 = *(_DWORD *)(v26 + 4);
        if ( v27 )
        {
          for ( i = 0; i < v27; ++i )
          {
            v28 = *(char **)(*(_DWORD *)v26 + v25);
            if ( v28 )
            {
              v29 = v27;
              while ( 1 )
              {
                v16 = (char *)*((_DWORD *)v28 + 4);
                v30 = 3 * ((2 * v29 - 1) & *((_DWORD *)v28 + 7));
                v31 = (char *)&v24[v30];
                v32 = *((_DWORD *)v31 + 1) + 1;
                *((_DWORD *)v31 + 1) = v32;
                if ( v32 > *(_DWORD *)(v26 + 24) )
                {
                  ++*(_DWORD *)(v26 + 28);
                  *((_DWORD *)v31 + 2) = calculate_miner_hashrate(
                                           *((_DWORD *)v31 + 1),
                                           *(_DWORD *)(*(_DWORD *)(a1 + 344) + 24));
                }
                *((_DWORD *)v28 + 3) = 0;
                *((_DWORD *)v28 + 4) = v24[v30];
                v33 = v24[v30];
                if ( v33 )
                  *(_DWORD *)(v33 + 12) = v28;
                v24[v30] = v28;
                v26 = *(_DWORD *)(a1 + 344);
                if ( !v16 )
                  break;
                v29 = *(_DWORD *)(v26 + 4);
                v28 = v16;
              }
              v27 = *(_DWORD *)(v26 + 4);
            }
            v25 += 12;
          }
        }
        free(*(void **)v26);
        *(_DWORD *)(*(_DWORD *)(a1 + 344) + 4) *= 2;
        ++*(_DWORD *)(*(_DWORD *)(a1 + 344) + 8);
        **(_DWORD **)(a1 + 344) = v24;
        v34 = *(_DWORD **)(a1 + 344);
        v21 = dword_66B5C;
        v35 = v34[7];
        v36 = v34[3];
        v37 = v35 > v36 >> 1;
        if ( v35 <= v36 >> 1 )
          v38 = 0;
        else
          v38 = v34[8];
        if ( v37 )
          ++v38;
        v34[8] = v38;
        v39 = *(_DWORD *)(a1 + 344);
        if ( *(_DWORD *)(v39 + 32) > 1u )
          *(_DWORD *)(v39 + 36) = 1;
        v3 = dword_72EB8;
        if ( !v21 )
          goto LABEL_95;
        goto LABEL_38;
      }
LABEL_109:
      exit(-1);
    }
  }
  v3 = dword_72EB8;
LABEL_38:
  v40 = v21 + 344;
  v41 = 1;
  do
  {
    v42 = (char *)v40;
    v40 = 0;
    v43 = 0;
    v44 = 0;
    do
    {
      ++v44;
      if ( v41 )
      {
        v45 = (char *)*((_DWORD *)v42 + 2);
        if ( v45 && (v46 = *(_DWORD *)(*(_DWORD *)(v21 + 344) + 20), (v45 += v46) != 0) )
        {
          v47 = 1;
          do
          {
            if ( v47 == v41 )
            {
              v48 = v47;
              goto LABEL_48;
            }
            v45 = (char *)*((_DWORD *)v45 + 2);
            ++v47;
            if ( !v45 )
              break;
            v45 += v46;
          }
          while ( v45 );
          v48 = v41;
        }
        else
        {
          v48 = v41;
          v47 = 1;
        }
      }
      else
      {
        v45 = v42;
        v48 = 0;
        v47 = 0;
      }
LABEL_48:
      v49 = v42;
      v42 = v45;
LABEL_49:
      while ( v47 )
      {
        v53 = v42 == 0;
        if ( v42 )
          v53 = v48 == 0;
        if ( v53 )
        {
          if ( v49 )
          {
            v16 = (char *)*((_DWORD *)v49 + 2);
            if ( v16 )
              v16 += *(_DWORD *)(*(_DWORD *)(v21 + 344) + 20);
            goto LABEL_71;
          }
        }
        else
        {
          v16 = *(char **)(*(_DWORD *)(v21 + 344) + 20);
          if ( *(_DWORD *)(v49 - v16 + 264) - *(_DWORD *)(v42 - v16 + 264) > 0 )
          {
            v51 = *((_DWORD *)v42 + 2);
            if ( v51 )
              v51 += (int)v16;
LABEL_58:
            --v48;
            if ( !v43 )
            {
              v43 = v42;
              v42 = (char *)v51;
              goto LABEL_76;
            }
            v16 = &v42[-*(_DWORD *)(*(_DWORD *)(v21 + 344) + 20)];
            v43[2] = v16;
            if ( !v42 )
            {
              v43 = 0;
              v42 = (char *)v51;
              goto LABEL_49;
            }
            goto LABEL_62;
          }
          if ( v49 )
          {
            v55 = *((_DWORD *)v49 + 2);
            if ( v55 )
              v16 += v55;
            else
              v16 = 0;
            goto LABEL_71;
          }
        }
        v16 = v49;
LABEL_71:
        --v47;
        if ( !v43 )
        {
          v43 = v49;
          v49 = v16;
LABEL_76:
          v40 = (int)v43;
          if ( v43 )
          {
            v16 = 0;
            goto LABEL_63;
          }
          goto LABEL_49;
        }
        if ( !v49 )
        {
          v43[2] = 0;
          v43 = 0;
          v49 = v16;
          goto LABEL_49;
        }
        v51 = (int)v42;
        v42 = v49;
        v54 = &v49[-*(_DWORD *)(*(_DWORD *)(v21 + 344) + 20)];
        v49 = v16;
        v43[2] = v54;
LABEL_62:
        v16 = (char *)v43 - *(_DWORD *)(*(_DWORD *)(v21 + 344) + 20);
        v43 = v42;
        v42 = (char *)v51;
LABEL_63:
        v43[1] = v16;
      }
      v50 = v48 == 0;
      if ( v48 )
        v50 = v42 == 0;
      if ( !v50 )
      {
        v51 = *((_DWORD *)v42 + 2);
        v52 = v51 == 0;
        if ( v51 )
          v16 = *(char **)(v21 + 344);
        else
          v51 = v47;
        if ( !v52 )
        {
          v16 = (char *)*((_DWORD *)v16 + 5);
          v51 += (int)v16;
        }
        goto LABEL_58;
      }
    }
    while ( v42 );
    if ( v43 )
      v43[2] = 0;
    if ( v44 <= 1 )
      goto LABEL_94;
    v41 *= 2;
  }
  while ( v40 );
  v43 = 0;
LABEL_94:
  *(_DWORD *)(*(_DWORD *)(v21 + 344) + 16) = v43;
  dword_66B5C = v40 - *(_DWORD *)(*(_DWORD *)(v21 + 344) + 20);
LABEL_95:
  pthread_cond_broadcast((pthread_cond_t *)(v3 + 40));
  if ( pthread_mutex_unlock((pthread_mutex_t *)dword_66A80) )
  {
    v59 = _errno_location();
    snprintf(s, 2048u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v59, "cgminer.c", "hash_push", 5827);
    goto LABEL_107;
  }
  return off_658DC(0);
}
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 1DA28: using guessed type int sub_1DA28(void);
// 2AB30: using guessed type void __fastcall __noreturn sub_2AB30(_DWORD, _DWORD);
// 48AC8: using guessed type int __fastcall sub_48AC8(_DWORD, _DWORD);
// 657B8: using guessed type int dword_657B8;
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);
// 66640: using guessed type char byte_66640;
// 66641: using guessed type char byte_66641;
// 66A80: using guessed type int dword_66A80;
// 66B5C: using guessed type int dword_66B5C;
// 66BD0: using guessed type int dword_66BD0;
// 66BF4: using guessed type int dword_66BF4;
// 70CE8: using guessed type char byte_70CE8;
// 72EB8: using guessed type int dword_72EB8;

//----- (0003A014) --------------------------------------------------------
int __fastcall process_work_submission(_DWORD *work_info, int unnamed_arg2, int unnamed_arg3)
{
  _DWORD *work_data; // r4
  int pool_idx; // r5
  double *work_info_double_ptr; // r12
  __int64 current_val_qword_70E48; // kr08_8
  double current_dbl_72E80; // d6
  double work_increment; // d5
  double new_work_data_val; // d7
  int function_result; // r0
  _BYTE *work_info_byte_ptr; // r3
  int *lock_err_num_ptr; // r0
  double *work_info_double_ptr_reuse; // r0
  double unclear_double_val1; // d6
  double unclear_double_val2; // d7
  double increment_val; // d5
  int *unlock_err_num_ptr; // r0
  int *lock_err_num_ptr_discard; // r0
  int *unlock_err_num_ptr_discard; // r0
  void *function_args[2]; // [sp+14h] [bp-81Ch] BYREF
  pthread_t submit_work_thread_id; // [sp+1Ch] [bp-814h] BYREF
  char log_message[2064]; // [sp+20h] [bp-810h] BYREF

  function_args[0] = work_info;
  work_data = (_DWORD *)work_info[65];
  get_hardware_timestamp(work_info + 108, unnamed_arg2, unnamed_arg3, work_info);
  if ( byte_66BA8 )
  {
    pool_idx = *(_DWORD *)(get_thread_metadata(*((_DWORD *)function_args[0] + 64)) + 36);
    if ( pthread_mutex_lock(&stru_70CEC) )
    {
      lock_err_num_ptr = _errno_location();
      snprintf(
        log_message,
        2048u,
        "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
        *lock_err_num_ptr,
        "cgminer.c",
        "submit_work_async",
        8737);
    }
    else
    {
      work_info_double_ptr = (double *)function_args[0];
      current_val_qword_70E48 = qword_70E48;
      ++*(_DWORD *)(pool_idx + 36);
      qword_70E48 = current_val_qword_70E48 + 1;
      current_dbl_72E80 = dbl_72E80;
      ++*((_QWORD *)work_data + 1);
      *(double *)(pool_idx + 200) = *(double *)(pool_idx + 200) + work_info_double_ptr[47];
      work_increment = work_info_double_ptr[47];
      new_work_data_val = *((double *)work_data + 9) + work_increment;
      dbl_72E80 = current_dbl_72E80 + work_increment;
      *((double *)work_data + 9) = new_work_data_val;
      if ( !pthread_mutex_unlock(&stru_70CEC) )
      {
        function_result = off_658DC(0);
        if ( byte_70CE8 || byte_66640 || dword_657B8 > 4 )
        {
          snprintf(
            log_message,
            2048u,
            "Accepted %s %d benchmark share nonce %08x",
            *(const char **)(*(_DWORD *)(pool_idx + 4) + 8),
            *(_DWORD *)(pool_idx + 8),
            *((_DWORD *)function_args[0] + 19));
          return log_event(5, log_message, 0);
        }
        return function_result;
      }
      unlock_err_num_ptr = _errno_location();
      snprintf(
        log_message,
        2048u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *unlock_err_num_ptr,
        "cgminer.c",
        "submit_work_async",
        8744);
    }
LABEL_49:
    log_event(3, log_message, 1);
    shutdown_miner(1, 1);
  }
  if ( check_work_staleness(function_args[0], 1) )
  {
    if ( byte_6615D )
    {
      if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
      {
        snprintf(log_message, 2048u, "Pool %d stale share detected, submitting as user requested", *work_data);
        log_event(7, log_message, 0);
      }
    }
    else
    {
      if ( !*((_BYTE *)work_data + 104) )
      {
        if ( byte_70CE8 || byte_66640 || dword_657B8 > 4 )
        {
          snprintf(log_message, 2048u, "Pool %d stale share detected, discarding", *work_data);
          log_event(5, log_message, 0);
        }
        log_share_info("discard", function_args[0]);
        if ( pthread_mutex_lock(&stru_70CEC) )
        {
          lock_err_num_ptr_discard = _errno_location();
          snprintf(
            log_message,
            2048u,
            "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
            *lock_err_num_ptr_discard,
            "cgminer.c",
            "submit_work_async",
            8765);
        }
        else
        {
          work_info_double_ptr_reuse = (double *)function_args[0];
          unclear_double_val1 = *((double *)work_data + 11);
          unclear_double_val2 = dbl_70E50;
          ++work_data[30];
          increment_val = work_info_double_ptr_reuse[47];
          ++qword_74220;
          *((double *)work_data + 11) = unclear_double_val1 + increment_val;
          dbl_70E50 = unclear_double_val2 + increment_val;
          if ( !pthread_mutex_unlock(&stru_70CEC) )
          {
            off_658DC(0);
            return clear_miner_data_if_not_null(function_args, "cgminer.c", "submit_work_async", 8774);
          }
          unlock_err_num_ptr_discard = _errno_location();
          snprintf(
            log_message,
            2048u,
            "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
            *unlock_err_num_ptr_discard,
            "cgminer.c",
            "submit_work_async",
            8772);
        }
        goto LABEL_49;
      }
      if ( byte_70CE8 || byte_66640 || dword_657B8 > 4 )
      {
        snprintf(log_message, 2048u, "Pool %d stale share detected, submitting as pool requested", *work_data);
        log_event(5, log_message, 0);
      }
    }
    work_info_byte_ptr = function_args[0];
    *((_BYTE *)function_args[0] + 281) = 1;
  }
  else
  {
    work_info_byte_ptr = function_args[0];
  }
  if ( work_info_byte_ptr[284] )
  {
    if ( byte_66641 )
    {
      if ( !byte_70CE8 && !byte_66640 && dword_657B8 <= 6 )
      {
        if ( !work_data[182] )
        {
LABEL_16:
          if ( dword_657B8 <= 3 )
          {
            if ( work_data[182] )
              return clear_miner_data_if_not_null(function_args, "cgminer.c", "submit_work_async", 8788);
            goto LABEL_61;
          }
LABEL_30:
          strcpy(log_message, "Discarding work from removed pool");
          log_event(4, log_message, 0);
          if ( work_data[182] )
            return clear_miner_data_if_not_null(function_args, "cgminer.c", "submit_work_async", 8788);
          if ( byte_70CE8 || byte_66640 )
          {
LABEL_33:
            snprintf(log_message, 2048u, "Pushing pool %d work to stratum queue", *work_data);
            log_event(5, log_message, 0);
            return clear_miner_data_if_not_null(function_args, "cgminer.c", "submit_work_async", 8788);
          }
LABEL_61:
          if ( dword_657B8 <= 4 )
            return clear_miner_data_if_not_null(function_args, "cgminer.c", "submit_work_async", 8788);
          goto LABEL_33;
        }
LABEL_27:
        function_result = queue_push();
        if ( function_result )
          return function_result;
LABEL_28:
        if ( byte_70CE8 || byte_66640 )
          goto LABEL_30;
        goto LABEL_16;
      }
      snprintf(log_message, 2048u, "Pushing pool %d work to stratum queue", *work_data);
      log_event(7, log_message, 0);
    }
    if ( !work_data[182] )
      goto LABEL_28;
    goto LABEL_27;
  }
  if ( byte_70CE8 || byte_66640 || dword_657B8 > 4 )
  {
    strcpy(log_message, "Pushing submit work to work thread");
    log_event(5, log_message, 0);
    work_info_byte_ptr = function_args[0];
  }
  function_result = pthread_create(
                      &submit_work_thread_id,
                      0,
                      (void *(*)(void *))detach_current_thread,
                      work_info_byte_ptr);
  if ( function_result )
  {
    strcpy(log_message, "Failed to create submit_work_thread");
    log_event(3, log_message, 1);
    shutdown_miner(1, 1);
  }
  return function_result;
}
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 1DA28: using guessed type int sub_1DA28(void);
// 1EFF4: using guessed type int sub_1EFF4(void);
// 1F5C4: using guessed type int __fastcall sub_1F5C4(_DWORD, _DWORD, _DWORD, _DWORD);
// 27820: using guessed type int sub_27820();
// 28FFC: using guessed type int __fastcall sub_28FFC(_DWORD, _DWORD, _DWORD, _DWORD);
// 2AB30: using guessed type void __fastcall __noreturn sub_2AB30(_DWORD, _DWORD);
// 2DF8C: using guessed type int __fastcall sub_2DF8C(_DWORD);
// 31AE8: using guessed type int __fastcall sub_31AE8(_DWORD, _DWORD);
// 324CC: using guessed type int __fastcall sub_324CC(_DWORD, _DWORD);
// 657B8: using guessed type int dword_657B8;
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);
// 6615D: using guessed type char byte_6615D;
// 66640: using guessed type char byte_66640;
// 66641: using guessed type char byte_66641;
// 66BA8: using guessed type char byte_66BA8;
// 70CE8: using guessed type char byte_70CE8;
// 70CEC: using guessed type pthread_mutex_t stru_70CEC;
// 70E48: using guessed type __int64 qword_70E48;
// 72E80: using guessed type double dbl_72E80;
// 74220: using guessed type __int64 qword_74220;

//----- (0003A768) --------------------------------------------------------
int __fastcall submit_work(int miner_index, int work_data)
{
  int hash_compare_result; // r6
  unsigned int *new_work_ptr; // r5
  int unused_var1; // r1
  int unused_var2; // r2
  char log_message[2064]; // [sp+8h] [bp-810h] BYREF

  update_miner_statistics((int *)(miner_index + 36), work_data);
  hash_compare_result = compare_hashes_and_log((unsigned int *)(work_data + 192), (unsigned int *)(work_data + 160));
  if ( hash_compare_result )
  {
    new_work_ptr = (unsigned int *)initialize_work();
    copy_work_details(new_work_ptr, work_data, 0);
    process_work_submission(new_work_ptr, unused_var1, unused_var2);
    return hash_compare_result;
  }
  else
  {
    if ( byte_70CE8 || byte_66640 || dword_657B8 > 5 )
    {
      snprintf(
        log_message,
        2048u,
        "%s %s %d: Share above target",
        "submit_tested_work",
        *(const char **)(*(_DWORD *)(*(_DWORD *)(miner_index + 36) + 4) + 8),
        *(_DWORD *)(*(_DWORD *)(miner_index + 36) + 8));
      log_event(6, log_message, 0);
    }
    return 0;
  }
}
// 3A83C: variable 'unused_var1' is possibly undefined
// 3A83C: variable 'unused_var2' is possibly undefined
// 657B8: using guessed type int dword_657B8;
// 66640: using guessed type char byte_66640;
// 70CE8: using guessed type char byte_70CE8;

//----- (0003A854) --------------------------------------------------------
int __fastcall verify_and_submit_nonce(int miner_id, int work_data, unsigned int nonce)
{
  int is_duplicate; // r5

  is_duplicate = check_and_log_duplicate_share(miner_id, nonce);
  if ( is_duplicate
    && (*(_DWORD *)(work_data + 76) = nonce, process_sha256_block(work_data), !*(_DWORD *)(work_data + 220)) )
  {
    submit_work(miner_id, work_data);
    if ( dword_70D08 && byte_70DBC )
    {
      is_duplicate = (unsigned __int8)byte_70DBC;
      log_benchfile_event(work_data, nonce);
    }
  }
  else
  {
    is_duplicate = 0;
    increment_hardware_errors(miner_id);
  }
  return is_duplicate;
}
// 70D08: using guessed type int dword_70D08;
// 70DBC: using guessed type char byte_70DBC;

//----- (0003A8E8) --------------------------------------------------------
int __fastcall prepare_work_for_processing(int input_param)
{
  unsigned int *work_ptr; // r4
  int unused_param1; // r1
  int unused_param2; // r2

  work_ptr = (unsigned int *)initialize_work();
  copy_work_details(work_ptr, input_param, 0);
  return process_work_submission(work_ptr, unused_param1, unused_param2);
}
// 3A90C: variable 'unused_param1' is possibly undefined
// 3A90C: variable 'unused_param2' is possibly undefined

//----- (0003A910) --------------------------------------------------------
int __fastcall configure_work_for_processing(int arg1, int work_info, int work_data)
{
  unsigned int *work_ptr; // r5
  int arg2; // r1
  int arg3; // r2

  *(_DWORD *)(work_info + 76) = work_data;
  work_ptr = (unsigned int *)initialize_work();
  copy_work_details(work_ptr, work_info, 0);
  process_work_submission(work_ptr, arg2, arg3);
  return 1;
}
// 3A934: variable 'arg2' is possibly undefined
// 3A934: variable 'arg3' is possibly undefined

//----- (0003AADC) --------------------------------------------------------
void __fastcall __noreturn shutdown_miner_safely(int shutdown_reason)
{
  shutdown_miner(shutdown_reason, 1);
}

//----- (0003AAE8) --------------------------------------------------------
int __fastcall add_pool_details_to_miner(
        int miner_struct_ptr,
        int start_mining_flag,
        char *pool_str,
        const char *pool_url,
        int worker_name)
{
  int pool_str_len; // r0
  size_t pool_url_len; // r5
  size_t alloc_len; // r5
  char *combined_pool_worker_str; // r0
  const char *worker_name_ptr; // r12
  const char *pool_url_ptr; // r3
  int current_mining_state; // r2

  pool_str_len = update_proxy_settings(pool_str);
  *(_DWORD *)(miner_struct_ptr + 172) = pool_url;
  *(_DWORD *)(miner_struct_ptr + 164) = pool_str_len;
  *(_DWORD *)(miner_struct_ptr + 176) = worker_name;
  pool_url_len = strlen(pool_url);
  alloc_len = pool_url_len + strlen((const char *)worker_name) + 2;
  combined_pool_worker_str = (char *)safe_malloc_with_logging(alloc_len, "cgminer.c", "add_pool_details", 10888);
  worker_name_ptr = *(const char **)(miner_struct_ptr + 176);
  pool_url_ptr = *(const char **)(miner_struct_ptr + 172);
  *(_DWORD *)(miner_struct_ptr + 168) = combined_pool_worker_str;
  snprintf(combined_pool_worker_str, alloc_len, "%s:%s", pool_url_ptr, worker_name_ptr);
  current_mining_state = *(_DWORD *)(miner_struct_ptr + 100);
  *(_BYTE *)(miner_struct_ptr + 284) = 1;
  *(_BYTE *)(miner_struct_ptr + 107) = start_mining_flag ^ 1;
  *(_BYTE *)(miner_struct_ptr + 97) = 1;
  if ( current_mining_state != 1 )
    increment_counter_and_set_flag(miner_struct_ptr + 100);
  pthread_create(
    (pthread_t *)(miner_struct_ptr + 280),
    0,
    (void *(*)(void *))run_mining_thread,
    (void *)miner_struct_ptr);
  if ( !start_mining_flag )
  {
    pthread_join(*(_DWORD *)(miner_struct_ptr + 280), 0);
    return (unsigned __int8)byte_66964;
  }
  return start_mining_flag;
}
// 1E74C: using guessed type int __fastcall sub_1E74C(_DWORD, _DWORD, _DWORD, _DWORD);
// 27998: using guessed type int __fastcall sub_27998(_DWORD);
// 66964: using guessed type char byte_66964;

//----- (0003ABDC) --------------------------------------------------------
int __fastcall initialize_miner_defaults(int config_ptr)
{
  if ( !*(_DWORD *)(config_ptr + 12) )
    *(_DWORD *)(config_ptr + 12) = 159056;
  if ( !*(_DWORD *)(config_ptr + 16) )
    *(_DWORD *)(config_ptr + 16) = 159020;
  if ( !*(_DWORD *)(config_ptr + 20) )
    *(_DWORD *)(config_ptr + 20) = nullsub_1;
  if ( !*(_DWORD *)(config_ptr + 24) )
    *(_DWORD *)(config_ptr + 24) = nullsub_2;
  if ( !*(_DWORD *)(config_ptr + 32) )
    *(_DWORD *)(config_ptr + 32) = 159028;
  if ( !*(_DWORD *)(config_ptr + 44) )
    *(_DWORD *)(config_ptr + 44) = 166364;
  if ( !*(_DWORD *)(config_ptr + 52) )
    *(_DWORD *)(config_ptr + 52) = 166372;
  if ( !*(_DWORD *)(config_ptr + 56) )
    *(_DWORD *)(config_ptr + 56) = 159048;
  if ( !*(_DWORD *)(config_ptr + 84) )
    *(_DWORD *)(config_ptr + 84) = 166380;
  if ( !*(_DWORD *)(config_ptr + 88) )
    *(_DWORD *)(config_ptr + 88) = 166384;
  if ( !*(_DWORD *)(config_ptr + 92) )
    *(_DWORD *)(config_ptr + 92) = 166388;
  if ( !*(_DWORD *)(config_ptr + 60) )
    *(_DWORD *)(config_ptr + 60) = process_mining;
  if ( !*(_DWORD *)(config_ptr + 76) )
    *(_DWORD *)(config_ptr + 76) = 159020;
  if ( !*(_DWORD *)(config_ptr + 80) )
    *(_DWORD *)(config_ptr + 80) = 159020;
  if ( !*(_DWORD *)(config_ptr + 72) )
    *(_DWORD *)(config_ptr + 72) = 159028;
  if ( !*(_DWORD *)(config_ptr + 96) )
    *(_DWORD *)(config_ptr + 96) = 159068;
  if ( *(double *)(config_ptr + 104) == 0.0 )
    *(_QWORD *)(config_ptr + 104) = 4607182418800017408LL;
  return config_ptr;
}

//----- (0003AD3C) --------------------------------------------------------
int __fastcall initialize_miner_callbacks(int config_structure)
{
  *(_DWORD *)(config_structure + 28) = get_static_zero;
  *(_DWORD *)(config_structure + 12) = nullsub_4;
  *(_DWORD *)(config_structure + 20) = nullsub_1;
  *(_DWORD *)(config_structure + 24) = nullsub_2;
  *(_DWORD *)(config_structure + 40) = 0;
  *(_DWORD *)(config_structure + 44) = sub_289DC;
  *(_DWORD *)(config_structure + 48) = get_max_unsigned_int;
  *(_DWORD *)(config_structure + 52) = return_one;
  *(_DWORD *)(config_structure + 56) = sub_26D48;
  *(_DWORD *)(config_structure + 60) = nullsub_5;
  *(_DWORD *)(config_structure + 84) = nullsub_6;
  *(_DWORD *)(config_structure + 88) = nullsub_7;
  *(_DWORD *)(config_structure + 92) = nullsub_8;
  *(_DWORD *)(config_structure + 96) = reset_miner_status;
  *(_DWORD *)(config_structure + 16) = nullsub_3;
  *(_DWORD *)(config_structure + 36) = nullsub_3;
  *(_DWORD *)(config_structure + 76) = nullsub_3;
  *(_DWORD *)(config_structure + 80) = nullsub_3;
  *(_DWORD *)(config_structure + 32) = always_return_one;
  *(_DWORD *)(config_structure + 72) = always_return_one;
  *(_QWORD *)(config_structure + 104) = 4607182418800017408LL;
  *(_QWORD *)(config_structure + 112) = 4607182418800017408LL;
  return config_structure;
}

//----- (0003AE24) --------------------------------------------------------
int __fastcall initialize_device_lock(pthread_rwlock_t *device_lock)
{
  int device_list_ptr; // r1
  int current_device_index; // r3
  int temp_value; // r1
  unsigned int additional_value; // r2
  unsigned int writers_queued_or_value; // r3
  int init_result; // r0

  device_lock[1].__lock = 0;
  if ( pthread_rwlock_wrlock(&stru_72F18) )
    log_write_lock_error("enable_device", 11298);
  device_list_ptr = dword_72EC0;
  current_device_index = dword_68180;
  device_lock->__lock = dword_68180;
  *(_DWORD *)(device_list_ptr + 4 * current_device_index) = device_lock;
  dword_68180 = current_device_index + 1;
  if ( pthread_rwlock_unlock(&stru_72F18) )
    log_rwlock_error_and_exit("enable_device", 11300);
  off_658DC(0);
  if ( byte_72F68 )
    writers_queued_or_value = device_lock[4].__nr_writers_queued;
  else
    writers_queued_or_value = 16768;
  if ( byte_72F68 )
    additional_value = dword_68184;
  else
    HIWORD(writers_queued_or_value) = 7;
  if ( byte_72F68 )
  {
    writers_queued_or_value += additional_value;
    dword_68184 = writers_queued_or_value;
  }
  else
  {
    temp_value = *(_DWORD *)writers_queued_or_value;
    additional_value = device_lock[4].__nr_writers_queued;
  }
  if ( !byte_72F68 )
    additional_value += temp_value;
  if ( !byte_72F68 )
    *(_DWORD *)writers_queued_or_value = additional_value;
  init_result = pthread_rwlock_init(device_lock + 10, 0);
  if ( init_result )
    log_rwlock_init_error("enable_device", 11311);
  device_lock[11].__lock = 0;
  return init_result;
}
// 3AEC0: variable 'additional_value' is possibly undefined
// 3AEC8: variable 'temp_value' is possibly undefined
// 1DA28: using guessed type int sub_1DA28(void);
// 2B338: using guessed type void __fastcall __noreturn sub_2B338(_DWORD, _DWORD);
// 2B404: using guessed type void __fastcall __noreturn sub_2B404(_DWORD, _DWORD);
// 2BFAC: using guessed type void __fastcall __noreturn sub_2BFAC(_DWORD, _DWORD);
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);
// 68180: using guessed type int dword_68180;
// 68184: using guessed type int dword_68184;
// 72EC0: using guessed type int dword_72EC0;
// 72F18: using guessed type pthread_rwlock_t stru_72F18;
// 72F68: using guessed type char byte_72F68;

//----- (0003AF10) --------------------------------------------------------
int __fastcall update_miner_info(_DWORD *miner_info)
{
  unsigned int hash_init_val1; // r5
  const char *config_str; // r4
  size_t config_str_len; // r0
  int hash_init_val2; // r3
  size_t remaining_len; // r6
  int hash_val3; // r0
  unsigned __int8 *config_bytes_ptr; // r9
  int temp_val1; // lr
  int temp_val2; // r2
  int temp_val3; // r1
  int temp_val4; // r4
  unsigned int hash_loop_val1; // r5
  unsigned int hash_loop_val2; // r3
  int hash_loop_val3; // r2
  unsigned int hash_loop_val4; // r1
  unsigned int hash_loop_val5; // r3
  int hash_loop_val6; // r2
  unsigned int hash_loop_val7; // r1
  unsigned int hash_loop_val8; // r3
  size_t final_hash_val; // r3
  int hash_adjust_val1; // r0
  unsigned int hash_adjust_val2; // r2
  unsigned int hash_adjust_val3; // r7
  int hash_adjust_val4; // r3
  unsigned int hash_adjust_val5; // r2
  unsigned int hash_adjust_val6; // r7
  int hash_adjust_val7; // r3
  unsigned int hash_adjust_val_final; // r7
  _DWORD *hash_table_entry; // r1
  int hash_table_empty_slot; // r2
  int hash_entry_offset; // r8
  int current_hash_entry; // r5
  int next_hash_entry; // r5
  int updated_count; // r3
  int lock_result1; // r0
  int lock_result2; // r2
  int miners_count_temp; // r3
  int new_miners_count; // r1
  int final_result; // r0
  int new_miner_ptr; // r5
  unsigned int hash_init_val1_copy; // r7
  size_t new_miner_len; // r0
  int hash_init_val2_copy; // r12
  unsigned int remaining_len_copy; // r11
  int hash_val3_copy; // r3
  unsigned __int8 *new_miner_bytes_ptr; // r10
  unsigned int hash_loop_val_copy1; // r7
  unsigned __int8 *config_bytes_ptr_copy; // r2
  unsigned int temp_val3_copy; // r0
  unsigned int temp_val2_copy; // r1
  int hash_loop_val3_copy; // r3
  unsigned int hash_loop_val4_copy; // r0
  unsigned int hash_loop_val5_copy; // r1
  int hash_loop_val6_copy; // r3
  unsigned int hash_loop_val7_copy; // r0
  unsigned int hash_loop_val8_copy; // r1
  unsigned int final_hash_val_copy; // r12
  int hash_adjust_val1_copy; // r3
  unsigned int hash_adjust_val2_copy; // r2
  unsigned int hash_adjust_val3_copy; // r1
  int hash_adjust_val4_copy; // r3
  unsigned int hash_adjust_val5_copy; // r2
  unsigned int hash_adjust_val6_copy; // r1
  int hash_adjust_val7_copy; // r3
  unsigned int hash_adjust_val_final_copy; // r6
  int current_global_mempool_ptr; // r7
  int mempool_temp_val; // r3
  int new_miner_info_block; // r8
  __int64 temporary_64bit_val; // r2
  int hash_table_entry_id; // r3
  int previous_hash_entry; // r1
  int *hash_table_current_slot; // r2
  __int64 current_hash_count; // r2
  int current_mempool_ptr; // r3
  _DWORD *new_hash_array; // r8
  int mempool_rehash_offset; // r2
  int array_index_var; // r10
  int current_mempool_ptr_copy; // r3
  unsigned int new_hash_size; // r6
  _DWORD *current_hash_entry_copy; // r7
  unsigned int hash_array_size; // r4
  _DWORD *next_hash_entry_copy; // r6
  int hash_array_index; // r4
  char *hash_entry_ptr; // r9
  unsigned int hash_entry_count; // r3
  int current_mempool_ptr_copy2; // r2
  int current_hash_entry_val; // r3
  _DWORD *mempool_entry; // r3
  unsigned int lassified_count; // r2
  unsigned int hash_entry_lied_count; // r1
  bool need_resize_flag; // cc
  int resize_val; // r2
  int mempool_ptr; // r3
  unsigned __int8 *config_bytes_ptr_loop; // r11
  unsigned int remaining_len_loop; // r10
  void *new_mempool_ptr; // r0
  void **new_mempool_ptr_double; // r9
  void *new_mempool_entries_ptr; // r0
  const char *config_str_copy1; // [sp+10h] [bp-30h]
  char *s2; // [sp+10h] [bp-30h]
  char *config_str_copy2; // [sp+10h] [bp-30h]

  hash_init_val1 = -1640531527;
  config_str = *(const char **)(miner_info[1] + 8);
  config_str_copy1 = config_str;
  config_str_len = strlen(config_str);
  need_resize_flag = config_str_len > 11;
  hash_init_val2 = -17973521;
  remaining_len = config_str_len;
  hash_val3 = -1640531527;
  if ( need_resize_flag )
  {
    config_bytes_ptr = (unsigned __int8 *)(config_str + 12);
    remaining_len_loop = remaining_len;
    do
    {
      temp_val1 = *(config_bytes_ptr - 6);
      remaining_len_loop -= 12;
      temp_val2 = *(config_bytes_ptr - 2);
      temp_val3 = *(config_bytes_ptr - 10);
      config_bytes_ptr_loop = config_bytes_ptr;
      temp_val4 = *(config_bytes_ptr - 7);
      config_bytes_ptr += 12;
      hash_loop_val1 = (temp_val1 << 16)
                     + (temp_val4 << 8)
                     + *(config_bytes_ptr - 20)
                     + (*(config_bytes_ptr - 17) << 24)
                     + hash_init_val1;
      hash_loop_val2 = (temp_val2 << 16)
                     + (*(config_bytes_ptr - 15) << 8)
                     + *(config_bytes_ptr - 16)
                     + (*(config_bytes_ptr - 13) << 24)
                     + hash_init_val2;
      hash_loop_val3 = ((temp_val3 << 16)
                      + (*(config_bytes_ptr - 23) << 8)
                      + *(config_bytes_ptr - 24)
                      + (*(config_bytes_ptr - 21) << 24)
                      - hash_loop_val1
                      - hash_loop_val2
                      + hash_val3) ^ (hash_loop_val2 >> 13);
      hash_loop_val4 = (hash_loop_val1 - hash_loop_val2 - hash_loop_val3) ^ (hash_loop_val3 << 8);
      hash_loop_val5 = (hash_loop_val2 - hash_loop_val3 - hash_loop_val4) ^ (hash_loop_val4 >> 13);
      hash_loop_val6 = (hash_loop_val3 - hash_loop_val4 - hash_loop_val5) ^ (hash_loop_val5 >> 12);
      hash_loop_val7 = (hash_loop_val4 - hash_loop_val5 - hash_loop_val6) ^ (hash_loop_val6 << 16);
      hash_loop_val8 = (hash_loop_val5 - hash_loop_val6 - hash_loop_val7) ^ (hash_loop_val7 >> 5);
      hash_val3 = (hash_loop_val6 - hash_loop_val7 - hash_loop_val8) ^ (hash_loop_val8 >> 3);
      hash_init_val1 = (hash_loop_val7 - hash_loop_val8 - hash_val3) ^ (hash_val3 << 10);
      hash_init_val2 = (hash_loop_val8 - hash_val3 - hash_init_val1) ^ (hash_init_val1 >> 15);
    }
    while ( remaining_len_loop > 11 );
  }
  else
  {
    config_bytes_ptr_loop = (unsigned __int8 *)config_str;
    remaining_len_loop = remaining_len;
  }
  final_hash_val = remaining_len + hash_init_val2;
  switch ( remaining_len_loop )
  {
    case 1u:
      goto LABEL_16;
    case 2u:
      goto LABEL_15;
    case 3u:
      goto LABEL_14;
    case 4u:
      goto LABEL_13;
    case 5u:
      goto LABEL_12;
    case 6u:
      goto LABEL_11;
    case 7u:
      goto LABEL_10;
    case 8u:
      goto LABEL_9;
    case 9u:
      goto LABEL_8;
    case 10u:
      goto LABEL_7;
    case 11u:
      final_hash_val += config_bytes_ptr_loop[10] << 24;
LABEL_7:
      final_hash_val += config_bytes_ptr_loop[9] << 16;
LABEL_8:
      final_hash_val += config_bytes_ptr_loop[8] << 8;
LABEL_9:
      hash_init_val1 += config_bytes_ptr_loop[7] << 24;
LABEL_10:
      hash_init_val1 += config_bytes_ptr_loop[6] << 16;
LABEL_11:
      hash_init_val1 += config_bytes_ptr_loop[5] << 8;
LABEL_12:
      hash_init_val1 += config_bytes_ptr_loop[4];
LABEL_13:
      hash_val3 += config_bytes_ptr_loop[3] << 24;
LABEL_14:
      hash_val3 += config_bytes_ptr_loop[2] << 16;
LABEL_15:
      hash_val3 += config_bytes_ptr_loop[1] << 8;
LABEL_16:
      hash_val3 += *config_bytes_ptr_loop;
      break;
    default:
      break;
  }
  hash_adjust_val1 = (hash_val3 - hash_init_val1 - final_hash_val) ^ (final_hash_val >> 13);
  hash_adjust_val2 = (hash_init_val1 - final_hash_val - hash_adjust_val1) ^ (hash_adjust_val1 << 8);
  hash_adjust_val3 = (final_hash_val - hash_adjust_val1 - hash_adjust_val2) ^ (hash_adjust_val2 >> 13);
  hash_adjust_val4 = (hash_adjust_val1 - hash_adjust_val2 - hash_adjust_val3) ^ (hash_adjust_val3 >> 12);
  hash_adjust_val5 = (hash_adjust_val2 - hash_adjust_val3 - hash_adjust_val4) ^ (hash_adjust_val4 << 16);
  hash_adjust_val6 = (hash_adjust_val3 - hash_adjust_val4 - hash_adjust_val5) ^ (hash_adjust_val5 >> 5);
  hash_adjust_val7 = (hash_adjust_val4 - hash_adjust_val5 - hash_adjust_val6) ^ (hash_adjust_val6 >> 3);
  hash_adjust_val_final = (hash_adjust_val6
                         - hash_adjust_val7
                         - ((hash_adjust_val5 - hash_adjust_val6 - hash_adjust_val7) ^ (hash_adjust_val7 << 10))) ^ (((hash_adjust_val5 - hash_adjust_val6 - hash_adjust_val7) ^ (hash_adjust_val7 << 10)) >> 15);
  if ( !dword_68188
    || (hash_table_entry = *(_DWORD **)(dword_68188 + 8),
        (hash_table_empty_slot = *(_DWORD *)(*hash_table_entry + 12
                                                               * ((hash_table_entry[1] - 1) & hash_adjust_val_final))) == 0)
    || (hash_entry_offset = -hash_table_entry[5],
        current_hash_entry = hash_table_empty_slot - hash_table_entry[5],
        hash_table_empty_slot == hash_table_entry[5]) )
  {
LABEL_46:
    new_miner_ptr = safe_malloc_with_logging(40, "cgminer.c", "add_cgpu", 11345);
    log_memcpy_error(new_miner_ptr, *(_DWORD *)(miner_info[1] + 8), 4, "cgminer.c", "add_cgpu", 11346);
    *(_DWORD *)(new_miner_ptr + 4) = 0;
    miner_info[2] = 0;
    hash_init_val1_copy = -1640531527;
    new_miner_len = strlen((const char *)new_miner_ptr);
    hash_init_val2_copy = -17973521;
    s2 = (char *)new_miner_len;
    remaining_len_copy = new_miner_len;
    hash_val3_copy = -1640531527;
    if ( new_miner_len <= 11 )
    {
      config_bytes_ptr_copy = (unsigned __int8 *)new_miner_ptr;
      remaining_len_copy = new_miner_len;
    }
    else
    {
      new_miner_bytes_ptr = (unsigned __int8 *)(new_miner_ptr + 12);
      do
      {
        remaining_len_copy -= 12;
        hash_loop_val_copy1 = (*(new_miner_bytes_ptr - 6) << 16)
                            + (*(new_miner_bytes_ptr - 7) << 8)
                            + *(new_miner_bytes_ptr - 8)
                            + (*(new_miner_bytes_ptr - 5) << 24)
                            + hash_init_val1_copy;
        config_bytes_ptr_copy = new_miner_bytes_ptr;
        temp_val3_copy = (*(new_miner_bytes_ptr - 10) << 16)
                       + (*(new_miner_bytes_ptr - 11) << 8)
                       + *(new_miner_bytes_ptr - 12)
                       + (*(new_miner_bytes_ptr - 9) << 24)
                       - hash_loop_val_copy1;
        temp_val2_copy = (*(new_miner_bytes_ptr - 2) << 16)
                       + (*(new_miner_bytes_ptr - 3) << 8)
                       + *(new_miner_bytes_ptr - 4)
                       + (*(new_miner_bytes_ptr - 1) << 24)
                       + hash_init_val2_copy;
        new_miner_bytes_ptr += 12;
        hash_loop_val3_copy = (temp_val3_copy - temp_val2_copy + hash_val3_copy) ^ (temp_val2_copy >> 13);
        hash_loop_val4_copy = (hash_loop_val_copy1 - temp_val2_copy - hash_loop_val3_copy) ^ (hash_loop_val3_copy << 8);
        hash_loop_val5_copy = (temp_val2_copy - hash_loop_val3_copy - hash_loop_val4_copy) ^ (hash_loop_val4_copy >> 13);
        hash_loop_val6_copy = (hash_loop_val3_copy - hash_loop_val4_copy - hash_loop_val5_copy) ^ (hash_loop_val5_copy >> 12);
        hash_loop_val7_copy = (hash_loop_val4_copy - hash_loop_val5_copy - hash_loop_val6_copy) ^ (hash_loop_val6_copy << 16);
        hash_loop_val8_copy = (hash_loop_val5_copy - hash_loop_val6_copy - hash_loop_val7_copy) ^ (hash_loop_val7_copy >> 5);
        hash_val3_copy = (hash_loop_val6_copy - hash_loop_val7_copy - hash_loop_val8_copy) ^ (hash_loop_val8_copy >> 3);
        hash_init_val1_copy = (hash_loop_val7_copy - hash_loop_val8_copy - hash_val3_copy) ^ (hash_val3_copy << 10);
        hash_init_val2_copy = (hash_loop_val8_copy - hash_val3_copy - hash_init_val1_copy) ^ (hash_init_val1_copy >> 15);
      }
      while ( remaining_len_copy > 11 );
    }
    final_hash_val_copy = (unsigned int)&s2[hash_init_val2_copy];
    switch ( remaining_len_copy )
    {
      case 1u:
        goto LABEL_60;
      case 2u:
        goto LABEL_59;
      case 3u:
        goto LABEL_58;
      case 4u:
        goto LABEL_57;
      case 5u:
        goto LABEL_56;
      case 6u:
        goto LABEL_55;
      case 7u:
        goto LABEL_54;
      case 8u:
        goto LABEL_53;
      case 9u:
        goto LABEL_52;
      case 10u:
        goto LABEL_51;
      case 11u:
        final_hash_val_copy += config_bytes_ptr_copy[10] << 24;
LABEL_51:
        final_hash_val_copy += config_bytes_ptr_copy[9] << 16;
LABEL_52:
        final_hash_val_copy += config_bytes_ptr_copy[8] << 8;
LABEL_53:
        hash_init_val1_copy += config_bytes_ptr_copy[7] << 24;
LABEL_54:
        hash_init_val1_copy += config_bytes_ptr_copy[6] << 16;
LABEL_55:
        hash_init_val1_copy += config_bytes_ptr_copy[5] << 8;
LABEL_56:
        hash_init_val1_copy += config_bytes_ptr_copy[4];
LABEL_57:
        hash_val3_copy += config_bytes_ptr_copy[3] << 24;
LABEL_58:
        hash_val3_copy += config_bytes_ptr_copy[2] << 16;
LABEL_59:
        hash_val3_copy += config_bytes_ptr_copy[1] << 8;
LABEL_60:
        hash_val3_copy += *config_bytes_ptr_copy;
        break;
      default:
        break;
    }
    *(_DWORD *)(new_miner_ptr + 28) = new_miner_ptr;
    hash_adjust_val1_copy = (hash_val3_copy - hash_init_val1_copy - final_hash_val_copy) ^ (final_hash_val_copy >> 13);
    hash_adjust_val2_copy = (hash_init_val1_copy - final_hash_val_copy - hash_adjust_val1_copy) ^ (hash_adjust_val1_copy << 8);
    hash_adjust_val3_copy = (final_hash_val_copy - hash_adjust_val1_copy - hash_adjust_val2_copy) ^ (hash_adjust_val2_copy >> 13);
    hash_adjust_val4_copy = (hash_adjust_val1_copy - hash_adjust_val2_copy - hash_adjust_val3_copy) ^ (hash_adjust_val3_copy >> 12);
    hash_adjust_val5_copy = (hash_adjust_val2_copy - hash_adjust_val3_copy - hash_adjust_val4_copy) ^ (hash_adjust_val4_copy << 16);
    hash_adjust_val6_copy = (hash_adjust_val3_copy - hash_adjust_val4_copy - hash_adjust_val5_copy) ^ (hash_adjust_val5_copy >> 5);
    hash_adjust_val7_copy = (hash_adjust_val4_copy - hash_adjust_val5_copy - hash_adjust_val6_copy) ^ (hash_adjust_val6_copy >> 3);
    hash_adjust_val_final_copy = (hash_adjust_val6_copy
                                - hash_adjust_val7_copy
                                - ((hash_adjust_val5_copy - hash_adjust_val6_copy - hash_adjust_val7_copy) ^ (hash_adjust_val7_copy << 10))) ^ (((hash_adjust_val5_copy - hash_adjust_val6_copy - hash_adjust_val7_copy) ^ (hash_adjust_val7_copy << 10)) >> 15);
    *(_DWORD *)(new_miner_ptr + 36) = hash_adjust_val_final_copy;
    current_global_mempool_ptr = dword_68188;
    *(_DWORD *)(new_miner_ptr + 32) = strlen((const char *)new_miner_ptr);
    if ( current_global_mempool_ptr )
    {
      mempool_temp_val = *(_DWORD *)(current_global_mempool_ptr + 8);
      *(_DWORD *)(new_miner_ptr + 16) = 0;
      new_miner_info_block = new_miner_ptr + 8;
      *(_DWORD *)(new_miner_ptr + 8) = mempool_temp_val;
      *(_DWORD *)(new_miner_ptr + 12) = *(_DWORD *)(*(_DWORD *)(current_global_mempool_ptr + 8) + 16)
                                      - *(_DWORD *)(*(_DWORD *)(current_global_mempool_ptr + 8) + 20);
      *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(current_global_mempool_ptr + 8) + 16) + 8) = new_miner_ptr;
      *(_DWORD *)(*(_DWORD *)(current_global_mempool_ptr + 8) + 16) = new_miner_ptr + 8;
    }
    else
    {
      *(_DWORD *)(new_miner_ptr + 16) = 0;
      *(_DWORD *)(new_miner_ptr + 12) = 0;
      dword_68188 = new_miner_ptr;
      new_mempool_ptr = malloc(44u);
      *(_DWORD *)(new_miner_ptr + 8) = new_mempool_ptr;
      if ( !new_mempool_ptr )
        goto LABEL_96;
      memset(new_mempool_ptr, 0, 44u);
      new_miner_info_block = new_miner_ptr + 8;
      *(_DWORD *)(*(_DWORD *)(new_miner_ptr + 8) + 16) = new_miner_ptr + 8;
      *(_DWORD *)(*(_DWORD *)(new_miner_ptr + 8) + 4) = 32;
      *(_DWORD *)(*(_DWORD *)(new_miner_ptr + 8) + 8) = 5;
      *(_DWORD *)(*(_DWORD *)(new_miner_ptr + 8) + 20) = 8;
      new_mempool_ptr_double = *(void ***)(new_miner_ptr + 8);
      *new_mempool_ptr_double = malloc(384u);
      new_mempool_entries_ptr = **(void ***)(new_miner_ptr + 8);
      if ( !new_mempool_entries_ptr )
        goto LABEL_96;
      memset(new_mempool_entries_ptr, 0, 384u);
      current_global_mempool_ptr = new_miner_ptr;
      *(_DWORD *)(*(_DWORD *)(new_miner_ptr + 8) + 40) = -1609490463;
    }
    ++*(_DWORD *)(*(_DWORD *)(current_global_mempool_ptr + 8) + 12);
    temporary_64bit_val = *(_QWORD *)*(_DWORD *)(current_global_mempool_ptr + 8);
    hash_table_entry_id = 12 * ((HIDWORD(temporary_64bit_val) - 1) & hash_adjust_val_final_copy);
    ++*(_DWORD *)(temporary_64bit_val + hash_table_entry_id + 4);
    LODWORD(temporary_64bit_val) = *(_DWORD *)(**(_DWORD **)(current_global_mempool_ptr + 8) + hash_table_entry_id);
    *(_DWORD *)(new_miner_ptr + 20) = 0;
    *(_DWORD *)(new_miner_ptr + 24) = temporary_64bit_val;
    LODWORD(temporary_64bit_val) = **(_DWORD **)(current_global_mempool_ptr + 8);
    previous_hash_entry = *(_DWORD *)(temporary_64bit_val + hash_table_entry_id);
    hash_table_current_slot = (int *)(temporary_64bit_val + hash_table_entry_id);
    if ( previous_hash_entry )
    {
      *(_DWORD *)(previous_hash_entry + 12) = new_miner_info_block;
      hash_table_current_slot = (int *)(**(_DWORD **)(current_global_mempool_ptr + 8) + hash_table_entry_id);
    }
    *hash_table_current_slot = new_miner_info_block;
    current_hash_count = *(_QWORD *)(**(_DWORD **)(current_global_mempool_ptr + 8) + hash_table_entry_id + 4);
    if ( (unsigned int)current_hash_count < 10 * (HIDWORD(current_hash_count) + 1) )
      goto LABEL_27;
    current_mempool_ptr = *(_DWORD *)(new_miner_ptr + 8);
    if ( *(_DWORD *)(current_mempool_ptr + 36) == 1 )
      goto LABEL_27;
    new_hash_array = calloc(24 * *(_DWORD *)(current_mempool_ptr + 4), 1u);
    if ( new_hash_array )
    {
      mempool_rehash_offset = *(_DWORD *)(new_miner_ptr + 8);
      array_index_var = 0;
      *(_DWORD *)(mempool_rehash_offset + 24) = (((2 * *(_DWORD *)(mempool_rehash_offset + 4) - 1) & *(_DWORD *)(mempool_rehash_offset + 12)) != 0)
                                              + (*(_DWORD *)(mempool_rehash_offset + 12) >> (*(_BYTE *)(mempool_rehash_offset + 8)
                                                                                           + 1));
      *(_DWORD *)(*(_DWORD *)(new_miner_ptr + 8) + 28) = 0;
      current_mempool_ptr_copy = *(_DWORD *)(new_miner_ptr + 8);
      new_hash_size = *(_DWORD *)(current_mempool_ptr_copy + 4);
      if ( new_hash_size )
      {
        for ( config_str_copy2 = 0; (unsigned int)config_str_copy2 < new_hash_size; ++config_str_copy2 )
        {
          current_hash_entry_copy = *(_DWORD **)(*(_DWORD *)current_mempool_ptr_copy + array_index_var);
          if ( current_hash_entry_copy )
          {
            hash_array_size = new_hash_size;
            while ( 1 )
            {
              next_hash_entry_copy = (_DWORD *)current_hash_entry_copy[4];
              hash_array_index = 3 * ((2 * hash_array_size - 1) & current_hash_entry_copy[7]);
              hash_entry_ptr = (char *)&new_hash_array[hash_array_index];
              hash_entry_count = *((_DWORD *)hash_entry_ptr + 1) + 1;
              *((_DWORD *)hash_entry_ptr + 1) = hash_entry_count;
              current_mempool_ptr_copy2 = *(_DWORD *)(new_miner_ptr + 8);
              if ( hash_entry_count > *(_DWORD *)(current_mempool_ptr_copy2 + 24) )
              {
                ++*(_DWORD *)(current_mempool_ptr_copy2 + 28);
                *((_DWORD *)hash_entry_ptr + 2) = calculate_miner_hashrate(
                                                    *((_DWORD *)hash_entry_ptr + 1),
                                                    *(_DWORD *)(*(_DWORD *)(new_miner_ptr + 8) + 24));
              }
              current_hash_entry_copy[3] = 0;
              current_hash_entry_copy[4] = new_hash_array[hash_array_index];
              current_hash_entry_val = new_hash_array[hash_array_index];
              if ( current_hash_entry_val )
                *(_DWORD *)(current_hash_entry_val + 12) = current_hash_entry_copy;
              new_hash_array[hash_array_index] = current_hash_entry_copy;
              current_mempool_ptr_copy = *(_DWORD *)(new_miner_ptr + 8);
              if ( !next_hash_entry_copy )
                break;
              hash_array_size = *(_DWORD *)(current_mempool_ptr_copy + 4);
              current_hash_entry_copy = next_hash_entry_copy;
            }
            new_hash_size = *(_DWORD *)(current_mempool_ptr_copy + 4);
          }
          array_index_var += 12;
        }
      }
      free(*(void **)current_mempool_ptr_copy);
      *(_DWORD *)(*(_DWORD *)(new_miner_ptr + 8) + 4) *= 2;
      ++*(_DWORD *)(*(_DWORD *)(new_miner_ptr + 8) + 8);
      **(_DWORD **)(new_miner_ptr + 8) = new_hash_array;
      mempool_entry = *(_DWORD **)(new_miner_ptr + 8);
      lassified_count = mempool_entry[7];
      hash_entry_lied_count = mempool_entry[3];
      need_resize_flag = lassified_count > hash_entry_lied_count >> 1;
      if ( lassified_count <= hash_entry_lied_count >> 1 )
        resize_val = 0;
      else
        resize_val = mempool_entry[8];
      if ( need_resize_flag )
        ++resize_val;
      mempool_entry[8] = resize_val;
      mempool_ptr = *(_DWORD *)(new_miner_ptr + 8);
      if ( *(_DWORD *)(mempool_ptr + 32) > 1u )
        *(_DWORD *)(mempool_ptr + 36) = 1;
      goto LABEL_27;
    }
LABEL_96:
    exit(-1);
  }
  while ( *(_DWORD *)(current_hash_entry + 36) != hash_adjust_val_final
       || *(_DWORD *)(current_hash_entry + 32) != remaining_len
       || memcmp(*(const void **)(current_hash_entry + 28), config_str_copy1, remaining_len) )
  {
    next_hash_entry = *(_DWORD *)(current_hash_entry + 24);
    if ( next_hash_entry )
    {
      current_hash_entry = next_hash_entry + hash_entry_offset;
      if ( current_hash_entry )
        continue;
    }
    goto LABEL_46;
  }
  updated_count = *(_DWORD *)(current_hash_entry + 4) + 1;
  *(_DWORD *)(current_hash_entry + 4) = updated_count;
  miner_info[2] = updated_count;
LABEL_27:
  if ( pthread_rwlock_wrlock(&stru_72F18) )
    log_write_lock_error("add_cgpu", 11351);
  dword_72EC0 = realloc_with_logging(dword_72EC0, 4 * (dword_72F38 + dword_6818C + 2), "cgminer.c", "add_cgpu", 11352);
  if ( pthread_rwlock_unlock(&stru_72F18) )
    log_rwlock_error_and_exit("add_cgpu", 11353);
  off_658DC(0);
  if ( pthread_mutex_lock(&stru_70CEC) )
    log_mutex_error_and_exit("add_cgpu", 11355);
  miner_info[58] = time(0);
  if ( pthread_mutex_unlock(&stru_70CEC) )
    log_mutex_unlock_error("add_cgpu", 11357);
  lock_result1 = off_658DC(0);
  if ( byte_72F68 )
    miners_count_temp = dword_6818C;
  else
    miners_count_temp = dword_72F38;
  if ( byte_72F68 )
  {
    lock_result1 = dword_72F38;
    new_miners_count = miners_count_temp + 1;
    lock_result2 = dword_72EC0;
  }
  else
  {
    new_miners_count = miners_count_temp + 1;
  }
  if ( byte_72F68 )
    dword_6818C = new_miners_count;
  else
    dword_72F38 = new_miners_count;
  if ( byte_72F68 )
    miners_count_temp += lock_result1;
  else
    lock_result2 = dword_72EC0;
  final_result = 1;
  *(_DWORD *)(lock_result2 + 4 * miners_count_temp) = miner_info;
  if ( dword_72F38 - dword_73FC4 > dword_68190 )
    dword_68190 = dword_72F38 - dword_73FC4;
  return final_result;
}
// 3B054: control flows out of bounds to 3B058
// 3B494: control flows out of bounds to 3B498
// 3B2E4: variable 'lock_result2' is possibly undefined
// 1DA28: using guessed type int sub_1DA28(void);
// 1E74C: using guessed type int __fastcall sub_1E74C(_DWORD, _DWORD, _DWORD, _DWORD);
// 1E864: using guessed type int __fastcall sub_1E864(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 2220C: using guessed type int __fastcall sub_2220C(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 2B404: using guessed type void __fastcall __noreturn sub_2B404(_DWORD, _DWORD);
// 2B460: using guessed type void __fastcall __noreturn sub_2B460(_DWORD, _DWORD);
// 2B4BC: using guessed type void __fastcall __noreturn sub_2B4BC(_DWORD, _DWORD);
// 2BFAC: using guessed type void __fastcall __noreturn sub_2BFAC(_DWORD, _DWORD);
// 48AC8: using guessed type int __fastcall sub_48AC8(_DWORD, _DWORD);
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);
// 68188: using guessed type int dword_68188;
// 6818C: using guessed type int dword_6818C;
// 68190: using guessed type int dword_68190;
// 70CEC: using guessed type pthread_mutex_t stru_70CEC;
// 72EC0: using guessed type int dword_72EC0;
// 72F18: using guessed type pthread_rwlock_t stru_72F18;
// 72F38: using guessed type int dword_72F38;
// 72F68: using guessed type char byte_72F68;
// 73FC4: using guessed type int dword_73FC4;

//----- (0003B91C) --------------------------------------------------------
_BYTE *__fastcall copy_driver_info(const void *source_driver_info)
{
  _BYTE *copied_driver_info; // r5
  _BYTE *copy_result; // r0

  copied_driver_info = (_BYTE *)safe_malloc_with_logging(120, "cgminer.c", "copy_drv", 11381);
  log_memcpy_error(copied_driver_info, source_driver_info, 120u, (int)"cgminer.c", (int)"copy_drv", 11382);
  copy_result = copied_driver_info;
  copied_driver_info[100] = 1;
  return copy_result;
}
// 1E74C: using guessed type int __fastcall sub_1E74C(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0003B980) --------------------------------------------------------
void update_system_uptime()
{
  int error_code; // r4
  char *error_message; // r0
  struct sysinfo system_info; // [sp+0h] [bp-948h] BYREF
  char uptime_message[256]; // [sp+40h] [bp-908h] BYREF
  char log_buffer[2056]; // [sp+140h] [bp-808h] BYREF

  if ( sysinfo(&system_info) )
  {
    error_code = *_errno_location();
    error_message = strerror(error_code);
    sprintf(log_buffer, "Failed to get sysinfo, errno:%u, reason:%s\n", error_code, error_message);
    dword_740EC = time(0);
    dword_7412C = dword_740EC + 1;
  }
  else
  {
    dword_740EC = system_info.uptime;
    dword_7412C = system_info.uptime + 1;
    sprintf(
      uptime_message,
      "set_start_time_point total_tv_start_sys=%ld total_tv_end_sys=%ld\n",
      system_info.uptime,
      system_info.uptime + 1);
    if ( byte_70CE8 || byte_66640 || dword_657B8 > 4 )
    {
      snprintf(log_buffer, 2048u, "%s", uptime_message);
      log_event(5, log_buffer, 0);
    }
  }
}
// 657B8: using guessed type int dword_657B8;
// 66640: using guessed type char byte_66640;
// 70CE8: using guessed type char byte_70CE8;
// 740EC: using guessed type int dword_740EC;
// 7412C: using guessed type int dword_7412C;

//----- (0003BA90) --------------------------------------------------------
unsigned int manage_pool_changes()
{
  pthread_t thread_id; // r0
  int free_memory_tracker; // r0
  int initial_pool_count; // r7
  int index_before_add; // r6
  int function_call_result; // r0
  int current_pool_count_after_add; // r3
  int pool_index_offset; // r10
  int index_during_add; // r9
  int pool_struct_addr; // r8
  int index_after_add; // r6
  int index_during_remove; // r8
  int removed_alive; // r2
  int removed_dead; // r3
  int new_total_alive_minus1; // r12
  int new_total_minus1; // r1
  int pool_to_remove_addr; // r11
  int index_during_reload; // r7
  int sleep_counter; // r6
  unsigned int sleep_result; // r0
  int continue_sleep_check; // r3
  size_t message_length; // r0
  unsigned int final_sleep_result; // r0
  int watch_pool_thread_addr; // r5
  int index_print_pool_info; // r7
  int pool_monitor_required; // [sp+18h] [bp-858h]
  pthread_attr_t thread_attributes; // [sp+24h] [bp-84Ch] BYREF
  char log_message[2088]; // [sp+48h] [bp-828h] BYREF

  thread_id = pthread_self();
  pthread_detach(thread_id);
  pthread_mutex_lock((pthread_mutex_t *)&unk_68194);
  if ( *(_DWORD *)(dword_70D18 + (dword_66AC8 << 6) + 12) )
  {
    init_completion_timeout_thread(cancel_and_destroy_thread);
    pool_monitor_required = 1;
    usleep((__useconds_t)&loc_186A0);
  }
  else
  {
    pool_monitor_required = 0;
  }
  free_memory_tracker = dword_66968;
  if ( dword_66968 )
    free((void *)dword_66968);
  initial_pool_count = dword_70DB8;
  if ( dword_70DB8 > 0 )
  {
    index_before_add = 0;
    do
    {
      if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
      {
        snprintf(
          log_message,
          2048u,
          "before add pool, pool->pool_no = %d, pool->rpc_url = %s\n",
          **(_DWORD **)(dword_70E5C + 4 * index_before_add),
          *(const char **)(*(_DWORD *)(dword_70E5C + 4 * index_before_add) + 164));
        free_memory_tracker = log_event(7, log_message, 0);
      }
      ++index_before_add;
    }
    while ( initial_pool_count != index_before_add );
  }
  function_call_result = sub_29D68(free_memory_tracker);
  current_pool_count_after_add = dword_70DB8;
  if ( dword_70DB8 == initial_pool_count )
  {
    if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
    {
      strcpy(log_message, "Input pool error, try again\n");
      log_event(3, log_message, 0);
    }
    pthread_mutex_unlock((pthread_mutex_t *)&unk_68194);
  }
  else
  {
    byte_66964 = 0;
    if ( dword_70DB8 > initial_pool_count )
    {
      pool_index_offset = 4 * initial_pool_count;
      index_during_add = initial_pool_count;
      do
      {
        pool_struct_addr = *(_DWORD *)(dword_70E5C + pool_index_offset);
        if ( *(_DWORD *)(pool_struct_addr + 100) != 1 )
          function_call_result = increment_counter_and_set_flag(pool_struct_addr + 100);
        current_pool_count_after_add = dword_70DB8;
        ++index_during_add;
        *(_BYTE *)(pool_struct_addr + 97) = 1;
        pool_index_offset += 4;
      }
      while ( current_pool_count_after_add > index_during_add );
    }
    if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
    {
      snprintf(
        log_message,
        2048u,
        "total_pools = %d, need to remove %d pools\n",
        current_pool_count_after_add,
        initial_pool_count);
      function_call_result = log_event(7, log_message, 0);
    }
    if ( dword_70DB8 > 0 )
    {
      index_after_add = 0;
      do
      {
        if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
        {
          snprintf(
            log_message,
            2048u,
            "after add pool, pool->pool_no = %d, pool->rpc_url = %s\n",
            **(_DWORD **)(dword_70E5C + 4 * index_after_add),
            *(const char **)(*(_DWORD *)(dword_70E5C + 4 * index_after_add) + 164));
          function_call_result = log_event(7, log_message, 0);
        }
        ++index_after_add;
      }
      while ( dword_70DB8 > index_after_add );
    }
    if ( initial_pool_count > 0 )
    {
      index_during_remove = 0;
      do
      {
        pool_to_remove_addr = *(_DWORD *)dword_70E5C;
        if ( pool_to_remove_addr == get_current_pool_index(function_call_result) )
          switch_pools(0);
        ++index_during_remove;
        removed_alive = dword_66ADC;
        removed_dead = dword_66AE8;
        new_total_alive_minus1 = dword_72E7C - 1;
        new_total_minus1 = dword_66AE0 - 1;
        *(_DWORD *)(pool_to_remove_addr + 100) = 0;
        dword_72E7C = new_total_alive_minus1;
        dword_66AE0 = new_total_minus1;
        dword_66ADC = removed_alive - 1;
        dword_66AE8 = removed_dead - 1;
        function_call_result = update_job_queue(pool_to_remove_addr);
      }
      while ( initial_pool_count != index_during_remove );
    }
    if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
    {
      snprintf(log_message, 2048u, "total_pools after removed = %d\n", dword_70DB8);
      function_call_result = log_event(7, log_message, 0);
    }
    if ( dword_70DB8 > 0 )
    {
      index_during_reload = 0;
      do
      {
        if ( byte_70CE8 || byte_66640 || dword_657B8 > 4 )
        {
          snprintf(
            log_message,
            2048u,
            "after reload pool, pool->pool_no = %d, pool->rpc_url = %s\n",
            **(_DWORD **)(dword_70E5C + 4 * index_during_reload),
            *(const char **)(*(_DWORD *)(dword_70E5C + 4 * index_during_reload) + 164));
          function_call_result = log_event(5, log_message, 0);
        }
        ++index_during_reload;
      }
      while ( dword_70DB8 > index_during_reload );
    }
    sleep_counter = 0;
    initialize_mining_threads(function_call_result);
    do
    {
      ++sleep_counter;
      sleep_result = sleep(1u);
      if ( sleep_counter == 8 )
        continue_sleep_check = 0;
      else
        continue_sleep_check = ((unsigned __int8)byte_66964 ^ 1) & 1;
    }
    while ( continue_sleep_check );
    update_system_uptime(sleep_result);
    thread_attributes.__align = 25970;
    if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
    {
      snprintf(log_message, 2048u, "pool change success, send %s", thread_attributes.__size);
      log_event(7, log_message, 0);
    }
    message_length = strlen(thread_attributes.__size);
    flush_api_semaphore(&thread_attributes, message_length);
    if ( byte_66964 )
    {
      dword_681AC = 1;
    }
    else
    {
      if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
      {
        strcpy(log_message, "error pool input");
        log_event(3, log_message, 0);
      }
      if ( dword_70DB8 > 0 )
      {
        index_print_pool_info = 0;
        do
        {
          if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
          {
            snprintf(
              log_message,
              2048u,
              "pool%d, url = %s, user = %s, pass = %s\n",
              **(_DWORD **)(dword_70E5C + 4 * index_print_pool_info),
              *(const char **)(*(_DWORD *)(dword_70E5C + 4 * index_print_pool_info) + 164),
              *(const char **)(*(_DWORD *)(dword_70E5C + 4 * index_print_pool_info) + 172),
              *(const char **)(*(_DWORD *)(dword_70E5C + 4 * index_print_pool_info) + 176));
            log_event(3, log_message, 0);
          }
          ++index_print_pool_info;
        }
        while ( dword_70DB8 > index_print_pool_info );
      }
    }
    dword_681B0 = 1;
    pthread_mutex_unlock((pthread_mutex_t *)&unk_68194);
  }
  if ( pool_monitor_required )
  {
    watch_pool_thread_addr = dword_70D18 + (dword_66AC8 << 6);
    pthread_attr_init(&thread_attributes);
    pthread_attr_setstacksize(&thread_attributes, 2097152u);
    if ( create_thread(watch_pool_thread_addr, &thread_attributes, monitor_mining_pool) )
    {
      strcpy(log_message, "watchpool thread create failed");
      log_event(3, log_message, 1);
      shutdown_miner(1, 0);
    }
    pthread_detach(*(_DWORD *)(watch_pool_thread_addr + 12));
  }
  final_sleep_result = sleep(1u);
  dword_66A40 = 0;
  return final_sleep_result;
}
// 3BBB4: variable 'free_memory_tracker' is possibly undefined
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 1F1A8: using guessed type int sub_1F1A8();
// 21E74: using guessed type int __fastcall sub_21E74(_DWORD, _DWORD, _DWORD);
// 22140: using guessed type int __fastcall sub_22140(_DWORD);
// 27704: using guessed type int __fastcall sub_27704(_DWORD);
// 27998: using guessed type int __fastcall sub_27998(_DWORD);
// 29530: using guessed type int __fastcall sub_29530(_DWORD);
// 29D68: using guessed type int __fastcall sub_29D68(_DWORD);
// 2AB30: using guessed type void __fastcall __noreturn sub_2AB30(_DWORD, _DWORD);
// 2E47C: using guessed type int __fastcall sub_2E47C(_DWORD);
// 3B980: using guessed type int __fastcall sub_3B980(_DWORD);
// 40E70: using guessed type int __fastcall sub_40E70(_DWORD, _DWORD);
// 657B8: using guessed type int dword_657B8;
// 66640: using guessed type char byte_66640;
// 66641: using guessed type char byte_66641;
// 66964: using guessed type char byte_66964;
// 66968: using guessed type int dword_66968;
// 66A40: using guessed type int dword_66A40;
// 66AC8: using guessed type int dword_66AC8;
// 66ADC: using guessed type int dword_66ADC;
// 66AE0: using guessed type int dword_66AE0;
// 66AE8: using guessed type int dword_66AE8;
// 681AC: using guessed type int dword_681AC;
// 681B0: using guessed type int dword_681B0;
// 70CE8: using guessed type char byte_70CE8;
// 70D18: using guessed type int dword_70D18;
// 70DB8: using guessed type int dword_70DB8;
// 70E5C: using guessed type int dword_70E5C;
// 72E7C: using guessed type int dword_72E7C;

//----- (0003C280) --------------------------------------------------------
signed int read_miner_version_file()
{
  FILE *file_handle; // r6
  signed int operation_result; // r0
  char *newline_ptr; // r7
  unsigned __int8 *byte_68640_ptr; // r4
  int copy_end_pos; // r7
  char *second_newline_ptr; // r0
  size_t str_length; // r0
  int last_char; // r3
  int pre_last_char; // r3
  bool is_carriage_return; // zf
  int error_byte_ptr; // r5
  char read_buffer[256]; // [sp+8h] [bp-918h] BYREF
  char log_buffer[2072]; // [sp+108h] [bp-818h] BYREF

  file_handle = (FILE *)fopen64(dword_66858, "rb");
  operation_result = (signed int)memset(read_buffer, 0, sizeof(read_buffer));
  if ( file_handle )
  {
    operation_result = fread(read_buffer, 1u, 256u, file_handle);
    if ( operation_result <= 0 )
    {
      error_byte_ptr = (int)&byte_70CE8;
      if ( !byte_70CE8 && !byte_66640 && dword_657B8 <= 2 )
        goto LABEL_24;
      snprintf(log_buffer, 2048u, "Read miner version file %s error %d", (const char *)dword_66858, operation_result);
      operation_result = log_event(3, log_buffer, 0);
    }
    else
    {
      newline_ptr = strchr(read_buffer, 10);
      if ( newline_ptr )
      {
        byte_68640_ptr = byte_68640;
        log_memcpy_error(byte_681B4, read_buffer, newline_ptr - read_buffer, "cgminer.c", "read_version_file", 11612);
        copy_end_pos = stpcpy(read_buffer, newline_ptr + 1);
        second_newline_ptr = strchr(read_buffer, 10);
        if ( second_newline_ptr )
          log_memcpy_error(
            byte_682B4,
            read_buffer,
            second_newline_ptr - read_buffer,
            "cgminer.c",
            "read_version_file",
            11621);
        else
          memcpy(byte_682B4, read_buffer, copy_end_pos - (_DWORD)read_buffer + 1);
      }
      else
      {
        byte_68640_ptr = byte_68640;
        strcpy(byte_681B4, read_buffer);
      }
      str_length = strlen(byte_681B4) - 1;
      last_char = byte_68640[str_length - 1164];
      if ( last_char == 10 )
      {
        byte_68640[str_length - 1164] = 0;
        str_length = strlen(byte_681B4) - 1;
        last_char = byte_68640[str_length - 1164];
      }
      if ( last_char == 13 )
        byte_68640[str_length - 1164] = 0;
      operation_result = strlen(byte_682B4) - 1;
      pre_last_char = byte_68640[operation_result - 908];
      if ( pre_last_char == 10 )
      {
        byte_68640[operation_result - 908] = 0;
        operation_result = strlen(byte_682B4) - 1;
        pre_last_char = byte_68640[operation_result - 908];
      }
      is_carriage_return = pre_last_char == 13;
      error_byte_ptr = 3304;
      if ( pre_last_char == 13 )
      {
        byte_68640_ptr = &byte_68640[operation_result];
        LOBYTE(pre_last_char) = 0;
      }
      else
      {
        HIWORD(error_byte_ptr) = 7;
      }
      if ( is_carriage_return )
      {
        HIWORD(error_byte_ptr) = 7;
        *(byte_68640_ptr - 908) = pre_last_char;
      }
    }
  }
  else
  {
    error_byte_ptr = (int)&byte_70CE8;
    if ( !byte_70CE8 && !byte_66640 && dword_657B8 <= 2 )
      goto LABEL_24;
    snprintf(log_buffer, 2048u, "Open miner version file %s error", (const char *)dword_66858);
    operation_result = log_event(3, log_buffer, 0);
  }
  if ( *(_BYTE *)error_byte_ptr || byte_66640 )
    goto LABEL_23;
LABEL_24:
  if ( dword_657B8 > 2 )
  {
LABEL_23:
    snprintf(log_buffer, 2048u, "Miner compile time: %s type: %s", byte_681B4, byte_682B4);
    return log_event(3, log_buffer, 0);
  }
  return operation_result;
}
// 1209C: using guessed type int __fastcall stpcpy(_DWORD, _DWORD);
// 1224C: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 2220C: using guessed type int __fastcall sub_2220C(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 657B8: using guessed type int dword_657B8;
// 66640: using guessed type char byte_66640;
// 66858: using guessed type int dword_66858;
// 68640: using guessed type unsigned __int8 byte_68640[245];
// 70CE8: using guessed type char byte_70CE8;

//----- (0003C5A0) --------------------------------------------------------
void load_default_config()
{
  int access_status; // r6
  const char *config_file_path; // r8
  _DWORD *config_data_start; // r0
  _DWORD *config_json_root; // r7
  _DWORD *pools_array_start; // r0
  _DWORD *pools_array_node; // r8
  int operation_result; // r5
  _DWORD *update_value_ptr; // r0
  unsigned int *ref_count_ptr; // r3
  unsigned int old_ref_count; // r2
  unsigned int new_ref_count; // r2
  unsigned int pool_index; // r9
  char *pool_config_buffer; // r11
  _DWORD *pool_node_start; // r0
  _DWORD *pool_node; // r7
  _BOOL4 is_invalid_node; // r3
  _DWORD *pool_field_data; // r0
  int field_content; // r0
  _DWORD *user_field_data; // r0
  int user_content; // r0
  _DWORD *pass_field_data; // r0
  int pass_content; // r0
  char *current_pool_config; // r5
  const char *update_value_str; // r0
  int internal_pool_index; // r9
  int user_compare_result; // r0
  const char *pass_compare_str; // r1
  int internal_pool_node; // r8
  int pool_node_ptr_val; // t1
  int num_of_pools_in_current; // [sp+14h] [bp-1234h]
  _DWORD *current_pool_node_ptr; // [sp+18h] [bp-1230h]
  char temporary_buffer[92]; // [sp+24h] [bp-1224h] BYREF
  char error_message_buffer[160]; // [sp+80h] [bp-11C8h] BYREF
  char output_buffer[2048]; // [sp+120h] [bp-1128h] BYREF
  char log_buffer[2344]; // [sp+920h] [bp-928h] BYREF

  if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
  {
    snprintf(log_buffer, 2048u, "START %s", "load_default_config_without_restart");
    log_event(7, log_buffer, 0);
  }
  if ( dword_66968 )
    free((void *)dword_66968);
  dword_66968 = safe_malloc_with_logging(4096, "cgminer.c", "load_default_config_without_restart", 11925);
  get_bmminer_config_path();
  access_status = access((const char *)dword_66968, 4);
  if ( access_status )
  {
    free((void *)dword_66968);
    dword_66968 = 0;
    return;
  }
  config_file_path = (const char *)dword_66968;
  if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
  {
    snprintf(log_buffer, 2048u, "start %s\n", "judge_load_config");
    log_event(7, log_buffer, 0);
  }
  memset(log_buffer, 0, 2304u);
  if ( config_file_path )
  {
    config_data_start = (_DWORD *)handle_file_processing(config_file_path, 0, temporary_buffer);
    config_json_root = config_data_start;
    if ( !config_data_start || *config_data_start )
    {
      if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
      {
        snprintf(
          output_buffer,
          2048u,
          "%s: JSON decode of file '%s' failed\n %s",
          "judge_load_config",
          config_file_path,
          error_message_buffer);
        log_event(3, output_buffer, 0);
      }
      return;
    }
    if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
    {
      snprintf(output_buffer, 2048u, "%s: after json_load_file\n", "judge_load_config");
      log_event(7, output_buffer, 0);
    }
    pools_array_start = (_DWORD *)validate_and_fetch_data(config_json_root, "pools");
    pools_array_node = pools_array_start;
    if ( !pools_array_start || *pools_array_start != 1 )
      goto LABEL_35;
    num_of_pools_in_current = get_next_structure_pointer(pools_array_start);
    pool_index = 0;
    pool_config_buffer = log_buffer;
    for ( current_pool_node_ptr = config_json_root;
          get_next_structure_pointer(pools_array_node) > pool_index;
          pool_config_buffer += 768 )
    {
      pool_node_start = (_DWORD *)get_task_by_index(pools_array_node, pool_index);
      pool_node = pool_node_start;
      if ( !pool_node_start )
        break;
      is_invalid_node = pool_index == 3;
      if ( *pool_node_start )
        is_invalid_node = 1;
      if ( is_invalid_node )
        break;
      pool_field_data = (_DWORD *)validate_and_fetch_data(pool_node_start, "url");
      if ( !pool_field_data )
        break;
      if ( *pool_field_data != 2 )
        break;
      field_content = get_linked_item_or_null(pool_field_data);
      snprintf(pool_config_buffer, 256u, "%s", field_content);
      user_field_data = (_DWORD *)validate_and_fetch_data(pool_node, "user");
      if ( !user_field_data )
        break;
      if ( *user_field_data != 2 )
        break;
      user_content = get_linked_item_or_null(user_field_data);
      snprintf(pool_config_buffer + 256, 256u, "%s", user_content);
      pass_field_data = (_DWORD *)validate_and_fetch_data(pool_node, "pass");
      if ( !pass_field_data || *pass_field_data != 2 )
        break;
      pass_content = get_linked_item_or_null(pass_field_data);
      snprintf(pool_config_buffer + 512, 256u, "%s", pass_content);
      if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
      {
        snprintf(
          output_buffer,
          2048u,
          "%s\n%s\n%s\n",
          pool_config_buffer,
          pool_config_buffer + 256,
          pool_config_buffer + 512);
        log_event(7, output_buffer, 0);
      }
      ++pool_index;
    }
    config_json_root = current_pool_node_ptr;
    current_pool_config = log_buffer;
    if ( num_of_pools_in_current == dword_70DB8 )
    {
      if ( num_of_pools_in_current <= 0 )
      {
LABEL_35:
        operation_result = 0;
LABEL_36:
        update_value_ptr = (_DWORD *)validate_and_fetch_data(config_json_root, &unk_51FD0);
        if ( update_value_ptr )
        {
          if ( *update_value_ptr == 2 )
          {
            update_value_str = (const char *)get_linked_item_or_null(update_value_ptr);
            update_value_ptr = (_DWORD *)strtol(update_value_str, 0, 10);
            if ( update_value_ptr != (_DWORD *)dword_66160 )
            {
              operation_result |= 2u;
              dword_66160 = (int)update_value_ptr;
            }
          }
        }
        if ( config_json_root[1] != -1 )
        {
          ref_count_ptr = config_json_root + 1;
          __dmb(11u);
          do
          {
            old_ref_count = __ldrex(ref_count_ptr);
            new_ref_count = old_ref_count - 1;
          }
          while ( __strex(new_ref_count, ref_count_ptr) );
          if ( !new_ref_count )
            update_value_ptr = (_DWORD *)process_bitmain_miner(config_json_root);
        }
        if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
        {
          snprintf(output_buffer, 2048u, "ret = 0x%x", operation_result);
          update_value_ptr = (_DWORD *)log_event(7, output_buffer, 0);
        }
        switch ( operation_result )
        {
          case 2:
            flush_api_semaphore(&dword_66160, 4);
            return;
          case 3:
            update_value_ptr = (_DWORD *)flush_api_semaphore(&dword_66160, 4);
            break;
          case 1:
            break;
          default:
            return;
        }
        initialize_pool_change_thread(update_value_ptr);
        return;
      }
      internal_pool_index = dword_70E5C - 4;
      while ( 1 )
      {
        pool_node_ptr_val = *(_DWORD *)(internal_pool_index + 4);
        internal_pool_index += 4;
        internal_pool_node = pool_node_ptr_val;
        ++access_status;
        if ( strcmp(*(const char **)(pool_node_ptr_val + 164), current_pool_config) )
          break;
        user_compare_result = strcmp(*(const char **)(internal_pool_node + 172), current_pool_config + 256);
        pass_compare_str = current_pool_config + 512;
        current_pool_config += 768;
        if ( user_compare_result || strcmp(*(const char **)(internal_pool_node + 176), pass_compare_str) )
          break;
        if ( num_of_pools_in_current == access_status )
          goto LABEL_35;
      }
    }
    operation_result = 1;
    goto LABEL_36;
  }
  if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
  {
    snprintf(output_buffer, 2048u, "%s: bad param", "judge_load_config");
    log_event(3, output_buffer, 0);
  }
}
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 1E74C: using guessed type int __fastcall sub_1E74C(_DWORD, _DWORD, _DWORD, _DWORD);
// 28284: using guessed type int __fastcall sub_28284(_DWORD);
// 29C6C: using guessed type int sub_29C6C(void);
// 40E70: using guessed type int __fastcall sub_40E70(_DWORD, _DWORD);
// 467A0: using guessed type int __fastcall sub_467A0(_DWORD, _DWORD, _DWORD);
// 472EC: using guessed type int __fastcall sub_472EC(_DWORD, _DWORD);
// 47658: using guessed type int __fastcall sub_47658(_DWORD);
// 47674: using guessed type int __fastcall sub_47674(_DWORD, _DWORD);
// 47820: using guessed type int __fastcall sub_47820(_DWORD);
// 47C24: using guessed type int __fastcall sub_47C24(_DWORD);
// 657B8: using guessed type int dword_657B8;
// 66160: using guessed type int dword_66160;
// 66640: using guessed type char byte_66640;
// 66641: using guessed type char byte_66641;
// 66968: using guessed type int dword_66968;
// 70CE8: using guessed type char byte_70CE8;
// 70DB8: using guessed type int dword_70DB8;
// 70E5C: using guessed type int dword_70E5C;
// 3C5A0: using guessed type char var_1224[92];
// 3C5A0: using guessed type char var_11C8[160];

//----- (0003CC8C) --------------------------------------------------------
char *concatenate_strings(const char *base_string, const char *append_string, ...)
{
  size_t base_length; // r5
  size_t append_length; // r0
  char *result_string; // r5

  base_length = strlen(base_string);
  append_length = strlen(append_string);
  result_string = (char *)malloc(base_length + append_length);
  sprintf(result_string, base_string, append_string);
  return result_string;
}

//----- (0003CCC8) --------------------------------------------------------
int __fastcall set_flag(_BYTE *flag_pointer)
{
  *flag_pointer = 1;
  return 0;
}

//----- (0003CCD8) --------------------------------------------------------
int __fastcall reset_first_byte_to_zero(_BYTE *byte_array)
{
  *byte_array = 0;
  return 0;
}

//----- (0003CCE8) --------------------------------------------------------
int __fastcall reset_byte(_BYTE *byte_pointer)
{
  *byte_pointer = 0;
  return 0;
}

//----- (0003CCF8) --------------------------------------------------------
int __fastcall parse_boolean_text(const char *input_string, _BYTE *output_boolean)
{
  int parse_result; // r0

  if ( !strcasecmp(input_string, "yes") || !strcasecmp(input_string, "true") )
  {
    parse_result = 0;
    *output_boolean = 1;
  }
  else if ( !strcasecmp(input_string, "no") || !strcasecmp(input_string, "false") )
  {
    parse_result = 0;
    *output_boolean = 0;
  }
  else
  {
    return format_invalid_argument_message(input_string);
  }
  return parse_result;
}
// 3D830: using guessed type int __fastcall sub_3D830(_DWORD);

//----- (0003CD8C) --------------------------------------------------------
int __fastcall toggle_boolean_based_on_text(const char *text_input, _BYTE *boolean_output)
{
  int parse_result; // r0

  parse_result = parse_boolean_text(text_input, boolean_output);
  if ( !parse_result )
    *boolean_output ^= 1u;
  return parse_result;
}

//----- (0003CDAC) --------------------------------------------------------
int __fastcall set_value(int input_value, _DWORD *output_pointer)
{
  *output_pointer = input_value;
  return 0;
}

//----- (0003CDB8) --------------------------------------------------------
int __fastcall parse_float_from_str(const char *str, _DWORD *parsed_float_ptr)
{
  int parsed_int; // s0
  int *errno_ptr; // r5
  _BYTE *end_ptr; // r3
  int result; // r0
  _BYTE *end_char_ptr; // [sp+4h] [bp-14h] BYREF

  errno_ptr = _errno_location();
  *errno_ptr = 0;
  strtof(str, &end_char_ptr);
  end_ptr = end_char_ptr;
  *parsed_float_ptr = parsed_int;
  if ( *end_ptr || !*str )
    return concatenate_strings("'%s' is not a number", str);
  result = *errno_ptr;
  if ( *errno_ptr )
    return concatenate_strings("'%s' is out of range", str);
  return result;
}
// 3CDE8: variable 'parsed_int' is possibly undefined
// 1230C: using guessed type int __fastcall strtof(_DWORD, _DWORD);
// 3CC8C: using guessed type int sub_3CC8C(const char *, ...);

//----- (0003CE40) --------------------------------------------------------
int __fastcall parse_string_to_int(const char *input_string, int *output_int)
{
  int *error_location; // r5
  int converted_value; // r0
  char *end_ptr; // r3
  int parse_result; // r0
  char *end_ptr_ref; // [sp+4h] [bp-14h] BYREF

  error_location = _errno_location();
  *error_location = 0;
  converted_value = strtol(input_string, &end_ptr_ref, 0);
  end_ptr = end_ptr_ref;
  *output_int = converted_value;
  if ( *end_ptr || !*input_string )
    return concatenate_strings("'%s' is not a number", input_string);
  parse_result = *error_location;
  if ( *error_location )
    return concatenate_strings("'%s' is out of range", input_string);
  return parse_result;
}
// 3CC8C: using guessed type int sub_3CC8C(const char *, ...);

//----- (0003CEC8) --------------------------------------------------------
int __fastcall convert_string_to_int(const char *input_str, _DWORD *output_int)
{
  int parse_result; // r0
  int parsed_int; // [sp+4h] [bp-Ch] BYREF

  parse_result = parse_string_to_int(input_str, &parsed_int);
  if ( !parse_result )
    *output_int = parsed_int;
  return parse_result;
}

//----- (0003CF90) --------------------------------------------------------
int __fastcall increment_first_element(_DWORD *array)
{
  int status; // r0

  status = 0;
  ++*array;
  return status;
}

//----- (0003CFA8) --------------------------------------------------------
void __fastcall __noreturn exit_with_message(const char *message)
{
  puts(message);
  fflush((FILE *)stdout);
  exit(0);
}
// 664F4: using guessed type int stdout;

//----- (0003CFC8) --------------------------------------------------------
void __fastcall __noreturn print_help_message_and_exit(const char *command_argument)
{
  char *help_message; // r0

  help_message = generate_help_message((const char *)dword_74250, command_argument);
  printf("%s", help_message);
  fflush((FILE *)stdout);
  exit(0);
}
// 664F4: using guessed type int stdout;
// 74250: using guessed type int dword_74250;

//----- (0003D008) --------------------------------------------------------
char *__fastcall copy_boolean_to_string(char *destination, unsigned __int8 *source_boolean)
{
  int boolean_value; // r12
  const char *boolean_string; // r1

  boolean_value = *source_boolean;
  boolean_string = "true";
  if ( !boolean_value )
    boolean_string = "false";
  return strncpy(destination, boolean_string, 80u);
}

//----- (0003D02C) --------------------------------------------------------
char *__fastcall convert_byte_to_boolean_str(char *dest, unsigned __int8 *byte_value)
{
  int byte_as_int; // r12
  const char *bool_str; // r1

  byte_as_int = *byte_value;
  bool_str = "false";
  if ( !byte_as_int )
    bool_str = "true";
  return strncpy(dest, bool_str, 80u);
}

//----- (0003D050) --------------------------------------------------------
char *__fastcall format_string_to_json(_BYTE *output_buffer, const char **input_string)
{
  size_t input_str_len; // r0
  bool is_longer_than_78; // cc
  size_t copy_len; // r5
  char *start_of_copy; // r0
  const char *source_str; // r1
  _BYTE *end_of_copy; // r4
  char *final_result; // r0

  input_str_len = strlen(*input_string);
  is_longer_than_78 = input_str_len > 78;
  copy_len = input_str_len;
  *output_buffer = 34;
  start_of_copy = output_buffer + 1;
  source_str = *input_string;
  if ( is_longer_than_78 )
  {
    final_result = strncpy(start_of_copy, source_str, 78u);
    output_buffer[79] = 34;
  }
  else
  {
    end_of_copy = &output_buffer[copy_len];
    final_result = strncpy(start_of_copy, source_str, copy_len);
    end_of_copy[1] = 34;
    if ( copy_len != 78 )
      end_of_copy[2] = 0;
  }
  return final_result;
}

//----- (0003D0B0) --------------------------------------------------------
int __fastcall format_integer_to_string(char *output_buffer, _DWORD *integer_to_format)
{
  return snprintf(output_buffer, 80u, "%i", *integer_to_format);
}

//----- (0003D0C4) --------------------------------------------------------
int __fastcall format_temperature_to_string(char *output_buffer, float *temperature)
{
  return snprintf(output_buffer, 80u, "%.1f", *temperature);
}

//----- (0003D0F0) --------------------------------------------------------
int __fastcall format_hash_rate_to_string(char *output_buffer, _DWORD *hash_rate)
{
  return snprintf(output_buffer, 80u, "%u", *hash_rate);
}

//----- (0003D104) --------------------------------------------------------
int __fastcall format_long_to_string(char *output_buffer, _DWORD *long_value)
{
  return snprintf(output_buffer, 80u, "%li", *long_value);
}

//----- (0003D118) --------------------------------------------------------
int __fastcall format_hashrate_to_string(char *output_buffer, _DWORD *hashrate_pointer)
{
  return snprintf(output_buffer, 80u, "%lu", *hashrate_pointer);
}

//----- (0003D12C) --------------------------------------------------------
const char *__fastcall get_next_valid_token(unsigned int *token_index, size_t *token_length)
{
  _DWORD *current_token; // r12
  const char *token_string; // r4
  int offset; // r4
  unsigned int index_counter; // lr

  *token_index = 0;
  if ( !dword_74244 )
    return 0;
  current_token = (_DWORD *)dword_7424C;
  if ( *(_DWORD *)(dword_7424C + 4) == 8 )
  {
    offset = 28;
    index_counter = 1;
    do
    {
      *token_index = index_counter;
      if ( dword_74244 <= index_counter++ )
        return 0;
      current_token = (_DWORD *)(dword_7424C + offset);
      offset += 28;
    }
    while ( current_token[1] == 8 );
  }
  token_string = (const char *)(*current_token + 1);
  *token_length = strcspn(token_string, "|= ");
  return token_string;
}
// 74244: using guessed type int dword_74244;
// 7424C: using guessed type int dword_7424C;

//----- (0003D1CC) --------------------------------------------------------
size_t __fastcall parse_next_token(int input_str, size_t *current_pos)
{
  int current_char; // r3
  size_t current_address; // r0
  bool is_delimiter; // zf
  size_t next_token_start; // r4

  current_char = *(unsigned __int8 *)(input_str + *current_pos);
  current_address = input_str + *current_pos;
  is_delimiter = (current_char & 0xDF) == 0;
  if ( (current_char & 0xDF) != 0 )
    is_delimiter = current_char == 61;
  if ( is_delimiter )
    return 0;
  next_token_start = current_address + 2;
  *current_pos = strcspn((const char *)(current_address + 2), "|= ");
  return next_token_start;
}

//----- (0003D214) --------------------------------------------------------
const char *__fastcall parse_config_entry(int config_buffer, unsigned int *index, size_t *entry_length)
{
  unsigned int current_index; // r3
  _DWORD *entry_pointer; // r2
  const char *parse_result; // r0
  const char *entry_text; // r4

  current_index = *index;
  if ( *index >= dword_74244 )
    return 0;
  while ( 1 )
  {
    entry_pointer = (_DWORD *)(dword_7424C + 28 * current_index);
    if ( entry_pointer[1] != 8 )
      break;
LABEL_6:
    *index = ++current_index;
    if ( current_index >= dword_74244 )
      return 0;
  }
  if ( config_buffer )
  {
    parse_result = (const char *)parse_next_token(config_buffer, entry_length);
    config_buffer = (int)parse_result;
    if ( parse_result )
      return parse_result;
    current_index = *index;
    goto LABEL_6;
  }
  entry_text = (const char *)(*entry_pointer + 1);
  *entry_length = strcspn(entry_text, "|= ");
  return entry_text;
}
// 74244: using guessed type int dword_74244;
// 7424C: using guessed type int dword_7424C;

//----- (0003D2CC) --------------------------------------------------------
_BYTE *__fastcall sub_3D2CC(const char **a1)
{
  __int64 v1; // r2
  bool v2; // cc
  _BYTE *v4; // r4
  int v5; // r0
  const char *v6; // r12
  unsigned int v7; // r3
  int v8; // r3
  bool v9; // zf
  _BYTE *result; // r0
  int status; // [sp+Ch] [bp-1Ch] BYREF

  v1 = *(_QWORD *)a1;
  v2 = (unsigned int)a1[1] > 4;
  if ( a1[1] != (const char *)4 )
    v2 = (unsigned int)(a1[1] - 1) > 1;
  if ( v2 )
    errx(1, "Option %s: unknown entry type %u", (const char *)v1, HIDWORD(v1));
  if ( !a1[6] )
    errx(1, "Option %s: description cannot be NULL", (const char *)v1);
  if ( *(_BYTE *)v1 != 45 )
    errx(1, "Option %s: does not begin with '-'", (const char *)v1);
  v4 = (_BYTE *)(v1 + 1);
  v5 = strcspn((const char *)(v1 + 1), "|= ");
  for ( status = v5; ; v5 = status )
  {
    if ( *v4 == 45 )
    {
      if ( v5 == 1 )
        errx(1, "Option %s: invalid long option '--'", *a1);
      v6 = a1[1];
      ++dword_7423C;
    }
    else
    {
      if ( v5 != 1 )
        errx(1, "Option %s: invalid short option '%.*s'", *a1, v5 + 1, v4 - 1);
      v6 = a1[1];
      v7 = (unsigned int)(v6 - 2) & 0xFFFFFFFD;
      if ( !v7 )
        v7 = dword_74248;
      ++dword_74240;
      if ( ((unsigned int)(v6 - 2) & 0xFFFFFFFD) == 0 )
        dword_74248 = v7 + 1;
    }
    if ( v6 == (const char *)1 )
    {
      v8 = (unsigned __int8)v4[v5];
      v9 = v8 == 61;
      if ( v8 != 61 )
        v9 = v8 == 32;
      if ( v9 )
        errx(1, "Option %s: does not take arguments '%s'", *a1, &v4[v5 + 1]);
    }
    result = (_BYTE *)parse_next_token(v4, &status);
    v4 = result;
    if ( !result )
      break;
  }
  return result;
}
// 3D1CC: using guessed type int __fastcall sub_3D1CC(_DWORD, _DWORD);
// 7423C: using guessed type int dword_7423C;
// 74240: using guessed type int dword_74240;
// 74248: using guessed type int dword_74248;

//----- (0003D440) --------------------------------------------------------
int __fastcall add_job_to_queue(int *job_data)
{
  char *resized_queue_ptr; // r0
  int current_job_count; // r3
  int *job_data_ptr; // lr
  char *queue_ptr; // r12
  int index_offset; // r4
  int job_data_first; // r0
  int job_data_second; // r1
  int job_data_third; // r2
  int job_data_fourth; // r3
  int *current_job_ptr; // r12
  int last_job_value; // r0
  int job_data_fifth; // r1
  int job_data_sixth; // r2

  resized_queue_ptr = (char *)realloc((void *)dword_7424C, 28 * (dword_74244 + 1));
  current_job_count = dword_74244;
  job_data_ptr = job_data;
  queue_ptr = resized_queue_ptr;
  dword_7424C = (int)resized_queue_ptr;
  ++dword_74244;
  index_offset = 7 * current_job_count;
  job_data_first = *job_data_ptr;
  job_data_second = job_data_ptr[1];
  job_data_third = job_data_ptr[2];
  job_data_fourth = job_data_ptr[3];
  job_data_ptr += 4;
  current_job_ptr = (int *)&queue_ptr[4 * index_offset];
  *current_job_ptr = job_data_first;
  current_job_ptr[1] = job_data_second;
  current_job_ptr[2] = job_data_third;
  current_job_ptr[3] = job_data_fourth;
  current_job_ptr += 4;
  last_job_value = *job_data_ptr;
  job_data_fifth = job_data_ptr[1];
  job_data_sixth = job_data_ptr[2];
  *current_job_ptr = *job_data_ptr;
  current_job_ptr[1] = job_data_fifth;
  current_job_ptr[2] = job_data_sixth;
  return last_job_value;
}
// 74244: using guessed type int dword_74244;
// 7424C: using guessed type int dword_7424C;

//----- (0003D4A4) --------------------------------------------------------
const char *__fastcall parse_config_until_dash(unsigned int *config_data, size_t *remaining_size)
{
  const char *current_token; // r0
  const char *next_position; // r0

  current_token = get_next_valid_token(config_data, remaining_size);
  if ( !current_token )
    return 0;
  while ( *current_token != 45 )
  {
    current_token = parse_config_entry((int)current_token, config_data, remaining_size);
    if ( !current_token )
      return 0;
  }
  next_position = current_token + 1;
  --*remaining_size;
  return next_position;
}

//----- (0003D4FC) --------------------------------------------------------
const char *__fastcall find_next_entry(int config_start, unsigned int *unknown_param, size_t *remaining_bytes)
{
  const char *current_ptr; // r0
  const char *next_entry_ptr; // r0

  current_ptr = parse_config_entry(config_start, unknown_param, remaining_bytes);
  if ( !current_ptr )
    return 0;
  while ( *current_ptr != 45 )
  {
    current_ptr = parse_config_entry((int)current_ptr, unknown_param, remaining_bytes);
    if ( !current_ptr )
      return 0;
  }
  next_entry_ptr = current_ptr + 1;
  --*remaining_bytes;
  return next_entry_ptr;
}

//----- (0003D554) --------------------------------------------------------
const char *__fastcall get_next_config_token(unsigned int *config_buffer)
{
  const char *next_token; // r0
  size_t token_length; // [sp+4h] [bp-14h] BYREF

  token_length = 0;
  next_token = get_next_valid_token(config_buffer, &token_length);
  if ( !next_token )
    return 0;
  while ( *next_token == 45 )
  {
    next_token = parse_config_entry((int)next_token, config_buffer, &token_length);
    if ( !next_token )
      return 0;
  }
  return next_token;
}

//----- (0003D5B4) --------------------------------------------------------
const char *__fastcall parse_config_with_dash_prefix(int config_index, unsigned int *config_data)
{
  const char *parsed_data; // r0
  size_t data_length; // [sp+4h] [bp-14h] BYREF

  data_length = 1;
  parsed_data = parse_config_entry(config_index, config_data, &data_length);
  if ( !parsed_data )
    return 0;
  while ( *parsed_data == 45 )
  {
    parsed_data = parse_config_entry((int)parsed_data, config_data, &data_length);
    if ( !parsed_data )
      return 0;
  }
  return parsed_data;
}

//----- (0003D614) --------------------------------------------------------
int __fastcall validate_and_enqueue_job(
        const char *option1,
        const char *option2,
        const char *option3,
        const char *option4,
        const char *option5,
        const char *option6,
        const char *option7)
{
  const char *options_array[9]; // [sp+4h] [bp-24h] BYREF

  options_array[1] = option2;
  options_array[0] = option1;
  options_array[2] = option3;
  options_array[3] = option4;
  options_array[4] = option5;
  options_array[5] = option6;
  options_array[6] = option7;
  validate_option_format(options_array);
  return add_job_to_queue((int *)options_array);
}

//----- (0003D658) --------------------------------------------------------
int __fastcall update_miner_config(int config_ptr, int should_add_job)
{
  int *current_config; // r4
  int job_queue_index; // r6
  int config_type; // r3
  int job_details[13]; // [sp+4h] [bp-34h] BYREF

  current_config = (int *)config_ptr;
  job_queue_index = dword_74244;
  if ( should_add_job )
  {
    job_details[0] = 0;
    memset(&job_details[2], 0, 16);
    job_details[6] = should_add_job;
    job_details[1] = 8;
    add_job_to_queue(job_details);
    config_type = current_config[1];
    if ( config_type == 16 )
    {
LABEL_7:
      config_ptr = 7 * job_queue_index;
      *(_DWORD *)(dword_7424C + 28 * job_queue_index + 20) = dword_74244 - job_queue_index;
      return config_ptr;
    }
  }
  else
  {
    config_type = *(_DWORD *)(config_ptr + 4);
    if ( config_type == 16 )
      return config_ptr;
  }
  do
  {
    if ( config_type == 8 )
    {
      config_ptr = update_miner_config(*current_config, current_config[6]);
    }
    else
    {
      validate_option_format((const char **)current_config);
      config_ptr = add_job_to_queue(current_config);
    }
    current_config += 7;
    config_type = current_config[1];
  }
  while ( config_type != 16 );
  if ( should_add_job )
    goto LABEL_7;
  return config_ptr;
}
// 74244: using guessed type int dword_74244;
// 7424C: using guessed type int dword_7424C;

//----- (0003D72C) --------------------------------------------------------
bool __fastcall validate_command_line(int argc, const char **argv, void (*logger_function)(const char *, ...))
{
  int parse_result; // r0
  int current_index; // [sp+4h] [bp-1Ch] BYREF

  dword_74250 = (int)*argv;
  current_index = 0;
  do
    parse_result = parse_command_line_option(argc, argv, &current_index, logger_function);
  while ( parse_result == 1 );
  return parse_result == 0;
}
// 74250: using guessed type int dword_74250;

//----- (0003D788) --------------------------------------------------------
void sub_3D788()
{
  free((void *)dword_7424C);
  dword_7424C = 0;
}
// 7424C: using guessed type int dword_7424C;

//----- (0003D7A8) --------------------------------------------------------
int print_error_message(const char *format, ...)
{
  va_list args; // [sp+14h] [bp-Ch] BYREF

  va_start(args, format);
  vfprintf((FILE *)stderr, format, args);
  return fputc(10, (FILE *)stderr);
}
// 664F8: using guessed type int stderr;

//----- (0003D7F0) --------------------------------------------------------
void __noreturn terminate_with_error_message(const char *error_message, ...)
{
  va_list var_args; // [sp+14h] [bp-Ch] BYREF

  va_start(var_args, error_message);
  vfprintf((FILE *)stderr, error_message, var_args);
  fputc(10, (FILE *)stderr);
  exit(1);
}
// 664F8: using guessed type int stderr;

//----- (0003D830) --------------------------------------------------------
char *__fastcall format_invalid_argument_message(const char *argument)
{
  size_t argument_length; // r0
  char *formatted_message; // r4

  argument_length = strlen(argument);
  formatted_message = (char *)malloc(argument_length + 22);
  sprintf(formatted_message, "Invalid argument '%s'", argument);
  return formatted_message;
}

//----- (0003D860) --------------------------------------------------------
void *__fastcall remove_element_from_array(_DWORD *array_length_ptr, int array_ptr, int index_to_remove)
{
  void *memmove_result; // r0

  memmove_result = memmove(
                     (void *)(array_ptr + 4 * index_to_remove),
                     (const void *)(array_ptr + 4 * index_to_remove + 4),
                     4 * (*array_length_ptr - index_to_remove));
  --*array_length_ptr;
  return memmove_result;
}

//----- (0003D898) --------------------------------------------------------
int __fastcall sub_3D898(int a1, const char **a2, int *a3, void (*a4)(const char *, ...))
{
  bool v8; // zf
  int result; // r0
  const char **v10; // r6
  const char **v11; // r3
  int v12; // r4
  int v13; // t1
  unsigned __int8 *v14; // r0
  int v15; // lr
  int v16; // r12
  int v17; // r1
  int v18; // r3
  const char *v19; // r10
  int v20; // r3
  int v21; // r1
  char *v22; // r11
  int v23; // r10
  int v24; // r0
  int *v25; // r3
  const char *v26; // r7
  int *v27; // r11
  const char *v28; // r10
  size_t v29; // r4
  size_t v30; // lr
  int *v31; // r3
  const char *v32; // r11
  size_t v33; // r0
  int *v34; // r2
  const char *v35; // r11
  const char *v36; // r3
  size_t v37; // r10
  const char *v38; // [sp+8h] [bp-38h]
  int v39; // [sp+Ch] [bp-34h]
  int v40; // [sp+10h] [bp-30h] BYREF
  size_t n[11]; // [sp+14h] [bp-2Ch] BYREF

  v8 = getenv("POSIXLY_CORRECT") == 0;
  result = (int)a2[1];
  if ( !v8 )
  {
    v10 = a2 + 1;
    if ( !result )
      return result;
    if ( *(_BYTE *)result != 45 )
      return 0;
    v12 = 1;
    if ( *(_BYTE *)(result + 1) == 45 )
      goto LABEL_23;
LABEL_15:
    v14 = (unsigned __int8 *)get_next_config_token(&v40);
    if ( v14 )
    {
      v15 = *a3 + 1;
      if ( *v14 == (unsigned __int8)(*v10)[v15] )
      {
LABEL_17:
        v16 = v40;
        v38 = (const char *)(v14 - 1);
        *a3 = v15;
        n[0] = 2;
        v17 = 28 * v16;
        v18 = dword_7424C + 28 * v16;
        if ( *(_DWORD *)(v18 + 4) != 1 )
        {
LABEL_18:
          if ( v15 )
          {
            v19 = &(*v10)[v15 + 1];
            if ( *v19 )
            {
              *a3 = 0;
              goto LABEL_20;
            }
          }
          v19 = a2[v12 + 1];
          if ( v19 )
            goto LABEL_20;
          a4("%s: %.*s: %s", *a2, n[0], v38, "requires an argument");
          return -1;
        }
LABEL_37:
        v19 = 0;
        v22 = (char *)(*(int (__fastcall **)(_DWORD))(v18 + 8))(*(_DWORD *)(v18 + 20));
        goto LABEL_38;
      }
      while ( 1 )
      {
        v14 = (unsigned __int8 *)parse_config_with_dash_prefix(v14, &v40);
        if ( !v14 )
          break;
        v15 = *a3 + 1;
        if ( (unsigned __int8)(*v10)[v15] == *v14 )
          goto LABEL_17;
      }
    }
LABEL_36:
    v33 = strlen(*v10);
    a4("%s: %.*s: %s", *a2, v33, *v10, "unrecognized option");
    return -1;
  }
  if ( !result )
    return result;
  if ( *(_BYTE *)result == 45 )
  {
    v10 = a2 + 1;
    v12 = 1;
  }
  else
  {
    v11 = a2 + 2;
    v12 = 1;
    do
    {
      v10 = v11;
      v13 = (int)*v11++;
      result = v13;
      ++v12;
      if ( !v13 )
        return result;
    }
    while ( *(_BYTE *)result != 45 );
  }
  if ( *(_BYTE *)(result + 1) != 45 )
    goto LABEL_15;
LABEL_23:
  v23 = *(unsigned __int8 *)(result + 2);
  if ( !*(_BYTE *)(result + 2) )
  {
    remove_element_from_array(a1, a2, v12);
    return v23;
  }
  if ( *a3 )
    _assert_fail("*offset == 0", "ccan/opt/parse.c", 59u, "parse_one");
  v24 = parse_config_until_dash(&v40, n);
  if ( !v24 )
    goto LABEL_36;
  v25 = a3;
  v26 = (const char *)v24;
  v27 = v25;
  v39 = v12;
  while ( 1 )
  {
    v28 = *v10;
    v29 = n[0];
    if ( strncmp(*v10 + 2, v26, n[0]) )
      goto LABEL_35;
    v30 = v29 + 2;
    if ( v28[v29 + 2] == 61 )
      break;
    if ( !v28[v29 + 2] )
    {
      v16 = v40;
      v31 = v27;
      v32 = v26;
      a3 = v31;
      v12 = v39;
      v38 = v32 - 2;
      v17 = 28 * v40;
      n[0] = v30;
      v18 = dword_7424C + 28 * v40;
      if ( *(_DWORD *)(v18 + 4) == 1 )
        goto LABEL_37;
      goto LABEL_34;
    }
LABEL_35:
    v26 = (const char *)find_next_entry(v26, &v40, n);
    if ( !v26 )
      goto LABEL_36;
  }
  v16 = v40;
  v34 = v27;
  v35 = v26;
  a3 = v34;
  v36 = v28;
  v37 = v29 + 3;
  v12 = v39;
  v17 = 28 * v40;
  v19 = &v36[v37];
  n[0] = v30;
  v38 = v35 - 2;
  v18 = dword_7424C + 28 * v40;
  if ( *(_DWORD *)(v18 + 4) == 1 )
  {
    if ( v19 )
    {
      a4("%s: %.*s: %s", *a2, v30, v38, "doesn't allow an argument");
      return -1;
    }
    goto LABEL_37;
  }
  if ( !v19 )
  {
LABEL_34:
    v15 = *a3;
    goto LABEL_18;
  }
LABEL_20:
  v20 = dword_7424C;
  v21 = dword_7424C + v17;
  if ( *(_DWORD *)(v21 + 4) == 4 )
  {
    set_value(v19, *(_DWORD *)(v21 + 20), &dword_7424C, dword_7424C);
    v16 = v40;
    v20 = dword_7424C;
  }
  v22 = (char *)(*(int (__fastcall **)(const char *, _DWORD))(v20 + 28 * v16 + 12))(
                  v19,
                  *(_DWORD *)(v20 + 28 * v16 + 20));
LABEL_38:
  if ( v22 )
  {
    a4("%s: %.*s: %s", *a2, n[0], v38, v22);
    free(v22);
    return -1;
  }
  else
  {
    if ( *a3 )
    {
      if ( !(*v10)[*a3 + 1] )
      {
        *a3 = 0;
        goto LABEL_42;
      }
    }
    else
    {
LABEL_42:
      remove_element_from_array(a1, a2, v12);
      if ( v19 )
      {
        if ( *v10 == v19 )
          remove_element_from_array(a1, a2, v12);
      }
    }
    return 1;
  }
}
// 3CDAC: using guessed type int __fastcall sub_3CDAC(_DWORD, _DWORD, _DWORD, _DWORD);
// 3D4A4: using guessed type int __fastcall sub_3D4A4(_DWORD, _DWORD);
// 3D4FC: using guessed type int __fastcall sub_3D4FC(_DWORD, _DWORD, _DWORD);
// 3D554: using guessed type int __fastcall sub_3D554(_DWORD);
// 3D5B4: using guessed type int __fastcall sub_3D5B4(_DWORD, _DWORD);
// 3D860: using guessed type int __fastcall sub_3D860(_DWORD, _DWORD, _DWORD);
// 7424C: using guessed type int dword_7424C;

//----- (0003DD48) --------------------------------------------------------
char *__fastcall generate_help_message(const char *executable_name, const char *specific_option)
{
  size_t required_buffer_size; // r7
  int option_index; // r4
  unsigned int parsed_options_count; // r8
  size_t option_name_length; // r7
  size_t incremental_length_with_option; // r0
  size_t total_length_with_defaults; // r7
  size_t base_length; // r5
  const char *current_option_str; // r11
  char *allocated_buffer; // r0
  char *help_msg_builder; // r4
  int written_length; // r0
  char *builder_ptr; // r1
  char *current_position; // r4
  char *options_start; // r7
  char *option_short_name; // r12
  int option_char_count; // r8
  int sprintf_return; // r0
  int options_count; // r2
  char *current_line_start; // r5
  int option_offset; // r7
  unsigned int option_iteration; // r8
  int padding_count; // r2
  unsigned int line_length_before_desc; // r4
  unsigned int line_length; // r4
  char *default_val_position; // r3
  int current_option_data_offset; // r3
  const char *current_option_description; // r2
  int name_length; // r0
  unsigned int arg_length; // r4
  char *arg_position; // r3
  char *space_char_check; // r0
  char *equals_char_check; // r0
  int null_options_count; // r2
  int null_option_index; // r3
  char *newline; // [sp+0h] [bp-98h]
  const char *parsed_specific_option; // [sp+4h] [bp-94h]
  char *current_option_chars; // [sp+8h] [bp-90h]
  char *arg_required_position; // [sp+10h] [bp-88h]
  char *help_msg; // [sp+14h] [bp-84h]
  int processed_options[31]; // [sp+1Ch] [bp-7Ch] BYREF

  required_buffer_size = dword_74240 + 20 + strlen(executable_name);
  if ( specific_option )
  {
    required_buffer_size += strlen(specific_option);
    if ( !dword_74244 )
      goto LABEL_13;
    option_index = dword_7424C;
  }
  else
  {
    if ( !dword_74244 )
    {
      specific_option = "";
      goto LABEL_13;
    }
    null_options_count = 0;
    option_index = dword_7424C;
    null_option_index = dword_7424C;
    do
    {
      ++null_options_count;
      if ( *(void (__noreturn **)())(null_option_index + 8) == print_help_message_and_exit )
      {
        specific_option = *(const char **)(null_option_index + 20);
        if ( specific_option )
        {
          required_buffer_size += strlen(*(const char **)(null_option_index + 20));
          goto LABEL_4;
        }
      }
      null_option_index += 28;
    }
    while ( null_options_count != dword_74244 );
    specific_option = "";
  }
LABEL_4:
  parsed_options_count = 0;
  parsed_specific_option = specific_option;
  do
  {
    while ( 1 )
    {
      base_length = required_buffer_size + 6;
      current_option_str = *(const char **)(option_index + 24);
      if ( *(_DWORD *)(option_index + 4) != 8 )
        break;
      ++parsed_options_count;
      required_buffer_size += strlen(*(const char **)(option_index + 24)) + 3;
      option_index += 28;
      if ( parsed_options_count >= dword_74244 )
        goto LABEL_12;
    }
    if ( current_option_str != (const char *)&unk_74254 )
    {
      option_name_length = strlen(*(const char **)option_index);
      incremental_length_with_option = option_name_length + base_length + strlen(current_option_str);
      total_length_with_defaults = incremental_length_with_option + 118;
      if ( !*(_DWORD *)(option_index + 16) )
        total_length_with_defaults = incremental_length_with_option + 21;
      required_buffer_size = total_length_with_defaults + 1;
    }
    ++parsed_options_count;
    option_index += 28;
  }
  while ( parsed_options_count < dword_74244 );
LABEL_12:
  specific_option = parsed_specific_option;
LABEL_13:
  allocated_buffer = (char *)malloc(required_buffer_size);
  help_msg_builder = allocated_buffer;
  help_msg = allocated_buffer;
  if ( allocated_buffer )
  {
    written_length = sprintf(allocated_buffer, "Usage: %s", executable_name);
    builder_ptr = help_msg_builder;
    current_position = &help_msg_builder[written_length];
    options_start = current_position + 3;
    strcpy(&builder_ptr[written_length], " [-");
    option_short_name = (char *)get_next_config_token(processed_options);
    if ( option_short_name )
    {
      option_char_count = 0;
      do
      {
        if ( *(_UNKNOWN **)(dword_7424C + 28 * processed_options[0] + 24) != &unk_74254 )
          options_start[option_char_count++] = *option_short_name;
        option_short_name = (char *)parse_config_with_dash_prefix(option_short_name, processed_options);
      }
      while ( option_short_name );
      if ( option_char_count )
      {
        current_position = &options_start[option_char_count + 1];
        *(_WORD *)&options_start[option_char_count] = 93;
      }
    }
    sprintf_return = sprintf(current_position, " %s", specific_option);
    options_count = dword_74244;
    newline = "\n";
    current_line_start = &current_position[sprintf_return + 1];
    strcpy(&current_position[sprintf_return], "\n");
    if ( options_count )
    {
      option_offset = 0;
      option_iteration = 0;
      do
      {
        current_option_data_offset = dword_7424C + option_offset;
        current_option_description = *(const char **)(dword_7424C + option_offset + 24);
        if ( current_option_description != (const char *)&unk_74254 )
        {
          if ( *(_DWORD *)(current_option_data_offset + 4) == 8 )
          {
            current_line_start += sprintf(current_line_start, "%s:\n", current_option_description);
          }
          else
          {
            name_length = sprintf(current_line_start, "%s", *(const char **)current_option_data_offset);
            arg_length = name_length;
            arg_position = &current_line_start[name_length];
            if ( *(_DWORD *)(dword_7424C + option_offset + 4) == 2 )
            {
              arg_required_position = &current_line_start[name_length];
              current_option_chars = *(char **)(dword_7424C + option_offset);
              space_char_check = strchr(current_option_chars, 32);
              arg_position = arg_required_position;
              if ( !space_char_check )
              {
                equals_char_check = strchr(current_option_chars, 61);
                arg_position = arg_required_position;
                if ( !equals_char_check )
                {
                  arg_length += 6;
                  strcpy(arg_required_position, " <arg>");
                  arg_position = &current_line_start[arg_length];
                }
              }
            }
            if ( arg_length > 19 )
              padding_count = 1;
            else
              padding_count = 20 - arg_length;
            line_length_before_desc = sprintf(arg_position, "%.*s", padding_count, "                    ", newline)
                                    + arg_length;
            line_length = sprintf(
                            &current_line_start[line_length_before_desc],
                            "%s",
                            *(const char **)(dword_7424C + option_offset + 24))
                        + line_length_before_desc;
            default_val_position = &current_line_start[line_length];
            if ( *(_DWORD *)(dword_7424C + option_offset + 16) )
            {
              processed_options[20] = 3026478;
              (*(void (__fastcall **)(int *, _DWORD))(dword_7424C + option_offset + 16))(
                processed_options,
                *(_DWORD *)(dword_7424C + option_offset + 20));
              default_val_position = &current_line_start[sprintf(
                                                           &current_line_start[line_length],
                                                           " (default: %s)",
                                                           (const char *)processed_options)
                                                       + line_length];
            }
            *(_WORD *)default_val_position = *(_WORD *)newline;
            current_line_start = default_val_position + 1;
          }
        }
        ++option_iteration;
        option_offset += 28;
      }
      while ( dword_74244 > option_iteration );
    }
    *current_line_start = 0;
  }
  return help_msg;
}
// 3DF74: variable 'newline' is possibly undefined
// 3CFC8: using guessed type void __noreturn sub_3CFC8();
// 3D554: using guessed type int __fastcall sub_3D554(_DWORD);
// 3D5B4: using guessed type int __fastcall sub_3D5B4(_DWORD, _DWORD);
// 5434C: using guessed type __int16 word_5434C;
// 74240: using guessed type int dword_74240;
// 74244: using guessed type int dword_74244;
// 7424C: using guessed type int dword_7424C;

//----- (0003E18C) --------------------------------------------------------
char *__fastcall find_character(char *current_position, __int16 target_char, unsigned int length)
{
  char *next_position; // r3
  int search_mask; // r4
  char *aligned_position; // r12
  char *end_position; // r2
  char *next_char_position; // r3

  if ( !length )
    return 0;
  if ( ((unsigned __int8)current_position & 3) != 0 )
  {
    if ( (unsigned __int8)*current_position == (unsigned __int8)target_char )
      return current_position;
    next_position = current_position + 1;
    while ( 1 )
    {
      --length;
      current_position = next_position;
      if ( !length )
        return 0;
      if ( ((unsigned __int8)next_position++ & 3) == 0 )
        break;
      if ( (unsigned __int8)*current_position == (unsigned __int8)target_char )
        return current_position;
    }
  }
  search_mask = (unsigned __int16)(target_char << 8) | (unsigned __int8)target_char | (((unsigned __int16)(target_char << 8) | (unsigned __int8)target_char) << 16);
  if ( length > 3
    && (((*(_DWORD *)current_position ^ search_mask) - 16843009) & ~(*(_DWORD *)current_position ^ search_mask) & 0x80808080) == 0 )
  {
    aligned_position = current_position + 4;
    while ( 1 )
    {
      length -= 4;
      current_position = aligned_position;
      aligned_position += 4;
      if ( length <= 3 )
        break;
      if ( (((*(_DWORD *)current_position ^ search_mask) - 16843009) & ~(*(_DWORD *)current_position ^ search_mask) & 0x80808080) != 0 )
        goto LABEL_16;
    }
    if ( !length )
      return 0;
  }
LABEL_16:
  if ( (unsigned __int8)*current_position != (unsigned __int8)target_char )
  {
    end_position = &current_position[length];
    next_char_position = current_position + 1;
    while ( 1 )
    {
      current_position = next_char_position++;
      if ( current_position == end_position )
        break;
      if ( (unsigned __int8)*current_position == (unsigned __int8)target_char )
        return current_position;
    }
    return 0;
  }
  return current_position;
}

//----- (0003E2A0) --------------------------------------------------------
unsigned int __fastcall sub_3E2A0(int a1, unsigned int a2, int *a3)
{
  int v3; // r6
  int v4; // r12
  unsigned int v5; // r4
  int v6; // lr
  unsigned int v7; // r3
  int v8; // r5
  unsigned int v9; // r5
  unsigned int v10; // r7
  int v11; // r8
  unsigned int v12; // r4
  int v13; // r12
  int v14; // r5
  unsigned int v15; // r3
  int v16; // r6
  unsigned int v17; // r6
  unsigned int v18; // r7
  unsigned int result; // r0
  unsigned int v20; // r5
  bool v21; // zf

  v3 = 1;
  v4 = 1;
  v5 = 0;
  v6 = -1;
  while ( 1 )
  {
    v7 = v4 + v5;
    v8 = a1 + v6;
    if ( v4 + v5 >= a2 )
      break;
    while ( 1 )
    {
      v9 = *(unsigned __int8 *)(v8 + v4);
      v10 = *(unsigned __int8 *)(a1 + v7);
      if ( v10 >= v9 )
        break;
      v5 = v7;
      v4 = 1;
      v3 = v7 - v6;
      ++v7;
      v8 = a1 + v6;
      if ( v7 >= a2 )
        goto LABEL_5;
    }
    if ( v10 == v9 )
    {
      v21 = v4++ == v3;
      if ( v21 )
      {
        v5 = v7;
        v4 = 1;
      }
    }
    else
    {
      v3 = 1;
      v6 = v5;
      v4 = 1;
      ++v5;
    }
  }
LABEL_5:
  v11 = 1;
  v12 = 0;
  v13 = 1;
  v14 = -1;
  *a3 = v3;
  while ( 1 )
  {
    v15 = v13 + v12;
    v16 = a1 + v14;
    if ( a2 <= v13 + v12 )
      break;
    while ( 1 )
    {
      v17 = *(unsigned __int8 *)(v16 + v13);
      v18 = *(unsigned __int8 *)(a1 + v15);
      if ( v18 <= v17 )
        break;
      v12 = v15;
      v13 = 1;
      v11 = v15 - v14;
      ++v15;
      v16 = a1 + v14;
      if ( a2 <= v15 )
        goto LABEL_9;
    }
    if ( v18 == v17 )
    {
      v21 = v13++ == v11;
      if ( v21 )
      {
        v12 = v15;
        v13 = 1;
      }
    }
    else
    {
      v11 = 1;
      v14 = v12;
      v13 = 1;
      ++v12;
    }
  }
LABEL_9:
  result = v6 + 1;
  v20 = v14 + 1;
  if ( v20 >= v6 + 1 )
  {
    *a3 = v11;
    return v20;
  }
  return result;
}

//----- (0003E3B0) --------------------------------------------------------
unsigned int __fastcall find_matching_sequence(
        int start_position,
        int end_position,
        void *sequence,
        unsigned int sequence_length)
{
  unsigned int sequence_end_index; // r4
  unsigned int optimal_divide_index; // r6
  int *current_pointer; // r3
  char *sequence_pointer; // r1
  int current_index; // r3
  int current_byte; // t1
  unsigned int memcmp_result; // r0
  unsigned int current_offset; // r3
  bool comparison_flag; // cf
  unsigned int next_index; // r1
  unsigned int max_index; // r1
  char *sequence_compare_point; // lr
  unsigned __int8 *current_compare_point; // r12
  int byte_value_seq; // r9
  int byte_from_seq; // t1
  int byte_from_current_pos; // t1
  unsigned int compare_limit; // lr
  unsigned __int8 *compare_pointer; // r1
  char *decrementing_seq_ptr; // r8
  int decremented_byte_seq; // r10
  int dec_byte_from_seq; // t1
  int dec_byte_from_cur_pos; // t1
  unsigned int result_position; // r0
  unsigned int min_half_length; // r3
  unsigned int divide_index_minus_one; // r2
  unsigned int search_limit; // r10
  unsigned int offset_counter; // r9
  int next_offset; // r3
  unsigned __int8 *divide_compare_pointer; // r1
  unsigned int new_limit; // r3
  char *decr_sequence_pointer; // r12
  int decr_seq_byte_value; // r8
  int decr_byte_from_seq; // t1
  int decr_byte_from_cur_pos; // t1
  unsigned __int8 *back_compare_pointer; // r3
  char *backwards_seq_pointer; // r1
  int byte_value_backwards_seq; // lr
  int back_byte_from_seq; // t1
  int back_byte_from_cur_pos; // t1
  unsigned int start_search_position; // [sp+0h] [bp-448h]
  unsigned int first_part_length; // [sp+4h] [bp-444h]
  int extended_limit; // [sp+4h] [bp-444h]
  unsigned int second_part_length; // [sp+Ch] [bp-43Ch]
  int index_array[253]; // [sp+1Ch] [bp-42Ch] BYREF
  int array_end_marker; // [sp+41Ch] [bp-2Ch] BYREF

  sequence_end_index = sequence_length - 1;
  if ( sequence_length > 2 )
  {
    optimal_divide_index = find_optimal_split_index((int)sequence, sequence_length, index_array);
    first_part_length = index_array[0];
  }
  else
  {
    optimal_divide_index = sequence_length - 1;
    first_part_length = 1;
    index_array[0] = 1;
  }
  current_pointer = index_array;
  do
  {
    current_pointer[1] = sequence_length;
    ++current_pointer;
  }
  while ( current_pointer != &array_end_marker );
  if ( sequence_length )
  {
    sequence_pointer = (char *)sequence - 1;
    current_index = sequence_end_index;
    do
    {
      current_byte = (unsigned __int8)*++sequence_pointer;
      index_array[current_byte + 1] = current_index;
      comparison_flag = current_index-- != 0;
    }
    while ( comparison_flag );
  }
  memcmp_result = memcmp(sequence, (char *)sequence + first_part_length, optimal_divide_index);
  if ( !memcmp_result )
  {
    start_search_position = end_position - sequence_length;
    second_part_length = sequence_length - first_part_length;
    current_offset = 0;
    while ( 1 )
    {
      while ( 1 )
      {
        next_index = index_array[*(unsigned __int8 *)(start_position + current_offset + sequence_end_index) + 1];
        if ( next_index )
        {
          comparison_flag = 1;
          if ( memcmp_result )
            comparison_flag = next_index >= first_part_length;
          memcmp_result = 0;
          if ( !comparison_flag )
            next_index = second_part_length;
          current_offset += next_index;
          goto LABEL_15;
        }
        max_index = optimal_divide_index < memcmp_result ? memcmp_result : optimal_divide_index;
        if ( max_index < sequence_end_index )
          break;
LABEL_25:
        compare_limit = optimal_divide_index - 1;
        if ( optimal_divide_index > memcmp_result
          && (compare_pointer = (unsigned __int8 *)(start_position + optimal_divide_index - 1 + current_offset),
              *((unsigned __int8 *)sequence + optimal_divide_index - 1) == *compare_pointer) )
        {
          decrementing_seq_ptr = (char *)sequence + optimal_divide_index - 1;
          while ( compare_limit - 1 != memcmp_result - 1 )
          {
            dec_byte_from_seq = (unsigned __int8)*--decrementing_seq_ptr;
            decremented_byte_seq = dec_byte_from_seq;
            dec_byte_from_cur_pos = *--compare_pointer;
            if ( decremented_byte_seq != dec_byte_from_cur_pos )
              break;
            --compare_limit;
          }
        }
        else
        {
          compare_limit = optimal_divide_index;
        }
        if ( memcmp_result + 1 > compare_limit )
          return start_position + current_offset;
        memcmp_result = second_part_length;
        current_offset += first_part_length;
        if ( start_search_position < current_offset )
          return 0;
      }
      sequence_compare_point = (char *)sequence + max_index;
      current_compare_point = (unsigned __int8 *)(start_position + max_index + current_offset);
      if ( *current_compare_point == *((unsigned __int8 *)sequence + max_index) )
      {
        while ( ++max_index < sequence_end_index )
        {
          byte_from_seq = (unsigned __int8)*++sequence_compare_point;
          byte_value_seq = byte_from_seq;
          byte_from_current_pos = *++current_compare_point;
          if ( byte_value_seq != byte_from_current_pos )
            goto LABEL_35;
        }
        goto LABEL_25;
      }
LABEL_35:
      memcmp_result = 0;
      current_offset += max_index + 1 - optimal_divide_index;
LABEL_15:
      if ( start_search_position < current_offset )
        return 0;
    }
  }
  min_half_length = sequence_length - optimal_divide_index;
  divide_index_minus_one = optimal_divide_index - 1;
  search_limit = end_position - sequence_length;
  if ( sequence_length - optimal_divide_index < optimal_divide_index )
    min_half_length = optimal_divide_index;
  offset_counter = 0;
  extended_limit = min_half_length + 1;
  while ( 1 )
  {
    result_position = start_position + offset_counter;
    next_offset = index_array[*(unsigned __int8 *)(start_position + offset_counter + sequence_end_index) + 1];
    if ( !next_offset )
      break;
LABEL_52:
    offset_counter += next_offset;
LABEL_53:
    if ( offset_counter > search_limit )
      return 0;
  }
  if ( optimal_divide_index < sequence_end_index )
  {
    divide_compare_pointer = (unsigned __int8 *)(start_position + optimal_divide_index + offset_counter);
    if ( *divide_compare_pointer != *((unsigned __int8 *)sequence + optimal_divide_index) )
    {
      new_limit = optimal_divide_index;
LABEL_55:
      offset_counter += new_limit + 1 - optimal_divide_index;
      goto LABEL_53;
    }
    decr_sequence_pointer = (char *)sequence + optimal_divide_index;
    new_limit = optimal_divide_index;
    while ( ++new_limit < sequence_end_index )
    {
      decr_byte_from_seq = (unsigned __int8)*++decr_sequence_pointer;
      decr_seq_byte_value = decr_byte_from_seq;
      decr_byte_from_cur_pos = *++divide_compare_pointer;
      if ( decr_seq_byte_value != decr_byte_from_cur_pos )
        goto LABEL_55;
    }
  }
  if ( !optimal_divide_index )
    return result_position;
  back_compare_pointer = (unsigned __int8 *)(start_position + divide_index_minus_one + offset_counter);
  if ( *back_compare_pointer != *((unsigned __int8 *)sequence + divide_index_minus_one) )
  {
LABEL_51:
    next_offset = extended_limit;
    goto LABEL_52;
  }
  backwards_seq_pointer = (char *)sequence + divide_index_minus_one;
  while ( backwards_seq_pointer != sequence )
  {
    back_byte_from_seq = (unsigned __int8)*--backwards_seq_pointer;
    byte_value_backwards_seq = back_byte_from_seq;
    back_byte_from_cur_pos = *--back_compare_pointer;
    if ( byte_value_backwards_seq != back_byte_from_cur_pos )
      goto LABEL_51;
  }
  return result_position;
}

//----- (0003E6DC) --------------------------------------------------------
unsigned int __fastcall memmem(char *a1, unsigned int a2, unsigned __int8 *a3, unsigned int a4)
{
  char *v6; // r5
  char *character; // r0
  _BOOL4 v10; // r3
  unsigned int v11; // r7
  unsigned int optimal_split_index; // r6
  unsigned int v13; // r0
  unsigned int v14; // r2
  unsigned int v15; // r12
  unsigned int v16; // r3
  unsigned __int8 *v17; // lr
  char *v18; // r1
  int v19; // r8
  int v20; // t1
  int v21; // t1
  unsigned int v22; // lr
  char *v23; // r3
  unsigned __int8 *v24; // r7
  int v25; // r9
  int v26; // t1
  int v27; // t1
  unsigned int v29; // r3
  unsigned int v30; // r9
  unsigned int v31; // r0
  unsigned int v32; // r7
  char *v33; // r2
  unsigned int v34; // r3
  unsigned __int8 *v35; // r1
  int v36; // lr
  int v37; // t1
  int v38; // t1
  char *v39; // r3
  unsigned __int8 *v40; // r2
  int v41; // r12
  int v42; // t1
  int v43; // t1
  int v44; // [sp+4h] [bp-44h]
  int v45; // [sp+8h] [bp-40h]
  int v46; // [sp+1Ch] [bp-2Ch] BYREF

  if ( !a4 )
    return (unsigned int)a1;
  if ( a4 > a2 )
    return 0;
  if ( a4 > 31 )
    return find_matching_sequence((int)a1, a2, a3, a4);
  character = find_character(a1, *a3, a2);
  v6 = character;
  v10 = a4 == 1;
  if ( !character )
    v10 = 1;
  if ( v10 )
    return (unsigned int)v6;
  v11 = a2 - (character - a1);
  if ( a4 > v11 )
    return 0;
  if ( a4 > 2 )
  {
    optimal_split_index = find_optimal_split_index((int)a3, a4, &v46);
    v45 = v46;
  }
  else
  {
    optimal_split_index = a4 - 1;
    v45 = 1;
    v46 = 1;
  }
  v13 = memcmp(a3, &a3[v45], optimal_split_index);
  if ( !v13 )
  {
    v14 = v11 - a4;
    v15 = 0;
    while ( 1 )
    {
      if ( optimal_split_index < v15 )
        v16 = v15;
      else
        v16 = optimal_split_index;
      if ( a4 > v16 )
      {
        v17 = &a3[v16];
        v18 = &v6[v16 + v13];
        if ( a3[v16] != (unsigned __int8)*v18 )
        {
LABEL_32:
          v15 = 0;
          v13 += 1 - optimal_split_index + v16;
          goto LABEL_29;
        }
        while ( a4 != ++v16 )
        {
          v20 = *++v17;
          v19 = v20;
          v21 = (unsigned __int8)*++v18;
          if ( v19 != v21 )
            goto LABEL_32;
        }
      }
      v22 = optimal_split_index - 1;
      if ( optimal_split_index > v15
        && (v23 = &v6[optimal_split_index - 1 + v13], a3[optimal_split_index - 1] == (unsigned __int8)*v23) )
      {
        v24 = &a3[optimal_split_index - 1];
        while ( v22 - 1 != v15 - 1 )
        {
          v26 = *--v24;
          v25 = v26;
          v27 = (unsigned __int8)*--v23;
          if ( v25 != v27 )
            break;
          --v22;
        }
      }
      else
      {
        v22 = optimal_split_index;
      }
      if ( v15 + 1 > v22 )
      {
        v6 += v13;
        return (unsigned int)v6;
      }
      v15 = a4 - v45;
      v13 += v45;
LABEL_29:
      if ( v14 < v13 )
        return 0;
    }
  }
  v29 = a4 - optimal_split_index;
  v30 = optimal_split_index - 1;
  v31 = v11 - a4;
  if ( a4 - optimal_split_index < optimal_split_index )
    v29 = optimal_split_index;
  v32 = 0;
  v44 = v29 + 1;
  while ( 1 )
  {
    if ( a4 > optimal_split_index )
    {
      v33 = &v6[optimal_split_index + v32];
      if ( (unsigned __int8)*v33 != a3[optimal_split_index] )
      {
        v34 = optimal_split_index;
LABEL_49:
        v32 += 1 - optimal_split_index + v34;
        goto LABEL_50;
      }
      v35 = &a3[optimal_split_index];
      v34 = optimal_split_index;
      while ( a4 != ++v34 )
      {
        v37 = *++v35;
        v36 = v37;
        v38 = (unsigned __int8)*++v33;
        if ( v36 != v38 )
          goto LABEL_49;
      }
    }
    if ( !optimal_split_index )
      return (unsigned int)&v6[v32];
    v39 = &v6[v30 + v32];
    if ( (unsigned __int8)*v39 == a3[v30] )
      break;
LABEL_52:
    v32 += v44;
LABEL_50:
    if ( v31 < v32 )
      return 0;
  }
  v40 = &a3[v30];
  while ( v40 != a3 )
  {
    v42 = *--v40;
    v41 = v42;
    v43 = (unsigned __int8)*--v39;
    if ( v41 != v43 )
      goto LABEL_52;
  }
  return (unsigned int)&v6[v32];
}

//----- (0003E9C8) --------------------------------------------------------
_DWORD *__fastcall decrement_and_process_if_zero(_DWORD *counter_ptr)
{
  unsigned int *counter_next_ptr; // r3
  unsigned int current_value; // r2
  unsigned int decremented_value; // r2

  counter_next_ptr = counter_ptr + 1;
  __dmb(11u);
  do
  {
    current_value = __ldrex(counter_next_ptr);
    decremented_value = current_value - 1;
  }
  while ( __strex(decremented_value, counter_next_ptr) );
  if ( !decremented_value )
    return process_bitmain_miner(counter_ptr);
  return counter_ptr;
}

//----- (0003E9F0) --------------------------------------------------------
int __fastcall process_nonce_submission(unsigned __int8 *nonce_data, int nonce_size)
{
  int first_byte; // r8
  int second_int; // r7
  size_t first_chunk_size; // r10
  void *first_chunk_alloc; // r0
  void *first_chunk_copy; // r0
  size_t second_chunk_size; // r9
  unsigned __int8 *second_chunk_start; // r4
  void *second_chunk_alloc; // r0
  void *second_chunk_copy; // r0
  size_t third_chunk_size; // r10
  void *third_chunk_alloc; // r0
  int process_buffer[112]; // [sp+0h] [bp-9E0h] BYREF
  char log_message[2080]; // [sp+1C0h] [bp-820h] BYREF

  if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
  {
    snprintf(log_message, 2048u, "got nonce sz %d", nonce_size);
    log_event(7, log_message, 0);
  }
  first_byte = *nonce_data;
  second_int = *(_DWORD *)(nonce_data + 1);
  memcpy(process_buffer, nonce_data + 5, sizeof(process_buffer));
  first_chunk_size = nonce_data[453];
  first_chunk_alloc = calloc(1u, first_chunk_size);
  first_chunk_copy = memcpy(first_chunk_alloc, nonce_data + 454, first_chunk_size);
  second_chunk_size = nonce_data[first_chunk_size + 454];
  second_chunk_start = &nonce_data[first_chunk_size + 455];
  process_buffer[72] = (int)first_chunk_copy;
  second_chunk_alloc = calloc(1u, second_chunk_size);
  second_chunk_copy = memcpy(second_chunk_alloc, second_chunk_start, second_chunk_size);
  third_chunk_size = second_chunk_start[second_chunk_size];
  process_buffer[77] = (int)second_chunk_copy;
  third_chunk_alloc = calloc(1u, third_chunk_size);
  process_buffer[80] = (int)memcpy(third_chunk_alloc, &second_chunk_start[second_chunk_size + 1], third_chunk_size);
  process_buffer[82] = (int)calloc(1u, 1u);
  process_buffer[65] = *(_DWORD *)(dword_70E5C + 4 * first_byte);
  process_buffer[63] = *(_DWORD *)dword_71E78;
  process_buffer[64] = **(_DWORD **)dword_71E78;
  if ( !check_and_log_duplicate_share(*(_DWORD *)dword_71E78, second_int)
    || !update_and_check_block_status(process_buffer, second_int) )
  {
    increment_hardware_errors(*(_DWORD *)dword_71E78);
    clear_miner_data(process_buffer);
    return -1;
  }
  submit_work(*(_DWORD *)dword_71E78, process_buffer);
  if ( dword_70D08 && byte_70DBC )
  {
    log_benchfile_event(process_buffer, second_int);
    if ( byte_66641 )
      goto LABEL_10;
  }
  else if ( byte_66641 )
  {
LABEL_10:
    if ( byte_70CE8 || byte_66640 || dword_657B8 > 6 )
    {
      snprintf(log_message, 2048u, "%s nonce submited", "cb_bitmain_submit_nonce");
      log_event(7, log_message, 0);
    }
  }
  clear_miner_data(process_buffer);
  return 0;
}
// 28EA8: using guessed type int __fastcall sub_28EA8(_DWORD);
// 29144: using guessed type int __fastcall sub_29144(_DWORD, _DWORD);
// 2A07C: using guessed type int __fastcall sub_2A07C(_DWORD, _DWORD);
// 2A0E8: using guessed type int __fastcall sub_2A0E8(_DWORD, _DWORD);
// 3A768: using guessed type int __fastcall sub_3A768(_DWORD, _DWORD);
// 657B8: using guessed type int dword_657B8;
// 66640: using guessed type char byte_66640;
// 66641: using guessed type char byte_66641;
// 70CE8: using guessed type char byte_70CE8;
// 70D08: using guessed type int dword_70D08;
// 70DBC: using guessed type char byte_70DBC;
// 70E5C: using guessed type int dword_70E5C;
// 71E78: using guessed type int dword_71E78;

//----- (0003EC74) --------------------------------------------------------
int __fastcall unlock_mutex_logging(int line_number)
{
  int unlock_result; // r0
  int *errno_ptr; // r0
  char log_message[2056]; // [sp+10h] [bp-808h] BYREF

  unlock_result = pthread_mutex_unlock(&stru_74258);
  if ( unlock_result )
  {
    errno_ptr = _errno_location();
    snprintf(
      log_message,
      2048u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *errno_ptr,
      "socketa_api.c",
      "cb_bitmain_api_stats",
      line_number);
    log_event(3, log_message, 1);
    shutdown_miner_safely(1);
  }
  return unlock_result;
}
// 3AADC: using guessed type void __fastcall __noreturn sub_3AADC(_DWORD);
// 74258: using guessed type pthread_mutex_t stru_74258;

//----- (0003ECF0) --------------------------------------------------------
int __fastcall parse_json_data(const char *json_data, int error_code)
{
  double total_hash_value; // d0
  _DWORD *json_object; // r0
  _DWORD *json_object_root; // r4
  _DWORD *inited_value; // r0
  unsigned int *reference_count; // r3
  unsigned int current_value; // r2
  unsigned int decremented_value; // r2
  _DWORD *chain_num_value; // r0
  unsigned int *reference_count_2; // r3
  unsigned int current_value_2; // r2
  int *errno_location_result_1; // r0
  int *errno_location_result_2; // r0
  _DWORD *real_miner_type_value; // r0
  _DWORD *rate_5s_value; // r0
  int unlock_result; // r0
  int *errno_location_result_3; // r0
  const char *rate_5s_string; // r0
  _DWORD *rate_30m_value; // r0
  int error_line; // r0
  const char *real_miner_type_string; // r0
  int *errno_location_result_4; // r0
  const char *rate_30m_string; // r0
  _DWORD *rate_avg_value; // r0
  const char *rate_avg_string; // r0
  _DWORD *rate_ideal_value; // r0
  const char *rate_ideal_string; // r0
  _DWORD *rate_unit_value; // r0
  const char *rate_unit_string; // r0
  _DWORD *fan_num_value; // r0
  _DWORD *fan_array; // r0
  _DWORD *fan_object; // r7
  char *fan_index; // r8
  unsigned int fan_counter; // r6
  bool is_less_than; // cc
  unsigned int incremented_value; // r1
  _DWORD *fan_speed_value; // r0
  char *chain_data_offset; // r6
  unsigned int chain_counter; // r4
  _DWORD *chain_object; // r0
  bool is_end_or_invalid; // zf
  _DWORD *current_chain_object; // r7
  _DWORD *chain_index_value; // r0
  _DWORD *freq_avg_value; // r0
  _DWORD *rate_ideal_chain_value; // r0
  const char *rate_ideal_chain_string; // r0
  _DWORD *rate_real_value; // r0
  const char *rate_real_string; // r0
  _DWORD *asic_num_value; // r0
  _DWORD *asic_value; // r0
  const char *asic_string; // r0
  _DWORD *temp_pic_array; // r0
  _DWORD *temp_pic_object; // r8
  char *temp_pic_index; // r9
  unsigned int temp_pic_counter; // r10
  _DWORD *temp_pic_value; // r0
  bool is_end_or_invalid_temp_pic; // zf
  _DWORD *miner_version_value; // r0
  const char *miner_version_string; // r0
  _DWORD *total_hash_value_object; // r0
  _DWORD *temp_pcb_array; // r0
  _DWORD *temp_pcb_object; // r8
  char *temp_pcb_index; // r9
  unsigned int temp_pcb_counter; // r10
  _DWORD *temp_pcb_value; // r0
  bool is_end_or_invalid_temp_pcb; // zf
  _DWORD *miner_id_value; // r0
  _DWORD *temp_chip_array; // r0
  _DWORD *temp_chip_object; // r8
  char *temp_chip_index; // r9
  unsigned int temp_chip_counter; // r10
  _DWORD *temp_chip_value; // r0
  bool is_end_or_invalid_temp_chip; // zf
  _DWORD *hw_value; // r0
  int hw_result; // r0
  unsigned int rate_array_counter; // r8
  _DWORD *rate_array_object; // r0
  _DWORD *current_rate_array_object; // r10
  char *rate_array_index; // r11
  unsigned int incremented_value_2; // r1
  _DWORD *rate_array_value; // r0
  _DWORD *nonce_value; // r0
  int nonce_result; // r0
  _DWORD *eeprom_value; // r0
  _DWORD *sn_value; // r0
  const char *sn_string; // r0
  _DWORD *eeprom_vol_value; // r0
  _DWORD *eeprom_freq_value; // r0
  _DWORD *eeprom_bin_value; // r0
  _DWORD *eeprom_ft_value; // r0
  const char *eeprom_ft_string; // r0
  _DWORD *eeprom_code_value; // r0
  int tpl_value; // r0
  int tpl_object; // r10
  unsigned int tpl_counter; // r7
  _DWORD *tpl_item_object; // r0
  _DWORD *current_tpl_object; // r9
  unsigned int tpl_index_counter; // r11
  int tpl_result; // r0
  int tpl_offset; // r2
  const char *miner_id_string; // r0
  _DWORD *error_code_value; // r0
  int finalize_result; // r0
  _DWORD *json_object_root_2; // [sp+10h] [bp-940h]
  _DWORD *chain_array; // [sp+14h] [bp-93Ch]
  char initial_buffer[92]; // [sp+2Ch] [bp-924h] BYREF
  char load_data_error_buffer[160]; // [sp+88h] [bp-8C8h] BYREF
  char log_buffer[2088]; // [sp+128h] [bp-828h] BYREF

  if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
  {
    snprintf(log_buffer, 2048u, "%s(%d) : %s", "cb_bitmain_api_stats", error_code, json_data);
    log_event(7, log_buffer, 0);
  }
  json_object = (_DWORD *)process_command(json_data, 0, initial_buffer);
  json_object_root = json_object;
  if ( !json_object || *json_object )
  {
    if ( !byte_70CE8 && !byte_66640 && dword_657B8 <= 2 )
      return -2;
    snprintf(log_buffer, 2048u, "%s: load data is failed(%s)", "cb_bitmain_api_stats", load_data_error_buffer);
    log_event(3, log_buffer, 0);
    return -2;
  }
  if ( pthread_mutex_lock(&stru_74258) )
  {
    errno_location_result_1 = _errno_location();
    snprintf(
      log_buffer,
      2048u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *errno_location_result_1,
      "socketa_api.c",
      "cb_bitmain_api_stats",
      153);
    log_event(3, log_buffer, 1);
    shutdown_miner_safely(1);
  }
  memset(&unk_74270, 0, 6672u);
  inited_value = (_DWORD *)validate_and_fetch_data(json_object_root, "inited");
  if ( !inited_value || *inited_value != 3 )
  {
    if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
    {
      snprintf(log_buffer, 2048u, "%s: load json failed", "cb_bitmain_api_stats");
      log_event(3, log_buffer, 0);
    }
    if ( pthread_mutex_unlock(&stru_74258) )
    {
      errno_location_result_2 = _errno_location();
      snprintf(
        log_buffer,
        2048u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *errno_location_result_2,
        "socketa_api.c",
        "cb_bitmain_api_stats",
        158);
      log_event(3, log_buffer, 1);
      shutdown_miner_safely(1);
    }
    off_658DC(0);
    if ( json_object_root[1] == -1 )
      return -3;
    reference_count = json_object_root + 1;
    __dmb(11u);
    do
    {
      current_value = __ldrex(reference_count);
      decremented_value = current_value - 1;
    }
    while ( __strex(decremented_value, reference_count) );
    goto LABEL_22;
  }
  dword_74278 = get_linked_list_next_node();
  chain_num_value = (_DWORD *)validate_and_fetch_data(json_object_root, "chain_num");
  if ( !chain_num_value || *chain_num_value != 3 )
  {
    if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
    {
      snprintf(log_buffer, 2048u, "%s: load json failed", "cb_bitmain_api_stats");
      log_event(3, log_buffer, 0);
    }
    if ( pthread_mutex_unlock(&stru_74258) )
    {
      errno_location_result_3 = _errno_location();
      snprintf(
        log_buffer,
        2048u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *errno_location_result_3,
        "socketa_api.c",
        "cb_bitmain_api_stats",
        162);
      log_event(3, log_buffer, 1);
      shutdown_miner_safely(1);
    }
    off_658DC(0);
    if ( json_object_root[1] == -1 )
      return -3;
    reference_count_2 = json_object_root + 1;
    __dmb(11u);
    do
    {
      current_value_2 = __ldrex(reference_count_2);
      decremented_value = current_value_2 - 1;
    }
    while ( __strex(decremented_value, reference_count_2) );
LABEL_22:
    if ( !decremented_value )
      process_bitmain_miner(json_object_root);
    return -3;
  }
  dword_74274 = get_linked_list_next_node();
  real_miner_type_value = (_DWORD *)validate_and_fetch_data(json_object_root, "real_miner_type");
  if ( real_miner_type_value && *real_miner_type_value == 2 )
  {
    real_miner_type_string = (const char *)get_linked_item_or_null();
    snprintf(&byte_7427C, 256u, "%s", real_miner_type_string);
  }
  rate_5s_value = (_DWORD *)validate_and_fetch_data(json_object_root, "rate_5s");
  if ( !rate_5s_value || *rate_5s_value != 2 )
  {
    if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
    {
      snprintf(log_buffer, 2048u, "%s: load json failed", "cb_bitmain_api_stats");
      log_event(3, log_buffer, 0);
    }
    unlock_result = pthread_mutex_unlock(&stru_74258);
    if ( unlock_result )
    {
      errno_location_result_4 = _errno_location();
      snprintf(
        log_buffer,
        2048u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *errno_location_result_4,
        "socketa_api.c",
        "cb_bitmain_api_stats",
        172);
      log_event(3, log_buffer, 1);
      shutdown_miner_safely(1);
    }
LABEL_51:
    off_658DC(unlock_result);
    if ( json_object_root[1] != -1 )
    {
      decrement_and_process_if_zero(json_object_root);
      return -3;
    }
    return -3;
  }
  rate_5s_string = (const char *)get_linked_item_or_null();
  snprintf(byte_7437C, 16u, "%s", rate_5s_string);
  rate_30m_value = (_DWORD *)validate_and_fetch_data(json_object_root, "rate_30m");
  if ( !rate_30m_value || *rate_30m_value != 2 )
  {
    if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
    {
      snprintf(log_buffer, 2048u, "%s: load json failed", "cb_bitmain_api_stats");
      log_event(3, log_buffer, 0);
    }
    error_line = 176;
LABEL_61:
    unlock_result = unlock_mutex_logging(error_line);
    goto LABEL_51;
  }
  rate_30m_string = (const char *)get_linked_item_or_null();
  snprintf(byte_7438C, 16u, "%s", rate_30m_string);
  rate_avg_value = (_DWORD *)validate_and_fetch_data(json_object_root, "rate_avg");
  if ( !rate_avg_value || *rate_avg_value != 2 )
  {
    if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
    {
      snprintf(log_buffer, 2048u, "%s: load json failed", "cb_bitmain_api_stats");
      log_event(3, log_buffer, 0);
    }
    error_line = 180;
    goto LABEL_61;
  }
  rate_avg_string = (const char *)get_linked_item_or_null();
  snprintf(src, 16u, "%s", rate_avg_string);
  strncpy(byte_68610, src, 16u);
  rate_ideal_value = (_DWORD *)validate_and_fetch_data(json_object_root, "rate_ideal");
  if ( !rate_ideal_value || *rate_ideal_value != 2 )
  {
    if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
    {
      snprintf(log_buffer, 2048u, "%s: load json failed", "cb_bitmain_api_stats");
      log_event(3, log_buffer, 0);
    }
    error_line = 185;
    goto LABEL_61;
  }
  rate_ideal_string = (const char *)get_linked_item_or_null();
  snprintf(byte_743AC, 16u, "%s", rate_ideal_string);
  rate_unit_value = (_DWORD *)validate_and_fetch_data(json_object_root, "rate_unit");
  if ( !rate_unit_value || *rate_unit_value != 2 )
  {
    if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
    {
      snprintf(log_buffer, 2048u, "%s: load json failed", "cb_bitmain_api_stats");
      log_event(3, log_buffer, 0);
    }
    error_line = 189;
    goto LABEL_61;
  }
  rate_unit_string = (const char *)get_linked_item_or_null();
  snprintf(&byte_743AC[16], 8u, "%s", rate_unit_string);
  fan_num_value = (_DWORD *)validate_and_fetch_data(json_object_root, "fan_num");
  if ( !fan_num_value || *fan_num_value != 3 )
  {
    if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
    {
      snprintf(log_buffer, 2048u, "%s: load json failed", "cb_bitmain_api_stats");
      log_event(3, log_buffer, 0);
    }
    error_line = 193;
    goto LABEL_61;
  }
  *(_DWORD *)&byte_743AC[24] = get_linked_list_next_node();
  fan_array = (_DWORD *)validate_and_fetch_data(json_object_root, "fan");
  fan_object = fan_array;
  if ( !fan_array || *fan_array != 1 )
  {
    if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
    {
      snprintf(log_buffer, 2048u, "%s: load json failed", "cb_bitmain_api_stats");
      log_event(3, log_buffer, 0);
    }
    error_line = 197;
    goto LABEL_61;
  }
  fan_index = &byte_743AC[24];
  fan_counter = 0;
  while ( 1 )
  {
    is_less_than = get_next_structure_pointer(fan_object) > fan_counter;
    incremented_value = fan_counter++;
    if ( !is_less_than )
      break;
    fan_speed_value = (_DWORD *)get_task_by_index(fan_object, incremented_value);
    if ( !fan_speed_value )
      break;
    if ( *fan_speed_value != 3 )
    {
      if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
      {
        snprintf(log_buffer, 2048u, "%s: load json failed", "cb_bitmain_api_stats");
        log_event(3, log_buffer, 0);
      }
      error_line = 199;
      goto LABEL_61;
    }
    *((_DWORD *)fan_index + 1) = get_linked_list_next_node();
    fan_index += 4;
  }
  chain_array = (_DWORD *)validate_and_fetch_data(json_object_root, "chain");
  if ( !chain_array || *chain_array != 1 )
  {
    if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
    {
      snprintf(log_buffer, 2048u, "%s: load json failed", "cb_bitmain_api_stats");
      log_event(3, log_buffer, 0);
    }
    error_line = 204;
    goto LABEL_61;
  }
  chain_data_offset = (char *)&unk_745CC;
  json_object_root_2 = json_object_root;
  chain_counter = 0;
  dword_73FB8 = 0;
  while ( get_next_structure_pointer(chain_array) > chain_counter )
  {
    chain_object = (_DWORD *)get_task_by_index(chain_array, chain_counter);
    is_end_or_invalid = chain_object == 0;
    if ( chain_object )
      is_end_or_invalid = chain_counter == 4;
    current_chain_object = chain_object;
    if ( is_end_or_invalid )
      break;
    if ( *chain_object )
    {
      json_object_root = json_object_root_2;
      if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
      {
        snprintf(log_buffer, 2048u, "%s: load json failed", "cb_bitmain_api_stats");
        log_event(3, log_buffer, 0);
      }
      error_line = 210;
      goto LABEL_61;
    }
    chain_index_value = (_DWORD *)validate_and_fetch_data(chain_object, "index");
    if ( !chain_index_value || *chain_index_value != 3 )
    {
      json_object_root = json_object_root_2;
      if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
      {
        snprintf(log_buffer, 2048u, "%s: load json failed", "cb_bitmain_api_stats");
        log_event(3, log_buffer, 0);
      }
      error_line = 213;
      goto LABEL_61;
    }
    *((_DWORD *)chain_data_offset - 125) = get_linked_list_next_node();
    freq_avg_value = (_DWORD *)validate_and_fetch_data(current_chain_object, "freq_avg");
    if ( !freq_avg_value || *freq_avg_value != 3 )
    {
      json_object_root = json_object_root_2;
      if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
      {
        snprintf(log_buffer, 2048u, "%s: load json failed", "cb_bitmain_api_stats");
        log_event(3, log_buffer, 0);
      }
      error_line = 217;
      goto LABEL_61;
    }
    *((_DWORD *)chain_data_offset - 124) = get_linked_list_next_node();
    rate_ideal_chain_value = (_DWORD *)validate_and_fetch_data(current_chain_object, "rate_ideal");
    if ( !rate_ideal_chain_value || *rate_ideal_chain_value != 2 )
    {
      json_object_root = json_object_root_2;
      if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
      {
        snprintf(log_buffer, 2048u, "%s: load json failed", "cb_bitmain_api_stats");
        log_event(3, log_buffer, 0);
      }
      error_line = 221;
      goto LABEL_61;
    }
    rate_ideal_chain_string = (const char *)get_linked_item_or_null();
    snprintf(chain_data_offset - 492, 16u, "%s", rate_ideal_chain_string);
    rate_real_value = (_DWORD *)validate_and_fetch_data(current_chain_object, "rate_real");
    if ( !rate_real_value || *rate_real_value != 2 )
    {
      json_object_root = json_object_root_2;
      if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
      {
        snprintf(log_buffer, 2048u, "%s: load json failed", "cb_bitmain_api_stats");
        log_event(3, log_buffer, 0);
      }
      error_line = 225;
      goto LABEL_61;
    }
    rate_real_string = (const char *)get_linked_item_or_null();
    snprintf(chain_data_offset - 476, 16u, "%s", rate_real_string);
    asic_num_value = (_DWORD *)validate_and_fetch_data(current_chain_object, "asic_num");
    if ( !asic_num_value || *asic_num_value != 3 )
    {
      json_object_root = json_object_root_2;
      if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
      {
        snprintf(log_buffer, 2048u, "%s: load json failed", "cb_bitmain_api_stats");
        log_event(3, log_buffer, 0);
      }
      error_line = 229;
      goto LABEL_61;
    }
    *((_DWORD *)chain_data_offset - 115) = get_linked_list_next_node();
    asic_value = (_DWORD *)validate_and_fetch_data(current_chain_object, "asic");
    if ( !asic_value || *asic_value != 2 )
    {
      json_object_root = json_object_root_2;
      if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
      {
        snprintf(log_buffer, 2048u, "%s: load json failed", "cb_bitmain_api_stats");
        log_event(3, log_buffer, 0);
      }
      error_line = 233;
      goto LABEL_61;
    }
    asic_string = (const char *)get_linked_item_or_null();
    snprintf(chain_data_offset - 456, 256u, "%s", asic_string);
    temp_pic_array = (_DWORD *)validate_and_fetch_data(current_chain_object, "temp_pic");
    temp_pic_object = temp_pic_array;
    if ( !temp_pic_array || *temp_pic_array != 1 )
    {
      json_object_root = json_object_root_2;
      if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
      {
        snprintf(log_buffer, 2048u, "%s: load json failed", "cb_bitmain_api_stats");
        log_event(3, log_buffer, 0);
      }
      error_line = 237;
      goto LABEL_61;
    }
    temp_pic_index = chain_data_offset - 204;
    temp_pic_counter = 0;
    while ( get_next_structure_pointer(temp_pic_object) > temp_pic_counter )
    {
      temp_pic_value = (_DWORD *)get_task_by_index(temp_pic_object, temp_pic_counter);
      is_end_or_invalid_temp_pic = temp_pic_value == 0;
      if ( temp_pic_value )
        is_end_or_invalid_temp_pic = temp_pic_counter == 4;
      ++temp_pic_counter;
      if ( is_end_or_invalid_temp_pic )
        break;
      if ( *temp_pic_value != 3 )
      {
        json_object_root = json_object_root_2;
        if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
        {
          snprintf(log_buffer, 2048u, "%s: load json failed", "cb_bitmain_api_stats");
          log_event(3, log_buffer, 0);
        }
        error_line = 241;
        goto LABEL_61;
      }
      *((_DWORD *)temp_pic_index + 1) = get_linked_list_next_node();
      temp_pic_index += 4;
    }
    temp_pcb_array = (_DWORD *)validate_and_fetch_data(current_chain_object, "temp_pcb");
    temp_pcb_object = temp_pcb_array;
    if ( !temp_pcb_array || *temp_pcb_array != 1 )
    {
      json_object_root = json_object_root_2;
      if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
      {
        snprintf(log_buffer, 2048u, "%s: load json failed", "cb_bitmain_api_stats");
        log_event(3, log_buffer, 0);
      }
      error_line = 246;
      goto LABEL_61;
    }
    temp_pcb_index = chain_data_offset - 188;
    temp_pcb_counter = 0;
    while ( get_next_structure_pointer(temp_pcb_object) > temp_pcb_counter )
    {
      temp_pcb_value = (_DWORD *)get_task_by_index(temp_pcb_object, temp_pcb_counter);
      is_end_or_invalid_temp_pcb = temp_pcb_value == 0;
      if ( temp_pcb_value )
        is_end_or_invalid_temp_pcb = temp_pcb_counter == 4;
      ++temp_pcb_counter;
      if ( is_end_or_invalid_temp_pcb )
        break;
      if ( *temp_pcb_value != 3 )
      {
        json_object_root = json_object_root_2;
        if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
        {
          snprintf(log_buffer, 2048u, "%s: load json failed", "cb_bitmain_api_stats");
          log_event(3, log_buffer, 0);
        }
        error_line = 250;
        goto LABEL_61;
      }
      *((_DWORD *)temp_pcb_index + 1) = get_linked_list_next_node();
      temp_pcb_index += 4;
    }
    temp_chip_array = (_DWORD *)validate_and_fetch_data(current_chain_object, "temp_chip");
    temp_chip_object = temp_chip_array;
    if ( !temp_chip_array || *temp_chip_array != 1 )
    {
      json_object_root = json_object_root_2;
      if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
      {
        snprintf(log_buffer, 2048u, "%s: load json failed", "cb_bitmain_api_stats");
        log_event(3, log_buffer, 0);
      }
      error_line = 255;
      goto LABEL_61;
    }
    temp_chip_index = chain_data_offset - 172;
    temp_chip_counter = 0;
    while ( get_next_structure_pointer(temp_chip_object) > temp_chip_counter )
    {
      temp_chip_value = (_DWORD *)get_task_by_index(temp_chip_object, temp_chip_counter);
      is_end_or_invalid_temp_chip = temp_chip_value == 0;
      if ( temp_chip_value )
        is_end_or_invalid_temp_chip = temp_chip_counter == 4;
      ++temp_chip_counter;
      if ( is_end_or_invalid_temp_chip )
        break;
      if ( *temp_chip_value != 3 )
      {
        json_object_root = json_object_root_2;
        if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
        {
          snprintf(log_buffer, 2048u, "%s: load json failed", "cb_bitmain_api_stats");
          log_event(3, log_buffer, 0);
        }
        error_line = 259;
        goto LABEL_61;
      }
      *((_DWORD *)temp_chip_index + 1) = get_linked_list_next_node();
      temp_chip_index += 4;
    }
    hw_value = (_DWORD *)validate_and_fetch_data(current_chain_object, "hw");
    if ( !hw_value || *hw_value != 3 )
    {
      json_object_root = json_object_root_2;
      if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
      {
        snprintf(log_buffer, 2048u, "%s: load json failed", "cb_bitmain_api_stats");
        log_event(3, log_buffer, 0);
      }
      error_line = 264;
      goto LABEL_61;
    }
    hw_result = get_linked_list_next_node();
    *((_DWORD *)chain_data_offset - 38) = hw_result;
    rate_array_counter = 0;
    dword_75C74 = 0;
    dword_73FB8 += hw_result;
    rate_array_object = (_DWORD *)validate_and_fetch_data(current_chain_object, "rate_array");
    current_rate_array_object = rate_array_object;
    if ( !rate_array_object || *rate_array_object != 1 )
    {
      json_object_root = json_object_root_2;
      if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
      {
        snprintf(log_buffer, 2048u, "%s: load json failed", "cb_bitmain_api_stats");
        log_event(3, log_buffer, 0);
      }
      error_line = 270;
      goto LABEL_61;
    }
    for ( rate_array_index = chain_data_offset - 152; ; rate_array_index += 4 )
    {
      is_less_than = get_next_structure_pointer(current_rate_array_object) > rate_array_counter;
      incremented_value_2 = rate_array_counter++;
      if ( !is_less_than )
        break;
      rate_array_value = (_DWORD *)get_task_by_index(current_rate_array_object, incremented_value_2);
      if ( !rate_array_value )
        break;
      if ( *rate_array_value != 3 )
      {
        json_object_root = json_object_root_2;
        if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
        {
          snprintf(log_buffer, 2048u, "%s: load json failed", "cb_bitmain_api_stats");
          log_event(3, log_buffer, 0);
        }
        error_line = 272;
        goto LABEL_61;
      }
      *((_DWORD *)rate_array_index + 1) = get_linked_list_next_node();
      ++dword_75C74;
    }
    nonce_value = (_DWORD *)validate_and_fetch_data(current_chain_object, "nonce");
    if ( !nonce_value || *nonce_value != 3 )
    {
      json_object_root = json_object_root_2;
      if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
      {
        snprintf(log_buffer, 2048u, "%s: load json failed", "cb_bitmain_api_stats");
        log_event(3, log_buffer, 0);
      }
      error_line = 278;
      goto LABEL_61;
    }
    nonce_result = get_linked_list_next_node();
    *((_DWORD *)chain_data_offset - 13) = nonce_result;
    dword_75C70 += nonce_result;
    eeprom_value = (_DWORD *)validate_and_fetch_data(current_chain_object, "eeprom");
    if ( !eeprom_value || (unsigned int)(*eeprom_value - 5) > 1 )
    {
      json_object_root = json_object_root_2;
      if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
      {
        snprintf(log_buffer, 2048u, "%s: load json failed", "cb_bitmain_api_stats");
        log_event(3, log_buffer, 0);
      }
      error_line = 283;
      goto LABEL_61;
    }
    *(chain_data_offset - 48) = *eeprom_value == 5;
    sn_value = (_DWORD *)validate_and_fetch_data(current_chain_object, "sn");
    if ( !sn_value || *sn_value != 2 )
    {
      json_object_root = json_object_root_2;
      if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
      {
        snprintf(log_buffer, 2048u, "%s: load json failed", "cb_bitmain_api_stats");
        log_event(3, log_buffer, 0);
      }
      error_line = 287;
      goto LABEL_61;
    }
    sn_string = (const char *)get_linked_item_or_null();
    snprintf(chain_data_offset - 47, 32u, "%s", sn_string);
    eeprom_vol_value = (_DWORD *)validate_and_fetch_data(current_chain_object, "eeprom_vol");
    if ( !eeprom_vol_value || *eeprom_vol_value != 3 )
    {
      json_object_root = json_object_root_2;
      if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
      {
        snprintf(log_buffer, 2048u, "%s: load json failed", "cb_bitmain_api_stats");
        log_event(3, log_buffer, 0);
      }
      error_line = 291;
      goto LABEL_61;
    }
    *((_DWORD *)chain_data_offset - 2) = get_linked_list_next_node();
    eeprom_freq_value = (_DWORD *)validate_and_fetch_data(current_chain_object, "eeprom_freq");
    if ( !eeprom_freq_value || *eeprom_freq_value != 3 )
    {
      json_object_root = json_object_root_2;
      if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
      {
        snprintf(log_buffer, 2048u, "%s: load json failed", "cb_bitmain_api_stats");
        log_event(3, log_buffer, 0);
      }
      error_line = 295;
      goto LABEL_61;
    }
    *((_DWORD *)chain_data_offset - 3) = get_linked_list_next_node();
    eeprom_bin_value = (_DWORD *)validate_and_fetch_data(current_chain_object, "eeprom_bin");
    if ( !eeprom_bin_value || *eeprom_bin_value != 3 )
    {
      json_object_root = json_object_root_2;
      if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
      {
        snprintf(log_buffer, 2048u, "%s: load json failed", "cb_bitmain_api_stats");
        log_event(3, log_buffer, 0);
      }
      error_line = 299;
      goto LABEL_61;
    }
    *((_DWORD *)chain_data_offset - 1) = get_linked_list_next_node();
    eeprom_ft_value = (_DWORD *)validate_and_fetch_data(current_chain_object, "eeprom_ft");
    if ( !eeprom_ft_value || *eeprom_ft_value != 2 )
    {
      json_object_root = json_object_root_2;
      if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
      {
        snprintf(log_buffer, 2048u, "%s: load json failed", "cb_bitmain_api_stats");
        log_event(3, log_buffer, 0);
      }
      error_line = 303;
      goto LABEL_61;
    }
    eeprom_ft_string = (const char *)get_linked_item_or_null();
    snprintf(chain_data_offset, 16u, "%s", eeprom_ft_string);
    eeprom_code_value = (_DWORD *)validate_and_fetch_data(current_chain_object, "eeprom_code");
    if ( !eeprom_code_value || *eeprom_code_value != 3 )
    {
      json_object_root = json_object_root_2;
      if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
      {
        snprintf(log_buffer, 2048u, "%s: load json failed", "cb_bitmain_api_stats");
        log_event(3, log_buffer, 0);
      }
      error_line = 307;
      goto LABEL_61;
    }
    *((_DWORD *)chain_data_offset + 4) = get_linked_list_next_node();
    tpl_value = validate_and_fetch_data(current_chain_object, "tpl");
    tpl_object = tpl_value;
    if ( tpl_value )
    {
      tpl_counter = 0;
      *((_DWORD *)chain_data_offset + 5) = get_next_structure_pointer(tpl_value);
      while ( get_next_structure_pointer(tpl_object) > tpl_counter )
      {
        tpl_item_object = (_DWORD *)get_task_by_index(tpl_object, tpl_counter);
        current_tpl_object = tpl_item_object;
        if ( !tpl_item_object )
          break;
        if ( *tpl_item_object != 1 )
        {
          json_object_root = json_object_root_2;
          if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
          {
            snprintf(log_buffer, 2048u, "%s: load json failed", "cb_bitmain_api_stats");
            log_event(3, log_buffer, 0);
          }
          error_line = 317;
          goto LABEL_61;
        }
        tpl_index_counter = 0;
        *((_DWORD *)chain_data_offset + 6) = get_next_structure_pointer(tpl_item_object);
        while ( get_next_structure_pointer(current_tpl_object) > tpl_index_counter
             && get_task_by_index(current_tpl_object, tpl_index_counter) )
        {
          tpl_result = get_linked_list_next_node();
          tpl_offset = 388 * chain_counter + tpl_index_counter++;
          *((_DWORD *)&unk_74270 + tpl_offset + *((_DWORD *)chain_data_offset + 6) * tpl_counter + 222) = tpl_result;
        }
        ++tpl_counter;
      }
    }
    ++chain_counter;
    chain_data_offset += 1552;
  }
  json_object_root = json_object_root_2;
  miner_version_value = (_DWORD *)validate_and_fetch_data(json_object_root_2, "miner_version");
  if ( !miner_version_value || *miner_version_value != 2 )
  {
    if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
    {
      snprintf(log_buffer, 2048u, "%s: load json failed", "cb_bitmain_api_stats");
      log_event(3, log_buffer, 0);
    }
    error_line = 326;
    goto LABEL_61;
  }
  miner_version_string = (const char *)get_linked_item_or_null();
  snprintf(byte_75C18, 48u, "%s", miner_version_string);
  if ( strcmp(byte_75C18, byte_68628) )
    strncpy(byte_68628, byte_75C18, 256u);
  total_hash_value_object = (_DWORD *)validate_and_fetch_data(json_object_root_2, "total_hash");
  if ( !total_hash_value_object || *total_hash_value_object != 4 )
  {
    if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
    {
      snprintf(log_buffer, 2048u, "%s: load json failed", "cb_bitmain_api_stats");
      log_event(3, log_buffer, 0);
    }
    error_line = 332;
    goto LABEL_61;
  }
  sub_47B28();
  *(double *)&byte_75C18[48] = total_hash_value;
  unk_70CE0 = total_hash_value * 1000.0;
  miner_id_value = (_DWORD *)validate_and_fetch_data(json_object_root_2, "miner_id");
  if ( !miner_id_value || *miner_id_value != 2 )
  {
    if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
    {
      snprintf(log_buffer, 2048u, "%s: load json failed", "cb_bitmain_api_stats");
      log_event(3, log_buffer, 0);
    }
    error_line = 337;
    goto LABEL_61;
  }
  miner_id_string = (const char *)get_linked_item_or_null();
  snprintf(byte_75C50, 32u, "%s", miner_id_string);
  error_code_value = (_DWORD *)validate_and_fetch_data(json_object_root_2, "error_code");
  if ( !error_code_value || *error_code_value != 3 )
  {
    if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
    {
      snprintf(log_buffer, 2048u, "%s: load json failed", "cb_bitmain_api_stats");
      log_event(3, log_buffer, 0);
    }
    error_line = 341;
    goto LABEL_61;
  }
  dword_75C78 = get_linked_list_next_node();
  finalize_result = unlock_mutex_logging(344);
  off_658DC(finalize_result);
  if ( json_object_root_2[1] != -1 )
    decrement_and_process_if_zero(json_object_root_2);
  return 0;
}
// 3FC74: variable 'total_hash_value' is possibly undefined
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 3AADC: using guessed type void __fastcall __noreturn sub_3AADC(_DWORD);
// 3E9C8: using guessed type int __fastcall sub_3E9C8(_DWORD);
// 3EC74: using guessed type int __fastcall sub_3EC74(_DWORD);
// 46448: using guessed type int __fastcall sub_46448(_DWORD, _DWORD, _DWORD);
// 472EC: using guessed type int __fastcall sub_472EC(_DWORD, _DWORD);
// 47658: using guessed type int __fastcall sub_47658(_DWORD);
// 47674: using guessed type int __fastcall sub_47674(_DWORD, _DWORD);
// 47820: using guessed type int sub_47820(void);
// 47A7C: using guessed type int sub_47A7C(void);
// 47B28: using guessed type int sub_47B28(void);
// 47C24: using guessed type int __fastcall sub_47C24(_DWORD);
// 657B8: using guessed type int dword_657B8;
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);
// 66640: using guessed type char byte_66640;
// 66641: using guessed type char byte_66641;
// 70CE8: using guessed type char byte_70CE8;
// 73FB8: using guessed type int dword_73FB8;
// 74258: using guessed type pthread_mutex_t stru_74258;
// 74274: using guessed type int dword_74274;
// 74278: using guessed type int dword_74278;
// 7427C: using guessed type char byte_7427C;
// 75C70: using guessed type int dword_75C70;
// 75C74: using guessed type int dword_75C74;
// 75C78: using guessed type int dword_75C78;
// 3ECF0: using guessed type char var_924[92];
// 3ECF0: using guessed type char var_8C8[160];

//----- (00040C38) --------------------------------------------------------
int __fastcall check_and_parse_stats(const char *data_ptr, int data_len)
{
  bool is_invalid_args; // zf
  char log_buffer[2056]; // [sp+8h] [bp-808h] BYREF

  is_invalid_args = data_len == 0;
  if ( data_len )
    is_invalid_args = data_ptr == 0;
  if ( !is_invalid_args )
    return parse_json_data(data_ptr, data_len);
  if ( !byte_70CE8 && !byte_66640 && dword_657B8 <= 2 )
    return -1;
  snprintf(log_buffer, 2048u, "%s input err: data @ %p, len is %d", "cb_bitmain_api_stats", data_ptr, data_len);
  log_event(3, log_buffer, 0);
  return -1;
}
// 657B8: using guessed type int dword_657B8;
// 66640: using guessed type char byte_66640;
// 70CE8: using guessed type char byte_70CE8;

//----- (00040CEC) --------------------------------------------------------
int __fastcall send_detect_message(int param1, int param2)
{
  char message_buffer[2064]; // [sp+8h] [bp-810h] BYREF

  if ( byte_70CE8 || byte_66640 || dword_657B8 > 4 )
  {
    strcpy(message_buffer, "about to send detect");
    log_event(5, message_buffer, 0);
  }
  return send_recv_message(aBitmainApiDete, param1, param2, message_buffer, 0, 0);
}
// 43450: using guessed type int __fastcall sub_43450(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 657B8: using guessed type int dword_657B8;
// 66640: using guessed type char byte_66640;
// 70CE8: using guessed type char byte_70CE8;

//----- (00040DA8) --------------------------------------------------------
int __fastcall send_job_log_and_update(int job_id, int job_size)
{
  char log_message[2064]; // [sp+8h] [bp-810h] BYREF

  if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
  {
    snprintf(log_message, 2048u, "about to send job, size is %d", job_size);
    log_event(7, log_message, 0);
  }
  return send_recv_message(aBitmainUpdateJ, job_id, job_size, log_message, 0, 0);
}
// 43450: using guessed type int __fastcall sub_43450(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 657B8: using guessed type int dword_657B8;
// 66640: using guessed type char byte_66640;
// 66641: using guessed type char byte_66641;
// 70CE8: using guessed type char byte_70CE8;

//----- (00040E70) --------------------------------------------------------
int __fastcall flush_api_semaphore(int arg1, int arg2)
{
  char log_message[2064]; // [sp+8h] [bp-810h] BYREF

  if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
  {
    strcpy(log_message, "about to send a flush api semaphore");
    log_event(7, log_message, 0);
  }
  return send_recv_message(aBitmainFlushAp, arg1, arg2, log_message, 0, 0);
}
// 43450: using guessed type int __fastcall sub_43450(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 657B8: using guessed type int dword_657B8;
// 66640: using guessed type char byte_66640;
// 66641: using guessed type char byte_66641;
// 70CE8: using guessed type char byte_70CE8;

//----- (00040F44) --------------------------------------------------------
int __fastcall send_shutdown_message(int param1, int param2)
{
  char shutdown_message[2064]; // [sp+8h] [bp-810h] BYREF

  if ( byte_70CE8 || byte_66640 || dword_657B8 > 4 )
  {
    strcpy(shutdown_message, "about to send shutdown");
    log_event(5, shutdown_message, 0);
  }
  return send_recv_message(aBitmainShutdow, param1, param2, shutdown_message, 0, 0);
}
// 43450: using guessed type int __fastcall sub_43450(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 657B8: using guessed type int dword_657B8;
// 66640: using guessed type char byte_66640;
// 70CE8: using guessed type char byte_70CE8;

//----- (00041008) --------------------------------------------------------
int init_socket_api()
{
  int init_status; // r0
  int final_status; // r5
  char *api_string; // r4
  int *errno_ptr_init1; // r0
  int *errno_ptr_init2; // r0
  char error_message[2080]; // [sp+10h] [bp-820h] BYREF

  if ( pthread_mutex_init(&stru_74258, 0) )
  {
    errno_ptr_init1 = _errno_location();
    snprintf(
      error_message,
      2048u,
      "Failed to pthread_mutex_init errno=%d in %s %s():%d",
      *errno_ptr_init1,
      "socketa_api.c",
      "cgminer_socket_init",
      506);
    log_event(3, error_message, 1);
    shutdown_miner_safely(1);
  }
  if ( pthread_mutex_init(&stru_75C80, 0) )
  {
    errno_ptr_init2 = _errno_location();
    snprintf(
      error_message,
      2048u,
      "Failed to pthread_mutex_init errno=%d in %s %s():%d",
      *errno_ptr_init2,
      "socketa_api.c",
      "cgminer_socket_init",
      507);
    log_event(3, error_message, 1);
    shutdown_miner_safely(1);
  }
  init_status = init_network_connection(&off_53E84, 2);
  final_status = init_status;
  if ( init_status )
  {
    if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
    {
      snprintf(error_message, 2048u, "%s trans init failed: %d", "cgminer_socket_init", init_status);
      log_event(3, error_message, 0);
    }
  }
  else
  {
    while ( 1 )
    {
      api_string = aBitmainApiDete;
      final_status = 0;
      do
      {
        final_status |= initialize_connection(api_string);
        if ( byte_70CE8 || byte_66640 || dword_657B8 > 4 )
        {
          snprintf(error_message, 2048u, "%s reg %s return: %d", "cgminer_socket_init", api_string, final_status);
          log_event(5, error_message, 0);
        }
        api_string += 132;
      }
      while ( api_string != (char *)&unk_66450 );
      if ( !final_status )
        break;
      sleep(5u);
      if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
      {
        snprintf(error_message, 2048u, "%s reg failed wait 5s", "cgminer_socket_init");
        log_event(3, error_message, 0);
      }
    }
  }
  return final_status;
}
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 3AADC: using guessed type void __fastcall __noreturn sub_3AADC(_DWORD);
// 42F3C: using guessed type int __fastcall sub_42F3C(_DWORD, _DWORD);
// 43190: using guessed type int __fastcall sub_43190(_DWORD);
// 53E84: using guessed type int (*off_53E84)();
// 657B8: using guessed type int dword_657B8;
// 66640: using guessed type char byte_66640;
// 70CE8: using guessed type char byte_70CE8;
// 74258: using guessed type pthread_mutex_t stru_74258;
// 75C80: using guessed type pthread_mutex_t stru_75C80;

//----- (00041278) --------------------------------------------------------
int __fastcall load_configuration_info(int config_param)
{
  _DWORD *json_root; // r0
  _DWORD *config_json_root; // r5
  __int64 freq_level; // r6
  __int64 miner_mode; // r8
  int miner_mode_result; // r0
  int freq_level_result; // r0
  _DWORD *miner_mode_node; // r0
  _DWORD *freq_level_node; // r0
  unsigned int *ref_count; // r3
  unsigned int current_count; // r2
  unsigned int updated_count; // r2
  const char *freq_level_string; // r0
  const char *miner_mode_string; // r0
  char config_path[128]; // [sp+Ch] [bp-99Ch] BYREF
  char unknown_buffer1[92]; // [sp+8Ch] [bp-91Ch] BYREF
  char error_message_buffer[160]; // [sp+E8h] [bp-8C0h] BYREF
  char log_message[2080]; // [sp+188h] [bp-820h] BYREF

  memset(config_path, 0, sizeof(config_path));
  get_bmminer_config_path(config_path);
  json_root = (_DWORD *)handle_file_processing(config_path, 0, unknown_buffer1);
  config_json_root = json_root;
  if ( json_root && !*json_root )
  {
    miner_mode_node = (_DWORD *)validate_and_fetch_data(json_root, "bitmain-work-mode");
    if ( miner_mode_node && *miner_mode_node == 2 )
    {
      miner_mode_string = (const char *)get_linked_item_or_null(miner_mode_node);
      miner_mode = strtol(miner_mode_string, 0, 10);
    }
    else
    {
      miner_mode = -1LL;
    }
    freq_level_node = (_DWORD *)validate_and_fetch_data(config_json_root, &unk_51FD0);
    if ( freq_level_node && *freq_level_node == 2 )
    {
      freq_level_string = (const char *)get_linked_item_or_null(freq_level_node);
      freq_level = strtol(freq_level_string, 0, 10);
    }
    else
    {
      freq_level = -1LL;
    }
    if ( config_json_root[1] != -1 )
    {
      ref_count = config_json_root + 1;
      __dmb(11u);
      do
      {
        current_count = __ldrex(ref_count);
        updated_count = current_count - 1;
      }
      while ( __strex(updated_count, ref_count) );
      if ( !updated_count )
        process_bitmain_miner(config_json_root);
    }
  }
  else if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
  {
    freq_level = -1LL;
    miner_mode = -1LL;
    snprintf(
      log_message,
      2048u,
      "%s: JSON decode of file '%s' failed\n %s",
      "load_conf_info",
      config_path,
      error_message_buffer);
    log_event(3, log_message, 0);
  }
  else
  {
    freq_level = -1LL;
    miner_mode = -1LL;
  }
  miner_mode_result = set_error_context(miner_mode, HIDWORD(miner_mode));
  configure_miner_connection(config_param, "miner-mode", miner_mode_result);
  freq_level_result = set_error_context(freq_level, HIDWORD(freq_level));
  return configure_miner_connection(config_param, "freq-level", freq_level_result);
}
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 467A0: using guessed type int __fastcall sub_467A0(_DWORD, _DWORD, _DWORD);
// 472EC: using guessed type int __fastcall sub_472EC(_DWORD, _DWORD);
// 47820: using guessed type int __fastcall sub_47820(_DWORD);
// 47A48: using guessed type int __fastcall sub_47A48(_DWORD, _DWORD);
// 47C24: using guessed type int __fastcall sub_47C24(_DWORD);
// 4808C: using guessed type int __fastcall sub_4808C(_DWORD, _DWORD, _DWORD);
// 657B8: using guessed type int dword_657B8;
// 66640: using guessed type char byte_66640;
// 70CE8: using guessed type char byte_70CE8;
// 41278: using guessed type char var_91C[92];
// 41278: using guessed type char var_8C0[160];

//----- (00041474) --------------------------------------------------------
void notify_shutdown_event()
{
  char log_buffer[2056]; // [sp+0h] [bp-808h] BYREF

  if ( byte_70CE8 || byte_66640 || dword_657B8 > 4 )
  {
    strcpy(log_buffer, "cgminer call shutdown");
    log_event(5, log_buffer, 0);
  }
  if ( send_shutdown_message("shutdown", 8) && (byte_70CE8 || byte_66640 || dword_657B8 > 2) )
  {
    snprintf(log_buffer, 2048u, "%s: bitmain_shutdown failed.", "bitmain_c5_shutdown");
    log_event(3, log_buffer, 0);
  }
}
// 40F44: using guessed type int __fastcall sub_40F44(_DWORD, _DWORD);
// 657B8: using guessed type int dword_657B8;
// 66640: using guessed type char byte_66640;
// 70CE8: using guessed type char byte_70CE8;

//----- (00041570) --------------------------------------------------------
int log_api_detect_failure()
{
  char message_buffer[2056]; // [sp+0h] [bp-808h] BYREF

  snprintf(message_buffer, 2048u, "%s: api detect failed.", "bitmain_c5_prepare");
  log_event(3, message_buffer, 0);
  return 0;
}

//----- (00041700) --------------------------------------------------------
void __fastcall __noreturn sub_41700(const char *function_name, int line_number)
{
  int *errno_location; // r0
  char error_message[2064]; // [sp+10h] [bp-810h] BYREF

  errno_location = _errno_location();
  snprintf(
    error_message,
    2048u,
    "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
    *errno_location,
    "driver-btm-c5_socketa.c",
    function_name,
    line_number);
  log_event(3, error_message, 1);
  shutdown_miner_safely(1);
}

//----- (00041764) --------------------------------------------------------
void __fastcall __noreturn sub_41764(const char *function_name, int line_number)
{
  int *errno_ptr; // r0
  char error_message[2064]; // [sp+10h] [bp-810h] BYREF

  errno_ptr = _errno_location();
  snprintf(
    error_message,
    2048u,
    "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
    *errno_ptr,
    "driver-btm-c5_socketa.c",
    function_name,
    line_number);
  log_event(3, error_message, 1);
  shutdown_miner_safely(1);
}

//----- (000417C8) --------------------------------------------------------
_DWORD *calculate_statistics()
{
  _DWORD *miner_state_root; // r10
  __int64 elapsed_time_operation; // r0
  int elapsed_time_seconds; // r0
  int elapsed_time_ms; // r0
  int rate_5s_micros_result; // r0
  int rate_30m_microseconds; // r0
  int rate_30m_parse_micros; // r0
  int rate_avg_microseconds; // r0
  int rate_avg_parse_micros; // r0
  int rate_ideal_microseconds; // r0
  int rate_ideal_parse_micros; // r0
  const char *rate_unit_parse_result; // r0
  int chain_num_parse_result; // r0
  int fan_num; // r0
  _DWORD *fan_speed_root; // r7
  int *fan_speeds_array; // r5
  int fan_i; // r4
  int current_fan_speed; // t1
  int fan_speed_calculated_value; // r0
  double total_hwp_divisor; // d7
  int total_hwp_calculated; // r0
  int total_hwp_parse_result; // r0
  char *current_chain_data_ptr; // r4
  int chain_i; // r10
  _DWORD *current_chain_result; // r5
  char *current_asic_values_ptr; // r7
  int asic_i; // r9
  int chain_index_parse_result; // r0
  int freq_avg_parse_result; // r0
  int rate_ideal_calculated_per_chain; // r0
  int rate_ideal_parse_per_chain; // r0
  int rate_real_calculated_per_chain; // r0
  int rate_real_parse_per_chain; // r0
  int asic_number_result; // r0
  const char *asics_result_root; // r0
  _DWORD *temp_pic_result_root; // r8
  int current_temp_value; // t1
  int temp_calculated_value; // r0
  char *temp_pcb_ptr_current; // r8
  int temp_pcb_i; // r7
  _DWORD *temp_pcb_result_root; // r9
  int current_temp_pcb_value; // t1
  int temp_pcb_calculated_value; // r0
  char *temp_chip_ptr_current; // r8
  _DWORD *temp_chip_result_root; // r9
  int current_temp_chip_value; // t1
  int temp_chip_calculated_value; // r0
  int hw_result_value; // r0
  void *eeprom_loaded_result_value; // r2
  const char *serial_number_result_value; // r0
  double per_chain_hwp_divisor; // d7
  int per_chain_hwp_calculated; // r0
  int per_chain_hwp_parse_result; // r0
  _DWORD *tpl_result_root; // r0
  int tpl_i; // r7
  _DWORD *tpl_parent_result_root; // r11
  _DWORD *tpl_child_result_root; // r0
  int tpl_count_value; // r3
  _DWORD *tpl_child_values_root; // r8
  int tpl_value_i; // r5
  int tpl_value_offset_value; // r2
  int tpl_value_parsed_result; // r0
  _DWORD *v63; // [sp+4h] [bp-8Ch]
  _DWORD *tpl_parent_result_value; // [sp+14h] [bp-7Ch]
  _DWORD *miner_state_root_res; // [sp+18h] [bp-78h]
  _DWORD *current_chain_result_res; // [sp+1Ch] [bp-74h]
  double rate_5s_manual_calc; // [sp+20h] [bp-70h] BYREF
  double rate_30m_manual_calc; // [sp+28h] [bp-68h] BYREF
  double rate_avg_manual_calc; // [sp+30h] [bp-60h] BYREF
  double rate_ideal_manual_calc; // [sp+38h] [bp-58h] BYREF
  double rate_real_manual_calc; // [sp+40h] [bp-50h] BYREF
  char rate_unit_scratch_buffer[4]; // [sp+48h] [bp-48h] BYREF
  int unused_scratch_buffer; // [sp+4Ch] [bp-44h]

  rate_5s_manual_calc = 0.0;
  rate_30m_manual_calc = 0.0;
  rate_avg_manual_calc = 0.0;
  rate_ideal_manual_calc = 0.0;
  rate_real_manual_calc = 0.0;
  unused_scratch_buffer = 0;
  *(_DWORD *)rate_unit_scratch_buffer = 0;
  if ( pthread_mutex_lock(&stru_74258) )
    log_mutex_lock_error("bitmain_api_stats", 433);
  miner_state_root = initialize_miner_error_state();
  elapsed_time_operation = calculate_hash_rate(dword_66120, unk_66124);
  elapsed_time_seconds = set_error_context(elapsed_time_operation);
  configure_miner_connection(miner_state_root, "elapsed", elapsed_time_seconds);
  sscanf(byte_7437C, "%lf", &rate_5s_manual_calc);
  elapsed_time_ms = calculate_hash_rate(
                      COERCE_UNSIGNED_INT64(rate_5s_manual_calc * 100.0),
                      HIDWORD(COERCE_UNSIGNED_INT64(rate_5s_manual_calc * 100.0)));
  convert_float_to_int(elapsed_time_ms);
  rate_5s_micros_result = check_and_set_error_description();
  configure_miner_connection(miner_state_root, "rate_5s", rate_5s_micros_result);
  sscanf(byte_7438C, "%lf", &rate_30m_manual_calc);
  rate_30m_microseconds = calculate_hash_rate(
                            COERCE_UNSIGNED_INT64(rate_30m_manual_calc * 100.0),
                            HIDWORD(COERCE_UNSIGNED_INT64(rate_30m_manual_calc * 100.0)));
  convert_float_to_int(rate_30m_microseconds);
  rate_30m_parse_micros = check_and_set_error_description();
  configure_miner_connection(miner_state_root, "rate_30m", rate_30m_parse_micros);
  sscanf(src, "%lf", &rate_avg_manual_calc);
  rate_avg_microseconds = calculate_hash_rate(
                            COERCE_UNSIGNED_INT64(rate_avg_manual_calc * 100.0),
                            HIDWORD(COERCE_UNSIGNED_INT64(rate_avg_manual_calc * 100.0)));
  convert_float_to_int(rate_avg_microseconds);
  rate_avg_parse_micros = check_and_set_error_description();
  configure_miner_connection(miner_state_root, "rate_avg", rate_avg_parse_micros);
  sscanf(byte_743AC, "%lf", &rate_ideal_manual_calc);
  rate_ideal_microseconds = calculate_hash_rate(
                              COERCE_UNSIGNED_INT64(rate_ideal_manual_calc * 100.0),
                              HIDWORD(COERCE_UNSIGNED_INT64(rate_ideal_manual_calc * 100.0)));
  convert_float_to_int(rate_ideal_microseconds);
  rate_ideal_parse_micros = check_and_set_error_description();
  configure_miner_connection(miner_state_root, "rate_ideal", rate_ideal_parse_micros);
  snprintf(rate_unit_scratch_buffer, 8u, "%s/s", &byte_743AC[16]);
  rate_unit_parse_result = validate_utf8_or_return_input(rate_unit_scratch_buffer);
  configure_miner_connection(miner_state_root, "rate_unit", rate_unit_parse_result);
  chain_num_parse_result = set_error_context(dword_74274);
  configure_miner_connection(miner_state_root, "chain_num", chain_num_parse_result);
  fan_num = set_error_context(*(int *)&byte_743AC[24]);
  configure_miner_connection(miner_state_root, "fan_num", fan_num);
  fan_speed_root = initialize_error_description();
  if ( *(int *)&byte_743AC[24] > 0 )
  {
    fan_speeds_array = &dword_743C8;
    fan_i = 0;
    do
    {
      current_fan_speed = *fan_speeds_array++;
      ++fan_i;
      fan_speed_calculated_value = set_error_context(current_fan_speed);
      add_buffer_to_queue(fan_speed_root, fan_speed_calculated_value);
    }
    while ( *(int *)&byte_743AC[24] > fan_i );
  }
  configure_miner_connection(miner_state_root, "fan", fan_speed_root);
  total_hwp_divisor = (double)dword_75C70;
  if ( (double)dword_75C70 <= 512.0 )
    total_hwp_divisor = 512.0;
  total_hwp_calculated = calculate_hash_rate(
                           COERCE_UNSIGNED_INT64((double)dword_73FB8 * 512.0 / total_hwp_divisor * 10000.0),
                           HIDWORD(COERCE_UNSIGNED_INT64((double)dword_73FB8 * 512.0 / total_hwp_divisor * 10000.0)));
  convert_float_to_int(total_hwp_calculated);
  total_hwp_parse_result = check_and_set_error_description();
  configure_miner_connection(miner_state_root, "hwp_total", total_hwp_parse_result);
  load_configuration_info((int)miner_state_root);
  v63 = initialize_error_description();
  if ( dword_74274 > 0 )
  {
    miner_state_root_res = miner_state_root;
    current_chain_data_ptr = algn_743E0;
    chain_i = 0;
    do
    {
      current_chain_result = initialize_miner_error_state();
      current_asic_values_ptr = current_chain_data_ptr + 288;
      asic_i = 0;
      chain_index_parse_result = set_error_context(*((int *)current_chain_data_ptr - 2));
      configure_miner_connection(current_chain_result, "index", chain_index_parse_result);
      freq_avg_parse_result = set_error_context(*((int *)current_chain_data_ptr - 1));
      configure_miner_connection(current_chain_result, "freq_avg", freq_avg_parse_result);
      sscanf(current_chain_data_ptr, "%lf", &rate_ideal_manual_calc);
      rate_ideal_calculated_per_chain = calculate_hash_rate(
                                          COERCE_UNSIGNED_INT64(rate_ideal_manual_calc * 100.0),
                                          HIDWORD(COERCE_UNSIGNED_INT64(rate_ideal_manual_calc * 100.0)));
      convert_float_to_int(rate_ideal_calculated_per_chain);
      rate_ideal_parse_per_chain = check_and_set_error_description();
      configure_miner_connection(current_chain_result, "rate_ideal", rate_ideal_parse_per_chain);
      sscanf(current_chain_data_ptr + 16, "%lf", &rate_real_manual_calc);
      rate_real_calculated_per_chain = calculate_hash_rate(
                                         COERCE_UNSIGNED_INT64(rate_real_manual_calc * 100.0),
                                         HIDWORD(COERCE_UNSIGNED_INT64(rate_real_manual_calc * 100.0)));
      convert_float_to_int(rate_real_calculated_per_chain);
      rate_real_parse_per_chain = check_and_set_error_description();
      configure_miner_connection(current_chain_result, "rate_real", rate_real_parse_per_chain);
      asic_number_result = set_error_context(*((int *)current_chain_data_ptr + 8));
      configure_miner_connection(current_chain_result, "asic_num", asic_number_result);
      asics_result_root = validate_utf8_or_return_input(current_chain_data_ptr + 36);
      configure_miner_connection(current_chain_result, "asic", asics_result_root);
      temp_pic_result_root = initialize_error_description();
      do
      {
        current_temp_value = *((_DWORD *)current_asic_values_ptr + 1);
        current_asic_values_ptr += 4;
        ++asic_i;
        temp_calculated_value = set_error_context(current_temp_value);
        add_buffer_to_queue(temp_pic_result_root, temp_calculated_value);
      }
      while ( asic_i != 4 );
      configure_miner_connection(current_chain_result, "temp_pic", temp_pic_result_root);
      temp_pcb_ptr_current = current_chain_data_ptr + 304;
      temp_pcb_i = 0;
      temp_pcb_result_root = initialize_error_description();
      do
      {
        current_temp_pcb_value = *((_DWORD *)temp_pcb_ptr_current + 1);
        temp_pcb_ptr_current += 4;
        ++temp_pcb_i;
        temp_pcb_calculated_value = set_error_context(current_temp_pcb_value);
        add_buffer_to_queue(temp_pcb_result_root, temp_pcb_calculated_value);
      }
      while ( temp_pcb_i != 4 );
      configure_miner_connection(current_chain_result, "temp_pcb", temp_pcb_result_root);
      temp_chip_ptr_current = current_chain_data_ptr + 320;
      temp_chip_result_root = initialize_error_description();
      do
      {
        current_temp_chip_value = *((_DWORD *)temp_chip_ptr_current + 1);
        temp_chip_ptr_current += 4;
        temp_chip_calculated_value = set_error_context(current_temp_chip_value);
        add_buffer_to_queue(temp_chip_result_root, temp_chip_calculated_value);
        --temp_pcb_i;
      }
      while ( temp_pcb_i );
      configure_miner_connection(current_chain_result, "temp_chip", temp_chip_result_root);
      hw_result_value = set_error_context(*((int *)current_chain_data_ptr + 85));
      configure_miner_connection(current_chain_result, "hw", hw_result_value);
      if ( current_chain_data_ptr[444] )
        eeprom_loaded_result_value = get_reference_to_unk_664D4();
      else
        eeprom_loaded_result_value = get_global_variable_address();
      configure_miner_connection(current_chain_result, "eeprom_loaded", eeprom_loaded_result_value);
      serial_number_result_value = validate_utf8_or_return_input(current_chain_data_ptr + 445);
      configure_miner_connection(current_chain_result, "sn", serial_number_result_value);
      per_chain_hwp_divisor = (double)*((int *)current_chain_data_ptr + 110);
      if ( per_chain_hwp_divisor <= 512.0 )
        per_chain_hwp_divisor = 512.0;
      per_chain_hwp_calculated = calculate_hash_rate(
                                   COERCE_UNSIGNED_INT64(
                                     (double)*((int *)current_chain_data_ptr + 85)
                                   * 512.0
                                   / per_chain_hwp_divisor
                                   * 10000.0),
                                   HIDWORD(
                                     COERCE_UNSIGNED_INT64(
                                       (double)*((int *)current_chain_data_ptr + 85)
                                     * 512.0
                                     / per_chain_hwp_divisor
                                     * 10000.0)));
      convert_float_to_int(per_chain_hwp_calculated);
      per_chain_hwp_parse_result = check_and_set_error_description();
      configure_miner_connection(current_chain_result, "hwp", per_chain_hwp_parse_result);
      if ( *((_DWORD *)current_chain_data_ptr + 128) )
      {
        tpl_result_root = initialize_error_description();
        tpl_parent_result_value = tpl_result_root;
        if ( *((int *)current_chain_data_ptr + 128) > 0 )
        {
          tpl_i = 0;
          tpl_parent_result_root = tpl_result_root;
          current_chain_result_res = current_chain_result;
          do
          {
            tpl_child_result_root = initialize_error_description();
            tpl_count_value = *((_DWORD *)current_chain_data_ptr + 129);
            tpl_child_values_root = tpl_child_result_root;
            if ( tpl_count_value > 0 )
            {
              tpl_value_i = 0;
              do
              {
                tpl_value_offset_value = 388 * chain_i + tpl_value_i++;
                tpl_value_parsed_result = set_error_context(*((int *)&unk_74270
                                                            + tpl_value_offset_value
                                                            + tpl_i * tpl_count_value
                                                            + 222));
                add_buffer_to_queue(tpl_child_values_root, tpl_value_parsed_result);
                tpl_count_value = *((_DWORD *)current_chain_data_ptr + 129);
              }
              while ( tpl_count_value > tpl_value_i );
            }
            add_buffer_to_queue(tpl_parent_result_root, tpl_child_values_root);
            ++tpl_i;
          }
          while ( *((_DWORD *)current_chain_data_ptr + 128) > tpl_i );
          current_chain_result = current_chain_result_res;
        }
        configure_miner_connection(current_chain_result, "tpl", tpl_parent_result_value);
      }
      add_buffer_to_queue(v63, current_chain_result);
      ++chain_i;
      current_chain_data_ptr += 1552;
    }
    while ( dword_74274 > chain_i );
    miner_state_root = miner_state_root_res;
  }
  configure_miner_connection(miner_state_root, "chain", v63);
  if ( pthread_mutex_unlock(&stru_74258) )
    log_mutex_unlock_failure("bitmain_api_stats", 540);
  off_658DC(0);
  return miner_state_root;
}
// 4808C: using guessed type int __fastcall sub_4808C(_DWORD, _DWORD, _DWORD);
// 4854C: using guessed type int __fastcall sub_4854C(_DWORD, _DWORD);
// 4930C: using guessed type double __fastcall sub_4930C(_DWORD);
// 493A4: using guessed type __int64 __fastcall sub_493A4(_DWORD, _DWORD);
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);
// 66120: using guessed type int dword_66120;
// 73FB8: using guessed type int dword_73FB8;
// 74258: using guessed type pthread_mutex_t stru_74258;
// 74274: using guessed type int dword_74274;
// 743C8: using guessed type int dword_743C8;
// 75C70: using guessed type int dword_75C70;

//----- (00041F00) --------------------------------------------------------
__int64 reset_mining_processor()
{
  __int64 previous_state; // r6

  previous_state = qword_68740;
  if ( qword_68740 )
  {
    if ( pthread_mutex_lock(&stru_75C80) )
      log_mutex_lock_error("bitmain_c5_scanhash", 184);
    qword_68740 = 0LL;
    if ( pthread_mutex_unlock(&stru_75C80) )
      log_mutex_unlock_failure("bitmain_c5_scanhash", 186);
    off_658DC(0);
  }
  get_and_update_system_time(2);
  return previous_state;
}
// 1DA28: using guessed type int sub_1DA28(void);
// 1F7F8: using guessed type int __fastcall sub_1F7F8(_DWORD);
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);
// 68740: using guessed type __int64 qword_68740;
// 75C80: using guessed type pthread_mutex_t stru_75C80;

//----- (00041F98) --------------------------------------------------------
int detect_bitmain_c5()
{
  _DWORD *allocated_memory; // r0
  _DWORD *device_info; // r9
  int log_status; // r0
  int initialization_status; // r0
  int *lock_errno; // r0
  int *unlock_errno_first; // r0
  int *unlock_errno_second; // r0
  char message_prefix[4]; // [sp+14h] [bp-82Ch] BYREF
  char log_message[2040]; // [sp+18h] [bp-828h] BYREF

  allocated_memory = calloc(1u, 392u);
  device_info = allocated_memory;
  if ( !allocated_memory )
    _assert_fail("cgpu", "driver-btm-c5_socketa.c", 51u, "bitmain_c5_detect");
  allocated_memory[1] = &unk_66450;
  allocated_memory[8] = 0;
  allocated_memory[37] = 1;
  log_status = init_socket_api();
  if ( log_status )
  {
    if ( byte_70CE8 || byte_66640 || dword_657B8 > 2 )
    {
      strcpy(log_message, "cgminer socket init failes.");
      log_status = log_event(3, log_message, 0);
    }
  }
  else if ( byte_70CE8 || byte_66640 || dword_657B8 > 5 )
  {
    strcpy(log_message, "cgminer socket init succeeds.");
    log_status = log_event(6, log_message, 0);
  }
  if ( dword_66858 )
    read_miner_version_file(log_status);
  message_prefix[0] = 0;
  get_and_update_system_time(2000);
  while ( 1 )
  {
    flush_api_semaphore(message_prefix, 1);
    get_and_update_system_time(1000);
    if ( pthread_mutex_lock(&stru_74258) )
    {
      lock_errno = _errno_location();
      snprintf(
        log_message,
        2048u,
        "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
        *lock_errno,
        "driver-btm-c5_socketa.c",
        "bitmain_c5_detect",
        77);
      log_event(3, log_message, 1);
      shutdown_miner_safely(1);
    }
    if ( dword_74278 )
      break;
    if ( pthread_mutex_unlock(&stru_74258) )
    {
      unlock_errno_first = _errno_location();
      snprintf(
        log_message,
        2048u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *unlock_errno_first,
        "driver-btm-c5_socketa.c",
        "bitmain_c5_detect",
        83);
      log_event(3, log_message, 1);
      shutdown_miner_safely(1);
    }
    off_658DC(0);
  }
  if ( pthread_mutex_unlock(&stru_74258) )
  {
    unlock_errno_second = _errno_location();
    snprintf(
      log_message,
      2048u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *unlock_errno_second,
      "driver-btm-c5_socketa.c",
      "bitmain_c5_detect",
      79);
    log_event(3, log_message, 1);
    shutdown_miner_safely(1);
  }
  off_658DC(0);
  if ( byte_70CE8 || byte_66640 || dword_657B8 > 4 )
  {
    strcpy(log_message, "bmminer init done!!!");
    log_event(5, log_message, 0);
  }
  initialization_status = update_miner_info(device_info);
  if ( !initialization_status )
    _assert_fail("add_cgpu(cgpu)", "driver-btm-c5_socketa.c", 85u, "bitmain_c5_detect");
  return initialization_status;
}
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 1DA28: using guessed type int sub_1DA28(void);
// 1F7F8: using guessed type int __fastcall sub_1F7F8(_DWORD);
// 3AADC: using guessed type void __fastcall __noreturn sub_3AADC(_DWORD);
// 3AF10: using guessed type int __fastcall sub_3AF10(_DWORD);
// 3C280: using guessed type int __fastcall sub_3C280(_DWORD);
// 40E70: using guessed type int __fastcall sub_40E70(_DWORD, _DWORD);
// 41008: using guessed type int sub_41008(void);
// 657B8: using guessed type int dword_657B8;
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);
// 66640: using guessed type char byte_66640;
// 66858: using guessed type int dword_66858;
// 70CE8: using guessed type char byte_70CE8;
// 74258: using guessed type pthread_mutex_t stru_74258;
// 74278: using guessed type int dword_74278;
// 41F98: using guessed type char anonymous_0[4];

//----- (00042328) --------------------------------------------------------
char *__fastcall generate_job_buffer(int miner_index, size_t *buffer_size)
{
  pthread_mutex_t *mutex_lock_ptr; // r4
  pthread_rwlock_t *rw_lock_ptr; // r11
  const char *miner_data; // r9
  int num_entries; // r6
  size_t data_length; // r10
  const char *extra_data; // r8
  size_t miner_data_len; // r7
  size_t total_size; // r4
  char *allocated_buffer; // r0
  char *job_buffer; // r7
  size_t copy_offset; // r3
  size_t current_pos; // r10
  _DWORD **data_entries; // r5
  char *data_entry_ptr; // r3
  _DWORD **data_end; // r6
  _DWORD *current_entry; // t1
  int entry_data_1; // r12
  int entry_data_2; // r0
  int entry_data_3; // r1
  int entry_data_4; // r12
  int entry_data_5; // r0
  int entry_data_6; // r1
  size_t miner_data_actual_length; // r5
  size_t extra_data_pos; // r10
  size_t extra_data_len; // r5
  size_t next_pos; // r10
  size_t final_pos; // r5
  int temp_int_storage; // r1
  int entry_byte_cond; // r12
  int *errno_ptr_unlock; // r0
  int *errno_ptr_mutex_unlock; // r0
  int *errno_ptr_lock; // r0
  int *errno_ptr_rdlock; // r0
  int entries_total_size; // [sp+18h] [bp-838h]
  size_t base_data_offset; // [sp+1Ch] [bp-834h]
  int temp_data_double; // [sp+20h] [bp-830h] BYREF
  int temp_data_int; // [sp+24h] [bp-82Ch]
  char error_message[2088]; // [sp+28h] [bp-828h] BYREF

  mutex_lock_ptr = (pthread_mutex_t *)(miner_index + 212);
  temp_data_double = 0;
  temp_data_int = 0;
  if ( pthread_mutex_lock((pthread_mutex_t *)(miner_index + 212)) )
  {
    errno_ptr_lock = _errno_location();
    snprintf(
      error_message,
      2048u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *errno_ptr_lock,
      "driver-btm-c5_socketa.c",
      "rebuild_job_buf",
      222);
    log_event(3, error_message, 1);
    shutdown_miner_safely(1);
  }
  rw_lock_ptr = (pthread_rwlock_t *)(miner_index + 236);
  if ( pthread_rwlock_rdlock((pthread_rwlock_t *)(miner_index + 236)) )
  {
    errno_ptr_rdlock = _errno_location();
    snprintf(
      error_message,
      2048u,
      "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *errno_ptr_rdlock,
      "driver-btm-c5_socketa.c",
      "rebuild_job_buf",
      222);
    log_event(3, error_message, 1);
    shutdown_miner_safely(1);
  }
  if ( pthread_mutex_unlock(mutex_lock_ptr) )
  {
    errno_ptr_mutex_unlock = _errno_location();
    snprintf(
      error_message,
      2048u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *errno_ptr_mutex_unlock,
      "driver-btm-c5_socketa.c",
      "rebuild_job_buf",
      222);
    log_event(3, error_message, 1);
    shutdown_miner_safely(1);
  }
  miner_data = *(const char **)(miner_index + 672);
  num_entries = *(_DWORD *)(miner_index + 1708);
  data_length = *(_DWORD *)(miner_index + 1572);
  extra_data = *(const char **)(miner_index + 612);
  miner_data_len = strlen(miner_data);
  entries_total_size = 32 * num_entries;
  total_size = data_length + 1866 + 32 * num_entries + miner_data_len + strlen(extra_data);
  allocated_buffer = (char *)calloc(1u, total_size);
  job_buffer = allocated_buffer;
  if ( allocated_buffer )
  {
    memcpy(allocated_buffer, (const void *)miner_index, 1848u);
    memcpy(job_buffer + 1848, *(const void **)(miner_index + 1568), data_length);
    copy_offset = data_length + 1848;
    base_data_offset = data_length + 1848;
    current_pos = data_length + 1848;
    if ( num_entries > 0 )
    {
      data_entries = *(_DWORD ***)(miner_index + 676);
      data_entry_ptr = &job_buffer[copy_offset];
      data_end = &data_entries[num_entries];
      do
      {
        current_entry = *data_entries++;
        data_entry_ptr += 32;
        entry_data_1 = current_entry[1];
        entry_data_2 = current_entry[2];
        entry_data_3 = current_entry[3];
        *((_DWORD *)data_entry_ptr - 8) = *current_entry;
        *((_DWORD *)data_entry_ptr - 7) = entry_data_1;
        *((_DWORD *)data_entry_ptr - 6) = entry_data_2;
        *((_DWORD *)data_entry_ptr - 5) = entry_data_3;
        entry_data_4 = current_entry[5];
        entry_data_5 = current_entry[6];
        entry_data_6 = current_entry[7];
        *((_DWORD *)data_entry_ptr - 4) = current_entry[4];
        *((_DWORD *)data_entry_ptr - 3) = entry_data_4;
        *((_DWORD *)data_entry_ptr - 2) = entry_data_5;
        *((_DWORD *)data_entry_ptr - 1) = entry_data_6;
      }
      while ( data_end != data_entries );
      current_pos = base_data_offset + entries_total_size;
    }
    miner_data_actual_length = strlen(miner_data) + 1;
    memcpy(&job_buffer[current_pos], miner_data, miner_data_actual_length);
    extra_data_pos = miner_data_actual_length + current_pos;
    extra_data_len = strlen(extra_data);
    memcpy(&job_buffer[extra_data_pos], extra_data, extra_data_len + 1);
    next_pos = extra_data_pos + extra_data_len;
    final_pos = next_pos + 1;
    if ( pthread_rwlock_unlock(rw_lock_ptr) )
    {
      errno_ptr_unlock = _errno_location();
      snprintf(
        error_message,
        2048u,
        "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *errno_ptr_unlock,
        "driver-btm-c5_socketa.c",
        "rebuild_job_buf",
        258);
      log_event(3, error_message, 1);
      shutdown_miner_safely(1);
    }
    off_658DC(0);
    sscanf(byte_68610, "%.2lf", &temp_data_double);
    temp_int_storage = temp_data_int;
    entry_byte_cond = (unsigned __int8)byte_66641;
    *(_DWORD *)&job_buffer[final_pos] = temp_data_double;
    *(_DWORD *)&job_buffer[final_pos + 4] = temp_int_storage;
    *(double *)&job_buffer[next_pos + 9] = dbl_66148;
    if ( entry_byte_cond && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
    {
      snprintf(error_message, 2048u, "job buf total len:%d, offset:%d\n", total_size, next_pos + 17);
      log_event(7, error_message, 0);
    }
    *buffer_size = total_size;
    return job_buffer;
  }
  if ( !byte_70CE8 && !byte_66640 && dword_657B8 <= 2 )
    return job_buffer;
  snprintf(error_message, 2048u, "malloc temp job data buf failed: %d\n", total_size);
  log_event(3, error_message, 0);
  return 0;
}
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 1DA28: using guessed type int sub_1DA28(void);
// 3AADC: using guessed type void __fastcall __noreturn sub_3AADC(_DWORD);
// 657B8: using guessed type int dword_657B8;
// 658DC: using guessed type int (__fastcall *off_658DC)(_DWORD);
// 66148: using guessed type double dbl_66148;
// 66640: using guessed type char byte_66640;
// 66641: using guessed type char byte_66641;
// 70CE8: using guessed type char byte_70CE8;

//----- (0004278C) --------------------------------------------------------
void __fastcall sub_4278C(int a1)
{
  int v1; // r4
  int v2; // r1
  int v3; // r0
  int v4; // r0
  int v5; // r2
  bool v6; // zf
  char *v7; // r4
  int work_for_thread; // [sp+0h] [bp-818h] BYREF
  size_t v9; // [sp+4h] [bp-814h] BYREF
  char v10[2064]; // [sp+8h] [bp-810h] BYREF

  v1 = **(_DWORD **)(a1 + 152);
  if ( byte_66641 && (byte_70CE8 || byte_66640 || dword_657B8 > 6) )
  {
    strcpy(v10, "update job");
    log_event(7, v10, 0);
  }
  v2 = *(_DWORD *)v1;
  *(_BYTE *)(v1 + 63) = 0;
  *(_BYTE *)(v1 + 62) = 0;
  work_for_thread = fetch_work_for_thread(v1, v2);
  v3 = process_work_discard(&work_for_thread, "driver-btm-c5_socketa.c", "bitmain_c5_update", 288);
  v4 = get_current_pool_index(v3);
  if ( !*(_BYTE *)(v4 + 640) )
  {
    strcpy(v10, "Bitmain S9 has to use stratum pools");
    log_event(3, v10, 1);
    shutdown_miner_safely(1);
  }
  v5 = dword_681AC;
  v6 = dword_681AC == 0;
  if ( dword_681AC )
  {
    v5 = 0;
    *(_BYTE *)(v4 + 680) = 1;
  }
  if ( !v6 )
    dword_681AC = v5;
  v7 = generate_job_buffer(v4, &v9);
  if ( v9 && send_job_log_and_update() && (byte_70CE8 || byte_66640 || dword_657B8 > 2) )
  {
    snprintf(v10, 2048u, "%s: update job failed.", "bitmain_c5_update");
    log_event(3, v10, 0);
  }
  free(v7);
}
// 1CCEC: using guessed type int __fastcall sub_1CCEC(_DWORD, _DWORD, _DWORD);
// 292F8: using guessed type int __fastcall sub_292F8(_DWORD, _DWORD, _DWORD, _DWORD);
// 2E47C: using guessed type int __fastcall sub_2E47C(_DWORD);
// 3AADC: using guessed type void __fastcall __noreturn sub_3AADC(_DWORD);
// 40DA8: using guessed type int sub_40DA8(void);
// 657B8: using guessed type int dword_657B8;
// 66640: using guessed type char byte_66640;
// 66641: using guessed type char byte_66641;
// 681AC: using guessed type int dword_681AC;
// 70CE8: using guessed type char byte_70CE8;

//----- (00042980) --------------------------------------------------------
int __fastcall handle_client_connection(int connection_fd)
{
  pthread_t thread_id; // r0
  int socket_fd; // r7
  int index; // r4
  int new_global_value; // r4
  _DWORD *new_client_memory; // r0
  int global_client_count; // r11
  _DWORD *client_data_ptr; // r10
  const char *compare_str; // r5
  int compare_result; // r0
  int retrieve_value; // r3
  size_t src_len; // r0
  int client_id; // r10
  size_t message_len; // r0
  size_t send_len; // r0
  int scan_result; // [sp+14h] [bp-224h] BYREF
  pthread_t new_thread; // [sp+18h] [bp-220h] BYREF
  char prctl_name[8]; // [sp+1Ch] [bp-21Ch] BYREF
  int prctl_name_last_part; // [sp+24h] [bp-214h]
  int init_zero; // [sp+28h] [bp-210h]
  char client_data[4]; // [sp+2Ch] [bp-20Ch] BYREF
  int zero_init_1; // [sp+30h] [bp-208h]
  int v24; // [sp+34h] [bp-204h]
  int v25; // [sp+38h] [bp-200h]
  int v26; // [sp+3Ch] [bp-1FCh]
  int v27; // [sp+40h] [bp-1F8h]
  int v28; // [sp+44h] [bp-1F4h]
  int v29; // [sp+48h] [bp-1F0h]
  char s1[4]; // [sp+4Ch] [bp-1ECh] BYREF
  int v31; // [sp+50h] [bp-1E8h]
  int v32; // [sp+54h] [bp-1E4h]
  int v33; // [sp+58h] [bp-1E0h]
  int v34; // [sp+5Ch] [bp-1DCh]
  int v35; // [sp+60h] [bp-1D8h]
  int v36; // [sp+64h] [bp-1D4h]
  int v37; // [sp+68h] [bp-1D0h]
  pthread_attr_t attr; // [sp+6Ch] [bp-1CCh] BYREF
  int buf[32]; // [sp+90h] [bp-1A8h] BYREF
  char v40[4]; // [sp+110h] [bp-128h] BYREF
  char v41[252]; // [sp+114h] [bp-124h] BYREF

  thread_id = pthread_self();
  pthread_detach(thread_id);
  init_zero = 0;
  qmemcpy(prctl_name, "ct_a/mai", sizeof(prctl_name));
  prctl_name_last_part = *(unsigned __int16 *)"n";
  prctl(15, prctl_name);
  pthread_attr_init(&attr);
  pthread_attr_setstacksize(&attr, 1048576u);
  socket_fd = *(_DWORD *)(connection_fd + 8);
  while ( 1 )
  {
    memset(buf, 0, sizeof(buf));
    if ( recv(socket_fd, buf, 128u, 0) <= 0 )
      return 0;
    *(_DWORD *)client_data = 0;
    zero_init_1 = 0;
    *(_DWORD *)s1 = 0;
    v31 = 0;
    scan_result = 0;
    v24 = 0;
    v25 = 0;
    v26 = 0;
    v27 = 0;
    v28 = 0;
    v29 = 0;
    v32 = 0;
    v33 = 0;
    v34 = 0;
    v35 = 0;
    v36 = 0;
    v37 = 0;
    _isoc99_sscanf(buf, "%x%s%s", &scan_result, s1, client_data);
    index = strcmp(s1, "regist");
    if ( index )
    {
      new_global_value = dword_68748 + 1;
      memcpy((char *)&unk_68770 + 128 * dword_68748, buf, 128u);
      dword_68748 = new_global_value;
    }
    else
    {
      new_client_memory = calloc(152u, 1u);
      global_client_count = dword_6874C;
      client_data_ptr = new_client_memory;
      if ( !dword_6874C )
        goto LABEL_18;
      compare_str = s2;
      while ( 1 )
      {
        compare_result = strcmp(client_data, compare_str);
        compare_str += 136;
        if ( !compare_result )
          break;
        if ( ++index == global_client_count )
          goto LABEL_11;
      }
      retrieve_value = *((_DWORD *)&unk_6C770 + 34 * index + 33);
      client_data_ptr[3] = *((_DWORD *)&unk_6C770 + 34 * index);
      client_data_ptr[37] = retrieve_value;
LABEL_11:
      if ( global_client_count == index )
      {
LABEL_18:
        *(_DWORD *)v40 = 0;
        memset(v41, 0, sizeof(v41));
        sprintf(v40, "%x %d %s %s %s", 63, 0, "reg_resp", "no_name", client_data);
        send_len = strlen(v40);
        send(socket_fd, v40, send_len + 1, 0);
        free(client_data_ptr);
      }
      else
      {
        *client_data_ptr = dword_664C8;
        src_len = strlen(client_data);
        memcpy(client_data_ptr + 4, client_data, src_len + 1);
        client_data_ptr[36] = 0;
        pthread_create(&new_thread, &attr, (void *(*)(void *))initialize_network_thread, client_data_ptr);
        while ( !client_data_ptr[36] )
          usleep(10000u);
        client_id = *client_data_ptr;
        *(_DWORD *)v40 = 0;
        if ( client_id != dword_664C8 )
          dword_664C8 = client_id;
        memset(v41, 0, sizeof(v41));
        sprintf(v40, "%x %d %s %s %s", 63, client_id, "reg_resp", "OK", client_data);
        message_len = strlen(v40);
        send(socket_fd, v40, message_len + 1, 0);
        ++dword_664C8;
      }
    }
  }
}
// 11FC4: using guessed type int __fastcall _isoc99_sscanf(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 664C8: using guessed type int dword_664C8;
// 68748: using guessed type int dword_68748;
// 6874C: using guessed type int dword_6874C;

//----- (00042CB4) --------------------------------------------------------
int __fastcall initialize_network_thread(int arg)
{
  pthread_t thread_id; // r0
  unsigned int thread_number; // r2
  int sock; // r0
  int socket_fd; // r4
  unsigned int current_thread_number; // r3
  int client_fd; // r5
  size_t buf_length; // r0
  void *recv_buffer; // r6
  ssize_t recv_size; // r1
  int (__fastcall *callback_func)(void *, ssize_t); // r4
  size_t response_length; // r0
  size_t data_length; // [sp+Ch] [bp-264h]
  int sock_opt_val; // [sp+10h] [bp-260h] BYREF
  socklen_t addr_len; // [sp+14h] [bp-25Ch] BYREF
  char thread_name[4]; // [sp+18h] [bp-258h] BYREF
  int unused1; // [sp+1Ch] [bp-254h]
  int unused2; // [sp+20h] [bp-250h]
  int unused3; // [sp+24h] [bp-24Ch]
  struct sockaddr server_addr; // [sp+28h] [bp-248h] BYREF
  struct sockaddr client_addr; // [sp+38h] [bp-238h] BYREF
  char send_buffer[4]; // [sp+48h] [bp-228h] BYREF
  char unused_buffer1[252]; // [sp+4Ch] [bp-224h] BYREF
  char response_buffer[4]; // [sp+148h] [bp-128h] BYREF
  char unused_buffer2[252]; // [sp+14Ch] [bp-124h] BYREF

  thread_id = pthread_self();
  pthread_detach(thread_id);
  thread_number = *(_DWORD *)arg;
  *(_DWORD *)thread_name = 0;
  unused1 = 0;
  unused2 = 0;
  unused3 = 0;
  sprintf(thread_name, "ct_a/fcb/%d", thread_number);
  prctl(15, thread_name);
  server_addr.sa_family = 2;
  *(_DWORD *)&server_addr.sa_data[2] = inet_addr("127.0.0.1");
  sock = socket(2, 1, 0);
  socket_fd = sock;
  if ( sock < 0 )
  {
    perror("socket error");
    return 0;
  }
  else
  {
    sock_opt_val = 1;
    if ( setsockopt(sock, 1, 2, &sock_opt_val, 4u) < 0 )
    {
      perror("set sockopt err");
      return 0;
    }
    else
    {
      for ( current_thread_number = *(_DWORD *)arg; ; *(_DWORD *)arg = current_thread_number )
      {
        *(_WORD *)server_addr.sa_data = __rev16(current_thread_number);
        if ( bind(socket_fd, &server_addr, 16u) >= 0 )
          break;
        perror("bind error");
        current_thread_number = *(_DWORD *)arg + 1;
      }
      if ( listen(socket_fd, 5) < 0 )
      {
        perror("listen error");
      }
      else
      {
        addr_len = 16;
        *(_DWORD *)(arg + 144) = 1;
        client_fd = accept(socket_fd, &client_addr, &addr_len);
        if ( client_fd >= 0 )
        {
          *(_DWORD *)send_buffer = 0;
          memset(unused_buffer1, 0, sizeof(unused_buffer1));
          sprintf(send_buffer, "%x %s\n", 63, (const char *)(arg + 16));
          buf_length = strlen(send_buffer);
          send(client_fd, send_buffer, buf_length + 1, 0);
          data_length = *(_DWORD *)(arg + 148);
          recv_buffer = malloc(data_length);
          recv(client_fd, recv_buffer, data_length, 0);
          while ( 1 )
          {
            recv_size = recv(client_fd, recv_buffer, *(_DWORD *)(arg + 148), 0);
            if ( recv_size > 0 )
            {
              callback_func = *(int (__fastcall **)(void *, ssize_t))(arg + 12);
              if ( callback_func )
                callback_func = (int (__fastcall *)(void *, ssize_t))callback_func(recv_buffer, recv_size);
            }
            else
            {
              callback_func = 0;
            }
            *(_DWORD *)response_buffer = 0;
            memset(unused_buffer2, 0, sizeof(unused_buffer2));
            sprintf(response_buffer, "%x %d %s %s", 63, callback_func, arg + 16, "OK");
            response_length = strlen(response_buffer);
            send(client_fd, response_buffer, response_length + 1, 0);
          }
        }
        perror("accept error");
      }
      return 0;
    }
  }
}

//----- (00042F3C) --------------------------------------------------------
int __fastcall init_network_connection(int config_data, int config_count)
{
  int return_code; // r6
  char *current_config; // r4
  char *config_copy_dest; // r3
  char *config_end; // r7
  char *memcpy_result; // r0
  int current_config_val; // r0
  int socket_fd; // r4
  ssize_t recv_bytes; // r0
  char *recv_buffer_end; // r3
  bool is_recv_error; // cc
  int *message_parts; // r12
  int message_part1; // r0
  int message_part2; // r1
  int message_part3; // r2
  int message_part4; // r3
  int *message_remaining_parts; // r12
  int message_part5; // r1
  ssize_t recv_bytes_2; // r0
  char *recv_buffer_end_2; // r3
  int *heartbeat_message_parts; // r12
  int heartbeat_message_part1; // r0
  int heartbeat_message_part2; // r1
  int heartbeat_message_part3; // r2
  int heartbeat_message_part4; // r3
  int *heartbeat_message_remaining_parts; // r12
  int heartbeat_message_part5; // r1
  _DWORD *thread_data; // r0
  pthread_t thread_id; // [sp+0h] [bp-350h] BYREF
  struct sockaddr server_addr; // [sp+4h] [bp-34Ch] BYREF
  pthread_attr_t thread_attr; // [sp+14h] [bp-33Ch] BYREF
  int send_buf_part1; // [sp+38h] [bp-318h] BYREF
  int send_buf_part2; // [sp+3Ch] [bp-314h]
  int send_buf_part3; // [sp+40h] [bp-310h]
  int send_buf_part4; // [sp+44h] [bp-30Ch]
  int send_buf_part5; // [sp+48h] [bp-308h]
  int send_buf_part6; // [sp+4Ch] [bp-304h]
  char zero_buf[232]; // [sp+50h] [bp-300h] BYREF
  int recv_buf[128]; // [sp+138h] [bp-218h] BYREF
  char recv_buf_helper[24]; // [sp+338h] [bp-18h] BYREF

  return_code = dword_68750;
  if ( dword_68750 )
    return -1;
  pthread_attr_init(&thread_attr);
  pthread_attr_setstacksize(&thread_attr, 1048576u);
  pthread_mutex_init(&stru_68754, (const pthread_mutexattr_t *)return_code);
  if ( config_count )
  {
    current_config = (char *)(config_data + 4);
    config_copy_dest = s2;
    config_end = &current_config[136 * config_count];
    do
    {
      memcpy_result = (char *)memcpy(config_copy_dest, current_config, 128u);
      current_config += 136;
      config_copy_dest = memcpy_result + 136;
      current_config_val = *((_DWORD *)current_config - 35);
      *((_DWORD *)config_copy_dest - 2) = *((_DWORD *)current_config - 2);
      *((_DWORD *)config_copy_dest - 35) = current_config_val;
    }
    while ( current_config != config_end );
  }
  *(_WORD *)&server_addr.sa_data[6] = 0;
  *(_DWORD *)&server_addr.sa_data[8] = 0;
  *(_WORD *)&server_addr.sa_data[12] = 0;
  dword_6874C = config_count;
  server_addr.sa_family = 2;
  *(_DWORD *)&server_addr.sa_data[2] = inet_addr("127.0.0.1");
  *(_WORD *)server_addr.sa_data = 2646;
  socket_fd = socket(2, 1, 0);
  if ( socket_fd < 0 )
  {
    return_code = -4;
    perror("socket err:");
  }
  else
  {
    while ( connect(socket_fd, &server_addr, 16u) < 0 )
    {
      perror("connect err:");
      sleep(1u);
    }
    memset(recv_buf, 0, sizeof(recv_buf));
    recv_bytes = recv(socket_fd, recv_buf, 256u, 0);
    is_recv_error = recv_bytes <= 0;
    LOWORD(message_parts) = (unsigned __int16)"func1 func2 func3 func4";
    if ( recv_bytes > 0 )
      recv_buffer_end = recv_buf_helper;
    HIWORD(message_parts) = (unsigned int)"func1 func2 func3 func4" >> 16;
    if ( recv_bytes > 0 )
      recv_bytes += (ssize_t)recv_buffer_end;
    if ( !is_recv_error )
      *(_BYTE *)(recv_bytes - 512) = 0;
    message_part1 = *message_parts;
    message_part2 = message_parts[1];
    message_part3 = message_parts[2];
    message_part4 = message_parts[3];
    message_remaining_parts = message_parts + 4;
    send_buf_part1 = message_part1;
    send_buf_part2 = message_part2;
    send_buf_part3 = message_part3;
    send_buf_part4 = message_part4;
    message_part5 = message_remaining_parts[1];
    send_buf_part5 = *message_remaining_parts;
    send_buf_part6 = message_part5;
    memset(zero_buf, 0, sizeof(zero_buf));
    send(socket_fd, &send_buf_part1, 24u, 0);
    recv_bytes_2 = recv(socket_fd, recv_buf, 256u, 0);
    LOWORD(heartbeat_message_parts) = (unsigned __int16)"3f heart-beats 22027";
    if ( recv_bytes_2 > 0 )
      recv_buffer_end_2 = recv_buf_helper;
    HIWORD(heartbeat_message_parts) = (unsigned int)"3f heart-beats 22027" >> 16;
    if ( recv_bytes_2 > 0 )
      recv_buffer_end_2[recv_bytes_2 - 512] = 0;
    heartbeat_message_part1 = *heartbeat_message_parts;
    heartbeat_message_part2 = heartbeat_message_parts[1];
    heartbeat_message_part3 = heartbeat_message_parts[2];
    heartbeat_message_part4 = heartbeat_message_parts[3];
    heartbeat_message_remaining_parts = heartbeat_message_parts + 4;
    send_buf_part1 = heartbeat_message_part1;
    send_buf_part2 = heartbeat_message_part2;
    send_buf_part3 = heartbeat_message_part3;
    send_buf_part4 = heartbeat_message_part4;
    heartbeat_message_part5 = heartbeat_message_remaining_parts[1];
    send_buf_part5 = *heartbeat_message_remaining_parts;
    LOBYTE(send_buf_part6) = heartbeat_message_part5;
    send(socket_fd, &send_buf_part1, 21u, 0);
    dword_6876C = socket_fd;
    thread_data = malloc(12u);
    thread_data[2] = socket_fd;
    *thread_data = 22026;
    pthread_create(&thread_id, &thread_attr, (void *(*)(void *))handle_client_connection, thread_data);
    dword_68750 = 1;
  }
  return return_code;
}
// 4308C: variable 'recv_buffer_end' is possibly undefined
// 430F0: variable 'recv_buffer_end_2' is possibly undefined
// 6874C: using guessed type int dword_6874C;
// 68750: using guessed type int dword_68750;
// 68754: using guessed type pthread_mutex_t stru_68754;
// 6876C: using guessed type int dword_6876C;

//----- (00043190) --------------------------------------------------------
int __fastcall initialize_connection(int config_input)
{
  pthread_mutex_t *mutex_ptr; // r8
  int global_socket_fd; // r9
  int current_global_index; // r5
  size_t buf_length; // r0
  int new_socket_fd; // r0
  int connection_fd; // r5
  ssize_t recv_size; // r0
  unsigned int parsed_port; // r3
  int function_result; // r0
  unsigned int port; // [sp+10h] [bp-498h] BYREF
  int sscanf_result; // [sp+14h] [bp-494h] BYREF
  struct sockaddr server_addr; // [sp+18h] [bp-490h] BYREF
  int sscanf_buffer[24]; // [sp+28h] [bp-480h] BYREF
  int received_message[32]; // [sp+88h] [bp-420h] BYREF
  int send_buffer[32]; // [sp+108h] [bp-3A0h] BYREF
  char init_message[4]; // [sp+188h] [bp-320h] BYREF
  char zeroed_buffer[252]; // [sp+18Ch] [bp-31Ch] BYREF
  int recv_buffer[136]; // [sp+288h] [bp-220h] BYREF

  if ( !dword_68750 )
    return -1;
  mutex_ptr = (pthread_mutex_t *)malloc(36u);
  pthread_mutex_init(mutex_ptr, 0);
  global_socket_fd = dword_6876C;
  *(_DWORD *)init_message = 0;
  memset(zeroed_buffer, 0, sizeof(zeroed_buffer));
  sprintf(init_message, "%x regist %s", 63, (const char *)config_input);
  current_global_index = dword_68748;
  buf_length = strlen(init_message);
  send(global_socket_fd, init_message, buf_length + 1, 0);
  memset(received_message, 0, sizeof(received_message));
  while ( dword_68748 == current_global_index )
    usleep(1000u);
  memcpy(received_message, (char *)&unk_68770 + 128 * current_global_index, sizeof(received_message));
  port = 0;
  sscanf_result = 0;
  memset(sscanf_buffer, 0, sizeof(sscanf_buffer));
  _isoc99_sscanf(received_message, &unk_546A4, &sscanf_result, &port, sscanf_buffer);
  if ( !port )
    return -4;
  server_addr.sa_family = 2;
  memset(server_addr.sa_data, 0, sizeof(server_addr.sa_data));
  *(_DWORD *)&server_addr.sa_data[2] = inet_addr("127.0.0.1");
  *(_WORD *)server_addr.sa_data = __rev16(port);
  new_socket_fd = socket(2, 1, 0);
  connection_fd = new_socket_fd;
  if ( new_socket_fd < 0 )
  {
    perror("socket err:");
    return -4;
  }
  else if ( connect(new_socket_fd, &server_addr, 16u) < 0 )
  {
    perror("connect err:");
    return -3;
  }
  else
  {
    memset(recv_buffer, 0, 512);
    recv_size = recv(connection_fd, recv_buffer, 512u, 0);
    if ( recv_size > 0 )
      *((_BYTE *)recv_buffer + recv_size) = 0;
    memset(&send_buffer[1], 0, 124u);
    send_buffer[0] = 2181967;
    send(connection_fd, send_buffer, 4u, 0);
    parsed_port = port;
    function_result = 0;
    mutex_ptr[1].__owner = connection_fd;
    *(_DWORD *)(config_input + 128) = mutex_ptr;
    mutex_ptr[1].__lock = parsed_port;
  }
  return function_result;
}
// 11FC4: using guessed type int __fastcall _isoc99_sscanf(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 68748: using guessed type int dword_68748;
// 68750: using guessed type int dword_68750;
// 6876C: using guessed type int dword_6876C;

//----- (00043438) --------------------------------------------------------
int sub_43438()
{
  return 0;
}

//----- (00043450) --------------------------------------------------------
int __fastcall send_recv_message(int socket_fd, const void *message, size_t message_length, _DWORD *response_code)
{
  pthread_mutex_t *mutex; // r5
  int v8; // r4
  ssize_t bytes_received; // r0
  int unknown_var_1; // [sp+8h] [bp-160h] BYREF
  int parsed_response_code; // [sp+Ch] [bp-15Ch] BYREF
  int unknown_array[16]; // [sp+10h] [bp-158h] BYREF
  int receive_buffer[70]; // [sp+50h] [bp-118h] BYREF

  if ( !dword_68750 )
    return -1;
  mutex = *(pthread_mutex_t **)(socket_fd + 128);
  if ( !mutex )
    return -2;
  v8 = pthread_mutex_trylock(*(pthread_mutex_t **)(socket_fd + 128));
  if ( v8 )
    return -3;
  if ( send(mutex[1].__owner, message, message_length, 0) <= 0 )
  {
    v8 = -4;
    pthread_mutex_unlock(mutex);
  }
  else
  {
    memset(receive_buffer, 0, 256);
    bytes_received = recv(mutex[1].__owner, receive_buffer, 256u, 0);
    unknown_var_1 = 0;
    parsed_response_code = 0;
    memset(unknown_array, 0, sizeof(unknown_array));
    if ( bytes_received > 0 )
      _isoc99_sscanf(receive_buffer, &unk_546B0, &unknown_var_1, &parsed_response_code, unknown_array);
    if ( response_code )
      *response_code = parsed_response_code;
    pthread_mutex_unlock(mutex);
  }
  return v8;
}
// 11FC4: using guessed type int __fastcall _isoc99_sscanf(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 68750: using guessed type int dword_68750;

//----- (0004359C) --------------------------------------------------------
int get_status()
{
  return 0;
}

//----- (000435A4) --------------------------------------------------------
int __fastcall copy_data(void *source, size_t size, int destination)
{
  return append_data_to_buffer(destination, source, size);
}

//----- (000435B8) --------------------------------------------------------
int __fastcall append_data(void *source_data, size_t data_length, _DWORD *buffer_params)
{
  int current_length; // r12
  size_t new_length; // r3

  current_length = buffer_params[1];
  new_length = current_length + data_length;
  if ( current_length + data_length <= *buffer_params )
  {
    memcpy((void *)(buffer_params[2] + current_length), source_data, data_length);
    new_length = data_length + buffer_params[1];
  }
  buffer_params[1] = new_length;
  return 0;
}

//----- (000435FC) --------------------------------------------------------
size_t __fastcall write_data_to_file(const void *data, size_t size, FILE *file_stream)
{
  size_t write_status; // r0

  write_status = fwrite(data, size, 1u, file_stream) - 1;
  if ( write_status )
    return -1;
  return write_status;
}

//----- (00043618) --------------------------------------------------------
size_t __fastcall write_buffer(void *buffer, size_t length, int *file_descriptor)
{
  size_t write_result; // r0

  write_result = length - write(*file_descriptor, buffer, length);
  if ( write_result )
    return -1;
  return write_result;
}

//----- (00043640) --------------------------------------------------------
int __fastcall compare_strings(const char **string1_ptr, const char **string2_ptr)
{
  return strcmp(*string1_ptr, *string2_ptr);
}

//----- (0004364C) --------------------------------------------------------
int __fastcall json_escape_text(
        int start,
        int length,
        int (__fastcall *write_function)(char *, int, int),
        int write_arg,
        unsigned int flags)
{
  unsigned int end; // r8
  unsigned int current_ptr; // r10
  int next_ptr; // r5
  bool is_special_char; // zf
  int should_escape; // r1
  char *escaped_seq; // r0
  int escaped_seq_len; // r1
  unsigned int lead_surrogate; // r3
  int trail_surrogate; // [sp+0h] [bp-50h]
  int current_char; // [sp+14h] [bp-3Ch] BYREF
  char escape_buffer[56]; // [sp+18h] [bp-38h] BYREF

  current_char = 0;
  if ( write_function("\"", 1, write_arg) )
    return -1;
  end = start + length;
  for ( current_ptr = start; current_ptr < end; current_ptr = next_ptr )
  {
    next_ptr = decode_utf8_character(current_ptr, end - current_ptr, &current_char);
    if ( !next_ptr )
      return -1;
    is_special_char = current_char == 34;
    if ( current_char != 34 )
      is_special_char = current_char == 92;
    should_escape = is_special_char;
    if ( current_char <= 31 )
      should_escape |= 1u;
    if ( !should_escape && ((current_char == 47) & (flags >> 10)) == 0 && ((current_char > 127) & (flags >> 6)) == 0 )
      continue;
    if ( start != current_ptr && write_function((char *)start, current_ptr - start, write_arg) )
      return -1;
    if ( current_ptr == next_ptr )
      return write_function("\"", 1, write_arg);
    if ( current_char == 12 )
    {
      escaped_seq_len = 2;
      escaped_seq = "\\f";
      goto LABEL_26;
    }
    if ( current_char <= 12 )
    {
      switch ( current_char )
      {
        case 9:
          escaped_seq = "\\t";
          escaped_seq_len = 2;
          goto LABEL_26;
        case 10:
          escaped_seq = "\\n";
          escaped_seq_len = 2;
          goto LABEL_26;
        case 8:
          escaped_seq = "\\b";
          escaped_seq_len = 2;
          goto LABEL_26;
      }
LABEL_32:
      if ( current_char >= 65536 )
      {
        lead_surrogate = ((unsigned int)(current_char - 65536) >> 10) & 0x3FF | 0xD800;
        trail_surrogate = (current_char - 65536) & 0x3FF | 0xDC00;
        current_char -= 65536;
        snprintf(escape_buffer, 13u, "\\u%04X\\u%04X", lead_surrogate, trail_surrogate);
        escaped_seq = escape_buffer;
        escaped_seq_len = 12;
        goto LABEL_26;
      }
LABEL_33:
      snprintf(escape_buffer, 13u, "\\u%04X");
      escaped_seq = escape_buffer;
      escaped_seq_len = 6;
      goto LABEL_26;
    }
    if ( current_char == 34 )
    {
      escaped_seq = "\\\"";
      escaped_seq_len = 2;
      goto LABEL_26;
    }
    if ( current_char <= 34 )
    {
      if ( current_char == 13 )
      {
        escaped_seq = "\\r";
        escaped_seq_len = 2;
        goto LABEL_26;
      }
      goto LABEL_33;
    }
    if ( current_char == 47 )
    {
      escaped_seq = "\\/";
      escaped_seq_len = 2;
      goto LABEL_26;
    }
    if ( current_char != 92 )
      goto LABEL_32;
    escaped_seq = "\\\\";
    escaped_seq_len = 2;
LABEL_26:
    if ( write_function(escaped_seq, escaped_seq_len, write_arg) )
      return -1;
    start = next_ptr;
  }
  if ( start == current_ptr || !write_function((char *)start, current_ptr - start, write_arg) )
    return write_function("\"", 1, write_arg);
  return -1;
}
// 437EC: conditional instruction was optimized away because %var_3C.4 is in (E..21)
// 47028: using guessed type int __fastcall sub_47028(_DWORD, _DWORD, _DWORD);

//----- (000438D4) --------------------------------------------------------
int __fastcall write_padded_output(
        char flags,
        int padding_length,
        int condition_check,
        int (__fastcall *write_function)(char *, int, int),
        int write_arg)
{
  unsigned int total_padding; // r4
  int current_write_size; // r5

  if ( (flags & 0x1F) != 0 )
  {
    total_padding = (flags & 0x1F) * padding_length;
    if ( write_function("\n", 1, write_arg) )
      return -1;
    if ( total_padding )
    {
      while ( 1 )
      {
        current_write_size = total_padding >= 32 ? 32 : total_padding;
        if ( write_function("                                ", current_write_size, write_arg) )
          break;
        total_padding -= current_write_size;
        if ( !total_padding )
          return 0;
      }
      return -1;
    }
    return 0;
  }
  if ( !condition_check || (flags & 0x20) != 0 )
    return 0;
  return write_function(" ", 1, write_arg);
}

//----- (00043984) --------------------------------------------------------
int __fastcall format_and_send_address(int connection_id, const void *address_ptr, char *address_str)
{
  int data_length; // r0

  snprintf(address_str, 11u, "%p", address_ptr);
  if ( calculate_hash_and_fetch_data(connection_id, address_str) )
    return -1;
  data_length = get_config_base_address();
  return insert_or_update_node(connection_id, address_str, data_length);
}
// 44A6C: using guessed type int __fastcall sub_44A6C(_DWORD, _DWORD, _DWORD);
// 47C18: using guessed type int sub_47C18(void);

//----- (000439DC) --------------------------------------------------------
int __fastcall dump_json_from_object(
        _DWORD *object,
        int dump_options,
        int depth,
        int source_param,
        int (__fastcall *write_callback)(const char *, int, int),
        int callback_arg)
{
  int source_param_copy; // r5
  int is_compact_mode; // r8
  int filtered_dump_options; // r7
  char dump_options_copy; // r9
  char *delimiter; // r3
  int delimiter_length; // r3
  int v14; // r6
  int string_length; // r5
  int string_content; // r0
  __int64 number_value; // r0
  int number_string_size; // r0
  int formatted_size; // r1
  int next_depth; // r8
  int inner_object; // r6
  int delimiter_size; // r11
  int next_inner_object; // r9
  const char *object_key; // r10
  size_t key_length; // r0
  _DWORD *inner_object_value; // r0
  unsigned int next_index; // r9
  int next_depth_array; // r8
  int current_value; // r3
  int last_value; // r11
  unsigned int last_index; // r10
  _DWORD *nested_object; // r0
  int base_memory_addr; // r0
  int current_memory_addr; // r9
  unsigned int sort_index; // r7
  int next_inner_object_sort; // r5
  int current_sort_memory_addr; // r8
  int next_depth_sort; // r11
  unsigned int sorted_index; // r6
  const char *sorted_key; // r10
  const char *next_sorted_key; // t1
  _DWORD *sorted_object; // r9
  size_t sorted_key_length; // r0
  int compact_mode_copy; // r8
  const char *delimiter_ptr; // [sp+Ch] [bp-BCh]
  int has_children; // [sp+Ch] [bp-BCh]
  int depth_copy; // [sp+Ch] [bp-BCh]
  int delimiter_size_copy; // [sp+10h] [bp-B8h]
  int depth_copy2; // [sp+10h] [bp-B8h]
  int has_children_copy; // [sp+14h] [bp-B4h]
  int compact_mode_copy2; // [sp+14h] [bp-B4h]
  size_t sort_count; // [sp+18h] [bp-B0h]
  int depth_sort; // [sp+1Ch] [bp-ACh]
  int compact_sort; // [sp+20h] [bp-A8h]
  void *sort_base; // [sp+24h] [bp-A4h]
  int object_size; // [sp+28h] [bp-A0h]
  int compact_mode_sort; // [sp+28h] [bp-A0h]
  int initial_memory_addr; // [sp+2Ch] [bp-9Ch]
  int sorted_dump_options; // [sp+30h] [bp-98h]
  int source_param_sort; // [sp+34h] [bp-94h]
  char number_buffer[140]; // [sp+3Ch] [bp-8Ch] BYREF

  if ( !object )
    return -1;
  source_param_copy = source_param;
  is_compact_mode = dump_options & 0x10000;
  filtered_dump_options = dump_options & 0xFFFEFFFF;
  dump_options_copy = dump_options;
  switch ( *object )
  {
    case 0:
      delimiter = ":";
      if ( (dump_options & 0x20) == 0 )
        delimiter = ": ";
      delimiter_ptr = delimiter;
      if ( (dump_options & 0x20) != 0 )
        delimiter_length = 1;
      else
        delimiter_length = 2;
      delimiter_size_copy = delimiter_length;
      v14 = format_and_send_address(source_param_copy, (int)object, number_buffer);
      if ( v14 )
        return -1;
      has_children_copy = get_next_element_if_available(object);
      if ( is_compact_mode )
      {
        if ( !has_children_copy )
          goto LABEL_45;
      }
      else
      {
        if ( write_callback("{", 1, callback_arg) )
          return -1;
        if ( !has_children_copy )
        {
          remove_item_from_hash_table(source_param_copy, number_buffer);
          return write_callback("}", 1, callback_arg);
        }
      }
      if ( write_padded_output(filtered_dump_options, depth + 1, 0, write_callback, callback_arg) )
        return -1;
      if ( (dump_options_copy & 0x80) == 0 )
      {
        compact_sort = is_compact_mode;
        next_depth = depth + 1;
        inner_object = has_children_copy;
        delimiter_size = delimiter_size_copy;
        depth_copy2 = depth;
        while ( 1 )
        {
          next_inner_object = sub_475A0(object, inner_object);
          object_key = (const char *)get_adjusted_temperature(inner_object);
          key_length = strlen(object_key);
          json_escape_text(object_key, key_length, write_callback, callback_arg, filtered_dump_options);
          if ( write_callback(delimiter_ptr, delimiter_size, callback_arg) )
            return -1;
          inner_object_value = (_DWORD *)get_temperature_if_valid(inner_object);
          if ( dump_json_from_object(
                 inner_object_value,
                 filtered_dump_options,
                 next_depth,
                 source_param_copy,
                 write_callback,
                 callback_arg) )
          {
            return -1;
          }
          if ( !next_inner_object )
          {
            compact_mode_copy = compact_sort;
            v14 = 0;
            if ( write_padded_output(filtered_dump_options, depth_copy2, 0, write_callback, callback_arg) )
              return -1;
            goto LABEL_68;
          }
          if ( !write_callback((const char *)&word_4FD70, 1, callback_arg) )
          {
            inner_object = next_inner_object;
            if ( !write_padded_output(filtered_dump_options, next_depth, 1, write_callback, callback_arg) )
              continue;
          }
          return -1;
        }
      }
      object_size = get_error_or_next(object);
      base_memory_addr = get_error_description(4 * object_size);
      sort_base = (void *)base_memory_addr;
      if ( !base_memory_addr )
        return -1;
      sorted_dump_options = filtered_dump_options;
      source_param_sort = source_param_copy;
      current_memory_addr = base_memory_addr - 4;
      initial_memory_addr = base_memory_addr - 4;
      sort_index = 0;
      next_inner_object_sort = has_children_copy;
      while ( 1 )
      {
        *(_DWORD *)(current_memory_addr + 4) = get_adjusted_temperature(next_inner_object_sort);
        current_memory_addr += 4;
        next_inner_object_sort = sub_475A0(object, next_inner_object_sort);
        if ( !next_inner_object_sort )
          break;
        ++sort_index;
      }
      sort_count = sort_index + 1;
      source_param_copy = source_param_sort;
      if ( object_size != sort_index + 1 )
        _assert_fail("i == size", "dump.c", 352u, "do_dump");
      qsort(sort_base, sort_count, 4u, (__compar_fn_t)compare_strings);
      compact_mode_sort = is_compact_mode;
      current_sort_memory_addr = initial_memory_addr;
      next_depth_sort = depth + 1;
      sorted_index = 0;
      depth_sort = depth;
      do
      {
        next_sorted_key = *(const char **)(current_sort_memory_addr + 4);
        current_sort_memory_addr += 4;
        sorted_key = next_sorted_key;
        sorted_object = (_DWORD *)validate_and_fetch_data(object, next_sorted_key);
        if ( !sorted_object )
          _assert_fail("value", "dump.c", 363u, "do_dump");
        sorted_key_length = strlen(sorted_key);
        json_escape_text(sorted_key, sorted_key_length, write_callback, callback_arg, sorted_dump_options);
        if ( write_callback(delimiter_ptr, delimiter_size_copy, callback_arg)
          || dump_json_from_object(
               sorted_object,
               sorted_dump_options,
               next_depth_sort,
               source_param_sort,
               write_callback,
               callback_arg) )
        {
LABEL_64:
          v14 = -1;
          check_result_and_perform_action(sort_base);
          return v14;
        }
        if ( sorted_index < sort_index )
        {
          if ( write_callback((const char *)&word_4FD70, 1, callback_arg)
            || write_padded_output(sorted_dump_options, next_depth_sort, 1, write_callback, callback_arg) )
          {
            goto LABEL_64;
          }
        }
        else if ( write_padded_output(sorted_dump_options, depth_sort, 0, write_callback, callback_arg) )
        {
          goto LABEL_64;
        }
        ++sorted_index;
      }
      while ( sorted_index != sort_count );
      compact_mode_copy = compact_mode_sort;
      v14 = 0;
      check_result_and_perform_action(sort_base);
LABEL_68:
      remove_item_from_hash_table(source_param_copy, number_buffer);
      if ( !compact_mode_copy )
        return write_callback("}", 1, callback_arg);
      return v14;
    case 1:
      v14 = format_and_send_address(source_param, (int)object, number_buffer);
      if ( v14 )
        return -1;
      has_children = get_next_structure_pointer(object);
      if ( is_compact_mode )
      {
        if ( !has_children )
        {
LABEL_45:
          remove_item_from_hash_table(source_param_copy, number_buffer);
          return v14;
        }
      }
      else
      {
        if ( write_callback("[", 1, callback_arg) )
          return -1;
        if ( !has_children )
        {
          remove_item_from_hash_table(source_param_copy, number_buffer);
          return write_callback((const char *)&word_5434C, 1, callback_arg);
        }
      }
      next_index = write_padded_output(filtered_dump_options, depth + 1, 0, write_callback, callback_arg);
      if ( next_index )
        return -1;
      compact_mode_copy2 = is_compact_mode;
      next_depth_array = depth + 1;
      current_value = has_children;
      depth_copy = depth;
      last_value = current_value;
      last_index = current_value - 1;
      break;
    case 2:
      string_length = get_linked_item_or_null(object);
      string_content = get_associated_data(object);
      return json_escape_text(string_length, string_content, write_callback, callback_arg, filtered_dump_options);
    case 3:
      number_value = get_linked_list_next_node(object);
      number_string_size = snprintf(number_buffer, 100u, "%lld", number_value);
      return write_callback(number_buffer, number_string_size, callback_arg);
    case 4:
      sub_47B28(object);
      formatted_size = format_float_string(number_buffer, 100, (unsigned __int16)filtered_dump_options >> 11);
      if ( formatted_size < 0 )
        return -1;
      return write_callback(number_buffer, formatted_size, callback_arg);
    case 5:
      return write_callback("true", 4, callback_arg);
    case 6:
      return write_callback("false", 5, callback_arg);
    case 7:
      return write_callback("null", 4, callback_arg);
    default:
      return -1;
  }
  do
  {
    nested_object = (_DWORD *)get_task_by_index(object, next_index);
    v14 = dump_json_from_object(
            nested_object,
            filtered_dump_options,
            next_depth_array,
            source_param_copy,
            write_callback,
            callback_arg);
    if ( v14 )
      return -1;
    if ( last_index <= next_index )
    {
      if ( write_padded_output(filtered_dump_options, depth_copy, 0, write_callback, callback_arg) )
        return -1;
    }
    else if ( write_callback((const char *)&word_4FD70, 1, callback_arg)
           || write_padded_output(filtered_dump_options, next_depth_array, 1, write_callback, callback_arg) )
    {
      return -1;
    }
    ++next_index;
  }
  while ( last_value != next_index );
  remove_item_from_hash_table(source_param_copy, number_buffer);
  if ( !compact_mode_copy2 )
    return write_callback((const char *)&word_5434C, 1, callback_arg);
  return v14;
}
// 43A0C: control flows out of bounds to 43A10
// 43640: using guessed type int sub_43640();
// 4364C: using guessed type int __fastcall sub_4364C(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 438D4: using guessed type int __fastcall sub_438D4(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4693C: using guessed type int __fastcall sub_4693C(_DWORD);
// 46954: using guessed type int __fastcall sub_46954(_DWORD);
// 46CA8: using guessed type int __fastcall sub_46CA8(_DWORD, _DWORD, _DWORD);
// 472D0: using guessed type int __fastcall sub_472D0(_DWORD);
// 472EC: using guessed type int __fastcall sub_472EC(_DWORD, _DWORD);
// 47554: using guessed type int __fastcall sub_47554(_DWORD);
// 475A0: using guessed type int __fastcall sub_475A0(_DWORD, _DWORD);
// 475D4: using guessed type int __fastcall sub_475D4(_DWORD);
// 475E0: using guessed type int __fastcall sub_475E0(_DWORD);
// 47658: using guessed type int __fastcall sub_47658(_DWORD);
// 47674: using guessed type int __fastcall sub_47674(_DWORD, _DWORD);
// 47820: using guessed type int __fastcall sub_47820(_DWORD);
// 4783C: using guessed type int __fastcall sub_4783C(_DWORD);
// 47A7C: using guessed type __int64 __fastcall sub_47A7C(_DWORD);
// 47B28: using guessed type int __fastcall sub_47B28(_DWORD);
// 4FD70: using guessed type __int16 word_4FD70;
// 5434C: using guessed type __int16 word_5434C;

//----- (000441EC) --------------------------------------------------------
int __fastcall generate_resource_json(
        _DWORD *resource_object,
        int (__fastcall *write_function)(const char *, int, int),
        int write_arg,
        int flags)
{
  int result_status; // r4
  char temp_buffer[52]; // [sp+Ch] [bp-34h] BYREF

  if ( (flags & 0x200) == 0 && (!resource_object || *resource_object > 1u)
    || initialize_miner_data_structure(temp_buffer) )
  {
    return -1;
  }
  result_status = dump_json_from_object(resource_object, flags, 0, (int)temp_buffer, write_function, write_arg);
  update_and_get_miner_status(temp_buffer);
  return result_status;
}
// 449D8: using guessed type int __fastcall sub_449D8(_DWORD);
// 44A54: using guessed type int __fastcall sub_44A54(_DWORD);

//----- (00044264) --------------------------------------------------------
int __fastcall generate_config_json(_DWORD *output_buffer, int data_size)
{
  int v4; // r4
  int init_status; // r0
  char context_buffer[28]; // [sp+4h] [bp-1Ch] BYREF

  v4 = set_initial_error_state(context_buffer);
  if ( v4 )
    return 0;
  if ( !generate_resource_json(
          output_buffer,
          (int (__fastcall *)(const char *, int, int))copy_data,
          (int)context_buffer,
          data_size) )
  {
    init_status = get_first_int_from_pointer(context_buffer);
    v4 = copy_string_with_null_termination(init_status);
  }
  reset_and_perform_action_if_needed(context_buffer);
  return v4;
}
// 469B8: using guessed type int __fastcall sub_469B8(_DWORD);
// 46A10: using guessed type int __fastcall sub_46A10(_DWORD);
// 46A44: using guessed type int __fastcall sub_46A44(_DWORD);
// 46A84: using guessed type int __fastcall sub_46A84(_DWORD);

//----- (0004430C) --------------------------------------------------------
int __fastcall generate_resource_json_wrapper(_DWORD *data, int resource_id, int flags)
{
  return generate_resource_json(
           data,
           (int (__fastcall *)(const char *, int, int))write_data_to_file,
           resource_id,
           flags);
}

//----- (00044320) --------------------------------------------------------
int __fastcall write_config_file(int config_data, int file_path, int data_length)
{
  FILE *file_handle; // r4
  int write_result; // r5

  file_handle = (FILE *)fopen64(file_path, "w");
  if ( !file_handle )
    return -1;
  write_result = generate_resource_json(config_data, write_data_to_file, file_handle, data_length);
  if ( fclose(file_handle) )
    return -1;
  return write_result;
}
// 1224C: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 441EC: using guessed type int __fastcall sub_441EC(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00044384) --------------------------------------------------------
int __fastcall generate_resource_details_json(_DWORD *resource_data, int resource_id, int additional_data)
{
  int resource_id_ref; // [sp+4h] [bp-Ch] BYREF

  resource_id_ref = resource_id;
  return generate_resource_json(
           resource_data,
           (int (__fastcall *)(const char *, int, int))write_buffer,
           (int)&resource_id_ref,
           additional_data);
}

//----- (000443B0) --------------------------------------------------------
int __fastcall hash_calculate(unsigned __int16 *data, unsigned int length, int initial_hash_value)
{
  unsigned int hash_value; // r12
  unsigned __int16 *data_ptr; // r4
  int acc_a; // r3
  int acc_b; // lr
  int chunk_value_1; // r6
  int chunk_value_2; // r5
  int temp_a; // r3
  int temp_b; // lr
  int result_1; // r2
  int result_2; // r3
  int result_3; // r5
  int result_4; // r2
  int result_5; // r12
  int result_6; // r2
  int result_7; // lr
  int result_8; // r3
  int result_9; // r2
  int result_10; // r2
  int result_11; // r3
  unsigned __int16 *data_halfword_ptr; // r4
  int half_chunk_val_1; // r6
  int half_chunk_val_2; // r5
  int half_chunk_val_3; // r7
  int half_chunk_val_4; // r2
  int half_temp_a; // r3
  int half_result_1; // r12
  int half_temp_b; // lr
  int half_result_2; // r2
  int half_result_3; // lr
  int half_result_4; // r3
  int half_result_5; // r12
  int half_result_6; // r2
  int half_result_7; // r5
  int half_result_8; // r2
  int half_result_9; // r3
  int half_result_10; // r2
  unsigned __int16 *data_byte_ptr; // r4
  int byte_chunk_val_1; // r6
  int byte_chunk_val_2; // r2
  int byte_chunk_val_3; // r7
  int byte_chunk_val_4; // r8
  int byte_temp_a; // r3
  int byte_result_1; // r12
  int byte_temp_b; // lr
  int byte_result_2; // r2
  int byte_result_3; // lr
  int byte_result_4; // r3
  int byte_result_5; // r12
  int byte_result_6; // r2
  int byte_result_7; // r5
  int byte_result_8; // r2
  int byte_result_9; // r3
  int byte_result_10; // r2
  int final_hash_value; // r12
  int final_acc_a; // r3
  int final_acc_b; // r12
  int final_result_1; // lr
  int final_result_2; // r3
  int final_result_3; // r12
  int final_result_4; // r12
  int switch_temp_val; // r4

  hash_value = initial_hash_value - 559038737 + length;
  if ( ((unsigned __int8)data & 3) == 0 )
  {
    if ( length <= 12 )
    {
      acc_a = initial_hash_value - 559038737 + length;
      acc_b = acc_a;
    }
    else
    {
      data_ptr = data + 6;
      acc_a = initial_hash_value - 559038737 + length;
      acc_b = acc_a;
      do
      {
        length -= 12;
        chunk_value_1 = *((_DWORD *)data_ptr - 3);
        chunk_value_2 = *((_DWORD *)data_ptr - 2);
        data = data_ptr;
        temp_a = acc_a + *((_DWORD *)data_ptr - 1);
        data_ptr += 6;
        temp_b = acc_b + chunk_value_2;
        result_1 = (chunk_value_1 - temp_a + hash_value) ^ __ROR4__(temp_a, 28);
        result_2 = temp_b + temp_a;
        result_3 = result_1 + result_2;
        result_4 = (temp_b - result_1) ^ __ROR4__(result_1, 26);
        result_5 = result_4 + result_3;
        result_6 = (result_2 - result_4) ^ __ROR4__(result_4, 24);
        result_7 = result_6 + result_5;
        result_8 = (result_3 - result_6) ^ __ROR4__(result_6, 16);
        result_9 = result_5 - result_8;
        hash_value = result_8 + result_7;
        result_10 = result_9 ^ __ROR4__(result_8, 13);
        result_11 = result_7 - result_10;
        acc_b = result_10 + hash_value;
        acc_a = result_11 ^ __ROR4__(result_10, 28);
      }
      while ( length > 12 );
    }
    switch ( length )
    {
      case 1u:
        goto LABEL_27;
      case 2u:
        goto LABEL_32;
      case 3u:
        final_hash_value = (*(_DWORD *)data & 0xFFFFFF) + hash_value;
        goto LABEL_28;
      case 4u:
        final_hash_value = hash_value + *(_DWORD *)data;
        goto LABEL_28;
      case 5u:
        acc_b += *((unsigned __int8 *)data + 4);
        final_hash_value = hash_value + *(_DWORD *)data;
        goto LABEL_28;
      case 6u:
        acc_b += data[2];
        final_hash_value = hash_value + *(_DWORD *)data;
        goto LABEL_28;
      case 7u:
        final_hash_value = hash_value + *(_DWORD *)data;
        acc_b += *((_DWORD *)data + 1) & 0xFFFFFF;
        goto LABEL_28;
      case 8u:
        acc_b += *((_DWORD *)data + 1);
        final_hash_value = hash_value + *(_DWORD *)data;
        goto LABEL_28;
      case 9u:
        switch_temp_val = *((unsigned __int8 *)data + 8);
        goto LABEL_35;
      case 10u:
        switch_temp_val = data[4];
        goto LABEL_35;
      case 11u:
        acc_a += *((_DWORD *)data + 2) & 0xFFFFFF;
        acc_b += *((_DWORD *)data + 1);
        final_hash_value = hash_value + *(_DWORD *)data;
        goto LABEL_28;
      case 12u:
        switch_temp_val = *((_DWORD *)data + 2);
LABEL_35:
        acc_a += switch_temp_val;
        acc_b += *((_DWORD *)data + 1);
        final_hash_value = hash_value + *(_DWORD *)data;
        goto LABEL_28;
      default:
        return acc_a;
    }
  }
  if ( ((unsigned __int8)data & 1) == 0 )
  {
    if ( length <= 12 )
    {
      acc_a = initial_hash_value - 559038737 + length;
      acc_b = acc_a;
    }
    else
    {
      data_halfword_ptr = data + 6;
      acc_a = initial_hash_value - 559038737 + length;
      acc_b = acc_a;
      do
      {
        half_chunk_val_1 = *(data_halfword_ptr - 1);
        length -= 12;
        half_chunk_val_2 = *(data_halfword_ptr - 2);
        half_chunk_val_3 = *(data_halfword_ptr - 5);
        data = data_halfword_ptr;
        half_chunk_val_4 = *(data_halfword_ptr - 6);
        data_halfword_ptr += 6;
        half_temp_a = half_chunk_val_2 + (half_chunk_val_1 << 16) + acc_a;
        half_result_1 = (half_chunk_val_4 + (half_chunk_val_3 << 16) - half_temp_a + hash_value) ^ __ROR4__(
                                                                                                     half_temp_a,
                                                                                                     28);
        half_temp_b = *(data_halfword_ptr - 10) + (*(data_halfword_ptr - 9) << 16) + acc_b;
        half_result_2 = half_temp_b - half_result_1;
        half_result_3 = half_temp_b + half_temp_a;
        half_result_4 = half_result_2 ^ __ROR4__(half_result_1, 26);
        half_result_5 = half_result_1 + half_result_3;
        half_result_6 = (half_result_3 - half_result_4) ^ __ROR4__(half_result_4, 24);
        half_result_7 = half_result_6 + half_result_4 + half_result_5;
        half_result_8 = (half_result_5 - half_result_6) ^ __ROR4__(half_result_6, 16);
        half_result_9 = half_result_4 + half_result_5 - half_result_8;
        hash_value = half_result_8 + half_result_7;
        half_result_10 = half_result_9 ^ __ROR4__(half_result_8, 13);
        acc_b = half_result_10 + hash_value;
        acc_a = (half_result_7 - half_result_10) ^ __ROR4__(half_result_10, 28);
      }
      while ( length > 12 );
    }
    switch ( length )
    {
      case 1u:
        goto LABEL_27;
      case 2u:
        goto LABEL_32;
      case 3u:
        hash_value += *((unsigned __int8 *)data + 2) << 16;
LABEL_32:
        final_hash_value = *data + hash_value;
        goto LABEL_28;
      case 4u:
        goto LABEL_50;
      case 5u:
        acc_b += *((unsigned __int8 *)data + 4);
LABEL_50:
        final_hash_value = *data + hash_value + (data[1] << 16);
        goto LABEL_28;
      case 6u:
        goto LABEL_44;
      case 7u:
        acc_b += *((unsigned __int8 *)data + 6) << 16;
LABEL_44:
        final_hash_value = *data + hash_value + (data[1] << 16);
        acc_b += data[2];
        goto LABEL_28;
      case 8u:
        goto LABEL_46;
      case 9u:
        acc_a += *((unsigned __int8 *)data + 8);
LABEL_46:
        acc_b += data[2] + (data[3] << 16);
        final_hash_value = *data + hash_value + (data[1] << 16);
        goto LABEL_28;
      case 10u:
        goto LABEL_48;
      case 11u:
        acc_a += *((unsigned __int8 *)data + 10) << 16;
LABEL_48:
        acc_b += data[2] + (data[3] << 16);
        final_hash_value = *data + hash_value + (data[1] << 16);
        acc_a += data[4];
        goto LABEL_28;
      case 12u:
        acc_a += data[4] + (data[5] << 16);
        acc_b += data[2] + (data[3] << 16);
        final_hash_value = *data + hash_value + (data[1] << 16);
        goto LABEL_28;
      default:
        return acc_a;
    }
  }
  if ( length > 12 )
  {
    data_byte_ptr = data + 6;
    acc_a = initial_hash_value - 559038737 + length;
    acc_b = acc_a;
    do
    {
      byte_chunk_val_1 = *((unsigned __int8 *)data_byte_ptr - 2);
      length -= 12;
      byte_chunk_val_2 = *((unsigned __int8 *)data_byte_ptr - 10);
      byte_chunk_val_3 = *((unsigned __int8 *)data_byte_ptr - 3);
      data = data_byte_ptr;
      byte_chunk_val_4 = *((unsigned __int8 *)data_byte_ptr - 11);
      data_byte_ptr += 6;
      byte_temp_a = (byte_chunk_val_1 << 16)
                  + (byte_chunk_val_3 << 8)
                  + *((unsigned __int8 *)data_byte_ptr - 16)
                  + (*((unsigned __int8 *)data_byte_ptr - 13) << 24)
                  + acc_a;
      byte_result_1 = ((byte_chunk_val_2 << 16)
                     + (byte_chunk_val_4 << 8)
                     + *((unsigned __int8 *)data_byte_ptr - 24)
                     + (*((unsigned __int8 *)data_byte_ptr - 21) << 24)
                     - byte_temp_a
                     + hash_value) ^ __ROR4__(byte_temp_a, 28);
      byte_temp_b = (*((unsigned __int8 *)data_byte_ptr - 18) << 16)
                  + (*((unsigned __int8 *)data_byte_ptr - 19) << 8)
                  + *((unsigned __int8 *)data_byte_ptr - 20)
                  + (*((unsigned __int8 *)data_byte_ptr - 17) << 24)
                  + acc_b;
      byte_result_2 = byte_temp_b - byte_result_1;
      byte_result_3 = byte_temp_b + byte_temp_a;
      byte_result_4 = byte_result_2 ^ __ROR4__(byte_result_1, 26);
      byte_result_5 = byte_result_1 + byte_result_3;
      byte_result_6 = (byte_result_3 - byte_result_4) ^ __ROR4__(byte_result_4, 24);
      byte_result_7 = byte_result_6 + byte_result_4 + byte_result_5;
      byte_result_8 = (byte_result_5 - byte_result_6) ^ __ROR4__(byte_result_6, 16);
      byte_result_9 = byte_result_4 + byte_result_5 - byte_result_8;
      hash_value = byte_result_8 + byte_result_7;
      byte_result_10 = byte_result_9 ^ __ROR4__(byte_result_8, 13);
      acc_b = byte_result_10 + hash_value;
      acc_a = (byte_result_7 - byte_result_10) ^ __ROR4__(byte_result_10, 28);
    }
    while ( length > 12 );
  }
  else
  {
    acc_a = initial_hash_value - 559038737 + length;
    acc_b = acc_a;
  }
  switch ( length )
  {
    case 1u:
      goto LABEL_27;
    case 2u:
      goto LABEL_26;
    case 3u:
      goto LABEL_25;
    case 4u:
      goto LABEL_24;
    case 5u:
      goto LABEL_23;
    case 6u:
      goto LABEL_22;
    case 7u:
      goto LABEL_21;
    case 8u:
      goto LABEL_20;
    case 9u:
      goto LABEL_19;
    case 10u:
      goto LABEL_18;
    case 11u:
      goto LABEL_17;
    case 12u:
      acc_a += *((unsigned __int8 *)data + 11) << 24;
LABEL_17:
      acc_a += *((unsigned __int8 *)data + 10) << 16;
LABEL_18:
      acc_a += *((unsigned __int8 *)data + 9) << 8;
LABEL_19:
      acc_a += *((unsigned __int8 *)data + 8);
LABEL_20:
      acc_b += *((unsigned __int8 *)data + 7) << 24;
LABEL_21:
      acc_b += *((unsigned __int8 *)data + 6) << 16;
LABEL_22:
      acc_b += *((unsigned __int8 *)data + 5) << 8;
LABEL_23:
      acc_b += *((unsigned __int8 *)data + 4);
LABEL_24:
      hash_value += *((unsigned __int8 *)data + 3) << 24;
LABEL_25:
      hash_value += *((unsigned __int8 *)data + 2) << 16;
LABEL_26:
      hash_value += *((unsigned __int8 *)data + 1) << 8;
LABEL_27:
      final_hash_value = *(unsigned __int8 *)data + hash_value;
LABEL_28:
      final_acc_a = (acc_a ^ acc_b) - __ROR4__(acc_b, 18);
      final_acc_b = (final_hash_value ^ final_acc_a) - __ROR4__(final_acc_a, 21);
      final_result_1 = (acc_b ^ final_acc_b) - __ROR4__(final_acc_b, 7);
      final_result_2 = (final_acc_a ^ final_result_1) - __ROR4__(final_result_1, 16);
      final_result_3 = (final_acc_b ^ final_result_2) - __ROR4__(final_result_2, 28);
      final_result_4 = (final_result_1 ^ final_result_3) - __ROR4__(final_result_3, 18);
      acc_a = (final_result_2 ^ final_result_4) - __ROR4__(final_result_4, 8);
      break;
    default:
      return acc_a;
  }
  return acc_a;
}
// 44460: control flows out of bounds to 44464
// 44548: control flows out of bounds to 4454C
// 4466C: control flows out of bounds to 44670

//----- (000448F4) --------------------------------------------------------
int __fastcall find_target_entry(int base_offset, int *entry_pointers, char *target_name, int target_id)
{
  int current_entry; // r4

  current_entry = *entry_pointers;
  if ( *entry_pointers == base_offset + 12 && current_entry == entry_pointers[1] )
    return 0;
  while ( *(_DWORD *)(current_entry + 16) != target_id || strcmp((const char *)(current_entry + 24), target_name) )
  {
    if ( entry_pointers[1] == current_entry )
      return 0;
    current_entry = *(_DWORD *)(current_entry + 4);
  }
  return current_entry;
}

//----- (00044968) --------------------------------------------------------
int __fastcall update_miner_reference_count(int start_node)
{
  int end_node; // r6
  int current_node; // r4
  _DWORD *current_miner; // r0
  int next_node; // r5
  unsigned int *current_miner_ref_count; // r3
  unsigned int current_ref_count; // r2
  unsigned int updated_ref_count; // r2
  int temp_node; // r0

  end_node = start_node + 12;
  current_node = *(_DWORD *)(start_node + 16);
  if ( current_node != start_node + 12 )
  {
    do
    {
      current_miner = *(_DWORD **)(current_node + 20);
      next_node = *(_DWORD *)(current_node + 4);
      if ( current_miner )
      {
        current_miner_ref_count = current_miner + 1;
        if ( current_miner[1] != -1 )
        {
          __dmb(11u);
          do
          {
            current_ref_count = __ldrex(current_miner_ref_count);
            updated_ref_count = current_ref_count - 1;
          }
          while ( __strex(updated_ref_count, current_miner_ref_count) );
          if ( !updated_ref_count )
            process_bitmain_miner(current_miner);
        }
      }
      temp_node = current_node;
      current_node = next_node;
      start_node = check_result_and_perform_action(temp_node);
    }
    while ( next_node != end_node );
  }
  return start_node;
}
// 46954: using guessed type int __fastcall sub_46954(_DWORD);

//----- (000449D8) --------------------------------------------------------
int __fastcall initialize_miner_data_structure(_DWORD *miner_data)
{
  _DWORD *allocated_memory; // r0
  int chain_count; // r12
  _DWORD *next_element_pointer; // r3
  _DWORD *end_of_allocated_memory; // r2

  *miner_data = 0;
  miner_data[2] = 3;
  allocated_memory = (_DWORD *)get_error_description(64);
  miner_data[1] = allocated_memory;
  if ( !allocated_memory )
    return -1;
  chain_count = miner_data[2];
  next_element_pointer = miner_data + 3;
  miner_data[4] = miner_data + 3;
  miner_data[3] = miner_data + 3;
  miner_data[6] = miner_data + 5;
  miner_data[5] = miner_data + 5;
  if ( 1 << chain_count )
  {
    end_of_allocated_memory = (_DWORD *)((char *)allocated_memory + (8 << chain_count));
    do
    {
      allocated_memory[1] = next_element_pointer;
      *allocated_memory = next_element_pointer;
      allocated_memory += 2;
    }
    while ( allocated_memory != end_of_allocated_memory );
  }
  return 0;
}
// 4693C: using guessed type int __fastcall sub_4693C(_DWORD);

//----- (00044A54) --------------------------------------------------------
int __fastcall update_and_get_miner_status(int miner_data_ptr)
{
  update_miner_reference_count(miner_data_ptr);
  return check_result_and_perform_action(*(_DWORD *)(miner_data_ptr + 4));
}
// 46954: using guessed type int __fastcall sub_46954(_DWORD);

//----- (00044A6C) --------------------------------------------------------
int __fastcall insert_or_update_node(int *bitmain_hashtable, char *node_key, int node_value)
{
  int hash_bits; // r8
  int new_hash_bits; // r8
  int new_table_ptr; // r5
  int *end_of_table; // r1
  int **current_entry; // r3
  int *current_node; // r3
  int hash_mask; // r8
  int existing_hash_value; // lr
  int *next_node; // r12
  int hash_index; // r0
  int *first_node_in_bucket; // r2
  int **bucket_ptr; // r0
  int first_node; // r2
  unsigned int key_length; // r10
  int hash_value; // r9
  int *bucket; // r5
  int existing_node_ptr; // r0
  int node_to_update; // r8
  _DWORD *existing_data; // r0
  unsigned int *ref_count_ptr; // r3
  unsigned int current_ref_count; // r2
  unsigned int new_ref_count; // r2
  int result; // r0
  int error_description; // r0
  int *v30; // r8
  int *v31; // r3
  int v32; // r2
  int v33; // r1
  int v34; // r3

  hash_bits = bitmain_hashtable[2];
  if ( (unsigned int)*bitmain_hashtable >> hash_bits )
  {
    new_hash_bits = hash_bits + 1;
    new_table_ptr = get_error_description(8 << new_hash_bits);
    if ( !new_table_ptr )
      return -1;
    check_result_and_perform_action(bitmain_hashtable[1]);
    bitmain_hashtable[1] = new_table_ptr;
    bitmain_hashtable[2] = new_hash_bits;
    end_of_table = bitmain_hashtable + 3;
    if ( 1 << new_hash_bits )
    {
      current_entry = (int **)new_table_ptr;
      do
      {
        current_entry[1] = end_of_table;
        *current_entry = end_of_table;
        current_entry += 2;
      }
      while ( (int **)((8 << new_hash_bits) + new_table_ptr) != current_entry );
    }
    current_node = (int *)bitmain_hashtable[4];
    bitmain_hashtable[3] = (int)end_of_table;
    hash_mask = ~(-1 << new_hash_bits);
    bitmain_hashtable[4] = (int)end_of_table;
    if ( current_node != end_of_table )
    {
      do
      {
        while ( 1 )
        {
          next_node = (int *)current_node[1];
          hash_index = current_node[4] & hash_mask;
          first_node_in_bucket = *(int **)(new_table_ptr + 8 * hash_index);
          bucket_ptr = (int **)(new_table_ptr + 8 * hash_index);
          if ( first_node_in_bucket == end_of_table && end_of_table == bucket_ptr[1] )
            break;
          existing_hash_value = *first_node_in_bucket;
          current_node[1] = (int)first_node_in_bucket;
          *current_node = existing_hash_value;
          *(_DWORD *)(*first_node_in_bucket + 4) = current_node;
          *first_node_in_bucket = (int)current_node;
          *bucket_ptr = current_node;
          current_node = next_node;
          if ( next_node == end_of_table )
            goto LABEL_12;
        }
        first_node = bitmain_hashtable[3];
        current_node[1] = (int)end_of_table;
        *current_node = first_node;
        *(_DWORD *)(bitmain_hashtable[3] + 4) = current_node;
        bitmain_hashtable[3] = (int)current_node;
        bucket_ptr[1] = current_node;
        *bucket_ptr = current_node;
        current_node = next_node;
      }
      while ( next_node != end_of_table );
LABEL_12:
      new_table_ptr = bitmain_hashtable[1];
      hash_mask = ~(-1 << bitmain_hashtable[2]);
    }
  }
  else
  {
    new_table_ptr = bitmain_hashtable[1];
    hash_mask = ~(-1 << hash_bits);
  }
  key_length = strlen(node_key);
  hash_value = hash_calculate((unsigned __int16 *)node_key, key_length, dword_70B70);
  bucket = (int *)(new_table_ptr + 8 * (hash_mask & hash_value));
  existing_node_ptr = find_target_entry((int)bitmain_hashtable, bucket, node_key, hash_value);
  node_to_update = existing_node_ptr;
  if ( existing_node_ptr )
  {
    existing_data = *(_DWORD **)(existing_node_ptr + 20);
    if ( existing_data && existing_data[1] != -1 )
    {
      ref_count_ptr = existing_data + 1;
      __dmb(11u);
      do
      {
        current_ref_count = __ldrex(ref_count_ptr);
        new_ref_count = current_ref_count - 1;
      }
      while ( __strex(new_ref_count, ref_count_ptr) );
      if ( !new_ref_count )
        process_bitmain_miner(existing_data);
    }
    *(_DWORD *)(node_to_update + 20) = node_value;
    return 0;
  }
  error_description = get_error_description(key_length + 25);
  v30 = (int *)error_description;
  if ( !error_description )
    return -1;
  *(_DWORD *)(error_description + 16) = hash_value;
  strncpy((char *)(error_description + 24), node_key, key_length + 1);
  v31 = (int *)*bucket;
  v32 = (int)(v30 + 2);
  v30[5] = node_value;
  v30[1] = (int)v30;
  *v30 = (int)v30;
  v30[3] = (int)(v30 + 2);
  v30[2] = (int)(v30 + 2);
  if ( v31 == bitmain_hashtable + 3 && v31 == (int *)bucket[1] )
  {
    *v30 = bitmain_hashtable[3];
    v30[1] = (int)v31;
    *(_DWORD *)(bitmain_hashtable[3] + 4) = v30;
    bitmain_hashtable[3] = (int)v30;
    bucket[1] = (int)v30;
    *bucket = (int)v30;
  }
  else
  {
    *v30 = *v31;
    v30[1] = (int)v31;
    *(_DWORD *)(*v31 + 4) = v30;
    *v31 = (int)v30;
    *bucket = (int)v30;
  }
  v33 = bitmain_hashtable[5];
  v34 = *bitmain_hashtable;
  result = 0;
  v30[3] = (int)(bitmain_hashtable + 5);
  v30[2] = v33;
  *(_DWORD *)(bitmain_hashtable[5] + 4) = v32;
  bitmain_hashtable[5] = v32;
  *bitmain_hashtable = v34 + 1;
  return result;
}
// 70B70: using guessed type int dword_70B70;

//----- (00044D00) --------------------------------------------------------
int __fastcall calculate_hash_and_fetch_data(int data_structure_ptr, char *input_string)
{
  unsigned int input_string_length; // r0
  int hash_value; // r0
  int lookup_result; // r0

  input_string_length = strlen(input_string);
  hash_value = hash_calculate((unsigned __int16 *)input_string, input_string_length, dword_70B70);
  lookup_result = find_target_entry(
                    data_structure_ptr,
                    (int *)(*(_DWORD *)(data_structure_ptr + 4)
                          + 8 * (hash_value & ~(-1 << *(_DWORD *)(data_structure_ptr + 8)))),
                    input_string,
                    hash_value);
  if ( lookup_result )
    return *(_DWORD *)(lookup_result + 20);
  return lookup_result;
}
// 70B70: using guessed type int dword_70B70;

//----- (00044D60) --------------------------------------------------------
int __fastcall remove_item_from_hash_table(_DWORD *hash_table, char *item_key)
{
  unsigned int key_length; // r0
  int hash_value; // r0
  int items_array; // r9
  int index; // r5
  int *target_bucket; // r7
  _DWORD *target_item; // r0
  _DWORD *target_node; // r4
  _DWORD *next_node; // r1
  int node_next; // r2
  int node_previous; // r3
  int *next_node_ptr; // r1
  int next_node_third_value; // r2
  _DWORD *target_node_fifth_value; // r0
  int target_node_second_value; // r3
  int function_result; // r0
  unsigned int *reference_counter; // r3
  unsigned int current_count; // r2
  unsigned int updated_count; // r2
  bool is_last_node; // zf

  key_length = strlen(item_key);
  hash_value = hash_calculate((unsigned __int16 *)item_key, key_length, dword_70B70);
  items_array = hash_table[1];
  index = hash_value & ~(-1 << hash_table[2]);
  target_bucket = (int *)(items_array + 8 * index);
  target_item = (_DWORD *)find_target_entry((int)hash_table, target_bucket, item_key, hash_value);
  target_node = target_item;
  if ( !target_item )
    return -1;
  next_node = (_DWORD *)target_bucket[1];
  node_next = target_item[1];
  node_previous = *target_item;
  if ( target_item == *(_DWORD **)(items_array + 8 * index) )
  {
    is_last_node = target_item == next_node;
    if ( target_item == next_node )
      next_node = hash_table + 3;
    else
      *(_DWORD *)(items_array + 8 * index) = node_next;
    if ( is_last_node )
    {
      target_bucket[1] = (int)next_node;
      *(_DWORD *)(items_array + 8 * index) = next_node;
    }
  }
  else if ( target_item == next_node )
  {
    target_bucket[1] = node_previous;
  }
  *(_DWORD *)(node_previous + 4) = node_next;
  next_node_ptr = (int *)target_item[1];
  next_node_third_value = target_item[3];
  target_node_fifth_value = (_DWORD *)target_item[5];
  *next_node_ptr = node_previous;
  target_node_second_value = target_node[2];
  *(_DWORD *)(target_node_second_value + 4) = next_node_third_value;
  *(_DWORD *)target_node[3] = target_node_second_value;
  if ( target_node_fifth_value && target_node_fifth_value[1] != -1 )
  {
    reference_counter = target_node_fifth_value + 1;
    __dmb(11u);
    do
    {
      current_count = __ldrex(reference_counter);
      updated_count = current_count - 1;
    }
    while ( __strex(updated_count, reference_counter) );
    if ( !updated_count )
      process_bitmain_miner(target_node_fifth_value);
  }
  check_result_and_perform_action(target_node);
  function_result = 0;
  --*hash_table;
  return function_result;
}
// 46954: using guessed type int __fastcall sub_46954(_DWORD);
// 70B70: using guessed type int dword_70B70;

//----- (00044E80) --------------------------------------------------------
int __fastcall initialize_data_structure(_DWORD *miner_data)
{
  _DWORD *data_array_base; // r2
  int data_array_size_factor; // r0
  _DWORD *current_data_element; // r3
  _DWORD *end_data_pointer; // r1

  update_miner_reference_count((int)miner_data);
  data_array_base = miner_data + 3;
  data_array_size_factor = miner_data[2];
  if ( 1 << data_array_size_factor )
  {
    current_data_element = (_DWORD *)miner_data[1];
    end_data_pointer = (_DWORD *)((char *)current_data_element + (8 << data_array_size_factor));
    do
    {
      current_data_element[1] = data_array_base;
      *current_data_element = data_array_base;
      current_data_element += 2;
    }
    while ( current_data_element != end_data_pointer );
  }
  miner_data[4] = data_array_base;
  miner_data[3] = data_array_base;
  miner_data[6] = miner_data + 5;
  miner_data[5] = miner_data + 5;
  *miner_data = 0;
  return data_array_size_factor;
}

//----- (00044EDC) --------------------------------------------------------
int __fastcall get_next_element(int current_element)
{
  if ( *(_DWORD *)(current_element + 24) == current_element + 20 )
    return 0;
  else
    return *(_DWORD *)(current_element + 24);
}

//----- (00044EF4) --------------------------------------------------------
int __fastcall add_string_to_hash_table(int hash_table_ptr, char *input_string)
{
  unsigned int input_length; // r0
  int hash_value; // r0
  int entry_ptr; // r0

  input_length = strlen(input_string);
  hash_value = hash_calculate((unsigned __int16 *)input_string, input_length, dword_70B70);
  entry_ptr = find_target_entry(
                hash_table_ptr,
                (int *)(*(_DWORD *)(hash_table_ptr + 4) + 8 * (hash_value & ~(-1 << *(_DWORD *)(hash_table_ptr + 8)))),
                input_string,
                hash_value);
  if ( entry_ptr )
    entry_ptr += 8;
  return entry_ptr;
}
// 70B70: using guessed type int dword_70B70;

//----- (00044F54) --------------------------------------------------------
int __fastcall check_status(int base_value, int status_ptr)
{
  if ( *(_DWORD *)(status_ptr + 4) == base_value + 20 )
    return 0;
  else
    return *(_DWORD *)(status_ptr + 4);
}

//----- (00044F6C) --------------------------------------------------------
int __fastcall get_temperature_offset(int temperature_raw)
{
  return temperature_raw + 16;
}

//----- (00044F74) --------------------------------------------------------
int __fastcall get_temperature_value(int temperature_struct_pointer)
{
  return *(_DWORD *)(temperature_struct_pointer + 12);
}

//----- (00044F7C) --------------------------------------------------------
_DWORD *__fastcall update_miner_process(int process_ptr, int new_value)
{
  _DWORD *current_process; // r0
  unsigned int *process_counter_ptr; // r3
  unsigned int current_count; // r2
  unsigned int updated_count; // r2

  current_process = *(_DWORD **)(process_ptr + 12);
  if ( !current_process )
    goto LABEL_6;
  if ( current_process[1] == -1 )
    goto LABEL_6;
  process_counter_ptr = current_process + 1;
  __dmb(11u);
  do
  {
    current_count = __ldrex(process_counter_ptr);
    updated_count = current_count - 1;
  }
  while ( __strex(updated_count, process_counter_ptr) );
  if ( updated_count )
  {
LABEL_6:
    *(_DWORD *)(process_ptr + 12) = new_value;
  }
  else
  {
    current_process = process_bitmain_miner(current_process);
    *(_DWORD *)(process_ptr + 12) = new_value;
  }
  return current_process;
}

//----- (00044FE8) --------------------------------------------------------
int __fastcall generate_unique_id(int unique_id)
{
  int random_value; // r1
  unsigned __int8 lock_acquired; // r2
  int is_initialized; // r3
  int urandom_fd; // r0
  int urandom_file_descriptor; // r5
  ssize_t bytes_read; // r7
  int seed_value; // r5
  struct timeval time_struct; // [sp+0h] [bp-20h] BYREF

  if ( !dword_70B70 )
  {
    random_value = unique_id;
    unique_id = 1;
    do
      lock_acquired = __ldrex((unsigned __int8 *)algn_70B74);
    while ( __strex(1u, (unsigned __int8 *)algn_70B74) );
    if ( lock_acquired )
    {
      do
      {
        unique_id = sched_yield();
        is_initialized = dword_70B70;
        __dmb(11u);
      }
      while ( !is_initialized );
    }
    else
    {
      if ( !random_value )
      {
        urandom_fd = open64("/dev/urandom");
        urandom_file_descriptor = urandom_fd;
        if ( urandom_fd == -1
          || (bytes_read = read(urandom_fd, &time_struct, 4u), close(urandom_file_descriptor), bytes_read != 4) )
        {
          gettimeofday(&time_struct, 0);
          seed_value = time_struct.tv_usec ^ time_struct.tv_sec;
          unique_id = getpid();
          random_value = unique_id ^ seed_value;
        }
        else
        {
          unique_id = LOBYTE(time_struct.tv_sec);
          random_value = HIBYTE(time_struct.tv_sec) | ((BYTE2(time_struct.tv_sec) | ((BYTE1(time_struct.tv_sec) | (LOBYTE(time_struct.tv_sec) << 8)) << 8)) << 8);
        }
        if ( !random_value )
          random_value = 1;
      }
      __dmb(11u);
      dword_70B70 = random_value;
    }
  }
  return unique_id;
}
// 122E8: using guessed type int __fastcall open64(_DWORD);
// 70B70: using guessed type int dword_70B70;

//----- (000450E4) --------------------------------------------------------
int __fastcall sub_450E4(_DWORD *buffer_info)
{
  int current_position; // r2
  int next_byte; // r3
  bool is_end_of_buffer; // zf

  current_position = buffer_info[1];
  next_byte = *(unsigned __int8 *)(*buffer_info + current_position);
  is_end_of_buffer = next_byte == 0;
  if ( *(_BYTE *)(*buffer_info + current_position) )
    ++current_position;
  else
    next_byte = -1;
  if ( !is_end_of_buffer )
    buffer_info[1] = current_position;
  return next_byte;
}

//----- (00045108) --------------------------------------------------------
int __fastcall get_next_byte(int input_ptr)
{
  __int64 current_position; // r2

  current_position = *(_QWORD *)(input_ptr + 4);
  if ( HIDWORD(current_position) >= (unsigned int)current_position )
    return -1;
  LODWORD(current_position) = HIDWORD(current_position) + 1;
  HIDWORD(current_position) = *(unsigned __int8 *)(*(_DWORD *)input_ptr + HIDWORD(current_position));
  *(_DWORD *)(input_ptr + 8) = current_position;
  return HIDWORD(current_position);
}

//----- (0004512C) --------------------------------------------------------
int __fastcall fetch_next_byte(_DWORD *buffer_info)
{
  unsigned int current_position; // r3
  int (__fastcall *read_data_func)(_DWORD *, int, _DWORD); // r3
  int read_result; // r0
  int next_byte; // r0

  current_position = buffer_info[257];
  if ( current_position < buffer_info[256] )
    goto LABEL_4;
  read_data_func = (int (__fastcall *)(_DWORD *, int, _DWORD))buffer_info[258];
  buffer_info[257] = 0;
  read_result = read_data_func(buffer_info, 1024, buffer_info[259]);
  buffer_info[256] = read_result;
  if ( (unsigned int)(read_result - 1) <= 4294967293 )
  {
    current_position = buffer_info[257];
LABEL_4:
    next_byte = *((unsigned __int8 *)buffer_info + current_position);
    buffer_info[257] = current_position + 1;
    return next_byte;
  }
  return -1;
}

//----- (00045188) --------------------------------------------------------
int log_error_message(int log_level, _DWORD *parsing_context, int error_code, const char *format, ...)
{
  int log_level_copy; // r6
  const char *error_location; // r0
  int line_number; // r8
  int column; // r7
  int character_offset; // r9
  char *formatted_message; // r3
  char formatted_error_message[160]; // [sp+18h] [bp-168h] BYREF
  char enhanced_error_message[159]; // [sp+B8h] [bp-C8h] BYREF
  char null_terminator; // [sp+157h] [bp-29h]
  const char *format_copy; // [sp+17Ch] [bp-4h]
  va_list arg; // [sp+180h] [bp+0h] BYREF

  va_start(arg, format);
  format_copy = format;
  log_level_copy = log_level;
  if ( log_level )
  {
    vsnprintf(formatted_error_message, 160u, format_copy, arg);
    formatted_error_message[159] = 0;
    if ( parsing_context )
    {
      error_location = (const char *)get_first_int_from_pointer(parsing_context + 10);
      line_number = parsing_context[6];
      column = parsing_context[7];
      character_offset = parsing_context[9];
      if ( error_location && *error_location )
      {
        if ( parsing_context[11] <= 20u )
        {
          snprintf(enhanced_error_message, 160u, "%s near '%s'", formatted_error_message, error_location);
          formatted_message = enhanced_error_message;
          null_terminator = 0;
          return format_log_message(
                   log_level_copy,
                   line_number,
                   column,
                   character_offset,
                   error_code,
                   "%s",
                   (char)formatted_message);
        }
      }
      else
      {
        if ( error_code == 8 )
          error_code = 6;
        if ( parsing_context[5] != -2 )
        {
          snprintf(enhanced_error_message, 160u, "%s near end of file", formatted_error_message);
          formatted_message = enhanced_error_message;
          null_terminator = 0;
          return format_log_message(
                   log_level_copy,
                   line_number,
                   column,
                   character_offset,
                   error_code,
                   "%s",
                   (char)formatted_message);
        }
      }
      formatted_message = formatted_error_message;
    }
    else
    {
      column = -1;
      formatted_message = formatted_error_message;
      character_offset = 0;
      line_number = -1;
    }
    return format_log_message(
             log_level_copy,
             line_number,
             column,
             character_offset,
             error_code,
             "%s",
             (char)formatted_message);
  }
  return log_level;
}
// 46A84: using guessed type int __fastcall sub_46A84(_DWORD);

//----- (000452B8) --------------------------------------------------------
int __fastcall reset_device_if_necessary(_DWORD *device_status)
{
  if ( device_status[15] != 256 )
    return reset_and_perform_action_if_needed(device_status + 10);
  check_result_and_perform_action(device_status[16]);
  device_status[16] = 0;
  device_status[17] = 0;
  return reset_and_perform_action_if_needed(device_status + 10);
}
// 46954: using guessed type int __fastcall sub_46954(_DWORD);
// 46A44: using guessed type int __fastcall sub_46A44(_DWORD);

//----- (000452F8) --------------------------------------------------------
int __fastcall read_single_byte(int *file_descriptor_ptr)
{
  unsigned __int8 byte_read; // [sp+7h] [bp-9h] BYREF

  if ( read(*file_descriptor_ptr, &byte_read, 1u) == 1 )
    return byte_read;
  else
    return -1;
}

//----- (00045324) --------------------------------------------------------
int __fastcall decode_unicode_escape(_BYTE *str)
{
  _BYTE *current_char_ptr; // r3
  int unicode_value; // r0
  _BYTE *end_ptr; // lr
  int char_code; // r2
  int next_char_value; // t1
  int shifted_unicode_value; // r0
  int digit_value; // r1

  if ( *str != 117 )
    _assert_fail("str[0] == 'u'", "load.c", 309u, "decode_unicode_escape");
  current_char_ptr = str;
  unicode_value = 0;
  end_ptr = current_char_ptr + 4;
  while ( 1 )
  {
    next_char_value = (unsigned __int8)*++current_char_ptr;
    char_code = next_char_value;
    shifted_unicode_value = 16 * unicode_value;
    digit_value = next_char_value - 48;
    if ( (unsigned __int8)(next_char_value - 48) > 9u )
      break;
    unicode_value = digit_value + shifted_unicode_value;
LABEL_10:
    if ( current_char_ptr == end_ptr )
      return unicode_value;
  }
  if ( (unsigned int)(char_code - 97) <= 25 )
  {
    unicode_value = char_code - 87 + shifted_unicode_value;
    goto LABEL_10;
  }
  if ( (unsigned int)(char_code - 65) <= 25 )
  {
    unicode_value = char_code - 55 + shifted_unicode_value;
    goto LABEL_10;
  }
  return -1;
}

//----- (000453B8) --------------------------------------------------------
_DWORD *__fastcall stream_unget_char(_DWORD *stream, int char_to_unget)
{
  _DWORD *current_stream; // r4
  int prev_char; // r2
  int buffer_position; // r3
  int updated_position; // r3

  if ( (unsigned int)(char_to_unget + 2) > 1 )
  {
    current_stream = stream;
    --stream[9];
    if ( char_to_unget == 10 )
    {
      prev_char = stream[8];
      --stream[6];
      stream[7] = prev_char;
    }
    else
    {
      stream = (_DWORD *)check_signal_quality((unsigned __int8)char_to_unget);
      if ( stream )
        --current_stream[7];
    }
    buffer_position = current_stream[4];
    if ( !buffer_position )
      _assert_fail("stream->buffer_pos > 0", "load.c", 238u, "stream_unget");
    updated_position = buffer_position - 1;
    current_stream[4] = updated_position;
    if ( *((unsigned __int8 *)current_stream + updated_position + 8) != char_to_unget )
      _assert_fail("stream->buffer[stream->buffer_pos] == c", "load.c", 240u, "stream_unget");
  }
  return stream;
}
// 46ED4: using guessed type int __fastcall sub_46ED4(_DWORD);

//----- (00045474) --------------------------------------------------------
int __fastcall read_next_byte(int self_pointer, int error_message_argument)
{
  int offset; // r2
  int start_position; // r3
  int next_byte; // r6
  int new_offset; // r1
  int read_result; // r0
  int final_result; // r5
  int result; // r0
  int v11; // r3
  int v12; // r2
  unsigned int v13; // r0
  unsigned int v14; // r8
  _BYTE *v15; // r6
  _BYTE *v16; // r9
  int v17; // r2
  int arg; // [sp+0h] [bp-28h]

  offset = *(_DWORD *)(self_pointer + 16);
  start_position = self_pointer + offset;
  next_byte = *(unsigned __int8 *)(self_pointer + offset + 8);
  if ( *(_BYTE *)(self_pointer + offset + 8) )
  {
    new_offset = offset + 1;
    goto LABEL_8;
  }
  read_result = (*(int (__fastcall **)(_DWORD))self_pointer)(*(_DWORD *)(self_pointer + 4));
  final_result = read_result;
  if ( read_result == -1 )
  {
    *(_DWORD *)(self_pointer + 20) = -1;
    return final_result;
  }
  *(_DWORD *)(self_pointer + 16) = next_byte;
  *(_BYTE *)(self_pointer + 8) = read_result;
  if ( (unsigned int)(read_result - 128) <= 127 )
  {
    v13 = check_signal_quality((unsigned __int8)read_result);
    v14 = v13;
    if ( !v13 )
      goto LABEL_20;
    if ( v13 <= 1 )
      _assert_fail("count >= 2", "load.c", 189u, "stream_get");
    v15 = (_BYTE *)(self_pointer + 9);
    v16 = (_BYTE *)(self_pointer + 8 + v13);
    do
      *v15++ = (*(int (__fastcall **)(_DWORD))self_pointer)(*(_DWORD *)(self_pointer + 4));
    while ( v16 != v15 );
    if ( !validate_utf8_char((char *)(self_pointer + 8), v14, 0) )
    {
LABEL_20:
      arg = final_result;
      final_result = -2;
      *(_DWORD *)(self_pointer + 20) = -2;
      log_error_message(error_message_argument, (_DWORD *)self_pointer, 5, "unable to decode byte 0x%x", arg);
      return final_result;
    }
    *(_BYTE *)(self_pointer + v14 + 8) = 0;
    v17 = *(_DWORD *)(self_pointer + 16);
    new_offset = v17 + 1;
    start_position = self_pointer + v17;
  }
  else
  {
    new_offset = 1;
    start_position = self_pointer;
    *(_BYTE *)(self_pointer + 9) = next_byte;
  }
LABEL_8:
  *(_DWORD *)(self_pointer + 16) = new_offset;
  final_result = *(unsigned __int8 *)(start_position + 8);
  ++*(_DWORD *)(self_pointer + 36);
  if ( final_result != 10 )
  {
    if ( check_signal_quality(final_result) )
      ++*(_DWORD *)(self_pointer + 28);
    return final_result;
  }
  v11 = *(_DWORD *)(self_pointer + 24);
  v12 = *(_DWORD *)(self_pointer + 28);
  result = 10;
  *(_DWORD *)(self_pointer + 28) = 0;
  *(_DWORD *)(self_pointer + 24) = v11 + 1;
  *(_DWORD *)(self_pointer + 32) = v12;
  return result;
}

//----- (000455FC) --------------------------------------------------------
int __fastcall read_byte_with_check(int input_buffer, int flag)
{
  int next_byte; // r4

  next_byte = *(_DWORD *)(input_buffer + 20);
  if ( !next_byte )
    next_byte = read_next_byte(input_buffer, flag);
  if ( (unsigned int)(next_byte + 2) > 1 )
    append_char_to_buffer(input_buffer + 40, (unsigned __int8)next_byte);
  return next_byte;
}
// 46B6C: using guessed type int __fastcall sub_46B6C(_DWORD, _DWORD);

//----- (0004563C) --------------------------------------------------------
_DWORD *__fastcall lex_unget_unsave(_DWORD *result_ptr, int char_val)
{
  _DWORD *stream_ptr; // r5

  if ( (unsigned int)(char_val + 2) > 1 )
  {
    stream_ptr = result_ptr;
    stream_unget_char(result_ptr, char_val);
    result_ptr = (_DWORD *)consume_byte_from_buffer(stream_ptr + 10);
    if ( result_ptr != (_DWORD *)char_val )
      _assert_fail("c == d", "load.c", 282u, "lex_unget_unsave");
  }
  return result_ptr;
}
// 46B90: using guessed type int __fastcall sub_46B90(_DWORD);

//----- (00045688) --------------------------------------------------------
unsigned int __fastcall sub_45688(_DWORD *a1, int a2)
{
  _DWORD *v2; // r7
  unsigned int v5; // r4
  bool v6; // cc
  int v7; // r3
  int v8; // r4
  bool v9; // zf
  _BOOL4 v10; // r2
  bool v11; // cc
  int v12; // r0
  const char *v13; // r4
  unsigned int result; // r0
  int v15; // r1
  _DWORD *v16; // r0
  unsigned int v17; // r4
  int v18; // r0
  bool v19; // zf
  int v20; // r0
  bool v21; // zf
  const char *v22; // r4
  int *v23; // r7
  __int64 v24; // r0
  char *v25; // r3
  int v26; // r1
  int v27; // r3
  int v28; // r2
  __int64 v29; // r2
  int v30; // r8
  unsigned int v31; // r3
  unsigned int v32; // r4
  bool v33; // cc
  int v34; // r1
  _BYTE *v35; // r8
  unsigned __int8 *i; // r4
  int v37; // r3
  unsigned int v38; // r3
  int v39; // r0
  int v40; // r11
  int v41; // r0
  int v42; // r1
  int v43; // r0
  int v44; // r2
  int v45; // r3
  int v46; // r3
  char arg; // [sp+0h] [bp-40h]
  char arga; // [sp+0h] [bp-40h]
  int v49; // [sp+Ch] [bp-34h]
  __int64 endptr[6]; // [sp+10h] [bp-30h] BYREF

  v2 = a1 + 10;
  reset_buffer(a1 + 10);
  if ( a1[15] == 256 )
  {
    check_result_and_perform_action(a1[16]);
    a1[16] = 0;
    a1[17] = 0;
  }
  do
  {
    v5 = a1[5];
    if ( !v5 )
      v5 = read_next_byte(a1, a2);
    v6 = v5 > 32;
    if ( v5 != 32 )
      v6 = v5 - 9 > 1;
    v7 = !v6;
  }
  while ( !v6 || v5 == 13 );
  if ( v5 == -1 )
  {
    a1[15] = v7;
    return v7;
  }
  if ( v5 == -2 )
    goto LABEL_35;
  append_char_to_buffer(v2, (unsigned __int8)v5);
  if ( (((v5 & 0xFFFFFFDF) - 91) & 0xFFFFFFFD) == 0 )
    goto LABEL_38;
  v9 = v5 == 44;
  if ( v5 != 44 )
    v9 = v5 == 58;
  v10 = v9;
  if ( v9 )
    goto LABEL_38;
  if ( v5 != 34 )
  {
    v11 = v5 > 45;
    if ( v5 != 45 )
      v11 = v5 - 48 > 9;
    if ( !v11 )
    {
      a1[15] = -1;
      if ( v5 == 45 )
      {
        v43 = read_byte_with_check(a1, a2);
        v42 = v43;
        if ( v43 != 48 )
        {
          if ( (unsigned int)(v43 - 48) > 9 )
            goto LABEL_118;
          goto LABEL_58;
        }
      }
      else if ( v5 != 48 )
      {
        do
LABEL_58:
          v20 = read_byte_with_check(a1, a2);
        while ( (unsigned int)(v20 - 48) <= 9 );
        goto LABEL_59;
      }
      v20 = read_byte_with_check(a1, a2);
      if ( (unsigned int)(v20 - 48) <= 9 )
      {
LABEL_117:
        v42 = v20;
LABEL_118:
        lex_unget_unsave(a1, v42);
        return a1[15];
      }
LABEL_59:
      if ( (a1[13] & 8) != 0 )
        goto LABEL_70;
      v21 = v20 == 46;
      if ( v20 != 46 )
        v21 = v20 == 69;
      if ( v21 )
      {
LABEL_70:
        if ( v20 == 46 )
        {
          v34 = a1[5];
          if ( !v34 )
            v34 = read_next_byte(a1, a2);
          if ( (unsigned int)(v34 - 48) > 9 )
          {
            stream_unget_char(a1);
            return a1[15];
          }
          append_char_to_buffer(v2, (unsigned __int8)v34);
          do
            v20 = read_byte_with_check(a1, a2);
          while ( (unsigned int)(v20 - 48) <= 9 );
        }
        if ( (v20 & 0xFFFFFFDF) != 69 )
          goto LABEL_72;
      }
      else if ( v20 != 101 )
      {
        lex_unget_unsave(a1, v20);
        v22 = (const char *)get_first_int_from_pointer(v2);
        v23 = _errno_location();
        *v23 = 0;
        v24 = strtoll(v22, (char **)endptr, 10);
        if ( *v23 == 34 )
        {
          if ( v24 >= 0 )
            LOWORD(v46) = 18748;
          else
            LOWORD(v46) = 18720;
          HIWORD(v46) = 5;
          log_error_message(a2, (int)a1, 15, v46, arg);
          return a1[15];
        }
        else
        {
          if ( (const char *)LODWORD(endptr[0]) != &v22[a1[11]] )
            _assert_fail("end == saved_text + lex->saved_text.length", "load.c", 541u, "lex_scan_number");
          v8 = 257;
          *((_QWORD *)a1 + 8) = v24;
          a1[15] = 257;
        }
        return v8;
      }
      v20 = read_byte_with_check(a1, a2);
      if ( ((v20 - 43) & 0xFFFFFFFD) == 0 )
        v20 = read_byte_with_check(a1, a2);
      if ( (unsigned int)(v20 - 48) <= 9 )
      {
        do
          v20 = read_byte_with_check(a1, a2);
        while ( (unsigned int)(v20 - 48) <= 9 );
LABEL_72:
        lex_unget_unsave(a1, v20);
        if ( convert_string_to_double(v2, endptr) )
        {
          log_error_message(a2, (int)a1, 15, (int)"real number overflow", arg);
          return a1[15];
        }
        else
        {
          v29 = endptr[0];
          v8 = 258;
          a1[15] = 258;
          *((_QWORD *)a1 + 8) = v29;
        }
        return v8;
      }
      goto LABEL_117;
    }
    if ( (v5 & 0xFFFFFFDF) - 65 <= 25 )
    {
      do
        v12 = read_byte_with_check(a1, a2);
      while ( (v12 & 0xFFFFFFDF) - 65 <= 25 );
      lex_unget_unsave(a1, v12);
      v13 = (const char *)get_first_int_from_pointer(v2);
      if ( !strcmp(v13, "true") )
      {
        v8 = 259;
        a1[15] = 259;
        return v8;
      }
      if ( strcmp(v13, "false") )
      {
        if ( !strcmp(v13, "null") )
        {
          v8 = 261;
          a1[15] = 261;
          return v8;
        }
        goto LABEL_35;
      }
      v5 = 260;
LABEL_38:
      result = v5;
      a1[15] = v5;
      return result;
    }
    v25 = (char *)a1 + a1[4];
    v26 = (unsigned __int8)v25[8];
    if ( v25[8] )
    {
      do
      {
        append_char_to_buffer(v2, v26);
        v27 = a1[4] + 1;
        v28 = a1[9] + 1;
        a1[4] = v27;
        a1[9] = v28;
        v26 = *((unsigned __int8 *)a1 + v27 + 8);
      }
      while ( *((_BYTE *)a1 + v27 + 8) );
    }
LABEL_35:
    v8 = -1;
    a1[15] = -1;
    return v8;
  }
  a1[16] = v10;
  a1[15] = -1;
LABEL_40:
  v15 = a2;
  v16 = a1;
  while ( 1 )
  {
    v17 = read_byte_with_check(v16, v15);
LABEL_42:
    if ( v17 == 34 )
    {
      v35 = (_BYTE *)get_error_description(a1[11] + 1);
      if ( !v35 )
        goto LABEL_55;
      a1[16] = v35;
      for ( i = (unsigned __int8 *)(get_first_int_from_pointer(v2) + 1); ; i += 2 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            v37 = *i;
            if ( v37 == 34 )
            {
              *v35 = 0;
              v8 = 256;
              v44 = a1[16];
              a1[15] = 256;
              a1[17] = &v35[-v44];
              return v8;
            }
            if ( v37 == 92 )
              break;
            *v35 = v37;
            ++i;
            ++v35;
          }
          v38 = i[1];
          if ( v38 != 117 )
            break;
          v39 = decode_unicode_escape(i + 1);
          v40 = v39;
          if ( v39 < 0 )
          {
            LOWORD(v45) = (unsigned __int16)"invalid Unicode escape '%.6s'";
            arga = (char)i;
LABEL_138:
            HIWORD(v45) = (unsigned int)"invalid Unicode escape '%.6s'" >> 16;
            log_error_message(a2, (int)a1, 8, v45, arga);
            goto LABEL_55;
          }
          v49 = v39 - 55296;
          if ( (unsigned int)(v39 - 55296) >= 1024 )
          {
            if ( (unsigned int)(v39 - 56320) < 1024 )
              goto LABEL_142;
            i += 6;
          }
          else
          {
            if ( i[6] != 92 || i[7] != 117 )
            {
LABEL_142:
              log_error_message(a2, (int)a1, 8, (int)"invalid Unicode '\\u%04X'", v39);
              goto LABEL_55;
            }
            v41 = decode_unicode_escape(i + 7);
            if ( v41 < 0 )
            {
              LOWORD(v45) = 18628;
              arga = (_BYTE)i + 6;
              goto LABEL_138;
            }
            i += 12;
            if ( (unsigned int)(v41 - 56320) >= 1024 )
            {
              log_error_message(a2, (int)a1, 8, (int)"invalid Unicode '\\u%04X\\u%04X'", v40);
              goto LABEL_55;
            }
            v40 = v41 - 56320 + (v49 << 10) + 65536;
          }
          if ( convert_int_to_utf8(v40, v35, endptr) )
            _assert_fail("0", "load.c", 452u, "lex_scan_string");
          v35 += LODWORD(endptr[0]);
        }
        if ( v38 == 98 )
        {
          *v35 = 8;
        }
        else
        {
          if ( v38 <= 98 )
          {
            if ( v38 != 47 && v38 != 92 && v38 != 34 )
LABEL_130:
              _assert_fail("0", "load.c", 464u, "lex_scan_string");
            goto LABEL_125;
          }
          if ( v38 == 110 )
          {
            *v35 = 10;
          }
          else
          {
            if ( v38 <= 110 )
            {
              if ( v38 != 102 )
                goto LABEL_130;
              LOBYTE(v38) = 12;
LABEL_125:
              *v35 = v38;
              goto LABEL_106;
            }
            if ( v38 == 114 )
            {
              *v35 = 13;
            }
            else
            {
              if ( v38 != 116 )
                goto LABEL_130;
              *v35 = 9;
            }
          }
        }
LABEL_106:
        ++v35;
      }
    }
    if ( v17 == -2 )
      goto LABEL_55;
    if ( v17 == -1 )
    {
      log_error_message(a2, (int)a1, 6, (int)"premature end of input", arg);
      goto LABEL_55;
    }
    if ( v17 <= 31 )
      break;
    v15 = a2;
    v16 = a1;
    if ( v17 == 92 )
    {
      v18 = read_byte_with_check(a1, a2);
      if ( v18 == 117 )
      {
        v30 = 4;
        v17 = read_byte_with_check(a1, a2);
        while ( 1 )
        {
          v31 = v17 & 0xFFFFFFDF;
          v32 = v17 - 48;
          v31 -= 65;
          v33 = v31 > 5;
          if ( v31 > 5 )
            v33 = v32 > 9;
          if ( v33 )
            break;
          --v30;
          v17 = read_byte_with_check(a1, a2);
          if ( !v30 )
            goto LABEL_42;
        }
LABEL_54:
        log_error_message(a2, (int)a1, 8, (int)"invalid escape", arg);
        goto LABEL_55;
      }
      v19 = v18 == 92;
      if ( v18 != 92 )
        v19 = (v18 & 0xFFFFFFBF) == 34;
      if ( !v19 && v18 != 47 && (v18 & 0xFFFFFFF7) != 102 && ((v18 - 114) & 0xFFFFFFFD) != 0 )
        goto LABEL_54;
      goto LABEL_40;
    }
  }
  lex_unget_unsave(a1, v17);
  if ( v17 == 10 )
    log_error_message(a2, (int)a1, 8, (int)"unexpected newline", arg);
  else
    log_error_message(a2, (int)a1, 8, (int)"control character 0x%x", v17);
LABEL_55:
  check_result_and_perform_action(a1[16]);
  v8 = a1[15];
  a1[16] = 0;
  a1[17] = 0;
  return v8;
}
// 458C0: variable 'arg' is possibly undefined
// 45324: using guessed type int __fastcall sub_45324(_DWORD);
// 453B8: using guessed type int __fastcall sub_453B8(_DWORD);
// 45474: using guessed type int __fastcall sub_45474(_DWORD, _DWORD);
// 455FC: using guessed type int __fastcall sub_455FC(_DWORD, _DWORD);
// 4563C: using guessed type int __fastcall sub_4563C(_DWORD, _DWORD);
// 4693C: using guessed type int __fastcall sub_4693C(_DWORD);
// 46954: using guessed type int __fastcall sub_46954(_DWORD);
// 46A70: using guessed type int __fastcall sub_46A70(_DWORD);
// 46A84: using guessed type int __fastcall sub_46A84(_DWORD);
// 46B6C: using guessed type int __fastcall sub_46B6C(_DWORD, _DWORD);
// 46BB8: using guessed type int __fastcall sub_46BB8(_DWORD, _DWORD);
// 46DE8: using guessed type int __fastcall sub_46DE8(_DWORD, _DWORD, _DWORD);

//----- (00045EA0) --------------------------------------------------------
int __fastcall parse_json_value(int json, int options, int error)
{
  unsigned int depth; // r3
  int token_type; // r3
  int v7; // r6
  int string_start; // r7
  int string_len; // r9
  int next_token_type; // r3
  const void *object_key; // r7
  size_t object_key_len; // r2
  int sub_result; // r2
  int after_parse_token_type; // r3
  unsigned int *ref_counter; // r3
  unsigned int prev_ref_count; // r2
  unsigned int new_ref_count; // r2
  int array_end_check; // r3
  int comma_or_end_array_check; // r3
  int array_element; // r1
  unsigned int *object_ref_counter; // r3
  unsigned int object_prev_ref_count; // r2
  int object_to_free; // r0
  char error_buffer; // [sp+0h] [bp-20h]

  depth = *(_DWORD *)(json + 56) + 1;
  *(_DWORD *)(json + 56) = depth;
  if ( depth > 2048 )
  {
    v7 = 0;
    log_error_message(error, json, 2, (int)"maximum parsing depth reached", error_buffer);
    return v7;
  }
  token_type = *(_DWORD *)(json + 60);
  if ( token_type == 257 )
  {
    v7 = set_error_context(*(_DWORD *)(json + 64), *(_DWORD *)(json + 68));
    goto LABEL_9;
  }
  if ( token_type <= 257 )
  {
    if ( token_type == 91 )
    {
      v7 = initialize_error_description(json);
      if ( !v7 )
        return 0;
      parse_value((_DWORD *)json, error);
      array_end_check = *(_DWORD *)(json + 60);
      if ( array_end_check == 93 )
        goto LABEL_10;
      if ( array_end_check )
      {
        while ( 1 )
        {
          array_element = parse_json_value(json, options, error);
          if ( !array_element || add_buffer_to_queue(v7, array_element) )
            break;
          parse_value((_DWORD *)json, error);
          comma_or_end_array_check = *(_DWORD *)(json + 60);
          if ( comma_or_end_array_check != 44 )
          {
            if ( comma_or_end_array_check == 93 )
              goto LABEL_10;
            goto LABEL_62;
          }
          parse_value((_DWORD *)json, error);
          if ( !*(_DWORD *)(json + 60) )
            goto LABEL_62;
        }
      }
      else
      {
LABEL_62:
        log_error_message(error, json, 8, (int)"']' expected", error_buffer);
      }
      if ( *(_DWORD *)(v7 + 4) == -1 )
        return 0;
      object_ref_counter = (unsigned int *)(v7 + 4);
      __dmb(11u);
      do
      {
        object_prev_ref_count = __ldrex(object_ref_counter);
        new_ref_count = object_prev_ref_count - 1;
      }
      while ( __strex(new_ref_count, object_ref_counter) );
    }
    else
    {
      if ( token_type <= 91 )
      {
        if ( token_type == -1 )
        {
          v7 = 0;
          log_error_message(error, json, 8, (int)"invalid token", error_buffer);
          return v7;
        }
        goto LABEL_57;
      }
      if ( token_type != 123 )
      {
        if ( token_type != 256 )
          goto LABEL_57;
        string_start = *(_DWORD *)(json + 64);
        string_len = *(_DWORD *)(json + 68);
        if ( (options & 0x10) == 0 && memchr(*(const void **)(json + 64), 0, *(_DWORD *)(json + 68)) )
        {
          v7 = 0;
          log_error_message(error, json, 11, (int)"\\u0000 is not allowed without JSON_ALLOW_NUL", error_buffer);
          return v7;
        }
        v7 = format_miner_error_message(string_start, string_len);
        *(_DWORD *)(json + 64) = 0;
        *(_DWORD *)(json + 68) = 0;
        goto LABEL_9;
      }
      v7 = initialize_miner_error_state(json);
      if ( !v7 )
        return 0;
      parse_value((_DWORD *)json, error);
      next_token_type = *(_DWORD *)(json + 60);
      if ( next_token_type == 125 )
        goto LABEL_10;
      if ( next_token_type == 256 )
      {
        object_key = *(const void **)(json + 64);
        object_key_len = *(_DWORD *)(json + 68);
        *(_DWORD *)(json + 64) = 0;
        *(_DWORD *)(json + 68) = 0;
        if ( !object_key )
          return 0;
        while ( 1 )
        {
          if ( memchr(object_key, 0, object_key_len) )
          {
            check_result_and_perform_action(object_key);
            log_error_message(error, json, 13, (int)"NUL byte in object key not supported", error_buffer);
            goto LABEL_36;
          }
          if ( (options & 1) != 0 && validate_and_fetch_data(v7, object_key) )
          {
            check_result_and_perform_action(object_key);
            log_error_message(error, json, 14, (int)"duplicate object key", error_buffer);
            goto LABEL_36;
          }
          parse_value((_DWORD *)json, error);
          if ( *(_DWORD *)(json + 60) != 58 )
          {
            check_result_and_perform_action(object_key);
            log_error_message(error, json, 8, (int)"':' expected", error_buffer);
            goto LABEL_36;
          }
          parse_value((_DWORD *)json, error);
          sub_result = parse_json_value(json, options, error);
          if ( !sub_result || manage_bitmain_worker(v7, object_key, sub_result) )
          {
            check_result_and_perform_action(object_key);
            goto LABEL_36;
          }
          check_result_and_perform_action(object_key);
          parse_value((_DWORD *)json, error);
          after_parse_token_type = *(_DWORD *)(json + 60);
          if ( after_parse_token_type != 44 )
            break;
          parse_value((_DWORD *)json, error);
          if ( *(_DWORD *)(json + 60) != 256 )
            goto LABEL_63;
          object_key = *(const void **)(json + 64);
          object_key_len = *(_DWORD *)(json + 68);
          *(_DWORD *)(json + 64) = 0;
          *(_DWORD *)(json + 68) = 0;
          if ( !object_key )
            return 0;
        }
        if ( after_parse_token_type == 125 )
          goto LABEL_10;
        log_error_message(error, json, 8, (int)"'}' expected", error_buffer);
      }
      else
      {
LABEL_63:
        log_error_message(error, json, 8, (int)"string or '}' expected", error_buffer);
      }
LABEL_36:
      if ( *(_DWORD *)(v7 + 4) == -1 )
        return 0;
      ref_counter = (unsigned int *)(v7 + 4);
      __dmb(11u);
      do
      {
        prev_ref_count = __ldrex(ref_counter);
        new_ref_count = prev_ref_count - 1;
      }
      while ( __strex(new_ref_count, ref_counter) );
    }
    if ( !new_ref_count )
    {
      object_to_free = v7;
      v7 = 0;
      process_bitmain_miner(object_to_free);
      return v7;
    }
    return 0;
  }
  if ( token_type == 259 )
  {
    v7 = get_reference_to_unk_664D4(json);
  }
  else if ( token_type < 259 )
  {
    v7 = check_and_set_error_description(json);
  }
  else
  {
    if ( token_type != 260 )
    {
      if ( token_type == 261 )
      {
        v7 = get_config_base_address();
        goto LABEL_9;
      }
LABEL_57:
      v7 = 0;
      log_error_message(error, json, 8, (int)"unexpected token", error_buffer);
      return v7;
    }
    v7 = get_global_variable_address(json);
  }
LABEL_9:
  if ( v7 )
  {
LABEL_10:
    --*(_DWORD *)(json + 56);
    return v7;
  }
  return 0;
}
// 460CC: variable 'error_buffer' is possibly undefined
// 46954: using guessed type int __fastcall sub_46954(_DWORD);
// 47268: using guessed type int __fastcall sub_47268(_DWORD);
// 472EC: using guessed type int __fastcall sub_472EC(_DWORD, _DWORD);
// 475F8: using guessed type int __fastcall sub_475F8(_DWORD);
// 477B0: using guessed type int __fastcall sub_477B0(_DWORD, _DWORD);
// 47A48: using guessed type int __fastcall sub_47A48(_DWORD, _DWORD);
// 47ACC: using guessed type int __fastcall sub_47ACC(_DWORD);
// 47C00: using guessed type int __fastcall sub_47C00(_DWORD);
// 47C0C: using guessed type int __fastcall sub_47C0C(_DWORD);
// 47C18: using guessed type int sub_47C18(void);
// 47C24: using guessed type int __fastcall sub_47C24(_DWORD);
// 47EE4: using guessed type int __fastcall sub_47EE4(_DWORD, _DWORD, _DWORD);
// 4854C: using guessed type int __fastcall sub_4854C(_DWORD, _DWORD);

//----- (00046344) --------------------------------------------------------
int __fastcall parse_json(_DWORD *json_object, int parse_flags, int json_string)
{
  int parse_result; // r7
  unsigned int *ref_count_ptr; // r3
  unsigned int current_count; // r2
  unsigned int new_count; // r2
  int parse_ref; // r0

  json_object[14] = 0;
  parse_value(json_object, json_string);
  parse_result = parse_flags & 4;
  if ( (parse_flags & 4) == 0 && (json_object[15] & 0xFFFFFFDF) != 91 )
  {
    log_error_message(json_string, json_object, 8, "'[' or '{' expected");
    return parse_result;
  }
  parse_result = parse_json_value((int)json_object, parse_flags, json_string);
  if ( parse_result )
  {
    if ( (parse_flags & 2) != 0 || (parse_value(json_object, json_string), !json_object[15]) )
    {
      if ( json_string )
        *(_DWORD *)(json_string + 8) = json_object[9];
      return parse_result;
    }
    log_error_message(json_string, json_object, 7, "end of file expected");
    if ( *(_DWORD *)(parse_result + 4) != -1 )
    {
      ref_count_ptr = (unsigned int *)(parse_result + 4);
      __dmb(11u);
      do
      {
        current_count = __ldrex(ref_count_ptr);
        new_count = current_count - 1;
      }
      while ( __strex(new_count, ref_count_ptr) );
      if ( !new_count )
      {
        parse_ref = parse_result;
        parse_result = 0;
        process_bitmain_miner(parse_ref);
        return parse_result;
      }
    }
  }
  return 0;
}
// 47C24: using guessed type int __fastcall sub_47C24(_DWORD);

//----- (00046448) --------------------------------------------------------
int __fastcall process_command(int command_id, int json_data, int context)
{
  int result_status; // r4
  int callback_data[2]; // [sp+0h] [bp-68h] BYREF
  int callback_with_context[2]; // [sp+8h] [bp-60h] BYREF
  char buffer_initial_byte; // [sp+10h] [bp-58h]
  int buffer_offset; // [sp+18h] [bp-50h]
  int buffer_length; // [sp+1Ch] [bp-4Ch]
  int is_callback_set; // [sp+20h] [bp-48h]
  int unused1; // [sp+24h] [bp-44h]
  int unused2; // [sp+2Ch] [bp-3Ch]
  char callback_buffer[12]; // [sp+30h] [bp-38h] BYREF
  int json_data_copy; // [sp+3Ch] [bp-2Ch]
  int callback_result; // [sp+44h] [bp-24h]

  initialize_miner_status(context, "<string>");
  if ( command_id )
  {
    result_status = 0;
    callback_data[0] = command_id;
    callback_with_context[0] = (int)sub_450E4;
    callback_data[1] = 0;
    buffer_initial_byte = 0;
    buffer_offset = 0;
    buffer_length = 0;
    unused1 = 0;
    unused2 = 0;
    callback_with_context[1] = (int)callback_data;
    is_callback_set = 1;
    if ( !set_initial_error_state(callback_buffer) )
    {
      json_data_copy = json_data;
      callback_result = -1;
      result_status = parse_json(callback_with_context, json_data, context);
      reset_device_if_necessary(callback_with_context);
    }
  }
  else
  {
    result_status = 0;
    log_error_message(context, 0, 4, "wrong arguments");
  }
  return result_status;
}
// 450E4: using guessed type int sub_450E4();
// 452B8: using guessed type int __fastcall sub_452B8(_DWORD);
// 46A10: using guessed type int __fastcall sub_46A10(_DWORD);
// 489C4: using guessed type int __fastcall sub_489C4(_DWORD, _DWORD);
// 46448: using guessed type char var_38[12];

//----- (00046510) --------------------------------------------------------
int __fastcall sub_46510(int command_id, int command_type, int command_data, char *log_context)
{
  int v8; // r4
  int callback_info[3]; // [sp+4h] [bp-6Ch] BYREF
  int callback_params[2]; // [sp+10h] [bp-60h] BYREF
  char unused_char; // [sp+18h] [bp-58h]
  int unused_int1; // [sp+20h] [bp-50h]
  int unused_int2; // [sp+24h] [bp-4Ch]
  int callback_flag; // [sp+28h] [bp-48h]
  int unused_int3; // [sp+2Ch] [bp-44h]
  int unused_int4; // [sp+34h] [bp-3Ch]
  char temp_buffer[12]; // [sp+38h] [bp-38h] BYREF
  int json_data; // [sp+44h] [bp-2Ch]
  int json_parse_result; // [sp+4Ch] [bp-24h]

  initialize_miner_status(log_context, "<buffer>");
  if ( command_id )
  {
    v8 = 0;
    callback_info[0] = command_id;
    callback_info[1] = command_type;
    callback_params[0] = (int)get_next_byte;
    callback_info[2] = 0;
    unused_char = 0;
    unused_int1 = 0;
    unused_int2 = 0;
    unused_int3 = 0;
    unused_int4 = 0;
    callback_params[1] = (int)callback_info;
    callback_flag = 1;
    if ( !set_initial_error_state(temp_buffer) )
    {
      json_data = command_data;
      json_parse_result = -1;
      v8 = parse_json(callback_params, command_data, (int)log_context);
      reset_device_if_necessary(callback_params);
    }
  }
  else
  {
    v8 = 0;
    log_error_message((int)log_context, 0, 4, "wrong arguments");
  }
  return v8;
}
// 46510: using guessed type char var_38[12];

//----- (000465E4) --------------------------------------------------------
int __fastcall process_file_input(int input_stream, int arg2, int log_context)
{
  const char *stream_indicator; // r1
  int v7; // r4
  int file_handle[2]; // [sp+0h] [bp-60h] BYREF
  char unused1; // [sp+8h] [bp-58h]
  int unused2; // [sp+10h] [bp-50h]
  int unused3; // [sp+14h] [bp-4Ch]
  int config_flag; // [sp+18h] [bp-48h]
  int unused4; // [sp+1Ch] [bp-44h]
  int unused5; // [sp+24h] [bp-3Ch]
  char buffer[12]; // [sp+28h] [bp-38h] BYREF
  int arg2_copy; // [sp+34h] [bp-2Ch]
  int error_code; // [sp+3Ch] [bp-24h]

  if ( stdin == input_stream )
    stream_indicator = "<stdin>";
  else
    stream_indicator = "<stream>";
  initialize_miner_status(log_context, stream_indicator);
  if ( input_stream )
  {
    v7 = 0;
    file_handle[1] = input_stream;
    file_handle[0] = (int)fgetc;
    unused1 = 0;
    unused2 = 0;
    unused3 = 0;
    unused4 = 0;
    unused5 = 0;
    config_flag = 1;
    if ( !set_initial_error_state(buffer) )
    {
      arg2_copy = arg2;
      error_code = -1;
      v7 = parse_json(file_handle, arg2, log_context);
      reset_device_if_necessary(file_handle);
    }
  }
  else
  {
    v7 = 0;
    log_error_message(log_context, 0, 4, "wrong arguments");
  }
  return v7;
}
// 452B8: using guessed type int __fastcall sub_452B8(_DWORD);
// 46344: using guessed type int __fastcall sub_46344(_DWORD, _DWORD, _DWORD);
// 46A10: using guessed type int __fastcall sub_46A10(_DWORD);
// 489C4: using guessed type int __fastcall sub_489C4(_DWORD, _DWORD);
// 664F0: using guessed type int stdin;
// 465E4: using guessed type char var_38[12];

//----- (000466C4) --------------------------------------------------------
int __fastcall initialize_miner_config(int is_stream, int config_data_length, int error_context)
{
  const char *stream_type; // r1
  int v6; // r4
  int stream_flag; // [sp+4h] [bp-5Ch] BYREF
  int callback_data[2]; // [sp+8h] [bp-58h] BYREF
  char unknown1; // [sp+10h] [bp-50h]
  int unknown2; // [sp+18h] [bp-48h]
  int unknown3; // [sp+1Ch] [bp-44h]
  int callback_flag; // [sp+20h] [bp-40h]
  int unknown4; // [sp+24h] [bp-3Ch]
  int unknown5; // [sp+2Ch] [bp-34h]
  char unknown_buffer[12]; // [sp+30h] [bp-30h] BYREF
  int data_length; // [sp+3Ch] [bp-24h]
  int unknown6; // [sp+44h] [bp-1Ch]

  stream_flag = is_stream;
  if ( is_stream )
    stream_type = "<stream>";
  else
    stream_type = "<stdin>";
  initialize_miner_status(error_context, stream_type);
  if ( stream_flag < 0 )
  {
    v6 = 0;
    log_error_message(error_context, 0, 4, "wrong arguments");
  }
  else
  {
    v6 = 0;
    callback_data[0] = (int)read_single_byte;
    callback_data[1] = (int)&stream_flag;
    unknown1 = 0;
    unknown2 = 0;
    unknown3 = 0;
    unknown4 = 0;
    unknown5 = 0;
    callback_flag = 1;
    if ( !set_initial_error_state(unknown_buffer) )
    {
      data_length = config_data_length;
      unknown6 = -1;
      v6 = parse_json(callback_data, config_data_length, error_context);
      reset_device_if_necessary(callback_data);
    }
  }
  return v6;
}
// 452B8: using guessed type int __fastcall sub_452B8(_DWORD);
// 452F8: using guessed type int sub_452F8();
// 46A10: using guessed type int __fastcall sub_46A10(_DWORD);
// 489C4: using guessed type int __fastcall sub_489C4(_DWORD, _DWORD);
// 466C4: using guessed type char var_30[12];

//----- (000467A0) --------------------------------------------------------
int __fastcall handle_file_processing(const char *file_path, int arg2, int log_context)
{
  int file_open_result; // r0
  FILE *file_ptr; // r7
  int process_result; // r6
  int *errno_ptr; // r0
  char *error_message; // r0

  initialize_miner_status(log_context, file_path);
  if ( file_path )
  {
    file_open_result = fopen64(file_path, "rb");
    file_ptr = (FILE *)file_open_result;
    if ( file_open_result )
    {
      process_result = process_file_input(file_open_result, arg2, log_context);
      fclose(file_ptr);
    }
    else
    {
      errno_ptr = _errno_location();
      process_result = 0;
      error_message = strerror(*errno_ptr);
      log_error_message(log_context, 0, 3, "unable to open %s: %s", file_path, error_message);
    }
  }
  else
  {
    process_result = 0;
    log_error_message(log_context, 0, 4, "wrong arguments");
  }
  return process_result;
}
// 1224C: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 489C4: using guessed type int __fastcall sub_489C4(_DWORD, _DWORD);

//----- (0004693C) --------------------------------------------------------
int __fastcall get_error_description(int error_code)
{
  if ( error_code )
    return off_664CC();
  return error_code;
}
// 664CC: using guessed type int (*off_664CC)(void);

//----- (00046954) --------------------------------------------------------
int __fastcall check_result_and_perform_action(int status_code)
{
  if ( status_code )
    return off_664D0();
  return status_code;
}
// 664D0: using guessed type int (*off_664D0)(void);

//----- (0004696C) --------------------------------------------------------
_BYTE *__fastcall copy_buffer_with_termination(const void *source, size_t size)
{
  size_t result_buffer; // r5
  void *allocated_buffer; // r0

  result_buffer = size + 1;
  if ( size != -1 )
  {
    allocated_buffer = (void *)off_664CC(size + 1);
    result_buffer = (size_t)allocated_buffer;
    if ( allocated_buffer )
    {
      memcpy(allocated_buffer, source, size);
      *(_BYTE *)(result_buffer + size) = 0;
    }
  }
  return (_BYTE *)result_buffer;
}
// 664CC: using guessed type int (__fastcall *off_664CC)(_DWORD);

//----- (000469B8) --------------------------------------------------------
_BYTE *__fastcall sub_469B8(const char *a1)
{
  size_t v2; // r1

  v2 = strlen(a1);
  return copy_buffer_with_termination(a1, v2);
}

//----- (000469D4) --------------------------------------------------------
int __fastcall set_global_variable(__int64 new_value)
{
  *(_QWORD *)&off_664CC = new_value;
  return new_value;
}
// 664CC: using guessed type int (__fastcall *off_664CC)(_DWORD);

//----- (000469E4) --------------------------------------------------------
_DWORD *__fastcall update_miner_config_pointers(_DWORD *main_config, _DWORD *backup_config)
{
  if ( main_config )
    *main_config = off_664CC;
  if ( backup_config )
    *backup_config = off_664D0;
  return main_config;
}
// 664CC: using guessed type int (__fastcall *off_664CC)(_DWORD);
// 664D0: using guessed type int (*off_664D0)(void);

//----- (00046A10) --------------------------------------------------------
int __fastcall set_initial_error_state(_DWORD *error_state)
{
  _BYTE *error_message; // r0

  error_state[2] = 16;
  error_state[1] = 0;
  error_message = (_BYTE *)get_error_description(16);
  *error_state = error_message;
  if ( !error_message )
    return -1;
  *error_message = 0;
  return 0;
}

//----- (00046A44) --------------------------------------------------------
int __fastcall reset_and_perform_action_if_needed(int *status_array)
{
  int initial_state; // r0

  initial_state = *status_array;
  if ( initial_state )
    initial_state = check_result_and_perform_action(initial_state);
  status_array[2] = 0;
  status_array[1] = 0;
  *status_array = 0;
  return initial_state;
}

//----- (00046A70) --------------------------------------------------------
int __fastcall reset_buffer(int buffer_ptr)
{
  _BYTE *buffer; // r2

  buffer = *(_BYTE **)buffer_ptr;
  *(_DWORD *)(buffer_ptr + 4) = 0;
  *buffer = 0;
  return buffer_ptr;
}

//----- (00046A84) --------------------------------------------------------
int __fastcall get_first_int_from_pointer(int pointer)
{
  return *(_DWORD *)pointer;
}

//----- (00046A8C) --------------------------------------------------------
int __fastcall reset_and_return_previous_value(int *value_ptr)
{
  int previous_value; // r0

  previous_value = *value_ptr;
  *value_ptr = 0;
  return previous_value;
}

//----- (00046AA0) --------------------------------------------------------
int __fastcall append_data_to_buffer(const void **buffer_info, void *source_data, size_t data_size)
{
  unsigned int current_capacity; // r3
  _BYTE *used_space; // r0
  const void *data_pointer; // r8
  unsigned int new_capacity; // r3
  unsigned int required_space; // r0
  const void *reallocated_size; // r6
  void *allocated_memory; // r0
  const void *target_pointer; // r2
  int operation_status; // r0
  char *new_used_space; // r5

  current_capacity = (unsigned int)buffer_info[2];
  used_space = buffer_info[1];
  if ( current_capacity - (unsigned int)used_space > data_size )
  {
    data_pointer = *buffer_info;
LABEL_10:
    memcpy(&used_space[(_DWORD)data_pointer], source_data, data_size);
    target_pointer = *buffer_info;
    operation_status = 0;
    new_used_space = (char *)buffer_info[1] + data_size;
    buffer_info[1] = new_used_space;
    new_used_space[(_DWORD)target_pointer] = 0;
    return operation_status;
  }
  if ( !((data_size == -1) | (current_capacity >> 31)) && -2 - data_size >= (unsigned int)used_space )
  {
    new_capacity = 2 * current_capacity;
    required_space = (unsigned int)&used_space[data_size + 1];
    reallocated_size = (const void *)(required_space < new_capacity ? new_capacity : required_space);
    allocated_memory = (void *)get_error_description((int)reallocated_size);
    data_pointer = allocated_memory;
    if ( allocated_memory )
    {
      memcpy(allocated_memory, *buffer_info, (size_t)buffer_info[1]);
      check_result_and_perform_action((int)*buffer_info);
      used_space = buffer_info[1];
      *buffer_info = data_pointer;
      buffer_info[2] = reallocated_size;
      goto LABEL_10;
    }
  }
  return -1;
}

//----- (00046B6C) --------------------------------------------------------
int __fastcall append_char_to_buffer(const void **buffer, char character)
{
  char character_ref; // [sp+7h] [bp-9h] BYREF

  character_ref = character;
  return append_data_to_buffer(buffer, &character_ref, 1u);
}

//----- (00046B90) --------------------------------------------------------
int __fastcall consume_byte_from_buffer(int *buffer_info, char replacement_byte, int buffer_base)
{
  int remaining_bytes; // r3
  bool is_empty; // zf
  int retrieved_byte; // r0

  remaining_bytes = buffer_info[1];
  is_empty = remaining_bytes == 0;
  if ( remaining_bytes )
  {
    buffer_base = *buffer_info;
    --remaining_bytes;
    replacement_byte = 0;
    buffer_info[1] = remaining_bytes;
    retrieved_byte = *(unsigned __int8 *)(buffer_base + remaining_bytes);
  }
  else
  {
    retrieved_byte = 0;
  }
  if ( !is_empty )
    *(_BYTE *)(buffer_base + remaining_bytes) = replacement_byte;
  return retrieved_byte;
}

//----- (00046BB8) --------------------------------------------------------
int __fastcall convert_string_to_double(int string_buffer, double *output_double)
{
  double parsed_value; // d0
  struct lconv *locale_info; // r0
  const char *target_string; // r5
  int decimal_point_char; // r6
  char *decimal_point_position; // r0
  int *errno_ptr; // r6
  int conversion_status; // r0
  char *end_pointer; // [sp+4h] [bp-1Ch] BYREF

  locale_info = localeconv();
  target_string = *(const char **)string_buffer;
  decimal_point_char = *(unsigned __int8 *)locale_info->decimal_point;
  if ( decimal_point_char != 46 )
  {
    decimal_point_position = strchr(*(const char **)string_buffer, 46);
    if ( decimal_point_position )
    {
      *decimal_point_position = decimal_point_char;
      target_string = *(const char **)string_buffer;
    }
  }
  errno_ptr = _errno_location();
  *errno_ptr = 0;
  strtod(target_string, &end_pointer);
  if ( end_pointer != (char *)(*(_DWORD *)string_buffer + *(_DWORD *)(string_buffer + 4)) )
    _assert_fail("end == strbuffer->value + strbuffer->length", "strconv.c", 78u, "jsonp_strtod");
  if ( (parsed_value > 1.79769313e308 || parsed_value < -1.79769313e308) && *errno_ptr == 34 )
    return -1;
  conversion_status = 0;
  *output_double = parsed_value;
  return conversion_status;
}
// 46C38: variable 'parsed_value' is possibly undefined

//----- (00046CA8) --------------------------------------------------------
int __fastcall format_float_string(char *buffer, size_t buffer_size)
{
  unsigned int formatted_length; // r0
  unsigned int result_length; // r6
  int locale_decimal_point; // r1
  char *decimal_point_pos; // r0
  char *dot_pos; // r5
  char *exponent_pos; // r0
  unsigned __int8 *exponent_digit_ptr; // r4
  int first_exponent_digit; // r3
  _BYTE *trim_start_ptr; // r5
  int current_digit; // t1
  size_t move_length; // r2
  char *zero_fill_start; // r3

  formatted_length = snprintf(buffer, buffer_size, "%.*g");
  if ( buffer_size > formatted_length )
  {
    result_length = formatted_length;
    locale_decimal_point = *(unsigned __int8 *)localeconv()->decimal_point;
    if ( locale_decimal_point != 46 )
    {
      decimal_point_pos = strchr(buffer, locale_decimal_point);
      if ( decimal_point_pos )
        *decimal_point_pos = 46;
    }
    dot_pos = strchr(buffer, 46);
    exponent_pos = strchr(buffer, 101);
    if ( dot_pos )
    {
LABEL_6:
      if ( !exponent_pos )
        return result_length;
      goto LABEL_7;
    }
    if ( exponent_pos )
    {
LABEL_7:
      exponent_digit_ptr = (unsigned __int8 *)(exponent_pos + 2);
      first_exponent_digit = (unsigned __int8)exponent_pos[2];
      if ( exponent_pos[1] != 45 )
      {
        trim_start_ptr = exponent_pos + 1;
        if ( first_exponent_digit != 48 )
        {
LABEL_10:
          if ( exponent_digit_ptr != trim_start_ptr )
          {
            move_length = result_length - (exponent_digit_ptr - (unsigned __int8 *)buffer);
            result_length -= exponent_digit_ptr - trim_start_ptr;
            memmove(trim_start_ptr, exponent_digit_ptr, move_length);
          }
          return result_length;
        }
        do
LABEL_9:
          current_digit = *++exponent_digit_ptr;
        while ( current_digit == 48 );
        goto LABEL_10;
      }
      if ( first_exponent_digit == 48 )
      {
        trim_start_ptr = exponent_pos + 2;
        goto LABEL_9;
      }
      return result_length;
    }
    if ( result_length + 3 < buffer_size )
    {
      buffer[result_length] = 46;
      zero_fill_start = &buffer[result_length];
      result_length += 2;
      zero_fill_start[1] = 48;
      buffer[result_length] = 0;
      exponent_pos = strchr(buffer, 101);
      goto LABEL_6;
    }
  }
  return -1;
}

//----- (00046DE8) --------------------------------------------------------
int __fastcall convert_int_to_utf8(int input_integer, _BYTE *utf8_result, _DWORD *utf8_length)
{
  char last_byte; // r3
  int status; // r0
  char second_byte; // r3
  char third_byte; // r3
  unsigned int second_byte_with_mask; // r12

  if ( input_integer < 0 )
    return -1;
  if ( input_integer <= 127 )
  {
    *utf8_result = input_integer;
    status = 0;
    *utf8_length = 1;
  }
  else if ( input_integer < 2048 )
  {
    second_byte = (input_integer & 0x3F) + -128;
    *utf8_result = (input_integer >> 6) - 64;
    status = 0;
    utf8_result[1] = second_byte;
    *utf8_length = 2;
  }
  else if ( input_integer < 65536 )
  {
    third_byte = (input_integer & 0x3F) + -128;
    second_byte_with_mask = (((unsigned int)input_integer >> 6) & 0x3F) - 128;
    *utf8_result = (input_integer >> 12) - 32;
    status = 0;
    utf8_result[1] = second_byte_with_mask;
    utf8_result[2] = third_byte;
    *utf8_length = 3;
  }
  else if ( input_integer >= 1114112 )
  {
    return -1;
  }
  else
  {
    last_byte = (input_integer & 0x3F) + -128;
    *utf8_result = (input_integer >> 18) - 16;
    utf8_result[1] = (((unsigned int)input_integer >> 12) & 0x3F) + -128;
    utf8_result[2] = (((unsigned int)input_integer >> 6) & 0x3F) + -128;
    status = 0;
    utf8_result[3] = last_byte;
    *utf8_length = 4;
  }
  return status;
}

//----- (00046ED4) --------------------------------------------------------
int __fastcall check_signal_quality(int signal_strength)
{
  if ( (signal_strength & 0x80) == 0 )
    return 1;
  if ( (signal_strength ^ 0x80u) <= 65 )
    return 0;
  if ( (unsigned __int8)(signal_strength + 62) <= 29u )
    return 2;
  if ( (unsigned __int8)(signal_strength + 32) <= 15u )
    return 3;
  if ( (unsigned __int8)(signal_strength + 16) <= 4u )
    return 4;
  return 0;
}

//----- (00046F40) --------------------------------------------------------
int __fastcall validate_utf8_char(char *input_string, unsigned int expected_length, int *output_codepoint)
{
  char first_char; // lr
  int codepoint; // lr
  int validation_result; // r0
  int next_byte; // r3
  char *current_ptr; // r0
  unsigned int current_length; // r12
  int next_char; // t1
  bool is_invalid; // zf
  _BOOL4 is_three_byte_seq; // r3
  _BOOL4 is_four_byte_seq; // r1

  first_char = *input_string;
  switch ( expected_length )
  {
    case 2u:
      codepoint = first_char & 0x1F;
      break;
    case 3u:
      codepoint = first_char & 0xF;
      break;
    case 4u:
      codepoint = first_char & 7;
      break;
    default:
      return 0;
  }
  next_byte = (unsigned __int8)input_string[1];
  if ( (next_byte ^ 0x80u) > 63 )
    return 0;
  current_ptr = input_string + 1;
  current_length = 1;
  while ( 1 )
  {
    ++current_length;
    codepoint = (next_byte & 0x3F) + (codepoint << 6);
    if ( expected_length <= current_length )
      break;
    next_char = (unsigned __int8)*++current_ptr;
    LOBYTE(next_byte) = next_char;
    if ( (next_char ^ 0x80u) > 63 )
      return 0;
  }
  if ( codepoint >= 1114112 || (unsigned int)(codepoint - 55296) < 2048 )
    return 0;
  is_invalid = codepoint == 127;
  if ( codepoint <= 127 )
    is_invalid = expected_length == 2;
  validation_result = is_invalid;
  if ( is_invalid )
    return 0;
  is_three_byte_seq = expected_length == 3;
  if ( codepoint >= 2048 )
    is_three_byte_seq = 0;
  if ( !is_three_byte_seq )
  {
    is_four_byte_seq = expected_length == 4;
    if ( codepoint >= 65536 )
      is_four_byte_seq = 0;
    if ( !is_four_byte_seq )
    {
      validation_result = 1;
      if ( output_codepoint )
        *output_codepoint = codepoint;
      return validation_result;
    }
    return 0;
  }
  return validation_result;
}

//----- (00047028) --------------------------------------------------------
char *__fastcall decode_utf8_character(char *input_string, int validate_length, _DWORD *output_char_code)
{
  char *current_char_ptr; // r4
  unsigned int char_length; // r0
  unsigned int remaining_length; // r1
  int unused; // r2
  unsigned int char_size; // r6
  int decoded_char_code; // [sp+4h] [bp-14h] BYREF

  if ( validate_length )
  {
    current_char_ptr = input_string;
    char_length = check_signal_quality((unsigned __int8)*input_string);
    char_size = char_length;
    if ( char_length )
    {
      if ( char_length == 1 )
      {
        decoded_char_code = unused;
LABEL_7:
        input_string = &current_char_ptr[char_size];
        if ( output_char_code )
          *output_char_code = decoded_char_code;
        return input_string;
      }
      if ( remaining_length >= char_length && validate_utf8_char(current_char_ptr, char_length, &decoded_char_code) )
        goto LABEL_7;
    }
    return 0;
  }
  return input_string;
}
// 47058: variable 'unused' is possibly undefined
// 47064: variable 'remaining_length' is possibly undefined

//----- (000470A4) --------------------------------------------------------
int __fastcall validate_utf8_string(int string_ptr, unsigned int string_length)
{
  int current_position; // r4
  unsigned int char_size; // r5
  char *char_ptr; // r0

  if ( !string_length )
    return 1;
  current_position = 0;
  while ( 1 )
  {
    char_size = check_signal_quality(*(unsigned __int8 *)(string_ptr + current_position));
    char_ptr = (char *)(string_ptr + current_position);
    if ( !char_size )
      break;
    if ( char_size > 1 )
    {
      if ( string_length - current_position < char_size )
        break;
      current_position = char_size + current_position - 1;
      if ( !validate_utf8_char(char_ptr, char_size, 0) )
        break;
    }
    if ( string_length <= ++current_position )
      return 1;
  }
  return 0;
}

//----- (00047120) --------------------------------------------------------
int __fastcall copy_error_description(int error_data_ptr)
{
  __int64 error_info; // r4
  int new_error_data_ptr; // r0

  if ( error_data_ptr && *(_DWORD *)error_data_ptr == 3 )
    error_info = *(_QWORD *)(error_data_ptr + 8);
  else
    error_info = 0LL;
  new_error_data_ptr = get_error_description(16);
  if ( new_error_data_ptr )
  {
    *(_QWORD *)(new_error_data_ptr + 8) = error_info;
    *(_DWORD *)new_error_data_ptr = 3;
    *(_DWORD *)(new_error_data_ptr + 4) = 1;
  }
  return new_error_data_ptr;
}

//----- (00047170) --------------------------------------------------------
const void *__fastcall resize_and_maybe_move_buffer(
        _DWORD *buffer_info,
        int required_additional_size,
        int preserve_content)
{
  unsigned int current_capacity; // r12
  const void *current_buffer; // r5
  unsigned int double_current_capacity; // r3
  unsigned int needed_capacity; // r12
  unsigned int new_capacity; // r7
  void *new_buffer; // r0

  current_capacity = buffer_info[2];
  current_buffer = (const void *)buffer_info[4];
  if ( required_additional_size + buffer_info[3] <= current_capacity )
    return current_buffer;
  double_current_capacity = 2 * current_capacity;
  needed_capacity = current_capacity + required_additional_size;
  if ( double_current_capacity < needed_capacity )
    new_capacity = needed_capacity;
  else
    new_capacity = double_current_capacity;
  new_buffer = (void *)get_error_description(4 * new_capacity);
  if ( !new_buffer )
    return 0;
  buffer_info[2] = new_capacity;
  buffer_info[4] = new_buffer;
  if ( !preserve_content )
    return current_buffer;
  memcpy(new_buffer, current_buffer, 4 * buffer_info[3]);
  check_result_and_perform_action((int)current_buffer);
  return (const void *)buffer_info[4];
}

//----- (000471FC) --------------------------------------------------------
_DWORD *__fastcall format_error_message(_BYTE *input_buffer, size_t buffer_size, int buffer_prepared)
{
  _BYTE *processed_buffer; // r5
  _DWORD *error_description; // r0

  processed_buffer = input_buffer;
  if ( !input_buffer )
    return 0;
  if ( !buffer_prepared )
  {
    processed_buffer = copy_buffer_with_termination(input_buffer, buffer_size);
    if ( !processed_buffer )
      return 0;
  }
  error_description = (_DWORD *)get_error_description(16);
  if ( error_description )
  {
    error_description[2] = processed_buffer;
    error_description[3] = buffer_size;
    *error_description = 2;
    error_description[1] = 1;
  }
  else
  {
    check_result_and_perform_action((int)processed_buffer);
    return 0;
  }
  return error_description;
}

//----- (00047268) --------------------------------------------------------
_DWORD *initialize_miner_error_state()
{
  _DWORD *error_state; // r4
  int error_state_addr; // r0

  error_state = (_DWORD *)get_error_description(36);
  if ( error_state )
  {
    if ( !dword_70B70 )
      generate_unique_id(dword_70B70);
    error_state[1] = 1;
    *error_state = 0;
    if ( initialize_miner_data_structure(error_state + 2) )
    {
      error_state_addr = (int)error_state;
      error_state = 0;
      check_result_and_perform_action(error_state_addr);
    }
  }
  return error_state;
}
// 70B70: using guessed type int dword_70B70;

//----- (000472D0) --------------------------------------------------------
_DWORD *__fastcall get_error_or_next(_DWORD *node)
{
  if ( node )
  {
    if ( *node )
      return 0;
    else
      return (_DWORD *)node[2];
  }
  return node;
}

//----- (000472EC) --------------------------------------------------------
int __fastcall validate_and_fetch_data(_DWORD *header_ptr, char *data_ptr)
{
  bool is_invalid; // zf

  is_invalid = header_ptr == 0;
  if ( header_ptr )
    is_invalid = data_ptr == 0;
  if ( is_invalid || *header_ptr )
    return 0;
  else
    return calculate_hash_and_fetch_data((int)(header_ptr + 2), data_ptr);
}

//----- (00047314) --------------------------------------------------------
bool __fastcall compare_elements(int *element1, int *element2)
{
  int element_type; // r3
  int data_size_or_count; // r7
  int unused1; // r2
  unsigned int index_or_count; // r6
  int *unused2; // r1
  bool comparison_result; // zf
  int *data_or_sub_element1; // r0
  int *element1_ptr; // r8
  int current_element_ptr; // r0
  int *data_or_sub_element2; // r1
  int current_element_data; // r0
  char *current_element_char_ptr; // r6
  int element_data_offset; // r7
  int sub_element1_ptr; // r0
  char *current_element_data_ptr; // r1
  int *sub_element1; // r6
  size_t memory_size; // r2

  element_type = *element1;
  if ( *element1 != *element2 )
    return 0;
  if ( element1 == element2 )
    return 1;
  switch ( element_type )
  {
    case 0:
      if ( element1[2] != element2[2] )
        return 0;
      element1_ptr = element1 + 2;
      current_element_ptr = get_next_element((int)(element1 + 2));
      if ( !current_element_ptr )
        return 1;
      while ( 1 )
      {
        current_element_data = get_temperature_offset(current_element_ptr);
        current_element_char_ptr = (char *)current_element_data;
        if ( !current_element_data )
          break;
        element_data_offset = current_element_data - 16;
        sub_element1_ptr = get_temperature_value(current_element_data - 16);
        current_element_data_ptr = current_element_char_ptr;
        sub_element1 = (int *)sub_element1_ptr;
        if ( !sub_element1_ptr )
          break;
        data_or_sub_element2 = (int *)validate_and_fetch_data(element2, current_element_data_ptr);
        if ( !data_or_sub_element2 || !compare_elements(sub_element1, data_or_sub_element2) )
          return 0;
        if ( !*element1 )
        {
          current_element_ptr = check_status((int)element1_ptr, element_data_offset);
          if ( current_element_ptr )
            continue;
        }
        return 1;
      }
      return 1;
    case 1:
      data_size_or_count = element1[3];
      if ( data_size_or_count != element2[3] )
        return 0;
      if ( !data_size_or_count )
        return 1;
      unused1 = *element1;
      index_or_count = 0;
      break;
    case 2:
      memory_size = element1[3];
      return memory_size == element2[3] && !memcmp((const void *)element1[2], (const void *)element2[2], memory_size);
    case 3:
      return *((_QWORD *)element1 + 1) == *((_QWORD *)element2 + 1);
    case 4:
      return *((double *)element1 + 1) == *((double *)element2 + 1);
    default:
      return 0;
  }
  while ( 1 )
  {
    if ( element_type == 1 && element1[3] > index_or_count )
      data_or_sub_element1 = *(int **)(element1[4] + 4 * index_or_count);
    else
      data_or_sub_element1 = 0;
    if ( unused1 != 1 || element2[3] <= index_or_count )
      return 0;
    unused2 = *(int **)(element2[4] + 4 * index_or_count);
    comparison_result = unused2 == 0;
    if ( unused2 )
      comparison_result = data_or_sub_element1 == 0;
    if ( comparison_result || !compare_elements(data_or_sub_element1, unused2) )
      return 0;
    if ( data_size_or_count == ++index_or_count )
      break;
    element_type = *element1;
    unused1 = *element2;
  }
  return 1;
}
// 47348: control flows out of bounds to 4734C

//----- (000474F4) --------------------------------------------------------
int __fastcall check_and_remove_item(_DWORD *hash_table, char *item_key)
{
  bool is_invalid; // zf

  is_invalid = hash_table == 0;
  if ( hash_table )
    is_invalid = item_key == 0;
  if ( is_invalid || *hash_table )
    return -1;
  else
    return remove_item_from_hash_table(hash_table + 2, item_key);
}

//----- (00047554) --------------------------------------------------------
int __fastcall get_next_element_if_available(_DWORD *element_ptr)
{
  if ( !element_ptr || *element_ptr )
    return 0;
  else
    return get_next_element((int)(element_ptr + 2));
}

//----- (00047578) --------------------------------------------------------
int __fastcall add_key_to_hash_table_if_absent(_DWORD *hash_table_entry, char *key)
{
  bool is_invalid; // zf

  is_invalid = hash_table_entry == 0;
  if ( hash_table_entry )
    is_invalid = key == 0;
  if ( is_invalid || *hash_table_entry )
    return 0;
  else
    return add_string_to_hash_table((int)(hash_table_entry + 2), key);
}

//----- (000475A0) --------------------------------------------------------
int __fastcall sub_475A0(_DWORD *status_ptr, int check_flag)
{
  _BOOL4 is_status_checked; // r3

  if ( !status_ptr )
    return 0;
  is_status_checked = check_flag == 0;
  if ( *status_ptr )
    is_status_checked = 1;
  if ( is_status_checked )
    return 0;
  else
    return check_status((int)(status_ptr + 2), check_flag);
}

//----- (000475D4) --------------------------------------------------------
int __fastcall get_adjusted_temperature(int temperature)
{
  if ( temperature )
    return get_temperature_offset(temperature);
  return temperature;
}

//----- (000475E0) --------------------------------------------------------
int __fastcall get_temperature_if_valid(int temperature_sensor_id)
{
  if ( temperature_sensor_id )
    return get_temperature_value(temperature_sensor_id);
  return temperature_sensor_id;
}

//----- (000475EC) --------------------------------------------------------
int __fastcall adjust_result_value(int value)
{
  if ( value )
    value -= 16;
  return value;
}

//----- (000475F8) --------------------------------------------------------
_DWORD *initialize_error_description()
{
  _DWORD *error_desc_ptr; // r0
  _DWORD *error_data_ptr; // r4
  int error_description; // r0
  int temp_error_ptr; // r0

  error_desc_ptr = (_DWORD *)get_error_description(20);
  error_data_ptr = error_desc_ptr;
  if ( error_desc_ptr )
  {
    *error_desc_ptr = 1;
    error_desc_ptr[1] = 1;
    error_desc_ptr[3] = 0;
    error_desc_ptr[2] = 8;
    error_description = get_error_description(32);
    error_data_ptr[4] = error_description;
    if ( !error_description )
    {
      temp_error_ptr = (int)error_data_ptr;
      error_data_ptr = 0;
      check_result_and_perform_action(temp_error_ptr);
    }
  }
  return error_data_ptr;
}

//----- (00047658) --------------------------------------------------------
_DWORD *__fastcall get_next_structure_pointer(_DWORD *structure_pointer)
{
  if ( structure_pointer )
  {
    if ( *structure_pointer == 1 )
      return (_DWORD *)structure_pointer[3];
    else
      return 0;
  }
  return structure_pointer;
}

//----- (00047674) --------------------------------------------------------
_DWORD *__fastcall get_task_by_index(_DWORD *task_array, unsigned int index)
{
  if ( task_array )
  {
    if ( *task_array == 1 && task_array[3] > index )
      return *(_DWORD **)(task_array[4] + 4 * index);
    else
      return 0;
  }
  return task_array;
}

//----- (000476A8) --------------------------------------------------------
int __fastcall copy_and_increment_buffer_references(_DWORD *source_buffer, _DWORD *destination_buffer)
{
  _BOOL4 invalid_inputs; // r4
  __int64 destination_size_pair; // r0
  size_t entries_to_copy; // r2
  unsigned int current_index; // r3
  int current_entry_address; // r2
  int current_entry_ref_count; // r12
  unsigned int *ref_count_address; // r2
  unsigned int temp_ref_count; // r1
  int function_result; // r0

  if ( !source_buffer )
    return -1;
  invalid_inputs = *source_buffer != 1 || destination_buffer == 0;
  if ( invalid_inputs
    || *destination_buffer != 1
    || !resize_and_maybe_move_buffer(source_buffer, destination_buffer[3], 1) )
  {
    return -1;
  }
  destination_size_pair = *(_QWORD *)(destination_buffer + 3);
  entries_to_copy = destination_buffer[3];
  if ( (_DWORD)destination_size_pair )
  {
    current_index = 0;
    do
    {
      current_entry_address = *(_DWORD *)(HIDWORD(destination_size_pair) + 4 * current_index);
      if ( current_entry_address )
      {
        current_entry_ref_count = *(_DWORD *)(current_entry_address + 4);
        ref_count_address = (unsigned int *)(current_entry_address + 4);
        if ( current_entry_ref_count != -1 )
        {
          do
            temp_ref_count = __ldrex(ref_count_address);
          while ( __strex(temp_ref_count + 1, ref_count_address) );
          __dmb(11u);
          destination_size_pair = *(_QWORD *)(destination_buffer + 3);
        }
      }
      ++current_index;
    }
    while ( (unsigned int)destination_size_pair > current_index );
    entries_to_copy = 4 * destination_size_pair;
  }
  memcpy(
    (void *)(source_buffer[4] + 4 * source_buffer[3]),
    (const void *)HIDWORD(destination_size_pair),
    entries_to_copy);
  function_result = 0;
  source_buffer[3] += destination_buffer[3];
  return function_result;
}

//----- (00047780) --------------------------------------------------------
const char *__fastcall format_input_error_message(const char *input_string)
{
  char *char_input; // r4
  size_t input_length; // r0

  if ( input_string )
  {
    char_input = (char *)input_string;
    input_length = strlen(input_string);
    return (const char *)format_error_message(char_input, input_length, 0);
  }
  return input_string;
}

//----- (000477A8) --------------------------------------------------------
_DWORD *__fastcall format_error_message_wrapper(_BYTE *error_message, size_t message_size)
{
  return format_error_message(error_message, message_size, 0);
}

//----- (000477B0) --------------------------------------------------------
_DWORD *__fastcall format_miner_error_message(_BYTE *error_message, size_t message_size)
{
  return format_error_message(error_message, message_size, 1);
}

//----- (000477B8) --------------------------------------------------------
_DWORD *__fastcall validate_and_format_error_if_invalid_utf8(_BYTE *input_string, size_t string_length)
{
  if ( !input_string )
    return 0;
  if ( validate_utf8_string((int)input_string, string_length) )
    return format_error_message(input_string, string_length, 0);
  return 0;
}

//----- (000477FC) --------------------------------------------------------
const char *__fastcall validate_utf8_or_return_input(const char *input_string)
{
  char *utf8_string; // r4
  size_t string_length; // r0

  if ( input_string )
  {
    utf8_string = (char *)input_string;
    string_length = strlen(input_string);
    return (const char *)validate_and_format_error_if_invalid_utf8(utf8_string, string_length);
  }
  return input_string;
}

//----- (00047820) --------------------------------------------------------
_DWORD *__fastcall get_linked_item_or_null(_DWORD *item_pointer)
{
  if ( item_pointer )
  {
    if ( *item_pointer == 2 )
      return (_DWORD *)item_pointer[2];
    else
      return 0;
  }
  return item_pointer;
}

//----- (0004783C) --------------------------------------------------------
_DWORD *__fastcall get_associated_data(_DWORD *data_pointer)
{
  if ( data_pointer )
  {
    if ( *data_pointer == 2 )
      return (_DWORD *)data_pointer[3];
    else
      return 0;
  }
  return data_pointer;
}

//----- (00047858) --------------------------------------------------------
int __fastcall update_buffer(_DWORD *buffer_info, const void *source_buffer, size_t buffer_size)
{
  _BYTE *new_buffer; // r7
  int update_status; // r0

  if ( !buffer_info )
    return -1;
  if ( *buffer_info != 2 || source_buffer == 0 )
    return -1;
  new_buffer = copy_buffer_with_termination(source_buffer, buffer_size);
  if ( !new_buffer )
    return -1;
  check_result_and_perform_action(buffer_info[2]);
  update_status = 0;
  buffer_info[2] = new_buffer;
  buffer_info[3] = buffer_size;
  return update_status;
}

//----- (000478BC) --------------------------------------------------------
int __fastcall update_buffer_with_string(_DWORD *buffer, const char *string)
{
  size_t string_length; // r0

  if ( !string )
    return -1;
  string_length = strlen(string);
  return update_buffer(buffer, string, string_length);
}

//----- (000478F0) --------------------------------------------------------
int __fastcall update_if_valid_utf8(_DWORD *buffer, const void *input_string, size_t string_length)
{
  if ( input_string && validate_utf8_string((int)input_string, string_length) )
    return update_buffer(buffer, input_string, string_length);
  else
    return -1;
}

//----- (00047934) --------------------------------------------------------
int __fastcall check_and_update_utf8(_DWORD *output_buffer, const char *input_string)
{
  size_t input_length; // r0

  if ( !input_string )
    return -1;
  input_length = strlen(input_string);
  return update_if_valid_utf8(output_buffer, input_string, input_length);
}

//----- (00047968) --------------------------------------------------------
_DWORD *__fastcall sub_47968(char *format, __gnuc_va_list arg)
{
  int v3; // r0
  size_t v4; // r4
  char *error_description; // r0
  char *v6; // r7

  v3 = vsnprintf(0, 0, format, arg);
  v4 = v3;
  if ( !v3 )
    return validate_and_format_error_if_invalid_utf8("", 0);
  error_description = (char *)get_error_description(v3 + 1);
  v6 = error_description;
  if ( !error_description )
    return 0;
  vsnprintf(error_description, v4 + 1, format, arg);
  if ( validate_utf8_string((int)v6, v4) )
    return format_error_message(v6, v4, 1);
  check_result_and_perform_action((int)v6);
  return 0;
}

//----- (00047A18) --------------------------------------------------------
_DWORD *call_sub_47968_with_varargs(char *error_format_str, ...)
{
  va_list args; // [sp+14h] [bp-Ch] BYREF

  va_start(args, error_format_str);
  return format_error_message_with_va_list(error_format_str, args);
}

//----- (00047A48) --------------------------------------------------------
int __fastcall set_error_context(__int64 error_message_pointer)
{
  int error_context_pointer; // r0

  error_context_pointer = get_error_description(16);
  if ( error_context_pointer )
  {
    *(_QWORD *)(error_context_pointer + 8) = error_message_pointer;
    *(_DWORD *)error_context_pointer = 3;
    *(_DWORD *)(error_context_pointer + 4) = 1;
  }
  return error_context_pointer;
}

//----- (00047A7C) --------------------------------------------------------
__int64 __fastcall get_linked_list_next_node(int node_pointer)
{
  if ( node_pointer && *(_DWORD *)node_pointer == 3 )
    return *(_QWORD *)(node_pointer + 8);
  else
    return 0LL;
}

//----- (00047AA4) --------------------------------------------------------
int __fastcall set_miner_time(int miner_config_pointer, __int64 timestamp)
{
  if ( !miner_config_pointer || *(_DWORD *)miner_config_pointer != 3 )
    return -1;
  *(_QWORD *)(miner_config_pointer + 8) = timestamp;
  return 0;
}

//----- (00047ACC) --------------------------------------------------------
int check_and_set_error_description()
{
  double value; // d0
  int operation_status; // r0

  if ( fabs(value) > 1.79769313e308 )
    return 0;
  operation_status = get_error_description(16);
  if ( operation_status )
  {
    *(double *)(operation_status + 8) = value;
    *(_DWORD *)operation_status = 4;
    *(_DWORD *)(operation_status + 4) = 1;
  }
  return operation_status;
}
// 47ADC: variable 'value' is possibly undefined

//----- (00047B28) --------------------------------------------------------
void sub_47B28()
{
  ;
}

//----- (00047BB8) --------------------------------------------------------
int __fastcall check_and_update_double_value(double input_value)
{
  if ( LODWORD(input_value) && *(_DWORD *)LODWORD(input_value) == 3 )
    input_value = convert_float_to_int(*(_DWORD *)(LODWORD(input_value) + 8));
  return LODWORD(input_value);
}
// 4930C: using guessed type double __fastcall sub_4930C(_DWORD);

//----- (00047C00) --------------------------------------------------------
void *get_reference_to_unk_664D4()
{
  return &unk_664D4;
}

//----- (00047C0C) --------------------------------------------------------
void *get_global_variable_address()
{
  return &unk_664DC;
}

//----- (00047C18) --------------------------------------------------------
void *get_config_base_address()
{
  return &unk_664E4;
}

//----- (00047C24) --------------------------------------------------------
_DWORD *__fastcall process_bitmain_miner(_DWORD *miner_data)
{
  _DWORD *current_miner_data; // r4
  int current_data_ptr; // r0
  unsigned int data_count; // r1
  unsigned int index; // r5
  _DWORD *current_element_ptr; // r3
  unsigned int *ref_counter_ptr; // r2
  unsigned int current_ref_count; // r1
  unsigned int updated_ref_count; // r1

  current_miner_data = miner_data;
  if ( miner_data )
  {
    switch ( *miner_data )
    {
      case 0:
        update_and_get_miner_status(miner_data + 2);
        return (_DWORD *)check_result_and_perform_action(current_miner_data);
      case 1:
        data_count = miner_data[3];
        current_data_ptr = miner_data[4];
        if ( data_count )
        {
          for ( index = 0; index < data_count; ++index )
          {
            current_element_ptr = *(_DWORD **)(current_data_ptr + 4 * index);
            if ( current_element_ptr )
            {
              ref_counter_ptr = current_element_ptr + 1;
              if ( current_element_ptr[1] != -1 )
              {
                __dmb(11u);
                do
                {
                  current_ref_count = __ldrex(ref_counter_ptr);
                  updated_ref_count = current_ref_count - 1;
                }
                while ( __strex(updated_ref_count, ref_counter_ptr) );
                if ( !updated_ref_count )
                  process_bitmain_miner(current_element_ptr);
                current_data_ptr = current_miner_data[4];
                data_count = current_miner_data[3];
              }
            }
          }
        }
        goto LABEL_4;
      case 2:
        current_data_ptr = miner_data[2];
LABEL_4:
        check_result_and_perform_action(current_data_ptr);
        goto LABEL_5;
      case 3:
      case 4:
LABEL_5:
        miner_data = (_DWORD *)check_result_and_perform_action(current_miner_data);
        break;
      default:
        return miner_data;
    }
  }
  return miner_data;
}
// 47C3C: control flows out of bounds to 47C40
// 44A54: using guessed type int __fastcall sub_44A54(_DWORD);
// 46954: using guessed type int __fastcall sub_46954(_DWORD);

//----- (00047CF0) --------------------------------------------------------
int __fastcall process_miner_operations(_DWORD *miner_data)
{
  unsigned int operation_count; // r2
  unsigned int index; // r4
  _DWORD *current_operation_data; // r0
  unsigned int *operation_counter; // r3
  unsigned int current_count; // r2
  unsigned int decremented_count; // r2
  int status; // r0

  if ( !miner_data || *miner_data != 1 )
    return -1;
  operation_count = miner_data[3];
  if ( operation_count )
  {
    for ( index = 0; index < operation_count; ++index )
    {
      current_operation_data = *(_DWORD **)(miner_data[4] + 4 * index);
      if ( current_operation_data )
      {
        operation_counter = current_operation_data + 1;
        if ( current_operation_data[1] != -1 )
        {
          __dmb(11u);
          do
          {
            current_count = __ldrex(operation_counter);
            decremented_count = current_count - 1;
          }
          while ( __strex(decremented_count, operation_counter) );
          if ( !decremented_count )
            process_bitmain_miner(current_operation_data);
          operation_count = miner_data[3];
        }
      }
    }
  }
  status = 0;
  miner_data[3] = 0;
  return status;
}

//----- (00047D80) --------------------------------------------------------
int __fastcall process_miner_action(_DWORD *status_flag, int action_code, _DWORD *miner_data)
{
  _BOOL4 should_process; // r4
  unsigned int *miner_control; // r3
  unsigned int current_value; // r1
  unsigned int updated_value; // r1

  if ( !status_flag || *status_flag )
    goto LABEL_8;
  if ( !action_code )
    should_process = 1;
  if ( action_code )
    should_process = miner_data == 0;
  if ( should_process )
  {
LABEL_8:
    if ( !miner_data )
      return -1;
    if ( miner_data[1] == -1 )
      return -1;
    miner_control = miner_data + 1;
    __dmb(11u);
    do
    {
      current_value = __ldrex(miner_control);
      updated_value = current_value - 1;
    }
    while ( __strex(updated_value, miner_control) );
    if ( updated_value )
    {
      return -1;
    }
    else
    {
      process_bitmain_miner(miner_data);
      return -1;
    }
  }
  else
  {
    update_miner_process(action_code, (int)miner_data);
    return 0;
  }
}
// 47E04: variable 'should_process' is possibly undefined

//----- (00047E18) --------------------------------------------------------
int __fastcall decrement_processor_counter(_DWORD *proc_control_block, unsigned int processor_idx)
{
  unsigned int processor_count; // r12
  unsigned int processor_offset; // r6
  _DWORD *processor_ptr; // r0
  int new_processor_count; // r3
  unsigned int *ref_count_ptr; // r3
  unsigned int current_ref_count; // r2
  unsigned int new_ref_count; // r2

  if ( proc_control_block )
  {
    if ( *proc_control_block == 1 )
    {
      processor_count = proc_control_block[3];
      if ( processor_count > processor_idx )
      {
        processor_offset = 4 * processor_idx;
        processor_ptr = *(_DWORD **)(proc_control_block[4] + 4 * processor_idx);
        if ( processor_ptr && processor_ptr[1] != -1 )
        {
          ref_count_ptr = processor_ptr + 1;
          __dmb(11u);
          do
          {
            current_ref_count = __ldrex(ref_count_ptr);
            new_ref_count = current_ref_count - 1;
          }
          while ( __strex(new_ref_count, ref_count_ptr) );
          if ( !new_ref_count )
            process_bitmain_miner(processor_ptr);
          processor_count = proc_control_block[3];
          new_processor_count = processor_count - 1;
          if ( processor_count - 1 <= processor_idx )
            goto LABEL_7;
        }
        else
        {
          new_processor_count = processor_count - 1;
          if ( processor_count - 1 <= processor_idx )
          {
LABEL_7:
            proc_control_block[3] = new_processor_count;
            return 0;
          }
        }
        memmove(
          (void *)(proc_control_block[4] + processor_offset),
          (const void *)(proc_control_block[4] + processor_offset + 4),
          4 * (~processor_idx + processor_count));
        new_processor_count = proc_control_block[3] - 1;
        goto LABEL_7;
      }
    }
  }
  return -1;
}

//----- (00047EE4) --------------------------------------------------------
int __fastcall manage_bitmain_worker(_DWORD *worker_buffer, char *worker_id, _DWORD *worker_status)
{
  bool status_check; // zf
  int operation_status; // r0
  _BOOL4 update_required; // r3
  unsigned int *worker_count_ptr; // r3
  unsigned int current_worker_count; // r2
  unsigned int updated_worker_count; // r2
  unsigned int *count_pointer; // r3
  unsigned int initial_worker_count; // r2

  if ( !worker_status )
    return -1;
  status_check = worker_buffer == 0;
  if ( worker_buffer )
    status_check = worker_id == 0;
  if ( !status_check )
  {
    update_required = worker_status == worker_buffer;
    if ( *worker_buffer )
      update_required = 1;
    if ( !update_required )
    {
      operation_status = insert_or_update_node(worker_buffer + 2, worker_id, (int)worker_status);
      if ( !operation_status )
        return operation_status;
      if ( worker_status[1] != -1 )
      {
        worker_count_ptr = worker_status + 1;
        __dmb(11u);
        do
        {
          current_worker_count = __ldrex(worker_count_ptr);
          updated_worker_count = current_worker_count - 1;
        }
        while ( __strex(updated_worker_count, worker_count_ptr) );
        goto LABEL_18;
      }
      return -1;
    }
  }
  if ( worker_status[1] == -1 )
    return -1;
  count_pointer = worker_status + 1;
  __dmb(11u);
  do
  {
    initial_worker_count = __ldrex(count_pointer);
    updated_worker_count = initial_worker_count - 1;
  }
  while ( __strex(updated_worker_count, count_pointer) );
LABEL_18:
  if ( updated_worker_count )
    return -1;
  process_bitmain_miner(worker_status);
  return -1;
}

//----- (00047FA0) --------------------------------------------------------
int __fastcall update_temp_and_manage_worker(_DWORD *controller, _DWORD *worker_status)
{
  _BOOL4 is_invalid; // r3
  _DWORD *worker_status_ptr; // r9
  int next_element; // r0
  unsigned int *temp_value_ptr; // r3
  unsigned int current_temp_increment; // r2
  int temp_data_offset; // r0
  char *temp_data; // r4
  _DWORD *temp_value; // r8

  if ( !controller )
    return -1;
  is_invalid = worker_status == 0;
  if ( *controller )
    is_invalid = 1;
  if ( is_invalid || *worker_status )
    return -1;
  worker_status_ptr = worker_status + 2;
  for ( next_element = get_next_element((int)(worker_status + 2));
        next_element;
        next_element = check_status((int)worker_status_ptr, (int)(temp_data - 16)) )
  {
    temp_data_offset = get_temperature_offset(next_element);
    temp_data = (char *)temp_data_offset;
    if ( !temp_data_offset )
      break;
    temp_value = (_DWORD *)get_temperature_value(temp_data_offset - 16);
    if ( !temp_value )
      break;
    if ( !validate_and_fetch_data(controller, temp_data) )
    {
      temp_value_ptr = temp_value + 1;
      if ( temp_value[1] != -1 )
      {
        do
          current_temp_increment = __ldrex(temp_value_ptr);
        while ( __strex(current_temp_increment + 1, temp_value_ptr) );
        __dmb(11u);
      }
      manage_bitmain_worker(controller, temp_data, temp_value);
    }
    if ( *worker_status )
      break;
  }
  return 0;
}

//----- (0004808C) --------------------------------------------------------
int __fastcall configure_miner_connection(_DWORD *device_handle, char *worker_url, _DWORD *connection_status)
{
  unsigned int worker_url_length; // r0
  unsigned int *retry_counter_ptr; // r3
  unsigned int current_retry_count; // r2
  unsigned int updated_retry_count; // r2

  if ( worker_url )
  {
    worker_url_length = strlen(worker_url);
    if ( validate_utf8_string((int)worker_url, worker_url_length) )
      return manage_bitmain_worker(device_handle, worker_url, connection_status);
  }
  if ( !connection_status )
    return -1;
  if ( connection_status[1] == -1 )
    return -1;
  retry_counter_ptr = connection_status + 1;
  __dmb(11u);
  do
  {
    current_retry_count = __ldrex(retry_counter_ptr);
    updated_retry_count = current_retry_count - 1;
  }
  while ( __strex(updated_retry_count, retry_counter_ptr) );
  if ( updated_retry_count )
    return -1;
  process_bitmain_miner(connection_status);
  return -1;
}

//----- (00048120) --------------------------------------------------------
int __fastcall update_temperature_statistics(_DWORD *miner_status, _DWORD *temperature_data)
{
  _BOOL4 update_condition; // r3
  _DWORD *temperature_data_offset; // r8
  int current_element_ptr; // r0
  unsigned int current_temperature_count; // r1
  int current_temperature_ptr; // r0
  char *temperature_offset_ptr; // r5
  _DWORD *current_temperature_data; // r0
  unsigned int *temperature_count_ptr; // r3

  if ( !miner_status )
    return -1;
  update_condition = temperature_data == 0;
  if ( *miner_status )
    update_condition = 1;
  if ( update_condition || *temperature_data )
    return -1;
  temperature_data_offset = temperature_data + 2;
  current_element_ptr = get_next_element((int)(temperature_data + 2));
  if ( current_element_ptr )
  {
    while ( 1 )
    {
      current_temperature_ptr = get_temperature_offset(current_element_ptr);
      temperature_offset_ptr = (char *)current_temperature_ptr;
      if ( !current_temperature_ptr )
        break;
      current_temperature_data = (_DWORD *)get_temperature_value(current_temperature_ptr - 16);
      temperature_count_ptr = current_temperature_data + 1;
      if ( !current_temperature_data )
        return 0;
      if ( current_temperature_data[1] != -1 )
      {
        do
          current_temperature_count = __ldrex(temperature_count_ptr);
        while ( __strex(current_temperature_count + 1, temperature_count_ptr) );
        __dmb(11u);
      }
      if ( manage_bitmain_worker(miner_status, temperature_offset_ptr, current_temperature_data) )
        return -1;
      if ( !*temperature_data )
      {
        current_element_ptr = check_status((int)temperature_data_offset, (int)(temperature_offset_ptr - 16));
        if ( current_element_ptr )
          continue;
      }
      return 0;
    }
  }
  return 0;
}

//----- (00048200) --------------------------------------------------------
int __fastcall process_temperature_data(_DWORD *control_structure, _DWORD *temperature_list)
{
  _BOOL4 is_invalid; // r3
  _DWORD *temperature_list_ptr; // r9
  int current_element; // r0
  unsigned int *temperature_value_next; // r3
  unsigned int incremented_value; // r2
  int current_offset; // r0
  char *current_temperature_ptr; // r4
  _DWORD *temperature_data; // r6

  if ( !control_structure )
    return -1;
  is_invalid = temperature_list == 0;
  if ( *control_structure )
    is_invalid = 1;
  if ( is_invalid || *temperature_list )
    return -1;
  temperature_list_ptr = temperature_list + 2;
  for ( current_element = get_next_element((int)(temperature_list + 2));
        current_element;
        current_element = check_status((int)temperature_list_ptr, (int)(current_temperature_ptr - 16)) )
  {
    current_offset = get_temperature_offset(current_element);
    current_temperature_ptr = (char *)current_offset;
    if ( !current_offset )
      break;
    temperature_data = (_DWORD *)get_temperature_value(current_offset - 16);
    if ( !temperature_data )
      break;
    if ( validate_and_fetch_data(control_structure, current_temperature_ptr) )
    {
      temperature_value_next = temperature_data + 1;
      if ( temperature_data[1] != -1 )
      {
        do
          incremented_value = __ldrex(temperature_value_next);
        while ( __strex(incremented_value + 1, temperature_value_next) );
        __dmb(11u);
      }
      manage_bitmain_worker(control_structure, current_temperature_ptr, temperature_data);
    }
    if ( *temperature_list )
      break;
  }
  return 0;
}

//----- (000482F0) --------------------------------------------------------
int __fastcall process_bitcoin_miner_input(_DWORD *current_state, unsigned int input_index, _DWORD *miner_data)
{
  int is_same_or_first_state; // r2
  int operation_result; // r0
  unsigned int *miner_data_ref_counter; // r3
  unsigned int current_ref_count; // r2
  unsigned int decremented_ref_count; // r2
  char *resized_buffer; // r8
  char *current_buffer; // r0
  unsigned int offset_index; // r7
  int new_state_count; // r3
  unsigned int *miner_data_ref_counter_after_resize; // r3
  unsigned int current_ref_count_after_resize; // r2

  if ( !miner_data )
    return -1;
  if ( !current_state )
    goto LABEL_6;
  is_same_or_first_state = miner_data == current_state;
  if ( *current_state != 1 )
    is_same_or_first_state |= 1u;
  if ( is_same_or_first_state || current_state[3] < input_index )
  {
LABEL_6:
    if ( miner_data[1] == -1 )
      return -1;
    miner_data_ref_counter = miner_data + 1;
    __dmb(11u);
    do
    {
      current_ref_count = __ldrex(miner_data_ref_counter);
      decremented_ref_count = current_ref_count - 1;
    }
    while ( __strex(decremented_ref_count, miner_data_ref_counter) );
LABEL_10:
    if ( !decremented_ref_count )
    {
      process_bitmain_miner(miner_data);
      return -1;
    }
    return -1;
  }
  resized_buffer = (char *)resize_and_maybe_move_buffer(current_state, 1, 0);
  if ( !resized_buffer )
  {
    if ( miner_data[1] == -1 )
      return -1;
    miner_data_ref_counter_after_resize = miner_data + 1;
    __dmb(11u);
    do
    {
      current_ref_count_after_resize = __ldrex(miner_data_ref_counter_after_resize);
      decremented_ref_count = current_ref_count_after_resize - 1;
    }
    while ( __strex(decremented_ref_count, miner_data_ref_counter_after_resize) );
    goto LABEL_10;
  }
  current_buffer = (char *)current_state[4];
  offset_index = 4 * (input_index + 1);
  if ( current_buffer == resized_buffer )
  {
    memmove(&current_buffer[offset_index], &resized_buffer[offset_index - 4], 4 * (current_state[3] - input_index));
  }
  else
  {
    memcpy(current_buffer, resized_buffer, offset_index - 4);
    memcpy(
      (void *)(current_state[4] + offset_index),
      &resized_buffer[offset_index - 4],
      4 * (current_state[3] - input_index));
    check_result_and_perform_action((int)resized_buffer);
  }
  operation_result = 0;
  new_state_count = current_state[3] + 1;
  *(_DWORD *)(current_state[4] + offset_index - 4) = miner_data;
  current_state[3] = new_state_count;
  return operation_result;
}

//----- (0004854C) --------------------------------------------------------
int __fastcall add_buffer_to_queue(_DWORD *queue, _DWORD *buffer)
{
  _BOOL4 is_buffer_not_valid; // r5
  int status; // r0
  unsigned int *buffer_ref_counter; // r3
  unsigned int current_ref_count; // r2
  unsigned int new_ref_count; // r2
  int queue_tail; // r3
  unsigned int *buffer_ref_counter_loop; // r3
  unsigned int current_ref_count_loop; // r2

  if ( !buffer )
    return -1;
  if ( !queue )
    goto LABEL_6;
  is_buffer_not_valid = buffer == queue;
  if ( *queue != 1 )
    is_buffer_not_valid = 1;
  if ( !is_buffer_not_valid )
  {
    if ( resize_and_maybe_move_buffer(queue, 1, 1) )
    {
      queue_tail = queue[3];
      status = 0;
      *(_DWORD *)(queue[4] + 4 * queue_tail) = buffer;
      queue[3] = queue_tail + 1;
      return status;
    }
    if ( buffer[1] == -1 )
      return -1;
    buffer_ref_counter_loop = buffer + 1;
    __dmb(11u);
    do
    {
      current_ref_count_loop = __ldrex(buffer_ref_counter_loop);
      new_ref_count = current_ref_count_loop - 1;
    }
    while ( __strex(new_ref_count, buffer_ref_counter_loop) );
  }
  else
  {
LABEL_6:
    if ( buffer[1] == -1 )
      return -1;
    buffer_ref_counter = buffer + 1;
    __dmb(11u);
    do
    {
      current_ref_count = __ldrex(buffer_ref_counter);
      new_ref_count = current_ref_count - 1;
    }
    while ( __strex(new_ref_count, buffer_ref_counter) );
  }
  if ( new_ref_count )
    return -1;
  process_bitmain_miner(buffer);
  return -1;
}

//----- (00048628) --------------------------------------------------------
bool __fastcall are_elements_comparable_and_equal(int *element1, int *element2)
{
  bool is_null; // zf

  is_null = element2 == 0;
  if ( element2 )
    is_null = element1 == 0;
  return !is_null && compare_elements(element1, element2);
}

//----- (00048640) --------------------------------------------------------
_DWORD *__fastcall sub_48640(int a1)
{
  _DWORD *v2; // r7
  int i; // r0
  unsigned int v4; // r1
  int temperature_offset; // r0
  char *v6; // r5
  _DWORD *temperature_value; // r0
  unsigned int *v8; // r3
  unsigned int v9; // r3
  unsigned int j; // r5
  _DWORD *v11; // r1
  unsigned int *v12; // r2
  unsigned int v13; // r3

  if ( a1 )
  {
    switch ( *(_DWORD *)a1 )
    {
      case 0:
        v2 = initialize_miner_error_state();
        if ( !v2 )
          return 0;
        if ( !*(_DWORD *)a1 )
        {
          for ( i = get_next_element(a1 + 8); i; i = check_status(a1 + 8, (int)(v6 - 16)) )
          {
            temperature_offset = get_temperature_offset(i);
            v6 = (char *)temperature_offset;
            if ( !temperature_offset )
              break;
            temperature_value = (_DWORD *)get_temperature_value(temperature_offset - 16);
            v8 = temperature_value + 1;
            if ( !temperature_value )
              break;
            if ( temperature_value[1] != -1 )
            {
              do
                v4 = __ldrex(v8);
              while ( __strex(v4 + 1, v8) );
              __dmb(11u);
            }
            manage_bitmain_worker(v2, v6, temperature_value);
            if ( *(_DWORD *)a1 )
              break;
          }
        }
        return v2;
      case 1:
        v2 = initialize_error_description();
        if ( !v2 )
          return 0;
        if ( *(_DWORD *)a1 == 1 )
        {
          v9 = *(_DWORD *)(a1 + 12);
          if ( v9 )
          {
            for ( j = 0; j < v9; ++j )
            {
              v11 = 0;
              if ( v9 > j )
              {
                v11 = *(_DWORD **)(*(_DWORD *)(a1 + 16) + 4 * j);
                v12 = v11 + 1;
                if ( v11 )
                {
                  if ( v11[1] != -1 )
                  {
                    do
                      v13 = __ldrex(v12);
                    while ( __strex(v13 + 1, v12) );
                    __dmb(11u);
                  }
                }
              }
              add_buffer_to_queue(v2, v11);
              if ( *(_DWORD *)a1 != 1 )
                break;
              v9 = *(_DWORD *)(a1 + 12);
            }
          }
        }
        return v2;
      case 2:
        return format_error_message(*(_BYTE **)(a1 + 8), *(_DWORD *)(a1 + 12), 0);
      case 3:
        return (_DWORD *)copy_error_description(a1);
      case 4:
        return (_DWORD *)check_and_set_error_description();
      case 5:
      case 6:
      case 7:
        return (_DWORD *)a1;
      default:
        return 0;
    }
  }
  return 0;
}
// 48658: control flows out of bounds to 4865C

//----- (000487FC) --------------------------------------------------------
_DWORD *__fastcall handle_error_code(int error_code)
{
  _DWORD *v2; // r6
  int next_element; // r5
  char *temperature_offset_str; // r7
  int temperature_value_arg; // r0
  _DWORD *recursed_result; // r0
  unsigned int element_count; // r3
  unsigned int i; // r5
  int queue_element; // r0
  _DWORD *queue_result; // r0

  if ( error_code )
  {
    switch ( *(_DWORD *)error_code )
    {
      case 0:
        v2 = initialize_miner_error_state();
        if ( !v2 )
          return 0;
        if ( !*(_DWORD *)error_code )
        {
          for ( next_element = get_next_element(error_code + 8);
                next_element;
                next_element = check_status(error_code + 8, next_element) )
          {
            temperature_offset_str = (char *)get_temperature_offset(next_element);
            temperature_value_arg = get_temperature_value(next_element);
            recursed_result = handle_error_code(temperature_value_arg);
            manage_bitmain_worker(v2, temperature_offset_str, recursed_result);
            if ( *(_DWORD *)error_code )
              break;
          }
        }
        return v2;
      case 1:
        v2 = initialize_error_description();
        if ( !v2 )
          return 0;
        if ( *(_DWORD *)error_code == 1 )
        {
          element_count = *(_DWORD *)(error_code + 12);
          if ( element_count )
          {
            for ( i = 0; i < element_count; ++i )
            {
              queue_element = 0;
              if ( element_count > i )
                queue_element = *(_DWORD *)(*(_DWORD *)(error_code + 16) + 4 * i);
              queue_result = handle_error_code(queue_element);
              add_buffer_to_queue(v2, queue_result);
              if ( *(_DWORD *)error_code != 1 )
                break;
              element_count = *(_DWORD *)(error_code + 12);
            }
          }
        }
        return v2;
      case 2:
        return format_error_message(*(_BYTE **)(error_code + 8), *(_DWORD *)(error_code + 12), 0);
      case 3:
        return (_DWORD *)copy_error_description(error_code);
      case 4:
        return (_DWORD *)check_and_set_error_description();
      case 5:
      case 6:
      case 7:
        return (_DWORD *)error_code;
      default:
        return 0;
    }
  }
  return 0;
}
// 48814: control flows out of bounds to 48818

//----- (00048960) --------------------------------------------------------
char *__fastcall copy_trimmed_string_if_long(int destination, char *source)
{
  size_t source_length; // r0

  source_length = strlen(source);
  if ( source_length <= 79 )
    return strncpy((char *)(destination + 12), source, source_length + 1);
  qmemcpy((void *)(destination + 12), "...", 3);
  return strncpy((char *)(destination + 15), &source[source_length - 76], 77u);
}

//----- (000489C4) --------------------------------------------------------
char *__fastcall initialize_miner_status(char *status_buffer, char *input_string)
{
  if ( status_buffer )
  {
    status_buffer[92] = 0;
    *((_DWORD *)status_buffer + 2) = 0;
    *(_DWORD *)status_buffer = -1;
    *((_DWORD *)status_buffer + 1) = -1;
    if ( input_string )
      return copy_trimmed_string_if_long((int)status_buffer, input_string);
    else
      status_buffer[12] = 0;
  }
  return status_buffer;
}

//----- (00048A04) --------------------------------------------------------
char *__fastcall check_and_trim_string(char *trimmed_string, char *original_string)
{
  bool is_null; // zf

  is_null = original_string == 0;
  if ( original_string )
    is_null = trimmed_string == 0;
  if ( !is_null )
    return copy_trimmed_string_if_long((int)trimmed_string, original_string);
  return trimmed_string;
}

//----- (00048A14) --------------------------------------------------------
int format_log_message(int log_struct_ptr, int level, int module, int timestamp, int flags, char *format, ...)
{
  int v6; // r4
  va_list arg; // [sp+20h] [bp+8h] BYREF

  va_start(arg, format);
  v6 = log_struct_ptr;
  if ( log_struct_ptr )
  {
    if ( !*(_BYTE *)(log_struct_ptr + 92) )
    {
      *(_DWORD *)log_struct_ptr = level;
      *(_DWORD *)(log_struct_ptr + 4) = module;
      *(_DWORD *)(log_struct_ptr + 8) = timestamp;
      log_struct_ptr = vsnprintf((char *)(log_struct_ptr + 92), 159u, format, arg);
      *(_BYTE *)(v6 + 250) = 0;
      *(_BYTE *)(v6 + 251) = flags;
    }
  }
  return log_struct_ptr;
}

//----- (00048A78) --------------------------------------------------------
int __fastcall update_logging_buffer(
        int buffer_ptr,
        int log_level,
        int timestamp,
        int unknown_param,
        int newValue_byte251,
        char *format,
        __gnuc_va_list arg_list)
{
  int buffer_backup; // r4

  buffer_backup = buffer_ptr;
  if ( buffer_ptr )
  {
    if ( !*(_BYTE *)(buffer_ptr + 92) )
    {
      *(_DWORD *)buffer_ptr = log_level;
      *(_DWORD *)(buffer_ptr + 4) = timestamp;
      *(_DWORD *)(buffer_ptr + 8) = unknown_param;
      buffer_ptr = vsnprintf((char *)(buffer_ptr + 92), 159u, format, arg_list);
      *(_BYTE *)(buffer_backup + 250) = 0;
      *(_BYTE *)(buffer_backup + 251) = newValue_byte251;
    }
  }
  return buffer_ptr;
}

//----- (00048AC8) --------------------------------------------------------
unsigned int __fastcall calculate_miner_hashrate(unsigned int hashrate, unsigned int target_hashrate)
{
  if ( target_hashrate != 1 )
  {
    if ( !target_hashrate )
      JUMPOUT(299928);
    if ( hashrate <= target_hashrate )
    {
      return hashrate == target_hashrate;
    }
    else if ( (target_hashrate & (target_hashrate - 1)) != 0 )
    {
      return ((int (*)(void))((char *)&loc_48B00 + 16 * (31 - (__clz(target_hashrate) - __clz(hashrate)))))();
    }
    else
    {
      hashrate >>= 31 - __clz(target_hashrate);
    }
  }
  return hashrate;
}
// 48D20: control flows out of bounds to 49398

//----- (00048D24) --------------------------------------------------------
unsigned int __fastcall calculate_hashrate_if_valid(unsigned int current_time, unsigned int previous_time)
{
  if ( !previous_time )
    JUMPOUT(298266);
  return calculate_miner_hashrate(current_time, previous_time);
}
// 48D26: control flows out of bounds to 48D1A

//----- (00048D40) --------------------------------------------------------
int __fastcall calculate_modulo_via_bitshift(int initial_value, unsigned int divider)
{
  signed int xor_result; // r12
  unsigned int abs_initial_value; // r3

  if ( !divider )
    JUMPOUT(299928);
  xor_result = initial_value ^ divider;
  if ( (divider & 2147483648) != 0 )
    divider = -divider;
  if ( divider == 1 )
  {
    if ( (xor_result ^ initial_value) < 0 )
      return -initial_value;
  }
  else
  {
    abs_initial_value = initial_value;
    if ( initial_value < 0 )
      abs_initial_value = -initial_value;
    if ( abs_initial_value <= divider )
    {
      if ( abs_initial_value < divider )
        initial_value = 0;
      if ( abs_initial_value == divider )
        return (xor_result >> 31) | 1;
    }
    else if ( (divider & (divider - 1)) != 0 )
    {
      return ((int (__fastcall *)(_DWORD))((char *)&loc_48D88 + 16 * (31 - (__clz(divider) - __clz(abs_initial_value)))))(0);
    }
    else
    {
      initial_value = abs_initial_value >> (31 - __clz(divider));
      if ( xor_result < 0 )
        return -initial_value;
    }
  }
  return initial_value;
}
// 48FD0: control flows out of bounds to 49398

//----- (000492FC) --------------------------------------------------------
int __fastcall check_null_pointer(__int64 pointer)
{
  if ( pointer )
    JUMPOUT(299810);
  return pointer;
}
// 4930A: control flows out of bounds to 49322

//----- (0004930C) --------------------------------------------------------
int __fastcall sub_4930C(__int64 a1)
{
  bool v1; // cf
  int v2; // off
  int v3; // r4
  bool v4; // zf
  unsigned int v5; // r3
  int v6; // r3
  bool v7; // cc
  int v8; // r2
  unsigned int v9; // r12
  int v10; // r4
  int v11; // r4
  char v12; // r4
  int v13; // r4
  unsigned int v14; // r12
  int v15; // r2
  int v16; // r2

  if ( !a1 )
    return a1;
  if ( a1 < 0 )
  {
    v1 = (_DWORD)a1 == 0;
    LODWORD(a1) = -(int)a1;
    HIDWORD(a1) -= 2 * HIDWORD(a1) + !v1;
  }
  v13 = 1074;
  v14 = HIDWORD(a1) >> 22;
  if ( HIDWORD(a1) >> 22 )
  {
    v15 = 3;
    if ( HIDWORD(a1) >> 25 )
      v15 = 6;
    if ( HIDWORD(a1) >> 28 )
      v15 += 3;
    v16 = v15 + (HIDWORD(a1) >> 31);
    v14 = (_DWORD)a1 << (32 - v16);
    LODWORD(a1) = ((unsigned int)a1 >> v16) | (HIDWORD(a1) << (32 - v16));
    HIDWORD(a1) >>= v16;
    v13 = v16 + 1074;
  }
  if ( HIDWORD(a1) >= 1048576 )
  {
    if ( HIDWORD(a1) >= 2097152 )
    {
      v1 = a1 & 1;
      LODWORD(a1) = a1 >> 1;
      v14 = (v14 >> 1) | (v1 << 31);
      if ( (unsigned int)((v13 + 1) << 21) >= 4290772992 )
      {
        LODWORD(a1) = 0;
        return a1;
      }
    }
    goto LABEL_13;
  }
  v1 = __CFSHL__(v14, 1);
  v14 *= 2;
  v2 = v1 + (_DWORD)a1;
  v1 = __CFADD__(v1, (_DWORD)a1) | __CFADD__((_DWORD)a1, v2);
  LODWORD(a1) = a1 + v2;
  HIDWORD(a1) += v1 + HIDWORD(a1);
  v3 = v13 - 1;
  if ( (a1 & 0x10000000000000LL) != 0 )
  {
LABEL_13:
    v1 = v14 >= 2147483648;
    if ( v14 == -2147483648 )
      v1 = a1 & 1;
    LODWORD(a1) = v1 + (_DWORD)a1;
    return a1;
  }
  v4 = HIDWORD(a1) == 0;
  if ( !HIDWORD(a1) )
  {
    HIDWORD(a1) = a1;
    LODWORD(a1) = 0;
  }
  v5 = __clz(HIDWORD(a1));
  if ( v4 )
    v5 += 32;
  v6 = v5 - 11;
  v8 = v6 - 32;
  v7 = v6 <= 32;
  if ( v6 >= 32 )
    goto LABEL_25;
  v7 = v8 <= -12;
  if ( v8 <= -12 )
  {
    LOBYTE(v8) = v6;
LABEL_25:
    if ( v7 )
      LOBYTE(v14) = 32 - v8;
    HIDWORD(a1) <<= v8;
    v9 = (unsigned int)a1 >> v14;
    if ( v7 )
    {
      HIDWORD(a1) |= v9;
      LODWORD(a1) = (_DWORD)a1 << v8;
    }
    goto LABEL_29;
  }
  LODWORD(a1) = HIDWORD(a1) << v6;
  HIDWORD(a1) >>= 32 - v6;
LABEL_29:
  v7 = v3 < v6;
  v10 = v3 - v6;
  if ( v7 )
  {
    v11 = ~v10;
    v7 = v11 < 31;
    v12 = v11 - 31;
    if ( v7 )
      LODWORD(a1) = ((unsigned int)a1 >> (v12 + 32)) | (HIDWORD(a1) << -v12);
    else
      LODWORD(a1) = HIDWORD(a1) >> v12;
  }
  return a1;
}

//----- (00049368) --------------------------------------------------------
int __fastcall check_and_execute(int input_param_1, int input_param_2, int condition_check_1, int condition_check_2)
{
  if ( condition_check_2 || condition_check_1 )
    return sub_49408(input_param_1);
  else
    return raise(8);
}
// 49408: using guessed type int __fastcall sub_49408(_DWORD);

//----- (000493A4) --------------------------------------------------------
int __fastcall calculate_hash_rate(double hash_rate)
{
  if ( hash_rate < 0.0 )
    return -(int)calculate_hash_value(LODWORD(hash_rate), HIDWORD(hash_rate) ^ 0x80000000);
  else
    return calculate_hash_value(LODWORD(hash_rate), HIDWORD(hash_rate));
}
// 493C8: using guessed type __int64 __fastcall sub_493C8(_DWORD, _DWORD);

//----- (000493C8) --------------------------------------------------------
unsigned int __fastcall calculate_hash_value(double input_value)
{
  return (unsigned int)(input_value - (double)(unsigned int)(input_value * 2.32830644e-10) * 4294967300.0);
}

//----- (00049408) --------------------------------------------------------
int __fastcall sub_49408(unsigned __int64 dividend, unsigned __int64 divisor, unsigned __int64 *remainder_output)
{
  bool comparison_result; // cf
  unsigned __int64 temp_remainder; // r4
  unsigned int lead_zeros_divisor; // r12
  unsigned int lead_zeros_dividend; // r1
  unsigned int bit_shift; // r12
  char shift_adjustment; // r8
  char reverse_shift; // r9
  unsigned __int64 adjusted_divisor; // r6
  unsigned __int64 half_adjusted_divisor; // r6
  unsigned int shift_counter; // r2
  int temp_carry; // off

  comparison_result = dividend >= divisor;
  LODWORD(temp_remainder) = dividend;
  if ( dividend < divisor )
    LODWORD(dividend) = 0;
  HIDWORD(temp_remainder) = HIDWORD(dividend);
  if ( !comparison_result )
    goto LABEL_16;
  lead_zeros_divisor = __clz(HIDWORD(divisor));
  if ( HIDWORD(divisor) )
  {
    lead_zeros_dividend = __clz(HIDWORD(dividend));
    if ( HIDWORD(temp_remainder) )
      goto LABEL_7;
    goto LABEL_19;
  }
  lead_zeros_dividend = __clz(HIDWORD(dividend));
  lead_zeros_divisor = __clz(divisor) + 32;
  if ( !HIDWORD(temp_remainder) )
LABEL_19:
    lead_zeros_dividend = __clz(temp_remainder) + 32;
LABEL_7:
  bit_shift = lead_zeros_divisor - lead_zeros_dividend;
  shift_adjustment = bit_shift - 32;
  reverse_shift = 32 - bit_shift;
  adjusted_divisor = divisor << bit_shift;
  if ( temp_remainder >= divisor << bit_shift )
  {
    LODWORD(dividend) = 1 << bit_shift;
    temp_remainder -= adjusted_divisor;
    HIDWORD(dividend) = (1 << shift_adjustment) | (1u >> reverse_shift);
  }
  else
  {
    dividend = 0LL;
  }
  if ( bit_shift )
  {
    half_adjusted_divisor = adjusted_divisor >> 1;
    shift_counter = bit_shift;
    do
    {
      while ( temp_remainder >= half_adjusted_divisor )
      {
        temp_remainder = 2 * (temp_remainder - half_adjusted_divisor) + 1;
        if ( !--shift_counter )
          goto LABEL_15;
      }
      temp_carry = (temp_remainder + (unsigned int)temp_remainder) >> 32;
      LODWORD(temp_remainder) = 2 * temp_remainder;
      HIDWORD(temp_remainder) += temp_carry;
      --shift_counter;
    }
    while ( shift_counter );
LABEL_15:
    comparison_result = __CFADD__((_DWORD)dividend, (_DWORD)temp_remainder);
    LODWORD(dividend) = dividend + temp_remainder;
    LODWORD(temp_remainder) = ((unsigned int)temp_remainder >> bit_shift) | (HIDWORD(temp_remainder) << reverse_shift) | (HIDWORD(temp_remainder) >> shift_adjustment);
    HIDWORD(dividend) += comparison_result + HIDWORD(temp_remainder);
    HIDWORD(temp_remainder) >>= bit_shift;
    dividend -= temp_remainder << bit_shift;
  }
LABEL_16:
  if ( remainder_output )
    *remainder_output = temp_remainder;
  return dividend;
}

//----- (00049520) --------------------------------------------------------
int __fastcall init(int a1, int a2, int a3)
{
  void **v6; // r5
  int i; // r4
  int (__fastcall *v8)(int, int, int); // t1
  int result; // r0

  init_proc();
  v6 = &off_64EE0;
  for ( i = 0; i != 1; ++i )
  {
    v8 = (int (__fastcall *)(int, int, int))*v6++;
    result = v8(a1, a2, a3);
  }
  return result;
}
// 64EE0: using guessed type void *off_64EE0;

//----- (00049560) --------------------------------------------------------
void term_proc()
{
  ;
}

// nfuncs=914 queued=580 decompiled=580 lumina nreq=0 worse=0 better=0
// ALL OK, 580 function(s) have been successfully decompiled
