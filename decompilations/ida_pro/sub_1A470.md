```c
void __fastcall configureASICClock(int chain_id, unsigned int freq, int higher_voltage_flag)
{
  float display_freq; // s0
  const char *flag_str; // r3
  unsigned int post_div1; // r11
  unsigned int post_div2; // r8
  unsigned int user_div; // r2
  unsigned int calculated_freq; // r6
  unsigned int result_freq; // r5
  _QWORD *div_params_ptr; // r4
  int div_ret; // r7
  _QWORD *base_ptr; // r4
  unsigned __int8 *byte_ptr; // r6
  int log_index; // r5
  int current_freq; // lr
  int freq_log; // r3
  int div_val; // r1
  int div_val2; // r0
  int sorted_index; // r12
  int post_div_index; // r6
  char byte_post_div1; // r3
  char byte_post_div2; // r1
  char byte_user_div; // r2
  unsigned int freq_result; // r3
  size_t nmemb; // [sp+14h] [bp-9E4h]
  int div_tmp; // [sp+18h] [bp-9E0h]
  unsigned int new_post_div1; // [sp+24h] [bp-9D4h]
  char div_params_buffer[4]; // [sp+34h] [bp-9C4h] BYREF
  __int64 div_values; // [sp+38h] [bp-9C0h] BYREF
  _QWORD div_combinations[49]; // [sp+40h] [bp-9B8h] BYREF
  char log_buffer[2096]; // [sp+1C8h] [bp-830h] BYREF

  if ( (unsigned int)globalLogLevel > 3 )
  {
    flag_str = "false";
    if ( higher_voltage_flag )
      flag_str = "true";
    snprintf(log_buffer, 0x800u, "chain = %d, freq = %g, is_higher_voltage = %s\n", chain_id, display_freq, flag_str);
    logMessage(3, log_buffer, 0);
  }
  prepareClockConfiguration(chain_id, 1, 0, freq);
  div_values = 0LL;
  memset(div_combinations, 0, sizeof(div_combinations));
  retrieveDividers((int)&div_values, div_params_buffer, 0);
  post_div1 = (unsigned __int8)div_params_buffer[0];
  BYTE6(div_values) = div_params_buffer[0];
  new_post_div1 = BYTE1(div_values);
  if ( (unsigned __int8)div_values > 7u )
  {
    nmemb = 0;
    globalLogLevel;
  }
  else
  {
    div_tmp = (unsigned __int8)div_values;
    post_div2 = (unsigned __int8)div_values;
    nmemb = 0;
    globalLogLevel;
    do
    {
      if ( new_post_div1 <= post_div2 )
      {
        user_div = new_post_div1;
        do
        {
          if ( post_div1 <= 1 )
          {
            result_freq = post_div1;
            div_params_ptr = &div_combinations[nmemb];
            div_ret = user_div * div_tmp * result_freq;
            do
            {
              *(_BYTE *)div_params_ptr = post_div2;
              *((_BYTE *)div_params_ptr + 1) = user_div;
              *((_BYTE *)div_params_ptr + 2) = result_freq;
              *((_DWORD *)div_params_ptr + 1) = div_ret;
              if ( globalLogLevel > 4 )
              {
                snprintf(log_buffer, 0x800u, "post_div1 = %d, post_div2 = %d, user_div = %d, div_ret = %d\n", div_tmp, user_div, result_freq, div_ret);
                logMessage(4, log_buffer, 0);
                globalLogLevel;
              }
              ++result_freq;
              ++div_params_ptr;
              div_ret += user_div * div_tmp;
            }
            while ( (unsigned __int8)result_freq <= 1u );
            nmemb += (unsigned __int8)(1 - post_div1) + 1;
          }
          user_div = (unsigned __int8)(user_div + 1);
        }
        while ( user_div <= post_div2 );
      }
      post_div2 = (unsigned __int8)++div_tmp;
    }
    while ( (unsigned __int8)div_tmp <= 7u );
  }
  if ( globalLogLevel > 4 )
  {
    strcpy(log_buffer, "\n");
    logMessage(4, log_buffer, 0);
    if ( (unsigned int)globalLogLevel > 4 )
    {
      strcpy(log_buffer, "sorted\n");
      logMessage(4, log_buffer, 0);
    }
  }
  qsort(div_combinations, nmemb, 8u, (__compar_fn_t)compareDivResults);
  if ( nmemb )
  {
    base_ptr = div_combinations;
    byte_ptr = (unsigned __int8 *)div_combinations;
    log_index = 0;
    do
    {
      while ( (unsigned int)globalLogLevel <= 4 )
      {
        ++log_index;
        byte_ptr += 8;
        if ( log_index == nmemb )
          goto LABEL_24;
      }
      current_freq = *((_DWORD *)byte_ptr + 1);
      freq_log = log_index;
      div_val = byte_ptr[2];
      div_val2 = byte_ptr[1];
      ++log_index;
      sorted_index = *byte_ptr;
      byte_ptr += 8;
      snprintf(log_buffer, 0x800u, "[%d] post_div1 = %d, post_div2 = %d, user_div = %d, div_ret = %d\n", freq_log, sorted_index, div_val2, div_val, current_freq);
      logMessage(4, log_buffer, 0);
    }
    while ( log_index != nmemb );
LABEL_24:
    post_div_index = 0;
    do
    {
      byte_post_div1 = *((_BYTE *)base_ptr++ + 2);
      byte_post_div2 = *((_BYTE *)base_ptr - 8);
      byte_user_div = *((_BYTE *)base_ptr - 7);
      BYTE6(div_values) = byte_post_div1;
      LOBYTE(div_values) = byte_post_div2;
      BYTE1(div_values) = byte_user_div;
      freq_result = calculateFreq(div_values, SHIDWORD(div_values));
      if ( dword_7EDCC < freq_result )
      {
        if ( (unsigned int)globalLogLevel > 3 )
        {
          snprintf(
            log_buffer,
            0x800u,
            "[%d] _POSTDIV1 = %d, _POSTDIV2 = %d, USER_DIV = %d, freq = %d\n",
            post_div_index,
            (unsigned __int8)div_values,
            BYTE1(div_values),
            BYTE6(div_values),
            freq_result);
          logMessage(3, log_buffer, 0);
        }
        applyDividers(chain_id, 1, 0, freq, div_values, SWORD2(div_values));
        usleep((__useconds_t)&unk_F4240);
      }
      ++post_div_index;
    }
    while ( post_div_index != log_index );
  }
}
```