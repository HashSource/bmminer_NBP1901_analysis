/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

int init_proc();
// void abort(void);
// int __fastcall ERR_get_error(_DWORD); weak
// int __fastcall _libc_start_main(int (__fastcall *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end);
// int _gmon_start__(void); weak
// int fclose(FILE *stream);
// void *memset(void *s, int c, size_t n);
// int __fastcall RSA_verify(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall PEM_read_bio_RSA_PUBKEY(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall SHA256_Final(_DWORD, _DWORD); weak
// size_t strlen(const char *s);
// void *memcpy(void *dest, const void *src, size_t n);
// int __fastcall fopen64(_DWORD, _DWORD); weak
// int __fastcall BIO_new_mem_buf(_DWORD, _DWORD); weak
// char *strcpy(char *dest, const char *src);
// int printf(const char *format, ...);
// int __fastcall ERR_error_string(_DWORD, _DWORD); weak
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
int __fastcall j___xstat64(int a1, int a2, int a3);
// int __fastcall _xstat64(_DWORD, _DWORD, _DWORD); weak
// int puts(const char *s);
// int __fastcall RSA_free(_DWORD); weak
// int __fastcall SHA256_Update(_DWORD, _DWORD, _DWORD); weak
// int __fastcall BIO_free(_DWORD); weak
// int __fastcall SHA256_Init(_DWORD); weak
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
void __noreturn start(void (*a1)(void), int a2, int a3, int a4, ...);
int check_gmon_start();
char *get_firmware_version_address();
__int64 get_version_info_pointer();
char *get_firmware_version_cached();
int __fastcall print_usage_instructions(const char *);
int __fastcall extract_and_write_firmware_segments(int);
int create_and_fill_file();
int __fastcall verify_signature(int, int, int, int);
int __fastcall get_first_int_value(int);
__int64 __fastcall copy_64bit_value(const void *);
unsigned int __fastcall calculate_xor(int, unsigned int);
unsigned __int64 __fastcall rotate_right(unsigned __int64, char);
unsigned __int64 __fastcall compute_hash_value(int input_a, int input_b, __int64 low_seed, __int64 high_seed);
__int64 __fastcall calculate_hash(unsigned __int8 *, unsigned int);
__int64 __fastcall calculate_hash_value(int, int);
unsigned __int64 __fastcall sub_11BE0(int data_ptr, int data_len);
_QWORD *__fastcall calculate_hash_values(_QWORD *, __int64, __int64, __int64, __int64, unsigned __int64, __int64);
_QWORD *__fastcall compute_block_hash(_QWORD *, int, unsigned __int64, __int64);
__int64 __fastcall process_data(unsigned __int8 *a1, unsigned int a2);
int __fastcall validate_firmware_update(const char *, const char *, const char *, _BYTE *, unsigned __int8, char, char);
int __fastcall main(int, char **, char **); // idb
int __fastcall init(int a1, int a2, int a3);
void nullsub_1();
int __fastcall get_file_stat(int, int);
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

void *off_24F08 = (void *)0x108F5; // weak
_UNKNOWN unk_2507C; // weak
char byte_25838; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (000106E8) --------------------------------------------------------
int init_proc()
{
  return check_gmon_start();
}

//----- (000106F4) --------------------------------------------------------
void sub_106F4()
{
  JUMPOUT(0);
}
// 10700: control flows out of bounds to 0

//----- (000107E0) --------------------------------------------------------
// attributes: thunk
int __fastcall j___xstat64(int a1, int a2, int a3)
{
  return _xstat64(a1, a2, a3);
}
// 107E4: using guessed type int __fastcall _xstat64(_DWORD, _DWORD, _DWORD);

//----- (00010838) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __noreturn start(void (*a1)(void), int a2, int a3, int a4, ...)
{
  int v4; // [sp-4h] [bp-4h]
  va_list va; // [sp+0h] [bp+0h] BYREF

  va_start(va, a4);
  _libc_start_main(main, v4, (char **)va, (void (*)(void))init, nullsub_1, a1, va);
  abort();
}
// 10842: positive sp value 4 has been found
// 10854: variable 'v4' is possibly undefined
// 13B20: using guessed type int init();

//----- (00010868) --------------------------------------------------------
int check_gmon_start()
{
  int result; // r0

  if ( &__gmon_start__ )
    return _gmon_start__();
  return result;
}
// 1072C: using guessed type int _gmon_start__(void);

//----- (0001088C) --------------------------------------------------------
char *get_firmware_version_address()
{
  return &byte_25838;
}
// 25838: using guessed type char byte_25838;

//----- (000108B0) --------------------------------------------------------
__int64 get_version_info_pointer()
{
  __int64 version_info_pointer; // r0

  LODWORD(version_info_pointer) = &byte_25838;
  HIDWORD(version_info_pointer) = 0;
  return version_info_pointer;
}
// 25838: using guessed type char byte_25838;

//----- (000108DC) --------------------------------------------------------
char *get_firmware_version_cached()
{
  char *cached_version; // r0

  if ( !byte_25838 )
  {
    cached_version = get_firmware_version_address();
    byte_25838 = 1;
  }
  return cached_version;
}
// 25838: using guessed type char byte_25838;

//----- (000108F8) --------------------------------------------------------
int __fastcall print_usage_instructions(const char *executable_name)
{
  puts("Useage:\r");
  printf("\t%s [option] [paramaters]\n\n", executable_name);
  puts("\tOption:{-f} {-s} {-p} {-n} {-x} {-q}\n");
  puts("\t\t-f [minerType] [fileName] [rootPublicKeyFile]: \n\t\t\tOnly Check If Filename was Valided.\n");
  puts(
    "\t\t-s [minerType] [fileName] [rootPublicKeyFile]: \n"
    "\t\t\tCheck If Filename Was Valided, and Splite Bmu To \"/tmp/tmpfw/\"\n");
  puts("\t\t-p [minerType] [fileName] [rootPublicKeyFile]: \n\t\t\tCheck If Filename Was Valided, and Dump BmuComments\n");
  puts("\t\t-x [minerType] [fileName] [rootPublicKeyFile]: \n\t\t\tCheck If Filename Was FullSize BMU\n");
  puts("\t\t-n [nandBinFile]: \n\t\t\tSplite SigImg To Single File To \"/tmp/tmpNand/\"\n");
  puts("\t\t-q: \n\t\t\tGenerate A 256Bytes 0xff File To \"/tmp/256BFF\"\n");
  puts("\tReturns:");
  puts("\t\t0: \n\t\t\tWell Done!\n");
  return puts("\t\tOthers: \n\t\t\tSomething Wrong!\n");
}

//----- (000109A8) --------------------------------------------------------
int __fastcall extract_and_write_firmware_segments(int firmware_path)
{
  char buffer[32768]; // [sp+Ch] [bp-8010h] BYREF
  FILE *write_stream; // [sp+800Ch] [bp-10h]
  FILE *read_stream; // [sp+8010h] [bp-Ch]
  int segment_index; // [sp+8014h] [bp-8h]

  memset(buffer, 0, sizeof(buffer));
  read_stream = (FILE *)fopen64(firmware_path, "rb");
  if ( read_stream )
  {
    for ( segment_index = 0; ; ++segment_index )
    {
      if ( segment_index > 14 )
      {
        if ( read_stream )
          fclose(read_stream);
        return 0;
      }
      fread(buffer, *((_DWORD *)&unk_2507C + 33 * segment_index), 1u, read_stream);
      write_stream = (FILE *)fopen64((char *)&unk_2507C + 132 * segment_index + 4, "wb");
      if ( !write_stream )
        break;
      fwrite(buffer, *((_DWORD *)&unk_2507C + 33 * segment_index), 1u, write_stream);
      if ( write_stream )
        fclose(write_stream);
      write_stream = 0;
    }
    printf("Try To Write To File '%s' Failed!\n", (const char *)&unk_2507C + 132 * segment_index + 4);
    if ( read_stream )
      fclose(read_stream);
    return 2;
  }
  else
  {
    puts("Load Nand Image File Failed!");
    return 1;
  }
}
// 10798: using guessed type int __fastcall fopen64(_DWORD, _DWORD);

//----- (00010B9C) --------------------------------------------------------
int create_and_fill_file()
{
  int buffer[64]; // [sp+0h] [bp-10Ch] BYREF
  FILE *file_stream; // [sp+100h] [bp-Ch]
  int index; // [sp+104h] [bp-8h]

  file_stream = (FILE *)fopen64("/tmp/256BFF", "wb");
  if ( file_stream )
  {
    memset(buffer, 0, sizeof(buffer));
    for ( index = 0; index <= 255; ++index )
      *((_BYTE *)buffer + index) = -1;
    fwrite(buffer, 256u, 1u, file_stream);
    fclose(file_stream);
    file_stream = 0;
    return 0;
  }
  else
  {
    puts("GenFile Failed!");
    return 1;
  }
}
// 10798: using guessed type int __fastcall fopen64(_DWORD, _DWORD);

//----- (00010C70) --------------------------------------------------------
int __fastcall sub_10C70(int a1, int a2, int a3, int a4)
{
  int v4; // r0
  const char *v5; // r0
  int v7; // r0
  int error; // r0
  const char *v9; // r0
  char v14[112]; // [sp+1Ch] [bp-A0h] BYREF
  char v15[32]; // [sp+8Ch] [bp-30h] BYREF
  int v16; // [sp+ACh] [bp-10h]
  int bio_RSA_PUBKEY; // [sp+B0h] [bp-Ch]
  int v18; // [sp+B4h] [bp-8h]

  v18 = BIO_new_mem_buf(a4, 1024);
  bio_RSA_PUBKEY = PEM_read_bio_RSA_PUBKEY(v18, 0, 0, 0);
  if ( bio_RSA_PUBKEY )
  {
    SHA256_Init(v14);
    SHA256_Update(v14, a1, a2);
    SHA256_Final(v15, v14);
    v7 = RSA_verify(672, v15, 32, a3, 256, bio_RSA_PUBKEY);
    v16 = v7;
    if ( bio_RSA_PUBKEY )
      v7 = RSA_free(bio_RSA_PUBKEY);
    if ( v18 )
      v7 = BIO_free(v18);
    if ( v16 == 1 )
    {
      return 0;
    }
    else
    {
      error = ERR_get_error(v7);
      v9 = (const char *)ERR_error_string(error, 0);
      printf("OpenSSL error: %s\n", v9);
      puts("Check miner.pem Failed!");
      return 13;
    }
  }
  else
  {
    v4 = ERR_get_error(0);
    v5 = (const char *)ERR_error_string(v4, 0);
    printf("OpenSSL error: %s\n", v5);
    puts("Read Root PubK Failed!");
    return 12;
  }
}
// 10714: using guessed type int __fastcall ERR_get_error(_DWORD);
// 10750: using guessed type int __fastcall RSA_verify(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10768: using guessed type int __fastcall PEM_read_bio_RSA_PUBKEY(_DWORD, _DWORD, _DWORD, _DWORD);
// 10774: using guessed type int __fastcall SHA256_Final(_DWORD, _DWORD);
// 107A4: using guessed type int __fastcall BIO_new_mem_buf(_DWORD, _DWORD);
// 107C8: using guessed type int __fastcall ERR_error_string(_DWORD, _DWORD);
// 107FC: using guessed type int __fastcall RSA_free(_DWORD);
// 10808: using guessed type int __fastcall SHA256_Update(_DWORD, _DWORD, _DWORD);
// 10814: using guessed type int __fastcall BIO_free(_DWORD);
// 10820: using guessed type int __fastcall SHA256_Init(_DWORD);

//----- (00010DE8) --------------------------------------------------------
int __fastcall update_and_hash_firmware(
        FILE *source_file,
        int file_size,
        _DWORD *hash_result,
        char firmware_type,
        char signature_flag,
        char update_flag)
{
  int hash_part2; // r1
  int hash_part3; // r2
  int hash_part4; // r3
  int hash_part6; // r1
  int hash_part7; // r2
  int hash_part8; // r3
  _BYTE file_path_buffer[128]; // [sp+14h] [bp-520h] BYREF
  int hash_result_0; // [sp+94h] [bp-4A0h] BYREF
  int hash_result_1; // [sp+98h] [bp-49Ch]
  int hash_result_2; // [sp+9Ch] [bp-498h]
  int hash_result_3; // [sp+A0h] [bp-494h]
  int hash_result_4; // [sp+A4h] [bp-490h]
  int hash_result_5; // [sp+A8h] [bp-48Ch]
  int hash_result_6; // [sp+ACh] [bp-488h]
  int hash_result_7; // [sp+B0h] [bp-484h]
  _BYTE sha256_context[16]; // [sp+B4h] [bp-480h] BYREF
  int buffer[256]; // [sp+124h] [bp-410h] BYREF
  size_t bytes_read; // [sp+524h] [bp-10h]
  FILE *file_stream; // [sp+528h] [bp-Ch]
  int total_bytes_read; // [sp+52Ch] [bp-8h]

  memset(buffer, 0, sizeof(buffer));
  SHA256_Init(sha256_context);
  total_bytes_read = 0;
  bytes_read = 0;
  file_stream = 0;
  if ( update_flag )
  {
    strcpy(file_path_buffer, "/tmp/tmpfw/");
    memset(&file_path_buffer[12], 0, 116u);
    switch ( firmware_type )
    {
      case 0:
        strcat(file_path_buffer, "BOOT.bin");
        break;
      case 1:
        strcat(file_path_buffer, "devicetree.dtb");
        break;
      case 2:
        strcat(file_path_buffer, "uImage");
        break;
      case 3:
        strcat(file_path_buffer, "minerfs.image.gz");
        break;
      case 4:
        strcat(file_path_buffer, "update.image.gz");
        break;
      case 5:
        strcat(file_path_buffer, "crl.tar.gz");
        break;
      case 6:
        strcat(file_path_buffer, "miner.btm.tar.gz");
        break;
      case 7:
        strcat(file_path_buffer, "reserve");
        break;
      case 9:
        strcat(file_path_buffer, "datafile");
        break;
      default:
        break;
    }
    if ( signature_flag )
      strcat(file_path_buffer, ".sig");
    printf("fileName:'%s', size:[%d]\r\n", file_path_buffer, file_size);
    file_stream = (FILE *)fopen64(file_path_buffer, "wb");
    if ( !file_stream )
      printf("Create File '%s' Failed!\r\n", file_path_buffer);
  }
  while ( (unsigned int)(file_size - total_bytes_read) > 1024 )
  {
    bytes_read = fread(buffer, 1u, 1024u, source_file);
    total_bytes_read += bytes_read;
    SHA256_Update(sha256_context, buffer, 1024);
    if ( update_flag && file_stream )
      fwrite(buffer, 1u, 1024u, file_stream);
  }
  bytes_read = fread(buffer, 1u, file_size - total_bytes_read, source_file);
  SHA256_Update(sha256_context, buffer, bytes_read);
  if ( update_flag && file_stream )
    fwrite(buffer, 1u, bytes_read, file_stream);
  hash_result_0 = 0;
  hash_result_1 = 0;
  hash_result_2 = 0;
  hash_result_3 = 0;
  hash_result_4 = 0;
  hash_result_5 = 0;
  hash_result_6 = 0;
  hash_result_7 = 0;
  SHA256_Final(&hash_result_0, sha256_context);
  if ( update_flag && file_stream )
  {
    fclose(file_stream);
    file_stream = 0;
  }
  hash_part2 = hash_result_1;
  hash_part3 = hash_result_2;
  hash_part4 = hash_result_3;
  *hash_result = hash_result_0;
  hash_result[1] = hash_part2;
  hash_result[2] = hash_part3;
  hash_result[3] = hash_part4;
  hash_part6 = hash_result_5;
  hash_part7 = hash_result_6;
  hash_part8 = hash_result_7;
  hash_result[4] = hash_result_4;
  hash_result[5] = hash_part6;
  hash_result[6] = hash_part7;
  hash_result[7] = hash_part8;
  return hash_part8;
}
// 10EA0: control flows out of bounds to 10EA4
// 10774: using guessed type int __fastcall SHA256_Final(_DWORD, _DWORD);
// 10798: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 10808: using guessed type int __fastcall SHA256_Update(_DWORD, _DWORD, _DWORD);
// 10820: using guessed type int __fastcall SHA256_Init(_DWORD);

//----- (00011460) --------------------------------------------------------
int __fastcall get_first_int_value(int pointer)
{
  return *(_DWORD *)pointer;
}

//----- (00011490) --------------------------------------------------------
__int64 __fastcall copy_64bit_value(const void *source)
{
  __int64 copied_value; // [sp+8h] [bp-Ch] BYREF

  memcpy(&copied_value, source, sizeof(copied_value));
  return copied_value;
}
// 11490: using guessed type _QWORD dest;

//----- (000114C8) --------------------------------------------------------
unsigned int __fastcall calculate_xor(int base_value, unsigned int value_to_shift)
{
  return (value_to_shift >> 15) ^ base_value;
}

//----- (00011514) --------------------------------------------------------
unsigned __int64 __fastcall rotate_right(unsigned __int64 value, char shift_amount)
{
  return (value >> shift_amount) | (value << (-shift_amount & 0x3F));
}

//----- (00011598) --------------------------------------------------------
unsigned __int64 __fastcall compute_hash_value(int input_a, int input_b, __int64 low_seed, __int64 high_seed)
{
  int intermediate_sum; // r1
  unsigned __int64 final_hash; // r2

  intermediate_sum = (input_a ^ low_seed) * HIDWORD(high_seed) + (input_b ^ HIDWORD(low_seed)) * high_seed;
  final_hash = (unsigned int)high_seed * (unsigned __int64)(input_a ^ (unsigned int)low_seed);
  HIDWORD(final_hash) += intermediate_sum;
  return high_seed
       * (((low_seed ^ final_hash ^ (HIDWORD(final_hash) >> 15)) * high_seed) ^ ((unsigned int)(((low_seed ^ final_hash ^ (HIDWORD(final_hash) >> 15))
                                                                                               * high_seed) >> 32) >> 15));
}

//----- (000116C8) --------------------------------------------------------
__int64 __fastcall calculate_hash(unsigned __int8 *data, unsigned int length)
{
  unsigned __int64 temp_val1; // r0
  __int64 result_hash; // r2
  int temp_val2; // r0
  __int64 intermediate_hash_1; // r0
  unsigned int intermediate_hash_2; // r0
  int v7; // r1
  __int64 v9; // [sp+28h] [bp-74h]
  unsigned __int64 calculation_result_3; // [sp+40h] [bp-5Ch]
  unsigned __int64 calculation_result_4; // [sp+48h] [bp-54h]
  __int64 calculation_base; // [sp+50h] [bp-4Ch]
  __int64 adjusted_length; // [sp+58h] [bp-44h]
  unsigned int v16; // [sp+74h] [bp-28h]

  if ( length <= 7 )
  {
    if ( length <= 3 )
    {
      if ( length )
      {
        v16 = length + 4 * data[length - 1];
        intermediate_hash_1 = -7286425919675154353LL * (*data + (data[length >> 1] << 8));
        intermediate_hash_2 = calculate_xor(
                                intermediate_hash_1 ^ (-1748291289 * v16),
                                HIDWORD(intermediate_hash_1) ^ (-1012545444 * v16
                                                              + ((2546676007u * (unsigned __int64)v16) >> 32)));
        result_hash = 797982799LL * intermediate_hash_2;
        HIDWORD(result_hash) += 797982799 * v7 - 1696503237 * intermediate_hash_2;
      }
      else
      {
        return -7286425919675154353LL;
      }
    }
    else
    {
      v9 = length + 8LL * (unsigned int)get_first_int_value((int)data);
      temp_val2 = get_first_int_value((int)&data[length - 4]);
      return compute_hash_value(v9, SHIDWORD(v9), (unsigned int)temp_val2, 2 * length - 7286425919675154353LL);
    }
  }
  else
  {
    adjusted_length = 2 * length - 7286425919675154353LL;
    calculation_base = copy_64bit_value(data) - 7286425919675154353LL;
    calculation_result_4 = copy_64bit_value(&data[length - 8]);
    calculation_result_3 = calculation_base + adjusted_length * rotate_right(calculation_result_4, 37);
    temp_val1 = rotate_right(calculation_base, 25);
    return compute_hash_value(
             calculation_result_3,
             SHIDWORD(calculation_result_3),
             (temp_val1 + calculation_result_4) * adjusted_length,
             adjusted_length);
  }
  return result_hash;
}
// 119B8: variable 'v7' is possibly undefined

//----- (00011A00) --------------------------------------------------------
__int64 __fastcall calculate_hash_value(int data_offset, int data_length)
{
  __int64 first_chunk_value; // r0
  __int64 first_adjusted_value; // r2
  __int64 second_chunk_value; // r0
  __int64 second_adjusted_value; // r2
  unsigned __int64 first_calc_result; // r0
  __int64 v8; // [sp+8h] [bp-6Ch]
  unsigned __int64 combined_values_sum; // [sp+18h] [bp-5Ch]
  __int64 second_chunk_hash; // [sp+30h] [bp-44h]
  __int64 last_chunk_hash; // [sp+38h] [bp-3Ch]
  __int64 first_chunk_hash; // [sp+40h] [bp-34h]
  __int64 adjusted_first_hash; // [sp+48h] [bp-2Ch]
  __int64 hash_base_value; // [sp+50h] [bp-24h]

  hash_base_value = (unsigned int)(2 * data_length) - 7286425919675154353LL;
  first_chunk_value = copy_64bit_value((const void *)data_offset);
  first_adjusted_value = 3197694579LL * (unsigned int)first_chunk_value;
  HIDWORD(first_adjusted_value) += -1097272717 * HIDWORD(first_chunk_value) - 1265453457 * first_chunk_value;
  adjusted_first_hash = first_adjusted_value;
  first_chunk_hash = copy_64bit_value((const void *)(data_offset + 8));
  last_chunk_hash = copy_64bit_value((const void *)(data_offset + data_length - 8)) * hash_base_value;
  second_chunk_value = copy_64bit_value((const void *)(data_offset + data_length - 16));
  second_adjusted_value = 797982799LL * (unsigned int)second_chunk_value;
  HIDWORD(second_adjusted_value) += 797982799 * HIDWORD(second_chunk_value) - 1696503237 * second_chunk_value;
  second_chunk_hash = second_adjusted_value;
  first_calc_result = rotate_right(adjusted_first_hash + first_chunk_hash, 43);
  combined_values_sum = first_calc_result + rotate_right(last_chunk_hash, 30) + second_chunk_hash;
  v8 = rotate_right(first_chunk_hash - 7286425919675154353LL, 18) + adjusted_first_hash + last_chunk_hash;
  return compute_hash_value(combined_values_sum, SHIDWORD(combined_values_sum), v8, hash_base_value);
}

//----- (00011BE0) --------------------------------------------------------
unsigned __int64 __fastcall sub_11BE0(int data_ptr, int data_len)
{
  __int64 hash_seg_1; // r0
  __int64 hash_mix_seg_1; // r2
  __int64 hash_seg_2; // r0
  __int64 hash_mix_seg_2; // r2
  unsigned __int64 mix_sum_seg_1; // r0
  unsigned __int64 mix_sum_seg_2; // r0
  __int64 final_mix_seg_2; // [sp+10h] [bp-D4h]
  unsigned __int64 mix_sum_res; // [sp+28h] [bp-BCh]
  __int64 final_hash_seg; // [sp+50h] [bp-94h]
  __int64 hash_val_4; // [sp+70h] [bp-74h]
  __int64 hash_val_3; // [sp+78h] [bp-6Ch]
  __int64 hash_seg_4; // [sp+80h] [bp-64h]
  __int64 hash_seg_3; // [sp+88h] [bp-5Ch]
  __int64 hash_val_2; // [sp+90h] [bp-54h]
  unsigned __int64 hash_val_1; // [sp+98h] [bp-4Ch]
  __int64 hash_seg_2_mix; // [sp+A0h] [bp-44h]
  __int64 hash_seg_5; // [sp+A8h] [bp-3Ch]
  __int64 hash_seg_6; // [sp+B0h] [bp-34h]
  __int64 hash_mix_seg_3; // [sp+B8h] [bp-2Ch]
  __int64 hash_multiplier; // [sp+C0h] [bp-24h]

  hash_multiplier = (unsigned int)(2 * data_len) - 7286425919675154353LL;
  hash_seg_1 = copy_64bit_value((const void *)data_ptr);
  hash_mix_seg_1 = 797982799LL * (unsigned int)hash_seg_1;
  HIDWORD(hash_mix_seg_1) += 797982799 * HIDWORD(hash_seg_1) - 1696503237 * hash_seg_1;
  hash_mix_seg_3 = hash_mix_seg_1;
  hash_seg_6 = copy_64bit_value((const void *)(data_ptr + 8));
  hash_seg_5 = copy_64bit_value((const void *)(data_ptr + data_len - 8)) * hash_multiplier;
  hash_seg_2 = copy_64bit_value((const void *)(data_ptr + data_len - 16));
  hash_mix_seg_2 = 797982799LL * (unsigned int)hash_seg_2;
  HIDWORD(hash_mix_seg_2) += 797982799 * HIDWORD(hash_seg_2) - 1696503237 * hash_seg_2;
  hash_seg_2_mix = hash_mix_seg_2;
  mix_sum_seg_1 = rotate_right(hash_mix_seg_3 + hash_seg_6, 43);
  hash_val_1 = hash_seg_2_mix + mix_sum_seg_1 + rotate_right(hash_seg_5, 30);
  final_hash_seg = rotate_right(hash_seg_6 - 7286425919675154353LL, 18) + hash_mix_seg_3 + hash_seg_5;
  hash_val_2 = compute_hash_value(hash_val_1, SHIDWORD(hash_val_1), final_hash_seg, hash_multiplier);
  hash_seg_3 = copy_64bit_value((const void *)(data_ptr + 16)) * hash_multiplier;
  hash_seg_4 = copy_64bit_value((const void *)(data_ptr + 24));
  hash_val_3 = (copy_64bit_value((const void *)(data_ptr + data_len - 32)) + hash_val_1) * hash_multiplier;
  hash_val_4 = (copy_64bit_value((const void *)(data_ptr + data_len - 24)) + hash_val_2) * hash_multiplier;
  mix_sum_seg_2 = rotate_right(hash_seg_3 + hash_seg_4, 43);
  mix_sum_res = mix_sum_seg_2 + rotate_right(hash_val_3, 30) + hash_val_4;
  final_mix_seg_2 = rotate_right(hash_seg_4 + hash_mix_seg_3, 18) + hash_seg_3 + hash_val_3;
  return compute_hash_value(mix_sum_res, SHIDWORD(mix_sum_res), final_mix_seg_2, hash_multiplier);
}

//----- (00011FBC) --------------------------------------------------------
_QWORD *__fastcall calculate_hash_values(
        _QWORD *result_array,
        __int64 input1,
        __int64 input2,
        __int64 input3,
        __int64 input4,
        unsigned __int64 input5,
        __int64 input6)
{
  unsigned __int64 final_value; // [sp+40h] [bp-2Ch]
  unsigned __int64 intermediate_value1; // [sp+48h] [bp-24h]
  unsigned __int64 sum_input1_input5; // [sp+88h] [bp+1Ch]
  __int64 sum_all_inputs_except_input6; // [sp+88h] [bp+1Ch]
  unsigned __int64 rotated_sum; // [sp+90h] [bp+24h]

  sum_input1_input5 = input5 + input1;
  rotated_sum = rotate_right(input6 + sum_input1_input5 + input4, 21);
  intermediate_value1 = sum_input1_input5;
  sum_all_inputs_except_input6 = sum_input1_input5 + input2 + input3;
  final_value = rotated_sum + rotate_right(sum_all_inputs_except_input6, 44) + intermediate_value1;
  *result_array = sum_all_inputs_except_input6 + input4;
  result_array[1] = final_value;
  return result_array;
}
// 11FBC: using guessed type unsigned __int64 arg_18;
// 11FBC: using guessed type _QWORD arg_10;
// 11FBC: using guessed type _QWORD arg_0;
// 11FBC: using guessed type _QWORD arg_8;

//----- (000120DC) --------------------------------------------------------
_QWORD *__fastcall compute_block_hash(_QWORD *result, int data_block, unsigned __int64 timestamp, __int64 nonce)
{
  __int64 temp1; // r8
  __int64 temp2; // r4
  __int64 temp3; // r6
  __int64 temp4; // r0

  temp1 = copy_64bit_value((const void *)data_block);
  temp2 = copy_64bit_value((const void *)(data_block + 8));
  temp3 = copy_64bit_value((const void *)(data_block + 16));
  temp4 = copy_64bit_value((const void *)(data_block + 24));
  calculate_hash_values(result, temp1, temp2, temp3, temp4, timestamp, nonce);
  return result;
}

//----- (00012180) --------------------------------------------------------
__int64 __fastcall process_data(unsigned __int8 *input_param, unsigned int data_size)
{
  __int64 temp_result_1; // r2
  unsigned int temp_result_2; // r0
  int temp_result_3; // r1
  __int64 temp_result_4; // r2
  unsigned __int64 temp_result_5; // r0
  __int64 temp_result_6; // r2
  unsigned __int64 temp_result_7; // r0
  __int64 temp_result_8; // r2
  __int64 temp_result_9; // r4
  unsigned __int64 temp_accumulator_1; // r0
  __int64 temp_result_10; // r2
  unsigned __int64 temp_result_11; // r4
  __int64 temp_result_12; // r0
  unsigned __int8 *temp_result_13; // r4
  __int64 temp_result_14; // r0
  __int64 temp_result_15; // r4
  unsigned int temp_result_16; // r0
  int temp_result_17; // r1
  __int64 inner_loop_end; // r2
  __int64 temp_result_18; // r0
  __int64 temp_result_19; // [sp+18h] [bp-1C4h]
  __int64 temp_result_20; // [sp+50h] [bp-18Ch]
  __int64 final_result_2; // [sp+68h] [bp-174h]
  __int64 v27; // [sp+70h] [bp-16Ch]
  __int64 unused_var_1; // [sp+80h] [bp-15Ch]
  __int64 unused_var_2; // [sp+88h] [bp-154h]
  unsigned __int64 unused_var_3; // [sp+98h] [bp-144h]
  __int64 unused_var_4; // [sp+B0h] [bp-12Ch]
  unsigned __int64 temp_value_1; // [sp+C0h] [bp-11Ch]
  __int64 unused_var_5; // [sp+C8h] [bp-114h]
  unsigned __int64 unused_var_6; // [sp+D0h] [bp-10Ch]
  __int64 unused_var_7; // [sp+D8h] [bp-104h]
  unsigned __int64 unused_var_8; // [sp+118h] [bp-C4h]
  unsigned __int64 temp_xor_value_1; // [sp+130h] [bp-ACh]
  __int64 unused_var_9; // [sp+138h] [bp-A4h]
  unsigned __int64 unused_var_10; // [sp+140h] [bp-9Ch]
  __int64 unused_var_11; // [sp+148h] [bp-94h]
  __int64 unused_var_12; // [sp+158h] [bp-84h] BYREF
  __int64 temp_xor_result; // [sp+160h] [bp-7Ch]
  unsigned int temp_sum_result_1; // [sp+168h] [bp-74h]
  unsigned __int8 *temp_sum_result_2; // [sp+16Ch] [bp-70h]
  __int64 final_sum_result_1; // [sp+170h] [bp-6Ch] BYREF
  __int64 temp_hash_1; // [sp+178h] [bp-64h]
  __int64 temp_sum_result_3; // [sp+180h] [bp-5Ch] BYREF
  __int64 temp_multiplier; // [sp+188h] [bp-54h]
  __int64 temp_sum_start_1; // [sp+190h] [bp-4Ch]
  unsigned __int8 *temp_sum_start_2; // [sp+198h] [bp-44h]
  unsigned __int8 *temp_sum_initial; // [sp+19Ch] [bp-40h]
  __int64 temp_sum_accumulator_1; // [sp+1A0h] [bp-3Ch]
  unsigned __int64 temp_sum_accumulator_2; // [sp+1A8h] [bp-34h]
  unsigned __int64 output_hash; // [sp+1B0h] [bp-2Ch]
  __int64 hash_high_part; // [sp+1B8h] [bp-24h]

  temp_sum_result_2 = input_param;
  temp_sum_result_1 = data_size;
  temp_sum_accumulator_1 = 81LL;
  if ( data_size <= 16 )
    return calculate_hash(temp_sum_result_2, temp_sum_result_1);
  if ( temp_sum_result_1 <= 32 )
    return calculate_hash_value((int)temp_sum_result_2, temp_sum_result_1);
  if ( temp_sum_result_1 <= 64 )
    return sub_11BE0((int)temp_sum_result_2, temp_sum_result_1);
  temp_result_1 = 3197694579LL * (unsigned int)temp_sum_accumulator_1;
  HIDWORD(temp_result_1) += -1265453457 * temp_sum_accumulator_1 - 1097272717 * HIDWORD(temp_sum_accumulator_1);
  output_hash = temp_result_1 + 113;
  temp_result_2 = calculate_xor(
                    797982799 * (temp_result_1 + 113) + 113,
                    (unsigned __int64)(-7286425919675154353LL * (temp_result_1 + 113) + 113) >> 32);
  temp_result_4 = 797982799LL * temp_result_2;
  HIDWORD(temp_result_4) += 797982799 * temp_result_3 - 1696503237 * temp_result_2;
  temp_sum_accumulator_2 = temp_result_4;
  temp_sum_result_3 = 0LL;
  temp_multiplier = 0LL;
  final_sum_result_1 = 0LL;
  temp_hash_1 = 0LL;
  hash_high_part = -7286425919675154353LL * temp_sum_accumulator_1 + copy_64bit_value(temp_sum_result_2);
  temp_sum_initial = &temp_sum_result_2[(temp_sum_result_1 - 1) & 0xFFFFFFC0];
  temp_sum_start_2 = &temp_sum_initial[(((_BYTE)temp_sum_result_1 - 1) & 0x3F) - 63];
  do
  {
    unused_var_11 = hash_high_part + output_hash + temp_sum_result_3;
    unused_var_10 = unused_var_11 + copy_64bit_value(temp_sum_result_2 + 8);
    temp_result_5 = rotate_right(unused_var_10, 37);
    temp_result_6 = 3197694579LL * (unsigned int)temp_result_5;
    HIDWORD(temp_result_6) += -1097272717 * HIDWORD(temp_result_5) - 1265453457 * temp_result_5;
    hash_high_part = temp_result_6;
    unused_var_9 = temp_multiplier + output_hash;
    temp_xor_value_1 = unused_var_9 + copy_64bit_value(temp_sum_result_2 + 48);
    temp_result_7 = rotate_right(temp_xor_value_1, 42);
    temp_result_8 = 3197694579LL * (unsigned int)temp_result_7;
    HIDWORD(temp_result_8) += -1097272717 * HIDWORD(temp_result_7) - 1265453457 * temp_result_7;
    output_hash = temp_result_8;
    hash_high_part ^= temp_hash_1;
    temp_result_9 = temp_sum_result_3;
    v27 = temp_result_9 + copy_64bit_value(temp_sum_result_2 + 40);
    output_hash += v27;
    temp_accumulator_1 = rotate_right(final_sum_result_1 + temp_sum_accumulator_2, 33);
    temp_result_10 = 3197694579LL * (unsigned int)temp_accumulator_1;
    HIDWORD(temp_result_10) += -1097272717 * HIDWORD(temp_accumulator_1) - 1265453457 * temp_accumulator_1;
    temp_sum_accumulator_2 = temp_result_10;
    temp_result_11 = 3197694579LL * (unsigned int)temp_multiplier;
    HIDWORD(temp_result_11) += -1097272717 * HIDWORD(temp_multiplier) - 1265453457 * temp_multiplier;
    compute_block_hash(&temp_sum_result_3, (int)temp_sum_result_2, temp_result_11, final_sum_result_1 + hash_high_part);
    unused_var_8 = temp_hash_1 + temp_sum_accumulator_2;
    temp_result_12 = copy_64bit_value(temp_sum_result_2 + 16);
    compute_block_hash(&final_sum_result_1, (int)(temp_sum_result_2 + 32), unused_var_8, temp_result_12 + output_hash);
    temp_result_20 = temp_sum_accumulator_2 ^ hash_high_part;
    hash_high_part = temp_sum_accumulator_2;
    temp_sum_accumulator_2 ^= temp_result_20;
    temp_sum_result_2 += 64;
  }
  while ( temp_sum_result_2 != temp_sum_initial );
  temp_sum_start_1 = ((2 * (int)temp_sum_accumulator_2) & 0x1FELL) - 5435081209227447693LL;
  temp_sum_result_2 = temp_sum_start_2;
  final_sum_result_1 += (temp_sum_result_1 - 1) & 0x3FLL;
  temp_sum_result_3 += final_sum_result_1;
  final_sum_result_1 += temp_sum_result_3;
  unused_var_7 = hash_high_part + output_hash + temp_sum_result_3;
  unused_var_6 = unused_var_7 + copy_64bit_value(temp_sum_start_2 + 8);
  hash_high_part = rotate_right(unused_var_6, 37) * temp_sum_start_1;
  unused_var_5 = temp_multiplier + output_hash;
  temp_value_1 = unused_var_5 + copy_64bit_value(temp_sum_result_2 + 48);
  output_hash = rotate_right(temp_value_1, 42) * temp_sum_start_1;
  hash_high_part ^= 9 * temp_hash_1;
  unused_var_4 = 9 * temp_sum_result_3;
  final_result_2 = unused_var_4 + copy_64bit_value(temp_sum_result_2 + 40);
  output_hash += final_result_2;
  temp_sum_accumulator_2 = rotate_right(final_sum_result_1 + temp_sum_accumulator_2, 33) * temp_sum_start_1;
  compute_block_hash(
    &unused_var_12,
    (int)temp_sum_result_2,
    temp_sum_start_1 * temp_multiplier,
    final_sum_result_1 + hash_high_part);
  temp_sum_result_3 = unused_var_12;
  temp_multiplier = temp_xor_result;
  temp_result_13 = temp_sum_result_2 + 32;
  unused_var_3 = temp_hash_1 + temp_sum_accumulator_2;
  temp_result_14 = copy_64bit_value(temp_sum_result_2 + 16);
  compute_block_hash(&unused_var_12, (int)temp_result_13, unused_var_3, temp_result_14 + output_hash);
  final_sum_result_1 = unused_var_12;
  temp_hash_1 = temp_xor_result;
  temp_result_19 = temp_sum_accumulator_2 ^ hash_high_part;
  hash_high_part = temp_sum_accumulator_2;
  temp_sum_accumulator_2 ^= temp_result_19;
  temp_result_15 = compute_hash_value(temp_sum_result_3, SHIDWORD(temp_sum_result_3), unused_var_12, temp_sum_start_1);
  temp_result_16 = calculate_xor(output_hash, HIDWORD(output_hash));
  inner_loop_end = 2546676007LL * temp_result_16;
  HIDWORD(inner_loop_end) += -1748291289 * temp_result_17 - 1012545444 * temp_result_16;
  LODWORD(unused_var_2) = temp_result_15 - 1748291289 * temp_result_16;
  HIDWORD(unused_var_2) = (unsigned __int64)(temp_result_15 + inner_loop_end) >> 32;
  unused_var_1 = unused_var_2 + temp_sum_accumulator_2;
  temp_result_18 = compute_hash_value(temp_multiplier, SHIDWORD(temp_multiplier), temp_hash_1, temp_sum_start_1);
  return compute_hash_value(unused_var_1, SHIDWORD(unused_var_1), temp_result_18 + hash_high_part, temp_sum_start_1);
}
// 12294: variable 'temp_result_3' is possibly undefined
// 12B88: variable 'temp_result_17' is possibly undefined

//----- (00012C40) --------------------------------------------------------
int __fastcall validate_firmware_update(
        const char *firmware_path,
        const char *miner_type,
        const char *public_key_path,
        _BYTE *buffer,
        unsigned __int8 flag_dump_pem,
        char verbose,
        char is_full_package)
{
  unsigned int miner_type_length; // r0
  int openssl_error_code; // r0
  const char *openssl_error_msg; // r0
  int openssl_error_code_with_msg; // r0
  int openssl_error_code_with_err_msg; // r0
  const char *openssl_error_string; // r0
  int package_comment_buffer[65]; // [sp+1Ch] [bp-BF0h] BYREF
  _BYTE sha256_ctx_1[12]; // [sp+120h] [bp-AECh] BYREF
  int sha256_result_1[8]; // [sp+190h] [bp-A7Ch] BYREF
  int firmware_signature_buffer[64]; // [sp+1B0h] [bp-A5Ch] BYREF
  _BYTE sha256_ctx_2[12]; // [sp+2B0h] [bp-95Ch] BYREF
  _OWORD sha256_result_2[66]; // [sp+320h] [bp-8ECh] BYREF
  int public_key_buffer[256]; // [sp+740h] [bp-4CCh] BYREF
  __int64 miner_type_hash_in_file; // [sp+B40h] [bp-CCh] BYREF
  char file_stats_buffer[48]; // [sp+B48h] [bp-C4h] BYREF
  int file_size; // [sp+B78h] [bp-94h]
  unsigned int file_part_size; // [sp+BB4h] [bp-58h]
  int firmware_part_size; // [sp+BB8h] [bp-54h]
  int verify_result; // [sp+BBCh] [bp-50h]
  int rsa_pubkey_bio; // [sp+BC0h] [bp-4Ch]
  int bio_mem_buffer; // [sp+BC4h] [bp-48h]
  FILE *pem_file; // [sp+BC8h] [bp-44h]
  int pem_payload_check_result; // [sp+BCCh] [bp-40h]
  size_t pem_length; // [sp+BD0h] [bp-3Ch]
  FILE *public_key_file; // [sp+BD4h] [bp-38h]
  unsigned int expected_file_size; // [sp+BD8h] [bp-34h]
  unsigned __int16 content_flags; // [sp+BDEh] [bp-2Eh]
  __int64 miner_type_hash_calculated; // [sp+BE0h] [bp-2Ch]
  FILE *firmware_file; // [sp+BE8h] [bp-24h]
  int actual_file_size; // [sp+BECh] [bp-20h]
  int iterator_m; // [sp+BF0h] [bp-1Ch]
  int iterator_k; // [sp+BF4h] [bp-18h]
  int iterator_j; // [sp+BF8h] [bp-14h]
  int calculated_file_size; // [sp+BFCh] [bp-10h]
  int content_flags_bit_iterator; // [sp+C00h] [bp-Ch]
  unsigned __int8 content_flags_set_bit_count; // [sp+C07h] [bp-5h]

  get_file_stat(firmware_path, file_stats_buffer);
  actual_file_size = file_size;
  if ( file_size >= 2048 )
  {
    firmware_file = (FILE *)fopen64(firmware_path, "rb");
    if ( firmware_file )
    {
      fread(buffer, 2048u, 1u, firmware_file);
      if ( *buffer == 38 )
      {
        printf("miner_type %s\n", miner_type);
        miner_type_length = strlen(miner_type);
        miner_type_hash_calculated = process_data((int)miner_type, miner_type_length);
        memcpy(&miner_type_hash_in_file, buffer + 2, sizeof(miner_type_hash_in_file));
        printf("miner_type_hash %16llx, bmu_hash %16llx\n", miner_type_hash_calculated, miner_type_hash_in_file);
        if ( miner_type_hash_calculated == miner_type_hash_in_file )
        {
          content_flags_set_bit_count = 0;
          content_flags = _byteswap_ushort(*(_WORD *)(buffer + 11));
          if ( !is_full_package || (printf("content:%x\n", content_flags), (content_flags & 0xFE00) == 65024) )
          {
            for ( content_flags_bit_iterator = 0; content_flags_bit_iterator <= 15; ++content_flags_bit_iterator )
            {
              if ( (((int)content_flags >> content_flags_bit_iterator) & 1) != 0 )
                ++content_flags_set_bit_count;
            }
            if ( content_flags_set_bit_count == (unsigned __int8)buffer[1304] )
            {
              calculated_file_size = ((unsigned __int8)buffer[1304] + 9) << 8;
              expected_file_size = _byteswap_ulong(*(_DWORD *)(buffer + 1305));
              for ( iterator_j = 0; iterator_j < content_flags_set_bit_count; ++iterator_j )
              {
                file_part_size = _byteswap_ulong(*(_DWORD *)&buffer[5 * iterator_j + 1310]);
                calculated_file_size += file_part_size;
                printf("file[%d] size:[%d]\n", iterator_j, file_part_size);
              }
              if ( calculated_file_size == actual_file_size )
              {
                public_key_file = (FILE *)fopen64(public_key_path, "r");
                if ( public_key_file )
                {
                  memset(public_key_buffer, 0, sizeof(public_key_buffer));
                  fread(public_key_buffer, 1024u, 1u, public_key_file);
                  fclose(public_key_file);
                  public_key_file = 0;
                  pem_length = ((unsigned __int8)buffer[22] << 8) | (unsigned __int8)buffer[23];
                  pem_payload_check_result = verify_signature(buffer + 24, pem_length, buffer + 1048, public_key_buffer);
                  if ( pem_payload_check_result )
                  {
                    printf("Check pem payload failed! ret:[%d]\n", pem_payload_check_result);
                    if ( firmware_file )
                      fclose(firmware_file);
                    return pem_payload_check_result;
                  }
                  else
                  {
                    if ( flag_dump_pem )
                    {
                      pem_file = (FILE *)fopen64("/tmp/tmpfw/miner.pem", "w");
                      if ( !pem_file )
                      {
                        puts("Dump Miner.pem Failed!\r");
                        return 15;
                      }
                      fwrite(buffer + 24, 1u, pem_length, pem_file);
                      fclose(pem_file);
                      pem_file = (FILE *)fopen64("/tmp/tmpfw/miner.pem.sig", "w");
                      if ( !pem_file )
                      {
                        puts("Dump Miner.pem.sig Failed!\r");
                        return 16;
                      }
                      fwrite(buffer + 1048, 1u, 256u, pem_file);
                      fclose(pem_file);
                    }
                    memset(sha256_result_2, 0, sizeof(sha256_result_2));
                    SHA256_Init(sha256_ctx_2);
                    SHA256_Update(sha256_ctx_2, buffer, 2048);
                    SHA256_Final(sha256_result_2, sha256_ctx_2);
                    for ( iterator_k = 0; iterator_k < content_flags_set_bit_count; ++iterator_k )
                    {
                      firmware_part_size = _byteswap_ulong(*(_DWORD *)&buffer[5 * iterator_k + 1310]);
                      update_and_hash_firmware(
                        firmware_file,
                        firmware_part_size,
                        &sha256_result_2[2 * iterator_k + 2],
                        buffer[5 * iterator_k + 1309],
                        0,
                        flag_dump_pem);
                    }
                    for ( iterator_m = 0; iterator_m < content_flags_set_bit_count; ++iterator_m )
                      update_and_hash_firmware(
                        firmware_file,
                        256,
                        &sha256_result_2[2 * content_flags_set_bit_count + 2 + 2 * iterator_m],
                        buffer[5 * iterator_m + 1309],
                        1,
                        flag_dump_pem);
                    memset(firmware_signature_buffer, 0, sizeof(firmware_signature_buffer));
                    fseek(firmware_file, -256, 2);
                    fread(firmware_signature_buffer, 256u, 1u, firmware_file);
                    memset(sha256_result_1, 0, sizeof(sha256_result_1));
                    SHA256_Init(sha256_ctx_1);
                    SHA256_Update(sha256_ctx_1, sha256_result_2, (content_flags_set_bit_count << 6) + 32);
                    SHA256_Final(sha256_result_1, sha256_ctx_1);
                    bio_mem_buffer = 0;
                    rsa_pubkey_bio = 0;
                    bio_mem_buffer = BIO_new_mem_buf(buffer + 24, 1024);
                    rsa_pubkey_bio = PEM_read_bio_RSA_PUBKEY(bio_mem_buffer, 0, 0, 0);
                    if ( rsa_pubkey_bio )
                    {
                      verify_result = RSA_verify(
                                        672,
                                        sha256_result_1,
                                        32,
                                        firmware_signature_buffer,
                                        256,
                                        rsa_pubkey_bio);
                      if ( rsa_pubkey_bio )
                        RSA_free(rsa_pubkey_bio);
                      if ( bio_mem_buffer )
                        BIO_free(bio_mem_buffer);
                      if ( verify_result == 1 )
                      {
                        if ( firmware_file )
                          fclose(firmware_file);
                        firmware_file = 0;
                        puts("All Done!\r");
                        if ( verbose )
                        {
                          puts("This Comment Of This Package:");
                          memset(package_comment_buffer, 0, 257);
                          memcpy(package_comment_buffer, buffer + 1360, 256u);
                          puts((const char *)package_comment_buffer);
                        }
                        return 0;
                      }
                      else
                      {
                        openssl_error_code_with_msg = puts("Check File Sig failed!\r");
                        openssl_error_code_with_err_msg = ERR_get_error(openssl_error_code_with_msg);
                        openssl_error_string = (const char *)ERR_error_string(openssl_error_code_with_err_msg, 0);
                        printf("OpenSSL error: %s\n", openssl_error_string);
                        return 18;
                      }
                    }
                    else
                    {
                      openssl_error_code = ERR_get_error(0);
                      openssl_error_msg = (const char *)ERR_error_string(openssl_error_code, 0);
                      printf("OpenSSL error: %s\n", openssl_error_msg);
                      puts("Load Pem Failed!");
                      return 17;
                    }
                  }
                }
                else
                {
                  printf("Cannot Open Root PublicKey '%s'!\n", public_key_path);
                  if ( firmware_file )
                    fclose(firmware_file);
                  return 11;
                }
              }
              else
              {
                printf(
                  "Check FileSize Failed, FileSize Should Be [%d]Bytes, But It Was [%d] Bytes, And Total Says[%d]\n",
                  expected_file_size,
                  actual_file_size,
                  calculated_file_size);
                if ( firmware_file )
                  fclose(firmware_file);
                return 10;
              }
            }
            else
            {
              printf("Content Doesn't Match![%d][%d]\n", (unsigned __int8)buffer[1304], content_flags_set_bit_count);
              if ( firmware_file )
                fclose(firmware_file);
              return 9;
            }
          }
          else
          {
            puts("This Package Was Not Full Package!");
            return 20;
          }
        }
        else
        {
          puts("input miner_type and bmu miner type donot match!");
          if ( firmware_file )
            fclose(firmware_file);
          return 30;
        }
      }
      else
      {
        printf("'%s' Not A Btmu File!\n", firmware_path);
        if ( firmware_file )
          fclose(firmware_file);
        return 8;
      }
    }
    else
    {
      printf("Read File '%s' Failed!\n", firmware_path);
      return 7;
    }
  }
  else
  {
    printf("File '%s' Not Enough %d, Something Wrong!\n", firmware_path, 2048);
    return 6;
  }
}
// 10714: using guessed type int __fastcall ERR_get_error(_DWORD);
// 10750: using guessed type int __fastcall RSA_verify(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10768: using guessed type int __fastcall PEM_read_bio_RSA_PUBKEY(_DWORD, _DWORD, _DWORD, _DWORD);
// 10774: using guessed type int __fastcall SHA256_Final(_DWORD, _DWORD);
// 10798: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 107A4: using guessed type int __fastcall BIO_new_mem_buf(_DWORD, _DWORD);
// 107C8: using guessed type int __fastcall ERR_error_string(_DWORD, _DWORD);
// 107FC: using guessed type int __fastcall RSA_free(_DWORD);
// 10808: using guessed type int __fastcall SHA256_Update(_DWORD, _DWORD, _DWORD);
// 10814: using guessed type int __fastcall BIO_free(_DWORD);
// 10820: using guessed type int __fastcall SHA256_Init(_DWORD);
// 10C70: using guessed type int __fastcall sub_10C70(_DWORD, _DWORD, _DWORD, _DWORD);
// 13B60: using guessed type int __fastcall sub_13B60(_DWORD, _DWORD);
// 12C40: using guessed type char var_C4[48];

//----- (0001373C) --------------------------------------------------------
int __fastcall main(int a1, char **a2, char **a3)
{
  char v7[253]; // [sp+20h] [bp-B0Ch] BYREF
  char v8[2048]; // [sp+120h] [bp-A0Ch] BYREF
  char v9[4]; // [sp+920h] [bp-20Ch] BYREF
  char v10[124]; // [sp+924h] [bp-208h] BYREF
  char v11[4]; // [sp+9A0h] [bp-18Ch] BYREF
  char v12[124]; // [sp+9A4h] [bp-188h] BYREF
  char dest[4]; // [sp+A20h] [bp-10Ch] BYREF
  char s[252]; // [sp+A24h] [bp-108h] BYREF
  int v15; // [sp+B20h] [bp-Ch]
  char v16; // [sp+B25h] [bp-7h]
  char v17; // [sp+B26h] [bp-6h]
  unsigned __int8 v18; // [sp+B27h] [bp-5h]

  if ( a1 <= 1 )
  {
    print_usage_instructions(*a2);
    return 1;
  }
  if ( *a2[1] != 45 )
  {
    print_usage_instructions(*a2);
    return 2;
  }
  *(_DWORD *)dest = 0;
  memset(s, 0, sizeof(s));
  *(_DWORD *)v11 = 0;
  memset(v12, 0, sizeof(v12));
  *(_DWORD *)v9 = 0;
  memset(v10, 0, sizeof(v10));
  memset(v8, 0, sizeof(v8));
  v18 = 0;
  v17 = 0;
  v16 = 0;
  memset(v7, 0, sizeof(v7));
  switch ( a1 )
  {
    case 5:
      if ( strlen(a2[2]) <= 255 )
      {
        strcpy(dest, a2[2]);
        if ( strlen(a2[3]) <= 127 )
        {
          strcpy(v11, a2[3]);
          if ( strlen(a2[4]) > 127 )
          {
            puts("pemName Too Long!");
            return 4;
          }
          strcpy(v9, a2[4]);
          break;
        }
      }
LABEL_14:
      puts("fileName Too Long!");
      return 3;
    case 3:
      if ( strlen(a2[2]) > 127 )
        goto LABEL_14;
      strcpy(v11, a2[2]);
      break;
    case 2:
      break;
    default:
      puts("Param Err!");
      print_usage_instructions(*a2);
      return 3;
  }
  v15 = 0;
  switch ( a2[1][1] )
  {
    case 'f':
      goto LABEL_24;
    case 'n':
      return extract_and_write_firmware_segments((int)v11);
    case 'p':
      goto LABEL_20;
    case 'q':
      return create_and_fill_file();
    case 's':
      goto LABEL_22;
    case 'x':
      v16 = 1;
LABEL_20:
      if ( !v16 )
        v17 = 1;
LABEL_22:
      if ( !v17 )
        v18 = 1;
LABEL_24:
      v15 = validate_firmware_update(v11, dest, v9, v8, v18, v17, v16);
      break;
    default:
      puts("Command Not Support!");
      print_usage_instructions(*a2);
      v15 = 5;
      break;
  }
  return v15;
}
// 13A0C: control flows out of bounds to 13A10

//----- (00013B20) --------------------------------------------------------
int __fastcall init(int a1, int a2, int a3)
{
  void **v6; // r5
  int i; // r4
  int (__fastcall *v8)(int, int, int); // t1
  int result; // r0

  init_proc();
  v6 = &off_24F08;
  for ( i = 0; i != 1; ++i )
  {
    v8 = (int (__fastcall *)(int, int, int))*v6++;
    result = v8(a1, a2, a3);
  }
  return result;
}
// 24F08: using guessed type void *off_24F08;

//----- (00013B60) --------------------------------------------------------
int __fastcall get_file_stat(int file_path, int stat_buf)
{
  return j___xstat64(3, file_path, stat_buf);
}
// 107E0: using guessed type int __fastcall j___xstat64(_DWORD, _DWORD, _DWORD);

//----- (00013B6C) --------------------------------------------------------
void term_proc()
{
  ;
}

// nfuncs=81 queued=29 decompiled=29 lumina nreq=0 worse=0 better=0
// ALL OK, 29 function(s) have been successfully decompiled
