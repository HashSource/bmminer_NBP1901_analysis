```c
_BYTE *__fastcall createNewList(const char *listName, int elementSize, int allocationIncrement, int maxElementsCount, char shouldZeroOnAlloc, const char *operation, const char *file, int line)
{
  _BYTE *newList; // r4
  char *mutexBuffer; // r5
  int *mutexInitResult; // r0
  int *rwlockInitResult; // r0
  char logMessageBuffer[2080]; // [sp+10h] [bp-820h] BYREF

  if ( allocationIncrement <= 0 ) // Check if allocationIncrement is valid
  {
    snprintf(
      logMessageBuffer,
      sizeof(logMessageBuffer),
      "Invalid new list %s with allocate %d must be > 0 in %s %s():%d",
      listName,
      allocationIncrement,
      "klist.c",
      "_k_new_list",
      100);
    logMessage(3, logMessageBuffer, 1);
    terminateOnError(1);
    if ( maxElementsCount >= 0 )
      goto LABEL_ListInitialization;
  }
  else if ( maxElementsCount >= 0 ) // If allocationIncrement is valid, proceed to check maxElementsCount
  {
    goto LABEL_ListInitialization;
  }
  // Handle invalid maxElementsCount
  snprintf(
    logMessageBuffer,
    sizeof(logMessageBuffer),
    "Invalid new list %s with limit %d must be >= 0 in %s %s():%d",
    listName,
    maxElementsCount,
    "klist.c",
    "_k_new_list",
    103);
  logMessage(3, logMessageBuffer, 1);
  terminateOnError(1);
LABEL_ListInitialization:
  newList = calloc(1u, 0x40u); // Allocate memory for the list structure
  if ( !newList ) // Check if memory allocation was successful
  {
    snprintf(logMessageBuffer, sizeof(logMessageBuffer), "Failed to calloc list %s in %s %s():%d", listName, "klist.c", "_k_new_list", 107);
    logMessage(3, logMessageBuffer, 1);
    terminateOnError(1);
  }
  newList[4] = 0; // Initialize list flags
  mutexBuffer = (char *)calloc(1u, 0x38u); // Allocate memory for the mutex
  *((_DWORD *)newList + 2) = mutexBuffer; // Store mutex pointer in the list structure
  if ( !mutexBuffer ) // Check if mutex memory allocation was successful
  {
    snprintf(logMessageBuffer, sizeof(logMessageBuffer), "Failed to calloc lock for list %s in %s %s():%d", listName, "klist.c", "_k_new_list", 113);
    logMessage(3, logMessageBuffer, 1);
    terminateOnError(1);
    mutexBuffer = (char *)*((_DWORD *)newList + 2); // Retrieve the mutex pointer
  }
  if ( pthread_mutex_init((pthread_mutex_t *)mutexBuffer, 0) ) // Initialize the mutex
  {
    mutexInitResult = getErrnoLocation();
    snprintf(logMessageBuffer, sizeof(logMessageBuffer), "Failed to pthread_mutex_init errno=%d in %s %s():%d", *mutexInitResult, "klist.c", "_k_new_list", 115);
    logMessage(3, logMessageBuffer, 1);
    terminateOnError(1);
  }
  if ( pthread_rwlock_init((pthread_rwlock_t *)(mutexBuffer + 24), 0) ) // Initialize the read-write lock
  {
    rwlockInitResult = getErrnoLocation();
    snprintf(logMessageBuffer, sizeof(logMessageBuffer), "Failed to pthread_rwlock_init errno=%d in %s %s():%d", *rwlockInitResult, "klist.c", "_k_new_list", 115);
    logMessage(3, logMessageBuffer, 1);
    terminateOnError(1);
  }
  *(_DWORD *)newList = listName; // Store list name
  *((_DWORD *)newList + 5) = elementSize; // Store size of each element
  *((_DWORD *)newList + 9) = allocationIncrement; // Store allocation increment
  *((_DWORD *)newList + 10) = maxElementsCount; // Store max elements count limit
  newList[44] = shouldZeroOnAlloc; // Store flag for zero-initialization
  configureList((const char **)newList, operation, file, line); // Configure the list with operation, file, and line for logging
  return newList; // Return the pointer to the newly created list
}
```