```c
/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

undefined4 AdjustFrequency(int chain_index, undefined4 frequency_mode, uint *output_frequency)
{
  undefined4 status_code;
  char *chip_type;
  int comparison_result;
  uint freq_level;
  uint *freq_table_ptr;
  uint target_freq;
  uint asic_freq;
  int local_82c;
  undefined4 model_version_1;
  undefined4 model_version_2;
  undefined4 model_version_3;
  undefined4 model_version_4;
  undefined4 uStack_818;
  undefined local_814;
  
  // Check if frequency mode and flag is set or if work mode is greater than a threshold
  if ((GlobalWorkModeFlag == 0) || (*(char *)(GlobalWorkModeFlag + 0x1c) == '\0')) {
    if (4 < VerboseLoggingLevel) {
      snprintf((char *)&model_version_1, 0x800,"No work mode freq, chain = %d, mode = %d.\n", chain_index, frequency_mode);
      LogMessage(4, &model_version_1, 0);
      return 0xffffffff;
    }
    status_code = 0xffffffff;
  }
  else {
    comparison_result = *(int *)(GlobalWorkModeFlag + chain_index * 4);
    freq_table_ptr = &GlobalFrequencyTable;
    asic_freq = (uint)*(ushort *)(comparison_result + 0x23);
    target_freq = (uint)*(ushort *)(comparison_result + 0x25);
    do {
      if ((freq_table_ptr[-1] != 0) && (*freq_table_ptr == target_freq && (*freq_table_ptr != 0 && freq_table_ptr[-1] == asic_freq))) {
        chip_type = (char *)GetChipType();
        comparison_result = strcmp(chip_type, "NBS2003");
        freq_level = target_freq;
        if (comparison_result == 0) {
          local_82c = comparison_result;
          model_version_1 = comparison_result;
          model_version_2 = comparison_result;
          model_version_3 = comparison_result;
          model_version_4 = comparison_result;
          ReadAsicModelVersion(chain_index, &model_version_1, 0x10);
          ReadMinerModelVersion(chain_index, &local_82c);
          // Check against known ASIC and Miner model versions
          if ((((model_version_1 == 0x30563146) && (model_version_2 == 0x43314235)) && ((char)model_version_3 == '1'))
             && (local_82c - 3U < 2)) {
            // Adjust frequency level based on ASIC frequency and target frequency
            if (target_freq == 0x28a && asic_freq == 0x500) {
              freq_level = 600;
            }
            else {
              freq_level = 0x271;
              if (asic_freq == 0x514 && target_freq == 0x271) {
                freq_level = 0x23f;
              }
              if (((asic_freq != 0x514 || target_freq != 0x271) &&
                  (freq_level = target_freq, asic_freq == 0x500 && target_freq == 0x271)) &&
                 (freq_level = 0x23f, target_freq == 0x28a)) {
                freq_level = 600;
              }
            }
          }
        }
        if (output_frequency != (uint *)0x0) {
          *output_frequency = freq_level;
          return 0;
        }
      }
      freq_table_ptr = freq_table_ptr + 2;
    } while (freq_table_ptr != &EndOfFrequencyTable);
    // If reached the end of frequency table and no match is found
    if (4 < VerboseLoggingLevel) {
      // Log the mismatch event and set status accordingly
      LogFrequencyMismatch(&model_version_1);
      return 0xfffffffe;
    }
    status_code = 0xfffffffe;
  }
  return status_code;
}

```