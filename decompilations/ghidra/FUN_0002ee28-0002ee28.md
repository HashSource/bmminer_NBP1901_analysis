```c
void ProcessSHA256Block(int hashStatePtr, byte *dataPtr, int numberOfBlocks)
{
  byte *currentDataPtr;
  uint tempUint;
  int *hashStateWorkingVar1;
  int *hashStateWorkingVar2;
  int *hashStateWorkingVar4;
  int index;
  uint *currentSchedulePtr;
  uint *targetSchedulePtr;
  uint rotatedTempUint;
  byte *processedDataEnd;
  int hashStateCache[7];
  uint scheduleArray[65];
  int *hashStateWorkingVar3;
  
  if (0 < numberOfBlocks) {
    processedDataEnd = dataPtr;
    do {
      targetSchedulePtr = &scheduleArray[0];
      currentDataPtr = processedDataEnd;
      do {
        targetSchedulePtr = targetSchedulePtr + 1;
        *targetSchedulePtr = (uint)currentDataPtr[1] << 16 | (uint)currentDataPtr[2] << 8 | (uint)currentDataPtr[3] |
                             (uint)*currentDataPtr << 24;
        currentDataPtr = currentDataPtr + 4;
        currentSchedulePtr = scheduleArray;
      } while (scheduleArray + 15 != targetSchedulePtr); // Fill the first 16 words of the schedule array
      do {
        rotatedTempUint = currentSchedulePtr[14];
        targetSchedulePtr = currentSchedulePtr + 1;
        tempUint = *targetSchedulePtr;
        currentSchedulePtr[16] = ((rotatedTempUint >> 19 | rotatedTempUint << 13) ^ (rotatedTempUint >> 11 | rotatedTempUint << 21) ^
                       rotatedTempUint >> 10) + currentSchedulePtr[9] + *currentSchedulePtr +
                       ((tempUint >> 18 | tempUint << 14) ^ (tempUint >> 7 | tempUint << 25) ^ tempUint >> 3);
        currentSchedulePtr = targetSchedulePtr;
      } while (scheduleArray + 48 != targetSchedulePtr); // Extend the first 16 words into the remaining 48 words
      hashStateWorkingVar1 = &hashStateCache[0];
      hashStateWorkingVar2 = (int *)(hashStatePtr + 0x88);
      hashStateWorkingVar4 = hashStateWorkingVar1;
      do {
        hashStateWorkingVar3 = hashStateWorkingVar2 + 1;
        hashStateWorkingVar4 = hashStateWorkingVar4 + 1;
        *hashStateWorkingVar4 = *hashStateWorkingVar2;
        hashStateWorkingVar2 = hashStateWorkingVar3;
      } while ((int *)(hashStatePtr + 0xa8) != hashStateWorkingVar3); // Cache the current hash state
      index = 0;
      do {
        // The main SHA-256 compression function goes here, processing the data and updating the hash state
        index = index + 1;
        hashStateWorkingVar2 = (int *)(hashStatePtr + 0x88);
      } while (index != 64); // Loop through 64 rounds of SHA-256 hashing algorithm
      do {
        hashStateWorkingVar1 = hashStateWorkingVar1 + 1;
        hashStateWorkingVar4 = hashStateWorkingVar2 + 1;
        *hashStateWorkingVar2 = *hashStateWorkingVar1 + *hashStateWorkingVar2; // Add the compressed chunk to the current hash value
        hashStateWorkingVar2 = hashStateWorkingVar4;
      } while (hashStateWorkingVar3 != hashStateWorkingVar4); // Update the hash state with the new hash computation result
      processedDataEnd = processedDataEnd + 64; // Move to the next 64-byte chunk
    } while (dataPtr + numberOfBlocks * 64 != processedDataEnd); // Continue processing all blocks
    return;
  }
  return;
}
```