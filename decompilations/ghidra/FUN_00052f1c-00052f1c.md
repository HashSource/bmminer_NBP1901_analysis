```c
#include <pthread.h>

// Global logging framework initialized status flag
static int isLoggingFrameworkInitialized = 0;

// Global counter for logging framework use
static int loggingFrameworkUsageCounter = 0;

// Global lock for thread-safe logging framework initialization
static pthread_rwlock_t loggingFrameworkLock = PTHREAD_RWLOCK_INITIALIZER;

// Function to initialize logging framework
undefined4 InitializeLoggingFramework(char *configFilePath)
{
  int lockResult;
  int initResult;
  
  // Log the starting of the logging framework initialization
  LogDebug("src/zlog.c", 119, "------Logging Initialization Start------");
  
  // Compile-time information
  char *versionString = "1.2.12";
  char *timeString = "16:28:36";
  char *dateString = "Dec  6 2022";

  // Log compile-time information
  LogDebug("src/zlog.c", 120, "------compile time[%s %s], version[%s]------", dateString, timeString, versionString);
  
  // Acquire write lock
  lockResult = pthread_rwlock_wrlock(&loggingFrameworkLock);
  if (lockResult == 0) {
    // If logging framework is not already initialized
    if (isLoggingFrameworkInitialized == 0) {
      // Try to initialize logging framework with the provided config file path
      initResult = InternalInitializeLogging(configFilePath);
      if (initResult == 0) {
        // Increment usage counter and set the initialized flag
        loggingFrameworkUsageCounter += 1;
        isLoggingFrameworkInitialized = 1;

        // Log successful initialization
        LogDebug("src/zlog.c", 142, "------Logging Initialization Successful------");
        
        // Release write lock
        lockResult = pthread_rwlock_unlock(&loggingFrameworkLock);
        if (lockResult != 0) {
          // Log failure to release lock
          LogError("src/zlog.c", 145, "pthread_rwlock_unlock fail, rc=[%d]", lockResult);
          return 0xffffffff;
        }
        // Return success
        return 0;
      }
      // Log initialization failure
      LogError("src/zlog.c", 134, "Internal Logging Initialization[%s] failed", configFilePath);
    } else {
      // Log message if logging framework is already initialized
      LogError("src/zlog.c", 129, "Logging framework already initialized, Please use reload feature");
    }
    // Log the ending of a failed initialization
    LogError("src/zlog.c", 150, "------Logging Initialization Failed------");
    
    // Release write lock even if initialization failed
    lockResult = pthread_rwlock_unlock(&loggingFrameworkLock);
    if (lockResult != 0) {
      // Log failure to release lock
      LogError("src/zlog.c", 153, "pthread_rwlock_unlock fail, rc=[%d]", lockResult);
      return 0xffffffff;
    }
  } else {
    // Log failure to acquire write lock
    LogError("src/zlog.c", 124, "pthread_rwlock_wrlock failed, rc=[%d]", lockResult);
  }
  // Return error code for failed initialization
  return 0xffffffff;
}

// Function to log messages with different levels
void LogDebug(const char *sourceFile, int lineNumber, const char *message, ...);
void LogError(const char *sourceFile, int lineNumber, const char *message, ...);

// Function to internally initialize the logging framework
int InternalInitializeLogging(char *configFilePath);
```

Please note that because this is pseudo code, some types such as `undefined4` were assumed to be placeholder types and therefore are replaced with a placeholder return type. Additionally, without the definitions of `FUN_0005df98`, `FUN_00052dcc`, and `DAT_0058de1c`, I have provided assumed names for them. You'd need to replace these with appropriate entity names and include any missing headers or definitions as necessary for the actual code environment.