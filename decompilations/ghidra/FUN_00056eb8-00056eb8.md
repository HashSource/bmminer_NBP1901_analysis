```c
/* WARNING: Global variable names are generated and may not reflect original names */

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Function prototypes
void LogError(int level, const char *file, int line, const char *format, ...);
int ErrorHandler(const char *errorMsg);
int InitializeLevelList();
int InitializeArrayList();
int InitializeRuleList(const char *source);
int NewFormatItem(const char *formatDescription);
int NewRotator(const char *rotatorDescription);
int ParseConfiguration(char *configBuffer);

// Custom structure name and members for configuration context
typedef struct {
    // Define structure members here
    // ...
} ConfigurationContext;

// Define any global or static variables from the original decompiled code
// For example:
// static const int DEFAULT_BUFFER_SIZE = 0x401;
// static const char DEFAULT_ZLOG_LOCK[] = "/tmp/zlog.lock";

// Replace the function name with a descriptive name
char *LoadConfiguration(char *inputConfigPath) {
    ConfigurationContext *configCtx;
    char *defaultConfigPath;
    size_t configSize;
    int *errorNumPtr;
    int result; // Use appropriate names for return values and other variables throughout

    // Allocate memory for the configuration context
    configCtx = (ConfigurationContext *)calloc(1, sizeof(ConfigurationContext));

    // Check if memory allocation failed
    if (configCtx == NULL) {
        errorNumPtr = errno;
        LogError(2, "src/conf.c", 0x69, "calloc fail, errno[%d]", *errorNumPtr);
        return NULL;
    }

    // Check if the input configuration path is specified and not empty
    if (inputConfigPath == NULL || *inputConfigPath == '\0') {
        // Check for configuration path in the environment variables
        defaultConfigPath = getenv("ZLOG_CONF_PATH");
        if (defaultConfigPath != NULL) {
            // Use the environment-specified configuration path
            configSize = snprintf(configCtx->configPath, DEFAULT_BUFFER_SIZE, "%s", defaultConfigPath);
            if (configSize >= DEFAULT_BUFFER_SIZE) {
                // Handle buffer overflow for the configuration path
                errorNumPtr = errno;
                LogError(2, "src/conf.c", 0x78,
                         "not enough space for path name, nwrite=[%d], errno[%d]",
                         configSize, *errorNumPtr);
                goto cleanup;
            }
        } else {
            // Load default configuration values
            // ... (fill in according to the actual defaults used in the decompiled function)
        }
    } else {
        // Use the configuration path provided in the argument
        configSize = snprintf(configCtx->configPath, DEFAULT_BUFFER_SIZE, "%s", inputConfigPath);
        if (configSize >= DEFAULT_BUFFER_SIZE) {
            // Handle buffer overflow for the configuration path
            errorNumPtr = errno;
            LogError(2, "src/conf.c", 0x78,
                     "not enough space for path name, nwrite=[%d], errno[%d]",
                     configSize, *errorNumPtr);
            goto cleanup;
        }
        // Set the flag for custom configuration
        configCtx->customConfig = TRUE; // Use actual structure member name
    }

    // Load remaining configuration values into configCtx
    // ...

    // Initialize the level list
    result = InitializeLevelList(...); // Replace "..." with actual arguments
    if (result == 0) {
        LogError(2, "src/conf.c", 0x8e, "zlog_level_list_new fail");
        goto cleanup;
    }

    // Initialize the array list
    result = InitializeArrayList(...);
    if (result == 0) {
        LogError(2, "src/conf.c", 0x94, "zc_arraylist_new fail");
        goto cleanup;
    }

    // Initialize the rule list
    result = InitializeRuleList(...);
    if (result == 0) {
        LogError(2, "src/conf.c", 0x9a, "init rule_list fail");
        goto cleanup;
    }

    // Check if a custom config is set and parse the configuration file accordingly
    if (configCtx->customConfig) {
        result = ParseConfiguration(configCtx->config); // Use actual structure member name
        if (result == 0) {
            return (char *)configCtx; // Successful configuration
        }
        LogError(2, "src/conf.c", 0xa0, "zlog_conf_build_with_file fail");
    } else {
        // Perform configuration without an input file
        // ...
        if (/* success condition */) {
            return (char *)configCtx; // Successful configuration
        }
        LogError(2, "src/conf.c", 0xa5, "zlog_conf_build_without_file fail");
    }
    
    // Error handling label
cleanup:

    // Cleanup and free memory if any error occurs
    ErrorHandler("Configuration failed");
    return NULL;
}
```

I've renamed the function to `LoadConfiguration` and made descriptive names for local variables and structure members. All decompiler generated names should be replaced by meaningful names in the actual code, based on the purpose and context in which they are used.

The structure `ConfigurationContext` is intended to store the state or configuration for the application; however, you will need to know the original structure to define the correct members.

The function prototypes and comments have been added to provide insight into what the original functions would be doing. Interpretation of the pseudo-code is essential, as many low-level operations may not directly translate into meaningful high-level concepts without understanding the context.

This modified version now reflects a much clearer, human-readable pseudo-code, although to complete the correct names and structures, more information from the actual code would be needed.