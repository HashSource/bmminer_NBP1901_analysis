```c
void ProcessMiningData(byte *dataBuffer) {
  byte statusByte;
  ushort nonceData;
  undefined4 currentTime;
  uint nonceTime;
  int chainIndex;
  int temperatureCompensation;
  int temperatureValue;
  uint errorCode;
  uint frequencyValue;
  uint miningWorkTime;
  int frequencyIndex;
  uint frequencyMask;

  // Extract the chain index from the data buffer
  chainIndex = *(int *)(dataBuffer + 4);

  // Get the current time using a custom function
  currentTime = GetCurrentTime();

  // Calculate the nonce time using a function that takes chain index and current time
  nonceTime = CalculateNonceTime(chainIndex, currentTime);

  // Extract the nonce data from the data buffer
  nonceData = *(ushort *)(dataBuffer + 2);

  // Get the lower 4 bits from the first byte data for determining mining work time
  miningWorkTime = *dataBuffer & 0xf;

  // Get temperature compensation value using a function and the chain index
  temperatureCompensation = GetTemperatureCompensation(chainIndex);

  // Get the value used for temperature compensation
  temperatureValue = GetTemperatureValue();

  // Check if the mining work time is valid within the expected range
  if (miningWorkTime > 3 || !IsFrequencyValid(miningWorkTime)) {
    IncreaseErrorCounter(); // Increase specific error count
    return;
  }

  // Extract the status byte
  statusByte = *dataBuffer;

  // Check different flags in the status byte and increment relevant error counters
  if ((statusByte & 0x20) != 0) {
    IncreaseErrorCounterType1(miningWorkTime);
    return;
  }
  if ((statusByte & 0x40) != 0) {
    IncreaseErrorCounterType2(miningWorkTime);
    return;
  }
  if ((statusByte & 0x80) == 0) {
    IncreaseErrorCounterType3(miningWorkTime);
    return;
  }

  // Get the frequency error code for comparison
  errorCode = GetErrorCode();

  // If the nonce time is not greater than the calculated value, increase the error counter
  if (errorCode <= nonceTime) {
    IncreaseErrorCounterType4(miningWorkTime);
    return;
  }

  // Calculate the frequency value and index, and mask for error checking
  frequencyValue = (int)(nonceData & 0x7fff) >> 7;
  frequencyMask = nonceData & 3;
  frequencyIndex = temperatureValue * temperatureCompensation + frequencyMask;
  frequencyValue = GetFrequencyThreshold();

  // Check if frequency value exceeds a threshold or if the frequency value is within a range
  if (frequencyValue <= frequencyIndex || frequencyValue > 7) {
    IncreaseErrorCounterType5(miningWorkTime);
    return;
  }

  // Check if nonce time matches the expected value at a specific location
  if (CheckNonceTimeAgainstExpected(chainIndex, nonceTime, frequencyValue, frequencyMask)) {
    UpdateNonceStatistics(miningWorkTime, nonceTime, frequencyIndex);
    return;
  }

  // Update the nonce error statistics and increase error counter if the verification fails
  if (VerifyNonce(chainIndex, nonceData, miningWorkTime, chainIndex) == 0) {
    IncreaseErrorCounterType5(miningWorkTime);
  } else {
    IncrementNonceFoundCounter(miningWorkTime);
  }
  return;
}
```

Comments have been added to explain what each part of the function does, and the names have been clarified to convey the purpose of different variables and operations within the code. The goal was to make it more understandable without changing the existing structure and logic of the code.