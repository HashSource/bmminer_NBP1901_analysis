```c
void process_input_data(byte *inputBuffer)
{
  int index; // Temporary variable to hold calculated index
  uint currentBufferPosition; // To store the current buffer write position
  uint nextBufferPosition; // To store the calculated next position
  
  currentBufferPosition = BUFFER_WRITE_POSITION; // Get the current write position from a global
  nextBufferPosition = BUFFER_WRITE_POSITION + 1; // Calculate the next position
  index = nextBufferPosition * 8; // Calculate the index for the data storage
  
  // Store the second part of the input buffer (4 bytes) into the buffer array
  BUFFER_ARRAY[nextBufferPosition * 2] = *(undefined4 *)(inputBuffer + 4);
  
  // Extract specific bits from the third byte of the input buffer and store it
  BUFFER_SUB_ARRAY[nextBufferPosition * 2] = inputBuffer[3] & 0x07; // Mask with 0b00000111
  
  // Store the remaining three bytes of input buffer into subsequent positions
  BUFFER_SUB_ARRAY[index + 1] = inputBuffer[2];
  BUFFER_SUB_ARRAY[index + 2] = inputBuffer[1];
  
  // Check if we haven't reached the end of the buffer (0x1fe == 510)
  if (currentBufferPosition < 0x1fe) {
    BUFFER_WRITE_POSITION = nextBufferPosition; // Update the buffer write position
  }
  
  // Store the first byte of the input buffer by extracting specific bits
  BUFFER_SUB_ARRAY[index + 3] = inputBuffer[0] & 0x0F; // Mask with 0b00001111
  
  // If we have reached the end of the buffer, loop back to start
  if (currentBufferPosition >= 0x1fe) {
    BUFFER_WRITE_POSITION = 0; // Reset buffer write position
  }
  
  // Check if the sub buffer has reached the limit (0x1ff == 511)
  if (BUFFER_SUB_INDEX < 0x1ff) {
    BUFFER_SUB_INDEX = BUFFER_SUB_INDEX + 1; // Increment sub buffer index
  }
  else {
    BUFFER_SUB_INDEX = 0x1ff; // Set sub buffer index to maximum if it reached the limit
  }
  
  return;
}
```

Please note the following changes:
1. Function, variable and constant names are renamed to be more descriptive.
2. Comments are provided to explain the operations performed on each line of code.
3. Bitwise operations performed on bytes from `inputBuffer` have been commented to explain the masking logic used to store specific bits.