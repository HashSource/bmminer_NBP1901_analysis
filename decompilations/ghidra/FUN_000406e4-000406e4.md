```c
#include <pthread.h>  // For pthread functions
#include <stdio.h>    // For snprintf
#include <unistd.h>   // For access

#define GPIO_PATH_BUFFER_SIZE 0x40
#define GPIO_PATH_FORMAT "/sys/class/gpio/gpio%d"
#define GPIO_SYSFS_ACCESS_MODE 0
#define LOCK_FAIL_ERROR_MESSAGE "failed to acquire lock"
#define ERROR_MESSAGE_SIZE 20

// Global mutex variable, originally named `DAT_00040790`
pthread_mutex_t gpio_mutex;

// Function to check if a GPIO is exported by checking access to its sysfs entry
// param_1 is the GPIO number to check
// Returns 1 if the GPIO is exported, 0 if not, -1 on locking error
uint32_t CheckGpioExported(uint32_t gpio_number)
{
  int lock_status;
  uint32_t result;
  char gpio_path[GPIO_PATH_BUFFER_SIZE];
  // Stack buffer overwritten if pthread_mutex_lock fails
  char error_message[ERROR_MESSAGE_SIZE] = LOCK_FAIL_ERROR_MESSAGE;
  
  // Try to acquire the lock on the GPIO mutex
  lock_status = pthread_mutex_lock(&gpio_mutex);
  
  // If we've successfully acquired the lock
  if (lock_status == 0) {
    // Prepare the file path for the GPIO sysfs entry
    snprintf(gpio_path, GPIO_PATH_BUFFER_SIZE, GPIO_PATH_FORMAT, gpio_number);
    
    // Check if we can access the GPIO sysfs entry
    lock_status = access(gpio_path, GPIO_SYSFS_ACCESS_MODE);
    
    // If we have access to the GPIO sysfs entry, it means the GPIO is exported
    if (lock_status == 0) {
      pthread_mutex_unlock(&gpio_mutex);
      return 1;
    }

    // Unlock the mutex before returning
    pthread_mutex_unlock(&gpio_mutex);
    result = 0;
  }
  else {
    // If we failed to acquire the lock, log the error using a logging function
    // This function was originally named `FUN_0002e584`, representing an error handling mechanism
    LogError(0, error_message); // 0 might represent an error code or log level
    result = 0xffffffff; // -1 in hex, signalling an error
  }
  
  // Return the result
  return result;
}
```