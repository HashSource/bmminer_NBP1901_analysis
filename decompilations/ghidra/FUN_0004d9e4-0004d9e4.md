```c
#include <stdlib.h>
#include <string.h>

// Result code indicating success or type of failure
typedef enum {
    SUCCESS = 0,
    FAILURE = 0xffffffff
} ResultCode;

ResultCode appendToBuffer(void **bufferStruct, void *dataToAppend, size_t dataSize) {
    void *currentBufferEnd;
    void *bufferLimit;
    void *newBufferLimit;
    
    bufferLimit = bufferStruct[2];
    currentBufferEnd = bufferStruct[1];
    
    // Check if there's enough space in the buffer to append the data
    if (dataSize < (size_t)((int)bufferLimit - (int)currentBufferEnd)) {
        newBufferLimit = *bufferStruct;
        
        // Copy the data to the end of the current buffer
    AppendData:
        memcpy((void *)((int)newBufferLimit + (int)currentBufferEnd), dataToAppend, dataSize);
        
        // Update the buffer's end pointer after appending the data
        buffersEnd = (void *)(dataSize + (int)currentBufferEnd);
        bufferStruct[1] = buffersEnd;
        
        // Null-terminate the buffer at the new end
        *(char *)((int)*bufferStruct + (int)buffersEnd) = '\0';
        
        return SUCCESS;
    }
    
    // If the current buffer end is valid and there is enough space to allocate a new buffer
    // including the new data
    if (((dataSize != FAILURE) && (currentBufferEnd <= (void *)((size_t)-2 - dataSize)))) {
        // Calculate the new buffer limit including the new data and a null terminator
        newBufferLimit = (void *)(dataSize + 1 + (int)currentBufferEnd);
        
        // Double the buffer size until it's large enough to hold the new data
        if (newBufferLimit < (void *)((int)bufferLimit << 1)) {
            newBufferLimit = (void *)((int)bufferLimit << 1);
        }
        
        // Allocate the new buffer
        void *newBuffer = realloc_buffer(newBufferLimit);
        if (newBuffer != NULL) {
            // Copy the current data into the new buffer
            memcpy(newBuffer, *bufferStruct, (size_t)bufferStruct[1]);
            
            // Free the old buffer
            free_buffer(*bufferStruct);
            
            // Update the buffer structure to point to the new buffer and its limit
            currentBufferEnd = bufferStruct[1];
            *bufferStruct = newBuffer;
            bufferStruct[2] = newBufferLimit;
            
            // Now append the new data to the buffer
            goto AppendData;
        }
    }
    
    // Return failure if any of the conditions for appending data are not met
    return FAILURE;
}

// Assuming FUN_0004d880 is a function to reallocate the buffer
void* realloc_buffer(void* newSize) {
    // Reallocation logic (to be implemented, placeholder for example)
    return realloc(newSize); // Replace with real implementation if available
}

// Assuming FUN_0004d898 is a function to free the buffer
void free_buffer(void* buffer) {
    // Free buffer logic (to be implemented, placeholder for example)
    free(buffer); // Replace with real implementation if available
}
```