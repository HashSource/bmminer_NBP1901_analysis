```c
// Remove an entry from a hash table and clean up associated resources.
// Args:
// - hashTable: pointer to the hash table structure.
// - keyStr: null-terminated string key of the entry to be removed.
// Returns:
// - 0 if the entry was removed successfully, or 0xFFFFFFFF if an error occurred.

undefined4 removeHashTableEntry(int *hashTable, char *keyStr)
{
  bool lockAcquired;
  size_t keyLen;
  uint hashValue;
  int *bucketHead;
  int bucketIndex;
  int *prevEntry;
  uint tableIndex;
  int hashTableStart;
  int currentEntryPtr;
  
  keyLen = strlen(keyStr);
  hashValue = hashFunction(keyStr, keyLen, HASH_BASE); // DAT_005051c0 is HASH_BASE
  hashTableStart = hashTable[1];
  tableIndex = hashValue & ~(-1 << (hashTable[2] & 0xffU)); // mask with size/power of two to get the index
  bucketIndex = hashTableStart + tableIndex * 8;
  bucketHead = (int *)getBucketEntry(hashTable, bucketIndex, keyStr, hashValue); // FUN_0004b838 is renamed to getBucketEntry
  if (bucketHead == (int *)0x0) {
    return 0xffffffff; // Entry not found in the hash table.
  }
  prevEntry = bucketHead[1];
  currentEntryPtr = *bucketHead;
  if (bucketHead == *(int **)(hashTableStart + tableIndex * 8)) {
    if (bucketHead == *(int **)(bucketIndex + 4)) {
      // Head is also tail - reset to initial state.
      *(int **)(bucketIndex + 4) = hashTable + 3;
      *(int **)(hashTableStart + tableIndex * 8) = hashTable + 3;
    }
    else {
      // Update the head to the next entry.
      *(int *)(hashTableStart + tableIndex * 8) = prevEntry;
    }
  }
  else if (bucketHead == *(int **)(bucketIndex + 4)) {
    // Last entry in bucket, update tail.
    *(int *)(bucketIndex + 4) = currentEntryPtr;
  }
  // Correct the linkage of the previous and next entries.
  *(int *)(currentEntryPtr + 4) = prevEntry;
  bucketIndex = bucketHead[3];
  hashTableStart = bucketHead[5];
  *(int *)bucketHead[1] = currentEntryPtr;
  prevEntry = bucketHead[2];
  *(int *)(prevEntry + 4) = bucketIndex;
  *(int *)bucketHead[3] = prevEntry;
  if ((hashTableStart != 0) && (*(int *)(hashTableStart + 4) != -1)) {
    prevEntry = (int *)(hashTableStart + 4);
    DataMemoryBarrier(0xb); // Ensure memory operations complete before proceeding.
    do {
      hashTableStart = *prevEntry;
      lockAcquired = (bool)hasExclusiveAccess(prevEntry); // Test for exclusive access to this variable
    } while (!lockAcquired);
    *prevEntry = hashTableStart - 1;
    if (hashTableStart - 1 == 0) {
      releaseResource(); // Assume this function releases resources (FUN_0004eb6c renamed).
    }
  }
  freeEntry(bucketHead); // Deallocate the entry (FUN_0004d898 renamed)
  *hashTable = *hashTable - 1; // Decrement the count of entries in the hash table.
  return 0; // Successful removal.
}
```