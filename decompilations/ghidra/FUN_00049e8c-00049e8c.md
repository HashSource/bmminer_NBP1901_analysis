```c
/* Pseudo C code decompiled from ARM binary using Ghidra.
 * Function for reading data via I2C from a device on a Bitmain Antminer embedded Linux system.
 */

// Global variables have been renamed for clarity
extern pthread_mutex_t GlobalI2CMutex;
extern int GlobalI2CDescriptor;

// Function to read I2C data has been renamed to 'I2CReadData'
int I2CReadData(undefined4 contextId, byte *registerAddress, int numBytesToRead, int dataBufferOffset, int dataBufferSize) {
  byte byteValue;
  int *i2cDeviceAddresses;
  int readOpResult;
  int numBytesRead;
  uint calcValue;
  int tempVar;
  undefined4 errorMsgBuffer[2];
  int *deviceAddressArray;
  undefined4 errorMsg;
  undefined4 uStack_81c;
  undefined4 uStack_818;
  undefined4 uStack_814;
  undefined4 errorMsg_810;
  undefined4 uStack_80c;
  undefined4 errorMsg_808;
  undefined4 uStack_804;
  undefined4 uStack_7fc;
  undefined4 uStack_7f8;
  undefined4 uStack_7f4;
  undefined errorMsg_7f0;
  
  // Initial setup
  errorMsgBuffer[0] = contextId;
  if (numBytesToRead == 1) {
    // Attempt to lock the I2C bus mutex
    deviceAddressArray = (int *)pthread_mutex_lock(&GlobalI2CMutex);
    if (deviceAddressArray == (int *)0x0) {
      // Initiate the I2C read operation
      readOpResult = InitiateI2CReadOperation(GlobalI2CDescriptor, errorMsgBuffer, &deviceAddressArray);
      i2cDeviceAddresses = deviceAddressArray;
      if (readOpResult == 1) {
        readOpResult = 0;
        if (dataBufferSize != 0) {
          do {
            // Calculate I2C device read parameters
            tempVar = *i2cDeviceAddresses;
            calcValue = i2cDeviceAddresses[1];
            byteValue = *registerAddress;
            numBytesRead = I2CSendReadCommand();
            if (numBytesRead == 0) {
              DisplayError("IIC not ready for read1");
              free(deviceAddressArray);
              pthread_mutex_unlock(&GlobalI2CMutex);
              return -2;
            }
            // Execute the I2C read command
            I2CExecuteRead(tempVar, calcValue, byteValue, readOpResult, dataBufferOffset);
            numBytesRead++;
            numBytesRead = I2CCompleteRead(numBytesRead);
            if (numBytesRead == 0) {
              DisplayError("IIC failed to read data");
              free(deviceAddressArray);
              pthread_mutex_unlock(&GlobalI2CMutex);
              return -3;
            }
          } while (dataBufferSize != readOpResult);
        }
        // Clean up after successful read, unlock mutex
        free(deviceAddressArray);
        pthread_mutex_unlock(&GlobalI2CMutex);
        return dataBufferSize;
      }
      DisplayError("ctx not inited\n");
      pthread_mutex_unlock(&GlobalI2CMutex);
      readOpResult = -2;
    } else {
      DisplayError("Failed to I2C lock");
      readOpResult = -1;
    }
  } else {
    DisplayError("More than one byte reg address is not supported");
    readOpResult = -3;
  }
  return readOpResult;
}
```