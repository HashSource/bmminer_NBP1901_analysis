```c
long parseSizeStringToBytes(byte *sizeString)
{
  ushort **charTypeTablePtr;
  size_t strLength;
  long sizeInBytes;
  byte *currentCharPtr;
  byte *nonWhitespaceCharPtr;
  byte *nextCharPtr;
  int multiplier;
  uint charCode;
  
  // Validate that the input is not null
  if (sizeString == NULL) {
    logError(2,"src/zc_util.c",0x1b,"Size string is null or 0");
    return 0;
  }
  charCode = (uint)*sizeString;
  nonWhitespaceCharPtr = sizeString;
  if (charCode != 0) {
    charTypeTablePtr = __ctype_b_loc();
    currentCharPtr = sizeString;
    nextCharPtr = sizeString;
    do {
      nonWhitespaceCharPtr = currentCharPtr;
      // Check if the character is whitespace; if not, copy it
      if (((*charTypeTablePtr)[charCode] & 0x2000) == 0) {
        nonWhitespaceCharPtr = currentCharPtr + 1;
        *currentCharPtr = (byte)charCode;
      }
      nextCharPtr = nextCharPtr + 1;
      charCode = (uint)*nextCharPtr;
      currentCharPtr = nonWhitespaceCharPtr;
    } while (charCode != 0);
  }
  *nonWhitespaceCharPtr = 0;
  strLength = strlen((char *)sizeString);
  sizeInBytes = strtol((char *)sizeString, NULL, 10);
  if (sizeInBytes < 1) {
    sizeInBytes = 0;
  }
  else {
    charCode = (uint)sizeString[strLength - 1];
    if ((charCode & 0xdf) == 0x42) { // 'B' or 'b'
      charCode = (uint)sizeString[strLength - 2];
      multiplier = 0x400; // 1024
    }
    else {
      multiplier = 1000;
    }
    switch(charCode) {
    case 0x47: // 'G'
    case 0x67: // 'g'
      sizeInBytes = multiplier * multiplier * multiplier * sizeInBytes;
      break;
    default:
      charTypeTablePtr = __ctype_b_loc();
      if (((*charTypeTablePtr)[charCode] & 0x800) == 0) {
        logError(2,"src/zc_util.c",0x46,
                 "Wrong suffix parsing size in bytes for string [%s], ignoring suffix", sizeString);
      }
      break;
    case 0x4d: // 'M'
    case 0x6d: // 'm'
      multiplier = multiplier * multiplier;
      // Fallthrough to 'K' case
    case 0x4b: // 'K'
    case 0x6b: // 'k'
      sizeInBytes = multiplier * sizeInBytes;
    }
  }
  return sizeInBytes;
}
```