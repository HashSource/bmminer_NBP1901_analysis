```c
uint sendPicCommand(uint chainIndex, int data1, int data2, int dataPtr, uint dataSize)
{
  undefined4 logTag;
  int iVar2;
  char *errorMsg;
  uint operationResult;
  uint dataSizeAdjusted;
  uint dataSizeLocal;
  undefined2 checksum;
  uint operationLength;
  byte *dataBuffer;
  uint sizeCounter;
  undefined4 commandAddress;
  undefined2 startMarker;
  undefined2 payloadLength;
  undefined dataByte;
  undefined chainPlusSix;
  undefined dataByte2;
  undefined undefinedField;
  undefined4 headerField1;
  undefined4 headerField2;
  undefined4 headerField3;
  undefined4 headerField4;
  undefined4 headerField5;
  undefined4 headerField6;
  undefined2 headerField7;
  char responseBuffer[2052];
  uint headerCounter;

  if (chainIndex > 0xf) {
    snprintf(responseBuffer, 0x800, "%s: Bad PIC param, input chain is %d\n", TAG_UNKNOWN_1, chainIndex);
    logError(0, responseBuffer);
    return 0x80000201;
  }
  if ((*(int *)(CHAIN_DATA_ARRAY + chainIndex * 8) == 0) && (sizeCounter = openEeprom(), (int)sizeCounter < 0)) {
    snprintf(responseBuffer, 0x800, "%s: auto exec open_pic, but chain %d open eeprom failed\n",
             TAG_UNKNOWN_1, chainIndex);
    logError(0, responseBuffer, 0);
    return sizeCounter;
  }
  commandAddress = *(undefined4 *)(EEPROM_ADDRESS_ARRAY + chainIndex * 8);
  pthread_mutex_lock((pthread_mutex_t *)&MUTEX_GLOBAL_VAR);
  logTag = TAG_UNKNOWN_2;
  dataSizeAdjusted = dataSize;
  if (dataSize > 0xf) {
    dataSizeAdjusted = 0x10;
  }
  undefinedField = (undefined)data2;
  chainPlusSix = (undefined)(dataSize + 6);
  dataByte2 = (undefined)data1;
  headerCounter = (dataSize + 6 & 0xff) + data2 + 0x35 + data1;
  checksum = (undefined2)headerCounter;
  startMarker = 0xaa55;
  payloadLength = 0;
  headerField1 = 0;
  headerField2 = 0;
  headerField3 = 0;
  headerField4 = 0;
  headerField5 = 0;
  headerField6 = 0;
  headerField7 = 0;
  dataByte = 0x35;
  if (dataSize > 0) {
    dataBuffer = (byte *)(dataPtr - 1);
    dataSizeLocal = 0;
    do {
      dataBuffer = dataBuffer + 1;
      operationResult = (uint)*dataBuffer;
      if (((dataSizeLocal & 1) == 0) && (operationResult > 0x3f)) {
        snprintf(responseBuffer, 0x800, "%s: the data[%d] must be less than 0x3f\n", logTag, dataSizeLocal);
        logError(0, responseBuffer, 0);
        operationResult = (uint)*dataBuffer;
      }
      operationLength = headerCounter + operationResult;
      sizeCounter = dataSizeLocal + 1;
      *(char *)((int)&headerField1 + dataSizeLocal) = (char)operationResult;
      headerCounter = operationLength & 0xffff;
      checksum = (undefined2)operationLength;
      dataSizeLocal = sizeCounter;
    } while ((int)sizeCounter < (int)dataSizeAdjusted);
  }
  headerCounter = dataSizeAdjusted & 0xffff;
  dataSizeLocal = headerCounter + 8 & 0xffff;
  *(char *)((int)&startMarker + (headerCounter + 6 & 0xffff)) = (char)((ushort)checksum >> 8);
  *(char *)((int)&startMarker + (headerCounter + 7 & 0xffff)) = (char)checksum;
  headerCounter = writeEeprom(commandAddress, &startMarker, dataSizeLocal);
  if (headerCounter == dataSizeLocal) {
    usleep(300000);
    iVar2 = readEeprom(commandAddress, &payloadLength, 2);
    if (iVar2 == 2) {
      if (((byte)payloadLength != 0x35) || (payloadLength._1_1_ != 1)) {
        dataSizeAdjusted = 0;
        snprintf(responseBuffer, 0x800,
                 "%s failed 2! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
                 TAG_UNKNOWN_2, (uint)(byte)payloadLength, (uint)payloadLength._1_1_);
        logError(0, responseBuffer, 0);
      }
      goto FINISH;
    }
    errorMsg = "%s read EEPROM 2 err\n";
  }
  else {
    errorMsg = "%s write EEPROM 2 err\n";
  }
  snprintf(responseBuffer, 0x800, errorMsg, TAG_UNKNOWN_2);
  dataSizeAdjusted = 0;
  logError(0, responseBuffer);
FINISH:
  pthread_mutex_unlock((pthread_mutex_t *)&MUTEX_GLOBAL_VAR);
  return dataSizeAdjusted;
}
```

Comments, symbol names, and function names have been changed for better understanding, while maintaining the original structure.