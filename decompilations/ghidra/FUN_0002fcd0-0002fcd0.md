```c
#include <pthread.h> // Include pthread library for thread synchronization primitives
#include <stdbool.h> // Include bool type definition

// Create and enqueue a message into a thread-safe queue
// param_1 : QueueHandle - handle to the message queue structure
// param_2 : MessageData - data to be placed into the message queue
bool EnqueueMessage(int QueueHandle, undefined4 MessageData) {
  undefined4 *messagePtr;
  int lockResult;
  undefined4 *newMessage;
  undefined4 *prevMessage;
  bool wasQueueEmpty;

  // Allocate memory for the message and initialize the message structure
  messagePtr = (undefined4 *)AllocateMessageMemory(1, 0xc, "util.c", DAT_MessageAllocationID, 0x469);
  newMessage = messagePtr + 1;
  *messagePtr = MessageData; // Set message data
  messagePtr[1] = newMessage; // Initialize the next pointer
  messagePtr[2] = newMessage; // Initialize the previous pointer

  // Lock the queue to ensure thread-safe access
  lockResult = pthread_mutex_lock((pthread_mutex_t *)(QueueHandle + 0xc));
  if (lockResult != 0) {
    LogError(DAT_MessageAllocationID, 0x46d); // Log a mutex lock error
  }
  
  // Check if the queue is already marked as non-empty
  wasQueueEmpty = *(char *)(QueueHandle + 8) != '\0';
  
  // If the queue was marked as non-empty, free the allocated message
  if (wasQueueEmpty) {
    free(messagePtr);
  } else {
    // Otherwise, insert the new message into the queue
    prevMessage = *(undefined4 **)(QueueHandle + 4);
    *(undefined4 **)(QueueHandle + 4) = newMessage;
    messagePtr[1] = QueueHandle; // Point the message's next to the queue head
    messagePtr[2] = prevMessage; // Point the message's previous to the old head
    *prevMessage = newMessage; // Link the old head's next to the new message
  }
  
  // Signal that there is a new message in the queue
  pthread_cond_signal((pthread_cond_t *)(QueueHandle + 0x28));
  
  // Unlock the queue as we are done accessing it
  UnlockMutex((pthread_mutex_t *)(QueueHandle + 0xc), DAT_MessageAllocationID, 0x47a);
  
  // Call a function pointed to by the global pointer DAT_0007ecc4
  (*DAT_0007ecc4)();
  
  // Return true if the queue was empty before inserting, false otherwise
  return !wasQueueEmpty;
}

// Note: The function `AllocateMessageMemory`, `LogError`, `UnlockMutex`, and the variable `DAT_0007ecc4`
// have not been defined in the provided snippet, and their usage here assumes they are defined
// elsewhere in the program with those exact names. Further Reverse Engineering may be needed to provide 
// accurate names and implementations for those.
```