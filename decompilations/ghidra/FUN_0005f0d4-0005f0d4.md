```c
void *appendToBuffer(int bufferContext,void *dataToAppend,size_t dataLength)
{
  int resizeResult;
  void *currentBufferPosition;
  size_t remainingBufferSize;
  uint updatedBufferPosition;
  bool isNonBlockingMode;
  
  currentBufferPosition = *(void **)(bufferContext + 4);
  updatedBufferPosition = (int)currentBufferPosition + dataLength;
  
  // Check if there is enough space in the buffer to append the data
  if (*(uint *)(bufferContext + 8) < updatedBufferPosition) {
    // Not enough space, attempt to resize the buffer
    resizeResult = resizeBuffer(bufferContext,dataLength - (*(uint *)(bufferContext + 8) - (int)currentBufferPosition));
    if (resizeResult > 0) {
      logError(2,"src/buf.c",0x20d,"conf limit to %ld, can't extend, so output",
               *(undefined4 *)(bufferContext + 0x14));
      
      // Calculate remaining size and copy what fits
      remainingBufferSize = *(int *)(bufferContext + 8) - (int)*(void **)(bufferContext + 4);
      currentBufferPosition = memcpy(*(void **)(bufferContext + 4),dataToAppend,remainingBufferSize);
      isNonBlockingMode = *(char *)(bufferContext + 0x1c) == '\0';
      if (isNonBlockingMode) {
        currentBufferPosition = (void *)0x1;
      }
      
      // Update position in buffer
      *(size_t *)(bufferContext + 4) = *(int *)(bufferContext + 4) + remainingBufferSize;
      if (isNonBlockingMode) {
        return currentBufferPosition;
      }
      
      // Clean-up or finalize buffer if necessary
      finalizeBuffer(bufferContext);
      return (void *)0x1;
    }
    // Resize failed completely
    if (resizeResult != 0) {
      logError(2,"src/buf.c",0x215,"bufferResize fail");
      return (void *)0xffffffff; // Return an error
    }
    // Buffer was successfully resized, update the current position
    currentBufferPosition = *(void **)(bufferContext + 4);
    updatedBufferPosition = (int)currentBufferPosition + dataLength;
  }
  
  // There's enough space, so copy the data to the buffer
  memcpy(currentBufferPosition,dataToAppend,dataLength);
  
  // Update the buffer position
  *(uint *)(bufferContext + 4) = updatedBufferPosition;
  return (void *)0x0; // Return success
}
```

Note: This code assumes you provide the correct function and variable names based on other parts of the code or documentation. The comments are general explanations based on what the code seems to be doing. Some functions like `resizeBuffer`, `logError`, and `finalizeBuffer` are assumed based on the likely functionality related to buffer context management and error logging. Their exact functionality would need to be inferred from their respective implementations.