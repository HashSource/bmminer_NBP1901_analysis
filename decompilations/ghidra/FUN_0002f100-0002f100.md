```c
void CompleteHashCalculationAndUpdateOutput(int *hashStateBuffer, uint8_t *outputDigest)
{
  uint32_t messageLength;
  int indexOffset;
  uint32_t paddedMessageLength;
  int paddingIndex1;
  int paddingIndex2;
  int *hashStatePtr;
  int *currentHashStatePtr;
  int paddingLoopIndex;
  int zeroPaddingEndIndex;
  int messageLengthIndex1;
  int messageLengthIndex2;
  uint32_t blockCount;
  bool isShortMessage;
  
  messageLength = hashStateBuffer[1]; // Get the message length value from hash state buffer
  hashStatePtr = hashStateBuffer + 2; // Get pointer to the hash state
  isShortMessage = (messageLength & 0x3f) < 0x38; // Check if message length is shorter than 56 bytes
  
  // Determine block size based on the message length
  if (isShortMessage) {
    paddingIndex1 = 0x40;
  }
  else {
    paddingIndex1 = 0x80;
  }
  
  // Determine how many zeros should be added between the padding start and message size
  if (isShortMessage) {
    zeroPaddingEndIndex = 0x3c;
  }
  else {
    zeroPaddingEndIndex = 0x7c;
  }
  
  paddedMessageLength = (messageLength + *hashStateBuffer) * 8; // Calculate the bit length of the padded message
  
  // Set indices for message length based on message size
  if (isShortMessage) {
    messageLengthIndex1 = 0x3d;
    messageLengthIndex2 = 0x3e;
    paddingIndex2 = 0x3f;
    blockCount = 1;
  }
  else {
    messageLengthIndex1 = 0x7d;
    messageLengthIndex2 = 0x7e;
    paddingIndex2 = 0x7f;
    blockCount = 2;
  }
  
  // Clear remaining space after the message and before padding (if any)
  memset((void *)((int)hashStatePtr + messageLength), 0, paddingIndex1 - messageLength);
  // Set the first byte of padding
  *(uint8_t *)((int)hashStateBuffer + hashStateBuffer[1] + 8) = 0x80;
  // Place message bit length in the last 8 bytes of the buffer
  *(uint8_t *)((int)hashStatePtr + paddingIndex2) = (uint8_t)paddedMessageLength;
  *(uint8_t *)((int)hashStatePtr + messageLengthIndex2) = (uint8_t)(paddedMessageLength >> 8);
  *(uint8_t *)((int)hashStatePtr + messageLengthIndex1) = (uint8_t)(paddedMessageLength >> 16);
  *(uint8_t *)((int)hashStatePtr + zeroPaddingEndIndex) = (uint8_t)(paddedMessageLength >> 24);
  // Hash computation using the SHA-256 transform function
  SHA256Transform(hashStateBuffer, hashStatePtr, blockCount);
  
  currentHashStatePtr = hashStateBuffer + 0x22; // Point to the output part of the hash state buffer
  do {
    // Transfer the hash state into the output array
    outputDigest[3] = (uint8_t)*currentHashStatePtr;
    hashStatePtr = currentHashStatePtr + 1;
    outputDigest[2] = (uint8_t)((uint32_t)*currentHashStatePtr >> 8);
    outputDigest[1] = (uint8_t)*(uint16_t *)((int)currentHashStatePtr + 2);
    *outputDigest = *(uint8_t *)((int)currentHashStatePtr + 3);
    currentHashStatePtr = hashStatePtr;
    outputDigest += 4;
  } while (hashStateBuffer + 0x2a != hashStatePtr); // Repeat until the entire hash has been copied to the output
  return;
}
``` 
Comments are added to explain the role of each variable and operation within the function, the names of variables and functions have been changed to provide a clearer understanding of their roles. The function 'FUN_0002ee28' has been renamed to 'SHA256Transform', which is more descriptive of its likely role in performing a transformation as part of the SHA-256 hashing algorithm. The parameters 'param_1' and 'param_2' are renamed to 'hashStateBuffer' and 'outputDigest' to clarify their purposes. Additionally, each operation within the function is commented on to describe its function within the context of SHA-256 hash calculation and output preparation.