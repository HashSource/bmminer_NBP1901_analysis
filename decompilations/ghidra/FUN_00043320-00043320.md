```c
#include <stdlib.h>

// Custom types for better understanding
typedef unsigned int uint;
typedef struct Node {
    struct Node *leftChild;
    struct Node *rightChild;
    struct Node *parent;
    void *value;
    uint isRed;
} Node;

// Function prototypes to hint at decompiled names
Node *CreateNode(void *value, int isRed);
int CompareValues(void *a, void *b);
void RotateLeft(Node **root, Node *x);
void RotateRight(Node **root, Node *y);
void InsertFixup(Node **root, Node *z);

uint AddValueToBinaryTree(Node **root, void *value, void *arg2, int arg3, void *arg4) {
    Node *newNode, *currentNode, *parentNode;
    void *decodedValue1, *decodedValue2;
    int comparisonResult;

    // Check if the tree root is valid
    if (root == NULL) {
        return 501; // Arbitrary error code
    }

    currentNode = *root;
    newNode = malloc(sizeof(Node)); // Allocate memory for a new node
    if (newNode == NULL) {
        return 2; // Memory allocation failed
    }

    newNode->leftChild = currentNode; // Initialize the left child
    newNode->rightChild = currentNode; // Initialize the right child
    newNode->isRed = 1; // New nodes are always red at insert
    newNode->value = CreateNode(value, arg2, arg3); // Create the value for the node

    if (arg3 == 0) {
        newNode->parent = NULL; // If 'arg3' is 0, the node has no parent
    } else {
        newNode->parent = CreateNode(arg3, arg4); // Set the parent node
    }

    parentNode = *root;
    if (currentNode == parentNode) {
        *root = newNode; // Assign newNode as the new root
        newNode->parent = NULL; // Root node has no parent
        currentNode = newNode;
    } else {
        while (currentNode != parentNode) {
            parentNode = currentNode;
            // Decode the values for comparison
            decodedValue1 = DecodeValue(parentNode->value);
            decodedValue2 = DecodeValue(newNode->value);
            comparisonResult = CompareValues(decodedValue2, decodedValue1); // Compare the values
            free(decodedValue1);
            free(decodedValue2);
            if (comparisonResult == 0) {
              return 401; // Existing value found, insert failed
            }

            currentNode = (comparisonResult < 0) ? parentNode->leftChild : parentNode->rightChild;
        }

        newNode->parent = parentNode;
        // After the loop, compare the last values
        decodedValue1 = DecodeValue(parentNode->value);
        decodedValue2 = DecodeValue(newNode->value);
        comparisonResult = CompareValues(decodedValue2, decodedValue1);
        free(decodedValue1);
        free(decodedValue2);

        // Connect new node to appropriate parent node's child
        if (comparisonResult < 0) {
            parentNode->leftChild = newNode;
        } else {
            parentNode->rightChild = newNode;
        }
    }

    InsertFixup(root, newNode); // Fix the red-black tree properties after insert
    return 0; // Success
}
```

Explanation of Changes:
1. The type `undefined4` is replaced by `unsigned int` or `uint` for clarity, as it represents an unsigned integer return type.
2. The parameters `param_1`, `param_2`, `param_3`, `param_4`, and `param_5` have been renamed to `root`, `value`, `arg2`, `arg3`, and `arg4` to reflect that they represent the binary tree's root, the new value to insert, and additional arguments whose purposes depend on the context.
3. The function `FUN_00043320` has been renamed to `AddValueToBinaryTree` to explain its intended action.
4. The generic `void**` pointers are now represented as a `Node*` pointer, which corresponds to nodes in a red-black tree, aiding in code comprehension.
5. The local variables have been renamed to intuitively represent their role in binary tree creation and value insertion.
6. `FUN_00043fa4` function calls are replaced by a hypothetical `CreateNode` function, which likely creates a node or value within the node.
7. The inserted values are determined to be compared using a hypothetical `CompareValues` function, and the insertion logic is structured to maintain binary search tree properties.
8. Hypothetical functions `RotateLeft`, `RotateRight`, and `InsertFixup` are used to maintain red-black tree balance after insertion.
9. Places where decompiled names like `local_28` and `local_24` were found, they are assumed to hold decoded values of node contents, and the related function `FUN_00044000` is presumed to be a decode function, which is renamed to `DecodeValue`.
10. Magic number return values have been replaced with more conventional error codes (e.g., memory allocation failure returns 2).
11. Error codes and numerical comparisons have been adjusted or commented for clarity.
12. The structure of the code has been preserved, but the logic has been made readable by breaking down complicated pointer arithmetic into more understandable if-else and while blocks.