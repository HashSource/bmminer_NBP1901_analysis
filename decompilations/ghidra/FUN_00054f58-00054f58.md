```c
void LogMessageWithLevel(undefined4 file, undefined4 line, undefined4 function, undefined4 param_4,
                         undefined4 message, uint logLevel, undefined4 param_7)
{
  int *threadBufferPointer;
  int operationResult;
  uint effectiveLevel;
  uint levelByteOffset;
  
  pthread_rwlock_rdlock((pthread_rwlock_t *)&rwlockVariable);
  if (globalVariableOne == 0) {
    LogError(2, "src/zlog.c", 0x380, "Never called zlog_init() or dzlog_init() before");
  }
  else if (defaultCategoryVariable == 0) {
    LogError(2, "src/zlog.c", 0x387,
             "Default category is null, dzlog_init() or dzlog_set_category() is not called above");
  }
  else {
    effectiveLevel = logLevel + 7;
    if (-1 < (int)logLevel) {
      effectiveLevel = logLevel;
    }
    levelByteOffset = logLevel & 7;
    if ((int)logLevel < 1) {
      levelByteOffset = -(-logLevel & 7);
    }

    // Test if the log level is enabled for the current category
    if (((int)(uint)*(byte *)(defaultCategoryVariable + ((int)effectiveLevel >> 3) + 0x408) >> (7 - levelByteOffset & 0xff) & 1U) != 0) {
      threadBufferPointer = (int *)pthread_getspecific(specificKey);
      if (threadBufferPointer == (int *)0x0) {
        // If the thread-specific buffer is not set, try to allocate one
        threadBufferPointer = (int *)AllocateThreadBuffer(someGlobalValueVariable, *(undefined4 *)(CONFIG_VAR + 0x41c),
                                        *(undefined4 *)(CONFIG_VAR + 0x420),
                                        *(undefined4 *)(CONFIG_VAR + 0x244c));
        if (threadBufferPointer == (int *)0x0) {
          LogError(2, "src/zlog.c", 0x38d, "Failed to create new thread buffer");
          goto CleanUp;
        }

        // Set the thread-specific buffer
        operationResult = pthread_setspecific(specificKey, threadBufferPointer);
        if (operationResult != 0) {
          FreeBuffer(threadBufferPointer);
          LogError(2, "src/zlog.c", 0x38d, "pthread_setspecific failed, code[%d]", operationResult);
          goto CleanUp;
        }
      }

      if (*threadBufferPointer != someGlobalValueVariable) {
        // Resize the message buffer if needed
        operationResult = ResizeThreadBuffer(threadBufferPointer, *(undefined4 *)(CONFIG_VAR + 0x41c),
                             *(undefined4 *)(CONFIG_VAR + 0x420));
        if ((operationResult != 0) ||
           (operationResult = OtherFunction(threadBufferPointer, *(undefined4 *)(CONFIG_VAR + 0x244c)), operationResult != 0)) {
          LogError(2, "src/zlog.c", 0x38d, "Failed to resize thread message buffer, code[%d]", operationResult);
          goto CleanUp;
        }

        *threadBufferPointer = someGlobalValueVariable;
      }

      // Format the log message and write it to the buffer
      FormatLogMessage(threadBufferPointer[2], defaultCategoryVariable, *(undefined4 *)(defaultCategoryVariable + 0x404),
                       file, line, function, param_4, message, logLevel, param_7, &stack0x0000000c);
      
      // Output the log message
      operationResult = WriteLog(defaultCategoryVariable, threadBufferPointer);
      if (operationResult == 0) {
        if ((*(uint *)(CONFIG_VAR + 0x243c) != 0) &&
           (reloadConfigPeriodVariable += 1, *(uint *)(CONFIG_VAR + 0x243c) < reloadConfigPeriodVariable)) {
          // Unlock and potentially reload configuration after a threshold
          pthread_rwlock_unlock(mutexLockForRW);
          operationResult = ConfigReloadCheck(0xffffffff);
          if (operationResult == 0) {
            return; // If successful reload, return
          }
          LogError(2, "src/zlog.c", 0x3a9,
                   "Reached reload configuration period but failed to reload, check configuration using zlog-chk-conf utility");
          return;
        }
      }
      else {
        // If something goes wrong while trying to output the log, log an error
        LogError(2, "src/zlog.c", 0x396, "Failed to output the log, file[%s], line[%ld]", file,
                 message);
      }
    } // End of log level enabled if-condition
  }

CleanUp:
  // Clean up by unlocking the read-write lock
  pthread_rwlock_unlock(mutexLockForRW);
  return;
}
```