```c
#include <string.h>
#include <stdint.h>

#define BUFFER_SIZE 0x20000
#define DATA_BLOCK_SIZE 0x200
#define INITIAL_DATA_SOURCE 0x0007f588 // Address of the initial data to be copied
#define DATA_DEST_BASE 0x005059e0 // Start address of destination buffers in memory
#define DATA_DEST_OFFSET 0x5259e0 // Offset address for final memcpy

// Copies initial data block into four separate buffers in memory based on the given index
uint32_t CopyInitialDataToBuffers(uint32_t bufferIndex)
{
  uint8_t *destinationBuffer;
  uint8_t *nextBufferPosition;
  uint32_t currentBufferIndex;
  
  // Validate that the bufferIndex is within the acceptable range (0-3)
  if (bufferIndex < 4) {
    currentBufferIndex = 0;
    do {
      // If the current buffer index matches the target buffer index
      if (bufferIndex == currentBufferIndex) {
        // Calculate the start address of the destination buffer
        destinationBuffer = &DATA_DEST_BASE + bufferIndex * BUFFER_SIZE;
        
        // Copy the initial data block until the end of this buffer
        do {
          // Calculate the address for the next data block within the buffer
          nextBufferPosition = destinationBuffer + DATA_BLOCK_SIZE;
          
          // Perform the copy of the initial data block to the current position
          memcpy(destinationBuffer, INITIAL_DATA_SOURCE, DATA_BLOCK_SIZE);
          
          // Move to the next position for the subsequent copy
          destinationBuffer = nextBufferPosition;
        } while (nextBufferPosition != (uint8_t *)(bufferIndex * BUFFER_SIZE + DATA_DEST_OFFSET));
        
        // Special copy for a data block after the main buffer area
        memcpy(&DATA_DEST_BASE + DATA_DEST_OFFSET - BUFFER_SIZE + bufferIndex * DATA_BLOCK_SIZE,
               INITIAL_DATA_SOURCE, DATA_BLOCK_SIZE);
      }
      
      // Increment the buffer index counter and continue if there are more buffers
      currentBufferIndex++;
    } while (currentBufferIndex < 4);
    
    // Return success (0) after completing the operation
    return 0;
  }
  
  // Return an error code (0xFFFFFFFF) if the bufferIndex was out of bounds
  return 0xFFFFFFFF;
}
```

**Comments and modifications**

- Renamed `FUN_0005198c` to `CopyInitialDataToBuffers` for clarity.
- Renamed `param_1` to `bufferIndex` indicating it selects the target buffer to operate on.
- Renamed `__dest` to `destinationBuffer` to clarify that it's a pointer to the destination in memory.
- Renamed `puVar1` to `nextBufferPosition` to describe its role in pointing to the next buffer position.
- Renamed `uVar2` to `currentBufferIndex` to more clearly represent the index of the buffer being considered in the loop.
- Defined constants with descriptive names for magic numbers (addresses and sizes).
- Modified variable types to standard types (e.g., `undefined4` to `uint32_t`, `undefined` to `uint8_t`).
- Added comments to describe the purpose of each step within the function.
- Used pointer arithmetic for buffer position calculations.
- Changed `do {...} while` loops to better indicate the purpose of looping through indexes and memory positions.
- Ensured that all return types match the standard `uint32_t` type instead of `undefined4`.
- The given addresses for `DATA_DEST_BASE` and `INITIAL_DATA_SOURCE` are placeholders and should be replaced with the actual memory addresses from the decompiled ARM binary.