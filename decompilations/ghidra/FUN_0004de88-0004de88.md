```c
// Decode UTF-8 encoded character from the given buffer and store the Unicode code point
// Returns 1 if successful, 0 if the buffer does not contain a valid UTF-8 sequence
// param_1: Pointer to buffer containing UTF-8 bytes
// param_2: The maximum number of bytes to read (2, 3, or 4 for valid UTF-8 sequence lengths)
// param_3: Pointer to store the decoded Unicode code point (if decoding is successful)
unsigned int decodeUtf8Character(byte *utf8Buffer, unsigned int maxBytes, unsigned int *unicodeOut)
{
  unsigned int firstByteValue;
  unsigned int continuationByteValue;
  unsigned int unicodeValue;
  bool isInvalidSequence;
  
  // Get the value of the first byte
  unicodeValue = (unsigned int)*utf8Buffer;

  // Mask the value based on the max number of bytes allowed for the sequence
  if (maxBytes == 2) {
    unicodeValue &= 0x1f; // For 2-byte sequence, consider only 5 least significant bits
  }
  else if (maxBytes == 3) {
    unicodeValue &= 0xf;  // For 3-byte sequence, consider only 4 least significant bits
  }
  else if (maxBytes == 4) {
    unicodeValue &= 7;    // For 4-byte sequence, consider only 3 least significant bits
  }
  else {
    return 0; // Invalid sequence length
  }

  // Process continuation bytes
  continuationByteValue = (unsigned int)utf8Buffer[1];
  if ((continuationByteValue ^ 0x80) < 0x40) { // Check if continuation byte starts with 10xxxxxx
    utf8Buffer++; // Move buffer pointer to next byte
    unsigned int bytesRead = 1;
    do {
      bytesRead++; // Increment the number of bytes read
      // Calculate Unicode value using continuation byte
      unicodeValue = (continuationByteValue & 0x3f) + unicodeValue * 0x40;
      if (maxBytes <= bytesRead) {
        // Check for overlong sequences or invalid code points
        if (unicodeValue > 0x10ffff) return 0; // Beyond Unicode range
        if (unicodeValue - 0xd800 < 0x800) return 0; // UTF-16 surrogate halves are not valid code points
        // Validate boundaries based on the expected length of the UTF-8 sequence
        isInvalidSequence = unicodeValue == 0x7f;
        if ((int)unicodeValue < 0x80) {
          // For a 2-byte sequence, it should represent code points from 0x80 to 0x7FF
          isInvalidSequence = maxBytes == 2;
        }
        if (isInvalidSequence) return 0;
        if ((int)unicodeValue < 0x800 && maxBytes == 3) return 0; // 3-byte sequence should start from 0x800
        if ((int)unicodeValue < 0x10000 && maxBytes == 4) return 0; // 4-byte sequence should start from 0x10000
        
        // If output pointer is given, update it with the decoded Unicode value
        if (unicodeOut != NULL) {
          *unicodeOut = unicodeValue;
        }
        return 1; // Decoding successful
      }
      // Read next continuation byte
      utf8Buffer++;
      continuationByteValue = (unsigned int)*utf8Buffer;
    } while ((continuationByteValue ^ 0x80) < 0x40); // Check if indeed a continuation byte
  }
  return 0; // Invalid UTF-8 sequence
}
```
