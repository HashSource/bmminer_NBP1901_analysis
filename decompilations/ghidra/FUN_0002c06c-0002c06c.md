```c
uint readAsicRegister(uint chainId, uint chipId, uint regId)
{
  int readAttempts;
  int timeoutRetryCount;
  uint readValue;
  uint extractedValue;
  int matchedIndex;
  int maxReads;
  char logMessageBuffer[2052];
  
  timeoutRetryCount = 5; // Retry count if timeout occurs
  pthread_mutex_lock(&asicCommunicationMutex); // Lock ASIC communications mutex
  do {
    maxReads = 8; // Number of maximum register read attempts
    performHwCommunicationInitialStep(); // Some initial hardware communication step

    // Issue the command to read from ASIC's register
    sendAsicReadCommand(regId & 0xff, 0, chipId & 0xff, chainId & 0xff);

    do {
      delay(10); // Wait for 10ms
      pthread_mutex_lock(&responseQueueMutex); // Lock the response queue

      // If there are responses in the queue, process them
      if (responsesInQueue != 0) {
        matchedIndex = 0;
        
        /* Process the queue until we find a matching response or the queue is empty */
        do {
          responsesInQueue--;
          matchedIndex++;
          extractedValue = (responseBufferWriteIndex + 1) % MAX_RESPONSES;

          // Each response is 8 bytes, calculate the offset
          int responseOffset = extractedValue * 8;
          if (extractedValue < MAX_RESPONSES) {
            responseBufferWriteIndex = extractedValue;
          }

          // Extract the response details (chain, chip, reg)
          readValue = (uint)*(byte *)(responseBufferStart + responseOffset + 3);
          if ((readValue == regId) &&
              (*(byte *)(responseBufferStart + responseOffset + 1) == chipId) &&
              (*(byte *)(responseBufferStart + responseOffset + 2) == chainId)) {

            // If it is the desired register, extract the value and return
            if (chainId == SPECIFIC_REGISTER) {
              extractedValue = responseBuffer[(extractedValue * 2) + 1];
              if ((extractedValue & 0xE0000000) != 0) {
                // Invalid value detected, reset to zero
                extractedValue = 0;
              }
              pthread_mutex_unlock(&responseQueueMutex);
              performHwCommunicationFinalStep();
              pthread_mutex_unlock(&asicCommunicationMutex);
              return extractedValue;
            }

            // Return the register value for non-specific register IDs
            pthread_mutex_unlock(&responseQueueMutex);
            performHwCommunicationFinalStep();
            pthread_mutex_unlock(&asicCommunicationMutex);
            return responseBuffer[(extractedValue * 2) + 1];
          }

          // If verbose logging is enabled, log the mismatch error
          if (verboseLoggingLevel > 3) {
            snprintf(logMessageBuffer, 0x800,
                     "read asic reg error: expect chain = %d, chip = %d, reg = %d, got chain = %d, chip = %d, reg = %d\n",
                     regId, chipId, chainId, readValue,
                     (uint)*(byte *)(responseBufferStart + extractedValue * 8 + 1),
                     (uint)*(byte *)(responseBufferStart + extractedValue * 8 + 2));
            logError(3, logMessageBuffer, 0);
          }
        } while (maxReads != matchedIndex);
      }

      // Unlock the response queue after processing
      pthread_mutex_unlock(&responseQueueMutex);
      maxReads--;

    } while (maxReads != 0);

    // A retry for timeout scenario
    timeoutRetryCount--;

    // If timeoutRetry attempts are exhausted, log and exit
    if (timeoutRetryCount == 0) {
      if (verboseLoggingLevel > 4) {
        snprintf(logMessageBuffer, 0x800,"read asic reg timeout: expect chain = %d, chip = %d, reg = %d\n",
                 regId, chipId, chainId);
        logError(4, logMessageBuffer, 0);
      }
      performHwCommunicationFinalStep();
      pthread_mutex_unlock(&asicCommunicationMutex);
      return 0; // Return zero to indicate failure
    }
  } while (true);
}
```

**Please note:** For a dependable reconstruction, it's crucial to have more context like header definitions, related functions (`performHwCommunicationInitialStep`, `sendAsicReadCommand`, etc.), constants (`SPECIFIC_REGISTER`, `MAX_RESPONSES`, etc.), and variable declarations (`responseBuffer`, `responsesInQueue`, `responseBufferWriteIndex`, `responseBufferStart`, `asicCommunicationMutex`, `responseQueueMutex`, `verboseLoggingLevel`). This example assumes those would be available in the actual code, which must be provided for a precise conversion.