```c
void InitializeChainTests(void)
{
  int chainIndex;
  int chainTestPassed;
  int retryCount;
  char errorMessageBuffer[2052];
  int numOfAsics;
  int asicIndex;
  int coreIndex;
  int result;
  int numOfWorkingCores;
  int numOfWorkingAsics;
  unsigned int dataIndex;

  chainIndex = 0;
  chainTestPassed = 0;
  GetChainTestConfiguration();

  // Start testing chains
  do {
    numOfAsics = GetNumberOfAsics(chainIndex);
    if (numOfAsics != 0) {
      retryCount = 0;

      // Send test work to the chain
      SendTestWorkToChain(chainIndex,1,0,global_testWorkConfig);

      do {
        global_flagChainTesting = 1;
        ResetTestResultsBuffer(chainIndex);
        numOfAsics = GetNumberOfAsics();

        if (numOfAsics > 0) {
          asicIndex = 0;

          // Loop through each ASIC to perform tests
          do {
            CalculateTestWork(chainIndex, asicIndex);
            ResetTestProgressMarker();
            
            do {
              // Lock access to shared test results buffer
              pthread_mutex_lock(&mutex_testResultsBuffer);

              result = global_testResultsCounter;
              if (result > 0) {
                dataIndex = 0;
                do {
                  global_testResultsCounter = global_testResultsCounter - 1;
                  dataIndex = dataIndex + 1;

                  UpdateResultIndex();

                  coreIndex = CalculateCoreIndex(resultIndex);
                  
                  // If the result belongs to our chain
                  if (IsResultFromCurrentChain(resultBuffer[resultIndex], chainIndex)) {
                    StoreTestResult(resultBuffer[resultIndex], chainIndex, coreIndex);
                  }
                } while (result != dataIndex);
              }
              // Release the lock
              pthread_mutex_unlock(&mutex_testResultsBuffer);

              usleep(1000); // Sleep for a short period
              CheckTestProgress(errorMessageBuffer);
              result = CheckTestCompletion(errorMessageBuffer, testProgressMarker);
            } while (result < 100);
            
            // Move to the next ASIC
            asicIndex = asicIndex + 1;
          } while (numOfAsics != asicIndex);
        }

        numOfAsics = GetNumberOfAsics();
        if (numOfAsics < 1) {
          // Test did not pass for all ASICs
          if (global_debugLevel > 3) {
            numOfWorkingAsics = 0;
          }
          else {
            numOfWorkingAsics = 0;
            goto SKIP_RETRY;
          }
          snprintf(errorMessageBuffer, 0x800, "bad count is acceptable = %d", numOfWorkingAsics); // Log message
          LogToDebug(3, errorMessageBuffer, 0);
          usleep(1000000); // Wait before retrying
          break;
        }

        // Test can fail if results are missing â€“ retry logic
        numOfWorkingCores = 0;
        asicIndex = 0;
        numOfWorkingAsics = 0;
        do {
          result = CheckAsicResult();

          if (result > 0) {
            coreIndex = 0;
            short *coreResultPointer = GetCoreResultPointer(chainIndex, asicIndex);
            do {
              // Check the test result for the core
              CheckCoreTestResult(coreResultPointer, chainIndex, coreIndex, &numOfWorkingCores, errorMessageBuffer);
              coreResultPointer = coreResultPointer + 2;
            } while (result != coreIndex);

            // If there was a problematic core, reset the ASIC
            if (IsAsicResetNecessary()) {
              ResetAsic(chainIndex, asicIndex);
            }
          }
          asicIndex = asicIndex + 1;
        } while (numOfAsics != asicIndex);

        // Log the results for debugging purposes
        if (global_debugLevel > 3) {
          retryCount = retryCount + 1;
          snprintf(errorMessageBuffer, 0x800, "chain %d, bad core num %8d, rate = %.2f ========================round %d",
                   chainIndex, numOfWorkingCores);
          LogToDebug(3, errorMessageBuffer, 0);
        }

        if (numOfWorkingCores < 0x9c) {
SKIP_RETRY: // Skip further retries if the core count is acceptable
          usleep(1000000);
          if (retryCount > 1) {
            chainTestPassed = 0;
          }
        }
      } while (chainTestPassed); // Repeat if the test did not pass
    }

    chainIndex = chainIndex + 1;
    chainTestPassed = chainTestPassed + 0x100;

    // If all chains have been tested, exit the loop
    if (chainIndex == 4) {
      global_flagChainTesting = 0;
      FinalizeChainTests();
      return;
    }
  } while (true);
}
```