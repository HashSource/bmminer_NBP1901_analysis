```c
#include <pthread.h>
#include <unistd.h>
#include <sys/prctl.h>
#include <stdlib.h>

// PR_SET_NAME constant for setting thread name
#define PR_SET_NAME 0xf

// Thread data structure and function prototypes for handling work.
typedef struct ThreadData {
  void (*processWorkItem)(struct ThreadData *, int *); // Function for processing a work item
  int *(*fetchWorkItem)(void);  // Function to get next work item
  void (*finalizeWorkItem)(void *);  // Function to finalize a work item processing
  // ... other members would be here ...
} ThreadData;

// Global indicator for thread operation ongoing status
extern int ThreadOperational;

// Pseudo global data, extracted for symbolic representation
extern pthread_mutex_t OperationMutex;
extern char ThreadName[16]; // Normally 16-bytes space for thread name

int WorkerThreadFunction(void) {
  int operationResult;
  ThreadData *threadData;
  int *workItem;
  int workStatus;
  int adjustedStatus;
  int workItemId;
  int workItemCompleted;

  // Set thread name
  prctl(PR_SET_NAME, ThreadName, 0, 0, 0);

  while (ThreadOperational != 0) {
    operationResult = pthread_mutex_lock(&OperationMutex);
    if (operationResult == 0) {
      threadData = (ThreadData *)GetThreadDataFunction(ThreadOperational);
      operationResult = ProcessNextWorkItem(threadData);
      while (operationResult != 0) {
        workItem = (int *)(*threadData->fetchWorkItem)();
        workStatus = workItem[1];
        if (workStatus == 0) {
          // Here it could be processing a specific work item based on ID or type
          LOG_WORK_COMPLETED(*(undefined4 *)*(*(undefined4 **)(threadData->finalizeWorkItem + 0x10)),
                             *(undefined *)(workItem + 2));
          workItemId = *workItem;
          workItemCompleted = workItem[2] - 1;
          if (workItemCompleted != 0) {
            workItemCompleted = 1;
          }
          workItem[2] = workItemCompleted;
          operationResult = workItemId;
        }
        else {
          workItemId = *workItem;
          workItemCompleted = workItem[2];
        }
        adjustedStatus = workStatus - 200;
        workItem[1] = adjustedStatus;  // Here the status of work item is adjusted for some purpose
        threadData->processWorkItem(threadData, &workItemId); // Process work item
        free(workItem); // Free the memory allocated for workItem
        operationResult = ProcessNextWorkItem(threadData); // Check for next work item
      }
      free(threadData); // Free the memory allocated for thread data
      pthread_mutex_unlock(&OperationMutex); // Unlocking the mutex
    }
    usleep(200000); // Wait for 200ms before next iteration
  }
  return 0;
}
```

Please note that the above decompiled code lacked sufficient context to accurately rename all functions, variables, and data structures. The names have been chosen to provide a clearer understanding of what the decompiled code's intent might be, but they might need to be adapted for the exact context of the original application. Some assumptions have been made about the functionality based on typical patterns used in embedded systems and multithreaded applications.