```c
// Global mutex used for I2C bus access
pthread_mutex_t gI2cBusMutex = DAT_005051a8;

// Read the temperature from the temperature sensor chip
int ReadTemperatureSensorChip(uint32_t sensorId, int numBytesToRead, int bufferOffset) {
    int sensorAddress;
    int bitShiftValue;
    uint32_t i2cDataRegister;
    char errorMessageBuffer[2084];
    
    // Lock the mutex before accessing the I2C bus
    int* lockResult = pthread_mutex_lock(&gI2cBusMutex);

    if (lockResult == 0) {
        // Find sensor address and prepare for reading
        int initializationResult = InitializeI2cRead(DAT_005051a4, sensorId, &sensorAddress);
        if (initializationResult == 1) {
            sensorAddress = *sensorAddressPointer;
            bitShiftValue = sensorAddressPointer[1];
            if (bufferOffset != 0) {
                // Read the specified number of bytes from the temperature sensor chip
                while (bufferOffset < numBytesToRead) {
                    if (!PrepareTemperatureReading(sensorAddress)) {
                        free(sensorAddressPointer);
                        SetError(errorMessageBuffer, "iic_not_ready_4_read1", sizeof(errorMessageBuffer));
                        LogError(0, errorMessageBuffer);
                        pthread_mutex_unlock(&gI2cBusMutex);
                        return -2;
                    }

                    // Write I2C data to the configured register
                    WriteI2CData(0xc, sensorAddress << 0x1a | 0x2000000 | (bitShiftValue >> 4) << 0x14 | (bitShiftValue & 0xe) << 0xf);

                    // Check if more data needs to be read
                    bufferOffset = ReadNextTemperatureByte(bufferOffset);
                    if (bufferOffset == 0) {
                        free(sensorAddressPointer);
                        SetError(errorMessageBuffer, "iic_not_ready_4_read2", sizeof(errorMessageBuffer));
                        LogError(0, errorMessageBuffer);
                        pthread_mutex_unlock(&gI2cBusMutex);
                        return -3;
                    }
                }
            }

            // Cleanup and release the mutex
            free(sensorAddressPointer);
            pthread_mutex_unlock(&gI2cBusMutex);
            return numBytesToRead;
        }

        // Log initialization error for the sensor
        snprintf(errorMessageBuffer, sizeof(errorMessageBuffer), "ctx %d not inited\n", sensorId);
        LogError(0, errorMessageBuffer);
        pthread_mutex_unlock(&gI2cBusMutex);
        return -2;
    } else {
        // Failed to lock the I2C bus mutex
        SetError(errorMessageBuffer, "failed_to_i2c_lock", sizeof(errorMessageBuffer));
        LogError(0, errorMessageBuffer);
        return -1;
    }
}
```

**Note:** Since the original decompiled code contained potentially missing symbols or incorrectly decompiled constructs, the above code fills in with assumptions about what the original source might have looked like, applying meaningful names and proper type conversion where necessary. Some functions, like `InitializeI2cRead`, `PrepareTemperatureReading`, `WriteI2CData`, `ReadNextTemperatureByte`, `SetError`, and `LogError` are not defined in the snippet you provided and are used as placeholders to describe the high-level functionality that one can infer from the context. The variables `DAT_005051a4` and various error message strings like `iic_not_ready_4_read1` were also not defined, so they have been left unchanged pending additional information.