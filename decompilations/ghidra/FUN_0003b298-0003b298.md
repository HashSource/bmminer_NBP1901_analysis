```c
#include <stdint.h>
#include <stddef.h>
#include <string.h>
#include <stdio.h>

// Global variable definitions (assuming they're located elsewhere)
extern uint32_t _loggingLevel; // Example for DAT_0007eb9c
extern uint32_t _unknownGlobalVarCounter; // Example for unique0x10000236
extern int *_minerConfig; // Example for DAT_004fcb40
extern float _someThresholdValue; // Example for DAT_0007edd0
extern char *_debugStringArea; // Example for DAT_00482a70
extern uint32_t _someFrequencyControlVar; // Example for DAT_0007eb58

// Logging message strings (renamed based on context clues)
// Actual strings are not provided so these are placeholders
extern char *logMsg_freqTuning_basic;
extern char *logMsg_DoTuning_parallel;
extern char *logMsg_AllReadyChainDone_exit;
extern char *logMsg_SetVoltageFailed_exit;

// Function prototypes (renamed based on context clues or left as is)
int CheckAllChainsStatus();
int InitializeASICs(int param_1);
int UpdateASICFrequency();
int TriggerASICOperations();
int SetASICVoltage(float voltage, uint8_t target, char* debug_area, uint8_t debug_param);
void LogMessage(int log_level, char *message, ...);
int SendASICConfiguration(int chain_index);
int SetChainActive(int chain_index, int param_2);
int ReadASICResult(int chain_index);
int GetASICPerformanceMetric(int chain_index);
void ConfigureASICFrequency(uint32_t frequency, uint32_t control_var);
void CheckFrequencies(uint32_t *frequency);
int ComparePerformanceMetrics(int chain_index, int metric);

// Renamed function with added comments for clarity
int PerformFrequencyTuning(int target_frequency)
{
  uint32_t current_frequency;
  int result;
  int iVar3;
  int chain_index;
  int iVar5;
  int iVar6;
  float **ppfVar7;
  uint32_t uVar8;
  float **ppfVar9;
  int frequency_step;
  uint32_t uVar11;
  int *miner_config_ptr;
  bool condition;
  float fVar14;
  float *performance_metric_ptr;
  float fVar16;
  uint32_t frequency_min_threshold;
  uint32_t local_964 [15];
  float *apfStack_928 [60];
  char local_printf_buffer[2048]; // Placeholder for an array of undefined4
  uint32_t frequency_lower_bound; // Placeholder for local_968
  
  if (_loggingLevel > 3) {
    // Log this function call if the logging level is higher than 3
    LogMessage(3, logMsg_freqTuning_basic, 0);
  }
  miner_config_ptr = _minerConfig;
  memset(_minerConfig + 1,0,0x30); // Clearing part of the _minerConfig memory
  *miner_config_ptr = target_frequency; // Store the target frequency in the config
  CheckAllChainsStatus(); // Placeholder for FUN_00039a7c
  InitializeASICs(*(_minerConfig)); // Initialize ASICs with the first value in miner config
  result = UpdateASICFrequency(); // Update frequency and check the result
  if (result == 0) { // If update was successful
    SetASICVoltage((float)(uint32_t)*(_minerConfig + 1),0xff,_debugStringArea,
                 *(_minerConfig + 5)); // Set ASIC voltage based on config
    // Additional logging if needed
    if (_loggingLevel > 3) {
      LogMessage(3, logMsg_DoTuning_parallel, 0);
    }
    result = 0;
    chain_index = 0;
    while (chain_index < 4) {
      // Check status of each chain and activate it if not already active
      condition = SendASICConfiguration(chain_index) != 0;
      if (condition) {
        SetChainActive(chain_index,1);
      }
      chain_index++;
    }
    int config_base = *_minerConfig;
    uint32_t initial_frequency = *(uint32_t *)(config_base + 4);
    int frequency_start = *(int *)(config_base + 16);
    frequency_step = *(uint32_t *)(config_base + 12);
    frequency_lower_bound = initial_frequency; // This is the initial frequency
    frequency_min_threshold = frequency_start; // This is the minimum threshold for frequency

    // Log the current frequency parameters, if logging level is high enough
    if (_loggingLevel > 3) {
      LogMessage(3, "freq_prev = %d, freq_start = %d, freq_step = %d, freq_min = %d\n",
        initial_frequency, initial_frequency, frequency_start, frequency_step);
    }

    if (initial_frequency < frequency_step) {
      frequency_step = 0;
      result = 0;
    }
    else {
      // Loop over frequency values, tuning each ASIC chain and assessing performance
      
      /* ... The loop continues with additional logic related to ASIC tuning,
         individual performance checks per chain, and updating best frequency ... */
         
      // Check the performance of each ASIC chain and store the best frequency per chain
      for (chain_index = 0; chain_index < 4; chain_index++) {
        iVar4 = ReadASICResult(chain_index); // Check status of the ASIC chain
        if (iVar4 != 0) {
          // Store the best frequency for the ASIC chain based on performance metrics
          
          /* Additional logging and processing logic... */
        }      
      } // End of ASIC chain checking loop
    }
  } // End of the frequency update successful block

  return result; // Return the result of the tuning operation
}
```