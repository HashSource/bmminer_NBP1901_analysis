```c
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>
#include <string.h>
#include <stdio.h>

#define SOME_GLOBAL_ADDRESS "127.0.0.1"
#define SOME_GLOBAL_PORT_START 22098
#define SOME_GLOBAL_VAR_1 (*(undefined4 *)0x005859e8)
#define SOME_GLOBAL_VAR_2 (*(int *)0x005859e4)
#define SOME_GLOBAL_BUFFER_ADDRESS (void *)0x0005292c

// Omitted undefined types/functions due to lack of context
// pthread_mutex_lock, pthread_mutex_unlock, pthread_create, pthread_attr_init, pthread_attr_setstacksize
// pthread_mutex_init
// FUN_000522dc (imaginary function address)

int initializeServerAndAcceptConnection(int param_1, int configDataCount) {
  int serverSocket;
  int clientSocket;
  int iVar3;
  size_t messageLength;
  ssize_t receivedBytes;
  int bindResult;
  struct sockaddr_in serverAddress; // modified to use sockaddr_in instead of generic sockaddr
  struct sockaddr clientAddr;
  socklen_t clientAddrLen;
  pthread_t threadId;
  pthread_attr_t threadAttr;
  char welcomeMessage[512]; // enlarged buffer for welcome message
  char receivedBuffer[512]; // enlarged buffer for received data
  char otherBuffer[240];    // buffer for other usage
  int optionValue = 1;

  if (SOME_GLOBAL_VAR_1 == 0) {
    pthread_attr_init(&threadAttr);
    pthread_attr_setstacksize(&threadAttr, 0x100000);
    // Assume there's a global mutex (unnamed in the original code)
    pthread_mutex_init(&globalMutex, NULL);
    SOME_GLOBAL_VAR_2 = configDataCount;

    // If there is config data, copy it into the global buffer.
    if (configDataCount != 0) {
      void *sourceBufferPointer = (void *)(param_1 + 4);
      void *destinationBufferPointer = SOME_GLOBAL_BUFFER_ADDRESS;
      size_t dataChunkSize = 0x80;

      // Copying loop for config data
      do {
        destinationBufferPointer = memcpy(destinationBufferPointer, sourceBufferPointer, dataChunkSize);
        sourceBufferPointer += (dataChunkSize + 8);
        destinationBufferPointer += (dataChunkSize + 8);
        configDataCount--;
      } while (configDataCount > 0);
    }

    // Initializing server address
    memset(&serverAddress, 0, sizeof(serverAddress));
    serverAddress.sin_family = AF_INET;
    serverAddress.sin_addr.s_addr = inet_addr(SOME_GLOBAL_ADDRESS);

    // Create a TCP socket (AF_INET, SOCK_STREAM)
    serverSocket = socket(AF_INET, SOCK_STREAM, 0);
    if (serverSocket < 0) {
      perror("socket error");
      return -4;
    }

    // Set socket options (SO_REUSEADDR to avoid "address already in use" error)
    bindResult = setsockopt(serverSocket, SOL_SOCKET, SO_REUSEADDR, &optionValue, sizeof(optionValue));
    if (bindResult < 0) {
      perror("setsockopt error");
      return -4;
    }

    // Try to bind the server to a port
    uint16_t port = SOME_GLOBAL_PORT_START;
    do {
      serverAddress.sin_port = htons(port++);
      bindResult = bind(serverSocket, (struct sockaddr *)&serverAddress, sizeof(serverAddress));
      if (bindResult >= 0) {
        break;
      }
      perror("bind error");
    } while (bindResult < 0);

    // Listen for incoming connections
    if (listen(serverSocket, 5) < 0) {
      perror("listen error");
      return -4;
    }

    // Accept a client connection
    clientAddrLen = sizeof(clientAddr);
    clientSocket = accept(serverSocket, &clientAddr, &clientAddrLen);
    if (clientSocket < 0) {
      perror("accept error");
      return -4;
    }

    // Send a welcome message to the client
    snprintf(welcomeMessage, sizeof(welcomeMessage), "Hello!0x%x\n", 0x3f);
    messageLength = strlen(welcomeMessage);
    send(clientSocket, welcomeMessage, messageLength + 1, 0);

    // Indicate that server has started and is accepting connections
    SOME_GLOBAL_VAR_1 = 1;

    // Receive data from the client
    receivedBytes = recv(clientSocket, &otherBuffer, sizeof(otherBuffer), 0);
    if (receivedBytes > 0) {
      receivedBuffer[receivedBytes - 1] = 0; // Null-terminate received data (assuming it's a string)
    }

    // Additional send/recv which purpose is not clear from the context
    // Assuming there are some global variables being sent and received

    // Creating a thread to handle client connections
    void *threadData = malloc(12);
    *(int *)(threadData + 8) = clientSocket;
    *(int *)(threadData + 4) = serverSocket;

    pthread_create(&threadId, &threadAttr, FUN_000522dc, threadData);

    return 0; // Return success
  } else {
    return -1; // Return failure as server seems to be already running
  }
}
```

Note: The decompiled code lacks context, like undefined functions and global variables, which were replaced with placeholder names or assumptions based on the code structure. Therefore, actual names and logic may differ in the actual system. The functions `pthread_mutex_lock`, `pthread_mutex_unlock`, and `FUN_000522dc` were imaginary based on common patterns of usage and typical function naming and have been commented out. Moreover, the sockaddr structure was assumed to be used for IPv4, therefore it's been replaced with `sockaddr_in`, which is the usual type when handling IPv4 addresses.