```c
/* The following warnings indicate that there were blocks of code that Ghidra determined were not reachable. 
As these are within the RAM address space they suggest that the code may have been optimized out or
is otherwise not used in this context. This could be due to compiler optimizations or conditional 
compilation that was not active for the configuration that was being analyzed. */

/* WARNING: Removing unreachable block (ram,0x00014d0c) */
/* WARNING: Removing unreachable block (ram,0x00014d18) */

int GetTemperatureSensorValue(int sensorIndex, int sensorChannel) {
  short sensorValue;
  int statusCheck;
  
  // Check the hardware communication status
  statusCheck = CheckCommStatus();
  if (statusCheck == 0) {
    // If the status is good, then read the raw sensor value
    statusCheck = ReadRawSensorValue(sensorIndex, sensorChannel);
    if (statusCheck != 0xff) {
      // If the value is valid, return the calibrated value
      return (int)(short)((short)statusCheck + 0xf);
    }
    // Return a failed status if the raw value is invalid
    return 0xff;
  }
  // Another check on the hardware communication status
  statusCheck = CheckCommStatus();
  // Check if the status is non-zero, the sensor channel is within an expected range,
  // and some global pointers are not null.
  if (((statusCheck != 0) && (statusCheck = GetMaxSensorChannels(), sensorChannel < statusCheck)) &&
     (GlobalSensorPointer1 != NULL) && (GlobalSensorTablePointer != NULL)) {
    // Lock the mutex before accessing shared data
    pthread_mutex_lock(GlobalSensorDataMutex);
    // Retrieve the sensor value from a global data structure
    sensorValue = *(short *)(*(int *)(*(int *)(GlobalSensorTablePointer + sensorIndex * 4) + 8) + sensorChannel * 6 + 2);
    // Unlock the mutex after accessing the shared data
    pthread_mutex_unlock(GlobalSensorDataMutex);
    // Return the retrieved sensor value
    return (int)sensorValue;
  }
  // Return a failed status if the status is zero or other checks fail
  return 0xff;
}
```

Please note that I've made an informed guess that the original `FUN` and `DAT` prefixes indicate function and data pointers, respectively, in the original binary. Moreover, the ending `a0` and `f0` are likely offsets of these functions in the binary. I have replaced these with names that describe their apparent functionality based on the context provided. Additionally, magic numbers like `0xf` and `0xff` are left as they are, since their actual meaning or use is not clear from this snippet. Comments have been added to clarify the flow and the purpose of each code section.