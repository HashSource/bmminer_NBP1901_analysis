```c
/* Global variable used to indicate if initialization has been done */
extern int _isInitializationDone;

/* Global variable for mutex */
extern pthread_mutex_t _gpioControlMutex;

/* Global handlers for threads and synchronization (Note: Names are guessed based on usage) */
extern int _syncHandler;
extern int _threadHandler;
extern int _shouldThreadRun; 

/* Function prototypes (Note: Names are guessed based on behavior) */
void InitializeSyncObjects();
void _LogErrorAndExit(const char *errorMessage);
void CreateControlThread();
void SendMessageToThread(int message);
void LockMutexOrLogError(pthread_mutex_t *mutex);

/* WARNING: Function Rename and comments added for better understanding */
int ControlGPIO(unsigned int controlCode, int parameter)
{
  int lockResult;
  int messageResult;
  char localBuffer[2048]; // Buffer used for different purposes within the function
  
  if (parameter == 0) {
    strcpy(localBuffer, "bad_param");
    _LogErrorAndExit(localBuffer);
    return -1;
  } else {
    if (_isInitializationDone == 0) {
      InitializeSyncObjects(); // Initializes mutex and other synchronization objects
      CreateControlThread(); // Creates the thread that will handle control actions
      _isInitializationDone = 1;
    }
    lockResult = pthread_mutex_lock(&_gpioControlMutex);
    if (lockResult == 0) {
      messageResult = SendMessageToThread(controlCode);
      if (messageResult == 0) {
        *((int*)localBuffer) = parameter; // Set the parameter at the beginning of the buffer
        *((int*)(localBuffer+4)) = 0xffffffff; // Some kind of flag or secondary parameter
        // Sending a message to the thread handler for GPIO control with the parameter and additional data
        SendMessageToThread(controlCode, &localBuffer, 4, localBuffer + 4, 8);
      }
      pthread_mutex_unlock(&_gpioControlMutex);
      return 0;
    } else {
      strcpy(localBuffer, "fail_to_lock_gpio_ctrl_mutex");
      _LogErrorAndExit(localBuffer);
      return -1;
    }
  }
}

/* Placeholder function implementation for demonstration */
void InitializeSyncObjects() {
  /* Init code for synchronization objects like mutexes and signals */
}

void _LogErrorAndExit(const char *errorMessage) {
  /* This would log the error message and terminate the process, or handle the error as configured */
}

void CreateControlThread() {
  /* Code to create and start a new thread that would handle control commands */
}

int SendMessageToThread(int message) {
  /* Code that sends a message to a control thread and waits/synchronizes based on the system's needs */
  return 0; // Placeholder return value, actual implementation will differ
}

void LockMutexOrLogError(pthread_mutex_t *mutex) {
  /* This function would attempt to lock a mutex and log an error if it fails */
}
```