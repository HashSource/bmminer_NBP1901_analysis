```c
#include <pthread.h>
#include <string.h>
#include <stdio.h>
#include <stdint.h>
#include <unistd.h>

// Define UART management constants
#define UART_CHAIN_ID_MULTIPLIER 0x18 
#define UART_BASE_ADDRESS 0x504ce8
#define UART_STATUS_MSG_SIZE 2048
#define UART_SEND_BUFFER_SIZE 256

// Global variable, placeholder for actual global data string used in logging
extern char gLogDataPlaceholder[];

// Function declarations (signatures), these functions should be defined elsewhere
int GetSendAddressInfo(int chainId, uint32_t* fifoSpace, uint32_t* sendAddress, 
                       uint32_t* interruptRegister, uint32_t* fifoRegister);
void WriteToRegister(uint32_t registerAddress, uint32_t value);
int WaitForStatus(uint32_t registerAddress, uint32_t* status);
void WriteDataToRegister(uint32_t registerAddress, uint32_t value);

// Function for sending UART data
uint SendUARTData(int chainId, void *dataToSend, uint dataSize)
{
  pthread_mutex_t *chainMutex;
  uint fifoAvailableSpace;
  int32_t retVal;
  uint dataSizeWithFlag;
  byte dataBuffer[UART_SEND_BUFFER_SIZE];
  char statusMessage[UART_STATUS_MSG_SIZE];
  
  // Initialize local variables
  memset(dataBuffer, 0, UART_SEND_BUFFER_SIZE);
  uint32_t sendAddress = 0, interruptRegister = 0, fifoRegister = 0, fifoSpaceIndicator = 0;
  
  // Calculate the mutex address based on chain ID
  chainMutex = (pthread_mutex_t *)(chainId * UART_CHAIN_ID_MULTIPLIER + UART_BASE_ADDRESS);
  
  // Get the status of the UART send addresses before acquiring the lock
  pthread_mutex_lock(chainMutex);
  retVal = GetSendAddressInfo(chainId, &fifoSpaceIndicator, &sendAddress, 
                              &interruptRegister, &fifoRegister);

  // If getting the send address info failed, log the error and return
  if (retVal != 0) {
    snprintf(statusMessage, UART_STATUS_MSG_SIZE, "GetSendAddressInfo error, chain_id = %d\n", chainId);
    WriteToRegister(0, statusMessage); // Placeholder for actual logging function
    pthread_mutex_unlock(chainMutex);
    return 0;
  }

  // Wait until enough space is available in the FIFO to send the data
  retVal = 0x15; // Set the initial retry count
  do {
    // Check how much space is available in the FIFO
    WaitForStatus(sendAddress, &fifoAvailableSpace);
    
    // Shift and mask the FIFO space indicator to get the actual space available
    fifoAvailableSpace = (fifoAvailableSpace >> (fifoSpaceIndicator & 0xFF)) & 0xFF;
    
    // If there's enough space for the data, proceed to send
    if (dataSize <= fifoAvailableSpace) {
      retVal = 0x16; // Set the initial retry count for sending data
      do {
        // Check the FIFO status
        WaitForStatus(interruptRegister, &fifoAvailableSpace);
        
        // If the FIFO is ready to send data, write the data to the buffer
        if (fifoAvailableSpace >= 0) {
          memcpy(dataBuffer, dataToSend, dataSize); // Copy data to the local buffer
          for (uint i = 0; i < (dataSize & 0xFFFFFFFC); i += 4) {
            uint32_t dataPiece = 0;
            // Copy 4 bytes from the data buffer to the dataPiece in reverse order
            dataPiece = (uint32_t)dataBuffer[i] << 24 |
                        (uint32_t)dataBuffer[i + 1] << 16 |
                        (uint32_t)dataBuffer[i + 2] << 8 |
                        (uint32_t)dataBuffer[i + 3];

            // Write the copied data piece to the register
            WriteDataToRegister(fifoRegister, dataPiece);
          }

          // Handle potential remaining bytes that didn't fit into a 4-byte piece
          dataSizeWithFlag = (dataSize & 0xFFFFFFFC);
          if (dataSize & 3) { // If there are 1, 2, or 3 bytes left
            uint32_t tailData = 0;
            for (uint8_t j = 0; j < (dataSize & 3); ++j) {
              tailData |= (uint32_t)dataBuffer[dataSizeWithFlag + j] << ((3 - j) * 8);
            }
            WriteDataToRegister(fifoRegister, tailData); // Write remaining bytes
          }

          // Mark the end of data with a flag bit and the size
          WriteDataToRegister(interruptRegister, dataSize | 0x80000000);
          pthread_mutex_unlock(chainMutex);
          return dataSize;
        }
        usleep(3000); // sleep for 3ms before trying again
        retVal--;
      } while (retVal != 0);
      pthread_mutex_unlock(chainMutex);
      snprintf(statusMessage, UART_STATUS_MSG_SIZE,
               "%s: uart%d always busy, break\n", gLogDataPlaceholder, chainId);
      break;
    }
    usleep(3000); // sleep for 3ms before trying again
    retVal--;
  } while (retVal != 0);

  pthread_mutex_unlock(chainMutex);
  snprintf(statusMessage, UART_STATUS_MSG_SIZE,
           "%s: uart%d always does not have enough send FIFO space, break\n", gLogDataPlaceholder, chainId);
  WriteToRegister(0, statusMessage); // Placeholder for actual logging function
  return 0;
}
```