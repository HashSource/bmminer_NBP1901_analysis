```c
/* Globals that overlap with smaller symbols at the same address have been named starting with `g_` */

// Constant message strings
const char g_ErrorMessage[] = "create thread failed";
const char g_SuccessMessage[] = "create thread";

// Global variables representing system state
void *g_ThreadHandle = NULL; // Handle for the created thread
int g_VerbosityLevel = 0; // Verbosity level for logging

// Forward declaration of the thread function
void *ThreadMain(void *arg);

// Function to initialize and create a new thread
uint32_t InitializeAndCreateThread(void) {
  int creationResult;
  pthread_attr_t threadAttributes;
  uint32_t messageBuffer[20]; // Buffer for log messages

  // Only create a new thread if one does not already exist
  if (g_ThreadHandle == NULL) {
    // Initialize thread attributes
    pthread_attr_init(&threadAttributes);
    // Set the stack size for the thread
    pthread_attr_setstacksize(&threadAttributes, 0x200000);
    // Allocate memory to store thread data
    g_ThreadHandle = calloc(1, 0x40);
    // Create the new thread
    creationResult = pthread_create(g_ThreadHandle, &threadAttributes, ThreadMain, g_ThreadHandle);

    // Check for successful thread creation
    if (creationResult != 0) {
      // If verbose logging is enabled and thread creation failed
      if (g_VerbosityLevel > 3) {
        memcpy(messageBuffer, g_ErrorMessage, sizeof(g_ErrorMessage)); // Copy the error message to the buffer
        LogMessage(3, messageBuffer, 0); // Log the error message
      }
      return 0xffffffff; // Return an error code
    }

    // Detach the created thread
    pthread_detach(*(pthread_t *)((int)g_ThreadHandle + 0x0c));

    // If verbose logging is enabled and thread creation succeeded
    if (g_VerbosityLevel > 3) {
      memcpy(messageBuffer, g_SuccessMessage, sizeof(g_SuccessMessage)); // Copy the success message to the buffer
      LogMessage(3, messageBuffer, 0); // Log the success message
    }
  }

  return 0; // Return success
}
```