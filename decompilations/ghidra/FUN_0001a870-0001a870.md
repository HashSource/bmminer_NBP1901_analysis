```c
void SetFrequencyRange(float frequencyStep, undefined4 unknownParameter, uint frequencyStart, uint frequencyEnd)
{
  int chipIndex;
  uint frequencyStepCount;
  int isChipActive;
  uint frequencyDirection;
  double totalSteps;
  float currentFrequency;
  float finalFrequency;
  undefined local_bufferForFrequencySetting [4];
  undefined4 local_frequencySettingPart1;
  undefined4 local_frequencySettingPart2;
  char logBuffer[2052];
  long long frequencyStartEndCombined;
  
  // Log the frequency settings if verbosity level is high
  if (VERBOSITY_LEVEL > 4) {
    snprintf(logBuffer, 0x800, "fixed step freq_start = %d, freq_end = %d, freq_step = %.2f\n",
             frequencyStart, frequencyEnd, frequencyStep);
    Log(4, logBuffer, 0);
  }
  
  // Reset the chips
  for (chipIndex = 0; chipIndex < 4; chipIndex++) {
    isChipActive = CheckChipActive(chipIndex);
    if (isChipActive != 0) {
      ResetChip(chipIndex, 1, 0, unknownParameter);
    }
  }
  
  // Determine frequency step direction
  frequencyDirection = (frequencyStart < frequencyEnd) ? (frequencyEnd - frequencyStart) : (frequencyStart - frequencyEnd);
  // Compute total number of frequency steps needed
  totalSteps = ((double)(frequencyStep * (float)frequencyDirection + frequencyStep) - UNKNOWN_GLOBAL_FREQUENCY) / (double)frequencyStep;
  frequencyStepCount = (uint)(0.0 < totalSteps) * (int)(long long)totalSteps;
  
  if (frequencyStepCount != 0) {
    frequencyDirection = 1;
    frequencyStartEndCombined = ((long long)frequencyEnd) << 32;
    do {
      finalFrequency = (float)(frequencyStartEndCombined >> 32);
      local_frequencySettingPart1 = 0;
      local_frequencySettingPart2 = 0;
      // Increasing frequency
      if (frequencyStart < frequencyEnd) {
        currentFrequency = (float)frequencyStart + (float)frequencyDirection * frequencyStep;
        frequencyStartEndCombined = CombineFrequencies(finalFrequency, currentFrequency, finalFrequency);
      }
      // Decreasing frequency
      else {
        currentFrequency = (float)frequencyStart - (float)frequencyDirection * frequencyStep;
        frequencyStartEndCombined = CombineFrequencies(finalFrequency, currentFrequency);
      }
      // Set the current frequency for each active chip
      for (chipIndex = 0; chipIndex < 4; chipIndex++) {
        isChipActive = CheckChipActive(chipIndex);
        if (isChipActive != 0) {
          currentFrequency = ExtractCurrentFrequency(frequencyStartEndCombined);
          ConfigureChipFrequency(currentFrequency, &local_frequencySettingPart1, local_bufferForFrequencySetting, 0);
          SetChipFrequency(chipIndex, 1, 0, unknownParameter, local_frequencySettingPart1);
          // Log if verbosity is high
          if (VERBOSITY_LEVEL > 4) {
            snprintf(logBuffer, 0x800, "chain = %d set freq to %.2f", chipIndex, (double)currentFrequency);
            Log(4, logBuffer, 0);
          }
          // Update global variables with the frequency set
          GLOBAL_FREQUENCIES[chipIndex] = (int)currentFrequency;
          ANOTHER_GLOBAL_ARRAY[chipIndex] = (int)currentFrequency;
        }
      }
      // Increment the step direction
      frequencyDirection++;
      usleep(100000); // Sleep for 100ms between frequency steps
    } while (frequencyDirection <= frequencyStepCount);
  }
  
  // Set the final frequency for all active chips
  for (chipIndex = 0; chipIndex < 4; chipIndex++) {
    isChipActive = CheckChipActive(chipIndex);
    if (isChipActive != 0) {
      GLOBAL_FREQUENCIES[chipIndex] = frequencyEnd;
      ANOTHER_GLOBAL_ARRAY[chipIndex] = frequencyEnd;
    }
  }
  return;
}
```

I've renamed the functions, variables, and symbols to provide context where possible, based on what one can decipher from the decompiled code. I've also added comments to describe, at a high-level, what certain blocks of the code are doing. Without more context on the specific application, embedded system, or provided documentation, some names are kept vague (e.g., `unknownParameter`, `UNKNOWN_GLOBAL_FREQUENCY`, `GLOBAL_FREQUENCIES`, `ANOTHER_GLOBAL_ARRAY`). Additionally, the logging and check functions have assumed names like `Log` and `CheckChipActive` to represent their likely functionality, and `CombineFrequencies` and `ExtractCurrentFrequency` have been used to describe what appears to be frequency manipulation - actual functionality would need to be determined from their implementation.