```c
#include <errno.h>
#include <fcntl.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>

#define LOG_ERROR 2
#define LOG_INFO 1
#define LOG_DEBUG 0

// Prototype functions that need to be defined elsewhere or have their real names replaced
void Log(int level, const char *file, int line, const char *format, ...);
int FormatLogMessage(int formatControlOffset);
int CloseLogFile(int fileDescriptor);
int RotateLogFile(const char* logFilePath, ssize_t messageSize, int forceRotateControl, size_t maxLogSize, int rotateParam);

// Write buffer to a log file and handle log rotation if necessary
uint32_t WriteLogFile(int controlBlockOffset, int messageDataOffset)
{
  int fileDescriptor;
  ssize_t writeSize;
  struct stat64 logFileStats;
  char *logFilePath;
  int *errorNumberPtr;
  uint32_t result = 0;
  uint32_t rotateControl;
  uint32_t rotateInterval;
  char statBuffer[52]; // used to store stat64 data
  int fileSizeHigherBits;

  // Check if log message formatting succeeded
  if (FormatLogMessage(controlBlockOffset + 0x1878) == 0) {
    logFilePath = (char *)(controlBlockOffset + 0x1030);
    // Open the log file with options retrieved from the control block
    fileDescriptor = open64(logFilePath,
                            *(uint32_t *)(controlBlockOffset + 0x102c) | O_CREAT | O_WRONLY | O_APPEND,
                            *(mode_t *)(controlBlockOffset + 0x1028));
    if (fileDescriptor < 0) {
      errorNumberPtr = errno;
      result = -1;
      Log(LOG_ERROR, "src/rule.c", 0xae, "open file[%s] fail, errno[%d]", logFilePath, *errorNumberPtr);
    } else {
      // Calculate the size of the message to write and perform the write operation
      void *bufferStart = **(void ***)(messageDataOffset + 0x1c);
      size_t bufferSize = (size_t)(*(void ***)(messageDataOffset + 0x1c))[1] - (size_t)bufferStart;
      writeSize = write(fileDescriptor, bufferStart, bufferSize);
      if (writeSize < 0) {
        errorNumberPtr = errno;
        Log(LOG_ERROR, "src/rule.c", 0xb4, "write fail, errno[%d]", *errorNumberPtr);
        result = -1;
        CloseLogFile(fileDescriptor);
      } else {
        rotateControl = *(uint32_t *)(controlBlockOffset + 0x1868);
        if (rotateControl != 0) {
          rotateInterval = *(uint32_t *)(controlBlockOffset + 0x186c) + 1;
          if (rotateInterval < rotateControl) {
            *(uint32_t *)(controlBlockOffset + 0x186c) = rotateInterval;
          } else {
            *(uint32_t *)(controlBlockOffset + 0x186c) = 0;
            if (fsync(fileDescriptor) != 0) { // Make sure all changes written to file
              errorNumberPtr = errno;
              Log(LOG_ERROR, "src/rule.c", 0xbb, "fsync[%d] fail, errno[%d]", fileDescriptor, *errorNumberPtr);
            }
          }
        }
        if (CloseLogFile(fileDescriptor) < 0) {
          errorNumberPtr = errno;
          Log(LOG_ERROR, "src/rule.c", 0xbf, "close fail, maybe cause by write, errno[%d]", *errorNumberPtr);
          result = -1;
        } else {
          size_t maxLogSize = *(uint32_t *)(controlBlockOffset + 0x1450);
          if (bufferSize > maxLogSize) {
            Log(LOG_DEBUG, "src/rule.c", 0xc5, "one msg's len[%ld] > archive_max_size[%ld], no rotate", bufferSize, maxLogSize);
            return result;
          }
          // Check file size after writing log
          if (__xstat64(3, logFilePath, (struct stat64 *)statBuffer) != 0) {
            errorNumberPtr = errno;
            Log(LOG_INFO, "src/rule.c", 0xca, "stat [%s] fail, errno[%d], maybe in rotating", logFilePath, *errorNumberPtr);
            return result;
          }
          fileSizeHigherBits = ((int *)&statBuffer)[13];// Extrapolating: index for filesize higher bits
          // Check if log needs rotation
          if ((int64_t)(((uint64_t)fileSizeHigherBits << 32) + statBuffer[48] + bufferSize) >= (int64_t)maxLogSize) {
            if (RotateLogFile(logFilePath, bufferSize, *(int *)(0x0099eec8 + 0x1428), maxLogSize, *(int *)(controlBlockOffset + 0x1454)) != 0) {
              Log(LOG_ERROR, "src/rule.c", 0xd6, "log rotation fail");
              result = -1;
            }
          }
        }
      }
    }
  } else {
    Log(LOG_ERROR, "src/rule.c", 0xa7, "log message formatting failed");
    result = -1;
  }
  return result;
}
```