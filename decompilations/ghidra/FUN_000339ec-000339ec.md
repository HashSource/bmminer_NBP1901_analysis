```c
// Global variables are obfuscated with underscores and hex addresses, which should be renamed to meaningful names.

int isMinerInitialized = 2;
int minerOptionFlag = 1;
int minerLogLevel;
// Other global variables should be renamed according to their usage in the system, inferred from the context.

int InitializeMinerSystem(void) {
  int minerChainCount;
  int initializationResult;
  uint chainIndex;
  uint nextChain;
  char buffer[2048]; // Previously local_818 and related local variables for stack space
  
  // Miner initialization flag
  isMinerInitialized = 2;
  minerOptionFlag = 1;
  
  // Check logging level and perform initialization
  if (minerLogLevel < 4) {
    initializationResult = PerformFullSystemCheck();
  } else {
    // Log miner compile time and type
    snprintf(buffer, sizeof(buffer), "Miner compile time: %s type: %s\n", MinerCompileTime, MinerType);
    WriteLog(3, buffer, 0);
    
    // Check and log miner serial number if set
    if (minerSerialNumber != '\0') {
      if (minerLogLevel < 4) {
        initializationResult = PerformFullSystemCheck();
        // Continue with other conditions if statement invariant not needed
      }
      snprintf(buffer, sizeof(buffer), "Miner serial number: %s\n", minerSerialNumber);
      WriteLog(3, buffer, 0);
    }
    
    // Log additional information if log level allows
    if (minerLogLevel >= 4) {
      // Commit version and build information
      snprintf(buffer, sizeof(buffer),
               "Commit version: dd076742 2022-10-27 22:42:25, built by: Jenkins 2022-12-06 16:28:38\n");
      WriteLog(3, buffer, 0);
      // Other miner options and configurations
      snprintf(buffer, sizeof(buffer), "Option Multi Version     = %d\n", optionMultiVersion);
      WriteLog(3, buffer, 0);
      snprintf(buffer, sizeof(buffer), "Option Bitmain AB        = %d\n", optionBitmainAb);
      WriteLog(3, buffer, 0);
      snprintf(buffer, sizeof(buffer), "Mid Auto Generate        = %d\n", midAutoGenerate);
      WriteLog(3, buffer, 0);
      snprintf(buffer, sizeof(buffer), "Option Bitmain Work Mode = %d\n", bitmainWorkMode);
      WriteLog(3, buffer, 0);
    }
    initializationResult = PerformFullSystemCheck();
  }

  if (initializationResult != 0) {
    // Initialization failed - handle error based on the result
    // The error seems to involve byte manipulation of (possible) error strings
    // Error handling code would be placed here
    return 0;
  }
  
  // Execute startup procedures
  SetupInterruptHandler();
  InitializeHardwareAbstractionLayer();
  InitializeGPIO();
  InitializePWM();
  // Set miner A/B option to 1
  optionBitmainAb = 1;
  // Initialize network and USB communications
  SetupNetwork();
  InitializeUSB();

  // Check if basic IO interfaces are working correctly
  if (TestBasicIO() != 0) {
    // If failed, there is an issue with the IO interfaces
    return 0;
  }

  // Initialize core mining functions
  InitializeMiningHardware();
  DelayMilliseconds(100);
  InitializeTemperatureController();
  InitializeFanController();
  InitializeASIC();

  // Check ASIC presence and functionality
  if (IsASICFunctional() == 0) {
    // ASIC not functional
    if (minerLogLevel < 4) {
      return -1;
    }
    // Log the failure
    snprintf(buffer, sizeof(buffer), "No ASIC chain exists. Exiting...\n");
    WriteLog(3, buffer, 0);
    return -1;
  }

  // Log chain numbers if applicable
  if (minerOption1 != '\0' || minerOption2 != '\0' || minerLogLevel > 4) {
    minerChainCount = GetMinerChainCount();    
    snprintf(buffer, sizeof(buffer), "Chain count = %d", minerChainCount);
    WriteLog(5, buffer, 0);
  }

  // Test communication with each chain
  for (chainIndex = 0; chainIndex < 4; chainIndex++) {
    initializationResult = TestChainCommunication(chainIndex);
    if (initializationResult != 0) {
      HandleChainCommunicationFailure(chainIndex);
    }
  }

  // Check and configure miner operation
  initializationResult = ConfigureMinerOperation();
  if (initializationResult == 0) {
    if (isMinerInitialized == 1) {
      if (minerLogLevel < 4) {
        return 0;
      }
    } else {
      SetStatusLEDs(3, 0xff);
      if (minerLogLevel < 4) {
        // Continue to next check without logging
        // More conditions might be handled here
      }
    }
    // Handle Fixture data load failure by logging and exiting
    snprintf(buffer, sizeof(buffer), "Fixture data load failed. Exiting...\n");
    WriteLog(3, buffer, 0);
  }

  if (isMinerInitialized == 0 && MinerStartupSequence() != 0) {
    if (TestMinerNetworking() == 0 && minerLogLevel > 3) {
      snprintf(buffer, sizeof(buffer), "Miner network setup failed. Exiting...\n");
      WriteLog(3, buffer, 0);
      return 0;
    }
  }

  // If all checks and initializations pass, return success
  return 0;
}
```

Explanation:
1. Obfuscated global variables have been renamed to reflect their possible meanings inferred from the context. Since they are unknown without this context, representative names have been chosen based on their usage.
2. `FUN_000339ec` has been renamed to `InitializeMinerSystem`, a function that seems to handle system initialization for the miner hardware.
3. Other function names (e.g., `FUN_00031c64`, `FUN_0002e584`) have been replaced with dummy names that represent the action or check performed in the context (e.g., `PerformFullSystemCheck`, `WriteLog`), because the original names represent compiled function addresses and are not meaningful to readers.
4. Function parameters and return types have been inferred and may not represent the actual program.
5. Local buffers have been combined into a single buffer and renamed to `buffer` for readability.
6. Byte manipulation of the character arrays (`s_No_chain_exist__exit__00066d1c` and similar) is assumed to be related to error handling, hence only a comment is placed there to handle errors appropriately.
7. Control flow based on logging level (`minerLogLevel`) suggests different levels of logging details.
8. Comments have been added to give context to each section and action performed in the function.