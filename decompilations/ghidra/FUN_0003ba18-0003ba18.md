```c
uint getMaxChipFrequency(int chainId, int frequencyDataAddr)
{
  int chipIndex;
  uint *frequencyDataPtr;
  int totalChips;
  uint maxFrequency;
  int activeChipCount;
  char logBuffer[2048];
  
  maxFrequency = 0; // Initialize the maximum frequency to zero
  chipIndex = 0;    // Start with the first chip index
  do {
    // Check if the current chip index is active
    activeChipCount = checkChipIsActive(chipIndex);
    // If the chip is active and either the specified chainId is 0xff or matches the current chip index
    if ((activeChipCount != 0) && (chainId == 0xff || chainId == chipIndex)) {
      totalChips = 0; // Reset the counter to count the total number of chips 
      // Get the number of chips on the current chip index (chain)
      activeChipCount = getChipCountAtChain();
      if (activeChipCount != 0) {
        // Calculate the address where frequency data for the current chip starts
        frequencyDataPtr = (uint *)(frequencyDataAddr - 4 + chipIndex * 0x400);
        do {
          frequencyDataPtr++; // Move to the next data point
          totalChips++;       // Increment the total chip counter
          // Update the maximum frequency if a higher value is found
          if (maxFrequency < *frequencyDataPtr) {
            maxFrequency = *frequencyDataPtr;
          }
        } while (activeChipCount != totalChips); // Loop until all chips are checked
      }
    }
    chipIndex++; // Move to the next chip index
  } while (chipIndex != 4); // We have four chips to check

  // Check if debug level is set high enough to log the data
  if (4 < DEBUG_LEVEL) {
    // Prepare the log message
    snprintf(logBuffer, 0x800, "chain = %d, freq_max = %d\n", chainId, maxFrequency);
    // Log the message to a log file or console
    logDebug(4, logBuffer, 0);
  }
  
  return maxFrequency; // Return the maximum frequency found
}
```