```c
ulonglong calculateDivisionResult(uint dividend, uint divisor)
{
  uint raiseResult;
  ulonglong divisionResult;

  // If divisor is 1, return dividend as uint64 with divisor as upper 32-bit part
  if (divisor - 1 == 0) {
    return CONCAT44(divisor, dividend);
  }
  
  // If divisor is 0, raise a division by zero error
  if (divisor == 0) {
    raiseResult = raise(SIGFPE); // Signal code for Floating Point Exception
    return (ulonglong)raiseResult;
  }
  
  // If dividend is less than or equal to divisor
  if (dividend <= divisor) {
    // Return 1 if they are equal, otherwise return 0 (as upper 32-bit part will be used)
    return CONCAT44(divisor, (uint)(dividend == divisor));
  }
  
  // If divisor is a power of 2
  if ((divisor & divisor - 1) == 0) {
    // Shift dividend right by the number of trailing zeros in divisor
    return CONCAT44(divisor, dividend >> (0x1fU - __builtin_clz(divisor) & 0xff));
  }
  
  // Call another function dynamically based on the result of leading zero count comparison of divisor and dividend
  // This is a table-driven approach to replace a switch-case or if-else-if chain.
  // UNK_0005f8b8 is the start of the table; each entry is 0x10 bytes apart
  divisionResult = ((ulonglong (*)(uint, uint, uint))(&UNK_0005f8b8 + (0x1f - (__builtin_clz(divisor) - __builtin_clz(dividend))) * 0x10))
                    (dividend, divisor, 0);
  return divisionResult;
}
```