//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int32_t entry_point(int32_t a1, int32_t a2);
int32_t function_106e8(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_10708(int32_t a1);
int32_t function_10714(int32_t a1);
int32_t function_10720(int32_t a1, int32_t a2, int32_t * a3, int32_t a4, int32_t a5, int32_t a6, int32_t * a7);
int32_t function_1072c(void);
int32_t function_10738(int32_t a1);
int32_t function_10744(int32_t * a1, int32_t a2, int32_t a3, int32_t * a4);
int32_t function_10750(int32_t a1, int32_t * a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_1075c(int32_t a1, int32_t a2, int32_t a3);
int32_t function_10768(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_10774(int32_t * a1, int32_t * a2, int32_t * a3, int32_t * a4);
int32_t function_10780(int32_t * a1);
int32_t function_1078c(int32_t * a1, int32_t a2, int32_t a3, int32_t * a4);
int32_t function_10798(int32_t a1, char * a2, int32_t a3, int32_t * a4);
int32_t function_107a4(int32_t a1, int32_t a2);
int32_t function_107b0(int32_t * a1, int32_t a2);
int32_t function_107bc(char * a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_107c8(int32_t a1, int32_t a2);
int32_t function_107d4(int32_t * a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_107e0(void);
int32_t function_107f0(char * a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_107fc(int32_t a1);
int32_t function_10808(int32_t * a1, int32_t a2, int32_t a3, int32_t * a4);
int32_t function_10814(int32_t a1);
int32_t function_10820(int32_t * a1);
int32_t function_1082c(int32_t * a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_10868(void);
int32_t function_1088c(int32_t result, int32_t a2, int32_t a3, char a4);
int32_t function_108dc(void);
int32_t function_108f4(int32_t a1);
int32_t function_109a8(int32_t * a1);
int32_t function_10b9c(void);
int32_t function_10c70(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_10de8(int32_t a1, uint32_t a2, int32_t a3, uint32_t a4, uint32_t a5, uint32_t a6);
int32_t function_11460(int32_t result);
int32_t function_11490(int32_t a1);
int32_t function_114c8(uint64_t a1, int32_t a2);
int32_t function_11514(int64_t a1, int32_t a2, uint32_t a3);
int32_t function_11598(int64_t a1, int32_t a2, int64_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_116c8(int32_t a1, uint32_t a2);
int32_t function_119ec(int32_t a1, int32_t a2, int32_t a3);
int32_t function_11a04(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9);
int32_t function_11bd0(int32_t a1, int32_t a2, int32_t a3);
int32_t function_11dc8(uint32_t a1);
int32_t function_11f50(void);
int32_t function_11f58(int64_t a1, int64_t a2, int32_t a3);
int32_t function_11fbc(int32_t result, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_120dc(int32_t * a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_12180(int32_t result, uint32_t a2, int32_t a3);
int32_t function_12c34(int32_t a1, int32_t a2);
int32_t function_12c48(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_1373c(uint32_t a1, int32_t a2);
int32_t function_13b20(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_13b5c(void);
int32_t function_13b60(int32_t result, int32_t a2);
int32_t function_13b64(void);
int32_t function_13b6c(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_e0832002(void);
int32_t function_e1a00003(void);
int32_t function_e1a02003(void);
int32_t function_e1a03000(void);
int32_t function_e1a0c002(void);
int32_t function_e1a0e003(void);
int32_t function_e2433004(void);
int32_t function_e243300c(void);
int32_t function_e24b3e51(void);
int32_t function_e3033f1c(void);
int32_t function_e3403001(void);
int32_t function_e58c0000(void);
int32_t function_e58c1004(void);
int32_t function_e58c2008(void);
int32_t function_e58c300c(void);
int32_t function_e8be000f(void);
int32_t function_ea00004f(void);
int32_t function_ebfffdd2(void);
int32_t function_ff86c4c8(void);
int32_t function_ff86c848(void);
int32_t function_ff86ce70(void);
int32_t unknown_240(void);
int32_t unknown_412030(void);
int32_t unknown_413278(void);

// --------------------- Global Variables ---------------------

int32_t g1 = 0x108f5; // 0x24f08
int32_t g2 = 0; // 0x25070
int32_t g3 = 256; // 0x2507c
char * g4; // 0x25838
uint32_t g5;
int32_t g6;

// ------------------------ Functions -------------------------

// Address range: 0x106e8 - 0x106f4
int32_t function_106e8(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x106e8
    return function_10868();
}

// Address range: 0x10708 - 0x10714
int32_t function_10708(int32_t a1) {
    // 0x10708
    return function_e24b3e51();
}

// Address range: 0x10714 - 0x10720
int32_t function_10714(int32_t a1) {
    // 0x10714
    return function_e2433004();
}

// Address range: 0x10720 - 0x1072c
int32_t function_10720(int32_t a1, int32_t a2, int32_t * a3, int32_t a4, int32_t a5, int32_t a6, int32_t * a7) {
    // 0x10720
    return function_e243300c();
}

// Address range: 0x1072c - 0x10738
int32_t function_1072c(void) {
    // 0x1072c
    return function_e1a00003();
}

// Address range: 0x10738 - 0x10744
int32_t function_10738(int32_t a1) {
    // 0x10738
    return function_ebfffdd2();
}

// Address range: 0x10744 - 0x10750
int32_t function_10744(int32_t * a1, int32_t a2, int32_t a3, int32_t * a4) {
    // 0x10744
    return function_e1a03000();
}

// Address range: 0x10750 - 0x1075c
int32_t function_10750(int32_t a1, int32_t * a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x10750
    return function_e1a02003();
}

// Address range: 0x1075c - 0x10768
int32_t function_1075c(int32_t a1, int32_t a2, int32_t a3) {
    // 0x1075c
    return function_e24b3e51();
}

// Address range: 0x10768 - 0x10774
int32_t function_10768(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x10768
    return function_e2433004();
}

// Address range: 0x10774 - 0x10780
int32_t function_10774(int32_t * a1, int32_t * a2, int32_t * a3, int32_t * a4) {
    // 0x10774
    return function_e243300c();
}

// Address range: 0x10780 - 0x1078c
int32_t function_10780(int32_t * a1) {
    // 0x10780
    return function_e0832002();
}

// Address range: 0x1078c - 0x10798
int32_t function_1078c(int32_t * a1, int32_t a2, int32_t a3, int32_t * a4) {
    // 0x1078c
    return function_e3033f1c();
}

// Address range: 0x10798 - 0x107a4
int32_t function_10798(int32_t a1, char * a2, int32_t a3, int32_t * a4) {
    // 0x10798
    return function_e3403001();
}

// Address range: 0x107a4 - 0x107b0
int32_t function_107a4(int32_t a1, int32_t a2) {
    // 0x107a4
    return function_e1a0c002();
}

// Address range: 0x107b0 - 0x107bc
int32_t function_107b0(int32_t * a1, int32_t a2) {
    // 0x107b0
    return function_e1a0e003();
}

// Address range: 0x107bc - 0x107c8
int32_t function_107bc(char * a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x107bc
    return function_e8be000f();
}

// Address range: 0x107c8 - 0x107d4
int32_t function_107c8(int32_t a1, int32_t a2) {
    // 0x107c8
    return function_e58c0000();
}

// Address range: 0x107d4 - 0x107e0
int32_t function_107d4(int32_t * a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x107d4
    return function_e58c1004();
}

// Address range: 0x107e0 - 0x107f0
int32_t function_107e0(void) {
    // 0x107e0
    return function_e58c2008();
}

// Address range: 0x107f0 - 0x107fc
int32_t function_107f0(char * a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x107f0
    return function_e58c300c();
}

// Address range: 0x107fc - 0x10808
int32_t function_107fc(int32_t a1) {
    // 0x107fc
    return function_ea00004f();
}

// Address range: 0x10808 - 0x10814
int32_t function_10808(int32_t * a1, int32_t a2, int32_t a3, int32_t * a4) {
    // 0x10808
    return function_e24b3e51();
}

// Address range: 0x10814 - 0x10820
int32_t function_10814(int32_t a1) {
    // 0x10814
    return function_e2433004();
}

// Address range: 0x10820 - 0x1082c
int32_t function_10820(int32_t * a1) {
    // 0x10820
    return function_e243300c();
}

// Address range: 0x1082c - 0x10838
int32_t function_1082c(int32_t * a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x1082c
    return function_e1a00003();
}

// Address range: 0x10838 - 0x10860
int32_t entry_point(int32_t a1, int32_t a2) {
    // 0x10838
    int32_t v1; // 0x10838
    int32_t v2 = function_10720(0x1373c, a2, &v1, 0x13b21, 0x1373c, a1, &v1); // 0x10854
    return function_10708(v2);
}

// Address range: 0x10868 - 0x10884
int32_t function_10868(void) {
    // 0x10868
    if (g2 == 0) {
        int32_t result; // 0x10868
        return result;
    }
    // 0x10880
    return function_1072c();
}

// Address range: 0x1088c - 0x108dc
int32_t function_1088c(int32_t result, int32_t a2, int32_t a3, char a4) {
    // 0x1088c
    int32_t v1; // 0x1088c
    int32_t v2 = v1;
    bool v3; // 0x1088c
    if (v3) {
        return result;
    }
    bool v4; // 0x1088c
    if (!v3) {
        int32_t v5 = 0x100001 * v2 & -1 - 0x400000 * v2; // 0x108c4
        v4 = v5 < 0;
        if (v5 == 0) {
            return unknown_240();
        }
    }
    // 0x108d4
    if (v4 != v3) {
        __asm_svclt(0x4770);
    }
    return result;
}

// Address range: 0x108dc - 0x108f4
int32_t function_108dc(void) {
    // 0x108dc
    int32_t result; // 0x108dc
    if (*(char *)&g4 == 0) {
        // 0x108ea
        int32_t v1; // 0x108dc
        int32_t v2 = function_1088c(v1, v1, v1, 0); // 0x108ea
        *(char *)&g4 = 1;
        result = v2;
    }
    // 0x108f2
    return result;
}

// Address range: 0x108f4 - 0x109a8
int32_t function_108f4(int32_t a1) {
    int32_t v1; // 0x108f4
    function_107f0("Useage:\r", v1, v1, v1);
    function_107bc("\t%s [option] [paramaters]\n\n", a1, v1, v1);
    function_107f0("\tOption:{-f} {-s} {-p} {-n} {-x} {-q}\n", a1, v1, v1);
    function_107f0("\t\t-f [minerType] [fileName] [rootPublicKeyFile]: \n\t\t\tOnly Check If Filename was Valided.\n", a1, v1, v1);
    function_107f0("\t\t-s [minerType] [fileName] [rootPublicKeyFile]: \n\t\t\tCheck If Filename Was Valided, and Splite Bmu To \"/tmp/tmpfw/\"\n", a1, v1, v1);
    function_107f0("\t\t-p [minerType] [fileName] [rootPublicKeyFile]: \n\t\t\tCheck If Filename Was Valided, and Dump BmuComments\n", a1, v1, v1);
    function_107f0("\t\t-x [minerType] [fileName] [rootPublicKeyFile]: \n\t\t\tCheck If Filename Was FullSize BMU\n", a1, v1, v1);
    function_107f0("\t\t-n [nandBinFile]: \n\t\t\tSplite SigImg To Single File To \"/tmp/tmpNand/\"\n", a1, v1, v1);
    function_107f0("\t\t-q: \n\t\t\tGenerate A 256Bytes 0xff File To \"/tmp/256BFF\"\n", a1, v1, v1);
    function_107f0("\tReturns:", a1, v1, v1);
    function_107f0("\t\t0: \n\t\t\tWell Done!\n", a1, v1, v1);
    return __asm_nop(function_107f0("\t\tOthers: \n\t\t\tSomething Wrong!\n", a1, v1, v1));
}

// Address range: 0x109a8 - 0x10b9c
int32_t function_109a8(int32_t * a1) {
    int32_t v1 = 0; // bp-32788, 0x109d0
    int32_t v2; // bp-32784, 0x109a8
    function_10744(&v2, 0, 0x7ffc, &v2);
    int32_t v3; // bp-32776, 0x109a8
    int32_t v4 = function_10798((int32_t)a1, "rb", 0x7ffc, &v3); // 0x109fc
    int32_t v5 = 0; // 0x10a0c
    if (v4 == 0) {
        // 0x10a10
        function_107f0("Load Nand Image File Failed!", (int32_t)"rb", 0x7ffc, 0);
        // 0x10b90
        return 1;
    }
    int32_t v6 = 132 * v5; // 0x10a50
    int32_t * v7 = (int32_t *)(v6 + (int32_t)&g3); // 0x10a58
    function_1082c(&v1, *v7, 1, v4);
    int32_t v8 = v6 + (int32_t)&g3 + 4; // 0x10a94
    int32_t v9 = function_10798(v8, "wb", (int32_t)&g3, (int32_t *)v8); // 0x10aa4
    int32_t result; // 0x109a8
    while (v9 != 0) {
        // 0x10b08
        function_107d4(&v1, *v7, 1, v9);
        function_10738(v9);
        v5++;
        if (v5 >= 15) {
            // 0x10b84
            function_10738(v4);
            result = 0;
            return result;
        }
        v6 = 132 * v5;
        v7 = (int32_t *)(v6 + (int32_t)&g3);
        function_1082c(&v1, *v7, 1, v4);
        v8 = v6 + (int32_t)&g3 + 4;
        v9 = function_10798(v8, "wb", (int32_t)&g3, (int32_t *)v8);
    }
    // 0x10af8
    function_107bc("Try To Write To File '%s' Failed!\n", v8, (int32_t)&g3, v8);
    function_10738(v4);
    result = 2;
  lab_0x10b90:
    // 0x10b90
    return result;
}

// Address range: 0x10b9c - 0x10c70
int32_t function_10b9c(void) {
    // 0x10b9c
    int32_t v1; // 0x10b9c
    int32_t v2 = function_10798((int32_t)"/tmp/256BFF", "wb", v1, (int32_t *)v1); // 0x10bb8
    if (v2 == 0) {
        // 0x10bcc
        function_107f0("GenFile Failed!", (int32_t)"wb", v1, 0);
        // 0x10c64
        return 1;
    }
    int32_t v3 = 0; // bp-272, 0x10be4
    int32_t v4; // bp-268, 0x10b9c
    function_10744(&v4, 0, 252, &v4);
    for (int32_t i = 0; i < 256; i++) {
        // 0x10c10
        *(char *)(i + (int32_t)&v3) = -1;
    }
    // 0x10c3c
    function_107d4(&v3, 256, 1, v2);
    function_10738(v2);
    // 0x10c64
    return 0;
}

// Address range: 0x10c70 - 0x10de8
int32_t function_10c70(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = function_107a4(a4, 1024); // 0x10ca4
    int32_t v2 = function_10768(v1, 0, 0, 0); // 0x10cbc
    if (v2 == 0) {
        int32_t v3 = function_107c8(function_10714(0), 0); // 0x10ce0
        function_107bc("OpenSSL error: %s\n", v3, 0, v3);
        function_107f0("Read Root PubK Failed!", v3, 0, v3);
        // 0x10ddc
        return 12;
    }
    // 0x10d0c
    int32_t v4; // bp-164, 0x10c70
    function_10820(&v4);
    function_10808(&v4, a1, a2, &v4);
    int32_t v5; // bp-52, 0x10c70
    function_10774(&v5, &v4, &v4, &v5);
    int32_t v6 = function_10750(672, &v5, 32, a3, 256, v2); // 0x10d60
    int32_t v7 = function_107fc(v2); // 0x10d84
    if (v1 != 0) {
        // 0x10d88
        v7 = function_10814(v1);
    }
    int32_t result = 0; // 0x10d98
    if (v6 != 1) {
        int32_t v8 = function_107c8(function_10714(v7), 0); // 0x10db4
        function_107bc("OpenSSL error: %s\n", v8, 32, v8);
        function_107f0("Check miner.pem Failed!", v8, 32, v8);
        result = 13;
    }
    // 0x10ddc
    return result;
}

// Address range: 0x10de8 - 0x11460
int32_t function_10de8(int32_t a1, uint32_t a2, int32_t a3, uint32_t a4, uint32_t a5, uint32_t a6) {
    int32_t v1 = 0; // bp-1044, 0x10e08
    int32_t v2; // bp-1040, 0x10de8
    function_10744(&v2, 0, 1020, &v2);
    int32_t v3; // bp-1156, 0x10de8
    function_10820(&v3);
    int32_t v4 = 0; // 0x10e5c
    if (a6 % 256 != 0) {
        char * v5 = (char *)0x706d742f; // bp-1316, 0x10e78
        int32_t v6; // bp-1304, 0x10de8
        function_10744(&v6, 0, 116, &v6);
        g5 = a4 % 256;
        switch ((char)a4) {
            case 0: {
                int32_t v7 = function_10780((int32_t *)&v5) + (int32_t)&v5; // 0x10ef4
                *(int32_t *)v7 = 0x544f4f42;
                *(int32_t *)(v7 + 4) = 0x6e69622e;
                *(char *)(v7 + 8) = 0;
                // break -> 0x111b4
                break;
            }
            case 1: {
                int32_t v8 = function_10780((int32_t *)&v5) + (int32_t)&v5; // 0x10f40
                *(int32_t *)v8 = 0x69766564;
                *(int32_t *)(v8 + 4) = 0x72746563;
                *(int32_t *)(v8 + 8) = 0x642e6565;
                *(int16_t *)(v8 + 12) = 0x6274;
                *(char *)(v8 + 14) = 0;
                // break -> 0x111b4
                break;
            }
            case 2: {
                int32_t v9 = function_10780((int32_t *)&v5) + (int32_t)&v5; // 0x10f9c
                *(int32_t *)v9 = 0x616d4975;
                *(int16_t *)(v9 + 4) = 0x6567;
                *(char *)(v9 + 6) = 0;
                // break -> 0x111b4
                break;
            }
            case 3: {
                int32_t v10 = function_10780((int32_t *)&v5) + (int32_t)&v5; // 0x10fec
                *(int32_t *)v10 = 0x656e696d;
                *(int32_t *)(v10 + 4) = 0x2e736672;
                *(int32_t *)(v10 + 8) = 0x67616d69;
                *(int32_t *)(v10 + 12) = 0x7a672e65;
                *(char *)(v10 + 16) = 0;
                // break -> 0x111b4
                break;
            }
            case 4: {
                int32_t v11 = function_10780((int32_t *)&v5) + (int32_t)&v5; // 0x11048
                *(int32_t *)v11 = 0x61647075;
                *(int32_t *)(v11 + 4) = 0x692e6574;
                *(int32_t *)(v11 + 8) = 0x6567616d;
                *(int32_t *)(v11 + 12) = 0x7a672e;
                // break -> 0x111b4
                break;
            }
            case 5: {
                int32_t v12 = function_10780((int32_t *)&v5) + (int32_t)&v5; // 0x1109c
                *(int32_t *)v12 = 0x2e6c7263;
                *(int32_t *)(v12 + 4) = 0x2e726174;
                *(int16_t *)(v12 + 8) = 0x7a67;
                *(char *)(v12 + 10) = 0;
                // break -> 0x111b4
                break;
            }
            case 6: {
                int32_t v13 = function_10780((int32_t *)&v5) + (int32_t)&v5; // 0x110f0
                *(int32_t *)v13 = 0x656e696d;
                *(int32_t *)(v13 + 4) = 0x74622e72;
                *(int32_t *)(v13 + 8) = 0x61742e6d;
                *(int32_t *)(v13 + 12) = 0x7a672e72;
                *(char *)(v13 + 16) = 0;
                // break -> 0x111b4
                break;
            }
            case 7: {
                int32_t v14 = function_10780((int32_t *)&v5) + (int32_t)&v5; // 0x1114c
                *(int32_t *)v14 = 0x65736572;
                *(int32_t *)(v14 + 4) = 0x657672;
                // break -> 0x111b4
                break;
            }
            case 9: {
                int32_t v15 = function_10780((int32_t *)&v5) + (int32_t)&v5; // 0x11190
                *(int32_t *)v15 = 0x61746164;
                *(int32_t *)(v15 + 4) = 0x656c6966;
                *(char *)(v15 + 8) = 0;
                __asm_nop(0x61746164);
                // break -> 0x111b4
                break;
            }
        }
        int32_t v16; // 0x10de8
        if (a5 % 256 == 0) {
            // 0x111b4
            v16 = (int32_t)&v5;
        } else {
            int32_t v17 = function_10780((int32_t *)&v5); // 0x111d0
            int32_t v18 = (int32_t)&v5;
            int32_t v19 = v17 + v18; // 0x111e8
            *(int32_t *)v19 = 0x6769732e;
            *(char *)(v19 + 4) = 0;
            v16 = v18;
        }
        int32_t v20 = v16;
        function_107bc("fileName:'%s', size:[%d]\r\n", v20, a2, v20);
        int32_t v21 = function_10798(v20, "wb", a2, (int32_t *)&v5); // 0x1123c
        v4 = v21;
        if (v21 == 0) {
            // 0x11250
            function_107bc("Create File '%s' Failed!\r\n", v20, a2, v20);
            v4 = 0;
        }
    }
    int32_t v22 = &v1;
    int32_t v23 = a2; // 0x1130c
    if (a2 >= 1024 == (a2 != 1024)) {
        int32_t v24 = 0; // 0x1129c
        int32_t v25 = function_1082c(&v1, 1, 1024, a1); // 0x11288
        function_10808(&v3, v22, 1024, &v3);
        if (a6 % 256 != 0 && v4 != 0) {
            // 0x112e0
            function_107d4(&v1, 1, 1024, v4);
        }
        // 0x112fc
        v24 += v25;
        int32_t v26 = a2 - v24; // 0x11304
        v23 = v26;
        while (v26 >= 1024 == (v26 != 1024)) {
            // 0x11270
            v25 = function_1082c(&v1, 1, 1024, a1);
            function_10808(&v3, v22, 1024, &v3);
            if (a6 % 256 != 0 && v4 != 0) {
                // 0x112e0
                function_107d4(&v1, 1, 1024, v4);
            }
            // 0x112fc
            v24 += v25;
            v26 = a2 - v24;
            v23 = v26;
        }
    }
    int32_t v27 = function_1082c(&v1, 1, v23, a1); // 0x11330
    function_10808(&v3, v22, v27, &v3);
    int32_t v28; // bp-1188, 0x10de8
    if (a6 % 256 == 0 || v4 == 0) {
        // 0x11394
        v28 = 0;
        function_10774(&v28, &v3, &v3, &v28);
    } else {
        // 0x11404
        function_107d4(&v1, 1, v27, v4);
        v28 = 0;
        function_10774(&v28, &v3, &v3, &v28);
        function_10738(v4);
    }
    // 0x11414
    *(int32_t *)a3 = v28;
    *(int32_t *)(a3 + 4) = 0;
    *(int32_t *)(a3 + 8) = 0;
    *(int32_t *)(a3 + 12) = 0;
    *(int32_t *)(a3 + 16) = 0;
    *(int32_t *)(a3 + 20) = 0;
    *(int32_t *)(a3 + 24) = 0;
    *(int32_t *)(a3 + 28) = 0;
    __asm_nop(0);
    return 0;
}

// Address range: 0x11460 - 0x11490
int32_t function_11460(int32_t result) {
    // 0x11460
    return result;
}

// Address range: 0x11490 - 0x114c8
int32_t function_11490(int32_t a1) {
    // 0x11490
    int64_t v1; // bp-16, 0x11490
    function_1078c((int32_t *)&v1, a1, 8, (int32_t *)&v1);
    return (0x100000000 * v1 >> 32) / 0x100000000;
}

// Address range: 0x114c8 - 0x11514
int32_t function_114c8(uint64_t a1, int32_t a2) {
    // 0x114c8
    return ((int64_t)(0x100000000 * a1) >> 32) / 0x100000000 ^ a1 / 0x8000 % 0x20000;
}

// Address range: 0x11514 - 0x11598
int32_t function_11514(int64_t a1, int32_t a2, uint32_t a3) {
    uint64_t v1 = 0x100000000 * a1 >> 32; // 0x11528
    uint32_t v2 = (int32_t)v1; // 0x11528
    uint32_t v3 = (int32_t)(v1 / 0x100000000); // 0x11528
    return v2 >> a3 - 32 | v2 << 32 - a3 | v3 >> a3 | v3 << -a3 % 64;
}

// Address range: 0x11598 - 0x116c8
int32_t function_11598(int64_t a1, int32_t a2, int64_t a3, int32_t a4, int32_t a5, int32_t a6) {
    int32_t v1 = a3;
    int32_t v2 = ((v1 >> 31 ^ (int32_t)((0x100000000 * a1 >> 32) / 0x100000000)) * a5 ^ v1) / 0x80000000 * a5; // 0x11640
    return (v2 >> 31 ^ v2 / 0x8000) * a5 / 0x80000000;
}

// Address range: 0x116c8 - 0x119ec
int32_t function_116c8(int32_t a1, uint32_t a2) {
    // 0x116c8
    if (a2 != 7 && a2 >= 7) {
        int32_t v1 = (2 * a2 - 0x651e95c5) / 0x80000000;
        int32_t v2 = function_11490(a1) - 0x651e95c5 >> 31;
        int32_t v3 = function_11490(a2 + a1 - 8); // 0x11754
        int32_t v4 = v3 >> 31;
        int32_t v5 = function_11514((int64_t)v4, v3, 37) * v1 + v2 >> 31;
        int32_t v6 = (function_11514((int64_t)v2, v2, 25) + v4) * v1; // 0x117e0
        // 0x119dc
        return function_11598((int64_t)v5, v5, (int64_t)(v6 >> 31), v6, v1, v1);
    }
    if (a2 != 3 && a2 >= 3) {
        int32_t v7 = 2 * a2 - 0x651e95c5; // 0x11838
        int32_t v8 = 8 * function_11460(a1) + a2; // 0x11878
        // 0x119dc
        return function_11598((int64_t)(v8 >> 31), v8, (int64_t)function_11460(a2 + a1 - 4), 0, v7 >> 31, v7);
    }
    int32_t result = -0x651e95c5; // 0x118d8
    if (a2 != 0) {
        unsigned char v9 = *(char *)(a2 / 2 + a1); // 0x118f8
        unsigned char v10 = *(char *)(a2 + a1 - 1); // 0x11910
        int32_t v11; // 0x116c8
        int32_t v12 = -0x3c5a37a4 * (4 * (int32_t)v10 + a2) ^ -0x651e95c5 * (256 * (int32_t)v9 | (uint32_t)v11 % 256); // 0x11998
        result = -0x651e95c5 * function_114c8((int64_t)(v12 >> 31), v12);
    }
    // 0x119dc
    return result;
}

// Address range: 0x119ec - 0x11a02
int32_t function_119ec(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = unknown_412030(); // 0x119ec
    int32_t v2 = *(int32_t *)(v1 + 4); // 0x119fc
    int32_t result = v1 + 16; // 0x119fc
    *(int32_t *)v2 = result;
    *(int32_t *)(v2 + 4) = *(int32_t *)v1;
    int32_t v3; // 0x119ec
    *(int32_t *)(v2 + 12) = v3 ^ a2;
    return result;
}

// Address range: 0x11a04 - 0x11bd0
int32_t function_11a04(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9) {
    int32_t v1 = 2 * a2 - 0x651e95c5; // 0x11a2c
    int32_t v2 = function_11490(a1); // 0x11a3c
    int32_t v3 = function_11490(a1 + 8); // 0x11a74
    int32_t v4 = a2 + a1;
    int32_t v5 = function_11490(v4 - 8) * v1; // 0x11aac
    int32_t v6 = function_11490(v4 - 16); // 0x11ad4
    int32_t v7 = -0x4b6d4991 * v2 >> 31;
    int32_t v8 = v3 >> 31;
    int32_t v9 = v7 + v8; // 0x11b08
    int32_t v10 = function_11514((int64_t)(v9 >> 31), v9, 43); // 0x11b20
    int32_t v11 = v5 >> 31;
    int32_t v12 = function_11514((int64_t)v11, v5, 30) + v10 + (-0x651e95c5 * v6 >> 31); // 0x11b4c
    int32_t v13 = v8 - 0x651e95c5; // 0x11b68
    int32_t v14 = v11 + v7 + function_11514((int64_t)(v13 >> 31), v13, 18); // 0x11b94
    return function_11598((int64_t)(v12 >> 31), v12, (int64_t)(v14 >> 31), v14, v1 >> 31, v1);
}

// Address range: 0x11bd0 - 0x11dc4
int32_t function_11bd0(int32_t a1, int32_t a2, int32_t a3) {
    // 0x11bd0
    int32_t v1; // 0x11bd0
    bool v2; // 0x11bd0
    if (v2) {
        __asm_svchs(0x90404f);
        v1 = a1;
        if (v2) {
            // .thread
            v1 = function_ff86c4c8();
            goto lab_0x11bd8;
        } else {
            goto lab_0x11bd8;
        }
    } else {
        // .thread
        v1 = function_ff86c4c8();
        goto lab_0x11bd8;
    }
  lab_0x11bd8:;
    int32_t v3 = 2 * a2 - 0x651e95c5; // 0x11c0c
    int32_t v4 = function_11490(v1); // 0x11c1c
    int32_t v5 = function_11490(v1 + 8); // 0x11c54
    int32_t v6 = v1 + a2;
    int32_t v7 = function_11490(v6 - 8) * v3; // 0x11c8c
    int32_t v8 = function_11490(v6 - 16); // 0x11cb4
    int32_t v9 = -0x651e95c5 * v4 >> 31;
    int32_t v10 = v5 >> 31;
    int32_t v11 = v9 + v10; // 0x11ce8
    int32_t v12 = function_11514((int64_t)(v11 >> 31), v11, 43); // 0x11d00
    int32_t v13 = v7 >> 31;
    int32_t v14 = (function_11514((int64_t)v13, v7, 30) + v12 + (-0x651e95c5 * v8 >> 31)) / 0x80000000;
    int32_t v15 = v10 - 0x651e95c5; // 0x11d50
    int32_t v16 = v13 + v9 + function_11514((int64_t)(v15 >> 31), v15, 18); // 0x11d7c
    function_11598((int64_t)v14, v14, (int64_t)(v16 >> 31), v16, v3 >> 31, v3);
    return function_11490(v1 + 16);
}

// Address range: 0x11dc8 - 0x11f50
int32_t function_11dc8(uint32_t a1) {
    // 0x11dc8
    int32_t v1; // 0x11dc8
    int32_t * v2 = (int32_t *)(v1 - 36); // 0x11dc8
    uint64_t v3 = (int64_t)*v2 * (int64_t)a1; // 0x11dcc
    int32_t v4 = v1 + (int32_t)(v3 / 0x100000000); // 0x11dd0
    int32_t v5 = v1 - 92; // 0x11dd8
    *(int32_t *)v5 = (int32_t)v3;
    *(int32_t *)(v1 - 88) = v4;
    int32_t * v6 = (int32_t *)(v1 - 120); // 0x11de0
    int32_t v7 = function_11490(*v6 + 24); // 0x11dec
    int32_t v8 = v1 - 100; // 0x11df0
    *(int32_t *)v8 = v7;
    *(int32_t *)(v1 - 96) = v4;
    int32_t * v9 = (int32_t *)(v1 - 124); // 0x11df4
    uint32_t v10 = function_11490(*v9 - 32 + *v6); // 0x11e08
    uint64_t v11 = *(int64_t *)(v1 - 76); // 0x11e0c
    uint32_t v12 = v10 + (int32_t)(v11 / 0x100000000); // 0x11e10
    int32_t v13 = v1 - 156; // 0x11e14
    *(int32_t *)v13 = v12;
    *(int32_t *)(v1 - 152) = v4 + (int32_t)v11 + (int32_t)(v12 < v10);
    int32_t * v14 = (int32_t *)(v1 - 32); // 0x11e20
    int32_t v15 = *v14; // 0x11e20
    uint64_t v16 = *(int64_t *)v13; // 0x11e24
    uint64_t v17 = v16 / 0x100000000; // 0x11e24
    uint32_t v18 = *v2; // 0x11e30
    uint64_t v19 = v17 * (int64_t)v18; // 0x11e48
    int32_t v20 = v15 * (int32_t)v17 + v18 * (int32_t)v16 + (int32_t)(v19 / 0x100000000); // 0x11e4c
    int32_t v21 = v1 - 108; // 0x11e54
    *(int32_t *)v21 = (int32_t)v19;
    *(int32_t *)(v1 - 104) = v20;
    uint32_t v22 = function_11490(*v9 - 24 + *v6); // 0x11e70
    uint64_t v23 = *(int64_t *)(v1 - 84); // 0x11e74
    uint32_t v24 = v22 + (int32_t)(v23 / 0x100000000); // 0x11e78
    int32_t v25 = v1 - 164; // 0x11e7c
    *(int32_t *)v25 = v24;
    *(int32_t *)(v1 - 160) = v20 + (int32_t)v23 + (int32_t)(v24 < v22);
    int32_t v26 = *v14; // 0x11e88
    uint64_t v27 = *(int64_t *)v25; // 0x11e8c
    uint64_t v28 = v27 / 0x100000000; // 0x11e8c
    uint32_t v29 = *v2; // 0x11e98
    uint64_t v30 = v28 * (int64_t)v29; // 0x11eb0
    int32_t v31 = v1 - 116; // 0x11ebc
    *(int32_t *)v31 = (int32_t)v30;
    *(int32_t *)(v1 - 112) = v26 * (int32_t)v28 + v29 * (int32_t)v27 + (int32_t)(v30 / 0x100000000);
    uint64_t v32 = *(int64_t *)v5; // 0x11ec4
    uint32_t v33 = (int32_t)(v32 / 0x100000000); // 0x11ec4
    int64_t * v34 = (int64_t *)v8; // 0x11ec8
    uint64_t v35 = *v34; // 0x11ec8
    uint32_t v36 = (int32_t)(v35 / 0x100000000) + v33; // 0x11ecc
    int32_t v37 = v1 - 172; // 0x11ed0
    *(int32_t *)v37 = v36;
    *(int32_t *)(v1 - 168) = (int32_t)v35 + (int32_t)v32 + (int32_t)(v36 < v33);
    int64_t v38 = *(int64_t *)v37; // 0x11ee0
    int32_t v39 = v38; // 0x11ee0
    uint32_t v40 = function_11514(v38 >> 32, v39, 43); // 0x11ee4
    int64_t v41 = *(int64_t *)v21; // 0x11ef4
    int32_t v42 = v41; // 0x11ef4
    uint32_t v43 = function_11514(v41 >> 32, v42, 30) + v40; // 0x11f04
    int32_t v44 = v1 - 180; // 0x11f08
    *(int32_t *)v44 = v43;
    *(int32_t *)(v1 - 176) = v42 + v39 + (int32_t)(v43 < v40);
    uint64_t v45 = *(int64_t *)v31; // 0x11f14
    uint64_t v46 = *(int64_t *)v44; // 0x11f18
    uint32_t v47 = (int32_t)(v46 / 0x100000000); // 0x11f18
    uint32_t v48 = v47 + (int32_t)(v45 / 0x100000000); // 0x11f20
    *(int32_t *)(v1 - 188) = v48;
    *(int32_t *)(v1 - 184) = (int32_t)v46 + (int32_t)v45 + (int32_t)(v48 < v47);
    uint64_t v49 = *v34; // 0x11f30
    int32_t v50 = v49; // 0x11f30
    int32_t v51 = v49 / 0x100000000; // 0x11f30
    uint64_t v52 = *(int64_t *)(v1 - 44); // 0x11f34
    uint32_t v53 = (int32_t)(v52 / 0x100000000) + v51; // 0x11f38
    *(int32_t *)(v1 - 196) = v53;
    *(int32_t *)(v1 - 192) = (int32_t)v52 + v50 + (int32_t)(v53 < v51);
    return function_11f58((int64_t)v51, (int64_t)v50, 18);
}

// Address range: 0x11f50 - 0x11f58
int32_t function_11f50(void) {
    // 0x11f50
    bool v1; // 0x11f50
    if (v1) {
        __asm_svchs(0x90404f);
    }
    int32_t result; // 0x11f50
    return result;
}

// Address range: 0x11f58 - 0x11fbc
int32_t function_11f58(int64_t a1, int64_t a2, int32_t a3) {
    // 0x11f58
    int32_t v1; // 0x11f58
    int64_t v2 = *(int64_t *)(v1 - 196); // 0x11f58
    int32_t v3 = v2; // 0x11f58
    uint32_t v4 = function_11514(v2 >> 32, v3, a3); // 0x11f5c
    uint64_t v5 = *(int64_t *)(v1 - 92); // 0x11f60
    uint32_t v6 = v4 + (int32_t)(v5 / 0x100000000); // 0x11f64
    int32_t v7 = v1 - 204; // 0x11f68
    *(int32_t *)v7 = v6;
    *(int32_t *)(v1 - 200) = (int32_t)v5 + v3 + (int32_t)(v6 < v4);
    uint64_t v8 = *(int64_t *)(v1 - 108); // 0x11f74
    uint64_t v9 = *(int64_t *)v7; // 0x11f78
    uint32_t v10 = (int32_t)(v9 / 0x100000000); // 0x11f78
    uint32_t v11 = v10 + (int32_t)(v8 / 0x100000000); // 0x11f80
    int32_t v12 = v1 - 212; // 0x11f84
    *(int32_t *)v12 = v11;
    *(int32_t *)(v1 - 208) = (int32_t)v9 + (int32_t)v8 + (int32_t)(v11 < v10);
    uint64_t v13 = *(int64_t *)(v1 - 36); // 0x11f90
    int64_t v14 = *(int64_t *)v12; // 0x11f98
    int64_t v15 = *(int64_t *)(v1 - 188); // 0x11f9c
    return function_11598(v15 >> 32, (int32_t)v15, v14 >> 32, (int32_t)v14, (int32_t)(v13 / 0x100000000), (int32_t)v13);
}

// Address range: 0x11fbc - 0x120dc
int32_t function_11fbc(int32_t result, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x11fbc
    int64_t v1; // 0x11fbc
    int32_t v2 = ((a3 >> 31) + (int32_t)(v1 / 0x100000000)) / 0x80000000; // 0x11fe8
    int32_t v3 = v1 / 0x100000000; // 0x11ff4
    int32_t v4 = (int32_t)(v1 / 0x100000000) + v3 + v2; // 0x11ff8
    int32_t v5 = function_11514((int64_t)(v4 >> 31), v4, 21); // 0x12010
    int32_t v6 = (v2 + (a5 >> 31)) / 0x80000000 + (int32_t)((uint64_t)v1 / 0x100000000) >> 31;
    uint32_t v7 = ((v5 >> 31) + function_11514((int64_t)v6, v6, 44)) / 0x80000000;
    int32_t v8 = v6 + v3; // 0x12090
    uint32_t v9 = v7 + v2; // 0x120b0
    *(int32_t *)result = v8 >> 31;
    *(int32_t *)(result + 4) = v8;
    *(int32_t *)(result + 8) = v9;
    *(int32_t *)(result + 12) = v9 + (int32_t)(v9 < v7);
    return result;
}

// Address range: 0x120dc - 0x12180
int32_t function_120dc(int32_t * a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t result = (int32_t)a1;
    int32_t v1 = function_11490(a2); // 0x120f8
    int32_t v2 = function_11490(a2 + 8); // 0x12110
    function_11490(a2 + 16);
    function_11490(a2 + 24);
    function_11fbc(result, a2, v1, a2, v2);
    return result;
}

// Address range: 0x12180 - 0x12c34
int32_t function_12180(int32_t result, uint32_t a2, int32_t a3) {
    // 0x12180
    if (a2 >= 16 != a2 != 16) {
        // 0x12c24
        return function_116c8(result, a2);
    }
    // 0x121c4
    if (a2 >= 32 != a2 != 32 || a2 >= 64 != a2 != 64) {
        // 0x12c24
        return result;
    }
    int32_t v1 = function_114c8(0x413964a1, -0x709bf205); // 0x12288
    int64_t v2 = 0; // bp-96, 0x122bc
    int64_t v3 = 0; // bp-112, 0x122d4
    int32_t v4 = function_11490(result); // 0x12314
    int32_t v5 = (a2 - 1 & -64) + result; // 0x1233c
    v2 = 0;
    int32_t v6 = result; // 0x1235c
    int32_t v7 = v4 >> 31; // 0x1235c
    int32_t v8 = 0; // 0x1235c
    int32_t v9 = ((v8 + v7 >> 31) + (int32_t)((0x100000000 * v2 >> 32) / 0x100000000)) / 0x80000000 + function_11490(v6 + 8); // 0x123b4
    int32_t v10 = function_11514((int64_t)(v9 >> 31), v9, 37); // 0x123cc
    int32_t v11 = function_11490(v6 + 48) + v8; // 0x12430
    int32_t v12 = function_11514((int64_t)(v11 >> 31), v11, 42); // 0x12448
    int32_t v13 = -0x4b6d4991 * v10 >> 31;
    v8 = ((function_11490(v6 + 40) + (int32_t)((0x100000000 * v2 >> 32) / 0x100000000) >> 31) + (-0x4b6d4991 * v12 >> 31)) / 0x80000000;
    int32_t v14 = (-0x651e95c5 * v1 >> 31) + (int32_t)((0x100000000 * v3 >> 32) / 0x100000000); // 0x124f8
    int32_t v15 = -0x4b6d4991 * function_11514((int64_t)(v14 >> 31), v14, 33); // 0x12528
    function_120dc((int32_t *)&v2, v6, 0, 0, v13 + (int32_t)((0x100000000 * v3 >> 32) / 0x100000000) >> 31);
    int32_t v16 = v15 >> 31; // 0x125bc
    int32_t v17 = function_11490(v6 + 16); // 0x125dc
    function_120dc((int32_t *)&v3, v6 + 32, v16, v16, v8 + v17 >> 31);
    int32_t v18 = (0x100000000 * (int64_t)(v15 ^ v13) >> 63) / 0x100000000; // 0x12628
    v7 = (v13 ^ v18) >> 31;
    int32_t v19 = (v7 ^ v18) >> 31;
    v6 += 64;
    while (v6 != v5) {
        v9 = ((v8 + v7 >> 31) + (int32_t)((0x100000000 * v2 >> 32) / 0x100000000)) / 0x80000000 + function_11490(v6 + 8);
        v10 = function_11514((int64_t)(v9 >> 31), v9, 37);
        v11 = function_11490(v6 + 48) + v8;
        v12 = function_11514((int64_t)(v11 >> 31), v11, 42);
        v13 = -0x4b6d4991 * v10 >> 31;
        v8 = ((function_11490(v6 + 40) + (int32_t)((0x100000000 * v2 >> 32) / 0x100000000) >> 31) + (-0x4b6d4991 * v12 >> 31)) / 0x80000000;
        v14 = v19 + (int32_t)((0x100000000 * v3 >> 32) / 0x100000000);
        v15 = -0x4b6d4991 * function_11514((int64_t)(v14 >> 31), v14, 33);
        function_120dc((int32_t *)&v2, v6, 0, 0, v13 + (int32_t)((0x100000000 * v3 >> 32) / 0x100000000) >> 31);
        v16 = v15 >> 31;
        v17 = function_11490(v6 + 16);
        function_120dc((int32_t *)&v3, v6 + 32, v16, v16, v8 + v17 >> 31);
        v18 = (0x100000000 * (int64_t)(v15 ^ v13) >> 63) / 0x100000000;
        v7 = (v13 ^ v18) >> 31;
        v19 = (v7 ^ v18) >> 31;
        v6 += 64;
    }
    int32_t v20 = (a2 + 63) % 64 - 63 + v5; // 0x12358
    int32_t v21 = (0x100000000 * v3 >> 63) / 0x100000000; // 0x1274c
    int32_t v22 = (int32_t)((0x100000000 * v2 >> 32) / 0x100000000) + v21 >> 31;
    v2 = v22;
    v3 = v22 + v21 >> 31;
    int32_t v23 = (v22 + (v7 + v8 >> 31)) / 0x80000000 + function_11490(v20 + 8); // 0x127e0
    int32_t v24 = function_11514((int64_t)(v23 >> 31), v23, 37); // 0x127fc
    int32_t v25 = function_11490(v20 + 48) + v8; // 0x12868
    int32_t v26 = function_11514((int64_t)(v25 >> 31), v25, 42); // 0x12884
    int32_t v27 = -1 * v24 >> 31;
    uint64_t v28 = (0x100000000 * v2 >> 32) / 0x100000000; // 0x12918
    int32_t v29 = ((8 * (int32_t)v28 + (int32_t)v28 >> 31) + function_11490(v20 + 40)) / 0x80000000 + (-1 * v26 >> 31) >> 31;
    int32_t v30 = v19 + (int32_t)((0x100000000 * v3 >> 32) / 0x100000000); // 0x129b8
    int32_t v31 = function_11514((int64_t)(v30 >> 31), v30, 33); // 0x129d4
    int64_t v32; // bp-136, 0x12180
    function_120dc((int32_t *)&v32, v20, 0, 0, v27 + (int32_t)((0x100000000 * v3 >> 32) / 0x100000000) >> 31);
    v2 = 0x100000000 * v32 >> 32;
    int32_t v33 = -1 * v31 >> 31;
    int32_t v34 = function_11490(v20 + 16); // 0x12aa0
    function_120dc((int32_t *)&v32, v20 + 32, v33, v33, v29 + v34 >> 31);
    int64_t v35 = 0x100000000 * v32;
    v3 = v35 >> 32;
    int64_t v36 = v2; // 0x12b54
    int32_t v37 = function_11598(0x100000000 * v36 >> 63, (int32_t)v36, v35 >> 63, (int32_t)v32, -1, -1); // 0x12b6c
    int32_t v38 = (-0x3c5a37a4 * function_114c8((int64_t)v29, v29) + v37 >> 31) + v27; // 0x12bc0
    int64_t v39; // 0x12180
    int32_t v40 = v39; // 0x12bd0
    int64_t v41 = 0x100000000 * v39 >> 63; // 0x12be8
    int32_t v42 = function_11598(v41, v40, v41, v40, -1, -1) + v33; // 0x12bf0
    // 0x12c24
    return function_11598((int64_t)(v38 >> 31), v38, (int64_t)(v42 >> 31), v42, -1, -1);
}

// Address range: 0x12c34 - 0x12c42
int32_t function_12c34(int32_t a1, int32_t a2) {
    int32_t v1 = unknown_413278(); // 0x12c34
    int32_t v2 = *(int32_t *)(v1 + 4); // 0x12c3c
    *(int32_t *)v2 = v1 + 16;
    *(int32_t *)(v2 + 4) = *(int32_t *)v1;
    return -0x1d724ffc;
}

// Address range: 0x12c48 - 0x1373c
int32_t function_12c48(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x12c48
    int32_t v1; // 0x12c48
    int32_t * v2 = (int32_t *)(v1 - 3064); // 0x12c50
    *v2 = a1;
    int32_t * v3 = (int32_t *)(v1 - 3068); // 0x12c54
    *v3 = a2;
    int32_t * v4 = (int32_t *)(v1 - 3072); // 0x12c58
    *v4 = a3;
    int32_t * v5 = (int32_t *)(v1 - 3076); // 0x12c5c
    *v5 = a4;
    function_13b60(*v2, v1 - 196);
    uint32_t v6 = (int32_t)(*(int64_t *)(v1 - 148) / 0x100000000); // 0x12c70
    int32_t * v7 = (int32_t *)(v1 - 32); // 0x12c78
    *v7 = v6;
    int32_t v8 = *v2;
    if (v6 <= 2047) {
        // 0x12c88
        function_107bc("File '%s' Not Enough %d, Something Wrong!\n", v8, 2048, v6);
        // 0x13730
        return 6;
    }
    int32_t v9 = function_10798(v8, "rb", v6, (int32_t *)v6); // 0x12cb0
    int32_t * v10 = (int32_t *)(v1 - 36); // 0x12cb4
    *v10 = v9;
    if (v9 == 0) {
        // 0x12cc4
        function_107bc("Read File '%s' Failed!\n", *v2, v6, 0);
        // 0x13730
        return 7;
    }
    // 0x12cdc
    function_1082c((int32_t *)*v5, 2048, 1, v9);
    unsigned char v11 = *(char *)*v5; // 0x12cf4
    int32_t v12 = v11; // 0x12cf4
    if (v11 != 38) {
        // 0x12d00
        function_107bc("'%s' Not A Btmu File!\n", *v2, 1, v12);
        int32_t v13 = *v10; // 0x12d10
        if (v13 != 0) {
            // 0x12d1c
            function_10738(v13);
        }
        // 0x13730
        return 8;
    }
    // 0x12d2c
    function_107bc("miner_type %s\n", *v3, 1, v12);
    int32_t v14 = function_10780((int32_t *)*v3); // 0x12d40
    int32_t v15 = function_12180(*v3, v14, 1); // 0x12d50
    int32_t v16 = v1 - 44; // 0x12d54
    *(int32_t *)v16 = v15;
    *(int32_t *)(v1 - 40) = v14;
    int32_t v17 = *v5 + 2; // 0x12d5c
    int32_t v18 = v1 - 204; // 0x12d60
    int32_t * v19 = (int32_t *)v18; // 0x12d6c
    function_1078c(v19, v17, 8, v19);
    int64_t * v20 = (int64_t *)v16; // 0x12d78
    uint64_t v21 = *v20; // 0x12d78
    function_107bc("miner_type_hash %16llx, bmu_hash %16llx\n", v17, (int32_t)(v21 / 0x100000000), (int32_t)v21);
    uint64_t v22 = *(int64_t *)v18; // 0x12d88
    int32_t v23 = v22; // 0x12d88
    int32_t v24 = v22 / 0x100000000; // 0x12d88
    uint64_t v25 = *v20; // 0x12d8c
    int32_t v26 = v25; // 0x12d8c
    if (v26 == v23) {
        if ((int32_t)(v25 / 0x100000000) == v24) {
            char * v27 = (char *)(v1 - 5); // 0x12dc8
            *v27 = 0;
            int32_t v28 = __asm_sxth(256 * (int32_t)*(char *)(*v5 + 11)); // 0x12dd8
            uint32_t v29 = __asm_sxth(__asm_sxth((int32_t)*(char *)(*v5 + 12)) | v28); // 0x12dec
            int16_t * v30 = (int16_t *)(v1 - 46); // 0x12df0
            *v30 = (int16_t)v29;
            if (*(char *)(v1 + 12) != 0) {
                uint32_t v31 = v29 % 0x10000; // 0x12e00
                function_107bc("content:%x\n", v31, v28, v31);
                uint16_t v32 = *v30; // 0x12e14
                if (v32 <= 0xfdff) {
                    // 0x12e24
                    function_107f0("This Package Was Not Full Package!", v31, v28, (int32_t)(v32 & -512));
                    // 0x13730
                    return 20;
                }
            }
            int32_t * v33 = (int32_t *)(v1 - 12); // 0x12e3c
            *v33 = 0;
            int32_t v34 = 0; // 0x12e6c
            int32_t v35 = v34; // 0x12e58
            if ((1 << v34 & (int32_t)*v30) != 0) {
                // 0x12e5c
                *v27 = *v27 + 1;
                v35 = *v33;
            }
            // 0x12e68
            v34 = v35 + 1;
            *v33 = v34;
            while (v34 < 16) {
                // 0x12e44
                v35 = v34;
                if ((1 << v34 & (int32_t)*v30) != 0) {
                    // 0x12e5c
                    *v27 = *v27 + 1;
                    v35 = *v33;
                }
                // 0x12e68
                v34 = v35 + 1;
                *v33 = v34;
            }
            unsigned char v36 = *(char *)(*v5 + 1304); // 0x12e84
            unsigned char v37 = *v27; // 0x12e88
            int32_t v38 = v36;
            if (v37 != v36) {
                int32_t v39 = v37; // 0x12ea0
                function_107bc("Content Doesn't Match![%d][%d]\n", v38, v39, v39);
                int32_t v40 = *v10; // 0x12eb4
                if (v40 != 0) {
                    // 0x12ec0
                    function_10738(v40);
                }
                // 0x13730
                return 9;
            }
            int32_t * v41 = (int32_t *)(v1 - 16); // 0x12ee0
            *v41 = 256 * v38 + 2304;
            int32_t v42 = *v5; // 0x12ee4
            unsigned char v43 = *(char *)(v42 + 1305); // 0x12ee8
            unsigned char v44 = *(char *)(v42 + 1306); // 0x12ef4
            unsigned char v45 = *(char *)(v42 + 1307); // 0x12f04
            unsigned char v46 = *(char *)(v42 + 1308); // 0x12f14
            int32_t * v47 = (int32_t *)(v1 - 52); // 0x12f1c
            *v47 = 0x10000 * (int32_t)v44 | 0x1000000 * (int32_t)v43 | 256 * (int32_t)v45 | (int32_t)v46;
            int32_t * v48 = (int32_t *)(v1 - 20); // 0x12f24
            *v48 = 0;
            if (*v27 != 0) {
                int32_t * v49 = (int32_t *)(v1 - 88); // 0x12fd0
                int32_t v50 = *v5; // 0x12f40
                unsigned char v51 = *(char *)(v50 + 1310); // 0x12f4c
                unsigned char v52 = *(char *)(v50 + 1311); // 0x12f74
                unsigned char v53 = *(char *)(v50 + 1312); // 0x12f9c
                unsigned char v54 = *(char *)(v50 + 1313); // 0x12fc8
                int32_t v55 = 0x10000 * (int32_t)v52 | 0x1000000 * (int32_t)v51 | 256 * (int32_t)v53 | (int32_t)v54; // 0x12fcc
                *v49 = v55;
                int32_t v56 = v55 + *v41; // 0x12fdc
                *v41 = v56;
                function_107bc("file[%d] size:[%d]\n", *v48, *v49, v56);
                int32_t v57 = *v48 + 1; // 0x12ffc
                *v48 = v57;
                while (v57 < (int32_t)*v27) {
                    // 0x12f2c
                    v50 = *v5 + 5 * v57;
                    v51 = *(char *)(v50 + 1310);
                    v52 = *(char *)(v50 + 1311);
                    v53 = *(char *)(v50 + 1312);
                    v54 = *(char *)(v50 + 1313);
                    v55 = 0x10000 * (int32_t)v52 | 0x1000000 * (int32_t)v51 | 256 * (int32_t)v53 | (int32_t)v54;
                    *v49 = v55;
                    v56 = v55 + *v41;
                    *v41 = v56;
                    function_107bc("file[%d] size:[%d]\n", *v48, *v49, v56);
                    v57 = *v48 + 1;
                    *v48 = v57;
                }
            }
            int32_t v58 = *v41; // 0x13014
            int32_t v59 = *v7; // 0x13018
            if (v58 != v59) {
                int32_t v60 = *v47; // 0x1302c
                function_107bc("Check FileSize Failed, FileSize Should Be [%d]Bytes, But It Was [%d] Bytes, And Total Says[%d]\n", v60, v59, v58);
                int32_t v61 = *v10; // 0x1303c
                if (v61 != 0) {
                    // 0x13048
                    function_10738(v61);
                }
                // 0x13730
                return 10;
            }
            int32_t v62 = function_10798(*v4, "r", v58, (int32_t *)v58); // 0x13064
            int32_t * v63 = (int32_t *)(v1 - 56); // 0x13068
            *v63 = v62;
            if (v62 == 0) {
                // 0x13078
                function_107bc("Cannot Open Root PublicKey '%s'!\n", *v4, v58, 0);
                int32_t v64 = *v10; // 0x13088
                if (v64 != 0) {
                    // 0x13094
                    function_10738(v64);
                }
                // 0x13730
                return 11;
            }
            int32_t v65 = v1 - 1228; // 0x130a8
            int32_t * v66 = (int32_t *)v65; // 0x130a8
            *v66 = 0;
            int32_t * v67 = (int32_t *)(v1 - 1224); // 0x130c4
            function_10744(v67, 0, 1020, v67);
            function_1082c(v66, 1024, 1, *v63);
            function_10738(*v63);
            *v63 = 0;
            int32_t v68 = *v5; // 0x130f4
            unsigned char v69 = *(char *)(v68 + 23); // 0x13104
            int32_t v70 = 256 * (int32_t)*(char *)(v68 + 22) | (int32_t)v69; // 0x13108
            int32_t * v71 = (int32_t *)(v1 - 60); // 0x1310c
            *v71 = v70;
            int32_t v72 = *v5; // 0x13110
            int32_t v73 = v72 + 1048; // 0x13124
            int32_t v74 = function_10c70(v72 + 24, v70, v73, v65); // 0x13134
            int32_t * v75 = (int32_t *)(v1 - 64); // 0x13138
            *v75 = v74;
            if (v74 != 0) {
                // 0x13148
                function_107bc("Check pem payload failed! ret:[%d]\n", v74, v73, v74);
                int32_t v76 = *v10; // 0x13158
                if (v76 != 0) {
                    // 0x13164
                    function_10738(v76);
                }
                // 0x13730
                return *v75;
            }
            char * v77 = (char *)(v1 + 4); // 0x13174
            unsigned char v78 = *v77; // 0x13174
            if (v78 != 0) {
                int32_t v79 = function_10798((int32_t)"/tmp/tmpfw/miner.pem", "w", v73, (int32_t *)(int32_t)v78); // 0x13190
                int32_t * v80 = (int32_t *)(v1 - 68); // 0x13194
                *v80 = v79;
                if (v79 == 0) {
                    // 0x131ec
                    function_107f0("Dump Miner.pem Failed!\r", (int32_t)"w", v73, 0);
                    // 0x13730
                    return 15;
                }
                int32_t v81 = *v71; // 0x131ac
                function_107d4((int32_t *)(*v5 + 24), 1, v81, v79);
                function_10738(*v80);
                int32_t v82 = function_10798((int32_t)"/tmp/tmpfw/miner.pem.sig", "w", v81, (int32_t *)v79); // 0x131d4
                *v80 = v82;
                if (v82 == 0) {
                    // 0x13228
                    function_107f0("Dump Miner.pem.sig Failed!\r", (int32_t)"w", v81, 0);
                    // 0x13730
                    return 16;
                }
                // 0x13200
                function_107d4((int32_t *)(*v5 + 1048), 1, 256, v82);
                function_10738(*v80);
            }
            int32_t v83 = v1 - 2284; // 0x13244
            int32_t * v84 = (int32_t *)v83; // 0x13254
            function_10744(v84, 0, 1056, v84);
            int32_t * v85 = (int32_t *)(v1 - 2396); // 0x13268
            function_10820(v85);
            function_10808(v85, *v5, 2048, v85);
            function_10774(v84, v85, v85, v84);
            int32_t * v86 = (int32_t *)(v1 - 24); // 0x132b0
            *v86 = 0;
            if (*v27 != 0) {
                int32_t v87 = v1 - 2252; // 0x1336c
                int32_t v88 = *v5; // 0x132cc
                unsigned char v89 = *(char *)(v88 + 1310); // 0x132d8
                unsigned char v90 = *(char *)(v88 + 1311); // 0x13300
                unsigned char v91 = *(char *)(v88 + 1312); // 0x13328
                unsigned char v92 = *(char *)(v88 + 1313); // 0x13354
                int32_t v93 = 0x10000 * (int32_t)v90 | 0x1000000 * (int32_t)v89 | 256 * (int32_t)v91 | (int32_t)v92; // 0x13358
                *(int32_t *)(v1 - 84) = v93;
                int32_t v94 = *v86; // 0x13364
                unsigned char v95 = *(char *)(5 * v94 + 1309 + *v5); // 0x133a0
                function_10de8(*v10, v93, v87 + 32 * v94, (int32_t)v95, 0, (int32_t)*v77);
                int32_t v96 = *v86 + 1; // 0x133cc
                *v86 = v96;
                while (v96 < (int32_t)*v27) {
                    // 0x132b8
                    v88 = *v5 + 5 * v96;
                    v89 = *(char *)(v88 + 1310);
                    v90 = *(char *)(v88 + 1311);
                    v91 = *(char *)(v88 + 1312);
                    v92 = *(char *)(v88 + 1313);
                    v93 = 0x10000 * (int32_t)v90 | 0x1000000 * (int32_t)v89 | 256 * (int32_t)v91 | (int32_t)v92;
                    *(int32_t *)(v1 - 84) = v93;
                    v94 = *v86;
                    v95 = *(char *)(5 * v94 + 1309 + *v5);
                    function_10de8(*v10, v93, v87 + 32 * v94, (int32_t)v95, 0, (int32_t)*v77);
                    v96 = *v86 + 1;
                    *v86 = v96;
                }
            }
            int32_t * v97 = (int32_t *)(v1 - 28); // 0x133e8
            *v97 = 0;
            unsigned char v98 = *v27; // 0x13468
            if (v98 != 0) {
                int32_t v99 = 0; // 0x13460
                unsigned char v100 = *(char *)(5 * v99 + 1309 + *v5); // 0x13434
                unsigned char v101 = *v77; // 0x13438
                int32_t v102 = *v10; // 0x13454
                function_10de8(v102, 256, 32 * ((int32_t)v98 + 1 + v99) + v83, (int32_t)v100, 1, (int32_t)v101);
                v99 = *v97 + 1;
                *v97 = v99;
                int32_t v103 = (int32_t)*v27; // 0x13468
                while (v99 < v103) {
                    // 0x133f0
                    v100 = *(char *)(5 * v99 + 1309 + *v5);
                    v101 = *v77;
                    v102 = *v10;
                    function_10de8(v102, 256, 32 * (v103 + 1 + v99) + v83, (int32_t)v100, 1, (int32_t)v101);
                    v99 = *v97 + 1;
                    *v97 = v99;
                    v103 = (int32_t)*v27;
                }
            }
            int32_t v104 = v1 - 2652; // 0x1347c
            int32_t * v105 = (int32_t *)v104; // 0x1347c
            *v105 = 0;
            int32_t * v106 = (int32_t *)(v1 - 2648); // 0x13498
            function_10744(v106, 0, 252, v106);
            function_1075c(*v10, -256, 2);
            function_1082c(v105, 256, 1, *v10);
            int32_t v107 = v1 - 2684; // 0x134cc
            int32_t * v108 = (int32_t *)v107; // 0x134cc
            *v108 = 0;
            *(int32_t *)(v1 - 2680) = 0;
            *(int32_t *)(v1 - 2676) = 0;
            *(int32_t *)(v1 - 2672) = 0;
            *(int32_t *)(v1 - 2668) = 0;
            *(int32_t *)(v1 - 2664) = 0;
            *(int32_t *)(v1 - 2660) = 0;
            *(int32_t *)(v1 - 2656) = 0;
            int32_t * v109 = (int32_t *)(v1 - 2796); // 0x1350c
            function_10820(v109);
            function_10808(v109, v83, 64 * (int32_t)*v27 | 32, v109);
            function_10774(v108, v109, v109, v108);
            int32_t * v110 = (int32_t *)(v1 - 72); // 0x13568
            *v110 = 0;
            int32_t * v111 = (int32_t *)(v1 - 76); // 0x13570
            *v111 = 0;
            int32_t v112 = function_107a4(*v5 + 24, 1024); // 0x13584
            *v110 = v112;
            int32_t v113 = function_10768(v112, 0, 0, 0); // 0x1359c
            *v111 = v113;
            if (v113 == 0) {
                int32_t v114 = function_107c8(function_10714(0), 0); // 0x135c0
                function_107bc("OpenSSL error: %s\n", v114, 0, v114);
                function_107f0("Load Pem Failed!", v114, 0, v114);
                // 0x13730
                return 17;
            }
            int32_t v115 = function_10750(672, v108, 32, v104, 256, v113); // 0x1361c
            int32_t * v116 = (int32_t *)(v1 - 80); // 0x13620
            *v116 = v115;
            int32_t v117 = *v111; // 0x13624
            if (v117 != 0) {
                // 0x13630
                function_107fc(v117);
            }
            int32_t v118 = *v110; // 0x13638
            if (v118 != 0) {
                // 0x13644
                function_10814(v118);
            }
            int32_t v119 = *v116; // 0x1364c
            if (v119 != 1) {
                int32_t v120 = function_107f0("Check File Sig failed!\r", v107, 32, v119); // 0x13660
                int32_t v121 = function_107c8(function_10714(v120), 0); // 0x13674
                function_107bc("OpenSSL error: %s\n", v121, 32, v121);
                // 0x13730
                return 18;
            }
            int32_t v122 = *v10; // 0x13694
            if (v122 != 0) {
                // 0x136a0
                function_10738(v122);
            }
            // 0x136a8
            *v10 = 0;
            function_107f0("All Done!\r", v107, 32, 0);
            unsigned char v123 = *(char *)(v1 + 8); // 0x136bc
            if (v123 != 0) {
                // 0x136c8
                function_107f0("This Comment Of This Package:", v107, 32, (int32_t)v123);
                int32_t v124 = v1 - 3056; // 0x136d8
                int32_t * v125 = (int32_t *)v124; // 0x136d8
                *v125 = 0;
                int32_t * v126 = (int32_t *)(v1 - 3052); // 0x136f4
                function_10744(v126, 0, 253, v126);
                int32_t v127 = *v5 + 1360; // 0x136fc
                function_1078c(v125, v127, 256, v125);
                function_107f0((char *)v124, v127, 256, v124);
            }
            // 0x13730
            return 0;
        }
    }
    // 0x12d9c
    function_107f0("input miner_type and bmu miner type donot match!", v26, v24, v23);
    int32_t v128 = *v10; // 0x12da8
    if (v128 != 0) {
        // 0x12db4
        function_10738(v128);
    }
    // 0x13730
    return 30;
}

// Address range: 0x1373c - 0x13b20
int32_t function_1373c(uint32_t a1, int32_t a2) {
    // 0x1373c
    if (a1 <= 1) {
        // 0x13b14
        return 1;
    }
    int32_t * v1 = (int32_t *)(a2 + 4); // 0x13780
    if (*(char *)*v1 != 45) {
        // 0x13b14
        return 2;
    }
    int32_t v2 = 0; // bp-272, 0x137ac
    int32_t v3; // bp-268, 0x1373c
    function_10744(&v3, 0, 252, &v3);
    int32_t v4 = 0; // bp-400, 0x137c8
    int32_t v5; // bp-396, 0x1373c
    function_10744(&v5, 0, 124, &v5);
    int32_t v6 = 0; // bp-528, 0x137e4
    int32_t v7; // bp-524, 0x1373c
    function_10744(&v7, 0, 124, &v7);
    int32_t v8; // bp-2576, 0x1373c
    function_10744(&v8, 0, 2048, &v8);
    int32_t v9; // bp-2832, 0x1373c
    function_10744(&v9, 0, 253, &v9);
    int32_t v10 = 0; // 0x1373c
    int32_t v11 = 253; // 0x1373c
    switch (a1) {
        case 5: {
            int32_t * v12 = (int32_t *)(a2 + 8); // 0x13868
            uint32_t v13 = function_10780((int32_t *)*v12); // 0x13870
            if (v13 != 255 && v13 >= 255) {
                // 0x13880
                function_107f0("fileName Too Long!", 0, 253, v13);
                // 0x13b14
                return 3;
            }
            int32_t v14 = *v12; // 0x1389c
            function_107b0(&v2, v14);
            int32_t * v15 = (int32_t *)(a2 + 12); // 0x138b8
            uint32_t v16 = function_10780((int32_t *)*v15); // 0x138c0
            if (v16 != 127 && v16 >= 127) {
                // 0x138d0
                function_107f0("fileName Too Long!", v14, v14, v16);
                // 0x13b14
                return 3;
            }
            int32_t v17 = *v15; // 0x138ec
            function_107b0(&v4, v17);
            int32_t * v18 = (int32_t *)(a2 + 16); // 0x13908
            uint32_t v19 = function_10780((int32_t *)*v18); // 0x13910
            if (v19 != 127 && v19 >= 127) {
                // 0x13920
                function_107f0("pemName Too Long!", v17, v17, v19);
                // 0x13b14
                return 4;
            }
            int32_t v20 = *v18; // 0x1393c
            function_107b0(&v6, v20);
            v10 = v20;
            v11 = v20;
        }
        case 2: {
          lab_0x139e4:;
            unsigned char v21 = *(char *)(*v1 + 1); // 0x139fc
            int32_t v22 = (int32_t)v21 - 102; // 0x13a00
            g6 = v22;
            int32_t result; // 0x1373c
            switch (v21) {
                case 102: {
                }
                case 120: {
                }
                case 115: {
                }
                case 112: {
                    // 0x13a8c
                    result = &v4;
                    // break -> 0x13b14
                    break;
                }
                case 113: {
                    // 0x13ae0
                    result = function_10b9c();
                    // break -> 0x13b14
                    break;
                }
                case 110: {
                    // 0x13acc
                    result = function_109a8(&v4);
                    // break -> 0x13b14
                    break;
                }
                default: {
                    // 0x13aec
                    function_107f0("Command Not Support!", v10, v11, v22);
                    result = 5;
                    // break -> 0x13b14
                    break;
                }
            }
            // 0x13b14
            return result;
        }
        case 3: {
            int32_t * v23 = (int32_t *)(a2 + 8); // 0x13968
            uint32_t v24 = function_10780((int32_t *)*v23); // 0x13970
            if (v24 != 127 && v24 >= 127) {
                // 0x13980
                function_107f0("fileName Too Long!", 0, 253, v24);
                // 0x13b14
                return 3;
            }
            int32_t v25 = *v23; // 0x1399c
            function_107b0(&v4, v25);
            v10 = v25;
            v11 = v25;
            // branch (via goto) -> 0x139e4
            goto lab_0x139e4;
        }
        default: {
            // 0x139c0
            function_107f0("Param Err!", 0, 253, a1);
            // 0x13b14
            return 3;
        }
    }
}

// Address range: 0x13b20 - 0x13b54
int32_t function_13b20(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = function_106e8(a1, a2, a3, a4); // 0x13b30
    return 0x24f0a - (int32_t)&g1 >> 2 == 0 ? v1 : a1;
}

// Address range: 0x13b5c - 0x13b5e
int32_t function_13b5c(void) {
    // 0x13b5c
    int32_t result; // 0x13b5c
    return result;
}

// Address range: 0x13b60 - 0x13b64
int32_t function_13b60(int32_t result, int32_t a2) {
    // 0x13b60
    bool v1; // 0x13b60
    if (v1) {
        // branch -> 
    }
    return result;
}

// Address range: 0x13b64 - 0x13b6a
int32_t function_13b64(void) {
    // 0x13b64
    return function_107e0();
}

// Address range: 0x13b6c - 0x13b74
int32_t function_13b6c(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x13b6c
    return result;
}

// Address range: 0xe0832002 - 0xe0832003
int32_t function_e0832002(void) {
    // 0xe0832002
    int32_t result; // 0xe0832002
    return result;
}

// Address range: 0xe1a00003 - 0xe1a00004
int32_t function_e1a00003(void) {
    // 0xe1a00003
    int32_t result; // 0xe1a00003
    return result;
}

// Address range: 0xe1a02003 - 0xe1a02004
int32_t function_e1a02003(void) {
    // 0xe1a02003
    int32_t result; // 0xe1a02003
    return result;
}

// Address range: 0xe1a03000 - 0xe1a03001
int32_t function_e1a03000(void) {
    // 0xe1a03000
    int32_t result; // 0xe1a03000
    return result;
}

// Address range: 0xe1a0c002 - 0xe1a0c003
int32_t function_e1a0c002(void) {
    // 0xe1a0c002
    int32_t result; // 0xe1a0c002
    return result;
}

// Address range: 0xe1a0e003 - 0xe1a0e004
int32_t function_e1a0e003(void) {
    // 0xe1a0e003
    int32_t result; // 0xe1a0e003
    return result;
}

// Address range: 0xe2433004 - 0xe2433005
int32_t function_e2433004(void) {
    // 0xe2433004
    int32_t result; // 0xe2433004
    return result;
}

// Address range: 0xe243300c - 0xe243300d
int32_t function_e243300c(void) {
    // 0xe243300c
    int32_t result; // 0xe243300c
    return result;
}

// Address range: 0xe24b3e51 - 0xe24b3e52
int32_t function_e24b3e51(void) {
    // 0xe24b3e51
    int32_t result; // 0xe24b3e51
    return result;
}

// Address range: 0xe3033f1c - 0xe3033f1d
int32_t function_e3033f1c(void) {
    // 0xe3033f1c
    int32_t result; // 0xe3033f1c
    return result;
}

// Address range: 0xe3403001 - 0xe3403002
int32_t function_e3403001(void) {
    // 0xe3403001
    int32_t result; // 0xe3403001
    return result;
}

// Address range: 0xe58c0000 - 0xe58c0001
int32_t function_e58c0000(void) {
    // 0xe58c0000
    int32_t result; // 0xe58c0000
    return result;
}

// Address range: 0xe58c1004 - 0xe58c1005
int32_t function_e58c1004(void) {
    // 0xe58c1004
    int32_t result; // 0xe58c1004
    return result;
}

// Address range: 0xe58c2008 - 0xe58c2009
int32_t function_e58c2008(void) {
    // 0xe58c2008
    int32_t result; // 0xe58c2008
    return result;
}

// Address range: 0xe58c300c - 0xe58c300d
int32_t function_e58c300c(void) {
    // 0xe58c300c
    int32_t result; // 0xe58c300c
    return result;
}

// Address range: 0xe8be000f - 0xe8be0010
int32_t function_e8be000f(void) {
    // 0xe8be000f
    int32_t result; // 0xe8be000f
    return result;
}

// Address range: 0xea00004f - 0xea000050
int32_t function_ea00004f(void) {
    // 0xea00004f
    int32_t result; // 0xea00004f
    return result;
}

// Address range: 0xebfffdd2 - 0xebfffdd3
int32_t function_ebfffdd2(void) {
    // 0xebfffdd2
    int32_t result; // 0xebfffdd2
    return result;
}

// Address range: 0xff86c4c8 - 0xff86c4c9
int32_t function_ff86c4c8(void) {
    // 0xff86c4c8
    int32_t result; // 0xff86c4c8
    return result;
}

// Address range: 0xff86c848 - 0xff86c849
int32_t function_ff86c848(void) {
    // 0xff86c848
    int32_t result; // 0xff86c848
    return result;
}

// Address range: 0xff86ce70 - 0xff86ce71
int32_t function_ff86ce70(void) {
    // 0xff86ce70
    int32_t result; // 0xff86ce70
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.4.3)
// Detected functions: 79

