//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <arpa/inet.h>
#include <assert.h>
#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <locale.h>
#include <math.h>
#include <netdb.h>
#include <pthread.h>
#include <sched.h>
#include <semaphore.h>
#include <signal.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stropts.h>
#include <sys/mman.h>
#include <sys/prctl.h>
#include <sys/resource.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/syslog.h>
#include <sys/time.h>
#include <sys/uio.h>
#include <time.h>
#include <unistd.h>

// ---------------- Integer Types Definitions -----------------

typedef int8_t int2_t;
typedef int8_t int4_t;
typedef int32_t int31_t;

// ----------------- Float Types Definitions ------------------

typedef float float32_t;
typedef double float64_t;
typedef long double float128_t;

// ------------------------ Structures ------------------------

struct struct1 {
    int32_t e0;
    int32_t e1;
};

struct _IO_FILE {
    int32_t e0;
};

struct _TYPEDEF_glob64_t {
    int32_t e0;
    char ** e1;
    int32_t e2;
    int32_t e3;
    void (*e4)(int32_t *);
    struct dirent64 * (*e5)(int32_t *);
    int32_t * (*e6)(char *);
    int32_t (*e7)(char *, struct stat64 *);
    int32_t (*e8)(char *, struct stat64 *);
};

struct _TYPEDEF_lldiv_t {
    int64_t e0;
    int64_t e1;
};

struct _TYPEDEF_sigset_t {
    int32_t e0[1];
};

struct dirent64 {
    int32_t e0;
    int32_t e1;
    int16_t e2;
    char e3;
    char e4[256];
};

struct hostent {
    char * e0;
    char ** e1;
    int32_t e2;
    int32_t e3;
    char ** e4;
};

struct iovec {
    int32_t * e0;
    int32_t e1;
};

struct lconv {
    char * e0;
    char * e1;
    char * e2;
    char * e3;
    char * e4;
    char * e5;
    char * e6;
    char * e7;
    char * e8;
    char * e9;
    char e10;
    char e11;
    char e12;
    char e13;
    char e14;
    char e15;
    char e16;
    char e17;
    char e18;
    char e19;
    char e20;
    char e21;
    char e22;
    char e23;
};

struct sigaction {
    void (*e0)(int32_t);
    int32_t e1;
    void (*e2)();
    struct _TYPEDEF_sigset_t e3;
};

struct sockaddr {
    int32_t e0;
    char e1[14];
};

struct stat64 {
    int64_t e0;
    int64_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int64_t e6;
    int64_t e7;
    int64_t e8;
    int32_t e9;
    int32_t e10;
    int64_t e11;
    int32_t e12;
    int32_t e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int32_t e17;
    int32_t e18;
    int32_t e19;
};

struct sysinfo {
    int32_t e0;
    int32_t e1[3];
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int16_t e8;
    int16_t e9;
    int32_t e10;
    int32_t e11;
    int32_t e12;
    char e13[1];
};

struct timespec {
    int32_t e0;
    int32_t e1;
};

struct timeval {
    int32_t e0;
    int32_t e1;
};

struct rusage {
    struct timeval e0;
    struct timeval e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    int32_t e12;
    int32_t e13;
    int32_t e14;
    int32_t e15;
};

struct timezone {
    int32_t e0;
    int32_t e1;
};

struct tm {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    char * e10;
};

// ------------------- Function Prototypes --------------------

int32_t entry_point(int32_t a1, int32_t a2);
int32_t fgetc2(struct _IO_FILE * stream);
int32_t free(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_1012ea(void);
int32_t function_1018036(void);
int32_t function_1055066(void);
int32_t function_1055076(void);
int32_t function_105dac6(void);
int32_t function_1062b06(void);
int32_t function_10654da(void);
int32_t function_107471e(void);
int32_t function_107832e(void);
int32_t function_10d996(void);
int32_t function_113aa82(void);
int32_t function_113afb2(void);
int32_t function_1178342(void);
int32_t function_117a842(void);
int32_t function_119f78a(void);
int32_t function_11b08e6(void);
int32_t function_11bab0a(void);
int32_t function_11bacb6(void);
int32_t function_11c472e(void);
int32_t function_11c474e(void);
int32_t function_11c476e(void);
int32_t function_11d63d2(void);
int32_t function_11d66b2(void);
int32_t function_11db9b4(void);
int32_t function_11e2326(void);
int32_t function_11e4b8a(void);
int32_t function_11e4bb2(void);
int32_t function_11e84(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_11ea4(int32_t * a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_11eb0(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_11ebc(int32_t * a1, int32_t a2, int32_t a3);
int32_t function_11ec8(int32_t a1);
int32_t function_11ed4(int32_t * a1);
int32_t function_11ee0(int32_t a1);
int32_t function_11eec(int32_t a1, char * a2, int32_t a3, int32_t a4);
int32_t function_11ef8(int32_t * a1, int32_t a2, int32_t a3);
int32_t function_11f04(int32_t * a1);
int32_t function_11f10(int32_t a1);
int32_t function_11f1c(int32_t a1, int32_t a2, int32_t a3, int32_t * a4, int32_t a5);
int32_t function_11f28(int32_t a1, int32_t ** a2, int32_t a3, int32_t a4);
int32_t function_11f34(char * a1, int32_t * a2, int32_t a3, int32_t a4);
int32_t function_11f40(int32_t a1, int32_t a2, int32_t a3);
int32_t function_11f4c(int32_t a1);
int32_t function_11f58(int32_t a1);
int32_t function_11f64(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_11f70(int32_t a1, int32_t a2);
int32_t function_11f88(int32_t * a1, int32_t a2, int32_t a3);
int32_t function_11f917e(void);
int32_t function_11f94(int32_t * a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_11fa0(int32_t a1);
int32_t function_11fac(int32_t a1, int32_t * a2);
int32_t function_11fad6a(void);
int32_t function_11fb8(void);
int32_t function_11fc4(int32_t * a1, int32_t a2, char a3, int32_t a4);
int32_t function_11fd0(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_11fdc(int32_t a1, int32_t a2);
int32_t function_11fe8(int32_t a1);
int32_t function_11ff4(int32_t * a1);
int32_t function_12000(int32_t a1);
int32_t function_1200042(void);
int32_t function_1200c(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_12018(int32_t a1);
int32_t function_12024(int32_t * a1, int32_t * a2);
int32_t function_12030(int32_t a1);
int32_t function_1203c(int32_t a1, int32_t a2);
int32_t function_12048(int32_t a1);
int32_t function_12054(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t * a5, int32_t * a6);
int32_t function_12060(int32_t a1);
int32_t function_1206c(int32_t a1);
int32_t function_12078(int32_t a1, int32_t a2);
int32_t function_12084(int32_t a1, int32_t a2);
int32_t function_12090(int32_t a1);
int32_t function_1209c(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_120a8(int32_t * a1, int32_t * a2);
int32_t function_120b4(int32_t a1);
int32_t function_120c0(char * s1, char * s2);
void function_120cc(char * s);
int32_t function_120d8(int32_t fd, struct sockaddr * addr, int32_t * addr_len);
int32_t function_120e4(int32_t ver, int32_t fildes, struct stat64 * stat_buf);
int32_t function_120f0(int32_t sig, struct sigaction * act, struct sigaction * oact);
int32_t function_120fc(int32_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s);
char * function_12108(char * dest, char * src);
int32_t function_12114(int32_t fd, int32_t request, ...);
int32_t function_12120(int32_t fd, int32_t offset, int32_t whence);
int64_t function_1212c(char * nptr, char ** endptr, int32_t base);
int32_t function_12138(int32_t useconds);
char * function_12144(char * dest, char * src);
int32_t function_12150(struct timeval * tv, struct timezone * tz);
int32_t function_1215c(int32_t * ptr, int32_t size, int32_t n, struct _IO_FILE * stream);
int32_t function_12168(void);
int32_t function_12174(int32_t * newthread, int32_t * attr, int32_t * (*start_routine)(int32_t *), int32_t * arg);
int32_t function_12180(char * name, int32_t len);
float32_t function_1218c(char * nptr, char ** endptr);
int32_t function_12198(char * file, int32_t oflag, ...);
char * function_121a4(char * name);
int32_t function_121adfa(void);
int32_t function_121b0(char * s);
int32_t function_121b0c6(void);
int32_t function_121b256(void);
int32_t function_121bc(struct sysinfo * info);
int32_t function_121d4(int32_t main, int32_t argc, char ** ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)());
char * function_121e0(int32_t errnum);
int32_t function_121ec(char * s, int32_t maxsize, char * format, struct tm * tp);
struct tm * function_121f8(int32_t * timer);
int32_t ** function_12204(void);
int32_t ** function_12210(void);
void function_1221c(void);
int32_t function_12228(int32_t * sem);
int32_t function_12234(char * old, char * new);
int16_t ** function_12240(void);
int32_t function_122465e(void);
int32_t function_1224c(void);
void function_12258(int32_t status);
int32_t function_12264(int32_t sysno, ...);
int32_t function_12270(int32_t * sem, struct timespec * abstime);
int32_t function_1227c(char * nptr, char ** endptr, int32_t base);
int32_t function_12288(char * s);
char * function_122a0(char * s, int32_t c);
int32_t function_122ac(int32_t type, int32_t * oldtype);
int32_t function_122b8(struct _IO_FILE * stream, char * format, ...);
int32_t function_122c4(int32_t fd, int32_t cmd, ...);
float64_t function_122d0(float64_t a1);
int32_t function_122dc(int32_t * attr);
int32_t * function_122e8(void);
int32_t function_122f4(char * s1, char * s2, int32_t n);
int32_t function_12300(char * s, int32_t maxlen, char * format, ...);
int32_t function_1230c(void (*func)(int32_t *), int32_t * arg, int32_t * dso_handle);
int32_t function_1231c(int32_t a1, char * a2, int32_t * a3, int32_t a4);
char * function_12328(char * string);
int32_t function_12334(char * path, int32_t mode);
int32_t function_12340(int32_t fd, struct sockaddr * addr, int32_t len);
int32_t function_1234c(int32_t * sem, int32_t pshared, int32_t value);
int32_t * function_12358(int32_t * s, int32_t c, int32_t n);
int32_t function_12364(int32_t * rwlock);
int32_t function_1236dfe(void);
char * function_12370(char * dest, char * src, int32_t n);
int32_t function_1237bfa(void);
int32_t function_1237c(int32_t th);
int32_t function_12394(int32_t option, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5);
float64_t function_123a0(char * nptr, char ** endptr);
int32_t function_123ac(int32_t fd, int32_t * buf, int32_t n);
int32_t function_123b8(struct _IO_FILE * stream);
int32_t function_123c4(char * name, int32_t type);
int32_t function_123d0(struct _IO_FILE * stream);
int32_t function_123dc(int32_t * addr, int32_t len);
char * function_123e8(char * s, char * delim);
int32_t function_123f4(char * pattern, int32_t flags, int32_t (*errfunc)(char *, int32_t), struct _TYPEDEF_glob64_t * pglob);
int32_t function_12400(int32_t * cond, int32_t * mutex, struct timespec * abstime);
int32_t function_1240c(int32_t key, int32_t * pointer);
int32_t function_12418(struct _TYPEDEF_sigset_t * set);
struct _IO_FILE * function_12424(char * command, char * modes);
int32_t function_12430(int32_t * rwlock);
void function_1243c(int32_t status, char * format, ...);
char * function_12448(char * s, int32_t c);
int32_t function_1244bf2(void);
int32_t function_12454(int32_t fd, int32_t n);
int32_t function_12460(struct _IO_FILE * s, char * format, int32_t arg);
int32_t function_1246c(int32_t th, int32_t ** thread_return);
struct _TYPEDEF_lldiv_t function_12478(int64_t numer, int64_t denom);
int32_t function_12484(int32_t c, struct _IO_FILE * stream);
void function_12490(struct _TYPEDEF_glob64_t * pglob);
void function_1249c(int32_t pri, char * fmt, ...);
int32_t function_124a4ee(void);
int32_t function_124a59e(void);
int32_t function_124a8(char * s, char * format, ...);
struct lconv * function_124b4(void);
int32_t function_124c0(char * s, char * format, ...);
void function_124cc(char * ident, int32_t option, int32_t facility);
int32_t function_124d8(char * s, int32_t maxlen, char * format, int32_t arg);
struct _IO_FILE * function_124e4(char * filename, char * modes);
void function_124f0(int32_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int32_t *, int32_t *));
char * function_124fc(char * s, char * accept2);
int32_t function_12508(int32_t * cond, int32_t * mutex);
int32_t function_12514(int32_t domain, int32_t type, int32_t protocol);
int32_t function_12520(int32_t clock_id, int32_t flags, struct timespec * req, struct timespec * rem);
int32_t function_1252c(char * cp);
int32_t function_12538(void);
void function_12544(void);
struct hostent * function_12550(char * name);
int32_t function_1255c(struct _IO_FILE * stream, int32_t off, int32_t whence);
int32_t function_12568(int32_t * sem);
int32_t function_12574(int32_t ver, char * filename, struct stat64 * stat_buf);
int32_t function_12580(int32_t fd);
int32_t function_1258c(char * s, struct _IO_FILE * stream);
int32_t function_12598(char * s1, char * s2, int32_t n);
int32_t function_125a4(int32_t * cond);
void function_125b0(void);
int32_t function_125bc(int32_t fd, int32_t * buf, int32_t n, int32_t flags);
int32_t function_125bc7c(void);
int32_t function_125c8(int32_t fd);
int32_t function_125d4(int32_t ver, char * filename, struct stat64 * stat_buf);
int32_t function_125e0(int32_t fd, int32_t * buf, int32_t n, int32_t flags);
int32_t function_125ec(int32_t fd, struct sockaddr * addr, int32_t len);
void function_125f8(char * assertion, char * file, int32_t line, char * function);
int32_t * function_12604(int32_t key);
int32_t function_12610(struct _IO_FILE * stream);
int32_t function_1261622(void);
int32_t function_12620(int32_t a1, int32_t a2);
int32_t function_12651ae(void);
int32_t function_12651ca(void);
int32_t function_1265296(void);
int32_t function_126562a(void);
int32_t function_1275146(void);
int32_t function_127aa6a(void);
int32_t function_127aa6e(void);
int32_t function_127af7e(void);
int32_t function_127b15e(void);
int32_t function_127b1da(void);
int32_t function_127b1fa(void);
int32_t function_128c2b2(void);
int32_t function_1308fe(void);
int32_t function_132233a(void);
int32_t function_13afa2(void);
int32_t function_13c44(int32_t result, int32_t a2, int32_t a3);
int32_t function_13c50(void);
int32_t function_13c74(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_13cd0(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_13cdc(void);
int32_t function_13ce0(uint32_t a1);
int32_t function_13da4(int32_t a1, int32_t a2);
int32_t function_13fb0(int32_t a1);
int32_t function_140e0(void);
int32_t function_140e4(void);
int32_t function_14148(void);
int32_t function_141b4(void);
int32_t function_1420180(void);
int32_t function_1420544(void);
int32_t function_1420804(void);
int32_t function_1420ec4(void);
int32_t function_14218(void);
int32_t function_1427c(int32_t a1, int32_t a2);
int32_t function_142bc(int32_t a1, int32_t a2, int32_t a3, int32_t result, char * a5);
int32_t function_14434(void);
int32_t function_14454(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_144d27c(void);
int32_t function_146c8(uint32_t a1);
int32_t function_14cc0(int32_t a1, int32_t a2, uint32_t a3);
int32_t function_14d60(int32_t a1, int32_t a2, int32_t a3);
int32_t function_14dd8(int32_t a1, int32_t a2, uint32_t a3);
int32_t function_14e90(int32_t a1, int32_t a2);
int32_t function_14ed0(int32_t a1);
int32_t function_14f20(void);
int32_t function_14fa4(void);
int32_t function_14fadae(void);
int32_t function_15150(void);
int32_t function_151eb2(void);
int32_t function_15210(int32_t a1);
int32_t function_152f0(int32_t a1, int32_t a2);
int32_t function_15354(int32_t a1, int32_t a2);
int32_t function_153a0(int32_t a1, int32_t a2);
int32_t function_153ec(int32_t a1, uint32_t a2);
int32_t function_154a8(int32_t a1);
int32_t function_15508(void);
int32_t function_15550(void);
int32_t function_15564(void);
int32_t function_155b0(void);
int32_t function_155c4(void);
int32_t function_15610(int32_t a1, uint32_t a2);
int32_t function_156cc(int32_t a1);
int32_t function_1572c(void);
int32_t function_15760(void);
int32_t function_15774(void);
int32_t function_157ac(void);
int32_t function_157c0(void);
int32_t function_157f8(int32_t a1, int32_t a2);
int32_t function_1585c(void);
int32_t function_158fa4c(void);
int32_t function_15a2dd4(void);
int32_t function_15f7ba(void);
int32_t function_16284(int32_t a1, int32_t a2);
int32_t function_16290(int32_t a1, int32_t a2);
int32_t function_1629c(void);
int32_t function_162b0(void);
int32_t function_162c4(int32_t a1, int32_t a2);
int32_t function_16330(int32_t a1);
int32_t function_16378(void);
int32_t function_16580(void);
int32_t function_1697c(int32_t a1);
int32_t function_169c0(int32_t a1);
int32_t function_16a04(void);
int32_t function_16bd8(uint32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_17240(void);
int32_t function_17244(int32_t result, int32_t * a2, uint32_t a3);
int32_t function_1726bda(void);
int32_t function_1726fe2(void);
int32_t function_172b12(void);
int32_t function_172b21e(void);
int32_t function_173faa(void);
int32_t function_1740c(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_1753a2(void);
int32_t function_175dda2(void);
int32_t function_17a7d66(void);
int32_t function_17ab12(void);
int32_t function_17b002(void);
int32_t function_17b1fe(void);
int32_t function_17e8422(void);
int32_t function_17ef8(void);
int32_t function_17f7c(void);
int32_t function_17f90(void);
int32_t function_17fd8(int32_t result, int32_t * str2, uint32_t size);
int32_t function_18094(int32_t a1);
int32_t function_18128(int32_t a1);
int32_t function_18153fa(void);
int32_t function_181bc(void);
int32_t function_181c4(int32_t a1, int32_t a2);
int32_t function_18258(int32_t a1, int32_t a2);
int32_t function_182fc(int32_t a1, int32_t * a2);
int32_t function_18360(int32_t a1, int32_t * str2, uint32_t size);
int32_t function_183fc(int32_t a1, char a2, int32_t a3);
int32_t function_18654(int32_t a1, int32_t a2, int32_t * a3);
int32_t function_188a0(int32_t a1, char a2, int32_t * a3);
int32_t function_18948(int32_t a1, int32_t a2, int32_t a3);
int32_t function_18a0c(void);
int32_t function_18a14(void);
int32_t function_18b30(uint32_t a1);
int32_t function_18b68(int32_t a1);
int32_t function_18bc0(int32_t a1);
int32_t function_18be3a(void);
int32_t function_18c18(int32_t result, int32_t a2, int32_t a3);
int32_t function_18c40(int32_t a1);
int32_t function_18ce8(int32_t a1, int32_t a2, int32_t a3);
int32_t function_18d98(int32_t a1, int32_t a2, int32_t a3);
int32_t function_18e48(int32_t result, uint32_t a2, int32_t a3);
int32_t function_18ef0(int32_t result);
int32_t function_18f00(void);
int32_t function_18f10(int32_t result, int32_t a2, int32_t a3);
int32_t function_19074(int32_t result, int32_t a2, int32_t a3);
int32_t function_191dc(int32_t a1);
int32_t function_191f4(int32_t a1);
int32_t function_191f8(int32_t a1);
int32_t function_191fc(int32_t a1);
int32_t function_19214(uint32_t a1);
int32_t function_192c8(uint32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_1934e6(void);
int32_t function_19394(int32_t a1);
int32_t function_193c6(void);
int32_t function_193d4(void);
int32_t function_193f4(int32_t a1, int32_t a2);
int32_t function_1948a(void);
int32_t function_1948e(int32_t a1, uint32_t a2);
int32_t function_19496(void);
int32_t function_194a0(void);
int32_t function_194a6(void);
int32_t function_194b0(void);
int32_t function_194b4(void);
int32_t function_194c4(void);
int32_t function_194dc(void);
int32_t function_194f0(void);
int32_t function_195a8(int32_t a1);
int32_t function_19606(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_19630(int32_t a1, int32_t a2);
int32_t function_19638(int32_t a1, int32_t a2);
int32_t function_19698(int32_t a1, int32_t a2, int32_t a3, int32_t * a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9);
int32_t function_1996e(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_199bc(int32_t a1, int32_t a2);
int32_t function_199c4(void);
int32_t function_199ce(void);
int32_t function_199d0(int32_t a1, int32_t a2);
int32_t function_199e0(void);
int32_t function_199f0(void);
int32_t function_19a44(void);
int32_t function_19ab4(void);
int32_t function_19ac4(void);
int32_t function_19ad6(int32_t a1, int32_t a2, int32_t a3);
int32_t function_19ae6(void);
int32_t function_19aec(int32_t a1, int32_t a2);
int32_t function_19b4c(int32_t a1);
int32_t function_19b50(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_19b5c(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_19ba0(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_19cb8(int32_t a1);
int32_t function_19cbc(int32_t str, int32_t a2, uint32_t a3);
int32_t function_19ce0(void);
int32_t function_19cec(void);
int32_t function_19d112(void);
int32_t function_19d3c(int32_t a1, int32_t a2);
int32_t function_19d50(int32_t a1, int32_t a2);
int32_t function_19d60(int32_t a1, int32_t a2);
int32_t function_19d70(int32_t a1, int32_t a2, int32_t a3, int32_t * a4);
int32_t function_19de4(int32_t a1);
int32_t function_19e68(void);
int32_t function_19e92(void);
int32_t function_19e94(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_19f00(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t function_19f0c(void);
int32_t function_19f1a(void);
int32_t function_19f1c(void);
int32_t function_19f5c(void);
int32_t function_19f98(void);
int32_t function_19fe4(void);
int32_t function_1a014(void);
int32_t function_1a062(void);
int32_t function_1a064(void);
int32_t function_1a082(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_1a088(int32_t result);
int32_t function_1a08c(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_1a0f0(void);
int32_t function_1a104(void);
int32_t function_1a10a(int32_t a1);
int32_t function_1a10c(int32_t a1);
int32_t function_1a12a(int32_t a1);
int32_t function_1a130(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_1a1335e(void);
int32_t function_1a137ca(void);
int32_t function_1a137fe(void);
int32_t function_1a138(void);
int32_t function_1a1614e(void);
int32_t function_1a181e(void);
int32_t function_1a18c(void);
int32_t function_1a192d6(void);
int32_t function_1a1c8a(void);
int32_t function_1a2d8(void);
int32_t function_1a2e0(int32_t a1);
int32_t function_1a308(void);
int32_t function_1a3de(int32_t result, int32_t a2, int32_t a3);
int32_t function_1a3e4(int32_t a1, uint32_t a2);
int32_t function_1a448(void);
int32_t function_1a46c(void);
int32_t function_1a470(int32_t result, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_1a48a46(void);
int32_t function_1a5652a(void);
int32_t function_1a5a06a(void);
int32_t function_1a870(char result, int32_t a2, int32_t a3);
int32_t function_1a8a0(int32_t a1);
int32_t function_1a8ac(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, uint32_t a6, int32_t a7);
int32_t function_1a9615a(void);
int32_t function_1aaa0(int32_t result);
int32_t function_1aaa4(void);
int32_t function_1aaa8(int32_t result);
int32_t function_1aaac(int32_t a1, int32_t result);
int32_t function_1aab0(void);
int32_t function_1aab4(int32_t a1);
int32_t function_1aae4(int32_t a1, int32_t a2, int32_t a3, int32_t a4, uint32_t a5);
int32_t function_1ab20(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_1ab30(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_1ab6fd2(void);
int32_t function_1abce(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_1abf8(int32_t a1, int32_t a2, int32_t a3, int32_t a4, uint32_t a5, int32_t a6);
int32_t function_1ac0de(void);
int32_t function_1ad08(int32_t * a1, char a2, int32_t a3);
int32_t function_1b124e(void);
int32_t function_1b248(int32_t a1, int32_t a2, int32_t a3);
int32_t function_1b2f30(void);
int32_t function_1b2fc(void);
int32_t function_1b398(void);
int32_t function_1b4ac(void);
int32_t function_1bb01a(void);
int32_t function_1bc296(void);
int32_t function_1c49ee(void);
int32_t function_1d62aba(void);
int32_t function_1d64b56(void);
int32_t function_1da072(void);
int32_t function_1dbaa12(void);
int32_t function_1de3252(void);
int32_t function_1de836(void);
int32_t function_1e0076(void);
int32_t function_1e0c0(void);
int32_t function_1e0d0(void);
int32_t function_1e0e0(void);
int32_t function_1e0f0(void);
int32_t function_1e100(void);
int32_t function_1e110(void);
int32_t function_1e120(void);
int32_t function_1e130(void);
int32_t function_1e140(void);
int32_t function_1e150(void);
int32_t function_1e1566(void);
int32_t function_1e160(void);
int32_t function_1e170(void);
int32_t function_1e180(int32_t a1);
int32_t function_1e19c(void);
int32_t function_1e1ac(int32_t a1);
int32_t function_1e1bca(void);
int32_t function_1e1c8(int32_t a1);
int32_t function_1e1e4(int32_t a1);
int32_t function_1e200(int32_t a1, int32_t a2);
int32_t function_1e2256(void);
int32_t function_1e255e(void);
int32_t function_1e285a(void);
int32_t function_1e28c(void);
int32_t function_1e29c(int32_t a1);
int32_t function_1e2b4(void);
int32_t function_1e2c8(void);
int32_t function_1e2d8(void);
int32_t function_1e2ec(void);
int32_t function_1e2fc(void);
int32_t function_1e30c(void);
int32_t function_1e350(int32_t a1, int32_t a2);
int32_t function_1e3d4(int32_t a1, int32_t a2);
int32_t function_1e43c(int32_t a1);
int32_t function_1e49c(int32_t a1);
int32_t function_1e4b0(void);
int32_t function_1e4c0(int32_t a1);
int32_t function_1e52c(int32_t result);
int32_t function_1e58c(int32_t a1, int32_t a2, int32_t a3);
int32_t function_1e596(void);
int32_t function_1e5a0(int32_t a1);
int32_t function_1e5e89e(void);
int32_t function_1e610(int32_t a1, int32_t a2);
int32_t function_1e6297e(void);
int32_t function_1e67c(int32_t a1);
int32_t function_1e6e0(int32_t a1);
int32_t function_1e750(int32_t a1, int32_t a2);
int32_t function_1e7bc(int32_t a1);
int32_t function_1e820(int32_t a1, int32_t a2, int32_t a3);
int32_t function_1e894(int32_t a1, int32_t * str);
int32_t function_1e91c(int32_t a1);
int32_t function_1e970(void);
int32_t function_1e9b4(int32_t a1, int32_t a2);
int32_t function_1e9bc(void);
int32_t function_1e9c4(void);
int32_t function_1e9cc(int32_t a1);
int32_t function_1ea14(void);
int32_t function_1ea18(int32_t a1, int32_t a2, int32_t a3, uint32_t a4);
int32_t function_1ea84(int32_t a1);
int32_t function_1ead4(int32_t a1);
int32_t function_1eb1c(int32_t a1);
int32_t function_1eb74(void);
int32_t function_1ec7c(void);
int32_t function_1ec80(void);
int32_t function_1ec84(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_1ecdc(int32_t a1, uint32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_1ed08(void);
int32_t function_1edf0(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_1eeb8(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_1ef94(int32_t a1, char a2);
int32_t function_1efe0(int32_t a1, char a2, char a3, int32_t a4);
int32_t function_1f038(int32_t a1);
int32_t function_1f07c(void);
int32_t function_1f080(uint32_t a1, uint32_t a2);
int32_t function_1f0e0(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_1f164(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_1f1ec(int32_t a1, int32_t a2);
int32_t function_1f24c(int32_t a1);
int32_t function_1f27d52(void);
int32_t function_1f294(uint32_t a1);
int32_t function_1f29c(int32_t a1);
int32_t function_1f2e4(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_1f2ec(void);
int32_t function_1f2f0(int32_t a1);
int32_t function_1f2f4(void);
int32_t function_1f2f8(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_1f300(int32_t a1, int32_t a2, int32_t a3);
int32_t function_1f30a(void);
int32_t function_1f31c(void);
int32_t function_1f320(void);
int32_t function_1f340(int32_t a1);
int32_t function_1f3e8(int32_t a1);
int32_t function_1f490(int32_t a1);
int32_t function_1f574(int32_t a1, int32_t a2, int32_t a3);
int32_t function_1f69c(void);
int32_t function_1f6ac(int32_t a1);
int32_t function_1f76a(void);
int32_t function_1f780(int32_t a1, int32_t a2);
int32_t function_1f784(int32_t a1);
int32_t function_1f7a8(void);
int32_t function_1f7c4(int32_t a1, int32_t a2);
int32_t function_1f8b0(int32_t a1);
int32_t function_1f8ee(int32_t a1);
int32_t function_1f8f0(void);
int32_t function_1f8f4(void);
int32_t function_1f902(void);
int32_t function_1f904(void);
int32_t function_1f90e(void);
int32_t function_1f910(int32_t a1);
int32_t function_1f928(void);
int32_t function_1f958(int32_t result, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_1f95a(void);
int32_t function_1f960(int32_t a1);
int32_t function_1f968(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_1f96c(int32_t a1);
int32_t function_1f970(int32_t result);
int32_t function_1f976(int32_t a1);
int32_t function_1f97a(void);
int32_t function_1f984(void);
int32_t function_1f98a(void);
int32_t function_1f98c(int32_t a1);
int32_t function_1fa2c(int32_t a1);
int32_t function_1fa84e(void);
int32_t function_1fad86(void);
int32_t function_1fb02a(void);
int32_t function_1fb032(void);
int32_t function_1fb10(int32_t a1);
int32_t function_1fb18(int32_t a1, int32_t a2);
int32_t function_1fbba(void);
int32_t function_1fbbc(int32_t a1, uint32_t a2);
int32_t function_1fbcc(void);
int32_t function_1fbce(void);
int32_t function_1fbd2(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_1fbdc(int32_t a1, uint32_t a2, int32_t a3, int32_t a4);
int32_t function_1fc3e(int32_t a1);
int32_t function_1fc42(int32_t a1);
int32_t function_1fc44(int32_t str, int32_t a2, uint32_t a3);
int32_t function_1fc52(int32_t a1);
int32_t function_1fc54(int32_t a1);
int32_t function_1fc68(int32_t a1);
int32_t function_1fc84(int32_t a1, int32_t a2);
int32_t function_1fca0(int32_t a1, int32_t a2);
int32_t function_1fca4(int32_t a1);
int32_t function_1fccc(int32_t result, int32_t a2);
int32_t function_1fd80(int32_t a1, int32_t a2, int32_t a3);
int32_t function_1fd98(int32_t a1, int32_t a2, uint32_t a3, int32_t a4);
int32_t function_1fdd8(int32_t a1, uint32_t a2);
int32_t function_1fe20(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_1fe28(int32_t a1);
int32_t function_1fe2c(int32_t a1);
int32_t function_1fe30(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_1fe38(int32_t a1);
int32_t function_1fe68(int32_t a1, int32_t a2);
int32_t function_1fe7c(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_1fe80(int32_t a1, uint32_t a2, int32_t a3);
int32_t function_1fe9c(int32_t a1, uint32_t a2);
int32_t function_1ff78(int32_t a1);
int32_t function_1ff7c(void);
int32_t function_1ff8a(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t function_1ff98(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_1ffa4(void);
int32_t function_1ffe6(void);
int32_t function_1ffe8(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_1fff0(void);
int32_t function_1fff2(int32_t a1);
int32_t function_1fff4(int32_t a1, int32_t a2, uint32_t a3);
int32_t function_20018(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_20020(int32_t a1, int32_t a2);
int32_t function_20024(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_200d0(int32_t a1);
int32_t function_200d4(uint32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_200e4(void);
int32_t function_200ec(void);
int32_t function_200fc(int32_t a1, int32_t a2, int32_t a3, uint32_t a4);
int32_t function_20160(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_20170(int32_t a1);
int32_t function_20172(int32_t a1, int32_t a2, int32_t a3, int32_t a4, char a5);
int32_t function_201ba(void);
int32_t function_201bc(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_201c2(void);
int32_t function_201c4(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_201d8(void);
int32_t function_201f8(void);
int32_t function_2022de0(void);
int32_t function_20234(int32_t a1, uint32_t a2);
int32_t function_202a0(void);
int32_t function_202a4(void);
int32_t function_202be(int32_t a1, int32_t a2, int32_t a3);
int32_t function_202c4(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_202cc(int32_t a1, int32_t a2);
int32_t function_20308(void);
int32_t function_2031e(int32_t a1);
int32_t function_20320(void);
int32_t function_20324(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2035c(void);
int32_t function_20366(void);
int32_t function_20368(int32_t a1);
int32_t function_2036f6c(void);
int32_t function_2037c(void);
int32_t function_20390(void);
int32_t function_20398(int32_t result);
int32_t function_2039c(void);
int32_t function_2039e(uint32_t a1, int32_t a2, int32_t a3, uint32_t a4);
int32_t function_20404(int32_t a1, int32_t size, uint32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10);
int32_t function_20430(int32_t a1, int32_t a2);
int32_t function_20446(int32_t a1);
int32_t function_20448(int32_t a1, int32_t a2);
int32_t function_20492(int32_t a1);
int32_t function_20494(void);
int32_t function_20498(int32_t a1);
int32_t function_204992(void);
int32_t function_2049b2(void);
int32_t function_2049d2(void);
int32_t function_204ac(void);
int32_t function_204ae(int32_t a1);
int32_t function_204b0(void);
int32_t function_204b2(void);
int32_t function_204b4(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t function_204b8(int32_t result, int32_t a2);
int32_t function_204fe(void);
int32_t function_20500(void);
int32_t function_20528(int32_t a1, uint32_t a2);
int32_t function_20584(int32_t a1, int32_t a2);
int32_t function_2058c(int32_t a1);
int32_t function_20590(int32_t a1, int32_t size, uint32_t a3, int32_t a4);
int32_t function_205b8(int32_t a1, int32_t a2, int32_t a3);
int32_t function_205ec(int32_t a1);
int32_t function_205fa(int32_t a1);
int32_t function_20600(void);
int32_t function_20610(void);
int32_t function_20614(int32_t a1, int32_t a2, int32_t a3, uint32_t a4);
int32_t function_20638(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2063c(int32_t a1);
int32_t function_20640(int32_t result);
int32_t function_20646(int32_t a1);
int32_t function_20648(void);
int32_t function_2064c(void);
int32_t function_20662(int32_t a1);
int32_t function_20664(void);
int32_t function_20674(int32_t a1);
int32_t function_2067c(int32_t a1, int32_t a2);
int32_t function_20680(int32_t a1);
int32_t function_20684(int32_t a1, int32_t a2, int32_t a3, uint32_t a4, int32_t a5);
int32_t function_206b4(int32_t a1, int32_t a2);
int32_t function_206fe(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_20704(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_20714(void);
int32_t function_20742(int32_t a1);
int32_t function_20748(int32_t a1, int32_t a2, int32_t a3);
int32_t function_20778(void);
int32_t function_2077a(int32_t a1);
int32_t function_20780(void);
int32_t function_20786(int32_t result);
int32_t function_2078a(uint32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_207e0(int32_t a1);
int32_t function_207e4(int32_t a1);
int32_t function_207e8(int32_t result, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_20844(void);
int32_t function_20872(void);
int32_t function_20874(int32_t a1, int32_t a2);
int32_t function_20880(int32_t a1, int32_t a2);
int32_t function_208cc(int32_t a1, int32_t a2);
int32_t function_20918(void);
int32_t function_2091c(void);
int32_t function_20920(int32_t a1);
int32_t function_20926(void);
int32_t function_20928(int32_t a1);
int32_t function_2092c(int32_t a1);
int32_t function_20930(int32_t a1);
int32_t function_20934(int32_t a1);
int32_t function_20938(void);
int32_t function_2093a(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9);
int32_t function_20964(void);
int32_t function_209bc(void);
int32_t function_209c6(void);
int32_t function_209c8(int32_t result);
int32_t function_209cc(int32_t a1);
int32_t function_209d0(int32_t a1);
int32_t function_209d4(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_20a08(int32_t result);
int32_t function_20a20(int32_t result);
int32_t function_20a38(int32_t result);
int32_t function_20a50(int32_t a1);
int32_t function_20a8a(void);
int32_t function_20a8c(void);
int32_t function_20aa8(void);
int32_t function_20ac2(void);
int32_t function_20ac4(int32_t a1, int32_t a2);
int32_t function_20ad4(int32_t a1);
int32_t function_20b46(void);
int32_t function_20b4c(int32_t a1, int32_t a2, uint32_t a3, int32_t a4);
int32_t function_20b7c(int32_t a1);
int32_t function_20b92(void);
int32_t function_20b94(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_20bb0(int32_t a1);
int32_t function_20bb8(void);
int32_t function_20c16(void);
int32_t function_20c18(int32_t a1);
int32_t function_20c28(int32_t a1);
int32_t function_20c58(void);
int32_t function_20c5a(void);
int32_t function_20c5c(int32_t a1);
int32_t function_20c60(void);
int32_t function_20c6e(void);
int32_t function_20c72(int32_t a1, int32_t a2, int32_t a3);
int32_t function_20c7a(void);
int32_t function_20c7c(int32_t result);
int32_t function_20c80(int32_t result);
int32_t function_20c84(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_20c8c(int32_t a1);
int32_t function_20c90(int32_t result);
int32_t function_20c94(int32_t result);
int32_t function_20c98(void);
int32_t function_20ca2(int32_t a1);
int32_t function_20ca4(int32_t a1, int32_t a2, uint32_t a3);
int32_t function_20cc2(int32_t result, int32_t a2, int32_t a3);
int32_t function_20cc8(int32_t a1);
int32_t function_20cd2(void);
int32_t function_20cd4(int32_t result);
int32_t function_20cd8(void);
int32_t function_20cdc(int32_t a1, int32_t a2, int32_t result);
int32_t function_20ce0(void);
int32_t function_20ce4(void);
int32_t function_20ce8(void);
int32_t function_20cec(void);
int32_t function_20cee(void);
int32_t function_20cf0(int32_t a1);
int32_t function_20cf4(void);
int32_t function_20cf6(void);
int32_t function_20cf8(void);
int32_t function_20cfa(void);
int32_t function_20cfc(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_20d00(int32_t a1);
int32_t function_20d04(int32_t result, int32_t a2);
int32_t function_20d08(void);
int32_t function_20d0c(void);
int32_t function_20d12(void);
int32_t function_20d16(void);
int32_t function_20d18(int32_t result);
int32_t function_20d1c(int32_t a1);
int32_t function_20d22(void);
int32_t function_20d24(int32_t result, int32_t a2, int32_t a3);
int32_t function_20d44(int32_t a1, int32_t a2);
int32_t function_20e61a(void);
int32_t function_2164f2(void);
int32_t function_2167d2(void);
int32_t function_21965a(void);
int32_t function_21abf6(void);
int32_t function_21aec2(void);
int32_t function_21b052(void);
int32_t function_22167a(void);
int32_t function_2216a2(void);
int32_t function_2222ee(void);
int32_t function_222302(void);
int32_t function_2223da(void);
int32_t function_2223f2(void);
int32_t function_2246a6(void);
int32_t function_224d26(void);
int32_t function_224d4e(void);
int32_t function_224f02(void);
int32_t function_22528a(void);
int32_t function_231a4(uint32_t a1, int32_t a2, int32_t a3);
int32_t function_23270(int32_t result, int32_t a2, int32_t a3);
int32_t function_2327c(int32_t * a1, int32_t * a2);
int32_t function_23430(int32_t * a1, uint32_t a2, int32_t * a3);
int32_t function_234d8(int32_t str, int32_t size, int32_t a3);
int32_t function_23574(int32_t a1, int32_t str2, int32_t size, int32_t a4, int32_t a5);
int32_t function_24264(int32_t str);
int32_t function_24364(int32_t a1);
int32_t function_24398(int32_t a1);
int32_t function_244aa(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_244b2(void);
int32_t function_244b4(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_244c0(void);
int32_t function_244c2(void);
int32_t function_244c6(void);
int32_t function_244c8(void);
int32_t function_244cc(int32_t a1);
int32_t function_244d2(int32_t a1);
int32_t function_244d6(void);
int32_t function_244d8(void);
int32_t function_244ea(int32_t result);
int32_t function_244f0(int32_t a1, int32_t a2, int32_t a3, int32_t a4, char a5);
int32_t function_2458c(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t function_245ac(void);
int32_t function_24628(void);
int32_t function_246a0(void);
int32_t function_24710(int32_t a1, int32_t a2);
int32_t function_24722(int32_t a1);
int32_t function_24724(void);
int32_t function_247c6(int32_t a1);
int32_t function_247c8(void);
int32_t function_247d0(void);
int32_t function_247e8(void);
int32_t function_24800(void);
int32_t function_24816(int32_t a1);
int32_t function_24818(void);
int32_t function_248ae(int32_t a1);
int32_t function_248b0(void);
int32_t function_248be(void);
int32_t function_248c0(int32_t str, uint32_t a2);
int32_t function_2499c(int32_t a1);
int32_t function_249c4(int32_t a1);
int32_t function_249d8(int32_t result);
int32_t function_249e0(void);
int32_t function_249e4(int32_t result);
int32_t function_249f0(void);
int32_t function_249f4(void);
int32_t function_249f6(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_24a30(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_24a7c(void);
int32_t function_24ac0(void);
int32_t function_24ace(int32_t a1);
int32_t function_24ad8(int32_t a1, int32_t a2, int32_t a3, uint32_t a4);
int32_t function_24af4(int32_t a1);
int32_t function_24b10(int32_t a1);
int32_t function_24b36(void);
int32_t function_24b38(void);
int32_t function_24b4e(int32_t a1);
int32_t function_24b50(int32_t a1);
int32_t function_24b60(void);
int32_t function_24b62(int32_t a1);
int32_t function_24b64(int32_t a1);
int32_t function_24b68(void);
int32_t function_24b74(int32_t result);
int32_t function_24b7c(void);
int32_t function_24b8c(void);
int32_t function_24c12(int32_t a1);
int32_t function_24c18(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_24c3c(void);
int32_t function_24c8c(void);
int32_t function_24ca4(int32_t a1, int32_t a2);
int32_t function_24d2c(void);
int32_t function_24d88(void);
int32_t function_24d98(void);
int32_t function_24dcc(int32_t result);
int32_t function_24dd0(void);
int32_t function_24de8(void);
int32_t function_24e20(void);
int32_t function_24ea0(void);
int32_t function_24f06(int32_t result, int32_t a2, int32_t a3);
int32_t function_24f24(int32_t result);
int32_t function_24f28(void);
int32_t function_24f2c(int32_t result, int32_t a2);
int32_t function_24f32(int32_t a1);
int32_t function_24f34(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_24f38(int32_t a1, uint32_t a2, int32_t a3, int32_t a4);
int32_t function_25038(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_25040(void);
int32_t function_2504e(void);
int32_t function_25050(int32_t result);
int32_t function_25054(int32_t a1, int32_t a2);
int32_t function_25058(void);
int32_t function_250de(void);
int32_t function_250e0(void);
int32_t function_250e4(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t function_25104(void);
int32_t function_25174(void);
int32_t function_251db2(void);
int32_t function_251ec(void);
int32_t function_25204(void);
int32_t function_2520a(int32_t a1);
int32_t function_2520c(void);
int32_t function_25214(void);
int32_t function_25226(void);
int32_t function_25228(void);
int32_t function_25238(void);
int32_t function_2527c(void);
int32_t function_25284(void);
int32_t function_253a0(int32_t * str);
int32_t function_254f9a(void);
int32_t function_25529a(void);
int32_t function_2552d6(void);
int32_t function_2561d6(void);
int32_t function_2564b6(void);
int32_t function_258c8(int32_t * str);
int32_t function_259a4(int32_t result);
int32_t function_259aa(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_25a20(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_25ba2c(void);
int32_t function_25bba(void);
int32_t function_25bc0(void);
int32_t function_25bc4(void);
int32_t function_25bc8(int32_t a1, int32_t a2);
int32_t function_25bd4(int32_t a1);
int32_t function_25bd8(void);
int32_t function_25bdc(void);
int32_t function_25bde(void);
int32_t function_25be0(void);
int32_t function_25be4(void);
int32_t function_25be8(int32_t a1);
int32_t function_25bec(void);
int32_t function_25bf4(int32_t a1, int32_t a2);
int32_t function_25c0a(void);
int32_t function_25c10(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t function_25db0(void);
int32_t function_25e40(int32_t a1);
int32_t function_25e44(int32_t a1);
int32_t function_25e48(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_25e54(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_25f0ca(void);
int32_t function_25f50(int32_t a1);
int32_t function_25fd0(void);
int32_t function_25fd4(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_25fe4(void);
int32_t function_25ff0(int32_t a1, int32_t a2);
int32_t function_25ff4(void);
int32_t function_2600c(void);
int32_t function_26094(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2609a(void);
int32_t function_260a2(void);
int32_t function_260a4(int32_t a1, int32_t a2, int32_t a3, uint32_t a4);
int32_t function_260b8(int32_t a1);
int32_t function_260bc(int32_t a1);
int32_t function_260c0(void);
int32_t function_260c4(void);
int32_t function_260c8(int32_t a1);
int32_t function_260cc(int32_t a1, int32_t a2, uint32_t a3);
int32_t function_260f0(void);
int32_t function_260f8(int32_t result, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_26104(void);
int32_t function_26106(void);
int32_t function_26108(void);
int32_t function_2613a(int32_t a1);
int32_t function_2613c(void);
int32_t function_26146(int32_t a1);
int32_t function_2614a(int32_t a1);
int32_t function_2614c(int32_t a1, int32_t a2, int32_t a3, uint32_t a4);
int32_t function_26196(int32_t a1);
int32_t function_2619da(void);
int32_t function_261d0(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_261d8(int32_t result, int32_t a2, int32_t a3, uint32_t a4, int32_t a5);
int32_t function_2620e(void);
int32_t function_26210(int32_t str, int32_t a2, int32_t format, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9);
int32_t function_2623c(void);
int32_t function_26250(void);
int32_t function_26256(void);
int32_t function_26258(void);
int32_t function_26302(int32_t a1);
int32_t function_26304(void);
int32_t function_26306(void);
int32_t function_26308(int32_t a1, int32_t a2);
int32_t function_2630c(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_26310(int32_t result);
int32_t function_26314(int32_t a1, int32_t a2);
int32_t function_2631a(void);
int32_t function_2631c(void);
int32_t function_26320(int32_t a1, int32_t a2);
int32_t function_26324(int32_t result);
int32_t function_26326(int32_t a1);
int32_t function_26328(int32_t a1);
int32_t function_2632e(void);
int32_t function_26330(int32_t a1, int32_t a2);
int32_t function_26338(void);
int32_t function_2633c(int32_t a1, int32_t a2);
int32_t function_2635c(int32_t a1, int32_t a2);
int32_t function_26364(int32_t result);
int32_t function_26368(int32_t a1);
int32_t function_2636c(void);
int32_t function_26370(void);
int32_t function_26374(int32_t a1, int32_t a2, int32_t a3);
int32_t function_26378(void);
int32_t function_2637c(int32_t a1, int32_t a2);
int32_t function_26380(int32_t result, int32_t a2, int32_t a3);
int32_t function_26384(int32_t a1, int32_t a2, int32_t a3);
int32_t function_26388(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2638c(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_26390(void);
int32_t function_26394(int32_t a1, int32_t a2);
int32_t function_26398(int32_t fd);
int32_t function_2639c(int32_t a1);
int32_t function_263a0(int32_t a1);
int32_t function_263a4(void);
int32_t function_263a8(int32_t a1);
int32_t function_263b0(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_263bc(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_263be(void);
int32_t function_263c0(void);
int32_t function_263c6(int32_t a1, int32_t a2, int32_t a3);
int32_t function_263e0(int32_t a1);
int32_t function_26402(void);
int32_t function_26404(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t function_2640c(int32_t a1);
int32_t function_26410(void);
int32_t function_26414(int32_t a1, int32_t a2);
int32_t function_2641c(int32_t a1);
int32_t function_26422(void);
int32_t function_26424(int32_t a1);
int32_t function_26428(int32_t a1);
int32_t function_2642e(void);
int32_t function_26430(void);
int32_t function_2644a(int32_t a1);
int32_t function_2644c(void);
int32_t function_26452(void);
int32_t function_26454(void);
int32_t function_26470(void);
int32_t function_2647c(uint32_t a1);
int32_t function_26480(void);
int32_t function_264a0(int32_t fd);
int32_t function_264a2(void);
int32_t function_264a4(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_264a8(int32_t a1);
int32_t function_264ac(void);
int32_t function_264b2(void);
int32_t function_264b4(void);
int32_t function_264cfe(void);
int32_t function_26510(int32_t a1);
int32_t function_26514(int32_t a1, int32_t a2);
int32_t function_26518(int32_t a1);
int32_t function_2651c(int32_t a1);
int32_t function_26520(int32_t a1);
int32_t function_26524(int32_t a1);
int32_t function_26528(int32_t a1, int32_t a2);
int32_t function_2652c(int32_t a1);
int32_t function_26530(int32_t a1, int32_t a2);
int32_t function_26534(int32_t a1);
int32_t function_26538(int32_t a1);
int32_t function_2653c(int32_t a1);
int32_t function_26540(void);
int32_t function_26542(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2655c(void);
int32_t function_26564(void);
int32_t function_26586(int32_t a1);
int32_t function_26588(void);
int32_t function_265c4(char * special_file, int32_t flags);
int32_t function_265c6(void);
int32_t function_265c8(int32_t result);
int32_t function_265d0(void);
int32_t function_265d8(int32_t a1);
int32_t function_265dc(void);
int32_t function_265e4(void);
int32_t function_265ec(void);
int32_t function_265f4(void);
int32_t function_26618(int32_t a1, int32_t a2, int32_t a3);
int32_t function_2661c(void);
int32_t function_26624(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2662e(void);
int32_t function_2663e(void);
int32_t function_26642(int32_t a1);
int32_t function_2664e(void);
int32_t function_26650(int32_t a1);
int32_t function_2665a(void);
int32_t function_2665c(int32_t a1, uint32_t a2, int32_t a3, int32_t a4);
int32_t function_26668(void);
int32_t function_266b6(void);
int32_t function_266b8(int32_t a1);
int32_t function_266bc(void);
int32_t function_266c2(void);
int32_t function_266c4(void);
int32_t function_266ca(void);
int32_t function_266cc(int32_t a1);
int32_t function_266d0(void);
int32_t function_266d6(void);
int32_t function_266d8(int32_t a1, int32_t a2, int32_t a3);
int32_t function_266dc(int32_t a1);
int32_t function_266e0(void);
int32_t function_266e4(void);
int32_t function_266ea(char a1);
int32_t function_266ec(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_26710(int32_t a1);
int32_t function_26714(void);
int32_t function_26718(int32_t a1);
int32_t function_2671c(void);
int32_t function_26720(int32_t a1, int32_t a2, int32_t a3);
int32_t function_26724(int32_t a1, int32_t a2, int32_t a3);
int32_t function_26728(void);
int32_t function_2672c(void);
int32_t function_26730(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11, int32_t a12);
int32_t function_26750(void);
int32_t function_26766(int32_t a1);
int32_t function_26768(int32_t a1);
int32_t function_2676e(int32_t a1);
int32_t function_26770(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_26780(void);
int32_t function_26782(void);
int32_t function_26784(int32_t a1);
int32_t function_26788(int32_t a1);
int32_t function_2678c(void);
int32_t function_26790(int32_t a1);
int32_t function_26794(int32_t a1, int32_t a2, int32_t a3);
int32_t function_26798(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_267ac(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_267ae(int32_t a1);
int32_t function_267b8(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_267c0(void);
int32_t function_267c6(void);
int32_t function_267c8(void);
int32_t function_267cc(int32_t a1);
int32_t function_267ce(int32_t a1);
int32_t function_267d0(void);
int32_t function_267d4(void);
int32_t function_267f4(void);
int32_t function_267f8(void);
int32_t function_267fc(int32_t a1, int32_t a2, int32_t a3);
int32_t function_26808(int32_t a1);
int32_t function_2680c(int32_t a1);
int32_t function_26814(int32_t a1);
int32_t function_26818(int32_t a1);
int32_t function_2681c(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_26824(void);
int32_t function_26828(int32_t a1);
int32_t function_2682c(void);
int32_t function_26830(int32_t result, int32_t a2);
int32_t function_26834(int32_t a1);
int32_t function_26838(int32_t a1);
int32_t function_2683c(void);
int32_t function_26840(int32_t a1);
int32_t function_26856(int32_t a1);
int32_t function_2685a(void);
int32_t function_2685c(void);
int32_t function_2685e(void);
int32_t function_26860(int32_t a1);
int32_t function_26864(int32_t a1);
int32_t function_26868(int32_t a1, int32_t a2);
int32_t function_2686c(int32_t a1);
int32_t function_26870(int32_t a1);
int32_t function_26874(int32_t a1);
int32_t function_26878(int32_t a1);
int32_t function_2687c(int32_t a1);
int32_t function_26880(int32_t a1);
int32_t function_26884(int32_t a1);
int32_t function_26888(int32_t a1, int32_t a2);
int32_t function_2688e(int32_t a1);
int32_t function_26890(int32_t result, int32_t a2, int32_t a3);
int32_t function_26898(int32_t result);
int32_t function_2689c(int32_t a1);
int32_t function_268a0(int32_t result, int32_t a2);
int32_t function_268a6(int32_t a1);
int32_t function_268ac(int32_t result, int32_t a2);
int32_t function_268b0(void);
int32_t function_268b4(int32_t a1);
int32_t function_268b8(int32_t result);
int32_t function_268bc(int32_t a1, int32_t a2, int32_t a3);
int32_t function_268c0(int32_t a1);
int32_t function_268c4(int32_t a1);
int32_t function_268c8(void);
int32_t function_268ca(void);
int32_t function_268cc(int32_t a1);
int32_t function_268d0(int32_t a1);
int32_t function_268d4(int32_t a1);
int32_t function_268d8(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_268f4(int32_t a1, int32_t a2, int32_t a3);
int32_t function_268fc(void);
int32_t function_268fe(void);
int32_t function_2691e(void);
int32_t function_26924(int32_t result);
int32_t function_26928(void);
int32_t function_2692c(int32_t a1, int32_t a2);
int32_t function_26934(int32_t result);
int32_t function_26938(int32_t result);
int32_t function_2693c(void);
int32_t function_26940(void);
int32_t function_26944(int32_t a1);
int32_t function_26948(int32_t a1);
int32_t function_2694c(int32_t result);
int32_t function_26950(void);
int32_t function_26954(void);
int32_t function_2695a(int32_t a1);
int32_t function_2695e(int32_t a1);
int32_t function_26962(int32_t a1);
int32_t function_26964(void);
int32_t function_2696c(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_26970(int32_t a1);
int32_t function_2697c(int32_t a1, int32_t a2, int32_t a3);
int32_t function_26982(void);
int32_t function_26984(uint32_t a1, uint32_t a2);
int32_t function_2699a(int32_t a1);
int32_t function_2699c(void);
int32_t function_269ae(void);
int32_t function_269b0(int32_t result);
int32_t function_269b8(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_269de(void);
int32_t function_269e0(void);
int32_t function_269e4(void);
int32_t function_269e8(int32_t a1);
int32_t function_269ee(int32_t a1);
int32_t function_269f0(int32_t a1);
int32_t function_269f4(int32_t a1, int32_t a2, int32_t a3);
int32_t function_26a00(int32_t a1);
int32_t function_26a04(int32_t a1, int32_t a2, int32_t a3);
int32_t function_26a0c(void);
int32_t function_26a10(void);
int32_t function_26a16(void);
int32_t function_26a1a(void);
int32_t function_26a1c(int32_t result);
int32_t function_26a1e(void);
int32_t function_26a2c(int32_t a1, int32_t a2, int32_t a3);
int32_t function_26a30(void);
int32_t function_26a34(void);
int32_t function_26a38(void);
int32_t function_26a3c(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_26a40(int32_t a1);
int32_t function_26a46(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_26a5c(int32_t a1);
int32_t function_26a6e(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_26a72(int32_t a1);
int32_t function_26a88(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_26a90(int32_t a1);
int32_t function_26a94(int32_t a1, int32_t a2, int32_t a3);
int32_t function_26a98(void);
int32_t function_26a9e(void);
int32_t function_26aa0(void);
int32_t function_26aa4(void);
int32_t function_26aaa(int32_t a1);
int32_t function_26aae(void);
int32_t function_26ab0(void);
int32_t function_26ace(void);
int32_t function_26ad2(int32_t a1);
int32_t function_26ad4(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_26ae0(void);
int32_t function_26b04(int32_t a1);
int32_t function_26b08(void);
int32_t function_26b14(uint32_t a1);
int32_t function_26b18(int32_t result);
int32_t function_26b1c(void);
int32_t function_26b20(uint32_t a1);
int32_t function_26b24(void);
int32_t function_26b2a(void);
int32_t function_26b2e(void);
int32_t function_26b30(void);
int32_t function_26b34(void);
int32_t function_26b36(int32_t a1);
int32_t function_26b38(void);
int32_t function_26b40(int32_t result, int32_t a2, int32_t a3);
int32_t function_26b56(int32_t result);
int32_t function_26b62(int32_t a1, int32_t a2);
int32_t function_26b7a(int32_t result);
int32_t function_26b7e(int32_t a1);
int32_t function_26b82(void);
int32_t function_26b84(int32_t a1);
int32_t function_26b88(void);
int32_t function_26b8c(int32_t a1, int32_t a2, int32_t a3);
int32_t function_26b90(void);
int32_t function_26b94(void);
int32_t function_26b98(int32_t a1);
int32_t function_26b9c(int32_t result);
int32_t function_26ba0(int32_t a1, int32_t a2);
int32_t function_26ba4(int32_t result);
int32_t function_26ba6(void);
int32_t function_26baa(void);
int32_t function_26bac(void);
int32_t function_26bbe(char a1);
int32_t function_26bc2(void);
int32_t function_26bc4(void);
int32_t function_26bd4(void);
int32_t function_26bd8(int32_t who, struct rusage * usage);
int32_t function_26bdc(int32_t a1, int32_t a2);
int32_t function_26c3e(void);
int32_t function_26c40(void);
int32_t function_26c5c(int32_t a1);
int32_t function_26c60(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_26c64(void);
int32_t function_26c68(void);
int32_t function_26c6c(int32_t a1, int32_t a2, int32_t a3);
int32_t function_26c70(int32_t a1);
int32_t function_26c74(int32_t a1);
int32_t function_26c76(void);
int32_t function_26c78(void);
int32_t function_26c7e(void);
int32_t function_26c82(int32_t a1);
int32_t function_26c84(int32_t a1, uint32_t a2, int32_t a3, uint32_t a4);
int32_t function_26cae(void);
int32_t function_26cb0(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_26cca(int32_t a1);
int32_t function_26ccc(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t function_26cd8(int32_t a1);
int32_t function_26cde(void);
int32_t function_26ce0(int32_t a1);
int32_t function_26cea(int32_t a1);
int32_t function_26cec(int32_t a1, int32_t a2, int32_t a3);
int32_t function_26cf2(void);
int32_t function_26cf4(void);
int32_t function_26cf8(int32_t a1, int32_t a2);
int32_t function_26cfc(int32_t a1);
int32_t function_26d00(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_26d04(void);
int32_t function_26d06(void);
int32_t function_26d08(int32_t a1);
int32_t function_26d0e(void);
int32_t function_26d10(int32_t a1);
int32_t function_26d14(void);
int32_t function_26d18(int32_t a1, int32_t a2, int32_t a3);
int32_t function_26d1c(void);
int32_t function_26d20(void);
int32_t function_26d24(void);
int32_t function_26d2a(void);
int32_t function_26d2c(int32_t a1);
int32_t function_26d34(void);
int32_t function_26d3a(void);
int32_t function_26d3e(void);
int32_t function_26d40(int32_t a1);
int32_t function_26d44(int32_t a1);
int32_t function_26d48(int32_t a1);
int32_t function_26d4c(int32_t a1, int32_t a2);
int32_t function_26d50(int32_t a1);
int32_t function_26d54(int32_t a1);
int32_t function_26d58(int32_t a1, int32_t a2, int32_t a3);
int32_t function_26d5c(int32_t a1);
int32_t function_26d60(int32_t a1);
int32_t function_26d66(int32_t a1);
int32_t function_26d68(int32_t a1);
int32_t function_26d6e(int32_t a1);
int32_t function_26d70(void);
int32_t function_26d7c(void);
int32_t function_26d80(int32_t a1, int32_t a2);
int32_t function_26d9c(int32_t result);
int32_t function_26d9e(void);
int32_t function_26da2(int32_t a1);
int32_t function_26da4(int32_t a1);
int32_t function_26da8(uint32_t a1, int32_t a2);
int32_t function_26db0(int32_t a1);
int32_t function_26db4(void);
int32_t function_26db8(void);
int32_t function_26dba(void);
int32_t function_26dbc(int32_t a1);
int32_t function_26dc0(void);
int32_t function_26dc4(void);
int32_t function_26dc6(void);
int32_t function_26dc8(int32_t a1, int32_t a2, int32_t a3);
int32_t function_26dcc(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_26dd0(int32_t a1, int32_t a2, int32_t result);
int32_t function_26dd4(int32_t a1);
int32_t function_26dd8(int32_t a1, int32_t a2);
int32_t function_26dde(void);
int32_t function_26de0(int32_t a1);
int32_t function_26de8(void);
int32_t function_26dee(int32_t a1);
int32_t function_26df0(void);
int32_t function_26df4(void);
int32_t function_26e00(int32_t a1);
int32_t function_26e04(int32_t a1);
int32_t function_26e0a(void);
int32_t function_26e0c(int32_t a1);
int32_t function_26e10(uint32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_26e18(int32_t a1, int32_t a2, int32_t a3);
int32_t function_26e1c(int32_t a1);
int32_t function_26e20(int32_t a1);
int32_t function_26e22(void);
int32_t function_26e24(int32_t result, int32_t a2, int32_t a3);
int32_t function_26e26(int32_t a1);
int32_t function_26e28(int32_t a1);
int32_t function_26e2c(void);
int32_t function_26e30(int32_t a1, int32_t a2);
int32_t function_26e34(int32_t a1);
int32_t function_26e38(void);
int32_t function_26e3a(int32_t a1);
int32_t function_26e40(int32_t a1);
int32_t function_26e44(int32_t a1, int32_t a2, int32_t a3);
int32_t function_26e4a(void);
int32_t function_26e4c(int32_t a1);
int32_t function_26e60(int32_t result);
int32_t function_26e62(void);
int32_t function_26e64(void);
int32_t function_26e6a(void);
int32_t function_26e6c(int32_t a1, int32_t a2, int32_t a3);
int32_t function_26e72(int32_t a1);
int32_t function_26e74(int32_t a1, int32_t a2, int32_t a3);
int32_t function_26e78(int32_t a1);
int32_t function_26e7c(int32_t a1);
int32_t function_26e82(void);
int32_t function_26e86(void);
int32_t function_26e88(int32_t a1, int32_t a2, int32_t a3, uint32_t a4);
int32_t function_26eaa(void);
int32_t function_26eac(uint32_t a1, int32_t a2);
int32_t function_26ec4(int32_t a1);
int32_t function_26eda(void);
int32_t function_26edc(void);
int32_t function_26ee8(int32_t a1);
int32_t function_26eec(int32_t result, int32_t a2);
int32_t function_26ef0(int32_t a1);
int32_t function_26ef4(int32_t a1);
int32_t function_26f0c(void);
int32_t function_26f20(void);
int32_t function_26f34(int32_t a1);
int32_t function_26f3c(int32_t a1, int32_t a2);
int32_t function_26f40(void);
int32_t function_26f4e(int32_t a1);
int32_t function_26f50(int32_t a1);
int32_t function_26f54(int32_t a1);
int32_t function_26f5a(void);
int32_t function_26f5c(int32_t a1);
int32_t function_26f60(void);
int32_t function_26f64(int32_t result);
int32_t function_26f6a(void);
int32_t function_26f6c(void);
int32_t function_26f72(void);
int32_t function_26f74(int32_t a1, int32_t a2, int32_t a3);
int32_t function_26f80(int32_t a1);
int32_t function_26f84(int32_t result);
int32_t function_26f86(void);
int32_t function_26f8c(void);
int32_t function_26f94(int32_t result);
int32_t function_26f98(int32_t a1, int32_t a2);
int32_t function_26fa0(int32_t a1);
int32_t function_26fa4(int32_t a1);
int32_t function_26fa8(void);
int32_t function_26fac(int32_t a1);
int32_t function_26fb0(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2700c(int32_t a1);
int32_t function_27010(void);
int32_t function_2701a(void);
int32_t function_2701c(void);
int32_t function_2701e(void);
int32_t function_27028(int32_t a1, uint32_t a2);
int32_t function_27036(int32_t result, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t function_2703e(void);
int32_t function_27044(int32_t a1, int32_t result, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10);
int32_t function_27050(void);
int32_t function_27058(void);
int32_t function_2705a(int32_t a1);
int32_t function_2705c(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_27060(int32_t a1, int32_t a2);
int32_t function_27064(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_27068(int32_t a1, int32_t a2);
int32_t function_2706e(void);
int32_t function_27070(int32_t a1);
int32_t function_27074(void);
int32_t function_27078(int32_t a1);
int32_t function_2707c(int32_t a1, int32_t a2);
int32_t function_27080(int32_t result);
int32_t function_27084(void);
int32_t function_27088(int32_t a1, int32_t a2);
int32_t function_2708c(int32_t a1);
int32_t function_27090(int32_t result);
int32_t function_27094(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_27098(int32_t a1, int32_t a2, int32_t a3);
int32_t function_2709c(int32_t result);
int32_t function_270a0(int32_t result, int32_t a2, int32_t a3);
int32_t function_270a6(int32_t a1);
int32_t function_270a8(void);
int32_t function_270aa(int32_t a1);
int32_t function_270ac(void);
int32_t function_270b0(void);
int32_t function_270b4(int32_t a1, int32_t a2, int32_t a3);
int32_t function_270b8(void);
int32_t function_270bc(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_270c0(void);
int32_t function_270c4(void);
int32_t function_270c8(void);
int32_t function_270ce(void);
int32_t function_270d0(int32_t a1, int32_t a2, int32_t a3);
int32_t function_270d4(int32_t a1);
int32_t function_270d8(void);
int32_t function_270dc(int32_t a1, int32_t a2, int32_t a3);
int32_t function_270e0(void);
int32_t function_270e4(void);
int32_t function_270e8(void);
int32_t function_270ec(int32_t a1, int32_t a2, int32_t a3);
int32_t function_270f2(int32_t a1, int32_t a2);
int32_t function_270f6(void);
int32_t function_270f8(int32_t a1, int32_t a2);
int32_t function_270fc(int32_t a1);
int32_t function_27100(int32_t a1, int32_t a2);
int32_t function_27106(int32_t a1);
int32_t function_27108(void);
int32_t function_2710c(int32_t a1);
int32_t function_27110(void);
int32_t function_27114(int32_t result);
int32_t function_27118(void);
int32_t function_2711c(void);
int32_t function_2711e(int32_t a1);
int32_t function_27120(void);
int32_t function_2712e(void);
int32_t function_27130(void);
int32_t function_27142(int32_t a1);
int32_t function_27144(void);
int32_t function_27148(void);
int32_t function_2714c(void);
int32_t function_27150(int32_t a1);
int32_t function_2715a(void);
int32_t function_2715c(int32_t a1, int32_t a2, int32_t a3, uint32_t a4);
int32_t function_27198(int32_t a1, int32_t a2);
int32_t function_2719c(void);
int32_t function_271a0(void);
int32_t function_271ac(int32_t result);
int32_t function_271b4(int32_t result);
int32_t function_271b8(int32_t a1, int32_t a2);
int32_t function_271bc(void);
int32_t function_271c4(void);
int32_t function_271c8(void);
int32_t function_271ce(void);
int32_t function_271d0(int32_t a1);
int32_t function_271d4(int32_t a1);
int32_t function_271d8(int32_t a1);
int32_t function_271dc(void);
int32_t function_271e0(void);
int32_t function_271e4(void);
int32_t function_271e6(void);
int32_t function_271ea(int32_t a1);
int32_t function_271f8(int32_t a1, int32_t a2);
int32_t function_271fc(void);
int32_t function_27200(int32_t a1);
int32_t function_27204(void);
int32_t function_27208(int32_t a1);
int32_t function_2720c(void);
int32_t function_27210(void);
int32_t function_27216(int32_t a1, int32_t a2, int32_t a3);
int32_t function_27226(void);
int32_t function_2722a(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_27230(int32_t a1);
int32_t function_27234(int32_t a1, int32_t a2);
int32_t function_27238(void);
int32_t function_2723c(void);
int32_t function_27248(void);
int32_t function_27254(int32_t result);
int32_t function_27258(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_27264(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_27268(int32_t result);
int32_t function_2726c(int32_t a1);
int32_t function_27270(int32_t a1, int32_t a2, int32_t a3);
int32_t function_27274(void);
int32_t function_27278(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2727c(int32_t a1);
int32_t function_27282(void);
int32_t function_27284(int32_t a1);
int32_t function_27288(void);
int32_t function_2728e(void);
int32_t function_27290(void);
int32_t function_27298(int32_t result);
int32_t function_2729a(void);
int32_t function_2729c(int32_t result);
int32_t function_272a0(int32_t a1);
int32_t function_272a8(void);
int32_t function_272c2(void);
int32_t function_272c6(void);
int32_t function_272ca(void);
int32_t function_272ce(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_272d4(int32_t a1);
int32_t function_272d8(int32_t a1);
int32_t function_272dc(int32_t result, int32_t a2, int32_t a3);
int32_t function_272e2(int32_t a1);
int32_t function_272e6(void);
int32_t function_272ea(int32_t a1);
int32_t function_272ec(int32_t result);
int32_t function_272f2(void);
int32_t function_272f4(int32_t a1);
int32_t function_272f8(int32_t a1);
int32_t function_272fe(int32_t a1);
int32_t function_27300(int32_t a1);
int32_t function_27304(void);
int32_t function_27308(int32_t a1);
int32_t function_2730c(int32_t result, int32_t a2, int32_t a3);
int32_t function_27310(int32_t a1, int32_t a2);
int32_t function_27314(int32_t a1, int32_t a2);
int32_t function_27318(void);
int32_t function_2731c(int32_t a1);
int32_t function_27320(int32_t result);
int32_t function_27324(int32_t result, int32_t a2, int32_t a3);
int32_t function_27334(void);
int32_t function_27340(void);
int32_t function_27346(void);
int32_t function_27348(int32_t a1);
int32_t function_2734c(void);
int32_t function_27352(void);
int32_t function_27354(int32_t a1, int32_t a2);
int32_t function_2735c(int32_t result);
int32_t function_27360(void);
int32_t function_2737e(int32_t a1);
int32_t function_27380(void);
int32_t function_27384(int32_t result);
int32_t function_27388(void);
int32_t function_2738c(int32_t a1, int32_t result);
int32_t function_2738e(int32_t a1);
int32_t function_27390(void);
int32_t function_27396(void);
int32_t function_27398(void);
int32_t function_273a6(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_273ac(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_273b2(int32_t a1);
int32_t function_273b4(int32_t a1);
int32_t function_273b8(int32_t result, int32_t a2);
int32_t function_273be(void);
int32_t function_273c0(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_273cc(void);
int32_t function_273ce(void);
int32_t function_273d0(void);
int32_t function_273d6(void);
int32_t function_273d8(void);
int32_t function_273dc(int32_t a1, int32_t a2);
int32_t function_273e0(void);
int32_t function_273e4(void);
int32_t function_273ec(void);
int32_t function_273f0(int32_t a1, int32_t a2);
int32_t function_273fe(void);
int32_t function_27400(int32_t a1);
int32_t function_27404(void);
int32_t function_27408(int32_t a1, int32_t a2, uint32_t a3);
int32_t function_2740c(int32_t result, int32_t a2, int32_t a3);
int32_t function_27410(int32_t result, int32_t a2, int32_t a3);
int32_t function_27412(void);
int32_t function_27414(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_27418(int32_t result);
int32_t function_2741c(void);
int32_t function_27420(int32_t a1, int32_t a2, int32_t a3);
int32_t function_27424(int32_t a1);
int32_t function_2742a(int32_t a1);
int32_t function_2742e(void);
int32_t function_27430(void);
int32_t function_27432(void);
int32_t function_27436(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_27440(int32_t result);
int32_t function_27444(int32_t a1);
int32_t function_2744e(void);
int32_t function_27454(void);
int32_t function_27458(int32_t a1);
int32_t function_2745e(void);
int32_t function_27462(int32_t a1);
int32_t function_27466(int32_t a1);
int32_t function_27468(int32_t a1);
int32_t function_2746e(void);
int32_t function_27470(int32_t a1, int32_t a2);
int32_t function_27474(int32_t result);
int32_t function_27478(void);
int32_t function_2747a(void);
int32_t function_2747c(void);
int32_t function_27480(void);
int32_t function_27482(void);
int32_t function_27484(int32_t a1);
int32_t function_27490(void);
int32_t function_27494(int32_t a1);
int32_t function_274a2(int32_t a1);
int32_t function_274a4(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_274ae(void);
int32_t function_274b2(void);
int32_t function_274b4(int32_t result);
int32_t function_274b8(void);
int32_t function_274c0(void);
int32_t function_274c6(void);
int32_t function_274c8(void);
int32_t function_274ce(void);
int32_t function_274d0(uint32_t a1);
int32_t function_274de(void);
int32_t function_274e2(void);
int32_t function_274e4(int32_t result, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_274f6(int32_t a1);
int32_t function_274f8(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_27504(int32_t result);
int32_t function_27506(int32_t a1);
int32_t function_2750a(void);
int32_t function_2750c(int32_t result);
int32_t function_27512(int32_t a1);
int32_t function_2751a(void);
int32_t function_2751c(int32_t result, int32_t a2, int32_t a3);
int32_t function_27520(int32_t result);
int32_t function_27524(void);
int32_t function_2752a(int32_t a1);
int32_t function_2752e(void);
int32_t function_27530(void);
int32_t function_2754a(void);
int32_t function_2754c(int32_t a1);
int32_t function_27550(int32_t a1);
int32_t function_27554(void);
int32_t function_27558(void);
int32_t function_2755e(void);
int32_t function_27560(void);
int32_t function_27566(void);
int32_t function_27568(int32_t a1, int32_t a2);
int32_t function_2756c(int32_t a1);
int32_t function_27572(void);
int32_t function_27574(void);
int32_t function_27590(int32_t a1);
int32_t function_27594(int32_t a1);
int32_t function_27598(void);
int32_t function_2759c(int32_t a1);
int32_t function_275a0(void);
int32_t function_275a4(int32_t a1);
int32_t function_275a8(int32_t a1, int32_t a2, int32_t a3);
int32_t function_275ac(int32_t a1);
int32_t function_275b2(void);
int32_t function_275b4(void);
int32_t function_275b8(int32_t result);
int32_t function_275be(int32_t a1);
int32_t function_275c0(int32_t a1, int32_t a2, int32_t a3, uint32_t a4);
int32_t function_275fc(int32_t a1);
int32_t function_2763a(void);
int32_t function_2763c(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_27648(void);
int32_t function_2764c(int32_t result, int32_t a2, int32_t a3);
int32_t function_27650(void);
int32_t function_27656(void);
int32_t function_2765a(void);
int32_t function_2765c(void);
int32_t function_27662(void);
int32_t function_27664(void);
int32_t function_2766a(void);
int32_t function_2766c(void);
int32_t function_27674(void);
int32_t function_2767e(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_27686(void);
int32_t function_27688(void);
int32_t function_2768e(int32_t a1, int32_t result);
int32_t function_27694(int32_t result, int32_t a2);
int32_t function_27696(void);
int32_t function_27698(void);
int32_t function_276a6(void);
int32_t function_276aa(void);
int32_t function_276ac(int32_t a1);
int32_t function_276b0(void);
int32_t function_276b4(void);
int32_t function_276b8(int32_t result);
int32_t function_276bc(void);
int32_t function_276c0(int32_t a1, int32_t a2, int32_t a3);
int32_t function_276c4(void);
int32_t function_276c8(void);
int32_t function_276d2(int32_t a1);
int32_t function_276d4(void);
int32_t function_276dc(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_276e6(void);
int32_t function_276e8(int32_t a1);
int32_t function_276ee(void);
int32_t function_276f2(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_276fa(void);
int32_t function_276fc(void);
int32_t function_27700(int32_t result);
int32_t function_27706(void);
int32_t function_27708(void);
int32_t function_2770e(void);
int32_t function_27712(void);
int32_t function_27714(int32_t a1, int32_t a2, int32_t a3);
int32_t function_27718(int32_t result, int32_t a2);
int32_t function_2771e(int16_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_27732(void);
int32_t function_27734(int32_t a1, int32_t a2, int32_t a3);
int32_t function_2773c(void);
int32_t function_27740(void);
int32_t function_277402(void);
int32_t function_27742(void);
int32_t function_27746(int32_t a1);
int32_t function_2774c(int32_t result);
int32_t function_27750(int32_t a1);
int32_t function_27756(int32_t a1);
int32_t function_2775c(int32_t result);
int32_t function_27762(void);
int32_t function_27764(int32_t a1);
int32_t function_27768(void);
int32_t function_2776e(int32_t a1);
int32_t function_27772(int32_t result);
int32_t function_2777a(int32_t a1, int32_t result, int32_t a3, int32_t a4);
int32_t function_27782(void);
int32_t function_27784(void);
int32_t function_27786(void);
int32_t function_2778a(int32_t a1);
int32_t function_27790(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_277a6(void);
int32_t function_277aa(int32_t a1);
int32_t function_277ae(void);
int32_t function_277be(void);
int32_t function_277c0(void);
int32_t function_277c1a(void);
int32_t function_277c2(int32_t a1, int32_t a2);
int32_t function_277da(int32_t a1);
int32_t function_277e6(void);
int32_t function_277ea(void);
int32_t function_277ee(int32_t a1);
int32_t function_277f4(int32_t a1);
int32_t function_277f6(void);
int32_t function_277fa(void);
int32_t function_27800(int32_t result, int32_t a2, int32_t a3);
int32_t function_27804(int32_t a1);
int32_t function_27808(int32_t result);
int32_t function_2780c(int32_t a1);
int32_t function_27810(void);
int32_t function_27814(int32_t a1);
int32_t function_27818(int32_t a1);
int32_t function_2781c(int32_t a1);
int32_t function_27820(int32_t a1, int32_t a2, uint32_t a3, int32_t a4);
int32_t function_27836(void);
int32_t function_2783a(int32_t a1);
int32_t function_2783c(int32_t a1);
int32_t function_27840(int32_t result, int32_t a2);
int32_t function_27844(void);
int32_t function_27848(int32_t a1);
int32_t function_2784e(void);
int32_t function_27852(void);
int32_t function_27854(void);
int32_t function_27858(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_27860(void);
int32_t function_27866(int32_t a1, int32_t a2);
int32_t function_2786a(void);
int32_t function_2786e(int32_t a1);
int32_t function_27870(void);
int32_t function_27876(void);
int32_t function_27878(void);
int32_t function_27886(void);
int32_t function_27888(int32_t result);
int32_t function_2788e(void);
int32_t function_27892(void);
int32_t function_27894(void);
int32_t function_27896(void);
int32_t function_2789a(void);
int32_t function_2789c(void);
int32_t function_2789e(void);
int32_t function_278a2(void);
int32_t function_278a4(int32_t a1, int32_t a2);
int32_t function_278aa(void);
int32_t function_278ac(void);
int32_t function_278ae(void);
int32_t function_278b0(int32_t result, int32_t a2);
int32_t function_278b2(int32_t result, int32_t a2, int32_t a3);
int32_t function_278ba(void);
int32_t function_278bc(int32_t result);
int32_t function_278c0(int32_t a1);
int32_t function_278c4(void);
int32_t function_278c6(void);
int32_t function_278c8(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_278d4(void);
int32_t function_278ea(void);
int32_t function_278ec(int32_t a1, int32_t a2, int32_t a3);
int32_t function_278f2(void);
int32_t function_278f6(void);
int32_t function_278f8(void);
int32_t function_278fe(void);
int32_t function_27906(void);
int32_t function_27908(int32_t a1, int32_t a2);
int32_t function_27918(void);
int32_t function_27934(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_27940(void);
int32_t function_27a58(void);
int32_t function_27acba(void);
int32_t function_27acca(void);
int32_t function_27ad56(void);
int32_t function_27ad76(void);
int32_t function_27ad9a(void);
int32_t function_27b1ca(void);
int32_t function_27b20a(void);
int32_t function_27b70(void);
int32_t function_27c88(void);
int32_t function_27da0(void);
int32_t function_27eb8(void);
int32_t function_27f58(void);
int32_t function_27ff8(void);
int32_t function_28098(void);
int32_t function_28138(int32_t a1);
int32_t function_281b8(void);
int32_t function_281d4(int32_t a1, int32_t a2);
int32_t function_28208(int32_t a1, int32_t a2);
int32_t function_2823c(void);
int32_t function_282c4(int32_t a1);
int32_t function_282e4(int32_t format, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2832c(void);
int32_t function_28344(void);
int32_t function_2835c(void);
int32_t function_28374(void);
int32_t function_2838c(int32_t a1);
int32_t function_283e4(void);
int32_t function_28878(void);
int32_t function_288c4(int32_t a1);
int32_t function_289b8(int32_t a1, int32_t a2);
int32_t function_28d40(int32_t a1, uint32_t a2);
int32_t function_28d70(int32_t a1, uint32_t a2);
int32_t function_28d9c(int32_t a1, int32_t a2);
int32_t function_28dd0(int32_t a1, int32_t a2, int32_t a3);
int32_t function_28e18(int32_t a1, int32_t a2);
int32_t function_28e74(int32_t a1, int32_t a2, int32_t a3);
int32_t function_28ee8(int32_t a1, int32_t a2, int32_t a3);
int32_t function_28f5c(char * a1, int32_t a2);
int32_t function_28fb8(char * a1, int32_t a2);
int32_t function_29014(char * a1, int32_t a2);
int32_t function_29070(int32_t * a1, char * a2, int32_t a3);
int32_t function_290b4(void);
int32_t function_292e0(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2932c(int32_t str, int32_t a2, int32_t a3);
int32_t function_2935c(int32_t str);
int32_t function_29458(void);
int32_t function_294b8(void);
int32_t function_294ba(int32_t a1, int32_t a2);
int32_t function_294bd6(void);
int32_t function_294c76(void);
int32_t function_2951da(void);
int32_t function_29564(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10);
int32_t function_2964c(void);
int32_t function_29710(int32_t result);
int32_t function_2974c(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11, int32_t a12);
int32_t function_299da6(void);
int32_t function_2a1a4(int32_t a1);
int32_t function_2a1e0(int32_t * a1, char * a2, char * a3, int32_t a4);
int32_t function_2a2332(void);
int32_t function_2a264(int32_t a1, int32_t * a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_2a32b2(void);
int32_t function_2a3c4(int32_t a1);
int32_t function_2a570(void);
int32_t function_2a574(void);
int32_t function_2a578(void);
int32_t function_2a688(void);
int32_t function_2ab48(int32_t * a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2acec(void);
int32_t function_2ada0(int32_t str4);
int32_t function_2aef4(void);
int32_t function_2afc4(int32_t a1, int32_t a2);
int32_t function_2b05c(int32_t a1, int32_t a2, int32_t a3);
int32_t function_2b2232(void);
int32_t function_2b2f4(void);
int32_t function_2b330(int32_t a1, int32_t a2);
int32_t function_2b703a(void);
int32_t function_2b800(int32_t a1);
int32_t function_2b85c6(void);
int32_t function_2b944(int32_t a1, int32_t a2);
int32_t function_2ba832(void);
int32_t function_2baaaa(void);
int32_t function_2bacd6(void);
int32_t function_2bad92(void);
int32_t function_2bb44(int32_t a1, int32_t a2);
int32_t function_2bc2c(int32_t a1, int32_t a2);
int32_t function_2bdc4(int32_t a1);
int32_t function_2bdd0(void);
int32_t function_2be08(void);
int32_t function_2be40(uint32_t a1, uint32_t a2);
int32_t function_2c06c(uint32_t a1, uint32_t a2, int32_t a3);
int32_t function_2c2e8(uint32_t a1, int32_t a2, int32_t a3, int32_t * a4);
int32_t function_2c5e8(int32_t * a1);
int32_t function_2c96c(int32_t * a1);
int32_t function_2cb2c(void);
int32_t function_2cd30(int32_t a1, int32_t a2);
int32_t function_2cdfc(uint32_t a1, uint32_t a2);
int32_t function_2ce20(void);
int32_t function_2cfec(void);
int32_t function_2cffc(int32_t a1, int32_t a2);
int32_t function_2d158(void);
int32_t function_2d340(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2d4bd2(void);
int32_t function_2d4c72(void);
int32_t function_2d67c(int32_t a1);
int32_t function_2d724(int32_t a1, int32_t a2, int32_t a3, int32_t a4, char a5, int32_t a6, int32_t a7, int32_t a8);
int32_t function_2d9d4(int32_t a1);
int32_t function_2da5c(int32_t a1);
int32_t function_2da88(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2db50(int32_t a1, int32_t result, int32_t a3, int32_t a4, int32_t a5);
int32_t function_2dc24(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_2dd70(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_2deb8(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_2e00c(int32_t a1, int32_t result, int32_t a3, int32_t a4, int32_t a5);
int32_t function_2e0f8(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_2e23e6(void);
int32_t function_2e268(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_2e3d4(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2e4f0(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2e584(int32_t a1, int32_t * str2, int32_t a3);
int32_t function_2e828(int32_t a1);
int32_t function_2e8a4(void);
int32_t function_2e92c(int32_t * a1, int32_t a2, int32_t a3);
int32_t function_2e9a4(int32_t a1, int32_t a2, int32_t a3);
int32_t function_2ea54(int32_t a1, int32_t * str, int32_t a3);
int32_t function_2ee28(int32_t result, int32_t a2, int32_t a3);
int32_t function_2f024(int32_t * a1);
int32_t function_2f054(int32_t * a1, int32_t * a2, uint32_t a3);
int32_t function_2f100(int32_t * a1, int32_t a2);
int32_t function_2f1ec(int32_t a1, int32_t a2, int32_t * a3);
int32_t function_2f250(void);
int32_t function_2f258(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2f2c0(int32_t a1, char * a2, int32_t a3);
int32_t function_2f33c(char * a1, int32_t a2);
int32_t function_2f3a0(int32_t a1, int32_t a2);
int32_t function_2f408(uint32_t a1, char * a2, char * a3, int32_t a4);
int32_t function_2f490(int32_t a1, uint32_t a2, char * a3, char * a4, int32_t a5);
int32_t function_2f520(int32_t a1, uint32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_2f5b4(int32_t a1);
int32_t function_2f600(int32_t result, int32_t a2, int32_t a3);
int32_t function_2f670(int32_t * a1, uint32_t a2);
int32_t function_2f724(int32_t * a1, int32_t a2, int32_t a3);
int32_t function_2f812e(void);
int32_t function_2f8e8(int32_t * a1, int32_t str);
int32_t function_2f967e(void);
int32_t function_2f9c0(int32_t a1, int32_t a2);
int32_t function_2fa0c(int32_t a1, int32_t a2);
int32_t function_2fada2(void);
int32_t function_2fb1ee(void);
int32_t function_2fbfc(void);
int32_t function_2fc58(int32_t a1);
int32_t function_2fcc0(void);
int32_t function_2fcc8(void);
int32_t function_2fcd0(int32_t a1, int32_t a2);
int32_t function_2fda4(int32_t a1, int32_t abstime);
int32_t function_2fe84(int32_t a1);
int32_t function_2fec0(int32_t result, int32_t a2);
int32_t function_2fef4(int32_t result, int32_t a2);
int32_t function_2ff38(int32_t a1, int32_t a2);
int32_t function_2ff6c(int32_t a1, int32_t a2);
int32_t function_2ffa0(int32_t result, int32_t a2);
int32_t function_2ffd0(int32_t result, int32_t a2);
int32_t function_2ffec(int32_t a1);
int32_t function_30024(int32_t * a1);
int32_t function_30064(int32_t * a1);
int32_t function_300a4(int32_t a1);
int32_t function_300e0(int32_t result, int32_t a2);
int32_t function_30168(int32_t str, int32_t str2);
int32_t function_30258(int32_t str);
int32_t function_302a0(int32_t * a1);
int32_t function_302e4(int32_t a1);
int32_t function_30314(int32_t a1, int32_t a2, int32_t a3);
int32_t function_30350(int32_t a1);
int32_t function_3035c(int32_t * a1, int32_t a2);
int32_t function_3041c(int32_t * a1);
int32_t function_304d4(int32_t a1);
int32_t function_30500(int32_t a1, int32_t a2);
int32_t function_30534(void);
int32_t function_30538(int32_t result);
int32_t function_3053c(int32_t a1);
int32_t function_30540(void);
int32_t function_30544(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_30578(int32_t * a1, int32_t * a2);
int32_t function_305cc(int32_t a1, int32_t a2, int32_t a3);
int32_t function_305d0(void);
int32_t function_305d6(void);
int32_t function_305de(void);
int32_t function_305e0(int32_t a1);
int32_t function_305e4(int32_t a1, int32_t a2, int32_t a3);
int32_t function_305ee(void);
int32_t function_30600(void);
int32_t function_30604(void);
int32_t function_30614(int32_t a1, int32_t a2, int32_t a3);
int32_t function_30674(int32_t a1, int32_t a2, int32_t a3);
int32_t function_3067c(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_30784(int32_t result, int32_t a2);
int32_t function_30860(int32_t result, int32_t str);
int32_t function_30890(void);
int32_t function_30892(int32_t a1, int32_t a2, int32_t a3, uint32_t a4);
int32_t function_308e0(int32_t a1, int32_t a2, int32_t a3);
int32_t function_308e8(int32_t a1, int32_t a2, int32_t a3);
int32_t function_30928(void);
int32_t function_30934(int32_t str2);
int32_t function_30a54(int32_t a1);
int32_t function_30a94(int32_t sem, char * a2, char * a3, int32_t a4);
int32_t function_30b10(int32_t a1, int32_t * attr, int32_t * thread_func, int32_t thread_func_arg);
int32_t function_30b58(int32_t a1, char * a2, char * a3, int32_t a4);
int32_t function_30b90(int32_t a1);
int32_t function_30bd8(void);
int32_t function_30bdc(int32_t result, int32_t a2, int32_t a3);
int32_t function_30bec(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_30bf0(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_30c54(int32_t sem, int32_t a2, char * a3, char * a4);
int32_t function_30d28(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_30d2c(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t function_30d36(int32_t a1);
int32_t function_30d3c(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_30d4c(int32_t result, int32_t a2);
int32_t function_30d70(int32_t a1);
int32_t function_30d74(void);
int32_t function_30da4(int32_t sem);
int32_t function_30dd8(void);
int32_t function_30ddc(int32_t a1, int32_t a2, int32_t a3);
int32_t function_30e64(uint32_t a1, int32_t a2);
int32_t function_30e6c(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_30e80(int32_t thread);
int32_t function_30ea8(int32_t result, int32_t * a2, int32_t a3, char * a4, int32_t a5, int32_t a6);
int32_t function_31018(int32_t a1);
int32_t function_31078(int32_t a1);
int32_t function_3107c(void);
int32_t function_3107e(void);
int32_t function_31080(int32_t a1);
int32_t function_310a4(int32_t str, int32_t a2);
int32_t function_311b8(void);
int32_t function_311ec(int32_t a1, int32_t a2, int32_t a3);
int32_t function_31248(int32_t a1);
int32_t function_3124c(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_31260(void);
int32_t function_31268(int32_t * a1, int32_t a2);
int32_t function_312a8(int32_t a1, int32_t a2);
int32_t function_314eae(void);
int32_t function_31590(int32_t * a1, int32_t a2);
int32_t function_315ec(int32_t a1, int32_t a2);
int32_t function_316b0(int32_t * a1, int32_t * a2, uint32_t a3);
int32_t function_316d8(int32_t a1, int32_t a2);
int32_t function_31720(int32_t * a1);
int32_t function_31980(int32_t * str4, int32_t a2);
int32_t function_31bac(void);
int32_t function_31c64(int32_t a1, int32_t a2, int32_t * a3, int32_t * a4);
int32_t function_31cac(void);
int32_t function_31d38(void);
int32_t function_31d48(void);
int32_t function_31d58(int32_t a1, char * a2);
int32_t function_31f90(int32_t a1);
int32_t function_32010(uint32_t a1);
int32_t function_3204c(void);
int32_t function_3208c(void);
int32_t function_3218c(uint32_t a1);
int32_t function_321b8(int32_t a1, int32_t a2, int32_t a3);
int32_t function_323dc(void);
int32_t function_324a8(void);
int32_t function_32520(void);
int32_t function_32530(void);
int32_t function_3264c(void);
int32_t function_32924(int32_t a1);
int32_t function_329dc(void);
int32_t function_32bd0(void);
int32_t function_32ca8(void);
int32_t function_32cc0(int32_t * a1, int32_t a2, int32_t a3);
int32_t function_32f3c(void);
int32_t function_32f40(uint32_t a1);
int32_t function_3345c(void);
int32_t function_33478(int32_t result, int32_t a2);
int32_t function_3388c(void);
int32_t function_33950(void);
int32_t function_339ec(void);
int32_t function_33e34(void);
int32_t function_3403c(void);
int32_t function_34680(void);
int32_t function_34750(uint32_t a1, int32_t a2);
int32_t function_34818(void);
int32_t function_34828(uint32_t a1, char a2, int16_t a3, int16_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t function_350e8(void);
int32_t function_351102(void);
int32_t function_35344(void);
int32_t function_356c4(int32_t a1, int32_t a2);
int32_t function_359ec(void);
int32_t function_359f8(int32_t a1);
int32_t function_35a28(void);
int32_t function_35b1c(void);
int32_t function_35b804(void);
int32_t function_35b80c(void);
int32_t function_35bba(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_35c00(void);
int32_t function_35c04(int32_t a1);
int32_t function_35c74(void);
int32_t function_35d24(int32_t a1, int32_t a2, int32_t a3);
int32_t function_36174(int32_t result);
int32_t function_361e4(int32_t result);
int32_t function_361f4(void);
int32_t function_36204(void);
int32_t function_36208(int32_t a1);
int32_t function_36218(void);
int32_t function_362a0(int32_t a1);
int32_t function_36538(int32_t * a1);
int32_t function_36548(void);
int32_t function_36558(int32_t result);
int32_t function_36568(void);
int32_t function_3656c(void);
int32_t function_365e8(int32_t a1);
int32_t function_36680(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t function_367e4(void);
int32_t function_36884(void);
int32_t function_36908(void);
int32_t function_36a0c(void);
int32_t function_36aa8(void);
int32_t function_36b04(void);
int32_t function_36ca8(int32_t a1, int32_t a2, uint32_t a3, int32_t a4);
int32_t function_36d66(int32_t a1);
int32_t function_36d6c(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t function_36d74(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t function_36dbc(int32_t a1);
int32_t function_36e7c(int32_t a1);
int32_t function_36f2c(void);
int32_t function_36f6c(int32_t a1, int32_t a2);
int32_t function_37288(void);
int32_t function_37290(uint32_t a1, int32_t a2, int32_t str);
int32_t function_373c8(void);
int32_t function_373d4(void);
int32_t function_37424(void);
int32_t function_37434(void);
int32_t function_37444(void);
int32_t function_37450(void);
int32_t function_37460(void);
int32_t function_37494(void);
int32_t function_37498(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t function_374a4(int32_t str);
int32_t function_37538(int32_t a1);
int32_t function_37574(void);
int32_t function_375e4(void);
int32_t function_375e8(void);
int32_t function_375fc(int32_t a1);
int32_t function_37694(int32_t a1);
int32_t function_377b8(void);
int32_t function_377d8(int32_t a1);
int32_t function_378a2(int32_t a1);
int32_t function_378a4(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_37ac0(int32_t a1, int32_t a2, int32_t a3);
int32_t function_37b50(int32_t a1);
int32_t function_37bdc(void);
int32_t function_37be6(int32_t a1);
int32_t function_37be8(int32_t a1);
int32_t function_37c40(int32_t a1);
int32_t function_37c48(void);
int32_t function_37c4c(int32_t a1);
int32_t function_37f08(void);
int32_t function_37f72(int32_t a1);
int32_t function_37f74(int32_t result, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11);
int32_t function_37f7c(void);
int32_t function_37f88(void);
int32_t function_37fa0(int32_t * a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_38110(int32_t a1);
int32_t function_38450(void);
int32_t function_384c0(int32_t a1);
int32_t function_38520(char a1);
int32_t function_3859c(int32_t a1, int32_t a2, uint32_t a3);
int32_t function_3864e(int32_t a1);
int32_t function_38650(int32_t a1);
int32_t function_3867c(int32_t a1);
int32_t function_386b6(int32_t a1);
int32_t function_386b8(void);
int32_t function_386bc(int32_t a1, int32_t a2);
int32_t function_387f8(void);
int32_t function_3883c(int32_t a1);
int32_t function_388f4(int32_t a1);
int32_t function_3893c(int32_t a1);
int32_t function_389f0(int32_t a1);
int32_t function_38b6c(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t function_38c64(void);
int32_t function_38c70(int32_t a1, int32_t result);
int32_t function_38e40(void);
int32_t function_38f58(void);
int32_t function_39018(void);
int32_t function_390b0(int32_t a1);
int32_t function_39128(int32_t * a1);
int32_t function_391f4(void);
int32_t function_392b8(int32_t result);
int32_t function_39360(void);
int32_t function_39404(int32_t result);
int32_t function_394a6(int32_t a1);
int32_t function_394c0(void);
int32_t function_394d8(void);
int32_t function_39584(int32_t result);
int32_t function_3962c(int32_t result, int32_t a2);
int32_t function_397a0(int32_t a1);
int32_t function_398bc(void);
int32_t function_39954(void);
int32_t function_39998(void);
int32_t function_399d8(uint32_t a1);
int32_t function_39a7c(void);
int32_t function_39b60(int32_t a1);
int32_t function_39d44(int32_t result);
int32_t function_39d4c(int32_t result);
int32_t function_39d54(int32_t result);
int32_t function_39d58(int32_t a1, int32_t a2, int32_t a3, int32_t result);
int32_t function_39d5e(void);
int32_t function_39d6c(void);
int32_t function_39d88(void);
int32_t function_39ea0(void);
int32_t function_39fb4(int32_t a1);
int32_t function_3a054(int32_t result6, int32_t a2);
int32_t function_3a828(int32_t a1, int32_t a2);
int32_t function_3a86c(int32_t * a1);
int32_t function_3ac6c(void);
int32_t function_3ac94(void);
int32_t function_3adcc(void);
int32_t function_3ae88(int32_t a1);
int32_t function_3aea0(int32_t a1);
int32_t function_3af04(int32_t a1);
int32_t function_3af1c(void);
int32_t function_3b226(void);
int32_t function_3b22c(void);
int32_t function_3b272(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_3b2c4(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11, int32_t a12);
int32_t function_3b8a0(int32_t a1, int32_t a2);
int32_t function_3b8de(void);
int32_t function_3b8e0(int32_t result, int32_t a2, int32_t a3);
int32_t function_3b8e8(int32_t a1, int32_t a2);
int32_t function_3b94c(int32_t a1, int32_t a2);
int32_t function_3ba18(int32_t a1, int32_t a2);
int32_t function_3ba5c(int32_t a1);
int32_t function_3ba60(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_3bab4(void);
int32_t function_3bae4(int32_t a1);
int32_t function_3bb82(void);
int32_t function_3bb84(uint32_t a1, uint32_t a2, int32_t a3, int32_t a4);
int32_t function_3bc0c(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t function_3bc48(int32_t a1, int32_t a2);
int32_t function_3be08(void);
int32_t function_3be2a(void);
int32_t function_3be2c(int32_t a1);
int32_t function_3be4c(void);
int32_t function_3be84(void);
int32_t function_3bec4(int32_t a1);
int32_t function_3bee0(int32_t a1, int32_t a2);
int32_t function_3bf74(int32_t a1);
int32_t function_3bf94(void);
int32_t function_3c10a(void);
int32_t function_3c10c(void);
int32_t function_3c160(int32_t result, int32_t a2);
int32_t function_3c162(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_3c174(void);
int32_t function_3c204(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_3c38e(void);
int32_t function_3c394(void);
int32_t function_3c3da(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_3c402(void);
int32_t function_3c404(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_3c490(uint32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_3c498(int32_t a1);
int32_t function_3c49c(int32_t a1);
int32_t function_3c4a8(int32_t result);
int32_t function_3c4ae(void);
int32_t function_3c4b0(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_3c5dc(void);
int32_t function_3c628(int32_t a1);
int32_t function_3c62c(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11, int32_t a12);
int32_t function_3c7ea(void);
int32_t function_3c7ec(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_3c830(void);
int32_t function_3c93c(int32_t a1);
int32_t function_3c940(void);
int32_t function_3c968(int32_t a1);
int32_t function_3cab6(int32_t result);
int32_t function_3caba(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_3cb0a(void);
int32_t function_3cb0c(int32_t a1);
int32_t function_3cb18(void);
int32_t function_3cb1e(void);
int32_t function_3cb20(int32_t a1);
int32_t function_3cb58(uint32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_3cb5e(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_3cb78(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_3cc34(void);
int32_t function_3cc6c(int32_t a1, int32_t usec);
int32_t function_3cdd8(void);
int32_t function_3ce40(void);
int32_t function_3ce78(int32_t format);
int32_t function_3ceb0(int32_t format);
int32_t function_3cee0(void);
int32_t function_3cf48(int32_t a1);
int32_t function_3cf90(int32_t format);
int32_t function_3cfd4(void);
int32_t function_3cfe4(void);
int32_t function_3d01c(void);
int32_t function_3d02c(void);
int32_t function_3d080(int32_t result, int32_t a2);
int32_t function_3d082(void);
int32_t function_3d08c(int32_t a1, int32_t a2, int32_t a3, uint32_t a4);
int32_t function_3d0a8(void);
int32_t function_3d0cc(void);
int32_t function_3d104(void);
int32_t function_3d13c(void);
int32_t function_3d148(void);
int32_t function_3d180(void);
int32_t function_3d1b8(int32_t result);
int32_t function_3d1c2(void);
int32_t function_3d1c4(int32_t result);
int32_t function_3d1c8(int32_t a1);
int32_t function_3d210(void);
int32_t function_3d26c(void);
int32_t function_3d2a0(void);
int32_t function_3d2b4(char * str2, int32_t str);
int32_t function_3d2f0(int32_t a1);
int32_t function_3d300(int32_t a1);
int32_t function_3d310(int32_t a1);
int32_t function_3d320(int32_t a1, int32_t a2);
int32_t function_3d3b4(int32_t a1, int32_t a2);
int32_t function_3d3ce(int32_t result, int32_t a2, int32_t a3);
int32_t function_3d3d4(int32_t a1, int32_t * a2);
int32_t function_3d3e0(int32_t str, int32_t a2);
int32_t function_3d468(int32_t a1, int32_t * a2);
int32_t function_3d4f0(int32_t a1, int32_t a2);
int32_t function_3d518(int32_t a1, int32_t a2);
int32_t function_3d568(int32_t a1, int32_t a2);
int32_t function_3d5b8(int32_t a1);
int32_t function_3d5d0(void);
int32_t function_3d5f0(int32_t a1);
int32_t function_3d630(void);
int32_t function_3d654(void);
int32_t function_3d678(int32_t a1, int32_t a2);
int32_t function_3d6d8(int32_t str, int32_t a2);
int32_t function_3d6ec(void);
int32_t function_3d6ee(void);
int32_t function_3d6f8(void);
int32_t function_3d6fc(void);
int32_t function_3d700(int32_t a1, int32_t a2, int32_t a3);
int32_t function_3d706(void);
int32_t function_3d70c(void);
int32_t function_3d716(int32_t a1, int32_t a2);
int32_t function_3d744(int32_t str, int32_t a2, uint32_t a3);
int32_t function_3d754(int32_t a1, int32_t a2);
int32_t function_3d7f4(int32_t a1, int32_t a2);
int32_t function_3d83c(int32_t a1, uint32_t a2, int32_t a3);
int32_t function_3d8f4(int32_t * a1);
int32_t function_3da68(int32_t * a1);
int32_t function_3dacc(int32_t * a1, int32_t * a2);
int32_t function_3db24(int32_t a1, int32_t a2, int32_t * a3);
int32_t function_3db7c(int32_t * a1);
int32_t function_3dbdc(int32_t a1, int32_t a2);
int32_t function_3dc3c(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t function_3dc80(char (**a1)[15], char * a2);
int32_t function_3dd54(int32_t * a1, int32_t a2, int32_t a3);
int32_t function_3ddb0(void);
int32_t function_3ddd0(int32_t format, int32_t a2, int32_t a3, int32_t a4);
int32_t function_3de18(int32_t format, int32_t a2, int32_t a3, int32_t a4);
int32_t function_3de46(void);
int32_t function_3de48(void);
int32_t function_3de58(int32_t a1);
int32_t function_3de88(int32_t a1, int32_t a2, int32_t a3);
int32_t function_3dec0(int32_t a1, int32_t a2, int32_t * a3, int32_t a4);
int32_t function_3e8c8(int32_t a1, uint32_t a2, int32_t * a3);
int32_t function_3e9d8(int32_t a1, int32_t a2, int32_t a3, uint32_t a4);
int32_t function_3eff0(uint32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_3f92c(int32_t result, int32_t a2, int32_t a3);
int32_t function_3f970(int32_t result2, int32_t a2);
int32_t function_3f9bc(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_3f9c8(int32_t a1);
int32_t function_3f9d2(int32_t a1);
int32_t function_3f9d8(int32_t a1, int32_t a2);
int32_t function_3f9dc(void);
int32_t function_3f9ec(int32_t result2, int32_t a2);
int32_t function_3fa38(int32_t a1, int32_t a2, int32_t a3, int32_t result);
int32_t function_3fa44(void);
int32_t function_3fa4a(void);
int32_t function_3fa54(int32_t a1, int32_t a2, int32_t a3);
int32_t function_3fa64(int32_t a1);
int32_t function_3fb58(void);
int32_t function_3fd74(void);
int32_t function_3fe60(void);
int32_t function_3fe98(int32_t * a1);
int32_t function_3fec0(int32_t a1);
int32_t function_3fee8(int32_t a1);
int32_t function_3fef4(int32_t a1);
int32_t function_3fef8(void);
int32_t function_3fefc(void);
int32_t function_3ff04(void);
int32_t function_3ff08(int32_t a1);
int32_t function_3ff90(void);
int32_t function_3ff98(void);
int32_t function_3ffa0(int32_t a1);
int32_t function_3ffec(int32_t a1);
int32_t function_40038(void);
int32_t function_40228(void);
int32_t function_40248(void);
int32_t function_40314(int32_t a1, int32_t * a2);
int32_t function_40390(int32_t a1, int32_t a2);
int32_t function_40408(void);
int32_t function_4043c(int32_t a1, int32_t a2);
int32_t function_4044c(void);
int32_t function_40454(void);
int32_t function_40458(int32_t a1, int32_t a2);
int32_t function_40544(void);
int32_t function_40548(void);
int32_t function_40558(void);
int32_t function_40590(void);
int32_t function_405cc(int32_t a1, int32_t a2);
int32_t function_406ba(int32_t a1, int32_t a2);
int32_t function_406c0(int32_t a1, int32_t a2, uint32_t a3, int32_t a4);
int32_t function_406e4(int32_t a1);
int32_t function_40794(int32_t a1);
int32_t function_40910(int32_t a1);
int32_t function_40a02(void);
int32_t function_40a04(int32_t a1, int32_t a2, int32_t a3);
int32_t function_40a18(void);
int32_t function_40a4c(void);
int32_t function_40a94(void);
int32_t function_40ad8(int32_t a1, int32_t a2);
int32_t function_40c28(int32_t a1, char * a2);
int32_t function_40c8a(void);
int32_t function_40c8c(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_40cc0(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_40cd0(void);
int32_t function_40d04(void);
int32_t function_40d3c(void);
int32_t function_40d90(void);
int32_t function_40ed4(int32_t a1, int32_t a2);
int32_t function_4101c(int32_t a1);
int32_t function_410bc(int32_t result);
int32_t function_4110c(int32_t a1, uint32_t a2);
int32_t function_411d0(int32_t a1, int32_t a2);
int32_t function_41250(int32_t a1, int32_t * a2, int32_t * a3, int32_t * a4, int32_t * a5);
int32_t function_4136d0(void);
int32_t function_41474(int32_t a1);
int32_t function_4165c(int32_t a1);
int32_t function_41794(int32_t a1, int32_t a2, uint32_t a3);
int32_t function_419af8(void);
int32_t function_419d8(void);
int32_t function_41a38(void);
int32_t function_41a3c(int32_t a1, int32_t a2, uint32_t result2);
int32_t function_41c88(uint32_t a1, int32_t a2, uint32_t a3);
int32_t function_41cfc(int32_t a1, int32_t a2, int32_t a3);
int32_t function_41d80(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_41e38(int32_t a1, int32_t a2, int32_t a3);
int32_t function_41ec0(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_41f7c(uint32_t a1);
int32_t function_41fce0(void);
int32_t function_42080(int32_t a1);
int32_t function_420a4(void);
int32_t function_420b4(void);
int32_t function_420c4(uint32_t a1);
int32_t function_42100(void);
int32_t function_42138(void);
int32_t function_42170(int32_t a1, int32_t a2);
int32_t function_42180(int32_t result, int32_t a2);
int32_t function_421c4(void);
int32_t function_42308(int32_t a1);
int32_t function_42368(void);
int32_t function_42388(uint32_t a1);
int32_t function_42400(void);
int32_t function_424686(void);
int32_t function_42488(int32_t a1);
int32_t function_424c8(int32_t a1, int32_t a2);
int32_t function_42528(int32_t a1, int32_t a2);
int32_t function_426238(void);
int32_t function_426880(void);
int32_t function_42694(void);
int32_t function_42724(void);
int32_t function_42728(int32_t a1);
int32_t function_42734(int32_t a1);
int32_t function_42740(void);
int32_t function_42778(int32_t a1);
int32_t function_42784(int32_t a1);
int32_t function_42790(void);
int32_t function_427c8(void);
int32_t function_427cb8(void);
int32_t function_427d4(void);
int32_t function_427e0(void);
int32_t function_427f78(void);
int32_t function_42818(int32_t a1);
int32_t function_42928(int32_t a1);
int32_t function_429f8(void);
int32_t function_42a74(void);
int32_t function_42af0(int32_t a1, int32_t a2, int32_t a3);
int32_t function_42be0(void);
int32_t function_42c68(void);
int32_t function_42d2c(int32_t a1, uint32_t a2, int32_t a3, uint32_t a4);
int32_t function_42e80(void);
int32_t function_42e88(int32_t a1);
int32_t function_42f88(void);
int32_t function_43004(void);
int32_t function_4300c(void);
int32_t function_43014(void);
int32_t function_4301c(void);
int32_t function_43024(int32_t a1);
int32_t function_4306c(int32_t a1);
int32_t function_430b4(int32_t a1);
int32_t function_430bb0(void);
int32_t function_430c48(void);
int32_t function_430fc(void);
int32_t function_43148(uint32_t a1);
int32_t function_43198(uint32_t a1);
int32_t function_431e8(void);
int32_t function_43214(void);
int32_t function_43230(int32_t a1, int32_t a2, int32_t a3);
int32_t function_43290(int32_t a1);
int32_t function_432d0(int32_t a1, int32_t a2, int32_t a3);
int32_t function_43320(int32_t a1);
int32_t function_43338(int32_t a1);
int32_t function_43358(int32_t a1);
int32_t function_433d0(int32_t a1, int32_t * a2, int32_t * a3);
int32_t function_43414(int32_t a1);
int32_t function_43440(int32_t a1);
int32_t function_43488(int32_t a1);
int32_t function_4348c(int32_t a1, int32_t a2);
int32_t function_434e0(int32_t a1, int32_t a2);
int32_t function_43534(int32_t result, int32_t a2);
int32_t function_43594(int32_t result, int32_t a2);
int32_t function_4369c(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_4372c(int32_t a1);
int32_t function_437ac(int32_t a1, int32_t a2, int32_t a3);
int32_t function_43804(int32_t a1, int32_t a2);
int32_t function_43884(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_43ae8(int32_t a1, int32_t a2);
int32_t function_43d9c(int32_t a1);
int32_t function_43ea4(int32_t a1);
int32_t function_43ec4(int32_t a1);
int32_t function_43ee4(int32_t a1);
int32_t function_43ef8(int32_t a1, int32_t a2);
int32_t function_43f9c(void);
int32_t function_43fa0(void);
int32_t function_43fa4(int32_t a1, int32_t size);
int32_t function_43fa78(void);
int32_t function_44000(int32_t a1, int32_t * a2);
int32_t function_440020(void);
int32_t function_44040(int32_t a1, int32_t a2, int32_t size);
int32_t function_44074(int32_t a1);
int32_t function_44094(void);
int32_t function_44098(int32_t a1);
int32_t function_440e8(uint32_t a1);
int32_t function_44164(uint32_t a1);
int32_t function_44200(uint32_t a1, int32_t a2, int32_t * a3, int32_t a4);
int32_t function_44358(uint32_t a1, int32_t a2, int32_t * a3, int32_t a4);
int32_t function_444b8(void);
int32_t function_444c18(void);
int32_t function_44540(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_445d4(void);
int32_t function_445dc(void);
int32_t function_445e0(int32_t a1);
int32_t function_4464c(void);
int32_t function_44654(int32_t a1);
int32_t function_4466c(int32_t a1);
int32_t function_44680(int32_t a1);
int32_t function_44698(int32_t a1, int32_t a2, int32_t a3);
int32_t function_446dc(void);
int32_t function_44724(void);
int32_t function_4476c(int32_t a1);
int32_t function_44794(int32_t a1);
int32_t function_447a0(void);
int32_t function_447d8(void);
int32_t function_44810(void);
int32_t function_44848(void);
int32_t function_44880(int32_t a1);
int32_t function_448c8(void);
int32_t function_44900(void);
int32_t function_44938(void);
int32_t function_44970(void);
int32_t function_449768(void);
int32_t function_4498d8(void);
int32_t function_449a8(void);
int32_t function_449e0(void);
int32_t function_44a18(void);
int32_t function_44a50(void);
int32_t function_44a88(void);
int32_t function_44ae4(void);
int32_t function_44b54(int32_t * str, int32_t size);
int32_t function_44bb0(int32_t a1);
int32_t function_44bbc(void);
int32_t function_44bdc(int32_t a1);
int32_t function_44c04(void);
int32_t function_44c24(int32_t a1);
int32_t function_44c5c(int32_t a1);
int32_t function_44c84(int32_t a1);
int32_t function_44cb0(void);
int32_t function_44cce(void);
int32_t function_44cd0(int32_t a1);
int32_t function_44cf8(void);
int32_t function_44d04(void);
int32_t function_44d10(void);
int32_t function_44d30(void);
int32_t function_44d3c(void);
int32_t function_44d60(int32_t a1);
int32_t function_44d94(int32_t * a1);
int32_t function_44dfc(void);
int32_t function_44e1c(char a1);
int32_t function_44e44(void);
int32_t function_44e64(int32_t a1);
int32_t function_44e8c(void);
int32_t function_44eac(int32_t a1);
int32_t function_44ed4(int32_t a1);
int32_t function_44ef4(uint32_t a1);
int32_t function_44f0d8(void);
int32_t function_44f138(void);
int32_t function_44f28(void);
int32_t function_44f48(int32_t a1, int32_t a2, int32_t a3);
int32_t function_4509c(void);
int32_t function_450bc(int32_t a1);
int32_t function_450e4(void);
int32_t function_45104(int32_t a1);
int32_t function_4512c(int32_t * a1);
int32_t function_45154(int32_t a1);
int32_t function_4517c(int32_t a1);
int32_t function_451c0(int32_t a1);
int32_t function_45204(int32_t a1);
int32_t function_45244(int32_t * a1);
int32_t function_45288(uint32_t a1);
int32_t function_452b0(int32_t a1);
int32_t function_452d0(int32_t a1);
int32_t function_452f8(void);
int32_t function_45334(int32_t * a1);
int32_t function_4534ea(void);
int32_t function_454f62(void);
int32_t function_454f6e(void);
int32_t function_454f7e(void);
int32_t function_45527a(void);
int32_t function_455292(void);
int32_t function_4552a2(void);
int32_t function_45540a(void);
int32_t function_455456(void);
int32_t function_456532(void);
int32_t function_45700(void);
int32_t function_45734(uint32_t a1);
int32_t function_45788(int32_t a1, int32_t a2);
int32_t function_457e0(int32_t a1, int32_t a2);
int32_t function_4587c(int32_t a1, uint32_t a2);
int32_t function_458c4(void);
int32_t function_458e4(int32_t a1);
int32_t function_45918(void);
int32_t function_45940(int32_t a1);
int32_t function_4594c(uint32_t a1);
int32_t function_45990(uint32_t a1);
int32_t function_459d4(int32_t a1);
int32_t function_459f8(void);
int32_t function_45a04(void);
int32_t function_45a08(void);
int32_t function_45a0c(void);
int32_t function_45a34(int32_t a1);
int32_t function_45a8c(void);
int32_t function_45acc(void);
int32_t function_45b07e(void);
int32_t function_45b0c(void);
int32_t function_45b34(void);
int32_t function_45b74(void);
int32_t function_45c30(void);
int32_t function_45c70(void);
int32_t function_45c98(int32_t a1);
int32_t function_45cbc(int32_t a1, int32_t a2);
int32_t function_45d30(int32_t a1);
int32_t function_45e30(void);
int32_t function_45e360(void);
int32_t function_45e80(int32_t a1);
int32_t function_45ed0(int32_t * a1, uint32_t a2);
int32_t function_46024(uint32_t a1);
int32_t function_460c4(uint32_t result);
int32_t function_46152a(void);
int32_t function_46155e(void);
int32_t function_46156e(void);
int32_t function_461666(void);
int32_t function_46167a(void);
int32_t function_46178(uint32_t a1);
int32_t function_461ca2(void);
int32_t function_461ea2(void);
int32_t function_462afe(void);
int32_t function_462b9e(void);
int32_t function_46328e(void);
int32_t function_4632aa(void);
int32_t function_4637c(uint32_t a1);
int32_t function_464ae6(void);
int32_t function_464c16(void);
int32_t function_464f96(void);
int32_t function_46554(uint32_t a1);
int32_t function_465596(void);
int32_t function_465632(void);
int32_t function_46564e(void);
int32_t function_46565a(void);
int32_t function_4656d6(void);
int32_t function_4656fe(void);
int32_t function_46571a(void);
int32_t function_465776(void);
int32_t function_4672c(uint32_t a1);
int32_t function_46900(uint32_t a1);
int32_t function_469226(void);
int32_t function_46acc(uint32_t a1);
int32_t function_46c0d6(void);
int32_t function_46ca0(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_46eb4(int32_t a1);
int32_t function_46fe8(int32_t a1, int32_t a2);
int32_t function_47158(uint32_t a1, int32_t * a2, int32_t a3);
int32_t function_47222a(void);
int32_t function_474716(void);
int32_t function_4752c(uint32_t a1, int32_t a2, int32_t a3, int32_t a4, uint32_t a5);
int32_t function_477036(void);
int32_t function_477ec(uint32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_4782d2(void);
int32_t function_4785be(void);
int32_t function_47aa6e(void);
int32_t function_47ac4(uint32_t a1, int32_t a2);
int32_t function_47acaa(void);
int32_t function_47b196(void);
int32_t function_47b1b6(void);
int32_t function_47b1ce(void);
int32_t function_480036(void);
int32_t function_48110(uint32_t a1, char a2, int32_t a3, int32_t * a4, int32_t a5);
int32_t function_48438(uint32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_48520(int32_t a1, int32_t * a2, uint32_t a3, int32_t * a4, int32_t a5);
int32_t function_4878c2(void);
int32_t function_487e8(int32_t a1);
int32_t function_487e9a(void);
int32_t function_4880fe(void);
int32_t function_48834(int32_t a1, int32_t a2);
int32_t function_488a4(void);
int32_t function_488a4e(void);
int32_t function_488d8(void);
int32_t function_48910(void);
int32_t function_489652(void);
int32_t function_48967e(void);
int32_t function_489e0a(void);
int32_t function_48a4ee(void);
int32_t function_48a502(void);
int32_t function_48a5b2(void);
int32_t function_48abc(void);
int32_t function_48b58(void);
int32_t function_48b7c(void);
int32_t function_48be5a(void);
int32_t function_48bf5a(void);
int32_t function_48bf66(void);
int32_t function_48bf86(void);
int32_t function_48cb8(int32_t a1);
int32_t function_48d38(int32_t a1);
int32_t function_48ee4(void);
int32_t function_48efc(int32_t a1, int32_t a2, int32_t a3);
int32_t function_48f9c(int32_t result);
int32_t function_4910a(void);
int32_t function_49118(void);
int32_t function_49120(void);
int32_t function_49124(void);
int32_t function_4912c(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_4913c(int32_t a1, int32_t a2);
int32_t function_4914c(void);
int32_t function_49164(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_49294(void);
int32_t function_4929c(void);
int32_t function_492a4(int32_t a1, int32_t a2, int32_t a3);
int32_t function_493d0(int32_t * a1);
int32_t function_49574(int32_t a1);
int32_t function_495e4(int32_t a1, int32_t * a2, int32_t a3);
int32_t function_4966c(int32_t a1, int32_t * a2, int32_t a3);
int32_t function_496f4(int32_t a1, int32_t * a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_49794(int32_t a1, int32_t * a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_49834(int32_t a1, int32_t a2);
int32_t function_49844(void);
int32_t function_498a0(int32_t a1);
int32_t function_49904(void);
int32_t function_49965a(void);
int32_t function_499e8(int32_t a1);
int32_t function_49b10(int32_t a1, int32_t a2, int32_t result);
int32_t function_49b9fc(void);
int32_t function_49bd30(void);
int32_t function_49cfc(int32_t a1, int32_t a2, int32_t result);
int32_t function_49e8c(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t result);
int32_t function_4a0dc(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t result);
int32_t function_4a2d8(int32_t a1, int32_t a2, int32_t a3);
int32_t function_4a3ec(int32_t a1, int16_t a2);
int32_t function_4a4e8(int32_t a1, int32_t a2, int32_t a3);
int32_t function_4a4fc(int32_t a1, int32_t a2, uint32_t a3);
int32_t function_4a540(int32_t data, int32_t size, int32_t stream);
int32_t function_4a55c(int32_t buf, int32_t nbyte, int32_t fd);
int32_t function_4a584(int32_t a1, int32_t a2);
int32_t function_4a590(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_4a818(uint32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_4a8c8(int32_t a1, int32_t a2, int32_t * str);
int32_t function_4a920(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_4b130(int32_t a1, int32_t * a2, int32_t * a3, int32_t a4);
int32_t function_4b1a8(int32_t a1, int32_t a2);
int32_t function_4b214(int32_t a1, int32_t a2, int32_t a3);
int32_t function_4b250(int32_t a1, int32_t a2, int32_t a3);
int32_t function_4b264(int32_t a1, int32_t a2, int32_t a3);
int32_t function_4b2c8(int32_t a1, int32_t a2, int32_t a3);
int32_t function_4b2f4(int32_t a1, int32_t a2, int32_t a3);
int32_t function_4b838(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_4b8ac(int32_t result);
int32_t function_4b91c(int32_t * a1);
int32_t function_4b998(int32_t * a1);
int32_t function_4b9b0(uint32_t a1, int32_t a2, int32_t a3);
int32_t function_4bc44(int32_t a1, int32_t str);
int32_t function_4bca4(int32_t a1, int32_t * str);
int32_t function_4bdc4(int32_t a1);
int32_t function_4be20(int32_t a1);
int32_t function_4be38(int32_t a1, int32_t str);
int32_t function_4be98(int32_t a1, int32_t a2);
int32_t function_4beb0(int32_t a1);
int32_t function_4beb8(int32_t a1);
int32_t function_4bec0(int32_t a1, int32_t a2);
int32_t function_4bf2c(int32_t result);
int32_t function_4c028(int32_t a1);
int32_t function_4c04c(int32_t a1);
int32_t function_4c070(int32_t a1);
int32_t function_4c0cc(int32_t a1, int32_t a2, int32_t a3, char * format);
int32_t function_4c1fc(int32_t * a1);
int32_t function_4c23c(int32_t a1);
int32_t function_4c268(int32_t a1);
int32_t function_4c2fc(int32_t result, int32_t a2);
int32_t function_4c3b8(int32_t a1);
int32_t function_4c540(int32_t a1);
int32_t function_4c580(int32_t result, int32_t result2);
int32_t function_4c5cc(int32_t a1, int32_t a2);
int32_t function_4cde4(int32_t a1, uint32_t a2, int32_t a3);
int32_t function_4d288(int32_t * a1, int32_t a2, int32_t a3);
int32_t function_4d38c(int32_t a1, int32_t a2, int32_t * a3);
int32_t function_4d454(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_4d528(int32_t a1, int32_t a2, int32_t a3);
int32_t function_4d608(int32_t a1, int32_t a2, int32_t a3);
int32_t function_4d6e4(char * a1, int32_t a2, int32_t * a3);
int32_t function_4d79c(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_4d880(int32_t size);
int32_t function_4d898(int32_t a1);
int32_t function_4d8b0(int32_t a1, int32_t a2);
int32_t function_4d8fc(int32_t str);
int32_t function_4d918(int32_t result, int32_t a2);
int32_t function_4d928(int32_t result, int32_t a2);
int32_t function_4d954(int32_t * a1);
int32_t function_4d988(int32_t * a1);
int32_t function_4d9b4(int32_t result);
int32_t function_4d9c8(int32_t * a1);
int32_t function_4d9d0(int32_t result);
int32_t function_4d9e4(int32_t a1, int32_t a2, uint32_t a3);
int32_t function_4dab0(int32_t a1, int32_t a2);
int32_t function_4dad4(int32_t a1);
int32_t function_4db00(int32_t a1, int32_t * a2, int32_t a3, int32_t a4);
int32_t function_4dbf0(int32_t * str, uint32_t size, int32_t a3);
int32_t function_4dd30(int32_t a1, int32_t a2, int32_t * a3);
int32_t function_4de1c(int32_t a1);
int32_t function_4de88(uint32_t a1, int32_t a2, int32_t a3);
int32_t function_4df70(uint32_t result, uint32_t a2, int32_t * a3);
int32_t function_4dfec(int32_t a1, uint32_t a2);
int32_t function_4e068(int32_t a1);
int32_t function_4e0b8(int32_t a1, int32_t a2, int32_t a3);
int32_t function_4e144(int32_t a1, int32_t a2, int32_t a3);
int32_t function_4e1b0(void);
int32_t function_4e218(int32_t a1);
int32_t function_4e234(int32_t a1, char * a2);
int32_t function_4e25c(int32_t a1, int32_t a2);
int32_t function_4e43c(int32_t a1, int32_t a2);
int32_t function_4e464(int32_t a1);
int32_t function_4e49c(int32_t a1);
int32_t function_4e4c0(int32_t a1, int32_t a2);
int32_t function_4e4e8(int32_t a1, int32_t a2);
int32_t function_4e51c(int32_t a1);
int32_t function_4e528(int32_t a1);
int32_t function_4e534(int32_t a1);
int32_t function_4e540(void);
int32_t function_4e5a0(int32_t a1);
int32_t function_4e5bc(int32_t a1, uint32_t a2);
int32_t function_4e5f0(int32_t a1, int32_t a2);
int32_t function_4e6c8(int32_t str);
int32_t function_4e6f0(void);
int32_t function_4e6f8(int32_t a1, int32_t a2);
int32_t function_4e700(int32_t a1, int32_t a2);
int32_t function_4e744(int32_t * str);
int32_t function_4e768(int32_t a1);
int32_t function_4e784(int32_t a1);
int32_t function_4e7a0(int32_t a1, int32_t a2, int32_t a3);
int32_t function_4e804(int32_t a1, int32_t str);
int32_t function_4e838(int32_t a1, int32_t a2, int32_t a3);
int32_t function_4e87c(int32_t a1, int32_t str);
int32_t function_4e8b0(int32_t a1, int32_t * a2);
int32_t function_4e960(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_4e990(int32_t a1, int32_t a2);
int32_t function_4e9c4(int32_t a1);
int32_t function_4e9ec(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_4ea14(void);
int32_t function_4ea16(int32_t a1, int32_t a2, int32_t a3, uint32_t a4);
int32_t function_4ea62(void);
int32_t function_4ea64(void);
int32_t function_4ea70(int32_t result);
int32_t function_4ea94(void);
int32_t function_4ea9c(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_4eaf4(void);
int32_t function_4eafc(int32_t result2);
int32_t function_4eb48(void);
int32_t function_4eb54(void);
int32_t function_4eb60(void);
int32_t function_4eb6c(int32_t result);
int32_t function_4ec38(int32_t a1);
int32_t function_4ecc8(int32_t a1);
int32_t function_4ecda(int32_t a1);
int32_t function_4ecdc(void);
int32_t function_4ece0(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_4ed30(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_4ed60(int32_t a1, uint32_t a2);
int32_t function_4ee2c(int32_t a1, int32_t a2, int32_t a3);
int32_t function_4eee8(int32_t a1, int32_t a2);
int32_t function_4efd4(int32_t a1, char * str, int32_t a3);
int32_t function_4f068(int32_t a1, int32_t a2);
int32_t function_4f148(int32_t a1, int32_t a2);
int32_t function_4f19c(void);
int32_t function_4f1a6(int32_t a1);
int32_t function_4f1ac(int32_t a1, int32_t a2, int32_t a3);
int32_t function_4f200(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t function_4f230(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t function_4f238(int32_t a1, uint32_t a2, int32_t a3);
int32_t function_4f384(int32_t a1);
int32_t function_4f388(int32_t a1, uint32_t a2, int32_t a3);
int32_t function_4f494(int32_t a1, int32_t a2);
int32_t function_4f570(int32_t a1, int32_t a2);
int32_t function_4f588(int32_t a1);
int32_t function_4f744(int32_t a1);
int32_t function_4f8a8(int32_t a1, int32_t a2);
int32_t function_4f90c(int32_t result, char * a2);
int32_t function_4f94c(int32_t result, int32_t a2);
int32_t function_4f95c(int32_t result, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t format);
int32_t function_4f9c0(int32_t result, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t format, int32_t a7);
int32_t function_4fa0c(int32_t a1);
int32_t function_4fa10(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_4fa9c(int32_t a1, int32_t a2, int32_t a3, uint32_t a4, uint32_t a5, uint32_t a6, uint32_t a7, uint32_t a8);
int32_t function_4faec(int32_t a1, int32_t a2, int32_t a3);
int32_t function_4fb64(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_4fbdc(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_4fc14(int32_t a1, int32_t a2, int32_t a3);
int32_t function_4fcbc(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_4fdf0(int32_t a1, int32_t a2, int32_t a3, int32_t a4, uint32_t a5, uint32_t a6);
int32_t function_4fe30(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_4fe70(int32_t a1);
int32_t function_4feac(int32_t a1, int32_t a2);
int32_t function_4fef0(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_4ff3c(void);
int32_t function_4ff4c(int32_t a1);
int32_t function_4ff50(int32_t a1, int32_t a2);
int32_t function_4ffa0(int32_t a1, int32_t a2, int32_t a3);
int32_t function_4ffe8(int32_t a1, int32_t a2);
int32_t function_5021c(int32_t a1, uint32_t a2);
int32_t function_50288(int32_t a1, int32_t a2, int32_t a3);
int32_t function_502c0(int32_t result, int32_t * a2, int32_t a3);
int32_t function_5030e(int32_t a1, int32_t a2, int32_t a3, uint32_t a4);
int32_t function_503d0(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_504e8(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_50560(int32_t a1, int32_t a2, uint32_t a3, uint32_t a4);
int32_t function_505a4(int32_t a1, int32_t a2, int32_t a3, uint32_t a4, uint32_t a5);
int32_t function_505f4(int32_t a1, int32_t a2, uint32_t a3, int32_t a4, unsigned char a5);
int32_t function_50678(int32_t a1, uint32_t a2, int32_t a3, int32_t a4);
int32_t function_506f8(int32_t a1, int32_t a2, uint32_t a3, uint32_t a4);
int32_t function_50794(int32_t a1, uint32_t a2, uint32_t a3);
int32_t function_5082c(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_50850(int32_t a1, int32_t a2, int32_t a3);
int32_t function_50874(int32_t a1, int32_t a2, int32_t a3);
int32_t function_508a0(int32_t a1, int32_t a2);
int32_t function_508cc(void);
int32_t function_508dc(void);
int32_t function_508e4(int32_t a1, int32_t a2, char a3, int32_t a4);
int32_t function_509b4(int32_t a1, int32_t a2);
int32_t function_50a18(int32_t a1, int32_t a2, int32_t a3);
int32_t function_50a80(int32_t a1, int32_t a2, int32_t a3);
int32_t function_50aec(int32_t result, int32_t a2, int32_t a3);
int32_t function_50b12(void);
int32_t function_50b14(int32_t a1, unsigned char a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_50b48(int32_t a1, int32_t a2);
int32_t function_50ba4(void);
int32_t function_50bac(void);
int32_t function_50bb4(void);
int32_t function_50bbc(void);
int32_t function_50bc4(void);
int32_t function_50bcc(void);
int32_t function_50bd4(int32_t a1, int32_t a2);
int32_t function_50c38(int32_t a1, int32_t a2);
int32_t function_50cc4(int32_t a1, int32_t a2, int32_t a3);
int32_t function_50d54(int32_t a1, int32_t a2);
int32_t function_50d78(int32_t a1, int32_t a2, int32_t a3);
int32_t function_50d9c(void);
int32_t function_50da8(int32_t a1, int32_t a2);
int32_t function_50db4(int32_t a1, int32_t a2);
int32_t function_50dc4(int32_t a1, int32_t a2, int32_t a3);
int32_t function_50dd4(int32_t a1);
int32_t function_50df8(int32_t a1, int32_t a2);
int32_t function_50e20(int32_t a1, int32_t a2);
int32_t function_50e44(int32_t a1, int32_t a2, int32_t a3);
int32_t function_50e68(void);
int32_t function_50e70(void);
int32_t function_50e78(int32_t a1);
int32_t function_50ed0(int32_t a1);
int32_t function_50f28(int32_t a1);
int32_t function_50f80(int32_t a1, int32_t a2);
int32_t function_50fa4(int32_t a1, int32_t a2);
int32_t function_50fdc(int32_t result);
int32_t function_5103a(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_5113c(int32_t a1);
int32_t function_51142(int32_t a1, int32_t a2);
int32_t function_5114a(void);
int32_t function_5114c(int32_t a1);
int32_t function_51152(int32_t a1, int32_t a2);
int32_t function_5115e(void);
int32_t function_51160(void);
int32_t function_51164(int32_t a1, int32_t a2);
int32_t function_511d0(char a1, char a2, uint32_t a3, int32_t a4);
int32_t function_5121c(char a1, char a2, uint32_t a3, int32_t a4, uint32_t a5);
int32_t function_51260(char a1);
int32_t function_5126c(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_5129c(int32_t a1, int32_t a2, int32_t a3, int32_t a4, uint32_t a5);
int32_t function_512cc(int32_t a1, int32_t a2);
int32_t function_51328(int32_t a1, int32_t a2, int32_t a3);
int32_t function_5138c(void);
int32_t function_51390(int32_t a1);
int32_t function_51394(int32_t a1);
int32_t function_51398(int32_t a1, int32_t a2);
int32_t function_5139c(void);
int32_t function_513a0(int32_t result);
int32_t function_513a4(int32_t a1);
int32_t function_513a8(int32_t a1);
int32_t function_513ac(int32_t result);
int32_t function_513b0(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_513b8(void);
int32_t function_513bc(void);
int32_t function_513be(int32_t result);
int32_t function_513ce(void);
int32_t function_513d0(int32_t a1);
int32_t function_513d4(void);
int32_t function_513d6(void);
int32_t function_513d8(int32_t result, int32_t a2);
int32_t function_513dc(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_513e0(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_513fc(int32_t a1);
int32_t function_5146c(int32_t a1, int32_t a2);
int32_t function_51478(int32_t a1);
int32_t function_51484(int32_t a1, int32_t a2, int32_t a3);
int32_t function_51494(int32_t a1, int32_t a2);
int32_t function_514a4(int32_t a1);
int32_t function_51508(int32_t a1, int32_t a2);
int32_t function_51570(void);
int32_t function_51580(int32_t a1, int32_t a2);
int32_t function_51590(void);
int32_t function_515a0(int32_t a1, int32_t a2);
int32_t function_515b0(void);
int32_t function_515c0(int32_t a1, int32_t a2);
int32_t function_515d0(int32_t a1, int32_t a2, char a3, int32_t a4);
int32_t function_5161c(int32_t a1, int32_t a2, int32_t a3);
int32_t function_51668(int32_t a1, int32_t a2, char a3, char a4, uint32_t a5);
int32_t function_51694(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_516be(void);
int32_t function_516c0(void);
int32_t function_516c2(void);
int32_t function_516c4(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_516c8(void);
int32_t function_516cc(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_516d0(void);
int32_t function_516d4(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_516da(void);
int32_t function_516de(void);
int32_t function_516e2(void);
int32_t function_516e4(int32_t result, int32_t a2);
int32_t function_516ea(void);
int32_t function_516ec(void);
int32_t function_516f8(void);
int32_t function_516fe(void);
int32_t function_51700(void);
int32_t function_51708(int32_t a1, int32_t a2);
int32_t function_51718(int32_t a1, int32_t a2, int32_t a3);
int32_t function_51728(int32_t a1, int32_t a2);
int32_t function_5174c(int32_t a1, int32_t a2, int32_t a3);
int32_t function_51770(void);
int32_t function_51794(int32_t a1, int32_t a2);
int32_t function_517bc(int32_t a1, int32_t a2);
int32_t function_517f8(int32_t a1, int32_t a2, int32_t a3);
int32_t function_5182c(int32_t a1);
int32_t function_5182e(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_51882(int32_t a1);
int32_t function_51884(int32_t a1, int32_t a2);
int32_t function_51892(void);
int32_t function_51894(void);
int32_t function_51898(int32_t result, int32_t a2);
int32_t function_5189c(int32_t a1);
int32_t function_518a0(int32_t result, int32_t a2, int32_t a3);
int32_t function_518a4(int32_t result);
int32_t function_518a8(int32_t a1);
int32_t function_518ac(void);
int32_t function_518b0(int32_t a1);
int32_t function_518b4(int32_t result);
int32_t function_518b8(int32_t a1);
int32_t function_518bc(uint32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_518f8(void);
int32_t function_51900(void);
int32_t function_5190a(void);
int32_t function_5190c(void);
int32_t function_5190e(void);
int32_t function_51910(int32_t a1);
int32_t function_51914(void);
int32_t function_51918(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_5191c(int32_t a1);
int32_t function_51922(void);
int32_t function_51924(void);
int32_t function_51928(int32_t a1);
int32_t function_5192e(void);
int32_t function_51930(void);
int32_t function_51938(void);
int32_t function_5193c(int32_t a1, int32_t a2, int32_t a3);
int32_t function_51970(uint32_t a1);
int32_t function_51978(int32_t a1);
int32_t function_5198c(uint32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_51a20(int32_t a1, uint32_t a2, uint32_t a3, int32_t a4, int32_t * a5);
int32_t function_51b44(int32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, int32_t a5);
int32_t function_51cac(int32_t a1, int32_t a2, int32_t a3, uint32_t a4, int32_t * a5);
int32_t function_51d44(int32_t a1, int32_t * a2);
int32_t function_51d98(int32_t a1, int32_t a2, int32_t a3, int32_t * a4);
int32_t function_51e08(int32_t * a1);
int32_t function_51e54(int32_t a1, int32_t * a2, uint32_t a3);
int32_t function_51f28(int32_t a1, uint32_t a2);
int32_t function_52000(int32_t a1, int32_t a2);
int32_t function_5203e(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_52044(int32_t a1);
int32_t function_52048(void);
int32_t function_5204e(void);
int32_t function_52054(int32_t fd, struct iovec * iovec, int32_t count);
int32_t function_52058(int32_t a1);
int32_t function_5205c(int32_t result);
int32_t function_52062(void);
int32_t function_52064(void);
int32_t function_5206a(void);
int32_t function_5206e(void);
int32_t function_52070(int32_t a1, uint32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10);
int32_t function_522b0(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_522b8(uint32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9);
int32_t function_522cc(void);
int32_t function_522dc(int32_t a1);
int32_t function_5234c(int32_t result, int32_t a2);
int32_t function_52350(void);
int32_t function_5239e(void);
int32_t function_523a0(void);
int32_t function_524f4(int32_t a1, int32_t a2, int32_t a3);
int32_t function_524f8(void);
int32_t function_52508(void);
int32_t function_52594(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t function_525a0(void);
int32_t function_5261c(int32_t a1, int32_t a2);
int32_t function_52930(int32_t a1);
int32_t function_52bd8(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_52bf0(char * a1, int32_t buf, int32_t length, int32_t * a4);
int32_t function_52d3c(void);
int32_t function_52d44(void);
int32_t function_52d68(void);
int32_t function_52dcc(int32_t a1);
int32_t function_52f1c(char * a1);
int32_t function_530f2(int32_t a1, int32_t a2, uint32_t a3, uint32_t a4);
int32_t function_5317e(void);
int32_t function_53180(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_532e8(int32_t a1);
int32_t function_53314(int32_t a1);
int32_t function_53604(void);
int32_t function_536f4(char * a1);
int32_t function_538c4(int32_t a1);
int32_t function_53a94(int32_t a1, int32_t a2);
int32_t function_53d3a(void);
int32_t function_53d3c(int32_t a1);
int32_t function_53ec8(int32_t a1);
int32_t function_53fe0(void);
int32_t function_540c8(int32_t a1, uint32_t a2);
int32_t function_54140(int32_t result, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, uint32_t a7, int32_t a8, int32_t a9);
int32_t function_5433a(int32_t a1);
int32_t function_54348(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_5437c(int32_t a1);
int32_t function_543a8(void);
int32_t function_543c8(int32_t a1, int32_t a2, int32_t a3);
int32_t function_54400(int32_t result, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, uint32_t a7, int32_t a8, int32_t a9);
int32_t function_546c0(int32_t result, int32_t a2, int32_t a3, int32_t a4, int32_t a5, uint32_t a6, int32_t a7, int32_t a8);
int32_t function_5484c(int32_t result);
int32_t function_54850(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9);
int32_t function_54878(void);
int32_t function_54894(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9);
int32_t function_548a4(int32_t a1);
int32_t function_548c8(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9);
int32_t function_548f4(void);
int32_t function_54938(void);
int32_t function_54960(void);
int32_t function_54980(int32_t a1, int32_t a2, int32_t a3);
int32_t function_549b8(int32_t result, int32_t a2, int32_t a3, int32_t a4, int32_t a5, uint32_t a6, int32_t a7, int32_t a8);
int32_t function_54cb0(int32_t result, char * a2, int32_t a3, char * a4, int32_t a5, int32_t a6, uint32_t a7, int32_t a8);
int32_t function_54f58(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, uint32_t a6, int32_t a7);
int32_t function_550ee(void);
int32_t function_550f0(void);
int32_t function_550f8(void);
int32_t function_55118(int32_t a1);
int32_t function_5513c(void);
int32_t function_5515c(void);
int32_t function_551a0(int32_t a1);
int32_t function_551cc(void);
int32_t function_551ec(void);
int32_t function_5521c(void);
int32_t function_55388(int32_t a1, int32_t a2);
int32_t function_55568(int32_t a1, uint32_t a2);
int32_t function_555a4(void);
int32_t function_555b0(int32_t a1, int32_t a2, int32_t a3);
int32_t function_557c4(int32_t a1, int32_t a2);
int32_t function_55870(int32_t a1);
int32_t function_558e4(int32_t str, int32_t a2);
int32_t function_55a28(int32_t a1, int32_t a2);
int32_t function_55b28(int32_t a1);
int32_t function_55ba0(int32_t a1);
int32_t function_55c7c(int32_t a1, int32_t a2);
int32_t function_55ccc(int32_t a1, int32_t a2);
int32_t function_55d5c(int32_t a1);
int32_t function_55db8(void);
int32_t function_55e24(int32_t a1, int32_t a2);
int32_t function_55ebc(int32_t a1);
int32_t function_55f14(int32_t a1);
int32_t function_55f6c(int32_t a1, int32_t a2, int32_t a3);
int32_t function_56030(int32_t a1);
int32_t function_56b38(int32_t a1, int32_t a2);
int32_t function_56e0c(int32_t a1);
int32_t function_56eb8(int32_t a1);
int32_t function_5729c(int32_t a1, int32_t a2);
int32_t function_57364(int32_t a1);
int32_t function_573d8(int32_t a1);
int32_t function_57540(int32_t result, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11);
int32_t function_5759c(int32_t result, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11);
int32_t function_575fc(int32_t a1, int32_t a2);
int32_t function_5766c(int32_t a1);
int32_t function_576e4(int32_t * a1, int32_t a2);
int32_t function_57a1c(int32_t a1, int32_t a2);
int32_t function_57a8c(int32_t a1, int32_t a2);
int32_t function_57b24(int32_t a1);
int32_t function_57b80(int32_t a1, int32_t * a2);
int32_t function_57c30(void);
int32_t function_57d70(int32_t a1, int32_t a2);
int32_t function_57de4(int32_t a1, int32_t * str);
int32_t function_57e98(int32_t a1);
int32_t function_57ed4(int32_t a1, int32_t a2);
int32_t function_57f94(int32_t a1);
int32_t function_58008(void);
int32_t function_580c0(int32_t a1, int32_t a2, int32_t a3);
int32_t function_581b0(int32_t a1);
int32_t function_581b8(int32_t a1);
int32_t function_581fc(int32_t a1);
int32_t function_58238(int32_t a1);
int32_t function_58240(int32_t a1, int32_t a2);
int32_t function_582a0(int32_t a1);
int32_t function_582f8(void);
int32_t function_582fa(void);
int32_t function_582fc(int32_t a1, int32_t a2);
int32_t function_58304(int32_t str, int32_t a2);
int32_t function_58414(int32_t a1, int32_t a2);
int32_t function_584a4(int32_t a1);
int32_t function_58500(void);
int32_t function_5856c(int32_t a1, int32_t a2);
int32_t function_58584(int32_t a1);
int32_t function_585e4(int32_t a1);
int32_t function_58638(int32_t a1, int32_t a2);
int32_t function_58750(int32_t a1);
int32_t function_58834(int32_t a1);
int32_t function_58958(int32_t a1, int32_t a2, int32_t a3, int32_t a4, uint32_t a5, int32_t a6);
int32_t function_595c0(int32_t a1, int32_t a2);
int32_t function_596b0(int32_t a1, int32_t a2);
int32_t function_59954(int32_t a1, int32_t a2);
int32_t function_59a0c(int32_t a1, int32_t a2);
int32_t function_59cd4(int32_t a1, int32_t a2);
int32_t function_59e54(int32_t a1, int32_t a2);
int32_t function_59ef8(int32_t a1, int32_t a2);
int32_t function_59f9c(int32_t a1, int32_t a2);
int32_t function_5a040(int32_t a1, int32_t a2);
int32_t function_5a0d4(int32_t a1, int32_t a2);
int32_t function_5a30c(int32_t a1, int32_t a2);
int32_t function_5a4b82(void);
int32_t function_5a4baa(void);
int32_t function_5a66c(int32_t * a1, int32_t str2, int32_t a3, int32_t a4);
int32_t function_5a850(int32_t a1, int32_t a2);
int32_t function_5a97c(int32_t a1);
int32_t function_5aa9c(int32_t * a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t function_5babc(int32_t result, int32_t a2);
int32_t function_5bb9c(int32_t a1);
int32_t function_5bbe8(int32_t a1, int32_t a2);
int32_t function_5bccc(int32_t a1, int32_t a2);
int32_t function_5bd24(int32_t result, int32_t a2);
int32_t function_5bd34(int32_t result, int32_t a2);
int32_t function_5bd44(int32_t result, int32_t a2);
int32_t function_5bd54(int32_t a1, int32_t a2, int32_t a3);
int32_t function_5bd64(int32_t a1, int32_t a2, int32_t a3);
int32_t function_5bd78(int32_t a1, int32_t a2, int32_t a3);
int32_t function_5bd8c(int32_t a1, int32_t a2, int32_t a3);
int32_t function_5bda0(int32_t a1, int32_t a2, int32_t a3);
int32_t function_5bdb4(int32_t a1, int32_t a2, int32_t a3);
int32_t function_5bdc8(int32_t a1, int32_t a2, int32_t a3);
int32_t function_5bddc(int32_t a1, int32_t a2, int32_t a3);
int32_t function_5bdec(int32_t a1, int32_t a2, int32_t a3);
int32_t function_5be2c(int32_t a1, int32_t a2, int32_t a3);
int32_t function_5be70(int32_t a1, int32_t a2, int32_t a3);
int32_t function_5beec(int32_t a1, int32_t a2, int32_t a3);
int32_t function_5bf18(int32_t a1, int32_t a2, int32_t a3);
int32_t function_5c204(int32_t a1, int32_t a2, int32_t a3);
int32_t function_5c258(int32_t a1, int32_t a2, int32_t a3);
int32_t function_5c294(int32_t a1, int32_t a2, int32_t a3);
int32_t function_5c2e4(int32_t a1, int32_t a2, int32_t a3);
int32_t function_5c358(int32_t a1, int32_t a2, int32_t a3);
int32_t function_5c420(int32_t a1, int32_t a2, int32_t a3);
int32_t function_5c454(int32_t a1, int32_t a2, int32_t a3);
int32_t function_5c480(int32_t a1, int32_t a2);
int32_t function_5c510(int32_t a1, int32_t a2);
int32_t function_5c5a0(int32_t a1, int32_t a2);
int32_t function_5c630(int32_t a1, int32_t a2);
int32_t function_5c6f4(int32_t a1);
int32_t function_5c758(int32_t a1, int32_t * a2, int32_t a3);
int32_t function_5cec0(int32_t a1, int32_t a2);
int32_t function_5cfa8(int32_t a1);
int32_t function_5d07c(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_5d290(int32_t a1, int32_t a2, int32_t a3);
int32_t function_5d3b0(int32_t a1, int32_t a2);
int32_t function_5d428(int32_t a1, int32_t a2, int32_t a3);
int32_t function_5d4c0(int32_t a1);
int32_t function_5d580(int32_t a1);
int32_t function_5d5f0(int32_t a1, uint32_t a2, int32_t a3);
int32_t function_5d694(int32_t a1, int32_t a2);
int32_t function_5d6a0(int32_t a1, int32_t a2, int32_t a3);
int32_t function_5d7b8(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_5d890(int32_t a1);
int32_t function_5d950(int32_t result);
int32_t function_5d9ec(int32_t a1, int32_t a2);
int32_t function_5da58(int32_t a1, int32_t a2);
int32_t function_5dac0(int32_t a1, int32_t a2, int32_t a3);
int32_t function_5db72(void);
int32_t function_5db86(int32_t result, int32_t a2);
int32_t function_5db90(int32_t a1);
int32_t function_5dd1c(void);
int32_t function_5dd28(int32_t a1, int32_t a2);
int32_t function_5de60(int32_t a1);
int32_t function_5dea8(int32_t a1, int32_t a2);
int32_t function_5df18(void);
int32_t function_5df44(void);
int32_t function_5df58(int32_t * str);
int32_t function_5df98(int32_t a1, char * a2, int32_t a3, char * format);
int32_t function_5e140(int32_t * str);
int32_t function_5e310(int32_t str, int32_t a2);
int32_t function_5e4bd2(void);
int32_t function_5e524e(void);
int32_t function_5e5262(void);
int32_t function_5e558(int32_t result, int32_t a2);
int32_t function_5e680(int32_t a1);
int32_t function_5e6a4(int32_t a1, int32_t result);
int32_t function_5e6fe(void);
int32_t function_5e700(int32_t a1, int32_t a2);
int32_t function_5e70c(int32_t a1);
int32_t function_5e758(uint32_t a1, uint32_t a2, int32_t str);
int32_t function_5e8dc(int32_t a1, int32_t a2, int32_t a3);
int32_t function_5eb48(int32_t a1, int32_t a2, uint32_t a3);
int32_t function_5ed04(int32_t a1, int32_t a2, int32_t a3, int32_t a4, uint32_t a5);
int32_t function_5ef24(int32_t a1, int32_t a2, uint32_t a3);
int32_t function_5f0d4(int32_t a1, int32_t a2, int32_t a3);
int32_t function_5f1cc(int32_t a1, int32_t a2, uint32_t a3, int32_t a4, int32_t a5, uint32_t a6, uint32_t a7);
int32_t function_5f3f8(int32_t a1, int32_t a2);
int32_t function_5f474(int32_t a1);
int32_t function_5f4d8(int32_t a1);
int32_t function_5f880(void);
int32_t function_5f884(void);
int32_t function_5f886(uint32_t result, uint32_t a2, int32_t a3);
int32_t function_5fadc(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_5faec(int32_t result, int32_t a2, int32_t a3);
int32_t function_5faf8(void);
int32_t function_5fafa(int32_t a1, int32_t a2);
int32_t function_5fd8c(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_5fd9c(int32_t result, int32_t a2, int32_t a3);
int32_t function_5fda8(int32_t a1, int32_t a2);
int32_t function_5fdb8(void);
int32_t function_5fdbc(void);
int32_t function_5fdc0(void);
int32_t function_5fdcc(void);
int32_t function_5fdd0(void);
int32_t function_5fdd4(void);
int32_t function_5fdd8(int32_t a1, uint32_t a2, int32_t a3, uint32_t a4, int32_t a5, int32_t a6);
int32_t function_6002c(int32_t a1);
int32_t function_6004c(int32_t a1);
int32_t function_60070(void);
int32_t function_60074(void);
int32_t function_60078(void);
int32_t function_6007c(int32_t a1, int32_t a2, uint32_t a3);
int32_t function_600b4(int32_t a1, int32_t a2);
int32_t function_600bc(void);
int32_t function_600c4(int64_t a1, int32_t a2);
int32_t function_600cc(int32_t a1, uint32_t a2);
int32_t function_600da(int32_t a1, uint32_t a2);
int32_t function_60120(int32_t result, int32_t a2);
int32_t function_60138(void);
int32_t function_60150(int32_t a1, int32_t a2);
int32_t function_6015c(void);
int32_t function_60168(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_60180(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_601c8(uint32_t a1, int32_t a2, uint32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11, int32_t a12);
int32_t function_602d8(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_60314(void);
int32_t function_60318(int32_t a1, int32_t a2, int32_t a3);
int32_t function_60326(void);
int32_t function_6032c(int32_t result);
int32_t function_60334(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_60baba(void);
int32_t function_61b290(void);
int32_t function_61bc6(void);
int32_t function_61ca6(void);
int32_t function_6211a(void);
int32_t function_624d8e(void);
int32_t function_624db6(void);
int32_t function_624dde(void);
int32_t function_6283f6(void);
int32_t function_6317a(void);
int32_t function_64b62(void);
int32_t function_65b268(void);
int32_t function_664d76(void);
int32_t function_665c16(void);
int32_t function_684bce(void);
int32_t function_6a465e(void);
int32_t function_6c01e(void);
int32_t function_6de06(void);
int32_t function_6e60a(void);
int32_t function_72342(void);
int32_t function_752ca(void);
int32_t function_7539e(void);
int32_t function_75f36(void);
int32_t function_76236(void);
int32_t function_7631a(void);
int32_t function_76cbe(void);
int32_t function_76d0a(void);
int32_t function_76d56(void);
int32_t function_77e1e(void);
int32_t function_77e72(void);
int32_t function_77ebe(void);
int32_t function_784bae(void);
int32_t function_791ea(void);
int32_t function_7aafa(void);
int32_t function_7acde(void);
int32_t function_7ad8a(void);
int32_t function_7ada6(void);
int32_t function_7b1de(void);
int32_t function_7b526(void);
int32_t function_86a1a(void);
int32_t function_884b8e(void);
int32_t function_89182(void);
int32_t function_924636(void);
int32_t function_9941a(void);
int32_t function_a0bf02(void);
int32_t function_b4d7a(void);
int32_t function_c4a3e(void);
int32_t function_c4a5e(void);
int32_t function_c4a7e(void);
int32_t function_c4a9e(void);
int32_t function_ceaa6(void);
int32_t function_cebe2(void);
int32_t function_d07c2(void);
int32_t function_d2c3e(void);
int32_t function_d30ea(void);
int32_t function_d3546(void);
int32_t function_d3bb6(void);
int32_t function_d4332(void);
int32_t function_d4f36(void);
int32_t function_d5236(void);
int32_t function_d76baa(void);
int32_t function_d900e(void);
int32_t function_d90f2(void);
int32_t function_da562(void);
int32_t function_deda6(void);
int32_t function_e00c6(void);
int32_t function_e1510003(void);
int32_t function_e1b4e(void);
int32_t function_e2042(void);
int32_t function_e25de(void);
int32_t function_e28cca6b(void);
int32_t function_e28cca6c(void);
int32_t function_e28fc600(void);
int32_t function_e2ebe(void);
int32_t function_e34ff6(void);
int32_t function_e594c000(void);
int32_t function_e5bcf000(void);
int32_t function_e5bcf008(void);
int32_t function_e5bcf010(void);
int32_t function_e5bcf018(void);
int32_t function_e5bcf020(void);
int32_t function_e5bcf028(void);
int32_t function_e5bcffb8(void);
int32_t function_e5bcffc0(void);
int32_t function_e5bcffc8(void);
int32_t function_e5bcffd0(void);
int32_t function_e5bcffd8(void);
int32_t function_e5bcffe0(void);
int32_t function_e5bcffe8(void);
int32_t function_e5bcfff0(void);
int32_t function_e5bcfff8(void);
int32_t function_ee24e(void);
int32_t function_f0126(void);
int32_t function_f120e(void);
int32_t function_f1b3e(void);
int32_t function_f230e(void);
int32_t function_f472e(void);
int32_t function_f52ce(void);
int32_t function_f5842(void);
int32_t function_f628e(void);
int32_t function_f76992(void);
int32_t function_fa83a(void);
int32_t function_fad8e(void);
int32_t function_faf86(void);
int32_t function_fb2f6(void);
int32_t function_fe05e876(void);
int32_t function_fe0a4636(void);
int32_t function_fe0a7d2a(void);
int32_t function_fe1490c6(void);
int32_t function_fe20bcf2(void);
int32_t function_fe22460e(void);
int32_t function_fe227d02(void);
int32_t function_fe26515a(void);
int32_t function_fe322992(void);
int32_t function_fe32bcde(void);
int32_t function_fe35e5fe(void);
int32_t function_fe3a4b5e(void);
int32_t function_fe3cbe62(void);
int32_t function_fe41d3f2(void);
int32_t function_fe453fae(void);
int32_t function_fe4556d6(void);
int32_t function_fe45650e(void);
int32_t function_fe45ac22(void);
int32_t function_fe45dc0a(void);
int32_t function_fe4601c2(void);
int32_t function_fe4611b6(void);
int32_t function_fe4621a6(void);
int32_t function_fe46243e(void);
int32_t function_fe46328e(void);
int32_t function_fe4632aa(void);
int32_t function_fe4632d2(void);
int32_t function_fe468326(void);
int32_t function_fe47222a(void);
int32_t function_fe4754ea(void);
int32_t function_fe48bcd2(void);
int32_t function_fe48bd3e(void);
int32_t function_fe48bdee(void);
int32_t function_fe49a066(void);
int32_t function_fe49a18a(void);
int32_t function_fe49ba08(void);
int32_t function_fe5612d0(void);
int32_t function_fe6dc714(void);
int32_t function_fe6dc720(void);
int32_t function_fe71a29e(void);
int32_t function_fe7507aa(void);
int32_t function_fe75e2f6(void);
int32_t function_fe775756(void);
int32_t function_fe826bee(void);
int32_t function_fe82b232(void);
int32_t function_fe84bf9a(void);
int32_t function_fe85db2e(void);
int32_t function_fe8cbf86(void);
int32_t function_fe94bf2e(void);
int32_t function_fea0bcee(void);
int32_t function_fea889c2(void);
int32_t function_fea9095e(void);
int32_t function_fee6c40a(void);
int32_t function_ff052fb2(void);
int32_t function_ff05535e(void);
int32_t function_ff05adf6(void);
int32_t function_ff06bdfa(void);
int32_t function_ff07480a(void);
int32_t function_ff08a0a6(void);
int32_t function_ff08a156(void);
int32_t function_ff09bc3c(void);
int32_t function_ff0a83e2(void);
int32_t function_ff102b92(void);
int32_t function_ff1683ce(void);
int32_t function_ff1783b2(void);
int32_t function_ff17af6e(void);
int32_t function_ff1b7d66(void);
int32_t function_ff1b7d8e(void);
int32_t function_ff1cbbb6(void);
int32_t function_ff1cbdc6(void);
int32_t function_ff1d3426(void);
int32_t function_ff1d505a(void);
int32_t function_ff1d506a(void);
int32_t function_ff1d631a(void);
int32_t function_ff1d65fa(void);
int32_t function_ff1e1a6a(void);
int32_t function_ff1e1ede(void);
int32_t function_ff1e306e(void);
int32_t function_ff1faf3e(void);
int32_t function_ff21534e(void);
int32_t function_ff21a95e(void);
int32_t function_ff21adfa(void);
int32_t function_ff21bd98(void);
int32_t function_ff221c66(void);
int32_t function_ff22329a(void);
int32_t function_ff2232de(void);
int32_t function_ff22c386(void);
int32_t function_ff22e246(void);
int32_t function_ff230622(void);
int32_t function_ff231ff2(void);
int32_t function_ff232b76(void);
int32_t function_ff23810e(void);
int32_t function_ff238386(void);
int32_t function_ff23b1ea(void);
int32_t function_ff244646(void);
int32_t function_ff244666(void);
int32_t function_ff244686(void);
int32_t function_ff2446a6(void);
int32_t function_ff249226(void);
int32_t function_ff24b44e(void);
int32_t function_ff24bc3e(void);
int32_t function_ff24bd76(void);
int32_t function_ff25617a(void);
int32_t function_ff259666(void);
int32_t function_ff259dae(void);
int32_t function_ff25bc88(void);
int32_t function_ff26133e(void);
int32_t function_ff2726b6(void);
int32_t function_ff2a1326(void);
int32_t function_ff2a1446(void);
int32_t function_ff2b2896(void);
int32_t function_ff38bf52(void);
int32_t function_ff464cee(void);
int32_t function_ff664cda(void);
int32_t function_ff6a1bce(void);
int32_t function_ff81adb6(void);
int32_t function_ff8d2b86(void);
int32_t function_ff921ba6(void);
int32_t function_ff9cbf72(void);
int32_t function_ff9e1a32(void);
int32_t function_ff9e2292(void);
int32_t function_ff9e2cce(void);
int32_t function_ff9e3052(void);
int32_t function_ff9ee246(void);
int32_t function_ff9f061a(void);
int32_t function_ffa15036(void);
int32_t function_ffa1b0c2(void);
int32_t function_ffa1b252(void);
int32_t function_ffa2129e(void);
int32_t function_ffa21c9a(void);
int32_t function_ffa21cb2(void);
int32_t function_ffa2212a(void);
int32_t function_ffa22fea(void);
int32_t function_ffa251ae(void);
int32_t function_ffa31f6a(void);
int32_t function_ffa35962(void);
int32_t function_ffa4919e(void);
int32_t function_ffa49eea(void);
int32_t function_ffa4bb66(void);
int32_t function_ffa4bd8e(void);
int32_t function_ffa629ae(void);
int32_t function_ffa890a2(void);
int32_t function_ffb6c6b8(void);
int32_t function_ffba1b7e(void);
int32_t function_ffc2972c(void);
int32_t function_ffc29744(void);
int32_t function_ffc29ee4(void);
int32_t * malloc2(int32_t size);
int32_t memchr(int32_t result3, char a2, int32_t a3);
int32_t memmem(int32_t result, uint32_t a2, int32_t a3, uint32_t a4);
int32_t unknown_154a6f6(void);
int32_t unknown_1989fe0(void);
int32_t unknown_1a89fd0(void);
int32_t unknown_1b89fc0(int32_t a1);
int32_t unknown_1d0a67a(void);
int32_t unknown_240(void);
int32_t unknown_83(void);
int32_t unknown_f0a75a(void);
int32_t unknown_fe1c9f5c(int32_t a1);
int32_t unknown_fe3(void);
int32_t unknown_fe409b9c(void);
int32_t unknown_fee4bb7c(void);
int32_t unknown_ff4e9f3a(void);

// --------------------- Global Variables ---------------------

// Detected cryptographic pattern: SHA256_Hash_constant_words_K__0x428a2f98_ (32-bit, little endian)
int32_t SHA256_Hash_constant_words_K__0x428a2f98__at_7eba4[64] = {0x428a2f98, 0x71374491, -0x4a3f0431, -0x164a245b, 0x3956c25b, 0x59f111f1, -0x6dc07d5c, -0x54e3a12b, -0x27f85568, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, -0x7f214e02, -0x6423f959, -0x3e640e8c, -0x1b64963f, -0x1041b87a, 0xfc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, -0x67c1aeae, -0x57ce3993, -0x4ffcd838, -0x40a68039, -0x391ff40d, -0x2a586eb9, 0x6ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, -0x7e3d36d2, -0x6d8dd37b, -0x5d40175f, -0x57e599b5, -0x3db47490, -0x3893ae5d, -0x2e6d17e7, -0x2966f9dc, -0xbf1ca7b, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, -0x7b3787ec, -0x7338fdf8, -0x6f410006, -0x5baf9315, -0x41065c09, -0x398e870e}; // 0x7eba4
int32_t g1 = 0; // 0x100000
int32_t g2 = 0; // 0x101000
bool g3 = false; // 0x110000
int32_t g4 = -0x1cae0000; // 0x13c60
int32_t g5 = 0; // 0x16e360
int32_t g6 = -0x1743fff1; // 0x199bc
int32_t g7 = 0x3007e302; // 0x1dc1a
int32_t g8 = 0; // 0x200000
int32_t g9 = 0; // 0x202020
int32_t g10 = 0; // 0x202802
int32_t g11 = 0; // 0x202806
int32_t g12 = 0; // 0x202a2a
int32_t g13 = 0; // 0x203d7c
int32_t g14 = 0; // 0x210000
int32_t g15 = 0; // 0x214b4f
int32_t g16 = -0x1cad0000; // 0x249fc
int32_t g17 = -0x5ef114c; // 0x263ca
int32_t g18 = -0x16d2be10; // 0x2647c
int32_t g19 = 0x1a000004; // 0x26550
int32_t g20 = -0x1ad21ffc; // 0x26b80
int32_t g21 = -0x5ef114c; // 0x277d2
int32_t g22 = -0x1cf1dcac; // 0x283e4
int32_t g23 = -0x1cfdeb9c; // 0x28878
int32_t g24 = 0; // 0x2d5b20
bool g25 = false; // 0x2dc6c0
int32_t g26 = 0; // 0x2e2e2e
int32_t g27 = 0; // 0x303a53
int32_t g28 = 0; // 0x313a43
int32_t g29 = 0; // 0x313a46
int32_t g30 = 0; // 0x313a4d
int32_t g31 = 0; // 0x313a4e
int32_t g32 = 0; // 0x313a50
int32_t g33 = 0; // 0x313a52
int32_t g34 = 0; // 0x313a56
int32_t g35 = 0; // 0x323a4e
int32_t g36 = 0; // 0x323a50
int32_t g37 = 0; // 0x323a52
int32_t g38 = 0; // 0x333a4e
int32_t g39 = 0; // 0x333a52
int32_t g40 = 0; // 0x343a50
int32_t g41 = 0; // 0x353a50
int32_t g42 = -0x1c5fe000; // 0x35be0
int32_t g43 = 0; // 0x36ee80
int32_t g44 = -0x1d72eff8; // 0x3c3e8
int32_t g45 = -0x1cacfffd; // 0x3c3f8
int32_t g46 = -0x1f77effb; // 0x3cac4
int32_t g47 = 0; // 0x400000
int32_t g48 = 0; // 0x408ffc
int32_t * (*g49)(int32_t *) = (int32_t * (*)(int32_t *))-0x16d2bc10; // 0x40d90
int32_t g50 = -0x1ad21ffc; // 0x43214
char * g51; // 0x480000
int32_t g52 = 0; // 0x48212c
char * g53; // 0x482130
struct _IO_FILE * g54 = NULL; // 0x482134
char * g55; // 0x482138
int32_t g56 = 0; // 0x48213a
char * g57; // 0x482158
char * g58; // 0x482258
int32_t g59 = 0; // 0x482a58
char * g60; // 0x482a5c
char g61 = 0; // 0x482a5d
int32_t g62 = 0; // 0x482a60
int32_t g63 = 0; // 0x482a64
int32_t g64 = 0; // 0x482a68
int32_t g65 = 0; // 0x482a6c
char g66 = 0; // 0x482a70
char g67 = 0; // 0x482a71
int32_t g68 = 0; // 0x482a74
int32_t g69 = 0; // 0x482a78
int32_t g70 = 0; // 0x482a80
int32_t g71 = 0; // 0x482a84
char * g72; // 0x482a88
char g73 = 0; // 0x482a89
int32_t g74 = 0; // 0x482a8c
int32_t g75 = 0; // 0x482a90
int16_t g76 = 0; // 0x482a91
int32_t g77 = 0; // 0x482a94
int32_t g78 = 0; // 0x482a98
int32_t g79 = 0; // 0x482a9c
int32_t g80 = 0; // 0x482aa0
int32_t g81 = 0; // 0x483aa0
int32_t g82 = -0x1e5fcffe; // 0x4a4e8
int32_t g83 = -0x114f9440; // 0x4ea24
int16_t * g84 = (int16_t *)0x13a02004; // 0x4ea48
int32_t g85 = 0; // 0x4f0000
int32_t g86 = 0; // 0x4fbaa0
int32_t g87 = 0; // 0x4fcaa0
int32_t g88 = 0; // 0x4fcad0
char * g89; // 0x4fcae8
int32_t g90 = 0; // 0x4fcaec
int32_t g91 = 0; // 0x4fcb28
int32_t g92 = 0; // 0x4fcb2c
int32_t g93 = 0; // 0x4fcb30
int32_t g94 = 0; // 0x4fcb34
int32_t g95 = 0; // 0x4fcb38
int32_t g96 = 0; // 0x4fcb3c
int32_t g97 = 0; // 0x4fcb40
int32_t g98 = 0; // 0x4fcb44
int32_t g99 = 0; // 0x4fcb48
int32_t g100 = 0; // 0x4fcb4c
int32_t g101 = 0; // 0x4fcb68
int32_t g102 = 0; // 0x504b68
int32_t g103 = 0; // 0x504c8c
int32_t g104 = 0; // 0x504c90
int32_t g105 = 0; // 0x504c94
int32_t g106 = 0; // 0x504c98
int32_t g107 = 0; // 0x504c9c
int32_t g108 = 0; // 0x504ca0
int32_t g109 = 0; // 0x504ca4
int32_t g110 = 0; // 0x504ca8
int32_t g111 = 0; // 0x504cac
int32_t g112 = 0; // 0x504cc4
int32_t g113 = 0; // 0x504cc8
int32_t g114 = 0; // 0x504ce0
int32_t g115 = 0; // 0x504ce4
int32_t g116 = 0; // 0x504ce8
int32_t g117 = 0; // 0x504e68
int32_t g118 = 0; // 0x504fe8
int32_t g119 = 0; // 0x504fec
int32_t g120 = 0; // 0x505004
int32_t g121 = 0; // 0x505008
int32_t g122 = 0; // 0x50500c
int32_t g123 = 0; // 0x505010
int32_t g124 = 0; // 0x505014
int32_t g125 = 0; // 0x505018
int32_t g126 = 0; // 0x50501c
int32_t g127 = 0; // 0x505020
int32_t g128 = 0; // 0x505024
int32_t g129 = 0; // 0x505028
int32_t g130 = 0; // 0x50502c
int32_t g131 = 0; // 0x505030
int32_t g132 = 0; // 0x505048
int32_t g133 = 0; // 0x505088
int32_t g134 = 0; // 0x505108
int32_t g135 = 0; // 0x50510c
int32_t g136 = 0; // 0x505110
int32_t g137 = 0; // 0x505114
int32_t g138 = 0; // 0x505118
int32_t g139 = 0; // 0x50511c
int32_t g140 = 0; // 0x505134
int32_t g141 = 0; // 0x50514c
int32_t g142 = 0; // 0x505164
int32_t g143 = 0; // 0x50517c
int32_t g144 = 0; // 0x505180
int32_t g145 = 0; // 0x505184
int32_t g146 = 0; // 0x505188
int32_t g147 = 0; // 0x5051a0
int32_t g148 = 0; // 0x5051a4
int32_t g149 = 0; // 0x5051a8
int32_t g150 = 0; // 0x5051c0
char g151 = 0; // 0x5051c4
int32_t g152 = 0; // 0x5051c8
int32_t g153 = 0; // 0x5059c8
int32_t g154 = 0; // 0x5059e0
int32_t g155 = -0x17427ff0; // 0x51048
int16_t * g156 = (int16_t *)-0x17427ff0; // 0x510c4
int32_t g157 = 0; // 0x5259e0
int32_t g158 = 0x1a00005d; // 0x5316c
int32_t g159 = 0; // 0x5859e0
int32_t g160 = 0; // 0x5859e4
int32_t g161 = 0; // 0x5859e8
int32_t g162 = 0; // 0x5859ec
int32_t g163 = 0; // 0x585a04
int32_t g164 = 0; // 0x585a08
int32_t g165 = 0; // 0x589a08
char * g166; // 0x589a0c
int32_t g167 = 0; // 0x58de08
int32_t g168 = 0; // 0x58de0c
int32_t g169 = 0; // 0x58de10
int32_t g170 = 0; // 0x58de14
int32_t g171 = 0; // 0x58de18
int32_t g172 = 0; // 0x58de1c
int32_t g173 = 0; // 0x58de3c
int32_t g174 = 0; // 0x58de40
int32_t g175 = 0; // 0x58de44
char * g176; // 0x58de48
char * g177; // 0x58de4c
int32_t g178 = 0; // 0x58dfb8
int32_t g179 = 0; // 0x58dfbc
int32_t g180 = 0; // 0x58dfc0
int64_t g181 = 0; // 0x58dfc4
int32_t g182 = 0; // 0x58dfc8
int32_t g183 = 0; // 0x58dfcc
int32_t g184 = 0; // 0x58dfd0
int32_t g185 = 0; // 0x58dfd4
int32_t g186 = 0; // 0x58dfd8
int32_t g187 = 0; // 0x58dfdc
int32_t g188 = 0; // 0x58dfe0
int32_t g189 = 0; // 0x58dfe4
int32_t g190 = 0; // 0x58dfe8
int32_t g191 = 0; // 0x58dfec
int32_t g192 = 0; // 0x58dff0
int32_t g193 = 0; // 0x58dff4
int32_t g194 = 0; // 0x58dff8
int32_t g195 = 0; // 0x58dffc
char * g196; // 0x58e000
int32_t g197 = 0; // 0x58e004
int32_t g198 = 0; // 0x58e010
char g199 = 0; // 0x58e014
int32_t g200 = 0; // 0x58e015
int32_t g201 = 0; // 0x58e018
char g202 = 0; // 0x58e01c
char g203 = 0; // 0x58e01d
int32_t g204 = 0; // 0x58e020
int32_t g205 = 0; // 0x58e028
int32_t g206 = 0; // 0x58e030
int32_t g207 = 0; // 0x58e038
int16_t * g208 = NULL; // 0x58e03c
int64_t * g209 = NULL; // 0x58e040
int32_t g210 = 0; // 0x58e344
int32_t g211 = 0; // 0x58e348
int32_t g212 = 0; // 0x58e34c
char g213 = 0; // 0x58e350
int32_t g214 = 0; // 0x58e354
struct sigaction * g215 = NULL; // 0x58e35c
char * g216; // 0x58e3f0
int32_t g217 = 0; // 0x58e3f8
char * g218; // 0x590000
int32_t g219 = 0; // 0x5903f8
int32_t g220 = 0; // 0x590400
int32_t g221 = 0; // 0x590404
int32_t g222 = 0; // 0x590408
int32_t g223 = 0; // 0x590420
int32_t g224 = 0; // 0x590440
int32_t g225 = 0; // 0x592460
struct sigaction * g226 = NULL; // 0x592464
int32_t g227 = 0; // 0x5924f4
int32_t g228 = 0; // 0x5944f4
int32_t g229 = 0; // 0x59450c
struct sigaction * g230 = NULL; // 0x594524
int32_t g231 = 0; // 0x5945b4
int32_t g232 = 0; // 0x5945b8
int32_t g233 = 0; // 0x5945bc
int32_t g234 = 0; // 0x5945c0
int32_t g235 = 0; // 0x5955bc
int32_t g236 = 0; // 0x5955c0
int32_t g237 = 0; // 0x5955c8
int32_t g238 = 0; // 0x5955cc
int32_t g239 = 0; // 0x5955d0
int32_t g240 = 0; // 0x59cd98
int32_t g241 = 0; // 0x5b8d80
int32_t g242 = -0x1a6efff8; // 0x5c258
int32_t g243 = -0x1a6efff8; // 0x5c294
int32_t g244 = -0x158042d0; // 0x60000
int32_t g249 = 0; // 0x626370
int32_t g250 = 46; // 0x6347c
int32_t g252 = 0; // 0x647261
char (*g253)[6] = "http:"; // 0x654cc
int32_t g255 = 0x62000031; // 0x68fa1
int32_t g256 = 0; // 0x695a8
int32_t g257 = 0; // 0x696a8
int32_t g258 = 5; // 0x696e4
int32_t g259 = 0; // 0x697061
char * g260; // 0x6a008
char * g261 = "\n"; // 0x6a02c
int32_t g262 = 37; // 0x6d1e0
int32_t g264 = 32; // 0x6d60c
int32_t g265 = 0; // 0x6d6f62
int32_t g266 = 0; // 0x6e776f
int32_t g267 = 0; // 0x706863
int32_t g268 = 0; // 0x78616d
int32_t g269 = 0x13cdd; // 0x7df00
int32_t g270 = 2; // 0x7e298
int32_t g271 = -0x45410532; // 0x7e29c
int32_t g272 = 0x7a686f75; // 0x7e2ac
int32_t g273 = 0x2b330; // 0x7e3f8
char (*g274)[15] = "--version-file"; // 0x7e618
int32_t g275 = 2; // 0x7e61c
char (*g276)[19] = "--logfile-openflag"; // 0x7e634
int32_t g277 = 0; // 0x7eab0
int32_t g278 = 0x43f00000; // 0x7eab4
char * g279 = "\x02"; // 0x7eab8
int32_t g280 = 100; // 0x7eabc
char (*g281)[12] = "--config|-c"; // 0x7eac0
int16_t g282 = 550; // 0x7eb4c
int32_t g283 = 1; // 0x7eb58
char * g284 = "\x01"; // 0x7eb5c
int32_t g285 = 0x40c80000; // 0x7eb74
int64_t g286 = 0xfbc00000101; // 0x7eb78
int32_t g287 = -0x43ffffff; // 0x7eb79
char (*g288)[19] = "/var/log/hash_rate"; // 0x7eb98
char * g289 = "\x04"; // 0x7eb9c
int32_t g290 = 5; // 0x7eba0
int32_t g291 = -0x398e870e; // 0x7eca0
int32_t g292 = 0x5be0cd19; // 0x7ecc0
int32_t g293 = 0x2f250; // 0x7ecc4
int32_t g294 = 1; // 0x7edc8
int32_t g295 = 50; // 0x7edcc
int32_t g296 = 0x40a00000; // 0x7edd0
char g297 = 1; // 0x7edd4
int32_t g298 = -1; // 0x7edd8
int32_t g299 = -1; // 0x7eddc
int16_t g300 = 257; // 0x7ede0
int32_t g301 = -0xfffeff; // 0x7ede1
int32_t g302 = 0xff0001; // 0x7ede2
int16_t g303 = 255; // 0x7ede4
int32_t g304 = 255; // 0x7ede8
char (*g305)[9] = "HW Sweep"; // 0x7edf0
char (*g306)[9] = "SW Sweep"; // 0x7ee1c
int32_t g307 = 0; // 0x7ee48
int32_t g308 = -1; // 0x7f418
char (*g309)[17] = "/dev/bitmain-lcd"; // 0x7f41c
int32_t g310 = 0x121c8; // 0x7f568
int32_t g311 = 0x11f7c; // 0x7f56c
int32_t g312 = 5; // 0x7f570
int32_t g313 = 6; // 0x7f578
int32_t g314 = 7; // 0x7f580
int32_t g315 = 0; // 0x7f588
struct _IO_FILE * g316 = NULL; // 0x7f790
int32_t g317 = 0; // 0x7f798
int32_t g318 = 0; // 0x7f79c
int32_t g319 = 0; // 0x7f7a4
int32_t g320 = 0; // 0x7f7a8
int32_t g321 = 0; // 0x7f7ac
char * g322; // 0x7f7b0
int32_t g323 = 0; // 0x7f7b4
int32_t g324 = 0; // 0x7f7b8
int32_t g325 = 0; // 0x7f7bc
int32_t g326 = 0; // 0x7f7c0
int32_t g327 = 0; // 0x7f7d8
int32_t g328 = 0; // 0x7f7dc
char * g329; // 0x7f7e0
int32_t g330 = 0; // 0x7f7e4
int32_t g331 = 0; // 0x7f7e8
int32_t g332 = 0; // 0x7f7ec
int32_t g333 = 0; // 0x7f814
int32_t g334 = 0; // 0x7f818
int32_t g335 = 0; // 0x7f81c
int32_t g336 = 0; // 0x7f8bc
int32_t g337 = 0; // 0x7f8c4
int32_t g338 = 0; // 0x7f8d4
int32_t g339 = 0; // 0x7f8d8
int32_t g340 = 0; // 0x7f8dc
int32_t g341 = 0; // 0x7f8e0
char g342 = 0; // 0x7f8f4
char * g343; // 0x7f8f8
char g344 = 0; // 0x7f9f8
int32_t g345 = 0; // 0x7f9fc
int32_t g346 = 0; // 0x7fa00
int32_t g347 = 0; // 0x7fa04
int32_t g348 = 0; // 0x7fa08
int32_t g349 = 0; // 0x7fa18
int32_t g350 = 0; // 0x7fa38
int32_t g351 = 0; // 0x7fa3c
int32_t g352 = 0; // 0x7fa40
int64_t g353 = 0; // 0x7fa5c
int32_t g354 = 0; // 0x7fc00
int32_t g355 = 0; // 0x7fc04
int32_t g356 = 0; // 0x7fc08
char * g357; // 0x80000
int32_t g358 = 0; // 0x800000
int32_t g359 = 0; // 0x8074c
int32_t g360 = 0; // 0x80750
int32_t g361 = 0; // 0x80754
int32_t g362 = 0; // 0x80758
int32_t g363 = 0; // 0x8075c
int32_t g364 = 0; // 0x80760
char * g365; // 0x80768
int32_t g366 = 0; // 0x808ffc
char * g367; // 0x80968
char * g368; // 0x8096c
char * g369; // 0x80970
int32_t g370 = 0; // 0x80974
int32_t g371 = 0; // 0x80a010
int32_t g372 = 0; // 0x80a410
int32_t g373 = 0; // 0x80a74
int32_t g374 = 0; // 0x80a888
int32_t g375 = 0; // 0x80a894
int32_t g376 = 0; // 0x80a8a4
int32_t g377 = 0; // 0x80a90
char * g378; // 0x80ac0
int32_t g379 = 0; // 0x80ac4
char * g380; // 0x80ac8
int32_t g381 = 0; // 0x80acac
int32_t g382 = 0; // 0x80b90
int32_t g383 = 0; // 0x80b94
int32_t g384 = 0; // 0x80b98
int32_t g385 = 0; // 0x80b9c
char * g386; // 0x80ba0
char * g387; // 0x80ca0
char * g388; // 0x80da0
int32_t g389 = 0; // 0x80ea0
int32_t g390 = 0; // 0x80f18
int32_t g391 = 0; // 0x80f1c
int32_t g392 = 0; // 0x80f20
int32_t g393 = 0; // 0x80f38
int32_t g394 = 0; // 0x80f3c
int32_t g395 = 0; // 0x80f40
int32_t g396 = 0; // 0x80f50
int32_t g397 = 0; // 0x80f54
int32_t g398 = 0; // 0x80f58
int32_t g399 = 0; // 0x80f5c
int32_t g400 = 0; // 0x80f60
char g401 = 0; // 0x80f64
int32_t g402 = 0; // 0x80f78
int32_t g403 = 0; // 0x80f7c
int32_t g404 = 0; // 0x80f80
int32_t g405 = 0; // 0x80f84
int64_t * g406 = NULL; // 0x80f88
int32_t g407 = 0; // 0x80f90
int32_t g408 = 0; // 0x80f94
int32_t g409 = 0; // 0x80f98
char g410 = 0; // 0x80fa4
char g411 = 0; // 0x80fa8
char g412 = 0; // 0x80fac
char g413 = 0; // 0x80fb0
int32_t g414 = 0; // 0x80fb4
char * g415; // 0x80fdc
int32_t g416 = 0; // 0x810dc
int32_t g417 = 0; // 0x810f4
char * g418; // 0x8110c
int32_t g419 = 0; // 0x81110
int32_t g420 = 0; // 0x81114
int32_t g421 = 0; // 0x81118
int32_t g422 = 0; // 0x81124
int32_t g423 = 0; // 0x8114ac
int32_t g424 = 0; // 0x82124
int32_t g425 = 0; // 0x990000
int32_t g426 = 0; // 0x99cd98
int32_t g427 = 0; // 0x99ed98
int32_t g428 = 0; // 0x99ed9c
int32_t g429 = 0; // 0x99eda0
int32_t g430 = 0; // 0x99eda4
int32_t g431 = 0; // 0x99eda8
int32_t g432 = 0; // 0x99edac
int32_t g433 = 0; // 0x99edb0
int32_t g434 = 0; // 0x99edb4
int32_t g435 = 0; // 0x99edb8
char g436 = 0; // 0x99edbc
int32_t g437 = 0; // 0x99edc0
char g438 = 0; // 0x99edc2
int16_t g439 = 0; // 0x99edc4
int16_t g440 = 0; // 0x99edc6
int32_t g441 = 0; // 0x99edc8
int16_t g442 = 0; // 0x99edca
char g443 = 0; // 0x99edcb
int32_t g444 = 0; // 0x99edcc
int32_t g445 = 0; // 0x99edd0
int32_t g446 = 0; // 0x99edd4
int16_t g447 = 0; // 0x99edd6
int32_t g448 = 0; // 0x99edd8
int32_t g449 = 0; // 0x99eddc
char * g450; // 0x99ede0
int32_t g451 = 0; // 0x99ee08
int32_t g452 = 0; // 0x99ee0c
int32_t g453 = 0; // 0x99ee10
int32_t g454 = 0; // 0x99ee14
int32_t g455 = 0; // 0x99ee18
int32_t g456 = 0; // 0x99ee1c
int32_t g457 = 0; // 0x99ee20
int32_t g458 = 0; // 0x99ee24
int32_t g459 = 0; // 0x99ee28
int32_t g460 = 0; // 0x99ee48
int32_t g461 = 0; // 0x99eec8
int32_t g462 = 0; // 0xa2e63
int32_t g463 = 0; // 0xa2e70
int32_t g464 = 0; // 0xa3a72
int32_t g465 = 0; // 0xa6465
int32_t g466 = 0; // 0xa6572
bool g467 = false; // 0xb4000
int32_t g468 = 0; // 0xf0000
int64_t g469 = 0; // 0xf4000
bool g470 = false; // 0xf423f
int32_t g471 = 0; // 0xf4240
int32_t g472;
int32_t g473;
int32_t g474;
int32_t g475;
int32_t g476;
int32_t g477;
int32_t g478;
int32_t g479;
int32_t g480;
int32_t g481;
int32_t g482;
int32_t g483;
int32_t g484;
int32_t g485;
int32_t g486;
int32_t g487;
int32_t g488;
int32_t g489;
int32_t g490;
int32_t g491;
int32_t g492;
int32_t g493;
int32_t g494;
int32_t * g245 = &g26; // 0x607ec
int32_t * g246 = &g249; // 0x60830
int32_t * g247 = &g267; // 0x60834
int32_t * g248 = &g265; // 0x60cb8
int32_t * g251 = &g259; // 0x63640
int32_t * g254 = &g13; // 0x68a48
int32_t * g263 = &g9; // 0x6d254

// ------- Dynamically Linked Functions Without Header --------

int32_t __cxa_atexit(void (*a1)(int32_t *), int32_t * a2, int32_t * a3);
int32_t __fxstat64(int32_t a1, int32_t a2, struct stat64 * a3);
void __gmon_start__(void);
int32_t __libc_start_main(int32_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
int32_t __lxstat64(int32_t a1, char * a2, struct stat64 * a3);
char * __strdup(char * a1);
int32_t __xstat64(int32_t a1, char * a2, struct stat64 * a3);
void errx(int32_t a1, char * a2, ...);
struct _IO_FILE * fopen64(char * a1, char * a2);
int32_t glob64(char * a1, int32_t a2, int32_t (*a3)(char *, int32_t), struct _TYPEDEF_glob64_t * a4);
void globfree64(struct _TYPEDEF_glob64_t * a1);
int32_t lseek64(int32_t a1, int32_t a2, int32_t a3);
int32_t open64(char * a1, int32_t a2, ...);
int32_t sscanf2(int32_t a1, char * a2, int32_t * a3, int32_t a4);
int32_t sysinfo(struct sysinfo * a1);

// ------------------------ Functions -------------------------

// Address range: 0x11e84 - 0x11e90
int32_t function_11e84(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x11e84
    return function_13c50();
}

// Address range: 0x11ea4 - 0x11eb0
int32_t function_11ea4(int32_t * a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x11ea4
    return function_e28fc600();
}

// Address range: 0x11eb0 - 0x11ebc
int32_t function_11eb0(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x11eb0
    return function_e28cca6c();
}

// Address range: 0x11ebc - 0x11ec8
int32_t function_11ebc(int32_t * a1, int32_t a2, int32_t a3) {
    // 0x11ebc
    return function_e5bcf028();
}

// Address range: 0x11ec8 - 0x11ed4
int32_t function_11ec8(int32_t a1) {
    // 0x11ec8
    return function_e28fc600();
}

// Address range: 0x11ed4 - 0x11ee0
int32_t function_11ed4(int32_t * a1) {
    // 0x11ed4
    return function_e28cca6c();
}

// Address range: 0x11ee0 - 0x11eec
int32_t function_11ee0(int32_t a1) {
    // 0x11ee0
    return function_e5bcf020();
}

// Address range: 0x11eec - 0x11ef8
int32_t function_11eec(int32_t a1, char * a2, int32_t a3, int32_t a4) {
    // 0x11eec
    return function_e28fc600();
}

// Address range: 0x11ef8 - 0x11f04
int32_t function_11ef8(int32_t * a1, int32_t a2, int32_t a3) {
    // 0x11ef8
    return function_e28cca6c();
}

// Address range: 0x11f04 - 0x11f10
int32_t function_11f04(int32_t * a1) {
    // 0x11f04
    return function_e5bcf018();
}

// Address range: 0x11f10 - 0x11f1c
int32_t function_11f10(int32_t a1) {
    // 0x11f10
    return function_e28fc600();
}

// Address range: 0x11f1c - 0x11f28
int32_t function_11f1c(int32_t a1, int32_t a2, int32_t a3, int32_t * a4, int32_t a5) {
    // 0x11f1c
    return function_e28cca6c();
}

// Address range: 0x11f28 - 0x11f34
int32_t function_11f28(int32_t a1, int32_t ** a2, int32_t a3, int32_t a4) {
    // 0x11f28
    return function_e5bcf010();
}

// Address range: 0x11f34 - 0x11f40
int32_t function_11f34(char * a1, int32_t * a2, int32_t a3, int32_t a4) {
    // 0x11f34
    return function_e28fc600();
}

// Address range: 0x11f40 - 0x11f4c
int32_t function_11f40(int32_t a1, int32_t a2, int32_t a3) {
    // 0x11f40
    return function_e28cca6c();
}

// Address range: 0x11f4c - 0x11f58
int32_t function_11f4c(int32_t a1) {
    // 0x11f4c
    return function_e5bcf008();
}

// Address range: 0x11f58 - 0x11f64
int32_t function_11f58(int32_t a1) {
    // 0x11f58
    return function_e28fc600();
}

// Address range: 0x11f64 - 0x11f70
int32_t function_11f64(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x11f64
    return function_e28cca6c();
}

// Address range: 0x11f70 - 0x11f7c
int32_t function_11f70(int32_t a1, int32_t a2) {
    // 0x11f70
    return function_e5bcf000();
}

// Address range: 0x11f7c - 0x11f88
int32_t free(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x11f7c
    return function_e28fc600();
}

// Address range: 0x11f88 - 0x11f94
int32_t function_11f88(int32_t * a1, int32_t a2, int32_t a3) {
    // 0x11f88
    return function_e28cca6b();
}

// Address range: 0x11f94 - 0x11fa0
int32_t function_11f94(int32_t * a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x11f94
    return function_e5bcfff8();
}

// Address range: 0x11fa0 - 0x11fac
int32_t function_11fa0(int32_t a1) {
    // 0x11fa0
    return function_e28fc600();
}

// Address range: 0x11fac - 0x11fb8
int32_t function_11fac(int32_t a1, int32_t * a2) {
    // 0x11fac
    return function_e28cca6b();
}

// Address range: 0x11fb8 - 0x11fc4
int32_t function_11fb8(void) {
    // 0x11fb8
    return function_e5bcfff0();
}

// Address range: 0x11fc4 - 0x11fd0
int32_t function_11fc4(int32_t * a1, int32_t a2, char a3, int32_t a4) {
    // 0x11fc4
    return function_e28fc600();
}

// Address range: 0x11fd0 - 0x11fdc
int32_t function_11fd0(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x11fd0
    return function_e28cca6b();
}

// Address range: 0x11fdc - 0x11fe8
int32_t function_11fdc(int32_t a1, int32_t a2) {
    // 0x11fdc
    return function_e5bcffe8();
}

// Address range: 0x11fe8 - 0x11ff4
int32_t function_11fe8(int32_t a1) {
    // 0x11fe8
    return function_e28fc600();
}

// Address range: 0x11ff4 - 0x12000
int32_t function_11ff4(int32_t * a1) {
    // 0x11ff4
    return function_e28cca6b();
}

// Address range: 0x12000 - 0x1200c
int32_t function_12000(int32_t a1) {
    // 0x12000
    return function_e5bcffe0();
}

// Address range: 0x1200c - 0x12018
int32_t function_1200c(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x1200c
    return function_e28fc600();
}

// Address range: 0x12018 - 0x12024
int32_t function_12018(int32_t a1) {
    // 0x12018
    return function_e28cca6b();
}

// Address range: 0x12024 - 0x12030
int32_t function_12024(int32_t * a1, int32_t * a2) {
    // 0x12024
    return function_e5bcffd8();
}

// Address range: 0x12030 - 0x1203c
int32_t function_12030(int32_t a1) {
    // 0x12030
    return function_e28fc600();
}

// Address range: 0x1203c - 0x12048
int32_t function_1203c(int32_t a1, int32_t a2) {
    // 0x1203c
    return function_e28cca6b();
}

// Address range: 0x12048 - 0x12054
int32_t function_12048(int32_t a1) {
    // 0x12048
    return function_e5bcffd0();
}

// Address range: 0x12054 - 0x12060
int32_t function_12054(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t * a5, int32_t * a6) {
    // 0x12054
    return function_e28fc600();
}

// Address range: 0x12060 - 0x1206c
int32_t function_12060(int32_t a1) {
    // 0x12060
    return function_e28cca6b();
}

// Address range: 0x1206c - 0x12078
int32_t function_1206c(int32_t a1) {
    // 0x1206c
    return function_e5bcffc8();
}

// Address range: 0x12078 - 0x12084
int32_t function_12078(int32_t a1, int32_t a2) {
    // 0x12078
    return function_e28fc600();
}

// Address range: 0x12084 - 0x12090
int32_t function_12084(int32_t a1, int32_t a2) {
    // 0x12084
    return function_e28cca6b();
}

// Address range: 0x12090 - 0x1209c
int32_t function_12090(int32_t a1) {
    // 0x12090
    return function_e5bcffc0();
}

// Address range: 0x1209c - 0x120a8
int32_t function_1209c(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x1209c
    return function_e28fc600();
}

// Address range: 0x120a8 - 0x120b4
int32_t function_120a8(int32_t * a1, int32_t * a2) {
    // 0x120a8
    return function_e28cca6b();
}

// Address range: 0x120b4 - 0x120c0
int32_t function_120b4(int32_t a1) {
    // 0x120b4
    return function_e5bcffb8();
}

// Address range: 0x120c0 - 0x120cc
int32_t function_120c0(char * s1, char * s2) {
    // 0x120c0
    return strcasecmp(s1, s2);
}

// Address range: 0x120cc - 0x120d8
void function_120cc(char * s) {
    // 0x120cc
    perror(s);
}

// Address range: 0x120d8 - 0x120e4
int32_t function_120d8(int32_t fd, struct sockaddr * addr, int32_t * addr_len) {
    // 0x120d8
    return accept(fd, addr, addr_len);
}

// Address range: 0x120e4 - 0x120f0
int32_t function_120e4(int32_t ver, int32_t fildes, struct stat64 * stat_buf) {
    // 0x120e4
    return __fxstat64(ver, fildes, stat_buf);
}

// Address range: 0x120f0 - 0x120fc
int32_t function_120f0(int32_t sig, struct sigaction * act, struct sigaction * oact) {
    // 0x120f0
    return sigaction(sig, act, oact);
}

// Address range: 0x120fc - 0x12108
int32_t function_120fc(int32_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s) {
    // 0x120fc
    return fwrite(ptr, size, n, s);
}

// Address range: 0x12108 - 0x12114
char * function_12108(char * dest, char * src) {
    // 0x12108
    return strcat(dest, src);
}

// Address range: 0x12114 - 0x12120
int32_t function_12114(int32_t fd, int32_t request, ...) {
    // 0x12114
    return ioctl(fd, request);
}

// Address range: 0x12120 - 0x1212c
int32_t function_12120(int32_t fd, int32_t offset, int32_t whence) {
    // 0x12120
    return lseek64(fd, offset, whence);
}

// Address range: 0x1212c - 0x12138
int64_t function_1212c(char * nptr, char ** endptr, int32_t base) {
    // 0x1212c
    return 0x100000000 * strtoll(nptr, endptr, base) >> 32;
}

// Address range: 0x12138 - 0x12144
int32_t function_12138(int32_t useconds) {
    // 0x12138
    return usleep(useconds);
}

// Address range: 0x12144 - 0x12150
char * function_12144(char * dest, char * src) {
    // 0x12144
    return strcpy(dest, src);
}

// Address range: 0x12150 - 0x1215c
int32_t function_12150(struct timeval * tv, struct timezone * tz) {
    // 0x12150
    return gettimeofday(tv, tz);
}

// Address range: 0x1215c - 0x12168
int32_t function_1215c(int32_t * ptr, int32_t size, int32_t n, struct _IO_FILE * stream) {
    // 0x1215c
    return fread(ptr, size, n, stream);
}

// Address range: 0x12168 - 0x12174
int32_t function_12168(void) {
    // 0x12168
    return sched_yield();
}

// Address range: 0x12174 - 0x12180
int32_t function_12174(int32_t * newthread, int32_t * attr, int32_t * (*start_routine)(int32_t *), int32_t * arg) {
    // 0x12174
    return pthread_create(newthread, attr, start_routine, arg);
}

// Address range: 0x12180 - 0x1218c
int32_t function_12180(char * name, int32_t len) {
    // 0x12180
    return gethostname(name, len);
}

// Address range: 0x1218c - 0x12198
float32_t function_1218c(char * nptr, char ** endptr) {
    // 0x1218c
    return strtof(nptr, endptr);
}

// Address range: 0x12198 - 0x121a4
int32_t function_12198(char * file, int32_t oflag, ...) {
    // 0x12198
    return open64(file, oflag);
}

// Address range: 0x121a4 - 0x121b0
char * function_121a4(char * name) {
    // 0x121a4
    return getenv(name);
}

// Address range: 0x121b0 - 0x121bc
int32_t function_121b0(char * s) {
    // 0x121b0
    return puts(s);
}

// Address range: 0x121bc - 0x121c8
int32_t function_121bc(struct sysinfo * info) {
    // 0x121bc
    return sysinfo(info);
}

// Address range: 0x121c8 - 0x121d4
int32_t * malloc2(int32_t size) {
    // 0x121c8
    return malloc(size);
}

// Address range: 0x121d4 - 0x121e0
int32_t function_121d4(int32_t main, int32_t argc, char ** ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)()) {
    // 0x121d4
    return __libc_start_main(main, argc, ubp_av, init, fini, rtld_fini);
}

// Address range: 0x121e0 - 0x121ec
char * function_121e0(int32_t errnum) {
    // 0x121e0
    return strerror(errnum);
}

// Address range: 0x121ec - 0x121f8
int32_t function_121ec(char * s, int32_t maxsize, char * format, struct tm * tp) {
    // 0x121ec
    return strftime(s, maxsize, format, tp);
}

// Address range: 0x121f8 - 0x12204
struct tm * function_121f8(int32_t * timer) {
    // 0x121f8
    return localtime(timer);
}

// Address range: 0x12204 - 0x12210
int32_t ** function_12204(void) {
    // 0x12204
    return __ctype_tolower_loc();
}

// Address range: 0x12210 - 0x1221c
int32_t ** function_12210(void) {
    // 0x12210
    return __ctype_toupper_loc();
}

// Address range: 0x1221c - 0x12228
void function_1221c(void) {
    // 0x1221c
    __gmon_start__();
}

// Address range: 0x12228 - 0x12234
int32_t function_12228(int32_t * sem) {
    // 0x12228
    return sem_trywait(sem);
}

// Address range: 0x12234 - 0x12240
int32_t function_12234(char * old, char * new) {
    // 0x12234
    return rename(old, new);
}

// Address range: 0x12240 - 0x1224c
int16_t ** function_12240(void) {
    // 0x12240
    return __ctype_b_loc();
}

// Address range: 0x1224c - 0x12258
int32_t function_1224c(void) {
    // 0x1224c
    return getpid();
}

// Address range: 0x12258 - 0x12264
void function_12258(int32_t status) {
    // 0x12258
    exit(status);
}

// Address range: 0x12264 - 0x12270
int32_t function_12264(int32_t sysno, ...) {
    // 0x12264
    return syscall(sysno);
}

// Address range: 0x12270 - 0x1227c
int32_t function_12270(int32_t * sem, struct timespec * abstime) {
    // 0x12270
    return sem_timedwait(sem, abstime);
}

// Address range: 0x1227c - 0x12288
int32_t function_1227c(char * nptr, char ** endptr, int32_t base) {
    // 0x1227c
    return strtoul(nptr, endptr, base);
}

// Address range: 0x12288 - 0x12294
int32_t function_12288(char * s) {
    // 0x12288
    return strlen(s);
}

// Address range: 0x122a0 - 0x122ac
char * function_122a0(char * s, int32_t c) {
    // 0x122a0
    return strchr(s, c);
}

// Address range: 0x122ac - 0x122b8
int32_t function_122ac(int32_t type, int32_t * oldtype) {
    // 0x122ac
    return pthread_setcanceltype(type, oldtype);
}

// Address range: 0x122b8 - 0x122c4
int32_t function_122b8(struct _IO_FILE * stream, char * format, ...) {
    // 0x122b8
    return fprintf(stream, format);
}

// Address range: 0x122c4 - 0x122d0
int32_t function_122c4(int32_t fd, int32_t cmd, ...) {
    // 0x122c4
    return fcntl(fd, cmd);
}

// Address range: 0x122d0 - 0x122dc
float64_t function_122d0(float64_t a1) {
    // 0x122d0
    return sqrt(a1);
}

// Address range: 0x122dc - 0x122e8
int32_t function_122dc(int32_t * attr) {
    // 0x122dc
    return pthread_attr_init(attr);
}

// Address range: 0x122e8 - 0x122f4
int32_t * function_122e8(void) {
    // 0x122e8
    return __errno_location();
}

// Address range: 0x122f4 - 0x12300
int32_t function_122f4(char * s1, char * s2, int32_t n) {
    // 0x122f4
    return strncasecmp(s1, s2, n);
}

// Address range: 0x12300 - 0x1230c
int32_t function_12300(char * s, int32_t maxlen, char * format, ...) {
    // 0x12300
    return snprintf(s, maxlen, format);
}

// Address range: 0x1230c - 0x1231c
int32_t function_1230c(void (*func)(int32_t *), int32_t * arg, int32_t * dso_handle) {
    // 0x1230c
    return __cxa_atexit(func, arg, dso_handle);
}

// Address range: 0x1231c - 0x12328
int32_t function_1231c(int32_t a1, char * a2, int32_t * a3, int32_t a4) {
    // 0x1231c
    return sscanf2(a1, a2, a3, a4);
}

// Address range: 0x12328 - 0x12334
char * function_12328(char * string) {
    // 0x12328
    return __strdup(string);
}

// Address range: 0x12334 - 0x12340
int32_t function_12334(char * path, int32_t mode) {
    // 0x12334
    return mkdir(path, mode);
}

// Address range: 0x12340 - 0x1234c
int32_t function_12340(int32_t fd, struct sockaddr * addr, int32_t len) {
    // 0x12340
    return bind(fd, addr, len);
}

// Address range: 0x1234c - 0x12358
int32_t function_1234c(int32_t * sem, int32_t pshared, int32_t value) {
    // 0x1234c
    return sem_init(sem, pshared, value);
}

// Address range: 0x12358 - 0x12364
int32_t * function_12358(int32_t * s, int32_t c, int32_t n) {
    // 0x12358
    return memset(s, c, n);
}

// Address range: 0x12364 - 0x12370
int32_t function_12364(int32_t * rwlock) {
    // 0x12364
    return pthread_rwlock_unlock(rwlock);
}

// Address range: 0x12370 - 0x1237c
char * function_12370(char * dest, char * src, int32_t n) {
    // 0x12370
    return strncpy(dest, src, n);
}

// Address range: 0x1237c - 0x12388
int32_t function_1237c(int32_t th) {
    // 0x1237c
    return pthread_cancel(th);
}

// Address range: 0x12388 - 0x12394
int32_t fgetc2(struct _IO_FILE * stream) {
    // 0x12388
    return fgetc(stream);
}

// Address range: 0x12394 - 0x123a0
int32_t function_12394(int32_t option, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5) {
    // 0x12394
    return prctl(option, arg2, arg3, arg4, arg5);
}

// Address range: 0x123a0 - 0x123ac
float64_t function_123a0(char * nptr, char ** endptr) {
    // 0x123a0
    return strtod(nptr, endptr);
}

// Address range: 0x123ac - 0x123b8
int32_t function_123ac(int32_t fd, int32_t * buf, int32_t n) {
    // 0x123ac
    return write(fd, buf, n);
}

// Address range: 0x123b8 - 0x123c4
int32_t function_123b8(struct _IO_FILE * stream) {
    // 0x123b8
    return fileno(stream);
}

// Address range: 0x123c4 - 0x123d0
int32_t function_123c4(char * name, int32_t type) {
    // 0x123c4
    return access(name, type);
}

// Address range: 0x123d0 - 0x123dc
int32_t function_123d0(struct _IO_FILE * stream) {
    // 0x123d0
    return fclose(stream);
}

// Address range: 0x123dc - 0x123e8
int32_t function_123dc(int32_t * addr, int32_t len) {
    // 0x123dc
    return munmap(addr, len);
}

// Address range: 0x123e8 - 0x123f4
char * function_123e8(char * s, char * delim) {
    // 0x123e8
    return strtok(s, delim);
}

// Address range: 0x123f4 - 0x12400
int32_t function_123f4(char * pattern, int32_t flags, int32_t (*errfunc)(char *, int32_t), struct _TYPEDEF_glob64_t * pglob) {
    // 0x123f4
    return glob64(pattern, flags, errfunc, pglob);
}

// Address range: 0x12400 - 0x1240c
int32_t function_12400(int32_t * cond, int32_t * mutex, struct timespec * abstime) {
    // 0x12400
    return pthread_cond_timedwait(cond, mutex, abstime);
}

// Address range: 0x1240c - 0x12418
int32_t function_1240c(int32_t key, int32_t * pointer) {
    // 0x1240c
    return pthread_setspecific(key, pointer);
}

// Address range: 0x12418 - 0x12424
int32_t function_12418(struct _TYPEDEF_sigset_t * set) {
    // 0x12418
    return sigemptyset(set);
}

// Address range: 0x12424 - 0x12430
struct _IO_FILE * function_12424(char * command, char * modes) {
    // 0x12424
    return popen(command, modes);
}

// Address range: 0x12430 - 0x1243c
int32_t function_12430(int32_t * rwlock) {
    // 0x12430
    return pthread_rwlock_destroy(rwlock);
}

// Address range: 0x1243c - 0x12448
void function_1243c(int32_t status, char * format, ...) {
    // 0x1243c
    errx(status, format);
}

// Address range: 0x12448 - 0x12454
char * function_12448(char * s, int32_t c) {
    // 0x12448
    return strrchr(s, c);
}

// Address range: 0x12454 - 0x12460
int32_t function_12454(int32_t fd, int32_t n) {
    // 0x12454
    return listen(fd, n);
}

// Address range: 0x12460 - 0x1246c
int32_t function_12460(struct _IO_FILE * s, char * format, int32_t arg) {
    // 0x12460
    return vfprintf(s, format, arg);
}

// Address range: 0x1246c - 0x12478
int32_t function_1246c(int32_t th, int32_t ** thread_return) {
    // 0x1246c
    return pthread_join(th, thread_return);
}

// Address range: 0x12478 - 0x12484
struct _TYPEDEF_lldiv_t function_12478(int64_t numer, int64_t denom) {
    struct _TYPEDEF_lldiv_t v1; // 0x12480
    struct _TYPEDEF_lldiv_t result; // 0x12480
    // 0x12478
    v1 = lldiv(0x100000000 * numer >> 32, denom);
    result = (struct {int64_t e0; int64_t e1;}){
        .e0 = 0,
        .e1 = 0
    };
    result.e0 = 0x100000000 * v1.e0 >> 32;
    return result;
}

// Address range: 0x12484 - 0x12490
int32_t function_12484(int32_t c, struct _IO_FILE * stream) {
    // 0x12484
    return fputc(c, stream);
}

// Address range: 0x12490 - 0x1249c
void function_12490(struct _TYPEDEF_glob64_t * pglob) {
    // 0x12490
    globfree64(pglob);
}

// Address range: 0x1249c - 0x124a8
void function_1249c(int32_t pri, char * fmt, ...) {
    // 0x1249c
    syslog(pri, fmt);
}

// Address range: 0x124a8 - 0x124b4
int32_t function_124a8(char * s, char * format, ...) {
    // 0x124a8
    return sscanf(s, format);
}

// Address range: 0x124b4 - 0x124c0
struct lconv * function_124b4(void) {
    // 0x124b4
    return localeconv();
}

// Address range: 0x124c0 - 0x124cc
int32_t function_124c0(char * s, char * format, ...) {
    // 0x124c0
    return sprintf(s, format);
}

// Address range: 0x124cc - 0x124d8
void function_124cc(char * ident, int32_t option, int32_t facility) {
    // 0x124cc
    openlog(ident, option, facility);
}

// Address range: 0x124d8 - 0x124e4
int32_t function_124d8(char * s, int32_t maxlen, char * format, int32_t arg) {
    // 0x124d8
    return vsnprintf(s, maxlen, format, arg);
}

// Address range: 0x124e4 - 0x124f0
struct _IO_FILE * function_124e4(char * filename, char * modes) {
    // 0x124e4
    return fopen64(filename, modes);
}

// Address range: 0x124f0 - 0x124fc
void function_124f0(int32_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int32_t *, int32_t *)) {
    // 0x124f0
    qsort(base, nmemb, size, compar);
}

// Address range: 0x124fc - 0x12508
char * function_124fc(char * s, char * accept2) {
    // 0x124fc
    return strpbrk(s, accept2);
}

// Address range: 0x12508 - 0x12514
int32_t function_12508(int32_t * cond, int32_t * mutex) {
    // 0x12508
    return pthread_cond_wait(cond, mutex);
}

// Address range: 0x12514 - 0x12520
int32_t function_12514(int32_t domain, int32_t type, int32_t protocol) {
    // 0x12514
    return socket(domain, type, protocol);
}

// Address range: 0x12520 - 0x1252c
int32_t function_12520(int32_t clock_id, int32_t flags, struct timespec * req, struct timespec * rem) {
    // 0x12520
    return clock_nanosleep(clock_id, flags, req, rem);
}

// Address range: 0x1252c - 0x12538
int32_t function_1252c(char * cp) {
    // 0x1252c
    return inet_addr(cp);
}

// Address range: 0x12538 - 0x12544
int32_t function_12538(void) {
    // 0x12538
    return random();
}

// Address range: 0x12544 - 0x12550
void function_12544(void) {
    // 0x12544
    pthread_testcancel();
}

// Address range: 0x12550 - 0x1255c
struct hostent * function_12550(char * name) {
    // 0x12550
    return gethostbyname(name);
}

// Address range: 0x1255c - 0x12568
int32_t function_1255c(struct _IO_FILE * stream, int32_t off, int32_t whence) {
    // 0x1255c
    return fseek(stream, off, whence);
}

// Address range: 0x12568 - 0x12574
int32_t function_12568(int32_t * sem) {
    // 0x12568
    return sem_destroy(sem);
}

// Address range: 0x12574 - 0x12580
int32_t function_12574(int32_t ver, char * filename, struct stat64 * stat_buf) {
    // 0x12574
    return __xstat64(ver, filename, stat_buf);
}

// Address range: 0x12580 - 0x1258c
int32_t function_12580(int32_t fd) {
    // 0x12580
    return isatty(fd);
}

// Address range: 0x1258c - 0x12598
int32_t function_1258c(char * s, struct _IO_FILE * stream) {
    // 0x1258c
    return fputs(s, stream);
}

// Address range: 0x12598 - 0x125a4
int32_t function_12598(char * s1, char * s2, int32_t n) {
    // 0x12598
    return strncmp(s1, s2, n);
}

// Address range: 0x125a4 - 0x125b0
int32_t function_125a4(int32_t * cond) {
    // 0x125a4
    return pthread_cond_signal(cond);
}

// Address range: 0x125b0 - 0x125bc
void function_125b0(void) {
    // 0x125b0
    abort();
}

// Address range: 0x125bc - 0x125c8
int32_t function_125bc(int32_t fd, int32_t * buf, int32_t n, int32_t flags) {
    // 0x125bc
    return recv(fd, buf, n, flags);
}

// Address range: 0x125c8 - 0x125d4
int32_t function_125c8(int32_t fd) {
    // 0x125c8
    return close(fd);
}

// Address range: 0x125d4 - 0x125e0
int32_t function_125d4(int32_t ver, char * filename, struct stat64 * stat_buf) {
    // 0x125d4
    return __lxstat64(ver, filename, stat_buf);
}

// Address range: 0x125e0 - 0x125ec
int32_t function_125e0(int32_t fd, int32_t * buf, int32_t n, int32_t flags) {
    // 0x125e0
    return send(fd, buf, n, flags);
}

// Address range: 0x125ec - 0x125f8
int32_t function_125ec(int32_t fd, struct sockaddr * addr, int32_t len) {
    // 0x125ec
    return connect(fd, addr, len);
}

// Address range: 0x125f8 - 0x12604
void function_125f8(char * assertion, char * file, int32_t line, char * function) {
    // 0x125f8
    __assert_fail(assertion, file, line, function);
}

// Address range: 0x12604 - 0x12610
int32_t * function_12604(int32_t key) {
    // 0x12604
    return pthread_getspecific(key);
}

// Address range: 0x12610 - 0x1261c
int32_t function_12610(struct _IO_FILE * stream) {
    // 0x12610
    return pclose(stream);
}

// Address range: 0x12620 - 0x13c20
int32_t function_12620(int32_t a1, int32_t a2) {
    // 0x12620
    float64_t v1; // 0x12620
    __asm_vpush(v1);
    int32_t act = &g23; // bp-2484, 0x12648
    int32_t set; // bp-2480, 0x12620
    sigemptyset((struct _TYPEDEF_sigset_t *)&set);
    sigaction(SIGTERM, (struct sigaction *)&act, (struct sigaction *)&g226);
    sigaction(SIGINT, (struct sigaction *)&act, (struct sigaction *)&g230);
    sigaction(SIGABRT, (struct sigaction *)&act, (struct sigaction *)&g215);
    sem_init(&g395, 0, 0);
    function_29070(&g222, "main", 2771);
    int32_t str5; // bp-2344, 0x12620
    memset(&str5, 0, 256);
    int32_t str; // bp-2548, 0x12620
    memset(&str, 0, 64);
    snprintf((char *)&str, 64, "pidof %s", NULL);
    struct _IO_FILE * stream = popen((char *)&str, "r"); // 0x12708
    char * str2; // 0x12620
    int32_t v2; // 0x12620
    int32_t v3; // 0x12620
    int32_t v4; // 0x12620
    int32_t v5; // 0x12620
    int32_t v6; // 0x12620
    int32_t v7; // 0x12620
    int32_t v8; // 0x12620
    int32_t v9; // 0x12620
    int32_t v10; // 0x12620
    int32_t v11; // 0x12620
    int32_t v12; // 0x12620
    int32_t v13; // 0x12620
    int32_t v14; // 0x12620
    int32_t v15; // 0x12620
    int32_t str3; // bp-2580, 0x12620
    int32_t v16; // 0x12620
    int32_t v17; // 0x12620
    int32_t v18; // 0x12708
    int32_t v19; // 0x128b0
    int32_t v20; // 0x128c0
    if (stream == NULL) {
        // 0x13b88
        v4 = (int32_t)"pidof %s";
        v8 = 0;
        if (g61 == 0) {
            goto lab_0x129f0;
        } else {
            // 0x13b9c
            if ((*(char *)&g60 | *(char *)&g221) == 0) {
                // 0x13bc4
                v4 = (int32_t)"pidof %s";
                v8 = g290;
                if (g290 < 7) {
                    goto lab_0x129f0;
                } else {
                    goto lab_0x13bd8;
                }
            } else {
                goto lab_0x13bd8;
            }
        }
    } else {
        // 0x12730
        v18 = (int32_t)stream;
        if (function_11f88(&str5, 256, v18) == 0) {
            // 0x12730
            v6 = 0;
        } else {
            while (true) {
              lab_0x12748:
                // 0x12748
                v5 = 0;
                if (g61 == 0) {
                    goto lab_0x12730;
                } else {
                    // 0x12754
                    if (*(char *)&g221 == 0) {
                        // 0x12760
                        v2 = (int32_t)&g60;
                        if (*(char *)&g60 == 0 == g290 < 7) {
                            goto lab_0x127d8;
                        } else {
                            goto lab_0x12788;
                        }
                    } else {
                        goto lab_0x12788;
                    }
                }
            }
        }
      lab_0x12828:
        // 0x12828
        str2 = (char *)&str5;
        pclose(stream);
        v4 = v18;
        v8 = v6;
        if (strlen(str2) == 0) {
            goto lab_0x129f0;
        } else {
            int32_t v21 = &str5; // 0x12840
            v16 = 1;
            v14 = v21;
            v13 = 0;
            v10 = 0;
            while (true) {
              lab_0x12860:;
                int32_t v22 = v10;
                int32_t v23 = v13;
                v15 = v14;
                v17 = v16;
                memset(&str3, 0, 32);
                int32_t v24 = (int32_t)*__ctype_b_loc(); // 0x12878
                uint16_t v25 = *(int16_t *)(2 * (int32_t)*(char *)v15 + v24); // 0x12880
                v9 = v22;
                v11 = v23;
                if (((int32_t)v25 & 0x2000) == 0) {
                    goto lab_0x1284c;
                } else {
                    // 0x1288c
                    strncpy((char *)&str3, (char *)(v22 + v21), v17 + -1 - v22);
                    v19 = function_11ef8(&str3, 0, 10);
                    v9 = v17;
                    v11 = v23;
                    if (v19 < 1) {
                        goto lab_0x1284c;
                    } else {
                        // 0x128bc
                        v20 = v23 + 1;
                        v9 = v17;
                        v11 = v20;
                        if (g61 == 0) {
                            goto lab_0x1284c;
                        } else {
                            // 0x128cc
                            if ((*(char *)&g60 | *(char *)&g221) == 0) {
                                // 0x128f4
                                v9 = v17;
                                v11 = v20;
                                if (g290 < 7) {
                                    goto lab_0x1284c;
                                } else {
                                    goto lab_0x12908;
                                }
                            } else {
                                goto lab_0x12908;
                            }
                        }
                    }
                }
            }
          lab_0x12950:;
            // 0x12950
            int32_t v26; // 0x12620
            int32_t v27 = v26;
            int32_t v28; // 0x12620
            int32_t v29 = v28;
            v4 = v29;
            v8 = v27;
            if (v12 == 0) {
                goto lab_0x129f0;
            } else {
                char v30 = *(char *)&g221; // 0x12960
                char v31 = *(char *)&g60; // 0x12974
                if ((v31 || v30) == 0) {
                    int32_t v32 = g290; // 0x12988
                    v3 = v29;
                    v7 = v32;
                    if (v32 < 3) {
                        goto lab_0x129c0;
                    } else {
                        goto lab_0x12994;
                    }
                } else {
                    goto lab_0x12994;
                }
            }
        }
    }
  lab_0x12f60:;
    // 0x12f60
    int32_t v33; // 0x12dc4
    *(int32_t *)((int32_t)&g365 + 2052) = v33;
    int32_t v34; // 0x12e0c
    *(int32_t *)((int32_t)&g365 + 2056) = v34;
    char v35; // 0x12620
    int32_t v36; // 0x12620
    int32_t v37; // 0x12620
    int32_t v38; // 0x12dd4
    if (g61 == 0) {
        goto lab_0x13208;
    } else {
        // 0x12f78
        if (*(char *)&g221 == 0) {
            // 0x12f88
            if (*(char *)&g60 != 0 || g290 > 6) {
                goto lab_0x135ac;
            } else {
                int32_t v39 = (int32_t)g279; // 0x12fb4
                v35 = 0;
                v36 = v39 - v38;
                v37 = v39;
                goto lab_0x12fbc;
            }
        } else {
            goto lab_0x135ac;
        }
    }
  lab_0x13208:;
    // 0x13208
    int32_t v40; // 0x12620
    int32_t v41 = v40; // 0x12620
    int32_t str4; // bp-2088, 0x12620
    int32_t v42; // 0x12620
    char * v43; // 0x1320c
    switch ((int32_t)v43 - v38) {
        case 1: {
            goto lab_0x136bc;
        }
        case 0: {
            goto lab_0x13234;
        }
        case 2: {
            // 0x13234
            v41 = v42;
            goto lab_0x13234;
        }
        default: {
            // 0x13754
            if ((*(char *)&g60 | *(char *)&g221) == 0) {
                // 0x12ff0
                goto lab_0x12ff0_2;
            } else {
                // 0x12ffc
                snprintf((char *)&str4, 2048, "%s: job_id non't found ...\n", "bitmain_c5_scanhash");
                function_2e584(3, &str4, 0);
                goto lab_0x13028;
            }
        }
    }
  lab_0x13038:;
    // 0x13038
    int32_t v44; // 0x12d44
    function_2a3c4(v44);
    int32_t v45; // 0x12df8
    function_1e6e0(v45);
    int64_t v46; // 0x12620
    int64_t v47 = v46; // 0x13050
    if (g239 == 0) {
        // break (via goto) -> 0x13054
        goto lab_0x13054_3;
    }
    goto lab_0x12db4;
  lab_0x13234:;
    int32_t v63 = v41;
    int32_t v64; // bp-2616, 0x12620
    int32_t v51; // 0x12de4
    function_2a264(v44, &v64, v63, v63, v51);
    float64_t v65 = __asm_vldr(*(int32_t *)(v64 + 312)); // 0x13260
    int32_t v52; // 0x12e6c
    __asm_vstr(v65, v52);
    uint32_t v66 = __asm_vmov_6(v65); // 0x1326c
    int32_t v67 = function_60180(v66, v66, v63, *(int32_t *)v63); // 0x13270
    uint64_t v68 = *(int64_t *)&g402; // 0x13280
    int32_t v69 = v68 / 0x100000000; // 0x13280
    int32_t v70 = v67; // 0x13290
    if (v66 == (int32_t)v68 != (v67 == v69)) {
        // 0x13294
        g402 = v67;
        g403 = v66;
        g404 = 0;
        g405 = 0;
        int32_t v71 = -1; // 0x132b0
        int32_t v72 = -1; // 0x132b0
        int32_t v73 = v69; // 0x132b0
        if ((v67 || v66) != 0) {
            int32_t v74 = v66 / 2; // 0x132c8
            int32_t v75 = (int32_t)(v66 % 2 != 0) << 32 - v67 | (int32_t)((int64_t)v67 << (int64_t)(33 - v67)); // 0x132cc
            int32_t v76 = v75; // 0x132dc
            int32_t v77 = v74; // 0x132dc
            int32_t v78 = 0; // 0x132dc
            v71 = 0;
            v72 = 0;
            v73 = v75;
            if ((v75 || v74) != 0) {
                uint32_t v79 = v76;
                int32_t v80 = v78 == -1; // 0x132d4
                int32_t v81 = v78 + 1; // 0x132d0
                int32_t v82 = v77 / 2; // 0x132c8
                int32_t v83 = (int32_t)(v77 % 2 != 0) << 32 - v79 | (int32_t)((int64_t)v79 << (int64_t)(33 - v79)); // 0x132cc
                v77 = v82;
                v78 = v81;
                int32_t v84 = v80; // 0x132dc
                v71 = v80;
                v72 = v81;
                v73 = v83;
                while ((v83 || v82) != 0) {
                    // 0x132c0
                    v79 = v83;
                    v80 = v84 + (int32_t)(v78 == -1);
                    v81 = v78 + 1;
                    v82 = v77 / 2;
                    v83 = (int32_t)(v77 % 2 != 0) << 32 - v79 | (int32_t)((int64_t)v79 << (int64_t)(33 - v79));
                    v77 = v82;
                    v78 = v81;
                    v84 = v80;
                    v71 = v80;
                    v72 = v81;
                    v73 = v83;
                }
            }
        }
        // 0x132e0
        g404 = v72;
        g405 = v71;
        v70 = v73;
        if (g61 != 0) {
            // 0x132f8
            v70 = &g290;
            if ((*(char *)&g60 | *(char *)&g221) == 0 != g290 < 7) {
                // 0x13330
                __asm_vstr(__asm_vldr(v52), v52);
                snprintf((char *)&str4, 2048, "%s: pool_diff:%lld work_diff:%f pool_diff_bit:%lld ...\n");
                function_2e584(7, &str4, 0);
                v70 = 0;
            }
        }
    }
    float64_t v85 = __asm_vldr(g277); // 0x13374
    __asm_vstr(v85, v52);
    uint32_t v86 = __asm_vmov_6(v85); // 0x1337c
    uint32_t v87 = function_60180(v86, v86, v70, (int32_t)&g279); // 0x13380
    uint64_t v88 = *(int64_t *)&g406; // 0x13384
    if (v86 == (int32_t)v88) {
        if (v87 == (int32_t)(v88 / 0x100000000)) {
            goto lab_0x13478;
        } else {
            goto lab_0x1339c;
        }
    } else {
        goto lab_0x1339c;
    }
  lab_0x135ac:
    // 0x135ac
    snprintf((char *)&str4, 2048, "%s: Chain ID J%d ...\n", "bitmain_c5_scanhash", v45 + 1);
    function_2e584(7, &str4, 0);
    int32_t v89; // 0x12620
    int32_t v90; // 0x12620
    if (g61 == 0) {
        goto lab_0x13208;
    } else {
        int32_t v91 = (int32_t)g279; // 0x13600
        int32_t v92 = v91 - v38; // 0x13608
        v89 = v92;
        v90 = v91;
        if (*(char *)&g221 == 0) {
            // 0x135f4
            v35 = *(char *)&g60;
            v36 = v92;
            v37 = v91;
            goto lab_0x12fbc;
        } else {
            goto lab_0x131d0;
        }
    }
  lab_0x12ff0_2:
    // 0x12ff0
    if (g290 < 3) {
        goto lab_0x13028;
    } else {
        // 0x12ffc
        snprintf((char *)&str4, 2048, "%s: job_id non't found ...\n", "bitmain_c5_scanhash");
        function_2e584(3, &str4, 0);
        goto lab_0x13028;
    }
  lab_0x13028:
    // 0x13028
    if (function_1e29c(v45) != 1) {
        // break -> 0x12da8
        goto lab_0x12da8;
    }
    goto lab_0x13038;
  lab_0x12fbc:;
    int32_t v93 = v36;
    v89 = v93;
    v90 = v37;
    if (g290 > 6 || v35 != 0) {
        goto lab_0x131d0;
    } else {
        // 0x12fdc
        v41 = v40;
        switch (v93) {
            case 1: {
                goto lab_0x136bc;
            }
            case 0: {
                goto lab_0x13234;
            }
            case 2: {
                // 0x13234
                v41 = v42;
                goto lab_0x13234;
            }
            default: {
                goto lab_0x12ff0_2;
            }
        }
    }
  lab_0x131d0:
    // 0x131d0
    snprintf((char *)&str4, 2048, "%s: given_id:%d job_id:%d switch:%d  ...\n", "bitmain_c5_scanhash", v90, v38, v89);
    function_2e584(7, &str4, 0);
    goto lab_0x13208;
  lab_0x1339c:
    // 0x1339c
    *(int32_t *)&g406 = v87;
    *(int32_t *)((int32_t)&g406 + 4) = v86;
    if ((v87 || v86) != 0) {
        int32_t v94 = v86 / 2; // 0x133cc
        int32_t v95 = (int32_t)(v86 % 2 != 0) << 32 - v87 | (int32_t)((int64_t)v87 << (int64_t)(33 - v87)); // 0x133d0
        int32_t v96 = v95; // 0x133e0
        int32_t v97 = v94; // 0x133e0
        int32_t v98 = 0; // 0x133e0
        int32_t v99 = 0; // 0x133e0
        if ((v95 || v94) != 0) {
            int32_t v100 = v99;
            int32_t v101 = v98;
            uint32_t v102 = v97;
            uint32_t v103 = v96;
            int32_t v104 = v100 + (int32_t)(v101 == -1); // 0x133d8
            int32_t v105 = v101 + 1; // 0x133d4
            int32_t v106 = v102 / 2; // 0x133cc
            int32_t v107 = (int32_t)(v102 % 2 != 0) << 32 - v103 | (int32_t)((int64_t)v103 << (int64_t)(33 - v103)); // 0x133d0
            v96 = v107;
            v97 = v106;
            v98 = v105;
            v99 = v104;
            while ((v107 || v106) != 0) {
                // 0x133c4
                v100 = v99;
                v101 = v98;
                v102 = v97;
                v103 = v96;
                v104 = v100 + (int32_t)(v101 == -1);
                v105 = v101 + 1;
                v106 = v102 / 2;
                v107 = (int32_t)(v102 % 2 != 0) << 32 - v103 | (int32_t)((int64_t)v103 << (int64_t)(33 - v103));
                v96 = v107;
                v97 = v106;
                v98 = v105;
                v99 = v104;
            }
        }
    }
    // 0x133e8
    g407 = -1;
    g408 = -1;
    if (g61 != 0) {
        // 0x13400
        if ((*(char *)&g60 | *(char *)&g221) == 0 != g290 < 7) {
            // 0x13438
            __asm_vstr(__asm_vldr(v52), v52);
            snprintf((char *)&str4, 2048, "%s:net_diff:%lld current_diff:%f net_diff_bit %lld ...\n");
            function_2e584(7, &str4, 0);
        }
    }
    goto lab_0x13478;
  lab_0x13478:
    // 0x13478
    str5 = 80;
    int32_t v108 = *(int32_t *)(v64 + 64); // bp-2612, 0x134cc
    int32_t v109; // bp-2304, 0x12620
    function_316b0(&v109, &v108, 12);
    v108 = v33;
    int32_t v110; // bp-2292, 0x12620
    function_316b0(&v110, &v108, 4);
    function_2327c(&str5, &v108);
    memset(&str5, 0, 232);
    function_23430(&v108, 32, &str3);
    int32_t v111; // 0x12620
    int32_t v112 = v111 + 4; // 0x1352c
    int32_t v113 = llvm_bswap_i32(*(int32_t *)v112); // 0x13534
    int32_t v114 = (int32_t)&v64 + 4; // 0x13538
    *(int32_t *)v114 = v113;
    int32_t v115 = v114; // 0x1353c
    int32_t v116 = v112; // 0x1353c
    int32_t v117; // bp-2552, 0x12620
    while (v112 != (int32_t)&v117) {
        // 0x1352c
        v112 = v116 + 4;
        v113 = llvm_bswap_i32(*(int32_t *)v112);
        v114 = v115 + 4;
        *(int32_t *)v114 = v113;
        v115 = v114;
        v116 = v112;
    }
    int32_t v118 = 0; // 0x1354c
    int32_t v119 = v111; // 0x1354c
    int32_t v120; // bp-2584, 0x12620
    int64_t v121; // 0x12620
    int32_t v122; // 0x12620
    int32_t * v58; // 0x12620
    int32_t * v59; // 0x12620
    int16_t * v123; // 0x12620
    char * v124; // 0x12620
    int32_t v125; // 0x12620
    uint32_t v126; // 0x12620
    if (v120 == 0) {
        int32_t v127 = v119 - 4; // 0x13550
        while (*(int32_t *)v127 == 0) {
            int32_t v128 = v118 + 1; // 0x1355c
            v118 = v128;
            if (v128 == 7) {
                // break -> 0x13570
                break;
            }
            v127 -= 4;
        }
        uint32_t v129 = 7;
        uint32_t v130 = *(int32_t *)((int32_t)&g406 - 4); // 0x13574
        uint32_t v131 = 0x8000000 * v130 | *(int32_t *)((int32_t)&g406 - 8) / 32; // 0x13580
        v121 = v46;
        if (v130 < 32 == v131 == v129 || v130 < 32 == v131 < v129) {
            // 0x13784
            function_1e160();
            int32_t v132 = function_51978(v33); // 0x13790
            int32_t v133 = function_51970(v33); // 0x1379c
            if (g61 != 0) {
                // 0x137b0
                if ((*(char *)&g60 | *(char *)&g221) == 0 != g290 < 7) {
                    // 0x137e8
                    snprintf((char *)&str4, 2048, "%s: chain %d which_asic_nonce %d which_core_nonce %d", "hashtest_submit", v45, v132, v133);
                    function_2e584(7, &str4, 0);
                }
            }
            uint32_t v134 = *(int32_t *)((int32_t)&g406 - 8); // 0x13824
            int32_t v135 = *(int32_t *)((int32_t)&g406 - 4); // 0x1382c
            int32_t v136 = 8 * (v132 + 256 * v45); // 0x1384c
            int32_t * v137 = (int32_t *)(v136 + (int32_t)&g426); // 0x13858
            int32_t v138 = *v137; // 0x13858
            int32_t * v139 = (int32_t *)(v136 + (int32_t)&g426 + 4); // 0x13868
            *v137 = v138 + 1;
            uint32_t v140 = llvm_bswap_i32(*(int32_t *)(v125 - 4 * (0x8000000 * v135 | v134 / 32))); // 0x13878
            *v139 = *v139 + (int32_t)(v138 == -1);
            if (v140 < 0xffffffff >> v134 % 32) {
                int32_t v141 = 8 * v45; // 0x139b0
                int32_t * v142 = (int32_t *)(v141 + (int32_t)&g427); // 0x139b8
                uint32_t v143 = *v142; // 0x139b8
                int32_t * v144 = (int32_t *)(v141 + (int32_t)&g427 + 4); // 0x139c0
                *v142 = v143 + 256;
                *v144 = *v144 + (int32_t)(v143 > 0xfffffeff);
                function_2acec();
                v121 = (int32_t)v46 + 256;
            } else {
                // 0x1388c
                v121 = v46;
                if (v126 >= 0xfffffe != v122 != -0x1000100) {
                    int32_t v145 = 8 * v45; // 0x138ac
                    int32_t * v146 = (int32_t *)(v145 + (int32_t)&g427); // 0x138b8
                    uint32_t v147 = *v146; // 0x138b8
                    int32_t * v148 = (int32_t *)(v145 + (int32_t)&g427 + 4); // 0x138c0
                    *v146 = v147 + 256;
                    *v148 = *v148 + (int32_t)(v147 > 0xfffffeff);
                    v121 = (int32_t)v46 + 256;
                }
            }
        }
    } else {
        // 0x136cc
        if (function_1e29c(v45) == 1) {
            // 0x138f8
            if (g61 != 0) {
                // 0x13908
                if ((*(char *)&g60 | *(char *)&g221) == 0 != g290 < 7) {
                    // 0x13940
                    str4 = 0x68736168;
                    *v58 = 0x32335f32;
                    *v59 = 0x72726520;
                    *v123 = 0x726f;
                    *v124 = 0;
                    function_2e584(7, &str4, 0);
                }
            }
            // 0x13974
            function_2a3c4(v44);
            function_1e6e0(v45);
        }
        // 0x136dc
        v121 = v46;
        if (g61 != 0) {
            // 0x136ec
            v121 = v46;
            if ((*(char *)&g60 | *(char *)&g221) == 0 != g290 < 7) {
                // 0x13724
                snprintf((char *)&str4, 2048, "%s: HASH2_32[7] != 0", "hashtest_submit");
                function_2e584(7, &str4, 0);
                v121 = v46;
            }
        }
    }
    // 0x13590
    function_2a1e0(&v64, "bmminer.c", "bitmain_c5_scanhash", 2153);
    int64_t v149 = v121; // 0x12db0
    v47 = v121;
    if (g239 == 0) {
        // break -> 0x13054
        goto lab_0x13054_3;
    }
    goto lab_0x12db4_2;
  lab_0x1284c:;
    int32_t v151 = v17 + 1; // 0x1284c
    v16 = v151;
    v14 = v15 + 1;
    v13 = v11;
    v10 = v9;
    if (strlen(str2) < v151) {
        // break -> 0x12950
        goto lab_0x12950;
    }
    goto lab_0x12860;
  lab_0x12908:
    // 0x12908
    snprintf((char *)&str4, 2048, "Parsed proc id is: %d\n", v19);
    function_2e584(7, &str4, 0);
    v9 = v17;
    v11 = v20;
    goto lab_0x1284c;
  lab_0x12730:;
    int32_t v152 = function_11f88(&str5, 256, v18); // 0x1273c
    v6 = v5;
    if (v152 == 0) {
        // break -> 0x12828
        goto lab_0x12828;
    }
    goto lab_0x12748;
  lab_0x12788:
    // 0x12788
    snprintf((char *)&str4, 2048, "pidof %s command result is: %s\n", NULL, &str5);
    function_2e584(7, &str4, 0);
    v5 = 0;
    if (g61 == 0) {
        goto lab_0x12730;
    } else {
        // 0x127c4
        v2 = (int32_t)&g51 | 0x2a5c;
        if (*(char *)&g221 == 0) {
            goto lab_0x127d8;
        } else {
            goto lab_0x127f8;
        }
    }
  lab_0x127d8:
    // 0x127d8
    if (*(char *)v2 == 0) {
        // 0x127e4
        v5 = g290;
        if (g290 < 7) {
            goto lab_0x12730;
        } else {
            goto lab_0x127f8;
        }
    } else {
        goto lab_0x127f8;
    }
  lab_0x127f8:;
    int32_t len = strlen((char *)&str5); // 0x127fc
    snprintf((char *)&str4, 2048, "strlen is: %d\n", len);
    function_2e584(7, &str4, 0);
    v5 = len;
    goto lab_0x12730;
  lab_0x129f0:
    // 0x129f0
    function_52f1c("/etc/bitmain_category.conf");
    int32_t v153 = function_11eb0(1, 0x1664, v4, v8); // 0x12a14
    g225 = v153;
    int32_t v154 = function_11eb0(1, 392, v4, (int32_t)&g225); // 0x12a38
    g214 = v154;
    int32_t v155 = function_11eb0(1, 64, v4, (int32_t)&g225); // 0x12a4c
    *(int32_t *)(v155 + 36) = v154;
    *(int32_t *)(v154 + 20) = v153;
    g212 = v155;
    function_2bc2c(a1, a2);
    function_2aef4();
    if (function_2823c() != 0) {
        // 0x12a7c
        function_31d58(4, "socket init failed!");
    }
    // 0x12a8c
    if (function_339ec() != 0) {
        // 0x12a98
        function_31d58(4, "basic init failed!");
    }
    // 0x12aa8
    g220 = function_11eb0(1, 64, v4, v155);
    pthread_attr_init(&str);
    function_12024(&str, &g8);
    int32_t v156 = g220; // 0x12ad4
    if (function_30b10(v156, &str, &g22, v156) != 0) {
        // 0x12af4
        if ((*(char *)&g60 | *(char *)&g221) == 0 != g290 < 3) {
            // 0x12b30
            snprintf((char *)&str4, 2048, "%s: create thread for get api status failed\n", "main");
            function_2e584(3, &str4, 0);
        }
    }
    // 0x12b58
    function_11fa0(*(int32_t *)(g220 + 12));
    int32_t v157 = *(int32_t *)(*(int32_t *)(g212 + 36) + 20); // 0x12b74
    if (function_11fdc(v157 + 112, 0) != 0) {
        // 0x13c08
        function_28fb8("bitmain_soc_prepare", 1933);
    }
    // 0x12b88
    function_29070((int32_t *)v157, "bitmain_soc_prepare", 1934);
    function_29070((int32_t *)(v157 + 384), "bitmain_soc_prepare", 1935);
    function_29070((int32_t *)(v157 + 2232), "bitmain_soc_prepare", 1936);
    function_29070((int32_t *)(v157 + 4080), "bitmain_soc_prepare", 1937);
    memset(&str4, 0, 32);
    char v158; // 0x12620
    int32_t v159 = __asm_bfi((int32_t)v158, (int32_t)g401, 1, 1); // 0x12c10
    str4 = 81;
    function_31590(&str4, 30);
    if (function_34828(str4, (char)v159 || -4, 0x3609, g282, 2570, (int32_t)v158, 4, 600) == 0) {
        // 0x12c98
        function_31d58(4, "soc init failed!");
    }
    // 0x12ca8
    function_31d58(2, NULL);
    function_11f94(&g392, 0, 0x3609, (int32_t)g282);
    int32_t v160 = 0; // 0x12cc4
    int32_t v161 = 0x3609; // 0x12cc4
    if (g393 != 0) {
        char * v162 = g289; // 0x12cd0
        int32_t v163 = 0x3609; // 0x12cd8
        if (v162 >= (char *)3 == (v162 != (char *)3)) {
            // 0x13b54
            str4 = 0x72617473;
            function_2e584(3, &str4, 0);
            v163 = 0;
        }
        // 0x12cdc
        function_2b330(g394, g393);
        v160 = g393;
        v161 = v163;
    }
    float64_t v164 = __asm_vldr(0); // 0x12cf0
    function_11ea4(&g392, v160, v161, (int32_t)&g61);
    function_32ca8();
    int32_t v165 = &str4;
    v58 = (int32_t *)(v165 + 4);
    v59 = (int32_t *)(v165 + 8);
    int32_t v166 = v165 + 12;
    int32_t * v60 = (int32_t *)v166;
    int16_t * v61 = (int16_t *)(v165 + 16);
    char * v62 = (char *)(v165 + 18);
    v111 = &v120;
    v123 = (int16_t *)v166;
    v124 = (char *)(v165 + 14);
    int32_t v167; // bp-40, 0x12620
    v125 = (int32_t)&v167 - 2548;
    v126 = llvm_bswap_i32(v122);
    int32_t v168 = v160; // 0x12d20
    int32_t v169 = v161; // 0x12d20
    while (true) {
        int32_t v170 = v168; // 0x12d24
        int32_t v171 = v169; // 0x12d24
        int32_t v172; // 0x13058
        while (true) {
            // 0x12d28
            if (*(char *)(g214 + 364) != 0) {
                // break (via goto) -> 0x13a00
                goto lab_0x13a00;
            }
            // 0x12d3c
            v44 = g212;
            int32_t v173 = *(int32_t *)(v44 + 36); // 0x12d4c
            int32_t v174 = *(int32_t *)(v173 + 20); // 0x12d50
            function_11f94(&g88, v170, v171, v173);
            int32_t * v175 = (int32_t *)v174; // 0x12d60
            int32_t v176 = function_11f94(v175, v170, v171, v173); // 0x12d60
            int32_t v177 = v170; // 0x12d68
            int32_t v178 = v171; // 0x12d68
            if (v176 != 0) {
                int32_t v179 = *__errno_location(); // 0x13a84
                snprintf((char *)&str4, 2048, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", v179, "bmminer.c", "bitmain_c5_scanhash", 2063);
                function_2e584(3, &str4, 1);
                v177 = v165;
                v178 = 1;
            }
            int32_t rwlock = v174 + 24; // 0x12d70
            int32_t v180 = v177; // 0x12d80
            int32_t v181 = v178; // 0x12d80
            int32_t v182 = v174; // 0x12d80
            if (function_1206c(rwlock) != 0) {
                // 0x13b08
                v182 = *__errno_location();
                snprintf((char *)&str4, 2048, "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d", v182, "bmminer.c", "bitmain_c5_scanhash", 2063);
                function_2e584(3, &str4, 1);
                v180 = v165;
                v181 = 1;
            }
            // 0x12d84
            if (function_11ea4(v175, v180, v181, v182) != 0) {
                int32_t v183 = *__errno_location(); // 0x13ad0
                snprintf((char *)&str4, 2048, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", v183, "bmminer.c", "bitmain_c5_scanhash", 2063);
                function_2e584(3, &str4, 1);
            }
            // 0x12d94
            v47 = 0;
            if (g239 != 0) {
                // 0x12db4
                v42 = v174 + 3868;
                v40 = v174 + 172;
                int32_t v150 = v174 + 2020;
                v149 = 0;
                while (true) {
                  lab_0x12db4_2:
                    // 0x12db4
                    v46 = v149;
                    while (true) {
                        // 0x12db4
                        while (true) {
                          lab_0x12db4:;
                            int32_t v48 = g239;
                            int32_t v49 = g238;
                            int32_t v50 = 60 * v49; // 0x12dc0
                            v33 = *(int32_t *)(v50 + (int32_t)&g237 + 32);
                            v38 = *(int32_t *)(v50 + (int32_t)&g237 + 12);
                            v51 = *(int32_t *)(v50 + (int32_t)&g237 + 24);
                            v45 = *(int32_t *)(v50 + (int32_t)&g237 + 36);
                            v34 = *(int32_t *)(v50 + (int32_t)&g237 + 16);
                            v52 = llvm_bswap_i32(*(int32_t *)(v50 + (int32_t)&g237 + 20));
                            int32_t v53 = v48; // 0x12ea0
                            int32_t v54 = v49; // 0x12ea0
                            if (g61 != 0) {
                                // 0x12ea4
                                v53 = v48;
                                v54 = v49;
                                if ((*(char *)&g60 | *(char *)&g221) == 0 != g290 < 7) {
                                    // 0x12edc
                                    snprintf((char *)&str4, 2048, "%s: job_id:0x%x   work_id:0x%x   nonce2:0x%llx nonce3:0x%x   version:0x%x\n", "bitmain_c5_scanhash", v38, v34, (int64_t)v51, v33, v52);
                                    function_2e584(7, &str4, 0);
                                    v53 = g239;
                                    v54 = g238;
                                }
                            }
                            uint32_t v55 = v54; // 0x12f24
                            bool v56 = v55 == 509 | v55 < 509; // 0x12f34
                            int32_t v57 = v55 >= 509 == (v55 != 509) ? 0 : v56 ? v55 : 509;
                            g238 = v57 + (int32_t)v56;
                            g239 = v53 - 1;
                            if (v33 == *(int32_t *)((int32_t)&g365 + 2052)) {
                                // 0x1361c
                                if (v34 == *(int32_t *)((int32_t)&g365 + 2056)) {
                                    // 0x13628
                                    if (function_1e29c(v45) != 1) {
                                        // break -> 0x12da8
                                        break;
                                    }
                                    // 0x13638
                                    if (g61 != 0) {
                                        // 0x13648
                                        if ((*(char *)&g60 | *(char *)&g221) == 0 != g290 < 7) {
                                            // 0x13680
                                            str4 = 0x70656572;
                                            *v58 = 0x6e207461;
                                            *v59 = 0x65636e6f;
                                            *v60 = 0x72726520;
                                            *v61 = 0x726f;
                                            *v62 = 0;
                                            function_2e584(7, &str4, 0);
                                        }
                                    }
                                    goto lab_0x13038;
                                } else {
                                    goto lab_0x12f60;
                                }
                            } else {
                                goto lab_0x12f60;
                            }
                        }
                      lab_0x12da8:
                        // 0x12da8
                        v47 = v46;
                        if (g239 == 0) {
                            // break (via goto) -> 0x13054
                            goto lab_0x13054_3;
                        }
                    }
                  lab_0x136bc:
                    // 0x136bc
                    v41 = v150;
                    goto lab_0x13234;
                }
            }
          lab_0x13054_3:;
            uint64_t v184 = 0x100000000 * v47 >> 32; // 0x13058
            uint64_t v185 = v184 / 0x100000000; // 0x13058
            v172 = v185;
            int32_t v186 = g451 + v172; // 0x1306c
            int32_t v187 = g452 + (int32_t)v184 + (int32_t)(v186 < g451); // 0x13070
            g451 = v186;
            g452 = v187;
            int32_t v188 = v187; // 0x13084
            int32_t v189 = v186; // 0x13084
            if (pthread_rwlock_unlock((int32_t *)rwlock) != 0) {
                int32_t v190 = *__errno_location(); // 0x13a38
                snprintf((char *)&str4, 2048, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", v190, "bmminer.c", "bitmain_c5_scanhash", 2156);
                function_2e584(3, &str4, 1);
                v188 = v165;
                v189 = 1;
            }
            // 0x130c0
            function_2f250();
            function_11ea4(&g88, v188, v189, g293);
            function_304d4(1);
            v170 = 0;
            v171 = v172;
            if ((int32_t)(v185 || v184) != 0) {
                // break -> 0x130ec
                break;
            }
        }
        int32_t v191 = -1 * v172; // 0x1311c
        int64_t v192 = v191; // 0x13120
        int32_t v193 = 0; // 0x13130
        if (g61 != 0) {
            // 0x13134
            v193 = g61;
            if ((*(char *)&g60 | *(char *)&g221) == 0 != g290 < 7) {
                // 0x1316c
                snprintf((char *)&str4, 2048, "%s: hashes %llu ...\n", "bitmain_c5_scanhash", v192 >> 31);
                function_2e584(7, &str4, 0);
                v193 = v165;
            }
        }
        int32_t v194 = v191 >> 31; // 0x131a0
        v168 = v193;
        v169 = v194;
        if ((v194 || v191) != 0) {
            int32_t result = function_600c4(v192 >> 31, v191); // 0x131b0
            __asm_vmov(result, v191);
            return result;
        }
    }
  lab_0x13a00:
    // 0x13a00
    sem_destroy(&g395);
    function_194dc();
    function_53604();
    __asm_vpop(v164);
    return 0;
  lab_0x13bd8:
    // 0x13bd8
    snprintf((char *)&str4, 2048, " app-service:%s Not Found!!!", NULL);
    function_2e584(7, &str4, 0);
    v4 = 0;
    v8 = 0;
    goto lab_0x129f0;
  lab_0x12994:
    // 0x12994
    snprintf((char *)&str4, 2048, " %d instance of %s is  already Running on this machine", v12, NULL);
    function_2e584(3, &str4, 0);
    v3 = 0;
    v7 = v12;
    goto lab_0x129c0;
  lab_0x129c0:;
    int32_t v195 = v7;
    int32_t v196 = v3;
    v4 = v196;
    v8 = v195;
    if (v12 != 1) {
        // 0x129c8
        snprintf((char *)&str4, 2048, "%s is forbidden to start twice, will exit immediately!", (char *)2048);
        function_2e584(3, &str4, 1);
        v4 = 1;
        v8 = 2048;
    }
    goto lab_0x129f0;
}

// Address range: 0x13c20 - 0x13c44
int32_t entry_point(int32_t a1, int32_t a2) {
    // 0x13c20
    int32_t v1; // 0x13c20
    __libc_start_main(0x12620, a2, (char **)&v1, (void (*)())0x602d9, (void (*)())0x12620, (void (*)())a1);
    abort();
    // UNREACHABLE
}

// Address range: 0x13c44 - 0x13c48
int32_t function_13c44(int32_t result, int32_t a2, int32_t a3) {
    // 0x13c44
    return result;
}

// Address range: 0x13c50 - 0x13c6c
int32_t function_13c50(void) {
    int32_t v1 = *(int32_t *)((int32_t)&g4 + (int32_t)"o i2c_ioctl\n" + 648); // 0x13c5c
    if (v1 == 0) {
        int32_t result; // 0x13c50
        return result;
    }
    // 0x13c68
    __gmon_start__();
    return &g488;
}

// Address range: 0x13c74 - 0x13cd0
int32_t function_13c74(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x13c74
    float128_t v1; // 0x13c74
    float128_t v2 = v1;
    bool v3; // 0x13c74
    if (v3 || !v3) {
        return result;
    }
    // 0x13ca4
    int32_t v4; // 0x13c74
    int32_t v5 = 0x100001 * v4;
    bool v6; // 0x13c74
    int32_t v7; // 0x13c74
    if (v3) {
        // .thread
        v7 = v3 ? v5 : 0;
    } else {
        int32_t v8 = v5 & -1 - 0x400000 * v4; // 0x13cac
        v7 = v8 < 1 ? 0 : v5;
        v6 = v8 < 0;
        if (v8 == 0) {
            return unknown_240();
        }
    }
    // 0x13cbc
    if (v6 != v3) {
        __asm_svclt(0x4770);
    }
    float64_t v9; // 0x13c74
    __asm_vqrshl_s8(v9, v9);
    __asm_vaddhn_i16(v2, v2);
    if (!v3) {
        *(int32_t *)a4 = result;
        *(int32_t *)(a4 - 4) = v7;
        *(int32_t *)(a4 - 8) = a3;
    }
    return result;
}

// Address range: 0x13cd0 - 0x13cdc
int32_t function_13cd0(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t result = a1; // 0x13cd0
    if (a4 == 0) {
        // 0x13cd2
        result = function_13c74(a1, a2, a3, 0);
        int32_t v1; // 0x13cd0
        *(char *)v1 = 1;
    }
    // 0x13cda
    return result;
}

// Address range: 0x13cdc - 0x13cde
int32_t function_13cdc(void) {
    // 0x13cdc
    int32_t result; // 0x13cdc
    return result;
}

// Address range: 0x13ce0 - 0x13da4
int32_t function_13ce0(uint32_t a1) {
    // 0x13ce0
    if (function_1e2fc() == 0) {
        // 0x13d98
        return 0;
    }
    int32_t v1 = 0; // 0x13d44
    uint32_t v2 = 0; // 0x13d3c
    while (true) {
      lab_0x13d54:;
        int32_t v3 = v1;
        int32_t v4 = function_3ff08(v3); // 0x13d54
        if (v4 < 0) {
            goto lab_0x13d3c;
        } else {
            char * v5 = g289; // 0x13d60
            if (v5 != (char *)4 && v5 >= (char *)4) {
                // 0x13d6c
                int32_t str; // bp-2080, 0x13ce0
                snprintf((char *)&str, 2048, "fan[%u] speed[%u]\n", v3, v4);
                function_2e584(4, &str, 0);
            }
            // 0x13d0c
            function_1e3d4(v3, v4);
            if (v4 > 0x270f) {
                // 0x13d38
                function_1e350(v3, 0);
                goto lab_0x13d3c;
            } else {
                // 0x13d20
                if (v4 == a1 || v4 > a1) {
                    // 0x13d38
                    function_1e350(v3, 1);
                    goto lab_0x13d3c;
                } else {
                    // 0x13d38
                    function_1e350(v3, 0);
                    goto lab_0x13d3c;
                }
            }
        }
    }
  lab_0x13d98:;
    // 0x13d98
    int32_t result; // 0x13ce0
    return result;
  lab_0x13d3c:
    // 0x13d3c
    v2++;
    uint32_t v6 = function_1e2fc(); // 0x13d40
    v1 = v2 % 256;
    result = v1;
    if (v6 == v2 || v6 < v2) {
        // break -> 0x13d98
        goto lab_0x13d98;
    }
    goto lab_0x13d54;
}

// Address range: 0x13da4 - 0x13fb0
int32_t function_13da4(int32_t a1, int32_t a2) {
    int32_t v1 = 10; // 0x13db4
    int32_t str; // bp-2080, 0x13da4
    if (a2 == 0) {
        // 0x13e18
        function_13ce0(a1);
        int32_t v2 = function_1e30c(); // 0x13e1c
        int32_t v3 = function_1e2fc(); // 0x13e28
        int32_t v4 = v2 < v3 ? 0xf7a4 : (int32_t)&g319;
        int32_t v5; // 0x13da4
        if (v2 < v3) {
            int32_t v6 = v4 & 0xfffc | 0x70000; // 0x13e3c
            int32_t * v7 = (int32_t *)v6; // 0x13e44
            *v7 = *v7 + 1;
            v5 = v6;
            if (function_1e2fc() > 0) {
                int32_t v8 = 1; // 0x13da4
                int32_t v9 = 0; // 0x13da4
                char * v10 = g289; // 0x13e70
                int32_t v11; // 0x13e7c
                int32_t v12; // 0x13e84
                if (v10 != (char *)3 && v10 >= (char *)3) {
                    // 0x13e7c
                    v11 = *v7;
                    v12 = function_1e43c(v9);
                    snprintf((char *)&str, 2048, "conti_check_count:%d, fan_id = %d, fan_speed = %d\n", v11, v9, v12);
                    function_2e584(3, &str, 0);
                }
                uint32_t v13 = v8 % 256; // 0x13e5c
                v8++;
                v9 = v13;
                v5 = v6;
                while (v13 < function_1e2fc()) {
                    // 0x13e70
                    v10 = g289;
                    if (v10 != (char *)3 && v10 >= (char *)3) {
                        // 0x13e7c
                        v11 = *v7;
                        v12 = function_1e43c(v9);
                        snprintf((char *)&str, 2048, "conti_check_count:%d, fan_id = %d, fan_speed = %d\n", v11, v9, v12);
                        function_2e584(3, &str, 0);
                    }
                    // 0x13e5c
                    v13 = v8 % 256;
                    v8++;
                    v9 = v13;
                    v5 = v6;
                }
            }
        } else {
            *(int32_t *)v4 = 0;
            v5 = &g319;
        }
        uint32_t v14 = function_1e30c(); // 0x13eb8
        if (v14 >= function_1e2fc()) {
            // 0x13e00
            function_20a08(0);
            // 0x13e0c
            return 0;
        }
        uint32_t v15 = *(int32_t *)v5; // 0x13ecc
        if (v15 == 9 || v15 < 9) {
            // 0x13e00
            function_20a08(0);
            // 0x13e0c
            return 0;
        }
    } else {
        function_13ce0(a1);
        uint32_t v16 = function_1e30c(); // 0x13dc8
        while (v16 < function_1e2fc()) {
            // 0x13de0
            function_304d4(2000);
            if (v1 == 1) {
                // break -> 0x13dec
                break;
            }
            v1--;
            function_13ce0(a1);
            v16 = function_1e30c();
        }
        uint32_t v17 = function_1e30c(); // 0x13dec
        if (v17 >= function_1e2fc()) {
            // 0x13e00
            function_20a08(0);
            // 0x13e0c
            return 0;
        }
    }
    char * v18 = g289; // 0x13ee0
    if (v18 != (char *)1 && v18 != NULL) {
        int32_t v19 = function_1e30c(); // 0x13eec
        int32_t v20 = function_1e2fc(); // 0x13ef4
        snprintf((char *)&str, 2048, "Error, fan lost, only find %d (< %d)\n", v19, v20);
        function_2e584(1, &str, 0);
    }
    // 0x13f24
    if (function_1e2fc() > 0) {
        int32_t v21 = 1; // 0x13da4
        int32_t v22 = 0; // 0x13da4
        char * v23 = g289; // 0x13f44
        int32_t v24; // 0x13f54
        if (v23 != (char *)3 && v23 >= (char *)3) {
            // 0x13f50
            v24 = function_1e43c(v22);
            snprintf((char *)&str, 2048, "fan_id = %d, fan_speed = %d\n", v22, v24);
            function_2e584(3, &str, 0);
        }
        uint32_t v25 = v21 % 256; // 0x13f30
        v21++;
        v22 = v25;
        while (v25 < function_1e2fc()) {
            // 0x13f44
            v23 = g289;
            if (v23 != (char *)3 && v23 >= (char *)3) {
                // 0x13f50
                v24 = function_1e43c(v22);
                snprintf((char *)&str, 2048, "fan_id = %d, fan_speed = %d\n", v22, v24);
                function_2e584(3, &str, 0);
            }
            // 0x13f30
            v25 = v21 % 256;
            v21++;
            v22 = v25;
        }
    }
    // 0x13f84
    function_356c4(10, 255);
    function_20a08(1);
    function_31d58(7, "fan lost");
    // 0x13e0c
    return -1;
}

// Address range: 0x13fb0 - 0x140e0
int32_t function_13fb0(int32_t a1) {
    int32_t result = g320; // 0x13fd0
    if (g320 == 0) {
        // 0x1409c
        result = function_4101c(0);
        g320 = result;
    }
    // 0x13fd4
    char * str; // bp-2064, 0x13fb0
    if (result < 0) {
        // 0x1401c
        if ((*(char *)&g60 | *(char *)&g221) == 0 == g290 < 3) {
            // 0x14010
            return result;
        }
        // 0x14058
        str = (char *)0x206d7770;
        return function_2e584(3, (int32_t *)&str, 0);
    }
    // 0x13fdc
    if (g321 == a1) {
        // 0x14010
        return result;
    }
    char * v1 = g289; // 0x13ff0
    int32_t v2 = result; // 0x13ff8
    if (v1 >= (char *)4 == (v1 != (char *)4)) {
        // 0x140b0
        snprintf((char *)&str, 2048, "set pwm = %d", a1);
        function_2e584(4, (int32_t *)&str, 0);
        v2 = g320;
    }
    // 0x13ffc
    function_4110c(v2, a1);
    int32_t result2 = function_1e49c(a1); // 0x14008
    g321 = a1;
    // 0x14010
    return result2;
}

// Address range: 0x140e0 - 0x140e4
int32_t function_140e0(void) {
    // 0x140e0
    int32_t result; // 0x140e0
    return result;
}

// Address range: 0x140e4 - 0x14148
int32_t function_140e4(void) {
    char * v1 = g289; // 0x140f8
    if (v1 != (char *)3 && v1 >= (char *)3) {
        char * v2 = (char *)0x65746f4e; // bp-2056, 0x14114
        function_2e584(3, (int32_t *)&v2, 0);
    }
    // 0x14134
    return function_3ffa0(0);
}

// Address range: 0x14148 - 0x141b4
int32_t function_14148(void) {
    char * v1 = g289; // 0x1415c
    if (v1 != (char *)3 && v1 >= (char *)3) {
        char * v2 = (char *)0x65746f4e; // bp-2056, 0x14178
        function_2e584(3, (int32_t *)&v2, 0);
    }
    // 0x141a0
    return function_3ffec(0);
}

// Address range: 0x141b4 - 0x14218
int32_t function_141b4(void) {
    char * v1 = g289; // 0x141c8
    if (v1 != (char *)3 && v1 >= (char *)3) {
        char * v2 = (char *)0x65746f4e; // bp-2056, 0x141e4
        function_2e584(3, (int32_t *)&v2, 0);
    }
    // 0x14204
    return function_3ffa0(1);
}

// Address range: 0x14218 - 0x1427c
int32_t function_14218(void) {
    char * v1 = g289; // 0x1422c
    if (v1 != (char *)3 && v1 >= (char *)3) {
        char * v2 = (char *)0x65746f4e; // bp-2056, 0x14248
        function_2e584(3, (int32_t *)&v2, 0);
    }
    // 0x14268
    return function_3ffec(1);
}

// Address range: 0x1427c - 0x142bc
int32_t function_1427c(int32_t a1, int32_t a2) {
    int32_t v1 = 8; // 0x14288
    int32_t result = function_2c06c(28, a1, a2); // 0x14298
    while (result == 0) {
        // 0x142a8
        usleep(1000);
        if (v1 == 1) {
            // break -> 0x142b4
            break;
        }
        v1--;
        result = function_2c06c(28, a1, a2);
    }
    // 0x142b4
    return result;
}

// Address range: 0x142bc - 0x14434
int32_t function_142bc(int32_t a1, int32_t a2, int32_t a3, int32_t result, char * a5) {
    int32_t v1 = 0; // 0x142d8
    int32_t v2 = 2; // 0x142d8
    int32_t v3 = 2; // 0x142d8
    if (result == 0) {
        function_1427c(a2, a1);
        function_1ecdc(152, a3, 0, 0, a2, a1);
        usleep(1000);
        uint32_t v4 = function_1427c(a2, a1); // 0x14318
        usleep(1000);
        while (__asm_ubfx(v4, 8, 8) != a3) {
            int32_t v5 = v2;
            v1 = 1;
            v2 = 1;
            if (v5 == 1) {
                goto lab_0x14344;
            }
            function_1427c(a2, a1);
            function_1ecdc(152, a3, 0, 0, a2, a1);
            usleep(1000);
            v4 = function_1427c(a2, a1);
            usleep(1000);
        }
        // 0x14414
        if (v1 != 0 || v4 % 256 == 0) {
            // 0x14348
            return 0;
        }
        *a5 = (char)v4;
        // 0x14348
        return 1;
    }
    int32_t v6 = 0;
    function_1427c(a2, a1);
    function_1ecdc(152, a3, (int32_t)*a5, 1, a2, a1);
    function_1427c(a2, a1);
    usleep(1000);
    function_1427c(a2, a1);
    function_1ecdc(152, a3, 0, 0, a2, a1);
    int32_t v7 = function_1427c(a2, a1); // 0x143c4
    usleep(1000);
    while (__asm_ubfx(v7, 8, 8) != a3) {
        // 0x143e4
        if (*a5 == (char)v7) {
            // break -> 0x14404
            break;
        }
        int32_t v8 = v3;
        v3 = 1;
        if (v8 == 1) {
            // 0x14348
            return 0;
        }
        v6 = 1;
        function_1427c(a2, a1);
        function_1ecdc(152, a3, (int32_t)*a5, 1, a2, a1);
        function_1427c(a2, a1);
        usleep(1000);
        function_1427c(a2, a1);
        function_1ecdc(152, a3, 0, 0, a2, a1);
        v7 = function_1427c(a2, a1);
        usleep(1000);
    }
    // 0x14404
    if (v6 == 0) {
        // 0x14348
        return result;
    }
    // 0x14348
    return 0;
}

// Address range: 0x14434 - 0x14454
int32_t function_14434(void) {
    // 0x14434
    if (function_1e170() == 0) {
        // 0x1444c
        return function_1e19c();
    }
    // 0x14444
    return function_1e170();
}

// Address range: 0x14454 - 0x146c8
int32_t function_14454(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x14454
    char * str; // bp-2080, 0x14454
    if (g322 == NULL) {
        char * v1 = g289; // 0x1447c
        if (v1 >= (char *)3 != v1 != (char *)3) {
            // 0x1448c
            return 255;
        }
        // 0x14498
        str = (char *)0x206e6163;
        function_2e584(3, (int32_t *)&str, (int32_t)g322);
        return 255;
    }
    // 0x144e0
    if (function_1e29c(a1) == 0) {
        char * v2 = g289; // 0x14504
        if (v2 != (char *)4 && v2 >= (char *)4) {
            // 0x14510
            snprintf((char *)&str, 2048, "%s chain %d not pluged", "read_sensor_on_asic", a1);
            function_2e584(4, (int32_t *)&str, 0);
        }
        // 0x1448c
        return 255;
    }
    // 0x14548
    if (function_1e170() == 0) {
        char * v3 = g289; // 0x1455c
        if (v3 != (char *)3 && v3 >= (char *)3) {
            // 0x14568
            snprintf((char *)&str, 2048, "%s chain %d ,index %d not connected", "read_sensor_on_asic", a1, a2);
            function_2e584(3, (int32_t *)&str, 0);
        }
        // 0x1448c
        return 255;
    }
    // 0x145a0
    if (function_14434() > a2) {
        if (a3 != 0 != a3 != 1) {
            char v4 = -1; // bp-2081, 0x145bc
            int32_t v5 = 4 * a2; // 0x145cc
            int32_t v6 = a4 == 0 ? (int32_t)"read_sensor_on_asic" + 29 : (int32_t)"read_sensor_on_asic" + 30;
            int32_t v7 = (int32_t)*(char *)(v6 + 16 * a3);
            uint32_t v8 = __asm_smulbb(*(int32_t *)(g323 + v5), (int32_t)g322); // 0x145e8
            if (function_142bc(a1, v8 % 256, v7, 0, &v4) != 0) {
                // 0x1448c
                return (int32_t)v4 - 64;
            }
            char * v9 = g289; // 0x14610
            if (v9 != (char *)3 && v9 >= (char *)3) {
                int32_t v10 = *(int32_t *)(g323 + v5); // 0x1462c
                snprintf((char *)&str, 2048, "read temp sensor failed: chain = %d, sensor pos = %d, address = %d, reg = %d\n", a1, v10, v10 * (int32_t)g322, v7);
                function_2e584(3, (int32_t *)&str, 0);
            }
            // 0x1448c
            return 255;
        }
    }
    char * v11 = g289; // 0x1466c
    if (v11 != (char *)3 && v11 >= (char *)3) {
        // 0x14678
        snprintf((char *)&str, 2048, "%s invalid param. index = %d, type = %d, model = %d on chain %d", "read_sensor_on_asic", a2, a4, a3, a1);
        function_2e584(3, (int32_t *)&str, 0);
    }
    // 0x1448c
    return 255;
}

// Address range: 0x146c8 - 0x14cb8
int32_t function_146c8(uint32_t a1) {
    char * v1 = NULL; // 0x146f8
    int32_t v2; // 0x146c8
    int32_t v3; // 0x146c8
    int32_t v4; // 0x146c8
    char * str; // bp-2088, 0x146c8
    int32_t v5; // 0x146c8
    char * v6; // 0x146c8
    int32_t v7; // 0x1476c
    int32_t v8; // 0x146d4
    int32_t v9; // 0x14700
    uint32_t v10; // 0x1472c
    if (function_14434() > 0) {
        // 0x146fc
        v8 = 4 * a1;
        v3 = 0;
        while (true) {
          lab_0x146fc:
            // 0x146fc
            v4 = v3;
            v9 = 4 * v4;
            int32_t v11 = *(int32_t *)(g323 + v9); // 0x14724
            v10 = __asm_smulbb(v11, (int32_t)g322) % 256;
            function_50874(a1 % 256, v10, 0);
            usleep(0x2710);
            int32_t v12 = 4; // 0x1473c
            str = NULL;
            function_142bc(a1, v10, 254, 0, (char *)&str);
            v5 = 0;
            v6 = "NCT218";
            while ((int32_t)str % 256 != 26) {
                int32_t v13 = v12;
                v7 = v13 - 1;
                v12 = v7;
                if (v13 == 1) {
                    // 0x14778
                    v2 = 4;
                    goto lab_0x14778_2;
                }
                str = NULL;
                function_142bc(a1, v10, 254, 0, (char *)&str);
                v5 = 0;
                v6 = "NCT218";
            }
            goto lab_0x147d8;
        }
      lab_0x147f8:;
        char * v14 = g289; // 0x147f8
        if (v14 >= (char *)3 != v14 != (char *)3) {
            // 0x147b8
            return 0;
        }
        // 0x148a0
        str = (char *)0x206e6163;
        function_2e584(3, (int32_t *)&str, 0);
        goto lab_0x148d4;
    } else {
        goto lab_0x149cc;
    }
  lab_0x149cc:;
    char * v15 = g289;
    int32_t result = 0; // 0x149d0
    if (v15 != (char *)3 && v15 >= (char *)3) {
        // 0x149d4
        snprintf((char *)&str, 2048, "chain %d temp sensor %s\n", a1, v1);
        function_2e584(3, (int32_t *)&str, 0);
        result = 0;
    }
  lab_0x147b8:
    // 0x147b8
    return result;
  lab_0x14a78:;
    // 0x14a78
    int32_t v16; // 0x14b00
    if ((v16 < 0 ? -v16 : v16) < 3) {
        goto lab_0x146f0_3;
    }
    goto lab_0x14a88;
  lab_0x14a88:;
    // 0x14a88
    int32_t v17; // 0x146c8
    int32_t v18 = (v17 + 255) % 256; // 0x14a90
    int32_t v19 = v18; // 0x14a98
    if (v18 == 0) {
        goto lab_0x146f0_3;
    }
    goto lab_0x14a9c;
  lab_0x14b5c:;
    // 0x14b5c
    int32_t format; // 0x146c8
    int32_t v32; // 0x146c8
    int32_t v31; // 0x146c8
    snprintf((char *)&str, 2048, (char *)format, v32, a1, v31);
    function_2e584(3, (int32_t *)&str, 0);
    if ((v16 < 0 ? -v16 : v16) <= 2) {
        goto lab_0x146f0_3;
    }
    goto lab_0x14a88;
  lab_0x147d8:;
    char * v40 = v6;
    char * v41 = g289; // 0x147d8
    if (v41 >= (char *)3 == (v41 != (char *)3)) {
        int32_t v42 = *(int32_t *)(g323 + v9); // 0x1482c
        snprintf((char *)&str, 2048, "sensor %d @ chain %d is %s", v42, a1, v40);
        function_2e584(3, (int32_t *)&str, 0);
    }
    // 0x147e4
    if (g322 == NULL) {
        // break -> 0x147f8
        goto lab_0x147f8;
    }
    // 0x14850
    if (function_1e170() == 0) {
        char * v43 = g289; // 0x1485c
        result = 0;
        if (v43 == (char *)3 || v43 < (char *)3) {
            goto lab_0x147b8;
        } else {
            // 0x1486c
            snprintf((char *)&str, 2048, "%s chain %d ,index %d not connected", "set_ext_mode", a1, v4);
            function_2e584(3, (int32_t *)&str, 0);
            goto lab_0x148d4;
        }
    }
    int32_t v44 = 16 * v5; // 0x14934
    unsigned char v45 = *(char *)(v44 + (int32_t)"read_sensor_on_asic" + 31); // 0x14954
    uint32_t v46 = __asm_smulbb(*(int32_t *)(g323 + v9), (int32_t)g322); // 0x1496c
    if (function_142bc(a1, v46 % 256, (int32_t)v45, 1, (char *)&g488) == 0) {
        char * v47 = g289; // 0x14980
        result = 0;
        if (v47 == (char *)3 || v47 < (char *)3) {
            goto lab_0x147b8;
        } else {
            int32_t v48 = *(int32_t *)(g323 + v9); // 0x149a8
            snprintf((char *)&str, 2048, "set ext mode failed for senser %d @ chain %d", v48, a1);
            function_2e584(3, (int32_t *)&str, 0);
            goto lab_0x148d4;
        }
    }
    int32_t v23 = 6 * v4 + 2;
    char * v35 = (char *)(v44 | 32);
    v19 = 11;
    while (true) {
      lab_0x14a9c:
        // 0x14a9c
        v17 = v19;
        int32_t v20 = function_14454(a1, v4, v5, 0); // 0x14aac
        int32_t v21 = __asm_sxtb(v20); // 0x14abc
        int32_t v22 = *(int32_t *)(g324 + v8); // 0x14acc
        *(int16_t *)(*(int32_t *)(v22 + 4) + v23) = (int16_t)v21;
        int32_t v24 = function_14454(a1, v4, v5, 1); // 0x14ae0
        uint32_t v25 = v20 - v24; // 0x14ae8
        int32_t v26 = __asm_sxtb(v24); // 0x14af0
        int32_t v27 = *(int32_t *)(g324 + v8); // 0x14af4
        uint32_t v28 = (v25 + 2) % 256; // 0x14afc
        v16 = __asm_sxtb(v25 % 256);
        *(int16_t *)(*(int32_t *)(v27 + 8) + v23) = (int16_t)v26;
        if (v28 == 4 || v28 < 4) {
            // break -> 0x14c70
            break;
        }
        // 0x14b18
        if (g322 == NULL) {
            char * v29 = g289; // 0x14a6c
            if (v29 >= (char *)3 == (v29 != (char *)3)) {
                // 0x14b88
                str = (char *)0x206e6163;
                function_2e584(3, (int32_t *)&str, (int32_t)g322);
            }
            goto lab_0x14a78;
        } else {
            // 0x14b28
            if (function_1e170() == 0) {
                char * v30 = g289; // 0x14b34
                v31 = v4;
                format = (int32_t)"%s chain %d ,index %d not connected";
                v32 = (int32_t)"set_sensor_offset";
                if (v30 == (char *)3 || v30 < (char *)3) {
                    goto lab_0x14a78;
                } else {
                    goto lab_0x14b5c;
                }
            } else {
                uint32_t v33 = __asm_smulbb(*(int32_t *)(g323 + v9), (int32_t)g322); // 0x14bec
                int32_t v34 = function_142bc(a1, v33 % 256, (int32_t)*v35, 1, (char *)&g488); // 0x14bf4
                char * v36 = g289; // 0x14bfc
                bool v37 = v36 == (char *)3 | v36 < (char *)3;
                if (v34 == 0) {
                    if (!v37) {
                        int32_t v38 = g323; // 0x14c0c
                        int32_t v39 = *(int32_t *)(v38 + v9); // 0x14c24
                        snprintf((char *)&str, 2048, "set offset failed for senser %d @ chain %d", v39, a1);
                        function_2e584(3, (int32_t *)&str, 0);
                    }
                    goto lab_0x14a78;
                } else {
                    if (v37) {
                        goto lab_0x14a78;
                    } else {
                        // 0x14c4c
                        v31 = v16;
                        format = (int32_t)"sensor %d @ chain %d, offset = %d";
                        v32 = *(int32_t *)(g323 + v9);
                        goto lab_0x14b5c;
                    }
                }
            }
        }
    }
    char * v49 = g289; // 0x14c70
    if (v49 != (char *)4 && v49 >= (char *)4) {
        int32_t v50 = *(int32_t *)(g323 + v9); // 0x14c98
        snprintf((char *)&str, 2048, "sensor %d @ chain %d chip_temp_offset less than 2, no need to set offset", v50, a1);
        function_2e584(4, (int32_t *)&str, 0);
    }
  lab_0x146f0_3:;
    int32_t v51 = v4 + 1;
    v3 = v51;
    v1 = v40;
    if (function_14434() <= v51) {
        goto lab_0x149cc;
    }
    goto lab_0x146fc;
  lab_0x148d4:;
    char * v52 = g289; // 0x148d4
    if (v52 == (char *)3 || v52 < (char *)3) {
        int32_t result2 = result;
        return result2;
    }
    int32_t v53 = *(int32_t *)(g323 + v9); // 0x148f8
    snprintf((char *)&str, 2048, "sensor %d @ chain %d fail to set to ext mode", v53, a1);
    function_2e584(3, (int32_t *)&str, 0);
    v1 = v40;
    goto lab_0x149cc;
  lab_0x14778_2:
    // 0x14778
    str = (char *)(0x1000000 * v7 >> 24);
    function_142bc(a1, v10, 254, 0, (char *)&str);
    v5 = 1;
    v6 = "TMP451";
    if ((int32_t)str % 256 == 85) {
        goto lab_0x147d8;
    } else {
        int32_t v54 = v2;
        int32_t v55 = v54 - 1; // 0x147a4
        v2 = v55;
        if (v54 == 1) {
            char * v56 = g289; // 0x147ac
            result = -1;
            if (v56 >= (char *)3 == (v56 != (char *)3)) {
                int32_t v57 = *(int32_t *)(g323 + v9); // 0x14a1c
                snprintf((char *)&str, 2048, "sensor %d @ chain %d manufacture id unknown", v57, a1);
                function_2e584(3, (int32_t *)&str, v55);
                return -1;
            }
            goto lab_0x147b8;
        } else {
            goto lab_0x14778_2;
        }
    }
}

// Address range: 0x14cc0 - 0x14d5c
int32_t function_14cc0(int32_t a1, int32_t a2, uint32_t a3) {
    if (a2 == 0) {
        // 0x14d0c
        if ((uint32_t)function_1e19c() <= a3) {
            // 0x14d00
            return 255;
        }
    } else {
        // 0x14cd4
        if (function_1e170() == 0) {
            // 0x14d00
            return 255;
        }
        // 0x14ce0
        if (function_14434() <= a3 || g325 == 0) {
            // 0x14d00
            return 255;
        }
    }
    // 0x14d20
    if (g324 == 0) {
        // 0x14d00
        return 255;
    }
    // 0x14d2c
    function_11f94(&g326, a2, a3, g324);
    int32_t v1 = *(int32_t *)(g324 + 4 * a1); // 0x14d40
    int32_t v2 = *(int32_t *)(v1 + 4 * a2); // 0x14d44
    function_11ea4(&g326, a2, v2, v1);
    return (int32_t)*(int16_t *)(6 * a3 + 2 + v2);
}

// Address range: 0x14d60 - 0x14dd4
int32_t function_14d60(int32_t a1, int32_t a2, int32_t a3) {
    // 0x14d60
    int32_t v1; // 0x14d60
    function_11f94(&g326, a2, a3, v1);
    int32_t v2; // 0x14d60
    if (a2 == 0) {
        // 0x14d80
        v2 = function_1e19c();
    } else {
        // 0x14dcc
        v2 = function_14434();
    }
    int32_t result = 0; // 0x14d88
    int32_t v3; // 0x14d60
    if (a1 < 4 == v2 > a3) {
        int32_t v4 = *(int32_t *)(*(int32_t *)(g324 + 4 * a1) + 4 * a2); // 0x14da8
        v3 = v4;
        result = (int32_t)*(int16_t *)(6 * a3 + 4 + v4);
    }
    // 0x14dbc
    function_11ea4(&g326, a2, a3, v3);
    return result;
}

// Address range: 0x14dd8 - 0x14e90
int32_t function_14dd8(int32_t a1, int32_t a2, uint32_t a3) {
    // 0x14dd8
    if (a3 > -1 != function_1e29c(a1) != 0) {
        // 0x14e74
        return 255;
    }
    switch (a2) {
        case 1: {
            // 0x14e80
            if (function_14434() <= a3) {
                // 0x14e74
                return 255;
            }
            // break -> 0x14e24
            break;
        }
        case 2: {
            // 0x14e5c
            if (function_14434() <= a3 || function_1e170() == 0) {
                // 0x14e74
                return 255;
            }
            // break -> 0x14e24
            break;
        }
        case 0: {
            // 0x14e18
            if (function_1e19c() <= a3) {
                // 0x14e74
                return 255;
            }
            // break -> 0x14e24
            break;
        }
    }
    // 0x14e24
    int32_t v1; // 0x14dd8
    function_11f94(&g326, a2, a3, v1);
    int32_t v2 = *(int32_t *)(*(int32_t *)(g324 + 4 * a1) + 4 * a2); // 0x14e44
    function_11ea4(&g326, a2, a3, v2);
    return (int32_t)*(int16_t *)(6 * a3 + 2 + v2);
}

// Address range: 0x14e90 - 0x14ed0
int32_t function_14e90(int32_t a1, int32_t a2) {
    if (a2 == 0) {
        // 0x14ec4
        return (int32_t)"LM75A";
    }
    int32_t v1 = *(int32_t *)(g324 + 4 * a1); // 0x14eac
    int16_t v2 = *(int16_t *)*(int32_t *)(v1 + 4 * a2); // 0x14eb4
    int32_t result = *(int32_t *)(16 * (int32_t)v2 + (int32_t)"read_sensor_on_asic" + 20); // 0x14ebc
    return result;
}

// Address range: 0x14ed0 - 0x14f20
int32_t function_14ed0(int32_t a1) {
    // 0x14ed0
    if ((uint32_t)function_14434() <= 0) {
        // 0x14f10
        return 0;
    }
    int32_t v1 = 0; // 0x14eec
    if (*(int32_t *)(g323 + 4 * v1) == a1) {
        // 0x14f04
        if (function_1e170() != 0) {
            // break -> 0x14f10
            break;
        }
    }
    // 0x14ee4
    v1++;
    int32_t result = 0; // 0x14eec
    while (function_14434() > v1) {
        // 0x14ef0
        if (*(int32_t *)(g323 + 4 * v1) == a1) {
            // 0x14f04
            result = 1;
            if (function_1e170() != 0) {
                // break -> 0x14f10
                break;
            }
        }
        // 0x14ee4
        v1++;
        result = 0;
    }
    // 0x14f10
    return result;
}

// Address range: 0x14f20 - 0x14fa4
int32_t function_14f20(void) {
    int32_t v1 = 0;
    int32_t v2; // 0x14f20
    int32_t v3; // 0x14f20
    int32_t v4; // 0x14f90
    int32_t v5; // 0x14f78
    if (function_1e29c(v1) != 0) {
        // 0x14f54
        if (function_14434() > 0) {
            v3 = 0;
            if (function_1e170() != 0) {
                // 0x14f70
                v5 = *(int32_t *)(g323 + 4 * v3);
                function_51164(v1, __asm_smulbb(v5, (int32_t)g322) % 256);
                usleep(0x2710);
            }
            // 0x14f90
            v4 = v3 + 1;
            v2 = v4;
            while (function_14434() > v4) {
                // 0x14f60
                v3 = v2;
                if (function_1e170() != 0) {
                    // 0x14f70
                    v5 = *(int32_t *)(g323 + 4 * v3);
                    function_51164(v1, __asm_smulbb(v5, (int32_t)g322) % 256);
                    usleep(0x2710);
                }
                // 0x14f90
                v4 = v3 + 1;
                v2 = v4;
            }
        }
    }
    int32_t v6 = v1 + 1; // 0x14f40
    while (v6 != 4) {
        // 0x14f30
        v1 = v6;
        if (function_1e29c(v1) != 0) {
            // 0x14f54
            if (function_14434() > 0) {
                v3 = 0;
                if (function_1e170() != 0) {
                    // 0x14f70
                    v5 = *(int32_t *)(g323 + 4 * v3);
                    function_51164(v1, __asm_smulbb(v5, (int32_t)g322) % 256);
                    usleep(0x2710);
                }
                // 0x14f90
                v4 = v3 + 1;
                v2 = v4;
                while (function_14434() > v4) {
                    // 0x14f60
                    v3 = v2;
                    if (function_1e170() != 0) {
                        // 0x14f70
                        v5 = *(int32_t *)(g323 + 4 * v3);
                        function_51164(v1, __asm_smulbb(v5, (int32_t)g322) % 256);
                        usleep(0x2710);
                    }
                    // 0x14f90
                    v4 = v3 + 1;
                    v2 = v4;
                }
            }
        }
        // 0x14f40
        v6 = v1 + 1;
    }
    // 0x14f4c
    return 0;
}

// Address range: 0x14fa4 - 0x1514c
int32_t function_14fa4(void) {
    int32_t v1 = function_14434(); // 0x14fb0
    if (v1 > function_1e19c()) {
        // 0x14fc4
        function_14434();
    } else {
        // 0x15114
        function_1e19c();
    }
    char * v2 = g289; // 0x14fd8
    int32_t v3 = (int32_t)v2; // 0x14fe0
    int32_t v4; // 0x14fa4
    int32_t str; // bp-2080, 0x14fa4
    if (v2 >= (char *)3 == (v2 != (char *)3)) {
        // 0x15120
        snprintf((char *)&str, 2048, "max sensor num = %d", v3);
        function_2e584(3, &str, 0);
        v4 = 0;
    }
    int32_t v5 = 72 * v3; // 0x14ff4
    int32_t mem = (int32_t)malloc(16); // 0x14ffc
    g324 = mem;
    int32_t mem2 = (int32_t)malloc(48); // 0x1500c
    int32_t v6 = function_11eb0(v5, 1, v4, v3); // 0x1501c
    int32_t v7 = 6 * v3; // 0x15024
    int32_t v8 = mem2; // 0x15030
    int32_t v9 = mem - 4; // 0x15030
    int32_t v10 = v6 + v7; // 0x15034
    v9 += 4;
    *(int32_t *)v9 = v8;
    int32_t v11 = v10 + v7; // 0x1503c
    *(int32_t *)v8 = v6;
    *(int32_t *)(v8 + 4) = v10;
    *(int32_t *)(v8 + 8) = v11;
    int32_t v12 = v11 + v7; // 0x15054
    while (mem2 + 36 != v8) {
        // 0x15034
        v8 += 12;
        v10 = v12 + v7;
        v9 += 4;
        *(int32_t *)v9 = v8;
        v11 = v10 + v7;
        *(int32_t *)v8 = v12;
        *(int32_t *)(v8 + 4) = v10;
        *(int32_t *)(v8 + 8) = v11;
        v12 = v11 + v7;
    }
    // 0x15058
    g327 = v6 + v5;
    g323 = (int32_t)malloc(4 * function_14434());
    int32_t v13 = 0; // 0x15094
    if (function_14434() > 0) {
        int32_t v14 = function_1e180(v13); // 0x1507c
        *(int32_t *)(g323 + 4 * v13) = v14;
        v13++;
        while (function_14434() > v13) {
            // 0x15078
            v14 = function_1e180(v13);
            *(int32_t *)(g323 + 4 * v13) = v14;
            v13++;
        }
    }
    // 0x15098
    g328 = (int32_t)malloc(function_1e19c());
    int32_t v15 = 0; // 0x150c8
    if (function_1e19c() > 0) {
        int32_t v16 = function_1e1ac(v15); // 0x150ac
        *(char *)(g328 + v15) = (char)v16;
        v15++;
        while (function_1e19c() > v15) {
            // 0x150ac
            v16 = function_1e1ac(v15);
            *(char *)(g328 + v15) = (char)v16;
            v15++;
        }
    }
    // 0x150cc
    pthread_attr_init(&str);
    function_12024(&str, &g1);
    g329 = (char *)1;
    pthread_create(&g330, &str, (int32_t * (*)(int32_t *))0x1585c, NULL);
    return function_11fa0(g330);
}

// Address range: 0x15150 - 0x15210
int32_t function_15150(void) {
    // 0x15150
    int32_t result; // 0x15150
    if (g329 == NULL) {
        // 0x1518c
        return result;
    }
    char * v1 = g289; // 0x15178
    if (v1 == (char *)3 || v1 < (char *)3) {
        g329 = NULL;
    }
    if (v1 >= (char *)3 != v1 != (char *)3) {
        // 0x1518c
        return result;
    }
    char * v2 = (char *)0x6e696e75; // bp-2064, 0x151ac
    int32_t result2 = function_2e584(3, (int32_t *)&v2, 0); // 0x151c0
    char * v3 = g289; // 0x151c4
    g329 = NULL;
    if (v3 == (char *)3 || v3 < (char *)3) {
        // 0x1518c
        return result2;
    }
    // 0x151d8
    v2 = (char *)0x6e206f64;
    return function_2e584(3, (int32_t *)&v2, 0);
}

// Address range: 0x15210 - 0x152ec
int32_t function_15210(int32_t a1) {
    int32_t result = 0; // 0x15224
    if (function_1e170() == 0) {
        // 0x15228
        return result;
    }
    // 0x15230
    int32_t v1; // 0x15210
    function_11f94(&g326, v1, v1, v1);
    *(int32_t *)&g322 = a1;
    function_14f20();
    int32_t v2 = 0;
    int32_t v3; // 0x15210
    int32_t v4; // 0x15210
    int32_t str; // bp-2064, 0x15210
    char * v5; // 0x1529c
    if (function_1e29c(v2) != 0) {
        // 0x15284
        if (function_146c8(v2) != 0) {
            // 0x15294
            v5 = g289;
            if (v5 >= (char *)3 == (v5 != (char *)3)) {
                // 0x152c0
                snprintf((char *)&str, 2048, "calibration sensor on chain %d failed", v2);
                function_2e584(3, &str, 0);
                v3 = &str;
                v4 = 0;
                goto lab_0x152a8;
            } else {
                goto lab_0x152a8;
            }
        }
    }
    int32_t v6 = v2 + 1; // 0x1525c
    while (v6 != 4) {
        // 0x1524c
        v2 = v6;
        if (function_1e29c(v2) != 0) {
            // 0x15284
            if (function_146c8(v2) != 0) {
                // 0x15294
                v5 = g289;
                if (v5 >= (char *)3 == (v5 != (char *)3)) {
                    // 0x152c0
                    snprintf((char *)&str, 2048, "calibration sensor on chain %d failed", v2);
                    function_2e584(3, &str, 0);
                    v3 = &str;
                    v4 = 0;
                    goto lab_0x152a8;
                } else {
                    goto lab_0x152a8;
                }
            }
        }
        // 0x1525c
        v6 = v2 + 1;
    }
    // 0x15268
    g325 = 1;
    function_11ea4(&g326, v1, v1, 1);
    return 0;
  lab_0x152a8:
    // 0x152a8
    g325 = 1;
    function_11ea4(&g326, v3, v4, 1);
    result = -1;
    return result;
}

// Address range: 0x152f0 - 0x15354
int32_t function_152f0(int32_t a1, int32_t a2) {
    int32_t v1 = function_1e0c0(); // 0x152fc
    int32_t v2; // 0x152f0
    if (function_11eec(v1, "BHB28601", v2, v2) == 0) {
        // 0x1532c
        return function_14cc0(a1, 1, a2);
    }
    int32_t v3 = function_1e0c0(); // 0x15314
    if (function_11eec(v3, "BHB28501", v2, v2) == 0) {
        // 0x1532c
        return function_14cc0(a1, 1, a2);
    }
    // 0x15340
    return function_14cc0(a1, 0, a2);
}

// Address range: 0x15354 - 0x153a0
int32_t function_15354(int32_t a1, int32_t a2) {
    // 0x15354
    if (function_1e170() != 0) {
        // 0x1538c
        return function_14cc0(a1, 1, a2);
    }
    int32_t v1 = function_152f0(a1, a2); // 0x15374
    if (v1 == 255) {
        return 255;
    }
    // 0x15380
    return __asm_sxth(v1 + 10);
}

// Address range: 0x153a0 - 0x153ec
int32_t function_153a0(int32_t a1, int32_t a2) {
    // 0x153a0
    if (function_1e170() != 0) {
        // 0x153d8
        return function_14cc0(a1, 2, a2);
    }
    int32_t v1 = function_152f0(a1, a2); // 0x153c0
    if (v1 == 255) {
        return 255;
    }
    // 0x153cc
    return __asm_sxth(v1 + 15);
}

// Address range: 0x153ec - 0x154a8
int32_t function_153ec(int32_t a1, uint32_t a2) {
    // 0x153ec
    function_1e29c(a1);
    if (a2 >= 2 == (a2 != 2)) {
        // 0x15418
        return 255;
    }
    int32_t v1; // 0x153ec
    if (a2 == 0) {
        // 0x15428
        v1 = function_1e19c();
    } else {
        // 0x1549c
        v1 = function_14434();
    }
    int32_t v2 = 0; // 0x15434
    if (v1 < 1) {
        // 0x15418
        return 255;
    }
    int32_t v3 = 255;
    uint32_t v4 = v2 % 256; // 0x15478
    int32_t v5; // 0x153ec
    switch (a2) {
        case 0: {
            // 0x1548c
            v5 = function_152f0(a1, v4);
            // break -> 0x15450
            break;
        }
        case 1: {
            // 0x15494
            v5 = function_15354(a1, v4);
            // break -> 0x15450
            break;
        }
        default: {
            // 0x1544c
            v5 = function_153a0(a1, v4);
            // break -> 0x15450
            break;
        }
    }
    int32_t v6 = v5;
    int32_t v7 = v3; // 0x15454
    int32_t v8; // 0x153ec
    if (v6 != 255) {
        // 0x15458
        v8 = v3 == 255 ? v6 : v3;
        v7 = v8 < v6 == (v3 != 255) ? v6 : v8;
    }
    int32_t result = v7;
    v2++;
    while (v2 != v1) {
        // 0x15478
        v3 = result;
        v4 = v2 % 256;
        switch (a2) {
            case 0: {
                // 0x1548c
                v5 = function_152f0(a1, v4);
                // break -> 0x15450
                break;
            }
            case 1: {
                // 0x15494
                v5 = function_15354(a1, v4);
                // break -> 0x15450
                break;
            }
            default: {
                // 0x1544c
                v5 = function_153a0(a1, v4);
                // break -> 0x15450
                break;
            }
        }
        // 0x15450
        v6 = v5;
        v7 = v3;
        if (v6 != 255) {
            // 0x15458
            v8 = v3 == 255 ? v6 : v3;
            v7 = v8 < v6 == (v3 != 255) ? v6 : v8;
        }
        // 0x1546c
        result = v7;
        v2++;
    }
    // 0x15418
    return result;
}

// Address range: 0x154a8 - 0x15508
int32_t function_154a8(int32_t a1) {
    int32_t v1 = function_1e0c0(); // 0x154b0
    int32_t v2; // 0x154a8
    if (function_11eec(v1, "BHB28601", v2, v2) == 0) {
        // 0x154e0
        return __asm_sxth(function_153ec(a1, 1));
    }
    int32_t v3 = function_1e0c0(); // 0x154c8
    if (function_11eec(v3, "BHB28501", v2, v2) == 0) {
        // 0x154e0
        return __asm_sxth(function_153ec(a1, 1));
    }
    // 0x154f4
    return __asm_sxth(function_153ec(a1, 0));
}

// Address range: 0x15508 - 0x15550
int32_t function_15508(void) {
    int32_t result = 255; // 0x15510
    for (int32_t i = 0; i < 4; i++) {
        int32_t v1 = result;
        int32_t v2 = function_154a8(i); // 0x15518
        int32_t v3 = v1; // 0x15520
        if (v2 != 255) {
            // 0x15524
            v3 = v2;
            if (v1 != 255) {
                int32_t v4 = v1 == 255 ? v2 : v1;
                v3 = __asm_sxth(v2 < v4 ? v4 : v2);
            }
        }
        // 0x1553c
        result = v3;
    }
    // 0x15548
    return result;
}

// Address range: 0x15550 - 0x15564
int32_t function_15550(void) {
    // 0x15550
    int32_t v1; // 0x15550
    return __asm_sxth(function_153ec(v1, 1));
}

// Address range: 0x15564 - 0x155b0
int32_t function_15564(void) {
    int32_t result = 255; // 0x1556c
    for (int32_t i = 0; i < 4; i++) {
        int32_t v1 = result;
        int32_t v2 = __asm_sxth(function_153ec(i, 1)); // 0x1557c
        int32_t v3 = v1; // 0x15584
        if (v2 != 255) {
            int32_t v4 = v1 == 255 ? v2 : v1;
            v3 = v1 == 255 | v2 < v4 ? v4 : v2;
        }
        // 0x1559c
        result = v3;
    }
    // 0x155a8
    return result;
}

// Address range: 0x155b0 - 0x155c4
int32_t function_155b0(void) {
    // 0x155b0
    int32_t v1; // 0x155b0
    return __asm_sxth(function_153ec(v1, 2));
}

// Address range: 0x155c4 - 0x15610
int32_t function_155c4(void) {
    int32_t result = 255; // 0x155cc
    for (int32_t i = 0; i < 4; i++) {
        int32_t v1 = result;
        int32_t v2 = __asm_sxth(function_153ec(i, 2)); // 0x155dc
        int32_t v3 = v1; // 0x155e4
        if (v2 != 255) {
            int32_t v4 = v1 == 255 ? v2 : v1;
            v3 = v1 == 255 | v2 < v4 ? v4 : v2;
        }
        // 0x155fc
        result = v3;
    }
    // 0x15608
    return result;
}

// Address range: 0x15610 - 0x156cc
int32_t function_15610(int32_t a1, uint32_t a2) {
    // 0x15610
    function_1e29c(a1);
    if (a2 >= 2 == (a2 != 2)) {
        // 0x1563c
        return 255;
    }
    int32_t v1; // 0x15610
    if (a2 == 0) {
        // 0x1564c
        v1 = function_1e19c();
    } else {
        // 0x156c0
        v1 = function_14434();
    }
    int32_t v2 = 0; // 0x15658
    if (v1 < 1) {
        // 0x1563c
        return 255;
    }
    int32_t v3 = 255;
    uint32_t v4 = v2 % 256; // 0x1569c
    int32_t v5; // 0x15610
    switch (a2) {
        case 0: {
            // 0x156b0
            v5 = function_152f0(a1, v4);
            // break -> 0x15674
            break;
        }
        case 1: {
            // 0x156b8
            v5 = function_15354(a1, v4);
            // break -> 0x15674
            break;
        }
        default: {
            // 0x15670
            v5 = function_153a0(a1, v4);
            // break -> 0x15674
            break;
        }
    }
    int32_t v6 = v5;
    int32_t v7 = v3; // 0x15678
    int32_t v8; // 0x15610
    if (v6 != 255) {
        // 0x1567c
        v8 = v3 == 255 ? v6 : v3;
        v7 = v3 == 255 | v8 < v6 ? v8 : v6;
    }
    int32_t result = v7;
    v2++;
    while (v2 != v1) {
        // 0x1569c
        v3 = result;
        v4 = v2 % 256;
        switch (a2) {
            case 0: {
                // 0x156b0
                v5 = function_152f0(a1, v4);
                // break -> 0x15674
                break;
            }
            case 1: {
                // 0x156b8
                v5 = function_15354(a1, v4);
                // break -> 0x15674
                break;
            }
            default: {
                // 0x15670
                v5 = function_153a0(a1, v4);
                // break -> 0x15674
                break;
            }
        }
        // 0x15674
        v6 = v5;
        v7 = v3;
        if (v6 != 255) {
            // 0x1567c
            v8 = v3 == 255 ? v6 : v3;
            v7 = v3 == 255 | v8 < v6 ? v8 : v6;
        }
        // 0x15690
        result = v7;
        v2++;
    }
    // 0x1563c
    return result;
}

// Address range: 0x156cc - 0x1572c
int32_t function_156cc(int32_t a1) {
    int32_t v1 = function_1e0c0(); // 0x156d4
    int32_t v2; // 0x156cc
    if (function_11eec(v1, "BHB28601", v2, v2) == 0) {
        // 0x15704
        return __asm_sxth(function_15610(a1, 1));
    }
    int32_t v3 = function_1e0c0(); // 0x156ec
    if (function_11eec(v3, "BHB28501", v2, v2) == 0) {
        // 0x15704
        return __asm_sxth(function_15610(a1, 1));
    }
    // 0x15718
    return __asm_sxth(function_15610(a1, 0));
}

// Address range: 0x1572c - 0x15760
int32_t function_1572c(void) {
    int32_t v1 = 0;
    int32_t v2 = 255;
    int32_t v3 = v1 + 1; // 0x1573c
    int32_t v4 = function_156cc(v1); // 0x15740
    int32_t result = __asm_sxth(v4 < v2 ? v4 : v2); // 0x15750
    while (v3 != 4) {
        // 0x15738
        v1 = v3;
        v2 = result;
        v3 = v1 + 1;
        v4 = function_156cc(v1);
        result = __asm_sxth(v4 < v2 ? v4 : v2);
    }
    // 0x15758
    return result;
}

// Address range: 0x15760 - 0x15774
int32_t function_15760(void) {
    // 0x15760
    int32_t v1; // 0x15760
    return __asm_sxth(function_15610(v1, 1));
}

// Address range: 0x15774 - 0x157ac
int32_t function_15774(void) {
    int32_t v1 = 0; // 0x1577c
    int32_t v2 = 255;
    int32_t v3 = __asm_sxth(function_15610(v1, 1)); // 0x1578c
    v1++;
    int32_t result = v3 < v2 ? v3 : v2;
    while (v1 != 4) {
        // 0x15780
        v2 = result;
        v3 = __asm_sxth(function_15610(v1, 1));
        v1++;
        result = v3 < v2 ? v3 : v2;
    }
    // 0x157a4
    return result;
}

// Address range: 0x157ac - 0x157c0
int32_t function_157ac(void) {
    // 0x157ac
    int32_t v1; // 0x157ac
    return __asm_sxth(function_15610(v1, 2));
}

// Address range: 0x157c0 - 0x157f8
int32_t function_157c0(void) {
    int32_t v1 = 0; // 0x157c8
    int32_t v2 = 255;
    int32_t v3 = __asm_sxth(function_15610(v1, 2)); // 0x157d8
    v1++;
    int32_t result = v3 < v2 ? v3 : v2;
    while (v1 != 4) {
        // 0x157cc
        v2 = result;
        v3 = __asm_sxth(function_15610(v1, 2));
        v1++;
        result = v3 < v2 ? v3 : v2;
    }
    // 0x157f0
    return result;
}

// Address range: 0x157f8 - 0x1585c
int32_t function_157f8(int32_t a1, int32_t a2) {
    int32_t v1 = function_1e0c0(); // 0x15804
    int32_t v2; // 0x157f8
    if (function_11eec(v1, "BHB28601", v2, v2) == 0) {
        // 0x15834
        return function_14d60(a1, 1, a2);
    }
    int32_t v3 = function_1e0c0(); // 0x1581c
    if (function_11eec(v3, "BHB28501", v2, v2) == 0) {
        // 0x15834
        return function_14d60(a1, 1, a2);
    }
    // 0x15848
    return function_14d60(a1, 0, a2);
}

// Address range: 0x1585c - 0x16274
int32_t function_1585c(void) {
    // 0x1585c
    prctl(PR_SET_NAME, (int32_t)"temp_mtr", 0, 0, 0);
    char * v1 = g289; // 0x1589c
    char * str; // bp-2088, 0x1585c
    if (v1 >= (char *)3 == (v1 != (char *)3)) {
        // 0x16108
        str = (char *)0x706d6574;
        function_2e584(3, (int32_t *)&str, 0);
        if (g329 == NULL) {
            goto lab_0x15db8_2;
        } else {
            goto lab_0x158bc;
        }
    } else {
        // 0x158a8
        if (g329 == NULL) {
            // 0x15df8
            return 0;
        }
        // 0x158a8
        goto lab_0x158bc;
    }
  lab_0x15974:;
    // 0x15974
    int32_t v2; // 0x1585c
    int32_t v3 = v2;
    int32_t v4; // 0x1585c
    int32_t v5 = v4;
    int32_t v6; // 0x1585c
    int32_t v7 = v6;
    int32_t v8; // 0x1585c
    int32_t v9 = v8;
    char v10; // 0x1585c
    char v11 = v10;
    int32_t v12; // 0x1585c
    int32_t v13 = v12;
    int32_t v14 = *(int32_t *)((int32_t)&g322 + 12);
    int32_t v15 = v13; // 0x1585c
    int32_t v16 = v14; // 0x1585c
    char v17 = v11; // 0x1585c
    int32_t v18 = v9; // 0x1585c
    int32_t v19 = v7; // 0x1585c
    int32_t v20 = v5 + 1; // 0x1585c
    int32_t v21 = v3; // 0x1585c
    int32_t v22 = v5; // 0x1585c
    goto lab_0x15974_2;
  lab_0x15acc:;
    // 0x15acc
    int32_t v63; // 0x1585c
    int32_t v241 = v63;
    int32_t v59; // 0x1585c
    int32_t v242 = v59;
    int32_t * v97; // 0x1585c
    int32_t v31; // 0x1585c
    int32_t v102; // 0x1585c
    int32_t v33; // 0x1585c
    int32_t v104; // 0x1585c
    int32_t v61; // 0x1585c
    int32_t v34; // 0x1585c
    int32_t v105; // 0x1585c
    int32_t v62; // 0x1585c
    int32_t v35; // 0x1585c
    int32_t v106; // 0x1585c
    int32_t v36; // 0x1585c
    int32_t v107; // 0x1585c
    int32_t v37; // 0x1585c
    int32_t v108; // 0x1585c
    int32_t v38; // 0x1585c
    int32_t v54; // 0x1585c
    int32_t v90; // 0x1585c
    char v206; // bp-2104, 0x1585c
    int32_t v86; // bp-2112, 0x1585c
    int32_t v74; // bp-2120, 0x1585c
    char v32; // 0x1585c
    char v103; // 0x1585c
    char v60; // 0x1585c
    int32_t v95; // 0x1585c
    int32_t v96; // 0x1585c
    uint32_t v80; // 0x158f0
    uint32_t v205; // 0x1585c
    int32_t v98; // 0x1585c
    if (function_1e19c() > v54) {
        // 0x15fe4
        function_302a0(&v74);
        char v243; // 0x1585c
        if (function_1e29c(v80) == 0) {
            char * v244 = g289; // 0x16000
            v243 = -1;
            if (v244 >= (char *)4 == (v244 != (char *)4)) {
                // 0x16228
                snprintf((char *)&str, 2048, "%s chain %d not pluged", "read_sensor_on_pic", v80);
                function_2e584(4, v97, 0);
                v243 = -1;
            }
        } else {
            // 0x160a8
            if (v54 < function_1e19c()) {
                int32_t v245 = g328; // 0x16188
                char v246 = *(char *)(v245 + v54); // 0x1619c
                int32_t v247 = function_48110(v205, v246, 0, (int32_t *)&v206, 2); // 0x161a4
                if (v247 == 2) {
                    char v248 = v206; // 0x16268
                    v243 = v248;
                } else {
                    char * v249 = g289; // 0x161b4
                    v243 = -1;
                    if (v249 != (char *)3 && v249 >= (char *)3) {
                        // 0x161c0
                        snprintf((char *)&str, 2048, "fail to read pic temp for chain %d", v80);
                        function_2e584(3, v97, 0);
                        v243 = -1;
                    }
                }
            } else {
                char * v250 = g289; // 0x160b8
                v243 = -1;
                if (v250 != (char *)3 && v250 >= (char *)3) {
                    // 0x160c4
                    snprintf((char *)&str, 2048, "%s invalid index = %d on chain %d", "read_sensor_on_pic", v54, v80);
                    function_2e584(3, v97, 0);
                    v243 = -1;
                }
            }
        }
        char v251 = v243;
        function_302a0(&v86);
        int32_t v252 = v74; // 0x16024
        char * v253 = g289; // 0x16040
        v102 = v242;
        v103 = v251;
        v104 = v252;
        v105 = (int32_t)v253;
        v106 = v90;
        v107 = 1;
        v108 = v241;
        if (v253 != (char *)4 && v253 >= (char *)4) {
            int32_t v254 = v86; // 0x16024
            snprintf((char *)&str, 2048, "pic read %d on chain %d takes %ldms\n", v54, v80, 1000 * (v95 - v252 + v254) + v96);
            function_2e584(4, v97, 0);
            v102 = v242;
            v103 = v251;
            v104 = v98;
            v105 = 0;
            v106 = v54;
            v107 = 1;
            v108 = v241;
        }
        goto lab_0x15a64;
    } else {
        int32_t v255 = v62;
        int32_t v256 = v61;
        char v257 = v60;
        int32_t v258 = *(int32_t *)((int32_t)&g322 + 12);
        v31 = v242;
        v32 = v257;
        v33 = v256;
        v34 = v255;
        v35 = v258;
        v36 = 1;
        v37 = v241;
        v38 = 0;
        if (v258 == 0) {
            // 0x15abc
            v15 = v242;
            v16 = 0;
            v17 = v257;
            v18 = v256;
            v19 = v255;
            v20 = 2;
            v21 = v241 + 4;
            v22 = 1;
            goto lab_0x15974_2;
        } else {
            goto lab_0x15980;
        }
    }
  lab_0x15974_2:;
    int32_t v23 = v22;
    int32_t v24 = v21;
    int32_t v25 = v20;
    int32_t v26 = v19;
    int32_t v27 = v18;
    char v28 = v17;
    int32_t v29 = v16; // 0x15974
    int32_t v30 = v15;
    v31 = v30;
    v32 = v28;
    v33 = v27;
    v34 = v26;
    v35 = v29;
    v36 = v25;
    v37 = v24;
    v38 = v23;
    int32_t v39 = v30; // 0x1597c
    char v40 = v28; // 0x1597c
    int32_t v41 = v27; // 0x1597c
    int32_t v42 = v26; // 0x1597c
    int32_t v43 = 0; // 0x1597c
    int32_t v44 = v25; // 0x1597c
    int32_t v45 = v24; // 0x1597c
    if (v29 == 0) {
        goto lab_0x15ab4;
    } else {
        goto lab_0x15980;
    }
  lab_0x15ab4:;
    int32_t v46 = v44;
    int32_t v47 = v42;
    char v48 = v40;
    int32_t v49; // 0x1585c
    int32_t v50; // 0x1585c
    int32_t v51; // 0x1585c
    char v52; // 0x1585c
    if (v46 == 3) {
        int32_t v53 = v43;
        v52 = v48;
        v49 = v47;
        v50 = v53;
        v51 = v54 + 1;
        goto lab_0x15918;
    } else {
        int32_t v55 = v45;
        int32_t v56 = v41;
        int32_t v57 = v39;
        int32_t v58 = v55 + 4; // 0x15ac0
        v12 = v57;
        v10 = v48;
        v8 = v56;
        v6 = v47;
        v4 = v46;
        v2 = v58;
        v59 = v57;
        v60 = v48;
        v61 = v56;
        v62 = v47;
        v63 = v58;
        if (v46 == 0) {
            goto lab_0x15acc;
        } else {
            goto lab_0x15974;
        }
    }
  lab_0x15980:;
    int32_t v64 = v37;
    int32_t v65 = v36;
    int32_t v66 = v35;
    int32_t v67 = v34;
    int32_t v68 = v33;
    char v69 = v32;
    int32_t v70 = v31;
    int32_t v71 = *(int32_t *)((int32_t)&g322 + 56); // 0x15980
    v39 = v70;
    v40 = v69;
    v41 = v68;
    v42 = v67;
    v43 = v66;
    v44 = v65;
    v45 = v64;
    int32_t v72; // 0x15904
    if (v71 == 0) {
        // 0x1598c
        v39 = v70;
        v40 = v69;
        v41 = v68;
        v42 = v67;
        v43 = v66;
        v44 = v65;
        v45 = v64;
        if (function_14434() > v54) {
            int32_t v73 = v38;
            function_11f94(&g332, v68, v67, v66);
            function_302a0(&v74);
            char v75 = v69; // 0x1585c
            switch (v73) {
                case 1: {
                    int32_t v76 = g324; // 0x16160
                    int32_t v77 = *(int32_t *)(v76 + v72); // 0x1616c
                    int32_t v78 = *(int32_t *)(v77 + 4); // 0x16174
                    int16_t v79 = *(int16_t *)(v78 + v70); // 0x16178
                    v75 = function_14454(v80, v54, (int32_t)v79, 0);
                    // break -> 0x159b8
                    break;
                }
                case 2: {
                    int32_t v81 = g324; // 0x16200
                    int32_t v82 = *(int32_t *)(v81 + v72); // 0x1620c
                    int32_t v83 = *(int32_t *)(v82 + 8); // 0x16214
                    int16_t v84 = *(int16_t *)(v83 + v70); // 0x16218
                    v75 = function_14454(v80, v54, (int32_t)v84, 1);
                    // break -> 0x159b8
                    break;
                }
            }
            char v85 = v75;
            function_302a0(&v86);
            char * v87 = g289; // 0x159dc
            int32_t v88 = (int32_t)v87; // 0x159f0
            int32_t v89 = v90; // 0x159f0
            int32_t v91; // 0x1585c
            if (v87 != (char *)4 && v87 >= (char *)4) {
                int32_t v92 = v86; // 0x159c4
                int32_t v93 = v74; // 0x159c0
                int32_t v94 = v73 == 1 ? (int32_t)&g246 : (int32_t)&g247;
                snprintf((char *)&str, 2048, "%s read %d on chain %d takes %ldms\n", (char *)v94, v54, v80, 1000 * (v92 + v95 - v93) + v96);
                function_2e584(4, v97, 0);
                v91 = v98;
                v88 = 0;
                v89 = v94;
            }
            int32_t v99 = v89;
            int32_t v100 = v88;
            int32_t v101 = v91;
            function_11ea4(&g332, v101, v100, v99);
            v102 = v70;
            v103 = v85;
            v104 = v101;
            v105 = v100;
            v106 = v99;
            v107 = v65;
            v108 = v64;
            goto lab_0x15a64;
        } else {
            goto lab_0x15ab4;
        }
    } else {
        goto lab_0x15ab4;
    }
  lab_0x15a64:;
    int32_t v109 = v108;
    int32_t v110 = v107;
    int32_t v111 = v106;
    int32_t v112 = v105;
    int32_t v113 = v104;
    char v114 = v103;
    int32_t v115 = v102;
    function_11f94(&g326, v113, v112, v111);
    int32_t v116 = *(int32_t *)((int32_t)&g322 + 8); // 0x15a78
    int32_t * v117 = (int32_t *)(v116 + v72); // 0x15a8c
    int32_t v118 = *v117; // 0x15a8c
    int32_t v119 = *(int32_t *)(v118 + v109); // 0x15a90
    *(int16_t *)(v115 + 2 + v119) = (int16_t)v114;
    int32_t v120 = *v117; // 0x15a9c
    int32_t v121 = *(int32_t *)(v120 + v109); // 0x15aa0
    int32_t v122 = v121 + v115; // 0x15aa4
    *(int16_t *)(v122 + 4) = 0;
    function_11ea4(&g326, 0, v116, v122);
    v39 = v115;
    v40 = v114;
    v41 = 0;
    v42 = v116;
    v43 = v122;
    v44 = v110;
    v45 = v109;
    goto lab_0x15ab4;
  lab_0x15d24:;
    int32_t v123 = *(int32_t *)((int32_t)&g322 + 12); // 0x15d24
    int32_t v124; // 0x1585c
    int32_t v125; // 0x1585c
    int32_t v126; // 0x1585c
    int32_t v127; // 0x15ca0
    if (v123 == 0) {
        goto lab_0x15d74;
    } else {
        int32_t v128 = 2 * v124; // 0x15d34
        v125 = v128;
        v126 = v128;
        if (v127 < 81) {
            goto lab_0x15ee8;
        } else {
            goto lab_0x15d3c;
        }
    }
  lab_0x15d74:
    // 0x15d74
    function_13da4(400, 0);
    int32_t v129 = function_31d38(); // 0x15d80
    int32_t v130 = g414; // 0x15d94
    if (v129 != 0 && v130 != 1) {
        // 0x15da0
        function_35344();
    }
    // 0x15da4
    usleep(0x2710);
    int32_t v131 = *(int32_t *)((int32_t)&g322 + 48); // 0x15dac
    char v132; // 0x1585c
    char v133 = v132; // 0x15db4
    if (v131 == 0) {
        // break -> 0x15db8
        goto lab_0x15db8_2;
    }
    goto lab_0x158dc;
  lab_0x15ee8:;
    int32_t v226 = v126;
    function_20a20(0);
    int32_t v221; // 0x1585c
    if (v221 < v226) {
        // 0x15f64
        function_20a38(0);
        int32_t v227 = 255; // 0x15f78
        int32_t v228 = 0; // 0x15f78
        if (v127 == 0 == function_31d48() == 2) {
            int32_t v229 = v228;
            int32_t v230 = v227;
            int32_t v231 = v229 + 1; // 0x15f88
            int32_t v232 = function_156cc(v229); // 0x15f8c
            int32_t v233 = v232 < v230 ? v232 : v230;
            int32_t v234 = __asm_sxth(v233); // 0x15f9c
            v227 = v234;
            v228 = v231;
            while (v231 != 4) {
                // 0x15f84
                v229 = v228;
                v230 = v227;
                v231 = v229 + 1;
                v232 = function_156cc(v229);
                v233 = v232 < v230 ? v232 : v230;
                v234 = __asm_sxth(v233);
                v227 = v234;
                v228 = v231;
            }
            if (v234 == 0) {
                int32_t v235 = *(int32_t *)((int32_t)&g322 + 96); // 0x15fac
                int32_t v236 = v235 + 1; // 0x15fb0
                *(int32_t *)((int32_t)&g322 + 96) = v236;
                if (v236 > 10) {
                    goto lab_0x15d54;
                } else {
                    goto lab_0x15d74;
                }
            } else {
                goto lab_0x15d74;
            }
        } else {
            goto lab_0x15d74;
        }
    } else {
        goto lab_0x15ef8;
    }
  lab_0x15d3c:;
    int32_t v237 = v125;
    function_20a20(1);
    if (v221 < v237) {
        // 0x15d4c
        function_20a38(0);
        goto lab_0x15d54;
    } else {
        goto lab_0x15ef8;
    }
  lab_0x15ef8:
    // 0x15ef8
    function_20a38(1);
    char * v238 = g289; // 0x15f04
    if (v238 == (char *)3 || v238 < (char *)3) {
        // 0x15d64
        function_31d58(15, "over max temp");
        goto lab_0x15d74;
    } else {
        goto lab_0x15f10;
    }
  lab_0x15f10:;
    // 0x15f10
    int32_t v209; // 0x15cb0
    snprintf((char *)&str, 2048, "over max temp, pcb temp %d (max %d), chip temp %d(max %d) pcb temp rise %d chip temp rise %d, total_exit_failure %d\n", v127, 80, v209, 95, 0, 0, v221);
    function_2e584(3, v97, 0);
    // 0x15d64
    function_31d58(15, "over max temp");
    goto lab_0x15d74;
  lab_0x15d54:;
    char * v239 = g289; // 0x15d58
    if (v239 >= (char *)3 == (v239 != (char *)3)) {
        goto lab_0x15f10;
    } else {
        // 0x15d64
        function_31d58(15, "over max temp");
        goto lab_0x15d74;
    }
  lab_0x15db8_2:;
    char * v240 = g289; // 0x15dbc
    if (v240 != (char *)3 && v240 >= (char *)3) {
        // 0x15dc8
        str = (char *)0x706d6574;
        function_2e584(3, (int32_t *)&str, 0);
    }
    // 0x15df8
    return 0;
  lab_0x158bc:
    // 0x158bc
    while (true) {
      lab_0x158dc:;
        char v134 = v133;
        char v135 = v134; // 0x158ec
        char * v136 = NULL; // 0x158ec
        int32_t v137 = 0; // 0x158ec
        int32_t v138 = v137;
        char * v139 = v136;
        char v140 = v135;
        v80 = (int32_t)v139;
        char v141 = v140; // 0x15900
        int32_t v142 = v138; // 0x15900
        int32_t v143; // 0x1585c
        int32_t v144; // 0x1585c
        int32_t v145; // 0x1585c
        int32_t v146; // 0x1585c
        int32_t v147; // 0x1585c
        int32_t v148; // 0x1585c
        int32_t v149; // 0x1585c
        int32_t v150; // 0x1585c
        int32_t v151; // 0x1585c
        int32_t v152; // 0x1585c
        int32_t v153; // 0x1585c
        int32_t v154; // 0x1585c
        int32_t v155; // 0x1585c
        int32_t v156; // 0x1585c
        int32_t v157; // 0x1585c
        int32_t v158; // 0x1585c
        int32_t v159; // 0x1585c
        int32_t v160; // 0x1585c
        int32_t v161; // 0x1585c
        int32_t v162; // 0x1585c
        int32_t v163; // 0x1585c
        int32_t v164; // 0x1585c
        int32_t v165; // 0x1585c
        int32_t v166; // 0x1585c
        int32_t v167; // 0x1585c
        int32_t v168; // 0x1585c
        int32_t v169; // 0x1585c
        char v170; // 0x1585c
        int32_t v171; // 0x1585c
        int32_t v172; // 0x1585c
        int32_t v173; // 0x1585c
        int32_t v174; // 0x1585c
        int32_t v175; // 0x1585c
        uint32_t v176; // 0x1585c
        int32_t v177; // 0x15e54
        int32_t v178; // 0x15c58
        int32_t v179; // 0x15b88
        int32_t v180; // 0x15b90
        int32_t v181; // 0x15b94
        int32_t v182; // 0x15b9c
        int16_t v183; // 0x15ba4
        int32_t chars_printed; // 0x15ba8
        int32_t v184; // 0x15bac
        int32_t v185; // 0x15bb0
        int32_t v186; // 0x15bb4
        int32_t v187; // 0x15bbc
        int32_t v188; // 0x15bc4
        int32_t v189; // 0x15bcc
        int16_t v190; // 0x15bd0
        int32_t v191; // 0x1585c
        int32_t v192; // 0x15bdc
        int32_t v193; // 0x15918
        int32_t v194; // 0x15938
        int32_t v195; // 0x15b20
        int32_t v196; // 0x15e98
        int32_t v197; // 0x15b2c
        int32_t v198; // 0x15e6c
        int32_t * mem; // 0x15eb8
        int32_t * mem2; // 0x15e8c
        char * v199; // 0x1585c
        int32_t v200; // 0x15bf0
        int32_t v201; // 0x15bf8
        int32_t v202; // 0x15c14
        int32_t v203; // 0x15c28
        int32_t v204; // 0x15b78
        if (function_1e29c(v80) != 0) {
            // 0x15904
            v72 = 4 * v80;
            v205 = v80 % 256;
            v52 = v140;
            v49 = v138;
            v50 = v98;
            v51 = 0;
            while (true) {
                // 0x15918
                v54 = v51;
                v155 = v50;
                v152 = v49;
                v170 = v52;
                v193 = function_14434();
                if (v193 > function_1e19c()) {
                    // 0x1592c
                    if (v54 >= function_14434()) {
                        // break -> 0x15afc
                        break;
                    }
                } else {
                    // 0x15af0
                    if (v54 >= function_1e19c()) {
                        // break -> 0x15afc
                        break;
                    }
                }
                // 0x15938
                v194 = function_1e0c0();
                if (function_11eec(v194, "BHB28601", v152, v155) == 0) {
                    // 0x15950
                    v12 = 6 * v54;
                    v10 = v170;
                    v8 = (int32_t)"BHB28601";
                    v6 = v152;
                    v4 = 1;
                    v2 = 4;
                    goto lab_0x15974;
                } else {
                    // 0x15950
                    function_11eec(function_1e0c0(), "BHB28501", v152, v155);
                    v59 = 6 * v54;
                    v60 = v170;
                    v61 = (int32_t)"BHB28501";
                    v62 = v152;
                    v63 = 0;
                    goto lab_0x15acc;
                }
            }
            // 0x15afc
            v206 = -8;
            memset(v97, 0, 256);
            v195 = *(int32_t *)((int32_t)&g322 + 84);
            if (v195 == 0) {
                // 0x15e98
                v196 = function_14434();
                if (v196 > function_1e19c()) {
                    // 0x15eac
                    v173 = function_14434();
                } else {
                    // 0x15fd4
                    v173 = function_1e19c();
                }
                // 0x15eb8
                v174 = v173;
                mem = malloc(4 * v174 | 1);
                *(int32_t *)((int32_t)&g322 + 84) = (int32_t)mem;
            }
            // 0x15b2c
            v197 = *(int32_t *)((int32_t)&g322 + 88);
            if (v197 == 0) {
                // 0x15e6c
                v198 = function_14434();
                if (v198 > function_1e19c()) {
                    // 0x15e80
                    v171 = function_14434();
                } else {
                    // 0x15fc4
                    v171 = function_1e19c();
                }
                // 0x15e8c
                v172 = v171;
                mem2 = malloc(4 * v172 | 1);
                *(int32_t *)((int32_t)&g322 + 88) = (int32_t)mem2;
            }
            // 0x15b38
            function_11f94(&g326, 0, 256, v197);
            v146 = 0;
            v153 = 256;
            v168 = 0;
            v169 = v168;
            if (v169 == 0) {
                // 0x160a0
                v175 = function_1e19c();
            } else {
                // 0x15b50
                v154 = v153;
                v147 = v146;
                v199 = g322;
                v148 = v147;
                v150 = v154;
                v156 = 0;
                if (v199 == NULL) {
                    // break -> 0x15c80
                    break;
                }
                // 0x15b5c
                v175 = function_14434();
            }
            // 0x15b60
            v176 = v175;
            v143 = 4 * v169;
            v160 = -1;
            v164 = -1;
            if (v176 >= 1) {
                // 0x15b68
                v204 = 6 * v176;
                v158 = 0;
                v162 = 0;
                v166 = 0;
                v167 = v166;
                v163 = v162;
                v159 = v158;
                v179 = *(int32_t *)((int32_t)&g322 + 8);
                v180 = *(int32_t *)((int32_t)&g322 + 84);
                v181 = *(int32_t *)(v179 + v72);
                v182 = *(int32_t *)(v181 + v143);
                v183 = *(int16_t *)(v167 + 2 + v182);
                chars_printed = sprintf((char *)(v180 + v159), "%03d-", (int32_t)v183);
                v184 = *(int32_t *)((int32_t)&g322 + 8);
                v185 = chars_printed + v159;
                v186 = *(int32_t *)((int32_t)&g322 + 88);
                v187 = *(int32_t *)(v184 + v72);
                v188 = *(int32_t *)(v187 + v143);
                v189 = v167 + 6;
                v190 = *(int16_t *)(v167 + 4 + v188);
                v192 = sprintf((char *)(v186 + v163), "%03d-", (int32_t)v190) + v163;
                v158 = v185;
                v162 = v192;
                v166 = v189;
                while (v204 != v189) {
                    // 0x15b88
                    v167 = v166;
                    v163 = v162;
                    v159 = v158;
                    v179 = *(int32_t *)((int32_t)&g322 + 8);
                    v180 = *(int32_t *)((int32_t)&g322 + 84);
                    v181 = *(int32_t *)(v179 + v72);
                    v182 = *(int32_t *)(v181 + v143);
                    v183 = *(int16_t *)(v167 + 2 + v182);
                    chars_printed = sprintf((char *)(v180 + v159), "%03d-", (int32_t)v183);
                    v184 = *(int32_t *)((int32_t)&g322 + 8);
                    v185 = chars_printed + v159;
                    v186 = *(int32_t *)((int32_t)&g322 + 88);
                    v187 = *(int32_t *)(v184 + v72);
                    v188 = *(int32_t *)(v187 + v143);
                    v189 = v167 + 6;
                    v190 = *(int16_t *)(v167 + 4 + v188);
                    v192 = sprintf((char *)(v186 + v163), "%03d-", (int32_t)v190) + v163;
                    v158 = v185;
                    v162 = v192;
                    v166 = v189;
                }
                // 0x15be4
                v160 = v185 - 1;
                v164 = v192 - 1;
            }
            // 0x15bf0
            v165 = v164;
            v161 = v160;
            v200 = *(int32_t *)((int32_t)&g322 + 88);
            v201 = *(int32_t *)((int32_t)&g322 + 84);
            *(char *)(v200 + v165) = 32;
            *(char *)(v201 + v161) = 32;
            v202 = *(int32_t *)(v143 + v191);
            sprintf((char *)&str, "chain %d %s temp: %s, failure:%s", v80, (char *)v202, (char *)v201, (char *)v200);
            v203 = *(int32_t *)((int32_t)&g322 + 92);
            v144 = v203;
            if (v203 == 0) {
                // 0x15e4c
                v177 = function_536f4("bmminer_temp");
                *(int32_t *)((int32_t)&g322 + 92) = v177;
                v144 = v177;
            }
            // 0x15c34
            v145 = v144;
            v178 = v169 + 1;
            function_54cb0(v145, "temperature/temperature.c", 25, "dump_temp_info", 14, 539, 20, (int32_t)"%s");
            v146 = (int32_t)"temperature/temperature.c";
            v153 = 25;
            v168 = v178;
            v148 = (int32_t)"temperature/temperature.c";
            v150 = 25;
            v156 = (int32_t)"dump_temp_info";
            while (v178 != 3) {
                // 0x15b48
                v169 = v168;
                if (v169 == 0) {
                    // 0x160a0
                    v175 = function_1e19c();
                } else {
                    // 0x15b50
                    v154 = v153;
                    v147 = v146;
                    v199 = g322;
                    v148 = v147;
                    v150 = v154;
                    v156 = 0;
                    if (v199 == NULL) {
                        // break -> 0x15c80
                        break;
                    }
                    // 0x15b5c
                    v175 = function_14434();
                }
                // 0x15b60
                v176 = v175;
                v143 = 4 * v169;
                v160 = -1;
                v164 = -1;
                if (v176 >= 1) {
                    // 0x15b68
                    v204 = 6 * v176;
                    v158 = 0;
                    v162 = 0;
                    v166 = 0;
                    v167 = v166;
                    v163 = v162;
                    v159 = v158;
                    v179 = *(int32_t *)((int32_t)&g322 + 8);
                    v180 = *(int32_t *)((int32_t)&g322 + 84);
                    v181 = *(int32_t *)(v179 + v72);
                    v182 = *(int32_t *)(v181 + v143);
                    v183 = *(int16_t *)(v167 + 2 + v182);
                    chars_printed = sprintf((char *)(v180 + v159), "%03d-", (int32_t)v183);
                    v184 = *(int32_t *)((int32_t)&g322 + 8);
                    v185 = chars_printed + v159;
                    v186 = *(int32_t *)((int32_t)&g322 + 88);
                    v187 = *(int32_t *)(v184 + v72);
                    v188 = *(int32_t *)(v187 + v143);
                    v189 = v167 + 6;
                    v190 = *(int16_t *)(v167 + 4 + v188);
                    v192 = sprintf((char *)(v186 + v163), "%03d-", (int32_t)v190) + v163;
                    v158 = v185;
                    v162 = v192;
                    v166 = v189;
                    while (v204 != v189) {
                        // 0x15b88
                        v167 = v166;
                        v163 = v162;
                        v159 = v158;
                        v179 = *(int32_t *)((int32_t)&g322 + 8);
                        v180 = *(int32_t *)((int32_t)&g322 + 84);
                        v181 = *(int32_t *)(v179 + v72);
                        v182 = *(int32_t *)(v181 + v143);
                        v183 = *(int16_t *)(v167 + 2 + v182);
                        chars_printed = sprintf((char *)(v180 + v159), "%03d-", (int32_t)v183);
                        v184 = *(int32_t *)((int32_t)&g322 + 8);
                        v185 = chars_printed + v159;
                        v186 = *(int32_t *)((int32_t)&g322 + 88);
                        v187 = *(int32_t *)(v184 + v72);
                        v188 = *(int32_t *)(v187 + v143);
                        v189 = v167 + 6;
                        v190 = *(int16_t *)(v167 + 4 + v188);
                        v192 = sprintf((char *)(v186 + v163), "%03d-", (int32_t)v190) + v163;
                        v158 = v185;
                        v162 = v192;
                        v166 = v189;
                    }
                    // 0x15be4
                    v160 = v185 - 1;
                    v164 = v192 - 1;
                }
                // 0x15bf0
                v165 = v164;
                v161 = v160;
                v200 = *(int32_t *)((int32_t)&g322 + 88);
                v201 = *(int32_t *)((int32_t)&g322 + 84);
                *(char *)(v200 + v165) = 32;
                *(char *)(v201 + v161) = 32;
                v202 = *(int32_t *)(v143 + v191);
                sprintf((char *)&str, "chain %d %s temp: %s, failure:%s", v80, (char *)v202, (char *)v201, (char *)v200);
                v203 = *(int32_t *)((int32_t)&g322 + 92);
                v144 = v203;
                if (v203 == 0) {
                    // 0x15e4c
                    v177 = function_536f4("bmminer_temp");
                    *(int32_t *)((int32_t)&g322 + 92) = v177;
                    v144 = v177;
                }
                // 0x15c34
                v145 = v144;
                v178 = v169 + 1;
                function_54cb0(v145, "temperature/temperature.c", 25, "dump_temp_info", 14, 539, 20, (int32_t)"%s");
                v146 = (int32_t)"temperature/temperature.c";
                v153 = 25;
                v168 = v178;
                v148 = (int32_t)"temperature/temperature.c";
                v150 = 25;
                v156 = (int32_t)"dump_temp_info";
            }
            // 0x15c80
            v157 = v156;
            v151 = v150;
            v149 = v148;
            function_11ea4(&g326, v149, v151, v157);
            v141 = v170;
            v142 = v151;
        }
        int32_t v207 = v142;
        v132 = v141;
        int32_t v208 = v80 + 1; // 0x15c8c
        v135 = v132;
        v136 = (char *)v208;
        v137 = v207;
        while (v208 != 4) {
            // 0x158f0
            v138 = v137;
            v139 = v136;
            v140 = v135;
            v80 = (int32_t)v139;
            v141 = v140;
            v142 = v138;
            if (function_1e29c(v80) != 0) {
                // 0x15904
                v72 = 4 * v80;
                v205 = v80 % 256;
                v52 = v140;
                v49 = v138;
                v50 = v98;
                v51 = 0;
                while (true) {
                    // 0x15918
                    v54 = v51;
                    v155 = v50;
                    v152 = v49;
                    v170 = v52;
                    v193 = function_14434();
                    if (v193 > function_1e19c()) {
                        // 0x1592c
                        if (v54 >= function_14434()) {
                            // break -> 0x15afc
                            break;
                        }
                    } else {
                        // 0x15af0
                        if (v54 >= function_1e19c()) {
                            // break -> 0x15afc
                            break;
                        }
                    }
                    // 0x15938
                    v194 = function_1e0c0();
                    if (function_11eec(v194, "BHB28601", v152, v155) == 0) {
                        // 0x15950
                        v12 = 6 * v54;
                        v10 = v170;
                        v8 = (int32_t)"BHB28601";
                        v6 = v152;
                        v4 = 1;
                        v2 = 4;
                        goto lab_0x15974;
                    } else {
                        // 0x15950
                        function_11eec(function_1e0c0(), "BHB28501", v152, v155);
                        v59 = 6 * v54;
                        v60 = v170;
                        v61 = (int32_t)"BHB28501";
                        v62 = v152;
                        v63 = 0;
                        goto lab_0x15acc;
                    }
                }
                // 0x15afc
                v206 = -8;
                memset(v97, 0, 256);
                v195 = *(int32_t *)((int32_t)&g322 + 84);
                if (v195 == 0) {
                    // 0x15e98
                    v196 = function_14434();
                    if (v196 > function_1e19c()) {
                        // 0x15eac
                        v173 = function_14434();
                    } else {
                        // 0x15fd4
                        v173 = function_1e19c();
                    }
                    // 0x15eb8
                    v174 = v173;
                    mem = malloc(4 * v174 | 1);
                    *(int32_t *)((int32_t)&g322 + 84) = (int32_t)mem;
                }
                // 0x15b2c
                v197 = *(int32_t *)((int32_t)&g322 + 88);
                if (v197 == 0) {
                    // 0x15e6c
                    v198 = function_14434();
                    if (v198 > function_1e19c()) {
                        // 0x15e80
                        v171 = function_14434();
                    } else {
                        // 0x15fc4
                        v171 = function_1e19c();
                    }
                    // 0x15e8c
                    v172 = v171;
                    mem2 = malloc(4 * v172 | 1);
                    *(int32_t *)((int32_t)&g322 + 88) = (int32_t)mem2;
                }
                // 0x15b38
                function_11f94(&g326, 0, 256, v197);
                v146 = 0;
                v153 = 256;
                v168 = 0;
                v169 = v168;
                if (v169 == 0) {
                    // 0x160a0
                    v175 = function_1e19c();
                } else {
                    // 0x15b50
                    v154 = v153;
                    v147 = v146;
                    v199 = g322;
                    v148 = v147;
                    v150 = v154;
                    v156 = 0;
                    if (v199 == NULL) {
                        // break -> 0x15c80
                        break;
                    }
                    // 0x15b5c
                    v175 = function_14434();
                }
                // 0x15b60
                v176 = v175;
                v143 = 4 * v169;
                v160 = -1;
                v164 = -1;
                if (v176 >= 1) {
                    // 0x15b68
                    v204 = 6 * v176;
                    v158 = 0;
                    v162 = 0;
                    v166 = 0;
                    v167 = v166;
                    v163 = v162;
                    v159 = v158;
                    v179 = *(int32_t *)((int32_t)&g322 + 8);
                    v180 = *(int32_t *)((int32_t)&g322 + 84);
                    v181 = *(int32_t *)(v179 + v72);
                    v182 = *(int32_t *)(v181 + v143);
                    v183 = *(int16_t *)(v167 + 2 + v182);
                    chars_printed = sprintf((char *)(v180 + v159), "%03d-", (int32_t)v183);
                    v184 = *(int32_t *)((int32_t)&g322 + 8);
                    v185 = chars_printed + v159;
                    v186 = *(int32_t *)((int32_t)&g322 + 88);
                    v187 = *(int32_t *)(v184 + v72);
                    v188 = *(int32_t *)(v187 + v143);
                    v189 = v167 + 6;
                    v190 = *(int16_t *)(v167 + 4 + v188);
                    v192 = sprintf((char *)(v186 + v163), "%03d-", (int32_t)v190) + v163;
                    v158 = v185;
                    v162 = v192;
                    v166 = v189;
                    while (v204 != v189) {
                        // 0x15b88
                        v167 = v166;
                        v163 = v162;
                        v159 = v158;
                        v179 = *(int32_t *)((int32_t)&g322 + 8);
                        v180 = *(int32_t *)((int32_t)&g322 + 84);
                        v181 = *(int32_t *)(v179 + v72);
                        v182 = *(int32_t *)(v181 + v143);
                        v183 = *(int16_t *)(v167 + 2 + v182);
                        chars_printed = sprintf((char *)(v180 + v159), "%03d-", (int32_t)v183);
                        v184 = *(int32_t *)((int32_t)&g322 + 8);
                        v185 = chars_printed + v159;
                        v186 = *(int32_t *)((int32_t)&g322 + 88);
                        v187 = *(int32_t *)(v184 + v72);
                        v188 = *(int32_t *)(v187 + v143);
                        v189 = v167 + 6;
                        v190 = *(int16_t *)(v167 + 4 + v188);
                        v192 = sprintf((char *)(v186 + v163), "%03d-", (int32_t)v190) + v163;
                        v158 = v185;
                        v162 = v192;
                        v166 = v189;
                    }
                    // 0x15be4
                    v160 = v185 - 1;
                    v164 = v192 - 1;
                }
                // 0x15bf0
                v165 = v164;
                v161 = v160;
                v200 = *(int32_t *)((int32_t)&g322 + 88);
                v201 = *(int32_t *)((int32_t)&g322 + 84);
                *(char *)(v200 + v165) = 32;
                *(char *)(v201 + v161) = 32;
                v202 = *(int32_t *)(v143 + v191);
                sprintf((char *)&str, "chain %d %s temp: %s, failure:%s", v80, (char *)v202, (char *)v201, (char *)v200);
                v203 = *(int32_t *)((int32_t)&g322 + 92);
                v144 = v203;
                if (v203 == 0) {
                    // 0x15e4c
                    v177 = function_536f4("bmminer_temp");
                    *(int32_t *)((int32_t)&g322 + 92) = v177;
                    v144 = v177;
                }
                // 0x15c34
                v145 = v144;
                v178 = v169 + 1;
                function_54cb0(v145, "temperature/temperature.c", 25, "dump_temp_info", 14, 539, 20, (int32_t)"%s");
                v146 = (int32_t)"temperature/temperature.c";
                v153 = 25;
                v168 = v178;
                v148 = (int32_t)"temperature/temperature.c";
                v150 = 25;
                v156 = (int32_t)"dump_temp_info";
                while (v178 != 3) {
                    // 0x15b48
                    v169 = v168;
                    if (v169 == 0) {
                        // 0x160a0
                        v175 = function_1e19c();
                    } else {
                        // 0x15b50
                        v154 = v153;
                        v147 = v146;
                        v199 = g322;
                        v148 = v147;
                        v150 = v154;
                        v156 = 0;
                        if (v199 == NULL) {
                            // break -> 0x15c80
                            break;
                        }
                        // 0x15b5c
                        v175 = function_14434();
                    }
                    // 0x15b60
                    v176 = v175;
                    v143 = 4 * v169;
                    v160 = -1;
                    v164 = -1;
                    if (v176 >= 1) {
                        // 0x15b68
                        v204 = 6 * v176;
                        v158 = 0;
                        v162 = 0;
                        v166 = 0;
                        v167 = v166;
                        v163 = v162;
                        v159 = v158;
                        v179 = *(int32_t *)((int32_t)&g322 + 8);
                        v180 = *(int32_t *)((int32_t)&g322 + 84);
                        v181 = *(int32_t *)(v179 + v72);
                        v182 = *(int32_t *)(v181 + v143);
                        v183 = *(int16_t *)(v167 + 2 + v182);
                        chars_printed = sprintf((char *)(v180 + v159), "%03d-", (int32_t)v183);
                        v184 = *(int32_t *)((int32_t)&g322 + 8);
                        v185 = chars_printed + v159;
                        v186 = *(int32_t *)((int32_t)&g322 + 88);
                        v187 = *(int32_t *)(v184 + v72);
                        v188 = *(int32_t *)(v187 + v143);
                        v189 = v167 + 6;
                        v190 = *(int16_t *)(v167 + 4 + v188);
                        v192 = sprintf((char *)(v186 + v163), "%03d-", (int32_t)v190) + v163;
                        v158 = v185;
                        v162 = v192;
                        v166 = v189;
                        while (v204 != v189) {
                            // 0x15b88
                            v167 = v166;
                            v163 = v162;
                            v159 = v158;
                            v179 = *(int32_t *)((int32_t)&g322 + 8);
                            v180 = *(int32_t *)((int32_t)&g322 + 84);
                            v181 = *(int32_t *)(v179 + v72);
                            v182 = *(int32_t *)(v181 + v143);
                            v183 = *(int16_t *)(v167 + 2 + v182);
                            chars_printed = sprintf((char *)(v180 + v159), "%03d-", (int32_t)v183);
                            v184 = *(int32_t *)((int32_t)&g322 + 8);
                            v185 = chars_printed + v159;
                            v186 = *(int32_t *)((int32_t)&g322 + 88);
                            v187 = *(int32_t *)(v184 + v72);
                            v188 = *(int32_t *)(v187 + v143);
                            v189 = v167 + 6;
                            v190 = *(int16_t *)(v167 + 4 + v188);
                            v192 = sprintf((char *)(v186 + v163), "%03d-", (int32_t)v190) + v163;
                            v158 = v185;
                            v162 = v192;
                            v166 = v189;
                        }
                        // 0x15be4
                        v160 = v185 - 1;
                        v164 = v192 - 1;
                    }
                    // 0x15bf0
                    v165 = v164;
                    v161 = v160;
                    v200 = *(int32_t *)((int32_t)&g322 + 88);
                    v201 = *(int32_t *)((int32_t)&g322 + 84);
                    *(char *)(v200 + v165) = 32;
                    *(char *)(v201 + v161) = 32;
                    v202 = *(int32_t *)(v143 + v191);
                    sprintf((char *)&str, "chain %d %s temp: %s, failure:%s", v80, (char *)v202, (char *)v201, (char *)v200);
                    v203 = *(int32_t *)((int32_t)&g322 + 92);
                    v144 = v203;
                    if (v203 == 0) {
                        // 0x15e4c
                        v177 = function_536f4("bmminer_temp");
                        *(int32_t *)((int32_t)&g322 + 92) = v177;
                        v144 = v177;
                    }
                    // 0x15c34
                    v145 = v144;
                    v178 = v169 + 1;
                    function_54cb0(v145, "temperature/temperature.c", 25, "dump_temp_info", 14, 539, 20, (int32_t)"%s");
                    v146 = (int32_t)"temperature/temperature.c";
                    v153 = 25;
                    v168 = v178;
                    v148 = (int32_t)"temperature/temperature.c";
                    v150 = 25;
                    v156 = (int32_t)"dump_temp_info";
                }
                // 0x15c80
                v157 = v156;
                v151 = v150;
                v149 = v148;
                function_11ea4(&g326, v149, v151, v157);
                v141 = v170;
                v142 = v151;
            }
            // 0x15c88
            v207 = v142;
            v132 = v141;
            v208 = v80 + 1;
            v135 = v132;
            v136 = (char *)v208;
            v137 = v207;
        }
        // 0x15c9c
        v127 = function_15508();
        v209 = function_155c4();
        int32_t v210 = 0; // 0x15cb4
        int32_t v211 = 0; // 0x15cb4
        int32_t v212 = 0; // 0x15cb4
        int32_t v213 = v212;
        int32_t v214 = v211;
        int32_t v215 = v210;
        uint32_t v216 = v213 + 1; // 0x15cc4
        int32_t v217 = v214; // 0x15cc8
        int32_t v218 = v213; // 0x15cc8
        int32_t v219; // 0x15ce0
        int32_t v220; // 0x15ce8
        if (function_1e29c(v215) != 0) {
            // 0x15ccc
            v219 = function_157f8(v215, (function_14434() + 255) % 256);
            v220 = function_14434();
            v217 = v219 + v214 + function_157f8(v215, (v220 + 254) % 256);
            v218 = v216 % 256;
        }
        // 0x15d00
        v124 = v218;
        v221 = v217;
        int32_t v222 = v215 + 1; // 0x15d00
        v210 = v222;
        v211 = v221;
        v212 = v124;
        while (v222 != 4) {
            // 0x15cb8
            v213 = v212;
            v214 = v211;
            v215 = v210;
            v216 = v213 + 1;
            v217 = v214;
            v218 = v213;
            if (function_1e29c(v215) != 0) {
                // 0x15ccc
                v219 = function_157f8(v215, (function_14434() + 255) % 256);
                v220 = function_14434();
                v217 = v219 + v214 + function_157f8(v215, (v220 + 254) % 256);
                v218 = v216 % 256;
            }
            // 0x15d00
            v124 = v218;
            v221 = v217;
            v222 = v215 + 1;
            v210 = v222;
            v211 = v221;
            v212 = v124;
        }
        int32_t v223 = function_1e0c0(); // 0x15d0c
        if (function_11eec(v223, "BHB28601", v207, v216) == 0) {
            goto lab_0x15d24;
        } else {
            int32_t v224 = function_1e0c0(); // 0x15ec4
            if (function_11eec(v224, "BHB28501", v207, v216) == 0) {
                goto lab_0x15d24;
            } else {
                int32_t v225 = 2 * v124; // 0x15ee0
                v125 = v225;
                v126 = v225;
                if (v127 > 80) {
                    goto lab_0x15d3c;
                } else {
                    goto lab_0x15ee8;
                }
            }
        }
    }
    goto lab_0x15db8_2;
}

// Address range: 0x16284 - 0x16290
int32_t function_16284(int32_t a1, int32_t a2) {
    // 0x16284
    return function_14d60(a1, 1, a2);
}

// Address range: 0x16290 - 0x1629c
int32_t function_16290(int32_t a1, int32_t a2) {
    // 0x16290
    return function_14d60(a1, 2, a2);
}

// Address range: 0x1629c - 0x162b0
int32_t function_1629c(void) {
    // 0x1629c
    g331 = 1;
    int32_t result; // 0x1629c
    return result;
}

// Address range: 0x162b0 - 0x162c4
int32_t function_162b0(void) {
    // 0x162b0
    g331 = 0;
    int32_t result; // 0x162b0
    return result;
}

// Address range: 0x162c4 - 0x16330
int32_t function_162c4(int32_t a1, int32_t a2) {
    char v1 = a2 == 0 ? 4 : 68; // bp-25, 0x162e0
    if (function_14434() <= 0) {
        // 0x16328
        return 0;
    }
    int32_t v2 = 0;
    int32_t v3 = v2 + 1; // 0x16320
    int32_t v4 = function_1e180(v2); // 0x162ec
    uint32_t v5 = __asm_smulbb(v4, function_1e160()); // 0x162f8
    function_142bc(a1, v5 % 256, 9, 1, &v1);
    int32_t result = v3; // 0x16324
    while (function_14434() > v3) {
        // 0x162ec
        v2 = v3;
        v3 = v2 + 1;
        v4 = function_1e180(v2);
        v5 = __asm_smulbb(v4, function_1e160());
        function_142bc(a1, v5 % 256, 9, 1, &v1);
        result = v3;
    }
    // 0x16328
    return result;
}

// Address range: 0x16330 - 0x16378
int32_t function_16330(int32_t a1) {
    int32_t v1 = 0; // 0x16348
    int32_t v2 = 0; // 0x16348
    int32_t v3 = 0; // 0x16348
    if (function_1e29c(0) == 0) {
        goto lab_0x1634c;
    } else {
        goto lab_0x16368;
    }
  lab_0x1634c:;
    int32_t v4 = v2 + 1; // 0x1634c
    int32_t result = v1; // 0x16354
    if (v4 == 4) {
        // 0x1634c
        return result;
    }
    int32_t v5 = v4;
    int32_t v6 = function_1e29c(v5); // 0x1635c
    v3 = v5;
    while (v6 == 0) {
        int32_t v7 = v5 + 1; // 0x1634c
        if (v7 == 4) {
            // 0x1634c
            return 0;
        }
        v5 = v7;
        v6 = function_1e29c(v5);
        v3 = v5;
    }
    goto lab_0x16368;
  lab_0x16368:
    // 0x16368
    v2 = v3;
    v1 = function_162c4(v2, a1);
    goto lab_0x1634c;
}

// Address range: 0x16378 - 0x16580
int32_t function_16378(void) {
    // 0x16378
    int32_t v1; // 0x16378
    int32_t v2; // 0x16378
    int32_t v3; // 0x16378
    char * str; // bp-2072, 0x16378
    int32_t v4; // 0x16378
    if (g333 == 0) {
        int32_t v5 = function_11eb0(1, 32, v4, 0); // 0x164d4
        g333 = v5;
        if (v5 == 0) {
            char * v6 = g289; // 0x164f0
            if (v6 >= (char *)3 != v6 != (char *)3) {
                // 0x163cc
                return -1;
            }
            // 0x16548
            str = (char *)0x6d206f4e;
            function_2e584(3, (int32_t *)&str, 0);
            v1 = (int32_t)&str;
            v2 = 0;
            v3 = g333;
            goto lab_0x16458;
        } else {
            goto lab_0x16394;
        }
    } else {
        goto lab_0x16394;
    }
  lab_0x16394:;
    int32_t v7 = 0;
    int32_t v8; // 0x163ac
    int32_t * v9; // 0x163b0
    int32_t v10; // 0x163dc
    char * v11; // 0x1650c
    int32_t v12; // 0x163f0
    int32_t v13; // 0x163f4
    int32_t * v14; // 0x163fc
    char * v15; // 0x16420
    int32_t v16; // 0x1639c
    if (function_1e29c(v7) != 0) {
        // 0x163ac
        v16 = 4 * v7;
        v8 = g333;
        v9 = (int32_t *)(v8 + v16);
        if (*v9 == 0) {
            // 0x163d4
            v10 = function_11eb0(1, 72, v4, 0);
            *v9 = v10;
            if (v10 == 0) {
                // 0x16504
                v11 = g289;
                v1 = 72;
                v3 = v8;
                if (v11 == (char *)3 || v11 < (char *)3) {
                    goto lab_0x16458;
                } else {
                    // 0x16518
                    snprintf((char *)&str, 2048, "No memory for configuraion for chain %d.\n", v7);
                    function_2e584(3, (int32_t *)&str, 0);
                    v1 = (int32_t)&str;
                    v2 = 0;
                    v3 = g333;
                    goto lab_0x16458;
                }
            }
            // 0x163f0
            v12 = function_1e0f0();
            v13 = g333;
            v14 = (int32_t *)(v13 + v16);
            *(int32_t *)(*v14 + 63) = function_11eb0(v12, 1, v4, 0);
            if (*(int32_t *)(*v14 + 63) == 0) {
                // 0x16418
                v15 = g289;
                v1 = 1;
                v3 = v13;
                if (v15 == (char *)3 || v15 < (char *)3) {
                    goto lab_0x16458;
                } else {
                    // 0x1642c
                    snprintf((char *)&str, 2048, "No memory for configuraion for chain %d.\n", v7);
                    function_2e584(3, (int32_t *)&str, 0);
                    v1 = (int32_t)&str;
                    v2 = 0;
                    v3 = g333;
                    goto lab_0x16458;
                }
            }
        }
    }
    int32_t v17 = v7 + 1; // 0x163bc
    while (v17 != 4) {
        // 0x16398
        v7 = v17;
        if (function_1e29c(v7) != 0) {
            // 0x163ac
            v16 = 4 * v7;
            v8 = g333;
            v9 = (int32_t *)(v8 + v16);
            if (*v9 == 0) {
                // 0x163d4
                v10 = function_11eb0(1, 72, v4, 0);
                *v9 = v10;
                if (v10 == 0) {
                    // 0x16504
                    v11 = g289;
                    v1 = 72;
                    v3 = v8;
                    if (v11 == (char *)3 || v11 < (char *)3) {
                        goto lab_0x16458;
                    } else {
                        // 0x16518
                        snprintf((char *)&str, 2048, "No memory for configuraion for chain %d.\n", v7);
                        function_2e584(3, (int32_t *)&str, 0);
                        v1 = (int32_t)&str;
                        v2 = 0;
                        v3 = g333;
                        goto lab_0x16458;
                    }
                }
                // 0x163f0
                v12 = function_1e0f0();
                v13 = g333;
                v14 = (int32_t *)(v13 + v16);
                *(int32_t *)(*v14 + 63) = function_11eb0(v12, 1, v4, 0);
                if (*(int32_t *)(*v14 + 63) == 0) {
                    // 0x16418
                    v15 = g289;
                    v1 = 1;
                    v3 = v13;
                    if (v15 == (char *)3 || v15 < (char *)3) {
                        goto lab_0x16458;
                    } else {
                        // 0x1642c
                        snprintf((char *)&str, 2048, "No memory for configuraion for chain %d.\n", v7);
                        function_2e584(3, (int32_t *)&str, 0);
                        v1 = (int32_t)&str;
                        v2 = 0;
                        v3 = g333;
                        goto lab_0x16458;
                    }
                }
            }
        }
        // 0x163bc
        v17 = v7 + 1;
    }
    // 0x163cc
    return 0;
  lab_0x16458:
    // 0x16458
    if (v3 == 0) {
        // 0x163cc
        return -1;
    }
    int32_t v18 = v3 - 4;
    int32_t v19 = v18 + 4; // 0x1646c
    int32_t * v20 = (int32_t *)v19; // 0x1646c
    int32_t v21 = *v20; // 0x1646c
    int32_t v22 = v2; // 0x16474
    int32_t v23 = 0; // 0x16474
    int32_t v24; // 0x16378
    int32_t v25; // 0x16478
    int32_t v26; // 0x16488
    int32_t v27; // 0x1649c
    if (v21 != 0) {
        // 0x16478
        v25 = *(int32_t *)(v21 + 63);
        v27 = v21;
        if (v25 != 0) {
            // 0x16484
            free(v25, v1, v25, v21);
            v26 = *v20;
            *(char *)(v26 + 63) = 0;
            *(char *)(v26 + 64) = 0;
            *(char *)(v26 + 65) = 0;
            *(char *)(v26 + 66) = 0;
            v27 = *v20;
        }
        // 0x164a0
        v24 = v27;
        free(v24, v1, v25, v24);
        *v20 = 0;
        v22 = v25;
        v23 = v24;
    }
    int32_t v28 = v22;
    while (v18 != v3 + 8) {
        // 0x1646c
        v18 = v19;
        v19 = v18 + 4;
        v20 = (int32_t *)v19;
        v21 = *v20;
        v22 = v28;
        v23 = 0;
        if (v21 != 0) {
            // 0x16478
            v25 = *(int32_t *)(v21 + 63);
            v27 = v21;
            if (v25 != 0) {
                // 0x16484
                free(v25, v1, v25, v21);
                v26 = *v20;
                *(char *)(v26 + 63) = 0;
                *(char *)(v26 + 64) = 0;
                *(char *)(v26 + 65) = 0;
                *(char *)(v26 + 66) = 0;
                v27 = *v20;
            }
            // 0x164a0
            v24 = v27;
            free(v24, v1, v25, v24);
            *v20 = 0;
            v22 = v25;
            v23 = v24;
        }
        // 0x164ac
        v28 = v22;
    }
    // 0x164b4
    free(v3, v1, v28, v23);
    g333 = 0;
    // 0x163cc
    return -1;
}

// Address range: 0x16580 - 0x16978
int32_t function_16580(void) {
    int32_t v1 = 0;
    if (function_1e29c(v1) != 0) {
        // 0x1660c
        function_440e8(v1);
        function_304d4(10);
    }
    int32_t v2 = v1 + 1; // 0x165a0
    while (v2 != 4) {
        // 0x16590
        v1 = v2;
        if (function_1e29c(v1) != 0) {
            // 0x1660c
            function_440e8(v1);
            function_304d4(10);
        }
        // 0x165a0
        v2 = v1 + 1;
    }
    // 0x165ac
    memset(&g334, 0, 160);
    int32_t v3; // bp-2340, 0x16580
    int32_t v4 = function_4d6e4("/etc/levels.json", 0, &v3); // 0x165cc
    char * v5; // 0x16580
    char * str; // bp-2088, 0x16580
    int32_t format; // 0x16580
    if (v4 == 0) {
        goto lab_0x165e4;
    } else {
        int32_t * v6 = (int32_t *)v4; // 0x165d8
        if (*v6 == 0) {
            int32_t v7 = function_4e234(v4, "miner"); // 0x16628
            if (v7 == 0) {
                // 0x166a8
                v5 = g289;
                goto lab_0x1664c;
            } else {
                char * v8 = g289; // 0x16640
                v5 = v8;
                if (*(int32_t *)v7 == 2) {
                    int32_t v9 = 2; // 0x166f0
                    if (v8 >= (char *)4 == (v8 != (char *)4)) {
                        int32_t v10 = function_4e768(v7); // 0x16778
                        snprintf((char *)&str, 2048, "miner type in %s is %s", "/etc/levels.json", (char *)v10);
                        function_2e584(4, (int32_t *)&str, 0);
                        v9 = 0;
                    }
                    int32_t v11 = function_4e768(v7); // 0x166f8
                    int32_t str2 = function_11ebc((int32_t *)&g387, v11, v9); // 0x16708
                    if (str2 == 0) {
                        goto lab_0x16730;
                    } else {
                        // 0x16714
                        if (strcasecmp((char *)str2, (char *)function_4e768(v7)) == 0) {
                            int32_t v12 = function_4e234(v4, "levels"); // 0x167bc
                            if (v12 != 0) {
                                // 0x167c8
                                if (*(int32_t *)v12 == 1) {
                                    int32_t v13 = function_4e5a0(v12); // 0x16828
                                    int32_t v14 = 0; // 0x16850
                                    if (v13 == 0 != (v13 == 0)) {
                                        uint32_t v15 = 0;
                                        int32_t v16 = 8 * v15;
                                        int32_t v17 = 1; // 0x16580
                                        int32_t v18 = 0; // 0x16580
                                        int32_t v19; // 0x16580
                                        int32_t v20; // 0x16580
                                        int32_t v21; // 0x16854
                                        int32_t v22; // 0x16858
                                        int32_t v23; // 0x1686c
                                        uint32_t v24; // 0x16828
                                        int32_t v25; // 0x16878
                                        int32_t v26; // 0x16888
                                        int32_t v27; // 0x16898
                                        int32_t v28; // 0x168a4
                                        while (true) {
                                            // 0x16854
                                            v19 = v17;
                                            v21 = function_4e5bc(v12, v18);
                                            v22 = *v6;
                                            v20 = v22;
                                            if (v22 == 0) {
                                                // 0x1686c
                                                v23 = function_4e234(v21, "frequency");
                                                v20 = 0;
                                                if (v23 != 0) {
                                                    // 0x16878
                                                    v25 = *(int32_t *)v23;
                                                    v20 = v25;
                                                    if (v25 == 3) {
                                                        // 0x16884
                                                        v26 = function_4e9c4(v23);
                                                        *(int32_t *)(v16 + (int32_t)&g333 + 8) = v26;
                                                        v27 = function_4e234(v21, "voltage");
                                                        v20 = 0;
                                                        if (v27 != 0) {
                                                            // 0x168a4
                                                            v28 = *(int32_t *)v27;
                                                            v20 = v28;
                                                            if (v28 == 3) {
                                                                // break -> 0x168b0
                                                                break;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            // 0x16824
                                            v24 = function_4e5a0(v12);
                                            v14 = v19;
                                            v17 = v19 + 1;
                                            v18 = v19;
                                            if (v24 >= v19 != v24 != v19 == (v20 == 0 || v24 == v19 || v24 < v19)) {
                                                // break (via goto) -> 0x168d8
                                                goto lab_0x168d8;
                                            }
                                        }
                                        int32_t v29 = function_4e9c4(v27); // 0x168b0
                                        *(int32_t *)(v16 + (int32_t)&g333 + 4) = v29;
                                        uint32_t v30 = function_4e5a0(v12); // 0x16828
                                        v14 = v19;
                                        int32_t v31 = v15 + 1; // 0x16850
                                        while (v15 <= 18 && v30 >= v19 != v30 != v19 != (v30 == v19 || v30 < v19)) {
                                            // 0x16854
                                            v15 = v31;
                                            v16 = 8 * v15;
                                            v17 = v19 + 1;
                                            v18 = v19;
                                            while (true) {
                                                // 0x16854
                                                v19 = v17;
                                                v21 = function_4e5bc(v12, v18);
                                                v22 = *v6;
                                                v20 = v22;
                                                if (v22 == 0) {
                                                    // 0x1686c
                                                    v23 = function_4e234(v21, "frequency");
                                                    v20 = 0;
                                                    if (v23 != 0) {
                                                        // 0x16878
                                                        v25 = *(int32_t *)v23;
                                                        v20 = v25;
                                                        if (v25 == 3) {
                                                            // 0x16884
                                                            v26 = function_4e9c4(v23);
                                                            *(int32_t *)(v16 + (int32_t)&g333 + 8) = v26;
                                                            v27 = function_4e234(v21, "voltage");
                                                            v20 = 0;
                                                            if (v27 != 0) {
                                                                // 0x168a4
                                                                v28 = *(int32_t *)v27;
                                                                v20 = v28;
                                                                if (v28 == 3) {
                                                                    // break -> 0x168b0
                                                                    break;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                // 0x16824
                                                v24 = function_4e5a0(v12);
                                                v14 = v19;
                                                v17 = v19 + 1;
                                                v18 = v19;
                                                if (v24 >= v19 != v24 != v19 == (v20 == 0 || v24 == v19 || v24 < v19)) {
                                                    // break (via goto) -> 0x168d8
                                                    goto lab_0x168d8;
                                                }
                                            }
                                            // 0x168b0
                                            v29 = function_4e9c4(v27);
                                            *(int32_t *)(v16 + (int32_t)&g333 + 4) = v29;
                                            v30 = function_4e5a0(v12);
                                            v14 = v19;
                                            v31 = v15 + 1;
                                        }
                                    }
                                  lab_0x168d8:;
                                    int32_t v32 = 0; // 0x16580
                                    int32_t v33 = 8 * v32; // 0x168d8
                                    int32_t v34 = *(int32_t *)(v33 + (int32_t)&g334); // 0x168d8
                                    int32_t v35 = v32 + 1; // 0x168e0
                                    int32_t v36 = v12; // 0x168ec
                                    int32_t v37 = v14; // 0x168ec
                                    int32_t v38 = 0; // 0x168ec
                                    int32_t v39; // 0x168f0
                                    char * v40; // 0x168fc
                                    if (v34 != 0) {
                                        // 0x168f0
                                        v39 = *(int32_t *)(v33 + (int32_t)&g334 + 4);
                                        v36 = v12;
                                        v37 = v14;
                                        v38 = v34;
                                        if (v39 != 0) {
                                            // 0x168fc
                                            v40 = g289;
                                            v36 = v12;
                                            v37 = (int32_t)v40;
                                            v38 = v34;
                                            if (v40 != (char *)4 && v40 >= (char *)4) {
                                                // 0x16908
                                                snprintf((char *)&str, 2048, "level %d, voltage = %d frequency = %d", v35, v34, v39);
                                                v36 = function_2e584(4, (int32_t *)&str, 0);
                                                v37 = (int32_t)&str;
                                                v38 = 0;
                                            }
                                        }
                                    }
                                    int32_t v41 = v37;
                                    int32_t v42 = v36;
                                    v32 = v35;
                                    while (v35 != 20) {
                                        int32_t v43 = v41;
                                        int32_t v44 = v42;
                                        v33 = 8 * v32;
                                        v34 = *(int32_t *)(v33 + (int32_t)&g334);
                                        v35 = v32 + 1;
                                        v36 = v44;
                                        v37 = v43;
                                        v38 = 0;
                                        if (v34 != 0) {
                                            // 0x168f0
                                            v39 = *(int32_t *)(v33 + (int32_t)&g334 + 4);
                                            v36 = v44;
                                            v37 = v43;
                                            v38 = v34;
                                            if (v39 != 0) {
                                                // 0x168fc
                                                v40 = g289;
                                                v36 = v44;
                                                v37 = (int32_t)v40;
                                                v38 = v34;
                                                if (v40 != (char *)4 && v40 >= (char *)4) {
                                                    // 0x16908
                                                    snprintf((char *)&str, 2048, "level %d, voltage = %d frequency = %d", v35, v34, v39);
                                                    v36 = function_2e584(4, (int32_t *)&str, 0);
                                                    v37 = (int32_t)&str;
                                                    v38 = 0;
                                                }
                                            }
                                        }
                                        // 0x16934
                                        v41 = v37;
                                        v42 = v36;
                                        v32 = v35;
                                    }
                                    int32_t v45 = v4 + 4; // 0x1693c
                                    int32_t * v46 = (int32_t *)v45; // 0x1693c
                                    if (*v46 == -1) {
                                        // 0x165fc
                                        return 0;
                                    }
                                    // 0x16948
                                    __asm_dmb(v42, v41, v38, v45);
                                    int32_t v47 = *v46;
                                    int32_t v48 = v47 - 1; // 0x16954
                                    while (__asm_strex(v48, v47) != 0) {
                                        // 0x16950
                                        v47 = *v46;
                                        v48 = v47 - 1;
                                    }
                                    // 0x16964
                                    if (v48 == 0) {
                                        // 0x1696c
                                        function_4eb6c(v4);
                                    }
                                    // 0x165fc
                                    return 0;
                                }
                            }
                            char * v49 = g289; // 0x167d4
                            format = (int32_t)"failed to get levels in %s\n";
                            if (v49 == (char *)4 || v49 < (char *)4) {
                                // 0x165fc
                                return -2;
                            }
                            goto lab_0x166cc;
                        } else {
                            goto lab_0x16730;
                        }
                    }
                } else {
                    goto lab_0x1664c;
                }
            }
        } else {
            goto lab_0x165e4;
        }
    }
  lab_0x165e4:;
    char * v50 = g289; // 0x165ec
    if (v50 >= (char *)3 == (v50 != (char *)3)) {
        // 0x16668
        snprintf((char *)&str, 2048, "load vol-freq config file %s failed\n", "/etc/levels.json");
        function_2e584(3, (int32_t *)&str, 0);
        return -1;
    }
    // 0x165fc
    return v50 == (char *)3 | v50 < (char *)3 ? -1 : 4;
  lab_0x1664c:;
    char * v51 = v5;
    format = (int32_t)"failed to get miner type in %s\n";
    if (v51 >= (char *)4 != v51 != (char *)4) {
        // 0x165fc
        return -2;
    }
    goto lab_0x166cc;
  lab_0x166cc:
    // 0x166cc
    snprintf((char *)&str, 2048, (char *)format, "/etc/levels.json");
    function_2e584(4, (int32_t *)&str, 0);
    // 0x165fc
    return -2;
  lab_0x16730:;
    char * v52 = g289; // 0x16730
    if (v52 != (char *)3 && v52 >= (char *)3) {
        // 0x16740
        str = (char *)0x656e696d;
        function_2e584(3, (int32_t *)&str, 0);
    }
    // 0x165fc
    return -3;
}

// Address range: 0x1697c - 0x169c0
int32_t function_1697c(int32_t a1) {
    // 0x1697c
    int32_t str; // bp-2056, 0x1697c
    snprintf((char *)&str, 2048, "No chip bin, chain = %d\n", a1);
    function_2e584(3, &str, 0);
    return -1;
}

// Address range: 0x169c0 - 0x16a04
int32_t function_169c0(int32_t a1) {
    // 0x169c0
    int32_t str; // bp-2056, 0x169c0
    snprintf((char *)&str, 2048, "No ft ver, chain = %d\n", a1);
    function_2e584(3, &str, 0);
    return -1;
}

// Address range: 0x16a04 - 0x16bd8
int32_t function_16a04(void) {
    // 0x16a04
    char * str; // bp-2088, 0x16a04
    if (g333 != 0) {
        // 0x16a24
        if (*(char *)(g333 + 28) != 0) {
            int32_t v1 = 0;
            int32_t v2 = 0;
            int32_t v3 = v1; // 0x16a64
            int32_t v4; // bp-2344, 0x16a04
            int32_t v5; // 0x16b0c
            unsigned char v6; // 0x16b14
            int32_t v7; // 0x16b18
            int32_t v8; // 0x16b20
            int32_t v9; // 0x16b34
            int32_t v10; // 0x16b40
            int32_t v11; // 0x16b50
            char * v12; // 0x16b60
            char * v13; // 0x16afc
            int32_t v14; // 0x16b00
            if (function_1e29c(v2) != 0) {
                // 0x16ae8
                memset(&v4, 0, 256);
                v13 = g289;
                v14 = *(int32_t *)(g333 + 4 * v2);
                if (v13 >= (char *)3 == (v13 != (char *)3)) {
                    // 0x16bb0
                    snprintf((char *)&str, 2048, "[chain %d] Update miner info in eeprom.\n", v2);
                    function_2e584(3, (int32_t *)&str, 0);
                }
                // 0x16b0c
                v5 = (int32_t)*(char *)(v14 + 1);
                v6 = *(char *)(v14 + 56);
                v7 = 57 - v5;
                v8 = (int32_t)v6 - v7;
                function_11fc4(&v4, v14 + v5, v6, v8);
                v9 = v8 + 7 & -8;
                v10 = v5 + 5 & 504 | 2;
                function_18e48(v7 + (int32_t)&v4, v9, 1);
                v11 = v9 + v7;
                if (256 - v10 < v11) {
                    // 0x16b60
                    v12 = g289;
                    v3 = -1;
                    if (v12 != (char *)3 && v12 >= (char *)3) {
                        // 0x16b70
                        snprintf((char *)&str, 2048, "[chain %d] Update miner info Failed, EEPROM does not have enough space.\n", v2);
                        function_2e584(3, (int32_t *)&str, 0);
                        v3 = -1;
                    }
                } else {
                    // 0x16b98
                    function_44200(v2, v10 & 250, &v4, v11);
                    v3 = v1;
                }
            }
            int32_t result = v3;
            int32_t v15 = v2 + 1; // 0x16a68
            while (v15 != 4) {
                // 0x16a58
                v1 = result;
                v2 = v15;
                v3 = v1;
                if (function_1e29c(v2) != 0) {
                    // 0x16ae8
                    memset(&v4, 0, 256);
                    v13 = g289;
                    v14 = *(int32_t *)(g333 + 4 * v2);
                    if (v13 >= (char *)3 == (v13 != (char *)3)) {
                        // 0x16bb0
                        snprintf((char *)&str, 2048, "[chain %d] Update miner info in eeprom.\n", v2);
                        function_2e584(3, (int32_t *)&str, 0);
                    }
                    // 0x16b0c
                    v5 = (int32_t)*(char *)(v14 + 1);
                    v6 = *(char *)(v14 + 56);
                    v7 = 57 - v5;
                    v8 = (int32_t)v6 - v7;
                    function_11fc4(&v4, v14 + v5, v6, v8);
                    v9 = v8 + 7 & -8;
                    v10 = v5 + 5 & 504 | 2;
                    function_18e48(v7 + (int32_t)&v4, v9, 1);
                    v11 = v9 + v7;
                    if (256 - v10 < v11) {
                        // 0x16b60
                        v12 = g289;
                        v3 = -1;
                        if (v12 != (char *)3 && v12 >= (char *)3) {
                            // 0x16b70
                            snprintf((char *)&str, 2048, "[chain %d] Update miner info Failed, EEPROM does not have enough space.\n", v2);
                            function_2e584(3, (int32_t *)&str, 0);
                            v3 = -1;
                        }
                    } else {
                        // 0x16b98
                        function_44200(v2, v10 & 250, &v4, v11);
                        v3 = v1;
                    }
                }
                // 0x16a68
                result = v3;
                v15 = v2 + 1;
            }
            // 0x16a74
            return result;
        }
    }
    char * v16 = g289; // 0x16a8c
    if (v16 == (char *)3 || v16 < (char *)3) {
        // 0x16a74
        return -1;
    }
    // 0x16a9c
    str = (char *)0x66206f4e;
    function_2e584(3, (int32_t *)&str, 0);
    return -1;
}

// Address range: 0x16bd8 - 0x17240
int32_t function_16bd8(uint32_t result, int32_t a2, int32_t a3, int32_t a4) {
    char * v1 = g289; // 0x16bec
    if (v1 >= (char *)3 != v1 != (char *)3) {
        // 0x16bf8
        return result;
    }
    // 0x16c04
    int32_t str; // bp-2064, 0x16bd8
    snprintf((char *)&str, 2048, "%-30s : 0x%04x\n", "key_version", result % 16);
    int32_t v2 = function_2e584(3, &str, 0); // 0x16c3c
    char * v3 = g289; // 0x16c40
    int32_t v4 = v2; // 0x16c48
    char * v5 = v3; // 0x16c48
    int32_t v6; // 0x16bd8
    char * v7; // 0x16bd8
    if (v3 == (char *)3 || v3 < (char *)3) {
        goto lab_0x16d44;
    } else {
        // 0x16c4c
        snprintf((char *)&str, 2048, "%-30s : 0x%04x\n", "algorithm_code", (int32_t)((char)v2 / 16));
        int32_t result2 = function_2e584(3, &str, 0); // 0x16c80
        char * v8 = g289; // 0x16c84
        if (v8 == (char *)3 || v8 < (char *)3) {
            // 0x16bf8
            return result2;
        }
        unsigned char v9 = *(char *)(result + 1); // 0x16c90
        snprintf((char *)&str, 2048, "%-30s : 0x%04x\n", "fixture_info_len", (int32_t)v9);
        int32_t v10 = function_2e584(3, &str, 0); // 0x16cc0
        char * v11 = g289; // 0x16cc4
        v6 = v10;
        v7 = v11;
        if (v11 == (char *)3 || v11 < (char *)3) {
            goto lab_0x16dc4;
        } else {
            unsigned char v12 = *(char *)(result + 45); // 0x16cd0
            snprintf((char *)&str, 2048, "%-30s : 0x%04x\n", "fixture_standard", (int32_t)v12);
            int32_t result3 = function_2e584(3, &str, 0); // 0x16d00
            char * v13 = g289; // 0x16d04
            if (v13 == (char *)3 || v13 < (char *)3) {
                // 0x16bf8
                return result3;
            }
            unsigned char v14 = *(char *)(result + 46); // 0x16d10
            snprintf((char *)&str, 2048, "%-30s : 0x%04x\n", "test_standard", (int32_t)v14);
            v4 = function_2e584(3, &str, 0);
            v5 = g289;
            goto lab_0x16d44;
        }
    }
  lab_0x16d44:;
    char * v15 = v5; // 0x16d44
    int32_t result5 = v4; // 0x16d4c
    char * v16 = v15; // 0x16d4c
    if (v15 == (char *)3 || v15 < (char *)3) {
        goto lab_0x16e4c;
    } else {
        int32_t v17 = *(int32_t *)(result + 31); // 0x16d50
        snprintf((char *)&str, 2048, "%-30s : %s\n", "chip_technology", (char *)v17);
        int32_t result4 = function_2e584(3, &str, 0); // 0x16d80
        char * v18 = g289; // 0x16d84
        if (v18 == (char *)3 || v18 < (char *)3) {
            // 0x16bf8
            return result4;
        }
        unsigned char v19 = *(char *)(result + 2); // 0x16d90
        snprintf((char *)&str, 2048, "%-30s : 0x%02x\n", "fixture_fmt_version", (int32_t)v19);
        v6 = function_2e584(3, &str, 0);
        v7 = g289;
        goto lab_0x16dc4;
    }
  lab_0x16e4c:;
    char * v20 = v16; // 0x17084
    if (v20 == (char *)3 || v20 < (char *)3) {
        // 0x16bf8
        return result5;
    }
    unsigned char v21 = *(char *)(result + 30); // 0x16e58
    unsigned char v22 = *(char *)(result + 29); // 0x16e60
    snprintf((char *)&str, 2048, "%-30s : 0x%02x-%02x\n", (char *)&g248, (int32_t)v22, (int32_t)v21);
    int32_t result6 = function_2e584(3, &str, 0); // 0x16e90
    char * v23 = g289; // 0x16e94
    if (v23 == (char *)3 || v23 < (char *)3) {
        // 0x16bf8
        return result6;
    }
    uint16_t v24 = *(int16_t *)(result + 35); // 0x16ea0
    snprintf((char *)&str, 2048, "%-30s : %u\n", "hash_board_voltage", (int32_t)v24);
    int32_t result7 = function_2e584(3, &str, 0); // 0x16ed0
    char * v25 = g289; // 0x16ed0
    goto lab_0x16ed4;
  lab_0x16dc4:;
    char * v29 = v7; // 0x16dc4
    result7 = v6;
    v25 = v29;
    if (v29 == (char *)3 || v29 < (char *)3) {
        goto lab_0x16ed4;
    } else {
        int32_t v30 = *(int32_t *)(result + 3); // 0x16dd0
        snprintf((char *)&str, 2048, "%-30s : %s\n", "SN", (char *)v30);
        int32_t result9 = function_2e584(3, &str, 0); // 0x16e00
        char * v31 = g289; // 0x16e04
        if (v31 == (char *)3 || v31 < (char *)3) {
            // 0x16bf8
            return result9;
        }
        unsigned char v32 = *(char *)(result + 28); // 0x16e10
        unsigned char v33 = *(char *)(result + 27); // 0x16e18
        snprintf((char *)&str, 2048, "%-30s : 0x%02x-%02x\n", (char *)&g246, (int32_t)v33, (int32_t)v32);
        result5 = function_2e584(3, &str, 0);
        v16 = g289;
        goto lab_0x16e4c;
    }
  lab_0x16ed4:;
    char * v26 = v25; // 0x16ed4
    if (v26 == (char *)3 || v26 < (char *)3) {
        // 0x16bf8
        return result7;
    }
    uint16_t v27 = *(int16_t *)(result + 37); // 0x16ee0
    snprintf((char *)&str, 2048, "%-30s : %u\n", "hash_board_freq", (int32_t)v27);
    int32_t result8 = function_2e584(3, &str, 0); // 0x16f10
    char * v28 = g289; // 0x16f14
    if (v28 == (char *)3 || v28 < (char *)3) {
        // 0x16bf8
        return result8;
    }
    // 0x16f20
    __asm_vmov_7(*(int32_t *)(result + 39));
    return &str;
}

// Address range: 0x17240 - 0x17244
int32_t function_17240(void) {
    // 0x17240
    int32_t result; // 0x17240
    return result;
}

// Address range: 0x17244 - 0x1740c
int32_t function_17244(int32_t result, int32_t * a2, uint32_t a3) {
    char * v1 = g289; // 0x17260
    char * str; // bp-2088, 0x17244
    int32_t result2; // 0x173f8
    if (v1 >= (char *)3 == (v1 != (char *)3)) {
        // 0x173d0
        snprintf((char *)&str, 2048, "[chain %d]\n", result);
        result2 = function_2e584(3, (int32_t *)&str, 0);
        if (a3 == 0) {
            goto lab_0x17360_3;
        } else {
            goto lab_0x17274;
        }
    } else {
        // 0x1726c
        if (a3 == 0) {
            // 0x17368
            return result;
        }
        // 0x1726c
        goto lab_0x17274;
    }
  lab_0x1729c:;
    // 0x1729c
    int32_t v2; // 0x17244
    int32_t v3 = v2;
    int32_t v4; // 0x17244
    int32_t v5 = v4;
    int32_t v6 = v5; // 0x172a4
    int32_t v7 = v3; // 0x172a4
    if (v3 >= 3 == (v3 != 3)) {
        goto lab_0x172fc;
    } else {
        goto lab_0x172a8;
    }
  lab_0x172fc:;
    // 0x172fc
    uint32_t v8; // 0x17244
    int32_t v9; // 0x17244
    unsigned char v10 = *(char *)(v8 + v9); // 0x1730c
    char * str2; // 0x17244
    snprintf(str2, 2048, "%02X ", (int32_t)v10);
    int32_t * v11; // 0x17244
    int32_t v12 = function_2ea54(3, v11, 0); // 0x17320
    char * v13 = g289; // 0x17328
    int32_t v14 = (int32_t)v13; // 0x17328
    v6 = v12;
    v7 = v14;
    int32_t v15; // 0x17244
    int32_t v16; // 0x17244
    int32_t v17; // 0x17244
    uint32_t v18; // 0x172b4
    if (v18 == 15) {
        // 0x17330
        v6 = v12;
        v7 = v14;
        if (v13 == (char *)3 || v13 < (char *)3) {
            goto lab_0x172a8;
        } else {
            int32_t v19 = v8 + 1; // 0x17348
            str = (char *)10;
            int32_t v20 = function_2ea54(3, v11, 0); // 0x17350
            char * v21 = g289; // 0x17358
            int32_t v22 = (int32_t)v21; // 0x17358
            v15 = v20;
            v16 = v22;
            v17 = v19;
            if (v19 <= a3 != v19 != a3) {
                // break -> 0x17360
                goto lab_0x17360_3;
            }
            goto lab_0x172b4;
        }
    } else {
        goto lab_0x172a8;
    }
  lab_0x172a8:;
    int32_t v23 = v7;
    int32_t v24 = v6;
    int32_t v25 = v8 + 1; // 0x172a8
    v15 = v24;
    v16 = v23;
    v17 = v25;
    if (v25 == a3 || v25 > a3) {
        // break -> 0x17360
        goto lab_0x17360_3;
    }
    goto lab_0x172b4;
  lab_0x172b4:;
    int32_t v26 = v17;
    int32_t v27 = v16;
    int32_t v28 = v15;
    int32_t v29 = v28; // 0x17244
    int32_t v30 = v27; // 0x17244
    int32_t v31 = v26; // 0x17244
    goto lab_0x172b4_2;
  lab_0x17360_3:;
    uint32_t v38 = (int32_t)g289;
    if (v38 >= 3 == (v38 != 3)) {
        // 0x173ac
        str = (char *)10;
        return function_2ea54(3, (int32_t *)&str, 0);
    }
    // 0x17368
    return result2;
  lab_0x17274:
    // 0x17274
    while (true) {
      lab_0x172b4_2:
        // 0x172b4
        v8 = v31;
        int32_t v32 = v30;
        int32_t v33 = v29;
        v18 = v8 % 16;
        v4 = v33;
        v2 = v32;
        switch ((int4_t)v8) {
            case 0: {
                // 0x17294
                v4 = v33;
                v2 = v32;
                if (v32 >= 3 == (v32 != 3)) {
                    // 0x17374
                    snprintf(str2, 2048, "0x%04X ", v8);
                    int32_t v34 = function_2ea54(3, v11, v18); // 0x17398
                    char * v35 = g289; // 0x173a0
                    v4 = v34;
                    v2 = (int32_t)v35;
                }
                goto lab_0x1729c;
            }
            case -8: {
                // 0x172c4
                v6 = v33;
                v7 = v32;
                if (v32 == 3 || v32 < 3) {
                    goto lab_0x172a8;
                } else {
                    // 0x172cc
                    str = (char *)0x2020;
                    int32_t v36 = function_2ea54(3, v11, 0); // 0x172ec
                    char * v37 = g289; // 0x172f0
                    v6 = v36;
                    v7 = (int32_t)v37;
                    if (v37 == (char *)3 || v37 < (char *)3) {
                        goto lab_0x172a8;
                    } else {
                        goto lab_0x172fc;
                    }
                }
            }
            default: {
                goto lab_0x1729c;
            }
        }
    }
    goto lab_0x17360_3;
}

// Address range: 0x1740c - 0x17ef8
int32_t function_1740c(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x1740c
    int32_t v1; // bp-2856, 0x1740c
    memset(&v1, 0, 256);
    int32_t v2; // bp-2600, 0x1740c
    memset(&v2, 0, 256);
    int32_t v3 = *(int32_t *)(4 * a1 + a2); // 0x1744c
    char v4; // 0x1740c
    unsigned char v5 = v4 - 2;
    uint32_t v6 = (int32_t)v4 + 5 & 504;
    int32_t v7 = v5 >= 253 == (v5 != -3);
    int32_t v8 = 3; // 0x17460
    int32_t v9; // 0x1740c
    int32_t v10; // 0x1740c
    int32_t v11; // 0x1740c
    int32_t v12; // 0x1740c
    int32_t result; // 0x1740c
    int32_t v13; // 0x1740c
    char * str; // bp-2088, 0x1740c
    int32_t v14; // bp-2344, 0x1740c
    int32_t v15; // 0x1740c
    int32_t v16; // 0x1740c
    int32_t v17; // 0x1740c
    int32_t v18; // 0x1740c
    int32_t v19; // 0x1740c
    int32_t v20; // 0x1740c
    int32_t v21; // 0x1740c
    int32_t v22; // 0x1740c
    int32_t v23; // 0x1740c
    int32_t v24; // 0x1740c
    int32_t v25; // 0x1740c
    int32_t v26; // 0x17474
    int32_t v27; // 0x17690
    char * v28; // 0x17694
    while (true) {
      lab_0x17464:
        // 0x17464
        v26 = function_44358(a1, 0, &v1, 256);
        if (v26 != 0) {
            // break -> 0x17ae4
            break;
        }
        // 0x1748c
        v12 = v8;
        function_17244(a1, &v1, 256);
        memset(&v14, 0, 256);
        int32_t v29 = (v6 > 254 ? 1 : v6 < 255 ? 0 : v10) | v7;
        if (v29 == 0) {
            // 0x1750c
            if (v1 % 256 == 17) {
                // 0x17624
                int32_t v30; // bp-2854, 0x1740c
                function_11fc4(&v14, (int32_t)&v30, (char)v6, v6);
                int32_t v31 = &v14; // 0x17644
                function_18e48(v31, v6, 0);
                v2 = 0x10000 * v1 >> 16;
                int32_t v32 = __asm_ubfx(v1 % 0x10000, 4, 4); // 0x17664
                int32_t v33; // bp-2598, 0x1740c
                function_11fc4(&v33, v31, v5, v6);
                char * v34 = (char *)v3; // 0x1766c
                int32_t v35 = __asm_bfi((int32_t)*v34, v32, 4, 4); // 0x17670
                *v34 = (char)v35;
                *v34 = (char)__asm_bfi(v35, v2 % 256, 0, 4);
                uint32_t v36 = v33 % 256; // 0x1768c
                v27 = v36 - 1;
                v28 = (char *)(v3 + 2);
                *v28 = (char)v33;
                v15 = 46;
                v16 = 47;
                v21 = 50;
                v22 = 49;
                v19 = 53;
                v20 = 51;
                v17 = 57;
                v18 = 55;
                v23 = 48;
                v13 = 4;
                v9 = 40;
                v24 = 41;
                v25 = 45;
                if (v27 == 1 || v27 == 0) {
                    goto lab_0x1777c;
                } else {
                    // 0x176a0
                    v15 = 51;
                    v16 = 52;
                    v21 = 55;
                    v22 = 54;
                    v19 = 58;
                    v20 = 56;
                    v17 = 62;
                    v18 = 60;
                    v23 = 53;
                    v13 = 9;
                    v9 = 45;
                    v24 = 46;
                    v25 = 50;
                    if (v36 < 5) {
                        goto lab_0x1777c;
                    } else {
                        char * v37 = g289; // 0x176c0
                        result = -1;
                        if (v37 == (char *)3 || v37 < (char *)3) {
                            return result;
                        } else {
                            // 0x176cc
                            str = (char *)0x73696854;
                            function_2e584(3, (int32_t *)&str, 0);
                            goto lab_0x174f0;
                        }
                    }
                }
            }
            char * v38 = g289; // 0x1752c
            v11 = 0;
            if (v38 == (char *)3 || v38 < (char *)3) {
                goto lab_0x174dc;
            } else {
                // 0x17538
                str = (char *)0x52504545;
                function_2e584(3, (int32_t *)&str, 0);
                goto lab_0x175b4;
            }
        } else {
            char * v39 = g289; // 0x174d0
            v11 = v29;
            if (v39 >= (char *)3 == (v39 != (char *)3)) {
                // 0x17578
                str = (char *)0x52504545;
                function_2e584(3, (int32_t *)&str, 0);
                goto lab_0x175b4;
            } else {
                goto lab_0x174dc;
            }
        }
    }
    char * v40 = g289; // 0x17aec
    result = v26;
    if (v40 != (char *)3 && v40 >= (char *)3) {
        // 0x17af8
        snprintf((char *)&str, 2048, "Read configuration fail for chain %d.\n", a1);
        function_2e584(3, (int32_t *)&str, 0);
        result = v26;
    }
    // 0x174fc
    return result;
  lab_0x174f0:;
    char * v41 = g289;
    result = -1;
    if (v41 >= (char *)3 == (v41 != (char *)3)) {
        // 0x175e8
        snprintf((char *)&str, 2048, "Data load fail for chain %d.\n", a1);
        function_2e584(3, (int32_t *)&str, 0);
        return -1;
    }
    return result;
  lab_0x174dc:
    // 0x174dc
    usleep(0x7a120);
    v8 = v12 - 1;
    v10 = v11;
    if (v12 == 1) {
        goto lab_0x174f0;
    }
    goto lab_0x17464;
  lab_0x175b4:;
    char * v42 = g289; // 0x175b4
    int32_t v43 = (int32_t)v42; // 0x175b4
    v11 = v43;
    if (v42 != (char *)3 && v42 >= (char *)3) {
        // 0x175d0
        snprintf((char *)&str, 2048, "Data decode fail for chain %d.\n", a1);
        function_2e584(3, (int32_t *)&str, 0);
        v11 = v43;
    }
    goto lab_0x174dc;
  lab_0x1777c:;
    int32_t v44 = function_11eb0(18, 1, v27, v23); // 0x17784
    *(int32_t *)(v3 + 3) = v44;
    if (v44 == 0) {
        char * v45 = g289; // 0x17e54
        if (v45 == (char *)3 || v45 < (char *)3) {
            goto lab_0x17798;
        } else {
            // 0x17e64
            str = (char *)0x6f636544;
            function_2e584(3, (int32_t *)&str, 0);
            goto lab_0x17798;
        }
    } else {
        goto lab_0x17798;
    }
  lab_0x17798:;
    // 0x17798
    int32_t v46; // 0x1740c
    int32_t v47 = function_11eb0(3, 1, v46, (int32_t)v4); // 0x177cc
    int32_t * v48 = (int32_t *)(v3 + 7); // 0x177d8
    *v48 = v47;
    int32_t v49 = v47; // 0x177dc
    int32_t v50; // 0x1740c
    if (v47 == 0) {
        char * v51 = g289; // 0x17e00
        v49 = 0;
        if (v51 == (char *)3 || v51 < (char *)3) {
            goto lab_0x177e0;
        } else {
            // 0x17e10
            str = (char *)0x6f636544;
            function_2e584(3, (int32_t *)&str, 0);
            v50 = 0;
            v49 = *v48;
            goto lab_0x177e0;
        }
    } else {
        goto lab_0x177e0;
    }
  lab_0x177e0:
    // 0x177e0
    *(int16_t *)v49 = (int16_t)v46;
    int32_t v52 = function_11eb0(14, 1, v50, v46 % 0x10000); // 0x177f4
    *(int32_t *)(v3 + 11) = v52;
    if (v52 == 0) {
        char * v53 = g289; // 0x17dac
        if (v53 == (char *)3 || v53 < (char *)3) {
            goto lab_0x17808;
        } else {
            // 0x17dbc
            str = (char *)0x6f636544;
            function_2e584(3, (int32_t *)&str, 0);
            goto lab_0x17808;
        }
    } else {
        goto lab_0x17808;
    }
  lab_0x17808:;
    int32_t v54 = v4; // 0x17830
    int32_t v55 = (int32_t)*v28 - 1; // 0x17834
    int32_t v56; // 0x1740c
    int32_t v57; // 0x1740c
    int32_t v58; // 0x1740c
    int32_t str2; // 0x1740c
    int32_t size; // 0x17c04
    if (v55 == 1 || v55 == 0) {
        // 0x17c04
        size = v13 + 6;
        v14 = 0;
        int32_t v59 = function_11eb0(size, 1, v54, size); // 0x17c28
        int32_t * v60 = (int32_t *)(v3 + 16); // 0x17c34
        *v60 = v59;
        v58 = size;
        str2 = v59;
        if (v59 == 0) {
            char * v61 = g289; // 0x17ea8
            v58 = (int32_t)v61;
            str2 = 0;
            if (v61 == (char *)3 || v61 < (char *)3) {
                goto lab_0x17c3c;
            } else {
                // 0x17eb8
                str = (char *)0x6f636544;
                function_2e584(3, (int32_t *)&str, 0);
                v58 = 0x4f206e6f;
                str2 = *v60;
                goto lab_0x17c3c;
            }
        } else {
            goto lab_0x17c3c;
        }
    } else {
        int32_t v62 = function_11eb0(v13 + 1, 1, v54, v55); // 0x1784c
        int32_t * v63 = (int32_t *)(v3 + 16); // 0x17858
        *v63 = v62;
        v57 = v55;
        v56 = v62;
        if (v62 == 0) {
            char * v64 = g289; // 0x17ba0
            v57 = (int32_t)v64;
            v56 = 0;
            if (v64 == (char *)3 || v64 < (char *)3) {
                goto lab_0x17860;
            } else {
                // 0x17bb0
                str = (char *)0x6f636544;
                function_2e584(3, (int32_t *)&str, 0);
                v57 = 0x4f206e6f;
                v56 = *v63;
                goto lab_0x17860;
            }
        } else {
            goto lab_0x17860;
        }
    }
  lab_0x17c3c:;
    // 0x17c3c
    int32_t v65; // bp-2564, 0x1740c
    function_11fc4(&v14, (int32_t)&v65, (char)v13, v58);
    snprintf((char *)str2, size, "F%dV%02dB%dC%d", v14 % 256, (int32_t)v4, (int32_t)v4, (int32_t)v4);
    goto lab_0x17870;
  lab_0x17860:
    // 0x17860
    function_11fc4((int32_t *)v56, (int32_t)&v65, (char)v13, v57);
    goto lab_0x17870;
  lab_0x17870:;
    int32_t v66 = &v2; // 0x17870
    char * v67 = (char *)(v3 + 20); // 0x17874
    char * v68 = (char *)(v9 + v66); // 0x17878
    uint32_t v69 = __asm_bfi((int32_t)*v67, (int32_t)*v68, 0, 7); // 0x17884
    *v67 = (char)v69;
    int32_t v70 = (int32_t)(*v68 >> 7); // 0x17898
    int32_t v71 = __asm_bfi(v69 % 256, v70, 7, 1); // 0x1789c
    *v67 = (char)v71;
    int32_t v72 = function_11eb0(5, 1, v71, v70); // 0x178a4
    int32_t * v73 = (int32_t *)(v3 + 21); // 0x178b0
    *v73 = v72;
    int32_t v74 = v72; // 0x178b4
    if (v72 == 0) {
        char * v75 = g289; // 0x17d58
        if (v75 == (char *)3 || v75 < (char *)3) {
            goto lab_0x178b8;
        } else {
            // 0x17d68
            str = (char *)0x6f636544;
            function_2e584(3, (int32_t *)&str, 0);
            v74 = *v73;
            goto lab_0x178b8;
        }
    } else {
        goto lab_0x178b8;
    }
  lab_0x178b8:;
    // 0x178b8
    int32_t v76; // bp-40, 0x1740c
    int32_t v77 = &v76; // 0x178c0
    int32_t v78 = v77 - 2560;
    *(int32_t *)v74 = *(int32_t *)(v24 + v78);
    char * v79 = (char *)(v25 + v66); // 0x178ec
    char * v80 = (char *)(v3 + 25); // 0x178f4
    uint32_t v81 = __asm_bfi((int32_t)*v80, (int32_t)*v79, 0, 7); // 0x17900
    *v80 = (char)v81;
    *v80 = (char)__asm_bfi(v81 % 256, (int32_t)(*v79 >> 7), 7, 1);
    int32_t v82 = v21 + v77; // 0x17934
    *(char *)(v3 + 26) = *(char *)(v15 + v78);
    *(char *)(v3 + 27) = *(char *)(v16 + v78);
    *(char *)(v3 + 28) = *(char *)(v23 + v78);
    *(char *)(v3 + 29) = *(char *)(v22 + v78);
    unsigned char v83 = *(char *)(v82 - 2560); // 0x17958
    *(char *)(v3 + 30) = v83;
    int32_t v84 = function_11eb0(3, 1, v82, (int32_t)v83); // 0x17960
    int32_t * v85 = (int32_t *)(v3 + 31); // 0x1796c
    *v85 = v84;
    int32_t v86 = v84; // 0x17970
    if (v84 == 0) {
        char * v87 = g289; // 0x17d00
        v86 = 0;
        if (v87 == (char *)3 || v87 < (char *)3) {
            goto lab_0x17974;
        } else {
            // 0x17d10
            str = (char *)0x6f636544;
            function_2e584(3, (int32_t *)&str, 0);
            v86 = *v85;
            goto lab_0x17974;
        }
    } else {
        goto lab_0x17974;
    }
  lab_0x17974:
    // 0x17974
    __asm_vldr(0);
    *(int16_t *)v86 = *(int16_t *)(v20 + v66);
    uint16_t v88 = *(int16_t *)(v19 + v66); // 0x179c8
    *(int16_t *)(v3 + 35) = (int16_t)__asm_rev16((int32_t)v88);
    uint16_t v89 = *(int16_t *)(v18 + v66); // 0x179dc
    *(int16_t *)(v3 + 37) = (int16_t)__asm_rev16((int32_t)v89);
    uint16_t v90 = *(int16_t *)(v17 + v66); // 0x179ec
    __asm_vmov_7(__asm_rev16((int32_t)v90) % 0x10000);
    return 9;
}

// Address range: 0x17ef8 - 0x17f7c
int32_t function_17ef8(void) {
    // 0x17ef8
    if (g333 == 0) {
        int32_t result = function_16378(); // 0x17f6c
        if (result != 0) {
            // 0x17f78
            return result;
        }
    } else {
        // 0x17f10
        if (*(char *)(g333 + 28) != 0) {
            // 0x17f78
            int32_t result2; // 0x17ef8
            return result2;
        }
    }
    // 0x17f1c
    function_16580();
    int32_t v1 = 0;
    int32_t v2 = 0;
    int32_t result3 = 0; // 0x17f34
    int32_t v3 = v1; // 0x17f34
    int32_t v4; // 0x17ef8
    int32_t v5; // 0x17f60
    if (function_1e29c(v2) != 0) {
        // 0x17f58
        v5 = function_1740c(v2, g333, v4, 0, (int32_t)&g488);
        result3 = v5;
        v3 = v5 | v1;
    }
    int32_t v6 = v3;
    int32_t v7 = v2 + 1; // 0x17f38
    while (v7 != 4) {
        // 0x17f28
        v1 = v6;
        v2 = v7;
        result3 = 0;
        v3 = v1;
        if (function_1e29c(v2) != 0) {
            // 0x17f58
            v5 = function_1740c(v2, g333, v4, 0, (int32_t)&g488);
            result3 = v5;
            v3 = v5 | v1;
        }
        // 0x17f38
        v6 = v3;
        v7 = v2 + 1;
    }
    // 0x17f44
    if (v6 == 0) {
        *(char *)(g333 + 28) = 1;
    }
    // 0x17f78
    return result3;
}

// Address range: 0x17f7c - 0x17f90
int32_t function_17f7c(void) {
    // 0x17f7c
    return (int32_t)*(char *)(g333 + 28);
}

// Address range: 0x17f90 - 0x17fd8
int32_t function_17f90(void) {
    int32_t v1 = 0;
    if (function_1e29c(v1) != 0) {
        // 0x17fb0
        if (*(char *)(v1 + 20 + g333) == 0) {
            // break -> 0x17fd0
            break;
        }
    }
    int32_t v2 = v1 + 1; // 0x17fc4
    int32_t result = 1; // 0x17fcc
    while (v2 != 4) {
        // 0x17fa0
        v1 = v2;
        if (function_1e29c(v1) != 0) {
            // 0x17fb0
            result = 0;
            if (*(char *)(v1 + 20 + g333) == 0) {
                // break -> 0x17fd0
                break;
            }
        }
        // 0x17fc4
        v2 = v1 + 1;
        result = 1;
    }
    // 0x17fd0
    return result;
}

// Address range: 0x17fd8 - 0x18094
int32_t function_17fd8(int32_t result, int32_t * str2, uint32_t size) {
    // 0x17fd8
    if (g333 != 0) {
        // 0x17ff4
        if (*(char *)(g333 + 28) != 0) {
            // 0x18000
            if (str2 == NULL) {
                // 0x1802c
                return result;
            }
            char * str = (char *)*(int32_t *)(*(int32_t *)(g333 + 4 * result) + 3); // 0x1801c
            int32_t v1 = strlen(str) + 1; // 0x18020
            int32_t chars_printed = v1; // 0x18028
            if (v1 == size || v1 < size) {
                // 0x18078
                chars_printed = snprintf((char *)str2, size, "%s", str);
            }
            // 0x1802c
            return chars_printed;
        }
    }
    char * v2 = g289; // 0x1803c
    if (v2 == (char *)3 || v2 < (char *)3) {
        // 0x1802c
        return result;
    }
    // 0x18048
    int32_t str3; // bp-2064, 0x17fd8
    snprintf((char *)&str3, 2048, "No hash board sn, chain = %d.\n", result);
    return function_2e584(3, &str3, 0);
}

// Address range: 0x18094 - 0x18128
int32_t function_18094(int32_t a1) {
    // 0x18094
    if (g333 != 0) {
        // 0x180a8
        if (*(char *)(g333 + 28) != 0) {
            int32_t v1 = *(int32_t *)(g333 + 4 * a1); // 0x180d0
            unsigned char v2 = *(char *)(v1 + 28); // 0x180d8
            return 256 * (int32_t)*(char *)(v1 + 27) | (int32_t)v2;
        }
    }
    char * v3 = g289; // 0x180bc
    if (v3 >= (char *)3 != v3 != (char *)3) {
        // 0x180c8
        return 0xffff;
    }
    // 0x180e4
    int32_t str; // bp-2056, 0x18094
    snprintf((char *)&str, 2048, "No pcb version, chain = %d.\n", a1);
    function_2e584(3, &str, 0);
    return 0xffff;
}

// Address range: 0x18128 - 0x181bc
int32_t function_18128(int32_t a1) {
    // 0x18128
    if (g333 != 0) {
        // 0x1813c
        if (*(char *)(g333 + 28) != 0) {
            int32_t v1 = *(int32_t *)(g333 + 4 * a1); // 0x18164
            unsigned char v2 = *(char *)(v1 + 30); // 0x1816c
            return 256 * (int32_t)*(char *)(v1 + 29) | (int32_t)v2;
        }
    }
    char * v3 = g289; // 0x18150
    if (v3 >= (char *)3 != v3 != (char *)3) {
        // 0x1815c
        return 0xffff;
    }
    // 0x18178
    int32_t str; // bp-2056, 0x18128
    snprintf((char *)&str, 2048, "No bom version, chain = %d.\n", a1);
    function_2e584(3, &str, 0);
    return 0xffff;
}

// Address range: 0x181bc - 0x181c4
int32_t function_181bc(void) {
    // 0x181bc
    return 0;
}

// Address range: 0x181c4 - 0x18258
int32_t function_181c4(int32_t a1, int32_t a2) {
    // 0x181c4
    if (g333 != 0) {
        // 0x181d8
        if (*(char *)(g333 + 28) != 0) {
            unsigned char v1 = *(char *)(*(int32_t *)(g333 + 4 * a1) + 43); // 0x18208
            *(int32_t *)a2 = (int32_t)v1;
            return 0;
        }
    }
    char * v2 = g289; // 0x181ec
    if (v2 >= (char *)4 != v2 != (char *)4) {
        // 0x181f8
        return -1;
    }
    // 0x18214
    int32_t str; // bp-2056, 0x181c4
    snprintf((char *)&str, 2048, "No temp, chain = %d.\n", a1);
    function_2e584(4, &str, 0);
    return -1;
}

// Address range: 0x18258 - 0x182fc
int32_t function_18258(int32_t a1, int32_t a2) {
    // 0x18258
    if (g333 != 0) {
        // 0x1826c
        if (*(char *)(g333 + 28) != 0) {
            // 0x18278
            if (a2 == 0) {
                // 0x182a8
                return -2;
            }
            unsigned char v1 = *(char *)(*(int32_t *)(g333 + 4 * a1) + 46); // 0x18288
            *(int32_t *)a2 = (int32_t)v1;
            return 0;
        }
    }
    char * v2 = g289; // 0x1829c
    if (v2 >= (char *)3 != v2 != (char *)3) {
        // 0x182a8
        return -1;
    }
    // 0x182b0
    int32_t str; // bp-2056, 0x18258
    snprintf((char *)&str, 2048, "No test standard, chain = %d.\n", a1);
    function_2e584(3, &str, 0);
    return -1;
}

// Address range: 0x182fc - 0x18360
int32_t function_182fc(int32_t a1, int32_t * a2) {
    // 0x182fc
    if (g333 != 0) {
        // 0x18310
        if (*(char *)(g333 + 28) != 0) {
            // 0x1831c
            if (a2 == NULL) {
                // 0x1834c
                return -2;
            }
            // 0x18324
            *a2 = (int32_t)*(char *)(*(int32_t *)(g333 + 4 * a1) + 15);
            return 0;
        }
    }
    char * v1 = g289; // 0x18340
    if (v1 >= (char *)3 == (v1 != (char *)3)) {
        // 0x18354
        return function_1697c(a1);
    }
    // 0x1834c
    return -1;
}

// Address range: 0x18360 - 0x183fc
int32_t function_18360(int32_t a1, int32_t * str2, uint32_t size) {
    // 0x18360
    if (g333 != 0) {
        // 0x18374
        if (*(char *)(g333 + 28) != 0) {
            // 0x18380
            if (str2 == NULL) {
                // 0x183e0
                return -2;
            }
            char * str = (char *)*(int32_t *)(*(int32_t *)(g333 + 4 * a1) + 16); // 0x183a0
            if (strlen(str) >= size) {
                // 0x183e0
                return -2;
            }
            // 0x183ac
            snprintf((char *)str2, size, "%s", str);
            return 0;
        }
    }
    char * v1 = g289; // 0x183d4
    if (v1 >= (char *)3 == (v1 != (char *)3)) {
        // 0x183e8
        return function_169c0(a1);
    }
    // 0x183e0
    return -1;
}

// Address range: 0x183fc - 0x18654
int32_t function_183fc(int32_t a1, char a2, int32_t a3) {
    // 0x183fc
    char * str; // bp-2088, 0x183fc
    if (g333 != 0) {
        // 0x18420
        if (*(char *)(g333 + 28) != 0) {
            int32_t v1 = &g335;
            int32_t v2 = v1 + 8; // 0x18494
            while (v2 != (int32_t)&g336) {
                // 0x1845c
                v1 = v2;
                v2 = v1 + 8;
            }
            int32_t v3 = *(int32_t *)(v1 - 4); // 0x1845c
            char * v4 = g289; // 0x184a8
            if (v4 >= (char *)4 != v4 != (char *)4) {
                // 0x184b8
                return v4 == (char *)4 | v4 < (char *)4 ? -2 : v3;
            }
            // 0x18518
            str = (char *)0x71657266;
            function_2e584(4, (int32_t *)&str, 0);
            return -2;
        }
    }
    char * v5 = g289; // 0x184cc
    if (v5 == (char *)4 || v5 < (char *)4) {
        // 0x184b8
        return -1;
    }
    // 0x184dc
    snprintf((char *)&str, 2048, "No work mode freq, chain = %d, mode = %d.\n", a1, (int32_t)a2);
    function_2e584(4, (int32_t *)&str, 0);
    return -1;
}

// Address range: 0x18654 - 0x188a0
int32_t function_18654(int32_t a1, int32_t a2, int32_t * a3) {
    // 0x18654
    char * str; // bp-2088, 0x18654
    if (g333 != 0) {
        // 0x18678
        if (*(char *)(g333 + 28) != 0) {
            int32_t v1 = &g335;
            int32_t v2 = v1 + 8; // 0x186ec
            while (v2 != (int32_t)&g336) {
                // 0x186b4
                v1 = v2;
                v2 = v1 + 8;
            }
            int32_t v3 = *(int32_t *)(v1 - 4); // 0x186b4
            char * v4 = g289; // 0x18700
            if (v4 >= (char *)4 != v4 != (char *)4) {
                // 0x18710
                return v4 == (char *)4 | v4 < (char *)4 ? -2 : v3;
            }
            // 0x18770
            str = (char *)0x746c6f76;
            function_2e584(4, (int32_t *)&str, 0);
            return -2;
        }
    }
    char * v5 = g289; // 0x18724
    if (v5 == (char *)4 || v5 < (char *)4) {
        // 0x18710
        return -1;
    }
    // 0x18734
    snprintf((char *)&str, 2048, "No work mode voltage, chain = %d, mode = %d.\n", a1, a2);
    function_2e584(4, (int32_t *)&str, 0);
    return -1;
}

// Address range: 0x188a0 - 0x18948
int32_t function_188a0(int32_t a1, char a2, int32_t * a3) {
    // 0x188a0
    if (g333 != 0) {
        // 0x188b4
        if (*(char *)(g333 + 28) != 0) {
            // 0x188c0
            if (a3 == NULL) {
                // 0x188f0
                return (int32_t)a3;
            }
            // 0x188c8
            *a3 = (int32_t)*(int16_t *)(*(int32_t *)(g333 + 4 * a1) + 60);
            return 0;
        }
    }
    char * v1 = g289; // 0x188e4
    if (v1 >= (char *)3 != v1 != (char *)3) {
        // 0x188f0
        return 0xffff;
    }
    // 0x188f8
    int32_t str; // bp-2056, 0x188a0
    snprintf((char *)&str, 2048, "No work mode hash rate, chain = %d, mode = %d.\n", a1, (int32_t)a2);
    function_2e584(3, &str, 0);
    return 0xffff;
}

// Address range: 0x18948 - 0x18a0c
int32_t function_18948(int32_t a1, int32_t a2, int32_t a3) {
    // 0x18948
    if (g333 != 0) {
        // 0x18968
        if (*(char *)(g333 + 28) != 0) {
            int32_t v1 = *(int32_t *)(g333 + 4 * a1); // 0x18998
            if (v1 != 0) {
                // 0x189a4
                *(int32_t *)(v1 + 58) = a3;
                *(int32_t *)(v1 + 62) = *(int32_t *)(a3 + 4);
                *(char *)(v1 + 66) = *(char *)(a3 + 8);
                return 0;
            }
        }
    }
    char * v2 = g289; // 0x1897c
    int32_t result = v2 == (char *)3 | v2 < (char *)3 ? -1 : a1;
    if (v2 >= (char *)3 != v2 != (char *)3) {
        // 0x1898c
        return result;
    }
    // 0x189d0
    int32_t str; // bp-2056, 0x18948
    snprintf((char *)&str, 2048, "Can't set work mode conf, configuration is not loaded, chain = %d, mode = %d.\n", result, a2);
    function_2e584(3, &str, 0);
    return -1;
}

// Address range: 0x18a0c - 0x18a14
int32_t function_18a0c(void) {
    // 0x18a0c
    return 0;
}

// Address range: 0x18a14 - 0x18b30
int32_t function_18a14(void) {
    // 0x18a14
    int32_t v1; // bp-2320, 0x18a14
    int32_t * set_mem = memset(&v1, 0, 256); // 0x18a2c
    char v2; // 0x18a14
    int32_t v3 = v2; // 0x18a30
    int32_t v4 = 57 - v3; // 0x18a38
    int32_t v5 = v3 + 5 & 504; // 0x18a44
    int32_t v6 = v5 | 2; // 0x18a4c
    uint32_t v7 = ((int32_t)(unsigned char)v2 + 7 - v4 & -8) + v4 + v6; // 0x18a58
    if (v7 >= 257) {
        char * v8 = g289; // 0x18a6c
        if (v8 >= (char *)3 != v8 != (char *)3) {
            // 0x18a78
            return (int32_t)set_mem;
        }
        char * v9 = (char *)0x52504545; // bp-2064, 0x18af8
        return function_2e584(3, (int32_t *)&v9, 0);
    }
    // 0x18a84
    int32_t v10; // bp-2392, 0x18a14
    function_11fc4(&v1, (int32_t)&v10, v2, v7);
    int32_t v11; // bp-2318, 0x18a14
    function_18e48((int32_t)&v11, v5, 1);
    int32_t v12 = 0;
    if (function_1e29c(v12) != 0) {
        // 0x18ad0
        function_44200(v12, 0, &v1, v6);
    }
    int32_t v13 = v12 + 1; // 0x18ab4
    while (v13 != 4) {
        // 0x18aa4
        v12 = v13;
        if (function_1e29c(v12) != 0) {
            // 0x18ad0
            function_44200(v12, 0, &v1, v6);
        }
        // 0x18ab4
        v13 = v12 + 1;
    }
    // 0x18ac0
    return function_17ef8();
}

// Address range: 0x18b30 - 0x18b68
int32_t function_18b30(uint32_t a1) {
    // 0x18b30
    if (g333 == 0) {
        // 0x18b60
        return 0;
    }
    if (a1 >= 4 == (a1 != 4)) {
        // 0x18b60
        return 0;
    }
    // 0x18b4c
    return *(char *)(a1 + 16 + g333) != 0;
}

// Address range: 0x18b68 - 0x18bc0
int32_t function_18b68(int32_t a1) {
    char * v1 = (char *)0x45545858; // bp-2056, 0x18b84
    return function_2e584(3, (int32_t *)&v1, 0);
}

// Address range: 0x18bc0 - 0x18c18
int32_t function_18bc0(int32_t a1) {
    char * v1 = (char *)0x45545858; // bp-2056, 0x18bdc
    return function_2e584(3, (int32_t *)&v1, 0);
}

// Address range: 0x18c18 - 0x18c40
int32_t function_18c18(int32_t result, int32_t a2, int32_t a3) {
    // 0x18c18
    if (a3 < 1) {
        // 0x18c3c
        return result;
    }
    int32_t result2 = 4 * a3 + result; // 0x18c20
    int32_t v1 = result; // 0x18c20
    int32_t * v2 = (int32_t *)v1; // 0x18c24
    *v2 = *v2 ^ a2;
    v1 += 4;
    while (v1 != result2) {
        // 0x18c24
        v2 = (int32_t *)v1;
        *v2 = *v2 ^ a2;
        v1 += 4;
    }
    // 0x18c3c
    return result2;
}

// Address range: 0x18c40 - 0x18ce8
int32_t function_18c40(int32_t a1) {
    if (a1 == 3) {
        char * v1 = g289; // 0x18c88
        if (v1 != (char *)3 && v1 >= (char *)3) {
            char * v2 = (char *)0x2f636e65; // bp-2056, 0x18ca4
            function_2e584(3, (int32_t *)&v2, 0);
        }
    }
    // 0x18c54
    if (g270 == 2) {
        // 0x18cd8
        return 16 * a1 + (int32_t)&g272;
    }
    // 0x18c68
    return g270 == 3 ? 4 * a1 + (int32_t)&g271 : 0;
}

// Address range: 0x18ce8 - 0x18d98
int32_t function_18ce8(int32_t a1, int32_t a2, int32_t a3) {
    int32_t result = function_18c40(a3); // 0x18cf8
    switch (g270) {
        case 2: {
            if (a2 % 8 == 0) {
                // 0x18d78
                return function_18f10(a1, a2 / 8, result);
            }
            char * v1 = g289; // 0x18d64
            if (v1 != (char *)3 && v1 >= (char *)3) {
                // 0x18d70
                return function_18b68(result);
            }
            // .loopexit
            return result;
        }
        case 3: {
            int32_t v2 = a2 < 0 ? a2 + 3 : a2;
            if (v2 < 4) {
                // .loopexit
                return result;
            }
            int32_t v3 = a1; // 0x18d34
            int32_t * v4 = (int32_t *)v3; // 0x18d38
            *v4 = *(int32_t *)result ^ *v4;
            v3 += 4;
            while (v3 != (v2 & -4) + a1) {
                // 0x18d38
                v4 = (int32_t *)v3;
                *v4 = *(int32_t *)result ^ *v4;
                v3 += 4;
            }
            // .loopexit
            return result;
        }
    }
    // .loopexit
    return result;
}

// Address range: 0x18d98 - 0x18e48
int32_t function_18d98(int32_t a1, int32_t a2, int32_t a3) {
    int32_t result = function_18c40(a3); // 0x18da8
    switch (g270) {
        case 2: {
            if (a2 % 8 == 0) {
                // 0x18e28
                return function_19074(a1, a2 / 8, result);
            }
            char * v1 = g289; // 0x18e14
            if (v1 != (char *)3 && v1 >= (char *)3) {
                // 0x18e20
                return function_18bc0(result);
            }
            // .loopexit
            return result;
        }
        case 3: {
            int32_t v2 = a2 < 0 ? a2 + 3 : a2;
            if (v2 < 4) {
                // .loopexit
                return result;
            }
            int32_t v3 = a1; // 0x18de4
            int32_t * v4 = (int32_t *)v3; // 0x18de8
            *v4 = *(int32_t *)result ^ *v4;
            v3 += 4;
            while (v3 != (v2 & -4) + a1) {
                // 0x18de8
                v4 = (int32_t *)v3;
                *v4 = *(int32_t *)result ^ *v4;
                v3 += 4;
            }
            // .loopexit
            return result;
        }
    }
    // .loopexit
    return result;
}

// Address range: 0x18e48 - 0x18ef0
int32_t function_18e48(int32_t result, uint32_t a2, int32_t a3) {
    if (a2 % 4 == 0) {
        if (a3 == 0) {
            // 0x18e88
            return function_18d98(result, a2, 1);
        }
        // 0x18e98
        return function_18ce8(result, a2, 1);
    }
    char * v1 = g289; // 0x18e64
    if (v1 >= (char *)3 != v1 != (char *)3) {
        // 0x18e70
        return result;
    }
    char * v2 = (char *)0x52504545; // bp-2056, 0x18eb8
    return function_2e584(3, (int32_t *)&v2, 0);
}

// Address range: 0x18ef0 - 0x18f00
int32_t function_18ef0(int32_t result) {
    // 0x18ef0
    g270 = result;
    return result;
}

// Address range: 0x18f00 - 0x18f10
int32_t function_18f00(void) {
    // 0x18f00
    return g270;
}

// Address range: 0x18f10 - 0x19074
int32_t function_18f10(int32_t result, int32_t a2, int32_t a3) {
    if (a2 < 2) {
        char * v1 = g289; // 0x19028
        if (v1 == (char *)3 || v1 < (char *)3) {
            // 0x19014
            return result;
        }
        char * v2 = (char *)0x45545858; // bp-2088, 0x19044
        return function_2e584(3, (int32_t *)&v2, 0);
    }
    int32_t * v3 = (int32_t *)(result - 4 + 4 * a2); // 0x18f3c
    int32_t v4 = a2 - 1; // 0x18f40
    int32_t v5 = -0x61c88647 * function_5faf8(); // 0x18f58
    int32_t v6 = 0;
    int32_t v7 = v6 - 0x61c88647; // 0x18f74
    uint32_t v8 = v7 / 4; // 0x18f78
    int32_t v9 = 0; // 0x18f78
    uint32_t v10 = *v3;
    int32_t v11 = result + 4; // 0x18f7c
    uint32_t v12 = *(int32_t *)v11; // 0x18f7c
    int32_t v13 = *(int32_t *)((4 * (v9 ^ v8) & 12) + a3); // 0x18f8c
    v9++;
    uint32_t v14 = v12 ^ v7; // 0x18f94
    int32_t * v15 = (int32_t *)result; // 0x18fac
    int32_t v16 = *v15; // 0x18fac
    int32_t v17 = ((v13 ^ v10) + v14 ^ (4 * v12 ^ v10 / 32) + (v12 / 8 ^ 16 * v10)) + v16; // 0x18fbc
    *v15 = v17;
    int32_t v18; // 0x18f10
    while (v9 != v4) {
        // 0x18f7c
        v18 = v11;
        v10 = v17;
        v11 = v18 + 4;
        v12 = *(int32_t *)v11;
        v13 = *(int32_t *)((4 * (v9 ^ v8) & 12) + a3);
        v9++;
        v14 = v12 ^ v7;
        v15 = (int32_t *)v18;
        v16 = *v15;
        v17 = ((v13 ^ v10) + v14 ^ (4 * v12 ^ v10 / 32) + (v12 / 8 ^ 16 * v10)) + v16;
        *v15 = v17;
    }
    int32_t v19 = *(int32_t *)((4 * (v8 ^ v4) & 12) + a3); // 0x18fd8
    int32_t result2 = 16 * v17 ^ v14 / 8; // 0x18ff0
    int32_t v20 = ((v19 ^ v17) + v12 ^ (v17 / 32 ^ 4 * v14) + result2) + *v3; // 0x19008
    *v3 = v20;
    while (v6 - 0x1715609d != v5) {
        // 0x18f68
        v6 = v7;
        v7 = v6 - 0x61c88647;
        v8 = v7 / 4;
        v9 = 0;
        v10 = v20;
        v11 = result + 4;
        v12 = *(int32_t *)v11;
        v13 = *(int32_t *)((4 * (v9 ^ v8) & 12) + a3);
        v9++;
        v14 = v12 ^ v7;
        v15 = (int32_t *)result;
        v16 = *v15;
        v17 = ((v13 ^ v10) + v14 ^ (4 * v12 ^ v10 / 32) + (v12 / 8 ^ 16 * v10)) + v16;
        *v15 = v17;
        while (v9 != v4) {
            // 0x18f7c
            v18 = v11;
            v10 = v17;
            v11 = v18 + 4;
            v12 = *(int32_t *)v11;
            v13 = *(int32_t *)((4 * (v9 ^ v8) & 12) + a3);
            v9++;
            v14 = v12 ^ v7;
            v15 = (int32_t *)v18;
            v16 = *v15;
            v17 = ((v13 ^ v10) + v14 ^ (4 * v12 ^ v10 / 32) + (v12 / 8 ^ 16 * v10)) + v16;
            *v15 = v17;
        }
        // 0x18fc8
        v19 = *(int32_t *)((4 * (v8 ^ v4) & 12) + a3);
        result2 = 16 * v17 ^ v14 / 8;
        v20 = ((v19 ^ v17) + v12 ^ (v17 / 32 ^ 4 * v14) + result2) + *v3;
        *v3 = v20;
    }
    // 0x19014
    return result2;
}

// Address range: 0x19074 - 0x191dc
int32_t function_19074(int32_t result, int32_t a2, int32_t a3) {
    if (a2 < 2) {
        char * v1 = g289; // 0x19190
        if (v1 == (char *)3 || v1 < (char *)3) {
            // 0x1917c
            return result;
        }
        char * v2 = (char *)0x45545858; // bp-2088, 0x191ac
        return function_2e584(3, (int32_t *)&v2, 0);
    }
    int32_t v3 = function_5faf8(); // 0x19098
    int32_t v4 = result - 4 + 4 * a2; // 0x190d4
    int32_t v5 = -0x61c88647 * v3 - 0x4ab325aa;
    int32_t v6 = a2; // 0x190e4
    uint32_t v7 = v3;
    v6--;
    int32_t v8 = v4 - 4; // 0x190e8
    uint32_t v9 = *(int32_t *)v8; // 0x190e8
    int32_t v10 = *(int32_t *)(((4 * v6 ^ v5) & 12) + a3); // 0x190f8
    int32_t * v11 = (int32_t *)v4; // 0x19114
    int32_t v12 = *v11; // 0x19114
    int32_t v13 = v12 - ((v10 ^ v9) + (v7 ^ v5) ^ (v9 / 32 ^ 4 * v7) + (16 * v9 ^ v7 / 8)); // 0x19124
    *v11 = v13;
    int32_t v14; // 0x19074
    while (v6 != 1) {
        // 0x190e8
        v14 = v8;
        v7 = v13;
        v6--;
        v8 = v14 - 4;
        v9 = *(int32_t *)v8;
        v10 = *(int32_t *)(((4 * v6 ^ v5) & 12) + a3);
        v11 = (int32_t *)v14;
        v12 = *v11;
        v13 = v12 - ((v10 ^ v9) + (v7 ^ v5) ^ (v9 / 32 ^ 4 * v7) + (16 * v9 ^ v7 / 8));
        *v11 = v13;
    }
    uint32_t v15 = *(int32_t *)v4; // 0x19130
    int32_t v16 = *(int32_t *)((v5 & 12) + a3); // 0x19140
    int32_t v17 = 4 * v13; // 0x19144
    int32_t v18 = v5 + 0x61c88647; // 0x1914c
    int32_t result2 = v15 / 32 ^ v17; // 0x19154
    int32_t v19 = v17 - (result2 + (16 * v15 ^ v13 / 8) ^ (v16 ^ v15) + (v13 ^ v5)); // 0x19170
    *(int32_t *)result = v19;
    while (v18 != 0) {
        // 0x190dc
        v5 = v18;
        v6 = a2;
        v7 = v19;
        v6--;
        v8 = v4 - 4;
        v9 = *(int32_t *)v8;
        v10 = *(int32_t *)(((4 * v6 ^ v5) & 12) + a3);
        v11 = (int32_t *)v4;
        v12 = *v11;
        v13 = v12 - ((v10 ^ v9) + (v7 ^ v5) ^ (v9 / 32 ^ 4 * v7) + (16 * v9 ^ v7 / 8));
        *v11 = v13;
        while (v6 != 1) {
            // 0x190e8
            v14 = v8;
            v7 = v13;
            v6--;
            v8 = v14 - 4;
            v9 = *(int32_t *)v8;
            v10 = *(int32_t *)(((4 * v6 ^ v5) & 12) + a3);
            v11 = (int32_t *)v14;
            v12 = *v11;
            v13 = v12 - ((v10 ^ v9) + (v7 ^ v5) ^ (v9 / 32 ^ 4 * v7) + (16 * v9 ^ v7 / 8));
            *v11 = v13;
        }
        // 0x19130
        v15 = *(int32_t *)v4;
        v16 = *(int32_t *)((v5 & 12) + a3);
        v17 = 4 * v13;
        v18 = v5 + 0x61c88647;
        result2 = v15 / 32 ^ v17;
        v19 = v17 - (result2 + (16 * v15 ^ v13 / 8) ^ (v16 ^ v15) + (v13 ^ v5));
        *(int32_t *)result = v19;
    }
    // 0x1917c
    return result2;
}

// Address range: 0x191dc - 0x191f4
int32_t function_191dc(int32_t a1) {
    // 0x191dc
    function_4637c(a1);
    return 0;
}

// Address range: 0x191f4 - 0x191f8
int32_t function_191f4(int32_t a1) {
    // 0x191f4
    return function_4672c(a1);
}

// Address range: 0x191f8 - 0x191fc
int32_t function_191f8(int32_t a1) {
    // 0x191f8
    return function_46900(a1);
}

// Address range: 0x191fc - 0x19214
int32_t function_191fc(int32_t a1) {
    // 0x191fc
    function_46acc(a1);
    return 0;
}

// Address range: 0x19214 - 0x192c8
int32_t function_19214(uint32_t a1) {
    char * v1 = g289; // 0x1922c
    int32_t str; // bp-2064, 0x19214
    if (v1 >= (char *)3 == (v1 != (char *)3)) {
        // 0x1929c
        snprintf((char *)&str, 2048, "chain[%d] PIC jump to app\n", a1);
        function_2e584(3, &str, 0);
    }
    uint32_t v2 = a1 % 256; // 0x19238
    function_46554(v2);
    usleep(0x7a120);
    int32_t v3 = function_46178(v2); // 0x19254
    char * v4 = g289; // 0x19258
    int32_t result = v3; // 0x19260
    if (v4 != (char *)3 && v4 >= (char *)3) {
        // 0x19264
        snprintf((char *)&str, 2048, "Check chain[%d] PIC fw version=0x%02x\n", a1, v3);
        result = function_2e584(3, &str, 0);
    }
    // 0x19290
    return result;
}

// Address range: 0x192c8 - 0x19394
int32_t function_192c8(uint32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x192c8
    float64_t v1; // 0x192c8
    __asm_vpush_16(v1, v1, v1, v1);
    int32_t v2 = 0; // bp-2076, 0x192f4
    int32_t result = function_47158(a1 % 256, &v2, 1); // 0x192f8
    if (result % 256 != 0) {
        // 0x19304
        __asm_vldr_8(v2);
        __asm_vldr(0x66666666);
        __asm_vldr(0);
        return result;
    }
    float64_t v3 = __asm_vldr(0); // 0x19384
    char * v4 = g289; // 0x1938c
    int32_t result2 = result; // 0x1933c
    if (v4 != (char *)4 && v4 >= (char *)4) {
        // 0x19340
        int32_t v5; // 0x192c8
        __asm_vstr(v3, v5);
        int32_t str; // bp-2064, 0x192c8
        snprintf((char *)&str, 2048, "chain = %d, voltage = %f\n");
        result2 = function_2e584(4, &str, 0);
    }
    // 0x1936c
    return result2;
}

// Address range: 0x19394 - 0x193c4
int32_t function_19394(int32_t a1) {
    // 0x19394
    float64_t v1; // 0x19394
    __asm_vstr(v1, a1);
    int32_t str; // bp+24, 0x19394
    int32_t v2; // 0x19394
    snprintf((char *)&str, 2048, "an0 = %f.\n", (float64_t)(int64_t)v2);
    int32_t result = function_2e584(5, &str, v2); // 0x193b8
    __asm_vldr_8(v2);
    return result;
}

// Address range: 0x193c6 - 0x193d2
int32_t function_193c6(void) {
    // 0x193c6
    int32_t result; // 0x193c6
    bool v1; // 0x193c6
    if (v1 == !v1) {
        function_314eae();
        function_2d4c72();
        result = function_294c76();
    }
    // 0x193d2
    return result;
}

// Address range: 0x193d4 - 0x193d8
int32_t function_193d4(void) {
    // 0x193d4
    int32_t result; // 0x193d4
    return result;
}

// Address range: 0x193f4 - 0x19488
int32_t function_193f4(int32_t a1, int32_t a2) {
    // 0x193f4
    float64_t v1; // 0x193f4
    __asm_vpush_11(v1, v1);
    float64_t v2 = __asm_vldr(0); // 0x1940c
    __asm_vldr(-0x66666666);
    int32_t v3 = 0;
    while (function_1e29c(v3) == 0) {
        int32_t v4 = v3 + 1; // 0x19424
        if (v4 == 4) {
            char * v5 = g289; // 0x19438
            if (v5 == (char *)4 || v5 < (char *)4) {
                // 0x1946c
                return 0;
            }
            // 0x19444
            int32_t v6; // 0x193f4
            __asm_vstr(v2, v6);
            int32_t str; // bp-2056, 0x193f4
            snprintf((char *)&str, 2048, "the minimal voltage = %.2f");
            // 0x1946c
            return function_2e584(4, &str, 0);
        }
        v3 = v4;
    }
    int32_t result = function_192c8(v3, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488); // 0x19484
    return result;
}

// Address range: 0x1948a - 0x1948e
int32_t function_1948a(void) {
    // 0x1948a
    return function_454f62();
}

// Address range: 0x1948e - 0x19496
int32_t function_1948e(int32_t a1, uint32_t a2) {
    // 0x1948e
    __asm_cdp(15, 15, 15, 1, 3, 7);
    return a2 / 0x8000;
}

// Address range: 0x19496 - 0x1949e
int32_t function_19496(void) {
    int32_t result = function_454f6e(); // 0x1949a
    bool v1; // 0x19496
    if (v1 == !v1) {
        result = function_1055066();
    }
    // 0x1949e
    return result;
}

// Address range: 0x194a0 - 0x194a4
int32_t function_194a0(void) {
    // 0x194a0
    int32_t result; // 0x194a0
    return result;
}

// Address range: 0x194a6 - 0x194ae
int32_t function_194a6(void) {
    int32_t result = function_454f7e(); // 0x194aa
    bool v1; // 0x194a6
    if (v1 == !v1) {
        result = function_1055076();
    }
    // 0x194ae
    return result;
}

// Address range: 0x194b0 - 0x194b4
int32_t function_194b0(void) {
    // 0x194b0
    int32_t result; // 0x194b0
    return result;
}

// Address range: 0x194b4 - 0x194b8
int32_t function_194b4(void) {
    // 0x194b4
    return function_419af8();
}

// Address range: 0x194c4 - 0x194dc
int32_t function_194c4(void) {
    // 0x194c4
    bool v1; // 0x194c4
    if (!v1) {
        __asm_svclo(0xb99999);
    }
    function_42100();
    return function_12030(1);
}

// Address range: 0x194dc - 0x194f0
int32_t function_194dc(void) {
    // 0x194dc
    function_42138();
    return function_12030(1);
}

// Address range: 0x194f0 - 0x195a8
int32_t function_194f0(void) {
    // 0x194f0
    function_12030(1);
    int32_t v1 = 1; // 0x19504
    int32_t v2; // 0x19524
    while (true) {
        // 0x19508
        v1++;
        function_12030(1);
        if (v1 >= 30) {
            int32_t v3 = function_15508(); // 0x1951c
            v2 = function_1572c();
            int32_t v4 = v3 - v2; // 0x19528
            if (v1 == 180 || (v4 < 0 ? -v4 : v4) < 6) {
                // break -> 0x19544
                break;
            }
        }
    }
    char * v5 = g289; // 0x1954c
    int32_t result = v2; // 0x19554
    if (v5 != (char *)3 && v5 >= (char *)3) {
        int32_t v6 = function_15508(); // 0x19558
        int32_t v7 = v6 - function_1572c(); // 0x19564
        int32_t v8 = v7 < 0 ? -v7 : v7;
        int32_t str; // bp-2064, 0x194f0
        snprintf((char *)&str, 2048, "Slept %d seconds, diff = %d.\n", v1, v8);
        result = function_2e584(3, &str, 0);
    }
    // 0x1959c
    return result;
}

// Address range: 0x195a8 - 0x19604
int32_t function_195a8(int32_t a1) {
    char * v1 = g289; // 0x195c0
    int32_t result = a1; // 0x195c8
    if (v1 != (char *)3 && v1 >= (char *)3) {
        // 0x195cc
        int32_t str; // bp-2064, 0x195a8
        snprintf((char *)&str, 2048, "%s to %d.\n", "set_voltage_by_steps", a1);
        result = function_2e584(3, &str, 0);
    }
    // 0x195fc
    __asm_vmov_7(a1);
    __asm_vldr(0);
    return result;
}

// Address range: 0x19606 - 0x19630
int32_t function_19606(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t result = a1; // 0x19606
    bool v1; // 0x19606
    if (v1) {
        result = function_550ee();
    }
    int32_t v2; // 0x1962a
    if (v1) {
        if ((result & 1 << a4 - 1) == 0) {
            return result;
        }
        // 0x1961a
        v2 = function_d2c3e();
        // 0x1962e
        return function_19b4c(v2);
    }
    if (!v1) {
        return result;
    }
    // 0x1962e
    return function_19b4c(result);
    // 0x1961a
    v2 = function_d2c3e();
    // 0x1962e
    return function_19b4c(v2);
}

// Address range: 0x19630 - 0x19638
int32_t function_19630(int32_t a1, int32_t a2) {
    // 0x19630
    int32_t result; // 0x19630
    return result;
}

// Address range: 0x19638 - 0x19690
int32_t function_19638(int32_t a1, int32_t a2) {
    char * v1 = (char *)0x6d746962; // 0x19658
    function_2e584(3, (int32_t *)&v1, 0);
    return -1;
}

// Address range: 0x19698 - 0x1996c
int32_t function_19698(int32_t a1, int32_t a2, int32_t a3, int32_t * a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9) {
    // 0x19698
    float64_t v1; // 0x19698
    float64_t v2 = __asm_vpush_14(v1, v1, v1); // 0x196a0
    uint32_t v3 = function_48910(); // 0x196b0
    char * v4 = g289; // 0x196b4
    char * str; // bp-2072, 0x19698
    if (v4 >= (char *)3 == (v4 != (char *)3)) {
        // 0x19860
        snprintf((char *)&str, 2048, "power type version: 0x%04x\n", v3);
        function_2e584(3, (int32_t *)&str, 0);
    }
    int32_t v5 = function_1e91c(v3 % 0x10000); // 0x196c8
    char * v6 = g289; // 0x196d0
    if (v5 == 0) {
        // 0x196d8
        if (v6 >= (char *)3 != v6 != (char *)3) {
            // 0x196e4
            __asm_vpop_15(v2, v2, v2);
            return -1;
        }
        // 0x1988c
        str = (char *)0x65776f70;
        function_2e584(3, (int32_t *)&str, 0);
        __asm_vpop_15(v2, v2, v2);
        return -1;
    }
    if (v6 >= (char *)3 == (v6 != (char *)3)) {
        // 0x198d0
        str = (char *)0x65746e45;
        function_2e584(3, (int32_t *)&str, 0);
    }
    // 0x196fc
    function_42138();
    function_12030(1);
    function_194f0();
    int32_t result = function_195a8(a1); // 0x19710
    if (result < 0) {
        char * v7 = g289; // 0x1971c
        if (v7 != (char *)3 && v7 >= (char *)3) {
            // 0x19728
            snprintf((char *)&str, 2048, "%s power iic error.\n", "power_init");
            function_2e584(3, (int32_t *)&str, 0);
        }
        // 0x196e4
        __asm_vpop_15(v2, v2, v2);
        return result;
    }
    // 0x19754
    function_42100();
    uint32_t v8 = v3 - 117; // 0x19758
    int32_t result2 = function_12030(1); // 0x19760
    if (v8 >= 3 == (v8 != 3)) {
        // 0x19908
        __asm_vmov_7(a1);
        return result2;
    }
    // 0x1976c
    __asm_vldr(0);
    __asm_vldr(-0x66666666);
    __asm_vldr(-0x33333333);
    function_12030(1);
    int32_t result3 = function_192c8(0, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488); // 0x19798
    return result3;
}

// Address range: 0x1996e - 0x199ba
int32_t function_1996e(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x1996e
    bool v1; // 0x1996e
    if (v1) {
        function_d5236();
    }
    if (!v1) {
        function_ff052fb2();
    }
    int32_t v2 = function_455456(); // 0x1997a
    int32_t v3; // 0x1996e
    int32_t v4; // 0x1996e
    if (v1 ? v1 : (v4 & 32) != 0) {
        // .critedge.thread
        __asm_subs(v4, 160, 2);
        goto lab_dec_label_pc_0x1998a;
    } else {
        // .critedge
        *(int32_t *)v4 = 0x1997a;
        *(int32_t *)(v4 + 4) = 0x19984;
        __asm_subs(v2 / 8 & v4, 160, 2);
        v3 = v2;
        if ((v2 & 4) == 0) {
            goto lab_dec_label_pc_unknown_2;
        } else {
            goto lab_dec_label_pc_0x1998a;
        }
    }
  lab_dec_label_pc_0x1998a:
    *(int32_t *)v2 = 0x1997a;
    *(int32_t *)(v2 + 4) = 0x19990;
    v3 = v2 - 0x19990;
    goto lab_dec_label_pc_unknown_2;
  lab_dec_label_pc_unknown_2:;
    uint32_t result = v3;
    if (v1) {
        if (!v1) {
            // .thread18.thread
            __asm_rscspl(v4, 160, 6);
        }
    } else {
        int32_t v5 = __asm_rscspl(v4, 160, 6); // 0x19996
        if (!v1 && (result / 128 & result) != 0) {
            *(char *)v4 = (result & 64) == 0 ? 0 : (char)v5;
        }
    }
    if ((result & 64 * a2) != 0) {
        // 0x199ba
        return result;
    }
    *(int16_t *)&g6 = 0;
    return result;
}

// Address range: 0x199bc - 0x199c2
int32_t function_199bc(int32_t a1, int32_t a2) {
    // 0x199bc
    int32_t result; // 0x199bc
    return result;
}

// Address range: 0x199c4 - 0x199c8
int32_t function_199c4(void) {
    // 0x199c4
    return function_19cb8(0);
}

// Address range: 0x199ce - 0x199d0
int32_t function_199ce(void) {
    // 0x199ce
    int32_t result; // 0x199ce
    return result;
}

// Address range: 0x199d0 - 0x199e0
int32_t function_199d0(int32_t a1, int32_t a2) {
    // 0x199d0
    int32_t v1; // 0x199d0
    *(int16_t *)v1 = (int16_t)a2;
    int32_t v2; // bp+16, 0x199d0
    return function_2e584(3, &v2, v1);
}

// Address range: 0x199e0 - 0x199f0
int32_t function_199e0(void) {
    // 0x199e0
    int32_t result; // 0x199e0
    return result;
}

// Address range: 0x199f0 - 0x19a44
int32_t function_199f0(void) {
    // 0x199f0
    int32_t v1; // 0x199f0
    uint32_t v2 = v1;
    int32_t result; // 0x199f0
    if (v2 >= 3 == (v2 != 3)) {
        char * v3 = (char *)0x65776f70; // bp+16, 0x19a18
        result = function_2e584(3, (int32_t *)&v3, 0);
    }
    // 0x199fc
    return result;
}

// Address range: 0x19a44 - 0x19a98
int32_t function_19a44(void) {
    // 0x19a44
    int32_t v1; // 0x19a44
    uint32_t v2 = v1;
    if (v2 != 3 && v2 >= 3) {
        char * v3 = (char *)0x64616572; // bp+16, 0x19a60
        function_2e584(3, (int32_t *)&v3, 0);
    }
    // 0x19a80
    return function_31d58(9, "power voltage read failed, pls check!");
}

// Address range: 0x19ab4 - 0x19ac4
int32_t function_19ab4(void) {
    // 0x19ab4
    return g336;
}

// Address range: 0x19ac4 - 0x19ad4
int32_t function_19ac4(void) {
    int32_t result = function_48f9c(0); // 0x19acc
    __asm_vldr(0);
    return result;
}

// Address range: 0x19ad6 - 0x19ae6
int32_t function_19ad6(int32_t a1, int32_t a2, int32_t a3) {
    // 0x19ad6
    int32_t v1; // 0x19ad6
    bool v2; // 0x19ad6
    if (!v2) {
        v1 = function_ff05535e();
    }
    int32_t result = v1; // 0x19ada
    if (v2) {
        result = function_fe4556d6();
    }
    // 0x19ade
    int32_t v3; // 0x19ad6
    __asm_mrc(0, 0, v3, 7, 0, 0);
    return result;
}

// Address range: 0x19ae6 - 0x19ae8
int32_t function_19ae6(void) {
    // 0x19ae6
    int32_t v1; // 0x19ae6
    return function_1a12a(v1);
}

// Address range: 0x19aec - 0x19b4c
int32_t function_19aec(int32_t a1, int32_t a2) {
    // 0x19aec
    int32_t v1; // bp-2452, 0x19aec
    memset(&v1, 0, 128);
    int32_t v2; // bp-2484, 0x19aec
    memset(&v2, 0, 32);
    int32_t v3 = function_258c8(&v2); // 0x19b28
    int32_t v4 = v3; // 0x19b30
    if (v3 == 0) {
        v4 = function_19ba0((int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488);
    }
    char * v5 = g289; // 0x19b3c
    int32_t result = v4; // 0x19b44
    if (v5 >= (char *)3 == (v5 != (char *)3)) {
        result = function_19b5c((int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488);
    }
    // 0x19b48
    return result;
}

// Address range: 0x19b4c - 0x19b50
int32_t function_19b4c(int32_t a1) {
    // 0x19b4c
    return function_19e92();
}

// Address range: 0x19b50 - 0x19b5c
int32_t function_19b50(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x19b50
    int32_t result; // 0x19b50
    return result;
}

// Address range: 0x19b5c - 0x19ba0
int32_t function_19b5c(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    char * v1 = (char *)0x20746567; // bp+424, 0x19b70
    function_2e584(3, (int32_t *)&v1, 0);
    return -1;
}

// Address range: 0x19ba0 - 0x19cb8
int32_t function_19ba0(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x19ba0
    int32_t v1; // bp+12, 0x19ba0
    int32_t str; // bp+44, 0x19ba0
    int32_t v2; // 0x19ba0
    sprintf((char *)&str, "http://%s:%d/power/%s", (char *)v2, v2, &v1);
    int32_t v3 = function_253a0(&str); // 0x19bc4
    char * v4; // bp+424, 0x19ba0
    if (v3 == 0) {
        // 0x19c48
        v4 = (char *)0x70747468;
        int32_t v5 = function_2e584(3, (int32_t *)&v4, 0); // 0x19c88
        return function_19b4c(v5);
    }
    // 0x19bd0
    int32_t v6; // bp+172, 0x19ba0
    int32_t v7 = &v6; // 0x19bd4
    int32_t v8 = function_4d38c(v3, v2, &v6); // 0x19bd8
    int32_t v9; // 0x19ba0
    int32_t v10; // 0x19ba0
    int32_t v11; // 0x19ba0
    int32_t result; // 0x19ba0
    if (v8 == 0) {
        char * v12 = g289; // 0x19c98
        v10 = v7;
        v11 = (int32_t)v12;
        result = -1;
        if (v12 != (char *)3 && v12 >= (char *)3) {
            // 0x19ca8
            return (int32_t)&v4;
        }
    } else {
        int32_t v13 = function_4e234(v8, "power"); // 0x19bec
        int32_t v14 = v13; // 0x19bf4
        if (v13 == 0) {
            v14 = function_19cec();
        }
        int32_t v15 = function_4e9c4(v14); // 0x19bf8
        int32_t v16 = v8 + 4; // 0x19c00
        int32_t * v17 = (int32_t *)v16; // 0x19c00
        v9 = (int32_t)"power";
        v10 = v7;
        v11 = -1;
        result = v15;
        if (*v17 != -1) {
            // 0x19c0c
            __asm_dmb(v15, (int32_t)"power", v7, v16);
            int32_t v18 = *v17;
            int32_t v19 = v18 - 1; // 0x19c18
            while (__asm_strex(v19, v18) != 0) {
                // 0x19c14
                v18 = *v17;
                v19 = v18 - 1;
            }
            // 0x19c28
            v9 = 0;
            v10 = v19;
            v11 = v16;
            result = v15;
            if (v19 == 0) {
                function_19ce0();
                v9 = 0;
                v10 = 0;
                v11 = v16;
                result = v15;
            }
        }
    }
    // 0x19c30
    free(v3, v9, v10, v11);
    return result;
}

// Address range: 0x19cb8 - 0x19cbc
int32_t function_19cb8(int32_t a1) {
    // 0x19cb8
    return a1 + 172;
}

// Address range: 0x19cbc - 0x19ce0
int32_t function_19cbc(int32_t str, int32_t a2, uint32_t a3) {
    // 0x19cbc
    snprintf((char *)str, 2048, (char *)(a3 % 0x10000 | 0x60000));
    int32_t v1; // bp+424, 0x19cbc
    int32_t v2; // 0x19cbc
    return function_2e584(3, &v1, v2);
}

// Address range: 0x19ce0 - 0x19cec
int32_t function_19ce0(void) {
    // 0x19ce0
    int32_t v1; // 0x19ce0
    return function_4eb6c(v1);
}

// Address range: 0x19cec - 0x19d3c
int32_t function_19cec(void) {
    char * v1 = (char *)0x6a206f6e; // bp+424, 0x19d18
    int32_t v2; // 0x19cec
    return function_2e584(3, (int32_t *)&v1, v2);
}

// Address range: 0x19d3c - 0x19d50
int32_t function_19d3c(int32_t a1, int32_t a2) {
    // 0x19d3c
    return *(int32_t *)(a1 + 4) - *(int32_t *)(a2 + 4);
}

// Address range: 0x19d50 - 0x19d60
int32_t function_19d50(int32_t a1, int32_t a2) {
    // 0x19d50
    return *(int32_t *)(a2 + 4) - *(int32_t *)(a1 + 4);
}

// Address range: 0x19d60 - 0x19d70
int32_t function_19d60(int32_t a1, int32_t a2) {
    // 0x19d60
    return a1 - a2;
}

// Address range: 0x19d70 - 0x19de4
int32_t function_19d70(int32_t a1, int32_t a2, int32_t a3, int32_t * a4) {
    int32_t v1 = function_1e0f0(); // 0x19d84
    int32_t v2 = 0; // 0x19d8c
    int32_t result = v1; // 0x19d8c
    int32_t v3 = 0xffffff; // 0x19d8c
    int32_t v4 = 0; // 0x19d8c
    if (v1 >= 1) {
        // 0x19d90
        result = 4 * v1 + a1;
        int32_t v5 = a1; // 0x19da0
        int32_t v6 = 0; // 0x19da0
        uint32_t v7 = 0xffffff;
        uint32_t v8 = 0;
        uint32_t v9 = *(int32_t *)v5; // 0x19da4
        v5 += 4;
        v6 += v9;
        int32_t v10 = v8 < v9 ? v9 : v8;
        int32_t v11 = v7 < v9 ? v7 : v9;
        v2 = v10;
        v3 = v11;
        v4 = v6;
        while (v5 != result) {
            // 0x19da4
            v7 = v11;
            v8 = v10;
            v9 = *(int32_t *)v5;
            v5 += 4;
            v6 += v9;
            v10 = v8 < v9 ? v9 : v8;
            v11 = v7 < v9 ? v7 : v9;
            v2 = v10;
            v3 = v11;
            v4 = v6;
        }
    }
    // 0x19dc4
    *(int32_t *)a2 = v3;
    *(int32_t *)a3 = v2;
    *a4 = v4;
    return result;
}

// Address range: 0x19de4 - 0x19e68
int32_t function_19de4(int32_t a1) {
    int32_t result = 0; // bp-12, 0x19dfc
    if (g294 != 2) {
        // 0x19e08
        function_188a0(a1, *(char *)&g414, &result);
        return result;
    }
    int32_t v1 = *(int32_t *)(4 * a1 + (int32_t)&g337); // 0x19e30
    int32_t v2 = function_1e0f0(); // 0x19e34
    int32_t v3 = v2 * v1 * function_1e130(); // 0x19e40
    return result + (int32_t)(v3 < 0) + ((int32_t)(0x10624dd3 * (int64_t)v3 / 0x100000000) >> 6);
}

// Address range: 0x19e68 - 0x19e90
int32_t function_19e68(void) {
    // 0x19e68
    int32_t v1; // 0x19e68
    int32_t v2 = function_11eb0(function_1e0f0(), 4, v1, v1); // 0x19e78
    int32_t result = v2; // 0x19e80
    if (v2 == 0) {
        result = function_19f98();
    }
    // 0x19e84
    return result;
}

// Address range: 0x19e92 - 0x19e94
int32_t function_19e92(void) {
    // 0x19e92
    int32_t v1; // 0x19e92
    return function_199bc(v1, v1);
}

// Address range: 0x19e94 - 0x19f00
int32_t function_19e94(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x19e94
    if (a4 == 2) {
        function_19f0c();
    }
    // 0x19ea8
    int32_t v1; // 0x19e94
    int32_t v2 = v1; // 0x19eb8
    if (function_1e29c(v2) != 0) {
        function_19f5c();
    }
    // 0x19eb8
    v2++;
    while (v2 != 4) {
        // 0x19ea8
        if (function_1e29c(v2) != 0) {
            function_19f5c();
        }
        // 0x19eb8
        v2++;
    }
    char * v3 = g289; // 0x19ee4
    int32_t v4; // 0x19e94
    g338 = v4 / 1000;
    if (v3 >= (char *)4 == (v3 != (char *)4)) {
        function_19fe4();
    }
    // 0x19ef8
    return free(v4, 0, (int32_t)v3, a4);
}

// Address range: 0x19f00 - 0x19f0c
int32_t function_19f00(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    // 0x19f00
    int32_t result; // 0x19f00
    return result;
}

// Address range: 0x19f0c - 0x19f18
int32_t function_19f0c(void) {
    // 0x19f0c
    int32_t result; // 0x19f0c
    return result;
}

// Address range: 0x19f1a - 0x19f1c
int32_t function_19f1a(void) {
    // 0x19f1a
    int32_t result; // 0x19f1a
    return result;
}

// Address range: 0x19f1c - 0x19f5c
int32_t function_19f1c(void) {
    // 0x19f1c
    int32_t v1; // 0x19f1c
    if (function_1e29c(v1) == 0) {
        goto lab_0x19f28;
    } else {
        goto lab_0x19f44;
    }
  lab_0x19f28:;
    // 0x19f28
    int32_t v2; // 0x19f1c
    int32_t v3 = v2 + 1; // 0x19f28
    int32_t v4 = function_1e29c(v3); // 0x19f38
    int32_t v5 = v3; // 0x19f40
    int32_t v6 = v3; // 0x19f40
    while (v4 == 0) {
        // 0x19f28
        v3 = v5 + 1;
        v4 = function_1e29c(v3);
        v5 = v3;
        v6 = v3;
    }
    goto lab_0x19f44;
  lab_0x19f44:
    // 0x19f44
    function_1e0f0();
    function_1e130();
    v2 = v6;
    goto lab_0x19f28;
}

// Address range: 0x19f5c - 0x19f98
int32_t function_19f5c(void) {
    // 0x19f5c
    int32_t v1; // 0x19f5c
    function_183fc(v1, (char)v1, v1);
    int32_t v2 = 4 * function_1e0f0() + v1; // 0x19f78
    int32_t v3; // 0x19f5c
    int32_t v4 = v3 + 4; // 0x19f80
    int32_t result = function_1e130(); // 0x19f84
    while (v4 != v2) {
        // 0x19f80
        v4 += 4;
        result = function_1e130();
    }
    // 0x19f94
    return result;
}

// Address range: 0x19f98 - 0x19fe4
int32_t function_19f98(void) {
    char * v1 = g289; // 0x19fa0
    if (v1 == (char *)3 || v1 < (char *)3) {
        function_19f00((int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488);
    }
    char * v2 = (char *)0x6c6c616d; // 0x19fc8
    int32_t v3; // 0x19f98
    function_2e584(3, (int32_t *)&v2, v3);
    int32_t result = function_19f00((int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488); // 0x19fe0
    return result;
}

// Address range: 0x19fe4 - 0x1a014
int32_t function_19fe4(void) {
    // 0x19fe4
    int32_t str; // 0x19fe4
    int32_t v1; // 0x19fe4
    snprintf((char *)&str, 2048, "max_hash_rate = %d\n", v1);
    return function_2e584(4, &str, 0);
}

// Address range: 0x1a014 - 0x1a060
int32_t function_1a014(void) {
    // 0x1a014
    if (g294 == 2) {
        function_1a138();
    }
    int32_t result; // 0x1a014
    for (int32_t i = 0; i < 4; i++) {
        // 0x1a044
        result = 0;
        if (function_1e29c(i) != 0) {
            result = function_1a104();
        }
    }
    // 0x1a060
    return result;
}

// Address range: 0x1a062 - 0x1a064
int32_t function_1a062(void) {
    // 0x1a062
    int32_t result; // 0x1a062
    return result;
}

// Address range: 0x1a064 - 0x1a080
int32_t function_1a064(void) {
    int32_t result = 0; // 0x1a078
    int32_t v1; // 0x1a064
    if (function_1e29c(v1) != 0) {
        result = function_1a0f0();
    }
    // 0x1a07c
    return result;
}

// Address range: 0x1a082 - 0x1a088
int32_t function_1a082(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x1a082
    return result;
}

// Address range: 0x1a088 - 0x1a08c
int32_t function_1a088(int32_t result) {
    // 0x1a088
    return result;
}

// Address range: 0x1a08c - 0x1a0f0
int32_t function_1a08c(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x1a08c
    int32_t v1; // 0x1a08c
    int32_t result = v1 / 1000; // 0x1a0ac
    *(int32_t *)(v1 + 20) = result;
    // 0x1a0e4
    return result;
}

// Address range: 0x1a0f0 - 0x1a104
int32_t function_1a0f0(void) {
    // 0x1a0f0
    function_1e0f0();
    return function_1e130();
}

// Address range: 0x1a104 - 0x1a108
int32_t function_1a104(void) {
    // 0x1a104
    int32_t result; // 0x1a104
    return result;
}

// Address range: 0x1a10a - 0x1a10c
int32_t function_1a10a(int32_t a1) {
    // 0x1a10a
    return function_19cb8(a1);
}

// Address range: 0x1a10c - 0x1a128
int32_t function_1a10c(int32_t a1) {
    // 0x1a10c
    int32_t v1; // 0x1a10c
    return function_183fc(v1, (char)v1, v1);
}

// Address range: 0x1a12a - 0x1a130
int32_t function_1a12a(int32_t a1) {
    // 0x1a12a
    int32_t v1; // 0x1a12a
    return function_1a3de(a1, v1, v1);
}

// Address range: 0x1a130 - 0x1a138
int32_t function_1a130(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x1a130
    return result;
}

// Address range: 0x1a138 - 0x1a18c
int32_t function_1a138(void) {
    int32_t v1 = 0; // 0x1a154
    if (function_1e29c(0) == 0) {
        goto lab_0x1a158;
    } else {
        goto lab_0x1a174;
    }
  lab_0x1a158:;
    int32_t v2 = v1 + 1; // 0x1a158
    if (v2 == 4) {
        function_1a08c((int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488);
    }
    int32_t v3 = function_1e29c(v2); // 0x1a168
    int32_t v4 = v2; // 0x1a170
    v1 = v2;
    while (v3 == 0) {
        // 0x1a158
        v2 = v4 + 1;
        if (v2 == 4) {
            function_1a08c((int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488);
        }
        // 0x1a164
        v3 = function_1e29c(v2);
        v4 = v2;
        v1 = v2;
    }
    goto lab_0x1a174;
  lab_0x1a174:
    // 0x1a174
    function_1e0f0();
    function_1e130();
    goto lab_0x1a158;
}

// Address range: 0x1a18c - 0x1a2d8
int32_t function_1a18c(void) {
    // 0x1a18c
    function_1a014();
    int32_t str = 0x1adb0; // bp-2072, 0x1a1b0
    int32_t v1 = 0x19a28; // bp-2068, 0x1a1b0
    int32_t result2; // 0x1a18c
    int32_t result; // 0x1a18c
    if (function_5faf8() == 0) {
        int32_t v2 = &v1; // 0x1a1d8
        int32_t v3 = *(int32_t *)v2; // 0x1a1dc
        while (function_5faf8() == 0) {
            // 0x1a1f4
            v2 += 4;
            int32_t v4; // bp-2040, 0x1a18c
            if (v2 == (int32_t)&v4) {
                // 0x1a1fc
                result = function_1a014();
                goto lab_0x1a20c;
            }
            v3 = *(int32_t *)v2;
        }
        // 0x1a234
        g340 = v3;
        result = function_1a014();
        result2 = v3;
        if (v3 == 0) {
            goto lab_0x1a20c;
        } else {
            goto lab_0x1a258;
        }
    } else {
        // 0x1a234
        g340 = 0x1adb0;
        function_1a014();
        result2 = 0x1adb0;
        goto lab_0x1a258;
    }
  lab_0x1a20c:;
    char * v5 = g289; // 0x1a214
    if (v5 == (char *)4 || v5 < (char *)4) {
        *(int32_t *)((int32_t)&g337 + 24) = result;
    }
    if (v5 >= (char *)4 != v5 != (char *)4) {
        // 0x1a224
        return result;
    }
    // 0x1a2a0
    snprintf((char *)&str, 2048, "format sale hash failed %d\n", result);
    function_2e584(4, &str, 0);
    result2 = result;
    goto lab_0x1a258;
  lab_0x1a258:;
    char * v6 = g289;
    g340 = result2;
    if (v6 == (char *)4 || v6 < (char *)4) {
        // 0x1a224
        return result2;
    }
    // 0x1a264
    snprintf((char *)&str, 2048, "sale_hash_rate = %d\n", result2);
    function_2e584(4, &str, 0);
    return g340;
}

// Address range: 0x1a2d8 - 0x1a2e0
int32_t function_1a2d8(void) {
    // 0x1a2d8
    return 0;
}

// Address range: 0x1a2e0 - 0x1a308
int32_t function_1a2e0(int32_t a1) {
    int32_t v1 = 4 * a1;
    int32_t v2 = g294 == 2 ? (int32_t)&g337 : v1 + (int32_t)&g337;
    return *(int32_t *)(v2 + (g294 == 2 ? v1 : 28));
}

// Address range: 0x1a308 - 0x1a3dc
int32_t function_1a308(void) {
    // 0x1a308
    int32_t v1; // bp-2084, 0x1a308
    int32_t v2 = function_36538(&v1); // 0x1a318
    if (v2 != 0) {
        function_1a448();
    }
    // 0x1a324
    int32_t v3; // 0x1a370
    if (function_1e29c(v2) != 0) {
        // 0x1a364
        v3 = 1024 * v2 + (int32_t)&g86;
        memset((int32_t *)v3, 0, 1024);
        if (function_183fc(v2, *(char *)&g414, v3) != 0) {
            // 0x1a394
            function_356c4(3, 255);
            function_31d58(12, "Get frequency failed!");
            return -1;
        }
        // 0x1a3c0
        if (function_1e0f0() % 256 != 0) {
            // break -> 0x1a354
            break;
        }
    }
    int32_t v4 = v2 + 1; // 0x1a348
    int32_t result = 0; // 0x1a350
    while (v4 != 4) {
        int32_t v5 = v4;
        if (function_1e29c(v5) != 0) {
            // 0x1a364
            v3 = 1024 * v5 + (int32_t)&g86;
            memset((int32_t *)v3, 0, 1024);
            if (function_183fc(v5, *(char *)&g414, v3) != 0) {
                // 0x1a394
                function_356c4(3, 255);
                function_31d58(12, "Get frequency failed!");
                return -1;
            }
            int32_t v6 = function_1e0f0() % 256; // 0x1a3c4
            result = v6;
            if (v6 != 0) {
                // break -> 0x1a354
                break;
            }
        }
        // 0x1a348
        v4 = v5 + 1;
        result = 0;
    }
    // 0x1a354
    return result;
}

// Address range: 0x1a3de - 0x1a3e4
int32_t function_1a3de(int32_t result, int32_t a2, int32_t a3) {
    // 0x1a3de
    return result;
}

// Address range: 0x1a3e4 - 0x1a448
int32_t function_1a3e4(int32_t a1, uint32_t a2) {
    // 0x1a3e4
    int32_t v1; // 0x1a3e4
    int32_t v2 = 2 * v1; // 0x1a3f0
    uint32_t v3 = *(int32_t *)v2; // 0x1a3fc
    v2 += 4;
    while (v3 == a2 || v3 < a2) {
        // 0x1a3f4
        v3 = *(int32_t *)v2;
        v2 += 4;
    }
    // 0x1a408
    int32_t str; // bp+16, 0x1a3e4
    snprintf((char *)&str, 2048, "Freq(%d) > Max_freq(%d), invalid!\n", v3, a2);
    return function_2e584(3, &str, 0);
}

// Address range: 0x1a448 - 0x1a46c
int32_t function_1a448(void) {
    // 0x1a448
    function_356c4(3, 255);
    function_31d58(12, "Get max freq failed!");
    return -1;
}

// Address range: 0x1a46c - 0x1a470
int32_t function_1a46c(void) {
    // 0x1a46c
    int32_t result; // 0x1a46c
    return result;
}

// Address range: 0x1a470 - 0x1a870
int32_t function_1a470(int32_t result, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x1a470
    float64_t v1; // 0x1a470
    float64_t v2 = __asm_vpush(v1); // 0x1a478
    char * v3 = g289; // 0x1a48c
    float32_t v4; // 0x1a470
    float32_t v5 = __asm_vmov_f32(v4); // 0x1a49c
    if (v3 != (char *)3 && v3 >= (char *)3) {
        // 0x1a4a4
        return result;
    }
    // 0x1a4f4
    function_1f0e0(result, 1, 0, a2);
    int32_t v6 = 0; // bp-2488, 0x1a518
    int32_t base; // bp-2480, 0x1a470
    memset(&base, 0, 392);
    __asm_vmov_f32(v5);
    int32_t v7; // bp-2492, 0x1a470
    function_502c0((int32_t)&v6, &v7, 0);
    int32_t v8 = v6 % 256; // 0x1a53c
    int32_t v9; // 0x1a470
    char * str; // bp-2088, 0x1a470
    char * v10; // 0x1a470
    if (v8 >= 7 == (v8 != 7)) {
        // 0x1a860
        v10 = NULL;
        v9 = (int32_t)g289;
    } else {
        int32_t v11 = v7 % 256; // 0x1a540
        char v12; // 0x1a470
        uint32_t v13 = (int32_t)v12; // 0x1a57c
        uint32_t v14 = v8;
        int32_t v15 = (int32_t)g289;
        char * v16 = NULL;
        int32_t v17; // 0x1a470
        int32_t v18 = v14 == v13 | v14 > v13 ? v13 : v17;
        char * v19 = v16; // 0x1a588
        int32_t v20 = v15; // 0x1a588
        int32_t v21 = v18; // 0x1a588
        int32_t v22; // 0x1a470
        int32_t v23; // 0x1a470
        int32_t v24; // 0x1a470
        int32_t v25; // 0x1a470
        int32_t v26; // 0x1a470
        int32_t v27; // 0x1a470
        int32_t v28; // 0x1a470
        int32_t v29; // 0x1a470
        int32_t v30; // 0x1a470
        int32_t v31; // 0x1a470
        int32_t v32; // 0x1a470
        char * v33; // 0x1a470
        char * v34; // 0x1a470
        char * v35; // 0x1a470
        char v36; // 0x1a470
        int32_t v37; // 0x1a5fc
        int32_t v38; // 0x1a59c
        int32_t v39; // 0x1a5a8
        int32_t v40; // 0x1a470
        int32_t v41; // 0x1a5d0
        uint32_t v42; // 0x1a5d8
        if (v14 <= v13 != v14 != v13) {
            // 0x1a58c
            v36 = v14;
            v30 = v18;
            v22 = v15;
            v33 = v16;
            v34 = v33;
            v26 = v22;
            if (v11 != 0 != v11 != 1) {
                // 0x1a594
                v38 = (int32_t)v33;
                v39 = v30 * v8;
                v40 = 0x1000000 * v30 >> 24;
                v28 = 8 * v38 + (int32_t)&base;
                v32 = v39 * v11;
                v23 = v22;
                *(char *)v28 = v36;
                *(char *)(v28 + 1) = (char)v30;
                *(char *)(v28 + 2) = (char)v11;
                *(int32_t *)(v28 + 4) = v32;
                v24 = v23;
                if (v23 >= 4 == (v23 != 4)) {
                    // 0x1a7c4
                    snprintf((char *)&str, 2048, "post_div1 = %d, post_div2 = %d, user_div = %d, div_ret = %d\n", v8, v40, v11, v32);
                    function_2e584(4, (int32_t *)&str, 0);
                    v24 = (int32_t)g289;
                }
                // 0x1a5d0
                v25 = v24;
                v41 = v11 + 1;
                v42 = v41 % 256;
                v28 += 8;
                v31 = v32 + v39;
                while (v42 == 1 || v42 == 0) {
                    // 0x1a5b8
                    v32 = v31;
                    v29 = v41;
                    v23 = v25;
                    *(char *)v28 = v36;
                    *(char *)(v28 + 1) = (char)v30;
                    *(char *)(v28 + 2) = (char)v29;
                    *(int32_t *)(v28 + 4) = v32;
                    v24 = v23;
                    if (v23 >= 4 == (v23 != 4)) {
                        // 0x1a7c4
                        snprintf((char *)&str, 2048, "post_div1 = %d, post_div2 = %d, user_div = %d, div_ret = %d\n", v8, v40, v29, v32);
                        function_2e584(4, (int32_t *)&str, 0);
                        v24 = (int32_t)g289;
                    }
                    // 0x1a5d0
                    v25 = v24;
                    v41 = v29 + 1;
                    v42 = v41 % 256;
                    v28 += 8;
                    v31 = v32 + v39;
                }
                // 0x1a5e8
                v34 = (char *)((1 - v7) % 256 + 1 + v38);
                v26 = v25;
            }
            // 0x1a5f8
            v27 = v26;
            v35 = v34;
            v37 = (v30 + 1) % 256;
            v19 = v35;
            v20 = v27;
            v21 = v37;
            while (v37 == v14 || v37 < v14) {
                // 0x1a58c
                v30 = v37;
                v22 = v27;
                v33 = v35;
                v34 = v33;
                v26 = v22;
                if (v11 != 0 != v11 != 1) {
                    // 0x1a594
                    v38 = (int32_t)v33;
                    v39 = v30 * v8;
                    v40 = 0x1000000 * v30 >> 24;
                    v28 = 8 * v38 + (int32_t)&base;
                    v32 = v39 * v11;
                    v23 = v22;
                    *(char *)v28 = v36;
                    *(char *)(v28 + 1) = (char)v30;
                    *(char *)(v28 + 2) = (char)v11;
                    *(int32_t *)(v28 + 4) = v32;
                    v24 = v23;
                    if (v23 >= 4 == (v23 != 4)) {
                        // 0x1a7c4
                        snprintf((char *)&str, 2048, "post_div1 = %d, post_div2 = %d, user_div = %d, div_ret = %d\n", v8, v40, v11, v32);
                        function_2e584(4, (int32_t *)&str, 0);
                        v24 = (int32_t)g289;
                    }
                    // 0x1a5d0
                    v25 = v24;
                    v41 = v11 + 1;
                    v42 = v41 % 256;
                    v28 += 8;
                    v31 = v32 + v39;
                    while (v42 == 1 || v42 == 0) {
                        // 0x1a5b8
                        v32 = v31;
                        v29 = v41;
                        v23 = v25;
                        *(char *)v28 = v36;
                        *(char *)(v28 + 1) = (char)v30;
                        *(char *)(v28 + 2) = (char)v29;
                        *(int32_t *)(v28 + 4) = v32;
                        v24 = v23;
                        if (v23 >= 4 == (v23 != 4)) {
                            // 0x1a7c4
                            snprintf((char *)&str, 2048, "post_div1 = %d, post_div2 = %d, user_div = %d, div_ret = %d\n", v8, v40, v29, v32);
                            function_2e584(4, (int32_t *)&str, 0);
                            v24 = (int32_t)g289;
                        }
                        // 0x1a5d0
                        v25 = v24;
                        v41 = v29 + 1;
                        v42 = v41 % 256;
                        v28 += 8;
                        v31 = v32 + v39;
                    }
                    // 0x1a5e8
                    v34 = (char *)((1 - v7) % 256 + 1 + v38);
                    v26 = v25;
                }
                // 0x1a5f8
                v27 = v26;
                v35 = v34;
                v37 = (v30 + 1) % 256;
                v19 = v35;
                v20 = v27;
                v21 = v37;
            }
        }
        int32_t v43 = v20;
        char * v44 = v19;
        int32_t v45 = v8 + 1; // 0x1a60c
        uint32_t v46 = v45 % 256; // 0x1a610
        v10 = v44;
        v9 = v43;
        while (v46 == 7 || v46 < 7) {
            // 0x1a57c
            v14 = v46;
            v15 = v43;
            v16 = v44;
            int32_t v47 = v45;
            v18 = v14 == v13 | v14 > v13 ? v13 : v21;
            v19 = v16;
            v20 = v15;
            v21 = v18;
            if (v14 <= v13 != v14 != v13) {
                // 0x1a58c
                v36 = v14;
                v30 = v18;
                v22 = v15;
                v33 = v16;
                v34 = v33;
                v26 = v22;
                if (v11 != 0 != v11 != 1) {
                    // 0x1a594
                    v38 = (int32_t)v33;
                    v39 = v30 * v47;
                    v40 = 0x1000000 * v30 >> 24;
                    v28 = 8 * v38 + (int32_t)&base;
                    v32 = v39 * v11;
                    v23 = v22;
                    *(char *)v28 = v36;
                    *(char *)(v28 + 1) = (char)v30;
                    *(char *)(v28 + 2) = (char)v11;
                    *(int32_t *)(v28 + 4) = v32;
                    v24 = v23;
                    if (v23 >= 4 == (v23 != 4)) {
                        // 0x1a7c4
                        snprintf((char *)&str, 2048, "post_div1 = %d, post_div2 = %d, user_div = %d, div_ret = %d\n", v47, v40, v11, v32);
                        function_2e584(4, (int32_t *)&str, 0);
                        v24 = (int32_t)g289;
                    }
                    // 0x1a5d0
                    v25 = v24;
                    v41 = v11 + 1;
                    v42 = v41 % 256;
                    v28 += 8;
                    v31 = v32 + v39;
                    while (v42 == 1 || v42 == 0) {
                        // 0x1a5b8
                        v32 = v31;
                        v29 = v41;
                        v23 = v25;
                        *(char *)v28 = v36;
                        *(char *)(v28 + 1) = (char)v30;
                        *(char *)(v28 + 2) = (char)v29;
                        *(int32_t *)(v28 + 4) = v32;
                        v24 = v23;
                        if (v23 >= 4 == (v23 != 4)) {
                            // 0x1a7c4
                            snprintf((char *)&str, 2048, "post_div1 = %d, post_div2 = %d, user_div = %d, div_ret = %d\n", v47, v40, v29, v32);
                            function_2e584(4, (int32_t *)&str, 0);
                            v24 = (int32_t)g289;
                        }
                        // 0x1a5d0
                        v25 = v24;
                        v41 = v29 + 1;
                        v42 = v41 % 256;
                        v28 += 8;
                        v31 = v32 + v39;
                    }
                    // 0x1a5e8
                    v34 = (char *)((1 - v7) % 256 + 1 + v38);
                    v26 = v25;
                }
                // 0x1a5f8
                v27 = v26;
                v35 = v34;
                v37 = (v30 + 1) % 256;
                v19 = v35;
                v20 = v27;
                v21 = v37;
                while (v37 == v14 || v37 < v14) {
                    // 0x1a58c
                    v30 = v37;
                    v22 = v27;
                    v33 = v35;
                    v34 = v33;
                    v26 = v22;
                    if (v11 != 0 != v11 != 1) {
                        // 0x1a594
                        v38 = (int32_t)v33;
                        v39 = v30 * v47;
                        v40 = 0x1000000 * v30 >> 24;
                        v28 = 8 * v38 + (int32_t)&base;
                        v32 = v39 * v11;
                        v23 = v22;
                        *(char *)v28 = v36;
                        *(char *)(v28 + 1) = (char)v30;
                        *(char *)(v28 + 2) = (char)v11;
                        *(int32_t *)(v28 + 4) = v32;
                        v24 = v23;
                        if (v23 >= 4 == (v23 != 4)) {
                            // 0x1a7c4
                            snprintf((char *)&str, 2048, "post_div1 = %d, post_div2 = %d, user_div = %d, div_ret = %d\n", v47, v40, v11, v32);
                            function_2e584(4, (int32_t *)&str, 0);
                            v24 = (int32_t)g289;
                        }
                        // 0x1a5d0
                        v25 = v24;
                        v41 = v11 + 1;
                        v42 = v41 % 256;
                        v28 += 8;
                        v31 = v32 + v39;
                        while (v42 == 1 || v42 == 0) {
                            // 0x1a5b8
                            v32 = v31;
                            v29 = v41;
                            v23 = v25;
                            *(char *)v28 = v36;
                            *(char *)(v28 + 1) = (char)v30;
                            *(char *)(v28 + 2) = (char)v29;
                            *(int32_t *)(v28 + 4) = v32;
                            v24 = v23;
                            if (v23 >= 4 == (v23 != 4)) {
                                // 0x1a7c4
                                snprintf((char *)&str, 2048, "post_div1 = %d, post_div2 = %d, user_div = %d, div_ret = %d\n", v47, v40, v29, v32);
                                function_2e584(4, (int32_t *)&str, 0);
                                v24 = (int32_t)g289;
                            }
                            // 0x1a5d0
                            v25 = v24;
                            v41 = v29 + 1;
                            v42 = v41 % 256;
                            v28 += 8;
                            v31 = v32 + v39;
                        }
                        // 0x1a5e8
                        v34 = (char *)((1 - v7) % 256 + 1 + v38);
                        v26 = v25;
                    }
                    // 0x1a5f8
                    v27 = v26;
                    v35 = v34;
                    v37 = (v30 + 1) % 256;
                    v19 = v35;
                    v20 = v27;
                    v21 = v37;
                }
            }
            // 0x1a608
            v43 = v20;
            v44 = v19;
            v45 = v47 + 1;
            v46 = v45 % 256;
            v10 = v44;
            v9 = v43;
        }
    }
    uint32_t v48 = v9;
    if (v48 >= 4 == (v48 != 4)) {
        // 0x1a810
        str = (char *)10;
        function_2e584(4, (int32_t *)&str, 0);
        char * v49 = g289; // 0x1a830
        if (v49 != (char *)4 && v49 >= (char *)4) {
            // 0x1a83c
            str = (char *)0x74726f73;
            function_2e584(4, (int32_t *)&str, 0);
        }
    }
    int32_t nmemb = (int32_t)v10; // 0x1a628
    qsort(&base, nmemb, 8, (int32_t (*)(int32_t *, int32_t *))0x19d50);
    if (v10 == NULL) {
        // 0x1a800
        __asm_vpop(v2);
        return &g488;
    }
    int32_t v50 = &base; // 0x1a64c
    int32_t v51 = 0; // 0x1a664
    int32_t v52 = v50; // 0x1a664
    while (true) {
        int32_t v53 = v52;
        int32_t v54 = v51;
        char * v55 = g289; // 0x1a678
        if (v55 == (char *)4 || v55 < (char *)4) {
            int32_t v56 = v54 + 1; // 0x1a668
            v51 = v56;
            if (v56 == nmemb) {
                // break -> 0x1a6d8
                break;
            }
        } else {
            int32_t v57 = *(int32_t *)(v53 + 4); // 0x1a684
            unsigned char v58 = *(char *)(v53 | 2); // 0x1a68c
            unsigned char v59 = *(char *)(v53 | 1); // 0x1a694
            int32_t v60 = v54 + 1; // 0x1a698
            char v61 = *(char *)v53; // 0x1a69c
            snprintf((char *)&str, 2048, "[%d] post_div1 = %d, post_div2 = %d, user_div = %d, div_ret = %d\n", v54, (int32_t)v61, (int32_t)v59, (int32_t)v58, v57);
            function_2e584(4, (int32_t *)&str, 0);
            v51 = v60;
            if (v60 == nmemb) {
                // break -> 0x1a6d8
                break;
            }
        }
        // 0x1a678
        v52 = v53 + 8;
    }
    int32_t v62 = v50; // 0x1a704
    int32_t v63 = 0;
    unsigned char v64 = *(char *)(v62 | 2); // 0x1a73c
    unsigned char v65 = *(char *)(v62 | 1); // 0x1a748
    int32_t v66 = (int32_t)*(char *)v62; // 0x1a754
    v6 = v66;
    int32_t v67 = function_1f080(v66, 0); // 0x1a760
    int32_t v68 = v67; // 0x1a770
    char * v69; // 0x1a774
    if (g295 < v67) {
        // 0x1a774
        v69 = g289;
        if (v69 != (char *)3 && v69 >= (char *)3) {
            // 0x1a780
            snprintf((char *)&str, 2048, "[%d] _POSTDIV1 = %d, _POSTDIV2 = %d, USER_DIV = %d, freq = %d\n", v63, 0x1000000 * v6 >> 24, (int32_t)v65, (int32_t)v64, v67);
            function_2e584(3, (int32_t *)&str, 0);
        }
        // 0x1a708
        function_1f164(result, 1, 0, a2, 0x1000000 * v6 >> 24, 0);
        v68 = usleep((int32_t)&g471);
    }
    int32_t v70 = v63 + 1; // 0x1a730
    v62 += 8;
    int32_t result2 = v68; // 0x1a738
    while (v70 != nmemb) {
        // 0x1a73c
        v63 = v70;
        v64 = *(char *)(v62 | 2);
        v65 = *(char *)(v62 | 1);
        v66 = (int32_t)*(char *)v62;
        v6 = v66;
        v67 = function_1f080(v66, 0);
        v68 = v67;
        if (g295 < v67) {
            // 0x1a774
            v69 = g289;
            if (v69 != (char *)3 && v69 >= (char *)3) {
                // 0x1a780
                snprintf((char *)&str, 2048, "[%d] _POSTDIV1 = %d, _POSTDIV2 = %d, USER_DIV = %d, freq = %d\n", v63, 0x1000000 * v6 >> 24, (int32_t)v65, (int32_t)v64, v67);
                function_2e584(3, (int32_t *)&str, 0);
            }
            // 0x1a708
            function_1f164(result, 1, 0, a2, 0x1000000 * v6 >> 24, 0);
            v68 = usleep((int32_t)&g471);
        }
        // 0x1a730
        v70 = v63 + 1;
        v62 += 8;
        result2 = v68;
    }
    // 0x1a800
    __asm_vpop(v2);
    return result2;
}

// Address range: 0x1a870 - 0x1a8a0
int32_t function_1a870(char result, int32_t a2, int32_t a3) {
    // 0x1a870
    float64_t v1; // 0x1a870
    __asm_vpush_11(v1, v1);
    float32_t v2; // 0x1a870
    __asm_vmov_f32(v2);
    return result;
}

// Address range: 0x1a8a0 - 0x1a8ac
int32_t function_1a8a0(int32_t a1) {
    int32_t v1 = (int32_t)*(int16_t *)(a1 + 22); // 0x1a8a0
    __asm_mrc(0, 5, v1, 7, 13, 3);
    return (int32_t)*(int16_t *)(v1 + 16);
}

// Address range: 0x1a8ac - 0x1aaa0
int32_t function_1a8ac(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, uint32_t a6, int32_t a7) {
    // 0x1a8ac
    int32_t v1; // 0x1a8ac
    uint32_t v2 = v1;
    int32_t v3 = a4; // 0x1a8b8
    int32_t v4 = a3; // 0x1a8b8
    int32_t v5 = a2; // 0x1a8b8
    int32_t v6 = 0; // 0x1a8b8
    if (function_1e29c(v1) != 0) {
        // 0x1aa88
        v6 = function_1f0e0(v1, 1, 0, a5);
        v3 = a5;
        v4 = 0;
        v5 = 1;
    }
    int32_t result = v6; // 0x1a8c4
    if (v1 != 3) {
        result = function_1a8ac(v6, v5, v4, v3, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488);
    }
    // 0x1a8c8
    __asm_vldr(0x47ae147b);
    float32_t v7; // 0x1a8ac
    __asm_vadd_f32(__asm_vcvt_f32_u32(__asm_vmov_7(v2 > a6 ? v2 - a6 : a6 - v2)), v7);
    return result;
}

// Address range: 0x1aaa0 - 0x1aaa4
int32_t function_1aaa0(int32_t result) {
    // 0x1aaa0
    int32_t v1; // 0x1aaa0
    *(int16_t *)v1 = (int16_t)result;
    return result;
}

// Address range: 0x1aaa4 - 0x1aaa8
int32_t function_1aaa4(void) {
    // 0x1aaa4
    int32_t result; // 0x1aaa4
    return result;
}

// Address range: 0x1aaa8 - 0x1aaac
int32_t function_1aaa8(int32_t result) {
    // 0x1aaa8
    return result;
}

// Address range: 0x1aaac - 0x1aab0
int32_t function_1aaac(int32_t a1, int32_t result) {
    // 0x1aaac
    return result;
}

// Address range: 0x1aab0 - 0x1aab4
int32_t function_1aab0(void) {
    // 0x1aab0
    return 6;
}

// Address range: 0x1aab4 - 0x1aad8
int32_t function_1aab4(int32_t a1) {
    // 0x1aab4
    float64_t v1; // 0x1aab4
    __asm_vstr(v1, a1);
    int32_t str; // 0x1aab4
    snprintf((char *)str, 2048, (char *)str);
    return function_2e584(4, (int32_t *)str, 0);
}

// Address range: 0x1aae4 - 0x1ab20
int32_t function_1aae4(int32_t a1, int32_t a2, int32_t a3, int32_t a4, uint32_t a5) {
    // 0x1aae4
    float64_t v1; // 0x1aae4
    __asm_vpush_11(v1, v1);
    float32_t v2; // 0x1aae4
    __asm_vmov_f32(v2);
    return a5 % 256;
}

// Address range: 0x1ab20 - 0x1ab30
int32_t function_1ab20(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x1ab20
    __asm_cdp(0, 11, 3, 7, 0, 1);
    return (int32_t)*(int16_t *)(a1 + 22);
}

// Address range: 0x1ab30 - 0x1abcc
int32_t function_1ab30(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x1ab30
    int32_t v1; // 0x1ab30
    uint32_t v2 = v1;
    uint32_t v3 = v1;
    float64_t v4; // 0x1ab30
    __asm_vstr(v4, a4);
    int32_t str; // bp+56, 0x1ab30
    snprintf((char *)&str, 2048, "fixed step chain = %d, freq_start = %d, freq_end = %d, freq_step = %.2f, is_higher_voltage = %s\n");
    function_2e584(4, &str, 0);
    int32_t result = function_1f0e0(v1, 1, 0, v1); // 0x1ab98
    __asm_vldr(0x47ae147b);
    *(int32_t *)((int32_t)&str - 4) = 0;
    float32_t v5; // 0x1ab30
    __asm_vadd_f32(__asm_vcvt_f32_u32(__asm_vmov_7(v2 < v3 ? v3 - v2 : v2 - v3)), v5);
    return result;
}

// Address range: 0x1abce - 0x1abf6
int32_t function_1abce(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x1abce
    int32_t v1; // 0x1abce
    bool v2; // 0x1abce
    if (v2) {
        // 0x1abda
        v1 = function_2564b6();
    } else {
        function_11d66b2();
        function_ff1d65fa();
        v1 = function_2167d2();
    }
    // 0x1abde
    bool v3; // 0x1abce
    bool v4; // 0x1abce
    int32_t v5; // 0x1abce
    int32_t v6; // 0x1abce
    if (v2) {
        v5 = v1;
        v4 = false;
        v3 = true;
        if (v2) {
            goto lab_dec_label_pc_0x1abe6_3;
        } else {
            goto lab_dec_label_pc_unknown_3;
        }
    } else {
        v5 = v1;
        v4 = false;
        v3 = (v6 & 0x4000000) != 0;
        if ((v6 >> 27 & v6) == 0) {
            goto lab_dec_label_pc_0x1abe6_3;
        } else {
            goto lab_dec_label_pc_unknown_3;
        }
    }
  lab_dec_label_pc_0x1abe6_3:
    v5 = v6 * v6;
    v4 = v6 == 0;
    v3 = (1 << a4 - 1 & a4) != 0;
    goto lab_dec_label_pc_unknown_3;
  lab_dec_label_pc_unknown_3:;
    int32_t v7 = v5; // 0x1abea
    if (!v2) {
        v7 = function_fe41d3f2();
    }
    int32_t result = v7; // 0x1abf2
    if (((v6 & 16) != 0 || v3) == !v4) {
        result = function_1a137fe();
    }
    // 0x1abf6
    return result;
}

// Address range: 0x1abf8 - 0x1ad00
int32_t function_1abf8(int32_t a1, int32_t a2, int32_t a3, int32_t a4, uint32_t a5, int32_t a6) {
    // 0x1abf8
    int32_t v1; // 0x1abf8
    uint32_t v2 = v1;
    int32_t v3 = v1;
    float32_t v4 = __asm_vcvt_f32_u32(__asm_vmov_7(v1)); // 0x1ac04
    int32_t v5 = 1; // 0x1ac14
    float32_t v6; // 0x1abf8
    float32_t v7 = __asm_vmul_f32(__asm_vcvt_f32_u32(__asm_vmov_7(v5)), v6); // 0x1ac90
    float32_t v8; // 0x1abf8
    float32_t v9; // 0x1ac18
    float32_t v10; // 0x1ac98
    if (v1 < v1) {
        // 0x1ac18
        v9 = __asm_vadd_f32(v7, v4);
        __asm_vcmp_f32(v9, v6);
        __asm_vmrs(v1, v1);
        v8 = v9;
        if (v1 > v1) {
            v8 = __asm_vmovgt_f32(v6);
        }
    } else {
        // 0x1ac98
        v10 = __asm_vsub_f32(v4, v7);
        __asm_vcmp_f32(v10, v6);
        __asm_vmrs(v1, v1);
        v8 = v10;
    }
    // 0x1ac28
    __asm_vmov_f32(v8);
    int32_t v11; // bp+44, 0x1abf8
    function_502c0(v3, &v11, 0);
    int32_t result2 = function_1f164(v1, 1, 0, v1, v3, *(int32_t *)(v3 + 4)); // 0x1ac60
    while (v2 >= 4 != v2 != 4) {
        // 0x1ac70
        v5++;
        int32_t result = usleep(0x186a0); // 0x1ac74
        if (v5 > a5) {
            // 0x1acdc
            float64_t v12; // 0x1abf8
            __asm_vpop_13(v12, v12);
            return result;
        }
        v7 = __asm_vmul_f32(__asm_vcvt_f32_u32(__asm_vmov_7(v5)), v6);
        if (v1 < v1) {
            // 0x1ac18
            v9 = __asm_vadd_f32(v7, v4);
            __asm_vcmp_f32(v9, v6);
            __asm_vmrs(v1, v1);
            v8 = v9;
            if (v1 > v1) {
                v8 = __asm_vmovgt_f32(v6);
            }
        } else {
            // 0x1ac98
            v10 = __asm_vsub_f32(v4, v7);
            __asm_vcmp_f32(v10, v6);
            __asm_vmrs(v1, v1);
            v8 = v10;
        }
        // 0x1ac28
        __asm_vmov_f32(v8);
        function_502c0(v3, &v11, 0);
        result2 = function_1f164(v1, 1, 0, v1, v3, *(int32_t *)(v3 + 4));
    }
    // 0x1acac
    return result2;
}

// Address range: 0x1ad08 - 0x1b240
int32_t function_1ad08(int32_t * a1, char a2, int32_t a3) {
    // 0x1ad08
    float64_t v1; // 0x1ad08
    float64_t v2 = __asm_vpush_11(v1, v1); // 0x1ad10
    float32_t v3; // 0x1ad08
    float32_t v4 = __asm_vmov_f32(v3); // 0x1ad4c
    int32_t v5 = 0; // bp-6248, 0x1ad50
    int32_t v6; // bp-4136, 0x1ad08
    memset(&v6, 0, 0x1000);
    int32_t v7 = 0; // bp-6216, 0x1ad5c
    int32_t base = 0; // bp-6200, 0x1ad60
    int32_t v8 = -1; // bp-6232, 0x1ad78
    int32_t v9 = &v7;
    int32_t v10 = &v8;
    int32_t v11 = &v6;
    int32_t v12 = 0;
    int32_t v13 = 0;
    int32_t v14 = 0;
    int32_t v15 = v14; // 0x1ada0
    int32_t v16 = v12; // 0x1ada0
    int32_t v17; // 0x1ad08
    int32_t v18; // 0x1ad08
    int32_t v19; // 0x1b130
    int32_t v20; // 0x1b134
    int32_t v21; // 0x1b138
    int32_t v22; // 0x1b140
    int32_t v23; // 0x1b148
    uint32_t v24; // 0x1b160
    int32_t * v25; // 0x1b168
    int32_t v26; // 0x1b188
    int32_t v27; // 0x1b1f0
    int32_t v28; // 0x1b1a8
    if (function_1e29c(v13) != 0) {
        // 0x1b12c
        v19 = 1024 * v13;
        v20 = 4 * v13;
        v21 = v19 + (int32_t)a1;
        v22 = v20 + v9;
        v23 = v20 + v10;
        function_19d70(v21, v23, v22, &v5);
        v24 = *(int32_t *)v22;
        v25 = (int32_t *)v23;
        *(int32_t *)(v11 - 2064 + 4 * v12) = *v25;
        v26 = function_1e0f0();
        if (v26 != 0) {
            // 0x1b194
            v18 = v19 + v11;
            v28 = v21 + 4;
            *(int32_t *)v18 = *(int32_t *)v21 - *v25;
            v18 += 4;
            while (v28 != 4 * v26 + v21) {
                // 0x1b1a8
                v17 = v28;
                v28 = v17 + 4;
                *(int32_t *)v18 = *(int32_t *)v17 - *v25;
                v18 += 4;
            }
        }
        // 0x1b1bc
        if (g294 == 2) {
            // 0x1b1c8
            *(int32_t *)(v20 + 1 * (int32_t)&g337) = g65;
        }
        // 0x1b1e0
        function_1e0f0();
        v27 = function_5f880();
        *(int32_t *)(v20 + (int32_t)&g341) = v27;
        v15 = v14 < v24 ? v24 : v14;
        v16 = v12 + 1;
    }
    int32_t nmemb = v16;
    int32_t result = v15;
    int32_t v29 = v13 + 1; // 0x1ada4
    while (v29 != 4) {
        // 0x1ad94
        v12 = nmemb;
        v13 = v29;
        v14 = result;
        v15 = v14;
        v16 = v12;
        if (function_1e29c(v13) != 0) {
            // 0x1b12c
            v19 = 1024 * v13;
            v20 = 4 * v13;
            v21 = v19 + (int32_t)a1;
            v22 = v20 + v9;
            v23 = v20 + v10;
            function_19d70(v21, v23, v22, &v5);
            v24 = *(int32_t *)v22;
            v25 = (int32_t *)v23;
            *(int32_t *)(v11 - 2064 + 4 * v12) = *v25;
            v26 = function_1e0f0();
            if (v26 != 0) {
                // 0x1b194
                v18 = v19 + v11;
                v28 = v21 + 4;
                *(int32_t *)v18 = *(int32_t *)v21 - *v25;
                v18 += 4;
                while (v28 != 4 * v26 + v21) {
                    // 0x1b1a8
                    v17 = v28;
                    v28 = v17 + 4;
                    *(int32_t *)v18 = *(int32_t *)v17 - *v25;
                    v18 += 4;
                }
            }
            // 0x1b1bc
            if (g294 == 2) {
                // 0x1b1c8
                *(int32_t *)(v20 + 1 * (int32_t)&g337) = g65;
            }
            // 0x1b1e0
            function_1e0f0();
            v27 = function_5f880();
            *(int32_t *)(v20 + (int32_t)&g341) = v27;
            v15 = v14 < v24 ? v24 : v14;
            v16 = v12 + 1;
        }
        // 0x1ada4
        nmemb = v16;
        result = v15;
        v29 = v13 + 1;
    }
    // 0x1adb0
    qsort(&base, nmemb, 4, (int32_t (*)(int32_t *, int32_t *))0x19d60);
    int32_t v30 = a2; // 0x1add0
    float32_t v31 = __asm_vmov_7(base); // 0x1addc
    __asm_vcvt_f32_u32(v31);
    function_1a470(255, v30, a3, base, (int32_t)&g488);
    if (base == result) {
        // 0x1b0fc
        __asm_vpop_13(v2, v2);
        return result;
    }
    if (nmemb != 1 && nmemb != 0) {
        int32_t v32 = 1; // 0x1ae08
        int32_t v33 = &base;
        int32_t v34 = v33 + 4;
        int32_t * v35 = (int32_t *)v34;
        int32_t * v36 = (int32_t *)v33;
        int32_t v37 = 0;
        uint32_t v38; // 0x1ae24
        if (function_1e29c(v37) != 0) {
            // 0x1ae20
            v38 = *v35;
            if (*(int32_t *)(4 * v37 + v10) >= v38) {
                // 0x1b110
                __asm_vmov_f32(v4);
                function_1aae4(v37, v30, *v36, v38, (int32_t)&g488);
            }
        }
        int32_t v39 = v37 + 1; // 0x1ae34
        while (v39 != 4) {
            // 0x1ae10
            v37 = v39;
            if (function_1e29c(v37) != 0) {
                // 0x1ae20
                v38 = *v35;
                if (*(int32_t *)(4 * v37 + v10) >= v38) {
                    // 0x1b110
                    __asm_vmov_f32(v4);
                    function_1aae4(v37, v30, *v36, v38, (int32_t)&g488);
                }
            }
            // 0x1ae34
            v39 = v37 + 1;
        }
        while (nmemb != v32 + 1) {
            // 0x1ae40
            v32++;
            v33 = v34;
            v34 = v33 + 4;
            v35 = (int32_t *)v34;
            v36 = (int32_t *)v33;
            v37 = 0;
            if (function_1e29c(v37) != 0) {
                // 0x1ae20
                v38 = *v35;
                if (*(int32_t *)(4 * v37 + v10) >= v38) {
                    // 0x1b110
                    __asm_vmov_f32(v4);
                    function_1aae4(v37, v30, *v36, v38, (int32_t)&g488);
                }
            }
            // 0x1ae34
            v39 = v37 + 1;
            while (v39 != 4) {
                // 0x1ae10
                v37 = v39;
                if (function_1e29c(v37) != 0) {
                    // 0x1ae20
                    v38 = *v35;
                    if (*(int32_t *)(4 * v37 + v10) >= v38) {
                        // 0x1b110
                        __asm_vmov_f32(v4);
                        function_1aae4(v37, v30, *v36, v38, (int32_t)&g488);
                    }
                }
                // 0x1ae34
                v39 = v37 + 1;
            }
        }
    }
    // 0x1ae50
    char * v40; // bp-6184, 0x1ad08
    int32_t v41 = (int32_t)&v40;
    int32_t v42 = 0;
    int32_t result2 = function_1e29c(v42); // 0x1ae64
    float32_t v43 = v31; // 0x1ae6c
    int32_t v44; // 0x1ad08
    int32_t v45; // 0x1ad08
    bool v46; // 0x1ad08
    bool v47; // 0x1ad08
    int32_t v48; // 0x1ad08
    int32_t v49; // 0x1ad08
    int32_t v50; // 0x1ad08
    int32_t v51; // 0x1ad08
    int32_t v52; // 0x1ad08
    int32_t v53; // 0x1ad08
    int32_t v54; // 0x1ad08
    int32_t v55; // 0x1ad08
    int32_t v56; // 0x1ad08
    int32_t v57; // 0x1ad08
    int32_t v58; // 0x1ad08
    int32_t v59; // 0x1ad08
    int32_t v60; // 0x1ad08
    int32_t v61; // 0x1ad08
    float32_t v62; // 0x1ad08
    float32_t v63; // 0x1ad08
    float32_t v64; // 0x1ad08
    float32_t v65; // 0x1ad08
    float32_t v66; // 0x1ad08
    float32_t v67; // 0x1ad08
    float32_t v68; // 0x1ad08
    float32_t v69; // 0x1ad08
    int32_t v70; // 0x1ad08
    int32_t v71; // 0x1ae74
    float32_t v72; // 0x1ae78
    int32_t v73; // 0x1ae84
    char * v74; // 0x1ae98
    int32_t v75; // 0x1aee0
    char * v76; // 0x1b200
    int32_t v77; // 0x1aef4
    int32_t v78; // 0x1af00
    int32_t v79; // 0x1af80
    float32_t v80; // 0x1af88
    int32_t v81; // 0x1af18
    float32_t v82; // 0x1afb0
    float32_t v83; // 0x1afc0
    int32_t v84; // 0x1ad08
    int32_t v85; // 0x1afc4
    int32_t v86; // 0x1af90
    int32_t v87; // 0x1af50
    int32_t v88; // 0x1af54
    int32_t nmemb2; // 0x1af5c
    int32_t v89; // 0x1af2c
    int32_t v90; // 0x1af30
    int32_t v91; // 0x1af3c
    int32_t v92; // 0x1ad08
    int32_t v93; // 0x1af94
    float32_t v94; // 0x1af98
    int32_t v95; // 0x1afe4
    float32_t v96; // 0x1afec
    float32_t v97; // 0x1aff0
    int32_t v98; // 0x1aff4
    float32_t v99; // 0x1b000
    int32_t v100; // 0x1afa8
    int32_t v101; // 0x1b018
    int32_t v102; // 0x1b0c4
    int32_t v103; // 0x1b030
    int32_t v104; // 0x1b038
    float32_t v105; // 0x1b044
    if (result2 != 0) {
        // 0x1ae70
        v71 = 4 * v42;
        v72 = __asm_vmov_7(*(int32_t *)(v71 + v10));
        v73 = __asm_vmov_9(v72);
        v43 = v31;
        if (v73 != *(int32_t *)(v71 + v9)) {
            // 0x1ae90
            v74 = g289;
            if (v74 != (char *)3 && v74 >= (char *)3) {
                // 0x1aea4
                return result2;
            }
            // 0x1aed8
            v75 = function_11eb0(function_1e0f0(), 8, v73, (int32_t)v74);
            if (v75 == 0) {
                // 0x1b200
                v76 = g289;
                v43 = v31;
                if (v76 != (char *)3 && v76 >= (char *)3) {
                    // 0x1b20c
                    v40 = (char *)0x6c696166;
                    function_2e584(3, (int32_t *)&v40, 0);
                    v43 = v31;
                }
            } else {
                // 0x1aeec
                v77 = 1024 * v42 + v11;
                v40 = NULL;
                v78 = function_1e0e0();
                v48 = 8;
                v57 = v73;
                if (v78 != 0) {
                    v58 = 0;
                    v81 = function_1e100();
                    v70 = 0;
                    if (v81 != 0) {
                        v89 = function_1e100() * v58 + v70;
                        v90 = v70 + 1;
                        v91 = 8 * v89 + v75;
                        *(int32_t *)(v91 + 4) = *(int32_t *)(4 * v89 + v77);
                        *(int32_t *)v91 = v89;
                        v70 = v90;
                        while (v81 != v90) {
                            // 0x1af28
                            v89 = function_1e100() * v58 + v70;
                            v90 = v70 + 1;
                            v91 = 8 * v89 + v75;
                            *(int32_t *)(v91 + 4) = *(int32_t *)(4 * v89 + v77);
                            *(int32_t *)v91 = v89;
                            v70 = v90;
                        }
                    }
                    // 0x1af4c
                    v87 = v58 + 1;
                    v88 = function_1e100();
                    nmemb2 = function_1e100();
                    qsort((int32_t *)(8 * v58 * v88 + v75), nmemb2, 8, (int32_t (*)(int32_t *, int32_t *))0x19d40);
                    v48 = nmemb2;
                    v57 = 8;
                    while (v78 != v87) {
                        // 0x1af18
                        v58 = v87;
                        v81 = function_1e100();
                        v70 = 0;
                        if (v81 != 0) {
                            v89 = function_1e100() * v58 + v70;
                            v90 = v70 + 1;
                            v91 = 8 * v89 + v75;
                            *(int32_t *)(v91 + 4) = *(int32_t *)(4 * v89 + v77);
                            *(int32_t *)v91 = v89;
                            v70 = v90;
                            while (v81 != v90) {
                                // 0x1af28
                                v89 = function_1e100() * v58 + v70;
                                v90 = v70 + 1;
                                v91 = 8 * v89 + v75;
                                *(int32_t *)(v91 + 4) = *(int32_t *)(4 * v89 + v77);
                                *(int32_t *)v91 = v89;
                                v70 = v90;
                            }
                        }
                        // 0x1af4c
                        v87 = v58 + 1;
                        v88 = function_1e100();
                        nmemb2 = function_1e100();
                        qsort((int32_t *)(8 * v58 * v88 + v75), nmemb2, 8, (int32_t (*)(int32_t *, int32_t *))0x19d40);
                        v48 = nmemb2;
                        v57 = 8;
                    }
                }
                // 0x1af80
                v49 = v48;
                v79 = function_1e0f0();
                v80 = __asm_vldr_8(0);
                v64 = v80;
                if (v79 != 0) {
                    // 0x1af90
                    v86 = 4 * v79 + v77;
                    v93 = v77;
                    v93 = __asm_vldmia(v93, v31);
                    v94 = __asm_vcvt_f32_u32(v31);
                    __asm_vcmp_f32(v94, v80);
                    __asm_vmrs(v84, v84);
                    v62 = v80;
                    if (v79 >= 0) {
                        v62 = __asm_vmovgt_f32(v94);
                    }
                    v63 = v62;
                    v100 = v86 - v93;
                    v65 = v94;
                    v46 = ((v100 ^ v86) & (v93 ^ v86)) < 0;
                    v64 = v63;
                    while (v86 != v93) {
                        // 0x1af94
                        v93 = __asm_vldmia(v93, v65);
                        v94 = __asm_vcvt_f32_u32(v65);
                        __asm_vcmp_f32(v94, v63);
                        __asm_vmrs(v84, v84);
                        v62 = v63;
                        if (v100 < 0 == v46) {
                            v62 = __asm_vmovgt_f32(v94);
                        }
                        v63 = v62;
                        v100 = v86 - v93;
                        v65 = v94;
                        v46 = ((v100 ^ v86) & (v93 ^ v86)) < 0;
                        v64 = v63;
                    }
                }
                // 0x1afb0
                v82 = __asm_vadd_f32(v4, v64);
                v83 = __asm_vcvt_u32_f32(__asm_vdiv_f32(__asm_vsub_f32(v82, __asm_vmov_f32(1.0f)), v4));
                v85 = __asm_vmov_9(v83);
                __asm_vstr_12(v83, v84);
                v56 = v49;
                v69 = v83;
                if (v85 != 0) {
                    // 0x1afe0
                    v92 = v75 + 4;
                    v95 = 0;
                    v95++;
                    v96 = __asm_vmov_7(v95);
                    v97 = __asm_vcvt_f32_u32(v96);
                    v98 = function_1e100();
                    v99 = __asm_vmul_f32(v97, v4);
                    v50 = v49;
                    v60 = 0;
                    v66 = v96;
                    v54 = v49;
                    v68 = v96;
                    if (v98 != 0) {
                        while (true) {
                            // 0x1b018
                            v61 = v60;
                            v101 = function_1e0e0();
                            v51 = v50;
                            v59 = 0;
                            v44 = v101;
                            v47 = false;
                            v53 = v50;
                            v67 = v66;
                            if (v101 != 0) {
                                while (true) {
                                    // 0x1b028
                                    v45 = v44;
                                    v103 = *(int32_t *)(8 * (function_1e100() * v59 + v61) + v75);
                                    v104 = function_1e100() * v59 + v61;
                                    v105 = __asm_vcvt_f32_u32(__asm_vldr_8(*(int32_t *)(v92 + 8 * v104)));
                                    __asm_vcmpe_f32(v99, v105);
                                    __asm_vmrs(v84, v84);
                                    if (v45 < 0 == v47) {
                                        // 0x1b054
                                        __asm_vcmpe_f32(v4, __asm_vsub_f32(v99, v105));
                                        __asm_vmrs(v84, v84);
                                        v52 = v51;
                                        if ((v104 & 0x20000000) == 0) {
                                            goto lab_0x1b0b4;
                                        } else {
                                            goto lab_0x1b064;
                                        }
                                    } else {
                                        goto lab_0x1b064;
                                    }
                                }
                            }
                            // 0x1b0c0
                            v102 = v61 + 1;
                            usleep(0x186a0);
                            v50 = v53;
                            v60 = v102;
                            v66 = v67;
                            v54 = v53;
                            v68 = v67;
                            if (v98 == v102) {
                                // break -> 0x1b0d8
                                break;
                            }
                        }
                    }
                    // 0x1b0d8
                    v55 = v54;
                    v56 = v55;
                    v69 = v68;
                    while (v84 != v95) {
                        // 0x1afe0
                        v95++;
                        v96 = __asm_vmov_7(v95);
                        v97 = __asm_vcvt_f32_u32(v96);
                        v98 = function_1e100();
                        v99 = __asm_vmul_f32(v97, v4);
                        v50 = v55;
                        v60 = 0;
                        v66 = v96;
                        v54 = v55;
                        v68 = v96;
                        if (v98 != 0) {
                            while (true) {
                                // 0x1b018
                                v61 = v60;
                                v101 = function_1e0e0();
                                v51 = v50;
                                v59 = 0;
                                v44 = v101;
                                v47 = false;
                                v53 = v50;
                                v67 = v66;
                                if (v101 != 0) {
                                    while (true) {
                                        // 0x1b028
                                        v45 = v44;
                                        v103 = *(int32_t *)(8 * (function_1e100() * v59 + v61) + v75);
                                        v104 = function_1e100() * v59 + v61;
                                        v105 = __asm_vcvt_f32_u32(__asm_vldr_8(*(int32_t *)(v92 + 8 * v104)));
                                        __asm_vcmpe_f32(v99, v105);
                                        __asm_vmrs(v84, v84);
                                        if (v45 < 0 == v47) {
                                            // 0x1b054
                                            __asm_vcmpe_f32(v4, __asm_vsub_f32(v99, v105));
                                            __asm_vmrs(v84, v84);
                                            v52 = v51;
                                            if ((v104 & 0x20000000) == 0) {
                                                goto lab_0x1b0b4;
                                            } else {
                                                goto lab_0x1b064;
                                            }
                                        } else {
                                            goto lab_0x1b064;
                                        }
                                    }
                                }
                                // 0x1b0c0
                                v102 = v61 + 1;
                                usleep(0x186a0);
                                v50 = v53;
                                v60 = v102;
                                v66 = v67;
                                v54 = v53;
                                v68 = v67;
                                if (v98 == v102) {
                                    // break -> 0x1b0d8
                                    break;
                                }
                            }
                        }
                        // 0x1b0d8
                        v55 = v54;
                        v56 = v55;
                        v69 = v68;
                    }
                }
                // 0x1b0e8
                free(v75, v56, v57, 0);
                v43 = v69;
            }
        }
    }
    int32_t v106 = v42 + 1; // 0x1b0f0
    while (v106 != 4) {
        float32_t v107 = v43;
        v42 = v106;
        result2 = function_1e29c(v42);
        v43 = v107;
        if (result2 != 0) {
            // 0x1ae70
            v71 = 4 * v42;
            v72 = __asm_vmov_7(*(int32_t *)(v71 + v10));
            v73 = __asm_vmov_9(v72);
            v43 = v107;
            if (v73 != *(int32_t *)(v71 + v9)) {
                // 0x1ae90
                v74 = g289;
                if (v74 != (char *)3 && v74 >= (char *)3) {
                    // 0x1aea4
                    return result2;
                }
                // 0x1aed8
                v75 = function_11eb0(function_1e0f0(), 8, v73, (int32_t)v74);
                if (v75 == 0) {
                    // 0x1b200
                    v76 = g289;
                    v43 = v107;
                    if (v76 != (char *)3 && v76 >= (char *)3) {
                        // 0x1b20c
                        v40 = (char *)0x6c696166;
                        function_2e584(3, (int32_t *)&v40, 0);
                        v43 = v107;
                    }
                } else {
                    // 0x1aeec
                    v77 = 1024 * v42 + v11;
                    v40 = NULL;
                    v78 = function_1e0e0();
                    v48 = 8;
                    v57 = v73;
                    if (v78 != 0) {
                        v58 = 0;
                        v81 = function_1e100();
                        v70 = 0;
                        if (v81 != 0) {
                            v89 = function_1e100() * v58 + v70;
                            v90 = v70 + 1;
                            v91 = 8 * v89 + v75;
                            *(int32_t *)(v91 + 4) = *(int32_t *)(4 * v89 + v77);
                            *(int32_t *)v91 = v89;
                            v70 = v90;
                            while (v81 != v90) {
                                // 0x1af28
                                v89 = function_1e100() * v58 + v70;
                                v90 = v70 + 1;
                                v91 = 8 * v89 + v75;
                                *(int32_t *)(v91 + 4) = *(int32_t *)(4 * v89 + v77);
                                *(int32_t *)v91 = v89;
                                v70 = v90;
                            }
                        }
                        // 0x1af4c
                        v87 = v58 + 1;
                        v88 = function_1e100();
                        nmemb2 = function_1e100();
                        qsort((int32_t *)(8 * v58 * v88 + v75), nmemb2, 8, (int32_t (*)(int32_t *, int32_t *))0x19d40);
                        v48 = nmemb2;
                        v57 = 8;
                        while (v78 != v87) {
                            // 0x1af18
                            v58 = v87;
                            v81 = function_1e100();
                            v70 = 0;
                            if (v81 != 0) {
                                v89 = function_1e100() * v58 + v70;
                                v90 = v70 + 1;
                                v91 = 8 * v89 + v75;
                                *(int32_t *)(v91 + 4) = *(int32_t *)(4 * v89 + v77);
                                *(int32_t *)v91 = v89;
                                v70 = v90;
                                while (v81 != v90) {
                                    // 0x1af28
                                    v89 = function_1e100() * v58 + v70;
                                    v90 = v70 + 1;
                                    v91 = 8 * v89 + v75;
                                    *(int32_t *)(v91 + 4) = *(int32_t *)(4 * v89 + v77);
                                    *(int32_t *)v91 = v89;
                                    v70 = v90;
                                }
                            }
                            // 0x1af4c
                            v87 = v58 + 1;
                            v88 = function_1e100();
                            nmemb2 = function_1e100();
                            qsort((int32_t *)(8 * v58 * v88 + v75), nmemb2, 8, (int32_t (*)(int32_t *, int32_t *))0x19d40);
                            v48 = nmemb2;
                            v57 = 8;
                        }
                    }
                    // 0x1af80
                    v49 = v48;
                    v79 = function_1e0f0();
                    v80 = __asm_vldr_8(0);
                    v64 = v80;
                    if (v79 != 0) {
                        // 0x1af90
                        v86 = 4 * v79 + v77;
                        v93 = v77;
                        v93 = __asm_vldmia(v93, v107);
                        v94 = __asm_vcvt_f32_u32(v107);
                        __asm_vcmp_f32(v94, v80);
                        __asm_vmrs(v84, v84);
                        v62 = v80;
                        if (v79 >= 0) {
                            v62 = __asm_vmovgt_f32(v94);
                        }
                        v63 = v62;
                        v100 = v86 - v93;
                        v65 = v94;
                        v46 = ((v100 ^ v86) & (v93 ^ v86)) < 0;
                        v64 = v63;
                        while (v86 != v93) {
                            // 0x1af94
                            v93 = __asm_vldmia(v93, v65);
                            v94 = __asm_vcvt_f32_u32(v65);
                            __asm_vcmp_f32(v94, v63);
                            __asm_vmrs(v84, v84);
                            v62 = v63;
                            if (v100 < 0 == v46) {
                                v62 = __asm_vmovgt_f32(v94);
                            }
                            v63 = v62;
                            v100 = v86 - v93;
                            v65 = v94;
                            v46 = ((v100 ^ v86) & (v93 ^ v86)) < 0;
                            v64 = v63;
                        }
                    }
                    // 0x1afb0
                    v82 = __asm_vadd_f32(v4, v64);
                    v83 = __asm_vcvt_u32_f32(__asm_vdiv_f32(__asm_vsub_f32(v82, __asm_vmov_f32(1.0f)), v4));
                    v85 = __asm_vmov_9(v83);
                    __asm_vstr_12(v83, v84);
                    v56 = v49;
                    v69 = v83;
                    if (v85 != 0) {
                        // 0x1afe0
                        v92 = v75 + 4;
                        v95 = 0;
                        v95++;
                        v96 = __asm_vmov_7(v95);
                        v97 = __asm_vcvt_f32_u32(v96);
                        v98 = function_1e100();
                        v99 = __asm_vmul_f32(v97, v4);
                        v50 = v49;
                        v60 = 0;
                        v66 = v96;
                        v54 = v49;
                        v68 = v96;
                        if (v98 != 0) {
                            while (true) {
                                // 0x1b018
                                v61 = v60;
                                v101 = function_1e0e0();
                                v51 = v50;
                                v59 = 0;
                                v44 = v101;
                                v47 = false;
                                v53 = v50;
                                v67 = v66;
                                if (v101 != 0) {
                                    while (true) {
                                        // 0x1b028
                                        v45 = v44;
                                        v103 = *(int32_t *)(8 * (function_1e100() * v59 + v61) + v75);
                                        v104 = function_1e100() * v59 + v61;
                                        v105 = __asm_vcvt_f32_u32(__asm_vldr_8(*(int32_t *)(v92 + 8 * v104)));
                                        __asm_vcmpe_f32(v99, v105);
                                        __asm_vmrs(v84, v84);
                                        if (v45 < 0 == v47) {
                                            // 0x1b054
                                            __asm_vcmpe_f32(v4, __asm_vsub_f32(v99, v105));
                                            __asm_vmrs(v84, v84);
                                            v52 = v51;
                                            if ((v104 & 0x20000000) == 0) {
                                                goto lab_0x1b0b4;
                                            } else {
                                                goto lab_0x1b064;
                                            }
                                        } else {
                                            goto lab_0x1b064;
                                        }
                                    }
                                }
                                // 0x1b0c0
                                v102 = v61 + 1;
                                usleep(0x186a0);
                                v50 = v53;
                                v60 = v102;
                                v66 = v67;
                                v54 = v53;
                                v68 = v67;
                                if (v98 == v102) {
                                    // break -> 0x1b0d8
                                    break;
                                }
                            }
                        }
                        // 0x1b0d8
                        v55 = v54;
                        v56 = v55;
                        v69 = v68;
                        while (v84 != v95) {
                            // 0x1afe0
                            v95++;
                            v96 = __asm_vmov_7(v95);
                            v97 = __asm_vcvt_f32_u32(v96);
                            v98 = function_1e100();
                            v99 = __asm_vmul_f32(v97, v4);
                            v50 = v55;
                            v60 = 0;
                            v66 = v96;
                            v54 = v55;
                            v68 = v96;
                            if (v98 != 0) {
                                while (true) {
                                    // 0x1b018
                                    v61 = v60;
                                    v101 = function_1e0e0();
                                    v51 = v50;
                                    v59 = 0;
                                    v44 = v101;
                                    v47 = false;
                                    v53 = v50;
                                    v67 = v66;
                                    if (v101 != 0) {
                                        while (true) {
                                            // 0x1b028
                                            v45 = v44;
                                            v103 = *(int32_t *)(8 * (function_1e100() * v59 + v61) + v75);
                                            v104 = function_1e100() * v59 + v61;
                                            v105 = __asm_vcvt_f32_u32(__asm_vldr_8(*(int32_t *)(v92 + 8 * v104)));
                                            __asm_vcmpe_f32(v99, v105);
                                            __asm_vmrs(v84, v84);
                                            if (v45 < 0 == v47) {
                                                // 0x1b054
                                                __asm_vcmpe_f32(v4, __asm_vsub_f32(v99, v105));
                                                __asm_vmrs(v84, v84);
                                                v52 = v51;
                                                if ((v104 & 0x20000000) == 0) {
                                                    goto lab_0x1b0b4;
                                                } else {
                                                    goto lab_0x1b064;
                                                }
                                            } else {
                                                goto lab_0x1b064;
                                            }
                                        }
                                    }
                                    // 0x1b0c0
                                    v102 = v61 + 1;
                                    usleep(0x186a0);
                                    v50 = v53;
                                    v60 = v102;
                                    v66 = v67;
                                    v54 = v53;
                                    v68 = v67;
                                    if (v98 == v102) {
                                        // break -> 0x1b0d8
                                        break;
                                    }
                                }
                            }
                            // 0x1b0d8
                            v55 = v54;
                            v56 = v55;
                            v69 = v68;
                        }
                    }
                    // 0x1b0e8
                    free(v75, v56, v57, 0);
                    v43 = v69;
                }
            }
        }
        // 0x1b0f0
        v106 = v42 + 1;
    }
    // 0x1b0fc
    __asm_vpop_13(v2, v2);
    return result;
  lab_0x1b064:;
    float32_t v108 = __asm_vcvt_f32_u32(v72); // 0x1b064
    __asm_vcmpe_f32(v99, v105);
    __asm_vmrs(v84, v84);
    if (v45 < 0) {
        // .thread
        __asm_vaddmi_f32(v99, v108);
    } else {
        __asm_vaddpl_f32(v105, v108);
    }
    int32_t v109; // bp-6244, 0x1ad08
    function_502c0(v41, &v109, 0);
    int32_t v110 = function_1e160(); // 0x1b090
    function_1f164(v42, 0, __asm_smulbb(v110, v103) % 256, v30, (int32_t)v40, 0);
    v52 = 0;
    goto lab_0x1b0b4;
  lab_0x1b0b4:;
    int32_t v111 = v59 + 1; // 0x1b0b4
    int32_t v112 = v101 - v111; // 0x1b0b8
    v51 = v52;
    v59 = v111;
    v44 = v112;
    v47 = ((v112 ^ v101) & (v111 ^ v101)) < 0;
    v53 = v52;
    v67 = v105;
    if (v101 == v111) {
        // break -> 0x1b0c0
        goto lab_0x1b0c0;
    }
    goto lab_0x1b028;
}

// Address range: 0x1b248 - 0x1b2fc
int32_t function_1b248(int32_t a1, int32_t a2, int32_t a3) {
    char * v1 = g289; // 0x1b260
    int32_t str; // bp-2072, 0x1b248
    if (v1 != (char *)3 && v1 >= (char *)3) {
        // 0x1b278
        snprintf((char *)&str, 2048, "chain = %d, freq = %d\n", a1, a3);
        function_2e584(3, &str, 0);
    }
    // 0x1b2a8
    str = 0;
    __asm_vcvt_f32_u32(__asm_vldr_8(a3));
    int32_t v2; // bp-2076, 0x1b248
    function_502c0((int32_t)&str, &v2, 0);
    return function_1f164(a1, 1, 0, a2, str, 0);
}

// Address range: 0x1b2fc - 0x1b394
int32_t function_1b2fc(void) {
    // 0x1b2fc
    if (g294 == 2) {
        uint32_t v1 = g65; // 0x1b37c
        return v1 > 50 ? v1 : 50;
    }
    // 0x1b328
    int32_t v2; // bp-24, 0x1b2fc
    int32_t v3 = &v2;
    int32_t v4; // bp-28, 0x1b2fc
    int32_t v5 = &v4;
    int32_t v6 = 50;
    int32_t v7 = 0;
    int32_t v8 = v6; // 0x1b334
    int32_t v9; // bp-20, 0x1b2fc
    uint32_t v10; // 0x1b364
    if (function_1e29c(v7) != 0) {
        // 0x1b350
        function_19d70(1024 * v7 + (int32_t)&g86, v5, v3, &v9);
        v10 = v2;
        v8 = v6 < v10 ? v10 : v6;
    }
    int32_t result = v8;
    int32_t v11 = v7 + 1; // 0x1b338
    while (v11 != 4) {
        // 0x1b328
        v6 = result;
        v7 = v11;
        v8 = v6;
        if (function_1e29c(v7) != 0) {
            // 0x1b350
            function_19d70(1024 * v7 + (int32_t)&g86, v5, v3, &v9);
            v10 = v2;
            v8 = v6 < v10 ? v10 : v6;
        }
        // 0x1b338
        result = v8;
        v11 = v7 + 1;
    }
    // 0x1b344
    return result;
}

// Address range: 0x1b398 - 0x1b4ac
int32_t function_1b398(void) {
    // 0x1b398
    int32_t v1; // 0x1b398
    int32_t v2 = function_11eb0(g179, 528, v1, v1); // 0x1b3bc
    g201 = v2;
    int32_t str; // bp-2072, 0x1b398
    if (v2 == 0) {
        char * v3 = g289; // 0x1b408
        if (v3 == (char *)3 || v3 < (char *)3) {
            // 0x1b3f4
            return -0x7ffffc00;
        }
        // 0x1b41c
        snprintf((char *)&str, 2048, "malloc %d runtime_chain failed\n", g179);
        function_2e584(3, &str, 0);
        return -0x7ffffc00;
    }
    int32_t v4 = function_11eb0(g197, 8, v1, v1); // 0x1b3d4
    g204 = v4;
    if (v4 != 0) {
        g198 = 1;
        // 0x1b3f4
        return 0;
    }
    char * v5 = g289; // 0x1b460
    int32_t v6 = 8; // 0x1b468
    int32_t v7 = (int32_t)v5; // 0x1b468
    int32_t v8 = v2; // 0x1b468
    int32_t v9; // 0x1b398
    if (v5 != (char *)3 && v5 >= (char *)3) {
        // 0x1b46c
        snprintf((char *)&str, 2048, "malloc %d runtime_fan failed\n", v7);
        function_2e584(3, &str, 0);
        v8 = g201;
        v6 = &str;
        v9 = 0;
    }
    // 0x1b498
    free(v8, v6, v9, v7);
    // 0x1b3f4
    return -0x7ffffc00;
}

// Address range: 0x1b4ac - 0x1e0c0
int32_t function_1b4ac(void) {
    // 0x1b4ac
    int32_t v1; // bp-2340, 0x1b4ac
    int32_t v2 = function_4d6e4("/etc/topol.conf", 0, &v1); // 0x1b4c8
    char * v3; // 0x1b4ac
    char * v4; // 0x1b4ac
    char * v5; // 0x1b4ac
    char * v6; // 0x1b4ac
    int32_t v7; // 0x1b4ac
    int32_t v8; // 0x1b4ac
    int32_t v9; // 0x1b4ac
    int32_t v10; // 0x1b4ac
    int32_t v11; // 0x1b4ac
    int32_t v12; // 0x1b4ac
    int32_t v13; // 0x1b4ac
    int32_t v14; // 0x1b4ac
    int32_t v15; // 0x1b4ac
    int32_t format; // 0x1b4ac
    int32_t v16; // 0x1b4ac
    int32_t v17; // 0x1b4ac
    int32_t v18; // 0x1b4ac
    int32_t v19; // 0x1b4ac
    int32_t v20; // 0x1b4ac
    int32_t v21; // 0x1b4ac
    int32_t v22; // 0x1b4ac
    int32_t result; // 0x1b4ac
    int32_t v23; // 0x1b4ac
    char * str5; // 0x1b4ac
    int32_t v24; // 0x1b4ac
    char * str4; // 0x1b4ac
    char * v25; // bp-2080, 0x1b4ac
    char * str; // bp-2088, 0x1b4ac
    int32_t v26; // 0x1bcb8
    int32_t v27; // 0x1bd60
    char * v28; // 0x1b4ac
    int32_t v29; // 0x1bd70
    int32_t v30; // 0x1bf38
    int32_t v31; // 0x1be5c
    int32_t v32; // 0x1be98
    int32_t v33; // 0x1b69c
    char * v34; // 0x1b4ac
    int32_t v35; // 0x1b6ac
    int32_t v36; // 0x1b7c8
    char * v37; // 0x1b4ac
    int32_t v38; // 0x1b7d8
    int32_t v39; // 0x1b870
    char * v40; // 0x1b4ac
    int32_t v41; // 0x1b8a4
    char * v42; // 0x1b4ac
    int32_t v43; // 0x1b8b4
    int32_t v44; // 0x1b9e4
    char * v45; // 0x1b4ac
    int32_t v46; // 0x1b9f4
    int32_t v47; // 0x1ba18
    char * v48; // 0x1b4ac
    int32_t v49; // 0x1b510
    int32_t v50; // 0x1ba28
    int32_t v51; // 0x1bb50
    int32_t v52; // 0x1bc44
    if (v2 == 0) {
        goto lab_0x1b4e0;
    } else {
        int32_t v53 = *(int32_t *)v2; // 0x1b4d4
        v22 = v53;
        if (v53 == 0) {
            // 0x1b508
            v49 = function_4e234(v2, "machine");
            if (v49 == 0) {
                // 0x1b5bc
                v12 = &v1;
                v21 = (int32_t)g289;
                goto lab_0x1b534;
            } else {
                int32_t v54 = *(int32_t *)v49; // 0x1b51c
                char * v55 = g289; // 0x1b528
                int32_t v56 = (int32_t)v55; // 0x1b528
                v12 = v54;
                v21 = v56;
                if (v54 == 2) {
                    int32_t v57 = 2; // 0x1b644
                    int32_t v58 = v56; // 0x1b644
                    if (v55 >= (char *)3 == (v55 != (char *)3)) {
                        // 0x1b758
                        v58 = function_4e768(v49);
                        snprintf((char *)&str, 2048, "load machine %s conf\n", (char *)v58);
                        function_2e584(3, (int32_t *)&str, 0);
                        v57 = 0;
                    }
                    char * str2 = (char *)function_4e768(v49); // 0x1b65c
                    int32_t v59 = function_11eb0(strlen(str2) + 1, 1, v57, v58); // 0x1b668
                    g178 = v59;
                    if (v59 == 0) {
                        char * v60 = g289; // 0x1b704
                        v8 = 0;
                        v10 = 1;
                        v16 = v57;
                        result = -1;
                        if (v60 == (char *)3 || v60 < (char *)3) {
                            goto lab_0x1b540;
                        } else {
                            int32_t v61 = (int32_t)&str; // 0x1b714
                            str = (char *)0x20746567;
                            v25 = (char *)0x20656e69;
                            v9 = function_2e584(3, (int32_t *)&str, 0);
                            v11 = v61;
                            v24 = v61;
                            goto lab_0x1b5fc;
                        }
                    } else {
                        char * str3 = (char *)v59; // 0x1b680
                        strcpy(str3, str2);
                        char * v62 = g289; // 0x1b684
                        int32_t v63 = v57; // 0x1b68c
                        if (v62 >= (char *)3 == (v62 != (char *)3)) {
                            // 0x1b788
                            snprintf((char *)&str, 2048, "machine : %s \n", str3);
                            function_2e584(3, (int32_t *)&str, 0);
                            v63 = 0;
                        }
                        // 0x1b690
                        v33 = function_4e234(v2, "hw_version");
                        v34 = g289;
                        v35 = v63;
                        if (v33 == 0) {
                            goto lab_0x1b6bc;
                        } else {
                            // 0x1b6ac
                            v35 = *(int32_t *)v33;
                            if (v35 == 2) {
                                int32_t v64 = 2; // 0x1b7b8
                                if (v34 >= (char *)4 == (v34 != (char *)4)) {
                                    int32_t v65 = function_4e768(v33); // 0x1b800
                                    snprintf((char *)&str, 2048, "hw_version: %s\n", (char *)v65);
                                    function_2e584(4, (int32_t *)&str, 0);
                                    v64 = 0;
                                }
                                // 0x1b7bc
                                v36 = function_4e234(v2, "sw_version");
                                v37 = g289;
                                v38 = v64;
                                if (v36 == 0) {
                                    goto lab_0x1b7e8;
                                } else {
                                    // 0x1b7d8
                                    v38 = *(int32_t *)v36;
                                    if (v38 == 2) {
                                        // 0x1b830
                                        v20 = 2;
                                        if (v37 != (char *)4 && v37 >= (char *)4) {
                                            int32_t v66 = function_4e768(v36); // 0x1b838
                                            snprintf((char *)&str, 2048, "sw_version: %s\n", (char *)v66);
                                            function_2e584(4, (int32_t *)&str, 0);
                                            v20 = 0;
                                        }
                                        // 0x1b864
                                        v39 = function_4e234(v2, "processor");
                                        v40 = g289;
                                        if (v39 == 0) {
                                            goto lab_0x1b93c;
                                        } else {
                                            // 0x1b880
                                            if (*(int32_t *)v39 == 0) {
                                                int32_t v67 = v20; // 0x1b894
                                                if (v40 >= (char *)4 == (v40 != (char *)4)) {
                                                    // 0x1b97c
                                                    str = (char *)0x636f7270;
                                                    v25 = (char *)&g464;
                                                    function_2e584(4, (int32_t *)&str, 0);
                                                    v67 = 0;
                                                }
                                                // 0x1b898
                                                v41 = function_4e234(v39, "type");
                                                v42 = g289;
                                                v43 = v67;
                                                if (v41 == 0) {
                                                    goto lab_0x1b8c4;
                                                } else {
                                                    // 0x1b8b4
                                                    v43 = *(int32_t *)v41;
                                                    if (v43 == 2) {
                                                        int32_t v68 = 2; // 0x1b9a8
                                                        if (v42 != (char *)4 && v42 >= (char *)4) {
                                                            // 0x1b9ac
                                                            snprintf((char *)&str, 2048, "type: %s\n", (char *)function_4e768(v41));
                                                            function_2e584(4, (int32_t *)&str, 0);
                                                            v68 = 0;
                                                        }
                                                        // 0x1b9d8
                                                        v44 = function_4e234(v2, "power");
                                                        v45 = g289;
                                                        v46 = v68;
                                                        if (v44 == 0) {
                                                            goto lab_0x1bab0;
                                                        } else {
                                                            // 0x1b9f4
                                                            v46 = *(int32_t *)v44;
                                                            if (v46 == 0) {
                                                                // 0x1ba04
                                                                v7 = 0;
                                                                if (v45 >= (char *)4 == (v45 != (char *)4)) {
                                                                    // 0x1baec
                                                                    str = (char *)0x65776f70;
                                                                    function_2e584(4, (int32_t *)&str, 0);
                                                                    v7 = (int32_t)&str;
                                                                }
                                                                // 0x1ba0c
                                                                v47 = function_4e234(v44, "type");
                                                                v48 = g289;
                                                                v50 = 0;
                                                                if (v47 == 0) {
                                                                    goto lab_0x1ba38;
                                                                } else {
                                                                    // 0x1ba28
                                                                    v50 = *(int32_t *)v47;
                                                                    if (v50 == 2) {
                                                                        // 0x1bb10
                                                                        v13 = 2;
                                                                        if (v48 != (char *)4 && v48 >= (char *)4) {
                                                                            // 0x1bb18
                                                                            snprintf((char *)&str, 2048, "type: %s\n", (char *)function_4e768(v47));
                                                                            function_2e584(4, (int32_t *)&str, 0);
                                                                            v13 = 0;
                                                                        }
                                                                        // 0x1bb44
                                                                        v51 = function_4e234(v44, "version");
                                                                        if (v51 == 0) {
                                                                            goto lab_0x1bb68;
                                                                        } else {
                                                                            // 0x1bb5c
                                                                            if (*(int32_t *)v51 == 1) {
                                                                                int32_t v69 = function_4e5a0(v51); // 0x1bbac
                                                                                g207 = v69;
                                                                                g208 = (int16_t *)function_11eb0(v69, 2, v13, 1);
                                                                                v14 = v13;
                                                                                if (v69 >= 1) {
                                                                                    int32_t v70 = 0; // 0x1bbf0
                                                                                    int32_t v71 = function_4e9c4(function_4e5bc(v51, v70)); // 0x1bbe4
                                                                                    int32_t v72 = 2 * v70; // 0x1bbec
                                                                                    *(int16_t *)(v72 + (int32_t)g208) = (int16_t)v71;
                                                                                    char * v73 = g289; // 0x1bbf8
                                                                                    int32_t v74 = (int32_t)v73; // 0x1bc00
                                                                                    uint16_t v75; // 0x1bc14
                                                                                    if (v73 != (char *)4 && v73 >= (char *)4) {
                                                                                        // 0x1bc04
                                                                                        v75 = *(int16_t *)(v72 + (int32_t)g208);
                                                                                        snprintf((char *)&str, 2048, "psu version = 0x%x", (int32_t)v75);
                                                                                        function_2e584(4, (int32_t *)&str, 0);
                                                                                        v74 = 0;
                                                                                    }
                                                                                    // 0x1bc2c
                                                                                    v70++;
                                                                                    v14 = v74;
                                                                                    while (v70 < g207) {
                                                                                        // 0x1bbd8
                                                                                        v71 = function_4e9c4(function_4e5bc(v51, v70));
                                                                                        v72 = 2 * v70;
                                                                                        *(int16_t *)(v72 + (int32_t)g208) = (int16_t)v71;
                                                                                        v73 = g289;
                                                                                        v74 = (int32_t)v73;
                                                                                        if (v73 != (char *)4 && v73 >= (char *)4) {
                                                                                            // 0x1bc04
                                                                                            v75 = *(int16_t *)(v72 + (int32_t)g208);
                                                                                            snprintf((char *)&str, 2048, "psu version = 0x%x", (int32_t)v75);
                                                                                            function_2e584(4, (int32_t *)&str, 0);
                                                                                            v74 = 0;
                                                                                        }
                                                                                        // 0x1bc2c
                                                                                        v70++;
                                                                                        v14 = v74;
                                                                                    }
                                                                                }
                                                                                // 0x1bc38
                                                                                v52 = function_4e234(v44, "i2c_addr");
                                                                                if (v52 == 0) {
                                                                                    goto lab_0x1bc5c;
                                                                                } else {
                                                                                    // 0x1bc50
                                                                                    if (*(int32_t *)v52 == 3) {
                                                                                        char * v76 = g289; // 0x1bca0
                                                                                        int32_t v77 = v14; // 0x1bca8
                                                                                        if (v76 >= (char *)4 == (v76 != (char *)4)) {
                                                                                            // 0x1bcf0
                                                                                            snprintf((char *)&str, 2048, "i2c_addr: %d\n", function_4e9c4(v52));
                                                                                            function_2e584(4, (int32_t *)&str, 0);
                                                                                            v77 = 0;
                                                                                        }
                                                                                        // 0x1bcac
                                                                                        v26 = function_4e234(v44, "gpio");
                                                                                        if (v26 == 0) {
                                                                                            // 0x1bcac
                                                                                            v3 = g289;
                                                                                            v15 = v77;
                                                                                            goto lab_0x1bcd4;
                                                                                        } else {
                                                                                            int32_t v78 = *(int32_t *)v26; // 0x1bcc4
                                                                                            char * v79 = g289; // 0x1bcc8
                                                                                            v3 = v79;
                                                                                            v15 = v78;
                                                                                            if (v78 == 3) {
                                                                                                int32_t v80 = 3; // 0x1bd24
                                                                                                if (v79 != (char *)4 && v79 >= (char *)4) {
                                                                                                    // 0x1bd28
                                                                                                    snprintf((char *)&str, 2048, "gpio: %d\n", function_4e9c4(v26));
                                                                                                    function_2e584(4, (int32_t *)&str, 0);
                                                                                                    v80 = 0;
                                                                                                }
                                                                                                // 0x1bd54
                                                                                                v27 = function_4e234(v2, "fan");
                                                                                                v28 = g289;
                                                                                                v29 = v80;
                                                                                                if (v27 == 0) {
                                                                                                    goto lab_0x1bd80;
                                                                                                } else {
                                                                                                    // 0x1bd70
                                                                                                    v29 = *(int32_t *)v27;
                                                                                                    if (v29 == 1) {
                                                                                                        if (v28 != (char *)4 && v28 >= (char *)4) {
                                                                                                            // 0x1bdf4
                                                                                                            str = (char *)0x3a6e6166;
                                                                                                            function_2e584(4, (int32_t *)&str, 0);
                                                                                                        }
                                                                                                        // 0x1be1c
                                                                                                        str5 = NULL;
                                                                                                        str4 = NULL;
                                                                                                        if (function_4e5a0(v27) == 0) {
                                                                                                            goto lab_0x1c070;
                                                                                                        } else {
                                                                                                            int32_t v81 = 0x1b74;
                                                                                                            v23 = 0;
                                                                                                            int32_t v82 = function_4e5bc(v27, v23); // 0x1bf1c
                                                                                                            while (v82 != 0) {
                                                                                                                // 0x1bf28
                                                                                                                if (*(int32_t *)v82 != 0) {
                                                                                                                    // break -> 0x1bfb8
                                                                                                                    break;
                                                                                                                }
                                                                                                                // 0x1bf34
                                                                                                                v30 = function_4e234(v82, "id");
                                                                                                                if (v30 == 0) {
                                                                                                                    // 0x1bf34
                                                                                                                    v6 = g289;
                                                                                                                    v19 = v81;
                                                                                                                    goto lab_0x1c048;
                                                                                                                }
                                                                                                                char * v83 = g289; // 0x1bf48
                                                                                                                int32_t v84 = (int32_t)v83; // 0x1bf48
                                                                                                                v6 = v83;
                                                                                                                v19 = v84;
                                                                                                                if (*(int32_t *)v30 != 3) {
                                                                                                                    goto lab_0x1c048;
                                                                                                                }
                                                                                                                int32_t v85 = v84; // 0x1bf58
                                                                                                                if (v83 != (char *)4 && v83 >= (char *)4) {
                                                                                                                    // 0x1bf5c
                                                                                                                    snprintf((char *)&str, 2048, "id: %d\n", function_4e9c4(v30));
                                                                                                                    function_2e584(4, (int32_t *)&str, 0);
                                                                                                                    v85 = 0;
                                                                                                                }
                                                                                                                // 0x1be54
                                                                                                                v31 = function_4e234(v82, "position");
                                                                                                                if (v31 == 0) {
                                                                                                                    // 0x1be54
                                                                                                                    v4 = g289;
                                                                                                                    v17 = v85;
                                                                                                                    goto lab_0x1bff8;
                                                                                                                }
                                                                                                                int32_t v86 = *(int32_t *)v31; // 0x1be68
                                                                                                                char * v87 = g289; // 0x1be6c
                                                                                                                v4 = v87;
                                                                                                                v17 = v86;
                                                                                                                if (v86 != 2) {
                                                                                                                    goto lab_0x1bff8;
                                                                                                                }
                                                                                                                int32_t v88 = 2; // 0x1be7c
                                                                                                                if (v87 >= (char *)4 == (v87 != (char *)4)) {
                                                                                                                    // 0x1bf88
                                                                                                                    snprintf((char *)&str, 2048, "position: %s\n", (char *)function_4e768(v31));
                                                                                                                    function_2e584(4, (int32_t *)&str, 0);
                                                                                                                    v88 = 0;
                                                                                                                }
                                                                                                                int32_t v89 = function_4e768(v31); // 0x1be84
                                                                                                                v32 = function_4e234(v82, "direction");
                                                                                                                if (v32 == 0) {
                                                                                                                    // 0x1be80
                                                                                                                    v5 = g289;
                                                                                                                    v18 = v88;
                                                                                                                    goto lab_0x1c020;
                                                                                                                }
                                                                                                                char * v90 = g289; // 0x1bea8
                                                                                                                int32_t v91 = (int32_t)v90; // 0x1bea8
                                                                                                                v5 = v90;
                                                                                                                v18 = v91;
                                                                                                                if (*(int32_t *)v32 != 2) {
                                                                                                                    goto lab_0x1c020;
                                                                                                                }
                                                                                                                int32_t v92 = v91; // 0x1beb8
                                                                                                                if (v90 != (char *)4 && v90 >= (char *)4) {
                                                                                                                    int32_t v93 = function_4e768(v32); // 0x1bebc
                                                                                                                    snprintf((char *)&str, 2048, "direction: %s\n", (char *)v93);
                                                                                                                    function_2e584(4, (int32_t *)&str, 0);
                                                                                                                    v92 = 0;
                                                                                                                }
                                                                                                                int32_t v94 = v23 + 1; // 0x1beec
                                                                                                                int32_t v95 = function_4e768(v32); // 0x1bef0
                                                                                                                g197++;
                                                                                                                if (v94 >= function_4e5a0(v27)) {
                                                                                                                    // 0x1bf04
                                                                                                                    str5 = (char *)v95;
                                                                                                                    str4 = (char *)v89;
                                                                                                                    goto lab_0x1c070;
                                                                                                                }
                                                                                                                v81 = v92;
                                                                                                                v23 = v94;
                                                                                                                v82 = function_4e5bc(v27, v23);
                                                                                                            }
                                                                                                            char * v96 = g289; // 0x1bfb8
                                                                                                            v8 = v82;
                                                                                                            v10 = v23;
                                                                                                            v16 = v81;
                                                                                                            result = -1;
                                                                                                            format = (int32_t)"get array %d failed\n";
                                                                                                            if (v96 == (char *)3 || v96 < (char *)3) {
                                                                                                                goto lab_0x1b540;
                                                                                                            } else {
                                                                                                                goto lab_0x1bfdc;
                                                                                                            }
                                                                                                        }
                                                                                                    } else {
                                                                                                        goto lab_0x1bd80;
                                                                                                    }
                                                                                                }
                                                                                            } else {
                                                                                                goto lab_0x1bcd4;
                                                                                            }
                                                                                        }
                                                                                    } else {
                                                                                        goto lab_0x1bc5c;
                                                                                    }
                                                                                }
                                                                            } else {
                                                                                goto lab_0x1bb68;
                                                                            }
                                                                        }
                                                                    } else {
                                                                        goto lab_0x1ba38;
                                                                    }
                                                                }
                                                            } else {
                                                                goto lab_0x1bab0;
                                                            }
                                                        }
                                                    } else {
                                                        goto lab_0x1b8c4;
                                                    }
                                                }
                                            } else {
                                                goto lab_0x1b93c;
                                            }
                                        }
                                    } else {
                                        goto lab_0x1b7e8;
                                    }
                                }
                            } else {
                                goto lab_0x1b6bc;
                            }
                        }
                    }
                } else {
                    goto lab_0x1b534;
                }
            }
        } else {
            goto lab_0x1b4e0;
        }
    }
  lab_0x1c048:;
    char * v97 = v6; // 0x1c048
    v8 = v30;
    v10 = (int32_t)"id";
    v16 = v19;
    result = -1;
    format = (int32_t)"get arrya %d id failed\n";
    if (v97 == (char *)3 || v97 < (char *)3) {
        goto lab_0x1b540;
    } else {
        goto lab_0x1bfdc;
    }
  lab_0x1bff8:;
    char * v98 = v4; // 0x1bff8
    v8 = v31;
    v10 = (int32_t)"position";
    v16 = v17;
    result = -1;
    format = (int32_t)"get arrya %d position failed\n";
    if (v98 == (char *)3 || v98 < (char *)3) {
        goto lab_0x1b540;
    } else {
        goto lab_0x1bfdc;
    }
  lab_0x1c020:;
    char * v99 = v5; // 0x1c020
    v8 = v32;
    v10 = (int32_t)"direction";
    v16 = v18;
    result = -1;
    format = (int32_t)"get arrya%d direction failed\n";
    if (v99 == (char *)3 || v99 < (char *)3) {
        goto lab_0x1b540;
    } else {
        goto lab_0x1bfdc;
    }
  lab_0x1cdf0:;
    // 0x1cdf0
    int32_t v100; // 0x1c778
    int32_t v101 = function_4e234(v100, "pic"); // 0x1cdfc
    char * v102; // 0x1b4ac
    char * v103; // 0x1b4ac
    char * v104; // 0x1b4ac
    char * v105; // 0x1b4ac
    char * v106; // 0x1b4ac
    char * v107; // 0x1b4ac
    char * v108; // 0x1b4ac
    int32_t v109; // 0x1b4ac
    int32_t v110; // 0x1b4ac
    int32_t v111; // 0x1b4ac
    int32_t v112; // 0x1b4ac
    int32_t v113; // 0x1b4ac
    int32_t v114; // 0x1b4ac
    int32_t v115; // 0x1b4ac
    int32_t format3; // 0x1b4ac
    int32_t v116; // 0x1b4ac
    int32_t v117; // 0x1b4ac
    int32_t v118; // 0x1b4ac
    int32_t v119; // 0x1b4ac
    int32_t v120; // 0x1b4ac
    int32_t v121; // 0x1cebc
    int32_t v122; // 0x1cf58
    int32_t v123; // 0x1d004
    int32_t v124; // 0x1d14c
    int32_t v125; // 0x1d1cc
    int32_t v126; // 0x1d228
    int32_t v127; // 0x1d290
    if (v101 == 0) {
        // 0x1cdf0
        v102 = g289;
        v111 = v110;
        goto lab_0x1ce18;
    } else {
        int32_t v128 = *(int32_t *)v101; // 0x1ce08
        char * v129 = g289; // 0x1ce0c
        v102 = v129;
        v111 = v128;
        if (v128 == 0) {
            if (v129 != (char *)4 && v129 >= (char *)4) {
                // 0x1ce8c
                str = (char *)0x3a636970;
                function_2e584(4, (int32_t *)&str, 0);
            }
            // 0x1ceb0
            v121 = function_4e234(v101, "type");
            if (v121 == 0) {
                // 0x1ceb0
                v103 = g289;
                v112 = 0;
                goto lab_0x1ced8;
            } else {
                int32_t v130 = *(int32_t *)v121; // 0x1cec8
                char * v131 = g289; // 0x1cecc
                v103 = v131;
                v112 = v130;
                if (v130 == 2) {
                    int32_t v132 = 2; // 0x1cf1c
                    if (v131 != (char *)4 && v131 >= (char *)4) {
                        // 0x1cf20
                        snprintf((char *)&str, 2048, "type: %s\n", (char *)function_4e768(v121));
                        function_2e584(4, (int32_t *)&str, 0);
                        v132 = 0;
                    }
                    // 0x1cf4c
                    v122 = function_4e234(v101, "i2c_addr");
                    if (v122 == 0) {
                        // 0x1cf4c
                        v104 = g289;
                        v113 = v132;
                        goto lab_0x1cf74;
                    } else {
                        int32_t v133 = *(int32_t *)v122; // 0x1cf64
                        char * v134 = g289; // 0x1cf68
                        v104 = v134;
                        v113 = v133;
                        if (v133 == 3) {
                            // 0x1cfb8
                            v114 = 3;
                            int32_t v135 = (int32_t)v134; // 0x1cfbc
                            if (v134 != (char *)4 && v134 >= (char *)4) {
                                // 0x1cfc0
                                v135 = function_4e9c4(v122);
                                snprintf((char *)&str, 2048, "i2c_addr: %d\n", v135);
                                function_2e584(4, (int32_t *)&str, 0);
                                v114 = 0;
                            }
                            int32_t v136 = function_4e234(v101, "sensor"); // 0x1cff8
                            v123 = v135;
                            if (v136 == 0) {
                                goto lab_0x1d010;
                            } else {
                                // 0x1d004
                                v123 = *(int32_t *)v136;
                                if (v123 == 1) {
                                    char * v137 = g289; // 0x1d090
                                    int32_t v138 = v114; // 0x1d098
                                    int32_t v139 = (int32_t)v137; // 0x1d098
                                    if (v137 != (char *)4 && v137 >= (char *)4) {
                                        // 0x1d09c
                                        str = (char *)0x20636970;
                                        v25 = (char *)0xa3a726f;
                                        function_2e584(4, (int32_t *)&str, 0);
                                        v138 = 0;
                                        v139 = 0;
                                    }
                                    // 0x1d0c4
                                    g194 = function_4e5a0(v136);
                                    int32_t v140 = function_11eb0(function_4e5a0(v136), 12, v138, v139); // 0x1d0dc
                                    g195 = v140;
                                    if (v140 == 0) {
                                        char * v141 = g289; // 0x1d3e8
                                        v8 = 0;
                                        v10 = 12;
                                        v16 = v138;
                                        result = -1;
                                        if (v141 == (char *)3 || v141 < (char *)3) {
                                            goto lab_0x1b540;
                                        } else {
                                            // 0x1d3f4
                                            snprintf((char *)&str, 2048, "malloc %d sensor_t failed\n", function_4e5a0(v136));
                                            v109 = function_2e584(3, (int32_t *)&str, 0);
                                            goto lab_0x1ce48;
                                        }
                                    } else {
                                        // 0x1d118
                                        v119 = (int32_t)"index: %d\n";
                                        if (function_4e5a0(v136) == 0) {
                                            goto lab_0x1d42c;
                                        } else {
                                            int32_t v142 = (int32_t)"index: %d\n";
                                            v120 = 0;
                                            int32_t v143 = function_4e5bc(v136, v120); // 0x1d130
                                            while (v143 != 0) {
                                                // 0x1d13c
                                                if (*(int32_t *)v143 != 0) {
                                                    // break -> 0x1d3c4
                                                    break;
                                                }
                                                // 0x1d148
                                                v124 = function_4e234(v143, "index");
                                                if (v124 == 0) {
                                                    // 0x1d148
                                                    v108 = g289;
                                                    v118 = v142;
                                                    goto lab_0x1d3a0;
                                                }
                                                int32_t v144 = *(int32_t *)v124; // 0x1d158
                                                char * v145 = g289; // 0x1d15c
                                                v108 = v145;
                                                v118 = v144;
                                                if (v144 != 3) {
                                                    goto lab_0x1d3a0;
                                                }
                                                int32_t v146 = 3; // 0x1d16c
                                                if (v145 != (char *)4 && v145 >= (char *)4) {
                                                    // 0x1d170
                                                    snprintf((char *)&str, 2048, "index: %d\n", function_4e9c4(v124));
                                                    function_2e584(4, (int32_t *)&str, 0);
                                                    v146 = 0;
                                                }
                                                int32_t v147 = v146;
                                                int32_t v148 = function_4e9c4(v124); // 0x1d1a8
                                                int32_t v149 = function_4e9c4(v124); // 0x1d1b4
                                                int32_t v150 = 12 * v148 + g195; // 0x1d1c0
                                                *(int32_t *)v150 = v149;
                                                v125 = function_4e234(v143, "type");
                                                if (v125 == 0) {
                                                    // 0x1d198
                                                    v107 = g289;
                                                    v117 = v147;
                                                    goto lab_0x1d37c;
                                                }
                                                int32_t v151 = *(int32_t *)v125; // 0x1d1d8
                                                char * v152 = g289; // 0x1d1dc
                                                v107 = v152;
                                                v117 = v151;
                                                if (v151 != 2) {
                                                    goto lab_0x1d37c;
                                                }
                                                int32_t v153 = 2; // 0x1d1ec
                                                if (v152 != (char *)4 && v152 >= (char *)4) {
                                                    // 0x1d1f0
                                                    snprintf((char *)&str, 2048, "type: %s\n", (char *)function_4e768(v125));
                                                    function_2e584(4, (int32_t *)&str, 0);
                                                    v153 = 0;
                                                }
                                                // 0x1d21c
                                                v126 = function_4e234(v143, "iic");
                                                if (v126 == 0) {
                                                    // 0x1d21c
                                                    v106 = g289;
                                                    v116 = v153;
                                                    goto lab_0x1d358;
                                                }
                                                int32_t v154 = *(int32_t *)v126; // 0x1d234
                                                char * v155 = g289; // 0x1d238
                                                v106 = v155;
                                                v116 = v154;
                                                if (v154 != 3) {
                                                    goto lab_0x1d358;
                                                }
                                                int32_t v156 = 3; // 0x1d248
                                                if (v155 != (char *)4 && v155 >= (char *)4) {
                                                    // 0x1d24c
                                                    snprintf((char *)&str, 2048, "iic: %d\n", function_4e9c4(v126));
                                                    function_2e584(4, (int32_t *)&str, 0);
                                                    v156 = 0;
                                                }
                                                int32_t v157 = v156;
                                                *(int32_t *)(v150 + 4) = function_4e9c4(v126);
                                                v127 = function_4e234(v143, "x");
                                                if (v127 == 0) {
                                                    // 0x1d278
                                                    v105 = g289;
                                                    v115 = v157;
                                                    goto lab_0x1d31c;
                                                }
                                                int32_t v158 = *(int32_t *)v127; // 0x1d29c
                                                char * v159 = g289; // 0x1d2a0
                                                v105 = v159;
                                                v115 = v158;
                                                if (v158 != 2) {
                                                    goto lab_0x1d31c;
                                                }
                                                int32_t v160 = 2; // 0x1d2b0
                                                if (v159 != (char *)4 && v159 >= (char *)4) {
                                                    // 0x1d2b4
                                                    snprintf((char *)&str, 2048, "x: %s\n", (char *)function_4e768(v127));
                                                    function_2e584(4, (int32_t *)&str, 0);
                                                    v160 = 0;
                                                }
                                                int32_t v161 = v160; // 0x1d2e8
                                                if (g196 == NULL) {
                                                    // 0x1d2ec
                                                    if (strncasecmp((char *)function_4e768(v127), "right", 5) == 0) {
                                                        // .critedge
                                                        *(char *)(v150 + 8) = 1;
                                                        v161 = 5;
                                                    } else {
                                                        *(char *)(v150 + 8) = (char)(int32_t)g196;
                                                        v161 = 5;
                                                    }
                                                }
                                                int32_t v162 = v120 + 1; // 0x1d314
                                                v119 = v161;
                                                if (v162 >= function_4e5a0(v136)) {
                                                    goto lab_0x1d42c;
                                                }
                                                v142 = v161;
                                                v120 = v162;
                                                v143 = function_4e5bc(v136, v120);
                                            }
                                            char * v163 = g289; // 0x1d3c4
                                            v8 = v143;
                                            v10 = v120;
                                            v16 = v142;
                                            result = -1;
                                            format3 = (int32_t)"get array %d failed\n";
                                            if (v163 == (char *)3 || v163 < (char *)3) {
                                                goto lab_0x1b540;
                                            } else {
                                                goto lab_0x1d33c;
                                            }
                                        }
                                    }
                                } else {
                                    goto lab_0x1d010;
                                }
                            }
                        } else {
                            goto lab_0x1cf74;
                        }
                    }
                } else {
                    goto lab_0x1ced8;
                }
            }
        } else {
            goto lab_0x1ce18;
        }
    }
  lab_0x1cdc4:;
    char * v164 = g289; // 0x1cdc4
    v8 = 0;
    v10 = 8;
    int32_t v165; // 0x1b4ac
    v16 = v165;
    result = -1;
    int32_t format2 = (int32_t)"malloc %d domain_t failed\n"; // 0x1cdd4
    int32_t v166 = g182; // 0x1cdd4
    if (v164 == (char *)3 || v164 < (char *)3) {
        goto lab_0x1b540;
    } else {
        goto lab_0x1cd40;
    }
  lab_0x1d3a0:;
    char * v167 = v108; // 0x1d3a0
    v8 = v124;
    v10 = (int32_t)"index";
    v16 = v118;
    result = -1;
    format3 = (int32_t)"get array %d index failed\n";
    if (v167 == (char *)3 || v167 < (char *)3) {
        goto lab_0x1b540;
    } else {
        goto lab_0x1d33c;
    }
  lab_0x1d37c:;
    char * v168 = v107; // 0x1d37c
    v8 = v125;
    v10 = (int32_t)"type";
    v16 = v117;
    result = -1;
    format3 = (int32_t)"get array %d type failed\n";
    if (v168 == (char *)3 || v168 < (char *)3) {
        goto lab_0x1b540;
    } else {
        goto lab_0x1d33c;
    }
  lab_0x1d358:;
    char * v169 = v106; // 0x1d358
    v8 = v126;
    v10 = (int32_t)"iic";
    v16 = v116;
    result = -1;
    format3 = (int32_t)"get array %d bind_asic failed\n";
    if (v169 == (char *)3 || v169 < (char *)3) {
        goto lab_0x1b540;
    } else {
        goto lab_0x1d33c;
    }
  lab_0x1d31c:;
    char * v170 = v105; // 0x1d31c
    v8 = v127;
    v10 = (int32_t)"x";
    v16 = v115;
    result = -1;
    format3 = (int32_t)"get array %d x failed\n";
    if (v170 == (char *)3 || v170 < (char *)3) {
        goto lab_0x1b540;
    } else {
        goto lab_0x1d33c;
    }
  lab_0x1d42c:;
    int32_t v171 = function_4e234(v100, "eeprom"); // 0x1d438
    char * v172; // 0x1b4ac
    char * v173; // 0x1b4ac
    char * v174; // 0x1b4ac
    char * v175; // 0x1b4ac
    char * v176; // 0x1b4ac
    char * v177; // 0x1b4ac
    char * v178; // 0x1b4ac
    int32_t v179; // 0x1b4ac
    int32_t v180; // 0x1b4ac
    int32_t v181; // 0x1b4ac
    int32_t v182; // 0x1b4ac
    int32_t v183; // 0x1b4ac
    int32_t v184; // 0x1b4ac
    int32_t format4; // 0x1b4ac
    int32_t v185; // 0x1b4ac
    int32_t v186; // 0x1b4ac
    int32_t v187; // 0x1b4ac
    int32_t v188; // 0x1d4f0
    int32_t v189; // 0x1d58c
    int32_t v190; // 0x1d62c
    int32_t v191; // 0x1d760
    int32_t v192; // 0x1d7c8
    int32_t v193; // 0x1d824
    if (v171 == 0) {
        // 0x1d42c
        v172 = g289;
        goto lab_0x1d454;
    } else {
        char * v194 = g289; // 0x1d448
        v172 = v194;
        if (*(int32_t *)v171 == 0) {
            int32_t v195 = v119; // 0x1d4b8
            if (v194 != (char *)4 && v194 >= (char *)4) {
                // 0x1d4bc
                str = (char *)0x72706565;
                v25 = NULL;
                function_2e584(4, (int32_t *)&str, 0);
                v195 = 0;
            }
            // 0x1d4e4
            v188 = function_4e234(v171, "type");
            if (v188 == 0) {
                // 0x1d4e4
                v173 = g289;
                v180 = v195;
                goto lab_0x1d50c;
            } else {
                int32_t v196 = *(int32_t *)v188; // 0x1d4fc
                char * v197 = g289; // 0x1d500
                v173 = v197;
                v180 = v196;
                if (v196 == 2) {
                    int32_t v198 = 2; // 0x1d550
                    if (v197 != (char *)4 && v197 >= (char *)4) {
                        // 0x1d554
                        snprintf((char *)&str, 2048, "type: %s\n", (char *)function_4e768(v188));
                        function_2e584(4, (int32_t *)&str, 0);
                        v198 = 0;
                    }
                    // 0x1d580
                    v189 = function_4e234(v171, "i2c_addr");
                    if (v189 == 0) {
                        // 0x1d580
                        v174 = g289;
                        v181 = v198;
                        goto lab_0x1d5a8;
                    } else {
                        int32_t v199 = *(int32_t *)v189; // 0x1d598
                        char * v200 = g289; // 0x1d59c
                        v174 = v200;
                        v181 = v199;
                        if (v199 == 3) {
                            int32_t v201 = 3; // 0x1d5f0
                            if (v200 != (char *)4 && v200 >= (char *)4) {
                                // 0x1d5f4
                                snprintf((char *)&str, 2048, "i2c_addr: %d\n", function_4e9c4(v189));
                                function_2e584(4, (int32_t *)&str, 0);
                                v201 = 0;
                            }
                            // 0x1d620
                            v190 = function_4e234(v100, "sensor");
                            if (v190 == 0) {
                                // 0x1d620
                                v175 = g289;
                                v182 = v201;
                                goto lab_0x1d648;
                            } else {
                                int32_t v202 = *(int32_t *)v190; // 0x1d638
                                char * v203 = g289; // 0x1d63c
                                v175 = v203;
                                v182 = v202;
                                if (v202 == 1) {
                                    int32_t v204 = 1; // 0x1d6ac
                                    int32_t v205 = (int32_t)v203; // 0x1d6ac
                                    if (v203 != (char *)4 && v203 >= (char *)4) {
                                        // 0x1d6b0
                                        str = (char *)0x736e6573;
                                        v25 = NULL;
                                        function_2e584(4, (int32_t *)&str, 0);
                                        v204 = 0;
                                        v205 = (int32_t)&v25;
                                    }
                                    // 0x1d6d8
                                    g185 = function_4e5a0(v190);
                                    int32_t v206 = function_11eb0(function_4e5a0(v190), 12, v204, v205); // 0x1d6f0
                                    g193 = v206;
                                    if (v206 == 0) {
                                        char * v207 = g289; // 0x1d9c0
                                        v8 = 0;
                                        v10 = 12;
                                        v16 = v204;
                                        result = -1;
                                        if (v207 == (char *)3 || v207 < (char *)3) {
                                            goto lab_0x1b540;
                                        } else {
                                            // 0x1d9cc
                                            snprintf((char *)&str, 2048, "malloc %d sensor_t failed\n", function_4e5a0(v190));
                                            v179 = function_2e584(3, (int32_t *)&str, 0);
                                            goto lab_0x1d68c;
                                        }
                                    } else {
                                        // 0x1d72c
                                        v183 = (int32_t)"index: %d\n";
                                        if (function_4e5a0(v190) == 0) {
                                            goto lab_0x1d930;
                                        } else {
                                            int32_t v208 = (int32_t)"index: %d\n";
                                            v187 = 0;
                                            int32_t v209 = function_4e5bc(v190, v187); // 0x1d744
                                            while (v209 != 0) {
                                                // 0x1d750
                                                if (*(int32_t *)v209 != 0) {
                                                    // break -> 0x1d90c
                                                    break;
                                                }
                                                // 0x1d75c
                                                v191 = function_4e234(v209, "index");
                                                if (v191 == 0) {
                                                    // 0x1d75c
                                                    v178 = g289;
                                                    v186 = v208;
                                                    goto lab_0x1d8e8;
                                                }
                                                int32_t v210 = *(int32_t *)v191; // 0x1d76c
                                                char * v211 = g289; // 0x1d770
                                                v178 = v211;
                                                v186 = v210;
                                                if (v210 != 3) {
                                                    goto lab_0x1d8e8;
                                                }
                                                int32_t v212 = 3; // 0x1d780
                                                if (v211 != (char *)4 && v211 >= (char *)4) {
                                                    // 0x1d784
                                                    snprintf((char *)&str, 2048, "index: %d\n", function_4e9c4(v191));
                                                    function_2e584(4, (int32_t *)&str, 0);
                                                    v212 = 0;
                                                }
                                                int32_t v213 = function_4e9c4(v191); // 0x1d7b8
                                                v192 = function_4e234(v209, "type");
                                                if (v192 == 0) {
                                                    // 0x1d7ac
                                                    v177 = g289;
                                                    v185 = v212;
                                                    goto lab_0x1d8c4;
                                                }
                                                int32_t v214 = *(int32_t *)v192; // 0x1d7d4
                                                char * v215 = g289; // 0x1d7d8
                                                v177 = v215;
                                                v185 = v214;
                                                if (v214 != 2) {
                                                    goto lab_0x1d8c4;
                                                }
                                                int32_t v216 = 2; // 0x1d7e8
                                                if (v215 != (char *)4 && v215 >= (char *)4) {
                                                    // 0x1d7ec
                                                    snprintf((char *)&str, 2048, "type: %s\n", (char *)function_4e768(v192));
                                                    function_2e584(4, (int32_t *)&str, 0);
                                                    v216 = 0;
                                                }
                                                // 0x1d818
                                                v193 = function_4e234(v209, "bind_asic");
                                                if (v193 == 0) {
                                                    // 0x1d818
                                                    v176 = g289;
                                                    v184 = v216;
                                                    goto lab_0x1d888;
                                                }
                                                int32_t v217 = *(int32_t *)v193; // 0x1d830
                                                char * v218 = g289; // 0x1d834
                                                v176 = v218;
                                                v184 = v217;
                                                if (v217 != 3) {
                                                    goto lab_0x1d888;
                                                }
                                                int32_t v219 = 3; // 0x1d844
                                                if (v218 != (char *)4 && v218 >= (char *)4) {
                                                    // 0x1d848
                                                    snprintf((char *)&str, 2048, "bind_asic: %d\n", function_4e9c4(v193));
                                                    function_2e584(4, (int32_t *)&str, 0);
                                                    v219 = 0;
                                                }
                                                int32_t v220 = v187 + 1; // 0x1d878
                                                int32_t v221 = function_4e9c4(v193); // 0x1d87c
                                                *(int32_t *)(g193 + 4 + 12 * v213) = v221;
                                                v183 = v219;
                                                if (v220 >= function_4e5a0(v190)) {
                                                    goto lab_0x1d930;
                                                }
                                                v208 = v219;
                                                v187 = v220;
                                                v209 = function_4e5bc(v190, v187);
                                            }
                                            char * v222 = g289; // 0x1d90c
                                            v8 = v209;
                                            v10 = v187;
                                            v16 = v208;
                                            result = -1;
                                            format4 = (int32_t)"get array %d failed\n";
                                            if (v222 == (char *)3 || v222 < (char *)3) {
                                                goto lab_0x1b540;
                                            } else {
                                                goto lab_0x1d8a8;
                                            }
                                        }
                                    }
                                } else {
                                    goto lab_0x1d648;
                                }
                            }
                        } else {
                            goto lab_0x1d5a8;
                        }
                    }
                } else {
                    goto lab_0x1d50c;
                }
            }
        } else {
            goto lab_0x1d454;
        }
    }
  lab_0x1d8e8:;
    char * v223 = v178; // 0x1d8e8
    v8 = v191;
    v10 = (int32_t)"index";
    v16 = v186;
    result = -1;
    format4 = (int32_t)"get array %d index failed\n";
    if (v223 == (char *)3 || v223 < (char *)3) {
        goto lab_0x1b540;
    } else {
        goto lab_0x1d8a8;
    }
  lab_0x1d8c4:;
    char * v224 = v177; // 0x1d8c4
    v8 = v192;
    v10 = (int32_t)"type";
    v16 = v185;
    result = -1;
    format4 = (int32_t)"get array %d type failed\n";
    if (v224 == (char *)3 || v224 < (char *)3) {
        goto lab_0x1b540;
    } else {
        goto lab_0x1d8a8;
    }
  lab_0x1d888:;
    char * v225 = v176; // 0x1d888
    v8 = v193;
    v10 = (int32_t)"bind_asic";
    v16 = v184;
    result = -1;
    format4 = (int32_t)"get array %d bind_asic failed\n";
    if (v225 == (char *)3 || v225 < (char *)3) {
        goto lab_0x1b540;
    } else {
        goto lab_0x1d8a8;
    }
  lab_0x1d930:;
    int32_t v226 = function_4e234(v100, "domain"); // 0x1d93c
    char * v227; // 0x1b4ac
    char * v228; // 0x1b4ac
    char * v229; // 0x1b4ac
    char * v230; // 0x1b4ac
    char * v231; // 0x1b4ac
    char * v232; // 0x1b4ac
    int32_t v233; // 0x1b4ac
    int32_t v234; // 0x1b4ac
    int32_t v235; // 0x1b4ac
    int32_t v236; // 0x1b4ac
    int32_t v237; // 0x1b4ac
    int32_t v238; // 0x1b4ac
    int32_t v239; // 0x1b4ac
    int32_t v240; // 0x1b4ac
    int32_t v241; // 0x1b4ac
    int32_t v242; // 0x1b4ac
    int32_t format5; // 0x1b4ac
    int32_t v243; // 0x1da94
    int32_t v244; // 0x1dae8
    int32_t v245; // 0x1dc8c
    int32_t v246; // 0x1dca8
    int32_t v247; // 0x1dcf8
    int32_t v248; // 0x1dd20
    int32_t v249; // 0x1dd3c
    int32_t v250; // 0x1dda0
    if (v226 == 0) {
        // 0x1d930
        v227 = g289;
        v233 = v183;
        goto lab_0x1d960;
    } else {
        int32_t v251 = *(int32_t *)v226; // 0x1d950
        char * v252 = g289; // 0x1d954
        v227 = v252;
        v233 = v251;
        if (v251 == 1) {
            if (v252 != (char *)4 && v252 >= (char *)4) {
                // 0x1da0c
                str = (char *)0x616d6f64;
                v25 = NULL;
                function_2e584(4, (int32_t *)&str, 0);
            }
            // 0x1da34
            v234 = (int32_t)"index: %d\n";
            if (function_4e5a0(v226) == 0) {
                goto lab_0x1dbbc;
            } else {
                int32_t v253 = (int32_t)"index: %d\n";
                v241 = 0;
                int32_t v254 = function_4e5bc(v226, v241); // 0x1da78
                while (v254 != 0) {
                    // 0x1da84
                    if (*(int32_t *)v254 != 0) {
                        // break -> 0x1db7c
                        break;
                    }
                    // 0x1da90
                    v243 = function_4e234(v254, "index");
                    if (v243 == 0) {
                        // 0x1da90
                        v229 = g289;
                        v236 = v253;
                        goto lab_0x1dc04;
                    }
                    int32_t v255 = *(int32_t *)v243; // 0x1daa0
                    char * v256 = g289; // 0x1daa4
                    v229 = v256;
                    v236 = v255;
                    if (v255 != 3) {
                        goto lab_0x1dc04;
                    }
                    int32_t v257 = 3; // 0x1dab4
                    if (v256 != (char *)4 && v256 >= (char *)4) {
                        // 0x1dab8
                        snprintf((char *)&str, 2048, "index: %d\n", function_4e9c4(v243));
                        function_2e584(4, (int32_t *)&str, 0);
                        v257 = 0;
                    }
                    // 0x1dae0
                    v244 = function_4e234(v254, "asic");
                    if (v244 == 0) {
                        // 0x1dae0
                        v228 = g289;
                        v235 = v257;
                        goto lab_0x1db04;
                    }
                    int32_t v258 = *(int32_t *)v244; // 0x1daf4
                    char * v259 = g289; // 0x1daf8
                    v228 = v259;
                    v235 = v258;
                    if (v258 != 1) {
                        goto lab_0x1db04;
                    }
                    int32_t v260 = 1; // 0x1dc30
                    if (v259 != (char *)4 && v259 >= (char *)4) {
                        // 0x1dc34
                        str = (char *)0x63697361;
                        function_2e584(4, (int32_t *)&str, 0);
                        v260 = 0;
                    }
                    int32_t v261 = v260; // 0x1dc80
                    int32_t v262 = v260; // 0x1dc80
                    if (function_4e5a0(v244) != 0) {
                        v237 = v261;
                        v242 = 0;
                        v245 = function_4e5bc(v244, v242);
                        if (v245 == 0) {
                            goto lab_0x1debc_2;
                        }
                        // 0x1dc98
                        if (*(int32_t *)v245 != 0) {
                            goto lab_0x1debc_2;
                        }
                        // 0x1dca4
                        v246 = function_4e234(v245, "index");
                        if (v246 == 0) {
                            // 0x1dca4
                            v232 = g289;
                            v240 = v237;
                            goto lab_0x1de94;
                        }
                        int32_t v263 = *(int32_t *)v246; // 0x1dcb4
                        char * v264 = g289; // 0x1dcb8
                        v232 = v264;
                        v240 = v263;
                        if (v263 != 3) {
                            goto lab_0x1de94;
                        }
                        if (v264 != (char *)4 && v264 >= (char *)4) {
                            // 0x1dccc
                            snprintf((char *)&str, 2048, "index: %d\n", function_4e9c4(v246));
                            function_2e584(4, (int32_t *)&str, 0);
                        }
                        // 0x1dcf4
                        v247 = function_4e9c4(v246);
                        int32_t v265 = *(int32_t *)(g192 + 8) + 28 * v247; // 0x1dd18
                        *(int32_t *)v265 = v247;
                        v248 = function_4e234(v245, "coordinate");
                        if (v248 == 0) {
                            goto lab_0x1de6c_2;
                        }
                        // 0x1dd2c
                        if (*(int32_t *)v248 != 1) {
                            goto lab_0x1de6c_2;
                        }
                        // 0x1dd38
                        v249 = function_4e5bc(v248, 0);
                        if (v249 == 0) {
                            // 0x1dd38
                            v231 = g289;
                            v239 = v247;
                            goto lab_0x1de44;
                        }
                        int32_t v266 = *(int32_t *)v249; // 0x1dd48
                        char * v267 = g289; // 0x1dd4c
                        v231 = v267;
                        v239 = v266;
                        if (v266 != 3) {
                            goto lab_0x1de44;
                        }
                        int32_t v268 = 3; // 0x1dd5c
                        if (v267 != (char *)4 && v267 >= (char *)4) {
                            // 0x1dd60
                            snprintf((char *)&str, 2048, "x: %d\n", function_4e9c4(v249));
                            function_2e584(4, (int32_t *)&str, 0);
                            v268 = 0;
                        }
                        int32_t v269 = v268;
                        *(int32_t *)(v265 + 4) = function_4e9c4(v249);
                        v250 = function_4e5bc(v248, 1);
                        if (v250 == 0) {
                            // 0x1dd8c
                            v230 = g289;
                            v238 = v269;
                            goto lab_0x1de04;
                        }
                        int32_t v270 = *(int32_t *)v250; // 0x1ddac
                        char * v271 = g289; // 0x1ddb0
                        v230 = v271;
                        v238 = v270;
                        if (v270 != 3) {
                            goto lab_0x1de04;
                        }
                        int32_t v272 = 3; // 0x1ddc0
                        if (v271 != (char *)4 && v271 >= (char *)4) {
                            // 0x1ddc4
                            snprintf((char *)&str, 2048, "y: %d\n", function_4e9c4(v250));
                            function_2e584(4, (int32_t *)&str, 0);
                            v272 = 0;
                        }
                        int32_t v273 = v242 + 1; // 0x1ddf4
                        *(int32_t *)(v265 + 8) = function_4e9c4(v250);
                        int32_t v274 = v273; // 0x1dc80
                        v261 = v272;
                        v262 = v272;
                        while (v273 < function_4e5a0(v244)) {
                            // 0x1dc84
                            v237 = v261;
                            v242 = v274;
                            v245 = function_4e5bc(v244, v242);
                            if (v245 == 0) {
                                goto lab_0x1debc_2;
                            }
                            // 0x1dc98
                            if (*(int32_t *)v245 != 0) {
                                goto lab_0x1debc_2;
                            }
                            // 0x1dca4
                            v246 = function_4e234(v245, "index");
                            if (v246 == 0) {
                                // 0x1dca4
                                v232 = g289;
                                v240 = v237;
                                goto lab_0x1de94;
                            }
                            // 0x1dcb4
                            v263 = *(int32_t *)v246;
                            v264 = g289;
                            v232 = v264;
                            v240 = v263;
                            if (v263 != 3) {
                                goto lab_0x1de94;
                            }
                            if (v264 != (char *)4 && v264 >= (char *)4) {
                                // 0x1dccc
                                snprintf((char *)&str, 2048, "index: %d\n", function_4e9c4(v246));
                                function_2e584(4, (int32_t *)&str, 0);
                            }
                            // 0x1dcf4
                            v247 = function_4e9c4(v246);
                            v265 = *(int32_t *)(g192 + 8) + 28 * v247;
                            *(int32_t *)v265 = v247;
                            v248 = function_4e234(v245, "coordinate");
                            if (v248 == 0) {
                                goto lab_0x1de6c_2;
                            }
                            // 0x1dd2c
                            if (*(int32_t *)v248 != 1) {
                                goto lab_0x1de6c_2;
                            }
                            // 0x1dd38
                            v249 = function_4e5bc(v248, 0);
                            if (v249 == 0) {
                                // 0x1dd38
                                v231 = g289;
                                v239 = v247;
                                goto lab_0x1de44;
                            }
                            // 0x1dd48
                            v266 = *(int32_t *)v249;
                            v267 = g289;
                            v231 = v267;
                            v239 = v266;
                            if (v266 != 3) {
                                goto lab_0x1de44;
                            }
                            // 0x1dd58
                            v268 = 3;
                            if (v267 != (char *)4 && v267 >= (char *)4) {
                                // 0x1dd60
                                snprintf((char *)&str, 2048, "x: %d\n", function_4e9c4(v249));
                                function_2e584(4, (int32_t *)&str, 0);
                                v268 = 0;
                            }
                            // 0x1dd8c
                            v269 = v268;
                            *(int32_t *)(v265 + 4) = function_4e9c4(v249);
                            v250 = function_4e5bc(v248, 1);
                            if (v250 == 0) {
                                // 0x1dd8c
                                v230 = g289;
                                v238 = v269;
                                goto lab_0x1de04;
                            }
                            // 0x1ddac
                            v270 = *(int32_t *)v250;
                            v271 = g289;
                            v230 = v271;
                            v238 = v270;
                            if (v270 != 3) {
                                goto lab_0x1de04;
                            }
                            // 0x1ddbc
                            v272 = 3;
                            if (v271 != (char *)4 && v271 >= (char *)4) {
                                // 0x1ddc4
                                snprintf((char *)&str, 2048, "y: %d\n", function_4e9c4(v250));
                                function_2e584(4, (int32_t *)&str, 0);
                                v272 = 0;
                            }
                            // 0x1ddf0
                            v273 = v242 + 1;
                            *(int32_t *)(v265 + 8) = function_4e9c4(v250);
                            v274 = v273;
                            v261 = v272;
                            v262 = v272;
                        }
                    }
                    int32_t v275 = v241 + 1; // 0x1dee4
                    v234 = v262;
                    if (v275 >= function_4e5a0(v226)) {
                        goto lab_0x1dbbc;
                    }
                    v253 = v262;
                    v241 = v275;
                    v254 = function_4e5bc(v226, v241);
                }
                char * v276 = g289; // 0x1db7c
                v8 = v254;
                v10 = v241;
                v16 = v253;
                result = -1;
                format5 = (int32_t)"get array %d failed\n";
                if (v276 == (char *)3 || v276 < (char *)3) {
                    goto lab_0x1b540;
                } else {
                    goto lab_0x1dba0;
                }
            }
        } else {
            goto lab_0x1d960;
        }
    }
  lab_0x1e03c:;
    // 0x1e03c
    int32_t v277; // 0x1b4ac
    int32_t v278 = v277; // 0x1e044
    int32_t v279; // 0x1b4ac
    int32_t v280 = v279; // 0x1e044
    char v281 = 0; // 0x1e044
    char * v282; // 0x1df78
    int32_t v283; // 0x1b4ac
    if (v282 != (char *)3 && v282 >= (char *)3) {
        // 0x1e048
        str = (char *)0x20726961;
        v25 = NULL;
        function_2e584(3, (int32_t *)&str, 0);
        v278 = v283;
        v280 = 0;
        v281 = 0;
    }
    goto lab_0x1dfdc;
  lab_0x1dfdc:;
    // 0x1dfdc
    int32_t v284; // 0x1b4ac
    int32_t v285 = v284 + 1; // 0x1dfdc
    int32_t v286; // 0x1df2c
    *(char *)(v286 + 8) = v281;
    v284 = v285;
    int32_t v287 = v278; // 0x1df14
    int32_t v288 = v280; // 0x1df14
    if (v285 >= g185) {
        // break -> 0x1dfe8
        goto lab_0x1dfe8;
    }
    goto lab_0x1df18;
  lab_0x1dc04:;
    char * v301 = v229; // 0x1dc04
    v8 = v243;
    v10 = (int32_t)"index";
    v16 = v236;
    result = -1;
    format5 = (int32_t)"get array %d index failed\n";
    if (v301 == (char *)3 || v301 < (char *)3) {
        goto lab_0x1b540;
    } else {
        goto lab_0x1dba0;
    }
  lab_0x1db04:;
    char * v302 = v228; // 0x1db04
    v8 = v244;
    v10 = (int32_t)"asic";
    v16 = v235;
    result = -1;
    int32_t v303; // 0x1b4ac
    if (v302 == (char *)3 || v302 < (char *)3) {
        goto lab_0x1b540;
    } else {
        // 0x1db14
        str = (char *)0x20746567;
        v25 = (char *)0x69616620;
        v303 = function_2e584(3, (int32_t *)&str, 0);
        goto lab_0x1db44;
    }
  lab_0x1dbbc:;
    int32_t v304 = *(int32_t *)(g192 + 8); // 0x1dbd0
    int32_t v305 = v234; // 0x1dbe0
    int32_t v306 = 1; // 0x1dbe0
    if (g179 > 1) {
        int32_t v307 = 20 * v306 + g192; // 0x1dbec
        int32_t v308 = 28 * g183; // 0x1dbf0
        int32_t v309 = v306 + 1; // 0x1dbf4
        int32_t v310 = *(int32_t *)(v307 + 8); // 0x1dbf8
        function_11fc4((int32_t *)v310, v304, (char)v308, v307);
        v305 = v308;
        while (v309 < g179) {
            // 0x1dbe4
            v307 = 20 * v309 + g192;
            v308 = 28 * g183;
            v309++;
            v310 = *(int32_t *)(v307 + 8);
            function_11fc4((int32_t *)v310, v304, (char)v308, v307);
            v305 = v308;
        }
    }
    // 0x1df0c
    v287 = v304;
    v288 = v305;
    if (g185 > 0) {
        // 0x1df18
        v283 = (int32_t)&str;
        v284 = 0;
        while (true) {
          lab_0x1df18:;
            char * v289 = g289; // 0x1df20
            v286 = g193 + 12 * v284;
            int32_t v290 = (int32_t)g196; // 0x1df30
            int32_t v291 = *(int32_t *)(g192 + 8); // 0x1df34
            int32_t v292 = *(int32_t *)(v286 + 4); // 0x1df3c
            int32_t v293 = 28 * v292 + v291; // 0x1df40
            char * v294 = v289; // 0x1df44
            int32_t v295 = v290; // 0x1df44
            int32_t v296 = v291; // 0x1df44
            if (v289 != (char *)3 && v289 >= (char *)3) {
                int32_t v297 = *(int32_t *)(v293 + 8); // 0x1df48
                snprintf((char *)&str, 2048, "asic %d, wind %d, y %d\n", v292, v290, v297);
                function_2e584(3, (int32_t *)&str, 0);
                v294 = g289;
                v295 = v283;
                v296 = 0;
            }
            // 0x1df74
            v277 = v295;
            v282 = v294;
            v279 = v296;
            char * v298; // 0x1df74
            switch ((int32_t)v298) {
                case 1: {
                    int32_t v299 = (int32_t)g181 / 3; // 0x1e07c
                    v279 = v299;
                    if (*(int32_t *)(v293 + 8) > v299) {
                        goto lab_0x1e03c;
                    } else {
                        // 0x1e088
                        v278 = 0;
                        v280 = v299;
                        v281 = 1;
                        if (v282 != (char *)3 && v282 >= (char *)3) {
                            // 0x1e090
                            str = (char *)0x20726961;
                            function_2e584(3, (int32_t *)&str, 0);
                            v278 = v283;
                            v280 = 0;
                            v281 = 1;
                        }
                        goto lab_0x1dfdc;
                    }
                }
                case 0: {
                    int32_t v300 = 2 * (int32_t)g181 / 3; // 0x1df9c
                    v279 = v300;
                    if (*(int32_t *)(v293 + 8) < v300) {
                        goto lab_0x1e03c;
                    } else {
                        // 0x1dfa8
                        v278 = 0;
                        v280 = v300;
                        v281 = 1;
                        if (v282 != (char *)3 && v282 >= (char *)3) {
                            // 0x1dfb4
                            str = (char *)0x20726961;
                            function_2e584(3, (int32_t *)&str, 0);
                            v278 = v283;
                            v280 = 0;
                            v281 = 1;
                        }
                        goto lab_0x1dfdc;
                    }
                }
                default: {
                    goto lab_0x1e03c;
                }
            }
        }
    }
  lab_0x1dfe8:;
    int32_t v311 = function_1b398(); // 0x1dfe8
    v8 = 0;
    v10 = v287;
    v16 = v288;
    result = 0;
    if (v311 != 0) {
        char * v312 = g289; // 0x1dff4
        v8 = v311;
        v10 = v287;
        v16 = v288;
        result = v311;
        if (v312 != (char *)3 && v312 >= (char *)3) {
            // 0x1e000
            str = (char *)0x74696e69;
            v25 = (char *)0x72206c6f;
            v8 = function_2e584(3, (int32_t *)&str, 0);
            v10 = (int32_t)&str;
            v16 = 0;
            result = v311;
        }
    }
    goto lab_0x1b540;
  lab_0x1debc_2:;
    char * v505 = g289; // 0x1debc
    v8 = v245;
    v10 = v242;
    v16 = v237;
    result = -1;
    int32_t format6 = (int32_t)"get array %d failed\n"; // 0x1dec8
    if (v505 == (char *)3 || v505 < (char *)3) {
        goto lab_0x1b540;
    } else {
        goto lab_0x1de28;
    }
  lab_0x1de94:;
    char * v506 = v232; // 0x1de94
    v8 = v246;
    v10 = (int32_t)"index";
    v16 = v240;
    result = -1;
    format6 = (int32_t)"get array %d index failed\n";
    if (v506 == (char *)3 || v506 < (char *)3) {
        goto lab_0x1b540;
    } else {
        goto lab_0x1de28;
    }
  lab_0x1de6c_2:;
    char * v507 = g289; // 0x1de6c
    v8 = v248;
    v10 = (int32_t)"coordinate";
    v16 = v247;
    result = -1;
    format6 = (int32_t)"get array %d coordinate failed\n";
    if (v507 == (char *)3 || v507 < (char *)3) {
        goto lab_0x1b540;
    } else {
        goto lab_0x1de28;
    }
  lab_0x1de44:;
    char * v508 = v231; // 0x1de44
    v8 = v249;
    v10 = 0;
    v16 = v239;
    result = -1;
    format6 = (int32_t)"get array %d coordinate x failed\n";
    if (v508 == (char *)3 || v508 < (char *)3) {
        goto lab_0x1b540;
    } else {
        goto lab_0x1de28;
    }
  lab_0x1de04:;
    char * v509 = v230; // 0x1de04
    v8 = v250;
    v10 = 1;
    v16 = v238;
    result = -1;
    format6 = (int32_t)"get array %d coordinate y failed\n";
    if (v509 == (char *)3 || v509 < (char *)3) {
        goto lab_0x1b540;
    } else {
        goto lab_0x1de28;
    }
  lab_0x1b4e0:;
    char * v510 = g289; // 0x1b4e8
    if (v510 >= (char *)3 == (v510 != (char *)3)) {
        // 0x1b57c
        snprintf((char *)&str, 2048, "load topol config file %s failed\n", "/etc/topol.conf");
        function_2e584(3, (int32_t *)&str, 0);
        return -1;
    }
    // 0x1b4f8
    return v510 == (char *)3 | v510 < (char *)3 ? -1 : v22;
  lab_0x1b534:;
    uint32_t v511 = v21;
    v8 = v49;
    v10 = (int32_t)"machine";
    v16 = v12;
    result = -1;
    if (v511 >= 3 == (v511 != 3)) {
        int32_t v512 = (int32_t)&str; // 0x1b5d0
        str = (char *)0x20746567;
        v25 = (char *)0x20656e69;
        v9 = function_2e584(3, (int32_t *)&str, 0);
        v11 = v512;
        v24 = v512;
        goto lab_0x1b5fc;
    } else {
        goto lab_0x1b540;
    }
  lab_0x1b540:;
    int32_t v313 = v2 + 4; // 0x1b540
    int32_t * v314 = (int32_t *)v313; // 0x1b540
    if (*v314 == -1) {
        // 0x1b4f8
        return result;
    }
    // 0x1b54c
    __asm_dmb(v8, v10, v16, v313);
    int32_t v315 = *v314;
    int32_t v316 = v315 - 1; // 0x1b558
    while (__asm_strex(v316, v315) != 0) {
        // 0x1b554
        v315 = *v314;
        v316 = v315 - 1;
    }
    // 0x1b568
    if (v316 == 0) {
        // 0x1b570
        function_4eb6c(v2);
    }
    // 0x1b4f8
    return result;
  lab_0x1b5fc:;
    char * v317 = g289; // 0x1b5fc
    v8 = v9;
    v10 = v11;
    v16 = 0;
    result = -1;
    if (v317 != (char *)3 && v317 >= (char *)3) {
        int32_t * v318 = (int32_t *)v24; // 0x1b61c
        *v318 = 0x73726170;
        *(int32_t *)(v24 + 4) = 0x616d2065;
        *(int32_t *)(v24 + 8) = 0x6e696863;
        *(int32_t *)(v24 + 12) = 0x61662065;
        *(int32_t *)(v24 + 16) = 0x64656c69;
        *(int16_t *)(v24 + 20) = 10;
        v8 = function_2e584(3, v318, 0);
        v10 = v24;
        v16 = 0;
        result = -1;
    }
    goto lab_0x1b540;
  lab_0x1b6bc:;
    int32_t v319 = (int32_t)&str;
    int32_t v320; // 0x1b4ac
    int32_t v321 = v34 >= (char *)3 == (v34 != (char *)3) ? (int32_t)"get hw_version failed\n" : v320;
    v8 = v33;
    v10 = (int32_t)"hw_version";
    v16 = v35;
    result = -1;
    int32_t v322 = v319; // 0x1b6cc
    int32_t v323 = v321; // 0x1b6cc
    int32_t v324 = v34 >= (char *)3 == (v34 != (char *)3) ? v319 : v320; // 0x1b6cc
    if (v34 == (char *)3 || v34 < (char *)3) {
        goto lab_0x1b540;
    } else {
        goto lab_0x1b6d0;
    }
  lab_0x1b6d0:
    // 0x1b6d0
    str = (char *)*(int32_t *)v323;
    v25 = (char *)*(int32_t *)(v323 + 8);
    v9 = function_2e584(3, (int32_t *)&str, 0);
    v11 = v322;
    v24 = v324;
    goto lab_0x1b5fc;
  lab_0x1b7e8:
    // 0x1b7e8
    v8 = v36;
    v10 = (int32_t)"sw_version";
    v16 = v38;
    result = -1;
    if (v37 == (char *)3 || v37 < (char *)3) {
        goto lab_0x1b540;
    } else {
        int32_t v325 = (int32_t)&str;
        v322 = v325;
        v323 = (int32_t)"get sw_version failed\n";
        v324 = v325;
        goto lab_0x1b6d0;
    }
  lab_0x1b93c:
    // 0x1b93c
    v8 = v39;
    v10 = (int32_t)"processor";
    v16 = v20;
    result = -1;
    int32_t v326; // 0x1b4ac
    if (v40 == (char *)3 || v40 < (char *)3) {
        goto lab_0x1b540;
    } else {
        // 0x1b944
        str = (char *)0x20746567;
        v25 = (char *)0x6f737365;
        v326 = function_2e584(3, (int32_t *)&str, 0);
        goto lab_0x1b8fc;
    }
  lab_0x1b8fc:;
    int32_t v327 = (int32_t)&str;
    char * v328 = g289; // 0x1b8fc
    v8 = v326;
    v10 = v327;
    v16 = 0;
    result = -1;
    if (v328 != (char *)3 && v328 >= (char *)3) {
        // 0x1b908
        str = (char *)0x73726170;
        v25 = (char *)0x7365636f;
        v8 = function_2e584(3, (int32_t *)&str, 0);
        v10 = v327;
        v16 = 0;
        result = -1;
    }
    goto lab_0x1b540;
  lab_0x1b8c4:
    // 0x1b8c4
    v8 = v41;
    v10 = (int32_t)"type";
    v16 = v43;
    result = -1;
    if (v42 == (char *)3 || v42 < (char *)3) {
        goto lab_0x1b540;
    } else {
        // 0x1b8cc
        str = (char *)0x20746567;
        v25 = (char *)0x69616620;
        v326 = function_2e584(3, (int32_t *)&str, 0);
        goto lab_0x1b8fc;
    }
  lab_0x1bab0:
    // 0x1bab0
    v8 = v44;
    v10 = (int32_t)"power";
    v16 = v46;
    result = -1;
    int32_t v329; // 0x1b4ac
    int32_t v330; // 0x1b4ac
    int32_t v331; // 0x1b4ac
    if (v45 == (char *)3 || v45 < (char *)3) {
        goto lab_0x1b540;
    } else {
        int32_t v332 = (int32_t)&str; // 0x1babc
        str = (char *)0x20746567;
        v25 = (char *)0x61662072;
        v329 = function_2e584(3, (int32_t *)&str, 0);
        v330 = v332;
        v331 = v332;
        goto lab_0x1ba70;
    }
  lab_0x1ba70:;
    char * v333 = g289; // 0x1ba70
    v8 = v329;
    v10 = v330;
    v16 = 0;
    result = -1;
    int32_t v334 = v331; // 0x1ba78
    int32_t v335 = (int32_t)"parse power failed\n"; // 0x1ba78
    if (v333 == (char *)3 || v333 < (char *)3) {
        goto lab_0x1b540;
    } else {
        goto lab_0x1ba88;
    }
  lab_0x1ba38:;
    int32_t v336 = (int32_t)&str;
    int32_t v337 = v48 >= (char *)3 == (v48 != (char *)3) ? 0x61a28 : v7;
    v8 = v47;
    v10 = (int32_t)"type";
    v16 = v50;
    result = -1;
    int32_t v338 = v336; // 0x1ba48
    int32_t v339 = v48 >= (char *)3 == (v48 != (char *)3) ? v336 : v320; // 0x1ba48
    int32_t v340 = v337; // 0x1ba48
    if (v48 == (char *)3 || v48 < (char *)3) {
        goto lab_0x1b540;
    } else {
        goto lab_0x1ba4c;
    }
  lab_0x1ba88:;
    int32_t * v341 = (int32_t *)v334; // 0x1ba94
    *v341 = *(int32_t *)v335;
    *(int32_t *)(v334 + 4) = *(int32_t *)(v335 + 4);
    *(int32_t *)(v334 + 8) = *(int32_t *)(v335 + 8);
    *(int32_t *)(v334 + 12) = *(int32_t *)(v335 + 12);
    *(int32_t *)(v334 + 16) = *(int32_t *)(v335 + 16);
    v8 = function_2e584(3, v341, 0);
    v10 = v334;
    v16 = 0;
    result = -1;
    goto lab_0x1b540;
  lab_0x1ba4c:
    // 0x1ba4c
    str = (char *)*(int32_t *)v340;
    v25 = (char *)*(int32_t *)(v340 + 8);
    v329 = function_2e584(3, (int32_t *)&str, 0);
    v330 = v338;
    v331 = v339;
    goto lab_0x1ba70;
  lab_0x1bb68:;
    char * v342 = g289; // 0x1bb68
    v8 = v51;
    v10 = (int32_t)"version";
    v16 = v13;
    result = -1;
    if (v342 == (char *)3 || v342 < (char *)3) {
        goto lab_0x1b540;
    } else {
        int32_t v343 = (int32_t)&str; // 0x1bb78
        str = (char *)0x20746567;
        v25 = (char *)0x206e6f69;
        v329 = function_2e584(3, (int32_t *)&str, 0);
        v330 = v343;
        v331 = v343;
        goto lab_0x1ba70;
    }
  lab_0x1bc5c:;
    char * v344 = g289; // 0x1bc5c
    v8 = v52;
    v10 = (int32_t)"i2c_addr";
    v16 = v14;
    result = -1;
    if (v344 == (char *)3 || v344 < (char *)3) {
        goto lab_0x1b540;
    } else {
        int32_t v345 = (int32_t)&str; // 0x1bc6c
        str = (char *)0x20746567;
        v25 = (char *)0x72646461;
        v329 = function_2e584(3, (int32_t *)&str, 0);
        v330 = v345;
        v331 = v345;
        goto lab_0x1ba70;
    }
  lab_0x1bcd4:;
    char * v346 = v3; // 0x1bcd4
    v8 = v26;
    v10 = (int32_t)"gpio";
    v16 = v15;
    result = -1;
    if (v346 == (char *)3 || v346 < (char *)3) {
        goto lab_0x1b540;
    } else {
        int32_t v347 = (int32_t)&str;
        v338 = v347;
        v339 = v347;
        v340 = (int32_t)"get gpio failed\n";
        goto lab_0x1ba4c;
    }
  lab_0x1bd80:
    // 0x1bd80
    v8 = v27;
    v10 = (int32_t)"fan";
    v16 = v29;
    result = -1;
    int32_t v348; // 0x1b4ac
    if (v28 == (char *)3 || v28 < (char *)3) {
        goto lab_0x1b540;
    } else {
        // 0x1bd88
        str = (char *)0x20746567;
        v25 = (char *)0x6c696166;
        v348 = function_2e584(3, (int32_t *)&str, 0);
        goto lab_0x1bdac;
    }
  lab_0x1bdac:;
    int32_t v349 = (int32_t)&str;
    char * v350 = g289; // 0x1bdac
    v8 = v348;
    v10 = v349;
    v16 = 0;
    result = -1;
    if (v350 != (char *)3 && v350 >= (char *)3) {
        // 0x1bdb8
        *(int32_t *)&str = 0x73726170;
        *(int32_t *)(v349 + 4) = 0x61662065;
        *(int32_t *)(v349 + 8) = 0x6166206e;
        *(int32_t *)(v349 + 12) = 0x64656c69;
        *(int16_t *)(v349 + 16) = 10;
        v8 = function_2e584(3, (int32_t *)&str, 0);
        v10 = v349;
        v16 = 0;
        result = -1;
    }
    goto lab_0x1b540;
  lab_0x1c070:;
    // 0x1c070
    int32_t v351; // 0x1b4ac
    int32_t v352; // 0x1b4ac
    int32_t v353; // 0x1b4ac
    char * v354; // 0x1b4ac
    if (strncmp(str4, "right", 5) == 0) {
        // 0x1c090
        v354 = NULL;
        if (strncmp(str5, "in", 2) == 0) {
            goto lab_0x1c180;
        } else {
            int32_t strncmp_rc = strncmp(str4, "left", 4); // 0x1c0bc
            int32_t strncmp_rc2 = strncmp(str5, "out", 2);
            v351 = strncmp_rc2;
            v352 = (int32_t)"out";
            v353 = 2;
            v354 = strncmp_rc == 0 ? NULL : (char *)1;
            if (strncmp_rc2 == 0) {
                goto lab_0x1c180;
            } else {
                goto lab_0x1c0e4;
            }
        }
    } else {
        int32_t strncmp_rc3 = strncmp(str4, "left", 4); // 0x1c134
        v351 = strncmp_rc3;
        v352 = (int32_t)"left";
        v353 = 4;
        if (strncmp_rc3 == 0) {
            // 0x1c140
            v354 = NULL;
            if (strncmp(str5, "out", 2) == 0) {
                goto lab_0x1c180;
            } else {
                int32_t strncmp_rc4 = strncmp(str5, "in", 2); // 0x1c16c
                v351 = strncmp_rc4;
                v352 = (int32_t)"in";
                v353 = 2;
                v354 = (char *)1;
                if (strncmp_rc4 == 0) {
                    goto lab_0x1c180;
                } else {
                    goto lab_0x1c0e4;
                }
            }
        } else {
            goto lab_0x1c0e4;
        }
    }
  lab_0x1bfdc:
    // 0x1bfdc
    snprintf((char *)&str, 2048, (char *)format, v23);
    v348 = function_2e584(3, (int32_t *)&str, 0);
    goto lab_0x1bdac;
  lab_0x1c180:
    // 0x1c180
    g196 = v354;
    int32_t v355 = function_4e234(v2, "asic"); // 0x1c18c
    char * v356 = g289;
    int32_t v357 = 2; // 0x1c198
    char * v358; // 0x1b4ac
    char * v359; // 0x1b4ac
    char * v360; // 0x1b4ac
    char * v361; // 0x1b4ac
    char * v362; // 0x1b4ac
    char * v363; // 0x1b4ac
    char * v364; // 0x1b4ac
    char * v365; // 0x1b4ac
    char * v366; // 0x1b4ac
    int32_t v367; // 0x1b4ac
    int32_t v368; // 0x1b4ac
    int32_t v369; // 0x1b4ac
    int32_t v370; // 0x1b4ac
    int32_t v371; // 0x1b4ac
    int32_t v372; // 0x1b4ac
    int32_t v373; // 0x1b4ac
    int32_t v374; // 0x1b4ac
    int32_t v375; // 0x1b4ac
    int32_t v376; // 0x1b4ac
    int32_t v377; // 0x1c1c0
    int32_t v378; // 0x1c30c
    int32_t v379; // 0x1c43c
    int32_t v380; // 0x1c4f0
    int32_t v381; // 0x1c598
    int32_t v382; // 0x1c61c
    int32_t v383; // 0x1c6c4
    int32_t v384; // 0x1c78c
    int32_t v385; // 0x1c7d0
    int32_t v386; // 0x1c8a8
    int32_t v387; // 0x1c95c
    int32_t v388; // 0x1ca08
    int32_t v389; // 0x1cab4
    int32_t v390; // 0x1cb68
    if (v355 == 0) {
        goto lab_0x1c25c;
    } else {
        int32_t v391 = *(int32_t *)v355; // 0x1c19c
        v357 = v391;
        if (v391 == 0) {
            if (v356 >= (char *)4 == (v356 != (char *)4)) {
                // 0x1c298
                str = (char *)0x63697361;
                function_2e584(4, (int32_t *)&str, 0);
            }
            // 0x1c1b4
            v377 = function_4e234(v355, "asic_id");
            if (v377 == 0) {
                goto lab_0x1c1d8;
            } else {
                // 0x1c1cc
                if (*(int32_t *)v377 == 2) {
                    char * v392 = g289; // 0x1c2c8
                    if (v392 != (char *)4 && v392 >= (char *)4) {
                        // 0x1c2d4
                        snprintf((char *)&str, 2048, "asic_id: %s\n", (char *)function_4e768(v377));
                        function_2e584(4, (int32_t *)&str, 0);
                    }
                    // 0x1c300
                    v378 = function_4e234(v355, "asic_addr");
                    if (v378 == 0) {
                        goto lab_0x1c324;
                    } else {
                        // 0x1c318
                        if (*(int32_t *)v378 == 2) {
                            char * v393 = g289; // 0x1c368
                            if (v393 >= (char *)4 == (v393 != (char *)4)) {
                                int32_t v394 = function_4e768(v378); // 0x1c474
                                snprintf((char *)&str, 2048, "asic_addr : %s\n", (char *)v394);
                                function_2e584(4, (int32_t *)&str, 0);
                            }
                            int32_t v395 = function_11ef8((int32_t *)function_4e768(v378), 0, 0); // 0x1c384
                            g186 = v395;
                            char * v396 = g289; // 0x1c390
                            if (v395 == 0) {
                                // 0x1c398
                                v8 = 0;
                                v10 = 0;
                                v16 = 0;
                                result = -1;
                                v376 = (int32_t)"convert asic_addr failed\n";
                                if (v396 == (char *)3 || v396 < (char *)3) {
                                    goto lab_0x1b540;
                                } else {
                                    goto lab_0x1c3ac;
                                }
                            } else {
                                if (v396 != (char *)4 && v396 >= (char *)4) {
                                    // 0x1c408
                                    snprintf((char *)&str, 2048, "asic_addr 0x%x\n", v395);
                                    function_2e584(4, (int32_t *)&str, 0);
                                }
                                // 0x1c430
                                v379 = function_4e234(v355, "asic_core_num");
                                if (v379 == 0) {
                                    // 0x1c430
                                    v358 = g289;
                                    v367 = 0;
                                    goto lab_0x1c458;
                                } else {
                                    int32_t v397 = *(int32_t *)v379; // 0x1c448
                                    char * v398 = g289; // 0x1c44c
                                    v358 = v398;
                                    v367 = v397;
                                    if (v397 == 3) {
                                        int32_t v399 = 3; // 0x1c4a8
                                        if (v398 != (char *)4 && v398 >= (char *)4) {
                                            // 0x1c4ac
                                            snprintf((char *)&str, 2048, "asic_core_num: %d\n", function_4e9c4(v379));
                                            function_2e584(4, (int32_t *)&str, 0);
                                            v399 = 0;
                                        }
                                        // 0x1c4d8
                                        g187 = function_4e9c4(v379);
                                        v380 = function_4e234(v355, "asic_small_core_num");
                                        if (v380 == 0) {
                                            // 0x1c4d8
                                            v359 = g289;
                                            v368 = v399;
                                            goto lab_0x1c50c;
                                        } else {
                                            int32_t v400 = *(int32_t *)v380; // 0x1c4fc
                                            char * v401 = g289; // 0x1c500
                                            v359 = v401;
                                            v368 = v400;
                                            if (v400 == 3) {
                                                int32_t v402 = 3; // 0x1c550
                                                if (v401 != (char *)4 && v401 >= (char *)4) {
                                                    // 0x1c554
                                                    snprintf((char *)&str, 2048, "asic_small_core_num: %d\n", function_4e9c4(v380));
                                                    function_2e584(4, (int32_t *)&str, 0);
                                                    v402 = 0;
                                                }
                                                // 0x1c580
                                                g188 = function_4e9c4(v380);
                                                v381 = function_4e234(v355, "core_small_core_num");
                                                if (v381 == 0) {
                                                    // 0x1c580
                                                    v360 = g289;
                                                    v369 = v402;
                                                    goto lab_0x1c5b4;
                                                } else {
                                                    int32_t v403 = *(int32_t *)v381; // 0x1c5a4
                                                    char * v404 = g289; // 0x1c5a8
                                                    v360 = v404;
                                                    v369 = v403;
                                                    if (v403 == 3) {
                                                        int32_t v405 = 3; // 0x1c5d4
                                                        if (v404 != (char *)4 && v404 >= (char *)4) {
                                                            // 0x1c5d8
                                                            snprintf((char *)&str, 2048, "core_small_core_num: %d\n", function_4e9c4(v381));
                                                            function_2e584(4, (int32_t *)&str, 0);
                                                            v405 = 0;
                                                        }
                                                        // 0x1c604
                                                        g189 = function_4e9c4(v381);
                                                        v382 = function_4e234(v355, "asic_domain_num");
                                                        if (v382 == 0) {
                                                            // 0x1c604
                                                            v361 = g289;
                                                            v370 = v405;
                                                            goto lab_0x1c638;
                                                        } else {
                                                            int32_t v406 = *(int32_t *)v382; // 0x1c628
                                                            char * v407 = g289; // 0x1c62c
                                                            v361 = v407;
                                                            v370 = v406;
                                                            if (v406 == 3) {
                                                                int32_t v408 = 3; // 0x1c67c
                                                                if (v407 != (char *)4 && v407 >= (char *)4) {
                                                                    // 0x1c680
                                                                    snprintf((char *)&str, 2048, "asic_domain_num : %d\n", function_4e9c4(v382));
                                                                    function_2e584(4, (int32_t *)&str, 0);
                                                                    v408 = 0;
                                                                }
                                                                // 0x1c6ac
                                                                g190 = function_4e9c4(v382);
                                                                v383 = function_4e234(v355, "asic_addr_interval");
                                                                if (v383 == 0) {
                                                                    // 0x1c6ac
                                                                    v362 = g289;
                                                                    v371 = v408;
                                                                    goto lab_0x1c6e0;
                                                                } else {
                                                                    int32_t v409 = *(int32_t *)v383; // 0x1c6d0
                                                                    char * v410 = g289; // 0x1c6d4
                                                                    v362 = v410;
                                                                    v371 = v409;
                                                                    if (v409 == 3) {
                                                                        int32_t v411 = 3; // 0x1c730
                                                                        if (v410 != (char *)4 && v410 >= (char *)4) {
                                                                            // 0x1c734
                                                                            snprintf((char *)&str, 2048, "asic_addr_interval : %d\n", function_4e9c4(v383));
                                                                            function_2e584(4, (int32_t *)&str, 0);
                                                                            v411 = 0;
                                                                        }
                                                                        // 0x1c760
                                                                        g191 = function_4e9c4(v383);
                                                                        v100 = function_4e234(v2, "chain");
                                                                        v384 = v411;
                                                                        if (v100 == 0) {
                                                                            goto lab_0x1c844;
                                                                        } else {
                                                                            // 0x1c788
                                                                            v384 = *(int32_t *)v100;
                                                                            if (v384 == 0) {
                                                                                char * v412 = g289; // 0x1c798
                                                                                if (v412 != (char *)4 && v412 >= (char *)4) {
                                                                                    // 0x1c7a4
                                                                                    str = (char *)0x69616863;
                                                                                    function_2e584(4, (int32_t *)&str, 0);
                                                                                }
                                                                                // 0x1c7c4
                                                                                v385 = function_4e234(v100, "chain_num");
                                                                                if (v385 == 0) {
                                                                                    goto lab_0x1c7e8;
                                                                                } else {
                                                                                    // 0x1c7dc
                                                                                    if (*(int32_t *)v385 == 3) {
                                                                                        char * v413 = g289; // 0x1c884
                                                                                        if (v413 >= (char *)4 == (v413 != (char *)4)) {
                                                                                            // 0x1c8dc
                                                                                            snprintf((char *)&str, 2048, "chain_num : %d\n", function_4e9c4(v385));
                                                                                            function_2e584(4, (int32_t *)&str, 0);
                                                                                        }
                                                                                        // 0x1c890
                                                                                        g179 = function_4e9c4(v385);
                                                                                        v386 = function_4e234(v100, "chain_row");
                                                                                        if (v386 == 0) {
                                                                                            goto lab_0x1c8c0;
                                                                                        } else {
                                                                                            // 0x1c8b4
                                                                                            if (*(int32_t *)v386 == 3) {
                                                                                                char * v414 = g289; // 0x1c90c
                                                                                                if (v414 != (char *)4 && v414 >= (char *)4) {
                                                                                                    // 0x1c918
                                                                                                    snprintf((char *)&str, 2048, "chain_row: %d\n", function_4e9c4(v386));
                                                                                                    function_2e584(4, (int32_t *)&str, 0);
                                                                                                }
                                                                                                // 0x1c944
                                                                                                g180 = function_4e9c4(v386);
                                                                                                v387 = function_4e234(v100, "chain_column");
                                                                                                if (v387 == 0) {
                                                                                                    // 0x1c944
                                                                                                    v363 = g289;
                                                                                                    v372 = 0;
                                                                                                    goto lab_0x1c978;
                                                                                                } else {
                                                                                                    int32_t v415 = *(int32_t *)v387; // 0x1c968
                                                                                                    char * v416 = g289; // 0x1c96c
                                                                                                    v363 = v416;
                                                                                                    v372 = v415;
                                                                                                    if (v415 == 3) {
                                                                                                        int32_t v417 = 3; // 0x1c9c0
                                                                                                        if (v416 != (char *)4 && v416 >= (char *)4) {
                                                                                                            // 0x1c9c4
                                                                                                            snprintf((char *)&str, 2048, "chain_column: %d\n", function_4e9c4(v387));
                                                                                                            function_2e584(4, (int32_t *)&str, 0);
                                                                                                            v417 = 0;
                                                                                                        }
                                                                                                        // 0x1c9f0
                                                                                                        g181 = function_4e9c4(v387);
                                                                                                        v388 = function_4e234(v100, "chain_domain_num");
                                                                                                        if (v388 == 0) {
                                                                                                            // 0x1c9f0
                                                                                                            v364 = g289;
                                                                                                            v373 = v417;
                                                                                                            goto lab_0x1ca24;
                                                                                                        } else {
                                                                                                            int32_t v418 = *(int32_t *)v388; // 0x1ca14
                                                                                                            char * v419 = g289; // 0x1ca18
                                                                                                            v364 = v419;
                                                                                                            v373 = v418;
                                                                                                            if (v418 == 3) {
                                                                                                                int32_t v420 = 3; // 0x1ca6c
                                                                                                                if (v419 != (char *)4 && v419 >= (char *)4) {
                                                                                                                    // 0x1ca70
                                                                                                                    snprintf((char *)&str, 2048, "chain_domain_num : %d\n", function_4e9c4(v388));
                                                                                                                    function_2e584(4, (int32_t *)&str, 0);
                                                                                                                    v420 = 0;
                                                                                                                }
                                                                                                                // 0x1ca9c
                                                                                                                g182 = function_4e9c4(v388);
                                                                                                                v389 = function_4e234(v100, "chain_asic_num");
                                                                                                                if (v389 == 0) {
                                                                                                                    // 0x1ca9c
                                                                                                                    v365 = g289;
                                                                                                                    v374 = v420;
                                                                                                                    goto lab_0x1cad0;
                                                                                                                } else {
                                                                                                                    int32_t v421 = *(int32_t *)v389; // 0x1cac0
                                                                                                                    char * v422 = g289; // 0x1cac4
                                                                                                                    v365 = v422;
                                                                                                                    v374 = v421;
                                                                                                                    if (v421 == 3) {
                                                                                                                        int32_t v423 = 3; // 0x1cb20
                                                                                                                        if (v422 != (char *)4 && v422 >= (char *)4) {
                                                                                                                            // 0x1cb24
                                                                                                                            snprintf((char *)&str, 2048, "chain_asic_num : %d\n", function_4e9c4(v389));
                                                                                                                            function_2e584(4, (int32_t *)&str, 0);
                                                                                                                            v423 = 0;
                                                                                                                        }
                                                                                                                        // 0x1cb50
                                                                                                                        g183 = function_4e9c4(v389);
                                                                                                                        v390 = function_4e234(v100, "domain_asic_num");
                                                                                                                        if (v390 == 0) {
                                                                                                                            // 0x1cb50
                                                                                                                            v366 = g289;
                                                                                                                            v375 = v423;
                                                                                                                            goto lab_0x1cb84;
                                                                                                                        } else {
                                                                                                                            int32_t v424 = *(int32_t *)v390; // 0x1cb74
                                                                                                                            char * v425 = g289; // 0x1cb78
                                                                                                                            v366 = v425;
                                                                                                                            v375 = v424;
                                                                                                                            if (v424 == 3) {
                                                                                                                                int32_t v426 = 3; // 0x1cbc8
                                                                                                                                if (v425 != (char *)4 && v425 >= (char *)4) {
                                                                                                                                    // 0x1cbcc
                                                                                                                                    snprintf((char *)&str, 2048, "domain_asic_num : %d\n", function_4e9c4(v390));
                                                                                                                                    function_2e584(4, (int32_t *)&str, 0);
                                                                                                                                    v426 = 0;
                                                                                                                                }
                                                                                                                                int32_t v427 = function_4e9c4(v390); // 0x1cbfc
                                                                                                                                char * v428 = g289; // 0x1cc00
                                                                                                                                g184 = v427;
                                                                                                                                int32_t v429 = v426; // 0x1cc1c
                                                                                                                                int32_t v430 = (int32_t)v428; // 0x1cc1c
                                                                                                                                if (v428 != (char *)3 && v428 >= (char *)3) {
                                                                                                                                    // 0x1cc20
                                                                                                                                    snprintf((char *)&str, 2048, "chain_num %d, chain_domain_num %d, chain_asic_num %d, domain_asic_num %d\n", g179, g182, g183, v427);
                                                                                                                                    function_2e584(3, (int32_t *)&str, 0);
                                                                                                                                    v429 = 0;
                                                                                                                                    v430 = g179;
                                                                                                                                }
                                                                                                                                int32_t v431 = function_11eb0(g179, 20, v429, v430); // 0x1cc5c
                                                                                                                                g192 = v431;
                                                                                                                                if (v431 == 0) {
                                                                                                                                    char * v432 = g289; // 0x1cd20
                                                                                                                                    v8 = 0;
                                                                                                                                    v10 = 20;
                                                                                                                                    v16 = v429;
                                                                                                                                    result = -1;
                                                                                                                                    format2 = (int32_t)"malloc %d chain_t failed\n";
                                                                                                                                    v166 = g179;
                                                                                                                                    if (v432 == (char *)3 || v432 < (char *)3) {
                                                                                                                                        goto lab_0x1b540;
                                                                                                                                    } else {
                                                                                                                                        goto lab_0x1cd40;
                                                                                                                                    }
                                                                                                                                } else {
                                                                                                                                    // 0x1cc70
                                                                                                                                    v110 = 0;
                                                                                                                                    if (g179 > 0) {
                                                                                                                                        int32_t v433 = 28 * v427; // 0x1cc78
                                                                                                                                        int32_t v434 = -28 * v427; // 0x1cc80
                                                                                                                                        *(int32_t *)v431 = 0;
                                                                                                                                        int32_t v435 = function_11eb0(g182, 8, 0, 0); // 0x1ccb8
                                                                                                                                        int32_t * v436 = (int32_t *)(v431 + 12); // 0x1ccc0
                                                                                                                                        *v436 = v435;
                                                                                                                                        int32_t v437 = 0; // 0x1ccc4
                                                                                                                                        v165 = 0;
                                                                                                                                        if (v435 == 0) {
                                                                                                                                            goto lab_0x1cdc4;
                                                                                                                                        } else {
                                                                                                                                            int32_t v438 = 0;
                                                                                                                                            int32_t * v439 = v436;
                                                                                                                                            int32_t v440 = function_11eb0(g183, 28, v438, 0); // 0x1ccd0
                                                                                                                                            int32_t * v441 = (int32_t *)(v431 + 8); // 0x1ccd8
                                                                                                                                            *v441 = v440;
                                                                                                                                            while (v440 != 0) {
                                                                                                                                                int32_t v442 = v433; // 0x1ccfc
                                                                                                                                                int32_t v443 = 0; // 0x1ccfc
                                                                                                                                                if (g182 > 0) {
                                                                                                                                                    int32_t v444 = *v439 + 8 * v443; // 0x1cd04
                                                                                                                                                    *(int32_t *)v444 = v443;
                                                                                                                                                    int32_t v445 = v443 + 1; // 0x1cd10
                                                                                                                                                    *(int32_t *)(v444 + 4) = v442 + v434 + *v441;
                                                                                                                                                    v442 += v433;
                                                                                                                                                    v443 = v445;
                                                                                                                                                    while (g182 > v445) {
                                                                                                                                                        // 0x1cd00
                                                                                                                                                        v444 = *v439 + 8 * v443;
                                                                                                                                                        *(int32_t *)v444 = v443;
                                                                                                                                                        v445 = v443 + 1;
                                                                                                                                                        *(int32_t *)(v444 + 4) = v442 + v434 + *v441;
                                                                                                                                                        v442 += v433;
                                                                                                                                                        v443 = v445;
                                                                                                                                                    }
                                                                                                                                                }
                                                                                                                                                int32_t v446 = v437 + 1; // 0x1cd94
                                                                                                                                                v110 = v434;
                                                                                                                                                if (g179 <= v446) {
                                                                                                                                                    goto lab_0x1cdf0;
                                                                                                                                                }
                                                                                                                                                int32_t v447 = 20 * v446; // 0x1cca4
                                                                                                                                                int32_t v448 = v447 + g192; // 0x1ccb0
                                                                                                                                                *(int32_t *)v448 = v446;
                                                                                                                                                int32_t v449 = function_11eb0(g182, 8, v434, v447); // 0x1ccb8
                                                                                                                                                int32_t * v450 = (int32_t *)(v448 + 12); // 0x1ccc0
                                                                                                                                                *v450 = v449;
                                                                                                                                                v437 = v446;
                                                                                                                                                v165 = v434;
                                                                                                                                                if (v449 == 0) {
                                                                                                                                                    goto lab_0x1cdc4;
                                                                                                                                                }
                                                                                                                                                v438 = v434;
                                                                                                                                                v439 = v450;
                                                                                                                                                v440 = function_11eb0(g183, 28, v438, v447);
                                                                                                                                                v441 = (int32_t *)(v448 + 8);
                                                                                                                                                *v441 = v440;
                                                                                                                                            }
                                                                                                                                            char * v451 = g289; // 0x1cd9c
                                                                                                                                            v8 = 0;
                                                                                                                                            v10 = 28;
                                                                                                                                            v16 = v438;
                                                                                                                                            result = -1;
                                                                                                                                            format2 = (int32_t)"malloc %d asic_t failed\n";
                                                                                                                                            v166 = g183;
                                                                                                                                            if (v451 == (char *)3 || v451 < (char *)3) {
                                                                                                                                                goto lab_0x1b540;
                                                                                                                                            } else {
                                                                                                                                                goto lab_0x1cd40;
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                    } else {
                                                                                                                                        goto lab_0x1cdf0;
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            } else {
                                                                                                                                goto lab_0x1cb84;
                                                                                                                            }
                                                                                                                        }
                                                                                                                    } else {
                                                                                                                        goto lab_0x1cad0;
                                                                                                                    }
                                                                                                                }
                                                                                                            } else {
                                                                                                                goto lab_0x1ca24;
                                                                                                            }
                                                                                                        }
                                                                                                    } else {
                                                                                                        goto lab_0x1c978;
                                                                                                    }
                                                                                                }
                                                                                            } else {
                                                                                                goto lab_0x1c8c0;
                                                                                            }
                                                                                        }
                                                                                    } else {
                                                                                        goto lab_0x1c7e8;
                                                                                    }
                                                                                }
                                                                            } else {
                                                                                goto lab_0x1c844;
                                                                            }
                                                                        }
                                                                    } else {
                                                                        goto lab_0x1c6e0;
                                                                    }
                                                                }
                                                            } else {
                                                                goto lab_0x1c638;
                                                            }
                                                        }
                                                    } else {
                                                        goto lab_0x1c5b4;
                                                    }
                                                }
                                            } else {
                                                goto lab_0x1c50c;
                                            }
                                        }
                                    } else {
                                        goto lab_0x1c458;
                                    }
                                }
                            }
                        } else {
                            goto lab_0x1c324;
                        }
                    }
                } else {
                    goto lab_0x1c1d8;
                }
            }
        } else {
            goto lab_0x1c25c;
        }
    }
  lab_0x1c0e4:;
    char * v452 = g289; // 0x1c0e4
    v8 = v351;
    v10 = v352;
    v16 = v353;
    result = -1;
    if (v452 == (char *)3 || v452 < (char *)3) {
        goto lab_0x1b540;
    } else {
        // 0x1c0f0
        snprintf((char *)&str, 2048, "unkonwn wind position %s, direction %s\n", str4, str5);
        v348 = function_2e584(3, (int32_t *)&str, 0);
        goto lab_0x1bdac;
    }
  lab_0x1c25c:
    // 0x1c25c
    v8 = v355;
    v10 = (int32_t)"asic";
    v16 = v357;
    result = -1;
    int32_t v453; // 0x1b4ac
    if (v356 == (char *)3 || v356 < (char *)3) {
        goto lab_0x1b540;
    } else {
        // 0x1c264
        str = (char *)0x20746567;
        v25 = (char *)0x69616620;
        v453 = function_2e584(3, (int32_t *)&str, 0);
        goto lab_0x1c214;
    }
  lab_0x1c214:;
    int32_t v454 = (int32_t)&str;
    char * v455 = g289; // 0x1c214
    v8 = v453;
    v10 = v454;
    v16 = 0;
    result = -1;
    if (v455 != (char *)3 && v455 >= (char *)3) {
        // 0x1c220
        *(int32_t *)&str = 0x73726170;
        *(int32_t *)(v454 + 4) = 0x73612065;
        *(int32_t *)(v454 + 8) = 0x66206369;
        *(int32_t *)(v454 + 12) = 0x656c6961;
        *(int16_t *)(v454 + 16) = 2660;
        *(char *)(v454 + 18) = 0;
        v8 = function_2e584(3, (int32_t *)&str, 0);
        v10 = v454;
        v16 = 0;
        result = -1;
    }
    goto lab_0x1b540;
  lab_0x1c1d8:;
    char * v456 = g289; // 0x1c1d8
    v8 = v377;
    v10 = (int32_t)"asic_id";
    v16 = 0;
    result = -1;
    if (v456 == (char *)3 || v456 < (char *)3) {
        goto lab_0x1b540;
    } else {
        // 0x1c1e4
        str = (char *)0x20746567;
        v25 = (char *)0x2064695f;
        v453 = function_2e584(3, (int32_t *)&str, 0);
        goto lab_0x1c214;
    }
  lab_0x1c324:;
    char * v457 = g289; // 0x1c324
    v8 = v378;
    v10 = (int32_t)"asic_addr";
    v16 = 0;
    result = -1;
    if (v457 == (char *)3 || v457 < (char *)3) {
        goto lab_0x1b540;
    } else {
        // 0x1c330
        str = (char *)0x20746567;
        v25 = (char *)0x6464615f;
        v453 = function_2e584(3, (int32_t *)&str, 0);
        goto lab_0x1c214;
    }
  lab_0x1c3ac:
    // 0x1c3ac
    str = (char *)*(int32_t *)v376;
    v25 = (char *)*(int32_t *)(v376 + 8);
    v453 = function_2e584(3, (int32_t *)&str, 0);
    goto lab_0x1c214;
  lab_0x1c458:;
    char * v458 = v358; // 0x1c458
    v8 = v379;
    v10 = (int32_t)"asic_core_num";
    v16 = v367;
    result = -1;
    v376 = (int32_t)"get asic_core_num failed\n";
    if (v458 == (char *)3 || v458 < (char *)3) {
        goto lab_0x1b540;
    } else {
        goto lab_0x1c3ac;
    }
  lab_0x1c50c:;
    char * v459 = v359; // 0x1c50c
    v8 = v380;
    v10 = (int32_t)"asic_small_core_num";
    v16 = v368;
    result = -1;
    int32_t v460 = (int32_t)"get asic_small_core_num failed\n"; // 0x1c514
    if (v459 == (char *)3 || v459 < (char *)3) {
        goto lab_0x1b540;
    } else {
        goto lab_0x1c524;
    }
  lab_0x1c524:
    // 0x1c524
    str = (char *)*(int32_t *)v460;
    v25 = (char *)*(int32_t *)(v460 + 8);
    v453 = function_2e584(3, (int32_t *)&str, 0);
    goto lab_0x1c214;
  lab_0x1c5b4:;
    char * v461 = v360; // 0x1c5b4
    v8 = v381;
    v10 = (int32_t)"core_small_core_num";
    v16 = v369;
    result = -1;
    v460 = (int32_t)"get core_small_core_num failed\n";
    if (v461 == (char *)3 || v461 < (char *)3) {
        goto lab_0x1b540;
    } else {
        goto lab_0x1c524;
    }
  lab_0x1c638:;
    char * v462 = v361; // 0x1c638
    v8 = v382;
    v10 = (int32_t)"asic_domain_num";
    v16 = v370;
    result = -1;
    if (v462 == (char *)3 || v462 < (char *)3) {
        goto lab_0x1b540;
    } else {
        // 0x1c644
        str = (char *)0x20746567;
        v25 = (char *)0x6d6f645f;
        v453 = function_2e584(3, (int32_t *)&str, 0);
        goto lab_0x1c214;
    }
  lab_0x1c6e0:;
    char * v463 = v362; // 0x1c6e0
    v8 = v383;
    v10 = (int32_t)"asic_addr_interval";
    v16 = v371;
    result = -1;
    if (v463 == (char *)3 || v463 < (char *)3) {
        goto lab_0x1b540;
    } else {
        // 0x1c6ec
        str = (char *)0x20746567;
        v25 = (char *)0x6464615f;
        v453 = function_2e584(3, (int32_t *)&str, 0);
        goto lab_0x1c214;
    }
  lab_0x1c844:;
    char * v464 = g289; // 0x1c844
    v8 = v100;
    v10 = (int32_t)"chain";
    v16 = v384;
    result = -1;
    int32_t v465; // 0x1b4ac
    int32_t v466; // 0x1b4ac
    if (v464 == (char *)3 || v464 < (char *)3) {
        goto lab_0x1b540;
    } else {
        // 0x1c850
        str = (char *)0x20746567;
        v25 = (char *)0x6166206e;
        v465 = function_2e584(3, (int32_t *)&str, 0);
        v466 = (int32_t)&str;
        goto lab_0x1c828;
    }
  lab_0x1c828:;
    char * v467 = g289; // 0x1c828
    v8 = v465;
    v10 = v466;
    v16 = 0;
    result = -1;
    v334 = v466;
    v335 = (int32_t)"parse chain failed\n";
    if (v467 == (char *)3 || v467 < (char *)3) {
        goto lab_0x1b540;
    } else {
        goto lab_0x1ba88;
    }
  lab_0x1c7e8:;
    char * v468 = g289; // 0x1c7e8
    v8 = v385;
    v10 = (int32_t)"chain_num";
    v16 = 0;
    result = -1;
    int32_t v469 = (int32_t)"get chain_num failed\n"; // 0x1c7f0
    if (v468 == (char *)3 || v468 < (char *)3) {
        goto lab_0x1b540;
    } else {
        goto lab_0x1c800;
    }
  lab_0x1c800:
    // 0x1c800
    str = (char *)*(int32_t *)v469;
    v25 = (char *)*(int32_t *)(v469 + 8);
    v465 = function_2e584(3, (int32_t *)&str, 0);
    v466 = (int32_t)&str;
    goto lab_0x1c828;
  lab_0x1c8c0:;
    char * v470 = g289; // 0x1c8c0
    v8 = v386;
    v10 = (int32_t)"chain_row";
    v16 = 0;
    result = -1;
    v469 = (int32_t)"get chain_row failed\n";
    if (v470 == (char *)3 || v470 < (char *)3) {
        goto lab_0x1b540;
    } else {
        goto lab_0x1c800;
    }
  lab_0x1c978:;
    char * v471 = v363; // 0x1c978
    v8 = v387;
    v10 = (int32_t)"chain_column";
    v16 = v372;
    result = -1;
    if (v471 == (char *)3 || v471 < (char *)3) {
        goto lab_0x1b540;
    } else {
        // 0x1c984
        str = (char *)0x20746567;
        v25 = (char *)0x6f635f6e;
        v465 = function_2e584(3, (int32_t *)&str, 0);
        v466 = (int32_t)&str;
        goto lab_0x1c828;
    }
  lab_0x1ca24:;
    char * v472 = v364; // 0x1ca24
    v8 = v388;
    v10 = (int32_t)"chain_domain_num";
    v16 = v373;
    result = -1;
    if (v472 == (char *)3 || v472 < (char *)3) {
        goto lab_0x1b540;
    } else {
        // 0x1ca30
        str = (char *)0x20746567;
        v25 = (char *)0x6f645f6e;
        v465 = function_2e584(3, (int32_t *)&str, 0);
        v466 = (int32_t)&str;
        goto lab_0x1c828;
    }
  lab_0x1cad0:;
    char * v473 = v365; // 0x1cad0
    v8 = v389;
    v10 = (int32_t)"chain_asic_num";
    v16 = v374;
    result = -1;
    int32_t v474; // 0x1b4ac
    int32_t v475; // 0x1b4ac
    if (v473 == (char *)3 || v473 < (char *)3) {
        goto lab_0x1b540;
    } else {
        // 0x1cadc
        v474 = (int32_t)"get chain_asic_num failed\n";
        v475 = (int32_t)&str;
        goto lab_0x1caec;
    }
  lab_0x1caec:;
    int32_t * v476 = (int32_t *)v475; // 0x1caf0
    *v476 = *(int32_t *)v474;
    *(int32_t *)(v475 + 4) = *(int32_t *)(v474 + 4);
    *(int32_t *)(v475 + 8) = *(int32_t *)(v474 + 8);
    *(int32_t *)(v475 + 12) = *(int32_t *)(v474 + 12);
    uint32_t v477 = *(int32_t *)(v474 + 24); // 0x1caf4
    *(int32_t *)(v475 + 16) = *(int32_t *)(v474 + 16);
    *(int32_t *)(v475 + 20) = *(int32_t *)(v474 + 20);
    *(int16_t *)(v475 + 24) = (int16_t)v477;
    *(char *)(v475 + 26) = (char)(v477 / 0x10000);
    v465 = function_2e584(3, v476, 0);
    v466 = v475;
    goto lab_0x1c828;
  lab_0x1cb84:;
    char * v478 = v366; // 0x1cb84
    v8 = v390;
    v10 = (int32_t)"domain_asic_num";
    v16 = v375;
    result = -1;
    if (v478 == (char *)3 || v478 < (char *)3) {
        goto lab_0x1b540;
    } else {
        // 0x1cb90
        str = (char *)0x20746567;
        v25 = (char *)0x615f6e69;
        v465 = function_2e584(3, (int32_t *)&str, 0);
        v466 = (int32_t)&str;
        goto lab_0x1c828;
    }
  lab_0x1cd40:
    // 0x1cd40
    snprintf((char *)&str, 2048, (char *)format2, v166);
    int32_t v479 = (int32_t)&str;
    int32_t v480 = function_2e584(3, (int32_t *)&str, 0); // 0x1cd54
    char * v481 = g289; // 0x1cd58
    v8 = v480;
    v10 = v479;
    v16 = 0;
    result = -1;
    if (v481 == (char *)3 || v481 < (char *)3) {
        goto lab_0x1b540;
    } else {
        // 0x1cd64
        str = (char *)0x6f6c6c61;
        v25 = (char *)0x206c6f70;
        v465 = function_2e584(3, (int32_t *)&str, 0);
        v466 = v479;
        goto lab_0x1c828;
    }
  lab_0x1ce18:;
    char * v482 = v102; // 0x1ce18
    v8 = v101;
    v10 = (int32_t)"pic";
    v16 = v111;
    result = -1;
    if (v482 == (char *)3 || v482 < (char *)3) {
        goto lab_0x1b540;
    } else {
        // 0x1ce24
        str = (char *)0x20746567;
        v25 = (char *)0x6c696166;
        v109 = function_2e584(3, (int32_t *)&str, 0);
        goto lab_0x1ce48;
    }
  lab_0x1ce48:;
    int32_t v483 = (int32_t)&str;
    char * v484 = g289; // 0x1ce48
    v8 = v109;
    v10 = v483;
    v16 = 0;
    result = -1;
    if (v484 == (char *)3 || v484 < (char *)3) {
        goto lab_0x1b540;
    } else {
        // 0x1ce54
        *(int32_t *)&str = 0x73726170;
        *(int32_t *)(v483 + 4) = 0x68632065;
        *(int32_t *)(v483 + 8) = 0x206e6961;
        *(int32_t *)(v483 + 12) = 0x20636970;
        *(int32_t *)(v483 + 16) = 0x6c696166;
        *(int32_t *)(v483 + 20) = (int32_t)&g465;
        v465 = function_2e584(3, (int32_t *)&str, 0);
        v466 = v483;
        goto lab_0x1c828;
    }
  lab_0x1ced8:;
    char * v485 = v103; // 0x1ced8
    v8 = v121;
    v10 = (int32_t)"type";
    v16 = v112;
    result = -1;
    if (v485 == (char *)3 || v485 < (char *)3) {
        goto lab_0x1b540;
    } else {
        // 0x1cee4
        str = (char *)0x20746567;
        v25 = (char *)0x69616620;
        v109 = function_2e584(3, (int32_t *)&str, 0);
        goto lab_0x1ce48;
    }
  lab_0x1cf74:;
    char * v486 = v104; // 0x1cf74
    v8 = v122;
    v10 = (int32_t)"i2c_addr";
    v16 = v113;
    result = -1;
    if (v486 == (char *)3 || v486 < (char *)3) {
        goto lab_0x1b540;
    } else {
        // 0x1cf80
        str = (char *)0x20746567;
        v25 = (char *)0x72646461;
        v109 = function_2e584(3, (int32_t *)&str, 0);
        goto lab_0x1ce48;
    }
  lab_0x1d010:;
    int32_t v487 = function_11eec(g178, "BHB28601", v114, v123); // 0x1d020
    v119 = v114;
    if (v487 == 0) {
        goto lab_0x1d42c;
    } else {
        int32_t v488 = function_11eec(g178, "BHB28501", v114, v123); // 0x1d038
        v119 = v114;
        if (v488 == 0) {
            goto lab_0x1d42c;
        } else {
            char * v489 = g289; // 0x1d044
            v8 = v488;
            v10 = (int32_t)"BHB28501";
            v16 = v114;
            result = -1;
            if (v489 == (char *)3 || v489 < (char *)3) {
                goto lab_0x1b540;
            } else {
                // 0x1d050
                str = (char *)0x20746567;
                v25 = (char *)0x736e6573;
                v109 = function_2e584(3, (int32_t *)&str, 0);
                goto lab_0x1ce48;
            }
        }
    }
  lab_0x1d454:;
    char * v490 = v172; // 0x1d454
    v8 = v171;
    v10 = (int32_t)"eeprom";
    v16 = v119;
    result = -1;
    int32_t v491; // 0x1b4ac
    if (v490 == (char *)3 || v490 < (char *)3) {
        goto lab_0x1b540;
    } else {
        // 0x1d460
        str = (char *)0x20746567;
        v25 = (char *)0x66206d6f;
        v491 = function_2e584(3, (int32_t *)&str, 0);
        goto lab_0x1d498;
    }
  lab_0x1d33c:
    // 0x1d33c
    snprintf((char *)&str, 2048, (char *)format3, v120);
    v109 = function_2e584(3, (int32_t *)&str, 0);
    goto lab_0x1ce48;
  lab_0x1d498:;
    int32_t v492 = (int32_t)&str;
    char * v493 = g289; // 0x1d498
    v8 = v491;
    v10 = v492;
    v16 = 0;
    result = -1;
    v474 = (int32_t)"parse chain eeprom failed\n";
    v475 = v492;
    if (v493 == (char *)3 || v493 < (char *)3) {
        goto lab_0x1b540;
    } else {
        goto lab_0x1caec;
    }
  lab_0x1d50c:;
    char * v494 = v173; // 0x1d50c
    v8 = v188;
    v10 = (int32_t)"type";
    v16 = v180;
    result = -1;
    if (v494 == (char *)3 || v494 < (char *)3) {
        goto lab_0x1b540;
    } else {
        // 0x1d518
        str = (char *)0x20746567;
        v25 = (char *)0x69616620;
        v491 = function_2e584(3, (int32_t *)&str, 0);
        goto lab_0x1d498;
    }
  lab_0x1d5a8:;
    char * v495 = v174; // 0x1d5a8
    v8 = v189;
    v10 = (int32_t)"i2c_addr";
    v16 = v181;
    result = -1;
    if (v495 == (char *)3 || v495 < (char *)3) {
        goto lab_0x1b540;
    } else {
        // 0x1d5b4
        str = (char *)0x20746567;
        v25 = (char *)0x72646461;
        v491 = function_2e584(3, (int32_t *)&str, 0);
        goto lab_0x1d498;
    }
  lab_0x1d648:;
    char * v496 = v175; // 0x1d648
    v8 = v190;
    v10 = (int32_t)"sensor";
    v16 = v182;
    result = -1;
    if (v496 == (char *)3 || v496 < (char *)3) {
        goto lab_0x1b540;
    } else {
        // 0x1d654
        str = (char *)0x20746567;
        v25 = (char *)0x6620726f;
        v179 = function_2e584(3, (int32_t *)&str, 0);
        goto lab_0x1d68c;
    }
  lab_0x1d68c:;
    int32_t v497 = (int32_t)&str;
    char * v498 = g289; // 0x1d68c
    v8 = v179;
    v10 = v497;
    v16 = 0;
    result = -1;
    v474 = (int32_t)"parse chain sensor failed\n";
    v475 = v497;
    if (v498 == (char *)3 || v498 < (char *)3) {
        goto lab_0x1b540;
    } else {
        goto lab_0x1caec;
    }
  lab_0x1d8a8:
    // 0x1d8a8
    snprintf((char *)&str, 2048, (char *)format4, v187);
    v179 = function_2e584(3, (int32_t *)&str, 0);
    goto lab_0x1d68c;
  lab_0x1d960:;
    char * v499 = v227; // 0x1d960
    v8 = v226;
    v10 = (int32_t)"domain";
    v16 = v233;
    result = -1;
    int32_t v500; // 0x1b4ac
    int32_t v501; // 0x1b4ac
    if (v499 == (char *)3 || v499 < (char *)3) {
        goto lab_0x1b540;
    } else {
        // 0x1d96c
        str = (char *)0x20746567;
        v25 = (char *)0x66206e69;
        v500 = function_2e584(3, (int32_t *)&str, 0);
        v501 = (int32_t)&str;
        goto lab_0x1d9a4;
    }
  lab_0x1d9a4:;
    char * v502 = g289; // 0x1d9a4
    v8 = v500;
    v10 = v501;
    v16 = 0;
    result = -1;
    v474 = (int32_t)"parse chain domain failed\n";
    v475 = v501;
    if (v502 == (char *)3 || v502 < (char *)3) {
        goto lab_0x1b540;
    } else {
        goto lab_0x1caec;
    }
  lab_0x1dba0:
    // 0x1dba0
    snprintf((char *)&str, 2048, (char *)format5, v241);
    v500 = function_2e584(3, (int32_t *)&str, 0);
    v501 = (int32_t)&str;
    goto lab_0x1d9a4;
  lab_0x1db44:;
    int32_t v503 = (int32_t)&str;
    char * v504 = g289; // 0x1db44
    v8 = v303;
    v10 = v503;
    v16 = 0;
    result = -1;
    if (v504 == (char *)3 || v504 < (char *)3) {
        goto lab_0x1b540;
    } else {
        // 0x1db50
        snprintf((char *)&str, 2048, "parse arrry %d asic failed\n", v241);
        v500 = function_2e584(3, (int32_t *)&str, 0);
        v501 = v503;
        goto lab_0x1d9a4;
    }
  lab_0x1de28:
    // 0x1de28
    snprintf((char *)&str, 2048, (char *)format6, v242);
    v303 = function_2e584(3, (int32_t *)&str, 0);
    goto lab_0x1db44;
}

// Address range: 0x1e0c0 - 0x1e0d0
int32_t function_1e0c0(void) {
    // 0x1e0c0
    return g178;
}

// Address range: 0x1e0d0 - 0x1e0e0
int32_t function_1e0d0(void) {
    // 0x1e0d0
    return g179;
}

// Address range: 0x1e0e0 - 0x1e0f0
int32_t function_1e0e0(void) {
    // 0x1e0e0
    return g182;
}

// Address range: 0x1e0f0 - 0x1e100
int32_t function_1e0f0(void) {
    // 0x1e0f0
    return g183;
}

// Address range: 0x1e100 - 0x1e110
int32_t function_1e100(void) {
    // 0x1e100
    return g184;
}

// Address range: 0x1e110 - 0x1e120
int32_t function_1e110(void) {
    // 0x1e110
    return g186;
}

// Address range: 0x1e120 - 0x1e130
int32_t function_1e120(void) {
    // 0x1e120
    return g187;
}

// Address range: 0x1e130 - 0x1e140
int32_t function_1e130(void) {
    // 0x1e130
    return g188;
}

// Address range: 0x1e140 - 0x1e150
int32_t function_1e140(void) {
    // 0x1e140
    return g189;
}

// Address range: 0x1e150 - 0x1e160
int32_t function_1e150(void) {
    // 0x1e150
    return g190;
}

// Address range: 0x1e160 - 0x1e170
int32_t function_1e160(void) {
    // 0x1e160
    return g191;
}

// Address range: 0x1e170 - 0x1e180
int32_t function_1e170(void) {
    // 0x1e170
    return g185;
}

// Address range: 0x1e180 - 0x1e19c
int32_t function_1e180(int32_t a1) {
    // 0x1e180
    return *(int32_t *)(12 * a1 + 4 + g193);
}

// Address range: 0x1e19c - 0x1e1ac
int32_t function_1e19c(void) {
    // 0x1e19c
    return g194;
}

// Address range: 0x1e1ac - 0x1e1c8
int32_t function_1e1ac(int32_t a1) {
    // 0x1e1ac
    return *(int32_t *)(12 * a1 + 4 + g195);
}

// Address range: 0x1e1c8 - 0x1e1e4
int32_t function_1e1c8(int32_t a1) {
    // 0x1e1c8
    return (int32_t)*(char *)(12 * a1 + 8 + g195);
}

// Address range: 0x1e1e4 - 0x1e200
int32_t function_1e1e4(int32_t a1) {
    // 0x1e1e4
    return (int32_t)*(char *)(12 * a1 + 8 + g193);
}

// Address range: 0x1e200 - 0x1e28c
int32_t function_1e200(int32_t a1, int32_t a2) {
    // 0x1e200
    if (a1 > -1 != g179 > a1) {
        // 0x1e27c
        return -0x7ffffbff;
    }
    int32_t result = 0; // 0x1e238
    if (g198 == 0) {
        // 0x1e270
        result = function_1b398();
        if (result < 0) {
            // 0x1e27c
            return result;
        }
    }
    char * v1 = (char *)(g201 + 528 * a1); // 0x1e248
    if ((int32_t)*v1 == a2) {
        // 0x1e27c
        return result;
    }
    // 0x1e254
    *v1 = (char)a2;
    g199--;
    return result;
}

// Address range: 0x1e28c - 0x1e29c
int32_t function_1e28c(void) {
    // 0x1e28c
    return (unsigned char)g199;
}

// Address range: 0x1e29c - 0x1e2b4
int32_t function_1e29c(int32_t a1) {
    // 0x1e29c
    return (int32_t)*(char *)(g201 + 528 * a1);
}

// Address range: 0x1e2b4 - 0x1e2c8
int32_t function_1e2b4(void) {
    // 0x1e2b4
    float64_t v1; // 0x1e2b4
    __asm_vstr(v1, g205);
    return 0;
}

// Address range: 0x1e2c8 - 0x1e2d8
int32_t function_1e2c8(void) {
    // 0x1e2c8
    __asm_vldr(g205);
    int32_t result; // 0x1e2c8
    return result;
}

// Address range: 0x1e2d8 - 0x1e2ec
int32_t function_1e2d8(void) {
    // 0x1e2d8
    float64_t v1; // 0x1e2d8
    __asm_vstr(v1, g206);
    return 0;
}

// Address range: 0x1e2ec - 0x1e2fc
int32_t function_1e2ec(void) {
    // 0x1e2ec
    __asm_vldr(g206);
    int32_t result; // 0x1e2ec
    return result;
}

// Address range: 0x1e2fc - 0x1e30c
int32_t function_1e2fc(void) {
    // 0x1e2fc
    return g197;
}

// Address range: 0x1e30c - 0x1e350
int32_t function_1e30c(void) {
    // 0x1e30c
    if (g197 < 1) {
        // 0x1e344
        return 0;
    }
    int32_t result = 0; // 0x1e328
    int32_t v1 = 0; // 0x1e328
    char v2 = *(char *)(8 * v1 + g204); // 0x1e32c
    v1++;
    result += (int32_t)(v2 != 0);
    while (v1 != g197) {
        // 0x1e32c
        v2 = *(char *)(8 * v1 + g204);
        v1++;
        result += (int32_t)(v2 != 0);
    }
    // 0x1e344
    return result;
}

// Address range: 0x1e350 - 0x1e3d4
int32_t function_1e350(int32_t a1, int32_t a2) {
    // 0x1e350
    if (a1 > -1 != g197 > a1) {
        // 0x1e3c4
        return -0x7ffffbff;
    }
    int32_t result = 0; // 0x1e388
    if (g198 == 0) {
        // 0x1e3b8
        result = function_1b398();
        if (result < 0) {
            // 0x1e3c4
            return result;
        }
    }
    char * v1 = (char *)(g204 + 8 * a1); // 0x1e390
    if ((int32_t)*v1 == a2) {
        // 0x1e3c4
        return result;
    }
    // 0x1e39c
    *v1 = (char)a2;
    g202--;
    return result;
}

// Address range: 0x1e3d4 - 0x1e43c
int32_t function_1e3d4(int32_t a1, int32_t a2) {
    // 0x1e3d4
    if (a1 > -1 != g197 > a1) {
        // 0x1e42c
        return -0x7ffffbff;
    }
    // 0x1e3f8
    if (g198 != 0) {
        // 0x1e410
        *(int32_t *)(g204 + (8 * a1 | 4)) = a2;
        return 0;
    }
    int32_t result = function_1b398(); // 0x1e420
    if (result < 0) {
        // 0x1e42c
        return result;
    }
    // 0x1e410
    *(int32_t *)(g204 + (8 * a1 | 4)) = a2;
    return result;
}

// Address range: 0x1e43c - 0x1e49c
int32_t function_1e43c(int32_t a1) {
    // 0x1e43c
    if (a1 < 0 || g197 <= a1) {
        // 0x1e48c
        return -0x7ffffbff;
    }
    // 0x1e460
    if (g198 != 0) {
        // 0x1e470
        return *(int32_t *)(g204 + (8 * a1 | 4));
    }
    int32_t result = function_1b398(); // 0x1e480
    if (result < 0) {
        // 0x1e48c
        return result;
    }
    // 0x1e470
    return *(int32_t *)(g204 + (8 * a1 | 4));
}

// Address range: 0x1e49c - 0x1e4b0
int32_t function_1e49c(int32_t a1) {
    // 0x1e49c
    g203 = a1;
    return 0;
}

// Address range: 0x1e4b0 - 0x1e4c0
int32_t function_1e4b0(void) {
    // 0x1e4b0
    return (unsigned char)g203;
}

// Address range: 0x1e4c0 - 0x1e52c
int32_t function_1e4c0(int32_t a1) {
    // 0x1e4c0
    if (a1 > -1 != g179 > a1) {
        // 0x1e51c
        return -0x7ffffbff;
    }
    // 0x1e4e4
    float64_t v1; // 0x1e4c0
    int32_t v2 = __asm_vmov_6(v1); // 0x1e4ec
    int32_t result = 0; // 0x1e4f8
    if (g198 == 0) {
        // 0x1e510
        result = function_1b398();
        if (result < 0) {
            // 0x1e51c
            return result;
        }
    }
    int32_t v3 = g201 + 528 * a1; // 0x1e504
    *(int32_t *)(v3 + 8) = v2;
    *(int32_t *)(v3 + 12) = v2;
    return result;
}

// Address range: 0x1e52c - 0x1e58c
int32_t function_1e52c(int32_t result) {
    // 0x1e52c
    if (result < 0 || g179 <= result) {
        // 0x1e550
        __asm_vldr(-0x7fe00000);
        return result;
    }
    // 0x1e558
    int32_t result2; // 0x1e570
    if (g198 != 0) {
        // 0x1e568
        result2 = g201 + 528 * result;
        __asm_vldr(*(int32_t *)(result2 + 8));
        return result2;
    }
    int32_t result3 = function_1b398(); // 0x1e57c
    if (result3 < 0) {
        // 0x1e588
        __asm_vmov_7(result3);
        return result3;
    }
    // 0x1e568
    result2 = g201 + 528 * result;
    __asm_vldr(*(int32_t *)(result2 + 8));
    return result2;
}

// Address range: 0x1e58c - 0x1e596
int32_t function_1e58c(int32_t a1, int32_t a2, int32_t a3) {
    // 0x1e58c
    int32_t result; // 0x1e58c
    __asm_mrc(0, 5, result, 8, 0, 3);
    return result;
}

// Address range: 0x1e596 - 0x1e598
int32_t function_1e596(void) {
    // 0x1e596
    int32_t result; // 0x1e596
    return result;
}

// Address range: 0x1e5a0 - 0x1e610
int32_t function_1e5a0(int32_t a1) {
    // 0x1e5a0
    if (a1 > -1 != g179 > a1) {
        // 0x1e600
        return -0x7ffffbff;
    }
    int32_t result = 0; // 0x1e5d4
    if (g198 == 0) {
        // 0x1e5f4
        result = function_1b398();
        if (result < 0) {
            // 0x1e600
            return result;
        }
    }
    char * v1 = (char *)(g201 + (528 * a1 | 1)); // 0x1e5e4
    *v1 = *v1 + 1;
    return result;
}

// Address range: 0x1e610 - 0x1e67c
int32_t function_1e610(int32_t a1, int32_t a2) {
    // 0x1e610
    if (a1 > -1 != g179 > a1) {
        // 0x1e66c
        return -0x7ffffbff;
    }
    // 0x1e634
    if (g198 != 0) {
        // 0x1e64c
        *(char *)(g201 + (528 * a1 | 1)) = (char)a2;
        return 0;
    }
    int32_t result = function_1b398(); // 0x1e660
    if (result < 0) {
        // 0x1e66c
        return result;
    }
    // 0x1e64c
    *(char *)(g201 + (528 * a1 | 1)) = (char)a2;
    return result;
}

// Address range: 0x1e67c - 0x1e6e0
int32_t function_1e67c(int32_t a1) {
    // 0x1e67c
    if (a1 < 0 || g179 <= a1) {
        // 0x1e6d0
        return -0x7ffffbff;
    }
    // 0x1e6a0
    if (g198 != 0) {
        // 0x1e6b0
        return (int32_t)*(char *)(g201 + (528 * a1 | 1));
    }
    int32_t result = function_1b398(); // 0x1e6c4
    if (result < 0) {
        // 0x1e6d0
        return result;
    }
    // 0x1e6b0
    return (int32_t)*(char *)(g201 + (528 * a1 | 1));
}

// Address range: 0x1e6e0 - 0x1e750
int32_t function_1e6e0(int32_t a1) {
    // 0x1e6e0
    if (a1 > -1 != g179 > a1) {
        // 0x1e740
        return -0x7ffffbff;
    }
    int32_t result = 0; // 0x1e714
    if (g198 == 0) {
        // 0x1e734
        result = function_1b398();
        if (result < 0) {
            // 0x1e740
            return result;
        }
    }
    int32_t * v1 = (int32_t *)(g201 + (528 * a1 | 4)); // 0x1e724
    *v1 = *v1 + 1;
    return result;
}

// Address range: 0x1e750 - 0x1e7bc
int32_t function_1e750(int32_t a1, int32_t a2) {
    // 0x1e750
    if (a1 > -1 != g179 > a1) {
        // 0x1e7ac
        return -0x7ffffbff;
    }
    // 0x1e774
    if (g198 != 0) {
        // 0x1e78c
        *(int32_t *)(g201 + (528 * a1 | 4)) = a2;
        return 0;
    }
    int32_t result = function_1b398(); // 0x1e7a0
    if (result < 0) {
        // 0x1e7ac
        return result;
    }
    // 0x1e78c
    *(int32_t *)(g201 + (528 * a1 | 4)) = a2;
    return result;
}

// Address range: 0x1e7bc - 0x1e820
int32_t function_1e7bc(int32_t a1) {
    // 0x1e7bc
    if (a1 < 0 || g179 <= a1) {
        // 0x1e810
        return -0x7ffffbff;
    }
    // 0x1e7e0
    if (g198 != 0) {
        // 0x1e7f0
        return *(int32_t *)(g201 + (528 * a1 | 4));
    }
    int32_t result = function_1b398(); // 0x1e804
    if (result < 0) {
        // 0x1e810
        return result;
    }
    // 0x1e7f0
    return *(int32_t *)(g201 + (528 * a1 | 4));
}

// Address range: 0x1e820 - 0x1e894
int32_t function_1e820(int32_t a1, int32_t a2, int32_t a3) {
    // 0x1e820
    if (a1 > -1 != g179 > a1) {
        // 0x1e884
        return -0x7ffffbff;
    }
    // 0x1e844
    if (g198 != 0) {
        // 0x1e860
        *(char *)(528 * a1 + 16 + a2 + g201) = (char)a3;
        return 0;
    }
    int32_t result = function_1b398(); // 0x1e878
    if (result < 0) {
        // 0x1e884
        return result;
    }
    // 0x1e860
    *(char *)(528 * a1 + 16 + a2 + g201) = (char)a3;
    return result;
}

// Address range: 0x1e894 - 0x1e91c
int32_t function_1e894(int32_t a1, int32_t * str) {
    // 0x1e894
    if (a1 > -1 != g179 > a1) {
        // 0x1e8f4
        return -0x7ffffbff;
    }
    int32_t result = 0; // 0x1e8cc
    if (g198 == 0) {
        // 0x1e8fc
        result = function_1b398();
        if (result < 0) {
            // 0x1e8f4
            return result;
        }
    }
    // 0x1e8d0
    snprintf((char *)str, 512, "%s", (char *)(528 * a1 + 16 + g201));
    // 0x1e8f4
    return result;
}

// Address range: 0x1e91c - 0x1e970
int32_t function_1e91c(int32_t a1) {
    // 0x1e91c
    if (g207 < 1) {
        // 0x1e960
        return 0;
    }
    // 0x1e930
    if ((int32_t)*g208 == a1) {
        // 0x1e960
        return 1;
    }
    int32_t v1 = (int32_t)g208; // 0x1e930
    int32_t v2 = v1; // 0x1e948
    v2 += 2;
    int32_t result = 0; // 0x1e95c
    while (v2 != 2 * g207 + v1) {
        // 0x1e94c
        result = 1;
        if ((int32_t)*(int16_t *)v2 == a1) {
            // break -> 0x1e960
            break;
        }
        v2 += 2;
        result = 0;
    }
    // 0x1e960
    return result;
}

// Address range: 0x1e970 - 0x1e9b4
int32_t function_1e970(void) {
    int32_t v1 = 0; // 0x1e984
    int32_t v2 = 0; // 0x1e984
    int32_t v3 = 0; // 0x1e984
    if (function_1e29c(0) == 0) {
        goto lab_0x1e988;
    } else {
        goto lab_0x1e9a4;
    }
  lab_0x1e988:;
    int32_t v4 = v2 + 1; // 0x1e988
    int32_t result = v1; // 0x1e990
    if (v4 == 4) {
        // 0x1e988
        return result;
    }
    int32_t v5 = v4;
    int32_t v6 = function_1e29c(v5); // 0x1e998
    v3 = v5;
    while (v6 == 0) {
        int32_t v7 = v5 + 1; // 0x1e988
        if (v7 == 4) {
            // 0x1e988
            return 0;
        }
        v5 = v7;
        v6 = function_1e29c(v5);
        v3 = v5;
    }
    goto lab_0x1e9a4;
  lab_0x1e9a4:
    // 0x1e9a4
    v2 = v3;
    v1 = function_50c38(v2 % 256, 0);
    goto lab_0x1e988;
}

// Address range: 0x1e9b4 - 0x1e9bc
int32_t function_1e9b4(int32_t a1, int32_t a2) {
    // 0x1e9b4
    return function_51328(a1, a2, 1);
}

// Address range: 0x1e9bc - 0x1e9c4
int32_t function_1e9bc(void) {
    // 0x1e9bc
    int32_t v1; // 0x1e9bc
    return function_51328(v1, v1, 0);
}

// Address range: 0x1e9c4 - 0x1e9cc
int32_t function_1e9c4(void) {
    // 0x1e9c4
    int32_t v1; // 0x1e9c4
    return function_512cc(v1, 1);
}

// Address range: 0x1e9cc - 0x1ea14
int32_t function_1e9cc(int32_t a1) {
    int32_t v1 = 0; // 0x1e9e4
    int32_t v2 = 0; // 0x1e9e4
    int32_t v3 = 0; // 0x1e9e4
    if (function_1e29c(0) == 0) {
        goto lab_0x1e9e8;
    } else {
        goto lab_0x1ea04;
    }
  lab_0x1e9e8:;
    int32_t v4 = v2 + 1; // 0x1e9e8
    int32_t result = v1; // 0x1e9f0
    if (v4 == 4) {
        // 0x1e9e8
        return result;
    }
    int32_t v5 = v4;
    int32_t v6 = function_1e29c(v5); // 0x1e9f8
    v3 = v5;
    while (v6 == 0) {
        int32_t v7 = v5 + 1; // 0x1e9e8
        if (v7 == 4) {
            // 0x1e9e8
            return 0;
        }
        v5 = v7;
        v6 = function_1e29c(v5);
        v3 = v5;
    }
    goto lab_0x1ea04;
  lab_0x1ea04:
    // 0x1ea04
    v2 = v3;
    v1 = function_4ffe8(v2 % 256, a1);
    goto lab_0x1e9e8;
}

// Address range: 0x1ea14 - 0x1ea18
int32_t function_1ea14(void) {
    // 0x1ea14
    int32_t v1; // 0x1ea14
    return function_51164(v1, v1);
}

// Address range: 0x1ea18 - 0x1ea84
int32_t function_1ea18(int32_t a1, int32_t a2, int32_t a3, uint32_t a4) {
    uint32_t v1 = a4 % 256; // 0x1ea1c
    int32_t v2 = 0;
    int32_t v3 = function_1e29c(v2); // 0x1ea38
    int32_t result = 0; // 0x1ea40
    if (v3 != 0) {
        // 0x1ea44
        result = v3;
        if (a1 == 255 || v2 == a1) {
            if (a3 == 0) {
                // 0x1ea78
                result = function_50874(v2, a2, v1);
            } else {
                // 0x1ea64
                result = function_508a0(v2, v1);
            }
        }
    }
    int32_t v4 = v2 + 1; // 0x1ea68
    while (v4 != 4) {
        // 0x1ea30
        v2 = v4;
        v3 = function_1e29c(v2);
        result = 0;
        if (v3 != 0) {
            // 0x1ea44
            result = v3;
            if (a1 == 255 || v2 == a1) {
                if (a3 == 0) {
                    // 0x1ea78
                    result = function_50874(v2, a2, v1);
                } else {
                    // 0x1ea64
                    result = function_508a0(v2, v1);
                }
            }
        }
        // 0x1ea68
        v4 = v2 + 1;
    }
    // 0x1ea74
    return result;
}

// Address range: 0x1ea84 - 0x1ead4
int32_t function_1ea84(int32_t a1) {
    int32_t v1 = 0; // 0x1ea8c
    int32_t result; // 0x1ea84
    while (true) {
        uint32_t v2 = v1;
        uint32_t v3 = v2 % 256; // 0x1ea94
        v1 = v2 + 1;
        int32_t v4 = function_1e29c(v2); // 0x1ea9c
        if (v4 != 0 == (a1 == 255 || v3 == a1)) {
            // 0x1eac0
            result = function_513fc(v3);
            if (v1 == 4) {
                // break -> 0x1eabc
                break;
            }
        } else {
            // 0x1eab4
            result = v4;
            if (v1 == 4) {
                // break -> 0x1eabc
                break;
            }
        }
    }
    // 0x1eabc
    return result;
}

// Address range: 0x1ead4 - 0x1eb1c
int32_t function_1ead4(int32_t a1) {
    int32_t v1 = 0; // 0x1eadc
    int32_t result; // 0x1ead4
    while (true) {
        uint32_t v2 = v1;
        v1 = v2 + 1;
        if (function_1e29c(v2) == 0) {
            // 0x1eaf8
            result = 0;
            if (v1 == 4) {
                // break -> 0x1eb00
                break;
            }
        } else {
            // 0x1eb04
            result = function_5021c(v2 % 256, a1);
            if (v1 == 4) {
                // break -> 0x1eb00
                break;
            }
        }
    }
    // 0x1eb00
    return result;
}

// Address range: 0x1eb1c - 0x1eb74
int32_t function_1eb1c(int32_t a1) {
    int32_t v1 = 0; // 0x1eb2c
    int32_t result; // 0x1eb1c
    while (true) {
        uint32_t v2 = v1;
        v1 = v2 + 1;
        if (function_1e29c(v2) == 0) {
            // 0x1eb48
            result = 0;
            if (v1 == 4) {
                // break -> 0x1eb50
                break;
            }
        } else {
            // 0x1eb54
            result = function_508e4(v2 % 256, 1, *(char *)&g283, a1);
            if (v1 == 4) {
                // break -> 0x1eb50
                break;
            }
        }
    }
    // 0x1eb50
    return result;
}

// Address range: 0x1eb74 - 0x1ec7c
int32_t function_1eb74(void) {
    int32_t result = function_1e0e0(); // 0x1eb80
    if (result <= 9) {
        char * v1 = g289; // 0x1eb94
        if (v1 >= (char *)4 != v1 != (char *)4) {
            // 0x1eba0
            return result;
        }
        char * v2 = (char *)0x6e206f6e; // bp-2080, 0x1ebbc
        return function_2e584(4, (int32_t *)&v2, 0);
    }
    int32_t result2 = function_1e0e0(); // 0x1ebf0
    int32_t v3 = result2 - 3; // 0x1ebf4
    if (v3 < 0) {
        // 0x1eba0
        return result2;
    }
    int32_t v4 = function_1e100(); // 0x1ec00
    int32_t v5 = (v4 - 1 + v4 * v3) * function_1e160(); // 0x1ec18
    int32_t v6 = 0;
    int32_t result3 = 0; // 0x1ec30
    int32_t v7; // 0x1ec50
    int32_t v8; // 0x1ec58
    if (function_1e29c(v6) != 0) {
        // 0x1ec50
        v7 = function_1e0e0();
        v8 = function_1e100();
        result3 = function_5129c(v6, v5, v8 * (v7 - v3) + 14, 1, 1);
    }
    int32_t v9 = v6 + 1; // 0x1ec2c
    while (v9 != 4) {
        // 0x1ec1c
        v6 = v9;
        result3 = 0;
        if (function_1e29c(v6) != 0) {
            // 0x1ec50
            v7 = function_1e0e0();
            v8 = function_1e100();
            result3 = function_5129c(v6, v5, v8 * (v7 - v3) + 14, 1, 1);
        }
        // 0x1ec34
        v9 = v6 + 1;
    }
    int32_t v10 = v3 - 3; // 0x1ec3c
    while (v10 >= 0) {
        int32_t v11 = v10;
        v4 = function_1e100();
        v5 = (v4 - 1 + v4 * v11) * function_1e160();
        v6 = 0;
        result3 = 0;
        if (function_1e29c(v6) != 0) {
            // 0x1ec50
            v7 = function_1e0e0();
            v8 = function_1e100();
            result3 = function_5129c(v6, v5, v8 * (v7 - v11) + 14, 1, 1);
        }
        // 0x1ec34
        v9 = v6 + 1;
        while (v9 != 4) {
            // 0x1ec1c
            v6 = v9;
            result3 = 0;
            if (function_1e29c(v6) != 0) {
                // 0x1ec50
                v7 = function_1e0e0();
                v8 = function_1e100();
                result3 = function_5129c(v6, v5, v8 * (v7 - v11) + 14, 1, 1);
            }
            // 0x1ec34
            v9 = v6 + 1;
        }
        // 0x1ec3c
        v10 = v11 - 3;
    }
    // 0x1eba0
    return result3;
}

// Address range: 0x1ec7c - 0x1ec80
int32_t function_1ec7c(void) {
    // 0x1ec7c
    int32_t v1; // 0x1ec7c
    return function_4fe70(v1);
}

// Address range: 0x1ec80 - 0x1ec84
int32_t function_1ec80(void) {
    // 0x1ec80
    int32_t v1; // 0x1ec80
    return function_4ff50(v1, v1);
}

// Address range: 0x1ec84 - 0x1ecdc
int32_t function_1ec84(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = 0;
    int32_t result = 0; // 0x1eca8
    if (function_1e29c(v1) != 0) {
        // 0x1ecac
        result = v1;
        if (a1 == 255 || v1 == a1) {
            // 0x1ecc8
            result = function_4fef0(v1, a2, a3, a4);
        }
    }
    int32_t v2 = v1 + 1; // 0x1eccc
    while (v2 != 4) {
        // 0x1ec9c
        v1 = v2;
        result = 0;
        if (function_1e29c(v1) != 0) {
            // 0x1ecac
            result = v1;
            if (a1 == 255 || v1 == a1) {
                // 0x1ecc8
                result = function_4fef0(v1, a2, a3, a4);
            }
        }
        // 0x1eccc
        v2 = v1 + 1;
    }
    // 0x1ecd8
    return result;
}

// Address range: 0x1ecdc - 0x1ed08
int32_t function_1ecdc(int32_t a1, uint32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    uint32_t v1 = a2 % 256; // 0x1ece4
    char v2 = a6;
    char v3 = a5;
    if (a4 == 0) {
        // 0x1ed00
        return function_511d0(v2, v3, a1, v1);
    }
    // 0x1ecf4
    return function_5121c(v2, v3, a1, v1, 0x1000000 * a3 >> 24);
}

// Address range: 0x1ed08 - 0x1edf0
int32_t function_1ed08(void) {
    // 0x1ed08
    if (g61 != 0) {
        // 0x1ed28
        if ((*(char *)&g60 | *(char *)&g221) == 0 != g290 < 7) {
            // 0x1ed50
            int32_t str; // bp-2064, 0x1ed08
            snprintf((char *)&str, 2048, "--- %s\n", "dhash_chip_set_addr_all");
            function_2e584(7, &str, 0);
        }
    }
    int32_t v1 = 0;
    if (function_1e29c(v1) != 0) {
        // 0x1edb0
        function_4fe70(v1);
        function_304d4(30);
        function_4ff50(v1, function_1e160() % 256);
    }
    int32_t v2 = v1 + 1; // 0x1ed90
    while (v2 != 4) {
        // 0x1ed80
        v1 = v2;
        if (function_1e29c(v1) != 0) {
            // 0x1edb0
            function_4fe70(v1);
            function_304d4(30);
            function_4ff50(v1, function_1e160() % 256);
        }
        // 0x1ed90
        v2 = v1 + 1;
    }
    // 0x1ed9c
    return function_304d4(10);
}

// Address range: 0x1edf0 - 0x1eeb8
int32_t function_1edf0(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = a1; // bp-16, 0x1ee00
    int32_t v2; // bp-76, 0x1edf0
    memset(&v2, 0, 44);
    int32_t v3 = &v1; // 0x1ee18
    int32_t v4; // bp-84, 0x1edf0
    int32_t v5 = &v4; // 0x1ee28
    v4 = llvm_bswap_i32(a1);
    int32_t v6 = v3; // 0x1ee30
    int32_t v7 = 2; // 0x1ee30
    unsigned char v8 = *(char *)(v6 + 9); // 0x1ee34
    unsigned char v9 = *(char *)(v6 + 8); // 0x1ee3c
    unsigned char v10 = *(char *)(v6 + 11); // 0x1ee40
    unsigned char v11 = *(char *)(v6 + 10); // 0x1ee44
    *(int32_t *)(4 * v7 + v5) = 0x1000000 * (int32_t)v9 | 0x10000 * (int32_t)v8 | (int32_t)v10 | 256 * (int32_t)v11;
    v7++;
    v6 += 4;
    while (v7 != 5) {
        // 0x1ee34
        v8 = *(char *)(v6 + 9);
        v9 = *(char *)(v6 + 8);
        v10 = *(char *)(v6 + 11);
        v11 = *(char *)(v6 + 10);
        *(int32_t *)(4 * v7 + v5) = 0x1000000 * (int32_t)v9 | 0x10000 * (int32_t)v8 | (int32_t)v10 | 256 * (int32_t)v11;
        v7++;
        v6 += 4;
    }
    // 0x1ee68
    int32_t v12; // bp-64, 0x1edf0
    int32_t v13 = &v12; // 0x1ee6c
    unsigned char v14 = *(char *)(v3 + 21); // 0x1ee70
    int32_t v15 = v3 + 4; // 0x1ee74
    unsigned char v16 = *(char *)(v3 + 20); // 0x1ee78
    unsigned char v17 = *(char *)(v3 + 23); // 0x1ee7c
    unsigned char v18 = *(char *)(v3 + 22); // 0x1ee80
    *(int32_t *)v13 = 0x1000000 * (int32_t)v16 | 0x10000 * (int32_t)v14 | (int32_t)v17 | 256 * (int32_t)v18;
    v13 += 4;
    int32_t v19; // bp+16, 0x1edf0
    while (v15 != (int32_t)&v19) {
        int32_t v20 = v15;
        v14 = *(char *)(v20 + 21);
        v15 = v20 + 4;
        v16 = *(char *)(v20 + 20);
        v17 = *(char *)(v20 + 23);
        v18 = *(char *)(v20 + 22);
        *(int32_t *)v13 = 0x1000000 * (int32_t)v16 | 0x10000 * (int32_t)v14 | (int32_t)v17 | 256 * (int32_t)v18;
        v13 += 4;
    }
    // 0x1eea0
    return function_4587c(v5, 52);
}

// Address range: 0x1eeb8 - 0x1ef94
int32_t function_1eeb8(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = a1; // bp-16, 0x1eec8
    int32_t v2; // bp-180, 0x1eeb8
    memset(&v2, 0, 140);
    int32_t v3 = &v1; // 0x1eee0
    int32_t v4; // bp-188, 0x1eeb8
    int32_t v5 = &v4; // 0x1eef0
    v4 = llvm_bswap_i32(a1);
    int32_t v6 = v3; // 0x1eef8
    int32_t v7 = 2; // 0x1eef8
    unsigned char v8 = *(char *)(v6 + 9); // 0x1eefc
    unsigned char v9 = *(char *)(v6 + 8); // 0x1ef04
    unsigned char v10 = *(char *)(v6 + 11); // 0x1ef08
    unsigned char v11 = *(char *)(v6 + 10); // 0x1ef0c
    *(int32_t *)(4 * v7 + v5) = 0x1000000 * (int32_t)v9 | 0x10000 * (int32_t)v8 | (int32_t)v10 | 256 * (int32_t)v11;
    v7++;
    v6 += 4;
    while (v7 != 5) {
        // 0x1eefc
        v8 = *(char *)(v6 + 9);
        v9 = *(char *)(v6 + 8);
        v10 = *(char *)(v6 + 11);
        v11 = *(char *)(v6 + 10);
        *(int32_t *)(4 * v7 + v5) = 0x1000000 * (int32_t)v9 | 0x10000 * (int32_t)v8 | (int32_t)v10 | 256 * (int32_t)v11;
        v7++;
        v6 += 4;
    }
    // 0x1ef30
    int32_t v12; // bp-168, 0x1eeb8
    int32_t v13 = &v12; // 0x1ef34
    int32_t v14 = v13; // 0x1ef3c
    int32_t v15 = v3;
    unsigned char v16 = *(char *)(v15 + 21); // 0x1ef40
    int32_t v17 = v15 + 4; // 0x1ef44
    unsigned char v18 = *(char *)(v15 + 20); // 0x1ef48
    unsigned char v19 = *(char *)(v15 + 23); // 0x1ef4c
    unsigned char v20 = *(char *)(v15 + 22); // 0x1ef50
    *(int32_t *)v14 = 0x1000000 * (int32_t)v18 | 0x10000 * (int32_t)v16 | (int32_t)v19 | 256 * (int32_t)v20;
    v14 += 4;
    while (v15 != v3 + 28) {
        // 0x1ef40
        v15 = v17;
        v16 = *(char *)(v15 + 21);
        v17 = v15 + 4;
        v18 = *(char *)(v15 + 20);
        v19 = *(char *)(v15 + 23);
        v20 = *(char *)(v15 + 22);
        *(int32_t *)v14 = 0x1000000 * (int32_t)v18 | 0x10000 * (int32_t)v16 | (int32_t)v19 | 256 * (int32_t)v20;
        v14 += 4;
    }
    // 0x1ef70
    v13 += 32;
    int32_t v21; // bp+112, 0x1eeb8
    while (v17 != (int32_t)&v21) {
        int32_t v22 = v17;
        v14 = v13;
        v15 = v22;
        v16 = *(char *)(v15 + 21);
        v17 = v15 + 4;
        v18 = *(char *)(v15 + 20);
        v19 = *(char *)(v15 + 23);
        v20 = *(char *)(v15 + 22);
        *(int32_t *)v14 = 0x1000000 * (int32_t)v18 | 0x10000 * (int32_t)v16 | (int32_t)v19 | 256 * (int32_t)v20;
        v14 += 4;
        while (v15 != v22 + 28) {
            // 0x1ef40
            v15 = v17;
            v16 = *(char *)(v15 + 21);
            v17 = v15 + 4;
            v18 = *(char *)(v15 + 20);
            v19 = *(char *)(v15 + 23);
            v20 = *(char *)(v15 + 22);
            *(int32_t *)v14 = 0x1000000 * (int32_t)v18 | 0x10000 * (int32_t)v16 | (int32_t)v19 | 256 * (int32_t)v20;
            v14 += 4;
        }
        // 0x1ef70
        v13 += 32;
    }
    // 0x1ef7c
    return function_4587c(v5, 148);
}

// Address range: 0x1ef94 - 0x1efe0
int32_t function_1ef94(int32_t a1, char a2) {
    int32_t v1 = 0; // 0x1efac
    int32_t v2 = 0; // 0x1efac
    int32_t v3 = 0; // 0x1efac
    if (function_1e29c(0) == 0) {
        goto lab_0x1efb0;
    } else {
        goto lab_0x1efcc;
    }
  lab_0x1efb0:;
    int32_t v4 = v2 + 1; // 0x1efb0
    int32_t result = v1; // 0x1efb8
    if (v4 == 4) {
        // 0x1efb0
        return result;
    }
    int32_t v5 = v4;
    int32_t v6 = function_1e29c(v5); // 0x1efc0
    v3 = v5;
    while (v6 == 0) {
        int32_t v7 = v5 + 1; // 0x1efb0
        if (v7 == 4) {
            // 0x1efb0
            return 0;
        }
        v5 = v7;
        v6 = function_1e29c(v5);
        v3 = v5;
    }
    goto lab_0x1efcc;
  lab_0x1efcc:
    // 0x1efcc
    v2 = v3;
    v1 = function_5161c(v2 % 256, (int32_t)a2, 0);
    goto lab_0x1efb0;
}

// Address range: 0x1efe0 - 0x1f038
int32_t function_1efe0(int32_t a1, char a2, char a3, int32_t a4) {
    int32_t v1 = 0; // 0x1f000
    int32_t v2 = 0; // 0x1f000
    int32_t v3 = 0; // 0x1f000
    if (function_1e29c(0) == 0) {
        goto lab_0x1f004;
    } else {
        goto lab_0x1f020;
    }
  lab_0x1f004:;
    int32_t v4 = v2 + 1; // 0x1f004
    int32_t result = v1; // 0x1f00c
    if (v4 == 4) {
        // 0x1f004
        return result;
    }
    int32_t v5 = v4;
    int32_t v6 = function_1e29c(v5); // 0x1f014
    v3 = v5;
    while (v6 == 0) {
        int32_t v7 = v5 + 1; // 0x1f004
        if (v7 == 4) {
            // 0x1f004
            return 0;
        }
        v5 = v7;
        v6 = function_1e29c(v5);
        v3 = v5;
    }
    goto lab_0x1f020;
  lab_0x1f020:
    // 0x1f020
    v2 = v3;
    v1 = function_51694(v2 % 256, (int32_t)a2, (int32_t)a3, a4);
    goto lab_0x1f004;
}

// Address range: 0x1f038 - 0x1f07c
int32_t function_1f038(int32_t a1) {
    int32_t v1 = 0;
    int32_t result = 0; // 0x1f050
    if (function_1e29c(v1) != 0) {
        // 0x1f054
        result = v1;
        if (a1 == 255 || v1 == a1) {
            // 0x1f068
            result = function_51708(v1, 1);
        }
    }
    int32_t v2 = v1 + 1; // 0x1f06c
    while (v2 != 4) {
        // 0x1f044
        v1 = v2;
        result = 0;
        if (function_1e29c(v1) != 0) {
            // 0x1f054
            result = v1;
            if (a1 == 255 || v1 == a1) {
                // 0x1f068
                result = function_51708(v1, 1);
            }
        }
        // 0x1f06c
        v2 = v1 + 1;
    }
    // 0x1f078
    return result;
}

// Address range: 0x1f07c - 0x1f080
int32_t function_1f07c(void) {
    // 0x1f07c
    int32_t result; // 0x1f07c
    return result;
}

// Address range: 0x1f080 - 0x1f0e0
int32_t function_1f080(uint32_t a1, uint32_t a2) {
    float32_t v1 = __asm_vmov_f32(25.0f); // 0x1f084
    char v2; // 0x1f080
    float32_t v3 = __asm_vcvt_f32_s32(__asm_vmov_7((int32_t)v2)); // 0x1f0a4
    int32_t v4 = __asm_smulbb(a1 % 256, (int32_t)v2); // 0x1f0a8
    float32_t v5 = __asm_vmov_7(a2 % 0x10000); // 0x1f0ac
    float32_t v6 = __asm_vdiv_f32(v1, v3); // 0x1f0b0
    float32_t v7 = __asm_vcvt_f32_s32(v5); // 0x1f0b8
    float32_t v8 = __asm_vcvt_f32_s32(__asm_vmov_7(v4 * (int32_t)(unsigned char)v2)); // 0x1f0c4
    return __asm_vmov_9(__asm_vcvt_s32_f32(__asm_vdiv_f32(__asm_vmul_f32(v6, v7), v8)));
}

// Address range: 0x1f0e0 - 0x1f164
int32_t function_1f0e0(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = 0;
    int32_t v2 = function_1e29c(v1); // 0x1f108
    int32_t result = 0; // 0x1f110
    if (v2 != 0) {
        // 0x1f114
        result = v2;
        if (a1 == 255 || v1 == a1) {
            if (a2 == 0) {
                // 0x1f154
                result = function_506f8(v1, a3, a4, 0);
            } else {
                // 0x1f138
                result = function_50794(v1, a4, 0);
            }
        }
    }
    int32_t v3 = v1 + 1; // 0x1f140
    while (v3 != 4) {
        // 0x1f104
        v1 = v3;
        v2 = function_1e29c(v1);
        result = 0;
        if (v2 != 0) {
            // 0x1f114
            result = v2;
            if (a1 == 255 || v1 == a1) {
                if (a2 == 0) {
                    // 0x1f154
                    result = function_506f8(v1, a3, a4, 0);
                } else {
                    // 0x1f138
                    result = function_50794(v1, a4, 0);
                }
            }
        }
        // 0x1f140
        v3 = v1 + 1;
    }
    // 0x1f14c
    return result;
}

// Address range: 0x1f164 - 0x1f1ec
int32_t function_1f164(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    int32_t v1 = 0;
    int32_t v2 = function_1e29c(v1); // 0x1f188
    int32_t result = 0; // 0x1f190
    if (v2 != 0) {
        // 0x1f194
        result = v2;
        if (a1 == 255 || v1 == a1) {
            if (a2 == 0) {
                // 0x1f1d4
                result = function_505a4(v1, a3, a4, a5, (int32_t)(0x10000 * a6 >> 16));
            } else {
                // 0x1f1b8
                result = function_50560(v1, a4, a5, a6);
            }
        }
    }
    int32_t v3 = v1 + 1; // 0x1f1c0
    while (v3 != 4) {
        // 0x1f184
        v1 = v3;
        v2 = function_1e29c(v1);
        result = 0;
        if (v2 != 0) {
            // 0x1f194
            result = v2;
            if (a1 == 255 || v1 == a1) {
                if (a2 == 0) {
                    // 0x1f1d4
                    result = function_505a4(v1, a3, a4, a5, (int32_t)(0x10000 * a6 >> 16));
                } else {
                    // 0x1f1b8
                    result = function_50560(v1, a4, a5, a6);
                }
            }
        }
        // 0x1f1c0
        v3 = v1 + 1;
    }
    // 0x1f1cc
    return result;
}

// Address range: 0x1f1ec - 0x1f24c
int32_t function_1f1ec(int32_t a1, int32_t a2) {
    int32_t v1 = 0; // 0x1f204
    int32_t v2 = 0; // 0x1f204
    int32_t v3 = 0; // 0x1f204
    if (function_1e29c(0) == 0) {
        goto lab_0x1f208;
    } else {
        goto lab_0x1f224;
    }
  lab_0x1f208:;
    int32_t v4 = v2 + 1; // 0x1f208
    int32_t result = v1; // 0x1f210
    if (v4 == 4) {
        // 0x1f208
        return result;
    }
    int32_t v5 = v4;
    int32_t v6 = function_1e29c(v5); // 0x1f218
    v3 = v5;
    while (v6 == 0) {
        int32_t v7 = v5 + 1; // 0x1f208
        if (v7 == 4) {
            // 0x1f208
            return 0;
        }
        v5 = v7;
        v6 = function_1e29c(v5);
        v3 = v5;
    }
    goto lab_0x1f224;
  lab_0x1f224:;
    int32_t v8 = v3;
    uint32_t v9 = v8 % 256; // 0x1f224
    function_508dc();
    if (a2 == 0) {
        // 0x1f244
        v1 = function_50f28(v9);
        v2 = v8;
    } else {
        // 0x1f23c
        v1 = function_50ed0(v9);
        v2 = v8;
    }
    goto lab_0x1f208;
}

// Address range: 0x1f24c - 0x1f294
int32_t function_1f24c(int32_t a1) {
    int32_t v1 = 0; // 0x1f264
    int32_t v2 = 0; // 0x1f264
    int32_t v3 = 0; // 0x1f264
    if (function_1e29c(0) == 0) {
        goto lab_0x1f268;
    } else {
        goto lab_0x1f284;
    }
  lab_0x1f268:;
    int32_t v4 = v2 + 1; // 0x1f268
    int32_t result = v1; // 0x1f270
    if (v4 == 4) {
        // 0x1f268
        return result;
    }
    int32_t v5 = v4;
    int32_t v6 = function_1e29c(v5); // 0x1f278
    v3 = v5;
    while (v6 == 0) {
        int32_t v7 = v5 + 1; // 0x1f268
        if (v7 == 4) {
            // 0x1f268
            return 0;
        }
        v5 = v7;
        v6 = function_1e29c(v5);
        v3 = v5;
    }
    goto lab_0x1f284;
  lab_0x1f284:
    // 0x1f284
    v2 = v3;
    v1 = function_50d54(v2 % 256, a1);
    goto lab_0x1f268;
}

// Address range: 0x1f294 - 0x1f29c
int32_t function_1f294(uint32_t a1) {
    // 0x1f294
    int32_t v1; // 0x1f294
    return function_50da8(a1 % 256, v1);
}

// Address range: 0x1f29c - 0x1f2e4
int32_t function_1f29c(int32_t a1) {
    int32_t v1 = 0; // 0x1f2a4
    int32_t result; // 0x1f29c
    while (true) {
        uint32_t v2 = v1;
        v1 = v2 + 1;
        if (function_1e29c(v2) == 0) {
            // 0x1f2c0
            result = 0;
            if (v1 == 4) {
                // break -> 0x1f2c8
                break;
            }
        } else {
            // 0x1f2cc
            result = function_50b48(v2 % 256, a1);
            if (v1 == 4) {
                // break -> 0x1f2c8
                break;
            }
        }
    }
    // 0x1f2c8
    return result;
}

// Address range: 0x1f2e4 - 0x1f2ec
int32_t function_1f2e4(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x1f2e4
    return function_1f8ee(a1);
}

// Address range: 0x1f2ec - 0x1f2f0
int32_t function_1f2ec(void) {
    // 0x1f2ec
    return function_1f90e();
}

// Address range: 0x1f2f0 - 0x1f2f4
int32_t function_1f2f0(int32_t a1) {
    // 0x1f2f0
    return function_1f976(a1 + 89);
}

// Address range: 0x1f2f4 - 0x1f2f8
int32_t function_1f2f4(void) {
    // 0x1f2f4
    return function_1f97a();
}

// Address range: 0x1f2f8 - 0x1f300
int32_t function_1f2f8(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x1f2f8
    __asm_ldc(15, 3, *(int32_t *)(a4 + 320));
    return function_1f902();
}

// Address range: 0x1f300 - 0x1f308
int32_t function_1f300(int32_t a1, int32_t a2, int32_t a3) {
    // 0x1f300
    __asm_ldc(a1, a2, a3);
    return function_1f98a();
}

// Address range: 0x1f30a - 0x1f31a
int32_t function_1f30a(void) {
    // 0x1f30a
    int32_t v1; // 0x1f30a
    bool v2; // 0x1f30a
    if (v2) {
        // 0x1f312
        v1 = function_ff21a95e();
    } else {
        function_ff05adf6();
        v1 = function_121adfa();
    }
    int32_t result = v1; // 0x1f316
    if (v2) {
        result = function_21abf6();
    }
    // 0x1f31a
    return result;
}

// Address range: 0x1f31c - 0x1f320
int32_t function_1f31c(void) {
    // 0x1f31c
    int32_t result; // 0x1f31c
    return result;
}

// Address range: 0x1f320 - 0x1f340
int32_t function_1f320(void) {
    // 0x1f320
    return g219 - g210;
}

// Address range: 0x1f340 - 0x1f3e8
int32_t function_1f340(int32_t a1) {
    if (a1 != 0) {
        // 0x1f370
        return function_4efd4(a1, "inited", function_4e990(function_31d38(), 0));
    }
    // 0x1f378
    if ((*(char *)&g60 | *(char *)&g221) == 0 == g290 < 3) {
        // 0x1f370
        return 0;
    }
    // 0x1f3b4
    int32_t str; // bp-2056, 0x1f340
    snprintf((char *)&str, 2048, "%s: input bad json param\n", "api_miner_inited");
    return function_2e584(3, &str, 0);
}

// Address range: 0x1f3e8 - 0x1f48c
int32_t function_1f3e8(int32_t a1) {
    if (a1 != 0) {
        int32_t v1 = function_1e28c(); // 0x1f3f8
        // 0x1f418
        return function_4efd4(a1, "chain_num", function_4e990(v1, v1 >> 31));
    }
    // 0x1f420
    if ((*(char *)&g60 | *(char *)&g221) == 0 == g290 < 3) {
        // 0x1f418
        return 0;
    }
    // 0x1f45c
    int32_t str; // bp-2056, 0x1f3e8
    snprintf((char *)&str, 2048, "%s: input bad json param\n", "api_miner_chain_num");
    return function_2e584(3, &str, 0);
}

// Address range: 0x1f490 - 0x1f570
int32_t function_1f490(int32_t a1) {
    int32_t str = 0; // bp-2072, 0x1f4a4
    if (a1 != 0) {
        // 0x1f514
        function_1e2c8();
        float64_t v1; // 0x1f490
        int32_t v2; // 0x1f490
        __asm_vstr(v1, v2);
        snprintf((char *)&str, 16, "%.2f", 0.0);
        int32_t v3 = function_4e744(&str); // 0x1f534
        return function_4efd4(a1, "rate_5s", v3);
    }
    int32_t result = 0; // 0x1f4c8
    if ((*(char *)&g60 | *(char *)&g221) == 0 != g290 < 3) {
        // 0x1f4e0
        int32_t str2; // bp-2056, 0x1f490
        snprintf((char *)&str2, 2048, "%s: input bad json param\n", "api_miner_rate_5s");
        result = function_2e584(3, &str2, 0);
    }
    // 0x1f508
    return result;
}

// Address range: 0x1f574 - 0x1f69c
int32_t function_1f574(int32_t a1, int32_t a2, int32_t a3) {
    if (a1 != 0) {
        int32_t result = function_1e2ec(); // 0x1f59c
        __asm_vldr(0x47ae147b);
        return result;
    }
    // 0x1f628
    if ((*(char *)&g60 | *(char *)&g221) == 0 == g290 < 3) {
        // 0x1f61c
        return 0;
    }
    // 0x1f650
    int32_t str; // bp-2056, 0x1f574
    snprintf((char *)&str, 2048, "%s: input bad json param\n", "api_miner_rate_30m");
    return function_2e584(3, &str, 0);
}

// Address range: 0x1f69c - 0x1f6a0
int32_t function_1f69c(void) {
    // 0x1f69c
    return function_41fce0();
}

// Address range: 0x1f6ac - 0x1f768
int32_t function_1f6ac(int32_t a1) {
    int32_t v1 = 0; // bp-2072, 0x1f6c0
    if (a1 != 0) {
        // 0x1f730
        __asm_vldr_8(g219);
        __asm_vldr(g396);
        __asm_vmov_7(g210);
        return &v1;
    }
    // 0x1f6d4
    if ((*(char *)&g60 | *(char *)&g221) == 0) {
        function_1f7a8();
    }
    // 0x1f6fc
    int32_t str; // bp-2056, 0x1f6ac
    snprintf((char *)&str, 2048, "%s: input bad json param\n", "api_miner_rate_avg");
    return function_2e584(3, &str, 0);
}

// Address range: 0x1f76a - 0x1f77e
int32_t function_1f76a(void) {
    // 0x1f76a
    int32_t v1; // 0x1f76a
    bool v2; // 0x1f76a
    if (v2) {
        v1 = function_21b052();
    } else {
        // 0x1f772
        function_ffa1b252();
        v1 = function_121b256();
    }
    int32_t result = v1; // 0x1f77a
    if (!v2 && true) {
        result = function_ff81adb6();
    }
    // 0x1f77e
    return result;
}

// Address range: 0x1f780 - 0x1f784
int32_t function_1f780(int32_t a1, int32_t a2) {
    // 0x1f780
    return function_1fca0(a2, a2);
}

// Address range: 0x1f784 - 0x1f7a8
int32_t function_1f784(int32_t a1) {
    // 0x1f784
    int32_t v1; // 0x1f784
    return function_4efd4(v1, "rate_avg", function_4e744((int32_t *)v1));
}

// Address range: 0x1f7a8 - 0x1f7c0
int32_t function_1f7a8(void) {
    // 0x1f7a8
    int32_t result; // 0x1f7a8
    return result;
}

// Address range: 0x1f7c4 - 0x1f8ac
int32_t function_1f7c4(int32_t a1, int32_t a2) {
    if (a1 != 0) {
        int32_t result = function_1a18c(); // 0x1f848
        __asm_vmov_7(result);
        return result;
    }
    int32_t result2 = 0; // 0x1f7fc
    if ((*(char *)&g60 | *(char *)&g221) == 0 != g290 < 3) {
        // 0x1f814
        int32_t str; // bp-2056, 0x1f7c4
        snprintf((char *)&str, 2048, "%s: input bad json param\n", "api_miner_rate_ideal");
        result2 = function_2e584(3, &str, 0);
    }
    // 0x1f83c
    return result2;
}

// Address range: 0x1f8b0 - 0x1f8ec
int32_t function_1f8b0(int32_t a1) {
    int32_t v1 = 0; // 0x1f8c8
    if (a1 != 0) {
        v1 = function_1f928();
    }
    int32_t result = v1; // 0x1f8dc
    if (*(char *)&g221 != 0) {
        result = function_1f8f4();
    }
    // 0x1f8e0
    return result;
}

// Address range: 0x1f8ee - 0x1f8f0
int32_t function_1f8ee(int32_t a1) {
    // 0x1f8ee
    int32_t v1; // 0x1f8ee
    return function_1ff98(a1, v1, v1, v1);
}

// Address range: 0x1f8f0 - 0x1f8f4
int32_t function_1f8f0(void) {
    // 0x1f8f0
    int32_t result; // 0x1f8f0
    return result;
}

// Address range: 0x1f8f4 - 0x1f900
int32_t function_1f8f4(void) {
    // 0x1f8f4
    int32_t result; // 0x1f8f4
    return result;
}

// Address range: 0x1f902 - 0x1f904
int32_t function_1f902(void) {
    // 0x1f902
    int32_t v1; // 0x1f902
    return function_1fe20(v1, v1, v1, v1);
}

// Address range: 0x1f904 - 0x1f90c
int32_t function_1f904(void) {
    // 0x1f904
    int32_t str; // 0x1f904
    return snprintf((char *)str, str, (char *)str);
}

// Address range: 0x1f90e - 0x1f910
int32_t function_1f90e(void) {
    // 0x1f90e
    int32_t v1; // 0x1f90e
    return function_1fe2c(v1);
}

// Address range: 0x1f910 - 0x1f928
int32_t function_1f910(int32_t a1) {
    // 0x1f910
    int32_t v1; // 0x1f910
    return function_2e584(3, (int32_t *)v1, 0);
}

// Address range: 0x1f928 - 0x1f958
int32_t function_1f928(void) {
    char * v1 = (char *)0x4847; // 0x1f938
    function_4e744((int32_t *)&v1);
    int32_t result; // 0x1f928
    return result;
}

// Address range: 0x1f958 - 0x1f95a
int32_t function_1f958(int32_t result, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x1f958
    return result;
}

// Address range: 0x1f95a - 0x1f960
int32_t function_1f95a(void) {
    // 0x1f95a
    int32_t v1; // 0x1f95a
    bool v2; // 0x1f95a
    if (v2 || false) {
        v1 = function_da562();
    }
    // 0x1f95e
    int32_t v3; // 0x1f95a
    return function_1fe7c(v1, v3, v3, v3);
}

// Address range: 0x1f960 - 0x1f968
int32_t function_1f960(int32_t a1) {
    // 0x1f960
    int32_t result; // 0x1f960
    return result;
}

// Address range: 0x1f968 - 0x1f96c
int32_t function_1f968(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t result = function_1ff8a(a1, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488); // 0x1f96a
    return result;
}

// Address range: 0x1f96c - 0x1f970
int32_t function_1f96c(int32_t a1) {
    // 0x1f96c
    return function_205fa(a1 + 7);
}

// Address range: 0x1f970 - 0x1f974
int32_t function_1f970(int32_t result) {
    // 0x1f970
    return result;
}

// Address range: 0x1f976 - 0x1f978
int32_t function_1f976(int32_t a1) {
    // 0x1f976
    int32_t v1; // 0x1f976
    return function_20020(a1, v1);
}

// Address range: 0x1f97a - 0x1f97c
int32_t function_1f97a(void) {
    // 0x1f97a
    int32_t result; // 0x1f97a
    return result;
}

// Address range: 0x1f984 - 0x1f985
int32_t function_1f984(void) {
    // 0x1f984
    int32_t result; // 0x1f984
    return result;
}

// Address range: 0x1f98a - 0x1f98c
int32_t function_1f98a(void) {
    // 0x1f98a
    int32_t result; // 0x1f98a
    return result;
}

// Address range: 0x1f98c - 0x1fa28
int32_t function_1f98c(int32_t a1) {
    // 0x1f98c
    bool v1; // 0x1f98c
    if (!v1) {
        int32_t v2 = function_1e30c(); // 0x1f994
        // 0x1f9b4
        int32_t v3; // 0x1f98c
        return function_4efd4(v3, "fan_num", function_4e990(v2, v2 >> 31));
    }
    // 0x1f9bc
    if ((*(char *)&g60 | *(char *)&g221) == 0 == g290 < 3) {
        // 0x1f9b4
        int32_t result; // 0x1f98c
        return result;
    }
    // 0x1f9f8
    int32_t str; // bp-2048, 0x1f98c
    snprintf((char *)&str, 2048, "%s: input bad json param\n", "api_miner_fan_num");
    return function_2e584(3, &str, 0);
}

// Address range: 0x1fa2c - 0x1fb10
int32_t function_1fa2c(int32_t a1) {
    if (a1 == 0) {
        // 0x1faa0
        if ((*(char *)&g60 | *(char *)&g221) == 0 == g290 < 3) {
            // 0x1fa94
            return 0;
        }
        // 0x1fadc
        int32_t str; // bp-2072, 0x1fa2c
        snprintf((char *)&str, 2048, "%s: input bad json param\n", "api_miner_fan_speed");
        return function_2e584(3, &str, 0);
    }
    int32_t v1 = function_4e540(); // 0x1fa40
    uint32_t v2 = function_1e2fc(); // 0x1fa48
    if (v2 >= 1) {
        int32_t v3 = 0;
        int32_t v4 = v3 + 1; // 0x1fa5c
        int32_t v5 = function_1e43c(v3); // 0x1fa60
        function_4f494(v1, function_4e990(v5, v5 >> 31));
        while (v2 != v4) {
            // 0x1fa58
            v3 = v4;
            v4 = v3 + 1;
            v5 = function_1e43c(v3);
            function_4f494(v1, function_4e990(v5, v5 >> 31));
        }
    }
    // 0x1fa94
    return function_4efd4(a1, "fan", v1);
}

// Address range: 0x1fb10 - 0x1fb18
int32_t function_1fb10(int32_t a1) {
    int32_t result = function_201bc(a1, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488); // 0x1fb16
    return result;
}

// Address range: 0x1fb18 - 0x1fbb8
int32_t function_1fb18(int32_t a1, int32_t a2) {
    // 0x1fb18
    bool v1; // 0x1fb18
    bool v2 = v1;
    bool v3 = v1;
    int32_t v4; // 0x1fb18
    if (a1 != 0 == (v2 != !v3) == (v3 || !v2 || v4 == 0)) {
        int32_t v5 = function_1a2e0(a2); // 0x1fbac
        return function_4e990(v5, v5 >> 31);
    }
    char v6 = *(char *)&g60; // 0x1fb54
    int32_t result = a1; // 0x1fb48
    if ((v6 | *(char *)&g221) == 0 != g290 < 3) {
        // 0x1fb74
        int32_t str; // bp-2056, 0x1fb18
        snprintf((char *)&str, 2048, "%s: input bad param\n", "api_miner_chain_frequency");
        result = function_2e584(3, &str, 0);
    }
    // 0x1fb9c
    return result;
}

// Address range: 0x1fbba - 0x1fbbc
int32_t function_1fbba(void) {
    // 0x1fbba
    return function_201c2();
}

// Address range: 0x1fbbc - 0x1fbcc
int32_t function_1fbbc(int32_t a1, uint32_t a2) {
    // 0x1fbbc
    int32_t v1; // 0x1fbbc
    return function_4efd4(v1, (char *)(a2 % 0x10000 | 0x60000), a1);
}

// Address range: 0x1fbcc - 0x1fbce
int32_t function_1fbcc(void) {
    // 0x1fbcc
    int32_t result; // 0x1fbcc
    return result;
}

// Address range: 0x1fbce - 0x1fbd0
int32_t function_1fbce(void) {
    // 0x1fbce
    return function_200ec();
}

// Address range: 0x1fbd2 - 0x1fbdc
int32_t function_1fbd2(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x1fbd2
    return function_20662(a1);
}

// Address range: 0x1fbdc - 0x1fc3c
int32_t function_1fbdc(int32_t a1, uint32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = a1; // 0x1fc0c
    if ((a1 == a4 || a2 >= 3 == (a2 != 3) ? 1 : a2 == 3 | a2 < 3 ? 0 : a3) == a4) {
        v1 = function_1fc84(a1, a2);
    }
    int32_t result = v1; // 0x1fc20
    if ((*(char *)&g60 | *(char *)&g221) == 0) {
        result = function_1fc68((int32_t)&g488);
    }
    // 0x1fc38
    return result;
}

// Address range: 0x1fc3e - 0x1fc40
int32_t function_1fc3e(int32_t a1) {
    // 0x1fc3e
    int32_t v1; // 0x1fc3e
    return function_1f780(a1, v1);
}

// Address range: 0x1fc42 - 0x1fc44
int32_t function_1fc42(int32_t a1) {
    // 0x1fc42
    int32_t v1; // 0x1fc42
    int32_t result = function_20160(a1, v1, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488); // 0x1fc42
    return result;
}

// Address range: 0x1fc44 - 0x1fc50
int32_t function_1fc44(int32_t str, int32_t a2, uint32_t a3) {
    // 0x1fc44
    return snprintf((char *)str, 2048, (char *)(a3 % 0x10000 | 0x60000));
}

// Address range: 0x1fc52 - 0x1fc54
int32_t function_1fc52(int32_t a1) {
    // 0x1fc52
    return function_20170(a1);
}

// Address range: 0x1fc54 - 0x1fc68
int32_t function_1fc54(int32_t a1) {
    // 0x1fc54
    int32_t v1; // 0x1fc54
    return function_2e584(3, (int32_t *)v1, 0);
}

// Address range: 0x1fc68 - 0x1fc84
int32_t function_1fc68(int32_t a1) {
    // 0x1fc68
    int32_t result; // 0x1fc68
    return result;
}

// Address range: 0x1fc84 - 0x1fca0
int32_t function_1fc84(int32_t a1, int32_t a2) {
    // 0x1fc84
    return function_19de4(a2);
}

// Address range: 0x1fca0 - 0x1fca4
int32_t function_1fca0(int32_t a1, int32_t a2) {
    // 0x1fca0
    return function_1ffe6();
}

// Address range: 0x1fca4 - 0x1fccc
int32_t function_1fca4(int32_t a1) {
    // 0x1fca4
    int32_t str; // 0x1fca4
    snprintf((char *)str, str, (char *)str);
    int32_t v1; // 0x1fca4
    int32_t v2 = function_4e744(&v1); // 0x1fcac
    return function_4efd4(str, "rate_ideal", v2);
}

// Address range: 0x1fccc - 0x1fd80
int32_t function_1fccc(int32_t result, int32_t a2) {
    // 0x1fccc
    if ((*(char *)&g60 | *(char *)&g221) != 0 || g290 > 2) {
        // 0x1fd34
        int32_t str; // bp-2056, 0x1fccc
        snprintf((char *)&str, 2048, "%s: input bad param\n", "api_miner_chain_rate_real");
        return function_2e584(3, &str, 0);
    }
    // 0x1fd7c
    return result;
}

// Address range: 0x1fd80 - 0x1fd98
int32_t function_1fd80(int32_t a1, int32_t a2, int32_t a3) {
    // 0x1fd80
    bool v1; // 0x1fd80
    if (v1) {
        // 0x1fd94
        return function_2039c();
    }
    // 0x1fd82
    return function_202a0();
}

// Address range: 0x1fd98 - 0x1fdd4
int32_t function_1fd98(int32_t a1, int32_t a2, uint32_t a3, int32_t a4) {
    // 0x1fd98
    float64_t v1; // 0x1fd98
    __asm_vstr(v1, a4);
    int32_t str; // 0x1fd98
    snprintf((char *)&str, 16, (char *)(a3 % 0x10000 | 0x60000));
    int32_t v2 = function_4e744(&str); // 0x1fdb0
    int32_t v3; // 0x1fd98
    return function_4efd4(v3, "rate_real", v2);
}

// Address range: 0x1fdd8 - 0x1fe20
int32_t function_1fdd8(int32_t a1, uint32_t a2) {
    int32_t v1 = a1; // 0x1fdf8
    int32_t v2; // 0x1fdd8
    if (a1 != 0 == (a2 >= 3 != a2 != 3) == (a2 == 3 || a2 < 3 || v2 == 0)) {
        v1 = function_1fe68(a1, a2);
    }
    int32_t result = v1; // 0x1fe0c
    if (*(char *)&g221 != 0) {
        result = function_1fe38((int32_t)&g488);
    }
    // 0x1fe10
    return result;
}

// Address range: 0x1fe20 - 0x1fe28
int32_t function_1fe20(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x1fe20
    return function_1ff78(0);
}

// Address range: 0x1fe28 - 0x1fe2c
int32_t function_1fe28(int32_t a1) {
    // 0x1fe28
    return function_209cc(a1 + 7);
}

// Address range: 0x1fe2c - 0x1fe30
int32_t function_1fe2c(int32_t a1) {
    int32_t result = function_1f958((int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488); // 0x1fe2e
    return result;
}

// Address range: 0x1fe30 - 0x1fe38
int32_t function_1fe30(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x1fe30
    return result;
}

// Address range: 0x1fe38 - 0x1fe68
int32_t function_1fe38(int32_t a1) {
    // 0x1fe38
    int32_t str; // 0x1fe38
    snprintf((char *)&str, 2048, "%s: input bad param\n", "api_miner_chain_asic_num");
    return function_2e584(3, &str, 0);
}

// Address range: 0x1fe68 - 0x1fe7c
int32_t function_1fe68(int32_t a1, int32_t a2) {
    int32_t v1 = function_1e67c(a2); // 0x1fe70
    return function_4e990(v1, v1 >> 31);
}

// Address range: 0x1fe7c - 0x1fe80
int32_t function_1fe7c(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x1fe7c
    return function_20742(a4 >> 6);
}

// Address range: 0x1fe80 - 0x1fe98
int32_t function_1fe80(int32_t a1, uint32_t a2, int32_t a3) {
    // 0x1fe80
    int32_t v1; // 0x1fe80
    return function_4efd4(v1, (char *)(a2 % 0x10000 | 0x60000), a1);
}

// Address range: 0x1fe9c - 0x1ff78
int32_t function_1fe9c(int32_t a1, uint32_t a2) {
    // 0x1fe9c
    int32_t v1; // bp-2576, 0x1fe9c
    int32_t * set_mem = memset(&v1, 0, 512); // 0x1febc
    int32_t v2; // 0x1fe9c
    if (a1 != 0 == (a2 >= 3 != a2 != 3) == (a2 == 3 || a2 < 3 || v2 == 0)) {
        // 0x1ff58
        function_1e894(a2, &v1);
        return function_4e744(&v1);
    }
    // 0x1fedc
    if ((*(char *)&g60 | *(char *)&g221) != 0 || g290 > 2) {
        // 0x1ff04
        int32_t str; // bp-2064, 0x1fe9c
        snprintf((char *)&str, 2048, "%s: input bad param\n", "api_miner_chain_asic_status");
        return function_2e584(3, &str, 0);
    }
    // 0x1ff4c
    return (int32_t)set_mem;
}

// Address range: 0x1ff78 - 0x1ff7c
int32_t function_1ff78(int32_t a1) {
    // 0x1ff78
    int32_t v1; // 0x1ff78
    return function_202be(a1, v1, v1);
}

// Address range: 0x1ff7c - 0x1ff88
int32_t function_1ff7c(void) {
    // 0x1ff7c
    int32_t v1; // 0x1ff7c
    return function_4efd4(v1, (char *)v1, v1);
}

// Address range: 0x1ff8a - 0x1ff94
int32_t function_1ff8a(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    // 0x1ff8a
    int32_t v1; // 0x1ff8a
    return function_20638(a1, v1, v1, a1);
}

// Address range: 0x1ff98 - 0x1ffa4
int32_t function_1ff98(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = a1 + 1; // 0x1ff9c
    int32_t v2; // 0x1ff98
    *(int16_t *)(v2 + 28) = (int16_t)v1;
    return function_20cf0(v1);
}

// Address range: 0x1ffa4 - 0x1ffe4
int32_t function_1ffa4(void) {
    // 0x1ffa4
    int32_t v1; // 0x1ffa4
    bool v2; // 0x1ffa4
    int32_t v3; // 0x1ffa4
    if (v3 == 0 == !v2) {
        v1 = function_20020(v3, v3);
    }
    int32_t v4 = v1; // 0x1ffc4
    if (*(char *)&g221 != 0) {
        v4 = function_1fff0();
    }
    int32_t result = v4; // 0x1ffd8
    if (*(char *)&g60 != 0) {
        result = function_1fff0();
    }
    // 0x1ffdc
    return result;
}

// Address range: 0x1ffe6 - 0x1ffe8
int32_t function_1ffe6(void) {
    // 0x1ffe6
    int32_t v1; // 0x1ffe6
    return function_1fb10(v1);
}

// Address range: 0x1ffe8 - 0x1fff0
int32_t function_1ffe8(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x1ffe8
    return result;
}

// Address range: 0x1fff0 - 0x1fff1
int32_t function_1fff0(void) {
    // 0x1fff0
    int32_t result; // 0x1fff0
    return result;
}

// Address range: 0x1fff2 - 0x1fff4
int32_t function_1fff2(int32_t a1) {
    // 0x1fff2
    return function_205fa(a1);
}

// Address range: 0x1fff4 - 0x20018
int32_t function_1fff4(int32_t a1, int32_t a2, uint32_t a3) {
    // 0x1fff4
    int32_t str; // 0x1fff4
    snprintf((char *)&str, 2048, (char *)(a3 % 0x10000 | 0x60000));
    return function_2e584(3, &str, 0);
}

// Address range: 0x20018 - 0x20020
int32_t function_20018(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x20018
    int32_t result; // 0x20018
    return result;
}

// Address range: 0x20020 - 0x20024
int32_t function_20020(int32_t a1, int32_t a2) {
    // 0x20020
    *(int32_t *)(2 * a1) = a2;
    return function_20872();
}

// Address range: 0x20024 - 0x200cc
int32_t function_20024(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    int32_t v1 = function_4e540(); // 0x20028
    int32_t v2 = function_1e0c0(); // 0x20030
    int32_t v3; // 0x20024
    int32_t v4; // 0x20024
    if (function_11eec(v2, "BHB28601", v4, v4) == 0) {
        // 0x20060
        v3 = function_14434();
        goto lab_0x20068;
    } else {
        int32_t v5 = function_1e0c0(); // 0x20048
        if (function_11eec(v5, "BHB28501", v4, v4) == 0) {
            // 0x20060
            v3 = function_14434();
            goto lab_0x20068;
        } else {
            // 0x200c0
            v3 = function_1e19c();
            goto lab_0x20068;
        }
    }
  lab_0x20068:
    // 0x20068
    if (v3 < 1) {
        // 0x200a4
        return function_4efd4(a1, "temp_pic", v1);
    }
    int32_t v6 = 0; // 0x2006c
    int32_t v7 = v6 + 1; // 0x2007c
    int32_t v8 = __asm_sxth(function_152f0(v4, v6 % 256)); // 0x20084
    function_4f494(v1, function_4e990(v8, v8 >> 31));
    v6 = v7;
    while (v3 != v7) {
        // 0x20074
        v7 = v6 + 1;
        v8 = __asm_sxth(function_152f0(v4, v6 % 256));
        function_4f494(v1, function_4e990(v8, v8 >> 31));
        v6 = v7;
    }
    // 0x200a4
    return function_4efd4(a1, "temp_pic", v1);
}

// Address range: 0x200d0 - 0x200d4
int32_t function_200d0(int32_t a1) {
    // 0x200d0
    return function_20778();
}

// Address range: 0x200d4 - 0x200e4
int32_t function_200d4(uint32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x200d4
    int32_t v1; // 0x200d4
    int32_t v2 = a1 >> (uint32_t)v1; // 0x200d4
    *(int16_t *)(v1 + 28) = (int16_t)v2;
    return function_20786(v2);
}

// Address range: 0x200e4 - 0x200e8
int32_t function_200e4(void) {
    // 0x200e4
    int32_t v1; // 0x200e4
    // 0x200e6
    int32_t v2; // 0x200e4
    return function_20584(v1, v2);
}

// Address range: 0x200ec - 0x200fc
int32_t function_200ec(void) {
    // 0x200ec
    bool v1; // 0x200ec
    int32_t v2; // 0x200ec
    if (v1) {
        // 0x200f8
        return function_206fe(v2, v2, v2, v2);
    }
    // 0x200ee
    return function_2058c(v2);
}

// Address range: 0x200fc - 0x20160
int32_t function_200fc(int32_t a1, int32_t a2, int32_t a3, uint32_t a4) {
    char v1 = *(char *)(a4 % 0x10000 | (int32_t)&g218); // 0x20100
    int32_t result = a1; // 0x20108
    if ((*(char *)&g60 || v1) == 0 != g290 < 3) {
        // 0x20134
        int32_t str; // 0x200fc
        snprintf((char *)&str, 2048, "%s: input bad param\n", "api_miner_chain_temp_chip");
        result = function_2e584(3, &str, 0);
    }
    // 0x2015c
    return result;
}

// Address range: 0x20160 - 0x20170
int32_t function_20160(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x20160
    bool v1; // 0x20160
    if (v1) {
        // 0x2016c
        *(int32_t *)a1 = a1;
        return function_204b2();
    }
    // 0x20162
    return function_20680(a1);
}

// Address range: 0x20170 - 0x20171
int32_t function_20170(int32_t a1) {
    // 0x20170
    int32_t result; // 0x20170
    return result;
}

// Address range: 0x20172 - 0x201ba
int32_t function_20172(int32_t a1, int32_t a2, int32_t a3, int32_t a4, char a5) {
    // 0x20172
    bool v1; // 0x20172
    if (!v1) {
        __asm_svclo(0xb4eb00);
    }
    if (!v1) {
        int32_t result = a1; // 0x2018a
        if ((a1 & 36) == 0 && !((v1 ? v1 : (a1 & 0x4000000) != 0))) {
            // 0x2018e
            result = function_fe322992();
        }
        // .thread
        __asm_svcne(0xc0e6bf);
        return result;
    }
    if ((1 << a4 - 1 & a4) == 0) {
        // 0x2018e
        function_fe322992();
    }
    // 0x2018e
    int32_t v2; // 0x20172
    int32_t result2 = v2 * a4;
    if ((0x100000 * result2 & v2) == 0) {
        return result2;
    }
    // .thread
    __asm_svcne(0xc0e6bf);
    return result2;
}

// Address range: 0x201ba - 0x201bc
int32_t function_201ba(void) {
    // 0x201ba
    return function_20610();
}

// Address range: 0x201bc - 0x201c2
int32_t function_201bc(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x201bc
    int32_t v1; // 0x201bc
    return (uint32_t)v1 / 0x400000 + a1;
}

// Address range: 0x201c2 - 0x201c3
int32_t function_201c2(void) {
    // 0x201c2
    int32_t result; // 0x201c2
    return result;
}

// Address range: 0x201c4 - 0x201f8
int32_t function_201c4(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x201c4
    int32_t v1; // 0x201c4
    return function_4efd4(v1, "temp_chip", v1);
}

// Address range: 0x201d8 - 0x201d9
int32_t function_201d8(void) {
    // 0x201d8
    int32_t result; // 0x201d8
    return result;
}

// Address range: 0x201f8 - 0x20230
int32_t function_201f8(void) {
    // 0x201f8
    int32_t v1; // 0x201f8
    int32_t v2 = __asm_sxth(function_152f0(v1, v1)); // 0x201fc
    function_4f494(v1, function_4e990(v2, v2 >> 31));
    if (function_1e19c() > v1 + 1) {
        function_201f8();
    }
    // 0x2022c
    return function_201d8();
}

// Address range: 0x20234 - 0x202a0
int32_t function_20234(int32_t a1, uint32_t a2) {
    int32_t result = a1; // 0x20258
    int32_t v1; // 0x20234
    if (a1 != 0 == (a2 >= 3 != a2 != 3) == (a2 == 3 || a2 < 3 || v1 == 0)) {
        result = function_202cc(a1, a2);
    }
    // 0x2025c
    return result;
}

// Address range: 0x202a0 - 0x202a4
int32_t function_202a0(void) {
    // 0x202a0
    return function_20926();
}

// Address range: 0x202a4 - 0x202bc
int32_t function_202a4(void) {
    // 0x202a4
    int32_t str; // 0x202a4
    int32_t size; // 0x202a4
    snprintf((char *)&str, size, (char *)size);
    return 3;
}

// Address range: 0x202be - 0x202c4
int32_t function_202be(int32_t a1, int32_t a2, int32_t a3) {
    // 0x202be
    return function_207e0(a1);
}

// Address range: 0x202c4 - 0x202cc
int32_t function_202c4(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x202c4
    int32_t result; // 0x202c4
    return result;
}

// Address range: 0x202cc - 0x20308
int32_t function_202cc(int32_t a1, int32_t a2) {
    // 0x202cc
    function_4e540();
    if (g414 == 1) {
        function_2037c();
    }
    // 0x202f0
    if (g74 > 0) {
        function_20324((int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488);
    }
    // 0x20304
    return function_2037c();
}

// Address range: 0x20308 - 0x2031c
int32_t function_20308(void) {
    // 0x20308
    int32_t v1; // 0x20308
    int32_t v2 = __asm_sxth(function_15354(v1, v1)); // 0x2030c
    return function_4e990(v2, v2 >> 31);
}

// Address range: 0x2031e - 0x20320
int32_t function_2031e(int32_t a1) {
    // 0x2031e
    return function_20662(a1);
}

// Address range: 0x20320 - 0x20324
int32_t function_20320(void) {
    // 0x20320
    int32_t v1; // 0x20320
    return function_4f494(v1, v1);
}

// Address range: 0x20324 - 0x2035c
int32_t function_20324(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x20324
    int32_t v1; // 0x20324
    if (function_14434() > v1) {
        function_20308();
    }
    // 0x2033c
    return function_4efd4(v1, "temp_pcb", v1);
}

// Address range: 0x2035c - 0x20364
int32_t function_2035c(void) {
    // 0x2035c
    int32_t v1; // 0x2035c
    return __asm_sxth(function_152f0(v1, v1));
}

// Address range: 0x20366 - 0x20368
int32_t function_20366(void) {
    // 0x20366
    return function_20872();
}

// Address range: 0x20368 - 0x2037c
int32_t function_20368(int32_t a1) {
    // 0x20368
    int32_t v1; // 0x20368
    return function_4f494(v1, function_4e990(a1, a1 >> 31));
}

// Address range: 0x2037c - 0x20390
int32_t function_2037c(void) {
    // 0x2037c
    function_1e19c();
    int32_t result; // 0x2037c
    return result;
}

// Address range: 0x20390 - 0x20391
int32_t function_20390(void) {
    // 0x20390
    int32_t result; // 0x20390
    return result;
}

// Address range: 0x20398 - 0x2039c
int32_t function_20398(int32_t result) {
    // 0x20398
    return result;
}

// Address range: 0x2039c - 0x2039e
int32_t function_2039c(void) {
    // 0x2039c
    int32_t result; // 0x2039c
    return result;
}

// Address range: 0x2039e - 0x20404
int32_t function_2039e(uint32_t a1, int32_t a2, int32_t a3, uint32_t a4) {
    // 0x2039e
    bool v1; // 0x2039e
    int32_t v2; // 0x2039e
    bool v3; // 0x2039e
    if (v3) {
        v2 = a1 / 128 & a2;
        v1 = (a1 & 64) != 0;
    }
    int32_t v4; // 0x2039e
    int32_t v5; // 0x2039e
    int32_t v6; // 0x2039e
    if (v3) {
        int32_t v7 = a1 / 128 & a1 & function_d90f2() / 128; // 0x203b2
        v4 = v7;
        if ((v6 & 1 << a4 - 1) != 0) {
            // .critedge
            if ((v6 >> a4 & v6) == 0) {
                return v7 - a4;
            }
            // .thread24
            *(int32_t *)v7 = (int32_t)&v5;
            // 0x20402
            function_d900e();
            return function_20b46();
        }
    } else {
        // .thread8
        v4 = a1;
        if (v3 ? (v6 & 8) != 0 : v1) {
            // .thread24
            *(int32_t *)a1 = (int32_t)&v5;
            // 0x20402
            function_d900e();
            return function_20b46();
        }
    }
    *(int32_t *)v6 = v4;
    uint32_t v8 = 64 * v4; // 0x203c2
    if (v2 == v8) {
        return v4 - a4;
    }
    int32_t v9 = v4; // 0x203d2
    if ((v4 & 32) == 0 && v2 < v8) {
        int32_t v10 = function_1726bda(); // 0x203d2
        if ((v10 & 32 || a3 & 0x4000000) != 0) {
            // .thread24
            *(int32_t *)v10 = (int32_t)&v5;
            // 0x20402
            function_d900e();
            return function_20b46();
        }
        v9 = function_fe826bee();
        if ((v9 & 32) == 0) {
            // 0x20402
            function_d900e();
            return function_20b46();
        }
    }
    // .thread24
    *(int32_t *)v9 = (int32_t)&v5;
    // 0x20402
    function_d900e();
    return function_20b46();
}

// Address range: 0x20404 - 0x20430
int32_t function_20404(int32_t a1, int32_t size, uint32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10) {
    // 0x20404
    int32_t str; // 0x20404
    snprintf((char *)&str, size, (char *)(a3 % 0x10000 | 0x60000));
    return function_2e584(3, &str, 0);
}

// Address range: 0x20430 - 0x20444
int32_t function_20430(int32_t a1, int32_t a2) {
    // 0x20430
    return function_4e540();
}

// Address range: 0x20446 - 0x20448
int32_t function_20446(int32_t a1) {
    // 0x20446
    return function_1ff78(a1);
}

// Address range: 0x20448 - 0x20490
int32_t function_20448(int32_t a1, int32_t a2) {
    // 0x20448
    int32_t v1; // 0x20448
    uint32_t v2 = v1;
    int32_t v3 = a1; // 0x20454
    if (v2 >= 23 == (v2 != 23)) {
        v3 = function_204b8(a1, a2);
    }
    if (v2 == 0) {
        function_20498(v3);
    }
    int64_t v4 = *(int64_t *)(192 * a2 + (int32_t)&g209); // 0x20470
    return function_4f494(a1, function_4e990(function_6015c(), (int32_t)v4));
}

// Address range: 0x20492 - 0x20494
int32_t function_20492(int32_t a1) {
    // 0x20492
    return function_20742(a1);
}

// Address range: 0x20494 - 0x20498
int32_t function_20494(void) {
    // 0x20494
    int32_t result; // 0x20494
    return result;
}

// Address range: 0x20498 - 0x204ac
int32_t function_20498(int32_t a1) {
    // 0x20498
    int32_t v1; // 0x20498
    return function_4efd4(v1, "rate_array", v1);
}

// Address range: 0x204ac - 0x204ae
int32_t function_204ac(void) {
    // 0x204ac
    int32_t result; // 0x204ac
    return result;
}

// Address range: 0x204ae - 0x204b0
int32_t function_204ae(int32_t a1) {
    // 0x204ae
    return function_209cc(a1);
}

// Address range: 0x204b0 - 0x204b2
int32_t function_204b0(void) {
    // 0x204b0
    int32_t result; // 0x204b0
    return result;
}

// Address range: 0x204b2 - 0x204b4
int32_t function_204b2(void) {
    // 0x204b2
    int32_t v1; // 0x204b2
    return function_209d0(v1);
}

// Address range: 0x204b4 - 0x204b8
int32_t function_204b4(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    // 0x204b4
    int32_t result; // 0x204b4
    return result;
}

// Address range: 0x204b8 - 0x204fc
int32_t function_204b8(int32_t result, int32_t a2) {
    // 0x204b8
    return result;
}

// Address range: 0x204fe - 0x20500
int32_t function_204fe(void) {
    // 0x204fe
    return function_20610();
}

// Address range: 0x20500 - 0x20524
int32_t function_20500(void) {
    int32_t v1 = function_6015c(); // 0x20504
    int32_t v2; // 0x20500
    int32_t v3; // 0x20500
    int32_t v4 = function_4f494(v3, function_4e990(v1, (int32_t)*(int64_t *)&v2)); // 0x20514
    return function_20498(v4);
}

// Address range: 0x20528 - 0x20584
int32_t function_20528(int32_t a1, uint32_t a2) {
    int32_t result = a1; // 0x20548
    int32_t v1; // 0x20528
    if (a1 != 0 == (a2 >= 3 != a2 != 3) == (a2 == 3 || a2 < 3 || v1 == 0)) {
        result = function_205b8(a1, a2, (int32_t)&g488);
    }
    // 0x2054c
    return result;
}

// Address range: 0x20584 - 0x2058c
int32_t function_20584(int32_t a1, int32_t a2) {
    // 0x20584
    return function_20b92();
}

// Address range: 0x2058c - 0x20590
int32_t function_2058c(int32_t a1) {
    // 0x2058c
    return function_20cd2();
}

// Address range: 0x20590 - 0x205b8
int32_t function_20590(int32_t a1, int32_t size, uint32_t a3, int32_t a4) {
    // 0x20590
    int32_t str; // 0x20590
    snprintf((char *)&str, size, (char *)(a3 % 0x10000 | 0x60000));
    return function_2e584(3, &str, 0);
}

// Address range: 0x205b8 - 0x205e8
int32_t function_205b8(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = function_1e7bc(a2); // 0x205c0
    return function_4efd4(a1, "hw", function_4e990(v1, v1 >> 31));
}

// Address range: 0x205ec - 0x205f0
int32_t function_205ec(int32_t a1) {
    // 0x205ec
    return function_20c94(a1);
}

// Address range: 0x205fa - 0x20600
int32_t function_205fa(int32_t a1) {
    // 0x205fa
    int32_t v1; // 0x205fa
    *(int16_t *)(v1 + 28) = (int16_t)a1;
    return function_207e4(a1);
}

// Address range: 0x20600 - 0x20610
int32_t function_20600(void) {
    // 0x20600
    int32_t result; // 0x20600
    return result;
}

// Address range: 0x20610 - 0x20614
int32_t function_20610(void) {
    // 0x20610
    return function_20c16();
}

// Address range: 0x20614 - 0x20638
int32_t function_20614(int32_t a1, int32_t a2, int32_t a3, uint32_t a4) {
    int32_t result = a1; // 0x20620
    if (*(char *)(a4 % 0x10000 || (int32_t)&g218) != 0) {
        result = function_2064c();
    }
    // 0x20624
    return result;
}

// Address range: 0x20638 - 0x2063c
int32_t function_20638(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x20638
    return function_20c5a();
}

// Address range: 0x2063c - 0x20640
int32_t function_2063c(int32_t a1) {
    // 0x2063c
    int32_t v1; // 0x2063c
    return function_20cc2(a1 + 7, v1, v1);
}

// Address range: 0x20640 - 0x20644
int32_t function_20640(int32_t result) {
    // 0x20640
    return result;
}

// Address range: 0x20646 - 0x20648
int32_t function_20646(int32_t a1) {
    // 0x20646
    return function_20cf0(a1);
}

// Address range: 0x20648 - 0x2064c
int32_t function_20648(void) {
    // 0x20648
    int32_t result; // 0x20648
    return result;
}

// Address range: 0x2064c - 0x20660
int32_t function_2064c(void) {
    // 0x2064c
    int32_t v1; // 0x2064c
    return &v1;
}

// Address range: 0x20662 - 0x20663
int32_t function_20662(int32_t a1) {
    // 0x20662
    int32_t result; // 0x20662
    return result;
}

// Address range: 0x20664 - 0x20674
int32_t function_20664(void) {
    // 0x20664
    int32_t v1; // 0x20664
    return function_2e584(3, &v1, 0);
}

// Address range: 0x20674 - 0x2067c
int32_t function_20674(int32_t a1) {
    // 0x20674
    int32_t result; // 0x20674
    return result;
}

// Address range: 0x2067c - 0x20680
int32_t function_2067c(int32_t a1, int32_t a2) {
    // 0x2067c
    int32_t v1; // 0x2067c
    return function_20c84(a1, a2 + 24, v1, v1);
}

// Address range: 0x20680 - 0x20684
int32_t function_20680(int32_t a1) {
    // 0x20680
    return function_209c6();
}

// Address range: 0x20684 - 0x206b0
int32_t function_20684(int32_t a1, int32_t a2, int32_t a3, uint32_t a4, int32_t a5) {
    int32_t v1 = *(int32_t *)((a4 % 0x10000 | (int32_t)&g357) + 4 * a2); // 0x20688
    int32_t v2; // 0x20684
    return function_4efd4(v2, "nonce", function_4e990(v1, v1 >> 31));
}

// Address range: 0x206b4 - 0x206fc
int32_t function_206b4(int32_t a1, int32_t a2) {
    int32_t result = a1; // 0x206e8
    if (*(char *)&g221 != 0) {
        result = function_20714();
    }
    // 0x206ec
    return result;
}

// Address range: 0x206fe - 0x20704
int32_t function_206fe(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x206fe
    return function_20d22();
}

// Address range: 0x20704 - 0x20714
int32_t function_20704(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x20704
    return result;
}

// Address range: 0x20714 - 0x20740
int32_t function_20714(void) {
    // 0x20714
    int32_t str; // 0x20714
    snprintf((char *)&str, 2048, "%s: input bad param\n", "api_miner_chain_eeprom");
    return function_2e584(3, &str, 0);
}

// Address range: 0x20742 - 0x20748
int32_t function_20742(int32_t a1) {
    // 0x20742
    return function_20a8a();
}

// Address range: 0x20748 - 0x20778
int32_t function_20748(int32_t a1, int32_t a2, int32_t a3) {
    // 0x20748
    if (function_18b30(a2) == 0) {
        function_20778();
    }
    // 0x20758
    int32_t v1; // 0x20748
    return function_4efd4(v1, "eeprom", function_4eb48());
}

// Address range: 0x20778 - 0x20779
int32_t function_20778(void) {
    // 0x20778
    int32_t result; // 0x20778
    return result;
}

// Address range: 0x2077a - 0x20780
int32_t function_2077a(int32_t a1) {
    // 0x2077a
    return function_20ac2();
}

// Address range: 0x20780 - 0x20784
int32_t function_20780(void) {
    // 0x20780
    int32_t result; // 0x20780
    return result;
}

// Address range: 0x20786 - 0x2078a
int32_t function_20786(int32_t result) {
    // 0x20786
    return result;
}

// Address range: 0x2078a - 0x207de
int32_t function_2078a(uint32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x2078a
    bool v1; // 0x2078a
    bool v2 = v1 | false; // 0x2078a
    if (v2) {
        float32_t v3; // 0x2078a
        __asm_vdivle_f16(v3, v3, v3);
    }
    bool v4; // 0x2078a
    int32_t v5; // 0x2078a
    int32_t v6; // 0x2078a
    int32_t v7; // 0x2078a
    if (v1) {
        uint32_t v8 = result / 8;
        if ((result & 4) == 0) {
            // .thread2.thread
            *(int32_t *)a4 = v7 & v8;
            *(int32_t *)(a4 + 4) = 0x207b0;
            v5 = a4 - 0x207b0;
            goto lab_dec_label_pc_unknown_5;
        } else {
            // .thread2
            *(int32_t *)a4 = v8 ^ result;
            *(int32_t *)(a4 + 4) = 0x207b0;
            v6 = a4 - 0x207b0;
            v4 = true;
            goto lab__thread14;
        }
    } else {
        if (v2) {
            v5 = a4;
            v6 = a4;
            v4 = true;
            if ((result & 64) == 0) {
                goto lab_dec_label_pc_unknown_5;
            } else {
                goto lab__thread14;
            }
        } else {
            *(char *)v7 = (char)(result / 128 & result);
            v5 = a4;
            v6 = a4;
            v4 = true;
            if ((result & 64) == 0) {
                goto lab_dec_label_pc_unknown_5;
            } else {
                goto lab__thread14;
            }
        }
    }
  lab_dec_label_pc_unknown_5:
    v6 = v5;
    v4 = true;
    int32_t v9; // 0x2078a
    if ((1 << v5 - 1 & v7) == 0) {
        v6 = v5;
        v9 = result / 128 & a2;
        v4 = (result & 64) != 0;
    }
    goto lab__thread14;
  lab__thread14:;
    int32_t v10 = v6;
    bool v11 = true; // 0x207ba
    if (!((v1 ? (result & 64) != 0 : v4))) {
        v11 = (1 << v10 - 1 & v7) != 0;
    }
    int32_t v12; // 0x2078a
    if (v1) {
        int32_t v13 = result / 128 & result; // 0x207be
        v12 = v13;
        if ((1 << v10 - 1 & v10) != 0) {
            // .critedge.thread
            return v13 - v10;
        }
    } else {
        v12 = result;
        if (v11) {
            // 0x207de
            return result;
        }
    }
    // .critedge
    *(int32_t *)v7 = v12;
    uint32_t v14 = 64 * v12; // 0x207ca
    if (v9 == v14) {
        // .critedge.thread
        return v12 - v10;
    }
    int32_t result2 = v12; // 0x207da
    if ((v12 & 32) == 0 && v9 < v14) {
        result2 = function_1726fe2();
    }
    // 0x207de
    return result2;
}

// Address range: 0x207e0 - 0x207e4
int32_t function_207e0(int32_t a1) {
    // 0x207e0
    return a1 + 72;
}

// Address range: 0x207e4 - 0x207e8
int32_t function_207e4(int32_t a1) {
    // 0x207e4
    return function_20390();
}

// Address range: 0x207e8 - 0x20844
int32_t function_207e8(int32_t result, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x207e8
    if (a4 != 0 || g290 > 2) {
        // 0x207f0
        int32_t str; // bp+32, 0x207e8
        snprintf((char *)&str, 2048, "%s: input bad param\n", "api_miner_chain_sn");
        return function_2e584(3, &str, 0);
    }
    // 0x20838
    return result;
}

// Address range: 0x20844 - 0x20870
int32_t function_20844(void) {
    // 0x20844
    int32_t v1; // 0x20844
    int32_t v2; // 0x20844
    function_17fd8(v2, &v1, 32);
    int32_t v3 = function_4e744(&v1); // 0x20858
    return function_4efd4(v2, "sn", v3);
}

// Address range: 0x20872 - 0x20874
int32_t function_20872(void) {
    // 0x20872
    int32_t result; // 0x20872
    return result;
}

// Address range: 0x20874 - 0x2087c
int32_t function_20874(int32_t a1, int32_t a2) {
    // 0x20874
    int32_t result; // 0x20874
    return result;
}

// Address range: 0x20880 - 0x208cc
int32_t function_20880(int32_t a1, int32_t a2) {
    int32_t v1 = 0; // bp-20, 0x20898
    function_18654(a2, 2, &v1);
    return function_4efd4(a1, "eeprom_vol", function_4e990(v1, 0));
}

// Address range: 0x208cc - 0x20918
int32_t function_208cc(int32_t a1, int32_t a2) {
    int32_t v1 = 0; // bp-20, 0x208e4
    function_183fc(a2, 2, (int32_t)&v1);
    return function_4efd4(a1, "eeprom_freq", function_4e990(v1, 0));
}

// Address range: 0x20918 - 0x20919
int32_t function_20918(void) {
    // 0x20918
    int32_t result; // 0x20918
    return result;
}

// Address range: 0x2091c - 0x20920
int32_t function_2091c(void) {
    // 0x2091c
    int32_t result; // 0x2091c
    bool v1; // 0x2091c
    if (v1) {
        result = function_20938();
    }
    // 0x2091e
    return result;
}

// Address range: 0x20920 - 0x20924
int32_t function_20920(int32_t a1) {
    // 0x20920
    return a1 + 8;
}

// Address range: 0x20926 - 0x20928
int32_t function_20926(void) {
    // 0x20926
    int32_t result; // 0x20926
    return result;
}

// Address range: 0x20928 - 0x2092c
int32_t function_20928(int32_t a1) {
    // 0x20928
    *(int32_t *)(2 * a1) = a1;
    return function_20c6e();
}

// Address range: 0x2092c - 0x20930
int32_t function_2092c(int32_t a1) {
    // 0x2092c
    int32_t v1; // 0x2092c
    return function_20c72(a1, a1, v1);
}

// Address range: 0x20930 - 0x20934
int32_t function_20930(int32_t a1) {
    // 0x20930
    return function_2037c();
}

// Address range: 0x20934 - 0x20938
int32_t function_20934(int32_t a1) {
    // 0x20934
    return function_20c7a();
}

// Address range: 0x20938 - 0x2093a
int32_t function_20938(void) {
    // 0x20938
    __asm_udf(111);
    int32_t result; // 0x20938
    return result;
}

// Address range: 0x2093a - 0x209c6
int32_t function_2093a(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9) {
    // 0x2093a
    bool v1; // 0x2093a
    bool v2 = v1;
    int32_t v3; // 0x2093a
    int32_t v4 = v3;
    int32_t v5; // 0x2093a
    if (!v2) {
        *(int32_t *)(v3 + 4) = 0x20940;
        v5 = v3 - 0x20940;
    }
    // 0x20946
    bool v6; // 0x2093a
    bool v7; // 0x2093a
    bool v8; // 0x2093a
    int32_t v9; // 0x2093a
    if (((v2 ? 1024 : 4) & a1) != 0 == !v2) {
        int32_t v10 = 32 * v4 ^ a1; // 0x2095e
        v7 = v10 == 0;
        v9 = a1;
        v6 = false;
        v8 = v10 == 0;
        if (v10 < 0) {
            goto lab_dec_label_pc_unknown_6;
        } else {
            goto lab_dec_label_pc_unknown_7;
        }
    } else {
        v9 = a1;
        v6 = false;
        if (v1) {
            goto lab_dec_label_pc_unknown_6;
        } else {
            goto lab_dec_label_pc_unknown_7;
        }
    }
  lab_dec_label_pc_unknown_6:
    v9 = a1 - v4;
    v6 = true;
    v8 = v7;
    goto lab_dec_label_pc_unknown_7;
  lab_dec_label_pc_unknown_7:;
    uint32_t result = v9;
    bool v11; // 0x2093a
    if (v8 || v6 != v1) {
        // .thread17
        v11 = false;
        if ((result / 8 & result) == 0) {
            goto lab__thread24;
        } else {
            goto lab_dec_label_pc_unknown_8;
        }
    } else {
        goto lab_dec_label_pc_unknown_8;
    }
  lab_dec_label_pc_unknown_8:;
    bool v12 = false; // 0x20976
    bool v13 = v11; // 0x20976
    bool v14; // 0x2093a
    bool v15; // 0x2093a
    int32_t v16; // 0x2093a
    if ((result & 4) == 0) {
        goto lab__thread30_thread;
    } else {
        int32_t v17 = result / 8 & result; // 0x20976
        if (v17 == 0) {
            goto lab__thread24;
        } else {
            v12 = false;
            v13 = false;
            v14 = false;
            v15 = false;
            v16 = v17;
            if ((result & 4) == 0) {
                goto lab__thread30_thread;
            } else {
                goto lab__thread48;
            }
        }
    }
  lab__thread24:;
    bool v18; // 0x2093a
    bool v19; // 0x2093a
    int32_t v20; // 0x2093a
    if ((result & 64) == 0) {
        // .thread30
        v12 = true;
        v13 = false;
        v20 = result / 8 & result;
        v19 = true;
        v18 = false;
        if ((result & 4) == 0) {
            goto lab__thread30_thread;
        } else {
            goto lab__thread48_thread67;
        }
    } else {
        // .thread48.thread
        v20 = result / 128 & a4;
        v19 = true;
        v18 = false;
        goto lab__thread48_thread67;
    }
  lab__thread30_thread:
    // .thread30.thread
    v14 = v13;
    v15 = v12;
    v16 = result / 128 & v5;
    if ((result & 64) == 0) {
        v14 = v13;
        v15 = v12;
        v16 = ((v4 & 0x200000) == 0 ? v3 : result) & 2048 * v4;
    }
    goto lab__thread48;
  lab__thread48:
    // .thread48
    v20 = v16;
    v19 = v15;
    v18 = v14;
    if (!v15 && v14 == v1) {
        // .thread
        *(int32_t *)(0x400000 * result + v3) = v16;
        // .thread77
        return result;
    }
    goto lab__thread48_thread67;
  lab__thread48_thread67:
    // .thread48.thread67
    __asm_cdple(5, 7, 14, 1, 13, 4);
    if (v18 == v1) {
        if (v19) {
            // .thread77
            return result;
        }
        // .thread
        *(int32_t *)(0x400000 * result + v3) = v20;
        // .thread77
        return result;
    }
    uint32_t v21 = result / 8;
    *(char *)(v21 + v3) = (char)v20;
    int32_t v22 = result + v3; // 0x2099a
    int32_t v23; // 0x2093a
    if (v19) {
        // .thread51
        v23 = result / 64 & v5;
    } else {
        *(int32_t *)(0x400000 * result + v22) = v20;
        v23 = v21 & v3;
    }
    *(int32_t *)(v3 + 12) = v22;
    int32_t v24; // bp-133532, 0x2093a
    *(int32_t *)(v3 + 16) = (int32_t)&v24;
    *(int32_t *)(v3 + 20) = v23;
    *(int32_t *)(v3 + 24) = 0x209b4;
    // .thread77
    return result;
}

// Address range: 0x20964 - 0x20965
int32_t function_20964(void) {
    // 0x20964
    int32_t result; // 0x20964
    return result;
}

// Address range: 0x209bc - 0x209bd
int32_t function_209bc(void) {
    // 0x209bc
    int32_t result; // 0x209bc
    return result;
}

// Address range: 0x209c6 - 0x209c8
int32_t function_209c6(void) {
    // 0x209c6
    int32_t result; // 0x209c6
    return result;
}

// Address range: 0x209c8 - 0x209cc
int32_t function_209c8(int32_t result) {
    // 0x209c8
    return result;
}

// Address range: 0x209cc - 0x209d0
int32_t function_209cc(int32_t a1) {
    // 0x209cc
    *(int32_t *)(2 * a1) = a1;
    return function_20d12();
}

// Address range: 0x209d0 - 0x209d4
int32_t function_209d0(int32_t a1) {
    // 0x209d0
    return function_20d16();
}

// Address range: 0x209d4 - 0x20a08
int32_t function_209d4(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x209d4
    function_18258(a1, a4 - 4);
    int32_t v1; // 0x209d4
    return function_4efd4(v1, "eeprom_code", function_4e990(a5, v1));
}

// Address range: 0x20a08 - 0x20a20
int32_t function_20a08(int32_t result) {
    // 0x20a08
    g342 = __asm_bfi((int32_t)(unsigned char)g342, result, 0, 1);
    return result;
}

// Address range: 0x20a20 - 0x20a38
int32_t function_20a20(int32_t result) {
    // 0x20a20
    g342 = __asm_bfi((int32_t)(unsigned char)g342, result, 1, 1);
    return result;
}

// Address range: 0x20a38 - 0x20a50
int32_t function_20a38(int32_t result) {
    // 0x20a38
    g342 = __asm_bfi((int32_t)(unsigned char)g342, result, 2, 1);
    return result;
}

// Address range: 0x20a50 - 0x20a88
int32_t function_20a50(int32_t a1) {
    char * v1 = g289; // 0x20a68
    int32_t result = a1; // 0x20a7c
    if (v1 == (char *)4 || v1 < (char *)4) {
        result = function_20aa8();
    }
    // 0x20a80
    return result;
}

// Address range: 0x20a8a - 0x20a8c
int32_t function_20a8a(void) {
    // 0x20a8a
    int32_t result; // 0x20a8a
    return result;
}

// Address range: 0x20a8c - 0x20aa8
int32_t function_20a8c(void) {
    // 0x20a8c
    int32_t str; // 0x20a8c
    int32_t size; // 0x20a8c
    snprintf((char *)&str, size, (char *)size);
    return function_2e584(4, &str, 0);
}

// Address range: 0x20aa8 - 0x20ac0
int32_t function_20aa8(void) {
    // 0x20aa8
    int32_t v1; // 0x20aa8
    int32_t v2 = v1;
    return function_4e990(v2, v2 >> 31);
}

// Address range: 0x20ac2 - 0x20ac4
int32_t function_20ac2(void) {
    // 0x20ac2
    int32_t result; // 0x20ac2
    return result;
}

// Address range: 0x20ac4 - 0x20ad4
int32_t function_20ac4(int32_t a1, int32_t a2) {
    // 0x20ac4
    int32_t v1; // 0x20ac4
    return function_4efd4(v1, (char *)v1, v1);
}

// Address range: 0x20ad4 - 0x20b44
int32_t function_20ad4(int32_t a1) {
    if (a1 == 0) {
        // 0x20b0c
        return 0;
    }
    int32_t v1 = function_4e744((int32_t *)&g415); // 0x20aec
    return function_4efd4(a1, "miner_version", v1);
}

// Address range: 0x20b46 - 0x20b4c
int32_t function_20b46(void) {
    // 0x20b46
    int32_t result; // 0x20b46
    return result;
}

// Address range: 0x20b4c - 0x20b78
int32_t function_20b4c(int32_t a1, int32_t a2, uint32_t a3, int32_t a4) {
    // 0x20b4c
    int32_t str; // 0x20b4c
    snprintf((char *)&str, 2048, (char *)(a3 % 0x10000 | 0x60000));
    return function_2e584(3, &str, 0);
}

// Address range: 0x20b7c - 0x20b90
int32_t function_20b7c(int32_t a1) {
    int32_t result = a1; // 0x20b88
    if (a1 == 0) {
        result = function_20bb8();
    }
    // 0x20b8c
    return result;
}

// Address range: 0x20b92 - 0x20b94
int32_t function_20b92(void) {
    // 0x20b92
    int32_t result; // 0x20b92
    return result;
}

// Address range: 0x20b94 - 0x20bb0
int32_t function_20b94(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x20b94
    __asm_vldr(a4);
    int32_t v1; // 0x20b94
    return function_4efd4(v1, "total_hash", function_4ea14());
}

// Address range: 0x20bb0 - 0x20bb8
int32_t function_20bb0(int32_t a1) {
    // 0x20bb0
    int32_t result; // 0x20bb0
    return result;
}

// Address range: 0x20bb8 - 0x20c14
int32_t function_20bb8(void) {
    // 0x20bb8
    if ((*(char *)&g60 | *(char *)&g221) == 0 == g290 < 3) {
        function_20bb0((int32_t)&g488);
    }
    // 0x20bf4
    int32_t str; // 0x20bb8
    return snprintf((char *)&str, 2048, "%s: input bad json param\n", "api_total_hash");
}

// Address range: 0x20c16 - 0x20c18
int32_t function_20c16(void) {
    // 0x20c16
    int32_t result; // 0x20c16
    return result;
}

// Address range: 0x20c18 - 0x20c24
int32_t function_20c18(int32_t a1) {
    // 0x20c18
    int32_t v1; // 0x20c18
    return function_2e584(v1, (int32_t *)v1, v1);
}

// Address range: 0x20c28 - 0x20c58
int32_t function_20c28(int32_t a1) {
    if (a1 == 0) {
        function_20c60();
    }
    int32_t v1 = function_4e744((int32_t *)&g450); // 0x20c40
    return function_4efd4(a1, "miner_id", v1);
}

// Address range: 0x20c58 - 0x20c5a
int32_t function_20c58(void) {
    // 0x20c58
    int32_t result; // 0x20c58
    return result;
}

// Address range: 0x20c5a - 0x20c5c
int32_t function_20c5a(void) {
    // 0x20c5a
    int32_t result; // 0x20c5a
    return result;
}

// Address range: 0x20c5c - 0x20c60
int32_t function_20c5c(int32_t a1) {
    // 0x20c5c
    int32_t result; // 0x20c5c
    return result;
}

// Address range: 0x20c60 - 0x20c6c
int32_t function_20c60(void) {
    // 0x20c60
    int32_t result; // 0x20c60
    return result;
}

// Address range: 0x20c6e - 0x20c70
int32_t function_20c6e(void) {
    // 0x20c6e
    int32_t result; // 0x20c6e
    return result;
}

// Address range: 0x20c72 - 0x20c78
int32_t function_20c72(int32_t a1, int32_t a2, int32_t a3) {
    // 0x20c72
    return 0;
}

// Address range: 0x20c7a - 0x20c7c
int32_t function_20c7a(void) {
    // 0x20c7a
    int32_t result; // 0x20c7a
    return result;
}

// Address range: 0x20c7c - 0x20c80
int32_t function_20c7c(int32_t result) {
    // 0x20c7c
    return result;
}

// Address range: 0x20c80 - 0x20c84
int32_t function_20c80(int32_t result) {
    // 0x20c80
    return result;
}

// Address range: 0x20c84 - 0x20c8c
int32_t function_20c84(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x20c84
    return 0;
}

// Address range: 0x20c8c - 0x20c90
int32_t function_20c8c(int32_t a1) {
    // 0x20c8c
    return a1 + 7;
}

// Address range: 0x20c90 - 0x20c94
int32_t function_20c90(int32_t result) {
    // 0x20c90
    return result;
}

// Address range: 0x20c94 - 0x20c98
int32_t function_20c94(int32_t result) {
    // 0x20c94
    return result;
}

// Address range: 0x20c98 - 0x20ca0
int32_t function_20c98(void) {
    // 0x20c98
    int32_t result; // 0x20c98
    bool v1; // 0x20c98
    if (v1 || false) {
        result = function_20c58();
    }
    // 0x20c9c
    return result;
}

// Address range: 0x20ca2 - 0x20ca4
int32_t function_20ca2(int32_t a1) {
    // 0x20ca2
    return function_207e4(a1);
}

// Address range: 0x20ca4 - 0x20cc0
int32_t function_20ca4(int32_t a1, int32_t a2, uint32_t a3) {
    // 0x20ca4
    int32_t str; // 0x20ca4
    snprintf((char *)&str, 2048, (char *)(a3 % 0x10000 | 0x60000));
    return 3;
}

// Address range: 0x20cc2 - 0x20cc8
int32_t function_20cc2(int32_t result, int32_t a2, int32_t a3) {
    // 0x20cc2
    return result;
}

// Address range: 0x20cc8 - 0x20ccc
int32_t function_20cc8(int32_t a1) {
    // 0x20cc8
    int32_t result; // 0x20cc8
    return result;
}

// Address range: 0x20cd2 - 0x20cd4
int32_t function_20cd2(void) {
    // 0x20cd2
    int32_t result; // 0x20cd2
    return result;
}

// Address range: 0x20cd4 - 0x20cd8
int32_t function_20cd4(int32_t result) {
    // 0x20cd4
    return result;
}

// Address range: 0x20cd8 - 0x20cdc
int32_t function_20cd8(void) {
    // 0x20cd8
    int32_t result; // 0x20cd8
    return result;
}

// Address range: 0x20cdc - 0x20ce0
int32_t function_20cdc(int32_t a1, int32_t a2, int32_t result) {
    // 0x20cdc
    return result;
}

// Address range: 0x20ce0 - 0x20ce4
int32_t function_20ce0(void) {
    // 0x20ce0
    int32_t result; // 0x20ce0
    return result;
}

// Address range: 0x20ce4 - 0x20ce8
int32_t function_20ce4(void) {
    // 0x20ce4
    int32_t result; // 0x20ce4
    return result;
}

// Address range: 0x20ce8 - 0x20cec
int32_t function_20ce8(void) {
    // 0x20ce8
    int32_t result; // 0x20ce8
    return result;
}

// Address range: 0x20cec - 0x20cee
int32_t function_20cec(void) {
    // 0x20cec
    return function_20cf8();
}

// Address range: 0x20cee - 0x20cf0
int32_t function_20cee(void) {
    // 0x20cee
    int32_t result; // 0x20cee
    return result;
}

// Address range: 0x20cf0 - 0x20cf4
int32_t function_20cf0(int32_t a1) {
    // 0x20cf0
    int32_t result; // 0x20cf0
    return result;
}

// Address range: 0x20cf4 - 0x20cf6
int32_t function_20cf4(void) {
    // 0x20cf4
    int32_t result; // 0x20cf4
    return result;
}

// Address range: 0x20cf6 - 0x20cf8
int32_t function_20cf6(void) {
    // 0x20cf6
    int32_t result; // 0x20cf6
    return result;
}

// Address range: 0x20cf8 - 0x20cfa
int32_t function_20cf8(void) {
    // 0x20cf8
    int32_t result; // 0x20cf8
    return result;
}

// Address range: 0x20cfa - 0x20cfc
int32_t function_20cfa(void) {
    // 0x20cfa
    int32_t result; // 0x20cfa
    return result;
}

// Address range: 0x20cfc - 0x20d00
int32_t function_20cfc(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x20cfc
    *(int32_t *)a1 = a4;
    return a1 + 4;
}

// Address range: 0x20d00 - 0x20d04
int32_t function_20d00(int32_t a1) {
    // 0x20d00
    return a1 + 12;
}

// Address range: 0x20d04 - 0x20d08
int32_t function_20d04(int32_t result, int32_t a2) {
    // 0x20d04
    return result;
}

// Address range: 0x20d08 - 0x20d0c
int32_t function_20d08(void) {
    // 0x20d08
    int32_t result; // 0x20d08
    return result;
}

// Address range: 0x20d0c - 0x20d10
int32_t function_20d0c(void) {
    // 0x20d0c
    return 16;
}

// Address range: 0x20d12 - 0x20d14
int32_t function_20d12(void) {
    // 0x20d12
    int32_t result; // 0x20d12
    return result;
}

// Address range: 0x20d16 - 0x20d18
int32_t function_20d16(void) {
    // 0x20d16
    int32_t result; // 0x20d16
    return result;
}

// Address range: 0x20d18 - 0x20d1c
int32_t function_20d18(int32_t result) {
    // 0x20d18
    return result;
}

// Address range: 0x20d1c - 0x20d20
int32_t function_20d1c(int32_t a1) {
    // 0x20d1c
    return a1 + 20;
}

// Address range: 0x20d22 - 0x20d24
int32_t function_20d22(void) {
    // 0x20d22
    int32_t result; // 0x20d22
    return result;
}

// Address range: 0x20d24 - 0x20d44
int32_t function_20d24(int32_t result, int32_t a2, int32_t a3) {
    // 0x20d24
    *(int32_t *)(result + 32) = a2;
    *(int32_t *)(result + 36) = a3;
    *(int32_t *)result = 0;
    *(int32_t *)(result + 4) = 0;
    return result;
}

// Address range: 0x20d44 - 0x231a4
int32_t function_20d44(int32_t a1, int32_t a2) {
    int32_t * v1 = (int32_t *)(a1 + 8); // 0x20d4c
    uint32_t v2 = *v1; // 0x20d4c
    int32_t * v3 = (int32_t *)(a1 + 24); // 0x20d5c
    uint32_t v4 = *v3; // 0x20d5c
    int32_t * v5 = (int32_t *)(a1 + 32); // 0x20d64
    int32_t v6 = *v5; // 0x20d64
    int32_t * v7 = (int32_t *)(a1 + 28); // 0x20d6c
    int32_t v8 = *v7; // 0x20d6c
    int32_t * v9 = (int32_t *)(a1 + 36); // 0x20d74
    int32_t v10 = *v9; // 0x20d74
    int32_t * v11 = (int32_t *)(a1 + 12); // 0x20d78
    int32_t v12 = *v11; // 0x20d78
    int32_t * v13 = (int32_t *)(a1 + 16); // 0x20d80
    int32_t v14 = *v13; // 0x20d80
    int32_t * v15 = (int32_t *)(a1 + 20); // 0x20d90
    int32_t v16 = *v15; // 0x20d90
    int32_t v17 = llvm_bswap_i32(v6); // 0x20de8
    int32_t v18 = v17 + 0x428a2f98 + v10 + ((v4 / 2048 | 0x200000 * v4) ^ (v4 / 64 | 0x4000000 * v4) ^ (v4 / 0x2000000 | 128 * v4)) + ((v8 ^ v6) & v4 ^ v6); // 0x20df0
    uint32_t v19 = v18 + v16; // 0x20df8
    uint32_t v20 = v18 + ((v2 / 0x2000 | 0x80000 * v2) ^ (v2 / 4 | 0x40000000 * v2) ^ (v2 / 0x400000 | 1024 * v2)) + ((v12 | v2) & v14 | v12 & v2); // 0x20dfc
    uint32_t v21 = llvm_bswap_i32(*(int32_t *)(a2 + 4)); // 0x20e00
    int32_t v22 = v6 + 0x71374491 + v21 + (v19 & (v8 ^ v4) ^ v8) + ((v19 / 2048 | 0x200000 * v19) ^ (v19 / 64 | 0x4000000 * v19) ^ (v19 / 0x2000000 | 128 * v19)); // 0x20e58
    uint32_t v23 = v22 + ((v20 | v2) & v12 | v20 & v2) + ((v20 / 0x2000 | 0x80000 * v20) ^ (v20 / 4 | 0x40000000 * v20) ^ (v20 / 0x400000 | 1024 * v20)); // 0x20e70
    uint32_t v24 = v22 + v14; // 0x20e78
    uint32_t v25 = llvm_bswap_i32(*(int32_t *)(a2 + 8)); // 0x20ebc
    int32_t v26 = v8 - 0x4a3f0431 + v25 + (v24 & (v19 ^ v4) ^ v4) + ((v24 / 2048 | 0x200000 * v24) ^ (v24 / 64 | 0x4000000 * v24) ^ (v24 / 0x2000000 | 128 * v24)); // 0x20f00
    uint32_t v27 = v26 + ((v23 | v20) & v2 | v23 & v20) + ((v23 / 0x2000 | 0x80000 * v23) ^ (v23 / 4 | 0x40000000 * v23) ^ (v23 / 0x400000 | 1024 * v23)); // 0x20f0c
    uint32_t v28 = v26 + v12; // 0x20f1c
    uint32_t v29 = llvm_bswap_i32(*(int32_t *)(a2 + 12)); // 0x20f3c
    int32_t v30 = v4 - 0x164a245b + v29 + (v28 & (v24 ^ v19) ^ v19) + ((v28 / 2048 | 0x200000 * v28) ^ (v28 / 64 | 0x4000000 * v28) ^ (v28 / 0x2000000 | 128 * v28)); // 0x20f88
    uint32_t v31 = v30 + ((v27 | v23) & v20 | v27 & v23) + ((v27 / 0x2000 | 0x80000 * v27) ^ (v27 / 4 | 0x40000000 * v27) ^ (v27 / 0x400000 | 1024 * v27)); // 0x20f90
    uint32_t v32 = v30 + v2; // 0x20f94
    uint32_t v33 = llvm_bswap_i32(*(int32_t *)(a2 + 16)); // 0x20fd0
    int32_t v34 = v19 + 0x3956c25b + v33 + (v32 & (v28 ^ v24) ^ v24) + ((v32 / 2048 | 0x200000 * v32) ^ (v32 / 64 | 0x4000000 * v32) ^ (v32 / 0x2000000 | 128 * v32)); // 0x21000
    uint32_t v35 = v34 + v20; // 0x21008
    uint32_t v36 = v34 + ((v31 | v27) & v23 | v31 & v27) + ((v31 / 0x2000 | 0x80000 * v31) ^ (v31 / 4 | 0x40000000 * v31) ^ (v31 / 0x400000 | 1024 * v31)); // 0x21030
    uint32_t v37 = llvm_bswap_i32(*(int32_t *)(a2 + 20)); // 0x2103c
    int32_t v38 = v37 + 0x59f111f1 + v24 + (v35 & (v32 ^ v28) ^ v28) + ((v35 / 2048 | 0x200000 * v35) ^ (v35 / 64 | 0x4000000 * v35) ^ (v35 / 0x2000000 | 128 * v35)); // 0x21088
    uint32_t v39 = v38 + v23; // 0x21098
    uint32_t v40 = v38 + ((v36 | v31) & v27 | v36 & v31) + ((v36 / 0x2000 | 0x80000 * v36) ^ (v36 / 4 | 0x40000000 * v36) ^ (v36 / 0x400000 | 1024 * v36)); // 0x210a0
    uint32_t v41 = llvm_bswap_i32(*(int32_t *)(a2 + 24)); // 0x210ac
    int32_t v42 = v41 - 0x6dc07d5c + v28 + (v39 & (v35 ^ v32) ^ v32) + ((v39 / 2048 | 0x200000 * v39) ^ (v39 / 64 | 0x4000000 * v39) ^ (v39 / 0x2000000 | 128 * v39)); // 0x210ec
    uint32_t v43 = v42 + ((v40 | v36) & v31 | v40 & v36) + ((v40 / 0x2000 | 0x80000 * v40) ^ (v40 / 4 | 0x40000000 * v40) ^ (v40 / 0x400000 | 1024 * v40)); // 0x2110c
    uint32_t v44 = v42 + v27; // 0x21110
    uint32_t v45 = llvm_bswap_i32(*(int32_t *)(a2 + 28)); // 0x2111c
    int32_t v46 = v45 - 0x54e3a12b + v32 + (v44 & (v39 ^ v35) ^ v35) + ((v44 / 2048 | 0x200000 * v44) ^ (v44 / 64 | 0x4000000 * v44) ^ (v44 / 0x2000000 | 128 * v44)); // 0x2116c
    uint32_t v47 = v46 + v31; // 0x21170
    uint32_t v48 = llvm_bswap_i32(*(int32_t *)(a2 + 32)); // 0x21174
    uint32_t v49 = llvm_bswap_i32(*(int32_t *)(a2 + 36)); // 0x2118c
    uint32_t v50 = v46 + ((v43 | v40) & v36 | v43 & v40) + ((v43 / 0x2000 | 0x80000 * v43) ^ (v43 / 4 | 0x40000000 * v43) ^ (v43 / 0x400000 | 1024 * v43)); // 0x211ac
    uint32_t v51 = llvm_bswap_i32(*(int32_t *)(a2 + 40)); // 0x211b8
    uint32_t v52 = llvm_bswap_i32(*(int32_t *)(a2 + 44)); // 0x211e4
    int32_t v53 = v48 - 0x27f85568 + v35 + (v47 & (v44 ^ v39) ^ v39) + ((v47 / 2048 | 0x200000 * v47) ^ (v47 / 64 | 0x4000000 * v47) ^ (v47 / 0x2000000 | 128 * v47)); // 0x211fc
    uint32_t v54 = v53 + v36; // 0x21204
    uint32_t v55 = llvm_bswap_i32(*(int32_t *)(a2 + 48)); // 0x21208
    uint32_t v56 = v53 + ((v50 | v43) & v40 | v50 & v43) + ((v50 / 0x2000 | 0x80000 * v50) ^ (v50 / 4 | 0x40000000 * v50) ^ (v50 / 0x400000 | 1024 * v50)); // 0x21224
    int32_t v57 = v49 + 0x12835b01 + v39 + (v54 & (v47 ^ v44) ^ v44) + ((v54 / 2048 | 0x200000 * v54) ^ (v54 / 64 | 0x4000000 * v54) ^ (v54 / 0x2000000 | 128 * v54)); // 0x21254
    uint32_t v58 = llvm_bswap_i32(*(int32_t *)(a2 + 52)); // 0x21258
    uint32_t v59 = v57 + v40; // 0x21260
    uint32_t v60 = llvm_bswap_i32(*(int32_t *)(a2 + 56)); // 0x21284
    uint32_t v61 = v57 + ((v56 | v50) & v43 | v56 & v50) + ((v56 / 0x2000 | 0x80000 * v56) ^ (v56 / 4 | 0x40000000 * v56) ^ (v56 / 0x400000 | 1024 * v56)); // 0x21288
    uint32_t v62 = llvm_bswap_i32(*(int32_t *)(a2 + 60)); // 0x212c8
    int32_t v63 = v51 + 0x243185be + v44 + (v59 & (v54 ^ v47) ^ v47) + ((v59 / 2048 | 0x200000 * v59) ^ (v59 / 64 | 0x4000000 * v59) ^ (v59 / 0x2000000 | 128 * v59)); // 0x212cc
    uint32_t v64 = v63 + v43; // 0x212dc
    uint32_t v65 = v63 + ((v61 | v56) & v50 | v61 & v56) + ((v61 / 0x2000 | 0x80000 * v61) ^ (v61 / 4 | 0x40000000 * v61) ^ (v61 / 0x400000 | 1024 * v61)); // 0x21300
    int32_t v66 = v52 + 0x550c7dc3 + v47 + (v64 & (v59 ^ v54) ^ v54) + ((v64 / 2048 | 0x200000 * v64) ^ (v64 / 64 | 0x4000000 * v64) ^ (v64 / 0x2000000 | 128 * v64)); // 0x2135c
    uint32_t v67 = v66 + ((v65 | v61) & v56 | v65 & v61) + ((v65 / 0x2000 | 0x80000 * v65) ^ (v65 / 4 | 0x40000000 * v65) ^ (v65 / 0x400000 | 1024 * v65)); // 0x21368
    uint32_t v68 = v66 + v50; // 0x2136c
    int32_t v69 = v55 + 0x72be5d74 + v54 + (v68 & (v64 ^ v59) ^ v59) + ((v68 / 2048 | 0x200000 * v68) ^ (v68 / 64 | 0x4000000 * v68) ^ (v68 / 0x2000000 | 128 * v68)); // 0x213b8
    uint32_t v70 = v69 + ((v67 | v65) & v61 | v67 & v65) + ((v67 / 0x2000 | 0x80000 * v67) ^ (v67 / 4 | 0x40000000 * v67) ^ (v67 / 0x400000 | 1024 * v67)); // 0x213c4
    uint32_t v71 = v69 + v56; // 0x213c8
    int32_t v72 = v58 - 0x7f214e02 + v59 + (v71 & (v68 ^ v64) ^ v64) + ((v71 / 2048 | 0x200000 * v71) ^ (v71 / 64 | 0x4000000 * v71) ^ (v71 / 0x2000000 | 128 * v71)); // 0x21418
    uint32_t v73 = v72 + v61; // 0x21420
    uint32_t v74 = v72 + ((v70 | v67) & v65 | v70 & v67) + ((v70 / 0x2000 | 0x80000 * v70) ^ (v70 / 4 | 0x40000000 * v70) ^ (v70 / 0x400000 | 1024 * v70)); // 0x21424
    int32_t v75 = v60 - 0x6423f959 + v64 + (v73 & (v71 ^ v68) ^ v68) + ((v73 / 2048 | 0x200000 * v73) ^ (v73 / 64 | 0x4000000 * v73) ^ (v73 / 0x2000000 | 128 * v73)); // 0x21470
    uint32_t v76 = v75 + ((v74 | v70) & v67 | v74 & v70) + ((v74 / 0x2000 | 0x80000 * v74) ^ (v74 / 4 | 0x40000000 * v74) ^ (v74 / 0x400000 | 1024 * v74)); // 0x21478
    uint32_t v77 = v75 + v65; // 0x21480
    int32_t v78 = v62 - 0x3e640e8c + v68 + (v77 & (v73 ^ v71) ^ v71) + ((v77 / 2048 | 0x200000 * v77) ^ (v77 / 64 | 0x4000000 * v77) ^ (v77 / 0x2000000 | 128 * v77)); // 0x214c8
    uint32_t v79 = v78 + v67; // 0x214e8
    uint32_t v80 = v78 + ((v76 | v74) & v70 | v76 & v74) + ((v76 / 0x2000 | 0x80000 * v76) ^ (v76 / 4 | 0x40000000 * v76) ^ (v76 / 0x400000 | 1024 * v76)); // 0x21504
    uint32_t v81 = ((v21 / 128 | 0x2000000 * v21) ^ v21 / 8 ^ (v21 / 0x40000 | 0x4000 * v21)) + v17 + v49 + ((v60 / 0x20000 | 0x8000 * v60) ^ v60 / 1024 ^ (v60 / 0x80000 | 0x2000 * v60)); // 0x2150c
    int32_t v82 = v81 - 0x1b64963f + v71 + (v79 & (v77 ^ v73) ^ v73) + ((v79 / 2048 | 0x200000 * v79) ^ (v79 / 64 | 0x4000000 * v79) ^ (v79 / 0x2000000 | 128 * v79)); // 0x21544
    uint32_t v83 = v82 + v70; // 0x21578
    uint32_t v84 = v82 + ((v80 | v76) & v74 | v80 & v76) + ((v80 / 0x2000 | 0x80000 * v80) ^ (v80 / 4 | 0x40000000 * v80) ^ (v80 / 0x400000 | 1024 * v80)); // 0x21584
    uint32_t v85 = ((v25 / 128 | 0x2000000 * v25) ^ v25 / 8 ^ (v25 / 0x40000 | 0x4000 * v25)) + v21 + v51 + ((v62 / 0x20000 | 0x8000 * v62) ^ v62 / 1024 ^ (v62 / 0x80000 | 0x2000 * v62)); // 0x21594
    int32_t v86 = v85 - 0x1041b87a + v73 + (v83 & (v79 ^ v77) ^ v77) + ((v83 / 2048 | 0x200000 * v83) ^ (v83 / 64 | 0x4000000 * v83) ^ (v83 / 0x2000000 | 128 * v83)); // 0x215dc
    uint32_t v87 = v86 + v74; // 0x2160c
    uint32_t v88 = v86 + ((v84 | v80) & v76 | v84 & v80) + ((v84 / 0x2000 | 0x80000 * v84) ^ (v84 / 4 | 0x40000000 * v84) ^ (v84 / 0x400000 | 1024 * v84)); // 0x21610
    uint32_t v89 = ((v29 / 128 | 0x2000000 * v29) ^ v29 / 8 ^ (v29 / 0x40000 | 0x4000 * v29)) + v25 + v52 + ((v81 / 0x20000 | 0x8000 * v81) ^ v81 / 1024 ^ (v81 / 0x80000 | 0x2000 * v81)); // 0x2163c
    int32_t v90 = v89 + 0xfc19dc6 + v77 + (v87 & (v83 ^ v79) ^ v79) + ((v87 / 2048 | 0x200000 * v87) ^ (v87 / 64 | 0x4000000 * v87) ^ (v87 / 0x2000000 | 128 * v87)); // 0x21680
    uint32_t v91 = v90 + v76; // 0x216a8
    uint32_t v92 = v90 + ((v88 | v84) & v80 | v88 & v84) + ((v88 / 0x2000 | 0x80000 * v88) ^ (v88 / 4 | 0x40000000 * v88) ^ (v88 / 0x400000 | 1024 * v88)); // 0x216ac
    uint32_t v93 = ((v33 / 128 | 0x2000000 * v33) ^ v33 / 8 ^ (v33 / 0x40000 | 0x4000 * v33)) + v29 + v55 + ((v85 / 0x20000 | 0x8000 * v85) ^ v85 / 1024 ^ (v85 / 0x80000 | 0x2000 * v85)); // 0x216cc
    int32_t v94 = v93 + 0x240ca1cc + v79 + (v91 & (v87 ^ v83) ^ v83) + ((v91 / 2048 | 0x200000 * v91) ^ (v91 / 64 | 0x4000000 * v91) ^ (v91 / 0x2000000 | 128 * v91)); // 0x21714
    uint32_t v95 = v94 + ((v92 | v88) & v84 | v92 & v88) + ((v92 / 0x2000 | 0x80000 * v92) ^ (v92 / 4 | 0x40000000 * v92) ^ (v92 / 0x400000 | 1024 * v92)); // 0x21740
    uint32_t v96 = v94 + v80; // 0x2174c
    uint32_t v97 = ((v37 / 128 | 0x2000000 * v37) ^ v37 / 8 ^ (v37 / 0x40000 | 0x4000 * v37)) + v33 + v58 + ((v89 / 0x20000 | 0x8000 * v89) ^ v89 / 1024 ^ (v89 / 0x80000 | 0x2000 * v89)); // 0x2175c
    int32_t v98 = v97 + 0x2de92c6f + v83 + (v96 & (v91 ^ v87) ^ v87) + ((v96 / 2048 | 0x200000 * v96) ^ (v96 / 64 | 0x4000000 * v96) ^ (v96 / 0x2000000 | 128 * v96)); // 0x217a0
    uint32_t v99 = v98 + v84; // 0x217c0
    uint32_t v100 = v98 + ((v95 | v92) & v88 | v95 & v92) + ((v95 / 0x2000 | 0x80000 * v95) ^ (v95 / 4 | 0x40000000 * v95) ^ (v95 / 0x400000 | 1024 * v95)); // 0x217c8
    uint32_t v101 = ((v41 / 128 | 0x2000000 * v41) ^ v41 / 8 ^ (v41 / 0x40000 | 0x4000 * v41)) + v37 + v60 + ((v93 / 0x20000 | 0x8000 * v93) ^ v93 / 1024 ^ (v93 / 0x80000 | 0x2000 * v93)); // 0x217f0
    int32_t v102 = v101 + 0x4a7484aa + v87 + (v99 & (v96 ^ v91) ^ v91) + ((v99 / 2048 | 0x200000 * v99) ^ (v99 / 64 | 0x4000000 * v99) ^ (v99 / 0x2000000 | 128 * v99)); // 0x21840
    uint32_t v103 = v102 + v88; // 0x21854
    uint32_t v104 = v102 + ((v100 | v95) & v92 | v100 & v95) + ((v100 / 0x2000 | 0x80000 * v100) ^ (v100 / 4 | 0x40000000 * v100) ^ (v100 / 0x400000 | 1024 * v100)); // 0x21868
    uint32_t v105 = ((v45 / 128 | 0x2000000 * v45) ^ v45 / 8 ^ (v45 / 0x40000 | 0x4000 * v45)) + v41 + v62 + ((v97 / 0x20000 | 0x8000 * v97) ^ v97 / 1024 ^ (v97 / 0x80000 | 0x2000 * v97)); // 0x21890
    int32_t v106 = v105 + 0x5cb0a9dc + v91 + (v103 & (v99 ^ v96) ^ v96) + ((v103 / 2048 | 0x200000 * v103) ^ (v103 / 64 | 0x4000000 * v103) ^ (v103 / 0x2000000 | 128 * v103)); // 0x218d8
    uint32_t v107 = v106 + v92; // 0x218e4
    uint32_t v108 = v106 + ((v104 | v100) & v95 | v104 & v100) + ((v104 / 0x2000 | 0x80000 * v104) ^ (v104 / 4 | 0x40000000 * v104) ^ (v104 / 0x400000 | 1024 * v104)); // 0x218fc
    uint32_t v109 = ((v48 / 128 | 0x2000000 * v48) ^ v48 / 8 ^ (v48 / 0x40000 | 0x4000 * v48)) + v45 + v81 + ((v101 / 0x20000 | 0x8000 * v101) ^ v101 / 1024 ^ (v101 / 0x80000 | 0x2000 * v101)); // 0x21930
    int32_t v110 = v109 + 0x76f988da + v96 + (v107 & (v103 ^ v99) ^ v99) + ((v107 / 2048 | 0x200000 * v107) ^ (v107 / 64 | 0x4000000 * v107) ^ (v107 / 0x2000000 | 128 * v107)); // 0x2196c
    uint32_t v111 = v110 + v95; // 0x21994
    uint32_t v112 = v110 + ((v108 | v104) & v100 | v108 & v104) + ((v108 / 0x2000 | 0x80000 * v108) ^ (v108 / 4 | 0x40000000 * v108) ^ (v108 / 0x400000 | 1024 * v108)); // 0x2199c
    uint32_t v113 = ((v49 / 128 | 0x2000000 * v49) ^ v49 / 8 ^ (v49 / 0x40000 | 0x4000 * v49)) + v48 + v85 + ((v105 / 0x20000 | 0x8000 * v105) ^ v105 / 1024 ^ (v105 / 0x80000 | 0x2000 * v105)); // 0x219b8
    int32_t v114 = v113 - 0x67c1aeae + v99 + (v111 & (v107 ^ v103) ^ v103) + ((v111 / 2048 | 0x200000 * v111) ^ (v111 / 64 | 0x4000000 * v111) ^ (v111 / 0x2000000 | 128 * v111)); // 0x21a04
    uint32_t v115 = v114 + v100; // 0x21a10
    uint32_t v116 = v114 + ((v112 | v108) & v104 | v112 & v108) + ((v112 / 0x2000 | 0x80000 * v112) ^ (v112 / 4 | 0x40000000 * v112) ^ (v112 / 0x400000 | 1024 * v112)); // 0x21a20
    uint32_t v117 = ((v51 / 128 | 0x2000000 * v51) ^ v51 / 8 ^ (v51 / 0x40000 | 0x4000 * v51)) + v49 + v89 + ((v109 / 0x20000 | 0x8000 * v109) ^ v109 / 1024 ^ (v109 / 0x80000 | 0x2000 * v109)); // 0x21a54
    int32_t v118 = v117 - 0x57ce3993 + v103 + (v115 & (v111 ^ v107) ^ v107) + ((v115 / 2048 | 0x200000 * v115) ^ (v115 / 64 | 0x4000000 * v115) ^ (v115 / 0x2000000 | 128 * v115)); // 0x21aa4
    uint32_t v119 = v118 + ((v116 | v112) & v108 | v116 & v112) + ((v116 / 0x2000 | 0x80000 * v116) ^ (v116 / 4 | 0x40000000 * v116) ^ (v116 / 0x400000 | 1024 * v116)); // 0x21ac0
    uint32_t v120 = v118 + v104; // 0x21ac8
    uint32_t v121 = ((v52 / 128 | 0x2000000 * v52) ^ v52 / 8 ^ (v52 / 0x40000 | 0x4000 * v52)) + v51 + v93 + ((v113 / 0x20000 | 0x8000 * v113) ^ v113 / 1024 ^ (v113 / 0x80000 | 0x2000 * v113)); // 0x21aec
    int32_t v122 = v121 - 0x4ffcd838 + v107 + (v120 & (v115 ^ v111) ^ v111) + ((v120 / 2048 | 0x200000 * v120) ^ (v120 / 64 | 0x4000000 * v120) ^ (v120 / 0x2000000 | 128 * v120)); // 0x21b38
    uint32_t v123 = v122 + v108; // 0x21b54
    uint32_t v124 = v122 + ((v119 | v116) & v112 | v119 & v116) + ((v119 / 0x2000 | 0x80000 * v119) ^ (v119 / 4 | 0x40000000 * v119) ^ (v119 / 0x400000 | 1024 * v119)); // 0x21b6c
    uint32_t v125 = ((v55 / 128 | 0x2000000 * v55) ^ v55 / 8 ^ (v55 / 0x40000 | 0x4000 * v55)) + v52 + v97 + ((v117 / 0x20000 | 0x8000 * v117) ^ v117 / 1024 ^ (v117 / 0x80000 | 0x2000 * v117)); // 0x21b7c
    int32_t v126 = v125 - 0x40a68039 + v111 + (v123 & (v120 ^ v115) ^ v115) + ((v123 / 2048 | 0x200000 * v123) ^ (v123 / 64 | 0x4000000 * v123) ^ (v123 / 0x2000000 | 128 * v123)); // 0x21bcc
    uint32_t v127 = v126 + ((v124 | v119) & v116 | v124 & v119) + ((v124 / 0x2000 | 0x80000 * v124) ^ (v124 / 4 | 0x40000000 * v124) ^ (v124 / 0x400000 | 1024 * v124)); // 0x21be8
    uint32_t v128 = v126 + v112; // 0x21bf0
    uint32_t v129 = ((v58 / 128 | 0x2000000 * v58) ^ v58 / 8 ^ (v58 / 0x40000 | 0x4000 * v58)) + v55 + v101 + ((v121 / 0x20000 | 0x8000 * v121) ^ v121 / 1024 ^ (v121 / 0x80000 | 0x2000 * v121)); // 0x21c14
    int32_t v130 = v129 - 0x391ff40d + v115 + (v128 & (v123 ^ v120) ^ v120) + ((v128 / 2048 | 0x200000 * v128) ^ (v128 / 64 | 0x4000000 * v128) ^ (v128 / 0x2000000 | 128 * v128)); // 0x21c5c
    uint32_t v131 = v130 + v116; // 0x21c74
    uint32_t v132 = v130 + ((v127 | v124) & v119 | v127 & v124) + ((v127 / 0x2000 | 0x80000 * v127) ^ (v127 / 4 | 0x40000000 * v127) ^ (v127 / 0x400000 | 1024 * v127)); // 0x21c78
    uint32_t v133 = ((v60 / 128 | 0x2000000 * v60) ^ v60 / 8 ^ (v60 / 0x40000 | 0x4000 * v60)) + v58 + v105 + ((v125 / 0x20000 | 0x8000 * v125) ^ v125 / 1024 ^ (v125 / 0x80000 | 0x2000 * v125)); // 0x21cac
    int32_t v134 = v133 - 0x2a586eb9 + v120 + (v131 & (v128 ^ v123) ^ v123) + ((v131 / 2048 | 0x200000 * v131) ^ (v131 / 64 | 0x4000000 * v131) ^ (v131 / 0x2000000 | 128 * v131)); // 0x21cf8
    uint32_t v135 = v134 + v119; // 0x21d0c
    uint32_t v136 = v134 + ((v132 | v127) & v124 | v132 & v127) + ((v132 / 0x2000 | 0x80000 * v132) ^ (v132 / 4 | 0x40000000 * v132) ^ (v132 / 0x400000 | 1024 * v132)); // 0x21d10
    uint32_t v137 = ((v62 / 128 | 0x2000000 * v62) ^ v62 / 8 ^ (v62 / 0x40000 | 0x4000 * v62)) + v60 + v109 + ((v129 / 0x20000 | 0x8000 * v129) ^ v129 / 1024 ^ (v129 / 0x80000 | 0x2000 * v129)); // 0x21d44
    int32_t v138 = v137 + 0x6ca6351 + v123 + (v135 & (v131 ^ v128) ^ v128) + ((v135 / 2048 | 0x200000 * v135) ^ (v135 / 64 | 0x4000000 * v135) ^ (v135 / 0x2000000 | 128 * v135)); // 0x21d84
    uint32_t v139 = v138 + v124; // 0x21d8c
    uint32_t v140 = v138 + ((v136 | v132) & v127 | v136 & v132) + ((v136 / 0x2000 | 0x80000 * v136) ^ (v136 / 4 | 0x40000000 * v136) ^ (v136 / 0x400000 | 1024 * v136)); // 0x21db0
    uint32_t v141 = ((v81 / 128 | 0x2000000 * v81) ^ v81 / 8 ^ (v81 / 0x40000 | 0x4000 * v81)) + v62 + v113 + ((v133 / 0x20000 | 0x8000 * v133) ^ v133 / 1024 ^ (v133 / 0x80000 | 0x2000 * v133)); // 0x21de8
    int32_t v142 = v141 + 0x14292967 + v128 + (v139 & (v135 ^ v131) ^ v131) + ((v139 / 2048 | 0x200000 * v139) ^ (v139 / 64 | 0x4000000 * v139) ^ (v139 / 0x2000000 | 128 * v139)); // 0x21e18
    uint32_t v143 = v142 + v127; // 0x21e40
    uint32_t v144 = v142 + ((v140 | v136) & v132 | v140 & v136) + ((v140 / 0x2000 | 0x80000 * v140) ^ (v140 / 4 | 0x40000000 * v140) ^ (v140 / 0x400000 | 1024 * v140)); // 0x21e48
    uint32_t v145 = ((v85 / 128 | 0x2000000 * v85) ^ v85 / 8 ^ (v85 / 0x40000 | 0x4000 * v85)) + v81 + v117 + ((v137 / 0x20000 | 0x8000 * v137) ^ v137 / 1024 ^ (v137 / 0x80000 | 0x2000 * v137)); // 0x21e6c
    int32_t v146 = v145 + 0x27b70a85 + v131 + (v143 & (v139 ^ v135) ^ v135) + ((v143 / 2048 | 0x200000 * v143) ^ (v143 / 64 | 0x4000000 * v143) ^ (v143 / 0x2000000 | 128 * v143)); // 0x21eac
    uint32_t v147 = v146 + v132; // 0x21ec8
    uint32_t v148 = v146 + ((v144 | v140) & v136 | v144 & v140) + ((v144 / 0x2000 | 0x80000 * v144) ^ (v144 / 4 | 0x40000000 * v144) ^ (v144 / 0x400000 | 1024 * v144)); // 0x21ee4
    uint32_t v149 = ((v89 / 128 | 0x2000000 * v89) ^ v89 / 8 ^ (v89 / 0x40000 | 0x4000 * v89)) + v85 + v121 + ((v141 / 0x20000 | 0x8000 * v141) ^ v141 / 1024 ^ (v141 / 0x80000 | 0x2000 * v141)); // 0x21efc
    int32_t v150 = v149 + 0x2e1b2138 + v135 + (v147 & (v143 ^ v139) ^ v139) + ((v147 / 2048 | 0x200000 * v147) ^ (v147 / 64 | 0x4000000 * v147) ^ (v147 / 0x2000000 | 128 * v147)); // 0x21f44
    uint32_t v151 = v150 + v136; // 0x21f58
    uint32_t v152 = v150 + ((v148 | v144) & v140 | v148 & v144) + ((v148 / 0x2000 | 0x80000 * v148) ^ (v148 / 4 | 0x40000000 * v148) ^ (v148 / 0x400000 | 1024 * v148)); // 0x21f68
    uint32_t v153 = ((v93 / 128 | 0x2000000 * v93) ^ v93 / 8 ^ (v93 / 0x40000 | 0x4000 * v93)) + v89 + v125 + ((v145 / 0x20000 | 0x8000 * v145) ^ v145 / 1024 ^ (v145 / 0x80000 | 0x2000 * v145)); // 0x21fa4
    int32_t v154 = v153 + 0x4d2c6dfc + v139 + (v151 & (v147 ^ v143) ^ v143) + ((v151 / 2048 | 0x200000 * v151) ^ (v151 / 64 | 0x4000000 * v151) ^ (v151 / 0x2000000 | 128 * v151)); // 0x21fd8
    uint32_t v155 = v154 + v140; // 0x21fe8
    uint32_t v156 = v154 + ((v152 | v148) & v144 | v152 & v148) + ((v152 / 0x2000 | 0x80000 * v152) ^ (v152 / 4 | 0x40000000 * v152) ^ (v152 / 0x400000 | 1024 * v152)); // 0x21ff8
    uint32_t v157 = ((v97 / 128 | 0x2000000 * v97) ^ v97 / 8 ^ (v97 / 0x40000 | 0x4000 * v97)) + v93 + v129 + ((v149 / 0x20000 | 0x8000 * v149) ^ v149 / 1024 ^ (v149 / 0x80000 | 0x2000 * v149)); // 0x22030
    int32_t v158 = v157 + 0x53380d13 + v143 + (v155 & (v151 ^ v147) ^ v147) + ((v155 / 2048 | 0x200000 * v155) ^ (v155 / 64 | 0x4000000 * v155) ^ (v155 / 0x2000000 | 128 * v155)); // 0x2207c
    uint32_t v159 = v158 + v144; // 0x22084
    uint32_t v160 = v158 + ((v156 | v152) & v148 | v156 & v152) + ((v156 / 0x2000 | 0x80000 * v156) ^ (v156 / 4 | 0x40000000 * v156) ^ (v156 / 0x400000 | 1024 * v156)); // 0x22090
    uint32_t v161 = ((v101 / 128 | 0x2000000 * v101) ^ v101 / 8 ^ (v101 / 0x40000 | 0x4000 * v101)) + v97 + v133 + ((v153 / 0x20000 | 0x8000 * v153) ^ v153 / 1024 ^ (v153 / 0x80000 | 0x2000 * v153)); // 0x220bc
    int32_t v162 = v161 + 0x650a7354 + v147 + (v159 & (v155 ^ v151) ^ v151) + ((v159 / 2048 | 0x200000 * v159) ^ (v159 / 64 | 0x4000000 * v159) ^ (v159 / 0x2000000 | 128 * v159)); // 0x22114
    uint32_t v163 = v162 + v148; // 0x2211c
    uint32_t v164 = v162 + ((v160 | v156) & v152 | v160 & v156) + ((v160 / 0x2000 | 0x80000 * v160) ^ (v160 / 4 | 0x40000000 * v160) ^ (v160 / 0x400000 | 1024 * v160)); // 0x22120
    uint32_t v165 = ((v105 / 128 | 0x2000000 * v105) ^ v105 / 8 ^ (v105 / 0x40000 | 0x4000 * v105)) + v101 + v137 + ((v157 / 0x20000 | 0x8000 * v157) ^ v157 / 1024 ^ (v157 / 0x80000 | 0x2000 * v157)); // 0x22150
    int32_t v166 = v165 + 0x766a0abb + v151 + (v163 & (v159 ^ v155) ^ v155) + ((v163 / 2048 | 0x200000 * v163) ^ (v163 / 64 | 0x4000000 * v163) ^ (v163 / 0x2000000 | 128 * v163)); // 0x22198
    uint32_t v167 = v166 + v152; // 0x221ac
    uint32_t v168 = v166 + ((v164 | v160) & v156 | v164 & v160) + ((v164 / 0x2000 | 0x80000 * v164) ^ (v164 / 4 | 0x40000000 * v164) ^ (v164 / 0x400000 | 1024 * v164)); // 0x221b4
    uint32_t v169 = ((v109 / 128 | 0x2000000 * v109) ^ v109 / 8 ^ (v109 / 0x40000 | 0x4000 * v109)) + v105 + v141 + ((v161 / 0x20000 | 0x8000 * v161) ^ v161 / 1024 ^ (v161 / 0x80000 | 0x2000 * v161)); // 0x221f0
    int32_t v170 = v169 - 0x7e3d36d2 + v155 + (v167 & (v163 ^ v159) ^ v159) + ((v167 / 2048 | 0x200000 * v167) ^ (v167 / 64 | 0x4000000 * v167) ^ (v167 / 0x2000000 | 128 * v167)); // 0x22224
    uint32_t v171 = v170 + v156; // 0x2223c
    uint32_t v172 = v170 + ((v168 | v164) & v160 | v168 & v164) + ((v168 / 0x2000 | 0x80000 * v168) ^ (v168 / 4 | 0x40000000 * v168) ^ (v168 / 0x400000 | 1024 * v168)); // 0x22258
    uint32_t v173 = ((v113 / 128 | 0x2000000 * v113) ^ v113 / 8 ^ (v113 / 0x40000 | 0x4000 * v113)) + v109 + v145 + ((v165 / 0x20000 | 0x8000 * v165) ^ v165 / 1024 ^ (v165 / 0x80000 | 0x2000 * v165)); // 0x22278
    int32_t v174 = v173 - 0x6d8dd37b + v159 + (v171 & (v167 ^ v163) ^ v163) + ((v171 / 2048 | 0x200000 * v171) ^ (v171 / 64 | 0x4000000 * v171) ^ (v171 / 0x2000000 | 128 * v171)); // 0x222c0
    uint32_t v175 = v174 + ((v172 | v168) & v164 | v172 & v168) + ((v172 / 0x2000 | 0x80000 * v172) ^ (v172 / 4 | 0x40000000 * v172) ^ (v172 / 0x400000 | 1024 * v172)); // 0x222dc
    uint32_t v176 = v174 + v160; // 0x222f8
    uint32_t v177 = ((v117 / 128 | 0x2000000 * v117) ^ v117 / 8 ^ (v117 / 0x40000 | 0x4000 * v117)) + v113 + v149 + ((v169 / 0x20000 | 0x8000 * v169) ^ v169 / 1024 ^ (v169 / 0x80000 | 0x2000 * v169)); // 0x22314
    int32_t v178 = v177 - 0x5d40175f + v163 + (v176 & (v171 ^ v167) ^ v167) + ((v176 / 2048 | 0x200000 * v176) ^ (v176 / 64 | 0x4000000 * v176) ^ (v176 / 0x2000000 | 128 * v176)); // 0x22360
    uint32_t v179 = v178 + v164; // 0x2236c
    uint32_t v180 = v178 + ((v175 | v172) & v168 | v175 & v172) + ((v175 / 0x2000 | 0x80000 * v175) ^ (v175 / 4 | 0x40000000 * v175) ^ (v175 / 0x400000 | 1024 * v175)); // 0x22380
    uint32_t v181 = ((v121 / 128 | 0x2000000 * v121) ^ v121 / 8 ^ (v121 / 0x40000 | 0x4000 * v121)) + v117 + v153 + ((v173 / 0x20000 | 0x8000 * v173) ^ v173 / 1024 ^ (v173 / 0x80000 | 0x2000 * v173)); // 0x223a4
    int32_t v182 = v181 - 0x57e599b5 + v167 + (v179 & (v176 ^ v171) ^ v171) + ((v179 / 2048 | 0x200000 * v179) ^ (v179 / 64 | 0x4000000 * v179) ^ (v179 / 0x2000000 | 128 * v179)); // 0x22404
    uint32_t v183 = v182 + v168; // 0x2240c
    uint32_t v184 = v182 + ((v180 | v175) & v172 | v180 & v175) + ((v180 / 0x2000 | 0x80000 * v180) ^ (v180 / 4 | 0x40000000 * v180) ^ (v180 / 0x400000 | 1024 * v180)); // 0x22414
    uint32_t v185 = ((v125 / 128 | 0x2000000 * v125) ^ v125 / 8 ^ (v125 / 0x40000 | 0x4000 * v125)) + v121 + v157 + ((v177 / 0x20000 | 0x8000 * v177) ^ v177 / 1024 ^ (v177 / 0x80000 | 0x2000 * v177)); // 0x2243c
    int32_t v186 = v185 - 0x3db47490 + v171 + (v183 & (v179 ^ v176) ^ v176) + ((v183 / 2048 | 0x200000 * v183) ^ (v183 / 64 | 0x4000000 * v183) ^ (v183 / 0x2000000 | 128 * v183)); // 0x2248c
    uint32_t v187 = v186 + v172; // 0x224ac
    uint32_t v188 = v186 + ((v184 | v180) & v175 | v184 & v180) + ((v184 / 0x2000 | 0x80000 * v184) ^ (v184 / 4 | 0x40000000 * v184) ^ (v184 / 0x400000 | 1024 * v184)); // 0x224d0
    uint32_t v189 = ((v129 / 128 | 0x2000000 * v129) ^ v129 / 8 ^ (v129 / 0x40000 | 0x4000 * v129)) + v125 + v161 + ((v181 / 0x20000 | 0x8000 * v181) ^ v181 / 1024 ^ (v181 / 0x80000 | 0x2000 * v181)); // 0x224e0
    int32_t v190 = v189 - 0x3893ae5d + v176 + (v187 & (v183 ^ v179) ^ v179) + ((v187 / 2048 | 0x200000 * v187) ^ (v187 / 64 | 0x4000000 * v187) ^ (v187 / 0x2000000 | 128 * v187)); // 0x22510
    uint32_t v191 = v190 + ((v188 | v184) & v180 | v188 & v184) + ((v188 / 0x2000 | 0x80000 * v188) ^ (v188 / 4 | 0x40000000 * v188) ^ (v188 / 0x400000 | 1024 * v188)); // 0x22538
    uint32_t v192 = v190 + v175; // 0x22544
    uint32_t v193 = ((v133 / 128 | 0x2000000 * v133) ^ v133 / 8 ^ (v133 / 0x40000 | 0x4000 * v133)) + v129 + v165 + ((v185 / 0x20000 | 0x8000 * v185) ^ v185 / 1024 ^ (v185 / 0x80000 | 0x2000 * v185)); // 0x2256c
    int32_t v194 = v193 - 0x2e6d17e7 + v179 + (v192 & (v187 ^ v183) ^ v183) + ((v192 / 2048 | 0x200000 * v192) ^ (v192 / 64 | 0x4000000 * v192) ^ (v192 / 0x2000000 | 128 * v192)); // 0x225b8
    uint32_t v195 = v194 + v180; // 0x225cc
    uint32_t v196 = v194 + ((v191 | v188) & v184 | v191 & v188) + ((v191 / 0x2000 | 0x80000 * v191) ^ (v191 / 4 | 0x40000000 * v191) ^ (v191 / 0x400000 | 1024 * v191)); // 0x225d8
    uint32_t v197 = ((v137 / 128 | 0x2000000 * v137) ^ v137 / 8 ^ (v137 / 0x40000 | 0x4000 * v137)) + v133 + v169 + ((v189 / 0x20000 | 0x8000 * v189) ^ v189 / 1024 ^ (v189 / 0x80000 | 0x2000 * v189)); // 0x22600
    int32_t v198 = v197 - 0x2966f9dc + v183 + (v195 & (v192 ^ v187) ^ v187) + ((v195 / 2048 | 0x200000 * v195) ^ (v195 / 64 | 0x4000000 * v195) ^ (v195 / 0x2000000 | 128 * v195)); // 0x22648
    uint32_t v199 = v198 + v184; // 0x22654
    uint32_t v200 = v198 + ((v196 | v191) & v188 | v196 & v191) + ((v196 / 0x2000 | 0x80000 * v196) ^ (v196 / 4 | 0x40000000 * v196) ^ (v196 / 0x400000 | 1024 * v196)); // 0x22668
    uint32_t v201 = ((v141 / 128 | 0x2000000 * v141) ^ v141 / 8 ^ (v141 / 0x40000 | 0x4000 * v141)) + v137 + v173 + ((v193 / 0x20000 | 0x8000 * v193) ^ v193 / 1024 ^ (v193 / 0x80000 | 0x2000 * v193)); // 0x226a0
    int32_t v202 = v201 - 0xbf1ca7b + v187 + (v199 & (v195 ^ v192) ^ v192) + ((v199 / 2048 | 0x200000 * v199) ^ (v199 / 64 | 0x4000000 * v199) ^ (v199 / 0x2000000 | 128 * v199)); // 0x226e0
    uint32_t v203 = v202 + v188; // 0x226f0
    uint32_t v204 = v202 + ((v200 | v196) & v191 | v200 & v196) + ((v200 / 0x2000 | 0x80000 * v200) ^ (v200 / 4 | 0x40000000 * v200) ^ (v200 / 0x400000 | 1024 * v200)); // 0x22700
    uint32_t v205 = ((v145 / 128 | 0x2000000 * v145) ^ v145 / 8 ^ (v145 / 0x40000 | 0x4000 * v145)) + v141 + v177 + ((v197 / 0x20000 | 0x8000 * v197) ^ v197 / 1024 ^ (v197 / 0x80000 | 0x2000 * v197)); // 0x22738
    int32_t v206 = v205 + 0x106aa070 + v192 + (v203 & (v199 ^ v195) ^ v195) + ((v203 / 2048 | 0x200000 * v203) ^ (v203 / 64 | 0x4000000 * v203) ^ (v203 / 0x2000000 | 128 * v203)); // 0x2276c
    uint32_t v207 = v206 + v191; // 0x22784
    uint32_t v208 = v206 + ((v204 | v200) & v196 | v204 & v200) + ((v204 / 0x2000 | 0x80000 * v204) ^ (v204 / 4 | 0x40000000 * v204) ^ (v204 / 0x400000 | 1024 * v204)); // 0x22790
    uint32_t v209 = ((v149 / 128 | 0x2000000 * v149) ^ v149 / 8 ^ (v149 / 0x40000 | 0x4000 * v149)) + v145 + v181 + ((v201 / 0x20000 | 0x8000 * v201) ^ v201 / 1024 ^ (v201 / 0x80000 | 0x2000 * v201)); // 0x227c8
    int32_t v210 = v209 + 0x19a4c116 + v195 + (v207 & (v203 ^ v199) ^ v199) + ((v207 / 2048 | 0x200000 * v207) ^ (v207 / 64 | 0x4000000 * v207) ^ (v207 / 0x2000000 | 128 * v207)); // 0x22804
    uint32_t v211 = v210 + v196; // 0x2281c
    uint32_t v212 = v210 + ((v208 | v204) & v200 | v208 & v204) + ((v208 / 0x2000 | 0x80000 * v208) ^ (v208 / 4 | 0x40000000 * v208) ^ (v208 / 0x400000 | 1024 * v208)); // 0x22824
    uint32_t v213 = ((v153 / 128 | 0x2000000 * v153) ^ v153 / 8 ^ (v153 / 0x40000 | 0x4000 * v153)) + v149 + v185 + ((v205 / 0x20000 | 0x8000 * v205) ^ v205 / 1024 ^ (v205 / 0x80000 | 0x2000 * v205)); // 0x2284c
    int32_t v214 = v213 + 0x1e376c08 + v199 + (v211 & (v207 ^ v203) ^ v203) + ((v211 / 2048 | 0x200000 * v211) ^ (v211 / 64 | 0x4000000 * v211) ^ (v211 / 0x2000000 | 128 * v211)); // 0x22894
    uint32_t v215 = v214 + ((v212 | v208) & v204 | v212 & v208) + ((v212 / 0x2000 | 0x80000 * v212) ^ (v212 / 4 | 0x40000000 * v212) ^ (v212 / 0x400000 | 1024 * v212)); // 0x228b4
    uint32_t v216 = v214 + v200; // 0x228b8
    uint32_t v217 = ((v157 / 128 | 0x2000000 * v157) ^ v157 / 8 ^ (v157 / 0x40000 | 0x4000 * v157)) + v153 + v189 + ((v209 / 0x20000 | 0x8000 * v209) ^ v209 / 1024 ^ (v209 / 0x80000 | 0x2000 * v209)); // 0x228d8
    int32_t v218 = v217 + 0x2748774c + v203 + (v216 & (v211 ^ v207) ^ v207) + ((v216 / 2048 | 0x200000 * v216) ^ (v216 / 64 | 0x4000000 * v216) ^ (v216 / 0x2000000 | 128 * v216)); // 0x22924
    uint32_t v219 = v218 + v204; // 0x22934
    uint32_t v220 = v218 + ((v215 | v212) & v208 | v215 & v212) + ((v215 / 0x2000 | 0x80000 * v215) ^ (v215 / 4 | 0x40000000 * v215) ^ (v215 / 0x400000 | 1024 * v215)); // 0x22940
    uint32_t v221 = ((v161 / 128 | 0x2000000 * v161) ^ v161 / 8 ^ (v161 / 0x40000 | 0x4000 * v161)) + v157 + v193 + ((v213 / 0x20000 | 0x8000 * v213) ^ v213 / 1024 ^ (v213 / 0x80000 | 0x2000 * v213)); // 0x22968
    int32_t v222 = v221 + 0x34b0bcb5 + v207 + (v219 & (v216 ^ v211) ^ v211) + ((v219 / 2048 | 0x200000 * v219) ^ (v219 / 64 | 0x4000000 * v219) ^ (v219 / 0x2000000 | 128 * v219)); // 0x229b8
    uint32_t v223 = v222 + v208; // 0x229c4
    uint32_t v224 = v222 + ((v220 | v215) & v212 | v220 & v215) + ((v220 / 0x2000 | 0x80000 * v220) ^ (v220 / 4 | 0x40000000 * v220) ^ (v220 / 0x400000 | 1024 * v220)); // 0x229dc
    uint32_t v225 = ((v165 / 128 | 0x2000000 * v165) ^ v165 / 8 ^ (v165 / 0x40000 | 0x4000 * v165)) + v161 + v197 + ((v217 / 0x20000 | 0x8000 * v217) ^ v217 / 1024 ^ (v217 / 0x80000 | 0x2000 * v217)); // 0x22a0c
    int32_t v226 = v225 + 0x391c0cb3 + v211 + (v223 & (v219 ^ v216) ^ v216) + ((v223 / 2048 | 0x200000 * v223) ^ (v223 / 64 | 0x4000000 * v223) ^ (v223 / 0x2000000 | 128 * v223)); // 0x22a48
    uint32_t v227 = v226 + v212; // 0x22a5c
    uint32_t v228 = v226 + ((v224 | v220) & v215 | v224 & v220) + ((v224 / 0x2000 | 0x80000 * v224) ^ (v224 / 4 | 0x40000000 * v224) ^ (v224 / 0x400000 | 1024 * v224)); // 0x22a6c
    uint32_t v229 = ((v169 / 128 | 0x2000000 * v169) ^ v169 / 8 ^ (v169 / 0x40000 | 0x4000 * v169)) + v165 + v201 + ((v221 / 0x20000 | 0x8000 * v221) ^ v221 / 1024 ^ (v221 / 0x80000 | 0x2000 * v221)); // 0x22a98
    int32_t v230 = v229 + 0x4ed8aa4a + v216 + (v227 & (v223 ^ v219) ^ v219) + ((v227 / 2048 | 0x200000 * v227) ^ (v227 / 64 | 0x4000000 * v227) ^ (v227 / 0x2000000 | 128 * v227)); // 0x22adc
    uint32_t v231 = v230 + v215; // 0x22aec
    uint32_t v232 = v230 + ((v228 | v224) & v220 | v228 & v224) + ((v228 / 0x2000 | 0x80000 * v228) ^ (v228 / 4 | 0x40000000 * v228) ^ (v228 / 0x400000 | 1024 * v228)); // 0x22b00
    uint32_t v233 = ((v173 / 128 | 0x2000000 * v173) ^ v173 / 8 ^ (v173 / 0x40000 | 0x4000 * v173)) + v169 + v205 + ((v225 / 0x20000 | 0x8000 * v225) ^ v225 / 1024 ^ (v225 / 0x80000 | 0x2000 * v225)); // 0x22b24
    int32_t v234 = v233 + 0x5b9cca4f + v219 + (v231 & (v227 ^ v223) ^ v223) + ((v231 / 2048 | 0x200000 * v231) ^ (v231 / 64 | 0x4000000 * v231) ^ (v231 / 0x2000000 | 128 * v231)); // 0x22b6c
    uint32_t v235 = v234 + v220; // 0x22b9c
    uint32_t v236 = ((v177 / 128 | 0x2000000 * v177) ^ v177 / 8 ^ (v177 / 0x40000 | 0x4000 * v177)) + v173 + v209 + ((v229 / 0x20000 | 0x8000 * v229) ^ v229 / 1024 ^ (v229 / 0x80000 | 0x2000 * v229)); // 0x22ba4
    uint32_t v237 = v234 + ((v232 | v228) & v224 | v232 & v228) + ((v232 / 0x2000 | 0x80000 * v232) ^ (v232 / 4 | 0x40000000 * v232) ^ (v232 / 0x400000 | 1024 * v232)); // 0x22bb4
    int32_t v238 = v236 + 0x682e6ff3 + v223 + (v235 & (v231 ^ v227) ^ v227) + ((v235 / 2048 | 0x200000 * v235) ^ (v235 / 64 | 0x4000000 * v235) ^ (v235 / 0x2000000 | 128 * v235)); // 0x22bfc
    uint32_t v239 = v238 + v224; // 0x22c0c
    uint32_t v240 = v238 + ((v237 | v232) & v228 | v237 & v232) + ((v237 / 0x2000 | 0x80000 * v237) ^ (v237 / 4 | 0x40000000 * v237) ^ (v237 / 0x400000 | 1024 * v237)); // 0x22c20
    uint32_t v241 = ((v181 / 128 | 0x2000000 * v181) ^ v181 / 8 ^ (v181 / 0x40000 | 0x4000 * v181)) + v177 + v213 + ((v233 / 0x20000 | 0x8000 * v233) ^ v233 / 1024 ^ (v233 / 0x80000 | 0x2000 * v233)); // 0x22c54
    int32_t v242 = v241 + 0x748f82ee + v227 + (v239 & (v235 ^ v231) ^ v231) + ((v239 / 2048 | 0x200000 * v239) ^ (v239 / 64 | 0x4000000 * v239) ^ (v239 / 0x2000000 | 128 * v239)); // 0x22ca4
    uint32_t v243 = v242 + v228; // 0x22cb0
    uint32_t v244 = v242 + ((v240 | v237) & v232 | v240 & v237) + ((v240 / 0x2000 | 0x80000 * v240) ^ (v240 / 4 | 0x40000000 * v240) ^ (v240 / 0x400000 | 1024 * v240)); // 0x22ce4
    uint32_t v245 = ((v185 / 128 | 0x2000000 * v185) ^ v185 / 8 ^ (v185 / 0x40000 | 0x4000 * v185)) + v181 + v217 + ((v236 / 0x20000 | 0x8000 * v236) ^ v236 / 1024 ^ (v236 / 0x80000 | 0x2000 * v236)); // 0x22d14
    int32_t v246 = v245 + 0x78a5636f + v231 + (v243 & (v239 ^ v235) ^ v235) + ((v243 / 2048 | 0x200000 * v243) ^ (v243 / 64 | 0x4000000 * v243) ^ (v243 / 0x2000000 | 128 * v243)); // 0x22d60
    uint32_t v247 = v246 + v232; // 0x22d78
    uint32_t v248 = v246 + ((v244 | v240) & v237 | v244 & v240) + ((v244 / 0x2000 | 0x80000 * v244) ^ (v244 / 4 | 0x40000000 * v244) ^ (v244 / 0x400000 | 1024 * v244)); // 0x22d9c
    uint32_t v249 = ((v189 / 128 | 0x2000000 * v189) ^ v189 / 8 ^ (v189 / 0x40000 | 0x4000 * v189)) + v185 + v221 + ((v241 / 0x20000 | 0x8000 * v241) ^ v241 / 1024 ^ (v241 / 0x80000 | 0x2000 * v241)); // 0x22dac
    int32_t v250 = v249 - 0x7b3787ec + v235 + (v247 & (v243 ^ v239) ^ v239) + ((v247 / 2048 | 0x200000 * v247) ^ (v247 / 64 | 0x4000000 * v247) ^ (v247 / 0x2000000 | 128 * v247)); // 0x22e08
    uint32_t v251 = v250 + v237; // 0x22e20
    uint32_t v252 = v250 + ((v248 | v244) & v240 | v248 & v244) + ((v248 / 0x2000 | 0x80000 * v248) ^ (v248 / 4 | 0x40000000 * v248) ^ (v248 / 0x400000 | 1024 * v248)); // 0x22e24
    uint32_t v253 = ((v193 / 128 | 0x2000000 * v193) ^ v193 / 8 ^ (v193 / 0x40000 | 0x4000 * v193)) + v189 + v225 + ((v245 / 0x20000 | 0x8000 * v245) ^ v245 / 1024 ^ (v245 / 0x80000 | 0x2000 * v245)); // 0x22e64
    int32_t v254 = v253 - 0x7338fdf8 + v239 + (v251 & (v247 ^ v243) ^ v243) + ((v251 / 2048 | 0x200000 * v251) ^ (v251 / 64 | 0x4000000 * v251) ^ (v251 / 0x2000000 | 128 * v251)); // 0x22ed0
    uint32_t v255 = v254 + ((v252 | v248) & v244 | v252 & v248) + ((v252 / 0x2000 | 0x80000 * v252) ^ (v252 / 4 | 0x40000000 * v252) ^ (v252 / 0x400000 | 1024 * v252)); // 0x22ee8
    uint32_t v256 = v254 + v240; // 0x22ef4
    uint32_t v257 = ((v197 / 128 | 0x2000000 * v197) ^ v197 / 8 ^ (v197 / 0x40000 | 0x4000 * v197)) + v193 + v229 + ((v249 / 0x20000 | 0x8000 * v249) ^ v249 / 1024 ^ (v249 / 0x80000 | 0x2000 * v249)); // 0x22f24
    int32_t v258 = v257 - 0x6f410006 + v243 + (v256 & (v251 ^ v247) ^ v247) + ((v256 / 2048 | 0x200000 * v256) ^ (v256 / 64 | 0x4000000 * v256) ^ (v256 / 0x2000000 | 128 * v256)); // 0x22fa0
    uint32_t v259 = v258 + ((v255 | v252) & v248 | v255 & v252) + ((v255 / 0x2000 | 0x80000 * v255) ^ (v255 / 4 | 0x40000000 * v255) ^ (v255 / 0x400000 | 1024 * v255)); // 0x22fb0
    uint32_t v260 = v258 + v244; // 0x22fc4
    uint32_t v261 = ((v201 / 128 | 0x2000000 * v201) ^ v201 / 8 ^ (v201 / 0x40000 | 0x4000 * v201)) + v197 + v233 + ((v253 / 0x20000 | 0x8000 * v253) ^ v253 / 1024 ^ (v253 / 0x80000 | 0x2000 * v253)); // 0x22fd8
    int32_t v262 = v261 - 0x5baf9315 + v247 + (v260 & (v256 ^ v251) ^ v251) + ((v260 / 2048 | 0x200000 * v260) ^ (v260 / 64 | 0x4000000 * v260) ^ (v260 / 0x2000000 | 128 * v260)); // 0x23034
    uint32_t v263 = v262 + v248; // 0x23040
    uint32_t v264 = v262 + ((v259 | v255) & v252 | v259 & v255) + ((v259 / 0x2000 | 0x80000 * v259) ^ (v259 / 4 | 0x40000000 * v259) ^ (v259 / 0x400000 | 1024 * v259)); // 0x2304c
    int32_t v265 = v201 - 0x41065c09 + ((v205 / 128 | 0x2000000 * v205) ^ v205 / 8 ^ (v205 / 0x40000 | 0x4000 * v205)) + v236 + ((v257 / 0x20000 | 0x8000 * v257) ^ v257 / 1024 ^ (v257 / 0x80000 | 0x2000 * v257)) + v251 + (v263 & (v260 ^ v256) ^ v256) + ((v263 / 2048 | 0x200000 * v263) ^ (v263 / 64 | 0x4000000 * v263) ^ (v263 / 0x2000000 | 128 * v263)); // 0x230b8
    uint32_t v266 = v265 + ((v264 | v259) & v255 | v264 & v259) + ((v264 / 0x2000 | 0x80000 * v264) ^ (v264 / 4 | 0x40000000 * v264) ^ (v264 / 0x400000 | 1024 * v264)); // 0x230d8
    uint32_t v267 = v265 + v252; // 0x230dc
    int32_t v268 = v205 - 0x398e870e + ((v209 / 128 | 0x2000000 * v209) ^ v209 / 8 ^ (v209 / 0x40000 | 0x4000 * v209)) + v241 + ((v261 / 0x20000 | 0x8000 * v261) ^ v261 / 1024 ^ (v261 / 0x80000 | 0x2000 * v261)) + v256 + (v267 & (v263 ^ v260) ^ v260) + ((v267 / 2048 | 0x200000 * v267) ^ (v267 / 64 | 0x4000000 * v267) ^ (v267 / 0x2000000 | 128 * v267)); // 0x23138
    int32_t result = v264 + v14; // 0x23170
    *v9 = v260 + v10;
    *v15 = v259 + v16;
    *v5 = v263 + v6;
    *v13 = result;
    *v11 = v266 + v12;
    *v7 = v267 + v8;
    *v1 = ((v266 | v264) & v259 | v266 & v264) + v2 + v268 + ((v266 / 0x2000 | 0x80000 * v266) ^ (v266 / 4 | 0x40000000 * v266) ^ (v266 / 0x400000 | 1024 * v266));
    *v3 = v255 + v4 + v268;
    return result;
}

// Address range: 0x231a4 - 0x23270
int32_t function_231a4(uint32_t a1, int32_t a2, int32_t a3) {
    uint32_t v1 = a3 + a1; // 0x231b8
    if (v1 < a1) {
        int32_t * v2 = (int32_t *)(a1 + 4);
        *(int32_t *)a1 = v1;
        *v2 = *v2 + 1;
    } else {
        *(int32_t *)a1 = v1;
    }
    int32_t v3 = a1 % 64; // 0x231bc
    int32_t v4 = 64 - v3;
    int32_t v5 = v3 != 0 == v4 <= a3;
    int32_t v6 = a1; // 0x231ec
    int32_t v7 = a2; // 0x231ec
    int32_t v8 = a3; // 0x231ec
    int32_t v9 = v3; // 0x231ec
    if (v3 != 0 == v4 <= a3) {
        int32_t v10 = a1 + 40; // 0x23244
        function_11fc4((int32_t *)(v10 + v3), a2, (char)v4, v5);
        v6 = function_20d44(a1, v10);
        v7 = v4 + a2;
        v8 = a3 - v4;
        v9 = 0;
    }
    int32_t result = v6; // 0x231f4
    int32_t v11 = v7; // 0x231f4
    int32_t v12 = v8; // 0x231f4
    if (v8 >= 64) {
        // 0x231f8
        v11 = (v8 & -64) + v7;
        int32_t v13 = v7 + 64; // 0x23210
        result = function_20d44(a1, v7);
        while (v13 != v11) {
            int32_t v14 = v13;
            v13 = v14 + 64;
            result = function_20d44(a1, v14);
        }
        // 0x23220
        v12 = v8 % 64;
    }
    // 0x23224
    if (v12 < 1) {
        return result;
    }
    // 0x2322c
    return function_11fc4((int32_t *)(a1 + 40 + v9), v11, (char)v12, v5);
}

// Address range: 0x23270 - 0x2327c
int32_t function_23270(int32_t result, int32_t a2, int32_t a3) {
    if (a3 < 1) {
        return result;
    }
    // 0x23278
    return function_231a4(result, a2, a3);
}

// Address range: 0x2327c - 0x23430
// Used cryptographic patterns:
//  - padding_used_in_hashing_algorithms__0x80_0_____0_ (8-bit)
int32_t function_2327c(int32_t * a1, int32_t * a2) {
    int32_t v1 = (int32_t)a2;
    uint32_t v2 = (int32_t)a1;
    uint32_t v3 = v2 % 64; // 0x23294
    int32_t v4 = v3 == 55 | (v2 & 16) == 0 ? 56 - v3 : v3;
    int32_t v5 = (v2 & 16) != 0 == (v3 != 55) ? 120 - v4 : v4;
    int32_t v6 = 0x1000000 * *(int32_t *)(v2 + 4) / 0x200000 >> 24; // bp-24, 0x232f0
    function_231a4(v2, (int32_t)"\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", v5);
    int32_t result = function_231a4(v2, (int32_t)&v6, 8); // 0x23304
    *(char *)a2 = *(char *)(v2 + 11);
    *(char *)(v1 + 1) = (char)*(int16_t *)(v2 + 10);
    int32_t * v7 = (int32_t *)(v2 + 8); // 0x23318
    *(char *)(v1 + 2) = (char)(*v7 / 256);
    *(char *)(v1 + 3) = (char)*v7;
    *(char *)(v1 + 4) = *(char *)(v2 + 15);
    *(char *)(v1 + 5) = (char)*(int16_t *)(v2 + 14);
    int32_t * v8 = (int32_t *)(v2 + 12); // 0x2333c
    *(char *)(v1 + 6) = (char)(*v8 / 256);
    *(char *)(v1 + 7) = (char)*v8;
    *(char *)(v1 + 8) = *(char *)(v2 + 19);
    *(char *)(v1 + 9) = (char)*(int16_t *)(v2 + 18);
    int32_t * v9 = (int32_t *)(v2 + 16); // 0x23360
    *(char *)(v1 + 10) = (char)(*v9 / 256);
    *(char *)(v1 + 11) = (char)*v9;
    *(char *)(v1 + 12) = *(char *)(v2 + 23);
    *(char *)(v1 + 13) = (char)*(int16_t *)(v2 + 22);
    int32_t * v10 = (int32_t *)(v2 + 20); // 0x23384
    *(char *)(v1 + 14) = (char)(*v10 / 256);
    *(char *)(v1 + 15) = (char)*v10;
    *(char *)(v1 + 16) = *(char *)(v2 + 27);
    *(char *)(v1 + 17) = (char)*(int16_t *)(v2 + 26);
    int32_t * v11 = (int32_t *)(v2 + 24); // 0x233a8
    *(char *)(v1 + 18) = (char)(*v11 / 256);
    *(char *)(v1 + 19) = (char)*v11;
    *(char *)(v1 + 20) = *(char *)(v2 + 31);
    *(char *)(v1 + 21) = (char)*(int16_t *)(v2 + 30);
    int32_t * v12 = (int32_t *)(v2 + 28); // 0x233cc
    *(char *)(v1 + 22) = (char)(*v12 / 256);
    *(char *)(v1 + 23) = (char)*v12;
    *(char *)(v1 + 24) = *(char *)(v2 + 35);
    *(char *)(v1 + 25) = (char)*(int16_t *)(v2 + 34);
    int32_t * v13 = (int32_t *)(v2 + 32); // 0x233f0
    *(char *)(v1 + 26) = (char)(*v13 / 256);
    *(char *)(v1 + 27) = (char)*v13;
    *(char *)(v1 + 28) = *(char *)(v2 + 39);
    *(char *)(v1 + 29) = (char)*(int16_t *)(v2 + 38);
    int32_t * v14 = (int32_t *)(v2 + 36); // 0x23414
    *(char *)(v1 + 30) = (char)(*v14 / 256);
    *(char *)(v1 + 31) = (char)*v14;
    return result;
}

// Address range: 0x23430 - 0x234d8
int32_t function_23430(int32_t * a1, uint32_t a2, int32_t * a3) {
    int32_t v1 = 0; // bp-248, 0x234a8
    if (a2 >= 1) {
        // 0x234b4
        function_231a4((int32_t)&v1, (int32_t)a1, a2);
    }
    // 0x234c4
    return function_2327c(&v1, a3);
}

// Address range: 0x234d8 - 0x23574
int32_t function_234d8(int32_t str, int32_t size, int32_t a3) {
    // 0x234d8
    switch (function_36548()) {
        case 0: {
            // 0x23520
            snprintf((char *)str, size, "%d", a3);
            return 0;
        }
        case 1: {
            // 0x23544
            snprintf((char *)str, size, "%s:%s", "searchfailed", (char *)function_359ec());
            return 0;
        }
    }
    // 0x23500
    snprintf((char *)str, size, "searching");
    return 0;
}

// Address range: 0x23574 - 0x24264
int32_t function_23574(int32_t a1, int32_t str2, int32_t size, int32_t a4, int32_t a5) {
    // 0x23574
    float64_t v1; // 0x23574
    float64_t v2 = __asm_vpush_17(v1, v1, v1, v1, v1); // 0x2357c
    int32_t v3 = a1 + 4; // 0x23580
    char * str = (char *)v3; // 0x235a4
    int32_t str3; // bp-2088, 0x23574
    if (strncmp(str, "/rate", 5) == 0) {
        // 0x235b0
        if (g61 != 0) {
            // 0x235c4
            if ((*(char *)&g60 | *(char *)&g221) == 0 != g290 < 7) {
                // 0x23600
                str3 = 0x20646d63;
                function_2e584(7, &str3, 0);
            }
        }
        // 0x23630
        function_234d8(str2, size, function_1a18c());
        // 0x23644
        __asm_vpop_18(v2, v2, v2, v2, v2);
        return 0;
    }
    // 0x23658
    if (strncmp(str, "/ideal_rate", 11) == 0) {
        // 0x23674
        if (g61 != 0) {
            // 0x23688
            if ((*(char *)&g60 | *(char *)&g221) != 0 || g290 > 6) {
                // 0x236b0
                str3 = 0x20646d63;
                function_2e584(7, &str3, 0);
            }
        }
        // 0x236e0
        function_234d8(str2, size, function_1a014());
        // 0x23644
        __asm_vpop_18(v2, v2, v2, v2, v2);
        return 0;
    }
    // 0x236f8
    if (strncmp(str, "/max_rate", 9) == 0) {
        // 0x23714
        if (g61 != 0) {
            // 0x23728
            if ((*(char *)&g60 | *(char *)&g221) == 0 != g290 < 7) {
                // 0x23764
                str3 = 0x20646d63;
                function_2e584(7, &str3, 0);
            }
        }
        // 0x23798
        function_234d8(str2, size, function_19e68());
        // 0x23644
        __asm_vpop_18(v2, v2, v2, v2, v2);
        return 0;
    }
    // 0x237b0
    if (strncmp(str, "/miner_status", 13) == 0) {
        // 0x237cc
        if (g61 == 0) {
            // 0x23644
            __asm_vpop_18(v2, v2, v2, v2, v2);
            return 0;
        }
        // 0x237e0
        if ((*(char *)&g60 | *(char *)&g221) == 0 != g290 < 7) {
            // 0x2381c
            str3 = 0x20646d63;
            function_2e584(7, &str3, 0);
        }
        // 0x23644
        __asm_vpop_18(v2, v2, v2, v2, v2);
        return 0;
    }
    // 0x23858
    if (strncmp(str, "/productName", 12) == 0) {
        // 0x23958
        if (g61 != 0) {
            // 0x2396c
            if ((*(char *)&g60 | *(char *)&g221) == 0 != g290 < 7) {
                // 0x239a8
                str3 = 0x20646d63;
                function_2e584(7, &str3, 0);
            }
        }
        // 0x239d8
        snprintf((char *)str2, 256, "%s", (char *)&g387);
        // 0x23644
        __asm_vpop_18(v2, v2, v2, v2, v2);
        return 0;
    }
    // 0x23874
    if (strncmp(str, "/get_sn", 7) == 0) {
        // 0x23890
        if (g61 != 0) {
            // 0x238a4
            if ((*(char *)&g60 | *(char *)&g221) == 0 != g290 < 7) {
                // 0x238e0
                str3 = 0x20646d63;
                function_2e584(7, &str3, 0);
            }
        }
        // 0x23914
        if (*(char *)&g343 == 0) {
            // 0x23b00
            *(int32_t *)str2 = 0x6d206f6e;
            *(int32_t *)(str2 + 4) = 0x72656e69;
            *(int32_t *)(str2 + 8) = 0x206e7320;
            *(int32_t *)(str2 + 12) = 0x726f7473;
            *(int32_t *)(str2 + 16) = 0x6f206465;
            *(int32_t *)(str2 + 20) = 0x6f62206e;
            *(int32_t *)(str2 + 24) = (int32_t)&g252;
        } else {
            // 0x23928
            snprintf((char *)str2, 256, "%s", (char *)&g343);
        }
        // 0x23644
        __asm_vpop_18(v2, v2, v2, v2, v2);
        return 0;
    }
    // 0x23a54
    if (strncmp(str, "/set_sn", 7) == 0) {
        // 0x23a70
        if ((*(char *)&g60 | *(char *)&g221) == 0 != g290 < 5) {
            // 0x23aac
            str3 = 0x20646d63;
            function_2e584(5, &str3, 0);
        }
        // 0x23ae8
        snprintf((char *)str2, 20, "doesn't support sn set in Release mode");
        // 0x23644
        __asm_vpop_18(v2, v2, v2, v2, v2);
        return 0;
    }
    // 0x23b30
    int32_t delim; // bp-3112, 0x23574
    if (strncmp(str, "/readreg", 8) == 0) {
        // 0x23c14
        delim = 45;
        if (strtok(str, (char *)&delim) == NULL) {
            // 0x23d4c
            snprintf((char *)str2, size, "404 not found");
            // 0x23644
            __asm_vpop_18(v2, v2, v2, v2, v2);
            return 0;
        }
        char * next_token = strtok(NULL, (char *)&delim); // 0x23c3c
        if (next_token == NULL) {
            // 0x23d4c
            snprintf((char *)str2, size, "404 not found");
            // 0x23644
            __asm_vpop_18(v2, v2, v2, v2, v2);
            return 0;
        }
        int32_t v4 = function_11ef8((int32_t *)next_token, 0, 10); // 0x23c50
        char * next_token2 = strtok(NULL, (char *)&delim); // 0x23c60
        if (next_token2 == NULL) {
            // 0x23d4c
            snprintf((char *)str2, size, "404 not found");
            // 0x23644
            __asm_vpop_18(v2, v2, v2, v2, v2);
            return 0;
        }
        int32_t v5 = function_11ef8((int32_t *)next_token2, 0, 10); // 0x23c74
        char * next_token3 = strtok(NULL, (char *)&delim); // 0x23c84
        if (next_token3 == NULL) {
            // 0x23d4c
            snprintf((char *)str2, size, "404 not found");
            // 0x23644
            __asm_vpop_18(v2, v2, v2, v2, v2);
            return 0;
        }
        int32_t v6 = function_11ef8((int32_t *)next_token3, 0, 16); // 0x23c98
        if ((*(char *)&g60 | *(char *)&g221) == 0 != g290 < 5) {
            // 0x23cdc
            snprintf((char *)&str3, 2048, "recvBuf = %s, chain = %d, asic = %d, reg = 0x%x\n", (char *)a1, v4, v5, v6);
            function_2e584(5, &str3, 0);
        }
        int32_t v7 = function_1e160(); // 0x23d10
        snprintf((char *)str2, size, "reg 0x%08x of asic %2d @ chain %2d, val = 0x%08x", v6, v5, v4, function_2c06c(v6, v7 * v5, v4));
        // 0x23644
        __asm_vpop_18(v2, v2, v2, v2, v2);
        return 0;
    }
    // 0x23b4c
    if (strncmp(str, "/readcorereg", 12) == 0) {
        int32_t delim2 = 45; // bp-3116, 0x23d7c
        memset(&delim, 0, 1024);
        if (strtok(str, (char *)&delim2) == NULL) {
            // 0x23d4c
            snprintf((char *)str2, size, "404 not found");
            // 0x23644
            __asm_vpop_18(v2, v2, v2, v2, v2);
            return 0;
        }
        char * next_token4 = strtok(NULL, (char *)&delim2); // 0x23da0
        if (next_token4 == NULL) {
            // 0x23d4c
            snprintf((char *)str2, size, "404 not found");
            // 0x23644
            __asm_vpop_18(v2, v2, v2, v2, v2);
            return 0;
        }
        int32_t v8 = function_11ef8((int32_t *)next_token4, 0, 10); // 0x23db4
        char * next_token5 = strtok(NULL, (char *)&delim2); // 0x23dc4
        if (next_token5 == NULL) {
            // 0x23d4c
            snprintf((char *)str2, size, "404 not found");
            // 0x23644
            __asm_vpop_18(v2, v2, v2, v2, v2);
            return 0;
        }
        int32_t v9 = function_11ef8((int32_t *)next_token5, 0, 10); // 0x23dd8
        char * next_token6 = strtok(NULL, (char *)&delim2); // 0x23de8
        if (next_token6 == NULL) {
            // 0x23d4c
            snprintf((char *)str2, size, "404 not found");
            // 0x23644
            __asm_vpop_18(v2, v2, v2, v2, v2);
            return 0;
        }
        int32_t v10 = function_11ef8((int32_t *)next_token6, 0, 16); // 0x23dfc
        if ((*(char *)&g60 | *(char *)&g221) == 0 != g290 < 5) {
            // 0x23e40
            snprintf((char *)&str3, 2048, "recvBuf = %s, chain = %d, asic = %d, reg = 0x%x\n", (char *)a1, v8, v9, v10);
            function_2e584(5, &str3, 0);
        }
        // 0x23e74
        if (function_2c2e8(v10, v9, v8, &delim) != 0) {
            // 0x23e90
            snprintf((char *)str2, size, "500 server error");
            // 0x23644
            __asm_vpop_18(v2, v2, v2, v2, v2);
            return 0;
        }
        int32_t v11 = function_1e120(); // 0x241f8
        if (v11 < 1) {
            // 0x23644
            __asm_vpop_18(v2, v2, v2, v2, v2);
            return 0;
        }
        int32_t v12 = 0;
        int32_t v13 = 0;
        int32_t v14 = *(int32_t *)(4 * v12 + (int32_t)&delim); // 0x24218
        int32_t v15 = v12 + 1; // 0x2422c
        int32_t v16 = snprintf((char *)(v13 + str2), size - v13, "asic\t%03d\tcore\t%03d\treg\t0x%02x\tval\t0x%08x\n", v9, v12, v10, v14) + v13; // 0x2424c
        while (v15 != v11) {
            // 0x24218
            v12 = v15;
            v13 = v16;
            v14 = *(int32_t *)(4 * v12 + (int32_t)&delim);
            v15 = v12 + 1;
            v16 = snprintf((char *)(v13 + str2), size - v13, "asic\t%03d\tcore\t%03d\treg\t0x%02x\tval\t0x%08x\n", v9, v12, v10, v14) + v13;
        }
        // 0x23644
        __asm_vpop_18(v2, v2, v2, v2, v2);
        return 0;
    }
    // 0x23b68
    if (strncmp(str, "/resetcore", 10) == 0) {
        // 0x23ea8
        delim = 45;
        if (strtok(str, (char *)&delim) == NULL) {
            // 0x23d4c
            snprintf((char *)str2, size, "404 not found");
            // 0x23644
            __asm_vpop_18(v2, v2, v2, v2, v2);
            return 0;
        }
        char * next_token7 = strtok(NULL, (char *)&delim); // 0x23ecc
        if (next_token7 == NULL) {
            // 0x23d4c
            snprintf((char *)str2, size, "404 not found");
            // 0x23644
            __asm_vpop_18(v2, v2, v2, v2, v2);
            return 0;
        }
        int32_t v17 = function_11ef8((int32_t *)next_token7, 0, 10); // 0x23ee0
        char * next_token8 = strtok(NULL, (char *)&delim); // 0x23ef0
        if (next_token8 == NULL) {
            // 0x23d4c
            snprintf((char *)str2, size, "404 not found");
            // 0x23644
            __asm_vpop_18(v2, v2, v2, v2, v2);
            return 0;
        }
        int32_t v18 = function_11ef8((int32_t *)next_token8, 0, 10); // 0x23f04
        if ((*(char *)&g60 | *(char *)&g221) == 0 != g290 < 5) {
            // 0x23f48
            snprintf((char *)&str3, 2048, "recvBuf = %s, chain = %d, asic = %d\n", (char *)a1, v17, v18);
            function_2e584(5, &str3, 0);
        }
        // 0x23f78
        snprintf((char *)str2, size, "reset chain %d asic %d core success!!!.", v17, v18);
        // 0x23644
        __asm_vpop_18(v2, v2, v2, v2, v2);
        return 0;
    }
    // 0x23b84
    if (strncmp(str, "/nonce", 6) != 0) {
        // 0x239f8
        if (strncmp(str, "/adc", 4) == 0) {
            int32_t v19 = 0;
            int32_t result = 0;
            int32_t v20 = v19; // 0x23a3c
            if (function_1e29c(result) != 0) {
                // 0x24114
                snprintf((char *)(v19 + str2), size - v19, "\t\t\td0\td1\td2\td3\tsum\tavg\n");
                v20 = v19 + 23;
                if (function_1e0f0() != 0) {
                    // 0x24138
                    function_3f92c(result, 0, 0);
                    return result;
                }
            }
            int32_t v21 = result + 1; // 0x23a40
            while (v21 != 4) {
                // 0x23a30
                v19 = v20;
                result = v21;
                v20 = v19;
                if (function_1e29c(result) != 0) {
                    // 0x24114
                    snprintf((char *)(v19 + str2), size - v19, "\t\t\td0\td1\td2\td3\tsum\tavg\n");
                    v20 = v19 + 23;
                    if (function_1e0f0() != 0) {
                        // 0x24138
                        function_3f92c(result, 0, 0);
                        return result;
                    }
                }
                // 0x23a40
                v21 = result + 1;
            }
            // 0x23644
            __asm_vpop_18(v2, v2, v2, v2, v2);
            return 0;
        }
        // 0x24088
        if (strncmp(str, "/flush", 6) == 0) {
            // 0x24254
            function_452f8();
            // 0x23644
            __asm_vpop_18(v2, v2, v2, v2, v2);
            return 0;
        }
        // 0x240a4
        if (strncmp(str, "/power", 6) != 0) {
            // 0x23644
            __asm_vpop_18(v2, v2, v2, v2, v2);
            return -1;
        }
        // 0x240c0
        str3 = 0;
        if (sscanf2(v3, "/power-%d", &str3, a4) != 1 || str3 > 3) {
            // 0x23d4c
            snprintf((char *)str2, size, "404 not found");
            // 0x23644
            __asm_vpop_18(v2, v2, v2, v2, v2);
            return 0;
        }
        // 0x240ec
        function_192c8(str3, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488);
        char * v22; // 0x23574
        __asm_vstr(v1, (int32_t)v22);
        snprintf((char *)str2, size, "chain %d power is %.2f", str3);
        // 0x23644
        __asm_vpop_18(v2, v2, v2, v2, v2);
        return 0;
    }
    // 0x23ba0
    memset(&str3, 0, 256);
    int32_t v23 = &str3;
    int32_t v24 = 0;
    int32_t v25 = 0;
    int32_t v26 = 0;
    int32_t v27 = 0;
    int32_t v28 = v27; // 0x23bfc
    int32_t v29 = v25; // 0x23bfc
    int32_t v30 = v24; // 0x23bfc
    int32_t v31; // 0x23574
    int32_t v32; // 0x23574
    int32_t v33; // 0x23574
    int32_t v34; // 0x23574
    int32_t v35; // 0x23574
    int32_t v36; // 0x23574
    int32_t v37; // 0x23574
    int32_t v38; // 0x23574
    int32_t v39; // 0x23574
    int32_t chars_printed; // 0x24000
    int32_t v40; // 0x24008
    int32_t v41; // 0x24044
    int32_t chars_printed2; // 0x2406c
    int32_t v42; // 0x23fb0
    int32_t v43; // 0x23fb8
    int32_t v44; // 0x23fd8
    int32_t v45; // 0x23fe0
    if (function_1e29c(v26) != 0) {
        // 0x23f98
        v42 = v27 + 36;
        snprintf((char *)(v27 + str2), size - v27, "\n asic nonce number for chain[%d]...\n", v26);
        v43 = function_1e0f0();
        v28 = v42;
        v29 = v25;
        v30 = v24;
        v34 = v42;
        v37 = v25;
        v31 = v24;
        if (v43 != 0) {
            v38 = v37;
            v35 = v34;
            v33 = 0;
            v44 = function_2cdfc(v26, v33) + v31;
            v45 = v33 + 1;
            chars_printed = snprintf((char *)(v38 + v23), 256 - v38, "asic[%03d]=%-8d ", v33, function_2cdfc(v26, v33));
            v40 = function_1e100();
            function_5fadc(v45, v40, (int32_t)"asic[%03d]=%-8d ", v33);
            v36 = v35;
            v39 = chars_printed + v38;
            v32 = v44;
            if (v40 == 0) {
                // 0x24024
                function_1e100();
                v41 = function_5f880();
                chars_printed2 = snprintf((char *)(v35 + str2), size - v35, "domain %02d %s total=%-8u\n", v41, &str3, v44);
                v36 = chars_printed2 + v35;
                v39 = 0;
                v32 = 0;
            }
            // 0x24078
            v28 = v36;
            v29 = v39;
            v30 = v32;
            v31 = v32;
            while (v45 != v43) {
                // 0x23fc8
                v38 = v39;
                v35 = v36;
                v33 = v45;
                v44 = function_2cdfc(v26, v33) + v31;
                v45 = v33 + 1;
                chars_printed = snprintf((char *)(v38 + v23), 256 - v38, "asic[%03d]=%-8d ", v33, function_2cdfc(v26, v33));
                v40 = function_1e100();
                function_5fadc(v45, v40, (int32_t)"asic[%03d]=%-8d ", v33);
                v36 = v35;
                v39 = chars_printed + v38;
                v32 = v44;
                if (v40 == 0) {
                    // 0x24024
                    function_1e100();
                    v41 = function_5f880();
                    chars_printed2 = snprintf((char *)(v35 + str2), size - v35, "domain %02d %s total=%-8u\n", v41, &str3, v44);
                    v36 = chars_printed2 + v35;
                    v39 = 0;
                    v32 = 0;
                }
                // 0x24078
                v28 = v36;
                v29 = v39;
                v30 = v32;
                v31 = v32;
            }
        }
    }
    int32_t v46 = v26 + 1; // 0x23c00
    while (v46 != 4) {
        // 0x23bf0
        v24 = v30;
        v25 = v29;
        v26 = v46;
        v27 = v28;
        v28 = v27;
        v29 = v25;
        v30 = v24;
        if (function_1e29c(v26) != 0) {
            // 0x23f98
            v42 = v27 + 36;
            snprintf((char *)(v27 + str2), size - v27, "\n asic nonce number for chain[%d]...\n", v26);
            v43 = function_1e0f0();
            v28 = v42;
            v29 = v25;
            v30 = v24;
            v34 = v42;
            v37 = v25;
            v31 = v24;
            if (v43 != 0) {
                v38 = v37;
                v35 = v34;
                v33 = 0;
                v44 = function_2cdfc(v26, v33) + v31;
                v45 = v33 + 1;
                chars_printed = snprintf((char *)(v38 + v23), 256 - v38, "asic[%03d]=%-8d ", v33, function_2cdfc(v26, v33));
                v40 = function_1e100();
                function_5fadc(v45, v40, (int32_t)"asic[%03d]=%-8d ", v33);
                v36 = v35;
                v39 = chars_printed + v38;
                v32 = v44;
                if (v40 == 0) {
                    // 0x24024
                    function_1e100();
                    v41 = function_5f880();
                    chars_printed2 = snprintf((char *)(v35 + str2), size - v35, "domain %02d %s total=%-8u\n", v41, &str3, v44);
                    v36 = chars_printed2 + v35;
                    v39 = 0;
                    v32 = 0;
                }
                // 0x24078
                v28 = v36;
                v29 = v39;
                v30 = v32;
                v31 = v32;
                while (v45 != v43) {
                    // 0x23fc8
                    v38 = v39;
                    v35 = v36;
                    v33 = v45;
                    v44 = function_2cdfc(v26, v33) + v31;
                    v45 = v33 + 1;
                    chars_printed = snprintf((char *)(v38 + v23), 256 - v38, "asic[%03d]=%-8d ", v33, function_2cdfc(v26, v33));
                    v40 = function_1e100();
                    function_5fadc(v45, v40, (int32_t)"asic[%03d]=%-8d ", v33);
                    v36 = v35;
                    v39 = chars_printed + v38;
                    v32 = v44;
                    if (v40 == 0) {
                        // 0x24024
                        function_1e100();
                        v41 = function_5f880();
                        chars_printed2 = snprintf((char *)(v35 + str2), size - v35, "domain %02d %s total=%-8u\n", v41, &str3, v44);
                        v36 = chars_printed2 + v35;
                        v39 = 0;
                        v32 = 0;
                    }
                    // 0x24078
                    v28 = v36;
                    v29 = v39;
                    v30 = v32;
                    v31 = v32;
                }
            }
        }
        // 0x23c00
        v46 = v26 + 1;
    }
    // 0x23644
    __asm_vpop_18(v2, v2, v2, v2, v2);
    return 0;
}

// Address range: 0x24264 - 0x24364
int32_t function_24264(int32_t str) {
    int32_t v1 = function_19ab4(); // 0x24298
    int32_t v2 = 0;
    int32_t v3 = 0;
    int32_t v4 = 0;
    int32_t v5 = v4 + 1; // 0x242a4
    int32_t v6 = v3; // 0x242b0
    int32_t v7 = v2; // 0x242b0
    int32_t v8 = str; // 0x242b0
    int32_t v9; // 0x24308
    int32_t v10; // 0x24324
    int32_t v11; // 0x24340
    if (function_1e29c(v4) != 0) {
        // 0x242f4
        v9 = sprintf((char *)str, "chain%d_voltage=%d;", v5, v1) + v3;
        v10 = v9 + sprintf((char *)(v9 + str), "chain%d_voladded=%d;", v5, 0);
        v11 = v10 + sprintf((char *)(v10 + str), "chain%d_basefreq=%d;", v5, 300);
        v6 = v11 + sprintf((char *)(v11 + str), "chain%d_badcore=%d;", v5, 0);
        v7 = v2 + 1;
        v8 = v6 + str;
    }
    int32_t str3 = v8;
    int32_t v12 = v7;
    int32_t v13 = v6;
    while (v5 != 4) {
        int32_t str2 = str3;
        v2 = v12;
        v3 = v13;
        v4 = v5;
        v5 = v4 + 1;
        v6 = v3;
        v7 = v2;
        v8 = str2;
        if (function_1e29c(v4) != 0) {
            // 0x242f4
            v9 = sprintf((char *)str2, "chain%d_voltage=%d;", v5, v1) + v3;
            v10 = v9 + sprintf((char *)(v9 + str), "chain%d_voladded=%d;", v5, 0);
            v11 = v10 + sprintf((char *)(v10 + str), "chain%d_basefreq=%d;", v5, 300);
            v6 = v11 + sprintf((char *)(v11 + str), "chain%d_badcore=%d;", v5, 0);
            v7 = v2 + 1;
            v8 = v6 + str;
        }
        // 0x242b4
        str3 = v8;
        v12 = v7;
        v13 = v6;
    }
    int32_t chars_printed = sprintf((char *)str3, "chainnum=%d;", v12); // 0x242cc
    int32_t chars_printed2 = sprintf((char *)(v13 + str + chars_printed), "version=%s;", (char *)&g386); // 0x242f0
    return chars_printed2;
}

// Address range: 0x24364 - 0x24398
int32_t function_24364(int32_t a1) {
    // 0x24364
    int32_t v1; // 0x24364
    int32_t result = function_11fc4((int32_t *)&g343, (int32_t)&g388, 0, v1); // 0x2437c
    g345 = 0x23574;
    return result;
}

// Address range: 0x24398 - 0x244a8
int32_t function_24398(int32_t a1) {
    // 0x24398
    int32_t v1; // 0x24398
    function_11eb0(1, 0x6000, v1, 3);
    int32_t v2 = 0; // bp-22604, 0x243f4
    int32_t v3 = 0xa0d0a0d; // bp-22600, 0x24408
    int32_t v4; // bp-20520, 0x24398
    memset(&v4, 0, 0x2800);
    if (g344 == 0) {
        int32_t v5 = &v4; // 0x243f0
        int32_t v6 = 0; // 0x24434
        int32_t v7; // bp-22584, 0x24398
        int32_t v8 = function_12054(a1, v5, 0x27ff - v6, 0, &v7, &v2); // 0x24420
        int32_t v9 = v5; // 0x24438
        if (v8 < 1) {
            v9 = function_245ac();
        }
        // 0x2443c
        v6 += v8;
        int32_t v10 = v9; // 0x24448
        if (v6 > 0x27fe) {
            v10 = function_24628();
        }
        // 0x2444c
        if (function_11ebc((int32_t *)v10, (int32_t)&v3, 0x27fe) != 0) {
            function_246a0();
        }
        int32_t v11 = v6 + v5; // 0x2446c
        while (g344 == 0) {
            // 0x24414
            v8 = function_12054(a1, v11, 0x27ff - v6, 0, &v7, &v2);
            v9 = v5;
            if (v8 < 1) {
                v9 = function_245ac();
            }
            // 0x2443c
            v6 += v8;
            v10 = v9;
            if (v6 > 0x27fe) {
                v10 = function_24628();
            }
            // 0x2444c
            if (function_11ebc((int32_t *)v10, (int32_t)&v3, 0x27fe) != 0) {
                function_246a0();
            }
            // 0x24458
            v11 = v6 + v5;
        }
    }
    int32_t result = a1; // 0x24494
    if (*(char *)&g221 != 0) {
        result = function_244c0();
    }
    // 0x24498
    return result;
}

// Address range: 0x244aa - 0x244b0
int32_t function_244aa(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x244aa
    return function_24ace(0);
}

// Address range: 0x244b2 - 0x244b4
int32_t function_244b2(void) {
    // 0x244b2
    return function_24b36();
}

// Address range: 0x244b4 - 0x244c0
int32_t function_244b4(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x244b4
    return result;
}

// Address range: 0x244c0 - 0x244c1
int32_t function_244c0(void) {
    // 0x244c0
    int32_t result; // 0x244c0
    return result;
}

// Address range: 0x244c2 - 0x244c4
int32_t function_244c2(void) {
    // 0x244c2
    return function_249e0();
}

// Address range: 0x244c6 - 0x244c8
int32_t function_244c6(void) {
    // 0x244c6
    int32_t v1; // 0x244c6
    return function_24ace(v1);
}

// Address range: 0x244c8 - 0x244cc
int32_t function_244c8(void) {
    // 0x244c8
    return function_2520a(6);
}

// Address range: 0x244cc - 0x244d0
int32_t function_244cc(int32_t a1) {
    // 0x244cc
    return function_24c12(a1);
}

// Address range: 0x244d2 - 0x244d4
int32_t function_244d2(int32_t a1) {
    // 0x244d2
    return function_24816(a1);
}

// Address range: 0x244d6 - 0x244d8
int32_t function_244d6(void) {
    // 0x244d6
    return function_249f4();
}

// Address range: 0x244d8 - 0x244e8
int32_t function_244d8(void) {
    // 0x244d8
    int32_t str; // 0x244d8
    snprintf((char *)str, str, (char *)str);
    return 7;
}

// Address range: 0x244ea - 0x244f0
int32_t function_244ea(int32_t result) {
    // 0x244ea
    return result;
}

// Address range: 0x244f0 - 0x2458c
int32_t function_244f0(int32_t a1, int32_t a2, int32_t a3, int32_t a4, char a5) {
    // 0x244f0
    if (a4 == 71 == a5 == 69) {
        function_24710((int32_t)&g488, (int32_t)&g488);
    }
    // 0x24504
    int32_t fd; // 0x244f0
    close(fd);
    if ((char)fd == 0) {
        function_2458c((int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488);
    }
    // 0x24518
    if ((*(char *)&g60 | *(char *)&g221) == 0 == g290 < 7) {
        function_2458c((int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488);
    }
    char * v1 = (char *)0x74617473; // bp+12352, 0x24564
    return function_2e584(7, (int32_t *)&v1, 0);
}

// Address range: 0x2458c - 0x245ac
int32_t function_2458c(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    // 0x2458c
    int32_t v1; // 0x2458c
    if (v1 != 0) {
        // 0x24594
        free(v1, v1, v1, v1);
    }
    // 0x2459c
    return 0;
}

// Address range: 0x245ac - 0x24628
int32_t function_245ac(void) {
    // 0x245ac
    int32_t fd; // 0x245ac
    close(fd);
    if (g61 == 0) {
        function_2458c((int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488);
    }
    // 0x245c8
    if ((*(char *)&g60 | *(char *)&g221) == 0) {
        function_247d0();
    }
    char * v1 = (char *)0x6174733a; // bp+12352, 0x24600
    function_2e584(7, (int32_t *)&v1, 0);
    int32_t result = function_2458c((int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488); // 0x24624
    return result;
}

// Address range: 0x24628 - 0x246a0
int32_t function_24628(void) {
    // 0x24628
    int32_t fd; // 0x24628
    close(fd);
    if (g61 == 0) {
        function_2458c((int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488);
    }
    // 0x24644
    if ((*(char *)&g60 | *(char *)&g221) == 0) {
        function_247e8();
    }
    char * v1 = (char *)0x53465542; // bp+12352, 0x2467c
    function_2e584(7, (int32_t *)&v1, 0);
    int32_t result = function_2458c((int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488); // 0x2469c
    return result;
}

// Address range: 0x246a0 - 0x24710
int32_t function_246a0(void) {
    // 0x246a0
    if ((*(char *)&g60 | *(char *)&g221) == 0) {
        function_24800();
    }
    char * v1 = (char *)0x646e6966; // bp+12352, 0x246f0
    return function_2e584(7, (int32_t *)&v1, 0);
}

// Address range: 0x24710 - 0x24720
int32_t function_24710(int32_t a1, int32_t a2) {
    // 0x24710
    int32_t result; // 0x24710
    return result;
}

// Address range: 0x24722 - 0x24724
int32_t function_24722(int32_t a1) {
    // 0x24722
    int32_t v1; // 0x24722
    return function_24dcc(v1);
}

// Address range: 0x24724 - 0x247c4
int32_t function_24724(void) {
    // 0x24724
    int32_t v1; // bp+40, 0x24724
    int32_t fd; // 0x24724
    if (function_11f1c(fd, 1, 21, &v1, 8) == 0) {
        function_24818();
    }
    // 0x2474c
    close(fd);
    if ((char)fd == 0) {
        function_2458c((int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488);
    }
    // 0x24760
    if ((*(char *)&g60 | *(char *)&g221) == 0 == g290 < 7) {
        function_2458c((int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488);
    }
    // 0x2479c
    return 7;
}

// Address range: 0x247c6 - 0x247c8
int32_t function_247c6(int32_t a1) {
    // 0x247c6
    return function_24dcc(a1);
}

// Address range: 0x247c8 - 0x247d0
int32_t function_247c8(void) {
    // 0x247c8
    int32_t v1; // 0x247c8
    function_2e584(v1, (int32_t *)v1, v1);
    int32_t result = function_2458c((int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488); // 0x247cc
    return result;
}

// Address range: 0x247d0 - 0x247e8
int32_t function_247d0(void) {
    // 0x247d0
    int32_t result; // 0x247d0
    if (g290 < 7) {
        int32_t v1 = function_2458c((int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488); // 0x247e0
        result = v1;
    }
    // 0x247e4
    return result;
}

// Address range: 0x247e8 - 0x24800
int32_t function_247e8(void) {
    // 0x247e8
    int32_t result; // 0x247e8
    if (g290 < 7) {
        int32_t v1 = function_2458c((int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488); // 0x247f8
        result = v1;
    }
    // 0x247fc
    return result;
}

// Address range: 0x24800 - 0x24814
int32_t function_24800(void) {
    // 0x24800
    int32_t result; // 0x24800
    return result;
}

// Address range: 0x24816 - 0x24817
int32_t function_24816(int32_t a1) {
    // 0x24816
    int32_t result; // 0x24816
    return result;
}

// Address range: 0x24818 - 0x248ac
int32_t function_24818(void) {
    // 0x24818
    int32_t v1; // bp+40, 0x24818
    int32_t str; // 0x24818
    if (function_11f1c(str, 1, 20, &v1, str) != 0) {
        function_24d2c();
    }
    // 0x24838
    if (*(int32_t *)(str + 4) == 0) {
        function_24e20();
    }
    // 0x24844
    function_24d98();
    strlen((char *)str);
    int32_t str2; // bp+12352, 0x24818
    int32_t v2; // bp+24, 0x24818
    int32_t chars_printed = sprintf((char *)&str2, "HTTP/1.0  200  OK%s", &v2); // 0x24880
    int32_t str3 = chars_printed + (int32_t)&str2;
    return str3 + sprintf((char *)str3, "Server: SearchFreqServer%s", &v2);
}

// Address range: 0x248ae - 0x248b0
int32_t function_248ae(int32_t a1) {
    // 0x248ae
    return function_24f32(a1);
}

// Address range: 0x248b0 - 0x248bc
int32_t function_248b0(void) {
    // 0x248b0
    int32_t str; // 0x248b0
    return sprintf((char *)str, (char *)str);
}

// Address range: 0x248be - 0x248c0
int32_t function_248be(void) {
    // 0x248be
    int32_t result; // 0x248be
    return result;
}

// Address range: 0x248c0 - 0x2499c
int32_t function_248c0(int32_t str, uint32_t a2) {
    // 0x248c0
    int32_t str4; // 0x248c0
    int32_t str2 = sprintf((char *)str, (char *)(a2 % 0x10000 | 0x60000)) + str4 + str4;
    int32_t v1; // bp+24, 0x248c0
    int32_t str3 = str2 + sprintf((char *)str2, "Content-Type: text/plain%s", &v1);
    int32_t chars_printed = sprintf((char *)str3, "Content-Length: %d%s", str4, &v1); // 0x248fc
    int32_t v2; // bp+32, 0x248c0
    sprintf((char *)(str3 + chars_printed), "Connection: Keep-Alive%s", &v2);
    if ((char)str4 == 0) {
        function_24d88();
    }
    // 0x24924
    if (*(char *)&g221 != 0) {
        function_24a7c();
    }
    // 0x24938
    if (*(char *)&g60 != 0) {
        function_24a7c();
    }
    // 0x2494c
    if (g290 > 6) {
        function_24a7c();
    }
    if ((char)str4 != 0) {
        function_24ea0();
    }
    // 0x2496c
    return function_249c4(strlen((char *)str4));
}

// Address range: 0x2499c - 0x249c4
int32_t function_2499c(int32_t a1) {
    int32_t v1 = a1; // 0x249a0
    if (a1 < 1) {
        v1 = function_249f0();
    }
    // 0x249a4
    int32_t str; // 0x2499c
    uint32_t v2 = v1 + str; // 0x249a4
    int32_t len = strlen((char *)str); // 0x249ac
    int32_t result = len; // 0x249b4
    if (len == v2 || len < v2) {
        result = function_24ac0();
    }
    // 0x249b8
    return result;
}

// Address range: 0x249c4 - 0x249d4
int32_t function_249c4(int32_t a1) {
    // 0x249c4
    int32_t result; // 0x249c4
    return result;
}

// Address range: 0x249d8 - 0x249e0
int32_t function_249d8(int32_t result) {
    // 0x249d8
    return result;
}

// Address range: 0x249e0 - 0x249e1
int32_t function_249e0(void) {
    // 0x249e0
    int32_t result; // 0x249e0
    return result;
}

// Address range: 0x249e4 - 0x249f0
int32_t function_249e4(int32_t result) {
    // 0x249e4
    return result;
}

// Address range: 0x249f0 - 0x249f4
int32_t function_249f0(void) {
    // 0x249f0
    int32_t result; // 0x249f0
    return result;
}

// Address range: 0x249f4 - 0x249f5
int32_t function_249f4(void) {
    // 0x249f4
    int32_t result; // 0x249f4
    return result;
}

// Address range: 0x249f6 - 0x24a30
int32_t function_249f6(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = a1; // 0x249f6
    bool v2; // 0x249f6
    if (!v2) {
        *(int32_t *)(a1 + 4) = 0x249fc;
        v1 = a1 - (int32_t)&g16;
    }
    int32_t v3; // 0x249f6
    if (v2) {
        return v1 - v3;
    }
    // 0x249fe
    __asm_mcr2(3, 7, v3, 3, 3, 2);
    if (v2) {
        // 0x24a2e
        return function_2504e();
    }
    // .critedge
    *(int32_t *)v3 = v1;
    uint32_t v4 = 64 * v1; // 0x24a06
    if (v3 == v4) {
        return v1 - a4;
    }
    if ((v1 & 32) != 0 || v3 >= v4) {
        // 0x24a2e
        return function_2504e();
    }
    // 0x24a26
    if ((function_172b21e() & 32 || a3 & 0x4000000) == 0) {
        function_fe82b232();
    }
    // 0x24a2e
    return function_2504e();
}

// Address range: 0x24a30 - 0x24a7c
int32_t function_24a30(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    char * v1 = (char *)0x74617473; // bp+64, 0x24a50
    return function_2e584(7, (int32_t *)&v1, 0);
}

// Address range: 0x24a7c - 0x24acc
int32_t function_24a7c(void) {
    char * v1 = (char *)0x646e6573; // bp+64, 0x24a8c
    return function_2e584(7, (int32_t *)&v1, 0);
}

// Address range: 0x24ac0 - 0x24ac1
int32_t function_24ac0(void) {
    // 0x24ac0
    int32_t result; // 0x24ac0
    return result;
}

// Address range: 0x24ace - 0x24ad8
int32_t function_24ace(int32_t a1) {
    // 0x24ace
    return function_250de();
}

// Address range: 0x24ad8 - 0x24af4
int32_t function_24ad8(int32_t a1, int32_t a2, int32_t a3, uint32_t a4) {
    // 0x24ad8
    return function_24b10(a4 % 0x10000 | (int32_t)&g51);
}

// Address range: 0x24af4 - 0x24b10
int32_t function_24af4(int32_t a1) {
    // 0x24af4
    int32_t result; // 0x24af4
    return result;
}

// Address range: 0x24b10 - 0x24b34
int32_t function_24b10(int32_t a1) {
    // 0x24b10
    int32_t sock; // 0x24b10
    int32_t v1 = sock;
    return send(sock, (int32_t *)(sock + v1), a1 - v1, 0);
}

// Address range: 0x24b36 - 0x24b38
int32_t function_24b36(void) {
    // 0x24b36
    int32_t v1; // 0x24b36
    return function_25054(v1, v1);
}

// Address range: 0x24b38 - 0x24b4c
int32_t function_24b38(void) {
    // 0x24b38
    int32_t result; // 0x24b38
    int32_t v1; // 0x24b38
    if (v1 == 0) {
        result = function_24b8c();
    }
    // 0x24b48
    return result;
}

// Address range: 0x24b4e - 0x24b50
int32_t function_24b4e(int32_t a1) {
    // 0x24b4e
    return function_2520a(a1);
}

// Address range: 0x24b50 - 0x24b60
int32_t function_24b50(int32_t a1) {
    // 0x24b50
    int32_t result; // 0x24b50
    return result;
}

// Address range: 0x24b60 - 0x24b62
int32_t function_24b60(void) {
    // 0x24b60
    int32_t v1; // 0x24b60
    return function_24b64(v1);
}

// Address range: 0x24b62 - 0x24b64
int32_t function_24b62(int32_t a1) {
    // 0x24b62
    return function_24dcc(a1);
}

// Address range: 0x24b64 - 0x24b68
int32_t function_24b64(int32_t a1) {
    // 0x24b64
    return function_25226();
}

// Address range: 0x24b68 - 0x24b74
int32_t function_24b68(void) {
    // 0x24b68
    int32_t result; // 0x24b68
    return result;
}

// Address range: 0x24b74 - 0x24b7a
int32_t function_24b74(int32_t result) {
    // 0x24b74
    return result;
}

// Address range: 0x24b7c - 0x24b8c
int32_t function_24b7c(void) {
    // 0x24b7c
    int32_t v1; // bp+64, 0x24b7c
    return function_2e584(7, &v1, 0);
}

// Address range: 0x24b8c - 0x24c10
int32_t function_24b8c(void) {
    // 0x24b8c
    int32_t v1; // 0x24b8c
    if (v1 > 0) {
        function_24af4((int32_t)&g488);
    }
    if ((char)v1 == 0) {
        function_24c8c();
    }
    // 0x24ba0
    if ((*(char *)&g60 | *(char *)&g221) == 0 == g290 < 7) {
        function_24c3c();
    }
    // 0x24bdc
    return 7;
}

// Address range: 0x24c12 - 0x24c18
int32_t function_24c12(int32_t a1) {
    // 0x24c12
    return function_24dcc(0x1001 * a1);
}

// Address range: 0x24c18 - 0x24c3c
int32_t function_24c18(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t result = a1; // 0x24c1c
    if (a4 == 0) {
        result = function_24c8c();
    }
    // 0x24c20
    return result;
}

// Address range: 0x24c3c - 0x24c8c
int32_t function_24c3c(void) {
    // 0x24c3c
    int32_t v1; // 0x24c3c
    if ((char)v1 == 0 == g290 < 7) {
        function_24c8c();
    }
    char * v2 = (char *)0x20656e6f; // bp+64, 0x24c6c
    return function_2e584(7, (int32_t *)&v2, 0);
}

// Address range: 0x24c8c - 0x24ca4
int32_t function_24c8c(void) {
    // 0x24c8c
    int32_t fd; // 0x24c8c
    close(fd);
    free(fd, fd, fd, fd);
    return fd;
}

// Address range: 0x24ca4 - 0x24d2c
int32_t function_24ca4(int32_t a1, int32_t a2) {
    // 0x24ca4
    int32_t usec; // 0x24ca4
    if ((char)usec == 0) {
        // 0x24d20
        return usleep(usec);
    }
    // 0x24cb0
    char * v1; // bp+64, 0x24ca4
    if (*(char *)a1 != 0) {
        // 0x24ce4
        v1 = (char *)0x74617473;
        function_2e584(7, (int32_t *)&v1, 0);
        // 0x24d20
        return usleep(usec);
    }
    // 0x24cc0
    if (*(char *)a2 == 0 == g290 < 7) {
        // 0x24d20
        return usleep(usec);
    }
    // 0x24ce4
    v1 = (char *)0x74617473;
    function_2e584(7, (int32_t *)&v1, 0);
    // 0x24d20
    return usleep(usec);
}

// Address range: 0x24d2c - 0x24d88
int32_t function_24d2c(void) {
    // 0x24d2c
    int32_t fd; // 0x24d2c
    int32_t v1 = close(fd); // 0x24d3c
    if ((char)fd == 0) {
        v1 = function_2458c((int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488);
    }
    int32_t result = v1; // 0x24d50
    if ((*(char *)&g60 | *(char *)&g221) == 0 == g290 < 7) {
        result = function_2458c((int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488);
    }
    // 0x24d7c
    return result;
}

// Address range: 0x24d88 - 0x24d98
int32_t function_24d88(void) {
    // 0x24d88
    int32_t result; // 0x24d88
    return result;
}

// Address range: 0x24d98 - 0x24dcc
int32_t function_24d98(void) {
    // 0x24d98
    int32_t fd; // 0x24d98
    int32_t v1 = close(fd); // 0x24da8
    if ((char)fd == 0) {
        v1 = function_2458c((int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488);
    }
    int32_t result = v1; // 0x24dbc
    if (*(char *)&g221 != 0) {
        result = function_24de8();
    }
    // 0x24dc0
    return result;
}

// Address range: 0x24dcc - 0x24dd0
int32_t function_24dcc(int32_t result) {
    // 0x24dcc
    return result;
}

// Address range: 0x24dd0 - 0x24de8
int32_t function_24dd0(void) {
    // 0x24dd0
    int32_t result; // 0x24dd0
    bool v1; // 0x24dd0
    if (!v1) {
        result = function_24de8();
    }
    // 0x24dd4
    return result;
}

// Address range: 0x24de8 - 0x24e20
int32_t function_24de8(void) {
    char * v1 = (char *)0x74617473; // bp+12352, 0x24df8
    function_2e584(7, (int32_t *)&v1, 0);
    int32_t result = function_2458c((int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488); // 0x24e1c
    return result;
}

// Address range: 0x24e20 - 0x24ea0
int32_t function_24e20(void) {
    char * v1 = (char *)0x36206f4e; // bp+12352, 0x24e7c
    return function_2e584(7, (int32_t *)&v1, 0);
}

// Address range: 0x24ea0 - 0x24f04
int32_t function_24ea0(void) {
    char * v1 = (char *)0x646e6573; // bp+64, 0x24ee8
    return function_2e584(7, (int32_t *)&v1, 0);
}

// Address range: 0x24f06 - 0x24f24
int32_t function_24f06(int32_t result, int32_t a2, int32_t a3) {
    // 0x24f06
    int32_t v1; // 0x24f06
    uint32_t v2 = v1;
    bool v3 = false; // 0x24f06
    bool v4; // 0x24f06
    bool v5; // 0x24f06
    bool v6; // 0x24f06
    bool v7; // 0x24f06
    bool v8; // 0x24f06
    int32_t v9; // 0x24f06
    bool v10; // 0x24f06
    if (v10) {
        uint32_t v11 = (int32_t)&g467 - v2; // 0x24f06
        int32_t v12 = !v10; // 0x24f06
        int32_t v13 = v11 - v12; // 0x24f06
        uint32_t v14 = v13 - v12; // 0x24f06
        bool v15 = !v10 ? v2 != -1 | v14 > (int32_t)&g467 : v2 > 0xb4000; // 0x24f06
        v9 = v13;
        v4 = !v10;
        v5 = v11 % 2 != 0;
        v7 = v13 < 0;
        v8 = v13 == 0;
        v6 = !v15;
        v3 = (v14 & (v2 ^ (int32_t)&g467)) < 0;
    }
    if (v5 <= v4) {
        __asm_cdple(3, 8, 14, 3, 14, 0);
    }
    if (v6 == !v8) {
        *(int32_t *)v1 = v9;
    }
    if (!v7) {
        // 0x24f22
        return result;
    }
    int32_t result2 = function_175dda2(); // 0x24f1e
    if (v8 || v6 != v3) {
        result2 = function_fe85db2e();
    }
    // 0x24f22
    return result2;
}

// Address range: 0x24f24 - 0x24f28
int32_t function_24f24(int32_t result) {
    // 0x24f24
    return result;
}

// Address range: 0x24f28 - 0x24f2c
int32_t function_24f28(void) {
    // 0x24f28
    int32_t result; // 0x24f28
    bool v1; // 0x24f28
    if (v1) {
        int32_t v2; // 0x24f28
        result = function_24f34(v2, v2, v2, v2);
    }
    // 0x24f2a
    return result;
}

// Address range: 0x24f2c - 0x24f30
int32_t function_24f2c(int32_t result, int32_t a2) {
    // 0x24f2c
    return result;
}

// Address range: 0x24f32 - 0x24f34
int32_t function_24f32(int32_t a1) {
    // 0x24f32
    int32_t result; // 0x24f32
    return result;
}

// Address range: 0x24f34 - 0x24f38
int32_t function_24f34(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x24f34
    *(int16_t *)(a4 + 2) = (int16_t)a2;
    return result;
}

// Address range: 0x24f38 - 0x25038
int32_t function_24f38(int32_t a1, uint32_t a2, int32_t a3, int32_t a4) {
    // 0x24f38
    prctl(PR_SET_NAME, a2 % 0x10000 | 0x60000, a4, a4, a4);
    int32_t sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); // 0x24f68
    int32_t sock2; // 0x24f38
    *(int32_t *)sock2 = sock_fd;
    int32_t sock = sock_fd; // 0x24f74
    if (sock_fd < 0) {
        sock = function_25104();
    }
    int32_t addr = (uint32_t)sock2 % 0x10000 | -0x53e90000; // bp+16, 0x24f94
    if (bind(sock, (struct sockaddr *)&addr, 16) < 0) {
        function_25174();
    }
    // 0x24fa8
    if (listen(sock2, 100) < 0) {
        function_25214();
    }
    // 0x24fbc
    int32_t v1; // 0x24f38
    if ((*(char *)&g60 | *(char *)&v1) == 0) {
        function_251ec();
    }
    char * v2 = (char *)0x72617473; // bp+48, 0x24fec
    function_2e584(5, (int32_t *)&v2, 0);
    if (*(char *)(sock2 % 0x10000 || 0x70000) != 0) {
        function_250e4((int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488);
    }
    // 0x25018
    return function_25040();
}

// Address range: 0x25038 - 0x25040
int32_t function_25038(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x25038
    return result;
}

// Address range: 0x25040 - 0x2504c
int32_t function_25040(void) {
    // 0x25040
    return usleep(0x2710);
}

// Address range: 0x2504e - 0x25050
int32_t function_2504e(void) {
    // 0x2504e
    int32_t result; // 0x2504e
    return result;
}

// Address range: 0x25050 - 0x25054
int32_t function_25050(int32_t result) {
    // 0x25050
    return result;
}

// Address range: 0x25054 - 0x25058
int32_t function_25054(int32_t a1, int32_t a2) {
    // 0x25054
    int32_t v1; // 0x25054
    *(char *)a2 = (char)v1;
    return function_24b74(a1);
}

// Address range: 0x25058 - 0x250dc
int32_t function_25058(void) {
    // 0x25058
    int32_t sock; // 0x25058
    int32_t accepted_sock_fd = accept(sock, (struct sockaddr *)sock, (int32_t *)sock); // 0x25058
    if (accepted_sock_fd == -1) {
        function_25038(-1, sock, sock, sock % 256);
    }
    if ((char)sock != 0) {
        function_2527c();
    }
    if ((char)sock == 0) {
        // 0x250d0
        return function_24398(accepted_sock_fd);
    }
    int32_t str; // bp+48, 0x25058
    if ((char)sock != 0) {
        // 0x250ac
        snprintf((char *)&str, 2048, (char *)sock);
        function_2e584(7, &str, 0);
        // 0x250d0
        return function_24398(accepted_sock_fd);
    }
    // 0x2508c
    if ((char)sock == 0 == g290 < 7) {
        // 0x250d0
        return function_24398(accepted_sock_fd);
    }
    // 0x250ac
    snprintf((char *)&str, 2048, (char *)sock);
    function_2e584(7, &str, 0);
    // 0x250d0
    return function_24398(accepted_sock_fd);
}

// Address range: 0x250de - 0x250e0
int32_t function_250de(void) {
    // 0x250de
    int32_t result; // 0x250de
    return result;
}

// Address range: 0x250e0 - 0x250e4
int32_t function_250e0(void) {
    // 0x250e0
    int32_t result; // 0x250e0
    return result;
}

// Address range: 0x250e4 - 0x25104
int32_t function_250e4(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    // 0x250e4
    int32_t fd; // 0x250e4
    close(fd);
    *(int32_t *)fd = -1;
    return 0;
}

// Address range: 0x25104 - 0x25174
int32_t function_25104(void) {
    // 0x25104
    int32_t v1; // 0x25104
    if ((char)(v1 || v1) == 0) {
        function_25204();
    }
    char * v2 = (char *)0x6b636f73; // bp+48, 0x2512c
    function_2e584(5, (int32_t *)&v2, 0);
    return function_12030(10);
}

// Address range: 0x25174 - 0x251ec
int32_t function_25174(void) {
    // 0x25174
    int32_t fd; // 0x25174
    if ((char)fd == 0) {
        if (fd < 5 == (char)fd == 0) {
            // 0x251d0
            close(fd);
            *(int32_t *)fd = -1;
            return function_12030(10);
        }
    }
    char * v1 = (char *)0x70747468; // bp+48, 0x251a8
    function_2e584(5, (int32_t *)&v1, 0);
    // 0x251d0
    close(fd);
    *(int32_t *)fd = -1;
    return function_12030(10);
}

// Address range: 0x251ec - 0x25204
int32_t function_251ec(void) {
    // 0x251ec
    int32_t result; // 0x251ec
    return result;
}

// Address range: 0x25204 - 0x25208
int32_t function_25204(void) {
    // 0x25204
    int32_t result; // 0x25204
    return result;
}

// Address range: 0x2520a - 0x2520c
int32_t function_2520a(int32_t a1) {
    // 0x2520a
    int32_t result; // 0x2520a
    return result;
}

// Address range: 0x2520c - 0x25214
int32_t function_2520c(void) {
    // 0x2520c
    int32_t result; // 0x2520c
    return result;
}

// Address range: 0x25214 - 0x25224
int32_t function_25214(void) {
    // 0x25214
    int32_t result; // 0x25214
    int32_t v1; // 0x25214
    if ((char)v1 != 0) {
        result = function_25238();
    }
    // 0x25220
    return result;
}

// Address range: 0x25226 - 0x25228
int32_t function_25226(void) {
    // 0x25226
    int32_t result; // 0x25226
    return result;
}

// Address range: 0x25228 - 0x25238
int32_t function_25228(void) {
    // 0x25228
    int32_t result; // 0x25228
    bool v1; // 0x25228
    if (!v1) {
        result = function_25238();
    }
    // 0x2522c
    return result;
}

// Address range: 0x25238 - 0x2527c
int32_t function_25238(void) {
    char * v1 = (char *)0x70747468; // bp+48, 0x25248
    return function_2e584(5, (int32_t *)&v1, 0);
}

// Address range: 0x2527c - 0x25284
int32_t function_2527c(void) {
    // 0x2527c
    int32_t fd; // 0x2527c
    close(fd);
    int32_t result = function_250e4((int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488); // 0x25280
    return result;
}

// Address range: 0x25284 - 0x253a0
int32_t function_25284(void) {
    // 0x25284
    char * str; // bp-2056, 0x25284
    if ((*(char *)&g60 | *(char *)&g221) == 0 != g290 < 5) {
        // 0x252b8
        str = (char *)0x72617473;
        function_2e584(5, (int32_t *)&str, 0);
    }
    // 0x252e8
    int32_t attr; // bp-2092, 0x25284
    pthread_attr_init(&attr);
    function_12024(&attr, &g8);
    int32_t thread; // bp-2096, 0x25284
    int32_t result = pthread_create(&thread, &attr, (int32_t * (*)(int32_t *))0x24f04, NULL); // 0x25310
    if ((*(char *)&g60 | *(char *)&g221) != 0 || g290 > 4) {
        // 0x25334
        snprintf((char *)&str, 2048, "httpListenThread start ret=%d", result);
        return function_2e584(5, (int32_t *)&str, 0);
    }
    // 0x2537c
    return result;
}

// Address range: 0x253a0 - 0x258c8
int32_t function_253a0(int32_t * str) {
    // 0x253a0
    int32_t str4; // bp-4120, 0x253a0
    memset(&str4, 0, 0x1000);
    int32_t str3; // bp-8216, 0x253a0
    memset(&str3, 0, 1024);
    int32_t v1; // bp-7192, 0x253a0
    memset(&v1, 0, 1024);
    char * addr; // bp-6168, 0x253a0
    if (str == NULL) {
        // 0x25624
        if ((*(char *)&g60 | *(char *)&g221) == 0 != g290 < 5) {
            // 0x25660
            addr = (char *)0x206c7275;
            function_2e584(5, (int32_t *)&addr, 0);
        }
        // 0x2568c
        return 0;
    }
    // 0x253ec
    if (strncmp((char *)str, "http://", 7) != 0) {
        // 0x2569c
        if ((*(char *)&g60 | *(char *)&g221) != 0 || g290 > 4) {
            // 0x256ec
            addr = (char *)0x73726170;
            function_2e584(5, (int32_t *)&addr, 0);
            return 0;
        }
        // 0x2568c
        return 0;
    }
    int32_t v2 = (int32_t)str + 7; // 0x25408
    char * str2 = (char *)v2; // 0x25414
    char * found_char_pos = strchr(str2, 47); // 0x25414
    int32_t v3 = (int32_t)found_char_pos; // 0x25414
    int32_t len = strlen(str2); // 0x25420
    int32_t v4; // 0x253a0
    if (found_char_pos == NULL) {
        // 0x25734
        function_11fc4(&str3, v2, (char)len, v4);
        *(char *)(len + (int32_t)&str3) = (char)v3;
    } else {
        int32_t len2 = strlen(found_char_pos); // 0x25434
        int32_t v5 = len - len2; // 0x25440
        function_11fc4(&str3, v2, (char)v5, v4);
        int32_t v6 = v3 + 1; // 0x25450
        unsigned char v7 = *(char *)v6; // 0x25450
        *(char *)(v5 + (int32_t)&str3) = 0;
        if (v7 != 0) {
            // 0x257c4
            function_11fc4(&v1, v6, (char)len2 - 1, (int32_t)v7);
            int32_t v8; // bp-7193, 0x253a0
            *(char *)(len2 + (int32_t)&v8) = 0;
        }
    }
    char * found_char_pos2 = strchr((char *)&str3, 58); // 0x2546c
    int32_t v9 = 80; // 0x25478
    if (found_char_pos2 != NULL) {
        // 0x2547c
        *found_char_pos2 = 0;
        v9 = function_11ef8((int32_t *)((int32_t)found_char_pos2 + 1), 0, 10);
    }
    // 0x25490
    if (gethostbyname((char *)&str3) != NULL) {
        // 0x254a0
        __asm_rev16(v9);
        addr = (char *)2;
        int32_t sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP); // 0x254cc
        if (sock_fd != -1) {
            int32_t v10 = 10; // bp-8224, 0x254e8
            if (function_11f1c(sock_fd, 1, 21, &v10, 8) == 0) {
                // 0x2550c
                if (function_11f1c(sock_fd, 1, 20, &v10, 8) == 0) {
                    // 0x2552c
                    if (!((sock_fd < 0 | connect(sock_fd, (struct sockaddr *)&addr, 16) == -1))) {
                        // 0x2554c
                        sprintf((char *)&str4, "GET /%s HTTP/1.1\r\nHOST: %s:%d\r\nAccept: */*\r\n\r\n", &v1, &str3, v9);
                        uint32_t len3 = strlen((char *)&str4); // 0x25574
                        int32_t v11; // 0x253a0
                        if (len3 == 0) {
                          lab_0x257e4:
                            // 0x257e4
                            if (recv(sock_fd, &str4, 0x1000, 0) > 0) {
                                // 0x25850
                                close(sock_fd);
                                int32_t v12 = function_11ebc(&str4, (int32_t)"HTTP/1.1", 0x1000); // 0x25868
                                if (v12 == 0 || function_11ef8((int32_t *)(v12 + 9), 0, 10) != 200) {
                                    // 0x2568c
                                    return 0;
                                }
                                int32_t str5 = function_11ebc(&str4, (int32_t)"\r\n\r\n", 10); // 0x2589c
                                if (str5 == 0) {
                                    // 0x2568c
                                    return 0;
                                }
                                int32_t * mem = malloc(strlen((char *)str5) + 1); // 0x258b0
                                if (mem != NULL) {
                                    // 0x258bc
                                    strcpy((char *)mem, (char *)(str5 + 4));
                                }
                                // 0x2568c
                                return (int32_t)mem;
                            }
                            // 0x25804
                            v11 = (int32_t)"tcp client recv failed\n";
                            if ((*(char *)&g60 | *(char *)&g221) == 0 == g290 < 5) {
                                // 0x2568c
                                return 0;
                            }
                        } else {
                            int32_t v13 = &str4; // 0x25594
                            int32_t v14 = 0;
                            int32_t v15 = send(sock_fd, (int32_t *)(v14 + v13), len3 - v14, 0); // 0x255a4
                            while (v15 != -1) {
                                int32_t v16 = v15 + v14; // 0x255ac
                                if (len3 <= v16) {
                                    goto lab_0x257e4;
                                }
                                v14 = v16;
                                v15 = send(sock_fd, (int32_t *)(v14 + v13), len3 - v14, 0);
                            }
                            // 0x255b4
                            v11 = (int32_t)"tcp client send failed\n";
                            if ((*(char *)&g60 | *(char *)&g221) == 0 == g290 < 5) {
                                // 0x2568c
                                return 0;
                            }
                        }
                        // 0x255fc
                        addr = (char *)*(int32_t *)v11;
                        function_2e584(5, (int32_t *)&addr, 0);
                        // 0x2568c
                        return 0;
                    }
                }
            }
        }
    }
    // 0x25750
    if ((*(char *)&g60 | *(char *)&g221) == 0 != g290 < 5) {
        // 0x2578c
        addr = (char *)0x20706374;
        function_2e584(5, (int32_t *)&addr, 0);
    }
    // 0x2568c
    return 0;
}

// Address range: 0x258c8 - 0x259a4
int32_t function_258c8(int32_t * str) {
    int32_t sock_fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_IP); // 0x258e0
    if (sock_fd < 0) {
        // 0x25990
        return -1;
    }
    int32_t result = -1; // 0x2590c
    if (ioctl(sock_fd, 0x8912) == 0) {
        int32_t v1 = -1;
        int32_t v2; // bp-544, 0x258c8
        int32_t v3 = (int32_t)&v2 + 480;
        int32_t v4 = 15;
        int32_t v5 = v1; // 0x25954
        int32_t str2; // 0x2595c
        if (ioctl(sock_fd, 0x8915) == 0) {
            // 0x25958
            str2 = function_12018(*(int32_t *)(v3 + 20));
            v5 = v1;
            if (str2 != 0) {
                // 0x2596c
                strcpy((char *)str, (char *)str2);
                v5 = 0;
                if (function_11eec((int32_t)"127.0.0.1", (char *)str, v3, 15) != 0) {
                    // break -> 0x25988
                    break;
                }
            }
        }
        int32_t v6 = v5;
        int32_t v7 = v4 - 1; // 0x25948
        int32_t v8 = v3 - 32; // 0x25948
        result = v6;
        while (v4 != 0) {
            // 0x2594c
            v1 = v6;
            v3 = v8;
            v4 = v7;
            v5 = v1;
            if (ioctl(sock_fd, 0x8915) == 0) {
                // 0x25958
                str2 = function_12018(*(int32_t *)(v3 + 20));
                v5 = v1;
                if (str2 != 0) {
                    // 0x2596c
                    strcpy((char *)str, (char *)str2);
                    v5 = 0;
                    result = 0;
                    if (function_11eec((int32_t)"127.0.0.1", (char *)str, v3, 15) != 0) {
                        // break -> 0x25988
                        break;
                    }
                }
            }
            // 0x25930
            v6 = v5;
            v7 = v4 - 1;
            v8 = v3 - 32;
            result = v6;
        }
    }
    // 0x25988
    close(sock_fd);
    // 0x25990
    return result;
}

// Address range: 0x259a4 - 0x259aa
int32_t function_259a4(int32_t result) {
    // 0x259a4
    return result;
}

// Address range: 0x259aa - 0x25a20
int32_t function_259aa(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x259aa
    bool v1; // 0x259aa
    bool v2 = v1;
    int32_t v3 = a1; // 0x259ae
    int32_t v4; // 0x259aa
    if ((v2 ? (v4 & 0x20000) != 0 : v1) == !v2) {
        v3 = function_1de836();
    }
    bool v5 = true; // 0x259b2
    bool v6; // 0x259aa
    bool v7; // 0x259aa
    bool v8; // 0x259aa
    bool v9; // 0x259aa
    bool v10; // 0x259aa
    int32_t v11; // 0x259aa
    if (v2) {
        goto lab__thread;
    } else {
        int32_t v12 = v4 / 0x4000000 ^ v4; // 0x259b2
        v5 = v12 == 0;
        v7 = v12 < 0;
        if (v12 == 0 || v12 < 0 != v1) {
            goto lab__thread;
        } else {
            v9 = false;
            if (v1) {
                // 0x259c2
                v10 = false;
                v8 = true;
                v11 = v3;
                v6 = (v4 & 0x200000) != 0;
                goto lab__thread18_thread;
            } else {
                goto lab_dec_label_pc_unknown_9;
            }
        }
    }
  lab__thread:
    // .thread
    __asm_cdple(3, 8, 14, 2, 3, 0);
    v9 = v5;
    bool v13 = true; // 0x259ba
    bool v14 = v5; // 0x259ba
    int32_t v15 = v3; // 0x259ba
    if (v7) {
        goto lab_0x259be;
    } else {
        goto lab_dec_label_pc_unknown_9;
    }
  lab_0x259be:;
    // 0x259be
    int32_t v16; // 0x259aa
    if (v1) {
        // 0x259c2
        v16 = v15;
        v10 = false;
        v8 = v13;
        v11 = v15;
        v6 = (v4 & 0x200000) != 0;
        if (v14) {
            goto lab_dec_label_pc_unknown_10;
        } else {
            goto lab__thread18_thread;
        }
    } else {
        int32_t v17 = function_fe35e5fe(); // 0x259be
        v16 = v17;
        v10 = false;
        v8 = v13;
        v11 = v17;
        v6 = (v4 & 0x200000) != 0;
        if (v14) {
            goto lab_dec_label_pc_unknown_10;
        } else {
            goto lab__thread18_thread;
        }
    }
  lab_dec_label_pc_unknown_9:
    v13 = false;
    v14 = v9;
    v15 = function_fe75e2f6();
    goto lab_0x259be;
  lab_dec_label_pc_unknown_10:;
    int32_t v18 = v16;
    bool v19 = (v4 & 0x200000) != 0;
    v10 = false;
    v8 = false;
    v11 = v18;
    v6 = v19;
    if ((v18 / 8 & v18) == 0) {
        int32_t v20 = 2048 * v4 & v4; // 0x259d6
        v10 = false;
        v8 = v20 < 0;
        v11 = v18;
        v6 = v19;
        if (v20 == 0) {
            int32_t v21 = v18 >> 6;
            int32_t v22 = v21 & v4; // 0x259de
            v10 = false;
            v8 = v22 < 0;
            v11 = v18;
            v6 = v22 < 0 ? (v18 & 32) != 0 : v19;
            if (v22 == 0) {
                int32_t v23 = v21 & v4; // 0x259e6
                v10 = v23 == 0;
                v8 = v23 < 0;
                v11 = v18;
                v6 = v23 == 0 ? v19 : (v18 & 32) != 0;
            }
        }
    }
    goto lab__thread18_thread;
  lab__thread18_thread:;
    int32_t v24 = v11; // 0x259ee
    if (v8 == v1) {
        v24 = function_fe05e876();
    }
    // 0x259f2
    if (!v1) {
        __asm_umaalvc(0x259f2, v4, 0x259f8, v4);
    }
    int32_t v25 = v24; // 0x259f6
    if (v10 || !v6) {
        v25 = function_5e6fe();
    }
    // 0x259fa
    if (v6 == !v10) {
        *(int16_t *)(v4 + 239) = 0x59fa;
    }
    bool v26; // 0x259aa
    bool v27; // 0x259aa
    int32_t v28; // 0x259aa
    int32_t v29; // 0x259aa
    if (v1) {
        int32_t v30 = v25 & v4 >> 6; // 0x259fe
        v29 = v30;
        v27 = v30 == 0;
        v26 = v30 == 0;
        v28 = v25;
        if (v30 < 0) {
            goto lab_dec_label_pc_unknown_12;
        } else {
            goto lab_dec_label_pc_unknown_13;
        }
    } else {
        v29 = !v8 ? 0x259fa : -0x2ffffff8 - a3;
        v27 = v10;
        v26 = v10;
        v28 = v25;
        if (v8) {
            goto lab_dec_label_pc_unknown_12;
        } else {
            goto lab_dec_label_pc_unknown_13;
        }
    }
  lab_dec_label_pc_unknown_12:
    *(int32_t *)v25 = v29;
    *(int32_t *)(v25 + 4) = 0x25a0c;
    v26 = v27;
    v28 = v25 - 0x25a0c;
    goto lab_dec_label_pc_unknown_13;
  lab_dec_label_pc_unknown_13:;
    bool v31 = v26;
    if ((v31 ? (v28 & 4) != 0 : (a4 & 0x4000000) != 0) == !v31) {
        function_1e5e89e();
    }
    // 0x25a1a
    __asm_ldc(0, 9, -0x1cabfffc);
    return function_26540();
}

// Address range: 0x25a20 - 0x25bb8
int32_t function_25a20(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x25a20
    function_12060(a1);
    int32_t format; // 0x25a20
    if (function_1e29c(format) == 0) {
        // 0x25a34
        return 0;
    }
    // 0x25b14
    function_304d4(10);
    int32_t v1 = function_191fc(format % 256); // 0x25b20
    int32_t * v2 = (int32_t *)(4 * format + format);
    int32_t result; // 0x25b80
    if (v1 != 0) {
        *v2 = 0;
        // 0x25b74
        function_304d4(10);
        result = function_192c8(format, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488);
        return result;
    }
    // 0x25b34
    *v2 = *v2 + 1;
    if (format != 1 && (format & 0x40000000) != 0) {
        // 0x25b5c
        int32_t str; // bp+32, 0x25a20
        snprintf((char *)&str, 2048, (char *)format);
        function_2e584(1, &str, 0);
    }
    // 0x25b74
    function_304d4(10);
    result = function_192c8(format, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488);
    return result;
}

// Address range: 0x25bba - 0x25bbe
int32_t function_25bba(void) {
    // 0x25bba
    int32_t result; // 0x25bba
    bool v1; // 0x25bba
    if (v1 == !v1) {
        result = function_2216a2();
    }
    // 0x25bbe
    return result;
}

// Address range: 0x25bc0 - 0x25bc4
int32_t function_25bc0(void) {
    // 0x25bc0
    int32_t result; // 0x25bc0
    return result;
}

// Address range: 0x25bc4 - 0x25bc8
int32_t function_25bc4(void) {
    // 0x25bc4
    int32_t v1; // 0x25bc4
    return function_261d0(112, v1, v1, v1);
}

// Address range: 0x25bc8 - 0x25bd4
int32_t function_25bc8(int32_t a1, int32_t a2) {
    // 0x25bc8
    __asm_vstr((float64_t)(int64_t)a1, a2);
    int32_t v1; // 0x25bc8
    __asm_stc(0, 2, v1);
    return function_2685a();
}

// Address range: 0x25bd4 - 0x25bd8
int32_t function_25bd4(int32_t a1) {
    // 0x25bd4
    return function_269de();
}

// Address range: 0x25bd8 - 0x25bdc
int32_t function_25bd8(void) {
    // 0x25bd8
    int32_t v1; // 0x25bd8
    int32_t result = function_260f8(v1, v1, v1, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488); // 0x25bda
    return result;
}

// Address range: 0x25bdc - 0x25bde
int32_t function_25bdc(void) {
    // 0x25bdc
    int32_t result; // 0x25bdc
    return result;
}

// Address range: 0x25bde - 0x25bdf
int32_t function_25bde(void) {
    // 0x25bde
    int32_t result; // 0x25bde
    return result;
}

// Address range: 0x25be0 - 0x25be4
int32_t function_25be0(void) {
    // 0x25be0
    return function_2783a(0);
}

// Address range: 0x25be4 - 0x25be8
int32_t function_25be4(void) {
    // 0x25be4
    return 0;
}

// Address range: 0x25be8 - 0x25bec
int32_t function_25be8(int32_t a1) {
    // 0x25be8
    return function_26452();
}

// Address range: 0x25bec - 0x25bf4
int32_t function_25bec(void) {
    // 0x25bec
    int32_t v1; // 0x25bec
    return function_2e584(v1, (int32_t *)v1, v1);
}

// Address range: 0x25bf4 - 0x25c0a
int32_t function_25bf4(int32_t a1, int32_t a2) {
    int32_t result = function_426238(); // 0x25bfe
    return result;
}

// Address range: 0x25c0a - 0x25c0e
int32_t function_25c0a(void) {
    // 0x25c0a
    int32_t result; // 0x25c0a
    bool v1; // 0x25c0a
    if (v1 || false) {
        result = function_e00c6();
    }
    // 0x25c0e
    return result;
}

// Address range: 0x25c10 - 0x25db0
int32_t function_25c10(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    int32_t v1 = function_1e0e0(); // 0x25c10
    int32_t v2 = function_1e150() * v1; // 0x25c1c
    int32_t * mem = malloc(4 * v2); // 0x25c24
    int32_t result = (int32_t)mem; // 0x25c24
    char * v3; // 0x25c10
    if (mem == NULL) {
        char * v4 = g289; // 0x25d68
        if (v4 != (char *)3 && v4 >= (char *)3) {
            // 0x25d78
            v3 = (char *)0x6c696166;
            function_2e584(3, (int32_t *)&v3, result);
        }
        // 0x25c5c
        return result;
    }
    int32_t v5 = 0;
    int32_t v6; // 0x25c10
    int32_t v7 = v6; // 0x25c40
    int32_t v8; // 0x25c10
    int32_t v9 = v8; // 0x25c40
    int32_t v10; // 0x25c10
    int32_t v11 = v10; // 0x25c40
    int32_t v12 = 0; // 0x25c40
    int32_t v13; // 0x25c10
    bool v14; // 0x25c10
    bool v15; // 0x25c10
    int32_t v16; // 0x25c10
    int32_t v17; // 0x25c10
    int32_t v18; // 0x25c10
    int32_t v19; // 0x25c10
    int32_t v20; // 0x25c10
    int32_t v21; // 0x25c84
    int32_t v22; // 0x25c88
    int32_t v23; // 0x25c8c
    uint32_t v24; // 0x25c90
    int32_t v25; // 0x25c98
    uint32_t v26; // 0x25cb0
    int32_t v27; // 0x25cc8
    int32_t v28; // 0x25ccc
    uint32_t v29; // 0x25cd0
    int32_t v30; // 0x25cf8
    int32_t v31; // 0x25cf8
    int32_t v32; // 0x25cec
    if (!((v2 == 0 | function_1e29c(v5) == 0))) {
        v19 = 0;
        v21 = function_2cd30(v5, v19);
        v22 = v19 + 1;
        v23 = v21 + v12;
        v24 = (int32_t)(v23 < v12);
        v25 = result;
        *(int32_t *)v25 = v21;
        v20 = v25;
        v12 = v23;
        v16 = v24;
        while (v2 != v22) {
            // 0x25c7c
            v19 = v22;
            v21 = function_2cd30(v5, v19);
            v22 = v19 + 1;
            v23 = v21 + v12;
            v24 = v16 + (int32_t)(v23 < v12);
            v25 = v20 + 4;
            *(int32_t *)v25 = v21;
            v20 = v25;
            v12 = v23;
            v16 = v24;
        }
        // 0x25ca0
        v26 = function_60120(v23, v24);
        v15 = false;
        v14 = true;
        if (v24 == 0) {
            v15 = v26 == 0x1387;
            v14 = v26 >= 0x1387;
        }
        v7 = v24;
        v9 = 0x1387;
        v11 = 0;
        if (!v15 && v14) {
            // 0x25cc8
            v27 = *mem;
            v28 = v24 / 2;
            v29 = (int32_t)(v24 % 2 != 0) << 32 - v26 | (int32_t)((int64_t)v26 << (int64_t)(33 - v26));
            v18 = v27;
            if (v24 < 2 ? v27 < v29 : v24 > 1) {
                goto lab_0x25d0c_2;
            }
            // 0x25cec
            v7 = v28;
            v9 = v27;
            v11 = 0;
            if (v19 != 0) {
                v30 = result + 4;
                v31 = *(int32_t *)v30;
                v18 = v31;
                if (v24 < 2 ? v31 < v29 : v24 > 1) {
                    goto lab_0x25d0c_2;
                }
                // 0x25cec
                v32 = 2;
                v7 = v28;
                v9 = v31;
                v11 = 0;
                v13 = v32;
                v17 = v30;
                while (v32 != v2) {
                    // 0x25cf8
                    v30 = v17 + 4;
                    v31 = *(int32_t *)v30;
                    v18 = v31;
                    if (v24 < 2 ? v31 < v29 : v24 > 1) {
                        goto lab_0x25d0c_2;
                    }
                    // 0x25cec
                    v32 = v13 + 1;
                    v7 = v28;
                    v9 = v31;
                    v11 = 0;
                    v13 = v32;
                    v17 = v30;
                }
            }
        }
    }
    int32_t v33 = v11;
    int32_t v34 = v9;
    int32_t v35 = v7;
    int32_t v36 = v5 + 1; // 0x25c44
    while (v36 != 4) {
        // 0x25c34
        v5 = v36;
        v7 = v35;
        v9 = v34;
        v11 = v33;
        v12 = 0;
        if (!((v2 == 0 | function_1e29c(v5) == 0))) {
            v19 = 0;
            v21 = function_2cd30(v5, v19);
            v22 = v19 + 1;
            v23 = v21 + v12;
            v24 = (int32_t)(v23 < v12);
            v25 = result;
            *(int32_t *)v25 = v21;
            v20 = v25;
            v12 = v23;
            v16 = v24;
            while (v2 != v22) {
                // 0x25c7c
                v19 = v22;
                v21 = function_2cd30(v5, v19);
                v22 = v19 + 1;
                v23 = v21 + v12;
                v24 = v16 + (int32_t)(v23 < v12);
                v25 = v20 + 4;
                *(int32_t *)v25 = v21;
                v20 = v25;
                v12 = v23;
                v16 = v24;
            }
            // 0x25ca0
            v26 = function_60120(v23, v24);
            v15 = false;
            v14 = true;
            if (v24 == 0) {
                v15 = v26 == 0x1387;
                v14 = v26 >= 0x1387;
            }
            v7 = v24;
            v9 = 0x1387;
            v11 = 0;
            if (!v15 && v14) {
                // 0x25cc8
                v27 = *mem;
                v28 = v24 / 2;
                v29 = (int32_t)(v24 % 2 != 0) << 32 - v26 | (int32_t)((int64_t)v26 << (int64_t)(33 - v26));
                v18 = v27;
                if (v24 < 2 ? v27 < v29 : v24 > 1) {
                    goto lab_0x25d0c_2;
                }
                // 0x25cec
                v7 = v28;
                v9 = v27;
                v11 = 0;
                if (v19 != 0) {
                    v30 = result + 4;
                    v31 = *(int32_t *)v30;
                    v18 = v31;
                    if (v24 < 2 ? v31 < v29 : v24 > 1) {
                        goto lab_0x25d0c_2;
                    }
                    // 0x25cec
                    v32 = 2;
                    v7 = v28;
                    v9 = v31;
                    v11 = 0;
                    v13 = v32;
                    v17 = v30;
                    while (v32 != v2) {
                        // 0x25cf8
                        v30 = v17 + 4;
                        v31 = *(int32_t *)v30;
                        v18 = v31;
                        if (v24 < 2 ? v31 < v29 : v24 > 1) {
                            goto lab_0x25d0c_2;
                        }
                        // 0x25cec
                        v32 = v13 + 1;
                        v7 = v28;
                        v9 = v31;
                        v11 = 0;
                        v13 = v32;
                        v17 = v30;
                    }
                }
            }
        }
        // 0x25c44
        v33 = v11;
        v34 = v9;
        v35 = v7;
        v36 = v5 + 1;
    }
    // 0x25c50
    free(result, v35, v34, v33);
    // 0x25c5c
    return 0;
  lab_0x25d0c_2:;
    char * v37 = g289; // 0x25d14
    int32_t v38 = v28; // 0x25d1c
    int32_t v39 = v18; // 0x25d1c
    int32_t v40 = (int32_t)v37; // 0x25d1c
    if (v37 == (char *)3 || v37 < (char *)3) {
        goto lab_0x25d4c;
    } else {
        // 0x25d20
        v3 = (char *)0x616d6f44;
        function_2e584(3, (int32_t *)&v3, 0);
        v38 = (int32_t)&v3;
        v39 = 0;
        v40 = 0x65636e61;
        goto lab_0x25d4c;
    }
  lab_0x25d4c:
    // 0x25d4c
    free(result, v38, v39, v40);
    return 1;
}

// Address range: 0x25db0 - 0x25e40
int32_t function_25db0(void) {
    // 0x25db0
    int64_t v1; // bp-2080, 0x25db0
    function_302a0((int32_t *)&v1);
    if ((g69 || g68) == 0) {
        function_25fd4((int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488);
    }
    uint64_t v2 = 0x100000000 * v1 >> 32; // 0x25ddc
    int32_t v3 = (int32_t)(v2 / 0x100000000) - g68 + (int32_t)((int32_t)v2 - g69 < 0);
    if (v3 < 301) {
        function_25e54((int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488);
    }
    // 0x25e00
    if (g346 == 0) {
        function_25f50((int32_t)&g488);
    }
    if (g346 + 299 >= v3) {
        function_25e48((int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488);
    }
    // 0x25e1c
    if (g347 != 0) {
        function_25e48((int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488);
    }
    char * v4 = g289; // 0x25e30
    if (v4 >= (char *)3 == (v4 != (char *)3)) {
        function_25fe4();
    }
    // 0x25e3c
    return function_194dc();
}

// Address range: 0x25e40 - 0x25e44
int32_t function_25e40(int32_t a1) {
    // 0x25e40
    return function_2737e(a1 + 1);
}

// Address range: 0x25e44 - 0x25e48
int32_t function_25e44(int32_t a1) {
    // 0x25e44
    return a1 + 4;
}

// Address range: 0x25e48 - 0x25e54
int32_t function_25e48(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x25e48
    int32_t result; // 0x25e48
    return result;
}

// Address range: 0x25e54 - 0x25f50
int32_t function_25e54(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x25e54
    int32_t v1; // 0x25e54
    int32_t * v2 = (int32_t *)(v1 + 4); // 0x25e54
    char * v3; // 0x25e54
    if (*v2 != 0) {
        char * v4 = g289; // 0x25e68
        if (v4 >= (char *)3 == (v4 != (char *)3)) {
            // 0x25edc
            v3 = (char *)0x7774656e;
            function_2e584(3, (int32_t *)&v3, 0);
        }
        int32_t result = function_31d58(6, "network connection resume, restart..."); // 0x25e80
        *v2 = 0;
        *(int32_t *)v1 = 0;
        return result;
    }
    if (v1 == 0) {
        function_25e48((int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488);
    }
    char * v5 = g289; // 0x25eb0
    if (v5 >= (char *)3 == (v5 != (char *)3)) {
        // 0x25f1c
        v3 = (char *)0x7774656e;
        function_2e584(3, (int32_t *)&v3, 0);
    }
    int32_t result2 = function_31d58(function_31d48(), NULL); // 0x25ec4
    *(int32_t *)v1 = 0;
    return result2;
}

// Address range: 0x25f50 - 0x25fcc
int32_t function_25f50(int32_t a1) {
    // 0x25f50
    function_31d58(3, "network connection lost");
    int32_t v1 = function_2b2f4(); // 0x25f64
    function_11f10(v1 == 0 ? a1 : v1);
    char * v2 = g289; // 0x25f90
    int32_t v3 = random() % 300 + 1; // 0x25fa0
    int32_t v4; // 0x25f50
    *(int32_t *)v4 = v3;
    if (v2 == (char *)3 || v2 < (char *)3) {
        function_25e48((int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488);
    }
    // 0x25fac
    int32_t str; // 0x25f50
    snprintf((char *)&str, 2048, "will power off in %d seconds in case not resume", v3);
    return 3;
}

// Address range: 0x25fd0 - 0x25fd4
int32_t function_25fd0(void) {
    int32_t result = function_25e48((int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488); // 0x25fd0
    return result;
}

// Address range: 0x25fd4 - 0x25fe4
int32_t function_25fd4(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x25fd4
    int32_t v1; // 0x25fd4
    return function_302a0((int32_t *)v1);
}

// Address range: 0x25fe4 - 0x25ff0
int32_t function_25fe4(void) {
    // 0x25fe4
    int32_t result; // 0x25fe4
    return result;
}

// Address range: 0x25ff0 - 0x25ff4
int32_t function_25ff0(int32_t a1, int32_t a2) {
    // 0x25ff0
    return function_26510(a2);
}

// Address range: 0x25ff4 - 0x2600c
int32_t function_25ff4(void) {
    // 0x25ff4
    int32_t str; // 0x25ff4
    snprintf((char *)str, str, (char *)str);
    int32_t v1; // 0x25ff4
    return function_2e584(3, &v1, str);
}

// Address range: 0x2600c - 0x26094
int32_t function_2600c(void) {
    // 0x2600c
    int32_t v1; // 0x2600c
    function_452d0(function_452b0(v1) | 0x10000);
    prctl(PR_SET_NAME, (int32_t)"nonce_reg_process", 0, 0, 0);
    while (true) {
        uint32_t v2 = function_44d3c(); // 0x2603c
        uint32_t v3 = v2 / 2; // 0x26040
        int32_t v4 = 0; // 0x26044
        if (v2 >= 2) {
            while (true) {
                // 0x26060
                int32_t v5; // bp-32, 0x2600c
                function_44d94(&v5);
                int32_t v6 = v4 + 1;
                char v7; // 0x2600c
                if (v7 < 0) {
                    // 0x26078
                    function_2c5e8(&v5);
                    if (v3 == v6) {
                        // break -> 0x26088
                        break;
                    }
                } else {
                    // 0x26050
                    function_2c96c(&v5);
                    if (v3 == v6) {
                        // break -> 0x26088
                        break;
                    }
                }
                // 0x26060
                v4 = v6;
            }
        }
        // 0x26088
        function_304d4(1);
    }
}

// Address range: 0x26094 - 0x26098
int32_t function_26094(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x26094
    return function_2683c();
}

// Address range: 0x2609a - 0x260a2
int32_t function_2609a(void) {
    // 0x2609a
    int32_t result; // 0x2609a
    return result;
}

// Address range: 0x260a2 - 0x260a4
int32_t function_260a2(void) {
    // 0x260a2
    return function_26540();
}

// Address range: 0x260a4 - 0x260b8
int32_t function_260a4(int32_t a1, int32_t a2, int32_t a3, uint32_t a4) {
    if (a4 == 3 || a4 < 3) {
        function_260f0();
    }
    // 0x260b4
    return (int32_t)__errno_location();
}

// Address range: 0x260b8 - 0x260bc
int32_t function_260b8(int32_t a1) {
    // 0x260b8
    return function_25bde();
}

// Address range: 0x260bc - 0x260c0
int32_t function_260bc(int32_t a1) {
    // 0x260bc
    return function_26402();
}

// Address range: 0x260c0 - 0x260c2
int32_t function_260c0(void) {
    // 0x260c0
    int32_t result; // 0x260c0
    return result;
}

// Address range: 0x260c4 - 0x260c8
int32_t function_260c4(void) {
    // 0x260c4
    return function_266d0();
}

// Address range: 0x260c8 - 0x260cc
int32_t function_260c8(int32_t a1) {
    // 0x260c8
    return function_25be8(a1);
}

// Address range: 0x260cc - 0x260f0
int32_t function_260cc(int32_t a1, int32_t a2, uint32_t a3) {
    // 0x260cc
    int32_t str; // 0x260cc
    snprintf((char *)&str, 2048, (char *)(a3 % 0x10000 | 0x60000));
    return function_2e584(3, &str, 0);
}

// Address range: 0x260f0 - 0x260f8
int32_t function_260f0(void) {
    // 0x260f0
    return function_11fe8(0);
}

// Address range: 0x260f8 - 0x26106
int32_t function_260f8(int32_t result, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x260fa
    return function_26618(result, a2, a3);
    // 0x26100
    *(int16_t *)a3 = (int16_t)result;
    return result;
}

// Address range: 0x26104 - 0x26105
int32_t function_26104(void) {
    // 0x26104
    int32_t result; // 0x26104
    return result;
}

// Address range: 0x26106 - 0x26108
int32_t function_26106(void) {
    // 0x26106
    int32_t result; // 0x26106
    return result;
}

// Address range: 0x26108 - 0x26134
int32_t function_26108(void) {
    // 0x26108
    int32_t result; // bp-68, 0x26108
    int32_t v1 = sysinfo((struct sysinfo *)&result); // 0x26110
    if (v1 == 0) {
        // 0x26128
        return result;
    }
    // 0x2611c
    int32_t v2; // 0x26108
    return function_26094(v1, v2, v2, v2);
}

// Address range: 0x2613a - 0x2613c
int32_t function_2613a(int32_t a1) {
    // 0x2613a
    return function_265d8(a1);
}

// Address range: 0x2613c - 0x26144
int32_t function_2613c(void) {
    // 0x2613c
    return function_26104();
}

// Address range: 0x26146 - 0x26148
int32_t function_26146(int32_t a1) {
    // 0x26146
    return function_26766(a1);
}

// Address range: 0x2614a - 0x2614c
int32_t function_2614a(int32_t a1) {
    // 0x2614a
    return function_25e40(a1);
}

// Address range: 0x2614c - 0x26194
int32_t function_2614c(int32_t a1, int32_t a2, int32_t a3, uint32_t a4) {
    int32_t v1 = a4 % 0x10000 | (int32_t)&g425; // 0x2614c
    uint32_t v2 = *(int32_t *)v1; // 0x26154
    int32_t v3; // 0x2614c
    uint32_t v4 = *(int32_t *)(v3 + 16); // 0x26158
    int32_t v5 = *(int32_t *)(v3 + 20); // 0x26168
    int32_t * v6 = (int32_t *)(v3 + 8); // 0x2616c
    *v6 = a1;
    int32_t v7 = *(int32_t *)(v1 + 4) - v5 + (int32_t)(v2 < v4); // 0x26178
    int32_t result = function_600b4(v2 - v4, v7); // 0x26180
    __asm_vldr(-0x200000);
    __asm_vmov(result, v7);
    __asm_vldr(0);
    __asm_vmov_7(a1 - *v6);
    return result;
}

// Address range: 0x26196 - 0x261ce
int32_t function_26196(int32_t a1) {
    // 0x26196
    int32_t v1; // 0x26196
    int32_t v2 = v1;
    bool v3; // 0x26196
    bool v4; // 0x26196
    bool v5; // 0x26196
    if (v5) {
        // 0x2619a
        function_ff9e1a32();
        v3 = true;
        if (!v5) {
            // 0x261a6
            function_15f7ba();
            v3 = false;
        }
    } else {
        uint32_t v6 = 2048 * v2 & v2; // 0x2619e
        bool v7 = true; // 0x261a2
        if (v6 >= 0) {
            // 0x261a6
            function_15f7ba();
            v7 = false;
        }
        // 0x261aa
        function_1e1bca();
        function_61bc6();
        v4 = v6 == 0;
        v3 = v7;
    }
    // 0x261ae
    if (!v4 && v3 == v5) {
        __asm_svcgt(0xf5ed85);
    }
    if (v4) {
        function_fe4611b6();
    }
    if (!v3) {
        function_2619da();
    }
    if (v5) {
        // 0x261c2
        function_61ca6();
    } else {
        // 0x261be
        function_ffa21c9a();
        function_1a181e();
        function_ff1e1a6a();
    }
    // 0x261ca
    return function_461ca2();
}

// Address range: 0x261d0 - 0x261d8
int32_t function_261d0(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x261d0
    return result;
}

// Address range: 0x261d8 - 0x2620c
int32_t function_261d8(int32_t result, int32_t a2, int32_t a3, uint32_t a4, int32_t a5) {
    uint32_t v1 = *(int32_t *)(a4 % 0x10000 | 0x70000); // 0x261dc
    if (v1 >= 3 != v1 != 3) {
        // 0x261e8
        return result;
    }
    // 0x261f0
    float64_t v2; // 0x261d8
    __asm_vstr(v2, a5);
    return result;
}

// Address range: 0x2620e - 0x26210
int32_t function_2620e(void) {
    // 0x2620e
    return function_2672c();
}

// Address range: 0x26210 - 0x2623c
int32_t function_26210(int32_t str, int32_t a2, int32_t format, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9) {
    // 0x26210
    snprintf((char *)str, 2048, (char *)format);
    int32_t v1; // bp+16, 0x26210
    return function_2e584(3, &v1, 0);
}

// Address range: 0x2623c - 0x26240
int32_t function_2623c(void) {
    // 0x2623c
    return function_426880();
}

// Address range: 0x26250 - 0x26251
int32_t function_26250(void) {
    // 0x26250
    int32_t result; // 0x26250
    return result;
}

// Address range: 0x26256 - 0x26258
int32_t function_26256(void) {
    // 0x26256
    return function_2685a();
}

// Address range: 0x26258 - 0x26300
int32_t function_26258(void) {
    // 0x26258
    int32_t v1; // 0x26258
    int32_t v2 = *(int32_t *)((uint32_t)v1 % 0x10000 | (int32_t)&g357); // 0x26264
    if (v2 == 1) {
        function_26454();
    }
    // 0x26270
    g350 = function_26104();
    int32_t v3 = function_1e29c(0); // 0x262d4
    int32_t result = &g427; // 0x262ec
    if (v3 == 0) {
        result = function_263e0((int32_t)&g488);
    }
    // 0x262f0
    return result;
}

// Address range: 0x26302 - 0x26304
int32_t function_26302(int32_t a1) {
    // 0x26302
    int32_t v1; // 0x26302
    return function_25e40(v1);
}

// Address range: 0x26304 - 0x26306
int32_t function_26304(void) {
    // 0x26304
    int32_t v1; // 0x26304
    return function_26324(v1);
}

// Address range: 0x26306 - 0x26308
int32_t function_26306(void) {
    // 0x26306
    int32_t v1; // 0x26306
    return function_263bc(v1, v1, v1, v1);
}

// Address range: 0x26308 - 0x2630c
int32_t function_26308(int32_t a1, int32_t a2) {
    // 0x26308
    return function_26cf2();
}

// Address range: 0x2630c - 0x26310
int32_t function_2630c(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x2630c
    *(int32_t *)a1 = a3;
    *(int32_t *)(a1 + 4) = a4;
    return function_264a8(a1 + 8);
}

// Address range: 0x26310 - 0x26314
int32_t function_26310(int32_t result) {
    // 0x26310
    return result;
}

// Address range: 0x26314 - 0x26318
int32_t function_26314(int32_t a1, int32_t a2) {
    // 0x26314
    return function_274e2();
}

// Address range: 0x2631a - 0x2631c
int32_t function_2631a(void) {
    // 0x2631a
    return function_269de();
}

// Address range: 0x2631c - 0x26320
int32_t function_2631c(void) {
    // 0x2631c
    int32_t v1; // 0x2631c
    return function_26624(v1, v1, v1, v1);
}

// Address range: 0x26320 - 0x26324
int32_t function_26320(int32_t a1, int32_t a2) {
    // 0x26320
    return function_264a8(a1);
}

// Address range: 0x26324 - 0x26326
int32_t function_26324(int32_t result) {
    // 0x26324
    return result;
}

// Address range: 0x26326 - 0x26328
int32_t function_26326(int32_t a1) {
    // 0x26326
    return function_2783a(a1);
}

// Address range: 0x26328 - 0x2632c
int32_t function_26328(int32_t a1) {
    // 0x26328
    return function_26470();
}

// Address range: 0x2632e - 0x26330
int32_t function_2632e(void) {
    // 0x2632e
    return function_26452();
}

// Address range: 0x26330 - 0x26338
int32_t function_26330(int32_t a1, int32_t a2) {
    // 0x26330
    bool v1; // 0x26330
    int32_t v2; // 0x26330
    return function_60120(a1, v2 + a2 + (int32_t)(bool)v1);
}

// Address range: 0x26338 - 0x2633c
int32_t function_26338(void) {
    // 0x26338
    return function_2685c();
}

// Address range: 0x2633c - 0x2635c
int32_t function_2633c(int32_t a1, int32_t a2) {
    int32_t v1 = function_60120(a1, a2); // 0x26340
    __asm_vmov(function_600b4(v1, a2), a2);
    int32_t v2; // 0x2633c
    return v2 * v2;
}

// Address range: 0x2635c - 0x26364
int32_t function_2635c(int32_t a1, int32_t a2) {
    // 0x2635c
    __asm_cdp(0, 11, 3, 6, 0, 2);
    return function_26f86();
}

// Address range: 0x26364 - 0x26368
int32_t function_26364(int32_t result) {
    // 0x26364
    return result;
}

// Address range: 0x26368 - 0x2636c
int32_t function_26368(int32_t a1) {
    // 0x26368
    return function_26b36(a1 + 88);
}

// Address range: 0x2636c - 0x26370
int32_t function_2636c(void) {
    // 0x2636c
    int32_t result; // 0x2636c
    return result;
}

// Address range: 0x26370 - 0x26374
int32_t function_26370(void) {
    // 0x26370
    int32_t v1; // 0x26370
    return function_26710(128 * v1);
}

// Address range: 0x26374 - 0x26378
int32_t function_26374(int32_t a1, int32_t a2, int32_t a3) {
    // 0x26374
    return function_2647c(a1);
}

// Address range: 0x26378 - 0x2637c
int32_t function_26378(void) {
    // 0x26378
    int32_t v1; // 0x26378
    return function_26718(128 * v1);
}

// Address range: 0x2637c - 0x26380
int32_t function_2637c(int32_t a1, int32_t a2) {
    // 0x2637c
    return function_266c2();
}

// Address range: 0x26380 - 0x26384
int32_t function_26380(int32_t result, int32_t a2, int32_t a3) {
    // 0x26380
    return result;
}

// Address range: 0x26384 - 0x26388
int32_t function_26384(int32_t a1, int32_t a2, int32_t a3) {
    // 0x26384
    *(int32_t *)a3 = a1;
    return function_26cde();
}

// Address range: 0x26388 - 0x2638c
int32_t function_26388(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x26388
    return result;
}

// Address range: 0x2638c - 0x26390
int32_t function_2638c(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x2638c
    *(int32_t *)a1 = a3;
    *(int32_t *)(a1 + 4) = a4;
    return a1 + 12;
}

// Address range: 0x26390 - 0x26394
int32_t function_26390(void) {
    // 0x26390
    return function_2655c();
}

// Address range: 0x26394 - 0x26398
int32_t function_26394(int32_t a1, int32_t a2) {
    // 0x26394
    return function_26940();
}

// Address range: 0x26398 - 0x2639c
int32_t function_26398(int32_t fd) {
    // 0x26398
    return close(fd);
}

// Address range: 0x2639c - 0x263a0
int32_t function_2639c(int32_t a1) {
    // 0x2639c
    return function_264a2();
}

// Address range: 0x263a0 - 0x263a4
int32_t function_263a0(int32_t a1) {
    // 0x263a0
    return function_264ac();
}

// Address range: 0x263a4 - 0x263a8
int32_t function_263a4(void) {
    // 0x263a4
    return function_2642e();
}

// Address range: 0x263a8 - 0x263b0
int32_t function_263a8(int32_t a1) {
    // 0x263a8
    int32_t v1; // 0x263a8
    __asm_stc(0, 0, *(int32_t *)(v1 + 8));
    return function_264b2();
}

// Address range: 0x263b0 - 0x263bc
int32_t function_263b0(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t result = a1; // 0x263b4
    bool v1; // 0x263b0
    if ((a1 & 0x20000000) == 0 || v1) {
        result = function_263e0((int32_t)&g488);
    }
    // 0x263b8
    __asm_vldr(*(int32_t *)(8 * a1 + a4));
    return result;
}

// Address range: 0x263bc - 0x263be
int32_t function_263bc(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x263bc
    return result;
}

// Address range: 0x263be - 0x263c0
int32_t function_263be(void) {
    // 0x263be
    return function_269de();
}

// Address range: 0x263c0 - 0x263c4
int32_t function_263c0(void) {
    // 0x263c0
    int32_t v1; // 0x263c0
    return function_26a46(7, v1, v1, v1);
}

// Address range: 0x263c6 - 0x263de
int32_t function_263c6(int32_t a1, int32_t a2, int32_t a3) {
    // 0x263c6
    bool v1; // 0x263c6
    if (!v1) {
        function_ff221c66();
    }
    int32_t result = function_461ea2(); // 0x263ca
    if (v1) {
        *(int32_t *)a3 = (int32_t)&g17;
        *(int32_t *)(a3 + 4) = 0x263d4;
    }
    return result;
}

// Address range: 0x263e0 - 0x26400
int32_t function_263e0(int32_t a1) {
    int32_t * v1 = (int32_t *)a1; // 0x263f4
    *v1 = *v1 + 1;
    int32_t result; // 0x263e0
    return result;
}

// Address range: 0x26402 - 0x26404
int32_t function_26402(void) {
    // 0x26402
    int32_t result; // 0x26402
    return result;
}

// Address range: 0x26404 - 0x2640c
int32_t function_26404(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    // 0x26404
    int32_t result; // 0x26404
    return result;
}

// Address range: 0x2640c - 0x26410
int32_t function_2640c(int32_t a1) {
    // 0x2640c
    return a1 + 36;
}

// Address range: 0x26410 - 0x26414
int32_t function_26410(void) {
    // 0x26410
    int32_t v1; // 0x26410
    return function_26a1c(v1);
}

// Address range: 0x26414 - 0x2641c
int32_t function_26414(int32_t a1, int32_t a2) {
    // 0x26414
    __asm_stc(0, 2, a2);
    return function_26e2c();
}

// Address range: 0x2641c - 0x26420
int32_t function_2641c(int32_t a1) {
    // 0x2641c
    int32_t v1; // 0x2641c
    return function_26b62(a1, v1);
}

// Address range: 0x26422 - 0x26424
int32_t function_26422(void) {
    // 0x26422
    return function_26940();
}

// Address range: 0x26424 - 0x26428
int32_t function_26424(int32_t a1) {
    // 0x26424
    return a1 + 8;
}

// Address range: 0x26428 - 0x2642c
int32_t function_26428(int32_t a1) {
    // 0x26428
    return function_26878(a1 + 5);
}

// Address range: 0x2642e - 0x2642f
int32_t function_2642e(void) {
    // 0x2642e
    int32_t result; // 0x2642e
    return result;
}

// Address range: 0x26430 - 0x26448
int32_t function_26430(void) {
    // 0x26430
    int32_t v1; // bp+40, 0x26430
    return function_2e584(3, &v1, 0);
}

// Address range: 0x2644a - 0x2644c
int32_t function_2644a(int32_t a1) {
    // 0x2644a
    return function_2783a(a1);
}

// Address range: 0x2644c - 0x26450
int32_t function_2644c(void) {
    // 0x2644c
    int32_t result; // 0x2644c
    return result;
}

// Address range: 0x26452 - 0x26453
int32_t function_26452(void) {
    // 0x26452
    int32_t result; // 0x26452
    return result;
}

// Address range: 0x26454 - 0x26470
int32_t function_26454(void) {
    int32_t * set_mem = memset(&g349, 0, 32); // 0x26460
    int32_t v1; // 0x26454
    *(int32_t *)v1 = 0;
    return (int32_t)set_mem;
}

// Address range: 0x26470 - 0x26471
int32_t function_26470(void) {
    // 0x26470
    int32_t result; // 0x26470
    return result;
}

// Address range: 0x2647c - 0x2647e
int32_t function_2647c(uint32_t a1) {
    // 0x2647c
    int32_t v1; // 0x2647c
    uint32_t v2 = v1;
    return a1 << 32 - v2 | a1 >> v2;
}

// Address range: 0x26480 - 0x264a0
int32_t function_26480(void) {
    // 0x26480
    return prctl(PR_SET_NAME, (int32_t)"chk_sys", 0, 0, 0);
}

// Address range: 0x264a0 - 0x264a2
int32_t function_264a0(int32_t fd) {
    // 0x264a0
    return close(fd);
}

// Address range: 0x264a2 - 0x264a3
int32_t function_264a2(void) {
    // 0x264a2
    int32_t result; // 0x264a2
    return result;
}

// Address range: 0x264a4 - 0x264a8
int32_t function_264a4(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x264a4
    return function_26dee(a4 + a1);
}

// Address range: 0x264a8 - 0x264ac
int32_t function_264a8(int32_t a1) {
    // 0x264a8
    return function_26b2e();
}

// Address range: 0x264ac - 0x264ae
int32_t function_264ac(void) {
    // 0x264ac
    int32_t result; // 0x264ac
    return result;
}

// Address range: 0x264b2 - 0x264b4
int32_t function_264b2(void) {
    // 0x264b2
    int32_t v1; // 0x264b2
    return function_26b56(v1);
}

// Address range: 0x264b4 - 0x26510
int32_t function_264b4(void) {
    // 0x264b4
    bool v1; // 0x264b4
    if (!v1) {
        function_1e0c0();
    }
    int32_t v2 = function_26104(); // 0x264c0
    while (true) {
        // 0x264e0
        if (function_31d38() == 2) {
            int32_t v3 = function_26104(); // 0x264ec
            uint64_t v4 = *(int64_t *)&g451; // 0x264f0
            if ((int32_t)(v4 / 0x100000000 || v4) != 0) {
                // break -> 0x26500
                break;
            }
            uint32_t v5 = v3 - v2; // 0x264f4
            if (v5 >= 1800 == (v5 != 1800)) {
                // break -> 0x26500
                break;
            }
        }
        // 0x264d8
        function_304d4(10);
    }
    // 0x26500
    return function_26104();
}

// Address range: 0x26510 - 0x26514
int32_t function_26510(int32_t a1) {
    // 0x26510
    return function_26e78(a1);
}

// Address range: 0x26514 - 0x26518
int32_t function_26514(int32_t a1, int32_t a2) {
    // 0x26514
    return function_2663e();
}

// Address range: 0x26518 - 0x2651c
int32_t function_26518(int32_t a1) {
    // 0x26518
    return a1 + 60;
}

// Address range: 0x2651c - 0x26520
int32_t function_2651c(int32_t a1) {
    // 0x2651c
    return a1 + 8;
}

// Address range: 0x26520 - 0x26524
int32_t function_26520(int32_t a1) {
    // 0x26520
    int32_t v1; // 0x26520
    *(int16_t *)a1 = (int16_t)v1;
    return function_26ba6();
}

// Address range: 0x26524 - 0x26528
int32_t function_26524(int32_t a1) {
    // 0x26524
    return a1 + 64;
}

// Address range: 0x26528 - 0x2652c
int32_t function_26528(int32_t a1, int32_t a2) {
    // 0x26528
    return function_266ea(*(char *)(a2 + 2));
}

// Address range: 0x2652c - 0x26530
int32_t function_2652c(int32_t a1) {
    // 0x2652c
    return a1 + 56;
}

// Address range: 0x26530 - 0x26534
int32_t function_26530(int32_t a1, int32_t a2) {
    // 0x26530
    *(int32_t *)(2 * a1) = a2;
    return function_26c76();
}

// Address range: 0x26534 - 0x26538
int32_t function_26534(int32_t a1) {
    // 0x26534
    int32_t v1; // 0x26534
    return function_26a46(a1, v1, v1, v1);
}

// Address range: 0x26538 - 0x2653c
int32_t function_26538(int32_t a1) {
    // 0x26538
    return function_27288();
}

// Address range: 0x2653c - 0x26540
int32_t function_2653c(int32_t a1) {
    // 0x2653c
    return function_272a0(0);
}

// Address range: 0x26540 - 0x26542
int32_t function_26540(void) {
    // 0x26540
    int32_t result; // 0x26540
    return result;
}

// Address range: 0x26542 - 0x2655a
int32_t function_26542(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x26542
    bool v1; // 0x26542
    int32_t v2; // 0x26542
    if (v1) {
        *(int32_t *)(v2 + 4) = 0x26548;
    }
    __asm_cdpge(1, 10, 14, 9, 0, 5);
    if (v1) {
        *(int32_t *)(result + 4) = 0x26550;
        return result - (int32_t)&g19 - v2;
    }
    // 0x2655a
    return result;
}

// Address range: 0x2655c - 0x26564
int32_t function_2655c(void) {
    // 0x2655c
    return function_268a6(0);
}

// Address range: 0x26564 - 0x26584
int32_t function_26564(void) {
    // 0x26564
    int32_t v1; // 0x26564
    function_11ea4((int32_t *)v1, v1, v1, v1);
    function_12060(0);
    pthread_testcancel();
    return function_304d4(1000);
}

// Address range: 0x26586 - 0x26588
int32_t function_26586(int32_t a1) {
    // 0x26586
    return function_2737e(a1);
}

// Address range: 0x26588 - 0x265c4
int32_t function_26588(void) {
    // 0x26588
    function_12060(1);
    int32_t v1; // 0x26588
    uint64_t v2 = (int64_t)v1 * (int64_t)(uint32_t)v1 / 0x1000000000; // 0x26590
    int32_t v3 = v1 - 2 * (16 * (int32_t)v2 - (int32_t)v2); // 0x2659c
    if (function_1e29c(v3) != 0) {
        function_265d0();
    }
    // 0x265b4
    return v3 + 1;
}

// Address range: 0x265c4 - 0x265c6
int32_t function_265c4(char * special_file, int32_t flags) {
    // 0x265c4
    return umount2(special_file, flags);
}

// Address range: 0x265c6 - 0x265c7
int32_t function_265c6(void) {
    // 0x265c6
    int32_t result; // 0x265c6
    return result;
}

// Address range: 0x265c8 - 0x265d0
int32_t function_265c8(int32_t result) {
    // 0x265c8
    return result;
}

// Address range: 0x265d0 - 0x265d8
int32_t function_265d0(void) {
    // 0x265d0
    return function_1e160();
}

// Address range: 0x265d8 - 0x265dc
int32_t function_265d8(int32_t a1) {
    // 0x265d8
    return function_2691e();
}

// Address range: 0x265dc - 0x265e4
int32_t function_265dc(void) {
    // 0x265dc
    int32_t v1; // 0x265dc
    return function_3eff0(v1, v1, v1, v1, (int32_t)&g488);
}

// Address range: 0x265e4 - 0x265ec
int32_t function_265e4(void) {
    // 0x265e4
    return function_350e8();
}

// Address range: 0x265ec - 0x265f4
int32_t function_265ec(void) {
    // 0x265ec
    return function_1e0c0();
}

// Address range: 0x265f4 - 0x26618
int32_t function_265f4(void) {
    int32_t result = function_26104(); // 0x265f8
    g351 = result;
    g348 = result;
    g352 = result;
    g350 = result;
    return result;
}

// Address range: 0x26618 - 0x2661a
int32_t function_26618(int32_t a1, int32_t a2, int32_t a3) {
    // 0x26618
    return a3 & a1;
}

// Address range: 0x2661c - 0x26624
int32_t function_2661c(void) {
    // 0x2661c
    return function_1a18c();
}

// Address range: 0x26624 - 0x2662c
int32_t function_26624(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x26624
    __asm_mcr(0, 0, a4, 7, 9, 4);
    return function_26cae();
}

// Address range: 0x2662e - 0x2663e
int32_t function_2662e(void) {
    // 0x2662e
    int32_t result; // 0x2662e
    bool v1; // 0x2662e
    if (v1) {
        // 0x26636
        result = function_6211a();
    } else {
        function_ffa21cb2();
        result = function_1a1c8a();
    }
    // 0x2663a
    return result;
}

// Address range: 0x2663e - 0x2663f
int32_t function_2663e(void) {
    // 0x2663e
    int32_t result; // 0x2663e
    return result;
}

// Address range: 0x26642 - 0x2664e
int32_t function_26642(int32_t a1) {
    // 0x26642
    int32_t v1; // 0x26642
    __asm_mrc(0, 7, v1, 1, 0, 0);
    int32_t result = a1; // 0x26646
    bool v2; // 0x26642
    if (v2 == !v2) {
        result = umount2((char *)a1, v1);
    }
    // 0x26648
    __asm_stc2l(11, 14, *(int32_t *)(v1 - 1020));
    return result;
}

// Address range: 0x2664e - 0x26650
int32_t function_2664e(void) {
    // 0x2664e
    return function_26cf2();
}

// Address range: 0x26650 - 0x26658
int32_t function_26650(int32_t a1) {
    // 0x26650
    int32_t result; // 0x26650
    return result;
}

// Address range: 0x2665a - 0x2665c
int32_t function_2665a(void) {
    // 0x2665a
    return function_274e2();
}

// Address range: 0x2665c - 0x26668
int32_t function_2665c(int32_t a1, uint32_t a2, int32_t a3, int32_t a4) {
    // 0x2665c
    return function_31d58(a1, (char *)(a2 % 0x10000 | 0x60000));
}

// Address range: 0x26668 - 0x266b4
int32_t function_26668(void) {
    // 0x26668
    int32_t v1; // 0x26668
    int32_t v2 = v1;
    bool v3; // 0x26668
    if (v3) {
        *(char *)v2 = (char)v2;
        if ((v2 & 2048) == 0) {
            __asm_svclo(0xee6666);
            goto lab_dec_label_pc_0x26678;
        } else {
            goto lab_dec_label_pc_0x26678;
        }
    } else {
        if (v3) {
            goto lab_dec_label_pc_0x26678;
        } else {
            __asm_svclo(0xee6666);
            goto lab_dec_label_pc_0x26678;
        }
    }
  lab_dec_label_pc_0x26678:;
    float64_t v4; // 0x26668
    __asm_vpush_17(v4, v4, v4, v4, v4);
    function_32530();
    if ((int32_t)g353 % 5 == 0) {
        function_267d4();
    }
    // 0x266ac
    return 0x66666667;
}

// Address range: 0x266b6 - 0x266b8
int32_t function_266b6(void) {
    // 0x266b6
    return function_2683c();
}

// Address range: 0x266b8 - 0x266bc
int32_t function_266b8(int32_t a1) {
    // 0x266b8
    return function_26782();
}

// Address range: 0x266bc - 0x266c0
int32_t function_266bc(void) {
    // 0x266bc
    return function_27482();
}

// Address range: 0x266c2 - 0x266c4
int32_t function_266c2(void) {
    // 0x266c2
    int32_t v1; // 0x266c2
    return function_2696c(v1, v1, v1, v1);
}

// Address range: 0x266c4 - 0x266c8
int32_t function_266c4(void) {
    // 0x266c4
    int32_t result; // 0x266c4
    bool v1; // 0x266c4
    if (v1) {
        result = function_31d38();
    }
    // 0x266c8
    return result;
}

// Address range: 0x266ca - 0x266cc
int32_t function_266ca(void) {
    // 0x266ca
    return function_26cde();
}

// Address range: 0x266cc - 0x266d0
int32_t function_266cc(int32_t a1) {
    // 0x266cc
    int32_t r_usage; // 0x266cc
    return getrusage(a1 + 1, (struct rusage *)r_usage);
}

// Address range: 0x266d0 - 0x266d4
int32_t function_266d0(void) {
    // 0x266d0
    return function_277ee(-0x13bef4e9);
}

// Address range: 0x266d6 - 0x266d8
int32_t function_266d6(void) {
    // 0x266d6
    return function_2655c();
}

// Address range: 0x266d8 - 0x266dc
int32_t function_266d8(int32_t a1, int32_t a2, int32_t a3) {
    // 0x266d8
    return function_26868(a1, a2);
}

// Address range: 0x266dc - 0x266e0
int32_t function_266dc(int32_t a1) {
    // 0x266dc
    return a1 + 92;
}

// Address range: 0x266e0 - 0x266e4
int32_t function_266e0(void) {
    // 0x266e0
    return 5;
}

// Address range: 0x266e4 - 0x266e8
int32_t function_266e4(void) {
    // 0x266e4
    int32_t v1; // 0x266e4
    return function_267ac(v1, v1, 194, v1);
}

// Address range: 0x266ea - 0x266ec
int32_t function_266ea(char a1) {
    // 0x266ea
    int32_t result; // 0x266ea
    return result;
}

// Address range: 0x266ec - 0x26710
int32_t function_266ec(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    if (4 * a3 == a4) {
        function_26750();
    }
    // 0x266f4
    return 1800;
}

// Address range: 0x26710 - 0x26714
int32_t function_26710(int32_t a1) {
    // 0x26710
    return function_26dba();
}

// Address range: 0x26714 - 0x26718
int32_t function_26714(void) {
    // 0x26714
    int32_t result; // 0x26714
    return result;
}

// Address range: 0x26718 - 0x2671c
int32_t function_26718(int32_t a1) {
    // 0x26718
    return function_26d34();
}

// Address range: 0x2671c - 0x26720
int32_t function_2671c(void) {
    // 0x2671c
    return function_26e62();
}

// Address range: 0x26720 - 0x26724
int32_t function_26720(int32_t a1, int32_t a2, int32_t a3) {
    // 0x26720
    return function_26db8();
}

// Address range: 0x26724 - 0x26728
int32_t function_26724(int32_t a1, int32_t a2, int32_t a3) {
    // 0x26724
    return function_268b4(a1);
}

// Address range: 0x26728 - 0x2672c
int32_t function_26728(void) {
    // 0x26728
    return function_26834(5);
}

// Address range: 0x2672c - 0x26730
int32_t function_2672c(void) {
    // 0x2672c
    return function_267f4();
}

// Address range: 0x26730 - 0x26750
int32_t function_26730(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11, int32_t a12) {
    // 0x26730
    if (a3 * a1 == a4) {
        // 0x2673c
        function_26250();
    }
    // 0x26740
    float64_t v1; // 0x26730
    __asm_vpop_18(v1, v1, v1, v1, v1);
    return 0;
}

// Address range: 0x26750 - 0x26764
int32_t function_26750(void) {
    // 0x26750
    function_3264c();
    return 1800;
}

// Address range: 0x26766 - 0x26768
int32_t function_26766(int32_t a1) {
    // 0x26766
    int32_t v1; // 0x26766
    return function_268f4(v1, v1, v1);
}

// Address range: 0x26768 - 0x2676c
int32_t function_26768(int32_t a1) {
    // 0x26768
    return function_26aae();
}

// Address range: 0x2676e - 0x26770
int32_t function_2676e(int32_t a1) {
    // 0x2676e
    return function_26878(a1);
}

// Address range: 0x26770 - 0x26780
int32_t function_26770(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x26770
    return result;
}

// Address range: 0x26780 - 0x26781
int32_t function_26780(void) {
    // 0x26780
    int32_t result; // 0x26780
    return result;
}

// Address range: 0x26782 - 0x26783
int32_t function_26782(void) {
    // 0x26782
    int32_t result; // 0x26782
    return result;
}

// Address range: 0x26784 - 0x26788
int32_t function_26784(int32_t a1) {
    // 0x26784
    return a1 + 92;
}

// Address range: 0x26788 - 0x2678c
int32_t function_26788(int32_t a1) {
    // 0x26788
    return function_26ace();
}

// Address range: 0x2678c - 0x26790
int32_t function_2678c(void) {
    // 0x2678c
    return function_268cc(-0x1a77ffc0);
}

// Address range: 0x26790 - 0x26794
int32_t function_26790(int32_t a1) {
    // 0x26790
    return function_2776e(-0x1a77ffc0);
}

// Address range: 0x26794 - 0x26798
int32_t function_26794(int32_t a1, int32_t a2, int32_t a3) {
    // 0x26794
    return function_26924(a1);
}

// Address range: 0x26798 - 0x267ac
int32_t function_26798(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x26798
    return result;
}

// Address range: 0x267ac - 0x267ae
int32_t function_267ac(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x267ac
    return result;
}

// Address range: 0x267ae - 0x267b8
int32_t function_267ae(int32_t a1) {
    // 0x267ae
    int32_t v1; // 0x267ae
    return (uint32_t)v1 / 0x2000 + a1;
}

// Address range: 0x267b8 - 0x267c0
int32_t function_267b8(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x267b8
    return function_26718(a1);
}

// Address range: 0x267c0 - 0x267c4
int32_t function_267c0(void) {
    // 0x267c0
    return function_31d38();
}

// Address range: 0x267c6 - 0x267c8
int32_t function_267c6(void) {
    // 0x267c6
    return function_27482();
}

// Address range: 0x267c8 - 0x267cc
int32_t function_267c8(void) {
    // 0x267c8
    int32_t result; // 0x267c8
    return result;
}

// Address range: 0x267cc - 0x267ce
int32_t function_267cc(int32_t a1) {
    // 0x267cc
    return a1 + 92;
}

// Address range: 0x267ce - 0x267d0
int32_t function_267ce(int32_t a1) {
    // 0x267ce
    return function_25e40(a1);
}

// Address range: 0x267d0 - 0x267d4
int32_t function_267d0(void) {
    // 0x267d0
    int32_t result; // 0x267d0
    return result;
}

// Address range: 0x267d4 - 0x267f4
int32_t function_267d4(void) {
    // 0x267d4
    if (g398 == 1) {
        function_26ae0();
    }
    // 0x267e8
    return function_26104();
}

// Address range: 0x267f4 - 0x267f8
int32_t function_267f4(void) {
    // 0x267f4
    __asm_adr(464);
    return function_26338();
}

// Address range: 0x267f8 - 0x267fc
int32_t function_267f8(void) {
    // 0x267f8
    return function_26e0a();
}

// Address range: 0x267fc - 0x26804
int32_t function_267fc(int32_t a1, int32_t a2, int32_t a3) {
    // 0x267fc
    __asm_ldc(a1, a2, a3);
    return function_27490();
}

// Address range: 0x26808 - 0x2680c
int32_t function_26808(int32_t a1) {
    // 0x26808
    return function_2700c(a1 + 3);
}

// Address range: 0x2680c - 0x26814
int32_t function_2680c(int32_t a1) {
    // 0x2680c
    __asm_ldc(0, 9, -0x2e5fdffc);
    return function_271ce();
}

// Address range: 0x26814 - 0x26818
int32_t function_26814(int32_t a1) {
    // 0x26814
    *(int32_t *)(2 * a1) = a1;
    return function_273e0();
}

// Address range: 0x26818 - 0x2681c
int32_t function_26818(int32_t a1) {
    // 0x26818
    return function_26eaa();
}

// Address range: 0x2681c - 0x26824
int32_t function_2681c(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x2681c
    __asm_mcr(0, 0, a4, 12, 0, 2);
    return function_273be();
}

// Address range: 0x26824 - 0x26828
int32_t function_26824(void) {
    // 0x26824
    return 4;
}

// Address range: 0x26828 - 0x2682c
int32_t function_26828(int32_t a1) {
    // 0x26828
    return a1 + 8;
}

// Address range: 0x2682c - 0x26830
int32_t function_2682c(void) {
    // 0x2682c
    int32_t result; // 0x2682c
    return result;
}

// Address range: 0x26830 - 0x26834
int32_t function_26830(int32_t result, int32_t a2) {
    // 0x26830
    return result;
}

// Address range: 0x26834 - 0x26838
int32_t function_26834(int32_t a1) {
    // 0x26834
    return function_26b7a(a1);
}

// Address range: 0x26838 - 0x2683c
int32_t function_26838(int32_t a1) {
    // 0x26838
    return function_26b7e(a1);
}

// Address range: 0x2683c - 0x2683e
int32_t function_2683c(void) {
    // 0x2683c
    __asm_udf(150);
    int32_t result; // 0x2683c
    return result;
}

// Address range: 0x26840 - 0x26854
int32_t function_26840(int32_t a1) {
    int32_t result = a1; // 0x2684c
    if (a1 == 0) {
        result = function_26954();
    }
    // 0x26850
    return result;
}

// Address range: 0x26856 - 0x26858
int32_t function_26856(int32_t a1) {
    // 0x26856
    return function_26e78(a1);
}

// Address range: 0x2685a - 0x2685c
int32_t function_2685a(void) {
    // 0x2685a
    int32_t v1; // 0x2685a
    return function_26398(v1);
}

// Address range: 0x2685c - 0x2685e
int32_t function_2685c(void) {
    // 0x2685c
    int32_t v1; // 0x2685c
    return function_26868(v1, v1);
}

// Address range: 0x2685e - 0x26860
int32_t function_2685e(void) {
    // 0x2685e
    int32_t result; // 0x2685e
    return result;
}

// Address range: 0x26860 - 0x26864
int32_t function_26860(int32_t a1) {
    // 0x26860
    return function_2678c();
}

// Address range: 0x26864 - 0x26868
int32_t function_26864(int32_t a1) {
    // 0x26864
    return function_26baa();
}

// Address range: 0x26868 - 0x2686c
int32_t function_26868(int32_t a1, int32_t a2) {
    // 0x26868
    return function_263a8(a2 & a1);
}

// Address range: 0x2686c - 0x26870
int32_t function_2686c(int32_t a1) {
    // 0x2686c
    int32_t v1; // 0x2686c
    return function_2638c(a1, v1, v1, v1);
}

// Address range: 0x26870 - 0x26874
int32_t function_26870(int32_t a1) {
    // 0x26870
    int32_t v1; // 0x26870
    return function_2697c(a1, a1, v1);
}

// Address range: 0x26874 - 0x26878
int32_t function_26874(int32_t a1) {
    // 0x26874
    return function_27482();
}

// Address range: 0x26878 - 0x2687c
int32_t function_26878(int32_t a1) {
    // 0x26878
    int32_t v1; // 0x26878
    return function_26a04(v1, v1, v1);
}

// Address range: 0x2687c - 0x26880
int32_t function_2687c(int32_t a1) {
    // 0x2687c
    return function_26bc2();
}

// Address range: 0x26880 - 0x26884
int32_t function_26880(int32_t a1) {
    // 0x26880
    int32_t v1; // 0x26880
    *(char *)(a1 + 4) = (char)v1;
    return function_267ae(a1);
}

// Address range: 0x26884 - 0x26888
int32_t function_26884(int32_t a1) {
    // 0x26884
    return function_2699a(64 * a1);
}

// Address range: 0x26888 - 0x2688c
int32_t function_26888(int32_t a1, int32_t a2) {
    // 0x26888
    return function_26f3c(a1, a2);
}

// Address range: 0x2688e - 0x26890
int32_t function_2688e(int32_t a1) {
    // 0x2688e
    return function_2700c(a1);
}

// Address range: 0x26890 - 0x26894
int32_t function_26890(int32_t result, int32_t a2, int32_t a3) {
    // 0x26890
    return result;
}

// Address range: 0x26898 - 0x2689c
int32_t function_26898(int32_t result) {
    // 0x26898
    return result;
}

// Address range: 0x2689c - 0x268a0
int32_t function_2689c(int32_t a1) {
    // 0x2689c
    return function_27482();
}

// Address range: 0x268a0 - 0x268a6
int32_t function_268a0(int32_t result, int32_t a2) {
    // 0x268a0
    *(char *)result = (char)a2;
    int32_t v1; // 0x268a0
    *(char *)(result + 4) = (char)v1;
    return result;
}

// Address range: 0x268a6 - 0x268ac
int32_t function_268a6(int32_t a1) {
    int32_t result = a1; // 0x268a6
    bool v1; // 0x268a6
    if (!v1) {
        result = function_267ae(a1);
    }
    // 0x268a8
    return result;
}

// Address range: 0x268ac - 0x268b0
int32_t function_268ac(int32_t result, int32_t a2) {
    // 0x268ac
    return result;
}

// Address range: 0x268b0 - 0x268b4
int32_t function_268b0(void) {
    // 0x268b0
    return 4;
}

// Address range: 0x268b4 - 0x268b8
int32_t function_268b4(int32_t a1) {
    // 0x268b4
    return function_31d38();
}

// Address range: 0x268b8 - 0x268bc
int32_t function_268b8(int32_t result) {
    // 0x268b8
    return result;
}

// Address range: 0x268bc - 0x268c0
int32_t function_268bc(int32_t a1, int32_t a2, int32_t a3) {
    // 0x268bc
    *(int32_t *)a1 = a3;
    return a1 + 4;
}

// Address range: 0x268c0 - 0x268c4
int32_t function_268c0(int32_t a1) {
    // 0x268c0
    return 0;
}

// Address range: 0x268c4 - 0x268c8
int32_t function_268c4(int32_t a1) {
    // 0x268c4
    int32_t v1; // 0x268c4
    return function_2696c(a1 + 3, v1, v1, v1);
}

// Address range: 0x268c8 - 0x268ca
int32_t function_268c8(void) {
    // 0x268c8
    int32_t v1; // 0x268c8
    return function_268d4(v1);
}

// Address range: 0x268ca - 0x268cc
int32_t function_268ca(void) {
    // 0x268ca
    int32_t result; // 0x268ca
    return result;
}

// Address range: 0x268cc - 0x268d0
int32_t function_268cc(int32_t a1) {
    // 0x268cc
    int32_t v1; // 0x268cc
    return function_26a6e(2, v1, v1, v1);
}

// Address range: 0x268d0 - 0x268d4
int32_t function_268d0(int32_t a1) {
    // 0x268d0
    return a1 + 96;
}

// Address range: 0x268d4 - 0x268d8
int32_t function_268d4(int32_t a1) {
    // 0x268d4
    return function_26a00(a1 + 4);
}

// Address range: 0x268d8 - 0x268f4
int32_t function_268d8(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x268d8
    *(int32_t *)(a1 + 100) = a3;
    bool v1; // 0x268d8
    int32_t v2; // 0x268d8
    int32_t v3 = v2 + a3 + (int32_t)(bool)v1; // 0x268dc
    *(int32_t *)v2 = a4;
    *(int32_t *)(v2 + 4) = v3;
    return function_600b4(a4, v3);
}

// Address range: 0x268f4 - 0x268fc
int32_t function_268f4(int32_t a1, int32_t a2, int32_t a3) {
    // 0x268f4
    __asm_mcrr(0, 0, a1, a2, 5);
    return function_272c2();
}

// Address range: 0x268fc - 0x268fd
int32_t function_268fc(void) {
    // 0x268fc
    int32_t result; // 0x268fc
    return result;
}

// Address range: 0x268fe - 0x2691e
int32_t function_268fe(void) {
    // 0x268fe
    bool v1; // 0x268fe
    if (v1) {
        function_2e23e6();
    }
    if (!v1) {
        function_fe4621a6();
        function_ffa2212a();
    }
    if (!v1) {
        function_2223f2();
    }
    int32_t v2; // 0x268fe
    if (v1) {
        v2 = function_2223da();
    } else {
        // 0x26912
        v2 = function_11e2326();
    }
    int32_t result = v2; // 0x26916
    // 0x2691a
    return result;
}

// Address range: 0x2691e - 0x26922
int32_t function_2691e(void) {
    // 0x2691e
    __asm_cdp(14, 11, 13, 0, 6, 7);
    int32_t result; // 0x2691e
    return result;
}

// Address range: 0x26924 - 0x26928
int32_t function_26924(int32_t result) {
    // 0x26924
    return result;
}

// Address range: 0x26928 - 0x2692c
int32_t function_26928(void) {
    // 0x26928
    return 4;
}

// Address range: 0x2692c - 0x26934
int32_t function_2692c(int32_t a1, int32_t a2) {
    // 0x2692c
    __asm_cdp(0, 3, 4, 8, 6, 0);
    int32_t v1; // 0x2692c
    return function_26a3c(a1, a2, v1, (int32_t)*(int16_t *)(a2 + 24));
}

// Address range: 0x26934 - 0x26938
int32_t function_26934(int32_t result) {
    // 0x26934
    return result;
}

// Address range: 0x26938 - 0x2693c
int32_t function_26938(int32_t result) {
    // 0x26938
    return result;
}

// Address range: 0x2693c - 0x26940
int32_t function_2693c(void) {
    // 0x2693c
    int32_t v1; // 0x2693c
    return v1 >> 1;
}

// Address range: 0x26940 - 0x26944
int32_t function_26940(void) {
    // 0x26940
    int32_t result; // 0x26940
    return result;
}

// Address range: 0x26944 - 0x26948
int32_t function_26944(int32_t a1) {
    // 0x26944
    return function_269f0(a1 + 1);
}

// Address range: 0x26948 - 0x2694c
int32_t function_26948(int32_t a1) {
    // 0x26948
    return function_26ad2(0);
}

// Address range: 0x2694c - 0x26950
int32_t function_2694c(int32_t result) {
    // 0x2694c
    return result;
}

// Address range: 0x26950 - 0x26954
int32_t function_26950(void) {
    // 0x26950
    return 4;
}

// Address range: 0x26954 - 0x26958
int32_t function_26954(void) {
    // 0x26954
    int32_t result; // 0x26954
    return result;
}

// Address range: 0x2695a - 0x2695c
int32_t function_2695a(int32_t a1) {
    // 0x2695a
    return function_2783a(a1);
}

// Address range: 0x2695e - 0x26960
int32_t function_2695e(int32_t a1) {
    // 0x2695e
    int32_t v1; // 0x2695e
    return function_2700c(v1);
}

// Address range: 0x26962 - 0x26964
int32_t function_26962(int32_t a1) {
    // 0x26962
    return function_26e78(a1);
}

// Address range: 0x26964 - 0x26968
int32_t function_26964(void) {
    // 0x26964
    int32_t result; // 0x26964
    bool v1; // 0x26964
    if (!v1) {
        int32_t v2; // 0x26964
        result = function_26834(v2);
    }
    // 0x26968
    return result;
}

// Address range: 0x2696c - 0x26970
int32_t function_2696c(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x2696c
    return function_26f72();
}

// Address range: 0x26970 - 0x2697c
int32_t function_26970(int32_t a1) {
    // 0x26970
    return function_1e2b4();
}

// Address range: 0x2697c - 0x26980
int32_t function_2697c(int32_t a1, int32_t a2, int32_t a3) {
    // 0x2697c
    return function_26f84(a3 >> 19);
}

// Address range: 0x26982 - 0x26984
int32_t function_26982(void) {
    // 0x26982
    return function_26f86();
}

// Address range: 0x26984 - 0x26998
int32_t function_26984(uint32_t a1, uint32_t a2) {
    // 0x26984
    float64_t v1; // 0x26984
    __asm_vmov_6(v1);
    int32_t chars_printed = sprintf((char *)(a1 % 0x10000 | (int32_t)&g357), (char *)(a2 % 0x10000 | 0x60000)); // 0x26990
    return chars_printed;
}

// Address range: 0x2699a - 0x2699c
int32_t function_2699a(int32_t a1) {
    int32_t result = function_27044(a1, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488); // 0x2699a
    return result;
}

// Address range: 0x2699c - 0x269ac
int32_t function_2699c(void) {
    // 0x2699c
    bool v1; // 0x2699c
    if (v1) {
        function_26ab0();
    }
    // 0x269a0
    return function_26104();
}

// Address range: 0x269ae - 0x269b0
int32_t function_269ae(void) {
    // 0x269ae
    return function_27482();
}

// Address range: 0x269b0 - 0x269b4
int32_t function_269b0(int32_t result) {
    // 0x269b0
    *(char *)(result + 1) = (char)result;
    return result;
}

// Address range: 0x269b8 - 0x269dc
int32_t function_269b8(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    if ((a4 || a3) == 0) {
        function_26aa4();
    }
    // 0x269c0
    return a3 - (int32_t)(*(int64_t *)&g354 / 0x100000000);
}

// Address range: 0x269de - 0x269e0
int32_t function_269de(void) {
    // 0x269de
    int32_t v1; // 0x269de
    return function_26a88(v1, v1, v1, v1);
}

// Address range: 0x269e0 - 0x269e4
int32_t function_269e0(void) {
    // 0x269e0
    return function_26828(160);
}

// Address range: 0x269e4 - 0x269e8
int32_t function_269e4(void) {
    // 0x269e4
    return 1;
}

// Address range: 0x269e8 - 0x269ec
int32_t function_269e8(int32_t a1) {
    // 0x269e8
    return function_26b14(a1 + 3);
}

// Address range: 0x269ee - 0x269f0
int32_t function_269ee(int32_t a1) {
    // 0x269ee
    return function_26b36(a1);
}

// Address range: 0x269f0 - 0x269f4
int32_t function_269f0(int32_t a1) {
    // 0x269f0
    return function_26b1c();
}

// Address range: 0x269f4 - 0x26a00
int32_t function_269f4(int32_t a1, int32_t a2, int32_t a3) {
    // 0x269f4
    bool v1; // 0x269f4
    int32_t result = function_600b4(a1, a3 + a2 + (int32_t)(bool)v1); // 0x269f8
    __asm_vldr(0);
    return result;
}

// Address range: 0x26a00 - 0x26a04
int32_t function_26a00(int32_t a1) {
    // 0x26a00
    int32_t v1; // 0x26a00
    return function_270b4(a1, v1, v1);
}

// Address range: 0x26a04 - 0x26a0c
int32_t function_26a04(int32_t a1, int32_t a2, int32_t a3) {
    // 0x26a04
    __asm_mcrr(12, 1, a3, a2, 7);
    return function_2701a();
}

// Address range: 0x26a0c - 0x26a10
int32_t function_26a0c(void) {
    // 0x26a0c
    int32_t v1; // 0x26a0c
    return function_26542(v1, v1, v1, v1);
}

// Address range: 0x26a10 - 0x26a14
int32_t function_26a10(void) {
    // 0x26a10
    int32_t v1; // 0x26a10
    return function_27098(v1, v1, v1);
}

// Address range: 0x26a16 - 0x26a18
int32_t function_26a16(void) {
    // 0x26a16
    return function_2715a();
}

// Address range: 0x26a1a - 0x26a1c
int32_t function_26a1a(void) {
    // 0x26a1a
    return function_2655c();
}

// Address range: 0x26a1c - 0x26a1e
int32_t function_26a1c(int32_t result) {
    // 0x26a1c
    return result;
}

// Address range: 0x26a1e - 0x26a2c
int32_t function_26a1e(void) {
    // 0x26a1e
    bool v1; // 0x26a1e
    if (!v1) {
        // 0x26a22
        function_fe46243e();
        function_ff9ee246();
    }
    // 0x26a26
    int32_t v2; // 0x26a1e
    return function_2727c(v2 - 2);
}

// Address range: 0x26a2c - 0x26a30
int32_t function_26a2c(int32_t a1, int32_t a2, int32_t a3) {
    // 0x26a2c
    return function_26b34();
}

// Address range: 0x26a30 - 0x26a34
int32_t function_26a30(void) {
    // 0x26a30
    return function_2705a(1);
}

// Address range: 0x26a34 - 0x26a38
int32_t function_26a34(void) {
    // 0x26a34
    int32_t result; // 0x26a34
    return result;
}

// Address range: 0x26a38 - 0x26a3c
int32_t function_26a38(void) {
    // 0x26a38
    int32_t result; // 0x26a38
    return result;
}

// Address range: 0x26a3c - 0x26a40
int32_t function_26a3c(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x26a3c
    *(int32_t *)a2 = a2;
    *(int32_t *)(a2 + 4) = a3;
    *(int32_t *)(a2 + 8) = a4;
    return function_26b04(a1);
}

// Address range: 0x26a40 - 0x26a44
int32_t function_26a40(int32_t a1) {
    // 0x26a40
    return function_26b56(a1);
}

// Address range: 0x26a46 - 0x26a5c
int32_t function_26a46(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x26a46
    __asm_vldr(-0x1cfccd40);
    __asm_stc(0, 0, *(int32_t *)(a2 + 12));
    __asm_ldc_20(15, 0, a4, 360);
    return function_2778a((int32_t)*(char *)(a1 + 13));
}

// Address range: 0x26a5c - 0x26a68
int32_t function_26a5c(int32_t a1) {
    // 0x26a5c
    __asm_mrc(0, 1, a1, 7, 6, 1);
    return function_2682c();
}

// Address range: 0x26a6e - 0x26a72
int32_t function_26a6e(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x26a6e
    return result;
}

// Address range: 0x26a72 - 0x26a86
int32_t function_26a72(int32_t a1) {
    int32_t v1 = a1; // 0x26a72
    bool v2; // 0x26a72
    if (v2) {
        v1 = function_ff9e2292();
    }
    int32_t v3 = v1; // 0x26a76
    if (!v2) {
        v3 = function_1e255e();
    }
    // 0x26a7a
    if (!v2) {
        __asm_svclo(0xc8ee87);
    }
    int32_t result = v3; // 0x26a82
    if (v2) {
        result = function_119f78a();
    }
    // 0x26a86
    return result;
}

// Address range: 0x26a88 - 0x26a8e
int32_t function_26a88(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x26a88
    __asm_stc(14, 13, *(int32_t *)(a4 + 68));
    int32_t v1; // 0x26a88
    return (int32_t)*(int16_t *)(v1 + a1);
}

// Address range: 0x26a90 - 0x26a94
int32_t function_26a90(int32_t a1) {
    // 0x26a90
    return function_265c6();
}

// Address range: 0x26a94 - 0x26a98
int32_t function_26a94(int32_t a1, int32_t a2, int32_t a3) {
    // 0x26a94
    return function_2776e(8 * a3);
}

// Address range: 0x26a98 - 0x26a9c
int32_t function_26a98(void) {
    // 0x26a98
    return function_268fc();
}

// Address range: 0x26a9e - 0x26aa0
int32_t function_26a9e(void) {
    // 0x26a9e
    return function_26e2c();
}

// Address range: 0x26aa0 - 0x26aa4
int32_t function_26aa0(void) {
    // 0x26aa0
    int32_t result; // 0x26aa0
    return result;
}

// Address range: 0x26aa4 - 0x26aa8
int32_t function_26aa4(void) {
    // 0x26aa4
    int32_t result; // 0x26aa4
    return result;
}

// Address range: 0x26aaa - 0x26aac
int32_t function_26aaa(int32_t a1) {
    // 0x26aaa
    return function_26dee(a1);
}

// Address range: 0x26aae - 0x26aaf
int32_t function_26aae(void) {
    // 0x26aae
    int32_t result; // 0x26aae
    return result;
}

// Address range: 0x26ab0 - 0x26acc
int32_t function_26ab0(void) {
    // 0x26ab0
    g354 = 0;
    g355 = 0;
    return &g356;
}

// Address range: 0x26ace - 0x26acf
int32_t function_26ace(void) {
    // 0x26ace
    int32_t result; // 0x26ace
    return result;
}

// Address range: 0x26ad2 - 0x26ad4
int32_t function_26ad2(int32_t a1) {
    // 0x26ad2
    int32_t v1; // 0x26ad2
    return function_27216(a1, v1, v1);
}

// Address range: 0x26ad4 - 0x26ae0
int32_t function_26ad4(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x26ad4
    int32_t v1; // 0x26ad4
    *(int32_t *)(v1 + 3400) = a4;
    *(int32_t *)v1 = a4;
    return result;
}

// Address range: 0x26ae0 - 0x26b04
int32_t function_26ae0(void) {
    // 0x26ae0
    int32_t v1; // 0x26ae0
    memset((int32_t *)(v1 + 96), v1, 320);
    return (int32_t)memset((int32_t *)(v1 + 416), v1, 32);
}

// Address range: 0x26b04 - 0x26b08
int32_t function_26b04(int32_t a1) {
    // 0x26b04
    return function_274ce();
}

// Address range: 0x26b08 - 0x26b14
int32_t function_26b08(void) {
    // 0x26b08
    int32_t v1; // 0x26b08
    return (int32_t)memset((int32_t *)(v1 + 448), v1, v1);
}

// Address range: 0x26b14 - 0x26b18
int32_t function_26b14(uint32_t a1) {
    // 0x26b14
    int32_t v1; // 0x26b14
    uint32_t v2 = v1;
    return a1 << 32 - v2 | a1 >> v2;
}

// Address range: 0x26b18 - 0x26b1c
int32_t function_26b18(int32_t result) {
    // 0x26b18
    return result;
}

// Address range: 0x26b1c - 0x26b20
int32_t function_26b1c(void) {
    // 0x26b1c
    int32_t result; // 0x26b1c
    return result;
}

// Address range: 0x26b20 - 0x26b24
int32_t function_26b20(uint32_t a1) {
    // 0x26b20
    int32_t v1; // 0x26b20
    uint32_t v2 = v1;
    return a1 << 32 - v2 | a1 >> v2;
}

// Address range: 0x26b24 - 0x26b28
int32_t function_26b24(void) {
    // 0x26b24
    int32_t result; // 0x26b24
    return result;
}

// Address range: 0x26b2a - 0x26b2c
int32_t function_26b2a(void) {
    // 0x26b2a
    return function_2663e();
}

// Address range: 0x26b2e - 0x26b30
int32_t function_26b2e(void) {
    // 0x26b2e
    int32_t v1; // 0x26b2e
    return function_26642(v1);
}

// Address range: 0x26b30 - 0x26b34
int32_t function_26b30(void) {
    // 0x26b30
    int32_t result; // 0x26b30
    return result;
}

// Address range: 0x26b34 - 0x26b35
int32_t function_26b34(void) {
    // 0x26b34
    int32_t result; // 0x26b34
    return result;
}

// Address range: 0x26b36 - 0x26b37
int32_t function_26b36(int32_t a1) {
    // 0x26b36
    int32_t result; // 0x26b36
    return result;
}

// Address range: 0x26b38 - 0x26b40
int32_t function_26b38(void) {
    // 0x26b38
    return function_267cc(function_2d158());
}

// Address range: 0x26b40 - 0x26b50
int32_t function_26b40(int32_t result, int32_t a2, int32_t a3) {
    // 0x26b40
    __asm_vldr(0);
    return result;
}

// Address range: 0x26b56 - 0x26b5a
int32_t function_26b56(int32_t result) {
    // 0x26b56
    return result;
}

// Address range: 0x26b62 - 0x26b78
int32_t function_26b62(int32_t a1, int32_t a2) {
    // 0x26b62
    int32_t v1; // 0x26b62
    uint32_t v2 = v1;
    *(int16_t *)v2 = (int16_t)v2;
    int64_t v3 = (uint32_t)v1; // 0x26b70
    uint64_t v4 = (int64_t)v2 * v3; // 0x26b70
    uint64_t v5 = v4 / 0x100000000; // 0x26b70
    int64_t v6 = v4 < 0xffffffff00000001 ? v4 : v4 + 0xffffffff; // 0x26b74
    return ((v5 | v6) + v5 * v3) / 0x100000000;
}

// Address range: 0x26b7a - 0x26b7c
int32_t function_26b7a(int32_t result) {
    // 0x26b7a
    return result;
}

// Address range: 0x26b7e - 0x26b82
int32_t function_26b7e(int32_t a1) {
    // 0x26b7e
    int32_t v1; // 0x26b7e
    return function_26b8c(a1, v1, v1);
}

// Address range: 0x26b82 - 0x26b84
int32_t function_26b82(void) {
    // 0x26b82
    int32_t result; // 0x26b82
    return result;
}

// Address range: 0x26b84 - 0x26b88
int32_t function_26b84(int32_t a1) {
    // 0x26b84
    return function_272ca();
}

// Address range: 0x26b88 - 0x26b8c
int32_t function_26b88(void) {
    // 0x26b88
    int32_t v1; // 0x26b88
    bool v2; // 0x26b88
    int32_t v3; // 0x26b88
    if (v2) {
        v1 = function_26ba4(v3);
    }
    // 0x26b8a
    return function_27028(v1, v3);
}

// Address range: 0x26b8c - 0x26b90
int32_t function_26b8c(int32_t a1, int32_t a2, int32_t a3) {
    // 0x26b8c
    return function_27198(a3 >> 10, a2);
}

// Address range: 0x26b90 - 0x26b94
int32_t function_26b90(void) {
    // 0x26b90
    int32_t v1; // 0x26b90
    return function_271b4(v1);
}

// Address range: 0x26b94 - 0x26b98
int32_t function_26b94(void) {
    // 0x26b94
    return function_26eda();
}

// Address range: 0x26b98 - 0x26b9c
int32_t function_26b98(int32_t a1) {
    // 0x26b98
    return function_266b8(a1);
}

// Address range: 0x26b9c - 0x26ba0
int32_t function_26b9c(int32_t result) {
    // 0x26b9c
    return result;
}

// Address range: 0x26ba0 - 0x26ba4
int32_t function_26ba0(int32_t a1, int32_t a2) {
    // 0x26ba0
    return function_272e6();
}

// Address range: 0x26ba4 - 0x26ba6
int32_t function_26ba4(int32_t result) {
    // 0x26ba4
    return result;
}

// Address range: 0x26ba6 - 0x26ba8
int32_t function_26ba6(void) {
    // 0x26ba6
    int32_t v1; // 0x26ba6
    return function_2722a(v1, v1, v1, v1);
}

// Address range: 0x26baa - 0x26bab
int32_t function_26baa(void) {
    // 0x26baa
    int32_t result; // 0x26baa
    return result;
}

// Address range: 0x26bac - 0x26bbc
int32_t function_26bac(void) {
    // 0x26bac
    function_25db0();
    return function_304d4(1000);
}

// Address range: 0x26bbe - 0x26bc0
int32_t function_26bbe(char a1) {
    // 0x26bbe
    return function_266ea(a1);
}

// Address range: 0x26bc2 - 0x26bc4
int32_t function_26bc2(void) {
    // 0x26bc2
    int32_t v1; // 0x26bc2
    return function_27268(v1);
}

// Address range: 0x26bc4 - 0x26bd4
int32_t function_26bc4(void) {
    // 0x26bc4
    bool v1; // 0x26bc4
    if (!v1) {
        function_26bac();
    }
    // 0x26bc8
    int32_t v2; // 0x26bc4
    function_13da4(400, v2);
    return function_26bac();
}

// Address range: 0x26bd4 - 0x26bd5
int32_t function_26bd4(void) {
    // 0x26bd4
    int32_t result; // 0x26bd4
    return result;
}

// Address range: 0x26bd8 - 0x26bdc
int32_t function_26bd8(int32_t who, struct rusage * usage) {
    // 0x26bd8
    return function_27078(getrusage(who, usage));
}

// Address range: 0x26bdc - 0x26c3c
int32_t function_26bdc(int32_t a1, int32_t a2) {
    // 0x26bdc
    int32_t v1; // bp+48, 0x26bdc
    memset(&v1, 0, 256);
    int32_t result = g359; // 0x26c08
    if (g359 == 0) {
        result = function_26f20();
    }
    // 0x26c0c
    return result;
}

// Address range: 0x26c3e - 0x26c40
int32_t function_26c3e(void) {
    // 0x26c3e
    return function_272c2();
}

// Address range: 0x26c40 - 0x26c58
int32_t function_26c40(void) {
    // 0x26c40
    int32_t v1; // 0x26c40
    function_54cb0(v1, (char *)v1, 8, (char *)v1, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488);
    int32_t v2 = *(int32_t *)(v1 + 3404); // 0x26c48
    int32_t result = v2; // 0x26c50
    if (v2 == 0) {
        result = function_26f0c();
    }
    // 0x26c54
    return result;
}

// Address range: 0x26c5c - 0x26c60
int32_t function_26c5c(int32_t a1) {
    // 0x26c5c
    return function_26e00(a1 + 6);
}

// Address range: 0x26c60 - 0x26c64
int32_t function_26c60(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x26c60
    return function_273a6(a1, a4 - 6, a3, a4);
}

// Address range: 0x26c64 - 0x26c68
int32_t function_26c64(void) {
    // 0x26c64
    return function_26784(0);
}

// Address range: 0x26c68 - 0x26c6c
int32_t function_26c68(void) {
    // 0x26c68
    return function_27274();
}

// Address range: 0x26c6c - 0x26c70
int32_t function_26c6c(int32_t a1, int32_t a2, int32_t a3) {
    // 0x26c6c
    *(int32_t *)a1 = a3;
    return function_26ef0(a1 + 8);
}

// Address range: 0x26c70 - 0x26c74
int32_t function_26c70(int32_t a1) {
    // 0x26c70
    return function_26790(a1 + 12);
}

// Address range: 0x26c74 - 0x26c75
int32_t function_26c74(int32_t a1) {
    // 0x26c74
    int32_t result; // 0x26c74
    return result;
}

// Address range: 0x26c76 - 0x26c78
int32_t function_26c76(void) {
    // 0x26c76
    int32_t v1; // 0x26c76
    return function_26794(v1, v1, v1);
}

// Address range: 0x26c78 - 0x26c7c
int32_t function_26c78(void) {
    // 0x26c78
    return function_2781c(6);
}

// Address range: 0x26c7e - 0x26c80
int32_t function_26c7e(void) {
    // 0x26c7e
    return function_27288();
}

// Address range: 0x26c82 - 0x26c84
int32_t function_26c82(int32_t a1) {
    // 0x26c82
    return function_272a0(a1);
}

// Address range: 0x26c84 - 0x26cac
int32_t function_26c84(int32_t a1, uint32_t a2, int32_t a3, uint32_t a4) {
    // 0x26c84
    int32_t v1; // 0x26c84
    int32_t result = function_54cb0(a1, (char *)(a2 % 0x10000 | 0x60000), 8, (char *)(a4 % 0x10000 | 0x60000), v1, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488); // 0x26c9c
    return result;
}

// Address range: 0x26cae - 0x26cb0
int32_t function_26cae(void) {
    // 0x26cae
    int32_t v1; // 0x26cae
    return function_267cc(v1);
}

// Address range: 0x26cb0 - 0x26cc8
int32_t function_26cb0(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t result = 0; // 0x26cc0
    int32_t v1; // 0x26cb0
    if (function_1e29c(v1) != 0) {
        result = function_26cd8((int32_t)&g488);
    }
    // 0x26cc4
    return result;
}

// Address range: 0x26cca - 0x26ccc
int32_t function_26cca(int32_t a1) {
    // 0x26cca
    return function_2737e(a1);
}

// Address range: 0x26ccc - 0x26cd8
int32_t function_26ccc(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    // 0x26ccc
    int32_t result; // 0x26ccc
    return result;
}

// Address range: 0x26cd8 - 0x26cdc
int32_t function_26cd8(int32_t a1) {
    // 0x26cd8
    int32_t result; // 0x26cd8
    return result;
}

// Address range: 0x26cde - 0x26ce0
int32_t function_26cde(void) {
    // 0x26cde
    int32_t v1; // 0x26cde
    return function_26808(v1);
}

// Address range: 0x26ce0 - 0x26ce8
int32_t function_26ce0(int32_t a1) {
    int32_t result = a1; // 0x26ce4
    if (a1 == 0) {
        result = function_26ec4((int32_t)&g488);
    }
    // 0x26ce8
    return result;
}

// Address range: 0x26cea - 0x26cec
int32_t function_26cea(int32_t a1) {
    // 0x26cea
    return function_26828(a1);
}

// Address range: 0x26cec - 0x26cf0
int32_t function_26cec(int32_t a1, int32_t a2, int32_t a3) {
    // 0x26cec
    return function_27432();
}

// Address range: 0x26cf2 - 0x26cf4
int32_t function_26cf2(void) {
    // 0x26cf2
    int32_t v1; // 0x26cf2
    return function_27436(v1, v1, v1, v1);
}

// Address range: 0x26cf4 - 0x26cf8
int32_t function_26cf4(void) {
    // 0x26cf4
    return 28;
}

// Address range: 0x26cf8 - 0x26cfc
int32_t function_26cf8(int32_t a1, int32_t a2) {
    // 0x26cf8
    return function_26818(0);
}

// Address range: 0x26cfc - 0x26d00
int32_t function_26cfc(int32_t a1) {
    // 0x26cfc
    return function_27308(a1 + 28);
}

// Address range: 0x26d00 - 0x26d04
int32_t function_26d00(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x26d00
    return function_27320(a1);
}

// Address range: 0x26d04 - 0x26d06
int32_t function_26d04(void) {
    // 0x26d04
    return function_26d20();
}

// Address range: 0x26d06 - 0x26d08
int32_t function_26d06(void) {
    // 0x26d06
    return function_26824();
}

// Address range: 0x26d08 - 0x26d0c
int32_t function_26d08(int32_t a1) {
    // 0x26d08
    return function_276d2(a1 + 6);
}

// Address range: 0x26d0e - 0x26d10
int32_t function_26d0e(void) {
    // 0x26d0e
    return function_2682c();
}

// Address range: 0x26d10 - 0x26d14
int32_t function_26d10(int32_t a1) {
    // 0x26d10
    return function_27396();
}

// Address range: 0x26d14 - 0x26d18
int32_t function_26d14(void) {
    // 0x26d14
    return function_26834(0);
}

// Address range: 0x26d18 - 0x26d1c
int32_t function_26d18(int32_t a1, int32_t a2, int32_t a3) {
    // 0x26d18
    *(int16_t *)a3 = (int16_t)a1;
    return function_26838(a1);
}

// Address range: 0x26d1c - 0x26d20
int32_t function_26d1c(void) {
    // 0x26d1c
    return function_26fa0(8);
}

// Address range: 0x26d20 - 0x26d21
int32_t function_26d20(void) {
    // 0x26d20
    int32_t result; // 0x26d20
    return result;
}

// Address range: 0x26d24 - 0x26d28
int32_t function_26d24(void) {
    // 0x26d24
    return function_1e0f0();
}

// Address range: 0x26d2a - 0x26d2c
int32_t function_26d2a(void) {
    // 0x26d2a
    return function_271ce();
}

// Address range: 0x26d2c - 0x26d34
int32_t function_26d2c(int32_t a1) {
    // 0x26d2c
    int32_t result; // 0x26d2c
    bool v1; // 0x26d2c
    if (v1 || false) {
        result = function_26e04((int32_t)&g488);
    }
    // 0x26d30
    return result;
}

// Address range: 0x26d34 - 0x26d38
int32_t function_26d34(void) {
    // 0x26d34
    return function_27340();
}

// Address range: 0x26d3a - 0x26d3c
int32_t function_26d3a(void) {
    // 0x26d3a
    return function_273be();
}

// Address range: 0x26d3e - 0x26d40
int32_t function_26d3e(void) {
    // 0x26d3e
    return function_27482();
}

// Address range: 0x26d40 - 0x26d44
int32_t function_26d40(int32_t a1) {
    // 0x26d40
    int32_t v1; // 0x26d40
    *(int16_t *)v1 = (int16_t)a1;
    return function_26860(a1);
}

// Address range: 0x26d44 - 0x26d48
int32_t function_26d44(int32_t a1) {
    // 0x26d44
    int32_t v1; // 0x26d44
    *(char *)a1 = (char)v1;
    return function_271d0(a1);
}

// Address range: 0x26d48 - 0x26d4c
int32_t function_26d48(int32_t a1) {
    // 0x26d48
    int32_t v1; // 0x26d48
    return function_27354(a1 + 28, v1);
}

// Address range: 0x26d4c - 0x26d50
int32_t function_26d4c(int32_t a1, int32_t a2) {
    // 0x26d4c
    *(char *)(a2 + 20) = (char)a1;
    return function_26e60(a1);
}

// Address range: 0x26d50 - 0x26d54
int32_t function_26d50(int32_t a1) {
    // 0x26d50
    return function_273d6();
}

// Address range: 0x26d54 - 0x26d58
int32_t function_26d54(int32_t a1) {
    // 0x26d54
    return function_26874(a1 + 28);
}

// Address range: 0x26d58 - 0x26d5c
int32_t function_26d58(int32_t a1, int32_t a2, int32_t a3) {
    // 0x26d58
    *(int32_t *)a1 = a3;
    return function_268cc(a1 + 4);
}

// Address range: 0x26d5c - 0x26d60
int32_t function_26d5c(int32_t a1) {
    // 0x26d5c
    int32_t v1; // 0x26d5c
    return function_2722a(a1, a1, v1, v1);
}

// Address range: 0x26d60 - 0x26d64
int32_t function_26d60(int32_t a1) {
    // 0x26d60
    return function_270a6(a1 + 5);
}

// Address range: 0x26d66 - 0x26d68
int32_t function_26d66(int32_t a1) {
    // 0x26d66
    return function_277ee(a1);
}

// Address range: 0x26d68 - 0x26d6c
int32_t function_26d68(int32_t a1) {
    // 0x26d68
    return function_26e82();
}

// Address range: 0x26d6e - 0x26d70
int32_t function_26d6e(int32_t a1) {
    // 0x26d6e
    return function_2727c(a1);
}

// Address range: 0x26d70 - 0x26d7c
int32_t function_26d70(void) {
    // 0x26d70
    int32_t str; // 0x26d70
    return snprintf((char *)str, str, (char *)str);
}

// Address range: 0x26d7c - 0x26d7e
int32_t function_26d7c(void) {
    // 0x26d7c
    int32_t result; // 0x26d7c
    bool v1; // 0x26d7c
    if (!v1 && true) {
        result = function_27482();
    }
    // 0x26d7e
    return result;
}

// Address range: 0x26d80 - 0x26d9c
int32_t function_26d80(int32_t a1, int32_t a2) {
    // 0x26d80
    int32_t v1; // 0x26d80
    int32_t result = function_5fd8c(v1, a1, v1, v1); // 0x26d94
    if (a1 != 0) {
        result = function_26df4();
    }
    // 0x26d98
    return result;
}

// Address range: 0x26d9c - 0x26d9e
int32_t function_26d9c(int32_t result) {
    // 0x26d9c
    return result;
}

// Address range: 0x26d9e - 0x26da0
int32_t function_26d9e(void) {
    // 0x26d9e
    return function_274e2();
}

// Address range: 0x26da2 - 0x26da4
int32_t function_26da2(int32_t a1) {
    // 0x26da2
    return function_268cc(a1);
}

// Address range: 0x26da4 - 0x26da8
int32_t function_26da4(int32_t a1) {
    // 0x26da4
    return function_2705a((int32_t)&g488);
}

// Address range: 0x26da8 - 0x26db0
int32_t function_26da8(uint32_t a1, int32_t a2) {
    // 0x26da8
    return function_271f8(a1 / 256, 0);
}

// Address range: 0x26db0 - 0x26db4
int32_t function_26db0(int32_t a1) {
    // 0x26db0
    return function_270f6();
}

// Address range: 0x26db4 - 0x26db8
int32_t function_26db4(void) {
    // 0x26db4
    return function_268d4(__asm_adr(80));
}

// Address range: 0x26db8 - 0x26dba
int32_t function_26db8(void) {
    // 0x26db8
    int32_t v1; // 0x26db8
    return function_27458(v1);
}

// Address range: 0x26dba - 0x26dbb
int32_t function_26dba(void) {
    // 0x26dba
    int32_t result; // 0x26dba
    return result;
}

// Address range: 0x26dbc - 0x26dc0
int32_t function_26dbc(int32_t a1) {
    // 0x26dbc
    return function_268fc();
}

// Address range: 0x26dc0 - 0x26dc4
int32_t function_26dc0(void) {
    // 0x26dc0
    return function_27506(28);
}

// Address range: 0x26dc4 - 0x26dc6
int32_t function_26dc4(void) {
    // 0x26dc4
    return function_26df0();
}

// Address range: 0x26dc6 - 0x26dc8
int32_t function_26dc6(void) {
    // 0x26dc6
    return function_2784e();
}

// Address range: 0x26dc8 - 0x26dcc
int32_t function_26dc8(int32_t a1, int32_t a2, int32_t a3) {
    // 0x26dc8
    *(int32_t *)a3 = a1;
    return function_27712();
}

// Address range: 0x26dcc - 0x26dd0
int32_t function_26dcc(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x26dcc
    return function_2746e();
}

// Address range: 0x26dd0 - 0x26dd4
int32_t function_26dd0(int32_t a1, int32_t a2, int32_t result) {
    // 0x26dd0
    return result;
}

// Address range: 0x26dd4 - 0x26dd8
int32_t function_26dd4(int32_t a1) {
    // 0x26dd4
    int32_t v1; // 0x26dd4
    return function_268f4(a1 + 12, v1, v1);
}

// Address range: 0x26dd8 - 0x26ddc
int32_t function_26dd8(int32_t a1, int32_t a2) {
    // 0x26dd8
    return function_26fa0(a2);
}

// Address range: 0x26dde - 0x26de0
int32_t function_26dde(void) {
    // 0x26dde
    return function_268fc();
}

// Address range: 0x26de0 - 0x26de4
int32_t function_26de0(int32_t a1) {
    // 0x26de0
    return function_277aa(a1);
}

// Address range: 0x26de8 - 0x26dec
int32_t function_26de8(void) {
    // 0x26de8
    return function_2752e();
}

// Address range: 0x26dee - 0x26df0
int32_t function_26dee(int32_t a1) {
    // 0x26dee
    int32_t v1; // 0x26dee
    return function_2692c(v1, v1);
}

// Address range: 0x26df0 - 0x26df1
int32_t function_26df0(void) {
    // 0x26df0
    int32_t result; // 0x26df0
    return result;
}

// Address range: 0x26df4 - 0x26e00
int32_t function_26df4(void) {
    // 0x26df4
    int32_t result; // 0x26df4
    return result;
}

// Address range: 0x26e00 - 0x26e04
int32_t function_26e00(int32_t a1) {
    // 0x26e00
    int32_t v1; // 0x26e00
    *(int16_t *)v1 = (int16_t)a1;
    return function_26940();
}

// Address range: 0x26e04 - 0x26e08
int32_t function_26e04(int32_t a1) {
    // 0x26e04
    int32_t result; // 0x26e04
    return result;
}

// Address range: 0x26e0a - 0x26e0c
int32_t function_26e0a(void) {
    // 0x26e0a
    int32_t v1; // 0x26e0a
    return function_26934(v1);
}

// Address range: 0x26e0c - 0x26e10
int32_t function_26e0c(int32_t a1) {
    // 0x26e0c
    return function_274b2();
}

// Address range: 0x26e10 - 0x26e18
int32_t function_26e10(uint32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x26e10
    return function_27420(a1 / 256, a2, a3);
}

// Address range: 0x26e18 - 0x26e1c
int32_t function_26e18(int32_t a1, int32_t a2, int32_t a3) {
    // 0x26e18
    return function_278a2();
}

// Address range: 0x26e1c - 0x26e20
int32_t function_26e1c(int32_t a1) {
    // 0x26e1c
    return function_274a2(a1 + 6);
}

// Address range: 0x26e20 - 0x26e22
int32_t function_26e20(int32_t a1) {
    // 0x26e20
    int32_t v1; // 0x26e20
    return function_26e24(a1, v1, v1);
}

// Address range: 0x26e22 - 0x26e24
int32_t function_26e22(void) {
    // 0x26e22
    return function_27566();
}

// Address range: 0x26e24 - 0x26e26
int32_t function_26e24(int32_t result, int32_t a2, int32_t a3) {
    // 0x26e24
    *(int32_t *)a3 = a2;
    *(int32_t *)(a3 + 4) = a3;
    return result;
}

// Address range: 0x26e26 - 0x26e28
int32_t function_26e26(int32_t a1) {
    // 0x26e26
    return function_2776e(a1);
}

// Address range: 0x26e28 - 0x26e2c
int32_t function_26e28(int32_t a1) {
    // 0x26e28
    return function_26948(a1 + 12);
}

// Address range: 0x26e2c - 0x26e30
int32_t function_26e2c(void) {
    // 0x26e2c
    return function_27572();
}

// Address range: 0x26e30 - 0x26e34
int32_t function_26e30(int32_t a1, int32_t a2) {
    // 0x26e30
    return function_26950();
}

// Address range: 0x26e34 - 0x26e38
int32_t function_26e34(int32_t a1) {
    // 0x26e34
    return function_27440(a1 + 28);
}

// Address range: 0x26e38 - 0x26e39
int32_t function_26e38(void) {
    // 0x26e38
    int32_t result; // 0x26e38
    return result;
}

// Address range: 0x26e3a - 0x26e3c
int32_t function_26e3a(int32_t a1) {
    // 0x26e3a
    return function_27458(a1);
}

// Address range: 0x26e40 - 0x26e44
int32_t function_26e40(int32_t a1) {
    // 0x26e40
    return function_274c6();
}

// Address range: 0x26e44 - 0x26e48
int32_t function_26e44(int32_t a1, int32_t a2, int32_t a3) {
    // 0x26e44
    *(int16_t *)a3 = (int16_t)a1;
    return function_26964();
}

// Address range: 0x26e4a - 0x26e4c
int32_t function_26e4a(void) {
    // 0x26e4a
    return function_274ce();
}

// Address range: 0x26e4c - 0x26e60
int32_t function_26e4c(int32_t a1) {
    // 0x26e4c
    int32_t v1; // 0x26e4c
    function_54cb0(v1, (char *)v1, 8, (char *)v1, v1, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488);
    return *(int32_t *)(a1 + 3404);
}

// Address range: 0x26e60 - 0x26e62
int32_t function_26e60(int32_t result) {
    // 0x26e60
    return result;
}

// Address range: 0x26e62 - 0x26e64
int32_t function_26e62(void) {
    // 0x26e62
    int32_t v1; // 0x26e62
    return function_27506(v1);
}

// Address range: 0x26e64 - 0x26e68
int32_t function_26e64(void) {
    // 0x26e64
    int32_t result; // 0x26e64
    bool v1; // 0x26e64
    if (v1) {
        result = function_26edc();
    }
    // 0x26e68
    return result;
}

// Address range: 0x26e6a - 0x26e6c
int32_t function_26e6a(void) {
    // 0x26e6a
    return function_27482();
}

// Address range: 0x26e6c - 0x26e70
int32_t function_26e6c(int32_t a1, int32_t a2, int32_t a3) {
    // 0x26e6c
    return function_275b2();
}

// Address range: 0x26e72 - 0x26e74
int32_t function_26e72(int32_t a1) {
    // 0x26e72
    return function_2783a(a1);
}

// Address range: 0x26e74 - 0x26e78
int32_t function_26e74(int32_t a1, int32_t a2, int32_t a3) {
    // 0x26e74
    *(int32_t *)a3 = a1;
    *(int32_t *)(a3 + 4) = a2;
    *(int32_t *)(a3 + 8) = a3;
    return function_277be();
}

// Address range: 0x26e78 - 0x26e7c
int32_t function_26e78(int32_t a1) {
    // 0x26e78
    return function_270fc(28);
}

// Address range: 0x26e7c - 0x26e80
int32_t function_26e7c(int32_t a1) {
    // 0x26e7c
    return function_2699c();
}

// Address range: 0x26e82 - 0x26e84
int32_t function_26e82(void) {
    // 0x26e82
    int32_t result; // 0x26e82
    return result;
}

// Address range: 0x26e86 - 0x26e88
int32_t function_26e86(void) {
    // 0x26e86
    return function_27490();
}

// Address range: 0x26e88 - 0x26ea8
int32_t function_26e88(int32_t a1, int32_t a2, int32_t a3, uint32_t a4) {
    // 0x26e88
    int32_t v1; // 0x26e88
    int32_t result = function_54cb0(a1, "thread.c", 8, (char *)(a4 % 0x10000 | 0x60000), a3, v1, (int32_t)&g488, (int32_t)&g488); // 0x26ea0
    return result;
}

// Address range: 0x26eaa - 0x26eac
int32_t function_26eaa(void) {
    // 0x26eaa
    int32_t v1; // 0x26eaa
    return function_274b4(v1);
}

// Address range: 0x26eac - 0x26ec4
int32_t function_26eac(uint32_t a1, int32_t a2) {
    int32_t result = function_536f4((char *)(a1 % 0x10000 | 0x60000)); // 0x26eb0
    *(int32_t *)(a2 + 3404) = result;
    return result;
}

// Address range: 0x26ec4 - 0x26ed8
int32_t function_26ec4(int32_t a1) {
    int32_t result = function_536f4("bmminer_tuning"); // 0x26ecc
    *(int32_t *)(a1 + 3404) = result;
    return result;
}

// Address range: 0x26eda - 0x26edb
int32_t function_26eda(void) {
    // 0x26eda
    int32_t result; // 0x26eda
    return result;
}

// Address range: 0x26edc - 0x26ee8
int32_t function_26edc(void) {
    // 0x26edc
    return function_536f4("bmminer_tuning");
}

// Address range: 0x26ee8 - 0x26eec
int32_t function_26ee8(int32_t a1) {
    // 0x26ee8
    return a1 + 24;
}

// Address range: 0x26eec - 0x26ef0
int32_t function_26eec(int32_t result, int32_t a2) {
    // 0x26eec
    return result;
}

// Address range: 0x26ef0 - 0x26ef1
int32_t function_26ef0(int32_t a1) {
    // 0x26ef0
    int32_t result; // 0x26ef0
    return result;
}

// Address range: 0x26ef4 - 0x26f0c
int32_t function_26ef4(int32_t a1) {
    int32_t result = function_536f4("bmminer_tuning"); // 0x26efc
    *(int32_t *)(a1 + 3404) = result;
    return result;
}

// Address range: 0x26f0c - 0x26f20
int32_t function_26f0c(void) {
    int32_t result = function_536f4("bmminer_tuning"); // 0x26f14
    int32_t v1; // 0x26f0c
    *(int32_t *)(v1 + 3404) = result;
    return result;
}

// Address range: 0x26f20 - 0x26f34
int32_t function_26f20(void) {
    int32_t result = function_536f4("bmminer_tuning"); // 0x26f28
    int32_t v1; // 0x26f20
    *(int32_t *)(v1 + 3404) = result;
    return result;
}

// Address range: 0x26f34 - 0x26f3c
int32_t function_26f34(int32_t a1) {
    // 0x26f34
    int32_t v1; // 0x26f34
    return v1 ^ a1;
}

// Address range: 0x26f3c - 0x26f40
int32_t function_26f3c(int32_t a1, int32_t a2) {
    // 0x26f3c
    return function_27906();
}

// Address range: 0x26f40 - 0x26f4c
int32_t function_26f40(void) {
    int32_t v1 = function_1e0f0(); // 0x26f40
    int32_t result = v1; // 0x26f48
    if (v1 < 1) {
        result = function_26f74((int32_t)&g488, (int32_t)&g488, (int32_t)&g488);
    }
    // 0x26f4c
    return result;
}

// Address range: 0x26f4e - 0x26f50
int32_t function_26f4e(int32_t a1) {
    // 0x26f4e
    return function_2705a(a1);
}

// Address range: 0x26f50 - 0x26f54
int32_t function_26f50(int32_t a1) {
    // 0x26f50
    return function_27696();
}

// Address range: 0x26f54 - 0x26f58
int32_t function_26f54(int32_t a1) {
    // 0x26f54
    return function_2729a();
}

// Address range: 0x26f5a - 0x26f5c
int32_t function_26f5a(void) {
    // 0x26f5a
    return function_273e0();
}

// Address range: 0x26f5c - 0x26f60
int32_t function_26f5c(int32_t a1) {
    // 0x26f5c
    return function_27468(a1 + 1);
}

// Address range: 0x26f60 - 0x26f64
int32_t function_26f60(void) {
    // 0x26f60
    return 4;
}

// Address range: 0x26f64 - 0x26f68
int32_t function_26f64(int32_t result) {
    // 0x26f64
    return result;
}

// Address range: 0x26f6a - 0x26f6c
int32_t function_26f6a(void) {
    // 0x26f6a
    return function_2706e();
}

// Address range: 0x26f6c - 0x26f70
int32_t function_26f6c(void) {
    // 0x26f6c
    int32_t result; // 0x26f6c
    bool v1; // 0x26f6c
    if (!v1) {
        int32_t v2; // 0x26f6c
        result = function_26f5c(v2);
    }
    // 0x26f70
    return result;
}

// Address range: 0x26f72 - 0x26f73
int32_t function_26f72(void) {
    // 0x26f72
    int32_t result; // 0x26f72
    return result;
}

// Address range: 0x26f74 - 0x26f7c
int32_t function_26f74(int32_t a1, int32_t a2, int32_t a3) {
    // 0x26f74
    return 0;
}

// Address range: 0x26f80 - 0x26f84
int32_t function_26f80(int32_t a1) {
    // 0x26f80
    *(int32_t *)a1 = a1;
    return function_26df4();
}

// Address range: 0x26f84 - 0x26f86
int32_t function_26f84(int32_t result) {
    // 0x26f84
    return result;
}

// Address range: 0x26f86 - 0x26f8c
int32_t function_26f86(void) {
    // 0x26f86
    int32_t v1; // 0x26f86
    __asm_stc(0, 4, v1);
    return function_272ce(v1, v1, v1, v1);
}

// Address range: 0x26f8c - 0x26f94
int32_t function_26f8c(void) {
    // 0x26f8c
    return function_1e0f0();
}

// Address range: 0x26f94 - 0x26f98
int32_t function_26f94(int32_t result) {
    // 0x26f94
    *(int32_t *)(2 * result) = result;
    return result;
}

// Address range: 0x26f98 - 0x26fa0
int32_t function_26f98(int32_t a1, int32_t a2) {
    // 0x26f98
    return function_277ee(a2);
}

// Address range: 0x26fa0 - 0x26fa4
int32_t function_26fa0(int32_t a1) {
    // 0x26fa0
    *(int32_t *)(2 * a1) = a1;
    return function_276e6();
}

// Address range: 0x26fa4 - 0x26fa8
int32_t function_26fa4(int32_t a1) {
    // 0x26fa4
    return function_277f4(a1 + 5);
}

// Address range: 0x26fa8 - 0x26fac
int32_t function_26fa8(void) {
    // 0x26fa8
    return function_27432();
}

// Address range: 0x26fac - 0x26fb0
int32_t function_26fac(int32_t a1) {
    // 0x26fac
    return function_274b8();
}

// Address range: 0x26fb0 - 0x2700c
int32_t function_26fb0(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    if (a1 != a4) {
        function_26fac(a1);
    }
    // 0x26fc0
    function_1e0f0();
    function_5faf8();
    function_1e0f0();
    return function_1e0f0();
}

// Address range: 0x2700c - 0x27010
int32_t function_2700c(int32_t a1) {
    // 0x2700c
    return function_27352();
}

// Address range: 0x27010 - 0x27018
int32_t function_27010(void) {
    // 0x27010
    return function_5faf8();
}

// Address range: 0x2701a - 0x2701b
int32_t function_2701a(void) {
    // 0x2701a
    int32_t result; // 0x2701a
    return result;
}

// Address range: 0x2701c - 0x2701e
int32_t function_2701c(void) {
    // 0x2701c
    int32_t result; // 0x2701c
    return result;
}

// Address range: 0x2701e - 0x27026
int32_t function_2701e(void) {
    // 0x2701e
    bool v1; // 0x2701e
    if (v1) {
        function_1062b06();
    }
    // 0x27022
    return function_462afe();
}

// Address range: 0x27028 - 0x27032
int32_t function_27028(int32_t a1, uint32_t a2) {
    // 0x27028
    __asm_cdp(0, 11, 0, 1, 6, 0);
    return a2 / 0x8000;
}

// Address range: 0x27036 - 0x2703e
int32_t function_27036(int32_t result, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    // 0x27036
    __asm_ldc_20(0, 8, result, 448);
    return result;
}

// Address range: 0x2703e - 0x27042
int32_t function_2703e(void) {
    // 0x2703e
    int32_t result; // 0x2703e
    bool v1; // 0x2703e
    if (v1 == !v1) {
        result = function_e2042();
    }
    // 0x27042
    return result;
}

// Address range: 0x27044 - 0x2704e
int32_t function_27044(int32_t a1, int32_t result, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10) {
    // 0x27044
    __asm_ldc(0, 8, -0x1c5ffff1);
    return result;
}

// Address range: 0x27050 - 0x27054
int32_t function_27050(void) {
    // 0x27050
    int32_t result; // 0x27050
    return result;
}

// Address range: 0x27058 - 0x27059
int32_t function_27058(void) {
    // 0x27058
    int32_t result; // 0x27058
    return result;
}

// Address range: 0x2705a - 0x2705b
int32_t function_2705a(int32_t a1) {
    // 0x2705a
    int32_t result; // 0x2705a
    return result;
}

// Address range: 0x2705c - 0x27060
int32_t function_2705c(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x2705c
    return function_2767e(a1, a2, a3, a4);
}

// Address range: 0x27060 - 0x27064
int32_t function_27060(int32_t a1, int32_t a2) {
    // 0x27060
    return function_2766a();
}

// Address range: 0x27064 - 0x27068
int32_t function_27064(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x27064
    return function_27686();
}

// Address range: 0x27068 - 0x2706c
int32_t function_27068(int32_t a1, int32_t a2) {
    // 0x27068
    *(char *)(a2 + 1) = (char)a1;
    return function_276ee();
}

// Address range: 0x2706e - 0x27070
int32_t function_2706e(void) {
    // 0x2706e
    int32_t v1; // 0x2706e
    return function_276f2(v1, v1, v1, v1);
}

// Address range: 0x27070 - 0x27074
int32_t function_27070(int32_t a1) {
    // 0x27070
    return a1 + 7;
}

// Address range: 0x27074 - 0x27078
int32_t function_27074(void) {
    // 0x27074
    return 0;
}

// Address range: 0x27078 - 0x2707c
int32_t function_27078(int32_t a1) {
    // 0x27078
    return function_26ba4(a1);
}

// Address range: 0x2707c - 0x27080
int32_t function_2707c(int32_t a1, int32_t a2) {
    // 0x2707c
    return function_27686();
}

// Address range: 0x27080 - 0x27084
int32_t function_27080(int32_t result) {
    // 0x27080
    *(int16_t *)result = (int16_t)result;
    return result;
}

// Address range: 0x27084 - 0x27088
int32_t function_27084(void) {
    // 0x27084
    return function_271c4();
}

// Address range: 0x27088 - 0x2708c
int32_t function_27088(int32_t a1, int32_t a2) {
    // 0x27088
    *(int32_t *)(2 * a2) = a1;
    return function_2770e();
}

// Address range: 0x2708c - 0x27090
int32_t function_2708c(int32_t a1) {
    // 0x2708c
    return function_27712();
}

// Address range: 0x27090 - 0x27094
int32_t function_27090(int32_t result) {
    // 0x27090
    return result;
}

// Address range: 0x27094 - 0x27098
int32_t function_27094(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x27094
    return function_276aa();
}

// Address range: 0x27098 - 0x2709c
int32_t function_27098(int32_t a1, int32_t a2, int32_t a3) {
    // 0x27098
    *(int16_t *)a1 = (int16_t)a3;
    return function_276c4();
}

// Address range: 0x2709c - 0x270a0
int32_t function_2709c(int32_t result) {
    // 0x2709c
    *(int32_t *)result = result;
    return result;
}

// Address range: 0x270a0 - 0x270a4
int32_t function_270a0(int32_t result, int32_t a2, int32_t a3) {
    // 0x270a0
    return result;
}

// Address range: 0x270a6 - 0x270a8
int32_t function_270a6(int32_t a1) {
    // 0x270a6
    int32_t v1; // 0x270a6
    return function_27734(a1, v1, v1);
}

// Address range: 0x270a8 - 0x270a9
int32_t function_270a8(void) {
    // 0x270a8
    int32_t result; // 0x270a8
    return result;
}

// Address range: 0x270aa - 0x270ac
int32_t function_270aa(int32_t a1) {
    // 0x270aa
    return function_277ee(a1);
}

// Address range: 0x270ac - 0x270b0
int32_t function_270ac(void) {
    // 0x270ac
    int32_t v1; // 0x270ac
    bool v2; // 0x270ac
    if (v2) {
        v1 = function_270c8();
    }
    // 0x270ae
    return function_2754c(v1);
}

// Address range: 0x270b0 - 0x270b4
int32_t function_270b0(void) {
    // 0x270b0
    return function_26c74(__asm_adr(0));
}

// Address range: 0x270b4 - 0x270b8
int32_t function_270b4(int32_t a1, int32_t a2, int32_t a3) {
    // 0x270b4
    return function_2745e();
}

// Address range: 0x270b8 - 0x270bc
int32_t function_270b8(void) {
    // 0x270b8
    return function_27742();
}

// Address range: 0x270bc - 0x270c0
int32_t function_270bc(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x270bc
    *(int16_t *)(a4 + 12) = (int16_t)a1;
    return function_27254(a1);
}

// Address range: 0x270c0 - 0x270c4
int32_t function_270c0(void) {
    // 0x270c0
    int32_t v1; // 0x270c0
    *(int16_t *)(v1 + 50) = (int16_t)v1;
    return function_276d2((int32_t)&g488);
}

// Address range: 0x270c4 - 0x270c8
int32_t function_270c4(void) {
    // 0x270c4
    int32_t v1; // 0x270c4
    *(int16_t *)(v1 + 50) = (int16_t)v1;
    return function_27756(v1);
}

// Address range: 0x270c8 - 0x270cc
int32_t function_270c8(void) {
    // 0x270c8
    __asm_adr(616);
    return function_271e4();
}

// Address range: 0x270ce - 0x270d0
int32_t function_270ce(void) {
    // 0x270ce
    return function_2745e();
}

// Address range: 0x270d0 - 0x270d4
int32_t function_270d0(int32_t a1, int32_t a2, int32_t a3) {
    // 0x270d0
    return function_2719c();
}

// Address range: 0x270d4 - 0x270d8
int32_t function_270d4(int32_t a1) {
    // 0x270d4
    return function_271e0();
}

// Address range: 0x270d8 - 0x270dc
int32_t function_270d8(void) {
    // 0x270d8
    int32_t result; // 0x270d8
    return result;
}

// Address range: 0x270dc - 0x270e0
int32_t function_270dc(int32_t a1, int32_t a2, int32_t a3) {
    // 0x270dc
    return function_27274();
}

// Address range: 0x270e0 - 0x270e4
int32_t function_270e0(void) {
    // 0x270e0
    return function_271e6();
}

// Address range: 0x270e4 - 0x270e8
int32_t function_270e4(void) {
    // 0x270e4
    return function_27782();
}

// Address range: 0x270e8 - 0x270ec
int32_t function_270e8(void) {
    // 0x270e8
    return function_2742e();
}

// Address range: 0x270ec - 0x270f0
int32_t function_270ec(int32_t a1, int32_t a2, int32_t a3) {
    // 0x270ec
    return function_2770e();
}

// Address range: 0x270f2 - 0x270f4
int32_t function_270f2(int32_t a1, int32_t a2) {
    // 0x270f2
    return function_271f8(a1, a2);
}

// Address range: 0x270f6 - 0x270f8
int32_t function_270f6(void) {
    // 0x270f6
    int32_t v1; // 0x270f6
    return function_2777a(v1, v1, v1, v1);
}

// Address range: 0x270f8 - 0x270fc
int32_t function_270f8(int32_t a1, int32_t a2) {
    // 0x270f8
    return function_271c4();
}

// Address range: 0x270fc - 0x27100
int32_t function_270fc(int32_t a1) {
    // 0x270fc
    return function_2728e();
}

// Address range: 0x27100 - 0x27104
int32_t function_27100(int32_t a1, int32_t a2) {
    // 0x27100
    return function_2720c();
}

// Address range: 0x27106 - 0x27108
int32_t function_27106(int32_t a1) {
    // 0x27106
    return function_2778a(a1);
}

// Address range: 0x27108 - 0x2710c
int32_t function_27108(void) {
    // 0x27108
    return function_2744e();
}

// Address range: 0x2710c - 0x27110
int32_t function_2710c(int32_t a1) {
    // 0x2710c
    return a1 + 131;
}

// Address range: 0x27110 - 0x27114
int32_t function_27110(void) {
    // 0x27110
    int32_t result; // 0x27110
    return result;
}

// Address range: 0x27114 - 0x27118
int32_t function_27114(int32_t result) {
    // 0x27114
    return result;
}

// Address range: 0x27118 - 0x2711c
int32_t function_27118(void) {
    // 0x27118
    return 0;
}

// Address range: 0x2711c - 0x2711d
int32_t function_2711c(void) {
    // 0x2711c
    int32_t result; // 0x2711c
    return result;
}

// Address range: 0x2711e - 0x27120
int32_t function_2711e(int32_t a1) {
    // 0x2711e
    return function_26fa0(a1);
}

// Address range: 0x27120 - 0x2712c
int32_t function_27120(void) {
    int32_t result = 0; // 0x27128
    int32_t v1; // 0x27120
    if (function_1e29c(v1) != 0) {
        result = function_271c8();
    }
    // 0x2712c
    return result;
}

// Address range: 0x2712e - 0x27130
int32_t function_2712e(void) {
    // 0x2712e
    return function_276c4();
}

// Address range: 0x27130 - 0x27140
int32_t function_27130(void) {
    // 0x27130
    int32_t v1; // 0x27130
    if (v1 != 4) {
        function_2711c();
    }
    // 0x27138
    return function_19ab4();
}

// Address range: 0x27142 - 0x27144
int32_t function_27142(int32_t a1) {
    // 0x27142
    return function_26c74(a1);
}

// Address range: 0x27144 - 0x27148
int32_t function_27144(void) {
    // 0x27144
    return function_27876();
}

// Address range: 0x27148 - 0x2714c
int32_t function_27148(void) {
    // 0x27148
    return function_277e6();
}

// Address range: 0x2714c - 0x27150
int32_t function_2714c(void) {
    // 0x2714c
    return 6;
}

// Address range: 0x27150 - 0x27154
int32_t function_27150(int32_t a1) {
    // 0x27150
    return function_277fa();
}

// Address range: 0x2715a - 0x2715c
int32_t function_2715a(void) {
    // 0x2715a
    int32_t v1; // 0x2715a
    return function_27264(v1, v1, v1, v1);
}

// Address range: 0x2715c - 0x27198
int32_t function_2715c(int32_t a1, int32_t a2, int32_t a3, uint32_t a4) {
    // 0x2715c
    int32_t v1; // 0x2715c
    int32_t v2 = v1;
    int32_t v3 = a1; // 0x27168
    if (a4 <= 31) {
        v3 = function_271ac(a1);
    }
    // 0x2716c
    return function_195a8((v3 > v2 ? 20 : -20) + v2);
}

// Address range: 0x27198 - 0x2719c
int32_t function_27198(int32_t a1, int32_t a2) {
    // 0x27198
    return function_2701c();
}

// Address range: 0x2719c - 0x2719e
int32_t function_2719c(void) {
    // 0x2719c
    int32_t result; // 0x2719c
    return result;
}

// Address range: 0x271a0 - 0x271ac
int32_t function_271a0(void) {
    // 0x271a0
    int32_t result; // 0x271a0
    return result;
}

// Address range: 0x271ac - 0x271b4
int32_t function_271ac(int32_t result) {
    // 0x271ac
    return result;
}

// Address range: 0x271b4 - 0x271b6
int32_t function_271b4(int32_t result) {
    // 0x271b4
    return result;
}

// Address range: 0x271b8 - 0x271bc
int32_t function_271b8(int32_t a1, int32_t a2) {
    // 0x271b8
    return function_278fe();
}

// Address range: 0x271bc - 0x271c0
int32_t function_271bc(void) {
    // 0x271bc
    int32_t v1; // 0x271bc
    bool v2; // 0x271bc
    int32_t v3; // 0x271bc
    if (v2) {
        v1 = function_271d8(v3);
    }
    // 0x271be
    return function_276dc(v1, v3, v3, v3);
}

// Address range: 0x271c4 - 0x271c6
int32_t function_271c4(void) {
    // 0x271c4
    __asm_udf(66);
    int32_t result; // 0x271c4
    return result;
}

// Address range: 0x271c8 - 0x271cc
int32_t function_271c8(void) {
    // 0x271c8
    int32_t result; // 0x271c8
    __asm_vldr_8(result);
    return result;
}

// Address range: 0x271ce - 0x271d0
int32_t function_271ce(void) {
    // 0x271ce
    return function_27512((int32_t)&g488);
}

// Address range: 0x271d0 - 0x271d4
int32_t function_271d0(int32_t a1) {
    // 0x271d0
    int32_t v1; // 0x271d0
    return function_26d00(a1, v1, v1, v1);
}

// Address range: 0x271d4 - 0x271d8
int32_t function_271d4(int32_t a1) {
    // 0x271d4
    return function_2751a();
}

// Address range: 0x271d8 - 0x271dc
int32_t function_271d8(int32_t a1) {
    // 0x271d8
    return 0;
}

// Address range: 0x271dc - 0x271e0
int32_t function_271dc(void) {
    // 0x271dc
    return function_26cfc(__asm_adr(0));
}

// Address range: 0x271e0 - 0x271e2
int32_t function_271e0(void) {
    // 0x271e0
    int32_t result; // 0x271e0
    return result;
}

// Address range: 0x271e4 - 0x271e5
int32_t function_271e4(void) {
    // 0x271e4
    int32_t result; // 0x271e4
    return result;
}

// Address range: 0x271e6 - 0x271e7
int32_t function_271e6(void) {
    // 0x271e6
    int32_t result; // 0x271e6
    return result;
}

// Address range: 0x271ea - 0x271f8
int32_t function_271ea(int32_t a1) {
    int32_t v1 = a1; // 0x271ee
    bool v2; // 0x271ea
    int32_t v3; // 0x271ea
    if ((v2 || (v3 & 0x20000) != 0) == !v2) {
        v1 = function_1e0076();
    }
    // 0x271f2
    __asm_stc(13, 13, v3);
    return function_27694(v1, v3);
}

// Address range: 0x271f8 - 0x271fc
int32_t function_271f8(int32_t a1, int32_t a2) {
    // 0x271f8
    bool v1; // 0x271f8
    if (v1) {
        int32_t v2; // 0x271f8
        function_27234(v2, v2);
    }
    // 0x271fa
    return function_27698();
}

// Address range: 0x271fc - 0x27200
int32_t function_271fc(void) {
    // 0x271fc
    int32_t v1; // 0x271fc
    return function_27808(v1 >> 12);
}

// Address range: 0x27200 - 0x27204
int32_t function_27200(int32_t a1) {
    // 0x27200
    return function_26d20();
}

// Address range: 0x27204 - 0x27208
int32_t function_27204(void) {
    // 0x27204
    return function_2754a();
}

// Address range: 0x27208 - 0x2720c
int32_t function_27208(int32_t a1) {
    // 0x27208
    return function_2788e();
}

// Address range: 0x2720c - 0x2720d
int32_t function_2720c(void) {
    // 0x2720c
    int32_t result; // 0x2720c
    return result;
}

// Address range: 0x27210 - 0x27214
int32_t function_27210(void) {
    // 0x27210
    int32_t option; // 0x27210
    return prctl(option, option, option, option, (int32_t)&g488);
}

// Address range: 0x27216 - 0x27224
int32_t function_27216(int32_t a1, int32_t a2, int32_t a3) {
    // 0x27216
    return function_278c6();
}

// Address range: 0x27226 - 0x27228
int32_t function_27226(void) {
    // 0x27226
    int32_t result; // 0x27226
    return result;
}

// Address range: 0x2722a - 0x27230
int32_t function_2722a(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x2722a
    return function_27836();
}

// Address range: 0x27230 - 0x27234
int32_t function_27230(int32_t a1) {
    // 0x27230
    int32_t v1; // 0x27230
    return v1 + a1;
}

// Address range: 0x27234 - 0x27238
int32_t function_27234(int32_t a1, int32_t a2) {
    // 0x27234
    *(int32_t *)(2 * a2) = a1;
    return function_278ba();
}

// Address range: 0x27238 - 0x2723c
int32_t function_27238(void) {
    // 0x27238
    return function_27248();
}

// Address range: 0x2723c - 0x27248
int32_t function_2723c(void) {
    // 0x2723c
    int32_t v1; // 0x2723c
    function_11ea4((int32_t *)v1, v1, v1, v1);
    return function_304d4(1000);
}

// Address range: 0x27248 - 0x27254
int32_t function_27248(void) {
    // 0x27248
    int32_t v1; // 0x27248
    function_11f94((int32_t *)v1, v1, v1, v1);
    return function_19ab4();
}

// Address range: 0x27254 - 0x27258
int32_t function_27254(int32_t result) {
    // 0x27254
    return result;
}

// Address range: 0x27258 - 0x27264
int32_t function_27258(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x27258
    int32_t result; // 0x27258
    return result;
}

// Address range: 0x27264 - 0x27268
int32_t function_27264(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x27264
    return function_27886();
}

// Address range: 0x27268 - 0x2726c
int32_t function_27268(int32_t result) {
    // 0x27268
    return result;
}

// Address range: 0x2726c - 0x27270
int32_t function_2726c(int32_t a1) {
    // 0x2726c
    return function_278f2();
}

// Address range: 0x27270 - 0x27274
int32_t function_27270(int32_t a1, int32_t a2, int32_t a3) {
    // 0x27270
    return function_26db4();
}

// Address range: 0x27274 - 0x27278
int32_t function_27274(void) {
    // 0x27274
    return function_26e20(0);
}

// Address range: 0x27278 - 0x2727c
int32_t function_27278(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x27278
    return function_2789a();
}

// Address range: 0x2727c - 0x27280
int32_t function_2727c(int32_t a1) {
    // 0x2727c
    return function_26d9c(a1 + 52);
}

// Address range: 0x27282 - 0x27284
int32_t function_27282(void) {
    // 0x27282
    return function_27906();
}

// Address range: 0x27284 - 0x27288
int32_t function_27284(int32_t a1) {
    // 0x27284
    int32_t v1; // 0x27284
    return function_26e10(a1, v1, v1, v1);
}

// Address range: 0x27288 - 0x2728c
int32_t function_27288(void) {
    // 0x27288
    int32_t v1; // 0x27288
    return function_26da8(48, v1);
}

// Address range: 0x2728e - 0x2728f
int32_t function_2728e(void) {
    // 0x2728e
    int32_t result; // 0x2728e
    return result;
}

// Address range: 0x27290 - 0x27298
int32_t function_27290(void) {
    // 0x27290
    return function_304d4(0xea60);
}

// Address range: 0x27298 - 0x2729a
int32_t function_27298(int32_t result) {
    // 0x27298
    return result;
}

// Address range: 0x2729a - 0x2729c
int32_t function_2729a(void) {
    // 0x2729a
    int32_t result; // 0x2729a
    return result;
}

// Address range: 0x2729c - 0x272a0
int32_t function_2729c(int32_t result) {
    // 0x2729c
    return result;
}

// Address range: 0x272a0 - 0x272a8
int32_t function_272a0(int32_t a1) {
    // 0x272a0
    return function_278c6();
}

// Address range: 0x272a8 - 0x272c0
int32_t function_272a8(void) {
    // 0x272a8
    return function_27058();
}

// Address range: 0x272c2 - 0x272c4
int32_t function_272c2(void) {
    // 0x272c2
    return function_26dee((int32_t)&g488);
}

// Address range: 0x272c6 - 0x272c8
int32_t function_272c6(void) {
    // 0x272c6
    return function_26df4();
}

// Address range: 0x272ca - 0x272cc
int32_t function_272ca(void) {
    // 0x272ca
    int32_t result; // 0x272ca
    return result;
}

// Address range: 0x272ce - 0x272d4
int32_t function_272ce(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x272ce
    return function_278f2();
}

// Address range: 0x272d4 - 0x272d8
int32_t function_272d4(int32_t a1) {
    // 0x272d4
    return function_278f6();
}

// Address range: 0x272d8 - 0x272dc
int32_t function_272d8(int32_t a1) {
    // 0x272d8
    return a1 + 7;
}

// Address range: 0x272dc - 0x272e0
int32_t function_272dc(int32_t result, int32_t a2, int32_t a3) {
    // 0x272dc
    return result;
}

// Address range: 0x272e2 - 0x272e4
int32_t function_272e2(int32_t a1) {
    // 0x272e2
    return function_26e00(a1);
}

// Address range: 0x272e6 - 0x272e8
int32_t function_272e6(void) {
    // 0x272e6
    int32_t v1; // 0x272e6
    return function_27804(v1);
}

// Address range: 0x272ea - 0x272ec
int32_t function_272ea(int32_t a1) {
    // 0x272ea
    return function_277f4(a1);
}

// Address range: 0x272ec - 0x272f0
int32_t function_272ec(int32_t result) {
    // 0x272ec
    return result;
}

// Address range: 0x272f2 - 0x272f4
int32_t function_272f2(void) {
    // 0x272f2
    int32_t v1; // 0x272f2
    return function_26e10(v1, v1, v1, v1);
}

// Address range: 0x272f4 - 0x272f8
int32_t function_272f4(int32_t a1) {
    // 0x272f4
    return function_27814(a1 + 152);
}

// Address range: 0x272f8 - 0x272fc
int32_t function_272f8(int32_t a1) {
    // 0x272f8
    int32_t v1; // 0x272f8
    return function_26e18(a1 + 16, v1, v1);
}

// Address range: 0x272fe - 0x27300
int32_t function_272fe(int32_t a1) {
    // 0x272fe
    return function_2781c(a1);
}

// Address range: 0x27300 - 0x27304
int32_t function_27300(int32_t a1) {
    // 0x27300
    return function_26e20(a1 + 20);
}

// Address range: 0x27304 - 0x27308
int32_t function_27304(void) {
    // 0x27304
    return 7;
}

// Address range: 0x27308 - 0x2730c
int32_t function_27308(int32_t a1) {
    // 0x27308
    return function_27458(a1);
}

// Address range: 0x2730c - 0x27310
int32_t function_2730c(int32_t result, int32_t a2, int32_t a3) {
    // 0x2730c
    return result;
}

// Address range: 0x27310 - 0x27314
int32_t function_27310(int32_t a1, int32_t a2) {
    // 0x27310
    return function_26e30(a2 & a1, a2);
}

// Address range: 0x27314 - 0x27318
int32_t function_27314(int32_t a1, int32_t a2) {
    // 0x27314
    *(char *)a2 = (char)a2;
    return function_2765a();
}

// Address range: 0x27318 - 0x2731c
int32_t function_27318(void) {
    // 0x27318
    return function_26e38();
}

// Address range: 0x2731c - 0x27320
int32_t function_2731c(int32_t a1) {
    // 0x2731c
    return function_27662();
}

// Address range: 0x27320 - 0x27324
int32_t function_27320(int32_t result) {
    // 0x27320
    return result;
}

// Address range: 0x27324 - 0x27340
int32_t function_27324(int32_t result, int32_t a2, int32_t a3) {
    // 0x27324
    __asm_vldr(0);
    __asm_vldr(-0xa3d70a4);
    return result;
}

// Address range: 0x27334 - 0x27335
int32_t function_27334(void) {
    // 0x27334
    int32_t result; // 0x27334
    return result;
}

// Address range: 0x27340 - 0x27344
int32_t function_27340(void) {
    // 0x27340
    __asm_adr(16);
    return function_27686();
}

// Address range: 0x27346 - 0x27348
int32_t function_27346(void) {
    // 0x27346
    int32_t result; // 0x27346
    return result;
}

// Address range: 0x27348 - 0x2734c
int32_t function_27348(int32_t a1) {
    // 0x27348
    int32_t v1; // 0x27348
    return function_2768e(a1, v1);
}

// Address range: 0x2734c - 0x27350
int32_t function_2734c(void) {
    // 0x2734c
    int32_t v1; // 0x2734c
    return function_1e29c(v1);
}

// Address range: 0x27352 - 0x27354
int32_t function_27352(void) {
    // 0x27352
    int32_t result; // 0x27352
    return result;
}

// Address range: 0x27354 - 0x2735c
int32_t function_27354(int32_t a1, int32_t a2) {
    // 0x27354
    return function_27866(0, 0);
}

// Address range: 0x2735c - 0x27360
int32_t function_2735c(int32_t result) {
    // 0x2735c
    return result;
}

// Address range: 0x27360 - 0x2737c
int32_t function_27360(void) {
    // 0x27360
    bool v1; // 0x27360
    if (!v1) {
        int32_t v2; // 0x27360
        function_27348(v2);
    }
    // 0x27364
    int32_t v3; // bp+2648, 0x27360
    return &v3;
}

// Address range: 0x2737e - 0x2737f
int32_t function_2737e(int32_t a1) {
    // 0x2737e
    int32_t result; // 0x2737e
    return result;
}

// Address range: 0x27380 - 0x27384
int32_t function_27380(void) {
    // 0x27380
    int32_t v1; // 0x27380
    return (uint32_t)v1 / 0x10000000;
}

// Address range: 0x27384 - 0x27388
int32_t function_27384(int32_t result) {
    // 0x27384
    return result;
}

// Address range: 0x27388 - 0x2738c
int32_t function_27388(void) {
    // 0x27388
    int32_t v1; // 0x27388
    return function_304d4(v1);
}

// Address range: 0x2738c - 0x2738e
int32_t function_2738c(int32_t a1, int32_t result) {
    // 0x2738c
    return result;
}

// Address range: 0x2738e - 0x27390
int32_t function_2738e(int32_t a1) {
    // 0x2738e
    return function_276d2(a1);
}

// Address range: 0x27390 - 0x27394
int32_t function_27390(void) {
    // 0x27390
    int32_t v1; // 0x27390
    return function_1e29c(v1);
}

// Address range: 0x27396 - 0x27398
int32_t function_27396(void) {
    // 0x27396
    int32_t result; // 0x27396
    return result;
}

// Address range: 0x27398 - 0x273a4
int32_t function_27398(void) {
    // 0x27398
    int32_t result; // 0x27398
    bool v1; // 0x27398
    if (!v1) {
        result = function_275fc((int32_t)&g488);
    }
    // 0x2739c
    return result;
}

// Address range: 0x273a6 - 0x273ac
int32_t function_273a6(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x273a6
    return function_26ee8(a1 + 16);
}

// Address range: 0x273ac - 0x273b0
int32_t function_273ac(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x273ac
    return result;
}

// Address range: 0x273b2 - 0x273b4
int32_t function_273b2(int32_t a1) {
    // 0x273b2
    return function_26ef0(a1);
}

// Address range: 0x273b4 - 0x273b8
int32_t function_273b4(int32_t a1) {
    // 0x273b4
    return function_27248();
}

// Address range: 0x273b8 - 0x273bc
int32_t function_273b8(int32_t result, int32_t a2) {
    // 0x273b8
    *(int16_t *)a2 = (int16_t)result;
    return result;
}

// Address range: 0x273be - 0x273c0
int32_t function_273be(void) {
    // 0x273be
    int32_t result; // 0x273be
    return result;
}

// Address range: 0x273c0 - 0x273cc
int32_t function_273c0(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x273c0
    return function_26bd4();
}

// Address range: 0x273cc - 0x273cd
int32_t function_273cc(void) {
    // 0x273cc
    int32_t result; // 0x273cc
    return result;
}

// Address range: 0x273ce - 0x273d0
int32_t function_273ce(void) {
    // 0x273ce
    return function_27712();
}

// Address range: 0x273d0 - 0x273d4
int32_t function_273d0(void) {
    // 0x273d0
    int32_t v1; // 0x273d0
    return function_1e29c(v1);
}

// Address range: 0x273d6 - 0x273d8
int32_t function_273d6(void) {
    // 0x273d6
    int32_t result; // 0x273d6
    return result;
}

// Address range: 0x273d8 - 0x273dc
int32_t function_273d8(void) {
    // 0x273d8
    int32_t result; // 0x273d8
    return result;
}

// Address range: 0x273dc - 0x273e0
int32_t function_273dc(int32_t a1, int32_t a2) {
    // 0x273dc
    return function_278ea();
}

// Address range: 0x273e0 - 0x273e4
int32_t function_273e0(void) {
    // 0x273e0
    int32_t v1; // 0x273e0
    *(int16_t *)v1 = (int16_t)v1;
    return function_278f6();
}

// Address range: 0x273e4 - 0x273ec
int32_t function_273e4(void) {
    // 0x273e4
    int32_t result; // 0x273e4
    return result;
}

// Address range: 0x273ec - 0x273ee
int32_t function_273ec(void) {
    // 0x273ec
    int32_t result; // 0x273ec
    // 0x273ee
    return result;
}

// Address range: 0x273f0 - 0x273fc
int32_t function_273f0(int32_t a1, int32_t a2) {
    // 0x273f0
    return function_1e130();
}

// Address range: 0x273fe - 0x27400
int32_t function_273fe(void) {
    // 0x273fe
    return function_27742();
}

// Address range: 0x27400 - 0x27404
int32_t function_27400(int32_t a1) {
    // 0x27400
    return function_27746((int32_t)&g488);
}

// Address range: 0x27404 - 0x27408
int32_t function_27404(void) {
    // 0x27404
    int32_t v1; // 0x27404
    return function_27590(v1);
}

// Address range: 0x27408 - 0x2740c
int32_t function_27408(int32_t a1, int32_t a2, uint32_t a3) {
    // 0x27408
    return function_27410(a1, a2, a3 / 0x4000);
}

// Address range: 0x2740c - 0x27410
int32_t function_2740c(int32_t result, int32_t a2, int32_t a3) {
    // 0x2740c
    return result;
}

// Address range: 0x27410 - 0x27412
int32_t function_27410(int32_t result, int32_t a2, int32_t a3) {
    // 0x27410
    return result;
}

// Address range: 0x27412 - 0x27414
int32_t function_27412(void) {
    // 0x27412
    return function_2745e();
}

// Address range: 0x27414 - 0x27418
int32_t function_27414(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x27414
    return function_2741c();
}

// Address range: 0x27418 - 0x2741c
int32_t function_27418(int32_t result) {
    // 0x27418
    return result;
}

// Address range: 0x2741c - 0x27420
int32_t function_2741c(void) {
    // 0x2741c
    int32_t v1; // 0x2741c
    return function_2786e(v1);
}

// Address range: 0x27420 - 0x27424
int32_t function_27420(int32_t a1, int32_t a2, int32_t a3) {
    // 0x27420
    int32_t v1; // 0x27420
    return function_277aa(a3 - v1);
}

// Address range: 0x27424 - 0x27428
int32_t function_27424(int32_t a1) {
    // 0x27424
    return function_2786e(a1 + 3);
}

// Address range: 0x2742a - 0x2742c
int32_t function_2742a(int32_t a1) {
    // 0x2742a
    return function_2776e(a1);
}

// Address range: 0x2742e - 0x27430
int32_t function_2742e(void) {
    // 0x2742e
    int32_t v1; // 0x2742e
    return __asm_adr(v1);
}

// Address range: 0x27430 - 0x27432
int32_t function_27430(void) {
    // 0x27430
    int32_t result; // 0x27430
    return result;
}

// Address range: 0x27432 - 0x27433
int32_t function_27432(void) {
    // 0x27432
    int32_t result; // 0x27432
    return result;
}

// Address range: 0x27436 - 0x2743c
int32_t function_27436(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x27436
    __asm_mcrr(0, 0, a4, a2, 0);
    return function_2706e();
}

// Address range: 0x27440 - 0x27444
int32_t function_27440(int32_t result) {
    // 0x27440
    return result;
}

// Address range: 0x27444 - 0x27448
int32_t function_27444(int32_t a1) {
    // 0x27444
    return a1 + 60;
}

// Address range: 0x2744e - 0x27454
int32_t function_2744e(void) {
    // 0x2744e
    __asm_cdp(1, 1, 2, 8, 5, 0);
    int32_t v1; // 0x2744e
    return function_2735c(v1);
}

// Address range: 0x27454 - 0x27458
int32_t function_27454(void) {
    // 0x27454
    int32_t result; // 0x27454
    return result;
}

// Address range: 0x27458 - 0x2745c
int32_t function_27458(int32_t a1) {
    // 0x27458
    int32_t v1; // 0x27458
    return function_26f98(a1 + 28, v1);
}

// Address range: 0x2745e - 0x27460
int32_t function_2745e(void) {
    // 0x2745e
    int32_t result; // 0x2745e
    return result;
}

// Address range: 0x27462 - 0x27464
int32_t function_27462(int32_t a1) {
    // 0x27462
    return function_26fa0(a1);
}

// Address range: 0x27466 - 0x27468
int32_t function_27466(int32_t a1) {
    // 0x27466
    return function_277aa(a1);
}

// Address range: 0x27468 - 0x2746c
int32_t function_27468(int32_t a1) {
    // 0x27468
    *(int16_t *)a1 = (int16_t)a1;
    return function_26f94(a1);
}

// Address range: 0x2746e - 0x27470
int32_t function_2746e(void) {
    // 0x2746e
    int32_t v1; // 0x2746e
    return function_26fac(v1);
}

// Address range: 0x27470 - 0x27474
int32_t function_27470(int32_t a1, int32_t a2) {
    // 0x27470
    *(int16_t *)a2 = (int16_t)a1;
    return function_27504(a1);
}

// Address range: 0x27474 - 0x27478
int32_t function_27474(int32_t result) {
    // 0x27474
    return result;
}

// Address range: 0x27478 - 0x27479
int32_t function_27478(void) {
    // 0x27478
    int32_t result; // 0x27478
    return result;
}

// Address range: 0x2747a - 0x2747c
int32_t function_2747a(void) {
    // 0x2747a
    return function_277be();
}

// Address range: 0x2747c - 0x27480
int32_t function_2747c(void) {
    // 0x2747c
    return __asm_adr(4);
}

// Address range: 0x27480 - 0x27482
int32_t function_27480(void) {
    // 0x27480
    int32_t result; // 0x27480
    return result;
}

// Address range: 0x27482 - 0x27483
int32_t function_27482(void) {
    // 0x27482
    int32_t result; // 0x27482
    return result;
}

// Address range: 0x27484 - 0x27490
int32_t function_27484(int32_t a1) {
    int32_t result = a1; // 0x27488
    if (a1 == 0) {
        result = function_274c0();
    }
    // 0x2748c
    return result;
}

// Address range: 0x27490 - 0x27494
int32_t function_27490(void) {
    // 0x27490
    int32_t result; // 0x27490
    return result;
}

// Address range: 0x27494 - 0x2749c
int32_t function_27494(int32_t a1) {
    // 0x27494
    int32_t result; // 0x27494
    bool v1; // 0x27494
    if (!v1 && true) {
        result = function_274c0();
    }
    // 0x27498
    return result;
}

// Address range: 0x274a2 - 0x274a4
int32_t function_274a2(int32_t a1) {
    // 0x274a2
    int32_t v1; // 0x274a2
    return function_273dc(a1, v1);
}

// Address range: 0x274a4 - 0x274ac
int32_t function_274a4(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x274a4
    __asm_mcr(0, 1, a4, 7, 8, 0);
    return result;
}

// Address range: 0x274ae - 0x274b2
int32_t function_274ae(void) {
    // 0x274ae
    int32_t result; // 0x274ae
    return result;
}

// Address range: 0x274b2 - 0x274b3
int32_t function_274b2(void) {
    // 0x274b2
    int32_t result; // 0x274b2
    return result;
}

// Address range: 0x274b4 - 0x274b6
int32_t function_274b4(int32_t result) {
    // 0x274b4
    return result;
}

// Address range: 0x274b8 - 0x274b9
int32_t function_274b8(void) {
    // 0x274b8
    int32_t result; // 0x274b8
    return result;
}

// Address range: 0x274c0 - 0x274c4
int32_t function_274c0(void) {
    // 0x274c0
    int32_t result; // 0x274c0
    return result;
}

// Address range: 0x274c6 - 0x274c8
int32_t function_274c6(void) {
    // 0x274c6
    int32_t result; // 0x274c6
    return result;
}

// Address range: 0x274c8 - 0x274cc
int32_t function_274c8(void) {
    // 0x274c8
    int32_t result; // 0x274c8
    bool v1; // 0x274c8
    if (!v1) {
        result = function_27478();
    }
    // 0x274cc
    return result;
}

// Address range: 0x274ce - 0x274cf
int32_t function_274ce(void) {
    // 0x274ce
    int32_t result; // 0x274ce
    return result;
}

// Address range: 0x274d0 - 0x274dc
int32_t function_274d0(uint32_t a1) {
    int32_t result = a1; // 0x274d8
    int32_t v1; // 0x274d0
    if ((uint32_t)v1 >= a1) {
        result = function_278d4();
    }
    // 0x274dc
    return result;
}

// Address range: 0x274de - 0x274e0
int32_t function_274de(void) {
    // 0x274de
    return function_2701c();
}

// Address range: 0x274e2 - 0x274e4
int32_t function_274e2(void) {
    // 0x274e2
    int32_t v1; // 0x274e2
    return function_2700c(v1);
}

// Address range: 0x274e4 - 0x274f4
int32_t function_274e4(int32_t result, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x274e4
    return result;
}

// Address range: 0x274f6 - 0x274f8
int32_t function_274f6(int32_t a1) {
    // 0x274f6
    return function_2783a(a1);
}

// Address range: 0x274f8 - 0x27504
int32_t function_274f8(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x274f8
    return result;
}

// Address range: 0x27504 - 0x27506
int32_t function_27504(int32_t result) {
    // 0x27504
    return result;
}

// Address range: 0x27506 - 0x27508
int32_t function_27506(int32_t a1) {
    int32_t result = function_27036((int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488); // 0x27506
    return result;
}

// Address range: 0x2750a - 0x2750c
int32_t function_2750a(void) {
    // 0x2750a
    return function_2784e();
}

// Address range: 0x2750c - 0x27510
int32_t function_2750c(int32_t result) {
    // 0x2750c
    return result;
}

// Address range: 0x27512 - 0x27518
int32_t function_27512(int32_t a1) {
    // 0x27512
    int32_t result; // 0x27512
    return result;
}

// Address range: 0x2751a - 0x2751c
int32_t function_2751a(void) {
    // 0x2751a
    int32_t result; // 0x2751a
    return result;
}

// Address range: 0x2751c - 0x27520
int32_t function_2751c(int32_t result, int32_t a2, int32_t a3) {
    // 0x2751c
    return result;
}

// Address range: 0x27520 - 0x27524
int32_t function_27520(int32_t result) {
    // 0x27520
    return result;
}

// Address range: 0x27524 - 0x27528
int32_t function_27524(void) {
    // 0x27524
    return 6;
}

// Address range: 0x2752a - 0x2752c
int32_t function_2752a(int32_t a1) {
    // 0x2752a
    return function_2786e(a1);
}

// Address range: 0x2752e - 0x27530
int32_t function_2752e(void) {
    // 0x2752e
    int32_t result; // 0x2752e
    return result;
}

// Address range: 0x27530 - 0x27548
int32_t function_27530(void) {
    // 0x27530
    int32_t str; // 0x27530
    snprintf((char *)str, str, (char *)str);
    int32_t v1; // bp+600, 0x27530
    function_2e584(3, &v1, 0);
    return function_27334();
}

// Address range: 0x2754a - 0x2754b
int32_t function_2754a(void) {
    // 0x2754a
    int32_t result; // 0x2754a
    return result;
}

// Address range: 0x2754c - 0x27550
int32_t function_2754c(int32_t a1) {
    // 0x2754c
    return function_27892();
}

// Address range: 0x27550 - 0x27554
int32_t function_27550(int32_t a1) {
    // 0x27550
    return function_2778a(0);
}

// Address range: 0x27554 - 0x27558
int32_t function_27554(void) {
    // 0x27554
    return function_2789a();
}

// Address range: 0x27558 - 0x2755c
int32_t function_27558(void) {
    // 0x27558
    return function_27078(__asm_adr(0));
}

// Address range: 0x2755e - 0x27560
int32_t function_2755e(void) {
    // 0x2755e
    return function_278a2();
}

// Address range: 0x27560 - 0x27564
int32_t function_27560(void) {
    // 0x27560
    int32_t v1; // 0x27560
    return function_1aae4(v1, v1, v1, v1, (int32_t)&g488);
}

// Address range: 0x27566 - 0x27567
int32_t function_27566(void) {
    // 0x27566
    int32_t result; // 0x27566
    return result;
}

// Address range: 0x27568 - 0x2756c
int32_t function_27568(int32_t a1, int32_t a2) {
    // 0x27568
    return function_270a8();
}

// Address range: 0x2756c - 0x27570
int32_t function_2756c(int32_t a1) {
    // 0x2756c
    int32_t v1; // 0x2756c
    return function_278b2(a1, v1, v1);
}

// Address range: 0x27572 - 0x27573
int32_t function_27572(void) {
    // 0x27572
    int32_t result; // 0x27572
    return result;
}

// Address range: 0x27574 - 0x27590
int32_t function_27574(void) {
    // 0x27574
    float32_t v1; // 0x27574
    int32_t v2; // 0x27574
    *(int32_t *)(2 * v2) = __asm_vmov_9(__asm_vcvt_s32_f32(v1));
    return function_1e0f0();
}

// Address range: 0x27590 - 0x27594
int32_t function_27590(int32_t a1) {
    // 0x27590
    int32_t v1; // 0x27590
    return function_270d0(a1 + 12, v1, v1);
}

// Address range: 0x27594 - 0x27598
int32_t function_27594(int32_t a1) {
    // 0x27594
    return 0;
}

// Address range: 0x27598 - 0x2759c
int32_t function_27598(void) {
    // 0x27598
    return 4;
}

// Address range: 0x2759c - 0x275a0
int32_t function_2759c(int32_t a1) {
    // 0x2759c
    return a1 + 1;
}

// Address range: 0x275a0 - 0x275a4
int32_t function_275a0(void) {
    // 0x275a0
    return function_276aa();
}

// Address range: 0x275a4 - 0x275a8
int32_t function_275a4(int32_t a1) {
    // 0x275a4
    return a1 + 1;
}

// Address range: 0x275a8 - 0x275ac
int32_t function_275a8(int32_t a1, int32_t a2, int32_t a3) {
    // 0x275a8
    *(int32_t *)a1 = a3;
    return a1 + 4;
}

// Address range: 0x275ac - 0x275b0
int32_t function_275ac(int32_t a1) {
    // 0x275ac
    return function_27852();
}

// Address range: 0x275b2 - 0x275b4
int32_t function_275b2(void) {
    // 0x275b2
    int32_t v1; // 0x275b2
    return function_276b8(v1);
}

// Address range: 0x275b4 - 0x275b8
int32_t function_275b4(void) {
    // 0x275b4
    int32_t result; // 0x275b4
    return result;
}

// Address range: 0x275b8 - 0x275bc
int32_t function_275b8(int32_t result) {
    // 0x275b8
    return result;
}

// Address range: 0x275be - 0x275c0
int32_t function_275be(int32_t a1) {
    // 0x275be
    return function_270fc(a1);
}

// Address range: 0x275c0 - 0x275fc
int32_t function_275c0(int32_t a1, int32_t a2, int32_t a3, uint32_t a4) {
    // 0x275c0
    int32_t format; // 0x275c0
    *(int32_t *)(format + a3) = a2;
    if (a4 == 3 || a4 < 3) {
        function_273dc(a1, a2);
    }
    // 0x275cc
    int32_t str; // bp+600, 0x275c0
    snprintf((char *)&str, 2048, (char *)format);
    int32_t v1 = function_2e584(3, &str, 0); // 0x275f4
    return function_273dc(v1, (int32_t)&str);
}

// Address range: 0x275fc - 0x27638
int32_t function_275fc(int32_t a1) {
    // 0x275fc
    function_1e0f0();
    int32_t v1; // 0x275fc
    return 1024 * v1 + a1;
}

// Address range: 0x2763a - 0x2763c
int32_t function_2763a(void) {
    // 0x2763a
    return function_276c4();
}

// Address range: 0x2763c - 0x27648
int32_t function_2763c(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x2763c
    *(int32_t *)a1 = a4;
    return a1 + 4;
}

// Address range: 0x27648 - 0x2764c
int32_t function_27648(void) {
    // 0x27648
    int32_t result; // 0x27648
    return result;
}

// Address range: 0x2764c - 0x27650
int32_t function_2764c(int32_t result, int32_t a2, int32_t a3) {
    // 0x2764c
    return result;
}

// Address range: 0x27650 - 0x27654
int32_t function_27650(void) {
    // 0x27650
    return 6;
}

// Address range: 0x27656 - 0x2765a
int32_t function_27656(void) {
    // 0x27656
    int32_t result; // 0x27656
    return result;
}

// Address range: 0x2765a - 0x2765c
int32_t function_2765a(void) {
    // 0x2765a
    int32_t result; // 0x2765a
    return result;
}

// Address range: 0x2765c - 0x27660
int32_t function_2765c(void) {
    // 0x2765c
    int32_t str; // 0x2765c
    return snprintf((char *)str, str, (char *)str);
}

// Address range: 0x27662 - 0x27664
int32_t function_27662(void) {
    // 0x27662
    int32_t result; // 0x27662
    return result;
}

// Address range: 0x27664 - 0x27668
int32_t function_27664(void) {
    // 0x27664
    return 0;
}

// Address range: 0x2766a - 0x2766c
int32_t function_2766a(void) {
    // 0x2766a
    int32_t result; // 0x2766a
    return result;
}

// Address range: 0x2766c - 0x27674
int32_t function_2766c(void) {
    // 0x2766c
    int32_t v1; // 0x2766c
    return function_27458(function_2e584(v1, (int32_t *)v1, v1));
}

// Address range: 0x27674 - 0x27678
int32_t function_27674(void) {
    // 0x27674
    return function_427cb8();
}

// Address range: 0x2767e - 0x27686
int32_t function_2767e(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x2767e
    return result;
}

// Address range: 0x27686 - 0x27688
int32_t function_27686(void) {
    // 0x27686
    int32_t result; // 0x27686
    return result;
}

// Address range: 0x27688 - 0x2768c
int32_t function_27688(void) {
    // 0x27688
    int32_t result; // 0x27688
    return result;
}

// Address range: 0x2768e - 0x27694
int32_t function_2768e(int32_t a1, int32_t result) {
    // 0x2768e
    return result;
}

// Address range: 0x27694 - 0x27696
int32_t function_27694(int32_t result, int32_t a2) {
    // 0x27694
    return result;
}

// Address range: 0x27696 - 0x27698
int32_t function_27696(void) {
    // 0x27696
    int32_t result; // 0x27696
    return result;
}

// Address range: 0x27698 - 0x276a0
int32_t function_27698(void) {
    // 0x27698
    __asm_vldr(-0x1400335d);
    int32_t result; // 0x27698
    return result;
}

// Address range: 0x276a6 - 0x276a8
int32_t function_276a6(void) {
    // 0x276a6
    return function_271c4();
}

// Address range: 0x276aa - 0x276ac
int32_t function_276aa(void) {
    // 0x276aa
    int32_t result; // 0x276aa
    return result;
}

// Address range: 0x276ac - 0x276b0
int32_t function_276ac(int32_t a1) {
    // 0x276ac
    return a1 + 16;
}

// Address range: 0x276b0 - 0x276b4
int32_t function_276b0(void) {
    // 0x276b0
    int32_t result; // 0x276b0
    return result;
}

// Address range: 0x276b4 - 0x276b8
int32_t function_276b4(void) {
    // 0x276b4
    return __asm_adr(28);
}

// Address range: 0x276b8 - 0x276bc
int32_t function_276b8(int32_t result) {
    // 0x276b8
    return result;
}

// Address range: 0x276bc - 0x276c0
int32_t function_276bc(void) {
    // 0x276bc
    int32_t result; // 0x276bc
    return result;
}

// Address range: 0x276c0 - 0x276c4
int32_t function_276c0(int32_t a1, int32_t a2, int32_t a3) {
    // 0x276c0
    return function_27200(a1);
}

// Address range: 0x276c4 - 0x276c8
int32_t function_276c4(void) {
    // 0x276c4
    int32_t result; // 0x276c4
    int32_t v1 = result;
    *(int16_t *)v1 = (int16_t)v1;
    return result;
}

// Address range: 0x276c8 - 0x276d0
int32_t function_276c8(void) {
    // 0x276c8
    int32_t v1; // 0x276c8
    return function_1ead4(v1);
}

// Address range: 0x276d2 - 0x276d4
int32_t function_276d2(int32_t a1) {
    // 0x276d2
    int32_t result; // 0x276d2
    return result;
}

// Address range: 0x276d4 - 0x276dc
int32_t function_276d4(void) {
    // 0x276d4
    int32_t v1; // 0x276d4
    return function_1e29c(v1);
}

// Address range: 0x276dc - 0x276e4
int32_t function_276dc(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x276dc
    return 0;
}

// Address range: 0x276e6 - 0x276e8
int32_t function_276e6(void) {
    // 0x276e6
    int32_t result; // 0x276e6
    return result;
}

// Address range: 0x276e8 - 0x276ec
int32_t function_276e8(int32_t a1) {
    // 0x276e8
    return function_27da0();
}

// Address range: 0x276ee - 0x276f0
int32_t function_276ee(void) {
    // 0x276ee
    int32_t result; // 0x276ee
    return result;
}

// Address range: 0x276f2 - 0x276f8
int32_t function_276f2(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x276f2
    return function_27226();
}

// Address range: 0x276fa - 0x276fc
int32_t function_276fa(void) {
    // 0x276fa
    return function_27248();
}

// Address range: 0x276fc - 0x27700
int32_t function_276fc(void) {
    // 0x276fc
    return 0;
}

// Address range: 0x27700 - 0x27704
int32_t function_27700(int32_t result) {
    // 0x27700
    return result;
}

// Address range: 0x27706 - 0x27708
int32_t function_27706(void) {
    // 0x27706
    return function_2728e();
}

// Address range: 0x27708 - 0x2770c
int32_t function_27708(void) {
    // 0x27708
    int32_t result; // 0x27708
    return result;
}

// Address range: 0x2770e - 0x27710
int32_t function_2770e(void) {
    // 0x2770e
    int32_t result; // 0x2770e
    return result;
}

// Address range: 0x27712 - 0x27714
int32_t function_27712(void) {
    // 0x27712
    int32_t result; // 0x27712
    return result;
}

// Address range: 0x27714 - 0x27718
int32_t function_27714(int32_t a1, int32_t a2, int32_t a3) {
    // 0x27714
    *(int32_t *)a1 = a2;
    *(int32_t *)(a1 + 4) = a3;
    return a1 + 8;
}

// Address range: 0x27718 - 0x2771e
int32_t function_27718(int32_t result, int32_t a2) {
    // 0x27718
    return result;
}

// Address range: 0x2771e - 0x27732
int32_t function_2771e(int16_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x2771e
    bool v1; // 0x2771e
    if (!v1) {
        // 0x27722
        __asm_svcne(0x96e8ae);
    }
    return result;
}

// Address range: 0x27732 - 0x27734
int32_t function_27732(void) {
    // 0x27732
    int32_t result; // 0x27732
    return result;
}

// Address range: 0x27734 - 0x2773c
int32_t function_27734(int32_t a1, int32_t a2, int32_t a3) {
    // 0x27734
    return 2 * a1;
}

// Address range: 0x2773c - 0x27740
int32_t function_2773c(void) {
    // 0x2773c
    int32_t result; // 0x2773c
    return result;
}

// Address range: 0x27740 - 0x27742
int32_t function_27740(void) {
    // 0x27740
    int32_t result; // 0x27740
    return result;
}

// Address range: 0x27742 - 0x27744
int32_t function_27742(void) {
    // 0x27742
    int32_t result; // 0x27742
    return result;
}

// Address range: 0x27746 - 0x2774a
int32_t function_27746(int32_t a1) {
    // 0x27746
    __asm_ldc_20(15, 8, a1, 960);
    int32_t result; // 0x27746
    return result;
}

// Address range: 0x2774c - 0x27750
int32_t function_2774c(int32_t result) {
    // 0x2774c
    return result;
}

// Address range: 0x27750 - 0x27754
int32_t function_27750(int32_t a1) {
    // 0x27750
    *(int32_t *)a1 = a1;
    return a1 + 4;
}

// Address range: 0x27756 - 0x2775c
int32_t function_27756(int32_t a1) {
    // 0x27756
    return function_27298(a1);
}

// Address range: 0x2775c - 0x27760
int32_t function_2775c(int32_t result) {
    // 0x2775c
    return result;
}

// Address range: 0x27762 - 0x27764
int32_t function_27762(void) {
    // 0x27762
    return function_27876();
}

// Address range: 0x27764 - 0x27768
int32_t function_27764(int32_t a1) {
    // 0x27764
    return a1 + 8;
}

// Address range: 0x27768 - 0x2776c
int32_t function_27768(void) {
    // 0x27768
    return function_272d4(4);
}

// Address range: 0x2776e - 0x27770
int32_t function_2776e(int32_t a1) {
    // 0x2776e
    int32_t result; // 0x2776e
    return result;
}

// Address range: 0x27772 - 0x27778
int32_t function_27772(int32_t result) {
    // 0x27772
    __asm_adr(result);
    return result;
}

// Address range: 0x2777a - 0x27780
int32_t function_2777a(int32_t a1, int32_t result, int32_t a3, int32_t a4) {
    // 0x2777a
    return result;
}

// Address range: 0x27782 - 0x27784
int32_t function_27782(void) {
    // 0x27782
    int32_t result; // 0x27782
    return result;
}

// Address range: 0x27784 - 0x27786
int32_t function_27784(void) {
    // 0x27784
    int32_t v1; // 0x27784
    return function_27800(v1, v1, v1);
}

// Address range: 0x27786 - 0x2778a
int32_t function_27786(void) {
    // 0x27786
    int32_t result; // 0x27786
    return result;
}

// Address range: 0x2778a - 0x27790
int32_t function_2778a(int32_t a1) {
    // 0x2778a
    __asm_cdp(0, 0, 2, 5, 4, 0);
    return function_272f2();
}

// Address range: 0x27790 - 0x277a4
int32_t function_27790(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t result = a1; // 0x27794
    if (a3 > 39) {
        result = function_277c0();
    }
    // 0x27798
    int32_t v1; // 0x27790
    __asm_vmov_7(*(int32_t *)(v1 + 4 * a4));
    return result;
}

// Address range: 0x277a6 - 0x277aa
int32_t function_277a6(void) {
    // 0x277a6
    int32_t result; // 0x277a6
    return result;
}

// Address range: 0x277aa - 0x277ab
int32_t function_277aa(int32_t a1) {
    // 0x277aa
    int32_t result; // 0x277aa
    return result;
}

// Address range: 0x277ae - 0x277ba
int32_t function_277ae(void) {
    // 0x277ae
    bool v1; // 0x277ae
    if (v1) {
        // 0x277b2
        function_ff9e3052();
        function_ff22329a();
    }
    // 0x277b6
    return function_46328e();
}

// Address range: 0x277be - 0x277bf
int32_t function_277be(void) {
    // 0x277be
    int32_t result; // 0x277be
    return result;
}

// Address range: 0x277c0 - 0x277c1
int32_t function_277c0(void) {
    // 0x277c0
    int32_t result; // 0x277c0
    return result;
}

// Address range: 0x277c2 - 0x277da
int32_t function_277c2(int32_t a1, int32_t a2) {
    // 0x277c2
    bool v1; // 0x277c2
    if (v1) {
        function_fe4632aa();
    }
    if (v1) {
        // 0x277ce
        function_2a32b2();
    } else {
        // 0x277ca
        function_ffa22fea();
        function_ff1e306e();
    }
    int32_t result = function_4632aa(); // 0x277d2
    if (v1) {
        int32_t v2; // 0x277c2
        *(int32_t *)v2 = (int32_t)&g21;
        *(int32_t *)(v2 + 4) = 0x277dc;
    }
    return result;
}

// Address range: 0x277da - 0x277e0
int32_t function_277da(int32_t a1) {
    // 0x277da
    int32_t v1; // 0x277da
    return function_2771e(*(int16_t *)(2 * a1), 3, v1, v1);
}

// Address range: 0x277e6 - 0x277e8
int32_t function_277e6(void) {
    // 0x277e6
    int32_t v1; // 0x277e6
    return function_27714(v1, v1, v1);
}

// Address range: 0x277ea - 0x277ee
int32_t function_277ea(void) {
    // 0x277ea
    int32_t result; // 0x277ea
    return result;
}

// Address range: 0x277ee - 0x277ef
int32_t function_277ee(int32_t a1) {
    // 0x277ee
    int32_t result; // 0x277ee
    return result;
}

// Address range: 0x277f4 - 0x277f6
int32_t function_277f4(int32_t a1) {
    // 0x277f4
    int32_t result; // 0x277f4
    return result;
}

// Address range: 0x277f6 - 0x277fa
int32_t function_277f6(void) {
    // 0x277f6
    int32_t result; // 0x277f6
    return result;
}

// Address range: 0x277fa - 0x277fb
int32_t function_277fa(void) {
    // 0x277fa
    int32_t result; // 0x277fa
    return result;
}

// Address range: 0x27800 - 0x27802
int32_t function_27800(int32_t result, int32_t a2, int32_t a3) {
    // 0x27800
    return result;
}

// Address range: 0x27804 - 0x27808
int32_t function_27804(int32_t a1) {
    // 0x27804
    return a1 + 1;
}

// Address range: 0x27808 - 0x2780c
int32_t function_27808(int32_t result) {
    // 0x27808
    return result;
}

// Address range: 0x2780c - 0x27814
int32_t function_2780c(int32_t a1) {
    // 0x2780c
    int32_t result; // 0x2780c
    return result;
}

// Address range: 0x27810 - 0x27811
int32_t function_27810(void) {
    // 0x27810
    int32_t result; // 0x27810
    return result;
}

// Address range: 0x27814 - 0x27818
int32_t function_27814(int32_t a1) {
    // 0x27814
    return function_27346();
}

// Address range: 0x27818 - 0x2781c
int32_t function_27818(int32_t a1) {
    // 0x27818
    *(char *)a1 = (char)a1;
    int32_t v1; // 0x27818
    return function_27354(a1, v1);
}

// Address range: 0x2781c - 0x27820
int32_t function_2781c(int32_t a1) {
    // 0x2781c
    return function_27348(a1);
}

// Address range: 0x27820 - 0x27834
int32_t function_27820(int32_t a1, int32_t a2, uint32_t a3, int32_t a4) {
    int32_t result = a1; // 0x27828
    if (a3 >= 3 == (a3 != 3)) {
        result = function_27860();
    }
    // 0x2782c
    int32_t v1; // 0x27820
    __asm_vldr_8(v1);
    return result;
}

// Address range: 0x27836 - 0x27838
int32_t function_27836(void) {
    // 0x27836
    int32_t result; // 0x27836
    return result;
}

// Address range: 0x2783a - 0x2783c
int32_t function_2783a(int32_t a1) {
    // 0x2783a
    int32_t result; // 0x2783a
    return result;
}

// Address range: 0x2783c - 0x27840
int32_t function_2783c(int32_t a1) {
    // 0x2783c
    return 0;
}

// Address range: 0x27840 - 0x27844
int32_t function_27840(int32_t result, int32_t a2) {
    // 0x27840
    return result;
}

// Address range: 0x27844 - 0x27848
int32_t function_27844(void) {
    // 0x27844
    return 0;
}

// Address range: 0x27848 - 0x2784c
int32_t function_27848(int32_t a1) {
    // 0x27848
    return a1 + 7;
}

// Address range: 0x2784e - 0x27850
int32_t function_2784e(void) {
    // 0x2784e
    int32_t v1; // 0x2784e
    return function_2738c(v1, v1);
}

// Address range: 0x27852 - 0x27853
int32_t function_27852(void) {
    // 0x27852
    int32_t result; // 0x27852
    return result;
}

// Address range: 0x27854 - 0x27858
int32_t function_27854(void) {
    // 0x27854
    int32_t result; // 0x27854
    return result;
}

// Address range: 0x27858 - 0x27860
int32_t function_27858(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x27858
    return function_27810();
}

// Address range: 0x27860 - 0x27864
int32_t function_27860(void) {
    // 0x27860
    int32_t result; // 0x27860
    return result;
}

// Address range: 0x27866 - 0x27868
int32_t function_27866(int32_t a1, int32_t a2) {
    // 0x27866
    return function_27384(a1);
}

// Address range: 0x2786a - 0x2786c
int32_t function_2786a(void) {
    // 0x2786a
    return function_27388();
}

// Address range: 0x2786e - 0x27870
int32_t function_2786e(int32_t a1) {
    // 0x2786e
    int32_t result; // 0x2786e
    return result;
}

// Address range: 0x27870 - 0x27874
int32_t function_27870(void) {
    // 0x27870
    return 6;
}

// Address range: 0x27876 - 0x27878
int32_t function_27876(void) {
    // 0x27876
    int32_t result; // 0x27876
    return result;
}

// Address range: 0x27878 - 0x27884
int32_t function_27878(void) {
    // 0x27878
    int32_t str; // 0x27878
    return snprintf((char *)str, 2048, (char *)str);
}

// Address range: 0x27886 - 0x27888
int32_t function_27886(void) {
    // 0x27886
    int32_t result; // 0x27886
    return result;
}

// Address range: 0x27888 - 0x2788c
int32_t function_27888(int32_t result) {
    // 0x27888
    return result;
}

// Address range: 0x2788e - 0x27892
int32_t function_2788e(void) {
    // 0x2788e
    int32_t result; // 0x2788e
    return result;
}

// Address range: 0x27892 - 0x27893
int32_t function_27892(void) {
    // 0x27892
    int32_t result; // 0x27892
    return result;
}

// Address range: 0x27894 - 0x27896
int32_t function_27894(void) {
    // 0x27894
    int32_t result; // 0x27894
    return result;
}

// Address range: 0x27896 - 0x27898
int32_t function_27896(void) {
    // 0x27896
    int32_t result; // 0x27896
    return result;
}

// Address range: 0x2789a - 0x2789c
int32_t function_2789a(void) {
    // 0x2789a
    int32_t result; // 0x2789a
    return result;
}

// Address range: 0x2789c - 0x2789e
int32_t function_2789c(void) {
    // 0x2789c
    return function_278ac();
}

// Address range: 0x2789e - 0x278a0
int32_t function_2789e(void) {
    // 0x2789e
    int32_t result; // 0x2789e
    return result;
}

// Address range: 0x278a2 - 0x278a4
int32_t function_278a2(void) {
    // 0x278a2
    int32_t result; // 0x278a2
    return result;
}

// Address range: 0x278a4 - 0x278aa
int32_t function_278a4(int32_t a1, int32_t a2) {
    // 0x278a4
    int32_t result; // 0x278a4
    return result;
}

// Address range: 0x278aa - 0x278ac
int32_t function_278aa(void) {
    // 0x278aa
    int32_t result; // 0x278aa
    return result;
}

// Address range: 0x278ac - 0x278ae
int32_t function_278ac(void) {
    // 0x278ac
    int32_t v1; // 0x278ac
    return function_278b0(v1, v1);
}

// Address range: 0x278ae - 0x278b0
int32_t function_278ae(void) {
    // 0x278ae
    int32_t result; // 0x278ae
    return result;
}

// Address range: 0x278b0 - 0x278b2
int32_t function_278b0(int32_t result, int32_t a2) {
    // 0x278b0
    return result;
}

// Address range: 0x278b2 - 0x278b8
int32_t function_278b2(int32_t result, int32_t a2, int32_t a3) {
    // 0x278b2
    int32_t v1; // 0x278b2
    *(int32_t *)v1 = result;
    *(int32_t *)(v1 + 4) = a3;
    return result;
}

// Address range: 0x278ba - 0x278bc
int32_t function_278ba(void) {
    // 0x278ba
    int32_t result; // 0x278ba
    return result;
}

// Address range: 0x278bc - 0x278c0
int32_t function_278bc(int32_t result) {
    // 0x278bc
    return result;
}

// Address range: 0x278c0 - 0x278c4
int32_t function_278c0(int32_t a1) {
    // 0x278c0
    return a1 - 46;
}

// Address range: 0x278c4 - 0x278c6
int32_t function_278c4(void) {
    // 0x278c4
    int32_t result; // 0x278c4
    return result;
}

// Address range: 0x278c6 - 0x278c8
int32_t function_278c6(void) {
    // 0x278c6
    int32_t result; // 0x278c6
    return result;
}

// Address range: 0x278c8 - 0x278d4
int32_t function_278c8(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x278c8
    int32_t v1; // 0x278c8
    *(char *)v1 = (char)a4;
    return function_2e584(a1, (int32_t *)a2, a3);
}

// Address range: 0x278d4 - 0x278e8
int32_t function_278d4(void) {
    // 0x278d4
    int32_t v1; // 0x278d4
    uint32_t v2 = v1;
    int32_t result; // 0x278d4
    if (v2 == 3 || v2 < 3) {
        result = function_27694(v1, v1);
    }
    // 0x278e4
    return result;
}

// Address range: 0x278ea - 0x278ec
int32_t function_278ea(void) {
    // 0x278ea
    int32_t result; // 0x278ea
    return result;
}

// Address range: 0x278ec - 0x278f0
int32_t function_278ec(int32_t a1, int32_t a2, int32_t a3) {
    // 0x278ec
    *(int32_t *)a1 = a2;
    *(int32_t *)(a1 + 4) = a3;
    return a1 + 8;
}

// Address range: 0x278f2 - 0x278f6
int32_t function_278f2(void) {
    // 0x278f2
    int32_t result; // 0x278f2
    return result;
}

// Address range: 0x278f6 - 0x278f7
int32_t function_278f6(void) {
    // 0x278f6
    int32_t result; // 0x278f6
    return result;
}

// Address range: 0x278f8 - 0x278fc
int32_t function_278f8(void) {
    // 0x278f8
    return 0;
}

// Address range: 0x278fe - 0x27904
int32_t function_278fe(void) {
    // 0x278fe
    int32_t result; // 0x278fe
    return result;
}

// Address range: 0x27906 - 0x27908
int32_t function_27906(void) {
    // 0x27906
    int32_t result; // 0x27906
    return result;
}

// Address range: 0x27908 - 0x27918
int32_t function_27908(int32_t a1, int32_t a2) {
    // 0x27908
    int32_t v1; // 0x27908
    *(int16_t *)v1 = (int16_t)a2;
    int32_t v2; // bp+600, 0x27908
    int32_t v3 = function_2e584(a1, &v2, v1); // 0x27910
    return function_27694(v3, (int32_t)&v2);
}

// Address range: 0x27918 - 0x27934
int32_t function_27918(void) {
    // 0x27918
    int32_t v1; // 0x27918
    return function_27694(v1, v1);
}

// Address range: 0x27934 - 0x27940
int32_t function_27934(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x27934
    return function_427f78();
}

// Address range: 0x27940 - 0x27a58
int32_t function_27940(void) {
    // 0x27940
    if (g360 != 0) {
        // 0x27964
        return 0;
    }
    // 0x27970
    int32_t attr; // bp-2100, 0x27940
    pthread_attr_init(&attr);
    function_12024(&attr, &g1);
    int32_t v1; // 0x27940
    int32_t v2 = function_11eb0(1, 64, v1, v1); // 0x2798c
    g360 = v2;
    char * v3; // bp-2064, 0x27940
    if (function_30b10(v2, &attr, (int32_t *)0x259a8, v2) != 0) {
        char * v4 = g289; // 0x279b8
        if (v4 != (char *)3 && v4 >= (char *)3) {
            // 0x279c8
            v3 = (char *)0x61657263;
            function_2e584(3, (int32_t *)&v3, 0);
        }
        // 0x27964
        return -1;
    }
    // 0x27a00
    function_11fa0(*(int32_t *)(g360 + 12));
    char * v5 = g289; // 0x27a14
    if (v5 != (char *)3 && v5 >= (char *)3) {
        // 0x27a20
        v3 = (char *)0x61657263;
        function_2e584(3, (int32_t *)&v3, 0);
    }
    // 0x27964
    return 0;
}

// Address range: 0x27a58 - 0x27b70
int32_t function_27a58(void) {
    // 0x27a58
    if (g361 != 0) {
        // 0x27a7c
        return 0;
    }
    // 0x27a88
    int32_t attr; // bp-2100, 0x27a58
    pthread_attr_init(&attr);
    function_12024(&attr, &g358);
    int32_t v1; // 0x27a58
    int32_t v2 = function_11eb0(1, 64, v1, v1); // 0x27aa4
    g361 = v2;
    char * v3; // bp-2064, 0x27a58
    if (function_30b10(v2, &attr, (int32_t *)0x2600c, v2) != 0) {
        char * v4 = g289; // 0x27ad0
        if (v4 != (char *)3 && v4 >= (char *)3) {
            // 0x27ae0
            v3 = (char *)0x61657263;
            function_2e584(3, (int32_t *)&v3, 0);
        }
        // 0x27a7c
        return -1;
    }
    // 0x27b18
    function_11fa0(*(int32_t *)(g361 + 12));
    char * v5 = g289; // 0x27b2c
    if (v5 != (char *)3 && v5 >= (char *)3) {
        // 0x27b38
        v3 = (char *)0x61657263;
        function_2e584(3, (int32_t *)&v3, 0);
    }
    // 0x27a7c
    return 0;
}

// Address range: 0x27b70 - 0x27c88
int32_t function_27b70(void) {
    // 0x27b70
    if (g362 != 0) {
        // 0x27b94
        return 0;
    }
    // 0x27ba0
    int32_t attr; // bp-2100, 0x27b70
    pthread_attr_init(&attr);
    function_12024(&attr, &g8);
    int32_t v1; // 0x27b70
    int32_t v2 = function_11eb0(1, 64, v1, v1); // 0x27bbc
    g362 = v2;
    char * v3; // bp-2064, 0x27b70
    if (function_30b10(v2, &attr, &g18, v2) != 0) {
        char * v4 = g289; // 0x27be8
        if (v4 != (char *)3 && v4 >= (char *)3) {
            // 0x27bf8
            v3 = (char *)0x61657263;
            function_2e584(3, (int32_t *)&v3, 0);
        }
        // 0x27b94
        return -1;
    }
    // 0x27c30
    function_11fa0(*(int32_t *)(g362 + 12));
    char * v5 = g289; // 0x27c44
    if (v5 != (char *)3 && v5 >= (char *)3) {
        // 0x27c50
        v3 = (char *)0x61657263;
        function_2e584(3, (int32_t *)&v3, 0);
    }
    // 0x27b94
    return 0;
}

// Address range: 0x27c88 - 0x27da0
int32_t function_27c88(void) {
    // 0x27c88
    if (g363 != 0) {
        // 0x27cac
        return 0;
    }
    // 0x27cb8
    int32_t attr; // bp-2100, 0x27c88
    pthread_attr_init(&attr);
    function_12024(&attr, &g8);
    int32_t v1; // 0x27c88
    int32_t v2 = function_11eb0(1, 64, v1, v1); // 0x27cd4
    g363 = v2;
    char * v3; // bp-2064, 0x27c88
    if (function_30b10(v2, &attr, &g20, v2) != 0) {
        char * v4 = g289; // 0x27d00
        if (v4 != (char *)3 && v4 >= (char *)3) {
            // 0x27d10
            v3 = (char *)0x61657263;
            function_2e584(3, (int32_t *)&v3, 0);
        }
        // 0x27cac
        return -1;
    }
    // 0x27d48
    function_11fa0(*(int32_t *)(g363 + 12));
    char * v5 = g289; // 0x27d5c
    if (v5 != (char *)3 && v5 >= (char *)3) {
        // 0x27d68
        v3 = (char *)0x61657263;
        function_2e584(3, (int32_t *)&v3, 0);
    }
    // 0x27cac
    return 0;
}

// Address range: 0x27da0 - 0x27eb8
int32_t function_27da0(void) {
    // 0x27da0
    if (g364 != 0) {
        // 0x27dc4
        return 0;
    }
    // 0x27dd0
    int32_t attr; // bp-2100, 0x27da0
    pthread_attr_init(&attr);
    function_12024(&attr, &g8);
    int32_t v1; // 0x27da0
    int32_t v2 = function_11eb0(1, 64, v1, v1); // 0x27dec
    g364 = v2;
    char * v3; // bp-2064, 0x27da0
    if (function_30b10(v2, &attr, (int32_t *)0x271e8, v2) != 0) {
        char * v4 = g289; // 0x27e18
        if (v4 != (char *)3 && v4 >= (char *)3) {
            // 0x27e28
            v3 = (char *)0x61657263;
            function_2e584(3, (int32_t *)&v3, 0);
        }
        // 0x27dc4
        return -1;
    }
    // 0x27e60
    function_11fa0(*(int32_t *)(g364 + 12));
    char * v5 = g289; // 0x27e74
    if (v5 != (char *)3 && v5 >= (char *)3) {
        // 0x27e80
        v3 = (char *)0x61657263;
        function_2e584(3, (int32_t *)&v3, 0);
    }
    // 0x27dc4
    return 0;
}

// Address range: 0x27eb8 - 0x27f58
int32_t function_27eb8(void) {
    // 0x27eb8
    if (g360 == 0) {
        // 0x27f14
        int32_t result; // 0x27eb8
        return result;
    }
    int32_t result2 = function_11fb8(); // 0x27ed8
    if (*(int32_t *)(g360 + 12) == result2) {
        // 0x27f14
        return result2;
    }
    char * v1 = g289; // 0x27ef0
    int32_t v2 = (int32_t)v1; // 0x27ef8
    int32_t v3 = g360; // 0x27ef8
    int32_t v4; // 0x27eb8
    int32_t v5; // 0x27eb8
    if (v1 >= (char *)3 == (v1 != (char *)3)) {
        char * v6 = (char *)0x636e6163; // bp-2064, 0x27f30
        function_2e584(3, (int32_t *)&v6, 0);
        v3 = g360;
        v4 = (int32_t)&v6;
        v5 = 0;
        v2 = 2660;
    }
    // 0x27efc
    function_2fe84(v3);
    int32_t result3 = free(g360, v4, v5, v2); // 0x27f08
    g360 = 0;
    // 0x27f14
    return result3;
}

// Address range: 0x27f58 - 0x27ff8
int32_t function_27f58(void) {
    // 0x27f58
    if (g361 == 0) {
        // 0x27fb4
        int32_t result; // 0x27f58
        return result;
    }
    int32_t result2 = function_11fb8(); // 0x27f78
    if (*(int32_t *)(g361 + 12) == result2) {
        // 0x27fb4
        return result2;
    }
    char * v1 = g289; // 0x27f90
    int32_t v2 = (int32_t)v1; // 0x27f98
    int32_t v3 = g361; // 0x27f98
    int32_t v4; // 0x27f58
    int32_t v5; // 0x27f58
    if (v1 >= (char *)3 == (v1 != (char *)3)) {
        char * v6 = (char *)0x636e6163; // bp-2064, 0x27fd0
        function_2e584(3, (int32_t *)&v6, 0);
        v3 = g361;
        v4 = (int32_t)&v6;
        v5 = 0;
        v2 = 2660;
    }
    // 0x27f9c
    function_2fe84(v3);
    int32_t result3 = free(g361, v4, v5, v2); // 0x27fa8
    g361 = 0;
    // 0x27fb4
    return result3;
}

// Address range: 0x27ff8 - 0x28098
int32_t function_27ff8(void) {
    // 0x27ff8
    if (g362 == 0) {
        // 0x28054
        int32_t result; // 0x27ff8
        return result;
    }
    int32_t result2 = function_11fb8(); // 0x28018
    if (*(int32_t *)(g362 + 12) == result2) {
        // 0x28054
        return result2;
    }
    char * v1 = g289; // 0x28030
    int32_t v2 = (int32_t)v1; // 0x28038
    int32_t v3 = g362; // 0x28038
    int32_t v4; // 0x27ff8
    int32_t v5; // 0x27ff8
    if (v1 >= (char *)3 == (v1 != (char *)3)) {
        char * v6 = (char *)0x636e6163; // bp-2064, 0x28070
        function_2e584(3, (int32_t *)&v6, 0);
        v3 = g362;
        v4 = (int32_t)&v6;
        v5 = 0;
        v2 = 2660;
    }
    // 0x2803c
    function_2fe84(v3);
    int32_t result3 = free(g362, v4, v5, v2); // 0x28048
    g362 = 0;
    // 0x28054
    return result3;
}

// Address range: 0x28098 - 0x28138
int32_t function_28098(void) {
    // 0x28098
    if (g363 == 0) {
        // 0x280f4
        int32_t result; // 0x28098
        return result;
    }
    int32_t result2 = function_11fb8(); // 0x280b8
    if (*(int32_t *)(g363 + 12) == result2) {
        // 0x280f4
        return result2;
    }
    char * v1 = g289; // 0x280d0
    int32_t v2 = (int32_t)v1; // 0x280d8
    int32_t v3 = g363; // 0x280d8
    int32_t v4; // 0x28098
    int32_t v5; // 0x28098
    if (v1 >= (char *)3 == (v1 != (char *)3)) {
        char * v6 = (char *)0x636e6163; // bp-2064, 0x28110
        function_2e584(3, (int32_t *)&v6, 0);
        v3 = g363;
        v4 = (int32_t)&v6;
        v5 = 0;
        v2 = 2660;
    }
    // 0x280dc
    function_2fe84(v3);
    int32_t result3 = free(g363, v4, v5, v2); // 0x280e8
    g363 = 0;
    // 0x280f4
    return result3;
}

// Address range: 0x28138 - 0x281b8
int32_t function_28138(int32_t a1) {
    if (a1 > (int32_t)&g25) {
        // 0x281a8
        function_1eb74();
        function_304d4(100);
    }
    char * v1 = g289; // 0x2815c
    if (v1 != (char *)3 && v1 >= (char *)3) {
        // 0x28168
        int32_t str; // bp-2056, 0x28138
        snprintf((char *)&str, 2048, "set UART baud to %d\n", a1);
        function_2e584(3, &str, 0);
    }
    // 0x28190
    function_1e9cc(a1);
    function_1e160();
    return function_14f20();
}

// Address range: 0x281b8 - 0x281d4
int32_t function_281b8(void) {
    // 0x281b8
    function_28138(0xb71b00);
    return function_304d4(100);
}

// Address range: 0x281d4 - 0x28208
int32_t function_281d4(int32_t a1, int32_t a2) {
    // 0x281d4
    int32_t v1; // bp-12, 0x281d4
    return function_52bf0("bitmain_submit_nonce", a1, a2, &v1);
}

// Address range: 0x28208 - 0x28238
int32_t function_28208(int32_t a1, int32_t a2) {
    // 0x28208
    int32_t v1; // bp-12, 0x28208
    return function_52bf0("bitmain_api_status", a1, a2, &v1);
}

// Address range: 0x2823c - 0x282c0
int32_t function_2823c(void) {
    // 0x2823c
    puts("bmminer_socket_init");
    if (function_5261c((int32_t)&g273, 4) != 0) {
        function_12030(3);
        while (function_5261c((int32_t)&g273, 4) != 0) {
            // 0x28254
            function_12030(3);
        }
    }
    // 0x28270
    puts("regist ..");
    function_52930((int32_t)"bitmain_submit_nonce");
    if (function_52930((int32_t)"bitmain_api_status") == 0) {
        // 0x282ac
        puts("regist done!");
        return 0;
    }
    function_12030(3);
    function_52930((int32_t)"bitmain_submit_nonce");
    while (function_52930((int32_t)"bitmain_api_status") != 0) {
        // 0x2828c
        function_12030(3);
        function_52930((int32_t)"bitmain_submit_nonce");
    }
    // 0x282ac
    puts("regist done!");
    return 0;
}

// Address range: 0x282c4 - 0x282e4
int32_t function_282c4(int32_t a1) {
    // 0x282c4
    *(char *)a1 = 1;
    *(char *)&g60 = 1;
    return 0;
}

// Address range: 0x282e4 - 0x2832c
int32_t function_282e4(int32_t format, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = a2; // bp-12, 0x282e4
    vsnprintf((char *)&g365, 512, (char *)format, (int32_t)&v1);
    function_2e584(3, (int32_t *)&g365, 1);
    exit(1);
    // UNREACHABLE
}

// Address range: 0x2832c - 0x28340
int32_t function_2832c(void) {
    // 0x2832c
    int32_t v1; // 0x2832c
    function_3d3d4(v1, (int32_t *)&g367);
    return 0;
}

// Address range: 0x28344 - 0x28358
int32_t function_28344(void) {
    // 0x28344
    int32_t v1; // 0x28344
    function_3d3d4(v1, (int32_t *)&g368);
    return 0;
}

// Address range: 0x2835c - 0x28370
int32_t function_2835c(void) {
    // 0x2835c
    int32_t v1; // 0x2835c
    function_3d3d4(v1, (int32_t *)&g369);
    return 0;
}

// Address range: 0x28374 - 0x2838c
int32_t function_28374(void) {
    // 0x28374
    int32_t v1; // 0x28374
    function_3d3d4(v1, (int32_t *)&g216);
    return 0;
}

// Address range: 0x2838c - 0x283e0
int32_t function_2838c(int32_t a1) {
    // 0x2838c
    int32_t v1; // 0x2838c
    function_11f34("%s\nBuilt with bitmain_c5 mining support.\n", &g370, v1, v1);
    function_11f34("%s", (int32_t *)g457, v1, (int32_t)&g457);
    function_11f58(g318);
    exit(0);
    return &g488;
}

// Address range: 0x283e4 - 0x28870
int32_t function_283e4(void) {
    // 0x283e4
    prctl(PR_SET_NAME, (int32_t)&g251, 0, 0, 0);
    if (*(char *)(g214 + 364) != 0) {
        // 0x286d0
        return 0;
    }
    int32_t v1 = &g61;
    int32_t v2 = &g221;
    int32_t v3 = &g219; // 0x283e4
    int32_t v4; // 0x283e4
    int32_t v5; // 0x283e4
    int32_t v6; // 0x283e4
    int32_t v7; // 0x283e4
    int32_t v8; // 0x283e4
    int32_t v9; // 0x283e4
    int32_t str; // bp-2088, 0x283e4
    int32_t str2; // 0x285c8
    int32_t v10; // 0x28500
    while (true) {
      lab_0x28458:;
        int32_t v11 = v2;
        function_11f94(&g373, v1, v11, v3);
        pthread_cond_wait(&g377, &g373);
        int32_t v12; // 0x283e4
        int32_t v13; // 0x283e4
        int32_t v14; // bp-2152, 0x283e4
        if (sysinfo((struct sysinfo *)&v14) == 0) {
            // 0x28864
            *(int32_t *)((int32_t)&g219 >> 31) = (int32_t)&g219;
            v12 = &g373;
            v13 = (int32_t)&g219 >> 31;
        } else {
            int32_t v15 = &g373; // 0x28488
            int32_t v16 = v11; // 0x28488
            if ((*(char *)&g60 | *(char *)&g221) == 0 != g290 < 6) {
                int32_t err_num = *__errno_location(); // 0x284b8
                char * err_str = strerror(err_num); // 0x284c0
                snprintf((char *)&str, 2048, "Failed to get sysinfo, errno:%u, reason:%s\n", err_num, err_str);
                function_2e584(6, &str, 0);
                v15 = &str;
                v16 = 0;
            }
            // 0x284f0
            g219 = function_11fe8(0);
            v12 = v15;
            v13 = v16;
        }
        // 0x28500
        v10 = function_4e1b0();
        function_1f340(v10);
        function_1f3e8(v10);
        function_1f490(v10);
        function_1f574(v10, v12, v13);
        function_1f6ac(v10);
        function_1f7c4(v10, (int32_t)&g488);
        function_1f8b0(v10);
        function_1f984();
        function_1fa2c(v10);
        int32_t v17 = function_4e540(); // 0x2855c
        int32_t v18 = 0;
        int32_t v19 = 0;
        int32_t v20 = &g219; // 0x28574
        int32_t v21; // 0x286e0
        if (function_1e29c(v19) != 0) {
            // 0x286e0
            v21 = function_4e1b0();
            if (g61 != 0) {
                // 0x28710
                if ((*(char *)&g60 | *(char *)&g221) == 0 != g290 < 7) {
                    // 0x28748
                    snprintf((char *)&str, 2048, "%s: now i = %d", "bitmain_update_api_stats", v19);
                    function_2e584(7, &str, 0);
                }
            }
            // 0x28760
            function_4efd4(v21, "index", function_4e990(v19, v18));
            function_1fdd8(v21, v19);
            function_1fe9c(v21, v19);
            function_20234(v21, v19);
            function_200d0(v21);
            function_20528(v21, v19);
            function_20398(v21);
            function_205ec(v21);
            function_206b4(v21, v19);
            function_20880(v21, v19);
            function_208cc(v21, v19);
            function_20918();
            function_20964();
            function_209bc();
            function_4f494(v17, v21);
            v20 = (int32_t)"bitmain_update_api_stats";
        }
        int32_t v22 = v20;
        int32_t v23 = v19 + 1; // 0x28578
        int32_t v24 = v18 + (int32_t)(v19 == -1); // 0x2857c
        while (v23 == 4 != (v24 == 0)) {
            // 0x28564
            v18 = v24;
            v19 = v23;
            v20 = v22;
            if (function_1e29c(v19) != 0) {
                // 0x286e0
                v21 = function_4e1b0();
                if (g61 != 0) {
                    // 0x28710
                    if ((*(char *)&g60 | *(char *)&g221) == 0 != g290 < 7) {
                        // 0x28748
                        snprintf((char *)&str, 2048, "%s: now i = %d", "bitmain_update_api_stats", v19);
                        function_2e584(7, &str, 0);
                    }
                }
                // 0x28760
                function_4efd4(v21, "index", function_4e990(v19, v18));
                function_1fdd8(v21, v19);
                function_1fe9c(v21, v19);
                function_20234(v21, v19);
                function_200d0(v21);
                function_20528(v21, v19);
                function_20398(v21);
                function_205ec(v21);
                function_206b4(v21, v19);
                function_20880(v21, v19);
                function_208cc(v21, v19);
                function_20918();
                function_20964();
                function_209bc();
                function_4f494(v17, v21);
                v20 = (int32_t)"bitmain_update_api_stats";
            }
            // 0x28578
            v22 = v20;
            v23 = v19 + 1;
            v24 = v18 + (int32_t)(v19 == -1);
        }
        // 0x2858c
        function_4efd4(v10, "chain", v17);
        function_20ad4(v10);
        function_20b7c(v10);
        function_20c28(v10);
        function_20a50(v10);
        str2 = function_4b1a8(v10, 0);
        v4 = 0;
        v5 = 0;
        v7 = v17;
        v9 = v22;
        if (str2 == 0) {
            goto lab_0x28674;
        } else {
            // 0x285d4
            v6 = v17;
            v8 = 0;
            if (g61 == 0) {
                goto lab_0x28658;
            } else {
                // 0x285e4
                if ((*(char *)&g60 | *(char *)&g221) == 0) {
                    // 0x28608
                    v6 = v17;
                    v8 = g290;
                    if (g290 < 7) {
                        goto lab_0x28658;
                    } else {
                        goto lab_0x2861c;
                    }
                } else {
                    goto lab_0x2861c;
                }
            }
        }
    }
    // 0x286d0
    return 0;
  lab_0x28674:;
    int32_t v25 = v7;
    int32_t v26 = v5;
    int32_t v27 = v26; // 0x28678
    int32_t v28 = v25; // 0x28678
    int32_t v29 = v9; // 0x28678
    if (v10 != 0) {
        int32_t v30 = v10 + 4; // 0x2867c
        int32_t * v31 = (int32_t *)v30; // 0x2867c
        v27 = v26;
        v28 = v25;
        v29 = -1;
        if (*v31 != -1) {
            // 0x28688
            __asm_dmb(v4, v26, v25, v30);
            int32_t v32 = *v31;
            int32_t v33 = v32 - 1; // 0x28694
            while (__asm_strex(v33, v32) != 0) {
                // 0x28690
                v32 = *v31;
                v33 = v32 - 1;
            }
            // 0x286a4
            v27 = 0;
            v28 = v33;
            v29 = v30;
            if (v33 == 0) {
                // 0x286ac
                function_4eb6c(v10);
                v27 = 0;
                v28 = 0;
                v29 = v30;
            }
        }
    }
    // 0x286b4
    v2 = v28;
    v1 = v27;
    function_11ea4(&g373, v1, v2, v29);
    v3 = 0;
    if (*(char *)(g214 + 364) != 0) {
        return 0;
    }
    goto lab_0x28458;
  lab_0x28658:;
    int32_t v34 = strlen((char *)str2) + 1; // 0x28660
    function_28208(str2, v34);
    v4 = free(str2, v34, v6, v8);
    v5 = v34;
    v7 = v6;
    v9 = v8;
    goto lab_0x28674;
  lab_0x2861c:;
    char * str3 = (char *)str2; // 0x28620
    int32_t len = strlen(str3); // 0x28620
    snprintf((char *)&str, 2048, "%s(%d) : %s", "bitmain_update_api_stats", len + 1, str3);
    function_2e584(7, &str, 0);
    v6 = 0;
    v8 = (int32_t)"bitmain_update_api_stats";
    goto lab_0x28658;
}

// Address range: 0x28878 - 0x288c4
int32_t function_28878(void) {
    // 0x28878
    sigaction(SIGTERM, (struct sigaction *)&g226, NULL);
    sigaction(SIGINT, (struct sigaction *)&g230, NULL);
    sigaction(SIGABRT, (struct sigaction *)&g215, NULL);
    function_31cac();
    exit(0);
    return &g488;
}

// Address range: 0x288c4 - 0x289b4
int32_t function_288c4(int32_t a1) {
    // 0x288c4
    if (g378 == NULL) {
        // 0x289a8
        g378 = __strdup((char *)a1);
    }
    int32_t v1 = g379 + 1; // 0x288e8
    g379 = v1;
    if (v1 > 10) {
        // 0x28900
        return 0x6368c;
    }
    char * str = (char *)a1; // 0x28918
    int32_t v2; // bp-276, 0x288c4
    int32_t v3 = function_4d6e4(str, 0, &v2); // 0x28918
    if (v3 != 0) {
        // 0x28924
        if (*(int32_t *)v3 == 0) {
            // 0x28990
            return function_289b8(v3, 1);
        }
    }
    // 0x28930
    int32_t str2; // bp-184, 0x288c4
    int32_t size = strlen(str) + 35 + strlen((char *)&str2); // 0x28950
    int32_t str3 = function_2f408(size, "bmminer.c", "load_config", 902); // 0x28964
    snprintf((char *)str3, size, "JSON decode of file '%s' failed\n %s", str, &str2);
    return str3;
}

// Address range: 0x289b8 - 0x28d38
int32_t function_289b8(int32_t a1, int32_t a2) {
    int32_t v1; // 0x289b8
    if (a2 != 0) {
        // 0x289d4
        v1 = g382;
        if (g382 == 0) {
            g382 = 1;
            v1 = 1;
        }
    }
    // 0x289ec
    int32_t v2; // 0x289b8
    int32_t v3; // 0x289b8
    int32_t v4; // 0x289b8
    int32_t v5; // 0x289b8
    int32_t v6; // 0x289b8
    int32_t v7; // 0x289b8
    int32_t v8; // 0x289b8
    int32_t v9; // 0x289b8
    int32_t v10; // 0x289b8
    int32_t v11; // 0x289b8
    int32_t v12; // 0x289b8
    int32_t v13; // 0x289b8
    char * v14; // 0x289b8
    char * v15; // 0x289b8
    int32_t v16; // 0x289b8
    int32_t v17; // 0x289b8
    int32_t * v18; // 0x289b8
    int32_t v19; // 0x28a98
    uint32_t v20; // 0x28aa4
    int32_t v21; // 0x28aa8
    if (g275 != 16) {
        if ((g275 & 8) != 0) {
            // 0x28d1c
            __assert_fail("!(opt->type & OPT_SUBTABLE)", "bmminer.c", 734, "parse_config");
            return &g488;
        }
        int32_t v22 = v1; // 0x289b8
        int32_t v23 = g275; // 0x289b8
        int32_t v24 = (int32_t)&g276; // 0x289b8
        while (true) {
            int32_t v25 = v24;
            int32_t v26 = v22;
            int32_t v27 = *(int32_t *)(v25 - 28); // 0x28a48
            int32_t v28; // 0x289b8
            int32_t v29; // 0x289b8
            if (v27 == 0) {
                int32_t v30 = *(int32_t *)(v25 + 4); // 0x28a30
                v28 = v26;
                v29 = v30;
                if (v30 == 16) {
                    // break -> 0x28b60
                    break;
                }
            } else {
                char * str = __strdup((char *)v27); // 0x28a54
                char * next_token = strtok(str, "|"); // 0x28a60
                v6 = v26;
                v12 = v23;
                if (next_token != NULL) {
                    int32_t * v31 = (int32_t *)(v25 - 24);
                    v18 = (int32_t *)(v25 - 8);
                    v5 = v26;
                    v14 = next_token;
                    while (true) {
                      lab_0x28a84:
                        // 0x28a84
                        v15 = v14;
                        int32_t v32 = (int32_t)v15;
                        unsigned char v33 = *(char *)(v32 + 1); // 0x28a84
                        v4 = v5;
                        v11 = v33;
                        if (v33 == 45) {
                            // 0x28a90
                            v19 = function_4e234(a1, (char *)(v32 + 2));
                            v4 = 0;
                            v11 = 45;
                            if (v19 == 0) {
                                goto lab_0x28a70_2;
                            } else {
                                // 0x28aa4
                                v20 = *v31;
                                v21 = *(int32_t *)v19;
                                if ((v20 & 6) == 0) {
                                    goto lab_0x28ac4;
                                } else {
                                    switch (v21) {
                                        case 2: {
                                            int32_t v34 = function_4e768(v19); // 0x28c04
                                            int32_t v35 = *v31; // 0x28c18
                                            v7 = v35;
                                            v13 = v34;
                                            if (v35 == 4) {
                                                // 0x28c28
                                                function_3d3d4(v34, (int32_t *)*v18);
                                                v7 = 4;
                                                v13 = v34;
                                            }
                                            goto lab_0x28bb4;
                                        }
                                        case 1: {
                                            int32_t v36 = function_4e5a0(v19); // 0x28c68
                                            v4 = v19;
                                            v11 = 0;
                                            v8 = v19;
                                            v16 = 0;
                                            if (v36 != 0) {
                                                while (true) {
                                                  lab_0x28c74:
                                                    // 0x28c74
                                                    v17 = v16;
                                                    int32_t v37 = v8;
                                                    int32_t v38 = function_4e5bc(v19, v17); // 0x28c7c
                                                    v4 = v37;
                                                    v11 = 0;
                                                    if (v38 == 0) {
                                                        // break -> 0x28a70
                                                        break;
                                                    }
                                                    // 0x28c88
                                                    v2 = v37;
                                                    v9 = v38;
                                                    switch (*(int32_t *)v38) {
                                                        case 2: {
                                                            int32_t v39 = function_4e768(v38); // 0x28cb8
                                                            int32_t v40 = *v31; // 0x28ccc
                                                            v3 = v40;
                                                            v10 = v39;
                                                            if (v40 == 4) {
                                                                // 0x28d04
                                                                function_3d3d4(v39, (int32_t *)*v18);
                                                                v3 = 4;
                                                                v10 = v39;
                                                            }
                                                            goto lab_0x28cdc;
                                                        }
                                                        case 0: {
                                                            // 0x28cf8
                                                            v3 = v37;
                                                            v10 = function_289b8(v38, 0);
                                                            goto lab_0x28cdc;
                                                        }
                                                        default: {
                                                            goto lab_0x28c9c;
                                                        }
                                                    }
                                                }
                                            }
                                            goto lab_0x28a70_2;
                                        }
                                        default: {
                                            goto lab_0x28ac4;
                                        }
                                    }
                                }
                            }
                        } else {
                            goto lab_0x28a70_2;
                        }
                    }
                }
              lab_0x28b4c:
                // 0x28b4c
                free((int32_t)str, (int32_t)"|", v6, v12);
                int32_t v41 = *(int32_t *)(v25 + 4); // 0x28b54
                v28 = v6;
                v29 = v41;
                if (v41 == 16) {
                    // break -> 0x28b60
                    break;
                }
            }
            // 0x28a3c
            v22 = v28;
            v23 = v29;
            v24 = v25 + 28;
            if ((v29 & 8) != 0) {
                // 0x28d1c
                __assert_fail("!(opt->type & OPT_SUBTABLE)", "bmminer.c", 734, "parse_config");
                return &g488;
            }
        }
    }
    int32_t v42 = function_4e234(a1, "include"); // 0x28b6c
    if (v42 == 0) {
        // 0x28bf4
        return 0;
    }
    // 0x28b78
    if (*(int32_t *)v42 == 2) {
        // 0x28b84
        return function_288c4(function_4e768(v42));
    }
    // 0x28bf4
    return 0;
  lab_0x28ad8:;
    // 0x28ad8
    int32_t v43; // 0x289b8
    int32_t v44 = v43; // 0x28ae0
    int32_t v45 = v43; // 0x28ae0
    if (a2 == 0) {
        // 0x28bc8
        snprintf((char *)&g380, 200, "Parsing JSON option %s: %s", v15, (char *)v45);
        return (int32_t)&g380;
    }
    goto lab_0x28ae4;
  lab_0x28c9c:;
    int32_t v48 = v17 + 1; // 0x28c9c
    uint32_t v49 = function_4e5a0(v19); // 0x28ca4
    v4 = v2;
    v11 = v9;
    v8 = v2;
    v16 = v48;
    if (v49 >= v48 != v49 != v48) {
        // break -> 0x28a70
        goto lab_0x28a70_2;
    }
    goto lab_0x28c74;
  lab_0x28cdc:
    // 0x28cdc
    v43 = v10;
    v2 = v3;
    v9 = 0;
    if (v10 != 0) {
        goto lab_0x28ad8;
    }
    goto lab_0x28c9c;
  lab_0x28a70_2:;
    char * next_token2 = strtok(NULL, "|"); // 0x28a78
    v5 = v4;
    v14 = next_token2;
    v6 = v4;
    v12 = v11;
    if (next_token2 == NULL) {
        // break -> 0x28b4c
        goto lab_0x28b4c;
    }
    goto lab_0x28a84;
  lab_0x28ac4:;
    int32_t v50 = v21 - 5; // 0x28ac4
    int32_t v51 = v50 != 0 == (v50 != 1) ? 0x636f4 : v21;
    v43 = v51;
    if (v50 == 1 || v50 == 0) {
        int32_t v52 = *v18; // 0x28ba0
        v7 = v50;
        v13 = v52;
        if (v20 % 2 == 0) {
            if (v51 == 5) {
                // 0x28cf0
                function_3d2f0(v52);
                v4 = v50;
                v11 = 5;
            } else {
                // 0x28c48
                function_3d300(v52);
                v4 = v50;
                v11 = v51;
            }
            goto lab_0x28a70_2;
        } else {
            goto lab_0x28bb4;
        }
    } else {
        goto lab_0x28ad8;
    }
  lab_0x28bb4:;
    int32_t v53 = v13;
    v4 = v7;
    v11 = 0;
    if (v53 == 0) {
        goto lab_0x28a70_2;
    } else {
        // 0x28bbc
        v44 = v53;
        v45 = v53;
        if (a2 == 0) {
            // 0x28bc8
            snprintf((char *)&g380, 200, "Parsing JSON option %s: %s", v15, (char *)v45);
            return (int32_t)&g380;
        }
        goto lab_0x28ae4;
    }
  lab_0x28ae4:;
    int32_t v46 = v44;
    int32_t v47; // 0x289b8
    if ((*(char *)&g60 | *(char *)&g221) == 0) {
        // 0x28b04
        v47 = g290;
        if (g290 < 3) {
            goto lab_0x28b40;
        } else {
            goto lab_0x28b18;
        }
    } else {
        goto lab_0x28b18;
    }
  lab_0x28b18:;
    // 0x28b18
    int32_t str2; // bp-2088, 0x289b8
    snprintf((char *)&str2, 2048, "Invalid config option %s: %s", v15, (char *)v46);
    function_2e584(3, &str2, 0);
    v47 = 0;
    goto lab_0x28b40;
  lab_0x28b40:
    // 0x28b40
    g382 = -1;
    v4 = v47;
    v11 = -1;
    goto lab_0x28a70_2;
}

// Address range: 0x28d40 - 0x28d70
int32_t function_28d40(int32_t a1, uint32_t a2) {
    int32_t v1 = function_3d4f0(a1, a2); // 0x28d48
    int32_t result = v1; // 0x28d50
    if (v1 == 0) {
        // 0x28d54
        result = a2 >= 0x270f == (a2 != 0x270f) ? (int32_t)"Value out of range" : 0;
    }
    return result;
}

// Address range: 0x28d70 - 0x28d9c
int32_t function_28d70(int32_t a1, uint32_t a2) {
    int32_t v1 = function_3d4f0(a1, a2); // 0x28d78
    int32_t result = v1; // 0x28d80
    if (v1 == 0) {
        // 0x28d84
        result = a2 >= 100 == (a2 != 100) ? (int32_t)"Value out of range" : 0;
    }
    return result;
}

// Address range: 0x28d9c - 0x28dd0
int32_t function_28d9c(int32_t a1, int32_t a2) {
    int32_t v1 = function_3d4f0(a1, a2); // 0x28da4
    int32_t result = v1; // 0x28dac
    if (v1 == 0) {
        uint32_t v2 = a2 - 1; // 0x28dc0
        result = v2 >= 0xfffe == (v2 != 0xfffe) ? (int32_t)"Value out of range" : 0;
    }
    return result;
}

// Address range: 0x28dd0 - 0x28e18
int32_t function_28dd0(int32_t a1, int32_t a2, int32_t a3) {
    // 0x28dd0
    int32_t str; // bp-2056, 0x28dd0
    snprintf((char *)&str, 2048, "Free work called with NULL work from %s %s:%d", (char *)a1, (char *)a2, a3);
    return function_2e584(3, &str, 0);
}

// Address range: 0x28e18 - 0x28e74
int32_t function_28e18(int32_t a1, int32_t a2) {
    int32_t v1 = *__errno_location(); // 0x28e30
    int32_t str; // bp-2064, 0x28e18
    snprintf((char *)&str, 2048, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", v1, "bmminer.c", (char *)a1, a2);
    return function_2e584(3, &str, 1);
}

// Address range: 0x28e74 - 0x28ee8
int32_t function_28e74(int32_t a1, int32_t a2, int32_t a3) {
    int32_t result = 0; // 0x28e94
    if (function_11f70(a1, 0) != 0) {
        int32_t v1 = *__errno_location(); // 0x28ec8
        int32_t str; // bp-2064, 0x28e74
        snprintf((char *)&str, 2048, "Failed to pthread_rwlock_init errno=%d in %s %s():%d", v1, "bmminer.c", (char *)a2, a3);
        result = function_2e584(3, &str, 1);
    }
    // 0x28e98
    return result;
}

// Address range: 0x28ee8 - 0x28f5c
int32_t function_28ee8(int32_t a1, int32_t a2, int32_t a3) {
    // 0x28ee8
    if (function_12048(a1) == 0) {
        // 0x28f08
        return 0;
    }
    int32_t v1 = *__errno_location(); // 0x28f24
    int32_t str; // bp-2064, 0x28ee8
    snprintf((char *)&str, 2048, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", v1, "bmminer.c", (char *)a2, a3);
    return function_2e584(3, &str, 1);
}

// Address range: 0x28f5c - 0x28fb8
int32_t function_28f5c(char * a1, int32_t a2) {
    int32_t v1 = *__errno_location(); // 0x28f74
    int32_t str; // bp-2064, 0x28f5c
    snprintf((char *)&str, 2048, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", v1, "bmminer.c", a1, a2);
    return function_2e584(3, &str, 1);
}

// Address range: 0x28fb8 - 0x29014
int32_t function_28fb8(char * a1, int32_t a2) {
    int32_t v1 = *__errno_location(); // 0x28fd0
    int32_t str; // bp-2064, 0x28fb8
    snprintf((char *)&str, 2048, "Failed to pthread_mutex_init errno=%d in %s %s():%d", v1, "bmminer.c", a1, a2);
    return function_2e584(3, &str, 1);
}

// Address range: 0x29014 - 0x29070
int32_t function_29014(char * a1, int32_t a2) {
    int32_t v1 = *__errno_location(); // 0x2902c
    int32_t str; // bp-2064, 0x29014
    snprintf((char *)&str, 2048, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", v1, "bmminer.c", a1, a2);
    return function_2e584(3, &str, 1);
}

// Address range: 0x29070 - 0x290b4
int32_t function_29070(int32_t * a1, char * a2, int32_t a3) {
    int32_t v1 = (int32_t)a1;
    if (function_11fdc(v1, 0) != 0) {
        // 0x290a4
        function_28fb8(a2, a3);
    }
    // 0x29090
    return function_28e74(v1 + 24, (int32_t)a2, a3);
}

// Address range: 0x290b4 - 0x292d4
int32_t function_290b4(void) {
    int32_t result = function_2f490(1, 448, "bmminer.c", "make_work", 1368); // 0x290dc
    int32_t v1 = 448; // 0x290e4
    int32_t v2 = (int32_t)"bmminer.c"; // 0x290e4
    int32_t v3 = (int32_t)"make_work"; // 0x290e4
    char * str; // bp-2064, 0x290b4
    if (result == 0) {
        // 0x29168
        str = (char *)0x6c696146;
        function_2e584(3, (int32_t *)&str, 1);
        v1 = (int32_t)&str;
        v2 = 1;
        v3 = 0;
    }
    // 0x290e8
    int32_t v4; // 0x290b4
    int32_t v5; // 0x290b4
    if (function_11f94(&g222, v1, v2, v3) == 0) {
        int32_t v6 = function_12048((int32_t)&g223); // 0x29100
        v5 = v1;
        if (v6 == 0) {
            goto lab_0x2910c;
        } else {
            // 0x290fc
            v4 = (int32_t)&str;
            goto lab_0x291fc;
        }
    } else {
        int32_t v7 = *__errno_location(); // 0x291c0
        snprintf((char *)&str, 2048, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", v7, "bmminer.c", "total_work_inc", 1359);
        int32_t v8 = (int32_t)&str;
        function_2e584(3, (int32_t *)&str, 1);
        int32_t v9 = function_12048((int32_t)&g223); // 0x291f0
        v5 = v8;
        v4 = v8;
        if (v9 == 0) {
            goto lab_0x2910c;
        } else {
            goto lab_0x291fc;
        }
    }
  lab_0x2910c:;
    int32_t v10 = g383; // 0x29118
    int32_t v11 = v10 + 1; // 0x2911c
    g383 = v11;
    int32_t v12 = pthread_rwlock_unlock(&g223); // 0x29124
    int32_t v13 = v5; // 0x2912c
    int32_t v14 = v11; // 0x2912c
    int32_t v15 = (int32_t)&g365; // 0x2912c
    if (v12 != 0) {
        int32_t v16 = *__errno_location(); // 0x2925c
        snprintf((char *)&str, 2048, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", v16, "bmminer.c", "total_work_inc", 1361);
        function_2e584(3, (int32_t *)&str, 1);
        v13 = (int32_t)&str;
        v14 = 1;
        v15 = v16;
    }
    // 0x29130
    if (function_11ea4(&g222, v13, v14, v15) != 0) {
        int32_t v17 = *__errno_location(); // 0x292a4
        snprintf((char *)&str, 2048, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", v17, "bmminer.c", "total_work_inc", 1361);
        function_2e584(3, (int32_t *)&str, 1);
    }
    // 0x29144
    function_2f250();
    *(int32_t *)(result + 340) = v10;
    return result;
  lab_0x291fc:;
    char * str2 = (char *)&str;
    int32_t v18 = *__errno_location(); // 0x29214
    snprintf(str2, 2048, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", v18, "bmminer.c", "total_work_inc", 1359);
    function_2e584(3, (int32_t *)&str, 1);
    v5 = v4;
    goto lab_0x2910c;
}

// Address range: 0x292e0 - 0x2932c
int32_t function_292e0(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = function_3d4f0(a1, a2); // 0x292f0
    int32_t result = v1; // 0x292f8
    if (v1 == 0) {
        // 0x292fc
        result = !((a2 < a3 | a2 > a4)) ? 0 : (int32_t)"Value out of range";
    }
    return result;
}

// Address range: 0x2932c - 0x2935c
int32_t function_2932c(int32_t str, int32_t a2, int32_t a3) {
    int32_t * v1 = (int32_t *)a3; // 0x29348
    int32_t items_assigned = sscanf((char *)str, "%d-%d", (int32_t *)a2, v1); // 0x29348
    if (items_assigned == 1) {
        *v1 = (int32_t)"%d-%d";
    }
    return items_assigned;
}

// Address range: 0x2935c - 0x29458
int32_t function_2935c(int32_t str) {
    // 0x2935c
    if (g216 != NULL) {
        // 0x29378
        if (*g216 != 0) {
            // 0x29424
            return (int32_t)strcpy((char *)str, g216);
        }
    }
    // 0x29384
    char * str2; // 0x2935c
    if (getenv("HOME") == NULL) {
        goto lab_0x293b0;
    } else {
        // 0x29398
        if (*getenv("HOME") == 0) {
            goto lab_0x293b0;
        } else {
            // 0x2942c
            *(int16_t *)function_1203c(str, (int32_t)getenv("HOME")) = 47;
            str2 = (char *)str;
            goto lab_0x293b8;
        }
    }
  lab_0x293b0:;
    char * v1 = (char *)str;
    *v1 = 0;
    str2 = v1;
    goto lab_0x293b8;
  lab_0x293b8:;
    int32_t v2 = strlen(str2) + str; // 0x293c4
    *(int32_t *)v2 = 0x6d6d622e;
    *(int32_t *)(v2 + 4) = 0x72656e69;
    *(int16_t *)(v2 + 8) = 47;
    mkdir(str2, 511);
    int32_t v3 = strlen(str2) + str; // 0x293fc
    *(int32_t *)v3 = 0x696d6d62;
    *(int32_t *)(v3 + 4) = 0x2e72656e;
    *(char *)(v3 + 12) = 0;
    *(int32_t *)(v3 + 8) = 0x666e6f63;
    return 0x696d6d62;
}

// Address range: 0x29458 - 0x294b4
int32_t function_29458(void) {
    int32_t v1 = function_2f408(0x1000, "bmminer.c", "load_default_config", 950); // 0x29478
    g378 = (char *)v1;
    function_2935c(v1);
    int32_t v2 = access(g378, R_OK); // 0x2948c
    int32_t v3 = (int32_t)g378; // 0x29494
    if (v2 == 0) {
        // 0x294ac
        return function_288c4(v3);
    }
    int32_t result = free(v3, v2, (int32_t)"load_default_config", 950); // 0x2949c
    g378 = NULL;
    return result;
}

// Address range: 0x294b8 - 0x294b9
int32_t function_294b8(void) {
    // 0x294b8
    int32_t result; // 0x294b8
    return result;
}

// Address range: 0x294ba - 0x29564
int32_t function_294ba(int32_t a1, int32_t a2) {
    // 0x294ba
    int32_t v1; // 0x294ba
    uint32_t v2 = v1;
    function_464f96();
    bool v3; // 0x294ba
    bool v4; // 0x294ba
    if (v4) {
        __asm_svcmi(0xf0eef1);
    } else {
        // .critedge
        v3 = (v1 & 0x20000) != 0;
    }
    if (v3 == !v4) {
        function_e1b4e();
    }
    bool v5 = v3; // 0x294ca
    if (v4 || false) {
        __asm_cdple(13, 8, 14, 2, 13, 1);
        v5 = (v1 & 8) != 0;
    }
    int32_t v6; // 0x294ba
    int32_t v7; // 0x294ba
    int32_t v8; // 0x294ba
    int32_t v9; // 0x294ba
    int32_t v10; // 0x294ba
    int32_t v11; // 0x294ba
    int32_t v12; // 0x294ba
    int32_t v13; // 0x294ba
    int32_t v14; // 0x294ba
    int32_t v15; // 0x294ba
    int32_t v16; // 0x294ba
    int32_t v17; // 0x294ba
    int32_t v18; // 0x294ba
    int32_t v19; // 0x294ba
    int32_t v20; // 0x294ba
    int32_t v21; // 0x294ba
    int32_t v22; // 0x294ba
    int32_t v23; // 0x294ba
    bool v24; // 0x294ba
    bool v25; // 0x294ba
    bool v26; // 0x294ba
    bool v27; // 0x294ba
    bool v28; // 0x294ba
    bool v29; // 0x294ba
    if (v4) {
        int32_t v30 = v1 >> 4; // 0x294d2
        int32_t v31 = v2 - v30; // 0x294d2
        v25 = v2 >= v30;
        v29 = v2 == v30;
        v27 = v31 < 0;
        v13 = v30;
        v17 = v30;
        v19 = v30;
        v21 = v30;
        v23 = v30;
        v7 = v30;
        v9 = v30;
        v11 = v30;
        v15 = v30;
        v24 = v2 >= v30;
        v28 = v2 == v30;
        v26 = v31 < 0;
        v12 = v30;
        v16 = v30;
        v18 = v30;
        v20 = v30;
        v22 = v30;
        v6 = v30;
        v8 = v30;
        v10 = v30;
        v14 = v30;
        if (((v31 ^ v2) & (v30 ^ v2)) < 0) {
            goto lab_0x294da;
        } else {
            goto lab_dec_label_pc_unknown_16;
        }
    } else {
        v25 = v5;
        v29 = false;
        v24 = v5;
        v28 = false;
        if (v4) {
            goto lab_0x294da;
        } else {
            goto lab_dec_label_pc_unknown_16;
        }
    }
  lab_0x294da:;
    // 0x294da
    int32_t v32; // 0x294ba
    int32_t v33 = v32; // 0x294ba
    int32_t v34 = v15; // 0x294ba
    int32_t v35; // 0x294ba
    int32_t v36 = v35; // 0x294ba
    int32_t v37 = v11; // 0x294ba
    int32_t v38; // 0x294ba
    int32_t v39 = v38; // 0x294ba
    int32_t v40 = v9; // 0x294ba
    int32_t v41; // 0x294ba
    int32_t v42 = v41; // 0x294ba
    int32_t v43 = v7; // 0x294ba
    int32_t v44; // 0x294ba
    int32_t v45 = v44; // 0x294ba
    int32_t v46 = v23; // 0x294ba
    int32_t v47; // 0x294ba
    int32_t v48 = v47; // 0x294ba
    int32_t v49 = v21; // 0x294ba
    int32_t v50; // 0x294ba
    int32_t v51 = v50; // 0x294ba
    int32_t v52 = v19; // 0x294ba
    int32_t v53; // 0x294ba
    int32_t v54 = v53; // 0x294ba
    int32_t v55 = v17; // 0x294ba
    int32_t v56 = v13; // 0x294ba
    int32_t v57; // 0x294ba
    int32_t v58 = v57; // 0x294ba
    bool v59 = v27; // 0x294ba
    bool v60 = v29; // 0x294ba
    bool v61 = v25; // 0x294ba
    bool v62 = true; // 0x294ba
    int32_t v63 = function_fe32bcde(); // 0x294ba
    goto lab_0x294de;
  lab_dec_label_pc_unknown_16:;
    int32_t v73; // 0x294ba
    v33 = v73;
    v34 = v14;
    int32_t v74; // 0x294ba
    v36 = v74;
    v37 = v10;
    int32_t v75; // 0x294ba
    v39 = v75;
    v40 = v8;
    int32_t v76; // 0x294ba
    v42 = v76;
    v43 = v6;
    int32_t v77; // 0x294ba
    v45 = v77;
    v46 = v22;
    int32_t v78; // 0x294ba
    v48 = v78;
    v49 = v20;
    int32_t v79; // 0x294ba
    v51 = v79;
    v52 = v18;
    int32_t v80; // 0x294ba
    v54 = v80;
    v55 = v16;
    v56 = v12;
    int32_t v81; // 0x294ba
    v58 = v81;
    v59 = v26;
    v60 = v28;
    v61 = v24;
    v62 = false;
    v63 = function_fe3a4b5e();
    goto lab_0x294de;
  lab_0x294de:;
    bool v64 = v60;
    int32_t v65 = v63; // 0x294de
    if (v61 == !v64) {
        v65 = function_64b62();
    }
    int32_t v66 = v65; // 0x294e2
    if (!v62) {
        v66 = function_224f02();
    }
    int32_t v67 = v66; // 0x294e6
    if (v64) {
        v67 = function_624d8e();
    }
    int32_t result = v67; // 0x294ea
    if (v58 <= v56) {
        result = function_924636();
    }
    // 0x294ee
    if (v62) {
        // 0x29562
        return result;
    }
    if (v33 <= v34) {
        function_ffba1b7e();
    }
    if (v64) {
        function_5a4b82();
    }
    // 0x29506
    function_fe22460e();
    if ((result & 4) != 0 == !v64) {
        function_11e4b8a();
    }
    int32_t v68 = function_224d26(); // 0x2950e
    if (v64) {
        v68 = function_624db6();
    }
    int32_t result2 = v68; // 0x29512
    if (v36 <= v37) {
        result2 = function_6a465e();
    }
    // 0x29516
    if (v39 < v40) {
        // 0x29562
        return result2;
    }
    if (v45 <= v46) {
        function_ff921ba6();
    }
    if (v64) {
        function_5a4baa();
    }
    bool v69 = v42 < v43 ? (result & 4) != 0 : (result2 & 4) != 0;
    function_fe0a4636();
    if (v69 == !v64) {
        function_11e4bb2();
    }
    int32_t v70 = function_224d4e(); // 0x29536
    if (v64) {
        v70 = function_624dde();
    }
    int32_t result3 = v70; // 0x2953a
    if (v48 <= v49) {
        result3 = function_424686();
    }
    // 0x2953e
    if (v64 || !v69) {
        // 0x29562
        return result3;
    }
    if (v51 <= v52) {
        function_ff6a1bce();
    }
    int32_t v71 = function_1f27d52(); // 0x29552
    if (((result3 & 4) != 0 || v69 != !v64) == !v64) {
        v71 = function_122465e();
    }
    int32_t v72 = v71; // 0x2955a
    if (v54 <= v55) {
        v72 = function_2246a6();
    }
    int32_t result4 = v72; // 0x2955e
    if (v59) {
        result4 = function_17a7d66();
    }
    // 0x29562
    return result4;
}

// Address range: 0x29564 - 0x2964c
int32_t function_29564(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10) {
    // 0x29564
    int32_t v1; // 0x29564
    char * v2 = (char *)(v1 % 0x10000 | (int32_t)&g51); // 0x29570
    int32_t v3 = a1; // 0x29584
    float64_t v4; // 0x29564
    int32_t result; // 0x295ac
    if (*v2 == 0) {
        // 0x2958c
        result = function_30ea8(v1, &v3, 32, "bmminer.c", (int32_t)"set_target", 1124);
        __asm_vpop(v4);
        return result;
    }
    int32_t v5 = function_2f670(&v3, 32); // 0x295c8
    int32_t v6 = 0; // 0x295d8
    int32_t v7 = 32; // 0x295d8
    if (*v2 == 0) {
        goto lab_0x29640;
    } else {
        // 0x295dc
        if ((*(char *)&g60 | *(char *)&g221) == 0) {
            // 0x29604
            v6 = g290;
            v7 = 32;
            if (g290 < 7) {
                goto lab_0x29640;
            } else {
                goto lab_0x29618;
            }
        } else {
            goto lab_0x29618;
        }
    }
  lab_0x29640:;
    // 0x29640
    int32_t v8; // 0x29564
    free(v5, v7, v8, v6);
    // 0x2958c
    result = function_30ea8(v1, &v3, 32, "bmminer.c", (int32_t)"set_target", 1124);
    __asm_vpop(v4);
    return result;
  lab_0x29618:;
    // 0x29618
    int32_t str; // bp+40, 0x29564
    snprintf((char *)&str, 2048, "Generated target %s", (char *)v5);
    function_2e584(7, &str, 0);
    v8 = 0;
    v6 = v5;
    v7 = &str;
    goto lab_0x29640;
}

// Address range: 0x2964c - 0x29710
int32_t function_2964c(void) {
    // 0x2964c
    if ((*(char *)&g60 | *(char *)&g221) != 0 || g290 > 2) {
        char * v1 = (char *)0x66666944; // bp+40, 0x296cc
        function_2e584(3, (int32_t *)&v1, 0);
        return 0;
    }
    // 0x29688
    return 0;
}

// Address range: 0x29710 - 0x29748
int32_t function_29710(int32_t result) {
    // 0x29710
    bool v1; // 0x29710
    if (v1) {
        // 0x29728
        __asm_stclmi(15, 15, -0x126a74b2);
        function_ffc2972c();
        if (v1) {
            // 0x29740
            return -1;
        }
        function_ffc29744();
        // 0x29740
        return -1;
    }
    if (v1) {
        // 0x29740
        return result;
    }
    // 0x29728
    function_ffc2972c();
    function_ffc29744();
    // 0x29740
    return -1;
}

// Address range: 0x2974c - 0x2a188
int32_t function_2974c(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11, int32_t a12) {
    // 0x2974c
    float64_t v1; // 0x2974c
    __asm_vpush(v1);
    int32_t * v2 = (int32_t *)(a1 + 212); // 0x2976c
    int32_t str; // bp-2088, 0x2974c
    if (function_11f94(v2, a2, a3, a4) != 0) {
        int32_t v3 = *__errno_location(); // 0x29f50
        snprintf((char *)&str, 2048, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", v3, "bmminer.c", "gen_stratum_work", 1268);
        function_2e584(3, &str, 1);
    }
    int32_t v4 = a1 + 236; // 0x2978c
    if (function_12048(v4) != 0) {
        int32_t v5 = *__errno_location(); // 0x29f94
        snprintf((char *)&str, 2048, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", v5, "bmminer.c", "gen_stratum_work", 1268);
        function_2e584(3, &str, 1);
    }
    int32_t v6 = a1 + 624; // 0x297a0
    int32_t * v7 = (int32_t *)(a1 + 1568); // 0x297a4
    int32_t v8 = *v7; // 0x297a4
    uint64_t v9 = *(int64_t *)v6; // 0x297a8
    int32_t v10 = *(int32_t *)(a1 + 1576); // 0x297b0
    int32_t * v11 = (int32_t *)(a1 + 632); // 0x297b8
    int32_t v12 = *v11; // 0x297b8
    int32_t v13 = v9 / 0x100000000; // bp-2256, 0x297c0
    int32_t v14 = v9; // bp-2252, 0x297c0
    function_30ea8(v10 + v8, &v13, v12, "bmminer.c", (int32_t)"gen_stratum_work", 1273);
    int32_t * v15 = (int32_t *)v6; // 0x297e4
    int32_t v16 = *v15; // 0x297e4
    int32_t * v17 = (int32_t *)(a1 + 628); // 0x297ec
    int32_t v18 = *v17; // 0x297ec
    *v15 = v16 + 1;
    int32_t v19 = v18 + (int32_t)(v16 == -1); // 0x297f8
    *v17 = v19;
    int32_t v20 = a2 + 296; // 0x29800
    *(int32_t *)v20 = v16;
    *(int32_t *)(a2 + 300) = v18;
    int32_t v21 = *v11; // 0x29808
    *(int32_t *)(a2 + 304) = v21;
    int32_t * rwlock = (int32_t *)v4; // 0x29810
    int32_t v22; // 0x2974c
    int32_t v23; // 0x2974c
    int32_t v24; // 0x2974c
    int32_t v25; // 0x2974c
    if (pthread_rwlock_unlock(rwlock) == 0) {
        // 0x2981c
        v23 = v19;
        v24 = v18;
        v25 = v21;
        if (function_1206c(v4) == 0) {
            goto lab_0x2982c;
        } else {
            // 0x2981c
            v22 = &str;
            goto lab_0x2a024;
        }
    } else {
        int32_t v26 = *__errno_location(); // 0x29fd8
        snprintf((char *)&str, 2048, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", v26, "bmminer.c", "gen_stratum_work", 1279);
        int32_t v27 = &str;
        function_2e584(3, &str, 1);
        v23 = v27;
        v24 = 1;
        v25 = v26;
        v22 = v27;
        if (function_1206c(v4) == 0) {
            goto lab_0x2982c;
        } else {
            goto lab_0x2a024;
        }
    }
  lab_0x2982c:;
    // 0x2982c
    char * str3; // 0x2974c
    if (function_11ea4(v2, v23, v24, v25) == 0) {
        goto lab_0x2983c;
    } else {
        // 0x2982c
        str3 = (char *)&str;
        goto lab_0x2a074;
    }
  lab_0x2a024:;
    char * str2 = (char *)&str;
    int32_t v28 = *__errno_location(); // 0x2a028
    snprintf(str2, 2048, "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d", v28, "bmminer.c", "gen_stratum_work", 1279);
    function_2e584(3, &str, 1);
    str3 = str2;
    if (function_11ea4(v2, v22, 1, v28) == 0) {
        goto lab_0x2983c;
    } else {
        goto lab_0x2a074;
    }
  lab_0x2983c:
    // 0x2983c
    function_2f1ec(*v7, *(int32_t *)(a1 + 1572), &str);
    int32_t v29 = &str; // 0x29854
    int32_t v30; // bp-2248, 0x2974c
    function_2f1ec(v29, 32, &v30);
    int32_t v31; // bp-2216, 0x2974c
    int32_t v32 = &v31; // 0x29874
    function_30ea8(v32, &v30, 32, "bmminer.c", (int32_t)"gen_stratum_work", 1283);
    int32_t * v33 = (int32_t *)(a1 + 1708); // 0x29880
    if (*v33 >= 1) {
        // 0x2989c
        int32_t v34; // bp-2184, 0x2974c
        int32_t v35 = &v34; // 0x298a8
        int32_t v36 = 0; // 0x298b0
        int32_t v37 = *(int32_t *)(*(int32_t *)(a1 + 676) + 4 * v36); // 0x298ac
        v36++;
        function_30ea8(v35, (int32_t *)v37, 32, "bmminer.c", (int32_t)"gen_stratum_work", 1287);
        function_2f1ec(v32, 64, &str);
        function_2f1ec(v29, 32, &v30);
        function_30ea8(v32, &v30, 32, "bmminer.c", (int32_t)"gen_stratum_work", 1289);
        while (*v33 > v36) {
            // 0x2989c
            v37 = *(int32_t *)(*(int32_t *)(a1 + 676) + 4 * v36);
            v36++;
            function_30ea8(v35, (int32_t *)v37, 32, "bmminer.c", (int32_t)"gen_stratum_work", 1287);
            function_2f1ec(v32, 64, &str);
            function_2f1ec(v29, 32, &v30);
            function_30ea8(v32, &v30, 32, "bmminer.c", (int32_t)"gen_stratum_work", 1289);
        }
    }
    // 0x29908
    int32_t v38; // bp-2220, 0x2974c
    int32_t v39 = (int32_t)&v38 + 4; // 0x29918
    int32_t v40 = llvm_bswap_i32(*(int32_t *)v39); // 0x29920
    int32_t v41 = (int32_t)&v14 + 4; // 0x29924
    *(int32_t *)v41 = v40;
    int32_t v42 = v41; // 0x29928
    int32_t v43 = v39; // 0x29928
    int32_t v44; // bp-2188, 0x2974c
    while (v39 != (int32_t)&v44) {
        // 0x29918
        v39 = v43 + 4;
        v40 = llvm_bswap_i32(*(int32_t *)v39);
        v41 = v42 + 4;
        *(int32_t *)v41 = v40;
        v42 = v41;
        v43 = v39;
    }
    // 0x2992c
    function_30ea8(a2, (int32_t *)(a1 + 1580), 112, "bmminer.c", (int32_t)"gen_stratum_work", 1298);
    function_30ea8(a2 + 36, &v30, 32, "bmminer.c", (int32_t)"gen_stratum_work", 1299);
    uint64_t v45 = *(int64_t *)(a1 + 1824); // 0x2997c
    int32_t v46 = v45 / 0x100000000; // 0x2997c
    int32_t * v47 = (int32_t *)(a2 + 312); // 0x29980
    *v47 = v46;
    *(int32_t *)(a2 + 316) = (int32_t)v45;
    char * v48 = __strdup((char *)*(int32_t *)(a1 + 672)); // 0x2998c
    int32_t * v49 = (int32_t *)(a2 + 288); // 0x29990
    *v49 = (int32_t)v48;
    char * v50 = __strdup((char *)*(int32_t *)(a1 + 612)); // 0x29998
    *(int32_t *)(a2 + 320) = (int32_t)v50;
    char * v51 = __strdup((char *)(a1 + 1804)); // 0x299a8
    int32_t * v52 = (int32_t *)(a2 + 308); // 0x299ac
    *v52 = (int32_t)v51;
    int32_t v53 = v46; // 0x299bc
    if (pthread_rwlock_unlock(rwlock) != 0) {
        int32_t v54 = *__errno_location(); // 0x2a0bc
        snprintf((char *)&str, 2048, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", v54, "bmminer.c", "gen_stratum_work", 1310);
        function_2e584(3, &str, 1);
        v53 = 1;
    }
    // 0x299c0
    function_2f250();
    char v55; // 0x2974c
    int32_t v56; // 0x2974c
    int32_t v57; // 0x2974c
    int32_t v58; // 0x2974c
    int32_t v59; // 0x2974c
    int32_t v60; // 0x29d10
    int32_t v61; // 0x29d20
    if (g61 == 0) {
        goto lab_0x299e4;
    } else {
        // 0x29d08
        v60 = function_2f670((int32_t *)a2, 112);
        v61 = function_2f670(&v30, 32);
        v57 = 32;
        v58 = v53;
        v59 = 0;
        if (g61 == 0) {
            goto lab_0x29e84;
        } else {
            char v62 = *(char *)&g60; // 0x29d50
            v55 = v62;
            v56 = 32;
            if ((v62 | *(char *)&g221) == 0 == g290 < 7) {
                goto lab_0x29db8;
            } else {
                // 0x29d70
                snprintf((char *)&str, 2048, "Generated stratum merkle %s", (char *)v61);
                function_2e584(7, &str, 0);
                v57 = v29;
                v58 = 0;
                v59 = 0;
                if (g61 == 0) {
                    goto lab_0x29e84;
                } else {
                    // 0x29da4
                    if (*(char *)&g221 == 0) {
                        // 0x29da4
                        v55 = *(char *)&g60;
                        v56 = v29;
                        goto lab_0x29db8;
                    } else {
                        goto lab_0x29dd8;
                    }
                }
            }
        }
    }
  lab_0x2a074:
    // 0x2a074
    __errno_location();
    snprintf(str3, 2048, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d");
    function_2e584(3, &str, 1);
    goto lab_0x2983c;
  lab_0x299e4:;
    int32_t v63 = a2; // 0x299f4
    int32_t v64 = llvm_bswap_i32(*(int32_t *)v63); // 0x299f8
    int32_t v65; // bp-2156, 0x2974c
    int32_t v66 = (int32_t)&v65 + 4; // 0x299fc
    *(int32_t *)v66 = v64;
    int32_t v67 = v63; // 0x29a04
    int32_t v68 = v66; // 0x29a04
    int32_t v69; // bp-2092, 0x2974c
    while (v66 != (int32_t)&v69) {
        // 0x299f4
        v63 = v67 + 4;
        v64 = llvm_bswap_i32(*(int32_t *)v63);
        v66 = v68 + 4;
        *(int32_t *)v66 = v64;
        v67 = v63;
        v68 = v66;
    }
    // 0x29a08
    function_2f024(&str);
    int32_t v70; // bp-2152, 0x2974c
    function_2f054(&str, &v70, 64);
    int32_t v71; // bp-1952, 0x2974c
    function_30ea8(a2 + 128, &v71, 32, "bmminer.c", (int32_t)"calc_midstate", 1029);
    __asm_vldr(*v47);
    function_294b8();
    g231++;
    int32_t v72 = function_11fe8(0) - g384; // 0x29a7c
    int32_t result = v72; // 0x29a84
    if (v72 >= 6) {
        int32_t v73 = function_11fe8(0); // 0x29a8c
        g384 = v73;
        g385 = g231;
        result = v73;
    }
    // 0x29a9c
    __asm_vldr(*v47);
    *(char *)(a2 + 284) = 1;
    *(int32_t *)(a2 + 260) = a1;
    return result;
  lab_0x29e84:
    // 0x29e84
    free(v60, v57, v58, v59);
    free(v61, v57, v58, v59);
    goto lab_0x299e4;
  lab_0x29db8:
    // 0x29db8
    if (v55 == 0) {
        // 0x29dc4
        v57 = v56;
        v58 = g290;
        v59 = g290;
        if (g290 < 7) {
            goto lab_0x29e84;
        } else {
            goto lab_0x29dd8;
        }
    } else {
        goto lab_0x29dd8;
    }
  lab_0x29dd8:
    // 0x29dd8
    snprintf((char *)&str, 2048, "Generated stratum header %s", (char *)v60);
    function_2e584(7, &str, 0);
    v57 = v29;
    v58 = 0;
    v59 = 0;
    if (g61 == 0) {
        goto lab_0x29e84;
    } else {
        // 0x29e0c
        if ((*(char *)&g60 | *(char *)&g221) == 0) {
            // 0x29e2c
            v57 = v29;
            v58 = 0;
            v59 = g290;
            if (g290 < 7) {
                goto lab_0x29e84;
            } else {
                goto lab_0x29e40;
            }
        } else {
            goto lab_0x29e40;
        }
    }
  lab_0x29e40:;
    int32_t v74 = *v52; // 0x29e48
    int32_t v75 = *v49; // 0x29e50
    int64_t v76 = *(int64_t *)v20; // 0x29e54
    snprintf((char *)&str, 2048, "Work job_id %s nonce2 %llu ntime %s", (char *)v75, v76 >> 32, (char *)v74);
    function_2e584(7, &str, 0);
    v57 = v29;
    v58 = 0;
    v59 = v75;
    goto lab_0x29e84;
}

// Address range: 0x2a1a4 - 0x2a1e0
int32_t function_2a1a4(int32_t a1) {
    // 0x2a1a4
    int32_t v1; // 0x2a1a4
    free(*(int32_t *)(a1 + 288), v1, v1, v1);
    free(*(int32_t *)(a1 + 308), v1, v1, v1);
    free(*(int32_t *)(a1 + 328), v1, v1, v1);
    free(*(int32_t *)(a1 + 320), v1, v1, v1);
    return (int32_t)memset((int32_t *)a1, 0, 448);
}

// Address range: 0x2a1e0 - 0x2a264
int32_t function_2a1e0(int32_t * a1, char * a2, char * a3, int32_t a4) {
    int32_t v1 = (int32_t)a3;
    int32_t v2 = (int32_t)a2;
    int32_t result = (int32_t)a1;
    if (a1 == NULL) {
        // 0x2a210
        if ((*(char *)&g60 | *(char *)&g221) == 0 == g290 < 3) {
            return result;
        }
        // 0x2a254
        return function_28dd0(v2, v1, a4);
    }
    // 0x2a1f0
    function_2a1a4(result);
    int32_t result2 = free(result, v2, v1, a4); // 0x2a200
    *a1 = 0;
    return result2;
}

// Address range: 0x2a264 - 0x2a3c0
int32_t function_2a264(int32_t a1, int32_t * a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t v1 = a3 + 212; // 0x2a270
    *a2 = function_290b4();
    int32_t * v2 = (int32_t *)v1; // 0x2a290
    int32_t v3; // 0x2a264
    int32_t v4; // 0x2a264
    if (function_11f94(v2, (int32_t)a2, a3, a4) != 0) {
        // 0x2a384
        function_29014("get_work_by_nonce2", 1423);
        v3 = v4;
    }
    int32_t rwlock = a3 + 236; // 0x2a2a0
    function_28ee8(rwlock, (int32_t)"get_work_by_nonce2", 1423);
    int32_t v5 = llvm_bswap_i32(v3); // 0x2a2cc
    *(int32_t *)(a3 + 624) = a5 >> 31;
    *(int32_t *)(a3 + 628) = a5;
    v4 = v5;
    function_30ea8(a3 + 1580, &v4, 4, "bmminer.c", (int32_t)"get_work_by_nonce2", 1426);
    int32_t v6; // 0x2a264
    if (pthread_rwlock_unlock((int32_t *)rwlock) == 0) {
        int32_t v7 = &v4; // 0x2a2dc
        int32_t v8 = function_11ea4(v2, v7, 4, (int32_t)"bmminer.c"); // 0x2a308
        v6 = v7;
        if (v8 == 0) {
            goto lab_0x2a314;
        } else {
            // 0x2a3b0
            function_28f5c("get_work_by_nonce2", 1427);
            v6 = 1427;
            goto lab_0x2a314;
        }
    } else {
        // 0x2a394
        function_28e18((int32_t)"get_work_by_nonce2", 1427);
        v6 = 1427;
        if (function_11ea4(v2, 1427, 4, (int32_t)"bmminer.c") == 0) {
            goto lab_0x2a314;
        } else {
            // 0x2a3b0
            function_28f5c("get_work_by_nonce2", 1427);
            v6 = 1427;
            goto lab_0x2a314;
        }
    }
  lab_0x2a314:
    // 0x2a314
    function_2f250();
    function_2974c(a3, v6, 4, g293, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488);
    int32_t v9 = v4; // 0x2a340
    *(int32_t *)(v6 + 260) = a4;
    *(int32_t *)(v9 + 256) = v1;
    *(int32_t *)(v9 + 336) = 0;
    int32_t * v10 = (int32_t *)(*(int32_t *)(v9 + 260) + 68); // 0x2a360
    *v10 = *v10 + 1;
    *(char *)(v9 + 272) = 1;
    *(int32_t *)(v9 + 444) = v9;
    return 1;
}

// Address range: 0x2a3c4 - 0x2a56c
int32_t function_2a3c4(int32_t a1) {
    int32_t v1 = 0; // 0x2a3e0
    if (g61 == 0) {
        goto lab_0x2a444;
    } else {
        // 0x2a3e4
        if ((*(char *)&g60 | *(char *)&g221) == 0) {
            // 0x2a4c4
            v1 = g290;
            if (g290 < 7) {
                goto lab_0x2a444;
            } else {
                goto lab_0x2a40c;
            }
        } else {
            goto lab_0x2a40c;
        }
    }
  lab_0x2a444:;
    // 0x2a444
    int32_t v2; // 0x2a3c4
    int32_t v3; // 0x2a3c4
    int32_t str; // bp-2056, 0x2a3c4
    if (function_11f94(&g228, v2, v3, v1) != 0) {
        int32_t v4 = *__errno_location(); // 0x2a4f4
        snprintf((char *)&str, 2048, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", v4, "bmminer.c", "inc_hw_errors", 1446);
        function_2e584(3, &str, 1);
    }
    int32_t * v5 = (int32_t *)(a1 + 36); // 0x2a458
    int32_t * v6 = (int32_t *)(*v5 + 44); // 0x2a470
    int32_t v7 = g211 + 1; // 0x2a474
    int32_t v8 = *v6 + 1; // 0x2a478
    g211 = v7;
    *v6 = v8;
    if (function_11ea4(&g228, v7, v8, (int32_t)&g211) != 0) {
        int32_t v9 = *__errno_location(); // 0x2a53c
        snprintf((char *)&str, 2048, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", v9, "bmminer.c", "inc_hw_errors", 1449);
        function_2e584(3, &str, 1);
    }
    // 0x2a490
    return *(int32_t *)(*(int32_t *)(*v5 + 4) + 84) == 0 ? function_2f250() : a1;
  lab_0x2a40c:;
    int32_t v10 = *(int32_t *)(a1 + 36); // 0x2a40c
    int32_t v11 = *(int32_t *)(v10 + 8); // 0x2a424
    int32_t v12 = *(int32_t *)(*(int32_t *)(v10 + 4) + 8); // 0x2a428
    snprintf((char *)&str, 2048, "%s %d: invalid nonce - HW error", (char *)v12, v11);
    function_2e584(7, &str, 0);
    v2 = &str;
    v3 = 0;
    v1 = v12;
    goto lab_0x2a444;
}

// Address range: 0x2a570 - 0x2a574
int32_t function_2a570(void) {
    // 0x2a570
    int32_t result; // 0x2a570
    return result;
}

// Address range: 0x2a574 - 0x2a578
int32_t function_2a574(void) {
    // 0x2a574
    int32_t result; // 0x2a574
    return result;
}

// Address range: 0x2a578 - 0x2a688
int32_t function_2a578(void) {
    // 0x2a578
    int32_t str; // bp-2312, 0x2a578
    int32_t v1; // bp-2376, 0x2a578
    if (sysinfo((struct sysinfo *)&v1) != 0) {
        int32_t err_num = *__errno_location(); // 0x2a620
        sprintf((char *)&str, "Failed to get sysinfo, errno:%u, reason:%s\n", err_num, strerror(err_num));
        int32_t result = function_11fe8(0); // 0x2a648
        g210 = result;
        g219 = result + 1;
        return result;
    }
    int32_t v2 = v1 + 1; // 0x2a5a8
    g210 = v1;
    g219 = v2;
    int32_t chars_printed = sprintf((char *)&str, "set_start_time_point total_tv_start_sys=%ld total_tv_end_sys=%ld\n", v1, v2); // 0x2a5c0
    int32_t result2 = chars_printed; // 0x2a5d4
    if ((*(char *)&g60 | *(char *)&g221) != 0 || g290 > 4) {
        // 0x2a5ec
        int32_t str2; // bp-2056, 0x2a578
        snprintf((char *)&str2, 2048, "%s", &str);
        result2 = function_2e584(5, &str2, 0);
    }
    // 0x2a614
    return result2;
}

// Address range: 0x2a688 - 0x2ab38
int32_t function_2a688(void) {
    // 0x2a688
    int32_t data; // bp-2328, 0x2a688
    int32_t v1 = &data; // 0x2a6a8
    struct _IO_FILE * stream = fopen64(g369, "rb"); // 0x2a6ac
    memset(&data, 0, 256);
    int32_t v2; // 0x2a688
    int32_t str; // bp-2072, 0x2a688
    if (stream == NULL) {
        // 0x2a80c
        v2 = &g221;
        if ((*(char *)&g60 | *(char *)&g221) == 0 != g290 < 3) {
            // 0x2a834
            snprintf((char *)&str, 2048, "Open miner version file %s error", g369);
            function_2e584(3, &str, 0);
            v2 = &g221;
        }
    } else {
        int32_t items_read = fread(&data, 1, 256, stream); // 0x2a6dc
        if (items_read < 1) {
            // 0x2a9fc
            v2 = &g221;
            if ((*(char *)&g60 | *(char *)&g221) == 0 != g290 < 3) {
                // 0x2aa38
                snprintf((char *)&str, 2048, "Read miner version file %s error %d", g369, items_read);
                function_2e584(3, &str, 0);
                v2 = &g221;
            }
        } else {
            char * found_char_pos = strchr((char *)&data, 10); // 0x2a6f0
            if (found_char_pos == NULL) {
                // 0x2ab28
                strcpy((char *)&g386, (char *)&data);
            } else {
                int32_t v3 = (int32_t)found_char_pos; // 0x2a6f0
                function_30ea8((int32_t)&g386, &data, v3 - v1, "bmminer.c", (int32_t)"read_version_file", 1515);
                int32_t v4 = function_1203c(v1, v3 + 1); // 0x2a72c
                char * found_char_pos2 = strchr((char *)&data, 10); // 0x2a73c
                if (found_char_pos2 == NULL) {
                    // 0x2aa98
                    function_11fc4((int32_t *)&g387, v1, (char)(v4 - v1) + 1, (int32_t)"bmminer.c");
                } else {
                    // 0x2a748
                    function_30ea8((int32_t)&g387, &data, (int32_t)found_char_pos2 - v1, "bmminer.c", (int32_t)"read_version_file", 1524);
                }
            }
            int32_t len = strlen((char *)&g386); // 0x2a770
            char * v5 = (char *)(len + (int32_t)&g365 + 1079); // 0x2a77c
            char v6 = *v5; // 0x2a77c
            int32_t len2 = len; // 0x2a784
            char v7 = v6; // 0x2a784
            if (v6 == 10) {
                // 0x2a788
                *v5 = 0;
                len2 = strlen((char *)&g386);
                v7 = *(char *)(len2 + (int32_t)&g365 + 1079);
            }
            // 0x2a7a4
            if (v7 == 13) {
                *(char *)(len2 + (int32_t)&g365 + 1079) = 0;
            }
            int32_t len3 = strlen((char *)&g387); // 0x2a7b8
            char * v8 = (char *)(len3 + (int32_t)&g365 + 1335); // 0x2a7c4
            char v9 = *v8; // 0x2a7c4
            int32_t len4 = len3; // 0x2a7cc
            char v10 = v9; // 0x2a7cc
            if (v9 == 10) {
                // 0x2a7d0
                *v8 = 0;
                len4 = strlen((char *)&g387);
                v10 = *(char *)(len4 + (int32_t)&g365 + 1335);
            }
            // 0x2a7ec
            v2 = &g221;
            if (v10 == 13) {
                *(char *)(len4 + (int32_t)&g365 + 1335) = 0;
                v2 = (int32_t)&g218 | 1028;
            }
        }
    }
    struct _IO_FILE * stream2 = fopen64("/config/sn", "rb"); // 0x2a86c
    char v11; // 0x2a688
    char * v12; // 0x2a9a8
    if (stream2 == NULL) {
        // 0x2a9a8
        v12 = (char *)v2;
        if (*v12 == 0) {
            // 0x2a9b4
            v11 = 0;
            if (*(char *)&g60 == 0 == g290 < 3) {
                goto lab_0x2a8ec;
            } else {
                goto lab_0x2a9c8;
            }
        } else {
            goto lab_0x2a9c8;
        }
    } else {
        // 0x2a878
        memset(&data, 0, 256);
        int32_t items_read2 = fread(&data, 1, 250, stream2); // 0x2a898
        if (items_read2 < 1) {
            // 0x2aab0
            if ((*(char *)&g60 | *(char *)v2) == 0 != g290 < 3) {
                // 0x2aae4
                snprintf((char *)&str, 2048, "Read miner sn file %s error %d", "/config/sn", items_read2);
                function_2e584(3, &str, 0);
            }
        } else {
            int32_t v13 = function_11ebc(&data, (int32_t)"\r\n", 250); // 0x2a8b0
            if (v13 == 0) {
                // 0x2ab18
                strcpy((char *)&g388, (char *)&data);
            } else {
                // 0x2a8bc
                function_30ea8((int32_t)&g388, &data, v13 - v1, "bmminer.c", (int32_t)"read_version_file", 1572);
            }
        }
        // 0x2a8e0
        fclose(stream2);
        v11 = *(char *)v2;
        goto lab_0x2a8ec;
    }
  lab_0x2a9c8:
    // 0x2a9c8
    snprintf((char *)&str, 2048, "Open miner sn file %s error", "/config/sn");
    function_2e584(3, &str, 0);
    v11 = *v12;
    goto lab_0x2a8ec;
  lab_0x2a8ec:;
    int32_t len5 = strlen((char *)&g388); // 0x2a8f4
    char * v14 = (char *)(len5 + (int32_t)&g365 + 1591); // 0x2a900
    char v15 = *v14; // 0x2a900
    int32_t v16 = len5; // 0x2a908
    char v17 = v15; // 0x2a908
    if (v15 == 10) {
        // 0x2a90c
        *v14 = 0;
        int32_t len6 = strlen((char *)&g388); // 0x2a918
        v16 = len6;
        v17 = *(char *)(len6 + (int32_t)&g365 + 1591);
    }
    // 0x2a928
    if (v17 == 13) {
        *(char *)(v16 + (int32_t)&g365 + 1591) = 0;
    }
    int32_t result = v16 - 1; // 0x2a93c
    if ((*(char *)&g60 || v11) == 0 != g290 < 3) {
        // 0x2a968
        snprintf((char *)&str, 2048, "Miner compile time: %s type: %s sn :%s", (char *)((int32_t)&g387 - 256), (char *)&g387, (char *)&g388);
        result = function_2e584(3, &str, 0);
    }
    // 0x2a99c
    return result;
}

// Address range: 0x2ab48 - 0x2acec
int32_t function_2ab48(int32_t * a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = *(int32_t *)(a2 + 288); // 0x2ab50
    char * str = (char *)v1; // 0x2ab6c
    int32_t len = strlen(str); // 0x2ab6c
    int32_t v2 = *(int32_t *)(a2 + 308); // 0x2ab70
    char * str2 = (char *)v2; // 0x2ab7c
    int32_t len2 = strlen(str2); // 0x2ab7c
    int32_t v3 = *(int32_t *)(a2 + 320); // 0x2ab80
    char * str3 = (char *)v3; // 0x2ab98
    int32_t v4 = len + 459 + len2 + strlen(str3); // 0x2ab9c
    int32_t result = function_11eb0(1, v4, a3, a4); // 0x2aba8
    if (result == 0) {
        // 0x2acc4
        return result;
    }
    // 0x2abb4
    *(int32_t *)(result + 1) = a3;
    *(char *)result = (char)a4;
    function_11fc4((int32_t *)(result + 5), a2, -64, a4);
    uint32_t v5 = strlen(str) + 1; // 0x2abd8
    uint32_t v6 = v5 % 256; // 0x2abe0
    int32_t v7 = result + 454;
    char v8 = v5; // 0x2abf0
    *(char *)(result + 453) = v8;
    function_11fc4((int32_t *)v7, v1, v8, a4);
    uint32_t v9 = strlen(str2) + 1; // 0x2ac04
    int32_t v10 = v6 + 455; // 0x2ac08
    char v11 = v9; // 0x2ac1c
    *(char *)(v6 + v7) = v11;
    int32_t v12 = v9 % 256 + v10; // 0x2ac24
    function_11fc4((int32_t *)(v10 + result), v2, v11, a4);
    int32_t v13 = v12 + 1; // 0x2ac30
    uint32_t v14 = strlen(str3) + 1; // 0x2ac38
    char v15 = v14; // 0x2ac48
    *(char *)(v12 + result) = v15;
    function_11fc4((int32_t *)(v13 + result), v3, v15, a4);
    if (g61 == 0) {
        // 0x2acc0
        *a1 = v4;
        // 0x2acc4
        return result;
    }
    // 0x2ac68
    if ((*(char *)&g60 | *(char *)&g221) == 0 != g290 < 7) {
        // 0x2ac90
        int32_t str4; // bp-2088, 0x2ab48
        snprintf((char *)&str4, 2048, "need data size:%d, actual size:%d\n", v4, v14 % 256 + v13);
        function_2e584(7, &str4, 0);
    }
    // 0x2acc0
    *a1 = v4;
    // 0x2acc4
    return result;
}

// Address range: 0x2acec - 0x2ada0
int32_t function_2acec(void) {
    // 0x2acec
    int32_t v1; // bp-2060, 0x2acec
    int32_t v2; // 0x2acec
    int32_t v3 = function_2ab48(&v1, v2, v2, v2); // 0x2acfc
    int32_t v4; // 0x2acec
    if (function_281d4(v3, v1) == 0) {
        // 0x2ad70
        int32_t v5; // 0x2acec
        free(v3, v1, v4, v5);
        return 1;
    }
    // 0x2ad14
    if ((*(char *)&g60 | *(char *)&g221) == 0) {
        // 0x2ad88
        if (g290 <= 2) {
            // 0x2ad70
            free(v3, v1, v4, g290);
            return 1;
        }
    }
    char * v6 = (char *)0x696d6763; // bp-2056, 0x2ad4c
    function_2e584(3, (int32_t *)&v6, 0);
    // 0x2ad70
    free(v3, (int32_t)&v6, 0, 0x636e6f6e);
    return 1;
}

// Address range: 0x2ada0 - 0x2aef4
int32_t function_2ada0(int32_t str4) {
    // 0x2ada0
    int32_t str3; // bp-196, 0x2ada0
    memset(&str3, 0, 32);
    int32_t v1; // bp-164, 0x2ada0
    memset(&v1, 0, 32);
    int32_t str; // bp-132, 0x2ada0
    memset(&str, 0, 40);
    int32_t str2; // bp-92, 0x2ada0
    memset(&str2, 0, 59);
    int32_t timep; // bp-204, 0x2ada0
    function_302a0(&timep);
    int32_t v2 = 0; // 0x2ae10
    timep -= v2;
    struct tm * time_info = localtime(&timep); // 0x2ae28
    int32_t v3 = (int32_t)time_info; // 0x2ae28
    int32_t v4 = time_info->e0; // 0x2ae34
    int32_t v5 = *(int32_t *)(v3 + 20); // 0x2ae3c
    int32_t v6 = *(int32_t *)(v3 + 4); // 0x2ae48
    int32_t v7 = *(int32_t *)(v3 + 8); // 0x2ae58
    int32_t v8 = *(int32_t *)(v3 + 12); // 0x2ae60
    int32_t v9 = *(int32_t *)(v3 + 16); // 0x2ae68
    snprintf((char *)&str, 40, "[%d-%02d-%02d %02d:%02d:%02d]", v5 + 1900, v9 + 1, v8, v7, v6, v4);
    snprintf((char *)&str2, 59, "%s%s", "BITMAIN_OPENSOURCE", &str);
    function_2f1ec((int32_t)&str2, 59, &v1);
    function_2f1ec((int32_t)&v1, 32, &str3);
    while (strncmp((char *)&str3, (char *)str4, 32) != 0) {
        // 0x2aec8
        v2++;
        if (v2 == 4) {
            // 0x2aed0
            return 0;
        }
        timep -= v2;
        time_info = localtime(&timep);
        v3 = (int32_t)time_info;
        v4 = time_info->e0;
        v5 = *(int32_t *)(v3 + 20);
        v6 = *(int32_t *)(v3 + 4);
        v7 = *(int32_t *)(v3 + 8);
        v8 = *(int32_t *)(v3 + 12);
        v9 = *(int32_t *)(v3 + 16);
        snprintf((char *)&str, 40, "[%d-%02d-%02d %02d:%02d:%02d]", v5 + 1900, v9 + 1, v8, v7, v6, v4);
        snprintf((char *)&str2, 59, "%s%s", "BITMAIN_OPENSOURCE", &str);
        function_2f1ec((int32_t)&str2, 59, &v1);
        function_2f1ec((int32_t)&v1, 32, &str3);
    }
    // 0x2aedc
    puts("socket auth pass!!!!!!!!!!!!!!!!!!!!");
    return 1;
}

// Address range: 0x2aef4 - 0x2afbc
int32_t function_2aef4(void) {
    // 0x2aef4
    if (g214 == 0) {
        // 0x2afa0
        __assert_fail("cgpu", "bmminer.c", 2026, "bitmain_primary_init");
        return &g488;
    }
    // 0x2af14
    *(int32_t *)(g214 + 32) = 0;
    *(int32_t *)(g214 + 4) = (int32_t)&g389;
    int32_t * v1 = (int32_t *)(g214 + 20); // 0x2af38
    *v1 = g225;
    *(int32_t *)(g214 + 148) = 1;
    int32_t v2 = g225; // 0x2af40
    if (g225 == 0) {
        char * v3 = (char *)0x6c696146; // bp-2064, 0x2af7c
        function_2e584(3, (int32_t *)&v3, 1);
        v2 = *v1;
    }
    // 0x2af44
    *(int32_t *)(v2 + 0x1654) = 0;
    *(int32_t *)(v2 + 0x1658) = 1;
    *(int32_t *)(v2 + 0x165c) = 2;
    return 0;
}

// Address range: 0x2afc4 - 0x2b05c
int32_t function_2afc4(int32_t a1, int32_t a2) {
    int32_t v1; // 0x2b040
    if (a2 == 32) {
        // 0x2b03c
        v1 = function_2ada0(a1);
        *(char *)&g72 = (char)v1;
        return 0;
    }
    // 0x2afd8
    if ((*(char *)&g60 | *(char *)&g221) == 0 != g290 < 3) {
        // 0x2b014
        int32_t str; // bp-2056, 0x2afc4
        snprintf((char *)&str, 2048, "invald hash size %d\n", a2);
        function_2e584(3, &str, 0);
    }
    // 0x2b03c
    v1 = function_2ada0(a1);
    *(char *)&g72 = (char)v1;
    return 0;
}

// Address range: 0x2b05c - 0x2b2e8
int32_t function_2b05c(int32_t a1, int32_t a2, int32_t a3) {
    // 0x2b05c
    int32_t v1; // 0x2b05c
    int32_t v2 = v1;
    function_11fc4((int32_t *)a1, a2, 56, v2);
    int32_t v3 = *(int32_t *)(a1 + 1572); // 0x2b080
    int32_t v4 = v3 + 1848; // 0x2b08c
    int32_t v5 = function_11fc4((int32_t *)function_11eb0(1, v3, 1848, v2), a2 + 1848, (char)v3, v2); // 0x2b09c
    int32_t * v6 = (int32_t *)(a1 + 1708); // 0x2b0a4
    *(int32_t *)(a1 + 1568) = v5;
    int32_t v7 = function_2f408(4 * *v6 | 1, "bmminer.c", "parse_job_buf", 2190); // 0x2b0c4
    int32_t v8 = *v6; // 0x2b0c8
    int32_t * v9 = (int32_t *)(a1 + 676); // 0x2b0cc
    *v9 = v7;
    int32_t v10 = v8 < 1 ? v4 : v1; // 0x2b0d8
    char * str3; // bp-2088, 0x2b05c
    if (v8 > 0) {
        int32_t v11 = v4 + a2; // 0x2b0f8
        int32_t v12 = 0;
        int32_t v13 = function_2f408(32, "bmminer.c", "parse_job_buf", 2193); // 0x2b110
        int32_t v14 = 4 * v12; // 0x2b114
        *(int32_t *)(v7 + v14) = v13;
        int32_t v15 = *(int32_t *)(*v9 + v14); // 0x2b120
        int32_t v16 = v15; // 0x2b128
        if (v15 == 0) {
            // 0x2b290
            str3 = (char *)0x6c696146;
            function_2e584(3, (int32_t *)&str3, 1);
            v16 = *(int32_t *)(*v9 + v14);
        }
        int32_t v17 = v12 + 1; // 0x2b130
        *(int32_t *)v16 = *(int32_t *)v11;
        *(int32_t *)(v16 + 4) = *(int32_t *)(v11 + 4);
        *(int32_t *)(v16 + 8) = *(int32_t *)(v11 + 8);
        *(int32_t *)(v16 + 12) = *(int32_t *)(v11 + 12);
        *(int32_t *)(v16 + 16) = *(int32_t *)(v11 + 16);
        *(int32_t *)(v16 + 20) = *(int32_t *)(v11 + 20);
        *(int32_t *)(v16 + 24) = *(int32_t *)(v11 + 24);
        *(int32_t *)(v16 + 28) = *(int32_t *)(v11 + 28);
        while (*v6 > v17) {
            // 0x2b0fc
            v11 += 32;
            v12 = v17;
            v13 = function_2f408(32, "bmminer.c", "parse_job_buf", 2193);
            v14 = 4 * v12;
            *(int32_t *)(*v9 + v14) = v13;
            v15 = *(int32_t *)(*v9 + v14);
            v16 = v15;
            if (v15 == 0) {
                // 0x2b290
                str3 = (char *)0x6c696146;
                function_2e584(3, (int32_t *)&str3, 1);
                v16 = *(int32_t *)(*v9 + v14);
            }
            // 0x2b12c
            v17 = v12 + 1;
            *(int32_t *)v16 = *(int32_t *)v11;
            *(int32_t *)(v16 + 4) = *(int32_t *)(v11 + 4);
            *(int32_t *)(v16 + 8) = *(int32_t *)(v11 + 8);
            *(int32_t *)(v16 + 12) = *(int32_t *)(v11 + 12);
            *(int32_t *)(v16 + 16) = *(int32_t *)(v11 + 16);
            *(int32_t *)(v16 + 20) = *(int32_t *)(v11 + 20);
            *(int32_t *)(v16 + 24) = *(int32_t *)(v11 + 24);
            *(int32_t *)(v16 + 28) = *(int32_t *)(v11 + 28);
        }
        // 0x2b180
        v10 = v3 + 1880 + 32 * v12;
    }
    char * str = __strdup((char *)(v10 + a2)); // 0x2b184
    int32_t len = strlen(str); // 0x2b18c
    *(int32_t *)(a1 + 672) = (int32_t)str;
    int32_t v18 = v10 + 1 + len; // 0x2b198
    char * str2 = __strdup((char *)(v18 + a2)); // 0x2b1a0
    int32_t v19 = strlen(str2) + v18; // 0x2b1ac
    *(int32_t *)(a1 + 612) = (int32_t)str2;
    int32_t v20 = v19 + a2;
    int32_t v21 = v19 + 17; // 0x2b1dc
    g390 = *(int32_t *)(v20 + 1);
    g391 = *(int32_t *)(v20 + 5);
    int32_t v22 = *(int32_t *)(v20 + 9); // 0x2b1ec
    g277 = v22;
    g278 = *(int32_t *)(v20 + 13);
    int32_t v23 = v22; // 0x2b1f8
    if (g61 != 0) {
        // 0x2b1fc
        v23 = v22;
        if ((*(char *)&g60 | *(char *)&g221) == 0 != g290 < 7) {
            // 0x2b224
            snprintf((char *)&str3, 2048, "parse job buf len:%d\n", v21);
            v23 = function_2e584(7, (int32_t *)&str3, 0);
        }
    }
    int32_t result = v23; // 0x2b254
    if (v21 != a3) {
        // 0x2b258
        str3 = (char *)0x3a525245;
        result = function_2e584(3, (int32_t *)&str3, 1);
    }
    // 0x2b284
    return result;
}

// Address range: 0x2b2f4 - 0x2b330
int32_t function_2b2f4(void) {
    // 0x2b2f4
    int32_t v1; // 0x2b2f4
    function_11f94(&g392, v1, v1, v1);
    int32_t result = function_316d8(g394, g393); // 0x2b318
    function_11ea4(&g392, g393, v1, v1);
    return result;
}

// Address range: 0x2b330 - 0x2b7f8
int32_t function_2b330(int32_t a1, int32_t a2) {
    int32_t v1 = 0; // bp-2092, 0x2b364
    int32_t v2 = a2; // 0x2b368
    int32_t v3 = &g225; // 0x2b368
    if (g61 == 0) {
        goto lab_0x2b3c8;
    } else {
        // 0x2b36c
        if ((*(char *)&g60 | *(char *)&g221) == 0) {
            // 0x2b618
            v2 = a2;
            v3 = g290;
            if (g290 < 7) {
                goto lab_0x2b3c8;
            } else {
                goto lab_0x2b394;
            }
        } else {
            goto lab_0x2b394;
        }
    }
  lab_0x2b3c8:;
    int32_t v4 = function_31d38(); // 0x2b3c8
    char * str; // bp-2088, 0x2b330
    if (v4 == 1 || v4 == 0) {
        // 0x2b5bc
        function_11f94(&g392, v2, 0, v3);
        int32_t v5 = g394; // 0x2b5cc
        int32_t v6; // 0x2b330
        int32_t v7; // 0x2b330
        if (v5 == 0) {
            goto lab_0x2b5e4;
        } else {
            // 0x2b5d8
            v6 = v5;
            v7 = g393;
            if (g393 < a2) {
                goto lab_0x2b5e4;
            } else {
                goto lab_0x2b5f0;
            }
        }
      lab_0x2b5e4:;
        int32_t v8 = function_1209c(v5, a2, 0, v3); // 0x2b5e8
        g394 = v8;
        v6 = v8;
        v7 = v3;
        goto lab_0x2b5f0;
      lab_0x2b394:
        // 0x2b394
        snprintf((char *)&str, 2048, "%s, rec job data %p size: %d\n", "bitmain_update_job_cb", (int32_t *)a1, a2);
        function_2e584(7, (int32_t *)&str, 0);
        v2 = (int32_t)&str;
        v3 = (int32_t)"bitmain_update_job_cb";
        goto lab_0x2b3c8;
      lab_0x2b5f0:
        // 0x2b5f0
        function_11fc4((int32_t *)v6, a1, (char)a2, v7);
        g393 = a2;
        function_11ea4(&g392, a1, a2, v7);
        return 0;
    }
    int32_t * v9 = (int32_t *)(g225 + 112); // 0x2b3dc
    int32_t v10 = function_11f94(v9, v2, 0, v3); // 0x2b3dc
    int32_t v11 = 0; // 0x2b3e4
    int32_t v12 = v3; // 0x2b3e4
    if (v10 != 0) {
        // 0x2b760
        v12 = *__errno_location();
        snprintf((char *)&str, 2048, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", v12, "bmminer.c", "bitmain_update_job_cb", 2250);
        function_2e584(3, (int32_t *)&str, 1);
        v11 = 1;
    }
    int32_t v13 = function_11eb0(1, 1848, v11, v12); // 0x2b3f4
    function_2b05c(v13, a1, a2);
    unsigned char v14 = *(char *)(v13 + 640); // 0x2b408
    int32_t v15 = a1; // 0x2b410
    int32_t v16 = a2; // 0x2b410
    int32_t v17 = v14; // 0x2b410
    if (v14 == 0) {
        // 0x2b584
        str = (char *)0x6d746942;
        function_2e584(3, (int32_t *)&str, 1);
        v15 = (int32_t)&str;
        v16 = 1;
        v17 = 0x6f70206d;
    }
    int32_t * v18 = (int32_t *)g225; // 0x2b418
    if (function_11f94(v18, v15, v16, v17) != 0) {
        int32_t v19 = *__errno_location(); // 0x2b7b8
        snprintf((char *)&str, 2048, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", v19, "bmminer.c", "bitmain_update_job_cb", 2261);
        function_2e584(3, (int32_t *)&str, 1);
    }
    int32_t rwlock = g225 + 24; // 0x2b424
    if (function_12048(rwlock) != 0) {
        int32_t v20 = *__errno_location(); // 0x2b63c
        snprintf((char *)&str, 2048, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", v20, "bmminer.c", "bitmain_update_job_cb", 2261);
        function_2e584(3, (int32_t *)&str, 1);
    }
    int32_t v21 = g225 + 2020; // 0x2b440
    *(int32_t *)(g225 + 168) = *(int32_t *)v13;
    function_33478(g225 + 3868, v21);
    int32_t * v22 = (int32_t *)(g225 + 0x1658); // 0x2b45c
    int32_t v23 = g225 + 172; // 0x2b460
    *(int32_t *)(g225 + 0x165c) = *v22;
    function_33478(v21, v23);
    int32_t * v24 = (int32_t *)(g225 + 0x1654); // 0x2b474
    *v22 = *v24;
    function_33478(v23, v13);
    int32_t v25 = (int32_t)g279 + 1; // 0x2b498
    *v24 = v25;
    g279 = (char *)v25;
    int32_t v26 = pthread_rwlock_unlock((int32_t *)rwlock); // 0x2b4a4
    int32_t v27 = v13; // 0x2b4ac
    int32_t v28 = v25; // 0x2b4ac
    int32_t v29 = (int32_t)&g274; // 0x2b4ac
    if (v26 != 0) {
        // 0x2b67c
        v29 = *__errno_location();
        snprintf((char *)&str, 2048, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", v29, "bmminer.c", "bitmain_update_job_cb", 2273);
        function_2e584(3, (int32_t *)&str, 1);
        v27 = (int32_t)&str;
        v28 = 1;
    }
    // 0x2b4b0
    if (function_11ea4(v18, v27, v28, v29) != 0) {
        int32_t v30 = *__errno_location(); // 0x2b6d4
        snprintf((char *)&str, 2048, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", v30, "bmminer.c", "bitmain_update_job_cb", 2273);
        function_2e584(3, (int32_t *)&str, 1);
    }
    // 0x2b4c0
    function_2f250();
    int32_t v31 = *v24; // 0x2b4d0
    function_32cc0(&v1, v13, v31);
    function_11f94(&g87, v13, v31, g293);
    function_32f40(v1);
    function_11ea4(&g87, v13, v31, g293);
    free(v1, v13, v31, g293);
    int32_t v32 = function_11ea4(v9, v13, v31, g293); // 0x2b50c
    int32_t v33 = v13; // 0x2b514
    int32_t v34 = v31; // 0x2b514
    if (v32 != 0) {
        int32_t v35 = *__errno_location(); // 0x2b720
        snprintf((char *)&str, 2048, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", v35, "bmminer.c", "bitmain_update_job_cb", 2283);
        function_2e584(3, (int32_t *)&str, 1);
        v33 = (int32_t)&str;
        v34 = 1;
    }
    // 0x2b518
    function_2f250();
    uint32_t v36 = *(int32_t *)(v13 + 1708); // 0x2b520
    if (v36 >= 1) {
        int32_t * v37; // 0x2b330
        int32_t v38 = *v37; // 0x2b530
        int32_t v39; // 0x2b330
        int32_t v40 = v39 + 1; // 0x2b538
        int32_t v41; // 0x2b330
        int32_t v42; // 0x2b330
        free(*(int32_t *)(v38 + 4 * v39), v41, v42, v38);
        int32_t * v43; // 0x2b520
        while (*v43 > v40) {
            int32_t v44 = v40;
            v38 = *v37;
            v40 = v44 + 1;
            free(*(int32_t *)(v38 + 4 * v44), v41, v42, v38);
        }
    }
    // 0x2b54c
    free(*(int32_t *)(v13 + 676), v33, v34, v36);
    free(*(int32_t *)(v13 + 1568), v33, v34, v36);
    free(*(int32_t *)(v13 + 672), v33, v34, v36);
    free(*(int32_t *)(v13 + 612), v33, v34, v36);
    free(v13, v33, v34, v36);
    return 0;
}

// Address range: 0x2b800 - 0x2b944
int32_t function_2b800(int32_t a1) {
    // 0x2b800
    g478 = a1;
    int32_t result = 8; // 0x2b814
    switch (a1) {
        case 0: {
        }
        case 1: {
        }
        case 2: {
            // 0x2b8b8
            return strlen((char *)*(int32_t *)(a1 + 8)) + 1;
        }
        case 3: {
        }
        case 4: {
        }
        case 5: {
        }
        case 6: {
        }
        case 7: {
        }
        case 8: {
        }
        case 9: {
        }
        case 16: {
        }
        case 19: {
        }
        case 22: {
        }
        case 26: {
            // 0x2b88c
            return 4;
        }
        case 14: {
            // 0x2b88c
            return 1;
        }
        default: {
            // 0x2b8d0
            int32_t str; // bp-2056, 0x2b800
            if (*(char *)&g221 != 0) {
                // 0x2b8f8
                snprintf((char *)&str, 2048, "Should not happen for unknown data type %d", a1);
                function_2e584(3, &str, 0);
                return 0;
            }
            // 0x2b8e4
            result = 0;
            if (*(char *)&g60 != 0 || g290 > 2) {
                // 0x2b8f8
                snprintf((char *)&str, 2048, "Should not happen for unknown data type %d", a1);
                function_2e584(3, &str, 0);
                return 0;
            }
        }
        case 10: {
        }
        case 11: {
        }
        case 12: {
        }
        case 13: {
        }
        case 15: {
        }
        case 17: {
        }
        case 18: {
        }
        case 20: {
        }
        case 21: {
        }
        case 23: {
        }
        case 24: {
        }
        case 25: {
            // 0x2b88c
            return result;
        }
    }
}

// Address range: 0x2b944 - 0x2bb38
int32_t function_2b944(int32_t a1, int32_t a2) {
    // 0x2b944
    char * str; // bp-2072, 0x2b944
    char * str2; // 0x2b978
    switch (a2) {
        case 1: {
            // 0x2ba70
            int32_t v1; // 0x2b944
            function_11f94(&g373, 1, v1, v1);
            pthread_cond_signal(&g377);
            function_11ea4(&g373, 1, v1, v1);
            return 0;
        }
        case 4: {
            char * v2 = g289; // 0x2ba4c
            g280 = a1;
            if (v2 >= (char *)3 != v2 != (char *)3) {
                // 0x2ba60
                return 0;
            }
            // 0x2bad4
            snprintf((char *)&str, 2048, "freq_level = %d\n", a1);
            function_2e584(3, (int32_t *)&str, 0);
            return 0;
        }
        case 2: {
            // 0x2b970
            str2 = (char *)a1;
            if (strncmp(str2, "go", 2) == 0) {
                char * v3 = g289; // 0x2b98c
                if (v3 >= (char *)3 == (v3 != (char *)3)) {
                    // 0x2bb08
                    str = (char *)0x72617473;
                    function_2e584(3, (int32_t *)&str, 0);
                }
                // 0x2b998
                function_11f04(&g395);
            }
            // break -> 0x2b9a0
            break;
        }
        default: {
            // 0x2ba60
            return 0;
        }
    }
    // 0x2b9a0
    if (strncmp(str2, "re", 2) != 0) {
        // 0x2ba60
        return 0;
    }
    char * v4 = g289; // 0x2b9c4
    if (v4 >= (char *)3 == (v4 != (char *)3)) {
        // 0x2ba98
        str = (char *)0x6f6c6572;
        function_2e584(3, (int32_t *)&str, 0);
    }
    // 0x2b9d0
    function_265f4();
    g396 = 0;
    g397 = 0;
    g427 = 0;
    g428 = 0;
    g429 = 0;
    g430 = 0;
    g431 = 0;
    g432 = 0;
    g433 = 0;
    g434 = 0;
    g451 = 0;
    g452 = 0;
    function_32ca8();
    g398 = 1;
    g399 = 1;
    g400 = 1;
    return 0;
}

// Address range: 0x2bb44 - 0x2bc28
int32_t function_2bb44(int32_t a1, int32_t a2) {
    // 0x2bb44
    if ((*(char *)&g60 | *(char *)&g221) != 0 || g290 > 4) {
        // 0x2bb78
        int32_t str; // bp-2056, 0x2bb44
        snprintf((char *)&str, 2048, "%s %d\n", "bitmain_shutdown_cb", a2);
        function_2e584(5, &str, 0);
    }
    // 0x2bba4
    function_31cac();
    function_2fe84(g362);
    function_2fe84(g361);
    function_2fe84(g360);
    function_2fe84(g220);
    function_44a88();
    *(char *)(g214 + 364) = 1;
    return 0;
}

// Address range: 0x2bc2c - 0x2bdc0
int32_t function_2bc2c(int32_t a1, int32_t a2) {
    int32_t v1 = a1; // bp-2060, 0x2bc34
    function_3dc80(&g274, "Options for both config file and command line");
    function_3dc80((char (**)[15])&g281, "Options for command line only");
    function_3dd54(&v1, a2, 0x282e4);
    char * str; // bp-2056, 0x2bc2c
    if (v1 != 1) {
        // 0x2bc80
        str = (char *)0x78656e55;
        function_2e584(3, (int32_t *)&str, 1);
    }
    int32_t result = function_29458(); // 0x2bcd4
    if (g369 != NULL) {
        // 0x2bcd8
        result = function_2a688();
    }
    // 0x2bcdc
    if (g367 == NULL) {
        // 0x2bd7c
        return result;
    }
    // 0x2bce8
    *(char *)&g53 = 1;
    char * dest_str = strcpy((char *)&g57, g367); // 0x2bd00
    char * dest_str2; // 0x2bc2c
    if (g368 == NULL) {
        // 0x2bd9c
        *(int16_t *)&g55 = 0x2b61;
        *(char *)&g56 = 0;
        dest_str2 = dest_str;
    } else {
        // 0x2bd10
        dest_str2 = strcpy((char *)&g55, g368);
    }
    char v2 = *(char *)&g221; // 0x2bd24
    int32_t result2 = (int32_t)dest_str2; // 0x2bd2c
    if ((*(char *)&g60 || v2) != 0 || g290 > 2) {
        // 0x2bd44
        snprintf((char *)&str, 2048, "Log file path: %s Open flag: %s", (char *)&g57, (char *)&g55);
        result2 = function_2e584(3, (int32_t *)&str, 0);
    }
    // 0x2bd7c
    return result2;
}

// Address range: 0x2bdc4 - 0x2bdcc
int32_t function_2bdc4(int32_t a1) {
    // 0x2bdc4
    return function_11ed4(&g395);
}

// Address range: 0x2bdd0 - 0x2be08
int32_t function_2bdd0(void) {
    // 0x2bdd0
    int32_t v1; // 0x2bdd0
    function_11f94(&g416, v1, v1, v1);
    g232 = 0;
    g233 = 0;
    g234 = 0;
    return function_11ea4(&g416, v1, 0, (int32_t)&g232);
}

// Address range: 0x2be08 - 0x2be40
int32_t function_2be08(void) {
    // 0x2be08
    int32_t v1; // 0x2be08
    function_11f94(&g88, v1, v1, v1);
    g237 = 0;
    g238 = 0;
    g239 = 0;
    return function_11ea4(&g88, v1, 0, (int32_t)&g237);
}

// Address range: 0x2be40 - 0x2c06c
int32_t function_2be40(uint32_t a1, uint32_t a2) {
    // 0x2be40
    if (function_1e29c(a1) == 0) {
        char * v1 = g289; // 0x2be68
        if (v1 >= (char *)3 == (v1 != (char *)3)) {
            // 0x2bffc
            int32_t str; // bp-2088, 0x2be40
            snprintf((char *)&str, 2048, "Chain %d is not exist.\n", a1);
            function_2e584(3, &str, 0);
        }
        // 0x2be78
        return 0;
    }
    if (a2 == 0) {
        // 0x2bfec
        function_1e610(a1, 0);
    }
    // 0x2be90
    function_2bdd0();
    int32_t v2 = a2 % 256; // 0x2bea0
    function_1ec84(a1 % 256, 1, 0, v2);
    int32_t v3 = 1; // 0x2bec0
    int32_t v4 = v2; // 0x2bec0
    int32_t v5 = 0; // 0x2bec0
    int32_t v6 = 0; // 0x2bec0
    int32_t v7; // 0x2be40
    int32_t v8; // 0x2be40
    int32_t v9; // 0x2be40
    int32_t v10; // 0x2be40
    while (true) {
      lab_0x2bec4_2:;
        int32_t v11 = v4;
        function_304d4(300);
        function_11f94(&g416, v3, 0, v11);
        v3 = g234;
        v5 += v3;
        v7 = v3;
        v10 = 0;
        if (v3 >= 1) {
            goto lab_0x2bf00;
        }
        int32_t v12 = function_1e0f0(); // 0x2bfac
        v8 = v3;
        v9 = v11;
        if (v5 > 5 * v12 * function_1e28c()) {
            // break (via goto) -> 0x2bf7c
            goto lab_0x2bf7c;
        }
        // 0x2bfcc
        while (v3 == 0) {
            int32_t v13 = v6 + 1; // 0x2c030
            function_304d4(100);
            function_11ea4(&g416, 0, 0, v11);
            if (v13 == 4) {
                // 0x2be78
                return 1;
            }
            function_304d4(300);
            function_11f94(&g416, 0, 0, v11);
            v3 = g234;
            v5 += v3;
            v7 = v3;
            v10 = 0;
            if (v3 >= 1) {
                goto lab_0x2bf00;
            }
            // 0x2bfa8
            v12 = function_1e0f0();
            v8 = v3;
            v9 = v11;
            if (v5 > 5 * v12 * function_1e28c()) {
                // break (via goto) -> 0x2bf7c
                goto lab_0x2bf7c;
            }
            // 0x2bfcc
            v6 = v13;
        }
        if (a2 == 0) {
            int32_t v14 = function_1e0f0(); // 0x2c050
            v8 = v3;
            v9 = 0;
            if (v14 == function_1e67c(a1)) {
                // break -> 0x2bf7c
                break;
            }
        }
        // 0x2bfe0
        function_11ea4(&g416, v3, 0, a2);
        // 0x2bec4
        v4 = a2;
        goto lab_0x2bec4_2;
    }
  lab_0x2bf7c:
    // 0x2bf7c
    function_11ea4(&g416, v8, 0, v9);
    return 1;
  lab_0x2bf00:
    // 0x2bf00
    g234 = v7 - 1;
    int32_t v15 = v10 + 1; // 0x2bf0c
    uint32_t v16 = g233 + 1; // 0x2bf10
    int32_t v17 = 8 * v16; // 0x2bf14
    unsigned char v18 = *(char *)(v17 + (int32_t)&g232 + 10); // 0x2bf20
    unsigned char v19 = *(char *)(v17 + (int32_t)&g232 + 11); // 0x2bf24
    g233 = v16 >= 510 == (v16 != 510) ? 0 : v16;
    uint32_t v20 = *(int32_t *)(v17 + (int32_t)&g232 + 4); // 0x2bf2c
    if (v18 == 0 == (int32_t)v19 == a1) {
        // 0x2bf3c
        if (function_1e110() == v20 / 0x10000) {
            // 0x2bf50
            function_1e5a0(a1);
            if (v3 == v15) {
                goto lab_0x2bf60;
            } else {
                goto lab_0x2befc;
            }
        } else {
            goto lab_0x2bef4;
        }
    } else {
        goto lab_0x2bef4;
    }
  lab_0x2bef4:
    if (v3 == v15) {
        goto lab_0x2bf60;
    } else {
        goto lab_0x2befc;
    }
  lab_0x2bf60:
    // 0x2bf60
    function_1e0f0();
    function_1e28c();
  lab_0x2befc:
    // 0x2befc
    v7 = g234;
    v10 = v15;
    goto lab_0x2bf00;
}

// Address range: 0x2c06c - 0x2c2e4
int32_t function_2c06c(uint32_t a1, uint32_t a2, int32_t a3) {
    int32_t v1 = (uint32_t)(a1 % 256); // 0x2c070
    int32_t v2 = a2 % 256; // 0x2c084
    function_11f94(&g417, a2, a3, 5);
    int32_t v3 = 5; // 0x2c0cc
    int32_t v4; // 0x2c06c
    int32_t v5; // 0x2c06c
    int32_t v6; // 0x2c06c
    int32_t v7; // 0x2c06c
    int32_t v8; // 0x2c06c
    int32_t v9; // 0x2c06c
    int32_t str; // bp-2088, 0x2c06c
    int32_t v10; // 0x2c06c
    int32_t v11; // 0x2c06c
    while (true) {
        int32_t v12 = v3;
        function_2bdd0();
        function_1ec84(a3 % 256, 0, v2, v1);
        v10 = 8;
        v4 = 0;
        v6 = v2;
        v8 = v1;
        while (true) {
          lab_0x2c0f0:
            // 0x2c0f0
            v11 = v10;
            function_304d4(10);
            function_11f94(&g416, v4, v6, v8);
            int32_t v13 = g234; // 0x2c100
            int32_t v14 = v13; // 0x2c108
            int32_t v15 = 0; // 0x2c108
            v5 = v4;
            v7 = 0;
            v9 = v8;
            if (v13 != 0) {
                while (true) {
                    int32_t v16 = v14 - 1; // 0x2c128
                    g234 = v16;
                    int32_t v17 = g233 + 1; // 0x2c134
                    bool v18 = v17 == 510 | (v17 & 0x20000000) == 0; // 0x2c144
                    if (v17 >= 510 == (v17 != 510) || v18) {
                        g233 = v18 ? v17 : 0;
                    }
                    int32_t v19 = 8 * v17; // 0x2c140
                    int32_t v20 = (int32_t)*(char *)(v19 + (int32_t)&g232 + 11); // 0x2c148
                    if (v20 == a3) {
                        unsigned char v21 = *(char *)(v19 + (int32_t)&g232 + 9); // 0x2c154
                        if ((int32_t)v21 == a2) {
                            unsigned char v22 = *(char *)(v19 + (int32_t)&g232 + 10); // 0x2c160
                            if ((int32_t)v22 == a1) {
                                int32_t v23 = v19 + (int32_t)&g232; // 0x2c140
                                if (a1 != 28) {
                                    // 0x2c27c
                                    function_11ea4(&g416, v23, a1, v17);
                                    function_2bdd0();
                                    function_11ea4(&g417, v23, a1, v17);
                                    return *(int32_t *)(v19 + (int32_t)&g232 + 4);
                                }
                                uint32_t v24 = *(int32_t *)(v19 + (int32_t)&g232 + 4); // 0x2c17c
                                function_11ea4(&g416, v23, 28, v17);
                                function_2bdd0();
                                function_11ea4(&g417, v23, 28, v17);
                                return v24 < 0x20000000 ? v24 : 0;
                            }
                        }
                    }
                    int32_t v25 = v15 + 1; // 0x2c12c
                    char * v26 = g289; // 0x2c1b0
                    int32_t v27; // 0x2c06c
                    if (v26 >= (char *)3 == (v26 != (char *)3)) {
                        unsigned char v28 = *(char *)(v19 + (int32_t)&g232 + 10); // 0x2c1dc
                        unsigned char v29 = *(char *)(v19 + (int32_t)&g232 + 9); // 0x2c1e4
                        snprintf((char *)&str, 2048, "read asic reg error: expect chain = %d, chip = %d, reg = %d, got chain = %d, chip = %d, reg = %d\n", a3, a2, a1, v20, (int32_t)v29, (int32_t)v28);
                        function_2e584(3, &str, 0);
                        v5 = &str;
                        v7 = 0;
                        v9 = a3;
                        if (v13 == v25) {
                            // break -> 0x2c218
                            break;
                        }
                        // 0x2c1cc
                        v27 = g234;
                    } else {
                        // 0x2c1bc
                        v27 = v16;
                        if (v13 == v25) {
                            // 0x2c218
                            v5 = v19 + (int32_t)&g232;
                            v7 = (int32_t)v26;
                            v9 = v17;
                            goto lab_0x2c218_2;
                        }
                    }
                    // 0x2c1c4
                    v14 = v27;
                    v15 = v25;
                }
            }
            goto lab_0x2c218_2;
        }
      lab_0x2c230:
        // 0x2c230
        v3 = v12 - 1;
        if (v12 == 1) {
            // break -> 0x2c240
            break;
        }
    }
    char * v30 = g289; // 0x2c250
    int32_t v31; // 0x2c06c
    int32_t v32 = v31; // 0x2c258
    int32_t v33 = (int32_t)v30; // 0x2c258
    if (v30 >= (char *)4 == (v30 != (char *)4)) {
        // 0x2c2b0
        snprintf((char *)&str, 2048, "read asic reg timeout: expect chain = %d, chip = %d, reg = %d\n", a3, a2, a1);
        function_2e584(4, &str, v3);
        v32 = 0;
        v33 = a3;
    }
    // 0x2c25c
    function_2bdd0();
    int32_t v34; // 0x2c06c
    function_11ea4(&g417, v34, v32, v33);
    return 0;
  lab_0x2c218_2:
    // 0x2c218
    v31 = v7;
    v34 = v5;
    function_11ea4(&g416, v34, v31, v9);
    int32_t v35 = v11 - 1; // 0x2c224
    v10 = v35;
    v4 = v34;
    v6 = v31;
    v8 = v35;
    if (v11 == 1) {
        // break -> 0x2c230
        goto lab_0x2c230;
    }
    goto lab_0x2c0f0;
}

// Address range: 0x2c2e8 - 0x2c5e4
int32_t function_2c2e8(uint32_t a1, int32_t a2, int32_t a3, int32_t * a4) {
    // 0x2c2e8
    int32_t str; // bp-2088, 0x2c2e8
    if (function_1e29c(a3) == 0) {
        char * v1 = g289; // 0x2c31c
        if (v1 >= (char *)3 != v1 != (char *)3) {
            // 0x2c32c
            return v1 == (char *)3 | v1 < (char *)3;
        }
        // 0x2c338
        snprintf((char *)&str, 2048, "chain::%d don't exist!!!\n", a3);
        function_2e584(3, &str, 0);
        return -1;
    }
    int32_t v2 = (int32_t)a4;
    uint32_t v3 = a3 % 256; // 0x2c374
    function_11f94(&g417, a2, a3, v2);
    function_1629c();
    *(char *)&g418 = 1;
    function_2bdd0();
    int32_t v4; // 0x2c2e8
    int32_t v5; // 0x2c2e8
    if (a1 == 2) {
        int32_t v6 = function_1e160() * a2; // 0x2c598
        function_50dc4(v3, v6, 2);
        v4 = v6;
        v5 = 2;
    } else {
        int32_t v7 = function_1e160();
        if (a1 == 6) {
            int32_t v8 = v7 * a2; // 0x2c560
            function_50da8(v3, v8);
            v4 = v8;
            v5 = a3;
        } else {
            int32_t v9 = a1 % 256; // 0x2c3b0
            int32_t v10 = v7 * a2; // 0x2c3b4
            function_5193c(v3, v10, v9);
            v4 = v10;
            v5 = v9;
        }
    }
    // 0x2c3c0
    usleep(0x186a0);
    int32_t v11 = 0;
    int32_t v12 = 0;
    function_11f94(&g416, v4, v5, a2);
    int32_t v13 = g234; // 0x2c3f0
    int32_t v14 = v12; // 0x2c3fc
    int32_t v15 = v11; // 0x2c3fc
    int32_t v16 = v4; // 0x2c3fc
    int32_t v17 = 0; // 0x2c3fc
    int32_t v18 = v13; // 0x2c3fc
    int32_t v19; // 0x2c2e8
    int32_t v20; // 0x2c2e8
    int32_t v21; // 0x2c2e8
    int32_t v22; // 0x2c2e8
    int32_t v23; // 0x2c2e8
    int32_t v24; // 0x2c2e8
    int32_t v25; // 0x2c2e8
    int32_t v26; // 0x2c2e8
    int32_t v27; // 0x2c2e8
    int32_t v28; // 0x2c2e8
    int32_t v29; // 0x2c2e8
    int32_t v30; // 0x2c2e8
    int32_t v31; // 0x2c2e8
    int32_t v32; // 0x2c2e8
    int32_t v33; // 0x2c2e8
    int32_t v34; // 0x2c2e8
    int32_t v35; // 0x2c2e8
    int32_t v36; // 0x2c2e8
    int32_t v37; // 0x2c2e8
    int32_t v38; // 0x2c428
    uint32_t v39; // 0x2c42c
    int32_t v40; // 0x2c430
    int32_t v41; // 0x2c43c
    unsigned char v42; // 0x2c44c
    int32_t v43; // 0x2c478
    int32_t v44; // 0x2c484
    int32_t v45; // 0x2c48c
    int32_t v46; // 0x2c4a4
    uint32_t v47; // 0x2c4b0
    int32_t v48; // 0x2c4b8
    int32_t v49; // 0x2c4c0
    if (v13 < 1) {
        // 0x2c570
        function_11ea4(&g416, v4, v5, a2);
        v37 = v12;
        v32 = v11;
        v24 = v5;
        v27 = a2;
        if (v13 == 0) {
            // 0x2c580
            usleep(1000);
            v37 = v12;
            v32 = v11;
            v24 = v5;
            v27 = a2;
        }
    } else {
        while (true) {
            // 0x2c41c
            v22 = v16;
            v30 = v15;
            v35 = v14;
            g234 = v18 - 1;
            v38 = v17 + 1;
            v39 = g233 + 1;
            v40 = 8 * v39;
            v28 = v39 >= 510 == (v39 != 510) ? 0 : v39;
            v41 = (int32_t)*(char *)(v40 + (int32_t)&g232 + 11);
            g233 = v28;
            v33 = v35;
            v20 = v22;
            v25 = v28;
            if (v41 == a3) {
                // 0x2c44c
                v42 = *(char *)(v40 + (int32_t)&g232 + 10);
                v33 = v35;
                v20 = v22;
                v25 = v42;
                if (v42 == 64) {
                    // 0x2c458
                    v33 = v35;
                    v20 = function_1e160();
                    v25 = a2;
                    if (function_5faf8() == a2) {
                        // 0x2c478
                        v43 = (int32_t)*(int16_t *)(v40 + (int32_t)&g232 + 6);
                        v44 = v35 + 1;
                        v45 = function_1e120();
                        function_5fadc(v43, v45, a3, v43);
                        v46 = *(int32_t *)(4 * v45 + v2);
                        v33 = v44;
                        v20 = v45;
                        v25 = v46;
                        if (v46 == 0) {
                            // 0x2c4b0
                            v47 = *(int32_t *)(v40 + (int32_t)&g232 + 4);
                            v48 = v30 + 1;
                            v49 = function_1e120();
                            function_5fadc(v47 / 0x10000, v49, a3, v48);
                            *(int32_t *)(4 * v49 + v2) = v47 % 0x10000;
                            v34 = v44;
                            v29 = v48;
                            v21 = v49;
                            v19 = a3;
                            v36 = v44;
                            v31 = v48;
                            v23 = v49;
                            v26 = v2;
                            if (v13 == v38) {
                                // break -> 0x2c4e4
                                break;
                            }
                            goto lab_0x2c418;
                        } else {
                            goto lab_0x2c410;
                        }
                    } else {
                        goto lab_0x2c410;
                    }
                } else {
                    goto lab_0x2c410;
                }
            } else {
                goto lab_0x2c410;
            }
        }
        // 0x2c4e4
        function_11ea4(&g416, v23, v19, v26);
        v37 = v36;
        v32 = v31;
        v24 = v19;
        v27 = v26;
    }
    int32_t v50 = v24;
    int32_t v51 = v32;
    int32_t v52 = v37;
    int32_t v53; // bp-2096, 0x2c2e8
    function_302a0(&v53);
    int32_t v54; // bp-2104, 0x2c2e8
    while (function_30578(&v53, &v54) < 200) {
        int32_t v55 = v27;
        int32_t v56 = v50;
        v11 = v51;
        v12 = v52;
        function_11f94(&g416, v4, v56, v55);
        v13 = g234;
        v14 = v12;
        v15 = v11;
        v16 = v4;
        v17 = 0;
        v18 = v13;
        if (v13 < 1) {
            // 0x2c570
            function_11ea4(&g416, v4, v56, v55);
            v37 = v12;
            v32 = v11;
            v24 = v56;
            v27 = v55;
            if (v13 == 0) {
                // 0x2c580
                usleep(1000);
                v37 = v12;
                v32 = v11;
                v24 = v56;
                v27 = v55;
            }
        } else {
            while (true) {
                // 0x2c41c
                v22 = v16;
                v30 = v15;
                v35 = v14;
                g234 = v18 - 1;
                v38 = v17 + 1;
                v39 = g233 + 1;
                v40 = 8 * v39;
                v28 = v39 >= 510 == (v39 != 510) ? 0 : v39;
                v41 = (int32_t)*(char *)(v40 + (int32_t)&g232 + 11);
                g233 = v28;
                v33 = v35;
                v20 = v22;
                v25 = v28;
                if (v41 == a3) {
                    // 0x2c44c
                    v42 = *(char *)(v40 + (int32_t)&g232 + 10);
                    v33 = v35;
                    v20 = v22;
                    v25 = v42;
                    if (v42 == 64) {
                        // 0x2c458
                        v33 = v35;
                        v20 = function_1e160();
                        v25 = a2;
                        if (function_5faf8() == a2) {
                            // 0x2c478
                            v43 = (int32_t)*(int16_t *)(v40 + (int32_t)&g232 + 6);
                            v44 = v35 + 1;
                            v45 = function_1e120();
                            function_5fadc(v43, v45, a3, v43);
                            v46 = *(int32_t *)(4 * v45 + v2);
                            v33 = v44;
                            v20 = v45;
                            v25 = v46;
                            if (v46 == 0) {
                                // 0x2c4b0
                                v47 = *(int32_t *)(v40 + (int32_t)&g232 + 4);
                                v48 = v30 + 1;
                                v49 = function_1e120();
                                function_5fadc(v47 / 0x10000, v49, a3, v48);
                                *(int32_t *)(4 * v49 + v2) = v47 % 0x10000;
                                v34 = v44;
                                v29 = v48;
                                v21 = v49;
                                v19 = a3;
                                v36 = v44;
                                v31 = v48;
                                v23 = v49;
                                v26 = v2;
                                if (v13 == v38) {
                                    // break -> 0x2c4e4
                                    break;
                                }
                                goto lab_0x2c418;
                            } else {
                                goto lab_0x2c410;
                            }
                        } else {
                            goto lab_0x2c410;
                        }
                    } else {
                        goto lab_0x2c410;
                    }
                } else {
                    goto lab_0x2c410;
                }
            }
            // 0x2c4e4
            function_11ea4(&g416, v23, v19, v26);
            v37 = v36;
            v32 = v31;
            v24 = v19;
            v27 = v26;
        }
        // 0x2c4f0
        v50 = v24;
        v51 = v32;
        v52 = v37;
        function_302a0(&v53);
    }
    int32_t v57 = v4; // 0x2c518
    int32_t v58 = v50; // 0x2c518
    if (v51 != function_1e120()) {
        char * v59 = g289; // 0x2c524
        v57 = v4;
        v58 = v50;
        if (v59 >= (char *)3 == (v59 != (char *)3)) {
            int32_t v60 = function_1e120(); // 0x2c5a8
            snprintf((char *)&str, 2048, "recv core response not enough!!!, total recv::%d, valid::%d, need::%d.\n", v52, v51, v60);
            function_2e584(3, &str, 0);
            v57 = &str;
            v58 = 0;
        }
    }
    // 0x2c530
    *(char *)&g418 = 0;
    function_162b0();
    function_11ea4(&g417, v57, v58, (int32_t)&g416);
    return 0;
  lab_0x2c410:
    // 0x2c410
    v34 = v33;
    v29 = v30;
    v21 = v20;
    v19 = v41;
    v23 = v20;
    v26 = v25;
    if (v13 == v38) {
        // break -> 0x2c4e4
        goto lab_0x2c4e4;
    }
    goto lab_0x2c418;
  lab_0x2c418:
    // 0x2c418
    v14 = v34;
    v15 = v29;
    v16 = v21;
    v17 = v38;
    v18 = g234;
    goto lab_0x2c41c;
}

// Address range: 0x2c5e8 - 0x2c96c
int32_t function_2c5e8(int32_t * a1) {
    int32_t result = (int32_t)a1;
    int32_t v1 = result;
    if (g73 == 0) {
        // 0x2c62c
        return result;
    }
    char * str; // bp-2088, 0x2c5e8
    if ((result & 128) == 0) {
        char * v2 = g289; // 0x2c620
        if (v2 >= (char *)3 != v2 != (char *)3) {
            // 0x2c62c
            return result;
        }
        // 0x2c6a4
        str = (char *)0x20212121;
        return function_2e584(3, (int32_t *)&str, 0);
    }
    if ((result & 64) != 0) {
        char * v3 = g289; // 0x2c648
        int32_t result2 = result; // 0x2c650
        if (v3 != (char *)3 && v3 >= (char *)3) {
            // 0x2c654
            str = (char *)0x20212121;
            result2 = function_2e584(3, (int32_t *)&str, 0);
            v1 = result2;
        }
        // 0x2c684
        g236++;
        return result2;
    }
    // 0x2c6e4
    int32_t v4; // 0x2c5e8
    function_11f94(&g88, v4, v4, result % 256);
    int32_t v5 = g239; // 0x2c6f8
    int32_t v6; // 0x2c5e8
    int32_t v7; // 0x2c5e8
    int32_t v8; // 0x2c5e8
    int32_t v9; // 0x2c7d4
    int32_t v10; // 0x2c7d8
    uint32_t v11; // 0x2c7e0
    uint32_t v12; // 0x2c7f4
    if (v5 == 510 || v5 < 510) {
        int32_t v13 = __asm_ubfx((int32_t)*(int16_t *)(result + 2), 0, 15); // 0x2c75c
        int32_t v14 = 60 * g237; // 0x2c768
        *(int32_t *)(v14 + (int32_t)&g237 + 16) = v13;
        int32_t * v15 = (int32_t *)(v14 + (int32_t)&g237 + 32); // 0x2c774
        *v15 = *(int32_t *)(result + 4);
        int32_t * v16 = (int32_t *)(v14 + (int32_t)&g237 + 36); // 0x2c780
        *v16 = (int32_t)(*(char *)&v1 % 16);
        int32_t v17 = function_4466c(v13); // 0x2c784
        char * v18 = g289; // 0x2c788
        *(int32_t *)(v14 + (int32_t)&g237 + 12) = v17;
        if (v18 >= (char *)4 == (v18 != (char *)4)) {
            uint16_t v19 = *(int16_t *)(result + 9); // 0x2c8e0
            snprintf((char *)&str, 2048, "blk ver = 0x%x\n", (int32_t)v19);
            function_2e584(4, (int32_t *)&str, 0);
        }
        int32_t v20 = function_44680(v13); // 0x2c7ac
        *(int32_t *)(v14 + (int32_t)&g237 + 20) = v20;
        int32_t v21 = function_44654(v13); // 0x2c7b8
        *(int32_t *)(v14 + (int32_t)&g237 + 24) = v21;
        *(int32_t *)(v14 + (int32_t)&g237 + 28) = (int32_t)&str;
        function_44698(v13, v14 + (int32_t)&g237 + 40, 32);
        v9 = *v15;
        v10 = *v16;
        v11 = function_51970(v9);
        function_1e160();
        v12 = function_51978(v9);
        if (v10 < 4) {
            // 0x2c87c
            if (v12 < function_1e0f0()) {
                int32_t v22 = function_1e120(); // 0x2c888
                v1 = v22;
                if (v9 == 0 || v11 >= v22) {
                    goto lab_0x2c804;
                } else {
                    int32_t v23 = v12 + 256 * v10; // 0x2c898
                    int32_t * v24 = (int32_t *)(4 * v10 + (int32_t)&g421); // 0x2c8ac
                    int32_t * v25 = (int32_t *)(4 * v23 + (int32_t)&g421 + 16); // 0x2c8b4
                    int32_t * v26 = (int32_t *)(4 * (1024 * v23 + v11) + (int32_t)&g421 + 0x1010); // 0x2c8bc
                    *v24 = *v24 + 1;
                    *v25 = *v25 + 1;
                    *v26 = *v26 + 1;
                    goto lab_0x2c810;
                }
            } else {
                goto lab_0x2c804;
            }
        } else {
            goto lab_0x2c804;
        }
    } else {
        // 0x2c708
        v7 = v5;
        v8 = 510;
        if (g419 == 0) {
            char * v27 = g289; // 0x2c724
            int32_t v28 = v5; // 0x2c72c
            int32_t v29; // 0x2c5e8
            if (v27 >= (char *)3 == (v27 != (char *)3)) {
                // 0x2c84c
                str = (char *)0x636e6f6e;
                function_2e584(3, (int32_t *)&str, 0);
                v29 = (int32_t)&str;
                v28 = 0;
            }
            // 0x2c730
            g419 = 1;
            v6 = v29;
            v7 = v28;
            v8 = 1;
        }
        goto lab_0x2c738;
    }
  lab_0x2c804:;
    char * v30 = g289; // 0x2c804
    if (v30 >= (char *)4 == (v30 != (char *)4)) {
        // 0x2c908
        snprintf((char *)&str, 2048, "buf [%x] is error!\n", v9);
        function_2e584(4, (int32_t *)&str, 0);
        char * v31 = g289; // 0x2c930
        if (v31 != (char *)4 && v31 >= (char *)4) {
            // 0x2c93c
            snprintf((char *)&str, 2048, "chain = %d, chip = %d, core = %d\n", v10, v12, v11);
            function_2e584(4, (int32_t *)&str, 0);
        }
    }
    goto lab_0x2c810;
  lab_0x2c738:;
    int32_t result3 = function_11ea4(&g88, v6, v7, v8); // 0x2c740
    v1 = result3;
    // 0x2c62c
    return result3;
  lab_0x2c810:;
    uint32_t v32 = g237 + 1; // 0x2c81c
    g237 = v32 >= 510 == (v32 != 510) ? 0 : v32;
    g239++;
    g419 = 0;
    v6 = 510;
    v7 = 0;
    v8 = &g416;
    goto lab_0x2c738;
}

// Address range: 0x2c96c - 0x2cb2c
int32_t function_2c96c(int32_t * a1) {
    int32_t result2 = (int32_t)a1;
    int32_t v1 = result2;
    unsigned char v2 = (char)result2 & 64;
    char * str; // bp-2064, 0x2c96c
    if (v2 != 0) {
        char * v3 = g289; // 0x2c988
        int32_t result = result2; // 0x2c990
        if (v3 >= (char *)3 == (v3 != (char *)3)) {
            // 0x2ca04
            str = (char *)0x20212121;
            result = function_2e584(3, (int32_t *)&str, 0);
            v1 = result;
        }
        // 0x2c994
        g235++;
        // 0x2c9a8
        return result;
    }
    char * v4 = (char *)(result2 + 3); // 0x2c9b0
    int32_t v5 = (int32_t)*v4; // 0x2c9b0
    if ((v5 & 96) != 0) {
        char * v6 = g289; // 0x2c9c8
        if (v6 == (char *)3 || v6 < (char *)3) {
            // 0x2c9a8
            return result2;
        }
        // 0x2c9d4
        snprintf((char *)&str, 2048, "!!! REG_TYPE = 1. %u\n", result2);
        return function_2e584(3, (int32_t *)&str, (int32_t)v2);
    }
    // 0x2ca3c
    int32_t v7; // 0x2c96c
    function_11f94(&g416, v7, v5, v7);
    int32_t v8 = g234; // 0x2ca58
    int32_t v9; // 0x2c96c
    if (v8 >= 510 == (v8 != 510)) {
        char * v10 = g289; // 0x2cae4
        int32_t v11 = v8; // 0x2caec
        v9 = (int32_t)v10;
        int32_t v12; // 0x2c96c
        if (v10 != (char *)3 && v10 >= (char *)3) {
            // 0x2caf0
            str = (char *)0x5f676572;
            function_2e584(3, (int32_t *)&str, 0);
            v12 = (int32_t)&str;
            v11 = 0;
            v9 = 2593;
        }
        // 0x2cac8
        return function_11ea4(&g416, v12, v11, v9);
    }
    int32_t v13 = *(int32_t *)(result2 + 4); // 0x2ca68
    int32_t v14 = g232 + 1; // 0x2ca70
    v1 = v14;
    int32_t v15 = 8 * v14; // 0x2ca74
    int32_t v16 = v15 + (int32_t)&g232; // 0x2ca74
    *(int32_t *)(v15 + (int32_t)&g232 + 4) = v13;
    int32_t v17 = __asm_ubfx((int32_t)*v4, 0, 5); // 0x2ca80
    *(char *)(v15 + (int32_t)&g232 + 8) = (char)v17;
    char v18 = *(char *)(result2 + 2); // 0x2ca88
    *(char *)(v15 + (int32_t)&g232 + 9) = v18;
    char v19 = *(char *)(result2 + 1); // 0x2ca90
    *(char *)(v15 + (int32_t)&g232 + 10) = v19;
    int32_t v20 = __asm_ubfx((int32_t)*(char *)&v1, 0, 4); // 0x2caa8
    *(char *)(v15 + (int32_t)&g232 + 11) = (char)v20;
    v9 = &g232;
    if (*(char *)&g418 == 0 == v19 == 64) {
        // 0x2cac8
        return function_11ea4(&g416, v16, v8, v9);
    }
    int32_t v21 = v1;
    int32_t v22 = v8 + 1; // 0x2cab8
    g232 = v21;
    g234 = v22;
    if (v21 >= 510 == (v21 != 510)) {
        g232 = 0;
    }
    // 0x2cac8
    return function_11ea4(&g416, v16, v22, (int32_t)&g232);
}

// Address range: 0x2cb2c - 0x2cd2c
int32_t function_2cb2c(void) {
    char * v1 = g289; // 0x2cb40
    int32_t v2; // 0x2cb2c
    char * str; // bp-2088, 0x2cb2c
    if (v1 >= (char *)4 == (v1 != (char *)4)) {
        // 0x2ccf8
        str = (char *)0x7564200a;
        function_2e584(4, (int32_t *)&str, 0);
        v2 = 0;
    }
    int32_t * v3 = (int32_t *)&str;
    int32_t v4 = 0;
    int32_t v5 = 0;
    int32_t result = 0; // 0x2cb70
    int32_t v6 = v2; // 0x2cb70
    int32_t v7; // 0x2cb2c
    int32_t v8; // 0x2cb2c
    int32_t v9; // 0x2cb2c
    int32_t v10; // 0x2cb2c
    int32_t v11; // 0x2cb2c
    int32_t v12; // 0x2cb2c
    int32_t v13; // 0x2cb2c
    int32_t v14; // 0x2cb2c
    int32_t v15; // 0x2cb2c
    int32_t v16; // 0x2cb2c
    int32_t v17; // 0x2cb2c
    int32_t v18; // 0x2cb2c
    int32_t v19; // 0x2cb2c
    int32_t v20; // 0x2cb2c
    int32_t v21; // 0x2cbc8
    char * v22; // 0x2cbf0
    int32_t v23; // 0x2cbdc
    int32_t v24; // 0x2cbe4
    int32_t v25; // 0x2cbfc
    int32_t v26; // 0x2cc00
    int32_t v27; // 0x2cc0c
    char * v28; // 0x2cc18
    char * v29; // 0x2cb90
    int32_t v30; // 0x2cb9c
    char * v31; // 0x2cc2c
    int32_t v32; // 0x2cbb8
    int32_t v33; // 0x2cc5c
    char * v34; // 0x2cc60
    if (function_1e29c(v5) != 0) {
        // 0x2cb90
        v29 = g289;
        v9 = v2;
        if (v29 >= (char *)4 == (v29 != (char *)4)) {
            // 0x2cccc
            snprintf((char *)&str, 2048, "Chain[%d]:\n", v5);
            function_2e584(4, v3, 0);
            v9 = 0;
        }
        // 0x2cb9c
        v30 = function_1e0f0();
        v10 = v9;
        v8 = v30;
        v15 = v9;
        v20 = 0;
        if (v30 >= 1) {
            v18 = 0;
            v17 = 0;
            v32 = function_1e120();
            v12 = v32 < 1 ? 0 : v10;
            v19 = v18;
            if (v32 > 0) {
                // 0x2cbc8
                v21 = v17 + v4;
                v23 = 0x1000 * v21 + (int32_t)&g424;
                v23 += 4;
                v24 = *(int32_t *)v23;
                v11 = v24;
                while (v23 != 4 * (v32 + 1024 * v21) + (int32_t)&g424) {
                    // 0x2cbdc
                    v23 += 4;
                    v24 = *(int32_t *)v23 + v11;
                    v11 = v24;
                }
                // 0x2cbec
                v12 = v24;
                v19 = v24 + v18;
            }
            // 0x2cbf0
            v13 = v12;
            v22 = g289;
            v14 = v13;
            v16 = (int32_t)v22;
            if (v22 >= (char *)4 == (v22 != (char *)4)) {
                // 0x2cc88
                snprintf((char *)&str, 2048, "IC[%03d] = %-10d ", v17, v13);
                function_2e584(4, v3, 0);
                v14 = 0;
                v16 = v17;
            }
            // 0x2cbfc
            v25 = v17 + 1;
            v26 = function_1e100();
            v27 = function_5fd8c(v25, v26, v14, v16);
            v7 = v27;
            if (v26 == 0) {
                // 0x2cc18
                v28 = g289;
                v7 = v27;
                if (v28 >= (char *)4 == (v28 != (char *)4)) {
                    // 0x2ccb4
                    str = (char *)10;
                    v7 = function_2e584(4, v3, 0);
                }
            }
            // 0x2cc24
            v10 = v26;
            v8 = v7;
            v15 = v26;
            v20 = v19;
            while (v25 != v30) {
                // 0x2cbb8
                v18 = v19;
                v17 = v25;
                v32 = function_1e120();
                v12 = v32 < 1 ? 0 : v10;
                v19 = v18;
                if (v32 > 0) {
                    // 0x2cbc8
                    v21 = v17 + v4;
                    v23 = 0x1000 * v21 + (int32_t)&g424;
                    v23 += 4;
                    v24 = *(int32_t *)v23;
                    v11 = v24;
                    while (v23 != 4 * (v32 + 1024 * v21) + (int32_t)&g424) {
                        // 0x2cbdc
                        v23 += 4;
                        v24 = *(int32_t *)v23 + v11;
                        v11 = v24;
                    }
                    // 0x2cbec
                    v12 = v24;
                    v19 = v24 + v18;
                }
                // 0x2cbf0
                v13 = v12;
                v22 = g289;
                v14 = v13;
                v16 = (int32_t)v22;
                if (v22 >= (char *)4 == (v22 != (char *)4)) {
                    // 0x2cc88
                    snprintf((char *)&str, 2048, "IC[%03d] = %-10d ", v17, v13);
                    function_2e584(4, v3, 0);
                    v14 = 0;
                    v16 = v17;
                }
                // 0x2cbfc
                v25 = v17 + 1;
                v26 = function_1e100();
                v27 = function_5fd8c(v25, v26, v14, v16);
                v7 = v27;
                if (v26 == 0) {
                    // 0x2cc18
                    v28 = g289;
                    v7 = v27;
                    if (v28 >= (char *)4 == (v28 != (char *)4)) {
                        // 0x2ccb4
                        str = (char *)10;
                        v7 = function_2e584(4, v3, 0);
                    }
                }
                // 0x2cc24
                v10 = v26;
                v8 = v7;
                v15 = v26;
                v20 = v19;
            }
        }
        // 0x2cc2c
        v31 = g289;
        result = v8;
        v6 = v15;
        if (v31 != (char *)4 && v31 >= (char *)4) {
            // 0x2cc38
            snprintf((char *)&str, 2048, "Chain[%d] total nonce number = %d\n", v5, v20);
            v33 = function_2e584(4, v3, 0);
            v34 = g289;
            result = v33;
            v6 = 0;
            if (v34 != (char *)4 && v34 >= (char *)4) {
                // 0x2cc6c
                str = (char *)10;
                result = function_2e584(4, v3, 0);
                v6 = 0;
            }
        }
    }
    int32_t v35 = v5 + 1; // 0x2cb74
    int32_t v36 = v4 + 256; // 0x2cb80
    while (v35 != 4) {
        // 0x2cb64
        v4 = v36;
        v5 = v35;
        int32_t v37 = v6;
        result = 0;
        v6 = v37;
        if (function_1e29c(v5) != 0) {
            // 0x2cb90
            v29 = g289;
            v9 = v37;
            if (v29 >= (char *)4 == (v29 != (char *)4)) {
                // 0x2cccc
                snprintf((char *)&str, 2048, "Chain[%d]:\n", v5);
                function_2e584(4, v3, 0);
                v9 = 0;
            }
            // 0x2cb9c
            v30 = function_1e0f0();
            v10 = v9;
            v8 = v30;
            v15 = v9;
            v20 = 0;
            if (v30 >= 1) {
                v18 = 0;
                v17 = 0;
                v32 = function_1e120();
                v12 = v32 < 1 ? 0 : v10;
                v19 = v18;
                if (v32 > 0) {
                    // 0x2cbc8
                    v21 = v17 + v4;
                    v23 = 0x1000 * v21 + (int32_t)&g424;
                    v23 += 4;
                    v24 = *(int32_t *)v23;
                    v11 = v24;
                    while (v23 != 4 * (v32 + 1024 * v21) + (int32_t)&g424) {
                        // 0x2cbdc
                        v23 += 4;
                        v24 = *(int32_t *)v23 + v11;
                        v11 = v24;
                    }
                    // 0x2cbec
                    v12 = v24;
                    v19 = v24 + v18;
                }
                // 0x2cbf0
                v13 = v12;
                v22 = g289;
                v14 = v13;
                v16 = (int32_t)v22;
                if (v22 >= (char *)4 == (v22 != (char *)4)) {
                    // 0x2cc88
                    snprintf((char *)&str, 2048, "IC[%03d] = %-10d ", v17, v13);
                    function_2e584(4, v3, 0);
                    v14 = 0;
                    v16 = v17;
                }
                // 0x2cbfc
                v25 = v17 + 1;
                v26 = function_1e100();
                v27 = function_5fd8c(v25, v26, v14, v16);
                v7 = v27;
                if (v26 == 0) {
                    // 0x2cc18
                    v28 = g289;
                    v7 = v27;
                    if (v28 >= (char *)4 == (v28 != (char *)4)) {
                        // 0x2ccb4
                        str = (char *)10;
                        v7 = function_2e584(4, v3, 0);
                    }
                }
                // 0x2cc24
                v10 = v26;
                v8 = v7;
                v15 = v26;
                v20 = v19;
                while (v25 != v30) {
                    // 0x2cbb8
                    v18 = v19;
                    v17 = v25;
                    v32 = function_1e120();
                    v12 = v32 < 1 ? 0 : v10;
                    v19 = v18;
                    if (v32 > 0) {
                        // 0x2cbc8
                        v21 = v17 + v4;
                        v23 = 0x1000 * v21 + (int32_t)&g424;
                        v23 += 4;
                        v24 = *(int32_t *)v23;
                        v11 = v24;
                        while (v23 != 4 * (v32 + 1024 * v21) + (int32_t)&g424) {
                            // 0x2cbdc
                            v23 += 4;
                            v24 = *(int32_t *)v23 + v11;
                            v11 = v24;
                        }
                        // 0x2cbec
                        v12 = v24;
                        v19 = v24 + v18;
                    }
                    // 0x2cbf0
                    v13 = v12;
                    v22 = g289;
                    v14 = v13;
                    v16 = (int32_t)v22;
                    if (v22 >= (char *)4 == (v22 != (char *)4)) {
                        // 0x2cc88
                        snprintf((char *)&str, 2048, "IC[%03d] = %-10d ", v17, v13);
                        function_2e584(4, v3, 0);
                        v14 = 0;
                        v16 = v17;
                    }
                    // 0x2cbfc
                    v25 = v17 + 1;
                    v26 = function_1e100();
                    v27 = function_5fd8c(v25, v26, v14, v16);
                    v7 = v27;
                    if (v26 == 0) {
                        // 0x2cc18
                        v28 = g289;
                        v7 = v27;
                        if (v28 >= (char *)4 == (v28 != (char *)4)) {
                            // 0x2ccb4
                            str = (char *)10;
                            v7 = function_2e584(4, v3, 0);
                        }
                    }
                    // 0x2cc24
                    v10 = v26;
                    v8 = v7;
                    v15 = v26;
                    v20 = v19;
                }
            }
            // 0x2cc2c
            v31 = g289;
            result = v8;
            v6 = v15;
            if (v31 != (char *)4 && v31 >= (char *)4) {
                // 0x2cc38
                snprintf((char *)&str, 2048, "Chain[%d] total nonce number = %d\n", v5, v20);
                v33 = function_2e584(4, v3, 0);
                v34 = g289;
                result = v33;
                v6 = 0;
                if (v34 != (char *)4 && v34 >= (char *)4) {
                    // 0x2cc6c
                    str = (char *)10;
                    result = function_2e584(4, v3, 0);
                    v6 = 0;
                }
            }
        }
        // 0x2cb74
        v35 = v5 + 1;
        v36 = v4 + 256;
    }
    // 0x2cb84
    return result;
}

// Address range: 0x2cd30 - 0x2cdf8
int32_t function_2cd30(int32_t a1, int32_t a2) {
    // 0x2cd30
    function_1e120();
    function_1e150();
    int32_t v1 = function_5faf8(); // 0x2cd50
    function_1e150();
    int32_t v2 = function_5f880(); // 0x2cd64
    int32_t v3 = function_1e100() * v2; // 0x2cd70
    int32_t v4 = function_1e150(); // 0x2cd74
    int32_t v5; // 0x2cd30
    function_5fadc(a2, v4, v5, v5);
    uint32_t v6 = function_1e100() + v3; // 0x2cd8c
    if (v3 >= v6) {
        // 0x2cdec
        return 0;
    }
    uint32_t v7 = v4 * v1; // 0x2cd84
    int32_t result = 0; // 0x2cdb8
    int32_t v8 = 4 * (v7 + 1028 + 1024 * (v3 + 256 * a1)) + (int32_t)&g420; // 0x2cdb8
    int32_t v9 = v3; // 0x2cdb8
    int32_t v10; // 0x2cd30
    int32_t v11 = v7 >= v7 + v1 ? v10 : v8 + 4 * v1;
    int32_t v12 = result; // 0x2cdc8
    int32_t v13 = v8; // 0x2cdc8
    int32_t v14 = result; // 0x2cdc8
    int32_t v15; // 0x2cdcc
    int32_t v16; // 0x2cdd4
    if (v7 < v7 + v1) {
        v15 = v13 + 4;
        v16 = *(int32_t *)v15 + v12;
        v12 = v16;
        v13 = v15;
        v14 = v16;
        while (v15 != v11) {
            // 0x2cdcc
            v15 = v13 + 4;
            v16 = *(int32_t *)v15 + v12;
            v12 = v16;
            v13 = v15;
            v14 = v16;
        }
    }
    // 0x2cddc
    result = v14;
    v9++;
    v8 += 0x1000;
    while (v6 != v9) {
        // 0x2cdbc
        v11 = v7 >= v7 + v1 ? v11 : v8 + 4 * v1;
        v12 = result;
        v13 = v8;
        v14 = result;
        if (v7 < v7 + v1) {
            v15 = v13 + 4;
            v16 = *(int32_t *)v15 + v12;
            v12 = v16;
            v13 = v15;
            v14 = v16;
            while (v15 != v11) {
                // 0x2cdcc
                v15 = v13 + 4;
                v16 = *(int32_t *)v15 + v12;
                v12 = v16;
                v13 = v15;
                v14 = v16;
            }
        }
        // 0x2cddc
        result = v14;
        v9++;
        v8 += 0x1000;
    }
    // 0x2cdec
    return result;
}

// Address range: 0x2cdfc - 0x2ce20
int32_t function_2cdfc(uint32_t a1, uint32_t a2) {
    bool v1 = false; // 0x2ce00
    bool v2 = false; // 0x2ce00
    if (a2 == 255 || a2 < 255) {
        v1 = a1 == 3;
        v2 = a1 < 3;
    }
    int32_t v3 = a2; // 0x2ce04
    bool v4 = false; // 0x2ce04
    if (v1 || v2) {
        v3 = 256 * a1 + a2;
        v4 = (a1 & 0x1000000) == 0;
    }
    bool v5 = v1 | v4; // 0x2ce08
    int32_t v6 = a1; // 0x2ce14
    bool v7 = true; // 0x2ce14
    if (v5) {
        int32_t v8 = v3;
        int32_t v9 = v5 ? v8 + 4 : v8;
        v6 = *(int32_t *)(4 * v9 + (int32_t)&g421);
        v7 = (v9 & 0x40000000) != 0;
    }
    return v7 == !v1 ? 0 : v6;
}

// Address range: 0x2ce20 - 0x2cfec
int32_t function_2ce20(void) {
    char * v1 = g289; // 0x2ce34
    int32_t v2; // 0x2ce20
    char * str; // bp-2088, 0x2ce20
    if (v1 >= (char *)4 == (v1 != (char *)4)) {
        // 0x2cfb0
        str = (char *)0x7564200a;
        function_2e584(4, (int32_t *)&str, 0);
        v2 = 0;
    }
    int32_t * v3 = (int32_t *)&str;
    int32_t v4 = 0;
    int32_t result = 0; // 0x2ce6c
    int32_t v5 = v2; // 0x2ce6c
    int32_t v6; // 0x2ce20
    int32_t v7; // 0x2ce20
    int32_t v8; // 0x2ce20
    int32_t v9; // 0x2ce20
    int32_t v10; // 0x2ce20
    int32_t v11; // 0x2ce20
    int32_t v12; // 0x2ce20
    int32_t v13; // 0x2ce20
    int32_t v14; // 0x2ce20
    int32_t v15; // 0x2ce20
    int32_t v16; // 0x2ce20
    int32_t v17; // 0x2ce20
    int32_t v18; // 0x2ce20
    int32_t v19; // 0x2ce20
    int32_t v20; // 0x2cef8
    int32_t v21; // 0x2cea0
    char * v22; // 0x2ceb8
    int32_t v23; // 0x2cecc
    char * v24; // 0x2ce88
    int32_t v25; // 0x2cecc
    int32_t v26; // 0x2cef0
    char * v27; // 0x2cef4
    char * v28; // 0x2cf30
    if (function_1e29c(v4) != 0) {
        // 0x2ce88
        v24 = g289;
        v8 = v2;
        if (v24 >= (char *)4 == (v24 != (char *)4)) {
            // 0x2cf88
            snprintf((char *)&str, 2048, "Chain[%d]:\n", v4);
            function_2e584(4, v3, 0);
            v8 = 0;
        }
        // 0x2ce94
        v25 = function_1e0e0();
        v12 = v8;
        v13 = v8;
        if (function_1e150() * v25 > 0) {
            v19 = 0;
            v7 = 1;
            v26 = function_2cd30(v4, v19);
            v27 = g289;
            v9 = v12;
            v14 = (int32_t)v27;
            if (v27 != (char *)4 && v27 >= (char *)4) {
                // 0x2cf04
                snprintf((char *)&str, 2048, "D[%02d]:%-10d ", v19, v26);
                function_2e584(4, v3, 0);
                v9 = 0;
                v14 = v19;
            }
            // 0x2cea0
            v20 = v26;
            v10 = v9;
            v21 = function_1e150();
            function_5fd8c(v7, v21, v10, v14);
            v11 = v10;
            v15 = v20;
            if (v21 == 0) {
                // 0x2ceb8
                v22 = g289;
                v17 = v22 == (char *)4 | v22 < (char *)4 ? 0 : v20;
                v11 = v10;
                v15 = v17;
                if (v22 >= (char *)4 == (v22 != (char *)4)) {
                    // 0x2cf58
                    snprintf((char *)&str, 2048, "D_BIG[%02d]:%-10d\n", v19 / 4, v17);
                    function_2e584(4, v3, 0);
                    v11 = 0;
                    v15 = 0;
                }
            }
            // 0x2cec8
            v23 = function_1e0e0();
            v6 = v7 + 1;
            v18 = v7;
            v16 = v15;
            v12 = v11;
            v13 = v11;
            while (function_1e150() * v23 > v7) {
                // 0x2cef0
                v19 = v18;
                v7 = v6;
                v26 = function_2cd30(v4, v19);
                v27 = g289;
                v9 = v12;
                v14 = (int32_t)v27;
                if (v27 != (char *)4 && v27 >= (char *)4) {
                    // 0x2cf04
                    snprintf((char *)&str, 2048, "D[%02d]:%-10d ", v19, v26);
                    function_2e584(4, v3, 0);
                    v9 = 0;
                    v14 = v19;
                }
                // 0x2cea0
                v20 = v26 + v16;
                v10 = v9;
                v21 = function_1e150();
                function_5fd8c(v7, v21, v10, v14);
                v11 = v10;
                v15 = v20;
                if (v21 == 0) {
                    // 0x2ceb8
                    v22 = g289;
                    v17 = v22 == (char *)4 | v22 < (char *)4 ? 0 : v20;
                    v11 = v10;
                    v15 = v17;
                    if (v22 >= (char *)4 == (v22 != (char *)4)) {
                        // 0x2cf58
                        snprintf((char *)&str, 2048, "D_BIG[%02d]:%-10d\n", v19 / 4, v17);
                        function_2e584(4, v3, 0);
                        v11 = 0;
                        v15 = 0;
                    }
                }
                // 0x2cec8
                v23 = function_1e0e0();
                v6 = v7 + 1;
                v18 = v7;
                v16 = v15;
                v12 = v11;
                v13 = v11;
            }
        }
        // 0x2cf30
        v28 = g289;
        result = v4;
        v5 = v13;
        if (v28 != (char *)4 && v28 >= (char *)4) {
            // 0x2cf3c
            str = (char *)10;
            result = function_2e584(4, v3, 0);
            v5 = 0;
        }
    }
    int32_t v29 = v4 + 1; // 0x2ce70
    while (v29 != 4) {
        // 0x2ce60
        v4 = v29;
        int32_t v30 = v5;
        result = 0;
        v5 = v30;
        if (function_1e29c(v4) != 0) {
            // 0x2ce88
            v24 = g289;
            v8 = v30;
            if (v24 >= (char *)4 == (v24 != (char *)4)) {
                // 0x2cf88
                snprintf((char *)&str, 2048, "Chain[%d]:\n", v4);
                function_2e584(4, v3, 0);
                v8 = 0;
            }
            // 0x2ce94
            v25 = function_1e0e0();
            v12 = v8;
            v13 = v8;
            if (function_1e150() * v25 > 0) {
                v19 = 0;
                v7 = 1;
                v26 = function_2cd30(v4, v19);
                v27 = g289;
                v9 = v12;
                v14 = (int32_t)v27;
                if (v27 != (char *)4 && v27 >= (char *)4) {
                    // 0x2cf04
                    snprintf((char *)&str, 2048, "D[%02d]:%-10d ", v19, v26);
                    function_2e584(4, v3, 0);
                    v9 = 0;
                    v14 = v19;
                }
                // 0x2cea0
                v20 = v26;
                v10 = v9;
                v21 = function_1e150();
                function_5fd8c(v7, v21, v10, v14);
                v11 = v10;
                v15 = v20;
                if (v21 == 0) {
                    // 0x2ceb8
                    v22 = g289;
                    v17 = v22 == (char *)4 | v22 < (char *)4 ? 0 : v20;
                    v11 = v10;
                    v15 = v17;
                    if (v22 >= (char *)4 == (v22 != (char *)4)) {
                        // 0x2cf58
                        snprintf((char *)&str, 2048, "D_BIG[%02d]:%-10d\n", v19 / 4, v17);
                        function_2e584(4, v3, 0);
                        v11 = 0;
                        v15 = 0;
                    }
                }
                // 0x2cec8
                v23 = function_1e0e0();
                v6 = v7 + 1;
                v18 = v7;
                v16 = v15;
                v12 = v11;
                v13 = v11;
                while (function_1e150() * v23 > v7) {
                    // 0x2cef0
                    v19 = v18;
                    v7 = v6;
                    v26 = function_2cd30(v4, v19);
                    v27 = g289;
                    v9 = v12;
                    v14 = (int32_t)v27;
                    if (v27 != (char *)4 && v27 >= (char *)4) {
                        // 0x2cf04
                        snprintf((char *)&str, 2048, "D[%02d]:%-10d ", v19, v26);
                        function_2e584(4, v3, 0);
                        v9 = 0;
                        v14 = v19;
                    }
                    // 0x2cea0
                    v20 = v26 + v16;
                    v10 = v9;
                    v21 = function_1e150();
                    function_5fd8c(v7, v21, v10, v14);
                    v11 = v10;
                    v15 = v20;
                    if (v21 == 0) {
                        // 0x2ceb8
                        v22 = g289;
                        v17 = v22 == (char *)4 | v22 < (char *)4 ? 0 : v20;
                        v11 = v10;
                        v15 = v17;
                        if (v22 >= (char *)4 == (v22 != (char *)4)) {
                            // 0x2cf58
                            snprintf((char *)&str, 2048, "D_BIG[%02d]:%-10d\n", v19 / 4, v17);
                            function_2e584(4, v3, 0);
                            v11 = 0;
                            v15 = 0;
                        }
                    }
                    // 0x2cec8
                    v23 = function_1e0e0();
                    v6 = v7 + 1;
                    v18 = v7;
                    v16 = v15;
                    v12 = v11;
                    v13 = v11;
                }
            }
            // 0x2cf30
            v28 = g289;
            result = v4;
            v5 = v13;
            if (v28 != (char *)4 && v28 >= (char *)4) {
                // 0x2cf3c
                str = (char *)10;
                result = function_2e584(4, v3, 0);
                v5 = 0;
            }
        }
        // 0x2ce70
        v29 = v4 + 1;
    }
    // 0x2ce7c
    return result;
}

// Address range: 0x2cfec - 0x2cffc
int32_t function_2cfec(void) {
    // 0x2cfec
    return (int32_t)g288;
}

// Address range: 0x2cffc - 0x2d158
int32_t function_2cffc(int32_t a1, int32_t a2) {
    char * v1 = g289; // 0x2d014
    int32_t v2; // 0x2cffc
    int32_t v3; // 0x2cffc
    int32_t str; // bp-2080, 0x2cffc
    if (v1 >= (char *)3 == (v1 != (char *)3)) {
        // 0x2d118
        snprintf((char *)&str, 2048, "\n asic nonce number for chain[%d] asic[%d]...\n", a1, a2);
        function_2ea54(3, &str, 0);
        int32_t v4 = function_1e120(); // 0x2d144
        v2 = v4;
        v3 = v4;
        if (v4 > 0) {
            goto lab_0x2d030;
        } else {
            goto lab_0x2d150;
        }
    } else {
        int32_t v5 = function_1e120(); // 0x2d024
        v3 = v5;
        if (v5 < 1) {
            goto lab_0x2d150;
        } else {
            // 0x2d024
            v2 = v5;
            goto lab_0x2d030;
        }
    }
  lab_0x2d05c:;
    // 0x2d05c
    int32_t v6; // 0x2cffc
    int32_t v7 = v6; // 0x2d060
    int32_t v8; // 0x2cffc
    int32_t v9 = v8; // 0x2d060
    int32_t v10; // 0x2cffc
    int32_t v11 = v10; // 0x2d060
    int32_t result = v6; // 0x2d060
    int32_t v12 = v10; // 0x2d060
    if (v2 == v8) {
        // break -> 0x2d0ec
        goto lab_0x2d0ec_2;
    }
    goto lab_0x2d064;
  lab_0x2d064:;
    int32_t v13 = v7; // 0x2cffc
    int32_t v14 = v9; // 0x2cffc
    int32_t v15 = v11; // 0x2cffc
    goto lab_0x2d064_2;
  lab_0x2d030:;
    char * str2 = (char *)&str;
    int32_t v22 = 0x1000 * (256 * a1 + a2) + (int32_t)&g421 + 0x1010;
    v13 = v2;
    v14 = 0;
    v15 = (int32_t)g289;
    while (true) {
      lab_0x2d064_2:;
        int32_t v16 = v15;
        int32_t v17 = v14;
        bool v18 = v16 == 3 | v16 < 3; // 0x2d068
        int32_t v19 = v17 + 1;
        v6 = v13;
        v8 = v19;
        v10 = v16;
        if (v18) {
            goto lab_0x2d05c;
        } else {
            int32_t v20 = v18 ? v19 : v17;
            int32_t v21 = v20 + 1; // 0x2d088
            snprintf(str2, 2048, "core[%03d]=%-8d", v20, *(int32_t *)(v22 + 4 * v20));
            function_2ea54(3, &str, 0);
            char * v23 = g289; // 0x2d0bc
            int32_t v24 = (int32_t)v23; // 0x2d0bc
            int32_t v25 = 2 * v21 / 10; // 0x2d0c8
            v6 = 3;
            v8 = v21;
            v10 = v24;
            if (v21 == v25) {
                // 0x2d0d0
                v6 = 3;
                v8 = v21;
                v10 = v24;
                if (v23 == (char *)3 || v23 < (char *)3) {
                    goto lab_0x2d05c;
                } else {
                    // 0x2d0d8
                    str = 10;
                    int32_t v26 = function_2ea54(3, &str, v21 - v25); // 0x2d0dc
                    int32_t v27 = (int32_t)g289; // 0x2d0e4
                    v7 = v26;
                    v9 = v21;
                    v11 = v27;
                    result = v26;
                    v12 = v27;
                    if (v2 == v21) {
                        // break -> 0x2d0ec
                        break;
                    }
                    goto lab_0x2d064;
                }
            } else {
                goto lab_0x2d05c;
            }
        }
    }
    goto lab_0x2d0ec_2;
  lab_0x2d150:
    // 0x2d150
    result = v3;
    v12 = (int32_t)g289;
    goto lab_0x2d0ec_2;
  lab_0x2d0ec_2:;
    uint32_t v28 = v12;
    if (v28 != 3 && v28 >= 3) {
        // 0x2d0f4
        str = 10;
        int32_t v29 = function_2ea54(3, &str, 0); // 0x2d108
    }
    // 0x2d10c
    return result;
}

// Address range: 0x2d158 - 0x2d33c
int32_t function_2d158(void) {
    // 0x2d158
    int32_t v1; // bp-296, 0x2d158
    int32_t v2 = &v1; // 0x2d170
    memset(&v1, 0, 256);
    int32_t v3 = 0;
    int32_t v4 = 0;
    int32_t result = 0; // 0x2d1a4
    int32_t v5 = v4; // 0x2d1a4
    int32_t v6; // 0x2d158
    int32_t v7; // 0x2d158
    int32_t v8; // 0x2d158
    int32_t v9; // 0x2d158
    int32_t v10; // 0x2d158
    int32_t chars_printed; // 0x2d260
    int32_t v11; // 0x2d268
    int32_t v12; // 0x2d310
    int32_t v13; // 0x2d32c
    int32_t v14; // 0x2d208
    int32_t v15; // 0x2d240
    int32_t v16; // 0x2d240
    int32_t v17; // 0x2d254
    if (function_1e29c(v3) != 0) {
        // 0x2d1bc
        v13 = g420;
        if (g420 == 0) {
            // 0x2d324
            v13 = function_536f4("bmminer_nonce");
            g420 = v13;
        }
        // 0x2d1cc
        function_54cb0(v13, "asic_response.c", 15, "dump_nonce_info_all_core", 24, 538, 20, (int32_t)"\n asic nonce number for chain[%d]...\n");
        v14 = function_1e0f0();
        result = v14;
        v5 = v4;
        if (v14 >= 1) {
            // 0x2d218
            v15 = 1024 * v3 + (int32_t)&g422;
            v10 = 0;
            v7 = v4;
            v15 += 4;
            v16 = *(int32_t *)v15;
            v17 = v10 + 1;
            chars_printed = snprintf((char *)(v7 + v2), 256 - v7, "asic[%03d]=%-8d", v10, v16);
            v11 = function_1e100();
            v6 = function_5fd8c(v17, v11, (int32_t)"asic[%03d]=%-8d", v10);
            v8 = chars_printed + v7;
            if (v11 == 0) {
                // 0x2d284
                v12 = g420;
                if (g420 == 0) {
                    // 0x2d308
                    v12 = function_536f4("bmminer_nonce");
                    g420 = v12;
                }
                // 0x2d294
                function_1e100();
                function_5faf8();
                v6 = function_54cb0(v12, "asic_response.c", 15, "dump_nonce_info_all_core", 24, 544, 20, (int32_t)"domain %02d %s total=%-8u");
                v8 = 0;
            }
            // 0x2d2f0
            v9 = v8;
            result = v6;
            v5 = v9;
            while (v17 != v14) {
                // 0x2d240
                v10 = v17;
                v7 = v9;
                v15 += 4;
                v16 = *(int32_t *)v15;
                v17 = v10 + 1;
                chars_printed = snprintf((char *)(v7 + v2), 256 - v7, "asic[%03d]=%-8d", v10, v16);
                v11 = function_1e100();
                v6 = function_5fd8c(v17, v11, (int32_t)"asic[%03d]=%-8d", v10);
                v8 = chars_printed + v7;
                if (v11 == 0) {
                    // 0x2d284
                    v12 = g420;
                    if (g420 == 0) {
                        // 0x2d308
                        v12 = function_536f4("bmminer_nonce");
                        g420 = v12;
                    }
                    // 0x2d294
                    function_1e100();
                    function_5faf8();
                    v6 = function_54cb0(v12, "asic_response.c", 15, "dump_nonce_info_all_core", 24, 544, 20, (int32_t)"domain %02d %s total=%-8u");
                    v8 = 0;
                }
                // 0x2d2f0
                v9 = v8;
                result = v6;
                v5 = v9;
            }
        }
    }
    int32_t v18 = v3 + 1; // 0x2d1a8
    while (v18 != 4) {
        // 0x2d198
        v3 = v18;
        v4 = v5;
        result = 0;
        v5 = v4;
        if (function_1e29c(v3) != 0) {
            // 0x2d1bc
            v13 = g420;
            if (g420 == 0) {
                // 0x2d324
                v13 = function_536f4("bmminer_nonce");
                g420 = v13;
            }
            // 0x2d1cc
            function_54cb0(v13, "asic_response.c", 15, "dump_nonce_info_all_core", 24, 538, 20, (int32_t)"\n asic nonce number for chain[%d]...\n");
            v14 = function_1e0f0();
            result = v14;
            v5 = v4;
            if (v14 >= 1) {
                // 0x2d218
                v15 = 1024 * v3 + (int32_t)&g422;
                v10 = 0;
                v7 = v4;
                v15 += 4;
                v16 = *(int32_t *)v15;
                v17 = v10 + 1;
                chars_printed = snprintf((char *)(v7 + v2), 256 - v7, "asic[%03d]=%-8d", v10, v16);
                v11 = function_1e100();
                v6 = function_5fd8c(v17, v11, (int32_t)"asic[%03d]=%-8d", v10);
                v8 = chars_printed + v7;
                if (v11 == 0) {
                    // 0x2d284
                    v12 = g420;
                    if (g420 == 0) {
                        // 0x2d308
                        v12 = function_536f4("bmminer_nonce");
                        g420 = v12;
                    }
                    // 0x2d294
                    function_1e100();
                    function_5faf8();
                    v6 = function_54cb0(v12, "asic_response.c", 15, "dump_nonce_info_all_core", 24, 544, 20, (int32_t)"domain %02d %s total=%-8u");
                    v8 = 0;
                }
                // 0x2d2f0
                v9 = v8;
                result = v6;
                v5 = v9;
                while (v17 != v14) {
                    // 0x2d240
                    v10 = v17;
                    v7 = v9;
                    v15 += 4;
                    v16 = *(int32_t *)v15;
                    v17 = v10 + 1;
                    chars_printed = snprintf((char *)(v7 + v2), 256 - v7, "asic[%03d]=%-8d", v10, v16);
                    v11 = function_1e100();
                    v6 = function_5fd8c(v17, v11, (int32_t)"asic[%03d]=%-8d", v10);
                    v8 = chars_printed + v7;
                    if (v11 == 0) {
                        // 0x2d284
                        v12 = g420;
                        if (g420 == 0) {
                            // 0x2d308
                            v12 = function_536f4("bmminer_nonce");
                            g420 = v12;
                        }
                        // 0x2d294
                        function_1e100();
                        function_5faf8();
                        v6 = function_54cb0(v12, "asic_response.c", 15, "dump_nonce_info_all_core", 24, 544, 20, (int32_t)"domain %02d %s total=%-8u");
                        v8 = 0;
                    }
                    // 0x2d2f0
                    v9 = v8;
                    result = v6;
                    v5 = v9;
                }
            }
        }
        // 0x2d1a8
        v18 = v3 + 1;
    }
    // 0x2d1b4
    return result;
}

// Address range: 0x2d340 - 0x2d67c
int32_t function_2d340(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    unsigned char v1 = *(char *)(a1 + 4); // 0x2d348
    int32_t result = 0; // 0x2d354
    int32_t v2 = a3; // 0x2d354
    int32_t str; // bp-2072, 0x2d340
    if (v1 != 0) {
        // 0x2d558
        snprintf((char *)&str, 2048, "List %s store can't %s() - from %s %s() line %d in %s %s():%d", (char *)(int32_t)v1, "k_alloc_items", (char *)a2, (char *)a3, a4, "klist.c", "k_alloc_items", 19);
        function_2e584(3, &str, 1);
        result = function_2a574();
        v2 = 1;
    }
    int32_t * v3 = (int32_t *)(a1 + 40); // 0x2d358
    int32_t v4 = *v3; // 0x2d358
    int32_t v5; // 0x2d340
    int32_t v6; // 0x2d340
    if (v4 < 1) {
        // 0x2d550
        v5 = v2;
        v6 = *(int32_t *)(a1 + 36);
    } else {
        uint32_t v7 = *(int32_t *)(a1 + 24); // 0x2d364
        if (v4 <= v7) {
            // 0x2d4bc
            return result;
        }
        int32_t v8 = *(int32_t *)(a1 + 36); // 0x2d370
        v5 = v7;
        v6 = v4 < v8 + v7 ? v4 - v7 : v8;
    }
    int32_t * v9 = (int32_t *)(a1 + 48); // 0x2d380
    int32_t * v10 = (int32_t *)(a1 + 52); // 0x2d384
    int32_t v11 = *v9 + 1; // 0x2d388
    *v9 = v11;
    int32_t v12 = function_1209c(*v10, 4 * v11, v5, v4); // 0x2d394
    *v10 = v12;
    int32_t v13 = v5; // 0x2d3a0
    int32_t v14 = v4; // 0x2d3a0
    if (v12 == 0) {
        // 0x2d5bc
        v14 = *v9;
        snprintf((char *)&str, 2048, "List %s item_memory failed to realloc count=%d in %s %s():%d", (char *)v14, v14, "klist.c", "k_alloc_items", 33);
        function_2e584(3, &str, 1);
        function_2a574();
        v13 = 1;
    }
    int32_t v15 = function_11eb0(v6, 16, v13, v14); // 0x2d3ac
    int32_t * v16; // 0x2d340
    if (v15 == 0) {
        int32_t v17 = *v3; // 0x2d614
        int32_t * v18 = (int32_t *)(a1 + 24);
        int32_t v19 = *v18; // 0x2d61c
        snprintf((char *)&str, 2048, "List %s failed to calloc %d new items - total was %d, limit was %d in %s %s():%d", (char *)v19, v6, v19, v17, "klist.c", "k_alloc_items", 38);
        function_2e584(3, &str, 1);
        function_2a574();
        v16 = v18;
    } else {
        // 0x2d3a4
        v16 = (int32_t *)(a1 + 24);
    }
    int32_t * v20 = v16;
    *(int32_t *)(4 * *v9 - 4 + *v10) = v15;
    *(int32_t *)(a1 + 28) = v6;
    *(int32_t *)(a1 + 32) = v6;
    *v20 = *v20 + v6;
    *(int32_t *)v15 = 0;
    *(int32_t *)(v15 + 4) = 0;
    *(int32_t *)(v15 + 8) = v15 + 16;
    int32_t v21 = v15 + 16 * v6;
    if (v6 >= 3) {
        int32_t v22 = v15 + 32;
        *(int32_t *)(v22 - 16) = 0;
        *(int32_t *)(v22 - 12) = v22 - 32;
        *(int32_t *)(v22 - 8) = v22;
        int32_t v23 = v22 + 16; // 0x2d40c
        while (v23 != v21) {
            // 0x2d400
            v22 = v23;
            *(int32_t *)(v22 - 16) = 0;
            *(int32_t *)(v22 - 12) = v22 - 32;
            *(int32_t *)(v22 - 8) = v22;
            v23 = v22 + 16;
        }
    }
    int32_t v24 = v21 - 16; // 0x2d424
    *(int32_t *)v24 = 0;
    *(int32_t *)(a1 + 12) = v15;
    int32_t v25 = v21 - 32; // 0x2d454
    *(int32_t *)(v21 - 12) = v25;
    *(int32_t *)(v21 - 8) = 0;
    if (*(char *)(a1 + 44) != 0) {
        *(int32_t *)(a1 + 16) = v24;
    }
    int32_t * v26 = (int32_t *)(a1 + 56); // 0x2d464
    int32_t * v27 = (int32_t *)(a1 + 60); // 0x2d468
    int32_t v28 = v15; // 0x2d4b0
    int32_t v29 = *v26 + 1; // 0x2d46c
    *v26 = v29;
    int32_t v30 = function_1209c(*v27, 4 * v29, v25, v24); // 0x2d478
    *v27 = v30;
    int32_t v31 = v25; // 0x2d484
    int32_t v32 = v24; // 0x2d484
    int32_t v33; // 0x2d4c4
    if (v30 == 0) {
        // 0x2d4c4
        v33 = *v26;
        snprintf((char *)&str, 2048, "List %s data_memory failed to realloc count=%d in %s %s():%d", NULL, v33, "klist.c", "k_alloc_items", 69);
        function_2e584(3, &str, 1);
        function_2a574();
        v31 = 1;
        v32 = 0;
    }
    int32_t v34 = function_11eb0(1, *(int32_t *)(a1 + 20), v31, v32); // 0x2d490
    int32_t * v35 = (int32_t *)(v28 + 12); // 0x2d498
    *v35 = v34;
    int32_t result2 = v34; // 0x2d49c
    if (v34 == 0) {
        // 0x2d508
        snprintf((char *)&str, 2048, "List %s failed to calloc item data in %s %s():%d", NULL, "klist.c", "k_alloc_items", 73);
        function_2e584(3, &str, 1);
        function_2a574();
        result2 = *v35;
    }
    int32_t v36 = *v27; // 0x2d4a4
    int32_t v37 = *v26 + 0x3fffffff; // 0x2d4a8
    *(int32_t *)(4 * v37 + v36) = result2;
    v28 += 8;
    while (v28 != 0) {
        // 0x2d464
        v29 = *v26 + 1;
        *v26 = v29;
        v30 = function_1209c(*v27, 4 * v29, v36, v37);
        *v27 = v30;
        v31 = v36;
        v32 = v37;
        if (v30 == 0) {
            // 0x2d4c4
            v33 = *v26;
            snprintf((char *)&str, 2048, "List %s data_memory failed to realloc count=%d in %s %s():%d", NULL, v33, "klist.c", "k_alloc_items", 69);
            function_2e584(3, &str, 1);
            function_2a574();
            v31 = 1;
            v32 = 0;
        }
        // 0x2d488
        v34 = function_11eb0(1, *(int32_t *)(a1 + 20), v31, v32);
        v35 = (int32_t *)(v28 + 12);
        *v35 = v34;
        result2 = v34;
        if (v34 == 0) {
            // 0x2d508
            snprintf((char *)&str, 2048, "List %s failed to calloc item data in %s %s():%d", NULL, "klist.c", "k_alloc_items", 73);
            function_2e584(3, &str, 1);
            function_2a574();
            result2 = *v35;
        }
        // 0x2d4a0
        v36 = *v27;
        v37 = *v26 + 0x3fffffff;
        *(int32_t *)(4 * v37 + v36) = result2;
        v28 += 8;
    }
    // 0x2d4bc
    return result2;
}

// Address range: 0x2d67c - 0x2d720
int32_t function_2d67c(int32_t a1) {
    // 0x2d67c
    int32_t v1; // 0x2d67c
    int32_t result = function_11eb0(1, 64, v1, v1); // 0x2d694
    int32_t v2 = result; // 0x2d6a0
    if (result == 0) {
        // 0x2d6d0
        int32_t str; // bp-2064, 0x2d67c
        snprintf((char *)&str, 2048, "Failed to calloc store for %s in %s %s():%d", NULL, "klist.c", "k_new_store", 85);
        function_2e584(3, &str, 1);
        v2 = function_2a574();
    }
    // 0x2d6a4
    *(int32_t *)result = v2;
    *(int32_t *)(result + 8) = *(int32_t *)(a1 + 8);
    *(char *)(result + 44) = *(char *)(a1 + 44);
    *(char *)(result + 4) = 1;
    return result;
}

// Address range: 0x2d724 - 0x2d9d0
int32_t function_2d724(int32_t a1, int32_t a2, int32_t a3, int32_t a4, char a5, int32_t a6, int32_t a7, int32_t a8) {
    char * v1; // 0x2d724
    int32_t v2; // 0x2d724
    int32_t v3; // 0x2d724
    int32_t str; // bp-2080, 0x2d724
    if (a3 < 1) {
        char * v4 = (char *)a1;
        snprintf((char *)&str, 2048, "Invalid new list %s with allocate %d must be > 0 in %s %s():%d", v4, a3, "klist.c", "_k_new_list", 100);
        function_2e584(3, &str, 1);
        function_2a574();
        v2 = 1;
        v3 = a1;
        v1 = v4;
        if (a4 < 0) {
            goto lab_0x2d838;
        } else {
            goto lab_0x2d74c;
        }
    } else {
        // 0x2d744
        v2 = a3;
        v3 = a4;
        if (a4 < 0) {
            // 0x2d744
            v1 = (char *)a1;
            goto lab_0x2d838;
        } else {
            goto lab_0x2d74c;
        }
    }
  lab_0x2d838:;
    char * str2 = (char *)&str;
    snprintf(str2, 2048, "Invalid new list %s with limit %d must be >= 0 in %s %s():%d", v1, a4, "klist.c", "_k_new_list", 103);
    function_2e584(3, &str, 1);
    function_2a574();
    v2 = 1;
    v3 = a1;
    goto lab_0x2d74c;
  lab_0x2d74c:;
    int32_t result = function_11eb0(1, 64, v2, v3); // 0x2d754
    int32_t v5 = v2; // 0x2d75c
    if (result == 0) {
        // 0x2d8e0
        snprintf((char *)&str, 2048, "Failed to calloc list %s in %s %s():%d", (char *)a1, "klist.c", "_k_new_list", 107);
        function_2e584(3, &str, 1);
        function_2a574();
        v5 = 1;
    }
    // 0x2d760
    *(char *)(result + 4) = 0;
    int32_t v6 = function_11eb0(1, 56, v5, 0); // 0x2d770
    int32_t * v7 = (int32_t *)(result + 8); // 0x2d77c
    *v7 = v6;
    int32_t v8 = v6; // 0x2d780
    if (v6 == 0) {
        // 0x2d88c
        snprintf((char *)&str, 2048, "Failed to calloc lock for list %s in %s %s():%d", (char *)a1, "klist.c", "_k_new_list", 113);
        function_2e584(3, &str, 1);
        function_2a574();
        v8 = *v7;
    }
    // 0x2d784
    if (function_11fdc(v8, 0) != 0) {
        int32_t v9 = *__errno_location(); // 0x2d998
        snprintf((char *)&str, 2048, "Failed to pthread_mutex_init errno=%d in %s %s():%d", v9, "klist.c", "_k_new_list", 115);
        function_2e584(3, &str, 1);
        function_2a574();
    }
    // 0x2d798
    if (function_11f70(v8 + 24, 0) != 0) {
        int32_t v10 = *__errno_location(); // 0x2d948
        snprintf((char *)&str, 2048, "Failed to pthread_rwlock_init errno=%d in %s %s():%d", v10, "klist.c", "_k_new_list", 115);
        function_2e584(3, &str, 1);
        function_2a574();
    }
    // 0x2d7ac
    *(int32_t *)result = a1;
    *(int32_t *)(result + 20) = a2;
    *(int32_t *)(result + 36) = a3;
    *(int32_t *)(result + 40) = a4;
    *(char *)(result + 44) = a5;
    function_2d340(result, a6, a7, a8);
    return result;
}

// Address range: 0x2d9d4 - 0x2da5c
int32_t function_2d9d4(int32_t a1) {
    int32_t * v1 = (int32_t *)(a1 + 12); // 0x2d9dc
    int32_t v2 = *v1; // 0x2d9dc
    int32_t result = v2; // 0x2d9e4
    if (v2 == 0) {
        // 0x2da20
        if (*(char *)(a1 + 4) != 0) {
            // 0x2da2c
            return 0;
        }
        // 0x2da48
        int32_t v3; // 0x2d9d4
        function_2d340(a1, v3, v3, v3);
        result = *v1;
        if (result == 0) {
            // 0x2da2c
            return 0;
        }
    }
    int32_t * v4 = (int32_t *)(result + 8); // 0x2d9e8
    int32_t v5 = *v4; // 0x2d9e8
    *v1 = v5;
    if (v5 == 0) {
        // 0x2da38
        if (*(char *)(a1 + 44) != 0) {
            *(int32_t *)(a1 + 16) = 0;
        }
    } else {
        // 0x2d9f8
        *(int32_t *)(v5 + 4) = 0;
    }
    // 0x2da00
    *v4 = 0;
    *(int32_t *)(result + 4) = 0;
    int32_t * v6 = (int32_t *)(a1 + 28); // 0x2da10
    *v6 = *v6 - 1;
    return result;
}

// Address range: 0x2da5c - 0x2da88
int32_t function_2da5c(int32_t a1) {
    int32_t result = function_2d9d4(a1); // 0x2da64
    if (result != 0) {
        // 0x2da70
        memset((int32_t *)*(int32_t *)(result + 12), 0, *(int32_t *)(a1 + 20));
    }
    // 0x2da80
    return result;
}

// Address range: 0x2da88 - 0x2db4c
int32_t function_2da88(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x2da88
    if (*(char *)(a1 + 44) == 0) {
        // 0x2daec
        int32_t str; // bp-2064, 0x2da88
        snprintf((char *)&str, 2048, "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d", NULL, "_k_unlink_tail", (char *)a2, (char *)a3, a4, "klist.c", "_k_unlink_tail", 181);
        function_2e584(3, &str, 1);
        function_2a574();
    }
    int32_t * v1 = (int32_t *)(a1 + 16); // 0x2daa4
    int32_t result = *v1; // 0x2daa4
    if (result == 0) {
        // 0x2dae0
        return result;
    }
    int32_t * v2 = (int32_t *)(result + 4); // 0x2dab0
    int32_t v3 = *v2; // 0x2dab0
    *v1 = v3;
    if (v3 == 0) {
        *(int32_t *)(a1 + 12) = 0;
    } else {
        // .critedge
        *(int32_t *)(v3 + 8) = 0;
    }
    *(int32_t *)(result + 8) = 0;
    *v2 = 0;
    int32_t * v4 = (int32_t *)(a1 + 28); // 0x2dad4
    *v4 = *v4 - 1;
    // 0x2dae0
    return result;
}

// Address range: 0x2db50 - 0x2dc20
int32_t function_2db50(int32_t a1, int32_t result, int32_t a3, int32_t a4, int32_t a5) {
    // 0x2db50
    *(int32_t *)(result + 4) = 0;
    int32_t * v1 = (int32_t *)(a1 + 12); // 0x2dbd8
    *(int32_t *)(result + 8) = *v1;
    int32_t v2 = *v1; // 0x2dbe0
    if (v2 != 0) {
        *(int32_t *)(v2 + 4) = result;
    }
    *v1 = result;
    int32_t v3; // 0x2dc08
    uint64_t v4; // 0x2dc08
    if (*(char *)(a1 + 44) == 0) {
        // 0x2dc08
        v3 = a1 + 28;
        v4 = *(int64_t *)v3;
        *(int32_t *)v3 = (int32_t)(v4 / 0x100000000) + 1;
        *(int32_t *)(a1 + 32) = (int32_t)v4 + 1;
        return result;
    }
    int32_t * v5 = (int32_t *)(a1 + 16); // 0x2dbfc
    if (*v5 == 0) {
        *v5 = result;
    }
    // 0x2dc08
    v3 = a1 + 28;
    v4 = *(int64_t *)v3;
    *(int32_t *)v3 = (int32_t)(v4 / 0x100000000) + 1;
    *(int32_t *)(a1 + 32) = (int32_t)v4 + 1;
    return result;
}

// Address range: 0x2dc24 - 0x2dd6c
int32_t function_2dc24(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t v1 = a2; // 0x2dc4c
    int32_t str; // bp-2072, 0x2dc24
    if (a2 != a1) {
        // 0x2dc50
        snprintf((char *)&str, 2048, "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d", (char *)a1, "_k_add_tail", (char *)a2, (char *)a3, (char *)a4, a5, "klist.c", "_k_add_tail", 236);
        function_2e584(3, &str, 1);
        v1 = function_2a574();
    }
    int32_t result = v1; // 0x2dcbc
    if (*(char *)(a1 + 44) == 0) {
        // 0x2dd08
        snprintf((char *)&str, 2048, "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d", "_k_add_tail", "_k_add_tail", (char *)a3, (char *)a4, a5, "klist.c", "_k_add_tail", 241);
        function_2e584(3, &str, 1);
        result = function_2a574();
    }
    int32_t * v2 = (int32_t *)(a1 + 16); // 0x2dcc0
    *(int32_t *)(a2 + 8) = 0;
    *(int32_t *)(a2 + 4) = *v2;
    int32_t v3 = *v2; // 0x2dcd0
    if (v3 != 0) {
        *(int32_t *)(v3 + 8) = a2;
    }
    int32_t * v4 = (int32_t *)(a1 + 12); // 0x2dcdc
    *v2 = a2;
    int32_t v5 = a1 + 28; // 0x2dce8
    uint64_t v6 = *(int64_t *)v5; // 0x2dce8
    if (*v4 == 0) {
        *v4 = a2;
    }
    *(int32_t *)v5 = (int32_t)(v6 / 0x100000000) + 1;
    *(int32_t *)(a1 + 32) = (int32_t)v6 + 1;
    return result;
}

// Address range: 0x2dd70 - 0x2deb4
int32_t function_2dd70(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    int32_t v1 = a2; // 0x2dd98
    int32_t str; // bp-2072, 0x2dd70
    if (a2 != a1) {
        // 0x2dd9c
        snprintf((char *)&str, 2048, "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d", (char *)a1, "_k_insert_before", (char *)a2, (char *)a4, (char *)a5, a6, "klist.c", "_k_insert_before", 262);
        function_2e584(3, &str, 1);
        v1 = function_2a574();
    }
    int32_t result = v1; // 0x2de08
    if (a3 == 0) {
        // 0x2de48
        snprintf((char *)&str, 2048, "%s() (%s) can't before a null item - from %s %s() line %d in %s %s():%d", "_k_insert_before", (char *)v1, (char *)a4, (char *)a5, a6, "klist.c", "_k_insert_before", 267);
        function_2e584(3, &str, 1);
        result = function_2a574();
    }
    // 0x2de0c
    *(int32_t *)(a2 + 8) = a3;
    int32_t * v2 = (int32_t *)(a3 + 4); // 0x2de10
    *(int32_t *)(a2 + 4) = *v2;
    int32_t v3 = *v2; // 0x2de18
    if (v3 == 0) {
        // .critedge
        *(int32_t *)(a1 + 12) = a2;
    } else {
        *(int32_t *)(v3 + 8) = a2;
    }
    *v2 = a2;
    int32_t v4 = a1 + 28; // 0x2de2c
    uint64_t v5 = *(int64_t *)v4; // 0x2de2c
    *(int32_t *)v4 = (int32_t)(v5 / 0x100000000) + 1;
    *(int32_t *)(a1 + 32) = (int32_t)v5 + 1;
    return result;
}

// Address range: 0x2deb8 - 0x2e008
int32_t function_2deb8(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    int32_t v1 = a2; // 0x2dee0
    int32_t str; // bp-2072, 0x2deb8
    if (a2 != a1) {
        // 0x2dee4
        snprintf((char *)&str, 2048, "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d", (char *)a1, "_k_insert_after", (char *)a2, (char *)a4, (char *)a5, a6, "klist.c", "_k_insert_after", 286);
        function_2e584(3, &str, 1);
        v1 = function_2a574();
    }
    int32_t result = v1; // 0x2df50
    if (a3 == 0) {
        // 0x2df9c
        snprintf((char *)&str, 2048, "%s() (%s) can't after a null item - from %s %s() line %d in %s %s():%d", "_k_insert_after", (char *)v1, (char *)a4, (char *)a5, a6, "klist.c", "_k_insert_after", 291);
        function_2e584(3, &str, 1);
        result = function_2a574();
    }
    // 0x2df54
    *(int32_t *)(a2 + 4) = a3;
    int32_t * v2 = (int32_t *)(a3 + 8); // 0x2df58
    *(int32_t *)(a2 + 8) = *v2;
    int32_t v3 = *v2; // 0x2df60
    if (v3 == 0) {
        // 0x2df70
        if (*(char *)(a1 + 44) != 0) {
            *(int32_t *)(a1 + 16) = a2;
        }
    } else {
        *(int32_t *)(v3 + 4) = a2;
    }
    // 0x2df7c
    *v2 = a2;
    int32_t v4 = a1 + 28; // 0x2df80
    uint64_t v5 = *(int64_t *)v4; // 0x2df80
    *(int32_t *)v4 = (int32_t)(v5 / 0x100000000) + 1;
    *(int32_t *)(a1 + 32) = (int32_t)v5 + 1;
    return result;
}

// Address range: 0x2e00c - 0x2e0f4
int32_t function_2e00c(int32_t a1, int32_t result, int32_t a3, int32_t a4, int32_t a5) {
    int32_t v1 = result + 4; // 0x2e08c
    uint64_t v2 = *(int64_t *)v1; // 0x2e08c
    int32_t v3 = v2; // 0x2e08c
    int32_t v4 = v2 / 0x100000000; // 0x2e08c
    int32_t v5 = v3; // 0x2e094
    if (v4 != 0) {
        *(int32_t *)(v4 + 8) = v3;
        v5 = *(int32_t *)(result + 8);
    }
    // .critedge
    if (v5 != 0) {
        *(int32_t *)(v5 + 4) = *(int32_t *)v1;
    }
    int32_t * v6 = (int32_t *)(a1 + 12); // 0x2e0a8
    if (*v6 == result) {
        *v6 = *(int32_t *)(result + 8);
    }
    if (*(char *)(a1 + 44) != 0) {
        int32_t * v7 = (int32_t *)(a1 + 16); // 0x2e0c4
        if (*v7 == result) {
            *v7 = *(int32_t *)v1;
        }
    }
    // 0x2e0d4
    *(int32_t *)(result + 8) = 0;
    *(int32_t *)v1 = 0;
    int32_t * v8 = (int32_t *)(a1 + 28); // 0x2e0e0
    *v8 = *v8 - 1;
    return result;
}

// Address range: 0x2e0f8 - 0x2e264
int32_t function_2e0f8(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t v1 = a1; // 0x2e11c
    int32_t str; // bp-2072, 0x2e0f8
    if (a1 != a2) {
        // 0x2e120
        snprintf((char *)&str, 2048, "List %s can't %s() to a %s list - from %s %s() line %d in %s %s():%d", (char *)a1, "_k_list_transfer_to_head", (char *)a2, (char *)a3, (char *)a4, a5, "klist.c", "_k_list_transfer_to_head", 338);
        function_2e584(3, &str, 1);
        v1 = function_2a574();
    }
    int32_t result = v1; // 0x2e18c
    if (*(char *)(a1 + 44) == 0) {
        // 0x2e200
        snprintf((char *)&str, 2048, "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d", "_k_list_transfer_to_head", "_k_list_transfer_to_head", (char *)a3, (char *)a4, a5, "klist.c", "_k_list_transfer_to_head", 343);
        function_2e584(3, &str, 1);
        result = function_2a574();
    }
    int32_t * v2 = (int32_t *)(a1 + 12); // 0x2e190
    if (*v2 == 0) {
        // 0x2e1f8
        return result;
    }
    int32_t * v3 = (int32_t *)(a2 + 12); // 0x2e19c
    int32_t v4 = *v3; // 0x2e19c
    int32_t * v5 = (int32_t *)(a1 + 16); // 0x2e1a0
    int32_t v6 = *v5; // 0x2e1a0
    int32_t v7; // 0x2e0f8
    if (v4 == 0) {
        // .critedge
        *(int32_t *)(a2 + 16) = v6;
        v7 = 0;
    } else {
        // .critedge2
        *(int32_t *)(v4 + 4) = v6;
        v7 = *v3;
    }
    *(int32_t *)(*v5 + 8) = v7;
    *v3 = *v2;
    *v5 = 0;
    int32_t * v8 = (int32_t *)(a1 + 28); // 0x2e1cc
    *v2 = 0;
    int32_t * v9 = (int32_t *)(a2 + 28); // 0x2e1d4
    *v9 = *v9 + *v8;
    *v8 = 0;
    int32_t * v10 = (int32_t *)(a1 + 32); // 0x2e1e4
    int32_t * v11 = (int32_t *)(a2 + 32); // 0x2e1e8
    *v11 = *v11 + *v10;
    *v10 = 0;
    // 0x2e1f8
    return result;
}

// Address range: 0x2e268 - 0x2e3d0
int32_t function_2e268(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t v1 = a1; // 0x2e28c
    int32_t str; // bp-2072, 0x2e268
    if (a1 != a2) {
        // 0x2e290
        snprintf((char *)&str, 2048, "List %s can't %s() to a %s list - from %s %s() line %d in %s %s():%d", (char *)a1, "_k_list_transfer_to_tail", (char *)a2, (char *)a3, (char *)a4, a5, "klist.c", "_k_list_transfer_to_tail", 368);
        function_2e584(3, &str, 1);
        v1 = function_2a574();
    }
    int32_t result = v1; // 0x2e2fc
    if (*(char *)(a1 + 44) == 0) {
        // 0x2e36c
        snprintf((char *)&str, 2048, "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d", "_k_list_transfer_to_tail", "_k_list_transfer_to_tail", (char *)a3, (char *)a4, a5, "klist.c", "_k_list_transfer_to_tail", 373);
        function_2e584(3, &str, 1);
        result = function_2a574();
    }
    int32_t * v2 = (int32_t *)(a1 + 12); // 0x2e300
    int32_t v3 = *v2; // 0x2e300
    if (v3 == 0) {
        // 0x2e364
        return result;
    }
    int32_t * v4 = (int32_t *)(a2 + 16); // 0x2e30c
    int32_t v5 = *v4; // 0x2e30c
    int32_t v6; // 0x2e268
    if (v5 == 0) {
        // .critedge
        *(int32_t *)(a2 + 12) = v3;
        v6 = 0;
    } else {
        // .critedge2
        *(int32_t *)(v5 + 8) = v3;
        v6 = *v4;
    }
    *(int32_t *)(*v2 + 4) = v6;
    int32_t * v7 = (int32_t *)(a1 + 16); // 0x2e32c
    *v4 = *v7;
    *v7 = 0;
    int32_t * v8 = (int32_t *)(a1 + 28); // 0x2e338
    *v2 = 0;
    int32_t * v9 = (int32_t *)(a2 + 28); // 0x2e340
    *v9 = *v9 + *v8;
    *v8 = 0;
    int32_t * v10 = (int32_t *)(a1 + 32); // 0x2e350
    int32_t * v11 = (int32_t *)(a2 + 32); // 0x2e354
    *v11 = *v11 + *v10;
    *v10 = 0;
    // 0x2e364
    return result;
}

// Address range: 0x2e3d4 - 0x2e4ec
int32_t function_2e3d4(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    unsigned char v1 = *(char *)(a1 + 4); // 0x2e3dc
    int32_t v2 = a2; // 0x2e3ec
    int32_t v3 = a3; // 0x2e3ec
    if (v1 != 0) {
        // 0x2e48c
        int32_t str; // bp-2064, 0x2e3d4
        snprintf((char *)&str, 2048, "List %s can't %s() a store - from %s %s() line %d in %s %s():%d", (char *)(int32_t)v1, "_k_free_list", (char *)a2, (char *)a3, a4, "klist.c", "_k_free_list", 400);
        function_2e584(3, &str, 1);
        function_2a574();
        v2 = &str;
        v3 = 1;
    }
    int32_t * v4 = (int32_t *)(a1 + 48); // 0x2e3f0
    uint32_t v5 = *v4; // 0x2e3f0
    int32_t * v6 = (int32_t *)(a1 + 52);
    int32_t v7 = v5; // 0x2e3f8
    if (v5 >= 1) {
        int32_t v8 = 0;
        int32_t v9 = *v6; // 0x2e400
        int32_t v10 = v8 + 1; // 0x2e408
        free(*(int32_t *)(v9 + 4 * v8), v2, v3, v9);
        uint32_t v11 = *v4; // 0x2e410
        v7 = v11;
        while (v11 > v10) {
            // 0x2e400
            v8 = v10;
            v9 = *v6;
            v10 = v8 + 1;
            free(*(int32_t *)(v9 + 4 * v8), v2, v3, v9);
            v11 = *v4;
            v7 = v11;
        }
    }
    // 0x2e41c
    free(*v6, v2, v3, v7);
    int32_t * v12 = (int32_t *)(a1 + 56); // 0x2e424
    uint32_t v13 = *v12; // 0x2e424
    int32_t * v14 = (int32_t *)(a1 + 60);
    int32_t v15 = v13; // 0x2e42c
    if (v13 >= 1) {
        int32_t v16 = 0;
        int32_t v17 = *v14; // 0x2e434
        int32_t v18 = v16 + 1; // 0x2e43c
        free(*(int32_t *)(v17 + 4 * v16), v2, v3, v17);
        uint32_t v19 = *v12; // 0x2e444
        v15 = v19;
        while (v19 > v18) {
            // 0x2e434
            v16 = v18;
            v17 = *v14;
            v18 = v16 + 1;
            free(*(int32_t *)(v17 + 4 * v16), v2, v3, v17);
            v19 = *v12;
            v15 = v19;
        }
    }
    // 0x2e450
    free(*v14, v2, v3, v15);
    int32_t * v20 = (int32_t *)(a1 + 8); // 0x2e458
    int32_t v21 = *v20; // 0x2e458
    pthread_rwlock_destroy((int32_t *)(v21 + 24));
    function_11f4c(v21);
    free(*v20, v2, v3, v15);
    free(a1, v2, v3, v15);
    return 0;
}

// Address range: 0x2e4f0 - 0x2e580
int32_t function_2e4f0(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = a2; // 0x2e508
    int32_t v2 = a3; // 0x2e508
    int32_t v3 = a4; // 0x2e508
    if (*(char *)(a1 + 4) == 0) {
        // 0x2e50c
        int32_t str; // bp-2064, 0x2e4f0
        snprintf((char *)&str, 2048, "Store %s can't %s() the list - from %s %s() line %d in %s %s():%d", NULL, "_k_free_store", (char *)a2, (char *)a3, a4, "klist.c", "_k_free_store", 424);
        function_2e584(3, &str, 1);
        function_2a574();
        v1 = &str;
        v2 = 1;
        v3 = 0;
    }
    // 0x2e568
    free(a1, v1, v2, v3);
    return 0;
}

// Address range: 0x2e584 - 0x2e828
int32_t function_2e584(int32_t a1, int32_t * str2, int32_t a3) {
    // 0x2e584
    if (*(char *)&g221 != 0) {
        // 0x2e5a8
        syslog(a1 | 128, "%s", str2);
        int32_t v1 = g52; // 0x2e5cc
        if (g52 == 0) {
            // 0x2e7e0
            v1 = function_536f4("bmminer_miner");
            g52 = v1;
        }
        // 0x2e610
        return function_54cb0(v1, "logging.c", 9, "_applog", 7, 71, 60, (int32_t)"%s");
    }
    int32_t v2 = 0; // bp-104, 0x2e620
    function_302a0(&v2);
    int32_t timep = v2; // bp-108, 0x2e650
    struct tm * time_info = localtime(&timep); // 0x2e658
    int32_t v3 = (int32_t)time_info; // 0x2e658
    int32_t v4 = *(int32_t *)(v3 + 20); // 0x2e664
    int32_t v5 = time_info->e0; // 0x2e66c
    int32_t v6 = *(int32_t *)(v3 + 4); // 0x2e680
    int32_t v7 = *(int32_t *)(v3 + 8); // 0x2e690
    int32_t v8 = *(int32_t *)(v3 + 12); // 0x2e698
    int32_t v9 = *(int32_t *)(v3 + 16); // 0x2e6a0
    int32_t str; // bp-96, 0x2e584
    snprintf((char *)&str, 64, " [%d-%02d-%02d %02d:%02d:%02d.%03d] ", v4 + 1900, v9 + 1, v8, v7, v6, v5, 0);
    if (isatty(fileno(g316)) == 0) {
        // 0x2e7bc
        fprintf(g316, "%s%s\n", &str, str2);
        function_11f58((int32_t)g316);
    }
    // 0x2e6c4
    struct _IO_FILE * stream; // 0x2e810
    if (*(char *)&g53 == 0) {
        goto lab_0x2e73c;
    } else {
        // 0x2e6d8
        stream = g54;
        if (g54 == NULL) {
            // 0x2e808
            stream = fopen64((char *)&g57, (char *)&g55);
            g54 = stream;
            if (stream == NULL) {
                goto lab_0x2e73c;
            } else {
                goto lab_0x2e6e4;
            }
        } else {
            goto lab_0x2e6e4;
        }
    }
  lab_0x2e73c:;
    int32_t v10 = g52; // 0x2e744
    if (g52 == 0) {
        int32_t v11 = function_536f4("bmminer_miner"); // 0x2e7fc
        g52 = v11;
        v10 = v11;
    }
    int32_t result = function_54cb0(v10, "logging.c", 9, "_applog", 7, 117, 60, (int32_t)"%s"); // 0x2e780
    if (a1 == 3 || g213 % 2 == 0) {
        // 0x2e7a4
        return function_2e92c(&str, (int32_t)str2, a3);
    }
    // 0x2e610
    return result;
  lab_0x2e6e4:
    // 0x2e6e4
    fwrite(&str, strlen((char *)&str), 1, stream);
    fwrite(str2, strlen((char *)str2), 1, g54);
    fwrite((int32_t *)&g261, 1, 1, g54);
    function_11f58((int32_t)g54);
    goto lab_0x2e73c;
}

// Address range: 0x2e828 - 0x2e8a0
int32_t function_2e828(int32_t a1) {
    // 0x2e828
    int32_t v1; // 0x2e828
    if (function_11ea4(&g229, v1, v1, v1) == 0) {
        // 0x2e848
        return 0;
    }
    int32_t v2 = *__errno_location(); // 0x2e864
    int32_t str; // bp-2056, 0x2e828
    snprintf((char *)&str, 2048, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", v2, "logging.c", "my_log_curses", a1);
    function_2e584(3, &str, 1);
    return function_2a574();
}

// Address range: 0x2e8a4 - 0x2e928
int32_t function_2e8a4(void) {
    // 0x2e8a4
    int32_t v1; // 0x2e8a4
    if (function_11f94(&g229, v1, v1, v1) == 0) {
        // 0x2e8c4
        return 0;
    }
    int32_t v2 = *__errno_location(); // 0x2e8e8
    int32_t str; // bp-2056, 0x2e8a4
    snprintf((char *)&str, 2048, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", v2, "logging.c", "my_log_curses", 53);
    function_2e584(3, &str, 1);
    return function_2a574();
}

// Address range: 0x2e92c - 0x2e9a4
int32_t function_2e92c(int32_t * a1, int32_t a2, int32_t a3) {
    if (a3 != 0) {
        // 0x2e97c
        function_11ff4(&g229);
        function_2e828(42);
        function_2f250();
    }
    // 0x2e948
    function_2e8a4();
    function_11f34("%s%s%s", a1, a2, (int32_t)"                    \n");
    function_2e828(55);
    return function_2f250();
}

// Address range: 0x2e9a4 - 0x2ea54
int32_t function_2e9a4(int32_t a1, int32_t a2, int32_t a3) {
    // 0x2e9a4
    if (*(char *)&g221 != 0) {
        // 0x2ea1c
        syslog(a1 | 128, "%s", (char *)a2);
        return &g488;
    }
    // 0x2e9c0
    if (isatty(fileno(g316)) == 0) {
        // 0x2ea34
        fprintf(g316, "%s\n");
        function_11f58((int32_t)g316);
    }
    // 0x2e9e4
    if (a1 == 3 || g213 % 2 == 0) {
        // 0x2ea04
        return function_2e92c((int32_t *)&g260, a2, a3);
    }
    return 1;
}

// Address range: 0x2ea54 - 0x2ee1c
int32_t function_2ea54(int32_t a1, int32_t * str, int32_t a3) {
    // 0x2ea54
    struct _IO_FILE * stream2; // 0x2ee04
    if (strlen((char *)&g58) + 1 + strlen((char *)str) < 2048) {
        goto lab_0x2eb0c;
    } else {
        // 0x2ea98
        if (*(char *)&g221 == 0) {
            // 0x2ec88
            if (isatty(fileno(g316)) == 0) {
                // 0x2ed74
                fputs((char *)&g58, g316);
                function_11f58((int32_t)g316);
            }
            // 0x2eca4
            if (*(char *)&g53 == 0) {
                goto lab_0x2ece0;
            } else {
                // 0x2ecb0
                stream2 = g54;
                if (g54 == NULL) {
                    // 0x2edfc
                    stream2 = fopen64((char *)&g57, (char *)&g55);
                    g54 = stream2;
                    if (stream2 == NULL) {
                        goto lab_0x2ece0;
                    } else {
                        goto lab_0x2ecbc;
                    }
                } else {
                    goto lab_0x2ecbc;
                }
            }
        } else {
            // 0x2eaac
            syslog(a1 | 128, "%s", (char *)&g58);
            int32_t v1 = g59; // 0x2eac8
            if (g59 == 0) {
                // 0x2edb4
                v1 = function_536f4("bmminer_miner");
                g59 = v1;
            }
            // 0x2eacc
            function_54cb0(v1, "logging.c", 9, "_applawlog", 10, 167, 60, (int32_t)"%s");
            // 0x2eb04
            *(char *)&g58 = 0;
            goto lab_0x2eb0c;
        }
    }
  lab_0x2eb0c:;
    int32_t dest_str = (int32_t)strcat((char *)&g58, (char *)str); // 0x2eb14
    int32_t v2 = (int32_t)&g58; // 0x2eb1c
    while (true) {
      lab_0x2eb28:;
        char v3 = *(char *)v2; // 0x2eb28
        switch (v3) {
            case 13: {
                goto lab_0x2eb38;
            }
            case 10: {
                goto lab_0x2eb38;
            }
            default: {
                // 0x2eb20
                v2++;
                if (v3 == 0) {
                    // 0x2ebac
                    return dest_str;
                }
                goto lab_0x2eb28;
            }
        }
    }
  lab_0x2eb38:
    // 0x2eb38
    if (*(char *)&g221 != 0) {
        // 0x2eb4c
        syslog(a1 | 128, "%s", (char *)&g58);
        int32_t v4 = g59; // 0x2eb68
        if (g59 == 0) {
            // 0x2ed8c
            v4 = function_536f4("bmminer_miner");
            g59 = v4;
        }
        int32_t result = function_54cb0(v4, "logging.c", 9, "_applawlog", 10, 205, 60, (int32_t)"%s");
        *(char *)&g58 = 0;
        // 0x2ebac
        return result;
    }
    // 0x2ebb4
    if (isatty(fileno(g316)) == 0) {
        // 0x2ed5c
        fputs((char *)&g58, g316);
        function_11f58((int32_t)g316);
    }
    // 0x2ebd0
    struct _IO_FILE * stream; // 0x2ede4
    if (*(char *)&g53 == 0) {
        goto lab_0x2ec0c;
    } else {
        // 0x2ebdc
        stream = g54;
        if (g54 == NULL) {
            // 0x2eddc
            stream = fopen64((char *)&g57, (char *)&g55);
            g54 = stream;
            if (stream == NULL) {
                goto lab_0x2ec0c;
            } else {
                goto lab_0x2ebe8;
            }
        } else {
            goto lab_0x2ebe8;
        }
    }
  lab_0x2ec0c:;
    int32_t v5 = g59; // 0x2ec14
    if (g59 == 0) {
        int32_t v6 = function_536f4("bmminer_miner"); // 0x2eda8
        g59 = v6;
        v5 = v6;
    }
    int32_t result2 = function_54cb0(v5, "logging.c", 9, "_applawlog", 10, 233, 60, (int32_t)"%s"); // 0x2ec6c
    if (a1 == 3 || g213 % 2 == 0) {
        int32_t v7 = function_2e92c((int32_t *)&g260, (int32_t)&g58, a3); // 0x2ec80
        result2 = v7;
    }
    // 0x2eba4
    *(char *)&g58 = 0;
    // 0x2ebac
    return result2;
  lab_0x2ebe8:
    // 0x2ebe8
    fwrite((int32_t *)&g58, strlen((char *)&g58), 1, stream);
    function_11f58((int32_t)g54);
    goto lab_0x2ec0c;
  lab_0x2ece0:;
    int32_t v8 = g59; // 0x2ece8
    if (g59 == 0) {
        int32_t v9 = function_536f4("bmminer_miner"); // 0x2edd0
        g59 = v9;
        v8 = v9;
    }
    // 0x2ecec
    function_54cb0(v8, "logging.c", 9, "_applawlog", 10, 195, 60, (int32_t)"%s");
    if (a1 == 3 || g213 % 2 == 0) {
        // 0x2ed44
        function_2e92c((int32_t *)&g260, (int32_t)&g58, a3);
    }
    // 0x2eb04
    *(char *)&g58 = 0;
    goto lab_0x2eb0c;
  lab_0x2ecbc:
    // 0x2ecbc
    fwrite((int32_t *)&g58, strlen((char *)&g58), 1, stream2);
    function_11f58((int32_t)g54);
    goto lab_0x2ece0;
}

// Address range: 0x2ee28 - 0x2f024
// Used cryptographic patterns:
//  - SHA256_Hash_constant_words_K__0x428a2f98_ (32-bit, little endian)
int32_t function_2ee28(int32_t result, int32_t a2, int32_t a3) {
    // 0x2ee28
    if (a3 < 1) {
        // 0x2f01c
        return result;
    }
    int32_t v1 = result + 136; // 0x2ee48
    int32_t v2 = result + 168; // bp-332, 0x2ee5c
    int32_t v3; // bp-296, 0x2ee28
    int32_t v4 = &v3; // 0x2ee68
    int32_t v5 = &v2; // 0x2eee8
    int32_t v6 = a2; // 0x2ee5c
    int32_t v7; // 0x2ee28
    int32_t v8; // bp-300, 0x2ee28
    while (true) {
      lab_0x2ee60:;
        int32_t v9 = &v8; // 0x2ee68
        int32_t v10 = v6; // 0x2ee68
        while (true) {
            unsigned char v11 = *(char *)(v10 + 1); // 0x2ee6c
            unsigned char v12 = *(char *)(v10 + 2); // 0x2ee70
            unsigned char v13 = *(char *)(v10 + 3); // 0x2ee74
            unsigned char v14 = *(char *)v10; // 0x2ee78
            v9 += 4;
            *(int32_t *)v9 = 256 * (int32_t)v12 | 0x10000 * (int32_t)v11 | (int32_t)v13 | 0x1000000 * (int32_t)v14;
            v10 += 4;
            v7 = v4;
            int32_t v15; // bp-236, 0x2ee28
            if (v9 == (int32_t)&v15) {
                goto lab_0x2ee9c;
            }
        }
        goto lab_0x2eee4;
    }
  lab_0x2f01c:;
    // 0x2f01c
    int32_t result2; // 0x2ee28
    return result2;
  lab_0x2ee9c:;
    uint32_t v16 = *(int32_t *)(v7 + 56); // 0x2ee9c
    int32_t v17 = v7 + 4; // 0x2eea4
    uint32_t v18 = *(int32_t *)v17; // 0x2eea4
    int32_t v19 = *(int32_t *)(v7 + 36); // 0x2eeac
    int32_t v20 = *(int32_t *)v7; // 0x2eeb0
    *(int32_t *)(v7 + 64) = v20 + v19 + ((v16 / 0x20000 | 0x8000 * v16) ^ v16 / 1024 ^ (v16 / 0x80000 | 0x2000 * v16)) + ((v18 / 128 | 0x2000000 * v18) ^ v18 / 8 ^ (v18 / 0x40000 | 0x4000 * v18));
    v7 = v17;
    int32_t v21; // bp-104, 0x2ee28
    if (v17 == (int32_t)&v21) {
        goto lab_0x2eee4;
    } else {
        goto lab_0x2ee9c;
    }
  lab_0x2eee4:;
    int32_t v22 = v1 + 4; // 0x2eef8
    int32_t v23 = v5 + 4; // 0x2ef00
    *(int32_t *)v23 = *(int32_t *)v1;
    int32_t v24 = v22; // 0x2ef04
    int32_t v25 = v23; // 0x2ef04
    while (v2 != v22) {
        // 0x2eef8
        v22 = v24 + 4;
        v23 = v25 + 4;
        *(int32_t *)v23 = *(int32_t *)v24;
        v24 = v22;
        v25 = v23;
    }
    int32_t v26 = 0; // 0x2ef30
    int32_t v27; // 0x2ee28
    int32_t v28 = v27;
    int32_t v29; // 0x2ee28
    int32_t v30 = v29;
    int32_t v31; // 0x2ee28
    int32_t v32 = v31;
    int32_t v33; // 0x2ee28
    int32_t v34 = v33;
    int32_t v35; // 0x2ee28
    uint32_t v36 = v35;
    int32_t v37; // 0x2ee28
    uint32_t v38 = v37;
    int32_t v39 = 4 * v26; // 0x2ef70
    int32_t v40 = *(int32_t *)(v39 + v4); // 0x2ef70
    int32_t v41 = *(int32_t *)(v39 + (int32_t)&SHA256_Hash_constant_words_K__0x428a2f98__at_7eba4); // 0x2ef84
    int32_t v42 = v26 + 1; // 0x2ef8c
    int32_t v43 = ((v38 / 2048 | 0x200000 * v38) ^ (v38 / 64 | 0x4000000 * v38) ^ (v38 / 0x2000000 | 128 * v38)) + v8 + (v28 & v38 | v30 & -1 - v38) + v40 + v41; // 0x2efa4
    int32_t v44; // 0x2ee28
    int32_t v45 = v43 + v44; // 0x2efac
    int32_t v46 = ((v32 ^ v34) & v36 ^ v32 & v34) + ((v36 / 0x2000 | 0x80000 * v36) ^ (v36 / 4 | 0x40000000 * v36) ^ (v36 / 0x400000 | 1024 * v36)) + v43; // 0x2efb0
    int32_t v47 = v30; // 0x2efbc
    v26 = v42;
    int32_t v48 = v32; // 0x2efbc
    int32_t v49 = v28; // 0x2efbc
    int32_t v50 = v34; // 0x2efbc
    while (v42 != 64) {
        // 0x2ef4c
        v28 = v38;
        v30 = v49;
        v32 = v36;
        v34 = v48;
        v36 = v46;
        v38 = v45;
        v39 = 4 * v26;
        v40 = *(int32_t *)(v39 + v4);
        v41 = *(int32_t *)(v39 + (int32_t)&SHA256_Hash_constant_words_K__0x428a2f98__at_7eba4);
        v42 = v26 + 1;
        v43 = ((v38 / 2048 | 0x200000 * v38) ^ (v38 / 64 | 0x4000000 * v38) ^ (v38 / 0x2000000 | 128 * v38)) + v47 + (v28 & v38 | v30 & -1 - v38) + v40 + v41;
        v45 = v43 + v50;
        v46 = ((v32 ^ v34) & v36 ^ v32 & v34) + ((v36 / 0x2000 | 0x80000 * v36) ^ (v36 / 4 | 0x40000000 * v36) ^ (v36 / 0x400000 | 1024 * v36)) + v43;
        v47 = v30;
        v26 = v42;
        v48 = v32;
        v49 = v28;
        v50 = v34;
    }
    // 0x2efc0
    v8 = v30;
    int32_t * v51 = (int32_t *)v1; // 0x2efec
    int32_t v52 = *v51; // 0x2efec
    int32_t v53 = v5 + 4; // 0x2eff0
    *v51 = *(int32_t *)v53 + v52;
    int32_t v54 = v1 + 4; // 0x2eff8
    int32_t v55 = v53; // 0x2f000
    int32_t v56 = v54; // 0x2f000
    while (v2 != v54) {
        // 0x2efec
        v51 = (int32_t *)v56;
        v52 = *v51;
        v53 = v55 + 4;
        *v51 = *(int32_t *)v53 + v52;
        v54 = v56 + 4;
        v55 = v53;
        v56 = v54;
    }
    // 0x2f004
    v6 += 64;
    result2 = v52;
    v37 = v45;
    v27 = v38;
    v29 = v28;
    v35 = v46;
    v31 = v36;
    v33 = v32;
    v44 = v34;
    if (64 * a3 + a2 == v6) {
        // break -> 0x2f01c
        goto lab_0x2f01c;
    }
    goto lab_0x2ee60;
}

// Address range: 0x2f024 - 0x2f050
int32_t function_2f024(int32_t * a1) {
    int32_t result = (int32_t)a1;
    int32_t v1 = &g291; // 0x2f02c
    int32_t v2 = result + 136; // 0x2f02c
    v1 += 4;
    *(int32_t *)v2 = *(int32_t *)v1;
    while (v2 != result + 164) {
        // 0x2f030
        v2 += 4;
        v1 += 4;
        *(int32_t *)v2 = *(int32_t *)v1;
    }
    // 0x2f040
    *(int32_t *)(result + 4) = 0;
    *a1 = 0;
    return result;
}

// Address range: 0x2f054 - 0x2f100
int32_t function_2f054(int32_t * a1, int32_t * a2, uint32_t a3) {
    int32_t v1 = (int32_t)a2;
    int32_t v2 = (int32_t)a1;
    int32_t * v3 = (int32_t *)(v2 + 4); // 0x2f05c
    int32_t v4 = *v3; // 0x2f05c
    uint32_t v5 = 64 - v4; // 0x2f068
    int32_t v6 = v2 + 8;
    int32_t v7 = v5 < a3 ? v5 : a3;
    int32_t v8; // 0x2f054
    int32_t result = function_11fc4((int32_t *)(v4 + v6), v1, (char)v7, v8); // 0x2f084
    uint32_t v9 = *v3 + a3; // 0x2f08c
    if (v9 >= 63 != v9 != 63) {
        // 0x2f098
        *v3 = v9;
        return result;
    }
    uint32_t v10 = a3 - v7; // 0x2f0a0
    int32_t v11 = v7 + v1; // 0x2f0a8
    function_2ee28(v2, v6, 1);
    uint32_t v12 = v10 % 64; // 0x2f0c0
    function_2ee28(v2, v11, v10 / 64);
    int32_t result2 = function_11fc4((int32_t *)v6, (v10 & -64) + v11, (char)v12, v9); // 0x2f0e8
    *v3 = v12;
    *a1 = result2 + (v10 + 64 & -64);
    return result2;
}

// Address range: 0x2f100 - 0x2f1ec
int32_t function_2f100(int32_t * a1, int32_t a2) {
    int32_t v1 = (int32_t)a1;
    int32_t * v2 = (int32_t *)(v1 + 4); // 0x2f108
    int32_t v3 = *v2; // 0x2f108
    int32_t v4 = v1 + 8;
    uint32_t v5 = v3 + v1; // 0x2f130
    memset((int32_t *)(v3 + v4), 0, ((v3 & 56) == 56 ? 128 : 64) - v3);
    *(char *)(*v2 + v4) = -128;
    *(char *)(((v5 & 0x20000000) != 0 ? 127 : 63) + v4) = 8 * (char)v5;
    *(char *)(((v5 & 0x20000000) != 0 ? 126 : 62) + v4) = (char)(v5 / 32);
    *(char *)(((v5 & 0x20000000) != 0 ? 125 : 61) + v4) = (char)(v5 / 0x2000);
    *(char *)(((v3 & 56) == 56 ? 124 : 60) + v4) = (char)(v5 / 0x200000);
    int32_t result = function_2ee28(v1, v4, (v5 & 0x20000000) != 0 ? 2 : 1); // 0x2f1ac
    int32_t v6 = a2; // 0x2f1b4
    int32_t v7 = v1 + 136;
    int32_t * v8 = (int32_t *)v7; // 0x2f1b8
    *(char *)(v6 + 3) = (char)*v8;
    *(char *)(v6 + 2) = (char)(*v8 / 256);
    *(char *)(v6 + 1) = (char)*(int16_t *)(v7 + 2);
    *(char *)v6 = *(char *)(v7 + 3);
    int32_t v9 = v7 + 4; // 0x2f1e0
    v6 += 4;
    while (v1 + 164 != v7) {
        // 0x2f1b8
        v7 = v9;
        v8 = (int32_t *)v7;
        *(char *)(v6 + 3) = (char)*v8;
        *(char *)(v6 + 2) = (char)(*v8 / 256);
        *(char *)(v6 + 1) = (char)*(int16_t *)(v7 + 2);
        *(char *)v6 = *(char *)(v7 + 3);
        v9 = v7 + 4;
        v6 += 4;
    }
    // 0x2f1e4
    return result;
}

// Address range: 0x2f1ec - 0x2f248
int32_t function_2f1ec(int32_t a1, int32_t a2, int32_t * a3) {
    // 0x2f1ec
    int32_t v1; // bp-48, 0x2f1ec
    int32_t v2 = &v1; // 0x2f200
    int32_t v3 = &g291; // 0x2f200
    v3 += 4;
    *(int32_t *)v2 = *(int32_t *)v3;
    v2 += 4;
    while (v3 != (int32_t)&g292) {
        // 0x2f204
        v3 += 4;
        *(int32_t *)v2 = *(int32_t *)v3;
        v2 += 4;
    }
    int32_t v4 = 0; // bp-184, 0x2f21c
    function_2f054(&v4, (int32_t *)a1, a2);
    return function_2f100(&v4, (int32_t)a3);
}

// Address range: 0x2f250 - 0x2f258
int32_t function_2f250(void) {
    // 0x2f250
    return 0;
}

// Address range: 0x2f258 - 0x2f2c0
int32_t function_2f258(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = *__errno_location(); // 0x2f27c
    int32_t str; // bp-2072, 0x2f258
    snprintf((char *)&str, 2048, "Failed to sem_post errno=%d cgsem=0x%p in %s %s():%d", v1, (int32_t *)a1, (char *)a2, (char *)a3, a4);
    function_2e584(3, &str, 1);
    return function_2a574();
}

// Address range: 0x2f2c0 - 0x2f33c
int32_t function_2f2c0(int32_t a1, char * a2, int32_t a3) {
    // 0x2f2c0
    int32_t v1; // 0x2f2c0
    if (function_11ea4((int32_t *)a1, (int32_t)a2, a3, v1) == 0) {
        // 0x2f2e0
        return 0;
    }
    int32_t v2 = *__errno_location(); // 0x2f2fc
    int32_t str; // bp-2064, 0x2f2c0
    snprintf((char *)&str, 2048, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", v2, "util.c", a2, a3);
    function_2e584(3, &str, 1);
    return function_2a574();
}

// Address range: 0x2f33c - 0x2f3a0
int32_t function_2f33c(char * a1, int32_t a2) {
    int32_t v1 = *__errno_location(); // 0x2f354
    int32_t str; // bp-2064, 0x2f33c
    snprintf((char *)&str, 2048, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", v1, "util.c", a1, a2);
    function_2e584(3, &str, 1);
    return function_2a574();
}

// Address range: 0x2f3a0 - 0x2f408
int32_t function_2f3a0(int32_t a1, int32_t a2) {
    int32_t v1 = a1 + 12; // 0x2f3a4
    int32_t v2; // 0x2f3a0
    if (function_11f94((int32_t *)v1, a2, v2, v2) != 0) {
        // 0x2f3f4
        function_2f33c("tq_freezethaw", 1108);
    }
    // 0x2f3c0
    *(char *)(a1 + 8) = (char)a2;
    pthread_cond_signal((int32_t *)(a1 + 40));
    function_2f2c0(v1, "tq_freezethaw", 1111);
    return function_2f250();
}

// Address range: 0x2f408 - 0x2f490
int32_t function_2f408(uint32_t a1, char * a2, char * a3, int32_t a4) {
    int32_t v1 = a1 & -4;
    int32_t size = a1 % 4 == 0 ? v1 : v1 + 4;
    int32_t * mem = malloc(size); // 0x2f430
    int32_t result = (int32_t)mem; // 0x2f430
    if (mem != NULL) {
        // 0x2f43c
        return result;
    }
    // 0x2f448
    int32_t str; // bp-2072, 0x2f408
    snprintf((char *)&str, 2048, "Failed to malloc size %d from %s %s:%d", size, a2, a3, a4);
    function_2e584(3, &str, 1);
    function_2a574();
    return result;
}

// Address range: 0x2f490 - 0x2f520
int32_t function_2f490(int32_t a1, uint32_t a2, char * a3, char * a4, int32_t a5) {
    int32_t v1 = a2 & -4;
    int32_t v2 = a2 % 4 == 0 ? v1 : v1 + 4;
    int32_t result = function_11eb0(a1, v2, (int32_t)a3, (int32_t)a4); // 0x2f4b8
    if (result != 0) {
        // 0x2f4c4
        return result;
    }
    // 0x2f4d0
    int32_t str; // bp-2072, 0x2f490
    snprintf((char *)&str, 2048, "Failed to calloc memb %d size %d from %s %s:%d", a1, v2, a3, a4, a5);
    function_2e584(3, &str, 1);
    function_2a574();
    return 0;
}

// Address range: 0x2f520 - 0x2f5b4
int32_t function_2f520(int32_t a1, uint32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t v1 = a2 & -4;
    int32_t v2 = a2 % 4 == 0 ? v1 : v1 + 4;
    int32_t result = function_1209c(a1, v2, a3, a4); // 0x2f548
    if (result != 0) {
        // 0x2f554
        return result;
    }
    // 0x2f564
    int32_t str; // bp-2072, 0x2f520
    snprintf((char *)&str, 2048, "Failed to realloc size %d from %s %s:%d", v2, (char *)a3, (char *)a4, a5);
    function_2e584(3, &str, 1);
    function_2a574();
    return 0;
}

// Address range: 0x2f5b4 - 0x2f5fc
int32_t function_2f5b4(int32_t a1) {
    // 0x2f5b4
    if (a1 == 0) {
        // 0x2f5e4
        return (int32_t)"http:";
    }
    // 0x2f5c8
    if (*(int32_t *)((int32_t)&g253 + 12) == a1) {
        // 0x2f5e4
        return (int32_t)"http0:";
    }
    int32_t v1 = (int32_t)&g253; // 0x2f5d4
    int32_t v2 = *(int32_t *)(v1 + 16); // 0x2f5d8
    int32_t result = (int32_t)"invalid"; // 0x2f5e0
    while (v2 != 0) {
        // 0x2f5c8
        result = v2;
        if (*(int32_t *)(v1 + 20) == a1) {
            // break -> 0x2f5e4
            break;
        }
        v1 += 8;
        v2 = *(int32_t *)(v1 + 16);
        result = (int32_t)"invalid";
    }
    // 0x2f5e4
    return result;
}

// Address range: 0x2f600 - 0x2f670
int32_t function_2f600(int32_t result, int32_t a2, int32_t a3) {
    if (a3 < 1) {
        // 0x2f664
        *(char *)result = 0;
        return result;
    }
    int32_t v1 = a2 - 1;
    int32_t v2 = v1; // 0x2f620
    int32_t v3 = result; // 0x2f620
    v2++;
    char * v4 = (char *)v2; // 0x2f624
    char v5 = *(char *)((int32_t)(*v4 / 16) + (int32_t)"tq_freezethaw" + 72); // 0x2f634
    *(char *)v3 = v5;
    char v6 = *(char *)((int32_t)(*v4 % 16) + (int32_t)"tq_freezethaw" + 72); // 0x2f648
    *(char *)(v3 + 1) = v6;
    v3 += 2;
    while (v2 != v1 + a3) {
        // 0x2f624
        v2++;
        v4 = (char *)v2;
        v5 = *(char *)((int32_t)(*v4 / 16) + (int32_t)"tq_freezethaw" + 72);
        *(char *)v3 = v5;
        v6 = *(char *)((int32_t)(*v4 % 16) + (int32_t)"tq_freezethaw" + 72);
        *(char *)(v3 + 1) = v6;
        v3 += 2;
    }
    int32_t result2 = 2 * a3 + result; // 0x2f654
    *(char *)result2 = 0;
    return result2;
}

// Address range: 0x2f670 - 0x2f720
int32_t function_2f670(int32_t * a1, uint32_t a2) {
    int32_t v1 = 2 * a2; // 0x2f674
    uint32_t v2 = v1 | 1; // 0x2f67c
    int32_t v3 = -v2; // 0x2f684
    int32_t result = function_2f490(v2 + 4 - (v3 < 0 ? v2 % 4 : -((v3 % 4))), 1, "util.c", "bin2hex", 789); // 0x2f6b8
    int32_t v4 = a2 < 1 ? result : v1;
    if (a2 <= 0) {
        // 0x2f710
        *(char *)v4 = 0;
        return result;
    }
    int32_t v5 = (int32_t)a1 - 1; // 0x2f6c8
    int32_t v6 = v5; // 0x2f6d8
    int32_t v7 = result; // 0x2f6d8
    v6++;
    char * v8 = (char *)v6; // 0x2f6dc
    char v9 = *(char *)((int32_t)(*v8 / 16) + (int32_t)"tq_freezethaw" + 72); // 0x2f6ec
    *(char *)v7 = v9;
    char v10 = *(char *)((int32_t)(*v8 % 16) + (int32_t)"tq_freezethaw" + 72); // 0x2f700
    *(char *)(v7 + 1) = v10;
    v7 += 2;
    while (v6 != v5 + a2) {
        // 0x2f6dc
        v6++;
        v8 = (char *)v6;
        v9 = *(char *)((int32_t)(*v8 / 16) + (int32_t)"tq_freezethaw" + 72);
        *(char *)v7 = v9;
        v10 = *(char *)((int32_t)(*v8 % 16) + (int32_t)"tq_freezethaw" + 72);
        *(char *)(v7 + 1) = v10;
        v7 += 2;
    }
    // 0x2f710
    *(char *)(v4 + result) = 0;
    return result;
}

// Address range: 0x2f724 - 0x2f8e8
int32_t function_2f724(int32_t * a1, int32_t a2, int32_t a3) {
    if ((char)a2 == 0) {
        // 0x2f830
        return (bool)(a3 == 0);
    }
    // 0x2f730
    if (a3 == 0) {
        // 0x2f830
        return 0;
    }
    unsigned char v1 = *(char *)(a2 + 1); // 0x2f740
    char * v2; // bp-2064, 0x2f724
    if (v1 == 0) {
      lab_0x2f83c:
        // 0x2f83c
        if ((*(char *)&g60 | *(char *)&g221) == 0 != g290 < 3) {
            // 0x2f878
            v2 = (char *)0x32786568;
            function_2e584(3, (int32_t *)&v2, 0);
        }
        // 0x2f830
        return 0;
    }
    int32_t v3 = *(int32_t *)(4 * (int32_t)v1 + (int32_t)"tq_freezethaw" + 96); // 0x2f764
    int32_t v4 = *(int32_t *)((4 * a2 & 1020) + (int32_t)"tq_freezethaw" + 96); // 0x2f768
    if ((v4 || v3) <= 0xffffffff) {
      lab_0x2f7c4:
        // 0x2f7c4
        if ((*(char *)&g60 | *(char *)&g221) == 0 != g290 < 3) {
            // 0x2f800
            v2 = (char *)0x32786568;
            function_2e584(3, (int32_t *)&v2, 0);
        }
        // 0x2f830
        return 0;
    }
    int32_t v5 = a2 + 4; // 0x2f724
    int32_t v6 = a3; // 0x2f780
    int32_t v7 = (int32_t)a1; // 0x2f724
    v6--;
    *(char *)v7 = (char)(v3 | 16 * v4);
    unsigned char v8 = *(char *)(v5 - 2); // 0x2f788
    while (v8 != 0) {
        // 0x2f798
        if (v6 == 0) {
            // 0x2f830
            return 0;
        }
        unsigned char v9 = *(char *)(v5 - 1); // 0x2f7a0
        if (v9 == 0) {
            goto lab_0x2f83c;
        }
        int32_t v10 = *(int32_t *)(4 * (int32_t)v8 + (int32_t)"tq_freezethaw" + 96); // 0x2f7b4
        int32_t v11 = *(int32_t *)(4 * (int32_t)v9 + (int32_t)"tq_freezethaw" + 96); // 0x2f7b8
        v5 += 2;
        v7++;
        if ((v11 || v10) < 0) {
            goto lab_0x2f7c4;
        }
        v6--;
        *(char *)v7 = (char)(v11 | 16 * v10);
        v8 = *(char *)(v5 - 2);
    }
    // 0x2f8b8
    return v6 == 0;
}

// Address range: 0x2f8e8 - 0x2f9c0
int32_t function_2f8e8(int32_t * a1, int32_t str) {
    int32_t v1 = 0; // bp-48, 0x2f900
    int64_t v2 = 0; // bp-28, 0x2f918
    int32_t len = strlen((char *)str); // 0x2f91c
    int32_t v3 = 0; // 0x2f928
    if (len != 0) {
        int32_t v4 = str - 1; // 0x2f92c
        int32_t v5; // bp-56, 0x2f8e8
        int32_t v6 = &v5; // 0x2f940
        int32_t v7 = (int32_t)&v2 - 4; // 0x2f96c
        int32_t v8 = v4; // 0x2f944
        v8++;
        unsigned char v9 = *(char *)v8; // 0x2f948
        uint32_t v10 = *(int32_t *)(4 * (int32_t)v9 + (int32_t)"tq_freezethaw" + 1120); // 0x2f954
        uint64_t v11 = (int64_t)v10; // 0x2f968
        *(int32_t *)&v2 = (int32_t)v11;
        int32_t v12; // 0x2f8e8
        int32_t * v13; // 0x2f8e8
        uint64_t v14; // 0x2f968
        int32_t v15; // 0x2f96c
        if (v7 != v6) {
            // 0x2f95c
            v15 = v7;
            v13 = (int32_t *)v15;
            v14 = 58 * (int64_t)*v13 + (int64_t)(int32_t)(v11 / 0x100000000);
            *v13 = (int32_t)v14;
            v15 -= 4;
            v12 = v14 / 0x100000000;
            while (v15 != v6) {
                // 0x2f95c
                v13 = (int32_t *)v15;
                v14 = 58 * (int64_t)*v13 + (int64_t)v12;
                *v13 = (int32_t)v14;
                v15 -= 4;
                v12 = v14 / 0x100000000;
            }
        }
        // 0x2f97c
        while (len + v4 != v8) {
            // 0x2f948
            v8++;
            v9 = *(char *)v8;
            v10 = *(int32_t *)(4 * (int32_t)v9 + (int32_t)"tq_freezethaw" + 1120);
            v11 = 58 * (int64_t)(int32_t)v2 + (int64_t)v10;
            *(int32_t *)&v2 = (int32_t)v11;
            if (v7 != v6) {
                // 0x2f95c
                v15 = v7;
                v13 = (int32_t *)v15;
                v14 = 58 * (int64_t)*v13 + (int64_t)(int32_t)(v11 / 0x100000000);
                *v13 = (int32_t)v14;
                v15 -= 4;
                v12 = v14 / 0x100000000;
                while (v15 != v6) {
                    // 0x2f95c
                    v13 = (int32_t *)v15;
                    v14 = 58 * (int64_t)*v13 + (int64_t)v12;
                    *v13 = (int32_t)v14;
                    v15 -= 4;
                    v12 = v14 / 0x100000000;
                }
            }
        }
        // 0x2f988
        v3 = llvm_bswap_i32(v1);
    }
    int32_t v16 = (int32_t)a1;
    int32_t v17 = v16 + 1; // 0x2f994
    *(char *)a1 = 0;
    *(int32_t *)v17 = v3;
    int32_t v18 = &v1; // 0x2f9a4
    int32_t v19 = v17;
    int32_t v20 = v19 + 4; // 0x2f9ac
    v18 += 4;
    int32_t result = llvm_bswap_i32(*(int32_t *)v18); // 0x2f9a8
    *(int32_t *)v20 = result;
    while (v19 != v16 + 17) {
        // 0x2f9a4
        v19 = v20;
        v20 = v19 + 4;
        v18 += 4;
        result = llvm_bswap_i32(*(int32_t *)v18);
        *(int32_t *)v20 = result;
    }
    // 0x2f9b8
    return result;
}

// Address range: 0x2f9c0 - 0x2fa0c
int32_t function_2f9c0(int32_t a1, int32_t a2) {
    // 0x2f9c0
    if (a2 <= 127) {
        // 0x2fa00
        *(int32_t *)(a1 + 1) = a2;
        int32_t v1; // 0x2f9c0
        *(char *)a1 = a2 < 128 ? 1 : (char)v1;
        return 2;
    }
    int32_t v2 = a2 > 0x407f ? 0x407f : 2;
    int32_t result = a2 < 0x4080 ? 3 : a1; // 0x2f9e4
    char v3 = v2; // 0x2f9e4
    if (a2 > 0x407f) {
        // 0x2f9e8
        v3 = (v2 | (int32_t)&g8) < a2 ? 4 : 3;
        result = (v2 | (int32_t)&g8) < a2 ? 5 : 4;
    }
    // 0x2fa00
    *(int32_t *)(a1 + 1) = a2;
    *(char *)a1 = v3;
    return result;
}

// Address range: 0x2fa0c - 0x2fbfc
int32_t function_2fa0c(int32_t a1, int32_t a2) {
    int32_t v1 = a2 + 32; // 0x2fa1c
    int32_t v2 = a1 + 32; // 0x2fa1c
    v2 -= 4;
    uint32_t v3 = *(int32_t *)v2; // 0x2fa20
    v1 -= 4;
    uint32_t v4 = *(int32_t *)v1; // 0x2fa24
    int32_t result; // 0x2fa0c
    while (v3 >= v4 != v3 != v4 && v3 >= v4) {
        // 0x2fa34
        result = 1;
        if (v2 == a1) {
            goto lab_0x2fa40;
        }
        v2 -= 4;
        v3 = *(int32_t *)v2;
        v1 -= 4;
        v4 = *(int32_t *)v1;
    }
    // 0x2fa40
    result = v3 >= v4 != v3 != v4;
  lab_0x2fa40:
    // 0x2fa40
    if (g61 == 0) {
        // 0x2fa54
        return result;
    }
    int32_t v5 = llvm_bswap_i32(*(int32_t *)(a1 + 28)); // bp-2136, 0x2fa98
    int32_t v6 = llvm_bswap_i32(*(int32_t *)(a2 + 28)); // bp-2104, 0x2fad8
    int32_t v7 = llvm_bswap_i32(*(int32_t *)(a2 + 4)); // 0x2fb1c
    int32_t v8 = function_2f670(&v5, 32); // 0x2fb28
    int32_t v9 = function_2f670(&v6, 32); // 0x2fb38
    int32_t v10 = 32; // 0x2fb48
    int32_t v11 = v7; // 0x2fb48
    int32_t v12 = 0; // 0x2fb48
    if (g61 == 0) {
        goto lab_0x2fbbc;
    } else {
        // 0x2fb4c
        if ((*(char *)&g60 | *(char *)&g221) == 0) {
            // 0x2fbe4
            v10 = 32;
            v11 = v7;
            v12 = g290;
            if (g290 < 7) {
                goto lab_0x2fbbc;
            } else {
                goto lab_0x2fb74;
            }
        } else {
            goto lab_0x2fb74;
        }
    }
  lab_0x2fbbc:
    // 0x2fbbc
    free(v8, v10, v11, v12);
    free(v9, v10, v11, v12);
    return result;
  lab_0x2fb74:;
    int32_t v13 = result == 0 ? (int32_t)"no (false positive; hash > target)" : (int32_t)"YES (hash <= target)";
    int32_t str; // bp-2072, 0x2fa0c
    snprintf((char *)&str, 2048, " Proof: %s\nTarget: %s\nTrgVal? %s", (char *)v8, (char *)v9, (char *)v13);
    function_2e584(7, &str, 0);
    v10 = &str;
    v11 = 0;
    v12 = v8;
    goto lab_0x2fbbc;
}

// Address range: 0x2fbfc - 0x2fc54
int32_t function_2fbfc(void) {
    int32_t result = function_2f490(1, 88, "util.c", "tq_new", 1077); // 0x2fc20
    *(int32_t *)result = result;
    *(int32_t *)(result + 4) = result;
    function_11fdc(result + 12, 0);
    function_12078(result + 40, 0);
    return result;
}

// Address range: 0x2fc58 - 0x2fcc0
int32_t function_2fc58(int32_t a1) {
    // 0x2fc58
    if (a1 == 0) {
        return 0;
    }
    // 0x2fca4
    function_120b4(a1 + 40);
    function_11f4c(a1 + 12);
    int32_t v1; // 0x2fc58
    return free(a1, v1, a1, v1);
}

// Address range: 0x2fcc0 - 0x2fcc8
int32_t function_2fcc0(void) {
    // 0x2fcc0
    int32_t v1; // 0x2fcc0
    return function_2f3a0(v1, 1);
}

// Address range: 0x2fcc8 - 0x2fcd0
int32_t function_2fcc8(void) {
    // 0x2fcc8
    int32_t v1; // 0x2fcc8
    return function_2f3a0(v1, 0);
}

// Address range: 0x2fcd0 - 0x2fda0
int32_t function_2fcd0(int32_t a1, int32_t a2) {
    int32_t v1 = a1 + 12; // 0x2fcfc
    int32_t v2 = function_2f490(1, 12, "util.c", "tq_push", 1129); // 0x2fd00
    *(int32_t *)v2 = a2;
    int32_t v3 = v2 + 4; // 0x2fd10
    int32_t * v4 = (int32_t *)v3; // 0x2fd14
    *v4 = v3;
    int32_t * v5 = (int32_t *)(v2 + 8); // 0x2fd18
    *v5 = v3;
    int32_t v6 = 12; // 0x2fd24
    if (function_11f94((int32_t *)v1, 12, (int32_t)"util.c", (int32_t)"tq_push") != 0) {
        // 0x2fd90
        function_2f33c("tq_push", 1133);
        v6 = 1133;
    }
    unsigned char v7 = *(char *)(a1 + 8); // 0x2fd28
    int32_t result; // 0x2fcd0
    if (v7 == 0) {
        int32_t * v8 = (int32_t *)(a1 + 4); // 0x2fd34
        int32_t v9 = *v8; // 0x2fd34
        *v8 = v3;
        *v4 = a1;
        *v5 = v9;
        *(int32_t *)v9 = v3;
        result = 1;
    } else {
        // 0x2fd80
        free(v2, v6, (int32_t)"util.c", (int32_t)v7);
        result = 0;
    }
    // 0x2fd4c
    pthread_cond_signal((int32_t *)(a1 + 40));
    function_2f2c0(v1, "tq_push", 1146);
    function_2f250();
    return result;
}

// Address range: 0x2fda4 - 0x2fe80
int32_t function_2fda4(int32_t a1, int32_t abstime) {
    int32_t v1 = a1 + 12; // 0x2fda8
    int32_t * mutex = (int32_t *)v1; // 0x2fdb8
    int32_t v2 = 0; // 0x2fdc0
    int32_t v3; // 0x2fda4
    if (function_11f94(mutex, abstime, v3, v3) != 0) {
        // 0x2fe60
        v2 = function_2f33c("tq_pop", 1158);
    }
    int32_t v4 = v2; // 0x2fdcc
    if (v2 == a1) {
        int32_t * cond = (int32_t *)(a1 + 40);
        int32_t v5; // 0x2fda4
        if (abstime == 0) {
            // 0x2fe54
            v5 = pthread_cond_wait(cond, mutex);
        } else {
            // 0x2fe2c
            v5 = pthread_cond_timedwait(cond, mutex, (struct timespec *)abstime);
        }
        int32_t v6 = v5;
        v4 = 0;
        if (v6 != 0 || v6 == a1) {
            // 0x2fdf8
            function_2f2c0(v1, "tq_pop", 1184);
            function_2f250();
            return 0;
        }
    }
    int32_t * v7 = (int32_t *)(v4 + 4); // 0x2fdd0
    int32_t v8 = *v7; // 0x2fdd0
    int32_t * v9 = (int32_t *)v4; // 0x2fdd8
    int32_t v10 = *v9; // 0x2fdd8
    int32_t v11 = v4 - 4; // 0x2fddc
    *(int32_t *)(v10 + 4) = v8;
    *(int32_t *)v8 = v10;
    *v9 = 0;
    *v7 = 0;
    free(v11, v10, v8, 0);
    // 0x2fdf8
    function_2f2c0(v1, "tq_pop", 1184);
    function_2f250();
    return *(int32_t *)v11;
}

// Address range: 0x2fe84 - 0x2fec0
int32_t function_2fe84(int32_t a1) {
    if (a1 == 0) {
        return 0;
    }
    int32_t * v1 = (int32_t *)(a1 + 12); // 0x2fe90
    int32_t thread = *v1; // 0x2fe90
    if (thread == 0) {
        // 0x2fe9c
        return sem_destroy((int32_t *)(a1 + 16));
    }
    // 0x2fea8
    pthread_cancel(thread);
    *v1 = 0;
    return sem_destroy((int32_t *)(a1 + 16));
}

// Address range: 0x2fec0 - 0x2fef4
int32_t function_2fec0(int32_t result, int32_t a2) {
    int32_t * v1 = (int32_t *)(a2 + 4); // 0x2fec0
    int32_t v2 = result - a2; // 0x2fec8
    int32_t * v3 = (int32_t *)a2; // 0x2fecc
    *v3 = v2;
    int32_t v4 = *(int32_t *)(result + 4) - *v1; // 0x2fed4
    *v1 = v4;
    if (v4 < 0) {
        *v3 = v2 - 1;
        *v1 = v4 + (int32_t)&g469 + 576;
    }
    return result;
}

// Address range: 0x2fef4 - 0x2ff38
int32_t function_2fef4(int32_t result, int32_t a2) {
    int32_t * v1 = (int32_t *)(a2 + 4); // 0x2ff08
    int32_t v2 = a2 + result; // 0x2ff0c
    int32_t * v3 = (int32_t *)a2; // 0x2ff10
    *v3 = v2;
    int32_t v4 = *(int32_t *)(result + 4) + *v1; // 0x2ff18
    *v1 = v4;
    if (v4 > (int32_t)(bool)&g470) {
        int32_t v5 = v4 > (int32_t)&g470 ? v4 - (int32_t)&g469 : v4;
        *v3 = v2 + 1;
        *v1 = v5 - 576;
    }
    return result;
}

// Address range: 0x2ff38 - 0x2ff6c
int32_t function_2ff38(int32_t a1, int32_t a2) {
    if (a1 == a2) {
        // 0x2ff54
        return 0;
    }
    // 0x2ff48
    return (bool)(a1 > a2);
}

// Address range: 0x2ff6c - 0x2ffa0
int32_t function_2ff6c(int32_t a1, int32_t a2) {
    if (a1 == a2) {
        // 0x2ff88
        return 0;
    }
    // 0x2ff7c
    return (bool)(a1 < a2);
}

// Address range: 0x2ffa0 - 0x2ffd0
int32_t function_2ffa0(int32_t result, int32_t a2) {
    // 0x2ffa0
    *(int32_t *)result = a2;
    *(int32_t *)(result + 4) = *(int32_t *)(a2 + 4) / 1000;
    return result;
}

// Address range: 0x2ffd0 - 0x2ffec
int32_t function_2ffd0(int32_t result, int32_t a2) {
    // 0x2ffd0
    *(int32_t *)result = a2;
    *(int32_t *)(result + 4) = 1000 * *(int32_t *)(a2 + 4);
    return result;
}

// Address range: 0x2ffec - 0x30024
int32_t function_2ffec(int32_t a1) {
    struct _TYPEDEF_lldiv_t v1; // 0x3000c
    // 0x2ffec
    int32_t v2; // bp-32, 0x2ffec
    int32_t v3; // 0x2ffec
    v1 = lldiv((int64_t)(int32_t)&v2, (int64_t)v3);
    *(int32_t *)a1 = v2;
    return v1.e0;
}

// Address range: 0x30024 - 0x30064
int32_t function_30024(int32_t * a1) {
    struct _TYPEDEF_lldiv_t v1; // 0x30044
    // 0x30024
    int32_t v2; // bp-32, 0x30024
    int32_t v3; // 0x30024
    v1 = lldiv((int64_t)(int32_t)&v2, (int64_t)v3);
    *a1 = v2;
    *(int32_t *)((int32_t)a1 + 4) = 1000 * v3;
    return v1.e0;
}

// Address range: 0x30064 - 0x300a4
int32_t function_30064(int32_t * a1) {
    struct _TYPEDEF_lldiv_t v1; // 0x30080
    // 0x30064
    int32_t v2; // bp-32, 0x30064
    int32_t v3; // 0x30064
    v1 = lldiv((int64_t)(int32_t)&v2, (int64_t)v3);
    *a1 = v2;
    *(int32_t *)((int32_t)a1 + 4) = v3 * (int32_t)&g471;
    return v1.e0;
}

// Address range: 0x300a4 - 0x300e0
int32_t function_300a4(int32_t a1) {
    struct _TYPEDEF_lldiv_t v1; // 0x300c0
    // 0x300a4
    int32_t v2; // bp-32, 0x300a4
    int32_t v3; // 0x300a4
    v1 = lldiv((int64_t)(int32_t)&v2, (int64_t)v3);
    *(int32_t *)a1 = v2;
    *(int32_t *)(a1 + 4) = 1000 * v3;
    return v1.e0;
}

// Address range: 0x300e0 - 0x30168
int32_t function_300e0(int32_t result, int32_t a2) {
    int32_t * v1 = (int32_t *)(result + 4); // 0x300f4
    int32_t v2 = *v1; // 0x300f4
    int32_t v3 = a2 + result;
    int32_t * v4 = (int32_t *)result; // 0x300fc
    *v4 = v3;
    int32_t v5 = *(int32_t *)(a2 + 4); // 0x30100
    int32_t v6 = v5 + v2;
    *v1 = v6;
    if (v6 >= 0x3b9aca00) {
        int32_t v7 = v6 - 0x3b9aca00; // 0x30120
        *v4 = (v7 > 0x3b9ac9ff ? 2 : 1) + v3;
        *v1 = v7 > 0x3b9ac9ff ? v6 - 0x77359400 : v7;
        return result;
    }
    if (v6 >= 0) {
        return result;
    }
    uint32_t v8 = (-1 - v5 - v2) / 0x3b9aca00;
    *v4 = v3 + -1 - v8;
    *v1 = v6 + 0x3b9aca00 + 0x3b9aca00 * v8;
    return result;
}

// Address range: 0x30168 - 0x30258
int32_t function_30168(int32_t str, int32_t str2) {
    if (str == 0 || str2 == 0) {
        // 0x30244
        return 0;
    }
    uint32_t len = strlen((char *)str); // 0x30184
    uint32_t len2 = strlen((char *)str2); // 0x30190
    if (len == 0) {
        // 0x30244
        return 0;
    }
    // 0x301b4
    int32_t v1; // bp-32, 0x30168
    int32_t v2 = (int32_t)&v1 - (len + 14 & -8); // 0x301c4
    int32_t v3 = (int32_t)*__ctype_tolower_loc(); // 0x301d8
    int32_t v4 = v2 - 1; // 0x301e4
    int32_t v5 = str - 1; // 0x301e4
    int32_t v6 = 0; // 0x301e4
    v5++;
    unsigned char v7 = *(char *)v5; // 0x301e8
    v6++;
    v4++;
    *(char *)v4 = (char)*(int32_t *)(4 * (int32_t)v7 + v3);
    while (v6 < len) {
        // 0x301e8
        v5++;
        v7 = *(char *)v5;
        v6++;
        v4++;
        *(char *)v4 = (char)*(int32_t *)(4 * (int32_t)v7 + v3);
    }
    int32_t v8 = v2 - (len2 + 14 & -8); // 0x301cc
    int32_t v9 = v8 - 1; // 0x30208
    int32_t v10 = str2 - 1; // 0x30208
    int32_t v11 = 0; // 0x30208
    v10++;
    v11++;
    int32_t v12 = *(int32_t *)(4 * (int32_t)*(char *)v10 + v3); // 0x30218
    v9++;
    *(char *)v9 = (char)v12;
    while (v11 < len2) {
        // 0x3020c
        v10++;
        v11++;
        v12 = *(int32_t *)(4 * (int32_t)*(char *)v10 + v3);
        v9++;
        *(char *)v9 = (char)v12;
    }
    int32_t v13 = function_11ebc((int32_t *)v2, v8, v10); // 0x30228
    if (v13 == 0) {
        // 0x30244
        return 0;
    }
    // 0x30234
    return str - v2 + v13;
}

// Address range: 0x30258 - 0x302a0
int32_t function_30258(int32_t str) {
    // 0x30258
    if (str == 0) {
        // 0x30290
        *(int32_t *)str = 0;
        return str;
    }
    // 0x3026c
    int32_t accept2; // 0x30258
    char * found_byte_pos = strpbrk((char *)str, (char *)accept2); // 0x30270
    if (found_byte_pos == NULL) {
        // 0x30290
        *(int32_t *)str = 0;
        return str;
    }
    // 0x30288
    *found_byte_pos = 0;
    *(int32_t *)str = (int32_t)found_byte_pos + 1;
    return str;
}

// Address range: 0x302a0 - 0x302e4
int32_t function_302a0(int32_t * a1) {
    // 0x302a0
    int32_t v1; // bp-16, 0x302a0
    function_11fac(1, &v1);
    *a1 = v1;
    int64_t v2; // 0x302a0
    *(int32_t *)((int32_t)a1 + 4) = (int32_t)v2 / 1000;
    return 0;
}

// Address range: 0x302e4 - 0x30314
int32_t function_302e4(int32_t a1) {
    int32_t v1 = *(int32_t *)(a1 + 4); // 0x302ec
    return ((int32_t)(0x431bde83 * (int64_t)v1 / 0x100000000) >> 18) + (1000 * a1 | (int32_t)(v1 < 0));
}

// Address range: 0x30314 - 0x30350
int32_t function_30314(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = a1 - a2; // 0x3031c
    int32_t * v2 = (int32_t *)a3; // 0x30320
    *v2 = v1;
    int32_t result = *(int32_t *)(a1 + 4) - *(int32_t *)(a2 + 4); // 0x3032c
    if (result < 0) {
        *v2 = v1 - 1;
        *(int32_t *)(a3 + 4) = result + 0x3b9aca00;
    } else {
        *(int32_t *)(a3 + 4) = result;
    }
    // .critedge
    return result;
}

// Address range: 0x30350 - 0x3035c
int32_t function_30350(int32_t a1) {
    // 0x30350
    return function_11fac(1, (int32_t *)a1);
}

// Address range: 0x3035c - 0x3041c
int32_t function_3035c(int32_t * a1, int32_t a2) {
    // 0x3035c
    int32_t rqtp; // bp-16, 0x3035c
    function_30064(&rqtp);
    int32_t v1 = *(int32_t *)((int32_t)a1 + 4); // 0x30380
    int32_t v2 = rqtp; // 0x30388
    int32_t v3; // 0x3035c
    int32_t v4 = v1 + v3; // 0x30390
    rqtp = v2 + 0x3b9ac9ff;
    if (v4 < 0x3b9aca00) {
        if (v4 < 0) {
            // 0x30408
            rqtp = v2 + 0x3b9ac9fe - (-1 - v3 - v1) / 0x3b9aca00;
        }
    } else {
        // 0x303a8
        rqtp = (v4 > 0x773593ff ? 0x3b9aca01 : 0x3b9aca00) + v2;
    }
    int32_t result = clock_nanosleep(1, TIMER_ABSTIME, (struct timespec *)&rqtp, NULL); // 0x303e4
    while (result == 4) {
        // 0x303d4
        result = clock_nanosleep(1, TIMER_ABSTIME, (struct timespec *)&rqtp, NULL);
    }
    // 0x303f0
    return result;
}

// Address range: 0x3041c - 0x304d4
int32_t function_3041c(int32_t * a1) {
    // 0x3041c
    int32_t rqtp; // bp-16, 0x3041c
    function_30024(&rqtp);
    int32_t v1 = *(int32_t *)((int32_t)a1 + 4); // 0x30438
    int32_t v2 = rqtp; // 0x30440
    int32_t v3; // 0x3041c
    int32_t v4 = v1 + v3; // 0x30448
    rqtp = v2 + 0x3b9ac9ff;
    if (v4 < 0x3b9aca00) {
        if (v4 < 0) {
            // 0x304c0
            rqtp = v2 + 0x3b9ac9fe - (-1 - v3 - v1) / 0x3b9aca00;
        }
    } else {
        // 0x30460
        rqtp = (v4 > 0x773593ff ? 0x3b9aca01 : 0x3b9aca00) + v2;
    }
    int32_t result = clock_nanosleep(1, TIMER_ABSTIME, (struct timespec *)&rqtp, NULL); // 0x3049c
    while (result == 4) {
        // 0x3048c
        result = clock_nanosleep(1, TIMER_ABSTIME, (struct timespec *)&rqtp, NULL);
    }
    // 0x304a8
    return result;
}

// Address range: 0x304d4 - 0x30500
int32_t function_304d4(int32_t a1) {
    // 0x304d4
    int32_t v1; // bp-16, 0x304d4
    function_11fac(1, &v1);
    return function_3035c(&v1, a1);
}

// Address range: 0x30500 - 0x30534
int32_t function_30500(int32_t a1, int32_t a2) {
    // 0x30500
    int32_t v1; // bp-24, 0x30500
    function_11fac(1, &v1);
    return function_3041c(&v1);
}

// Address range: 0x30534 - 0x30538
int32_t function_30534(void) {
    // 0x30534
    return 0;
}

// Address range: 0x30538 - 0x3053c
int32_t function_30538(int32_t result) {
    // 0x30538
    return result;
}

// Address range: 0x3053c - 0x30540
int32_t function_3053c(int32_t a1) {
    // 0x3053c
    return a1 + 2;
}

// Address range: 0x30540 - 0x30544
int32_t function_30540(void) {
    // 0x30540
    int32_t v1; // 0x30540
    return function_30bec(v1, v1, v1, v1);
}

// Address range: 0x30544 - 0x30578
int32_t function_30544(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x30544
    __asm_udf(0);
    __asm_udf(184);
    float64_t v1; // 0x30544
    __asm_vrhadd_u16(v1, v1);
    return function_430bb0();
}

// Address range: 0x30578 - 0x305cc
int32_t function_30578(int32_t * a1, int32_t * a2) {
    int32_t v1 = (int32_t)a2;
    int32_t v2 = (int32_t)a1;
    int32_t v3 = v2 - v1; // 0x30580
    if (v3 > 3600) {
        // 0x305c0
        return &g43;
    }
    int32_t v4 = *(int32_t *)(v2 + 4) - *(int32_t *)(v1 + 4); // 0x305a4
    return ((int32_t)(0x10624dd3 * (int64_t)v4 / 0x100000000) >> 6) + (1000 * v3 | (int32_t)(v4 < 0));
}

// Address range: 0x305cc - 0x305d0
int32_t function_305cc(int32_t a1, int32_t a2, int32_t a3) {
    // 0x305cc
    *(int32_t *)a1 = a3;
    return a1 + 4;
}

// Address range: 0x305d0 - 0x305d4
int32_t function_305d0(void) {
    // 0x305d0
    return 4;
}

// Address range: 0x305d6 - 0x305dc
int32_t function_305d6(void) {
    // 0x305d6
    __asm_ldc(0, 3, -0x1fbddff4);
    int32_t result; // 0x305d6
    return result;
}

// Address range: 0x305de - 0x305df
int32_t function_305de(void) {
    // 0x305de
    int32_t result; // 0x305de
    return result;
}

// Address range: 0x305e0 - 0x305e4
int32_t function_305e0(int32_t a1) {
    // 0x305e0
    return 0;
}

// Address range: 0x305e4 - 0x305ec
int32_t function_305e4(int32_t a1, int32_t a2, int32_t a3) {
    // 0x305e4
    __asm_cdp(0, 0, 3, 7, 1, 0);
    return function_30674(a1, a2, a3);
}

// Address range: 0x305ee - 0x305fe
int32_t function_305ee(void) {
    // 0x305ee
    int32_t v1; // 0x305ee
    bool v2; // 0x305ee
    if (!v2) {
        v1 = function_46c0d6();
    }
    int32_t v3 = v1; // 0x305f2
    if (v2) {
        v3 = function_ff06bdfa();
    }
    int32_t v4 = v3; // 0x305f6
    if (v2) {
        v4 = function_1ac0de();
    }
    int32_t result = v4; // 0x305fa
    if (v2) {
        result = function_6c01e();
    }
    // 0x305fe
    return result;
}

// Address range: 0x30600 - 0x30604
int32_t function_30600(void) {
    // 0x30600
    int32_t result; // 0x30600
    return result;
}

// Address range: 0x30604 - 0x30612
int32_t function_30604(void) {
    int32_t v1 = function_430c48(); // 0x30604
    *(int16_t *)(v1 + 36) = (int16_t)v1;
    int32_t v2; // 0x30604
    return -1 - (v2 >> v2);
}

// Address range: 0x30614 - 0x30674
int32_t function_30614(int32_t a1, int32_t a2, int32_t a3) {
    // 0x30614
    *(int32_t *)a2 = a1;
    int32_t v1 = function_11ebc((int32_t *)a1, (int32_t)"//", a3); // 0x30630
    char * str = (char *)(v1 == 0 ? a1 : v1 + 2); // 0x30644
    strchr(str, 91);
    return (int32_t)strchr(str, 93);
}

// Address range: 0x30674 - 0x3067c
int32_t function_30674(int32_t a1, int32_t a2, int32_t a3) {
    // 0x30674
    *(int32_t *)(2 * a1) = a2;
    int32_t v1; // 0x30674
    return function_30d28(a1, a2, a3 + 5, v1);
}

// Address range: 0x3067c - 0x30784
int32_t function_3067c(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x3067c
    bool v1; // 0x3067c
    int32_t c; // 0x3067c
    char * found_char_pos = strchr((char *)(v1 ? c : c), c); // 0x30680
    int32_t v2 = (int32_t)found_char_pos; // 0x30680
    int32_t len = strlen((char *)c); // 0x3068c
    int32_t v3 = len; // 0x30694
    int32_t v4 = v2; // 0x30694
    int32_t v5 = v2; // 0x30694
    if (found_char_pos != NULL) {
        // 0x30698
        v3 = v2 - c;
        v5 = len + -1 - v3;
        v4 = v2 + 1;
        if (v5 <= 0) {
            // 0x30768
            return 0;
        }
    }
    int32_t v6 = v3;
    if (v6 < 1) {
        // 0x30768
        return 0;
    }
    int32_t v7 = c == 0 ? v6 : v6 - 2;
    int32_t str; // bp+16, 0x3067c
    snprintf((char *)&str, 254, "%.*s", v7, (char *)(c + (int32_t)(c != 0)));
    char * str2; // 0x3067c
    if (v5 == 0) {
        // 0x306e4
        str2 = (char *)0x3038;
    } else {
        // 0x30728
        snprintf((char *)&str2, 6, "%.*s", v5, (char *)v4);
        char * found_byte_pos = strpbrk((char *)&str2, "/#"); // 0x30754
        if (found_byte_pos != NULL) {
            *found_byte_pos = 0;
        }
    }
    // 0x30700
    *(int32_t *)c = (int32_t)__strdup((char *)&str2);
    *(int32_t *)c = (int32_t)__strdup((char *)&str);
    return 1;
}

// Address range: 0x30784 - 0x30858
int32_t function_30784(int32_t result, int32_t a2) {
    int32_t * v1 = (int32_t *)(a2 + 184); // 0x307a8
    *v1 = 0;
    char * str = (char *)result; // 0x307d8
    int32_t v2 = 0; // 0x307e0
    int32_t v3 = (int32_t)"tq_freezethaw" + 20; // 0x307e0
    int32_t len = 5; // 0x307e0
    if (strncmp(str, "http:", 5) != 0) {
        v2++;
        int32_t v4 = 8 * v2;
        int32_t v5 = *(int32_t *)(v4 + (int32_t)&g253); // 0x307b4
        while (v5 != 0) {
            char * str2 = (char *)v5;
            len = strlen(str2);
            if (strncmp(str, str2, len) == 0) {
                // 0x307cc
                v3 = v4 + (int32_t)"tq_freezethaw" + 20;
                goto lab_0x307e4;
            }
            v2++;
            v4 = 8 * v2;
            v5 = *(int32_t *)(v4 + (int32_t)&g253);
        }
        // 0x30850
        return result;
    }
    goto lab_0x307e4;
  lab_0x307e4:;
    char * found_char_pos = strchr(str, 124); // 0x307ec
    int32_t result2 = result; // 0x307f4
    if (found_char_pos != NULL) {
        int32_t v6 = (int32_t)found_char_pos; // 0x307ec
        *found_char_pos = 0;
        int32_t str3 = function_2f408(1 - result - len + v6, "util.c", "get_proxy", 750); // 0x30820
        *v1 = str3;
        strcpy((char *)str3, (char *)(len + result));
        *(int32_t *)(a2 + 180) = *(int32_t *)v3;
        result2 = v6 + 1;
    }
    // 0x30850
    return result2;
}

// Address range: 0x30860 - 0x30890
int32_t function_30860(int32_t result, int32_t str) {
    // 0x30860
    if (strlen((char *)str) == 0) {
        function_308e0((int32_t)&g488, (int32_t)&g488, (int32_t)&g488);
    }
    if (result == 0) {
        function_308e8((int32_t)&g488, (int32_t)&g488, (int32_t)&g488);
    }
    // 0x3088c
    return result;
}

// Address range: 0x30890 - 0x30892
int32_t function_30890(void) {
    // 0x30890
    int32_t result; // 0x30890
    *(int16_t *)(result + 50) = (int16_t)result;
    return result;
}

// Address range: 0x30892 - 0x308de
int32_t function_30892(int32_t a1, int32_t a2, int32_t a3, uint32_t a4) {
    // 0x30892
    bool v1; // 0x30892
    bool v2; // 0x30892
    bool v3; // 0x30892
    int32_t v4; // 0x30892
    int32_t v5; // 0x30892
    int32_t v6; // 0x30892
    int32_t v7; // 0x30892
    bool v8; // 0x30892
    int32_t v9; // 0x30892
    if (v8) {
        *(int32_t *)(v9 + 4) = 0x30898;
        int32_t v10 = v9 - 0x30898; // 0x30892
        int32_t v11 = 32 * a1 & a4 & a1 << a4; // 0x308a6
        v1 = v11 < 0;
        v5 = v10;
        if (v11 == 0) {
            v4 = a1;
            v6 = v10;
            v7 = v10;
            v2 = v11 < 0;
            v3 = true;
            if ((a1 & 0x8000000) == 0) {
                goto lab_dec_label_pc_unknown_18;
            } else {
                goto lab__critedge1;
            }
        } else {
            goto lab_dec_label_pc_unknown_17;
        }
    } else {
        // .thread18
        __asm_bicsne(v9, 192, 6);
        goto lab_dec_label_pc_unknown_17;
    }
  lab_dec_label_pc_unknown_17:
    v4 = v9 & 0x100000 * a1;
    v6 = v5;
    v7 = v5;
    v2 = v1;
    v3 = false;
    if ((a1 & 0x1000) == 0) {
        goto lab_dec_label_pc_unknown_18;
    } else {
        goto lab__critedge1;
    }
  lab_dec_label_pc_unknown_18:
    __asm_ldclo(3, 14, *(int32_t *)(v9 - 256));
    int32_t v12 = unknown_ff4e9f3a(); // 0x308b6
    int32_t v13 = v12; // 0x308ba
    bool v14 = false; // 0x308ba
    bool v15 = v2; // 0x308ba
    int32_t v16 = v7; // 0x308ba
    int32_t v17 = v12; // 0x308ba
    bool v18 = false; // 0x308ba
    bool v19 = v2; // 0x308ba
    int32_t v20 = v7; // 0x308ba
    if (v3) {
        goto lab_dec_label_pc_unknown_19;
    } else {
        goto lab_dec_label_pc_unknown_20;
    }
  lab__critedge1:;
    uint32_t v21 = 64 * v4; // 0x308b2
    int32_t v22 = unknown_ff4e9f3a(); // 0x308b6
    v13 = v22;
    v14 = v21 >= v6;
    v15 = v21 - v6 < 0;
    v16 = v6;
    v17 = v22;
    v18 = v21 >= v6;
    v19 = v21 - v6 < 0;
    v20 = v6;
    if (v21 == v6) {
        goto lab_dec_label_pc_unknown_19;
    } else {
        goto lab_dec_label_pc_unknown_20;
    }
  lab_dec_label_pc_unknown_19:;
    int32_t v23 = v20; // 0x308be
    bool v24 = true; // 0x308be
    int32_t v25 = v17; // 0x308be
    int32_t v26 = v20; // 0x308be
    bool v27 = true; // 0x308be
    int32_t v28 = v17; // 0x308be
    bool v29 = v18; // 0x308be
    if (v19) {
        goto lab_dec_label_pc_unknown_21;
    } else {
        goto lab_dec_label_pc_unknown_22;
    }
  lab_dec_label_pc_unknown_20:
    __asm_svcne(0x70ebff);
    v23 = v16;
    v24 = false;
    v25 = v13;
    v26 = v16;
    v27 = false;
    v28 = v13;
    v29 = v14;
    if (v15) {
        goto lab_dec_label_pc_unknown_21;
    } else {
        goto lab_dec_label_pc_unknown_22;
    }
  lab_dec_label_pc_unknown_21:;
    int32_t v30 = v25; // 0x308c2
    bool v31 = v24; // 0x308c2
    int32_t v32 = v23; // 0x308c2
    int32_t v33 = v25; // 0x308c2
    bool v34 = v24; // 0x308c2
    int32_t v35 = v23; // 0x308c2
    if ((v9 & 0x4000000) == 0) {
        goto lab_dec_label_pc_unknown_23;
    } else {
        goto lab_dec_label_pc_unknown_24;
    }
  lab_dec_label_pc_unknown_22:
    v30 = v28;
    v31 = v27;
    v32 = v26;
    v33 = v28;
    v34 = v27;
    v35 = v26;
    if (v29) {
        goto lab_dec_label_pc_unknown_24;
    } else {
        goto lab_dec_label_pc_unknown_23;
    }
  lab_dec_label_pc_unknown_23:;
    int32_t v36 = v30; // 0x308c6
    int32_t v37 = v30; // 0x308c6
    int32_t v38 = v32; // 0x308c6
    if (v31) {
        goto lab__thread61;
    } else {
        goto lab_dec_label_pc_unknown_25;
    }
  lab_dec_label_pc_unknown_24:
    v36 = v33;
    v37 = v33;
    v38 = v35;
    if (v34) {
        goto lab__thread61;
    } else {
        goto lab_dec_label_pc_unknown_25;
    }
  lab__thread61:;
    bool v39 = true; // 0x308ce
    int32_t result = v37; // 0x308ce
    int32_t v40 = v38 & v37 / 8; // 0x308ce
    bool v41 = (v37 & 4) != 0; // 0x308ce
    goto lab__thread65;
  lab_dec_label_pc_unknown_25:
    v39 = false;
    result = v36;
    v40 = v36 / 8 & v9;
    v41 = false;
    if ((v36 & 4) != 0) {
        v39 = false;
        result = v36;
        v40 = v36 >> 6 & v9;
        v41 = (v36 & 32) != 0;
    }
    goto lab__thread65;
  lab__thread65:
    // .thread65
    if (v41 == !v39) {
        // branch -> 
    }
    if (v39) {
        *(int32_t *)v9 = v40;
        *(int32_t *)(v9 + 4) = 0x308dc;
    }
    if (v41 == !v39) {
        *(int32_t *)(v9 + 416) = v40;
    }
    return result;
}

// Address range: 0x308e0 - 0x308e8
int32_t function_308e0(int32_t a1, int32_t a2, int32_t a3) {
    // 0x308e0
    int32_t result; // 0x308e0
    return result;
}

// Address range: 0x308e8 - 0x30928
int32_t function_308e8(int32_t a1, int32_t a2, int32_t a3) {
    // 0x308e8
    int32_t str2; // 0x308e8
    int32_t v1 = str2 & -4;
    int32_t str = function_2f408(str2 % 4 == 0 ? v1 : v1 + 4, "util.c", "realloc_strcat", 3382); // 0x3090c
    strcpy((char *)str, (char *)str2);
    return str;
}

// Address range: 0x30928 - 0x30930
int32_t function_30928(void) {
    // 0x30928
    int32_t result; // 0x30928
    return result;
}

// Address range: 0x30934 - 0x30a50
int32_t function_30934(int32_t str2) {
    if (str2 == 0) {
        int32_t * mem = malloc(7); // 0x309dc
        if (mem == NULL) {
            // 0x30a08
            int32_t str; // bp-2072, 0x30934
            snprintf((char *)&str, 2048, "Failed to malloc null in %s %s():%d", "util.c", "str_text", 3407);
            function_2e584(3, &str, 1);
            function_2a574();
        } else {
            int32_t v1 = (int32_t)mem; // 0x309dc
            *mem = 0x6c756e28;
            *(int16_t *)(v1 + 4) = 0x296c;
            *(char *)(v1 + 6) = 0;
        }
    }
    int32_t result = function_2f408(4 * strlen((char *)str2) + 5, "util.c", "str_text", 3412); // 0x3096c
    int32_t v2 = result; // 0x30980
    int32_t v3 = str2 - 1; // 0x30980
    int32_t v4; // 0x30934
    while (true) {
        int32_t v5 = v2;
        v3++;
        char * v6 = (char *)v3; // 0x30990
        unsigned char v7 = *v6; // 0x30990
        int32_t v8 = v7; // 0x30990
        uint32_t v9 = v8 - 32; // 0x30994
        char * str3 = (char *)v5;
        if (v9 == 94 || v9 < 94) {
            // 0x30984
            *str3 = v7;
            int32_t v10 = v5 + 1;
            v2 = v10;
            v4 = v10;
            if (*v6 == 0) {
                // break -> 0x309c4
                break;
            }
        } else {
            // 0x309a8
            sprintf(str3, "0x%02x", v8);
            int32_t v11 = v5 + 4; // 0x309b8
            v2 = v11;
            v4 = v11;
            if (*v6 == 0) {
                // break -> 0x309c4
                break;
            }
        }
    }
    // 0x309c4
    *(char *)v4 = 0;
    return result;
}

// Address range: 0x30a54 - 0x30a94
int32_t function_30a54(int32_t a1) {
    // 0x30a54
    int32_t str; // bp-24, 0x30a54
    snprintf((char *)&str, 16, "cg@%s", (char *)a1);
    return prctl(PR_SET_NAME, (int32_t)&str, 0, 0, 0);
}

// Address range: 0x30a94 - 0x30b10
int32_t function_30a94(int32_t sem, char * a2, char * a3, int32_t a4) {
    int32_t v1 = sem_init((int32_t *)sem, 0, 0); // 0x30ab4
    int32_t result = 0; // 0x30abc
    if (v1 != 0) {
        int32_t v2 = *__errno_location(); // 0x30ad4
        int32_t str; // bp-2072, 0x30a94
        snprintf((char *)&str, 2048, "Failed to sem_init ret=%d errno=%d in %s %s():%d", v1, v2, a2, a3, a4);
        function_2e584(3, &str, 1);
        result = function_2a574();
    }
    // 0x30b04
    return result;
}

// Address range: 0x30b10 - 0x30b54
int32_t function_30b10(int32_t a1, int32_t * attr, int32_t * thread_func, int32_t thread_func_arg) {
    // 0x30b10
    function_30a94(a1 + 16, "util.c", "thr_info_create", 1191);
    return pthread_create((int32_t *)(a1 + 12), attr, (int32_t * (*)(int32_t *))thread_func, (int32_t *)thread_func_arg);
}

// Address range: 0x30b58 - 0x30b90
int32_t function_30b58(int32_t a1, char * a2, char * a3, int32_t a4) {
    // 0x30b58
    if (function_11f04((int32_t *)a1) == 0) {
        return 0;
    }
    // 0x30b78
    return function_2f258(a1, (int32_t)a2, (int32_t)a3, a4);
}

// Address range: 0x30b90 - 0x30bd0
int32_t function_30b90(int32_t a1) {
    // 0x30b90
    pthread_setcanceltype(1, PTHREAD_CANCEL_DEFERRED);
    function_30b58(a1, "util.c", "completion_thread", 3638);
    return 0;
}

// Address range: 0x30bd8 - 0x30bdc
int32_t function_30bd8(void) {
    // 0x30bd8
    __asm_udf(129);
    int32_t v1; // 0x30bd8
    return function_31078(v1);
}

// Address range: 0x30bdc - 0x30bec
int32_t function_30bdc(int32_t result, int32_t a2, int32_t a3) {
    // 0x30bdc
    bool v1; // 0x30bdc
    if (v1) {
        // 0x30be8
        *(int32_t *)result = a3;
        return result;
    }
    // 0x30bde
    return function_3107c();
}

// Address range: 0x30bec - 0x30bf0
int32_t function_30bec(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x30bec
    *(char *)result = (char)a4;
    return result;
}

// Address range: 0x30bf0 - 0x30c54
int32_t function_30bf0(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x30bf0
    int32_t v1; // 0x30bf0
    int32_t * v2 = (int32_t *)v1; // 0x30bf4
    if (function_11ed4(v2) == 0) {
        // 0x30c00
        return 0;
    }
    int32_t v3 = *__errno_location(); // 0x30c10
    if (v3 == 4) {
        function_30bf0((int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488);
    }
    // 0x30c1c
    int32_t str; // bp+16, 0x30bf0
    snprintf((char *)&str, 2048, "Failed to sem_wait errno=%d cgsem=0x%p in %s %s():%d", v3, v2, (char *)v1, (char *)v1, v1);
    function_2e584(3, &str, 1);
    // 0x30c00
    return function_2a574();
}

// Address range: 0x30c54 - 0x30d28
int32_t function_30c54(int32_t sem, int32_t a2, char * a3, char * a4) {
    // 0x30c54
    int32_t v1; // bp-2088, 0x30c54
    function_11fac(1, &v1);
    int64_t v2; // 0x30c54
    int32_t v3 = v2; // 0x30c80
    int64_t abs_timeout; // bp-2096, 0x30c54
    function_30064((int32_t *)&abs_timeout);
    uint64_t v4 = 0x100000000 * abs_timeout >> 32; // 0x30cd0
    int32_t v5 = v3 - v3 % 1000 - 0x3b9aca00 + (int32_t)v4 > 0x3b9ac9ff ? 2 : 1;
    abs_timeout = v1 + (int32_t)(v4 / 0x100000000) + v5;
    if (sem_timedwait((int32_t *)sem, (struct timespec *)&abs_timeout) == 0) {
        // 0x30d24
        return 0;
    }
    int32_t v6 = *__errno_location(); // 0x30d18
    int32_t result = 110; // 0x30d20
    if (v6 != 110) {
        result = function_30d4c(v6, (int32_t)&g488);
    }
    // 0x30d24
    return result;
}

// Address range: 0x30d28 - 0x30d34
int32_t function_30d28(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x30d28
    bool v1; // 0x30d28
    if (v1) {
        // 0x30d34
        return result;
    }
    // 0x30d2a
    return function_31248(result);
}

// Address range: 0x30d2c - 0x30d30
int32_t function_30d2c(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    // 0x30d2c
    int32_t result; // 0x30d2c
    return result;
}

// Address range: 0x30d36 - 0x30d3c
int32_t function_30d36(int32_t a1) {
    // 0x30d36
    int32_t v1; // 0x30d36
    return function_30e64(a1 + 4, v1);
}

// Address range: 0x30d3c - 0x30d4c
int32_t function_30d3c(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x30d3c
    return result;
}

// Address range: 0x30d4c - 0x30d70
int32_t function_30d4c(int32_t result, int32_t a2) {
    // 0x30d4c
    return result;
}

// Address range: 0x30d70 - 0x30d74
int32_t function_30d70(int32_t a1) {
    // 0x30d70
    return function_30890();
}

// Address range: 0x30d74 - 0x30da4
int32_t function_30d74(void) {
    // 0x30d74
    int32_t str; // bp+32, 0x30d74
    int32_t format; // 0x30d74
    snprintf((char *)&str, 2048, (char *)format);
    function_2e584(3, &str, 1);
    function_2a574();
    return 0;
}

// Address range: 0x30da4 - 0x30dd8
int32_t function_30da4(int32_t sem) {
    // 0x30da4
    int32_t * v1; // 0x30dc4
    while (true) {
        int32_t result = sem_trywait((int32_t *)sem); // 0x30db8
        if (result < 0) {
            // 0x30dc4
            v1 = __errno_location();
            if (*v1 != 4) {
                // break -> 
                break;
            }
        } else {
            if (result != 0) {
                return result;
            }
        }
    }
    return (int32_t)v1;
}

// Address range: 0x30dd8 - 0x30ddc
int32_t function_30dd8(void) {
    // 0x30dd8
    int32_t sem; // 0x30dd8
    return sem_destroy((int32_t *)sem);
}

// Address range: 0x30ddc - 0x30e64
int32_t function_30ddc(int32_t a1, int32_t a2, int32_t a3) {
    int32_t thread_func_arg = function_2f408(24, "util.c", "cg_completion_timeout", 3649); // 0x30e04
    function_30a94(thread_func_arg, "util.c", "cg_completion_timeout", 3650);
    *(int32_t *)(thread_func_arg + 16) = a1;
    *(int32_t *)(thread_func_arg + 20) = a2;
    int32_t thread; // bp-28, 0x30ddc
    pthread_create(&thread, NULL, (int32_t * (*)(int32_t *))0x30b90, (int32_t *)thread_func_arg);
    return function_30c54(thread_func_arg, a3, "util.c", "cg_completion_timeout");
}

// Address range: 0x30e64 - 0x30e6c
int32_t function_30e64(uint32_t a1, int32_t a2) {
    // 0x30e64
    return a1 / 256;
}

// Address range: 0x30e6c - 0x30e80
int32_t function_30e6c(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x30e6c
    int32_t thread; // 0x30e6c
    pthread_cancel(thread);
    return 0;
}

// Address range: 0x30e80 - 0x30ea4
int32_t function_30e80(int32_t thread) {
    // 0x30e80
    int32_t retval; // 0x30e80
    pthread_join(thread, (int32_t **)retval);
    free(retval, retval, retval, retval);
    return 0;
}

// Address range: 0x30ea8 - 0x31018
int32_t function_30ea8(int32_t result, int32_t * a2, int32_t a3, char * a4, int32_t a5, int32_t a6) {
    int32_t format; // 0x30ea8
    if (a3 < 1) {
        // 0x30ee8
        format = (int32_t)"ERR: Asked to memcpy %u bytes from %s %s():%d";
        if ((*(char *)&g60 | *(char *)&g221) == 0 == g290 < 3) {
            // 0x30f58
            return result;
        }
    } else {
        if (result == 0) {
            // 0x30f60
            format = (int32_t)"ERR: Asked to memcpy %u bytes to NULL from %s %s():%d";
            if ((*(char *)&g60 | *(char *)&g221) == 0 == g290 < 3) {
                // 0x30f58
                return 0;
            }
        } else {
            if (a2 != NULL) {
                // 0x30edc
                return function_11fc4((int32_t *)result, (int32_t)a2, (char)a3, (int32_t)a4);
            }
            char v1 = *(char *)&g60; // 0x30fd8
            format = (int32_t)"ERR: Asked to memcpy %u bytes from NULL from %s %s():%d";
            if ((v1 | *(char *)&g221) == 0 == g290 < 3) {
                // 0x30f58
                return result;
            }
        }
    }
    // 0x30f40
    int32_t str; // bp-2064, 0x30ea8
    snprintf((char *)&str, 2048, (char *)format, a3, a4, (char *)a5, a6);
    // 0x30f58
    return function_2e584(3, &str, 0);
}

// Address range: 0x31018 - 0x31078
int32_t function_31018(int32_t a1) {
    int32_t v1 = 0; // bp-36, 0x31030
    int32_t v2; // 0x31018
    function_2f8e8(&v1, v2);
    *(char *)a1 = 118;
    *(char *)(a1 + 1) = -87;
    *(char *)(a1 + 2) = 20;
    return a1 + 3;
}

// Address range: 0x31078 - 0x3107c
int32_t function_31078(int32_t a1) {
    // 0x31078
    return a1 + 6;
}

// Address range: 0x3107c - 0x3107d
int32_t function_3107c(void) {
    // 0x3107c
    int32_t result; // 0x3107c
    return result;
}

// Address range: 0x3107e - 0x31080
int32_t function_3107e(void) {
    // 0x3107e
    int32_t result; // 0x3107e
    return result;
}

// Address range: 0x31080 - 0x310a0
int32_t function_31080(int32_t a1) {
    // 0x31080
    int32_t v1; // bp+13, 0x31080
    int32_t v2; // 0x31080
    int32_t result = function_30ea8(v2, &v1, v2, (char *)v2, (int32_t)&g488, (int32_t)&g488); // 0x31084
    *(char *)(v2 + 23) = -120;
    *(char *)(v2 + 24) = -84;
    return result;
}

// Address range: 0x310a4 - 0x311b4
int32_t function_310a4(int32_t str, int32_t a2) {
    uint32_t len = strlen((char *)str); // 0x310b8
    int32_t result = function_2f408(len + 9, "util.c", "ser_string", 996); // 0x310d4
    if (len == 252 || len < 252) {
        // 0x3117c
        *(char *)result = (char)len;
        function_30ea8(result + 1, (int32_t *)str, len, "util.c", (int32_t)"ser_string", 1000);
        *(int32_t *)a2 = len + 1;
        return result;
    }
    if (len < 0x10000) {
        int32_t v1 = __asm_rev16(len); // 0x31138
        *(char *)result = -3;
        *(int16_t *)(result + 1) = (int16_t)v1;
        function_30ea8(result + 3, (int32_t *)str, len, "util.c", (int32_t)"ser_string", 1009);
        *(int32_t *)a2 = len + 3;
        return result;
    }
    int32_t v2 = llvm_bswap_i32(len); // 0x310f0
    *(char *)result = -2;
    *(int32_t *)(result + 1) = v2;
    function_30ea8(result + 5, (int32_t *)str, len, "util.c", (int32_t)"ser_string", 1019);
    *(int32_t *)a2 = len + 5;
    return result;
}

// Address range: 0x311b8 - 0x311e8
int32_t function_311b8(void) {
    // 0x311b8
    int32_t v1; // 0x311b8
    return function_30ea8(v1, (int32_t *)v1, 8, "util.c", (int32_t)"copy_time", 1236);
}

// Address range: 0x311ec - 0x31248
int32_t function_311ec(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = a1; // 0x311f8
    if (a3 < a2) {
        v1 = function_31260();
    }
    int32_t v2 = v1; // 0x31200
    if (a3 == a2) {
        v2 = function_31248(v1);
    }
    int32_t v3 = a3 - a2; // 0x31204
    int32_t * v4 = (int32_t *)v2; // 0x31208
    *v4 = v3;
    int32_t v5 = *(int32_t *)(a3 + 4) - *(int32_t *)(a2 + 4); // 0x31214
    int32_t * v6 = (int32_t *)(v2 + 4); // 0x3121c
    *v6 = v5;
    if (v5 >= 0) {
        // 0x31224
        return 0;
    }
    // 0x3122c
    *v4 = v3 - 1;
    *v6 = v5 + (int32_t)&g469 + 576;
    return 0;
}

// Address range: 0x31248 - 0x3124c
int32_t function_31248(int32_t a1) {
    // 0x31248
    return function_30d70(a1);
}

// Address range: 0x3124c - 0x31260
int32_t function_3124c(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x3124c
    return -1;
}

// Address range: 0x31260 - 0x31268
int32_t function_31260(void) {
    // 0x31260
    return -1;
}

// Address range: 0x31268 - 0x312a8
int32_t function_31268(int32_t * a1, int32_t a2) {
    int32_t result = (int32_t)a1;
    if (a2 == 1) {
        // 0x312a4
        return result;
    }
    int32_t result2 = result + a2; // 0x3127c
    int32_t v1 = result - 1; // 0x3127c
    int32_t v2 = 0;
    int32_t v3 = v2 + 1; // 0x31280
    v1++;
    char * v4 = (char *)v1; // 0x31284
    result2--;
    char * v5 = (char *)result2; // 0x3128c
    *v4 = *v5;
    *v5 = *v4;
    while (v3 < a2 - 2 - v2) {
        // 0x31280
        v2 = v3;
        v3 = v2 + 1;
        v1++;
        v4 = (char *)v1;
        result2--;
        v5 = (char *)result2;
        *v4 = *v5;
        *v5 = *v4;
    }
    // 0x312a4
    return result2;
}

// Address range: 0x312a8 - 0x31590
int32_t function_312a8(int32_t a1, int32_t a2) {
    // 0x312a8
    g479 = a1 - 1;
    int32_t result = 1; // 0x312b0
    int32_t result2 = 0; // 0x312b0
    switch (a1) {
        case 1: {
            return result;
        }
        case 2: {
            // 0x313f0
            return (a2 & 128) == 0 ? 1 : 2;
        }
        case 64: {
            uint32_t v1 = a2 + 252 & 252; // 0x313fc
            if (v1 >= 248 != v1 != 248) {
                // 0x31408
                return (int32_t)*(char *)(v1 + (int32_t)"tq_freezethaw" + 2028);
            }
            // 0x313f0
            return 1;
        }
        case 4: {
            int32_t v2 = a2 & 192; // 0x31430
            result = 4;
            result2 = 3;
            switch ((char)v2) {
                case -128: {
                    return result2;
                }
                case -64: {
                    return result;
                }
                default: {
                    // 0x313f0
                    return v2 == 64 ? 2 : 1;
                }
            }
        }
        case 32: {
            uint32_t v3 = a2 + 248 & 248; // 0x3148c
            result = 1;
            if (v3 >= 240 != v3 != 240) {
                // 0x31498
                return (int32_t)*(char *)(v3 + (int32_t)"tq_freezethaw" + 1784);
            }
            // 0x313f0
            return result;
        }
        case 16: {
            uint32_t v4 = a2 & 240; // 0x313b8
            if (v4 == 128) {
                // 0x313f0
                return 9;
            }
            if (v4 < 128) {
                // 0x313c8
                if (v4 == 64) {
                    // 0x313f0
                    return 5;
                }
                char v5 = v4;
                if (v4 < 64) {
                    // 0x313d4
                    result = 1;
                    result2 = 3;
                    switch (v5) {
                        case 32: {
                            return result2;
                        }
                        case 48: {
                            // 0x313f0
                            return 4;
                        }
                        case 16: {
                            // 0x313f0
                            return 2;
                        }
                        default: {
                            return result;
                        }
                    }
                } else {
                    // 0x3150c
                    result = 1;
                    result2 = 7;
                    switch (v5) {
                        case 96: {
                            return result2;
                        }
                        case 112: {
                            // 0x313f0
                            return 8;
                        }
                        case 80: {
                            // 0x313f0
                            return 6;
                        }
                        default: {
                            return result;
                        }
                    }
                }
            } else {
                // 0x314c0
                if (v4 == 192) {
                    // 0x313f0
                    return 13;
                }
                char v6 = v4;
                if (v4 < 192) {
                    // 0x31528
                    result = 1;
                    result2 = 11;
                    switch (v6) {
                        case -96: {
                            return result2;
                        }
                        case -80: {
                            // 0x313f0
                            return 12;
                        }
                        case -112: {
                            // 0x313f0
                            return 10;
                        }
                        default: {
                            return result;
                        }
                    }
                } else {
                    // 0x314cc
                    result = 16;
                    result2 = 15;
                    switch (v6) {
                        case -32: {
                            return result2;
                        }
                        case -16: {
                            return result;
                        }
                        case -48: {
                            // 0x3147c
                            result2 = 14;
                            // 0x313f0
                            return result2;
                        }
                        default: {
                            // 0x313f0
                            return 1;
                        }
                    }
                }
            }
        }
        case 8: {
            uint32_t v7 = a2 & 224; // 0x31454
            if (v7 == 128) {
                // 0x313f0
                return 5;
            }
            char v8 = v7;
            if (v7 < 128) {
                // 0x31464
                result = 1;
                result2 = 3;
                switch (v8) {
                    case 64: {
                        return result2;
                    }
                    case 96: {
                        // 0x313f0
                        return 4;
                    }
                    case 32: {
                        // 0x313f0
                        return 2;
                    }
                    default: {
                        return result;
                    }
                }
            } else {
                // 0x314ec
                result = 8;
                result2 = 7;
                switch (v8) {
                    case -64: {
                        return result2;
                    }
                    case -32: {
                        return result;
                    }
                    case -96: {
                        // 0x313f0
                        return 6;
                    }
                    default: {
                        // 0x313f0
                        return 1;
                    }
                }
            }
        }
        default: {
            return result2;
        }
    }
}

// Address range: 0x31590 - 0x315ec
int32_t function_31590(int32_t * a1, int32_t a2) {
    if (a2 == 0) {
        // 0x315e4
        return 0xffff;
    }
    int32_t v1 = (int32_t)a1;
    int32_t v2 = v1 - 1; // 0x315b8
    v2++;
    int32_t v3 = 255 ^ (int32_t)*(char *)v2; // 0x315c0
    int32_t v4 = 255 ^ (int32_t)*(char *)(v3 + (int32_t)"tq_freezethaw" + 2280); // 0x315d0
    int32_t v5 = (int32_t)*(char *)(v3 + (int32_t)"tq_freezethaw" + 2536); // 0x315d4
    while ((a2 + 0xffff) % 0x10000 + v1 != v2) {
        // 0x315bc
        v2++;
        v3 = v4 ^ (int32_t)*(char *)v2;
        v4 = v5 ^ (int32_t)*(char *)(v3 + (int32_t)"tq_freezethaw" + 2280);
        v5 = (int32_t)*(char *)(v3 + (int32_t)"tq_freezethaw" + 2536);
    }
    // 0x315dc
    return 256 * v5 | v4;
}

// Address range: 0x315ec - 0x316b0
int32_t function_315ec(int32_t a1, int32_t a2) {
    int32_t v1 = 28; // 0x315f4
    int32_t v2 = 1; // 0x315f4
    if (a2 != 0) {
        char v3 = *(char *)a1; // 0x3162c
        int32_t v4 = v3 > -1;
        bool v5 = false; // 0x3166c
        if (a2 == 1) {
            // .thread30
            v1 = v3 > -1 ? 24 : 28;
            v2 = v4;
        } else {
            int32_t v6 = 1;
            int32_t v7 = 1;
            int32_t v8 = v4;
            int32_t v9 = a1 + (int32_t)v5;
            int32_t v10 = v5 ? 128 : 64;
            int32_t v11 = (1 ^ v4) % 256; // 0x31664
            int32_t v12 = v5 ? 1 : 2; // 0x31630
            int32_t v13 = 2; // 0x31634
            int32_t v14 = 1 ^ (int32_t)((v10 & (int32_t)*(char *)v9) != 0);
            int32_t v15 = v14 % 256; // 0x31648
            v5 = v12 == 8;
            int32_t v16 = v13; // 0x3166c
            int32_t v17 = v12; // 0x3166c
            int32_t v18 = v7; // 0x3166c
            int32_t v19 = v6; // 0x3166c
            int32_t v20 = v9; // 0x3166c
            int32_t v21 = v10; // 0x3166c
            while (v13 != a2) {
                // 0x3161c
                v6 = v8;
                v7 = v11;
                v8 = v15;
                v9 = v20 + (int32_t)v5;
                v10 = v5 ? 128 : v21 / 2;
                v11 = (v19 ^ v14) % 256;
                v12 = v5 ? 1 : v17 + 1;
                v13 = v16 + 1;
                v14 = v18 ^ (int32_t)((v10 & (int32_t)*(char *)v9) != 0);
                v15 = v14 % 256;
                v5 = v12 == 8;
                v16 = v13;
                v17 = v12;
                v18 = v7;
                v19 = v6;
                v20 = v9;
                v21 = v10;
            }
            int32_t v22 = v11 == 0 ? v7 == 0 ? 0 : 16 : v7 == 0 ? 8 : 24;
            int32_t v23 = v15 == v6 ? v22 : v22 | 4;
            v1 = v23;
            v2 = v15;
            if (v8 == 0) {
                // 0x31694
                return v23 | (int32_t)(v15 != 0);
            }
        }
    }
    // 0x31694
    return v1 | 2 | (int32_t)(v2 != 0);
}

// Address range: 0x316b0 - 0x316d8
int32_t function_316b0(int32_t * a1, int32_t * a2, uint32_t a3) {
    int32_t result = (int32_t)a1;
    if (a3 < 4) {
        // 0x316d4
        return result;
    }
    int32_t v1 = (int32_t)a2;
    int32_t result2 = result - 4; // 0x316bc
    int32_t v2 = v1 + 4; // 0x316c0
    int32_t v3 = llvm_bswap_i32(*(int32_t *)v1); // 0x316c8
    result2 += 4;
    *(int32_t *)result2 = v3;
    while (v2 != (a3 & -4) + v1) {
        int32_t v4 = v2;
        v2 = v4 + 4;
        v3 = llvm_bswap_i32(*(int32_t *)v4);
        result2 += 4;
        *(int32_t *)result2 = v3;
    }
    // 0x316d4
    return result2;
}

// Address range: 0x316d8 - 0x31720
int32_t function_316d8(int32_t a1, int32_t a2) {
    if (a2 == 0) {
        // 0x31718
        return 0;
    }
    int32_t v1 = a1; // 0x316ec
    int32_t v2 = -1; // 0x316ec
    unsigned char v3 = *(char *)v1; // 0x316f0
    v1++;
    int32_t v4 = *(int32_t *)(4 * (v2 % 256 ^ (int32_t)v3) + (int32_t)"tq_freezethaw" + 2792); // 0x31704
    v2 = v4 ^ v2 / 256;
    while (v1 != a2 + a1) {
        // 0x316f0
        v3 = *(char *)v1;
        v1++;
        v4 = *(int32_t *)(4 * (v2 % 256 ^ (int32_t)v3) + (int32_t)"tq_freezethaw" + 2792);
        v2 = v4 ^ v2 / 256;
    }
    // 0x31710
    return -1 - v2;
}

// Address range: 0x31720 - 0x31980
int32_t function_31720(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    unsigned char v2 = *(char *)&g221; // 0x31738
    int32_t v3 = v2; // 0x31740
    char v4; // 0x31720
    int32_t v5; // 0x31720
    if (v2 == 0) {
        unsigned char v6 = *(char *)&g60; // 0x3174c
        v3 = v6;
        if (v6 == 0) {
            // 0x3193c
            v3 = &g290;
            v4 = 0;
            v5 = v1;
            if (g290 > 4) {
                goto lab_0x31758;
            } else {
                goto lab_0x317c8;
            }
        } else {
            goto lab_0x31758;
        }
    } else {
        goto lab_0x31758;
    }
  lab_0x318c8:;
    // 0x318c8
    int32_t v7; // 0x31720
    int32_t v8 = *(int32_t *)(v7 + 4); // 0x318c8
    int32_t * v9 = (int32_t *)(v7 + 8);
    int32_t str; // bp-2088, 0x31720
    snprintf((char *)&str, 2048, "board id = %d, chain num = %d\n", v8, *v9);
    int32_t v10 = function_2e584(5, &str, 0); // 0x318ec
    int32_t * v11 = v9; // 0x318f4
    int32_t v12 = v10; // 0x318f4
    char v13 = *(char *)&g221; // 0x318f4
    goto lab_0x31818;
  lab_0x31818:;
    int32_t v14 = v12;
    int32_t * v15 = v11;
    int32_t v16 = v13;
    int32_t v17 = *v15; // 0x31818
    int32_t v18 = v14; // 0x31820
    int32_t v19 = v16; // 0x31820
    if (v17 != 0) {
        int32_t v20 = v7 + 12;
        int32_t v21 = v14; // 0x31720
        int32_t v22 = v17; // 0x31720
        int32_t v23 = 0;
        int32_t v24; // 0x31720
        uint32_t v25; // 0x31720
        int32_t v26; // 0x31848
        if (v16 == 0) {
            // 0x31830
            v25 = v22;
            v24 = v21;
            v26 = v23;
            while (*(char *)&g60 == 0 && g290 <= 4) {
                // 0x31848
                v26++;
                v18 = v24;
                v19 = 0;
                if (v25 >= v26 != v25 != v26) {
                    // break (via goto) -> 0x31854
                    goto lab_0x31854;
                }
            }
        }
        int32_t v27 = *(int32_t *)(v20 + 4 * v23); // 0x31904
        int32_t v28 = v23 + 1; // 0x31910
        snprintf((char *)&str, 2048, "\tchain id = %d\n", v27);
        int32_t v29 = function_2e584(5, &str, 0); // 0x31924
        uint32_t v30 = *v15; // 0x31928
        int32_t v31 = (int32_t)*(char *)&g221; // 0x3192c
        v18 = v29;
        v19 = v31;
        while (v30 >= v28 == (v30 != v28)) {
            // 0x31828
            v23 = v28;
            if (v31 == 0) {
                // 0x31830
                v25 = v30;
                v24 = v29;
                v26 = v23;
                while (*(char *)&g60 == 0 && g290 <= 4) {
                    // 0x31848
                    v26++;
                    v18 = v24;
                    v19 = 0;
                    if (v25 >= v26 != v25 != v26) {
                        // break (via goto) -> 0x31854
                        goto lab_0x31854;
                    }
                }
            }
            // 0x318f8
            v27 = *(int32_t *)(v20 + 4 * v23);
            v28 = v23 + 1;
            snprintf((char *)&str, 2048, "\tchain id = %d\n", v27);
            v29 = function_2e584(5, &str, 0);
            v30 = *v15;
            v31 = (int32_t)*(char *)&g221;
            v18 = v29;
            v19 = v31;
        }
    }
  lab_0x31854:;
    int32_t v32 = v18;
    int32_t v33; // 0x31720
    int32_t v34 = v33 + 1; // 0x31858
    int32_t v35 = v32; // 0x31864
    int32_t v36 = v19; // 0x31864
    int32_t v37 = v7 + 72; // 0x31864
    v33 = v34;
    int32_t result = v32; // 0x31864
    int32_t v38 = v19; // 0x31864
    if (v32 >= v34 != v32 != v34) {
        // break -> 0x31868
        goto lab_0x31868;
    }
    goto lab_0x317f8;
  lab_0x31758:
    // 0x31758
    function_11fc4(&str, (int32_t)"==========================capability start==========================\n", 70, v3);
    int32_t v39 = function_2e584(5, &str, 0); // 0x3177c
    char v40 = *(char *)&g221; // 0x31780
    v4 = v40;
    v5 = v39;
    if ((*(char *)&g60 || v40) != 0 || g290 > 4) {
        // 0x317a0
        snprintf((char *)&str, 2048, "board num = %d\n", v39);
        int32_t v41 = function_2e584(5, &str, 0); // 0x317c4
        v4 = *(char *)&g221;
        v5 = v41;
    }
    goto lab_0x317c8;
  lab_0x317c8:;
    int32_t v42 = v4; // 0x317cc
    result = 0;
    v38 = v42;
    if (v5 != 0) {
        // 0x317f8
        v35 = v5;
        v36 = v42;
        v37 = v1;
        v33 = 0;
        while (true) {
          lab_0x317f8:
            // 0x317f8
            v7 = v37;
            if (v36 == 0) {
                // 0x31800
                if (*(char *)&g60 != 0 || g290 > 4) {
                    goto lab_0x318c8;
                } else {
                    // 0x31800
                    v11 = (int32_t *)(v7 + 8);
                    v12 = v35;
                    v13 = 0;
                    goto lab_0x31818;
                }
            } else {
                goto lab_0x318c8;
            }
        }
    }
  lab_0x31868:;
    int32_t v43 = v38; // 0x3186c
    if (v38 == 0) {
        unsigned char v44 = *(char *)&g60; // 0x31878
        v43 = v44;
        if (v44 == 0) {
            // 0x31884
            v43 = g290;
            if (g290 < 5) {
                // 0x318bc
                return result;
            }
        }
    }
    // 0x31898
    function_11fc4(&str, (int32_t)"==========================capability end============================\n", 70, v43);
    // 0x318bc
    return function_2e584(5, &str, 0);
}

// Address range: 0x31980 - 0x31bac
int32_t function_31980(int32_t * str4, int32_t a2) {
    // 0x31980
    int32_t str3; // bp-2088, 0x31980
    int32_t v1 = &str3;
    int32_t str; // bp-2108, 0x31980
    int32_t v2 = &str;
    int32_t v3 = 0;
    int32_t v4 = v3 + 1; // 0x319b0
    int32_t v5; // 0x31980
    int32_t v6; // 0x31980
    int32_t v7; // 0x31980
    int32_t v8; // 0x31980
    int32_t v9; // 0x31980
    int32_t v10; // 0x31980
    int32_t v11; // 0x31980
    int32_t v12; // bp-2084, 0x31980
    int32_t v13; // bp-2087, 0x31980
    int32_t v14; // 0x31a9c
    int32_t v15; // 0x31aa8
    int32_t v16; // 0x31aac
    int32_t v17; // 0x31b94
    int32_t v18; // 0x31af0
    int32_t v19; // 0x31afc
    int32_t v20; // 0x31b18
    int32_t v21; // 0x31b2c
    int32_t v22; // 0x31b38
    int32_t v23; // 0x31b3c
    int32_t v24; // 0x31b58
    int32_t str2; // 0x31a54
    int32_t v25; // 0x31a58
    int32_t v26; // 0x31a6c
    int32_t v27; // 0x31a88
    if (function_1e29c(v3) != 0) {
        // 0x319f0
        str3 = 123;
        memset(&v12, 0, 2044);
        str = 0;
        sprintf((char *)&str, "Chain%d:{", v4);
        str2 = function_1203c((int32_t)&v13, v2);
        v25 = g62;
        v26 = 0x3c00 * v3;
        v27 = v25 - 1 + -60 * ((v25 + (int32_t)(-0x77777777 * (int64_t)v25 / 0x100000000) >> 5) - (v25 >> 31));
        v5 = v27;
        v10 = v5 < 0 ? v5 + 60 : v5;
        v14 = v5 - 1;
        v16 = *(int32_t *)(8 * (v10 + v26) + (int32_t)&g81);
        v7 = v16;
        while (v14 != v27 - a2) {
            // 0x31a90
            v5 = v14;
            v10 = v5 < 0 ? v5 + 60 : v5;
            v14 = v5 - 1;
            v15 = *(int32_t *)(8 * (v10 + v26) + (int32_t)&g81);
            v16 = v15 + v7;
            v7 = v16;
        }
        // 0x31ab4
        sprintf((char *)&str, "N%d=%d", 0, v16);
        strcpy((char *)str2, (char *)&str);
        v9 = 1;
        if (function_1e0f0() >= 2) {
            v18 = g62;
            v19 = 60 * v9 + v26;
            v20 = v18 - 1 + -60 * ((v18 + (int32_t)(-0x77777777 * (int64_t)v18 / 0x100000000) >> 5) - (v18 >> 31));
            v6 = v20;
            v11 = v6 < 0 ? v6 + 60 : v6;
            v21 = v6 - 1;
            v23 = *(int32_t *)(8 * (v19 + v11) + (int32_t)&g81);
            v8 = v23;
            while (v20 - a2 != v21) {
                // 0x31b20
                v6 = v21;
                v11 = v6 < 0 ? v6 + 60 : v6;
                v21 = v6 - 1;
                v22 = *(int32_t *)(8 * (v19 + v11) + (int32_t)&g81);
                v23 = v22 + v8;
                v8 = v23;
            }
            // 0x31b44
            sprintf((char *)&str, ",N%d=%d", v9, v23);
            v24 = v9 + 1;
            strcat((char *)&str3, (char *)&str);
            v9 = v24;
            while (function_1e0f0() > v24) {
                // 0x31af0
                v18 = g62;
                v19 = 60 * v9 + v26;
                v20 = v18 - 1 + -60 * ((v18 + (int32_t)(-0x77777777 * (int64_t)v18 / 0x100000000) >> 5) - (v18 >> 31));
                v6 = v20;
                v11 = v6 < 0 ? v6 + 60 : v6;
                v21 = v6 - 1;
                v23 = *(int32_t *)(8 * (v19 + v11) + (int32_t)&g81);
                v8 = v23;
                while (v20 - a2 != v21) {
                    // 0x31b20
                    v6 = v21;
                    v11 = v6 < 0 ? v6 + 60 : v6;
                    v21 = v6 - 1;
                    v22 = *(int32_t *)(8 * (v19 + v11) + (int32_t)&g81);
                    v23 = v22 + v8;
                    v8 = v23;
                }
                // 0x31b44
                sprintf((char *)&str, ",N%d=%d", v9, v23);
                v24 = v9 + 1;
                strcat((char *)&str3, (char *)&str);
                v9 = v24;
            }
        }
        // 0x31b74
        v17 = strlen((char *)&str3) + v1;
        *(int16_t *)v17 = 0x2c7d;
        *(char *)(v17 + 2) = 0;
        strcat((char *)str4, (char *)&str3);
    }
    while (v4 != 4) {
        // 0x319ac
        v3 = v4;
        v4 = v3 + 1;
        if (function_1e29c(v3) != 0) {
            // 0x319f0
            str3 = 123;
            memset(&v12, 0, 2044);
            str = 0;
            sprintf((char *)&str, "Chain%d:{", v4);
            str2 = function_1203c((int32_t)&v13, v2);
            v25 = g62;
            v26 = 0x3c00 * v3;
            v27 = v25 - 1 + -60 * ((v25 + (int32_t)(-0x77777777 * (int64_t)v25 / 0x100000000) >> 5) - (v25 >> 31));
            v5 = v27;
            v10 = v5 < 0 ? v5 + 60 : v5;
            v14 = v5 - 1;
            v16 = *(int32_t *)(8 * (v10 + v26) + (int32_t)&g81);
            v7 = v16;
            while (v14 != v27 - a2) {
                // 0x31a90
                v5 = v14;
                v10 = v5 < 0 ? v5 + 60 : v5;
                v14 = v5 - 1;
                v15 = *(int32_t *)(8 * (v10 + v26) + (int32_t)&g81);
                v16 = v15 + v7;
                v7 = v16;
            }
            // 0x31ab4
            sprintf((char *)&str, "N%d=%d", 0, v16);
            strcpy((char *)str2, (char *)&str);
            v9 = 1;
            if (function_1e0f0() >= 2) {
                v18 = g62;
                v19 = 60 * v9 + v26;
                v20 = v18 - 1 + -60 * ((v18 + (int32_t)(-0x77777777 * (int64_t)v18 / 0x100000000) >> 5) - (v18 >> 31));
                v6 = v20;
                v11 = v6 < 0 ? v6 + 60 : v6;
                v21 = v6 - 1;
                v23 = *(int32_t *)(8 * (v19 + v11) + (int32_t)&g81);
                v8 = v23;
                while (v20 - a2 != v21) {
                    // 0x31b20
                    v6 = v21;
                    v11 = v6 < 0 ? v6 + 60 : v6;
                    v21 = v6 - 1;
                    v22 = *(int32_t *)(8 * (v19 + v11) + (int32_t)&g81);
                    v23 = v22 + v8;
                    v8 = v23;
                }
                // 0x31b44
                sprintf((char *)&str, ",N%d=%d", v9, v23);
                v24 = v9 + 1;
                strcat((char *)&str3, (char *)&str);
                v9 = v24;
                while (function_1e0f0() > v24) {
                    // 0x31af0
                    v18 = g62;
                    v19 = 60 * v9 + v26;
                    v20 = v18 - 1 + -60 * ((v18 + (int32_t)(-0x77777777 * (int64_t)v18 / 0x100000000) >> 5) - (v18 >> 31));
                    v6 = v20;
                    v11 = v6 < 0 ? v6 + 60 : v6;
                    v21 = v6 - 1;
                    v23 = *(int32_t *)(8 * (v19 + v11) + (int32_t)&g81);
                    v8 = v23;
                    while (v20 - a2 != v21) {
                        // 0x31b20
                        v6 = v21;
                        v11 = v6 < 0 ? v6 + 60 : v6;
                        v21 = v6 - 1;
                        v22 = *(int32_t *)(8 * (v19 + v11) + (int32_t)&g81);
                        v23 = v22 + v8;
                        v8 = v23;
                    }
                    // 0x31b44
                    sprintf((char *)&str, ",N%d=%d", v9, v23);
                    v24 = v9 + 1;
                    strcat((char *)&str3, (char *)&str);
                    v9 = v24;
                }
            }
            // 0x31b74
            v17 = strlen((char *)&str3) + v1;
            *(int16_t *)v17 = 0x2c7d;
            *(char *)(v17 + 2) = 0;
            strcat((char *)str4, (char *)&str3);
        }
    }
    int32_t result = strlen((char *)str4) + (int32_t)str4; // 0x319dc
    *(char *)(result - 1) = 0;
    return result;
}

// Address range: 0x31bac - 0x31c64
int32_t function_31bac(void) {
    int32_t v1 = 0;
    int32_t v2 = 0;
    int32_t v3 = v1; // 0x31bd4
    int32_t v4; // bp-2068, 0x31bac
    int32_t v5; // 0x31c1c
    uint32_t v6; // 0x31c28
    if (function_1e29c(v2) != 0) {
        // 0x31c10
        v5 = function_18654(v2, (int32_t)*(char *)&g414, &v4);
        v3 = v1;
        if (v5 == 0) {
            // 0x31c28
            v6 = v4;
            v3 = v1 < v6 ? v6 : v1;
        }
    }
    int32_t v7 = v3;
    int32_t v8 = v2 + 1; // 0x31bd8
    while (v8 != 4) {
        // 0x31bc8
        v1 = v7;
        v2 = v8;
        v3 = v1;
        if (function_1e29c(v2) != 0) {
            // 0x31c10
            v5 = function_18654(v2, (int32_t)*(char *)&g414, &v4);
            v3 = v1;
            if (v5 == 0) {
                // 0x31c28
                v6 = v4;
                v3 = v1 < v6 ? v6 : v1;
            }
        }
        // 0x31bd8
        v7 = v3;
        v8 = v2 + 1;
    }
    char * v9 = g289; // 0x31bec
    if (v9 >= (char *)4 == (v9 != (char *)4)) {
        // 0x31c38
        int32_t str; // bp-2064, 0x31bac
        snprintf((char *)&str, 2048, "max voltage in eeprom = %d\n", v7);
        function_2e584(4, &str, 0);
    }
    // 0x31bf8
    return v7 == 0 ? -1 : v7;
}

// Address range: 0x31c64 - 0x31cac
int32_t function_31c64(int32_t a1, int32_t a2, int32_t * a3, int32_t * a4) {
    char * v1 = (char *)0x73696854; // bp-2056, 0x31c80
    return function_2e584(3, (int32_t *)&v1, 0);
}

// Address range: 0x31cac - 0x31d38
int32_t function_31cac(void) {
    char * v1 = g289; // 0x31cbc
    if (v1 >= (char *)3 == (v1 != (char *)3)) {
        char * v2 = (char *)0x2a2a2a2a; // bp-2056, 0x31d14
        function_2e584(3, (int32_t *)&v2, 0);
    }
    int32_t v3 = 0;
    if (function_1e29c(v3) != 0) {
        // 0x31cf8
        function_46900(v3);
    }
    int32_t v4 = v3 + 1; // 0x31cdc
    while (v4 != 4) {
        // 0x31ccc
        v3 = v4;
        if (function_1e29c(v3) != 0) {
            // 0x31cf8
            function_46900(v3);
        }
        // 0x31cdc
        v4 = v3 + 1;
    }
    // 0x31ce8
    function_194dc();
    return function_447d8();
}

// Address range: 0x31d38 - 0x31d48
int32_t function_31d38(void) {
    // 0x31d38
    return g63;
}

// Address range: 0x31d48 - 0x31d58
int32_t function_31d48(void) {
    // 0x31d48
    return g64;
}

// Address range: 0x31d58 - 0x31f84
int32_t function_31d58(int32_t a1, char * a2) {
    // 0x31d58
    g63 = a1;
    char * v1 = g289; // 0x31d80
    char * str; // bp-2072, 0x31d58
    int32_t v2; // 0x31d58
    if (a2 == NULL) {
        if (v1 >= (char *)3 == (v1 != (char *)3)) {
            // 0x31ea8
            snprintf((char *)&str, 2048, "%s\n");
            v2 = function_2e584(3, (int32_t *)&str, 0);
            goto lab_0x31dd0;
        } else {
            goto lab_0x31e30;
        }
    } else {
        if (v1 == (char *)3 || v1 < (char *)3) {
            goto lab_0x31e30;
        } else {
            int32_t v3 = (int32_t)v1; // 0x31da8
            bool v4 = true; // 0x31da8
            if (a1 == 17 || a1 < 17) {
                v3 = *(int32_t *)(4 * a1 + ((int32_t)&g244 | 0x66c0));
                v4 = (a1 & 0x40000000) != 0;
            }
            char * v5 = v4 == (a1 != 17) ? NULL : (char *)v3; // 0x31dbc
            snprintf((char *)&str, 2048, "%s: %s\n", v5, a2);
            v2 = function_2e584(3, (int32_t *)&str, 0);
            goto lab_0x31dd0;
        }
    }
  lab_0x31e30:;
    int32_t v6 = a1; // 0x31e38
    int32_t v7 = a1; // 0x31e38
    if (a1 == 3) {
        // 0x31e3c
        return 3;
    }
    goto lab_0x31ddc;
  lab_0x31dd0:
    // 0x31dd0
    v6 = v2;
    v7 = g63;
    int32_t result = v2; // 0x31dd8
    int32_t v8 = g63; // 0x31dd8
    if (a1 == 3) {
        goto lab_0x31de0;
    } else {
        goto lab_0x31ddc;
    }
  lab_0x31ddc:
    // 0x31ddc
    g64 = a1;
    result = v6;
    v8 = v7;
    goto lab_0x31de0;
  lab_0x31de0:
    // 0x31de0
    g482 = v8 - 4;
    switch (v8) {
        case 4: {
        }
        case 5: {
        }
        case 7: {
        }
        case 8: {
        }
        case 9: {
        }
        case 10: {
        }
        case 12: {
        }
        case 14: {
        }
        case 15: {
        }
        case 16: {
        }
        case 17: {
            char * v9 = g289; // 0x31e48
            if (v9 != (char *)1 && v9 != NULL) {
                // 0x31e54
                snprintf((char *)&str, 2048, "%s: %s\n", "stop_mining", a2);
                function_2e584(1, (int32_t *)&str, 0);
            }
            // 0x31e80
            function_15150();
            function_27ff8();
            function_27f58();
            function_27eb8();
            return function_42784(function_42728(function_31cac()));
        }
        case 6: {
        }
        case 11: {
        }
        case 13: {
            char * v10 = g289; // 0x31ee8
            if (v10 == (char *)1 || v10 == NULL) {
                // branch -> 0x31f24
            } else {
                // 0x31ef8
                snprintf((char *)&str, 2048, "%s: %s\n", "stop_mining_and_restart", a2);
                function_2e584(1, (int32_t *)&str, 0);
            }
            int32_t * v11 = (int32_t *)&str;
            function_15150();
            function_27ff8();
            function_27f58();
            function_27eb8();
            int32_t v12 = function_31cac(); // 0x31f34
            function_42784(function_42728(v12));
            str = (char *)0x74736572;
            function_2e584(0, v11, 0);
            __assert_fail("0", "driver-btm-api.c", 152, "stop_mining_and_restart");
            return &g488;
        }
    }
    // 0x31e3c
    return result;
}

// Address range: 0x31f90 - 0x32010
int32_t function_31f90(int32_t a1) {
    char * v1 = g289; // 0x31fa4
    if (v1 >= (char *)3 == (v1 != (char *)3)) {
        // 0x31fe4
        int32_t str; // bp-2056, 0x31f90
        snprintf((char *)&str, 2048, "Chain %d PIC reset failed.\n", a1);
        function_2e584(3, &str, 0);
    }
    // 0x31fb0
    function_1e200(a1, 0);
    function_356c4(4, a1);
    function_31d58(8, "PIC reset failed.\n");
    return -1;
}

// Address range: 0x32010 - 0x3204c
int32_t function_32010(uint32_t a1) {
    uint32_t v1 = a1 % 256; // 0x32014
    if (function_191dc(v1) == 0) {
        // 0x32044
        return function_31f90(a1);
    }
    // 0x32030
    function_19214(a1);
    function_46900(v1);
    return 0;
}

// Address range: 0x3204c - 0x3208c
int32_t function_3204c(void) {
    int32_t v1 = 0;
    int32_t v2 = 0;
    int32_t v3 = v1; // 0x32064
    if (function_1e29c(v2) != 0) {
        // 0x3207c
        v3 = function_32010(v2) | v1;
    }
    int32_t result = v3;
    int32_t v4 = v2 + 1; // 0x32068
    while (v4 != 4) {
        // 0x32058
        v1 = result;
        v2 = v4;
        v3 = v1;
        if (function_1e29c(v2) != 0) {
            // 0x3207c
            v3 = function_32010(v2) | v1;
        }
        // 0x32068
        result = v3;
        v4 = v2 + 1;
    }
    // 0x32074
    return result;
}

// Address range: 0x3208c - 0x3218c
int32_t function_3208c(void) {
    int32_t v1 = g294; // 0x32098
    bool v2; // 0x3208c
    bool v3; // 0x3208c
    bool v4; // 0x3208c
    int32_t result2; // 0x3208c
    float32_t v5; // 0x3208c
    int32_t v6; // 0x3208c
    if (v1 == 2) {
        int32_t v7 = 0;
        int32_t v8 = 0; // 0x320f0
        int32_t v9; // 0x32178
        int32_t v10; // 0x3217c
        int32_t v11; // 0x32160
        if (function_1e29c(v7) != 0) {
            // 0x32160
            v11 = function_1e0f0();
            v8 = v11;
            if (v11 >= 1) {
                // 0x3216c
                v9 = 4 * (v11 + 256 * v7) + (int32_t)&g86;
                v10 = 1024 * v7 + (int32_t)&g86;
                *(int32_t *)v10 = g65;
                v10 += 4;
                v8 = v9;
                while (v10 != v9) {
                    // 0x3217c
                    *(int32_t *)v10 = g65;
                    v10 += 4;
                    v8 = v9;
                }
            }
        }
        int32_t v12 = v7 + 1; // 0x320f4
        while (v12 != 4) {
            // 0x320e4
            v7 = v12;
            v8 = 0;
            if (function_1e29c(v7) != 0) {
                // 0x32160
                v11 = function_1e0f0();
                v8 = v11;
                if (v11 >= 1) {
                    // 0x3216c
                    v9 = 4 * (v11 + 256 * v7) + (int32_t)&g86;
                    v10 = 1024 * v7 + (int32_t)&g86;
                    *(int32_t *)v10 = g65;
                    v10 += 4;
                    v8 = v9;
                    while (v10 != v9) {
                        // 0x3217c
                        *(int32_t *)v10 = g65;
                        v10 += 4;
                        v8 = v9;
                    }
                }
            }
            // 0x320f4
            v12 = v7 + 1;
        }
        float32_t v13 = __asm_vldr_8(g285); // 0x32108
        __asm_vcmpe_f32_10(v13, 0);
        __asm_vmrs(v6, v6);
        result2 = v8;
        v5 = v13;
        v2 = false;
        v4 = true;
        v3 = false;
    } else {
        // 0x320a4
        v5 = __asm_vldr_8(g285);
        v2 = v1 < 2;
        v4 = false;
        v3 = (1 - v1 & v1) < 0;
    }
    // 0x320b8
    __asm_vcmpe_f32_10(v5, 0);
    __asm_vmrs(v6, v6);
    if (v4 || v2 != v3) {
        // 0x32138
        __asm_vldr_8(g296);
        int32_t result = function_1ad08(&g86, g66, 1); // 0x3214c
        float32_t v14 = __asm_vmov_7(result); // 0x32150
        g65 = result;
        __asm_vcvt_f32_u32(v14);
        return result;
    }
    // 0x320c4
    __asm_vcvt_f32_u32(__asm_vldr_8(*(int32_t *)((int32_t)&g62 + 12)));
    return result2;
}

// Address range: 0x3218c - 0x321b8
int32_t function_3218c(uint32_t a1) {
    int32_t result = 1; // 0x3218c
    int32_t v1 = 1; // 0x321a0
    switch (a1) {
        case 0: {
            // 0x321ac
            return 0;
        }
        default: {
            v1 *= 2;
            result = v1;
            while (v1 < a1) {
                // 0x321a0
                v1 *= 2;
                result = v1;
            }
        }
        case 1: {
            // 0x321ac
            return result;
        }
    }
}

// Address range: 0x321b8 - 0x323dc
int32_t function_321b8(int32_t a1, int32_t a2, int32_t a3) {
    if (a1 == 0) {
        goto lab_0x321cc;
    } else {
        // 0x32244
        if (function_1e160() == 0) {
            goto lab_0x321cc;
        } else {
            // 0x32258
            if (function_1e120() == 0) {
                goto lab_0x321cc;
            } else {
                // 0x32264
                function_1e160();
                uint32_t v1 = function_1e130(); // 0x3226c
                switch (v1) {
                    case 0: {
                        goto lab_0x323a0;
                    }
                    case 1: {
                        goto lab_0x32298;
                    }
                    default: {
                        int32_t v2 = 2; // 0x32288
                        int32_t v3 = v2; // 0x32290
                        while (v1 >= v2 == (v1 != v2)) {
                            // 0x32288
                            v2 = 2 * v3;
                            v3 = v2;
                        }
                        // 0x32294
                        function_5faf8();
                        goto lab_0x32298;
                    }
                }
            }
        }
    }
  lab_0x321cc:;
    char * v4 = g289; // 0x321d4
    int32_t result = 0; // 0x321dc
    char * str; // bp-2080, 0x321b8
    if (v4 != (char *)3 && v4 >= (char *)3) {
        // 0x321e0
        str = (char *)0x65746f4e;
        result = function_2e584(3, (int32_t *)&str, 0);
    }
    // 0x32224
    g449 = 0x1ffff;
    // 0x32238
    return result;
  lab_0x323a0:
    // 0x323a0
    __asm_udf(0);
    char * v5 = g289; // 0x323b4
    int32_t result2 = (int32_t)v5; // 0x323b4
    g294 = 2;
    g67 = 1;
    if (v5 != (char *)3 && v5 >= (char *)3) {
        // 0x323d8
        return function_31c64(result2, 1, &g294, &g62);
    }
    // 0x32238
    return result2;
  lab_0x32298:;
    int32_t v6 = function_5faf8(); // 0x322c0
    g449 = v6;
    function_1e160();
    uint32_t v7 = function_1e130(); // 0x322d4
    switch (v7) {
        case 0: {
            goto lab_0x323a0;
        }
        case 1: {
            goto lab_0x32308;
        }
        default: {
            int32_t v8 = 2; // 0x322f0
            int32_t v9 = v8; // 0x322f8
            while (v7 >= v8 == (v7 != v8)) {
                // 0x322f0
                v8 = 2 * v9;
                v9 = v8;
            }
            // 0x322fc
            function_5faf8();
            goto lab_0x32308;
        }
    }
  lab_0x32308:
    // 0x32308
    if ((g436 & 4) != 0 && g442 != 0) {
        g449 = 1000 * (int32_t)(g442 % 256) + (int32_t)g443;
    }
    int32_t v10 = function_44c84(v6); // 0x3233c
    char * v11 = g289; // 0x32348
    int32_t result3 = v10; // 0x32350
    if (v11 != (char *)3 && v11 >= (char *)3) {
        int32_t v12 = function_5faf8(); // 0x32364
        snprintf((char *)&str, 2048, "freq = %d, percent = %d, hcn = %d, timeout = %d\n", a1, a3, v12 * a2);
        result3 = function_2e584(3, (int32_t *)&str, 0);
    }
    // 0x32238
    return result3;
}

// Address range: 0x323dc - 0x324a8
int32_t function_323dc(void) {
    int32_t v1 = 0;
    int32_t v2 = function_1e29c(v1); // 0x32408
    int32_t result = 0; // 0x32410
    int32_t str; // bp-2072, 0x323dc
    char * v3; // 0x32414
    int32_t v4; // 0x3243c
    char * v5; // 0x32468
    int32_t v6; // 0x32478
    if (v2 != 0) {
        // 0x32414
        v3 = g289;
        result = v2;
        if (v3 >= (char *)3 == (v3 != (char *)3)) {
            // 0x32438
            v4 = function_18094(v1);
            snprintf((char *)&str, 2048, "Chain [%d] PCB Version: 0x%04x\n", v1, v4);
            function_2e584(3, &str, 0);
            v5 = g289;
            result = v1;
            if (v5 != (char *)3 && v5 >= (char *)3) {
                // 0x32478
                v6 = function_18128(v1);
                snprintf((char *)&str, 2048, "Chain [%d] BOM Version: 0x%04x\n", v1, v6);
                result = function_2e584(3, &str, 0);
            }
        }
    }
    int32_t v7 = v1 + 1; // 0x32420
    while (v7 != 4) {
        // 0x32404
        v1 = v7;
        v2 = function_1e29c(v1);
        result = 0;
        if (v2 != 0) {
            // 0x32414
            v3 = g289;
            result = v2;
            if (v3 >= (char *)3 == (v3 != (char *)3)) {
                // 0x32438
                v4 = function_18094(v1);
                snprintf((char *)&str, 2048, "Chain [%d] PCB Version: 0x%04x\n", v1, v4);
                function_2e584(3, &str, 0);
                v5 = g289;
                result = v1;
                if (v5 != (char *)3 && v5 >= (char *)3) {
                    // 0x32478
                    v6 = function_18128(v1);
                    snprintf((char *)&str, 2048, "Chain [%d] BOM Version: 0x%04x\n", v1, v6);
                    result = function_2e584(3, &str, 0);
                }
            }
        }
        // 0x32420
        v7 = v1 + 1;
    }
    // 0x3242c
    return result;
}

// Address range: 0x324a8 - 0x32520
int32_t function_324a8(void) {
    // 0x324a8
    int32_t v1; // bp-316, 0x324a8
    function_3fe98(&v1);
    int32_t result = function_31720(&v1); // 0x324bc
    if (v1 == 0) {
        // 0x32518
        return result;
    }
    int32_t v2 = &v1; // 0x324d0
    int32_t v3 = 0; // 0x324d0
    int32_t v4 = v2 + 8; // 0x324d4
    int32_t * v5 = (int32_t *)v4; // 0x324d4
    int32_t v6 = v4; // 0x324e4
    int32_t v7 = result; // 0x324e4
    int32_t v8; // 0x324a8
    uint32_t v9; // 0x324f4
    int32_t v10; // 0x324f8
    int32_t v11; // 0x324ec
    if (*v5 != 0) {
        v11 = v6 + 4;
        v7 = function_1e200(*(int32_t *)v11, 1);
        v9 = *v5;
        v10 = 1;
        v8 = v10;
        v6 = v11;
        while (v9 >= v10 == (v9 != v10)) {
            // 0x324e8
            v11 = v6 + 4;
            v7 = function_1e200(*(int32_t *)v11, 1);
            v9 = *v5;
            v10 = v8 + 1;
            v8 = v10;
            v6 = v11;
        }
    }
    int32_t v12 = v1; // 0x32504
    int32_t result2 = v7;
    v3++;
    v2 += 72;
    while (v12 >= v3 == (v12 != v3)) {
        // 0x324d4
        v4 = v2 + 8;
        v5 = (int32_t *)v4;
        v6 = v4;
        int32_t v13 = result2; // 0x324e4
        if (*v5 != 0) {
            v11 = v6 + 4;
            v7 = function_1e200(*(int32_t *)v11, 1);
            v9 = *v5;
            v10 = 1;
            v8 = v10;
            v6 = v11;
            while (v9 >= v10 == (v9 != v10)) {
                // 0x324e8
                v11 = v6 + 4;
                v7 = function_1e200(*(int32_t *)v11, 1);
                v9 = *v5;
                v10 = v8 + 1;
                v8 = v10;
                v6 = v11;
            }
            // 0x32504
            v12 = v1;
            v13 = v7;
        }
        // 0x32508
        result2 = v13;
        v3++;
        v2 += 72;
    }
    // 0x32518
    return result2;
}

// Address range: 0x32520 - 0x32530
int32_t function_32520(void) {
    // 0x32520
    int32_t v1; // 0x32520
    return function_42778(function_42728(v1));
}

// Address range: 0x32530 - 0x3264c
int32_t function_32530(void) {
    int32_t result = function_36548(); // 0x3253c
    int32_t v1; // 0x32610
    if (g294 == 0) {
        switch (result) {
            case 0: {
                // 0x32610
                v1 = function_42728(result);
                return function_42784(v1);
            }
            case 1: {
                char v2 = g297 ^ 1;
                g297 = v2;
                int32_t v3; // 0x32530
                if (v2 == 0) {
                    // 0x3263c
                    v3 = function_42734(1);
                } else {
                    // 0x32570
                    v3 = function_42728(1);
                }
                char v4 = g297 ^ 1;
                g297 = v4;
                if (v4 == 0) {
                    // 0x32588
                    return function_42784(v3);
                }
                // 0x32608
                return function_42778(v3);
            }
            default: {
                goto lab_0x325f0;
            }
        }
    } else {
        // 0x32590
        g476 = g63;
        switch (g63) {
            case 0: {
                // 0x3261c
                return result;
            }
            case 1: {
                // 0x3261c
                return result;
            }
            case 2: {
                goto lab_0x325f0;
            }
            case 17: {
                // 0x32610
                v1 = function_42728(result);
                return function_42784(v1);
            }
            default: {
                char v5 = g297 ^ 1;
                g297 = v5;
                int32_t v6; // 0x32530
                if (v5 == 0) {
                    // 0x32644
                    v6 = function_42734(result);
                } else {
                    // 0x32634
                    v6 = function_42728(result);
                }
                // 0x32588
                return function_42784(v6);
            }
        }
    }
  lab_0x325f0:;
    int32_t v7 = function_42734(result); // 0x325f0
    char v8 = g297 ^ 1;
    g297 = v8;
    if (v8 == 0) {
        // 0x32588
        return function_42784(v7);
    }
    // 0x32608
    return function_42778(v7);
}

// Address range: 0x3264c - 0x32924
int32_t function_3264c(void) {
    for (int32_t i = 0; i < 4; i++) {
        // 0x32684
        if (function_1e29c(i) != 0) {
            // 0x32880
            function_1e0f0();
            function_1e0f0();
        }
    }
    // 0x326a0
    g62++;
    memset(&g227, 0, 0x2000);
    memset(&g224, 0, 0x2000);
    memset(&g217, 0, 0x2000);
    function_31980(&g227, 10);
    function_31980(&g224, 30);
    function_31980(&g217, 60);
    int32_t v1 = &g80;
    int32_t v2 = 0;
    int32_t v3 = 0x2000;
    int32_t result = 0; // 0x32758
    int32_t v4 = v3; // 0x32758
    int32_t v5; // 0x3264c
    int32_t v6; // 0x3264c
    int32_t v7; // 0x3264c
    int32_t v8; // 0x3264c
    int32_t v9; // 0x3264c
    int32_t v10; // 0x3264c
    int32_t v11; // 0x3264c
    int32_t v12; // 0x3264c
    int32_t v13; // 0x3264c
    int32_t v14; // 0x3264c
    int32_t v15; // 0x3264c
    int32_t v16; // 0x32830
    int32_t v17; // 0x32794
    int32_t v18; // 0x327d4
    int32_t v19; // 0x327d8
    int32_t v20; // 0x327e8
    int32_t * v21; // 0x32858
    int32_t v22; // 0x327f8
    uint32_t v23; // 0x32808
    int32_t v24; // 0x32810
    int32_t v25; // 0x3264c
    int32_t v26; // 0x32818
    if (function_1e29c(v2) != 0) {
        // 0x32778
        v5 = 0;
        if (function_1e0f0() != 0) {
            // 0x32818
            v25 = 0x3c00 * v2;
            v15 = 2048 * v2 + (int32_t)&g426;
            v11 = 0;
            v13 = 0;
            v6 = 0;
            v26 = function_1e100();
            function_5fadc(v11, v26, v3, (int32_t)&g426);
            v16 = v13;
            v7 = v6;
            if (v26 == 0) {
                // 0x32830
                v16 = v13 + 1;
                function_1e820(v2, v6, 32);
                v7 = v16 + v11;
            }
            // 0x32794
            v8 = v7;
            v12 = v16;
            v17 = g62;
            v18 = -60 * ((v17 + (int32_t)(-0x77777777 * (int64_t)v17 / 0x100000000) >> 5) - (v17 >> 31)) + v17;
            v19 = v18 - 1;
            v14 = v19 < 0 ? v18 + 59 : v19;
            v20 = *(int32_t *)(8 * (60 * v11 + v25 + v14) + (int32_t)&g81);
            if (v20 < 2) {
                // 0x3284c
                function_1e820(v2, v8, 120);
                v21 = (int32_t *)(4 * v11 + v1);
                *v21 = *v21 + 1;
            } else {
                // 0x327f4
                function_1e820(v2, v8, 111);
            }
            // 0x327f8
            v22 = v11 + 1;
            *(int32_t *)v15 = 0;
            *(int32_t *)(v15 + 4) = 0;
            v23 = function_1e0f0();
            v24 = v12 + v22;
            v15 += 8;
            v10 = 0;
            v9 = 0;
            v5 = v24;
            while (v23 != v22 && v23 >= v22) {
                // 0x32818
                v11 = v22;
                v13 = v12;
                v6 = v24;
                v26 = function_1e100();
                function_5fadc(v11, v26, v9, v10);
                v16 = v13;
                v7 = v6;
                if (v26 == 0) {
                    // 0x32830
                    v16 = v13 + 1;
                    function_1e820(v2, v6, 32);
                    v7 = v16 + v11;
                }
                // 0x32794
                v8 = v7;
                v12 = v16;
                v17 = g62;
                v18 = -60 * ((v17 + (int32_t)(-0x77777777 * (int64_t)v17 / 0x100000000) >> 5) - (v17 >> 31)) + v17;
                v19 = v18 - 1;
                v14 = v19 < 0 ? v18 + 59 : v19;
                v20 = *(int32_t *)(8 * (60 * v11 + v25 + v14) + (int32_t)&g81);
                if (v20 < 2) {
                    // 0x3284c
                    function_1e820(v2, v8, 120);
                    v21 = (int32_t *)(4 * v11 + v1);
                    *v21 = *v21 + 1;
                } else {
                    // 0x327f4
                    function_1e820(v2, v8, 111);
                }
                // 0x327f8
                v22 = v11 + 1;
                *(int32_t *)v15 = 0;
                *(int32_t *)(v15 + 4) = 0;
                v23 = function_1e0f0();
                v24 = v12 + v22;
                v15 += 8;
                v10 = 0;
                v9 = 0;
                v5 = v24;
            }
        }
        // 0x32868
        result = function_1e820(v2, v5, 0);
        v4 = 0;
    }
    int32_t v27 = v2 + 1; // 0x3275c
    int32_t v28 = v1 + 1024; // 0x32768
    while (v27 != 4) {
        // 0x3274c
        v1 = v28;
        v2 = v27;
        v3 = v4;
        result = 0;
        v4 = v3;
        if (function_1e29c(v2) != 0) {
            // 0x32778
            v5 = 0;
            if (function_1e0f0() != 0) {
                // 0x32818
                v25 = 0x3c00 * v2;
                v15 = 2048 * v2 + (int32_t)&g426;
                v11 = 0;
                v13 = 0;
                v6 = 0;
                v26 = function_1e100();
                function_5fadc(v11, v26, v3, (int32_t)&g426);
                v16 = v13;
                v7 = v6;
                if (v26 == 0) {
                    // 0x32830
                    v16 = v13 + 1;
                    function_1e820(v2, v6, 32);
                    v7 = v16 + v11;
                }
                // 0x32794
                v8 = v7;
                v12 = v16;
                v17 = g62;
                v18 = -60 * ((v17 + (int32_t)(-0x77777777 * (int64_t)v17 / 0x100000000) >> 5) - (v17 >> 31)) + v17;
                v19 = v18 - 1;
                v14 = v19 < 0 ? v18 + 59 : v19;
                v20 = *(int32_t *)(8 * (60 * v11 + v25 + v14) + (int32_t)&g81);
                if (v20 < 2) {
                    // 0x3284c
                    function_1e820(v2, v8, 120);
                    v21 = (int32_t *)(4 * v11 + v1);
                    *v21 = *v21 + 1;
                } else {
                    // 0x327f4
                    function_1e820(v2, v8, 111);
                }
                // 0x327f8
                v22 = v11 + 1;
                *(int32_t *)v15 = 0;
                *(int32_t *)(v15 + 4) = 0;
                v23 = function_1e0f0();
                v24 = v12 + v22;
                v15 += 8;
                v10 = 0;
                v9 = 0;
                v5 = v24;
                while (v23 != v22 && v23 >= v22) {
                    // 0x32818
                    v11 = v22;
                    v13 = v12;
                    v6 = v24;
                    v26 = function_1e100();
                    function_5fadc(v11, v26, v9, v10);
                    v16 = v13;
                    v7 = v6;
                    if (v26 == 0) {
                        // 0x32830
                        v16 = v13 + 1;
                        function_1e820(v2, v6, 32);
                        v7 = v16 + v11;
                    }
                    // 0x32794
                    v8 = v7;
                    v12 = v16;
                    v17 = g62;
                    v18 = -60 * ((v17 + (int32_t)(-0x77777777 * (int64_t)v17 / 0x100000000) >> 5) - (v17 >> 31)) + v17;
                    v19 = v18 - 1;
                    v14 = v19 < 0 ? v18 + 59 : v19;
                    v20 = *(int32_t *)(8 * (60 * v11 + v25 + v14) + (int32_t)&g81);
                    if (v20 < 2) {
                        // 0x3284c
                        function_1e820(v2, v8, 120);
                        v21 = (int32_t *)(4 * v11 + v1);
                        *v21 = *v21 + 1;
                    } else {
                        // 0x327f4
                        function_1e820(v2, v8, 111);
                    }
                    // 0x327f8
                    v22 = v11 + 1;
                    *(int32_t *)v15 = 0;
                    *(int32_t *)(v15 + 4) = 0;
                    v23 = function_1e0f0();
                    v24 = v12 + v22;
                    v15 += 8;
                    v10 = 0;
                    v9 = 0;
                    v5 = v24;
                }
            }
            // 0x32868
            result = function_1e820(v2, v5, 0);
            v4 = 0;
        }
        // 0x3275c
        v27 = v2 + 1;
        v28 = v1 + 1024;
    }
    // 0x3276c
    return result;
}

// Address range: 0x32924 - 0x329dc
int32_t function_32924(int32_t a1) {
    // 0x32924
    function_1ed08();
    function_304d4(10);
    int32_t result = function_1e0f0() - 1; // 0x32944
    int32_t v1 = result % 256; // 0x32948
    if (v1 == 0) {
        // 0x3299c
        return result;
    }
    int32_t v2 = v1;
    function_1e9b4(a1, v2);
    function_2be40(a1, 0);
    int32_t result3 = function_1e67c(a1); // 0x32978
    while (result3 < 1) {
        int32_t v3 = (v2 + 255) % 256; // 0x32954
        int32_t result2 = result3; // 0x32958
        if (v3 == 0) {
            // 0x3299c
            return result2;
        }
        v2 = v3;
        function_1e9b4(a1, v2);
        function_2be40(a1, 0);
        result3 = function_1e67c(a1);
    }
    char * v4 = g289; // 0x32990
    if (v4 >= (char *)3 != v4 != (char *)3) {
        // 0x3299c
        return result3;
    }
    // 0x329a8
    int32_t str; // bp-2064, 0x32924
    snprintf((char *)&str, 2048, "bad asic is %d\n", v2);
    return function_2e584(3, &str, 0);
}

// Address range: 0x329dc - 0x32bd0
int32_t function_329dc(void) {
    int32_t v1 = 0;
    int32_t v2 = 0;
    int32_t v3 = v2; // 0x32a10
    int32_t v4; // 0x329dc
    int32_t v5; // 0x329dc
    int32_t str; // bp-2088, 0x329dc
    int32_t v6; // 0x32ae4
    char * v7; // 0x32b14
    int32_t v8; // 0x32ac8
    char * v9; // 0x32acc
    char * v10; // 0x32a74
    int32_t v11; // 0x32b00
    if (function_1e29c(v1) != 0) {
        v5 = 0;
        function_4594c(v1);
        function_12030(3);
        function_4672c(v1);
        function_304d4(1000);
        if (g413 != 0) {
            // 0x32a74
            v10 = g289;
            if (v10 >= (char *)3 == (v10 != (char *)3)) {
                // 0x32b74
                snprintf((char *)&str, 2048, "pic enabled for chain %d, press anykey to continue...", v1);
                function_2e584(3, &str, 0);
            }
            // 0x32a80
            function_12000(g317);
        }
        // 0x32a88
        function_45990(v1);
        function_304d4(200);
        function_4594c(v1);
        function_12030(1);
        function_45990(v1);
        function_304d4(200);
        function_2be40(v1, 0);
        v8 = function_1e67c(v1);
        v9 = g289;
        if (v9 >= (char *)3 == (v9 != (char *)3)) {
            // 0x32b40
            snprintf((char *)&str, 2048, "Chain[%d]: find %d asic, times %d\n", v1, v8, v5);
            function_2e584(3, &str, 0);
        }
        while (v8 != function_1e0f0()) {
            // 0x32af0
            v6 = v5 + 1;
            function_46900(v1);
            v4 = v6;
            if (v6 == 3) {
                // break -> 0x32afc
                break;
            }
            v5 = v4;
            function_4594c(v1);
            function_12030(3);
            function_4672c(v1);
            function_304d4(1000);
            if (g413 != 0) {
                // 0x32a74
                v10 = g289;
                if (v10 >= (char *)3 == (v10 != (char *)3)) {
                    // 0x32b74
                    snprintf((char *)&str, 2048, "pic enabled for chain %d, press anykey to continue...", v1);
                    function_2e584(3, &str, 0);
                }
                // 0x32a80
                function_12000(g317);
            }
            // 0x32a88
            function_45990(v1);
            function_304d4(200);
            function_4594c(v1);
            function_12030(1);
            function_45990(v1);
            function_304d4(200);
            function_2be40(v1, 0);
            v8 = function_1e67c(v1);
            v9 = g289;
            if (v9 >= (char *)3 == (v9 != (char *)3)) {
                // 0x32b40
                snprintf((char *)&str, 2048, "Chain[%d]: find %d asic, times %d\n", v1, v8, v5);
                function_2e584(3, &str, 0);
            }
        }
        // 0x32afc
        v11 = function_1e67c(v1);
        v3 = v2;
        if (function_1e0f0() != v11) {
            // 0x32b14
            v7 = g289;
            if (v7 >= (char *)3 == (v7 != (char *)3)) {
                // 0x32b9c
                snprintf((char *)&str, 2048, "Chain %d only find %d asic, will power off hash board %d\n", v1, v11, v1);
                function_2e584(3, &str, 0);
            }
            // 0x32b20
            function_46900(v1);
            function_1e200(v1, 0);
            v3 = -1;
        }
    }
    int32_t result = v3;
    int32_t v12 = v1 + 1; // 0x32a14
    while (v12 != 4) {
        // 0x32a04
        v1 = v12;
        v2 = result;
        v3 = v2;
        if (function_1e29c(v1) != 0) {
            v5 = 0;
            function_4594c(v1);
            function_12030(3);
            function_4672c(v1);
            function_304d4(1000);
            if (g413 != 0) {
                // 0x32a74
                v10 = g289;
                if (v10 >= (char *)3 == (v10 != (char *)3)) {
                    // 0x32b74
                    snprintf((char *)&str, 2048, "pic enabled for chain %d, press anykey to continue...", v1);
                    function_2e584(3, &str, 0);
                }
                // 0x32a80
                function_12000(g317);
            }
            // 0x32a88
            function_45990(v1);
            function_304d4(200);
            function_4594c(v1);
            function_12030(1);
            function_45990(v1);
            function_304d4(200);
            function_2be40(v1, 0);
            v8 = function_1e67c(v1);
            v9 = g289;
            if (v9 >= (char *)3 == (v9 != (char *)3)) {
                // 0x32b40
                snprintf((char *)&str, 2048, "Chain[%d]: find %d asic, times %d\n", v1, v8, v5);
                function_2e584(3, &str, 0);
            }
            while (v8 != function_1e0f0()) {
                // 0x32af0
                v6 = v5 + 1;
                function_46900(v1);
                v4 = v6;
                if (v6 == 3) {
                    // break -> 0x32afc
                    break;
                }
                v5 = v4;
                function_4594c(v1);
                function_12030(3);
                function_4672c(v1);
                function_304d4(1000);
                if (g413 != 0) {
                    // 0x32a74
                    v10 = g289;
                    if (v10 >= (char *)3 == (v10 != (char *)3)) {
                        // 0x32b74
                        snprintf((char *)&str, 2048, "pic enabled for chain %d, press anykey to continue...", v1);
                        function_2e584(3, &str, 0);
                    }
                    // 0x32a80
                    function_12000(g317);
                }
                // 0x32a88
                function_45990(v1);
                function_304d4(200);
                function_4594c(v1);
                function_12030(1);
                function_45990(v1);
                function_304d4(200);
                function_2be40(v1, 0);
                v8 = function_1e67c(v1);
                v9 = g289;
                if (v9 >= (char *)3 == (v9 != (char *)3)) {
                    // 0x32b40
                    snprintf((char *)&str, 2048, "Chain[%d]: find %d asic, times %d\n", v1, v8, v5);
                    function_2e584(3, &str, 0);
                }
            }
            // 0x32afc
            v11 = function_1e67c(v1);
            v3 = v2;
            if (function_1e0f0() != v11) {
                // 0x32b14
                v7 = g289;
                if (v7 >= (char *)3 == (v7 != (char *)3)) {
                    // 0x32b9c
                    snprintf((char *)&str, 2048, "Chain %d only find %d asic, will power off hash board %d\n", v1, v11, v1);
                    function_2e584(3, &str, 0);
                }
                // 0x32b20
                function_46900(v1);
                function_1e200(v1, 0);
                v3 = -1;
            }
        }
        // 0x32a14
        result = v3;
        v12 = v1 + 1;
    }
    // 0x32a20
    return result;
}

// Address range: 0x32bd0 - 0x32ca8
int32_t function_32bd0(void) {
    int32_t v1 = function_44b54((int32_t *)&g450, 32); // 0x32bf0
    char * v2 = g289; // 0x32bf4
    int32_t v3 = v1; // 0x32bfc
    int32_t str; // bp-2064, 0x32bd0
    if (v2 >= (char *)3 == (v2 != (char *)3)) {
        // 0x32c78
        snprintf((char *)&str, 2048, "miner ID : %s\n", (char *)&g450);
        v3 = function_2e584(3, &str, 0);
    }
    uint32_t v4 = function_45c98(v3); // 0x32c00
    char * v5 = g289; // 0x32c04
    int32_t v6 = __asm_ubfx(v4, 16, 8); // 0x32c08
    if (v5 != (char *)3 && v5 >= (char *)3) {
        // 0x32c18
        snprintf((char *)&str, 2048, "FPGA Version = 0x%04X\n", v4 % 0x10000);
        function_2e584(3, &str, 0);
    }
    // 0x32c40
    return sprintf((char *)&g415, "%d.%d.%d.%d", v4 % 256, v6, 1, 3);
}

// Address range: 0x32ca8 - 0x32cbc
int32_t function_32ca8(void) {
    // 0x32ca8
    function_302a0(&g68);
    return function_2a578();
}

// Address range: 0x32cc0 - 0x32f3c
int32_t function_32cc0(int32_t * a1, int32_t a2, int32_t a3) {
    unsigned char v1 = *(char *)(a2 + 680); // 0x32cdc
    char v2; // 0x32cc0
    __asm_bfi((int32_t)(unsigned char)v2, (int32_t)v1, 0, 1);
    int16_t v3 = 82; // bp-2184, 0x32d18
    int32_t v4 = 0; // bp-2192, 0x32d1c
    int32_t v5; // bp-2168, 0x32cc0
    function_2f724(&v5, a2 + 1780, 4);
    int32_t v6; // bp-2164, 0x32cc0
    function_2f724(&v6, a2 + 1712, 32);
    int32_t v7; // bp-2128, 0x32cc0
    function_2f724(&v7, a2 + 1792, 4);
    int32_t v8; // bp-2132, 0x32cc0
    function_2f724(&v8, a2 + 1804, 4);
    int32_t * v9 = (int32_t *)(a2 + 1568); // 0x32d8c
    int32_t v10 = *v9; // 0x32d8c
    int32_t v11; // bp-2112, 0x32cc0
    int32_t v12 = &v11; // 0x32d90
    int32_t * v13 = (int32_t *)(a2 + 1572); // 0x32d94
    int32_t v14 = *v13; // 0x32d94
    int32_t v15 = *(int32_t *)(a2 + 632); // 0x32d9c
    v11 = *(int32_t *)(v10 + *(int32_t *)(a2 + 1576));
    v4 = (int32_t)(*(int64_t *)(a2 + 624) / 0x100000000);
    function_11fc4(&v11, (int32_t)&v4, (char)v15, v12);
    int32_t * v16 = (int32_t *)(a2 + 1708); // 0x32dd0
    int32_t v17 = *v16; // 0x32dd0
    int32_t v18 = 32 * v17 + v14; // 0x32dd8
    int32_t size = v18 + 98; // 0x32ddc
    int32_t * mem = malloc(size); // 0x32de4
    int32_t v19 = v12; // 0x32dec
    int32_t v20 = v14; // 0x32dec
    int32_t v21 = v10; // 0x32dec
    int32_t v22 = v17; // 0x32dec
    if (mem == NULL) {
        char * v23 = (char *)0x6c696146; // bp-2088, 0x32f04
        function_2e584(3, (int32_t *)&v23, 1);
        function_2a574();
        v22 = *v16;
        v21 = *v9;
        v20 = *v13;
        v19 = 0x636f6c6c;
    }
    int32_t v24 = (int32_t)mem; // 0x32de4
    memset(mem, 0, size);
    function_11fc4(mem, (int32_t)&v3, 96, v19);
    int32_t v25 = v24 + 96;
    function_11fc4((int32_t *)v25, v21, (char)v20, v19);
    if (v22 >= 1) {
        int32_t v26 = *(int32_t *)(a2 + 676); // 0x32e30
        int32_t v27 = v26; // 0x32e3c
        int32_t v28 = v20 + v25; // 0x32e3c
        int32_t v29 = *(int32_t *)v27; // 0x32e40
        v27 += 4;
        *(int32_t *)v28 = *(int32_t *)v29;
        *(int32_t *)(v28 + 4) = *(int32_t *)(v29 + 4);
        *(int32_t *)(v28 + 8) = *(int32_t *)(v29 + 8);
        *(int32_t *)(v28 + 12) = *(int32_t *)(v29 + 12);
        *(int32_t *)(v28 + 16) = *(int32_t *)(v29 + 16);
        *(int32_t *)(v28 + 20) = *(int32_t *)(v29 + 20);
        *(int32_t *)(v28 + 24) = *(int32_t *)(v29 + 24);
        *(int32_t *)(v28 + 28) = *(int32_t *)(v29 + 28);
        v28 += 32;
        while (v27 != v26 + 4 * v22) {
            // 0x32e40
            v29 = *(int32_t *)v27;
            v27 += 4;
            *(int32_t *)v28 = *(int32_t *)v29;
            *(int32_t *)(v28 + 4) = *(int32_t *)(v29 + 4);
            *(int32_t *)(v28 + 8) = *(int32_t *)(v29 + 8);
            *(int32_t *)(v28 + 12) = *(int32_t *)(v29 + 12);
            *(int32_t *)(v28 + 16) = *(int32_t *)(v29 + 16);
            *(int32_t *)(v28 + 20) = *(int32_t *)(v29 + 20);
            *(int32_t *)(v28 + 24) = *(int32_t *)(v29 + 24);
            *(int32_t *)(v28 + 28) = *(int32_t *)(v29 + 28);
            v28 += 32;
        }
    }
    int32_t v30 = (int32_t)a1;
    int32_t v31 = function_31590(mem, (v18 + 96) % 0x10000); // 0x32ea0
    int32_t v32 = g70; // 0x32ea4
    *(int16_t *)(v25 + v18) = (int16_t)v31;
    g70 = v32 + 1;
    g71 += (int32_t)(v32 == -1);
    int32_t * mem2 = malloc(size); // 0x32ec4
    *a1 = (int32_t)mem2;
    function_11fc4(mem2, v24, (char)size, v30);
    free(v24, v24, size, v30);
    return size;
}

// Address range: 0x32f3c - 0x32f40
int32_t function_32f3c(void) {
    // 0x32f3c
    int32_t result; // 0x32f3c
    return result;
}

// Address range: 0x32f40 - 0x33454
int32_t function_32f40(uint32_t a1) {
    // 0x32f40
    char * str; // bp-2088, 0x32f40
    if ((char)a1 != 82) {
        // 0x32f64
        if (g61 == 0) {
            // 0x32fd8
            return -1;
        }
        // 0x32f6c
        if ((*(char *)&g60 | *(char *)&g221) == 0 != g290 < 7) {
            // 0x32fa8
            snprintf((char *)&str, 2048, "%s: SEND_JOB_TYPE is wrong : 0x%x\n", "dhash_chip_send_job", a1 % 256);
            function_2e584(7, (int32_t *)&str, 0);
        }
        // 0x32fd8
        return -1;
    }
    int32_t v1 = *(int32_t *)(a1 + 4); // 0x32ffc
    int32_t v2 = 0; // 0x33000
    if (g61 == 0) {
        goto lab_0x3306c;
    } else {
        // 0x33004
        if ((*(char *)&g60 | *(char *)&g221) == 0) {
            // 0x3302c
            v2 = g290;
            if (g290 < 7) {
                goto lab_0x3306c;
            } else {
                goto lab_0x33040;
            }
        } else {
            goto lab_0x33040;
        }
    }
  lab_0x3306c:;
    int32_t v3 = v1 + 8; // 0x3306c
    int32_t v4; // 0x32f40
    int32_t v5 = function_11eb0(v3, 1, v4, v2); // 0x33078
    if (v5 == 0) {
        // 0x3329c
        if (g61 == 0) {
            // 0x32fd8
            return -2;
        }
        // 0x332a8
        if ((*(char *)&g60 | *(char *)&g221) == 0 != g290 < 7) {
            // 0x332e4
            snprintf((char *)&str, 2048, "%s: malloc buffer failed.\n", "dhash_chip_send_job");
            function_2e584(7, (int32_t *)&str, 0);
        }
        // 0x32fd8
        return -2;
    }
    // 0x33084
    function_11fc4((int32_t *)v5, a1, (char)v3, v2);
    unsigned char v6 = *(char *)&g72; // 0x33098
    if (v6 == 0) {
        char * v7 = g289; // 0x3331c
        int32_t v8 = a1; // 0x33324
        int32_t v9 = v3; // 0x33324
        int32_t v10 = (int32_t)v7; // 0x33324
        if (v7 != (char *)3 && v7 >= (char *)3) {
            // 0x33328
            str = (char *)0x796c6e6f;
            function_2e584(3, (int32_t *)&str, (int32_t)v6);
            v8 = (int32_t)&str;
            v9 = 0;
            v10 = 0x69736120;
        }
        // 0x33354
        free(v5, v8, v9, v10);
        return 0;
    }
    int32_t v11 = g298; // 0x330b0
    int32_t v12; // 0x32f40
    int32_t v13; // 0x32f40
    int32_t v14; // 0x32f40
    if (*(char *)(v5 + 80) == 0) {
        // 0x33374
        g283 = 1;
        g409 = 0;
        v14 = 1;
        if (v11 == 1) {
            // 0x33354
            free(v5, 1, 0, 1);
            return 0;
        }
        goto lab_0x330e4;
    } else {
        int32_t v15 = *(int32_t *)(v5 + 84); // 0x330bc
        int32_t v16 = *(int32_t *)(v5 + 88); // 0x330c4
        g283 = v15;
        g409 = v16;
        v14 = v15;
        v12 = v11;
        v13 = v16;
        if (v15 == v11) {
            goto lab_0x33100;
        } else {
            goto lab_0x330e4;
        }
    }
  lab_0x33040:
    // 0x33040
    snprintf((char *)&str, 2048, "%s: len = 0x%x\n", "dhash_chip_send_job", v1);
    function_2e584(7, (int32_t *)&str, 0);
    v4 = 0;
    v2 = (int32_t)"dhash_chip_send_job";
    goto lab_0x3306c;
  lab_0x330e4:;
    char * v17 = g289; // 0x330ec
    int32_t v18 = v14; // 0x330f4
    int32_t v19 = (int32_t)v17; // 0x330f4
    if (v17 >= (char *)3 == (v17 != (char *)3)) {
        // 0x333fc
        snprintf((char *)&str, 2048, "Version num %d\n", v14);
        function_2e584(3, (int32_t *)&str, 0);
        v18 = g283;
        v19 = 0;
    }
    // 0x330f8
    g298 = v18;
    v12 = v18;
    v13 = v19;
    goto lab_0x33100;
  lab_0x33100:;
    int32_t v20 = v12 - 4 & -5; // 0x33104
    if (v20 != 0) {
        // 0x33354
        free(v5, v12, v13, v20);
        return 0;
    }
    // 0x33110
    if (g299 != g409) {
        char * v21 = g289; // 0x33128
        int32_t v22 = v12; // 0x33130
        if (v21 >= (char *)3 == (v21 != (char *)3)) {
            // 0x33424
            snprintf((char *)&str, 2048, "Mask num 0x%x\n", g409);
            function_2e584(3, (int32_t *)&str, 0);
            v22 = g283;
        }
        // 0x33134
        g299 = g409;
        function_321b8(g65, v22, 90);
    }
    // 0x33144
    if ((*(char *)(v5 + 9) & 2) != 0) {
        // 0x333ec
        function_44e1c(*(char *)(v5 + 10));
    }
    int32_t v23 = 0; // bp-2168, 0x331f0
    if (g73 == 0) {
        int32_t v24 = function_452d0(function_452b0(*(int32_t *)(v5 + 52)) | 0x10000); // 0x333d0
        function_44794(function_4476c(v24) | 128);
        g73 = 1;
    }
    char * v25 = g289; // 0x331f8
    int32_t v26 = 0; // 0x33200
    int32_t v27 = (int32_t)(*(int64_t *)(v5 + 72) / 0x100000000); // 0x33200
    int32_t v28 = (int32_t)v25; // 0x33200
    if (v25 >= (char *)4 == (v25 != (char *)4)) {
        // 0x3339c
        snprintf((char *)&str, 2048, "start to send job, mid_auto_gen = %d", v23);
        function_2e584(4, (int32_t *)&str, 0);
        v26 = (int32_t)&str;
        v27 = 0;
        v28 = v23;
    }
    // 0x33204
    function_45334(&v23);
    free(v5, v26, v27, v28);
    if (g61 == 0) {
        // 0x33284
        function_302a0(&g68);
        function_304d4(1);
        // 0x32fd8
        return 0;
    }
    // 0x33220
    if ((*(char *)&g60 | *(char *)&g221) == 0 != g290 < 7) {
        // 0x3325c
        snprintf((char *)&str, 2048, "--- %s end\n", "dhash_chip_send_job");
        function_2e584(7, (int32_t *)&str, 0);
    }
    // 0x33284
    function_302a0(&g68);
    function_304d4(1);
    // 0x32fd8
    return 0;
}

// Address range: 0x3345c - 0x33478
int32_t function_3345c(void) {
    // 0x3345c
    function_44ae4();
    function_458e4(15);
    return function_12030(2);
}

// Address range: 0x33478 - 0x33888
int32_t function_33478(int32_t result, int32_t a2) {
    int32_t * v1 = (int32_t *)(a2 + 672); // 0x33478
    int32_t v2 = *v1; // 0x33478
    if (v2 == 0) {
        return result;
    }
    int32_t * v3 = (int32_t *)(a2 + 1708); // 0x334a0
    uint32_t v4 = *v3; // 0x334a0
    int32_t * v5 = (int32_t *)(a2 + 1572); // 0x334a4
    uint32_t v6 = *v5; // 0x334a4
    int32_t * v7 = (int32_t *)(result + 212); // 0x334a8
    int32_t v8; // 0x33478
    int32_t v9 = function_11f94(v7, a2, v8, v2); // 0x334a8
    int32_t v10 = a2; // 0x334b0
    int32_t v11 = v2; // 0x334b0
    int32_t v12; // 0x33478
    char * str; // bp-2088, 0x33478
    if (v9 != 0) {
        // 0x33750
        v11 = *__errno_location();
        snprintf((char *)&str, 2048, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", v11, "driver-btm-api.c", "copy_pool_stratum", 1140);
        function_2e584(3, (int32_t *)&str, 1);
        function_2a574();
        v10 = (int32_t)&str;
        v12 = 1;
    }
    int32_t rwlock = result + 236; // 0x334b4
    int32_t v13 = v10; // 0x334c4
    int32_t v14 = v12; // 0x334c4
    int32_t v15 = v11; // 0x334c4
    if (function_12048(rwlock) != 0) {
        // 0x337a0
        v15 = *__errno_location();
        snprintf((char *)&str, 2048, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", v15, "driver-btm-api.c", "copy_pool_stratum", 1140);
        function_2e584(3, (int32_t *)&str, 1);
        function_2a574();
        v13 = (int32_t)&str;
        v14 = 1;
    }
    int32_t * v16 = (int32_t *)(result + 672); // 0x334c8
    free(*v16, v13, v14, v15);
    int32_t * v17 = (int32_t *)(result + 612); // 0x334d0
    free(*v17, v13, v14, v15);
    int32_t * v18 = (int32_t *)(result + 1568); // 0x334d8
    free(*v18, v13, v14, v15);
    int32_t v19 = v6 & -4;
    int32_t v20 = v6 % 4 == 0 ? v19 : v19 + 4;
    int32_t v21 = function_11eb0(v20, 1, v14, v15); // 0x334f4
    *v18 = v21;
    int32_t v22 = v21; // 0x33500
    int32_t v23 = v15; // 0x33500
    if (v21 == 0) {
        // 0x337f0
        str = (char *)0x6c696146;
        function_2e584(3, (int32_t *)&str, 1);
        function_2a574();
        v22 = *v18;
        v23 = 0;
    }
    int32_t v24 = *(int32_t *)(a2 + 1568); // 0x33508
    function_11fc4((int32_t *)v22, v24, (char)v20, v23);
    int32_t * v25 = (int32_t *)(result + 1708); // 0x33510
    uint32_t v26 = *v25; // 0x33510
    int32_t v27 = v26; // 0x33518
    if (v26 >= 1) {
        int32_t v28 = 0;
        int32_t v29 = *(int32_t *)(result + 676); // 0x33520
        int32_t v30 = v28 + 1; // 0x33528
        free(*(int32_t *)(v29 + 4 * v28), v24, v20, v29);
        uint32_t v31 = *v25; // 0x33530
        v27 = v31;
        while (v31 > v30) {
            // 0x33520
            v28 = v30;
            v29 = *(int32_t *)(result + 676);
            v30 = v28 + 1;
            free(*(int32_t *)(v29 + 4 * v28), v24, v20, v29);
            v31 = *v25;
            v27 = v31;
        }
    }
    int32_t v32 = v24; // 0x33540
    if (v4 != 0) {
        int32_t * v33 = (int32_t *)(result + 676); // 0x3360c
        int32_t v34 = 4 * v4 | 1; // 0x33610
        int32_t v35 = function_1209c(*v33, v34, v20, v27); // 0x33614
        *v33 = v35;
        v32 = v34;
        if (v4 >= 1) {
            int32_t v36 = 0; // 0x33658
            int32_t v37 = 4 * v36; // 0x33638
            *(int32_t *)(v35 + v37) = (int32_t)malloc(32);
            int32_t v38 = *(int32_t *)(*v33 + v37); // 0x33648
            int32_t v39 = v38; // 0x33650
            if (v38 == 0) {
                // 0x336ac
                str = (char *)0x6c696146;
                function_2e584(3, (int32_t *)&str, 1);
                function_2a574();
                v39 = *(int32_t *)(*v33 + v37);
            }
            // 0x33654
            v36++;
            int32_t v40 = *(int32_t *)(*(int32_t *)(a2 + 676) + v37); // 0x33660
            *(int32_t *)v39 = *(int32_t *)v40;
            *(int32_t *)(v39 + 4) = *(int32_t *)(v40 + 4);
            *(int32_t *)(v39 + 8) = *(int32_t *)(v40 + 8);
            *(int32_t *)(v39 + 12) = *(int32_t *)(v40 + 12);
            int32_t v41 = *(int32_t *)(v40 + 28); // 0x33690
            *(int32_t *)(v39 + 16) = *(int32_t *)(v40 + 16);
            *(int32_t *)(v39 + 20) = *(int32_t *)(v40 + 20);
            *(int32_t *)(v39 + 24) = *(int32_t *)(v40 + 24);
            *(int32_t *)(v39 + 28) = v41;
            v32 = v41;
            while (v4 != v36) {
                // 0x33630
                v37 = 4 * v36;
                *(int32_t *)(*v33 + v37) = (int32_t)malloc(32);
                v38 = *(int32_t *)(*v33 + v37);
                v39 = v38;
                if (v38 == 0) {
                    // 0x336ac
                    str = (char *)0x6c696146;
                    function_2e584(3, (int32_t *)&str, 1);
                    function_2a574();
                    v39 = *(int32_t *)(*v33 + v37);
                }
                // 0x33654
                v36++;
                v40 = *(int32_t *)(*(int32_t *)(a2 + 676) + v37);
                *(int32_t *)v39 = *(int32_t *)v40;
                *(int32_t *)(v39 + 4) = *(int32_t *)(v40 + 4);
                *(int32_t *)(v39 + 8) = *(int32_t *)(v40 + 8);
                *(int32_t *)(v39 + 12) = *(int32_t *)(v40 + 12);
                v41 = *(int32_t *)(v40 + 28);
                *(int32_t *)(v39 + 16) = *(int32_t *)(v40 + 16);
                *(int32_t *)(v39 + 20) = *(int32_t *)(v40 + 20);
                *(int32_t *)(v39 + 24) = *(int32_t *)(v40 + 24);
                *(int32_t *)(v39 + 28) = v41;
                v32 = v41;
            }
        }
    }
    // 0x33544
    *(int32_t *)result = v32;
    uint64_t v42 = *(int64_t *)(a2 + 1824); // 0x33554
    *(int32_t *)(result + 1824) = (int32_t)(v42 / 0x100000000);
    *(int32_t *)(result + 1828) = (int32_t)v42;
    *(int32_t *)(result + 1572) = *v5;
    *(int32_t *)(result + 1576) = *(int32_t *)(a2 + 1576);
    *(int32_t *)(result + 632) = *(int32_t *)(a2 + 632);
    *v25 = *v3;
    *v16 = (int32_t)__strdup((char *)*v1);
    *v17 = (int32_t)__strdup((char *)*(int32_t *)(a2 + 612));
    int32_t v43 = result + 1804; // 0x335a4
    int32_t v44 = a2 + 1580; // 0x335ac
    *(int32_t *)v43 = *(int32_t *)(a2 + 1804);
    *(int32_t *)(result + 1808) = *(int32_t *)(a2 + 1808);
    *(int32_t *)(result + 1812) = *(int32_t *)(a2 + 1812);
    function_11fc4((int32_t *)(result + 1580), v44, -128, v43);
    int32_t v45 = v44; // 0x335d8
    int32_t v46 = 128; // 0x335d8
    int32_t v47 = v43; // 0x335d8
    if (pthread_rwlock_unlock((int32_t *)rwlock) != 0) {
        // 0x33838
        v47 = *__errno_location();
        snprintf((char *)&str, 2048, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", v47, "driver-btm-api.c", "copy_pool_stratum", 1178);
        function_2e584(3, (int32_t *)&str, 1);
        function_2a574();
        v45 = (int32_t)&str;
        v46 = 1;
    }
    // 0x335dc
    if (function_11ea4(v7, v45, v46, v47) == 0) {
        // 0x335ec
        return function_2f250();
    }
    int32_t v48 = *__errno_location(); // 0x33718
    snprintf((char *)&str, 2048, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", v48, "driver-btm-api.c", "copy_pool_stratum", 1178);
    function_2e584(3, (int32_t *)&str, 1);
    function_2a574();
    // 0x335ec
    return function_2f250();
}

// Address range: 0x3388c - 0x33950
int32_t function_3388c(void) {
    char * v1 = g289; // 0x338a4
    *(char *)&g302 = g412;
    *(char *)&g301 = g411;
    int16_t str; // bp-2064, 0x3388c
    if (v1 != (char *)3 && v1 >= (char *)3) {
        unsigned char v2 = *(char *)&g300; // 0x338e0
        snprintf((char *)&str, 2048, "pulse_mode = %d, ccdly_sel = %d, pwth_sel = %d\n", (int32_t)v2, (int32_t)g412, (int32_t)g411);
        function_2e584(3, (int32_t *)&str, 0);
    }
    // 0x33914
    str = g300;
    char v3; // 0x3388c
    int32_t v4 = __asm_bfi(__asm_bfi(0, (int32_t)(g300 % 256), 0, 8), (int32_t)(unsigned char)v3, 8, 8); // 0x3393c
    return __asm_bfi(v4, (int32_t)((g300 >> 15) % 256), 16, 8);
}

// Address range: 0x33950 - 0x339ec
int32_t function_33950(void) {
    int32_t v1 = function_3388c(); // 0x33958
    int32_t v2 = __asm_ubfx(v1, 8, 8); // 0x3395c
    int32_t v3 = __asm_ubfx(v1, 16, 8); // 0x33960
    function_1e970();
    function_304d4(200);
    function_1ed08();
    function_304d4(10);
    function_1ef94(255, (char)v1);
    function_304d4(10);
    function_1efe0(255, (char)v2, (char)v3, 0);
    function_304d4(10);
    function_1ead4(255);
    function_304d4(10);
    function_1ea18(255, 0, 1, 3);
    return function_1ea84(255);
}

// Address range: 0x339ec - 0x33e34
int32_t function_339ec(void) {
    char * v1 = g289; // 0x33a04
    g294 = 2;
    g67 = 1;
    char * v2 = v1; // 0x33a28
    char * v3; // 0x339ec
    int32_t v4; // 0x339ec
    char * str; // bp-2072, 0x339ec
    if (v1 >= (char *)3 == (v1 != (char *)3)) {
        // 0x33a60
        int32_t v5; // 0x339ec
        function_31c64(v5, 1, (int32_t *)v1, &g62);
        v2 = g289;
        if (v2 == (char *)3 || v2 < (char *)3) {
            goto lab_0x33a2c;
        } else {
            // 0x33a70
            snprintf((char *)&str, 2048, "Miner compile time: %s type: %s\n", (char *)&g386, (char *)&g387);
            function_2e584(3, (int32_t *)&str, 0);
            char * v6 = g289; // 0x33aac
            v3 = v6;
            v4 = (int32_t)&g388;
            if (*(char *)&g388 == 0) {
                goto lab_0x33af0;
            } else {
                if (v6 == (char *)3 || v6 < (char *)3) {
                    goto lab_0x33a40;
                } else {
                    // 0x33ac8
                    snprintf((char *)&str, 2048, "Miner sn: %s\n", (char *)&g388);
                    function_2e584(3, (int32_t *)&str, 0);
                    v3 = g289;
                    v4 = (int32_t)&g388;
                    goto lab_0x33af0;
                }
            }
        }
    } else {
        goto lab_0x33a2c;
    }
  lab_0x33a2c:
    // 0x33a2c
    v3 = v2;
    v4 = 0;
    if (*(char *)&g388 == 0) {
        goto lab_0x33af0;
    } else {
        goto lab_0x33a40;
    }
  lab_0x33af0:;
    char * v7 = v3;
    if (v7 == (char *)3 || v7 < (char *)3) {
        goto lab_0x33a40;
    } else {
        // 0x33af8
        function_11fc4((int32_t *)&str, (int32_t)"commit version: dd076742 2022-10-27 22:42:25, build by: jenkins 2022-12-06 16:28:38\n", 85, v4);
        function_2e584(3, (int32_t *)&str, 0);
        char * v8 = g289; // 0x33b1c
        if (v8 == (char *)3 || v8 < (char *)3) {
            goto lab_0x33a40;
        } else {
            // 0x33b28
            snprintf((char *)&str, 2048, "opt_multi_version     = %d\n", g283);
            function_2e584(3, (int32_t *)&str, 0);
            char * v9 = g289; // 0x33b58
            if (v9 == (char *)3 || v9 < (char *)3) {
                goto lab_0x33a40;
            } else {
                unsigned char v10 = *(char *)&g284; // 0x33b74
                snprintf((char *)&str, 2048, "opt_bitmain_ab        = %d\n", (int32_t)v10);
                function_2e584(3, (int32_t *)&str, 0);
                char * v11 = g289; // 0x33b94
                if (v11 == (char *)3 || v11 < (char *)3) {
                    goto lab_0x33a40;
                } else {
                    // 0x33ba0
                    snprintf((char *)&str, 2048, "mid_auto_gen          = %d\n", 0);
                    function_2e584(3, (int32_t *)&str, 0);
                    char * v12 = g289; // 0x33bc8
                    if (v12 == (char *)3 || v12 < (char *)3) {
                        goto lab_0x33a40;
                    } else {
                        // 0x33bd4
                        snprintf((char *)&str, 2048, "opt_bitmain_work_mode = %d\n", g414);
                        function_2e584(3, (int32_t *)&str, 0);
                        if (function_3fd74() != 0) {
                            // 0x33a50
                            return 0;
                        }
                        goto lab_0x33c10;
                    }
                }
            }
        }
    }
  lab_0x33a40:
    // 0x33a40
    if (function_3fd74() != 0) {
        // 0x33a50
        return 0;
    }
    goto lab_0x33c10;
  lab_0x33c10:
    // 0x33c10
    function_140e4();
    int32_t v13 = function_141b4(); // 0x33c14
    int32_t v14 = function_42778(function_42728(v13)); // 0x33c1c
    *(char *)&g284 = 1;
    function_24364(v14);
    function_25284();
    if (function_1b4ac() != 0) {
        // 0x33a50
        return 0;
    }
    // 0x33c44
    function_3345c();
    function_13fb0(100);
    function_32bd0();
    function_45b74();
    function_324a8();
    if (function_1e28c() == 0) {
        char * v15 = g289; // 0x33c68
        if (v15 != (char *)3 && v15 >= (char *)3) {
            // 0x33c78
            str = (char *)0x63206f4e;
            function_2e584(3, (int32_t *)&str, 0);
        }
        // 0x33a50
        return -1;
    }
    // 0x33cb8
    if ((*(char *)&g60 | *(char *)&g221) == 0 != g290 < 5) {
        // 0x33cf4
        snprintf((char *)&str, 2048, "chain num = %d", function_1e28c());
        function_2e584(5, (int32_t *)&str, 0);
    }
    int32_t v16 = 0;
    if (function_1e29c(v16) != 0) {
        // 0x33e18
        function_4fa0c(v16);
    }
    int32_t v17 = v16 + 1; // 0x33d2c
    while (v17 != 4) {
        // 0x33d24
        v16 = v17;
        if (function_1e29c(v16) != 0) {
            // 0x33e18
            function_4fa0c(v16);
        }
        // 0x33d3c
        v17 = v16 + 1;
    }
    // 0x33d44
    function_17ef8();
    if (function_17f7c() == 0) {
        // 0x33d54
        if (g294 == 1) {
            char * v18 = g289; // 0x33e24
            if (v18 == (char *)3 || v18 < (char *)3) {
                // 0x33a50
                return 0;
            }
            // 0x33d78
            str = (char *)0x74786946;
            function_2e584(3, (int32_t *)&str, 0);
            goto lab_0x33dac;
        } else {
            // 0x33d60
            function_356c4(3, 255);
            char * v19 = g289; // 0x33d6c
            if (v19 == (char *)3 || v19 < (char *)3) {
                goto lab_0x33dac;
            } else {
                // 0x33d78
                str = (char *)0x74786946;
                function_2e584(3, (int32_t *)&str, 0);
                goto lab_0x33dac;
            }
        }
    } else {
        goto lab_0x33dac;
    }
  lab_0x33dac:
    // 0x33dac
    if (g294 != 0 || function_36218() == 0 || function_17f90() != 0) {
        // 0x33a50
        return 0;
    }
    char * v20 = g289; // 0x33dd0
    if (v20 != (char *)3 && v20 >= (char *)3) {
        // 0x33ddc
        str = (char *)0x656e694d;
        function_2e584(3, (int32_t *)&str, 0);
    }
    // 0x33a50
    return 0;
}

// Address range: 0x33e34 - 0x3403c
int32_t function_33e34(void) {
    // 0x33e34
    function_323dc();
    function_446dc();
    int32_t result = function_13da4(4000, 1); // 0x33e50
    if (result != 0) {
        // 0x33f3c
        return result;
    }
    char * v1 = g289; // 0x33e64
    int32_t v2; // 0x33e34
    int32_t v3; // 0x33e34
    int32_t v4; // 0x33e34
    int32_t v5; // 0x33e34
    int32_t result2; // 0x33e34
    char * str; // bp-2064, 0x33e34
    if (v1 >= (char *)3 == (v1 != (char *)3)) {
        // 0x33f70
        str = (char *)0x206e6146;
        int32_t v6 = (int32_t)&str; // 0x33f8c
        function_2e584(3, (int32_t *)&str, 0);
        int32_t v7 = function_3204c(); // 0x33fa4
        v2 = v6;
        v4 = 0;
        v3 = v6;
        v5 = 0;
        result2 = v7;
        if (v7 == 0) {
            goto lab_0x33e7c;
        } else {
            goto lab_0x33f4c;
        }
    } else {
        int32_t v8 = function_3204c(); // 0x33e70
        v2 = 1;
        v3 = 1;
        result2 = v8;
        if (v8 == 0) {
            goto lab_0x33e7c;
        } else {
            goto lab_0x33f4c;
        }
    }
  lab_0x33e7c:
    // 0x33e7c
    function_27940();
    function_14fa4();
    unsigned char v9 = *(char *)&g287; // 0x33e8c
    int32_t v10; // 0x33e34
    if (v9 == 0) {
        // 0x33e98
        if (g74 > 0) {
            int32_t v11 = function_19698(g74, v2, v4, &g62, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488); // 0x33fb4
            v10 = v11;
            goto lab_0x33fbc;
        } else {
            goto lab_0x33eac;
        }
    } else {
        int32_t v12 = v9; // 0x33e8c
        int32_t v13 = function_1e0c0(); // 0x34014
        int32_t v14 = function_11eec(v13, "BHB28601", v4, v12) == 0 ? 1900 : 1500;
        int32_t v15 = function_19698(v14, (int32_t)"BHB28601", v4, (int32_t *)v12, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488); // 0x34030
        v10 = v15;
        goto lab_0x33fbc;
    }
  lab_0x33f4c:
    // 0x33f4c
    v2 = v3;
    v4 = v5;
    if (function_1e28c() == 0 || g294 == 0) {
        // 0x33f3c
        return result2;
    }
    goto lab_0x33e7c;
  lab_0x33eac:;
    char * v16 = g289; // 0x33eac
    if (v16 >= (char *)3 == (v16 != (char *)3)) {
        // 0x33fe4
        snprintf((char *)&str, 2048, "start up min temp by 75a = %d", function_1572c());
        function_2e584(3, (int32_t *)&str, 0);
    }
    // 0x33eb8
    function_448c8();
    function_449e0();
    function_44a50();
    function_304d4(10);
    function_28138(0x1c200);
    function_304d4(10);
    int32_t v17 = function_329dc(); // 0x33ee0
    int32_t result3; // 0x33e34
    if (v17 != 0) {
        // 0x33eec
        result3 = v17;
        if (function_1e28c() == 0 || g294 == 0) {
            // 0x33f3c
            return result3;
        }
    }
    // 0x33f0c
    function_33950();
    g338 = 0;
    g340 = 0;
    g339 = 0;
    // 0x33f3c
    return 0;
  lab_0x33fbc:
    // 0x33fbc
    if (v10 != 0) {
        // 0x33fc4
        function_356c4(12, 0);
        function_31d58(9, "get power type version failed!");
        int32_t v18; // 0x33e34
        result3 = v18;
        int32_t result4 = result3;
        return result4;
    }
    goto lab_0x33eac;
}

// Address range: 0x3403c - 0x34680
int32_t function_3403c(void) {
    // 0x3403c
    float64_t v1; // 0x3403c
    float64_t v2 = __asm_vpush(v1); // 0x34044
    int32_t v3 = function_3388c(); // 0x3406c
    int32_t v4 = __asm_ubfx(v3, 8, 8); // 0x34074
    int32_t v5 = __asm_ubfx(v3, 16, 8); // 0x3407c
    float32_t v6 = __asm_vldr_8(0x463e2000); // 0x34080
    function_1629c();
    int32_t v7 = 0; // 0x34094
    int32_t v8 = 0; // 0x34094
    while (true) {
        int32_t v9 = v8;
        int32_t v10 = v7;
        if (function_1e29c(v9) != 0) {
            // 0x340e0
            function_1f0e0(v9, 1, 0, (int32_t)g66);
            int32_t * v11 = (int32_t *)(0x100000 * v9 + (int32_t)&g240);
            int32_t v12 = 256 * v9;
            *(char *)&g418 = 1;
            function_2bdd0();
            memset(v11, 0, (int32_t)&g1);
            int32_t v13 = function_1e0f0(); // 0x34140
            int32_t v14 = 0; // 0x3414c
            int32_t v15; // 0x3403c
            int32_t v16; // 0x3403c
            int32_t v17; // 0x3403c
            int32_t v18; // 0x3403c
            int32_t v19; // 0x3403c
            int32_t v20; // 0x3403c
            int32_t v21; // 0x3403c
            int32_t v22; // 0x3403c
            int32_t v23; // 0x3403c
            int32_t v24; // 0x3403c
            int32_t v25; // 0x3403c
            int32_t v26; // 0x3403c
            int32_t str; // bp-2088, 0x3403c
            int32_t v27; // bp-2096, 0x3403c
            int32_t v28; // 0x3417c
            int32_t v29; // 0x34198
            uint32_t v30; // 0x342b0
            int32_t v31; // 0x341d4
            uint32_t v32; // 0x341e0
            int32_t v33; // 0x342c4
            int32_t v34; // 0x341ec
            char * v35; // 0x341f4
            int32_t v36; // 0x341f4
            unsigned char v37; // 0x34200
            int32_t v38; // 0x341d8
            int32_t v39; // 0x34210
            int32_t v40; // 0x34220
            int16_t * v41; // 0x34228
            unsigned char v42; // 0x34234
            int32_t v43; // 0x34238
            int32_t v44; // 0x3425c
            uint16_t v45; // 0x34260
            int32_t v46; // 0x34278
            if (v13 >= 1) {
                v28 = function_1e160() * v14;
                function_50da8(v9, v28);
                function_302a0(&v27);
                v21 = &g1;
                function_11f94(&g416, v28, v21, v14);
                v29 = *(int32_t *)((int32_t)&g232 + 8);
                v22 = v29;
                v17 = v28;
                v20 = v21;
                v24 = v29;
                if (v29 >= 1) {
                    v31 = v22 - 1;
                    *(int32_t *)((int32_t)&g232 + 8) = v31;
                    v32 = *(int32_t *)((int32_t)&g232 + 4) + 1;
                    if ((v32 & 0x20000000) != 0 == (v32 != 510) || v32 == 510 || v32 < 510) {
                        v26 = (v32 & 0x20000000) != 0 == (v32 != 510) ? 0 : v32;
                        *(int32_t *)((int32_t)&g232 + 4) = v26;
                    }
                    v34 = 8 * v32;
                    v35 = (char *)(v34 + (int32_t)&g232 + 11);
                    v36 = (int32_t)*v35;
                    v16 = 0;
                    v19 = v36;
                    v23 = v31;
                    if (v9 == v36) {
                        // 0x34200
                        v37 = *(char *)(v34 + (int32_t)&g232 + 10);
                        v16 = 0;
                        v19 = v9;
                        v23 = v37;
                        if (v37 == 64) {
                            // 0x3420c
                            v39 = *(int32_t *)(v34 + (int32_t)&g232 + 4);
                            function_1e160();
                            v40 = function_5faf8();
                            v41 = (int16_t *)(v34 + (int32_t)&g232 + 6);
                            v42 = *v35;
                            v43 = __asm_ubfx((int32_t)*v41, 0, 10);
                            *(int16_t *)(4 * (v43 + 1024 * (v40 + v12)) + (int32_t)&g240 + 2) = (int16_t)v39;
                            function_1e160();
                            v44 = function_5faf8();
                            v45 = *v41;
                            v46 = 4 * (__asm_ubfx((int32_t)v45, 0, 10) + 1024 * (v44 + 256 * (int32_t)(v42 % 4)));
                            *(int16_t *)(v46 + (int32_t)&g240) = 1;
                            v16 = &g240;
                            v19 = 1;
                            v23 = v46;
                        }
                    }
                    // 0x34280
                    v38 = 1;
                    v17 = v16;
                    v20 = v19;
                    v24 = v23;
                    while (v29 != v38) {
                        // 0x341c4
                        v31 = *(int32_t *)((int32_t)&g232 + 8) - 1;
                        *(int32_t *)((int32_t)&g232 + 8) = v31;
                        v32 = *(int32_t *)((int32_t)&g232 + 4) + 1;
                        if ((v32 & 0x20000000) != 0 == (v32 != 510) || v32 == 510 || v32 < 510) {
                            v26 = (v32 & 0x20000000) != 0 == (v32 != 510) ? 0 : v32;
                            *(int32_t *)((int32_t)&g232 + 4) = v26;
                        }
                        v34 = 8 * v32;
                        v35 = (char *)(v34 + (int32_t)&g232 + 11);
                        v36 = (int32_t)*v35;
                        v16 = 0;
                        v19 = v36;
                        v23 = v31;
                        if (v9 == v36) {
                            // 0x34200
                            v37 = *(char *)(v34 + (int32_t)&g232 + 10);
                            v16 = 0;
                            v19 = v9;
                            v23 = v37;
                            if (v37 == 64) {
                                // 0x3420c
                                v39 = *(int32_t *)(v34 + (int32_t)&g232 + 4);
                                function_1e160();
                                v40 = function_5faf8();
                                v41 = (int16_t *)(v34 + (int32_t)&g232 + 6);
                                v42 = *v35;
                                v43 = __asm_ubfx((int32_t)*v41, 0, 10);
                                *(int16_t *)(4 * (v43 + 1024 * (v40 + v12)) + (int32_t)&g240 + 2) = (int16_t)v39;
                                function_1e160();
                                v44 = function_5faf8();
                                v45 = *v41;
                                v46 = 4 * (__asm_ubfx((int32_t)v45, 0, 10) + 1024 * (v44 + 256 * (int32_t)(v42 % 4)));
                                *(int16_t *)(v46 + (int32_t)&g240) = 1;
                                v16 = &g240;
                                v19 = 1;
                                v23 = v46;
                            }
                        }
                        // 0x34280
                        v38++;
                        v17 = v16;
                        v20 = v19;
                        v24 = v23;
                    }
                }
                // 0x34290
                v25 = v24;
                v21 = v20;
                function_11ea4(&g416, v17, v21, v25);
                usleep(1000);
                function_302a0(&str);
                v30 = function_30578(&str, &v27);
                v15 = &v27;
                while (v30 < 100) {
                    // 0x34190
                    function_11f94(&g416, v15, v21, v25);
                    v29 = *(int32_t *)((int32_t)&g232 + 8);
                    v22 = v29;
                    v17 = v15;
                    v20 = v21;
                    v24 = v29;
                    if (v29 >= 1) {
                        v31 = v22 - 1;
                        *(int32_t *)((int32_t)&g232 + 8) = v31;
                        v32 = *(int32_t *)((int32_t)&g232 + 4) + 1;
                        if ((v32 & 0x20000000) != 0 == (v32 != 510) || v32 == 510 || v32 < 510) {
                            v26 = (v32 & 0x20000000) != 0 == (v32 != 510) ? 0 : v32;
                            *(int32_t *)((int32_t)&g232 + 4) = v26;
                        }
                        v34 = 8 * v32;
                        v35 = (char *)(v34 + (int32_t)&g232 + 11);
                        v36 = (int32_t)*v35;
                        v16 = 0;
                        v19 = v36;
                        v23 = v31;
                        if (v9 == v36) {
                            // 0x34200
                            v37 = *(char *)(v34 + (int32_t)&g232 + 10);
                            v16 = 0;
                            v19 = v9;
                            v23 = v37;
                            if (v37 == 64) {
                                // 0x3420c
                                v39 = *(int32_t *)(v34 + (int32_t)&g232 + 4);
                                function_1e160();
                                v40 = function_5faf8();
                                v41 = (int16_t *)(v34 + (int32_t)&g232 + 6);
                                v42 = *v35;
                                v43 = __asm_ubfx((int32_t)*v41, 0, 10);
                                *(int16_t *)(4 * (v43 + 1024 * (v40 + v12)) + (int32_t)&g240 + 2) = (int16_t)v39;
                                function_1e160();
                                v44 = function_5faf8();
                                v45 = *v41;
                                v46 = 4 * (__asm_ubfx((int32_t)v45, 0, 10) + 1024 * (v44 + 256 * (int32_t)(v42 % 4)));
                                *(int16_t *)(v46 + (int32_t)&g240) = 1;
                                v16 = &g240;
                                v19 = 1;
                                v23 = v46;
                            }
                        }
                        // 0x34280
                        v38 = 1;
                        v17 = v16;
                        v20 = v19;
                        v24 = v23;
                        while (v29 != v38) {
                            // 0x341c4
                            v31 = *(int32_t *)((int32_t)&g232 + 8) - 1;
                            *(int32_t *)((int32_t)&g232 + 8) = v31;
                            v32 = *(int32_t *)((int32_t)&g232 + 4) + 1;
                            if ((v32 & 0x20000000) != 0 == (v32 != 510) || v32 == 510 || v32 < 510) {
                                v26 = (v32 & 0x20000000) != 0 == (v32 != 510) ? 0 : v32;
                                *(int32_t *)((int32_t)&g232 + 4) = v26;
                            }
                            v34 = 8 * v32;
                            v35 = (char *)(v34 + (int32_t)&g232 + 11);
                            v36 = (int32_t)*v35;
                            v16 = 0;
                            v19 = v36;
                            v23 = v31;
                            if (v9 == v36) {
                                // 0x34200
                                v37 = *(char *)(v34 + (int32_t)&g232 + 10);
                                v16 = 0;
                                v19 = v9;
                                v23 = v37;
                                if (v37 == 64) {
                                    // 0x3420c
                                    v39 = *(int32_t *)(v34 + (int32_t)&g232 + 4);
                                    function_1e160();
                                    v40 = function_5faf8();
                                    v41 = (int16_t *)(v34 + (int32_t)&g232 + 6);
                                    v42 = *v35;
                                    v43 = __asm_ubfx((int32_t)*v41, 0, 10);
                                    *(int16_t *)(4 * (v43 + 1024 * (v40 + v12)) + (int32_t)&g240 + 2) = (int16_t)v39;
                                    function_1e160();
                                    v44 = function_5faf8();
                                    v45 = *v41;
                                    v46 = 4 * (__asm_ubfx((int32_t)v45, 0, 10) + 1024 * (v44 + 256 * (int32_t)(v42 % 4)));
                                    *(int16_t *)(v46 + (int32_t)&g240) = 1;
                                    v16 = &g240;
                                    v19 = 1;
                                    v23 = v46;
                                }
                            }
                            // 0x34280
                            v38++;
                            v17 = v16;
                            v20 = v19;
                            v24 = v23;
                        }
                    }
                    // 0x34290
                    v25 = v24;
                    v21 = v20;
                    function_11ea4(&g416, v17, v21, v25);
                    usleep(1000);
                    function_302a0(&str);
                    v30 = function_30578(&str, &v27);
                    v15 = &v27;
                }
                // 0x342bc
                v33 = v14 + 1;
                v14 = v33;
                v18 = v13;
                while (v13 != v33) {
                    // 0x3416c
                    v28 = function_1e160() * v14;
                    function_50da8(v9, v28);
                    function_302a0(&v27);
                    function_11f94(&g416, v28, v18, v14);
                    v29 = *(int32_t *)((int32_t)&g232 + 8);
                    v22 = v29;
                    v17 = v28;
                    v20 = v18;
                    v24 = v29;
                    if (v29 >= 1) {
                        v31 = v22 - 1;
                        *(int32_t *)((int32_t)&g232 + 8) = v31;
                        v32 = *(int32_t *)((int32_t)&g232 + 4) + 1;
                        if ((v32 & 0x20000000) != 0 == (v32 != 510) || v32 == 510 || v32 < 510) {
                            v26 = (v32 & 0x20000000) != 0 == (v32 != 510) ? 0 : v32;
                            *(int32_t *)((int32_t)&g232 + 4) = v26;
                        }
                        v34 = 8 * v32;
                        v35 = (char *)(v34 + (int32_t)&g232 + 11);
                        v36 = (int32_t)*v35;
                        v16 = 0;
                        v19 = v36;
                        v23 = v31;
                        if (v9 == v36) {
                            // 0x34200
                            v37 = *(char *)(v34 + (int32_t)&g232 + 10);
                            v16 = 0;
                            v19 = v9;
                            v23 = v37;
                            if (v37 == 64) {
                                // 0x3420c
                                v39 = *(int32_t *)(v34 + (int32_t)&g232 + 4);
                                function_1e160();
                                v40 = function_5faf8();
                                v41 = (int16_t *)(v34 + (int32_t)&g232 + 6);
                                v42 = *v35;
                                v43 = __asm_ubfx((int32_t)*v41, 0, 10);
                                *(int16_t *)(4 * (v43 + 1024 * (v40 + v12)) + (int32_t)&g240 + 2) = (int16_t)v39;
                                function_1e160();
                                v44 = function_5faf8();
                                v45 = *v41;
                                v46 = 4 * (__asm_ubfx((int32_t)v45, 0, 10) + 1024 * (v44 + 256 * (int32_t)(v42 % 4)));
                                *(int16_t *)(v46 + (int32_t)&g240) = 1;
                                v16 = &g240;
                                v19 = 1;
                                v23 = v46;
                            }
                        }
                        // 0x34280
                        v38 = 1;
                        v17 = v16;
                        v20 = v19;
                        v24 = v23;
                        while (v29 != v38) {
                            // 0x341c4
                            v31 = *(int32_t *)((int32_t)&g232 + 8) - 1;
                            *(int32_t *)((int32_t)&g232 + 8) = v31;
                            v32 = *(int32_t *)((int32_t)&g232 + 4) + 1;
                            if ((v32 & 0x20000000) != 0 == (v32 != 510) || v32 == 510 || v32 < 510) {
                                v26 = (v32 & 0x20000000) != 0 == (v32 != 510) ? 0 : v32;
                                *(int32_t *)((int32_t)&g232 + 4) = v26;
                            }
                            v34 = 8 * v32;
                            v35 = (char *)(v34 + (int32_t)&g232 + 11);
                            v36 = (int32_t)*v35;
                            v16 = 0;
                            v19 = v36;
                            v23 = v31;
                            if (v9 == v36) {
                                // 0x34200
                                v37 = *(char *)(v34 + (int32_t)&g232 + 10);
                                v16 = 0;
                                v19 = v9;
                                v23 = v37;
                                if (v37 == 64) {
                                    // 0x3420c
                                    v39 = *(int32_t *)(v34 + (int32_t)&g232 + 4);
                                    function_1e160();
                                    v40 = function_5faf8();
                                    v41 = (int16_t *)(v34 + (int32_t)&g232 + 6);
                                    v42 = *v35;
                                    v43 = __asm_ubfx((int32_t)*v41, 0, 10);
                                    *(int16_t *)(4 * (v43 + 1024 * (v40 + v12)) + (int32_t)&g240 + 2) = (int16_t)v39;
                                    function_1e160();
                                    v44 = function_5faf8();
                                    v45 = *v41;
                                    v46 = 4 * (__asm_ubfx((int32_t)v45, 0, 10) + 1024 * (v44 + 256 * (int32_t)(v42 % 4)));
                                    *(int16_t *)(v46 + (int32_t)&g240) = 1;
                                    v16 = &g240;
                                    v19 = 1;
                                    v23 = v46;
                                }
                            }
                            // 0x34280
                            v38++;
                            v17 = v16;
                            v20 = v19;
                            v24 = v23;
                        }
                    }
                    // 0x34290
                    v25 = v24;
                    v21 = v20;
                    function_11ea4(&g416, v17, v21, v25);
                    usleep(1000);
                    function_302a0(&str);
                    v30 = function_30578(&str, &v27);
                    v15 = &v27;
                    while (v30 < 100) {
                        // 0x34190
                        function_11f94(&g416, v15, v21, v25);
                        v29 = *(int32_t *)((int32_t)&g232 + 8);
                        v22 = v29;
                        v17 = v15;
                        v20 = v21;
                        v24 = v29;
                        if (v29 >= 1) {
                            v31 = v22 - 1;
                            *(int32_t *)((int32_t)&g232 + 8) = v31;
                            v32 = *(int32_t *)((int32_t)&g232 + 4) + 1;
                            if ((v32 & 0x20000000) != 0 == (v32 != 510) || v32 == 510 || v32 < 510) {
                                v26 = (v32 & 0x20000000) != 0 == (v32 != 510) ? 0 : v32;
                                *(int32_t *)((int32_t)&g232 + 4) = v26;
                            }
                            v34 = 8 * v32;
                            v35 = (char *)(v34 + (int32_t)&g232 + 11);
                            v36 = (int32_t)*v35;
                            v16 = 0;
                            v19 = v36;
                            v23 = v31;
                            if (v9 == v36) {
                                // 0x34200
                                v37 = *(char *)(v34 + (int32_t)&g232 + 10);
                                v16 = 0;
                                v19 = v9;
                                v23 = v37;
                                if (v37 == 64) {
                                    // 0x3420c
                                    v39 = *(int32_t *)(v34 + (int32_t)&g232 + 4);
                                    function_1e160();
                                    v40 = function_5faf8();
                                    v41 = (int16_t *)(v34 + (int32_t)&g232 + 6);
                                    v42 = *v35;
                                    v43 = __asm_ubfx((int32_t)*v41, 0, 10);
                                    *(int16_t *)(4 * (v43 + 1024 * (v40 + v12)) + (int32_t)&g240 + 2) = (int16_t)v39;
                                    function_1e160();
                                    v44 = function_5faf8();
                                    v45 = *v41;
                                    v46 = 4 * (__asm_ubfx((int32_t)v45, 0, 10) + 1024 * (v44 + 256 * (int32_t)(v42 % 4)));
                                    *(int16_t *)(v46 + (int32_t)&g240) = 1;
                                    v16 = &g240;
                                    v19 = 1;
                                    v23 = v46;
                                }
                            }
                            // 0x34280
                            v38 = 1;
                            v17 = v16;
                            v20 = v19;
                            v24 = v23;
                            while (v29 != v38) {
                                // 0x341c4
                                v31 = *(int32_t *)((int32_t)&g232 + 8) - 1;
                                *(int32_t *)((int32_t)&g232 + 8) = v31;
                                v32 = *(int32_t *)((int32_t)&g232 + 4) + 1;
                                if ((v32 & 0x20000000) != 0 == (v32 != 510) || v32 == 510 || v32 < 510) {
                                    v26 = (v32 & 0x20000000) != 0 == (v32 != 510) ? 0 : v32;
                                    *(int32_t *)((int32_t)&g232 + 4) = v26;
                                }
                                v34 = 8 * v32;
                                v35 = (char *)(v34 + (int32_t)&g232 + 11);
                                v36 = (int32_t)*v35;
                                v16 = 0;
                                v19 = v36;
                                v23 = v31;
                                if (v9 == v36) {
                                    // 0x34200
                                    v37 = *(char *)(v34 + (int32_t)&g232 + 10);
                                    v16 = 0;
                                    v19 = v9;
                                    v23 = v37;
                                    if (v37 == 64) {
                                        // 0x3420c
                                        v39 = *(int32_t *)(v34 + (int32_t)&g232 + 4);
                                        function_1e160();
                                        v40 = function_5faf8();
                                        v41 = (int16_t *)(v34 + (int32_t)&g232 + 6);
                                        v42 = *v35;
                                        v43 = __asm_ubfx((int32_t)*v41, 0, 10);
                                        *(int16_t *)(4 * (v43 + 1024 * (v40 + v12)) + (int32_t)&g240 + 2) = (int16_t)v39;
                                        function_1e160();
                                        v44 = function_5faf8();
                                        v45 = *v41;
                                        v46 = 4 * (__asm_ubfx((int32_t)v45, 0, 10) + 1024 * (v44 + 256 * (int32_t)(v42 % 4)));
                                        *(int16_t *)(v46 + (int32_t)&g240) = 1;
                                        v16 = &g240;
                                        v19 = 1;
                                        v23 = v46;
                                    }
                                }
                                // 0x34280
                                v38++;
                                v17 = v16;
                                v20 = v19;
                                v24 = v23;
                            }
                        }
                        // 0x34290
                        v25 = v24;
                        v21 = v20;
                        function_11ea4(&g416, v17, v21, v25);
                        usleep(1000);
                        function_302a0(&str);
                        v30 = function_30578(&str, &v27);
                        v15 = &v27;
                    }
                    // 0x342bc
                    v33 = v14 + 1;
                    v14 = v33;
                    v18 = v13;
                }
            }
            int32_t v47 = function_1e0f0(); // 0x342d4
            char * v48; // 0x3403c
            int32_t v49; // 0x3403c
            while (v47 >= 1) {
                int32_t v50 = 0;
                int32_t v51 = 0;
                int32_t v52 = 0;
                uint32_t v53 = function_1e120(); // 0x34300
                int32_t v54 = v52; // 0x34308
                int32_t v55 = v51; // 0x34308
                int32_t v56; // 0x3403c
                int32_t v57; // 0x3403c
                int32_t v58; // 0x3403c
                int32_t v59; // 0x3403c
                int32_t v60; // 0x3403c
                int32_t v61; // 0x3403c
                int32_t v62; // 0x3403c
                int32_t v63; // 0x3403c
                int32_t v64; // 0x3403c
                int32_t v65; // 0x3403c
                uint16_t v66; // 0x3435c
                uint16_t v67; // 0x34368
                char * v68; // 0x3436c
                int32_t v69; // 0x3434c
                char * v70; // 0x343c4
                char * v71; // 0x34464
                if (v53 >= 1) {
                    // 0x3430c
                    v65 = v51;
                    v60 = 0;
                    v59 = 0x1000 * (v50 + v10) + (int32_t)&g240;
                    v66 = *(int16_t *)(v59 + 2);
                    v56 = 0;
                    v61 = v52;
                    v63 = v65;
                    if (v66 == 0) {
                        // 0x34368
                        v67 = *(int16_t *)v59;
                        v68 = g289;
                        if (v67 == 0) {
                            if (v68 >= (char *)3 == (v68 != (char *)3)) {
                                // 0x34514
                                snprintf((char *)&str, 2048, "core %8d in asic %d not returned", v60, v50);
                                function_2e584(3, &str, (int32_t)v67);
                            }
                        } else {
                            if (v68 != (char *)3 && v68 >= (char *)3) {
                                // 0x34380
                                snprintf((char *)&str, 2048, "core %8d data in asic %d is zero", v60, v50);
                                function_2e584(3, &str, (int32_t)v66);
                            }
                        }
                        // 0x34340
                        v56 = 1;
                        v61 = 1;
                        v63 = v65 + 1;
                    }
                    // 0x3434c
                    v64 = v63;
                    v62 = v61;
                    v57 = v56;
                    v69 = v60 + 1;
                    v58 = v59 + 4;
                    while (v53 != v69) {
                        // 0x3435c
                        v65 = v64;
                        v60 = v69;
                        v59 = v58;
                        v66 = *(int16_t *)(v59 + 2);
                        v56 = v57;
                        v61 = v62;
                        v63 = v65;
                        if (v66 == 0) {
                            // 0x34368
                            v67 = *(int16_t *)v59;
                            v68 = g289;
                            if (v67 == 0) {
                                if (v68 >= (char *)3 == (v68 != (char *)3)) {
                                    // 0x34514
                                    snprintf((char *)&str, 2048, "core %8d in asic %d not returned", v60, v50);
                                    function_2e584(3, &str, (int32_t)v67);
                                }
                            } else {
                                if (v68 != (char *)3 && v68 >= (char *)3) {
                                    // 0x34380
                                    snprintf((char *)&str, 2048, "core %8d data in asic %d is zero", v60, v50);
                                    function_2e584(3, &str, (int32_t)v66);
                                }
                            }
                            // 0x34340
                            v56 = 1;
                            v61 = 1;
                            v63 = v65 + 1;
                        }
                        // 0x3434c
                        v64 = v63;
                        v62 = v61;
                        v57 = v56;
                        v69 = v60 + 1;
                        v58 = v59 + 4;
                    }
                    // 0x343b8
                    v54 = v62;
                    v55 = v64;
                    if (v57 != 0) {
                        // 0x343c4
                        v70 = g289;
                        if (v70 >= (char *)3 == (v70 != (char *)3)) {
                            // 0x3457c
                            snprintf((char *)&str, 2048, "reopen asic %d", v50);
                            function_2e584(3, &str, 0);
                        }
                        // 0x343d0
                        function_50cc4(v9, function_1e160() * v50, 1);
                        usleep(0x2710);
                        function_50cc4(v9, function_1e160() * v50, 0);
                        usleep(0x2710);
                        function_515d0(v9, function_1e160() * v50, (char)v3, 0);
                        function_304d4(10);
                        function_51668(v9, function_1e160() * v50, (char)v4, (char)v5, 0);
                        function_50df8(v9, function_1e160() * v50);
                        usleep(0x2710);
                        v71 = g289;
                        if (v71 >= (char *)3 == (v71 != (char *)3)) {
                            // 0x3454c
                            snprintf((char *)&str, 2048, "reset clock asic %d", v50);
                            function_2e584(3, &str, 0);
                        }
                        // 0x34470
                        function_517f8(v9, function_1e160() * v50, 0);
                        function_51794(v9, function_1e160() * v50);
                        usleep(0x186a0);
                        function_517f8(v9, function_1e160() * v50, 1);
                        v54 = v62;
                        v55 = v64;
                    }
                }
                int32_t v72 = v55;
                int32_t v73 = v54;
                int32_t v74 = v50 + 1; // 0x344b8
                while (v47 != v74) {
                    // 0x34300
                    v50 = v74;
                    v51 = v72;
                    v52 = v73;
                    v53 = function_1e120();
                    v54 = v52;
                    v55 = v51;
                    if (v53 >= 1) {
                        // 0x3430c
                        v65 = v51;
                        v60 = 0;
                        v59 = 0x1000 * (v50 + v10) + (int32_t)&g240;
                        v66 = *(int16_t *)(v59 + 2);
                        v56 = 0;
                        v61 = v52;
                        v63 = v65;
                        if (v66 == 0) {
                            // 0x34368
                            v67 = *(int16_t *)v59;
                            v68 = g289;
                            if (v67 == 0) {
                                if (v68 >= (char *)3 == (v68 != (char *)3)) {
                                    // 0x34514
                                    snprintf((char *)&str, 2048, "core %8d in asic %d not returned", v60, v50);
                                    function_2e584(3, &str, (int32_t)v67);
                                }
                            } else {
                                if (v68 != (char *)3 && v68 >= (char *)3) {
                                    // 0x34380
                                    snprintf((char *)&str, 2048, "core %8d data in asic %d is zero", v60, v50);
                                    function_2e584(3, &str, (int32_t)v66);
                                }
                            }
                            // 0x34340
                            v56 = 1;
                            v61 = 1;
                            v63 = v65 + 1;
                        }
                        // 0x3434c
                        v64 = v63;
                        v62 = v61;
                        v57 = v56;
                        v69 = v60 + 1;
                        v58 = v59 + 4;
                        while (v53 != v69) {
                            // 0x3435c
                            v65 = v64;
                            v60 = v69;
                            v59 = v58;
                            v66 = *(int16_t *)(v59 + 2);
                            v56 = v57;
                            v61 = v62;
                            v63 = v65;
                            if (v66 == 0) {
                                // 0x34368
                                v67 = *(int16_t *)v59;
                                v68 = g289;
                                if (v67 == 0) {
                                    if (v68 >= (char *)3 == (v68 != (char *)3)) {
                                        // 0x34514
                                        snprintf((char *)&str, 2048, "core %8d in asic %d not returned", v60, v50);
                                        function_2e584(3, &str, (int32_t)v67);
                                    }
                                } else {
                                    if (v68 != (char *)3 && v68 >= (char *)3) {
                                        // 0x34380
                                        snprintf((char *)&str, 2048, "core %8d data in asic %d is zero", v60, v50);
                                        function_2e584(3, &str, (int32_t)v66);
                                    }
                                }
                                // 0x34340
                                v56 = 1;
                                v61 = 1;
                                v63 = v65 + 1;
                            }
                            // 0x3434c
                            v64 = v63;
                            v62 = v61;
                            v57 = v56;
                            v69 = v60 + 1;
                            v58 = v59 + 4;
                        }
                        // 0x343b8
                        v54 = v62;
                        v55 = v64;
                        if (v57 != 0) {
                            // 0x343c4
                            v70 = g289;
                            if (v70 >= (char *)3 == (v70 != (char *)3)) {
                                // 0x3457c
                                snprintf((char *)&str, 2048, "reopen asic %d", v50);
                                function_2e584(3, &str, 0);
                            }
                            // 0x343d0
                            function_50cc4(v9, function_1e160() * v50, 1);
                            usleep(0x2710);
                            function_50cc4(v9, function_1e160() * v50, 0);
                            usleep(0x2710);
                            function_515d0(v9, function_1e160() * v50, (char)v3, 0);
                            function_304d4(10);
                            function_51668(v9, function_1e160() * v50, (char)v4, (char)v5, 0);
                            function_50df8(v9, function_1e160() * v50);
                            usleep(0x2710);
                            v71 = g289;
                            if (v71 >= (char *)3 == (v71 != (char *)3)) {
                                // 0x3454c
                                snprintf((char *)&str, 2048, "reset clock asic %d", v50);
                                function_2e584(3, &str, 0);
                            }
                            // 0x34470
                            function_517f8(v9, function_1e160() * v50, 0);
                            function_51794(v9, function_1e160() * v50);
                            usleep(0x186a0);
                            function_517f8(v9, function_1e160() * v50, 1);
                            v54 = v62;
                            v55 = v64;
                        }
                    }
                    // 0x344b4
                    v72 = v55;
                    v73 = v54;
                    v74 = v50 + 1;
                }
                char * v75 = g289; // 0x344d4
                int32_t v76 = v72; // 0x344dc
                if (v75 >= (char *)3 == (v75 != (char *)3)) {
                    // 0x34608
                    __asm_vdiv_f32(__asm_vcvt_f32_s32(__asm_vmov_7(v76)), v6);
                    return &str;
                }
                // 0x344e0
                v48 = v75;
                v49 = v72;
                if (v72 < 156) {
                    goto lab_0x345b0;
                }
                // 0x344e8
                usleep((int32_t)&g471);
                if (v73 % 2 == 0) {
                    goto lab_0x340a8;
                }
                *(char *)&g418 = 1;
                function_2bdd0();
                memset(v11, 0, (int32_t)&g1);
                v13 = function_1e0f0();
                v14 = 0;
                if (v13 >= 1) {
                    v28 = function_1e160() * v14;
                    function_50da8(v9, v28);
                    function_302a0(&v27);
                    v21 = &g1;
                    function_11f94(&g416, v28, v21, v14);
                    v29 = *(int32_t *)((int32_t)&g232 + 8);
                    v22 = v29;
                    v17 = v28;
                    v20 = v21;
                    v24 = v29;
                    if (v29 >= 1) {
                        v31 = v22 - 1;
                        *(int32_t *)((int32_t)&g232 + 8) = v31;
                        v32 = *(int32_t *)((int32_t)&g232 + 4) + 1;
                        if ((v32 & 0x20000000) != 0 == (v32 != 510) || v32 == 510 || v32 < 510) {
                            v26 = (v32 & 0x20000000) != 0 == (v32 != 510) ? 0 : v32;
                            *(int32_t *)((int32_t)&g232 + 4) = v26;
                        }
                        v34 = 8 * v32;
                        v35 = (char *)(v34 + (int32_t)&g232 + 11);
                        v36 = (int32_t)*v35;
                        v16 = 0;
                        v19 = v36;
                        v23 = v31;
                        if (v9 == v36) {
                            // 0x34200
                            v37 = *(char *)(v34 + (int32_t)&g232 + 10);
                            v16 = 0;
                            v19 = v9;
                            v23 = v37;
                            if (v37 == 64) {
                                // 0x3420c
                                v39 = *(int32_t *)(v34 + (int32_t)&g232 + 4);
                                function_1e160();
                                v40 = function_5faf8();
                                v41 = (int16_t *)(v34 + (int32_t)&g232 + 6);
                                v42 = *v35;
                                v43 = __asm_ubfx((int32_t)*v41, 0, 10);
                                *(int16_t *)(4 * (v43 + 1024 * (v40 + v12)) + (int32_t)&g240 + 2) = (int16_t)v39;
                                function_1e160();
                                v44 = function_5faf8();
                                v45 = *v41;
                                v46 = 4 * (__asm_ubfx((int32_t)v45, 0, 10) + 1024 * (v44 + 256 * (int32_t)(v42 % 4)));
                                *(int16_t *)(v46 + (int32_t)&g240) = 1;
                                v16 = &g240;
                                v19 = 1;
                                v23 = v46;
                            }
                        }
                        // 0x34280
                        v38 = 1;
                        v17 = v16;
                        v20 = v19;
                        v24 = v23;
                        while (v29 != v38) {
                            // 0x341c4
                            v31 = *(int32_t *)((int32_t)&g232 + 8) - 1;
                            *(int32_t *)((int32_t)&g232 + 8) = v31;
                            v32 = *(int32_t *)((int32_t)&g232 + 4) + 1;
                            if ((v32 & 0x20000000) != 0 == (v32 != 510) || v32 == 510 || v32 < 510) {
                                v26 = (v32 & 0x20000000) != 0 == (v32 != 510) ? 0 : v32;
                                *(int32_t *)((int32_t)&g232 + 4) = v26;
                            }
                            v34 = 8 * v32;
                            v35 = (char *)(v34 + (int32_t)&g232 + 11);
                            v36 = (int32_t)*v35;
                            v16 = 0;
                            v19 = v36;
                            v23 = v31;
                            if (v9 == v36) {
                                // 0x34200
                                v37 = *(char *)(v34 + (int32_t)&g232 + 10);
                                v16 = 0;
                                v19 = v9;
                                v23 = v37;
                                if (v37 == 64) {
                                    // 0x3420c
                                    v39 = *(int32_t *)(v34 + (int32_t)&g232 + 4);
                                    function_1e160();
                                    v40 = function_5faf8();
                                    v41 = (int16_t *)(v34 + (int32_t)&g232 + 6);
                                    v42 = *v35;
                                    v43 = __asm_ubfx((int32_t)*v41, 0, 10);
                                    *(int16_t *)(4 * (v43 + 1024 * (v40 + v12)) + (int32_t)&g240 + 2) = (int16_t)v39;
                                    function_1e160();
                                    v44 = function_5faf8();
                                    v45 = *v41;
                                    v46 = 4 * (__asm_ubfx((int32_t)v45, 0, 10) + 1024 * (v44 + 256 * (int32_t)(v42 % 4)));
                                    *(int16_t *)(v46 + (int32_t)&g240) = 1;
                                    v16 = &g240;
                                    v19 = 1;
                                    v23 = v46;
                                }
                            }
                            // 0x34280
                            v38++;
                            v17 = v16;
                            v20 = v19;
                            v24 = v23;
                        }
                    }
                    // 0x34290
                    v25 = v24;
                    v21 = v20;
                    function_11ea4(&g416, v17, v21, v25);
                    usleep(1000);
                    function_302a0(&str);
                    v30 = function_30578(&str, &v27);
                    v15 = &v27;
                    while (v30 < 100) {
                        // 0x34190
                        function_11f94(&g416, v15, v21, v25);
                        v29 = *(int32_t *)((int32_t)&g232 + 8);
                        v22 = v29;
                        v17 = v15;
                        v20 = v21;
                        v24 = v29;
                        if (v29 >= 1) {
                            v31 = v22 - 1;
                            *(int32_t *)((int32_t)&g232 + 8) = v31;
                            v32 = *(int32_t *)((int32_t)&g232 + 4) + 1;
                            if ((v32 & 0x20000000) != 0 == (v32 != 510) || v32 == 510 || v32 < 510) {
                                v26 = (v32 & 0x20000000) != 0 == (v32 != 510) ? 0 : v32;
                                *(int32_t *)((int32_t)&g232 + 4) = v26;
                            }
                            v34 = 8 * v32;
                            v35 = (char *)(v34 + (int32_t)&g232 + 11);
                            v36 = (int32_t)*v35;
                            v16 = 0;
                            v19 = v36;
                            v23 = v31;
                            if (v9 == v36) {
                                // 0x34200
                                v37 = *(char *)(v34 + (int32_t)&g232 + 10);
                                v16 = 0;
                                v19 = v9;
                                v23 = v37;
                                if (v37 == 64) {
                                    // 0x3420c
                                    v39 = *(int32_t *)(v34 + (int32_t)&g232 + 4);
                                    function_1e160();
                                    v40 = function_5faf8();
                                    v41 = (int16_t *)(v34 + (int32_t)&g232 + 6);
                                    v42 = *v35;
                                    v43 = __asm_ubfx((int32_t)*v41, 0, 10);
                                    *(int16_t *)(4 * (v43 + 1024 * (v40 + v12)) + (int32_t)&g240 + 2) = (int16_t)v39;
                                    function_1e160();
                                    v44 = function_5faf8();
                                    v45 = *v41;
                                    v46 = 4 * (__asm_ubfx((int32_t)v45, 0, 10) + 1024 * (v44 + 256 * (int32_t)(v42 % 4)));
                                    *(int16_t *)(v46 + (int32_t)&g240) = 1;
                                    v16 = &g240;
                                    v19 = 1;
                                    v23 = v46;
                                }
                            }
                            // 0x34280
                            v38 = 1;
                            v17 = v16;
                            v20 = v19;
                            v24 = v23;
                            while (v29 != v38) {
                                // 0x341c4
                                v31 = *(int32_t *)((int32_t)&g232 + 8) - 1;
                                *(int32_t *)((int32_t)&g232 + 8) = v31;
                                v32 = *(int32_t *)((int32_t)&g232 + 4) + 1;
                                if ((v32 & 0x20000000) != 0 == (v32 != 510) || v32 == 510 || v32 < 510) {
                                    v26 = (v32 & 0x20000000) != 0 == (v32 != 510) ? 0 : v32;
                                    *(int32_t *)((int32_t)&g232 + 4) = v26;
                                }
                                v34 = 8 * v32;
                                v35 = (char *)(v34 + (int32_t)&g232 + 11);
                                v36 = (int32_t)*v35;
                                v16 = 0;
                                v19 = v36;
                                v23 = v31;
                                if (v9 == v36) {
                                    // 0x34200
                                    v37 = *(char *)(v34 + (int32_t)&g232 + 10);
                                    v16 = 0;
                                    v19 = v9;
                                    v23 = v37;
                                    if (v37 == 64) {
                                        // 0x3420c
                                        v39 = *(int32_t *)(v34 + (int32_t)&g232 + 4);
                                        function_1e160();
                                        v40 = function_5faf8();
                                        v41 = (int16_t *)(v34 + (int32_t)&g232 + 6);
                                        v42 = *v35;
                                        v43 = __asm_ubfx((int32_t)*v41, 0, 10);
                                        *(int16_t *)(4 * (v43 + 1024 * (v40 + v12)) + (int32_t)&g240 + 2) = (int16_t)v39;
                                        function_1e160();
                                        v44 = function_5faf8();
                                        v45 = *v41;
                                        v46 = 4 * (__asm_ubfx((int32_t)v45, 0, 10) + 1024 * (v44 + 256 * (int32_t)(v42 % 4)));
                                        *(int16_t *)(v46 + (int32_t)&g240) = 1;
                                        v16 = &g240;
                                        v19 = 1;
                                        v23 = v46;
                                    }
                                }
                                // 0x34280
                                v38++;
                                v17 = v16;
                                v20 = v19;
                                v24 = v23;
                            }
                        }
                        // 0x34290
                        v25 = v24;
                        v21 = v20;
                        function_11ea4(&g416, v17, v21, v25);
                        usleep(1000);
                        function_302a0(&str);
                        v30 = function_30578(&str, &v27);
                        v15 = &v27;
                    }
                    // 0x342bc
                    v33 = v14 + 1;
                    v14 = v33;
                    v18 = v13;
                    while (v13 != v33) {
                        // 0x3416c
                        v28 = function_1e160() * v14;
                        function_50da8(v9, v28);
                        function_302a0(&v27);
                        function_11f94(&g416, v28, v18, v14);
                        v29 = *(int32_t *)((int32_t)&g232 + 8);
                        v22 = v29;
                        v17 = v28;
                        v20 = v18;
                        v24 = v29;
                        if (v29 >= 1) {
                            v31 = v22 - 1;
                            *(int32_t *)((int32_t)&g232 + 8) = v31;
                            v32 = *(int32_t *)((int32_t)&g232 + 4) + 1;
                            if ((v32 & 0x20000000) != 0 == (v32 != 510) || v32 == 510 || v32 < 510) {
                                v26 = (v32 & 0x20000000) != 0 == (v32 != 510) ? 0 : v32;
                                *(int32_t *)((int32_t)&g232 + 4) = v26;
                            }
                            v34 = 8 * v32;
                            v35 = (char *)(v34 + (int32_t)&g232 + 11);
                            v36 = (int32_t)*v35;
                            v16 = 0;
                            v19 = v36;
                            v23 = v31;
                            if (v9 == v36) {
                                // 0x34200
                                v37 = *(char *)(v34 + (int32_t)&g232 + 10);
                                v16 = 0;
                                v19 = v9;
                                v23 = v37;
                                if (v37 == 64) {
                                    // 0x3420c
                                    v39 = *(int32_t *)(v34 + (int32_t)&g232 + 4);
                                    function_1e160();
                                    v40 = function_5faf8();
                                    v41 = (int16_t *)(v34 + (int32_t)&g232 + 6);
                                    v42 = *v35;
                                    v43 = __asm_ubfx((int32_t)*v41, 0, 10);
                                    *(int16_t *)(4 * (v43 + 1024 * (v40 + v12)) + (int32_t)&g240 + 2) = (int16_t)v39;
                                    function_1e160();
                                    v44 = function_5faf8();
                                    v45 = *v41;
                                    v46 = 4 * (__asm_ubfx((int32_t)v45, 0, 10) + 1024 * (v44 + 256 * (int32_t)(v42 % 4)));
                                    *(int16_t *)(v46 + (int32_t)&g240) = 1;
                                    v16 = &g240;
                                    v19 = 1;
                                    v23 = v46;
                                }
                            }
                            // 0x34280
                            v38 = 1;
                            v17 = v16;
                            v20 = v19;
                            v24 = v23;
                            while (v29 != v38) {
                                // 0x341c4
                                v31 = *(int32_t *)((int32_t)&g232 + 8) - 1;
                                *(int32_t *)((int32_t)&g232 + 8) = v31;
                                v32 = *(int32_t *)((int32_t)&g232 + 4) + 1;
                                if ((v32 & 0x20000000) != 0 == (v32 != 510) || v32 == 510 || v32 < 510) {
                                    v26 = (v32 & 0x20000000) != 0 == (v32 != 510) ? 0 : v32;
                                    *(int32_t *)((int32_t)&g232 + 4) = v26;
                                }
                                v34 = 8 * v32;
                                v35 = (char *)(v34 + (int32_t)&g232 + 11);
                                v36 = (int32_t)*v35;
                                v16 = 0;
                                v19 = v36;
                                v23 = v31;
                                if (v9 == v36) {
                                    // 0x34200
                                    v37 = *(char *)(v34 + (int32_t)&g232 + 10);
                                    v16 = 0;
                                    v19 = v9;
                                    v23 = v37;
                                    if (v37 == 64) {
                                        // 0x3420c
                                        v39 = *(int32_t *)(v34 + (int32_t)&g232 + 4);
                                        function_1e160();
                                        v40 = function_5faf8();
                                        v41 = (int16_t *)(v34 + (int32_t)&g232 + 6);
                                        v42 = *v35;
                                        v43 = __asm_ubfx((int32_t)*v41, 0, 10);
                                        *(int16_t *)(4 * (v43 + 1024 * (v40 + v12)) + (int32_t)&g240 + 2) = (int16_t)v39;
                                        function_1e160();
                                        v44 = function_5faf8();
                                        v45 = *v41;
                                        v46 = 4 * (__asm_ubfx((int32_t)v45, 0, 10) + 1024 * (v44 + 256 * (int32_t)(v42 % 4)));
                                        *(int16_t *)(v46 + (int32_t)&g240) = 1;
                                        v16 = &g240;
                                        v19 = 1;
                                        v23 = v46;
                                    }
                                }
                                // 0x34280
                                v38++;
                                v17 = v16;
                                v20 = v19;
                                v24 = v23;
                            }
                        }
                        // 0x34290
                        v25 = v24;
                        v21 = v20;
                        function_11ea4(&g416, v17, v21, v25);
                        usleep(1000);
                        function_302a0(&str);
                        v30 = function_30578(&str, &v27);
                        v15 = &v27;
                        while (v30 < 100) {
                            // 0x34190
                            function_11f94(&g416, v15, v21, v25);
                            v29 = *(int32_t *)((int32_t)&g232 + 8);
                            v22 = v29;
                            v17 = v15;
                            v20 = v21;
                            v24 = v29;
                            if (v29 >= 1) {
                                v31 = v22 - 1;
                                *(int32_t *)((int32_t)&g232 + 8) = v31;
                                v32 = *(int32_t *)((int32_t)&g232 + 4) + 1;
                                if ((v32 & 0x20000000) != 0 == (v32 != 510) || v32 == 510 || v32 < 510) {
                                    v26 = (v32 & 0x20000000) != 0 == (v32 != 510) ? 0 : v32;
                                    *(int32_t *)((int32_t)&g232 + 4) = v26;
                                }
                                v34 = 8 * v32;
                                v35 = (char *)(v34 + (int32_t)&g232 + 11);
                                v36 = (int32_t)*v35;
                                v16 = 0;
                                v19 = v36;
                                v23 = v31;
                                if (v9 == v36) {
                                    // 0x34200
                                    v37 = *(char *)(v34 + (int32_t)&g232 + 10);
                                    v16 = 0;
                                    v19 = v9;
                                    v23 = v37;
                                    if (v37 == 64) {
                                        // 0x3420c
                                        v39 = *(int32_t *)(v34 + (int32_t)&g232 + 4);
                                        function_1e160();
                                        v40 = function_5faf8();
                                        v41 = (int16_t *)(v34 + (int32_t)&g232 + 6);
                                        v42 = *v35;
                                        v43 = __asm_ubfx((int32_t)*v41, 0, 10);
                                        *(int16_t *)(4 * (v43 + 1024 * (v40 + v12)) + (int32_t)&g240 + 2) = (int16_t)v39;
                                        function_1e160();
                                        v44 = function_5faf8();
                                        v45 = *v41;
                                        v46 = 4 * (__asm_ubfx((int32_t)v45, 0, 10) + 1024 * (v44 + 256 * (int32_t)(v42 % 4)));
                                        *(int16_t *)(v46 + (int32_t)&g240) = 1;
                                        v16 = &g240;
                                        v19 = 1;
                                        v23 = v46;
                                    }
                                }
                                // 0x34280
                                v38 = 1;
                                v17 = v16;
                                v20 = v19;
                                v24 = v23;
                                while (v29 != v38) {
                                    // 0x341c4
                                    v31 = *(int32_t *)((int32_t)&g232 + 8) - 1;
                                    *(int32_t *)((int32_t)&g232 + 8) = v31;
                                    v32 = *(int32_t *)((int32_t)&g232 + 4) + 1;
                                    if ((v32 & 0x20000000) != 0 == (v32 != 510) || v32 == 510 || v32 < 510) {
                                        v26 = (v32 & 0x20000000) != 0 == (v32 != 510) ? 0 : v32;
                                        *(int32_t *)((int32_t)&g232 + 4) = v26;
                                    }
                                    v34 = 8 * v32;
                                    v35 = (char *)(v34 + (int32_t)&g232 + 11);
                                    v36 = (int32_t)*v35;
                                    v16 = 0;
                                    v19 = v36;
                                    v23 = v31;
                                    if (v9 == v36) {
                                        // 0x34200
                                        v37 = *(char *)(v34 + (int32_t)&g232 + 10);
                                        v16 = 0;
                                        v19 = v9;
                                        v23 = v37;
                                        if (v37 == 64) {
                                            // 0x3420c
                                            v39 = *(int32_t *)(v34 + (int32_t)&g232 + 4);
                                            function_1e160();
                                            v40 = function_5faf8();
                                            v41 = (int16_t *)(v34 + (int32_t)&g232 + 6);
                                            v42 = *v35;
                                            v43 = __asm_ubfx((int32_t)*v41, 0, 10);
                                            *(int16_t *)(4 * (v43 + 1024 * (v40 + v12)) + (int32_t)&g240 + 2) = (int16_t)v39;
                                            function_1e160();
                                            v44 = function_5faf8();
                                            v45 = *v41;
                                            v46 = 4 * (__asm_ubfx((int32_t)v45, 0, 10) + 1024 * (v44 + 256 * (int32_t)(v42 % 4)));
                                            *(int16_t *)(v46 + (int32_t)&g240) = 1;
                                            v16 = &g240;
                                            v19 = 1;
                                            v23 = v46;
                                        }
                                    }
                                    // 0x34280
                                    v38++;
                                    v17 = v16;
                                    v20 = v19;
                                    v24 = v23;
                                }
                            }
                            // 0x34290
                            v25 = v24;
                            v21 = v20;
                            function_11ea4(&g416, v17, v21, v25);
                            usleep(1000);
                            function_302a0(&str);
                            v30 = function_30578(&str, &v27);
                            v15 = &v27;
                        }
                        // 0x342bc
                        v33 = v14 + 1;
                        v14 = v33;
                        v18 = v13;
                    }
                }
                // 0x342d4
                v47 = function_1e0f0();
            }
            char * v77 = g289; // 0x34664
            v48 = v77;
            v49 = 0;
            if (v77 >= (char *)3 == (v77 != (char *)3)) {
                // 0x34608
                __asm_vdiv_f32(__asm_vcvt_f32_s32(__asm_vmov_7(0)), v6);
                return &str;
            }
          lab_0x345b0:;
            char * v78 = v48; // 0x345b4
            if (v78 != (char *)3 && v78 >= (char *)3) {
                // 0x345c0
                snprintf((char *)&str, 2048, "bad count is acceptable = %d", v49);
                function_2e584(3, &str, 0);
            }
            // 0x345ec
            usleep((int32_t)&g471);
        }
      lab_0x340a8:
        // 0x340a8
        v8 = v9 + 1;
        v7 = v10 + 256;
        if (v8 == 4) {
            // break -> 0x340c0
            break;
        }
    }
    // 0x340c0
    *(char *)&g418 = 0;
    int32_t result = function_162b0(); // 0x340cc
    __asm_vpop(v2);
    return result;
}

// Address range: 0x34680 - 0x34750
int32_t function_34680(void) {
    char * v1 = g289; // 0x34694
    if (v1 >= (char *)3 == (v1 != (char *)3)) {
        char * v2 = (char *)0x74666f73; // bp-2072, 0x3472c
        function_2e584(3, (int32_t *)&v2, 0);
    }
    int32_t v3 = 0;
    int32_t result = 0; // 0x346c0
    if (function_1e29c(v3) != 0) {
        // 0x346dc
        function_50c38(v3, 1);
        usleep(0x30d40);
        function_50c38(v3, 0);
        usleep((int32_t)"version array failed\n");
        function_50dd4(v3);
        result = usleep(0x30d40);
    }
    int32_t v4 = v3 + 1; // 0x346c4
    while (v4 != 4) {
        // 0x346b4
        v3 = v4;
        result = 0;
        if (function_1e29c(v3) != 0) {
            // 0x346dc
            function_50c38(v3, 1);
            usleep(0x30d40);
            function_50c38(v3, 0);
            usleep((int32_t)"version array failed\n");
            function_50dd4(v3);
            result = usleep(0x30d40);
        }
        // 0x346c4
        v4 = v3 + 1;
    }
    // 0x346d0
    return result;
}

// Address range: 0x34750 - 0x34818
int32_t function_34750(uint32_t a1, int32_t a2) {
    int32_t v1 = function_3388c(); // 0x34760
    int32_t v2 = __asm_ubfx(v1, 8, 8); // 0x3476c
    int32_t v3 = __asm_ubfx(v1, 16, 8); // 0x34770
    int32_t result = 0; // 0x34788
    if (function_1e29c(a1) != 0) {
        uint32_t v4 = a1 % 256; // 0x3478c
        function_50cc4(v4, function_1e160() * a2, 1);
        usleep(0x2710);
        function_50cc4(v4, function_1e160() * a2, 0);
        usleep(0x2710);
        int32_t v5 = function_1e160(); // 0x347c8
        function_515d0(v4, v5 * a2, (char)v1, (int32_t)g66);
        usleep(0x2710);
        result = function_51668(v4, function_1e160() * a2, (char)v2, (char)v3, 0);
    }
    // 0x34810
    return result;
}

// Address range: 0x34818 - 0x34828
int32_t function_34818(void) {
    // 0x34818
    return function_31d58(14, "Can't get temperature sensor type!");
}

// Address range: 0x34828 - 0x350e0
int32_t function_34828(uint32_t a1, char a2, int16_t a3, int16_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    // 0x34828
    g435 = a1;
    g436 = a2;
    g437 = a3;
    g439 = a4;
    g441 = a5;
    g444 = a6;
    g445 = a7;
    g446 = a8;
    int32_t v1; // 0x34828
    int32_t format; // 0x34828
    int32_t v2; // 0x34828
    int32_t v3; // 0x34828
    char * str; // bp-2104, 0x34828
    int32_t v4; // 0x34828
    int32_t v5; // 0x34828
    if ((char)a1 == 81) {
        int32_t v6 = function_31590(&g435, 30); // 0x348e8
        int32_t v7 = g447; // 0x348ec
        char * v8 = g289;
        if (v6 == v7) {
            // 0x34920
            v1 = 30;
            v2 = a7;
            if (v8 >= (char *)3 == (v8 != (char *)3)) {
                // 0x34bdc
                __asm_ubfx((int32_t)g436, 1, 1);
                snprintf((char *)&str, 2048, "fan_eft : %d  fan_pwm : %d\n");
                function_2e584(3, (int32_t *)&str, 0);
                v1 = (int32_t)&str;
                v2 = 0;
            }
            // 0x34934
            if (g294 == 0) {
                uint32_t v9 = function_362a0(161); // 0x3494c
                int32_t v10 = 0;
                if (function_1e29c(v10) != 0) {
                    // 0x34bd0
                    function_4fa0c(v10);
                }
                int32_t v11 = v10 + 1; // 0x3495c
                while (v11 != 4) {
                    // 0x34954
                    v10 = v11;
                    if (function_1e29c(v10) != 0) {
                        // 0x34bd0
                        function_4fa0c(v10);
                    }
                    // 0x3496c
                    v11 = v10 + 1;
                }
                // 0x34974
                if (v9 % 256 != 0) {
                    // 0x3489c
                    return 0;
                }
            }
            // 0x3497c
            if (function_27a58() % 256 != 0) {
                // 0x3489c
                return 0;
            }
            // 0x34988
            if (g67 == 0) {
                goto lab_0x349a8;
            } else {
                // 0x3499c
                if ((g436 & 16) == 0) {
                    goto lab_0x349a8;
                } else {
                    // 0x34c20
                    g74 = g440;
                    v5 = function_31bac();
                    goto lab_0x349b8;
                }
            }
        } else {
            // 0x348f8
            v4 = v6;
            format = (int32_t)"config_parameter.crc = 0x%x, but we calculate it as 0x%x\n";
            v3 = v7;
            if (v8 == (char *)4 || v8 < (char *)4) {
                // 0x3489c
                return 0;
            }
            goto lab_0x348c4;
        }
    } else {
        char * v12 = g289; // 0x3488c
        v4 = a1 % 256;
        format = (int32_t)"config_parameter.token_type != 0x%x, it is 0x%x\n";
        v3 = 81;
        if (v12 >= (char *)4 != v12 != (char *)4) {
            // 0x3489c
            return 0;
        }
        goto lab_0x348c4;
    }
  lab_0x348c4:
    // 0x348c4
    snprintf((char *)&str, 2048, (char *)format, v3, v4);
    function_2e584(4, (int32_t *)&str, 0);
    // 0x3489c
    return 0;
  lab_0x349a8:;
    int32_t v13 = function_31bac(); // 0x349a8
    v5 = v13;
    int32_t v14; // 0x34828
    int32_t v15; // 0x34828
    if (v13 < 1) {
        // 0x34c14
        v14 = v1;
        v15 = v2;
        if (v13 % 256 != 0) {
            // 0x3489c
            return 0;
        }
        goto lab_0x349ec;
    } else {
        goto lab_0x349b8;
    }
  lab_0x349b8:
    // 0x349b8
    g74 = v5;
    char * v16 = g289; // 0x349b8
    v14 = v1;
    v15 = v2;
    if (v16 != (char *)3 && v16 >= (char *)3) {
        // 0x349c4
        snprintf((char *)&str, 2048, "fixed working voltage = %d\n", v5);
        function_2e584(3, (int32_t *)&str, 0);
        v14 = (int32_t)&str;
        v15 = 0;
    }
    goto lab_0x349ec;
  lab_0x349ec:
    // 0x349ec
    if (function_33e34() % 256 != 0) {
        // 0x3489c
        return 0;
    }
    // 0x349fc
    int32_t v17; // 0x34828
    int32_t v18; // 0x34828
    int32_t v19; // 0x34828
    char * v20; // 0x34828
    if (g67 == 0) {
        goto lab_0x34a14;
    } else {
        // 0x34a08
        if ((g436 & 8) == 0) {
            goto lab_0x34a14;
        } else {
            // 0x34ec0
            g65 = g439;
            int32_t v21; // bp-2140, 0x34828
            int32_t v22 = &v21;
            int32_t v23 = 0;
            int32_t v24 = 0;
            int32_t v25 = v14; // 0x34ee8
            int32_t v26 = v15; // 0x34ee8
            int32_t v27 = v24; // 0x34ee8
            uint32_t v28; // 0x34828
            unsigned char v29; // 0x34f68
            int32_t v30; // 0x34f68
            int32_t v31; // 0x34f70
            uint32_t v32; // 0x34f7c
            if (function_1e29c(v23) != 0) {
                // 0x34f64
                v29 = *(char *)&g414;
                v30 = v29;
                v31 = function_183fc(v23, v29, v22);
                v25 = v30;
                v26 = v22;
                v27 = v24;
                if (v31 == 0) {
                    // 0x34f7c
                    v32 = v21;
                    v28 = v24 == 0 ? v32 : v24;
                    v25 = v30;
                    v26 = v22;
                    v27 = v24 == 0 | v28 < v32 ? v28 : v32;
                }
            }
            int32_t v33 = v27;
            int32_t v34 = v26;
            int32_t v35 = v25;
            int32_t v36 = v23 + 1; // 0x34eec
            while (v36 != 4) {
                // 0x34edc
                v23 = v36;
                v24 = v33;
                v25 = v35;
                v26 = v34;
                v27 = v24;
                if (function_1e29c(v23) != 0) {
                    // 0x34f64
                    v29 = *(char *)&g414;
                    v30 = v29;
                    v31 = function_183fc(v23, v29, v22);
                    v25 = v30;
                    v26 = v22;
                    v27 = v24;
                    if (v31 == 0) {
                        // 0x34f7c
                        v32 = v21;
                        v28 = v24 == 0 ? v32 : v24;
                        v25 = v30;
                        v26 = v22;
                        v27 = v24 == 0 | v28 < v32 ? v28 : v32;
                    }
                }
                // 0x34eec
                v33 = v27;
                v34 = v26;
                v35 = v25;
                v36 = v23 + 1;
            }
            char * v37 = g289; // 0x34ef8
            int32_t v38 = v35; // 0x34f00
            int32_t v39 = v34; // 0x34f00
            char * v40 = v37; // 0x34f00
            if (v37 >= (char *)3 == (v37 != (char *)3)) {
                // 0x35044
                snprintf((char *)&str, 2048, "min freq in eeprom = %d\n", v33);
                function_2e584(3, (int32_t *)&str, 0);
                v40 = g289;
                v38 = (int32_t)&str;
                v39 = 0;
            }
            char * v41 = v40;
            if (v33 > 0) {
                // .thread
                g65 = v33;
                v17 = v33;
                v18 = v38;
                v19 = v39;
                v20 = v41;
            } else {
                char * v42 = v41; // 0x34f18
                int32_t v43 = v38; // 0x34f18
                if (v41 != (char *)3 && v41 >= (char *)3) {
                    // 0x34f1c
                    str = (char *)0x6c696166;
                    function_2e584(3, (int32_t *)&str, 0);
                    v42 = g289;
                    v43 = (int32_t)&str;
                }
                // 0x34f54
                g65 = 200;
                v17 = 200;
                v18 = v43;
                v19 = 200;
                v20 = v42;
            }
            goto lab_0x34a28;
        }
    }
  lab_0x34a14:
    // 0x34a14
    g65 = 200;
    v17 = 200;
    v18 = v14;
    v19 = 200;
    v20 = g289;
    goto lab_0x34a28;
  lab_0x34a28:;
    char * v44 = v20;
    int32_t v45 = v18; // 0x34a2c
    int32_t v46 = v19; // 0x34a2c
    if (v44 != (char *)3 && v44 >= (char *)3) {
        // 0x34a30
        snprintf((char *)&str, 2048, "fixed frequency is %d\n", v17);
        function_2e584(3, (int32_t *)&str, 0);
        v45 = (int32_t)&str;
        v46 = 0;
    }
    int32_t v47 = v45; // 0x34a60
    int32_t v48; // 0x34828
    int32_t v49; // 0x34d88
    if (g414 == 3) {
        // 0x34d88
        v49 = g74;
        int32_t v50 = function_1e0c0(); // 0x34d8c
        if (function_11eec(v50, "NBS1902", v46, 3) == 0) {
            goto lab_0x34dcc;
        } else {
            int32_t v51 = function_1e0c0(); // 0x34fa0
            if (function_11eec(v51, "NBS1902L", v46, 3) == 0) {
                goto lab_0x34dcc;
            } else {
                int32_t v52 = function_1e0c0(); // 0x34fb8
                if (function_11eec(v52, "NBT1903", v46, 3) == 0) {
                    goto lab_0x34dcc;
                } else {
                    int32_t v53 = function_1e0c0(); // 0x34fd0
                    v48 = (int32_t)"NBP1901";
                    if (function_11eec(v53, "NBP1901", v46, 3) == 0) {
                        goto lab_dec_label_pc_unknown_26;
                    } else {
                        // 0x350c0
                        v47 = (int32_t)"NBP1901L";
                        v48 = (int32_t)"NBP1901L";
                        if (function_11eec(function_1e0c0(), "NBP1901L", v46, 3) == 0) {
                            goto lab_dec_label_pc_unknown_26;
                        } else {
                            goto lab_0x34a64;
                        }
                    }
                }
            }
        }
    } else {
        goto lab_0x34a64;
    }
  lab_0x34a64:;
    // 0x34a64
    int32_t v54; // 0x34828
    if (g414 != 1 == g74 > 0) {
        int32_t v55 = function_1e160(); // 0x34c34
        if (function_15210(v55) % 256 == 0) {
            // 0x34e68
            function_20a38(0);
            v54 = v47;
        } else {
            // 0x34c48
            function_20a38(1);
            function_31d58(14, "Can't get temperature sensor type!");
            v54 = (int32_t)"Can't get temperature sensor type!";
        }
    } else {
        // 0x34a78
        function_194dc();
        function_13fb0(0);
        function_304d4(2000);
        v54 = v47;
    }
    int32_t v56 = function_1572c(); // 0x34a8c
    char * v57 = g289; // 0x34a90
    g448 = v56;
    int32_t v58; // 0x34828
    int32_t v59; // 0x34828
    int32_t v60; // 0x34828
    int32_t v61; // 0x34828
    int32_t v62; // 0x34828
    if (v57 >= (char *)3 == (v57 != (char *)3)) {
        // 0x34c64
        snprintf((char *)&str, 2048, "Bring up temperature is %d\n", v56);
        int32_t v63 = (int32_t)&str; // 0x34c7c
        function_2e584(3, (int32_t *)&str, 0);
        v58 = v63;
        v61 = 0;
        v62 = 0;
        if (g413 == 0) {
            goto lab_0x34abc;
        } else {
            char * v64 = g289; // 0x34ca0
            v59 = v63;
            v60 = 0;
            if (v64 != (char *)3 && v64 >= (char *)3) {
                // 0x34cac
                str = (char *)0x73657270;
                function_2e584(3, (int32_t *)&str, 0);
                v59 = v63;
                v60 = 0;
            }
            goto lab_0x34cec;
        }
    } else {
        // 0x34aa8
        v58 = v54;
        v61 = &g448;
        v62 = 0;
        v59 = v54;
        v60 = &g448;
        if (g413 == 0) {
            goto lab_0x34abc;
        } else {
            goto lab_0x34cec;
        }
    }
  lab_0x34dcc:;
    float32_t v65 = __asm_vldr_8(g74); // 0x34da4
    float32_t v66 = __asm_vldr_8(0x3f68f5c3); // 0x34da8
    float32_t v67 = __asm_vldr_8(0x44960000); // 0x34dac
    float32_t v68 = __asm_vmul_f32(__asm_vcvt_f32_s32(v65), v66); // 0x34db4
    __asm_vcmpe_f32(v68, v67);
    int32_t v69; // 0x34828
    __asm_vmrs(v69, v69);
    int32_t v70 = __asm_vmov_9(__asm_vcvt_s32_f32(v68)); // 0x34dc8
    __asm_vldr_8(g65);
    return 0x66666667 * (v49 - v70);
  lab_0x34abc:
    // 0x34abc
    function_11f94(&g332, v58, v61, v62);
    function_28138(0xb71b00);
    function_11ea4(&g332, v58, v61, v62);
    int32_t v71; // 0x34828
    if (*(char *)&g287 == 0) {
        // 0x34e70
        function_3403c();
        v71 = v61;
    } else {
        // 0x34af4
        v71 = v61;
        if (g74 > 0) {
            // 0x34e78
            v71 = v61;
            if (function_19ab4() != g74) {
                int32_t v72 = function_1572c(); // 0x34e88
                int32_t v73 = g74; // 0x34eac
                int32_t v74 = v61; // 0x34eac
                if (!((v72 > 19 | *(char *)&g286 % 2 == 0))) {
                    int32_t v75 = 100 * (20 - v72); // 0x35084
                    int32_t v76 = 0; // 0x35098
                    if (v75 < 4000) {
                        v76 = v75 / 40;
                    }
                    int32_t v77 = v75 < 4000 ? v76 : 100;
                    int32_t v78 = function_19ac4(); // 0x350a4
                    v73 = (v77 + g74 > v78 ? v78 : g74) + v77;
                    v74 = v75;
                    if (v77 + g74 > v78) {
                        // 0x350b8
                        v73 = function_19ac4();
                        v74 = v75;
                    }
                }
                // 0x34eb0
                function_195a8(v73);
                function_304d4(4000);
                v71 = v74;
            }
        }
    }
    // 0x34b00
    function_304d4(1000);
    int32_t v79 = v71; // 0x34b10
    if (function_1e100() == 2) {
        int32_t v80 = 0;
        int32_t v81 = v71; // 0x34e28
        if (function_1e29c(v80) != 0) {
            // 0x34e2c
            function_50a80(v80, 19 * function_1e160(), 0);
            function_50a80(v80, 55 * function_1e160(), 0);
            v81 = 0;
        }
        int32_t v82 = v80 + 1; // 0x34e1c
        v79 = v81;
        int32_t v83 = v81; // 0x34e60
        while (v82 != 4) {
            // 0x34e14
            v80 = v82;
            v81 = v83;
            if (function_1e29c(v80) != 0) {
                // 0x34e2c
                function_50a80(v80, 19 * function_1e160(), 0);
                function_50a80(v80, 55 * function_1e160(), 0);
                v81 = 0;
            }
            // 0x34e5c
            v82 = v80 + 1;
            v79 = v81;
            v83 = v81;
        }
    }
    // 0x34b14
    function_31d58(1, "soc init done!");
    if (function_27c88() % 256 != 0) {
        // 0x3489c
        return 0;
    }
    int32_t v84 = 0;
    int32_t v85 = v79; // 0x34b54
    int32_t v86; // 0x34828
    int32_t v87; // 0x34828
    int32_t v88; // 0x34828
    int32_t v89; // 0x34828
    int32_t v90; // 0x34828
    int32_t v91; // 0x34828
    int32_t v92; // 0x34828
    int32_t v93; // 0x34828
    int32_t v94; // 0x34d40
    int32_t v95; // 0x34d58
    int32_t v96; // 0x34d14
    int32_t v97; // 0x34d30
    if (function_1e29c(v84) != 0) {
        // 0x34d00
        v86 = 0;
        if (function_1e67c(v84) != 0) {
            // 0x34d40
            v93 = 2048 * v84 + (int32_t)&g426;
            v89 = 0;
            v92 = 0;
            v87 = 0;
            v94 = function_1e100();
            function_5fadc(v89, v94, v79, (int32_t)&g426);
            v90 = v87;
            v95 = v92;
            if (v94 == 0) {
                // 0x34d58
                v95 = v92 + 1;
                function_1e820(v84, v87, 32);
                v90 = v95 + v89;
            }
            // 0x34d14
            v91 = v95;
            v96 = v89 + 1;
            function_1e820(v84, v90, 111);
            *(int32_t *)v93 = 0;
            *(int32_t *)(v93 + 4) = 0;
            v97 = v91 + v96;
            v93 += 8;
            v88 = 111;
            v86 = v97;
            while (v96 < function_1e67c(v84)) {
                // 0x34d40
                v89 = v96;
                v92 = v91;
                v87 = v97;
                v94 = function_1e100();
                function_5fadc(v89, v94, v88, (int32_t)&g426);
                v90 = v87;
                v95 = v92;
                if (v94 == 0) {
                    // 0x34d58
                    v95 = v92 + 1;
                    function_1e820(v84, v87, 32);
                    v90 = v95 + v89;
                }
                // 0x34d14
                v91 = v95;
                v96 = v89 + 1;
                function_1e820(v84, v90, 111);
                *(int32_t *)v93 = 0;
                *(int32_t *)(v93 + 4) = 0;
                v97 = v91 + v96;
                v93 += 8;
                v88 = 111;
                v86 = v97;
            }
        }
        // 0x34d74
        function_1e820(v84, v86, 111);
        v85 = 111;
    }
    int32_t v98 = v84 + 1; // 0x34b58
    while (v98 != 4) {
        // 0x34b48
        v84 = v98;
        int32_t v99 = v85;
        v85 = v99;
        if (function_1e29c(v84) != 0) {
            // 0x34d00
            v86 = 0;
            if (function_1e67c(v84) != 0) {
                // 0x34d40
                v93 = 2048 * v84 + (int32_t)&g426;
                v89 = 0;
                v92 = 0;
                v87 = 0;
                v94 = function_1e100();
                function_5fadc(v89, v94, v99, (int32_t)&g426);
                v90 = v87;
                v95 = v92;
                if (v94 == 0) {
                    // 0x34d58
                    v95 = v92 + 1;
                    function_1e820(v84, v87, 32);
                    v90 = v95 + v89;
                }
                // 0x34d14
                v91 = v95;
                v96 = v89 + 1;
                function_1e820(v84, v90, 111);
                *(int32_t *)v93 = 0;
                *(int32_t *)(v93 + 4) = 0;
                v97 = v91 + v96;
                v93 += 8;
                v88 = 111;
                v86 = v97;
                while (v96 < function_1e67c(v84)) {
                    // 0x34d40
                    v89 = v96;
                    v92 = v91;
                    v87 = v97;
                    v94 = function_1e100();
                    function_5fadc(v89, v94, v88, (int32_t)&g426);
                    v90 = v87;
                    v95 = v92;
                    if (v94 == 0) {
                        // 0x34d58
                        v95 = v92 + 1;
                        function_1e820(v84, v87, 32);
                        v90 = v95 + v89;
                    }
                    // 0x34d14
                    v91 = v95;
                    v96 = v89 + 1;
                    function_1e820(v84, v90, 111);
                    *(int32_t *)v93 = 0;
                    *(int32_t *)(v93 + 4) = 0;
                    v97 = v91 + v96;
                    v93 += 8;
                    v88 = 111;
                    v86 = v97;
                }
            }
            // 0x34d74
            function_1e820(v84, v86, 111);
            v85 = 111;
        }
        // 0x34b58
        v98 = v84 + 1;
    }
    int32_t v100 = function_27b70(); // 0x34b64
    if (v100 % 256 != 0) {
        // 0x3489c
        return 0;
    }
    int32_t v101 = v100; // 0x34b80
    if (g410 != 0) {
        // 0x35074
        v101 = function_27da0();
    }
    // 0x34b84
    function_2bdc4(v101);
    function_3208c();
    function_304d4(500);
    char * v102 = g289; // 0x34b94
    if (v102 != (char *)3 && v102 >= (char *)3) {
        // 0x34ba4
        str = (char *)0x74696e49;
        function_2e584(3, (int32_t *)&str, 0);
    }
    // 0x3489c
    return 1;
  lab_0x34cec:
    // 0x34cec
    function_12000(g317);
    v58 = v59;
    v61 = v60;
    v62 = &g317;
    goto lab_0x34abc;
  lab_dec_label_pc_unknown_26:;
    float32_t v103 = __asm_vldr_8(g74); // 0x34fe8
    float32_t v104 = __asm_vldr_8(0x3f68f5c3); // 0x34fec
    float32_t v105 = __asm_vldr_8(0x44960000); // 0x34ff0
    float32_t v106 = __asm_vmul_f32(__asm_vcvt_f32_s32(v103), v104); // 0x34ff8
    __asm_vcmpe_f32(v106, v105);
    __asm_vmrs(v69, v69);
    int32_t v107 = __asm_vmovpl(__asm_vcvtpl_s32_f32(v106)); // 0x3500c
    int32_t v108 = v49 - v107; // 0x35014
    g74 = v107;
    g65 += v108 % 10 - v108;
    v47 = v48;
    goto lab_0x34a64;
}

// Address range: 0x350e8 - 0x35344
int32_t function_350e8(void) {
    uint32_t v1 = function_1572c(); // 0x350f8
    int16_t v2 = g303; // 0x350fc
    uint32_t v3 = v1 % 0x10000; // 0x35100
    int32_t v4 = __asm_sxth(v3 - 10); // 0x35108
    int32_t v5; // 0x350e8
    if (v2 == 255) {
        g303 = v4;
        // 0x35244
        *(int16_t *)(((int32_t)&g51 | 0x2a60) + 48) = 0;
        v5 = (int32_t)&g51 | 0x2a60;
        goto lab_0x3513c;
    } else {
        if ((int32_t)v2 - v4 < 6) {
            // 0x35244
            *(int16_t *)(((int32_t)&g51 | 0x2a60) + 48) = 0;
            v5 = (int32_t)&g51 | 0x2a60;
            goto lab_0x3513c;
        } else {
            // 0x35128
            *(int16_t *)&g75 = (int16_t)&g76;
            v5 = &g62;
            goto lab_0x3513c;
        }
    }
  lab_0x3513c:;
    int32_t * v6 = (int32_t *)(v5 + 44); // 0x3513c
    if (*v6 < 1 || g414 == 1) {
        // 0x35238
        return 0;
    }
    int32_t v7 = g414; // 0x35160
    int32_t v8; // 0x35170
    if (v4 < 20) {
        goto lab_0x3517c;
    } else {
        int16_t v9 = *(int16_t *)(v5 + 48); // 0x35164
        v8 = v9;
        if (v9 < 2) {
            goto lab_0x35258;
        } else {
            // 0x35170
            v8 = v3 - 21;
            v7 = v8;
            if (v8 >= 8 == (v8 != 8)) {
                goto lab_0x35258;
            } else {
                goto lab_0x3517c;
            }
        }
    }
  lab_0x3517c:;
    int32_t v10 = function_19ab4(); // 0x3517c
    int32_t v11 = 100 * (20 - v4); // 0x35188
    int32_t v12 = v7; // 0x351a0
    if (v11 < 4000) {
        v12 = 0x66666667 * (int64_t)v11 / 0x100000000;
    }
    int32_t v13 = v11 < 4000 ? (v12 >> 4) - (v11 >> 31) : 100;
    char * v14 = g289; // 0x351b0
    if (v14 >= (char *)4 == (v14 != (char *)4)) {
        int32_t v15 = *v6; // 0x352f8
        int32_t v16 = v10 - v15 + v13; // 0x35318
        int32_t v17 = v16 < 0 ? -v16 : v16;
        int32_t str; // bp-2080, 0x350e8
        snprintf((char *)&str, 2048, "curr_vol = %d, g_voltage = %d,compensate_voltage = %d, abs = %d", v10, v15, v13, v17);
        function_2e584(4, &str, 0);
    }
    int32_t v18 = *v6 + v13; // 0x351c0
    int32_t v19 = v10 - v18; // 0x351c4
    if ((v19 < 0 ? -v19 : v19) < 20) {
        // 0x35234
        g303 = v4;
        // 0x35238
        return 0;
    }
    int32_t v20 = v10 + 49; // 0x351d8
    int32_t v21 = v20; // 0x351e0
    int32_t v22 = v18; // 0x351e0
    int32_t v23 = v10; // 0x351e0
    if (v20 < v18) {
        int32_t v24 = v10;
        while (function_19ac4() > v21) {
            int32_t v25 = v21 + 20; // 0x3521c
            int32_t v26 = v24 + 20; // 0x351f0
            function_195a8(v26);
            usleep(0x30d40);
            int32_t v27 = *v6 + v13; // 0x35208
            v21 = v25;
            v22 = v27;
            v23 = v26;
            if (v27 <= v25) {
                goto lab_0x3522c;
            }
            v24 = v26;
        }
        // 0x35224
        v22 = *v6 + v13;
        v23 = v24;
    }
  lab_0x3522c:
    // 0x3522c
    if (v23 == v22) {
        // 0x35234
        g303 = v4;
        // 0x35238
        return 0;
    }
    // 0x352b0
    function_195a8(v22);
    g303 = v4;
    // 0x35238
    return 0;
  lab_0x35258:;
    uint32_t v28 = v3 - 30; // 0x35258
    if (v28 >= 21 == (v28 != 21)) {
        int32_t v29 = function_1e0c0(); // 0x352bc
        int32_t v30; // 0x350e8
        if ((function_11eec(v29, "NBS1902L", v30, v8) == 0 ? v4 : v4 + 10) < 50) {
            // 0x35234
            g303 = v4;
            // 0x35238
            return 0;
        }
        int32_t v31 = function_19ab4(); // 0x352dc
        int32_t v32 = *v6 - 20; // 0x352e4
        if (v32 == v31) {
            // 0x35234
            g303 = v4;
            // 0x35238
            return 0;
        }
        // 0x352b0
        function_195a8(v32);
        g303 = v4;
        // 0x35238
        return 0;
    }
    int32_t v33 = function_19ab4(); // 0x35264
    int32_t v34 = *v6; // 0x3526c
    int32_t v35 = v34; // 0x35278
    int32_t v36 = v33; // 0x35278
    if (v34 < v33 - 19) {
        int32_t v37 = v33;
        int32_t v38 = v37 - 20; // 0x35284
        function_195a8(v38);
        usleep(0x30d40);
        uint32_t v39 = *v6; // 0x35298
        v35 = v39;
        v36 = v38;
        while (v39 < v37 - 39) {
            // 0x35284
            v37 = v38;
            v38 = v37 - 20;
            function_195a8(v38);
            usleep(0x30d40);
            v39 = *v6;
            v35 = v39;
            v36 = v38;
        }
    }
    // 0x352a8
    if (v35 == v36) {
        // 0x35234
        g303 = v4;
        // 0x35238
        return 0;
    }
    // 0x352b0
    function_195a8(v35);
    g303 = v4;
    // 0x35238
    return 0;
}

// Address range: 0x35344 - 0x356c4
int32_t function_35344(void) {
    // 0x35344
    int32_t v1; // 0x35344
    uint32_t v2 = v1;
    int32_t str; // bp-2080, 0x35344
    if ((g436 & 2) != 0) {
        unsigned char v3 = g438; // 0x35364
        if (v3 == 100 || v3 < 100) {
            int32_t result = function_13fb0((int32_t)v3); // 0x35448
            if (g77 != 0) {
                // 0x35434
                return result;
            }
            char * v4 = g289; // 0x35460
            int32_t result2 = result; // 0x35468
            if (v4 != (char *)3 && v4 >= (char *)3) {
                // 0x3546c
                snprintf((char *)&str, 2048, "fan_etf: Set fixed fan speed=%d\n", (int32_t)g438);
                result2 = function_2e584(3, &str, 0);
            }
            // 0x35494
            g77 = 1;
            return result2;
        }
    }
    int32_t v5 = function_1572c(); // 0x35370
    int32_t v6 = function_15508(); // 0x35378
    int32_t v7 = function_155c4(); // 0x35380
    int32_t v8 = function_1572c(); // 0x35388
    int32_t v9 = g304; // 0x35398
    int32_t v10; // 0x35344
    int32_t v11; // 0x35344
    int32_t v12; // 0x35344
    if (v9 == 255) {
        // 0x354a8
        v10 = *(int32_t *)(((int32_t)&g51 | 0x2a60) + 56);
        v12 = (int32_t)&g51 | 0x2a60;
        goto lab_0x354b4;
    } else {
        int32_t v13 = v9 - v5; // 0x353a4
        int32_t v14 = g78; // 0x353bc
        v10 = v14;
        v12 = &g62;
        if ((v13 < 0 ? -v13 : v13) < 5) {
            goto lab_0x354b4;
        } else {
            int32_t v15 = v14 + 1; // 0x353c4
            g78 = v15 < 2 ? v15 : 2;
            g79 = v14 > 0;
            v11 = &g62;
            goto lab_0x353e4;
        }
    }
  lab_0x354b4:;
    int32_t v16 = v10;
    int32_t v17 = v16 - 1; // 0x354b4
    *(int32_t *)(v12 + 60) = v16 > 1 ? 1 : v16 < 2 ? 0 : v16;
    *(int32_t *)(v12 + 56) = v17 & (int32_t)(v17 < 0) - 1;
    v11 = v12;
    goto lab_0x353e4;
  lab_0x353e4:;
    int32_t v18 = v6 - v8; // 0x35390
    g304 = v5;
    if (v6 <= 72) {
        int32_t v19 = v18 < 0 ? -v18 : v18; // 0x353f4
        int32_t v20 = v19 - 32; // 0x353fc
        bool v21 = v19 == 32; // 0x353fc
        int32_t v22 = 31 - v19 & v19; // 0x353fc
        if (v19 < 33) {
            v20 = v5 - 50;
            v21 = v5 == 50;
            v22 = 49 - v5 & v5;
        }
        if (v21 || v20 < 0 != v22 < 0) {
            // 0x35514
            if (*(int32_t *)(v11 + 60) == 0) {
                // 0x35520
                *(int32_t *)(v11 + 52) = 0;
                if (v19 > 27) {
                    int32_t v23 = function_1e4b0(); // 0x35580
                    float32_t v24 = __asm_vcvt_f32_s32(__asm_vmov_7(v19)); // 0x35588
                    float32_t v25 = __asm_vmov_f32(25.0f); // 0x3558c
                    float32_t v26 = __asm_vmul_f32(__asm_vdiv_f32(__asm_vsub_f32(v24, v25), v25), __asm_vmov_f32(10.0f)); // 0x3559c
                    __asm_vstr_12(__asm_vcvt_u32_f32(v26), v2);
                    int32_t v27 = 100; // 0x355b8
                    if (v23 + v2 % 256 <= 99) {
                        // 0x356b4
                        v27 = (function_1e4b0() + v2) % 256;
                    }
                    char * v28 = g289; // 0x355c4
                    if (v28 != (char *)4 && v28 >= (char *)4) {
                        int32_t v29 = function_1e4b0(); // 0x355d0
                        snprintf((char *)&str, 2048, "max temp = %04d, diff = %04d, + pwm form %04d to %04d\n", v6, v19, v29, v27);
                        function_2e584(4, &str, 0);
                    }
                    // 0x35434
                    return function_13fb0(v27);
                }
                if (v19 >= 23) {
                    char * v30 = g289; // 0x3553c
                    int32_t result3 = v18; // 0x35544
                    if (v30 != (char *)4 && v30 >= (char *)4) {
                        int32_t v31 = function_1e4b0(); // 0x35548
                        snprintf((char *)&str, 2048, "max temp = %04d, diff = %04d, = pwm %04d\n", v6, v19, v31);
                        result3 = function_2e584(4, &str, 0);
                    }
                    // 0x35434
                    return result3;
                }
                int32_t v32 = function_1e4b0(); // 0x35614
                float32_t v33 = __asm_vcvt_f32_s32(__asm_vmov_7(v19)); // 0x3561c
                float32_t v34 = __asm_vmov_f32(25.0f); // 0x35620
                float32_t v35 = __asm_vmul_f32(__asm_vdiv_f32(__asm_vsub_f32(v34, v33), v34), __asm_vmov_f32(10.0f)); // 0x35630
                __asm_vstr_12(__asm_vcvt_u32_f32(v35), v2);
                uint32_t v36 = v2 % 256; // 0x3563c
                int32_t v37 = v32 - v36; // 0x35640
                int32_t v38 = v37 < 40 ? 40 : v36;
                int32_t v39 = v37; // 0x3564c
                int32_t v40 = v38; // 0x3564c
                if (v37 > 39) {
                    // 0x35650
                    v39 = function_1e4b0();
                    v40 = (v39 - v38) % 256;
                }
                char * v41 = g289; // 0x35664
                int32_t result4 = v39; // 0x3566c
                if (v41 != (char *)4 && v41 >= (char *)4) {
                    int32_t v42 = function_1e4b0(); // 0x35670
                    snprintf((char *)&str, 2048, "max temp = %04d, diff = %04d, - pwm form %04d to %04d\n", v6, v19, v42, v40);
                    result4 = function_2e584(4, &str, 0);
                }
                // 0x356a8
                if (v6 > 67) {
                    // 0x35434
                    return result4;
                }
                // 0x35434
                return function_13fb0(v40);
            }
        }
    }
    int32_t * v43 = (int32_t *)(v11 + 52); // 0x35404
    if (*v43 != 0) {
        // 0x35434
        return function_13fb0(100);
    }
    char * v44 = g289; // 0x35418
    if (v44 >= (char *)4 == (v44 != (char *)4)) {
        int32_t v45 = *(int32_t *)(v11 + 56); // 0x354d4
        snprintf((char *)&str, 2048, "min pic temp = %d max pic temp = %d pic diff = %d, max chip temp = %d, last diff continuous_time = %d", v5, v6, v18, v7, v45);
        function_2e584(4, &str, 0);
    }
    // 0x35424
    *v43 = 1;
    // 0x35434
    return function_13fb0(100);
}

// Address range: 0x356c4 - 0x359ec
int32_t function_356c4(int32_t a1, int32_t a2) {
    // 0x356c4
    g487 = a1;
    switch (a1) {
        case 0: {
            // 0x359b0
            snprintf((char *)&g89, 64, "J%d:1", a2);
            // break -> 0x3574c
            break;
        }
        case 1: {
            // 0x35990
            snprintf((char *)&g89, 64, "J%d:2", a2);
            // break -> 0x3574c
            break;
        }
        case 2: {
            // 0x35970
            snprintf((char *)&g89, 64, "J%d:8", a2);
            // break -> 0x3574c
            break;
        }
        case 3: {
            // 0x35950
            snprintf((char *)&g89, 64, "J%d:4", a2);
            // break -> 0x3574c
            break;
        }
        case 4: {
            // 0x35930
            snprintf((char *)&g89, 64, "J%d:5", a2);
            // break -> 0x3574c
            break;
        }
        case 5: {
            // 0x35918
            *(int32_t *)&g89 = (int32_t)&g33;
            // break -> 0x3574c
            break;
        }
        case 6: {
            // 0x35900
            *(int32_t *)&g89 = (int32_t)&g37;
            // break -> 0x3574c
            break;
        }
        case 7: {
            // 0x358e0
            snprintf((char *)&g89, 64, "T:%d", a2);
            // break -> 0x3574c
            break;
        }
        case 8: {
            // 0x358c8
            *(int32_t *)&g89 = (int32_t)&g32;
            // break -> 0x3574c
            break;
        }
        case 9: {
            // 0x358b0
            *(int32_t *)&g89 = (int32_t)&g36;
            // break -> 0x3574c
            break;
        }
        case 10: {
            // 0x35898
            *(int32_t *)&g89 = (int32_t)&g29;
            // break -> 0x3574c
            break;
        }
        case 11: {
            // 0x35878
            snprintf((char *)&g89, 64, "J%d:6", a2);
            // break -> 0x3574c
            break;
        }
        case 12: {
            // 0x35860
            *(int32_t *)&g89 = (int32_t)&g34;
            // break -> 0x3574c
            break;
        }
        case 13: {
            // 0x35848
            *(int32_t *)&g89 = (int32_t)&g30;
            // break -> 0x3574c
            break;
        }
        case 14: {
            // 0x35830
            *(int32_t *)&g89 = (int32_t)&g31;
            // break -> 0x3574c
            break;
        }
        case 15: {
            // 0x35818
            *(int32_t *)&g89 = (int32_t)&g40;
            // break -> 0x3574c
            break;
        }
        case 22: {
            // 0x35738
            *(int32_t *)&g89 = (int32_t)&g41;
            // break -> 0x3574c
            break;
        }
        case 17: {
            // 0x35800
            *(int32_t *)&g89 = (int32_t)&g39;
            // break -> 0x3574c
            break;
        }
        case 18: {
            // 0x357e8
            *(int32_t *)&g89 = (int32_t)&g28;
            // break -> 0x3574c
            break;
        }
        case 19: {
            // 0x357d0
            *(int32_t *)&g89 = (int32_t)&g35;
            // break -> 0x3574c
            break;
        }
        case 20: {
            // 0x357b8
            *(int32_t *)&g89 = (int32_t)&g27;
            // break -> 0x3574c
            break;
        }
        case 21: {
            // 0x357a0
            *(int32_t *)&g89 = (int32_t)&g38;
            // break -> 0x3574c
            break;
        }
        default: {
            // 0x359d0
            *(int32_t *)&g89 = 0x6e6b6e75;
            g90 = &g266;
            // break -> 0x3574c
            break;
        }
    }
    int32_t v1 = function_36558(1); // 0x35750
    char * v2 = g289; // 0x3575c
    int32_t result = v1; // 0x35764
    if (v2 != (char *)3 && v2 >= (char *)3) {
        // 0x35768
        int32_t str; // bp-2056, 0x356c4
        snprintf((char *)&str, 2048, "Sweep error string = %s.\n", (char *)&g89);
        result = function_2e584(3, &str, 0);
    }
    // 0x35794
    return result;
}

// Address range: 0x359ec - 0x359f8
int32_t function_359ec(void) {
    // 0x359ec
    return (int32_t)&g89;
}

// Address range: 0x359f8 - 0x35a28
int32_t function_359f8(int32_t a1) {
    int32_t v1 = a1 - 2000; // 0x359fc
    return v1 - v1 % 3000 + 2000;
}

// Address range: 0x35a28 - 0x35b1c
int32_t function_35a28(void) {
    char * v1 = g289; // 0x35a38
    int32_t v2; // 0x35a28
    char * v3; // bp-2072, 0x35a28
    if (v1 == (char *)4 || v1 < (char *)4) {
        // branch -> 0x35a80
    } else {
        // 0x35a48
        v3 = (char *)0x4245445b;
        v2 = function_2e584(4, (int32_t *)&v3, 0);
    }
    int32_t * v4 = (int32_t *)&v3;
    function_452d0(function_452b0(v2) | 0x10000);
    function_2bdd0();
    int32_t v5; // 0x35a28
    int32_t v6; // 0x35a28
    int32_t v7; // 0x35aa0
    while (true) {
        // 0x35a9c
        v7 = __asm_ubfx(function_44d3c(), 1, 8);
        v5 = 0;
        if (v7 != 0) {
            while (true) {
              lab_0x35ac4_2:
                // 0x35ac4
                v6 = v5;
                function_44d94(v4);
                char v8; // 0x35a28
                if (v8 < 0) {
                    // 0x35b10
                    function_39018();
                    goto lab_0x35ab8;
                } else {
                    uint32_t v9 = g234; // 0x35ad8
                    if (v9 >= 510 == (v9 != 510)) {
                        goto lab_0x35af4;
                    } else {
                        uint32_t v10 = g232; // 0x35ae8
                        if (v10 == 510 || v10 < 510) {
                            // 0x35ab4
                            function_39128(v4);
                            goto lab_0x35ab8;
                        } else {
                            goto lab_0x35af4;
                        }
                    }
                }
            }
        }
      lab_0x35b04_2:
        // 0x35b04
        usleep(1000);
    }
  lab_0x35ab8:;
    int32_t v11 = v6 + 1; // 0x35ab8
    int32_t v12 = v11; // 0x35ac0
    if (v7 == v11) {
        // break -> 0x35b04
        goto lab_0x35b04_2;
    }
    // 0x35ac4
    v5 = v12;
    goto lab_0x35ac4_2;
  lab_0x35af4:;
    int32_t v13 = v6 + 1; // 0x35af4
    function_2bdd0();
    v12 = v13;
    if (v7 == v13) {
        // break -> 0x35b04
        goto lab_0x35b04_2;
    }
    // 0x35ac4
    v5 = v12;
    goto lab_0x35ac4_2;
}

// Address range: 0x35b1c - 0x35bb8
int32_t function_35b1c(void) {
    int32_t v1 = 0;
    int32_t v2 = 0;
    int32_t v3 = function_1e29c(v2); // 0x35b4c
    int32_t v4 = v1; // 0x35b60
    float32_t v5; // 0x35b78
    float32_t v6; // 0x35b7c
    int32_t v7; // 0x35b1c
    char * v8; // 0x35b68
    int32_t v9; // 0x35b1c
    if (v3 != 0) {
        // 0x35b64
        v8 = g289;
        v9 = g91 + 4 * v2;
        v5 = __asm_vldr_8(*(int32_t *)(v9 + 0x1020));
        v6 = __asm_vldr_8(*(int32_t *)(*(int32_t *)(g91 + 8) + 20));
        if (v8 >= (char *)3 == (v8 != (char *)3)) {
            // break -> 0x35ba8
            break;
        }
        // 0x35b84
        __asm_vcmpe_f32(v5, v6);
        __asm_vmrs(v7, v7);
        v4 = v1;
        if ((int32_t)v8 < 3) {
            *(int32_t *)(v9 + 0x1040) = 1;
            v4 = 1;
        }
    }
    int32_t v10 = v4;
    int32_t v11 = v2 + 1; // 0x35b9c
    int32_t result = v10; // 0x35ba4
    while (v11 != 4) {
        // 0x35b48
        v1 = v10;
        v2 = v11;
        v3 = function_1e29c(v2);
        v4 = v1;
        if (v3 != 0) {
            // 0x35b64
            v8 = g289;
            v9 = g91 + 4 * v2;
            v5 = __asm_vldr_8(*(int32_t *)(v9 + 0x1020));
            v6 = __asm_vldr_8(*(int32_t *)(*(int32_t *)(g91 + 8) + 20));
            result = v3;
            if (v8 >= (char *)3 == (v8 != (char *)3)) {
                // break -> 0x35ba8
                break;
            }
            // 0x35b84
            __asm_vcmpe_f32(v5, v6);
            __asm_vmrs(v7, v7);
            v4 = v1;
            if ((int32_t)v8 < 3) {
                *(int32_t *)(v9 + 0x1040) = 1;
                v4 = 1;
            }
        }
        // 0x35b9c
        v10 = v4;
        v11 = v2 + 1;
        result = v10;
    }
    // 0x35ba8
    return result;
}

// Address range: 0x35bba - 0x35bfe
int32_t function_35bba(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x35bba
    int32_t v1; // 0x35bba
    bool v2; // 0x35bba
    int32_t v3; // 0x35bba
    if (!v2) {
        *(int16_t *)v3 = (int16_t)v3;
        v1 = 0;
    }
    int32_t v4 = a1; // 0x35bbe
    if (!v2) {
        v4 = function_ff22e246();
    }
    uint32_t v5 = v4;
    if (v2) {
        *(int16_t *)v3 = (int16_t)v3;
    }
    bool v6; // 0x35bba
    bool v7; // 0x35bba
    if (v2) {
        v7 = (v5 / 128 & v5) == 0;
        v6 = (v5 & 64) != 0;
    } else {
        // 0x35bca
        function_ee24e();
        v7 = false;
    }
    int32_t v8; // 0x35bba
    if (v2) {
        // 0x35bd2
        v8 = function_6e60a();
    } else {
        // 0x35bd2
        v8 = function_f120e();
    }
    int32_t v9 = v8;
    bool v10 = v2 ? v6 : (v3 & 32) != 0;
    int32_t v11 = v7 ? v9 : v9 - (int32_t)&g42;
    int32_t v12 = __asm_rsb(v1, 160, 6); // 0x35be6
    if (v7 ? (v11 & 64) != 0 : (v3 & 0x8000000) != 0 == v10) {
        *(int32_t *)v11 = v12;
        *(int32_t *)(v11 + 4) = 0x35bf0;
    }
    int32_t result; // 0x35bba
    if (v2) {
        // 0x35bfa
        result = function_6de06();
    } else {
        // 0x35bfa
        result = function_1b124e();
    }
    // 0x35bfe
    return result;
}

// Address range: 0x35c00 - 0x35c04
int32_t function_35c00(void) {
    // 0x35c00
    int32_t result; // 0x35c00
    return result;
}

// Address range: 0x35c04 - 0x35c74
int32_t function_35c04(int32_t a1) {
    int32_t v1 = 0;
    int32_t v2 = 0;
    int32_t v3 = v1; // 0x35c20
    int32_t v4; // 0x35c44
    int32_t v5; // 0x35c58
    int32_t v6; // 0x35c5c
    int32_t v7; // 0x35c68
    if (function_1e29c(v2) != 0) {
        // 0x35c44
        v4 = function_1e0f0();
        v3 = v1;
        if (v4 != 0) {
            // 0x35c50
            v6 = 0;
            v7 = v1;
            v5 = a1 - 4 + 1024 * v2;
            v5 += 4;
            v6++;
            v7 += function_1e130() * *(int32_t *)v5;
            v3 = v7;
            while (v4 != v6) {
                // 0x35c58
                v5 += 4;
                v6++;
                v7 += function_1e130() * *(int32_t *)v5;
                v3 = v7;
            }
        }
    }
    int32_t v8 = v3;
    int32_t v9 = v2 + 1; // 0x35c24
    while (v9 != 4) {
        // 0x35c14
        v1 = v8;
        v2 = v9;
        v3 = v1;
        if (function_1e29c(v2) != 0) {
            // 0x35c44
            v4 = function_1e0f0();
            v3 = v1;
            if (v4 != 0) {
                // 0x35c50
                v6 = 0;
                v7 = v1;
                v5 = a1 - 4 + 1024 * v2;
                v5 += 4;
                v6++;
                v7 += function_1e130() * *(int32_t *)v5;
                v3 = v7;
                while (v4 != v6) {
                    // 0x35c58
                    v5 += 4;
                    v6++;
                    v7 += function_1e130() * *(int32_t *)v5;
                    v3 = v7;
                }
            }
        }
        // 0x35c24
        v8 = v3;
        v9 = v2 + 1;
    }
    // 0x35c30
    return v8 / 1000;
}

// Address range: 0x35c74 - 0x35d24
int32_t function_35c74(void) {
    char * v1 = g289; // 0x35c84
    int32_t v2 = (int32_t)v1; // 0x35c8c
    int32_t v3; // 0x35c74
    int32_t v4; // 0x35c74
    if (v1 >= (char *)4 == (v1 != (char *)4)) {
        char * v5 = (char *)0x4245445b; // bp-2056, 0x35cc8
        int32_t v6 = (int32_t)&v5; // 0x35ce0
        function_2e584(4, (int32_t *)&v5, 0);
        char * v7 = g289; // 0x35ce8
        v3 = v6;
        v4 = 0;
        v2 = (int32_t)v7;
        if (v7 != (char *)4 && v7 >= (char *)4) {
            // 0x35cf4
            v5 = (char *)0x4245445b;
            function_2e584(4, (int32_t *)&v5, 0);
            v3 = v6;
            v4 = 0;
            v2 = &g463;
        }
    }
    int32_t result = 0; // 0x35ca0
    if (g91 != 0) {
        // 0x35ca4
        result = free(g91, v3, v4, v2);
        g91 = 0;
    }
    // 0x35cb0
    return result;
}

// Address range: 0x35d24 - 0x36174
int32_t function_35d24(int32_t a1, int32_t a2, int32_t a3) {
    char * v1 = g289; // 0x35d3c
    char * str; // bp-2088, 0x35d24
    if (v1 >= (char *)3 == (v1 != (char *)3)) {
        // 0x35fe4
        str = (char *)10;
        function_2ea54(3, (int32_t *)&str, 0);
        char * v2 = g289; // 0x36004
        if (v2 != (char *)3 && v2 >= (char *)3) {
            // 0x36010
            snprintf((char *)&str, 2048, ">>>> Get ideal hash rate, round %d.\n", a3);
            function_2e584(3, (int32_t *)&str, 0);
        }
    }
    int32_t result = function_39fb4(a2); // 0x35d50
    if (result != 0) {
        char * v3 = g289; // 0x35d5c
        if (v3 >= (char *)3 != v3 != (char *)3) {
            // 0x35d68
            return result;
        }
        // 0x35d78
        str = (char *)0x72616f42;
        function_2e584(3, (int32_t *)&str, 0);
        return result;
    }
    int32_t v4 = function_39a7c(); // 0x35db4
    int32_t v5 = *(int32_t *)(v4 + 16); // 0x35dc0
    if (v4 > v5) {
        *(int32_t *)v4 = v5;
    }
    g92 = v4 > v5 ? g91 : v4;
    __asm_vcvt_f32_s32(__asm_vldr_8(g296));
    unsigned char v6 = *(char *)(*(int32_t *)(g91 + 8) + 8); // 0x35e08
    function_1ad08((int32_t *)(g91 + 12), g66, (int32_t)v6);
    if (function_19ab4() != g92) {
        int32_t result2 = function_195a8(g92); // 0x35e24
        if (result2 != 0) {
            // 0x35d68
            return result2;
        }
    }
    int32_t v7 = 0xffffff;
    int32_t v8 = 0;
    int32_t v9 = v7; // 0x35e44
    uint32_t v10; // 0x35d24
    int32_t v11; // 0x35d24
    int32_t v12; // 0x35e48
    int32_t v13; // 0x35d24
    int32_t v14; // 0x35e6c
    uint32_t v15; // 0x35e6c
    if (function_1e29c(v8) != 0) {
        // 0x35e48
        v12 = function_1e0f0();
        v9 = v7;
        if (v12 != 0) {
            // 0x35e54
            v13 = g91 + 8;
            v14 = v13 + 1024 * v8;
            v10 = v7;
            v14 += 4;
            v15 = *(int32_t *)v14;
            v11 = v10 < v15 ? v10 : v15;
            v9 = v11;
            while (v14 != v13 + 4 * (v12 + 256 * v8)) {
                // 0x35e6c
                v10 = v11;
                v14 += 4;
                v15 = *(int32_t *)v14;
                v11 = v10 < v15 ? v10 : v15;
                v9 = v11;
            }
        }
    }
    int32_t v16 = v9;
    int32_t v17 = v8 + 1; // 0x35e80
    while (v17 != 4) {
        // 0x35e38
        v7 = v16;
        v8 = v17;
        v9 = v7;
        if (function_1e29c(v8) != 0) {
            // 0x35e48
            v12 = function_1e0f0();
            v9 = v7;
            if (v12 != 0) {
                // 0x35e54
                v13 = g91 + 8;
                v14 = v13 + 1024 * v8;
                v10 = v7;
                v14 += 4;
                v15 = *(int32_t *)v14;
                v11 = v10 < v15 ? v10 : v15;
                v9 = v11;
                while (v14 != v13 + 4 * (v12 + 256 * v8)) {
                    // 0x35e6c
                    v10 = v11;
                    v14 += 4;
                    v15 = *(int32_t *)v14;
                    v11 = v10 < v15 ? v10 : v15;
                    v9 = v11;
                }
            }
        }
        // 0x35e80
        v16 = v9;
        v17 = v8 + 1;
    }
    char * v18 = g289; // 0x35e8c
    if (v18 >= (char *)3 == (v18 != (char *)3)) {
        // 0x360a0
        snprintf((char *)&str, 2048, "chain = %d, freq_min = %d\n", 255, v16);
        function_2e584(3, (int32_t *)&str, 0);
    }
    int32_t v19 = 0;
    int32_t v20 = 0;
    int32_t v21 = v20; // 0x35eb0
    uint32_t v22; // 0x35d24
    int32_t v23; // 0x35d24
    int32_t v24; // 0x35eb4
    int32_t v25; // 0x35d24
    int32_t v26; // 0x35ed8
    uint32_t v27; // 0x35ed8
    if (function_1e29c(v19) != 0) {
        // 0x35eb4
        v24 = function_1e0f0();
        v21 = v20;
        if (v24 != 0) {
            // 0x35ec0
            v25 = g91 + 8;
            v26 = v25 + 1024 * v19;
            v22 = v20;
            v26 += 4;
            v27 = *(int32_t *)v26;
            v23 = v22 < v27 ? v27 : v22;
            v21 = v23;
            while (v26 != v25 + 4 * (v24 + 256 * v19)) {
                // 0x35ed8
                v22 = v23;
                v26 += 4;
                v27 = *(int32_t *)v26;
                v23 = v22 < v27 ? v27 : v22;
                v21 = v23;
            }
        }
    }
    int32_t v28 = v21;
    int32_t v29 = v19 + 1; // 0x35eec
    while (v29 != 4) {
        // 0x35ea4
        v19 = v29;
        v20 = v28;
        v21 = v20;
        if (function_1e29c(v19) != 0) {
            // 0x35eb4
            v24 = function_1e0f0();
            v21 = v20;
            if (v24 != 0) {
                // 0x35ec0
                v25 = g91 + 8;
                v26 = v25 + 1024 * v19;
                v22 = v20;
                v26 += 4;
                v27 = *(int32_t *)v26;
                v23 = v22 < v27 ? v27 : v22;
                v21 = v23;
                while (v26 != v25 + 4 * (v24 + 256 * v19)) {
                    // 0x35ed8
                    v22 = v23;
                    v26 += 4;
                    v27 = *(int32_t *)v26;
                    v23 = v22 < v27 ? v27 : v22;
                    v21 = v23;
                }
            }
        }
        // 0x35eec
        v28 = v21;
        v29 = v19 + 1;
    }
    char * v30 = g289; // 0x35ef8
    if (v30 >= (char *)3 == (v30 != (char *)3)) {
        // 0x36070
        snprintf((char *)&str, 2048, "chain = %d, freq_max = %d\n", 255, v28);
        function_2e584(3, (int32_t *)&str, 0);
    }
    int32_t v31 = v28; // bp-2092, 0x35f1c
    function_321b8(v16, g283, 20);
    int32_t v32 = 0;
    if (function_1e29c(v32) != 0) {
        // 0x3604c
        function_3962c(v32, 1);
    }
    int32_t v33 = v32 + 1; // 0x35f34
    while (v33 != 4) {
        // 0x35f24
        v32 = v33;
        if (function_1e29c(v32) != 0) {
            // 0x3604c
            function_3962c(v32, 1);
        }
        // 0x35f34
        v33 = v32 + 1;
    }
    // 0x35f40
    function_3a86c(&v31);
    int32_t v34 = function_391f4(); // 0x35f4c
    int32_t v35 = 0;
    if (function_1e29c(v35) != 0) {
        // 0x3603c
        function_3a054(v35, v34);
    }
    int32_t v36 = v35 + 1; // 0x35f64
    while (v36 != 4) {
        // 0x35f54
        v35 = v36;
        if (function_1e29c(v35) != 0) {
            // 0x3603c
            function_3a054(v35, v34);
        }
        // 0x35f64
        v36 = v35 + 1;
    }
    int32_t v37 = 0;
    int32_t v38 = 0;
    int32_t v39 = v38; // 0x35f9c
    int32_t v40; // 0x35d24
    int32_t v41; // 0x35d24
    int32_t v42; // 0x35d24
    int32_t v43; // 0x35d24
    int32_t v44; // 0x35d24
    int32_t v45; // 0x360d0
    char * v46; // 0x36128
    int32_t v47; // 0x360e4
    int32_t v48; // 0x36100
    int32_t v49; // 0x36104
    int32_t v50; // 0x36114
    if (function_1e29c(v37) != 0) {
        // 0x360d0
        v45 = function_1e0f0();
        v43 = v38;
        v41 = 0;
        if (v45 != 0) {
            // 0x360e0
            v47 = 1024 * v37;
            v48 = g91 + (v47 | 8);
            v49 = v34 + (int32_t)&g366 + v47;
            v48 += 4;
            v49 += 4;
            v50 = *(int32_t *)v49 * *(int32_t *)v48 / 0x1f40;
            v40 = v50;
            while (g91 + 8 + 4 * (v45 + 256 * v37) != v48) {
                // 0x36100
                v48 += 4;
                v49 += 4;
                v50 = v40 + *(int32_t *)v49 * *(int32_t *)v48 / 0x1f40;
                v40 = v50;
            }
            // 0x3611c
            v43 = v50 + v38;
            v41 = v50;
        }
        // 0x36128
        v42 = v41;
        v44 = v43;
        v46 = g289;
        *(int32_t *)(4 * v37 + 0x100c + g91) = v42;
        v39 = v44;
        if (v46 != (char *)3 && v46 >= (char *)3) {
            // 0x36144
            snprintf((char *)&str, 2048, "chain = %d, ideal_hash_rate_GH = %d\n", v37, v42);
            function_2e584(3, (int32_t *)&str, 0);
            v39 = v44;
        }
    }
    int32_t v51 = v39;
    int32_t v52 = v37 + 1; // 0x35fa0
    while (v52 != 4) {
        // 0x35f90
        v37 = v52;
        v38 = v51;
        v39 = v38;
        if (function_1e29c(v37) != 0) {
            // 0x360d0
            v45 = function_1e0f0();
            v43 = v38;
            v41 = 0;
            if (v45 != 0) {
                // 0x360e0
                v47 = 1024 * v37;
                v48 = g91 + (v47 | 8);
                v49 = v34 + (int32_t)&g366 + v47;
                v48 += 4;
                v49 += 4;
                v50 = *(int32_t *)v49 * *(int32_t *)v48 / 0x1f40;
                v40 = v50;
                while (g91 + 8 + 4 * (v45 + 256 * v37) != v48) {
                    // 0x36100
                    v48 += 4;
                    v49 += 4;
                    v50 = v40 + *(int32_t *)v49 * *(int32_t *)v48 / 0x1f40;
                    v40 = v50;
                }
                // 0x3611c
                v43 = v50 + v38;
                v41 = v50;
            }
            // 0x36128
            v42 = v41;
            v44 = v43;
            v46 = g289;
            *(int32_t *)(4 * v37 + 0x100c + g91) = v42;
            v39 = v44;
            if (v46 != (char *)3 && v46 >= (char *)3) {
                // 0x36144
                snprintf((char *)&str, 2048, "chain = %d, ideal_hash_rate_GH = %d\n", v37, v42);
                function_2e584(3, (int32_t *)&str, 0);
                v39 = v44;
            }
        }
        // 0x35fa0
        v51 = v39;
        v52 = v37 + 1;
    }
    char * v53 = g289; // 0x35fac
    if (v53 != (char *)3 && v53 >= (char *)3) {
        // 0x35fb8
        snprintf((char *)&str, 2048, "hash_rate_total_GH = %d\n", v51);
        function_2e584(3, (int32_t *)&str, 0);
    }
    // 0x35d68
    return 0;
}

// Address range: 0x36174 - 0x361e4
int32_t function_36174(int32_t result) {
    // 0x36174
    function_356c4(15, 255);
    char * v1 = g289; // 0x36194
    if (v1 != (char *)3 && v1 >= (char *)3) {
        // 0x361a0
        int32_t str; // bp-2056, 0x36174
        snprintf((char *)&str, 2048, "Unknown miner type(%d).\n", 2);
        function_2e584(3, &str, 0);
    }
    // 0x361c8
    *(int32_t *)result = 3000;
    *(int32_t *)(result + 4) = 2000;
    *(int32_t *)(result + 8) = 0x359f8;
    return result;
}

// Address range: 0x361e4 - 0x361f4
int32_t function_361e4(int32_t result) {
    // 0x361e4
    g92 = result;
    return result;
}

// Address range: 0x361f4 - 0x36204
int32_t function_361f4(void) {
    // 0x361f4
    return g92;
}

// Address range: 0x36204 - 0x36208
int32_t function_36204(void) {
    // 0x36204
    return function_19ab4();
}

// Address range: 0x36208 - 0x36218
int32_t function_36208(int32_t a1) {
    // 0x36208
    return function_195a8(g92);
}

// Address range: 0x36218 - 0x362a0
int32_t function_36218(void) {
    struct _IO_FILE * file = fopen64("/config/scanfreqdone", "r"); // 0x36230
    char * v1 = g289; // 0x36240
    if (v1 >= (char *)4 == (v1 != (char *)4)) {
        char * v2 = (char *)0x4245445b; // bp-2056, 0x36274
        function_2e584(4, (int32_t *)&v2, 0);
    }
    int32_t result = (int32_t)file; // 0x36250
    if (file != NULL) {
        // 0x36254
        fclose(file);
        result = 1;
    }
    // 0x3625c
    return result;
}

// Address range: 0x362a0 - 0x36538
int32_t function_362a0(int32_t a1) {
    int32_t v1 = function_36218(); // 0x362b0
    char * v2; // bp-2056, 0x362a0
    char * str; // bp-2072, 0x362a0
    if (v1 != 0) {
        char * v3 = g289; // 0x362c4
        if (v3 >= (char *)3 != v3 != (char *)3) {
            // 0x362d4
            return v3 == (char *)3 | v3 < (char *)3 ? 0 : v1;
        }
        // 0x362e0
        str = (char *)0x65657753;
        v2 = (char *)0x202c656e;
        function_2e584(3, (int32_t *)&str, 0);
        return 0;
    }
    // 0x36328
    int32_t v4; // bp-2080, 0x362a0
    function_302a0(&v4);
    char * v5 = g289; // 0x3633c
    int32_t v6 = a1 - 160; // 0x36348
    g93 = 2;
    int32_t v7; // 0x362a0
    int32_t v8; // 0x362a0
    if (v5 >= (char *)4 == (v5 != (char *)4)) {
        // 0x36390
        snprintf((char *)&str, 2048, "[DEBUG] Sweep init, sweep_type = 0x%X.\n", a1);
        function_2e584(4, (int32_t *)&str, 0);
        if (v6 != 0 == (v6 != 1)) {
            goto lab_0x36360;
        } else {
            char * v9 = g289; // 0x363c0
            v7 = 0;
            v8 = (int32_t)v9;
            if (v9 != (char *)4 && v9 >= (char *)4) {
                // 0x363cc
                str = (char *)0x4245445b;
                v2 = (char *)0x6d656d20;
                function_2e584(4, (int32_t *)&str, 0);
                v7 = 0;
                v8 = 0x65657773;
            }
            goto lab_0x36400;
        }
    } else {
        // 0x36358
        v7 = 2;
        v8 = (int32_t)v5;
        if (v6 == 1 || v6 == 0) {
            goto lab_0x36400;
        } else {
            goto lab_0x36360;
        }
    }
  lab_0x36360:
    // 0x36360
    function_356c4(20, 255);
    char * v10 = g289; // 0x3636c
    int32_t v11 = (int32_t)"Sweep type error, exit.\n"; // 0x36374
    char ** v12 = &str; // 0x36374
    if (v10 >= (char *)3 != v10 != (char *)3) {
        // 0x36378
        g93 = 1;
        return -1;
    }
    goto lab_0x36490;
  lab_0x36400:;
    int32_t v14 = g91; // 0x36408
    if (g91 == 0) {
        int32_t v21 = function_11eb0(0x107c, 1, v7, v8); // 0x364f4
        g91 = v21;
        v14 = v21;
        if (v21 == 0) {
            // 0x36508
            function_356c4(13, 255);
            char * v22 = g289; // 0x36514
            if (v22 == (char *)3 || v22 < (char *)3) {
                // 0x36378
                g93 = 1;
                return -1;
            }
            // 0x36520
            str = (char *)0x6c696146;
            v11 = (int32_t)" memory for sweep ctxt.\n";
            v12 = &v2;
            goto lab_0x36490;
        } else {
            goto lab_0x3640c;
        }
    } else {
        goto lab_0x3640c;
    }
  lab_0x36490:;
    int32_t v13 = (int32_t)v12;
    *(int32_t *)v12 = *(int32_t *)v11;
    *(int32_t *)(v13 + 4) = *(int32_t *)(v11 + 4);
    *(int32_t *)(v13 + 8) = *(int32_t *)(v11 + 8);
    *(int32_t *)(v13 + 12) = *(int32_t *)(v11 + 12);
    *(int32_t *)(v13 + 16) = *(int32_t *)(v11 + 16);
    *(int32_t *)(v13 + 20) = *(int32_t *)(v11 + 20);
    *(char *)(v13 + 24) = (char)*(int32_t *)(v11 + 24);
    function_2e584(3, (int32_t *)&str, 0);
    // 0x36378
    g93 = 1;
    return -1;
  lab_0x3640c:
    // 0x3640c
    *(int32_t *)v14 = a1;
    *(int32_t *)(v14 + 4) = 0x477fff00;
    int32_t v15 = 0;
    uint32_t v16; // 0x364b8
    int32_t v17; // 0x362a0
    int32_t v18; // 0x364dc
    if (function_1e29c(v15) != 0) {
        // 0x364b8
        v16 = function_1e0f0();
        if (v16 >= 1) {
            // 0x364c4
            v17 = g91 + 8;
            v18 = v17 + 1024 * v15;
            v18 += 4;
            *(int32_t *)v18 = 300;
            while (v18 != v17 + 4 * (v16 + 256 * v15)) {
                // 0x364dc
                v18 += 4;
                *(int32_t *)v18 = 300;
            }
        }
    }
    int32_t v19 = v15 + 1; // 0x36434
    while (v19 != 4) {
        // 0x36424
        v15 = v19;
        if (function_1e29c(v15) != 0) {
            // 0x364b8
            v16 = function_1e0f0();
            if (v16 >= 1) {
                // 0x364c4
                v17 = g91 + 8;
                v18 = v17 + 1024 * v15;
                v18 += 4;
                *(int32_t *)v18 = 300;
                while (v18 != v17 + 4 * (v16 + 256 * v15)) {
                    // 0x364dc
                    v18 += 4;
                    *(int32_t *)v18 = 300;
                }
            }
        }
        // 0x36434
        v19 = v15 + 1;
    }
    // 0x36440
    function_356c4(15, 255);
    char * v20 = g289; // 0x3644c
    if (v20 != (char *)3 && v20 >= (char *)3) {
        // 0x36458
        snprintf((char *)&str, 2048, "Unknown miner type(%d).\n", 2);
        function_2e584(3, (int32_t *)&str, 0);
    }
    // 0x36378
    g93 = 1;
    return -1;
}

// Address range: 0x36538 - 0x36548
int32_t function_36538(int32_t * a1) {
    // 0x36538
    *a1 = 1000;
    return 0;
}

// Address range: 0x36548 - 0x36558
int32_t function_36548(void) {
    // 0x36548
    return g93;
}

// Address range: 0x36558 - 0x36568
int32_t function_36558(int32_t result) {
    // 0x36558
    g93 = result;
    return result;
}

// Address range: 0x36568 - 0x3656c
int32_t function_36568(void) {
    // 0x36568
    int32_t result; // 0x36568
    return result;
}

// Address range: 0x3656c - 0x365e8
int32_t function_3656c(void) {
    char * v1 = g289; // 0x36574
    if (v1 >= (char *)4 != v1 != (char *)4) {
        // 0x36580
        return g94 + 8;
    }
    char * v2 = (char *)0x4245445b; // bp-2056, 0x365b4
    function_2e584(4, (int32_t *)&v2, 0);
    return g94 + 8;
}

// Address range: 0x365e8 - 0x36680
int32_t function_365e8(int32_t a1) {
    char * v1 = g289; // 0x36600
    if (v1 >= (char *)4 == (v1 != (char *)4)) {
        // 0x36654
        int32_t str; // bp-2064, 0x365e8
        snprintf((char *)&str, 2048, "[DEBUG] Check if is recv nonce enough, chain = %d.\n", a1);
        function_2e584(4, &str, 0);
    }
    uint32_t v2 = *(int32_t *)(g94 + 4 * (a1 + (int32_t)&g10)); // 0x36624
    int32_t v3 = function_1e130(); // 0x36628
    return v2 >= 8 * v3 * function_1e0f0();
}

// Address range: 0x36680 - 0x367e4
int32_t function_36680(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    // 0x36680
    float64_t v1; // 0x36680
    float64_t v2 = __asm_vpush_11(v1, v1); // 0x3668c
    char * v3 = g289; // 0x36694
    if (v3 >= (char *)4 == (v3 != (char *)4)) {
        // 0x367b8
        int32_t str; // bp-2088, 0x36680
        snprintf((char *)&str, 2048, "[DEBUG] Check if is unbalanche happen, chain = %d\n", a1);
        function_2e584(4, &str, 0);
    }
    int32_t result = function_1e0f0(); // 0x366a8
    if (result != 0) {
        // 0x366b8
        return result;
    }
    // 0x367a4
    __asm_vpop_13(v2, v2);
    return 0;
}

// Address range: 0x367e4 - 0x36884
int32_t function_367e4(void) {
    char * v1 = g289; // 0x367f4
    if (v1 >= (char *)4 == (v1 != (char *)4)) {
        char * v2 = (char *)0x4245445b; // bp-2056, 0x36860
        function_2e584(4, (int32_t *)&v2, 0);
    }
    // 0x36800
    function_1f1ec(255, 0);
    int32_t v3 = 0;
    int32_t v4 = 0; // 0x3681c
    if (function_1e29c(v3) != 0) {
        // 0x36844
        v4 = function_50e78(v3);
    }
    int32_t v5 = v3 + 1; // 0x36820
    while (v5 != 4) {
        // 0x36810
        v3 = v5;
        v4 = 0;
        if (function_1e29c(v3) != 0) {
            // 0x36844
            v4 = function_50e78(v3);
        }
        // 0x36820
        v5 = v3 + 1;
    }
    // 0x3682c
    return function_44794(function_4476c(v4) & -0x8f01 | 0x8400);
}

// Address range: 0x36884 - 0x36908
int32_t function_36884(void) {
    char * v1 = g289; // 0x36898
    if (v1 != (char *)4 && v1 >= (char *)4) {
        char * v2 = (char *)0x4245445b; // bp-2056, 0x368b4
        function_2e584(4, (int32_t *)&v2, 0);
    }
    int32_t * set_mem = memset((int32_t *)(g94 + 8), 0, (int32_t)&g376); // 0x368f8
    return (int32_t)set_mem;
}

// Address range: 0x36908 - 0x36a0c
int32_t function_36908(void) {
    char * v1 = g289; // 0x3691c
    char * v2; // 0x36908
    char * v3; // 0x36908
    char * v4; // 0x36908
    int32_t v5; // bp-2072, 0x36908
    if (v1 >= (char *)4 == (v1 != (char *)4)) {
        // 0x369cc
        v5 = 0x4245445b;
        function_2e584(4, &v5, 0);
        v3 = (char *)0x646e6553;
        v2 = (char *)0x6d2d3120;
        v4 = (char *)0x205d4755;
    }
    // 0x3692c
    memset(&v5, 0, 52);
    v5 = 1;
    uint32_t v6 = 0;
    int32_t v7 = function_1e29c(v6); // 0x36954
    int32_t result = 0; // 0x36960
    int32_t v8; // 0x36908
    int32_t v9 = v8; // 0x36960
    int32_t v10; // 0x36908
    int32_t v11; // 0x3697c
    if (v7 != 0) {
        // 0x36980
        v10 = v7 == 0 ? v8 : 1 << v6;
        if ((function_44ed4(v7) & v10) == 0) {
            v11 = function_304d4(1);
            while ((function_44ed4(v11) & v10) == 0) {
                // 0x3697c
                v11 = function_304d4(1);
            }
        }
        // 0x36990
        function_1edf0(v5, (int32_t)v4, (int32_t)v3, (int32_t)v2);
        result = function_304d4(10);
        v9 = v6 | -128;
    }
    int32_t v12 = v6 + 1; // 0x36964
    while (v12 != 4) {
        int32_t v13 = v9;
        v6 = v12;
        v7 = function_1e29c(v6);
        result = 0;
        v9 = v13;
        if (v7 != 0) {
            // 0x36980
            v10 = v7 == 0 ? v13 : 1 << v6;
            if ((function_44ed4(v7) & v10) == 0) {
                v11 = function_304d4(1);
                while ((function_44ed4(v11) & v10) == 0) {
                    // 0x3697c
                    v11 = function_304d4(1);
                }
            }
            // 0x36990
            function_1edf0(v5, (int32_t)v4, (int32_t)v3, (int32_t)v2);
            result = function_304d4(10);
            v9 = v6 | -128;
        }
        // 0x36964
        v12 = v6 + 1;
    }
    // 0x36970
    return result;
}

// Address range: 0x36a0c - 0x36aa8
int32_t function_36a0c(void) {
    char * v1 = g289; // 0x36a1c
    int32_t v2; // 0x36a0c
    int32_t v3; // 0x36a0c
    if (v1 >= (char *)4 == (v1 != (char *)4)) {
        char * v4 = (char *)0x4245445b; // bp-2056, 0x36a78
        function_2e584(4, (int32_t *)&v4, 0);
        v2 = (int32_t)&v4;
        v3 = 0;
    }
    // 0x36a28
    if (g94 == 0) {
        // 0x36a60
        return 0;
    }
    int32_t v5 = *(int32_t *)(g94 + 4); // 0x36a3c
    int32_t v6 = g94; // 0x36a44
    if (v5 != 0) {
        // 0x36a48
        free(v5, v2, v3, v5);
        v6 = g94;
    }
    int32_t result = free(v6, v2, v3, v5); // 0x36a54
    g94 = 0;
    // 0x36a60
    return result;
}

// Address range: 0x36aa8 - 0x36b04
int32_t function_36aa8(void) {
    char * v1 = g289; // 0x36abc
    if (v1 != (char *)4 && v1 >= (char *)4) {
        char * v2 = (char *)0x4245445b; // bp-2056, 0x36ad8
        function_2e584(4, (int32_t *)&v2, 0);
    }
    // 0x36af4
    return function_36a0c();
}

// Address range: 0x36b04 - 0x36ca8
int32_t function_36b04(void) {
    char * v1 = g289; // 0x36b14
    int32_t v2; // 0x36b04
    char * v3; // bp-2064, 0x36b04
    if (v1 >= (char *)4 == (v1 != (char *)4)) {
        // 0x36b40
        v3 = (char *)0x4245445b;
        function_2e584(4, (int32_t *)&v3, 0);
        char * v4 = g289; // 0x36b6c
        v2 = 0;
        if (v4 != (char *)4 && v4 >= (char *)4) {
            // 0x36b78
            v3 = (char *)0x4245445b;
            function_2e584(4, (int32_t *)&v3, 0);
            v2 = 0;
        }
    }
    // 0x36b20
    if (g94 != 0) {
        // 0x36b38
        return 0;
    }
    int32_t v5 = function_11eb0((int32_t)&g423, 1, v2, 0); // 0x36bc8
    g94 = v5;
    if (v5 == 0) {
        // 0x36c54
        function_356c4(13, 255);
        char * v6 = g289; // 0x36c60
        if (v6 != (char *)3 && v6 >= (char *)3) {
            // 0x36c6c
            v3 = (char *)0x6c696146;
            function_2e584(3, (int32_t *)&v3, 0);
        }
        // 0x36b38
        return -1;
    }
    int32_t * mem = malloc(1024); // 0x36be0
    int32_t v7 = (int32_t)mem; // 0x36be0
    *(int32_t *)(v5 + 4) = v7;
    if (mem != NULL) {
        // 0x36b38
        return 0;
    }
    // 0x36bf4
    function_36a0c();
    function_356c4(13, 255);
    char * v8 = g289; // 0x36c04
    if (v8 != (char *)3 && v8 >= (char *)3) {
        // 0x36c10
        v3 = (char *)0x6c696146;
        function_2e584(3, (int32_t *)&v3, v7);
    }
    // 0x36b38
    return -1;
}

// Address range: 0x36ca8 - 0x36d64
int32_t function_36ca8(int32_t a1, int32_t a2, uint32_t a3, int32_t a4) {
    uint32_t v1 = a3 / 0x10000; // 0x36cb4
    int32_t v2 = 256 * a1 + a2;
    int32_t * v3 = (int32_t *)(a4 + (int32_t)&g358 + 0x9000 + 4 * v2); // 0x36ce0
    *v3 = *v3 + v1;
    int32_t v4 = 4 * a1 + a4;
    if (v1 <= 8 * function_1e130()) {
        int32_t * v5 = (int32_t *)(v4 + (int32_t)&g358 + 0xa000);
        *v5 = *v5 + v1;
    }
    int32_t * v6 = (int32_t *)(v4 + (int32_t)&g358 + 0xa860); // 0x36d38
    *v6 = a3 % 0x10000 - v1 + *v6;
    *(char *)(*(int32_t *)(g94 + 4) + v2) = 1;
    return function_1e130();
}

// Address range: 0x36d66 - 0x36d6c
int32_t function_36d66(int32_t a1) {
    // 0x36d66
    __asm_udf(a1);
    return function_37288();
}

// Address range: 0x36d6c - 0x36d74
int32_t function_36d6c(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    // 0x36d6c
    int32_t result; // 0x36d6c
    return result;
}

// Address range: 0x36d74 - 0x36dbc
int32_t function_36d74(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    // 0x36d74
    int32_t v1; // 0x36d74
    int32_t v2 = *(int32_t *)(v1 + 0x9000); // 0x36d7c
    int32_t str; // bp+16, 0x36d74
    snprintf((char *)&str, 2048, "Nonce counter overflow: chain = %d, asic = %d, nonce_return = %d, nonce_match = %d, nonce_accumulate = %d\n", v1, v1, v1, v1, v2);
    return function_2e584(3, &str, 0);
}

// Address range: 0x36dbc - 0x36e7c
int32_t function_36dbc(int32_t a1) {
    // 0x36dbc
    int32_t v1; // 0x36dbc
    unsigned char v2 = (char)v1 % 16;
    function_1e160();
    if (v2 != 3 && v2 >= 3) {
        // 0x36ddc
        return function_390b0(a1);
    }
    int32_t v3 = v2; // 0x36dcc
    if (function_1e29c(v3) == 0) {
        // 0x36ddc
        return function_390b0(a1);
    }
    uint32_t v4 = function_5faf8(); // 0x36e08
    uint32_t result = function_1e0f0(); // 0x36e10
    if (result == v4 || result < v4) {
        // 0x36ddc
        return function_390b0(a1);
    }
    switch (*(char *)(a1 + 1)) {
        case -112: {
            // 0x36e24
            if ((*(int32_t *)(a1 + 4) & 136) == 0) {
                return result;
            }
            // 0x36e30
            *(char *)(v4 + 256 * v3 + *(int32_t *)(g94 + 4)) = 1;
            return result;
        }
        case -32: {
            // 0x36e58
            return function_36ca8(v3, v4, *(int32_t *)(a1 + 4), g94 + 8);
        }
    }
    // 0x36ddc
    return function_390b0(a1);
}

// Address range: 0x36e7c - 0x36f2c
int32_t function_36e7c(int32_t a1) {
    char * v1 = g289; // 0x36e94
    if (v1 >= (char *)4 == (v1 != (char *)4)) {
        // 0x36ef8
        int32_t str; // bp-2064, 0x36e7c
        snprintf((char *)&str, 2048, "[DEBUG] Check if read reg done, chain = %d, done_threshold = %d.\n", a1, 1);
        function_2e584(4, &str, 0);
    }
    // 0x36eb0
    function_1e0f0();
    function_1e0f0();
    return 0;
}

// Address range: 0x36f2c - 0x36f6c
int32_t function_36f2c(void) {
    int32_t v1 = 0;
    if (function_1e29c(v1) != 0) {
        // 0x36f58
        if (function_36e7c(v1) == 0) {
            // break -> 0x36f50
            break;
        }
    }
    int32_t v2 = v1 + 1; // 0x36f44
    int32_t result = 1; // 0x36f4c
    while (v2 != 4) {
        // 0x36f34
        v1 = v2;
        if (function_1e29c(v1) != 0) {
            // 0x36f58
            result = 0;
            if (function_36e7c(v1) == 0) {
                // break -> 0x36f50
                break;
            }
        }
        // 0x36f44
        v2 = v1 + 1;
        result = 1;
    }
    // 0x36f50
    return result;
}

// Address range: 0x36f6c - 0x37288
int32_t function_36f6c(int32_t a1, int32_t a2) {
    int32_t v1 = function_3388c(); // 0x36f84
    char * v2 = g289; // 0x36f88
    int32_t v3 = __asm_ubfx(v1, 8, 8); // 0x36f8c
    int32_t v4 = __asm_ubfx(v1, 16, 8); // 0x36f94
    int32_t v5; // 0x36f6c
    int32_t v6; // 0x36f6c
    int32_t * v7; // 0x36f6c
    int32_t v8; // 0x36f6c
    int32_t * v9; // 0x36f6c
    int32_t v10; // 0x36f6c
    int32_t * v11; // 0x36f6c
    int32_t v12; // 0x36f6c
    int32_t v13; // 0x36f6c
    char v14; // 0x36f6c
    int32_t v15; // 0x36f6c
    char v16; // 0x36f6c
    int32_t v17; // 0x36f6c
    int32_t v18; // 0x36f6c
    int32_t v19; // 0x36f6c
    int32_t v20; // 0x36f6c
    int32_t v21; // 0x36f6c
    int32_t v22; // bp-2088, 0x36f6c
    if (v2 >= (char *)4 == (v2 != (char *)4)) {
        // 0x36fb4
        function_37538((int32_t)&g488);
        int32_t v23 = &v22; // 0x36fb8
        v16 = v4;
        v17 = v23;
        v5 = v23 + 12;
        v12 = v23 + 8;
        v13 = v23 + 4;
        v21 = 3;
      lab_0x37094:
        // 0x37094
        v22 = 0x4245445b;
        int32_t * v24 = (int32_t *)v13;
        *v24 = 0x205d4755;
        int32_t * v25 = (int32_t *)v12;
        *v25 = 0x20746553;
        int32_t * v26 = (int32_t *)v5;
        *v26 = 0x72617473;
        *(int32_t *)(v17 + 16) = 0x6f6e2074;
        *(int32_t *)(v17 + 20) = 0x2065636e;
        *(int32_t *)(v17 + 24) = 0x7366666f;
        *(int32_t *)(v17 + 28) = 0x69207465;
        *(int32_t *)(v17 + 32) = 0x6c61766e;
        *(int32_t *)(v17 + 36) = 0xa2e6469;
        *(char *)(v17 + 40) = 0;
        function_2e584(4, &v22, 0);
        v14 = v16;
        v15 = v17;
        v11 = v26;
        v10 = v5;
        v9 = v25;
        v8 = v12;
        v7 = v24;
        v6 = v13;
        v18 = v19;
        v20 = v21;
    } else {
        int32_t v27 = &v22; // 0x36fb8
        int32_t v28 = v27 + 4;
        int32_t v29 = v27 + 8;
        int32_t v30 = v27 + 12;
        v14 = v4;
        v15 = v27;
        v11 = (int32_t *)v30;
        v10 = v30;
        v9 = (int32_t *)v29;
        v8 = v29;
        v7 = (int32_t *)v28;
        v6 = v28;
        v20 = 3;
    }
    int32_t * v31 = v7;
    int32_t * v32 = v9;
    int32_t * v33 = v11;
    char v34 = v14;
    int32_t v35 = v18;
    int32_t v36 = v20; // 0x37080
    int32_t v37 = function_40390(24, 0); // 0x36fe4
    function_44794(function_4476c(v37) & -0x8f01 | 0x8400);
    int32_t v38 = 0;
    if (function_1e29c(v38) != 0) {
        // 0x37110
        function_50288(v38, 1, 0);
    }
    int32_t v39 = v38 + 1; // 0x3700c
    while (v39 != 4) {
        // 0x36ffc
        v38 = v39;
        if (function_1e29c(v38) != 0) {
            // 0x37110
            function_50288(v38, 1, 0);
        }
        // 0x3700c
        v39 = v38 + 1;
    }
    char * v40 = g289; // 0x37018
    if (v40 >= (char *)4 == (v40 != (char *)4)) {
        function_37460();
    }
    // 0x37024
    memset(&v22, 0, 148);
    v22 = 1;
    uint32_t v41 = 0;
    int32_t v42 = function_1e29c(v41); // 0x37044
    v35 = v42 == 0 ? v35 : 1 << v41;
    int32_t v43; // bp-2072, 0x36f6c
    int32_t v44; // bp-2248, 0x36f6c
    int32_t v45; // 0x370d0
    if (v42 != 0) {
        // 0x370d4
        if ((function_44ed4(v42) & v35) == 0) {
            v45 = function_304d4(1);
            while ((function_44ed4(v45) & v35) == 0) {
                // 0x370d0
                v45 = function_304d4(1);
            }
        }
        // 0x370e4
        function_11fc4(&v44, (int32_t)&v43, -124, v41 | -128);
        function_1eeb8(v22, *v31, *v32, *v33);
        function_304d4(10);
    }
    int32_t v46 = v41 + 1; // 0x37054
    int32_t v47 = v35; // 0x3705c
    while (v46 != 4) {
        // 0x37040
        v41 = v46;
        v42 = function_1e29c(v41);
        v35 = v42 == 0 ? v47 : 1 << v41;
        if (v42 != 0) {
            // 0x370d4
            if ((function_44ed4(v42) & v35) == 0) {
                v45 = function_304d4(1);
                while ((function_44ed4(v45) & v35) == 0) {
                    // 0x370d0
                    v45 = function_304d4(1);
                }
            }
            // 0x370e4
            function_11fc4(&v44, (int32_t)&v43, -124, v41 | -128);
            function_1eeb8(v22, *v31, *v32, *v33);
            function_304d4(10);
        }
        // 0x37054
        v46 = v41 + 1;
        v47 = v35;
    }
    int32_t v48 = function_12030(1); // 0x37064
    function_44794(function_4476c(v48) & -0x8f01 | 0x8100);
    usleep(0x186a0);
    while (v36 != 1) {
        // 0x37088
        v36--;
        char * v49 = g289; // 0x37088
        v16 = v34;
        v17 = v15;
        v5 = v10;
        v12 = v8;
        v13 = v6;
        v19 = v35;
        v21 = v36;
        if (v49 != (char *)4 && v49 >= (char *)4) {
            goto lab_0x37094;
        }
        v37 = function_40390(24, 0);
        function_44794(function_4476c(v37) & -0x8f01 | 0x8400);
        v38 = 0;
        if (function_1e29c(v38) != 0) {
            // 0x37110
            function_50288(v38, 1, 0);
        }
        // 0x3700c
        v39 = v38 + 1;
        while (v39 != 4) {
            // 0x36ffc
            v38 = v39;
            if (function_1e29c(v38) != 0) {
                // 0x37110
                function_50288(v38, 1, 0);
            }
            // 0x3700c
            v39 = v38 + 1;
        }
        // 0x37018
        v40 = g289;
        if (v40 >= (char *)4 == (v40 != (char *)4)) {
            function_37460();
        }
        // 0x37024
        memset(&v22, 0, 148);
        v22 = 1;
        v41 = 0;
        v42 = function_1e29c(v41);
        v35 = v42 == 0 ? v35 : 1 << v41;
        if (v42 != 0) {
            // 0x370d4
            if ((function_44ed4(v42) & v35) == 0) {
                v45 = function_304d4(1);
                while ((function_44ed4(v45) & v35) == 0) {
                    // 0x370d0
                    v45 = function_304d4(1);
                }
            }
            // 0x370e4
            function_11fc4(&v44, (int32_t)&v43, -124, v41 | -128);
            function_1eeb8(v22, *v31, *v32, *v33);
            function_304d4(10);
        }
        // 0x37054
        v46 = v41 + 1;
        v47 = v35;
        while (v46 != 4) {
            // 0x37040
            v41 = v46;
            v42 = function_1e29c(v41);
            v35 = v42 == 0 ? v47 : 1 << v41;
            if (v42 != 0) {
                // 0x370d4
                if ((function_44ed4(v42) & v35) == 0) {
                    v45 = function_304d4(1);
                    while ((function_44ed4(v45) & v35) == 0) {
                        // 0x370d0
                        v45 = function_304d4(1);
                    }
                }
                // 0x370e4
                function_11fc4(&v44, (int32_t)&v43, -124, v41 | -128);
                function_1eeb8(v22, *v31, *v32, *v33);
                function_304d4(10);
            }
            // 0x37054
            v46 = v41 + 1;
            v47 = v35;
        }
        // 0x37060
        v48 = function_12030(1);
        function_44794(function_4476c(v48) & -0x8f01 | 0x8100);
        usleep(0x186a0);
    }
    // 0x37124
    function_1f1ec(255, 1);
    function_1efe0(255, (char)v3, v34, 1);
    function_36908();
    usleep(0x186a0);
    function_36908();
    usleep(0x186a0);
    function_36908();
    usleep(0x186a0);
    int32_t v50 = 0; // 0x37174
    if (function_1e29c(v50) != 0) {
        function_37450();
    }
    // 0x37188
    v50++;
    int32_t v51 = 0; // 0x37190
    while (v50 != 4) {
        // 0x37178
        if (function_1e29c(v50) != 0) {
            function_37450();
        }
        // 0x37188
        v50++;
        v51 = 0;
    }
    if (function_1e29c(v51) != 0) {
        function_37444();
    }
    int32_t v52 = v51 + 1; // 0x371a8
    v51 = v52;
    while (v52 != 4) {
        // 0x37198
        if (function_1e29c(v51) != 0) {
            function_37444();
        }
        // 0x371a8
        v52 = v51 + 1;
        v51 = v52;
    }
    for (int32_t i = 3; i > 0; i--) {
        for (int32_t j = 0; j < 4; j++) {
            // 0x371f8
            if (function_1e29c(j) != 0) {
                function_37424();
            }
        }
        // 0x37214
        usleep(0x186a0);
    }
    for (int32_t i = 0; i < 4; i++) {
        // 0x37224
        if (function_1e29c(i) != 0) {
            function_37434();
        }
    }
    for (int32_t i = 8; i > 0; i--) {
        for (int32_t j = 0; j < 4; j++) {
            // 0x3724c
            if (function_1e29c(j) != 0) {
                function_373c8();
            }
        }
        // 0x37268
        usleep(0x7918 - (int32_t)(0xcccccccd * (int64_t)(a2 - 250) / 0x1000000000));
    }
    // 0x37278
    function_36908();
    return usleep(0x186a0);
}

// Address range: 0x37288 - 0x37290
int32_t function_37288(void) {
    // 0x37288
    int32_t v1; // 0x37288
    __asm_ldc2(11, 14, *(int32_t *)(v1 + 1020));
    return function_3864e(0x4000000 * v1);
}

// Address range: 0x37290 - 0x373c8
int32_t function_37290(uint32_t a1, int32_t a2, int32_t str) {
    // 0x37290
    int32_t v1; // 0x37290
    uint32_t v2 = v1;
    usleep(a1 % 0x10000 | 0x10000);
    function_36908();
    usleep(0x186a0);
    function_1efe0(255, (char)a2, (char)v1, v1);
    if (v2 >= 4 == (v2 != 4)) {
        function_374a4((int32_t)&g488);
    }
    // 0x372c8
    memset((int32_t *)*(int32_t *)(g94 + 4), 0, 1024);
    function_1ec84(255, 1, 0, 224);
    int32_t v3 = 5;
    int32_t usec = 0x186a0; // 0x37318
    if (function_36f2c() != 0) {
        usec = function_37494();
    }
    // 0x3731c
    usleep(usec);
    int32_t v4 = v3 - 1; // 0x37324
    while (v3 != 1) {
        // 0x3730c
        v3 = v4;
        usec = 0x186a0;
        if (function_36f2c() != 0) {
            usec = function_37494();
        }
        // 0x3731c
        usleep(usec);
        v4 = v3 - 1;
    }
    int32_t v5 = 95;
    for (int32_t i = 0; i < 4; i++) {
        // 0x37340
        if (function_1e29c(i) != 0) {
            function_373d4();
        }
    }
    // 0x3735c
    usleep(0x186a0);
    if (function_36f2c() != 0) {
        function_37494();
    }
    int32_t v6 = v5 - 1; // 0x37374
    while (v5 != 1) {
        // 0x3733c
        v5 = v6;
        for (int32_t i = 0; i < 4; i++) {
            // 0x37340
            if (function_1e29c(i) != 0) {
                function_373d4();
            }
        }
        // 0x3735c
        usleep(0x186a0);
        if (function_36f2c() != 0) {
            function_37494();
        }
        // 0x37370
        v6 = v5 - 1;
    }
    if (v2 == 3 || v2 < 3) {
        function_37498((int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488);
    }
    // 0x3738c
    snprintf((char *)str, 2048, "Read REG[0x%X] done failed.\n", 224);
    function_2e584(3, (int32_t *)str, 0);
    return -1;
}

// Address range: 0x373c8 - 0x373d4
int32_t function_373c8(void) {
    // 0x373c8
    int32_t v1; // 0x373c8
    return function_50fdc((uint32_t)v1 % 256);
}

// Address range: 0x373d4 - 0x37424
int32_t function_373d4(void) {
    int32_t v1 = function_1e0f0(); // 0x373d4
    int32_t v2; // 0x373d4
    int32_t v3 = 256 * v2 + v2; // 0x373e8
    int32_t v4 = 0;
    int32_t v5 = v1; // 0x373f4
    uint32_t v6; // 0x373fc
    if (*(char *)v3 != 1) {
        // 0x373f8
        v6 = __asm_smulbb(function_1e160(), v4);
        v5 = function_1ec84(v2 % 256, 0, v6 % 256, 224);
    }
    int32_t result = v5;
    int32_t v7 = v4 + 1; // 0x37414
    v3++;
    while (v1 != v7) {
        // 0x373ec
        v4 = v7;
        v5 = result;
        if (*(char *)v3 != 1) {
            // 0x373f8
            v6 = __asm_smulbb(function_1e160(), v4);
            v5 = function_1ec84(v2 % 256, 0, v6 % 256, 224);
        }
        // 0x37414
        result = v5;
        v7 = v4 + 1;
        v3++;
    }
    // 0x37420
    return result;
}

// Address range: 0x37424 - 0x37434
int32_t function_37424(void) {
    // 0x37424
    int32_t v1; // 0x37424
    return function_50f80((uint32_t)v1 % 256, v1);
}

// Address range: 0x37434 - 0x37444
int32_t function_37434(void) {
    // 0x37434
    int32_t v1; // 0x37434
    return function_50fa4((uint32_t)v1 % 256, 8);
}

// Address range: 0x37444 - 0x37450
int32_t function_37444(void) {
    // 0x37444
    int32_t v1; // 0x37444
    return function_50e78((uint32_t)v1 % 256);
}

// Address range: 0x37450 - 0x37460
int32_t function_37450(void) {
    // 0x37450
    int32_t v1; // 0x37450
    return function_50bd4((uint32_t)v1 % 256, 0);
}

// Address range: 0x37460 - 0x37494
int32_t function_37460(void) {
    // 0x37460
    int32_t v1; // 0x37460
    int32_t * v2 = (int32_t *)v1; // 0x37470
    *v2 = 0x4245445b;
    *(int32_t *)(v1 + 4) = 0x205d4755;
    *(int32_t *)(v1 + 8) = 0x646e6553;
    *(int32_t *)(v1 + 12) = 0x6c756e20;
    *(int32_t *)(v1 + 16) = 0x6f77206c;
    *(int32_t *)(v1 + 20) = 0xa2e6b72;
    *(char *)(v1 + 24) = 0;
    return function_2e584(v1, v2, 0);
}

// Address range: 0x37494 - 0x37498
int32_t function_37494(void) {
    // 0x37494
    return 0;
}

// Address range: 0x37498 - 0x374a4
int32_t function_37498(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    // 0x37498
    int32_t result; // 0x37498
    return result;
}

// Address range: 0x374a4 - 0x37538
int32_t function_374a4(int32_t str) {
    int32_t * v1 = (int32_t *)str; // 0x374b8
    *v1 = 0x4245445b;
    *(int32_t *)(str + 4) = 0x205d4755;
    *(int32_t *)(str + 8) = 0x20746547;
    *(int32_t *)(str + 12) = 0x636e6f6e;
    *(int32_t *)(str + 16) = 0x6f632065;
    *(int32_t *)(str + 20) = 0x65746e75;
    *(int32_t *)(str + 24) = 0x63202c72;
    *(int32_t *)(str + 28) = 0x6e696168;
    *(int16_t *)(str + 32) = 2606;
    *(char *)(str + 34) = 0;
    int32_t v2; // 0x374a4
    function_2e584(v2, v1, v2);
    snprintf((char *)str, 2048, "[DEBUG] Read reg and wait done, reg = %d, done_threshold = %d.\n", 224, 1);
    return function_2e584(v2, v1, v2);
}

// Address range: 0x37538 - 0x37574
int32_t function_37538(int32_t a1) {
    // 0x37538
    int32_t str; // bp+160, 0x37538
    snprintf((char *)&str, 2048, "[DEBUG] Send work, max_freq = %d\n", a1);
    return function_2e584(4, &str, 0);
}

// Address range: 0x37574 - 0x375e4
int32_t function_37574(void) {
    char * v1 = g289; // 0x3757c
    if (v1 >= (char *)4 != v1 != (char *)4) {
        // 0x37588
        return (int32_t)&g305;
    }
    char * v2 = (char *)0x4245445b; // bp-2056, 0x375b0
    function_2e584(4, (int32_t *)&v2, 0);
    return (int32_t)&g305;
}

// Address range: 0x375e4 - 0x375e8
int32_t function_375e4(void) {
    // 0x375e4
    int32_t result; // 0x375e4
    return result;
}

// Address range: 0x375e8 - 0x375fc
int32_t function_375e8(void) {
    // 0x375e8
    return g95 + 8;
}

// Address range: 0x375fc - 0x37694
int32_t function_375fc(int32_t a1) {
    char * v1 = g289; // 0x37614
    if (v1 >= (char *)4 == (v1 != (char *)4)) {
        // 0x37668
        int32_t str; // bp-2064, 0x375fc
        snprintf((char *)&str, 2048, "[DEBUG] Check if is recv nonce enough, chain = %d.\n", a1);
        function_2e584(4, &str, 0);
    }
    uint32_t v2 = *(int32_t *)(g95 + 4 * (a1 + (int32_t)&g10)); // 0x37638
    int32_t v3 = function_1e130(); // 0x3763c
    return v2 >= 8 * v3 * function_1e0f0();
}

// Address range: 0x37694 - 0x377b8
int32_t function_37694(int32_t a1) {
    // 0x37694
    function_1e0e0();
    function_5f880();
    function_1e150();
    uint32_t v1 = function_5f880(); // 0x376e0
    int32_t v2 = function_1e0e0(); // 0x376e8
    if (v2 == 0) {
        // 0x37778
        return 0;
    }
    uint32_t v3 = v1 / 2; // 0x376e4
    int32_t result = 0;
    int32_t v4 = 0;
    int32_t v5 = result; // 0x37764
    int32_t v6 = 0; // 0x37764
    int32_t v7 = result; // 0x37764
    int32_t v8; // 0x37694
    int32_t str; // bp-2088, 0x37694
    uint32_t v9; // 0x3773c
    char * v10; // 0x37748
    int32_t v11; // 0x37758
    uint32_t v12; // 0x3775c
    int32_t v13; // 0x3772c
    if (function_1e150() != 0) {
        v13 = function_1e150() * v4 + v6;
        v9 = *(int32_t *)(4 * (64 * a1 + (int32_t)&g11 + v13) + g95);
        v8 = v5;
        if (v9 < v3) {
            // 0x37748
            v10 = g289;
            v8 = 1;
            if (v10 >= (char *)3 == (v10 != (char *)3)) {
                // 0x37788
                snprintf((char *)&str, 2048, "Domain unbalance happen, chain = %d, domain = %d, nonce_num_domain = %d, threshold = %d.\n", a1, v13, v9, v3);
                function_2e584(3, &str, 0);
                v8 = 1;
            }
        }
        // 0x37758
        v11 = v6 + 1;
        v12 = function_1e150();
        v5 = v8;
        v6 = v11;
        v7 = v8;
        while (v12 >= v11 == (v12 != v11)) {
            // 0x37728
            v13 = function_1e150() * v4 + v6;
            v9 = *(int32_t *)(4 * (64 * a1 + (int32_t)&g11 + v13) + g95);
            v8 = v5;
            if (v9 < v3) {
                // 0x37748
                v10 = g289;
                v8 = 1;
                if (v10 >= (char *)3 == (v10 != (char *)3)) {
                    // 0x37788
                    snprintf((char *)&str, 2048, "Domain unbalance happen, chain = %d, domain = %d, nonce_num_domain = %d, threshold = %d.\n", a1, v13, v9, v3);
                    function_2e584(3, &str, 0);
                    v8 = 1;
                }
            }
            // 0x37758
            v11 = v6 + 1;
            v12 = function_1e150();
            v5 = v8;
            v6 = v11;
            v7 = v8;
        }
    }
    // 0x37768
    result = v7;
    int32_t v14 = v4 + 1; // 0x3776c
    while (v2 != v14) {
        // 0x37714
        v4 = v14;
        v5 = result;
        v6 = 0;
        v7 = result;
        if (function_1e150() != 0) {
            v13 = function_1e150() * v4 + v6;
            v9 = *(int32_t *)(4 * (64 * a1 + (int32_t)&g11 + v13) + g95);
            v8 = v5;
            if (v9 < v3) {
                // 0x37748
                v10 = g289;
                v8 = 1;
                if (v10 >= (char *)3 == (v10 != (char *)3)) {
                    // 0x37788
                    snprintf((char *)&str, 2048, "Domain unbalance happen, chain = %d, domain = %d, nonce_num_domain = %d, threshold = %d.\n", a1, v13, v9, v3);
                    function_2e584(3, &str, 0);
                    v8 = 1;
                }
            }
            // 0x37758
            v11 = v6 + 1;
            v12 = function_1e150();
            v5 = v8;
            v6 = v11;
            v7 = v8;
            while (v12 >= v11 == (v12 != v11)) {
                // 0x37728
                v13 = function_1e150() * v4 + v6;
                v9 = *(int32_t *)(4 * (64 * a1 + (int32_t)&g11 + v13) + g95);
                v8 = v5;
                if (v9 < v3) {
                    // 0x37748
                    v10 = g289;
                    v8 = 1;
                    if (v10 >= (char *)3 == (v10 != (char *)3)) {
                        // 0x37788
                        snprintf((char *)&str, 2048, "Domain unbalance happen, chain = %d, domain = %d, nonce_num_domain = %d, threshold = %d.\n", a1, v13, v9, v3);
                        function_2e584(3, &str, 0);
                        v8 = 1;
                    }
                }
                // 0x37758
                v11 = v6 + 1;
                v12 = function_1e150();
                v5 = v8;
                v6 = v11;
                v7 = v8;
            }
        }
        // 0x37768
        result = v7;
        v14 = v4 + 1;
    }
    // 0x37778
    return result;
}

// Address range: 0x377b8 - 0x377d8
int32_t function_377b8(void) {
    int32_t * set_mem = memset((int32_t *)(g95 + 8), 0, (int32_t)&g376); // 0x377d4
    return (int32_t)set_mem;
}

// Address range: 0x377d8 - 0x378a0
int32_t function_377d8(int32_t a1) {
    // 0x377d8
    int32_t v1; // bp-2304, 0x377d8
    function_302a0(&v1);
    char * v2 = g289; // 0x37800
    if (v2 >= (char *)3 == (v2 != (char *)3)) {
        function_37bdc();
    }
    // 0x3780c
    if (function_1e0f0() == 0) {
        function_37c40((int32_t)&g488);
    }
    int32_t v3 = function_1e130(); // 0x37884
    int32_t result = v3; // 0x37890
    if (v3 == 0) {
        result = function_37ac0((int32_t)&g488, (int32_t)&g488, (int32_t)&g488);
    }
    // 0x37894
    return result;
}

// Address range: 0x378a2 - 0x378a4
int32_t function_378a2(int32_t a1) {
    // 0x378a2
    return function_3864e(a1);
}

// Address range: 0x378a4 - 0x37ac0
int32_t function_378a4(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x378a4
    int32_t v1; // bp+292, 0x378a4
    int32_t v2 = &v1;
    int32_t v3; // bp+224, 0x378a4
    int32_t v4 = &v3;
    char v5; // bp+276, 0x378a4
    int32_t v6 = &v5;
    int32_t v7 = 0; // 0x378bc
    int32_t v8 = a3; // 0x378bc
    int32_t v9 = v8; // 0x378d8
    int32_t v10 = 0;
    int32_t v11; // 0x378e4
    int32_t v12; // 0x378a4
    if ((function_44ed4(a1) & v12) == 0) {
        v11 = usleep(1000);
        while ((function_44ed4(v11) & v12) == 0) {
            // 0x378dc
            v11 = usleep(1000);
        }
    }
    int32_t v13 = v9 - 20;
    int32_t v14 = v13 + 16; // 0x37908
    int32_t v15 = v4 + 16; // 0x37918
    *(int32_t *)v4 = *(int32_t *)v13;
    *(int32_t *)(v4 + 4) = *(int32_t *)(v13 + 4);
    *(int32_t *)(v4 + 8) = *(int32_t *)(v13 + 8);
    *(int32_t *)(v4 + 12) = *(int32_t *)(v13 + 12);
    int32_t v16 = v15; // 0x37928
    while (v13 != v9 + 12) {
        // 0x37904
        v13 = v14;
        v14 = v13 + 16;
        v15 = v16 + 16;
        *(int32_t *)v16 = *(int32_t *)v13;
        *(int32_t *)(v16 + 4) = *(int32_t *)(v13 + 4);
        *(int32_t *)(v16 + 8) = *(int32_t *)(v13 + 8);
        *(int32_t *)(v16 + 12) = *(int32_t *)(v13 + 12);
        v16 = v15;
    }
    // 0x3792c
    *(int32_t *)v15 = *(int32_t *)v14;
    int32_t v17; // bp+278, 0x378a4
    memset(&v17, 0, 146);
    int32_t v18 = *(int32_t *)(v9 - 12); // 0x37960
    int32_t v19 = *(int32_t *)(v9 - 8); // 0x37974
    char v20; // 0x378a4
    char v21 = v20 + 1; // 0x37984
    v1 = *(int32_t *)(v9 - 4);
    v5 = 1;
    int32_t v22 = 0; // 0x379c4
    int32_t v23 = 52 * a5 + v12; // 0x379c4
    if (v22 == v7 % 4) {
        function_37b50((int32_t)&g488);
    }
    int32_t v24 = 32 * v22 + v6; // 0x379e0
    *(int32_t *)(v24 + 20) = (int32_t)v21;
    int32_t v25; // bp+272, 0x378a4
    *(int32_t *)(v24 + 48) = v25;
    int32_t v26 = v23 + v12; // 0x379f8
    int32_t v27 = v4 + 16; // 0x37a04
    int32_t v28 = v26 + 16; // 0x37a08
    *(int32_t *)v26 = *(int32_t *)v4;
    *(int32_t *)(v26 + 4) = *(int32_t *)(v4 + 4);
    *(int32_t *)(v26 + 8) = *(int32_t *)(v4 + 8);
    *(int32_t *)(v26 + 12) = *(int32_t *)(v4 + 12);
    v26 = v28;
    int32_t v29; // 0x378a4
    while (v27 != (int32_t)&v25) {
        // 0x379fc
        v29 = v27;
        v27 = v29 + 16;
        v28 = v26 + 16;
        *(int32_t *)v26 = *(int32_t *)v29;
        *(int32_t *)(v26 + 4) = *(int32_t *)(v29 + 4);
        *(int32_t *)(v26 + 8) = *(int32_t *)(v29 + 8);
        *(int32_t *)(v26 + 12) = *(int32_t *)(v29 + 12);
        v26 = v28;
    }
    // 0x37a28
    *(int32_t *)v28 = v25;
    v22++;
    v23 += 52;
    while (v22 != 4) {
        // 0x379c8
        if (v22 == v7 % 4) {
            function_37b50((int32_t)&g488);
        }
        // 0x379d8
        v24 = 32 * v22 + v6;
        *(int32_t *)(v24 + 20) = (int32_t)v21;
        *(int32_t *)(v24 + 48) = v25;
        v26 = v23 + v12;
        v27 = v4 + 16;
        v28 = v26 + 16;
        *(int32_t *)v26 = *(int32_t *)v4;
        *(int32_t *)(v26 + 4) = *(int32_t *)(v4 + 4);
        *(int32_t *)(v26 + 8) = *(int32_t *)(v4 + 8);
        *(int32_t *)(v26 + 12) = *(int32_t *)(v4 + 12);
        v26 = v28;
        while (v27 != (int32_t)&v25) {
            // 0x379fc
            v29 = v27;
            v27 = v29 + 16;
            v28 = v26 + 16;
            *(int32_t *)v26 = *(int32_t *)v29;
            *(int32_t *)(v26 + 4) = *(int32_t *)(v29 + 4);
            *(int32_t *)(v26 + 8) = *(int32_t *)(v29 + 8);
            *(int32_t *)(v26 + 12) = *(int32_t *)(v29 + 12);
            v26 = v28;
        }
        // 0x37a28
        *(int32_t *)v28 = v25;
        v22++;
        v23 += 52;
    }
    uint32_t v30 = a5 + 4; // 0x37a58
    int32_t v31; // 0x378a4
    function_11fc4(&v31, v2, -124, a5);
    int32_t v32 = v10 + 128; // 0x37a70
    int32_t result = function_1eeb8((int32_t)v5, a5 % 128 | v10, v18, v19); // 0x37a78
    int32_t v33 = v30 < 128 ? v30 : 0;
    char v34 = v21; // 0x37a90
    int32_t v35 = result; // 0x37a90
    v9 += 52;
    while (v32 != 1024) {
        // 0x378e8
        v10 = v32;
        if ((function_44ed4(v35) & v12) == 0) {
            v11 = usleep(1000);
            while ((function_44ed4(v11) & v12) == 0) {
                // 0x378dc
                v11 = usleep(1000);
            }
        }
        // 0x378f4
        v13 = v9 - 20;
        v14 = v13 + 16;
        v15 = v4 + 16;
        *(int32_t *)v4 = *(int32_t *)v13;
        *(int32_t *)(v4 + 4) = *(int32_t *)(v13 + 4);
        *(int32_t *)(v4 + 8) = *(int32_t *)(v13 + 8);
        *(int32_t *)(v4 + 12) = *(int32_t *)(v13 + 12);
        v16 = v15;
        while (v13 != v9 + 12) {
            // 0x37904
            v13 = v14;
            v14 = v13 + 16;
            v15 = v16 + 16;
            *(int32_t *)v16 = *(int32_t *)v13;
            *(int32_t *)(v16 + 4) = *(int32_t *)(v13 + 4);
            *(int32_t *)(v16 + 8) = *(int32_t *)(v13 + 8);
            *(int32_t *)(v16 + 12) = *(int32_t *)(v13 + 12);
            v16 = v15;
        }
        // 0x3792c
        *(int32_t *)v15 = *(int32_t *)v14;
        memset(&v17, 0, 146);
        v18 = *(int32_t *)(v9 - 12);
        v19 = *(int32_t *)(v9 - 8);
        v21 = v34 + 1;
        v1 = *(int32_t *)(v9 - 4);
        v5 = 1;
        v22 = 0;
        v23 = 52 * v33 + v12;
        if (v22 == v7 % 4) {
            function_37b50((int32_t)&g488);
        }
        // 0x379d8
        v24 = 32 * v22 + v6;
        *(int32_t *)(v24 + 20) = (int32_t)v21;
        *(int32_t *)(v24 + 48) = v25;
        v26 = v23 + v12;
        v27 = v4 + 16;
        v28 = v26 + 16;
        *(int32_t *)v26 = *(int32_t *)v4;
        *(int32_t *)(v26 + 4) = *(int32_t *)(v4 + 4);
        *(int32_t *)(v26 + 8) = *(int32_t *)(v4 + 8);
        *(int32_t *)(v26 + 12) = *(int32_t *)(v4 + 12);
        v26 = v28;
        while (v27 != (int32_t)&v25) {
            // 0x379fc
            v29 = v27;
            v27 = v29 + 16;
            v28 = v26 + 16;
            *(int32_t *)v26 = *(int32_t *)v29;
            *(int32_t *)(v26 + 4) = *(int32_t *)(v29 + 4);
            *(int32_t *)(v26 + 8) = *(int32_t *)(v29 + 8);
            *(int32_t *)(v26 + 12) = *(int32_t *)(v29 + 12);
            v26 = v28;
        }
        // 0x37a28
        *(int32_t *)v28 = v25;
        v22++;
        v23 += 52;
        while (v22 != 4) {
            // 0x379c8
            if (v22 == v7 % 4) {
                function_37b50((int32_t)&g488);
            }
            // 0x379d8
            v24 = 32 * v22 + v6;
            *(int32_t *)(v24 + 20) = (int32_t)v21;
            *(int32_t *)(v24 + 48) = v25;
            v26 = v23 + v12;
            v27 = v4 + 16;
            v28 = v26 + 16;
            *(int32_t *)v26 = *(int32_t *)v4;
            *(int32_t *)(v26 + 4) = *(int32_t *)(v4 + 4);
            *(int32_t *)(v26 + 8) = *(int32_t *)(v4 + 8);
            *(int32_t *)(v26 + 12) = *(int32_t *)(v4 + 12);
            v26 = v28;
            while (v27 != (int32_t)&v25) {
                // 0x379fc
                v29 = v27;
                v27 = v29 + 16;
                v28 = v26 + 16;
                *(int32_t *)v26 = *(int32_t *)v29;
                *(int32_t *)(v26 + 4) = *(int32_t *)(v29 + 4);
                *(int32_t *)(v26 + 8) = *(int32_t *)(v29 + 8);
                *(int32_t *)(v26 + 12) = *(int32_t *)(v29 + 12);
                v26 = v28;
            }
            // 0x37a28
            *(int32_t *)v28 = v25;
            v22++;
            v23 += 52;
        }
        // 0x37a40
        v30 = v33 + 4;
        function_11fc4(&v31, v2, -124, v33);
        v32 = v10 + 128;
        result = function_1eeb8((int32_t)v5, v33 % 128 | v10, v18, v19);
        v33 = v30 < 128 ? v30 : 0;
        v34 = v21;
        v35 = result;
        v9 += 52;
    }
    // 0x37a94
    v7++;
    v8 += 416;
    while (v12 != v7) {
        // 0x378c0
        v9 = v8;
        v10 = 0;
        if ((function_44ed4(result) & v12) == 0) {
            v11 = usleep(1000);
            while ((function_44ed4(v11) & v12) == 0) {
                // 0x378dc
                v11 = usleep(1000);
            }
        }
        // 0x378f4
        v13 = v9 - 20;
        v14 = v13 + 16;
        v15 = v4 + 16;
        *(int32_t *)v4 = *(int32_t *)v13;
        *(int32_t *)(v4 + 4) = *(int32_t *)(v13 + 4);
        *(int32_t *)(v4 + 8) = *(int32_t *)(v13 + 8);
        *(int32_t *)(v4 + 12) = *(int32_t *)(v13 + 12);
        v16 = v15;
        while (v13 != v9 + 12) {
            // 0x37904
            v13 = v14;
            v14 = v13 + 16;
            v15 = v16 + 16;
            *(int32_t *)v16 = *(int32_t *)v13;
            *(int32_t *)(v16 + 4) = *(int32_t *)(v13 + 4);
            *(int32_t *)(v16 + 8) = *(int32_t *)(v13 + 8);
            *(int32_t *)(v16 + 12) = *(int32_t *)(v13 + 12);
            v16 = v15;
        }
        // 0x3792c
        *(int32_t *)v15 = *(int32_t *)v14;
        memset(&v17, 0, 146);
        v18 = *(int32_t *)(v9 - 12);
        v19 = *(int32_t *)(v9 - 8);
        v21++;
        v1 = *(int32_t *)(v9 - 4);
        v5 = 1;
        v22 = 0;
        v23 = 52 * v33 + v12;
        if (v22 == v7 % 4) {
            function_37b50((int32_t)&g488);
        }
        // 0x379d8
        v24 = 32 * v22 + v6;
        *(int32_t *)(v24 + 20) = (int32_t)v21;
        *(int32_t *)(v24 + 48) = v25;
        v26 = v23 + v12;
        v27 = v4 + 16;
        v28 = v26 + 16;
        *(int32_t *)v26 = *(int32_t *)v4;
        *(int32_t *)(v26 + 4) = *(int32_t *)(v4 + 4);
        *(int32_t *)(v26 + 8) = *(int32_t *)(v4 + 8);
        *(int32_t *)(v26 + 12) = *(int32_t *)(v4 + 12);
        v26 = v28;
        while (v27 != (int32_t)&v25) {
            // 0x379fc
            v29 = v27;
            v27 = v29 + 16;
            v28 = v26 + 16;
            *(int32_t *)v26 = *(int32_t *)v29;
            *(int32_t *)(v26 + 4) = *(int32_t *)(v29 + 4);
            *(int32_t *)(v26 + 8) = *(int32_t *)(v29 + 8);
            *(int32_t *)(v26 + 12) = *(int32_t *)(v29 + 12);
            v26 = v28;
        }
        // 0x37a28
        *(int32_t *)v28 = v25;
        v22++;
        v23 += 52;
        while (v22 != 4) {
            // 0x379c8
            if (v22 == v7 % 4) {
                function_37b50((int32_t)&g488);
            }
            // 0x379d8
            v24 = 32 * v22 + v6;
            *(int32_t *)(v24 + 20) = (int32_t)v21;
            *(int32_t *)(v24 + 48) = v25;
            v26 = v23 + v12;
            v27 = v4 + 16;
            v28 = v26 + 16;
            *(int32_t *)v26 = *(int32_t *)v4;
            *(int32_t *)(v26 + 4) = *(int32_t *)(v4 + 4);
            *(int32_t *)(v26 + 8) = *(int32_t *)(v4 + 8);
            *(int32_t *)(v26 + 12) = *(int32_t *)(v4 + 12);
            v26 = v28;
            while (v27 != (int32_t)&v25) {
                // 0x379fc
                v29 = v27;
                v27 = v29 + 16;
                v28 = v26 + 16;
                *(int32_t *)v26 = *(int32_t *)v29;
                *(int32_t *)(v26 + 4) = *(int32_t *)(v29 + 4);
                *(int32_t *)(v26 + 8) = *(int32_t *)(v29 + 8);
                *(int32_t *)(v26 + 12) = *(int32_t *)(v29 + 12);
                v26 = v28;
            }
            // 0x37a28
            *(int32_t *)v28 = v25;
            v22++;
            v23 += 52;
        }
        // 0x37a40
        v30 = v33 + 4;
        function_11fc4(&v31, v2, -124, v33);
        v32 = v10 + 128;
        result = function_1eeb8((int32_t)v5, v33 % 128 | v10, v18, v19);
        v33 = v30 < 128 ? v30 : 0;
        v34 = v21;
        v35 = result;
        v9 += 52;
        while (v32 != 1024) {
            // 0x378e8
            v10 = v32;
            if ((function_44ed4(v35) & v12) == 0) {
                v11 = usleep(1000);
                while ((function_44ed4(v11) & v12) == 0) {
                    // 0x378dc
                    v11 = usleep(1000);
                }
            }
            // 0x378f4
            v13 = v9 - 20;
            v14 = v13 + 16;
            v15 = v4 + 16;
            *(int32_t *)v4 = *(int32_t *)v13;
            *(int32_t *)(v4 + 4) = *(int32_t *)(v13 + 4);
            *(int32_t *)(v4 + 8) = *(int32_t *)(v13 + 8);
            *(int32_t *)(v4 + 12) = *(int32_t *)(v13 + 12);
            v16 = v15;
            while (v13 != v9 + 12) {
                // 0x37904
                v13 = v14;
                v14 = v13 + 16;
                v15 = v16 + 16;
                *(int32_t *)v16 = *(int32_t *)v13;
                *(int32_t *)(v16 + 4) = *(int32_t *)(v13 + 4);
                *(int32_t *)(v16 + 8) = *(int32_t *)(v13 + 8);
                *(int32_t *)(v16 + 12) = *(int32_t *)(v13 + 12);
                v16 = v15;
            }
            // 0x3792c
            *(int32_t *)v15 = *(int32_t *)v14;
            memset(&v17, 0, 146);
            v18 = *(int32_t *)(v9 - 12);
            v19 = *(int32_t *)(v9 - 8);
            v21 = v34 + 1;
            v1 = *(int32_t *)(v9 - 4);
            v5 = 1;
            v22 = 0;
            v23 = 52 * v33 + v12;
            if (v22 == v7 % 4) {
                function_37b50((int32_t)&g488);
            }
            // 0x379d8
            v24 = 32 * v22 + v6;
            *(int32_t *)(v24 + 20) = (int32_t)v21;
            *(int32_t *)(v24 + 48) = v25;
            v26 = v23 + v12;
            v27 = v4 + 16;
            v28 = v26 + 16;
            *(int32_t *)v26 = *(int32_t *)v4;
            *(int32_t *)(v26 + 4) = *(int32_t *)(v4 + 4);
            *(int32_t *)(v26 + 8) = *(int32_t *)(v4 + 8);
            *(int32_t *)(v26 + 12) = *(int32_t *)(v4 + 12);
            v26 = v28;
            while (v27 != (int32_t)&v25) {
                // 0x379fc
                v29 = v27;
                v27 = v29 + 16;
                v28 = v26 + 16;
                *(int32_t *)v26 = *(int32_t *)v29;
                *(int32_t *)(v26 + 4) = *(int32_t *)(v29 + 4);
                *(int32_t *)(v26 + 8) = *(int32_t *)(v29 + 8);
                *(int32_t *)(v26 + 12) = *(int32_t *)(v29 + 12);
                v26 = v28;
            }
            // 0x37a28
            *(int32_t *)v28 = v25;
            v22++;
            v23 += 52;
            while (v22 != 4) {
                // 0x379c8
                if (v22 == v7 % 4) {
                    function_37b50((int32_t)&g488);
                }
                // 0x379d8
                v24 = 32 * v22 + v6;
                *(int32_t *)(v24 + 20) = (int32_t)v21;
                *(int32_t *)(v24 + 48) = v25;
                v26 = v23 + v12;
                v27 = v4 + 16;
                v28 = v26 + 16;
                *(int32_t *)v26 = *(int32_t *)v4;
                *(int32_t *)(v26 + 4) = *(int32_t *)(v4 + 4);
                *(int32_t *)(v26 + 8) = *(int32_t *)(v4 + 8);
                *(int32_t *)(v26 + 12) = *(int32_t *)(v4 + 12);
                v26 = v28;
                while (v27 != (int32_t)&v25) {
                    // 0x379fc
                    v29 = v27;
                    v27 = v29 + 16;
                    v28 = v26 + 16;
                    *(int32_t *)v26 = *(int32_t *)v29;
                    *(int32_t *)(v26 + 4) = *(int32_t *)(v29 + 4);
                    *(int32_t *)(v26 + 8) = *(int32_t *)(v29 + 8);
                    *(int32_t *)(v26 + 12) = *(int32_t *)(v29 + 12);
                    v26 = v28;
                }
                // 0x37a28
                *(int32_t *)v28 = v25;
                v22++;
                v23 += 52;
            }
            // 0x37a40
            v30 = v33 + 4;
            function_11fc4(&v31, v2, -124, v33);
            v32 = v10 + 128;
            result = function_1eeb8((int32_t)v5, v33 % 128 | v10, v18, v19);
            v33 = v30 < 128 ? v30 : 0;
            v34 = v21;
            v35 = result;
            v9 += 52;
        }
        // 0x37a94
        v7++;
        v8 += 416;
    }
    // 0x37ab8
    return result;
}

// Address range: 0x37ac0 - 0x37b50
int32_t function_37ac0(int32_t a1, int32_t a2, int32_t a3) {
    // 0x37ac0
    int32_t v1; // bp+216, 0x37ac0
    function_302a0(&v1);
    int32_t v2; // 0x37ac0
    uint32_t v3 = *(int32_t *)v2; // 0x37b00
    if (v3 != 3 && v3 >= 3) {
        // 0x37b10
        int32_t str; // bp+424, 0x37ac0
        snprintf((char *)&str, 2048, "Send work for chain %d done, time cost %lds, sleep_count = %d\n", a2, (int32_t)false - v2 + v1, v2);
        function_2e584(3, &str, 0);
    }
    // 0x37b40
    return 0;
}

// Address range: 0x37b50 - 0x37bdc
int32_t function_37b50(int32_t a1) {
    // 0x37b50
    int32_t v1; // 0x37b50
    int32_t v2 = 32 * v1 + v1; // 0x37b54
    *(int32_t *)(v2 + 4) = *(int32_t *)(v1 + 4);
    *(int32_t *)(v2 + 12) = *(int32_t *)(v1 + 12);
    *(int32_t *)(v2 + 8) = *(int32_t *)(v1 + 8);
    *(int32_t *)(v2 + 16) = *(int32_t *)(v1 + 16);
    *(int32_t *)(v2 + 20) = *(int32_t *)(v1 + 20);
    *(int32_t *)(v2 + 24) = *(int32_t *)(v1 + 24);
    *(int32_t *)(v2 + 28) = *(int32_t *)(v1 + 28);
    int32_t v3 = a1 + 16; // 0x37b9c
    int32_t v4; // 0x37b50
    int32_t v5 = v4 + 16; // 0x37ba4
    int32_t result = *(int32_t *)(a1 + 4); // 0x37ba8
    *(int32_t *)v4 = *(int32_t *)a1;
    *(int32_t *)(v4 + 4) = result;
    *(int32_t *)(v4 + 8) = *(int32_t *)(a1 + 8);
    *(int32_t *)(v4 + 12) = *(int32_t *)(a1 + 12);
    v4 = v5;
    while (v3 != v1) {
        int32_t v6 = v3;
        v3 = v6 + 16;
        v5 = v4 + 16;
        result = *(int32_t *)(v6 + 4);
        *(int32_t *)v4 = *(int32_t *)v6;
        *(int32_t *)(v4 + 4) = result;
        *(int32_t *)(v4 + 8) = *(int32_t *)(v6 + 8);
        *(int32_t *)(v4 + 12) = *(int32_t *)(v6 + 12);
        v4 = v5;
    }
    // 0x37bcc
    *(int32_t *)v5 = *(int32_t *)v1;
    return result;
}

// Address range: 0x37bdc - 0x37be4
int32_t function_37bdc(void) {
    // 0x37bdc
    int32_t result; // 0x37bdc
    return result;
}

// Address range: 0x37be6 - 0x37be8
int32_t function_37be6(int32_t a1) {
    // 0x37be6
    return function_3864e(a1);
}

// Address range: 0x37be8 - 0x37c40
int32_t function_37be8(int32_t a1) {
    // 0x37be8
    int32_t str; // 0x37be8
    int32_t * v1 = (int32_t *)str; // 0x37bf4
    function_2ea54(3, v1, 0);
    snprintf((char *)str, 2048, ">>>> Send work for chain %d.\n", a1);
    function_2e584(3, v1, 0);
    return function_1e0f0();
}

// Address range: 0x37c40 - 0x37c48
int32_t function_37c40(int32_t a1) {
    // 0x37c40
    int32_t result; // 0x37c40
    return result;
}

// Address range: 0x37c48 - 0x37c4c
int32_t function_37c48(void) {
    // 0x37c48
    int32_t v1; // 0x37c48
    return function_390b0(v1);
}

// Address range: 0x37c4c - 0x37f08
int32_t function_37c4c(int32_t a1) {
    int32_t v1 = *(int32_t *)(a1 + 4); // 0x37c54
    function_1e160();
    uint32_t v2 = function_51978(v1); // 0x37c64
    int32_t v3; // 0x37c4c
    unsigned char v4 = (char)v3 % 16;
    int32_t v5 = __asm_ubfx((int32_t)*(int16_t *)(a1 + 2), 0, 15); // 0x37c7c
    int32_t v6 = function_51970(v1); // 0x37c80
    int32_t result = function_1e140(); // 0x37c88
    if (v4 != 3 && v4 >= 3) {
        // 0x37c94
        g374++;
        return result;
    }
    int32_t v7 = v4; // 0x37c78
    int32_t result2 = function_1e29c(v7); // 0x37cc0
    if (result2 == 0) {
        // 0x37c94
        g374++;
        return 0;
    }
    if ((result2 & 32) != 0) {
        int32_t * v8 = (int32_t *)((int32_t)(4 * v4) + (int32_t)&g358 + 0xa828 + g95); // 0x37d28
        *v8 = *v8 + 1;
        return result2;
    }
    if ((result2 & 64) != 0) {
        int32_t * v9 = (int32_t *)((int32_t)(4 * v4) + (int32_t)&g358 + 0xa838 + g95); // 0x37d84
        *v9 = *v9 + 1;
        return result2;
    }
    if ((result2 & 128) == 0) {
        int32_t * v10 = (int32_t *)((int32_t)(4 * v4) + (int32_t)&g358 + 0xa848 + g95); // 0x37d00
        *v10 = *v10 + 1;
        return result2;
    }
    uint32_t result3 = function_1e0f0(); // 0x37d38
    if (result3 >= v2 != result3 != v2) {
        int32_t * v11 = (int32_t *)((int32_t)(4 * v4) + (int32_t)&g358 + 0xa88c + g95); // 0x37d5c
        *v11 = *v11 + 1;
        return result3;
    }
    uint32_t v12 = v5 % 4; // 0x37d94
    uint32_t v13 = result * v6 + v12; // 0x37d9c
    uint32_t result4 = function_1e130(); // 0x37da0
    if ((v5 < 1024 || v12 == 0) != (v5 <= 1023 && result4 != v13 && result4 >= v13)) {
        int32_t * v14 = (int32_t *)((int32_t)(4 * v4) + (int32_t)&g358 + 0xa868 + g95); // 0x37dd8
        *v14 = *v14 + 1;
        return result4;
    }
    uint32_t v15 = v5 >> 7; // 0x37d98
    int32_t v16 = *(int32_t *)(4 * (v2 + (int32_t)&g12) + 4 + g95); // 0x37e14
    if (*(int32_t *)(52 * v15 + 4 + 416 * v13 + v16) != v1) {
        int32_t v17 = __asm_smlabb(52, v5 % 128, 0x1a00 * v7 + (int32_t)&g381); // 0x37e40
        int32_t result5 = function_386bc(v17 + g95, v1); // 0x37e48
        int32_t v18 = g95 + (int32_t)(4 * v4); // 0x37e54
        if (result5 == 0) {
            int32_t * v19 = (int32_t *)(v18 + (int32_t)&g358 + 0xa868);
            *v19 = *v19 + 1;
        } else {
            int32_t * v20 = (int32_t *)(v18 + (int32_t)&g358 + 0xa858);
            *v20 = *v20 + 1;
        }
        return result5;
    }
    int32_t v21 = v2 + 256 * v7; // 0x37e7c
    int32_t v22 = 1 << v15; // 0x37e84
    int32_t v23 = g95 + 4 * (v13 + 1024 * v21); // 0x37e8c
    int32_t * v24 = (int32_t *)(v23 + 8); // 0x37e90
    int32_t v25 = *v24; // 0x37e90
    if ((v25 & v22) != 0) {
        int32_t * v26 = (int32_t *)((int32_t)(4 * v4) + (int32_t)&g358 + 0xa818 + g95); // 0x37ea8
        *v26 = *v26 + 1;
        return 52;
    }
    // 0x37eb8
    *v24 = v25 | v22;
    int32_t * v27 = (int32_t *)(v23 + (int32_t)&g47 + 0x9008); // 0x37ecc
    *v27 = *v27 + 1;
    int32_t * v28 = (int32_t *)(4 * v21 + (int32_t)&g358 + 0x9008 + g95); // 0x37ee8
    *v28 = *v28 + 1;
    int32_t * v29 = (int32_t *)((int32_t)(4 * v4) + (int32_t)&g358 + 0xa008 + g95); // 0x37ef8
    *v29 = *v29 + 1;
    return v23 + (int32_t)&g47 + 0x9000;
}

// Address range: 0x37f08 - 0x37f70
int32_t function_37f08(void) {
    int32_t v1 = function_1e0f0(); // 0x37f10
    if (v1 == 0) {
        function_37f7c();
    }
    int32_t v2 = 0; // 0x37f30
    int32_t v3 = 4 * (v2 + (int32_t)&g12) + 4;
    int32_t v4 = *(int32_t *)(v3 + g95); // 0x37f44
    int32_t v5; // 0x37f08
    if (v4 != 0) {
        // 0x37f50
        free(v4, v5, g95, v4);
        *(int32_t *)(g95 + v3) = 0;
    }
    // 0x37f60
    v2++;
    int32_t v6 = g95;
    while (v1 != v2) {
        int32_t v7 = v6;
        v3 = 4 * (v2 + (int32_t)&g12) + 4;
        v4 = *(int32_t *)(v3 + v7);
        int32_t v8 = v7; // 0x37f4c
        if (v4 != 0) {
            // 0x37f50
            free(v4, v5, v7, v4);
            v8 = g95;
            *(int32_t *)(v8 + v3) = 0;
        }
        // 0x37f60
        v2++;
        v6 = v8;
    }
    // 0x37f68
    return free(v6, v5, v6, v4);
}

// Address range: 0x37f72 - 0x37f74
int32_t function_37f72(int32_t a1) {
    // 0x37f72
    return function_3864e(a1);
}

// Address range: 0x37f74 - 0x37f7c
int32_t function_37f74(int32_t result, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11) {
    // 0x37f74
    int32_t v1; // 0x37f74
    *(int32_t *)v1 = a4;
    return result;
}

// Address range: 0x37f7c - 0x37f88
int32_t function_37f7c(void) {
    // 0x37f7c
    int32_t result; // 0x37f7c
    return result;
}

// Address range: 0x37f88 - 0x37fa0
int32_t function_37f88(void) {
    // 0x37f88
    if (g95 == 0) {
        int32_t result; // 0x37f88
        return result;
    }
    // 0x37f9c
    return function_37f08();
}

// Address range: 0x37fa0 - 0x38110
int32_t function_37fa0(int32_t * a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x37fa0
    if (a4 == 0) {
        // 0x3809c
        return 0;
    }
    int32_t result = a4 >> 31;
    int32_t v1 = 52 * a3 * a4; // 0x37fe8
    int32_t result2 = 0;
    int32_t v2 = *(int32_t *)(4 * (a2 + (int32_t)&g12) + 4 + g95); // 0x38064
    int32_t data; // bp-2136, 0x37fa0
    while (fread(&data, 1, 48, (struct _IO_FILE *)&data) == 48) {
        int32_t v3 = result2 + 1; // 0x38058
        int32_t v4 = v2 + v1; // 0x38074
        *(int32_t *)(v4 + 4) = a4;
        *(int32_t *)v4 = result2;
        v1 += 52;
        if (v3 == result) {
            // 0x3809c
            return result;
        }
        result2 = v3;
        v2 = *(int32_t *)(4 * (a2 + (int32_t)&g12) + 4 + g95);
    }
    char * v5 = g289; // 0x38090
    if (v5 >= (char *)3 != v5 != (char *)3) {
        // 0x3809c
        return result2;
    }
    char * v6 = (char *)0x64616f4c; // bp-2088, 0x380d0
    function_2e584(3, (int32_t *)&v6, 0);
    return result2;
}

// Address range: 0x38110 - 0x38450
int32_t function_38110(int32_t a1) {
    char * v1 = g289; // 0x38128
    int32_t v2 = (int32_t)v1; // 0x38130
    int32_t v3; // 0x38110
    char * str; // bp-2088, 0x38110
    if (v1 >= (char *)4 == (v1 != (char *)4)) {
        // 0x381e8
        str = (char *)0x4245445b;
        function_2e584(4, (int32_t *)&str, 0);
        v3 = 0;
        v2 = 0;
    }
    // 0x38134
    if (g95 == 0) {
        int32_t v4 = function_11eb0((int32_t)&g423, 1, v3, v2); // 0x382b4
        g95 = v4;
        if (v4 == 0) {
            char * v5 = g289; // 0x38408
            if (v5 == (char *)3 || v5 < (char *)3) {
                // 0x38330
                function_356c4(13, 255);
                // 0x38298
                return -1;
            }
            // 0x38414
            str = (char *)0x6c696146;
            function_2e584(3, (int32_t *)&str, 0);
            goto lab_0x383c0;
        } else {
            int32_t v6 = function_1e0f0(); // 0x382c8
            int32_t v7 = 0; // 0x382d4
            if (v6 == 0) {
                goto lab_0x38148;
            } else {
                int32_t * mem = malloc(416 * function_1e130()); // 0x38300
                int32_t v8 = (int32_t)mem; // 0x38300
                *(int32_t *)(4 * (v7 + (int32_t)&g12) + 4 + g95) = v8;
                while (mem != NULL) {
                    int32_t v9 = v7 + 1; // 0x38314
                    v7 = v9;
                    if (v6 == v9) {
                        goto lab_0x38148;
                    }
                    mem = malloc(416 * function_1e130());
                    v8 = (int32_t)mem;
                    *(int32_t *)(4 * (v7 + (int32_t)&g12) + 4 + g95) = v8;
                }
                char * v10 = g289; // 0x38320
                if (v10 >= (char *)3 != v10 != (char *)3) {
                    // 0x3832c
                    function_37f08();
                    // 0x38330
                    function_356c4(13, 255);
                    // 0x38298
                    return -1;
                }
                // 0x38388
                str = (char *)0x6c696146;
                function_2e584(3, (int32_t *)&str, v8);
                goto lab_0x383c0;
            }
        }
    } else {
        goto lab_0x38148;
    }
  lab_0x38148:
    // 0x38148
    *(int32_t *)g95 = a1;
    char * v11 = (char *)*(int32_t *)g95; // 0x38160
    struct _IO_FILE * file2 = fopen64(v11, "r"); // 0x38160
    struct _IO_FILE * file = file2; // bp-2092, 0x3816c
    if (file2 == NULL) {
        char * v12 = g289; // 0x38228
        if (v12 >= (char *)3 == (v12 != (char *)3)) {
            // 0x3835c
            snprintf((char *)&str, 2048, "Fail to open pattern file %s.\n", v11);
            function_2e584(3, (int32_t *)&str, (int32_t)file2);
        }
        goto lab_0x38234;
    } else {
        // 0x38174
        if (function_1e0f0() == 0) {
            goto lab_0x381d8_2;
        } else {
            int32_t v13; // 0x38110
            int32_t v14 = v13;
            int32_t v15; // 0x38110
            int32_t v16; // 0x38110
            int32_t v17; // 0x38184
            int32_t v18; // 0x381a8
            int32_t v19; // 0x381b8
            if (function_1e130() != 0) {
                int32_t v20; // 0x38110
                int32_t v21 = v20;
                int32_t v22; // 0x38110
                v15 = v22;
                v18 = v15 + 1;
                int32_t v23 = function_37fa0((int32_t *)&file, v14, v15, 8); // 0x381b0
                v19 = v23 + v21;
                v22 = v18;
                v20 = v19;
                v16 = v19;
                while (v17 != v18) {
                    // 0x3819c
                    v21 = v20;
                    v15 = v22;
                    v18 = v15 + 1;
                    v23 = function_37fa0((int32_t *)&file, v14, v15, 8);
                    v19 = v23 + v21;
                    v22 = v18;
                    v20 = v19;
                    v16 = v19;
                }
            }
            uint32_t v24 = 0;
            // 0x38184
            while (v24 >= 8 * function_1e130()) {
                int32_t v25 = v14 + 1; // 0x381cc
                int32_t v26; // 0x38174
                if (v26 == v25) {
                    // 0x381d8
                    goto lab_0x381d8_2;
                }
                v14 = v25;
                v17 = function_1e130();
                v16 = 0;
                if (v17 != 0) {
                    v15 = 0;
                    v18 = v15 + 1;
                    v19 = function_37fa0((int32_t *)&file, v14, v15, 8);
                    v16 = v19;
                    while (v17 != v18) {
                        // 0x3819c
                        v15 = v18;
                        v18 = v15 + 1;
                        v19 += function_37fa0((int32_t *)&file, v14, v15, 8);
                        v16 = v19;
                    }
                }
                // 0x381c0
                v24 = v16;
            }
            char * v27 = g289; // 0x38344
            if (v27 >= (char *)3 == (v27 != (char *)3)) {
                int32_t v28 = function_1e130(); // 0x383cc
                snprintf((char *)&str, 2048, "No enough work, asic = %d, work_count = %d, work_count_target = %d.\n", v14, v24, 8 * v28);
                function_2e584(3, (int32_t *)&str, 0);
            }
            // 0x38350
            fclose(file);
            goto lab_0x38234;
        }
    }
  lab_0x383c0:
    // 0x383c0
    if (g95 == 0) {
        // 0x38330
        function_356c4(13, 255);
        // 0x38298
        return -1;
    }
    // 0x3832c
    function_37f08();
    // 0x38330
    function_356c4(13, 255);
    // 0x38298
    return -1;
  lab_0x38234:
    // 0x38234
    function_356c4(22, 255);
    char * v29 = g289; // 0x38240
    int32_t result = -1; // 0x3824c
    if (v29 != (char *)3 && v29 >= (char *)3) {
        // 0x38250
        str = (char *)0x64616f4c;
        function_2e584(3, (int32_t *)&str, 0);
        result = -1;
    }
    goto lab_0x3828c;
  lab_0x381d8_2:
    // 0x381d8
    fclose(file2);
    result = 0;
    goto lab_0x3828c;
  lab_0x3828c:
    // 0x3828c
    function_44970();
    function_44880(4);
    // 0x38298
    return result;
}

// Address range: 0x38450 - 0x384c0
int32_t function_38450(void) {
    char * v1 = g289; // 0x38458
    if (v1 >= (char *)4 != v1 != (char *)4) {
        // 0x38464
        return (int32_t)&g306;
    }
    char * v2 = (char *)0x4245445b; // bp-2056, 0x3848c
    function_2e584(4, (int32_t *)&v2, 0);
    return (int32_t)&g306;
}

// Address range: 0x384c0 - 0x38520
int32_t function_384c0(int32_t a1) {
    char * v1 = g289; // 0x384c8
    if (v1 != NULL != v1 != (char *)1) {
        // 0x384d4
        return 255;
    }
    // 0x384dc
    int32_t str; // bp-2056, 0x384c0
    snprintf((char *)&str, 2048, "input value error: %c\n", (char)a1);
    function_2e584(1, &str, 0);
    return 255;
}

// Address range: 0x38520 - 0x3859c
int32_t function_38520(char a1) {
    uint32_t v1 = (int32_t)a1;
    uint32_t v2 = v1 - 48; // 0x38520
    if (v2 == 9 || v2 < 9) {
        // 0x38564
        return v1 % 16;
    }
    int32_t result = 10; // 0x38520
    switch (a1 & -33) {
        case 66: {
            // 0x3856c
            result = 11;
        }
        case 65: {
            // 0x3856c
            return result;
        }
        case 67: {
            // 0x3856c
            result = 12;
            return result;
        }
        case 68: {
            // 0x3856c
            result = 13;
            return result;
        }
        case 69: {
            // 0x3856c
            result = 14;
            return result;
        }
        case 70: {
            // 0x3856c
            result = 15;
            return result;
        }
        default: {
            // 0x38560
            return function_384c0(v1);
        }
    }
}

// Address range: 0x3859c - 0x3864c
int32_t function_3859c(int32_t a1, int32_t a2, uint32_t a3) {
    int32_t result; // 0x3859c
    if (a1 >= 1 && a2 != 0) {
        // 0x38638
        result = a1;
        if (a3 < 2) {
            result = function_3867c((int32_t)&g488);
        }
    } else {
        char * v1 = g289; // 0x385dc
        result = v1 == (char *)4 | v1 < (char *)4 ? -1 : a1;
        if (v1 >= (char *)4 == (v1 != (char *)4)) {
            // 0x385f8
            int32_t str; // bp-2088, 0x3859c
            snprintf((char *)&str, 2048, "s2hex para error dst(%p), src(%p), inlen(%d)\n", (int32_t *)a1, (int32_t *)a2, a3);
            function_2e584(4, &str, 0);
            return -1;
        }
    }
    // 0x385ec
    return result;
}

// Address range: 0x3864e - 0x38650
int32_t function_3864e(int32_t a1) {
    // 0x3864e
    int32_t result; // 0x3864e
    return result;
}

// Address range: 0x38650 - 0x3867c
int32_t function_38650(int32_t a1) {
    // 0x38650
    int32_t v1; // 0x38650
    int32_t v2 = function_38520((char)v1); // 0x3865c
    int32_t result = function_38520(*(char *)(v1 + 1)) ^ 16 * v2; // 0x38670
    *(char *)a1 = (char)result;
    return result;
}

// Address range: 0x3867c - 0x386b4
int32_t function_3867c(int32_t a1) {
    // 0x3867c
    int32_t result; // 0x3867c
    if (a1 == 0) {
        // 0x38688
        return result;
    }
    int32_t v1 = function_38520(*(char *)(2 * result + result)); // 0x386a0
    return function_384c0(0) ^ 16 * v1;
}

// Address range: 0x386b6 - 0x386b8
int32_t function_386b6(int32_t a1) {
    // 0x386b6
    return function_3864e(a1);
}

// Address range: 0x386b8 - 0x386bc
int32_t function_386b8(void) {
    // 0x386b8
    int32_t result; // 0x386b8
    return result;
}

// Address range: 0x386bc - 0x387f8
int32_t function_386bc(int32_t a1, int32_t a2) {
    // 0x386bc
    int32_t v1; // bp-312, 0x386bc
    memset(&v1, 0, 32);
    int32_t v2; // bp-280, 0x386bc
    memset(&v2, 0, 32);
    if (a1 == 0) {
        // 0x387f0
        return 0;
    }
    int32_t v3 = llvm_bswap_i32(a2); // 0x38708
    int32_t v4 = *(int32_t *)(a1 + 20); // bp-240, 0x38718
    function_31268(&v4, 32);
    int32_t v5 = 80; // bp-248, 0x38744
    v1 = *(int32_t *)(a1 + 8);
    function_31268(&v1, 12);
    int32_t v6; // bp-208, 0x386bc
    function_316b0(&v6, &v1, 12);
    v1 = v3;
    function_31268(&v1, 4);
    int32_t v7; // bp-196, 0x386bc
    function_316b0(&v7, &v1, 4);
    function_2327c(&v5, &v1);
    memset(&v5, 0, 232);
    function_23430(&v1, 32, &v2);
    int32_t v8; // bp-316, 0x386bc
    int32_t v9 = &v8; // 0x387cc
    int32_t v10; // bp-284, 0x386bc
    int32_t v11 = &v10; // 0x387cc
    v11 += 4;
    int32_t v12 = llvm_bswap_i32(*(int32_t *)v11); // 0x387d8
    v9 += 4;
    *(int32_t *)v9 = v12;
    int32_t v13; // bp-252, 0x386bc
    while (v11 != (int32_t)&v13) {
        // 0x387d0
        v11 += 4;
        v12 = llvm_bswap_i32(*(int32_t *)v11);
        v9 += 4;
        *(int32_t *)v9 = v12;
    }
    // 0x387f0
    return v10 != 0;
}

// Address range: 0x387f8 - 0x3883c
int32_t function_387f8(void) {
    int32_t v1 = 0x646e6148; // bp-2056, 0x38818
    return function_2e584(3, &v1, 0);
}

// Address range: 0x3883c - 0x388f4
int32_t function_3883c(int32_t a1) {
    char * v1 = g289; // 0x38854
    if (v1 >= (char *)4 == (v1 != (char *)4)) {
        // 0x388c8
        int32_t str; // bp-2064, 0x3883c
        snprintf((char *)&str, 2048, "[DEBUG] Send work one chain, chain = %d.\n", (int32_t)&str);
        function_2e584(4, &str, 0);
    }
    // 0x38860
    if (g96 != 0) {
        // 0x38874
        if (*(int32_t *)(g96 + 4) != 0) {
            // 0x38880
            *(int32_t *)(a1 + 4) = 1;
            // 0x38898
            return 0;
        }
    }
    char * v2 = g289; // 0x388a8
    if (v2 == (char *)3 || v2 < (char *)3) {
        // 0x38898
        return 0;
    }
    // 0x388b4
    function_387f8();
    return 0;
}

// Address range: 0x388f4 - 0x3893c
int32_t function_388f4(int32_t a1) {
    int32_t v1 = 0x646e6148; // bp-2056, 0x38914
    function_2e584(3, &v1, 0);
    return 1;
}

// Address range: 0x3893c - 0x389f0
int32_t function_3893c(int32_t a1) {
    char * v1 = g289; // 0x38954
    int32_t result = a1; // 0x3895c
    if (v1 >= (char *)4 == (v1 != (char *)4)) {
        char * v2 = (char *)0x4245445b; // bp-2064, 0x389c8
        result = function_2e584(4, (int32_t *)&v2, 0);
    }
    // 0x38960
    if (g96 != 0) {
        // 0x38974
        if (*(int32_t *)(g96 + 4) != 0) {
            // 0x38990
            return 255;
        }
    }
    char * v3 = g289; // 0x3899c
    if (v3 != (char *)3 && v3 >= (char *)3) {
        // 0x389a8
        return function_387f8();
    }
    // 0x38990
    return result;
}

// Address range: 0x389f0 - 0x38b6c
int32_t function_389f0(int32_t a1) {
    // 0x389f0
    int32_t v1; // 0x389f0
    int32_t v2; // 0x389f0
    int32_t v3; // bp-2080, 0x389f0
    int32_t v4; // 0x38ac0
    if (g96 != 0) {
        // 0x38a10
        if (*(int32_t *)(g96 + 4) != 0) {
            // 0x38a1c
            int32_t v5; // bp-2096, 0x389f0
            int32_t v6 = &v5; // 0x38a00
            v5 = 0;
            memset(&v3, 0, 48);
            int32_t v7 = &v3;
            int32_t v8 = 0;
            int32_t * thread_func_arg; // 0x38a8c
            int32_t * thread; // 0x38a94
            int32_t v9; // 0x38a64
            if (function_1e29c(v8) != 0) {
                // 0x38a6c
                v9 = 4 * v8;
                if (*(int32_t *)(v9 + 8 + g96) == 1) {
                    // 0x38a7c
                    thread_func_arg = (int32_t *)v7;
                    *thread_func_arg = v8;
                    *(int32_t *)(v7 + 4) = 0;
                    *(int32_t *)(v7 + 8) = a1;
                    thread = (int32_t *)(v9 + v6);
                    pthread_create(thread, NULL, (int32_t * (*)(int32_t *))0x3883c, thread_func_arg);
                    function_11fa0(*thread);
                }
            }
            int32_t v10 = v8 + 1; // 0x38aa0
            int32_t v11 = v7 + 12; // 0x38aac
            while (v10 != 4) {
                // 0x38a58
                v7 = v11;
                v8 = v10;
                if (function_1e29c(v8) != 0) {
                    // 0x38a6c
                    v9 = 4 * v8;
                    if (*(int32_t *)(v9 + 8 + g96) == 1) {
                        // 0x38a7c
                        thread_func_arg = (int32_t *)v7;
                        *thread_func_arg = v8;
                        *(int32_t *)(v7 + 4) = 0;
                        *(int32_t *)(v7 + 8) = a1;
                        thread = (int32_t *)(v9 + v6);
                        pthread_create(thread, NULL, (int32_t * (*)(int32_t *))0x3883c, thread_func_arg);
                        function_11fa0(*thread);
                    }
                }
                // 0x38aa0
                v10 = v8 + 1;
                v11 = v7 + 12;
            }
            // 0x38abc
            int32_t v12; // bp-32, 0x389f0
            int32_t v13 = &v12;
            v1 = 0;
            while (true) {
              lab_0x38abc_2:
                // 0x38abc
                v2 = v1;
                v4 = function_1e29c(v2);
                if (v4 == 0) {
                    goto lab_0x38af8;
                } else {
                    // 0x38ad4
                    if (*(int32_t *)(v13 - 2064 + 4 * v2) == 0) {
                        goto lab_0x38af8;
                    } else {
                        // 0x38aec
                        if (*(int32_t *)(v13 - 2044 + 12 * v2) == 0) {
                            // 0x38b5c
                            usleep(0x186a0);
                            // 0x38abc
                            v1 = 0;
                            goto lab_0x38abc_2;
                        } else {
                            goto lab_0x38af8;
                        }
                    }
                }
            }
        }
    }
    char * v14 = g289; // 0x38b18
    int32_t result = a1; // 0x38b20
    if (v14 != (char *)3 && v14 >= (char *)3) {
        // 0x38b24
        v3 = 0x646e6148;
        return function_2e584(3, &v3, 0);
    }
    // 0x38b04
    return result;
  lab_0x38af8:;
    int32_t v15 = v2 + 1; // 0x38af8
    result = v4;
    if (v15 == 4) {
        return result;
    }
    // 0x38abc
    v1 = v15;
    goto lab_0x38abc_2;
}

// Address range: 0x38b6c - 0x38c64
int32_t function_38b6c(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    // 0x38b6c
    float64_t v1; // 0x38b6c
    float64_t v2 = __asm_vpush(v1); // 0x38b74
    function_1e0f0();
    function_1e0f0();
    function_5faf8();
    int32_t v3 = function_1e0f0(); // 0x38bd8
    int32_t result = function_1e0f0();
    if (v3 < 1) {
        // 0x38c54
        __asm_vpop(v2);
        __asm_vldr_8(0);
        return result;
    }
    int32_t result2 = function_5faf8(); // 0x38c2c
    __asm_vmov_7(result2);
    return result2;
}

// Address range: 0x38c64 - 0x38c6c
int32_t function_38c64(void) {
    // 0x38c64
    int32_t v1; // 0x38c64
    return (float32_t)sqrt((float64_t)(int64_t)v1);
}

// Address range: 0x38c70 - 0x38e40
int32_t function_38c70(int32_t a1, int32_t result) {
    char * v1 = g289; // 0x38c88
    int32_t v2 = a1 - 160; // 0x38c90
    int32_t v3; // 0x38c70
    int32_t v4; // 0x38c70
    char * str; // bp-2072, 0x38c70
    if (v1 >= (char *)4 == (v1 != (char *)4)) {
        // 0x38ccc
        snprintf((char *)&str, 2048, "[DEBUG] sweep_type = 0x%X, pattern_file_path = %s\n", a1, (char *)result);
        function_2e584(4, (int32_t *)&str, 0);
        if (v2 != 0 == (v2 != 1)) {
            goto lab_0x38ca4;
        } else {
            char * v5 = g289; // 0x38d00
            v3 = 0;
            v4 = (int32_t)v5;
            if (v5 != (char *)4 && v5 >= (char *)4) {
                // 0x38d0c
                str = (char *)0x4245445b;
                function_2e584(4, (int32_t *)&str, 0);
                v3 = 0;
                v4 = 0;
            }
            goto lab_0x38d4c;
        }
    } else {
        // 0x38c9c
        v4 = (int32_t)v1;
        if (v2 == 1 || v2 == 0) {
            goto lab_0x38d4c;
        } else {
            goto lab_0x38ca4;
        }
    }
  lab_0x38ca4:
    // 0x38ca4
    function_356c4(20, 255);
    char * v6 = g289; // 0x38cb0
    if (v6 >= (char *)3 != v6 != (char *)3) {
        // 0x38cbc
        return -1;
    }
    // 0x38d94
    snprintf((char *)&str, 2048, "Invalid sweep type 0x%X\n", a1);
    // 0x38dac
    function_2e584(3, (int32_t *)&str, 0);
    // 0x38cbc
    return -1;
  lab_0x38d4c:;
    int32_t v7 = g96; // 0x38d5c
    if (g96 == 0) {
        int32_t v8 = function_11eb0(68, 1, v3, v4); // 0x38dd4
        g96 = v8;
        if (v8 == 0) {
            // 0x38e00
            function_356c4(13, 255);
            char * v9 = g289; // 0x38e0c
            if (v9 == (char *)3 || v9 < (char *)3) {
                // 0x38cbc
                return -1;
            }
            // 0x38e18
            str = (char *)0x6c696146;
            // 0x38dac
            function_2e584(3, (int32_t *)&str, 0);
            // 0x38cbc
            return -1;
        }
        // 0x38de8
        *(int32_t *)(v8 + 8) = 0;
        *(int32_t *)(v8 + 12) = 0;
        *(int32_t *)(v8 + 16) = 0;
        *(int32_t *)(v8 + 20) = 0;
        v7 = v8;
    }
    // 0x38d60
    *(int32_t *)v7 = a1;
    if (a1 == 160) {
        // 0x38dc0
        *(int32_t *)(v7 + 4) = function_38450();
    } else {
        // 0x38d6c
        *(int32_t *)(v7 + 4) = function_37574();
    }
    // 0x38cbc
    return result;
}

// Address range: 0x38e40 - 0x38f58
int32_t function_38e40(void) {
    char * v1 = g289; // 0x38e50
    char * v2; // 0x38e40
    int32_t v3; // 0x38e40
    int32_t v4; // 0x38e40
    int32_t v5; // 0x38e40
    int32_t v6; // 0x38e40
    int32_t v7; // 0x38e40
    char * v8; // bp-2064, 0x38e40
    if (v1 >= (char *)4 == (v1 != (char *)4)) {
        // 0x38f04
        v8 = (char *)0x4245445b;
        function_2e584(4, (int32_t *)&v8, 0);
        int32_t v9 = *(int32_t *)((int32_t)&g85 | 0xcb3c); // 0x38f3c
        if (v9 == 0) {
            char * v10 = g289; // 0x38f48
            v7 = (int32_t)&g85 | 0xcb3c;
            if (v10 >= (char *)4 != v10 != (char *)4) {
                // 0x38ea8
                return 0;
            }
            goto lab_0x38ec0;
        } else {
            // 0x38f04
            v2 = g289;
            v3 = v9;
            v4 = (int32_t)&v8;
            v5 = 0;
            v6 = (int32_t)&g85 | 0xcb3c;
            goto lab_0x38e70;
        }
    } else {
        // 0x38e5c
        v2 = v1;
        v3 = g96;
        v6 = &g96;
        if (g96 == 0) {
            // 0x38ea8
            return 0;
        }
        goto lab_0x38e70;
    }
  lab_0x38e70:;
    char * v11 = v2;
    int32_t v12 = (int32_t)v11;
    int32_t * v13; // 0x38e40
    int32_t v14; // 0x38e40
    int32_t v15; // 0x38e40
    int32_t v16; // 0x38e40
    int32_t v17; // 0x38e40
    int32_t v18; // 0x38e40
    int32_t v19; // 0x38e40
    int32_t v20; // 0x38e40
    int32_t v21; // 0x38e40
    if (*(int32_t *)(v3 + 4) == 0) {
        // 0x38eb0
        v7 = v6;
        if (v11 == (char *)4 || v11 < (char *)4) {
            // 0x38eb0
            v13 = (int32_t *)v6;
            v14 = v3;
            v16 = v4;
            v18 = v5;
            v20 = v12;
            goto lab_0x38e9c;
        } else {
            goto lab_0x38ec0;
        }
    } else {
        // 0x38e7c
        v15 = v4;
        v17 = v5;
        v19 = v12;
        v21 = v6;
        v7 = v6;
        if (v11 >= (char *)4 == (v11 != (char *)4)) {
            goto lab_0x38ec0;
        } else {
            goto lab_0x38e90;
        }
    }
  lab_0x38ec0:
    // 0x38ec0
    v8 = (char *)0x4245445b;
    function_2e584(4, (int32_t *)&v8, 0);
    v15 = (int32_t)&v8;
    v17 = 0;
    v19 = 0;
    v21 = v7;
    goto lab_0x38e90;
  lab_0x38e90:;
    int32_t * v22 = (int32_t *)v21;
    int32_t v23 = *v22; // 0x38e90
    v13 = v22;
    v14 = v23;
    v16 = v15;
    v18 = v17;
    v20 = v19;
    if (v23 == 0) {
        // 0x38ea8
        return 0;
    }
    goto lab_0x38e9c;
  lab_0x38e9c:;
    int32_t result = free(v14, v16, v18, v20); // 0x38e9c
    *v13 = 0;
    // 0x38ea8
    return result;
}

// Address range: 0x38f58 - 0x39018
int32_t function_38f58(void) {
    char * v1 = g289; // 0x38f68
    int32_t result; // 0x38f58
    int32_t v2; // bp-2056, 0x38f58
    if (v1 >= (char *)4 == (v1 != (char *)4)) {
        // 0x38fe4
        v2 = 0x4245445b;
        result = function_2e584(4, &v2, 0);
    }
    // 0x38f74
    if (g96 != 0) {
        // 0x38f88
        if (*(int32_t *)(g96 + 4) != 0) {
            // 0x38f9c
            return result;
        }
    }
    char * v3 = g289; // 0x38fa4
    if (v3 == (char *)3 || v3 < (char *)3) {
        // 0x38f9c
        return result;
    }
    // 0x38fb0
    v2 = 0x646e6148;
    return function_2e584(3, &v2, 0);
}

// Address range: 0x39018 - 0x390b0
int32_t function_39018(void) {
    // 0x39018
    int32_t result; // 0x39018
    if (g96 != 0) {
        // 0x39038
        if (*(int32_t *)(g96 + 4) != 0) {
            // 0x39058
            return result;
        }
    }
    char * v1 = g289; // 0x3906c
    if (v1 == (char *)3 || v1 < (char *)3) {
        // 0x39058
        return result;
    }
    int32_t v2 = 0x646e6148; // bp-2056, 0x3908c
    return function_2e584(3, &v2, 0);
}

// Address range: 0x390b0 - 0x39128
int32_t function_390b0(int32_t a1) {
    int32_t result = a1;
    int32_t v1 = *(int32_t *)(a1 + 4); // 0x390bc
    int32_t v2 = g232; // 0x390c4
    int32_t v3 = v2 + 1; // 0x390c8
    int32_t v4 = 8 * v3; // 0x390d0
    *(int32_t *)(v4 + (int32_t)&g232 + 4) = v1;
    int32_t v5 = __asm_ubfx((int32_t)*(char *)(a1 + 3), 0, 5); // 0x390dc
    *(char *)(v4 + (int32_t)&g232 + 8) = (char)v5;
    char v6 = *(char *)(a1 + 2); // 0x390e4
    *(char *)(v4 + (int32_t)&g232 + 9) = v6;
    char v7 = *(char *)(a1 + 1); // 0x390ec
    *(char *)(v4 + (int32_t)&g232 + 10) = v7;
    if (v2 == 509 || (v3 & 0x20000000) == 0) {
        g232 = v3;
    }
    int32_t v8 = __asm_ubfx((int32_t)*(char *)&result, 0, 4); // 0x390fc
    *(char *)(v4 + (int32_t)&g232 + 11) = (char)v8;
    if ((v3 & 0x20000000) != 0 == (v2 != 509)) {
        g232 = 0;
    }
    uint32_t v9 = g234; // 0x39110
    int32_t v10 = v9 >= 510 == (v9 != 510) ? 511 : v9 + (int32_t)(v9 == 510 | v9 < 510);
    g234 = v10;
    return result;
}

// Address range: 0x39128 - 0x391f4
int32_t function_39128(int32_t * a1) {
    int32_t result = (int32_t)a1;
    if (g96 != 0) {
        int32_t v1 = *(int32_t *)(g96 + 4); // 0x39148
        if (v1 != 0) {
            // 0x39154
            int32_t v2; // 0x39128
            function_11f94(&g416, v2, v2, v1);
            int32_t v3 = *(int32_t *)(g96 + 64); // 0x39168
            int32_t v4; // 0x39128
            if (v3 == 0) {
                // 0x391e8
                function_390b0(result);
                v4 = g96;
            } else {
                // 0x39174
                v4 = *(int32_t *)(*(int32_t *)(g96 + 4) + 24);
            }
            // 0x39190
            return function_11ea4(&g416, v2, v3, v4);
        }
    }
    char * v5 = g289; // 0x391a4
    if (v5 == (char *)3 || v5 < (char *)3) {
        // 0x39190
        return result;
    }
    int32_t v6 = 0x646e6148; // bp-2064, 0x391c4
    return function_2e584(3, &v6, 0);
}

// Address range: 0x391f4 - 0x392b8
int32_t function_391f4(void) {
    char * v1 = g289; // 0x39204
    int32_t result; // 0x391f4
    char * v2; // bp-2056, 0x391f4
    if (v1 >= (char *)4 == (v1 != (char *)4)) {
        // 0x39288
        v2 = (char *)0x4245445b;
        result = function_2e584(4, (int32_t *)&v2, 0);
    }
    // 0x39210
    if (g96 != 0) {
        // 0x39224
        if (*(int32_t *)(g96 + 4) != 0) {
            // 0x39238
            return result;
        }
    }
    char * v3 = g289; // 0x39240
    if (v3 == (char *)3 || v3 < (char *)3) {
        // 0x39238
        return 0;
    }
    // 0x39250
    v2 = (char *)0x646e6148;
    function_2e584(3, (int32_t *)&v2, 0);
    return 0;
}

// Address range: 0x392b8 - 0x39360
int32_t function_392b8(int32_t result) {
    char * v1 = g289; // 0x392d0
    int32_t v2 = result; // 0x392d8
    if (v1 >= (char *)4 == (v1 != (char *)4)) {
        // 0x39334
        int32_t str; // bp-2064, 0x392b8
        snprintf((char *)&str, 2048, "[DEBUG] Check if chain is unbalance happen, chain = %d.\n", result);
        v2 = function_2e584(4, &str, 0);
    }
    // 0x392dc
    if (g96 != 0) {
        // 0x392f0
        if (*(int32_t *)(g96 + 4) != 0) {
            // 0x39308
            return result;
        }
    }
    char * v3 = g289; // 0x39314
    if (v3 != (char *)3 && v3 >= (char *)3) {
        // 0x39324
        return function_388f4(v2);
    }
    // 0x39308
    return 1;
}

// Address range: 0x39360 - 0x39404
int32_t function_39360(void) {
    char * v1 = g289; // 0x39370
    if (v1 >= (char *)4 == (v1 != (char *)4)) {
        char * v2 = (char *)0x4245445b; // bp-2056, 0x393d0
        function_2e584(4, (int32_t *)&v2, 0);
    }
    int32_t v3 = 0;
    if (function_1e29c(v3) != 0) {
        // 0x393a8
        if (function_392b8(v3) != 0) {
            // break -> 0x393a0
            break;
        }
    }
    int32_t v4 = v3 + 1; // 0x39390
    int32_t result = 0; // 0x39398
    while (v4 != 4) {
        // 0x39380
        v3 = v4;
        if (function_1e29c(v3) != 0) {
            // 0x393a8
            result = 1;
            if (function_392b8(v3) != 0) {
                // break -> 0x393a0
                break;
            }
        }
        // 0x39390
        v4 = v3 + 1;
        result = 0;
    }
    // 0x393a0
    return result;
}

// Address range: 0x39404 - 0x394a4
int32_t function_39404(int32_t result) {
    // 0x39404
    float64_t v1; // 0x39404
    float64_t v2 = __asm_vpush(v1); // 0x39410
    char * v3 = g289; // 0x3941c
    float32_t v4; // 0x39404
    float32_t v5 = __asm_vmov_f32(v4); // 0x39424
    if (v3 >= (char *)4 == (v3 != (char *)4)) {
        // 0x394a4
        return result;
    }
    // 0x39430
    if (g96 != 0) {
        int32_t v6 = *(int32_t *)(g96 + 4); // 0x39444
        if (v6 != 0) {
            // 0x39450
            __asm_vcmpe_f32(__asm_vldr_8(*(int32_t *)(4 * result + 48 + g96)), v5);
            int32_t v7; // 0x39404
            __asm_vmrs(v7, v7);
            int32_t result2 = 0; // 0x3946c
            if (v6 < 0) {
                *(char *)(result + 28 + g96) = 1;
                result2 = 1;
            }
            // 0x39470
            __asm_vpop(v2);
            return result2;
        }
    }
    char * v8 = g289; // 0x39480
    if (v8 == (char *)3 || v8 < (char *)3) {
        // 0x39470
        __asm_vpop(v2);
        return 1;
    }
    int32_t result3 = function_388f4(g96); // 0x39490
    __asm_vpop(v2);
    return result3;
}

// Address range: 0x394a6 - 0x394be
int32_t function_394a6(int32_t a1) {
    // 0x394a6
    bool v1; // 0x394a6
    if (v1) {
        __asm_stchs(14, 14, *(int32_t *)(a1 + 732));
    }
    int32_t v2 = a1; // 0x394b6
    if (!v1) {
        v2 = function_f1b3e();
    }
    int32_t result = v2; // 0x394ba
    if (!v1) {
        result = function_72342();
    }
    // 0x394be
    return result;
}

// Address range: 0x394c0 - 0x394d8
int32_t function_394c0(void) {
    // 0x394c0
    int32_t str; // 0x394c0
    snprintf((char *)str, str, (char *)str);
    int32_t v1; // 0x394c0
    return function_2e584(4, &v1, 0);
}

// Address range: 0x394d8 - 0x39584
int32_t function_394d8(void) {
    // 0x394d8
    float64_t v1; // 0x394d8
    float64_t v2 = __asm_vpush(v1); // 0x394e4
    char * v3 = g289; // 0x394ec
    float32_t v4; // 0x394d8
    float32_t v5 = __asm_vmov_f32(v4); // 0x394f0
    if (v3 >= (char *)4 == (v3 != (char *)4)) {
        char * v6 = (char *)0x4245445b; // bp-2056, 0x39558
        function_2e584(4, (int32_t *)&v6, 0);
    }
    int32_t v7 = 0;
    if (function_1e29c(v7) != 0) {
        // 0x3952c
        __asm_vmov_f32(v5);
        if (function_39404(v7) != 0) {
            // break -> 0x39520
            break;
        }
    }
    int32_t v8 = v7 + 1; // 0x39510
    int32_t result = 0; // 0x39518
    while (v8 != 4) {
        // 0x39500
        v7 = v8;
        if (function_1e29c(v7) != 0) {
            // 0x3952c
            __asm_vmov_f32(v5);
            result = 1;
            if (function_39404(v7) != 0) {
                // break -> 0x39520
                break;
            }
        }
        // 0x39510
        v8 = v7 + 1;
        result = 0;
    }
    // 0x39520
    __asm_vpop(v2);
    return result;
}

// Address range: 0x39584 - 0x3962c
int32_t function_39584(int32_t result) {
    char * v1 = g289; // 0x3959c
    int32_t v2 = result; // 0x395a4
    if (v1 >= (char *)4 == (v1 != (char *)4)) {
        // 0x39600
        int32_t str; // bp-2064, 0x39584
        snprintf((char *)&str, 2048, "[DEBUG] Check if recv nonce enough, chain = %d.\n", result);
        v2 = function_2e584(4, &str, 0);
    }
    // 0x395a8
    if (g96 != 0) {
        // 0x395bc
        if (*(int32_t *)(g96 + 4) != 0) {
            // 0x395d4
            return result;
        }
    }
    char * v3 = g289; // 0x395e0
    if (v3 != (char *)3 && v3 >= (char *)3) {
        // 0x395f0
        return function_388f4(v2);
    }
    // 0x395d4
    return 1;
}

// Address range: 0x3962c - 0x397a0
int32_t function_3962c(int32_t result, int32_t a2) {
    char * v1 = g289; // 0x39644
    int32_t v2; // 0x3962c
    if (v1 == (char *)3 || v1 < (char *)3) {
        // 0x396f4
        if (g96 == 0 || *(int32_t *)(g96 + 4) == 0) {
            // 0x396e8
            return result;
        }
        goto lab_0x39714;
    } else {
        // 0x39654
        v2 = 0x67e58;
        switch (a2) {
            case 0: {
                goto lab_0x39664;
            }
            case 1: {
                // 0x39784
                v2 = (int32_t)"READY";
                goto lab_0x39664;
            }
            case 2: {
                // 0x39664
                v2 = (int32_t)"DONE";
                goto lab_0x39664;
            }
            default: {
                v2 = (int32_t)"UNKNOWN";
                goto lab_0x39664;
            }
        }
    }
  lab_0x39714:;
    int32_t v3 = 0;
    int32_t result2 = function_1e29c(v3); // 0x3971c
    if (result2 != 0) {
        if (result == 255) {
            // 0x39774
            *(int32_t *)(4 * v3 + 8 + g96) = a2;
        } else {
            if (v3 == result) {
                // 0x39790
                *(int32_t *)(4 * result + 8 + g96) = a2;
                return result2;
            }
        }
    }
    int32_t v4 = v3 + 1; // 0x39738
    while (v4 != 4) {
        // 0x39718
        v3 = v4;
        result2 = function_1e29c(v3);
        if (result2 != 0) {
            if (result == 255) {
                // 0x39774
                *(int32_t *)(4 * v3 + 8 + g96) = a2;
            } else {
                if (v3 == result) {
                    // 0x39790
                    *(int32_t *)(4 * result + 8 + g96) = a2;
                    return result2;
                }
            }
        }
        // 0x39738
        v4 = v3 + 1;
    }
  lab_0x396e8:
    // 0x396e8
    return result2;
  lab_0x39664:;
    // 0x39664
    int32_t str; // bp-2072, 0x3962c
    snprintf((char *)&str, 2048, "chain = %d, status = %s\n", result, (char *)v2);
    int32_t v5 = function_2e584(3, &str, 0); // 0x39694
    if (g96 == 0) {
        goto lab_0x396b0;
    } else {
        // 0x396a4
        if (*(int32_t *)(g96 + 4) == 0) {
            goto lab_0x396b0;
        } else {
            goto lab_0x39714;
        }
    }
  lab_0x396b0:;
    char * v6 = g289; // 0x396b0
    int32_t result3 = v5; // 0x396b8
    if (v6 != (char *)3 && v6 >= (char *)3) {
        // 0x396bc
        str = 0x646e6148;
        result3 = function_2e584(3, &str, 0);
    }
    // 0x396e8
    return result3;
}

// Address range: 0x397a0 - 0x398bc
int32_t function_397a0(int32_t a1) {
    char * v1 = g289; // 0x397b8
    int32_t v2 = g96; // 0x397cc
    int32_t str; // bp-2064, 0x397a0
    if (v1 != (char *)4 && v1 >= (char *)4) {
        int32_t v3 = 0x67e58; // 0x397a0
        int32_t v4; // 0x397c4
        switch (*(int32_t *)(4 * a1 + 8 + v4)) {
            case 1: {
                // 0x398b0
                v3 = (int32_t)"READY";
            }
            case 0: {
              lab_0x397e8:
                // 0x397e8
                snprintf((char *)&str, 2048, "[DEBUG] chain = %d, status = %s\n", a1, (char *)v3);
                function_2e584(4, &str, 0);
                v2 = g96;
                // break -> 0x39818
                break;
            }
            case 2: {
                v3 = (int32_t)"DONE";
                // branch (via goto) -> 0x397e8
                goto lab_0x397e8;
            }
            default: {
                // 0x397e8
                v3 = (int32_t)"UNKNOWN";
                // branch (via goto) -> 0x397e8
                goto lab_0x397e8;
            }
        }
    }
    // 0x39818
    if (v2 != 0) {
        // 0x39820
        if (*(int32_t *)(v2 + 4) != 0) {
            // 0x39834
            return *(int32_t *)(4 * a1 + 8 + v2);
        }
    }
    char * v5 = g289; // 0x39840
    if (v5 == (char *)3 || v5 < (char *)3) {
        // 0x39834
        return 2;
    }
    // 0x39850
    str = 0x646e6148;
    function_2e584(3, &str, 0);
    return 2;
}

// Address range: 0x398bc - 0x39954
int32_t function_398bc(void) {
    char * v1 = g289; // 0x398cc
    int32_t result; // 0x398bc
    if (v1 >= (char *)4 == (v1 != (char *)4)) {
        char * v2 = (char *)0x4245445b; // bp-2056, 0x39930
        result = function_2e584(4, (int32_t *)&v2, 0);
    }
    // 0x398d8
    if (g96 != 0) {
        // 0x398ec
        if (*(int32_t *)(g96 + 4) != 0) {
            // 0x39900
            return result;
        }
    }
    char * v3 = g289; // 0x39908
    if (v3 != (char *)3 && v3 >= (char *)3) {
        // 0x39914
        return function_387f8();
    }
    // 0x39900
    return result;
}

// Address range: 0x39954 - 0x39998
int32_t function_39954(void) {
    int32_t v1 = 0;
    if (function_1e29c(v1) != 0) {
        // 0x39980
        if (function_397a0(v1) == 0) {
            // break -> 0x39978
            break;
        }
    }
    int32_t v2 = v1 + 1; // 0x3996c
    int32_t result = 0; // 0x39974
    while (v2 != 4) {
        // 0x3995c
        v1 = v2;
        if (function_1e29c(v1) != 0) {
            // 0x39980
            result = 1;
            if (function_397a0(v1) == 0) {
                // break -> 0x39978
                break;
            }
        }
        // 0x3996c
        v2 = v1 + 1;
        result = 0;
    }
    // 0x39978
    return result;
}

// Address range: 0x39998 - 0x399d8
int32_t function_39998(void) {
    int32_t v1 = 0;
    if (function_1e29c(v1) != 0) {
        // 0x399c4
        if (function_397a0(v1) == 1) {
            // break -> 0x399bc
            break;
        }
    }
    int32_t v2 = v1 + 1; // 0x399b0
    int32_t result = 0; // 0x399b8
    while (v2 != 4) {
        // 0x399a0
        v1 = v2;
        if (function_1e29c(v1) != 0) {
            // 0x399c4
            result = 1;
            if (function_397a0(v1) == 1) {
                // break -> 0x399bc
                break;
            }
        }
        // 0x399b0
        v2 = v1 + 1;
        result = 0;
    }
    // 0x399bc
    return result;
}

// Address range: 0x399d8 - 0x39a7c
int32_t function_399d8(uint32_t a1) {
    char * v1 = g289; // 0x399ec
    if (v1 >= (char *)4 == (v1 != (char *)4)) {
        // 0x39a50
        int32_t str; // bp-2064, 0x399d8
        snprintf((char *)&str, 2048, "[DEBUG] Set chain serial, chain_serial_count = %d.\n", a1);
        function_2e584(4, &str, 0);
    }
    int32_t v2 = 0;
    int32_t v3 = 0;
    int32_t v4 = function_1e29c(v3); // 0x39a04
    int32_t v5 = v3; // 0x39a10
    int32_t v6 = v2; // 0x39a10
    int32_t v7; // 0x39a1c
    if (v4 != 0) {
        // 0x39a14
        if (v2 == a1 || v2 > a1) {
            // break -> 0x39a34
            break;
        }
        // 0x39a1c
        v7 = function_397a0(v3);
        v5 = v7;
        v6 = v2;
        if (v7 == 0) {
            // 0x39a3c
            v5 = function_3962c(v3, 1);
            v6 = v2 + 1;
        }
    }
    int32_t v8 = v3 + 1; // 0x39a28
    int32_t result = v5; // 0x39a30
    while (v8 != 4) {
        // 0x39a00
        v2 = v6;
        v3 = v8;
        v4 = function_1e29c(v3);
        v5 = v3;
        v6 = v2;
        if (v4 != 0) {
            // 0x39a14
            result = v3;
            if (v2 == a1 || v2 > a1) {
                // break -> 0x39a34
                break;
            }
            // 0x39a1c
            v7 = function_397a0(v3);
            v5 = v7;
            v6 = v2;
            if (v7 == 0) {
                // 0x39a3c
                v5 = function_3962c(v3, 1);
                v6 = v2 + 1;
            }
        }
        // 0x39a28
        v8 = v3 + 1;
        result = v5;
    }
    // 0x39a34
    return result;
}

// Address range: 0x39a7c - 0x39b60
int32_t function_39a7c(void) {
    char * v1 = g289; // 0x39a8c
    int32_t result; // 0x39a7c
    int32_t v2; // bp-2056, 0x39a7c
    if (v1 >= (char *)4 == (v1 != (char *)4)) {
        // 0x39b2c
        v2 = 0x4245445b;
        result = function_2e584(4, &v2, 0);
    }
    // 0x39a98
    if (g96 != 0) {
        // 0x39aac
        if (*(int32_t *)(g96 + 4) != 0) {
            // 0x39ab8
            *(int32_t *)(g96 + 24) = 0;
            *(int32_t *)(g96 + 28) = 0;
            *(int32_t *)(g96 + 32) = 0;
            *(int32_t *)(g96 + 36) = 0;
            *(int32_t *)(g96 + 40) = 0;
            *(int32_t *)(g96 + 44) = 0;
            *(int32_t *)(g96 + 48) = 0;
            *(int32_t *)(g96 + 52) = 0;
            *(int32_t *)(g96 + 56) = 0;
            *(int32_t *)(g96 + 60) = 0;
            // 0x39ae4
            return result;
        }
    }
    char * v3 = g289; // 0x39aec
    if (v3 == (char *)3 || v3 < (char *)3) {
        // 0x39ae4
        return result;
    }
    // 0x39af8
    v2 = 0x646e6148;
    return function_2e584(3, &v2, 0);
}

// Address range: 0x39b60 - 0x39d44
int32_t function_39b60(int32_t a1) {
    // 0x39b60
    float64_t v1; // 0x39b60
    float64_t v2 = __asm_vpush_11(v1, v1); // 0x39b68
    float32_t v3; // 0x39b60
    float32_t v4 = __asm_vmov_f32(v3); // 0x39b7c
    __asm_vmov_f32(v3);
    __asm_vmov_f32(v3);
    int32_t result = function_391f4(); // 0x39b88
    char * v5 = g289; // 0x39b8c
    if (v5 >= (char *)4 == (v5 != (char *)4)) {
        // 0x39c6c
        return result;
    }
    // 0x39b9c
    int32_t str; // bp-2080, 0x39b60
    if (g96 != 0) {
        // 0x39bb0
        if (*(int32_t *)(g96 + 4) != 0) {
            int32_t v6 = function_1e130(); // 0x39bbc
            int32_t v7 = 4 * a1; // 0x39bc4
            int32_t v8 = function_1e0f0(); // 0x39bcc
            int32_t v9 = result + v7; // 0x39bd4
            uint32_t v10 = *(int32_t *)(v9 + (int32_t)&g358 + 0xa850); // 0x39be0
            float32_t v11 = __asm_vcvt_u32_f32(__asm_vmul_f32(__asm_vcvt_f32_s32(__asm_vmov_7(8 * v6 * v8)), v4)); // 0x39bf0
            uint32_t v12 = __asm_vmov_9(v11); // 0x39bf4
            int32_t v13; // 0x39b60
            if (v10 != v12 && v10 >= v12) {
                char * v14 = g289; // 0x39c00
                if (v14 >= (char *)3 == (v14 != (char *)3)) {
                    // 0x39cb0
                    __asm_vstr_12(v11, v13);
                    snprintf((char *)&str, 2048, "chain = %d, hw = %d, hw_threshold = %d, too much hw.\n", a1);
                    function_2e584(3, &str, 0);
                }
                // 0x39c10
                __asm_vpop_13(v2, v2);
                return 1;
            }
            float32_t v15 = __asm_vldr_8(*(int32_t *)(v9 + (int32_t)&g358 + 0xa000)); // 0x39ce4
            int32_t v16 = function_1e130(); // 0x39ce8
            float32_t v17 = __asm_vcvt_f32_u32(v15); // 0x39cf4
            int32_t result2 = function_1e0f0() * 8 * v16; // 0x39cfc
            int32_t v18 = g96 + v7; // 0x39d04
            char * v19 = g289; // 0x39d08
            float32_t v20 = __asm_vmov_7(result2); // 0x39d0c
            int32_t * v21 = (int32_t *)(v18 + 48); // 0x39d10
            float32_t v22 = __asm_vldr_8(*v21); // 0x39d10
            float32_t v23 = __asm_vcvt_f32_s32(v20); // 0x39d14
            int32_t * v24 = (int32_t *)(v18 + 32); // 0x39d18
            __asm_vldr_8(*v24);
            float32_t v25 = __asm_vdiv_f32(v17, v23); // 0x39d1c
            __asm_vcmpe_f32(v22, v25);
            __asm_vmrs(v13, v13);
            __asm_vstr_12(v25, *v24);
            if (v10 - v12 < 0) {
                __asm_vstrmi(v25, *v21);
            }
            if (v19 != (char *)3 && v19 >= (char *)3) {
                // 0x39d3c
                __asm_vldr_8(*v21);
                return result2;
            }
            // 0x39c10
            __asm_vpop_13(v2, v2);
            return 0;
        }
    }
    // 0x39c20
    if (v5 == (char *)3 || v5 < (char *)3) {
        // 0x39c10
        __asm_vpop_13(v2, v2);
        return 1;
    }
    // 0x39c2c
    str = 0x646e6148;
    function_2e584(3, &str, 0);
    __asm_vpop_13(v2, v2);
    return 1;
}

// Address range: 0x39d44 - 0x39d4c
int32_t function_39d44(int32_t result) {
    // 0x39d44
    __asm_cdp(0, 11, 3, 7, 7, 0);
    return result;
}

// Address range: 0x39d4c - 0x39d54
int32_t function_39d4c(int32_t result) {
    // 0x39d4c
    __asm_cdp(0, 11, 2, 7, 6, 0);
    return result;
}

// Address range: 0x39d54 - 0x39d58
int32_t function_39d54(int32_t result) {
    // 0x39d54
    return result;
}

// Address range: 0x39d58 - 0x39d5c
int32_t function_39d58(int32_t a1, int32_t a2, int32_t a3, int32_t result) {
    // 0x39d58
    return result;
}

// Address range: 0x39d5e - 0x39d6a
int32_t function_39d5e(void) {
    // 0x39d5e
    int32_t v1; // 0x39d5e
    bool v2; // 0x39d5e
    if (v2) {
        // 0x39d62
        v1 = function_f5842();
    } else {
        // 0x39d62
        v1 = function_7539e();
    }
    int32_t result = v1; // 0x39d66
    if (!v2) {
        result = function_1753a2();
    }
    // 0x39d6a
    return result;
}

// Address range: 0x39d6c - 0x39d88
int32_t function_39d6c(void) {
    // 0x39d6c
    int32_t str; // 0x39d6c
    snprintf((char *)str, str, (char *)str);
    int32_t v1; // bp+24, 0x39d6c
    function_2e584(3, &v1, 0);
    return 0;
}

// Address range: 0x39d88 - 0x39ea0
int32_t function_39d88(void) {
    char * v1 = g289; // 0x39d9c
    int32_t v2; // bp-2064, 0x39d88
    if (v1 >= (char *)4 == (v1 != (char *)4)) {
        // 0x39e54
        v2 = 0x4245445b;
        function_2e584(4, &v2, 0);
    }
    // 0x39da8
    if (g96 != 0) {
        // 0x39dbc
        if (*(int32_t *)(g96 + 4) != 0) {
            int32_t v3 = 0;
            if (function_1e29c(v3) != 0) {
                // 0x39de4
                if (*(int32_t *)(4 * v3 + 8 + g96) != 2) {
                    // break -> 0x39e00
                    break;
                }
            }
            int32_t v4 = v3 + 1; // 0x39ddc
            int32_t result = 1; // 0x39df8
            while (v4 != 4) {
                // 0x39dcc
                v3 = v4;
                if (function_1e29c(v3) != 0) {
                    // 0x39de4
                    result = 0;
                    if (*(int32_t *)(4 * v3 + 8 + g96) != 2) {
                        // break -> 0x39e00
                        break;
                    }
                }
                // 0x39df4
                v4 = v3 + 1;
                result = 1;
            }
            // 0x39e00
            return result;
        }
    }
    char * v5 = g289;
    if (v5 == (char *)3 || v5 < (char *)3) {
        // 0x39e00
        return 1;
    }
    // 0x39e18
    v2 = 0x646e6148;
    function_2e584(3, &v2, 0);
    return 1;
}

// Address range: 0x39ea0 - 0x39fb4
int32_t function_39ea0(void) {
    char * v1 = g289; // 0x39eb4
    int32_t v2; // bp-2064, 0x39ea0
    if (v1 >= (char *)4 == (v1 != (char *)4)) {
        // 0x39f6c
        v2 = 0x4245445b;
        function_2e584(4, &v2, 0);
    }
    // 0x39ec0
    if (g96 != 0) {
        // 0x39ed4
        if (*(int32_t *)(g96 + 4) != 0) {
            int32_t v3 = 0;
            if (function_1e29c(v3) != 0) {
                // 0x39efc
                if ((*(int32_t *)(4 * v3 + 8 + g96) & -3) != 0) {
                    // break -> 0x39f18
                    break;
                }
            }
            int32_t v4 = v3 + 1; // 0x39ef4
            int32_t result = 1; // 0x39f10
            while (v4 != 4) {
                // 0x39ee4
                v3 = v4;
                if (function_1e29c(v3) != 0) {
                    // 0x39efc
                    result = 0;
                    if ((*(int32_t *)(4 * v3 + 8 + g96) & -3) != 0) {
                        // break -> 0x39f18
                        break;
                    }
                }
                // 0x39f0c
                v4 = v3 + 1;
                result = 1;
            }
            // 0x39f18
            return result;
        }
    }
    char * v5 = g289;
    if (v5 == (char *)3 || v5 < (char *)3) {
        // 0x39f18
        return 1;
    }
    // 0x39f30
    v2 = 0x646e6148;
    function_2e584(3, &v2, 0);
    return 1;
}

// Address range: 0x39fb4 - 0x3a054
int32_t function_39fb4(int32_t a1) {
    char * v1 = g289; // 0x39fc4
    if (v1 >= (char *)4 == (v1 != (char *)4)) {
        // 0x3a028
        int32_t str; // bp-2056, 0x39fb4
        snprintf((char *)&str, 2048, "[DEBUG] Board init, is_power_off = %d.\n", a1);
        function_2e584(4, &str, 0);
    }
    int32_t v2 = 0;
    if (function_1e29c(v2) != 0) {
        // 0x3a01c
        function_4fa0c(v2);
    }
    int32_t v3 = v2 + 1; // 0x39fe4
    while (v3 != 4) {
        // 0x39fd4
        v2 = v3;
        if (function_1e29c(v2) != 0) {
            // 0x3a01c
            function_4fa0c(v2);
        }
        // 0x39fe4
        v3 = v2 + 1;
    }
    // 0x39ff0
    function_3345c();
    int32_t result = function_33e34(); // 0x39ff4
    function_304d4(10);
    function_281b8();
    function_304d4(10);
    return result;
}

// Address range: 0x3a054 - 0x3a828
int32_t function_3a054(int32_t result6, int32_t a2) {
    // 0x3a054
    float64_t v1; // 0x3a054
    float64_t v2 = __asm_vpush(v1); // 0x3a060
    char * v3 = g289; // 0x3a078
    int32_t result3; // 0x3a054
    int32_t v4; // 0x3a054
    int32_t v5; // 0x3a054
    int32_t str; // bp-2088, 0x3a054
    if (g96 != 0) {
        // 0x3a084
        if (*(int32_t *)(g96 + 4) != 0) {
            int32_t v6 = (int32_t)v3; // 0x3a09c
            if (v3 >= (char *)3 == (v3 != (char *)3)) {
                // 0x3a340
                snprintf((char *)&str, 2048, "chain %d stats:\n", result6);
                function_2ea54(3, &str, 0);
                char * v7 = g289; // 0x3a368
                v6 = 0;
                if (v7 != (char *)3 && v7 >= (char *)3) {
                    int32_t v8 = function_1e130(); // 0x3a374
                    int32_t v9 = function_1e0f0(); // 0x3a37c
                    snprintf((char *)&str, 2048, "%-30s : %d\n", "send_nonce_num", 8 * v8 * v9);
                    function_2ea54(3, &str, 0);
                    char * v10 = g289; // 0x3a3b8
                    v6 = 0;
                    if (v10 != (char *)3 && v10 >= (char *)3) {
                        int32_t * v11 = (int32_t *)(4 * (result6 + (int32_t)&g8 + 0x2800) + a2); // 0x3a3d4
                        snprintf((char *)&str, 2048, "%-30s : %d\n", "recv_nonce_num", *v11);
                        function_2ea54(3, &str, 0);
                        char * v12 = g289; // 0x3a400
                        v6 = 0;
                        if (v12 != (char *)3 && v12 >= (char *)3) {
                            float32_t v13 = __asm_vmov_7(*v11); // 0x3a410
                            int32_t v14 = function_1e130(); // 0x3a414
                            float32_t v15 = __asm_vcvt_f32_u32(v13); // 0x3a41c
                            __asm_vdiv_f32(v15, __asm_vcvt_f32_s32(__asm_vmov_7(8 * v14 * function_1e0f0())));
                            return &str;
                        }
                    }
                }
            }
            int32_t v16 = function_1e0f0(); // 0x3a0a0
            int32_t v17 = (int32_t)g289; // 0x3a0a8
            int32_t result2 = 0; // 0x3a0ac
            int32_t v18 = v17; // 0x3a0ac
            if (v16 != 0) {
                int32_t v19 = 1024 * result6 + (int32_t)&g358 + 0x9000 + a2;
                int32_t v20 = 0;
                int32_t v21 = v17;
                int32_t v22 = v6; // 0x3a0f8
                int32_t v23 = v21; // 0x3a0f8
                int32_t v24; // 0x3a118
                if (v21 != 3 && v21 >= 3) {
                    // 0x3a0fc
                    v24 = *(int32_t *)(v19 + 4 * v20);
                    snprintf((char *)&str, 2048, "IC[%03d]:%04d ", v20, v24);
                    function_2ea54(3, &str, 0);
                    v22 = 0;
                    v23 = v20;
                }
                int32_t v25 = v20 + 1; // 0x3a0c4
                int32_t v26 = function_1e100(); // 0x3a0c8
                int32_t v27 = function_5fadc(v25, v26, v22, v23); // 0x3a0d4
                char * v28 = g289; // 0x3a0dc
                int32_t v29 = (int32_t)v28; // 0x3a0dc
                int32_t v30 = v27; // 0x3a0e0
                int32_t v31 = v29; // 0x3a0e0
                if (v26 == 0) {
                    // 0x3a0e4
                    v30 = v27;
                    v31 = v29;
                    if (v28 >= (char *)3 == (v28 != (char *)3)) {
                        // 0x3a2e8
                        str = 10;
                        v30 = function_2ea54(3, &str, 0);
                        v31 = (int32_t)g289;
                    }
                }
                int32_t v32 = v31;
                result2 = v30;
                v18 = v32;
                while (v25 != v16) {
                    // 0x3a0f4
                    v20 = v25;
                    v21 = v32;
                    v22 = v26;
                    v23 = v21;
                    if (v21 != 3 && v21 >= 3) {
                        // 0x3a0fc
                        v24 = *(int32_t *)(v19 + 4 * v20);
                        snprintf((char *)&str, 2048, "IC[%03d]:%04d ", v20, v24);
                        function_2ea54(3, &str, 0);
                        v22 = 0;
                        v23 = v20;
                    }
                    // 0x3a0c4
                    v25 = v20 + 1;
                    v26 = function_1e100();
                    v27 = function_5fadc(v25, v26, v22, v23);
                    v28 = g289;
                    v29 = (int32_t)v28;
                    v30 = v27;
                    v31 = v29;
                    if (v26 == 0) {
                        // 0x3a0e4
                        v30 = v27;
                        v31 = v29;
                        if (v28 >= (char *)3 == (v28 != (char *)3)) {
                            // 0x3a2e8
                            str = 10;
                            v30 = function_2ea54(3, &str, 0);
                            v31 = (int32_t)g289;
                        }
                    }
                    // 0x3a0ec
                    v32 = v31;
                    result2 = v30;
                    v18 = v32;
                }
            }
            uint32_t v33 = v18;
            if (v33 >= 3 == (v33 != 3)) {
                // 0x3a7c8
                str = 10;
                int32_t result = function_2ea54(3, &str, 0); // 0x3a7dc
                if (*(int32_t *)g96 == 161) {
                    // 0x3a140
                    __asm_vpop(v2);
                    return result;
                }
                char * v34 = g289; // 0x3a7f0
                if (v34 != (char *)3 && v34 >= (char *)3) {
                    // 0x3a7fc
                    snprintf((char *)&str, 2048, "Chain %d domain:\n", result6);
                    function_2ea54(3, &str, 0);
                }
            } else {
                // 0x3a158
                if (*(int32_t *)g96 == 161) {
                    // 0x3a140
                    __asm_vpop(v2);
                    return result2;
                }
            }
            // 0x3a168
            result3 = 0;
            if (function_1e0e0() != 0) {
                int32_t v35 = 256 * result6 + (int32_t)&g372 + a2;
                v4 = 0;
                while (true) {
                  lab_0x3a19c:
                    // 0x3a19c
                    v5 = v4;
                    int32_t v36 = function_1e150() * v5; // 0x3a1a0
                    if (function_1e150() != 0) {
                        int32_t v37 = 0;
                        char * v38 = g289; // 0x3a1d0
                        int32_t v39; // 0x3a054
                        int32_t v40; // 0x3a1f0
                        if (v38 != (char *)3 && v38 >= (char *)3) {
                            // 0x3a1dc
                            v39 = v37 + v36;
                            v40 = *(int32_t *)(a2 + (int32_t)&g371 + 4 * (v39 + 64 * result6));
                            snprintf((char *)&str, 2048, "D[%02d]:%04d ", v39, v40);
                            function_2ea54(3, &str, 0);
                        }
                        int32_t v41 = v37 + 1; // 0x3a1c0
                        uint32_t v42 = function_1e150(); // 0x3a1c4
                        while (v42 != v41 && v42 >= v41) {
                            // 0x3a1d0
                            v37 = v41;
                            v38 = g289;
                            if (v38 != (char *)3 && v38 >= (char *)3) {
                                // 0x3a1dc
                                v39 = v37 + v36;
                                v40 = *(int32_t *)(a2 + (int32_t)&g371 + 4 * (v39 + 64 * result6));
                                snprintf((char *)&str, 2048, "D[%02d]:%04d ", v39, v40);
                                function_2ea54(3, &str, 0);
                            }
                            // 0x3a1c0
                            v41 = v37 + 1;
                            v42 = function_1e150();
                        }
                    }
                    // 0x3a214
                    if (function_1e150() < 2) {
                        goto lab_0x3a2c0;
                    } else {
                        char * v43 = g289; // 0x3a220
                        if (v43 >= (char *)3 == (v43 != (char *)3)) {
                            int32_t v44 = *(int32_t *)(v35 + 4 * v5); // 0x3a2a0
                            snprintf((char *)&str, 2048, "D_BIG[%02d]:%05d", v5, v44);
                            function_2ea54(3, &str, 0);
                            goto lab_0x3a2c0;
                        } else {
                            goto lab_0x3a22c;
                        }
                    }
                }
            }
          lab_0x3a23c:;
            char * v45 = g289; // 0x3a23c
            if (v45 == (char *)3 || v45 < (char *)3) {
                // 0x3a140
                __asm_vpop(v2);
                return result3;
            }
            // 0x3a248
            str = 2570;
            int32_t result4 = function_2ea54(3, &str, 0); // 0x3a26c
            __asm_vpop(v2);
            return result4;
        }
    }
    // 0x3a138
    if (v3 >= (char *)3 == (v3 != (char *)3)) {
        // 0x3a304
        str = 0x646e6148;
        int32_t result5 = function_2e584(3, &str, 0); // 0x3a32c
        __asm_vpop(v2);
        return result5;
    }
    // 0x3a140
    __asm_vpop(v2);
    return result6;
  lab_0x3a2c0:;
    char * v46 = g289; // 0x3a2c0
    if (v46 != (char *)3 && v46 >= (char *)3) {
        // 0x3a2cc
        str = 10;
        function_2ea54(3, &str, 0);
    }
    goto lab_0x3a22c;
  lab_0x3a22c:;
    int32_t v47 = v5 + 1; // 0x3a22c
    int32_t v48 = function_1e0e0(); // 0x3a230
    v4 = v47;
    result3 = v48;
    if (v48 >= v47 != v48 != v47) {
        // break -> 0x3a23c
        goto lab_0x3a23c;
    }
    goto lab_0x3a19c;
}

// Address range: 0x3a828 - 0x3a86c
int32_t function_3a828(int32_t a1, int32_t a2) {
    // 0x3a828
    float64_t v1; // 0x3a828
    float64_t v2 = __asm_vpush(v1); // 0x3a834
    int32_t v3 = *(int32_t *)(4 * (a1 + (int32_t)&g8 + 0x2800) + a2); // 0x3a838
    float32_t v4 = __asm_vmov_7(v3); // 0x3a83c
    int32_t v5 = function_1e130(); // 0x3a840
    float32_t v6 = __asm_vcvt_f32_u32(v4); // 0x3a848
    int32_t result = function_1e0f0() * 8 * v5; // 0x3a854
    __asm_vdiv_f32(v6, __asm_vcvt_f32_s32(__asm_vmov_7(result)));
    __asm_vpop(v2);
    return result;
}

// Address range: 0x3a86c - 0x3ac6c
int32_t function_3a86c(int32_t * a1) {
    int32_t result2 = (int32_t)a1;
    char * v1 = g289; // 0x3a894
    int32_t str; // bp-2088, 0x3a86c
    if (g96 != 0) {
        // 0x3a8a0
        if (*(int32_t *)(g96 + 4) != 0) {
            if (v1 >= (char *)3 == (v1 != (char *)3)) {
                // 0x3ac28
                str = 0x74746150;
                function_2e584(3, &str, 0);
            }
            // 0x3a8c0
            int32_t v2; // bp-2104, 0x3a86c
            function_302a0(&v2);
            int32_t v3 = function_398bc(); // 0x3a8c8
            function_452d0(function_452b0(v3) | 0x10000);
            *(int32_t *)(g96 + 64) = 1;
            if (*(int32_t *)g96 == 161) {
                // 0x3ac20
                function_3893c(result2);
            } else {
                // 0x3a8f8
                function_389f0(result2);
            }
            int32_t v4 = 0;
            int32_t v5; // 0x3a86c
            int32_t v6; // 0x3a86c
            if (function_1e29c(v4) != 0) {
                // 0x3a91c
                v5 = 3;
                if (*(int32_t *)(4 * v4 + 8 + g96) == 1) {
                    while (function_39584(v4) == 0) {
                        // 0x3aa50
                        v6 = v5;
                        usleep(0x186a0);
                        v5 = v6 - 1;
                        if (v6 == 1) {
                            // break -> 0x3a930
                            break;
                        }
                    }
                }
            }
            int32_t v7 = v4 + 1; // 0x3a930
            while (v7 != 4) {
                // 0x3a90c
                v4 = v7;
                if (function_1e29c(v4) != 0) {
                    // 0x3a91c
                    v5 = 3;
                    if (*(int32_t *)(4 * v4 + 8 + g96) == 1) {
                        while (function_39584(v4) == 0) {
                            // 0x3aa50
                            v6 = v5;
                            usleep(0x186a0);
                            v5 = v6 - 1;
                            if (v6 == 1) {
                                // break -> 0x3a930
                                break;
                            }
                        }
                    }
                }
                // 0x3a930
                v7 = v4 + 1;
            }
            // 0x3a93c
            *(int32_t *)(g96 + 64) = 0;
            int32_t v8 = function_391f4(); // 0x3a964
            int32_t v9 = v8 + (int32_t)&g47;
            int32_t v10 = v8 + (int32_t)&g358 + 0xa010;
            int32_t v11 = v8 + (int32_t)&g358 + 0xa410;
            int32_t v12 = 0;
            int32_t v13; // 0x3a86c
            int32_t v14; // 0x3a86c
            float32_t v15; // 0x3a86c
            int32_t v16; // 0x3a990
            int32_t v17; // 0x3aa60
            int32_t v18; // 0x3ab84
            int32_t v19; // 0x3aa70
            int32_t v20; // 0x3aa7c
            int32_t v21; // 0x3a86c
            int32_t v22; // 0x3ab9c
            int32_t v23; // 0x3aa9c
            int32_t v24; // 0x3aaa4
            int32_t v25; // 0x3ab70
            int32_t * v26; // 0x3a86c
            int32_t v27; // 0x3abac
            int32_t * v28; // 0x3abac
            int32_t v29; // 0x3abb0
            int32_t v30; // 0x3aaec
            int32_t v31; // 0x3aafc
            int32_t v32; // 0x3ab0c
            int32_t v33; // 0x3ab18
            int32_t v34; // 0x3ab18
            int32_t * v35; // 0x3ab3c
            int32_t * v36; // 0x3ab58
            int32_t v37; // 0x3abc0
            if (function_1e29c(v12) != 0) {
                // 0x3a98c
                v16 = 4 * v12;
                if (*(int32_t *)(v16 + 8 + g96) == 1) {
                    // 0x3aa60
                    v17 = function_1e0f0();
                    if (v17 != 0) {
                        // 0x3aa70
                        v19 = 256 * v12;
                        v20 = 64 * v12;
                        v21 = 2304 * v12;
                        v14 = 0;
                        function_1e100();
                        v23 = function_5f880();
                        v24 = function_1e130();
                        if (v24 != 0) {
                            // 0x3aab0
                            v26 = (int32_t *)(v11 + 4 * (v23 + v20));
                            v31 = 0;
                            v33 = v8 + (int32_t)&g48 + 0x1000 * (v14 + v19);
                            v30 = function_1e150();
                            function_1e150();
                            v31++;
                            function_1e130();
                            v32 = function_5f880();
                            v33 += 4;
                            v34 = *(int32_t *)v33;
                            v35 = (int32_t *)(v10 + 4 * (v30 * v23 + v20 + v32));
                            *v35 = *v35 + v34;
                            *v26 = *v26 + v34;
                            v36 = (int32_t *)(4 * (9 * v14 + v21 + v34) + v9);
                            *v36 = *v36 + 1;
                            while (v24 != v31) {
                                // 0x3aaec
                                v30 = function_1e150();
                                function_1e150();
                                v31++;
                                function_1e130();
                                v32 = function_5f880();
                                v33 += 4;
                                v34 = *(int32_t *)v33;
                                v35 = (int32_t *)(v10 + 4 * (v30 * v23 + v20 + v32));
                                *v35 = *v35 + v34;
                                *v26 = *v26 + v34;
                                v36 = (int32_t *)(4 * (9 * v14 + v21 + v34) + v9);
                                *v36 = *v36 + 1;
                            }
                        }
                        // 0x3ab68
                        v25 = v14 + 1;
                        while (v17 != v25) {
                            // 0x3aa8c
                            v14 = v25;
                            function_1e100();
                            v23 = function_5f880();
                            v24 = function_1e130();
                            if (v24 != 0) {
                                // 0x3aab0
                                v26 = (int32_t *)(v11 + 4 * (v23 + v20));
                                v31 = 0;
                                v33 = v8 + (int32_t)&g48 + 0x1000 * (v14 + v19);
                                v30 = function_1e150();
                                function_1e150();
                                v31++;
                                function_1e130();
                                v32 = function_5f880();
                                v33 += 4;
                                v34 = *(int32_t *)v33;
                                v35 = (int32_t *)(v10 + 4 * (v30 * v23 + v20 + v32));
                                *v35 = *v35 + v34;
                                *v26 = *v26 + v34;
                                v36 = (int32_t *)(4 * (9 * v14 + v21 + v34) + v9);
                                *v36 = *v36 + 1;
                                while (v24 != v31) {
                                    // 0x3aaec
                                    v30 = function_1e150();
                                    function_1e150();
                                    v31++;
                                    function_1e130();
                                    v32 = function_5f880();
                                    v33 += 4;
                                    v34 = *(int32_t *)v33;
                                    v35 = (int32_t *)(v10 + 4 * (v30 * v23 + v20 + v32));
                                    *v35 = *v35 + v34;
                                    *v26 = *v26 + v34;
                                    v36 = (int32_t *)(4 * (9 * v14 + v21 + v34) + v9);
                                    *v36 = *v36 + 1;
                                }
                            }
                            // 0x3ab68
                            v25 = v14 + 1;
                        }
                    }
                    // 0x3ab84
                    v18 = function_1e0f0();
                    if (v18 != 0) {
                        // 0x3ab90
                        v22 = 0x2400 * v12 + v9;
                        v37 = v22;
                        v29 = *(int32_t *)v37;
                        v13 = v37;
                        v27 = v13 + 4;
                        v28 = (int32_t *)v27;
                        v29 += *v28;
                        *v28 = v29;
                        while (v13 != v37 + 28) {
                            // 0x3abac
                            v13 = v27;
                            v27 = v13 + 4;
                            v28 = (int32_t *)v27;
                            v29 += *v28;
                            *v28 = v29;
                        }
                        // 0x3abc0
                        v37 += 36;
                        while (v37 != 36 * v18 + v22) {
                            // 0x3aba4
                            v29 = *(int32_t *)v37;
                            v13 = v37;
                            v27 = v13 + 4;
                            v28 = (int32_t *)v27;
                            v29 += *v28;
                            *v28 = v29;
                            while (v13 != v37 + 28) {
                                // 0x3abac
                                v13 = v27;
                                v27 = v13 + 4;
                                v28 = (int32_t *)v27;
                                v29 += *v28;
                                *v28 = v29;
                            }
                            // 0x3abc0
                            v37 += 36;
                        }
                    }
                    // 0x3abcc
                    function_38b6c(v12, v8, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488);
                    __asm_vstr_12(v15, *(int32_t *)(v8 + (int32_t)&g375 + v16));
                }
            }
            int32_t v38 = v12 + 1; // 0x3a9a4
            while (v38 != 4) {
                // 0x3a97c
                v12 = v38;
                if (function_1e29c(v12) != 0) {
                    // 0x3a98c
                    v16 = 4 * v12;
                    if (*(int32_t *)(v16 + 8 + g96) == 1) {
                        // 0x3aa60
                        v17 = function_1e0f0();
                        if (v17 != 0) {
                            // 0x3aa70
                            v19 = 256 * v12;
                            v20 = 64 * v12;
                            v21 = 2304 * v12;
                            v14 = 0;
                            function_1e100();
                            v23 = function_5f880();
                            v24 = function_1e130();
                            if (v24 != 0) {
                                // 0x3aab0
                                v26 = (int32_t *)(v11 + 4 * (v23 + v20));
                                v31 = 0;
                                v33 = v8 + (int32_t)&g48 + 0x1000 * (v14 + v19);
                                v30 = function_1e150();
                                function_1e150();
                                v31++;
                                function_1e130();
                                v32 = function_5f880();
                                v33 += 4;
                                v34 = *(int32_t *)v33;
                                v35 = (int32_t *)(v10 + 4 * (v30 * v23 + v20 + v32));
                                *v35 = *v35 + v34;
                                *v26 = *v26 + v34;
                                v36 = (int32_t *)(4 * (9 * v14 + v21 + v34) + v9);
                                *v36 = *v36 + 1;
                                while (v24 != v31) {
                                    // 0x3aaec
                                    v30 = function_1e150();
                                    function_1e150();
                                    v31++;
                                    function_1e130();
                                    v32 = function_5f880();
                                    v33 += 4;
                                    v34 = *(int32_t *)v33;
                                    v35 = (int32_t *)(v10 + 4 * (v30 * v23 + v20 + v32));
                                    *v35 = *v35 + v34;
                                    *v26 = *v26 + v34;
                                    v36 = (int32_t *)(4 * (9 * v14 + v21 + v34) + v9);
                                    *v36 = *v36 + 1;
                                }
                            }
                            // 0x3ab68
                            v25 = v14 + 1;
                            while (v17 != v25) {
                                // 0x3aa8c
                                v14 = v25;
                                function_1e100();
                                v23 = function_5f880();
                                v24 = function_1e130();
                                if (v24 != 0) {
                                    // 0x3aab0
                                    v26 = (int32_t *)(v11 + 4 * (v23 + v20));
                                    v31 = 0;
                                    v33 = v8 + (int32_t)&g48 + 0x1000 * (v14 + v19);
                                    v30 = function_1e150();
                                    function_1e150();
                                    v31++;
                                    function_1e130();
                                    v32 = function_5f880();
                                    v33 += 4;
                                    v34 = *(int32_t *)v33;
                                    v35 = (int32_t *)(v10 + 4 * (v30 * v23 + v20 + v32));
                                    *v35 = *v35 + v34;
                                    *v26 = *v26 + v34;
                                    v36 = (int32_t *)(4 * (9 * v14 + v21 + v34) + v9);
                                    *v36 = *v36 + 1;
                                    while (v24 != v31) {
                                        // 0x3aaec
                                        v30 = function_1e150();
                                        function_1e150();
                                        v31++;
                                        function_1e130();
                                        v32 = function_5f880();
                                        v33 += 4;
                                        v34 = *(int32_t *)v33;
                                        v35 = (int32_t *)(v10 + 4 * (v30 * v23 + v20 + v32));
                                        *v35 = *v35 + v34;
                                        *v26 = *v26 + v34;
                                        v36 = (int32_t *)(4 * (9 * v14 + v21 + v34) + v9);
                                        *v36 = *v36 + 1;
                                    }
                                }
                                // 0x3ab68
                                v25 = v14 + 1;
                            }
                        }
                        // 0x3ab84
                        v18 = function_1e0f0();
                        if (v18 != 0) {
                            // 0x3ab90
                            v22 = 0x2400 * v12 + v9;
                            v37 = v22;
                            v29 = *(int32_t *)v37;
                            v13 = v37;
                            v27 = v13 + 4;
                            v28 = (int32_t *)v27;
                            v29 += *v28;
                            *v28 = v29;
                            while (v13 != v37 + 28) {
                                // 0x3abac
                                v13 = v27;
                                v27 = v13 + 4;
                                v28 = (int32_t *)v27;
                                v29 += *v28;
                                *v28 = v29;
                            }
                            // 0x3abc0
                            v37 += 36;
                            while (v37 != 36 * v18 + v22) {
                                // 0x3aba4
                                v29 = *(int32_t *)v37;
                                v13 = v37;
                                v27 = v13 + 4;
                                v28 = (int32_t *)v27;
                                v29 += *v28;
                                *v28 = v29;
                                while (v13 != v37 + 28) {
                                    // 0x3abac
                                    v13 = v27;
                                    v27 = v13 + 4;
                                    v28 = (int32_t *)v27;
                                    v29 += *v28;
                                    *v28 = v29;
                                }
                                // 0x3abc0
                                v37 += 36;
                            }
                        }
                        // 0x3abcc
                        function_38b6c(v12, v8, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488);
                        __asm_vstr_12(v15, *(int32_t *)(v8 + (int32_t)&g375 + v16));
                    }
                }
                // 0x3a9a4
                v38 = v12 + 1;
            }
            // 0x3a9b0
            function_302a0((int32_t *)((int32_t)&str - 8));
            char * v39 = g289; // 0x3a9e0
            if (v39 >= (char *)3 != v39 != (char *)3) {
                // 0x3a9ec
                int32_t result; // 0x3a86c
                return result;
            }
            // 0x3abec
            int32_t v40; // 0x3a86c
            snprintf((char *)&str, 2048, "Pattern test done, time cost %lds\n", v40 + (int32_t)false - v2);
            return function_2e584(3, &str, 0);
        }
    }
    // 0x3a9f8
    if (v1 == (char *)3 || v1 < (char *)3) {
        // 0x3a9ec
        return result2;
    }
    // 0x3aa00
    str = 0x646e6148;
    return function_2e584(3, &str, 0);
}

// Address range: 0x3ac6c - 0x3ac94
int32_t function_3ac6c(void) {
    int32_t v1 = function_19ab4(); // 0x3ac70
    int32_t v2 = function_361f4(); // 0x3ac78
    if (v1 == v2) {
        // 0x3ac8c
        return 0;
    }
    // 0x3ac84
    return function_36208(v2);
}

// Address range: 0x3ac94 - 0x3adcc
int32_t function_3ac94(void) {
    char * v1 = g289; // 0x3aca8
    int32_t v2 = (int32_t)v1; // 0x3acb0
    int32_t v3; // 0x3ac94
    char * v4; // bp-2072, 0x3ac94
    if (v1 >= (char *)4 == (v1 != (char *)4)) {
        // 0x3acd8
        v4 = (char *)0x4245445b;
        function_2e584(4, (int32_t *)&v4, 0);
        char * v5 = g289; // 0x3ad0c
        v3 = 0;
        v2 = (int32_t)v5;
        if (v5 != (char *)4 && v5 >= (char *)4) {
            // 0x3ad18
            v4 = (char *)0x4245445b;
            function_2e584(4, (int32_t *)&v4, 0);
            v3 = 0;
            v2 = &g462;
        }
    }
    // 0x3acb4
    if (g97 != 0) {
        // 0x3accc
        return 0;
    }
    int32_t v6 = function_11eb0(52, 1, v3, v2); // 0x3ad58
    g97 = v6;
    if (v6 != 0) {
        // 0x3accc
        return 0;
    }
    // 0x3ad6c
    function_356c4(13, 255);
    char * v7 = g289; // 0x3ad78
    if (v7 != (char *)3 && v7 >= (char *)3) {
        // 0x3ad88
        v4 = (char *)0x6c696146;
        function_2e584(3, (int32_t *)&v4, 0);
    }
    // 0x3accc
    return -1;
}

// Address range: 0x3adcc - 0x3ae88
int32_t function_3adcc(void) {
    char * v1 = g289; // 0x3addc
    int32_t v2 = (int32_t)v1; // 0x3ade4
    int32_t v3; // 0x3adcc
    int32_t v4; // 0x3adcc
    if (v1 >= (char *)4 == (v1 != (char *)4)) {
        char * v5 = (char *)0x4245445b; // bp-2056, 0x3ae20
        int32_t v6 = (int32_t)&v5; // 0x3ae30
        function_2e584(4, (int32_t *)&v5, 0);
        char * v7 = g289; // 0x3ae44
        v3 = v6;
        v4 = 0;
        v2 = (int32_t)v7;
        if (v7 != (char *)4 && v7 >= (char *)4) {
            // 0x3ae50
            v5 = (char *)0x4245445b;
            function_2e584(4, (int32_t *)&v5, 0);
            v3 = v6;
            v4 = 0;
            v2 = 0x6e757420;
        }
    }
    int32_t result = 0; // 0x3adf8
    if (g97 != 0) {
        // 0x3adfc
        result = free(g97, v3, v4, v2);
        g97 = 0;
    }
    // 0x3ae08
    return result;
}

// Address range: 0x3ae88 - 0x3aea0
int32_t function_3ae88(int32_t a1) {
    // 0x3ae88
    return *(int32_t *)(4 * a1 + 20 + g97);
}

// Address range: 0x3aea0 - 0x3af04
int32_t function_3aea0(int32_t a1) {
    char * v1 = g289; // 0x3aeb4
    if (v1 != (char *)4 && v1 >= (char *)4) {
        // 0x3aec0
        int32_t str; // bp-2056, 0x3aea0
        snprintf((char *)&str, 2048, "[DEBUG] Get freq result, chain = %d.\n", a1);
        function_2e584(4, &str, 0);
    }
    // 0x3aee8
    return *(int32_t *)(4 * a1 + 4 + g97);
}

// Address range: 0x3af04 - 0x3af1c
int32_t function_3af04(int32_t a1) {
    int32_t result = g97 + 4 * a1; // 0x3af10
    __asm_vldr_8(*(int32_t *)(result + 36));
    return result;
}

// Address range: 0x3af1c - 0x3b224
int32_t function_3af1c(void) {
    char * v1 = g289; // 0x3af30
    if (v1 >= (char *)3 != v1 != (char *)3) {
        // 0x3af3c
        int32_t result; // 0x3af1c
        return result;
    }
    int32_t v2 = *(int32_t *)g97; // 0x3af6c
    int32_t str; // bp-2072, 0x3af1c
    snprintf((char *)&str, 2048, "%-40s : %d\n", "voltage", *(int32_t *)v2);
    int32_t v3 = function_2ea54(3, &str, 0); // 0x3af88
    char * v4 = g289; // 0x3af8c
    char * v5 = v4; // 0x3af94
    int32_t result4 = v3; // 0x3af94
    char * v6; // 0x3af1c
    int32_t result6; // 0x3af1c
    if (v4 == (char *)3 || v4 < (char *)3) {
        goto lab_0x3b0ac;
    } else {
        int32_t v7 = *(int32_t *)(*(int32_t *)g97 + 4); // 0x3afb8
        snprintf((char *)&str, 2048, "%-40s : %d\n", "freq_base", v7);
        int32_t result2 = function_2ea54(3, &str, 0); // 0x3afd0
        char * v8 = g289; // 0x3afd4
        if (v8 == (char *)3 || v8 < (char *)3) {
            // 0x3af3c
            return result2;
        }
        int32_t v9 = *(int32_t *)(*(int32_t *)g97 + 8); // 0x3b000
        snprintf((char *)&str, 2048, "%-40s : %d\n", "freq_threshold", v9);
        int32_t v10 = function_2ea54(3, &str, 0); // 0x3b018
        char * v11 = g289; // 0x3b01c
        v6 = v11;
        result6 = v10;
        if (v11 == (char *)3 || v11 < (char *)3) {
            goto lab_0x3b160;
        } else {
            int32_t v12 = *(int32_t *)(*(int32_t *)g97 + 12); // 0x3b048
            snprintf((char *)&str, 2048, "%-40s : %d\n", "freq_serial_threshold", v12);
            int32_t result3 = function_2ea54(3, &str, 0); // 0x3b060
            char * v13 = g289; // 0x3b064
            if (v13 == (char *)3 || v13 < (char *)3) {
                // 0x3af3c
                return result3;
            }
            int32_t v14 = *(int32_t *)(*(int32_t *)g97 + 16); // 0x3b090
            snprintf((char *)&str, 2048, "%-40s : %d\n", "freq_step", v14);
            result4 = function_2ea54(3, &str, 0);
            v5 = g289;
            goto lab_0x3b0ac;
        }
    }
  lab_0x3b0ac:;
    char * v15 = v5; // 0x3b0ac
    if (v15 == (char *)3 || v15 < (char *)3) {
        // 0x3af3c
        return result4;
    }
    char * v16 = *(char *)(*(int32_t *)g97 + 20) == 0 ? "false" : "true"; // 0x3b0f8
    snprintf((char *)&str, 2048, "%-40s : %s\n", "is_inc_freq_with_high_vol", v16);
    int32_t result5 = function_2ea54(3, &str, 0); // 0x3b10c
    char * v17 = g289; // 0x3b110
    if (v17 == (char *)3 || v17 < (char *)3) {
        // 0x3af3c
        return result5;
    }
    char * v18 = *(char *)(*(int32_t *)g97 + 21) == 0 ? "false" : "true"; // 0x3b148
    snprintf((char *)&str, 2048, "%-40s : %s\n", "is_inc_freq_with_high_vol_runtime", v18);
    int32_t v19 = function_2ea54(3, &str, 0); // 0x3b15c
    v6 = g289;
    result6 = v19;
    goto lab_0x3b160;
  lab_0x3b160:;
    char * v20 = v6; // 0x3b160
    if (v20 == (char *)3 || v20 < (char *)3) {
        // 0x3af3c
        return result6;
    }
    int32_t v21 = *(int32_t *)(*(int32_t *)g97 + 24); // 0x3b18c
    snprintf((char *)&str, 2048, "%-40s : %d\n", "is_board_init_with_power_off", v21);
    int32_t result7 = function_2ea54(3, &str, 0); // 0x3b1a4
    char * v22 = g289; // 0x3b1a8
    if (v22 == (char *)3 || v22 < (char *)3) {
        // 0x3af3c
        return result7;
    }
    // 0x3b1b4
    __asm_vldr_8(*(int32_t *)(*(int32_t *)g97 + 28));
    return &str;
}

// Address range: 0x3b226 - 0x3b22a
int32_t function_3b226(void) {
    // 0x3b226
    int32_t result; // 0x3b226
    bool v1; // 0x3b226
    if (!v1) {
        result = function_76d0a();
    }
    // 0x3b22a
    return result;
}

// Address range: 0x3b22c - 0x3b270
int32_t function_3b22c(void) {
    // 0x3b22c
    int32_t str; // 0x3b22c
    snprintf((char *)str, str, (char *)str);
    int32_t v1; // 0x3b22c
    function_2ea54(3, &v1, 0);
    __asm_vldr_8(*(int32_t *)(str + 36));
    return &v1;
}

// Address range: 0x3b272 - 0x3b2c4
int32_t function_3b272(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = a1; // 0x3b272
    bool v2; // 0x3b272
    if (!v2) {
        v1 = function_76d56();
    }
    // 0x3b276
    if (!v2) {
        __asm_stcpl_21(13, 14, v1, -564);
    }
    bool v3; // 0x3b272
    bool v4; // 0x3b272
    int32_t v5; // 0x3b272
    int32_t v6; // 0x3b272
    if (v2) {
        // .thread
        goto lab_dec_label_pc_unknown_27;
    } else {
        *(int32_t *)v6 = 0x3b276;
        *(int32_t *)(v6 + 4) = 0x3b280;
        // 0x3b28e
        __asm_ldclgt(3, 14, *(int32_t *)(a2 + 640));
        v3 = (v6 & 0x8000000) != 0;
        v5 = v1;
        v4 = v2 == ((v6 & 0x8000000) != 0);
        goto lab_dec_label_pc_unknown_28;
    }
  lab_dec_label_pc_unknown_27:;
    bool v7 = (v6 & 0x8000000) != 0;
    v3 = v7;
    v5 = function_f628e();
    v4 = v7;
    goto lab_dec_label_pc_unknown_28;
  lab_dec_label_pc_unknown_28:;
    bool v8; // 0x3b272
    bool v9; // 0x3b272
    bool v10; // 0x3b272
    bool v11; // 0x3b272
    bool v12; // 0x3b272
    bool v13; // 0x3b272
    bool v14; // 0x3b272
    bool v15; // 0x3b272
    bool v16; // 0x3b272
    bool v17; // 0x3b272
    if (v4 == !v2) {
        uint32_t v18 = v5;
        uint32_t v19 = 32 * v6; // 0x3b292
        uint32_t v20 = v19 - v18; // 0x3b292
        int32_t v21 = !v3; // 0x3b292
        int32_t v22 = v20 - v21; // 0x3b292
        uint32_t v23 = v22 - v21; // 0x3b292
        bool v24 = !v3 ? v18 != -1 | v19 < v23 : v19 < v18; // 0x3b292
        v15 = ((v23 ^ v19) & (v18 ^ v19)) < 0;
        v13 = !v24;
        v17 = v22 == 0;
        v11 = v20 % 2 != 0;
        v9 = !v3;
        v14 = ((v23 ^ v19) & (v18 ^ v19)) < 0;
        v12 = !v24;
        v16 = v22 == 0;
        v10 = v20 % 2 != 0;
        v8 = !v3;
        if (v22 < 0) {
            goto lab_dec_label_pc_unknown_30;
        } else {
            goto lab_dec_label_pc_unknown_31;
        }
    } else {
        v13 = v4;
        v12 = v4;
        if (v2) {
            goto lab_dec_label_pc_unknown_30;
        } else {
            goto lab_dec_label_pc_unknown_31;
        }
    }
  lab_dec_label_pc_unknown_30:
    __asm_svcmi(0xf0e8bd);
    bool v25 = v9; // 0x3b29a
    bool v26 = v11; // 0x3b29a
    bool v27 = v17; // 0x3b29a
    bool v28 = v13; // 0x3b29a
    bool v29 = v9; // 0x3b29a
    bool v30 = v11; // 0x3b29a
    bool v31 = v17; // 0x3b29a
    bool v32 = v13; // 0x3b29a
    bool v33 = true; // 0x3b29a
    if (v15) {
        goto lab_0x3b29e;
    } else {
        goto lab_dec_label_pc_unknown_32;
    }
  lab_dec_label_pc_unknown_31:
    v25 = v8;
    v26 = v10;
    v27 = v16;
    v28 = v12;
    v29 = v8;
    v30 = v10;
    v31 = v16;
    v32 = v12;
    v33 = true;
    if (v14) {
        goto lab_0x3b29e;
    } else {
        goto lab_dec_label_pc_unknown_32;
    }
  lab_0x3b29e:
    // 0x3b29e
    if (v32 == v33 == !v31) {
        function_173faa();
    }
    if (v30 <= v29) {
        __asm_cdple(13, 9, 14, 5, 13, 1);
    }
    if (v31) {
        __asm_qsubeq(a4, v6);
    }
    if (v33) {
        function_105dac6();
    }
    // 0x3b2c2
    return function_3c4ae();
  lab_dec_label_pc_unknown_32:
    function_fe775756();
    v29 = v25;
    v30 = v26;
    v31 = v27;
    v32 = v28;
    v33 = false;
    goto lab_0x3b29e;
}

// Address range: 0x3b2c4 - 0x3b8a0
int32_t function_3b2c4(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11, int32_t a12) {
    // 0x3b2c4
    int32_t v1; // 0x3b2c4
    uint32_t v2 = v1;
    int32_t * v3 = (int32_t *)(v1 % 0x10000 | (int32_t)&g85); // 0x3b2d0
    memset((int32_t *)(*v3 + 4), 0, 48);
    function_39a7c();
    function_361e4(*(int32_t *)*(int32_t *)*v3);
    int32_t result = function_3ac6c(); // 0x3b2f4
    if (result != 0) {
        // 0x3b300
        float64_t v4; // 0x3b2c4
        __asm_vpop_13(v4, v4);
        return result;
    }
    int32_t v5 = *(int32_t *)*v3; // 0x3b328
    float32_t v6 = __asm_vldr_8(*(int32_t *)(v5 + 4)); // 0x3b330
    unsigned char v7 = *(char *)(v5 + 20); // 0x3b334
    __asm_vcvt_f32_u32(v6);
    function_1a470(255, (int32_t)g66, (int32_t)v7, v5, (int32_t)&g488);
    char * str; // bp+344, 0x3b2c4
    if (v2 >= 3 == (v2 != 3)) {
        // 0x3b7f0
        str = (char *)10;
        function_2ea54(3, (int32_t *)&str, 0);
        if (v2 != 3 && v2 >= 3) {
            // 0x3b818
            str = (char *)0x3e3e3e3e;
            function_2e584(3, (int32_t *)&str, 0);
        }
    }
    int32_t v8 = 0;
    if (function_1e29c(v8) != 0) {
        // 0x3b750
        function_3962c(v8, 1);
    }
    int32_t v9 = v8 + 1; // 0x3b360
    while (v9 != 4) {
        // 0x3b350
        v8 = v9;
        if (function_1e29c(v8) != 0) {
            // 0x3b750
            function_3962c(v8, 1);
        }
        // 0x3b360
        v9 = v8 + 1;
    }
    int32_t v10 = *(int32_t *)*v3; // 0x3b374
    int32_t v11 = *(int32_t *)(v10 + 4); // 0x3b37c
    int32_t v12 = *(int32_t *)(v10 + 16); // 0x3b380
    uint32_t v13 = *(int32_t *)(v10 + 12); // 0x3b384
    if (v2 >= 3 == (v2 != 3)) {
        // 0x3b7b4
        snprintf((char *)&str, 2048, "freq_prev = %d, freq_start = %d, freq_step = %d, freq_min = %d\n", v11, v11, v12, v13);
        function_2e584(3, (int32_t *)&str, 0);
    }
    int32_t v14 = v11; // bp+40, 0x3b398
    if (v11 < v13) {
        // 0x3b4e0
        __asm_vmov_f32(5.0f);
        return 0;
    }
    bool v15 = v2 == 3 | v2 < 3;
    int32_t v16 = 0; // 0x3b2c4
    int32_t v17 = v11; // 0x3b3f8
    int32_t v18; // 0x3b2c4
    while (true) {
      lab_0x3b3c0:
        // 0x3b3c0
        v18 = v17;
        if (v2 >= 3 == (v2 != 3)) {
            // 0x3b6a8
            str = (char *)10;
            function_2ea54(3, (int32_t *)&str, 0);
            if (v15) {
                goto lab_0x3b3cc;
            } else {
                // 0x3b6d0
                snprintf((char *)&str, 2048, ">>>> freq_curr = %d\n", v14);
                function_2e584(3, (int32_t *)&str, 0);
                if (function_39998() == 0) {
                    goto lab_0x3b718;
                }
                goto lab_0x3b3d8;
            }
        } else {
            goto lab_0x3b3cc;
        }
    }
  lab_0x3b704:
    if (v15) {
        // 0x3b4e0
        __asm_vmov_f32(5.0f);
        return 0;
    }
  lab_0x3b718:
    // 0x3b718
    str = (char *)0x206c6c41;
    function_2e584(3, (int32_t *)&str, 0);
    // 0x3b4e0
    __asm_vmov_f32(5.0f);
    return 0;
  lab_0x3b458:;
    // 0x3b458
    int32_t v19; // 0x3b2c4
    int32_t v20 = v19;
    int32_t v21; // 0x3b2c4
    float32_t v22; // 0x3b644
    int32_t v23; // 0x3b648
    if (function_1e29c(v20) == 0) {
        goto lab_0x3b468;
    } else {
        // 0x3b61c
        if (function_397a0(v20) == 1) {
            int32_t v24 = *(int32_t *)*v3; // 0x3b638
            __asm_vldr_8(*(int32_t *)(v24 + 36));
            __asm_vldr_8(*(int32_t *)(v24 + 32));
            v22 = __asm_vldr_8(*(int32_t *)(v24 + 28));
            v23 = function_39b60(v20);
            if (v23 == 0) {
                int32_t v25 = 4 * v20;
                *(int32_t *)(v25 + 20 + *v3) = 1;
                v21 = v25;
                goto lab_0x3b660;
            } else {
                // 0x3b79c
                function_3962c(v20, 2);
                v21 = 4 * v20;
                goto lab_0x3b660;
            }
        } else {
            goto lab_0x3b468;
        }
    }
  lab_0x3b3cc:
    // 0x3b3cc
    if (function_39998() == 0) {
        // break -> 0x3b704
        goto lab_0x3b704;
    }
    goto lab_0x3b3d8;
  lab_0x3b3d8:;
    int32_t v26 = 0;
    float32_t v27; // 0x3b5fc
    unsigned char v28; // 0x3b600
    if (function_1e29c(v26) != 0) {
        // 0x3b5cc
        if (function_397a0(v26) == 1) {
            // 0x3b5dc
            v27 = __asm_vldr_8(g296);
            v28 = *(char *)(*(int32_t *)*v3 + 21);
            __asm_vcvt_f32_s32(v27);
            function_1aae4(v26, (int32_t)g66, v18, v14, (int32_t)v28);
        }
    }
    int32_t v29 = v26 + 1; // 0x3b3ec
    while (v29 != 4) {
        // 0x3b3dc
        v26 = v29;
        if (function_1e29c(v26) != 0) {
            // 0x3b5cc
            if (function_397a0(v26) == 1) {
                // 0x3b5dc
                v27 = __asm_vldr_8(g296);
                v28 = *(char *)(*(int32_t *)*v3 + 21);
                __asm_vcvt_f32_s32(v27);
                function_1aae4(v26, (int32_t)g66, v18, v14, (int32_t)v28);
            }
        }
        // 0x3b3ec
        v29 = v26 + 1;
    }
    // 0x3b3f8
    v17 = v14;
    if (function_3ac6c() != 0) {
        if (v15) {
            goto lab_0x3b4e0;
        } else {
            // 0x3b858
            str = (char *)0x20746553;
            function_2e584(3, (int32_t *)&str, 0);
            goto lab_0x3b4e0;
        }
    }
    // 0x3b408
    function_321b8(v14, g283, 20);
    function_3a86c(&v14);
    int32_t v30 = function_391f4(); // 0x3b430
    int32_t v31 = 0; // 0x3b434
    while (true) {
        int32_t v32 = v31;
        if (function_1e29c(v32) != 0) {
            // 0x3b688
            if (function_397a0(v32) == 1) {
                // 0x3b698
                function_3a054(v32, v30);
            }
        }
        int32_t v33 = v32 + 1; // 0x3b448
        v31 = v33;
        v19 = 0;
        if (v33 == 4) {
            goto lab_0x3b458;
        }
    }
    goto lab_0x3b474;
  lab_0x3b474:;
    // 0x3b474
    int32_t v34; // bp+44, 0x3b2c4
    int32_t * v35 = (int32_t *)(4 * v16 + (int32_t)&v34);
    int32_t v36 = 0; // 0x3b488
    int32_t v37 = v30 + (int32_t)&g375;
    int32_t v38; // bp+104, 0x3b2c4
    int32_t v39 = 16 * v16 + (int32_t)&v38;
    if (function_1e29c(v36) != 0) {
        *(int32_t *)v39 = *(int32_t *)v37;
        *v35 = v14;
    }
    int32_t v40 = v36 + 1; // 0x3b498
    v36 = v40;
    int32_t v41 = v39 + 4; // 0x3b4b8
    int32_t v42 = v37 + 4; // 0x3b4b8
    while (v40 != 4) {
        // 0x3b48c
        v37 = v42;
        v39 = v41;
        if (function_1e29c(v36) != 0) {
            *(int32_t *)v39 = *(int32_t *)v37;
            *v35 = v14;
        }
        // .critedge
        v40 = v36 + 1;
        v36 = v40;
        v41 = v39 + 4;
        v42 = v37 + 4;
    }
    int32_t v43 = v14 - v12; // 0x3b4c8
    v14 = v43;
    v16++;
    if (v13 != v43 && v13 >= v43) {
      lab_0x3b4e0:
        // 0x3b4e0
        __asm_vmov_f32(5.0f);
        return 0;
    }
    goto lab_0x3b3c0;
  lab_0x3b468:;
    int32_t v44 = v20 + 1; // 0x3b468
    v19 = v44;
    if (v44 == 4) {
        goto lab_0x3b474;
    } else {
        goto lab_0x3b458;
    }
  lab_0x3b660:
    // 0x3b660
    function_3a828(v20, v30);
    int32_t * v45 = (int32_t *)(v21 + 36 + *v3); // 0x3b674
    __asm_vcmpe_f32(v22, __asm_vldr_8(*v45));
    __asm_vmrs(v1, v1);
    if (v23 > 0) {
        __asm_vstrgt(v22, *v45);
        goto lab_0x3b468;
    } else {
        goto lab_0x3b468;
    }
}

// Address range: 0x3b8a0 - 0x3b8dc
int32_t function_3b8a0(int32_t a1, int32_t a2) {
    int32_t v1 = function_1e0f0(); // 0x3b8b4
    int32_t result = v1; // 0x3b8c0
    if (v1 == 0) {
        result = function_3b8e8((int32_t)&g488, (int32_t)&g488);
    }
    // 0x3b8c4
    return result;
}

// Address range: 0x3b8de - 0x3b8e0
int32_t function_3b8de(void) {
    // 0x3b8de
    return function_3c4ae();
}

// Address range: 0x3b8e0 - 0x3b8e8
int32_t function_3b8e0(int32_t result, int32_t a2, int32_t a3) {
    // 0x3b8e0
    return result;
}

// Address range: 0x3b8e8 - 0x3b94c
int32_t function_3b8e8(int32_t a1, int32_t a2) {
    // 0x3b8e8
    function_1e0f0();
    int32_t result = function_5f880(); // 0x3b8f4
    char * v1 = g289; // 0x3b904
    if (v1 != (char *)4 && v1 >= (char *)4) {
        // 0x3b910
        int32_t str; // 0x3b8e8
        int32_t v2; // 0x3b8e8
        snprintf((char *)&str, 2048, "chain = %d, freq_avg = %d\n", v2, result);
        function_2e584(4, &str, 0);
    }
    // 0x3b93c
    return result;
}

// Address range: 0x3b94c - 0x3ba18
int32_t function_3b94c(int32_t a1, int32_t a2) {
    int32_t v1 = 0xffffff;
    int32_t v2 = 0;
    int32_t v3 = v1; // 0x3b974
    uint32_t v4; // 0x3b94c
    int32_t v5; // 0x3b94c
    int32_t v6; // 0x3b9e8
    int32_t v7; // 0x3b9fc
    uint32_t v8; // 0x3b9fc
    int32_t v9; // 0x3ba00
    if ((a1 == 255 || v2 == a1) == (function_1e29c(v2) != 0)) {
        // 0x3b9e8
        v6 = function_1e0f0();
        v3 = v1;
        if (v6 != 0) {
            // 0x3b9f4
            v7 = a2 - 4 + 1024 * v2;
            v9 = 0;
            v4 = v1;
            v7 += 4;
            v8 = *(int32_t *)v7;
            v9++;
            v5 = v4 < v8 ? v4 : v8;
            v3 = v5;
            while (v6 != v9) {
                // 0x3b9fc
                v4 = v5;
                v7 += 4;
                v8 = *(int32_t *)v7;
                v9++;
                v5 = v4 < v8 ? v4 : v8;
                v3 = v5;
            }
        }
    }
    int32_t result = v3;
    int32_t v10 = v2 + 1; // 0x3b98c
    while (v10 != 4) {
        // 0x3b968
        v1 = result;
        v2 = v10;
        v3 = v1;
        if ((a1 == 255 || v2 == a1) == (function_1e29c(v2) != 0)) {
            // 0x3b9e8
            v6 = function_1e0f0();
            v3 = v1;
            if (v6 != 0) {
                // 0x3b9f4
                v7 = a2 - 4 + 1024 * v2;
                v9 = 0;
                v4 = v1;
                v7 += 4;
                v8 = *(int32_t *)v7;
                v9++;
                v5 = v4 < v8 ? v4 : v8;
                v3 = v5;
                while (v6 != v9) {
                    // 0x3b9fc
                    v4 = v5;
                    v7 += 4;
                    v8 = *(int32_t *)v7;
                    v9++;
                    v5 = v4 < v8 ? v4 : v8;
                    v3 = v5;
                }
            }
        }
        // 0x3b98c
        result = v3;
        v10 = v2 + 1;
    }
    char * v11 = g289; // 0x3b9a0
    if (v11 != (char *)4 && v11 >= (char *)4) {
        // 0x3b9ac
        int32_t str; // bp-2072, 0x3b94c
        snprintf((char *)&str, 2048, "chain = %d, freq_min = %d\n", a1, result);
        function_2e584(4, &str, 0);
    }
    // 0x3b9d8
    return result;
}

// Address range: 0x3ba18 - 0x3ba5c
int32_t function_3ba18(int32_t a1, int32_t a2) {
    int32_t v1 = function_1e29c(0); // 0x3ba38
    if (v1 == 0) {
        // 0x3ba58
        return 0;
    }
    int32_t result = v1; // 0x3ba18
    switch (a1) {
        case 255: {
        }
        case 0: {
            result = function_3bab4();
            // break -> 0x3ba58
            break;
        }
    }
    // 0x3ba58
    return result;
}

// Address range: 0x3ba5c - 0x3ba60
int32_t function_3ba5c(int32_t a1) {
    // 0x3ba5c
    return function_3c10a();
}

// Address range: 0x3ba60 - 0x3bab4
int32_t function_3ba60(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    char * v1 = g289; // 0x3ba6c
    int32_t result; // 0x3ba60
    if (v1 != (char *)4 && v1 >= (char *)4) {
        // 0x3ba78
        int32_t str; // 0x3ba60
        snprintf((char *)&str, 2048, "chain = %d, freq_max = %d\n", result, result);
        function_2e584(result, &str, 0);
    }
    // 0x3baa4
    return result;
}

// Address range: 0x3bab4 - 0x3bae4
int32_t function_3bab4(void) {
    // 0x3bab4
    return function_1e0f0();
}

// Address range: 0x3bae4 - 0x3bb80
int32_t function_3bae4(int32_t a1) {
    uint32_t v1 = function_3b8a0(a1, g98 + 4); // 0x3bb00
    function_3b94c(a1, g98 + 4);
    function_3ba18(a1, g98 + 4);
    int32_t result = function_3ba18(a1, g98 + 0x1014); // 0x3bb40
    uint32_t v2 = *(int32_t *)(*(int32_t *)g98 + 20); // 0x3bb4c
    if (v2 >= v1 == (v2 != v1)) {
        // 0x3bb6c
        return result;
    }
    char * v3 = g289; // 0x3bb60
    if (v3 >= (char *)3 == (v3 != (char *)3)) {
        function_3bc0c(result, v2, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488);
    }
    // 0x3bb6c
    return 1;
}

// Address range: 0x3bb82 - 0x3bb84
int32_t function_3bb82(void) {
    // 0x3bb82
    return function_3c4ae();
}

// Address range: 0x3bb84 - 0x3bc0c
int32_t function_3bb84(uint32_t a1, uint32_t a2, int32_t a3, int32_t a4) {
    // 0x3bb84
    int32_t str; // bp+16, 0x3bb84
    bool v1; // 0x3bb84
    int32_t v2; // 0x3bb84
    if (v1 != !v1) {
        int32_t chars_printed = snprintf((char *)&str, 2048, "chain = %d, freq_max = %d, freq_min = %d, freq_diff = %d, freq_diff_threshold = %d, freq diff enough\n", v2, v2, v2, a4, a3); // 0x3bbc0
        return chars_printed;
    }
    int32_t v3 = a2 < a1 ? a1 : 0;
    int32_t chars_printed2 = snprintf((char *)&str, 2048, "chain = %d, freq_max_runtime = %d, freq_threshold = %d, max freq enough\n", v2, v3, a2); // 0x3bc04
    return chars_printed2;
}

// Address range: 0x3bc0c - 0x3bc48
int32_t function_3bc0c(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    // 0x3bc0c
    int32_t str; // bp+16, 0x3bc0c
    int32_t v1; // 0x3bc0c
    snprintf((char *)&str, 2048, "chain = %d, freq_avg = %d, freq_threshold = %d, avg freq enough\n", v1, v1, a2);
    function_2e584(3, &str, 0);
    return 1;
}

// Address range: 0x3bc48 - 0x3be08
int32_t function_3bc48(int32_t a1, int32_t a2) {
    char * v1 = g289; // 0x3bc60
    int32_t str; // bp-2088, 0x3bc48
    if (v1 >= (char *)4 == (v1 != (char *)4)) {
        // 0x3bddc
        snprintf((char *)&str, 2048, "[DEBUG] Dump freq table, chain = %d.\n", a1);
        function_2e584(4, &str, 0);
    }
    int32_t v2 = 0;
    int32_t v3 = function_1e29c(v2); // 0x3bc88
    int32_t result = 0; // 0x3bc90
    int32_t v4; // 0x3bc48
    int32_t v5; // 0x3bc48
    int32_t v6; // 0x3bc48
    int32_t v7; // 0x3bc48
    int32_t v8; // 0x3bc48
    int32_t v9; // 0x3bc48
    int32_t v10; // 0x3bc48
    int32_t v11; // 0x3bc48
    uint32_t v12; // 0x3bc48
    int32_t v13; // 0x3bc48
    int32_t v14; // 0x3bcd4
    int32_t v15; // 0x3bcd8
    int32_t v16; // 0x3bce4
    char * v17; // 0x3bcec
    int32_t v18; // 0x3bcec
    int32_t v19; // 0x3bd0c
    char * v20; // 0x3bd38
    int32_t v21; // 0x3bd38
    char * v22; // 0x3bca8
    int32_t v23; // 0x3bcb4
    int32_t v24; // 0x3bcbc
    int32_t v25; // 0x3bccc
    if (v3 != 0) {
        // 0x3bc94
        result = v3;
        if (a1 == 255 || v2 == a1) {
            // 0x3bca8
            v22 = g289;
            if (v22 >= (char *)3 == (v22 != (char *)3)) {
                // 0x3bdb0
                snprintf((char *)&str, 2048, "chain = %d\n", v2);
                function_2ea54(3, &str, (int32_t)!((a1 == 255 | v2 == a1)));
            }
            // 0x3bcb4
            v23 = function_1e0f0();
            v24 = (int32_t)g289;
            v5 = 0;
            v11 = v24;
            if (v23 != 0) {
                // 0x3bcc4
                v25 = 1024 * v2 + a2;
                v13 = 0;
                v10 = v24;
                v6 = a2;
                v7 = v10;
                if (v10 != 3 && v10 >= 3) {
                    // 0x3bd0c
                    v19 = *(int32_t *)(v25 + 4 * v13);
                    snprintf((char *)&str, 2048, "[%3d]:%-3d", v13, v19);
                    function_2ea54(3, &str, 0);
                    v20 = g289;
                    v21 = (int32_t)v20;
                    v6 = 0;
                    v7 = v21;
                    if (v20 != (char *)3 && v20 >= (char *)3) {
                        // 0x3bd50
                        str = &g9;
                        function_2ea54(3, &str, 0);
                        v6 = 0;
                        v7 = v21;
                    }
                }
                // 0x3bcd4
                v14 = v13 + 1;
                v15 = function_1e100();
                v16 = function_5fadc(v14, v15, v6, v7);
                v17 = g289;
                v18 = (int32_t)v17;
                v4 = v16;
                v8 = v18;
                if (v15 == 0) {
                    // 0x3bcf4
                    v4 = v16;
                    v8 = v18;
                    if (v17 >= (char *)3 == (v17 != (char *)3)) {
                        // 0x3bd94
                        str = 10;
                        v4 = function_2ea54(3, &str, 0);
                        v8 = (int32_t)g289;
                    }
                }
                // 0x3bcfc
                v9 = v8;
                v5 = v4;
                v11 = v9;
                while (v23 != v14) {
                    // 0x3bd04
                    v13 = v14;
                    v10 = v9;
                    v6 = v15;
                    v7 = v10;
                    if (v10 != 3 && v10 >= 3) {
                        // 0x3bd0c
                        v19 = *(int32_t *)(v25 + 4 * v13);
                        snprintf((char *)&str, 2048, "[%3d]:%-3d", v13, v19);
                        function_2ea54(3, &str, 0);
                        v20 = g289;
                        v21 = (int32_t)v20;
                        v6 = 0;
                        v7 = v21;
                        if (v20 != (char *)3 && v20 >= (char *)3) {
                            // 0x3bd50
                            str = &g9;
                            function_2ea54(3, &str, 0);
                            v6 = 0;
                            v7 = v21;
                        }
                    }
                    // 0x3bcd4
                    v14 = v13 + 1;
                    v15 = function_1e100();
                    v16 = function_5fadc(v14, v15, v6, v7);
                    v17 = g289;
                    v18 = (int32_t)v17;
                    v4 = v16;
                    v8 = v18;
                    if (v15 == 0) {
                        // 0x3bcf4
                        v4 = v16;
                        v8 = v18;
                        if (v17 >= (char *)3 == (v17 != (char *)3)) {
                            // 0x3bd94
                            str = 10;
                            v4 = function_2ea54(3, &str, 0);
                            v8 = (int32_t)g289;
                        }
                    }
                    // 0x3bcfc
                    v9 = v8;
                    v5 = v4;
                    v11 = v9;
                }
            }
            // 0x3bd5c
            v12 = v11;
            result = v5;
            if (v12 != 3 && v12 >= 3) {
                // 0x3bd64
                str = 10;
                result = function_2ea54(3, &str, 0);
            }
        }
    }
    int32_t v26 = v2 + 1; // 0x3bd7c
    while (v26 != 4) {
        // 0x3bc84
        v2 = v26;
        v3 = function_1e29c(v2);
        result = 0;
        if (v3 != 0) {
            // 0x3bc94
            result = v3;
            if (a1 == 255 || v2 == a1) {
                // 0x3bca8
                v22 = g289;
                if (v22 >= (char *)3 == (v22 != (char *)3)) {
                    // 0x3bdb0
                    snprintf((char *)&str, 2048, "chain = %d\n", v2);
                    function_2ea54(3, &str, (int32_t)!((a1 == 255 | v2 == a1)));
                }
                // 0x3bcb4
                v23 = function_1e0f0();
                v24 = (int32_t)g289;
                v5 = 0;
                v11 = v24;
                if (v23 != 0) {
                    // 0x3bcc4
                    v25 = 1024 * v2 + a2;
                    v13 = 0;
                    v10 = v24;
                    v6 = a2;
                    v7 = v10;
                    if (v10 != 3 && v10 >= 3) {
                        // 0x3bd0c
                        v19 = *(int32_t *)(v25 + 4 * v13);
                        snprintf((char *)&str, 2048, "[%3d]:%-3d", v13, v19);
                        function_2ea54(3, &str, 0);
                        v20 = g289;
                        v21 = (int32_t)v20;
                        v6 = 0;
                        v7 = v21;
                        if (v20 != (char *)3 && v20 >= (char *)3) {
                            // 0x3bd50
                            str = &g9;
                            function_2ea54(3, &str, 0);
                            v6 = 0;
                            v7 = v21;
                        }
                    }
                    // 0x3bcd4
                    v14 = v13 + 1;
                    v15 = function_1e100();
                    v16 = function_5fadc(v14, v15, v6, v7);
                    v17 = g289;
                    v18 = (int32_t)v17;
                    v4 = v16;
                    v8 = v18;
                    if (v15 == 0) {
                        // 0x3bcf4
                        v4 = v16;
                        v8 = v18;
                        if (v17 >= (char *)3 == (v17 != (char *)3)) {
                            // 0x3bd94
                            str = 10;
                            v4 = function_2ea54(3, &str, 0);
                            v8 = (int32_t)g289;
                        }
                    }
                    // 0x3bcfc
                    v9 = v8;
                    v5 = v4;
                    v11 = v9;
                    while (v23 != v14) {
                        // 0x3bd04
                        v13 = v14;
                        v10 = v9;
                        v6 = v15;
                        v7 = v10;
                        if (v10 != 3 && v10 >= 3) {
                            // 0x3bd0c
                            v19 = *(int32_t *)(v25 + 4 * v13);
                            snprintf((char *)&str, 2048, "[%3d]:%-3d", v13, v19);
                            function_2ea54(3, &str, 0);
                            v20 = g289;
                            v21 = (int32_t)v20;
                            v6 = 0;
                            v7 = v21;
                            if (v20 != (char *)3 && v20 >= (char *)3) {
                                // 0x3bd50
                                str = &g9;
                                function_2ea54(3, &str, 0);
                                v6 = 0;
                                v7 = v21;
                            }
                        }
                        // 0x3bcd4
                        v14 = v13 + 1;
                        v15 = function_1e100();
                        v16 = function_5fadc(v14, v15, v6, v7);
                        v17 = g289;
                        v18 = (int32_t)v17;
                        v4 = v16;
                        v8 = v18;
                        if (v15 == 0) {
                            // 0x3bcf4
                            v4 = v16;
                            v8 = v18;
                            if (v17 >= (char *)3 == (v17 != (char *)3)) {
                                // 0x3bd94
                                str = 10;
                                v4 = function_2ea54(3, &str, 0);
                                v8 = (int32_t)g289;
                            }
                        }
                        // 0x3bcfc
                        v9 = v8;
                        v5 = v4;
                        v11 = v9;
                    }
                }
                // 0x3bd5c
                v12 = v11;
                result = v5;
                if (v12 != 3 && v12 >= 3) {
                    // 0x3bd64
                    str = 10;
                    result = function_2ea54(3, &str, 0);
                }
            }
        }
        // 0x3bd7c
        v26 = v2 + 1;
    }
    // 0x3bd88
    return result;
}

// Address range: 0x3be08 - 0x3be28
int32_t function_3be08(void) {
    char * v1 = g289; // 0x3be18
    int32_t result; // 0x3be08
    if (v1 >= (char *)4 == (v1 != (char *)4)) {
        result = function_3be4c();
    }
    // 0x3be24
    return result;
}

// Address range: 0x3be2a - 0x3be2c
int32_t function_3be2a(void) {
    // 0x3be2a
    return function_3c4ae();
}

// Address range: 0x3be2c - 0x3be4c
int32_t function_3be2c(int32_t a1) {
    int32_t result = 0; // 0x3be34
    int32_t v1; // 0x3be2c
    if (v1 != 0) {
        // 0x3be38
        result = free(v1, v1, v1, v1);
        *(int32_t *)v1 = 0;
    }
    // 0x3be44
    return result;
}

// Address range: 0x3be4c - 0x3bec4
int32_t function_3be4c(void) {
    char * v1 = (char *)0x4245445b; // 0x3be5c
    function_2e584(4, (int32_t *)&v1, 0);
    v1 = (char *)0x4245445b;
    return function_2e584(4, (int32_t *)&v1, 0);
}

// Address range: 0x3be84 - 0x3be85
int32_t function_3be84(void) {
    // 0x3be84
    int32_t result; // 0x3be84
    return result;
}

// Address range: 0x3bec4 - 0x3bee0
int32_t function_3bec4(int32_t a1) {
    // 0x3bec4
    return *(int32_t *)(4 * a1 + 0x1004 + g98);
}

// Address range: 0x3bee0 - 0x3bf74
int32_t function_3bee0(int32_t a1, int32_t a2) {
    char * v1 = g289; // 0x3bef8
    if (v1 >= (char *)4 == (v1 != (char *)4)) {
        // 0x3bf48
        int32_t str; // bp-2064, 0x3bee0
        snprintf((char *)&str, 2048, "[DEBUG] Get freq result, chain = %d.\n", a1);
        function_2e584(4, &str, 0);
    }
    int32_t v2 = function_1e0f0(); // 0x3bf08
    if (v2 == 0) {
        // 0x3bf3c
        return 0;
    }
    int32_t result = g98 + 1024 * a1; // 0x3bf28
    int32_t v3 = a2; // 0x3bf28
    result += 4;
    *(int32_t *)v3 = *(int32_t *)result;
    v3 += 4;
    while (v3 != 4 * v2 + a2) {
        // 0x3bf2c
        result += 4;
        *(int32_t *)v3 = *(int32_t *)result;
        v3 += 4;
    }
    // 0x3bf3c
    return result;
}

// Address range: 0x3bf74 - 0x3bf94
int32_t function_3bf74(int32_t a1) {
    int32_t result = 4 * a1 + 0x3030 + g98; // 0x3bf88
    __asm_vldr_8(*(int32_t *)(result + 4));
    return result;
}

// Address range: 0x3bf94 - 0x3c108
int32_t function_3bf94(void) {
    char * v1 = g289; // 0x3bfa8
    int32_t str; // bp-2072, 0x3bf94
    if (v1 >= (char *)3 == (v1 != (char *)3)) {
        int32_t v2 = *(int32_t *)g98; // 0x3c068
        snprintf((char *)&str, 2048, "%-40s : %d\n", "voltage", *(int32_t *)v2);
        function_2ea54(3, &str, 0);
        char * v3 = g289; // 0x3c088
        if (v3 != (char *)3 && v3 >= (char *)3) {
            // 0x3c094
            snprintf((char *)&str, 2048, "%-40s : ", "freq_base");
            function_2ea54(3, &str, 0);
        }
    }
    char * str2 = (char *)&str;
    int32_t v4 = 0;
    int32_t v5 = function_1e29c(v4); // 0x3bfcc
    int32_t result = 0; // 0x3bfd4
    int32_t v6; // 0x3c024
    char * v7; // 0x3bfd8
    if (v5 != 0) {
        // 0x3bfd8
        v7 = g289;
        result = v5;
        if (v7 >= (char *)3 == (v7 != (char *)3)) {
            // 0x3c008
            v6 = *(int32_t *)(4 * v4 + 4 + *(int32_t *)g98);
            snprintf(str2, 2048, "[%d] = %d ", v4, v6);
            result = function_2ea54(3, &str, 0);
        }
    }
    int32_t v8 = v4 + 1; // 0x3bfe4
    while (v8 != 4) {
        // 0x3bfc8
        v4 = v8;
        v5 = function_1e29c(v4);
        result = 0;
        if (v5 != 0) {
            // 0x3bfd8
            v7 = g289;
            result = v5;
            if (v7 >= (char *)3 == (v7 != (char *)3)) {
                // 0x3c008
                v6 = *(int32_t *)(4 * v4 + 4 + *(int32_t *)g98);
                snprintf(str2, 2048, "[%d] = %d ", v4, v6);
                result = function_2ea54(3, &str, 0);
            }
        }
        // 0x3bfe4
        v8 = v4 + 1;
    }
    char * v9 = g289; // 0x3bff0
    if (v9 >= (char *)3 != v9 != (char *)3) {
        // 0x3bffc
        return result;
    }
    // 0x3c0c4
    str = 10;
    int32_t v10 = function_2ea54(3, &str, 0); // 0x3c0d8
    char * v11 = g289; // 0x3c0dc
    int32_t result2 = v10; // 0x3c0e4
    if (v11 == (char *)3 || v11 < (char *)3) {
        result2 = function_3c204(v10, (int32_t)&str, 0, (int32_t)v11);
    }
    // 0x3bffc
    return result2;
}

// Address range: 0x3c10a - 0x3c10c
int32_t function_3c10a(void) {
    // 0x3c10a
    int32_t v1; // 0x3c10a
    return function_3c628(v1);
}

// Address range: 0x3c10c - 0x3c160
int32_t function_3c10c(void) {
    // 0x3c10c
    int32_t str; // 0x3c10c
    snprintf((char *)str, str, (char *)str);
    int32_t v1; // 0x3c10c
    function_2ea54(3, &v1, 0);
    return &v1;
}

// Address range: 0x3c160 - 0x3c162
int32_t function_3c160(int32_t result, int32_t a2) {
    // 0x3c160
    return result;
}

// Address range: 0x3c162 - 0x3c172
int32_t function_3c162(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = a1; // 0x3c162
    bool v2; // 0x3c162
    if (v2) {
        *(int32_t *)(a1 + 4) = 0x3c168;
        v1 = a1 - 0x3c168;
    }
    int32_t result = v1; // 0x3c16e
    if (!v2 && true) {
        result = function_e34ff6();
    }
    // 0x3c172
    return result;
}

// Address range: 0x3c174 - 0x3c204
int32_t function_3c174(void) {
    // 0x3c174
    int32_t v1; // 0x3c174
    int32_t v2 = *(int32_t *)(v1 + 28); // 0x3c1a0
    int32_t str; // 0x3c174
    snprintf((char *)&str, 2048, "%-40s : %d\n", "freq_diff_threshold", v2);
    function_2ea54(3, &str, 0);
    snprintf((char *)&str, 2048, "%-40s : %d\n", "freq_step", *(int32_t *)(v1 + 32));
    return function_2ea54(3, &str, 0);
}

// Address range: 0x3c204 - 0x3c38c
int32_t function_3c204(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x3c204
    int32_t v1; // 0x3c204
    uint32_t v2 = v1;
    int32_t str; // 0x3c204
    if (v2 == 3 || v2 < 3) {
        // 0x3c358
        __asm_vldr_8(*(int32_t *)(*(int32_t *)g98 + 48));
        return &str;
    }
    char * v3 = *(char *)(*(int32_t *)g98 + 36) == 0 ? "false" : "true"; // 0x3c25c
    snprintf((char *)&str, 2048, "%-40s : %s\n", "is_inc_freq_with_high_vol", v3);
    function_2ea54(3, &str, 0);
    char * v4 = *(char *)(*(int32_t *)g98 + 37) == 0 ? "false" : "true"; // 0x3c2ac
    snprintf((char *)&str, 2048, "%-40s : %s\n", "is_inc_freq_with_high_vol_runtime", v4);
    function_2ea54(3, &str, 0);
    int32_t v5 = *(int32_t *)(*(int32_t *)g98 + 40); // 0x3c2ec
    snprintf((char *)&str, 2048, "%-40s : %d\n", "is_board_init_with_power_off", v5);
    function_2ea54(3, &str, 0);
    __asm_vldr_8(*(int32_t *)(*(int32_t *)g98 + 44));
    return &str;
}

// Address range: 0x3c38e - 0x3c392
int32_t function_3c38e(void) {
    // 0x3c38e
    int32_t result; // 0x3c38e
    bool v1; // 0x3c38e
    if (!v1) {
        result = function_77e72();
    }
    // 0x3c392
    return result;
}

// Address range: 0x3c394 - 0x3c3d8
int32_t function_3c394(void) {
    // 0x3c394
    int32_t str; // 0x3c394
    snprintf((char *)str, str, (char *)str);
    int32_t v1; // 0x3c394
    function_2ea54(3, &v1, 0);
    __asm_vldr_8(*(int32_t *)(str + 52));
    return &v1;
}

// Address range: 0x3c3da - 0x3c402
int32_t function_3c3da(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = a1; // 0x3c3da
    bool v2; // 0x3c3da
    if (!v2) {
        v1 = function_77ebe();
    }
    // 0x3c3de
    int32_t result; // 0x3c3da
    int32_t v3; // 0x3c3da
    if (v2) {
        result = v1;
        if (v2) {
            goto lab_dec_label_pc_0x3c3e2_2;
        } else {
            goto lab_dec_label_pc_unknown_33;
        }
    } else {
        *(char *)(0x8000000 * v3 + v3) = -34;
        result = v1;
        if ((v3 & 32) == 0) {
            goto lab_dec_label_pc_unknown_33;
        } else {
            goto lab_dec_label_pc_0x3c3e2_2;
        }
    }
  lab_dec_label_pc_0x3c3e2_2:
    *(int32_t *)v1 = 0x3c3de;
    *(int32_t *)(v1 + 4) = 0x3c3e8;
    result = v1 - (int32_t)&g44;
    goto lab_dec_label_pc_unknown_33;
  lab_dec_label_pc_unknown_33:;
    int32_t v4; // 0x3c3da
    int32_t v5; // 0x3c3da
    if (v2) {
        int32_t v6 = 32 * v3 & a4; // 0x3c3ea
        v4 = v6;
        if ((v3 & 0x8000000) == 0) {
            goto lab_dec_label_pc_unknown_34;
        } else {
            // .thread8
            __asm_mrc2(3, 7, v6, 14, 3, 2);
            v5 = result;
            goto lab_dec_label_pc_unknown_35;
        }
    } else {
        return result;
        int32_t v7 = result / 128 & v3; // 0x3c3e6
        v4 = v7;
        if ((result & 64) != 0) {
            // .thread10
            __asm_mrc2(3, 7, v7, 14, 3, 2);
            return result;
        }
        goto lab_dec_label_pc_unknown_34;
    }
  lab_dec_label_pc_unknown_34:
    *(int32_t *)result = v4;
    *(int32_t *)(result + 4) = 0x3c3f8;
    int32_t result2 = result - (int32_t)&g45; // 0x3c3f2
    __asm_mrc2(3, 7, v4, 14, 3, 2);
    v5 = result2;
    if (!v2) {
        return result2;
    }
    goto lab_dec_label_pc_unknown_35;
  lab_dec_label_pc_unknown_35:
    return v5 - 0x3c404;
}

// Address range: 0x3c402 - 0x3c404
int32_t function_3c402(void) {
    // 0x3c402
    int32_t result; // 0x3c402
    return result;
}

// Address range: 0x3c404 - 0x3c490
int32_t function_3c404(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t v1 = *(int32_t *)(a1 + 56); // 0x3c420
    int32_t str; // 0x3c404
    snprintf((char *)&str, 2048, "%-40s : %d\n", "freq_tuning_fine_step", v1);
    function_2ea54(3, &str, 0);
    int32_t v2; // 0x3c404
    int32_t v3 = *(int32_t *)(v2 + 60); // 0x3c468
    snprintf((char *)&str, 2048, "%-40s : %d\n", "freq_tuning_fine_count", v3);
    return function_2ea54(3, &str, 0);
}

// Address range: 0x3c490 - 0x3c498
int32_t function_3c490(uint32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x3c490
    int32_t v1; // 0x3c490
    return function_3cab6(a1 >> (uint32_t)v1);
}

// Address range: 0x3c498 - 0x3c49c
int32_t function_3c498(int32_t a1) {
    // 0x3c498
    return function_3d1c2();
}

// Address range: 0x3c49c - 0x3c4a8
int32_t function_3c49c(int32_t a1) {
    // 0x3c49e
    return function_3c93c(a1);
    // 0x3c4a4
    *(char *)a1 = (char)a1;
    return function_3c7ea();
}

// Address range: 0x3c4a8 - 0x3c4ac
int32_t function_3c4a8(int32_t result) {
    // 0x3c4a8
    return result;
}

// Address range: 0x3c4ae - 0x3c4b0
int32_t function_3c4ae(void) {
    // 0x3c4ae
    int32_t v1; // 0x3c4ae
    return function_3cb58(v1, v1, v1, v1);
}

// Address range: 0x3c4b0 - 0x3c5dc
int32_t function_3c4b0(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x3c4b0
    int32_t v1; // 0x3c4b0
    uint32_t v2 = v1;
    int32_t v3; // 0x3c4b0
    int32_t v4; // 0x3c4b0
    char * v5; // 0x3c4b0
    bool v6; // 0x3c4b0
    if (v6 == !v6) {
        // 0x3c4e0
        v5 = (char *)0x4245445b;
        function_2e584(4, (int32_t *)&v5, 0);
        v3 = 0;
        if (v2 != 4 && v2 >= 4) {
            // 0x3c518
            v5 = (char *)0x4245445b;
            function_2e584(4, (int32_t *)&v5, 0);
            v4 = 0;
            v3 = 0;
        }
    }
    // 0x3c4b4
    if (g98 == 0) {
        int32_t v7 = function_11eb0(0x3044, 1, v3, v4); // 0x3c564
        g98 = v7;
        if (v7 == 0) {
            // 0x3c578
            function_356c4(13, 255);
            if (v2 != 3 && v2 >= 3) {
                // 0x3c594
                v5 = (char *)0x6c696146;
                function_2e584(3, (int32_t *)&v5, 0);
            }
            // 0x3c4d4
            return -1;
        }
    }
    // 0x3c4c8
    function_3bf94();
    // 0x3c4d4
    return 0;
}

// Address range: 0x3c5dc - 0x3c628
int32_t function_3c5dc(void) {
    // 0x3c5dc
    float64_t v1; // 0x3c5dc
    __asm_vpush_11(v1, v1);
    char * v2 = g289; // 0x3c5f0
    if (v2 >= (char *)3 == (v2 != (char *)3)) {
        function_3d26c();
    }
    int32_t result = 0; // 0x3c618
    if (function_1e29c(0) != 0) {
        result = function_3d148();
    }
    // 0x3c61c
    return result;
}

// Address range: 0x3c628 - 0x3c62c
int32_t function_3c628(int32_t a1) {
    // 0x3c628
    int32_t v1; // 0x3c628
    return function_3c160(a1, v1);
}

// Address range: 0x3c62c - 0x3c7e8
int32_t function_3c62c(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11, int32_t a12) {
    // 0x3c62c
    int32_t v1; // 0x3c62c
    uint32_t v2 = v1;
    uint32_t v3 = v1;
    function_361e4(a4);
    int32_t v4 = v2 + 4; // 0x3c644
    function_11fc4((int32_t *)(v2 + 0x1014), v4, 0, a4);
    if (v3 >= 3 == (v3 != 3)) {
        function_3d210();
    }
    for (int32_t i = 0; i < 4; i++) {
        // 0x3c660
        if (function_1e29c(i) != 0) {
            function_3d0a8();
        }
    }
    float64_t v5 = __asm_vldr(-0xa3d70a4); // 0x3c680
    if (function_39998() == 0) {
        function_3d1b8(0);
    }
    int32_t str; // bp+56, 0x3c62c
    if (v2 >= 3 == (v2 != 3)) {
        // 0x3c7a0
        snprintf((char *)&str, 2048, "is_need_serial = %d\n", 0);
        function_2e584(3, &str, 0);
        if (v2 != 3 && v2 >= 3) {
            // 0x3c7d0
            str = 10;
            return function_2ea54(3, &str, 0);
        }
    }
    int32_t v6 = 0;
    int32_t v7; // 0x3c780
    if (function_1e29c(v6) != 0) {
        // 0x3c748
        if (!((v2 == 3 | v2 < 3 | function_397a0(v6) != 1))) {
            // 0x3c764
            v7 = *(int32_t *)(v3 + 0x3014 + 4 * v6);
            snprintf((char *)&str, 2048, "chain = %d, grade = %d\n", v6, v7);
            function_2e584(3, &str, 0);
        }
    }
    int32_t v8 = v6 + 1; // 0x3c6dc
    while (v8 != 4) {
        // 0x3c6cc
        v6 = v8;
        if (function_1e29c(v6) != 0) {
            // 0x3c748
            if (!((v2 == 3 | v2 < 3 | function_397a0(v6) != 1))) {
                // 0x3c764
                v7 = *(int32_t *)(v3 + 0x3014 + 4 * v6);
                snprintf((char *)&str, 2048, "chain = %d, grade = %d\n", v6, v7);
                function_2e584(3, &str, 0);
            }
        }
        // 0x3c6dc
        v8 = v6 + 1;
    }
    if (v2 >= 3 == (v2 != 3)) {
        function_3cfe4();
    }
    int32_t result = function_39fb4(*(int32_t *)(v3 + 40)); // 0x3c700
    if (result == 0) {
        function_3c830();
    }
    if (v3 >= 3 == (v3 != 3)) {
        function_3d02c();
    }
    // 0x3c724
    function_3bc48(255, v4);
    float64_t v9; // 0x3c62c
    __asm_vpop_13(v9, v5);
    return result;
}

// Address range: 0x3c7ea - 0x3c7ec
int32_t function_3c7ea(void) {
    // 0x3c7ea
    int32_t result; // 0x3c7ea
    return result;
}

// Address range: 0x3c7ec - 0x3c828
int32_t function_3c7ec(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    char * v1 = (char *)0x3e3e3e3e; // bp+56, 0x3c804
    return function_2e584(3, (int32_t *)&v1, 0);
}

// Address range: 0x3c830 - 0x3c93c
int32_t function_3c830(void) {
    // 0x3c830
    function_39a7c();
    int32_t v1; // bp+56, 0x3c830
    int32_t v2; // 0x3c830
    memset(&v1, v2, 0x1000);
    int32_t v3; // 0x3c830
    if (function_1e29c(v3) != 0) {
        function_3cee0();
    }
    int32_t v4 = v3 + 1; // 0x3c878
    while (v4 != 4) {
        // 0x3c868
        if (function_1e29c(v4) != 0) {
            function_3cee0();
        }
        // 0x3c878
        v4++;
    }
    int32_t v5 = function_19ab4(); // 0x3c884
    int32_t v6 = function_361f4(); // 0x3c88c
    int32_t v7 = v6; // 0x3c894
    if (v5 == v6) {
        v7 = function_3d104();
    }
    int32_t v8 = function_36208(v7); // 0x3c898
    __asm_vcvt_f32_s32(__asm_vldr_8(g296));
    function_1ad08(&v1, g66, (int32_t)*(char *)(v2 + 36));
    if (v8 != 0) {
        function_3d2a0();
    }
    // 0x3c8dc
    if (function_39998() == 0) {
        function_3ce78((int32_t)&g488);
    }
    int32_t result; // 0x3c830
    for (int32_t i = 0; i < 4; i++) {
        // 0x3c914
        result = 0;
        if (function_1e29c(i) != 0) {
            result = function_3cdd8();
        }
    }
    // 0x3c930
    return result;
}

// Address range: 0x3c93c - 0x3c940
int32_t function_3c93c(int32_t a1) {
    // 0x3c93c
    *(int32_t *)(2 * a1) = a1;
    return function_3d082();
}

// Address range: 0x3c940 - 0x3c968
int32_t function_3c940(void) {
    int32_t v1 = 0; // 0x3c94c
    int32_t v2; // 0x3c940
    if (function_1e29c(v2) != 0) {
        v1 = function_3ce40();
    }
    int32_t result = v1; // 0x3c958
    if (v2 != 3) {
        result = function_3c940();
    }
    // 0x3c95c
    return result;
}

// Address range: 0x3c968 - 0x3cab4
int32_t function_3c968(int32_t a1) {
    int32_t v1; // 0x3c968
    if (function_1e29c(v1) != 0) {
        function_3cc6c((int32_t)&g488, (int32_t)&g488);
    }
    int32_t v2 = v1 + 1; // 0x3c998
    // 0x3c968
    while (v2 != 4) {
        // 0x3c988
        if (function_1e29c(v2) != 0) {
            function_3cc6c((int32_t)&g488, (int32_t)&g488);
        }
        // 0x3c998
        v2++;
    }
    // 0x3c9a4
    int32_t v3; // 0x3c968
    int32_t v4 = v3 + 0x1014; // 0x3c9b8
    int32_t v5 = function_3b94c(255, v4); // 0x3c9bc
    function_321b8(v5, g283, 20);
    int32_t v6 = function_3ba18(255, v4); // 0x3c9e0
    int32_t * v7 = (int32_t *)(v3 - 16); // 0x3c9e8
    *v7 = v6;
    function_3a86c(v7);
    function_391f4();
    for (int32_t i = 0; i < 4; i++) {
        // 0x3c9fc
        if (function_1e29c(i) != 0) {
            function_3cc34();
        }
    }
    int32_t v8 = 0; // 0x3ca38
    int32_t v9 = 0; // 0x3ca38
    if (function_1e29c(0) == 0) {
        goto lab_0x3ca3c;
    } else {
        goto lab_0x3ca58;
    }
  lab_0x3ca3c:;
    int32_t v10 = v8 + 1; // 0x3ca3c
    int32_t v11 = function_1e29c(v10); // 0x3ca4c
    int32_t v12 = v10; // 0x3ca54
    v9 = v10;
    while (v11 == 0) {
        // 0x3ca3c
        v10 = v12 + 1;
        v11 = function_1e29c(v10);
        v12 = v10;
        v9 = v10;
    }
    goto lab_0x3ca58;
  lab_0x3ca58:;
    int32_t v13 = v9;
    int32_t v14 = function_397a0(v13); // 0x3ca5c
    v8 = v13;
    if (v14 == 1) {
        // 0x3ca68
        v8 = v13;
        if (*(int32_t *)(v3 + 0x3024 + 4 * v13) == 0) {
            int32_t v15 = function_1e0f0(); // 0x3ca84
            int32_t result = v15; // 0x3ca8c
            if (v15 < 1) {
                result = function_1e0f0();
            }
            // 0x3ca90
            return result;
        }
    }
    goto lab_0x3ca3c;
}

// Address range: 0x3cab6 - 0x3caba
int32_t function_3cab6(int32_t result) {
    // 0x3cab6
    int32_t v1; // 0x3cab6
    __asm_mcr(5, 0, v1, 8, 12, 4);
    return result;
}

// Address range: 0x3caba - 0x3cb0a
int32_t function_3caba(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x3caba
    bool v1; // 0x3caba
    if (v1) {
        *(int32_t *)(a1 + (int32_t)&g46) = 0x3cac0;
    }
    int32_t v2 = a1; // 0x3cabe
    if (v1 == !v1) {
        v2 = function_1275146();
    }
    bool v3; // 0x3caba
    int32_t v4; // 0x3caba
    int32_t v5; // 0x3caba
    int32_t v6; // 0x3caba
    if (v1) {
        v3 = v1 ? v1 : a2 < 0;
        v4 = function_fe4754ea();
    } else {
        *(int16_t *)v6 = -0x353e;
        v3 = v1 ? v6 < 0 : a2 < 0;
        v5 = 0;
        v4 = v2;
    }
    // 0x3cad2
    if (!v1) {
        // 0x3cade
        function_ffa35962();
        function_2b85c6();
    }
    bool v7 = v1 ? (v4 & 4) != 0 : (v6 & 16) != 0 | v3;
    if (v7 == !v1) {
        function_ff238386();
    }
    int32_t v8 = function_4785be(); // 0x3cae6
    if (v7) {
        // .thread
        *(int32_t *)v8 = 0x3cae6;
        *(int32_t *)(v8 + 4) = 0x3caf0;
        // .critedge
        return v1 ? v8 - a2 : v5 * v6;
    }
    int32_t result = v1 ? v8 : v5 * v6;
    if ((v8 & 64) == 0) {
        __asm_swplo(v6, a2);
        __asm_smlabblo(a4, result, v6);
    }
    // .critedge
    return result;
}

// Address range: 0x3cb0a - 0x3cb0c
int32_t function_3cb0a(void) {
    // 0x3cb0a
    int32_t result; // 0x3cb0a
    return result;
}

// Address range: 0x3cb0c - 0x3cb18
int32_t function_3cb0c(int32_t a1) {
    // 0x3cb0c
    int32_t result; // 0x3cb0c
    return result;
}

// Address range: 0x3cb18 - 0x3cb1c
int32_t function_3cb18(void) {
    // 0x3cb18
    return function_1e0f0();
}

// Address range: 0x3cb1e - 0x3cb20
int32_t function_3cb1e(void) {
    // 0x3cb1e
    return function_3d1c2();
}

// Address range: 0x3cb20 - 0x3cb58
int32_t function_3cb20(int32_t a1) {
    int32_t v1 = a1; // 0x3cb20
    bool v2; // 0x3cb20
    if (v2 || false) {
        v1 = function_3d01c();
    }
    // 0x3cb24
    int32_t v3; // 0x3cb20
    return v3 + 0x2010 + 4 * (v1 + 256 * v3);
}

// Address range: 0x3cb58 - 0x3cb5e
int32_t function_3cb58(uint32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x3cb58
    int32_t v1; // 0x3cb58
    *(int16_t *)(v1 + 42) = (int16_t)a4;
    return a1 / 256;
}

// Address range: 0x3cb5e - 0x3cb78
int32_t function_3cb5e(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x3cb5e
    int32_t v1; // 0x3cb72
    bool v2; // 0x3cb5e
    int32_t v3; // 0x3cb5e
    if (v2) {
        // .thread
        *(int32_t *)(a1 + 4) = 0x3cb64;
        if (v2) {
            // .thread17
            v1 = function_b4d7a();
            // 0x3cb76
            return function_3d080(v1, a2);
        }
        int32_t v4 = a1 - 0x3cb64; // 0x3cb5e
        *(int32_t *)(v3 - 2560) = v4;
        // 0x3cb76
        return function_3d080(v4, a2);
    }
    if ((1 << a4 - 1 & a1) == 0) {
        // .thread18
        *(int32_t *)(v3 - 2560) = a1;
        // 0x3cb76
        return function_3d080(a1, a2);
    }
    // .thread17
    v1 = function_b4d7a();
    // 0x3cb76
    return function_3d080(v1, a2);
}

// Address range: 0x3cb78 - 0x3cc34
int32_t function_3cb78(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x3cb78
    int32_t str; // 0x3cb78
    int32_t v1 = str;
    int32_t v2 = str + a4; // 0x3cb84
    int32_t v3 = a3 + 16 + str; // 0x3cb84
    v3 += 4;
    v2 += 4;
    *(int32_t *)v2 = *(int32_t *)v3;
    while (v2 != str + 4 * a1) {
        // 0x3cb88
        v3 += 4;
        v2 += 4;
        *(int32_t *)v2 = *(int32_t *)v3;
    }
    int32_t v4 = 4 * str; // 0x3cb9c
    int32_t v5 = v4 + str; // 0x3cba4
    *(int32_t *)(v5 + 0x1004) = 1;
    if (v1 != 3 && v1 >= 3) {
        int32_t v6 = *(int32_t *)(v5 + 0x3014); // 0x3cbc0
        snprintf((char *)str, 2048, "Update freq result of high grade, chain = %d, grade_curr = %d.\n", str, v6);
        function_2e584(3, (int32_t *)str, 0);
    }
    // 0x3cbec
    function_3a828(str, a5);
    int32_t * v7 = (int32_t *)(str + 0x3034 + v4); // 0x3cc08
    float32_t v8; // 0x3cb78
    __asm_vcmpe_f32(v8, __asm_vldr_8(*v7));
    __asm_vmrs(str, str);
    if (v1 > 3) {
        __asm_vstrgt(v8, *v7);
    }
    function_3bae4(str);
    return function_3962c(str, 2);
}

// Address range: 0x3cc34 - 0x3cc6c
int32_t function_3cc34(void) {
    // 0x3cc34
    int32_t v1; // 0x3cc34
    function_397a0(v1);
    return function_3a054(v1, v1);
}

// Address range: 0x3cc6c - 0x3cdd8
int32_t function_3cc6c(int32_t a1, int32_t usec) {
    // 0x3cc6c
    int32_t v1; // 0x3cc6c
    uint32_t v2 = v1;
    function_397a0(v1);
    int32_t v3 = *(int32_t *)(v1 + 0x3024 + 4 * v1); // 0x3cc8c
    int32_t v4 = function_1e0f0(); // 0x3cc98
    if (v4 == 0) {
        function_3d13c();
    }
    int32_t v5 = 256 * v1; // 0x3ccac
    int32_t v6 = 1024 * v1 + v1;
    int32_t v7 = v6 + 0x1014; // 0x3ccc8
    int32_t v8 = v6; // 0x3ccc8
    v8 += 4;
    int32_t v9 = *(int32_t *)v8; // 0x3cccc
    int32_t * v10 = (int32_t *)v7; // 0x3ccd0
    *v10 = v9;
    int32_t v11 = v3; // 0x3ccdc
    if (*(int32_t *)(v7 + 0x1000) == 1) {
        v11 = v9 - *(int32_t *)(v1 + 32);
        *v10 = v11;
    }
    int32_t v12 = v11;
    v7 += 4;
    while (v8 != 4 * (v4 + v5) + v1) {
        // 0x3cccc
        v8 += 4;
        v9 = *(int32_t *)v8;
        v10 = (int32_t *)v7;
        *v10 = v9;
        v11 = v12;
        if (*(int32_t *)(v7 + 0x1000) == 1) {
            v11 = v9 - *(int32_t *)(v1 + 32);
            *v10 = v11;
        }
        v12 = v11;
        v7 += 4;
    }
    // 0x3ccf0
    if (*(char *)(v1 + 37) != 0) {
        function_3cfd4();
    }
    int32_t v13 = v1 - 12; // 0x3cd04
    int32_t v14 = v1 - 8; // 0x3cd08
    __asm_vcvt_f32_u32(__asm_vmov_7(v12));
    function_502c0(v14, (int32_t *)v13, 0);
    *(char *)(v1 - 2) = *(char *)v13;
    if (v2 >= 3 == (v2 != 3)) {
        function_3cf90((int32_t)&g488);
    }
    int32_t v15 = function_1e0f0(); // 0x3cd28
    int32_t v16; // 0x3cc6c
    if (v15 == 0) {
      lab_0x3cdc4:
        // 0x3cdc4
        return function_3bc48(v1, v16 + 0x1014);
    }
    int32_t v17 = v3;
    int32_t v18; // 0x3cc6c
    int32_t v19; // 0x3cd4c
    while (*(int32_t *)(v18 + 0x1014 + 4 * (v17 + v5)) != v12) {
        // 0x3cd4c
        v19 = v17 + 1;
        v16 = v18;
        if (v15 == v19) {
            return function_3bc48(v1, v16 + 0x1014);
        }
        v17 = v19;
    }
    if (v2 >= 3 == (v2 != 3)) {
        function_3ceb0((int32_t)&g488);
    }
    uint32_t v20 = __asm_smulbb(function_1e160(), v17); // 0x3cd84
    int32_t v21 = *(int32_t *)v14; // 0x3cd88
    int32_t v22 = v17 + 1; // 0x3cd8c
    unsigned char v23 = *(char *)a1; // 0x3cd90
    function_1f164(v1, 0, v20 % 256, (int32_t)v23, *(int32_t *)(v1 - 4), v21);
    usleep(usec);
    while (v15 != v22) {
        // 0x3cd58
        v17 = v22;
        while (*(int32_t *)(v5 + 0x1014 + 4 * (v17 + v5)) != v12) {
            // 0x3cd4c
            v19 = v17 + 1;
            v16 = v5;
            if (v15 == v19) {
                return function_3bc48(v1, v16 + 0x1014);
            }
            v17 = v19;
        }
        if (v2 >= 3 == (v2 != 3)) {
            function_3ceb0((int32_t)&g488);
        }
        // 0x3cd7c
        v20 = __asm_smulbb(function_1e160(), v17);
        v21 = *(int32_t *)v14;
        v22 = v17 + 1;
        v23 = *(char *)a1;
        function_1f164(v1, 0, v20 % 256, (int32_t)v23, *(int32_t *)(v1 - 4), v21);
        usleep(usec);
    }
    // 0x3cdc4
    return function_3bc48(v1, v5 + 0x1014);
}

// Address range: 0x3cdd8 - 0x3ce40
int32_t function_3cdd8(void) {
    // 0x3cdd8
    int32_t str; // 0x3cdd8
    function_397a0(str);
    function_3b8a0(str, 2 * str);
    snprintf((char *)str, 2048, (char *)str);
    return function_2e584(3, (int32_t *)str, 0);
}

// Address range: 0x3ce40 - 0x3ce78
int32_t function_3ce40(void) {
    // 0x3ce40
    int32_t v1; // 0x3ce40
    uint32_t v2 = v1;
    function_397a0(v1);
    int32_t v3 = *(int32_t *)(v1 + 0x3024 + 4 * v1); // 0x3ce64
    int32_t result = v3; // 0x3ce68
    if (v2 >= 3 == (v2 != 3)) {
        result = function_3cf48(v3);
    }
    // 0x3ce6c
    return result;
}

// Address range: 0x3ce78 - 0x3ceb0
int32_t function_3ce78(int32_t format) {
    // 0x3ce78
    int32_t str; // 0x3ce78
    snprintf((char *)str, 2048, (char *)format);
    function_2e584(3, (int32_t *)str, 0);
    return function_3c968((int32_t)&g488);
}

// Address range: 0x3ceb0 - 0x3cee0
int32_t function_3ceb0(int32_t format) {
    // 0x3ceb0
    int32_t str; // 0x3ceb0
    snprintf((char *)str, 2048, (char *)format);
    return function_2e584(3, (int32_t *)str, 0);
}

// Address range: 0x3cee0 - 0x3cf48
int32_t function_3cee0(void) {
    // 0x3cee0
    int32_t result; // 0x3cee0
    if (function_397a0(result) == 1) {
        function_3d180();
    }
    uint32_t v1 = function_3b8a0(result, result + 4); // 0x3cefc
    int32_t * v2 = (int32_t *)(result + 24); // 0x3cf08
    uint32_t v3 = *v2; // 0x3cf08
    if (v1 == v3 || v1 < v3) {
        function_3d0cc();
    }
    int32_t v4 = 4 * (function_1e0f0() + 256 * result) + result; // 0x3cf2c
    int32_t v5 = 1024 * result + result; // 0x3cf2c
    *(int32_t *)v5 = *v2;
    v5 += 4;
    while (v5 != v4) {
        // 0x3cf30
        *(int32_t *)v5 = *v2;
        v5 += 4;
    }
    // 0x3cf44
    return result;
}

// Address range: 0x3cf48 - 0x3cf90
int32_t function_3cf48(int32_t a1) {
    // 0x3cf48
    int32_t str; // 0x3cf48
    snprintf((char *)str, 2048, (char *)str);
    function_2e584(3, (int32_t *)str, 0);
    return *(int32_t *)(str + 0x3024 + 4 * str);
}

// Address range: 0x3cf90 - 0x3cfd4
int32_t function_3cf90(int32_t format) {
    // 0x3cf90
    int32_t str; // 0x3cf90
    snprintf((char *)str, 2048, (char *)format);
    return function_2e584(3, (int32_t *)str, 0);
}

// Address range: 0x3cfd4 - 0x3cfe4
int32_t function_3cfd4(void) {
    // 0x3cfd4
    return function_1a46c();
}

// Address range: 0x3cfe4 - 0x3d01c
int32_t function_3cfe4(void) {
    char * v1 = (char *)0x72616f42; // bp+56, 0x3cff8
    return function_2e584(3, (int32_t *)&v1, 0);
}

// Address range: 0x3d01c - 0x3d02c
int32_t function_3d01c(void) {
    // 0x3d01c
    int32_t v1; // 0x3d01c
    return function_3962c(v1, 2);
}

// Address range: 0x3d02c - 0x3d080
int32_t function_3d02c(void) {
    char * v1 = (char *)0x72616f42; // bp+56, 0x3d040
    function_2e584(3, (int32_t *)&v1, 0);
    return 0x61726150;
}

// Address range: 0x3d080 - 0x3d082
int32_t function_3d080(int32_t result, int32_t a2) {
    // 0x3d080
    return result;
}

// Address range: 0x3d082 - 0x3d08c
int32_t function_3d082(void) {
    // 0x3d082
    int32_t v1; // 0x3d082
    int32_t v2 = *(int32_t *)(v1 + 4); // 0x3d082
    int32_t v3 = *(int32_t *)(v1 + 8); // 0x3d082
    *(int32_t *)(v1 + 4) = v2;
    *(int32_t *)(v1 + 8) = v3;
    return function_3d3ce(v1, v2, v3);
}

// Address range: 0x3d08c - 0x3d0a8
int32_t function_3d08c(int32_t a1, int32_t a2, int32_t a3, uint32_t a4) {
    // 0x3d08c
    int32_t v1; // 0x3d08c
    *(int16_t *)v1 = (int16_t)a4;
    *(char *)(v1 + 2) = (char)(a4 / 0x10000);
    return function_3d1c8(function_2e584(3, (int32_t *)a2, 0));
}

// Address range: 0x3d0a8 - 0x3d0cc
int32_t function_3d0a8(void) {
    // 0x3d0a8
    int32_t v1; // 0x3d0a8
    int32_t v2 = function_3bae4(v1) == 0 ? 1 : 2;
    return function_3962c(v1, v2);
}

// Address range: 0x3d0cc - 0x3d104
int32_t function_3d0cc(void) {
    // 0x3d0cc
    int32_t v1; // 0x3d0cc
    int32_t v2 = 1024 * v1; // 0x3d0e0
    int32_t result = 4 * (function_1e0f0() + 256 * v1) + v1; // 0x3d0ec
    int32_t v3 = v2 + v1; // 0x3d0ec
    int32_t v4 = v2 + v1; // 0x3d0ec
    v3 += 4;
    *(int32_t *)v4 = *(int32_t *)v3;
    v4 += 4;
    while (v3 != result) {
        // 0x3d0f0
        v3 += 4;
        *(int32_t *)v4 = *(int32_t *)v3;
        v4 += 4;
    }
    // 0x3d100
    return result;
}

// Address range: 0x3d104 - 0x3d13c
int32_t function_3d104(void) {
    // 0x3d104
    __asm_vcvt_f32_s32(__asm_vldr_8(g296));
    int32_t v1; // 0x3d104
    unsigned char v2 = *(char *)(v1 + 36); // 0x3d130
    return function_1ad08((int32_t *)v1, g66, (int32_t)v2);
}

// Address range: 0x3d13c - 0x3d148
int32_t function_3d13c(void) {
    // 0x3d13c
    int32_t result; // 0x3d13c
    return result;
}

// Address range: 0x3d148 - 0x3d180
int32_t function_3d148(void) {
    // 0x3d148
    int32_t v1; // 0x3d148
    int32_t v2 = 4 * (function_1e0f0() + 256 * v1) + v1; // 0x3d160
    int32_t result = 4 * v1 + v1; // 0x3d168
    int32_t v3 = 1024 * v1 + v1; // 0x3d168
    v3 += 4;
    *(int32_t *)v3 = *(int32_t *)(result + 4);
    while (v3 != v2) {
        // 0x3d16c
        v3 += 4;
        *(int32_t *)v3 = *(int32_t *)(result + 4);
    }
    // 0x3d17c
    return result;
}

// Address range: 0x3d180 - 0x3d1b8
int32_t function_3d180(void) {
    // 0x3d180
    int32_t v1; // 0x3d180
    int32_t v2 = 1024 * v1; // 0x3d194
    int32_t result = 4 * (function_1e0f0() + 256 * v1) + v1; // 0x3d1a0
    int32_t v3 = v2 + v1; // 0x3d1a0
    int32_t v4 = v2 + v1; // 0x3d1a0
    v3 += 4;
    *(int32_t *)v4 = *(int32_t *)v3;
    v4 += 4;
    while (v3 != result) {
        // 0x3d1a4
        v3 += 4;
        *(int32_t *)v4 = *(int32_t *)v3;
        v4 += 4;
    }
    // 0x3d1b4
    return result;
}

// Address range: 0x3d1b8 - 0x3d1c0
int32_t function_3d1b8(int32_t result) {
    // 0x3d1b8
    return result;
}

// Address range: 0x3d1c2 - 0x3d1c4
int32_t function_3d1c2(void) {
    // 0x3d1c2
    int32_t result; // 0x3d1c2
    return result;
}

// Address range: 0x3d1c4 - 0x3d1c8
int32_t function_3d1c4(int32_t result) {
    // 0x3d1c4
    return result;
}

// Address range: 0x3d1c8 - 0x3d210
int32_t function_3d1c8(int32_t a1) {
    char * v1 = (char *)0x706d7544; // bp+56, 0x3d1e4
    return function_2e584(3, (int32_t *)&v1, 0);
}

// Address range: 0x3d210 - 0x3d26c
int32_t function_3d210(void) {
    char * v1 = (char *)10; // bp+56, 0x3d220
    function_2ea54(3, (int32_t *)&v1, 0);
    v1 = (char *)0x3e3e3e3e;
    return function_2e584(3, (int32_t *)&v1, 0);
}

// Address range: 0x3d26c - 0x3d2a0
int32_t function_3d26c(void) {
    char * v1 = (char *)0x66206f44; // bp+56, 0x3d27c
    return function_2e584(3, (int32_t *)&v1, 0);
}

// Address range: 0x3d2a0 - 0x3d2b4
int32_t function_3d2a0(void) {
    // 0x3d2a0
    int32_t result; // 0x3d2a0
    return result;
}

// Address range: 0x3d2b4 - 0x3d2f0
int32_t function_3d2b4(char * str2, int32_t str) {
    int32_t * mem = malloc(strlen((char *)str) + strlen(str2)); // 0x3d2d4
    sprintf((char *)mem, str2);
    return (int32_t)mem;
}

// Address range: 0x3d2f0 - 0x3d300
int32_t function_3d2f0(int32_t a1) {
    // 0x3d2f0
    *(char *)a1 = 1;
    return 0;
}

// Address range: 0x3d300 - 0x3d310
int32_t function_3d300(int32_t a1) {
    // 0x3d300
    *(char *)a1 = 0;
    return 0;
}

// Address range: 0x3d310 - 0x3d320
int32_t function_3d310(int32_t a1) {
    // 0x3d310
    *(char *)a1 = 0;
    return 0;
}

// Address range: 0x3d320 - 0x3d3b4
int32_t function_3d320(int32_t a1, int32_t a2) {
    char * str = (char *)a1; // 0x3d334
    if (strcasecmp(str, "yes") == 0 || strcasecmp(str, "true") == 0) {
        // 0x3d3a4
        *(char *)a2 = 1;
        return 0;
    }
    // 0x3d358
    if (strcasecmp(str, "no") == 0) {
        // 0x3d394
        *(char *)a2 = 0;
        return 0;
    }
    // 0x3d370
    if (strcasecmp(str, "false") != 0) {
        // 0x3d388
        return function_3de58(a1);
    }
    // 0x3d394
    *(char *)a2 = 0;
    return 0;
}

// Address range: 0x3d3b4 - 0x3d3cc
int32_t function_3d3b4(int32_t a1, int32_t a2) {
    // 0x3d3b4
    return function_3d320(a1, a2);
}

// Address range: 0x3d3ce - 0x3d3d2
int32_t function_3d3ce(int32_t result, int32_t a2, int32_t a3) {
    // 0x3d3ce
    *(int16_t *)a3 = (int16_t)result;
    return result;
}

// Address range: 0x3d3d4 - 0x3d3e0
int32_t function_3d3d4(int32_t a1, int32_t * a2) {
    // 0x3d3d4
    *a2 = a1;
    return 0;
}

// Address range: 0x3d3e0 - 0x3d468
int32_t function_3d3e0(int32_t str, int32_t a2) {
    int32_t * v1 = __errno_location(); // 0x3d3f0
    *v1 = 0;
    char * endptr; // bp-20, 0x3d3e0
    strtof((char *)str, &endptr);
    float32_t v2; // 0x3d3e0
    __asm_vstr_12(v2, (int32_t)&endptr);
    int32_t v3; // 0x3d3e0
    if ((char)v3 == 0 | *endptr != 0) {
        // 0x3d460
        return function_3d2b4("'%s' is not a number", str);
    }
    // 0x3d42c
    if (*v1 == 0) {
        // 0x3d460
        return 0;
    }
    // 0x3d438
    return function_3d2b4("'%s' is out of range", str);
}

// Address range: 0x3d468 - 0x3d4f0
int32_t function_3d468(int32_t a1, int32_t * a2) {
    int32_t * v1 = __errno_location(); // 0x3d478
    *v1 = 0;
    char * v2; // bp-20, 0x3d468
    *a2 = function_11ef8((int32_t *)a1, (int32_t)&v2, 0);
    int32_t v3; // 0x3d468
    if ((char)v3 == 0 | *v2 != 0) {
        // 0x3d4e8
        return function_3d2b4("'%s' is not a number", a1);
    }
    // 0x3d4b4
    if (*v1 == 0) {
        // 0x3d4e8
        return 0;
    }
    // 0x3d4c0
    return function_3d2b4("'%s' is out of range", a1);
}

// Address range: 0x3d4f0 - 0x3d518
int32_t function_3d4f0(int32_t a1, int32_t a2) {
    // 0x3d4f0
    int32_t v1; // bp-12, 0x3d4f0
    int32_t result = function_3d468(a1, &v1); // 0x3d500
    if (result == 0) {
        *(int32_t *)a2 = v1;
    }
    return result;
}

// Address range: 0x3d518 - 0x3d568
int32_t function_3d518(int32_t a1, int32_t a2) {
    // 0x3d518
    int32_t v1; // bp-20, 0x3d518
    int32_t result = function_3d468(a1, &v1); // 0x3d52c
    if (result != 0) {
        // 0x3d538
        return result;
    }
    // 0x3d540
    if (v1 < 0) {
        // 0x3d550
        return function_3d2b4("'%s' is negative", a1);
    }
    // .thread
    *(int32_t *)a2 = v1;
    // 0x3d538
    return result;
}

// Address range: 0x3d568 - 0x3d5b8
int32_t function_3d568(int32_t a1, int32_t a2) {
    // 0x3d568
    int32_t v1; // bp-20, 0x3d568
    int32_t result = function_3d468(a1, &v1); // 0x3d57c
    if (result != 0) {
        // 0x3d588
        return result;
    }
    // 0x3d590
    *(int32_t *)a2 = v1;
    if (v1 < 0) {
        // 0x3d5a0
        return function_3d2b4("'%s' is negative", a1);
    }
    // 0x3d588
    return result;
}

// Address range: 0x3d5b8 - 0x3d5d0
int32_t function_3d5b8(int32_t a1) {
    // 0x3d5b8
    *(int32_t *)a1 = 1;
    return 0;
}

// Address range: 0x3d5d0 - 0x3d5f0
int32_t function_3d5d0(void) {
    // 0x3d5d0
    int32_t str; // 0x3d5d0
    puts((char *)str);
    function_11f58(g318);
    exit(0);
    // UNREACHABLE
}

// Address range: 0x3d5f0 - 0x3d630
int32_t function_3d5f0(int32_t a1) {
    // 0x3d5f0
    int32_t v1; // 0x3d5f0
    function_11f34("%s", (int32_t *)g457, v1, (int32_t)&g457);
    function_11f58(g318);
    exit(0);
    // UNREACHABLE
}

// Address range: 0x3d630 - 0x3d654
int32_t function_3d630(void) {
    // 0x3d630
    int32_t str; // 0x3d630
    char * str2 = (char)str == 0 ? "false" : "true"; // 0x3d650
    return (int32_t)strncpy((char *)str, str2, 80);
}

// Address range: 0x3d654 - 0x3d678
int32_t function_3d654(void) {
    // 0x3d654
    int32_t str; // 0x3d654
    char * str2 = (char)str == 0 ? "true" : "false"; // 0x3d674
    return (int32_t)strncpy((char *)str, str2, 80);
}

// Address range: 0x3d678 - 0x3d6d8
int32_t function_3d678(int32_t a1, int32_t a2) {
    char * str = (char *)a2; // 0x3d68c
    uint32_t len = strlen(str); // 0x3d68c
    *(char *)a1 = 34;
    int32_t str2 = a1 + 1; // 0x3d69c
    if (len >= 78 == (len != 78)) {
        char * dest_str = strncpy((char *)str2, str, 78); // 0x3d6cc
        *(char *)(a1 + 79) = 34;
        return (int32_t)dest_str;
    }
    int32_t v1 = len + a1; // 0x3d6ac
    char * dest_str2 = strncpy((char *)str2, str, len); // 0x3d6b0
    *(char *)(v1 + 1) = 34;
    if (len != 78) {
        *(char *)(v1 + 2) = 0;
    }
    return (int32_t)dest_str2;
}

// Address range: 0x3d6d8 - 0x3d6ec
int32_t function_3d6d8(int32_t str, int32_t a2) {
    // 0x3d6d8
    return snprintf((char *)str, 80, "%i", a2);
}

// Address range: 0x3d6ec - 0x3d6ee
int32_t function_3d6ec(void) {
    // 0x3d6ec
    return function_3d6f8();
}

// Address range: 0x3d6ee - 0x3d6f6
int32_t function_3d6ee(void) {
    // 0x3d6ee
    int32_t v1; // 0x3d6ee
    bool v2; // 0x3d6ee
    if (v2) {
        v1 = function_d76baa();
    }
    int32_t result = v1; // 0x3d6f2
    if (!v2) {
        result = function_7631a();
    }
    // 0x3d6f6
    return result;
}

// Address range: 0x3d6f8 - 0x3d6fc
int32_t function_3d6f8(void) {
    // 0x3d6f8
    int32_t result; // 0x3d6f8
    return result;
}

// Address range: 0x3d6fc - 0x3d700
int32_t function_3d6fc(void) {
    // 0x3d6fc
    return 6;
}

// Address range: 0x3d700 - 0x3d704
int32_t function_3d700(int32_t a1, int32_t a2, int32_t a3) {
    // 0x3d700
    return function_3de46();
}

// Address range: 0x3d706 - 0x3d70a
int32_t function_3d706(void) {
    // 0x3d706
    int32_t result; // 0x3d706
    bool v1; // 0x3d706
    if (!v1) {
        result = function_791ea();
    }
    // 0x3d70a
    return result;
}

// Address range: 0x3d70c - 0x3d714
int32_t function_3d70c(void) {
    // 0x3d70c
    int32_t str; // 0x3d70c
    return snprintf((char *)str, str, (char *)str);
}

// Address range: 0x3d716 - 0x3d744
int32_t function_3d716(int32_t a1, int32_t a2) {
    int32_t v1 = a1; // 0x3d716
    bool v2; // 0x3d716
    if (v2) {
        v1 = function_f76992();
    }
    // 0x3d71a
    bool v3; // 0x3d716
    bool v4; // 0x3d716
    bool v5; // 0x3d716
    bool v6; // 0x3d716
    int32_t v7; // 0x3d716
    if (v2) {
        bool v8 = v2 | (v7 & 0x4000000) != 0;
        v3 = v8;
        v5 = true;
        v4 = v8;
        v6 = true;
        if (v2) {
            goto lab_dec_label_pc_unknown_37;
        } else {
            goto lab_dec_label_pc_unknown_38;
        }
    } else {
        uint32_t v9 = v1 >> 6; // 0x3d722
        v3 = v1 >= v9;
        v5 = v1 == v9;
        v4 = v1 >= v9;
        v6 = v1 == v9;
        if (v1 - v9 < 0) {
            goto lab_dec_label_pc_unknown_37;
        } else {
            goto lab_dec_label_pc_unknown_38;
        }
    }
  lab_dec_label_pc_unknown_37:;
    bool v10 = true; // 0x3d72a
    bool v11 = v6; // 0x3d72a
    bool v12 = true; // 0x3d72a
    bool v13 = v6; // 0x3d72a
    if (v4) {
        goto lab_dec_label_pc_unknown_39;
    } else {
        goto lab_0x3d72e;
    }
  lab_dec_label_pc_unknown_38:
    __asm_rscspl(v7, 160, 6);
    v10 = false;
    v11 = v5;
    v12 = false;
    v13 = v5;
    if (v3) {
        goto lab_dec_label_pc_unknown_39;
    } else {
        goto lab_0x3d72e;
    }
  lab_dec_label_pc_unknown_39:;
    int32_t v14 = function_107832e(); // 0x3d72a
    int32_t v15 = v14; // 0x3d736
    int32_t v16 = v14; // 0x3d736
    bool v17 = v10; // 0x3d736
    bool v18 = true; // 0x3d736
    if (v11) {
        goto lab_dec_label_pc_unknown_40;
    } else {
        goto lab_dec_label_pc_unknown_41;
    }
  lab_0x3d72e:
    // 0x3d72e
    v15 = v1;
    v16 = v1;
    v17 = v12;
    v18 = (v7 & 0x4000000) != 0;
    if (v13) {
        goto lab_dec_label_pc_unknown_40;
    } else {
        goto lab_dec_label_pc_unknown_41;
    }
  lab_dec_label_pc_unknown_40:;
    bool v19 = v18; // 0x3d73a
    int32_t result2 = v16; // 0x3d73a
    bool v20 = v18; // 0x3d73a
    int32_t result = v16; // 0x3d73a
    if (v17) {
        goto lab_dec_label_pc_unknown_42;
    } else {
        goto lab_dec_label_pc_unknown_43;
    }
  lab_dec_label_pc_unknown_41:;
    uint32_t v21 = v15 >> 6; // 0x3d736
    v19 = v15 >= v21;
    result2 = v15;
    v20 = v15 >= v21;
    result = v15;
    if (v15 - v21 < 0) {
        goto lab_dec_label_pc_unknown_42;
    } else {
        goto lab_dec_label_pc_unknown_43;
    }
  lab_dec_label_pc_unknown_42:
    if (!v20) {
        // 0x3d742
        return result;
    }
    // 0x3d742
    return function_1178342();
  lab_dec_label_pc_unknown_43:
    __asm_rscpl(0x3d740, 160, 6);
    if (!v19) {
        // 0x3d742
        return result2;
    }
    // 0x3d742
    return function_1178342();
}

// Address range: 0x3d744 - 0x3d754
int32_t function_3d744(int32_t str, int32_t a2, uint32_t a3) {
    // 0x3d744
    return snprintf((char *)str, 80, (char *)(a3 % 0x10000 | 0x60000));
}

// Address range: 0x3d754 - 0x3d7f4
int32_t function_3d754(int32_t a1, int32_t a2) {
    int32_t * v1 = (int32_t *)a1; // 0x3d764
    *v1 = 0;
    if (g458 == 0) {
        // 0x3d7ac
        return 0;
    }
    int32_t v2 = g456; // 0x3d788
    int32_t v3 = 28; // 0x3d788
    if (*(int32_t *)(g456 + 4) != 8) {
      lab_0x3d78c:;
        int32_t result = *(int32_t *)v2 + 1; // 0x3d79c
        int32_t v4 = function_11f28(result, &g254, (int32_t)&g456, (int32_t)&g458); // 0x3d7a4
        *(int32_t *)a2 = v4;
        // 0x3d7ac
        return result;
    }
    uint32_t v5 = 1;
    *v1 = v5;
    while (g458 != v5 && g458 >= v5) {
        int32_t v6 = g456 + v3; // 0x3d7d4
        v2 = v6;
        v3 += 28;
        if (*(int32_t *)(v6 + 4) != 8) {
            goto lab_0x3d78c;
        }
        v5++;
        *v1 = v5;
    }
    // 0x3d7ac
    return 0;
}

// Address range: 0x3d7f4 - 0x3d83c
int32_t function_3d7f4(int32_t a1, int32_t a2) {
    int32_t v1 = a2 + a1; // 0x3d7fc
    unsigned char v2 = *(char *)v1; // 0x3d7fc
    int32_t v3 = v2; // 0x3d7fc
    int32_t v4 = v3 & 223; // 0x3d804
    int32_t result = 0; // 0x3d814
    if (v2 != 61 && v4 != 0) {
        // 0x3d818
        result = v1 + 2;
        *(int32_t *)a2 = function_11f28(result, &g254, v4, v3);
    }
    // 0x3d834
    return result;
}

// Address range: 0x3d83c - 0x3d8f4
int32_t function_3d83c(int32_t a1, uint32_t a2, int32_t a3) {
    // 0x3d83c
    if ((uint32_t)g458 <= a2) {
        // 0x3d8b8
        return 0;
    }
    int32_t v1 = g456 + 28 * a2; // 0x3d87c
    int32_t v2 = a1; // 0x3d888
    int32_t v3 = a2; // 0x3d888
    int32_t v4; // 0x3d894
    int32_t result; // 0x3d8d0
    if (*(int32_t *)(v1 + 4) != 8) {
        if (a1 == 0) {
            // 0x3d8c4
            result = *(int32_t *)v1 + 1;
            *(int32_t *)a3 = function_11f28(result, &g254, v1, a2);
            return result;
        }
        // 0x3d894
        v4 = function_3d7f4(a1, a3);
        v2 = 0;
        v3 = a3;
        if (v4 != 0) {
            // break -> 0x3d8b8
            break;
        }
    }
    int32_t v5 = v3 + 1; // 0x3d8a4
    *(int32_t *)a2 = v5;
    int32_t result2 = 0; // 0x3d8b4
    while (v5 < g458) {
        int32_t v6 = v5;
        int32_t v7 = v2;
        v1 = g456 + 28 * v6;
        v2 = v7;
        v3 = v6;
        if (*(int32_t *)(v1 + 4) != 8) {
            if (v7 == 0) {
                // 0x3d8c4
                result = *(int32_t *)v1 + 1;
                *(int32_t *)a3 = function_11f28(result, &g254, v1, v6);
                return result;
            }
            // 0x3d894
            v4 = function_3d7f4(v7, a3);
            v2 = 0;
            v3 = a3;
            result2 = v4;
            if (v4 != 0) {
                // break -> 0x3d8b8
                break;
            }
        }
        // 0x3d8a4
        v5 = v3 + 1;
        *(int32_t *)a2 = v5;
        result2 = 0;
    }
    // 0x3d8b8
    return result2;
}

// Address range: 0x3d8f4 - 0x3da68
int32_t function_3d8f4(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    uint64_t v2 = *(int64_t *)&v1; // 0x3d8fc
    int32_t v3 = v2;
    int32_t v4 = v2 / 0x100000000; // 0x3d8fc
    int32_t v5 = v3 - 1; // 0x3d900
    if (!((v3 == 4 ? v3 < 4 : v5 == 0)) == (v3 != 4 && v5 != 1)) {
        // 0x3da58
        errx(1, "Option %s: unknown entry type %u", (char *)v4, v3);
        return &g488;
    }
    char * v6 = (char *)v4;
    char * v7 = v6; // 0x3d91c
    int32_t v8 = 0; // 0x3d91c
    int32_t v9; // 0x3d8f4
    int32_t v10; // 0x3d8f4
    int32_t v11; // 0x3d8f4
    int32_t v12; // 0x3d8f4
    int32_t v13; // 0x3d8f4
    int32_t v14; // 0x3d8f4
    int32_t v15; // 0x3d8f4
    int32_t v16; // 0x3d8f4
    char * v17; // bp-28, 0x3d8f4
    if (*(int32_t *)(v3 + 24) == 0) {
        goto lab_0x3da48;
    } else {
        unsigned char v18 = *v6; // 0x3d920
        v8 = v18;
        if (v18 == 45) {
            int32_t v19 = v4 + 1; // 0x3d92c
            int32_t v20 = function_11f28(v19, &g254, v4, v8); // 0x3d94c
            v1 = v20;
            v17 = (char *)v20;
            int32_t * v21 = (int32_t *)(v3 + 4);
            v9 = v20;
            v14 = v19;
            while (true) {
              lab_0x3d9bc:
                // 0x3d9bc
                v15 = v14;
                int32_t v22 = v9; // 0x3d994
                int32_t v23; // 0x3d8f4
                if (*(char *)v15 == 45) {
                    // 0x3d9c8
                    if (v22 == 1) {
                        // break -> 0x3da28
                        break;
                    }
                    // 0x3d9d0
                    g454++;
                    v23 = *v21;
                } else {
                    if (v22 != 1) {
                        int32_t v24 = v15 - 1; // 0x3d9ec
                        errx(1, "Option %s: invalid short option '%.*s'", (char *)v22, v22 + 1, (char *)v24);
                        v1 = &g488;
                        v10 = &g488;
                        v16 = v24;
                        v13 = v12;
                        goto lab_0x3da0c;
                    }
                    int32_t v25 = *v21; // 0x3d968
                    g455++;
                    v23 = v25;
                    if ((v25 - 2 & -3) == 0) {
                        g453++;
                        v23 = v25;
                    }
                }
                // 0x3d98c
                v11 = v23;
                if (v11 == 1) {
                    // 0x3d994
                    v10 = v22;
                    v16 = v15;
                    v13 = 1;
                    switch (*(char *)(v15 + v22)) {
                        case 61: {
                            goto lab_0x3da0c;
                        }
                        case 32: {
                            goto lab_0x3da0c;
                        }
                        default: {
                            goto lab_0x3d9a4;
                        }
                    }
                } else {
                    goto lab_0x3d9a4;
                }
            }
        } else {
            goto lab_0x3da38;
        }
    }
  lab_0x3d9a4:;
    int32_t v26 = function_3d7f4(v15, (int32_t)&v17); // 0x3d9ac
    v1 = v26;
    if (v26 == 0) {
        // 0x3d9e4
        return 0;
    }
    int32_t v27 = (int32_t)v17; // 0x3d9b8
    v1 = v27;
    v9 = v27;
    v14 = v26;
    v12 = v11;
    goto lab_0x3d9bc;
  lab_0x3da0c:;
    int32_t v28 = v10 + 1 + v16; // 0x3da14
    errx(v13, "Option %s: does not take arguments '%s'", (char *)v10, (char *)v28);
    v1 = &g488;
    goto lab_0x3da28;
  lab_0x3da48:
    // 0x3da48
    errx(1, "Option %s: description cannot be NULL", v7);
    // 0x3da58
    errx(1, "Option %s: unknown entry type %u", v7, v8);
    return &g488;
  lab_0x3da38:
    // 0x3da38
    v7 = v6;
    errx(1, "Option %s: does not begin with '-'", v7);
    goto lab_0x3da48;
  lab_0x3da28:;
    // 0x3da28
    int32_t v29; // 0x3d8f4
    int32_t v30 = v29;
    char * v31 = (char *)v30;
    errx(v30, "Option %s: invalid long option '--'", v31);
    goto lab_0x3da38;
}

// Address range: 0x3da68 - 0x3dacc
int32_t function_3da68(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    int32_t v2; // 0x3da68
    int32_t v3 = function_1209c(g456, 28 * g458 + 28, v2, v2); // 0x3da94
    int32_t v4 = g458; // 0x3da98
    g456 = v3;
    g458 = v4 + 1;
    int32_t v5 = 28 * v4 + v3; // 0x3dab8
    *(int32_t *)v5 = v3;
    *(int32_t *)(v5 + 4) = *(int32_t *)(v1 + 4);
    *(int32_t *)(v5 + 8) = *(int32_t *)(v1 + 8);
    *(int32_t *)(v5 + 12) = *(int32_t *)(v1 + 12);
    int32_t result = *(int32_t *)(v1 + 16); // 0x3dac0
    *(int32_t *)(v5 + 16) = result;
    *(int32_t *)(v5 + 20) = *(int32_t *)(v1 + 20);
    *(int32_t *)(v5 + 24) = *(int32_t *)(v1 + 24);
    return result;
}

// Address range: 0x3dacc - 0x3db24
int32_t function_3dacc(int32_t * a1, int32_t * a2) {
    int32_t v1 = (int32_t)a2;
    int32_t v2 = (int32_t)a1;
    int32_t v3 = function_3d754(v2, v1); // 0x3dad8
    if (v3 == 0) {
        // 0x3db1c
        return 0;
    }
    int32_t v4 = v3; // 0x3db04
    if (*(char *)v3 == 45) {
        // 0x3db08
        *a2 = v1 - 1;
        return v3 + 1;
    }
    v4 = function_3d83c(v4, v2, v1);
    while (v4 != 0) {
        int32_t v5 = v4; // 0x3db04
        if (*(char *)v4 == 45) {
            // 0x3db08
            *a2 = v2 - 1;
            return v5 + 1;
        }
        v4 = function_3d83c(v4, v2, v1);
    }
    // 0x3db1c
    return 0;
}

// Address range: 0x3db24 - 0x3db7c
int32_t function_3db24(int32_t a1, int32_t a2, int32_t * a3) {
    int32_t v1 = (int32_t)a3;
    int32_t v2 = function_3d83c(a1, a2, v1); // 0x3db30
    if (v2 == 0) {
        // 0x3db74
        return 0;
    }
    int32_t v3 = v2;
    while (*(char *)v3 != 45) {
        int32_t v4 = function_3d83c(v3, a2, v1); // 0x3db48
        if (v4 == 0) {
            // 0x3db74
            return 0;
        }
        v3 = v4;
    }
    // 0x3db60
    *a3 = v1 - 1;
    return v3 + 1;
}

// Address range: 0x3db7c - 0x3dbdc
int32_t function_3db7c(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    int32_t v2 = 0; // bp-20, 0x3db90
    int32_t v3 = &v2; // 0x3db94
    int32_t v4 = function_3d754(v1, v3); // 0x3db98
    if (v4 == 0) {
        // 0x3dbc8
        return 0;
    }
    int32_t v5 = v4; // 0x3dba0
    int32_t result = v5; // 0x3dbc4
    while (*(char *)v5 == 45) {
        // 0x3dba8
        v5 = function_3d83c(v5, v1, v3);
        result = 0;
        if (v5 == 0) {
            // break -> 0x3dbc8
            break;
        }
        result = v5;
    }
    // 0x3dbc8
    return result;
}

// Address range: 0x3dbdc - 0x3dc3c
int32_t function_3dbdc(int32_t a1, int32_t a2) {
    int32_t v1 = 1; // bp-20, 0x3dbf0
    int32_t v2 = &v1; // 0x3dbf4
    int32_t v3 = function_3d83c(a1, a2, v2); // 0x3dbf8
    if (v3 == 0) {
        // 0x3dc28
        return 0;
    }
    int32_t v4 = v3; // 0x3dc00
    int32_t result = v4; // 0x3dc24
    while (*(char *)v4 == 45) {
        // 0x3dc08
        v4 = function_3d83c(v4, a2, v2);
        result = 0;
        if (v4 == 0) {
            // break -> 0x3dc28
            break;
        }
        result = v4;
    }
    // 0x3dc28
    return result;
}

// Address range: 0x3dc3c - 0x3dc80
int32_t function_3dc3c(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    int32_t v1 = a1; // bp-36, 0x3dc54
    function_3d8f4(&v1);
    return function_3da68(&v1);
}

// Address range: 0x3dc80 - 0x3dd54
int32_t function_3dc80(char (**a1)[15], char * a2) {
    int32_t result = (int32_t)a1;
    int32_t v1 = g458; // 0x3dc98
    int32_t v2; // 0x3dc80
    if (a2 == NULL) {
        int32_t v3 = *(int32_t *)(result + 4); // 0x3dd30
        v2 = v3;
        if (v3 == 16) {
            // 0x3dd28
            return result;
        }
        goto lab_0x3dcd8;
    } else {
        int32_t v4 = 0; // bp-52, 0x3dcac
        function_3da68(&v4);
        int32_t v5 = *(int32_t *)(result + 4); // 0x3dccc
        v2 = v5;
        if (v5 == 16) {
            goto lab_0x3dd08;
        } else {
            goto lab_0x3dcd8;
        }
    }
  lab_0x3dcd8:;
    // 0x3dcd8
    int32_t result2; // 0x3dc80
    int32_t * v6; // 0x3dce4
    int32_t v7; // 0x3dd44
    if (v2 == 8) {
        // 0x3dd44
        v7 = *(int32_t *)(result + 24);
        result2 = function_3dc80((char (**)[15])*(int32_t *)result, (char *)v7);
    } else {
        // 0x3dce4
        v6 = (int32_t *)result;
        function_3d8f4(v6);
        result2 = function_3da68(v6);
    }
    int32_t v8 = *(int32_t *)(result + 32); // 0x3dcf4
    int32_t v9 = result + 28; // 0x3dcfc
    while (v8 != 16) {
        int32_t v10 = v9;
        if (v8 == 8) {
            // 0x3dd44
            v7 = *(int32_t *)(v10 + 24);
            int32_t v11 = *(int32_t *)v10; // 0x3dd48
            result2 = function_3dc80((char (**)[15])v11, (char *)v7);
        } else {
            // 0x3dce4
            v6 = (int32_t *)v10;
            function_3d8f4(v6);
            result2 = function_3da68(v6);
        }
        // 0x3dcf0
        v8 = *(int32_t *)(v10 + 32);
        v9 = v10 + 28;
    }
    // 0x3dd00
    if (a2 == NULL) {
        // 0x3dd28
        return result2;
    }
    goto lab_0x3dd08;
  lab_0x3dd08:
    // 0x3dd08
    *(int32_t *)(28 * v1 + 20 + g456) = g458 - v1;
    // 0x3dd28
    return 7 * v1;
}

// Address range: 0x3dd54 - 0x3ddb0
int32_t function_3dd54(int32_t * a1, int32_t a2, int32_t a3) {
    // 0x3dd54
    g457 = a2;
    int32_t v1 = 0; // bp-28, 0x3dd80
    while (function_3dec0((int32_t)a1, a2, &v1, a3) == 1) {
        // continue -> 0x3dd84
    }
    // 0x3dda0
    return 0;
}

// Address range: 0x3ddb0 - 0x3ddd0
int32_t function_3ddb0(void) {
    // 0x3ddb0
    int32_t v1; // 0x3ddb0
    int32_t result = free(g456, v1, v1, v1); // 0x3ddc0
    g456 = 0;
    return result;
}

// Address range: 0x3ddd0 - 0x3de18
int32_t function_3ddd0(int32_t format, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = a2; // bp-12, 0x3ddd0
    vfprintf(g316, (char *)format, (int32_t)&v1);
    return fputc(10, g316);
}

// Address range: 0x3de18 - 0x3de44
int32_t function_3de18(int32_t format, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = a2; // bp-12, 0x3de18
    return vfprintf(g316, (char *)format, (int32_t)&v1);
}

// Address range: 0x3de46 - 0x3de48
int32_t function_3de46(void) {
    // 0x3de46
    int32_t result; // 0x3de46
    return result;
}

// Address range: 0x3de48 - 0x3de58
int32_t function_3de48(void) {
    // 0x3de48
    int32_t stream; // 0x3de48
    fputc(10, (struct _IO_FILE *)stream);
    exit(1);
    return &g488;
}

// Address range: 0x3de58 - 0x3de88
int32_t function_3de58(int32_t a1) {
    char * str = (char *)a1; // 0x3de60
    int32_t * mem = malloc(strlen(str) + 22); // 0x3de68
    sprintf((char *)mem, "Invalid argument '%s'", str);
    return (int32_t)mem;
}

// Address range: 0x3de88 - 0x3dec0
int32_t function_3de88(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = 4 * a3 + a2;
    int32_t result = function_11f64(v1, v1 + 4, 4 * (a1 - a3), a1); // 0x3deac
    *(int32_t *)a1 = result - 1;
    return result;
}

// Address range: 0x3dec0 - 0x3e7b4
int32_t function_3dec0(int32_t a1, int32_t a2, int32_t * a3, int32_t a4) {
    int32_t v1 = (int32_t)a3;
    char * env_val = getenv("POSIXLY_CORRECT"); // 0x3dee0
    int32_t v2 = a2 + 4;
    int32_t v3 = *(int32_t *)v2; // 0x3dee8
    int32_t v4; // 0x3dec0
    int32_t v5; // 0x3dec0
    int32_t v6; // 0x3dec0
    int32_t v7; // 0x3dec0
    int32_t v8; // 0x3dec0
    int32_t v9; // 0x3dec0
    int32_t v10; // 0x3dec0
    if (env_val == NULL) {
        // 0x3df14
        if (v3 == 0) {
            // 0x3df0c
            return 0;
        }
        int32_t v11 = v3; // 0x3df24
        int32_t v12 = v1; // 0x3df24
        int32_t v13 = 1; // 0x3df24
        int32_t v14 = v2; // 0x3df24
        if (*(char *)v3 != 45) {
            int32_t v15 = 1; // 0x3df30
            int32_t v16 = a2 + 8;
            int32_t v17 = *(int32_t *)v16; // 0x3df44
            while (v17 != 0) {
                // 0x3df34
                v15++;
                v11 = v17;
                v12 = 45;
                v13 = v15;
                v14 = v16;
                if (*(char *)v17 == 45) {
                    goto lab_0x3df60;
                }
                v16 += 4;
                v17 = *(int32_t *)v16;
            }
        }
      lab_0x3df60:
        // 0x3df60
        v5 = v12;
        v7 = v13;
        v9 = v14;
        v4 = v11;
        v6 = v12;
        v8 = v13;
        v10 = v14;
        if (*(char *)(v11 + 1) == 45) {
            goto lab_0x3e02c;
        } else {
            goto lab_0x3df6c;
        }
    } else {
        // 0x3def0
        if (v3 == 0 || *(char *)v3 != 45) {
            // 0x3df0c
            return 0;
        }
        // 0x3e050
        v5 = v1;
        v7 = 1;
        v9 = v2;
        v4 = v3;
        v6 = v1;
        v8 = 1;
        v10 = v2;
        if (*(char *)(v3 + 1) == 45) {
            goto lab_0x3e02c;
        } else {
            goto lab_0x3df6c;
        }
    }
  lab_0x3dfa4:;
    // 0x3dfa4
    int32_t v18; // 0x3df78
    int32_t v19 = v18 - 1; // 0x3dfa8
    int32_t v20; // 0x3df90
    *a3 = v20;
    int32_t v21 = 2; // bp-44, 0x3dfc8
    int32_t v22; // bp-48, 0x3dec0
    int32_t v23 = 28 * v22; // 0x3dfcc
    int32_t v24 = g456 + v23; // 0x3dfd0
    int32_t v25 = v19; // 0x3dfdc
    int32_t v26 = v23; // 0x3dfdc
    int32_t v27 = v24; // 0x3dfdc
    int32_t v28 = v7; // 0x3dfdc
    int32_t v29 = v9; // 0x3dfdc
    int32_t * v30; // 0x3dec0
    int32_t v31; // 0x3dec0
    int32_t v32; // 0x3dec0
    int32_t v33; // 0x3dec0
    int32_t v34; // 0x3dec0
    int32_t v35; // 0x3dec0
    int32_t v36; // 0x3dec0
    int32_t v37; // 0x3dec0
    int32_t v38; // 0x3dec0
    int32_t v39; // 0x3dec0
    int32_t v40; // 0x3dec0
    int32_t v41; // 0x3dec0
    int32_t v42; // 0x3dec0
    int32_t v43; // 0x3dec0
    int32_t * v44; // 0x3dec0
    if (*(int32_t *)(v24 + 4) == 1) {
        goto lab_0x3e170;
    } else {
        // 0x3dfe0
        v32 = v22;
        v41 = v9;
        v39 = v7;
        v37 = &g456;
        v35 = v23;
        v43 = v19;
        v30 = v44;
        v31 = v22;
        v40 = v9;
        v38 = v7;
        v36 = &g456;
        v34 = v23;
        v33 = v20;
        v42 = v19;
        if (v20 == 0) {
            goto lab_0x3dfe8;
        } else {
            goto lab_0x3e1dc;
        }
    }
  lab_0x3e138:;
    // 0x3e138
    int32_t str; // 0x3dec0
    strlen((char *)*(int32_t *)str);
    // 0x3df0c
    return -1;
  lab_0x3e120:;
    // 0x3e120
    int32_t str2; // 0x3dec0
    int32_t v45 = function_3db24(str2, (int32_t)&v22, &v21); // 0x3e12c
    int32_t v46 = v45; // 0x3e134
    str = v10;
    if (v45 == 0) {
        goto lab_0x3e138;
    }
    goto lab_0x3e09c;
  lab_0x3e02c:
    // 0x3e02c
    if (*(char *)(v4 + 2) == 0) {
        // 0x3e038
        function_3de88(a1, a2, v8);
        // 0x3df0c
        return 0;
    }
    // 0x3e064
    if (v6 != 0) {
        // 0x3e350
        __assert_fail("*offset == 0", "ccan/opt/parse.c", 59, "parse_one");
        int32_t v53 = strlen((char *)&g488) + 20 + g455 + strlen("ccan/opt/parse.c"); // 0x3e3b8
        int32_t size = v53; // 0x3e3bc
        if (g458 != 0) {
            int32_t v54 = g456; // 0x3e3dc
            int32_t v55 = v53; // 0x3e3dc
            int32_t v56 = 0; // 0x3e3dc
            while (true) {
                int32_t v57 = v56;
                int32_t v58 = v55;
                int32_t str4 = v54;
                int32_t str3 = *(int32_t *)(str4 + 24); // 0x3e430
                int32_t v59; // 0x3dec0
                int32_t v60; // 0x3dec0
                if (*(int32_t *)(str4 + 4) == 8) {
                    int32_t v61 = v57 + 1; // 0x3e440
                    int32_t v62 = v58 + 3 + strlen((char *)str3); // 0x3e450
                    v59 = v62;
                    v60 = v61;
                    size = v62;
                    if (v61 >= g458) {
                        // break -> 0x3e460
                        break;
                    }
                } else {
                    int32_t v63 = v58; // 0x3e3e4
                    if (str3 != (int32_t)&g459) {
                        int32_t len = strlen((char *)*(int32_t *)str4); // 0x3e3ec
                        int32_t len2 = strlen((char *)str3); // 0x3e3f8
                        int32_t v64 = *(int32_t *)(str4 + 16); // 0x3e3fc
                        v63 = v58 + 7 + len + len2 + (v64 == 0 ? 21 : 118);
                    }
                    int32_t v65 = v57 + 1; // 0x3e418
                    v59 = v63;
                    v60 = v65;
                    size = v63;
                    if (v65 >= g458) {
                        // break -> 0x3e460
                        break;
                    }
                }
                // 0x3e428
                v54 = str4 + 28;
                v55 = v59;
                v56 = v60;
            }
        }
        int32_t * mem = malloc(size); // 0x3e464
        int32_t result = (int32_t)mem; // 0x3e464
        if (mem == NULL) {
            // 0x3df0c
            return result;
        }
        int32_t v66 = sprintf((char *)mem, "Usage: %s", (char *)&g488) + result; // 0x3e494
        *(int32_t *)v66 = (int32_t)&g24;
        int32_t v67; // bp-188, 0x3dec0
        int32_t v68 = function_3db7c(&v67); // 0x3e4a8
        int32_t v69 = v66; // 0x3e4b0
        if (v68 != 0) {
            int32_t v70 = v66 + 3; // 0x3e49c
            int32_t v71 = 0;
            int32_t v72 = *(int32_t *)(28 * v67 + 24 + g456); // 0x3e4e0
            if (v72 != (int32_t)&g459) {
                *(char *)(v71 + v70) = *(char *)v68;
            }
            int32_t v73 = v71 + (int32_t)(v72 != (int32_t)&g459);
            int32_t v74 = function_3dbdc(v68, (int32_t)&v67); // 0x3e4f4
            while (v74 != 0) {
                int32_t v75 = v74;
                v71 = v73;
                v72 = *(int32_t *)(28 * v67 + 24 + g456);
                if (v72 != (int32_t)&g459) {
                    *(char *)(v71 + v70) = *(char *)v75;
                }
                // .thread
                v73 = v71 + (int32_t)(v72 != (int32_t)&g459);
                v74 = function_3dbdc(v75, (int32_t)&v67);
            }
            // 0x3e500
            v69 = v66;
            if (v73 != 0) {
                int32_t v76 = v73 + v70; // 0x3e724
                *(int16_t *)v76 = 93;
                v69 = v76 + 1;
            }
        }
        int32_t str5 = v69;
        int32_t v77 = sprintf((char *)str5, " %s") + str5; // 0x3e528
        int32_t v78 = v77 + 1; // 0x3e530
        int16_t v79 = *(int16_t *)&g261; // 0x3e534
        *(int16_t *)v77 = v79;
        int32_t v80 = v78; // 0x3e540
        if (g458 != 0) {
            int32_t v81 = 0;
            int32_t str6 = v78;
            int32_t v82 = g456 + v81; // 0x3e63c
            int32_t v83 = *(int32_t *)(v82 + 24); // 0x3e640
            int32_t v84 = str6; // 0x3e648
            int32_t v85; // 0x3dec0
            int32_t v86; // 0x3dec0
            int32_t str8; // 0x3dec0
            int32_t v87; // 0x3dec0
            int32_t v88; // 0x3dec0
            uint32_t v89; // 0x3dec0
            int32_t v90; // 0x3dec0
            int32_t chars_printed; // 0x3e664
            int32_t v91; // 0x3e670
            int32_t v92; // 0x3e674
            int32_t v93; // 0x3e684
            char * str7; // 0x3e698
            int32_t str9; // 0x3dec0
            int32_t v94; // 0x3e5b4
            int32_t str10; // 0x3dec0
            int32_t v95; // 0x3e6cc
            if (v83 != (int32_t)&g459) {
                // 0x3e64c
                if (*(int32_t *)(v82 + 4) == 8) {
                    // 0x3e708
                    v84 = sprintf((char *)str6, "%s:\n", (char *)v83) + str6;
                } else {
                    // 0x3e658
                    chars_printed = sprintf((char *)str6, "%s", (char *)*(int32_t *)v82);
                    v91 = chars_printed + str6;
                    v92 = g456 + v81;
                    v86 = g456;
                    str8 = v91;
                    v88 = chars_printed;
                    if (*(int32_t *)(v92 + 4) == 2) {
                        // 0x3e684
                        v93 = *(int32_t *)v92;
                        str7 = (char *)v93;
                        v86 = v93;
                        str8 = v91;
                        v88 = chars_printed;
                        if (strchr(str7, 32) == NULL) {
                            // 0x3e6ac
                            v86 = v93;
                            str8 = v91;
                            v88 = chars_printed;
                            if (strchr(str7, 61) == NULL) {
                                // 0x3e6c8
                                v95 = chars_printed + 6;
                                *(int32_t *)v91 = 0x72613c20;
                                *(int16_t *)(v91 + 4) = 0x3e67;
                                *(char *)(v91 + 6) = 0;
                                v86 = 0;
                                str8 = v95 + str6;
                                v88 = v95;
                            }
                        }
                    }
                    // 0x3e580
                    v89 = v88;
                    v90 = v89 == 19 | v89 < 19 ? 20 - v89 : v86;
                    v85 = v89 >= 19 == (v89 != 19) ? 1 : v90;
                    str9 = sprintf((char *)str8, "%.*s", v85, "                    ") + v89 + str6;
                    v94 = *(int32_t *)(v81 + 24 + g456);
                    str10 = str9 + sprintf((char *)str9, "%s", (char *)v94);
                    v87 = str10;
                    if (*(int32_t *)(v81 + 16 + g456) != 0) {
                        // 0x3e5d8
                        v87 = sprintf((char *)str10, " (default: %s)", &v67) + str10;
                    }
                    // 0x3e614
                    *(int16_t *)v87 = v79;
                    v84 = v87 + 1;
                }
            }
            uint32_t v96 = g458; // 0x3e624
            int32_t v97 = 1; // 0x3e628
            int32_t v98 = v81 + 28; // 0x3e634
            int32_t v99 = v97; // 0x3e634
            v80 = v84;
            while (v96 != v97 && v96 >= v97) {
                // 0x3e638
                v81 = v98;
                str6 = v84;
                v82 = g456 + v81;
                v83 = *(int32_t *)(v82 + 24);
                v84 = str6;
                if (v83 != (int32_t)&g459) {
                    // 0x3e64c
                    if (*(int32_t *)(v82 + 4) == 8) {
                        // 0x3e708
                        v84 = sprintf((char *)str6, "%s:\n", (char *)v83) + str6;
                    } else {
                        // 0x3e658
                        chars_printed = sprintf((char *)str6, "%s", (char *)*(int32_t *)v82);
                        v91 = chars_printed + str6;
                        v92 = g456 + v81;
                        v86 = g456;
                        str8 = v91;
                        v88 = chars_printed;
                        if (*(int32_t *)(v92 + 4) == 2) {
                            // 0x3e684
                            v93 = *(int32_t *)v92;
                            str7 = (char *)v93;
                            v86 = v93;
                            str8 = v91;
                            v88 = chars_printed;
                            if (strchr(str7, 32) == NULL) {
                                // 0x3e6ac
                                v86 = v93;
                                str8 = v91;
                                v88 = chars_printed;
                                if (strchr(str7, 61) == NULL) {
                                    // 0x3e6c8
                                    v95 = chars_printed + 6;
                                    *(int32_t *)v91 = 0x72613c20;
                                    *(int16_t *)(v91 + 4) = 0x3e67;
                                    *(char *)(v91 + 6) = 0;
                                    v86 = 0;
                                    str8 = v95 + str6;
                                    v88 = v95;
                                }
                            }
                        }
                        // 0x3e580
                        v89 = v88;
                        v90 = v89 == 19 | v89 < 19 ? 20 - v89 : v86;
                        v85 = v89 >= 19 == (v89 != 19) ? 1 : v90;
                        str9 = sprintf((char *)str8, "%.*s", v85, "                    ") + v89 + str6;
                        v94 = *(int32_t *)(v81 + 24 + g456);
                        str10 = str9 + sprintf((char *)str9, "%s", (char *)v94);
                        v87 = str10;
                        if (*(int32_t *)(v81 + 16 + g456) != 0) {
                            // 0x3e5d8
                            v87 = sprintf((char *)str10, " (default: %s)", &v67) + str10;
                        }
                        // 0x3e614
                        *(int16_t *)v87 = v79;
                        v84 = v87 + 1;
                    }
                }
                // 0x3e624
                v96 = g458;
                v97 = v99 + 1;
                v98 = v81 + 28;
                v99 = v97;
                v80 = v84;
            }
        }
        // 0x3e6f4
        *(char *)v80 = 0;
        // 0x3df0c
        return result;
    }
    int32_t v100 = function_3dacc(&v22, &v21); // 0x3e080
    str = v10;
    int32_t v101; // 0x3dec0
    int32_t v102; // 0x3dec0
    int32_t v103; // 0x3dec0
    int32_t v104; // 0x3dec0
    int32_t v105; // 0x3dec0
    int32_t v106; // 0x3dec0
    int32_t v107; // 0x3dec0
    if (v100 == 0) {
        goto lab_0x3e138;
    } else {
        int32_t * v48 = (int32_t *)v10;
        v46 = v100;
        int32_t v47; // 0x3e09c
        int32_t n; // 0x3e0a4
        int32_t v49; // 0x3e0bc
        while (true) {
          lab_0x3e09c:
            // 0x3e09c
            str2 = v46;
            v47 = *v48;
            n = v21;
            if (strncmp((char *)(v47 + 2), (char *)str2, n) == 0) {
                // 0x3e0bc
                v49 = n + 2;
                switch (*(char *)(v49 + v47)) {
                    case 61: {
                        goto lab_0x3e290;
                    }
                    case 0: {
                        int32_t v50 = str2 - 2; // 0x3e0ec
                        int32_t v51 = 28 * v22; // 0x3e100
                        v21 = v49;
                        int32_t v52 = *(int32_t *)((int32_t)&g425 | 0xee1c) + v51; // 0x3e108
                        v25 = v50;
                        v26 = v51;
                        v27 = v52;
                        v28 = v8;
                        v29 = v10;
                        v30 = v48;
                        v31 = v22;
                        v40 = v10;
                        v38 = v8;
                        v36 = (int32_t)&g425 | 0xee1c;
                        v34 = v51;
                        v33 = (int32_t)&g425 | 0xee1c;
                        v42 = v50;
                        if (*(int32_t *)(v52 + 4) == 1) {
                            goto lab_0x3e170;
                        } else {
                            goto lab_0x3e1dc;
                        }
                    }
                    default: {
                        goto lab_0x3e120;
                    }
                }
            } else {
                goto lab_0x3e120;
            }
        }
      lab_0x3e290:;
        int32_t v108 = 28 * v22; // 0x3e2c0
        int32_t v109 = v47 + 3 + n; // 0x3e2c4
        int32_t v110 = str2 - 2; // 0x3e2c8
        v21 = v49;
        int32_t v111 = *(int32_t *)((int32_t)&g425 | 0xee1c) + v108; // 0x3e2d4
        if (*(int32_t *)(v111 + 4) == 1) {
            // 0x3e31c
            v25 = v110;
            v26 = v108;
            v27 = v111;
            v28 = v8;
            v29 = v10;
            if (v109 != 0) {
                // 0x3df0c
                return -1;
            }
            goto lab_0x3e170;
        } else {
            // 0x3e2e4
            v107 = v110;
            v102 = v108;
            v103 = (int32_t)&g425 | 0xee1c;
            v104 = v8;
            v105 = v10;
            v106 = v109;
            v101 = v22;
            v30 = v48;
            v31 = v22;
            v40 = v10;
            v38 = v8;
            v36 = (int32_t)&g425 | 0xee1c;
            v34 = v108;
            v33 = (int32_t)&g425 | 0xee1c;
            v42 = v110;
            if (v109 == 0) {
                goto lab_0x3e1dc;
            } else {
                goto lab_0x3dff8;
            }
        }
    }
  lab_0x3df6c:
    // 0x3df6c
    v18 = function_3db7c(&v22);
    str = v9;
    if (v18 == 0) {
        goto lab_0x3e138;
    } else {
        // 0x3df84
        v44 = (int32_t *)v9;
        char v112 = *(char *)v18; // 0x3df8c
        v20 = v5 + 1;
        char v113 = *(char *)(*v44 + v20); // 0x3df94
        char v114 = v112; // 0x3dfa0
        if (v112 == v113) {
            goto lab_0x3dfa4;
        } else {
            int32_t v115; // 0x3dec0
            int32_t v116 = function_3dbdc(v18, v112 == v113 ? v115 : (int32_t)&v22); // 0x3e204
            while (v116 != 0) {
                char v117 = *(char *)(*v44 + (int32_t)v114 + 1); // 0x3e220
                v114 = v117;
                if (v117 == *(char *)v116) {
                    goto lab_0x3dfa4;
                }
                v116 = function_3dbdc(v116, v112 == v113 ? v115 : (int32_t)&v22);
            }
            goto lab_0x3e138;
        }
    }
  lab_0x3e170:;
    int32_t v118 = v25; // 0x3e180
    int32_t v119 = v26; // 0x3e180
    int32_t v120 = v27 + 8; // 0x3e180
    int32_t v121 = v28; // 0x3e180
    int32_t v122 = v29; // 0x3e180
    int32_t v123 = 0; // 0x3e180
    int32_t v124 = *(int32_t *)(v27 + 20); // 0x3e180
    goto lab_0x3e184;
  lab_0x3e1dc:;
    int32_t v127 = v33 + 1 + *v30; // 0x3e1e4
    v32 = v31;
    v41 = v40;
    v39 = v38;
    v37 = v36;
    v35 = v34;
    v43 = v42;
    if (*(char *)v127 == 0) {
        goto lab_0x3dfe8;
    } else {
        *a3 = 0;
        v107 = v42;
        v102 = v34;
        v103 = v36;
        v104 = v38;
        v105 = v40;
        v106 = v127;
        v101 = v31;
        goto lab_0x3dff8;
    }
  lab_0x3dff8:;
    int32_t * v128 = (int32_t *)v103; // 0x3dff8
    int32_t v129 = *v128; // 0x3dff8
    int32_t v130 = v129 + v102; // 0x3dffc
    int32_t v131 = v129; // 0x3e008
    int32_t v132 = v101; // 0x3e008
    if (*(int32_t *)(v130 + 4) == 4) {
        // 0x3e270
        function_3d3d4(v106, (int32_t *)*(int32_t *)(v130 + 20));
        v131 = *v128;
        v132 = v22;
    }
    int32_t v133 = 28 * v132 + v131; // 0x3e014
    v118 = v107;
    v119 = *(int32_t *)(v133 + 20);
    v120 = v133 + 12;
    v121 = v104;
    v122 = v105;
    v123 = v106;
    v124 = v106;
    goto lab_0x3e184;
  lab_0x3e184:
    // 0x3e184
    if (v124 != 0) {
        // 0x3e244
        free(v124, v119, v21, v118);
        // 0x3df0c
        return -1;
    }
    int32_t v125 = *(int32_t *)v120;
    if (v125 != 0) {
        // 0x3e198
        if (*(char *)(v125 + 1 + *(int32_t *)v122) != 0) {
            // 0x3df0c
            return 1;
        }
        // 0x3e1ac
        *a3 = 0;
    }
    // 0x3e1b0
    function_3de88(a1, a2, v121);
    if (v123 == 0) {
        // 0x3df0c
        return 1;
    }
    // 0x3e1c8
    if (*(int32_t *)v122 == v123) {
        // 0x3e230
        function_3de88(a1, a2, v121);
    }
    // 0x3df0c
    return 1;
  lab_0x3dfe8:;
    int32_t v126 = *(int32_t *)(4 * v39 + v2); // 0x3dfec
    v107 = v43;
    v102 = v35;
    v103 = v37;
    v104 = v39;
    v105 = v41;
    v106 = v126;
    v101 = v32;
    if (v126 == 0) {
        // 0x3df0c
        return -1;
    }
    goto lab_0x3dff8;
}

// Address range: 0x3e7b4 - 0x3e8c8
int32_t memchr(int32_t result3, char a2, int32_t a3) {
    // 0x3e7b4
    if (a3 == 0) {
        // 0x3e804
        return 0;
    }
    int32_t result = result3; // 0x3e7c8
    int32_t v1 = a3; // 0x3e7c8
    int32_t result2; // 0x3e7b4
    if (result3 % 4 == 0) {
      lab_0x3e888:
        // 0x3e888
        if (*(char *)result == a2) {
            // 0x3e804
            return result;
        }
        int32_t v2 = result; // 0x3e89c
        v2++;
        result2 = 0;
        while (v2 != v1 + result) {
            // 0x3e8a0
            result2 = v2;
            if (*(char *)v2 == a2) {
                // break -> 0x3e804
                break;
            }
            v2++;
            result2 = 0;
        }
        // 0x3e804
        return result2;
    }
    int32_t v3 = a3; // 0x3e7d4
    if ((char)result3 == a2) {
        // 0x3e804
        return result3;
    }
    int32_t v4 = result3; // 0x3e7d4
    result2 = 0;
    while (v3 != 1) {
        // 0x3e7e0
        v4++;
        v3--;
        result = v4;
        v1 = v3;
        if (v4 % 4 == 0) {
            goto lab_0x3e888;
        }
        // 0x3e7ec
        result2 = v4;
        if (*(char *)v4 == a2) {
            // break -> 0x3e804
            break;
        }
        result2 = 0;
    }
    // 0x3e804
    return result2;
}

// Address range: 0x3e8c8 - 0x3e9d8
int32_t function_3e8c8(int32_t a1, uint32_t a2, int32_t * a3) {
    int32_t v1 = 1; // 0x3e8e8
    int32_t v2 = 0; // 0x3e8e8
    int32_t v3 = -1; // 0x3e8e8
    int32_t v4 = -1; // 0x3e8e8
    int32_t v5 = 1; // 0x3e8e8
    if (a2 > 1) {
        int32_t v6; // 0x3e8c8
        int32_t v7; // 0x3e8c8
        while (true) {
            // 0x3e8ec
            v6 = v3;
            int32_t v8 = v6 + a1;
            char * v9 = (char *)(v8 + 1);
            int32_t v10 = 1;
            unsigned char v11 = *(char *)(v10 + v8); // 0x3e8ec
            unsigned char v12 = *(char *)(v1 + a1); // 0x3e8f0
            int32_t v13 = v1; // 0x3e8f8
            int32_t v14 = v1; // 0x3e8f8
            int32_t v15 = v2; // 0x3e8f8
            int32_t v16 = 1; // 0x3e8f8
            int32_t v17 = v10; // 0x3e8f8
            char v18 = v11; // 0x3e8f8
            char v19 = v12; // 0x3e8f8
            unsigned char v20; // 0x3e8ec
            unsigned char v21; // 0x3e8f0
            int32_t v22; // 0x3e908
            if (v12 < v11) {
                v7 = v13;
                v22 = v7 + 1;
                if (v22 >= a2) {
                    // break (via goto) -> 0x3e918
                    goto lab_0x3e918;
                }
                // 0x3e8ec
                v20 = *v9;
                v21 = *(char *)(v22 + a1);
                while (v21 < v20) {
                    // 0x3e8fc
                    v7 = v22;
                    v22 = v7 + 1;
                    if (v22 >= a2) {
                        // break (via goto) -> 0x3e918
                        goto lab_0x3e918;
                    }
                    // 0x3e8ec
                    v20 = *v9;
                    v21 = *(char *)(v22 + a1);
                }
                // 0x3e980
                v14 = v22;
                v15 = v7;
                v16 = v7 - v6;
                v17 = 1;
                v18 = v20;
                v19 = v21;
            }
            // 0x3e980
            v3 = v15;
            while (v19 == v18) {
                int32_t v23 = v17;
                int32_t v24 = v23 == v16 ? v14 : v3;
                v10 = v23 == v16 ? 1 : v23 + 1;
                int32_t v25 = v10 + v24; // 0x3e8dc
                v4 = v6;
                v5 = v16;
                if (v25 >= a2) {
                    goto lab_0x3e918_3;
                }
                v11 = *(char *)(v10 + v8);
                v12 = *(char *)(v25 + a1);
                v13 = v25;
                v14 = v25;
                v15 = v24;
                v17 = v10;
                v18 = v11;
                v19 = v12;
                if (v12 < v11) {
                    v7 = v13;
                    v22 = v7 + 1;
                    if (v22 >= a2) {
                        // break (via goto) -> 0x3e918
                        goto lab_0x3e918;
                    }
                    // 0x3e8ec
                    v20 = *v9;
                    v21 = *(char *)(v22 + a1);
                    while (v21 < v20) {
                        // 0x3e8fc
                        v7 = v22;
                        v22 = v7 + 1;
                        if (v22 >= a2) {
                            // break (via goto) -> 0x3e918
                            goto lab_0x3e918;
                        }
                        // 0x3e8ec
                        v20 = *v9;
                        v21 = *(char *)(v22 + a1);
                    }
                    // 0x3e980
                    v14 = v22;
                    v15 = v7;
                    v16 = v7 - v6;
                    v17 = 1;
                    v18 = v20;
                    v19 = v21;
                }
                // 0x3e980
                v3 = v15;
            }
            // 0x3e984
            v1 = v3 + 2;
            v2 = v3 + 1;
            v4 = v3;
            v5 = 1;
            if (v1 >= a2) {
                goto lab_0x3e918_3;
            }
        }
      lab_0x3e918:
        // 0x3e918
        v4 = v6;
        v5 = v7 - v6;
    }
  lab_0x3e918_3:
    // 0x3e918
    *a3 = v5;
    int32_t v26 = 1; // 0x3e938
    int32_t v27 = -1; // 0x3e938
    int32_t v28 = 0; // 0x3e938
    int32_t v29 = -1; // 0x3e938
    int32_t v30 = 1; // 0x3e938
    if (a2 != 1 && a2 != 0) {
        int32_t v31; // 0x3e8c8
        int32_t v32; // 0x3e8c8
        while (true) {
            // 0x3e93c
            v32 = v27;
            int32_t v33 = v32 + a1;
            char * v34 = (char *)(v33 + 1);
            int32_t v35 = v26; // 0x3e92c
            int32_t v36 = 1;
            int32_t v37 = 1; // 0x3e8c8
            int32_t v38 = v28; // 0x3e8c8
            int32_t v39; // 0x3e8c8
            while (true) {
                int32_t v40 = v36;
                int32_t v41 = v35;
                unsigned char v42 = *(char *)(v40 + v33); // 0x3e93c
                unsigned char v43 = *(char *)(v41 + a1); // 0x3e940
                int32_t v44 = v41; // 0x3e948
                int32_t v45; // 0x3e8c8
                int32_t v46; // 0x3e8c8
                int32_t v47; // 0x3e8c8
                int32_t v48; // 0x3e8c8
                if (v43 == v42 || v43 < v42) {
                    // 0x3e998
                    v39 = v38;
                    v45 = v40;
                    v48 = v37;
                    v47 = v38;
                    v46 = v41;
                    if (v43 != v42) {
                        // break -> 0x3e99c
                        break;
                    }
                } else {
                    v31 = v44;
                    int32_t v49 = v31 + 1; // 0x3e958
                    if (v49 <= a2 != v49 != a2) {
                        // break (via goto) -> 0x3e968
                        goto lab_0x3e968;
                    }
                    unsigned char v50 = *v34; // 0x3e93c
                    unsigned char v51 = *(char *)(v49 + a1); // 0x3e940
                    while (v51 != v50 && v51 >= v50) {
                        // 0x3e94c
                        v31 = v49;
                        v49 = v31 + 1;
                        if (v49 <= a2 != v49 != a2) {
                            // break (via goto) -> 0x3e968
                            goto lab_0x3e968;
                        }
                        // 0x3e93c
                        v50 = *v34;
                        v51 = *(char *)(v49 + a1);
                    }
                    // 0x3e998
                    v39 = v31;
                    v45 = 1;
                    v48 = v31 - v32;
                    v47 = v31;
                    v46 = v49;
                    if (v51 != v50) {
                        // break -> 0x3e99c
                        break;
                    }
                }
                int32_t v52 = v45;
                int32_t v53 = v52 == v48 ? v46 : v47;
                v36 = v52 == v48 ? 1 : v52 + 1;
                v35 = v36 + v53;
                v37 = v48;
                v38 = v53;
                v29 = v32;
                v30 = v48;
                if (v35 == a2 || v35 > a2) {
                    goto lab_0x3e968_3;
                }
            }
            int32_t v54 = v39 + 2; // 0x3e92c
            v26 = v54;
            v27 = v39;
            v28 = v39 + 1;
            v29 = v39;
            v30 = 1;
            if (v54 == a2 || v54 > a2) {
                goto lab_0x3e968_3;
            }
        }
      lab_0x3e968:
        // 0x3e968
        v29 = v32;
        v30 = v31 - v32;
    }
  lab_0x3e968_3:;
    uint32_t v55 = v4 + 1; // 0x3e968
    uint32_t v56 = v29 + 1; // 0x3e96c
    if (v56 >= v55) {
        *a3 = v30;
    }
    return v56 >= v55 ? v56 : v55;
}

// Address range: 0x3e9d8 - 0x3ed04
int32_t function_3e9d8(int32_t a1, int32_t a2, int32_t a3, uint32_t a4) {
    uint32_t v1 = a4 - 1; // 0x3e9f8
    int32_t v2; // 0x3e9d8
    int32_t v3; // bp-1068, 0x3e9d8
    int32_t v4; // 0x3e9d8
    if (a4 >= 2 == (a4 != 2)) {
        int32_t v5 = function_3e8c8(a3, a4, &v3); // 0x3ece0
        v4 = v3;
        v2 = v5;
    } else {
        // 0x3ea00
        v3 = 1;
        v4 = 1;
        v2 = v1;
    }
    int32_t v6 = v2;
    int32_t v7; // bp-44, 0x3e9d8
    int32_t v8 = &v7; // 0x3ea1c
    int32_t v9 = &v3; // 0x3ea1c
    v9 += 4;
    *(int32_t *)v9 = a4;
    while (v9 != v8) {
        // 0x3ea20
        v9 += 4;
        *(int32_t *)v9 = a4;
    }
    int32_t v10 = v8; // 0x3ea30
    int32_t v11; // bp-40, 0x3e9d8
    if (a4 != 0) {
        int32_t v12 = (int32_t)&v11 - 1024; // 0x3ea44
        int32_t v13 = a3 - 1; // 0x3ea38
        int32_t v14 = v1;
        v13++;
        *(int32_t *)(v12 + 4 * (int32_t)*(char *)v13) = v14;
        int32_t v15 = v14 - 1; // 0x3ea50
        v10 = -1;
        while (v14 != 0) {
            // 0x3ea3c
            v14 = v15;
            v13++;
            *(int32_t *)(v12 + 4 * (int32_t)*(char *)v13) = v14;
            v15 = v14 - 1;
            v10 = -1;
        }
    }
    // 0x3ea54
    int32_t v16; // 0x3e9d8
    uint32_t v17; // 0x3e9d8
    int32_t v18; // 0x3e9d8
    int32_t v19; // 0x3e9d8
    int32_t v20; // 0x3e9d8
    int32_t v21; // 0x3e9d8
    int32_t v22; // 0x3e9d8
    int32_t v23; // 0x3e9d8
    int32_t v24; // 0x3ea7c
    int32_t v25; // 0x3ea84
    uint32_t v26; // 0x3ebd0
    int32_t v27; // 0x3ebd4
    uint32_t v28; // 0x3ebdc
    int32_t v29; // 0x3ebf0
    int32_t v30; // 0x3e9d8
    int32_t v31; // 0x3e9d8
    int32_t v32; // 0x3ea70
    uint32_t v33; // 0x3ea74
    if (function_1200c(a3, v4 + a3, v6, v10) == 0) {
        // 0x3ea70
        v32 = v6 - 1;
        v33 = a2 - a4;
        v24 = v32 + a3;
        v25 = a4 - v4;
        int32_t v34 = 1 - v6; // 0x3ea8c
        int32_t v35 = (int32_t)&v11 - 1024; // 0x3ead0
        v16 = 0;
        v18 = 0;
        while (true) {
          lab_0x3eac4_2:
            // 0x3eac4
            v19 = v18;
            v17 = v16;
            v30 = v19 + a1;
            uint32_t v36 = *(int32_t *)(v35 + 4 * (int32_t)*(char *)(v30 + v1)); // 0x3ead4
            if (v36 == 0) {
                int32_t v37 = v6 >= v17 ? v6 : v17;
                if (v37 < v1) {
                    int32_t v38 = v37 + a3; // 0x3eaf8
                    int32_t v39 = v37 + v30; // 0x3eafc
                    int32_t v40 = v38; // 0x3eb0c
                    int32_t v41 = v37; // 0x3eb0c
                    int32_t v42 = v39; // 0x3eb0c
                    int32_t v43 = v37; // 0x3eb0c
                    if (*(char *)v39 == *(char *)v38) {
                        int32_t v44 = v41 + 1; // 0x3eb24
                        while (v44 < v1) {
                            int32_t v45 = v40 + 1; // 0x3eb14
                            int32_t v46 = v42 + 1; // 0x3eb18
                            v40 = v45;
                            v41 = v44;
                            v42 = v46;
                            v43 = v44;
                            if (*(char *)v45 != *(char *)v46) {
                                // 0x3ebbc
                                v23 = v34 + v19 + v43;
                                goto lab_0x3eab8;
                            }
                            v44 = v41 + 1;
                        }
                        goto lab_0x3eb30;
                    } else {
                        // 0x3ebbc
                        v23 = v34 + v19 + v43;
                        goto lab_0x3eab8;
                    }
                } else {
                    goto lab_0x3eb30;
                }
            } else {
                int32_t v47 = v17 == 0 | v36 >= v4 ? v36 : v25;
                v23 = v47 + v19;
                goto lab_0x3eab8;
            }
        }
    } else {
        // 0x3ebd0
        v26 = a4 - v6;
        v27 = v6 - 1;
        v28 = a2 - a4;
        int32_t v48 = v6 + a3; // 0x3ebec
        v29 = v27 + a3;
        int32_t v49 = 1 - v6; // 0x3ebf8
        int32_t v50 = (int32_t)&v11 - 1024; // 0x3ec10
        v20 = 0;
        while (true) {
          lab_0x3ec04:
            // 0x3ec04
            v21 = v20;
            v31 = v21 + a1;
            int32_t v51 = *(int32_t *)(v50 + 4 * (int32_t)*(char *)(v31 + v1)); // 0x3ec14
            int32_t v52 = v51; // 0x3ec1c
            if (v51 == 0) {
                if (v6 < v1) {
                    int32_t v53 = v31 + v6; // 0x3ec30
                    int32_t v54 = v53; // 0x3ec40
                    int32_t v55 = v48; // 0x3ec40
                    if (*(char *)v53 == *(char *)v48) {
                        int32_t v56 = v6 + 1; // 0x3ec60
                        while (v56 < v1) {
                            int32_t v57 = v55 + 1; // 0x3ec50
                            int32_t v58 = v54 + 1; // 0x3ec54
                            v54 = v58;
                            int32_t v59 = v56; // 0x3ec5c
                            v55 = v57;
                            int32_t v60 = v56; // 0x3ec5c
                            if (*(char *)v57 != *(char *)v58) {
                                // 0x3ecc0
                                v22 = v49 + v21 + v60;
                                goto lab_0x3ecb4;
                            }
                            v56 = v59 + 1;
                        }
                        goto lab_0x3ec6c;
                    } else {
                        // 0x3ecc0
                        v22 = v49 + v21 + v6;
                        goto lab_0x3ecb4;
                    }
                } else {
                    goto lab_0x3ec6c;
                }
            } else {
                // 0x3ecb0
                v22 = v52 + v21;
                goto lab_0x3ecb4;
            }
        }
    }
  lab_0x3ebb0_6:;
    // 0x3ebb0
    int32_t result; // 0x3e9d8
    return result;
  lab_0x3eb30:;
    int32_t v61 = v6; // 0x3eb3c
    if (v6 != v17 && v6 >= v17) {
        int32_t v62 = v30 + v32; // 0x3eb48
        int32_t v63 = v62; // 0x3eb58
        int32_t v64 = v24; // 0x3eb58
        v61 = v6;
        if (*(char *)v24 == *(char *)v62) {
            int32_t v65 = v32;
            v61 = v17;
            while (v65 != v17) {
                int32_t v66 = v64 - 1; // 0x3eb68
                int32_t v67 = v63 - 1; // 0x3eb6c
                int32_t v68 = v65 - 1; // 0x3eb74
                v63 = v67;
                v64 = v66;
                v61 = v65;
                if (*(char *)v66 != *(char *)v67) {
                    // break -> 0x3eb88
                    break;
                }
                v65 = v68;
                v61 = v17;
            }
        }
    }
    uint32_t v69 = v61;
    uint32_t v70 = v17 + 1; // 0x3eb88
    result = v30;
    if (v70 >= v69 == (v70 != v69)) {
        // break -> 0x3ebb0
        goto lab_0x3ebb0_6;
    }
    int32_t v71 = v19 + v4; // 0x3eb9c
    int32_t v72 = v25; // 0x3eba8
    int32_t v73 = v71; // 0x3eba8
    result = 0;
    if (v33 < v71) {
        // break -> 0x3ebb0
        goto lab_0x3ebb0_6;
    }
    goto lab_0x3eac4;
  lab_0x3eab8:
    // 0x3eab8
    v72 = 0;
    v73 = v23;
    if (v33 < v23) {
        // break -> 0x3ebb0
        goto lab_0x3ebb0_6;
    }
    goto lab_0x3eac4;
  lab_0x3eac4:
    // 0x3eac4
    v16 = v72;
    v18 = v73;
    goto lab_0x3eac4_2;
  lab_0x3ec6c:
    // 0x3ec6c
    result = v31;
    if (v6 == 0) {
        // break -> 0x3ebb0
        goto lab_0x3ebb0_6;
    }
    int32_t v74 = v31 + v27; // 0x3ec7c
    int32_t v75 = v74; // 0x3ec8c
    if (*(char *)v74 == *(char *)v29) {
        result = v31;
        if (v29 == a3) {
            // break (via goto) -> 0x3ebb0
            goto lab_0x3ebb0_6;
        }
        int32_t v76 = v29 - 1; // 0x3ec9c
        int32_t v77 = v75 - 1; // 0x3eca0
        int32_t v78 = v76; // 0x3eca8
        v75 = v77;
        while (*(char *)v76 == *(char *)v77) {
            // 0x3ec94
            result = v31;
            if (v78 == a3) {
                // break (via goto) -> 0x3ebb0
                goto lab_0x3ebb0_6;
            }
            // 0x3ec9c
            v76 = v78 - 1;
            v77 = v75 - 1;
            v78 = v76;
            v75 = v77;
        }
    }
    // 0x3ecb0
    v22 = (v26 < v6 ? v6 : v26) + 1 + v21;
    goto lab_0x3ecb4;
  lab_0x3ecb4:;
    int32_t v79 = v22;
    v20 = v79;
    if (v79 != v28 && v79 >= v28) {
        // break -> 0x3ebb0
        goto lab_0x3ebb0_6;
    }
    goto lab_0x3ec04;
}

// Address range: 0x3ed04 - 0x3efec
int32_t memmem(int32_t result, uint32_t a2, int32_t a3, uint32_t a4) {
    // 0x3ed04
    if (a4 == 0) {
        // 0x3ee98
        return result;
    }
    // 0x3ed1c
    if (a4 >= a2 == (a4 != a2)) {
        // 0x3ee98
        return 0;
    }
    if (a4 >= 31 == (a4 != 31)) {
        // 0x3eeb8
        return function_3e9d8(result, a2, a3, a4);
    }
    int32_t result2 = memchr(result, (char)a3, a2); // 0x3ed3c
    if (result2 == 0) {
        // 0x3ee98
        return result2;
    }
    uint32_t v1 = result - result2 + a2; // 0x3ed64
    if (v1 <= a4 == (v1 != a4)) {
        // 0x3ee98
        return 0;
    }
    int32_t v2; // 0x3ed04
    int32_t v3; // 0x3ed04
    char * v4; // bp-44, 0x3ed04
    char * v5; // 0x3ed04
    if (a4 >= 2 == (a4 != 2)) {
        int32_t v6 = function_3e8c8(a3, a4, (int32_t *)&v4); // 0x3efc8
        v5 = v4;
        v2 = (int32_t)v4;
        v3 = v6;
    } else {
        // 0x3ed78
        v4 = (char *)1;
        v5 = (char *)1;
        v2 = 1;
        v3 = a4 - 1;
    }
    int32_t v7 = v3;
    int32_t v8 = (int32_t)v5; // 0x3ed88
    int32_t v9; // 0x3ed04
    uint32_t v10; // 0x3ed04
    int32_t v11; // 0x3ed04
    int32_t v12; // 0x3ed04
    int32_t v13; // 0x3ed04
    int32_t v14; // 0x3edb0
    int32_t v15; // 0x3eda4
    if (function_1200c(a3, v8 + a3, v7, v2) == 0) {
        // 0x3eda4
        v15 = v7 - 1;
        v14 = v15 + a3;
        v11 = 0;
        v9 = 0;
        while (true) {
          lab_0x3edcc:
            // 0x3edcc
            v10 = v9;
            v12 = v11;
            v13 = v7 >= v10 ? v7 : v10;
            if (v13 == a4 || v13 > a4) {
                goto lab_0x3ee1c;
            } else {
                // 0x3ede0
                if (*(char *)(v13 + a3) == *(char *)(v12 + result2 + v13)) {
                    int32_t v16; // 0x3ed04
                    while (v16 + 1 != a4) {
                        // 0x3ee00
                        int32_t v17; // 0x3ed04
                        int32_t v18 = v17;
                        int32_t v19; // 0x3ed04
                        int32_t v20 = v19;
                        int32_t v21 = v20 + 1; // 0x3ee00
                        char v22 = *(char *)v21; // 0x3ee00
                        int32_t v23 = v18 + 1; // 0x3ee04
                        char v24 = *(char *)v23; // 0x3ee04
                        v19 = v21;
                        v17 = v23;
                        int32_t v25; // 0x3ee10
                        v16 = v25;
                        if (v22 != v24) {
                            goto lab_0x3eea4;
                        }
                        int32_t v26 = v16;
                        v25 = v26 + 1;
                    }
                    goto lab_0x3ee1c;
                } else {
                    goto lab_0x3eea4;
                }
            }
        }
      lab_0x3efe4:
        // 0x3ee98
        return v12 + result2;
    }
    uint32_t v27 = a4 - v7; // 0x3eecc
    int32_t v28 = v7 - 1; // 0x3eed0
    uint32_t v29 = v1 - a4; // 0x3eed8
    int32_t v30 = v7 + a3; // 0x3eee4
    int32_t v31 = 1 - v7; // 0x3eee8
    int32_t v32 = (v27 < v7 ? v7 : v27) + 1; // 0x3eef0
    char * v33 = (char *)(v28 + a3); // 0x3eef4
    bool v34 = v7 == a4 | v7 > a4; // 0x3ef00
    char * v35 = (char *)v30;
    int32_t v36 = 0; // 0x3eef8
    int32_t v37; // 0x3ed04
    int32_t v38; // 0x3ed04
    int32_t v39; // 0x3ed04
    while (true) {
      lab_0x3eefc_2:
        // 0x3eefc
        v38 = v36;
        if (v34) {
            // 0x3eefc
            v37 = v38 + result2;
            goto lab_0x3ef48;
        } else {
            int32_t v40 = v38 + result2;
            int32_t v41 = v40 + v7; // 0x3ef0c
            int32_t v42 = v41; // 0x3ef1c
            int32_t v43 = v30; // 0x3ef1c
            if (*(char *)v41 == *v35) {
                int32_t v44 = v7 + 1; // 0x3ef3c
                v37 = v40;
                while (v44 != a4) {
                    int32_t v45 = v43 + 1; // 0x3ef2c
                    int32_t v46 = v42 + 1; // 0x3ef30
                    v42 = v46;
                    v43 = v45;
                    int32_t v47 = v44; // 0x3ef38
                    int32_t v48 = v44; // 0x3ef38
                    if (*(char *)v45 != *(char *)v46) {
                        // 0x3ef9c
                        v39 = v31 + v38 + v48;
                        goto lab_0x3efa4;
                    }
                    v44 = v47 + 1;
                    v37 = v40;
                }
                goto lab_0x3ef48;
            } else {
                // 0x3ef9c
                v39 = v31 + v38 + v7;
                goto lab_0x3efa4;
            }
        }
    }
  lab_0x3ee98_3:;
    // 0x3ee98
    int32_t result3; // 0x3ed04
    return result3;
  lab_0x3eea4:;
    int32_t v49 = 0; // 0x3eeb4
    int32_t v50 = 1 - v7 + v12 + v13; // 0x3eeb4
    goto lab_0x3ee8c;
  lab_0x3ee1c:;
    int32_t v55 = v7; // 0x3ee28
    if (v7 != v10 && v7 >= v10) {
        int32_t v56 = v12 + result2 + v15; // 0x3ee34
        int32_t v57 = v56; // 0x3ee44
        int32_t v58 = v14; // 0x3ee44
        v55 = v7;
        if (*(char *)v14 == *(char *)v56) {
            int32_t v59 = v15;
            v55 = v10;
            while (v59 != v10) {
                int32_t v60 = v58 - 1; // 0x3ee54
                int32_t v61 = v57 - 1; // 0x3ee58
                int32_t v62 = v59 - 1; // 0x3ee60
                v57 = v61;
                v58 = v60;
                v55 = v59;
                if (*(char *)v60 != *(char *)v61) {
                    // break -> 0x3ee74
                    break;
                }
                v59 = v62;
                v55 = v10;
            }
        }
    }
    uint32_t v63 = v55;
    uint32_t v64 = v10 + 1; // 0x3ee74
    if (v64 >= v63 == (v64 != v63)) {
        // break -> 0x3efe4
        goto lab_0x3efe4;
    }
    // 0x3ee80
    v49 = a4 - v8;
    v50 = v12 + v8;
    goto lab_0x3ee8c;
  lab_0x3ee8c:
    // 0x3ee8c
    v11 = v50;
    v9 = v49;
    if (v1 - a4 < v50) {
      lab_0x3ee98_3:
        // 0x3ee98
        return 0;
    }
    goto lab_0x3edcc;
  lab_0x3ef48:
    // 0x3ef48
    result3 = v37;
    if (v7 == 0) {
        // break -> 0x3ee98
        goto lab_0x3ee98_3;
    }
    // 0x3ef50
    if (*(char *)(v37 + v28) == *v33) {
        int32_t v51; // 0x3ed04
        if (v51 == a3) {
            // break (via goto) -> 0x3ee98
            goto lab_0x3ee98_3;
        }
        int32_t v52 = v51 - 1; // 0x3ef74
        int32_t v53; // 0x3ed04
        int32_t v54 = v53 - 1; // 0x3ef78
        v51 = v52;
        v53 = v54;
        while (*(char *)v52 == *(char *)v54) {
            // 0x3ef84
            if (v51 == a3) {
                // break (via goto) -> 0x3ee98
                goto lab_0x3ee98_3;
            }
            // 0x3ef74
            v52 = v51 - 1;
            v54 = v53 - 1;
            v51 = v52;
            v53 = v54;
        }
    }
    // 0x3efb0
    v39 = v32 + v38;
    goto lab_0x3efa4;
  lab_0x3efa4:
    // 0x3efa4
    v36 = v39;
    result3 = 0;
    if (v29 < v36) {
        // break -> 0x3ee98
        goto lab_0x3ee98_3;
    }
    goto lab_0x3eefc_2;
}

// Address range: 0x3eff0 - 0x3f92c
int32_t function_3eff0(uint32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x3eff0
    float64_t v1; // 0x3eff0
    float64_t v2 = __asm_vpush_14(v1, v1, v1); // 0x3eff8
    int32_t v3; // bp-8232, 0x3eff0
    memset(&v3, 0, 0x2000);
    int32_t v4 = function_1e0c0(); // 0x3f01c
    int32_t v5 = (int32_t)"BHB28601"; // 0x3f030
    float64_t v6; // 0x3eff0
    float64_t v7; // 0x3eff0
    int32_t v8; // 0x3eff0
    int32_t v9; // 0x3eff0
    int32_t v10; // 0x3eff0
    int32_t str2; // bp-12328, 0x3eff0
    if (function_11eec(v4, "BHB28601", 0x2000, a4) == 0) {
        goto lab_0x3f04c;
    } else {
        int32_t v11 = function_1e0c0(); // 0x3f034
        v5 = (int32_t)"BHB28701";
        if (function_11eec(v11, "BHB28701", 0x2000, a4) == 0) {
            goto lab_0x3f04c;
        } else {
            int32_t v12 = function_1e0f0(); // 0x3f4f4
            float64_t v13 = v2; // 0x3f4fc
            int32_t v14 = (int32_t)"BHB28701"; // 0x3f4fc
            if (v12 != 0) {
                float64_t v15 = __asm_vldr(0); // 0x3f500
                uint32_t v16 = a1 % 256; // 0x3f50c
                int32_t v17 = 0; // 0x3f514
                int32_t v18 = &str2;
                int32_t v19 = 0;
                if (function_14ed0(v17) == 0) {
                    // 0x3f534
                    function_5146c(v16, v19);
                    usleep(0x1388);
                    function_51508(v16, v19);
                    usleep(0x2710);
                    __asm_vstr(v15, *(int32_t *)v18);
                }
                // 0x3f558
                v17++;
                int32_t v20 = v19 + a2; // 0x3f564
                int32_t v21 = v18 + 8; // 0x3f564
                v13 = v15;
                v14 = v19;
                while (v12 != v17) {
                    // 0x3f518
                    v18 = v21;
                    v19 = v20;
                    if (function_14ed0(v17) == 0) {
                        // 0x3f534
                        function_5146c(v16, v19);
                        usleep(0x1388);
                        function_51508(v16, v19);
                        usleep(0x2710);
                        __asm_vstr(v15, *(int32_t *)v18);
                    }
                    // 0x3f558
                    v17++;
                    v20 = v19 + a2;
                    v21 = v18 + 8;
                    v13 = v15;
                    v14 = v19;
                }
            }
            // 0x3f568
            usleep(0x186a0);
            int32_t result = function_1e0e0(); // 0x3f574
            if (result != 0) {
                // 0x3f584
                __asm_vldr_8(0x3a000000);
                __asm_vldr(0x60000000);
                return result;
            }
            int32_t v22 = function_1e0e0(); // 0x3f7d4
            v6 = v13;
            v7 = v2;
            v8 = v14;
            v9 = 0x2000;
            v10 = 0;
            if (v22 != 0) {
                // 0x3f7e4
                int32_t str; // bp-12456, 0x3eff0
                int32_t v23 = &str; // 0x3f808
                int32_t v24 = &str2;
                int32_t v25 = 0;
                int32_t chars_printed = sprintf((char *)&str, "domain %2d:", v25); // 0x3f834
                int32_t v26 = function_1e100(); // 0x3f83c
                int32_t v27 = 0; // 0x3f844
                int32_t v28 = chars_printed; // 0x3f844
                int32_t v29; // 0x3eff0
                int32_t v30; // 0x3f850
                int32_t v31; // 0x3f860
                int64_t v32; // 0x3f868
                if (v26 != 0) {
                    v29 = v28;
                    v30 = function_1e100();
                    v31 = v27 + 1;
                    v32 = *(int64_t *)(8 * (v30 * v25 + v27) + v24);
                    v27 = v31;
                    v28 = sprintf((char *)(v29 + v23), "\t%.2f", (float64_t)(v32 >> 32)) + v29;
                    while (v26 != v31) {
                        // 0x3f850
                        v29 = v28;
                        v30 = function_1e100();
                        v31 = v27 + 1;
                        v32 = *(int64_t *)(8 * (v30 * v25 + v27) + v24);
                        v27 = v31;
                        v28 = sprintf((char *)(v29 + v23), "\t%.2f", (float64_t)(v32 >> 32)) + v29;
                    }
                }
                int32_t v33 = g99; // 0x3f884
                if (g99 == 0) {
                    // 0x3f91c
                    v33 = function_536f4("bmminer_adc");
                    g99 = v33;
                }
                int32_t v34 = v25 + 1; // 0x3f8b4
                function_54cb0(v33, "log/adc_sample.c", 16, "check_adc_voltage", 17, 169, 20, (int32_t)"chain %2d %s");
                v6 = v13;
                v7 = v2;
                v8 = (int32_t)"log/adc_sample.c";
                v9 = 16;
                v10 = v22;
                while (v34 != v22) {
                    // 0x3f828
                    v25 = v34;
                    chars_printed = sprintf((char *)&str, "domain %2d:", v25);
                    v26 = function_1e100();
                    v27 = 0;
                    v28 = chars_printed;
                    if (v26 != 0) {
                        v29 = v28;
                        v30 = function_1e100();
                        v31 = v27 + 1;
                        v32 = *(int64_t *)(8 * (v30 * v25 + v27) + v24);
                        v27 = v31;
                        v28 = sprintf((char *)(v29 + v23), "\t%.2f", (float64_t)(v32 >> 32)) + v29;
                        while (v26 != v31) {
                            // 0x3f850
                            v29 = v28;
                            v30 = function_1e100();
                            v31 = v27 + 1;
                            v32 = *(int64_t *)(8 * (v30 * v25 + v27) + v24);
                            v27 = v31;
                            v28 = sprintf((char *)(v29 + v23), "\t%.2f", (float64_t)(v32 >> 32)) + v29;
                        }
                    }
                    // 0x3f87c
                    v33 = g99;
                    if (g99 == 0) {
                        // 0x3f91c
                        v33 = function_536f4("bmminer_adc");
                        g99 = v33;
                    }
                    // 0x3f888
                    v34 = v25 + 1;
                    function_54cb0(v33, "log/adc_sample.c", 16, "check_adc_voltage", 17, 169, 20, (int32_t)"chain %2d %s");
                    v6 = v13;
                    v7 = v2;
                    v8 = (int32_t)"log/adc_sample.c";
                    v9 = 16;
                    v10 = v22;
                }
            }
            goto lab_0x3f490;
        }
    }
  lab_0x3f424:;
    int32_t v35 = function_536f4("bmminer_adc"); // 0x3f428
    g99 = v35;
    int32_t v36 = v35; // 0x3f430
    int32_t v37; // 0x3eff0
    int32_t v38 = v37; // 0x3f430
    goto lab_0x3f34c;
  lab_0x3f34c:
    // 0x3f34c
    function_54cb0(v36, "log/adc_sample.c", 16, "dump_adc_voltage", 16, 81, 20, (int32_t)"%s");
    char * v39 = (char *)&str2; // 0x3f380
    int32_t v40 = v38; // 0x3f380
    int32_t v41; // 0x3f2dc
    if (v41 == v38) {
        // break -> 0x3f450
        goto lab_0x3f450;
    }
    goto lab_0x3f384;
  lab_0x3f04c:;
    uint32_t v62 = a1 % 256; // 0x3f04c
    function_11f94(&g332, v5, 0x2000, v62);
    function_16330(1);
    usleep(0x4e20);
    function_51478(v62);
    usleep(0x4e20);
    function_514a4(v62);
    usleep(0x4e20);
    int32_t v63 = function_1e0e0(); // 0x3f094
    float64_t v64 = v2; // 0x3f0a0
    float64_t v65 = v2; // 0x3f0a0
    int32_t v66 = v5; // 0x3f0a0
    int32_t v67 = 0x2000; // 0x3f0a0
    int32_t v53; // 0x3eff0
    if (v63 != 0) {
        float64_t v68 = __asm_vldr(-0x66666666); // 0x3f0a4
        float64_t v69 = __asm_vldr(0); // 0x3f0ac
        int32_t v70 = 0;
        int32_t v71 = function_1e100(); // 0x3f0c4
        int32_t v72; // 0x3eff0
        int32_t v73 = v72; // 0x3f0cc
        int32_t v74 = 0; // 0x3f0cc
        int32_t v75 = v72; // 0x3f0cc
        int32_t v76 = v5; // 0x3f0cc
        int32_t v77 = 0x2000; // 0x3f0cc
        int32_t v78; // 0x3eff0
        int32_t v79; // 0x3eff0
        int32_t v80; // 0x3f138
        int32_t v81; // 0x3f148
        int32_t v82; // 0x3f164
        int32_t v83; // 0x3f128
        int32_t v84; // 0x3f180
        int32_t result2; // 0x3f194
        int32_t v85; // 0x3f4d8
        if (v71 != 0) {
            v80 = function_1e100() * v70 + v74;
            v81 = v80 * function_1e160();
            v82 = v73;
            v78 = v81;
            v79 = a1;
            if (function_14ed0(v80) == 0) {
                // 0x3f164
                v82 = function_2c06c(176, v81, a1);
                if ((v82 & 4) != 0) {
                    // 0x3f180
                    v84 = function_2c06c(180, v81, a1);
                    result2 = function_2c06c(184, v81, a1);
                    __asm_ubfx(v84, 0, 12);
                    return result2;
                }
                // 0x3f0d8
                v85 = g99;
                if (g99 == 0) {
                    // 0x3f4d0
                    v85 = function_536f4("bmminer_adc");
                    g99 = v85;
                }
                // 0x3f0e4
                function_54cb0(v85, "log/adc_sample.c", 16, "get_adc_data_with_addr", 22, 45, 20, (int32_t)"chain::%d, asic::%d adc control vm sample not ready %08x.\n");
                v78 = (int32_t)"log/adc_sample.c";
                v79 = 16;
            }
            // 0x3f128
            v83 = v74 + 1;
            v73 = v82;
            v74 = v83;
            v75 = v82;
            v76 = v78;
            v77 = v79;
            while (v71 != v83) {
                // 0x3f134
                v80 = function_1e100() * v70 + v74;
                v81 = v80 * function_1e160();
                v82 = v73;
                v78 = v81;
                v79 = a1;
                if (function_14ed0(v80) == 0) {
                    // 0x3f164
                    v82 = function_2c06c(176, v81, a1);
                    if ((v82 & 4) != 0) {
                        // 0x3f180
                        v84 = function_2c06c(180, v81, a1);
                        result2 = function_2c06c(184, v81, a1);
                        __asm_ubfx(v84, 0, 12);
                        return result2;
                    }
                    // 0x3f0d8
                    v85 = g99;
                    if (g99 == 0) {
                        // 0x3f4d0
                        v85 = function_536f4("bmminer_adc");
                        g99 = v85;
                    }
                    // 0x3f0e4
                    function_54cb0(v85, "log/adc_sample.c", 16, "get_adc_data_with_addr", 22, 45, 20, (int32_t)"chain::%d, asic::%d adc control vm sample not ready %08x.\n");
                    v78 = (int32_t)"log/adc_sample.c";
                    v79 = 16;
                }
                // 0x3f128
                v83 = v74 + 1;
                v73 = v82;
                v74 = v83;
                v75 = v82;
                v76 = v78;
                v77 = v79;
            }
        }
        int32_t v86 = v77;
        int32_t v87 = v76;
        int32_t v88 = v70 + 1; // 0x3f244
        v72 = v75;
        v53 = v75;
        v64 = v68;
        v65 = v69;
        v66 = v87;
        v67 = v86;
        while (v88 != v63) {
            // 0x3f0c4
            v70 = v88;
            v71 = function_1e100();
            v73 = v72;
            v74 = 0;
            v75 = v72;
            v76 = v87;
            v77 = v86;
            if (v71 != 0) {
                v80 = function_1e100() * v70 + v74;
                v81 = v80 * function_1e160();
                v82 = v73;
                v78 = v81;
                v79 = a1;
                if (function_14ed0(v80) == 0) {
                    // 0x3f164
                    v82 = function_2c06c(176, v81, a1);
                    if ((v82 & 4) != 0) {
                        // 0x3f180
                        v84 = function_2c06c(180, v81, a1);
                        result2 = function_2c06c(184, v81, a1);
                        __asm_ubfx(v84, 0, 12);
                        return result2;
                    }
                    // 0x3f0d8
                    v85 = g99;
                    if (g99 == 0) {
                        // 0x3f4d0
                        v85 = function_536f4("bmminer_adc");
                        g99 = v85;
                    }
                    // 0x3f0e4
                    function_54cb0(v85, "log/adc_sample.c", 16, "get_adc_data_with_addr", 22, 45, 20, (int32_t)"chain::%d, asic::%d adc control vm sample not ready %08x.\n");
                    v78 = (int32_t)"log/adc_sample.c";
                    v79 = 16;
                }
                // 0x3f128
                v83 = v74 + 1;
                v73 = v82;
                v74 = v83;
                v75 = v82;
                v76 = v78;
                v77 = v79;
                while (v71 != v83) {
                    // 0x3f134
                    v80 = function_1e100() * v70 + v74;
                    v81 = v80 * function_1e160();
                    v82 = v73;
                    v78 = v81;
                    v79 = a1;
                    if (function_14ed0(v80) == 0) {
                        // 0x3f164
                        v82 = function_2c06c(176, v81, a1);
                        if ((v82 & 4) != 0) {
                            // 0x3f180
                            v84 = function_2c06c(180, v81, a1);
                            result2 = function_2c06c(184, v81, a1);
                            __asm_ubfx(v84, 0, 12);
                            return result2;
                        }
                        // 0x3f0d8
                        v85 = g99;
                        if (g99 == 0) {
                            // 0x3f4d0
                            v85 = function_536f4("bmminer_adc");
                            g99 = v85;
                        }
                        // 0x3f0e4
                        function_54cb0(v85, "log/adc_sample.c", 16, "get_adc_data_with_addr", 22, 45, 20, (int32_t)"chain::%d, asic::%d adc control vm sample not ready %08x.\n");
                        v78 = (int32_t)"log/adc_sample.c";
                        v79 = 16;
                    }
                    // 0x3f128
                    v83 = v74 + 1;
                    v73 = v82;
                    v74 = v83;
                    v75 = v82;
                    v76 = v78;
                    v77 = v79;
                }
            }
            // 0x3f240
            v86 = v77;
            v87 = v76;
            v88 = v70 + 1;
            v72 = v75;
            v53 = v75;
            v64 = v68;
            v65 = v69;
            v66 = v87;
            v67 = v86;
        }
    }
    int32_t v89 = function_1e0e0(); // 0x3f250
    int32_t v90 = v66; // 0x3f25c
    int32_t v91 = v67; // 0x3f25c
    if (v89 != 0) {
        int32_t v92 = 0; // 0x3f290
        while (true) {
            int32_t v45 = v92;
            int32_t v93 = g99; // 0x3f29c
            if (g99 == 0) {
                // 0x3f4e4
                v93 = function_536f4("bmminer_adc");
                g99 = v93;
            }
            // 0x3f2a0
            function_54cb0(v93, "log/adc_sample.c", 16, "dump_adc_voltage", 16, 67, 20, (int32_t)"[C: %d], [D: %d]");
            v41 = function_1e100();
            v39 = (char *)a1;
            v40 = 0;
            if (v41 != 0) {
                while (true) {
                  lab_0x3f384:;
                    int32_t v42 = v40;
                    char * v43 = v39;
                    memset(&str2, 0, 256);
                    int32_t v44 = function_1e100() * v45 + v42; // 0x3f398
                    function_1e100();
                    int32_t v46 = 32 * v44 + (int32_t)&v3; // 0x3f3c4
                    int32_t v47; // bp-40, 0x3eff0
                    int32_t v48 = (int32_t)&v47 - 0x2800 + 8 * v44; // 0x3f3cc
                    int32_t v49; // 0x3eff0
                    if (function_5f880() == 1) {
                        float64_t v50 = __asm_vldr(*(int32_t *)(v46 + 24)); // 0x3f3e0
                        float64_t v51 = __asm_vldr(*(int32_t *)v48); // 0x3f3e8
                        int32_t v52 = v42 + 1; // 0x3f3ec
                        __asm_vstr(v50, v53);
                        __asm_vstr(v51, v49);
                        float64_t v54 = __asm_vldr(*(int32_t *)(v46 + 8)); // 0x3f3fc
                        float64_t v55 = __asm_vldr(*(int32_t *)(v46 + 16)); // 0x3f400
                        __asm_vstr(v54, 20);
                        __asm_vstr(v55, (int32_t)v43);
                        __asm_vstr(__asm_vldr(*(int32_t *)v46), 16);
                        snprintf((char *)&str2, 256, "{I} %2d: d0 %.3f, d1 %.3f, d2 %.3f, d3 %.3f, sum = %f\n");
                        v36 = g99;
                        v38 = v52;
                        v37 = v52;
                        if (g99 == 0) {
                            goto lab_0x3f424;
                        } else {
                            goto lab_0x3f34c;
                        }
                    } else {
                        float64_t v56 = __asm_vldr(*(int32_t *)v48); // 0x3f310
                        int32_t v57 = v42 + 1; // 0x3f314
                        float64_t v58 = __asm_vldr(*(int32_t *)(v46 + 24)); // 0x3f318
                        __asm_vstr(v56, v49);
                        float64_t v59 = __asm_vldr(*(int32_t *)(v46 + 16)); // 0x3f320
                        __asm_vstr(v58, v53);
                        float64_t v60 = __asm_vldr(*(int32_t *)(v46 + 8)); // 0x3f328
                        __asm_vstr(v59, (int32_t)v43);
                        float64_t v61 = __asm_vldr(*(int32_t *)v46); // 0x3f330
                        __asm_vstr(v60, 20);
                        __asm_vstr(v61, 16);
                        snprintf((char *)&str2, 256, "{I} %2d: d0 %.3f, d1 %.3f, d2 %.3f, d3 %.3f, sum = %f");
                        v36 = g99;
                        v38 = v57;
                        v37 = v57;
                        if (g99 == 0) {
                            goto lab_0x3f424;
                        } else {
                            goto lab_0x3f34c;
                        }
                    }
                }
            }
          lab_0x3f450:
            // 0x3f450
            v92 = v45 + 1;
            v90 = (int32_t)"log/adc_sample.c";
            v91 = 16;
            if (v92 == v89) {
                // break -> 0x3f464
                break;
            }
        }
    }
    // 0x3f464
    function_513fc(v62);
    usleep(0x4e20);
    function_16330(0);
    usleep(0x4e20);
    function_11ea4(&g332, v90, v91, v89);
    v6 = v64;
    v7 = v65;
    v8 = v90;
    v9 = v91;
    v10 = v89;
    goto lab_0x3f490;
  lab_0x3f490:
    // 0x3f490
    function_11f94(&g100, v8, v9, v10);
    int32_t v94 = &v3; // 0x3f4a4
    function_11fc4((int32_t *)(0x2000 * a1 + (int32_t)&g101), v94, 0, v10);
    function_11ea4(&g100, v94, 0x2000, v10);
    __asm_vpop_15(v6, v7, v2);
    return 0;
}

// Address range: 0x3f92c - 0x3f968
int32_t function_3f92c(int32_t result, int32_t a2, int32_t a3) {
    int32_t v1 = a3 - 3; // 0x3f930
    bool v2 = a3 == 3; // 0x3f930
    int32_t v3 = 2 - a3 & a3; // 0x3f930
    if (a3 < 4) {
        v1 = a2 - 255;
        v2 = a2 == 255;
        v3 = 254 - a2 & a2;
    }
    if (result <= 3 && (v2 || v1 < 0 != v3 < 0)) {
        int32_t v4 = *(int32_t *)(8 * (4 * (256 * result + a2) + a3) + ((int32_t)&g85 | 0xcb68)); // 0x3f95c
        __asm_vldreq(v4);
    } else {
        // .critedge
        __asm_vldrne(0);
    }
    return result;
}

// Address range: 0x3f970 - 0x3f9bc
int32_t function_3f970(int32_t result2, int32_t a2) {
    int32_t v1 = result2 - 3; // 0x3f974
    bool v2 = result2 == 3; // 0x3f974
    int32_t v3 = 2 - result2 & result2; // 0x3f974
    if (result2 < 4) {
        v1 = a2 - 255;
        v2 = a2 == 255;
        v3 = 254 - a2 & a2;
    }
    if (v2 || v1 < 0 != v3 < 0) {
        // 0x3f984
        int32_t v4; // 0x3f970
        int32_t result = function_11f94(&g100, a2, v4, v4); // 0x3f998
        __asm_vldr(0);
        float64_t v5; // 0x3f970
        __asm_vldmia_19(32 * (256 * result2 + a2) + (int32_t)&g101, v5);
        return result;
    }
    // 0x3f97c
    __asm_vldr(0);
    return result2;
}

// Address range: 0x3f9bc - 0x3f9c8
int32_t function_3f9bc(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x3f9bc
    int32_t v1; // 0x3f9bc
    __asm_mrc(15, 1, v1, 0, 11, 7);
    return result;
}

// Address range: 0x3f9c8 - 0x3f9d0
int32_t function_3f9c8(int32_t a1) {
    // 0x3f9c8
    float64_t v1; // 0x3f9c8
    __asm_vstr(v1, a1);
    int32_t v2; // 0x3f9c8
    return function_11ea4((int32_t *)v2, v2, v2, v2);
}

// Address range: 0x3f9d2 - 0x3f9d8
int32_t function_3f9d2(int32_t a1) {
    // 0x3f9d2
    __asm_ldc(0, 13, a1);
    int32_t v1; // 0x3f9d2
    return function_3fef4(v1);
}

// Address range: 0x3f9d8 - 0x3f9dc
int32_t function_3f9d8(int32_t a1, int32_t a2) {
    // 0x3f9d8
    int32_t result; // 0x3f9d8
    return result;
}

// Address range: 0x3f9dc - 0x3f9e0
int32_t function_3f9dc(void) {
    // 0x3f9dc
    return function_440020();
}

// Address range: 0x3f9ec - 0x3fa38
int32_t function_3f9ec(int32_t result2, int32_t a2) {
    int32_t v1 = result2 - 3; // 0x3f9f0
    bool v2 = result2 == 3; // 0x3f9f0
    int32_t v3 = 2 - result2 & result2; // 0x3f9f0
    if (result2 < 4) {
        v1 = a2 - 255;
        v2 = a2 == 255;
        v3 = 254 - a2 & a2;
    }
    if (v2 || v1 < 0 != v3 < 0) {
        // 0x3fa00
        float64_t v4; // 0x3f9ec
        __asm_vpush(v4);
        int32_t v5; // 0x3f9ec
        int32_t result = function_11f94(&g100, a2, v5, v5); // 0x3fa14
        __asm_vldr(0);
        __asm_vldmia_19(32 * (256 * result2 + a2) + (int32_t)&g101, v4);
        return result;
    }
    // 0x3f9f8
    __asm_vldr(0);
    return result2;
}

// Address range: 0x3fa38 - 0x3fa44
int32_t function_3fa38(int32_t a1, int32_t a2, int32_t a3, int32_t result) {
    // 0x3fa38
    int32_t v1; // 0x3fa38
    __asm_mrc(15, 1, v1, 8, 11, 7);
    return result;
}

// Address range: 0x3fa44 - 0x3fa48
int32_t function_3fa44(void) {
    // 0x3fa44
    int32_t v1; // 0x3fa44
    return function_11ea4((int32_t *)v1, v1, v1, v1);
}

// Address range: 0x3fa4a - 0x3fa52
int32_t function_3fa4a(void) {
    // 0x3fa4a
    int32_t v1; // 0x3fa4a
    bool v2; // 0x3fa4a
    if (v2) {
        v1 = function_7b526();
    }
    int32_t result = v1; // 0x3fa4e
    if (v2 == !v2) {
        result = function_fb2f6();
    }
    // 0x3fa52
    return result;
}

// Address range: 0x3fa54 - 0x3fa58
int32_t function_3fa54(int32_t a1, int32_t a2, int32_t a3) {
    // 0x3fa54
    int32_t result; // 0x3fa54
    return result;
}

// Address range: 0x3fa64 - 0x3fb58
int32_t function_3fa64(int32_t a1) {
    int32_t sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP); // 0x3fa80
    char * v1; // bp-2064, 0x3fa64
    if (sock_fd < 0) {
        // 0x3faec
        v1 = (char *)0x6f727265;
        function_2e584(0, (int32_t *)&v1, 0);
        // 0x3fae0
        return -1;
    }
    int32_t v2 = ioctl(sock_fd, 0x8927); // 0x3faac
    if (v2 < 0) {
        // 0x3fb24
        v1 = (char *)0x6f727265;
        function_2e584(0, (int32_t *)&v1, 0);
        close(sock_fd);
        // 0x3fae0
        return -2;
    }
    // 0x3fac4
    int32_t v3; // bp-2079, 0x3fa64
    int32_t v4 = &v3; // 0x3fac4
    int32_t v5 = a1 - 1; // 0x3fac8
    v4++;
    v5++;
    *(char *)v5 = *(char *)v4;
    while (v5 != (v2 >= 0 ? a1 + 5 : v2)) {
        // 0x3fac4
        v4++;
        v5++;
        *(char *)v5 = *(char *)v4;
    }
    // 0x3fad4
    close(sock_fd);
    // 0x3fae0
    return 0;
}

// Address range: 0x3fb58 - 0x3fd74
int32_t function_3fb58(void) {
    int32_t v1 = 0; // bp-2092, 0x3fb7c
    memset(&g102, 0, 292);
    function_40314(2, &v1);
    uint32_t v2 = v1; // 0x3fb90
    char * str; // bp-2088, 0x3fb58
    if (v2 == 0) {
        // 0x3fcf0
        str = (char *)0x6e6e6143;
        return function_2e584(0, (int32_t *)&str, 0);
    }
    int32_t v3; // 0x3fb58
    int32_t result2; // 0x3fb58
    int32_t v4; // 0x3fb58
    if (v2 < 0) {
        int32_t v5 = v2 / 0x1000000; // 0x3fc40
        v1 = v5;
        g103 = 1;
        snprintf((char *)&str, 2048, "HASH_ON_PLUG T9 = 0x%x\n", v5);
        int32_t result = function_2e584(2, (int32_t *)&str, 0); // 0x3fc74
        if (v1 == 0) {
            // 0x3fc34
            return result;
        }
        int32_t v6 = g102;
        uint32_t v7 = v1;
        int32_t v8 = 0;
        int32_t v9 = 0; // 0x3fcbc
        int32_t v10 = v6; // 0x3fcbc
        int32_t v11; // 0x3fcb8
        if (v7 % 2 != 0) {
            // 0x3fcc0
            v11 = 72 * v6;
            *(int32_t *)(v11 + (int32_t)&g102 + 4) = v8;
            switch ((int31_t)v8) {
                case 1: {
                    // 0x3fd60
                    *(int32_t *)(v11 + (int32_t)&g102 + 12) = 2;
                    *(int32_t *)(v11 + (int32_t)&g102 + 16) = 10;
                    *(int32_t *)(v11 + (int32_t)&g102 + 20) = 11;
                    *(int32_t *)(v11 + (int32_t)&g102 + 8) = 3;
                    // break -> 0x3fcd8
                    break;
                }
                case 0: {
                    // 0x3fd4c
                    *(int32_t *)(v11 + (int32_t)&g102 + 12) = 1;
                    *(int32_t *)(v11 + (int32_t)&g102 + 16) = 8;
                    *(int32_t *)(v11 + (int32_t)&g102 + 20) = 9;
                    *(int32_t *)(v11 + (int32_t)&g102 + 8) = 3;
                    // break -> 0x3fcd8
                    break;
                }
                case 2: {
                    // 0x3fd34
                    *(int32_t *)(v11 + (int32_t)&g102 + 12) = 3;
                    *(int32_t *)(v11 + (int32_t)&g102 + 16) = 12;
                    *(int32_t *)(v11 + (int32_t)&g102 + 20) = 13;
                    *(int32_t *)(v11 + (int32_t)&g102 + 8) = 3;
                    // break -> 0x3fcd8
                    break;
                }
            }
            // 0x3fcd8
            v9 = 1;
            v10 = v6 + 1;
        }
        int32_t v12 = v10;
        int32_t v13 = v9;
        int32_t v14 = v8 + 1; // 0x3fce4
        result2 = v14;
        v4 = v13;
        v3 = v12;
        int32_t v15 = v7 / 2; // 0x3fce8
        while (v7 >= 2) {
            // 0x3fcb0
            v6 = v12;
            v7 = v15;
            v8 = v14;
            v9 = v13;
            v10 = v6;
            if (v7 % 2 != 0) {
                // 0x3fcc0
                v11 = 72 * v6;
                *(int32_t *)(v11 + (int32_t)&g102 + 4) = v8;
                switch ((int31_t)v8) {
                    case 1: {
                        // 0x3fd60
                        *(int32_t *)(v11 + (int32_t)&g102 + 12) = 2;
                        *(int32_t *)(v11 + (int32_t)&g102 + 16) = 10;
                        *(int32_t *)(v11 + (int32_t)&g102 + 20) = 11;
                        *(int32_t *)(v11 + (int32_t)&g102 + 8) = 3;
                        // break -> 0x3fcd8
                        break;
                    }
                    case 0: {
                        // 0x3fd4c
                        *(int32_t *)(v11 + (int32_t)&g102 + 12) = 1;
                        *(int32_t *)(v11 + (int32_t)&g102 + 16) = 8;
                        *(int32_t *)(v11 + (int32_t)&g102 + 20) = 9;
                        *(int32_t *)(v11 + (int32_t)&g102 + 8) = 3;
                        // break -> 0x3fcd8
                        break;
                    }
                    case 2: {
                        // 0x3fd34
                        *(int32_t *)(v11 + (int32_t)&g102 + 12) = 3;
                        *(int32_t *)(v11 + (int32_t)&g102 + 16) = 12;
                        *(int32_t *)(v11 + (int32_t)&g102 + 20) = 13;
                        *(int32_t *)(v11 + (int32_t)&g102 + 8) = 3;
                        // break -> 0x3fcd8
                        break;
                    }
                }
                // 0x3fcd8
                v9 = 1;
                v10 = v6 + 1;
            }
            // 0x3fce0
            v12 = v10;
            v13 = v9;
            v14 = v8 + 1;
            result2 = v14;
            v4 = v13;
            v3 = v12;
            v15 = v7 / 2;
        }
    } else {
        int32_t v16 = v2 % 0x10000; // 0x3fba0
        g103 = 0;
        v1 = v16;
        snprintf((char *)&str, 2048, "HASH_ON_PLUG V9 = 0x%x\n", v16);
        function_2e584(2, (int32_t *)&str, 0);
        if (v1 == 0) {
            // 0x3fc34
            return 0;
        }
        int32_t v17 = g102;
        uint32_t v18 = v1;
        int32_t v19 = 0;
        int32_t v20 = 0; // 0x3fbf8
        int32_t v21 = v17; // 0x3fbf8
        int32_t v22; // 0x3fbf4
        int32_t * v23; // 0x3fbfc
        int32_t v24; // 0x3fbfc
        if (v18 % 2 != 0) {
            // 0x3fbfc
            v22 = 72 * v17;
            v23 = (int32_t *)(v22 + (int32_t)&g102 + 8);
            v24 = *v23;
            *(int32_t *)(v22 + (int32_t)&g102 + 4) = v19;
            *v23 = v24 + 1;
            *(int32_t *)(4 * (v24 + 18 * v17) + (int32_t)&g102 + 12) = v19;
            v20 = 1;
            v21 = v17 + 1;
        }
        int32_t v25 = v21;
        int32_t v26 = v20;
        int32_t v27 = v19 + 1; // 0x3fc28
        int32_t v28 = v18 / 2; // 0x3fc28
        result2 = 0;
        v4 = v26;
        v3 = v25;
        while (v18 >= 2) {
            // 0x3fbec
            v17 = v25;
            v18 = v28;
            v19 = v27;
            v20 = v26;
            v21 = v17;
            if (v18 % 2 != 0) {
                // 0x3fbfc
                v22 = 72 * v17;
                v23 = (int32_t *)(v22 + (int32_t)&g102 + 8);
                v24 = *v23;
                *(int32_t *)(v22 + (int32_t)&g102 + 4) = v19;
                *v23 = v24 + 1;
                *(int32_t *)(4 * (v24 + 18 * v17) + (int32_t)&g102 + 12) = v19;
                v20 = 1;
                v21 = v17 + 1;
            }
            // 0x3fc20
            v25 = v21;
            v26 = v20;
            v27 = v19 + 1;
            v28 = v18 / 2;
            result2 = 0;
            v4 = v26;
            v3 = v25;
        }
    }
    // 0x3fc2c
    if (v4 != 0) {
        g102 = v3;
    }
    // 0x3fc34
    return result2;
}

// Address range: 0x3fd74 - 0x3fe60
int32_t function_3fd74(void) {
    // 0x3fd74
    if (g104 != 0) {
        // 0x3fd98
        return 0;
    }
    // 0x3fda8
    char * v1; // bp-2072, 0x3fd74
    if (function_40228() != 0) {
        // 0x3fdf8
        v1 = (char *)0x61677066;
        function_2e584(0, (int32_t *)&v1, 0);
        // 0x3fd98
        return -1;
    }
    // 0x3fdb4
    if (function_4044c() != 0) {
        // 0x3fe2c
        v1 = (char *)0x6f697067;
        function_2e584(0, (int32_t *)&v1, 0);
        // 0x3fd98
        return -2;
    }
    // 0x3fdc0
    memset(&g102, 0, 292);
    function_3fb58();
    g104 = 1;
    function_3fefc();
    function_42694();
    function_419d8();
    return 0;
}

// Address range: 0x3fe60 - 0x3fe98
int32_t function_3fe60(void) {
    // 0x3fe60
    if (g104 == 0) {
        int32_t result; // 0x3fe60
        return result;
    }
    // 0x3fe78
    function_41a38();
    function_40248();
    function_3ff04();
    function_42724();
    int32_t result2 = function_40454(); // 0x3fe88
    g104 = 0;
    return result2;
}

// Address range: 0x3fe98 - 0x3fec0
int32_t function_3fe98(int32_t * a1) {
    // 0x3fe98
    if (a1 == NULL) {
        return 0;
    }
    // 0x3fea4
    function_3fb58();
    int32_t v1; // 0x3fe98
    return function_11fc4(a1, (int32_t)&g102, 36, v1);
}

// Address range: 0x3fec0 - 0x3fee8
int32_t function_3fec0(int32_t a1) {
    if (a1 == 0) {
        // 0x3fee0
        return -1;
    }
    // 0x3fec8
    *(int32_t *)a1 = 0;
    *(int32_t *)(a1 + 4) = 0;
    *(int32_t *)(a1 + 8) = 0;
    *(int32_t *)(a1 + 12) = 0;
    return function_3fa64(a1);
}

// Address range: 0x3fee8 - 0x3fef4
int32_t function_3fee8(int32_t a1) {
    int32_t v1 = a1; // 0x3feec
    if (a1 == 0) {
        v1 = function_3fef4(0);
    }
    // 0x3fef0
    return function_3fa64(v1);
}

// Address range: 0x3fef4 - 0x3fef8
int32_t function_3fef4(int32_t a1) {
    // 0x3fef4
    int32_t v1; // 0x3fef4
    return function_406ba(a1, v1);
}

// Address range: 0x3fef8 - 0x3fefc
int32_t function_3fef8(void) {
    // 0x3fef8
    int32_t result; // 0x3fef8
    return result;
}

// Address range: 0x3fefc - 0x3ff04
int32_t function_3fefc(void) {
    // 0x3fefc
    return 0;
}

// Address range: 0x3ff04 - 0x3ff08
int32_t function_3ff04(void) {
    // 0x3ff04
    int32_t result; // 0x3ff04
    return result;
}

// Address range: 0x3ff08 - 0x3ff90
int32_t function_3ff08(int32_t a1) {
    int32_t v1 = 0; // bp-24, 0x3ff20
    int32_t v2; // bp-20, 0x3ff08
    function_40314(0, &v2);
    v2 %= 0x10000;
    int32_t v3 = 6; // 0x3ff30
    function_40314(1, &v1);
    while (__asm_ubfx(v1, 8, 3) != a1) {
        int32_t v4 = v3;
        usleep(0x2710);
        v3 = v4 - 1;
        if (v4 == 1) {
            // 0x3ff60
            return -1;
        }
        function_40314(1, &v1);
    }
    // 0x3ff60
    return (v2 == 0xb025 ? 240 : 120) * (v1 % 256);
}

// Address range: 0x3ff90 - 0x3ff98
int32_t function_3ff90(void) {
    // 0x3ff90
    return 6;
}

// Address range: 0x3ff98 - 0x3ffa0
int32_t function_3ff98(void) {
    // 0x3ff98
    return -1;
}

// Address range: 0x3ffa0 - 0x3ffec
int32_t function_3ffa0(int32_t a1) {
    switch (a1) {
        case 0: {
            // 0x3ffe0
            return function_40ed4(954, 1);
        }
        case 1: {
            // 0x3ffb0
            return function_40ed4(955, 1);
        }
    }
    int32_t v1 = function_40ed4(954, 1); // 0x3ffc4
    return function_40ed4(955, 1) + v1;
}

// Address range: 0x3ffec - 0x40038
int32_t function_3ffec(int32_t a1) {
    switch (a1) {
        case 0: {
            // 0x40030
            return function_40ed4(954, 0);
        }
        case 1: {
            // 0x3fffc
            return function_40ed4(955, 0);
        }
    }
    int32_t v1 = function_40ed4(954, 0); // 0x40014
    return function_40ed4(955, 0) + v1;
}

// Address range: 0x40038 - 0x40228
int32_t function_40038(void) {
    int32_t v1 = open64("/dev/axi_fpga_dev", 2); // 0x40050
    g105 = v1;
    int32_t str; // bp-2072, 0x40038
    if (v1 < 0) {
        // 0x40124
        snprintf((char *)&str, 2048, "/dev/axi_fpga_dev open failed. fd = %d\n", v1);
        function_2e584(0, &str, 0);
        // 0x40118
        return -1;
    }
    int32_t v2 = function_11fd0(0, 0x1200, 3, 1, v1); // 0x40088
    g106 = v2;
    if (v2 == 0) {
        // 0x401a4
        snprintf((char *)&str, 2048, "mmap axi_fpga_addr failed. axi_fpga_addr = %p\n", NULL);
        function_2e584(0, &str, 0);
        close(g105);
        // 0x40118
        return -2;
    }
    int32_t v3 = open64("/dev/fpga_mem", 2); // 0x400a8
    g107 = v3;
    if (v3 < 0) {
        // 0x40154
        snprintf((char *)&str, 2048, "/dev/fpga_mem open failed. fd_fpga_mem_hal = %d\n", v3);
        function_2e584(0, &str, 0);
        perror("open");
        munmap((int32_t *)g106, 0x1200);
        close(g105);
        // 0x40118
        return -1;
    }
    int32_t v4 = function_11fd0(0, 0x1000000, 3, 1, v3); // 0x400d0
    g108 = v4;
    int32_t result; // 0x40038
    if (v4 == 0) {
        // 0x401dc
        snprintf((char *)&str, 2048, "mmap fpga_mem_addr_hal failed. fpga_mem_addr_hal = 0x%x\n", 0);
        function_2e584(0, &str, 0);
        munmap((int32_t *)g106, 0x1200);
        close(g105);
        close(g107);
        result = -1;
    } else {
        // 0x400e4
        snprintf((char *)&str, 2048, "mmap fpga_mem_addr_hal = 0x%x\n", v4);
        function_2e584(3, &str, 0);
        g109 = 1;
        result = 0;
    }
    // 0x40118
    return result;
}

// Address range: 0x40228 - 0x40248
int32_t function_40228(void) {
    // 0x40228
    if (g109 == 0) {
        // 0x40244
        return function_40038();
    }
    // 0x4023c
    return 0;
}

// Address range: 0x40248 - 0x40314
int32_t function_40248(void) {
    // 0x40248
    if (g109 == 0) {
        // 0x40264
        int32_t result; // 0x40248
        return result;
    }
    // 0x4026c
    char * v1; // bp-2056, 0x40248
    if (munmap((int32_t *)g106, 0x1200) < 0) {
        // 0x402b4
        v1 = (char *)0x6d6e756d;
        function_2e584(0, (int32_t *)&v1, 0);
    }
    // 0x40280
    if (munmap((int32_t *)g108, 0x1000000) < 0) {
        // 0x402dc
        v1 = (char *)0x6d6e756d;
        function_2e584(0, (int32_t *)&v1, 0);
    }
    // 0x40294
    g109 = 0;
    close(g105);
    return close(g107);
}

// Address range: 0x40314 - 0x40390
int32_t function_40314(int32_t a1, int32_t * a2) {
    // 0x40314
    if (g109 == 0) {
        // 0x4037c
        if (function_40038() != 0) {
            // 0x40388
            return -1;
        }
    }
    int32_t v1 = g103 == 0 ? (int32_t)&g307 + 744 : (int32_t)&g307;
    int32_t v2 = *(int32_t *)(4 * *(int32_t *)(v1 + 4 * a1) + g106); // 0x4035c
    *a2 = v2;
    return 0;
}

// Address range: 0x40390 - 0x40408
int32_t function_40390(int32_t a1, int32_t a2) {
    // 0x40390
    if (g109 == 0) {
        // 0x403f4
        if (function_40038() != 0) {
            // 0x40400
            return -1;
        }
    }
    int32_t v1 = g103 == 0 ? (int32_t)&g307 + 744 : (int32_t)&g307;
    *(int32_t *)(4 * *(int32_t *)(v1 + 4 * a1) + g106) = a2;
    return 0;
}

// Address range: 0x40408 - 0x4043c
int32_t function_40408(void) {
    // 0x40408
    if (g109 != 0 || function_40038() == 0) {
        // 0x40420
        return g108;
    }
    // 0x40434
    return 0;
}

// Address range: 0x4043c - 0x4044c
int32_t function_4043c(int32_t a1, int32_t a2) {
    // 0x4043c
    return a1 - a2;
}

// Address range: 0x4044c - 0x40454
int32_t function_4044c(void) {
    // 0x4044c
    return 0;
}

// Address range: 0x40454 - 0x40458
int32_t function_40454(void) {
    // 0x40454
    int32_t result; // 0x40454
    return result;
}

// Address range: 0x40458 - 0x40544
int32_t function_40458(int32_t a1, int32_t a2) {
    int32_t v1 = a1; // bp-2076, 0x40464
    if (a2 == 0) {
        function_40590();
    }
    int32_t v2 = a2; // 0x40480
    int32_t v3; // 0x40458
    int32_t v4; // 0x40458
    if (g110 == 0) {
        // 0x404bc
        function_11fdc((int32_t)&g111, 0);
        g112 = function_432d0(0x4043c, 0, 0);
        function_11fdc((int32_t)&g113, 0);
        g114 = 1;
        int32_t attr; // bp-2072, 0x40458
        pthread_attr_init(&attr);
        function_12024(&attr, &g8);
        pthread_create(&g115, &attr, (int32_t * (*)(int32_t *))&g49, NULL);
        g110 = 1;
        v2 = &attr;
        v3 = (int32_t)&g49;
        v4 = 0;
    }
    // 0x40484
    if (function_11f94(&g111, v2, v3, v4) != 0) {
        function_40558();
    }
    // 0x40494
    if (function_43338(g112) == 0) {
        // 0x4052c
        return g112;
    }
    // 0x404a8
    function_11ea4(&g111, (int32_t)&v1, v3, v4);
    return 0;
}

// Address range: 0x40544 - 0x40548
int32_t function_40544(void) {
    // 0x40544
    return function_40c8a();
}

// Address range: 0x40548 - 0x40558
int32_t function_40548(void) {
    // 0x40548
    int32_t v1; // 0x40548
    return function_43320(v1);
}

// Address range: 0x40558 - 0x40590
int32_t function_40558(void) {
    // 0x40558
    int32_t v1; // 0x40558
    int32_t * v2 = (int32_t *)v1; // 0x40568
    *v2 = 0x6c696166;
    *(int32_t *)(v1 + 4) = 0x206f7420;
    *(int32_t *)(v1 + 8) = 0x6b636f6c;
    *(int32_t *)(v1 + 12) = 0x69706720;
    *(int32_t *)(v1 + 16) = 0x7463206f;
    *(int32_t *)(v1 + 20) = 0x6d206c72;
    *(int32_t *)(v1 + 24) = 0x78657475;
    *(int16_t *)(v1 + 28) = 10;
    function_2e584(0, v2, 0);
    return -1;
}

// Address range: 0x40590 - 0x405c8
int32_t function_40590(void) {
    // 0x40590
    int32_t v1; // 0x40590
    int32_t v2 = v1;
    char * v3 = (char *)0x20646162; // bp+16, 0x405a0
    function_2e584(v2, (int32_t *)&v3, v2);
    return -1;
}

// Address range: 0x405cc - 0x406b8
int32_t function_405cc(int32_t a1, int32_t a2) {
    int32_t v1 = a1; // bp-2068, 0x405dc
    if (a2 == 0) {
        // 0x40654
        return 0x20646162;
    }
    // 0x405e4
    char * v2; // bp-2064, 0x405cc
    int32_t v3; // 0x405cc
    if (function_11f94(&g111, a2, v3, a2) != 0) {
        // 0x40670
        v2 = (char *)0x6c696166;
        function_2e584(0, (int32_t *)&v2, 0);
        // 0x40654
        return -1;
    }
    // 0x405fc
    int32_t v4; // 0x405cc
    int32_t v5; // 0x405cc
    int32_t v6; // 0x405cc
    if (function_43338(g112) == 1) {
        // 0x40660
        function_43358(g112);
        v4 = &v1;
        v6 = a2;
    } else {
        // 0x40610
        v2 = (char *)0x6c6c6163;
        function_2e584(1, (int32_t *)&v2, 0);
        v4 = (int32_t)&v2;
        v5 = 0;
        v6 = 0x64657265;
    }
    // 0x40648
    function_11ea4(&g111, v4, v5, v6);
    // 0x40654
    return 0;
}

// Address range: 0x406ba - 0x406c0
int32_t function_406ba(int32_t a1, int32_t a2) {
    // 0x406ba
    int32_t v1; // 0x406ba
    *(int32_t *)v1 = a1;
    *(int32_t *)(v1 + 4) = a2;
    return function_40544();
}

// Address range: 0x406c0 - 0x406e0
int32_t function_406c0(int32_t a1, int32_t a2, uint32_t a3, int32_t a4) {
    // 0x406c0
    int32_t v1; // 0x406c0
    *(int16_t *)v1 = (int16_t)a3;
    *(char *)(v1 + 2) = (char)(a3 / 0x10000);
    int32_t v2; // 0x406c0
    function_2e584(a1, &v2, a4);
    return -1;
}

// Address range: 0x406e4 - 0x40790
int32_t function_406e4(int32_t a1) {
    // 0x406e4
    char * str; // bp-2064, 0x406e4
    int32_t result; // 0x406e4
    int32_t v1; // 0x406e4
    if (function_11f94(&g113, v1, v1, v1) == 0) {
        // 0x40704
        snprintf((char *)&str, 64, "/sys/class/gpio/gpio%d", a1);
        int32_t v2 = access((char *)&str, F_OK); // 0x40724
        function_11ea4(&g113, 0, (int32_t)"/sys/class/gpio/gpio%d", a1);
        result = v2 == 0;
    } else {
        // 0x4075c
        str = (char *)0x6c696166;
        function_2e584(0, (int32_t *)&str, 0);
        result = -1;
    }
    // 0x4073c
    return result;
}

// Address range: 0x40794 - 0x4090c
int32_t function_40794(int32_t a1) {
    // 0x40794
    char * str2; // bp-2064, 0x40794
    int32_t v1; // 0x40794
    if (function_11f94(&g113, v1, v1, v1) != 0) {
        // 0x40854
        str2 = (char *)0x6c696166;
        function_2e584(0, (int32_t *)&str2, 0);
        // 0x40838
        return -1;
    }
    // 0x407b0
    int32_t str; // bp-2128, 0x40794
    snprintf((char *)&str, 64, "/sys/class/gpio/gpio%d", a1);
    if (access((char *)&str, F_OK) == 0) {
        // 0x40840
        function_11ea4(&g113, 0, (int32_t)"/sys/class/gpio/gpio%d", a1);
        return 0;
    }
    int32_t fd = open64("/sys/class/gpio/export", 1); // 0x407e8
    if (fd < 0) {
        // 0x40888
        str2 = (char *)0x6c696146;
        function_2e584(0, (int32_t *)&str2, 0);
        function_11ea4(&g113, (int32_t)&str2, 0, 0x6e697469);
        // 0x40838
        return -2;
    }
    int32_t chars_printed = snprintf((char *)&str, 64, "%d", a1); // 0x40808
    int32_t result; // 0x40794
    if (write(fd, &str, chars_printed) < 0) {
        // 0x408cc
        snprintf((char *)&str2, 2048, "Failed to export gpio %d!", a1);
        function_2e584(0, (int32_t *)&str2, 0);
        close(fd);
        function_11ea4(&g113, (int32_t)&str2, 0, a1);
        result = -3;
    } else {
        // 0x40824
        close(fd);
        function_11ea4(&g113, (int32_t)&str, chars_printed, a1);
        result = 0;
    }
    // 0x40838
    return result;
}

// Address range: 0x40910 - 0x40a00
int32_t function_40910(int32_t a1) {
    // 0x40910
    int32_t v1; // 0x40910
    int32_t amode = function_11f94(&g113, v1, v1, v1); // 0x40924
    if (amode != 0) {
        function_40a18();
    }
    // 0x40930
    int32_t str; // bp-2128, 0x40910
    snprintf((char *)&str, 64, "/sys/class/gpio/gpio%d", a1);
    int32_t v2 = access((char *)&str, amode); // 0x40950
    if (v2 != 0) {
        // 0x409c4
        int32_t str2; // bp-2064, 0x40910
        snprintf((char *)&str2, 2048, "port %d already unexported, ret = %d\n", a1, v2);
        function_2e584(1, &str2, amode);
        perror("access error");
        return &g488;
    }
    int32_t fd = open64("/sys/class/gpio/unexport", 1); // 0x40968
    if (fd < 0) {
        function_40a4c();
    }
    int32_t chars_printed = snprintf((char *)&str, 64, "%d", a1); // 0x40988
    if (write(fd, &str, chars_printed) < 0) {
        function_40a94();
    }
    // 0x409a4
    close(fd);
    function_11ea4(&g113, (int32_t)&str, chars_printed, a1);
    return 0;
}

// Address range: 0x40a02 - 0x40a04
int32_t function_40a02(void) {
    // 0x40a02
    return function_40544();
}

// Address range: 0x40a04 - 0x40a18
int32_t function_40a04(int32_t a1, int32_t a2, int32_t a3) {
    // 0x40a04
    int32_t result; // 0x40a04
    function_11ea4((int32_t *)result, result, result, result);
    return result;
}

// Address range: 0x40a18 - 0x40a4c
int32_t function_40a18(void) {
    char * v1 = (char *)0x6c696166; // bp+72, 0x40a30
    return function_2e584(0, (int32_t *)&v1, 0);
}

// Address range: 0x40a4c - 0x40a94
int32_t function_40a4c(void) {
    // 0x40a4c
    int32_t v1; // 0x40a4c
    int32_t v2 = v1;
    char * v3 = (char *)0x6c696146; // bp+72, 0x40a5c
    function_2e584(v2, (int32_t *)&v3, v2);
    return function_11ea4(&g113, (int32_t)&v3, v2, 0x74697277);
}

// Address range: 0x40a94 - 0x40ad4
int32_t function_40a94(void) {
    // 0x40a94
    int32_t fd; // 0x40a94
    int32_t v1 = fd;
    int32_t str; // bp+72, 0x40a94
    snprintf((char *)&str, 2048, "Failed to unexport gpio %d!", fd);
    function_2e584(v1, &str, v1);
    close(fd);
    return function_11ea4(&g113, (int32_t)&str, v1, fd);
}

// Address range: 0x40ad8 - 0x40c24
int32_t function_40ad8(int32_t a1, int32_t a2) {
    // 0x40ad8
    char * str2; // bp-2072, 0x40ad8
    int32_t v1; // 0x40ad8
    if (function_11f94(&g113, a2, v1, v1) != 0) {
        // 0x40b74
        str2 = (char *)0x6c696166;
        function_2e584(0, (int32_t *)&str2, 0);
        // 0x40b68
        return -1;
    }
    // 0x40afc
    int32_t str; // bp-2136, 0x40ad8
    snprintf((char *)&str, 64, "/sys/class/gpio/gpio%d/direction", a1);
    int32_t fd = open64((char *)&str, 1); // 0x40b1c
    if (fd < 0) {
        // 0x40bec
        snprintf((char *)&str2, 2048, "Failed to open gpio %d direction for writing!\n", a1);
        function_2e584(0, (int32_t *)&str2, 0);
        function_11ea4(&g113, (int32_t)&str2, 0, a1);
        // 0x40b68
        return -2;
    }
    int32_t buf = a2 == 0 ? (int32_t)"in" : (int32_t)"in" + 3;
    int32_t nbyte = a2 == 0 ? 2 : 3;
    int32_t result; // 0x40ad8
    if (write(fd, (int32_t *)buf, nbyte) < 0) {
        // 0x40ba8
        snprintf((char *)&str2, 2048, "Failed to set gpio %d direction %s !\n", a1, (char *)buf);
        function_2e584(0, (int32_t *)&str2, 0);
        close(fd);
        function_11ea4(&g113, (int32_t)&str2, 0, a1);
        result = -3;
    } else {
        // 0x40b54
        close(fd);
        function_11ea4(&g113, buf, nbyte, (int32_t)"in");
        result = 0;
    }
    // 0x40b68
    return result;
}

// Address range: 0x40c28 - 0x40c88
int32_t function_40c28(int32_t a1, char * a2) {
    // 0x40c28
    int32_t v1; // 0x40c28
    int32_t v2 = function_11f94(&g113, (int32_t)a2, v1, v1); // 0x40c48
    if (v2 != 0) {
        function_40cd0();
    }
    // 0x40c54
    int32_t str; // bp-2136, 0x40c28
    snprintf((char *)&str, 64, "/sys/class/gpio/gpio%d/value", a1);
    int32_t v3 = open64((char *)&str, v2); // 0x40c74
    int32_t result = v3; // 0x40c7c
    if (v3 < 0) {
        result = function_40d04();
    }
    // 0x40c80
    return result;
}

// Address range: 0x40c8a - 0x40c8c
int32_t function_40c8a(void) {
    // 0x40c8a
    int32_t result; // 0x40c8a
    return result;
}

// Address range: 0x40c8c - 0x40cc0
int32_t function_40c8c(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x40c8c
    if (function_11f40(a1, a2, a3) < 0) {
        function_40d3c();
    }
    // 0x40c9c
    int32_t fd; // 0x40c8c
    close(fd);
    function_11ea4(&g113, a2, a3, a4);
    int32_t result = function_11ef8((int32_t *)a4, fd, 10); // 0x40cb8
    *(char *)fd = (char)result;
    return result;
}

// Address range: 0x40cc0 - 0x40cd0
int32_t function_40cc0(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x40cc0
    int32_t result; // 0x40cc0
    return result;
}

// Address range: 0x40cd0 - 0x40d04
int32_t function_40cd0(void) {
    // 0x40cd0
    int32_t v1; // 0x40cd0
    int32_t v2 = v1;
    char * v3 = (char *)0x6c696166; // bp+80, 0x40ce8
    function_2e584(v2, (int32_t *)&v3, v2);
    int32_t result = function_40cc0((int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488); // 0x40d00
    return result;
}

// Address range: 0x40d04 - 0x40d3c
int32_t function_40d04(void) {
    // 0x40d04
    int32_t v1; // 0x40d04
    int32_t v2 = v1;
    int32_t str; // bp+80, 0x40d04
    snprintf((char *)&str, 2048, "Failed to open gpio %d value for reading!\n", v1);
    function_2e584(v2, &str, v2);
    function_11ea4(&g113, (int32_t)&str, v2, v1);
    int32_t result = function_40cc0((int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488); // 0x40d38
    return result;
}

// Address range: 0x40d3c - 0x40d8c
int32_t function_40d3c(void) {
    // 0x40d3c
    int32_t fd; // 0x40d3c
    int32_t v1 = fd;
    char * v2 = (char *)0x6c696146; // bp+80, 0x40d4c
    function_2e584(v1, (int32_t *)&v2, v1);
    close(fd);
    function_11ea4(&g113, (int32_t)&v2, v1, 0);
    int32_t result = function_40cc0((int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488); // 0x40d88
    return result;
}

// Address range: 0x40d90 - 0x40ed4
int32_t function_40d90(void) {
    // 0x40d90
    prctl(PR_SET_NAME, (int32_t)"gpio", 0, 0, 0);
    if (g114 == 0) {
        // 0x40ec8
        return 0;
    }
    // 0x40de8
    int32_t v1; // bp-40, 0x40d90
    int32_t v2 = &v1;
    char v3; // bp-41, 0x40d90
    int32_t v4 = &v3;
    int32_t v5 = 0;
    int32_t v6 = (int32_t)"gpio";
    int32_t v7 = function_11f94(&g111, v6, v5, g114); // 0x40dec
    int32_t v8 = v6; // 0x40df4
    int32_t v9 = v5; // 0x40df4
    int32_t v10; // 0x40d90
    int32_t v11; // 0x40d90
    int32_t v12; // 0x40d90
    int32_t v13; // 0x40d90
    int32_t v14; // 0x40d90
    int32_t v15; // 0x40d90
    int32_t v16; // 0x40d90
    int32_t v17; // 0x40d90
    int32_t * v18; // 0x40e74
    int32_t * v19; // 0x40d90
    int32_t v20; // 0x40e8c
    int32_t v21; // 0x40e9c
    int32_t v22; // 0x40e18
    int32_t v23; // 0x40e1c
    int32_t v24; // 0x40e8c
    int32_t v25; // 0x40e9c
    int32_t v26; // 0x40dfc
    int32_t * v27; // 0x40e00
    if (v7 == 0) {
        // 0x40df8
        v26 = function_43440(g112);
        v27 = (int32_t *)v26;
        v13 = v6;
        v16 = v5;
        v11 = *v27;
        if (v26 != 0) {
            // 0x40e74
            v18 = (int32_t *)(v26 + 20);
            v19 = (int32_t *)(v26 + 4);
            v20 = *(int32_t *)*(int32_t *)(*v18 + 16);
            v3 = 0;
            v21 = function_40c28(*(int32_t *)v20, &v3);
            v15 = v5;
            v10 = v20;
            if (v21 == 0) {
                v22 = v3;
                v23 = *v19;
                v12 = v22;
                v14 = v22;
                v17 = v22;
                if (v23 != v22) {
                    // 0x40e2c
                    v1 = *v27;
                    v12 = v2;
                    v14 = 8;
                    v17 = v23;
                }
                // 0x40e58
                free(v26, v12, v14, v17);
                v24 = *(int32_t *)*(int32_t *)(*v18 + 16);
                v3 = 0;
                v25 = function_40c28(*(int32_t *)v24, &v3);
                v15 = v14;
                v10 = v24;
                while (v25 == 0) {
                    // 0x40e18
                    v22 = v3;
                    v23 = *v19;
                    v12 = v22;
                    v14 = v22;
                    v17 = v22;
                    if (v23 != v22) {
                        // 0x40e2c
                        v1 = *v27;
                        v12 = v2;
                        v14 = 8;
                        v17 = v23;
                    }
                    // 0x40e58
                    free(v26, v12, v14, v17);
                    v24 = *(int32_t *)*(int32_t *)(*v18 + 16);
                    v3 = 0;
                    v25 = function_40c28(*(int32_t *)v24, &v3);
                    v15 = v14;
                    v10 = v24;
                }
            }
            // 0x40eac
            v11 = v10;
            v16 = v15;
            free(v26, v4, v16, v11);
            v13 = v4;
        }
        // 0x40eb4
        v9 = v16;
        v8 = v13;
        function_43488(v26);
        function_11ea4(&g111, v8, v9, v11);
    }
    // 0x40dd0
    usleep(0x30d40);
    int32_t v28 = g114; // 0x40ddc
    while (v28 != 0) {
        // 0x40de8
        v5 = v9;
        v6 = v8;
        v7 = function_11f94(&g111, v6, v5, v28);
        v8 = v6;
        v9 = v5;
        if (v7 == 0) {
            // 0x40df8
            v26 = function_43440(g112);
            v27 = (int32_t *)v26;
            v13 = v6;
            v16 = v5;
            v11 = *v27;
            if (v26 != 0) {
                // 0x40e74
                v18 = (int32_t *)(v26 + 20);
                v19 = (int32_t *)(v26 + 4);
                v20 = *(int32_t *)*(int32_t *)(*v18 + 16);
                v3 = 0;
                v21 = function_40c28(*(int32_t *)v20, &v3);
                v15 = v5;
                v10 = v20;
                if (v21 == 0) {
                    v22 = v3;
                    v23 = *v19;
                    v12 = v22;
                    v14 = v22;
                    v17 = v22;
                    if (v23 != v22) {
                        // 0x40e2c
                        v1 = *v27;
                        v12 = v2;
                        v14 = 8;
                        v17 = v23;
                    }
                    // 0x40e58
                    free(v26, v12, v14, v17);
                    v24 = *(int32_t *)*(int32_t *)(*v18 + 16);
                    v3 = 0;
                    v25 = function_40c28(*(int32_t *)v24, &v3);
                    v15 = v14;
                    v10 = v24;
                    while (v25 == 0) {
                        // 0x40e18
                        v22 = v3;
                        v23 = *v19;
                        v12 = v22;
                        v14 = v22;
                        v17 = v22;
                        if (v23 != v22) {
                            // 0x40e2c
                            v1 = *v27;
                            v12 = v2;
                            v14 = 8;
                            v17 = v23;
                        }
                        // 0x40e58
                        free(v26, v12, v14, v17);
                        v24 = *(int32_t *)*(int32_t *)(*v18 + 16);
                        v3 = 0;
                        v25 = function_40c28(*(int32_t *)v24, &v3);
                        v15 = v14;
                        v10 = v24;
                    }
                }
                // 0x40eac
                v11 = v10;
                v16 = v15;
                free(v26, v4, v16, v11);
                v13 = v4;
            }
            // 0x40eb4
            v9 = v16;
            v8 = v13;
            function_43488(v26);
            function_11ea4(&g111, v8, v9, v11);
        }
        // 0x40dd0
        usleep(0x30d40);
        v28 = g114;
    }
    // 0x40ec8
    return 0;
}

// Address range: 0x40ed4 - 0x41014
int32_t function_40ed4(int32_t a1, int32_t a2) {
    // 0x40ed4
    char * v1; // bp-2064, 0x40ed4
    int32_t v2; // 0x40ed4
    if (function_11f94(&g113, a2, v2, v2) != 0) {
        // 0x40f58
        v1 = (char *)0x6c696166;
        function_2e584(0, (int32_t *)&v1, 0);
        // 0x40f50
        return -1;
    }
    // 0x40ef4
    int32_t str; // bp-2128, 0x40ed4
    snprintf((char *)&str, 64, "/sys/class/gpio/gpio%d/value", a1);
    int32_t fd = open64((char *)&str, 1); // 0x40f14
    if (fd < 0) {
        // 0x40f8c
        v1 = (char *)0x6c696146;
        function_2e584(0, (int32_t *)&v1, 0);
        function_11ea4(&g113, (int32_t)&v1, 0, 0x72772072);
        // 0x40f50
        return -2;
    }
    int32_t buf = a2 == 0 ? (int32_t)"01" : (int32_t)&g255;
    int32_t result; // 0x40ed4
    if (write(fd, (int32_t *)buf, 1) < 0) {
        // 0x40fd0
        v1 = (char *)0x6c696146;
        function_2e584(0, (int32_t *)&v1, 0);
        close(fd);
        function_11ea4(&g113, (int32_t)&v1, 0, 0x20657469);
        result = -3;
    } else {
        // 0x40f3c
        close(fd);
        function_11ea4(&g113, buf, 1, a1);
        result = 0;
    }
    // 0x40f50
    return result;
}

// Address range: 0x4101c - 0x410bc
int32_t function_4101c(int32_t a1) {
    // 0x4101c
    char * v1; // bp-2056, 0x4101c
    if (g104 == 0) {
        // 0x41084
        v1 = (char *)0x61656c70;
        function_2e584(0, (int32_t *)&v1, 0);
        // 0x41044
        return -2;
    }
    int32_t result = (int32_t)(a1 == 1 | a1 == 0) + a1; // 0x41040
    if (a1 != 0 == (a1 != 1)) {
        // 0x4104c
        v1 = (char *)0x20646162;
        function_2e584(0, (int32_t *)&v1, 0);
        result = -3;
    }
    // 0x41044
    return result;
}

// Address range: 0x410bc - 0x4110c
int32_t function_410bc(int32_t result) {
    if (result < 3) {
        return result;
    }
    char * v1 = (char *)0x20646162; // bp-2056, 0x410e0
    return function_2e584(0, (int32_t *)&v1, 0);
}

// Address range: 0x4110c - 0x411d0
int32_t function_4110c(int32_t a1, uint32_t a2) {
    char * str; // bp-2064, 0x4110c
    if (a1 > 2) {
        // 0x41198
        str = (char *)0x20646162;
        function_2e584(0, (int32_t *)&str, 0);
        // 0x41154
        return -3;
    }
    if (a1 != 1) {
        // 0x41128
        snprintf((char *)&str, 2048, "pwm type %d not supported\n", a1 - 1);
        function_2e584(0, (int32_t *)&str, 0);
        // 0x41154
        return 0;
    }
    int32_t v1 = a2 < 100 ? a2 : 100;
    int32_t v2 = 100 - v1 | 0x10000 * v1; // 0x41170
    function_40390(19, v2);
    function_40390(23, v2);
    return 0;
}

// Address range: 0x411d0 - 0x41250
int32_t function_411d0(int32_t a1, int32_t a2) {
    if (a1 > 2) {
        char * v1 = (char *)0x20646162; // bp-2064, 0x4122c
        function_2e584(0, (int32_t *)&v1, 0);
        // 0x41200
        return -3;
    }
    int32_t result = -5; // 0x411e8
    if (a1 == 1) {
        int32_t * v2 = (int32_t *)a2; // 0x411f4
        function_40314(19, v2);
        *v2 = (int32_t)*(int16_t *)(a2 + 2);
        result = 0;
    }
    // 0x41200
    return result;
}

// Address range: 0x41250 - 0x41474
int32_t function_41250(int32_t a1, int32_t * a2, int32_t * a3, int32_t * a4, int32_t * a5) {
    // 0x41250
    g480 = a1;
    int32_t v1; // 0x41250
    int32_t v2; // 0x41250
    int32_t v3; // 0x41250
    switch (a1) {
        case 0: {
            // 0x412d4
            *a2 = 24;
            v2 = 64;
            v3 = 69;
            v1 = 68;
            // break -> 0x412b4
            break;
        }
        case 1: {
            // 0x412ec
            *a2 = 16;
            v2 = 64;
            v3 = 71;
            v1 = 70;
            // break -> 0x412b4
            break;
        }
        case 2: {
            // 0x41304
            *a2 = 8;
            v2 = 64;
            v3 = 73;
            v1 = 72;
            // break -> 0x412b4
            break;
        }
        case 3: {
            // 0x4131c
            *a2 = 0;
            *a3 = 64;
            *a4 = 74;
            *a5 = 75;
            // 0x412c8
            return 0;
        }
        case 4: {
            // 0x41344
            *a2 = 24;
            v2 = 65;
            v3 = 77;
            v1 = 76;
            // break -> 0x412b4
            break;
        }
        case 5: {
            // 0x4135c
            *a2 = 16;
            v2 = 65;
            v3 = 79;
            v1 = 78;
            // break -> 0x412b4
            break;
        }
        case 6: {
            // 0x41374
            *a2 = 8;
            v2 = 65;
            v3 = 81;
            v1 = 80;
            // break -> 0x412b4
            break;
        }
        case 7: {
            // 0x4138c
            *a2 = 0;
            *a3 = 65;
            *a4 = 82;
            *a5 = 83;
            // 0x412c8
            return 0;
        }
        case 8: {
            // 0x413b4
            *a2 = 24;
            v2 = 66;
            v3 = 85;
            v1 = 84;
            // break -> 0x412b4
            break;
        }
        case 9: {
            // 0x413cc
            *a2 = 16;
            v2 = 66;
            v3 = 87;
            v1 = 86;
            // break -> 0x412b4
            break;
        }
        case 10: {
            // 0x413e4
            *a2 = 8;
            v2 = 66;
            v3 = 116;
            v1 = 115;
            // break -> 0x412b4
            break;
        }
        case 11: {
            // 0x413fc
            *a2 = 0;
            *a3 = 66;
            *a4 = 117;
            *a5 = 118;
            // 0x412c8
            return 0;
        }
        case 12: {
            // 0x41424
            *a2 = 24;
            v2 = 67;
            v3 = 120;
            v1 = 119;
            // break -> 0x412b4
            break;
        }
        case 13: {
            // 0x412a0
            *a2 = 16;
            v2 = 67;
            v3 = 122;
            v1 = 121;
            // break -> 0x412b4
            break;
        }
        default: {
            // 0x4143c
            int32_t str; // bp-2056, 0x41250
            snprintf((char *)&str, 2048, "%s: The uart %d is not supported!!!\n", "get_send_address_info", a1);
            function_2e584(0, &str, 0);
            // 0x412c8
            return -1;
        }
    }
    // 0x412b4
    *a3 = v2;
    *a4 = v1;
    *a5 = v3;
    // 0x412c8
    return 0;
}

// Address range: 0x41474 - 0x41658
int32_t function_41474(int32_t a1) {
    int32_t v1 = 0; // bp-2060, 0x41484
    g481 = a1;
    int32_t result; // 0x41474
    switch (a1) {
        case 0: {
            // 0x414ec
            function_40314(88, &v1);
            result = __asm_ubfx(v1, 16, 10);
            // break -> 0x414e0
            break;
        }
        case 1: {
            // 0x41504
            function_40314(88, &v1);
            result = __asm_ubfx(v1, 0, 10);
            // break -> 0x414e0
            break;
        }
        case 2: {
            // 0x4151c
            function_40314(89, &v1);
            result = __asm_ubfx(v1, 16, 10);
            // break -> 0x414e0
            break;
        }
        case 3: {
            // 0x41534
            function_40314(89, &v1);
            result = __asm_ubfx(v1, 0, 10);
            // break -> 0x414e0
            break;
        }
        case 4: {
            // 0x4154c
            function_40314(90, &v1);
            result = __asm_ubfx(v1, 16, 10);
            // break -> 0x414e0
            break;
        }
        case 5: {
            // 0x41564
            function_40314(90, &v1);
            result = __asm_ubfx(v1, 0, 10);
            // break -> 0x414e0
            break;
        }
        case 6: {
            // 0x4157c
            function_40314(91, &v1);
            result = __asm_ubfx(v1, 16, 10);
            // break -> 0x414e0
            break;
        }
        case 7: {
            // 0x41594
            function_40314(91, &v1);
            result = __asm_ubfx(v1, 0, 10);
            // break -> 0x414e0
            break;
        }
        case 8: {
            // 0x415ac
            function_40314(92, &v1);
            result = __asm_ubfx(v1, 16, 10);
            // break -> 0x414e0
            break;
        }
        case 9: {
            // 0x415c4
            function_40314(92, &v1);
            result = __asm_ubfx(v1, 0, 10);
            // break -> 0x414e0
            break;
        }
        case 10: {
            // 0x415dc
            function_40314(93, &v1);
            result = __asm_ubfx(v1, 16, 10);
            // break -> 0x414e0
            break;
        }
        case 11: {
            // 0x415f4
            function_40314(93, &v1);
            result = __asm_ubfx(v1, 0, 10);
            // break -> 0x414e0
            break;
        }
        case 12: {
            // 0x4160c
            function_40314(94, &v1);
            result = __asm_ubfx(v1, 16, 10);
            // break -> 0x414e0
            break;
        }
        case 13: {
            // 0x414cc
            function_40314(94, &v1);
            result = __asm_ubfx(v1, 0, 10);
            // break -> 0x414e0
            break;
        }
        default: {
            // 0x41624
            int32_t str; // bp-2056, 0x41474
            snprintf((char *)&str, 2048, "%s: The uart%d is not supported!!!\n", "check_how_many_uart_data_in_fpga", a1);
            function_2e584(0, &str, 0);
            result = 0;
            // break -> 0x414e0
            break;
        }
    }
    // 0x414e0
    return result;
}

// Address range: 0x4165c - 0x41790
int32_t function_4165c(int32_t a1) {
    int32_t v1 = 0; // bp-2092, 0x4167c
    int32_t v2 = 0; // bp-2088, 0x41684
    int32_t v3 = 0; // bp-2084, 0x41688
    int32_t v4 = 0; // bp-2080, 0x4168c
    int32_t v5 = 0; // bp-2076, 0x41690
    int32_t * v6 = (int32_t *)(24 * a1 + (int32_t)&g116); // 0x41694
    int32_t v7; // 0x4165c
    function_11f94(v6, v7, v7, 3 * a1);
    int32_t v8 = function_41250(a1, &v5, &v1, &v2, &v3); // 0x416b0
    int32_t v9 = 21; // 0x416b8
    int32_t v10; // 0x4165c
    int32_t str; // bp-2072, 0x4165c
    if (v8 != 0) {
        // 0x41738
        snprintf((char *)&str, 2048, "get_send_address_info error, chain_id = %d\n", a1);
        v10 = a1;
      lab_0x41750:
        // 0x41750
        function_2e584(0, &str, 0);
        return function_11ea4(v6, (int32_t)&str, 0, v10);
    }
    function_40314(v1, &v4);
    int32_t v11 = (v4 >> v5) % 256; // 0x41718
    v4 = v11;
    while (v11 != 255) {
        int32_t v12 = v9;
        function_11f34("%s: waiting fpga uart%d clear send fifo space ...\n", (int32_t *)"clear_uart_tx_fifo", a1, v11);
        function_40390(v2, v4 | -0x80000000);
        usleep(3000);
        v9 = v12 - 1;
        if (v12 == 1) {
            // 0x41770
            snprintf((char *)&str, 2048, "%s: uart%d always dose not has enough send fifo space, break\n", "clear_uart_tx_fifo", a1);
            v10 = (int32_t)"clear_uart_tx_fifo";
            goto lab_0x41750;
        }
        function_40314(v1, &v4);
        v11 = (v4 >> v5) % 256;
        v4 = v11;
    }
    // 0x41728
    return function_11ea4(v6, (int32_t)"clear_uart_tx_fifo", a1, 255);
}

// Address range: 0x41794 - 0x419d4
int32_t function_41794(int32_t a1, int32_t a2, uint32_t a3) {
    char v1 = 0; // bp-2084, 0x417ac
    g483 = a1;
    int32_t v2 = 129; // 0x417b4
    int32_t v3 = 130; // 0x417b4
    int32_t result; // 0x41794
    switch (a1) {
        case 0: {
            // 0x41918
            v2 = 95;
            v3 = 96;
        }
        case 13: {
          lab_0x41868:
            // 0x41868
            function_40390(v2, __asm_ubfx(a3, 0, 10) | -0x80000000);
            result = a3 & -4;
            if (a3 >= 4) {
                int32_t v4 = a2 + 4; // 0x4188c
                function_40314(v3, (int32_t *)&v1);
                *(char *)(a2 + 3) = v1;
                char v5 = v1 >> 7; // 0x418a8
                *(char *)a2 = v5;
                *(char *)(a2 + 1) = v5;
                *(char *)(a2 + 2) = v5;
                while (result + a2 != v4) {
                    int32_t v6 = v4;
                    v4 = v6 + 4;
                    function_40314(v3, (int32_t *)&v1);
                    *(char *)(v6 + 3) = v1;
                    v5 = v1 >> 7;
                    *(char *)v6 = v5;
                    *(char *)(v6 + 1) = v5;
                    *(char *)(v6 + 2) = v5;
                }
            }
            // break -> 0x418bc
            break;
        }
        case 1: {
            // 0x41930
            v2 = 97;
            v3 = 98;
            // branch (via goto) -> 0x41868
            goto lab_0x41868;
        }
        case 2: {
            // 0x4193c
            v2 = 99;
            v3 = 100;
            // branch (via goto) -> 0x41868
            goto lab_0x41868;
        }
        case 3: {
            // 0x41948
            v2 = 101;
            v3 = 102;
            // branch (via goto) -> 0x41868
            goto lab_0x41868;
        }
        case 4: {
            // 0x41954
            v2 = 103;
            v3 = 104;
            // branch (via goto) -> 0x41868
            goto lab_0x41868;
        }
        case 5: {
            // 0x41960
            v2 = 105;
            v3 = 106;
            // branch (via goto) -> 0x41868
            goto lab_0x41868;
        }
        case 6: {
            // 0x4196c
            v2 = 107;
            v3 = 108;
            // branch (via goto) -> 0x41868
            goto lab_0x41868;
        }
        case 7: {
            // 0x4190c
            v2 = 109;
            v3 = 110;
            // branch (via goto) -> 0x41868
            goto lab_0x41868;
        }
        case 8: {
            // 0x41924
            v2 = 111;
            v3 = 112;
            // branch (via goto) -> 0x41868
            goto lab_0x41868;
        }
        case 9: {
            // 0x41978
            v2 = 113;
            v3 = 114;
            // branch (via goto) -> 0x41868
            goto lab_0x41868;
        }
        case 10: {
            // 0x41984
            v2 = 123;
            v3 = 124;
            // branch (via goto) -> 0x41868
            goto lab_0x41868;
        }
        case 11: {
            // 0x41990
            v2 = 125;
            v3 = 126;
            // branch (via goto) -> 0x41868
            goto lab_0x41868;
        }
        case 12: {
            // 0x4199c
            v2 = 127;
            v3 = 128;
            // branch (via goto) -> 0x41868
            goto lab_0x41868;
        }
        default: {
            // 0x417f4
            int32_t str; // bp-2080, 0x41794
            snprintf((char *)&str, 2048, "%s: The uart%d is not supported!!!\n", "get_read_address_info", a1);
            function_2e584(0, &str, 0);
            snprintf((char *)&str, 2048, "get_read_address_info error, chain_id = %d\n", a1);
            function_2e584(0, &str, 0);
            // 0x41850
            return 0;
        }
    }
    // 0x418bc
    if (a3 % 4 == 0) {
        // 0x41850
        return result;
    }
    // 0x418c8
    function_40314(v3, (int32_t *)&v1);
    int32_t v7 = result + a2; // 0x418d8
    int32_t result2; // 0x41794
    switch ((int2_t)a3) {
        case -2: {
            char v8 = v1 >> 7; // 0x419c8
            *(char *)v7 = v8;
            *(char *)(v7 + 1) = v8;
            result2 = result | 2;
            // break -> 0x41850
            break;
        }
        case -1: {
            char v9 = v1 >> 7; // 0x418fc
            *(char *)v7 = v9;
            *(char *)(v7 + 1) = v9;
            *(char *)(v7 + 2) = v9;
            result2 = a3 | 3;
            // break -> 0x41850
            break;
        }
        default: {
            // 0x419a8
            result2 = result | 1;
            // break -> 0x41850
            break;
        }
    }
    // 0x41850
    return result2;
}

// Address range: 0x419d8 - 0x41a38
int32_t function_419d8(void) {
    // 0x419d8
    if (g104 != 0) {
        // 0x419ec
        return 0;
    }
    char * v1 = (char *)0x61656c70; // bp-2056, 0x41a0c
    function_2e584(0, (int32_t *)&v1, 0);
    return -1;
}

// Address range: 0x41a38 - 0x41a3c
int32_t function_41a38(void) {
    // 0x41a38
    int32_t result; // 0x41a38
    return result;
}

// Address range: 0x41a3c - 0x41c84
int32_t function_41a3c(int32_t a1, int32_t a2, uint32_t result2) {
    // 0x41a3c
    int32_t v1; // bp-2328, 0x41a3c
    memset(&v1, 0, 256);
    int32_t v2 = 0; // bp-2348, 0x41a70
    int32_t v3 = 0; // bp-2344, 0x41a78
    int32_t v4 = 0; // bp-2340, 0x41a7c
    int32_t v5 = 0; // bp-2336, 0x41a84
    int32_t v6 = 0; // bp-2332, 0x41a88
    int32_t * v7 = (int32_t *)(24 * a1 + (int32_t)&g116); // 0x41a8c
    function_11f94(v7, 0, 256, 3 * a1);
    int32_t v8 = function_41250(a1, &v6, &v2, &v3, &v4); // 0x41aa8
    int32_t v9 = 21; // 0x41ab4
    int32_t str; // bp-2072, 0x41a3c
    if (v8 != 0) {
        int32_t result = v8 == 0 ? 21 : 0;
        snprintf((char *)&str, 2048, "get_send_address_info error, chain_id = %d\n", a1);
        function_2e584(result, &str, result);
        function_11ea4(v7, (int32_t)&str, result, a1);
        return result;
    }
    function_40314(v2, &v5);
    uint32_t v10 = (v5 >> v6) % 256; // 0x41ae4
    v5 = v10;
    int32_t format; // 0x41a3c
    while (v10 < result2) {
        int32_t v11 = v9;
        usleep(3000);
        v9 = v11 - 1;
        if (v11 == 1) {
            // 0x41c1c
            function_11ea4(v7, (int32_t)&v5, v6, v10);
            format = (int32_t)"%s: uart%d always dose not has enough send fifo space, break\n";
            goto lab_0x41c34;
        }
        function_40314(v2, &v5);
        v10 = (v5 >> v6) % 256;
        v5 = v10;
    }
    int32_t v12 = 22; // 0x41a3c
    function_40314(v3, &v5);
    while (v5 < 0) {
        int32_t v13 = v12;
        usleep(3000);
        v12 = v13 - 1;
        if (v13 == 1) {
            // 0x41c5c
            function_11ea4(v7, (int32_t)&v5, v6, v5);
            format = (int32_t)"%s: uart%d always busy, break\n";
            goto lab_0x41c34;
        }
        function_40314(v3, &v5);
    }
    // 0x41b24
    function_11fc4(&v1, a2, (char)result2, v5);
    int32_t v14 = v5; // 0x41b38
    if (result2 >= 4) {
        int32_t v15 = &v1; // 0x41b3c
        unsigned char v16 = *(char *)(v15 | 1); // 0x41b44
        int32_t v17 = v15 + 4; // 0x41b48
        unsigned char v18 = *(char *)v15; // 0x41b4c
        unsigned char v19 = *(char *)(v15 | 3); // 0x41b50
        int32_t v20 = 0x1000000 * (int32_t)v18 | 0x10000 * (int32_t)v16 | (int32_t)v19; // 0x41b64
        function_40390(v4, v20 | 256 * (int32_t)*(char *)(v15 | 2));
        v14 = v20;
        while ((result2 & -4) + v15 != v17) {
            int32_t v21 = v17;
            v16 = *(char *)(v21 | 1);
            v17 = v21 + 4;
            v18 = *(char *)v21;
            v19 = *(char *)(v21 | 3);
            v20 = 0x1000000 * (int32_t)v18 | 0x10000 * (int32_t)v16 | (int32_t)v19;
            function_40390(v4, v20 | 256 * (int32_t)*(char *)(v21 | 2));
            v14 = v20;
        }
    }
    int32_t v22 = 0; // 0x41b80
    int32_t v23 = v14; // 0x41b80
    if (result2 % 4 != 0) {
        // 0x41b84
        int32_t v24; // bp-24, 0x41a3c
        int32_t v25 = (result2 & -4) + (int32_t)&v24; // 0x41b8c
        int32_t v26 = (int32_t)*(char *)(v25 - 2304); // 0x41b90
        int32_t v27 = 0x1000000 * v26; // 0x41b94
        int32_t v28 = v27; // 0x41a3c
        v22 = 1;
        v23 = v26;
        switch ((int2_t)result2) {
            case -2: {
                int32_t v29 = (int32_t)*(char *)(v25 - 2303); // 0x41c78
                v28 = 0x10000 * v29 | v27;
                v22 = 2;
                v23 = v29;
                // break -> 0x41bb8
                break;
            }
            case -1: {
                int32_t v30 = (int32_t)*(char *)(v25 - 2303); // 0x41ba8
                int32_t v31 = 0x10000 * v30 | 256 * (int32_t)*(char *)(v25 - 2302); // 0x41bb0
                v28 = v31 | v27;
                v22 = v30;
                v23 = v31;
                // break -> 0x41bb8
                break;
            }
        }
        // 0x41bb8
        function_40390(v4, v28);
    }
    int32_t v32 = result2 | -0x80000000; // 0x41bc0
    function_40390(v3, v32);
    function_11ea4(v7, v32, v22, v23);
    return result2;
  lab_0x41c34:
    // 0x41c34
    snprintf((char *)&str, 2048, (char *)format, "uart_send", a1);
    function_2e584(0, &str, 0);
    return 0;
}

// Address range: 0x41c88 - 0x41cf8
int32_t function_41c88(uint32_t a1, int32_t a2, uint32_t a3) {
    int32_t v1 = 3 * a1; // 0x41c8c
    int32_t * v2 = (int32_t *)(24 * a1 + (int32_t)&g117); // 0x41ca8
    function_11f94(v2, a2, a3, v1);
    uint32_t v3 = function_41474(a1 % 256); // 0x41cb0
    int32_t v4 = v3 < a3 ? v3 : a3;
    if (v4 == 0) {
        // 0x41cc4
        function_11ea4(v2, a2, a3, v1);
        return 0;
    }
    int32_t result = function_41794(a1, a2, v4); // 0x41ce0
    function_11ea4(v2, a2, v4, v1);
    return result;
}

// Address range: 0x41cfc - 0x41d80
int32_t function_41cfc(int32_t a1, int32_t a2, int32_t a3) {
    // 0x41cfc
    if (a3 == 0) {
        // 0x41d68
        return -3;
    }
    int32_t * v1 = (int32_t *)(24 * a1 + (int32_t)&g116); // 0x41d28
    int32_t v2; // 0x41cfc
    function_11f94(v1, a2, a3, v2);
    int32_t v3; // 0x41cfc
    int32_t v4; // 0x41cfc
    int32_t v5; // 0x41cfc
    if (a2 == 0) {
        // 0x41d70
        function_40390(15, a3);
        v3 = a3;
        v4 = a3;
    } else {
        // 0x41d34
        int32_t str; // bp-2064, 0x41cfc
        snprintf((char *)&str, 2048, "unknown set config type = %d\n", a2);
        function_2e584(1, &str, 0);
        v3 = &str;
        v4 = 0;
        v5 = a2;
    }
    // 0x41d5c
    function_11ea4(v1, v3, v4, v5);
    // 0x41d68
    return -5;
}

// Address range: 0x41d80 - 0x41e38
int32_t function_41d80(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    bool v1 = a3 == 0 | a4 != 0;
    if (v1) {
        // 0x41e04
        return -3;
    }
    int32_t * v2 = (int32_t *)(24 * a1 + (int32_t)&g116); // 0x41dc4
    function_11f94(v2, a2, a3, 0);
    int32_t str; // bp-2072, 0x41d80
    if (a2 == 0) {
        // 0x41e10
        str = 0;
        function_40314(15, &str);
        *(int32_t *)a3 = str;
        abort();
        // UNREACHABLE
    }
    int32_t v3 = v1;
    snprintf((char *)&str, 2048, "unknown set config type = %d\n", a2);
    function_2e584(1, &str, v3);
    function_11ea4(v2, (int32_t)&str, v3, a2);
    // 0x41e04
    return -5;
}

// Address range: 0x41e38 - 0x41ec0
int32_t function_41e38(int32_t a1, int32_t a2, int32_t a3) {
    // 0x41e38
    if (a3 == 0) {
        // 0x41ea4
        return -3;
    }
    int32_t * v1 = (int32_t *)(24 * a1 + (int32_t)&g116); // 0x41e64
    int32_t v2; // 0x41e38
    function_11f94(v1, a2, a3, v2);
    int32_t v3; // 0x41e38
    int32_t v4; // 0x41e38
    int32_t v5; // 0x41e38
    if (a2 == 0) {
        int32_t v6 = 0x10000 * a3; // 0x41eb4
        function_40390(15, v6);
        v3 = v6;
        v4 = a3;
    } else {
        // 0x41e70
        int32_t str; // bp-2064, 0x41e38
        snprintf((char *)&str, 2048, "unknown set config type = %d\n", a2);
        function_2e584(1, &str, 0);
        v3 = &str;
        v4 = 0;
        v5 = a2;
    }
    // 0x41e98
    function_11ea4(v1, v3, v4, v5);
    // 0x41ea4
    return -5;
}

// Address range: 0x41ec0 - 0x41f7c
int32_t function_41ec0(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    bool v1 = a3 == 0 | a4 != 0;
    if (v1) {
        // 0x41f44
        return -3;
    }
    int32_t * v2 = (int32_t *)(24 * a1 + (int32_t)&g116); // 0x41f04
    function_11f94(v2, a2, a3, 0);
    int32_t str; // bp-2072, 0x41ec0
    if (a2 == 0) {
        // 0x41f50
        str = 0;
        function_40314(15, &str);
        *(int32_t *)a3 = __asm_ubfx(str, 16, 6);
        abort();
        // UNREACHABLE
    }
    int32_t v3 = v1;
    snprintf((char *)&str, 2048, "unknown set config type = %d\n", a2);
    function_2e584(1, &str, v3);
    function_11ea4(v2, (int32_t)&str, v3, a2);
    // 0x41f44
    return -5;
}

// Address range: 0x41f7c - 0x42078
int32_t function_41f7c(uint32_t a1) {
    int32_t v1 = 3 * a1; // 0x41f80
    int32_t * v2 = (int32_t *)(24 * a1 + (int32_t)&g117); // 0x41f9c
    int32_t v3; // 0x41f7c
    function_11f94(v2, v3, v3, v1);
    int32_t size = function_41474(a1 % 256); // 0x41fa4
    if (size == 0) {
        // 0x42018
        int32_t v4; // 0x41f7c
        int32_t v5; // 0x41f7c
        return function_11ea4(v2, v4, v5, v1);
    }
    int32_t * mem = malloc(size); // 0x41fb0
    int32_t v6 = (int32_t)mem; // 0x41fb0
    int32_t str; // bp-2072, 0x41f7c
    if (mem == NULL) {
        // 0x4202c
        snprintf((char *)&str, 2048, "%s: uart%d malloc buffer error\n", "clear_uart_rx_fifo", a1);
        function_2e584(v6, &str, v6);
        usleep(0x7a120);
        int32_t result = function_11ea4(v2, (int32_t)&str, v6, (int32_t)"clear_uart_rx_fifo"); // 0x42068
        return result;
    }
    int32_t v7 = function_41794(a1, v6, size); // 0x41fc8
    int32_t v8 = v6; // 0x41fd0
    int32_t v9 = size; // 0x41fd0
    int32_t v10 = v1; // 0x41fd0
    if (size != v7) {
        // 0x41fd4
        snprintf((char *)&str, 2048, "%s: uart%d clear rx fifo error. nbytes = %d, len = %d\n", "clear_uart_rx_fifo", a1, size, v7);
        function_2e584(0, &str, 0);
        v8 = &str;
        v9 = 0;
        v10 = (int32_t)"clear_uart_rx_fifo";
    }
    // 0x42008
    free(v6, v8, v9, v10);
    usleep(0x2710);
    // 0x42018
    return function_11ea4(v2, v8, v9, v10);
}

// Address range: 0x42080 - 0x420a4
int32_t function_42080(int32_t a1) {
    // 0x42080
    function_41f7c(a1);
    usleep(0x2710);
    function_4165c(a1);
    return 0;
}

// Address range: 0x420a4 - 0x420b4
int32_t function_420a4(void) {
    // 0x420a4
    int32_t v1; // 0x420a4
    function_4165c(v1);
    return 0;
}

// Address range: 0x420b4 - 0x420c4
int32_t function_420b4(void) {
    // 0x420b4
    int32_t v1; // 0x420b4
    function_41f7c(v1);
    return 0;
}

// Address range: 0x420c4 - 0x420fc
int32_t function_420c4(uint32_t a1) {
    int32_t v1 = 3 * a1; // 0x420c8
    int32_t * v2 = (int32_t *)(24 * a1 + (int32_t)&g117); // 0x420dc
    int32_t v3; // 0x420c4
    function_11f94(v2, v3, v3, v1);
    int32_t result = function_41474(a1 % 256); // 0x420e4
    function_11ea4(v2, v3, v3, v1);
    return result;
}

// Address range: 0x42100 - 0x42138
int32_t function_42100(void) {
    // 0x42100
    if (function_406e4(907) == 0) {
        // 0x42114
        function_40794(907);
        function_40ad8(907, 1);
    }
    // 0x42128
    return function_40ed4(907, 0);
}

// Address range: 0x42138 - 0x42170
int32_t function_42138(void) {
    // 0x42138
    if (function_406e4(907) == 0) {
        // 0x4214c
        function_40794(907);
        function_40ad8(907, 1);
    }
    // 0x42160
    return function_40ed4(907, 1);
}

// Address range: 0x42170 - 0x42180
int32_t function_42170(int32_t a1, int32_t a2) {
    // 0x42170
    return a1 - a2;
}

// Address range: 0x42180 - 0x421c4
int32_t function_42180(int32_t result, int32_t a2) {
    // 0x42180
    if (a2 == 0) {
        // 0x421a8
        return result;
    }
    int32_t result2 = function_43338(a2); // 0x4219c
    if (result2 == 1) {
        // 0x421b0
        return function_43358(a2);
    }
    // 0x421a8
    return result2;
}

// Address range: 0x421c4 - 0x42308
int32_t function_421c4(void) {
    // 0x421c4
    prctl(PR_SET_NAME, (int32_t)"ui", 0, 0, 0);
    if (g118 == 0) {
        // 0x422fc
        return 0;
    }
    if (function_11f94(&g119, (int32_t)"ui", 0, g118) == 0) {
        // 0x42230
        if (function_43440(g120) != 0) {
            // break -> 0x4229c
            break;
        }
        // 0x422e8
        function_43488(0);
        function_11ea4(&g119, (int32_t)"ui", 0, 0);
    }
    // 0x4220c
    usleep(0x30d40);
    int32_t v1 = g118; // 0x42214
    while (v1 != 0) {
        // 0x42220
        if (function_11f94(&g119, (int32_t)"ui", 0, v1) == 0) {
            // 0x42230
            if (function_43440(g120) != 0) {
                // break -> 0x4229c
                break;
            }
            // 0x422e8
            function_43488(0);
            function_11ea4(&g119, (int32_t)"ui", 0, 0);
        }
        // 0x4220c
        usleep(0x30d40);
        v1 = g118;
    }
    // 0x422fc
    return 0;
}

// Address range: 0x42308 - 0x42368
int32_t function_42308(int32_t a1) {
    // 0x42308
    if (function_43014() == a1) {
        // 0x42360
        return 256;
    }
    int32_t result = 257; // 0x42330
    if (function_4301c() != a1) {
        // 0x42334
        int32_t str; // bp-2056, 0x42308
        snprintf((char *)&str, 2048, "unmaped port = %d\n", a1);
        function_2e584(0, &str, 0);
        result = 258;
    }
    // 0x42360
    return result;
}

// Address range: 0x42368 - 0x42388
int32_t function_42368(void) {
    // 0x42368
    if (function_43004() < 0) {
        // 0x42378
        return 0;
    }
    // 0x42380
    return function_43004();
}

// Address range: 0x42388 - 0x42400
int32_t function_42388(uint32_t a1) {
    if (a1 == 2) {
        // 0x423e4
        if ((uint32_t)function_4300c() >= 0) {
            // 0x423f0
            return function_4300c();
        }
        // 0x423cc
        return 0;
    }
    if (a1 < 2) {
        if (a1 == 1) {
            // 0x423dc
            return function_42368();
        }
        // 0x423cc
        return 0;
    }
    switch (a1) {
        case 256: {
            // 0x423c0
            if ((uint32_t)function_43014() >= 0) {
                // 0x423f8
                return function_43014();
            }
            // break -> 0x423cc
            break;
        }
        case 257: {
            // 0x423ac
            if ((uint32_t)function_4301c() >= 0) {
                // 0x423b8
                return function_4301c();
            }
            // break -> 0x423cc
            break;
        }
    }
    // 0x423cc
    return 0;
}

// Address range: 0x42400 - 0x42488
int32_t function_42400(void) {
    // 0x42400
    function_11fdc((int32_t)&g119, 0);
    g121 = 0;
    g122 = 0;
    g123 = 0;
    g124 = 0;
    g125 = 0;
    g120 = function_432d0(0x42170, 0, 0);
    int32_t attr; // bp-52, 0x42400
    pthread_attr_init(&attr);
    function_12024(&attr, &g8);
    int32_t result = pthread_create(&g126, &attr, (int32_t * (*)(int32_t *))0x421c4, NULL); // 0x42474
    g118 = 1;
    return result;
}

// Address range: 0x42488 - 0x424c8
int32_t function_42488(int32_t a1) {
    // 0x42488
    int32_t str; // bp-2056, 0x42488
    snprintf((char *)&str, 2048, "gpio port %d is not a supported key\n", a1);
    return function_2e584(1, &str, 0);
}

// Address range: 0x424c8 - 0x42524
int32_t function_424c8(int32_t a1, int32_t a2) {
    int32_t result = function_42308(a1); // 0x424d4
    if (result == 258) {
        // 0x42518
        return function_42488(a1);
    }
    // 0x424f0
    return result;
}

// Address range: 0x42528 - 0x42690
int32_t function_42528(int32_t a1, int32_t a2) {
    int32_t v1 = function_42388(a1); // 0x42538
    char * v2; // bp-2072, 0x42528
    if (v1 == 0) {
        // 0x42624
        v2 = (char *)0x75736e75;
        function_2e584(0, (int32_t *)&v2, 0);
        // 0x42594
        return -1;
    }
    // 0x42544
    int32_t v3; // 0x42528
    if (function_11f94(&g119, a2, v3, v3) != 0) {
        // 0x4265c
        v2 = (char *)0x6c696166;
        function_2e584(0, (int32_t *)&v2, 0);
        // 0x42594
        return -1;
    }
    // 0x4255c
    int32_t v4; // 0x42528
    int32_t v5; // 0x42528
    int32_t v6; // 0x42528
    int32_t result; // 0x42528
    switch (a2) {
        case 1: {
            // 0x425cc
            function_42180(v1, g120);
            v4 = 0;
            result = function_40ed4(v1, 0);
            // break -> 0x4258c
            break;
        }
        case 2: {
            int32_t v7 = v1; // bp-2076, 0x425a8
            v4 = 2;
            result = -1;
            if (g120 != 0) {
                int32_t v8 = &v7; // 0x425b4
                int32_t v9 = function_43338(g120); // 0x425b8
                v4 = v8;
                v5 = v9;
                result = -1;
                if (v9 == 0) {
                    // 0x425ec
                    v2 = (char *)200;
                    function_43320(g120);
                    v4 = v8;
                    v5 = 4;
                    v6 = (int32_t)&v2;
                    result = -1;
                }
            }
            // break -> 0x4258c
            break;
        }
        default: {
            // 0x42570
            function_42180(v1, g120);
            v4 = 1;
            result = function_40ed4(v1, 1);
            // break -> 0x4258c
            break;
        }
    }
    // 0x4258c
    function_11ea4(&g119, v4, v5, v6);
    // 0x42594
    return result;
}

// Address range: 0x42694 - 0x42724
int32_t function_42694(void) {
    // 0x42694
    if (g127 == 0) {
        // 0x426ac
        function_40794(function_42368());
        function_40ad8(function_42368(), 1);
        function_40794(function_42388(2));
        function_40ad8(function_42388(2), 1);
        function_40794(function_42388(256));
        function_40ad8(function_42388(256), 0);
        function_40794(function_42388(257));
        function_40ad8(function_42388(257), 0);
        g127 = 1;
    }
    // 0x4271c
    return 0;
}

// Address range: 0x42724 - 0x42728
int32_t function_42724(void) {
    // 0x42724
    int32_t result; // 0x42724
    return result;
}

// Address range: 0x42728 - 0x42734
int32_t function_42728(int32_t a1) {
    // 0x42728
    return function_42528(1, 0);
}

// Address range: 0x42734 - 0x42740
int32_t function_42734(int32_t a1) {
    // 0x42734
    return function_42528(1, 1);
}

// Address range: 0x42740 - 0x42778
int32_t function_42740(void) {
    // 0x42740
    if (g118 != 0) {
        // 0x42754
        return function_42528(1, 2);
    }
    // 0x42760
    function_42400();
    return function_42528(1, 2);
}

// Address range: 0x42778 - 0x42784
int32_t function_42778(int32_t a1) {
    // 0x42778
    return function_42528(2, 0);
}

// Address range: 0x42784 - 0x42790
int32_t function_42784(int32_t a1) {
    // 0x42784
    return function_42528(2, 1);
}

// Address range: 0x42790 - 0x427c8
int32_t function_42790(void) {
    // 0x42790
    if (g118 != 0) {
        // 0x427a4
        return function_42528(2, 2);
    }
    // 0x427b0
    function_42400();
    return function_42528(2, 2);
}

// Address range: 0x427c8 - 0x427d4
int32_t function_427c8(void) {
    // 0x427c8
    return function_42528(16, 0);
}

// Address range: 0x427d4 - 0x427e0
int32_t function_427d4(void) {
    // 0x427d4
    return function_42528(16, 1);
}

// Address range: 0x427e0 - 0x42818
int32_t function_427e0(void) {
    // 0x427e0
    if (g118 != 0) {
        // 0x427f4
        return function_42528(16, 2);
    }
    // 0x42800
    function_42400();
    return function_42528(16, 2);
}

// Address range: 0x42818 - 0x42920
int32_t function_42818(int32_t a1) {
    // 0x42818
    char * v1; // bp-2064, 0x42818
    int32_t v2; // 0x42818
    if (function_11f94(&g119, v2, v2, v2) != 0) {
        // 0x428ec
        v1 = (char *)0x6c696166;
        function_2e584(0, (int32_t *)&v1, 0);
        // 0x428a0
        return -1;
    }
    // 0x4283c
    if (g128 == 0) {
        // 0x428ac
        function_40458(function_42388(256), 0x424c8);
        function_40458(function_42388(257), 0x424c8);
        g128 = 1;
    }
    int32_t v3 = &g121; // 0x4284c
    int32_t v4 = 0;
    int32_t v5; // 0x42818
    int32_t v6; // 0x42818
    int32_t v7; // 0x42818
    int32_t result; // 0x42818
    while (*(int32_t *)v3 != 0) {
        // 0x42850
        v3 += 4;
        int32_t v8 = v4 + 1; // 0x4285c
        if (v8 == 5) {
            // 0x42868
            v1 = (char *)0x6d206f6e;
            function_2e584(0, (int32_t *)&v1, 0);
            v5 = (int32_t)&v1;
            v6 = 0;
            v7 = 0x72656e65;
            result = -2;
            goto lab_0x42898;
        }
        v4 = v8;
    }
    int32_t v9 = 4 * v4; // 0x428e0
    *(int32_t *)(v9 + (int32_t)&g118 + 32) = a1;
    v5 = 0;
    v6 = v3;
    v7 = v9 + (int32_t)&g118;
    result = 0;
    goto lab_0x42898;
  lab_0x42898:
    // 0x42898
    function_11ea4(&g119, v5, v6, v7);
    // 0x428a0
    return result;
}

// Address range: 0x42928 - 0x429f4
int32_t function_42928(int32_t a1) {
    // 0x42928
    int32_t v1; // 0x42928
    int32_t v2 = function_11f94(&g119, v1, v1, v1); // 0x42944
    int32_t v3 = &g121; // 0x42950
    char * v4; // bp-2064, 0x42928
    if (v2 != 0) {
        // 0x429c0
        v4 = (char *)0x6c696166;
        function_2e584(0, (int32_t *)&v4, 0);
        // 0x429a4
        return -1;
    }
    int32_t v5 = 0;
    int32_t v6; // 0x42928
    int32_t v7; // 0x42928
    int32_t v8; // 0x42928
    while (*(int32_t *)v3 != a1) {
        int32_t v9 = v5 + 1; // 0x42960
        v3 += 4;
        if (v9 == 5) {
            // 0x4296c
            v4 = (char *)0x7473696c;
            function_2e584(1, (int32_t *)&v4, 0);
            v6 = (int32_t)&v4;
            v7 = 0;
            v8 = &g466;
            goto lab_0x42998;
        }
        v5 = v9;
    }
    // 0x429b0
    *(int32_t *)(4 * v5 + (int32_t)&g118 + 32) = 0;
    v7 = a1;
    v8 = 0;
    goto lab_0x42998;
  lab_0x42998:
    // 0x42998
    function_11ea4(&g119, v6, v7, v8);
    // 0x429a4
    return 0;
}

// Address range: 0x429f8 - 0x42a70
int32_t function_429f8(void) {
    // 0x429f8
    int32_t result; // 0x429f8
    char * v1; // bp-2056, 0x429f8
    int32_t v2; // 0x429f8
    if (function_11f94(&g119, v2, v2, v2) == 0) {
        int32_t v3 = function_43014(); // 0x42a10
        function_40c28(v3, (char *)&v1);
        function_11ea4(&g119, (int32_t)&v1, v2, v2);
        result = (int32_t)v1 % 256 != 0;
    } else {
        // 0x42a3c
        v1 = (char *)0x6c696166;
        function_2e584(0, (int32_t *)&v1, 0);
        result = -1;
    }
    // 0x42a30
    return result;
}

// Address range: 0x42a74 - 0x42aec
int32_t function_42a74(void) {
    // 0x42a74
    int32_t result; // 0x42a74
    char * v1; // bp-2056, 0x42a74
    int32_t v2; // 0x42a74
    if (function_11f94(&g119, v2, v2, v2) == 0) {
        int32_t v3 = function_4301c(); // 0x42a8c
        function_40c28(v3, (char *)&v1);
        function_11ea4(&g119, (int32_t)&v1, v2, v2);
        result = (int32_t)v1 % 256 != 0;
    } else {
        // 0x42ab8
        v1 = (char *)0x6c696166;
        function_2e584(0, (int32_t *)&v1, 0);
        result = -1;
    }
    // 0x42aac
    return result;
}

// Address range: 0x42af0 - 0x42bdc
int32_t function_42af0(int32_t a1, int32_t a2, int32_t a3) {
    // 0x42af0
    char * str; // bp-2072, 0x42af0
    int32_t v1; // 0x42af0
    if (function_11f94(&g119, a2, a3, v1) != 0) {
        // 0x42ba8
        str = (char *)0x6c696166;
        function_2e584(0, (int32_t *)&str, 0);
        // 0x42b50
        return -4;
    }
    int32_t v2 = g308; // 0x42b28
    if (g308 < 0) {
        int32_t v3 = function_42c68(); // 0x42b94
        g308 = v3;
        function_42e88(v3);
        v2 = g308;
    }
    // 0x42b2c
    int32_t v4; // 0x42af0
    int32_t v5; // 0x42af0
    int32_t v6; // 0x42af0
    int32_t result; // 0x42af0
    if (v2 < 1) {
        // 0x42b60
        snprintf((char *)&str, 2048, "failed to init %s\n", g309);
        function_2e584(0, (int32_t *)&str, 0);
        v4 = (int32_t)&str;
        v5 = 0;
        v6 = (int32_t)g309;
        result = -1;
    } else {
        int32_t v7 = __asm_sxtb(a1); // 0x42b3c
        int32_t v8 = function_42d2c(v2, v7, a2, a3); // 0x42b40
        v4 = v7;
        v5 = a2;
        v6 = a3;
        result = v8;
    }
    // 0x42b48
    function_11ea4(&g119, v4, v5, v6);
    // 0x42b50
    return result;
}

// Address range: 0x42be0 - 0x42c64
int32_t function_42be0(void) {
    // 0x42be0
    int32_t v1; // 0x42be0
    if (function_11f94(&g119, v1, v1, v1) != 0) {
        char * v2 = (char *)0x6c696166; // bp-2056, 0x42c40
        return function_2e584(0, (int32_t *)&v2, 0);
    }
    // 0x42bfc
    if (g308 > 0) {
        // 0x42c24
        function_42e88(g308);
    }
    // 0x42c10
    return function_11ea4(&g119, v1, v1, (int32_t)&g308);
}

// Address range: 0x42c68 - 0x42d2c
int32_t function_42c68(void) {
    // 0x42c68
    if (g129 != 0) {
        // 0x42cb4
        return 0;
    }
    // 0x42c8c
    int32_t v1; // 0x42c68
    int32_t v2 = g129 == 0 ? v1 : 0;
    char * v3; // bp-2064, 0x42c68
    if (v2 == 0) {
        // 0x42cc0
        v3 = (char *)0x20646162;
        function_2e584(0, (int32_t *)&v3, 0);
        // 0x42cb4
        return -3;
    }
    int32_t v4 = open64((char *)v2, 2050); // 0x42c9c
    g130 = v4;
    int32_t result; // 0x42c68
    if (v4 >= 0) {
        g129 = 1;
        result = v4;
    } else {
        // 0x42cf8
        v3 = (char *)0x6e65706f;
        function_2e584(0, (int32_t *)&v3, 0);
        result = -1;
    }
    // 0x42cb4
    return result;
}

// Address range: 0x42d2c - 0x42e78
int32_t function_42d2c(int32_t a1, uint32_t a2, int32_t a3, uint32_t a4) {
    // 0x42d2c
    if (g129 == 0) {
        // 0x42df8
        return -2;
    }
    // 0x42d50
    char * v1; // bp-2088, 0x42d2c
    if (g130 != a1) {
        // 0x42e04
        v1 = (char *)0x20646162;
        function_2e584(1, (int32_t *)&v1, 0);
        // 0x42df8
        return -3;
    }
    uint32_t v2 = a2 % 256; // 0x42d60
    bool v3 = false; // 0x42d68
    bool v4 = true; // 0x42d68
    if (a4 == 64 || a4 < 64) {
        v3 = v2 == 3;
        v4 = v2 >= 3;
    }
    if (v4 == !v3) {
        // 0x42e04
        v1 = (char *)0x20646162;
        function_2e584(1, (int32_t *)&v1, 0);
        // 0x42df8
        return -3;
    }
    int32_t v5 = function_11f94(&g131, g129, a3, v2); // 0x42d80
    int32_t v6 = 0; // 0x42d88
    if (v5 != 0) {
        // 0x42e44
        int32_t v7; // 0x42d2c
        int32_t v8 = v4 == !v3 ? 1 : v7;
        int32_t v9 = v3 | !v4 ? 0 : v8;
        v1 = (char *)0x6c696166;
        function_2e584(v9, (int32_t *)&v1, v9);
        // 0x42df8
        return -4;
    }
    uint32_t v10 = a4;
    int32_t v11 = v10 < 16 ? v10 : 16;
    uint32_t v12 = (a2 + 1) % 256; // 0x42dac
    function_11fc4((int32_t *)(16 * a2 + (int32_t)&g132), v6 + a3, (char)v11, v2);
    int32_t v13 = __asm_sxtb(v12); // 0x42dbc
    int32_t v14 = v12 >= 3 == (v12 != 3) ? 0 : v12;
    int32_t v15 = v10 - v11; // 0x42dd8
    v6 += v11;
    while ((v12 == 3 || v12 < 3 ? (int32_t)(v10 > 16) : v14) != 0) {
        // 0x42d90
        v10 = v15;
        v11 = v10 < 16 ? v10 : 16;
        v12 = (v13 + 1) % 256;
        function_11fc4((int32_t *)(16 * v13 + (int32_t)&g132), v6 + a3, (char)v11, v2);
        v13 = __asm_sxtb(v12);
        v14 = v12 >= 3 == (v12 != 3) ? 0 : v12;
        v15 = v10 - v11;
        v6 += v11;
    }
    // 0x42ddc
    write(g130, &g132, 64);
    function_11ea4(&g131, (int32_t)&g132, 64, v2);
    // 0x42df8
    return 0;
}

// Address range: 0x42e80 - 0x42e88
int32_t function_42e80(void) {
    // 0x42e80
    return 0;
}

// Address range: 0x42e88 - 0x42f88
int32_t function_42e88(int32_t a1) {
    // 0x42e88
    if (g129 == 0) {
        // 0x42f08
        return -2;
    }
    // 0x42ea8
    char * v1; // bp-2064, 0x42e88
    if (g130 != a1) {
        // 0x42f14
        v1 = (char *)0x20646162;
        function_2e584(1, (int32_t *)&v1, 0);
        // 0x42f08
        return -3;
    }
    // 0x42eb4
    int32_t result; // 0x42e88
    int32_t v2; // 0x42e88
    if (function_11f94(&g131, v2, v2, a1) == 0) {
        // 0x42ec4
        memset(&g132, 32, 64);
        lseek64(g130, 32, 0);
        write(g130, &g132, 64);
        function_11ea4(&g131, (int32_t)&g132, 64, 0);
        result = 0;
    } else {
        // 0x42f54
        v1 = (char *)0x6c696166;
        function_2e584(0, (int32_t *)&v1, 0);
        result = -4;
    }
    // 0x42f08
    return result;
}

// Address range: 0x42f88 - 0x43004
int32_t function_42f88(void) {
    // 0x42f88
    int32_t v1; // 0x42f88
    int32_t fd = g129 == 0 ? 0 : v1;
    if (g129 == 0) {
        // 0x42fa8
        return fd;
    }
    int32_t result = 0; // 0x42fb8
    if (close(fd) != 0) {
        char * v2 = (char *)0x2064636c; // bp-2056, 0x42fdc
        function_2e584(0, (int32_t *)&v2, 0);
        result = -1;
    }
    // 0x42fbc
    g129 = 0;
    return result;
}

// Address range: 0x43004 - 0x4300c
int32_t function_43004(void) {
    // 0x43004
    return 941;
}

// Address range: 0x4300c - 0x43014
int32_t function_4300c(void) {
    // 0x4300c
    return 942;
}

// Address range: 0x43014 - 0x4301c
int32_t function_43014(void) {
    // 0x43014
    return 921;
}

// Address range: 0x4301c - 0x43024
int32_t function_4301c(void) {
    // 0x4301c
    return 943;
}

// Address range: 0x43024 - 0x4306c
int32_t function_43024(int32_t a1) {
    int32_t v1 = 0; // 0x4304c
    int32_t v2 = (int32_t)&g256 + 4; // 0x4304c
    if (a1 == 0) {
      lab_0x43050:
        // 0x43050
        return *(int32_t *)v2;
    }
    v1++;
    while (v1 != 16) {
        int32_t v3 = 16 * v1;
        if (*(int32_t *)(v3 + (int32_t)&g256) == a1) {
            // 0x43048
            v2 = v3 + (int32_t)&g256 + 4;
            return *(int32_t *)v2;
        }
        v1++;
    }
    // 0x43064
    return -2;
}

// Address range: 0x4306c - 0x430b4
int32_t function_4306c(int32_t a1) {
    int32_t v1 = 0; // 0x43094
    int32_t v2 = (int32_t)&g256 + 8; // 0x43094
    if (a1 == 0) {
      lab_0x43098:
        // 0x43098
        return *(int32_t *)v2;
    }
    v1++;
    while (v1 != 16) {
        int32_t v3 = 16 * v1;
        if (*(int32_t *)(v3 + (int32_t)&g256) == a1) {
            // 0x43090
            v2 = v3 + (int32_t)&g256 + 8;
            return *(int32_t *)v2;
        }
        v1++;
    }
    // 0x430ac
    return -2;
}

// Address range: 0x430b4 - 0x430fc
int32_t function_430b4(int32_t a1) {
    int32_t v1 = 0; // 0x430dc
    int32_t v2 = (int32_t)&g256 + 12; // 0x430dc
    if (a1 == 0) {
      lab_0x430e0:
        // 0x430e0
        return *(int32_t *)v2;
    }
    v1++;
    while (v1 != 16) {
        int32_t v3 = 16 * v1;
        if (*(int32_t *)(v3 + (int32_t)&g256) == a1) {
            // 0x430d8
            v2 = v3 + (int32_t)&g256 + 12;
            return *(int32_t *)v2;
        }
        v1++;
    }
    // 0x430f4
    return -2;
}

// Address range: 0x430fc - 0x43148
int32_t function_430fc(void) {
    int32_t v1 = &g256;
    int32_t v2 = v1 + 16; // 0x43114
    if (*(int32_t *)v2 == 255) {
        // 0x43120
        if (*(int32_t *)(v1 + 20) == 255) {
            // 0x4312c
            if (*(int32_t *)(v1 + 24) == 255) {
                // 0x43138
                if (*(int32_t *)(v1 + 28) == 255) {
                    // break -> 
                    break;
                }
            }
        }
    }
    int32_t v3 = 2; // 0x43108
    int32_t result = 16; // 0x43110
    while (v3 != 16) {
        // 0x43114
        v1 = v2;
        int32_t v4 = v3;
        v2 = v1 + 16;
        if (*(int32_t *)v2 == 255) {
            // 0x43120
            if (*(int32_t *)(v1 + 20) == 255) {
                // 0x4312c
                if (*(int32_t *)(v1 + 24) == 255) {
                    // 0x43138
                    result = v4;
                    if (*(int32_t *)(v1 + 28) == 255) {
                        // break -> 
                        break;
                    }
                }
            }
        }
        // 0x43108
        v3 = v4 + 1;
        result = 16;
    }
    return result;
}

// Address range: 0x43148 - 0x43198
int32_t function_43148(uint32_t a1) {
    if (a1 < 6) {
        // 0x43180
        return *(int32_t *)(12 * a1 + (int32_t)&g256 + 260);
    }
    // 0x43178
    return -2;
}

// Address range: 0x43198 - 0x431e8
int32_t function_43198(uint32_t a1) {
    if (a1 < 6) {
        // 0x431d0
        return *(int32_t *)(12 * a1 + (int32_t)&g256 + 264);
    }
    // 0x431c8
    return -1;
}

// Address range: 0x431e8 - 0x43210
int32_t function_431e8(void) {
    int32_t result = 1;
    int32_t v1 = &g257; // 0x43208
    v1 += 12;
    result += (int32_t)(*(int32_t *)v1 != -1);
    while (v1 != (int32_t)&g258) {
        // 0x43208
        v1 += 12;
        result += (int32_t)(*(int32_t *)v1 != -1);
    }
    return result;
}

// Address range: 0x43214 - 0x43230
int32_t function_43214(void) {
    // 0x43214
    int32_t result; // bp-12, 0x43214
    int32_t v1; // 0x43214
    function_44000(v1, &result);
    return result;
}

// Address range: 0x43230 - 0x43290
int32_t function_43230(int32_t a1, int32_t a2, int32_t a3) {
    int32_t * v1 = (int32_t *)(a1 + 20); // 0x43248
    int32_t v2 = *v1; // 0x43248
    int32_t v3 = v2; // 0x43258
    if (*(int32_t *)(*(int32_t *)*(int32_t *)(a1 + 12) + 32) != 0) {
        // 0x4325c
        int32_t v4; // bp-28, 0x43230
        function_44000(v2, &v4);
        v3 = *v1;
    }
    // 0x43278
    return function_44040(*(int32_t *)(v3 + 20), a2, a3);
}

// Address range: 0x43290 - 0x432d0
int32_t function_43290(int32_t a1) {
    int32_t * v1 = (int32_t *)(a1 + 20); // 0x43290
    int32_t v2 = *v1; // 0x43290
    int32_t v3 = *(int32_t *)*(int32_t *)(a1 + 12); // 0x432a4
    int32_t v4; // 0x43290
    if (v2 == 0) {
        // 0x432c0
        v4 = function_43ea4(v3);
    } else {
        // 0x432ac
        v4 = function_43ef8(v3, v2);
    }
    // 0x432b4
    *v1 = v4;
    int32_t result = 0; // 0x432b8
    if (v4 != 0) {
        result = *(int32_t *)(v4 + 20);
    }
    return result;
}

// Address range: 0x432d0 - 0x43320
int32_t function_432d0(int32_t a1, int32_t a2, int32_t a3) {
    int32_t * mem = malloc(4); // 0x432e4
    if (mem != NULL) {
        int32_t v1 = function_437ac(a1, a2, a3); // 0x432fc
        *mem = v1;
        if (v1 != 0) {
            // 0x4330c
            return (int32_t)mem;
        }
    }
    // 0x4330c
    return 0;
}

// Address range: 0x43320 - 0x43338
int32_t function_43320(int32_t a1) {
    // 0x43320
    if (a1 == 0) {
        // 0x43330
        return 501;
    }
    // 0x43328
    int32_t v1; // 0x43320
    return function_43884(a1, v1, v1, v1, (int32_t)&g488);
}

// Address range: 0x43338 - 0x43358
int32_t function_43338(int32_t a1) {
    // 0x43338
    if (a1 == 0) {
        return 0;
    }
    // 0x43340
    int32_t v1; // 0x43338
    return function_43804(a1, v1) != 0;
}

// Address range: 0x43358 - 0x433d0
int32_t function_43358(int32_t a1) {
    // 0x43358
    if (a1 == 0) {
        // 0x433c0
        return 501;
    }
    // 0x43360
    int32_t v1; // 0x43358
    int32_t v2 = function_43ae8(a1, v1); // 0x4336c
    if (v2 != 0) {
        // 0x4337c
        int32_t v3; // bp-12, 0x43358
        int32_t v4 = &v3; // 0x4337c
        int32_t * v5 = (int32_t *)(v2 + 16); // 0x43380
        function_44000(*v5, &v3);
        free(v3, v4, v1, v1);
        function_44074(*v5);
        int32_t * v6 = (int32_t *)(v2 + 20); // 0x4339c
        function_44000(*v6, &v3);
        free(v3, v4, v1, v1);
        function_44074(*v6);
        free(v2, v4, v1, v1);
    }
    // 0x433c0
    return 0;
}

// Address range: 0x433d0 - 0x43414
int32_t function_433d0(int32_t a1, int32_t * a2, int32_t * a3) {
    if (a1 == 0) {
        // 0x43404
        return 0;
    }
    int32_t v1 = function_43804(a1, (int32_t)a2); // 0x433e4
    if (v1 == 0) {
        // 0x43404
        return 0;
    }
    // 0x433f0
    function_44000(*(int32_t *)(v1 + 20), a3);
    return 1;
}

// Address range: 0x43414 - 0x43440
int32_t function_43414(int32_t a1) {
    int32_t result = 0; // 0x43420
    if (a1 != 0) {
        // 0x43424
        result = function_43d9c(a1);
        int32_t v1; // 0x43414
        free(a1, v1, v1, v1);
    }
    // 0x43438
    return result;
}

// Address range: 0x43440 - 0x43488
int32_t function_43440(int32_t a1) {
    int32_t * mem = malloc(24); // 0x4344c
    int32_t result = (int32_t)mem; // 0x4344c
    *(int32_t *)(result + 12) = a1;
    *mem = 0x43290;
    *(int32_t *)(result + 8) = (int32_t)&g50;
    *(int32_t *)(result + 4) = 0x43230;
    *(int32_t *)(result + 16) = 0;
    *(int32_t *)(result + 20) = 0;
    return result;
}

// Address range: 0x43488 - 0x4348c
int32_t function_43488(int32_t a1) {
    // 0x43488
    int32_t v1; // 0x43488
    return free(a1, v1, v1, v1);
}

// Address range: 0x4348c - 0x434e0
int32_t function_4348c(int32_t a1, int32_t a2) {
    int32_t * v1 = (int32_t *)(a2 + 4); // 0x4348c
    int32_t v2 = *v1; // 0x4348c
    int32_t v3 = a1 + 4; // 0x43490
    int32_t * v4 = (int32_t *)v2; // 0x43494
    int32_t v5 = *v4; // 0x43494
    *v1 = v5;
    if (v5 != v3) {
        *(int32_t *)(v5 + 8) = a2;
    }
    int32_t * v6 = (int32_t *)(a2 + 8); // 0x434a8
    int32_t v7 = *v6; // 0x434a8
    int32_t v8 = v7; // 0x434ac
    if (v3 != v2) {
        *(int32_t *)(v2 + 8) = v7;
        v8 = *v6;
    }
    // .critedge
    int32_t result; // 0x4348c
    if (v8 == 0) {
        *(int32_t *)a1 = v2;
        result = a1;
    } else {
        int32_t * v9 = (int32_t *)v8; // 0x434c0
        int32_t v10 = *v9; // 0x434c0
        if (v10 == a2) {
            *v9 = v2;
            result = a2;
        } else {
            // .critedge1
            *(int32_t *)(v8 + 4) = v2;
            result = v10;
        }
    }
    // 0x434d0
    *v4 = a2;
    if (v3 != a2) {
        *v6 = v2;
    }
    return result;
}

// Address range: 0x434e0 - 0x43534
int32_t function_434e0(int32_t a1, int32_t a2) {
    int32_t v1 = a1 + 4; // 0x434e4
    int32_t * v2 = (int32_t *)(a2 + 4); // 0x434e8
    int32_t v3 = *v2; // 0x434e8
    *(int32_t *)a2 = v3;
    if (v3 != v1) {
        *(int32_t *)(v3 + 8) = a2;
    }
    int32_t * v4 = (int32_t *)(a2 + 8); // 0x434fc
    int32_t v5 = *v4; // 0x434fc
    int32_t result; // 0x434e0
    if (v5 == 0) {
        *(int32_t *)a1 = a2;
        result = a1;
    } else {
        int32_t * v6 = (int32_t *)(v5 + 4); // 0x43514
        int32_t v7 = *v6; // 0x43514
        if (v7 == a2) {
            *v6 = a2;
            result = a2;
        } else {
            // .critedge1
            *(int32_t *)v5 = a2;
            result = v7;
        }
    }
    // 0x43524
    *v2 = a2;
    if (v1 != a2) {
        *v4 = a2;
    }
    return result;
}

// Address range: 0x43534 - 0x43594
int32_t function_43534(int32_t result, int32_t a2) {
    int32_t v1 = result + 4; // 0x43538
    if (v1 == a2) {
        // .loopexit
        return result;
    }
    int32_t v2 = a2; // 0x43540
    int32_t v3 = *(int32_t *)(v2 + 12); // 0x43568
    while (v3 == 1 || v3 == 0) {
        int32_t v4 = function_43534(result, *(int32_t *)v2); // 0x43558
        v2 += 4;
        int32_t result2 = v4; // 0x43564
        if (v2 == v1) {
            // .loopexit
            return result2;
        }
        v3 = *(int32_t *)(v2 + 12);
    }
    // 0x43574
    __assert_fail("debug_node_color(pTree,n) == clib_red || debug_node_color(pTree,n) == clib_black", "3rdparty/cstl/src/c_rb.c", 479, "debug_verify_property_1");
    return &g488;
}

// Address range: 0x43594 - 0x43698
int32_t function_43594(int32_t result, int32_t a2) {
    int32_t v1 = result + 4; // 0x435a0
    int32_t v2 = a2; // 0x435a8
    if (v1 == a2) {
        // 0x435ac
        return result;
    }
    int32_t result2 = result; // 0x43594
    int32_t v3 = v2; // 0x43594
    int32_t v4; // 0x43594
    int32_t v5; // 0x43594
    int32_t v6; // 0x43594
    int32_t v7; // 0x43594
    int32_t v8; // 0x43594
    int32_t v9; // 0x43594
    int32_t v10; // 0x43600
    int32_t v11; // 0x435e8
    int32_t v12; // 0x43620
    while (true) {
        // 0x435c0
        v9 = v3;
        v2 = *(int32_t *)v9;
        if (*(int32_t *)(v9 + 12) == 1) {
            // 0x435d4
            v5 = result2;
            if (v2 != v1) {
                // 0x435dc
                if (*(int32_t *)(v2 + 12) != 0) {
                    // break (via goto) -> 0x43644
                    goto lab_0x43644;
                }
            }
            // 0x435e8
            v11 = *(int32_t *)(v9 + 4);
            if (v11 == v1) {
                // 0x43620
                v12 = *(int32_t *)(v9 + 8);
                v6 = v12;
                if (v12 == v1) {
                    // break -> 0x435a4
                    break;
                }
                goto lab_0x4360c;
            } else {
                // 0x435f4
                if (*(int32_t *)(v11 + 12) != 0) {
                    // 0x4367c
                    __assert_fail("debug_node_color(pTree,n->right) == clib_black", "3rdparty/cstl/src/c_rb.c", 496, "debug_verify_property_4");
                    return &g488;
                }
                // 0x43600
                v10 = *(int32_t *)(v9 + 8);
                v6 = v10;
                if (v10 == v1) {
                    // 0x43634
                    v4 = function_43594(result, v2);
                    v8 = v11;
                    goto lab_0x435c0;
                } else {
                    goto lab_0x4360c;
                }
            }
        } else {
            v7 = *(int32_t *)(v9 + 4);
            goto lab_0x435b0;
        }
    }
    // 0x435a4
    while (v2 != v1) {
        // 0x435c0
        result2 = v5;
        v3 = v2;
        while (true) {
            // 0x435c0
            v9 = v3;
            v2 = *(int32_t *)v9;
            if (*(int32_t *)(v9 + 12) == 1) {
                // 0x435d4
                v5 = result2;
                if (v2 != v1) {
                    // 0x435dc
                    if (*(int32_t *)(v2 + 12) != 0) {
                        // break (via goto) -> 0x43644
                        goto lab_0x43644;
                    }
                }
                // 0x435e8
                v11 = *(int32_t *)(v9 + 4);
                if (v11 == v1) {
                    // 0x43620
                    v12 = *(int32_t *)(v9 + 8);
                    v6 = v12;
                    if (v12 == v1) {
                        // break -> 0x435a4
                        break;
                    }
                    goto lab_0x4360c;
                } else {
                    // 0x435f4
                    if (*(int32_t *)(v11 + 12) != 0) {
                        // 0x4367c
                        __assert_fail("debug_node_color(pTree,n->right) == clib_black", "3rdparty/cstl/src/c_rb.c", 496, "debug_verify_property_4");
                        return &g488;
                    }
                    // 0x43600
                    v10 = *(int32_t *)(v9 + 8);
                    v6 = v10;
                    if (v10 == v1) {
                        // 0x43634
                        v4 = function_43594(result, v2);
                        v8 = v11;
                        goto lab_0x435c0;
                    } else {
                        goto lab_0x4360c;
                    }
                }
            } else {
                v7 = *(int32_t *)(v9 + 4);
                goto lab_0x435b0;
            }
        }
    }
    // 0x435ac
    return result2;
  lab_0x43644:
    // 0x43644
    __assert_fail("debug_node_color(pTree,n->left) == clib_black", "3rdparty/cstl/src/c_rb.c", 495, "debug_verify_property_4");
  lab_0x43660:
    // 0x43660
    __assert_fail("debug_node_color(pTree,n->parent) == clib_black", "3rdparty/cstl/src/c_rb.c", 497, "debug_verify_property_4");
    // 0x4367c
    __assert_fail("debug_node_color(pTree,n->right) == clib_black", "3rdparty/cstl/src/c_rb.c", 496, "debug_verify_property_4");
    return &g488;
  lab_0x435b0:;
    int32_t v13 = function_43594(result, v2); // 0x435b4
    int32_t result3 = v13; // 0x435bc
    v4 = v13;
    v8 = v7;
    if (v7 == v1) {
        // 0x435ac
        return result3;
    }
    goto lab_0x435c0;
  lab_0x4360c:
    // 0x4360c
    v7 = v11;
    if (*(int32_t *)(v6 + 12) != 0) {
        goto lab_0x43660;
    }
    goto lab_0x435b0;
  lab_0x435c0:
    // 0x435c0
    result2 = v4;
    v3 = v8;
    goto lab_0x435c0_2;
}

// Address range: 0x4369c - 0x43728
int32_t function_4369c(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = a1 + 4; // 0x436a4
    int32_t v2 = a3 + 1; // 0x436b8
    int32_t v3 = a2; // 0x436bc
    int32_t v4 = a3; // 0x436bc
    int32_t v5 = v2; // 0x436bc
    int32_t result = a1; // 0x436bc
    int32_t v6 = v2; // 0x436bc
    if (v1 != a2) {
        int32_t v7 = *(int32_t *)(v3 + 12); // 0x436c0
        v4 = v7 == 0 ? v5 : v4;
        v5 += (int32_t)(v7 == 0);
        int32_t v8 = function_4369c(a1, *(int32_t *)v3, v4, a4); // 0x436e0
        v3 += 4;
        result = v8;
        v6 = v5;
        while (v3 != v1) {
            // 0x436c0
            v7 = *(int32_t *)(v3 + 12);
            v4 = v7 == 0 ? v5 : v4;
            v5 += (int32_t)(v7 == 0);
            v8 = function_4369c(a1, *(int32_t *)v3, v4, a4);
            v3 += 4;
            result = v8;
            v6 = v5;
        }
    }
    // 0x436f0
    if (a4 == -1) {
        // 0x43720
        *(int32_t *)a4 = v6;
        return result;
    }
    if (v6 == a4) {
        return result;
    }
    // 0x43704
    __assert_fail("black_count == *path_black_count", "3rdparty/cstl/src/c_rb.c", 517, "debug_verify_property_5_helper");
    // 0x43720
    *(int32_t *)a4 = v6;
    return &g488;
}

// Address range: 0x4372c - 0x437a8
int32_t function_4372c(int32_t a1) {
    // 0x4372c
    function_43534(a1, a1);
    if (*(int32_t *)(a1 + 12) != 0) {
        // 0x4378c
        __assert_fail("debug_node_color(pTree,root) == clib_black", "3rdparty/cstl/src/c_rb.c", 486, "debug_verify_property_2");
        return &g488;
    }
    // 0x4375c
    function_43594(a1, a1);
    int32_t v1 = -1; // bp-20, 0x43770
    return function_4369c(a1, a1, 0, (int32_t)&v1);
}

// Address range: 0x437ac - 0x43804
int32_t function_437ac(int32_t a1, int32_t a2, int32_t a3) {
    int32_t * mem = malloc(40); // 0x437c0
    int32_t result = (int32_t)mem; // 0x437c0
    if (mem == NULL) {
        return result;
    }
    int32_t v1 = result + 4; // 0x437d0
    *(int32_t *)(result + 20) = 0;
    *(int32_t *)(result + 24) = 0;
    *(int32_t *)(result + 12) = 0;
    *(int32_t *)(result + 16) = 0;
    *(int32_t *)(result + 36) = a1;
    *(int32_t *)(result + 28) = a2;
    *(int32_t *)(result + 32) = a3;
    *mem = v1;
    *(int32_t *)v1 = v1;
    *(int32_t *)(result + 8) = v1;
    return result;
}

// Address range: 0x43804 - 0x43884
int32_t function_43804(int32_t a1, int32_t a2) {
    int32_t v1 = a1;
    int32_t v2; // bp-28, 0x43804
    function_44000(*(int32_t *)(v1 + 16), &v2);
    int32_t v3 = v2;
    int32_t v4; // 0x43804
    free(v3, v3, v4, *(int32_t *)(a1 + 36));
    int32_t result = a1; // 0x43864
    while (a2 != 0) {
        int32_t v5 = *(int32_t *)(a2 >= 0 ? v1 + 4 : v1);
        result = 0;
        if (v5 == a1 + 4) {
            // break -> 0x43868
            break;
        }
        v1 = v5;
        function_44000(*(int32_t *)(v1 + 16), &v2);
        v3 = v2;
        free(v3, v3, v4, *(int32_t *)(a1 + 36));
        result = a1;
    }
    // 0x43868
    return result;
}

// Address range: 0x43884 - 0x43ae8
int32_t function_43884(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t * mem = malloc(24); // 0x438a0
    if (mem == NULL) {
        // 0x4395c
        return 2;
    }
    int32_t v1 = (int32_t)mem; // 0x438a0
    int32_t v2 = a1 + 4; // 0x438b0
    *mem = v2;
    *(int32_t *)(v1 + 4) = v2;
    *(int32_t *)(v1 + 12) = 1;
    int32_t v3 = function_43fa4(a2, a3); // 0x438cc
    int32_t * v4 = (int32_t *)(v1 + 16); // 0x438d4
    *v4 = v3;
    int32_t v5; // 0x43884
    if (a4 == 0) {
        *(int32_t *)(v1 + 20) = 0;
        v5 = v3;
    } else {
        int32_t v6 = function_43fa4(a4, a5); // 0x438e8
        *(int32_t *)(v1 + 20) = v6;
        v5 = v6;
    }
    // 0x438f0
    int32_t v7; // 0x43884
    if (v2 == v5) {
        // 0x43ab8
        *(int32_t *)a1 = v1;
        *(int32_t *)(v1 + 8) = 0;
        v7 = v1;
      lab_0x43a1c:
        // 0x43a1c
        *(int32_t *)(v7 + 12) = 0;
        function_4372c(a1);
        return 0;
    }
    int32_t * v8 = (int32_t *)(a1 + 36);
    int32_t v9 = v5;
    int32_t * v10 = (int32_t *)(v9 + 16); // 0x43918
    int32_t v11; // bp-40, 0x43884
    function_44000(*v10, &v11);
    int32_t v12; // bp-36, 0x43884
    function_44000(*v4, &v12);
    int32_t v13 = *v8; // 0x4392c
    int32_t v14 = v11;
    free(v14, v14, a3, v13);
    free(v12, v14, a3, v13);
    int32_t v15; // 0x439a8
    while (v12 != 0) {
        uint64_t v16 = *(int64_t *)v9; // 0x43900
        int32_t v17 = v16 / 0x100000000; // 0x43900
        int32_t v18 = v12 >= 0 ? (int32_t)v16 : v17;
        if (v2 == v18) {
            // 0x43964
            *(int32_t *)(v1 + 8) = v9;
            function_44000(*v10, &v11);
            function_44000(*v4, &v12);
            int32_t v19 = *v8; // 0x43984
            int32_t v20 = v11;
            free(v20, v20, v17, v19);
            v15 = free(v12, v20, v17, v19);
            if (v12 < 0) {
                *(int32_t *)v9 = v1;
                goto lab_0x439bc;
            } else {
                *(int32_t *)(v9 + 4) = v1;
                goto lab_0x439bc;
            }
        }
        v9 = v18;
        v10 = (int32_t *)(v9 + 16);
        function_44000(*v10, &v11);
        function_44000(*v4, &v12);
        v13 = *v8;
        v14 = v11;
        free(v14, v14, v17, v13);
        free(v12, v14, v17, v13);
    }
    // 0x4395c
    return 401;
  lab_0x439bc:;
    int32_t v21 = v1; // 0x439c0
    int32_t v22 = v15; // 0x439c0
    v7 = v1;
    if (v15 == v1) {
        goto lab_0x43a1c;
    } else {
        goto lab_0x439c4;
    }
  lab_0x439c4:;
    int32_t v23 = v22; // 0x43884
    int32_t v24 = v21; // 0x43884
    goto lab_0x439c4_2;
  lab_0x439c4_2:;
    int32_t v25 = v24;
    int32_t v26 = v23;
    int32_t v27 = *(int32_t *)(v25 + 8); // 0x439c4
    int32_t * v28 = (int32_t *)(v27 + 12);
    v7 = v26;
    int32_t * v29; // 0x43884
    int32_t * v30; // 0x43884
    int32_t v31; // 0x43884
    int32_t v32; // 0x43884
    int32_t v33; // 0x43884
    int32_t v34; // 0x43884
    int32_t v35; // 0x43ae0
    int32_t v36; // 0x43aac
    if (*v28 == 1) {
        int32_t * v37 = (int32_t *)(v27 + 8);
        int32_t v38 = *v37; // 0x439d4
        int32_t v39 = *(int32_t *)v38; // 0x439d8
        if (v27 == v39) {
            int32_t * v40 = (int32_t *)(*(int32_t *)(v38 + 4) + 12); // 0x43a3c
            if (*v40 == 1) {
                // 0x43a84
                *v28 = 0;
                *v40 = 0;
                *(int32_t *)(v38 + 12) = 1;
                v31 = v26;
                v32 = v38;
                goto lab_0x439bc_2;
            } else {
                // 0x43a48
                v29 = v28;
                v35 = v38;
                v34 = v25;
                if (*(int32_t *)(v27 + 4) == v25) {
                    // 0x43acc
                    function_4348c(a1, v27);
                    int32_t v41 = *v37; // 0x43ad8
                    v35 = *(int32_t *)(v41 + 8);
                    v29 = (int32_t *)(v41 + 12);
                    v34 = v27;
                    goto lab_0x43a54;
                } else {
                    goto lab_0x43a54;
                }
            }
        } else {
            int32_t * v42 = (int32_t *)(v39 + 12); // 0x439e4
            if (*v42 == 1) {
                // 0x43a70
                *v28 = 0;
                *v42 = 0;
                *(int32_t *)(v38 + 12) = 1;
                v31 = v26;
                v32 = v38;
                goto lab_0x439bc_2;
            } else {
                // 0x439f0
                v30 = v28;
                v36 = v38;
                v33 = v25;
                if (v25 == *(int32_t *)v27) {
                    // 0x43a98
                    function_434e0(a1, v27);
                    int32_t v43 = *v37; // 0x43aa4
                    v36 = *(int32_t *)(v43 + 8);
                    v30 = (int32_t *)(v43 + 12);
                    v33 = v27;
                    goto lab_0x439fc;
                } else {
                    goto lab_0x439fc;
                }
            }
        }
    } else {
        goto lab_0x43a1c;
    }
  lab_0x439bc_2:
    // 0x439bc
    v21 = v32;
    v22 = v31;
    v7 = v31;
    if (v32 == v31) {
        goto lab_0x43a1c;
    } else {
        goto lab_0x439c4;
    }
  lab_0x43a54:
    // 0x43a54
    *v29 = 0;
    *(int32_t *)(v35 + 12) = 1;
    v31 = function_434e0(a1, v35);
    v32 = v34;
    goto lab_0x439bc_2;
  lab_0x439fc:
    // 0x439fc
    *v30 = 0;
    *(int32_t *)(v36 + 12) = 1;
    int32_t v44 = function_4348c(a1, v36); // 0x43a0c
    v23 = v44;
    v24 = v33;
    v7 = v33;
    if (v33 == v44) {
        goto lab_0x43a1c;
    } else {
        goto lab_0x439c4_2;
    }
}

// Address range: 0x43ae8 - 0x43d9c
int32_t function_43ae8(int32_t a1, int32_t a2) {
    int32_t v1 = a1 + 4;
    int32_t v2 = a1; // 0x43b08
    int32_t * v3 = (int32_t *)(v2 + 16); // 0x43b20
    int32_t v4; // bp-28, 0x43ae8
    function_44000(*v3, &v4);
    int32_t v5 = v4;
    int32_t v6; // 0x43ae8
    int32_t v7 = free(v5, v5, v6, *(int32_t *)(a1 + 36)); // 0x43b40
    int32_t v8 = *(int32_t *)v2; // 0x43b48
    while (a2 != 0) {
        // 0x43b0c
        v2 += 4;
        if (v2 == v1) {
            // 0x43bf8
            return 0;
        }
        v3 = (int32_t *)(v2 + 16);
        function_44000(*v3, &v4);
        v5 = v4;
        v7 = free(v5, v5, v6, *(int32_t *)(a1 + 36));
        v8 = *(int32_t *)v2;
    }
    int32_t v9 = *(int32_t *)v1; // 0x43b54
    int32_t v10 = v9; // 0x43b58
    int32_t result = a1; // 0x43b58
    if (v1 != v8) {
        // 0x43b5c
        v10 = v8;
        result = a1;
        if (v1 != v9) {
            int32_t v11 = v9;
            int32_t v12 = *(int32_t *)v11; // 0x43b74
            while (v1 != v12) {
                // 0x43b74
                v11 = v12;
                v12 = *(int32_t *)v11;
            }
            // 0x43b80
            v10 = *(int32_t *)(v11 + 4);
            result = v11;
        }
    }
    int32_t * v13 = (int32_t *)(result + 8); // 0x43b88
    *(int32_t *)(v10 + 8) = *v13;
    int32_t v14 = *v13; // 0x43b90
    if (v14 == 0) {
        *(int32_t *)a1 = v10;
    } else {
        int32_t * v15 = (int32_t *)v14; // 0x43ba0
        if (result == *v15) {
            *v15 = v10;
        } else {
            // .critedge
            *(int32_t *)(v14 + 4) = v10;
        }
    }
    int32_t v16 = v7; // 0x43bb4
    if (result != a1) {
        int32_t * v17 = (int32_t *)(result + 16); // 0x43bbc
        v16 = *v17;
        int32_t * v18 = (int32_t *)(a1 + 20); // 0x43bc0
        int32_t * v19 = (int32_t *)(result + 20); // 0x43bc4
        *v3 = v16;
        *v17 = *v3;
        *v18 = *v19;
        *v19 = *v18;
    }
    // 0x43bd8
    if (*(int32_t *)(result + 12) != 0) {
        // 0x43be4
        function_4372c(a1);
        return result;
    }
    int32_t v20 = v10; // 0x43c14
    int32_t v21 = v10; // 0x43c14
    int32_t * v22; // 0x43ae8
    int32_t * v23; // 0x43ae8
    int32_t v24; // 0x43ae8
    int32_t v25; // 0x43ae8
    int32_t v26; // 0x43ae8
    int32_t v27; // 0x43ae8
    if (v10 != v16) {
        v21 = v20;
        while (*(int32_t *)(v20 + 12) == 0) {
            int32_t * v28 = (int32_t *)(v20 + 8);
            int32_t v29 = *v28; // 0x43c24
            int32_t v30 = *(int32_t *)v29; // 0x43c28
            int32_t v31; // 0x43ae8
            int32_t v32; // 0x43ae8
            if (v20 == v30) {
                int32_t v33 = *(int32_t *)(v29 + 4); // 0x43cd4
                int32_t * v34 = (int32_t *)(v33 + 12); // 0x43cd8
                int32_t v35 = v29; // 0x43ce0
                int32_t v36 = v33; // 0x43ce0
                if (*v34 == 1) {
                    // 0x43d7c
                    *v34 = 0;
                    *(int32_t *)(v29 + 12) = 1;
                    function_4348c(a1, v29);
                    v35 = *v28;
                    v36 = *(int32_t *)(v35 + 4);
                }
                int32_t v37 = v36;
                int32_t v38 = v35;
                int32_t * v39 = (int32_t *)(*(int32_t *)v37 + 12); // 0x43ce8
                int32_t * v40 = (int32_t *)(*(int32_t *)(v37 + 4) + 12);
                int32_t v41 = *v40; // 0x43cec
                if (*v39 != 0) {
                    // 0x43d2c
                    v22 = v40;
                    v25 = v37;
                    v27 = v38;
                    if (v41 == 0) {
                        // 0x43d38
                        *v39 = 0;
                        *(int32_t *)(v37 + 12) = 1;
                        function_434e0(a1, v37);
                        int32_t v42 = *v28; // 0x43d4c
                        int32_t v43 = *(int32_t *)(v42 + 4); // 0x43d50
                        v22 = (int32_t *)(*(int32_t *)(v43 + 4) + 12);
                        v25 = v43;
                        v27 = v42;
                        goto lab_0x43d04;
                    } else {
                        goto lab_0x43d04;
                    }
                }
                // 0x43cf8
                v31 = v37;
                v32 = v38;
                v22 = v40;
                v25 = v37;
                v27 = v38;
                if (v41 != 0) {
                    goto lab_0x43d04;
                }
            } else {
                int32_t * v44 = (int32_t *)(v30 + 12); // 0x43c34
                int32_t v45 = v29; // 0x43c3c
                int32_t v46 = v30; // 0x43c3c
                if (*v44 == 1) {
                    // 0x43d5c
                    *v44 = 0;
                    *(int32_t *)(v29 + 12) = 1;
                    function_434e0(a1, v29);
                    v45 = *v28;
                    v46 = *(int32_t *)v45;
                }
                int32_t v47 = v46;
                int32_t v48 = v45;
                int32_t * v49 = (int32_t *)(*(int32_t *)(v47 + 4) + 12); // 0x43c48
                int32_t * v50 = (int32_t *)(*(int32_t *)v47 + 12);
                int32_t v51 = *v50; // 0x43c4c
                if (*v49 != 0) {
                    // 0x43c80
                    v23 = v50;
                    v24 = v47;
                    v26 = v48;
                    if (v51 == 0) {
                        // 0x43c8c
                        *v49 = 0;
                        *(int32_t *)(v47 + 12) = 1;
                        function_4348c(a1, v47);
                        int32_t v52 = *v28; // 0x43ca0
                        int32_t v53 = *(int32_t *)v52; // 0x43ca4
                        v23 = (int32_t *)(*(int32_t *)v53 + 12);
                        v24 = v53;
                        v26 = v52;
                        goto lab_0x43cac;
                    } else {
                        goto lab_0x43cac;
                    }
                }
                // 0x43c58
                v31 = v47;
                v32 = v48;
                v23 = v50;
                v24 = v47;
                v26 = v48;
                if (v51 != 0) {
                    goto lab_0x43cac;
                }
            }
            // 0x43c64
            v20 = v32;
            *(int32_t *)(v31 + 12) = 1;
            v21 = 0;
            if (v20 == 0) {
                // break -> 0x43c74
                break;
            }
            v21 = v20;
        }
        // 0x43c74
        *(int32_t *)(v21 + 12) = 0;
        // 0x43be4
        function_4372c(a1);
        return result;
    }
  lab_0x43c74:
    // 0x43c74
    *(int32_t *)(v21 + 12) = 0;
    // 0x43be4
    function_4372c(a1);
    return result;
  lab_0x43d04:;
    int32_t * v54 = (int32_t *)(v27 + 12); // 0x43d04
    *(int32_t *)(v25 + 12) = *v54;
    *v54 = 0;
    *v22 = 0;
    v21 = function_4348c(a1, v27);
    goto lab_0x43c74;
  lab_0x43cac:;
    int32_t * v55 = (int32_t *)(v26 + 12); // 0x43cac
    *(int32_t *)(v24 + 12) = *v55;
    *v55 = 0;
    *v23 = 0;
    v21 = function_434e0(a1, v26);
    goto lab_0x43c74;
}

// Address range: 0x43d9c - 0x43ea4
int32_t function_43d9c(int32_t a1) {
    int32_t v1 = a1 + 4; // 0x43dac
    int32_t * v2 = (int32_t *)(a1 + 28);
    int32_t * v3 = (int32_t *)(a1 + 32);
    int32_t v4 = a1;
    int32_t v5; // 0x43d9c
    int32_t v6; // 0x43d9c
    int32_t v7; // 0x43d9c
    int32_t v8; // 0x43d9c
    int32_t v9; // 0x43d9c
    int32_t v10; // 0x43d9c
    int32_t v11; // 0x43db4
    int32_t v12; // 0x43de0
    while (true) {
        // 0x43db4
        v8 = v4;
        v11 = *(int32_t *)v8;
        v9 = v11;
        if (v11 == v1) {
            // 0x43de0
            v10 = v11 == v1 ? v8 : v11;
            v12 = *(int32_t *)(v10 + 4);
            v9 = v12;
            if (v1 == v12) {
                // break -> 0x43df0
                break;
            }
        }
        // 0x43dc4
        v4 = v9;
        v6 = v5;
        v7 = v11;
        if (v4 == v1) {
            // break (via goto) -> 0x43dcc
            goto lab_0x43dcc;
        }
    }
    int32_t * v13 = (int32_t *)(v10 + 16); // 0x43df4
    int32_t v14 = *v13; // 0x43df4
    int32_t v15 = v5; // 0x43dfc
    int32_t v16 = v14; // 0x43dfc
    int32_t v17 = 0; // 0x43dfc
    int32_t v18; // bp-32, 0x43d9c
    if (*v2 != 0) {
        // 0x43e00
        function_44000(v14, &v18);
        v17 = *v2;
        v16 = *v13;
        v15 = &v18;
    }
    int32_t v19 = v15;
    function_44074(v16);
    int32_t * v20 = (int32_t *)(v10 + 20); // 0x43e1c
    int32_t v21 = *v20; // 0x43e1c
    int32_t v22 = v19; // 0x43e24
    int32_t v23 = v17; // 0x43e24
    int32_t v24; // bp-28, 0x43d9c
    int32_t v25; // 0x43e48
    if (v21 != 0) {
        // 0x43e28
        v22 = v19;
        v25 = v21;
        v23 = 0;
        if (*v3 != 0) {
            // 0x43e34
            function_44000(v21, &v24);
            v23 = *v3;
            v25 = *v20;
            v22 = &v24;
        }
        // 0x43e4c
        function_44074(v25);
    }
    int32_t v26 = v23;
    int32_t v27 = v22;
    int32_t v28 = *(int32_t *)(v10 + 8); // 0x43e50
    int32_t v29; // 0x43d9c
    if (v28 == 0) {
        // 0x43dc4
        free(v10, v27, v29, v26);
        v6 = v27;
        v7 = v26;
        goto lab_0x43dcc;
    }
    int32_t * v30 = (int32_t *)v28; // 0x43e5c
    int32_t v31 = *v30; // 0x43e5c
    int32_t * v32; // 0x43e78
    int32_t v33; // 0x43e78
    if (v1 == v31) {
        // 0x43e78
        v32 = (int32_t *)(v28 + 4);
        v33 = *v32;
        if (v1 != v33) {
            // 0x43e88
            free(v33, v27, v29, v26);
            *v32 = v1;
        }
    } else {
        // 0x43e68
        free(v31, v27, v29, v26);
        *v30 = v1;
    }
    // 0x43dc4
    v6 = v27;
    v7 = v26;
    while (v28 != v1) {
        int32_t v34 = v27;
        v4 = v28;
        while (true) {
            // 0x43db4
            v8 = v4;
            v11 = *(int32_t *)v8;
            v9 = v11;
            if (v11 == v1) {
                // 0x43de0
                v10 = v11 == v1 ? v8 : v11;
                v12 = *(int32_t *)(v10 + 4);
                v9 = v12;
                if (v1 == v12) {
                    // break -> 0x43df0
                    break;
                }
            }
            // 0x43dc4
            v4 = v9;
            v6 = v34;
            v7 = v11;
            if (v4 == v1) {
                // break (via goto) -> 0x43dcc
                goto lab_0x43dcc;
            }
        }
        // 0x43df0
        v13 = (int32_t *)(v10 + 16);
        v14 = *v13;
        v15 = v34;
        v16 = v14;
        v17 = 0;
        if (*v2 != 0) {
            // 0x43e00
            function_44000(v14, &v18);
            v17 = *v2;
            v16 = *v13;
            v15 = &v18;
        }
        // 0x43e18
        v19 = v15;
        function_44074(v16);
        v20 = (int32_t *)(v10 + 20);
        v21 = *v20;
        int32_t v35 = v19; // 0x43e24
        int32_t v36 = v17; // 0x43e24
        if (v21 != 0) {
            // 0x43e28
            v22 = v19;
            v25 = v21;
            v23 = 0;
            if (*v3 != 0) {
                // 0x43e34
                function_44000(v21, &v24);
                v23 = *v3;
                v25 = *v20;
                v22 = &v24;
            }
            // 0x43e4c
            v36 = v23;
            function_44074(v25);
            v35 = v22;
        }
        // 0x43e50
        v26 = v36;
        v27 = v35;
        v28 = *(int32_t *)(v10 + 8);
        if (v28 == 0) {
            // 0x43dc4
            free(v10, v27, v29, v26);
            v6 = v27;
            v7 = v26;
            goto lab_0x43dcc;
        }
        // 0x43e5c
        v30 = (int32_t *)v28;
        v31 = *v30;
        if (v1 == v31) {
            // 0x43e78
            v32 = (int32_t *)(v28 + 4);
            v33 = *v32;
            if (v1 != v33) {
                // 0x43e88
                free(v33, v27, v29, v26);
                *v32 = v1;
            }
        } else {
            // 0x43e68
            free(v31, v27, v29, v26);
            *v30 = v1;
        }
        // 0x43dc4
        v6 = v27;
        v7 = v26;
    }
  lab_0x43dcc:
    // 0x43dcc
    free(a1, v6, v29, v7);
    return 0;
}

// Address range: 0x43ea4 - 0x43ec4
int32_t function_43ea4(int32_t a1) {
    int32_t v1; // 0x43ea4
    int32_t result = v1;
    int32_t v2 = *(int32_t *)result; // 0x43eb0
    // 0x43ea4
    while (v2 != a1 + 4) {
        // 0x43eb0
        result = v2;
        v2 = *(int32_t *)result;
    }
    // 0x43ebc
    return result;
}

// Address range: 0x43ec4 - 0x43ee4
int32_t function_43ec4(int32_t a1) {
    int32_t v1; // 0x43ec4
    int32_t result = v1;
    int32_t v2 = *(int32_t *)(result + 4); // 0x43ed0
    // 0x43ec4
    while (v2 != a1 + 4) {
        // 0x43ed0
        result = v2;
        v2 = *(int32_t *)(result + 4);
    }
    // 0x43edc
    return result;
}

// Address range: 0x43ee4 - 0x43ef8
int32_t function_43ee4(int32_t a1) {
    // 0x43ee4
    return 1;
}

// Address range: 0x43ef8 - 0x43f9c
int32_t function_43ef8(int32_t a1, int32_t a2) {
    int32_t result2 = *(int32_t *)(a2 + 4); // 0x43ef8
    int32_t v1 = a1 + 4; // 0x43efc
    if (result2 != v1) {
        int32_t result = result2;
        int32_t v2 = *(int32_t *)result; // 0x43f10
        while (v1 != v2) {
            // 0x43f10
            result = v2;
            v2 = *(int32_t *)result;
        }
        // 0x43f1c
        return result;
    }
    int32_t v3 = a1;
    int32_t v4 = *(int32_t *)(v3 + 4); // 0x43f30
    while (result2 != v4) {
        // 0x43f30
        v3 = v4;
        v4 = *(int32_t *)(v3 + 4);
    }
    // 0x43f3c
    if (v3 == a2) {
        // 0x43f1c
        return 0;
    }
    int32_t result3 = *(int32_t *)(a2 + 8); // 0x43f44
    if (result2 == result3) {
        // 0x43f1c
        return result2;
    }
    // 0x43f50
    if (*(int32_t *)(result3 + 4) != a2) {
        // 0x43f1c
        return result3;
    }
    int32_t v5 = result3;
    int32_t v6 = *(int32_t *)(v5 + 8); // 0x43f70
    int32_t result4 = result2; // 0x43f78
    while (result2 != v6) {
        // 0x43f60
        result4 = v6;
        if (*(int32_t *)(v6 + 4) != v5) {
            // break -> 0x43f1c
            break;
        }
        v5 = v6;
        v6 = *(int32_t *)(v5 + 8);
        result4 = result2;
    }
    // 0x43f1c
    return result4;
}

// Address range: 0x43f9c - 0x43fa0
int32_t function_43f9c(void) {
    // 0x43f9c
    int32_t v1; // 0x43f9c
    return function_11fc4((int32_t *)v1, v1, (char)v1, v1);
}

// Address range: 0x43fa0 - 0x43fa4
int32_t function_43fa0(void) {
    // 0x43fa0
    int32_t v1; // 0x43fa0
    return function_11fc4((int32_t *)v1, v1, (char)v1, v1);
}

// Address range: 0x43fa4 - 0x44000
int32_t function_43fa4(int32_t a1, int32_t size) {
    int32_t * mem = malloc(8); // 0x43fb4
    int32_t result = (int32_t)mem; // 0x43fb4
    if (mem == NULL) {
        // 0x43fe8
        return result;
    }
    // 0x43fc0
    *(int32_t *)(result + 4) = size;
    int32_t * mem2 = malloc(size); // 0x43fc8
    int32_t v1 = (int32_t)mem2; // 0x43fc8
    *mem = v1;
    int32_t result2; // 0x43fa4
    if (mem2 == NULL) {
        // 0x43ff0
        int32_t v2; // 0x43fa4
        free(result, size, v2, v1);
        result2 = v1;
    } else {
        // 0x43fdc
        function_11fc4(mem2, a1, (char)size, v1);
        result2 = result;
    }
    // 0x43fe8
    return result2;
}

// Address range: 0x44000 - 0x44040
int32_t function_44000(int32_t a1, int32_t * a2) {
    int32_t size = *(int32_t *)(a1 + 4); // 0x44008
    int32_t * mem = malloc(size); // 0x44014
    int32_t v1 = (int32_t)mem; // 0x44014
    *a2 = v1;
    if (mem == NULL) {
        // 0x44038
        return 3;
    }
    // 0x44024
    function_11fc4(mem, v1, (char)size, v1);
    return 0;
}

// Address range: 0x44040 - 0x44074
int32_t function_44040(int32_t a1, int32_t a2, int32_t size) {
    // 0x44040
    int32_t v1; // 0x44040
    free(a1, a2, size, v1);
    int32_t * mem = malloc(size); // 0x4405c
    *(int32_t *)a1 = (int32_t)mem;
    return function_11fc4(mem, a2, (char)size, v1);
}

// Address range: 0x44074 - 0x44094
int32_t function_44074(int32_t a1) {
    // 0x44074
    if (a1 == 0) {
        return 0;
    }
    // 0x44080
    int32_t v1; // 0x44074
    free(a1, v1, v1, v1);
    return free(a1, v1, v1, v1);
}

// Address range: 0x44094 - 0x44098
int32_t function_44094(void) {
    // 0x44094
    int32_t v1; // 0x44094
    return (int32_t)__strdup((char *)v1);
}

// Address range: 0x44098 - 0x440e8
int32_t function_44098(int32_t a1) {
    // 0x44098
    int32_t str; // bp-2056, 0x44098
    snprintf((char *)&str, 2048, "%s: Bad eeprom param, input chain is %d\n", "eeprom_open", a1);
    function_2e584(0, &str, 0);
    return -0x7ffffeff;
}

// Address range: 0x440e8 - 0x44164
int32_t function_440e8(uint32_t a1) {
    if (a1 >= 15 == (a1 != 15)) {
        // 0x44154
        return function_44098(a1);
    }
    int32_t v1 = 8 * a1; // 0x44104
    int32_t * v2 = (int32_t *)(v1 + (int32_t)&g133); // 0x44104
    int32_t result = *v2; // 0x44104
    if (result != 0) {
        // 0x44110
        if (*(int32_t *)(v1 + (int32_t)&g133 + 4) != 0) {
            // 0x44154
            return result;
        }
    }
    int32_t v3 = a1; // bp-24, 0x44134
    int32_t result2 = function_493d0(&v3); // 0x4413c
    if (result2 >= 0) {
        *v2 = result2;
        *(int32_t *)(v1 + (int32_t)&g133 + 4) = 1;
    }
    // 0x44154
    return result2;
}

// Address range: 0x44164 - 0x441fc
int32_t function_44164(uint32_t a1) {
    if (a1 >= 15 == (a1 != 15)) {
        // 0x441c4
        int32_t str; // bp-2064, 0x44164
        snprintf((char *)&str, 2048, "%s: Bad eeprom param, input chain is %d\n", "eeprom_close", a1);
        return function_2e584(0, &str, 0);
    }
    int32_t v1 = 8 * a1; // 0x44180
    int32_t * v2 = (int32_t *)(v1 + (int32_t)&g133); // 0x44188
    int32_t v3 = *v2; // 0x44188
    int32_t * v4 = (int32_t *)(v1 + (int32_t)&g133 + 4);
    if (v3 == 0) {
        // 0x44194
        if (*v4 == 0) {
            // 0x441b8
            return 0;
        }
    }
    int32_t result = function_49574(v3); // 0x441a4
    *v4 = 0;
    *v2 = 0;
    // 0x441b8
    return result;
}

// Address range: 0x44200 - 0x44354
int32_t function_44200(uint32_t a1, int32_t a2, int32_t * a3, int32_t a4) {
    int32_t str; // bp-2080, 0x44200
    if (a1 >= 15 == (a1 != 15)) {
        // 0x4431c
        snprintf((char *)&str, 2048, "%s: Bad eeprom param, input chain is %d\n", "eeprom_write", a1);
        function_2e584(0, &str, 0);
        // 0x442bc
        return -0x7ffffeff;
    }
    int32_t v1 = 8 * a1; // 0x44224
    int32_t v2; // 0x44200
    if (*(int32_t *)(v1 + (int32_t)&g133 + 4) == 0) {
        int32_t result = function_440e8(a1); // 0x442e0
        v2 = result;
        if (result < 0) {
            // 0x442ec
            snprintf((char *)&str, 2048, "%s: auto exec eeprom_open, but chain %d open eeprom failed\n", "eeprom_write", a1);
            function_2e584(0, &str, 0);
            // 0x442bc
            return result;
        }
    }
    if (a4 == 0) {
        // 0x442c8
        function_12030(1);
        return 0;
    }
    int32_t v3 = (int32_t)a3;
    int32_t v4 = a2; // 0x44200
    int32_t v5 = v3; // 0x44268
    int32_t v6 = *(int32_t *)(v1 + (int32_t)&g133); // 0x4425c
    int32_t v7 = 0x1000000 * v4 >> 24; // bp-2081, 0x4426c
    while (function_49794(v6, &v7, 1, v5, a4 == 0 ? v2 : 1) == 1) {
        // 0x4424c
        v5++;
        v4 = (v4 + 1) % 256;
        if ((a4 == 0 ? 0 : v3 + a4) == v5) {
            // 0x442c8
            function_12030(1);
            return 0;
        }
        v6 = *(int32_t *)(v1 + (int32_t)&g133);
        v7 = 0x1000000 * v4 >> 24;
    }
    // 0x44284
    snprintf((char *)&str, 2048, "fail to write eeprom by iic, chain:%d, addr: %d", a1, v7 % 256);
    function_2e584(0, &str, 0);
    // 0x442bc
    return -0x7fffff00;
}

// Address range: 0x44358 - 0x444b0
int32_t function_44358(uint32_t a1, int32_t a2, int32_t * a3, int32_t a4) {
    int32_t str; // bp-2080, 0x44358
    if (a1 >= 15 == (a1 != 15)) {
        // 0x44478
        snprintf((char *)&str, 2048, "%s: Bad eeprom param, input chain is %d\n", "eeprom_read", a1);
        function_2e584(0, &str, 0);
        // 0x44414
        return -0x7ffffeff;
    }
    int32_t v1 = 8 * a1; // 0x4437c
    int32_t v2; // 0x44358
    if (*(int32_t *)(v1 + (int32_t)&g133 + 4) == 0) {
        int32_t result = function_440e8(a1); // 0x4443c
        v2 = result;
        if (result < 0) {
            // 0x44448
            snprintf((char *)&str, 2048, "%s: auto exec eeprom_open, but chain %d open eeprom failed\n", "eeprom_read", a1);
            function_2e584(0, &str, 0);
            // 0x44414
            return result;
        }
    }
    if (a4 == 0) {
        // 0x44420
        usleep(0x7a120);
        return 0;
    }
    int32_t v3 = (int32_t)a3;
    int32_t v4 = a2; // 0x44358
    int32_t v5 = v3; // 0x443c0
    int32_t v6 = *(int32_t *)(v1 + (int32_t)&g133); // 0x443b4
    int32_t v7 = 0x1000000 * v4 >> 24; // bp-2081, 0x443c4
    while (function_496f4(v6, &v7, 1, v5, a4 == 0 ? v2 : 1) == 1) {
        // 0x443a4
        v5++;
        v4 = (v4 + 1) % 256;
        if ((a4 == 0 ? 0 : v3 + a4) == v5) {
            // 0x44420
            usleep(0x7a120);
            return 0;
        }
        v6 = *(int32_t *)(v1 + (int32_t)&g133);
        v7 = 0x1000000 * v4 >> 24;
    }
    // 0x443dc
    snprintf((char *)&str, 2048, "fail to read eeprom by iic, chain: %d, addr: %d\n", a1, v7 % 256);
    function_2e584(0, &str, 0);
    // 0x44414
    return -0x7fffff00;
}

// Address range: 0x444b8 - 0x44540
int32_t function_444b8(void) {
    int32_t v1 = 0; // bp-20, 0x444d0
    function_40314(35, &v1);
    function_40390(35, v1 & -65);
    int32_t v2 = 10; // 0x444e8
    usleep(1000);
    v1 = 0;
    function_40314(35, &v1);
    int32_t result = 35; // 0x44514
    while ((v1 & 64) != 0) {
        int32_t v3 = v2;
        v1 = 0;
        function_40314(35, &v1);
        v2 = v3 - 1;
        result = function_40390(35, v1 & -65);
        if (v3 == 1) {
            // break -> 0x44538
            break;
        }
        usleep(1000);
        v1 = 0;
        function_40314(35, &v1);
        result = 35;
    }
    // 0x44538
    return result;
}

// Address range: 0x44540 - 0x445d4
int32_t function_44540(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    if (result == 0x1c200) {
        // 0x445b4
        return 26;
    }
    // 0x44550
    __asm_vmov_7(result);
    __asm_vldr(0);
    return result;
}

// Address range: 0x445d4 - 0x445d8
int32_t function_445d4(void) {
    // 0x445d4
    return function_444c18();
}

// Address range: 0x445dc - 0x445de
int32_t function_445dc(void) {
    // 0x445dc
    int32_t result; // 0x445dc
    return result;
}

// Address range: 0x445e0 - 0x4464c
int32_t function_445e0(int32_t a1) {
    // 0x445e0
    function_40390(27, a1);
    int32_t v1; // bp-12, 0x445e0
    if (a1 >= 0) {
        // 0x44638
        return function_40314(27, &v1);
    }
    int32_t v2 = 3001; // 0x44600
    function_40314(27, &v1);
    int32_t result = 1000; // 0x4462c
    while (v1 < 0) {
        int32_t v3 = v2;
        v2 = v3 - 1;
        result = usleep(1000);
        if (v3 == 1) {
            // break -> 0x44630
            break;
        }
        function_40314(27, &v1);
        result = 1000;
    }
    // 0x44630
    return result;
}

// Address range: 0x4464c - 0x44654
int32_t function_4464c(void) {
    // 0x4464c
    return 0;
}

// Address range: 0x44654 - 0x4466c
int32_t function_44654(int32_t a1) {
    // 0x44654
    return (int32_t)(*(int64_t *)(g134 + (64 * a1 | 8)) / 0x100000000);
}

// Address range: 0x4466c - 0x44680
int32_t function_4466c(int32_t a1) {
    // 0x4466c
    return *(int32_t *)(g134 + 64 * a1);
}

// Address range: 0x44680 - 0x44698
int32_t function_44680(int32_t a1) {
    // 0x44680
    return *(int32_t *)(g134 + (64 * a1 | 4));
}

// Address range: 0x44698 - 0x446dc
int32_t function_44698(int32_t a1, int32_t a2, int32_t a3) {
    if (a3 == 0) {
        // 0x446d4
        return 0;
    }
    int32_t v1 = a2 - 1;
    int32_t v2 = v1; // 0x446c0
    int32_t v3 = g134 + (64 * a1 | 31); // 0x446c0
    v3++;
    v2++;
    *(char *)v2 = *(char *)v3;
    while (v2 != v1 + a3) {
        // 0x446c4
        v3++;
        v2++;
        *(char *)v2 = *(char *)v3;
    }
    // 0x446d4
    return 0;
}

// Address range: 0x446dc - 0x44724
int32_t function_446dc(void) {
    int32_t v1 = 0; // bp-12, 0x446f0
    function_40314(13, &v1);
    int32_t v2 = v1 | 0xffff;
    v1 = v2;
    function_40390(13, v2);
    return function_12030(2);
}

// Address range: 0x44724 - 0x4476c
int32_t function_44724(void) {
    int32_t v1 = 0; // bp-12, 0x44738
    function_40314(13, &v1);
    int32_t v2 = v1 & -0x10000; // 0x44748
    v1 = v2;
    function_40390(13, v2);
    return function_12030(2);
}

// Address range: 0x4476c - 0x44794
int32_t function_4476c(int32_t a1) {
    int32_t result = 0; // bp-12, 0x44780
    function_40314(35, &result);
    return result;
}

// Address range: 0x44794 - 0x447a0
int32_t function_44794(int32_t a1) {
    // 0x44794
    return function_40390(35, a1);
}

// Address range: 0x447a0 - 0x447d8
int32_t function_447a0(void) {
    int32_t v1 = 0; // bp-12, 0x447b4
    function_40314(35, &v1);
    function_40390(35, v1 | 64);
    return 0;
}

// Address range: 0x447d8 - 0x44810
int32_t function_447d8(void) {
    int32_t v1 = 0; // bp-12, 0x447ec
    function_40314(35, &v1);
    function_40390(35, v1 & -65);
    return 0;
}

// Address range: 0x44810 - 0x44848
int32_t function_44810(void) {
    int32_t v1 = 0; // bp-12, 0x44824
    function_40314(35, &v1);
    function_40390(35, v1 | 128);
    return 0;
}

// Address range: 0x44848 - 0x44880
int32_t function_44848(void) {
    int32_t v1 = 0; // bp-12, 0x4485c
    function_40314(35, &v1);
    function_40390(35, v1 & -129);
    return 0;
}

// Address range: 0x44880 - 0x448c8
int32_t function_44880(int32_t a1) {
    int32_t v1 = 0; // bp-20, 0x44898
    function_40314(35, &v1);
    function_40390(35, v1 & -3841 | 256 * a1 & 3840);
    return 0;
}

// Address range: 0x448c8 - 0x44900
int32_t function_448c8(void) {
    int32_t v1 = 0; // bp-12, 0x448dc
    function_40314(35, &v1);
    function_40390(35, v1 | 0x8000);
    return 0;
}

// Address range: 0x44900 - 0x44938
int32_t function_44900(void) {
    int32_t v1 = 0; // bp-12, 0x44914
    function_40314(35, &v1);
    function_40390(35, v1 & -0x8001);
    return 0;
}

// Address range: 0x44938 - 0x44970
int32_t function_44938(void) {
    int32_t v1 = 0; // bp-12, 0x4494c
    function_40314(35, &v1);
    function_40390(35, v1 | 32);
    return 0;
}

// Address range: 0x44970 - 0x449a8
int32_t function_44970(void) {
    int32_t v1 = 0; // bp-12, 0x44984
    function_40314(35, &v1);
    function_40390(35, v1 & -33);
    return 0;
}

// Address range: 0x449a8 - 0x449e0
int32_t function_449a8(void) {
    int32_t v1 = 0; // bp-12, 0x449bc
    function_40314(35, &v1);
    function_40390(35, v1 | 0x4000);
    return 0;
}

// Address range: 0x449e0 - 0x44a18
int32_t function_449e0(void) {
    int32_t v1 = 0; // bp-12, 0x449f4
    function_40314(35, &v1);
    function_40390(35, v1 & -0x4001);
    return 0;
}

// Address range: 0x44a18 - 0x44a50
int32_t function_44a18(void) {
    int32_t v1 = 0; // bp-12, 0x44a2c
    function_40314(35, &v1);
    function_40390(35, v1 | 0x2000);
    return 0;
}

// Address range: 0x44a50 - 0x44a88
int32_t function_44a50(void) {
    int32_t v1 = 0; // bp-12, 0x44a64
    function_40314(35, &v1);
    function_40390(35, v1 & -0x2001);
    return 0;
}

// Address range: 0x44a88 - 0x44ae4
int32_t function_44a88(void) {
    int32_t v1 = 0; // bp-16, 0x44a9c
    function_40314(27, &v1);
    int32_t v2 = v1 & -0x400001; // 0x44aac
    v1 = v2;
    function_40390(27, v2);
    int32_t v3 = 0; // bp-12, 0x44ac4
    function_40314(35, &v3);
    return function_40390(35, v3 & -65);
}

// Address range: 0x44ae4 - 0x44b54
int32_t function_44ae4(void) {
    int32_t v1 = 0; // bp-12, 0x44af8
    function_40314(13, &v1);
    function_40390(13, v1 | 0xffff);
    function_12030(3);
    function_40314(13, &v1);
    function_40390(13, v1 & -0x10000);
    function_12030(1);
    return function_444b8();
}

// Address range: 0x44b54 - 0x44bb0
int32_t function_44b54(int32_t * str, int32_t size) {
    int32_t v1 = 0; // bp-24, 0x44b70
    int32_t v2 = 0; // bp-20, 0x44b74
    function_40314(31, &v1);
    function_40314(32, &v2);
    return snprintf((char *)str, size, "%08x%08x", v2, v1);
}

// Address range: 0x44bb0 - 0x44bbc
int32_t function_44bb0(int32_t a1) {
    // 0x44bb0
    return function_40390(0, a1);
}

// Address range: 0x44bbc - 0x44bdc
int32_t function_44bbc(void) {
    // 0x44bbc
    int32_t result; // bp-12, 0x44bbc
    function_40314(41, &result);
    return result;
}

// Address range: 0x44bdc - 0x44c04
int32_t function_44bdc(int32_t a1) {
    // 0x44bdc
    function_40390(41, a1);
    int32_t v1; // bp-12, 0x44bdc
    return function_40314(41, &v1);
}

// Address range: 0x44c04 - 0x44c24
int32_t function_44c04(void) {
    // 0x44c04
    int32_t result; // bp-12, 0x44c04
    function_40314(39, &result);
    return result;
}

// Address range: 0x44c24 - 0x44c5c
int32_t function_44c24(int32_t a1) {
    // 0x44c24
    int32_t v1; // bp-12, 0x44c24
    function_40314(39, &v1);
    function_40390(39, a1);
    return function_40314(39, &v1);
}

// Address range: 0x44c5c - 0x44c84
int32_t function_44c5c(int32_t a1) {
    // 0x44c5c
    function_40390(20, a1);
    int32_t v1; // bp-12, 0x44c5c
    return function_40314(20, &v1);
}

// Address range: 0x44c84 - 0x44cb0
int32_t function_44c84(int32_t a1) {
    // 0x44c84
    function_40390(20, __asm_ubfx(a1, 0, 17) | -0x80000000);
    int32_t v1; // bp-12, 0x44c84
    return function_40314(20, &v1);
}

// Address range: 0x44cb0 - 0x44ccc
int32_t function_44cb0(void) {
    // 0x44cb0
    int32_t result; // bp-12, 0x44cb0
    function_40314(22, &result);
    return result;
}

// Address range: 0x44cce - 0x44cd0
int32_t function_44cce(void) {
    // 0x44cce
    int32_t result; // 0x44cce
    return result;
}

// Address range: 0x44cd0 - 0x44cf8
int32_t function_44cd0(int32_t a1) {
    // 0x44cd0
    function_40390(22, a1);
    int32_t v1; // bp-12, 0x44cd0
    return function_40314(22, &v1);
}

// Address range: 0x44cf8 - 0x44d04
int32_t function_44cf8(void) {
    // 0x44cf8
    return function_40390(33, 0x30000);
}

// Address range: 0x44d04 - 0x44d10
int32_t function_44d04(void) {
    // 0x44d04
    return function_40390(33, 0x10000);
}

// Address range: 0x44d10 - 0x44d30
int32_t function_44d10(void) {
    // 0x44d10
    int32_t v1; // bp-12, 0x44d10
    function_40314(33, &v1);
    return (uint32_t)v1 % 0x10000;
}

// Address range: 0x44d30 - 0x44d3c
int32_t function_44d30(void) {
    // 0x44d30
    return function_40390(33, 0);
}

// Address range: 0x44d3c - 0x44d60
int32_t function_44d3c(void) {
    // 0x44d3c
    int32_t v1; // bp-12, 0x44d3c
    function_40314(6, &v1);
    return __asm_ubfx(v1, 0, 15);
}

// Address range: 0x44d60 - 0x44d94
int32_t function_44d60(int32_t a1) {
    // 0x44d60
    int64_t v1; // bp-16, 0x44d60
    function_40314(4, (int32_t *)&v1);
    int32_t v2; // bp-12, 0x44d60
    int32_t result = function_40314(5, &v2); // 0x44d80
    uint64_t v3 = 0x100000000 * v1 >> 32; // 0x44d84
    *(int32_t *)a1 = (int32_t)(v3 / 0x100000000);
    *(int32_t *)(a1 + 4) = (int32_t)v3;
    return result;
}

// Address range: 0x44d94 - 0x44dfc
int32_t function_44d94(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    int64_t v2 = 0; // bp-24, 0x44dac
    int32_t v3 = 0; // bp-20, 0x44db0
    int64_t v4 = 0; // bp-16, 0x44db4
    int32_t v5 = 0; // bp-12, 0x44db8
    function_40314(4, (int32_t *)&v2);
    function_40314(5, &v3);
    function_40314(4, (int32_t *)&v4);
    function_40314(5, &v5);
    uint64_t v6 = 0x100000000 * v2 >> 32; // 0x44de4
    int32_t result = v6 / 0x100000000; // 0x44de4
    uint64_t v7 = 0x100000000 * v4 >> 32; // 0x44de8
    *a1 = result;
    *(int32_t *)(v1 + 4) = (int32_t)v6;
    *(int32_t *)(v1 + 8) = (int32_t)(v7 / 0x100000000);
    *(int32_t *)(v1 + 12) = (int32_t)v7;
    return result;
}

// Address range: 0x44dfc - 0x44e1c
int32_t function_44dfc(void) {
    // 0x44dfc
    int32_t result; // bp-12, 0x44dfc
    function_40314(21, &result);
    return result;
}

// Address range: 0x44e1c - 0x44e44
int32_t function_44e1c(char a1) {
    // 0x44e1c
    function_40390(21, (int32_t)a1);
    int32_t v1; // bp-12, 0x44e1c
    return function_40314(21, &v1);
}

// Address range: 0x44e44 - 0x44e64
int32_t function_44e44(void) {
    // 0x44e44
    int32_t result; // bp-12, 0x44e44
    function_40314(44, &result);
    return result;
}

// Address range: 0x44e64 - 0x44e8c
int32_t function_44e64(int32_t a1) {
    // 0x44e64
    function_40390(44, a1);
    int32_t v1; // bp-12, 0x44e64
    return function_40314(44, &v1);
}

// Address range: 0x44e8c - 0x44eac
int32_t function_44e8c(void) {
    // 0x44e8c
    int32_t result; // bp-12, 0x44e8c
    function_40314(42, &result);
    return result;
}

// Address range: 0x44eac - 0x44ed4
int32_t function_44eac(int32_t a1) {
    // 0x44eac
    function_40390(42, a1);
    int32_t v1; // bp-12, 0x44eac
    return function_40314(42, &v1);
}

// Address range: 0x44ed4 - 0x44ef4
int32_t function_44ed4(int32_t a1) {
    // 0x44ed4
    int32_t result; // bp-12, 0x44ed4
    function_40314(3, &result);
    return result;
}

// Address range: 0x44ef4 - 0x44f28
int32_t function_44ef4(uint32_t a1) {
    // 0x44ef4
    int32_t v1; // bp-12, 0x44ef4
    function_40314(3, &v1);
    return (v1 & 1 << a1) != 0;
}

// Address range: 0x44f28 - 0x44f48
int32_t function_44f28(void) {
    // 0x44f28
    int32_t result; // bp-12, 0x44f28
    function_40314(45, &result);
    return result;
}

// Address range: 0x44f48 - 0x4509c
int32_t function_44f48(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = 0; // 0x44f68
    uint32_t v2 = 0;
    int32_t v3; // bp-24, 0x44f48
    int32_t v4 = v1 + (int32_t)&v3; // 0x44f74
    if ((1 << v2 & a3) != 0) {
        *(char *)(v4 - 8) = (char)v2;
    }
    uint32_t v5 = v2 + 1; // 0x44f7c
    v1 += (int32_t)((1 << v2 & a3) != 0);
    while (v1 <= 7 && (v4 == 0 || v5 >= 31 == (v5 != 31)) != (v5 != 31 && v5 >= 31)) {
        // 0x44f6c
        v2 = v5;
        v4 = v1 + (int32_t)&v3;
        if ((1 << v2 & a3) != 0) {
            *(char *)(v4 - 8) = (char)v2;
        }
        v5 = v2 + 1;
        v1 += (int32_t)((1 << v2 & a3) != 0);
    }
    char v6; // 0x44f48
    if (a2 == 4) {
        // 0x45050
        function_40390(45, a1);
        int32_t v7 = a1 | 1; // 0x45068
        function_40390(57, v7);
        int32_t v8 = 1 << (int32_t)v6; // 0x4507c
        function_40390(58, v8 | a1);
        return function_40390(59, v8 | v7);
    }
    int32_t result = function_40390(45, a1);
    if (a2 != 8) {
        // 0x44fb0
        return result;
    }
    int32_t v9 = a1 | 1; // 0x44fdc
    function_40390(57, v9);
    int32_t v10 = 1 << (int32_t)v6; // 0x44ff0
    int32_t v11 = v10 | a1; // 0x44ff4
    int32_t v12 = v10 | v9; // 0x44ff8
    function_40390(58, v11);
    int32_t v13 = 1 << (int32_t)(unsigned char)v6; // 0x4500c
    function_40390(59, v13 | a1);
    function_40390(60, v12);
    function_40390(61, v13 | v9);
    function_40390(62, v11 | v13);
    return function_40390(63, v12 | v13);
}

// Address range: 0x4509c - 0x450bc
int32_t function_4509c(void) {
    // 0x4509c
    int32_t result; // bp-12, 0x4509c
    function_40314(46, &result);
    return result;
}

// Address range: 0x450bc - 0x450e4
int32_t function_450bc(int32_t a1) {
    // 0x450bc
    function_40390(46, a1);
    int32_t v1; // bp-12, 0x450bc
    return function_40314(46, &v1);
}

// Address range: 0x450e4 - 0x45104
int32_t function_450e4(void) {
    // 0x450e4
    int32_t result; // bp-12, 0x450e4
    function_40314(47, &result);
    return result;
}

// Address range: 0x45104 - 0x4512c
int32_t function_45104(int32_t a1) {
    // 0x45104
    function_40390(47, a1);
    int32_t v1; // bp-12, 0x45104
    return function_40314(47, &v1);
}

// Address range: 0x4512c - 0x45154
int32_t function_4512c(int32_t * a1) {
    int32_t v1 = (int32_t)a1 - 4; // 0x45134
    int32_t v2 = 48;
    int32_t v3 = v2 + 1; // 0x4513c
    v1 += 4;
    int32_t result = function_40390(v2, *(int32_t *)v1); // 0x45144
    while (v3 != 56) {
        // 0x45138
        v2 = v3;
        v3 = v2 + 1;
        v1 += 4;
        result = function_40390(v2, *(int32_t *)v1);
    }
    // 0x45150
    return result;
}

// Address range: 0x45154 - 0x4517c
int32_t function_45154(int32_t a1) {
    // 0x45154
    function_40390(36, a1);
    int32_t v1; // bp-12, 0x45154
    return function_40314(36, &v1);
}

// Address range: 0x4517c - 0x451c0
int32_t function_4517c(int32_t a1) {
    // 0x4517c
    int32_t v1; // bp-16, 0x4517c
    function_40314(36, &v1);
    function_40390(36, v1 & -256 | a1);
    int32_t v2; // bp-12, 0x4517c
    function_40314(36, &v2);
    return 0;
}

// Address range: 0x451c0 - 0x45204
int32_t function_451c0(int32_t a1) {
    // 0x451c0
    int32_t v1; // bp-16, 0x451c0
    function_40314(36, &v1);
    function_40390(36, v1 & -0xff01 | 256 * a1);
    int32_t v2; // bp-12, 0x451c0
    function_40314(36, &v2);
    return 0;
}

// Address range: 0x45204 - 0x45244
int32_t function_45204(int32_t a1) {
    // 0x45204
    int32_t v1; // bp-16, 0x45204
    function_40314(36, &v1);
    function_40390(36, (uint32_t)v1 % 0x10000 | 0x10000 * a1);
    int32_t v2; // bp-12, 0x45204
    function_40314(36, &v2);
    return 0;
}

// Address range: 0x45244 - 0x45288
int32_t function_45244(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    function_40390(37, v1);
    function_40390(38, *(int32_t *)(v1 + 4));
    int32_t v2; // bp-12, 0x45244
    function_40314(37, &v2);
    return function_40314(38, &v2);
}

// Address range: 0x45288 - 0x452b0
int32_t function_45288(uint32_t a1) {
    // 0x45288
    function_40390(40, a1 % 0x10000);
    int32_t v1; // bp-12, 0x45288
    return function_40314(40, &v1);
}

// Address range: 0x452b0 - 0x452d0
int32_t function_452b0(int32_t a1) {
    // 0x452b0
    int32_t result; // bp-12, 0x452b0
    function_40314(7, &result);
    return result;
}

// Address range: 0x452d0 - 0x452f8
int32_t function_452d0(int32_t a1) {
    // 0x452d0
    function_40390(7, a1);
    int32_t v1; // bp-12, 0x452d0
    return function_40314(7, &v1);
}

// Address range: 0x452f8 - 0x45334
int32_t function_452f8(void) {
    // 0x452f8
    int32_t v1; // bp-12, 0x452f8
    function_40314(7, &v1);
    function_40390(7, v1 | 0x10000);
    function_40314(7, &v1);
    return 0;
}

// Address range: 0x45334 - 0x45700
int32_t function_45334(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    int32_t v2; // bp-72, 0x45334
    memset(&v2, 0, 32);
    int32_t v3 = g135; // 0x45358
    uint32_t v4 = *(int32_t *)(v1 + 12); // 0x45360
    int32_t v5 = v4 & -64; // 0x45370
    uint32_t v6 = v4 % 64; // 0x45380
    int32_t v7 = v6 >= 55 == (v6 != 55) ? v5 + 128 : v5;
    int32_t v8 = v6 == 55 | v6 < 55 ? v7 + 64 : v7;
    int32_t v9 = function_11eb0(v8, 1, v3, v6); // 0x45394
    if (v9 == 0) {
        // 0x456e0
        return -4;
    }
    int32_t v10 = v3 == g136 ? g137 : v3;
    function_11fc4((int32_t *)v9, *(int32_t *)(v1 + 8), (char)v4, v6);
    int32_t v11 = llvm_bswap_i32(8 * v4); // 0x453bc
    int32_t v12 = v8 + v9; // 0x453c0
    *(char *)(v9 + v4) = -128;
    *(int32_t *)(v12 - 8) = 0;
    *(int32_t *)(v12 - 4) = v11;
    if (v8 != 0) {
        int32_t v13 = v9 - 1;
        int32_t v14 = v10 - 1; // 0x453e8
        int32_t v15 = v14; // 0x453f4
        int32_t v16 = v13; // 0x453f4
        v16++;
        v15++;
        *(char *)v15 = *(char *)v16;
        while (v8 + v13 != v16) {
            // 0x453f8
            v16++;
            v15++;
            *(char *)v15 = *(char *)v16;
        }
        int32_t v17 = v14; // 0x45424
        int32_t v18 = v13; // 0x45424
        int32_t v19 = 0;
        v17++;
        unsigned char v20 = *(char *)v17; // 0x45428
        v18++;
        if (v20 != *(char *)v18) {
            // 0x45448
            function_11f34("%s: coinbase_padding_in_ddr[%d] = 0x%x, but *(coinbase_padding + %d) = 0x%x", (int32_t *)"dhash_send_job", v19, (int32_t)v20);
        }
        int32_t v21 = v19 + 1; // 0x45458
        while (v8 + v14 != v17) {
            // 0x45428
            v19 = v21;
            v17++;
            v20 = *(char *)v17;
            v18++;
            if (v20 != *(char *)v18) {
                // 0x45448
                function_11f34("%s: coinbase_padding_in_ddr[%d] = 0x%x, but *(coinbase_padding + %d) = 0x%x", (int32_t *)"dhash_send_job", v19, (int32_t)v20);
            }
            // 0x45450
            v21 = v19 + 1;
        }
    }
    int32_t * v22 = (int32_t *)(v1 + 20); // 0x45460
    if (*v22 != 0) {
        int32_t v23 = 0; // 0x45474
        int32_t v24 = v8 + v10; // 0x45474
        int32_t v25 = *(int32_t *)(v1 + 16) + 32 * v23; // 0x45480
        v23++;
        *(int32_t *)v24 = *(int32_t *)v25;
        *(int32_t *)(v24 + 4) = *(int32_t *)(v25 + 4);
        *(int32_t *)(v24 + 8) = *(int32_t *)(v25 + 8);
        *(int32_t *)(v24 + 12) = *(int32_t *)(v25 + 12);
        *(int32_t *)(v24 + 16) = *(int32_t *)(v25 + 16);
        *(int32_t *)(v24 + 20) = *(int32_t *)(v25 + 20);
        *(int32_t *)(v24 + 24) = *(int32_t *)(v25 + 24);
        *(int32_t *)(v24 + 28) = *(int32_t *)(v25 + 28);
        uint32_t v26 = *v22; // 0x454c8
        v24 += 32;
        while (v26 >= v23 == (v26 != v23)) {
            // 0x45478
            v25 = *(int32_t *)(v1 + 16) + 32 * v23;
            v23++;
            *(int32_t *)v24 = *(int32_t *)v25;
            *(int32_t *)(v24 + 4) = *(int32_t *)(v25 + 4);
            *(int32_t *)(v24 + 8) = *(int32_t *)(v25 + 8);
            *(int32_t *)(v24 + 12) = *(int32_t *)(v25 + 12);
            *(int32_t *)(v24 + 16) = *(int32_t *)(v25 + 16);
            *(int32_t *)(v24 + 20) = *(int32_t *)(v25 + 20);
            *(int32_t *)(v24 + 24) = *(int32_t *)(v25 + 24);
            *(int32_t *)(v24 + 28) = *(int32_t *)(v25 + 28);
            v26 = *v22;
            v24 += 32;
        }
    }
    // 0x454d4
    function_444b8();
    int32_t v27 = v10 == g135 ? (int32_t)&g8 : g138 + (int32_t)&g14;
    function_40390(41, v27);
    int32_t v28; // bp-76, 0x45334
    function_40314(41, &v28);
    function_40390(44, *(int32_t *)(v1 + 32));
    int32_t v29 = function_40314(44, &v28); // 0x45518
    int32_t v30 = 1; // 0x45530
    if (v29 == 0) {
        v30 = *(int32_t *)(v1 + 4);
    }
    function_44f48(*(int32_t *)(v1 + 36), v30, *(int32_t *)(v1 + 40));
    memset(&v2, 0, 32);
    int32_t v31 = *(int32_t *)(v1 + 44); // 0x45548
    int32_t v32 = v31; // 0x45550
    int32_t v33 = &v28; // 0x45550
    unsigned char v34 = *(char *)(v32 + 2); // 0x45554
    unsigned char v35 = *(char *)(v32 + 3); // 0x4555c
    unsigned char v36 = *(char *)v32; // 0x45560
    unsigned char v37 = *(char *)(v32 + 1); // 0x45564
    v33 += 4;
    *(int32_t *)v33 = 0x1000000 * (int32_t)v35 | 0x10000 * (int32_t)v34 | (int32_t)v36 | 256 * (int32_t)v37;
    while (v32 != v31 + 28) {
        // 0x45554
        v32 += 4;
        v34 = *(char *)(v32 + 2);
        v35 = *(char *)(v32 + 3);
        v36 = *(char *)v32;
        v37 = *(char *)(v32 + 1);
        v33 += 4;
        *(int32_t *)v33 = 0x1000000 * (int32_t)v35 | 0x10000 * (int32_t)v34 | (int32_t)v36 | 256 * (int32_t)v37;
    }
    // 0x45584
    function_4512c(&v2);
    function_40390(46, *(int32_t *)(v1 + 24));
    function_40314(46, &v28);
    function_40390(47, *(int32_t *)(v1 + 28));
    function_40314(47, &v28);
    int32_t v38 = __asm_ubfx(v8, 6, 8); // 0x455c0
    int32_t v39 = *(int32_t *)(v1 + 52); // 0x455c4
    function_40390(36, 256 * *(int32_t *)(v1 + 56) & 0xff00 | v38 | 0x10000 * v39);
    function_40314(36, &v28);
    int32_t v40 = *(int32_t *)(v1 + 64); // 0x455f4
    v2 = v40;
    function_45244(&v2);
    function_45288(*v22);
    function_40390(42, (32 * *v22 + v8) % 0x10000);
    function_40314(42, &v28);
    usleep(1000);
    function_40390(20, __asm_ubfx(*(int32_t *)(v1 + 72), 0, 17) | -0x80000000);
    int32_t v41 = function_40314(20, &v28); // 0x4564c
    int32_t v42 = *(int32_t *)(v1 + 4); // 0x45650
    int32_t v43 = 0; // 0x45688
    if (*(int32_t *)(v1 + 76) != 0) {
        // 0x4568c
        function_452f8();
        v43 = 128;
    }
    int32_t v44 = v42 == 1 | v42 == 0 ? 0 : *(int32_t *)(v1 + 68);
    int32_t v45 = v41 == 0 ? v42 != 0 == (v42 != 1) ? 1 : v44 : 0;
    v28 = 0;
    function_40314(35, &v28);
    int32_t v46 = v45 == 0 ? v41 == 0 ? 0x8160 : 0xc160 : 256 * v42 & 3840 | 0x8060; // 0x456bc
    int32_t v47 = v43 | v46 | v28 & -0x8f61; // 0x456c4
    function_40390(35, v47);
    free(v9, v47, v40, v45);
    g136 = v10;
    // 0x456e0
    return 0;
}

// Address range: 0x45700 - 0x45730
int32_t function_45700(void) {
    // 0x45700
    int32_t v1; // 0x45700
    function_11f94(&g139, v1, v1, v1);
    int32_t v2; // bp-12, 0x45700
    function_40314(27, &v2);
    return function_11ea4(&g139, (int32_t)&v2, v1, v1);
}

// Address range: 0x45734 - 0x45784
int32_t function_45734(uint32_t a1) {
    // 0x45734
    int32_t v1; // 0x45734
    function_11f94(&g139, v1, v1, v1);
    usleep(0xc350);
    int32_t v2; // bp-20, 0x45734
    function_40314(27, &v2);
    function_445e0(v2 & -64 | a1 % 64);
    return function_11ea4(&g139, (int32_t)&v2, v1, v1);
}

// Address range: 0x45788 - 0x457dc
int32_t function_45788(int32_t a1, int32_t a2) {
    // 0x45788
    int32_t v1; // 0x45788
    function_11f94(&g139, a2, v1, v1);
    int32_t v2; // bp-20, 0x45788
    function_40314(27, &v2);
    int32_t v3 = v2 & -0xf0001 | 0x10000 * a1; // 0x457b8
    function_445e0(a2 == 0 ? v3 & -0xc00001 | 0x800000 : v3 | 0xc00000);
    return function_11ea4(&g139, (int32_t)&v2, v1, v1);
}

// Address range: 0x457e0 - 0x45878
int32_t function_457e0(int32_t a1, int32_t a2) {
    // 0x457e0
    int32_t v1; // 0x457e0
    int32_t v2 = function_11f94(&g139, a2, v1, v1); // 0x457f8
    function_40390(28, v2);
    function_40390(29, *(int32_t *)(a1 + 4));
    function_40390(30, *(int32_t *)(a1 + 8));
    int32_t v3; // bp-20, 0x457e0
    function_40314(28, &v3);
    function_40314(29, &v3);
    function_40314(30, &v3);
    function_40314(27, &v3);
    function_445e0(0x10000 * a2 | (int32_t)&g358 | -0x80000000 | v3 & 0x7ff0ffff);
    return function_11ea4(&g139, (int32_t)&v3, v1, v1);
}

// Address range: 0x4587c - 0x458c0
int32_t function_4587c(int32_t a1, uint32_t a2) {
    // 0x4587c
    int32_t v1; // 0x4587c
    function_11f94(&g140, a2, v1, v1);
    if (a2 < 4) {
        // 0x458b4
        return function_11ea4(&g140, a2, v1, v1);
    }
    int32_t v2 = a1; // 0x4589c
    int32_t v3 = *(int32_t *)v2; // 0x458a0
    v2 += 4;
    function_40390(16, v3);
    int32_t v4 = 17; // 0x458b0
    int32_t v5 = v3; // 0x458b0
    while (v2 != (a2 & -4) + a1) {
        // 0x458a0
        v3 = *(int32_t *)v2;
        v2 += 4;
        function_40390(v4, v3);
        v4 = 17;
        v5 = v3;
    }
    // 0x458b4
    return function_11ea4(&g140, v5, v1, v1);
}

// Address range: 0x458c4 - 0x458e4
int32_t function_458c4(void) {
    // 0x458c4
    int32_t result; // bp-12, 0x458c4
    function_40314(18, &result);
    return result;
}

// Address range: 0x458e4 - 0x45918
int32_t function_458e4(int32_t a1) {
    // 0x458e4
    function_40390(18, a1 | -0x7f7f8000);
    g136 = g135;
    return function_44c24(g138);
}

// Address range: 0x45918 - 0x45940
int32_t function_45918(void) {
    int32_t result = 0; // bp-12, 0x4592c
    function_40314(15, &result);
    return result;
}

// Address range: 0x45940 - 0x4594c
int32_t function_45940(int32_t a1) {
    // 0x45940
    return function_40390(15, a1);
}

// Address range: 0x4594c - 0x45990
int32_t function_4594c(uint32_t a1) {
    int32_t v1 = 0; // bp-12, 0x45964
    function_40314(13, &v1);
    int32_t v2 = v1 | 1 << a1; // 0x45978
    v1 = v2;
    return function_40390(13, v2);
}

// Address range: 0x45990 - 0x459d4
int32_t function_45990(uint32_t a1) {
    int32_t v1 = 0; // bp-12, 0x459a8
    function_40314(13, &v1);
    int32_t v2 = v1 & (-1 << a1) - 1; // 0x459bc
    v1 = v2;
    return function_40390(13, v2);
}

// Address range: 0x459d4 - 0x459f8
int32_t function_459d4(int32_t a1) {
    // 0x459d4
    function_4594c(a1);
    usleep(0x186a0);
    return function_45990(a1);
}

// Address range: 0x459f8 - 0x45a04
int32_t function_459f8(void) {
    // 0x459f8
    return usleep(0x186a0);
}

// Address range: 0x45a04 - 0x45a08
int32_t function_45a04(void) {
    // 0x45a04
    int32_t result; // 0x45a04
    return result;
}

// Address range: 0x45a08 - 0x45a0c
int32_t function_45a08(void) {
    // 0x45a08
    int32_t result; // 0x45a08
    return result;
}

// Address range: 0x45a0c - 0x45a34
int32_t function_45a0c(void) {
    int32_t v1 = 0; // bp-12, 0x45a1c
    function_40314(0, &v1);
    return v1 < 0;
}

// Address range: 0x45a34 - 0x45a8c
int32_t function_45a34(int32_t a1) {
    int32_t v1 = 0; // bp-12, 0x45a4c
    function_40314(0, &v1);
    int32_t v2 = v1; // 0x45a58
    if (a1 == 0) {
        float32_t v3 = fabsf((float32_t)v2);
        v1 = v3;
        // 0x45a6c
        function_40390(0, (int32_t)v3);
        return 0;
    }
    int32_t v4 = v2; // 0x45a68
    if (a1 == 1) {
        v4 = v2 | -0x80000000;
        v1 = v4;
    }
    // 0x45a6c
    function_40390(0, v4);
    return 0;
}

// Address range: 0x45a8c - 0x45acc
int32_t function_45a8c(void) {
    int32_t v1 = 0; // bp-12, 0x45aa0
    function_40314(0, &v1);
    int32_t v2 = v1 | 0x20000000; // 0x45ab0
    v1 = v2;
    function_40390(0, v2);
    return 0;
}

// Address range: 0x45acc - 0x45b0c
int32_t function_45acc(void) {
    int32_t v1 = 0; // bp-12, 0x45ae0
    function_40314(0, &v1);
    int32_t v2 = v1 & -0x20000001; // 0x45af0
    v1 = v2;
    function_40390(0, v2);
    return 0;
}

// Address range: 0x45b0c - 0x45b34
int32_t function_45b0c(void) {
    int32_t v1 = 0; // bp-12, 0x45b1c
    function_40314(0, &v1);
    return __asm_ubfx(v1, 29, 1);
}

// Address range: 0x45b34 - 0x45b74
int32_t function_45b34(void) {
    int32_t v1 = 0; // bp-12, 0x45b48
    function_40314(0, &v1);
    int32_t v2 = v1 | 0x40000000; // 0x45b58
    v1 = v2;
    function_40390(0, v2);
    return 0;
}

// Address range: 0x45b74 - 0x45c30
int32_t function_45b74(void) {
    // 0x45b74
    int32_t v1; // 0x45b74
    uint32_t v2 = v1;
    int32_t v3 = function_40408(); // 0x45b7c
    int32_t v4 = v3 + (int32_t)&g8; // 0x45b8c
    g134 = v3;
    g135 = v4;
    g137 = v3 + (int32_t)&g14;
    int32_t v5; // bp-80, 0x45b74
    int32_t v6 = sysinfo((struct sysinfo *)&v5); // 0x45ba0
    int32_t v7 = v2 >= 0x3b9aca00 == (v2 != 0x3b9aca00) ? 0x3f000000 : v6;
    int32_t v8; // 0x45b74
    if (v2 >= 0x3b9aca00 == (v2 != 0x3b9aca00)) {
        // .thread
        g138 = v7;
        v8 = 0x3f000000;
    } else {
        int32_t v9 = v2 >= 0x1dcd6500 == (v2 != 0x1dcd6500) ? 0x1f000000 : v7;
        if (v2 >= 0x1dcd6500 == (v2 != 0x1dcd6500)) {
            // .thread5
            g138 = v9;
            v8 = 0x1f000000;
        } else {
            bool v10 = v2 == 0xbebc200 | v2 < 0xbebc200; // 0x45be4
            int32_t v11 = v10 ? 0x7000000 : v2 >= 0xbebc200 == (v2 != 0xbebc200) ? 0xf000000 : v9;
            v8 = v11;
            if (v2 >= 0xbebc200 == (v2 != 0xbebc200) || v10) {
                g138 = v11;
                v8 = v11;
            }
        }
    }
    // 0x45bf8
    g136 = v4;
    function_44c24(v8);
    function_40390(41, (int32_t)&g8);
    int32_t v12; // bp-84, 0x45b74
    function_40314(41, &v12);
    function_45acc();
    function_45b34();
    return 0;
}

// Address range: 0x45c30 - 0x45c70
int32_t function_45c30(void) {
    int32_t v1 = 0; // bp-12, 0x45c44
    function_40314(0, &v1);
    int32_t v2 = v1 & -0x40000001; // 0x45c54
    v1 = v2;
    function_40390(0, v2);
    return 0;
}

// Address range: 0x45c70 - 0x45c98
int32_t function_45c70(void) {
    int32_t v1 = 0; // bp-12, 0x45c80
    function_40314(0, &v1);
    return __asm_ubfx(v1, 30, 1);
}

// Address range: 0x45c98 - 0x45cbc
int32_t function_45c98(int32_t a1) {
    int32_t result = 0; // bp-12, 0x45ca8
    function_40314(0, &result);
    return result;
}

// Address range: 0x45cbc - 0x45d30
int32_t function_45cbc(int32_t a1, int32_t a2) {
    // 0x45cbc
    int32_t v1; // 0x45cbc
    int32_t v2 = function_44540(a2, a2, v1, v1); // 0x45ccc
    int32_t v3 = 0; // bp-20, 0x45cdc
    function_40314(15, &v3);
    int32_t v4 = v3; // 0x45cbc
    switch (a1) {
        case 0: {
            // .thread
            v4 = __asm_bfieq(v3, v2, 0, 6);
            // break -> 0x45d04
            break;
        }
        case 1: {
            // .thread2
            v4 = __asm_bfieq(v3, v2, 8, 6);
            // break -> 0x45d04
            break;
        }
        case 2: {
            // .thread3
            v4 = __asm_bfieq(v3, v2, 16, 6);
            // break -> 0x45d04
            break;
        }
        case 3: {
            v4 = __asm_bfieq(v3, v2, 24, 6);
            // break -> 0x45d04
            break;
        }
    }
    // 0x45d04
    function_40390(15, v4);
    return 0;
}

// Address range: 0x45d30 - 0x45e30
int32_t function_45d30(int32_t a1) {
    int32_t v1 = 0; // bp-12, 0x45d48
    function_40314(15, &v1);
    int32_t result = -1; // 0x45d30
    int32_t v2; // 0x45d30
    int32_t v3; // 0x45d30
    switch (a1) {
        case 0: {
            int32_t v4 = v1 % 64; // 0x45d5c
            v2 = v4;
            if (v4 == 0) {
                // 0x45d98
                return &g25;
            }
            goto lab_0x45d64;
        }
        case 1: {
            int32_t v5 = __asm_ubfx(v1, 8, 6); // 0x45dd4
            v3 = v5;
            result = &g25;
            switch (v5) {
                case 0: {
                    return result;
                }
                case 1: {
                    // 0x45d98
                    return &g5;
                }
                default: {
                    goto lab_0x45d6c;
                }
            }
        }
        case 2: {
            int32_t v6 = __asm_ubfx(v1, 16, 6); // 0x45e18
            v2 = v6;
            if (v6 == 0) {
                // 0x45d98
                return &g25;
            }
            goto lab_0x45d64;
        }
        case 3: {
            int32_t v7 = __asm_ubfx(v1, 24, 6); // 0x45db8
            v2 = v7;
            if (v7 == 0) {
                // 0x45d98
                return &g25;
            }
            goto lab_0x45d64;
        }
        default: {
            return result;
        }
    }
  lab_0x45d64:
    // 0x45d64
    v3 = v2;
    if (v2 == 1) {
        // 0x45d98
        return &g5;
    }
    goto lab_0x45d6c;
  lab_0x45d6c:
    // 0x45d6c
    result = &g241;
    switch (v3) {
        case 3: {
            goto lab_0x45d98;
        }
        case 4: {
            // 0x45dc4
            result = 0xb71b00;
          lab_0x45d98:
            // 0x45d98
            return result;
        }
        default: {
            // 0x45d7c
            return v3 == 5 ? 0x17d7840 : 0x1c200;
        }
    }
}

// Address range: 0x45e30 - 0x45e80
int32_t function_45e30(void) {
    // 0x45e30
    int32_t v1; // 0x45e30
    uint32_t v2 = function_44540(v1, v1, v1, v1); // 0x45e38
    int32_t v3 = 0; // bp-20, 0x45e48
    function_40314(15, &v3);
    uint32_t v4 = v2 % 64; // 0x45e58
    int32_t v5 = __asm_bfi(__asm_bfi(__asm_bfi(v3, v4, 0, 6), v4, 8, 6), v4, 16, 6); // 0x45e68
    function_40390(15, __asm_bfi(v5, v4, 24, 6));
    return 0;
}

// Address range: 0x45e80 - 0x45ed0
int32_t function_45e80(int32_t a1) {
    // 0x45e80
    int32_t str; // bp-2056, 0x45e80
    snprintf((char *)&str, 2048, "%s: Bad pic param, input chain is %d\n", "open_pic", a1);
    function_2e584(0, &str, 0);
    return -0x7ffffdff;
}

// Address range: 0x45ed0 - 0x46024
int32_t function_45ed0(int32_t * a1, uint32_t a2) {
    int32_t v1 = (int32_t)a1;
    int32_t str; // bp-2072, 0x45ed0
    snprintf((char *)&str, 2048, "Dumping %u %s bytes from %p:\n", a2, "read return data", a1);
    function_2e584(2, &str, 0);
    int32_t v2 = 0; // 0x45f2c
    while (true) {
        uint32_t v3 = v2;
        if (v3 <= a2 == (v3 != a2)) {
            unsigned char v4 = *(char *)(v3 + v1); // 0x45f30
            int32_t v5 = v3 + 1; // 0x45f34
            snprintf((char *)&str, 2048, "%02x ", (int32_t)v4);
            function_2e584(2, &str, 0);
            v2 = v5;
            if (v5 == 16) {
                // break -> 0x45f88
                break;
            }
        } else {
            int32_t v6 = v3 + 1; // 0x45f74
            str = &g9;
            function_2e584(2, &str, 0);
            v2 = v6;
            if (v6 == 16) {
                // break -> 0x45f88
                break;
            }
        }
    }
    int32_t v7 = 0; // 0x45f98
    while (true) {
        uint32_t v8 = v7;
        if (v8 <= a2 == (v8 != a2)) {
            unsigned char v9 = *(char *)(v8 + v1); // 0x45f9c
            int32_t v10 = v8 + 1; // 0x45fa0
            uint32_t v11 = (int32_t)v9 - 32; // 0x45fa4
            snprintf((char *)&str, 2048, "%c", v11 >= 94 == (v11 != 94) ? 46 : v9);
            function_2e584(2, &str, 0);
            v7 = v10;
            if (v10 == 16) {
                // break -> 0x46000
                break;
            }
        } else {
            int32_t v12 = v8 + 1; // 0x45fec
            str = 32;
            function_2e584(2, &str, 0);
            v7 = v12;
            if (v12 == 16) {
                // break -> 0x46000
                break;
            }
        }
    }
    // 0x46000
    str = 10;
    return function_2e584(2, &str, 0);
}

// Address range: 0x46024 - 0x460c4
int32_t function_46024(uint32_t a1) {
    // 0x46024
    if (a1 >= 15 == (a1 != 15)) {
        // 0x460ac
        return function_45e80(a1);
    }
    int32_t v1 = 8 * a1; // 0x46040
    int32_t * v2 = (int32_t *)(v1 + (int32_t)&g460); // 0x46040
    int32_t result = *v2; // 0x46040
    if (result != 0) {
        // 0x4604c
        if (*(int32_t *)(v1 + (int32_t)&g460 + 4) != 0) {
            // 0x460ac
            return result;
        }
    }
    int32_t v3 = a1; // bp-24, 0x46074
    int32_t v4; // 0x46024
    function_11f94(&g141, v4, 0, 4);
    int32_t result2 = function_493d0(&v3); // 0x46084
    function_11ea4(&g141, v4, 0, 4);
    if (result2 >= 0) {
        *v2 = result2;
        *(int32_t *)(v1 + (int32_t)&g460 + 4) = 1;
    }
    // 0x460ac
    return result2;
}

// Address range: 0x460c4 - 0x46174
int32_t function_460c4(uint32_t result) {
    // 0x460c4
    if (result >= 15 == (result != 15)) {
        // 0x4613c
        int32_t str; // bp-2064, 0x460c4
        snprintf((char *)&str, 2048, "%s: Bad pic param, input chain is %d\n", "close_pic", result);
        return function_2e584(0, &str, 0);
    }
    int32_t v1 = 8 * result; // 0x460e0
    int32_t * v2 = (int32_t *)(v1 + (int32_t)&g460); // 0x460e8
    int32_t v3 = *v2; // 0x460e8
    int32_t * v4 = (int32_t *)(v1 + (int32_t)&g460 + 4);
    int32_t v5 = v3; // 0x460f0
    if (v3 == 0) {
        // 0x460f4
        v5 = *v4;
        if (v5 == 0) {
            // 0x46130
            return result;
        }
    }
    // 0x46104
    int32_t v6; // 0x460c4
    function_11f94(&g141, v6, v6, v5);
    function_49574(*v2);
    *v4 = 0;
    // 0x46130
    return function_11ea4(&g141, v6, v6, 0);
}

// Address range: 0x46178 - 0x46374
int32_t function_46178(uint32_t a1) {
    // 0x46178
    char v1; // 0x46178
    unsigned char v2 = v1;
    int32_t str; // bp-2072, 0x46178
    if (a1 >= 15 == (a1 != 15)) {
        // 0x4633c
        snprintf((char *)&str, 2048, "%s: Bad pic param, input chain is %d\n", "get_pic_version", a1);
        function_2e584(0, &str, 0);
        // 0x46274
        return -0x7ffffdff;
    }
    int32_t v3 = 8 * a1; // 0x46198
    if (*(int32_t *)(v3 + (int32_t)&g460 + 4) == 0) {
        int32_t result = function_46024(a1); // 0x46284
        if (result < 0) {
            // 0x46290
            snprintf((char *)&str, 2048, "%s: auto exec open_pic, but chain %d open eeprom failed\n", "get_pic_version", a1);
            function_2e584(0, &str, 0);
            // 0x46274
            return result;
        }
    }
    int32_t v4 = v3 + (int32_t)&g460; // 0x46198
    int32_t v5 = *(int32_t *)v4; // 0x461a8
    int32_t v6; // 0x46178
    function_11f94(&g141, v6, v6, v4);
    int32_t v7 = 0x1704aa55; // bp-2088, 0x461d8
    int32_t v8 = 0; // bp-2096, 0x461e4
    int32_t v9 = function_4966c(v5, &v7, 6); // 0x461f0
    int32_t format = 0x69bfc; // 0x46204
    int32_t v10; // 0x46178
    int32_t v11; // 0x46178
    int32_t result2; // 0x46178
    int32_t format2; // 0x46178
    if (v9 == 6) {
        // 0x46208
        usleep(0x493e0);
        int32_t v12 = function_495e4(v5, &v8, 5); // 0x46220
        format = (int32_t)"%s read iic err\n";
        if (v12 == 5) {
            // 0x4622c
            format2 = (int32_t)"%s failed!\n";
            if (v1 == 23) {
                // 0x46238
                format2 = (int32_t)"%s failed!\n";
                if (v8 % 256 == 5) {
                    // 0x46244
                    v10 = &v8;
                    v11 = 0;
                    result2 = 228;
                    format2 = (int32_t)"%s failed 2!\n";
                    if (v2 == -28 == ((int32_t)v2 + 28) / 256 == (int32_t)v1) {
                        goto lab_0x46268;
                    } else {
                        goto lab_0x46300;
                    }
                } else {
                    goto lab_0x46300;
                }
            } else {
                goto lab_0x46300;
            }
        } else {
            goto lab_0x462cc;
        }
    } else {
        goto lab_0x462cc;
    }
  lab_0x462cc:
    // 0x462cc
    snprintf((char *)&str, 2048, (char *)format);
    function_2e584(0, &str, 0);
    v10 = &str;
    v11 = (int32_t)"_bitmain_pic_get_sw_ver_common";
    result2 = -0x7ffffe00;
    goto lab_0x46268;
  lab_0x46268:
    // 0x46268
    function_11ea4(&g141, v10, 0, v11);
    // 0x46274
    return result2;
  lab_0x46300:
    // 0x46300
    snprintf((char *)&str, 2048, (char *)format2, "_bitmain_pic_get_sw_ver_common");
    function_2e584(0, &str, 0);
    function_45ed0(&v8, 5);
    v10 = 5;
    v11 = (int32_t)"_bitmain_pic_get_sw_ver_common";
    result2 = -0x7ffffe00;
    goto lab_0x46268;
}

// Address range: 0x4637c - 0x4654c
int32_t function_4637c(uint32_t a1) {
    // 0x4637c
    int32_t str; // bp-2072, 0x4637c
    if (a1 >= 15 == (a1 != 15)) {
        // 0x46514
        snprintf((char *)&str, 2048, "%s: Bad pic param, input chain is %d\n", "reset_pic", a1);
        function_2e584(0, &str, 0);
        // 0x46460
        return -0x7ffffdff;
    }
    int32_t v1 = 8 * a1; // 0x4639c
    if (*(int32_t *)(v1 + (int32_t)&g460 + 4) == 0) {
        int32_t result = function_46024(a1); // 0x46470
        if (result < 0) {
            // 0x4647c
            snprintf((char *)&str, 2048, "%s: auto exec open_pic, but chain %d open eeprom failed\n", "reset_pic", a1);
            function_2e584(0, &str, 0);
            // 0x46460
            return result;
        }
    }
    int32_t v2 = v1 + (int32_t)&g460; // 0x4639c
    int32_t v3 = *(int32_t *)v2; // 0x463ac
    int32_t v4; // 0x4637c
    function_11f94(&g141, v4, v4, v2);
    int32_t v5 = 0x704aa55; // bp-2088, 0x463e0
    int32_t v6 = 0; // bp-2092, 0x463ec
    int32_t v7 = function_4966c(v3, &v5, 6); // 0x463f4
    int32_t format = 0x69bfc; // 0x46408
    int32_t v8; // 0x4637c
    int32_t v9; // 0x4637c
    int32_t v10; // 0x4637c
    int32_t result2; // 0x4637c
    if (v7 == 6) {
        // 0x4640c
        usleep(0x493e0);
        int32_t v11 = function_495e4(v3, &v6, 2); // 0x46424
        format = (int32_t)"%s read iic err\n";
        if (v11 == 2) {
            uint32_t v12 = v6 % 256; // 0x46430
            v8 = 1;
            v9 = 2;
            v10 = 7;
            result2 = 0;
            char v13; // 0x4637c
            if (v13 == 1 == v12 == 7) {
                goto lab_0x46448;
            } else {
                // 0x464e0
                snprintf((char *)&str, 2048, "%s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n", "_bitmain_pic_reset_common", v12, (int32_t)v13);
                function_2e584(0, &str, 0);
                goto lab_0x464d4;
            }
        } else {
            goto lab_0x464b8;
        }
    } else {
        goto lab_0x464b8;
    }
  lab_0x464b8:
    // 0x464b8
    snprintf((char *)&str, 2048, (char *)format);
    function_2e584(0, &str, 0);
    goto lab_0x464d4;
  lab_0x464d4:
    // 0x464d4
    v8 = &str;
    v9 = 0;
    v10 = (int32_t)"_bitmain_pic_reset_common";
    result2 = -0x7ffffe00;
    goto lab_0x46448;
  lab_0x46448:
    // 0x46448
    function_11ea4(&g141, v8, v9, v10);
    usleep(0x7a120);
    // 0x46460
    return result2;
}

// Address range: 0x46554 - 0x46724
int32_t function_46554(uint32_t a1) {
    // 0x46554
    int32_t str; // bp-2072, 0x46554
    if (a1 >= 15 == (a1 != 15)) {
        // 0x466ec
        snprintf((char *)&str, 2048, "%s: Bad pic param, input chain is %d\n", "jump_from_loader_to_app", a1);
        function_2e584(0, &str, 0);
        // 0x46638
        return -0x7ffffdff;
    }
    int32_t v1 = 8 * a1; // 0x46574
    if (*(int32_t *)(v1 + (int32_t)&g460 + 4) == 0) {
        int32_t result = function_46024(a1); // 0x46648
        if (result < 0) {
            // 0x46654
            snprintf((char *)&str, 2048, "%s: auto exec open_pic, but chain %d open eeprom failed\n", "jump_from_loader_to_app", a1);
            function_2e584(0, &str, 0);
            // 0x46638
            return result;
        }
    }
    int32_t v2 = v1 + (int32_t)&g460; // 0x46574
    int32_t v3 = *(int32_t *)v2; // 0x46584
    int32_t v4; // 0x46554
    function_11f94(&g141, v4, v4, v2);
    int32_t v5 = 0x604aa55; // bp-2088, 0x465b8
    int32_t v6 = 0; // bp-2092, 0x465c4
    int32_t v7 = function_4966c(v3, &v5, 6); // 0x465cc
    int32_t format = 0x69bfc; // 0x465e0
    int32_t v8; // 0x46554
    int32_t v9; // 0x46554
    int32_t v10; // 0x46554
    int32_t result2; // 0x46554
    if (v7 == 6) {
        // 0x465e4
        usleep(0x493e0);
        int32_t v11 = function_495e4(v3, &v6, 2); // 0x465fc
        format = (int32_t)"%s read iic err\n";
        if (v11 == 2) {
            // 0x46608
            usleep(0x493e0);
            uint32_t v12 = v6 % 256; // 0x46614
            v8 = 1;
            v9 = 2;
            v10 = 6;
            result2 = 0;
            char v13; // 0x46554
            if (v13 == 1 == v12 == 6) {
                goto lab_0x4662c;
            } else {
                // 0x466b8
                snprintf((char *)&str, 2048, "%s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n", "_bitmain_pic_start_app_common", v12, (int32_t)v13);
                function_2e584(0, &str, 0);
                goto lab_0x466ac;
            }
        } else {
            goto lab_0x46690;
        }
    } else {
        goto lab_0x46690;
    }
  lab_0x46690:
    // 0x46690
    snprintf((char *)&str, 2048, (char *)format);
    function_2e584(0, &str, 0);
    goto lab_0x466ac;
  lab_0x466ac:
    // 0x466ac
    v8 = &str;
    v9 = 0;
    v10 = (int32_t)"_bitmain_pic_start_app_common";
    result2 = -0x7ffffe00;
    goto lab_0x4662c;
  lab_0x4662c:
    // 0x4662c
    function_11ea4(&g141, v8, v9, v10);
    // 0x46638
    return result2;
}

// Address range: 0x4672c - 0x468f8
int32_t function_4672c(uint32_t a1) {
    // 0x4672c
    int32_t str; // bp-2072, 0x4672c
    if (a1 >= 15 == (a1 != 15)) {
        // 0x468c0
        snprintf((char *)&str, 2048, "%s: Bad pic param, input chain is %d\n", "enable_dc_dc", a1);
        function_2e584(0, &str, 0);
        // 0x4680c
        return -0x7ffffdff;
    }
    int32_t v1 = 8 * a1; // 0x4674c
    if (*(int32_t *)(v1 + (int32_t)&g460 + 4) == 0) {
        int32_t result = function_46024(a1); // 0x4681c
        if (result < 0) {
            // 0x46828
            snprintf((char *)&str, 2048, "%s: auto exec open_pic, but chain %d open eeprom failed\n", "enable_dc_dc", a1);
            function_2e584(0, &str, 0);
            // 0x4680c
            return result;
        }
    }
    int32_t v2 = v1 + (int32_t)&g460; // 0x4674c
    int32_t v3 = *(int32_t *)v2; // 0x4675c
    int32_t v4; // 0x4672c
    function_11f94(&g141, v4, v4, v2);
    int32_t v5 = 0x1505aa55; // bp-2088, 0x46790
    int32_t v6 = 0; // bp-2092, 0x467a0
    int32_t v7 = function_4966c(v3, &v5, 7); // 0x467ac
    int32_t format = 0x69bfc; // 0x467c0
    int32_t v8; // 0x4672c
    int32_t v9; // 0x4672c
    int32_t v10; // 0x4672c
    int32_t result2; // 0x4672c
    if (v7 == 7) {
        // 0x467c4
        usleep(0x493e0);
        int32_t v11 = function_495e4(v3, &v6, 2); // 0x467dc
        format = (int32_t)"%s read iic err\n";
        if (v11 == 2) {
            uint32_t v12 = v6 % 256; // 0x467e8
            v8 = 1;
            v9 = 2;
            v10 = 21;
            result2 = 0;
            char v13; // 0x4672c
            if (v13 == 1 == v12 == 21) {
                goto lab_0x46800;
            } else {
                // 0x4688c
                snprintf((char *)&str, 2048, "%s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n", "_bitmain_pic_enable_dc_dc_common", v12, (int32_t)v13);
                function_2e584(0, &str, 0);
                goto lab_0x46880;
            }
        } else {
            goto lab_0x46864;
        }
    } else {
        goto lab_0x46864;
    }
  lab_0x46864:
    // 0x46864
    snprintf((char *)&str, 2048, (char *)format);
    function_2e584(0, &str, 0);
    goto lab_0x46880;
  lab_0x46880:
    // 0x46880
    v8 = &str;
    v9 = 0;
    v10 = (int32_t)"_bitmain_pic_enable_dc_dc_common";
    result2 = -0x7ffffe00;
    goto lab_0x46800;
  lab_0x46800:
    // 0x46800
    function_11ea4(&g141, v8, v9, v10);
    // 0x4680c
    return result2;
}

// Address range: 0x46900 - 0x46ac4
int32_t function_46900(uint32_t a1) {
    // 0x46900
    int32_t str; // bp-2072, 0x46900
    if (a1 >= 15 == (a1 != 15)) {
        // 0x46a8c
        snprintf((char *)&str, 2048, "%s: Bad pic param, input chain is %d\n", "disable_dc_dc", a1);
        function_2e584(0, &str, 0);
        // 0x469d8
        return -0x7ffffdff;
    }
    int32_t v1 = 8 * a1; // 0x46920
    if (*(int32_t *)(v1 + (int32_t)&g460 + 4) == 0) {
        int32_t result = function_46024(a1); // 0x469e8
        if (result < 0) {
            // 0x469f4
            snprintf((char *)&str, 2048, "%s: auto exec open_pic, but chain %d open eeprom failed\n", "disable_dc_dc", a1);
            function_2e584(0, &str, 0);
            // 0x469d8
            return result;
        }
    }
    int32_t v2 = v1 + (int32_t)&g460; // 0x46920
    int32_t v3 = *(int32_t *)v2; // 0x46930
    int32_t v4; // 0x46900
    function_11f94(&g141, v4, v4, v2);
    int32_t v5 = 0x1505aa55; // bp-2088, 0x46964
    int32_t v6 = 0; // bp-2092, 0x46970
    int32_t v7 = function_4966c(v3, &v5, 7); // 0x46978
    int32_t format = 0x69bfc; // 0x4698c
    int32_t v8; // 0x46900
    int32_t v9; // 0x46900
    int32_t v10; // 0x46900
    int32_t result2; // 0x46900
    if (v7 == 7) {
        // 0x46990
        usleep(0x493e0);
        int32_t v11 = function_495e4(v3, &v6, 2); // 0x469a8
        format = (int32_t)"%s read iic err\n";
        if (v11 == 2) {
            uint32_t v12 = v6 % 256; // 0x469b4
            v8 = 1;
            v9 = 2;
            v10 = 21;
            result2 = 0;
            char v13; // 0x46900
            if (v13 == 1 == v12 == 21) {
                goto lab_0x469cc;
            } else {
                // 0x46a58
                snprintf((char *)&str, 2048, "%s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n", "_bitmain_pic_disable_dc_dc_common", v12, (int32_t)v13);
                function_2e584(0, &str, 0);
                goto lab_0x46a4c;
            }
        } else {
            goto lab_0x46a30;
        }
    } else {
        goto lab_0x46a30;
    }
  lab_0x46a30:
    // 0x46a30
    snprintf((char *)&str, 2048, (char *)format);
    function_2e584(0, &str, 0);
    goto lab_0x46a4c;
  lab_0x46a4c:
    // 0x46a4c
    v8 = &str;
    v9 = 0;
    v10 = (int32_t)"_bitmain_pic_disable_dc_dc_common";
    result2 = -0x7ffffe00;
    goto lab_0x469cc;
  lab_0x469cc:
    // 0x469cc
    function_11ea4(&g141, v8, v9, v10);
    // 0x469d8
    return result2;
}

// Address range: 0x46acc - 0x46c98
int32_t function_46acc(uint32_t a1) {
    // 0x46acc
    int32_t str; // bp-2072, 0x46acc
    if (a1 >= 15 == (a1 != 15)) {
        // 0x46c60
        snprintf((char *)&str, 2048, "%s: Bad pic param, input chain is %d\n", "send_pic_heart_beat", a1);
        function_2e584(0, &str, 0);
        // 0x46ba8
        return -0x7ffffdff;
    }
    int32_t v1 = 8 * a1; // 0x46aec
    if (*(int32_t *)(v1 + (int32_t)&g460 + 4) == 0) {
        int32_t result = function_46024(a1); // 0x46bb8
        if (result < 0) {
            // 0x46bc4
            snprintf((char *)&str, 2048, "%s: auto exec open_pic, but chain %d open eeprom failed\n", "send_pic_heart_beat", a1);
            function_2e584(0, &str, 0);
            // 0x46ba8
            return result;
        }
    }
    int32_t v2 = v1 + (int32_t)&g460; // 0x46aec
    int32_t v3 = *(int32_t *)v2; // 0x46afc
    int32_t v4; // 0x46acc
    function_11f94(&g141, v4, v4, v2);
    int32_t v5 = 0x1604aa55; // bp-2088, 0x46b2c
    int32_t v6 = 0; // bp-2096, 0x46b38
    int32_t v7 = function_4966c(v3, &v5, 6); // 0x46b44
    int32_t format = 0x69bfc; // 0x46b5c
    int32_t v8; // 0x46acc
    int32_t v9; // 0x46acc
    int32_t v10; // 0x46acc
    int32_t result2; // 0x46acc
    if (v7 == 6) {
        // 0x46b60
        usleep(0x493e0);
        int32_t v11 = function_495e4(v3, &v6, 6); // 0x46b78
        format = (int32_t)"%s read iic err\n";
        if (v11 == 6) {
            // 0x46b84
            v8 = &v6;
            v9 = 6;
            v10 = 1;
            result2 = 0;
            char v12; // 0x46acc
            if (v12 == 1 != (v12 == 22)) {
                // 0x46c28
                snprintf((char *)&str, 2048, "%s failed!\n", "_bitmain_pic_heart_beat_common");
                function_2e584(0, &str, 0);
                function_45ed0(&v6, 6);
                v8 = 6;
                v9 = 0;
                v10 = (int32_t)"_bitmain_pic_heart_beat_common";
                result2 = -0x7ffffe00;
            }
            goto lab_0x46b9c;
        } else {
            goto lab_0x46c00;
        }
    } else {
        goto lab_0x46c00;
    }
  lab_0x46c00:
    // 0x46c00
    snprintf((char *)&str, 2048, (char *)format);
    function_2e584(0, &str, 0);
    v8 = &str;
    v9 = 0;
    v10 = (int32_t)"_bitmain_pic_heart_beat_common";
    result2 = -0x7ffffe00;
    goto lab_0x46b9c;
  lab_0x46b9c:
    // 0x46b9c
    function_11ea4(&g141, v8, v9, v10);
    // 0x46ba8
    return result2;
}

// Address range: 0x46ca0 - 0x46eb4
int32_t function_46ca0(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x46ca0
    char v1; // 0x46ca0
    unsigned char v2 = v1;
    function_11f94(&g141, a2, a3, a4);
    int32_t v3 = a5 < 16 ? a5 : 16;
    int32_t v4 = a2 + 59 + a3 + (a5 + 6) % 256; // 0x46cfc
    int16_t v5 = -0x55ab; // bp-2096, 0x46d0c
    int16_t v6 = 0; // bp-2100, 0x46d28
    int32_t v7; // 0x46ca0
    int32_t v8; // 0x46ca0
    char v9; // 0x46ca0
    char v10; // 0x46ca0
    int32_t v11; // 0x46ca0
    int32_t v12; // 0x46ca0
    int32_t v13; // 0x46ca0
    int32_t v14; // bp-24, 0x46ca0
    if (a5 > 0) {
        int32_t v15 = &v14;
        int32_t v16 = v15 - 2072;
        uint32_t v17 = 0; // 0x46d44
        int32_t v18 = 6;
        unsigned char v19 = *(char *)(v17 + a4); // 0x46d40
        v17 = (v17 + 1) % 0x10000;
        uint32_t v20 = v4 + (int32_t)v19; // 0x46d5c
        *(char *)(v18 + v16) = v19;
        int32_t v21 = (v18 + 1) % 0x10000; // 0x46d68
        int32_t v22 = v20 % 0x10000; // 0x46d6c
        while (v17 < v3) {
            // 0x46d3c
            v18 = v21;
            v19 = *(char *)(v17 + a4);
            v17 = (v17 + 1) % 0x10000;
            v20 = v22 + (int32_t)v19;
            *(char *)(v18 + v16) = v19;
            v21 = (v18 + 1) % 0x10000;
            v22 = v20 % 0x10000;
        }
        // 0x46d70
        v7 = v16;
        v8 = v15;
        v11 = (v18 + 2) % 0x10000;
        v12 = v21;
        v13 = (v18 + 3) % 0x10000;
        v9 = v20;
        v10 = v20 / 256;
    } else {
        int32_t v23 = &v14; // 0x46d8c
        v7 = v23 - 2072;
        v8 = v23;
        v11 = 7;
        v12 = 6;
        v13 = 8;
        v9 = v4;
        v10 = v4 / 256;
    }
    int32_t v24 = v12 + v8; // 0x46d90
    *(char *)(v24 - 2072) = v10;
    *(char *)(v11 + v7) = v9;
    int32_t v25 = function_4966c(a1, (int32_t *)&v5, v13); // 0x46db0
    int32_t format = (int32_t)"%s write iic err\n"; // 0x46db8
    int32_t v26; // 0x46ca0
    int32_t v27; // 0x46ca0
    int32_t v28; // 0x46ca0
    int32_t result; // 0x46ca0
    int32_t str; // bp-2072, 0x46ca0
    if (v25 == v13) {
        // 0x46dbc
        usleep(0x2710);
        int32_t v29 = function_495e4(a1, (int32_t *)&v6, 2); // 0x46dd0
        format = (int32_t)"%s read iic err\n";
        if (v29 == 2) {
            uint16_t v30 = v6 % 256;
            v26 = 59;
            v27 = 2;
            v28 = v24;
            result = v3;
            if (v2 == 1 != (v30 == 59)) {
                // 0x46e24
                snprintf((char *)&str, 2048, "%s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n", "_pic_write_iic", (int32_t)v30, (int32_t)v2);
                function_2e584(0, &str, 0);
                v26 = &str;
                v27 = 0;
                v28 = (int32_t)"_pic_write_iic";
                result = -0x7ffffe00;
            }
            goto lab_0x46df4;
        } else {
            goto lab_0x46e78;
        }
    } else {
        goto lab_0x46e78;
    }
  lab_0x46e78:
    // 0x46e78
    snprintf((char *)&str, 2048, (char *)format, "_pic_write_iic");
    function_2e584(0, &str, 0);
    v26 = &str;
    v27 = 0;
    v28 = (int32_t)"_pic_write_iic";
    result = -0x7ffffe00;
    goto lab_0x46df4;
  lab_0x46df4:
    // 0x46df4
    function_11ea4(&g141, v26, v27, v28);
    return result;
}

// Address range: 0x46eb4 - 0x46fe4
int32_t function_46eb4(int32_t a1) {
    // 0x46eb4
    int32_t v1; // 0x46eb4
    function_11f94(&g141, v1, v1, v1);
    int32_t v2 = 0x106aa55; // bp-2080, 0x46efc
    int32_t v3 = 0; // bp-2084, 0x46f00
    int32_t v4 = function_4966c(a1, &v2, 8); // 0x46f04
    int32_t format = 0x69bfc; // 0x46f18
    int32_t v5; // 0x46eb4
    int32_t v6; // 0x46eb4
    int32_t v7; // 0x46eb4
    int32_t result; // 0x46eb4
    int32_t str; // bp-2064, 0x46eb4
    if (v4 == 8) {
        // 0x46f1c
        usleep(0x493e0);
        int32_t v8 = function_495e4(a1, &v3, 2); // 0x46f34
        format = (int32_t)"%s read iic err\n";
        if (v8 == 2) {
            uint32_t v9 = v3 % 256; // 0x46f40
            v5 = 1;
            v6 = 2;
            v7 = 1;
            result = 0;
            char v10; // 0x46eb4
            if (v10 == 1 != (v9 == 1)) {
                // 0x46fa8
                snprintf((char *)&str, 2048, "%s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n", "_bitmain_pic_seek_1704", v9, (int32_t)v10);
                function_2e584(0, &str, 0);
                v5 = &str;
                v6 = 0;
                v7 = (int32_t)"_bitmain_pic_seek_1704";
                result = -0x7ffffe00;
            }
            goto lab_0x46f5c;
        } else {
            goto lab_0x46f80;
        }
    } else {
        goto lab_0x46f80;
    }
  lab_0x46f80:
    // 0x46f80
    snprintf((char *)&str, 2048, (char *)format);
    function_2e584(0, &str, 0);
    v5 = &str;
    v6 = 0;
    v7 = (int32_t)"_bitmain_pic_seek_1704";
    result = -0x7ffffe00;
    goto lab_0x46f5c;
  lab_0x46f5c:
    // 0x46f5c
    function_11ea4(&g141, v5, v6, v7);
    return result;
}

// Address range: 0x46fe8 - 0x47158
int32_t function_46fe8(int32_t a1, int32_t a2) {
    // 0x46fe8
    int32_t str; // bp-2080, 0x46fe8
    snprintf((char *)&str, 2048, "Dumping %u %s bytes from %p:\n", a2, "read return data", (int32_t *)a1);
    int32_t result = function_2e584(2, &str, 0); // 0x47030
    if (a2 < 1) {
        // 0x4714c
        return result;
    }
    uint32_t v1 = a2;
    int32_t v2 = 0; // 0x47050
    uint32_t v3; // 0x46fe8
    unsigned char v4; // 0x47054
    int32_t v5; // 0x47058
    int32_t v6; // 0x47098
    while (true) {
        // 0x47078
        v3 = v2;
        if (v1 >= v3 == (v1 != v3)) {
            // 0x47054
            v4 = *(char *)(v3 + a1);
            v5 = v3 + 1;
            snprintf((char *)&str, 2048, "%02x ", (int32_t)v4);
            function_2e584(2, &str, 0);
            v2 = v5;
            if (v5 == 16) {
                // break -> 0x470ac
                break;
            }
        } else {
            // 0x4708c
            v6 = v3 + 1;
            str = &g9;
            function_2e584(2, &str, 0);
            v2 = v6;
            if (v6 == 16) {
                // break -> 0x470ac
                break;
            }
        }
    }
    int32_t v7 = 0; // 0x470bc
    uint32_t v8; // 0x46fe8
    unsigned char v9; // 0x470c0
    int32_t v10; // 0x470c4
    uint32_t v11; // 0x470c8
    int32_t v12; // 0x47110
    while (true) {
        // 0x470f0
        v8 = v7;
        if (v1 >= v8 == (v1 != v8)) {
            // 0x470c0
            v9 = *(char *)(v8 + a1);
            v10 = v8 + 1;
            v11 = (int32_t)v9 - 32;
            snprintf((char *)&str, 2048, "%c", v11 >= 94 == (v11 != 94) ? 46 : v9);
            function_2e584(2, &str, 0);
            v7 = v10;
            if (v10 == 16) {
                // break -> 0x47124
                break;
            }
        } else {
            // 0x47104
            v12 = v8 + 1;
            str = 32;
            function_2e584(2, &str, 0);
            v7 = v12;
            if (v12 == 16) {
                // break -> 0x47124
                break;
            }
        }
    }
    // 0x47124
    str = 10;
    int32_t result2 = function_2e584(2, &str, 0); // 0x4713c
    int32_t v13 = v1 - 16; // 0x47148
    int32_t v14 = a1 + 16; // 0x47148
    while (v1 > 16) {
        int32_t v15 = v14;
        v1 = v13;
        int32_t v16 = 0; // 0x47050
        while (true) {
            // 0x47078
            v3 = v16;
            if (v1 >= v3 == (v1 != v3)) {
                // 0x47054
                v4 = *(char *)(v3 + v15);
                v5 = v3 + 1;
                snprintf((char *)&str, 2048, "%02x ", (int32_t)v4);
                function_2e584(2, &str, 0);
                v2 = v5;
                if (v5 == 16) {
                    // break -> 0x470ac
                    break;
                }
            } else {
                // 0x4708c
                v6 = v3 + 1;
                str = &g9;
                function_2e584(2, &str, 0);
                v2 = v6;
                if (v6 == 16) {
                    // break -> 0x470ac
                    break;
                }
            }
            // 0x47078
            v16 = v2;
        }
        int32_t v17 = 0; // 0x470bc
        while (true) {
            // 0x470f0
            v8 = v17;
            if (v1 >= v8 == (v1 != v8)) {
                // 0x470c0
                v9 = *(char *)(v8 + v15);
                v10 = v8 + 1;
                v11 = (int32_t)v9 - 32;
                snprintf((char *)&str, 2048, "%c", v11 >= 94 == (v11 != 94) ? 46 : v9);
                function_2e584(2, &str, 0);
                v7 = v10;
                if (v10 == 16) {
                    // break -> 0x47124
                    break;
                }
            } else {
                // 0x47104
                v12 = v8 + 1;
                str = 32;
                function_2e584(2, &str, 0);
                v7 = v12;
                if (v12 == 16) {
                    // break -> 0x47124
                    break;
                }
            }
            // 0x470f0
            v17 = v7;
        }
        // 0x47124
        str = 10;
        result2 = function_2e584(2, &str, 0);
        v13 = v1 - 16;
        v14 = v15 + 16;
    }
    // 0x4714c
    return result2;
}

// Address range: 0x47158 - 0x4751c
int32_t function_47158(uint32_t a1, int32_t * a2, int32_t a3) {
    // 0x47158
    char v1; // 0x47158
    unsigned char v2 = v1;
    int32_t str; // bp-2080, 0x47158
    if (a1 >= 15 == (a1 != 15)) {
        // 0x474a0
        snprintf((char *)&str, 2048, "%s: Bad pic param, input chain is %d\n", "pic_get_voltage", a1);
        function_2e584(0, &str, 0);
        // 0x4729c
        return -0x7ffffdff;
    }
    int32_t v3 = 8 * a1; // 0x47180
    if (*(int32_t *)(v3 + (int32_t)&g460 + 4) == 0) {
        int32_t result = function_46024(a1); // 0x472ac
        if (result < 0) {
            // 0x472b8
            snprintf((char *)&str, 2048, "%s: auto exec open_pic, but chain %d open eeprom failed\n", "pic_get_voltage", a1);
            function_2e584(0, &str, 0);
            // 0x4729c
            return result;
        }
    }
    int32_t v4 = (int32_t)a2;
    int32_t v5 = v3 + (int32_t)&g460; // 0x47180
    int32_t v6; // 0x47158
    int32_t format; // 0x47158
    int32_t v7; // 0x47158
    int32_t v8; // 0x47158
    int32_t v9; // 0x47158
    int32_t result2; // 0x47158
    int32_t v10; // bp-2092, 0x47158
    int32_t v11; // bp-2100, 0x47158
    int16_t v12; // 0x47158
    switch (a3) {
        case 3: {
            // 0x472e8
            function_11f94(&g141, v4, 3, v5);
            int32_t v13 = *(int32_t *)v5; // 0x472fc
            v11 = 0x3704aa55;
            v10 = 0;
            int32_t v14 = function_4966c(v13, &v11, 6); // 0x47330
            format = 0x69bfc;
            v9 = (int32_t)"_read_an_voltage";
            if (v14 == 6) {
                // 0x47348
                usleep(0x493e0);
                int32_t v15 = function_495e4(v13, &v10, 11); // 0x47360
                format = 0x69c10;
                v9 = (int32_t)"_read_an_voltage";
                if (v15 == 11) {
                    uint32_t v16 = v10 % 256; // 0x4737c
                    if (v1 == 55 == v16 == 11) {
                        int32_t v17 = &v10; // 0x473a4
                        v17++;
                        uint32_t v18 = 11 + (int32_t)*(char *)v17; // 0x473ac
                        uint32_t v19 = v18 % 0x10000; // 0x473b0
                        int32_t v20; // bp-2084, 0x47158
                        while (v17 != (int32_t)&v20) {
                            // 0x473a4
                            v17++;
                            v18 = v19 + (int32_t)*(char *)v17;
                            v19 = v18 % 0x10000;
                        }
                        // 0x473b8
                        format = (int32_t)"%s failed 2!\n";
                        v9 = (int32_t)"_read_an_voltage";
                        if (v1 == (char)v18 == v19 / 256 == (int32_t)v1) {
                            // 0x473d4
                            int32_t v21; // 0x47158
                            int32_t v22 = __asm_rev16(v21 % 0x10000) % 0x10000; // 0x473e8
                            int32_t v23 = __asm_rev16((int32_t)(256 * v12 >> 8)) % 0x10000; // 0x473f0
                            int32_t v24 = __asm_rev16(0) % 0x10000; // 0x473f4
                            *a2 = v22;
                            *(int32_t *)(v4 + 4) = v23;
                            *(int32_t *)(v4 + 8) = v24;
                            v6 = v22;
                            v7 = v23;
                            v8 = v24;
                            result2 = 11;
                            goto lab_0x47290;
                        } else {
                            goto lab_0x4740c;
                        }
                    } else {
                        // 0x474d8
                        snprintf((char *)&str, 2048, "%s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n", "_read_an_voltage", v16, (int32_t)v1);
                        function_2e584(0, &str, 0);
                        v6 = &str;
                        v7 = 0;
                        v8 = (int32_t)"_read_an_voltage";
                        result2 = -1;
                        goto lab_0x47290;
                    }
                } else {
                    goto lab_0x4740c;
                }
            } else {
                goto lab_0x4740c;
            }
        }
        case 1: {
            // 0x471a0
            function_11f94(&g141, v4, 1, v5);
            int32_t v25 = *(int32_t *)v5; // 0x471b4
            v10 = 0;
            v11 = 0x3a04aa55;
            int32_t v26 = function_4966c(v25, &v11, 6); // 0x471e4
            format = 0x69bfc;
            v9 = (int32_t)"_read_an6_voltage";
            if (v26 == 6) {
                // 0x471fc
                usleep(0x493e0);
                int32_t v27 = function_495e4(v25, &v10, 7); // 0x47214
                format = 0x69c10;
                v9 = (int32_t)"_read_an6_voltage";
                if (v27 == 7) {
                    uint32_t v28 = v10 % 256; // 0x47230
                    if (v1 == 1 == v1 == 58 == v28 == 7) {
                        uint32_t v29 = __asm_rev16(0); // 0x47270
                        format = (int32_t)"%s failed 2!\n";
                        v9 = (int32_t)"_read_an6_voltage";
                        if (v2 + 66 == v1 == ((int32_t)v2 + 66) / 256 == (int32_t)(v12 % 256)) {
                            int32_t v30 = v29 % 0x10000; // 0x47274
                            int32_t v31 = v1;
                            *a2 = v30;
                            v6 = v31;
                            v7 = v30;
                            v8 = v31;
                            result2 = 7;
                            goto lab_0x47290;
                        } else {
                            goto lab_0x4740c;
                        }
                    } else {
                        // 0x47430
                        snprintf((char *)&str, 2048, "%s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x, read_back_data[2] = 0x%02x\n\n", "_read_an6_voltage", v28, (int32_t)v1, (int32_t)v1);
                        function_2e584(0, &str, 0);
                        v6 = &str;
                        v7 = 0;
                        v8 = (int32_t)"_read_an6_voltage";
                        result2 = -1;
                        goto lab_0x47290;
                    }
                } else {
                    goto lab_0x4740c;
                }
            } else {
                goto lab_0x4740c;
            }
        }
        default: {
            // 0x4746c
            snprintf((char *)&str, 2048, "%s failed: parameters error!\n", "pic_get_voltage");
            function_2e584(0, &str, 0);
            // 0x4729c
            return -0x7ffffdff;
        }
    }
  lab_0x4740c:
    // 0x4740c
    snprintf((char *)&str, 2048, (char *)format);
    function_2e584(0, &str, 0);
    v6 = &str;
    v7 = 0;
    v8 = v9;
    result2 = -1;
    goto lab_0x47290;
  lab_0x47290:
    // 0x47290
    function_11ea4(&g141, v6, v7, v8);
    // 0x4729c
    return result2;
}

// Address range: 0x4752c - 0x477e4
int32_t function_4752c(uint32_t a1, int32_t a2, int32_t a3, int32_t a4, uint32_t a5) {
    // 0x4752c
    int32_t str; // bp-2088, 0x4752c
    if (a1 >= 15 == (a1 != 15)) {
        // 0x477ac
        snprintf((char *)&str, 2048, "%s: Bad pic param, input chain is %d\n", "app_write_data_into_flash", a1);
        function_2e584(0, &str, 0);
        // 0x476dc
        return -0x7ffffdff;
    }
    int32_t v1 = 8 * a1; // 0x47558
    if (*(int32_t *)(v1 + (int32_t)&g460 + 4) == 0) {
        int32_t result = function_46024(a1); // 0x476ec
        if (result < 0) {
            // 0x476f8
            snprintf((char *)&str, 2048, "%s: auto exec open_pic, but chain %d open eeprom failed\n", "app_write_data_into_flash", a1);
            function_2e584(0, &str, 0);
            // 0x476dc
            return result;
        }
    }
    int32_t v2 = v1 + (int32_t)&g460; // 0x47558
    int32_t v3 = *(int32_t *)v2; // 0x47570
    function_11f94(&g141, a2, a3, v2);
    int32_t v4 = a5 < 16 ? a5 : 16;
    int32_t v5 = a2 + 53 + a3 + (a5 + 6) % 256; // 0x475b8
    int16_t v6 = -0x55ab; // bp-2120, 0x475bc
    int16_t v7 = 0; // bp-2124, 0x475c0
    char v8 = v5; // 0x475e4
    char v9 = v5 / 256; // 0x475e4
    if (a5 >= 1) {
        int32_t v10 = (int32_t)&v6 + 6;
        int32_t v11 = a4 - 1; // 0x475f8
        uint32_t v12 = 0;
        v11++;
        char * v13 = (char *)v11; // 0x47620
        unsigned char v14 = *v13; // 0x47620
        int32_t v15 = v14; // 0x47620
        int32_t v16 = v15; // 0x47624
        if (v12 % 2 == 0) {
            // 0x47628
            v16 = v15;
            if (v14 != 63 && v14 >= 63) {
                // 0x47630
                snprintf((char *)&str, 2048, "%s: the data[%d] must less than 0x3f\n", "_app_write_data_into_flash_1704_v8", v12);
                function_2e584(0, &str, 0);
                v16 = (int32_t)*v13;
            }
        }
        uint32_t v17 = v16 + v5; // 0x47600
        int32_t v18 = v12 + 1; // 0x47608
        *(char *)(v10 + v12) = (char)v16;
        int32_t v19 = v17 % 0x10000; // 0x47618
        while (v4 > v18) {
            // 0x4761c
            v12 = v18;
            v11++;
            v13 = (char *)v11;
            v14 = *v13;
            v15 = v14;
            v16 = v15;
            if (v12 % 2 == 0) {
                // 0x47628
                v16 = v15;
                if (v14 != 63 && v14 >= 63) {
                    // 0x47630
                    snprintf((char *)&str, 2048, "%s: the data[%d] must less than 0x3f\n", "_app_write_data_into_flash_1704_v8", v12);
                    function_2e584(0, &str, 0);
                    v16 = (int32_t)*v13;
                }
            }
            // 0x475fc
            v17 = v16 + v19;
            v18 = v12 + 1;
            *(char *)(v10 + v12) = (char)v16;
            v19 = v17 % 0x10000;
        }
        // 0x47660
        v8 = v17;
        v9 = v17 / 256;
    }
    uint32_t v20 = (v4 + 8) % 0x10000; // 0x47674
    int32_t v21; // bp-40, 0x4752c
    int32_t v22 = (int32_t)&v21 - 2080;
    *(char *)(v22 + (v4 + 6) % 0x10000) = v9;
    *(char *)(v22 + (v4 + 7) % 0x10000) = v8;
    int32_t v23 = function_4966c(v3, (int32_t *)&v6, v20); // 0x47698
    int32_t format = (int32_t)"%s write iic 2 err\n"; // 0x476a0
    int32_t v24; // 0x4752c
    int32_t v25; // 0x4752c
    int32_t v26; // 0x4752c
    int32_t result2; // 0x4752c
    if (v23 == v20) {
        // 0x47728
        usleep(0x493e0);
        int32_t v27 = function_495e4(v3, (int32_t *)&v7, 2); // 0x47740
        format = (int32_t)"%s read iic 2 err\n";
        if (v27 == 2) {
            uint16_t v28 = v7 % 256;
            v24 = 1;
            v25 = 2;
            v26 = 53;
            result2 = v4;
            char v29; // 0x4752c
            if (v29 == 1 != (v28 == 53)) {
                // 0x47764
                snprintf((char *)&str, 2048, "%s failed 2! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n", "_app_write_data_into_flash_1704_v8", (int32_t)v28, (int32_t)v29);
                function_2e584(0, &str, 0);
                v24 = &str;
                v25 = 0;
                v26 = (int32_t)"_app_write_data_into_flash_1704_v8";
                result2 = 0;
            }
            goto lab_0x476d0;
        } else {
            goto lab_0x476b0;
        }
    } else {
        goto lab_0x476b0;
    }
  lab_0x476b0:
    // 0x476b0
    snprintf((char *)&str, 2048, (char *)format, "_app_write_data_into_flash_1704_v8");
    function_2e584(0, &str, 0);
    v24 = &str;
    v25 = 0;
    v26 = (int32_t)"_app_write_data_into_flash_1704_v8";
    result2 = 0;
    goto lab_0x476d0;
  lab_0x476d0:
    // 0x476d0
    function_11ea4(&g141, v24, v25, v26);
    // 0x476dc
    return result2;
}

// Address range: 0x477ec - 0x47abc
int32_t function_477ec(uint32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t str; // bp-2088, 0x477ec
    if (a1 >= 15 == (a1 != 15)) {
        // 0x47a70
        snprintf((char *)&str, 2048, "%s: Bad pic param, input chain is %d\n", "app_read_data_from_flash", a1);
        function_2e584(0, &str, 0);
        // 0x478e4
        return -0x7ffffdff;
    }
    int32_t v1 = 8 * a1; // 0x47818
    if (*(int32_t *)(v1 + (int32_t)&g460 + 4) == 0) {
        int32_t result = function_46024(a1); // 0x478f4
        if (result < 0) {
            // 0x47900
            snprintf((char *)&str, 2048, "%s: auto exec open_pic, but chain %d open eeprom failed\n", "app_read_data_from_flash", a1);
            function_2e584(0, &str, 0);
            // 0x478e4
            return result;
        }
    }
    int32_t v2 = v1 + (int32_t)&g460; // 0x47818
    int32_t size = a5 + 5; // 0x47830
    int32_t v3 = *(int32_t *)v2; // 0x47838
    function_11f94(&g141, a2, a3, v2);
    int32_t * mem = malloc(size); // 0x47844
    int32_t v4 = (int32_t)mem; // 0x47844
    int32_t v5 = 0x3607aa55; // bp-2100, 0x47864
    int32_t v6 = function_4966c(v3, &v5, 9); // 0x47898
    int32_t format = (int32_t)"%s write iic 2 err\n"; // 0x478a0
    int32_t v7; // 0x477ec
    int32_t result2; // 0x477ec
    int32_t v8; // 0x477ec
    if (v6 == 9) {
        // 0x47930
        usleep(0x493e0);
        format = (int32_t)"%s read iic 2 err\n";
        if (size == function_495e4(v3, mem, size)) {
            unsigned char v9 = *(char *)(v4 + 1); // 0x47954
            int32_t v10 = v9; // 0x47954
            int32_t v11 = (int32_t)*(char *)mem; // 0x47958
            unsigned char v12 = *(char *)(v4 + 2); // 0x4795c
            if (size == v11 == v9 == 54 == v12 == 1) {
                int32_t v13 = a5 + 3; // 0x479d4
                int32_t v14 = v13 < 1 ? 0 : v10;
                int32_t v15 = v14; // 0x479e4
                int32_t v16 = v14; // 0x479e4
                if (v13 > 0) {
                    int32_t v17 = 1; // 0x47a0c
                    int32_t v18 = 3; // 0x47a0c
                    if (v13 != 1) {
                        uint32_t v19 = (v17 + 1) % 0x10000; // 0x47a00
                        int32_t v20 = (size + (int32_t)*(char *)(v17 + v4)) % 0x10000; // 0x47a04
                        int32_t v21 = v20; // 0x47a0c
                        v17 = v19;
                        v18 = v20;
                        while (v19 < v13) {
                            // 0x479f4
                            v19 = (v17 + 1) % 0x10000;
                            v20 = (v21 + (int32_t)*(char *)(v17 + v4)) % 0x10000;
                            v21 = v20;
                            v17 = v19;
                            v18 = v20;
                        }
                    }
                    // 0x47a10
                    v15 = v18;
                    v16 = v15 / 256;
                }
                int32_t v22 = size + v4; // 0x47a14
                if (v16 == (int32_t)*(char *)(v22 - 2)) {
                    int32_t v23 = (int32_t)*(char *)(v22 - 1); // 0x47a24
                    if (v15 % 256 == v23) {
                        int32_t v24 = a5 < 16 ? a5 : 16;
                        int32_t v25 = v4 + 3; // 0x47ab0
                        function_11fc4((int32_t *)a4, v25, (char)v24, v23);
                        v7 = v25;
                        result2 = v24;
                        v8 = v23;
                        goto lab_0x478d0;
                    } else {
                        goto lab_0x47a34;
                    }
                } else {
                    goto lab_0x47a34;
                }
            } else {
                // 0x47974
                snprintf((char *)&str, 2048, "%s failed !\n read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x\n", "_app_read_data_from_flash_1704_v8", v11, v10, (int32_t)v12);
                function_2e584(0, &str, 0);
                function_46fe8(v4, size);
                v7 = size;
                result2 = 0;
                v8 = (int32_t)"_app_read_data_from_flash_1704_v8";
                goto lab_0x478d0;
            }
        } else {
            goto lab_0x478b0;
        }
    } else {
        goto lab_0x478b0;
    }
  lab_0x478b0:
    // 0x478b0
    snprintf((char *)&str, 2048, (char *)format, "_app_read_data_from_flash_1704_v8");
    function_2e584(0, &str, 0);
    v7 = &str;
    result2 = 0;
    v8 = (int32_t)"_app_read_data_from_flash_1704_v8";
    goto lab_0x478d0;
  lab_0x478d0:
    // 0x478d0
    free(v4, v7, result2, v8);
    function_11ea4(&g141, v7, result2, v8);
    // 0x478e4
    return result2;
  lab_0x47a34:
    // 0x47a34
    snprintf((char *)&str, 2048, "%s failed 2!\n", "_app_read_data_from_flash_1704_v8");
    function_2e584(0, &str, 0);
    function_46fe8(v4, size);
    v7 = size;
    result2 = 0;
    v8 = (int32_t)"_app_read_data_from_flash_1704_v8";
    goto lab_0x478d0;
}

// Address range: 0x47ac4 - 0x480fc
int32_t function_47ac4(uint32_t a1, int32_t a2) {
    // 0x47ac4
    char v1; // 0x47ac4
    unsigned char v2 = v1;
    int32_t str; // bp-5032, 0x47ac4
    if (a1 >= 15 == (a1 != 15)) {
        // 0x480bc
        snprintf((char *)&str, 2048, "%s: Bad pic param, input chain is %d\n", "upgrade_pic", a1);
        function_2e584(0, &str, 0);
        // 0x47f44
        return -0x7ffffdff;
    }
    int32_t v3 = 8 * a1; // 0x47ae8
    if (*(int32_t *)(v3 + (int32_t)&g460 + 4) == 0) {
        int32_t result = function_46024(a1); // 0x47af8
        if (result < 0) {
            // 0x47fd8
            snprintf((char *)&str, 2048, "%s: auto exec open_pic, but chain %d open eeprom failed\n", "upgrade_pic", a1);
            function_2e584(0, &str, 0);
            return result;
        }
    }
    // 0x47b04
    memset(&str, 0, 0x1388);
    int32_t v4 = *(int32_t *)(v3 + (int32_t)&g460); // 0x47b44
    int32_t str3 = 0; // bp-7136, 0x47b4c
    int32_t str2; // bp-7080, 0x47ac4
    snprintf((char *)&str2, 2048, "%s\n");
    function_2e584(2, &str2, 0);
    char * v5 = (char *)a2; // 0x47b74
    struct _IO_FILE * stream = fopen64(v5, "r"); // 0x47b74
    int32_t v6 = (int32_t)stream; // 0x47b74
    if (stream == NULL) {
        // 0x48084
        snprintf((char *)&str2, 2048, "%s: open %s failed\n", "_update_pic_app_program_1704", v5);
        function_2e584(v6, &str2, v6);
        // 0x47f44
        return -0x7ffffe00;
    }
    // 0x47b80
    fseek(stream, 0, SEEK_SET);
    memset(&str, 0, 0x1388);
    snprintf((char *)&str2, 2048, "%s: pic_flash_length = %d\n", "_update_pic_app_program_1704", 2432);
    function_2e584(2, &str2, 0);
    int32_t v7 = &str;
    int32_t v8 = v7 + 2; // 0x47bec
    function_11f88(&str3, 1023, v6);
    uint32_t str_as_ul = strtoul((char *)&str3, NULL, 16); // 0x47c00
    uint32_t v9 = str_as_ul / 256; // 0x47c04
    *(char *)(v7 | 1) = (char)str_as_ul;
    *(char *)v7 = (char)v9;
    int32_t v10; // bp-168, 0x47ac4
    while (v8 != (int32_t)&v10) {
        // 0x47be0
        v7 = v8;
        v8 = v7 + 2;
        function_11f88(&str3, 1023, v6);
        str_as_ul = strtoul((char *)&str3, NULL, 16);
        v9 = str_as_ul / 256;
        *(char *)(v7 | 1) = (char)str_as_ul;
        *(char *)v7 = (char)v9;
    }
    // 0x47c18
    fclose(stream);
    int32_t v11 = function_4637c(a1); // 0x47c24
    int32_t format2 = (int32_t)"%s: reset pic error!\n\n"; // 0x47c2c
    int32_t result2 = v11; // 0x47c2c
    int32_t v12; // 0x47ac4
    int32_t v13; // 0x47ac4
    int32_t v14; // 0x47ac4
    int16_t v15; // bp-7108, 0x47ac4
    int32_t v16; // bp-7112, 0x47ac4
    int32_t v17; // bp-7140, 0x47ac4
    if (v11 == 0) {
        int32_t v18 = function_46eb4(v4); // 0x47c34
        if (v18 == 0) {
            // 0x47c40
            function_11f94(&g141, 0, 16, v9);
            v16 = 0x404aa55;
            v15 = 0;
            v17 = 0;
            if (function_4966c(v4, &v16, 6) == 6) {
                // 0x47c88
                usleep(0x493e0);
                if (function_495e4(v4, &v17, 2) == 2) {
                    // 0x47cac
                    usleep(0x493e0);
                    uint32_t v19 = v17 % 256; // 0x47cb8
                    v12 = 4;
                    v13 = 2;
                    v14 = 1;
                    if (v2 == 1 == v19 == 4) {
                        goto lab_0x47cd0;
                    } else {
                        // 0x4801c
                        snprintf((char *)&str2, 2048, "%s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n", "_bitmain_pic_erase_1704", v19, (int32_t)v2);
                        goto lab_0x48038;
                    }
                } else {
                    // 0x48068
                    snprintf((char *)&str2, 2048, "%s read iic err\n", "_bitmain_pic_erase_1704");
                    goto lab_0x48038;
                }
            } else {
                // 0x4804c
                snprintf((char *)&str2, 2048, "%s write iic err\n", "_bitmain_pic_erase_1704");
                goto lab_0x48038;
            }
        } else {
            // 0x47ef4
            snprintf((char *)&str2, 2048, "%s set 1704 flash pointer err\n", "_erase_pic_app");
            function_2e584(0, &str2, 0);
            format2 = (int32_t)"%s: erase app flash error!\n\n";
            result2 = v18;
            goto lab_0x47f28;
        }
    } else {
        goto lab_0x47f28;
    }
  lab_0x47f60:;
    // 0x47f60
    int32_t format; // 0x47ac4
    snprintf((char *)&str2, 2048, (char *)format);
    function_2e584(0, &str2, 0);
    goto lab_0x47ec0;
  lab_0x47ec0:;
    // 0x47ec0
    int32_t v20; // 0x47ac4
    int32_t v21 = v20 + 1; // 0x47ec0
    int32_t v22; // 0x47ac4
    function_11ea4(&g141, v22, 0, (int32_t)"_bitmain_pic_write_1704");
    v20 = v21;
    if (v21 == 304) {
        // break -> 0x47ed4
        goto lab_0x47ed4;
    }
    goto lab_0x47d04;
  lab_0x47f90:;
    // 0x47f90
    int32_t v31; // 0x47ac4
    snprintf((char *)&str2, 2048, (char *)(int32_t)"%s failed 1! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n", "_bitmain_pic_write_1704", v31, (int32_t)v2);
    function_2e584(0, &str2, 0);
    goto lab_0x47ec0;
  lab_0x47f28:
    // 0x47f28
    snprintf((char *)&str2, 2048, (char *)format2, "_update_pic_app_program_1704");
    function_2e584(0, &str2, 0);
    // 0x47f44
    return result2;
  lab_0x48038:
    // 0x48038
    function_2e584(0, &str2, 0);
    v12 = &str2;
    v13 = 0;
    v14 = (int32_t)"_bitmain_pic_erase_1704";
    goto lab_0x47cd0;
  lab_0x47cd0:
    // 0x47cd0
    function_11ea4(&g141, v12, v13, v14);
    int32_t v36 = function_46eb4(v4); // 0x47ce0
    format2 = (int32_t)"%s: set 1704 flash pointer err!\n\n";
    result2 = v36;
    if (v36 == 0) {
        // 0x47d04
        v22 = &str2;
        int32_t v24 = &v15;
        v20 = 0;
        while (true) {
          lab_0x47d04:
            // 0x47d04
            snprintf((char *)&str2, 2048, "send pic program time: %d", v20);
            function_2e584(2, &str2, 0);
            function_11f94(&g141, v22, 0, v20);
            v17 = 0;
            v15 = 0;
            v16 = 0x214aa55;
            int32_t v23 = v24; // 0x47d90
            int32_t v25; // bp-7129, 0x47ac4
            int32_t v26 = &v25; // 0x47d90
            v26++;
            *(char *)v23 = *(char *)v26;
            v23++;
            int32_t v27; // bp-7113, 0x47ac4
            while (v26 != (int32_t)&v27) {
                // 0x47d94
                v26++;
                *(char *)v23 = *(char *)v26;
                v23++;
            }
            int32_t v28 = function_4966c(v4, &v16, 22); // 0x47dc4
            format = 0x6a04c;
            if (v28 == 22) {
                // 0x47ddc
                usleep(0x493e0);
                int32_t v29 = function_495e4(v4, &v17, 2); // 0x47df4
                format = (int32_t)"%s read iic 1 err\n";
                if (v29 == 2) {
                    int32_t v30 = v17 % 256; // 0x47e00
                    v31 = v30;
                    if (v2 == 1 == v30 == 2) {
                        // 0x47e18
                        v16 = 0x504aa55;
                        v15 = 2304;
                        int32_t v32 = function_4966c(v4, &v16, 6); // 0x47e34
                        format = 0x69eb8;
                        if (v32 == 6) {
                            // 0x47e4c
                            usleep(0x493e0);
                            int32_t v33 = function_495e4(v4, &v17, 2); // 0x47e64
                            format = 0x69ecc;
                            if (v33 == 2) {
                                uint32_t v34 = v17; // 0x47e80
                                int32_t v35 = v34 % 256; // 0x47e80
                                v31 = v35;
                                if (v35 == 5) {
                                    // 0x47e98
                                    snprintf((char *)&str2, 2048, "%s  success write to pic flash\n", "_bitmain_pic_write_1704");
                                    function_2e584(2, &str2, 0);
                                    goto lab_0x47ec0;
                                } else {
                                    goto lab_0x47f90;
                                }
                            } else {
                                goto lab_0x47f60;
                            }
                        } else {
                            goto lab_0x47f60;
                        }
                    } else {
                        goto lab_0x47f90;
                    }
                } else {
                    goto lab_0x47f60;
                }
            } else {
                goto lab_0x47f60;
            }
        }
      lab_0x47ed4:;
        int32_t v37 = function_4637c(a1); // 0x47ed8
        format2 = (int32_t)"%s: reset pic error!\n\n";
        result2 = v37;
        if (v37 == 0) {
            // 0x47f44
            return 0;
        }
    }
    goto lab_0x47f28;
}

// Address range: 0x48110 - 0x48430
int32_t function_48110(uint32_t a1, char a2, int32_t a3, int32_t * a4, int32_t a5) {
    // 0x48110
    char v1; // 0x48110
    unsigned char v2 = v1;
    int32_t str; // bp-2088, 0x48110
    if (a1 >= 15 == (a1 != 15)) {
        // 0x483e4
        snprintf((char *)&str, 2048, "%s: Bad pic param, input chain is %d\n", "pic_read_iic", a1);
        function_2e584(0, &str, 0);
        // 0x4822c
        return -0x7ffffdff;
    }
    int32_t v3 = 8 * a1; // 0x4813c
    if (*(int32_t *)(v3 + (int32_t)&g460 + 4) == 0) {
        int32_t result = function_46024(a1); // 0x4823c
        if (result < 0) {
            // 0x48248
            snprintf((char *)&str, 2048, "%s: auto exec open_pic, but chain %d open eeprom failed\n", "pic_read_iic", a1);
            function_2e584(0, &str, 0);
            // 0x4822c
            return result;
        }
    }
    int32_t v4 = a2;
    int32_t * v5 = (int32_t *)(v3 + (int32_t)&g460); // 0x48154
    int32_t result2 = function_46ca0(*v5, v4, a3, 0, 0); // 0x48168
    if (result2 < 0) {
        // 0x482f4
        snprintf((char *)&str, 2048, "%s: select slave: 0x%02x, reg/command: 0x%02x is failed", "pic_read_iic", v4, a3);
        function_2e584(0, &str, 0);
        return result2;
    }
    // 0x48174
    usleep(0x2710);
    int32_t v6 = *v5; // 0x48180
    function_11f94(&g141, v4, a3, 0);
    int32_t v7 = 0; // bp-2112, 0x481c4
    int32_t v8 = 0x3c06aa55; // bp-2120, 0x481e4
    int32_t v9 = function_4966c(v6, &v8, 8); // 0x481e8
    int32_t format = (int32_t)"%s write iic err\n"; // 0x481f0
    int32_t v10; // 0x48110
    int32_t result3; // 0x48110
    int32_t v11; // 0x48110
    if (v9 == 8) {
        int32_t v12 = a5 < 16 ? a5 : 16;
        int32_t v13 = v12 + 5; // 0x48278
        usleep(0x2710);
        int32_t v14 = function_495e4(v6, &v7, v13); // 0x48290
        format = (int32_t)"%s read iic err\n";
        if (v13 == v14) {
            uint32_t v15 = v7 % 256; // 0x4829c
            if (v2 == 1 == v1 == 60 == v13 == v15) {
                int32_t v16 = v12 + 3; // 0x4834c
                int32_t v17 = 0; // 0x48358
                int32_t v18 = 0; // 0x48358
                int32_t v19; // bp-40, 0x48110
                if (v16 > 0) {
                    // 0x48364
                    v17 = 3;
                    v18 = 0;
                    if (v16 != 1) {
                        uint32_t v20 = 1; // 0x4836c
                        unsigned char v21 = *(char *)((int32_t)&v19 - 2072 + v20); // 0x48360
                        uint32_t v22 = v13 + (int32_t)v21; // 0x48368
                        v20 = (v20 + 1) % 0x10000;
                        uint32_t v23 = v22 % 0x10000; // 0x48374
                        while (v20 < v16) {
                            // 0x48360
                            v21 = *(char *)((int32_t)&v19 - 2072 + v20);
                            v22 = v23 + (int32_t)v21;
                            v20 = (v20 + 1) % 0x10000;
                            v23 = v22 % 0x10000;
                        }
                        // 0x48384
                        v17 = v22 % 256;
                        v18 = v23 / 256;
                    }
                }
                int32_t v24 = v12 + (int32_t)&v19;
                if (v18 == (int32_t)*(char *)(v24 - 2069)) {
                    // 0x4839c
                    if (v17 == (int32_t)*(char *)(v24 - 2068)) {
                        // 0x4841c
                        int32_t v25; // bp-2109, 0x48110
                        int32_t v26 = &v25; // 0x4841c
                        function_11fc4(a4, v26, (char)v12, v17);
                        v10 = v26;
                        result3 = v12;
                        v11 = v17;
                        goto lab_0x48220;
                    } else {
                        goto lab_0x483b4;
                    }
                } else {
                    goto lab_0x483b4;
                }
            } else {
                // 0x482b8
                snprintf((char *)&str, 2048, "%s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x, read_back_data[2] = 0x%02x\n\n", "_pic_read_iic", v15, (int32_t)v1, (int32_t)v2);
                function_2e584(0, &str, 0);
                v10 = &str;
                result3 = 0;
                v11 = (int32_t)"_pic_read_iic";
                goto lab_0x48220;
            }
        } else {
            goto lab_0x48200;
        }
    } else {
        goto lab_0x48200;
    }
  lab_0x48200:
    // 0x48200
    snprintf((char *)&str, 2048, (char *)format, "_pic_read_iic");
    function_2e584(0, &str, 0);
    v10 = &str;
    result3 = 0;
    v11 = (int32_t)"_pic_read_iic";
    goto lab_0x48220;
  lab_0x48220:
    // 0x48220
    function_11ea4(&g141, v10, result3, v11);
    // 0x4822c
    return result3;
  lab_0x483b4:
    // 0x483b4
    snprintf((char *)&str, 2048, "%s failed 2!\n", "_pic_read_iic");
    function_2e584(0, &str, 0);
    v10 = &str;
    result3 = 0;
    v11 = (int32_t)"_pic_read_iic";
    goto lab_0x48220;
}

// Address range: 0x48438 - 0x48518
int32_t function_48438(uint32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t str; // bp-2080, 0x48438
    if (a1 >= 15 == (a1 != 15)) {
        // 0x484e0
        snprintf((char *)&str, 2048, "%s: Bad pic param, input chain is %d\n", "pic_write_iic", a1);
        function_2e584(0, &str, 0);
        // 0x48494
        return -0x7ffffdff;
    }
    int32_t v1 = 8 * a1; // 0x48460
    int32_t v2; // 0x4847c
    if (*(int32_t *)(v1 + (int32_t)&g460 + 4) != 0) {
        // 0x48474
        v2 = *(int32_t *)(v1 + (int32_t)&g460);
        // 0x48494
        return function_46ca0(v2, a2, a3, a4, a5);
    }
    int32_t result = function_46024(a1); // 0x484a4
    if (result >= 0) {
        // 0x48474
        v2 = *(int32_t *)(v1 + (int32_t)&g460);
        // 0x48494
        return function_46ca0(v2, a2, a3, a4, a5);
    }
    // 0x484b0
    snprintf((char *)&str, 2048, "%s: auto exec open_pic, but chain %d open eeprom failed\n", "pic_write_iic", a1);
    function_2e584(0, &str, 0);
    // 0x48494
    return result;
}

// Address range: 0x48520 - 0x487e8
int32_t function_48520(int32_t a1, int32_t * a2, uint32_t a3, int32_t * a4, int32_t a5) {
    int32_t v1 = (int32_t)a4;
    int32_t v2 = (int32_t)a2;
    int32_t v3 = v1 + 1; // 0x48540
    char v4 = 17; // bp-2089, 0x48560
    function_11f94(&g142, v2, a3, v3);
    int32_t v5 = v1 + a5;
    char * v6 = (char *)(v5 - 1); // 0x48594
    char * v7 = (char *)(v2 + 3);
    int32_t v8 = v1 - 1;
    char * str; // bp-2088, 0x48520
    int32_t v9 = (int32_t)&str;
    int32_t v10 = 0;
    int32_t v11 = 0;
    uint32_t v12 = (v11 + 1) % 256; // 0x485b4
    function_49794(a1, (int32_t *)&v4, 1, v11 + v2, 1);
    while (v12 < a3) {
        // 0x485ac
        v11 = v12;
        v12 = (v11 + 1) % 256;
        function_49794(a1, (int32_t *)&v4, 1, v11 + v2, 1);
    }
    // 0x485d8
    usleep((int32_t)"version array failed\n");
    int32_t v13 = 0;
    uint32_t v14 = (v13 + 1) % 256; // 0x485f4
    function_496f4(a1, (int32_t *)&v4, 1, v13 + v1, 1);
    while (v14 < a5) {
        // 0x485ec
        v13 = v14;
        v14 = (v13 + 1) % 256;
        function_496f4(a1, (int32_t *)&v4, 1, v13 + v1, 1);
    }
    // 0x48618
    usleep(0x186a0);
    int32_t v15 = v3; // 0x48634
    v15++;
    uint32_t v16 = (int32_t)*(char *)v15; // 0x48640
    int32_t v17 = v16 % 0x10000; // 0x48644
    while (v5 - 3 != v15) {
        // 0x48638
        v15++;
        v16 = v17 + (int32_t)*(char *)v15;
        v17 = v16 % 0x10000;
    }
    int32_t v18 = 256 * (int32_t)*v6 | (int32_t)*(char *)(v5 - 2); // 0x4865c
    if (v17 == v18) {
        if ((char)v2 == (char)v16) {
            // 0x48774
            if (*(char *)(v2 + 1) == *(char *)v3) {
                // 0x487bc
                if (*v7 == *(char *)(v1 + 3)) {
                    // 0x487cc
                    if ((int32_t)*(char *)(v1 + 2) + 2 == a5) {
                        // break -> 0x48744
                        break;
                    }
                }
            }
        }
        // 0x48784
        str = (char *)0x65776f70;
        function_2e584(0, (int32_t *)&str, 0);
    } else {
        // 0x4866c
        snprintf((char *)&str, 2048, "power reply the bad crc, crc = 0x%04x, crc_read = 0x%04x\n", v17, v18);
        function_2e584(0, (int32_t *)&str, 0);
    }
    int32_t v19 = v8; // 0x486b4
    int32_t v20 = 0; // 0x486b4
    v19++;
    unsigned char v21 = *(char *)v19; // 0x486b8
    snprintf((char *)&str, 2048, "read_back_data[%d] = 0x%02x", v20, (int32_t)v21);
    function_2e584(0, (int32_t *)&str, 0);
    v20++;
    while (v8 + a5 != v19) {
        // 0x486b8
        v19++;
        v21 = *(char *)v19;
        snprintf((char *)&str, 2048, "read_back_data[%d] = 0x%02x", v20, (int32_t)v21);
        function_2e584(0, (int32_t *)&str, 0);
        v20++;
    }
    int32_t v22 = (int32_t)*v7; // 0x4870c
    int32_t v23 = v10 + 1; // 0x48714
    snprintf((char *)&str, 2048, "Send power cmd(0x%02x) failed, retry %d\n", v22, v10);
    function_2e584(0, (int32_t *)&str, 0);
    int32_t v24 = v22; // 0x48738
    int32_t v25 = v9; // 0x48738
    int32_t v26 = 0; // 0x48738
    int32_t result = -0x7ffffd00; // 0x48738
    while (v23 != 3) {
        // 0x4859c
        v10 = v23;
        v11 = 0;
        v12 = (v11 + 1) % 256;
        function_49794(a1, (int32_t *)&v4, 1, v11 + v2, 1);
        while (v12 < a3) {
            // 0x485ac
            v11 = v12;
            v12 = (v11 + 1) % 256;
            function_49794(a1, (int32_t *)&v4, 1, v11 + v2, 1);
        }
        // 0x485d8
        usleep((int32_t)"version array failed\n");
        v13 = 0;
        v14 = (v13 + 1) % 256;
        function_496f4(a1, (int32_t *)&v4, 1, v13 + v1, 1);
        while (v14 < a5) {
            // 0x485ec
            v13 = v14;
            v14 = (v13 + 1) % 256;
            function_496f4(a1, (int32_t *)&v4, 1, v13 + v1, 1);
        }
        // 0x48618
        usleep(0x186a0);
        v15 = v3;
        v15++;
        v16 = (int32_t)*(char *)v15;
        v17 = v16 % 0x10000;
        while (v5 - 3 != v15) {
            // 0x48638
            v15++;
            v16 = v17 + (int32_t)*(char *)v15;
            v17 = v16 % 0x10000;
        }
        // 0x4864c
        v18 = 256 * (int32_t)*v6 | (int32_t)*(char *)(v5 - 2);
        if (v17 == v18) {
            if ((char)v2 == (char)v16) {
                // 0x48774
                if (*(char *)(v2 + 1) == *(char *)v3) {
                    // 0x487bc
                    if (*v7 == *(char *)(v1 + 3)) {
                        // 0x487cc
                        v24 = a5;
                        v25 = v2;
                        v26 = a5;
                        result = 0;
                        if ((int32_t)*(char *)(v1 + 2) + 2 == a5) {
                            // break -> 0x48744
                            break;
                        }
                    }
                }
            }
            // 0x48784
            str = (char *)0x65776f70;
            function_2e584(0, (int32_t *)&str, 0);
        } else {
            // 0x4866c
            snprintf((char *)&str, 2048, "power reply the bad crc, crc = 0x%04x, crc_read = 0x%04x\n", v17, v18);
            function_2e584(0, (int32_t *)&str, 0);
        }
        // 0x48698
        v19 = v8;
        v20 = 0;
        v19++;
        v21 = *(char *)v19;
        snprintf((char *)&str, 2048, "read_back_data[%d] = 0x%02x", v20, (int32_t)v21);
        function_2e584(0, (int32_t *)&str, 0);
        v20++;
        while (v8 + a5 != v19) {
            // 0x486b8
            v19++;
            v21 = *(char *)v19;
            snprintf((char *)&str, 2048, "read_back_data[%d] = 0x%02x", v20, (int32_t)v21);
            function_2e584(0, (int32_t *)&str, 0);
            v20++;
        }
        // 0x486f0
        v22 = (int32_t)*v7;
        v23 = v10 + 1;
        snprintf((char *)&str, 2048, "Send power cmd(0x%02x) failed, retry %d\n", v22, v10);
        function_2e584(0, (int32_t *)&str, 0);
        v24 = v22;
        v25 = v9;
        v26 = 0;
        result = -0x7ffffd00;
    }
    // 0x48744
    function_11ea4(&g142, v25, v26, v24);
    return result;
}

// Address range: 0x487e8 - 0x48834
int32_t function_487e8(int32_t a1) {
    char * v1 = (char *)0x20746573; // bp-2056, 0x48804
    function_2e584(0, (int32_t *)&v1, 0);
    return -0x7ffffd00;
}

// Address range: 0x48834 - 0x488a4
int32_t function_48834(int32_t a1, int32_t a2) {
    int32_t v1 = -0x7cf955ab; // bp-24, 0x48860
    int32_t v2 = 0; // bp-16, 0x48878
    int32_t v3 = function_48520(a1, &v1, 8, &v2, 8); // 0x48884
    int32_t result = 0; // 0x48890
    if (v3 != 0) {
        // 0x4889c
        result = function_487e8(v3);
    }
    // 0x48894
    return result;
}

// Address range: 0x488a4 - 0x488d8
int32_t function_488a4(void) {
    // 0x488a4
    int32_t v1; // 0x488a4
    function_11f94(&g142, v1, v1, v1);
    function_49574(g143);
    g144 = 0;
    g145 = 0;
    return function_11ea4(&g142, v1, v1, 0);
}

// Address range: 0x488d8 - 0x48910
int32_t function_488d8(void) {
    // 0x488d8
    if (g143 == 0 || g144 == 0) {
        // 0x488f8
        function_488a4();
        return 0;
    }
    // 0x48908
    return 0;
}

// Address range: 0x48910 - 0x48ab8
int32_t function_48910(void) {
    // 0x48910
    char * str; // bp-2080, 0x48910
    if (g144 == 0) {
        int32_t result = function_48b58(); // 0x48930
        if (result < 0) {
            // 0x48a1c
            snprintf((char *)&str, 2048, "%s: auto exec bitmain_power_open, but open power failed\n", "bitmain_power_version");
            function_2e584(0, (int32_t *)&str, 0);
            // 0x48a0c
            return result;
        }
    }
    // 0x4893c
    int32_t v1; // bp-2096, 0x48910
    int32_t v2 = &v1;
    char v3; // bp-2088, 0x48910
    int32_t v4 = &v3;
    int32_t v5 = (int32_t)&str;
    for (int32_t i = 10; i > 0; i--) {
        // 0x48958
        v1 = -1;
        v3 = 0;
        int32_t v6; // 0x48910
        int32_t v7; // 0x48910
        function_11f94(&g142, v6, v7, -1);
        int32_t v8; // 0x48910
        int32_t v9; // 0x48910
        if (function_496f4(g143, (int32_t *)&v3, 1, v2, 1) == 1) {
            // 0x48994
            function_11ea4(&g142, v4, 1, v2);
            v8 = v4;
            v9 = 1;
            if (v1 % 256 == 245) {
                // break -> 0x489b8
                break;
            }
        } else {
            // 0x48a4c
            snprintf((char *)&str, 2048, "%s: iic read is failed\n", "_bitmain_get_power_code_version");
            function_2e584(0, (int32_t *)&str, 0);
            function_11ea4(&g142, v5, 0, (int32_t)"_bitmain_get_power_code_version");
            v8 = v5;
            v9 = 0;
        }
        // 0x489a4
        usleep(0x186a0);
        v6 = v8;
        v7 = v9;
    }
    // 0x489b8
    v1 = 0x204aa55;
    v3 = 0;
    int32_t v10 = function_48520(g143, &v1, 6, (int32_t *)&v3, 8); // 0x489f4
    int32_t result2 = 0; // 0x489fc
    if (v10 != 0) {
        // 0x48a7c
        str = (char *)0x20746567;
        function_2e584(0, (int32_t *)&str, 0);
        result2 = -0x7ffffd00;
    }
    // 0x48a0c
    return result2;
}

// Address range: 0x48abc - 0x48b58
int32_t function_48abc(void) {
    int32_t v1 = 0; // bp-24, 0x48ae0
    int32_t v2; // 0x48abc
    function_11f94(&g142, v2, v2, 0x20001);
    int32_t result = function_493d0(&v1); // 0x48aec
    function_11ea4(&g142, v2, v2, 0x20001);
    if (result < 0) {
        // 0x48b24
        return result;
    }
    // 0x48b04
    g143 = result;
    g144 = 1;
    int32_t result2 = function_48910(); // 0x48b10
    if (result2 >= 0) {
        // .thread
        g145 = result2;
        // 0x48b24
        return 0;
    }
    // 0x48b30
    if (g143 == 0 || g144 == 0) {
        // 0x48b48
        function_488a4();
        return result2;
    }
    // 0x48b24
    return result2;
}

// Address range: 0x48b58 - 0x48b7c
int32_t function_48b58(void) {
    // 0x48b58
    if (g143 == 0 || g144 == 0) {
        // 0x48b78
        return function_48abc();
    }
    return g143;
}

// Address range: 0x48b7c - 0x48cb4
int32_t function_48b7c(void) {
    // 0x48b7c
    char * str; // bp-2064, 0x48b7c
    if (g144 == 0) {
        int32_t result = function_48abc(); // 0x48b9c
        if (result < 0) {
            // 0x48c88
            snprintf((char *)&str, 2048, "%s: auto exec bitmain_power_open, but open power failed\n", "bitmain_get_power_status");
            function_2e584(0, (int32_t *)&str, 0);
            // 0x48bf4
            return result;
        }
    }
    int32_t v1 = 0; // bp-2072, 0x48bd8
    int32_t v2 = 0xa04aa55; // bp-2080, 0x48bdc
    if (function_48520(g143, &v2, 6, &v1, 8) == 0) {
        // 0x48bf4
        return 0;
    }
    // 0x48c04
    str = (char *)0x20746567;
    function_2e584(0, (int32_t *)&str, 0);
    str = (char *)0x206e6163;
    function_2e584(0, (int32_t *)&str, 0);
    return -0x7ffffd00;
}

// Address range: 0x48cb8 - 0x48d34
int32_t function_48cb8(int32_t a1) {
    // 0x48cb8
    if (g144 != 0) {
        // 0x48cf8
        return function_48834(g143, a1);
    }
    int32_t result = function_48abc(); // 0x48cdc
    if (result >= 0) {
        // 0x48cf8
        return function_48834(g143, a1);
    }
    // 0x48d08
    int32_t str; // bp-2072, 0x48cb8
    snprintf((char *)&str, 2048, "%s: auto exec bitmain_power_open, but open power failed\n", "bitmain_set_voltage_by_n");
    function_2e584(0, &str, 0);
    // 0x48cf8
    return result;
}

// Address range: 0x48d38 - 0x48ec0
int32_t function_48d38(int32_t a1) {
    // 0x48d38
    g484 = g145 - 65;
    int32_t result; // 0x48d38
    switch (g145) {
        case 65: {
        }
        case 66: {
            // 0x48e54
            __asm_vldr(-0x58212945);
            __asm_vldr(0x4aec8d5c);
            return result;
        }
        case 67: {
            // 0x48e74
            __asm_vldr(0x1f42bb66);
            __asm_vldr(0x447c30d3);
            return result;
        }
        case 119: {
        }
        case 117: {
        }
        case 114: {
        }
        case 113: {
            // 0x48e34
            __asm_vldr(-0x702e6645);
            __asm_vldr(-0x36c15d2d);
            return result;
        }
        case 118: {
        }
        case 116: {
            // 0x48e94
            __asm_vldr(-0x58a76102);
            __asm_vldr(0x2ac32229);
            return result;
        }
    }
    // 0x48eb4
    return -1;
}

// Address range: 0x48ee4 - 0x48ee6
int32_t function_48ee4(void) {
    // 0x48ee4
    int32_t result; // 0x48ee4
    return result;
}

// Address range: 0x48efc - 0x48f98
int32_t function_48efc(int32_t a1, int32_t a2, int32_t a3) {
    // 0x48efc
    if (g144 == 0) {
        // 0x48f4c
        float64_t v1; // 0x48efc
        int32_t v2; // 0x48efc
        __asm_vstr(v1, v2);
        int32_t result = function_48abc(); // 0x48f50
        __asm_vldr(v2);
        if (result < 0) {
            // 0x48f60
            int32_t str; // bp-2064, 0x48efc
            snprintf((char *)&str, 2048, "%s: auto exec bitmain_power_open, but open power failed\n", "bitmain_set_voltage");
            function_2e584(0, &str, 0);
            // 0x48f3c
            return result;
        }
    }
    uint32_t v3 = function_48d38((int32_t)&g488); // 0x48f20
    int32_t result2 = -0x7ffffcff; // 0x48f28
    if (v3 >= 255 != v3 != 255) {
        // 0x48f2c
        result2 = function_48834(g143, v3 % 256);
    }
    // 0x48f3c
    return result2;
}

// Address range: 0x48f9c - 0x49108
int32_t function_48f9c(int32_t result) {
    // 0x48f9c
    g489 = g145 - 65;
    switch (g145) {
        case 65: {
        }
        case 66: {
            // 0x490bc
            __asm_vldr_8(result);
            __asm_vldr(-0x58212945);
            return result;
        }
        case 67: {
            // 0x490dc
            __asm_vldr_8(result);
            __asm_vldr(0x1f42bb66);
            return result;
        }
        case 119: {
        }
        case 117: {
        }
        case 114: {
        }
        case 113: {
            // 0x4909c
            __asm_vldr_8(result);
            __asm_vldr(-0x702e6645);
            return result;
        }
        case 118: {
        }
        case 116: {
            // 0x490fc
            __asm_vldr_8(result);
            __asm_vldr(0x2ac32229);
            __asm_vldr(-0x58a76102);
            return result;
        }
    }
    // 0x4911c
    return result;
}

// Address range: 0x4910a - 0x49118
int32_t function_4910a(void) {
    // 0x4910a
    int32_t v1; // 0x4910a
    bool v2; // 0x4910a
    if (!v2) {
        v1 = function_1244bf2();
    }
    int32_t result = v1; // 0x4910e
    if (v2) {
        result = function_1c49ee();
    }
    // 0x49112
    __asm_cdp(0, 8, 13, 7, 8, 0);
    return result;
}

// Address range: 0x49118 - 0x4911c
int32_t function_49118(void) {
    // 0x49118
    int32_t result; // 0x49118
    return result;
}

// Address range: 0x49120 - 0x49124
int32_t function_49120(void) {
    // 0x49120
    int32_t result; // 0x49120
    return result;
}

// Address range: 0x49124 - 0x49128
int32_t function_49124(void) {
    // 0x49124
    return function_449768();
}

// Address range: 0x4912c - 0x49138
int32_t function_4912c(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x4912c
    bool v1; // 0x4912c
    bool v2 = v1;
    int32_t v3; // 0x4912c
    if ((v2 ? a4 : v3) > (v2 ? 0x80000000 * v3 : v3)) {
        return *(int32_t *)(v3 - 4);
    }
    // 0x49134
    return result;
}

// Address range: 0x4913c - 0x49148
int32_t function_4913c(int32_t a1, int32_t a2) {
    int32_t result = a1; // 0x49140
    bool v1; // 0x4913c
    if (v1) {
        result = function_ffb6c6b8();
    }
    // 0x49144
    return result;
}

// Address range: 0x4914c - 0x4914e
int32_t function_4914c(void) {
    // 0x4914c
    int32_t result; // 0x4914c
    return result;
}

// Address range: 0x49164 - 0x49294
int32_t function_49164(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x49164
    char * str; // bp-2064, 0x49164
    if (g144 == 0) {
        int32_t v1 = function_48abc(); // 0x49188
        if (v1 < 0) {
            // 0x491f0
            snprintf((char *)&str, 2048, "%s: auto exec bitmain_power_open, but open power failed\n", "bitmain_get_voltage");
            int32_t result = function_2e584(0, (int32_t *)&str, 0); // 0x49214
            __asm_vmov_7(v1);
            return result;
        }
    }
    int32_t v2 = 0; // bp-2072, 0x491c4
    int32_t v3 = 0x304aa55; // bp-2080, 0x491c8
    if (function_48520(g143, &v3, 6, &v2, 8) == 0) {
        // 0x491dc
        return function_48f9c(0);
    }
    // 0x49224
    str = (char *)0x20746567;
    function_2e584(0, (int32_t *)&str, 0);
    str = (char *)0x206e6163;
    int32_t result2 = function_2e584(0, (int32_t *)&str, 0); // 0x49280
    __asm_vldr(0x40000000);
    return result2;
}

// Address range: 0x49294 - 0x49298
int32_t function_49294(void) {
    // 0x49294
    return function_4498d8();
}

// Address range: 0x4929c - 0x492a0
int32_t function_4929c(void) {
    // 0x4929c
    bool v1; // 0x4929c
    if (v1 || false) {
        // 0x492a0
        int32_t result; // 0x4929c
        return result;
    }
    return unknown_fe3();
}

// Address range: 0x492a4 - 0x493cc
int32_t function_492a4(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = 0; // bp-2084, 0x492f4
    int32_t v2 = 0x606aa55; // bp-2092, 0x492f8
    int32_t result = 0; // 0x492fc
    char * str; // bp-2072, 0x492a4
    if (g144 == 0) {
        // 0x49300
        result = function_48abc();
        if (result < 0) {
            // 0x49368
            snprintf((char *)&str, 2048, "%s: auto exec bitmain_power_open, but open power failed\n", "bitmain_power_read");
            function_2e584(0, (int32_t *)&str, 0);
            // 0x4935c
            return result;
        }
    }
    // 0x4930c
    if (function_48520(g143, &v2, 8, &v1, a3 + 7) != 0) {
        // 0x49394
        str = (char *)0x20746573;
        function_2e584(0, (int32_t *)&str, 0);
        // 0x4935c
        return -0x7ffffd00;
    }
    // 0x49330
    if (a3 == 0) {
        // 0x4935c
        return result;
    }
    // 0x49338
    int32_t v3; // bp-2079, 0x492a4
    int32_t v4 = &v3; // 0x49348
    int32_t v5 = a2 - 1; // 0x49348
    v5++;
    *(char *)v5 = *(char *)v4;
    v4++;
    while (v5 != (a3 + 255) % 256 + a2) {
        // 0x4934c
        v5++;
        *(char *)v5 = *(char *)v4;
        v4++;
    }
    // 0x4935c
    return result;
}

// Address range: 0x493d0 - 0x49574
int32_t function_493d0(int32_t * a1) {
    // 0x493d0
    char * v1; // bp-2072, 0x493d0
    int32_t v2; // 0x493d0
    if (function_11f94(&g146, v2, v2, v2) != 0) {
        // 0x49540
        v1 = (char *)0x6c696166;
        function_2e584(0, (int32_t *)&v1, 0);
        // 0x4946c
        return -4;
    }
    int32_t v3 = (int32_t)a1;
    int32_t v4; // 0x493d0
    int32_t v5; // 0x493d0
    int32_t v6; // 0x493d0
    int32_t v7; // 0x493d0
    int32_t result; // 0x493d0
    int32_t v8; // 0x493fc
    if (a1 == NULL) {
        // 0x494b0
        v1 = (char *)0x20646162;
        int32_t v9 = 0; // bp-2062, 0x494dc
        function_2e584(v3, (int32_t *)&v1, v3);
        v4 = (int32_t)&v1;
        v5 = v3;
        v7 = &v9;
        result = -3;
        goto lab_0x49460;
    } else {
        // 0x493fc
        v8 = function_49904();
        if (v8 < 0) {
            // 0x4947c
            v1 = (char *)0x6c696166;
            function_2e584(0, (int32_t *)&v1, 0);
            v4 = (int32_t)&v1;
            v5 = 0;
            v7 = 0x6e695f63;
            result = -1;
            goto lab_0x49460;
        } else {
            // 0x49408
            if (function_4a3ec(v8, *(int16_t *)(v3 + 4)) == 0) {
                int32_t v10 = 2 * (int32_t)*(char *)(v3 + 7); // 0x494f8
                int32_t v11 = 16 * (int32_t)*(char *)(v3 + 6) | v10; // 0x494fc
                int32_t v12 = function_4a2d8(v8, 1795, v11); // 0x49500
                v4 = 1795;
                v5 = v11;
                v7 = v10;
                result = v8;
                if (v12 == 0) {
                    goto lab_0x49460;
                } else {
                    // 0x4950c
                    v1 = (char *)0x6c696166;
                    function_2e584(0, (int32_t *)&v1, 0);
                    v6 = 0x6f695f63;
                    goto lab_0x49448;
                }
            } else {
                // 0x49418
                v1 = (char *)0x6c696166;
                function_2e584(0, (int32_t *)&v1, 0);
                v6 = 0x65735f63;
                goto lab_0x49448;
            }
        }
    }
  lab_0x49460:
    // 0x49460
    function_11ea4(&g146, v4, v5, v7);
    // 0x4946c
    return result;
  lab_0x49448:;
    int32_t v13 = (int32_t)&v1;
    v4 = v13;
    v5 = 0;
    v7 = v6;
    result = -1;
    if (v8 != 0) {
        // 0x49454
        function_499e8(v8);
        v4 = v13;
        v5 = 0;
        v7 = v6;
        result = -1;
    }
    goto lab_0x49460;
}

// Address range: 0x49574 - 0x495e4
int32_t function_49574(int32_t a1) {
    // 0x49574
    int32_t v1; // 0x49574
    if (function_11f94(&g146, v1, v1, v1) == 0) {
        // 0x49594
        function_499e8(a1);
        return function_11ea4(&g146, v1, v1, v1);
    }
    char * v2 = (char *)0x6c696166; // bp-2056, 0x495c4
    return function_2e584(0, (int32_t *)&v2, 0);
}

// Address range: 0x495e4 - 0x4966c
int32_t function_495e4(int32_t a1, int32_t * a2, int32_t a3) {
    int32_t v1 = (int32_t)a2;
    int32_t result; // 0x495e4
    int32_t v2; // 0x495e4
    if (function_11f94(&g146, v1, a3, v2) == 0) {
        int32_t v3 = function_49b10(a1, v1, a3); // 0x49618
        function_11ea4(&g146, v1, a3, v2);
        result = v3;
    } else {
        char * v4 = (char *)0x6c696166; // bp-2064, 0x49650
        function_2e584(0, (int32_t *)&v4, 0);
        result = -4;
    }
    // 0x4962c
    return result;
}

// Address range: 0x4966c - 0x496f4
int32_t function_4966c(int32_t a1, int32_t * a2, int32_t a3) {
    int32_t v1 = (int32_t)a2;
    int32_t result; // 0x4966c
    int32_t v2; // 0x4966c
    if (function_11f94(&g146, v1, a3, v2) == 0) {
        int32_t v3 = function_49cfc(a1, v1, a3); // 0x496a0
        function_11ea4(&g146, v1, a3, v2);
        result = v3;
    } else {
        char * v4 = (char *)0x6c696166; // bp-2064, 0x496d8
        function_2e584(0, (int32_t *)&v4, 0);
        result = -4;
    }
    // 0x496b4
    return result;
}

// Address range: 0x496f4 - 0x49794
int32_t function_496f4(int32_t a1, int32_t * a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t v1 = (int32_t)a2;
    int32_t result; // 0x496f4
    if (function_11f94(&g146, v1, a3, a4) == 0) {
        int32_t v2 = function_49e8c(a1, v1, a3, a4, a5); // 0x4973c
        function_11ea4(&g146, v1, a3, a4);
        result = v2;
    } else {
        char * v3 = (char *)0x6c696166; // bp-2072, 0x49778
        function_2e584(0, (int32_t *)&v3, 0);
        result = -4;
    }
    // 0x49750
    return result;
}

// Address range: 0x49794 - 0x49834
int32_t function_49794(int32_t a1, int32_t * a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t v1 = (int32_t)a2;
    int32_t result; // 0x49794
    if (function_11f94(&g146, v1, a3, a4) == 0) {
        int32_t v2 = function_4a0dc(a1, v1, a3, a4, a5); // 0x497dc
        function_11ea4(&g146, v1, a3, a4);
        result = v2;
    } else {
        char * v3 = (char *)0x6c696166; // bp-2072, 0x49818
        function_2e584(0, (int32_t *)&v3, 0);
        result = -4;
    }
    // 0x497f0
    return result;
}

// Address range: 0x49834 - 0x49844
int32_t function_49834(int32_t a1, int32_t a2) {
    // 0x49834
    return a1 - a2;
}

// Address range: 0x49844 - 0x498a0
int32_t function_49844(void) {
    int32_t v1 = 0; // bp-20, 0x49858
    int32_t v2 = 601; // 0x4985c
    function_40314(12, &v1);
    int32_t result = 1; // 0x49884
    while (v1 > 0xffffffff) {
        int32_t v3 = v2;
        usleep(0x1388);
        v2 = v3 - 1;
        result = 0;
        if (v3 == 1) {
            // break -> 0x49888
            break;
        }
        function_40314(12, &v1);
        result = 1;
    }
    // 0x49888
    return result;
}

// Address range: 0x498a0 - 0x49904
int32_t function_498a0(int32_t a1) {
    char v1 = 0; // bp-20, 0x498b8
    int32_t v2 = 601; // 0x498bc
    function_40314(12, (int32_t *)&v1);
    while (v1 > 255) {
        int32_t v3 = v2;
        usleep(0x1388);
        v2 = v3 - 1;
        if (v3 == 1) {
            // 0x498f8
            return 0;
        }
        function_40314(12, (int32_t *)&v1);
    }
    // 0x498e8
    *(char *)a1 = v1;
    return 1;
}

// Address range: 0x49904 - 0x499e8
int32_t function_49904(void) {
    // 0x49904
    char * v1; // bp-2064, 0x49904
    if (g104 == 0) {
        // 0x499b0
        v1 = (char *)0x61656c70;
        function_2e584(0, (int32_t *)&v1, 0);
        // 0x49978
        return -2;
    }
    int32_t v2 = g147; // 0x49930
    int32_t v3; // 0x49904
    int32_t v4; // 0x49904
    if (v2 == 0) {
        int32_t v5 = function_432d0(0x49834, 0, 0); // 0x49990
        g148 = v5;
        function_11fdc((int32_t)&g149, 0);
        v3 = g147;
        v4 = v5;
    } else {
        // 0x4993c
        v3 = v2;
        v4 = g148;
    }
    int32_t result = v3 + 1; // 0x49950
    g147 = result;
    v1 = NULL;
    function_43320(v4);
    // 0x49978
    return result;
}

// Address range: 0x499e8 - 0x49b0c
int32_t function_499e8(int32_t a1) {
    int32_t v1 = a1; // bp-2068, 0x499fc
    char * str; // bp-2064, 0x499e8
    int32_t v2; // 0x499e8
    if (function_11f94(&g149, v2, v2, v2) != 0) {
        // 0x49a98
        str = (char *)0x6c696166;
        return function_2e584(0, (int32_t *)&str, 0);
    }
    // 0x49a10
    int32_t v3; // 0x499e8
    int32_t v4; // 0x499e8
    if (function_43338(g148) == 1) {
        // 0x49ad0
        function_43358(g148);
        v3 = &v1;
    } else {
        // 0x49a24
        snprintf((char *)&str, 2048, "ctx(%d) is not inited\n", a1);
        function_2e584(1, (int32_t *)&str, 0);
        v3 = (int32_t)&str;
        v4 = 0;
    }
    // 0x49a4c
    if (function_43440(g148) == 0) {
        // 0x49ae0
        function_43488(0);
        function_11ea4(&g149, v3, v4, 0);
        g147 = 0;
        int32_t result = function_43414(g148); // 0x49af8
        g148 = 0;
        return result;
    }
    while (true) {
        // continue -> infloop
    }
}

// Address range: 0x49b10 - 0x49cf8
int32_t function_49b10(int32_t a1, int32_t a2, int32_t result) {
    int32_t v1 = a1; // bp-2084, 0x49b28
    char * str; // bp-2072, 0x49b10
    int32_t v2; // 0x49b10
    if (function_11f94(&g149, a2, result, v2) != 0) {
        // 0x49c8c
        str = (char *)0x6c696166;
        function_2e584(0, (int32_t *)&str, 0);
        // 0x49c14
        return -1;
    }
    int32_t v3 = 0; // bp-2076, 0x49b4c
    if (function_433d0(g148, &v1, &v3) != 1) {
        // 0x49cc0
        snprintf((char *)&str, 2048, "ctx %d not inited\n", v1);
        function_2e584(0, (int32_t *)&str, 0);
        function_11ea4(&g149, (int32_t)&str, 0, v1);
        // 0x49c14
        return -2;
    }
    uint32_t v4 = *(int32_t *)(v3 + 4); // 0x49b68
    uint32_t v5 = v4 / 16; // 0x49b70
    int32_t v6 = 0x8000 * v4 & 0x70000; // 0x49b7c
    int32_t v7 = &v1; // 0x49b88
    if (result == 0) {
      lab_0x49c20:
        // 0x49c20
        free(v3, v7, v5, v6);
        function_11ea4(&g149, v7, v5, v6);
        return result;
    }
    // 0x49b8c
    v7 = 0x4000000 * *(int32_t *)v3 | 0x100000 * v5 | v6 | 0x2000000;
    int32_t v8 = a2; // 0x49b90
    while (function_49844() != 0) {
        // 0x49b94
        function_40390(12, v7);
        if (function_498a0(v8) == 0) {
            // 0x49c38
            free(v3, v7, v5, v6);
            str = (char *)0x20636969;
            function_2e584(0, (int32_t *)&str, 0);
            function_11ea4(&g149, (int32_t)&str, 0, 0);
            return -3;
        }
        // 0x49bac
        v8++;
        if (v8 == result + a2) {
            // 0x49c1c
            goto lab_0x49c20;
        }
    }
    // 0x49bc8
    free(v3, v7, v5, v6);
    str = (char *)0x20636969;
    function_2e584(0, (int32_t *)&str, 0);
    function_11ea4(&g149, (int32_t)&str, 0, 0);
    // 0x49c14
    return -2;
}

// Address range: 0x49cfc - 0x49e88
int32_t function_49cfc(int32_t a1, int32_t a2, int32_t result) {
    int32_t v1 = a1; // bp-2084, 0x49d14
    char * str; // bp-2072, 0x49cfc
    int32_t v2; // 0x49cfc
    if (function_11f94(&g149, a2, result, v2) != 0) {
        // 0x49e1c
        str = (char *)0x6c696166;
        function_2e584(0, (int32_t *)&str, 0);
        // 0x49df4
        return -1;
    }
    int32_t v3 = (int32_t)&str; // 0x49d28
    int32_t v4 = 0; // bp-2076, 0x49d38
    if (function_433d0(g148, &v1, &v4) != 1) {
        // 0x49e50
        snprintf((char *)&str, 2048, "ctx %d not inited\n", v1);
        function_2e584(0, (int32_t *)&str, 0);
        function_11ea4(&g149, v3, 0, v1);
        // 0x49df4
        return -2;
    }
    int32_t v5 = &v1; // 0x49d50
    int32_t v6 = &v4; // 0x49d50
    int32_t v7 = v3; // 0x49d50
    if (result == 0) {
        goto lab_0x49e00;
      lab_0x49e00:
        // 0x49e00
        free(v4, v5, v6, v7);
        function_11ea4(&g149, v5, v6, v7);
        return result;
    }
    int32_t v8 = a2 - 1;
    int32_t v9 = v8; // 0x49d60
    uint32_t v10 = *(int32_t *)(v4 + 4); // 0x49d70
    v9++;
    int32_t v11 = *(int32_t *)v4; // 0x49d78
    v6 = v10 / 16;
    v7 = 0x8000 * v10 & 0x70000;
    v5 = 0x100000 * v6 | (int32_t)*(char *)v9 | v7 | 0x4000000 * v11;
    while (function_49844() != 0) {
        // 0x49d64
        function_40390(12, v5);
        if (v8 + result == v9) {
            // 0x49dfc
            goto lab_0x49e00;
        }
        v10 = *(int32_t *)(v4 + 4);
        v9++;
        v11 = *(int32_t *)v4;
        v6 = v10 / 16;
        v7 = 0x8000 * v10 & 0x70000;
        v5 = 0x100000 * v6 | (int32_t)*(char *)v9 | v7 | 0x4000000 * v11;
    }
    // 0x49da8
    free(v4, v5, v6, v7);
    str = (char *)0x20636969;
    function_2e584(0, (int32_t *)&str, 0);
    function_11ea4(&g149, v3, 0, 0);
    // 0x49df4
    return -2;
}

// Address range: 0x49e8c - 0x4a0d8
int32_t function_49e8c(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t result) {
    int32_t v1 = a1; // bp-2092, 0x49e9c
    char * str; // bp-2080, 0x49e8c
    if (a3 != 1) {
        // 0x4a028
        str = (char *)0x65726f6d;
        function_2e584(0, (int32_t *)&str, 0);
        // 0x49fa8
        return -3;
    }
    // 0x49ea8
    if (function_11f94(&g149, a2, 1, a4) != 0) {
        // 0x4a06c
        str = (char *)0x6c696166;
        function_2e584(0, (int32_t *)&str, 0);
        // 0x49fa8
        return -1;
    }
    int32_t v2 = (int32_t)&str; // 0x49ec8
    int32_t v3 = 0; // bp-2084, 0x49ed8
    if (function_433d0(g148, &v1, &v3) != 1) {
        // 0x4a0a0
        snprintf((char *)&str, 2048, "ctx %d not inited\n", v1);
        function_2e584(0, (int32_t *)&str, 0);
        function_11ea4(&g149, v2, 0, v1);
        // 0x49fa8
        return -2;
    }
    int32_t v4 = &v1; // 0x49ed4
    int32_t v5 = v4; // 0x49ef0
    int32_t v6 = &v3; // 0x49ef0
    int32_t v7 = v2; // 0x49ef0
    if (result == 0) {
        goto lab_0x49fb8;
      lab_0x49fb8:
        // 0x49fb8
        free(v3, v5, v6, v7);
        function_11ea4(&g149, v5, v6, v7);
        return result;
    }
    int32_t v8 = v4 & 252; // 0x49e8c
    int32_t v9 = 0; // 0x49f00
    int32_t v10 = *(int32_t *)v3; // 0x49f18
    uint32_t v11 = *(int32_t *)(v3 + 4); // 0x49f1c
    while (function_49844() != 0) {
        // 0x49ef8
        v6 = v11 / 16;
        v7 = 0x8000 * v11 & 0x70000;
        v5 = 0x4000000 * v10 | 256 * (v9 + v8) | 0x100000 * v6 | v7 | 0x3000000;
        function_40390(12, v5);
        if (function_498a0(v9 + a4) == 0) {
            // 0x49fd8
            str = (char *)0x20636969;
            function_2e584(0, (int32_t *)&str, 0);
            free(v3, v2, 0, 0x6572206f);
            function_11ea4(&g149, v2, 0, 0x6572206f);
            return -3;
        }
        // 0x49f10
        v9++;
        v8 = 0;
        if (v9 == result) {
            // 0x49fb4
            goto lab_0x49fb8;
        }
        v10 = *(int32_t *)v3;
        v11 = *(int32_t *)(v3 + 4);
    }
    // 0x49f5c
    str = (char *)0x20636969;
    function_2e584(0, (int32_t *)&str, 0);
    free(v3, v2, 0, 0);
    function_11ea4(&g149, v2, 0, 0);
    // 0x49fa8
    return -2;
}

// Address range: 0x4a0dc - 0x4a2d4
int32_t function_4a0dc(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t result) {
    int32_t v1 = a1; // bp-2092, 0x4a0ec
    char * str; // bp-2080, 0x4a0dc
    if (a3 != 1) {
        // 0x4a224
        str = (char *)0x65726f6d;
        function_2e584(0, (int32_t *)&str, 0);
        // 0x4a1f4
        return -3;
    }
    // 0x4a0f8
    if (function_11f94(&g149, a2, 1, a4) != 0) {
        // 0x4a268
        str = (char *)0x6c696166;
        function_2e584(0, (int32_t *)&str, 0);
        // 0x4a1f4
        return -1;
    }
    int32_t v2 = (int32_t)&str; // 0x4a118
    int32_t v3 = 0; // bp-2084, 0x4a128
    if (function_433d0(g148, &v1, &v3) != 1) {
        // 0x4a29c
        snprintf((char *)&str, 2048, "ctx %d not inited\n", v1);
        function_2e584(0, (int32_t *)&str, 0);
        function_11ea4(&g149, v2, 0, v1);
        // 0x4a1f4
        return -2;
    }
    int32_t v4 = &v1; // 0x4a124
    int32_t v5 = v4; // 0x4a140
    int32_t v6 = &v3; // 0x4a140
    int32_t v7 = v2; // 0x4a140
    if (result == 0) {
        goto lab_0x4a204;
      lab_0x4a204:
        // 0x4a204
        free(v3, v5, v6, v7);
        function_11ea4(&g149, v5, v6, v7);
        return result;
    }
    char v8 = v4; // 0x4a148
    int32_t v9 = a4 - 1; // 0x4a148
    int32_t v10 = 0; // 0x4a148
    int32_t v11 = *(int32_t *)v3; // 0x4a158
    uint32_t v12 = *(int32_t *)(v3 + 4); // 0x4a15c
    v9++;
    unsigned char v13 = *(char *)v9; // 0x4a160
    while (function_49844() != 0) {
        int32_t v14 = v10;
        v6 = v13;
        v7 = 0x8000 * v12 & 0x70000;
        v10 = v14 + 1;
        v5 = 0x4000000 * v11 | 256 * (v14 + (int32_t)v8) | 0x100000 * v12 / 16 | v6 | v7 | 0x1000000;
        function_40390(12, v5);
        v8 = v13;
        if (v10 == result) {
            // 0x4a200
            goto lab_0x4a204;
        }
        v11 = *(int32_t *)v3;
        v12 = *(int32_t *)(v3 + 4);
        v9++;
        v13 = *(char *)v9;
    }
    // 0x4a1a8
    str = (char *)0x20636969;
    function_2e584(0, (int32_t *)&str, 0);
    free(v3, v2, 0, 0);
    function_11ea4(&g149, v2, 0, 0);
    // 0x4a1f4
    return -2;
}

// Address range: 0x4a2d8 - 0x4a3e8
int32_t function_4a2d8(int32_t a1, int32_t a2, int32_t a3) {
    // 0x4a2d8
    char * v1; // bp-2072, 0x4a2d8
    int32_t v2; // 0x4a2d8
    if (function_11f94(&g149, a2, a3, v2) != 0) {
        // 0x4a3b4
        v1 = (char *)0x6c696166;
        function_2e584(0, (int32_t *)&v1, 0);
        // 0x4a3a8
        return -4;
    }
    int32_t v3 = function_43440(g148); // 0x4a30c
    int32_t v4 = *(int32_t *)v3; // 0x4a310
    int32_t v5 = a2; // 0x4a320
    int32_t v6 = a3; // 0x4a320
    int32_t v7 = v4; // 0x4a320
    if (v3 != 0) {
        int32_t v8 = *(int32_t *)*(int32_t *)(*(int32_t *)(v3 + 20) + 16); // 0x4a344
        while (*(int32_t *)v8 != a1) {
            // continue -> 0x4a33c
        }
        // 0x4a354
        v5 = a2;
        v6 = a3;
        v7 = 1795;
        if (a2 == 1795) {
            int32_t v9 = *(int32_t *)(v3 + 4); // 0x4a374
            int32_t v10 = (int32_t)&v1; // 0x4a380
            v1 = (char *)v4;
            free(v3, v10, 8, v9);
            v5 = v10;
            v6 = 8;
            v7 = v9;
        }
    }
    // 0x4a394
    function_43488(v3);
    function_11ea4(&g149, v5, v6, v7);
    // 0x4a3a8
    return 0;
}

// Address range: 0x4a3ec - 0x4a4e4
int32_t function_4a3ec(int32_t a1, int16_t a2) {
    int32_t v1 = a2;
    char * v2; // bp-2064, 0x4a3ec
    int32_t v3; // 0x4a3ec
    if (function_11f94(&g149, v1, v3, v3) != 0) {
        // 0x4a4b0
        v2 = (char *)0x6c696166;
        function_2e584(0, (int32_t *)&v2, 0);
        // 0x4a4a8
        return -4;
    }
    int32_t v4 = function_43440(g148); // 0x4a418
    int32_t v5 = v1; // 0x4a42c
    int32_t v6 = *(int32_t *)v4; // 0x4a42c
    int32_t v7; // 0x4a3ec
    if (v4 != 0) {
        int32_t v8 = *(int32_t *)(v4 + 20); // 0x4a448
        while (*(int32_t *)*(int32_t *)*(int32_t *)(v8 + 16) != a1) {
            // continue -> 0x4a448
        }
        // 0x4a460
        v6 = *(int32_t *)(v4 + 4);
        v2 = (char *)v1;
        v5 = (int32_t)&v2;
        free(v4, v5, 8, v6);
        v7 = 8;
    }
    // 0x4a494
    function_43488(v4);
    function_11ea4(&g149, v5, v7, v6);
    // 0x4a4a8
    return 0;
}

// Address range: 0x4a4e8 - 0x4a4fc
int32_t function_4a4e8(int32_t a1, int32_t a2, int32_t a3) {
    // 0x4a4e8
    return function_4d9e4(a3, a1, a2);
}

// Address range: 0x4a4fc - 0x4a540
int32_t function_4a4fc(int32_t a1, int32_t a2, uint32_t a3) {
    int32_t * v1 = (int32_t *)(a3 + 4); // 0x4a504
    int32_t v2 = *v1; // 0x4a504
    int32_t v3 = v2 + a2; // 0x4a508
    int32_t v4 = v3; // 0x4a510
    if (v3 >= a3 != v3 != a3) {
        int32_t v5 = *(int32_t *)(a3 + 8); // 0x4a514
        function_11fc4((int32_t *)(v5 + v2), a1, (char)a2, v5);
        v4 = *v1 + a2;
    }
    // 0x4a534
    *v1 = v4;
    return 0;
}

// Address range: 0x4a540 - 0x4a55c
int32_t function_4a540(int32_t data, int32_t size, int32_t stream) {
    int32_t items_written = fwrite((int32_t *)data, size, 1, (struct _IO_FILE *)stream); // 0x4a54c
    return items_written == 1 ? items_written - 1 : -1;
}

// Address range: 0x4a55c - 0x4a584
int32_t function_4a55c(int32_t buf, int32_t nbyte, int32_t fd) {
    int32_t v1 = write(fd, (int32_t *)buf, nbyte); // 0x4a574
    return v1 == nbyte ? nbyte - v1 : -1;
}

// Address range: 0x4a584 - 0x4a590
int32_t function_4a584(int32_t a1, int32_t a2) {
    // 0x4a584
    int32_t v1; // 0x4a584
    return function_11eec(a1, (char *)a2, v1, v1);
}

// Address range: 0x4a590 - 0x4a818
int32_t function_4a590(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x4a590
    return -1;
}

// Address range: 0x4a818 - 0x4a8c8
int32_t function_4a818(uint32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x4a818
    if (a1 % 32 != 0) {
        // 0x4a890
        return -1;
    }
    // 0x4a8a0
    if (a3 == 0) {
        // 0x4a890
        return 0;
    }
    // 0x4a8a8
    return (a1 & 32) == 0 ? (int32_t)&g264 : 0;
}

// Address range: 0x4a8c8 - 0x4a920
int32_t function_4a8c8(int32_t a1, int32_t a2, int32_t * str) {
    int32_t v1 = (int32_t)str;
    snprintf((char *)str, 11, "%p", (int32_t *)a2);
    if (function_4bc44(a1, v1) != 0) {
        // 0x4a918
        return -1;
    }
    // 0x4a900
    return function_4b9b0(a1, v1, function_4eb60());
}

// Address range: 0x4a920 - 0x4b12c
int32_t function_4a920(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x4a920
    if (a1 == 0) {
        // 0x4a9c0
        return -1;
    }
    int32_t v1 = a2 & -0x10001; // 0x4a93c
    g477 = a1;
    int32_t str; // bp-140, 0x4a920
    int32_t v2; // 0x4aa14
    switch (a1) {
        case 7: {
            // 0x4a9c0
            return (int32_t)"null";
        }
        case 1: {
            // 0x4a9f4
            if (function_4a8c8(a4, 1, &str) != 0) {
                // 0x4a9c0
                return -1;
            }
            // 0x4aa10
            v2 = function_4e5a0(1);
            if ((a2 & 0x10000) == 0) {
                // 0x4a9c0
                return -1;
            }
            // break -> 0x4ae14
            break;
        }
        case 2: {
            int32_t v3 = function_4e768(2); // 0x4aa80
            return function_4a590(v3, function_4e784(2), a5, a6, v1);
        }
        case 3: {
            // 0x4aab8
            function_4e9c4(3);
            snprintf((char *)&str, 100, "%lld", 3);
            return &str;
        }
        case 4: {
            // 0x4aafc
            function_4ea70(4);
            int32_t v4 = __asm_ubfx(v1, 11, 5); // 0x4ab08
            if (function_4dbf0(&str, 100, v4) >= 0) {
                // 0x4ab1c
                return &str;
            }
            // 0x4a9c0
            return -1;
        }
        case 5: {
            // 0x4a9c0
            return (int32_t)"true";
        }
        case 6: {
            // 0x4a9c0
            return (int32_t)"false";
        }
        default: {
            // 0x4a9c0
            return -1;
        }
    }
    if (v2 == 0) {
        // 0x4ae20
        function_4bca4(a4, &str);
        // 0x4a9c0
        return 0;
    }
    int32_t v5 = a3 + 1; // 0x4ad00
    if (function_4a818(v1, v5, 0, a5, a6) != 0) {
        // 0x4a9c0
        return -1;
    }
    int32_t v6 = function_4e5bc(1, 0); // 0x4ad58
    if (v2 == 1 != (function_4a920(v6, v1, v5, a4, a5, a6) == 0) || function_4a818(v1, a3, 0, a5, a6) != 0) {
        // 0x4a9c0
        return -1;
    }
    // 0x4add8
    function_4bca4(a4, &str);
    return 0;
}

// Address range: 0x4b130 - 0x4b1a8
int32_t function_4b130(int32_t a1, int32_t * a2, int32_t * a3, int32_t a4) {
    // 0x4b130
    if (a1 != 1 && (a4 & 512) == 0) {
        // 0x4b194
        return -1;
    }
    // 0x4b154
    int32_t v1; // bp-52, 0x4b130
    int32_t v2 = function_4b91c(&v1); // 0x4b168
    int32_t result = -1; // 0x4b170
    if (v2 == 0) {
        // 0x4b174
        result = function_4a920(a1, a4, 0, (int32_t)&v1, (int32_t)a2, (int32_t)a3);
        function_4b998(&v1);
    }
    // 0x4b194
    return result;
}

// Address range: 0x4b1a8 - 0x4b214
int32_t function_4b1a8(int32_t a1, int32_t a2) {
    // 0x4b1a8
    int32_t v1; // bp-28, 0x4b1a8
    if (function_4d954(&v1) != 0) {
        // 0x4b1f4
        return 0;
    }
    int32_t v2 = function_4b130(a1, &g82, &v1, a2); // 0x4b1e0
    int32_t result = 0; // 0x4b1e8
    if (v2 == 0) {
        int32_t v3 = function_4d9c8(&v1); // 0x4b204
        result = function_4d8fc(v3);
    }
    // 0x4b1ec
    function_4d988(&v1);
    // 0x4b1f4
    return result;
}

// Address range: 0x4b214 - 0x4b250
int32_t function_4b214(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = a3; // bp-20, 0x4b22c
    int32_t v2; // 0x4b214
    function_4b130(a1, (int32_t *)0x4a4fc, &v1, v2);
    return 0;
}

// Address range: 0x4b250 - 0x4b264
int32_t function_4b250(int32_t a1, int32_t a2, int32_t a3) {
    // 0x4b250
    return function_4b130(a1, (int32_t *)0x4a540, (int32_t *)a2, a3);
}

// Address range: 0x4b264 - 0x4b2c8
int32_t function_4b264(int32_t a1, int32_t a2, int32_t a3) {
    struct _IO_FILE * file = fopen64((char *)a2, "w"); // 0x4b280
    if (file != NULL) {
        int32_t result = function_4b130(a1, (int32_t *)0x4a540, &file->e0, a3); // 0x4b2a0
        if (fclose(file) == 0) {
            // 0x4b2b8
            return result;
        }
    }
    // 0x4b2b8
    return -1;
}

// Address range: 0x4b2c8 - 0x4b2f4
int32_t function_4b2c8(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = a2; // bp-12, 0x4b2d8
    return function_4b130(a1, (int32_t *)0x4a55c, &v1, a3);
}

// Address range: 0x4b2f4 - 0x4b838
int32_t function_4b2f4(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = a2 - 0x21524111 + a3; // 0x4b308
    int32_t v2; // 0x4b2f4
    int32_t v3; // 0x4b2f4
    int32_t v4; // 0x4b2f4
    int32_t v5; // 0x4b2f4
    int32_t v6; // 0x4b2f4
    int32_t v7; // 0x4b2f4
    int32_t v8; // 0x4b2f4
    int32_t v9; // 0x4b2f4
    int32_t v10; // 0x4b2f4
    int32_t v11; // 0x4b2f4
    int32_t v12; // 0x4b2f4
    int32_t v13; // 0x4b2f4
    int32_t v14; // 0x4b2f4
    int32_t v15; // 0x4b2f4
    int32_t v16; // 0x4b2f4
    int32_t v17; // 0x4b2f4
    int32_t v18; // 0x4b2f4
    int32_t v19; // 0x4b2f4
    int32_t v20; // 0x4b2f4
    int32_t v21; // 0x4b2f4
    int32_t v22; // 0x4b2f4
    int32_t v23; // 0x4b2f4
    int32_t v24; // 0x4b2f4
    int32_t v25; // 0x4b2f4
    int32_t v26; // 0x4b2f4
    int32_t v27; // 0x4b2f4
    int32_t v28; // 0x4b2f4
    int32_t v29; // 0x4b2f4
    int32_t v30; // 0x4b2f4
    int32_t v31; // 0x4b2f4
    int32_t v32; // 0x4b2f4
    int32_t v33; // 0x4b2f4
    int32_t v34; // 0x4b2f4
    int32_t v35; // 0x4b2f4
    int32_t v36; // 0x4b2f4
    int32_t v37; // 0x4b2f4
    int32_t result; // 0x4b2f4
    int32_t v38; // 0x4b2f4
    int32_t v39; // 0x4b2f4
    int32_t v40; // 0x4b2f4
    int32_t v41; // 0x4b2f4
    int32_t v42; // 0x4b2f4
    int32_t v43; // 0x4b2f4
    int32_t v44; // 0x4b2f4
    int32_t v45; // 0x4b2f4
    int32_t v46; // 0x4b2f4
    if (a1 % 4 == 0) {
        // 0x4b310
        v18 = v1;
        v24 = a1;
        int32_t v47 = a2; // 0x4b314
        v38 = v1;
        v3 = v1;
        if (a2 != 12 && a2 >= 12) {
            int32_t v48 = a1 + 12;
            int32_t v49 = a2 - 12; // 0x4b328
            uint32_t v50 = *(int32_t *)(a1 + 8) + v1; // 0x4b33c
            int32_t v51 = *(int32_t *)(a1 + 4) + v1; // 0x4b34c
            uint32_t v52 = v1 - v50 + *(int32_t *)a1 ^ (v50 / 0x10000000 | 16 * v50); // 0x4b350
            int32_t v53 = v51 + v50; // 0x4b354
            int32_t v54 = v52 + v53; // 0x4b35c
            uint32_t v55 = (v52 / 0x4000000 | 64 * v52) ^ v51 - v52; // 0x4b360
            int32_t v56 = v55 + v54; // 0x4b368
            uint32_t v57 = (v55 / 0x1000000 | 256 * v55) ^ v53 - v55; // 0x4b36c
            int32_t v58 = v57 + v56; // 0x4b374
            uint32_t v59 = (v57 / 0x10000 | 0x10000 * v57) ^ v54 - v57; // 0x4b378
            int32_t v60 = v59 + v58; // 0x4b380
            uint32_t v61 = (v59 / 0x2000 | 0x80000 * v59) ^ v56 - v59; // 0x4b384
            int32_t v62 = v61 + v60; // 0x4b38c
            int32_t v63 = (v61 / 0x10000000 | 16 * v61) ^ v58 - v61; // 0x4b390
            int32_t v64 = v49; // 0x4b394
            int32_t v65 = v48; // 0x4b394
            v18 = v62;
            v24 = v48;
            v47 = v49;
            v38 = v63;
            v3 = v60;
            while ((v61 & 0x8000000) != 0 == (v49 != 12)) {
                // 0x4b324
                v48 = v65 + 12;
                v49 = v64 - 12;
                v50 = *(int32_t *)(v65 + 8) + v63;
                v51 = *(int32_t *)(v65 + 4) + v62;
                v52 = v60 - v50 + *(int32_t *)v65 ^ (v50 / 0x10000000 | 16 * v50);
                v53 = v51 + v50;
                v54 = v52 + v53;
                v55 = (v52 / 0x4000000 | 64 * v52) ^ v51 - v52;
                v56 = v55 + v54;
                v57 = (v55 / 0x1000000 | 256 * v55) ^ v53 - v55;
                v58 = v57 + v56;
                v59 = (v57 / 0x10000 | 0x10000 * v57) ^ v54 - v57;
                v60 = v59 + v58;
                v61 = (v59 / 0x2000 | 0x80000 * v59) ^ v56 - v59;
                v62 = v61 + v60;
                v63 = (v61 / 0x10000000 | 16 * v61) ^ v58 - v61;
                v64 = v49;
                v65 = v48;
                v18 = v62;
                v24 = v48;
                v47 = v49;
                v38 = v63;
                v3 = v60;
            }
        }
        // 0x4b398
        g490 = v47 - 1;
        v13 = v18;
        v27 = v24;
        v36 = v38;
        v8 = v3;
        result = v38;
        v15 = v18;
        v28 = v24;
        v39 = v38;
        v2 = v3;
        switch (v47) {
            case 1: {
                goto lab_0x4b63c;
            }
            case 2: {
                goto lab_0x4b698;
            }
            case 3: {
                // 0x4b740
                v14 = v18;
                v37 = v38;
                v9 = *(int32_t *)v24 % 0x1000000 + v3;
                goto lab_0x4b644;
            }
            case 4: {
                // 0x4b6a4
                v14 = v18;
                v37 = v38;
                v9 = *(int32_t *)v24 + v3;
                goto lab_0x4b644;
            }
            case 5: {
                // 0x4b6f0
                v14 = v18 + (int32_t)*(char *)(v24 + 4);
                v37 = v38;
                v9 = *(int32_t *)v24 + v3;
                goto lab_0x4b644;
            }
            case 6: {
                // 0x4b704
                v14 = v18 + (int32_t)*(int16_t *)(v24 + 4);
                v37 = v38;
                v9 = *(int32_t *)v24 + v3;
                goto lab_0x4b644;
            }
            case 7: {
                // 0x4b718
                v14 = *(int32_t *)(v24 + 4) % 0x1000000 + v18;
                v37 = v38;
                v9 = *(int32_t *)v24 + v3;
                goto lab_0x4b644;
            }
            case 8: {
                // 0x4b72c
                v14 = *(int32_t *)(v24 + 4) + v18;
                v37 = v38;
                v9 = *(int32_t *)v24 + v3;
                goto lab_0x4b644;
            }
            case 9: {
                // 0x4b6b0
                v46 = (int32_t)*(char *)(v24 + 8);
                goto lab_0x4b6b4;
            }
            case 10: {
                // 0x4b6cc
                v46 = (int32_t)*(int16_t *)(v24 + 8);
                goto lab_0x4b6b4;
            }
            case 11: {
                // 0x4b6d4
                v14 = *(int32_t *)(v24 + 4) + v18;
                v37 = *(int32_t *)(v24 + 8) % 0x1000000 + v38;
                v9 = *(int32_t *)v24 + v3;
                goto lab_0x4b644;
            }
            case 12: {
                // 0x4b7fc
                v46 = *(int32_t *)(v24 + 8);
                goto lab_0x4b6b4;
            }
            default: {
                return result;
            }
        }
    } else {
        bool v66 = a2 == 12 | a2 < 12;
        if (a1 % 2 == 0) {
            // 0x4b3e0
            v19 = v1;
            v25 = a1;
            int32_t v67 = a2; // 0x4b3e4
            v42 = v1;
            v4 = v1;
            if (!v66) {
                int32_t v68 = a1 + 12;
                int32_t v69 = a2 - 12; // 0x4b3f8
                uint16_t v70 = *(int16_t *)(a1 + 8); // 0x4b3fc
                uint16_t v71 = *(int16_t *)(a1 + 2); // 0x4b404
                uint16_t v72 = *(int16_t *)a1; // 0x4b40c
                uint32_t v73 = (0x10000 * (int32_t)*(int16_t *)(a1 + 10) | (int32_t)v70) + v1; // 0x4b41c
                uint16_t v74 = *(int16_t *)(a1 + 4); // 0x4b420
                uint32_t v75 = v1 - v73 + (0x10000 * (int32_t)v71 | (int32_t)v72) ^ (v73 / 0x10000000 | 16 * v73); // 0x4b434
                int32_t v76 = (0x10000 * (int32_t)*(int16_t *)(a1 + 6) | (int32_t)v74) + v1; // 0x4b438
                int32_t v77 = v76 + v73; // 0x4b440
                uint32_t v78 = (v75 / 0x4000000 | 64 * v75) ^ v76 - v75; // 0x4b444
                int32_t v79 = v77 + v75; // 0x4b448
                int32_t v80 = v78 + v79; // 0x4b450
                uint32_t v81 = (v78 / 0x1000000 | 256 * v78) ^ v77 - v78; // 0x4b454
                int32_t v82 = v81 + v80; // 0x4b45c
                uint32_t v83 = (v81 / 0x10000 | 0x10000 * v81) ^ v79 - v81; // 0x4b460
                int32_t v84 = v83 + v82; // 0x4b468
                uint32_t v85 = (v83 / 0x2000 | 0x80000 * v83) ^ v80 - v83; // 0x4b46c
                int32_t v86 = v85 + v84; // 0x4b474
                int32_t v87 = (v85 / 0x10000000 | 16 * v85) ^ v82 - v85; // 0x4b478
                int32_t v88 = v69; // 0x4b47c
                int32_t v89 = v68; // 0x4b47c
                v19 = v86;
                v25 = v68;
                v67 = v69;
                v42 = v87;
                v4 = v84;
                while ((v85 & 0x8000000) != 0 == (v69 != 12)) {
                    // 0x4b3f4
                    v68 = v89 + 12;
                    uint16_t v90 = *(int16_t *)(v89 + 10); // 0x4b3f4
                    v69 = v88 - 12;
                    v70 = *(int16_t *)(v89 + 8);
                    v71 = *(int16_t *)(v89 + 2);
                    v72 = *(int16_t *)v89;
                    uint16_t v91 = *(int16_t *)(v89 + 6); // 0x4b418
                    v73 = (0x10000 * (int32_t)v90 | (int32_t)v70) + v87;
                    v74 = *(int16_t *)(v89 + 4);
                    v75 = v84 - v73 + (0x10000 * (int32_t)v71 | (int32_t)v72) ^ (v73 / 0x10000000 | 16 * v73);
                    v76 = (0x10000 * (int32_t)v91 | (int32_t)v74) + v86;
                    v77 = v76 + v73;
                    v78 = (v75 / 0x4000000 | 64 * v75) ^ v76 - v75;
                    v79 = v77 + v75;
                    v80 = v78 + v79;
                    v81 = (v78 / 0x1000000 | 256 * v78) ^ v77 - v78;
                    v82 = v81 + v80;
                    v83 = (v81 / 0x10000 | 0x10000 * v81) ^ v79 - v81;
                    v84 = v83 + v82;
                    v85 = (v83 / 0x2000 | 0x80000 * v83) ^ v80 - v83;
                    v86 = v85 + v84;
                    v87 = (v85 / 0x10000000 | 16 * v85) ^ v82 - v85;
                    v88 = v69;
                    v89 = v68;
                    v19 = v86;
                    v25 = v68;
                    v67 = v69;
                    v42 = v87;
                    v4 = v84;
                }
            }
            // 0x4b480
            g491 = v67 - 1;
            v13 = v19;
            v27 = v25;
            v36 = v42;
            v8 = v4;
            result = v42;
            v15 = v19;
            v28 = v25;
            v39 = v42;
            v2 = v4;
            v16 = v19;
            v40 = v42;
            v41 = v42;
            v17 = v19;
            switch (v67) {
                case 1: {
                    goto lab_0x4b63c;
                }
                case 2: {
                    goto lab_0x4b698;
                }
                case 3: {
                    // 0x4b690
                    v15 = v19;
                    v28 = v25;
                    v39 = v42;
                    v2 = 0x10000 * (int32_t)*(char *)(v25 + 2) + v4;
                    goto lab_0x4b698;
                }
                case 4: {
                    goto lab_0x4b7dc;
                }
                case 5: {
                    // 0x4b7d4
                    v17 = v19 + (int32_t)*(char *)(v25 + 4);
                    goto lab_0x4b7dc;
                }
                case 6: {
                    goto lab_0x4b758;
                }
                case 7: {
                    // 0x4b750
                    v16 = 0x10000 * (int32_t)*(char *)(v25 + 6) + v19;
                    goto lab_0x4b758;
                }
                case 8: {
                    goto lab_0x4b77c;
                }
                case 9: {
                    // 0x4b774
                    v40 = v42 + (int32_t)*(char *)(v25 + 8);
                    goto lab_0x4b77c;
                }
                case 10: {
                    goto lab_0x4b7a8;
                }
                case 11: {
                    // 0x4b7a0
                    v41 = 0x10000 * (int32_t)*(char *)(v25 + 10) + v42;
                    goto lab_0x4b7a8;
                }
                case 12: {
                    uint16_t v92 = *(int16_t *)(v25 + 8); // 0x4b804
                    uint16_t v93 = *(int16_t *)(v25 + 10); // 0x4b808
                    uint16_t v94 = *(int16_t *)(v25 + 4); // 0x4b80c
                    uint16_t v95 = *(int16_t *)(v25 + 6); // 0x4b814
                    uint16_t v96 = *(int16_t *)v25; // 0x4b818
                    uint16_t v97 = *(int16_t *)(v25 + 2); // 0x4b81c
                    v14 = v19 + (int32_t)v94 + 0x10000 * (int32_t)v95;
                    v37 = v42 + (int32_t)v92 + 0x10000 * (int32_t)v93;
                    v9 = v4 + (int32_t)v96 + 0x10000 * (int32_t)v97;
                    goto lab_0x4b644;
                }
                default: {
                    return result;
                }
            }
        } else {
            // 0x4b4c0
            v20 = v1;
            v26 = a1;
            int32_t v98 = a2; // 0x4b4cc
            int32_t v99 = v1; // 0x4b4cc
            v5 = v1;
            if (!v66) {
                int32_t v100 = a1 + 12;
                unsigned char v101 = *(char *)(a1 + 10); // 0x4b4dc
                int32_t v102 = a2 - 12; // 0x4b4e0
                unsigned char v103 = *(char *)(a1 + 2); // 0x4b4e4
                unsigned char v104 = *(char *)(a1 + 9); // 0x4b4ec
                unsigned char v105 = *(char *)(a1 + 1); // 0x4b4f4
                unsigned char v106 = *(char *)(a1 + 6); // 0x4b500
                unsigned char v107 = *(char *)a1; // 0x4b508
                unsigned char v108 = *(char *)(a1 + 8); // 0x4b510
                unsigned char v109 = *(char *)(a1 + 11); // 0x4b518
                unsigned char v110 = *(char *)(a1 + 3); // 0x4b524
                unsigned char v111 = *(char *)(a1 + 5); // 0x4b530
                uint32_t v112 = (256 * (int32_t)v104 | 0x10000 * (int32_t)v101 | (int32_t)v108 | 0x1000000 * (int32_t)v109) + v1; // 0x4b534
                unsigned char v113 = *(char *)(a1 + 7); // 0x4b53c
                unsigned char v114 = *(char *)(a1 + 4); // 0x4b540
                uint32_t v115 = v1 - v112 + (256 * (int32_t)v105 | 0x10000 * (int32_t)v103 | (int32_t)v107 | 0x1000000 * (int32_t)v110) ^ (v112 / 0x10000000 | 16 * v112); // 0x4b554
                int32_t v116 = (256 * (int32_t)v111 | 0x10000 * (int32_t)v106 | (int32_t)v114 | 0x1000000 * (int32_t)v113) + v1; // 0x4b55c
                int32_t v117 = v116 + v112; // 0x4b564
                uint32_t v118 = v116 - v115 ^ (v115 / 0x4000000 | 64 * v115); // 0x4b568
                int32_t v119 = v117 + v115; // 0x4b56c
                int32_t v120 = v118 + v119; // 0x4b574
                uint32_t v121 = (v118 / 0x1000000 | 256 * v118) ^ v117 - v118; // 0x4b578
                int32_t v122 = v121 + v120; // 0x4b580
                uint32_t v123 = (v121 / 0x10000 | 0x10000 * v121) ^ v119 - v121; // 0x4b584
                int32_t v124 = v123 + v122; // 0x4b58c
                uint32_t v125 = (v123 / 0x2000 | 0x80000 * v123) ^ v120 - v123; // 0x4b590
                int32_t v126 = v125 + v124; // 0x4b598
                int32_t v127 = (v125 / 0x10000000 | 16 * v125) ^ v122 - v125; // 0x4b59c
                int32_t v128 = v102; // 0x4b5a0
                int32_t v129 = v100; // 0x4b5a0
                v20 = v126;
                v26 = v100;
                v98 = v102;
                v99 = v127;
                v5 = v124;
                while ((v125 & 0x8000000) != 0 == (v102 != 12)) {
                    // 0x4b4dc
                    v100 = v129 + 12;
                    v101 = *(char *)(v129 + 10);
                    v102 = v128 - 12;
                    v103 = *(char *)(v129 + 2);
                    v104 = *(char *)(v129 + 9);
                    v105 = *(char *)(v129 + 1);
                    v106 = *(char *)(v129 + 6);
                    v107 = *(char *)v129;
                    v108 = *(char *)(v129 + 8);
                    v109 = *(char *)(v129 + 11);
                    v110 = *(char *)(v129 + 3);
                    v111 = *(char *)(v129 + 5);
                    v112 = (256 * (int32_t)v104 | 0x10000 * (int32_t)v101 | (int32_t)v108 | 0x1000000 * (int32_t)v109) + v127;
                    v113 = *(char *)(v129 + 7);
                    v114 = *(char *)(v129 + 4);
                    v115 = v124 - v112 + (256 * (int32_t)v105 | 0x10000 * (int32_t)v103 | (int32_t)v107 | 0x1000000 * (int32_t)v110) ^ (v112 / 0x10000000 | 16 * v112);
                    v116 = (256 * (int32_t)v111 | 0x10000 * (int32_t)v106 | (int32_t)v114 | 0x1000000 * (int32_t)v113) + v126;
                    v117 = v116 + v112;
                    v118 = v116 - v115 ^ (v115 / 0x4000000 | 64 * v115);
                    v119 = v117 + v115;
                    v120 = v118 + v119;
                    v121 = (v118 / 0x1000000 | 256 * v118) ^ v117 - v118;
                    v122 = v121 + v120;
                    v123 = (v121 / 0x10000 | 0x10000 * v121) ^ v119 - v121;
                    v124 = v123 + v122;
                    v125 = (v123 / 0x2000 | 0x80000 * v123) ^ v120 - v123;
                    v126 = v125 + v124;
                    v127 = (v125 / 0x10000000 | 16 * v125) ^ v122 - v125;
                    v128 = v102;
                    v129 = v100;
                    v20 = v126;
                    v26 = v100;
                    v98 = v102;
                    v99 = v127;
                    v5 = v124;
                }
            }
            // 0x4b5a4
            g492 = v98 - 1;
            v43 = v99;
            v44 = v99;
            v45 = v99;
            v29 = v99;
            v21 = v20;
            v30 = v99;
            v22 = v20;
            v31 = v99;
            v23 = v20;
            v32 = v99;
            v10 = v20;
            v33 = v99;
            v11 = v20;
            v34 = v99;
            v6 = v5;
            v12 = v20;
            v35 = v99;
            v7 = v5;
            v13 = v20;
            v27 = v26;
            v36 = v99;
            v8 = v5;
            result = v99;
            switch (v98) {
                case 1: {
                    goto lab_0x4b63c;
                }
                case 2: {
                    goto lab_0x4b634;
                }
                case 3: {
                    goto lab_0x4b62c;
                }
                case 4: {
                    goto lab_0x4b624;
                }
                case 5: {
                    goto lab_0x4b61c;
                }
                case 6: {
                    goto lab_0x4b614;
                }
                case 7: {
                    goto lab_0x4b60c;
                }
                case 8: {
                    goto lab_0x4b604;
                }
                case 9: {
                    goto lab_0x4b5fc;
                }
                case 10: {
                    goto lab_0x4b5f4;
                }
                case 11: {
                    goto lab_0x4b5ec;
                }
                case 12: {
                    // 0x4b5e4
                    v43 = 0x1000000 * (int32_t)*(char *)(v26 + 11) + v99;
                    goto lab_0x4b5ec;
                }
                default: {
                    return result;
                }
            }
        }
    }
  lab_0x4b63c:
    // 0x4b63c
    v14 = v13;
    v37 = v36;
    v9 = v8 + (int32_t)*(char *)v27;
    goto lab_0x4b644;
  lab_0x4b698:
    // 0x4b698
    v14 = v15;
    v37 = v39;
    v9 = v2 + (int32_t)*(int16_t *)v28;
    goto lab_0x4b644;
  lab_0x4b644:;
    uint32_t v130 = v14;
    uint32_t v131 = (v37 ^ v130) - (v130 / 0x40000 | 0x4000 * v130); // 0x4b648
    uint32_t v132 = (v131 ^ v9) - (v131 / 0x200000 | 2048 * v131); // 0x4b650
    uint32_t v133 = (v132 ^ v130) - (v132 / 128 | 0x2000000 * v132); // 0x4b658
    uint32_t v134 = (v133 ^ v131) - (v133 / 0x10000 | 0x10000 * v133); // 0x4b660
    uint32_t v135 = (v134 ^ v132) - (v134 / 0x10000000 | 16 * v134); // 0x4b668
    uint32_t v136 = (v135 ^ v133) - (v135 / 0x40000 | 0x4000 * v135); // 0x4b670
    result = (v136 ^ v134) - (v136 / 256 | 0x1000000 * v136);
    // 0x4b67c
    return result;
  lab_0x4b6b4:
    // 0x4b6b4
    v14 = *(int32_t *)(v24 + 4) + v18;
    v37 = v46 + v38;
    v9 = *(int32_t *)v24 + v3;
    goto lab_0x4b644;
  lab_0x4b7dc:;
    uint16_t v137 = *(int16_t *)v25; // 0x4b7dc
    uint16_t v138 = *(int16_t *)(v25 + 2); // 0x4b7e0
    v14 = v17;
    v37 = v42;
    v9 = v4 + (int32_t)v137 + 0x10000 * (int32_t)v138;
    goto lab_0x4b644;
  lab_0x4b758:;
    uint16_t v139 = *(int16_t *)v25; // 0x4b758
    uint16_t v140 = *(int16_t *)(v25 + 2); // 0x4b75c
    v14 = v16 + (int32_t)*(int16_t *)(v25 + 4);
    v37 = v42;
    v9 = v4 + (int32_t)v139 + 0x10000 * (int32_t)v140;
    goto lab_0x4b644;
  lab_0x4b77c:;
    uint16_t v141 = *(int16_t *)(v25 + 4); // 0x4b77c
    uint16_t v142 = *(int16_t *)(v25 + 6); // 0x4b780
    uint16_t v143 = *(int16_t *)v25; // 0x4b784
    uint16_t v144 = *(int16_t *)(v25 + 2); // 0x4b788
    v14 = v19 + (int32_t)v141 + 0x10000 * (int32_t)v142;
    v37 = v40;
    v9 = v4 + (int32_t)v143 + 0x10000 * (int32_t)v144;
    goto lab_0x4b644;
  lab_0x4b7a8:;
    uint16_t v145 = *(int16_t *)(v25 + 4); // 0x4b7a8
    uint16_t v146 = *(int16_t *)(v25 + 6); // 0x4b7ac
    uint16_t v147 = *(int16_t *)v25; // 0x4b7b0
    uint16_t v148 = *(int16_t *)(v25 + 2); // 0x4b7b4
    v14 = v19 + (int32_t)v145 + 0x10000 * (int32_t)v146;
    v37 = v41 + (int32_t)*(int16_t *)(v25 + 8);
    v9 = v4 + (int32_t)v147 + 0x10000 * (int32_t)v148;
    goto lab_0x4b644;
  lab_0x4b634:
    // 0x4b634
    v13 = v12;
    v27 = v26;
    v36 = v35;
    v8 = 256 * (int32_t)*(char *)(v26 + 1) + v7;
    goto lab_0x4b63c;
  lab_0x4b62c:
    // 0x4b62c
    v12 = v11;
    v35 = v34;
    v7 = 0x10000 * (int32_t)*(char *)(v26 + 2) + v6;
    goto lab_0x4b634;
  lab_0x4b624:
    // 0x4b624
    v11 = v10;
    v34 = v33;
    v6 = 0x1000000 * (int32_t)*(char *)(v26 + 3) + v5;
    goto lab_0x4b62c;
  lab_0x4b61c:
    // 0x4b61c
    v10 = v23 + (int32_t)*(char *)(v26 + 4);
    v33 = v32;
    goto lab_0x4b624;
  lab_0x4b614:
    // 0x4b614
    v23 = 256 * (int32_t)*(char *)(v26 + 5) + v22;
    v32 = v31;
    goto lab_0x4b61c;
  lab_0x4b60c:
    // 0x4b60c
    v22 = 0x10000 * (int32_t)*(char *)(v26 + 6) + v21;
    v31 = v30;
    goto lab_0x4b614;
  lab_0x4b604:
    // 0x4b604
    v21 = 0x1000000 * (int32_t)*(char *)(v26 + 7) + v20;
    v30 = v29;
    goto lab_0x4b60c;
  lab_0x4b5fc:
    // 0x4b5fc
    v29 = v45 + (int32_t)*(char *)(v26 + 8);
    goto lab_0x4b604;
  lab_0x4b5f4:
    // 0x4b5f4
    v45 = 256 * (int32_t)*(char *)(v26 + 9) + v44;
    goto lab_0x4b5fc;
  lab_0x4b5ec:
    // 0x4b5ec
    v44 = 0x10000 * (int32_t)*(char *)(v26 + 10) + v43;
    goto lab_0x4b5f4;
}

// Address range: 0x4b838 - 0x4b8ac
int32_t function_4b838(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t * v1 = (int32_t *)(a2 + 4);
    int32_t v2 = a4; // 0x4b854
    if (a1 + 12 == a2) {
        // 0x4b894
        v2 = *v1;
        if (v2 == a2) {
            // 0x4b88c
            return 0;
        }
    }
    int32_t v3 = a2;
    if (*(int32_t *)(v3 + 16) == a4) {
        // 0x4b878
        if (function_11eec(v3 + 24, (char *)a3, a4, v2) == 0) {
            // break -> 0x4b88c
            break;
        }
    }
    int32_t result = 0; // 0x4b864
    while (*v1 != v3) {
        // 0x4b868
        v3 += 4;
        if (*(int32_t *)(v3 + 16) == a4) {
            int32_t v4 = function_11eec(v3 + 24, (char *)a3, a4, v2); // 0x4b880
            result = v3;
            if (v4 == 0) {
                // break -> 0x4b88c
                break;
            }
        }
        // 0x4b85c
        result = 0;
    }
    // 0x4b88c
    return result;
}

// Address range: 0x4b8ac - 0x4b91c
int32_t function_4b8ac(int32_t result) {
    int32_t v1 = result + 12; // 0x4b8b0
    int32_t v2 = *(int32_t *)(result + 16); // 0x4b8b4
    if (v2 == v1) {
        // 0x4b918
        return result;
    }
    int32_t v3 = *(int32_t *)(v2 + 20); // 0x4b8c0
    int32_t v4 = *(int32_t *)(v2 + 4); // 0x4b8c4
    int32_t v5; // 0x4b8ac
    int32_t v6 = v5; // 0x4b8cc
    int32_t v7; // 0x4b8ac
    int32_t v8; // 0x4b8e8
    int32_t v9; // 0x4b8d0
    int32_t * v10; // 0x4b8d0
    int32_t v11; // 0x4b8d0
    int32_t v12; // 0x4b8e0
    if (v3 != 0) {
        // 0x4b8d0
        v9 = v3 + 4;
        v10 = (int32_t *)v9;
        v11 = *v10;
        v6 = v5;
        if (v11 != -1) {
            // 0x4b8e0
            v12 = __asm_dmb(v3, v5, v11, v9);
            v7 = *v10;
            v8 = v7 - 1;
            while (__asm_strex(v8, v7) != 0) {
                // 0x4b8e4
                v7 = *v10;
                v8 = v7 - 1;
            }
            // 0x4b8f8
            v6 = 0;
            if (v8 == 0) {
                // 0x4b900
                function_4eb6c(v12);
                v6 = 0;
            }
        }
    }
    int32_t result2 = function_4d898(v2); // 0x4b914
    while (v4 != v1) {
        int32_t v13 = v4;
        int32_t v14 = v6;
        v3 = *(int32_t *)(v13 + 20);
        v4 = *(int32_t *)(v13 + 4);
        v6 = v14;
        if (v3 != 0) {
            // 0x4b8d0
            v9 = v3 + 4;
            v10 = (int32_t *)v9;
            v11 = *v10;
            v6 = v14;
            if (v11 != -1) {
                // 0x4b8e0
                v12 = __asm_dmb(v3, v14, v11, v9);
                v7 = *v10;
                v8 = v7 - 1;
                while (__asm_strex(v8, v7) != 0) {
                    // 0x4b8e4
                    v7 = *v10;
                    v8 = v7 - 1;
                }
                // 0x4b8f8
                v6 = 0;
                if (v8 == 0) {
                    // 0x4b900
                    function_4eb6c(v12);
                    v6 = 0;
                }
            }
        }
        // 0x4b904
        result2 = function_4d898(v13);
    }
    // 0x4b918
    return result2;
}

// Address range: 0x4b91c - 0x4b998
int32_t function_4b91c(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    *a1 = 0;
    int32_t * v2 = (int32_t *)(v1 + 8); // 0x4b930
    *v2 = 3;
    int32_t v3 = function_4d880(64); // 0x4b938
    *(int32_t *)(v1 + 4) = v3;
    if (v3 == 0) {
        // 0x4b988
        return -1;
    }
    int32_t v4 = v1 + 12; // 0x4b950
    int32_t v5 = v1 + 20; // 0x4b954
    *(int32_t *)(v1 + 16) = v4;
    *(int32_t *)v4 = v4;
    *(int32_t *)(v1 + 24) = v5;
    *(int32_t *)v5 = v5;
    int32_t v6 = v3; // 0x4b974
    *(int32_t *)(v6 + 4) = v4;
    *(int32_t *)v6 = v4;
    v6 += 8;
    while (v6 != (8 << *v2) + v3) {
        // 0x4b978
        *(int32_t *)(v6 + 4) = v4;
        *(int32_t *)v6 = v4;
        v6 += 8;
    }
    // 0x4b988
    return 0;
}

// Address range: 0x4b998 - 0x4b9b0
int32_t function_4b998(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    function_4b8ac(v1);
    return function_4d898(*(int32_t *)(v1 + 4));
}

// Address range: 0x4b9b0 - 0x4bc44
int32_t function_4b9b0(uint32_t a1, int32_t a2, int32_t a3) {
    int32_t * v1 = (int32_t *)(a1 + 8); // 0x4b9b8
    uint32_t v2 = *v1; // 0x4b9b8
    int32_t v3; // 0x4b9b0
    int32_t v4; // 0x4b9b0
    int32_t v5; // 0x4b9b0
    int32_t v6; // 0x4b9b0
    int32_t v7; // 0x4ba04
    int32_t * v8; // 0x4ba70
    int32_t v9; // 0x4ba70
    int32_t * v10; // 0x4ba78
    int32_t v11; // 0x4ba78
    if (a1 >> v2 == 0) {
        // 0x4bad4
        v5 = *(int32_t *)(a1 + 4);
        v6 = -1 - (-1 << v2);
    } else {
        uint32_t v12 = v2 + 1; // 0x4b9d0
        int32_t v13 = 8 << v12; // 0x4b9d8
        int32_t v14 = function_4d880(v13); // 0x4b9e8
        if (v14 == 0) {
            // 0x4bc3c
            return -1;
        }
        int32_t * v15 = (int32_t *)(a1 + 4); // 0x4b9f4
        function_4d898(*v15);
        *v15 = v14;
        *v1 = v12;
        v7 = a1 + 12;
        int32_t v16 = v14; // 0x4ba10
        *(int32_t *)(v16 + 4) = v7;
        *(int32_t *)v16 = v7;
        v16 += 8;
        while (v14 + v13 != v16) {
            // 0x4ba14
            *(int32_t *)(v16 + 4) = v7;
            *(int32_t *)v16 = v7;
            v16 += 8;
        }
        int32_t * v17 = (int32_t *)(a1 + 16); // 0x4ba24
        int32_t v18 = *v17; // 0x4ba24
        int32_t * v19 = (int32_t *)v7; // 0x4ba2c
        *v19 = v7;
        int32_t v20 = -1 - (-1 << v12); // 0x4ba30
        *v17 = v7;
        v3 = v18;
        v5 = v14;
        v6 = v20;
        if (v18 != v7) {
            while (true) {
              lab_0x4ba6c_2:
                // 0x4ba6c
                v4 = v3;
                v8 = (int32_t *)(v4 + 4);
                v9 = *v8;
                int32_t v21 = 8 * (*(int32_t *)(v4 + 16) & v20) + v14; // 0x4ba78
                v10 = (int32_t *)v21;
                v11 = *v10;
                if (v11 == v7) {
                    int32_t * v22 = (int32_t *)(v21 + 4); // 0x4ba88
                    if (v7 == *v22) {
                        // 0x4ba94
                        *v8 = v7;
                        *(int32_t *)v4 = *v19;
                        *(int32_t *)(*v19 + 4) = v4;
                        *v19 = v4;
                        *v22 = v4;
                        *v10 = v4;
                        if (v9 == v7) {
                            // break -> 0x4bac0
                            break;
                        }
                        // 0x4ba6c
                        v3 = v9;
                        goto lab_0x4ba6c_2;
                    } else {
                        goto lab_0x4ba44;
                    }
                } else {
                    goto lab_0x4ba44;
                }
            }
          lab_0x4bac0:
            // 0x4bac0
            v5 = *v15;
            v6 = -1 - (-1 << *v1);
        }
    }
    char * str = (char *)a2; // 0x4bae4
    int32_t len = strlen(str); // 0x4bae4
    int32_t v23 = function_4b2f4(a2, len, g150); // 0x4bb00
    int32_t v24 = 8 * (v23 & v6) + v5; // 0x4bb14
    int32_t v25 = function_4b838(a1, v24, a2, v23); // 0x4bb20
    if (v25 != 0) {
        int32_t * v26 = (int32_t *)(v25 + 20); // 0x4bb2c
        int32_t v27 = *v26; // 0x4bb2c
        if (v27 == 0) {
            // 0x4bb68
            *v26 = a3;
            return 0;
        }
        int32_t v28 = v27 + 4; // 0x4bb38
        int32_t * v29 = (int32_t *)v28; // 0x4bb38
        if (*v29 == -1) {
            // 0x4bb68
            *v26 = a3;
            return 0;
        }
        int32_t v30 = __asm_dmb(v27, v24, a2, v28); // 0x4bb48
        int32_t v31 = *v29;
        int32_t v32 = v31 - 1; // 0x4bb50
        while (__asm_strex(v32, v31) != 0) {
            // 0x4bb4c
            v31 = *v29;
            v32 = v31 - 1;
        }
        if (v32 == 0) {
            // 0x4bb74
            function_4eb6c(v30);
        }
        // 0x4bb68
        *v26 = a3;
        return 0;
    }
    int32_t v33 = function_4d880(len + 25); // 0x4bb80
    if (v33 == 0) {
        // 0x4bc3c
        return -1;
    }
    // 0x4bb8c
    *(int32_t *)(v33 + 16) = v23;
    char * dest_str = strncpy((char *)(v33 + 24), str, len + 1); // 0x4bb9c
    int32_t * v34 = (int32_t *)v24; // 0x4bba0
    int32_t v35 = *v34; // 0x4bba0
    int32_t v36 = a1 + 12; // 0x4bba4
    int32_t v37 = v33 + 8; // 0x4bba8
    *(int32_t *)(v33 + 20) = a3;
    int32_t * v38 = (int32_t *)(v33 + 4); // 0x4bbb0
    *v38 = v33;
    int32_t * v39 = (int32_t *)v33; // 0x4bbb8
    *v39 = v33;
    int32_t * v40 = (int32_t *)(v33 + 12); // 0x4bbbc
    *v40 = v37;
    int32_t * v41 = (int32_t *)v37; // 0x4bbc0
    *v41 = v37;
    if (v35 == v36) {
        int32_t * v42 = (int32_t *)(v24 + 4); // 0x4bc10
        if (v36 == *v42) {
            int32_t * v43 = (int32_t *)v36; // 0x4bc1c
            *v39 = *v43;
            *v38 = v36;
            *(int32_t *)(*v43 + 4) = v33;
            *v43 = v33;
            *v42 = v33;
            goto lab_0x4bbe0;
        } else {
            goto lab_0x4bbc8;
        }
    } else {
        goto lab_0x4bbc8;
    }
  lab_0x4ba44:;
    int32_t * v44 = (int32_t *)v11; // 0x4ba44
    *v8 = v11;
    *(int32_t *)v4 = *v44;
    *(int32_t *)(*v44 + 4) = v4;
    *v44 = v4;
    *v10 = v4;
    if (v9 == v7) {
        // break -> 0x4bac0
        goto lab_0x4bac0;
    }
    // 0x4ba6c
    v3 = v9;
    goto lab_0x4ba6c_2;
  lab_0x4bbc8:;
    int32_t * v45 = (int32_t *)v35; // 0x4bbc8
    *v39 = *v45;
    *v38 = v35;
    *(int32_t *)(*v45 + 4) = v33;
    *v45 = v33;
    goto lab_0x4bbe0;
  lab_0x4bbe0:
    // 0x4bbe0
    *v34 = v33;
    int32_t v46 = a1 + 20; // 0x4bbe0
    int32_t * v47 = (int32_t *)v46; // 0x4bbe0
    *v40 = v46;
    *v41 = *v47;
    *(int32_t *)(*v47 + 4) = v37;
    *v47 = v37;
    *(int32_t *)a1 = (int32_t)dest_str + 1;
    return 0;
}

// Address range: 0x4bc44 - 0x4bca4
int32_t function_4bc44(int32_t a1, int32_t str) {
    int32_t v1 = function_4b2f4(str, strlen((char *)str), g150); // 0x4bc70
    uint32_t v2 = *(int32_t *)(a1 + 8); // 0x4bc74
    int32_t v3 = *(int32_t *)(a1 + 4); // 0x4bc7c
    int32_t v4 = function_4b838(a1, 8 * ((-1 << v2 ^ 0x1fffffff) & v1) + v3, str, v1); // 0x4bc94
    int32_t result = 0; // 0x4bc9c
    if (v4 != 0) {
        result = *(int32_t *)(v4 + 20);
    }
    return result;
}

// Address range: 0x4bca4 - 0x4bdc4
int32_t function_4bca4(int32_t a1, int32_t * str) {
    int32_t v1 = (int32_t)str;
    int32_t v2 = function_4b2f4(v1, strlen((char *)str), g150); // 0x4bcd0
    int32_t v3 = *(int32_t *)(a1 + 4); // 0x4bcdc
    int32_t v4 = 8 * ((-1 << *(int32_t *)(a1 + 8) ^ 0x1fffffff) & v2) + v3; // 0x4bcf0
    int32_t v5 = function_4b838(a1, v4, v1, v2); // 0x4bcf8
    if (v5 == 0) {
        // 0x4bdbc
        return -1;
    }
    int32_t * v6 = (int32_t *)v4; // 0x4bd04
    int32_t * v7 = (int32_t *)(v4 + 4); // 0x4bd08
    int32_t v8 = *v7; // 0x4bd08
    int32_t * v9 = (int32_t *)(v5 + 4); // 0x4bd0c
    int32_t v10 = *v9; // 0x4bd0c
    int32_t v11 = *(int32_t *)v5; // 0x4bd14
    if (v5 == *v6) {
        if (v5 == v8) {
            int32_t v12 = v5 == v8 ? a1 + 12 : v8;
            *v7 = v12;
            *v6 = v12;
        } else {
            *v6 = v10;
        }
    } else {
        if (v5 == v8) {
            *v7 = v11;
        }
    }
    // 0x4bd24
    *(int32_t *)(v11 + 4) = v10;
    int32_t v13 = *v9; // 0x4bd28
    int32_t * v14 = (int32_t *)(v5 + 12); // 0x4bd2c
    int32_t v15 = *(int32_t *)(v5 + 20); // 0x4bd30
    *(int32_t *)v13 = v11;
    int32_t v16 = *(int32_t *)(v5 + 8); // 0x4bd38
    *(int32_t *)(v16 + 4) = *v14;
    int32_t v17 = *v14; // 0x4bd44
    *(int32_t *)v17 = v16;
    if (v15 == 0) {
        // 0x4bd5c
        *(int32_t *)a1 = function_4d898(v5) - 1;
        return 0;
    }
    int32_t v18 = v15 + 4; // 0x4bd50
    int32_t * v19 = (int32_t *)v18; // 0x4bd50
    if (*v19 == -1) {
        // 0x4bd5c
        *(int32_t *)a1 = function_4d898(v5) - 1;
        return 0;
    }
    int32_t v20 = __asm_dmb(v15, v13, v17, v18); // 0x4bd7c
    int32_t v21 = *v19;
    int32_t v22 = v21 - 1; // 0x4bd84
    while (__asm_strex(v22, v21) != 0) {
        // 0x4bd80
        v21 = *v19;
        v22 = v21 - 1;
    }
    if (v22 == 0) {
        // 0x4bd9c
        function_4eb6c(v20);
    }
    // 0x4bd5c
    *(int32_t *)a1 = function_4d898(v5) - 1;
    return 0;
}

// Address range: 0x4bdc4 - 0x4be20
int32_t function_4bdc4(int32_t a1) {
    // 0x4bdc4
    function_4b8ac(a1);
    int32_t v1 = a1 + 12; // 0x4bdd4
    uint32_t result = *(int32_t *)(a1 + 8); // 0x4bdd8
    int32_t v2 = *(int32_t *)(a1 + 4); // 0x4bde4
    int32_t v3 = v2; // 0x4bdec
    *(int32_t *)(v3 + 4) = v1;
    *(int32_t *)v3 = v1;
    v3 += 8;
    while (v3 != v2 + (8 << result)) {
        // 0x4bdf0
        *(int32_t *)(v3 + 4) = v1;
        *(int32_t *)v3 = v1;
        v3 += 8;
    }
    int32_t v4 = a1 + 20; // 0x4be00
    *(int32_t *)(a1 + 16) = v1;
    *(int32_t *)v1 = v1;
    *(int32_t *)(a1 + 24) = v4;
    *(int32_t *)v4 = v4;
    *(int32_t *)a1 = 0;
    return result;
}

// Address range: 0x4be20 - 0x4be38
int32_t function_4be20(int32_t a1) {
    int32_t v1 = *(int32_t *)(a1 + 24); // 0x4be20
    return v1 == a1 + 20 ? 0 : v1;
}

// Address range: 0x4be38 - 0x4be98
int32_t function_4be38(int32_t a1, int32_t str) {
    int32_t v1 = function_4b2f4(str, strlen((char *)str), g150); // 0x4be64
    uint32_t v2 = *(int32_t *)(a1 + 8); // 0x4be68
    int32_t v3 = *(int32_t *)(a1 + 4); // 0x4be70
    int32_t v4 = function_4b838(a1, 8 * ((-1 << v2 ^ 0x1fffffff) & v1) + v3, str, v1); // 0x4be88
    return v4 == 0 ? 0 : v4 + 8;
}

// Address range: 0x4be98 - 0x4beb0
int32_t function_4be98(int32_t a1, int32_t a2) {
    int32_t v1 = *(int32_t *)(a2 + 4); // 0x4be98
    return v1 == a1 + 20 ? 0 : v1;
}

// Address range: 0x4beb0 - 0x4beb8
int32_t function_4beb0(int32_t a1) {
    // 0x4beb0
    return a1 + 16;
}

// Address range: 0x4beb8 - 0x4bec0
int32_t function_4beb8(int32_t a1) {
    // 0x4beb8
    return *(int32_t *)(a1 + 12);
}

// Address range: 0x4bec0 - 0x4bf2c
int32_t function_4bec0(int32_t a1, int32_t a2) {
    int32_t * v1 = (int32_t *)(a1 + 12); // 0x4bec8
    int32_t result = *v1; // 0x4bec8
    if (result == 0) {
        // 0x4bf08
        *v1 = a2;
        return 0;
    }
    int32_t v2 = result + 4; // 0x4bed8
    int32_t * v3 = (int32_t *)v2; // 0x4bed8
    if (*v3 == -1) {
        // 0x4bf08
        *v1 = a2;
        return result;
    }
    // 0x4bee4
    int32_t v4; // 0x4bec0
    int32_t result2 = __asm_dmb(result, a2, v4, v2); // 0x4bee8
    int32_t v5 = *v3;
    int32_t v6 = v5 - 1; // 0x4bef0
    while (__asm_strex(v6, v5) != 0) {
        // 0x4beec
        v5 = *v3;
        v6 = v5 - 1;
    }
    // 0x4bf00
    if (v6 != 0) {
        // 0x4bf08
        *v1 = a2;
        return result2;
    }
    int32_t result3 = function_4eb6c(result2); // 0x4bf18
    *v1 = a2;
    return result3;
}

// Address range: 0x4bf2c - 0x4c028
int32_t function_4bf2c(int32_t result) {
    // 0x4bf2c
    if (g150 != 0) {
        // 0x4bf48
        return result;
    }
    while (__asm_strexb(1, (int32_t)g151) != 0) {
        // continue -> 0x4bf5c
    }
    // 0x4bf6c
    if (g151 != 0) {
        int32_t result2 = __asm_dmb(sched_yield(), result, (int32_t)g151, g150); // 0x4bf9c
        while (g150 == 0) {
            // 0x4bf8c
            result2 = __asm_dmb(sched_yield(), result, (int32_t)g151, g150);
        }
        // 0x4bf48
        return result2;
    }
    int32_t v1 = 1; // 0x4bf78
    int32_t v2 = result; // 0x4bf78
    int32_t v3 = 0; // 0x4bf78
    int32_t v4 = &g151; // 0x4bf78
    int32_t v5; // 0x4bf2c
    int32_t tp; // bp-32, 0x4bf2c
    int32_t v6; // 0x4bf2c
    if (result == 0) {
        int32_t fd = open64("/dev/urandom", 0); // 0x4bfb0
        v5 = 0;
        if (fd == -1) {
            goto lab_0x4c000;
        } else {
            int32_t v7 = function_11f40(fd, (int32_t)&tp, 4); // 0x4bfc8
            close(fd);
            v5 = 4;
            if (v7 == 4) {
                int32_t v8 = tp % 256; // 0x4bfe0
                char v9; // 0x4bf2c
                int32_t v10 = 256 * v8 | (int32_t)v9; // 0x4bff0
                int32_t v11 = 256 * v10 | (int32_t)v9; // 0x4bff4
                v1 = v8;
                v3 = v10;
                v4 = v11;
                v6 = 256 * v11 | (int32_t)v9;
                goto lab_0x4c01c;
            } else {
                goto lab_0x4c000;
            }
        }
    } else {
        goto lab_0x4bf7c;
    }
  lab_0x4bf7c:;
    int32_t result3 = __asm_dmb(v1, v2, v3, v4); // 0x4bf7c
    g150 = v2;
    return result3;
  lab_0x4c000:
    // 0x4c000
    gettimeofday((struct timeval *)&tp, NULL);
    int32_t pid = getpid(); // 0x4c014
    v1 = pid;
    v3 = v5;
    v4 = &g151;
    int32_t v12; // 0x4bf2c
    v6 = tp ^ v12 ^ pid;
    goto lab_0x4c01c;
  lab_0x4c01c:;
    int32_t v13 = v6;
    v2 = v13 == 0 ? 1 : v13;
    goto lab_0x4bf7c;
}

// Address range: 0x4c028 - 0x4c04c
int32_t function_4c028(int32_t a1) {
    int32_t * v1 = (int32_t *)(a1 + 4); // 0x4c028
    int32_t v2 = *v1; // 0x4c028
    unsigned char v3 = *(char *)(v2 + a1); // 0x4c030
    if (v3 != 0) {
        *v1 = v2 + 1;
    }
    return v3 == 0 ? -1 : (int32_t)v3;
}

// Address range: 0x4c04c - 0x4c070
int32_t function_4c04c(int32_t a1) {
    uint64_t v1 = *(int64_t *)(a1 + 4); // 0x4c04c
    uint32_t v2 = (int32_t)v1; // 0x4c04c
    int32_t v3 = v2; // 0x4c05c
    if (v2 < (int32_t)(v1 / 0x100000000)) {
        *(int32_t *)(a1 + 8) = v2 + 1;
        v3 = (int32_t)*(char *)(v2 + a1);
    }
    // .thread
    return v2 >= (int32_t)(v1 / 0x100000000) ? -1 : v3;
}

// Address range: 0x4c070 - 0x4c0cc
int32_t function_4c070(int32_t a1) {
    int32_t * v1 = (int32_t *)(a1 + 1028); // 0x4c070
    uint32_t v2 = *v1; // 0x4c070
    int32_t * v3 = (int32_t *)(a1 + 1024); // 0x4c074
    if (v2 < *v3) {
        // 0x4c0b4
        *v1 = v2 + 1;
        return (int32_t)*(char *)(v2 + a1);
    }
    // 0x4c088
    *v1 = 0;
    *v3 = a1;
    uint32_t v4 = a1 + 2; // 0x4c0a8
    if (v4 < a1 - 1 == (v4 != 0)) {
        // 0x4c0c4
        return -1;
    }
    int32_t v5 = *v1;
    *v1 = v5 + 1;
    return (int32_t)*(char *)(v5 + a1);
}

// Address range: 0x4c0cc - 0x4c1fc
int32_t function_4c0cc(int32_t a1, int32_t a2, int32_t a3, char * format) {
    // 0x4c0cc
    if (a1 == 0) {
        // 0x4c188
        return 0;
    }
    // 0x4c0e0
    int32_t v1; // 0x4c0cc
    int32_t str; // bp-360, 0x4c0cc
    vsnprintf((char *)&str, 160, format, (int32_t)&v1);
    int32_t v2 = a3; // 0x4c110
    int32_t v3 = -1; // 0x4c110
    int32_t v4 = -1; // 0x4c110
    int32_t v5 = 0; // 0x4c110
    int32_t str2; // bp-200, 0x4c0cc
    int32_t v6; // 0x4c120
    int32_t v7; // 0x4c124
    int32_t v8; // 0x4c128
    if (a2 == 0) {
        return function_4f95c(a1, v4, v3, v5, v2, (int32_t)"%s");
    } else {
        int32_t v9 = function_4d9c8((int32_t *)(a2 + 40)); // 0x4c118
        v6 = *(int32_t *)(a2 + 24);
        v7 = *(int32_t *)(a2 + 28);
        v8 = *(int32_t *)(a2 + 36);
        if (v9 == 0) {
            goto lab_0x4c198;
        } else {
            char * v10 = (char *)v9; // 0x4c130
            if (*v10 == 0) {
                goto lab_0x4c198;
            } else {
                uint32_t v11 = *(int32_t *)(a2 + 44); // 0x4c13c
                v2 = a3;
                v3 = v7;
                v4 = v6;
                v5 = v8;
                if (v11 == 20 || v11 < 20) {
                    // 0x4c1d4
                    snprintf((char *)&str2, 160, "%s near '%s'", &str, v10);
                    v2 = a3;
                    v3 = v7;
                    v4 = v6;
                    v5 = v8;
                }
                return function_4f95c(a1, v4, v3, v5, v2, (int32_t)"%s");
            }
        }
    }
    // 0x4c188
    return function_4f95c(a1, v4, v3, v5, v2, (int32_t)"%s");
  lab_0x4c198:;
    int32_t v12 = a3 == 8 ? 6 : a3;
    v2 = v12;
    v3 = v7;
    v4 = v6;
    v5 = v8;
    if (*(int32_t *)(a2 + 20) != -2) {
        // 0x4c1ac
        snprintf((char *)&str2, 160, "%s near end of file", &str);
        v2 = v12;
        v3 = v7;
        v4 = v6;
        v5 = v8;
    }
    return function_4f95c(a1, v4, v3, v5, v2, (int32_t)"%s");
}

// Address range: 0x4c1fc - 0x4c23c
int32_t function_4c1fc(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    if (*(int32_t *)(v1 + 60) != 256) {
        // 0x4c210
        return function_4d988((int32_t *)(v1 + 40));
    }
    int32_t * v2 = (int32_t *)(v1 + 64); // 0x4c21c
    function_4d898(*v2);
    *v2 = 0;
    *(int32_t *)(v1 + 68) = 0;
    return function_4d988((int32_t *)(v1 + 40));
}

// Address range: 0x4c23c - 0x4c268
int32_t function_4c23c(int32_t a1) {
    // 0x4c23c
    int32_t v1; // bp-9, 0x4c23c
    return function_11f40(a1, (int32_t)&v1, 1) == 1 ? v1 % 256 : -1;
}

// Address range: 0x4c268 - 0x4c2fc
int32_t function_4c268(int32_t a1) {
    if ((char)a1 != 117) {
        // 0x4c2dc
        __assert_fail("str[0] == 'u'", "load.c", 309, "decode_unicode_escape");
        return &g488;
    }
    int32_t v1 = a1;
    int32_t v2 = v1 + 1; // 0x4c284
    unsigned char v3 = *(char *)v2; // 0x4c284
    int32_t v4 = v3; // 0x4c284
    int32_t v5 = 0; // 0x4c288
    unsigned char v6 = v3 - 48;
    int32_t v7; // 0x4c268
    int32_t v8; // 0x4c268
    uint32_t v9; // 0x4c2a0
    bool v10; // 0x4c2a8
    uint32_t v11; // 0x4c2b4
    if (v6 == 9 || v6 < 9) {
        // .thread4
        v7 = v5 - 48 + v4;
    } else {
        // 0x4c2a0
        v9 = v4 - 97;
        v10 = v9 == 25 | v9 < 25;
        v8 = v10 ? v4 - 87 : v4;
        if (v10) {
            // .thread5
            v7 = v8 + v5;
        } else {
            // 0x4c2b4
            v11 = v8 - 65;
            if (v11 >= 25 == (v11 != 25)) {
                // break -> 0x4c2d0
                break;
            }
            // 0x4c2c0
            v7 = v8 + v5 - 55;
        }
    }
    int32_t v12 = v7; // 0x4c2d0
    int32_t result = v12; // 0x4c2cc
    while (v1 != a1 + 3) {
        // 0x4c284
        v1 = v2;
        v2 = v1 + 1;
        v3 = *(char *)v2;
        v4 = v3;
        v5 = 16 * v12;
        v6 = v3 - 48;
        if (v6 == 9 || v6 < 9) {
            // .thread4
            v7 = v5 - 48 + v4;
        } else {
            // 0x4c2a0
            v9 = v4 - 97;
            v10 = v9 == 25 | v9 < 25;
            v8 = v10 ? v4 - 87 : v4;
            if (v10) {
                // .thread5
                v7 = v8 + v5;
            } else {
                // 0x4c2b4
                v11 = v8 - 65;
                result = -1;
                if (v11 >= 25 == (v11 != 25)) {
                    // break -> 0x4c2d0
                    break;
                }
                // 0x4c2c0
                v7 = v8 + v5 - 55;
            }
        }
        // 0x4c2c8
        v12 = v7;
        result = v12;
    }
    // 0x4c2d0
    return result;
}

// Address range: 0x4c2fc - 0x4c3b4
int32_t function_4c2fc(int32_t result, int32_t a2) {
    int32_t v1 = a2 + 2; // 0x4c2fc
    if (v1 == 1 || v1 == 0) {
        return result;
    }
    int32_t * v2 = (int32_t *)(result + 36); // 0x4c308
    *v2 = *v2 - 1;
    int32_t v3 = a2; // 0x4c324
    int32_t v4; // 0x4c2fc
    if (a2 == 10) {
        int32_t * v5 = (int32_t *)(result + 24); // 0x4c328
        *v5 = *v5 - 1;
        *(int32_t *)(result + 28) = *(int32_t *)(result + 32);
        v4 = result;
        goto lab_0x4c33c;
    } else {
        goto lab_0x4c37c;
    }
  lab_0x4c37c:;
    int32_t v6 = function_4de1c(v3 % 256); // 0x4c380
    if (v6 != 0) {
        int32_t * v7 = (int32_t *)(result + 28);
        *v7 = *v7 - 1;
    }
    // .thread
    v4 = v6;
    goto lab_0x4c33c;
  lab_0x4c33c:;
    int32_t * v8 = (int32_t *)(result + 16); // 0x4c33c
    int32_t v9 = *v8; // 0x4c33c
    if (v9 == 0) {
        // 0x4c398
        __assert_fail("stream->buffer_pos > 0", "load.c", 238, "stream_unget");
        return &g488;
    }
    int32_t v10 = v9 - 1; // 0x4c348
    *v8 = v10;
    int32_t result2 = v4; // 0x4c35c
    if ((int32_t)*(char *)(result + 8 + v10) == a2) {
        return result2;
    }
    // 0x4c360
    __assert_fail("stream->buffer[stream->buffer_pos] == c", "load.c", 240, "stream_unget");
    v3 = (int32_t)"load.c";
    goto lab_0x4c37c;
}

// Address range: 0x4c3b8 - 0x4c53c
int32_t function_4c3b8(int32_t a1) {
    int32_t * v1 = (int32_t *)(a1 + 16); // 0x4c3b8
    int32_t v2 = *v1; // 0x4c3b8
    int32_t v3 = v2 + a1; // 0x4c3c8
    unsigned char v4 = *(char *)(v3 + 8); // 0x4c3cc
    int32_t v5 = v2 + 1;
    int32_t v6 = v5; // 0x4c3d8
    int32_t v7 = v3; // 0x4c3d8
    if (v4 == 0) {
        int32_t * v8 = (int32_t *)(a1 + 4); // 0x4c3e4
        uint32_t v9 = *v8; // 0x4c3e4
        if (v9 == -1) {
            *(int32_t *)(a1 + 20) = -1;
            // 0x4c454
            return -1;
        }
        uint32_t v10 = v9 - 128; // 0x4c3fc
        *v1 = (int32_t)v4;
        int32_t v11 = a1 + 8;
        *(char *)v11 = (char)v9;
        if (v10 >= 127 == (v10 != 127)) {
            *(char *)(a1 + 9) = 0;
        }
        int32_t v12; // 0x4c3b8
        int32_t v13 = v4 == 0 ? v12 : v5;
        v6 = v10 >= 127 == (v10 != 127) ? 1 : v13;
        v7 = v10 >= 127 == (v10 != 127) ? a1 : v10;
        if (v10 == 127 || v10 < 127) {
            int32_t v14 = function_4de1c(v9 % 256); // 0x4c488
            if (v14 == 0) {
                // 0x4c4f4
                *(int32_t *)(a1 + 20) = -2;
                function_4c0cc(v13, a1, 5, "unable to decode byte 0x%x");
                // 0x4c454
                return -2;
            }
            if (v14 == 1) {
                // 0x4c520
                __assert_fail("count >= 2", "load.c", 189, "stream_get");
                return &g488;
            }
            int32_t v15 = v14 + v11;
            int32_t v16 = a1 + 9; // 0x4c4b4
            *(char *)v16 = (char)*v8;
            v16++;
            while ((v14 == 1 ? v12 : v15) != v16) {
                // 0x4c4a8
                *(char *)v16 = (char)*v8;
                v16++;
            }
            // 0x4c4c0
            if (function_4de88(v14 == 1 ? v12 : v11, v14, 0) == 0) {
                // 0x4c4f4
                *(int32_t *)(a1 + 20) = -2;
                function_4c0cc(v13, a1, 5, "unable to decode byte 0x%x");
                // 0x4c454
                return -2;
            }
            // 0x4c4d8
            *(char *)v15 = 0;
            int32_t v17 = *v1; // 0x4c4e4
            v6 = v17 + 1;
            v7 = v17 + a1;
        }
    }
    // 0x4c420
    *v1 = v6;
    unsigned char v18 = *(char *)(v7 + 8); // 0x4c424
    int32_t * v19 = (int32_t *)(a1 + 36); // 0x4c428
    *v19 = *v19 + 1;
    if (v18 != 10) {
        int32_t result = v18; // 0x4c424
        if (function_4de1c(result) != 0) {
            int32_t * v20 = (int32_t *)(a1 + 28);
            *v20 = *v20 + 1;
        }
        // 0x4c454
        return result;
    }
    int32_t * v21 = (int32_t *)(a1 + 24); // 0x4c460
    int32_t * v22 = (int32_t *)(a1 + 28); // 0x4c468
    *v22 = 0;
    *v21 = *v21 + 1;
    *(int32_t *)(a1 + 32) = *v22;
    return 10;
}

// Address range: 0x4c540 - 0x4c580
int32_t function_4c540(int32_t a1) {
    int32_t v1 = *(int32_t *)(a1 + 20); // 0x4c548
    int32_t result = v1; // 0x4c550
    if (v1 == 0) {
        // 0x4c574
        result = function_4c3b8(a1);
    }
    int32_t v2 = result + 2; // 0x4c554
    if (v2 != 1 && v2 != 0) {
        // 0x4c560
        function_4dab0(a1 + 40, result % 256);
    }
    // 0x4c56c
    return result;
}

// Address range: 0x4c580 - 0x4c5c8
int32_t function_4c580(int32_t result, int32_t result2) {
    int32_t v1 = result2 + 2; // 0x4c580
    if (v1 == 1 || v1 == 0) {
        return result;
    }
    // 0x4c58c
    function_4c2fc(result, result2);
    if (function_4dad4(result + 40) == result2) {
        return result2;
    }
    // 0x4c5ac
    __assert_fail("c == d", "load.c", 282, "lex_unget_unsave");
    return &g488;
}

// Address range: 0x4c5cc - 0x4cddc
int32_t function_4c5cc(int32_t a1, int32_t a2) {
    int32_t v1 = a1 + 40; // 0x4c5d0
    function_4d9b4(v1);
    int32_t * v2 = (int32_t *)(a1 + 60); // 0x4c5e8
    if (*v2 == 256) {
        int32_t * v3 = (int32_t *)(a1 + 64); // 0x4c750
        function_4d898(*v3);
        *v3 = 0;
        *(int32_t *)(a1 + 68) = 0;
    }
    int32_t * v4 = (int32_t *)(a1 + 20); // 0x4c5f4
    int32_t v5 = *v4; // 0x4c5f4
    int32_t v6 = v5; // 0x4c5fc
    if (v5 == 0) {
        // 0x4c728
        v6 = function_4c3b8(a1);
    }
    int32_t result = v6;
    int32_t v7 = result - 9; // 0x4c600
    while (result == 13 || result == 32 | v7 == 1 || (result == 32 ? result < 32 : v7 == 0)) {
        // 0x4c5f4
        v5 = *v4;
        v6 = v5;
        if (v5 == 0) {
            // 0x4c728
            v6 = function_4c3b8(a1);
        }
        // 0x4c600
        result = v6;
        v7 = result - 9;
    }
    switch (result) {
        case -1: {
            // .thread
            *v2 = 0;
            // 0x4c71c
            return 0;
        }
        case -2: {
            // 0x4c714
            *v2 = -1;
            // 0x4c71c
            return -1;
        }
    }
    // 0x4c638
    function_4dab0(v1, result % 256);
    int32_t v8 = result & -33; // 0x4c644
    if ((v8 - 91 & -3) == 0) {
        // 0x4c740
        *v2 = result;
        return result;
    }
    int32_t result2 = result; // 0x4c5cc
    int32_t v9; // 0x4c5cc
    char v10; // 0x4c5cc
    int32_t v11; // 0x4c5cc
    char v12; // 0x4c5cc
    int32_t v13; // 0x4c5cc
    int32_t v14; // 0x4c5cc
    int32_t v15; // 0x4c5cc
    int32_t v16; // 0x4c5cc
    int32_t v17; // 0x4c5cc
    int32_t v18; // 0x4c5cc
    int64_t endptr; // bp-48, 0x4c5cc
    uint32_t v19; // 0x4c670
    int32_t * v20; // 0x4c76c
    switch (result) {
        case 58: {
            goto lab_0x4c740;
        }
        case 44: {
            goto lab_0x4c740;
        }
        case 34: {
            // 0x4c768
            v20 = (int32_t *)(a1 + 64);
            *v20 = 0;
            *v2 = -1;
            while (true) {
                int32_t v21; // 0x4c7b4
                while (true) {
                  lab_0x4c77c:;
                    int32_t v22 = function_4c540(a1); // 0x4c780
                    while (true) {
                      lab_0x4c784:;
                        uint32_t v23 = v22;
                        switch (v23) {
                            case 34: {
                                goto lab_0x4ca80;
                            }
                            case -2: {
                                goto lab_0x4c808;
                            }
                            case -1: {
                                // 0x4cc60
                                function_4c0cc(a2, a1, 6, "premature end of input");
                                goto lab_0x4c808;
                            }
                            default: {
                                if (v23 == 31 || v23 < 31) {
                                    // 0x4ca4c
                                    function_4c580(a1, v23);
                                    if (v23 == 10) {
                                        // 0x4cc7c
                                        function_4c0cc(a2, a1, 8, "unexpected newline");
                                        goto lab_0x4c808;
                                    } else {
                                        // 0x4ca60
                                        function_4c0cc(a2, a1, 8, "control character 0x%x");
                                        goto lab_0x4c808;
                                    }
                                }
                                if (v23 == 92) {
                                    // 0x4c7b4
                                    v21 = function_4c540(a1);
                                    switch (v21) {
                                        case 117: {
                                            int32_t v24 = function_4c540(a1); // 0x4c9c4
                                            int32_t v25 = 4; // 0x4c9c4
                                            while (true) {
                                              lab_0x4c9c8:;
                                                int32_t v26 = v25;
                                                int32_t v27 = v24;
                                                uint32_t v28 = (v27 & -33) - 65; // 0x4c9d0
                                                bool v29 = v28 == 5; // 0x4c9d8
                                                bool v30 = v28 >= 5; // 0x4c9d8
                                                if (v28 >= 5 == (v28 != 5)) {
                                                    uint32_t v31 = v27 - 48; // 0x4c9cc
                                                    v29 = v31 == 9;
                                                    v30 = v31 >= 9;
                                                }
                                                if (v30 == !v29) {
                                                    // 0x4c7f0
                                                    function_4c0cc(a2, a1, 8, "invalid escape");
                                                    goto lab_0x4c808;
                                                }
                                                // 0x4c9e0
                                                v24 = function_4c540(a1);
                                                v22 = v24;
                                                v25 = v26 - 1;
                                                if (v26 == 1) {
                                                    goto lab_0x4c784;
                                                } else {
                                                    goto lab_0x4c9c8;
                                                }
                                            }
                                        }
                                        case 98: {
                                            goto lab_0x4c774;
                                        }
                                        case 92: {
                                            goto lab_0x4c774;
                                        }
                                        case 34: {
                                            goto lab_0x4c774;
                                        }
                                        case 110: {
                                            goto lab_0x4c774;
                                        }
                                        case 102: {
                                            goto lab_0x4c774;
                                        }
                                        case 47: {
                                            goto lab_0x4c774;
                                        }
                                        default: {
                                            goto lab_0x4c7e4;
                                        }
                                    }
                                } else {
                                    goto lab_0x4c77c;
                                }
                            }
                        }
                    }
                }
              lab_0x4c7e4:
                if ((v21 - 114 & -3) != 0) {
                    // 0x4c7f0
                    function_4c0cc(a2, a1, 8, "invalid escape");
                    goto lab_0x4c808;
                }
              lab_0x4c774:;
            }
          lab_0x4ca80:;
            int32_t v32 = function_4d880(*(int32_t *)(a1 + 44) + 1); // 0x4ca88
            if (v32 != 0) {
                // 0x4ca94
                *v20 = v32;
                int32_t v33 = function_4d9c8((int32_t *)v1) + 1; // 0x4caa4
                char v34 = *(char *)v33; // 0x4cab0
                v18 = v32;
                if (v34 == 34) {
                  lab_0x4cc98:
                    // 0x4cc98
                    *(char *)v18 = 0;
                    *v2 = 256;
                    *(int32_t *)(a1 + 68) = v18 - *v20;
                    // 0x4c71c
                    return 256;
                }
                // 0x4cabc
                v10 = v34;
                v16 = v32;
                v13 = v33;
                while (true) {
                  lab_0x4cabc:
                    // 0x4cabc
                    v14 = v13;
                    v17 = v16;
                    char v35 = v10;
                    int32_t v36 = v14 + 1;
                    if (v35 == 92) {
                        char v37 = *(char *)v36; // 0x4cad4
                        switch (v37) {
                            case 117: {
                                int32_t v38 = function_4c268(v36); // 0x4cb1c
                                if (v38 < 0) {
                                    // break -> 0x4ccd8
                                    break;
                                }
                                uint32_t v39 = v38 - 0xd800; // 0x4cb28
                                int32_t v40 = v14 + 6; // 0x4cb2c
                                int32_t v41; // 0x4c5cc
                                int32_t v42; // 0x4c5cc
                                if (v39 < 1024) {
                                    // 0x4cb3c
                                    if (*(char *)v40 != 92) {
                                        // 0x4cd2c
                                        function_4c0cc(a2, a1, 8, "invalid Unicode '\\u%04X'");
                                        goto lab_0x4c808;
                                    }
                                    int32_t v43 = v14 + 7; // 0x4cb4c
                                    if (*(char *)v43 != 117) {
                                        // 0x4cd2c
                                        function_4c0cc(a2, a1, 8, "invalid Unicode '\\u%04X'");
                                        goto lab_0x4c808;
                                    }
                                    int32_t v44 = function_4c268(v43); // 0x4cb5c
                                    if (v44 < 0) {
                                        // break -> 0x4ccd8
                                        break;
                                    }
                                    uint32_t v45 = v44 - 0xdc00; // 0x4cb70
                                    if (v45 >= 1024) {
                                        // 0x4cdb8
                                        function_4c0cc(a2, a1, 8, "invalid Unicode '\\u%04X\\u%04X'");
                                        goto lab_0x4c808;
                                    }
                                    // 0x4cb80
                                    v42 = v14 + 12;
                                    v41 = 1024 * v39 + 0x10000 + v45;
                                } else {
                                    // 0x4ccbc
                                    v42 = v40;
                                    v41 = v38;
                                    if ((v38 & -1024) == 0xdc00) {
                                        // 0x4cd2c
                                        function_4c0cc(a2, a1, 8, "invalid Unicode '\\u%04X'");
                                        goto lab_0x4c808;
                                    }
                                }
                                // 0x4cb88
                                if (function_4dd30(v41, v17, (int32_t *)&endptr) != 0) {
                                    // 0x4cd9c
                                    __assert_fail("0", "load.c", 452, "lex_scan_string");
                                    // 0x4cdb8
                                    function_4c0cc(a2, a1, 8, "invalid Unicode '\\u%04X\\u%04X'");
                                    goto lab_0x4c808;
                                }
                                // 0x4cba0
                                v15 = v42;
                                v9 = endptr;
                                goto lab_0x4cab0;
                            }
                            case 98: {
                                // 0x4cc58
                                *(char *)v17 = 8;
                                // 0x4cb10
                                v15 = v14 + 2;
                                v9 = 1;
                                goto lab_0x4cab0;
                            }
                            default: {
                                if (v37 < 98) {
                                    // 0x4cc24
                                    v12 = v37;
                                    switch (v37) {
                                        case 92: {
                                            goto lab_0x4cc14;
                                        }
                                        case 47: {
                                            goto lab_0x4cc14;
                                        }
                                        case 34: {
                                            goto lab_0x4cc14;
                                        }
                                        default: {
                                            goto lab_0x4cc3c;
                                        }
                                    }
                                } else {
                                    if (v37 == 110) {
                                        // 0x4cc1c
                                        *(char *)v17 = 10;
                                        // 0x4cb10
                                        v15 = v14 + 2;
                                        v9 = 1;
                                        goto lab_0x4cab0;
                                    } else {
                                        if (v37 < 110) {
                                            // 0x4cc08
                                            v12 = 12;
                                            if (v37 == 102) {
                                                goto lab_0x4cc14;
                                            } else {
                                                goto lab_0x4cc3c;
                                            }
                                        } else {
                                            switch (v37) {
                                                case 114: {
                                                    // 0x4cc00
                                                    *(char *)v17 = 13;
                                                    // 0x4cb10
                                                    v15 = v14 + 2;
                                                    v9 = 1;
                                                    goto lab_0x4cab0;
                                                }
                                                case 116: {
                                                    // 0x4cb08
                                                    *(char *)v17 = 9;
                                                    // 0x4cb10
                                                    v15 = v14 + 2;
                                                    v9 = 1;
                                                    goto lab_0x4cab0;
                                                }
                                                default: {
                                                    goto lab_0x4cc3c;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        *(char *)v17 = v35;
                        v15 = v36;
                        v9 = 1;
                        goto lab_0x4cab0;
                    }
                }
                // 0x4ccd8
                function_4c0cc(a2, a1, 8, "invalid Unicode escape '%.6s'");
            }
            goto lab_0x4c808;
        }
        default: {
            // 0x4c670
            v19 = result - 48;
            if (result != 45 && v19 != 9 && !((result == 45 ? result < 45 : v19 < 9))) {
                uint32_t v46 = v8 - 65; // 0x4c680
                if (v46 >= 25 == (v46 != 25)) {
                    int32_t * v47 = (int32_t *)(a1 + 16); // 0x4c8d8
                    int32_t v48 = a1 + 8;
                    char v49 = *(char *)(*v47 + v48); // 0x4c8e0
                    if (v49 == 0) {
                        // 0x4c714
                        *v2 = -1;
                        // 0x4c71c
                        return -1;
                    }
                    int32_t * v50 = (int32_t *)(a1 + 36);
                    function_4dab0(v1, (int32_t)v49);
                    int32_t v51 = *v47 + 1; // 0x4c8fc
                    *v47 = v51;
                    *v50 = *v50 + 1;
                    char v52 = *(char *)(v51 + v48); // 0x4c910
                    while (v52 != 0) {
                        // 0x4c8ec
                        function_4dab0(v1, (int32_t)v52);
                        v51 = *v47 + 1;
                        *v47 = v51;
                        *v50 = *v50 + 1;
                        v52 = *(char *)(v51 + v48);
                    }
                    // 0x4c714
                    *v2 = -1;
                    // 0x4c71c
                    return -1;
                }
                int32_t v53 = function_4c540(a1); // 0x4c694
                uint32_t v54 = (v53 & -33) - 65; // 0x4c69c
                while (v54 == 25 || v54 < 25) {
                    // 0x4c68c
                    v53 = function_4c540(a1);
                    v54 = (v53 & -33) - 65;
                }
                // 0x4c6a8
                function_4c580(a1, v53);
                int32_t v55 = function_4d9c8((int32_t *)v1); // 0x4c6b8
                int32_t v56 = function_11eec(v55, "true", v19, v54); // 0x4c6c8
                int32_t v57 = v56 == 0 ? 259 : v55;
                if (v56 == 0) {
                    *v2 = v57;
                    // 0x4c71c
                    return 259;
                }
                // 0x4c6dc
                result2 = 260;
                if (function_11eec(v57, "false", v19, v54) == 0) {
                  lab_0x4c740:
                    // 0x4c740
                    *v2 = result2;
                    return result2;
                }
                // 0x4c6f4
                if (function_11eec(v57, "null", v19, v54) != 0) {
                    // 0x4c714
                    *v2 = -1;
                    // 0x4c71c
                    return -1;
                }
                *v2 = 261;
                // 0x4c71c
                return 261;
            }
            // 0x4c824
            *v2 = -1;
            switch (result) {
                case 45: {
                    int32_t v58 = function_4c540(a1); // 0x4cbe0
                    if (v58 == 48) {
                        goto lab_0x4cbac;
                    } else {
                        uint32_t v59 = v58 - 48; // 0x4cbf0
                        v11 = v58;
                        if (v59 == 9 || v59 < 9) {
                            goto lab_generated_0;
                        } else {
                            goto lab_0x4cbc8;
                        }
                    }
                }
                case 48: {
                    goto lab_0x4cbac;
                }
                default: {
                    goto lab_generated_1;
                }
            }
        }
    }
  lab_0x4cab0:;
    int32_t v60 = v9 + v17;
    char v61 = *(char *)v15; // 0x4cab0
    v10 = v61;
    v16 = v60;
    v13 = v15;
    v18 = v60;
    if (v61 == 34) {
        goto lab_0x4cc98;
    }
    goto lab_0x4cabc;
  lab_0x4cc14:
    // 0x4cc14
    *(char *)v17 = v12;
    // 0x4cb10
    v15 = v14 + 2;
    v9 = 1;
    goto lab_0x4cab0;
  lab_0x4cc3c:
    // 0x4cc3c
    __assert_fail("0", "load.c", 464, "lex_scan_string");
    // 0x4cc58
    *(char *)v17 = 8;
    // 0x4cb10
    v15 = v14 + 2;
    v9 = 1;
    goto lab_0x4cab0;
  lab_0x4c808:
    // 0x4c808
    function_4d898(*v20);
    *v20 = 0;
    *(int32_t *)(a1 + 68) = 0;
    // 0x4c71c
    return *v2;
  lab_0x4cbac:;
    int32_t v62 = function_4c540(a1); // 0x4cbb4
    uint32_t v63 = v62 - 48; // 0x4cbb8
    int32_t v64 = v62; // 0x4cbc0
    v11 = v62;
    if (v63 >= 9 == (v63 != 9)) {
        goto lab_0x4c854;
    } else {
        goto lab_0x4cbc8;
    }
  lab_generated_2:;
    int32_t v65 = function_4c540(a1); // 0x4c844
    uint32_t v66 = v65 - 48; // 0x4c848
    v64 = v65;
    while (v66 == 9 || v66 < 9) {
        // 0x4c83c
        v65 = function_4c540(a1);
        v66 = v65 - 48;
        v64 = v65;
    }
    goto lab_0x4c854;
  lab_0x4c854:;
    // 0x4c854
    int32_t v67; // 0x4c5cc
    if ((*(int32_t *)(a1 + 52) & 8) == 0) {
        switch (v64) {
            case 101: {
                goto lab_0x4c968;
            }
            case 46: {
                goto lab_0x4c9fc;
            }
            case 69: {
                goto lab_0x4c968;
            }
            default: {
                // 0x4c874
                function_4c580(a1, v64);
                int32_t str = function_4d9c8((int32_t *)v1); // 0x4c884
                int32_t * v68 = __errno_location(); // 0x4c88c
                *v68 = 0;
                int32_t v69 = &endptr; // 0x4c8a0
                int64_t str_as_ll = strtoll((char *)str, (char **)&endptr, 10); // 0x4c8a4
                int32_t v70 = v69; // 0x4c8b0
                if (*v68 != 34) {
                    // 0x4c8b4
                    if (*(int32_t *)(a1 + 44) + str == (int32_t)endptr) {
                        // 0x4c8c8
                        *(int32_t *)(a1 + 64) = (int32_t)str_as_ll;
                        *(int32_t *)(a1 + 68) = v69;
                        *v2 = 257;
                        // 0x4c71c
                        return 257;
                    }
                    // 0x4cd4c
                    __assert_fail("end == saved_text + lex->saved_text.length", "load.c", 541, "lex_scan_number");
                    v70 = (int32_t)"load.c";
                }
                // 0x4cd68
                function_4c0cc(a2, a1, 15, (char *)(v70 % 2 == 0 ? 0x6a714 : 0x6a6f8));
                // 0x4c71c
                return *v2;
            }
        }
    } else {
        // 0x4c920
        v67 = v64;
        if (v64 == 46) {
            goto lab_0x4c9fc;
        } else {
            goto lab_0x4c928;
        }
    }
  lab_0x4cbc8:
    // 0x4cbc8
    function_4c580(a1, v11);
    // 0x4c71c
    return *v2;
  lab_0x4c968:;
    int32_t v71 = function_4c540(a1); // 0x4c970
    int32_t v72 = v71; // 0x4c97c
    if ((v71 - 43 & -3) == 0) {
        // 0x4c980
        v72 = function_4c540(a1);
    }
    uint32_t v73 = v72 - 48; // 0x4c98c
    v11 = v72;
    int32_t v74; // 0x4c5cc
    int32_t v75; // 0x4c5cc
    if (v73 >= 9 == (v73 != 9)) {
        goto lab_0x4cbc8;
    } else {
        int32_t v76 = function_4c540(a1); // 0x4c9a0
        int32_t v77 = v76 - 48; // 0x4c9a4
        v74 = v76;
        v75 = v77;
        while (v77 == 9 || v77 < 9) {
            // 0x4c998
            v76 = function_4c540(a1);
            v77 = v76 - 48;
            v74 = v76;
            v75 = v77;
        }
        goto lab_0x4c934;
    }
  lab_0x4c9fc:;
    int32_t v78 = *v4; // 0x4c9fc
    int32_t v79 = v78; // 0x4ca04
    if (v78 == 0) {
        // 0x4ca08
        v79 = function_4c3b8(a1);
    }
    uint32_t v80 = v79 - 48; // 0x4ca18
    if (v80 >= 9 == (v80 != 9)) {
        // 0x4ccf0
        function_4c2fc(a1, v79);
        // 0x4c71c
        return *v2;
    }
    // 0x4ca24
    function_4dab0(v1, v79 % 256);
    int32_t v81 = function_4c540(a1); // 0x4ca38
    uint32_t v82 = v81 - 48; // 0x4ca3c
    v67 = v81;
    while (v82 == 9 || v82 < 9) {
        // 0x4ca30
        v81 = function_4c540(a1);
        v82 = v81 - 48;
        v67 = v81;
    }
    goto lab_0x4c928;
  lab_0x4c928:;
    int32_t v83 = v67 & -33; // 0x4c928
    v74 = v67;
    v75 = v83;
    if (v83 == 69) {
        goto lab_0x4c968;
    } else {
        goto lab_0x4c934;
    }
  lab_0x4c934:
    // 0x4c934
    function_4c580(a1, v74);
    int32_t result3; // 0x4c5cc
    if (function_4db00(v1, (int32_t *)&endptr, v19, v75) == 0) {
        uint64_t v84 = 0x100000000 * endptr >> 32; // 0x4c954
        *v2 = 258;
        *(int32_t *)(a1 + 64) = (int32_t)(v84 / 0x100000000);
        *(int32_t *)(a1 + 68) = (int32_t)v84;
        result3 = 258;
    } else {
        // 0x4cd00
        function_4c0cc(a2, a1, 15, "real number overflow");
        result3 = *v2;
    }
    // 0x4c71c
    return result3;
}

// Address range: 0x4cde4 - 0x4d288
int32_t function_4cde4(int32_t a1, uint32_t a2, int32_t a3) {
    int32_t * v1 = (int32_t *)(a1 + 56); // 0x4cde4
    uint32_t v2 = *v1 + 1; // 0x4cdf4
    *v1 = v2;
    if (v2 >= 2048 == (v2 != 2048)) {
        // 0x4d188
        function_4c0cc(a3, a1, 2, "maximum parsing depth reached");
        // 0x4ce58
        return 0;
    }
    int32_t * v3 = (int32_t *)(a1 + 60); // 0x4ce04
    uint32_t v4 = *v3; // 0x4ce04
    int32_t v5; // 0x4cde4
    int32_t v6; // 0x4cde4
    int32_t v7; // 0x4cde4
    int32_t v8; // 0x4cde4
    int32_t v9; // 0x4cde4
    int32_t v10; // 0x4cde4
    int32_t v11; // 0x4cde4
    int32_t result; // 0x4cde4
    int32_t v12; // 0x4d084
    int32_t v13; // 0x4ced4
    if (v4 == 257) {
        uint64_t v14 = *(int64_t *)(a1 + 64); // 0x4d074
        v11 = function_4e990((int32_t)(v14 / 0x100000000), (int32_t)v14);
        goto lab_0x4ce44;
    } else {
        if (v4 > 257) {
            // 0x4ce18
        } else {
            if (v4 == 91) {
                // 0x4d084
                v12 = function_4e540();
                if (v12 == 0) {
                    // 0x4ce58
                    return 0;
                }
                // 0x4d090
                function_4c5cc(a1, a3);
                result = v12;
                switch (*v3) {
                    case 93: {
                        goto lab_0x4ce4c;
                    }
                    case 0: {
                        goto lab_0x4d1b0;
                    }
                    default: {
                        while (true) {
                          lab_0x4d0f0:;
                            int32_t v15 = function_4cde4(a1, a2, a3); // 0x4d0fc
                            v6 = v12;
                            v8 = 0;
                            v10 = a3;
                            if (v15 == 0) {
                                // break -> 0x4d10c
                                break;
                            }
                            // 0x4d0b4
                            v6 = a1;
                            v8 = a3;
                            v10 = a3;
                            if (function_4f494(v12, v15) != 0) {
                                // break -> 0x4d10c
                                break;
                            }
                            // 0x4d0c8
                            function_4c5cc(a1, a3);
                            result = v12;
                            switch (*v3) {
                                case 44: {
                                    // 0x4d0e0
                                    function_4c5cc(a1, a3);
                                    if (*v3 == 0) {
                                        goto lab_0x4d1b0;
                                    }
                                    goto lab_0x4d0f0;
                                }
                                case 93: {
                                    goto lab_0x4ce4c;
                                }
                                default: {
                                    goto lab_0x4d1b0;
                                }
                            }
                        }
                        goto lab_0x4d10c;
                    }
                }
            } else {
                if (v4 <= 91) {
                    if (v4 == -1) {
                        // 0x4d048
                        function_4c0cc(a3, a1, 8, "invalid token");
                        // 0x4ce58
                        return 0;
                    }
                  lab_0x4d14c:
                    // 0x4d14c
                    function_4c0cc(a3, a1, 8, "unexpected token");
                    // 0x4ce58
                    return 0;
                }
                switch (v4) {
                    case 123: {
                        // 0x4ced4
                        v13 = function_4e1b0();
                        if (v13 == 0) {
                            // 0x4ce58
                            return 0;
                        }
                        // 0x4cee0
                        function_4c5cc(a1, a3);
                        result = v13;
                        switch (*v3) {
                            case 125: {
                                goto lab_0x4ce4c;
                            }
                            case 256: {
                                int32_t * v16 = (int32_t *)(a1 + 64); // 0x4cf00
                                int32_t v17 = *v16; // 0x4cf00
                                int32_t * v18 = (int32_t *)(a1 + 68); // 0x4cf08
                                *v16 = 0;
                                *v18 = 0;
                                if (v17 == 0) {
                                    // 0x4ce58
                                    return 0;
                                }
                                int32_t v19 = *v18; // 0x4cf20
                                int32_t v20 = v17; // 0x4cf20
                                int32_t v21; // 0x4cde4
                                while (true) {
                                  lab_0x4cfd8:
                                    // 0x4cfd8
                                    v21 = v20;
                                    if (memchr(v21, 0, v19) != 0) {
                                        // break -> 0x4cff4
                                        break;
                                    }
                                    if (a2 % 2 != 0) {
                                        // 0x4cf2c
                                        if (function_4e234(v13, (char *)v21) != 0) {
                                            // 0x4d264
                                            function_4d898(v21);
                                            v5 = function_4c0cc(a3, a1, 14, "duplicate object key");
                                            v7 = a1;
                                            v9 = 14;
                                            goto lab_0x4d014;
                                        }
                                    }
                                    // 0x4cf38
                                    function_4c5cc(a1, a3);
                                    if (*v3 != 58) {
                                        // 0x4d1e8
                                        function_4d898(v21);
                                        v5 = function_4c0cc(a3, a1, 8, "':' expected");
                                        v7 = a1;
                                        v9 = 8;
                                        goto lab_0x4d014;
                                    }
                                    // 0x4cf58
                                    function_4c5cc(a1, a3);
                                    int32_t v22 = function_4cde4(a1, a2, a3); // 0x4cf68
                                    if (v22 == 0) {
                                        // 0x4d20c
                                        v5 = function_4d898(v21);
                                        v7 = v21;
                                        v9 = 0;
                                        goto lab_0x4d014;
                                    }
                                    int32_t v23 = function_4ee2c(v13, v21, v22); // 0x4cf7c
                                    v5 = function_4d898(v21);
                                    v7 = v21;
                                    v9 = v22;
                                    if (v23 != 0) {
                                        goto lab_0x4d014;
                                    }
                                    // 0x4cf8c
                                    function_4c5cc(a1, a3);
                                    result = v13;
                                    switch (*v3) {
                                        case 44: {
                                            // 0x4cfb0
                                            function_4c5cc(a1, a3);
                                            if (*v3 != 256) {
                                                goto lab_0x4d1cc;
                                            }
                                            int32_t v24 = *v16; // 0x4cfc0
                                            *v16 = 0;
                                            *v18 = 0;
                                            v19 = *v18;
                                            v20 = v24;
                                            if (v24 == 0) {
                                                // 0x4ce58
                                                return 0;
                                            }
                                            goto lab_0x4cfd8;
                                        }
                                        case 125: {
                                            goto lab_0x4ce4c;
                                        }
                                        default: {
                                            // 0x4d228
                                            v5 = function_4c0cc(a3, a1, 8, "'}' expected");
                                            v7 = a1;
                                            v9 = 8;
                                            goto lab_0x4d014;
                                        }
                                    }
                                }
                                // 0x4cff4
                                function_4d898(v21);
                                v5 = function_4c0cc(a3, a1, 13, "NUL byte in object key not supported");
                                v7 = a1;
                                v9 = 13;
                                goto lab_0x4d014;
                            }
                            default: {
                                goto lab_0x4d1cc;
                            }
                        }
                    }
                    case 256: {
                        int32_t * v25 = (int32_t *)(a1 + 64); // 0x4ce84
                        int32_t v26 = *v25; // 0x4ce84
                        int32_t * v27 = (int32_t *)(a1 + 68); // 0x4ce88
                        int32_t v28 = *v27; // 0x4ce88
                        if ((a2 & 16) == 0) {
                            // 0x4ce90
                            if (memchr(v26, 0, v28) != 0) {
                                // 0x4d244
                                function_4c0cc(a3, a1, 11, "\\u0000 is not allowed without JSON_ALLOW_NUL");
                            }
                        }
                        int32_t v29 = function_4e6f8(v26, v28); // 0x4ceb0
                        *v25 = 0;
                        *v27 = 0;
                        v11 = v29;
                        goto lab_0x4ce44;
                    }
                    default: {
                        goto lab_0x4d14c;
                    }
                }
            }
        }
    }
  lab_0x4d1b0:
    // 0x4d1b0
    v6 = function_4c0cc(a3, a1, 8, "']' expected");
    v8 = a1;
    v10 = 8;
    goto lab_0x4d10c;
  lab_0x4ce4c:
    // 0x4ce4c
    *v1 = *v1 - 1;
    // 0x4ce58
    return result;
  lab_0x4d014:;
    int32_t v37 = v13 + 4; // 0x4d014
    int32_t * v38 = (int32_t *)v37; // 0x4d014
    if (*v38 == -1) {
        // 0x4ce58
        return 0;
    }
    // 0x4d020
    __asm_dmb(v5, v7, v9, v37);
    int32_t v39 = *v38;
    int32_t v40 = v39 - 1; // 0x4d02c
    int32_t v41 = __asm_strex(v40, v39); // 0x4d030
    int32_t v35 = v40; // 0x4d038
    int32_t v36 = v13; // 0x4d038
    while (v41 != 0) {
        // 0x4d028
        v39 = *v38;
        v40 = v39 - 1;
        v41 = __asm_strex(v40, v39);
        v35 = v40;
        v36 = v13;
    }
    goto lab_0x4d134;
  lab_0x4d1cc:
    // 0x4d1cc
    v5 = function_4c0cc(a3, a1, 8, "string or '}' expected");
    v7 = a1;
    v9 = 8;
    goto lab_0x4d014;
  lab_0x4ce44:
    // 0x4ce44
    result = v11;
    if (v11 == 0) {
        // 0x4ce58
        return 0;
    }
    goto lab_0x4ce4c;
  lab_0x4d10c:;
    int32_t v30 = v12 + 4; // 0x4d10c
    int32_t * v31 = (int32_t *)v30; // 0x4d10c
    if (*v31 == -1) {
        // 0x4ce58
        return 0;
    }
    // 0x4d118
    __asm_dmb(v6, v8, v10, v30);
    int32_t v32 = *v31;
    int32_t v33 = v32 - 1; // 0x4d124
    int32_t v34 = __asm_strex(v33, v32); // 0x4d128
    v35 = v33;
    v36 = v12;
    while (v34 != 0) {
        // 0x4d120
        v32 = *v31;
        v33 = v32 - 1;
        v34 = __asm_strex(v33, v32);
        v35 = v33;
        v36 = v12;
    }
    goto lab_0x4d134;
  lab_0x4d134:
    // 0x4d134
    if (v35 == 0) {
        // 0x4d13c
        function_4eb6c(v36);
    }
    // 0x4ce58
    return 0;
}

// Address range: 0x4d288 - 0x4d38c
int32_t function_4d288(int32_t * a1, int32_t a2, int32_t a3) {
    int32_t v1 = (int32_t)a1;
    *(int32_t *)(v1 + 56) = 0;
    function_4c5cc(v1, a3);
    if ((a2 & 4) == 0) {
        // 0x4d2b0
        if ((*(int32_t *)(v1 + 60) & -33) != 91) {
            // 0x4d370
            function_4c0cc(a3, v1, 8, "'[' or '{' expected");
            // 0x4d2ec
            return 0;
        }
    }
    int32_t result = function_4cde4(v1, a2, a3); // 0x4d2cc
    if (result == 0) {
        // 0x4d2ec
        return 0;
    }
    if ((a2 & 2) == 0) {
        // 0x4d2f4
        function_4c5cc(v1, a3);
        if (*(int32_t *)(v1 + 60) != 0) {
            int32_t v2 = function_4c0cc(a3, v1, 7, "end of file expected"); // 0x4d320
            int32_t v3 = result + 4; // 0x4d324
            int32_t * v4 = (int32_t *)v3; // 0x4d324
            if (*v4 == -1) {
                // 0x4d2ec
                return 0;
            }
            // 0x4d33c
            __asm_dmb(v2, v1, 7, v3);
            int32_t v5 = *v4;
            int32_t v6 = v5 - 1; // 0x4d348
            while (__asm_strex(v6, v5) != 0) {
                // 0x4d344
                v5 = *v4;
                v6 = v5 - 1;
            }
            // 0x4d358
            if (v6 == 0) {
                // 0x4d360
                function_4eb6c(result);
            }
            // 0x4d2ec
            return 0;
        }
    }
    // 0x4d2e0
    if (a3 != 0) {
        *(int32_t *)(a3 + 8) = *(int32_t *)(v1 + 36);
    }
    // 0x4d2ec
    return result;
}

// Address range: 0x4d38c - 0x4d454
int32_t function_4d38c(int32_t a1, int32_t a2, int32_t * a3) {
    int32_t v1 = (int32_t)a3;
    function_4f90c(v1, "<string>");
    if (a1 == 0) {
        // 0x4d434
        function_4c0cc(v1, 0, 4, "wrong arguments");
        // 0x4d428
        return 0;
    }
    int32_t v2 = 0x4c028; // bp-96, 0x4d3d0
    int32_t v3; // bp-56, 0x4d38c
    int32_t v4 = function_4d954(&v3); // 0x4d3f4
    int32_t result = 0; // 0x4d3fc
    if (v4 == 0) {
        // 0x4d400
        result = function_4d288(&v2, a2, v1);
        function_4c1fc(&v2);
    }
    // 0x4d428
    return result;
}

// Address range: 0x4d454 - 0x4d528
int32_t function_4d454(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x4d454
    function_4f90c(a4, "<buffer>");
    if (a1 == 0) {
        // 0x4d508
        function_4c0cc(a4, 0, 4, "wrong arguments");
        // 0x4d4fc
        return 0;
    }
    int32_t v1 = 0x4c04c; // bp-96, 0x4d4a4
    int32_t v2; // bp-56, 0x4d454
    int32_t v3 = function_4d954(&v2); // 0x4d4c8
    int32_t result = 0; // 0x4d4d0
    if (v3 == 0) {
        // 0x4d4d4
        result = function_4d288(&v1, a3, a4);
        function_4c1fc(&v1);
    }
    // 0x4d4fc
    return result;
}

// Address range: 0x4d528 - 0x4d608
int32_t function_4d528(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = g317 == a1 ? (int32_t)"<stdin>" : (int32_t)"<stream>";
    function_4f90c(a3, (char *)v1);
    if (a1 == 0) {
        // 0x4d5e8
        function_4c0cc(a3, 0, 4, "wrong arguments");
        // 0x4d5dc
        return 0;
    }
    int32_t v2 = 0x12388; // bp-96, 0x4d58c
    int32_t v3; // bp-56, 0x4d528
    int32_t v4 = function_4d954(&v3); // 0x4d5a8
    int32_t result = 0; // 0x4d5b0
    if (v4 == 0) {
        // 0x4d5b4
        result = function_4d288(&v2, a2, a3);
        function_4c1fc(&v2);
    }
    // 0x4d5dc
    return result;
}

// Address range: 0x4d608 - 0x4d6e4
int32_t function_4d608(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = a1 == 0 ? (int32_t)"<stdin>" : (int32_t)"<stream>";
    function_4f90c(a3, (char *)v1);
    if (a1 < 0) {
        // 0x4d6c4
        function_4c0cc(a3, 0, 4, "wrong arguments");
        // 0x4d6b8
        return 0;
    }
    int32_t v2 = 0x4c23c; // bp-88, 0x4d664
    int32_t v3; // bp-48, 0x4d608
    int32_t v4 = function_4d954(&v3); // 0x4d684
    int32_t result = 0; // 0x4d68c
    if (v4 == 0) {
        // 0x4d690
        result = function_4d288(&v2, a2, a3);
        function_4c1fc(&v2);
    }
    // 0x4d6b8
    return result;
}

// Address range: 0x4d6e4 - 0x4d79c
int32_t function_4d6e4(char * a1, int32_t a2, int32_t * a3) {
    int32_t v1 = (int32_t)a3;
    function_4f90c(v1, a1);
    if (a1 == NULL) {
        int32_t result = (int32_t)a1;
        function_4c0cc(v1, result, 4, "wrong arguments");
        // 0x4d73c
        return result;
    }
    struct _IO_FILE * file = fopen64(a1, "rb"); // 0x4d718
    int32_t v2 = (int32_t)file; // 0x4d718
    int32_t result2; // 0x4d6e4
    if (file == NULL) {
        // 0x4d768
        strerror(*__errno_location());
        function_4c0cc(v1, v2, 3, "unable to open %s: %s");
        result2 = v2;
    } else {
        int32_t v3 = function_4d528(v2, a2, v1); // 0x4d72c
        fclose(file);
        result2 = v3;
    }
    // 0x4d73c
    return result2;
}

// Address range: 0x4d79c - 0x4d880
int32_t function_4d79c(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x4d79c
    int32_t v1; // bp-1064, 0x4d79c
    memset(&v1, 0, 1040);
    function_4f90c(a4, "<callback>");
    if (a1 == 0) {
        // 0x4d864
        function_4c0cc(a4, 0, 4, "wrong arguments");
        // 0x4d854
        return 0;
    }
    int32_t v2 = 0x4c070; // bp-1136, 0x4d804
    int32_t v3; // bp-1096, 0x4d79c
    int32_t v4 = function_4d954(&v3); // 0x4d820
    int32_t result = 0; // 0x4d828
    if (v4 == 0) {
        // 0x4d82c
        result = function_4d288(&v2, a3, a4);
        function_4c1fc(&v2);
    }
    // 0x4d854
    return result;
}

// Address range: 0x4d880 - 0x4d898
int32_t function_4d880(int32_t size) {
    if (size == 0) {
        return 0;
    }
    // 0x4d888
    return (int32_t)malloc(size);
}

// Address range: 0x4d898 - 0x4d8b0
int32_t function_4d898(int32_t a1) {
    // 0x4d898
    if (a1 == 0) {
        return 0;
    }
    // 0x4d8a0
    int32_t v1; // 0x4d898
    return free(a1, v1, v1, g311);
}

// Address range: 0x4d8b0 - 0x4d8fc
int32_t function_4d8b0(int32_t a1, int32_t a2) {
    int32_t size = a2 + 1; // 0x4d8b4
    if (size == 0) {
        // 0x4d8f4
        return 0;
    }
    int32_t * mem = malloc(size); // 0x4d8d4
    int32_t result = (int32_t)mem; // 0x4d8d4
    if (mem != NULL) {
        // 0x4d8e0
        function_11fc4(mem, a1, (char)a2, g310);
        *(char *)(result + a2) = 0;
    }
    // 0x4d8f4
    return result;
}

// Address range: 0x4d8fc - 0x4d918
int32_t function_4d8fc(int32_t str) {
    // 0x4d8fc
    return function_4d8b0(str, strlen((char *)str));
}

// Address range: 0x4d918 - 0x4d928
int32_t function_4d918(int32_t result, int32_t a2) {
    // 0x4d918
    g310 = result;
    g311 = a2;
    return result;
}

// Address range: 0x4d928 - 0x4d954
int32_t function_4d928(int32_t result, int32_t a2) {
    if (result != 0) {
        *(int32_t *)result = g310;
    }
    if (a2 != 0) {
        *(int32_t *)a2 = *(int32_t *)0x7f56c;
    }
    // .thread3
    return result;
}

// Address range: 0x4d954 - 0x4d988
int32_t function_4d954(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    *(int32_t *)(v1 + 8) = 16;
    *(int32_t *)(v1 + 4) = 0;
    int32_t v2 = function_4d880(16); // 0x4d96c
    *a1 = v2;
    if (v2 != 0) {
        *(char *)v2 = 0;
    }
    return v2 == 0;
}

// Address range: 0x4d988 - 0x4d9b4
int32_t function_4d988(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    int32_t result = v1; // 0x4d998
    if (a1 != NULL) {
        // 0x4d99c
        result = function_4d898(v1);
    }
    // 0x4d9a0
    *(int32_t *)(v1 + 8) = 0;
    *(int32_t *)(v1 + 4) = 0;
    *a1 = 0;
    return result;
}

// Address range: 0x4d9b4 - 0x4d9c8
int32_t function_4d9b4(int32_t result) {
    // 0x4d9b4
    *(int32_t *)(result + 4) = 0;
    *(char *)result = 0;
    return result;
}

// Address range: 0x4d9c8 - 0x4d9d0
int32_t function_4d9c8(int32_t * a1) {
    // 0x4d9c8
    return (int32_t)a1;
}

// Address range: 0x4d9d0 - 0x4d9e4
int32_t function_4d9d0(int32_t result) {
    // 0x4d9d0
    *(int32_t *)result = 0;
    return result;
}

// Address range: 0x4d9e4 - 0x4dab0
int32_t function_4d9e4(int32_t a1, int32_t a2, uint32_t a3) {
    int32_t * v1 = (int32_t *)(a1 + 8); // 0x4d9ec
    int32_t v2 = *v1; // 0x4d9ec
    int32_t * v3 = (int32_t *)(a1 + 4); // 0x4d9f8
    int32_t v4 = *v3; // 0x4d9f8
    uint32_t v5 = v2 - v4; // 0x4d9fc
    int32_t v6 = v4; // 0x4da08
    int32_t v7 = v2; // 0x4da08
    int32_t v8 = v4; // 0x4da08
    if (v5 >= a3 != v5 != a3) {
        if (-2 - a3 < v4 || v2 < 0 || a3 == -1) {
            // 0x4daa8
            return -1;
        }
        // 0x4da34
        v7 = 2 * v2;
        uint32_t v9 = a3 + 1 + v4; // 0x4da3c
        int32_t v10 = v9 < v7 ? v7 : v9;
        v8 = function_4d880(v10);
        if (v8 == 0) {
            // 0x4daa8
            return -1;
        }
        // 0x4da5c
        function_4d898(function_11fc4((int32_t *)v8, v8, (char)*v3, v7));
        v6 = *v3;
        *(int32_t *)a1 = v8;
        *v1 = v10;
    }
    int32_t v11 = function_11fc4((int32_t *)(v8 + v6), a2, (char)a3, v7); // 0x4da84
    int32_t v12 = *v3 + a3; // 0x4da98
    *v3 = v12;
    *(char *)(v12 + v11) = 0;
    return 0;
}

// Address range: 0x4dab0 - 0x4dad4
int32_t function_4dab0(int32_t a1, int32_t a2) {
    int32_t v1 = 0x1000000 * a2 >> 24; // bp-9, 0x4dac0
    return function_4d9e4(a1, (int32_t)&v1, 1);
}

// Address range: 0x4dad4 - 0x4dafc
int32_t function_4dad4(int32_t a1) {
    int32_t * v1 = (int32_t *)(a1 + 4); // 0x4dad4
    int32_t v2 = *v1; // 0x4dad4
    int32_t result = 0; // 0x4dae8
    if (v2 != 0) {
        int32_t v3 = v2 == 0 ? 0 : v2 - 1;
        *v1 = v3;
        char * v4 = (char *)(v3 + a1);
        *v4 = 0;
        result = (int32_t)*v4;
    }
    // .critedge.thread
    return result;
}

// Address range: 0x4db00 - 0x4dbe0
int32_t function_4db00(int32_t a1, int32_t * a2, int32_t a3, int32_t a4) {
    struct lconv * locale_info = localeconv(); // 0x4db10
    int32_t v1 = (int32_t)locale_info; // 0x4db10
    char v2 = *(char *)*(int32_t *)locale_info; // 0x4db1c
    int32_t str = v1; // 0x4db24
    if (v2 != 46) {
        char * found_char_pos = strchr((char *)locale_info, 46); // 0x4db30
        if (found_char_pos != NULL) {
            *found_char_pos = v2;
        }
        str = found_char_pos == NULL ? v1 : (int32_t)found_char_pos;
    }
    // 0x4db40
    *__errno_location() = 0;
    int32_t endptr; // bp-28, 0x4db00
    float64_t str_as_d = strtod((char *)str, (char **)&endptr); // 0x4db58
    if (endptr == *(int32_t *)(a1 + 4) + (int32_t)(float32_t)str_as_d) {
        // 0x4db74
        __asm_vldr(-1);
        return (float32_t)str_as_d;
    }
    // 0x4dbbc
    __assert_fail("end == strbuffer->value + strbuffer->length", "strconv.c", 78, "jsonp_strtod");
    return __asm_nop((int32_t)&g488);
}

// Address range: 0x4dbf0 - 0x4dd30
int32_t function_4dbf0(int32_t * str, uint32_t size, int32_t a3) {
    // 0x4dbf0
    float64_t v1; // 0x4dbf0
    int32_t v2; // 0x4dbf0
    __asm_vstr(v1, v2);
    int32_t chars_printed = snprintf((char *)str, size, "%.*g", a3 == 0 ? 17 : a3); // 0x4dc18
    if (chars_printed == size || chars_printed > size) {
        // 0x4dcd0
        return -1;
    }
    unsigned char c = *(char *)*(int32_t *)localeconv(); // 0x4dc30
    if (c != 46) {
        char * found_char_pos = strchr((char *)str, (int32_t)c); // 0x4dc40
        if (found_char_pos != NULL) {
            *found_char_pos = 46;
        }
    }
    int32_t v3 = (int32_t)str;
    char * found_char_pos2 = strchr((char *)str, 46); // 0x4dc58
    char * found_char_pos3 = strchr((char *)str, 101); // 0x4dc68
    int32_t v4 = (int32_t)found_char_pos3; // 0x4dc68
    int32_t found_char_pos4 = v4; // 0x4dc70
    int32_t result = chars_printed; // 0x4dc70
    int32_t v5; // 0x4dbf0
    int32_t result2; // 0x4dbf0
    if (found_char_pos2 == NULL) {
        // 0x4dce8
        v5 = v4;
        result2 = chars_printed;
        if (found_char_pos3 == NULL) {
            // 0x4dcf0
            if (chars_printed + 3 >= size) {
                // 0x4dcd0
                return -1;
            }
            int32_t v6 = chars_printed + v3; // 0x4dd04
            *(char *)v6 = 46;
            result = chars_printed + 2;
            *(char *)(v6 + 1) = 48;
            *(char *)(result + v3) = (char)v4;
            found_char_pos4 = (int32_t)strchr((char *)str, 101);
            goto lab_0x4dc74;
        } else {
            goto lab_0x4dc7c;
        }
    } else {
        goto lab_0x4dc74;
    }
  lab_0x4dc74:
    // 0x4dc74
    v5 = found_char_pos4;
    result2 = result;
    if (found_char_pos4 == 0) {
        // 0x4dcd0
        return result;
    }
    goto lab_0x4dc7c;
  lab_0x4dc7c:;
    int32_t v7 = v5 + 1; // 0x4dc7c
    int32_t v8 = v5 + 2; // 0x4dc80
    char v9 = *(char *)v8; // 0x4dc84
    char v10; // 0x4dbf0
    int32_t v11; // 0x4dbf0
    int32_t v12; // 0x4dbf0
    int32_t v13; // 0x4dbf0
    if (*(char *)v7 == 45) {
        // 0x4dcd8
        v12 = v8;
        if (v9 != 48) {
            // 0x4dcd0
            return result2;
        }
        goto lab_0x4dc9c;
    } else {
        // 0x4dc90
        v12 = v7;
        v13 = v7;
        v11 = v8;
        v10 = v9;
        if (v9 == 48) {
            goto lab_0x4dc9c;
        } else {
            goto lab_0x4dcb0;
        }
    }
  lab_0x4dc9c:;
    int32_t v14 = v8 + 1; // 0x4dc9c
    char v15 = *(char *)v14; // 0x4dc9c
    int32_t v16 = v14; // 0x4dca4
    while (v15 == 48) {
        // 0x4dc9c
        v14 = v16 + 1;
        v15 = *(char *)v14;
        v16 = v14;
    }
    // 0x4dca8
    v13 = v12;
    v11 = v14;
    v10 = v15;
    if (v12 == v14) {
        // 0x4dcd0
        return result2;
    }
    goto lab_0x4dcb0;
  lab_0x4dcb0:;
    int32_t v17 = v11;
    function_11f64(v13, v17, result2 + v3 - v17, (int32_t)v10);
    // 0x4dcd0
    return v13 + result2 - v17;
}

// Address range: 0x4dd30 - 0x4de1c
int32_t function_4dd30(int32_t a1, int32_t a2, int32_t * a3) {
    if (a1 < 0) {
        // 0x4de0c
        return -1;
    }
    if (a1 < 128) {
        // 0x4ddc4
        *(char *)a2 = (char)a1;
        *a3 = 1;
        return 0;
    }
    if (a1 < 2048) {
        // 0x4dd9c
        *(char *)a2 = (char)((uint32_t)a1 / 64) - 64;
        *(char *)(a2 + 1) = (char)a1 % 64 | -128;
        *a3 = 2;
        return 0;
    }
    if (a1 < 0x10000) {
        int32_t v1 = __asm_ubfx(a1, 6, 6); // 0x4dddc
        *(char *)a2 = (char)(a1 / 0x1000) - 32;
        *(char *)(a2 + 1) = (char)v1 ^ -128;
        *(char *)(a2 + 2) = (char)a1 % 64 | -128;
        *a3 = 3;
        return 0;
    }
    if (a1 >= (int32_t)&g3) {
        // 0x4de0c
        return -1;
    }
    int32_t v2 = __asm_ubfx(a1, 12, 6); // 0x4dd60
    int32_t v3 = __asm_ubfx(a1, 6, 6); // 0x4dd64
    *(char *)a2 = (char)(a1 / 0x40000) - 16;
    *(char *)(a2 + 1) = (char)v2 ^ -128;
    *(char *)(a2 + 2) = (char)v3 ^ -128;
    *(char *)(a2 + 3) = (char)a1 % 64 | -128;
    *a3 = 4;
    return 0;
}

// Address range: 0x4de1c - 0x4de88
int32_t function_4de1c(int32_t a1) {
    // 0x4de1c
    if ((a1 & 128) == 0) {
        // 0x4de24
        return 1;
    }
    uint32_t v1 = a1 ^ 128; // 0x4de2c
    if (v1 == 65 || v1 < 65) {
        // 0x4de24
        return 0;
    }
    uint32_t v2 = (a1 + 62) % 256; // 0x4de3c
    if (v2 == 29 || v2 < 29) {
        // 0x4de24
        return 2;
    }
    uint32_t v3 = (a1 + 32) % 256; // 0x4de4c
    int32_t result = 3; // 0x4de54
    if (v3 != 15 && v3 >= 15) {
        uint32_t v4 = (a1 + 16) % 256; // 0x4de5c
        result = v4 == 4 | v4 < 4 ? 4 : v4 >= 4 == (v4 != 4) ? 0 : v4;
    }
    // 0x4de24
    return result;
}

// Address range: 0x4de88 - 0x4df70
int32_t function_4de88(uint32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = (uint32_t)(a1 % 32);
    int32_t v2 = v1; // 0x4de9c
    if (a2 != 2) {
        uint32_t v3 = a2 == 2 ? v1 : a1 % 256;
        v2 = v3 % 16;
        if (a2 != 3) {
            // 0x4deac
            v2 = v3 % 8;
            if (a2 != 4) {
                // 0x4deb8
                return 0;
            }
        }
    }
    int32_t v4 = a1 + 1; // 0x4dec0
    int32_t v5 = (int32_t)*(char *)v4; // 0x4dec0
    uint32_t v6 = v5 ^ 128; // 0x4dec4
    int32_t v7 = v4; // 0x4decc
    if (v6 >= 63 == (v6 != 63)) {
        // 0x4deb8
        return 0;
    }
    int32_t v8 = 1; // 0x4decc
    int32_t v9 = v2;
    v8++;
    int32_t v10 = v5 % 64 | 64 * v9; // 0x4def8
    while ((v9 & 0x4000000) != 0 == (v8 != a2)) {
        // 0x4dedc
        v7++;
        int32_t v11 = (int32_t)*(char *)v7; // 0x4dedc
        uint32_t v12 = v11 ^ 128; // 0x4dee0
        if (v12 >= 63 == (v12 != 63)) {
            // 0x4deb8
            return 0;
        }
        v9 = v10;
        v8++;
        v10 = v11 % 64 | 64 * v9;
    }
    // 0x4df00
    if ((v9 & 0x3ffffe0) == 864 || v10 >= (int32_t)&g3 || (v10 < 128 ? a2 == 2 : v10 == 127)) {
        // 0x4deb8
        return 0;
    }
    // .critedge
    if (a3 != 0) {
        *(int32_t *)a3 = v10;
    }
    // 0x4deb8
    return 1;
}

// Address range: 0x4df70 - 0x4dfec
int32_t function_4df70(uint32_t result, uint32_t a2, int32_t * a3) {
    // 0x4df70
    if (a2 == 0) {
        // 0x4dfe0
        return result;
    }
    int32_t v1 = result % 256; // 0x4df80
    uint32_t v2 = function_4de1c(v1); // 0x4df90
    int32_t v3; // bp-20, 0x4df70
    switch (v2) {
        case 0: {
            // 0x4dfe0
            return 0;
        }
        case 1: {
            v3 = v1;
            // break -> 0x4dfc8
            break;
        }
        default: {
            // 0x4dfa8
            if (v2 > a2 || function_4de88(result, v2, (int32_t)&v3) == 0) {
                // 0x4dfe0
                return 0;
            }
            // break -> 0x4dfc8
            break;
        }
    }
    // 0x4dfc8
    if (a3 != NULL) {
        *a3 = v3;
    }
    // 0x4dfe0
    return v2 + result;
}

// Address range: 0x4dfec - 0x4e068
int32_t function_4dfec(int32_t a1, uint32_t a2) {
    int32_t v1 = 0; // 0x4dff4
    int32_t result = 1; // 0x4dff4
    if (a2 == 0) {
        // 0x4e058
        return result;
    }
    int32_t v2; // 0x4dfec
    while (true) {
      lab_0x4e034:;
        int32_t v3 = v1;
        int32_t v4 = v3 + a1; // 0x4e034
        uint32_t v5 = function_4de1c((int32_t)*(char *)v4); // 0x4e03c
        v2 = v3;
        result = 0;
        switch (v5) {
            case 0: {
                return result;
            }
            case 1: {
                goto lab_0x4e028;
            }
            default: {
                // 0x4e00c
                if (a2 - v3 < v5) {
                    // break -> 0x4e058
                    break;
                }
                int32_t v6 = function_4de88(v4, v5, 0); // 0x4e014
                v2 = v3 - 1 + v5;
                if (v6 == 0) {
                    // break -> 0x4e058
                    break;
                }
                goto lab_0x4e028;
            }
        }
    }
    // 0x4e058
    return 1;
  lab_0x4e028:
    // 0x4e028
    v1 = v2 + 1;
    if (v1 == a2 || v1 > a2) {
        return 1;
    }
    goto lab_0x4e034;
}

// Address range: 0x4e068 - 0x4e0b8
int32_t function_4e068(int32_t a1) {
    int32_t v1 = 0; // 0x4e070
    int32_t v2 = 0; // 0x4e070
    if (a1 == 3) {
        uint64_t v3 = *(int64_t *)11; // 0x4e0b0
        v1 = v3 / 0x100000000;
        v2 = v3;
    }
    int32_t result = function_4d880(16); // 0x4e08c
    if (result == 0) {
        return 0;
    }
    // 0x4e098
    *(int32_t *)(result + 8) = v1;
    *(int32_t *)(result + 12) = v2;
    *(int32_t *)result = 3;
    *(int32_t *)(result + 4) = 1;
    return result;
}

// Address range: 0x4e0b8 - 0x4e144
int32_t function_4e0b8(int32_t a1, int32_t a2, int32_t a3) {
    int32_t * v1 = (int32_t *)(a1 + 12); // 0x4e0b8
    int32_t * v2 = (int32_t *)(a1 + 8); // 0x4e0bc
    uint32_t v3 = *v2; // 0x4e0bc
    uint32_t v4 = *v1 + a2; // 0x4e0c4
    int32_t * v5 = (int32_t *)(a1 + 16); // 0x4e0c8
    int32_t result = *v5; // 0x4e0c8
    if (v4 >= v3 != v4 != v3) {
        // 0x4e0d4
        return result;
    }
    uint32_t v6 = 2 * v3; // 0x4e0dc
    uint32_t v7 = v3 + a2; // 0x4e0e0
    int32_t v8 = v6 < v7 ? v7 : v6;
    int32_t v9 = function_4d880(4 * v8); // 0x4e0fc
    if (v9 == 0) {
        // 0x4e0d4
        return 0;
    }
    // 0x4e108
    *v2 = v8;
    *v5 = v9;
    if (a3 == 0) {
        // 0x4e0d4
        return result;
    }
    // 0x4e118
    function_11fc4((int32_t *)v9, result, 4 * (char)*v1, v9);
    function_4d898(result);
    return *v5;
}

// Address range: 0x4e144 - 0x4e1b0
int32_t function_4e144(int32_t a1, int32_t a2, int32_t a3) {
    if (a1 == 0) {
        // 0x4e198
        return 0;
    }
    int32_t v1 = a1; // 0x4e158
    if (a3 == 0) {
        // 0x4e18c
        v1 = function_4d8b0(a1, a2);
        if (v1 == 0) {
            // 0x4e198
            return 0;
        }
    }
    int32_t result = function_4d880(16); // 0x4e160
    if (result == 0) {
        // 0x4e1a0
        function_4d898(v1);
        return 0;
    }
    // 0x4e16c
    *(int32_t *)(result + 8) = v1;
    *(int32_t *)(result + 12) = a2;
    *(int32_t *)result = 2;
    *(int32_t *)(result + 4) = 1;
    return result;
}

// Address range: 0x4e1b0 - 0x4e218
int32_t function_4e1b0(void) {
    int32_t v1 = function_4d880(36); // 0x4e1b8
    if (v1 == 0) {
        // 0x4e1f8
        return 0;
    }
    // 0x4e1c4
    if (g150 == 0) {
        // 0x4e200
        function_4bf2c(0);
    }
    // 0x4e1d8
    *(int32_t *)(v1 + 4) = 1;
    *(int32_t *)v1 = 0;
    int32_t v2 = function_4b91c((int32_t *)(v1 + 8)); // 0x4e1ec
    int32_t result = v1; // 0x4e1f4
    if (v2 != 0) {
        // 0x4e208
        function_4d898(v1);
        result = 0;
    }
    // 0x4e1f8
    return result;
}

// Address range: 0x4e218 - 0x4e234
int32_t function_4e218(int32_t a1) {
    // 0x4e218
    return 0;
}

// Address range: 0x4e234 - 0x4e25c
int32_t function_4e234(int32_t a1, char * a2) {
    // 0x4e234
    return 0;
}

// Address range: 0x4e25c - 0x4e43c
int32_t function_4e25c(int32_t a1, int32_t a2) {
    // 0x4e25c
    return (bool)(a1 == a2);
}

// Address range: 0x4e43c - 0x4e464
int32_t function_4e43c(int32_t a1, int32_t a2) {
    // 0x4e43c
    return -1;
}

// Address range: 0x4e464 - 0x4e49c
int32_t function_4e464(int32_t a1) {
    // 0x4e464
    return -1;
}

// Address range: 0x4e49c - 0x4e4c0
int32_t function_4e49c(int32_t a1) {
    // 0x4e49c
    return 0;
}

// Address range: 0x4e4c0 - 0x4e4e8
int32_t function_4e4c0(int32_t a1, int32_t a2) {
    // 0x4e4c0
    return 0;
}

// Address range: 0x4e4e8 - 0x4e51c
int32_t function_4e4e8(int32_t a1, int32_t a2) {
    // 0x4e4e8
    return 0;
}

// Address range: 0x4e51c - 0x4e528
int32_t function_4e51c(int32_t a1) {
    if (a1 == 0) {
        return 0;
    }
    // 0x4e524
    return function_4beb0(a1);
}

// Address range: 0x4e528 - 0x4e534
int32_t function_4e528(int32_t a1) {
    if (a1 == 0) {
        return 0;
    }
    // 0x4e530
    return function_4beb8(a1);
}

// Address range: 0x4e534 - 0x4e540
int32_t function_4e534(int32_t a1) {
    // 0x4e534
    return a1 == 0 ? 0 : a1 - 16;
}

// Address range: 0x4e540 - 0x4e5a0
int32_t function_4e540(void) {
    int32_t v1 = function_4d880(20); // 0x4e548
    if (v1 == 0) {
        // 0x4e588
        return 0;
    }
    // 0x4e554
    *(int32_t *)v1 = 1;
    *(int32_t *)(v1 + 4) = 1;
    *(int32_t *)(v1 + 12) = 0;
    *(int32_t *)(v1 + 8) = 8;
    int32_t v2 = function_4d880(32); // 0x4e574
    *(int32_t *)(v1 + 16) = v2;
    int32_t result = v1; // 0x4e584
    if (v2 == 0) {
        // 0x4e590
        function_4d898(v1);
        result = 0;
    }
    // 0x4e588
    return result;
}

// Address range: 0x4e5a0 - 0x4e5bc
int32_t function_4e5a0(int32_t a1) {
    // 0x4e5a0
    if (a1 == 0) {
        return 0;
    }
    int32_t v1 = a1; // 0x4e5b0
    if (a1 == 1) {
        v1 = *(int32_t *)13;
    }
    return a1 == 1 ? v1 : 0;
}

// Address range: 0x4e5bc - 0x4e5f0
int32_t function_4e5bc(int32_t a1, uint32_t a2) {
    if (a1 != 1) {
        // 0x4e5e8
        return 0;
    }
    uint32_t v1 = *(int32_t *)13; // 0x4e5d0
    if (v1 == a2 || v1 < a2) {
        // 0x4e5e8
        return 0;
    }
    // 0x4e5dc
    return *(int32_t *)(*(int32_t *)17 + 4 * a2);
}

// Address range: 0x4e5f0 - 0x4e6c8
int32_t function_4e5f0(int32_t a1, int32_t a2) {
    if (a1 == 0) {
        // 0x4e6c0
        return -1;
    }
    if (a1 == 1 != (a2 == 1) || function_4e0b8(1, *(int32_t *)13, 1) == 0) {
        // 0x4e6c0
        return -1;
    }
    uint64_t v1 = *(int64_t *)13; // 0x4e63c
    uint64_t v2 = v1 / 0x100000000; // 0x4e63c
    int32_t v3 = v2; // 0x4e63c
    int32_t v4 = v1; // 0x4e648
    char v5 = v2; // 0x4e648
    if (v3 != 0) {
        int32_t v6 = 0;
        int32_t v7 = v4;
        int32_t v8 = *(int32_t *)(4 * v6 + v7); // 0x4e650
        int32_t v9 = v3; // 0x4e658
        int32_t v10 = v7; // 0x4e658
        int32_t v11; // 0x4e5f0
        int32_t v12; // 0x4e5f0
        int32_t v13; // 0x4e65c
        int32_t * v14; // 0x4e65c
        int32_t v15; // 0x4e65c
        int32_t v16; // 0x4e670
        int32_t v17; // 0x4e674
        uint64_t v18; // 0x4e684
        int32_t v19; // 0x4e670
        int32_t v20; // 0x4e674
        if (v8 != 0) {
            // 0x4e65c
            v13 = v8 + 4;
            v14 = (int32_t *)v13;
            v15 = *v14;
            v9 = v3;
            v10 = v7;
            if (v15 != -1) {
                // 0x4e66c
                v16 = v15 + 1;
                v17 = __asm_strex(v16, v15);
                v11 = v16;
                if (v17 != 0) {
                    v12 = *v14;
                    v19 = v12 + 1;
                    v20 = __asm_strex(v19, v12);
                    v11 = v19;
                    while (v20 != 0) {
                        // 0x4e66c
                        v12 = *v14;
                        v19 = v12 + 1;
                        v20 = __asm_strex(v19, v12);
                        v11 = v19;
                    }
                }
                // 0x4e680
                __asm_dmb(0, v11, v13, v6);
                v18 = *(int64_t *)13;
                v9 = v18 / 0x100000000;
                v10 = v18;
            }
        }
        // 0x4e688
        v4 = v10;
        int32_t v21 = v9;
        int32_t v22 = v6 + 1; // 0x4e688
        while (v21 >= v22 == (v21 != v22)) {
            // 0x4e650
            v6 = v22;
            v7 = v4;
            int32_t v23 = v21;
            v8 = *(int32_t *)(4 * v6 + v7);
            v9 = v23;
            v10 = v7;
            if (v8 != 0) {
                // 0x4e65c
                v13 = v8 + 4;
                v14 = (int32_t *)v13;
                v15 = *v14;
                v9 = v23;
                v10 = v7;
                if (v15 != -1) {
                    // 0x4e66c
                    v16 = v15 + 1;
                    v17 = __asm_strex(v16, v15);
                    v11 = v16;
                    if (v17 != 0) {
                        v12 = *v14;
                        v19 = v12 + 1;
                        v20 = __asm_strex(v19, v12);
                        v11 = v19;
                        while (v20 != 0) {
                            // 0x4e66c
                            v12 = *v14;
                            v19 = v12 + 1;
                            v20 = __asm_strex(v19, v12);
                            v11 = v19;
                        }
                    }
                    // 0x4e680
                    __asm_dmb(0, v11, v13, v6);
                    v18 = *(int64_t *)13;
                    v9 = v18 / 0x100000000;
                    v10 = v18;
                }
            }
            // 0x4e688
            v4 = v10;
            v21 = v9;
            v22 = v6 + 1;
        }
        // 0x4e694
        v5 = 4 * (char)v21;
    }
    int32_t v24 = *(int32_t *)17; // 0x4e698
    function_11fc4((int32_t *)(4 * *(int32_t *)13 + v24), v4, v5, v24);
    *(int32_t *)13 = 2 * *(int32_t *)13;
    return 0;
}

// Address range: 0x4e6c8 - 0x4e6f0
int32_t function_4e6c8(int32_t str) {
    if (str == 0) {
        return 0;
    }
    // 0x4e6d0
    return function_4e144(str, strlen((char *)str), 0);
}

// Address range: 0x4e6f0 - 0x4e6f8
int32_t function_4e6f0(void) {
    // 0x4e6f0
    int32_t v1; // 0x4e6f0
    return function_4e144(v1, v1, 0);
}

// Address range: 0x4e6f8 - 0x4e700
int32_t function_4e6f8(int32_t a1, int32_t a2) {
    // 0x4e6f8
    return function_4e144(a1, a2, 1);
}

// Address range: 0x4e700 - 0x4e744
int32_t function_4e700(int32_t a1, int32_t a2) {
    if (a1 == 0 || function_4dfec(a1, a2) == 0) {
        // 0x4e734
        return 0;
    }
    // 0x4e720
    return function_4e144(a1, a2, 0);
}

// Address range: 0x4e744 - 0x4e768
int32_t function_4e744(int32_t * str) {
    int32_t result = (int32_t)str;
    if (str == NULL) {
        return result;
    }
    // 0x4e74c
    return function_4e700(result, strlen((char *)str));
}

// Address range: 0x4e768 - 0x4e784
int32_t function_4e768(int32_t a1) {
    // 0x4e768
    if (a1 == 0) {
        return 0;
    }
    int32_t v1 = a1; // 0x4e778
    if (a1 == 2) {
        v1 = *(int32_t *)10;
    }
    return a1 == 2 ? v1 : 0;
}

// Address range: 0x4e784 - 0x4e7a0
int32_t function_4e784(int32_t a1) {
    // 0x4e784
    if (a1 == 0) {
        return 0;
    }
    int32_t v1 = a1; // 0x4e794
    if (a1 == 2) {
        v1 = *(int32_t *)14;
    }
    return a1 == 2 ? v1 : 0;
}

// Address range: 0x4e7a0 - 0x4e804
int32_t function_4e7a0(int32_t a1, int32_t a2, int32_t a3) {
    if (a1 != 2) {
        // 0x4e7fc
        return -1;
    }
    int32_t v1 = function_4d8b0(a2, a3); // 0x4e7d8
    if (v1 == 0) {
        // 0x4e7fc
        return -1;
    }
    // 0x4e7e4
    function_4d898(*(int32_t *)10);
    *(int32_t *)10 = v1;
    *(int32_t *)14 = a3;
    return 0;
}

// Address range: 0x4e804 - 0x4e838
int32_t function_4e804(int32_t a1, int32_t str) {
    if (str == 0) {
        // 0x4e830
        return -1;
    }
    // 0x4e810
    return function_4e7a0(a1, str, strlen((char *)str));
}

// Address range: 0x4e838 - 0x4e87c
int32_t function_4e838(int32_t a1, int32_t a2, int32_t a3) {
    if (a2 == 0 || function_4dfec(a2, a3) == 0) {
        // 0x4e874
        return -1;
    }
    // 0x4e860
    return function_4e7a0(a1, a2, a3);
}

// Address range: 0x4e87c - 0x4e8b0
int32_t function_4e87c(int32_t a1, int32_t str) {
    if (str == 0) {
        // 0x4e8a8
        return -1;
    }
    // 0x4e888
    return function_4e838(a1, str, strlen((char *)str));
}

// Address range: 0x4e8b0 - 0x4e960
int32_t function_4e8b0(int32_t a1, int32_t * a2) {
    int32_t v1 = (int32_t)a2;
    char * format = (char *)a1; // 0x4e8d4
    int32_t chars_printed = vsnprintf(NULL, 0, format, v1); // 0x4e8d4
    if (chars_printed == 0) {
        // 0x4e930
        return function_4e700((int32_t)&g260, 0);
    }
    int32_t size = chars_printed + 1; // 0x4e8e0
    int32_t str = function_4d880(size); // 0x4e8e8
    if (str == 0) {
        // 0x4e928
        return 0;
    }
    // 0x4e8f4
    vsnprintf((char *)str, size, format, v1);
    int32_t result; // 0x4e8b0
    if (function_4dfec(str, chars_printed) == 0) {
        // 0x4e950
        function_4d898(str);
        result = 0;
    } else {
        // 0x4e918
        result = function_4e144(str, chars_printed, 1);
    }
    // 0x4e928
    return result;
}

// Address range: 0x4e960 - 0x4e990
int32_t function_4e960(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = a2; // bp-12, 0x4e960
    return function_4e8b0(a1, &v1);
}

// Address range: 0x4e990 - 0x4e9c4
int32_t function_4e990(int32_t a1, int32_t a2) {
    int32_t result = function_4d880(16); // 0x4e9a0
    if (result == 0) {
        return 0;
    }
    // 0x4e9ac
    *(int32_t *)(result + 8) = a1;
    *(int32_t *)(result + 12) = a2;
    *(int32_t *)result = 3;
    *(int32_t *)(result + 4) = 1;
    return result;
}

// Address range: 0x4e9c4 - 0x4e9ec
int32_t function_4e9c4(int32_t a1) {
    if (a1 == 3) {
        // 0x4e9e4
        return (int32_t)(*(int64_t *)11 / 0x100000000);
    }
    // 0x4e9d8
    return 0;
}

// Address range: 0x4e9ec - 0x4ea14
int32_t function_4e9ec(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    if (a1 != 3) {
        // 0x4ea0c
        return -1;
    }
    // 0x4ea00
    *(int32_t *)11 = a3;
    *(int32_t *)15 = a4;
    return 0;
}

// Address range: 0x4ea14 - 0x4ea15
int32_t function_4ea14(void) {
    // 0x4ea14
    int32_t result; // 0x4ea14
    return result;
}

// Address range: 0x4ea16 - 0x4ea62
int32_t function_4ea16(int32_t a1, int32_t a2, int32_t a3, uint32_t a4) {
    // 0x4ea16
    int32_t v1; // 0x4ea16
    uint32_t v2 = v1;
    int32_t result = function_48a4ee(); // 0x4ea16
    bool v3; // 0x4ea16
    if (v3) {
        g83 = 0x4ea20;
        return result;
    }
    if (v3) {
        // 0x4ea26
        function_ff08a0a6();
        function_124a4ee();
    } else {
        // 0x4ea22
        function_469226();
    }
    uint32_t v4 = function_48a502(); // 0x4ea2a
    bool v5; // 0x4ea16
    bool v6; // 0x4ea16
    bool v7; // 0x4ea16
    bool v8; // 0x4ea16
    bool v9; // 0x4ea16
    bool v10; // 0x4ea16
    int32_t v11; // 0x4ea16
    int32_t v12; // 0x4ea16
    int32_t v13; // 0x4ea16
    int32_t v14; // 0x4ea16
    if (v3) {
        uint32_t v15 = 0x100000 * v4; // 0x4ea32
        if (v15 == v4) {
            int32_t v16 = unknown_fe409b9c(); // 0x4ea3e
            if ((v4 & v1 / 0x40000) == 0) {
                *(int32_t *)v16 = 0x4ea3e;
                *(int32_t *)(v16 + 4) = 0x4ea48;
                int32_t v17 = v16 - (int32_t)&g84; // 0x4ea42
                v11 = v17;
                v9 = true;
                v7 = false;
                v13 = v17;
                v8 = true;
                if ((v1 & 0x20000) != 0) {
                    goto lab_dec_label_pc_unknown_45;
                } else {
                    goto lab__thread17_2;
                }
            } else {
                v11 = v16;
                v9 = false;
                v7 = false;
                v13 = v16;
                v8 = false;
                if ((v1 & 0x20000) != 0) {
                    goto lab_dec_label_pc_unknown_45;
                } else {
                    goto lab__thread17_2;
                }
            }
        } else {
            if (0xfffff * v4 < 0) {
                function_4878c2();
            }
            int32_t v18 = unknown_fe409b9c(); // 0x4ea3e
            v11 = v18;
            v9 = false;
            v7 = 0xfffff * v4 < 0;
            if (v15 < v4) {
                v5 = (v18 & 64) != 0;
                v12 = v18;
                v14 = v18;
                v10 = false;
                v6 = (v18 & 64) != 0;
                if (0xfffff * v4 < 0) {
                    goto lab_dec_label_pc_unknown_46;
                } else {
                    goto lab_dec_label_pc_unknown_47;
                }
            } else {
                goto lab_dec_label_pc_unknown_45;
            }
        }
    } else {
        int32_t v19 = unknown_fe409b9c(); // 0x4ea3e
        v11 = v19;
        v9 = false;
        v7 = false;
        v13 = v19;
        v8 = false;
        if (v3) {
            goto lab_dec_label_pc_unknown_45;
        } else {
            goto lab__thread17_2;
        }
    }
  lab_dec_label_pc_unknown_45:
    v5 = (v11 & 64) != 0;
    v12 = v11;
    v14 = v11;
    v10 = v9;
    v6 = (v11 & (1 << a4 - 1 | 64)) != 0;
    if (v7) {
        goto lab_dec_label_pc_unknown_46;
    } else {
        goto lab_dec_label_pc_unknown_47;
    }
  lab__thread17_2:
    // .thread17
    v14 = v13;
    v10 = v8;
    v6 = (v13 & 64) != 0;
    goto lab_dec_label_pc_unknown_47;
  lab_dec_label_pc_unknown_46:;
    bool v24 = v5;
    uint32_t v25 = v12 / 128; // 0x4ea4e
    int32_t v26 = v25 - v2 + (int32_t)!v24; // 0x4ea4e
    bool v27 = !v24 ? v2 != -1 | v25 < v26 - (int32_t)!v24 : v25 < v2; // 0x4ea4e
    v14 = v12;
    v10 = v26 == 0;
    v6 = !v27;
    goto lab_dec_label_pc_unknown_47;
  lab_dec_label_pc_unknown_47:;
    bool v20 = v10;
    int32_t result2 = v14;
    bool v21 = ((result2 & 0x200000) != 0 | v6 == ((result2 & 4) != 0)) == !v20 ? 2048 * result2 == result2 : v20;
    if (v21) {
        int16_t v22; // 0x4ea16
        int16_t v23 = v22;
        *(int16_t *)result2 = v23;
    }
    return result2;
}

// Address range: 0x4ea62 - 0x4ea64
int32_t function_4ea62(void) {
    // 0x4ea62
    int32_t v1; // 0x4ea62
    return function_4f1a6(v1);
}

// Address range: 0x4ea64 - 0x4ea68
int32_t function_4ea64(void) {
    // 0x4ea64
    int32_t result; // 0x4ea64
    return result;
}

// Address range: 0x4ea70 - 0x4ea94
int32_t function_4ea70(int32_t result) {
    if (result == 4) {
        // 0x4ea8c
        __asm_vldr(*(int32_t *)12);
        return 4;
    }
    // 0x4ea84
    __asm_vldr(0);
    return result;
}

// Address range: 0x4ea94 - 0x4ea98
int32_t function_4ea94(void) {
    // 0x4ea94
    return function_44f0d8();
}

// Address range: 0x4ea9c - 0x4eaf4
int32_t function_4ea9c(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x4ea9c
    return a1 == 0 ? -1 : a1;
}

// Address range: 0x4eaf4 - 0x4eaf8
int32_t function_4eaf4(void) {
    // 0x4eaf4
    return function_44f138();
}

// Address range: 0x4eafc - 0x4eb40
int32_t function_4eafc(int32_t result2) {
    // 0x4eafc
    bool v1; // 0x4eafc
    if (!v1) {
        __asm_svcvc(0xefffff);
    }
    switch (result2) {
        case 4: {
            // 0x4eb24
            __asm_vldr(*(int32_t *)12);
            return 4;
        }
        case 3: {
            int64_t v2 = *(int64_t *)11; // 0x4eb30
            int32_t v3 = v2; // 0x4eb30
            int32_t result = function_600c4(v2 >> 32, v3); // 0x4eb34
            __asm_vmov(result, v3);
            return result;
        }
    }
    // 0x4eb1c
    __asm_vldr(0);
    return result2;
}

// Address range: 0x4eb48 - 0x4eb54
int32_t function_4eb48(void) {
    // 0x4eb48
    return &g312;
}

// Address range: 0x4eb54 - 0x4eb5c
int32_t function_4eb54(void) {
    // 0x4eb54
    return &g313;
}

// Address range: 0x4eb60 - 0x4eb68
int32_t function_4eb60(void) {
    // 0x4eb60
    return &g314;
}

// Address range: 0x4eb6c - 0x4ec38
int32_t function_4eb6c(int32_t result) {
    if (result == 0) {
        return result;
    }
    // 0x4eb78
    g493 = result;
    int32_t v1; // 0x4eb6c
    switch (result) {
        case 4: {
        }
        case 3: {
            // 0x4eba4
            return function_4d898(result);
        }
        case 1: {
            int32_t v2 = *(int32_t *)13; // 0x4ebc8
            int32_t v3 = *(int32_t *)17; // 0x4ebcc
            v1 = v3;
            int32_t v4 = 0; // 0x4ebd8
            if (v2 != 0) {
                int32_t v5 = *(int32_t *)(4 * v4 + v3); // 0x4ebdc
                int32_t v6 = v3; // 0x4ebe4
                int32_t v7 = v2; // 0x4ebe4
                int32_t v8; // 0x4eb6c
                int32_t v9; // 0x4ec00
                int32_t v10; // 0x4ebe8
                int32_t * v11; // 0x4ebe8
                if (v5 != 0) {
                    // 0x4ebe8
                    v10 = v5 + 4;
                    v11 = (int32_t *)v10;
                    v6 = v3;
                    v7 = v2;
                    if (*v11 != -1) {
                        // 0x4ebf8
                        __asm_dmb(v3, v2, v10, v5);
                        v8 = *v11;
                        v9 = v8 - 1;
                        while (__asm_strex(v9, v8) != 0) {
                            // 0x4ebfc
                            v8 = *v11;
                            v9 = v8 - 1;
                        }
                        if (v9 == 0) {
                            // 0x4ec18
                            function_4eb6c(v5);
                        }
                        // 0x4ec20
                        v6 = *(int32_t *)17;
                        v7 = *(int32_t *)13;
                    }
                }
                int32_t v12 = v4 + 1; // 0x4ec28
                v1 = v6;
                v4 = v12;
                while (v12 < v7) {
                    int32_t v13 = v7;
                    int32_t v14 = v6;
                    v5 = *(int32_t *)(4 * v4 + v14);
                    v6 = v14;
                    v7 = v13;
                    if (v5 != 0) {
                        // 0x4ebe8
                        v10 = v5 + 4;
                        v11 = (int32_t *)v10;
                        v6 = v14;
                        v7 = v13;
                        if (*v11 != -1) {
                            // 0x4ebf8
                            __asm_dmb(v14, v13, v10, v5);
                            v8 = *v11;
                            v9 = v8 - 1;
                            while (__asm_strex(v9, v8) != 0) {
                                // 0x4ebfc
                                v8 = *v11;
                                v9 = v8 - 1;
                            }
                            if (v9 == 0) {
                                // 0x4ec18
                                function_4eb6c(v5);
                            }
                            // 0x4ec20
                            v6 = *(int32_t *)17;
                            v7 = *(int32_t *)13;
                        }
                    }
                    // 0x4ec28
                    v12 = v4 + 1;
                    v1 = v6;
                    v4 = v12;
                }
            }
            // break -> 0x4eba0
            break;
        }
        case 2: {
            // 0x4eba0
            function_4d898(*(int32_t *)10);
            // 0x4eba4
            return function_4d898(result);
        }
        default: {
            return result;
        }
    }
    // 0x4eba0
    function_4d898(v1);
    // 0x4eba4
    return function_4d898(result);
}

// Address range: 0x4ec38 - 0x4ecc8
int32_t function_4ec38(int32_t a1) {
    if (a1 != 1) {
        // 0x4ecc0
        return -1;
    }
    int32_t v1 = *(int32_t *)13; // 0x4ec50
    int32_t v2 = 0; // 0x4ec58
    if (v1 == 0) {
        // 0x4ecb4
        *(int32_t *)13 = 0;
        return 0;
    }
    int32_t v3 = *(int32_t *)(*(int32_t *)17 + 4 * v2); // 0x4ec64
    int32_t v4 = v1; // 0x4ec6c
    int32_t v5; // 0x4ec88
    int32_t v6; // 0x4ec70
    int32_t * v7; // 0x4ec70
    int32_t v8; // 0x4ec70
    int32_t v9; // 0x4ec80
    int32_t v10; // 0x4ec38
    if (v3 != 0) {
        // 0x4ec70
        v6 = v3 + 4;
        v7 = (int32_t *)v6;
        v8 = *v7;
        v4 = v1;
        if (v8 != -1) {
            // 0x4ec80
            v9 = __asm_dmb(v3, v8, v1, v6);
            v10 = *v7;
            v5 = v10 - 1;
            while (__asm_strex(v5, v10) != 0) {
                // 0x4ec84
                v10 = *v7;
                v5 = v10 - 1;
            }
            if (v5 == 0) {
                // 0x4eca0
                function_4eb6c(v9);
            }
            // 0x4eca4
            v4 = *(int32_t *)13;
        }
    }
    // 0x4eca8
    v2++;
    while (v4 >= v2 == (v4 != v2)) {
        int32_t v11 = v4;
        v3 = *(int32_t *)(*(int32_t *)17 + 4 * v2);
        v4 = v11;
        if (v3 != 0) {
            // 0x4ec70
            v6 = v3 + 4;
            v7 = (int32_t *)v6;
            v8 = *v7;
            v4 = v11;
            if (v8 != -1) {
                // 0x4ec80
                v9 = __asm_dmb(v3, v8, v11, v6);
                v10 = *v7;
                v5 = v10 - 1;
                while (__asm_strex(v5, v10) != 0) {
                    // 0x4ec84
                    v10 = *v7;
                    v5 = v10 - 1;
                }
                if (v5 == 0) {
                    // 0x4eca0
                    function_4eb6c(v9);
                }
                // 0x4eca4
                v4 = *(int32_t *)13;
            }
        }
        // 0x4eca8
        v2++;
    }
    // 0x4ecb4
    *(int32_t *)13 = 0;
    return 0;
}

// Address range: 0x4ecc8 - 0x4ecd8
int32_t function_4ecc8(int32_t a1) {
    int32_t result = a1; // 0x4ecd0
    if (a1 == 0) {
        int32_t v1; // 0x4ecc8
        result = function_4ece0(0, v1, v1, (int32_t)&g488);
    }
    // 0x4ecd4
    return result;
}

// Address range: 0x4ecda - 0x4ecdc
int32_t function_4ecda(int32_t a1) {
    // 0x4ecda
    return function_4f384(a1);
}

// Address range: 0x4ecdc - 0x4ece0
int32_t function_4ecdc(void) {
    // 0x4ecdc
    int32_t result; // 0x4ecdc
    return result;
}

// Address range: 0x4ece0 - 0x4ed30
int32_t function_4ece0(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    if (a3 == 0) {
        // 0x4ecf4
        return -1;
    }
    int32_t v1 = a3 + 4; // 0x4ece8
    int32_t * v2 = (int32_t *)v1; // 0x4ece8
    if (*v2 == -1) {
        // 0x4ecf4
        return -1;
    }
    // 0x4ecfc
    __asm_dmb(a1, a2, a3, v1);
    int32_t v3 = *v2;
    int32_t v4 = v3 - 1; // 0x4ed08
    while (__asm_strex(v4, v3) != 0) {
        // 0x4ed04
        v3 = *v2;
        v4 = v3 - 1;
    }
    if (v4 != 0) {
        // 0x4ecf4
        return -1;
    }
    // 0x4ed20
    function_4eb6c(a3);
    return -1;
}

// Address range: 0x4ed30 - 0x4ed60
int32_t function_4ed30(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = a2; // 0x4ed4c
    if (a2 == 0) {
        v1 = function_4ece0(a2, a2, a3, (int32_t)&g488);
    }
    // 0x4ed50
    function_4bec0(v1, a3);
    return a2 == 0;
}

// Address range: 0x4ed60 - 0x4ee2c
int32_t function_4ed60(int32_t a1, uint32_t a2) {
    // 0x4ed60
    if (a1 != 1) {
        // 0x4ee24
        return -1;
    }
    uint32_t v1 = *(int32_t *)13; // 0x4ed78
    if (v1 == a2 || v1 < a2) {
        // 0x4ee24
        return -1;
    }
    int32_t v2 = 4 * a2; // 0x4ed8c
    int32_t v3 = *(int32_t *)17 + v2;
    int32_t v4 = *(int32_t *)v3; // 0x4ed90
    int32_t v5; // 0x4ed60
    int32_t v6; // 0x4ed60
    int32_t v7; // 0x4ed60
    if (v4 == 0) {
        goto lab_0x4eda8;
    } else {
        int32_t v8 = v4 + 4; // 0x4ed9c
        int32_t * v9 = (int32_t *)v8; // 0x4ed9c
        if (*v9 == -1) {
            goto lab_0x4eda8;
        } else {
            // 0x4edc0
            int32_t v10; // 0x4ed60
            int32_t v11 = __asm_dmb(v4, a2, v10, v8); // 0x4edc4
            int32_t v12 = *v9;
            int32_t v13 = v12 - 1; // 0x4edcc
            while (__asm_strex(v13, v12) != 0) {
                // 0x4edc8
                v12 = *v9;
                v13 = v12 - 1;
            }
            if (v13 == 0) {
                // 0x4ede4
                function_4eb6c(v11);
            }
            int32_t v14 = *(int32_t *)13; // 0x4ede8
            int32_t v15 = v14 - 1; // 0x4edec
            if (v15 == a2 || v15 < a2) {
                // 0x4edb4
                *(int32_t *)13 = v15;
                return 0;
            }
            // 0x4ede8
            v5 = *(int32_t *)17 + v2;
            v7 = v15;
            v6 = v14;
            goto lab_0x4edf8;
        }
    }
  lab_0x4eda8:;
    int32_t v16 = v1 - 1; // 0x4eda8
    v5 = v3;
    v7 = v16;
    v6 = v1;
    if (v16 >= a2 != v16 != a2) {
        // 0x4edb4
        *(int32_t *)13 = v16;
        return 0;
    }
    goto lab_0x4edf8;
  lab_0x4edf8:;
    int32_t v17 = v5;
    function_11f64(v17, v17 + 4, 4 * (v6 + (a2 ^ 0x3fffffff)), v7);
    // 0x4edb4
    *(int32_t *)13 = *(int32_t *)13 - 1;
    return 0;
}

// Address range: 0x4ee2c - 0x4eee8
int32_t function_4ee2c(int32_t a1, int32_t a2, int32_t a3) {
    if (a3 == 0) {
        // 0x4ee50
        return -1;
    }
    int32_t v1 = a3 + 4; // 0x4ee44
    int32_t * v2 = (int32_t *)v1; // 0x4ee44
    if (*v2 == -1) {
        // 0x4ee50
        return -1;
    }
    // 0x4eeb4
    __asm_dmb(a1, a2, a3, v1);
    int32_t v3 = *v2;
    int32_t v4 = v3 - 1; // 0x4eec0
    while (__asm_strex(v4, v3) != 0) {
        // 0x4eebc
        v3 = *v2;
        v4 = v3 - 1;
    }
    if (v4 != 0) {
        // 0x4ee50
        return -1;
    }
    // 0x4eed8
    function_4eb6c(a3);
    return -1;
}

// Address range: 0x4eee8 - 0x4efd4
int32_t function_4eee8(int32_t a1, int32_t a2) {
    // 0x4eee8
    return -1;
}

// Address range: 0x4efd4 - 0x4f068
int32_t function_4efd4(int32_t a1, char * str, int32_t a3) {
    int32_t v1 = (int32_t)str;
    int32_t v2 = a1; // 0x4efe0
    int32_t len = v1; // 0x4efe0
    if (str != NULL) {
        // 0x4efe4
        len = strlen(str);
        v2 = 0;
        if (function_4dfec(v1, len) != 0) {
            // 0x4f054
            return function_4ee2c(a1, v1, a3);
        }
    }
    if (a3 == 0) {
        // 0x4f018
        return -1;
    }
    int32_t v3 = a3 + 4; // 0x4f00c
    int32_t * v4 = (int32_t *)v3; // 0x4f00c
    if (*v4 == -1) {
        // 0x4f018
        return -1;
    }
    // 0x4f020
    __asm_dmb(v2, len, a3, v3);
    int32_t v5 = *v4;
    int32_t v6 = v5 - 1; // 0x4f02c
    while (__asm_strex(v6, v5) != 0) {
        // 0x4f028
        v5 = *v4;
        v6 = v5 - 1;
    }
    if (v6 != 0) {
        // 0x4f018
        return -1;
    }
    // 0x4f044
    function_4eb6c(a3);
    return -1;
}

// Address range: 0x4f068 - 0x4f148
int32_t function_4f068(int32_t a1, int32_t a2) {
    // 0x4f068
    return -1;
}

// Address range: 0x4f148 - 0x4f19c
int32_t function_4f148(int32_t a1, int32_t a2) {
    if (a1 == 0) {
        int32_t v1 = function_4f230((int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488); // 0x4f150
        if (v1 == 0) {
            goto lab_0x4f170;
        } else {
            // 0x4f154
            function_4f230((int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488);
            goto lab_0x4f170;
        }
    } else {
        // 0x4f154
        function_4f230((int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488);
        goto lab_0x4f170;
    }
  lab_0x4f170:
    if (a2 != 0) {
        function_4f230((int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488);
    }
    // 0x4f17c
    if (function_4be20(a2 + 8) != 0) {
        function_4f200((int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488);
    }
    // 0x4f194
    return 0;
}

// Address range: 0x4f19c - 0x4f1a4
int32_t function_4f19c(void) {
    // 0x4f19c
    int32_t v1; // 0x4f19c
    return function_4e234(v1, (char *)v1);
}

// Address range: 0x4f1a6 - 0x4f1ac
int32_t function_4f1a6(int32_t a1) {
    // 0x4f1a6
    return function_4f384(4);
}

// Address range: 0x4f1ac - 0x4f200
int32_t function_4f1ac(int32_t a1, int32_t a2, int32_t a3) {
    // 0x4f1ac
    int32_t v1; // 0x4f1ac
    if (a3 == -1) {
        // 0x4f1d0
        function_4ee2c(v1, v1, v1);
        return function_4be98(v1, v1);
    }
    int32_t v2 = v1 + 4; // 0x4f1ac
    int32_t v3 = *(int32_t *)v2;
    int32_t v4 = v3 + 1; // 0x4f1bc
    while (__asm_strex(v4, v3) != 0) {
        // 0x4f1b8
        v3 = *(int32_t *)v2;
        v4 = v3 + 1;
    }
    // 0x4f1cc
    __asm_dmb(a1, 0, v4, v2);
    // 0x4f1d0
    function_4ee2c(v1, v1, v1);
    return function_4be98(v1, v1);
}

// Address range: 0x4f200 - 0x4f230
int32_t function_4f200(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    // 0x4f200
    int32_t v1; // 0x4f200
    int32_t v2 = function_4beb0(v1); // 0x4f200
    if (function_4beb8(v2 - 16) != 0) {
        function_4f19c();
    }
    // 0x4f228
    return 0;
}

// Address range: 0x4f230 - 0x4f238
int32_t function_4f230(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    // 0x4f230
    return -1;
}

// Address range: 0x4f238 - 0x4f384
int32_t function_4f238(int32_t a1, uint32_t a2, int32_t a3) {
    if (a3 == 0) {
        // 0x4f280
        return -1;
    }
    int32_t v1 = a3; // 0x4f238
    int32_t v2; // 0x4f238
    switch (a1) {
        case 0: {
            goto lab_0x4f274;
        }
        case 1: {
            uint32_t v3 = *(int32_t *)13; // 0x4f2bc
            v1 = 0;
            if (v3 < a2) {
                goto lab_0x4f274;
            } else {
                int32_t v4 = function_4e0b8(1, 1, 0); // 0x4f2cc
                if (v4 != 0) {
                    int32_t v5 = *(int32_t *)17; // 0x4f2d8
                    int32_t v6 = 4 * a2; // 0x4f2dc
                    int32_t v7 = v6 + 4; // 0x4f2e0
                    int32_t v8 = v4 + v6; // 0x4f2ec
                    if (v5 == v4) {
                        // 0x4f36c
                        return function_11f64(v4 + v7, v8, 4 * (*(int32_t *)13 - a2), v3);
                    }
                    // 0x4f2f4
                    function_11fc4((int32_t *)v5, v4, (char)v6, v3);
                    int32_t v9 = *(int32_t *)13; // 0x4f300
                    int32_t v10 = *(int32_t *)17; // 0x4f308
                    function_11fc4((int32_t *)(v10 + v7), v8, 4 * (char)(v9 - a2), v3);
                    function_4d898(v4);
                    *(int32_t *)(*(int32_t *)17 + v6) = a3;
                    *(int32_t *)13 = *(int32_t *)13 + 1;
                    return 0;
                }
                int32_t v11 = a3 + 4; // 0x4f340
                int32_t * v12 = (int32_t *)v11; // 0x4f340
                if (*v12 == -1) {
                    // 0x4f280
                    return -1;
                }
                // 0x4f34c
                __asm_dmb(0, 1, 0, v11);
                int32_t v13 = *v12;
                int32_t v14 = v13 - 1; // 0x4f358
                int32_t v15 = __asm_strex(v14, v13); // 0x4f35c
                v2 = v14;
                while (v15 != 0) {
                    // 0x4f354
                    v13 = *v12;
                    v14 = v13 - 1;
                    v15 = __asm_strex(v14, v13);
                    v2 = v14;
                }
                goto lab_0x4f2a4;
            }
        }
        default: {
            v1 = 1;
            goto lab_0x4f274;
        }
    }
  lab_0x4f274:;
    int32_t v16 = a3 + 4; // 0x4f274
    int32_t * v17 = (int32_t *)v16; // 0x4f274
    if (*v17 == -1) {
        // 0x4f280
        return -1;
    }
    // 0x4f288
    __asm_dmb(a1, a2, v1, v16);
    int32_t v18 = *v17;
    int32_t v19 = v18 - 1; // 0x4f294
    int32_t v20 = __asm_strex(v19, v18); // 0x4f298
    v2 = v19;
    while (v20 != 0) {
        // 0x4f290
        v18 = *v17;
        v19 = v18 - 1;
        v20 = __asm_strex(v19, v18);
        v2 = v19;
    }
    goto lab_0x4f2a4;
  lab_0x4f2a4:
    // 0x4f2a4
    if (v2 != 0) {
        // 0x4f280
        return -1;
    }
    // 0x4f2ac
    function_4eb6c(a3);
    return -1;
}

// Address range: 0x4f384 - 0x4f385
int32_t function_4f384(int32_t a1) {
    // 0x4f384
    int32_t result; // 0x4f384
    return result;
}

// Address range: 0x4f388 - 0x4f494
int32_t function_4f388(int32_t a1, uint32_t a2, int32_t a3) {
    // 0x4f388
    if (a3 == 0) {
        // 0x4f3d4
        return -1;
    }
    if (a1 == 1) {
        uint32_t v1 = *(int32_t *)13; // 0x4f40c
        if (v1 != a2 && v1 >= a2) {
            int32_t v2 = 4 * a2; // 0x4f41c
            int32_t v3 = *(int32_t *)17 + v2; // 0x4f420
            int32_t v4 = *(int32_t *)v3; // 0x4f420
            if (v4 == 0) {
                // 0x4f43c
                *(int32_t *)v3 = a3;
                // 0x4f3d4
                return 0;
            }
            int32_t v5 = v4 + 4; // 0x4f430
            int32_t * v6 = (int32_t *)v5; // 0x4f430
            int32_t v7 = *v6; // 0x4f430
            if (v7 == -1) {
                // 0x4f43c
                *(int32_t *)v3 = a3;
                // 0x4f3d4
                return 0;
            }
            int32_t v8 = __asm_dmb(v4, v7, a3, v5); // 0x4f44c
            int32_t v9 = *v6;
            int32_t v10 = v9 - 1; // 0x4f454
            while (__asm_strex(v10, v9) != 0) {
                // 0x4f450
                v9 = *v6;
                v10 = v9 - 1;
            }
            if (v10 == 0) {
                // 0x4f474
                function_4eb6c(v8);
            }
            // 0x4f43c
            *(int32_t *)(*(int32_t *)17 + v2) = a3;
            // 0x4f3d4
            return 0;
        }
    }
    int32_t v11 = a3 + 4; // 0x4f3c4
    int32_t * v12 = (int32_t *)v11; // 0x4f3c4
    if (*v12 == -1) {
        // 0x4f3d4
        return -1;
    }
    // 0x4f3dc
    __asm_dmb(a1, a2, a3, v11);
    int32_t v13 = *v12;
    int32_t v14 = v13 - 1; // 0x4f3e8
    while (__asm_strex(v14, v13) != 0) {
        // 0x4f3e4
        v13 = *v12;
        v14 = v13 - 1;
    }
    // 0x4f3f8
    if (v14 == 0) {
        // 0x4f400
        function_4eb6c(a3);
    }
    // 0x4f3d4
    return -1;
}

// Address range: 0x4f494 - 0x4f570
int32_t function_4f494(int32_t a1, int32_t a2) {
    // 0x4f494
    if (a2 == 0) {
        // 0x4f4d8
        return -1;
    }
    int32_t v1; // 0x4f494
    if (a1 == 1) {
        // 0x4f514
        if (function_4e0b8(1, 1, 1) != 0) {
            int32_t v2 = *(int32_t *)13; // 0x4f528
            *(int32_t *)(*(int32_t *)17 + 4 * v2) = a2;
            *(int32_t *)13 = v2 + 1;
            return 0;
        }
        int32_t v3 = a2 + 4; // 0x4f544
        int32_t * v4 = (int32_t *)v3; // 0x4f544
        if (*v4 == -1) {
            // 0x4f4d8
            return -1;
        }
        // 0x4f550
        __asm_dmb(0, 1, 1, v3);
        int32_t v5 = *v4;
        int32_t v6 = v5 - 1; // 0x4f55c
        int32_t v7 = __asm_strex(v6, v5); // 0x4f560
        v1 = v6;
        while (v7 != 0) {
            // 0x4f558
            v5 = *v4;
            v6 = v5 - 1;
            v7 = __asm_strex(v6, v5);
            v1 = v6;
        }
    } else {
        int32_t v8 = a2 + 4; // 0x4f4cc
        int32_t * v9 = (int32_t *)v8; // 0x4f4cc
        if (*v9 == -1) {
            // 0x4f4d8
            return -1;
        }
        // 0x4f4e0
        int32_t v10; // 0x4f494
        __asm_dmb(a1, a2, v10, v8);
        int32_t v11 = *v9;
        int32_t v12 = v11 - 1; // 0x4f4ec
        int32_t v13 = __asm_strex(v12, v11); // 0x4f4f0
        v1 = v12;
        while (v13 != 0) {
            // 0x4f4e8
            v11 = *v9;
            v12 = v11 - 1;
            v13 = __asm_strex(v12, v11);
            v1 = v12;
        }
    }
    // 0x4f4fc
    if (v1 != 0) {
        // 0x4f4d8
        return -1;
    }
    // 0x4f504
    function_4eb6c(a2);
    return -1;
}

// Address range: 0x4f570 - 0x4f588
int32_t function_4f570(int32_t a1, int32_t a2) {
    if (a1 == 0 || a2 == 0) {
        // 0x4f580
        return 0;
    }
    // 0x4f57c
    return function_4e25c(a1, a2);
}

// Address range: 0x4f588 - 0x4f744
int32_t function_4f588(int32_t a1) {
    if (a1 == 0) {
        // 0x4f5c8
        return 0;
    }
    // 0x4f594
    g485 = a1;
    int32_t result = a1; // 0x4f59c
    switch (a1) {
        case 7: {
            return result;
        }
        case 1: {
            int32_t v1 = function_4e540(); // 0x4f678
            result = v1;
            switch (v1) {
                case 0: {
                    return 0;
                }
                case 1: {
                    int32_t v2 = *(int32_t *)13; // 0x4f690
                    if (v2 == 0) {
                        // 0x4f5c8
                        return 1;
                    }
                    uint32_t v3 = 0;
                    uint32_t v4 = v2;
                    int32_t v5 = 0; // 0x4f6bc
                    int32_t v6; // 0x4f588
                    int32_t v7; // 0x4f588
                    int32_t v8; // 0x4f6c4
                    int32_t v9; // 0x4f6cc
                    int32_t * v10; // 0x4f6d4
                    int32_t v11; // 0x4f6d4
                    int32_t v12; // 0x4f6e4
                    int32_t v13; // 0x4f6e8
                    int32_t v14; // 0x4f6e4
                    int32_t v15; // 0x4f6e8
                    if (v4 != v3 && v4 >= v3) {
                        // 0x4f6c0
                        v8 = *(int32_t *)(*(int32_t *)17 + 4 * v3);
                        v5 = 0;
                        if (v8 != 0) {
                            // 0x4f6d4
                            v9 = v8 + 4;
                            v10 = (int32_t *)v9;
                            v11 = *v10;
                            v5 = v8;
                            if (v11 != -1) {
                                // 0x4f6e0
                                v12 = v11 + 1;
                                v13 = __asm_strex(v12, v11);
                                v6 = v12;
                                if (v13 != 0) {
                                    v7 = *v10;
                                    v14 = v7 + 1;
                                    v15 = __asm_strex(v14, v7);
                                    v6 = v14;
                                    while (v15 != 0) {
                                        // 0x4f6e0
                                        v7 = *v10;
                                        v14 = v7 + 1;
                                        v15 = __asm_strex(v14, v7);
                                        v6 = v14;
                                    }
                                }
                                // 0x4f6f4
                                __asm_dmb(0, v8, v9, v6);
                                v5 = v8;
                            }
                        }
                    }
                    // 0x4f6f8
                    result = 1;
                    while (function_4f494(1, v5) == 1) {
                        uint32_t v16 = *(int32_t *)13; // 0x4f6a4
                        int32_t v17 = v3 + 1; // 0x4f6a8
                        result = 1;
                        if (v17 >= v16) {
                            // break -> 0x4f5c8
                            break;
                        }
                        v3 = v17;
                        v4 = v16;
                        v5 = 0;
                        if (v4 != v3 && v4 >= v3) {
                            // 0x4f6c0
                            v8 = *(int32_t *)(*(int32_t *)17 + 4 * v3);
                            v5 = 0;
                            if (v8 != 0) {
                                // 0x4f6d4
                                v9 = v8 + 4;
                                v10 = (int32_t *)v9;
                                v11 = *v10;
                                v5 = v8;
                                if (v11 != -1) {
                                    // 0x4f6e0
                                    v12 = v11 + 1;
                                    v13 = __asm_strex(v12, v11);
                                    v6 = v12;
                                    if (v13 != 0) {
                                        v7 = *v10;
                                        v14 = v7 + 1;
                                        v15 = __asm_strex(v14, v7);
                                        v6 = v14;
                                        while (v15 != 0) {
                                            // 0x4f6e0
                                            v7 = *v10;
                                            v14 = v7 + 1;
                                            v15 = __asm_strex(v14, v7);
                                            v6 = v14;
                                        }
                                    }
                                    // 0x4f6f4
                                    __asm_dmb(0, v8, v9, v6);
                                    v5 = v8;
                                }
                            }
                        }
                        // 0x4f6f8
                        result = 1;
                    }
                    // 0x4f5c8
                    return result;
                }
                default: {
                    return result;
                }
            }
        }
        case 2: {
            uint64_t v18 = *(int64_t *)10; // 0x4f714
            return function_4e144((int32_t)(v18 / 0x100000000), (int32_t)v18, 0);
        }
        case 3: {
            // 0x4f724
            return function_4e068(3);
        }
        case 4: {
            // 0x4f730
            __asm_vldr(*(int32_t *)12);
            return function_4ea14();
        }
        case 5: {
            return result;
        }
        case 6: {
            return result;
        }
        default: {
            return 0;
        }
    }
}

// Address range: 0x4f744 - 0x4f8a8
int32_t function_4f744(int32_t a1) {
    if (a1 == 0) {
        // 0x4f784
        return 0;
    }
    // 0x4f750
    g486 = a1;
    int32_t result = a1; // 0x4f758
    switch (a1) {
        case 7: {
            return result;
        }
        case 1: {
            int32_t v1 = function_4e540(); // 0x4f808
            result = v1;
            switch (v1) {
                case 0: {
                    return 0;
                }
                case 1: {
                    int32_t v2 = *(int32_t *)13; // 0x4f820
                    if (v2 == 0) {
                        // 0x4f784
                        return 1;
                    }
                    uint32_t v3 = 0;
                    uint32_t v4 = v2;
                    int32_t v5 = 0; // 0x4f84c
                    if (v4 >= v3 == (v4 != v3)) {
                        v5 = *(int32_t *)(*(int32_t *)17 + 4 * v3);
                    }
                    int32_t v6 = function_4f744(v5); // 0x4f854
                    result = 1;
                    while (function_4f494(1, v6) == 1) {
                        uint32_t v7 = *(int32_t *)13; // 0x4f834
                        int32_t v8 = v3 + 1; // 0x4f838
                        result = 1;
                        if (v8 >= v7) {
                            // break -> 0x4f784
                            break;
                        }
                        v3 = v8;
                        v4 = v7;
                        v5 = 0;
                        if (v4 >= v3 == (v4 != v3)) {
                            v5 = *(int32_t *)(*(int32_t *)17 + 4 * v3);
                        }
                        v6 = function_4f744(v5);
                        result = 1;
                    }
                    // 0x4f784
                    return result;
                }
                default: {
                    return result;
                }
            }
        }
        case 2: {
            uint64_t v9 = *(int64_t *)10; // 0x4f878
            return function_4e144((int32_t)(v9 / 0x100000000), (int32_t)v9, 0);
        }
        case 3: {
            // 0x4f888
            return function_4e068(3);
        }
        case 4: {
            // 0x4f894
            __asm_vldr(*(int32_t *)12);
            return function_4ea14();
        }
        case 5: {
            return result;
        }
        case 6: {
            return result;
        }
        default: {
            return 0;
        }
    }
}

// Address range: 0x4f8a8 - 0x4f90c
int32_t function_4f8a8(int32_t a1, int32_t a2) {
    char * str = (char *)a2; // 0x4f8b8
    uint32_t len = strlen(str); // 0x4f8b8
    if (len == 79 || len < 79) {
        // 0x4f8f8
        return (int32_t)strncpy((char *)(a1 + 12), str, len + 1);
    }
    // 0x4f8c8
    *(int16_t *)(a1 + 12) = *(int16_t *)&g245;
    *(char *)(a1 + 14) = 46;
    return (int32_t)strncpy((char *)(a1 + 15), (char *)(a2 - 76 + len), 77);
}

// Address range: 0x4f90c - 0x4f94c
int32_t function_4f90c(int32_t result, char * a2) {
    if (result == 0) {
        return 0;
    }
    int32_t v1 = (int32_t)a2;
    *(char *)(result + 92) = 0;
    *(int32_t *)(result + 8) = 0;
    *(int32_t *)result = -1;
    *(int32_t *)(result + 4) = -1;
    if (a2 != NULL) {
        // 0x4f944
        return function_4f8a8(result, v1);
    }
    // 0x4f93c
    *(char *)(result + 12) = (char)v1;
    return result;
}

// Address range: 0x4f94c - 0x4f95c
int32_t function_4f94c(int32_t result, int32_t a2) {
    if (result == 0 || a2 == 0) {
        return result;
    }
    // 0x4f958
    return function_4f8a8(result, a2);
}

// Address range: 0x4f95c - 0x4f9c0
int32_t function_4f95c(int32_t result, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t format) {
    if (result == 0) {
        // 0x4f980
        return result;
    }
    char * str = (char *)(result + 92); // 0x4f974
    if (*str != 0) {
        // 0x4f980
        return result;
    }
    // 0x4f988
    *(int32_t *)result = a2;
    *(int32_t *)(result + 4) = a3;
    *(int32_t *)(result + 8) = a4;
    int32_t v1; // 0x4f95c
    int32_t chars_printed = vsnprintf(str, 159, (char *)format, (int32_t)&v1); // 0x4f9a8
    *(char *)(result + 250) = 0;
    *(char *)(result + 251) = (char)a5;
    return chars_printed;
}

// Address range: 0x4f9c0 - 0x4fa0c
int32_t function_4f9c0(int32_t result, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t format, int32_t a7) {
    if (result == 0) {
        return result;
    }
    char * str = (char *)(result + 92); // 0x4f9cc
    if (*str != 0) {
        return result;
    }
    // 0x4f9d8
    *(int32_t *)result = a2;
    *(int32_t *)(result + 4) = a3;
    *(int32_t *)(result + 8) = a4;
    int32_t chars_printed = vsnprintf(str, 159, (char *)format, a7); // 0x4f9f8
    *(char *)(result + 250) = 0;
    *(char *)(result + 251) = (char)a5;
    return chars_printed;
}

// Address range: 0x4fa0c - 0x4fa10
int32_t function_4fa0c(int32_t a1) {
    // 0x4fa0c
    int32_t v1; // 0x4fa0c
    return function_5198c(a1, v1, v1, v1);
}

// Address range: 0x4fa10 - 0x4fa9c
int32_t function_4fa10(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x4fa10
    int32_t v1; // bp-44, 0x4fa10
    int32_t v2 = function_51cac(a2, a3, a4, a5, &v1); // 0x4fa44
    int32_t result = -1; // 0x4fa4c
    if (v2 == 0) {
        // 0x4fa50
        function_51e54(a1, &v1, 9);
        function_51b44((int32_t)(a2 != 1), a1, a2 == 1 ? 0 : a3, a4, a5);
        result = 0;
    }
    // 0x4fa88
    return result;
}

// Address range: 0x4fa9c - 0x4faec
int32_t function_4fa9c(int32_t a1, int32_t a2, int32_t a3, uint32_t a4, uint32_t a5, uint32_t a6, uint32_t a7, uint32_t a8) {
    if (a4 >= 3 == (a4 != 3)) {
        // 0x4fae4
        return -1;
    }
    int32_t v1 = __asm_bfi(__asm_bfi(0x40000000, a6 % 256, 0, 3), a5 % 256, 4, 3); // 0x4fac8
    unsigned char v2 = *(char *)(a4 + (int32_t)"\b`dh"); // 0x4facc
    return function_4fa10(a1, a2, a3, (int32_t)v2, 0x1000000 * __asm_bfi(__asm_bfi(v1, a7 % 256, 8, 6), a8 % 0x10000, 16, 12) >> 24);
}

// Address range: 0x4faec - 0x4fb64
int32_t function_4faec(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = __asm_bfc(__asm_bfc(__asm_bfi(__asm_bfi(0, 31, 0, 8), 5, 8, 4) | 0x8000, 16, 8) | -0x80000000, 0, 8); // 0x4fb28
    function_4fa10(a1, a2, a3, 60, (int32_t)&g488);
    usleep(0x2710);
    return function_4fa10(a1, a2, a3, 60, __asm_bfc(__asm_bfi(v1, 6, 8, 4), 15, 1));
}

// Address range: 0x4fb64 - 0x4fbdc
int32_t function_4fb64(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = __asm_bfc(__asm_bfi(__asm_bfi(0, __asm_bfi(4, a4, 0, 2), 0, 8), 1, 8, 4) | 0x8000, 16, 8) | -0x80000000; // 0x4fb94
    function_4fa10(a1, a2, a3, 60, v1);
    usleep(0x2710);
    return function_4fa10(a1, a2, a3, 60, __asm_bfc(__asm_bfi(v1, 2, 8, 4), 15, 1));
}

// Address range: 0x4fbdc - 0x4fc14
int32_t function_4fbdc(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x4fbdc
    return function_4fa10(a1, a2, a3, 60, __asm_bfi(__asm_bfi(__asm_bfi(__asm_bfi(0, 170, 0, 8), 4, 8, 4) | 0x8000, a5, 16, 8), a4, 31, 1));
}

// Address range: 0x4fc14 - 0x4fcbc
int32_t function_4fc14(int32_t a1, int32_t a2, int32_t a3) {
    // 0x4fc14
    function_4fa10(a1, a2, a3, 188, 320);
    usleep(0x2710);
    int32_t v1; // bp-20, 0x4fc14
    if (a2 == 0) {
        // 0x4fc9c
        function_51a20(1, a1, a3, 176, &v1);
    } else {
        // 0x4fc48
        function_51a20(0, a1, 0, 176, &v1);
    }
    // 0x4fc64
    v1 = 0x207c310b;
    function_4fa10(a1, a2, a3, 176, 0x207c310b);
    usleep(0x2710);
    return 0;
}

// Address range: 0x4fcbc - 0x4fdf0
int32_t function_4fcbc(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x4fcbc
    function_4fa10(a1, a2, a3, 188, 504);
    usleep(0x2710);
    int32_t v1; // bp-28, 0x4fcbc
    if (a2 == 0) {
        // 0x4fdd0
        function_51a20(1, a1, a3, 176, &v1);
    } else {
        // 0x4fcf4
        function_51a20(0, a1, 0, 176, &v1);
    }
    int32_t v2 = __asm_bfi(504, a4, 0, 3); // 0x4fd24
    char v3; // 0x4fcbc
    __asm_bfc((int32_t)(v3 % 32 | 32), 2, 2);
    __asm_bfi((int32_t)(v3 | 48), 1, 0, 4);
    int32_t v4 = (char)v1 & -76 | 67; // 0x4fd58
    v1 = v4;
    function_4fa10(a1, a2, a3, 176, v4);
    usleep(0x2710);
    function_4fa10(a1, a2, a3, 188, v2);
    usleep(0x2710);
    function_4fa10(a1, a2, a3, 176, v1);
    usleep(0x2710);
    return 0;
}

// Address range: 0x4fdf0 - 0x4fe30
int32_t function_4fdf0(int32_t a1, int32_t a2, int32_t a3, int32_t a4, uint32_t a5, uint32_t a6) {
    int32_t v1 = __asm_bfi(__asm_bfi(0, a4, 4, 2), a5 % 256, 6, 2); // 0x4fe08
    int32_t v2 = v1; // 0x4fe10
    if (a6 % 256 == 0) {
        v2 = __asm_bfieq(v1, 0, 0, 1);
    }
    return function_4fa10(a1, a2, a3, 60, 0x1000000 * (v2 | (int32_t)(a6 % 256 != 0)) >> 24);
}

// Address range: 0x4fe30 - 0x4fe70
int32_t function_4fe30(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x4fe30
    return function_4fa10(a1, a2, a3, 60, __asm_bfc(__asm_bfi(__asm_bfi(0, a4 == 0 ? 0 : 64, 0, 8), 13, 8, 4) | 0x8000, 16, 8) | -0x80000000);
}

// Address range: 0x4fe70 - 0x4feac
int32_t function_4fe70(int32_t a1) {
    // 0x4fe70
    int32_t v1; // bp-16, 0x4fe70
    int32_t v2 = function_51e08(&v1); // 0x4fe80
    int32_t result = -1; // 0x4fe88
    if (v2 == 0) {
        // 0x4fe8c
        result = function_51e54(a1, &v1, 5);
    }
    // 0x4fe9c
    return result;
}

// Address range: 0x4feac - 0x4fef0
int32_t function_4feac(int32_t a1, int32_t a2) {
    // 0x4feac
    int32_t v1; // bp-16, 0x4feac
    int32_t v2 = function_51d44(a2, &v1); // 0x4fec4
    int32_t result = -1; // 0x4fecc
    if (v2 == 0) {
        // 0x4fed0
        result = function_51e54(a1, &v1, 5);
    }
    // 0x4fee0
    return result;
}

// Address range: 0x4fef0 - 0x4ff3c
int32_t function_4fef0(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x4fef0
    int32_t v1; // bp-16, 0x4fef0
    int32_t v2 = function_51d98(a2, a3, a4, &v1); // 0x4ff10
    int32_t result = -1; // 0x4ff18
    if (v2 == 0) {
        // 0x4ff1c
        result = function_51e54(a1, &v1, 5);
    }
    // 0x4ff2c
    return result;
}

// Address range: 0x4ff3c - 0x4ff4c
int32_t function_4ff3c(void) {
    // 0x4ff3c
    int32_t v1; // 0x4ff3c
    return function_4fef0(v1, 1, 0, 0);
}

// Address range: 0x4ff4c - 0x4ff50
int32_t function_4ff4c(int32_t a1) {
    // 0x4ff4c
    return function_4fe70(a1);
}

// Address range: 0x4ff50 - 0x4ffa0
int32_t function_4ff50(int32_t a1, int32_t a2) {
    int32_t v1 = function_5f880(); // 0x4ff60
    int32_t v2 = 0; // 0x4ff68
    if (v1 == 0) {
        // 0x4ff98
        return 0;
    }
    int32_t v3 = 0; // 0x4ff68
    function_4feac(a1, v3);
    v2++;
    usleep(0x2710);
    v3 += a2;
    while (v2 != v1) {
        // 0x4ff74
        function_4feac(a1, v3);
        v2++;
        usleep(0x2710);
        v3 += a2;
    }
    // 0x4ff98
    return 0;
}

// Address range: 0x4ffa0 - 0x4ffe8
int32_t function_4ffa0(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = 0; // 0x4ffa8
    if (a3 == 0) {
        // 0x4ffe0
        return 0;
    }
    int32_t v2 = 0; // 0x4ffa8
    function_4feac(a1, v2);
    v1++;
    usleep(0x2710);
    v2 += a2;
    while (v1 != a3) {
        // 0x4ffbc
        function_4feac(a1, v2);
        v1++;
        usleep(0x2710);
        v2 += a2;
    }
    // 0x4ffe0
    return 0;
}

// Address range: 0x4ffe8 - 0x5021c
int32_t function_4ffe8(int32_t a1, int32_t a2) {
    uint32_t v1 = (function_5f880() + 255) % 256;
    int32_t v2; // bp-36, 0x4ffe8
    char v3; // 0x4ffe8
    if (a2 == (int32_t)&g25 || (a2 & 0x20000000) == 0) {
        // 0x501c0
        function_51a20(0, a1, 0, 24, &v2);
        __asm_bfi((int32_t)v3, v1 / 32, 0, 4);
        __asm_bfi((int32_t)v3, v1, 0, 5);
        __asm_bfc((int32_t)(unsigned char)v3, 0, 1);
    } else {
        // 0x5000c
        int32_t v4; // bp-32, 0x4ffe8
        function_51a20(0, a1, 0, 104, &v4);
        int32_t v5; // bp-28, 0x4ffe8
        function_51a20(0, a1, 0, 40, &v5);
        __asm_bfc((int32_t)(v3 | 64), 5, 1);
        int32_t v6 = __asm_bfi(__asm_bfi(v4 % 256, 1, 4, 3), 1, 0, 3); // 0x50080
        __asm_bfi((int32_t)v3, 1, 0, 6);
        v4 = 0x1000000 * v6 >> 24;
        int16_t v7; // 0x4ffe8
        __asm_bfi((int32_t)v7, 112, 0, 12);
        function_4fa10(a1, 1, 0, 104, v4);
        usleep(0x2710);
        function_4fa10(a1, 1, 0, 104, v4);
        usleep(0x2710);
        v5 = 15;
        __asm_bfi((int32_t)(v3 % 64), 6, 0, 4);
        __asm_bfc((int32_t)(v3 % 64 | -128), 4, 2);
        function_4fa10(a1, 1, 0, 40, v5);
        usleep(0x2710);
        function_51a20(0, a1, 0, 24, &v2);
        __asm_bfi((int32_t)v3, v1 / 32, 0, 4);
        __asm_bfi((int32_t)v3, v1, 0, 5);
    }
    // 0x50184
    function_4fa10(a1, 1, 0, 24, v2);
    usleep(0xc350);
    function_45cbc(a1, a2);
    return 0;
}

// Address range: 0x5021c - 0x50288
int32_t function_5021c(int32_t a1, uint32_t a2) {
    int32_t v1 = __asm_ubfx(a2, 8, 8); // 0x5022c
    unsigned char v2 = *(char *)(a2 % 256 + (int32_t)"\b`dh" + 4); // 0x50238
    int32_t v3 = __asm_ubfx(a2, 16, 8); // 0x5023c
    unsigned char v4 = *(char *)(v1 + (int32_t)"\b`dh" + 4); // 0x50248
    unsigned char v5 = *(char *)(v3 + (int32_t)"\b`dh" + 4); // 0x50250
    int32_t v6 = __asm_bfi(0, (int32_t)v2, 0, 8); // 0x50254
    unsigned char v7 = *(char *)(a2 / 0x1000000 + (int32_t)"\b`dh" + 4); // 0x50258
    int32_t v8 = __asm_bfi(v6, (int32_t)v4, 8, 8); // 0x50260
    return function_4fa10(a1, 1, 0, 20, __asm_bfi(__asm_bfi(v8, (int32_t)v5, 16, 8), (int32_t)v7, 24, 8));
}

// Address range: 0x50288 - 0x502c0
int32_t function_50288(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = -0x80000000; // 0x50298
    if (a2 == 0) {
        int32_t v2 = a2 == 0 ? 0 : -0x80000000;
        v1 = __asm_bfieq(v2, v2, 31, 1);
    }
    return function_4fa10(a1, 1, 0, 12, __asm_bfi(v1, a3, 0, 16));
}

// Address range: 0x502c0 - 0x5030c
int32_t function_502c0(int32_t result, int32_t * a2, int32_t a3) {
    // 0x502c0
    __asm_vldr_8(0x45480000);
    __asm_vldr_8(0x44fa0000);
    __asm_vldr_8(0x45435000);
    float64_t v1; // 0x502c0
    __asm_vpush(v1);
    float32_t v2; // 0x502c0
    __asm_vmov_f32(v2);
    __asm_vmov_f32(10.0f);
    __asm_vmov_f32(25.0f);
    return result;
}

// Address range: 0x5030e - 0x503d0
int32_t function_5030e(int32_t a1, int32_t a2, int32_t a3, uint32_t a4) {
    // 0x5030e
    int32_t v1; // 0x5030e
    uint32_t v2 = v1;
    int32_t v3 = v1;
    bool v4; // 0x5030e
    if (v4) {
        function_fe48bdee();
    }
    if (v4) {
        function_ffa4919e();
    }
    bool v5 = v4 ? v4 : (v3 & 16) != 0;
    if (!v5) {
        function_a0bf02();
    }
    if (!v4) {
        function_fe48bd3e();
    }
    bool v6; // 0x5030e
    bool v7; // 0x5030e
    bool v8; // 0x5030e
    bool v9; // 0x5030e
    bool v10; // 0x5030e
    bool v11; // 0x5030e
    if (v5) {
        goto lab_0x5032a;
    } else {
        uint32_t v12 = 0x10000000 * v3; // 0x50322
        int32_t v13 = v12 - a2; // 0x50322
        v9 = ((v13 ^ v12) & (v12 ^ a2)) < 0;
        v8 = v13 < 0;
        v11 = v12 == a2;
        if (v12 < a2) {
            uint32_t v14 = function_ffa49eea(); // 0x50326
            if ((v14 & 4 || v1 & 0x200000) == 0) {
                // 0x5033e
                function_fea889c2();
                function_fe48bcd2();
                v7 = false;
                v10 = (v14 / 8 & v1) == 0;
                v6 = false;
                if (((v13 ^ v12) & (v12 ^ a2)) < 0) {
                    goto lab_0x50362;
                } else {
                    goto lab_0x50362_2;
                }
            } else {
                // 0x50342
                v7 = false;
                v10 = (v14 / 8 & v1) == 0;
                v6 = true;
                if (((v13 ^ v12) & (v12 ^ a2)) < 0) {
                    goto lab_0x50362;
                } else {
                    goto lab_0x50362_2;
                }
            }
        } else {
            goto lab_0x5032a;
        }
    }
  lab_0x5032a:
    // 0x5032a
    v7 = v8;
    v10 = v11;
    v6 = true;
    if (v9) {
        goto lab_0x50362;
    } else {
        goto lab_0x50362_2;
    }
  lab_0x50362:;
    bool v15 = v7; // 0x50366
    bool v16 = v6; // 0x50366
    int32_t v17 = 0x5035e; // 0x50366
    if (v10) {
        goto lab_dec_label_pc_0x50366;
    } else {
        goto lab_0x5038e;
    }
  lab_0x50362_2:
    // 0x50362
    function_ffa4bb66();
    function_fe94bf2e();
    function_fea0bcee();
    function_fe20bcf2();
    function_ff24bd76();
    function_18be3a();
    function_ff24bc3e();
    function_48be5a();
    goto lab_dec_label_pc_0x50366;
  lab_dec_label_pc_0x50366:;
    uint32_t v18 = v3 >> 4; // 0x50366
    int32_t v19 = v18 - v2 + (int32_t)((v3 & 8) == 0); // 0x50366
    uint32_t v20 = v19 - (int32_t)((v3 & 8) == 0); // 0x50366
    bool v21; // 0x5030e
    bool v22; // 0x5030e
    bool v23; // 0x5030e
    bool v24; // 0x5030e
    bool v25; // 0x5030e
    bool v26; // 0x5030e
    bool v27; // 0x5030e
    int32_t v28; // 0x5030e
    int32_t v29; // 0x5030e
    int32_t v30; // 0x5030e
    int32_t v31; // 0x5030e
    int32_t v32; // 0x5030e
    int32_t v33; // 0x5030e
    if (v19 == 0) {
        int32_t v34 = v3 >> a4 & v3; // 0x5036a
        if (((v20 ^ v18) & (v18 ^ v2)) < 0) {
            // 0x50372
            v15 = v34 < 0;
            v16 = (v3 & 1 << a4 - 1) != 0;
            v17 = v34;
            if (v34 == 0) {
                // 0x5038e
                *(int32_t *)a2 = 0;
                *(int32_t *)(a2 + 4) = 0x50378;
                int32_t v35 = a2 - v1; // 0x50372
                int16_t v36 = *(int16_t *)function_48bf5a(); // 0x50386
                function_48bf66();
                function_462b9e();
                v30 = v36;
                v22 = (v3 & 0x8000000) != 0;
                v31 = v35;
                v26 = true;
                v33 = v1 - v35;
                goto lab_0x503ae_2;
            } else {
                goto lab_0x5038e;
            }
        } else {
            function_ff232b76();
            v28 = v34;
            v25 = v34 < 0;
            v21 = (v3 & 1 << a4 - 1) != 0;
            if (v34 == 0) {
                *(int32_t *)a2 = 0;
                *(int32_t *)(a2 + 4) = 0x50378;
                function_fe1490c6();
                v23 = (v3 & 0x8000000) != 0;
                v29 = v1 - (v3 / 0x10000000 | 16 * v3);
                v32 = a2 - v1;
                v27 = true;
                v24 = v34 < 0;
                goto lab_0x50382;
            } else {
                goto lab__thread91;
            }
        }
    } else {
        bool v37 = (v3 & 8) == 0 ? v2 != -1 | v18 < v20 : v18 < v2; // 0x50366
        v15 = v19 < 0;
        v16 = !v37;
        v17 = v19;
        if (((v20 ^ v18) & (v18 ^ v2)) < 0) {
            goto lab_0x5038e;
        } else {
            // .thread197
            function_ff232b76();
            v28 = v19;
            v25 = v19 < 0;
            v21 = !v37;
            goto lab__thread91;
        }
    }
  lab_0x5038e:
    // 0x5038e
    function_48bf5a();
    function_48bf66();
    function_ff1cbbb6();
    v30 = v17;
    v22 = v16;
    v31 = a2;
    v26 = false;
    int32_t v38; // 0x5030e
    bool v39; // 0x5030e
    bool v40; // 0x5030e
    bool v41; // 0x5030e
    bool v42; // 0x5030e
    int32_t v43; // 0x5030e
    if (v15) {
        // 0x503ae
        v38 = function_48bf86();
        v39 = v16;
        v42 = false;
        v40 = true;
        v41 = true;
        v43 = v17;
        goto lab_dec_label_pc_unknown_49;
    } else {
        goto lab_0x503ae_2;
    }
  lab_0x503ae_2:
    // 0x503ae
    function_fe8cbf86();
    int32_t v44 = function_48bf86(); // 0x503ae
    int32_t v45 = v44; // 0x503b2
    int32_t v46 = v30; // 0x503b2
    bool v47 = v22; // 0x503b2
    int32_t v48 = v31; // 0x503b2
    bool v49 = false; // 0x503b2
    bool v50 = true; // 0x503b2
    int32_t v51 = v33; // 0x503b2
    v38 = v44;
    v39 = v22;
    v42 = false;
    v40 = false;
    v41 = true;
    int32_t v52 = v33; // 0x503b2
    v43 = v30;
    if (v26) {
        goto lab_dec_label_pc_unknown_50;
    } else {
        goto lab_dec_label_pc_unknown_49;
    }
  lab_dec_label_pc_unknown_49:;
    bool v53; // 0x5030e
    int32_t v54; // 0x5030e
    int32_t v55; // 0x5030e
    int32_t v56; // 0x5030e
    if (v39 == !v42) {
        int32_t v57 = 0x100000 * v38 & v1; // 0x503b6
        int32_t v58 = v57 == 0 | (v38 & 0x1000) == 0 ? v52 * v57 : v43;
        v54 = v58;
        v55 = v58;
        v53 = true;
        if (v57 < 0) {
            goto lab_0x503c2;
        } else {
            goto lab_dec_label_pc_unknown_53;
        }
    } else {
        int32_t v59 = v42 | !v39 ? v56 * v52 : v43;
        v54 = v59;
        v55 = v59;
        v53 = true;
        if (v40) {
            goto lab_0x503c2;
        } else {
            goto lab_dec_label_pc_unknown_53;
        }
    }
  lab_dec_label_pc_unknown_50:
    *(int32_t *)v1 = v46;
    *(int32_t *)(v1 + 4) = 0x503b8;
    v38 = v45;
    v39 = v47;
    v42 = true;
    v40 = v49;
    v41 = v50;
    v52 = v51;
    v43 = v46;
    v56 = v1 - v48;
    goto lab_dec_label_pc_unknown_49;
  lab__thread91:
    // .thread91
    function_fe1490c6();
    v23 = v21;
    v29 = v28;
    v32 = a2;
    v27 = false;
    v24 = v25;
    goto lab_0x50382;
  lab_0x50382:
    // 0x50382
    function_ff8d2b86();
    int32_t v60 = function_48bf5a(); // 0x50382
    int32_t v61 = v29; // 0x50386
    bool v62 = false; // 0x50386
    if (v27) {
        v61 = (int32_t)*(int16_t *)v60;
        v62 = true;
    }
    // 0x5038e
    function_ff102b92();
    function_48bf66();
    bool v63; // 0x5030e
    bool v64; // 0x5030e
    int32_t v65; // 0x5030e
    if (v62) {
        int32_t v66 = v1 - v32;
        function_462b9e();
        v65 = v66;
        v63 = true;
        v64 = true;
        if (!v24) {
            function_fe8cbf86();
            v65 = v66;
            v63 = false;
            v64 = true;
        }
    } else {
        // 0x5039e
        function_ff1cbbb6();
        v63 = true;
        v64 = false;
        if (!v24) {
            // .thread205
            function_fe8cbf86();
            v63 = false;
            v64 = false;
        }
    }
    // 0x503a6
    function_ff1cbdc6();
    function_ffa4bd8e();
    function_ff9cbf72();
    int32_t v67 = function_48bf86(); // 0x503ae
    v45 = v67;
    v46 = v61;
    v47 = v23;
    v48 = v32;
    v49 = v63;
    v50 = false;
    v51 = v65;
    v38 = v67;
    v39 = v23;
    v42 = false;
    v40 = v63;
    v41 = false;
    v52 = v65;
    v43 = v61;
    if (v64) {
        goto lab_dec_label_pc_unknown_50;
    } else {
        goto lab_dec_label_pc_unknown_49;
    }
  lab_0x503c2:
    // 0x503c2
    if (v53 != v41) {
        *(int32_t *)a3 = v55;
        *(int32_t *)(a3 + 4) = 0x503c8;
    }
    if (v53) {
        function_488a4e();
    }
    // 0x503ca
    __asm_cdp(0, 1, 5, 7, 1, 0);
    return function_50b12();
  lab_dec_label_pc_unknown_53:
    function_1a48a46();
    v55 = v54;
    v53 = false;
    goto lab_0x503c2;
}

// Address range: 0x503d0 - 0x504dc
int32_t function_503d0(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x503d0
    int32_t v1; // 0x503d0
    if (v1 == 0) {
        // 0x504c8
        puts("find div fail, use default value");
        float64_t v2; // 0x503d0
        __asm_vpop(v2);
        return -1;
    }
    float32_t v3 = __asm_vmov_7(v1); // 0x50408
    int32_t v4 = __asm_smulbb(v1, v1); // 0x5040c
    float32_t v5 = __asm_vdiv_f32(__asm_vmov_f32(25.0f), __asm_vcvt_f32_s32(v3)); // 0x5042c
    float32_t v6 = __asm_vmov_7(v1); // 0x50434
    __asm_vdiv_f32(__asm_vmul_f32(v5, __asm_vcvt_f32_s32(v6)), __asm_vcvt_f32_s32(__asm_vmov_7(v4 * v1)));
    return (int32_t)"final refdiv: %d, fbdiv: %d, postdiv1: %d, postdiv2: %d, usr divider: %d, min diff value: %f\n";
}

// Address range: 0x504e8 - 0x50560
int32_t function_504e8(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x504e8
    __asm_vcvt_f32_u32(__asm_vldr_8(a5));
    int32_t v1; // bp-32, 0x504e8
    int32_t v2; // bp-36, 0x504e8
    int32_t v3 = function_502c0((int32_t)&v1, &v2, 0); // 0x50514
    int32_t result = -1; // 0x5051c
    if (v3 == 0) {
        // 0x50520
        char v4; // 0x504e8
        int16_t v5; // 0x504e8
        result = function_4fa9c(a1, a2, a3, a4, v1 % 256, (int32_t)v4, (int32_t)(unsigned char)v4, (int32_t)v5);
    }
    // 0x50550
    return result;
}

// Address range: 0x50560 - 0x505a4
int32_t function_50560(int32_t a1, int32_t a2, uint32_t a3, uint32_t a4) {
    // 0x50560
    char v1; // 0x50560
    return function_4fa9c(a1, 1, 0, a2, a3 % 256, (int32_t)(unsigned char)v1, (int32_t)v1, a4 % 0x10000);
}

// Address range: 0x505a4 - 0x505f4
int32_t function_505a4(int32_t a1, int32_t a2, int32_t a3, uint32_t a4, uint32_t a5) {
    int32_t v1 = __asm_ubfx(a4, 8, 8); // 0x505b8
    return function_4fa9c(a1, 0, a2, a3, a4 % 256, v1, __asm_ubfx(a4, 16, 8), a5 % 0x10000);
}

// Address range: 0x505f4 - 0x50678
int32_t function_505f4(int32_t a1, int32_t a2, uint32_t a3, int32_t a4, unsigned char a5) {
    int32_t result = -1; // 0x50604
    if (a3 >= 3 != a3 != 3) {
        int32_t v1 = (int32_t)*(char *)(a3 + (int32_t)"\b`dh"); // 0x50618
        int32_t v2; // bp-28, 0x505f4
        function_51a20(1, a1, a2, v1, &v2);
        int32_t v3 = 0x1000000 * __asm_bfi(__asm_bfi(v2 % 256, a4, 4, 3), (int32_t)a5, 0, 3) >> 24; // 0x50658
        v2 = v3;
        result = function_4fa10(a1, 0, a2, v1, v3);
    }
    // 0x50668
    return result;
}

// Address range: 0x50678 - 0x506f8
int32_t function_50678(int32_t a1, uint32_t a2, int32_t a3, int32_t a4) {
    if (a2 >= 3 == (a2 != 3)) {
        // 0x506f0
        return -1;
    }
    int32_t v1 = (int32_t)*(char *)(a2 + (int32_t)"\b`dh"); // 0x50698
    int32_t v2; // bp-28, 0x50678
    function_51a20(0, a1, 0, v1, &v2);
    int32_t v3 = 0x1000000 * __asm_bfi(__asm_bfi(v2 % 256, a3, 4, 3), a4, 0, 3) >> 24; // 0x506d8
    v2 = v3;
    return function_4fa10(a1, 1, 0, v1, v3);
}

// Address range: 0x506f8 - 0x50794
int32_t function_506f8(int32_t a1, int32_t a2, uint32_t a3, uint32_t a4) {
    int32_t v1 = __asm_ubfx(a4, 8, 8); // 0x50704
    int32_t result = -1; // 0x5070c
    if (a3 >= 3 != a3 != 3) {
        int32_t v2 = (int32_t)*(char *)(a3 + (int32_t)"\b`dh" + 260); // 0x50724
        int32_t v3; // bp-28, 0x506f8
        function_51a20(1, a1, a2, v2, &v3);
        int32_t v4 = __asm_bfi(v3 % 256, a4 % 256, 0, 4); // 0x50760
        char v5; // 0x506f8
        int32_t v6 = __asm_bfi((int32_t)(unsigned char)v5, v1, 0, 4); // 0x50764
        int32_t v7 = __asm_bfc(v4, 6, 2); // 0x50768
        __asm_bfc(v6, 6, 2);
        int32_t v8 = 0x1000000 * v7 >> 24; // 0x50770
        v3 = v8;
        result = function_4fa10(a1, 0, a2, v2, v8);
    }
    // 0x50784
    return result;
}

// Address range: 0x50794 - 0x5082c
int32_t function_50794(int32_t a1, uint32_t a2, uint32_t a3) {
    int32_t v1 = __asm_ubfx(a3, 8, 8); // 0x507a0
    int32_t result = -1; // 0x507a8
    if (a2 >= 3 != a2 != 3) {
        int32_t v2 = (int32_t)*(char *)(a2 + (int32_t)"\b`dh" + 260); // 0x507c0
        int32_t v3; // bp-28, 0x50794
        function_51a20(0, a1, 0, v2, &v3);
        int32_t v4 = __asm_bfi(v3 % 256, a3 % 256, 0, 4); // 0x507f8
        char v5; // 0x50794
        int32_t v6 = __asm_bfi((int32_t)(unsigned char)v5, v1, 0, 4); // 0x507fc
        int32_t v7 = __asm_bfc(v4, 6, 2); // 0x50800
        __asm_bfc(v6, 6, 2);
        int32_t v8 = 0x1000000 * v7 >> 24; // 0x50808
        v3 = v8;
        result = function_4fa10(a1, 1, 0, v2, v8);
    }
    // 0x5081c
    return result;
}

// Address range: 0x5082c - 0x50850
int32_t function_5082c(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x5082c
    return function_504e8(a1, 0, a2, a3, a4);
}

// Address range: 0x50850 - 0x50874
int32_t function_50850(int32_t a1, int32_t a2, int32_t a3) {
    // 0x50850
    return function_504e8(a1, 1, 0, a2, a3);
}

// Address range: 0x50874 - 0x508a0
int32_t function_50874(int32_t a1, int32_t a2, int32_t a3) {
    // 0x50874
    return function_4fa10(a1, 0, a2, 84, __asm_bfi(0, a3, 0, 3));
}

// Address range: 0x508a0 - 0x508cc
int32_t function_508a0(int32_t a1, int32_t a2) {
    // 0x508a0
    return function_4fa10(a1, 1, 0, 84, __asm_bfi(0, a2, 0, 3));
}

// Address range: 0x508cc - 0x508dc
int32_t function_508cc(void) {
    // 0x508cc
    int32_t v1; // 0x508cc
    return function_4fef0(v1, 1, 0, 72);
}

// Address range: 0x508dc - 0x508e4
int32_t function_508dc(void) {
    // 0x508dc
    return 0;
}

// Address range: 0x508e4 - 0x509b4
int32_t function_508e4(int32_t a1, int32_t a2, char a3, int32_t a4) {
    // 0x508e4
    int32_t v1; // bp-28, 0x508e4
    function_51a20(0, a1, 0, 164, &v1);
    char v2; // 0x508e4
    int32_t v3 = (unsigned char)v2; // 0x50918
    int32_t v4 = a2 == 0 ? v3 : v3 | 128;
    char v5 = v4; // 0x50924
    if (a2 == 0) {
        v5 = __asm_bfieq(v4, 0, 7, 1);
    }
    char v6; // 0x508e4
    switch (a3) {
        case 4: {
            // 0x5099c
            v6 = __asm_bfc((int32_t)v5, 4, 2);
            // break -> 0x50954
            break;
        }
        case 8: {
            // 0x50988
            v6 = __asm_bfi((int32_t)v5, 1, 4, 2);
            // break -> 0x50954
            break;
        }
        case 12: {
            // 0x50944
            v6 = __asm_bfi((int32_t)v5, 2, 4, 2);
            // break -> 0x50954
            break;
        }
        default: {
            // 0x50980
            return -1;
        }
    }
    // 0x50954
    v1 = 0x10000 * a4 >> 16;
    __asm_bfc((int32_t)v6, 6, 1);
    // 0x50980
    return function_4fa10(a1, 1, 0, 164, v1);
}

// Address range: 0x509b4 - 0x50a18
int32_t function_509b4(int32_t a1, int32_t a2) {
    // 0x509b4
    int32_t v1; // bp-20, 0x509b4
    function_51a20(0, a1, 0, 24, &v1);
    uint32_t v2 = (uint32_t)v1 % 256; // 0x509e0
    int32_t v3 = v2 | 4; // 0x509f8
    if (a2 == 0) {
        v3 = __asm_bfieq(v2, 0, 2, 1);
    }
    int32_t v4 = 0x1000000 * v3 >> 24; // 0x509fc
    v1 = v4;
    return function_4fa10(a1, 1, 0, 24, v4);
}

// Address range: 0x50a18 - 0x50a80
int32_t function_50a18(int32_t a1, int32_t a2, int32_t a3) {
    // 0x50a18
    int32_t v1; // bp-20, 0x50a18
    function_51a20(1, a1, a2, 24, &v1);
    uint32_t v2 = (uint32_t)v1 % 256; // 0x50a48
    int32_t v3 = v2 | 4; // 0x50a60
    if (a3 == 0) {
        v3 = __asm_bfieq(v2, 0, 2, 1);
    }
    int32_t v4 = 0x1000000 * v3 >> 24; // 0x50a64
    v1 = v4;
    return function_4fa10(a1, 0, a2, 24, v4);
}

// Address range: 0x50a80 - 0x50ae8
int32_t function_50a80(int32_t a1, int32_t a2, int32_t a3) {
    // 0x50a80
    int32_t v1; // bp-20, 0x50a80
    function_51a20(1, a1, a2, 24, &v1);
    if (a3 == 0) {
        char v2; // 0x50a80
        __asm_bfieq((int32_t)(unsigned char)v2, 0, 5, 1);
    }
    return function_4fa10(a1, 0, a2, 24, v1);
}

// Address range: 0x50aec - 0x50b12
int32_t function_50aec(int32_t result, int32_t a2, int32_t a3) {
    // 0x50aec
    bool v1; // 0x50aec
    if (v1) {
        // 0x50b10
        return result + 88;
    }
    // 0x50aee
    return result;
}

// Address range: 0x50b12 - 0x50b14
int32_t function_50b12(void) {
    // 0x50b12
    int32_t result; // 0x50b12
    return result;
}

// Address range: 0x50b14 - 0x50b48
int32_t function_50b14(int32_t a1, unsigned char a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x50b14
    int32_t v1; // 0x50b14
    function_51a20(v1, v1, v1, v1, &g488);
    __asm_bfi((int32_t)a2, v1, 4, 4);
    return function_4fa10(v1, 0, v1, 88, a1);
}

// Address range: 0x50b48 - 0x50ba4
int32_t function_50b48(int32_t a1, int32_t a2) {
    // 0x50b48
    int32_t v1; // bp-20, 0x50b48
    function_51a20(0, a1, 0, 88, &v1);
    char v2; // 0x50b48
    __asm_bfi((int32_t)(unsigned char)v2, a2, 4, 4);
    return function_4fa10(a1, 1, 0, 88, v1);
}

// Address range: 0x50ba4 - 0x50bac
int32_t function_50ba4(void) {
    // 0x50ba4
    return -1;
}

// Address range: 0x50bac - 0x50bb4
int32_t function_50bac(void) {
    // 0x50bac
    return -1;
}

// Address range: 0x50bb4 - 0x50bbc
int32_t function_50bb4(void) {
    // 0x50bb4
    return -1;
}

// Address range: 0x50bbc - 0x50bc4
int32_t function_50bbc(void) {
    // 0x50bbc
    return -1;
}

// Address range: 0x50bc4 - 0x50bcc
int32_t function_50bc4(void) {
    // 0x50bc4
    return -1;
}

// Address range: 0x50bcc - 0x50bd4
int32_t function_50bcc(void) {
    // 0x50bcc
    return -1;
}

// Address range: 0x50bd4 - 0x50c38
int32_t function_50bd4(int32_t a1, int32_t a2) {
    // 0x50bd4
    int32_t v1; // bp-20, 0x50bd4
    function_51a20(0, a1, 0, 24, &v1);
    if (a2 == 0) {
        char v2; // 0x50bd4
        __asm_bfieq((int32_t)(unsigned char)v2, 0, 7, 1);
    }
    return function_4fa10(a1, 1, 0, 24, v1);
}

// Address range: 0x50c38 - 0x50cc4
int32_t function_50c38(int32_t a1, int32_t a2) {
    // 0x50c38
    int32_t v1; // bp-20, 0x50c38
    function_51a20(0, a1, 0, 24, &v1);
    char v2; // 0x50c38
    if (a2 == 0) {
        // 0x50c6c
        __asm_bfi((int32_t)v2, 0, 6, 1);
    } else {
        // 0x50ca8
        __asm_bfc((int32_t)(unsigned char)v2, 4, 4);
    }
    // 0x50c84
    return function_4fa10(a1, 1, 0, 24, v1);
}

// Address range: 0x50cc4 - 0x50d54
int32_t function_50cc4(int32_t a1, int32_t a2, int32_t a3) {
    // 0x50cc4
    int32_t v1; // bp-20, 0x50cc4
    function_51a20(1, a1, a2, 24, &v1);
    char v2; // 0x50cc4
    if (a3 == 0) {
        // 0x50cfc
        __asm_bfi((int32_t)v2, 0, 6, 1);
    } else {
        // 0x50d38
        __asm_bfc((int32_t)(unsigned char)v2, 4, 4);
    }
    // 0x50d14
    return function_4fa10(a1, 0, a2, 24, v1);
}

// Address range: 0x50d54 - 0x50d78
int32_t function_50d54(int32_t a1, int32_t a2) {
    // 0x50d54
    return function_4fa10(a1, 1, 0, 16, a2);
}

// Address range: 0x50d78 - 0x50d9c
int32_t function_50d78(int32_t a1, int32_t a2, int32_t a3) {
    // 0x50d78
    return function_4fa10(a1, 0, a2, 16, a3);
}

// Address range: 0x50d9c - 0x50da8
int32_t function_50d9c(void) {
    // 0x50d9c
    int32_t v1; // 0x50d9c
    return function_4faec(v1, 1, 0);
}

// Address range: 0x50da8 - 0x50db4
int32_t function_50da8(int32_t a1, int32_t a2) {
    // 0x50da8
    return function_4faec(a1, 0, a2);
}

// Address range: 0x50db4 - 0x50dc4
int32_t function_50db4(int32_t a1, int32_t a2) {
    // 0x50db4
    return function_4fb64(a1, 1, 0, a2);
}

// Address range: 0x50dc4 - 0x50dd4
int32_t function_50dc4(int32_t a1, int32_t a2, int32_t a3) {
    // 0x50dc4
    return function_4fb64(a1, 0, a2, a3);
}

// Address range: 0x50dd4 - 0x50df8
int32_t function_50dd4(int32_t a1) {
    // 0x50dd4
    return function_4fbdc(a1, 1, 0, 1, 0);
}

// Address range: 0x50df8 - 0x50e20
int32_t function_50df8(int32_t a1, int32_t a2) {
    // 0x50df8
    return function_4fbdc(a1, 0, a2, 1, 0);
}

// Address range: 0x50e20 - 0x50e44
int32_t function_50e20(int32_t a1, int32_t a2) {
    // 0x50e20
    return function_4fbdc(a1, 1, 0, 0, a2);
}

// Address range: 0x50e44 - 0x50e68
int32_t function_50e44(int32_t a1, int32_t a2, int32_t a3) {
    // 0x50e44
    return function_4fbdc(a1, 0, a2, 0, a3);
}

// Address range: 0x50e68 - 0x50e70
int32_t function_50e68(void) {
    // 0x50e68
    return -1;
}

// Address range: 0x50e70 - 0x50e78
int32_t function_50e70(void) {
    // 0x50e70
    return -1;
}

// Address range: 0x50e78 - 0x50ed0
int32_t function_50e78(int32_t a1) {
    // 0x50e78
    int32_t v1; // bp-12, 0x50e78
    function_51a20(0, a1, 0, 144, &v1);
    return function_4fa10(a1, 1, 0, 144, v1);
}

// Address range: 0x50ed0 - 0x50f28
int32_t function_50ed0(int32_t a1) {
    // 0x50ed0
    int32_t v1; // bp-12, 0x50ed0
    function_51a20(0, a1, 0, 52, &v1);
    int32_t v2 = (char)v1 | 1; // 0x50f10
    v1 = v2;
    return function_4fa10(a1, 1, 0, 52, v2);
}

// Address range: 0x50f28 - 0x50f80
int32_t function_50f28(int32_t a1) {
    // 0x50f28
    int32_t v1; // bp-12, 0x50f28
    function_51a20(0, a1, 0, 52, &v1);
    int32_t v2 = 0x1000000 * __asm_bfc((uint32_t)v1 % 256, 0, 1) >> 24; // 0x50f68
    v1 = v2;
    return function_4fa10(a1, 1, 0, 52, v2);
}

// Address range: 0x50f80 - 0x50fa4
int32_t function_50f80(int32_t a1, int32_t a2) {
    // 0x50f80
    return function_4fa10(a1, 1, 0, 156, a2);
}

// Address range: 0x50fa4 - 0x50fdc
int32_t function_50fa4(int32_t a1, int32_t a2) {
    // 0x50fa4
    return function_4fa10(a1, 1, 0, 144, __asm_bfi(0, a2 - 1, 4, 3) | 0x38001801);
}

// Address range: 0x50fdc - 0x51038
int32_t function_50fdc(int32_t result) {
    // 0x50fdc
    int32_t v1; // bp-12, 0x50fdc
    function_51a20(0, result, 0, 144, &v1);
    v1 = (char)v1 | -118;
    char v2; // 0x50fdc
    __asm_bfc((int32_t)(unsigned char)v2, 3, 1);
    return result;
}

// Address range: 0x5103a - 0x5113a
int32_t function_5103a(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = unknown_1d0a67a(); // 0x5103e
    bool v2; // 0x5103a
    int32_t v3 = v2 | false ? v1 - (int32_t)&g155 : v1;
    bool v4; // 0x5103a
    bool v5; // 0x5103a
    int32_t v6; // 0x5103a
    if (v2 == !v2) {
        int32_t v7 = v3 & 32 * v6; // 0x51046
        v4 = v7 < 0;
        v5 = v7 == 0;
    }
    uint32_t result = v3 - (v4 ? v6 : 0);
    bool v8; // 0x5103a
    bool v9; // 0x5103a
    bool v10; // 0x5103a
    bool v11; // 0x5103a
    bool v12; // 0x5103a
    bool v13; // 0x5103a
    if (v5 || v4 != v2) {
        if ((result & v6 / 0x40000) == 0) {
            v8 = (result & 4) != 0;
            v9 = false;
            if ((v6 & 0x200000) != 0) {
                __asm_rsbeq(v6, 160, 6);
                return result;
            }
            goto lab_dec_label_pc_unknown_55;
        } else {
            v8 = false;
            v9 = (v6 & 0x200000) != 0;
            v10 = (v6 & 0x8000000) != 0;
            v11 = true;
            v12 = (v6 & 0x200000) != 0;
            v13 = false;
            if ((result & 4) != 0) {
                goto lab_0x5107a;
            } else {
                goto lab_dec_label_pc_unknown_55;
            }
        }
    } else {
        // .thread
        v8 = false;
        v9 = (v6 & 0x200000) != 0;
        v10 = (v6 & 0x8000000) != 0;
        v11 = true;
        v12 = (v6 & 0x200000) != 0;
        if ((result & 4) == 0) {
            goto lab_dec_label_pc_unknown_55;
        } else {
            goto lab_0x5107a;
        }
    }
  lab_dec_label_pc_unknown_55:;
    int32_t v14 = result / 8 + result; // 0x5106a
    v10 = (v6 & 0x8000000) != 0;
    v11 = v8;
    v12 = v9;
    bool v15 = (v14 & -result) < 0; // 0x5106e
    v13 = v14 < 0;
    if (v14 == 0) {
        __asm_rsbeq(v6, 160, 6);
        return result;
    }
    goto lab_0x5107a;
  lab_0x5107a:;
    bool v16 = v13 == v15 ? v11 : (result & 1024) != 0;
    int32_t v17 = (v16 ? 0 : v6) + result;
    if ((v17 & 64) != 0) {
        return v17 - v6;
    }
    int32_t v18 = a4 >> 15; // 0x5109e
    int32_t v19 = v18 + 0x510a4; // 0x5109e
    bool v20 = v19 == 0 | v19 < 0 != (v19 & -v18) < 0; // 0x510b2
    int32_t v21 = unknown_154a6f6(); // 0x510ba
    int32_t v22 = v20 ? v21 - (int32_t)&g156 : v21;
    bool v23 = v19 < 0; // 0x510c2
    bool v24 = v19 == 0; // 0x510c2
    bool v25 = (v6 & 1024) != 0 == !v20; // 0x510c2
    if ((v6 & 1024) != 0 == !v20 == (v19 != 0)) {
        int32_t v26 = v22 & 32 * v6; // 0x510c2
        v23 = v26 < 0;
        v24 = v26 == 0;
        v25 = v10;
    }
    uint32_t v27 = unknown_fe1c9f5c((v25 ? 0 : v6) + v22); // 0x510d2
    if (v24 || v23 != (v19 & -v18) < 0) {
        if ((v6 / 0x40000 & v6) == 0) {
            if ((v27 & 4) != 0) {
                __asm_subeq(v6, 160, 2);
                // .thread51
                return unknown_1b89fc0(unknown_f0a75a());
            }
        } else {
            if (v12) {
                // .thread51
                return unknown_1b89fc0(unknown_f0a75a());
            }
        }
    } else {
        if (v12) {
            // .thread51
            return unknown_1b89fc0(unknown_f0a75a());
        }
    }
    if (v27 / 8 != -v27) {
        // .thread51
        return unknown_1b89fc0(unknown_f0a75a());
    }
    __asm_subeq(v6, 160, 2);
    // .thread51
    return unknown_1b89fc0(unknown_f0a75a());
}

// Address range: 0x5113c - 0x51140
int32_t function_5113c(int32_t a1) {
    // 0x5113c
    return function_513a0(a1 + 160);
}

// Address range: 0x51142 - 0x5114a
int32_t function_51142(int32_t a1, int32_t a2) {
    // 0x51142
    return unknown_1a89fd0();
}

// Address range: 0x5114a - 0x5114b
int32_t function_5114a(void) {
    // 0x5114a
    int32_t result; // 0x5114a
    return result;
}

// Address range: 0x5114c - 0x51150
int32_t function_5114c(int32_t a1) {
    // 0x5114c
    return function_51892();
}

// Address range: 0x51152 - 0x5115e
int32_t function_51152(int32_t a1, int32_t a2) {
    int32_t v1 = unknown_1989fe0(); // 0x51156
    int32_t result = v1; // 0x5115a
    bool v2; // 0x51152
    if (v2) {
        *(int32_t *)(v1 + 4) = 0x51160;
        result = v1 - 0x51160;
    }
    return result;
}

// Address range: 0x5115e - 0x51160
int32_t function_5115e(void) {
    // 0x5115e
    return function_51922();
}

// Address range: 0x51160 - 0x51164
int32_t function_51160(void) {
    // 0x51160
    int32_t result; // 0x51160
    return result;
}

// Address range: 0x51164 - 0x511d0
int32_t function_51164(int32_t a1, int32_t a2) {
    // 0x51164
    int32_t v1; // bp-20, 0x51164
    function_51a20(1, a1, a2, 24, &v1);
    int32_t v2 = 0x1000000 * __asm_bfi((uint32_t)v1 % 256, 3, 4, 3) >> 24; // 0x511b8
    v1 = v2;
    return function_4fa10(a1, 0, a2, 24, v2);
}

// Address range: 0x511d0 - 0x5121c
int32_t function_511d0(char a1, char a2, uint32_t a3, int32_t a4) {
    int32_t v1 = __asm_bfi(__asm_bfc(__asm_bfi(0, a4, 8, 8), 16, 1), a3 / 2, 17, 7); // 0x511e4
    return function_4fa10((int32_t)a1, 0, (int32_t)a2, 28, __asm_bfc(__asm_bfc(__asm_bfc(__asm_bfc(v1 | 0x1000000, 25, 1), 26, 1), 30, 1), 31, 1));
}

// Address range: 0x5121c - 0x51260
int32_t function_5121c(char a1, char a2, uint32_t a3, int32_t a4, uint32_t a5) {
    int32_t v1 = __asm_bfi(256 * a4 | a5 % 256 | 0x10000, a3 / 2, 17, 7); // 0x5123c
    return function_4fa10((int32_t)a1, 0, (int32_t)a2, 28, 0x1000000 * __asm_bfc(__asm_bfc(__asm_bfc(__asm_bfc(v1 | 0x1000000, 25, 1), 26, 1), 30, 1), 31, 1) >> 24);
}

// Address range: 0x51260 - 0x5126c
int32_t function_51260(char a1) {
    // 0x51260
    int32_t v1; // 0x51260
    return function_5121c((char)v1, (char)v1, v1, v1, (int32_t)a1);
}

// Address range: 0x5126c - 0x5129c
int32_t function_5126c(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x5126c
    return function_4fa10(a1, 0, a2, 68, __asm_bfi(__asm_bfi(0, a4, 8, 8), a3, 24, 8));
}

// Address range: 0x5129c - 0x512cc
int32_t function_5129c(int32_t a1, int32_t a2, int32_t a3, int32_t a4, uint32_t a5) {
    int32_t v1 = __asm_bfi((int32_t)&g468, a5 % 256, 0, 1); // 0x512a8
    return function_4fa10(a1, 0, a2, 44, 0x1000000 * __asm_bfi(__asm_bfi(v1, a4, 1, 1), a3, 16, 16) >> 24);
}

// Address range: 0x512cc - 0x51328
int32_t function_512cc(int32_t a1, int32_t a2) {
    // 0x512cc
    int32_t v1; // bp-20, 0x512cc
    function_51a20(0, a1, 0, 24, &v1);
    int32_t v2 = 0x1000000 * __asm_bfi((uint32_t)v1 % 256, a2, 3, 1) >> 24; // 0x51310
    v1 = v2;
    return function_4fa10(a1, 1, 0, 24, v2);
}

// Address range: 0x51328 - 0x51388
int32_t function_51328(int32_t a1, int32_t a2, int32_t a3) {
    // 0x51328
    int32_t v1; // bp-20, 0x51328
    function_51a20(1, a1, a2, 24, &v1);
    int32_t v2 = 0x1000000 * __asm_bfi((uint32_t)v1 % 256, a3, 3, 1) >> 24; // 0x51370
    v1 = v2;
    return function_4fa10(a1, 0, a2, 24, v2);
}

// Address range: 0x5138c - 0x51390
int32_t function_5138c(void) {
    // 0x5138c
    int32_t v1; // 0x5138c
    bool v2; // 0x5138c
    if (v2) {
        int32_t v3; // 0x5138c
        v1 = function_513b0(v3, v3, v3, v3);
    }
    // 0x5138e
    return function_5182c(v1);
}

// Address range: 0x51390 - 0x51394
int32_t function_51390(int32_t a1) {
    // 0x51390
    return function_518b0(a1 + 12);
}

// Address range: 0x51394 - 0x51398
int32_t function_51394(int32_t a1) {
    // 0x51394
    *(int32_t *)(2 * a1) = a1;
    return function_516da();
}

// Address range: 0x51398 - 0x5139c
int32_t function_51398(int32_t a1, int32_t a2) {
    // 0x51398
    *(int32_t *)a1 = a2;
    return function_516de();
}

// Address range: 0x5139c - 0x513a0
int32_t function_5139c(void) {
    // 0x5139c
    return function_516e2();
}

// Address range: 0x513a0 - 0x513a4
int32_t function_513a0(int32_t result) {
    // 0x513a0
    return result;
}

// Address range: 0x513a4 - 0x513a8
int32_t function_513a4(int32_t a1) {
    // 0x513a4
    return function_516ea();
}

// Address range: 0x513a8 - 0x513ac
int32_t function_513a8(int32_t a1) {
    // 0x513a8
    return a1 + 176;
}

// Address range: 0x513ac - 0x513b0
int32_t function_513ac(int32_t result) {
    // 0x513ac
    return result;
}

// Address range: 0x513b0 - 0x513b8
int32_t function_513b0(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x513b0
    int32_t v1; // 0x513b0
    return 0x10000 * v1 + a1;
}

// Address range: 0x513b8 - 0x513bc
int32_t function_513b8(void) {
    // 0x513b8
    return function_516fe();
}

// Address range: 0x513bc - 0x513be
int32_t function_513bc(void) {
    // 0x513bc
    int32_t v1; // 0x513bc
    return function_513dc(v1, v1, v1, v1);
}

// Address range: 0x513be - 0x513ce
int32_t function_513be(int32_t result) {
    // 0x513be
    return result;
}

// Address range: 0x513ce - 0x513d0
int32_t function_513ce(void) {
    // 0x513ce
    int32_t result; // 0x513ce
    return result;
}

// Address range: 0x513d0 - 0x513d4
int32_t function_513d0(int32_t a1) {
    // 0x513d0
    return 0;
}

// Address range: 0x513d4 - 0x513d6
int32_t function_513d4(void) {
    // 0x513d4
    int32_t result; // 0x513d4
    return result;
}

// Address range: 0x513d6 - 0x513d8
int32_t function_513d6(void) {
    // 0x513d6
    int32_t result; // 0x513d6
    return result;
}

// Address range: 0x513d8 - 0x513dc
int32_t function_513d8(int32_t result, int32_t a2) {
    // 0x513d8
    return result;
}

// Address range: 0x513dc - 0x513e0
int32_t function_513dc(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x513dc
    *(int32_t *)a3 = result;
    *(int32_t *)(a3 + 4) = a2;
    *(int32_t *)(a3 + 8) = a3;
    *(int32_t *)(a3 + 12) = a4;
    return result;
}

// Address range: 0x513e0 - 0x513fc
int32_t function_513e0(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x513e0
    int32_t v1; // 0x513e0
    return function_4fa10(v1, v1, v1, v1, a1);
}

// Address range: 0x513fc - 0x5146c
int32_t function_513fc(int32_t a1) {
    // 0x513fc
    int32_t v1; // bp-12, 0x513fc
    function_51a20(0, a1, 0, 176, &v1);
    int32_t v2 = __asm_bfc(v1 % 256, 6, 1); // 0x5143c
    char v3; // 0x513fc
    __asm_bfc((int32_t)v3, 2, 1);
    v1 = 0x1000000 * v2 >> 24;
    __asm_bfc((int32_t)(unsigned char)v3, 5, 1);
    return function_4fa10(a1, 1, 0, 176, v1);
}

// Address range: 0x5146c - 0x51478
int32_t function_5146c(int32_t a1, int32_t a2) {
    // 0x5146c
    return function_4fc14(a1, 0, a2);
}

// Address range: 0x51478 - 0x51484
int32_t function_51478(int32_t a1) {
    // 0x51478
    return function_4fc14(a1, 1, 0);
}

// Address range: 0x51484 - 0x51494
int32_t function_51484(int32_t a1, int32_t a2, int32_t a3) {
    // 0x51484
    return function_4fcbc(a1, 0, a2, a3);
}

// Address range: 0x51494 - 0x514a4
int32_t function_51494(int32_t a1, int32_t a2) {
    // 0x51494
    return function_4fcbc(a1, 1, 0, a2);
}

// Address range: 0x514a4 - 0x51508
int32_t function_514a4(int32_t a1) {
    // 0x514a4
    int32_t v1; // bp-12, 0x514a4
    function_51a20(0, a1, 0, 176, &v1);
    int32_t v2 = (char)v1 | 16; // 0x514e4
    v1 = v2;
    function_4fa10(a1, 1, 0, 176, v2);
    usleep(0x7530);
    return 0;
}

// Address range: 0x51508 - 0x51570
int32_t function_51508(int32_t a1, int32_t a2) {
    // 0x51508
    int32_t v1; // bp-20, 0x51508
    function_51a20(1, a1, a2, 176, &v1);
    int32_t v2 = (char)v1 | 16; // 0x5154c
    v1 = v2;
    function_4fa10(a1, 0, a2, 176, v2);
    usleep(0x7530);
    return 0;
}

// Address range: 0x51570 - 0x51580
int32_t function_51570(void) {
    // 0x51570
    int32_t v1; // 0x51570
    return function_4fef0(v1, 1, 0, 176);
}

// Address range: 0x51580 - 0x51590
int32_t function_51580(int32_t a1, int32_t a2) {
    // 0x51580
    return function_4fef0(a1, 0, a2, 176);
}

// Address range: 0x51590 - 0x515a0
int32_t function_51590(void) {
    // 0x51590
    int32_t v1; // 0x51590
    return function_4fef0(v1, 1, 0, 180);
}

// Address range: 0x515a0 - 0x515b0
int32_t function_515a0(int32_t a1, int32_t a2) {
    // 0x515a0
    return function_4fef0(a1, 0, a2, 180);
}

// Address range: 0x515b0 - 0x515c0
int32_t function_515b0(void) {
    // 0x515b0
    int32_t v1; // 0x515b0
    return function_4fef0(v1, 1, 0, 184);
}

// Address range: 0x515c0 - 0x515d0
int32_t function_515c0(int32_t a1, int32_t a2) {
    // 0x515c0
    return function_4fef0(a1, 0, a2, 184);
}

// Address range: 0x515d0 - 0x5161c
int32_t function_515d0(int32_t a1, int32_t a2, char a3, int32_t a4) {
    int32_t v1 = __asm_bfi(0, __asm_bfi(__asm_bfi(0, (int32_t)a3, 4, 2), a4, 0, 3), 0, 8); // 0x515e8
    return function_4fa10(a1, 0, a2, 60, __asm_bfc(__asm_bfi(v1, 7, 8, 4) | 0x8000, 16, 8) | -0x80000000);
}

// Address range: 0x5161c - 0x51668
int32_t function_5161c(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = __asm_bfi(0, __asm_bfi(__asm_bfi(0, a2, 4, 2), a3, 0, 3), 0, 8); // 0x51634
    return function_4fa10(a1, 1, 0, 60, __asm_bfc(__asm_bfi(v1, 7, 8, 4) | 0x8000, 16, 8) | -0x80000000);
}

// Address range: 0x51668 - 0x51694
int32_t function_51668(int32_t a1, int32_t a2, char a3, char a4, uint32_t a5) {
    // 0x51668
    return function_4fdf0(a1, 0, a2, (int32_t)a3, (int32_t)a4, a5 % 256);
}

// Address range: 0x51694 - 0x516bc
int32_t function_51694(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x51694
    return function_4fdf0(a1, 1, 0, a2, a3, a4);
}

// Address range: 0x516be - 0x516c0
int32_t function_516be(void) {
    // 0x516be
    int32_t result; // 0x516be
    return result;
}

// Address range: 0x516c0 - 0x516c2
int32_t function_516c0(void) {
    // 0x516c0
    int32_t v1; // 0x516c0
    return function_516cc(v1, v1, v1, v1);
}

// Address range: 0x516c2 - 0x516c4
int32_t function_516c2(void) {
    // 0x516c2
    int32_t result; // 0x516c2
    return result;
}

// Address range: 0x516c4 - 0x516c8
int32_t function_516c4(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x516c4
    *(int32_t *)a1 = a1;
    *(int32_t *)(a1 + 4) = a2;
    *(int32_t *)(a1 + 8) = a3;
    *(int32_t *)(a1 + 12) = a4;
    return a1 + 20;
}

// Address range: 0x516c8 - 0x516cc
int32_t function_516c8(void) {
    // 0x516c8
    int32_t result; // 0x516c8
    bool v1; // 0x516c8
    if (v1) {
        int32_t v2; // 0x516c8
        result = function_516e4(v2, v2);
    }
    // 0x516ca
    return result;
}

// Address range: 0x516cc - 0x516d0
int32_t function_516cc(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x516cc
    int32_t v1; // 0x516cc
    *(int32_t *)v1 = a1;
    *(int32_t *)(v1 + 4) = a2;
    *(int32_t *)(v1 + 8) = a3;
    *(int32_t *)(v1 + 12) = a4;
    int32_t result = function_51668(a1, a2, (char)a3, (char)a4, (int32_t)&g488); // 0x516ce
    return result;
}

// Address range: 0x516d0 - 0x516d4
int32_t function_516d0(void) {
    // 0x516d0
    return 1;
}

// Address range: 0x516d4 - 0x516d8
int32_t function_516d4(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x516d4
    int32_t v1; // 0x516d4
    *(int32_t *)v1 = result;
    *(int32_t *)(v1 + 4) = a2;
    *(int32_t *)(v1 + 8) = a3;
    *(int32_t *)(v1 + 12) = a4;
    return result;
}

// Address range: 0x516da - 0x516dc
int32_t function_516da(void) {
    // 0x516da
    int32_t result; // 0x516da
    return result;
}

// Address range: 0x516de - 0x516e0
int32_t function_516de(void) {
    // 0x516de
    int32_t result; // 0x516de
    return result;
}

// Address range: 0x516e2 - 0x516e4
int32_t function_516e2(void) {
    // 0x516e2
    int32_t result; // 0x516e2
    return result;
}

// Address range: 0x516e4 - 0x516e8
int32_t function_516e4(int32_t result, int32_t a2) {
    // 0x516e4
    *(int32_t *)a2 = a2;
    return result;
}

// Address range: 0x516ea - 0x516ec
int32_t function_516ea(void) {
    // 0x516ea
    int32_t result; // 0x516ea
    return result;
}

// Address range: 0x516ec - 0x516f8
int32_t function_516ec(void) {
    // 0x516ec
    int32_t v1; // 0x516ec
    return function_4fa10(v1, v1, v1, v1, (int32_t)&g488);
}

// Address range: 0x516f8 - 0x516fc
int32_t function_516f8(void) {
    // 0x516f8
    return 1;
}

// Address range: 0x516fe - 0x51700
int32_t function_516fe(void) {
    // 0x516fe
    int32_t result; // 0x516fe
    return result;
}

// Address range: 0x51700 - 0x51708
int32_t function_51700(void) {
    // 0x51700
    int32_t v1; // 0x51700
    return function_4fef0(v1, 0, v1, v1);
}

// Address range: 0x51708 - 0x51718
int32_t function_51708(int32_t a1, int32_t a2) {
    // 0x51708
    return function_4fe30(a1, 1, 0, a2);
}

// Address range: 0x51718 - 0x51728
int32_t function_51718(int32_t a1, int32_t a2, int32_t a3) {
    // 0x51718
    return function_4fe30(a1, 0, a2, a3);
}

// Address range: 0x51728 - 0x5174c
int32_t function_51728(int32_t a1, int32_t a2) {
    // 0x51728
    return function_4fa10(a1, 1, 0, 128, a2);
}

// Address range: 0x5174c - 0x51770
int32_t function_5174c(int32_t a1, int32_t a2, int32_t a3) {
    // 0x5174c
    return function_4fa10(a1, 0, a2, 128, a3);
}

// Address range: 0x51770 - 0x51794
int32_t function_51770(void) {
    // 0x51770
    int32_t v1; // 0x51770
    return function_4fa10(v1, 1, 0, 128, 0);
}

// Address range: 0x51794 - 0x517bc
int32_t function_51794(int32_t a1, int32_t a2) {
    // 0x51794
    return function_4fa10(a1, 0, a2, 128, 0);
}

// Address range: 0x517bc - 0x517f8
int32_t function_517bc(int32_t a1, int32_t a2) {
    int32_t v1; // 0x517bc
    if (a2 == 0) {
        v1 = __asm_bfieq(0, 0, 0, 16);
    } else {
        v1 = __asm_bfine(0, 255, 0, 16);
    }
    return function_4fa10(a1, 1, 0, 32, v1);
}

// Address range: 0x517f8 - 0x5182c
int32_t function_517f8(int32_t a1, int32_t a2, int32_t a3) {
    // 0x517f8
    return function_4fa10(a1, 0, a2, 32, __asm_bfi(0, a3 == 0 ? 0 : 255, 0, 16));
}

// Address range: 0x5182c - 0x5182e
int32_t function_5182c(int32_t a1) {
    // 0x5182c
    int32_t v1; // 0x5182c
    return v1 & a1;
}

// Address range: 0x5182e - 0x51882
int32_t function_5182e(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x5182e
    int32_t v1; // 0x5182e
    bool v2; // 0x5182e
    bool v3; // 0x5182e
    bool v4; // 0x5182e
    int32_t v5; // 0x5182e
    if (v4 || false) {
        if ((v5 / 0x40000 & v5) == 0) {
            if ((a1 & 68) == 0) {
                goto lab_dec_label_pc_unknown_57;
            } else {
                // ._crit_edge
                v2 = (a1 & 64) != 0;
                v1 = a1 / 8;
                goto lab_dec_label_pc_unknown_58;
            }
        } else {
            v3 = false;
            if ((v5 & 0x200000) == 0) {
                goto lab_dec_label_pc_unknown_57;
            } else {
                goto lab__thread24_2;
            }
        }
    } else {
        // .thread18
        if ((v5 & 0x200000) == 0) {
            goto lab_dec_label_pc_unknown_57;
        } else {
            goto lab__thread24_2;
        }
    }
  lab_dec_label_pc_unknown_57:;
    bool v6 = (a1 & 64) != 0;
    int32_t v7 = a1 / 8;
    int32_t v8 = v5 ^ v7; // 0x5184a
    v2 = v6;
    v1 = v7;
    bool v9 = v6; // 0x51852
    int32_t v10 = v8; // 0x51852
    if (v8 == 0) {
        goto lab_dec_label_pc_unknown_58;
    } else {
        goto lab_0x5185e;
    }
  lab__thread24_2:;
    int32_t v11 = a1; // 0x5186e
    bool v12 = v3; // 0x5186e
    bool v13 = false; // 0x5186e
    if ((a1 & 64) != 0) {
        return v13 | v12 != v14 ? v11 : v5 * v5;
    } else {
        goto lab_dec_label_pc_unknown_59;
    }
  lab_dec_label_pc_unknown_58:;
    int32_t v15 = v1 - a2; // 0x51852
    v9 = v2;
    bool v16 = (v15 & a2) < 0; // 0x5185a
    v10 = v15;
    if (v1 == a2) {
        return a1 - v5;
    }
    goto lab_0x5185e;
  lab_0x5185e:;
    bool v17 = v16; // 0x5186e
    bool v14 = v16; // 0x5186e
    v11 = a1;
    v12 = v10 < 0;
    v13 = false;
    if (v9) {
        goto lab__thread12;
    } else {
        goto lab_dec_label_pc_unknown_59;
    }
  lab__thread12:
    // .thread12
    return v13 | v12 != v14 ? v11 : v5 * v5;
  lab_dec_label_pc_unknown_59:;
    int32_t v18 = v5 | 128 * a4; // 0x5186e
    v14 = v17;
    v11 = a1;
    v12 = v18 < 0;
    v13 = v18 == 0;
    if ((a4 & 0x2000000) == 0) {
        int32_t v19 = v5 & a4 >> 15; // 0x51872
        v14 = v17;
        v11 = v19;
        v12 = v18 < 0;
        v13 = v18 == 0;
        if ((a4 & 0x4000) == 0) {
            int32_t v20 = v5 >> 11 ^ v5; // 0x51876
            v14 = v17;
            v11 = v19;
            v12 = v20 < 0;
            v13 = v20 == 0;
        }
    }
    goto lab__thread12;
}

// Address range: 0x51882 - 0x51884
int32_t function_51882(int32_t a1) {
    // 0x51882
    return function_513a0(a1);
}

// Address range: 0x51884 - 0x51890
int32_t function_51884(int32_t a1, int32_t a2) {
    // 0x51884
    int32_t v1; // 0x51884
    return function_4fa10(v1, v1, v1, v1, (int32_t)&g488);
}

// Address range: 0x51892 - 0x51893
int32_t function_51892(void) {
    // 0x51892
    int32_t result; // 0x51892
    return result;
}

// Address range: 0x51894 - 0x51898
int32_t function_51894(void) {
    // 0x51894
    int32_t result; // 0x51894
    bool v1; // 0x51894
    if (v1) {
        int32_t v2; // 0x51894
        result = function_518b8(v2);
    }
    // 0x51896
    return result;
}

// Address range: 0x51898 - 0x5189c
int32_t function_51898(int32_t result, int32_t a2) {
    // 0x51898
    *(int32_t *)(2 * result) = a2;
    return result;
}

// Address range: 0x5189c - 0x518a0
int32_t function_5189c(int32_t a1) {
    // 0x5189c
    return a1 + 12;
}

// Address range: 0x518a0 - 0x518a4
int32_t function_518a0(int32_t result, int32_t a2, int32_t a3) {
    // 0x518a0
    *(int32_t *)result = a3;
    return result;
}

// Address range: 0x518a4 - 0x518a8
int32_t function_518a4(int32_t result) {
    // 0x518a4
    return result;
}

// Address range: 0x518a8 - 0x518ac
int32_t function_518a8(int32_t a1) {
    // 0x518a8
    return 0;
}

// Address range: 0x518ac - 0x518b0
int32_t function_518ac(void) {
    // 0x518ac
    return 5;
}

// Address range: 0x518b0 - 0x518b4
int32_t function_518b0(int32_t a1) {
    // 0x518b0
    return function_513d0(a1);
}

// Address range: 0x518b4 - 0x518b8
int32_t function_518b4(int32_t result) {
    // 0x518b4
    return result;
}

// Address range: 0x518b8 - 0x518bc
int32_t function_518b8(int32_t a1) {
    // 0x518b8
    return a1 + 52;
}

// Address range: 0x518bc - 0x518f8
int32_t function_518bc(uint32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x518bc
    int32_t v1; // 0x518bc
    function_51a20(v1, v1, v1, v1, &g488);
    uint32_t v2 = a1 % 256; // 0x518c0
    int32_t v3 = v2 | 8; // 0x518d8
    if (v1 == 0) {
        v3 = __asm_bfieq(v2, 0, 3, 1);
    }
    return function_4fa10(v1, 0, v1, 52, 0x1000000 * v3 >> 24);
}

// Address range: 0x518f8 - 0x51900
int32_t function_518f8(void) {
    // 0x518f8
    return -1;
}

// Address range: 0x51900 - 0x51908
int32_t function_51900(void) {
    // 0x51900
    return -1;
}

// Address range: 0x5190a - 0x5190c
int32_t function_5190a(void) {
    // 0x5190a
    return function_5204e();
}

// Address range: 0x5190c - 0x5190e
int32_t function_5190c(void) {
    // 0x5190c
    int32_t v1; // 0x5190c
    return function_51918(v1, v1, v1, v1);
}

// Address range: 0x5190e - 0x51910
int32_t function_5190e(void) {
    // 0x5190e
    int32_t result; // 0x5190e
    return result;
}

// Address range: 0x51910 - 0x51914
int32_t function_51910(int32_t a1) {
    // 0x51910
    int32_t v1; // 0x51910
    *(int32_t *)v1 = a1;
    return function_518ac();
}

// Address range: 0x51914 - 0x51918
int32_t function_51914(void) {
    // 0x51914
    int32_t result; // 0x51914
    bool v1; // 0x51914
    if (v1) {
        result = function_51930();
    }
    // 0x51916
    return result;
}

// Address range: 0x51918 - 0x5191c
int32_t function_51918(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x51918
    int32_t v1; // 0x51918
    *(int32_t *)v1 = a1;
    *(int32_t *)(v1 + 4) = a2;
    *(int32_t *)(v1 + 8) = a3;
    *(int32_t *)(v1 + 12) = a4;
    int32_t result = function_518bc((int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488); // 0x5191a
    return result;
}

// Address range: 0x5191c - 0x51920
int32_t function_5191c(int32_t a1) {
    // 0x5191c
    return function_52062();
}

// Address range: 0x51922 - 0x51924
int32_t function_51922(void) {
    // 0x51922
    int32_t v1; // 0x51922
    return function_5203e(v1, v1, v1, v1);
}

// Address range: 0x51924 - 0x51928
int32_t function_51924(void) {
    // 0x51924
    return function_5206a();
}

// Address range: 0x51928 - 0x5192c
int32_t function_51928(int32_t a1) {
    // 0x51928
    return function_5206e();
}

// Address range: 0x5192e - 0x51930
int32_t function_5192e(void) {
    // 0x5192e
    int32_t result; // 0x5192e
    return result;
}

// Address range: 0x51930 - 0x51938
int32_t function_51930(void) {
    // 0x51930
    int32_t v1; // 0x51930
    return function_51e54(v1, (int32_t *)v1, v1);
}

// Address range: 0x51938 - 0x5193c
int32_t function_51938(void) {
    // 0x51938
    int32_t result; // 0x51938
    return result;
}

// Address range: 0x5193c - 0x51970
int32_t function_5193c(int32_t a1, int32_t a2, int32_t a3) {
    // 0x5193c
    return function_4fa10(a1, 0, a2, 60, __asm_bfc(__asm_bfi(0, a3, 8, 4), 15, 1) | -0x80000000);
}

// Address range: 0x51970 - 0x51978
int32_t function_51970(uint32_t a1) {
    // 0x51970
    return a1 / 0x1000000;
}

// Address range: 0x51978 - 0x5198c
int32_t function_51978(int32_t a1) {
    // 0x51978
    __asm_ubfx(a1, 16, 8);
    return (uint32_t)function_5f880() % 256;
}

// Address range: 0x5198c - 0x51a20
int32_t function_5198c(uint32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x5198c
    if (a1 >= 3 == (a1 != 3)) {
        // 0x519d4
        return -1;
    }
    int32_t v1 = 0x20000 * a1;
    int32_t * v2 = (int32_t *)(512 * a1 + (int32_t)&g152);
    for (int32_t i = 0; i < 4; i++) {
        int32_t v3 = v1 + (int32_t)&g154; // 0x519c4
        if (i == a1) {
            int32_t v4 = v3 + 512; // 0x519f4
            function_11fc4((int32_t *)v3, (int32_t)&g315, 0, a4);
            v3 = v4;
            while (v4 != v1 + (int32_t)&g157) {
                // 0x519e8
                v4 = v3 + 512;
                function_11fc4((int32_t *)v3, (int32_t)&g315, 0, a4);
                v3 = v4;
            }
            // 0x51a04
            function_11fc4(v2, (int32_t)&g315, 0, a4);
        }
    }
    // 0x519d4
    return 0;
}

// Address range: 0x51a20 - 0x51b44
int32_t function_51a20(int32_t a1, uint32_t a2, uint32_t a3, int32_t a4, int32_t * a5) {
    uint32_t v1 = __asm_ubfx(a4, 2, 8); // 0x51a28
    if (a2 >= 3 == (a2 != 3)) {
        // 0x51aa4
        return -1;
    }
    // 0x51a34
    if (a3 >= 255 == (a3 != 255)) {
        // 0x51aa4
        return -2;
    }
    // 0x51a3c
    if (v1 >= 63 == (v1 != 63)) {
        // 0x51aa4
        return -3;
    }
    // 0x51a44
    function_11f94(&g153, a2, a3, a4);
    int32_t v2; // 0x51b00
    switch (a1) {
        case 0: {
            int32_t v3 = 8 * (v1 + 64 * a2) + (int32_t)&g152; // 0x51ae0
            int32_t v4 = *(int32_t *)v3; // 0x51ae0
            if (v4 != a4) {
                // 0x51aec
                function_11ea4(&g153, a2, a3, v4);
                // 0x51a80
                function_11f34("[%s] level::%d, which_chain::%u, which_asic::%u, register_address::%02x failed.\r\n", (int32_t *)"get_register_cache_value", a1, a2);
                // 0x51aa4
                return -4;
            }
            // 0x51b00
            v2 = *(int32_t *)(v3 + 4);
            *a5 = v2;
            function_11ea4(&g153, a2, (int32_t)a5, v2);
            return 0;
        }
        case 1: {
            int32_t v5 = 8 * (v1 + 64 * (256 * a2 + a3)) + (int32_t)&g154; // 0x51ac0
            int32_t v6 = *(int32_t *)v5; // 0x51ac0
            if (v6 != a4) {
                // 0x51acc
                function_11ea4(&g153, a2, v6, (int32_t)&g154);
                // 0x51a80
                function_11f34("[%s] level::%d, which_chain::%u, which_asic::%u, register_address::%02x failed.\r\n", (int32_t *)"get_register_cache_value", a1, a2);
                // 0x51aa4
                return -5;
            }
            // 0x51b00
            v2 = *(int32_t *)(v5 + 4);
            *a5 = v2;
            function_11ea4(&g153, a2, (int32_t)a5, v2);
            return 0;
        }
    }
    // 0x51a74
    function_11ea4(&g153, a2, a3, a4);
    // 0x51a80
    function_11f34("[%s] level::%d, which_chain::%u, which_asic::%u, register_address::%02x failed.\r\n", (int32_t *)"get_register_cache_value", a1, a2);
    // 0x51aa4
    return -6;
}

// Address range: 0x51b44 - 0x51ca4
int32_t function_51b44(int32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, int32_t a5) {
    // 0x51b44
    if (a2 >= 3 == (a2 != 3)) {
        // 0x51bc8
        return -1;
    }
    // 0x51b58
    if (a3 >= 255 == (a3 != 255)) {
        // 0x51bc8
        return -2;
    }
    // 0x51b60
    if (a4 >= 256 == ((a4 & -4) != 256)) {
        // 0x51bc8
        return -3;
    }
    uint32_t v1 = a4 / 4; // 0x51b60
    function_11f94(&g153, a2, a3, a4);
    int32_t v2; // 0x51c5c
    switch (a1) {
        case 0: {
            int32_t v3 = v1 + 64 * a2; // 0x51c00
            int32_t v4 = 8 * v3; // 0x51c04
            int32_t v5 = *(int32_t *)(v4 + (int32_t)&g152); // 0x51c04
            if (v5 != a4) {
                // 0x51c10
                function_11ea4(&g153, a2, v3, v5);
                // 0x51ba8
                function_11f34("[%s] level::%d, which_chain::%u, which_asic::%u, register_address::%02x failed.\r\n", (int32_t *)"set_register_cache_value", a1, a2);
                // 0x51bc8
                return -4;
            }
            int32_t v6 = 8 * (v1 + 0x4000 * a2); // 0x51c50
            *(int32_t *)(v4 + (int32_t)&g152 + 4) = a5;
            v2 = v6 + (int32_t)&g157;
            int32_t v7 = v6 + (int32_t)&g154; // 0x51c60
            *(int32_t *)(v7 + 4) = a5;
            v7 += 512;
            while (v7 != v2) {
                // 0x51c64
                *(int32_t *)(v7 + 4) = a5;
                v7 += 512;
            }
            // break -> 0x51c74
            break;
        }
        case 1: {
            int32_t v8 = 8 * (v1 + 64 * (256 * a2 + a3)); // 0x51be4
            int32_t v9 = v8 + (int32_t)&g154; // 0x51be4
            int32_t v10 = *(int32_t *)v9; // 0x51be4
            if (v10 == a4) {
                // 0x51c20
                *(int32_t *)(v8 + (int32_t)&g154 + 4) = a5;
                function_11ea4(&g153, a2, a4, v9);
                return 0;
            }
            // 0x51bf0
            function_11ea4(&g153, a2, v10, (int32_t)&g154);
            // 0x51ba8
            function_11f34("[%s] level::%d, which_chain::%u, which_asic::%u, register_address::%02x failed.\r\n", (int32_t *)"set_register_cache_value", a1, a2);
            // 0x51bc8
            return -5;
        }
        default: {
            // 0x51b9c
            function_11ea4(&g153, a2, a3, a4);
            // 0x51ba8
            function_11f34("[%s] level::%d, which_chain::%u, which_asic::%u, register_address::%02x failed.\r\n", (int32_t *)"set_register_cache_value", a1, a2);
            // 0x51bc8
            return -6;
        }
    }
    // 0x51c74
    function_11ea4(&g153, (int32_t)&g154, v2, v2);
    return 0;
}

// Address range: 0x51cac - 0x51d44
int32_t function_51cac(int32_t a1, int32_t a2, int32_t a3, uint32_t a4, int32_t * a5) {
    int32_t result = -1; // 0x51cb8
    if (a5 != NULL) {
        int32_t v1 = (int32_t)a5;
        *a5 = 0;
        *(char *)(v1 + 3) = (char)a3;
        *(char *)(v1 + 7) = (char)a4;
        int32_t v2 = __asm_bfi(0, 1, 0, 4); // 0x51ce4
        *(char *)(v1 + 2) = (char)a2;
        int32_t v3 = __asm_bfi(v2, (int32_t)(a1 != 0), 4, 1); // 0x51cec
        *(char *)(v1 + 4) = (char)(a4 / 0x1000000);
        int32_t v4 = __asm_bfi(v3, 2, 5, 3); // 0x51d00
        *(char *)(v1 + 5) = (char)(a4 / 0x10000);
        *(char *)(v1 + 6) = (char)(a4 / 256);
        char * v5 = (char *)(v1 + 8); // 0x51d18
        *v5 = 0;
        *(char *)a5 = (char)v4;
        *(char *)(v1 + 1) = 9;
        *v5 = (char)__asm_bfi((int32_t)*v5, function_51f28(v1, 64), 0, 5);
        result = 0;
    }
    // 0x51d34
    return result;
}

// Address range: 0x51d44 - 0x51d98
int32_t function_51d44(int32_t a1, int32_t * a2) {
    int32_t result = -1; // 0x51d4c
    if (a2 != NULL) {
        int32_t v1 = (int32_t)a2;
        *a2 = 0;
        char * v2 = (char *)(v1 + 4); // 0x51d60
        *v2 = 0;
        *(char *)(v1 + 2) = (char)a1;
        *(char *)(v1 + 1) = 5;
        *(char *)a2 = 64;
        *v2 = (char)__asm_bfi((int32_t)*v2, function_51f28(v1, 32), 0, 5);
        result = 0;
    }
    // 0x51d88
    return result;
}

// Address range: 0x51d98 - 0x51e08
int32_t function_51d98(int32_t a1, int32_t a2, int32_t a3, int32_t * a4) {
    int32_t result = -1; // 0x51da0
    if (a4 != NULL) {
        int32_t v1 = (int32_t)a4;
        *a4 = 0;
        *(char *)(v1 + 3) = (char)a3;
        *(char *)(v1 + 2) = (char)a2;
        int32_t v2; // 0x51d98
        int32_t v3 = __asm_bfi((uint32_t)v2 % 256, 2, 0, 4); // 0x51dcc
        char * v4 = (char *)(v1 + 4); // 0x51dd0
        *v4 = 0;
        int32_t v5 = __asm_bfi(v3, (int32_t)(a1 != 0), 4, 1); // 0x51dd4
        *(char *)(v1 + 1) = 5;
        *(char *)a4 = (char)__asm_bfi(v5, 2, 5, 3);
        *v4 = (char)__asm_bfi((int32_t)*v4, function_51f28(v1, 32), 0, 5);
        result = 0;
    }
    // 0x51df8
    return result;
}

// Address range: 0x51e08 - 0x51e54
int32_t function_51e08(int32_t * a1) {
    int32_t result = -1; // 0x51e10
    if (a1 != NULL) {
        int32_t v1 = (int32_t)a1;
        *a1 = 0;
        char * v2 = (char *)(v1 + 4); // 0x51e24
        *v2 = 0;
        *(char *)(v1 + 1) = 5;
        *(char *)a1 = 83;
        *v2 = (char)__asm_bfi((int32_t)*v2, function_51f28(v1, 32), 0, 5);
        result = 0;
    }
    // 0x51e44
    return result;
}

// Address range: 0x51e54 - 0x51f28
int32_t function_51e54(int32_t a1, int32_t * a2, uint32_t a3) {
    // 0x51e54
    int32_t v1; // bp-36, 0x51e54
    int32_t v2 = &v1; // 0x51e68
    v1 = 0;
    int32_t v3 = 0; // 0x51e7c
    int32_t v4 = v2; // 0x51e7c
    if (a3 == 0) {
        // 0x51ecc
        function_457e0(v2, a1);
        return 0;
    }
    int32_t v5; // 0x51e54
    while (true) {
      lab_0x51e80_2:
        // 0x51e80
        v5 = v4;
        uint32_t v6 = v3;
        if (v6 < a3) {
            int32_t v7 = v6 + (int32_t)a2; // 0x51e84
            int32_t * v8 = (int32_t *)v5; // 0x51e98
            char * v9 = (char *)v7;
            int32_t v10 = 0;
            int32_t v11 = *v8; // 0x51e98
            int32_t v12; // 0x51e54
            int32_t v13; // 0x51e54
            int32_t v14; // 0x51ee0
            int32_t v15; // 0x51e54
            int32_t v16; // 0x51ef8
            int32_t v17; // 0x51f14
            int32_t v18; // 0x51ea4
            if (v10 == 0) {
                // 0x51ea0
                v18 = 0x1000000 * (int32_t)*v9 | v11;
                *v8 = v18;
                v12 = v18;
            } else {
                // 0x51ee0
                v14 = (int32_t)*(char *)(v10 + v7);
                v13 = (v10 == 1 ? 0x10000 * v14 : 0) | v11;
                if (v10 == 1) {
                    *v8 = v13;
                    v12 = v13;
                } else {
                    if (v10 == 2) {
                        v15 = v13 | 256 * v14;
                        *v8 = v15;
                        v12 = v15;
                    } else {
                        // 0x51f08
                        v16 = v13 | v14;
                        *v8 = v16;
                        v12 = v16;
                        if (v10 == 3) {
                            // 0x51f14
                            v17 = v6 + 4;
                            v3 = v17;
                            if (v17 < a3) {
                                goto lab_0x51e80;
                            } else {
                                goto lab_0x51ecc;
                            }
                        }
                    }
                }
            }
            int32_t v19 = v10 + 1; // 0x51eac
            while (v19 + v6 < a3) {
                // 0x51e94
                v10 = v19;
                v11 = v12;
                if (v10 == 0) {
                    // 0x51ea0
                    v18 = 0x1000000 * (int32_t)*v9 | v11;
                    *v8 = v18;
                    v12 = v18;
                } else {
                    // 0x51ee0
                    v14 = (int32_t)*(char *)(v10 + v7);
                    v13 = (v10 == 1 ? 0x10000 * v14 : 0) | v11;
                    if (v10 == 1) {
                        *v8 = v13;
                        v12 = v13;
                    } else {
                        if (v10 == 2) {
                            v15 = v13 | 256 * v14;
                            *v8 = v15;
                            v12 = v15;
                        } else {
                            // 0x51f08
                            v16 = v13 | v14;
                            *v8 = v16;
                            v12 = v16;
                            if (v10 == 3) {
                                // 0x51f14
                                v17 = v6 + 4;
                                v3 = v17;
                                if (v17 < a3) {
                                    goto lab_0x51e80;
                                } else {
                                    goto lab_0x51ecc;
                                }
                            }
                        }
                    }
                }
                // 0x51eac
                v19 = v10 + 1;
            }
        }
        int32_t v20 = v6 + 4; // 0x51ebc
        v3 = v20;
        if (v20 >= a3) {
            // break -> 0x51ecc
            break;
        }
        goto lab_0x51e80;
    }
  lab_0x51ecc:
    // 0x51ecc
    function_457e0(v2, a1);
    return 0;
  lab_0x51e80:
    // 0x51e80
    v4 = v5 + 4;
    goto lab_0x51e80_2;
}

// Address range: 0x51f28 - 0x52000
int32_t function_51f28(int32_t a1, uint32_t a2) {
    if (a2 == 0) {
        // 0x51fe8
        return 31;
    }
    char v1 = *(char *)a1; // 0x51f68
    int32_t v2 = v1 > -1;
    bool v3 = false; // 0x51fb4
    uint32_t v4 = 1; // 0x51fb4
    int32_t v5 = 1; // 0x51fb4
    int32_t v6 = 128; // 0x51fb4
    if (a2 == 1) {
        // .thread33
        return (v1 > -1 ? 26 : 30) | (int32_t)(v2 != 0);
    }
    int32_t v7 = a1; // 0x51fb4
    int32_t v8 = 1;
    int32_t v9 = 1;
    int32_t v10 = v2;
    v7 += (int32_t)v3;
    v6 /= 2;
    int32_t v11 = (1 ^ v2) % 256; // 0x51fac
    v5 = v3 ? 1 : (v5 + 1) % 256;
    v4 = (v4 + 1) % 256;
    int32_t v12 = 1 ^ (int32_t)((v6 & (int32_t)*(char *)v7) != 0);
    int32_t v13 = v12 % 256; // 0x51f90
    v3 = v5 == 8;
    while (v4 < a2) {
        int32_t v14 = v8;
        int32_t v15 = v9;
        v8 = v10;
        v9 = v11;
        v10 = v13;
        v7 += (int32_t)v3;
        v6 /= 2;
        v11 = (v14 ^ v12) % 256;
        unsigned char v16 = *(char *)v7; // 0x51f68
        v5 = v3 ? 1 : (v5 + 1) % 256;
        v4 = (v4 + 1) % 256;
        v12 = v15 ^ (int32_t)((v6 & (int32_t)v16) != 0);
        v13 = v12 % 256;
        v3 = v5 == 8;
    }
    int32_t v17 = v11 == 0 ? v9 == 0 ? 0 : 16 : v9 == 0 ? 8 : 24;
    int32_t v18 = v13 == v8 ? v17 : v17 | 4;
    return (v10 == 0 ? v18 : v18 | 2) | (int32_t)(v13 != 0);
}

// Address range: 0x52000 - 0x5203c
int32_t function_52000(int32_t a1, int32_t a2) {
    int32_t v1 = a1; // 0x52004
    if (a2 == 0) {
        v1 = function_52048();
    }
    // 0x52008
    return v1 + 1;
}

// Address range: 0x5203e - 0x52044
int32_t function_5203e(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x5203e
    return function_5234c(a1, a2);
}

// Address range: 0x52044 - 0x52048
int32_t function_52044(int32_t a1) {
    // 0x52044
    int32_t result; // 0x52044
    return result;
}

// Address range: 0x52048 - 0x5204c
int32_t function_52048(void) {
    // 0x52048
    return 0xffff;
}

// Address range: 0x5204e - 0x52050
int32_t function_5204e(void) {
    int32_t result = function_522b0((int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488); // 0x5204e
    return result;
}

// Address range: 0x52054 - 0x52058
int32_t function_52054(int32_t fd, struct iovec * iovec, int32_t count) {
    // 0x52054
    return function_524f4(readv(fd, iovec, count), (int32_t)iovec, count);
}

// Address range: 0x52058 - 0x5205c
int32_t function_52058(int32_t a1) {
    // 0x52058
    *(char *)a1 = (char)a1;
    return function_5239e();
}

// Address range: 0x5205c - 0x52060
int32_t function_5205c(int32_t result) {
    // 0x5205c
    return result;
}

// Address range: 0x52062 - 0x52064
int32_t function_52062(void) {
    // 0x52062
    int32_t result; // 0x52062
    return result;
}

// Address range: 0x52064 - 0x52068
int32_t function_52064(void) {
    // 0x52064
    return function_11fb8();
}

// Address range: 0x5206a - 0x5206b
int32_t function_5206a(void) {
    // 0x5206a
    int32_t result; // 0x5206a
    return result;
}

// Address range: 0x5206e - 0x52070
int32_t function_5206e(void) {
    // 0x5206e
    int32_t result; // 0x5206e
    return result;
}

// Address range: 0x52070 - 0x522b0
int32_t function_52070(int32_t a1, uint32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10) {
    // 0x52070
    int32_t str; // bp+16, 0x52070
    sprintf((char *)&str, (char *)(a2 % 0x10000 | 0x60000));
    int32_t domain; // 0x52070
    prctl(PR_SET_NAME, (int32_t)&str, domain, domain, (int32_t)&g488);
    int16_t addr = domain; // bp+32, 0x520a0
    inet_addr("127.0.0.1");
    int32_t sock_fd = socket(domain, SOCK_STREAM, domain); // 0x520bc
    int32_t v1 = 1; // 0x520d4
    if (function_11f1c(sock_fd, 1, domain, &v1, 4) < 0) {
        // 0x5229c
        perror("set sockopt err");
        return 0;
    }
    // 0x520f8
    __asm_rev16(domain);
    if (bind(sock_fd, (struct sockaddr *)&addr, 16) < 0) {
        int32_t v2 = domain + 1;
        perror("bind error");
        *(int32_t *)domain = v2;
        __asm_rev16(v2);
        while (bind(sock_fd, (struct sockaddr *)&addr, 16) < 0) {
            // 0x5211c
            perror("bind error");
            *(int32_t *)domain = v2;
            __asm_rev16(v2);
        }
    }
    // 0x52130
    if (listen(sock_fd, 5) < 0) {
        // 0x52284
        perror("listen error");
        return 0;
    }
    int32_t addr_len = 16; // bp+12, 0x52150
    *(int32_t *)(domain + 144) = 1;
    int32_t addr2; // bp+48, 0x52070
    int32_t accepted_sock_fd = accept(sock_fd, (struct sockaddr *)&addr2, &addr_len); // 0x52160
    if (accepted_sock_fd < 0) {
        function_522cc();
    }
    int32_t str2 = 0; // bp+64, 0x5217c
    int32_t v3; // bp+68, 0x52070
    memset(&v3, 0, 252);
    char * v4 = (char *)(domain + 16); // 0x521a0
    sprintf((char *)&str2, "%x %s\n", 63, v4);
    send(accepted_sock_fd, &str2, strlen((char *)&str2) + 1, 0);
    int32_t * length = (int32_t *)(domain + 148); // 0x521c4
    int32_t size = *length; // 0x521c4
    int32_t * mem = malloc(size); // 0x521d0
    int32_t v5 = (int32_t)mem; // 0x521d0
    int32_t v6 = recv(accepted_sock_fd, mem, size, 0); // 0x521f0
    if (v6 > 0) {
        *(char *)(v6 + v5) = 0;
    }
    int32_t v7 = 0;
    while (true) {
        int32_t v8 = recv(accepted_sock_fd, mem, *length, 0); // 0x5220c
        int32_t v9 = v8 < 1 ? 0 : v7; // 0x5221c
        if (v8 > 0) {
            // 0x52220
            v9 = *(int32_t *)(domain + 12) == 0 ? 0 : v5;
        }
        // 0x52234
        v7 = v9;
        int32_t str3 = 0; // bp+320, 0x52240
        int32_t v10; // bp+324, 0x52070
        memset(&v10, 0, 252);
        sprintf((char *)&str3, "%x %d %s %s", 63, v7, v4, "OK");
        send(accepted_sock_fd, &str3, strlen((char *)&str3) + 1, 0);
    }
}

// Address range: 0x522b0 - 0x522b8
int32_t function_522b0(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x522b0
    int32_t v1; // 0x522b0
    return (int32_t)*(int16_t *)(v1 + 62);
}

// Address range: 0x522b8 - 0x522cc
int32_t function_522b8(uint32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9) {
    // 0x522b8
    perror((char *)(a1 % 0x10000 | 0x60000));
    return 0;
}

// Address range: 0x522cc - 0x522dc
int32_t function_522cc(void) {
    // 0x522cc
    perror("accept error");
    return &g488;
}

// Address range: 0x522dc - 0x5234c
int32_t function_522dc(int32_t a1) {
    // 0x522dc
    function_11fa0(function_11fb8());
    char * v1 = (char *)0x625f7463; // bp-540, 0x52324
    int16_t v2 = 110; // bp-532, 0x5232c
    prctl(PR_SET_NAME, (int32_t)&v1, 110, (int32_t)&v2, 0x625f7463);
    int32_t attr; // bp-460, 0x522dc
    pthread_attr_init(&attr);
    return function_12024(&attr, &g1);
}

// Address range: 0x5234c - 0x52350
int32_t function_5234c(int32_t result, int32_t a2) {
    // 0x5234c
    *(char *)a2 = (char)result;
    return result;
}

// Address range: 0x52350 - 0x5239c
int32_t function_52350(void) {
    int32_t buf = 0; // bp+144, 0x52360
    int32_t v1; // bp+148, 0x52350
    memset(&v1, 0, 124);
    int32_t sock; // 0x52350
    int32_t v2 = recv(sock, &buf, 128, 0); // 0x52378
    int32_t v3 = v2; // 0x52380
    if (v2 < 1) {
        v3 = function_52594((int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488);
    }
    // 0x52384
    int32_t v4; // bp+528, 0x52350
    int32_t result = v3 + (int32_t)&v4; // 0x5238c
    *(char *)(result - 384) = 0;
    return result;
}

// Address range: 0x5239e - 0x523a0
int32_t function_5239e(void) {
    // 0x5239e
    int32_t result; // 0x5239e
    return result;
}

// Address range: 0x523a0 - 0x524f4
int32_t function_523a0(void) {
    // 0x523a0
    int32_t v1; // 0x523a0
    int32_t v2 = v1;
    int32_t v3; // bp+144, 0x523a0
    int32_t v4 = &v3; // 0x523a4
    sscanf2(v4, (char *)v1, (int32_t *)v1, v1);
    int32_t v5; // bp+76, 0x523a0
    if (function_11eec((int32_t)&v5, (char *)v1, v1, v1) != 0) {
        // 0x52404
        function_11fc4((int32_t *)(128 * v2 + (int32_t)&g164), v4, -128, v1);
        *(int32_t *)v2 = v2 + 1;
        return function_52350();
    }
    int32_t v6 = function_11eb0(152, 1, v1, v1); // 0x52434
    int32_t v7 = *(int32_t *)(v2 + 4); // 0x52438
    if (v7 == 0) {
        // 0x5244c
        return function_525a0();
    }
    // 0x5245c
    int32_t str; // bp+44, 0x523a0
    int32_t v8 = &str; // 0x52460
    int32_t v9 = (int32_t)&g166; // 0x523a0
    int32_t v10 = 0;
    while (function_11eec(v8, (char *)v9, v1, v1) != 0) {
        int32_t v11 = v10 + 1; // 0x52450
        v9 += 136;
        if (v11 == v7) {
            goto lab_0x52494;
        }
        v10 = v11;
    }
    int32_t v12 = 136 * v10; // 0x52480
    int32_t v13 = *(int32_t *)(v12 + (int32_t)&g165); // 0x52484
    int32_t v14 = *(int32_t *)(v12 + (int32_t)&g165 + 132); // 0x52488
    *(int32_t *)(v6 + 12) = v13;
    *(int32_t *)(v6 + 148) = v14;
    if (v7 == v10) {
      lab_0x52494:
        // 0x52494
        function_525a0();
    }
    int32_t * thread_func_arg = (int32_t *)v6; // 0x524b0
    *thread_func_arg = 0x4e20;
    int32_t len = strlen((char *)&str); // 0x524b4
    function_11fc4((int32_t *)(v6 + 16), v8, (char)len + 1, 0x4e20);
    *(int32_t *)(v6 + 144) = 0;
    int32_t attr; // bp+108, 0x523a0
    int32_t thread; // bp+24, 0x523a0
    return pthread_create(&thread, &attr, (int32_t * (*)(int32_t *))0x52050, thread_func_arg);
}

// Address range: 0x524f4 - 0x524f8
int32_t function_524f4(int32_t a1, int32_t a2, int32_t a3) {
    // 0x524f4
    return 0x10000000 * a3;
}

// Address range: 0x524f8 - 0x52508
int32_t function_524f8(void) {
    // 0x524f8
    int32_t usec; // 0x524f8
    return usleep(usec);
}

// Address range: 0x52508 - 0x52594
int32_t function_52508(void) {
    // 0x52508
    int32_t sock; // 0x52508
    int32_t v1 = sock;
    int32_t str = 0; // bp+272, 0x52520
    // 0x52508
    int32_t v2; // bp+276, 0x52508
    memset(&v2, 0, 252);
    int32_t v3; // bp+44, 0x52508
    sprintf((char *)&str, "%x %d %s %s %s", 63, sock, "reg_resp", "OK", &v3);
    send(sock, &str, strlen((char *)&str) + 1, 0);
    *(int32_t *)v1 = v1 + 1;
    return function_52350();
}

// Address range: 0x52594 - 0x525a0
int32_t function_52594(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    // 0x52594
    int32_t result; // 0x52594
    return result;
}

// Address range: 0x525a0 - 0x52618
int32_t function_525a0(void) {
    int32_t str = 0; // bp+272, 0x525b0
    int32_t v1; // bp+276, 0x525a0
    memset(&v1, 0, 252);
    int32_t v2; // bp+44, 0x525a0
    sprintf((char *)&str, "%x %d %s %s %s", 63, 0, "reg_resp", "no_name", &v2);
    int32_t length = strlen((char *)&str) + 1; // 0x525fc
    int32_t sock; // 0x525a0
    send(sock, &str, length, 0);
    free(sock, (int32_t)&str, length, 0);
    return function_52350();
}

// Address range: 0x5261c - 0x5292c
int32_t function_5261c(int32_t a1, int32_t a2) {
    // 0x5261c
    if (g161 != 0) {
        // 0x528c4
        return -1;
    }
    // 0x5263c
    int32_t attr; // bp-1092, 0x5261c
    pthread_attr_init(&attr);
    function_12024(&attr, &g1);
    function_11fdc((int32_t)&g162, 0);
    g160 = a2;
    if (a2 != 0) {
        int32_t v1 = a1 + 4; // 0x52674
        int32_t v2 = (int32_t)&g166;
        int32_t v3 = function_11fc4((int32_t *)v2, v1, -128, v2); // 0x5268c
        int32_t v4 = v1 + 136; // 0x52690
        *(int32_t *)(v3 + 128) = *(int32_t *)(v1 + 128);
        *(int32_t *)(v3 - 4) = *(int32_t *)(v1 - 4);
        while (v4 != 136 * a2 + v1) {
            int32_t v5 = v4;
            v2 = v3 + 136;
            v3 = function_11fc4((int32_t *)v2, v5, -128, v2);
            v4 = v5 + 136;
            *(int32_t *)(v3 + 128) = *(int32_t *)(v5 + 128);
            *(int32_t *)(v3 - 4) = *(int32_t *)(v5 - 4);
        }
    }
    int16_t addr = 2; // bp-1124, 0x526d4
    inet_addr("127.0.0.1");
    int32_t v6 = 1; // bp-1136, 0x526ec
    int32_t sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP); // 0x526f0
    if (sock_fd < 0) {
        // 0x528f0
        perror("socket error");
        // 0x528c4
        return -4;
    }
    // 0x526fc
    if (function_11f1c(sock_fd, 1, 2, &v6, 4) < 0) {
        // 0x52918
        perror("set sockopt err");
        // 0x528c4
        return -4;
    }
    // 0x52734
    __asm_rev16(0x560a);
    int32_t v7 = bind(sock_fd, (struct sockaddr *)&addr, 16); // 0x5274c
    int32_t v8 = 0x560a; // 0x52758
    if (v7 < 0) {
        v8++;
        perror("bind error");
        __asm_rev16(v8);
        while (bind(sock_fd, (struct sockaddr *)&addr, 16) < 0) {
            // 0x52730
            v8++;
            perror("bind error");
            __asm_rev16(v8);
        }
    }
    // 0x5275c
    if (listen(sock_fd, 5) < 0) {
        // 0x528dc
        perror("listen error");
        // 0x528c4
        return -4;
    }
    int32_t addr_len = 16; // bp-1132, 0x52780
    int32_t addr2; // bp-1108, 0x5261c
    int32_t accepted_sock_fd = accept(sock_fd, (struct sockaddr *)&addr2, &addr_len); // 0x52784
    if (accepted_sock_fd < 0) {
        // 0x52904
        perror("accept error");
        // 0x528c4
        return -4;
    }
    int32_t str = 0; // bp-1056, 0x527a0
    int32_t v9; // bp-1052, 0x5261c
    memset(&v9, 0, 124);
    sprintf((char *)&str, "Hello!0x%x\n", 63);
    send(accepted_sock_fd, &str, strlen((char *)&str) + 1, 0);
    g161 = 1;
    int32_t buf = 0; // bp-544, 0x527ec
    g163 = accepted_sock_fd;
    int32_t v10; // bp-540, 0x5261c
    memset(&v10, 0, 508);
    int32_t v11 = recv(accepted_sock_fd, &buf, 1024, 0); // 0x5280c
    int32_t v12; // bp-40, 0x5261c
    int32_t v13 = &v12;
    if (v11 > 0) {
        *(char *)(v13 - 504 + v11) = 0;
    }
    int32_t buf2 = 0x20333231; // bp-800, 0x52834
    int32_t v14; // bp-784, 0x5261c
    memset(&v14, 0, 240);
    send(accepted_sock_fd, &buf2, 16, 0);
    int32_t buf3 = 0; // bp-928, 0x52868
    int32_t v15; // bp-924, 0x5261c
    memset(&v15, 0, 124);
    int32_t v16 = recv(accepted_sock_fd, &buf3, 128, 0); // 0x52880
    if (v16 > 0) {
        *(char *)(v13 - 888 + v16) = 0;
    }
    int32_t * mem = malloc(12); // 0x5289c
    int32_t v17 = (int32_t)mem; // 0x5289c
    *(int32_t *)(v17 + 8) = accepted_sock_fd;
    *(int32_t *)(v17 + 4) = sock_fd;
    int32_t thread; // bp-1128, 0x5261c
    pthread_create(&thread, &attr, (int32_t * (*)(int32_t *))0x522dc, mem);
    // 0x528c4
    return 0;
}

// Address range: 0x52930 - 0x52bd8
int32_t function_52930(int32_t a1) {
    // 0x52930
    if (g161 == 0) {
        // 0x52b94
        return -1;
    }
    int32_t mem = (int32_t)malloc(36); // 0x5295c
    function_11fdc(mem, 0);
    int32_t str = 0; // bp-800, 0x5297c
    int32_t v1; // bp-796, 0x52930
    memset(&v1, 0, 252);
    sprintf((char *)&str, "%x regist %s", 63, (char *)a1);
    send(g163, &str, strlen((char *)&str) + 1, 0);
    int32_t v2 = 0; // bp-1056, 0x529c8
    int32_t v3; // bp-1052, 0x52930
    memset(&v3, 0, 124);
    usleep(1000);
    while (true) {
        // 0x529dc
        usleep(1000);
    }
    // 0x529f0
    function_11fc4(&v2, 128 * g159 + (int32_t)&g164, -128, g159);
    int32_t v4 = 0; // bp-1176, 0x52a38
    int32_t v5 = 0; // bp-1172, 0x52a3c
    sscanf2((int32_t)&v2, "%x%d%s%s%s", &v5, (int32_t)&v4);
    if (v4 == 0) {
        // 0x52b94
        return -4;
    }
    int16_t addr = 2; // bp-1168, 0x52abc
    inet_addr("127.0.0.1");
    __asm_rev16(v4);
    int32_t sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP); // 0x52af0
    if (sock_fd < 0) {
        // 0x52bc4
        perror("socket err:");
        // 0x52b94
        return -4;
    }
    // 0x52afc
    if (connect(sock_fd, (struct sockaddr *)&addr, 16) < 0) {
        // 0x52bb0
        perror("connect err:");
        // 0x52b94
        return -3;
    }
    int32_t buf = 0; // bp-544, 0x52b1c
    int32_t v6; // bp-540, 0x52930
    memset(&v6, 0, 508);
    int32_t v7 = recv(sock_fd, &buf, 512, 0); // 0x52b34
    if (v7 > 0) {
        int32_t v8; // bp-40, 0x52930
        *(char *)((int32_t)&v8 - 504 + v7) = 0;
    }
    int32_t v9; // bp-924, 0x52930
    memset(&v9, 0, 124);
    int32_t buf2 = &g15; // bp-928, 0x52b78
    send(sock_fd, &buf2, 4, 0);
    *(int32_t *)(mem + 32) = sock_fd;
    *(int32_t *)(a1 + 128) = mem;
    *(int32_t *)(mem + 24) = v4;
    // 0x52b94
    return 0;
}

// Address range: 0x52bd8 - 0x52bf0
int32_t function_52bd8(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x52bd8
    return 0;
}

// Address range: 0x52bf0 - 0x52d3c
int32_t function_52bf0(char * a1, int32_t buf, int32_t length, int32_t * a4) {
    // 0x52bf0
    if (g161 == 0) {
        // 0x52cdc
        return -1;
    }
    int32_t v1 = *(int32_t *)((int32_t)a1 + 128); // 0x52c0c
    if (v1 == 0) {
        // 0x52cdc
        return -2;
    }
    int32_t * v2 = (int32_t *)v1; // 0x52c28
    if (function_11ff4(v2) != 0) {
        // 0x52cdc
        return -3;
    }
    int32_t * sock = (int32_t *)(v1 + 32); // 0x52c40
    if (send(*sock, (int32_t *)buf, length, 0) < 1) {
        // 0x52d2c
        function_11ea4(v2, buf, length, 0);
        // 0x52cdc
        return -4;
    }
    int32_t buf2 = 0; // bp-280, 0x52c5c
    int32_t v3; // bp-276, 0x52bf0
    memset(&v3, 0, 252);
    int32_t v4 = &buf2; // 0x52c64
    int32_t v5 = recv(*sock, &buf2, 256, 0); // 0x52c74
    int32_t v6 = 0; // bp-352, 0x52c7c
    int32_t v7 = 0; // bp-348, 0x52c80
    v7 = 0;
    int32_t v8 = v4; // 0x52cc4
    int32_t v9 = 256; // 0x52cc4
    int32_t v10 = 0; // 0x52cc4
    if (v5 > 0) {
        // 0x52ce8
        v10 = &v7;
        sscanf2(v4, "%x%d%s%s", &v6, v10);
        v8 = (int32_t)"%x%d%s%s";
        v9 = &v6;
    }
    int32_t v11 = a4 == NULL ? v10 : v7;
    if (a4 != NULL) {
        *a4 = v11;
    }
    function_11ea4(v2, v8, v9, v11);
    // 0x52cdc
    return 0;
}

// Address range: 0x52d3c - 0x52d44
int32_t function_52d3c(void) {
    // 0x52d3c
    return 0;
}

// Address range: 0x52d44 - 0x52d68
int32_t function_52d44(void) {
    int32_t * v1 = pthread_getspecific(g167); // 0x52d54
    int32_t result = (int32_t)v1; // 0x52d54
    if (v1 == NULL) {
        return result;
    }
    // 0x52d60
    return function_5cfa8(result);
}

// Address range: 0x52d68 - 0x52dcc
int32_t function_52d68(void) {
    int32_t v1 = g168; // 0x52d74
    if (v1 != 0) {
        // 0x52d80
        function_55d5c(v1);
    }
    int32_t v2 = g170; // 0x52d84
    g168 = 0;
    g169 = 0;
    if (v2 != 0) {
        // 0x52d9c
        function_584a4(v2);
    }
    // 0x52da0
    g170 = 0;
    int32_t v3 = g461; // 0x52db0
    int32_t result = 0; // 0x52db8
    if (v3 != 0) {
        // 0x52dbc
        result = function_56e0c(v3);
    }
    // 0x52dc0
    g461 = 0;
    return result;
}

// Address range: 0x52dcc - 0x52f1c
int32_t function_52dcc(int32_t a1) {
    // 0x52dcc
    if (g171 == 0) {
        // 0x52dec
        if (function_12084((int32_t)&g167, 0x5cfa8) != 0) {
            // 0x52e68
            function_5df98(2, "src/zlog.c", 76, "pthread_key_create fail, rc[%d]");
            // 0x52e88
            function_52d68();
            // 0x52e60
            return -1;
        }
        // 0x52e04
        int32_t v1; // 0x52dcc
        if (function_60318(0x52d44, 0x5cfa8, v1) != 0) {
            // 0x52e94
            function_5df98(2, "src/zlog.c", 85, "atexit fail, rc[%d]");
            // 0x52e88
            function_52d68();
            // 0x52e60
            return -1;
        }
        g171 = 1;
    }
    int32_t v2 = function_56eb8(a1); // 0x52e24
    g461 = v2;
    if (v2 == 0) {
        // 0x52eb8
        function_5df98(2, "src/zlog.c", 93, "zlog_conf_new[%s] fail");
        // 0x52e88
        function_52d68();
        // 0x52e60
        return -1;
    }
    int32_t v3 = function_55db8(); // 0x52e3c
    g168 = v3;
    if (v3 == 0) {
        // 0x52edc
        function_5df98(2, "src/zlog.c", 99, "zlog_category_table_new fail");
        // 0x52e88
        function_52d68();
        // 0x52e60
        return -1;
    }
    int32_t v4 = function_58500(); // 0x52e4c
    g170 = v4;
    if (v4 != 0) {
        // 0x52e60
        return 0;
    }
    // 0x52efc
    function_5df98(2, "src/zlog.c", 105, "zlog_record_table_new fail");
    // 0x52e88
    function_52d68();
    // 0x52e60
    return -1;
}

// Address range: 0x52f1c - 0x530e8
int32_t function_52f1c(char * a1) {
    // 0x52f1c
    function_5df98(0, "src/zlog.c", 119, "------zlog_init start------");
    function_5df98(0, "src/zlog.c", 120, "------compile time[%s %s], version[%s]------");
    if (function_12048((int32_t)&g172) != 0) {
        // 0x530c0
        function_5df98(2, "src/zlog.c", 124, "pthread_rwlock_wrlock fail, rc[%d]");
        // 0x53008
        return -1;
    }
    // 0x52f9c
    if (g173 == 0) {
        // 0x52fa8
        if (function_52dcc((int32_t)a1) == 0) {
            // 0x53030
            g173 = 1;
            g171++;
            function_5df98(0, "src/zlog.c", 142, "------zlog_init success end------");
            int32_t v1 = pthread_rwlock_unlock(&g172); // 0x53060
            int32_t result = 0; // 0x53068
            if (v1 != 0) {
                // 0x5306c
                function_5df98(2, "src/zlog.c", 145, "pthread_rwlock_unlock fail, rc=[%d]");
                result = -1;
            }
            // 0x53008
            return result;
        }
        // 0x52fb8
        function_5df98(2, "src/zlog.c", 135, "zlog_init_inner[%s] fail");
    } else {
        // 0x53010
        function_5df98(2, "src/zlog.c", 129, "already init, use zlog_reload pls");
    }
    // 0x52fd8
    function_5df98(2, "src/zlog.c", 150, "------zlog_init fail end------");
    if (pthread_rwlock_unlock(&g172) == 0) {
        // 0x53008
        return -1;
    }
    // 0x53094
    function_5df98(2, "src/zlog.c", 153, "pthread_rwlock_unlock fail, rc=[%d]");
    return -1;
}

// Address range: 0x530f2 - 0x5317e
int32_t function_530f2(int32_t a1, int32_t a2, uint32_t a3, uint32_t a4) {
    // 0x530f2
    bool v1; // 0x530f2
    bool v2; // 0x530f2
    if (v2) {
        goto lab_dec_label_pc_0x530fa;
    } else {
        __asm_svcne(0x98e1a0);
        // .thread14
        v1 = true;
        if ((a1 & 32) == 0) {
            goto lab__thread18_3;
        } else {
            goto lab_dec_label_pc_unknown_60;
        }
    }
  lab_dec_label_pc_0x530fa:;
    int32_t v3; // 0x530f2
    int32_t v4 = v3 & 64 * v3; // 0x530fa
    int32_t v5 = a1 & 32;
    bool v6; // 0x530f2
    bool v7; // 0x530f2
    bool v8; // 0x530f2
    bool v9; // 0x530f2
    bool v10; // 0x530f2
    bool v11; // 0x530f2
    int32_t v12; // 0x530f2
    int32_t v13; // 0x530f2
    if (v4 == 0) {
        v1 = v5 != 0;
        if ((v3 & 8 || v3 & 0x4000000) == 0) {
            // .thread23
            v8 = v4 < 0;
            v11 = true;
            if ((a1 & 4) == 0) {
                // .thread38
                v13 = a1;
                v6 = v5 != 0;
                v7 = v5 != 0;
                v10 = false;
                v12 = a1;
                if (v4 < 0) {
                    goto lab__thread66;
                } else {
                    goto lab_dec_label_pc_unknown_62;
                }
            } else {
                goto lab_dec_label_pc_unknown_61;
            }
        } else {
            goto lab_dec_label_pc_unknown_60;
        }
    } else {
        v9 = v4 < 0;
        v1 = true;
        if (v5 != 0) {
            goto lab_dec_label_pc_unknown_60;
        } else {
            goto lab__thread18_3;
        }
    }
  lab_dec_label_pc_unknown_60:;
    int32_t v14 = a1 >> 6; // 0x53106
    uint32_t v15 = v14 + a3; // 0x53106
    int32_t v16 = v1; // 0x53106
    int32_t v17 = v15 + v16; // 0x53106
    int32_t v18 = v17 + v16; // 0x53106
    bool v19; // 0x530f2
    bool v20; // 0x530f2
    bool v21; // 0x530f2
    bool v22; // 0x530f2
    int32_t v23; // 0x530f2
    if (v17 == 0) {
        v8 = v17 < 0;
        v11 = true;
        v21 = ((v18 ^ a3) & (v18 ^ v14)) < 0;
        if ((a1 & 4) == 0) {
            // ..thread38_crit_edge
            v7 = (a1 & 32) != 0;
            v10 = false;
            v12 = a1;
            goto lab_dec_label_pc_unknown_62;
        } else {
            goto lab_dec_label_pc_unknown_61;
        }
    } else {
        v8 = v17 < 0;
        v11 = false;
        v21 = ((v18 ^ a3) & (v18 ^ v14)) < 0;
        v19 = v17 < 0;
        v22 = false;
        v20 = ((v18 ^ a3) & (v18 ^ v14)) < 0;
        v23 = a1;
        if (v17 < 0 ? v1 ? v17 <= a3 : v15 < a3 : (a1 & 64) != 0) {
            goto lab_dec_label_pc_unknown_61;
        } else {
            goto lab_0x53116;
        }
    }
  lab__thread18_3:
    // .thread18
    v8 = v9;
    v11 = false;
    v19 = v9;
    v22 = false;
    v23 = a1;
    if ((a1 & 64) != 0 == !v9) {
        goto lab_dec_label_pc_unknown_61;
    } else {
        goto lab_0x53116;
    }
  lab_dec_label_pc_unknown_61:
    v19 = v8;
    v22 = v11;
    v20 = v21;
    v23 = function_fe84bf9a();
    goto lab_0x53116;
  lab_0x53116:;
    // 0x53116
    bool v24; // 0x530f2
    bool v25; // 0x530f2
    if (v22 || v19 != v20) {
        v25 = v19;
        v24 = v19;
        if (v22) {
            goto lab_dec_label_pc_unknown_64;
        } else {
            goto lab_dec_label_pc_unknown_65;
        }
    } else {
        int32_t v26 = 0x400000 * v23; // 0x53116
        v25 = v3 - v26 < 0;
        v24 = v3 - v26 < 0;
        if (v3 == v26) {
            goto lab_dec_label_pc_unknown_64;
        } else {
            goto lab_dec_label_pc_unknown_65;
        }
    }
  lab__thread66:
    // .thread66
    __asm_cdpmi(3, 0, 14, 8, 10, 0);
    v7 = v6;
    v10 = true;
    v12 = v13;
    goto lab_dec_label_pc_unknown_62;
  lab_dec_label_pc_unknown_62:;
    int32_t v27 = v12; // 0x5314e
    bool v28 = v10; // 0x5314e
    bool v29 = true; // 0x5314e
    int32_t v30; // 0x530f2
    int32_t v31; // 0x530f2
    int32_t v32; // 0x530f2
    if ((v3 & 0x200000) != 0 == v7) {
        int32_t v33 = (v12 >> 6) + v3 + 1; // 0x5314e
        v30 = v33;
        v31 = v33;
        v32 = v12;
        goto lab_dec_label_pc_unknown_66;
    } else {
        goto lab_dec_label_pc_unknown_63;
    }
  lab_dec_label_pc_unknown_63:;
    int32_t v34 = v27; // 0x53156
    int32_t v35 = v27; // 0x53156
    bool v36 = v29; // 0x53156
    bool v37 = (v27 & 64) != 0 == v29; // 0x53156
    if (v28) {
        goto lab_dec_label_pc_unknown_67;
    } else {
        goto lab_dec_label_pc_unknown_68;
    }
  lab_dec_label_pc_unknown_64:;
    bool v38 = (v23 & 32) != 0;
    v13 = v23;
    v6 = v38;
    v7 = v38;
    v10 = false;
    v12 = v23;
    if (v24) {
        goto lab__thread66;
    } else {
        goto lab_dec_label_pc_unknown_62;
    }
  lab_dec_label_pc_unknown_65:;
    bool v39 = (v23 & 32) != 0;
    __asm_svcne(0x98e30b);
    bool v40 = false; // 0x53136
    if (v25) {
        __asm_cdpmi(3, 0, 14, 8, 10, 0);
        v40 = true;
    }
    v27 = v23;
    v28 = v40;
    v29 = false;
    int32_t v41; // 0x530f2
    bool v42; // 0x530f2
    int32_t v43; // 0x530f2
    if ((v3 & 0x200000) == 0) {
        goto lab_dec_label_pc_unknown_63;
    } else {
        uint32_t v44 = (v23 >> 6) + v3; // 0x5314e
        int32_t v45 = v44 + (int32_t)v39; // 0x5314e
        v30 = v45;
        v31 = v45;
        v32 = v23;
        v41 = v45;
        v43 = v23;
        v42 = v44 < v3;
        if (v39) {
            goto lab_dec_label_pc_unknown_66;
        } else {
            goto lab_dec_label_pc_unknown_69;
        }
    }
  lab_dec_label_pc_unknown_66:
    v41 = v31;
    v43 = v32;
    v42 = v30 <= v3;
    goto lab_dec_label_pc_unknown_69;
  lab_dec_label_pc_unknown_67:;
    uint32_t v57 = v34 / 128; // 0x53156
    bool v50 = v3 == v57; // 0x5315a
    int32_t v48 = v34; // 0x5315a
    bool v49 = v3 == v57; // 0x5315a
    if (v3 < v57) {
        goto lab_0x5315e;
    } else {
        goto lab_dec_label_pc_unknown_70;
    }
  lab_dec_label_pc_unknown_68:
    v50 = v36;
    v48 = v35;
    v49 = v36;
    if (v37) {
        goto lab_dec_label_pc_unknown_70;
    } else {
        goto lab_0x5315e;
    }
  lab_dec_label_pc_unknown_69:
    v34 = v43;
    v35 = v43;
    v36 = v41 == 0;
    v37 = v41 == 0 ? (v43 & 64) != 0 : v42;
    if (v41 < 0) {
        goto lab_dec_label_pc_unknown_67;
    } else {
        goto lab_dec_label_pc_unknown_68;
    }
  lab_0x5315e:;
    bool v46 = false; // 0x5315e
    int32_t v47 = v48; // 0x5315e
    if (v49) {
        goto lab_dec_label_pc_unknown_71;
    } else {
        goto lab__thread8_2;
    }
  lab_dec_label_pc_unknown_70:
    v46 = true;
    v47 = function_fe3cbe62();
    if (v50) {
        goto lab_dec_label_pc_unknown_71;
    } else {
        goto lab__thread8_2;
    }
  lab_dec_label_pc_unknown_71:;
    int32_t v51 = unknown_fee4bb7c(); // 0x53162
    int32_t v52 = v51; // 0x53166
    bool v53 = false; // 0x53166
    bool v54 = (v47 & 1024) != 0; // 0x53166
    if ((0x400000 * v47 & v3) == 0) {
        *(int32_t *)v51 = 0;
        *(int32_t *)(v51 + 4) = (int32_t)&g158;
        uint32_t v55 = v51 >> a4; // 0x5316a
        v52 = v51;
        v53 = v3 == v55;
        v54 = v3 >= v55;
    }
    goto lab__thread12_2;
  lab__thread8_2:
    // .thread8
    v52 = unknown_fee4bb7c();
    v53 = false;
    v54 = v46;
    goto lab__thread12_2;
  lab__thread12_2:;
    bool v56 = v54 ? v53 : v3 == 0x100000 * v52;
    return v56 ? v3 * v3 : v52;
}

// Address range: 0x5317e - 0x53180
int32_t function_5317e(void) {
    // 0x5317e
    int32_t result; // 0x5317e
    return result;
}

// Address range: 0x53180 - 0x532e8
int32_t function_53180(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x53180
    int32_t v1; // 0x53180
    if (function_52dcc(v1) == 0) {
        int32_t v2 = function_55f6c(*(int32_t *)(v1 + 4), v1, *(int32_t *)(g461 + 0x2448)); // 0x5324c
        *(int32_t *)(v1 + 8) = v2;
        if (v2 != 0) {
            int32_t * v3 = (int32_t *)(v1 + 16); // 0x5325c
            *v3 = *v3 + 1;
            *(int32_t *)(v1 + 52) = 1;
            function_5df98(0, "src/zlog.c", 194, "------dzlog_init success end------");
            int32_t result = 0; // 0x53298
            if (pthread_rwlock_unlock((int32_t *)(v1 + 20)) != 0) {
                // 0x5329c
                function_5df98(2, "src/zlog.c", 197, "pthread_rwlock_unlock fail, rc=[%d]");
                result = -1;
            }
            // 0x531dc
            return result;
        }
        // 0x532c4
        function_5df98(2, "src/zlog.c", 187, "zlog_category_table_fetch_category[%s] fail");
    } else {
        // 0x5318c
        function_5df98(2, "src/zlog.c", 178, "zlog_init_inner[%s] fail");
    }
    // 0x531ac
    function_5df98(2, "src/zlog.c", 202, "------dzlog_init fail end------");
    if (pthread_rwlock_unlock(&g172) == 0) {
        // 0x531dc
        return -1;
    }
    // 0x53204
    function_5df98(2, "src/zlog.c", 205, "pthread_rwlock_unlock fail, rc=[%d]");
    return -1;
}

// Address range: 0x532e8 - 0x53310
int32_t function_532e8(int32_t a1) {
    // 0x532e8
    function_5df98(2, "src/zlog.c", 168, "pthread_rwlock_wrlock fail, rc[%d]");
    return -1;
}

// Address range: 0x53314 - 0x53600
int32_t function_53314(int32_t a1) {
    // 0x53314
    function_5df98(0, "src/zlog.c", 219, "------zlog_reload start------");
    if (function_12048((int32_t)&g172) != 0) {
        // 0x535d8
        function_5df98(2, "src/zlog.c", 222, "pthread_rwlock_wrlock fail, rc[%d]");
        // 0x53450
        return -1;
    }
    // 0x53354
    int32_t v1; // 0x53468
    if (g173 == 0) {
        // 0x534d0
        function_5df98(2, "src/zlog.c", 227, "never call zlog_init() or dzlog_init() before");
        goto lab_0x5347c;
    } else {
        int32_t v2 = a1; // 0x5336c
        if (a1 == 0) {
            v2 = *(int32_t *)((int32_t)&g425 | 0xeec8);
        }
        v1 = v2;
        if (v2 == -1) {
            // 0x5345c
            v1 = g461;
            if (*(int32_t *)(v1 + 0x243c) < g174) {
                goto lab_0x53378;
            } else {
                goto lab_0x5347c;
            }
        } else {
            goto lab_0x53378;
        }
    }
  lab_0x5347c:
    // 0x5347c
    function_5df98(0, "src/zlog.c", 291, "------zlog_reload do nothing------");
    int32_t v3 = pthread_rwlock_unlock(&g172); // 0x5349c
    int32_t result = 0; // 0x534a4
    if (v3 != 0) {
        // 0x534a8
        function_5df98(2, "src/zlog.c", 294, "pthread_rwlock_unlock fail, rc=[%d]");
        result = -1;
    }
    // 0x53450
    return result;
  lab_0x53378:
    // 0x53378
    g174 = 0;
    int32_t v4 = function_56eb8(v1); // 0x53384
    if (v4 == 0) {
        // 0x53574
        function_5df98(2, "src/zlog.c", 250, "zlog_conf_new fail");
        function_5df98(1, "src/zlog.c", 280, "zlog_reload fail, use old conf file, still working");
    } else {
        int32_t * v5 = (int32_t *)(v4 + 0x2448); // 0x53394
        int32_t v6 = *v5; // 0x53394
        int32_t v7 = 0; // 0x533a0
        int32_t v8 = v6; // 0x533a0
        if (*(int32_t *)(v6 + 4) >= 1) {
            int32_t v9 = v7 + 1; // 0x533b0
            function_5bccc(*(int32_t *)(*(int32_t *)v6 + 4 * v7), g170);
            int32_t v10 = *v5; // 0x533b8
            v7 = v9;
            v8 = v10;
            while (*(int32_t *)(v10 + 4) > v9) {
                // 0x533a4
                v9 = v7 + 1;
                function_5bccc(*(int32_t *)(*(int32_t *)v10 + 4 * v7), g170);
                v10 = *v5;
                v7 = v9;
                v8 = v10;
            }
        }
        // 0x533c8
        if (function_55e24(g168, v8) == 0) {
            // 0x534f0
            g171++;
            function_55ebc(g168);
            function_56e0c(g461);
            g461 = v4;
            function_5df98(0, "src/zlog.c", 271, "------zlog_reload success, total init verison[%d] ------");
            int32_t v11 = pthread_rwlock_unlock(&g172); // 0x53540
            result = 0;
            if (v11 != 0) {
                // 0x5354c
                function_5df98(2, "src/zlog.c", 274, "pthread_rwlock_unlock fail, rc=[%d]");
                result = -1;
            }
            // 0x53450
            return result;
        }
        // 0x533d8
        function_5df98(2, "src/zlog.c", 260, "zlog_category_table_update fail");
        function_5df98(1, "src/zlog.c", 280, "zlog_reload fail, use old conf file, still working");
        function_56e0c(v4);
    }
    // 0x53418
    function_5df98(2, "src/zlog.c", 283, "------zlog_reload fail, total init version[%d] ------");
    if (pthread_rwlock_unlock(&g172) != 0) {
        // 0x535b0
        function_5df98(2, "src/zlog.c", 286, "pthread_rwlock_unlock fail, rc=[%d]");
    }
    // 0x53450
    return -1;
}

// Address range: 0x53604 - 0x536f0
int32_t function_53604(void) {
    // 0x53604
    function_5df98(0, "src/zlog.c", 304, "------zlog_fini start------");
    if (function_12048((int32_t)&g172) != 0) {
        // 0x536c8
        return function_5df98(2, "src/zlog.c", 307, "pthread_rwlock_wrlock fail, rc[%d]");
    }
    // 0x53640
    if (g173 == 0) {
        // 0x536a8
        function_5df98(2, "src/zlog.c", 312, "before finish, must zlog_init() or dzlog_init() fisrt");
    } else {
        // 0x5364c
        function_52d68();
        g173 = 0;
    }
    // 0x53654
    function_5df98(0, "src/zlog.c", 320, "------zlog_fini end------");
    int32_t v1 = pthread_rwlock_unlock(&g172); // 0x53674
    int32_t result = 0; // 0x5367c
    if (v1 != 0) {
        // 0x53680
        result = function_5df98(2, "src/zlog.c", 323, "pthread_rwlock_unlock fail, rc=[%d]");
    }
    // 0x536a0
    return result;
}

// Address range: 0x536f4 - 0x538c0
int32_t function_536f4(char * a1) {
    int32_t result = (int32_t)a1;
    if (a1 == NULL) {
        // 0x53874
        function_5df98(2, "src/zlog.c", 334, "cname is null or 0");
        // 0x537a0
        return result;
    }
    // 0x53704
    function_5df98(0, "src/zlog.c", 335, "------zlog_get_category[%s] start------");
    if (function_12048((int32_t)&g172) != 0) {
        // 0x5384c
        function_5df98(2, "src/zlog.c", 338, "pthread_rwlock_wrlock fail, rc[%d]");
        // 0x537a0
        return 0;
    }
    // 0x5373c
    if (g173 == 0) {
        // 0x537ac
        function_5df98(2, "src/zlog.c", 343, "never call zlog_init() or dzlog_init() before");
    } else {
        int32_t v1 = function_55f6c(g168, result, *(int32_t *)(g461 + 0x2448)); // 0x53764
        if (v1 != 0) {
            // 0x53770
            function_5df98(0, "src/zlog.c", 357, "------zlog_get_category[%s] success, end------ ");
            int32_t v2 = pthread_rwlock_unlock(&g172); // 0x53794
            int32_t result2 = v1; // 0x5379c
            if (v2 != 0) {
                // 0x53898
                function_5df98(2, "src/zlog.c", 360, "pthread_rwlock_unlock fail, rc=[%d]");
                result2 = 0;
            }
            // 0x537a0
            return result2;
        }
        // 0x53828
        function_5df98(2, "src/zlog.c", 353, "zlog_category_table_fetch_category[%s] fail");
    }
    // 0x537c8
    function_5df98(2, "src/zlog.c", 365, "------zlog_get_category[%s] fail, end------ ");
    if (pthread_rwlock_unlock(&g172) == 0) {
        // 0x537a0
        return 0;
    }
    // 0x537f8
    function_5df98(2, "src/zlog.c", 368, "pthread_rwlock_unlock fail, rc=[%d]");
    return 0;
}

// Address range: 0x538c4 - 0x53a90
int32_t function_538c4(int32_t a1) {
    if (a1 == 0) {
        // 0x53a44
        function_5df98(2, "src/zlog.c", 377, "cname is null or 0");
        // 0x539f0
        return -1;
    }
    // 0x538d4
    function_5df98(0, "src/zlog.c", 379, "------dzlog_set_category[%s] start------");
    if (function_12048((int32_t)&g172) != 0) {
        // 0x53a1c
        function_5df98(2, "src/zlog.c", 382, "pthread_rwlock_wrlock fail, rc[%d]");
        // 0x539f0
        return -1;
    }
    // 0x5390c
    if (g173 == 0) {
        // 0x53918
        function_5df98(2, "src/zlog.c", 387, "never call zlog_init() or dzlog_init() before");
    } else {
        int32_t v1 = function_55f6c(g168, a1, *(int32_t *)(g461 + 0x2448)); // 0x539b0
        g169 = v1;
        if (v1 != 0) {
            // 0x539c0
            function_5df98(0, "src/zlog.c", 400, "------dzlog_set_category[%s] end, success------ ");
            int32_t v2 = pthread_rwlock_unlock(&g172); // 0x539e4
            int32_t result = 0; // 0x539ec
            if (v2 != 0) {
                // 0x53a68
                function_5df98(2, "src/zlog.c", 403, "pthread_rwlock_unlock fail, rc=[%d]");
                result = -1;
            }
            // 0x539f0
            return result;
        }
        // 0x539f8
        function_5df98(2, "src/zlog.c", 396, "zlog_category_table_fetch_category[%s] fail");
    }
    // 0x53934
    function_5df98(2, "src/zlog.c", 408, "------dzlog_set_category[%s] end, fail------ ");
    if (pthread_rwlock_unlock(&g172) == 0) {
        // 0x539f0
        return -1;
    }
    // 0x53968
    function_5df98(2, "src/zlog.c", 411, "pthread_rwlock_unlock fail, rc=[%d]");
    return -1;
}

// Address range: 0x53a94 - 0x53d38
int32_t function_53a94(int32_t a1, int32_t a2) {
    if (a1 == 0) {
        // 0x53d14
        function_5df98(2, "src/zlog.c", 462, "key is null or 0");
        // 0x53b04
        return -1;
    }
    if (a2 == 0) {
        // 0x53cf0
        function_5df98(2, "src/zlog.c", 463, "value is null or 0");
        // 0x53b04
        return -1;
    }
    // 0x53ab0
    if (function_1206c((int32_t)&g172) != 0) {
        // 0x53cc8
        function_5df98(2, "src/zlog.c", 467, "pthread_rwlock_wrlock fail, rc[%d]");
        // 0x53b04
        return -1;
    }
    // 0x53ac8
    int32_t v1; // 0x53a94
    int32_t * value; // 0x53a94
    if (g173 == 0) {
        // 0x53ad4
        function_5df98(2, "src/zlog.c", 472, "never call zlog_init() or dzlog_init() before");
        goto lab_0x53af0;
    } else {
        int32_t * v2 = pthread_getspecific(g167); // 0x53b10
        if (v2 == NULL) {
            int32_t v3 = g461; // 0x53c44
            int32_t v4 = *(int32_t *)(v3 + 0x244c); // 0x53c50
            int32_t v5 = function_5d07c(g171, *(int32_t *)(v3 + 1052), *(int32_t *)(v3 + 1056), v4); // 0x53c58
            if (v5 == 0) {
                // 0x53ca8
                function_5df98(2, "src/zlog.c", 476, "zlog_thread_new fail");
                goto lab_0x53af0;
            } else {
                // 0x53c64
                value = (int32_t *)v5;
                v1 = v5;
                if (pthread_setspecific(g167, value) == 0) {
                    goto lab_0x53b20;
                } else {
                    // 0x53c7c
                    function_5cfa8(v5);
                    function_5df98(2, "src/zlog.c", 476, "pthread_setspecific fail, rd[%d]");
                    goto lab_0x53af0;
                }
            }
        } else {
            // 0x53b0c
            value = v2;
            v1 = (int32_t)v2;
            goto lab_0x53b20;
        }
    }
  lab_0x53af0:
    // 0x53af0
    if (pthread_rwlock_unlock(&g172) != 0) {
        // 0x53bb4
        function_5df98(2, "src/zlog.c", 492, "pthread_rwlock_unlock fail, rc=[%d]");
        return -1;
    }
    // 0x53b04
    return -1;
  lab_0x53b20:
    // 0x53b20
    if (*value == g171) {
        goto lab_0x53b74;
    } else {
        int32_t v6 = *(int32_t *)(g461 + 1052); // 0x53b40
        if (function_5d290(v1, v6, *(int32_t *)(g461 + 1056)) == 0) {
            // 0x53b50
            if (function_5d3b0(v1, *(int32_t *)(g461 + 0x244c)) == 0) {
                // 0x53b6c
                *value = g171;
                goto lab_0x53b74;
            } else {
                // 0x53be0
                function_5df98(2, "src/zlog.c", 476, "zlog_thread_resize_msg_buf fail, rd[%d]");
                goto lab_0x53af0;
            }
        } else {
            // 0x53be0
            function_5df98(2, "src/zlog.c", 476, "zlog_thread_resize_msg_buf fail, rd[%d]");
            goto lab_0x53af0;
        }
    }
  lab_0x53b74:
    // 0x53b74
    if (function_580c0(*(int32_t *)(v1 + 4), a1, a2) == 0) {
        int32_t v7 = pthread_rwlock_unlock(&g172); // 0x53c08
        int32_t result = 0; // 0x53c10
        if (v7 != 0) {
            // 0x53c14
            function_5df98(2, "src/zlog.c", 485, "pthread_rwlock_unlock fail, rc=[%d]");
            result = -1;
        }
        // 0x53b04
        return result;
    }
    // 0x53b8c
    function_5df98(2, "src/zlog.c", 479, "zlog_mdc_put fail, key[%s], value[%s]");
    goto lab_0x53af0;
}

// Address range: 0x53d3a - 0x53d3b
int32_t function_53d3a(void) {
    // 0x53d3a
    int32_t result; // 0x53d3a
    return result;
}

// Address range: 0x53d3c - 0x53ec4
int32_t function_53d3c(int32_t a1) {
    if (a1 == 0) {
        // 0x53e78
        function_5df98(2, "src/zlog.c", 504, "key is null or 0");
        // 0x53da4
        return 0;
    }
    // 0x53d4c
    if (function_1206c((int32_t)&g172) != 0) {
        // 0x53e50
        function_5df98(2, "src/zlog.c", 508, "pthread_rwlock_rdlock fail, rc[%d]");
        // 0x53da4
        return 0;
    }
    // 0x53d64
    if (g173 == 0) {
        // 0x53db0
        function_5df98(2, "src/zlog.c", 513, "never call zlog_init() or dzlog_init() before");
    } else {
        int32_t * v1 = pthread_getspecific(g167); // 0x53d74
        if (v1 == NULL) {
            // 0x53e0c
            function_5df98(2, "src/zlog.c", 519, "thread not found, maybe not use zlog_put_mdc before");
        } else {
            int32_t v2 = function_581b8(*(int32_t *)((int32_t)v1 + 4)); // 0x53d88
            if (v2 != 0) {
                int32_t v3 = pthread_rwlock_unlock(&g172); // 0x53d98
                int32_t result = v2; // 0x53da0
                if (v3 != 0) {
                    // 0x53e9c
                    function_5df98(2, "src/zlog.c", 531, "pthread_rwlock_unlock fail, rc=[%d]");
                    result = 0;
                }
                // 0x53da4
                return result;
            }
            // 0x53e2c
            function_5df98(2, "src/zlog.c", 525, "key[%s] not found in mdc");
        }
    }
    // 0x53dcc
    if (pthread_rwlock_unlock(&g172) == 0) {
        // 0x53da4
        return 0;
    }
    // 0x53ddc
    function_5df98(2, "src/zlog.c", 538, "pthread_rwlock_unlock fail, rc=[%d]");
    return 0;
}

// Address range: 0x53ec8 - 0x53fdc
int32_t function_53ec8(int32_t a1) {
    if (a1 == 0) {
        // 0x53f70
        return function_5df98(2, "src/zlog.c", 549, "key is null or 0");
    }
    // 0x53ed8
    if (function_1206c((int32_t)&g172) != 0) {
        // 0x53f94
        return function_5df98(2, "src/zlog.c", 553, "pthread_rwlock_rdlock fail, rc[%d]");
    }
    // 0x53ef0
    if (g173 == 0) {
        // 0x53efc
        function_5df98(2, "src/zlog.c", 558, "never call zlog_init() or dzlog_init() before");
    } else {
        int32_t * v1 = pthread_getspecific(g167); // 0x53f54
        if (v1 == NULL) {
            // 0x53fbc
            function_5df98(2, "src/zlog.c", 564, "thread not found, maybe not use zlog_put_mdc before");
        } else {
            // 0x53f60
            function_58238(*(int32_t *)((int32_t)v1 + 4));
        }
    }
    int32_t v2 = pthread_rwlock_unlock(&g172); // 0x53f1c
    int32_t result = 0; // 0x53f24
    if (v2 != 0) {
        // 0x53f28
        result = function_5df98(2, "src/zlog.c", 573, "pthread_rwlock_unlock fail, rc=[%d]");
    }
    // 0x53f48
    return result;
}

// Address range: 0x53fe0 - 0x540c4
int32_t function_53fe0(void) {
    // 0x53fe0
    if (function_1206c((int32_t)&g172) != 0) {
        // 0x5407c
        return function_5df98(2, "src/zlog.c", 586, "pthread_rwlock_rdlock fail, rc[%d]");
    }
    // 0x54000
    if (g173 == 0) {
        // 0x5405c
        function_5df98(2, "src/zlog.c", 591, "never call zlog_init() or dzlog_init() before");
    } else {
        int32_t * v1 = pthread_getspecific(g167); // 0x54010
        if (v1 == NULL) {
            // 0x540a4
            function_5df98(2, "src/zlog.c", 597, "thread not found, maybe not use zlog_put_mdc before");
        } else {
            // 0x5401c
            function_581b0(*(int32_t *)((int32_t)v1 + 4));
        }
    }
    int32_t v2 = pthread_rwlock_unlock(&g172); // 0x54028
    int32_t result = 0; // 0x54030
    if (v2 != 0) {
        // 0x54034
        result = function_5df98(2, "src/zlog.c", 606, "pthread_rwlock_unlock fail, rc=[%d]");
    }
    // 0x54054
    return result;
}

// Address range: 0x540c8 - 0x54140
int32_t function_540c8(int32_t a1, uint32_t a2) {
    int32_t v1 = a1 + 1032;
    memset((int32_t *)v1, 0, 32);
    int32_t v2 = a2 / 128; // 0x540fc
    int32_t v3 = -a2; // 0x54100
    char * v4 = (char *)(v2 + v1); // 0x54110
    *v4 = *v4 | -1 - (char)(255 << 8 - (v3 < 0 ? a2 % 8 : -((v3 % 8))));
    memset((int32_t *)(a1 + 1033 + v2), 255, 31 - v2);
    return 0;
}

// Address range: 0x54140 - 0x54338
int32_t function_54140(int32_t result, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, uint32_t a7, int32_t a8, int32_t a9) {
    int32_t v1 = -a7; // 0x5415c
    unsigned char v2 = *(char *)(result + 1032 + a7 / 128); // 0x54170
    if ((1 << 7 - (v1 < 0 ? a7 % 8 : -((v1 % 8))) & (int32_t)v2) == 0) {
        // 0x54190
        return result;
    }
    // 0x54198
    function_1206c((int32_t)&g172);
    if (g173 == 0) {
        // 0x542e8
        function_5df98(2, "src/zlog.c", 647, "never call zlog_init() or dzlog_init() before");
        // 0x54304
        return pthread_rwlock_unlock(&g172);
    }
    int32_t * v3 = pthread_getspecific(g167); // 0x541c4
    if (v3 == NULL) {
        // 0x54190
        return g171;
    }
    int32_t v4 = (int32_t)v3; // 0x541c4
    if (*v3 != g171) {
        int32_t v5 = g461; // 0x541ec
        if (function_5d290(v4, *(int32_t *)(v5 + 1052), *(int32_t *)(v5 + 1056)) != 0 || function_5d3b0(v4, *(int32_t *)(g461 + 0x244c)) != 0) {
            // 0x54314
            function_5df98(2, "src/zlog.c", 651, "zlog_thread_resize_msg_buf fail, rd[%d]");
            // 0x54304
            return pthread_rwlock_unlock(&g172);
        }
        // 0x54228
        *v3 = g171;
    }
    int32_t v6 = *(int32_t *)(v4 + 8); // 0x5423c
    function_57540(v6, result, *(int32_t *)(result + 1028), a2, a3, a4, a5, a6, a7, a8, a9);
    if (function_55c7c(result, v4) != 0) {
        function_5437c((int32_t)&g488);
    }
    uint32_t v7 = *(int32_t *)(g461 + 0x243c); // 0x5428c
    if (v7 == 0) {
        // 0x54304
        return pthread_rwlock_unlock(&g172);
    }
    int32_t v8 = g174 + 1; // 0x5429c
    g174 = v8;
    if (v7 >= v8) {
        // 0x54304
        return pthread_rwlock_unlock(&g172);
    }
    // 0x542ac
    pthread_rwlock_unlock(&g172);
    if (function_53314(-1) == 0) {
        // 0x54190
        return 0;
    }
    // 0x542c4
    return function_5df98(2, "src/zlog.c", 676, "reach reload-conf-period but zlog_reload fail, zlog-chk-conf [file] see detail");
}

// Address range: 0x5433a - 0x54348
int32_t function_5433a(int32_t a1) {
    bool v1 = true; // 0x5433a
    bool v2; // 0x5433a
    bool v3; // 0x5433a
    if (!v3) {
        int32_t v4; // 0x5433a
        uint32_t v5 = 64 * v4 + v4; // 0x5433a
        v2 = v5 == 0;
        v1 = v5 < v4;
    }
    int32_t v6 = a1; // 0x54342
    if (!((v2 ? v1 : (a1 & 32) != 0))) {
        v6 = function_10d996();
    }
    // 0x54346
    return function_5484c(v6);
}

// Address range: 0x54348 - 0x5437c
int32_t function_54348(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = *(int32_t *)(a2 + 1052); // 0x54350
    int32_t value = function_5d07c(a1, v1, *(int32_t *)(a2 + 1056), *(int32_t *)(a4 + 1100)); // 0x54354
    if (value == 0) {
        function_543a8();
    }
    // 0x54360
    int32_t key; // 0x54348
    int32_t v2 = pthread_setspecific(key, (int32_t *)value); // 0x54368
    if (v2 != 0) {
        function_543c8(v2, value, v2);
    }
    // 0x54374
    return *(int32_t *)(key + 16);
}

// Address range: 0x5437c - 0x543a8
int32_t function_5437c(int32_t a1) {
    // 0x5437c
    return function_5df98(2, "src/zlog.c", 659, "zlog_output fail, srcfile[%s], srcline[%ld]");
}

// Address range: 0x543a8 - 0x543c8
int32_t function_543a8(void) {
    // 0x543a8
    return function_5df98(2, "src/zlog.c", 651, "zlog_thread_new fail");
}

// Address range: 0x543c8 - 0x543fc
int32_t function_543c8(int32_t a1, int32_t a2, int32_t a3) {
    // 0x543c8
    int32_t v1; // 0x543c8
    function_5cfa8(v1);
    return function_5df98(2, "src/zlog.c", 651, "pthread_setspecific fail, rd[%d]");
}

// Address range: 0x54400 - 0x546bc
int32_t function_54400(int32_t result, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, uint32_t a7, int32_t a8, int32_t a9) {
    int32_t v1 = -a7; // 0x5441c
    unsigned char v2 = *(char *)(result + 1032 + a7 / 128); // 0x54430
    if ((1 << 7 - (v1 < 0 ? a7 % 8 : -((v1 % 8))) & (int32_t)v2) == 0) {
        // 0x54450
        return result;
    }
    // 0x54458
    function_1206c((int32_t)&g172);
    if (g173 == 0) {
        // 0x545a8
        function_5df98(2, "src/zlog.c", 694, "never call zlog_init() or dzlog_init() before");
        // 0x545c4
        return pthread_rwlock_unlock(&g172);
    }
    int32_t * v3 = pthread_getspecific(g167); // 0x54484
    int32_t * v4; // 0x54400
    int32_t v5; // 0x54400
    if (v3 == NULL) {
        int32_t v6 = g461; // 0x54600
        int32_t v7 = *(int32_t *)(v6 + 1056); // 0x54608
        int32_t v8 = function_5d07c(g171, *(int32_t *)(v6 + 1052), v7, *(int32_t *)(v6 + 0x244c)); // 0x54614
        if (v8 == 0) {
            // 0x54668
            function_5df98(2, "src/zlog.c", 698, "zlog_thread_new fail");
            // 0x545c4
            return pthread_rwlock_unlock(&g172);
        }
        int32_t * value = (int32_t *)v8;
        if (pthread_setspecific(g167, value) != 0) {
            // 0x54688
            function_5cfa8(v8);
            function_5df98(2, "src/zlog.c", 698, "pthread_setspecific fail, rd[%d]");
            // 0x545c4
            return pthread_rwlock_unlock(&g172);
        }
        // 0x54634
        v4 = value;
        v5 = v8;
    } else {
        // 0x54480
        v4 = v3;
        v5 = (int32_t)v3;
    }
    // 0x54494
    if (*v4 != g171) {
        int32_t v9 = *(int32_t *)(g461 + 1052); // 0x544b8
        if (function_5d290(v5, v9, *(int32_t *)(g461 + 1056)) != 0 || function_5d3b0(v5, *(int32_t *)(g461 + 0x244c)) != 0) {
            // 0x545d4
            function_5df98(2, "src/zlog.c", 698, "zlog_thread_resize_msg_buf fail, rd[%d]");
            // 0x545c4
            return pthread_rwlock_unlock(&g172);
        }
        // 0x544e8
        *v4 = g171;
    }
    int32_t v10 = *(int32_t *)(v5 + 8); // 0x544fc
    function_5759c(v10, result, *(int32_t *)(result + 1028), a2, a3, a4, a5, a6, a7, a8, a9);
    if (function_55c7c(result, v5) != 0) {
        // 0x5463c
        function_5df98(2, "src/zlog.c", 706, "zlog_output fail, srcfile[%s], srcline[%ld]");
        // 0x545c4
        return pthread_rwlock_unlock(&g172);
    }
    uint32_t v11 = *(int32_t *)(g461 + 0x243c); // 0x5454c
    if (v11 == 0) {
        // 0x545c4
        return pthread_rwlock_unlock(&g172);
    }
    int32_t v12 = g174 + 1; // 0x5455c
    g174 = v12;
    if (v11 >= v12) {
        // 0x545c4
        return pthread_rwlock_unlock(&g172);
    }
    // 0x5456c
    pthread_rwlock_unlock(&g172);
    if (function_53314(-1) == 0) {
        // 0x54450
        return 0;
    }
    // 0x54584
    return function_5df98(2, "src/zlog.c", 723, "reach reload-conf-period but zlog_reload fail, zlog-chk-conf [file] see detail");
}

// Address range: 0x546c0 - 0x5484c
int32_t function_546c0(int32_t result, int32_t a2, int32_t a3, int32_t a4, int32_t a5, uint32_t a6, int32_t a7, int32_t a8) {
    int32_t v1 = -a6; // 0x546e8
    unsigned char v2 = *(char *)(a6 / 128 + 1032 + g169); // 0x546fc
    if ((1 << 7 - (v1 < 0 ? a6 % 8 : -((v1 % 8))) & (int32_t)v2) == 0) {
        // 0x54718
        return result;
    }
    // 0x54720
    function_1206c((int32_t)&g172);
    if (g173 == 0) {
        function_548c8((int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488);
    }
    // 0x54744
    if (g169 == 0) {
        function_54878();
    }
    int32_t * v3 = pthread_getspecific(g167); // 0x54754
    int32_t v4 = g171; // 0x54760
    if (v3 == NULL) {
        v4 = function_548f4();
    }
    int32_t v5 = (int32_t)v3; // 0x54754
    if (*v3 != v4) {
        int32_t v6 = g461; // 0x5477c
        int32_t v7 = function_5d290(v5, *(int32_t *)(v6 + 1052), *(int32_t *)(v6 + 1056)); // 0x5478c
        if (v7 != 0) {
            function_548a4(v7);
        }
        int32_t v8 = function_5d3b0(v5, *(int32_t *)(g461 + 0x244c)); // 0x547ac
        if (v8 != 0) {
            function_548a4(v8);
        }
        // 0x547b8
        *v3 = g171;
    }
    int32_t v9 = *(int32_t *)(g169 + 1028); // 0x547d0
    function_57540(*(int32_t *)(v5 + 8), g169, v9, result, a2, a3, a4, a5, a6, a7, a8);
    if (function_55c7c(g169, v5) != 0) {
        function_54938();
    }
    uint32_t v10 = *(int32_t *)(g461 + 0x243c); // 0x5481c
    if (v10 == 0) {
        function_54894((int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488);
    }
    int32_t v11 = g174 + 1; // 0x5482c
    g174 = v11;
    if (v10 >= v11) {
        function_54894((int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488);
    }
    // 0x5483c
    pthread_rwlock_unlock(&g172);
    return function_53314(-1);
}

// Address range: 0x5484c - 0x54850
int32_t function_5484c(int32_t result) {
    // 0x5484c
    return result;
}

// Address range: 0x54850 - 0x54878
int32_t function_54850(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9) {
    // 0x54850
    return function_5df98(2, "src/zlog.c", 778, "reach reload-conf-period but zlog_reload fail, zlog-chk-conf [file] see detail");
}

// Address range: 0x54878 - 0x54894
int32_t function_54878(void) {
    // 0x54878
    return function_5df98(2, "src/zlog.c", 749, "zlog_default_category is null,dzlog_init() or dzlog_set_cateogry() is not called above");
}

// Address range: 0x54894 - 0x548a4
int32_t function_54894(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9) {
    // 0x54894
    return pthread_rwlock_unlock(&g172);
}

// Address range: 0x548a4 - 0x548c8
int32_t function_548a4(int32_t a1) {
    // 0x548a4
    function_5df98(2, "src/zlog.c", 753, "zlog_thread_resize_msg_buf fail, rd[%d]");
    int32_t result = function_54894((int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488); // 0x548c4
    return result;
}

// Address range: 0x548c8 - 0x548f4
int32_t function_548c8(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9) {
    // 0x548c8
    function_5df98(2, "src/zlog.c", 742, "never call zlog_init() or dzlog_init() before");
    return pthread_rwlock_unlock(&g172);
}

// Address range: 0x548f4 - 0x54938
int32_t function_548f4(void) {
    int32_t v1 = *(int32_t *)(g461 + 0x244c); // 0x54908
    int32_t v2 = *(int32_t *)(g461 + 1052); // 0x5490c
    int32_t key; // 0x548f4
    int32_t value = function_5d07c(key, v2, *(int32_t *)(g461 + 1056), v1); // 0x54910
    if (value == 0) {
        function_54960();
    }
    int32_t v3 = pthread_setspecific(key, (int32_t *)value); // 0x54924
    if (v3 != 0) {
        function_54980(v3, value, v3);
    }
    // 0x54930
    return *(int32_t *)(key + 16);
}

// Address range: 0x54938 - 0x54960
int32_t function_54938(void) {
    // 0x54938
    function_5df98(2, "src/zlog.c", 761, "zlog_output fail, srcfile[%s], srcline[%ld]");
    int32_t result = function_54894((int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488); // 0x5495c
    return result;
}

// Address range: 0x54960 - 0x54980
int32_t function_54960(void) {
    // 0x54960
    function_5df98(2, "src/zlog.c", 753, "zlog_thread_new fail");
    int32_t result = function_54894((int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488); // 0x5497c
    return result;
}

// Address range: 0x54980 - 0x549b4
int32_t function_54980(int32_t a1, int32_t a2, int32_t a3) {
    // 0x54980
    int32_t v1; // 0x54980
    function_5cfa8(v1);
    function_5df98(2, "src/zlog.c", 753, "pthread_setspecific fail, rd[%d]");
    int32_t result = function_54894((int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488, (int32_t)&g488); // 0x549b0
    return result;
}

// Address range: 0x549b8 - 0x54cac
int32_t function_549b8(int32_t result, int32_t a2, int32_t a3, int32_t a4, int32_t a5, uint32_t a6, int32_t a7, int32_t a8) {
    int32_t v1 = -a6; // 0x549e0
    unsigned char v2 = *(char *)(a6 / 128 + 1032 + g169); // 0x549f4
    if ((1 << 7 - (v1 < 0 ? a6 % 8 : -((v1 % 8))) & (int32_t)v2) == 0) {
        // 0x54a10
        return result;
    }
    // 0x54a18
    function_1206c((int32_t)&g172);
    if (g173 == 0) {
        // 0x54bc0
        function_5df98(2, "src/zlog.c", 795, "never call zlog_init() or dzlog_init() before");
        return pthread_rwlock_unlock(&g172);
    }
    // 0x54a3c
    if (g169 == 0) {
        // 0x54b70
        function_5df98(2, "src/zlog.c", 802, "zlog_default_category is null,dzlog_init() or dzlog_set_cateogry() is not called above");
        // 0x54b8c
        return pthread_rwlock_unlock(&g172);
    }
    int32_t * v3 = pthread_getspecific(g167); // 0x54a4c
    int32_t * v4; // 0x549b8
    int32_t v5; // 0x549b8
    if (v3 == NULL) {
        int32_t v6 = g461; // 0x54bf4
        int32_t v7 = *(int32_t *)(v6 + 1052); // 0x54c04
        int32_t v8 = function_5d07c(g171, v7, *(int32_t *)(v6 + 1056), *(int32_t *)(v6 + 0x244c)); // 0x54c08
        if (v8 == 0) {
            // 0x54c58
            function_5df98(2, "src/zlog.c", 806, "zlog_thread_new fail");
            // 0x54b8c
            return pthread_rwlock_unlock(&g172);
        }
        int32_t * value = (int32_t *)v8;
        if (pthread_setspecific(g167, value) != 0) {
            // 0x54c78
            function_5cfa8(v8);
            function_5df98(2, "src/zlog.c", 806, "pthread_setspecific fail, rd[%d]");
            // 0x54b8c
            return pthread_rwlock_unlock(&g172);
        }
        // 0x54c28
        v4 = value;
        v5 = v8;
    } else {
        // 0x54a48
        v4 = v3;
        v5 = (int32_t)v3;
    }
    // 0x54a5c
    if (*v4 != g171) {
        int32_t v9 = *(int32_t *)(g461 + 1052); // 0x54a80
        if (function_5d290(v5, v9, *(int32_t *)(g461 + 1056)) != 0 || function_5d3b0(v5, *(int32_t *)(g461 + 0x244c)) != 0) {
            // 0x54b9c
            function_5df98(2, "src/zlog.c", 806, "zlog_thread_resize_msg_buf fail, rd[%d]");
            // 0x54b8c
            return pthread_rwlock_unlock(&g172);
        }
        // 0x54ab0
        *v4 = g171;
    }
    int32_t v10 = g169; // 0x54ab8
    int32_t v11 = *(int32_t *)(v5 + 8); // 0x54ac4
    function_5759c(v11, v10, *(int32_t *)(v10 + 1028), result, a2, a3, a4, a5, a6, a7, a8);
    if (function_55c7c(g169, v5) != 0) {
        // 0x54c30
        function_5df98(2, "src/zlog.c", 814, "zlog_output fail, srcfile[%s], srcline[%ld]");
        // 0x54b8c
        return pthread_rwlock_unlock(&g172);
    }
    uint32_t v12 = *(int32_t *)(g461 + 0x243c); // 0x54b14
    if (v12 == 0) {
        // 0x54b8c
        return pthread_rwlock_unlock(&g172);
    }
    int32_t v13 = g174 + 1; // 0x54b24
    g174 = v13;
    if (v12 >= v13) {
        // 0x54b8c
        return pthread_rwlock_unlock(&g172);
    }
    // 0x54b34
    pthread_rwlock_unlock(&g172);
    if (function_53314(-1) == 0) {
        // 0x54a10
        return 0;
    }
    // 0x54b4c
    return function_5df98(2, "src/zlog.c", 831, "reach reload-conf-period but zlog_reload fail, zlog-chk-conf [file] see detail");
}

// Address range: 0x54cb0 - 0x54f54
int32_t function_54cb0(int32_t result, char * a2, int32_t a3, char * a4, int32_t a5, int32_t a6, uint32_t a7, int32_t a8) {
    if (result != 0) {
        int32_t v1 = -a7; // 0x54cd0
        unsigned char v2 = *(char *)(result + 1032 + a7 / 128); // 0x54ce0
        if ((1 << 7 - (v1 < 0 ? a7 % 8 : -((v1 % 8))) & (int32_t)v2) == 0) {
            // 0x54d44
            return result;
        }
    }
    // 0x54cf8
    function_1206c((int32_t)&g172);
    if (g173 == 0) {
        // 0x54d20
        function_5df98(2, "src/zlog.c", 850, "never call zlog_init() or dzlog_init() before");
        // 0x54d44
        return pthread_rwlock_unlock(&g172);
    }
    int32_t * v3 = pthread_getspecific(g167); // 0x54d50
    int32_t * v4; // 0x54cb0
    int32_t v5; // 0x54cb0
    if (v3 == NULL) {
        int32_t v6 = g461; // 0x54ea0
        int32_t v7 = *(int32_t *)(v6 + 1056); // 0x54ea8
        int32_t v8 = function_5d07c(g171, *(int32_t *)(v6 + 1052), v7, *(int32_t *)(v6 + 0x244c)); // 0x54eb4
        if (v8 == 0) {
            // 0x54f08
            function_5df98(2, "src/zlog.c", 854, "zlog_thread_new fail");
            // 0x54d44
            return pthread_rwlock_unlock(&g172);
        }
        int32_t * value = (int32_t *)v8;
        if (pthread_setspecific(g167, value) != 0) {
            // 0x54f28
            function_5cfa8(v8);
            function_5df98(2, "src/zlog.c", 854, "pthread_setspecific fail, rd[%d]");
            // 0x54d44
            return pthread_rwlock_unlock(&g172);
        }
        // 0x54ed4
        v4 = value;
        v5 = v8;
    } else {
        // 0x54d4c
        v4 = v3;
        v5 = (int32_t)v3;
    }
    // 0x54d60
    if (*v4 != g171) {
        int32_t v9 = *(int32_t *)(g461 + 1052); // 0x54d80
        if (function_5d290(v5, v9, *(int32_t *)(g461 + 1056)) != 0 || function_5d3b0(v5, *(int32_t *)(g461 + 0x244c)) != 0) {
            // 0x54e74
            function_5df98(2, "src/zlog.c", 854, "zlog_thread_resize_msg_buf fail, rd[%d]");
            // 0x54d44
            return pthread_rwlock_unlock(&g172);
        }
        // 0x54dac
        *v4 = g171;
    }
    int32_t v10 = *(int32_t *)(result + 1028); // 0x54dbc
    int32_t v11 = *(int32_t *)(v5 + 8); // 0x54dc4
    int32_t v12; // bp+16, 0x54cb0
    function_57540(v11, result, v10, (int32_t)a2, a3, (int32_t)a4, a5, a6, a7, a8, (int32_t)&v12);
    if (function_55c7c(result, v5) != 0) {
        // 0x54edc
        function_5df98(2, "src/zlog.c", 861, "zlog_output fail, srcfile[%s], srcline[%ld]");
        // 0x54d44
        return pthread_rwlock_unlock(&g172);
    }
    uint32_t v13 = *(int32_t *)(g461 + 0x243c); // 0x54e1c
    if (v13 == 0) {
        // 0x54d44
        return pthread_rwlock_unlock(&g172);
    }
    int32_t v14 = g174 + 1; // 0x54e2c
    g174 = v14;
    if (v13 >= v14) {
        // 0x54d44
        return pthread_rwlock_unlock(&g172);
    }
    // 0x54e3c
    pthread_rwlock_unlock(&g172);
    int32_t result2 = 0; // 0x54e50
    if (function_53314(-1) != 0) {
        // 0x54e54
        result2 = function_5df98(2, "src/zlog.c", 880, "reach reload-conf-period but zlog_reload fail, zlog-chk-conf [file] see detail");
    }
    // 0x54d44
    return result2;
}

// Address range: 0x54f58 - 0x550ec
int32_t function_54f58(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, uint32_t a6, int32_t a7) {
    // 0x54f58
    function_1206c((int32_t)&g172);
    if (g173 == 0) {
        function_550f8();
    }
    // 0x54f90
    if (g169 == 0) {
        function_5513c();
    }
    int32_t v1 = -a6; // 0x54fa8
    unsigned char v2 = *(char *)(a6 / 128 + 1032 + g169); // 0x54fb8
    if ((1 << 7 - (v1 < 0 ? a6 % 8 : -((v1 % 8))) & (int32_t)v2) == 0) {
        // 0x54fd0
        return pthread_rwlock_unlock(&g172);
    }
    int32_t * v3 = pthread_getspecific(g167); // 0x54fe4
    int32_t v4 = g171; // 0x54ff0
    if (v3 == NULL) {
        v4 = function_5515c();
    }
    int32_t v5 = (int32_t)v3; // 0x54fe4
    if (*v3 != v4) {
        int32_t v6 = g461; // 0x5500c
        int32_t v7 = function_5d290(v5, *(int32_t *)(v6 + 1052), *(int32_t *)(v6 + 1056)); // 0x55018
        if (v7 != 0) {
            function_55118(v7);
        }
        int32_t v8 = function_5d3b0(v5, *(int32_t *)(g461 + 0x244c)); // 0x55034
        if (v8 != 0) {
            function_55118(v8);
        }
        // 0x55040
        *v3 = g171;
    }
    int32_t v9 = *(int32_t *)(g169 + 1028); // 0x55058
    int32_t v10 = *(int32_t *)(v5 + 8); // 0x5505c
    int32_t v11; // bp+12, 0x54f58
    function_57540(v10, g169, v9, a1, a2, a3, a4, a5, a6, a7, (int32_t)&v11);
    if (function_55c7c(g169, v5) != 0) {
        function_551a0((int32_t)&g488);
    }
    uint32_t v12 = *(int32_t *)(g461 + 0x243c); // 0x550a0
    if (v12 == 0) {
        // 0x54fd0
        return pthread_rwlock_unlock(&g172);
    }
    int32_t v13 = g174 + 1; // 0x550b0
    g174 = v13;
    if (v12 >= v13) {
        // 0x54fd0
        return pthread_rwlock_unlock(&g172);
    }
    // 0x550c0
    pthread_rwlock_unlock(&g172);
    return function_53314(-1);
}

// Address range: 0x550ee - 0x550f0
int32_t function_550ee(void) {
    // 0x550ee
    int32_t result; // 0x550ee
    return result;
}

// Address range: 0x550f0 - 0x550f8
int32_t function_550f0(void) {
    // 0x550f0
    int32_t v1; // 0x550f0
    return function_5df98(v1, (char *)v1, v1, (char *)v1);
}

// Address range: 0x550f8 - 0x55118
int32_t function_550f8(void) {
    // 0x550f8
    return function_5df98(2, "src/zlog.c", 896, "never call zlog_init() or dzlog_init() before");
}

// Address range: 0x55118 - 0x5513c
int32_t function_55118(int32_t a1) {
    // 0x55118
    return function_5df98(2, "src/zlog.c", 909, "zlog_thread_resize_msg_buf fail, rd[%d]");
}

// Address range: 0x5513c - 0x5515c
int32_t function_5513c(void) {
    // 0x5513c
    return function_5df98(2, "src/zlog.c", 903, "zlog_default_category is null,dzlog_init() or dzlog_set_cateogry() is not called above");
}

// Address range: 0x5515c - 0x551a0
int32_t function_5515c(void) {
    int32_t v1 = *(int32_t *)(g461 + 0x244c); // 0x55170
    int32_t v2 = *(int32_t *)(g461 + 1052); // 0x55174
    int32_t key; // 0x5515c
    int32_t value = function_5d07c(key, v2, *(int32_t *)(g461 + 1056), v1); // 0x55178
    if (value == 0) {
        function_551cc();
    }
    // 0x55184
    if (pthread_setspecific(key, (int32_t *)value) != 0) {
        function_551ec();
    }
    // 0x55198
    return *(int32_t *)(key + 16);
}

// Address range: 0x551a0 - 0x551cc
int32_t function_551a0(int32_t a1) {
    // 0x551a0
    return function_5df98(2, "src/zlog.c", 918, "zlog_output fail, srcfile[%s], srcline[%ld]");
}

// Address range: 0x551cc - 0x551ec
int32_t function_551cc(void) {
    // 0x551cc
    return function_5df98(2, "src/zlog.c", 909, "zlog_thread_new fail");
}

// Address range: 0x551ec - 0x55218
int32_t function_551ec(void) {
    // 0x551ec
    int32_t v1; // 0x551ec
    function_5cfa8(v1);
    return function_5df98(2, "src/zlog.c", 909, "pthread_setspecific fail, rd[%d]");
}

// Address range: 0x5521c - 0x55384
int32_t function_5521c(void) {
    // 0x5521c
    if (function_1206c((int32_t)&g172) != 0) {
        // 0x55334
        return function_5df98(2, "src/zlog.c", 948, "pthread_rwlock_wrlock fail, rc[%d]");
    }
    // 0x5523c
    function_5df98(1, "src/zlog.c", 951, "------zlog_profile start------ ");
    function_5df98(1, "src/zlog.c", 952, "is init:[%d]");
    function_5df98(1, "src/zlog.c", 953, "init version:[%d]");
    function_56b38(g461, 1);
    function_58414(g170, 1);
    function_55ccc(g168, 1);
    if (g169 != 0) {
        // 0x552d8
        function_5df98(1, "src/zlog.c", 958, "-default_category-");
        function_557c4(g169, 1);
    }
    // 0x55300
    function_5df98(1, "src/zlog.c", 961, "------zlog_profile end------ ");
    if (pthread_rwlock_unlock(&g172) == 0) {
        // 0x5532c
        return 0;
    }
    // 0x5535c
    return function_5df98(2, "src/zlog.c", 964, "pthread_rwlock_unlock fail, rc=[%d]");
}

// Address range: 0x55388 - 0x55564
int32_t function_55388(int32_t a1, int32_t a2) {
    if (a1 == 0) {
        // 0x55540
        function_5df98(2, "src/zlog.c", 978, "rname is null or 0");
        // 0x553f4
        return -1;
    }
    if (a2 == 0) {
        // 0x5551c
        function_5df98(2, "src/zlog.c", 979, "record_output is null or 0");
        // 0x553f4
        return -1;
    }
    // 0x553a4
    if (function_12048((int32_t)&g172) != 0) {
        // 0x554cc
        function_5df98(2, "src/zlog.c", 983, "pthread_rwlock_rdlock fail, rd[%d]");
        // 0x553f4
        return -1;
    }
    // 0x553bc
    int32_t v1; // 0x55388
    if (g173 == 0) {
        // 0x553c8
        function_5df98(2, "src/zlog.c", 988, "never call zlog_init() or dzlog_init() before");
        v1 = 0;
    } else {
        int32_t v2 = function_58304(a1, a2); // 0x55408
        if (v2 == 0) {
            // 0x55480
            function_5df98(2, "src/zlog.c", 995, "zlog_record_new fail");
            v1 = -1;
        } else {
            int32_t v3 = function_5dac0(g170, v2, v2); // 0x55420
            if (v3 == 0) {
                int32_t v4 = *(int32_t *)(g461 + 0x2448); // 0x5543c
                v1 = 0;
                int32_t v5 = 0; // 0x55448
                if (*(int32_t *)(v4 + 4) >= 1) {
                    int32_t v6 = v5 + 1; // 0x5545c
                    function_5bccc(*(int32_t *)(*(int32_t *)v4 + 4 * v5), g170);
                    int32_t v7 = *(int32_t *)(g461 + 0x2448); // 0x5546c
                    v1 = 0;
                    v5 = v6;
                    while (*(int32_t *)(v7 + 4) > v6) {
                        // 0x55450
                        v6 = v5 + 1;
                        function_5bccc(*(int32_t *)(*(int32_t *)v7 + 4 * v5), g170);
                        v7 = *(int32_t *)(g461 + 0x2448);
                        v1 = 0;
                        v5 = v6;
                    }
                }
            } else {
                // 0x554a4
                function_582a0(v2);
                function_5df98(2, "src/zlog.c", 1002, "zc_hashtable_put fail");
                v1 = v3;
            }
        }
    }
    int32_t v8 = pthread_rwlock_unlock(&g172); // 0x553e8
    int32_t result = v1; // 0x553f0
    if (v8 != 0) {
        // 0x554f4
        function_5df98(2, "src/zlog.c", 1013, "pthread_rwlock_unlock fail, rd=[%d]");
        result = -1;
    }
    // 0x553f4
    return result;
}

// Address range: 0x55568 - 0x555a4
int32_t function_55568(int32_t a1, uint32_t a2) {
    if (a1 == 0) {
        return 0;
    }
    int32_t v1 = -a2; // 0x55584
    unsigned char v2 = *(char *)(a1 + 1032 + a2 / 128); // 0x5558c
    return ((int32_t)v2 >> 7 - (v1 < 0 ? a2 % 8 : -((v1 % 8)))) % 2;
}

// Address range: 0x555a4 - 0x555b0
int32_t function_555a4(void) {
    // 0x555a4
    return (int32_t)"1.2.12";
}

// Address range: 0x555b0 - 0x557c4
int32_t function_555b0(int32_t a1, int32_t a2, int32_t a3) {
    int32_t * v1 = (int32_t *)(a1 + 1096); // 0x555b8
    int32_t v2 = *v1; // 0x555b8
    if (v2 != 0) {
        // 0x555d0
        function_5d580(v2);
    }
    // 0x555d4
    memset((int32_t *)(a1 + 1032), 0, 32);
    int32_t v3 = function_5d4c0(0); // 0x555ec
    *v1 = v3;
    if (v3 == 0) {
        // 0x557a0
        function_5df98(2, "src/category.c", 72, "zc_arraylist_new fail");
        // 0x556ac
        return -1;
    }
    int32_t v4 = a1 + 1031;
    int32_t v5 = a1 + 1062;
    int32_t v6 = 0;
    int32_t v7 = 0; // 0x55624
    int32_t v8 = 0;
    int32_t v9 = *(int32_t *)(4 * v7); // 0x55648
    int32_t v10 = function_5bbe8(v9, a1); // 0x55650
    int32_t v11 = a1; // 0x55658
    int32_t v12 = v8; // 0x55658
    int32_t v13; // 0x555b0
    int32_t v14; // 0x55680
    char * v15; // 0x55680
    int32_t v16; // 0x55684
    unsigned char v17; // 0x555b0
    if (v10 != 0) {
        // 0x5565c
        if (function_5d694(*v1, v9) != 0) {
            // 0x55724
            function_5df98(2, "src/category.c", 81, "zc_arrylist_add fail");
            goto lab_0x55740;
        }
        // 0x55670
        v16 = v9 + 0x1007;
        v13 = v4;
        v14 = v13 + 1;
        v15 = (char *)v14;
        v16++;
        v17 = *(char *)v16 | *v15;
        *v15 = v17;
        while (v13 != v5) {
            // 0x55680
            v13 = v14;
            v14 = v13 + 1;
            v15 = (char *)v14;
            v16++;
            v17 = *(char *)v16 | *v15;
            *v15 = v17;
        }
        // 0x55698
        v11 = v17;
        v12 = v8 + 1;
    }
    int32_t v18 = v12;
    v7++;
    v6 = function_5bb9c(v9) == 0 ? v6 : v9;
    while (v7 < 32) {
        // 0x55640
        v8 = v18;
        v9 = *(int32_t *)(4 * v7 + v11);
        v10 = function_5bbe8(v9, a1);
        v11 = a1;
        v12 = v8;
        if (v10 != 0) {
            // 0x5565c
            if (function_5d694(*v1, v9) != 0) {
                // 0x55724
                function_5df98(2, "src/category.c", 81, "zc_arrylist_add fail");
                goto lab_0x55740;
            }
            // 0x55670
            v16 = v9 + 0x1007;
            v13 = v4;
            v14 = v13 + 1;
            v15 = (char *)v14;
            v16++;
            v17 = *(char *)v16 | *v15;
            *v15 = v17;
            while (v13 != v5) {
                // 0x55680
                v13 = v14;
                v14 = v13 + 1;
                v15 = (char *)v14;
                v16++;
                v17 = *(char *)v16 | *v15;
                *v15 = v17;
            }
            // 0x55698
            v11 = v17;
            v12 = v8 + 1;
        }
        // 0x55620
        v18 = v12;
        v7++;
        v6 = function_5bb9c(v9) == 0 ? v6 : v9;
    }
    // 0x556a0
    if (v18 != 0) {
        // 0x556ac
        return 0;
    }
    if (v6 == 0) {
        // 0x5575c
        function_5df98(0, "src/category.c", 103, "category[%s], no match rules & no wastebin_rule");
        // 0x556ac
        return 0;
    }
    // 0x556bc
    function_5df98(0, "src/category.c", 95, "category[%s], no match rules, use wastebin_rule");
    if (function_5d694(*v1, v6) != 0) {
        // 0x55780
        function_5df98(2, "src/category.c", 97, "zc_arrylist_add fail");
      lab_0x55740:
        // 0x55740
        function_5d580(*v1);
        *v1 = 0;
        return -1;
    }
    int32_t v19 = v6 + 0x1007; // 0x55704
    int32_t v20 = v4;
    int32_t v21 = v20 + 1; // 0x55708
    char * v22 = (char *)v21; // 0x55708
    v19++;
    *v22 = *(char *)v19 | *v22;
    while (v5 != v20) {
        // 0x55708
        v20 = v21;
        v21 = v20 + 1;
        v22 = (char *)v21;
        v19++;
        *v22 = *(char *)v19 | *v22;
    }
    // 0x556ac
    return 0;
}

// Address range: 0x557c4 - 0x55870
int32_t function_557c4(int32_t a1, int32_t a2) {
    if (a1 == 0) {
        // 0x5584c
        return function_5df98(2, "src/category.c", 22, "a_category is null or 0");
    }
    int32_t result = function_5df98(a2, "src/category.c", 26, "--category[%p][%s][%p]--"); // 0x55800
    int32_t * v1 = (int32_t *)(a1 + 1096); // 0x55804
    int32_t v2 = *v1; // 0x55804
    if (v2 == 0) {
        // 0x55844
        return result;
    }
    // 0x55810
    if (*(int32_t *)(v2 + 4) < 1) {
        // 0x55844
        return result;
    }
    int32_t v3 = 0;
    int32_t v4 = v3 + 1; // 0x5582c
    int32_t result2 = function_5a850(*(int32_t *)(*(int32_t *)v2 + 4 * v3), a2); // 0x55830
    int32_t v5 = *v1; // 0x55834
    while (*(int32_t *)(v5 + 4) > v4) {
        // 0x55820
        v3 = v4;
        v4 = v3 + 1;
        result2 = function_5a850(*(int32_t *)(*(int32_t *)v5 + 4 * v3), a2);
        v5 = *v1;
    }
    // 0x55844
    return result2;
}

// Address range: 0x55870 - 0x558e4
int32_t function_55870(int32_t a1) {
    if (a1 == 0) {
        // 0x558c0
        return function_5df98(2, "src/category.c", 38, "a_category is null or 0");
    }
    int32_t v1 = *(int32_t *)(a1 + 1096); // 0x55880
    if (v1 != 0) {
        // 0x5588c
        function_5d580(v1);
    }
    // 0x55890
    function_5df98(0, "src/category.c", 40, "zlog_category_del[%p]");
    return free(a1, (int32_t)"src/category.c", 40, (int32_t)"zlog_category_del[%p]");
}

// Address range: 0x558e4 - 0x55a28
int32_t function_558e4(int32_t str, int32_t a2) {
    // 0x558e4
    if (str == 0) {
        // 0x559e0
        function_5df98(2, "src/category.c", 119, "name is null or 0");
        // 0x55954
        return 0;
    }
    if (a2 == 0) {
        // 0x55a04
        function_5df98(2, "src/category.c", 120, "rules is null or 0");
        // 0x55954
        return 0;
    }
    uint32_t len = strlen((char *)str); // 0x55900
    if (len >= 1024 == (len != 1024)) {
        // 0x55960
        function_5df98(2, "src/category.c", 124, "name[%s] too long");
        // 0x55954
        return 0;
    }
    // 0x55910
    int32_t v1; // 0x558e4
    int32_t v2 = function_11eb0(1, 1104, v1, v1); // 0x55918
    if (v2 == 0) {
        // 0x559b4
        __errno_location();
        function_5df98(2, "src/category.c", 129, "calloc fail, errno[%d]");
        // 0x55954
        return 0;
    }
    // 0x55924
    function_11fc4((int32_t *)v2, str, (char)len + 1, v1);
    *(int32_t *)(v2 + 1028) = len;
    int32_t result; // 0x558e4
    if (function_555b0(v2, a2, a2 + 4) == 0) {
        // 0x5594c
        function_557c4(v2, 0);
        result = v2;
    } else {
        // 0x55988
        function_5df98(2, "src/category.c", 135, "zlog_category_fit_rules fail");
        function_55870(v2);
        result = 0;
    }
    // 0x55954
    return result;
}

// Address range: 0x55a28 - 0x55b28
int32_t function_55a28(int32_t a1, int32_t a2) {
    if (a1 == 0) {
        // 0x55b04
        function_5df98(2, "src/category.c", 150, "a_category is null or 0");
        return -1;
    }
    if (a2 == 0) {
        // 0x55ae0
        function_5df98(2, "src/category.c", 151, "new_rules is null or 0");
        return -1;
    }
    int32_t * v1 = (int32_t *)(a1 + 1100); // 0x55a40
    int32_t v2 = *v1; // 0x55a40
    if (v2 != 0) {
        // 0x55a4c
        function_5d580(v2);
    }
    int32_t * v3 = (int32_t *)(a1 + 1096); // 0x55a68
    *(int32_t *)(a1 + 1064) = *(int32_t *)(a1 + 1032);
    *(int32_t *)(a1 + 1068) = *(int32_t *)(a1 + 1036);
    *(int32_t *)(a1 + 1072) = *(int32_t *)(a1 + 1040);
    *(int32_t *)(a1 + 1076) = *(int32_t *)(a1 + 1044);
    *v1 = *v3;
    *(int32_t *)(a1 + 1080) = *(int32_t *)(a1 + 1048);
    *v3 = 0;
    *(int32_t *)(a1 + 1084) = *(int32_t *)(a1 + 1052);
    *(int32_t *)(a1 + 1088) = *(int32_t *)(a1 + 1056);
    *(int32_t *)(a1 + 1092) = *(int32_t *)(a1 + 1060);
    if (function_555b0(a1, a2, a2 + 4) == 0) {
        return 0;
    }
    // 0x55ab8
    function_5df98(2, "src/category.c", 163, "zlog_category_obtain_rules fail");
    *v3 = 0;
    return -1;
}

// Address range: 0x55b28 - 0x55ba0
int32_t function_55b28(int32_t a1) {
    if (a1 == 0) {
        // 0x55b80
        return function_5df98(2, "src/category.c", 176, "a_category is null or 0");
    }
    int32_t * v1 = (int32_t *)(a1 + 1100); // 0x55b34
    int32_t v2 = *v1; // 0x55b34
    if (v2 == 0) {
        // 0x55b60
        return function_5df98(1, "src/category.c", 178, "a_category->fit_rules_backup is NULL, never update before");
    }
    // 0x55b40
    function_5d580(v2);
    *v1 = 0;
    return (int32_t)memset((int32_t *)(a1 + 1064), 0, 32);
}

// Address range: 0x55ba0 - 0x55c7c
int32_t function_55ba0(int32_t a1) {
    if (a1 == 0) {
        // 0x55c3c
        return function_5df98(2, "src/category.c", 194, "a_category is null or 0");
    }
    int32_t * v1 = (int32_t *)(a1 + 1100); // 0x55bac
    int32_t v2 = *v1; // 0x55bac
    if (v2 == 0) {
        // 0x55c5c
        return function_5df98(1, "src/category.c", 196, "a_category->fit_rules_backup in NULL, never update before");
    }
    int32_t * v3 = (int32_t *)(a1 + 1096); // 0x55bb8
    int32_t v4 = *v3; // 0x55bb8
    if (v4 == 0) {
        // .critedge
        *v3 = v2;
        *v1 = 0;
    } else {
        // 0x55bcc
        function_5d580(v4);
        *v1 = 0;
        *v3 = *v1;
    }
    int32_t * v5 = (int32_t *)(a1 + 1064); // 0x55bec
    *(int32_t *)(a1 + 1032) = *v5;
    *(int32_t *)(a1 + 1036) = *(int32_t *)(a1 + 1068);
    *(int32_t *)(a1 + 1040) = *(int32_t *)(a1 + 1072);
    *(int32_t *)(a1 + 1044) = *(int32_t *)(a1 + 1076);
    *(int32_t *)(a1 + 1048) = *(int32_t *)(a1 + 1080);
    *(int32_t *)(a1 + 1052) = *(int32_t *)(a1 + 1084);
    *(int32_t *)(a1 + 1056) = *(int32_t *)(a1 + 1088);
    *(int32_t *)(a1 + 1060) = *(int32_t *)(a1 + 1092);
    return (int32_t)memset(v5, 0, 32);
}

// Address range: 0x55c7c - 0x55ccc
int32_t function_55c7c(int32_t a1, int32_t a2) {
    int32_t * v1 = (int32_t *)(a1 + 1096); // 0x55c7c
    int32_t v2 = *v1; // 0x55c7c
    if (*(int32_t *)(v2 + 4) < 1) {
        // 0x55cc0
        return 0;
    }
    int32_t v3 = 0;
    int32_t v4 = v3 + 1; // 0x55ca8
    int32_t result = function_5babc(*(int32_t *)(*(int32_t *)v2 + 4 * v3), a2); // 0x55cac
    int32_t v5 = *v1; // 0x55cb0
    while (*(int32_t *)(v5 + 4) > v4) {
        // 0x55c9c
        v3 = v4;
        v4 = v3 + 1;
        result = function_5babc(*(int32_t *)(*(int32_t *)v5 + 4 * v3), a2);
        v5 = *v1;
    }
    // 0x55cc0
    return result;
}

// Address range: 0x55ccc - 0x55d5c
int32_t function_55ccc(int32_t a1, int32_t a2) {
    if (a1 == 0) {
        // 0x55d38
        return function_5df98(2, "src/category_table.c", 21, "categories is null or 0");
    }
    // 0x55cdc
    function_5df98(a2, "src/category_table.c", 22, "-category_table[%p]-");
    int32_t v1 = function_5de60(a1); // 0x55d04
    if (v1 == 0) {
        // 0x55d30
        return 0;
    }
    int32_t v2 = v1; // 0x55d0c
    function_557c4(*(int32_t *)(v2 + 8), a2);
    v2 = function_5dea8(a1, v2);
    while (v2 != 0) {
        // 0x55d10
        function_557c4(*(int32_t *)(v2 + 8), a2);
        v2 = function_5dea8(a1, v2);
    }
    // 0x55d30
    return 0;
}

// Address range: 0x55d5c - 0x55db8
int32_t function_55d5c(int32_t a1) {
    if (a1 == 0) {
        // 0x55d9c
        return function_5df98(2, "src/category_table.c", 34, "categories is null or 0");
    }
    // 0x55d64
    function_5d890(a1);
    return function_5df98(0, "src/category_table.c", 36, "zlog_category_table_del[%p]");
}

// Address range: 0x55db8 - 0x55e24
int32_t function_55db8(void) {
    int32_t result = function_5d7b8(20, 0x5df18, 0x5df44, 0, 0x55870); // 0x55de4
    if (result == 0) {
        // 0x55e04
        function_5df98(2, "src/category_table.c", 49, "zc_hashtable_new fail");
    } else {
        // 0x55df0
        function_55ccc(result, 0);
    }
    // 0x55df8
    return result;
}

// Address range: 0x55e24 - 0x55ebc
int32_t function_55e24(int32_t a1, int32_t a2) {
    if (a1 == 0) {
        // 0x55e98
        function_5df98(2, "src/category_table.c", 62, "categories is null or 0");
        return -1;
    }
    int32_t v1 = function_5de60(a1); // 0x55e34
    if (v1 == 0) {
        // 0x55e90
        return 0;
    }
    int32_t v2 = v1; // 0x55e3c
    while (function_55a28(*(int32_t *)(v2 + 8), a2) == 0) {
        // 0x55e44
        v2 = function_5dea8(a1, v2);
        if (v2 == 0) {
            // 0x55e90
            return 0;
        }
    }
    // 0x55e6c
    function_5df98(2, "src/category_table.c", 66, "zlog_category_update_rules fail, try rollback");
    return -1;
}

// Address range: 0x55ebc - 0x55f14
int32_t function_55ebc(int32_t a1) {
    if (a1 == 0) {
        // 0x55ef4
        return function_5df98(2, "src/category_table.c", 78, "categories is null or 0");
    }
    int32_t v1 = function_5de60(a1); // 0x55ec8
    if (v1 == 0) {
        // 0x55ef0
        return 0;
    }
    int32_t v2 = v1; // 0x55ed0
    function_55b28(*(int32_t *)(v2 + 8));
    v2 = function_5dea8(a1, v2);
    while (v2 != 0) {
        // 0x55ed4
        function_55b28(*(int32_t *)(v2 + 8));
        v2 = function_5dea8(a1, v2);
    }
    // 0x55ef0
    return 0;
}

// Address range: 0x55f14 - 0x55f6c
int32_t function_55f14(int32_t a1) {
    if (a1 == 0) {
        // 0x55f4c
        return function_5df98(2, "src/category_table.c", 91, "categories is null or 0");
    }
    int32_t v1 = function_5de60(a1); // 0x55f20
    if (v1 == 0) {
        // 0x55f48
        return 0;
    }
    int32_t v2 = v1; // 0x55f28
    function_55ba0(*(int32_t *)(v2 + 8));
    v2 = function_5dea8(a1, v2);
    while (v2 != 0) {
        // 0x55f2c
        function_55ba0(*(int32_t *)(v2 + 8));
        v2 = function_5dea8(a1, v2);
    }
    // 0x55f48
    return 0;
}

// Address range: 0x55f6c - 0x56030
int32_t function_55f6c(int32_t a1, int32_t a2, int32_t a3) {
    if (a1 == 0) {
        // 0x55fec
        function_5df98(2, "src/category_table.c", 105, "categories is null or 0");
        // 0x55f8c
        return 0;
    }
    int32_t result = function_5da58(a1, a2); // 0x55f80
    if (result != 0) {
        // 0x55f8c
        return result;
    }
    int32_t v1 = function_558e4(a2, a3); // 0x55f9c
    if (v1 == 0) {
        // 0x56010
        function_5df98(2, "src/category_table.c", 114, "zc_category_new fail");
        // 0x55f8c
        return 0;
    }
    int32_t v2 = function_5dac0(a1, v1, v1); // 0x55fb4
    int32_t result2 = v1; // 0x55fc0
    if (v2 != 0) {
        // 0x55fc4
        function_5df98(2, "src/category_table.c", 119, "zc_hashtable_put fail");
        function_55870(v1);
        result2 = 0;
    }
    // 0x55f8c
    return result2;
}

// Address range: 0x56030 - 0x56b38
int32_t function_56030(int32_t a1) {
    char * str5 = (char *)a1; // 0x5604c
    int32_t v1; // bp-24744, 0x56030
    if (__lxstat64(3, str5, (struct stat64 *)&v1) != 0) {
        // 0x56998
        __errno_location();
        function_5df98(2, "src/conf.c", 238, "lstat conf file[%s] fail, errno[%d]");
        // 0x56304
        return -1;
    }
    // 0x5605c
    int32_t v2; // bp-24664, 0x56030
    int32_t tm; // bp-24788, 0x56030
    function_120a8(&v2, &tm);
    strftime((char *)(a1 + 1025), 21, "%F %T", (struct tm *)&tm);
    struct _IO_FILE * file = fopen64(str5, "r"); // 0x56090
    if (file == NULL) {
        // 0x56a3c
        function_5df98(2, "src/conf.c", 245, "open configure file[%s] fail");
        // 0x56304
        return -1;
    }
    int32_t v3 = (int32_t)file; // 0x56090
    int32_t str2; // bp-24640, 0x56030
    memset(&str2, 0, 0x1001);
    if (function_11f88(&str2, 0x1001, v3) == 0) {
        // 0x562fc
        fclose(file);
        // 0x56304
        return 0;
    }
    int32_t v4 = &str2; // 0x560a0
    int32_t v5 = a1 + 0x244c; // 0x560cc
    int32_t v6; // bp-20540, 0x56030
    int32_t v7 = &v6;
    int32_t * v8 = (int32_t *)(a1 + 0x2438);
    int32_t * v9 = (int32_t *)(a1 + 0x2430);
    int32_t * v10 = (int32_t *)(a1 + 0x2444);
    int32_t * v11 = (int32_t *)(a1 + 0x2440);
    int32_t * v12 = (int32_t *)(a1 + 1048);
    int32_t v13 = v4;
    int32_t v14 = 0;
    int32_t v15 = 0; // 0x56030
    int32_t v16; // 0x56030
    int32_t v17; // 0x56030
    int32_t v18; // 0x56030
    while (true) {
      lab_0x560f4:
        // 0x560f4
        v18 = v15;
        int32_t v19 = v14;
        int32_t v20 = v13;
        char * str = (char *)v20;
        int32_t v21 = v20 - 1;
        char * v22 = (char *)(strlen(str) + v21); // 0x56104
        if (*v22 == 10) {
            *v22 = 0;
        }
        char v23 = *str; // 0x56114
        v15 = v18;
        v16 = v19;
        v17 = v20;
        if (v23 == 0) {
            goto lab_0x560d8;
        } else {
            int32_t v24 = (int32_t)*__ctype_b_loc(); // 0x56128
            unsigned char v25 = v23;
            int32_t v26 = v20;
            while ((*(int16_t *)(2 * (int32_t)v25 + v24) & 0x2000) != 0) {
                int32_t v27 = v26 + 1; // 0x56130
                char v28 = *(char *)v27; // 0x56130
                v15 = v18;
                v16 = v19;
                v17 = v20;
                if (v28 == 0) {
                    goto lab_0x560d8;
                }
                v25 = v28;
                v26 = v27;
            }
            // 0x5614c
            v15 = v18;
            v16 = v19;
            v17 = v20;
            if (v25 == 35) {
                goto lab_0x560d8;
            } else {
                char v29 = *(char *)v26; // 0x56154
                int32_t v30 = v21; // 0x56160
                char v31 = v29; // 0x56160
                int32_t v32 = v26; // 0x56160
                char * v33 = str; // 0x56160
                if (v29 != 0) {
                    int32_t v34 = v30 + 1; // 0x56168
                    *(char *)v34 = v31;
                    int32_t v35 = 1; // 0x5616c
                    int32_t v36 = v32 + 1; // 0x56170
                    char v37 = *(char *)v36; // 0x56170
                    v30 = v34;
                    v32 = v36;
                    int32_t v38 = v35; // 0x56178
                    while (v37 != 0) {
                        // 0x56168
                        v34 = v30 + 1;
                        *(char *)v34 = v37;
                        v35 = v38 + 1;
                        v36 = v32 + 1;
                        v37 = *(char *)v36;
                        v30 = v34;
                        v32 = v36;
                        v38 = v35;
                    }
                    // 0x5617c
                    v33 = (char *)(v35 + v20);
                }
                // 0x56180
                *v33 = 0;
                int32_t v39 = strlen(str) + v21;
                unsigned char v40 = *(char *)v39; // 0x561a4
                int32_t v41 = v39 - 1; // 0x561a4
                while ((*(int16_t *)(2 * (int32_t)v40 + v24) & 0x2000) != 0) {
                    // 0x561a0
                    v39 = v41;
                    v40 = *(char *)v39;
                    v41 = v39 - 1;
                }
                if (v40 != 92 || v39 - v4 > 4066) {
                    int32_t v42 = str2 % 256; // 0x5620c
                    *(char *)(v39 + 1) = 0;
                    int32_t v43 = v42; // 0x5621c
                    if (v42 == 0) {
                        uint32_t len = strlen((char *)&str2); // 0x568cc
                        if (len != 0x1000 && len >= 0x1000) {
                            // 0x568d8
                            function_5df98(2, "src/conf.c", 346, "line_len[%ld] > MAXLEN_CFG_LINE[%ld], may cause overflow");
                            goto lab_0x562b0_4;
                        }
                        goto lab_0x56270;
                    } else {
                        int32_t v44 = v4;
                        int32_t v45 = v43 == 34;
                        while (v43 == 35 != (v45 == 0)) {
                            int32_t v46 = v44 + 1; // 0x56228
                            unsigned char v47 = *(char *)v46; // 0x56228
                            int32_t v48 = v45; // 0x56230
                            int32_t v49 = v46; // 0x56230
                            v43 = v47;
                            if (v47 == 0) {
                                goto lab_0x56254;
                            }
                            v44 = v49;
                            v45 = v48 ^ (int32_t)(v43 == 34);
                        }
                        // 0x56250
                        *(char *)v44 = 0;
                      lab_0x56254:;
                        uint32_t len2 = strlen((char *)&str2); // 0x56258
                        if (len2 >= 0x1000 == (len2 != 0x1000)) {
                            // 0x568d8
                            function_5df98(2, "src/conf.c", 346, "line_len[%ld] > MAXLEN_CFG_LINE[%ld], may cause overflow");
                            goto lab_0x562b0_4;
                        }
                        // 0x56264
                        if (str2 % 256 == 91) {
                            // 0x56510
                            sscanf2(v4, "[ %[^] \t]", &v6, 91);
                            if (function_11eec(v7, "global", v7, 91) == 0) {
                                // 0x56638
                                v15 = 1;
                                v16 = 0;
                                v17 = v4;
                                if (v18 != 0) {
                                    // 0x56a9c
                                    function_5df98(2, "src/conf.c", 368, "wrong sequence of section, must follow global->levels->formats->rules");
                                    goto lab_0x562b0_4;
                                }
                            } else {
                                // 0x56544
                                if (function_11eec(v7, "levels", v7, 91) == 0) {
                                    // 0x56900
                                    v15 = 2;
                                    v16 = 0;
                                    v17 = v4;
                                    if (v18 > 1) {
                                        // 0x56a9c
                                        function_5df98(2, "src/conf.c", 368, "wrong sequence of section, must follow global->levels->formats->rules");
                                        goto lab_0x562b0_4;
                                    }
                                } else {
                                    // 0x56560
                                    if (function_11eec(v7, "formats", v7, 91) == 0) {
                                        // 0x56918
                                        v15 = 3;
                                        v16 = 0;
                                        v17 = v4;
                                        if (v18 > 2) {
                                            // 0x56a9c
                                            function_5df98(2, "src/conf.c", 368, "wrong sequence of section, must follow global->levels->formats->rules");
                                            goto lab_0x562b0_4;
                                        }
                                    } else {
                                        // 0x5657c
                                        if (function_11eec(v7, "rules", v7, 91) != 0) {
                                            // 0x56abc
                                            function_5df98(2, "src/conf.c", 363, "wrong section name[%s]");
                                            goto lab_0x562b0_4;
                                        }
                                        if (v18 == 4) {
                                            // 0x56a9c
                                            function_5df98(2, "src/conf.c", 368, "wrong sequence of section, must follow global->levels->formats->rules");
                                            goto lab_0x562b0_4;
                                        }
                                        uint32_t v50 = *(int32_t *)(a1 + 0x243c); // 0x565a8
                                        if (v50 != 0) {
                                            uint32_t v51 = *v8; // 0x565b4
                                            if (v50 >= v51 != v50 != v51) {
                                                // 0x565c0
                                                function_5df98(1, "src/conf.c", 382, "fsync_period[%ld] >= reload_conf_period[%ld],set fsync_period to zero");
                                                *v8 = 0;
                                            }
                                        }
                                        int32_t v52 = function_58834(a1 + 1060); // 0x565e8
                                        *(int32_t *)(a1 + 0x1428) = v52;
                                        if (v52 == 0) {
                                            // 0x56a7c
                                            function_5df98(2, "src/conf.c", 391, "zlog_rotater_new fail");
                                            goto lab_0x562b0_4;
                                        }
                                        int32_t v53 = function_576e4((int32_t *)(a1 + 0x142c), v5); // 0x56608
                                        *v9 = v53;
                                        v15 = 4;
                                        v16 = 0;
                                        v17 = v4;
                                        if (v53 == 0) {
                                            // 0x56618
                                            function_5df98(2, "src/conf.c", 398, "zlog_format_new fail");
                                            goto lab_0x562b0_4;
                                        }
                                    }
                                }
                            }
                            goto lab_0x560d8;
                        } else {
                            goto lab_0x56270;
                        }
                    }
                } else {
                    int32_t v54 = v41; // 0x561e0
                    int32_t v55 = v41; // 0x561e0
                    if ((*(int16_t *)(2 * (int32_t)*(char *)v41 + v24) & 0x2000) != 0) {
                        int32_t v56 = v54 - 1; // 0x561e4
                        v54 = v56;
                        v55 = v56;
                        while ((*(int16_t *)(2 * (int32_t)*(char *)v56 + v24) & 0x2000) != 0) {
                            // 0x561e4
                            v56 = v54 - 1;
                            v54 = v56;
                            v55 = v56;
                        }
                    }
                    int32_t v57 = v55 + 1; // 0x561f8
                    *(char *)v57 = 0;
                    v15 = v18;
                    v16 = v57 - v4;
                    v17 = v57;
                    goto lab_0x560d8;
                }
            }
        }
    }
  lab_0x562fc:
    // 0x562fc
    fclose(file);
    // 0x56304
    return 0;
  lab_0x560d8:
    // 0x560d8
    v13 = v17;
    v14 = v16;
    if (function_11f88((int32_t *)v13, 0x1001 - v14, v3) == 0) {
        // break -> 0x562fc
        goto lab_0x562fc;
    }
    goto lab_0x560f4;
  lab_0x562b0_4:
    // 0x562b0
    function_5df98(2, "src/conf.c", 314, "parse configure file[%s]line_no[%ld] fail");
    function_5df98(2, "src/conf.c", 315, "line[%s]");
    // 0x562fc
    fclose(file);
    // 0x56304
    return -1;
  lab_0x56270:
    // 0x56270
    g494 = v18 - 1;
    int32_t v58; // bp-12340, 0x56030
    int32_t v59; // bp-24792, 0x56030
    int32_t str3; // bp-4140, 0x56030
    int32_t v60; // 0x56030
    int32_t v61; // 0x56030
    int32_t v62; // 0x56030
    int32_t v63; // 0x56030
    switch (v18) {
        case 1: {
            // 0x563f4
            memset(&v6, 0, 0x1001);
            memset(&str3, 0, 0x1001);
            int32_t v64 = sscanf2(v4, " %[^=]= %s ", &v6, v60); // 0x56438
            if (v64 != 2) {
                // 0x56a18
                function_5df98(2, "src/conf.c", 412, "sscanf [%s] fail, name or value is null");
                goto lab_0x562b0_4;
            }
            // 0x56444
            int32_t v65; // bp-16440, 0x56030
            memset(&v65, 0, 0x1001);
            memset(&v58, 0, 0x1001);
            int32_t v66; // bp-8240, 0x56030
            memset(&v66, 0, 0x1001);
            v59 = 0;
            sscanf2(v7, "%s%n%s%s", &v65, v61);
            if (function_11eec(v62, "strict", v62, v61) == 0) {
                // 0x564c8
                if (function_11eec(v63, "init", v62, v61) == 0) {
                    int32_t v67 = strcasecmp((char *)&str3, "false"); // 0x564f0
                    if (v67 == 0) {
                        char * env_val = getenv("ZLOG_STRICT_INIT"); // 0x569fc
                        if (env_val == NULL) {
                            int32_t v68 = (int32_t)env_val; // 0x569fc
                            *v12 = v68;
                            v15 = 1;
                            v16 = v68;
                            v17 = v4;
                            goto lab_0x560d8;
                        } else {
                            goto lab_0x564fc;
                        }
                    } else {
                        goto lab_0x564fc;
                    }
                } else {
                    goto lab_0x56658;
                }
            } else {
                goto lab_0x56658;
            }
        }
        case 2: {
            int32_t v69 = function_57b80(*v11, &str2); // 0x563b4
            v15 = 2;
            v16 = 0;
            v17 = v4;
            if (v69 != 0) {
                // 0x563c0
                function_5df98(2, "src/conf.c", 460, "zlog_level_list_set fail");
                v15 = 2;
                v16 = 0;
                v17 = v4;
                if (*v12 != 0) {
                    goto lab_0x562b0_4;
                }
            }
            goto lab_0x560d8;
        }
        case 3: {
            int32_t v70 = function_576e4(&str2, v5); // 0x56378
            if (v70 == 0) {
                // 0x566c0
                function_5df98(2, "src/conf.c", 467, "zlog_format_new fail [%s]");
                v15 = 3;
                v16 = 0;
                v17 = v4;
                if (*v12 != 0) {
                    goto lab_0x562b0_4;
                }
            } else {
                // 0x56384
                v15 = 3;
                v16 = 0;
                v17 = v4;
                if (function_5d694(*v10, v70) != 0) {
                    // 0x56b10
                    function_5766c(v70);
                    function_5df98(2, "src/conf.c", 473, "zc_arraylist_add fail");
                    goto lab_0x562b0_4;
                }
            }
            goto lab_0x560d8;
        }
        case 4: {
            int32_t v71 = *(int32_t *)(a1 + 0x2434); // 0x56328
            int32_t v72 = function_5aa9c(&str2, *v11, *v9, *v10, v71, *v8, v5); // 0x5633c
            if (v72 == 0) {
                // 0x566f0
                function_5df98(2, "src/conf.c", 487, "zlog_rule_new fail [%s]");
                v15 = 4;
                v16 = 0;
                v17 = v4;
                if (*v12 != 0) {
                    goto lab_0x562b0_4;
                }
            } else {
                // 0x56348
                v15 = 4;
                v16 = 0;
                v17 = v4;
                if (function_5d694(*(int32_t *)(a1 + 0x2448), v72) != 0) {
                    // 0x56ae8
                    function_5a97c(v72);
                    function_5df98(2, "src/conf.c", 493, "zc_arraylist_add fail");
                    goto lab_0x562b0_4;
                }
            }
            goto lab_0x560d8;
        }
        default: {
            // 0x56294
            function_5df98(2, "src/conf.c", 498, "not in any section");
            goto lab_0x562b0_4;
        }
    }
  lab_0x56658:;
    int32_t v73 = function_11eec(v62, "buffer", v62, v61); // 0x56664
    int32_t v74 = v61; // 0x5666c
    if (v73 == 0) {
        uint32_t v75 = v58; // 0x56670
        int32_t v76 = v75 % 256; // 0x56670
        v74 = v76;
        if (v76 == 109) {
            // 0x5667c
            int32_t v77; // 0x56030
            v74 = v77;
            char v78; // 0x56030
            unsigned char v79; // 0x56030
            int32_t v80; // 0x56030
            unsigned char v81; // 0x56030
            switch (v81) {
                case 105: {
                    // 0x56930
                    v74 = v80;
                    if (v78 == 0 == v79 == 110) {
                        int32_t v82 = function_5e140(&str3); // 0x56954
                        int32_t * v83; // 0x56030
                        *v83 = v82;
                        v15 = 1;
                        v16 = 0;
                        v17 = v4;
                        goto lab_0x560d8;
                    } else {
                        goto lab_0x5671c;
                    }
                }
                case 97: {
                    // 0x56690
                    v74 = v80;
                    if (v78 == 0 == v79 == 120) {
                        int32_t v84 = function_5e140(&str3); // 0x566b4
                        int32_t * v85; // 0x56030
                        *v85 = v84;
                        v15 = 1;
                        v16 = 0;
                        v17 = v4;
                        goto lab_0x560d8;
                    } else {
                        goto lab_0x5671c;
                    }
                }
                default: {
                    goto lab_0x5671c;
                }
            }
        } else {
            goto lab_0x5671c;
        }
    } else {
        goto lab_0x5671c;
    }
  lab_0x5671c:;
    int32_t v86 = v74;
    if (function_11eec(v62, "file", v62, v86) == 0) {
        // 0x56734
        if (function_11eec(v63, "perms", v62, v86) == 0) {
            // 0x569d0
            int32_t * v87; // 0x56030
            sscanf2(v60, "%o", v87, v86);
            v15 = 1;
            v16 = 0;
            v17 = v4;
            goto lab_0x560d8;
        } else {
            goto lab_0x5674c;
        }
    } else {
        goto lab_0x5674c;
    }
  lab_0x564fc:
    // 0x564fc
    *v12 = 1;
    v15 = 1;
    v16 = 0;
    v17 = v4;
    goto lab_0x560d8;
  lab_0x5674c:;
    // 0x5674c
    int32_t v88; // 0x56030
    if (function_11eec(v62, "rotate", v62, v86) == 0) {
        // 0x56764
        if (function_11eec(v63, "lock", v62, v86) == 0) {
            // 0x5677c
            if (function_11eec(v88, "file", v62, v86) == 0) {
                // 0x56794
                char * str4; // 0x56030
                if (function_11eec(v60, "self", v62, v86) == 0) {
                    // 0x567b8
                    strcpy(str4, str5);
                    v15 = 1;
                    v16 = 0;
                    v17 = v4;
                } else {
                    // 0x56a68
                    strcpy(str4, (char *)&str3);
                    v15 = 1;
                    v16 = 0;
                    v17 = v4;
                }
                goto lab_0x560d8;
            } else {
                goto lab_0x567cc;
            }
        } else {
            goto lab_0x567cc;
        }
    } else {
        goto lab_0x567cc;
    }
  lab_0x567cc:
    // 0x567cc
    if (function_11eec(v62, "default", v62, v86) == 0) {
        // 0x567e4
        if (function_11eec(v63, "format", v62, v86) == 0) {
            int32_t v89 = v59; // 0x56960
            char * str6; // 0x56030
            strcpy(str6, (char *)(v89 + v4));
            v15 = 1;
            v16 = 0;
            v17 = v4;
            goto lab_0x560d8;
        } else {
            goto lab_0x567fc;
        }
    } else {
        goto lab_0x567fc;
    }
  lab_0x567fc:
    // 0x567fc
    if (function_11eec(v62, "reload", v62, v86) == 0) {
        // 0x56814
        if (function_11eec(v63, "conf", v62, v86) == 0) {
            // 0x5682c
            if (function_11eec(v88, "period", v62, v86) == 0) {
                int32_t v90 = function_5e140(&str3); // 0x56850
                int32_t * v91; // 0x56030
                *v91 = v90;
                v15 = 1;
                v16 = 0;
                v17 = v4;
                goto lab_0x560d8;
            } else {
                goto lab_0x56860;
            }
        } else {
            goto lab_0x56860;
        }
    } else {
        goto lab_0x56860;
    }
  lab_0x56860:
    // 0x56860
    if (function_11eec(v62, "fsync", v62, v86) == 0) {
        // 0x56878
        if (function_11eec(v63, "period", v62, v86) == 0) {
            int32_t v92 = function_5e140(&str3); // 0x56988
            *v8 = v92;
            v15 = 1;
            v16 = 0;
            v17 = v4;
            goto lab_0x560d8;
        } else {
            goto lab_0x56890;
        }
    } else {
        goto lab_0x56890;
    }
  lab_0x56890:
    // 0x56890
    function_5df98(2, "src/conf.c", 454, "name[%s] is not any one of global options");
    int32_t v93 = *v12; // 0x568b8
    v15 = 1;
    v16 = 0;
    v17 = v4;
    if (v93 != 0) {
        goto lab_0x562b0_4;
    }
    goto lab_0x560d8;
}

// Address range: 0x56b38 - 0x56e0c
int32_t function_56b38(int32_t a1, int32_t a2) {
    if (a1 == 0) {
        // 0x56de8
        return function_5df98(2, "src/conf.c", 44, "a_conf is null or 0");
    }
    // 0x56b48
    function_5df98(a2, "src/conf.c", 45, "-conf[%p]-");
    function_5df98(a2, "src/conf.c", 46, "--global--");
    function_5df98(a2, "src/conf.c", 47, "---file[%s],mtime[%s]---");
    function_5df98(a2, "src/conf.c", 48, "---strict init[%d]---");
    function_5df98(a2, "src/conf.c", 49, "---buffer min[%ld]---");
    function_5df98(a2, "src/conf.c", 50, "---buffer max[%ld]---");
    int32_t * v1 = (int32_t *)(a1 + 0x2430); // 0x56c24
    if (*v1 != 0) {
        // 0x56c30
        function_5df98(a2, "src/conf.c", 52, "---default_format---");
        function_575fc(*v1, a2);
    }
    // 0x56c58
    function_5df98(a2, "src/conf.c", 55, "---file perms[0%o]---");
    function_5df98(a2, "src/conf.c", 56, "---reload conf period[%ld]---");
    function_5df98(a2, "src/conf.c", 57, "---fsync period[%ld]---");
    function_5df98(a2, "src/conf.c", 59, "---rotate lock file[%s]---");
    int32_t v2 = *(int32_t *)(a1 + 0x1428); // 0x56cf0
    if (v2 != 0) {
        // 0x56cfc
        function_58638(v2, a2);
    }
    int32_t v3 = *(int32_t *)(a1 + 0x2440); // 0x56d04
    int32_t v4 = 0; // 0x56d0c
    if (v3 != 0) {
        // 0x56d10
        v4 = function_57a8c(v3, a2);
    }
    int32_t * v5 = (int32_t *)(a1 + 0x2444); // 0x56d18
    int32_t result = v4; // 0x56d20
    if (*v5 != 0) {
        int32_t v6 = function_5df98(a2, "src/conf.c", 65, "--format list[%p]--"); // 0x56d40
        int32_t v7 = *v5; // 0x56d44
        int32_t v8 = 0; // 0x56d50
        result = v6;
        if (*(int32_t *)(v7 + 4) >= 1) {
            int32_t v9 = v8 + 1; // 0x56d64
            int32_t v10 = function_575fc(*(int32_t *)(*(int32_t *)v7 + 4 * v8), a2); // 0x56d68
            int32_t v11 = *v5; // 0x56d6c
            int32_t v12 = v11; // 0x56d78
            v8 = v9;
            result = v10;
            while (*(int32_t *)(v11 + 4) > v9) {
                // 0x56d58
                v9 = v8 + 1;
                v10 = function_575fc(*(int32_t *)(*(int32_t *)v12 + 4 * v8), a2);
                v11 = *v5;
                v12 = v11;
                v8 = v9;
                result = v10;
            }
        }
    }
    int32_t * v13 = (int32_t *)(a1 + 0x2448); // 0x56d7c
    if (*v13 == 0) {
        // 0x56de0
        return result;
    }
    int32_t result2 = function_5df98(a2, "src/conf.c", 72, "--rule_list[%p]--"); // 0x56da4
    int32_t v14 = *v13; // 0x56da8
    if (*(int32_t *)(v14 + 4) < 1) {
        // 0x56de0
        return result2;
    }
    int32_t v15 = 0;
    int32_t v16 = v15 + 1; // 0x56dc8
    int32_t result3 = function_5a850(*(int32_t *)(*(int32_t *)v14 + 4 * v15), a2); // 0x56dcc
    int32_t v17 = *v13; // 0x56dd0
    while (*(int32_t *)(v17 + 4) > v16) {
        // 0x56dbc
        v15 = v16;
        v16 = v15 + 1;
        result3 = function_5a850(*(int32_t *)(*(int32_t *)v17 + 4 * v15), a2);
        v17 = *v13;
    }
    // 0x56de0
    return result3;
}

// Address range: 0x56e0c - 0x56eb8
int32_t function_56e0c(int32_t a1) {
    // 0x56e0c
    if (a1 == 0) {
        // 0x56e98
        return function_5df98(2, "src/conf.c", 83, "a_conf is null or 0");
    }
    int32_t v1 = *(int32_t *)(a1 + 0x1428); // 0x56e1c
    if (v1 != 0) {
        // 0x56e28
        function_58750(v1);
    }
    int32_t v2 = *(int32_t *)(a1 + 0x2440); // 0x56e30
    if (v2 != 0) {
        // 0x56e3c
        function_57b24(v2);
    }
    int32_t v3 = *(int32_t *)(a1 + 0x2430); // 0x56e40
    if (v3 != 0) {
        // 0x56e4c
        function_5766c(v3);
    }
    int32_t v4 = *(int32_t *)(a1 + 0x2444); // 0x56e50
    if (v4 != 0) {
        // 0x56e5c
        function_5d580(v4);
    }
    int32_t v5 = *(int32_t *)(a1 + 0x2448); // 0x56e60
    if (v5 != 0) {
        // 0x56e6c
        function_5d580(v5);
    }
    // 0x56e70
    int32_t v6; // 0x56e0c
    free(a1, v6, v6, a1 + 0x1000);
    return function_5df98(0, "src/conf.c", 90, "zlog_conf_del[%p]");
}

// Address range: 0x56eb8 - 0x5729c
int32_t function_56eb8(int32_t a1) {
    // 0x56eb8
    int32_t v1; // 0x56eb8
    int32_t result = function_11eb0(1, 0x2450, v1, v1); // 0x56ecc
    if (result == 0) {
        // 0x571d0
        __errno_location();
        function_5df98(2, "src/conf.c", 105, "calloc fail, errno[%d]");
        // 0x57008
        return result;
    }
    int32_t v2; // 0x56eb8
    int32_t v3; // 0x56eb8
    char * str; // 0x56eb8
    if (a1 == 0 || (char)result == 0) {
        char * env_val = getenv("ZLOG_CONF_PATH"); // 0x56ef4
        if (env_val == NULL) {
            int32_t v4 = (int32_t)env_val; // 0x56ef4
            memset((int32_t *)result, v4, 1025);
            *(int32_t *)(result + 1048) = 1;
            int32_t v5 = result + 1060; // 0x57040
            *(int32_t *)(result + 1056) = (int32_t)&g8;
            *(int32_t *)(result + 1052) = 1024;
            *(int32_t *)v5 = 0x706d742f;
            *(int32_t *)(result + 1064) = 0x6f6c7a2f;
            *(int32_t *)(result + 1068) = 0x6f6c2e67;
            *(int16_t *)(result + 1072) = 0x6b63;
            *(char *)(result + 1074) = 0;
            v2 = v5;
            v3 = v4;
            goto lab_0x56f60;
        } else {
            // 0x56f00
            str = (char *)result;
            uint32_t chars_printed = snprintf(str, 1025, "%s", getenv("ZLOG_CONF_PATH")); // 0x56f20
            if (chars_printed >= 1024 == (chars_printed != 1024)) {
                // 0x5714c
                __errno_location();
                function_5df98(2, "src/conf.c", 120, "not enough space for path name, nwrite=[%d], errno[%d]");
                // 0x57178
                function_56e0c(result);
                return 0;
            }
            goto lab_0x56f30;
        }
    } else {
        char * str2 = (char *)result;
        uint32_t chars_printed2 = snprintf(str2, 1025, "%s", (char *)a1); // 0x5713c
        str = str2;
        if (chars_printed2 != 1024 && chars_printed2 >= 1024) {
            // 0x5714c
            __errno_location();
            function_5df98(2, "src/conf.c", 120, "not enough space for path name, nwrite=[%d], errno[%d]");
            // 0x57178
            function_56e0c(result);
            return 0;
        }
        goto lab_0x56f30;
    }
  lab_0x56f30:;
    int32_t str3 = result + 1060; // 0x56f40
    *(int32_t *)(result + 1048) = 1;
    *(int32_t *)(result + 1052) = 1024;
    *(int32_t *)(result + 1056) = (int32_t)&g8;
    strcpy((char *)str3, str);
    v2 = str3;
    v3 = 1;
    goto lab_0x56f60;
  lab_0x56f60:;
    int32_t * v6 = (int32_t *)(result + 0x142c); // 0x56f84
    *v6 = 0x61666564;
    *(int32_t *)(result + 0x1430) = 0x20746c75;
    *(int32_t *)(result + 0x1434) = 0x2522203d;
    *(int32_t *)(result + 0x1438) = 0x56252044;
    *(int32_t *)(result + 0x143c) = 0x70255b20;
    *(int32_t *)(result + 0x1440) = 0x3a46253a;
    *(int32_t *)(result + 0x1444) = 0x205d4c25;
    *(int32_t *)(result + 0x1448) = 0x6e256d25;
    *(int16_t *)(result + 0x144c) = 34;
    int32_t * v7 = (int32_t *)(result + 0x2434); // 0x56f98
    *v7 = 384;
    *(int32_t *)(result + 0x243c) = 0;
    int32_t * v8 = (int32_t *)(result + 0x2438); // 0x56fa0
    *v8 = 0;
    int32_t v9 = function_57c30(); // 0x56fa4
    int32_t * v10 = (int32_t *)(result + 0x2440); // 0x56fac
    *v10 = v9;
    if (v9 == 0) {
        // 0x57190
        function_5df98(2, "src/conf.c", 142, "zlog_level_list_new fail");
        // 0x57178
        function_56e0c(result);
        return 0;
    }
    int32_t v11 = function_5d4c0(0x5766c); // 0x56fbc
    int32_t * v12 = (int32_t *)(result + 0x2444); // 0x56fc4
    *v12 = v11;
    if (v11 == 0) {
        // 0x571b0
        function_5df98(2, "src/conf.c", 148, "zc_arraylist_new fail");
        // 0x57178
        function_56e0c(result);
        return 0;
    }
    int32_t v13 = function_5d4c0(0x5a97c); // 0x56fd4
    int32_t * v14 = (int32_t *)(result + 0x2448); // 0x56fdc
    *v14 = v13;
    if (v13 == 0) {
        // 0x5721c
        function_5df98(2, "src/conf.c", 154, "init rule_list fail");
        // 0x57178
        function_56e0c(result);
        return 0;
    }
    if (v3 != 0) {
        // 0x56fec
        if (function_56030(result) == 0) {
            // 0x56ffc
            function_56b38(result, 0);
            // 0x57008
            return result;
        }
        // 0x571fc
        function_5df98(2, "src/conf.c", 160, "zlog_conf_build_with_file fail");
        // 0x57178
        function_56e0c(result);
        return 0;
    }
    int32_t v15 = result + 0x244c; // 0x57070
    int32_t v16 = function_576e4(v6, v15); // 0x57078
    int32_t * v17 = (int32_t *)(result + 0x2430); // 0x57080
    *v17 = v16;
    if (v16 == 0) {
        // 0x5723c
        function_5df98(2, "src/conf.c", 183, "zlog_format_new fail");
        // 0x5710c
        function_5df98(2, "src/conf.c", 165, "zlog_conf_build_without_file fail");
        // 0x57178
        function_56e0c(result);
        return 0;
    }
    int32_t v18 = function_58834(v2); // 0x5708c
    *(int32_t *)(result + 0x1428) = v18;
    if (v18 == 0) {
        // 0x5725c
        function_5df98(2, "src/conf.c", 189, "zlog_rotater_new fail");
        // 0x5710c
        function_5df98(2, "src/conf.c", 165, "zlog_conf_build_without_file fail");
        // 0x57178
        function_56e0c(result);
        return 0;
    }
    int32_t v19 = function_5aa9c((int32_t *)"*.*        >stdout", *v10, *v17, *v12, *v7, *v8, v15); // 0x570c8
    if (v19 == 0) {
        // 0x5727c
        function_5df98(2, "src/conf.c", 202, "zlog_rule_new fail");
        // 0x5710c
        function_5df98(2, "src/conf.c", 165, "zlog_conf_build_without_file fail");
        // 0x57178
        function_56e0c(result);
        return 0;
    }
    // 0x570d4
    if (function_5d694(*v14, v19) == 0) {
        // 0x56ffc
        function_56b38(result, 0);
        // 0x57008
        return result;
    }
    // 0x570e8
    function_5a97c(v19);
    function_5df98(2, "src/conf.c", 209, "zc_arraylist_add fail");
    // 0x5710c
    function_5df98(2, "src/conf.c", 165, "zlog_conf_build_without_file fail");
    // 0x57178
    function_56e0c(result);
    return 0;
}

// Address range: 0x5729c - 0x57364
int32_t function_5729c(int32_t a1, int32_t a2) {
    if (a1 == 0) {
        // 0x57348
        return function_5df98(2, "src/event.c", 30, "a_event is null or 0");
    }
    // 0x572a4
    return function_5df98(a2, "src/event.c", 40, "---event[%p][%s,%s][%s(%ld),%s(%ld),%ld,%d][%p,%s][%ld,%ld][%ld,%ld][%d]---");
}

// Address range: 0x57364 - 0x573d8
int32_t function_57364(int32_t a1) {
    // 0x57364
    if (a1 == 0) {
        // 0x573b4
        return function_5df98(2, "src/event.c", 48, "a_event is null or 0");
    }
    int32_t v1 = *(int32_t *)(a1 + 372); // 0x57374
    if (v1 != 0) {
        // 0x57380
        int32_t v2; // 0x57364
        free(v1, v2, v2, v2);
    }
    // 0x57384
    function_5df98(0, "src/event.c", 50, "zlog_event_del[%p]");
    return free(a1, (int32_t)"src/event.c", 50, (int32_t)"zlog_event_del[%p]");
}

// Address range: 0x573d8 - 0x57540
int32_t function_573d8(int32_t a1) {
    // 0x573d8
    int32_t v1; // 0x573d8
    int32_t v2 = function_11eb0(1, 540, v1, v1); // 0x573ec
    if (v2 == 0) {
        // 0x574dc
        __errno_location();
        function_5df98(2, "src/event.c", 61, "calloc fail, errno[%d]");
        // 0x57498
        return 0;
    }
    int32_t v3 = function_11eb0(a1, 0x100c, v1, v1); // 0x57400
    *(int32_t *)(v2 + 372) = v3;
    if (v3 == 0) {
        // 0x57508
        __errno_location();
        function_5df98(2, "src/event.c", 67, "calloc fail, errno[%d]");
        free(v2, (int32_t)"src/event.c", 67, (int32_t)"calloc fail, errno[%d]");
        // 0x57498
        return 0;
    }
    // 0x57414
    *(int32_t *)(v2 + 376) = a1;
    char * name = (char *)(v2 + 8); // 0x57424
    int32_t result; // 0x573d8
    if (gethostname(name, 256) == 0) {
        // 0x57430
        *(int32_t *)(v2 + 268) = strlen(name);
        int32_t v4 = function_11fb8(); // 0x5743c
        int32_t * v5 = (int32_t *)(v2 + 424); // 0x57448
        *v5 = v4;
        *(int32_t *)(v2 + 460) = sprintf((char *)(v2 + 428), "%lu");
        *(int32_t *)(v2 + 496) = sprintf((char *)(v2 + 464), "%x", *v5);
        int32_t v6 = syscall(SYS_gettid); // 0x57478
        *(int32_t *)(v2 + 500) = v6;
        *(int32_t *)(v2 + 536) = sprintf((char *)(v2 + 504), "%u", v6);
        result = v2;
    } else {
        // 0x574a4
        __errno_location();
        function_5df98(2, "src/event.c", 78, "gethostname fail, errno[%d]");
        function_57364(v2);
        result = 0;
    }
    // 0x57498
    return result;
}

// Address range: 0x57540 - 0x5759c
int32_t function_57540(int32_t result, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11) {
    // 0x57540
    *(int32_t *)result = a2;
    *(int32_t *)(result + 4) = a3;
    *(int32_t *)(result + 272) = a4;
    *(int32_t *)(result + 276) = a5;
    *(int32_t *)(result + 280) = a6;
    *(int32_t *)(result + 284) = a7;
    *(int32_t *)(result + 288) = a8;
    *(int32_t *)(result + 292) = a9;
    *(int32_t *)(result + 304) = a10;
    *(int32_t *)(result + 308) = a11;
    *(int32_t *)(result + 312) = 0;
    *(int32_t *)(result + 380) = 0;
    *(int32_t *)(result + 316) = 0;
    return result;
}

// Address range: 0x5759c - 0x575fc
int32_t function_5759c(int32_t result, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11) {
    // 0x5759c
    *(int32_t *)(result + 4) = a3;
    *(int32_t *)(result + 272) = a4;
    *(int32_t *)(result + 276) = a5;
    *(int32_t *)result = a2;
    *(int32_t *)(result + 280) = a6;
    *(int32_t *)(result + 284) = a7;
    *(int32_t *)(result + 288) = a8;
    *(int32_t *)(result + 292) = a9;
    *(int32_t *)(result + 312) = 1;
    *(int32_t *)(result + 296) = a10;
    *(int32_t *)(result + 300) = a11;
    *(int32_t *)(result + 380) = 0;
    *(int32_t *)(result + 316) = 0;
    return result;
}

// Address range: 0x575fc - 0x5766c
int32_t function_575fc(int32_t a1, int32_t a2) {
    if (a1 == 0) {
        // 0x57650
        return function_5df98(2, "src/format.c", 24, "a_format is null or 0");
    }
    // 0x57604
    return function_5df98(a2, "src/format.c", 29, "---format[%p][%s = %s(%p)]---");
}

// Address range: 0x5766c - 0x576e4
int32_t function_5766c(int32_t a1) {
    if (a1 == 0) {
        // 0x576c0
        return function_5df98(2, "src/format.c", 45, "a_format is null or 0");
    }
    int32_t v1 = *(int32_t *)(a1 + 0x2004); // 0x57680
    if (v1 != 0) {
        // 0x5768c
        function_5d580(v1);
    }
    // 0x57690
    function_5df98(0, "src/format.c", 49, "zlog_format_del[%p]");
    return free(a1, (int32_t)"src/format.c", 49, (int32_t)"zlog_format_del[%p]");
}

// Address range: 0x576e4 - 0x57a1c
int32_t function_576e4(int32_t * a1, int32_t a2) {
    int32_t result = (int32_t)a1;
    int32_t v1 = 0; // bp-40, 0x576f4
    if (a1 == NULL) {
        // 0x57988
        function_5df98(2, "src/format.c", 65, "line is null or 0");
        // 0x578b4
        return result;
    }
    // 0x576fc
    int32_t v2; // 0x576e4
    int32_t result2 = function_11eb0(1, 0x2008, v2, v2); // 0x57708
    if (result2 == 0) {
        // 0x579ac
        __errno_location();
        function_5df98(2, "src/format.c", 69, "calloc fail, errno[%d]");
        // 0x578b4
        return 0;
    }
    int32_t * v3 = (int32_t *)result2; // 0x5771c
    memset(v3, 0, 0x1001);
    v1 = 0;
    if (sscanf2(result, " %[^= \t] = %n", v3, (int32_t)&v1) != 1) {
        // 0x57900
        function_5df98(2, "src/format.c", 81, "format[%s], syntax wrong");
        // 0x578a8
        function_5766c(result2);
        // 0x578b4
        return 0;
    }
    if ((char)result2 != 34) {
        // 0x57924
        function_5df98(2, "src/format.c", 86, "the 1st char of pattern is not \", line+nread[%s]");
      lab_0x578a8:
        // 0x578a8
        function_5766c(result2);
        // 0x578b4
        return 0;
    }
    char v4 = *(char *)result2; // 0x57758
    int32_t v5 = 34; // 0x57760
    if (v4 != 0) {
        int16_t * v6 = *__ctype_b_loc(); // 0x57768
        int32_t v7 = result2; // 0x5776c
        char v8 = v4; // 0x5776c
        int32_t v9 = v8;
        uint16_t v10 = *(int16_t *)(2 * v9 + (int32_t)v6); // 0x5777c
        while (((v8 == 95 ? v9 + 0x1fa1 : 1) & (int32_t)(v10 / 8 ^ 1)) == 0) {
            // 0x5778c
            v7++;
            v8 = *(char *)v7;
            v5 = 0;
            if (v8 == 0) {
                goto lab_0x57798;
            }
            v9 = v8;
            v10 = *(int16_t *)(2 * v9 + (int32_t)v6);
        }
        // 0x57888
        function_5df98(2, "src/format.c", 92, "a_format->name[%s] character is not in [a-Z][0-9][_]");
        // 0x578a8
        function_5766c(result2);
        // 0x578b4
        return 0;
    }
  lab_0x57798:;
    int32_t str = result + 1 + v1; // 0x577a0
    char * found_char_pos = strrchr((char *)str, 34); // 0x577a8
    if (found_char_pos == NULL) {
        // 0x579d8
        function_5df98(2, "src/format.c", 100, "there is no \" at end of pattern, line[%s]");
        // 0x578a8
        function_5766c(result2);
        // 0x578b4
        return 0;
    }
    uint32_t v11 = (int32_t)found_char_pos - str; // 0x577b4
    if (v11 >= 0x1000 == (v11 != 0x1000)) {
        // 0x57948
        function_5df98(2, "src/format.c", 105, "pattern is too long");
        // 0x578a8
        function_5766c(result2);
        // 0x578b4
        return 0;
    }
    int32_t v12 = result2 + 0x1001; // 0x577c8
    int32_t * v13 = (int32_t *)v12; // 0x577d4
    memset(v13, 0, 0x1001);
    function_11fc4(v13, str, (char)v11, v5);
    if (function_5e310(v12, 0x1001) != 0) {
        // 0x57968
        function_5df98(2, "src/format.c", 112, "zc_str_replace_env fail");
        // 0x578a8
        function_5766c(result2);
        // 0x578b4
        return 0;
    }
    int32_t v14 = function_5d4c0(0x5c6f4); // 0x57808
    int32_t * v15 = (int32_t *)(result2 + 0x2004); // 0x57810
    *v15 = v14;
    if (v14 == 0) {
        // 0x579fc
        function_5df98(2, "src/format.c", 119, "zc_arraylist_new fail");
        // 0x578a8
        function_5766c(result2);
        // 0x578b4
        return 0;
    }
    // 0x57818
    if (*(char *)v12 == 0) {
        // 0x578c0
        function_575fc(result2, 0);
        return result2;
    }
    // 0x5784c
    char * v16; // bp-36, 0x576e4
    int32_t v17 = function_5c758(v12, (int32_t *)&v16, a2); // 0x57858
    while (v17 != 0) {
        // 0x5782c
        if (function_5d694(*v15, v17) != 0) {
            // 0x578d8
            function_5c6f4(v17);
            function_5df98(2, "src/format.c", 132, "zc_arraylist_add fail");
            goto lab_0x578a8;
        }
        // 0x5783c
        if (*v16 == 0) {
            // 0x578c0
            function_575fc(result2, 0);
            return result2;
        }
        v17 = function_5c758((int32_t)v16, (int32_t *)&v16, a2);
    }
    // 0x57868
    function_5df98(2, "src/format.c", 126, "zlog_spec_new fail");
    // 0x578a8
    function_5766c(result2);
    // 0x578b4
    return 0;
}

// Address range: 0x57a1c - 0x57a8c
int32_t function_57a1c(int32_t a1, int32_t a2) {
    int32_t * v1 = (int32_t *)(a1 + 0x2004); // 0x57a24
    int32_t v2 = *v1; // 0x57a24
    int32_t v3 = *(int32_t *)(a2 + 28); // 0x57a28
    *(int32_t *)(v3 + 4) = *(int32_t *)v3;
    int32_t v4 = v2; // 0x57a44
    if (*(int32_t *)(v2 + 4) <= 0) {
        // 0x57a7c
        return 0;
    }
    int32_t v5 = 0; // 0x57a44
    int32_t result = -1; // 0x57a68
    while (*(int32_t *)(*(int32_t *)v4 + 4 * v5) == 0) {
        // 0x57a6c
        v5++;
        v4 = *v1;
        result = 0;
        if (*(int32_t *)(v4 + 4) <= v5) {
            // break -> 0x57a7c
            break;
        }
        result = -1;
    }
    // 0x57a7c
    return result;
}

// Address range: 0x57a8c - 0x57b24
int32_t function_57a8c(int32_t a1, int32_t a2) {
    if (a1 == 0) {
        // 0x57b00
        return function_5df98(2, "src/level_list.c", 25, "levels is null or 0");
    }
    int32_t result = function_5df98(a2, "src/level_list.c", 26, "--level_list[%p]--"); // 0x57abc
    int32_t * v1 = (int32_t *)(a1 + 4); // 0x57ac0
    uint32_t v2 = *v1; // 0x57ac0
    if (v2 <= 0) {
        // 0x57af8
        return result;
    }
    int32_t v3 = 0; // 0x57acc
    int32_t v4 = *(int32_t *)(4 * v3 + result); // 0x57ad8
    int32_t v5 = 0; // 0x57ae0
    int32_t v6 = v2; // 0x57ae0
    if (v4 != 0) {
        // 0x57ae4
        v5 = function_5f3f8(v4, a2);
        v6 = *v1;
    }
    int32_t result2 = v5;
    v3++;
    while (v6 > v3) {
        // 0x57ad0
        v4 = *(int32_t *)(4 * v3 + result2);
        v5 = 0;
        if (v4 != 0) {
            // 0x57ae4
            v5 = function_5f3f8(v4, a2);
            v6 = *v1;
        }
        // 0x57aec
        result2 = v5;
        v3++;
    }
    // 0x57af8
    return result2;
}

// Address range: 0x57b24 - 0x57b80
int32_t function_57b24(int32_t a1) {
    if (a1 == 0) {
        // 0x57b64
        return function_5df98(2, "src/level_list.c", 37, "levels is null or 0");
    }
    // 0x57b2c
    function_5d580(a1);
    return function_5df98(0, "src/level_list.c", 39, "zc_level_list_del[%p]");
}

// Address range: 0x57b80 - 0x57c30
int32_t function_57b80(int32_t a1, int32_t * a2) {
    int32_t v1 = function_5f4d8((int32_t)a2); // 0x57b94
    if (v1 == 0) {
        // 0x57c0c
        function_5df98(2, "src/level_list.c", 85, "zlog_level_new fail");
        // 0x57bb8
        return -1;
    }
    int32_t result = 0; // 0x57bb4
    if (function_5d5f0(a1, *(int32_t *)v1, v1) != 0) {
        // 0x57bc0
        function_5df98(2, "src/level_list.c", 90, "zc_arraylist_set fail");
        function_5df98(2, "src/level_list.c", 96, "line[%s]");
        function_5f474(v1);
        result = -1;
    }
    // 0x57bb8
    return result;
}

// Address range: 0x57c30 - 0x57d70
int32_t function_57c30(void) {
    int32_t result = function_5d4c0(0x5f474); // 0x57c3c
    if (result == 0) {
        // 0x57d50
        function_5df98(2, "src/level_list.c", 62, "zc_arraylist_new fail");
        // 0x57c84
        return 0;
    }
    // 0x57c48
    if (function_57b80(result, (int32_t *)"* = 0, LOG_INFO") != 0 || function_57b80(result, (int32_t *)"DEBUG = 20, LOG_DEBUG") != 0 || function_57b80(result, (int32_t *)"INFO = 40, LOG_INFO") != 0 || function_57b80(result, (int32_t *)"NOTICE = 60, LOG_NOTICE") != 0 || function_57b80(result, (int32_t *)"WARN = 80, LOG_WARNING") != 0 || function_57b80(result, (int32_t *)"ERROR = 100, LOG_ERR") != 0 || function_57b80(result, (int32_t *)"FATAL = 120, LOG_ALERT") != 0 || function_57b80(result, (int32_t *)"UNKNOWN = 254, LOG_ERR") != 0) {
        // 0x57c5c
        function_5df98(2, "src/level_list.c", 67, "zlog_level_set_default fail");
        function_5d580(result);
        // 0x57c84
        return 0;
    }
    // 0x57d34
    if (function_57b80(result, (int32_t *)"! = 255, LOG_INFO") == 0) {
        // 0x57c84
        return result;
    }
    // 0x57c5c
    function_5df98(2, "src/level_list.c", 67, "zlog_level_set_default fail");
    function_5d580(result);
    // 0x57c84
    return 0;
}

// Address range: 0x57d70 - 0x57de4
int32_t function_57d70(int32_t a1, int32_t a2) {
    int32_t * v1 = (int32_t *)(a1 + 4); // 0x57d70
    if (*v1 > a2) {
        int32_t result = *(int32_t *)(4 * a2 + a1); // 0x57d80
        if (result != 0) {
            // 0x57d8c
            return result;
        }
    }
    int32_t v2 = function_5df98(2, "src/level_list.c", 119, "l[%d] not in (0,254), or has no level defined,see configure file define, set to UNKOWN"); // 0x57dc0
    int32_t result2 = 0; // 0x57dd4
    if (*v1 > 254) {
        result2 = *(int32_t *)(v2 + 1016);
    }
    // 0x57d8c
    return result2;
}

// Address range: 0x57de4 - 0x57e98
int32_t function_57de4(int32_t a1, int32_t * str) {
    // 0x57de4
    int32_t v1; // 0x57de4
    if (str == NULL || (char)v1 == 0) {
        // 0x57e70
        function_5df98(2, "src/level_list.c", 132, "str is [%s], can't find level");
        // 0x57e64
        return -1;
    }
    int32_t v2 = *(int32_t *)(a1 + 4); // 0x57e00
    if (v2 < 1) {
        // 0x57e40
        function_5df98(2, "src/level_list.c", 142, "str[%s] can't found in level list");
        // 0x57e64
        return -1;
    }
    int32_t v3 = a1 - 4; // 0x57e10
    int32_t v4 = 0;
    v3 += 4;
    int32_t v5 = *(int32_t *)v3; // 0x57e14
    int32_t result; // 0x57de4
    if (v5 != 0) {
        // 0x57e28
        result = v4;
        if (strcasecmp((char *)str, (char *)(v5 + 4)) == 0) {
            // 0x57e64
            return result;
        }
    }
    int32_t v6 = v4 + 1; // 0x57e34
    while (v6 != v2) {
        // 0x57e14
        v4 = v6;
        v3 += 4;
        v5 = *(int32_t *)v3;
        if (v5 != 0) {
            // 0x57e28
            result = v4;
            if (strcasecmp((char *)str, (char *)(v5 + 4)) == 0) {
                // 0x57e64
                return result;
            }
        }
        // 0x57e34
        v6 = v4 + 1;
    }
    // 0x57e40
    function_5df98(2, "src/level_list.c", 142, "str[%s] can't found in level list");
    // 0x57e64
    return -1;
}

// Address range: 0x57e98 - 0x57ed4
int32_t function_57e98(int32_t a1) {
    // 0x57e98
    function_5df98(0, "src/mdc.c", 44, "zlog_mdc_kv_del[%p]");
    return free(a1, (int32_t)"src/mdc.c", 44, (int32_t)"zlog_mdc_kv_del[%p]");
}

// Address range: 0x57ed4 - 0x57f94
int32_t function_57ed4(int32_t a1, int32_t a2) {
    if (a1 == 0) {
        // 0x57f70
        return function_5df98(2, "src/mdc.c", 21, "a_mdc is null or 0");
    }
    int32_t v1 = function_5de60(function_5df98(a2, "src/mdc.c", 22, "---mdc[%p]---")); // 0x57f0c
    if (v1 == 0) {
        // 0x57f68
        return 0;
    }
    int32_t v2 = v1; // 0x57f14
    v2 = function_5dea8(function_5df98(a2, "src/mdc.c", 28, "----mdc_kv[%p][%s]-[%s]----"), v2);
    while (v2 != 0) {
        // 0x57f2c
        v2 = function_5dea8(function_5df98(a2, "src/mdc.c", 28, "----mdc_kv[%p][%s]-[%s]----"), v2);
    }
    // 0x57f68
    return 0;
}

// Address range: 0x57f94 - 0x58008
int32_t function_57f94(int32_t a1) {
    if (a1 == 0) {
        // 0x57fe4
        return function_5df98(2, "src/mdc.c", 35, "a_mdc is null or 0");
    }
    // 0x57fb0
    function_5d890(a1);
    function_5df98(0, "src/mdc.c", 37, "zlog_mdc_del[%p]");
    return free(a1, (int32_t)"src/mdc.c", 37, (int32_t)"zlog_mdc_del[%p]");
}

// Address range: 0x58008 - 0x580c0
int32_t function_58008(void) {
    // 0x58008
    int32_t v1; // 0x58008
    int32_t v2 = function_11eb0(1, 4, v1, v1); // 0x58018
    if (v2 == 0) {
        // 0x58068
        __errno_location();
        function_5df98(2, "src/mdc.c", 69, "calloc fail, errno[%d]");
        // 0x5805c
        return 0;
    }
    int32_t v3 = function_5d7b8(20, 0x5df18, 0x5df44, 0, 0x57e98); // 0x58048
    *(int32_t *)v2 = v3;
    int32_t result = v2; // 0x58058
    if (v3 == 0) {
        // 0x58094
        function_5df98(2, "src/mdc.c", 78, "zc_hashtable_new fail");
        function_57f94(v2);
        result = 0;
    }
    // 0x5805c
    return result;
}

// Address range: 0x580c0 - 0x581b0
int32_t function_580c0(int32_t a1, int32_t a2, int32_t a3) {
    // 0x580c0
    int32_t v1; // 0x580c0
    int32_t str = function_11eb0(1, 2056, a3, v1); // 0x580dc
    if (str == 0) {
        // 0x58138
        __errno_location();
        function_5df98(2, "src/mdc.c", 54, "calloc fail, errno[%d]");
        function_5df98(2, "src/mdc.c", 96, "zlog_mdc_kv_new failed");
        // 0x58130
        return -1;
    }
    // 0x580e8
    snprintf((char *)str, 1025, "%s", (char *)a2);
    int32_t chars_printed = snprintf((char *)(str + 1025), 1025, "%s", (char *)a3); // 0x58110
    *(int32_t *)(str + 2052) = chars_printed;
    int32_t result = 0; // 0x5812c
    if (function_5dac0(chars_printed, str, str) != 0) {
        // 0x58184
        function_5df98(2, "src/mdc.c", 101, "zc_hashtable_put fail");
        function_57e98(str);
        result = -1;
    }
    // 0x58130
    return result;
}

// Address range: 0x581b0 - 0x581b8
int32_t function_581b0(int32_t a1) {
    // 0x581b0
    return function_5d950(a1);
}

// Address range: 0x581b8 - 0x581fc
int32_t function_581b8(int32_t a1) {
    // 0x581b8
    int32_t v1; // 0x581b8
    int32_t v2 = function_5da58(a1, v1); // 0x581c0
    if (v2 != 0) {
        // 0x581cc
        return v2 + 1025;
    }
    // 0x581d8
    function_5df98(2, "src/mdc.c", 121, "zc_hashtable_get fail");
    return 0;
}

// Address range: 0x581fc - 0x58238
int32_t function_581fc(int32_t a1) {
    // 0x581fc
    int32_t v1; // 0x581fc
    int32_t result = function_5da58(a1, v1); // 0x58204
    if (result == 0) {
        // 0x58218
        function_5df98(2, "src/mdc.c", 134, "zc_hashtable_get fail");
    }
    // 0x58210
    return result;
}

// Address range: 0x58238 - 0x58240
int32_t function_58238(int32_t a1) {
    // 0x58238
    int32_t v1; // 0x58238
    return function_5dd28(a1, v1);
}

// Address range: 0x58240 - 0x582a0
int32_t function_58240(int32_t a1, int32_t a2) {
    if (a1 == 0) {
        // 0x58284
        return function_5df98(2, "src/record.c", 14, "a_record is null or 0");
    }
    // 0x58248
    return function_5df98(a2, "src/record.c", 15, "--record:[%p][%s:%p]--");
}

// Address range: 0x582a0 - 0x582f8
int32_t function_582a0(int32_t a1) {
    if (a1 == 0) {
        // 0x582e0
        return 2;
    }
    // 0x582b0
    function_5df98(0, "src/record.c", 22, "zlog_record_del[%p]");
    return free(a1, (int32_t)"src/record.c", 22, (int32_t)"zlog_record_del[%p]");
}

// Address range: 0x582f8 - 0x582fa
int32_t function_582f8(void) {
    // 0x582f8
    int32_t result; // 0x582f8
    return result;
}

// Address range: 0x582fa - 0x582fc
int32_t function_582fa(void) {
    // 0x582fa
    int32_t result; // 0x582fa
    return result;
}

// Address range: 0x582fc - 0x58304
int32_t function_582fc(int32_t a1, int32_t a2) {
    // 0x582fc
    int32_t v1; // 0x582fc
    return function_5df98(v1, (char *)v1, v1, (char *)v1);
}

// Address range: 0x58304 - 0x58414
int32_t function_58304(int32_t str, int32_t a2) {
    // 0x58304
    if (str == 0) {
        // 0x583c4
        function_5df98(2, "src/record.c", 31, "name is null or 0");
        // 0x58364
        return 0;
    }
    if (a2 == 0) {
        // 0x583a0
        function_5df98(2, "src/record.c", 32, "output is null or 0");
        // 0x58364
        return 0;
    }
    // 0x58320
    int32_t v1; // 0x58304
    int32_t v2 = function_11eb0(1, 1032, v1, v1); // 0x58328
    if (v2 == 0) {
        // 0x583e8
        __errno_location();
        function_5df98(2, "src/record.c", 36, "calloc fail, errno[%d]");
        // 0x58364
        return 0;
    }
    uint32_t len = strlen((char *)str); // 0x58338
    int32_t result; // 0x58304
    if (len >= 1024 == (len != 1024)) {
        // 0x58370
        function_5df98(2, "src/record.c", 41, "name[%s] is too long");
        function_582a0(v2);
        result = 0;
    } else {
        // 0x58344
        function_11fc4((int32_t *)v2, str, (char)len + 1, v1);
        *(int32_t *)(v2 + 1028) = a2;
        function_58240(v2, 0);
        result = v2;
    }
    // 0x58364
    return result;
}

// Address range: 0x58414 - 0x584a4
int32_t function_58414(int32_t a1, int32_t a2) {
    if (a1 == 0) {
        // 0x58480
        return function_5df98(2, "src/record_table.c", 21, "records is null or 0");
    }
    // 0x58424
    function_5df98(a2, "src/record_table.c", 22, "-record_table[%p]-");
    int32_t v1 = function_5de60(a1); // 0x5844c
    if (v1 == 0) {
        // 0x58478
        return 0;
    }
    int32_t v2 = v1; // 0x58454
    function_58240(*(int32_t *)(v2 + 8), a2);
    v2 = function_5dea8(a1, v2);
    while (v2 != 0) {
        // 0x58458
        function_58240(*(int32_t *)(v2 + 8), a2);
        v2 = function_5dea8(a1, v2);
    }
    // 0x58478
    return 0;
}

// Address range: 0x584a4 - 0x58500
int32_t function_584a4(int32_t a1) {
    if (a1 == 0) {
        // 0x584e4
        return function_5df98(2, "src/record_table.c", 34, "records is null or 0");
    }
    // 0x584ac
    function_5d890(a1);
    return function_5df98(0, "src/record_table.c", 36, "zlog_record_table_del[%p]");
}

// Address range: 0x58500 - 0x5856c
int32_t function_58500(void) {
    int32_t result = function_5d7b8(20, 0x5df18, 0x5df44, 0, 0x582a0); // 0x5852c
    if (result == 0) {
        // 0x5854c
        function_5df98(2, "src/record_table.c", 49, "zc_hashtable_new fail");
    } else {
        // 0x58538
        function_58414(result, 0);
    }
    // 0x58540
    return result;
}

// Address range: 0x5856c - 0x58584
int32_t function_5856c(int32_t a1, int32_t a2) {
    // 0x5856c
    return (bool)(a1 > a2);
}

// Address range: 0x58584 - 0x585e4
int32_t function_58584(int32_t a1) {
    // 0x58584
    function_5df98(0, "src/rotater.c", 126, "del onefile[%p]");
    function_5df98(0, "src/rotater.c", 127, "a_file->path[%s]");
    return free(a1, (int32_t)"src/rotater.c", 127, (int32_t)"a_file->path[%s]");
}

// Address range: 0x585e4 - 0x58638
int32_t function_585e4(int32_t a1) {
    // 0x585e4
    *(int32_t *)(a1 + 32) = 0;
    *(int32_t *)(a1 + 36) = 0;
    *(int32_t *)(a1 + 1084) = 0;
    *(int32_t *)(a1 + 1080) = 0;
    *(int32_t *)(a1 + 1076) = 0;
    *(int32_t *)(a1 + 1068) = 0;
    *(int32_t *)(a1 + 1072) = 0;
    memset((int32_t *)(a1 + 40), 0, 1025);
    int32_t * v1 = (int32_t *)(a1 + 1088); // 0x5861c
    int32_t v2 = *v1; // 0x5861c
    int32_t result = 0; // 0x58624
    if (v2 != 0) {
        // 0x58628
        result = function_5d580(v2);
    }
    // 0x5862c
    *v1 = 0;
    return result;
}

// Address range: 0x58638 - 0x58750
int32_t function_58638(int32_t a1, int32_t a2) {
    if (a1 == 0) {
        // 0x5872c
        return function_5df98(2, "src/rotater.c", 34, "a_rotater is null or 0");
    }
    int32_t result = function_5df98(a2, "src/rotater.c", 50, "--rotater[%p][%p,%s,%d][%s,%s,%s,%ld,%ld,%d,%d,%d]--"); // 0x586bc
    int32_t * v1 = (int32_t *)(a1 + 1088); // 0x586c0
    int32_t v2 = *v1; // 0x586c0
    if (v2 == 0) {
        // 0x58724
        return result;
    }
    // 0x586cc
    if (*(int32_t *)(v2 + 4) < 1) {
        // 0x58724
        return result;
    }
    int32_t v3 = 0; // 0x586d4
    v3++;
    int32_t result2 = function_5df98(a2, "src/rotater.c", 55, "[%s,%d]->"); // 0x58720
    while (*(int32_t *)(*v1 + 4) > v3) {
        // 0x586ec
        v3++;
        result2 = function_5df98(a2, "src/rotater.c", 55, "[%s,%d]->");
    }
    // 0x58724
    return result2;
}

// Address range: 0x58750 - 0x58834
int32_t function_58750(int32_t a1) {
    if (a1 == 0) {
        // 0x58810
        return function_5df98(2, "src/rotater.c", 64, "a_rotater is null or 0");
    }
    int32_t fd = *(int32_t *)(a1 + 28); // 0x58760
    if (fd != 0) {
        // 0x587ac
        if (close(fd) != 0) {
            // 0x587b8
            __errno_location();
            function_5df98(2, "src/rotater.c", 68, "close fail, errno[%d]");
        }
    }
    // 0x5876c
    if (function_11f4c(a1) != 0) {
        // 0x587e4
        __errno_location();
        function_5df98(2, "src/rotater.c", 73, "pthread_mutex_destroy fail, errno[%d]");
    }
    // 0x5877c
    function_5df98(0, "src/rotater.c", 76, "zlog_rotater_del[%p]");
    return free(a1, (int32_t)"src/rotater.c", 76, (int32_t)"zlog_rotater_del[%p]");
}

// Address range: 0x58834 - 0x58958
int32_t function_58834(int32_t a1) {
    // 0x58834
    if (a1 == 0) {
        // 0x588cc
        function_5df98(2, "src/rotater.c", 86, "lock_file is null or 0");
        // 0x58888
        return 0;
    }
    // 0x58844
    int32_t v1; // 0x58834
    int32_t v2 = function_11eb0(1, 1092, v1, v1); // 0x5884c
    if (v2 == 0) {
        // 0x588f0
        __errno_location();
        function_5df98(2, "src/rotater.c", 90, "calloc fail, errno[%d]");
        // 0x58888
        return 0;
    }
    // 0x58858
    if (function_11fdc(v2, 0) != 0) {
        // 0x58894
        __errno_location();
        function_5df98(2, "src/rotater.c", 95, "pthread_mutex_init fail, errno[%d]");
        free(v2, (int32_t)"src/rotater.c", 95, (int32_t)"pthread_mutex_init fail, errno[%d]");
        // 0x58888
        return 0;
    }
    int32_t v3 = open64((char *)a1, 66); // 0x58874
    int32_t result; // 0x58834
    if (v3 < 0) {
        // 0x5891c
        __errno_location();
        function_5df98(2, "src/rotater.c", 108, "open file[%s] fail, errno[%d]");
        function_58750(v2);
        result = 0;
    } else {
        *(int32_t *)(v2 + 28) = v3;
        *(int32_t *)(v2 + 24) = a1;
        result = v2;
    }
    // 0x58888
    return result;
}

// Address range: 0x58958 - 0x595c0
int32_t function_58958(int32_t a1, int32_t a2, int32_t a3, int32_t a4, uint32_t a5, int32_t a6) {
    int32_t v1 = a4;
    if (a2 == 0) {
        // 0x5924c
        function_5df98(2, "src/rotater.c", 536, "base_path is null or 0");
        // 0x58ab4
        return -1;
    }
    int32_t str3 = v1; // 0x58970
    int32_t str7 = 1; // bp-1072, 0x5898c
    int32_t * v2 = (int32_t *)a1; // 0x58990
    int32_t * fd; // 0x589ac
    switch (function_11ff4(v2)) {
        case 16: {
            // 0x592a0
            function_5df98(1, "src/rotater.c", 481, "pthread_mutex_trylock fail, as lock_mutex is locked by other threads");
            // 0x58a0c
            function_5df98(1, "src/rotater.c", 539, "zlog_rotater_trylock fail, maybe lock by other process or threads");
            return 0;
        }
        case 0: {
            // 0x589a4
            fd = (int32_t *)(a1 + 28);
            if (fcntl(*fd, F_SETLK64) != 0) {
                // 0x589bc
                if ((*__errno_location() - 11 & -3) == 0) {
                    // 0x58ac4
                    function_5df98(1, "src/rotater.c", 493, "fcntl lock fail, as file is lock by other process");
                    if (function_11ea4(v2, (int32_t)"src/rotater.c", 493, (int32_t)"fcntl lock fail, as file is lock by other process") == 0) {
                        // 0x58a0c
                        function_5df98(1, "src/rotater.c", 539, "zlog_rotater_trylock fail, maybe lock by other process or threads");
                        return 0;
                    }
                } else {
                    // 0x589d4
                    function_5df98(2, "src/rotater.c", 495, "lock fd[%d] fail, errno[%d]");
                    if (function_11ea4(v2, (int32_t)"src/rotater.c", 495, (int32_t)"lock fd[%d] fail, errno[%d]") == 0) {
                        // 0x58a0c
                        function_5df98(1, "src/rotater.c", 539, "zlog_rotater_trylock fail, maybe lock by other process or threads");
                        return 0;
                    }
                }
                // 0x58af0
                function_5df98(2, "src/rotater.c", 498, "pthread_mutex_unlock fail, errno[%d]");
                // 0x58a0c
                function_5df98(1, "src/rotater.c", 539, "zlog_rotater_trylock fail, maybe lock by other process or threads");
                return 0;
            }
            // break -> 0x58a3c
            break;
        }
        default: {
            // 0x590fc
            function_5df98(2, "src/rotater.c", 484, "pthread_mutex_trylock fail, rc[%d]");
            // 0x58a0c
            function_5df98(1, "src/rotater.c", 539, "zlog_rotater_trylock fail, maybe lock by other process or threads");
            return 0;
        }
    }
    char * v3 = (char *)a2; // 0x58a48
    int32_t result; // 0x58958
    int32_t v4; // bp-1176, 0x58958
    char * v5; // 0x58958
    int32_t * file_path; // 0x58bc0
    int32_t * v6; // 0x58bc4
    int32_t * v7; // 0x58bc8
    int32_t v8; // 0x58be0
    int32_t v9; // 0x58958
    if (__xstat64(3, v3, (struct stat64 *)&v4) == 0) {
        // 0x58a54
        int64_t v10; // 0x58958
        uint32_t v11 = (int32_t)(v10 / 0x100000000); // 0x58a58
        uint32_t v12 = v11 + a3; // 0x58a60
        uint32_t v13 = a5 / 0x80000000 - (int32_t)v10 + (int32_t)(v12 < v11); // 0x58a6c
        v1 = v13 - (int32_t)(v12 > a5);
        result = 0;
        if ((v13 % 2 != 0) < (v12 > a5)) {
            // 0x58bbc
            file_path = (int32_t *)(a1 + 32);
            *file_path = a2;
            v6 = (int32_t *)(a1 + 36);
            *v6 = str3;
            v7 = (int32_t *)(a1 + 1084);
            *v7 = a6;
            if (*(char *)&v1 == 0) {
                char * str = (char *)(a1 + 40); // 0x58ed8
                uint32_t chars_printed = snprintf(str, 1025, "%s.*", v3); // 0x58eec
                if (chars_printed >= 1025 == (chars_printed != 1025)) {
                    // 0x59510
                    __errno_location();
                    function_5df98(2, "src/rotater.c", 360, "nwirte[%d], overflow or errno[%d]");
                    // 0x59408
                    function_5df98(2, "src/rotater.c", 437, "zlog_rotater_parse_archive_path fail");
                    goto lab_0x58ea0;
                } else {
                    // 0x58f00
                    *(int32_t *)(a1 + 1080) = 1;
                    *(int32_t *)(a1 + 1076) = 0;
                    char * str2 = (char *)*file_path; // 0x58f10
                    *(int32_t *)(a1 + 1068) = strlen(str2) + 1;
                    *(int32_t *)(a1 + 1072) = strlen(str2) + 2;
                    v5 = str;
                    goto lab_0x58ca0;
                }
            } else {
                char * found_char_pos = strchr((char *)str3, 35); // 0x58be0
                if (found_char_pos == NULL) {
                    // 0x594ec
                    function_5df98(2, "src/rotater.c", 374, "no # in archive_path[%s]");
                    // 0x59408
                    function_5df98(2, "src/rotater.c", 437, "zlog_rotater_parse_archive_path fail");
                    goto lab_0x58ea0;
                } else {
                    // 0x58bec
                    v8 = (int32_t)found_char_pos;
                    str7 = 0;
                    sscanf2(v8, "#%d%n", (int32_t *)(a1 + 1076), (int32_t)&str7);
                    int32_t v14 = str7; // 0x58c08
                    if (v14 == 0) {
                        str7 = 1;
                    }
                    v9 = (v14 == 0 ? 1 : v14) + v8;
                    char v15 = *(char *)v9; // 0x58c18
                    unsigned char v16 = v15 == 114 ? 1 : v15;
                    int32_t v17 = v16;
                    v1 = v17;
                    if (v15 == 114) {
                        *(int32_t *)(a1 + 1080) = v17;
                        goto lab_0x58c3c;
                    } else {
                        if (v16 == 115) {
                            // 0x58c34
                            v1 = 2;
                            *(int32_t *)(a1 + 1080) = 2;
                            goto lab_0x58c3c;
                        } else {
                            // 0x5944c
                            function_5df98(2, "src/rotater.c", 386, "#r or #s not found");
                            // 0x59408
                            function_5df98(2, "src/rotater.c", 437, "zlog_rotater_parse_archive_path fail");
                            goto lab_0x58ea0;
                        }
                    }
                }
            }
        } else {
            goto lab_0x58a74;
        }
    } else {
        // 0x58b18
        __errno_location();
        v1 = (int32_t)"stat [%s] fail, errno[%d]";
        function_5df98(2, "src/rotater.c", 545, "stat [%s] fail, errno[%d]");
        result = -1;
        goto lab_0x58a74;
    }
  lab_0x58de8:
    // 0x58de8
    v1 = (int32_t)"not the expect pattern file";
    function_5df98(1, "src/rotater.c", 211, "not the expect pattern file");
    int32_t v18 = 211; // 0x58dfc
    goto lab_0x58dc8;
  lab_0x58dc8:;
    // 0x58dc8
    int32_t v19; // 0x58958
    int32_t v20 = v19 - 1;
    if (v20 == 0) {
        // break -> 0x58e04
        goto lab_0x58e04_2;
    }
    int32_t v21 = v1; // 0x58958
    int32_t v22 = v18; // 0x58958
    v19 = v20;
    int32_t v23; // 0x58dd0
    int32_t v24 = v23; // 0x58958
    goto lab_0x58dd0;
  lab_0x58e54:;
    // 0x58e54
    int32_t v29; // 0x58d40
    free(v29, (int32_t)"src/rotater.c", 155, v1);
    goto lab_0x58de8;
  lab_0x58a74:
    // 0x58a74
    str7 = 2;
    if (fcntl(*fd, F_SETLK64) != 0) {
        // 0x58b4c
        __errno_location();
        function_5df98(2, "src/rotater.c", 518, "unlock fd[%s] fail, errno[%d]");
        if (function_11ea4(v2, (int32_t)"src/rotater.c", 518, (int32_t)"unlock fd[%s] fail, errno[%d]") == 0) {
            // 0x58b90
            function_5df98(2, "src/rotater.c", 569, "zlog_rotater_unlock fail");
            return result;
        }
        // 0x59278
        function_5df98(2, "src/rotater.c", 523, "pthread_mutext_unlock fail, errno[%d]");
        // 0x58b90
        function_5df98(2, "src/rotater.c", 569, "zlog_rotater_unlock fail");
        return result;
    }
    // 0x58aa4
    if (function_11ea4(v2, 13, (int32_t)&str7, v1) == 0) {
        // 0x58ab4
        return result;
    }
    // 0x59270
    __errno_location();
    // 0x59278
    function_5df98(2, "src/rotater.c", 523, "pthread_mutext_unlock fail, errno[%d]");
    // 0x58b90
    function_5df98(2, "src/rotater.c", 569, "zlog_rotater_unlock fail");
    return result;
  lab_0x58ca0:;
    char * v35 = v5;
    int32_t v36 = function_5d4c0(0x58584); // 0x58ca8
    int32_t * v34 = (int32_t *)(a1 + 1088); // 0x58cb0
    *v34 = v36;
    if (v36 == 0) {
        // 0x5949c
        function_5df98(2, "src/rotater.c", 191, "zc_arraylist_new fail");
        // 0x58e84
        function_5df98(2, "src/rotater.c", 443, "zlog_rotater_add_archive_files fail");
        goto lab_0x58ea0;
    } else {
        // 0x58cb8
        switch (glob64(v35, 7, NULL, (struct _TYPEDEF_glob64_t *)&str7)) {
            case 3: {
                goto lab_0x58e04_2;
            }
            case 0: {
                int32_t v37 = str7; // 0x58ce0
                if (v37 != 0) {
                    // 0x58cf4
                    v1 = (int32_t)"not the expect pattern file";
                    int32_t v30; // bp-1180, 0x58958
                    int32_t v31 = &v30;
                    v21 = (int32_t)"not the expect pattern file";
                    v22 = (int32_t)"src/rotater.c";
                    v19 = v37;
                    int32_t v38; // 0x58958
                    v24 = v38 - 4;
                    while (true) {
                      lab_0x58dd0:;
                        int32_t v25 = v22;
                        v23 = v24 + 4;
                        int32_t v26 = *(int32_t *)v23; // 0x58dd0
                        char * str4 = (char *)v26; // 0x58ddc
                        if (function_11eec(*file_path, str4, v25, v21) == 0) {
                            goto lab_0x58de8;
                        } else {
                            unsigned char v27 = *(char *)(v26 - 1 + strlen(str4)); // 0x58d2c
                            int32_t v28 = v27; // 0x58d2c
                            v1 = v28;
                            if (v27 == 47) {
                                goto lab_0x58de8;
                            } else {
                                // 0x58d38
                                v29 = function_11eb0(1, 1032, v25, v28);
                                if (v29 == 0) {
                                    // 0x59070
                                    __errno_location();
                                    function_5df98(2, "src/rotater.c", 149, "calloc fail, errno[%d]");
                                    goto lab_0x58de8;
                                } else {
                                    int32_t str5 = v29 + 4; // 0x58d4c
                                    uint32_t chars_printed2 = snprintf((char *)str5, 1025, "%s", str4); // 0x58d60
                                    if (chars_printed2 >= 1024 == (chars_printed2 != 1024)) {
                                        // 0x58e2c
                                        __errno_location();
                                        v1 = (int32_t)"snprintf fail or overflow, nwrite=[%d], errno[%d]";
                                        function_5df98(2, "src/rotater.c", 155, "snprintf fail or overflow, nwrite=[%d], errno[%d]");
                                        goto lab_0x58e54;
                                    } else {
                                        // 0x58d70
                                        v30 = 0;
                                        sscanf2(*(int32_t *)(a1 + 1068) + str5, "%d%n", (int32_t *)v29, v31);
                                        int32_t v32 = *(int32_t *)(a1 + 1076); // 0x58d94
                                        v1 = v32;
                                        if (v32 != 0 == v32 > v30) {
                                            // 0x59210
                                            v1 = (int32_t)"aa.1.log is not expect, need aa.01.log";
                                            function_5df98(1, "src/rotater.c", 164, "aa.1.log is not expect, need aa.01.log");
                                            goto lab_0x58e54;
                                        } else {
                                            int32_t v33 = function_5d6a0(*v34, 0x5856c, v29); // 0x58dbc
                                            v18 = v29;
                                            if (v33 != 0) {
                                                // 0x58e60
                                                function_5df98(2, "src/rotater.c", 219, "zc_arraylist_sortadd fail");
                                                globfree64((struct _TYPEDEF_glob64_t *)&str7);
                                                // 0x58e84
                                                function_5df98(2, "src/rotater.c", 443, "zlog_rotater_add_archive_files fail");
                                                goto lab_0x58ea0;
                                            }
                                            goto lab_0x58dc8;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                goto lab_0x58e04_2;
            }
            default: {
                // 0x594bc
                __errno_location();
                function_5df98(2, "src/rotater.c", 200, "glob err, rc=[%d], errno[%d]");
                // 0x58e84
                function_5df98(2, "src/rotater.c", 443, "zlog_rotater_add_archive_files fail");
                goto lab_0x58ea0;
            }
        }
    }
  lab_0x58ea0:
    // 0x58ea0
    function_585e4(a1);
    v1 = (int32_t)"zlog_rotater_lsmv [%s] fail, return";
    function_5df98(2, "src/rotater.c", 560, "zlog_rotater_lsmv [%s] fail, return");
    result = -1;
    goto lab_0x58a74;
  lab_0x58c3c:;
    int32_t v39 = *v6; // 0x58c3c
    uint32_t v40 = v8 - v39; // 0x58c40
    if (v40 >= 1024 == (v40 != 1024)) {
        // 0x59428
        function_5df98(2, "src/rotater.c", 393, "sizeof glob_path not enough,len[%ld]");
        // 0x59408
        function_5df98(2, "src/rotater.c", 437, "zlog_rotater_parse_archive_path fail");
        goto lab_0x58ea0;
    } else {
        int32_t v41 = a1 + 40; // 0x58c4c
        uint32_t size = 1025 - v40; // 0x58c60
        function_11fc4((int32_t *)v41, v39, (char)v40, v1);
        v1 = v9 + 1;
        int32_t chars_printed3 = snprintf((char *)(v40 + v41), size, "*%s"); // 0x58c80
        if (chars_printed3 > -1 == size >= chars_printed3) {
            // .critedge
            v1 = v40 + 1;
            *(int32_t *)(a1 + 1068) = v40;
            *(int32_t *)(a1 + 1072) = v1;
            v5 = (char *)v41;
            goto lab_0x58ca0;
        } else {
            // 0x593dc
            __errno_location();
            function_5df98(2, "src/rotater.c", 401, "nwirte[%d], overflow or errno[%d]");
            // 0x59408
            function_5df98(2, "src/rotater.c", 437, "zlog_rotater_parse_archive_path fail");
            goto lab_0x58ea0;
        }
    }
  lab_0x58e04_2:
    // 0x58e04
    globfree64((struct _TYPEDEF_glob64_t *)&str7);
    int32_t v42 = *(int32_t *)(a1 + 1080); // 0x58e0c
    v1 = v42;
    int32_t v43; // 0x58958
    switch (v42) {
        case 1: {
            int32_t v44 = *v34; // 0x58f30
            v1 = v44;
            int32_t v45 = *(int32_t *)(v44 + 4) - 1; // 0x58f38
            int32_t * v46; // 0x58958
            int32_t v47; // 0x58958
            int32_t * v48; // 0x58958
            int32_t * v49; // 0x58958
            if (v45 < 0) {
                // 0x58f30
                v49 = (int32_t *)(a1 + 1068);
                v48 = (int32_t *)(a1 + 1076);
                v47 = (int32_t)v35;
                v46 = (int32_t *)(a1 + 1072);
              lab_0x592c0:;
                char * str6 = (char *)&str7;
                memset(&str7, 0, 1025);
                int32_t v50 = *v46; // 0x592d0
                int32_t v51 = *v48; // 0x592e0
                int32_t v52 = *v49; // 0x592e8
                v1 = v52;
                uint32_t chars_printed4 = snprintf(str6, 1025, "%.*s%0*d%s", v52, v35, v51, 0, (char *)(v50 + v47)); // 0x59308
                if (chars_printed4 >= 1024 == (chars_printed4 != 1024)) {
                    // 0x59570
                    __errno_location();
                    function_5df98(2, "src/rotater.c", 335, "nwirte[%d], overflow or errno[%d]");
                    // 0x59050
                    function_5df98(2, "src/rotater.c", 450, "zlog_rotater_roll_files fail");
                    goto lab_0x58ea0;
                } else {
                    // 0x59318
                    if (rename((char *)*file_path, str6) == 0) {
                        // 0x58e20
                        function_585e4(a1);
                        result = 0;
                        goto lab_0x58a74;
                    } else {
                        // 0x5932c
                        __errno_location();
                        function_5df98(2, "src/rotater.c", 340, "rename[%s]->[%s] fail, errno[%d]");
                        // 0x59050
                        function_5df98(2, "src/rotater.c", 450, "zlog_rotater_roll_files fail");
                        goto lab_0x58ea0;
                    }
                }
            } else {
                int32_t v53 = 4 * v45; // 0x58f44
                int32_t v54 = *(int32_t *)(*(int32_t *)v44 + v53); // 0x58f48
                v1 = v54;
                if (v54 == 0) {
                  lab_0x5922c_2:
                    // 0x5922c
                    function_5df98(2, "src/rotater.c", 297, "zc_arraylist_get fail");
                } else {
                    int32_t v55 = (int32_t)v35;
                    int32_t * v56 = (int32_t *)(a1 + 1072);
                    int32_t * v57 = (int32_t *)(a1 + 1076);
                    int32_t * v58 = (int32_t *)(a1 + 1068);
                    int32_t v59 = v54; // 0x58f64
                    int32_t v60 = v45; // 0x58f64
                    int32_t v61 = v53; // 0x58f64
                    while (true) {
                        int32_t v62 = v60;
                        int32_t v63 = *v7; // 0x58fec
                        int32_t file_path2 = v59 + 4; // 0x58ffc
                        if (v63 < 1 || v62 < v63 - 1) {
                            // 0x58f68
                            memset(&str7, 0, 1025);
                            int32_t v64 = *v56; // 0x58f6c
                            int32_t v65 = *v57; // 0x58f74
                            int32_t v66 = *v58; // 0x58f7c
                            int32_t chars_printed5 = snprintf((char *)&str7, 1025, "%.*s%0*d%s", v66, v35, v65, v62 + 1, (char *)(v64 + v55)); // 0x58f9c
                            v1 = chars_printed5;
                            if (chars_printed5 >= 1024 == (chars_printed5 != 1024)) {
                                // break -> 0x59370
                                break;
                            }
                            // 0x58fb4
                            if (rename((char *)file_path2, (char *)&str7) != 0) {
                                // 0x593a4
                                __errno_location();
                                function_5df98(2, "src/rotater.c", 323, "rename[%s]->[%s] fail, errno[%d]");
                                // 0x59050
                                function_5df98(2, "src/rotater.c", 450, "zlog_rotater_roll_files fail");
                                goto lab_0x58ea0;
                            }
                        } else {
                            // 0x59014
                            if (function_12090(file_path2) != 0) {
                                // 0x59024
                                __errno_location();
                                function_5df98(2, "src/rotater.c", 305, "unlink[%s] fail, errno[%d]");
                                // 0x59050
                                function_5df98(2, "src/rotater.c", 450, "zlog_rotater_roll_files fail");
                                goto lab_0x58ea0;
                            }
                        }
                        // 0x58fc0
                        v49 = v58;
                        v48 = v57;
                        v47 = v55;
                        v46 = v56;
                        if (v62 == 0) {
                            goto lab_0x592c0;
                        }
                        // 0x58fc8
                        v60 = v62 - 1;
                        int32_t v67 = *v34; // 0x58fc8
                        v1 = v67;
                        if (*(int32_t *)(v67 + 4) <= v60) {
                            goto lab_0x5922c_2;
                        }
                        // 0x58fd8
                        v61 -= 4;
                        v59 = *(int32_t *)(*(int32_t *)v67 + v61);
                        v1 = v59;
                        if (v59 == 0) {
                            goto lab_0x5922c_2;
                        }
                    }
                    // 0x59370
                    __errno_location();
                    function_5df98(2, "src/rotater.c", 318, "nwirte[%d], overflow or errno[%d]");
                }
                // 0x59050
                function_5df98(2, "src/rotater.c", 450, "zlog_rotater_roll_files fail");
                goto lab_0x58ea0;
            }
        }
        case 2: {
            int32_t v68 = *v34; // 0x59098
            int32_t v69 = *(int32_t *)(v68 + 4); // 0x5909c
            v1 = v69;
            int32_t v70 = v69; // 0x590a8
            int32_t v71 = v68; // 0x590a8
            int32_t v72 = 0; // 0x590a8
            v43 = 0;
            if (v69 > 0) {
                while (true) {
                    int32_t v73 = v72;
                    int32_t v74 = v71;
                    int32_t v75 = *v7; // 0x590c0
                    int32_t v76 = v70 - v75; // 0x590c8
                    v1 = v76;
                    int32_t v77 = v74; // 0x590cc
                    if (v75 > 0 == v76 > v73) {
                        // 0x590d8
                        if (function_12090(*(int32_t *)(*(int32_t *)v74 + 4 * v73) + 4) != 0) {
                            // break -> 0x5946c
                            break;
                        }
                        // 0x590f4
                        v77 = *v34;
                    }
                    int32_t v78 = v77;
                    int32_t v79 = *(int32_t *)(v78 + 4); // 0x590b0
                    v1 = v79;
                    int32_t v80 = v73 + 1; // 0x590b4
                    v70 = v79;
                    v71 = v78;
                    v72 = v80;
                    if (v79 <= v80) {
                        // 0x59120
                        v43 = 0;
                        if (v79 < 1) {
                            goto lab_0x59150;
                        } else {
                            int32_t v81 = *(int32_t *)(4 * v79 - 4 + *(int32_t *)v78); // 0x59130
                            if (v81 == 0) {
                                // 0x595a0
                                function_5df98(2, "src/rotater.c", 256, "zc_arraylist_get fail");
                                // 0x591f0
                                function_5df98(2, "src/rotater.c", 456, "zlog_rotater_seq_files fail");
                                goto lab_0x58ea0;
                            } else {
                                int32_t v82 = *(int32_t *)v81; // 0x5913c
                                int32_t v83 = v79 - 1; // 0x59140
                                int32_t v84 = v83 < v82 ? v82 : v83;
                                v1 = v84;
                                v43 = v84 + 1;
                                goto lab_0x59150;
                            }
                        }
                    }
                }
                // 0x5946c
                __errno_location();
                function_5df98(2, "src/rotater.c", 246, "unlink[%s] fail, errno[%d]");
                // 0x591f0
                function_5df98(2, "src/rotater.c", 456, "zlog_rotater_seq_files fail");
                goto lab_0x58ea0;
            } else {
                goto lab_0x59150;
            }
        }
        default: {
            // 0x58e20
            function_585e4(a1);
            result = 0;
            goto lab_0x58a74;
        }
    }
  lab_0x59150:
    // 0x59150
    memset(&str7, 0, 1025);
    int32_t v85 = *(int32_t *)(a1 + 1072); // 0x59160
    int32_t v86 = *(int32_t *)(a1 + 1076); // 0x59170
    int32_t v87 = *(int32_t *)(a1 + 1068); // 0x59174
    v1 = v87;
    uint32_t chars_printed6 = snprintf((char *)&str7, 1025, "%.*s%0*d%s", v87, v35, v86, v43, (char *)(v85 + (int32_t)v35)); // 0x59194
    if (chars_printed6 >= 1024 == (chars_printed6 != 1024)) {
        // 0x59540
        __errno_location();
        function_5df98(2, "src/rotater.c", 272, "nwirte[%d], overflow or errno[%d]");
        // 0x591f0
        function_5df98(2, "src/rotater.c", 456, "zlog_rotater_seq_files fail");
        goto lab_0x58ea0;
    } else {
        // 0x591a4
        if (rename((char *)*file_path, (char *)&str7) == 0) {
            // 0x58e20
            function_585e4(a1);
            result = 0;
            goto lab_0x58a74;
        } else {
            // 0x591b8
            __errno_location();
            function_5df98(2, "src/rotater.c", 277, "rename[%s]->[%s] fail, errno[%d]");
            // 0x591f0
            function_5df98(2, "src/rotater.c", 456, "zlog_rotater_seq_files fail");
            goto lab_0x58ea0;
        }
    }
}

// Address range: 0x595c0 - 0x596b0
int32_t function_595c0(int32_t a1, int32_t a2) {
    // 0x595c0
    if (*(int32_t *)(a1 + 0x2084) == 0) {
        // 0x59660
        function_5df98(2, "src/rule.c", 386, "user defined record funcion for [%s] not set, no output");
        // 0x59634
        return -1;
    }
    // 0x595dc
    if (function_57a1c(*(int32_t *)(a1 + 0x1878), a2) == 0) {
        // 0x595f4
        *(char *)*(int32_t *)(*(int32_t *)(a2 + 28) + 4) = 0;
        function_5df98(2, "src/rule.c", 401, "a_rule->record fail");
    } else {
        // 0x5968c
        function_5df98(2, "src/rule.c", 391, "zlog_format_gen_msg fail");
    }
    // 0x59634
    return -1;
}

// Address range: 0x596b0 - 0x59954
int32_t function_596b0(int32_t a1, int32_t a2) {
    // 0x596b0
    int64_t v1; // 0x596b0
    uint64_t v2 = v1;
    if (function_57a1c(*(int32_t *)(a1 + 0x1878), a2) != 0) {
        // 0x5986c
        function_5df98(2, "src/rule.c", 84, "zlog_format_gen_msg fail");
        // 0x59790
        return -1;
    }
    char * v3 = (char *)(a1 + 0x1030); // 0x596e8
    int32_t v4; // 0x596b0
    int32_t v5; // 0x596b0
    int32_t v6; // 0x596b0
    int32_t fd3; // 0x596b0
    int64_t v7; // bp-144, 0x596b0
    int32_t * v8; // 0x59704
    int32_t fd2; // 0x59704
    int32_t v9; // 0x596b0
    int32_t v10; // 0x596b0
    if (__xstat64(3, v3, (struct stat64 *)&v7) == 0) {
        // 0x596f4
        v9 = v2;
        v10 = a1 + 0x1448;
        uint64_t v11 = *(int64_t *)v10; // 0x59700
        v8 = (int32_t *)(a1 + 0x1438);
        fd2 = *v8;
        if (v9 == (int32_t)v11) {
            if ((int32_t)(v2 / 0x100000000) == (int32_t)(v11 / 0x100000000)) {
                uint64_t v12 = 0x100000000 * v7 >> 32; // 0x59854
                uint64_t v13 = *(int64_t *)(a1 + 0x1440); // 0x59858
                if ((int32_t)v12 == (int32_t)v13) {
                    fd3 = fd2;
                    if ((int32_t)(v12 / 0x100000000) == (int32_t)(v13 / 0x100000000)) {
                        goto lab_0x59750;
                    } else {
                        goto lab_0x59714;
                    }
                } else {
                    goto lab_0x59714;
                }
            } else {
                goto lab_0x59714;
            }
        } else {
            goto lab_0x59714;
        }
    } else {
        // 0x5979c
        if (*__errno_location() != 2) {
            // 0x59890
            function_5df98(2, "src/rule.c", 91, "stat fail on [%s], errno[%d]");
            // 0x59790
            return -1;
        }
        int32_t * fd = (int32_t *)(a1 + 0x1438); // 0x597b0
        close(*fd);
        int32_t v14 = open64(v3, *(int32_t *)(a1 + 0x102c) | 1089); // 0x597cc
        *fd = v14;
        if (v14 < 0) {
            // 0x598f4
            function_5df98(2, "src/rule.c", 107, "open file[%s] fail, errno[%d]");
            // 0x59790
            return -1;
        }
        // 0x597dc
        if (__xstat64(3, v3, (struct stat64 *)&v7) != 0) {
            // 0x59924
            function_5df98(2, "src/rule.c", 114, "stat fail on new file[%s], errno[%d]");
            // 0x59790
            return -1;
        }
        // 0x597f4
        v4 = a1 + 0x1448;
        v5 = v2;
        v6 = *fd;
        goto lab_0x5973c;
    }
  lab_0x59714:
    // 0x59714
    close(fd2);
    int32_t v15 = open64(v3, *(int32_t *)(a1 + 0x102c) | 1089); // 0x5972c
    *v8 = v15;
    v4 = v10;
    v5 = v9;
    v6 = v15;
    if (v15 < 0) {
        // 0x598ec
        __errno_location();
        // 0x598f4
        function_5df98(2, "src/rule.c", 107, "open file[%s] fail, errno[%d]");
        // 0x59790
        return -1;
    }
    goto lab_0x5973c;
  lab_0x5973c:;
    uint64_t v16 = 0x100000000 * v7 >> 32; // 0x5973c
    *(int32_t *)(a1 + 0x1440) = (int32_t)(v16 / 0x100000000);
    *(int32_t *)(a1 + 0x1444) = (int32_t)v16;
    *(int32_t *)v4 = (int32_t)(v2 / 0x100000000);
    *(int32_t *)(a1 + 0x144c) = v5;
    fd3 = v6;
    goto lab_0x59750;
  lab_0x59750:;
    int32_t v17 = *(int32_t *)(a2 + 28); // 0x59750
    int32_t buf = *(int32_t *)v17; // 0x59754
    if (write(fd3, (int32_t *)buf, *(int32_t *)(v17 + 4) - buf) < 0) {
        // 0x598bc
        __errno_location();
        function_5df98(2, "src/rule.c", 125, "write fail, errno[%d]");
        // 0x59790
        return -1;
    }
    uint32_t v18 = *(int32_t *)(a1 + 0x1868); // 0x59770
    if (v18 == 0) {
        // 0x59790
        return 0;
    }
    int32_t * v19 = (int32_t *)(a1 + 0x186c); // 0x5977c
    uint32_t v20 = *v19 + 1; // 0x59780
    if (v18 >= v20 == (v18 != v20)) {
        *v19 = v20;
    }
    if (v18 != v20 && v18 >= v20) {
        // 0x59790
        return 0;
    }
    // 0x59804
    *v19 = 0;
    int32_t result = 0; // 0x59818
    if (function_11ee0(*(int32_t *)(a1 + 0x1438)) != 0) {
        // 0x5981c
        __errno_location();
        function_5df98(2, "src/rule.c", 133, "fsync[%d] fail, errno[%d]");
        result = 0;
    }
    // 0x59790
    return result;
}

// Address range: 0x59954 - 0x59a0c
int32_t function_59954(int32_t a1, int32_t a2) {
    int32_t * v1 = (int32_t *)(a1 + 0x185c); // 0x5995c
    int32_t v2 = *v1; // 0x5995c
    if (v2 == 0) {
        // 0x59a00
        return a1 + 0x1458;
    }
    int32_t * v3 = (int32_t *)(a2 + 20); // 0x59968
    int32_t v4 = *v3; // 0x59968
    int32_t v5 = *(int32_t *)v4; // 0x59974
    *(int32_t *)(v4 + 4) = v5;
    int32_t v6 = v2; // 0x59984
    int32_t v7 = 0; // 0x59984
    int32_t v8 = v5; // 0x59984
    if (*(int32_t *)(v2 + 4) <= 0) {
      lab_0x599ec:
        // 0x599ec
        *(char *)v8 = 0;
        return *(int32_t *)*v3;
    }
    while (*(int32_t *)(*(int32_t *)v6 + 4 * v7) == 0) {
        // 0x5998c
        v7++;
        v6 = *v1;
        if (*(int32_t *)(v6 + 4) <= v7) {
            // 0x599e4
            v8 = *(int32_t *)(*v3 + 4);
            goto lab_0x599ec;
        }
    }
    // 0x599c0
    function_5df98(2, "src/rule.c", 151, "zlog_spec_gen_path fail");
    return 0;
}

// Address range: 0x59a0c - 0x59cd4
int32_t function_59a0c(int32_t a1, int32_t a2) {
    // 0x59a0c
    int64_t v1; // 0x59a0c
    uint64_t v2 = v1;
    if (function_57a1c(*(int32_t *)(a1 + 0x1878), a2) != 0) {
        // 0x59c14
        function_5df98(2, "src/rule.c", 167, "zlog_format_gen_msg fail");
        // 0x59adc
        return -1;
    }
    int32_t v3 = a1 + 0x1030; // 0x59a38
    char * v4 = (char *)v3; // 0x59a4c
    int32_t fd = open64(v4, *(int32_t *)(a1 + 0x102c) | 1089); // 0x59a4c
    if (fd < 0) {
        // 0x59c38
        __errno_location();
        function_5df98(2, "src/rule.c", 174, "open file[%s] fail, errno[%d]");
        // 0x59adc
        return -1;
    }
    int32_t v5 = *(int32_t *)(a2 + 28); // 0x59a58
    int32_t buf = *(int32_t *)v5; // 0x59a5c
    uint32_t nbyte = *(int32_t *)(v5 + 4) - buf; // 0x59a60
    if (write(fd, (int32_t *)buf, nbyte) < 0) {
        // 0x59c6c
        __errno_location();
        function_5df98(2, "src/rule.c", 180, "write fail, errno[%d]");
        close(fd);
        // 0x59adc
        return -1;
    }
    uint32_t v6 = *(int32_t *)(a1 + 0x1868); // 0x59a78
    if (v6 != 0) {
        int32_t * v7 = (int32_t *)(a1 + 0x186c); // 0x59ae8
        uint32_t v8 = *v7 + 1; // 0x59aec
        if (v6 >= v8 == (v6 != v8)) {
            // .thread
            *v7 = v8;
        } else {
            // 0x59afc
            *v7 = 0;
            if (function_11ee0(fd) != 0) {
                // 0x59b10
                __errno_location();
                function_5df98(2, "src/rule.c", 187, "fsync[%d] fail, errno[%d]");
            }
        }
    }
    // 0x59a84
    if (close(fd) < 0) {
        // 0x59ca4
        __errno_location();
        function_5df98(2, "src/rule.c", 191, "close fail, maybe cause by write, errno[%d]");
        // 0x59adc
        return -1;
    }
    int32_t * v9 = (int32_t *)(a1 + 0x1450); // 0x59a94
    if (*v9 < nbyte) {
        // 0x59b40
        function_5df98(0, "src/rule.c", 197, "one msg's len[%ld] > archive_max_size[%ld], no rotate");
        return 0;
    }
    // 0x59aa0
    int32_t v10; // bp-136, 0x59a0c
    if (__xstat64(3, v4, (struct stat64 *)&v10) != 0) {
        // 0x59b70
        __errno_location();
        function_5df98(1, "src/rule.c", 202, "stat [%s] fail, errno[%d], maybe in rotating");
        return 0;
    }
    uint32_t v11 = *v9; // 0x59ab8
    uint32_t v12 = (int32_t)(v2 / 0x100000000); // 0x59abc
    uint32_t v13 = nbyte + v12; // 0x59ac4
    if ((((int32_t)(v13 < v12) + (int32_t)v2 + (int32_t)(v11 < 0)) % 2 != 0) < (v13 < v11)) {
        // 0x59adc
        return 0;
    }
    int32_t v14 = *(int32_t *)(g461 + 0x1428); // 0x59bc0
    int32_t v15 = function_59954(a1, a2); // 0x59bc4
    int32_t result = 0; // 0x59bec
    if (function_58958(v14, v3, nbyte, v15, *v9, *(int32_t *)(a1 + 0x1454)) != 0) {
        // 0x59bf0
        function_5df98(2, "src/rule.c", 214, "zlog_rotater_rotate fail");
        result = -1;
    }
    // 0x59adc
    return result;
}

// Address range: 0x59cd4 - 0x59e54
int32_t function_59cd4(int32_t a1, int32_t a2) {
    // 0x59cd4
    if (*(int32_t *)(a1 + 0x2084) == 0) {
        // 0x59e04
        function_5df98(2, "src/rule.c", 413, "user defined record funcion for [%s] not set, no output");
        // 0x59dd8
        return -1;
    }
    int32_t * v1 = (int32_t *)(a2 + 16); // 0x59cf0
    int32_t v2 = *v1; // 0x59cf0
    int32_t * v3 = (int32_t *)(a1 + 0x1434); // 0x59cf4
    int32_t v4 = *v3; // 0x59cf4
    int32_t v5 = *(int32_t *)v2; // 0x59cfc
    *(int32_t *)(v2 + 4) = v5;
    int32_t v6 = v4; // 0x59d10
    int32_t v7 = 0; // 0x59d10
    int32_t v8 = v5; // 0x59d10
    if (*(int32_t *)(v4 + 4) <= 0) {
        goto lab_0x59d7c;
      lab_0x59d7c:
        // 0x59d7c
        *(char *)v8 = 0;
        if (function_57a1c(*(int32_t *)(a1 + 0x1878), a2) == 0) {
            // 0x59d98
            *(char *)*(int32_t *)(*(int32_t *)(a2 + 28) + 4) = 0;
            function_5df98(2, "src/rule.c", 430, "a_rule->record fail");
        } else {
            // 0x59e30
            function_5df98(2, "src/rule.c", 420, "zlog_format_gen_msg fail");
        }
        // 0x59dd8
        return -1;
    }
    while (*(int32_t *)(*(int32_t *)v6 + 4 * v7) == 0) {
        // 0x59d18
        v7++;
        v6 = *v3;
        if (v7 >= *(int32_t *)(v6 + 4)) {
            // 0x59d74
            v8 = *(int32_t *)(*v1 + 4);
            goto lab_0x59d7c;
        }
    }
    // 0x59d4c
    function_5df98(2, "src/rule.c", 417, "zlog_spec_gen_path fail");
    return -1;
}

// Address range: 0x59e54 - 0x59ef8
int32_t function_59e54(int32_t a1, int32_t a2) {
    // 0x59e54
    if (function_57a1c(*(int32_t *)(a1 + 0x1878), a2) != 0) {
        // 0x59ea4
        function_5df98(2, "src/rule.c", 459, "zlog_format_gen_msg fail");
        // 0x59e98
        return -1;
    }
    int32_t v1 = *(int32_t *)(a2 + 28); // 0x59e74
    int32_t buf = *(int32_t *)v1; // 0x59e7c
    int32_t result = 0; // 0x59e94
    if (write(2, (int32_t *)buf, *(int32_t *)(v1 + 4) - buf) < 0) {
        // 0x59ec8
        __errno_location();
        function_5df98(2, "src/rule.c", 465, "write fail, errno[%d]");
        result = -1;
    }
    // 0x59e98
    return result;
}

// Address range: 0x59ef8 - 0x59f9c
int32_t function_59ef8(int32_t a1, int32_t a2) {
    // 0x59ef8
    if (function_57a1c(*(int32_t *)(a1 + 0x1878), a2) != 0) {
        // 0x59f48
        function_5df98(2, "src/rule.c", 441, "zlog_format_gen_msg fail");
        // 0x59f3c
        return -1;
    }
    int32_t v1 = *(int32_t *)(a2 + 28); // 0x59f18
    int32_t buf = *(int32_t *)v1; // 0x59f20
    int32_t result = 0; // 0x59f38
    if (write(1, (int32_t *)buf, *(int32_t *)(v1 + 4) - buf) < 0) {
        // 0x59f6c
        __errno_location();
        function_5df98(2, "src/rule.c", 447, "write fail, errno[%d]");
        result = -1;
    }
    // 0x59f3c
    return result;
}

// Address range: 0x59f9c - 0x5a040
int32_t function_59f9c(int32_t a1, int32_t a2) {
    // 0x59f9c
    if (function_57a1c(*(int32_t *)(a1 + 0x1878), a2) != 0) {
        // 0x59fec
        function_5df98(2, "src/rule.c", 345, "zlog_format_gen_msg fail");
        // 0x59fe0
        return -1;
    }
    int32_t v1 = *(int32_t *)(a2 + 28); // 0x59fbc
    int32_t buf = *(int32_t *)v1; // 0x59fc4
    int32_t v2 = *(int32_t *)(v1 + 4); // 0x59fc8
    int32_t result = 0; // 0x59fdc
    if (write(*(int32_t *)(a1 + 0x1864), (int32_t *)buf, v2 - buf) < 0) {
        // 0x5a010
        __errno_location();
        function_5df98(2, "src/rule.c", 352, "write fail, errno[%d]");
        result = -1;
    }
    // 0x59fe0
    return result;
}

// Address range: 0x5a040 - 0x5a0d4
int32_t function_5a040(int32_t a1, int32_t a2) {
    // 0x5a040
    int32_t result; // 0x5a040
    if (function_57a1c(*(int32_t *)(a1 + 0x1878), a2) == 0) {
        int32_t v1 = *(int32_t *)(g461 + 0x2440); // 0x5a074
        int32_t v2 = function_57d70(v1, *(int32_t *)(*(int32_t *)(a2 + 8) + 292)); // 0x5a078
        int32_t * v3 = (int32_t *)(a2 + 28); // 0x5a07c
        *(char *)*(int32_t *)(*v3 + 4) = 0;
        int32_t v4 = *(int32_t *)(a1 + 0x1874); // 0x5a098
        int32_t v5 = *(int32_t *)*v3; // 0x5a09c
        syslog(v4 | *(int32_t *)(v2 + 2060), "%s", (char *)v5);
        result = 0;
    } else {
        // 0x5a0b0
        function_5df98(2, "src/rule.c", 364, "zlog_format_gen_msg fail");
        result = -1;
    }
    // 0x5a0a8
    return result;
}

// Address range: 0x5a0d4 - 0x5a30c
int32_t function_5a0d4(int32_t a1, int32_t a2) {
    int32_t * v1 = (int32_t *)(a1 + 0x1434); // 0x5a0dc
    int32_t v2 = *v1; // 0x5a0dc
    int32_t * v3 = (int32_t *)(a2 + 16); // 0x5a0e8
    int32_t v4 = *v3; // 0x5a0e8
    int32_t v5 = *(int32_t *)v4; // 0x5a0f0
    *(int32_t *)(v4 + 4) = v5;
    int32_t v6 = v2; // 0x5a100
    int32_t v7 = 0; // 0x5a100
    int32_t v8 = v5; // 0x5a100
    if (*(int32_t *)(v2 + 4) > 0) {
        while (*(int32_t *)(*(int32_t *)v6 + 4 * v7) == 0) {
            // 0x5a108
            v7++;
            v6 = *v1;
            if (*(int32_t *)(v6 + 4) <= v7) {
                // 0x5a168
                v8 = *(int32_t *)(*v3 + 4);
                goto lab_0x5a170;
            }
        }
        // 0x5a13c
        function_5df98(2, "src/rule.c", 245, "zlog_spec_gen_path fail");
        // 0x5a15c
        return -1;
    }
    goto lab_0x5a170;
  lab_0x5a170:
    // 0x5a170
    *(char *)v8 = 0;
    if (function_57a1c(*(int32_t *)(a1 + 0x1878), a2) != 0) {
        // 0x5a274
        function_5df98(2, "src/rule.c", 248, "zlog_format_output fail");
        // 0x5a15c
        return -1;
    }
    int32_t v9 = *(int32_t *)*v3; // 0x5a1a0
    int32_t fd = open64((char *)v9, *(int32_t *)(a1 + 0x102c) | 1089); // 0x5a1a4
    if (fd < 0) {
        // 0x5a298
        __errno_location();
        function_5df98(2, "src/rule.c", 255, "open file[%s] fail, errno[%d]");
        // 0x5a15c
        return -1;
    }
    int32_t v10 = *(int32_t *)(a2 + 28); // 0x5a1b0
    int32_t buf = *(int32_t *)v10; // 0x5a1b4
    if (write(fd, (int32_t *)buf, *(int32_t *)(v10 + 4) - buf) < 0) {
        // 0x5a2d4
        __errno_location();
        function_5df98(2, "src/rule.c", 260, "write fail, errno[%d]");
        close(fd);
        // 0x5a15c
        return -1;
    }
    uint32_t v11 = *(int32_t *)(a1 + 0x1868); // 0x5a1d0
    if (v11 != 0) {
        int32_t * v12 = (int32_t *)(a1 + 0x186c); // 0x5a1dc
        uint32_t v13 = *v12 + 1; // 0x5a1e0
        if (v11 >= v13 == (v11 != v13)) {
            *v12 = v13;
        }
        if (v11 == v13 || v11 < v13) {
            // 0x5a230
            *v12 = 0;
            if (function_11ee0(fd) != 0) {
                // 0x5a244
                __errno_location();
                function_5df98(2, "src/rule.c", 267, "fsync[%d] fail, errno[%d]");
            }
        }
    }
    int32_t result = 0; // 0x5a1fc
    if (close(fd) < 0) {
        // 0x5a200
        __errno_location();
        function_5df98(2, "src/rule.c", 271, "close fail, maybe cause by write, errno[%d]");
        result = -1;
    }
    // 0x5a15c
    return result;
}

// Address range: 0x5a30c - 0x5a66c
int32_t function_5a30c(int32_t a1, int32_t a2) {
    // 0x5a30c
    int64_t v1; // 0x5a30c
    uint64_t v2 = v1;
    int32_t * v3 = (int32_t *)(a1 + 0x1434); // 0x5a314
    int32_t v4 = *v3; // 0x5a314
    int32_t * v5 = (int32_t *)(a2 + 16); // 0x5a324
    int32_t v6 = *v5; // 0x5a324
    int32_t v7 = *(int32_t *)v6; // 0x5a32c
    *(int32_t *)(v6 + 4) = v7;
    int32_t v8 = v4; // 0x5a33c
    int32_t v9 = 0; // 0x5a33c
    int32_t v10 = v7; // 0x5a33c
    if (*(int32_t *)(v4 + 4) > 0) {
        while (*(int32_t *)(*(int32_t *)v8 + 4 * v9) == 0) {
            // 0x5a344
            v9++;
            v8 = *v3;
            if (*(int32_t *)(v8 + 4) <= v9) {
                // 0x5a3a4
                v10 = *(int32_t *)(*v5 + 4);
                goto lab_0x5a3ac;
            }
        }
        // 0x5a378
        function_5df98(2, "src/rule.c", 285, "zlog_spec_gen_path fail");
        // 0x5a398
        return -1;
    }
    goto lab_0x5a3ac;
  lab_0x5a3ac:
    // 0x5a3ac
    *(char *)v10 = 0;
    if (function_57a1c(*(int32_t *)(a1 + 0x1878), a2) != 0) {
        // 0x5a5d4
        function_5df98(2, "src/rule.c", 288, "zlog_format_output fail");
        // 0x5a398
        return -1;
    }
    int32_t v11 = *(int32_t *)*v5; // 0x5a3d4
    char * v12 = (char *)v11; // 0x5a3e4
    int32_t fd = open64(v12, *(int32_t *)(a1 + 0x102c) | 1089); // 0x5a3e4
    if (fd < 0) {
        // 0x5a5f8
        __errno_location();
        function_5df98(2, "src/rule.c", 295, "open file[%s] fail, errno[%d]");
        // 0x5a398
        return -1;
    }
    int32_t v13 = *(int32_t *)(a2 + 28); // 0x5a3f0
    int32_t buf = *(int32_t *)v13; // 0x5a3f4
    uint32_t nbyte = *(int32_t *)(v13 + 4) - buf; // 0x5a3f8
    if (write(fd, (int32_t *)buf, nbyte) < 0) {
        // 0x5a634
        __errno_location();
        function_5df98(2, "src/rule.c", 301, "write fail, errno[%d]");
        close(fd);
        // 0x5a398
        return -1;
    }
    uint32_t v14 = *(int32_t *)(a1 + 0x1868); // 0x5a410
    if (v14 != 0) {
        int32_t * v15 = (int32_t *)(a1 + 0x186c); // 0x5a41c
        uint32_t v16 = *v15 + 1; // 0x5a420
        if (v14 >= v16 == (v14 != v16)) {
            *v15 = v16;
        }
        if (v14 == v16 || v14 < v16) {
            // 0x5a4c4
            *v15 = 0;
            if (function_11ee0(fd) != 0) {
                // 0x5a4d8
                __errno_location();
                function_5df98(2, "src/rule.c", 308, "fsync[%d] fail, errno[%d]");
            }
        }
    }
    // 0x5a430
    if (close(fd) < 0) {
        // 0x5a5a4
        __errno_location();
        function_5df98(2, "src/rule.c", 312, "write fail, maybe cause by write, errno[%d]");
        // 0x5a398
        return -1;
    }
    int32_t * v17 = (int32_t *)(a1 + 0x1450); // 0x5a440
    uint32_t v18 = *v17; // 0x5a440
    if (nbyte >= v18 == (nbyte != v18)) {
        // 0x5a494
        function_5df98(0, "src/rule.c", 318, "one msg's len[%ld] > archive_max_size[%ld], no rotate");
        return 0;
    }
    // 0x5a44c
    int32_t v19; // bp-144, 0x5a30c
    if (__xstat64(3, v12, (struct stat64 *)&v19) != 0) {
        // 0x5a508
        __errno_location();
        function_5df98(1, "src/rule.c", 323, "stat [%s] fail, errno[%d], maybe in rotating");
        // 0x5a398
        return 0;
    }
    uint32_t v20 = *v17; // 0x5a464
    uint32_t v21 = (int32_t)(v2 / 0x100000000); // 0x5a468
    uint32_t v22 = nbyte + v21; // 0x5a470
    if ((((int32_t)(v22 < v21) + (int32_t)v2 + (int32_t)(v20 < 0)) % 2 != 0) < (v22 < v20)) {
        // 0x5a398
        return 0;
    }
    int32_t v23 = *(int32_t *)(g461 + 0x1428); // 0x5a550
    int32_t v24 = function_59954(a1, a2); // 0x5a554
    int32_t result = 0; // 0x5a57c
    if (function_58958(v23, v11, nbyte, v24, *v17, *(int32_t *)(a1 + 0x1454)) != 0) {
        // 0x5a580
        function_5df98(2, "src/rule.c", 335, "zlog_rotater_rotate fail");
        result = -1;
    }
    // 0x5a398
    return result;
}

// Address range: 0x5a66c - 0x5a850
int32_t function_5a66c(int32_t * a1, int32_t str2, int32_t a3, int32_t a4) {
    int32_t str = (int32_t)a1 + 1; // 0x5a670
    char * found_char_pos = strrchr((char *)str, 34); // 0x5a690
    char * v1 = found_char_pos; // bp-28, 0x5a698
    if (found_char_pos == NULL) {
        // 0x5a828
        function_5df98(2, "src/rule.c", 516, "matching \" not found in conf line[%s]");
        // 0x5a764
        return -1;
    }
    uint32_t v2 = (int32_t)found_char_pos - str; // 0x5a6a0
    if (v2 >= 1024 == (v2 != 1024)) {
        // 0x5a7c4
        function_5df98(2, "src/rule.c", 521, "file_path too long %ld > %ld");
        // 0x5a764
        return -1;
    }
    // 0x5a6ac
    function_11fc4((int32_t *)str2, str, (char)v2, a4);
    if (function_5e310(str2, 1025) != 0) {
        // 0x5a804
        function_5df98(2, "src/rule.c", 528, "zc_str_replace_env fail");
        // 0x5a764
        return -1;
    }
    // 0x5a6cc
    if (strchr((char *)str2, 37) == NULL) {
        // 0x5a764
        return 0;
    }
    int32_t v3 = function_5d4c0(0x5c6f4); // 0x5a6e8
    int32_t v4; // 0x5a66c
    if ((char)v4 == 0) {
        // 0x5a770
        *(int32_t *)a3 = v3;
        return 0;
    }
    int32_t v5 = function_5c758(str2, (int32_t *)&v1, a4); // 0x5a728
    while (v5 != 0) {
        // 0x5a700
        if (function_5d694(v3, v5) != 0) {
            // 0x5a780
            function_5df98(2, "src/rule.c", 551, "zc_arraylist_add fail");
            if (v3 == 0) {
                // 0x5a7ac
                function_5c6f4(v5);
                return -1;
            }
            // 0x5a7a4
            function_5d580(v3);
            // 0x5a7ac
            function_5c6f4(v5);
            return -1;
        }
        // 0x5a70c
        if (*v1 == 0) {
            // 0x5a770
            *(int32_t *)a3 = v3;
            return 0;
        }
        v5 = function_5c758((int32_t)v1, (int32_t *)&v1, a4);
    }
    // 0x5a73c
    function_5df98(2, "src/rule.c", 546, "zlog_spec_new fail");
    if (v3 != 0) {
        // 0x5a7f4
        function_5d580(v3);
    }
    // 0x5a764
    return -1;
}

// Address range: 0x5a850 - 0x5a97c
int32_t function_5a850(int32_t a1, int32_t a2) {
    if (a1 == 0) {
        // 0x5a960
        return function_5df98(2, "src/rule.c", 39, "a_rule is null or 0");
    }
    int32_t result = function_5df98(a2, "src/rule.c", 65, "---rule:[%p][%s%c%d]-[%d,%d][%s,%p,%d:%ld*%d~%s][%d][%d][%s:%s:%p];[%p]---"); // 0x5a914
    int32_t * v1 = (int32_t *)(a1 + 0x1434); // 0x5a918
    int32_t v2 = *v1; // 0x5a918
    if (v2 == 0) {
        // 0x5a958
        return result;
    }
    // 0x5a924
    if (*(int32_t *)(v2 + 4) < 1) {
        // 0x5a958
        return result;
    }
    int32_t v3 = 0;
    int32_t v4 = v3 + 1; // 0x5a940
    int32_t result2 = function_5c630(*(int32_t *)(*(int32_t *)v2 + 4 * v3), a2); // 0x5a944
    int32_t v5 = *v1; // 0x5a948
    while (*(int32_t *)(v5 + 4) > v4) {
        // 0x5a934
        v3 = v4;
        v4 = v3 + 1;
        result2 = function_5c630(*(int32_t *)(*(int32_t *)v5 + 4 * v3), a2);
        v5 = *v1;
    }
    // 0x5a958
    return result2;
}

// Address range: 0x5a97c - 0x5aa9c
int32_t function_5a97c(int32_t a1) {
    if (a1 == 0) {
        // 0x5aa78
        return function_5df98(2, "src/rule.c", 942, "a_rule is null or 0");
    }
    int32_t * v1 = (int32_t *)(a1 + 0x1434); // 0x5a990
    int32_t v2 = *v1; // 0x5a990
    if (v2 != 0) {
        // 0x5a99c
        function_5d580(v2);
        *v1 = 0;
    }
    int32_t fd = *(int32_t *)(a1 + 0x1438); // 0x5a9a8
    if (fd != 0) {
        // 0x5aa14
        if (close(fd) != 0) {
            // 0x5aa20
            __errno_location();
            function_5df98(2, "src/rule.c", 949, "close fail, maybe cause by write, errno[%d]");
        }
    }
    int32_t stream = *(int32_t *)(a1 + 0x1860); // 0x5a9b4
    if (stream != 0) {
        // 0x5a9c0
        if (pclose((struct _IO_FILE *)stream) == -1) {
            // 0x5aa4c
            __errno_location();
            function_5df98(2, "src/rule.c", 954, "pclose fail, errno[%d]");
        }
    }
    int32_t * v3 = (int32_t *)(a1 + 0x185c); // 0x5a9cc
    int32_t v4 = *v3; // 0x5a9cc
    if (v4 != 0) {
        // 0x5a9d8
        function_5d580(v4);
        *v3 = 0;
    }
    // 0x5a9e4
    function_5df98(0, "src/rule.c", 961, "zlog_rule_del[%p]");
    return free(a1, (int32_t)"src/rule.c", 961, (int32_t)"zlog_rule_del[%p]");
}

// Address range: 0x5aa9c - 0x5babc
int32_t function_5aa9c(int32_t * a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    int32_t v1 = a4;
    int32_t result = (int32_t)a1;
    int32_t v2 = 0; // bp-28852, 0x5aab0
    if (a1 == NULL) {
        // 0x5b5b4
        function_5df98(2, "src/rule.c", 592, "line is null or 0");
        // 0x5afe8
        return result;
    }
    if (a3 == 0) {
        // 0x5b5d8
        function_5df98(2, "src/rule.c", 593, "default_format is null or 0");
        // 0x5afe8
        return 0;
    }
    // 0x5aac4
    if (v1 == 0) {
        // 0x5b4cc
        function_5df98(2, "src/rule.c", 594, "formats is null or 0");
        // 0x5afe8
        return 0;
    }
    int32_t str = function_11eb0(1, 0x2088, a3, v1); // 0x5aadc
    if (str == 0) {
        // 0x5b4f0
        __errno_location();
        function_5df98(2, "src/rule.c", 598, "calloc fail, errno[%d]");
        // 0x5afe8
        return 0;
    }
    // 0x5aae8
    *(int32_t *)(str + 0x1028) = a5;
    int32_t * v3 = (int32_t *)(str + 0x1868); // 0x5ab14
    *v3 = a6;
    int32_t v4; // bp-28740, 0x5aa9c
    memset(&v4, 0, 0x1001);
    if (sscanf2(result, "%s %n", &v4, (int32_t)&v2) != 1) {
        // 0x5b0d8
        function_5df98(2, "src/rule.c", 612, "sscanf [%s] fail, selector");
        // 0x5afdc
        function_5a97c(str);
        // 0x5afe8
        return 0;
    }
    // 0x5ab3c
    int32_t str2; // bp-24640, 0x5aa9c
    memset(&str2, 0, 0x1001);
    int32_t v5; // bp-20540, 0x5aa9c
    memset(&v5, 0, 0x1001);
    int32_t v6 = &v5; // 0x5ab70
    if (sscanf2((int32_t)&v4, " %[^.].%s", &str2, v6) != 2) {
        // 0x5b22c
        function_5df98(2, "src/rule.c", 627, "sscanf [%s] fail, category or level is null");
      lab_0x5afdc:
        // 0x5afdc
        function_5a97c(str);
        // 0x5afe8
        return 0;
    }
    int32_t v7 = &str2; // 0x5ab8c
    v1 = v7;
    int32_t v8 = str2 % 256; // 0x5ab90
    int32_t v9; // 0x5aa9c
    int32_t v10; // 0x5aa9c
    int32_t v11; // 0x5aa9c
    char v12; // 0x5aa9c
    int16_t * v13; // 0x5aba0
    if (v8 != 0) {
        // 0x5ab9c
        v13 = *__ctype_b_loc();
        v9 = v7;
        v10 = v8;
        while (true) {
          lab_0x5aba8:
            // 0x5aba8
            v11 = v10;
            v12 = v11;
            switch (v12) {
                case 95: {
                    goto lab_dec_label_pc_0x5abb8;
                }
                case 45: {
                    goto lab_dec_label_pc_0x5abb8;
                }
                default: {
                    v1 = 1;
                    goto lab_dec_label_pc_0x5abb8;
                }
            }
        }
      lab_0x5b204:
        // 0x5b204
        function_5df98(2, "src/rule.c", 634, "category name[%s] character is not in [a-Z][0-9][_!*-]");
        // 0x5afdc
        function_5a97c(str);
        // 0x5afe8
        return 0;
    }
  lab_0x5abf0:
    // 0x5abf0
    strcpy((char *)str, (char *)&str2);
    v1 = v5 % 256;
    char v14 = v5;
    char * v15; // 0x5aa9c
    int32_t v16; // 0x5aa9c
    switch (v14) {
        case 42: {
            char * v17 = (char *)(str + 0x1001);
            *v17 = 42;
            v15 = v17;
            v16 = v6;
            // break -> 0x5ac44
            break;
        }
        case 61: {
        }
        case 33: {
            char * v18 = (char *)(str + 0x1001);
            *v18 = v14;
            v15 = v18;
            int32_t v19; // bp-20539, 0x5aa9c
            v16 = &v19;
            // break -> 0x5ac44
            break;
        }
        default: {
            char * v20 = (char *)(str + 0x1001);
            *v20 = 46;
            v15 = v20;
            v16 = v6;
            // break -> 0x5ac44
            break;
        }
    }
    int32_t v21 = function_57de4(a2, (int32_t *)v16); // 0x5ac48
    unsigned char v22 = *v15; // 0x5ac4c
    *(int32_t *)(str + 0x1004) = v21;
    int32_t v23 = (int32_t)v22 - 33; // 0x5ac58
    v1 = v23;
    g472 = v23;
    switch (v22) {
        case 33: {
            // 0x5b008
            memset((int32_t *)(str + 0x1008), 255, 32);
            int32_t v24 = -v21; // 0x5b028
            int32_t v25 = v21 / 128 + str; // 0x5b02c
            v1 = v25;
            char * v26 = (char *)(v25 + 0x1008); // 0x5b03c
            *v26 = *v26 & -1 - (char)(1 << 7 - (v24 < 0 ? v21 % 8 : -((v24 % 8))));
            // break -> 0x5ad40
            break;
        }
        case 61: {
            // 0x5b06c
            memset((int32_t *)(str + 0x1008), 0, 32);
            int32_t v27 = -v21; // 0x5b08c
            int32_t v28 = v21 / 128 + str; // 0x5b090
            v1 = v28;
            char * v29 = (char *)(v28 + 0x1008); // 0x5b0a0
            *v29 = *v29 | (char)(1 << 7 - (v27 < 0 ? v21 % 8 : -((v27 % 8))));
            // break -> 0x5ad40
            break;
        }
        case 46: {
            int32_t v30 = str + 0x1008;
            memset((int32_t *)v30, 0, 32);
            int32_t v31 = -v21; // 0x5ad00
            int32_t v32 = v21 / 128; // 0x5ad04
            int32_t v33 = v31 % 8; // 0x5ad08
            v1 = v33;
            char * v34 = (char *)(v32 + v30); // 0x5ad18
            *v34 = *v34 | -1 - (char)(255 << 8 - (v31 < 0 ? v21 % 8 : -v33));
            memset((int32_t *)(str + 0x1009 + v32), 255, 31 - v32);
            // break -> 0x5ad40
            break;
        }
        case 42: {
            // 0x5b054
            memset((int32_t *)(str + 0x1008), 255, 32);
            // break -> 0x5ad40
            break;
        }
    }
    // 0x5ad40
    int32_t str3; // bp-16440, 0x5aa9c
    memset(&str3, 0, 0x1001);
    int32_t v35; // bp-12340, 0x5aa9c
    memset(&v35, 0, 0x1001);
    int32_t v36 = &v35; // 0x5ad74
    if (sscanf2(v2 + result, " %[^;];%s", &str3, v36) < 1) {
        // 0x5b7f0
        function_5df98(2, "src/rule.c", 700, "sscanf [%s] fail");
        // 0x5afdc
        function_5a97c(str);
        // 0x5afe8
        return 0;
    }
    int32_t v37 = &str3; // 0x5ad78
    v1 = v36;
    if (v35 % 256 == 0) {
        // 0x5b0b8
        v1 = (int32_t)"no format specified, use default";
        function_5df98(0, "src/rule.c", 706, "no format specified, use default");
        *(int32_t *)(str + 0x1878) = a3;
    } else {
        uint64_t v38 = *(int64_t *)&v1; // 0x5ada4
        int32_t v39 = v38;
        if (v39 < 1) {
            // 0x5afb4
            function_5df98(2, "src/rule.c", 722, "in conf file can't find format[%s], pls check");
            // 0x5afdc
            function_5a97c(str);
            // 0x5afe8
            return 0;
        }
        int32_t v40 = v38 / 0x100000000; // 0x5ada4
        int32_t v41 = *(int32_t *)v40; // 0x5adc4
        int32_t v42 = function_11eec(v41, (char *)&v35, v37, v39); // 0x5add8
        int32_t v43 = 1; // 0x5ade0
        int32_t v44 = v40; // 0x5ade0
        int32_t v45 = v41; // 0x5ade0
        if (v42 != 0) {
            while (v43 != v39) {
                int32_t v46 = v44 + 4; // 0x5adc4
                int32_t v47 = *(int32_t *)v46; // 0x5adc4
                int32_t v48 = function_11eec(v47, (char *)&v35, v37, v1); // 0x5add8
                v43++;
                v44 = v46;
                v45 = v47;
                if (v48 == 0) {
                    goto lab_0x5ade4;
                }
            }
            // 0x5afb4
            function_5df98(2, "src/rule.c", 722, "in conf file can't find format[%s], pls check");
            // 0x5afdc
            function_5a97c(str);
            // 0x5afe8
            return 0;
        }
      lab_0x5ade4:
        // 0x5ade4
        *(int32_t *)(str + 0x1878) = v45;
    }
    // 0x5ade8
    int32_t v49; // bp-8240, 0x5aa9c
    memset(&v49, 0, 0x1001);
    if (sscanf2(v37, " %[^,],", &v49, v1) < 1) {
        // 0x5b814
        function_5df98(2, "src/rule.c", 734, "sscanf [%s] fail");
        // 0x5afdc
        function_5a97c(str);
        // 0x5afe8
        return 0;
    }
    char * found_char_pos = strchr((char *)&str3, 44); // 0x5ae2c
    int32_t v50 = (int32_t)found_char_pos; // 0x5ae2c
    uint32_t v51 = v49 % 256; // 0x5ae3c
    int32_t * v52; // 0x5aa9c
    int32_t str9; // 0x5aa9c
    int32_t v53; // 0x5aa9c
    int32_t str7; // 0x5aa9c
    char * v54; // bp-28848, 0x5aa9c
    int32_t v55; // bp-8232, 0x5aa9c
    int32_t str4; // bp-8239, 0x5aa9c
    if (found_char_pos == NULL) {
        // 0x5b0fc
        v53 = v50;
        if (v51 == 45) {
            goto lab_0x5b254;
        } else {
            char v56 = v49;
            if (v51 < 45) {
                // 0x5b494
                v52 = &v49;
                str7 = v50;
                switch (v56) {
                    case 34: {
                        goto lab_0x5b288;
                    }
                    case 36: {
                        // 0x5b4a4
                        sscanf2((int32_t)&str4, "%s", (int32_t *)(str + 0x1880), (int32_t)&v55);
                        str9 = str + 0x1c81;
                        goto lab_0x5aef4;
                    }
                    default: {
                        goto lab_0x5b3b8;
                    }
                }
            } else {
                switch (v56) {
                    case 62: {
                        // 0x5b3f4
                        if (strncmp((char *)&str4, "syslog", 6) == 0) {
                            // 0x5b418
                            function_5df98(2, "src/rule.c", 477, "facility is null or 0");
                            *(int32_t *)(str + 0x1874) = -187;
                            function_5df98(2, "src/rule.c", 853, "-187 get");
                            // 0x5afdc
                            function_5a97c(str);
                            // 0x5afe8
                            return 0;
                        }
                        goto lab_0x5b1b0;
                    }
                    case 124: {
                        goto lab_0x5b118;
                    }
                    default: {
                        goto lab_0x5b3b8;
                    }
                }
            }
        }
    } else {
        int16_t * v57 = *__ctype_b_loc(); // 0x5ae48
        int32_t v58 = v50 + 1;
        char * str5 = (char *)v58; // 0x5ae58
        int32_t v59 = v58; // 0x5ae68
        while ((*(int16_t *)(2 * (int32_t)*str5 + (int32_t)v57) & 0x2000) != 0) {
            // 0x5ae50
            v58 = v59 + 1;
            str5 = (char *)v58;
            v59 = v58;
        }
        // 0x5ae6c
        v53 = v58;
        if (v51 == 45) {
            goto lab_0x5b254;
        } else {
            char v60 = v49;
            if (v51 < 45) {
                // 0x5ae78
                v52 = &v49;
                str7 = v58;
                switch (v60) {
                    case 34: {
                        goto lab_0x5b288;
                    }
                    case 36: {
                        int32_t v61 = &v55; // 0x5ae90
                        v1 = v61;
                        sscanf2((int32_t)&str4, "%s", (int32_t *)(str + 0x1880), v61);
                        char * found_char_pos2 = strchr(str5, 34); // 0x5aeac
                        if (found_char_pos2 == NULL) {
                            // 0x5ba00
                            function_5df98(2, "src/rule.c", 874, "record_path not start with \", [%s]");
                            // 0x5afdc
                            function_5a97c(str);
                            int32_t v62 = 0; // 0x5afe4
                            int32_t result2 = v62;
                            return result2;
                        }
                        int32_t str6 = (int32_t)found_char_pos2 + 1; // 0x5aeb8
                        char * found_char_pos3 = strrchr((char *)str6, 34); // 0x5aec4
                        v54 = found_char_pos3;
                        if (found_char_pos3 == NULL) {
                            // 0x5b470
                            function_5df98(2, "src/rule.c", 881, "matching \" not found in conf line[%s]");
                            // 0x5afdc
                            function_5a97c(str);
                            // 0x5afe8
                            return 0;
                        }
                        uint32_t v63 = (int32_t)found_char_pos3 - str6; // 0x5aed4
                        if (v63 >= 1024 == (v63 != 1024)) {
                            // 0x5b8b8
                            function_5df98(2, "src/rule.c", 886, "record_path too long %ld > %ld");
                            // 0x5afdc
                            function_5a97c(str);
                            // 0x5afe8
                            return 0;
                        }
                        int32_t v64 = str + 0x1c81; // 0x5aee8
                        function_11fc4((int32_t *)v64, str6, (char)v63, v1);
                        str9 = v64;
                        goto lab_0x5aef4;
                    }
                    default: {
                        goto lab_0x5b3b8;
                    }
                }
            } else {
                switch (v60) {
                    case 62: {
                        // 0x5b18c
                        v1 = &v55;
                        if (strncmp((char *)&str4, "syslog", 6) == 0) {
                            // 0x5b5fc
                            if (strcasecmp(str5, "LOG_LOCAL0") == 0) {
                                // 0x5b860
                                *(int32_t *)(str + 0x1874) = 128;
                                // 0x5b7c0
                                *(int32_t *)(str + 0x187c) = 0x5a040;
                                openlog(NULL, LOG_PID | LOG_NDELAY | LOG_NOWAIT, LOG_USER);
                                // 0x5afe8
                                return str;
                            }
                            // 0x5b614
                            if (strcasecmp(str5, "LOG_LOCAL1") == 0) {
                                // 0x5b8ac
                                *(int32_t *)(str + 0x1874) = 136;
                                // 0x5b7c0
                                *(int32_t *)(str + 0x187c) = 0x5a040;
                                openlog(NULL, LOG_PID | LOG_NDELAY | LOG_NOWAIT, LOG_USER);
                                // 0x5afe8
                                return str;
                            }
                            // 0x5b62c
                            if (strcasecmp(str5, "LOG_LOCAL2") == 0) {
                                // 0x5b8e4
                                *(int32_t *)(str + 0x1874) = 144;
                                // 0x5b7c0
                                *(int32_t *)(str + 0x187c) = 0x5a040;
                                openlog(NULL, LOG_PID | LOG_NDELAY | LOG_NOWAIT, LOG_USER);
                                // 0x5afe8
                                return str;
                            }
                            // 0x5b644
                            if (strcasecmp(str5, "LOG_LOCAL3") == 0) {
                                // 0x5b948
                                *(int32_t *)(str + 0x1874) = 152;
                                // 0x5b7c0
                                *(int32_t *)(str + 0x187c) = 0x5a040;
                                openlog(NULL, LOG_PID | LOG_NDELAY | LOG_NOWAIT, LOG_USER);
                                // 0x5afe8
                                return str;
                            }
                            // 0x5b65c
                            if (strcasecmp(str5, "LOG_LOCAL4") == 0) {
                                // 0x5b93c
                                *(int32_t *)(str + 0x1874) = 160;
                                // 0x5b7c0
                                *(int32_t *)(str + 0x187c) = 0x5a040;
                                openlog(NULL, LOG_PID | LOG_NDELAY | LOG_NOWAIT, LOG_USER);
                                // 0x5afe8
                                return str;
                            }
                            // 0x5b674
                            if (strcasecmp(str5, "LOG_LOCAL5") == 0) {
                                // 0x5b9f4
                                *(int32_t *)(str + 0x1874) = 168;
                                // 0x5b7c0
                                *(int32_t *)(str + 0x187c) = 0x5a040;
                                openlog(NULL, LOG_PID | LOG_NDELAY | LOG_NOWAIT, LOG_USER);
                                // 0x5afe8
                                return str;
                            }
                            // 0x5b68c
                            if (strcasecmp(str5, "LOG_LOCAL6") == 0) {
                                // 0x5ba5c
                                *(int32_t *)(str + 0x1874) = 176;
                                // 0x5b7c0
                                *(int32_t *)(str + 0x187c) = 0x5a040;
                                openlog(NULL, LOG_PID | LOG_NDELAY | LOG_NOWAIT, LOG_USER);
                                // 0x5afe8
                                return str;
                            }
                            // 0x5b6a4
                            if (strcasecmp(str5, "LOG_LOCAL7") == 0) {
                                // 0x5ba50
                                *(int32_t *)(str + 0x1874) = 184;
                                // 0x5b7c0
                                *(int32_t *)(str + 0x187c) = 0x5a040;
                                openlog(NULL, LOG_PID | LOG_NDELAY | LOG_NOWAIT, LOG_USER);
                                // 0x5afe8
                                return str;
                            }
                            // 0x5b6bc
                            if (strcasecmp(str5, "LOG_USER") == 0) {
                                // 0x5ba8c
                                *(int32_t *)(str + 0x1874) = 8;
                                // 0x5b7c0
                                *(int32_t *)(str + 0x187c) = 0x5a040;
                                openlog(NULL, LOG_PID | LOG_NDELAY | LOG_NOWAIT, LOG_USER);
                                // 0x5afe8
                                return str;
                            }
                            // 0x5b6d4
                            if (strcasecmp(str5, "LOG_AUTHPRIV") != 0) {
                                // 0x5b6ec
                                if (strcasecmp(str5, "LOG_CRON") == 0) {
                                    // 0x5bab0
                                    *(int32_t *)(str + 0x1874) = 72;
                                    // 0x5b7c0
                                    *(int32_t *)(str + 0x187c) = 0x5a040;
                                    openlog(NULL, LOG_PID | LOG_NDELAY | LOG_NOWAIT, LOG_USER);
                                    // 0x5afe8
                                    return str;
                                }
                                // 0x5b704
                                if (strcasecmp(str5, "LOG_DAEMON") == 0) {
                                    // 0x5baa4
                                    *(int32_t *)(str + 0x1874) = 24;
                                    // 0x5b7c0
                                    *(int32_t *)(str + 0x187c) = 0x5a040;
                                    openlog(NULL, LOG_PID | LOG_NDELAY | LOG_NOWAIT, LOG_USER);
                                    // 0x5afe8
                                    return str;
                                }
                                // 0x5b71c
                                if (strcasecmp(str5, "LOG_FTP") == 0) {
                                    // 0x5ba98
                                    *(int32_t *)(str + 0x1874) = 88;
                                    // 0x5b7c0
                                    *(int32_t *)(str + 0x187c) = 0x5a040;
                                    openlog(NULL, LOG_PID | LOG_NDELAY | LOG_NOWAIT, LOG_USER);
                                    // 0x5afe8
                                    return str;
                                }
                                // 0x5b734
                                if (strcasecmp(str5, "LOG_KERN") == 0) {
                                    *(int32_t *)(str + 0x1874) = 0;
                                    // 0x5b7c0
                                    *(int32_t *)(str + 0x187c) = 0x5a040;
                                    openlog(NULL, LOG_PID | LOG_NDELAY | LOG_NOWAIT, LOG_USER);
                                    // 0x5afe8
                                    return str;
                                }
                                // 0x5b750
                                if (strcasecmp(str5, "LOG_LPR") == 0) {
                                    // 0x5ba80
                                    *(int32_t *)(str + 0x1874) = 48;
                                    // 0x5b7c0
                                    *(int32_t *)(str + 0x187c) = 0x5a040;
                                    openlog(NULL, LOG_PID | LOG_NDELAY | LOG_NOWAIT, LOG_USER);
                                    // 0x5afe8
                                    return str;
                                }
                                // 0x5b768
                                if (strcasecmp(str5, "LOG_MAIL") == 0) {
                                    // 0x5ba74
                                    *(int32_t *)(str + 0x1874) = 16;
                                    // 0x5b7c0
                                    *(int32_t *)(str + 0x187c) = 0x5a040;
                                    openlog(NULL, LOG_PID | LOG_NDELAY | LOG_NOWAIT, LOG_USER);
                                    // 0x5afe8
                                    return str;
                                }
                                // 0x5b780
                                if (strcasecmp(str5, "LOG_NEWS") == 0) {
                                    // 0x5ba68
                                    *(int32_t *)(str + 0x1874) = 56;
                                    // 0x5b7c0
                                    *(int32_t *)(str + 0x187c) = 0x5a040;
                                    openlog(NULL, LOG_PID | LOG_NDELAY | LOG_NOWAIT, LOG_USER);
                                    // 0x5afe8
                                    return str;
                                }
                                // 0x5b798
                                if (strcasecmp(str5, "LOG_SYSLOG") == 0) {
                                    // .critedge
                                    v1 = 40;
                                    *(int32_t *)(str + 0x1874) = 40;
                                    // 0x5b7c0
                                    *(int32_t *)(str + 0x187c) = 0x5a040;
                                    openlog(NULL, LOG_PID | LOG_NDELAY | LOG_NOWAIT, LOG_USER);
                                    // 0x5afe8
                                    return str;
                                }
                            }
                            // 0x5b7b8
                            *(int32_t *)(str + 0x1874) = 80;
                            // 0x5b7c0
                            *(int32_t *)(str + 0x187c) = 0x5a040;
                            openlog(NULL, LOG_PID | LOG_NDELAY | LOG_NOWAIT, LOG_USER);
                            // 0x5afe8
                            return str;
                        }
                        goto lab_0x5b1b0;
                    }
                    case 124: {
                        goto lab_0x5b118;
                    }
                    default: {
                        goto lab_0x5b3b8;
                    }
                }
            }
        }
    }
  lab_dec_label_pc_0x5abb8:;
    uint16_t v65 = *(int16_t *)(2 * v11 + (int32_t)v13); // 0x5abb8
    int32_t v66; // 0x5aa9c
    switch (v12) {
        case 95: {
            goto lab_dec_label_pc_0x5abc8;
        }
        case 45: {
            goto lab_dec_label_pc_0x5abc8;
        }
        case 42: {
            goto lab_dec_label_pc_0x5abc8;
        }
        default: {
            // ._crit_edge
            v66 = v1 % 2;
            goto lab_dec_label_pc_unknown_73;
        }
    }
  lab_dec_label_pc_0x5abc8:
    v66 = 0;
    if (v11 == 42) {
        goto lab_dec_label_pc_unknown_73;
    } else {
        v66 = 0;
        goto lab_dec_label_pc_unknown_73;
    }
  lab_dec_label_pc_unknown_73:;
    int32_t v67 = (v11 == 33 ? 0 : v66) & (int32_t)(v65 / 8 ^ 1); // 0x5abdc
    v1 = v67;
    if (v67 != 0) {
        // break -> 0x5b204
        goto lab_0x5b204;
    }
    int32_t v68 = v9 + 1; // 0x5abe4
    unsigned char v69 = *(char *)v68; // 0x5abe4
    v9 = v68;
    v10 = v69;
    if (v69 == 0) {
        goto lab_0x5abf0;
    }
    goto lab_0x5aba8;
  lab_0x5b254:
    // 0x5b254
    if (str4 % 256 != 34) {
        // 0x5b86c
        function_5df98(2, "src/rule.c", 751, " - must set before a file output");
        // 0x5afdc
        function_5a97c(str);
        // 0x5afe8
        return 0;
    }
    // 0x5b268
    *(int32_t *)(str + 0x102c) = (int32_t)&g2;
    *v3 = 0;
    v52 = &str4;
    str7 = v53;
    goto lab_0x5b288;
  lab_0x5b288:;
    int32_t v70 = str + 0x1030; // 0x5b294
    int32_t v71 = str + 0x1434; // 0x5b2a0
    if (function_5a66c(v52, v70, v71, a7) != 0) {
        // 0x5b88c
        function_5df98(2, "src/rule.c", 767, "zlog_rule_parse_path fail");
        // 0x5afdc
        function_5a97c(str);
        // 0x5afe8
        return 0;
    }
    // 0x5b2b4
    if (str7 != 0) {
        // 0x5b2bc
        int32_t v72; // bp-4140, 0x5aa9c
        memset(&v72, 0, 0x1001);
        if (sscanf2(str7, " %[0-9MmKkBb] * %d ~", &v72, str + 0x1454) != 0) {
            // 0x5b45c
            *(int32_t *)(str + 0x1450) = function_5e140(&v72);
        }
        char * found_char_pos4 = strchr((char *)str7, 34); // 0x5b2fc
        if (found_char_pos4 != NULL) {
            int32_t str8 = str + 0x1458; // 0x5b314
            if (function_5a66c((int32_t *)found_char_pos4, str8, str + 0x185c, a7) != 0) {
                // 0x5b954
                function_5df98(2, "src/rule.c", 784, "zlog_rule_parse_path fail");
                // 0x5afdc
                function_5a97c(str);
                // 0x5afe8
                return 0;
            }
            char * found_char_pos5 = strchr((char *)str8, 35); // 0x5b33c
            if (found_char_pos5 == NULL) {
                // 0x5b36c
                function_5df98(2, "src/rule.c", 790, "archive_path must contain #r or #s");
                // 0x5afdc
                function_5a97c(str);
                // 0x5afe8
                return 0;
            }
            // 0x5b348
            if (strchr(found_char_pos5, 114) == NULL) {
                // 0x5b358
                if (strchr(found_char_pos5, 115) == NULL) {
                    // 0x5b36c
                    function_5df98(2, "src/rule.c", 790, "archive_path must contain #r or #s");
                    // 0x5afdc
                    function_5a97c(str);
                    // 0x5afe8
                    return 0;
                }
            }
        }
    }
    int32_t * v73 = (int32_t *)(str + 0x1450); // 0x5b390
    int32_t v74 = *v73; // 0x5b390
    v1 = v74;
    if (*(int32_t *)v71 != 0) {
        int32_t v75 = v74 > 0 ? 0x5a30c : 0x5a0d4;
        v1 = v75;
        *(int32_t *)(str + 0x187c) = v75;
        // 0x5afe8
        return str;
    }
    int32_t v76 = v74 > 0 ? 0x59a0c : 0x596b0;
    v1 = v76;
    *(int32_t *)(str + 0x187c) = v76;
    int32_t v77 = open64((char *)v70, *(int32_t *)(str + 0x102c) | 1089); // 0x5b548
    int32_t * fd = (int32_t *)(str + 0x1438); // 0x5b550
    *fd = v77;
    if (v77 < 0) {
        // 0x5b974
        __errno_location();
        function_5df98(2, "src/rule.c", 817, "open file[%s] fail, errno[%d]");
        // 0x5afdc
        function_5a97c(str);
        // 0x5afe8
        return 0;
    }
    // 0x5b558
    if (__fxstat64(3, v77, (struct stat64 *)&v54) != 0) {
        // 0x5b9a4
        __errno_location();
        function_5df98(2, "src/rule.c", 823, "stat [%s] fail, errno[%d], failing to open static_fd");
        // 0x5afdc
        function_5a97c(str);
        // 0x5afe8
        return 0;
    }
    // 0x5b570
    if (*v73 >= 1) {
        // 0x5b57c
        close(*fd);
        *fd = -1;
    }
    int32_t v78 = (int32_t)v54; // 0x5b58c
    *(int32_t *)(str + 0x1440) = v78 >> 31;
    *(int32_t *)(str + 0x1444) = v78;
    int64_t v79; // 0x5aa9c
    *(int32_t *)(str + 0x1448) = (int32_t)(v79 / 0x100000000);
    *(int32_t *)(str + 0x144c) = (int32_t)v79;
    // 0x5afe8
    return str;
  lab_0x5b3b8:
    // 0x5b3b8
    function_5df98(2, "src/rule.c", 930, "the 1st char[%c] of file_path[%s] is wrong");
    // 0x5afdc
    function_5a97c(str);
    // 0x5afe8
    return 0;
  lab_0x5b118:;
    // 0x5b118
    int32_t v80; // bp-16424, 0x5aa9c
    v1 = &v80;
    int32_t command; // bp-16439, 0x5aa9c
    struct _IO_FILE * stream = popen((char *)&command, "w"); // 0x5b12c
    *(int32_t *)(str + 0x1860) = (int32_t)stream;
    if (stream == NULL) {
        // 0x5b910
        __errno_location();
        function_5df98(2, "src/rule.c", 839, "popen fail, errno[%d]");
        // 0x5afdc
        function_5a97c(str);
        // 0x5afe8
        return 0;
    }
    int32_t v81 = fileno(stream); // 0x5b13c
    *(int32_t *)(str + 0x1864) = v81;
    if (v81 < 0) {
        // 0x5b158
        __errno_location();
        function_5df98(2, "src/rule.c", 844, "fileno fail, errno[%d]");
        // 0x5afdc
        function_5a97c(str);
        // 0x5afe8
        return 0;
    }
    v1 = 0x59f9c;
    *(int32_t *)(str + 0x187c) = 0x59f9c;
    // 0x5afe8
    return str;
  lab_0x5aef4:
    // 0x5aef4
    if (function_5e310(str9, 1025) != 0) {
        // 0x5b8f0
        function_5df98(2, "src/rule.c", 895, "zc_str_replace_env fail");
        // 0x5afdc
        function_5a97c(str);
        // 0x5afe8
        return 0;
    }
    int32_t * v82 = (int32_t *)(str + 0x187c);
    if (strchr((char *)str9, 37) == NULL) {
        // 0x5b5a4
        *v82 = 0x595c0;
        // 0x5afe8
        return str;
    }
    // 0x5af1c
    *v82 = 0x59cd4;
    int32_t v83 = function_5d4c0(0x5c6f4); // 0x5af30
    int32_t * v84 = (int32_t *)(str + 0x1434); // 0x5af38
    *v84 = v83;
    if (v83 == 0) {
        // 0x5b9d4
        function_5df98(2, "src/rule.c", 909, "zc_arraylist_new fail");
        // 0x5afdc
        function_5a97c(str);
        // 0x5afe8
        return 0;
    }
    // 0x5af40
    if (*(char *)(str + 0x1c81) == 0) {
        // 0x5afe8
        return str;
    }
    int32_t v85 = function_5c758(str9, (int32_t *)&v54, a7); // 0x5af84
    while (v85 != 0) {
        // 0x5af50
        if (function_5d694(*v84, v85) != 0) {
            // 0x5b838
            function_5c6f4(v85);
            function_5df98(2, "src/rule.c", 922, "zc_arraylist_add fail");
            goto lab_0x5afdc;
        }
        // 0x5af60
        if (*v54 == 0) {
            // 0x5afe8
            return str;
        }
        v85 = function_5c758((int32_t)v54, (int32_t *)&v54, a7);
    }
    // 0x5af94
    function_5df98(2, "src/rule.c", 915, "zlog_spec_new fail");
    // 0x5afdc
    function_5a97c(str);
    // 0x5afe8
    return 0;
  lab_0x5b1b0:;
    char * str10 = (char *)&str4;
    if (strncmp(str10, "stdout", 6) == 0) {
        // 0x5b7e0
        *(int32_t *)(str + 0x187c) = 0x59ef8;
        // 0x5afe8
        return str;
    }
    // 0x5b1d8
    if (strncmp(str10, "stderr", 6) == 0) {
        // 0x5b1f4
        *(int32_t *)(str + 0x187c) = 0x59e54;
        // 0x5afe8
        return str;
    }
    // 0x5ba24
    function_5df98(2, "src/rule.c", 864, "[%s]the string after is not syslog, stdout or stderr");
    // 0x5afdc
    function_5a97c(str);
    // 0x5afe8
    return 0;
}

// Address range: 0x5babc - 0x5bb9c
int32_t function_5babc(int32_t result, int32_t a2) {
    unsigned char v1 = *(char *)(result + 0x1001); // 0x5bac0
    g473 = (int32_t)v1 - 33;
    switch (v1) {
        case 33: {
            // 0x5bb48
            if (*(int32_t *)(*(int32_t *)(a2 + 8) + 292) == *(int32_t *)(result + 0x1004)) {
                // 0x5bb5c
                return 0;
            }
        }
        case 42: {
            // 0x5bb5c
            return result;
        }
        case 61: {
            // 0x5bb64
            if (*(int32_t *)(*(int32_t *)(a2 + 8) + 292) == *(int32_t *)(result + 0x1004)) {
                // 0x5bb5c
                return result;
            }
        }
        default: {
            // 0x5bb5c
            return 0;
        }
        case 46: {
            // 0x5bb80
            if (*(int32_t *)(*(int32_t *)(a2 + 8) + 292) < *(int32_t *)(result + 0x1004)) {
                // 0x5bb5c
                return 0;
            }
            return result;
        }
    }
}

// Address range: 0x5bb9c - 0x5bbe8
int32_t function_5bb9c(int32_t a1) {
    if (a1 != 0) {
        // 0x5bba4
        return 0;
    }
    // 0x5bbc0
    function_5df98(2, "src/rule.c", 1002, "a_rule is null or 0");
    return -1;
}

// Address range: 0x5bbe8 - 0x5bccc
int32_t function_5bbe8(int32_t a1, int32_t a2) {
    // 0x5bbe8
    if (a1 == 0) {
        // 0x5bc84
        function_5df98(2, "src/rule.c", 1014, "a_rule is null or 0");
        return -1;
    }
    if (a2 == 0) {
        // 0x5bca8
        function_5df98(2, "src/rule.c", 1015, "category is null or 0");
        return -1;
    }
    // 0x5bc00
    int32_t v1; // 0x5bbe8
    char v2 = v1;
    char v3 = v2; // 0x5bc08
    if (v2 == 42) {
        // 0x5bc0c
        v3 = *(char *)(a1 + 1);
        if (v3 == 0) {
            // 0x5bc18
            return 1;
        }
    }
    char * str2 = (char *)a2; // 0x5bc28
    if (function_11eec(a1, str2, v1, (int32_t)v3) == 0) {
        // 0x5bc18
        return 1;
    }
    char * str = (char *)a1; // 0x5bc38
    int32_t len = strlen(str); // 0x5bc38
    int32_t v4 = len - 1; // 0x5bc3c
    if (*(char *)(v4 + a1) != 95) {
        // 0x5bc18
        return 0;
    }
    int32_t len2 = strlen(str2); // 0x5bc5c
    strncmp(str, str2, v4 == len2 ? len2 : len);
    return 0;
}

// Address range: 0x5bccc - 0x5bd24
int32_t function_5bccc(int32_t a1, int32_t a2) {
    // 0x5bccc
    switch (*(int32_t *)(a1 + 0x187c)) {
        case 0x59cd4: {
        }
        case 0x595c0: {
            int32_t v1 = function_5da58(a2, a1 + 0x1880); // 0x5bd08
            if (v1 != 0) {
                *(int32_t *)(a1 + 0x2084) = *(int32_t *)(v1 + 1028);
            }
            // break -> 0x5bcf0
            break;
        }
    }
    // 0x5bcf0
    return 0;
}

// Address range: 0x5bd24 - 0x5bd34
int32_t function_5bd24(int32_t result, int32_t a2) {
    // 0x5bd24
    return result;
}

// Address range: 0x5bd34 - 0x5bd44
int32_t function_5bd34(int32_t result, int32_t a2) {
    // 0x5bd34
    return result;
}

// Address range: 0x5bd44 - 0x5bd54
int32_t function_5bd44(int32_t result, int32_t a2) {
    // 0x5bd44
    return result;
}

// Address range: 0x5bd54 - 0x5bd64
int32_t function_5bd54(int32_t a1, int32_t a2, int32_t a3) {
    // 0x5bd54
    return function_5f0d4(a3, a3, *(int32_t *)(a1 + 4));
}

// Address range: 0x5bd64 - 0x5bd78
int32_t function_5bd64(int32_t a1, int32_t a2, int32_t a3) {
    // 0x5bd64
    return function_5f0d4(a3, (int32_t)&g262, 1);
}

// Address range: 0x5bd78 - 0x5bd8c
int32_t function_5bd78(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = *(int32_t *)(a2 + 8); // 0x5bd78
    return function_5f0d4(a3, v1 + 428, *(int32_t *)(v1 + 460));
}

// Address range: 0x5bd8c - 0x5bda0
int32_t function_5bd8c(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = *(int32_t *)(a2 + 8); // 0x5bd8c
    return function_5f0d4(a3, v1 + 464, *(int32_t *)(v1 + 496));
}

// Address range: 0x5bda0 - 0x5bdb4
int32_t function_5bda0(int32_t a1, int32_t a2, int32_t a3) {
    // 0x5bda0
    return function_5f0d4(a3, (int32_t)&g261, 1);
}

// Address range: 0x5bdb4 - 0x5bdc8
int32_t function_5bdb4(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = *(int32_t *)(a2 + 8); // 0x5bdb4
    return function_5f0d4(a3, v1 + 504, *(int32_t *)(v1 + 536));
}

// Address range: 0x5bdc8 - 0x5bddc
int32_t function_5bdc8(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = *(int32_t *)(a2 + 8); // 0x5bdc8
    return function_5f0d4(a3, v1 + 8, *(int32_t *)(v1 + 268));
}

// Address range: 0x5bddc - 0x5bdec
int32_t function_5bddc(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = *(int32_t *)(a2 + 8); // 0x5bddc
    return function_5f0d4(a3, *(int32_t *)v1, *(int32_t *)(v1 + 4));
}

// Address range: 0x5bdec - 0x5be2c
int32_t function_5bdec(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = *(int32_t *)(g461 + 0x2440); // 0x5be0c
    int32_t v2 = function_57d70(v1, *(int32_t *)(*(int32_t *)(a2 + 8) + 292)); // 0x5be10
    return function_5f0d4(a3, v2 + 4, *(int32_t *)(v2 + 2056));
}

// Address range: 0x5be2c - 0x5be70
int32_t function_5be2c(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = *(int32_t *)(g461 + 0x2440); // 0x5be4c
    int32_t v2 = function_57d70(v1, *(int32_t *)(*(int32_t *)(a2 + 8) + 292)); // 0x5be50
    return function_5f0d4(a3, v2 + 1029, *(int32_t *)(v2 + 2056));
}

// Address range: 0x5be70 - 0x5beec
int32_t function_5be70(int32_t a1, int32_t a2, int32_t a3) {
    int32_t * v1 = (int32_t *)(a2 + 8); // 0x5be78
    int32_t v2 = *v1; // 0x5be78
    int32_t * v3 = (int32_t *)(v2 + 380); // 0x5be7c
    int32_t v4; // 0x5be70
    if (*v3 != 0) {
        // 0x5be88
        v4 = v2;
        return function_5f0d4(a3, v4 + 388, *(int32_t *)(v4 + 420));
    }
    // 0x5be9c
    *v3 = getpid();
    int32_t v5 = *v1; // 0x5bea8
    int32_t v6 = *(int32_t *)(v5 + 380); // 0x5beac
    int32_t * v7 = (int32_t *)(v5 + 384); // 0x5beb0
    if (v6 == *v7) {
        // 0x5be88
        v4 = v5;
        return function_5f0d4(a3, v4 + 388, *(int32_t *)(v4 + 420));
    }
    // 0x5bebc
    *v7 = v6;
    int32_t chars_printed = sprintf((char *)(v5 + 388), "%u", v6); // 0x5becc
    int32_t v8 = *v1; // 0x5bed0
    *(int32_t *)(v8 + 420) = chars_printed;
    return function_5f0d4(a3, v8 + 388, chars_printed);
}

// Address range: 0x5beec - 0x5bf18
int32_t function_5beec(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = *(int32_t *)(a2 + 8); // 0x5beec
    int32_t v2 = *(int32_t *)(v1 + 288); // 0x5bf00
    return function_5ed04(a3, v1, v2, v2 >> 31, 0);
}

// Address range: 0x5bf18 - 0x5c204
int32_t function_5bf18(int32_t a1, int32_t a2, int32_t a3) {
    int32_t * v1 = (int32_t *)(a2 + 8); // 0x5bf18
    int32_t v2 = *v1; // 0x5bf18
    switch (*(int32_t *)(v2 + 312)) {
        case 0: {
            int32_t v3 = *(int32_t *)(v2 + 304); // 0x5bf34
            if (v3 == 0) {
                // 0x5c08c
                return function_5f0d4(a3, (int32_t)"format=(null)", 13);
            }
            // 0x5bf50
            return function_5e8dc(a3, v3, *(int32_t *)(v2 + 308));
        }
        case 1: {
            // 0x5bf74
            if (*(int32_t *)(v2 + 296) == 0) {
                int32_t v4 = function_5f0d4(a3, (int32_t)"buf=(null)", 10); // 0x5c108
                if (v4 < 0) {
                    // 0x5c1a0
                    function_5df98(2, "src/spec.c", 336, "write hex msg fail");
                    // 0x5bf50
                    return -1;
                }
                // 0x5c114
                if (v4 == 0) {
                    // 0x5bf50
                    return 0;
                }
                // 0x5c0d4
                function_5df98(2, "src/spec.c", 339, "write hex msg, buf is full");
                // 0x5bf50
                return 1;
            }
            // break -> 0x5bf80
            break;
        }
        default: {
            // 0x5bf50
            return 0;
        }
    }
    int32_t v5 = function_5f0d4(a3, (int32_t)"\n             0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F    0123456789ABCDEF", 80); // 0x5bf94
    int32_t v6 = v5; // 0x5bf9c
    int32_t v7; // 0x5bf18
    int32_t v8; // 0x5bf18
    uint32_t v9; // 0x5bf18
    uint32_t v10; // 0x5bf18
    if (v5 == 0) {
        // 0x5bfcc
        char v11; // bp-41, 0x5bf18
        int32_t v12 = &v11;
        int32_t v13 = 1; // 0x5bf18
        int32_t v14 = 0; // 0x5bf18
        int32_t v15 = 16; // 0x5bf18
        while (true) {
            int32_t v16 = function_5f0d4(a3, (int32_t)&g261, 1); // 0x5bfd8
            v6 = v16;
            if (v16 != 0) {
                // break -> 0x5c0cc
                break;
            }
            int32_t v17 = v13;
            int32_t v18 = function_5ed04(a3, (int32_t)&g261, v17, v14, 10); // 0x5bff8
            v6 = v18;
            if (v18 != 0) {
                // break -> 0x5c0cc
                break;
            }
            int32_t v19 = function_5f0d4(a3, (int32_t)&g263, 3); // 0x5c010
            v6 = v19;
            if (v19 != 0) {
                // break -> 0x5c0cc
                break;
            }
            // 0x5c01c
            v10 = v15;
            int32_t v20 = v10 - 16; // 0x5c01c
            uint32_t v21 = v20;
            int32_t v22 = *v1; // 0x5c068
            uint32_t v23 = *(int32_t *)(v22 + 300); // 0x5c078
            int32_t v24 = (int32_t)&g263; // 0x5c080
            int32_t v25 = 3; // 0x5c080
            unsigned char v26; // 0x5c02c
            int32_t v27; // 0x5c038
            if (v23 >= v21 == (v23 != v21)) {
                // 0x5c028
                v26 = *(char *)(*(int32_t *)(v22 + 296) + v21);
                v11 = v26;
                v27 = function_5ef24(a3, (int32_t)v26, 2);
                v24 = &g264;
                v25 = 1;
                v6 = v27;
                if (v27 != 0) {
                    // break (via goto) -> 0x5c0cc
                    goto lab_0x5c0cc_4;
                }
            }
            int32_t v28 = function_5f0d4(a3, v24, v25); // 0x5c050
            v6 = v28;
            if (v28 != 0) {
                // break (via goto) -> 0x5c0cc
                goto lab_0x5c0cc_4;
            }
            int32_t v29 = v21 + 1; // 0x5c05c
            while (v29 != v10) {
                // 0x5c068
                v21 = v29;
                v22 = *v1;
                v23 = *(int32_t *)(v22 + 300);
                v24 = (int32_t)&g263;
                v25 = 3;
                if (v23 >= v21 == (v23 != v21)) {
                    // 0x5c028
                    v26 = *(char *)(*(int32_t *)(v22 + 296) + v21);
                    v11 = v26;
                    v27 = function_5ef24(a3, (int32_t)v26, 2);
                    v24 = &g264;
                    v25 = 1;
                    v6 = v27;
                    if (v27 != 0) {
                        // break (via goto) -> 0x5c0cc
                        goto lab_0x5c0cc_4;
                    }
                }
                // 0x5c050
                v28 = function_5f0d4(a3, v24, v25);
                v6 = v28;
                if (v28 != 0) {
                    // break (via goto) -> 0x5c0cc
                    goto lab_0x5c0cc_4;
                }
                // 0x5c05c
                v29 = v21 + 1;
            }
            int32_t v30 = function_5f0d4(a3, (int32_t)"  ", 2); // 0x5c12c
            v6 = v30;
            v8 = v20;
            if (v30 != 0) {
                // break -> 0x5c0cc
                break;
            }
            while (true) {
              lab_0x5c168:
                // 0x5c168
                v9 = v8;
                int32_t v31 = *v1; // 0x5c168
                uint32_t v32 = *(int32_t *)(v31 + 300); // 0x5c16c
                v7 = &g264;
                if (v32 == v9 || v32 < v9) {
                    goto lab_0x5c0bc;
                } else {
                    unsigned char v33 = *(char *)(*(int32_t *)(v31 + 296) + v9); // 0x5c188
                    v11 = v33;
                    uint32_t v34 = (int32_t)v33 - 32; // 0x5c190
                    v7 = v12;
                    if (v34 >= 94 == (v34 != 94)) {
                        int32_t v35 = function_5f0d4(a3, (int32_t)&g250, 1); // 0x5c150
                        v6 = v35;
                        if (v35 != 0) {
                            // break (via goto) -> 0x5c0cc
                            goto lab_0x5c0cc_4;
                        }
                        goto lab_0x5c15c;
                    } else {
                        goto lab_0x5c0bc;
                    }
                }
            }
          lab_0x5c1c4:
            // 0x5c1c4
            v13 = v17 + 1;
            v14 += (int32_t)(v17 == -1);
            v15 = v10 + 16;
            if (v10 >= *(int32_t *)(*v1 + 300)) {
                // 0x5bf50
                return 0;
            }
        }
    }
  lab_0x5c0cc_4:
    // 0x5c0cc
    if (v6 < 0) {
        // 0x5c1a0
        function_5df98(2, "src/spec.c", 336, "write hex msg fail");
        // 0x5bf50
        return -1;
    }
    // 0x5c0d4
    function_5df98(2, "src/spec.c", 339, "write hex msg, buf is full");
    // 0x5bf50
    return 1;
  lab_0x5c0bc:;
    int32_t v36 = function_5f0d4(a3, v7, 1); // 0x5c0bc
    v6 = v36;
    if (v36 != 0) {
        // break (via goto) -> 0x5c0cc
        goto lab_0x5c0cc_4;
    }
    goto lab_0x5c15c;
  lab_0x5c15c:;
    int32_t v37 = v9 + 1; // 0x5c15c
    v8 = v37;
    if (v10 == v37) {
        // break -> 0x5c1c4
        goto lab_0x5c1c4;
    }
    goto lab_0x5c168;
}

// Address range: 0x5c204 - 0x5c258
int32_t function_5c204(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = *(int32_t *)(a2 + 8); // 0x5c20c
    int32_t str = *(int32_t *)(v1 + 272); // 0x5c214
    char * found_char_pos = strrchr((char *)str, 47); // 0x5c21c
    int32_t v2 = *(int32_t *)(v1 + 276); // 0x5c224
    if (found_char_pos == NULL) {
        // 0x5c248
        return function_5f0d4(a3, str, v2);
    }
    int32_t v3 = (int32_t)found_char_pos; // 0x5c21c
    return function_5f0d4(a3, v3 + 1, v2 + str + -1 - v3);
}

// Address range: 0x5c258 - 0x5c294
int32_t function_5c258(int32_t a1, int32_t a2, int32_t a3) {
    int32_t * v1 = (int32_t *)(a2 + 8); // 0x5c258
    int32_t v2 = *v1; // 0x5c258
    int32_t tp = v2 + 316; // 0x5c268
    int32_t v3 = v2; // 0x5c270
    if (*(int32_t *)tp == 0) {
        // 0x5c274
        gettimeofday((struct timeval *)tp, NULL);
        v3 = *v1;
    }
    // 0x5c280
    return function_5eb48(a3, *(int32_t *)(v3 + 320), 6);
}

// Address range: 0x5c294 - 0x5c2e4
int32_t function_5c294(int32_t a1, int32_t a2, int32_t a3) {
    int32_t * v1 = (int32_t *)(a2 + 8); // 0x5c294
    int32_t v2 = *v1; // 0x5c294
    int32_t tp = v2 + 316; // 0x5c2a4
    int32_t v3 = v2; // 0x5c2ac
    if (*(int32_t *)tp == 0) {
        // 0x5c2b0
        gettimeofday((struct timeval *)tp, NULL);
        v3 = *v1;
    }
    // 0x5c2bc
    return function_5eb48(a3, *(int32_t *)(v3 + 320) / 1000, 3);
}

// Address range: 0x5c2e4 - 0x5c358
int32_t function_5c2e4(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = function_581fc(*(int32_t *)(a2 + 4)); // 0x5c304
    if (v1 != 0) {
        // 0x5c310
        return function_5f0d4(a3, v1 + 1025, *(int32_t *)(v1 + 2052));
    }
    // 0x5c32c
    function_5df98(2, "src/spec.c", 123, "zlog_mdc_get_kv key[%s] fail");
    return 0;
}

// Address range: 0x5c358 - 0x5c420
int32_t function_5c358(int32_t a1, int32_t a2, int32_t a3) {
    int32_t * v1 = (int32_t *)(a2 + 8); // 0x5c360
    int32_t v2 = *v1; // 0x5c360
    int32_t tp = v2 + 316; // 0x5c378
    int32_t v3 = *(int32_t *)tp; // 0x5c378
    int32_t v4 = v3; // bp-28, 0x5c38c
    int32_t v5 = v2; // 0x5c394
    int32_t v6 = v3; // 0x5c394
    if (v3 == 0) {
        // 0x5c408
        gettimeofday((struct timeval *)tp, NULL);
        v5 = *v1;
        v6 = *(int32_t *)(v5 + 316);
        v4 = v6;
    }
    int32_t tm = v2 + 328; // 0x5c384
    int32_t v7 = v6; // 0x5c3a0
    if (*(int32_t *)(v5 + 324) != v6) {
        // 0x5c3a4
        function_120a8(&v4, (int32_t *)tm);
        v7 = v4;
        *(int32_t *)(*v1 + 324) = v7;
    }
    int32_t str = *(int32_t *)(v2 + 372) + 0x100c * *(int32_t *)(a1 + 0x100c); // 0x5c390
    int32_t * v8 = (int32_t *)(str + 0x1008); // 0x5c3c0
    int32_t v9; // 0x5c358
    if (*v8 == v7) {
        // 0x5c400
        v9 = *(int32_t *)(str + 0x1004);
    } else {
        int32_t copied_chars = strftime((char *)str, 0x1001, (char *)(a1 + 8), (struct tm *)tm); // 0x5c3dc
        *(int32_t *)(str + 0x1004) = copied_chars;
        *v8 = v4;
        v9 = copied_chars;
    }
    // 0x5c3ec
    return function_5f0d4(a3, str, v9);
}

// Address range: 0x5c420 - 0x5c454
int32_t function_5c420(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = *(int32_t *)(a2 + 8); // 0x5c420
    if (*(int32_t *)(v1 + 272) == 0) {
        // 0x5c440
        return function_5f0d4(a3, (int32_t)"(func=null)", 11);
    }
    // 0x5c430
    return function_5f0d4(a3, *(int32_t *)(v1 + 280), *(int32_t *)(v1 + 284));
}

// Address range: 0x5c454 - 0x5c480
int32_t function_5c454(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = *(int32_t *)(a2 + 8); // 0x5c454
    int32_t v2 = *(int32_t *)(v1 + 272); // 0x5c45c
    if (v2 == 0) {
        // 0x5c470
        return function_5f0d4(a3, (int32_t)"(file=null)", 11);
    }
    // 0x5c468
    return function_5f0d4(a3, v2, *(int32_t *)(v1 + 276));
}

// Address range: 0x5c480 - 0x5c510
int32_t function_5c480(int32_t a1, int32_t a2) {
    int32_t * v1 = (int32_t *)(a2 + 12); // 0x5c480
    int32_t v2 = *v1; // 0x5c480
    *(int32_t *)(v2 + 4) = *(int32_t *)v2;
    int32_t result; // 0x5c480
    if (a1 < 0) {
        // 0x5c4ec
        function_5df98(2, "src/spec.c", 418, "a_spec->gen_buf fail");
        result = -1;
    } else {
        int32_t v3 = *v1; // 0x5c4b0
        int32_t v4 = *(int32_t *)(a1 + 0x241c); // 0x5c4b4
        int32_t v5 = *(int32_t *)(a1 + 0x2414); // 0x5c4b8
        int32_t v6 = *(int32_t *)v3; // 0x5c4bc
        int32_t v7 = *(int32_t *)(v3 + 4); // 0x5c4bc
        int32_t v8 = *(int32_t *)(a1 + 0x2420); // 0x5c4c4
        int32_t v9 = *(int32_t *)(a1 + 0x2418); // 0x5c4d8
        result = function_5f1cc(*(int32_t *)(a2 + 20), v6, v7 - v6, v5, v9, v8, v4);
    }
    // 0x5c4e4
    return result;
}

// Address range: 0x5c510 - 0x5c5a0
int32_t function_5c510(int32_t a1, int32_t a2) {
    int32_t * v1 = (int32_t *)(a2 + 12); // 0x5c510
    int32_t v2 = *v1; // 0x5c510
    *(int32_t *)(v2 + 4) = *(int32_t *)v2;
    int32_t result; // 0x5c510
    if (a1 < 0) {
        // 0x5c57c
        function_5df98(2, "src/spec.c", 392, "a_spec->gen_buf fail");
        result = -1;
    } else {
        int32_t v3 = *v1; // 0x5c540
        int32_t v4 = *(int32_t *)(a1 + 0x241c); // 0x5c544
        int32_t v5 = *(int32_t *)(a1 + 0x2414); // 0x5c548
        int32_t v6 = *(int32_t *)v3; // 0x5c54c
        int32_t v7 = *(int32_t *)(v3 + 4); // 0x5c54c
        int32_t v8 = *(int32_t *)(a1 + 0x2420); // 0x5c554
        int32_t v9 = *(int32_t *)(a1 + 0x2418); // 0x5c568
        result = function_5f1cc(*(int32_t *)(a2 + 16), v6, v7 - v6, v5, v9, v8, v4);
    }
    // 0x5c574
    return result;
}

// Address range: 0x5c5a0 - 0x5c630
int32_t function_5c5a0(int32_t a1, int32_t a2) {
    int32_t * v1 = (int32_t *)(a2 + 24); // 0x5c5a0
    int32_t v2 = *v1; // 0x5c5a0
    *(int32_t *)(v2 + 4) = *(int32_t *)v2;
    int32_t result; // 0x5c5a0
    if (a1 < 0) {
        // 0x5c60c
        function_5df98(2, "src/spec.c", 366, "a_spec->gen_buf fail");
        result = -1;
    } else {
        int32_t v3 = *v1; // 0x5c5d0
        int32_t v4 = *(int32_t *)(a1 + 0x241c); // 0x5c5d4
        int32_t v5 = *(int32_t *)(a1 + 0x2414); // 0x5c5d8
        int32_t v6 = *(int32_t *)v3; // 0x5c5dc
        int32_t v7 = *(int32_t *)(v3 + 4); // 0x5c5dc
        int32_t v8 = *(int32_t *)(a1 + 0x2420); // 0x5c5e4
        int32_t v9 = *(int32_t *)(a1 + 0x2418); // 0x5c5f8
        result = function_5f1cc(*(int32_t *)(a2 + 28), v6, v7 - v6, v5, v9, v8, v4);
    }
    // 0x5c604
    return result;
}

// Address range: 0x5c630 - 0x5c6f4
int32_t function_5c630(int32_t a1, int32_t a2) {
    if (a1 == 0) {
        // 0x5c6d8
        return function_5df98(2, "src/spec.c", 34, "a_spec is null or 0");
    }
    // 0x5c638
    return function_5df98(a2, "src/spec.c", 41, "----spec[%p][%.*s][%s|%d][%s,%ld,%ld,%s][%s]----");
}

// Address range: 0x5c6f4 - 0x5c758
int32_t function_5c6f4(int32_t a1) {
    if (a1 == 0) {
        // 0x5c734
        return function_5df98(2, "src/spec.c", 460, "a_spec is null or 0");
    }
    // 0x5c704
    function_5df98(0, "src/spec.c", 461, "zlog_spec_del[%p]");
    return free(a1, (int32_t)"src/spec.c", 461, (int32_t)"zlog_spec_del[%p]");
}

// Address range: 0x5c758 - 0x5cec0
int32_t function_5c758(int32_t a1, int32_t * a2, int32_t a3) {
    int32_t v1 = 0; // bp-44, 0x5c768
    if (a1 == 0) {
        // 0x5ce40
        function_5df98(2, "src/spec.c", 476, "pattern_start is null or 0");
        // 0x5c804
        return 0;
    }
    if (a2 == NULL) {
        // 0x5ce1c
        function_5df98(2, "src/spec.c", 477, "pattern_next is null or 0");
        // 0x5c804
        return (int32_t)a2;
    }
    // 0x5c77c
    int32_t v2; // 0x5c758
    int32_t result = function_11eb0(1, 0x2434, a3, v2); // 0x5c788
    if (result == 0) {
        // 0x5ce64
        __errno_location();
        function_5df98(2, "src/spec.c", 481, "calloc fail, errno[%d]");
        // 0x5c804
        return 0;
    }
    int32_t * v3 = (int32_t *)result; // 0x5c798
    *v3 = a1;
    if ((char)v2 != 37) {
        char * str = (char *)a1; // 0x5c7ac
        char * found_char_pos = strchr(str, 37); // 0x5c7ac
        int32_t v4 = (int32_t)found_char_pos; // 0x5c7ac
        *a2 = v4;
        if (found_char_pos == NULL) {
            int32_t len = strlen(str); // 0x5c8d0
            *(int32_t *)(result + 4) = len;
            *a2 = len + a1;
        } else {
            // 0x5c7bc
            *(int32_t *)(result + 4) = v4 - a1;
        }
        // 0x5c7c4
        *(int32_t *)(result + 0x2424) = 0x5bd54;
        *(int32_t *)(result + 0x2428) = 0x5bd24;
        *(int32_t *)(result + 0x242c) = 0x5bd34;
        *(int32_t *)(result + 0x2430) = 0x5bd44;
        // 0x5c7f8
        function_5c630(result, 0);
        // 0x5c804
        return result;
    }
    int32_t v5 = result + 0x1411; // 0x5c818
    v1 = 0;
    int32_t v6 = &v1; // 0x5c82c
    int32_t * v7 = (int32_t *)(result + 0x2428);
    int32_t v8; // 0x5c758
    if (sscanf2(a1, "%%%[.0-9-]%n", (int32_t *)v5, v6) == 1) {
        // 0x5c980
        *v7 = 0x5c5a0;
        *(int32_t *)(result + 0x242c) = 0x5c510;
        *(int32_t *)(result + 0x2430) = 0x5c480;
        char * v9 = (char *)v5;
        char * str2; // 0x5c758
        int32_t v10; // 0x5c758
        switch (*v9) {
            case 45: {
                // .thread
                *(int32_t *)(result + 0x2414) = 1;
                int32_t v11 = result + 0x1412;
                str2 = (char *)v11;
                v10 = v11;
                // break -> 0x5c9d4
                break;
            }
            case 48: {
                *(int32_t *)(result + 0x2418) = 1;
            }
            default: {
                *(int32_t *)(result + 0x2414) = 0;
                str2 = v9;
                v10 = v5;
                // break -> 0x5c9d4
                break;
            }
        }
        int32_t v12 = 0; // bp-40, 0x5c9e0
        int32_t v13 = 0; // bp-36, 0x5c9ec
        sscanf2(v10, "%ld.", &v12, 0);
        char * found_char_pos2 = strchr(str2, 46); // 0x5c9fc
        if (found_char_pos2 != NULL) {
            // 0x5ca08
            sscanf2((int32_t)found_char_pos2, ".%ld", &v13, 0);
        }
        // 0x5ca18
        *(int32_t *)(result + 0x2420) = v12 >> 31;
        *(int32_t *)(result + 0x241c) = v12;
        v8 = v1;
    } else {
        // 0x5c840
        *v7 = 0x5bd24;
        *(int32_t *)(result + 0x242c) = 0x5bd34;
        *(int32_t *)(result + 0x2430) = 0x5bd44;
        v1 = 1;
        v8 = 1;
    }
    int32_t v14 = v8 + a1; // 0x5c874
    char * str3 = (char *)v14; // 0x5c874
    switch (*str3) {
        case 100: {
            int32_t v15 = v14 + 1; // 0x5c8e4
            int32_t v16 = result + 8; // 0x5c8e8
            int32_t v17; // 0x5c758
            if (*(char *)v15 == 40) {
                // 0x5ca2c
                if (strncmp(str3, "d()", 3) == 0) {
                    // 0x5cc28
                    *(int32_t *)v16 = 0x25204625;
                    *(int16_t *)(result + 12) = 84;
                    v17 = v14 + 3;
                } else {
                    // 0x5ca48
                    v1 = 0;
                    int32_t v18 = sscanf2(v14, "d(%[^)])%n", (int32_t *)v16, v6); // 0x5ca64
                    int32_t v19 = v1;
                    if (v18 != 1) {
                        v1 = 0;
                    }
                    int32_t v20 = (v18 == 1 ? v19 : 0) + v14;
                    v17 = v20;
                    if (*(char *)(v20 - 1) != 41) {
                        // 0x5ca88
                        function_5df98(2, "src/spec.c", 529, "in string[%s] can't find match ')'");
                        // 0x5caa8
                        function_5c6f4(result);
                        // 0x5c804
                        return 0;
                    }
                }
            } else {
                // 0x5c8f4
                *(int32_t *)v16 = 0x25204625;
                *(int16_t *)(result + 12) = 84;
                v17 = v15;
            }
            int32_t v21 = *v3;
            *(int32_t *)(result + 0x100c) = v21;
            *(int32_t *)a3 = v21 + 1;
            *(int32_t *)(result + 0x2424) = 0x5c358;
            *a2 = v17;
            *(int32_t *)(result + 4) = v17 - v21;
            // 0x5c7f8
            function_5c630(result, 0);
            // 0x5c804
            return result;
        }
        case 77: {
            // 0x5cd9c
            v1 = 0;
            int32_t v22; // 0x5c758
            if (sscanf2(v14, "M(%[^)])%n", (int32_t *)(result + 0x1010), v6) == 1) {
                // 0x5ce90
                v22 = v1 + v14;
            } else {
                // 0x5cdc8
                v1 = 0;
                v22 = v14;
                if (strncmp(str3, "M()", 3) == 0) {
                    v1 = 3;
                    v22 = v14 + 3;
                }
            }
            // 0x5cdf0
            if (*(char *)(v22 - 1) != 41) {
                // 0x5ce9c
                function_5df98(2, "src/spec.c", 554, "in string[%s] can't find match ')'");
                // 0x5caa8
                function_5c6f4(result);
                // 0x5c804
                return 0;
            }
            // 0x5ce00
            *(int32_t *)(result + 4) = v22 - *v3;
            *a2 = v22;
            *(int32_t *)(result + 0x2424) = 0x5c2e4;
            // 0x5c7f8
            function_5c630(result, 0);
            // 0x5c804
            return result;
        }
    }
    int32_t strncmp_rc = strncmp(str3, "ms", 2); // 0x5c89c
    int32_t v23 = *v3; // 0x5c8a4
    if (strncmp_rc == 0) {
        int32_t v24 = v14 + 2; // 0x5c8ac
        *(int32_t *)(result + 4) = v24 - v23;
        *a2 = v24;
        *(int32_t *)(result + 0x2424) = (int32_t)&g243;
        // 0x5c7f8
        function_5c630(result, 0);
        // 0x5c804
        return result;
    }
    // 0x5c944
    if (strncmp(str3, "us", 2) == 0) {
        int32_t v25 = v14 + 2; // 0x5c960
        *(int32_t *)(result + 4) = v25 - v23;
        *a2 = v25;
        *(int32_t *)(result + 0x2424) = (int32_t)&g242;
        // 0x5c7f8
        function_5c630(result, 0);
        // 0x5c804
        return result;
    }
    int32_t v26 = v14 + 1;
    *a2 = v26;
    unsigned char v27 = *str3; // 0x5cac8
    int32_t v28 = v27; // 0x5cac8
    *(int32_t *)(result + 4) = v26 - v23;
    g474 = v28 - 37;
    switch (v27) {
        case 37: {
            // 0x5cd64
            *(int32_t *)(result + 0x2424) = 0x5bd64;
            // 0x5c7f8
            function_5c630(result, 0);
            // 0x5c804
            return result;
        }
        case 118: {
            // 0x5cc4c
            *(int32_t *)(result + 0x2424) = 0x5be2c;
            // 0x5c7f8
            function_5c630(result, 0);
            // 0x5c804
            return result;
        }
        case 116: {
            // 0x5cc5c
            *(int32_t *)(result + 0x2424) = 0x5bd8c;
            // 0x5c7f8
            function_5c630(result, 0);
            // 0x5c804
            return result;
        }
        case 112: {
            // 0x5cc6c
            *(int32_t *)(result + 0x2424) = 0x5be70;
            // 0x5c7f8
            function_5c630(result, 0);
            // 0x5c804
            return result;
        }
        case 110: {
            // 0x5cc7c
            *(int32_t *)(result + 0x2424) = 0x5bda0;
            // 0x5c7f8
            function_5c630(result, 0);
            // 0x5c804
            return result;
        }
        case 109: {
            // 0x5cc8c
            *(int32_t *)(result + 0x2424) = 0x5bf18;
            // 0x5c7f8
            function_5c630(result, 0);
            // 0x5c804
            return result;
        }
        case 107: {
            // 0x5cc9c
            *(int32_t *)(result + 0x2424) = 0x5bdb4;
            // 0x5c7f8
            function_5c630(result, 0);
            // 0x5c804
            return result;
        }
        case 102: {
            // 0x5ccac
            *(int32_t *)(result + 0x2424) = 0x5c204;
            // 0x5c7f8
            function_5c630(result, 0);
            // 0x5c804
            return result;
        }
        case 99: {
            // 0x5ccbc
            *(int32_t *)(result + 0x2424) = 0x5bddc;
            // 0x5c7f8
            function_5c630(result, 0);
            // 0x5c804
            return result;
        }
        case 86: {
            // 0x5cccc
            *(int32_t *)(result + 0x2424) = 0x5bdec;
            // 0x5c7f8
            function_5c630(result, 0);
            // 0x5c804
            return result;
        }
        case 85: {
            // 0x5ccdc
            *(int32_t *)(result + 0x2424) = 0x5c420;
            // 0x5c7f8
            function_5c630(result, 0);
            // 0x5c804
            return result;
        }
        case 84: {
            // 0x5ccec
            *(int32_t *)(result + 0x2424) = 0x5bd78;
            // 0x5c7f8
            function_5c630(result, 0);
            // 0x5c804
            return result;
        }
        case 76: {
            // 0x5ccfc
            *(int32_t *)(result + 0x2424) = 0x5beec;
            // 0x5c7f8
            function_5c630(result, 0);
            // 0x5c804
            return result;
        }
        case 72: {
            // 0x5cd0c
            *(int32_t *)(result + 0x2424) = 0x5bdc8;
            // 0x5c7f8
            function_5c630(result, 0);
            // 0x5c804
            return result;
        }
        case 70: {
            // 0x5cd1c
            *(int32_t *)(result + 0x2424) = 0x5c454;
            // 0x5c7f8
            function_5c630(result, 0);
            // 0x5c804
            return result;
        }
        case 68: {
            // 0x5cd2c
            *(int16_t *)(result + 12) = 84;
            *(int32_t *)(result + 8) = 0x25204625;
            *(int32_t *)a3 = v28 + 1;
            *(int32_t *)(result + 0x100c) = v28;
            *(int32_t *)(result + 0x2424) = 0x5c358;
            // 0x5c7f8
            function_5c630(result, 0);
            // 0x5c804
            return result;
        }
    }
    // 0x5cd74
    function_5df98(2, "src/spec.c", 634, "str[%s] in wrong format, p[%c]");
    // 0x5caa8
    function_5c6f4(result);
    // 0x5c804
    return 0;
}

// Address range: 0x5cec0 - 0x5cfa8
int32_t function_5cec0(int32_t a1, int32_t a2) {
    if (a1 == 0) {
        // 0x5cf84
        return function_5df98(2, "src/thread.c", 20, "a_thread is null or 0");
    }
    // 0x5ced0
    function_5df98(a2, "src/thread.c", 29, "--thread[%p][%p][%p][%p,%p,%p,%p,%p]--");
    function_57ed4(*(int32_t *)(a1 + 4), a2);
    function_5729c(*(int32_t *)(a1 + 8), a2);
    function_5e6a4(*(int32_t *)(a1 + 12), a2);
    function_5e6a4(*(int32_t *)(a1 + 16), a2);
    function_5e6a4(*(int32_t *)(a1 + 20), a2);
    function_5e6a4(*(int32_t *)(a1 + 24), a2);
    return function_5e6a4(*(int32_t *)(a1 + 28), a2);
}

// Address range: 0x5cfa8 - 0x5d07c
int32_t function_5cfa8(int32_t a1) {
    if (a1 == 0) {
        // 0x5d058
        return function_5df98(2, "src/thread.c", 43, "a_thread is null or 0");
    }
    int32_t v1 = *(int32_t *)(a1 + 4); // 0x5cfb8
    if (v1 != 0) {
        // 0x5cfc4
        function_57f94(v1);
    }
    int32_t v2 = *(int32_t *)(a1 + 8); // 0x5cfc8
    if (v2 != 0) {
        // 0x5cfd4
        function_57364(v2);
    }
    int32_t v3 = *(int32_t *)(a1 + 12); // 0x5cfd8
    if (v3 != 0) {
        // 0x5cfe4
        function_5e70c(v3);
    }
    int32_t v4 = *(int32_t *)(a1 + 16); // 0x5cfe8
    if (v4 != 0) {
        // 0x5cff4
        function_5e70c(v4);
    }
    int32_t v5 = *(int32_t *)(a1 + 20); // 0x5cff8
    if (v5 != 0) {
        // 0x5d004
        function_5e70c(v5);
    }
    int32_t v6 = *(int32_t *)(a1 + 24); // 0x5d008
    if (v6 != 0) {
        // 0x5d014
        function_5e70c(v6);
    }
    int32_t v7 = *(int32_t *)(a1 + 28); // 0x5d018
    if (v7 != 0) {
        // 0x5d024
        function_5e70c(v7);
    }
    // 0x5d028
    function_5df98(0, "src/thread.c", 59, "zlog_thread_del[%p]");
    return free(a1, (int32_t)"src/thread.c", 59, (int32_t)"zlog_thread_del[%p]");
}

// Address range: 0x5d07c - 0x5d290
int32_t function_5d07c(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t result = function_11eb0(1, 32, a3, a4); // 0x5d09c
    if (result == 0) {
        // 0x5d170
        __errno_location();
        function_5df98(2, "src/thread.c", 70, "calloc fail, errno[%d]");
        // 0x5d164
        return result;
    }
    // 0x5d0a8
    *(int32_t *)result = a1;
    int32_t v1 = function_58008(); // 0x5d0ac
    *(int32_t *)(result + 4) = v1;
    if (v1 == 0) {
        // 0x5d19c
        function_5df98(2, "src/thread.c", 78, "zlog_mdc_new fail");
        // 0x5d1b8
        function_5cfa8(result);
        return 0;
    }
    int32_t v2 = function_573d8(a4); // 0x5d0c0
    *(int32_t *)(result + 8) = v2;
    if (v2 == 0) {
        // 0x5d1d0
        function_5df98(2, "src/thread.c", 84, "zlog_event_new fail");
        // 0x5d1b8
        function_5cfa8(result);
        return 0;
    }
    int32_t v3 = function_5e758(1025, 1025, 0); // 0x5d0dc
    *(int32_t *)(result + 12) = v3;
    if (v3 == 0) {
        // 0x5d1f0
        function_5df98(2, "src/thread.c", 90, "zlog_buf_new fail");
        // 0x5d1b8
        function_5cfa8(result);
        return 0;
    }
    int32_t v4 = function_5e758(1025, 1025, 0); // 0x5d0f8
    *(int32_t *)(result + 16) = v4;
    if (v4 == 0) {
        // 0x5d210
        function_5df98(2, "src/thread.c", 96, "zlog_buf_new fail");
        // 0x5d1b8
        function_5cfa8(result);
        return 0;
    }
    int32_t v5 = function_5e758(1025, 1025, 0); // 0x5d114
    *(int32_t *)(result + 20) = v5;
    if (v5 == 0) {
        // 0x5d230
        function_5df98(2, "src/thread.c", 102, "zlog_buf_new fail");
        // 0x5d1b8
        function_5cfa8(result);
        return 0;
    }
    int32_t v6 = function_5e758(a2, a3, (int32_t)"...\n"); // 0x5d134
    *(int32_t *)(result + 24) = v6;
    if (v6 == 0) {
        // 0x5d250
        function_5df98(2, "src/thread.c", 108, "zlog_buf_new fail");
        // 0x5d1b8
        function_5cfa8(result);
        return 0;
    }
    int32_t v7 = function_5e758(a2, a3, (int32_t)"...\n"); // 0x5d154
    *(int32_t *)(result + 28) = v7;
    if (v7 != 0) {
        // 0x5d164
        return result;
    }
    // 0x5d270
    function_5df98(2, "src/thread.c", 114, "zlog_buf_new fail");
    // 0x5d1b8
    function_5cfa8(result);
    return 0;
}

// Address range: 0x5d290 - 0x5d3b0
int32_t function_5d290(int32_t a1, int32_t a2, int32_t a3) {
    if (a1 == 0) {
        // 0x5d38c
        function_5df98(2, "src/thread.c", 131, "a_thread is null or 0");
        return -1;
    }
    int32_t * v1 = (int32_t *)(a1 + 28); // 0x5d29c
    int32_t v2 = *v1; // 0x5d29c
    if (*(int32_t *)(v2 + 16) == a2) {
        // 0x5d2b4
        if (*(int32_t *)(v2 + 20) == a3) {
            // 0x5d368
            function_5df98(0, "src/thread.c", 135, "buf size not changed, no need rebuild");
            return 0;
        }
    }
    int32_t v3 = function_5e758(a2, a3, (int32_t)"...\n"); // 0x5d2d0
    if (v3 == 0) {
        // 0x5d344
        function_5df98(2, "src/thread.c", 141, "zlog_buf_new fail");
        return -1;
    }
    int32_t v4 = function_5e758(a2, a3, (int32_t)"...\n"); // 0x5d2ec
    if (v4 == 0) {
        // 0x5d318
        function_5df98(2, "src/thread.c", 147, "zlog_buf_new fail");
        function_5e70c(v3);
        return -1;
    }
    int32_t * v5 = (int32_t *)(a1 + 24); // 0x5d2f8
    function_5e70c(*v5);
    *v5 = v3;
    function_5e70c(*v1);
    *v1 = v4;
    return 0;
}

// Address range: 0x5d3b0 - 0x5d428
int32_t function_5d3b0(int32_t a1, int32_t a2) {
    if (a1 == 0) {
        // 0x5d3e0
        function_5df98(2, "src/thread.c", 167, "a_thread is null or 0");
        return -1;
    }
    int32_t v1 = function_573d8(a2); // 0x5d3c0
    if (v1 == 0) {
        // 0x5d404
        function_5df98(2, "src/thread.c", 171, "zlog_event_new fail");
        return -1;
    }
    int32_t * v2 = (int32_t *)(a1 + 8); // 0x5d3cc
    function_57364(*v2);
    *v2 = v1;
    return 0;
}

// Address range: 0x5d428 - 0x5d4c0
int32_t function_5d428(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = 2 * a2; // 0x5d440
    int32_t v2 = v1 < a3 ? a3 : v1;
    int32_t v3 = 4 * v2; // 0x5d44c
    int32_t v4; // 0x5d428
    int32_t v5 = function_1209c(a1, v3, a3, v4); // 0x5d450
    if (v5 == 0) {
        // 0x5d490
        __errno_location();
        function_5df98(2, "src/zc_arraylist.c", 67, "realloc fail, errno[%d]");
        // 0x5d474
        return -1;
    }
    // 0x5d45c
    *(int32_t *)a1 = v5;
    if (v2 != v3) {
        // 0x5d47c
        memset((int32_t *)(v5 + 16 * v2), 0, -12 * v2);
    }
    // 0x5d46c
    *(int32_t *)a2 = v2;
    // 0x5d474
    return 0;
}

// Address range: 0x5d4c0 - 0x5d580
int32_t function_5d4c0(int32_t a1) {
    // 0x5d4c0
    int32_t v1; // 0x5d4c0
    int32_t v2 = function_11eb0(1, 16, v1, v1); // 0x5d4d4
    if (v2 == 0) {
        // 0x5d51c
        __errno_location();
        function_5df98(2, "src/zc_arraylist.c", 22, "calloc fail, errno[%d]");
        // 0x5d510
        return 0;
    }
    // 0x5d4e0
    *(int32_t *)(v2 + 12) = a1;
    *(int32_t *)(v2 + 8) = 32;
    *(int32_t *)(v2 + 4) = 0;
    int32_t v3 = function_11eb0(32, 4, v1, 0); // 0x5d4fc
    *(int32_t *)v2 = v3;
    int32_t result = v2; // 0x5d50c
    if (v3 == 0) {
        // 0x5d548
        __errno_location();
        function_5df98(2, "src/zc_arraylist.c", 32, "calloc fail, errno[%d]");
        free(v2, (int32_t)"src/zc_arraylist.c", 32, (int32_t)"calloc fail, errno[%d]");
        result = 0;
    }
    // 0x5d510
    return result;
}

// Address range: 0x5d580 - 0x5d5f0
int32_t function_5d580(int32_t a1) {
    if (a1 == 0) {
        return 0;
    }
    int32_t v1 = *(int32_t *)(a1 + 12); // 0x5d58c
    int32_t v2 = 0; // 0x5d598
    int32_t v3 = a1; // 0x5d598
    int32_t v4; // 0x5d580
    if (v1 != 0) {
        int32_t v5 = *(int32_t *)(a1 + 4); // 0x5d59c
        int32_t v6 = 0; // 0x5d5a4
        v2 = v1;
        v3 = a1;
        v4 = v5;
        if (v5 >= 1) {
            int32_t v7 = *(int32_t *)(4 * v6 + a1); // 0x5d5ac
            int32_t v8 = v6 + 1; // 0x5d5b0
            int32_t v9 = v7 == 0 ? a1 : v7;
            int32_t v10 = v9; // 0x5d5d0
            v6 = v8;
            while (v5 > v8) {
                // 0x5d5ac
                v7 = *(int32_t *)(4 * v6 + v10);
                v8 = v6 + 1;
                v9 = v7 == 0 ? v10 : v7;
                v10 = v9;
                v6 = v8;
            }
            int32_t v11 = v7 == 0 ? 0 : v1;
            v2 = v11;
            v3 = v9;
            v4 = v5;
            if (v9 == 0) {
                // 0x5d5e4
                return free(a1, v5, 0, v11);
            }
        }
    }
    int32_t v12 = v3;
    free(v12, v4, v12, v2);
    // 0x5d5e4
    return free(a1, v4, v12, v2);
}

// Address range: 0x5d5f0 - 0x5d694
int32_t function_5d5f0(int32_t a1, uint32_t a2, int32_t a3) {
    int32_t v1 = a1 + 8; // 0x5d5f0
    int32_t v2 = a1; // 0x5d608
    if (*(int32_t *)v1 <= a2) {
        // 0x5d65c
        v2 = 0;
        if (function_5d428(a1, v1, a2) != 0) {
            // 0x5d670
            function_5df98(2, "src/zc_arraylist.c", 81, "expand_internal fail");
            return -1;
        }
    }
    int32_t v3 = 4 * a2; // 0x5d610
    int32_t v4 = v2 + v3; // 0x5d614
    int32_t * v5 = (int32_t *)v4;
    int32_t v6 = *v5; // 0x5d614
    int32_t * v7 = v5; // 0x5d620
    if (v6 != 0) {
        // 0x5d624
        v7 = (int32_t *)(*(int32_t *)(a1 + 12) == 0 ? v4 : v6 + v3);
    }
    int32_t * v8 = (int32_t *)(a1 + 4); // 0x5d63c
    *v7 = a3;
    if (*v8 <= a2) {
        *v8 = a2 + 1;
    }
    return 0;
}

// Address range: 0x5d694 - 0x5d6a0
int32_t function_5d694(int32_t a1, int32_t a2) {
    // 0x5d694
    return function_5d5f0(a1, *(int32_t *)(a1 + 4), a2);
}

// Address range: 0x5d6a0 - 0x5d7b4
int32_t function_5d6a0(int32_t a1, int32_t a2, int32_t a3) {
    int32_t * v1 = (int32_t *)(a1 + 4); // 0x5d6a0
    uint32_t v2 = *v1; // 0x5d6a0
    int32_t v3 = a1; // 0x5d6b4
    int32_t v4 = 0; // 0x5d6b4
    int32_t v5 = a1; // 0x5d6b4
    int32_t v6 = 0; // 0x5d6b4
    if (v2 >= 1) {
        v3 += 4 * v4;
        v5 = v3;
        v6 = v4;
        while (v3 < 1) {
            // 0x5d6c4
            v4++;
            v5 = v3;
            v6 = v4;
            if (v2 <= v4) {
                // break -> 0x5d6ec
                break;
            }
            v3 += 4 * v4;
            v5 = v3;
            v6 = v4;
        }
    }
    // 0x5d6ec
    if (v6 == v2) {
        // 0x5d76c
        return function_5d5f0(a1, v2, a3);
    }
    int32_t v7 = 4 * v6 + v5; // 0x5d6fc
    int32_t * v8 = (int32_t *)v7; // 0x5d6fc
    if (*v8 == 0) {
        // 0x5d780
        *v8 = a3;
        return 0;
    }
    int32_t v9 = a1 + 8; // 0x5d70c
    int32_t v10 = v7; // 0x5d714
    int32_t v11 = v2; // 0x5d714
    int32_t v12 = v5; // 0x5d714
    if (*(int32_t *)v9 <= v2) {
        // 0x5d718
        if (function_5d428(a1, v9, 0) != 0) {
            // 0x5d790
            function_5df98(2, "src/zc_arraylist.c", 107, "expand_internal fail");
            return -1;
        }
        // 0x5d730
        v11 = *v1;
        v12 = 0;
    }
    int32_t v13 = v11;
    function_11f64(v10 + 4 + v12, v10, 4 * (v13 - v6), v13);
    *(int32_t *)v10 = a3;
    *v1 = *v1 + 1;
    return 0;
}

// Address range: 0x5d7b8 - 0x5d890
int32_t function_5d7b8(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t v1 = function_11eb0(1, 28, a3, a4); // 0x5d7d8
    if (v1 == 0) {
        // 0x5d82c
        __errno_location();
        function_5df98(2, "src/zc_hashtable.c", 38, "calloc fail, errno[%d]");
        // 0x5d820
        return 0;
    }
    int32_t v2 = function_11eb0(a1, 4, a3, a4); // 0x5d7ec
    *(int32_t *)(v1 + 4) = v2;
    int32_t result; // 0x5d7b8
    if (v2 == 0) {
        // 0x5d858
        __errno_location();
        function_5df98(2, "src/zc_hashtable.c", 44, "calloc fail, errno[%d]");
        free(v1, (int32_t)"src/zc_hashtable.c", 44, (int32_t)"calloc fail, errno[%d]");
        result = 0;
    } else {
        // 0x5d800
        *(int32_t *)(v1 + 8) = a1;
        *(int32_t *)(v1 + 12) = a2;
        *(int32_t *)(v1 + 16) = a3;
        *(int32_t *)(v1 + 20) = a4;
        *(int32_t *)(v1 + 24) = a5;
        *(int32_t *)v1 = 0;
        result = v1;
    }
    // 0x5d820
    return result;
}

// Address range: 0x5d890 - 0x5d950
int32_t function_5d890(int32_t a1) {
    // 0x5d890
    if (a1 == 0) {
        // 0x5d928
        return function_5df98(2, "src/zc_hashtable.c", 68, "a_table[%p] is NULL, just do nothing");
    }
    int32_t * v1 = (int32_t *)(a1 + 4); // 0x5d8a0
    int32_t v2 = *v1; // 0x5d8a0
    int32_t * v3 = (int32_t *)(a1 + 8); // 0x5d8a0
    int32_t v4 = *v3; // 0x5d8a0
    int32_t v5 = v2; // 0x5d8ac
    int32_t v6 = 0; // 0x5d8ac
    int32_t v7; // 0x5d890
    if (v4 != 0) {
        int32_t v8 = 0; // 0x5d900
        int32_t v9 = *(int32_t *)(4 * v8 + v2); // 0x5d8b0
        int32_t v10 = v9; // 0x5d8b8
        int32_t v11 = v2; // 0x5d8b8
        int32_t v12 = v4; // 0x5d8b8
        int32_t v13; // 0x5d8c0
        if (v9 != 0) {
            v13 = *(int32_t *)(v10 + 16);
            free(v10, v7, v7, *(int32_t *)(a1 + 24));
            v10 = v13;
            while (v13 != 0) {
                // 0x5d8bc
                v13 = *(int32_t *)(v10 + 16);
                free(v10, v7, v7, *(int32_t *)(a1 + 24));
                v10 = v13;
            }
            // 0x5d8fc
            v11 = *v1;
            v12 = *v3;
        }
        int32_t v14 = v12;
        int32_t v15 = v11;
        v8++;
        v5 = v15;
        v6 = v14;
        while (v14 >= v8 == (v14 != v8)) {
            // 0x5d8b0
            v9 = *(int32_t *)(4 * v8 + v15);
            v10 = v9;
            v11 = v15;
            v12 = v14;
            if (v9 != 0) {
                v13 = *(int32_t *)(v10 + 16);
                free(v10, v7, v7, *(int32_t *)(a1 + 24));
                v10 = v13;
                while (v13 != 0) {
                    // 0x5d8bc
                    v13 = *(int32_t *)(v10 + 16);
                    free(v10, v7, v7, *(int32_t *)(a1 + 24));
                    v10 = v13;
                }
                // 0x5d8fc
                v11 = *v1;
                v12 = *v3;
            }
            // 0x5d900
            v14 = v12;
            v15 = v11;
            v8++;
            v5 = v15;
            v6 = v14;
        }
    }
    // 0x5d90c
    if (v5 != 0) {
        // 0x5d914
        free(v5, v7, v7, v6);
    }
    // 0x5d918
    return free(a1, v7, v7, v6);
}

// Address range: 0x5d950 - 0x5d9ec
int32_t function_5d950(int32_t result) {
    int32_t * v1 = (int32_t *)(result + 8); // 0x5d950
    int32_t v2 = *v1; // 0x5d950
    if (v2 == 0) {
        // 0x5d9e0
        *(int32_t *)result = 0;
        return result;
    }
    int32_t * v3 = (int32_t *)(result + 4); // 0x5d964
    int32_t v4 = *v3; // 0x5d96c
    int32_t v5 = 0; // 0x5d96c
    int32_t v6 = 4 * v5; // 0x5d970
    int32_t v7 = v6 + v4; // 0x5d970
    int32_t * v8 = (int32_t *)v7;
    int32_t v9 = *v8; // 0x5d970
    int32_t v10 = v9; // 0x5d980
    int32_t * v11 = v8; // 0x5d980
    int32_t v12 = result; // 0x5d980
    int32_t v13 = v2; // 0x5d980
    int32_t v14; // 0x5d988
    if (v9 != 0) {
        v14 = *(int32_t *)(v10 + 16);
        v12 = free(v10, v2, v7, *(int32_t *)(result + 24));
        v10 = v14;
        while (v14 != 0) {
            // 0x5d984
            v14 = *(int32_t *)(v10 + 16);
            v12 = free(v10, v2, v7, *(int32_t *)(result + 24));
            v10 = v14;
        }
        // 0x5d9c4
        v4 = *v3;
        v13 = *v1;
        v11 = (int32_t *)(v4 + v6);
    }
    int32_t result2 = v12;
    v5++;
    *v11 = 0;
    while (v13 >= v5 == (v13 != v5)) {
        int32_t v15 = v13;
        v6 = 4 * v5;
        v7 = v6 + v4;
        v8 = (int32_t *)v7;
        v9 = *v8;
        v10 = v9;
        v11 = v8;
        int32_t v16 = result2; // 0x5d980
        v13 = v15;
        if (v9 != 0) {
            v14 = *(int32_t *)(v10 + 16);
            v12 = free(v10, v15, v7, *(int32_t *)(result + 24));
            v10 = v14;
            while (v14 != 0) {
                // 0x5d984
                v14 = *(int32_t *)(v10 + 16);
                v12 = free(v10, v15, v7, *(int32_t *)(result + 24));
                v10 = v14;
            }
            // 0x5d9c4
            v4 = *v3;
            v13 = *v1;
            v11 = (int32_t *)(v4 + v6);
            v16 = v12;
        }
        // 0x5d9d0
        result2 = v16;
        v5++;
        *v11 = 0;
    }
    // 0x5d9e0
    *(int32_t *)result = 0;
    return result2;
}

// Address range: 0x5d9ec - 0x5da58
int32_t function_5d9ec(int32_t a1, int32_t a2) {
    int32_t v1 = *(int32_t *)(a1 + 8); // 0x5da04
    int32_t v2; // 0x5d9ec
    function_5fadc(a2, v1, v2, *(int32_t *)(a1 + 12));
    int32_t v3 = *(int32_t *)(*(int32_t *)(a1 + 4) + 4 * v1); // 0x5da10
    if (v3 == 0) {
        // 0x5da44
        return 0;
    }
    int32_t v4 = v3; // 0x5da20
    int32_t result = v3; // 0x5da40
    while (a2 == 0) {
        // 0x5da20
        v4 += 16;
        result = 0;
        if (v4 == 0) {
            // break -> 0x5da44
            break;
        }
        result = v3;
    }
    // 0x5da44
    return result;
}

// Address range: 0x5da58 - 0x5dac0
int32_t function_5da58(int32_t a1, int32_t a2) {
    int32_t v1 = *(int32_t *)(a1 + 8); // 0x5da70
    int32_t v2; // 0x5da58
    function_5fadc(a2, v1, v2, *(int32_t *)(a1 + 12));
    int32_t v3 = *(int32_t *)(*(int32_t *)(a1 + 4) + 4 * v1); // 0x5da7c
    if (v3 == 0) {
        // 0x5dab8
        return 0;
    }
    int32_t v4 = v3; // 0x5da8c
    while (a2 == 0) {
        // 0x5da8c
        v4 += 16;
        if (v4 == 0) {
            // 0x5dab8
            return 0;
        }
    }
    // 0x5dab0
    return *(int32_t *)(v3 + 8);
}

// Address range: 0x5dac0 - 0x5db70
int32_t function_5dac0(int32_t a1, int32_t a2, int32_t a3) {
    int32_t * v1 = (int32_t *)(a1 + 8); // 0x5dae0
    int32_t v2 = *v1; // 0x5dae0
    int32_t v3 = function_5fadc(a2, v2, a3, *(int32_t *)(a1 + 12)); // 0x5dae8
    int32_t v4 = *(int32_t *)(*(int32_t *)(a1 + 4) + 4 * v2); // 0x5daf0
    int32_t result = v3; // 0x5daf8
    int32_t v5 = v2; // 0x5daf8
    if (v4 == 0) {
      lab_0x5db68:
        // 0x5db68
        __asm_vmov_7(v5);
        __asm_vldr(-0x33333333);
        return result;
    }
    int32_t v6 = v4; // 0x5db00
    while (a2 == 0) {
        // 0x5db00
        v6 += 16;
        if (v6 == 0) {
            // 0x5db64
            v5 = *v1;
            result = 0;
            goto lab_0x5db68;
        }
    }
    // 0x5db24
    *(int32_t *)(v4 + 4) = a2;
    *(int32_t *)(v4 + 8) = a3;
    return 0;
}

// Address range: 0x5db72 - 0x5db86
int32_t function_5db72(void) {
    // 0x5db72
    bool v1; // 0x5db72
    if (v1) {
        // 0x5db7a
        function_9941a();
        function_1a192d6();
        function_ff259666();
    } else {
        // 0x5db76
        function_21965a();
    }
    // 0x5db82
    return function_49965a();
}

// Address range: 0x5db86 - 0x5db90
int32_t function_5db86(int32_t result, int32_t a2) {
    // 0x5db86
    __asm_cdp(0, 15, 0, 1, 7, 1);
    // 0x5db8e
    return result;
}

// Address range: 0x5db90 - 0x5dd1c
int32_t function_5db90(int32_t a1) {
    // 0x5db90
    int32_t v1; // 0x5db90
    int32_t v2 = v1;
    int32_t v3 = function_11eb0(v1, 4, v1, v1); // 0x5db98
    if (v3 == 0) {
        // 0x5dca0
        __errno_location();
        function_5df98(2, "src/zc_hashtable.c", 126, "calloc fail, errno[%d]");
        function_5df98(2, "src/zc_hashtable.c", 205, "rehash fail");
        return -1;
    }
    int32_t * v4 = (int32_t *)(v2 + 4); // 0x5dba4
    int32_t v5 = *v4; // 0x5dba4
    int32_t v6 = 4; // 0x5dbb0
    int32_t v7 = v5; // 0x5dbb0
    if (v1 != 0) {
        int32_t * v8 = (int32_t *)(v3 + 4 * v1);
        int32_t v9 = 4; // 0x5dbc4
        int32_t v10 = v5; // 0x5dbc4
        int32_t v11 = *(int32_t *)v10; // 0x5dbc8
        int32_t v12 = v11; // 0x5dbd0
        int32_t v13 = v5; // 0x5dbd0
        int32_t v14; // 0x5db90
        int32_t v15; // 0x5db90
        int32_t * v16; // 0x5dbd4
        int32_t v17; // 0x5dbd4
        int32_t v18; // 0x5dbec
        int32_t v19; // 0x5dbf8
        if (v11 != 0) {
            v15 = v12;
            v16 = (int32_t *)(v15 + 16);
            v17 = *v16;
            *(int32_t *)(v15 + 12) = 0;
            *v16 = 0;
            function_5fadc(*(int32_t *)v15, v1, v1, v5);
            v18 = *v8;
            v19 = 0;
            if (v18 != 0) {
                *(int32_t *)(v18 + 12) = v15;
                v19 = *v8;
                *v16 = v19;
            }
            // .critedge.thread
            *v8 = v15;
            v14 = v19;
            v13 = v19;
            while (v17 != 0) {
                // 0x5dbd4
                v15 = v17;
                v16 = (int32_t *)(v15 + 16);
                v17 = *v16;
                *(int32_t *)(v15 + 12) = 0;
                *v16 = 0;
                function_5fadc(*(int32_t *)v15, v1, v1, v14);
                v18 = *v8;
                v19 = 0;
                if (v18 != 0) {
                    *(int32_t *)(v18 + 12) = v15;
                    v19 = *v8;
                    *v16 = v19;
                }
                // .critedge.thread
                *v8 = v15;
                v14 = v19;
                v13 = v19;
            }
        }
        // 0x5dc0c
        v10 += 4;
        int32_t v20 = v13;
        v6 = v9;
        v7 = v20;
        while (v5 + 4 * v1 != v10) {
            // 0x5dbc8
            v11 = *(int32_t *)v10;
            v14 = v20;
            v12 = v11;
            v13 = v20;
            if (v11 != 0) {
                v15 = v12;
                v16 = (int32_t *)(v15 + 16);
                v17 = *v16;
                *(int32_t *)(v15 + 12) = 0;
                *v16 = 0;
                function_5fadc(*(int32_t *)v15, v1, v1, v14);
                v18 = *v8;
                v19 = 0;
                if (v18 != 0) {
                    *(int32_t *)(v18 + 12) = v15;
                    v19 = *v8;
                    *v16 = v19;
                }
                // .critedge.thread
                *v8 = v15;
                v14 = v19;
                v13 = v19;
                while (v17 != 0) {
                    // 0x5dbd4
                    v15 = v17;
                    v16 = (int32_t *)(v15 + 16);
                    v17 = *v16;
                    *(int32_t *)(v15 + 12) = 0;
                    *v16 = 0;
                    function_5fadc(*(int32_t *)v15, v1, v1, v14);
                    v18 = *v8;
                    v19 = 0;
                    if (v18 != 0) {
                        *(int32_t *)(v18 + 12) = v15;
                        v19 = *v8;
                        *v16 = v19;
                    }
                    // .critedge.thread
                    *v8 = v15;
                    v14 = v19;
                    v13 = v19;
                }
            }
            // 0x5dc0c
            v10 += 4;
            v20 = v13;
            v6 = v9;
            v7 = v20;
        }
    }
    // 0x5dc1c
    free(v5, v6, v1, v7);
    *v4 = v3;
    int32_t v21 = function_11eb0(1, 20, v1, v7); // 0x5dc34
    if (v21 == 0) {
        // 0x5dcec
        __errno_location();
        function_5df98(2, "src/zc_hashtable.c", 212, "calloc fail, errno[%d]");
        return -1;
    }
    int32_t v22 = *(int32_t *)(v2 + 8); // 0x5dc54
    int32_t * v23 = (int32_t *)(v21 + 16); // 0x5dc58
    *v23 = 0;
    *(int32_t *)(v21 + 8) = a1;
    *(int32_t *)(v21 + 12) = 0;
    function_5fadc(v1, v22, a1, 0);
    int32_t * v24 = (int32_t *)(*v4 + 4 * v22); // 0x5dc74
    int32_t v25 = *v24; // 0x5dc74
    if (v25 != 0) {
        *(int32_t *)(v25 + 12) = v21;
        *v23 = *v24;
    }
    // .critedge1.thread
    *v24 = v21;
    *(int32_t *)v2 = v2 + 1;
    return 0;
}

// Address range: 0x5dd1c - 0x5dd20
int32_t function_5dd1c(void) {
    // 0x5dd1c
    return function_45e360();
}

// Address range: 0x5dd28 - 0x5de60
int32_t function_5dd28(int32_t a1, int32_t a2) {
    // 0x5dd28
    if (a1 == 0 || a2 == 0) {
        // 0x5ddec
        return function_5df98(2, "src/zc_hashtable.c", 240, "a_table[%p] or a_key[%p] is NULL, just do nothing");
    }
    int32_t * v1 = (int32_t *)(a1 + 8); // 0x5dd50
    int32_t v2 = *v1; // 0x5dd50
    int32_t v3; // 0x5dd28
    function_5fadc(a2, v2, v3, *(int32_t *)(a1 + 12));
    int32_t * v4 = (int32_t *)(a1 + 4); // 0x5dd58
    int32_t v5 = *(int32_t *)(*v4 + 4 * v2); // 0x5dd5c
    if (v5 == 0) {
        // 0x5ddf4
        return function_5df98(2, "src/zc_hashtable.c", 251, "p[%p] not found in hashtable");
    }
    int32_t v6 = *(int32_t *)(v5 + 16);
    int32_t * v7 = (int32_t *)(v5 + 12); // 0x5ddbc
    int32_t v8 = *v7; // 0x5ddbc
    int32_t v9 = v8; // 0x5ddc4
    if (v6 != 0) {
        *(int32_t *)(v6 + 12) = v8;
        v9 = *v7;
    }
    // .critedge
    int32_t v10; // 0x5dd28
    int32_t v11; // 0x5dd28
    if (v9 == 0) {
        int32_t v12 = *v1; // 0x5de20
        function_5fadc(*(int32_t *)v5, v12, v3, 0);
        int32_t v13 = *v4; // 0x5de2c
        *(int32_t *)(v13 + 4 * v12) = v6;
        v10 = v12;
        v11 = v13;
    } else {
        *(int32_t *)(v9 + 16) = v6;
        v10 = *(int32_t *)(v5 + 4);
        v11 = v9;
    }
    int32_t result = free(v5, v10, v3, v11); // 0x5dddc
    *(int32_t *)a1 = result - 1;
    // 0x5ddec
    return result;
}

// Address range: 0x5de60 - 0x5dea8
int32_t function_5de60(int32_t a1) {
    int32_t v1 = *(int32_t *)(a1 + 8); // 0x5de60
    if (v1 == 0) {
        // 0x5de98
        return 0;
    }
    int32_t v2 = *(int32_t *)(a1 + 4); // 0x5de6c
    int32_t result = *(int32_t *)v2; // 0x5de70
    int32_t v3 = v2; // 0x5de78
    if (result != 0) {
        // 0x5de98
        return result;
    }
    int32_t v4 = 0; // 0x5de78
    v4++;
    int32_t result2 = 0; // 0x5de88
    while (v4 != v1) {
        // 0x5de8c
        v3 += 4;
        int32_t v5 = *(int32_t *)v3; // 0x5de8c
        result2 = v5;
        if (v5 != 0) {
            // break -> 0x5de98
            break;
        }
        v4++;
        result2 = 0;
    }
    // 0x5de98
    return result2;
}

// Address range: 0x5dea8 - 0x5df18
int32_t function_5dea8(int32_t a1, int32_t a2) {
    int32_t result = *(int32_t *)(a2 + 16); // 0x5deac
    if (result != 0) {
        // 0x5deb8
        return result;
    }
    int32_t v1 = *(int32_t *)(a1 + 8); // 0x5dec0
    int32_t v2; // 0x5dea8
    function_5fadc(a2, v1, v2, v2);
    if (v1 != -1) {
        // 0x5deb8
        return 0;
    }
    int32_t v3 = *(int32_t *)(a1 + 4); // 0x5dee0
    int32_t result2 = *(int32_t *)v3; // 0x5dee4
    int32_t v4 = 0; // 0x5def0
    if (result2 != 0) {
        // 0x5deb8
        return result2;
    }
    int32_t v5 = v3; // 0x5def0
    v4++;
    int32_t result3 = 0; // 0x5defc
    while (v4 != -1) {
        // 0x5df00
        v5 += 4;
        int32_t v6 = *(int32_t *)v5; // 0x5df00
        result3 = v6;
        if (v6 != 0) {
            // break -> 0x5deb8
            break;
        }
        v4++;
        result3 = 0;
    }
    // 0x5deb8
    return result3;
}

// Address range: 0x5df18 - 0x5df44
int32_t function_5df18(void) {
    // 0x5df18
    int32_t v1; // 0x5df18
    char v2 = v1;
    int32_t result = 0x1505; // 0x5df24
    if (v2 == 0) {
        // 0x5df3c
        return 0x1505;
    }
    int32_t v3; // 0x5df18
    int32_t v4 = v3 + 1; // 0x5df2c
    char v5 = *(char *)v4; // 0x5df2c
    result = 33 * result + (int32_t)v2;
    while (v5 != 0) {
        unsigned char v6 = v5;
        v4++;
        v5 = *(char *)v4;
        result = 33 * result + (int32_t)v6;
    }
    // 0x5df3c
    return result;
}

// Address range: 0x5df44 - 0x5df58
int32_t function_5df44(void) {
    // 0x5df44
    int32_t v1; // 0x5df44
    function_11eec(v1, (char *)v1, v1, v1);
    return 0;
}

// Address range: 0x5df58 - 0x5df98
int32_t function_5df58(int32_t * str) {
    // 0x5df58
    int32_t v1; // bp-56, 0x5df58
    function_11fe8((int32_t)&v1);
    int32_t tm; // bp-52, 0x5df58
    function_120a8(&v1, &tm);
    return strftime((char *)str, 21, "%m-%d %T", (struct tm *)&tm);
}

// Address range: 0x5df98 - 0x5e140
int32_t function_5df98(int32_t a1, char * a2, int32_t a3, char * format) {
    // 0x5df98
    char * v1; // 0x5df98
    char * v2; // 0x5df98
    int32_t v3; // 0x5df98
    if (g175 == 0) {
        // 0x5e070
        g175 = 1;
        g176 = getenv("ZLOG_PROFILE_DEBUG");
        char * env_val = getenv("ZLOG_PROFILE_ERROR"); // 0x5e090
        g177 = env_val;
        v3 = 0;
        v1 = env_val;
        v2 = env_val;
        switch (a1) {
            case 1: {
                goto lab_0x5e0a0;
            }
            case 2: {
                goto lab_0x5e0ec;
            }
            case 0: {
                goto lab_0x5e020;
            }
            default: {
                goto lab_0x5dfe0;
            }
        }
    } else {
        // 0x5dfc4
        v3 = 0;
        switch (a1) {
            case 1: {
                // 0x5e0a0
                v1 = g177;
                goto lab_0x5e0a0;
            }
            case 2: {
                // 0x5e0ec
                v2 = g177;
                goto lab_0x5e0ec;
            }
            case 0: {
                goto lab_0x5e020;
            }
            default: {
                goto lab_0x5dfe0;
            }
        }
    }
  lab_0x5e0a0:
    // 0x5e0a0
    if (v1 == NULL) {
        // 0x5e010
        return (int32_t)v1;
    }
    struct _IO_FILE * stream = fopen64(v1, "a"); // 0x5e0b4
    if (stream == NULL) {
        // 0x5e010
        return -1;
    }
    // 0x5e0c0
    int32_t v4; // bp-48, 0x5df98
    function_5df58(&v4);
    fprintf(stream, "%s WARN  (%d:%s:%ld) ", &v4, getpid(), a2, a3);
    v3 = (int32_t)stream;
    goto lab_0x5dfe0;
  lab_0x5e0ec:
    // 0x5e0ec
    if (v2 == NULL) {
        // 0x5e010
        int32_t v6; // 0x5df98
        int32_t result = v6;
        return result;
    }
    struct _IO_FILE * stream3 = fopen64(v2, "a"); // 0x5e100
    if (stream3 == NULL) {
        // 0x5e010
        return -1;
    }
    // 0x5e10c
    function_5df58(&v4);
    fprintf(stream3, "%s ERROR (%d:%s:%ld) ", &v4, getpid(), a2, a3);
    v3 = (int32_t)stream3;
    goto lab_0x5dfe0;
  lab_0x5e020:
    // 0x5e020
    if (g176 == NULL) {
        // 0x5e010
        return (int32_t)g176;
    }
    struct _IO_FILE * stream4 = fopen64(g176, "a"); // 0x5e038
    if (stream4 == NULL) {
        // 0x5e010
        return -1;
    }
    // 0x5e044
    function_5df58(&v4);
    fprintf(stream4, "%s DEBUG (%d:%s:%ld) ", &v4, getpid(), a2, a3);
    v3 = (int32_t)stream4;
    goto lab_0x5dfe0;
  lab_0x5dfe0:;
    struct _IO_FILE * stream2 = (struct _IO_FILE *)v3; // 0x5dff4
    int32_t v5; // 0x5df98
    vfprintf(stream2, format, (int32_t)&v5);
    fputc(10, stream2);
    fclose(stream2);
    // 0x5e010
    return 0;
}

// Address range: 0x5e140 - 0x5e310
int32_t function_5e140(int32_t * str) {
    int32_t result = (int32_t)str;
    if (str == NULL) {
        // 0x5e2e8
        function_5df98(2, "src/zc_util.c", 27, "astring is null or 0");
        return result;
    }
    // 0x5e150
    int32_t v1; // 0x5e140
    char v2 = v1;
    int32_t v3 = result; // 0x5e15c
    if (v2 != 0) {
        int16_t ** v4 = __ctype_b_loc(); // 0x5e160
        int32_t v5 = result; // 0x5e168
        int32_t v6 = result; // 0x5e17c
        if ((*(int16_t *)(2 * (int32_t)v2 + (int32_t)*v4) & 0x2000) == 0) {
            *(char *)result = v2;
            v6 = result + 1;
        }
        int32_t v7 = v6;
        v5++;
        char v8 = *(char *)v5; // 0x5e180
        v3 = v7;
        while (v8 != 0) {
            unsigned char v9 = v8;
            int32_t v10 = v7;
            int16_t v11 = *(int16_t *)(2 * (int32_t)v9 + (int32_t)*v4); // 0x5e174
            v6 = v10;
            if ((v11 & 0x2000) == 0) {
                *(char *)v10 = v9;
                v6 = v10 + 1;
            }
            v7 = v6;
            v5++;
            v8 = *(char *)v5;
            v3 = v7;
        }
    }
    // 0x5e18c
    *(char *)v3 = 0;
    int32_t len = strlen((char *)str); // 0x5e198
    int32_t result2 = function_11ef8(str, 0, 10); // 0x5e1ac
    if (result2 <= 0) {
        // 0x5e294
        return 0;
    }
    int32_t v12 = len + result; // 0x5e1bc
    int32_t v13 = (int32_t)*(char *)(v12 - 1); // 0x5e1c0
    int32_t v14 = len; // 0x5e1cc
    if ((v13 & 223) == 66) {
        v14 = (int32_t)*(char *)(v12 - 2);
    }
    int32_t v15 = (v13 & 223) == 66 ? v14 : v13;
    g475 = v15 - 71;
    switch (v15) {
        case 71: {
        }
        case 103: {
            // 0x5e294
            return ((v13 & 223) == 66 ? 0x40000000 : 0x3b9aca00) * result2;
        }
        case 109: {
        }
        case 77: {
            // 0x5e294
            return ((v13 & 223) == 66 ? 0x100000 : 0xf4240) * result2;
        }
        case 107: {
        }
        case 75: {
            // 0x5e294
            return ((v13 & 223) == 66 ? 1024 : 1000) * result2;
        }
    }
    // 0x5e2ac
    if ((*(int16_t *)(2 * v15 + (int32_t)*__ctype_b_loc()) & 2048) == 0) {
        // 0x5e2c4
        function_5df98(2, "src/zc_util.c", 70, "Wrong suffix parsing size in bytes for string [%s], ignoring suffix");
    }
    // 0x5e294
    return result2;
}

// Address range: 0x5e310 - 0x5e558
int32_t function_5e310(int32_t str, int32_t a2) {
    // 0x5e310
    strlen((char *)str);
    int32_t v1; // bp-12344, 0x5e310
    int32_t v2 = &v1;
    int32_t result; // 0x5e40c
    while (true) {
        char * found_char_pos = strchr((char *)str, 37); // 0x5e40c
        result = (int32_t)found_char_pos;
        while (found_char_pos != NULL) {
            int32_t v3 = result + 1;
            char * v4; // bp-12340, 0x5e310
            memset((int32_t *)&v4, 0, 0x1001);
            int32_t v5; // bp-8240, 0x5e310
            memset(&v5, 0, 0x1001);
            int32_t v6; // bp-4140, 0x5e310
            memset(&v6, 0, 0x1001);
            v1 = 0;
            int32_t str2; // 0x5e310
            int32_t v7; // bp-12339, 0x5e310
            if (sscanf2(v3, "%[.0-9-]%n", &v7, v2) == 1) {
                // 0x5e334
                v4 = (char *)37;
                int32_t v8; // bp-12328, 0x5e310
                *(char *)((int32_t)&v8 - 11 + v1) = 115;
                str2 = v1 + v3;
            } else {
                // 0x5e48c
                v1 = 0;
                v4 = (char *)0x7325;
                str2 = v3;
            }
            // 0x5e350
            if (sscanf2(str2, "E(%[^)])%n", &v5, v2) != 0) {
                // break -> 0x5e374
                break;
            }
            found_char_pos = strchr((char *)str2, 37);
            result = (int32_t)found_char_pos;
        }
        return result;
    }
    // 0x5e4a4
    return result;
}

// Address range: 0x5e558 - 0x5e680
int32_t function_5e558(int32_t result, int32_t a2) {
    uint32_t v1 = *(int32_t *)(result + 20); // 0x5e560
    if (v1 == 0) {
        // 0x5e574
        __asm_vmov_7(a2);
        return result;
    }
    int32_t * v2 = (int32_t *)(result + 24); // 0x5e568
    uint32_t v3 = *v2; // 0x5e568
    if (v1 == v3 || v1 < v3) {
        // 0x5e604
        function_5df98(2, "src/buf.c", 169, "a_buf->size_real[%ld] >= a_buf->size_max[%ld]");
        return 1;
    }
    uint32_t v4 = v3 + a2; // 0x5e5ec
    int32_t v5 = v1 >= v4 ? v4 : v1;
    int32_t * v6 = (int32_t *)(result + 4); // 0x5e5a0
    int32_t v7 = *v6; // 0x5e5a0
    int32_t v8 = function_1209c(result, v5, v4, v7); // 0x5e5ac
    int32_t result2; // 0x5e558
    if (v8 == 0) {
        // 0x5e638
        __errno_location();
        free(function_5df98(2, "src/buf.c", 189, "realloc fail, errno[%d]"), (int32_t)"src/buf.c", 189, (int32_t)"realloc fail, errno[%d]");
        *(int32_t *)result = 0;
        *v6 = 0;
        *(int32_t *)(result + 8) = 0;
        *(int32_t *)(result + 12) = 0;
        result2 = -1;
    } else {
        int32_t v9 = v8 + v5; // 0x5e5b8
        *v6 = v7 - result + v8;
        *(int32_t *)result = v8;
        *(int32_t *)(result + 12) = v9;
        *(int32_t *)(result + 8) = v9 - 1;
        *v2 = v5;
        result2 = v1 < v4;
    }
    // 0x5e5d8
    return result2;
}

// Address range: 0x5e680 - 0x5e6a4
int32_t function_5e680(int32_t a1) {
    int32_t v1 = *(int32_t *)(a1 + 4); // 0x5e680
    uint32_t v2 = *(int32_t *)(a1 + 1056); // 0x5e688
    uint32_t v3 = v1 - v2; // 0x5e690
    int32_t v4 = v3 < v2 ? v2 : v3;
    return function_11fc4((int32_t *)v4, a1 + 28, (char)(v1 - v4), v2);
}

// Address range: 0x5e6a4 - 0x5e6fc
int32_t function_5e6a4(int32_t a1, int32_t result) {
    // 0x5e6a4
    return result;
}

// Address range: 0x5e6fe - 0x5e700
int32_t function_5e6fe(void) {
    // 0x5e6fe
    int32_t result; // 0x5e6fe
    return result;
}

// Address range: 0x5e700 - 0x5e70c
int32_t function_5e700(int32_t a1, int32_t a2) {
    // 0x5e700
    int32_t v1; // 0x5e700
    return function_5df98(v1, (char *)v1, v1, (char *)v1);
}

// Address range: 0x5e70c - 0x5e758
int32_t function_5e70c(int32_t a1) {
    // 0x5e70c
    if (a1 != 0) {
        // 0x5e724
        int32_t v1; // 0x5e70c
        free(a1, v1, v1, v1);
    }
    // 0x5e728
    function_5df98(0, "src/buf.c", 82, "zlog_buf_del[%p]");
    return free(a1, (int32_t)"src/buf.c", 82, (int32_t)"zlog_buf_del[%p]");
}

// Address range: 0x5e758 - 0x5e8dc
int32_t function_5e758(uint32_t a1, uint32_t a2, int32_t str) {
    // 0x5e758
    if (a1 == 0) {
        // 0x5e860
        function_5df98(2, "src/buf.c", 92, "buf_size_min == 0, not allowed");
        // 0x5e7f8
        return 0;
    }
    if (a2 != 0) {
        if (a1 >= a2 == (a1 != a2)) {
            // 0x5e804
            function_5df98(2, "src/buf.c", 98, "buf_size_max[%lu] < buf_size_min[%lu] && buf_size_max != 0");
            // 0x5e7f8
            return 0;
        }
    }
    // 0x5e778
    int32_t v1; // 0x5e758
    int32_t result = function_11eb0(1, 1060, str, v1); // 0x5e784
    if (result == 0) {
        // 0x5e884
        __errno_location();
        function_5df98(2, "src/buf.c", 104, "calloc fail, errno[%d]");
        // 0x5e7f8
        return 0;
    }
    int32_t v2 = 0; // 0x5e794
    if (str != 0) {
        uint32_t len = strlen((char *)str); // 0x5e79c
        if (len >= 1024 == (len != 1024)) {
            // 0x5e830
            function_5df98(2, "src/buf.c", 110, "truncate_str[%s] overflow");
            // 0x5e850
            function_5e70c(result);
            // 0x5e7f8
            return 0;
        }
        // 0x5e7ac
        v2 = len + 1;
        function_11fc4((int32_t *)(result + 28), str, (char)v2, v1);
        *(int32_t *)(result + 1056) = len;
    }
    // 0x5e7c0
    *(int32_t *)(result + 16) = a1;
    *(int32_t *)(result + 20) = a2;
    *(int32_t *)(result + 24) = a1;
    int32_t v3 = function_11eb0(1, a1, v2, v1); // 0x5e7d4
    *(int32_t *)result = v3;
    if (v3 == 0) {
        // 0x5e8b0
        __errno_location();
        function_5df98(2, "src/buf.c", 124, "calloc fail, errno[%d]");
        // 0x5e850
        function_5e70c(result);
        // 0x5e7f8
        return 0;
    }
    int32_t v4 = v3 + a1; // 0x5e7e4
    *(int32_t *)(result + 4) = v3;
    *(int32_t *)(result + 12) = v4;
    *(int32_t *)(result + 8) = v4 - 1;
    // 0x5e7f8
    return result;
}

// Address range: 0x5e8dc - 0x5eb48
int32_t function_5e8dc(int32_t a1, int32_t a2, int32_t a3) {
    if (a1 == 0) {
        // 0x5ea50
        function_5df98(2, "src/buf.c", 214, "pre-use of zlog_buf_resize fail, so can't convert");
        // 0x5e950
        return -1;
    }
    int32_t * v1 = (int32_t *)(a1 + 12); // 0x5e8f0
    int32_t * v2 = (int32_t *)(a1 + 4); // 0x5e8f8
    int32_t str = *v2; // 0x5e8f8
    uint32_t size = *v1 - str; // 0x5e910
    char * format = (char *)a2; // 0x5e91c
    int32_t chars_printed = vsnprintf((char *)str, size, format, a3); // 0x5e91c
    if (chars_printed >= 0 && chars_printed < size) {
        // 0x5e95c
        *v2 = *v2 + chars_printed;
        return 0;
    }
    if (chars_printed < 0) {
        // 0x5ea74
        __errno_location();
        function_5df98(2, "src/buf.c", 226, "vsnprintf fail, errno[%d]");
        function_5df98(2, "src/buf.c", 227, "nwrite[%d], size_left[%ld], format[%s]");
        // 0x5e950
        return -1;
    }
    // 0x5e944
    if (chars_printed < size) {
        // 0x5e950
        return 0;
    }
    int32_t v3 = function_5e558(a1, 1 - size + chars_printed); // 0x5e984
    if (v3 > 0) {
        // 0x5e9d8
        function_5df98(2, "src/buf.c", 234, "conf limit to %ld, can't extend, so truncate");
        int32_t str2 = *v2; // 0x5e9fc
        int32_t size2 = *v1 - str2; // 0x5ea14
        vsnprintf((char *)str2, size2, format, a3);
        *v2 = size2 - 1 + *v2;
        if (*(char *)(a1 + 28) != 0) {
            // 0x5ea40
            function_5e680(a1);
        }
        // 0x5e950
        return 1;
    }
    if (v3 != 0) {
        // 0x5eacc
        function_5df98(2, "src/buf.c", 243, "zlog_buf_resize fail");
        // 0x5e950
        return -1;
    }
    int32_t str3 = *v2; // 0x5e994
    uint32_t chars_printed2 = vsnprintf((char *)str3, *v1 - str3, format, a3); // 0x5e9b4
    if (chars_printed2 >= 0) {
        // 0x5e9c0
        *v2 = *v2 + chars_printed2;
        return 0;
    }
    // 0x5eaf0
    __errno_location();
    function_5df98(2, "src/buf.c", 252, "vsnprintf fail, errno[%d]");
    function_5df98(2, "src/buf.c", 253, "nwrite[%d], size_left[%ld], format[%s]");
    // 0x5e950
    return -1;
}

// Address range: 0x5eb48 - 0x5ed04
int32_t function_5eb48(int32_t a1, int32_t a2, uint32_t a3) {
    if (a1 == 0) {
        // 0x5ece0
        function_5df98(2, "src/buf.c", 276, "pre-use of zlog_buf_resize fail, so can't convert");
        // 0x5ebf8
        return -1;
    }
    // 0x5eb5c
    int32_t v1; // bp-33, 0x5eb48
    int32_t v2 = &v1; // 0x5eb5c
    int32_t v3 = v2; // 0x5eb6c
    uint32_t v4 = a2;
    int32_t v5 = v4 / 10; // 0x5eb74
    v3--;
    *(char *)v3 = (char)(v4 - 2 * v5) + 48;
    while (v4 >= 10) {
        // 0x5eb70
        v4 = v5;
        v5 = v4 / 10;
        v3--;
        *(char *)v3 = (char)(v4 - 2 * v5) + 48;
    }
    int32_t v6 = v2 - v3; // 0x5eb90
    int32_t * v7 = (int32_t *)(a1 + 4); // 0x5eb9c
    int32_t v8 = *v7; // 0x5eb9c
    int32_t * v9 = (int32_t *)(a1 + 8); // 0x5eb9c
    uint32_t v10 = *v9; // 0x5eb9c
    int32_t v11; // 0x5eb48
    int32_t v12; // 0x5eb48
    int32_t v13; // 0x5eb48
    int32_t v14; // 0x5eb48
    int32_t v15; // 0x5eb48
    int32_t v16; // 0x5eb48
    int32_t v17; // 0x5eb48
    int32_t v18; // 0x5eb48
    if (v6 == a3 || v6 > a3) {
        int32_t v19 = v8 + v6; // 0x5ebd0
        v12 = v8;
        v15 = 0;
        v18 = v19;
        v13 = v6;
        v16 = 0;
        if (v19 >= v10 == (v19 != v10)) {
            goto lab_0x5ec04;
        } else {
            goto lab_0x5ebe0;
        }
    } else {
        int32_t v20 = v8 + a3; // 0x5eba4
        int32_t v21 = a3 - v6; // 0x5eba8
        v11 = v8;
        v14 = v21;
        v17 = v20;
        v13 = a3;
        v16 = v21;
        if (v20 >= v10 == (v20 != v10)) {
            goto lab_0x5ec04;
        } else {
            goto lab_0x5ebb4;
        }
    }
  lab_0x5ec04:;
    uint32_t v22 = v16;
    int32_t v23 = function_5e558(a1, v8 - v10 + v13); // 0x5ec10
    if (v23 > 0) {
        // 0x5ec4c
        function_5df98(2, "src/buf.c", 302, "conf limit to %ld, can't extend, so output");
        int32_t v24 = *v7; // 0x5ec70
        uint32_t v25 = *v9 - v24; // 0x5ec74
        bool v26 = v25 == v22 | v25 < v22; // 0x5ec7c
        int32_t v27 = v26 ? v25 : v22;
        int32_t v28 = v24; // 0x5ec8c
        if (v27 != 0) {
            // 0x5eccc
            memset((int32_t *)v24, 48, v27);
            v28 = *v7;
        }
        int32_t v29 = v25 >= v22 == (v25 != v22) ? v25 - v27 : v13;
        char v30 = v26 ? 0 : (char)v29;
        function_11fc4((int32_t *)(v28 + v27), v3, v30, (int32_t)"conf limit to %ld, can't extend, so output");
        *v7 = *v7 + v25;
        if (*(char *)(a1 + 28) != 0) {
            // 0x5ecbc
            function_5e680(a1);
        }
        // 0x5ebf8
        return 1;
    }
    if (v23 != 0) {
        // 0x5ec28
        function_5df98(2, "src/buf.c", 318, "zlog_buf_resize fail");
        // 0x5ebf8
        return -1;
    }
    int32_t v31 = *v7; // 0x5ec1c
    v11 = v31;
    v14 = v22;
    v17 = v31 + v13;
    goto lab_0x5ebb4;
  lab_0x5ebe0:
    // 0x5ebe0
    function_11fc4((int32_t *)(v15 + v12), v3, (char)v6, v10);
    *v7 = v18;
    // 0x5ebf8
    return 0;
  lab_0x5ebb4:
    // 0x5ebb4
    v12 = v11;
    v15 = 0;
    v18 = v17;
    if (v14 != 0) {
        // 0x5ebbc
        memset((int32_t *)v11, 48, v14);
        v12 = *v7;
        v15 = v14;
        v18 = v17;
    }
    goto lab_0x5ebe0;
}

// Address range: 0x5ed04 - 0x5ef24
int32_t function_5ed04(int32_t a1, int32_t a2, int32_t a3, int32_t a4, uint32_t a5) {
    if (a1 == 0) {
        // 0x5ef00
        function_5df98(2, "src/buf.c", 342, "pre-use of zlog_buf_resize fail, so can't convert");
        // 0x5edbc
        return -1;
    }
    int32_t v1; // 0x5ed04
    int32_t v2; // 0x5ed04
    int32_t v3; // 0x5ed04
    int32_t v4; // 0x5ed04
    int32_t v5; // bp-36, 0x5ed04
    if (a4 == 0) {
        int32_t v6 = &v5; // 0x5ed34
        v1 = v6;
        if (a3 == -1 == (a3 != -1)) {
            goto lab_0x5edc8;
        } else {
            uint32_t v7 = a3;
            int32_t v8 = v7 / 10; // 0x5ed4c
            int32_t v9 = v7 - 2 * v8 + 48; // 0x5ed5c
            int32_t v10 = v6 - 1; // 0x5ed60
            *(char *)v10 = (char)v9;
            int32_t v11 = v10; // 0x5ed64
            v2 = v6;
            v3 = v9;
            v4 = v10;
            while (v7 >= 10) {
                // 0x5ed48
                v7 = v8;
                v8 = v7 / 10;
                v9 = v7 - 2 * v8 + 48;
                v10 = v11 - 1;
                *(char *)v10 = (char)v9;
                v11 = v10;
                v2 = v6;
                v3 = v9;
                v4 = v10;
            }
            goto lab_0x5ed68;
        }
    } else {
        // .thread13
        v1 = &v5;
        goto lab_0x5edc8;
    }
  lab_0x5edc8:
    // 0x5edc8
    function_60120(a3, a4);
    int32_t v12 = v1 - 1; // 0x5edf0
    *(char *)v12 = 58;
    int32_t v13 = function_60120(a3, a4); // 0x5edf4
    v2 = v1;
    v3 = 0;
    v4 = v12;
    int32_t v14 = v13; // 0x5ee04
    int32_t v15 = v12; // 0x5ee04
    while ((v13 || a4) != 0) {
        // 0x5edc8
        function_60120(v14, a4);
        v12 = v15 - 1;
        *(char *)v12 = 58;
        v13 = function_60120(v14, a4);
        v2 = v1;
        v3 = 0;
        v4 = v12;
        v14 = v13;
        v15 = v12;
    }
    goto lab_0x5ed68;
  lab_0x5ed68:;
    int32_t v16 = v2 - v4; // 0x5ed6c
    int32_t v17 = a1 + 4; // 0x5ed70
    uint64_t v18 = *(int64_t *)v17; // 0x5ed70
    uint32_t v19 = (int32_t)v18; // 0x5ed70
    int32_t v20 = v18 / 0x100000000; // 0x5ed70
    int32_t v21; // 0x5ed04
    int32_t v22; // 0x5ed04
    int32_t v23; // 0x5ed04
    int32_t v24; // 0x5ed04
    int32_t v25; // 0x5ed04
    int32_t v26; // 0x5ed04
    int32_t v27; // 0x5ed04
    int32_t v28; // 0x5ed04
    if (v16 == a5 || v16 > a5) {
        int32_t v29 = v16 + v20; // 0x5ee0c
        v22 = v20;
        v25 = 0;
        v28 = v29;
        v23 = v16;
        v26 = 0;
        if (v29 == v19 || v29 < v19) {
            goto lab_0x5eda4;
        } else {
            goto lab_0x5ee24;
        }
    } else {
        int32_t v30 = v20 + a5; // 0x5ed7c
        int32_t v31 = a5 - v16; // 0x5ed80
        v21 = v20;
        v24 = v31;
        v27 = v30;
        v23 = a5;
        v26 = v31;
        if (v30 >= v19 == (v30 != v19)) {
            goto lab_0x5ee24;
        } else {
            goto lab_0x5ed8c;
        }
    }
  lab_0x5eda4:
    // 0x5eda4
    function_11fc4((int32_t *)(v25 + v22), v4, (char)v16, v3);
    *(int32_t *)v17 = v28;
    // 0x5edbc
    return 0;
  lab_0x5ee24:;
    uint32_t v32 = v26;
    int32_t v33 = function_5e558(a1, v20 - v19 + v23); // 0x5ee30
    if (v33 > 0) {
        // 0x5ee6c
        function_5df98(2, "src/buf.c", 393, "conf limit to %ld, can't extend, so output");
        int32_t * v34 = (int32_t *)v17; // 0x5ee90
        int32_t v35 = *v34; // 0x5ee90
        uint32_t v36 = *(int32_t *)(a1 + 8) - v35; // 0x5ee94
        bool v37 = v36 == v32 | v36 < v32; // 0x5ee9c
        int32_t v38 = v37 ? v36 : v32;
        int32_t v39 = v35; // 0x5eeac
        if (v38 != 0) {
            // 0x5eeec
            memset((int32_t *)v35, 48, v38);
            v39 = *v34;
        }
        int32_t v40 = v36 >= v32 == (v36 != v32) ? v36 - v38 : v16;
        char v41 = v37 ? 0 : (char)v40;
        function_11fc4((int32_t *)(v39 + v38), v4, v41, (int32_t)"conf limit to %ld, can't extend, so output");
        *v34 = *v34 + v36;
        if (*(char *)(a1 + 28) != 0) {
            // 0x5eedc
            function_5e680(a1);
        }
        // 0x5edbc
        return 1;
    }
    if (v33 != 0) {
        // 0x5ee48
        function_5df98(2, "src/buf.c", 409, "zlog_buf_resize fail");
        // 0x5edbc
        return -1;
    }
    int32_t v42 = *(int32_t *)v17; // 0x5ee3c
    v21 = v42;
    v24 = v32;
    v27 = v42 + v23;
    goto lab_0x5ed8c;
  lab_0x5ed8c:
    // 0x5ed8c
    v22 = v21;
    v25 = 0;
    v28 = v27;
    if (v24 != 0) {
        // 0x5ed94
        memset((int32_t *)v21, 48, v24);
        v22 = *(int32_t *)v17;
        v25 = v24;
        v28 = v27;
    }
    goto lab_0x5eda4;
}

// Address range: 0x5ef24 - 0x5f0d4
int32_t function_5ef24(int32_t a1, int32_t a2, uint32_t a3) {
    if (a1 == 0) {
        // 0x5f0b0
        function_5df98(2, "src/buf.c", 434, "pre-use of zlog_buf_resize fail, so can't convert");
        // 0x5efc8
        return -1;
    }
    // 0x5ef38
    int32_t v1; // bp-33, 0x5ef24
    int32_t v2 = &v1; // 0x5ef3c
    uint32_t v3 = a2; // 0x5ef48
    int32_t v4 = v2; // 0x5ef48
    char v5 = *(char *)(v3 % 16 | (int32_t)"0123456789abcdef"); // 0x5ef54
    v4--;
    *(char *)v4 = v5;
    while (v3 >= 16) {
        // 0x5ef4c
        v3 /= 16;
        v5 = *(char *)(v3 % 16 | (int32_t)"0123456789abcdef");
        v4--;
        *(char *)v4 = v5;
    }
    int32_t v6 = v2 - v4; // 0x5ef60
    int32_t * v7 = (int32_t *)(a1 + 4); // 0x5ef6c
    int32_t v8 = *v7; // 0x5ef6c
    int32_t * v9 = (int32_t *)(a1 + 8); // 0x5ef6c
    uint32_t v10 = *v9; // 0x5ef6c
    int32_t v11; // 0x5ef24
    int32_t v12; // 0x5ef24
    int32_t v13; // 0x5ef24
    int32_t v14; // 0x5ef24
    int32_t v15; // 0x5ef24
    int32_t v16; // 0x5ef24
    int32_t v17; // 0x5ef24
    int32_t v18; // 0x5ef24
    if (v6 == a3 || v6 > a3) {
        int32_t v19 = v8 + v6; // 0x5efa0
        v12 = v8;
        v14 = 0;
        v18 = v19;
        v15 = 0;
        v16 = v6;
        if (v10 < v19) {
            goto lab_0x5efd4;
        } else {
            goto lab_0x5efb0;
        }
    } else {
        int32_t v20 = v8 + a3; // 0x5ef74
        int32_t v21 = a3 - v6; // 0x5ef78
        v11 = v8;
        v13 = v21;
        v17 = v20;
        v15 = v21;
        v16 = a3;
        if (v20 >= v10 == (v20 != v10)) {
            goto lab_0x5efd4;
        } else {
            goto lab_0x5ef84;
        }
    }
  lab_0x5efd4:;
    uint32_t v22 = v15;
    int32_t v23 = function_5e558(a1, v8 - v10 + v16); // 0x5efe0
    if (v23 > 0) {
        // 0x5f01c
        function_5df98(2, "src/buf.c", 473, "conf limit to %ld, can't extend, so output");
        int32_t v24 = *v7; // 0x5f040
        uint32_t v25 = *v9 - v24; // 0x5f044
        bool v26 = v25 == v22 | v25 < v22; // 0x5f04c
        int32_t v27 = v26 ? v25 : v22;
        int32_t v28 = v24; // 0x5f05c
        if (v27 != 0) {
            // 0x5f09c
            memset((int32_t *)v24, 48, v27);
            v28 = *v7;
        }
        int32_t v29 = v25 >= v22 == (v25 != v22) ? v25 - v27 : v16;
        char v30 = v26 ? 0 : (char)v29;
        function_11fc4((int32_t *)(v28 + v27), v4, v30, (int32_t)"conf limit to %ld, can't extend, so output");
        *v7 = *v7 + v25;
        if (*(char *)(a1 + 28) != 0) {
            // 0x5f08c
            function_5e680(a1);
        }
        // 0x5efc8
        return 1;
    }
    if (v23 != 0) {
        // 0x5eff8
        function_5df98(2, "src/buf.c", 489, "zlog_buf_resize fail");
        // 0x5efc8
        return -1;
    }
    int32_t v31 = *v7; // 0x5efec
    v11 = v31;
    v13 = v22;
    v17 = v31 + v16;
    goto lab_0x5ef84;
  lab_0x5efb0:
    // 0x5efb0
    function_11fc4((int32_t *)(v14 + v12), v4, (char)v6, v10);
    *v7 = v18;
    // 0x5efc8
    return 0;
  lab_0x5ef84:
    // 0x5ef84
    v12 = v11;
    v14 = 0;
    v18 = v17;
    if (v13 != 0) {
        // 0x5ef8c
        memset((int32_t *)v11, 48, v13);
        v12 = *v7;
        v14 = v13;
        v18 = v17;
    }
    goto lab_0x5efb0;
}

// Address range: 0x5f0d4 - 0x5f1cc
int32_t function_5f0d4(int32_t a1, int32_t a2, int32_t a3) {
    int32_t * v1 = (int32_t *)(a1 + 4); // 0x5f0d4
    int32_t v2 = *v1; // 0x5f0d4
    int32_t * v3 = (int32_t *)(a1 + 8); // 0x5f0e0
    uint32_t v4 = *v3; // 0x5f0e0
    int32_t v5 = v2 + a3;
    int32_t v6 = v2; // 0x5f0f8
    int32_t v7 = v5; // 0x5f0f8
    if (v5 > v4) {
        int32_t v8 = function_5e558(a1, v5 - v4); // 0x5f104
        if (v8 > 0) {
            // 0x5f13c
            function_5df98(2, "src/buf.c", 525, "conf limit to %ld, can't extend, so output");
            int32_t v9 = *v1; // 0x5f160
            int32_t v10 = *v3 - v9; // 0x5f170
            function_11fc4((int32_t *)v9, a2, (char)v10, v9);
            *v1 = *v1 + v10;
            if (*(char *)(a1 + 28) != 0) {
                // 0x5f198
                function_5e680(a1);
            }
            // 0x5f134
            return 1;
        }
        if (v8 != 0) {
            // 0x5f1a8
            function_5df98(2, "src/buf.c", 533, "zlog_buf_resize fail");
            // 0x5f134
            return -1;
        }
        // .thread
        v6 = *v1;
        v7 = v6 + a3;
    }
    int32_t v11 = v6;
    function_11fc4((int32_t *)v11, a2, (char)a3, v11);
    *v1 = v7;
    // 0x5f134
    return 0;
}

// Address range: 0x5f1cc - 0x5f3f8
int32_t function_5f1cc(int32_t a1, int32_t a2, uint32_t a3, int32_t a4, int32_t a5, uint32_t a6, uint32_t a7) {
    if (a1 == 0) {
        // 0x5f3b0
        function_5df98(2, "src/buf.c", 562, "pre-use of zlog_buf_resize fail, so can't convert");
        // 0x5f280
        return -1;
    }
    int32_t v1 = a7 == a3 | a7 < a3 ? 0 : a4;
    int32_t v2 = a7 == 0 | a7 >= a3 == (a7 != a3) ? 1 : v1;
    int32_t v3 = a1 + 4; // 0x5f208
    uint64_t v4 = *(int64_t *)v3; // 0x5f208
    int32_t v5 = v4 / 0x100000000; // 0x5f208
    uint32_t v6 = v2 == 0 ? a7 : a3;
    bool v7 = a6 == 0 | v6 >= a6;
    uint32_t v8 = (int32_t)v4 - v5; // 0x5f21c
    uint32_t v9 = v7 ? v6 : a6;
    uint32_t v10 = v7 ? 0 : a6 - v6;
    int32_t v11 = v5; // 0x5f230
    if (v9 > v8) {
        int32_t v12 = function_5e558(a1, v9 - v8); // 0x5f2a8
        if (v12 > 0) {
            // 0x5f2c0
            function_5df98(2, "src/buf.c", 592, "conf limit to %ld, can't extend, so output");
            int32_t * v13 = (int32_t *)v3; // 0x5f2e4
            int32_t v14 = *v13; // 0x5f2e4
            uint32_t v15 = *(int32_t *)(a1 + 8) - v14; // 0x5f2f0
            if (a4 == 0) {
                int32_t v16 = v15 <= v10 ? v15 : v10;
                int32_t v17 = v14; // 0x5f364
                int32_t v18 = (int32_t)"conf limit to %ld, can't extend, so output"; // 0x5f364
                if (v16 != 0) {
                    // 0x5f368
                    memset((int32_t *)v14, a5 == 0 ? 32 : 48, v16);
                    v17 = *v13;
                    v18 = a5;
                }
                char v19 = v15 <= v10 ? 0 : (char)(v15 - v10);
                function_11fc4((int32_t *)(v17 + v16), a2, v19, v18);
            } else {
                int32_t v20 = v6 >= v15 ? v15 : v6;
                int32_t v21 = v14; // 0x5f300
                if (v6 < v15) {
                    // 0x5f398
                    memset((int32_t *)(v20 + v14), 32, v15 - v20);
                    v21 = *v13;
                }
                // 0x5f304
                function_11fc4((int32_t *)v21, a2, (char)v20, (int32_t)"conf limit to %ld, can't extend, so output");
            }
            // 0x5f310
            *v13 = *v13 + v15;
            if (*(char *)(a1 + 28) != 0) {
                // 0x5f32c
                function_5e680(a1);
            }
            // 0x5f280
            return 1;
        }
        if (v12 != 0) {
            // 0x5f3d4
            function_5df98(2, "src/buf.c", 624, "zlog_buf_resize fail");
            // 0x5f280
            return -1;
        }
        // 0x5f2b8
        v11 = *(int32_t *)v3;
    }
    // 0x5f234
    if (a4 == 0) {
        int32_t v22 = v11; // 0x5f240
        int32_t v23 = v2; // 0x5f240
        if (v10 != 0) {
            // 0x5f244
            memset((int32_t *)v11, a5 == 0 ? 32 : 48, v10);
            v22 = *(int32_t *)v3;
            v23 = a5;
        }
        // 0x5f260
        function_11fc4((int32_t *)(v22 + v10), a2, (char)v6, v23);
    } else {
        int32_t v24 = v11; // 0x5f28c
        if (v10 != 0) {
            // 0x5f33c
            memset((int32_t *)(v11 + v6), 32, v10);
            v24 = *(int32_t *)v3;
        }
        // 0x5f290
        function_11fc4((int32_t *)v24, a2, (char)v6, v2);
    }
    int32_t * v25 = (int32_t *)v3; // 0x5f270
    *v25 = *v25 + v9;
    // 0x5f280
    return 0;
}

// Address range: 0x5f3f8 - 0x5f474
int32_t function_5f3f8(int32_t a1, int32_t a2) {
    if (a1 == 0) {
        // 0x5f458
        return function_5df98(2, "src/level.c", 19, "a_level is null or 0");
    }
    // 0x5f400
    return function_5df98(a2, "src/level.c", 26, "---level[%p][%d,%s,%s,%d,%d]---");
}

// Address range: 0x5f474 - 0x5f4d8
int32_t function_5f474(int32_t a1) {
    if (a1 == 0) {
        // 0x5f4b4
        return function_5df98(2, "src/level.c", 33, "a_level is null or 0");
    }
    // 0x5f484
    function_5df98(0, "src/level.c", 34, "zlog_level_del[%p]");
    return free(a1, (int32_t)"src/level.c", 34, (int32_t)"zlog_level_del[%p]");
}

// Address range: 0x5f4d8 - 0x5f880
int32_t function_5f4d8(int32_t a1) {
    int32_t v1 = 0; // bp-8228, 0x5f4ec
    if (a1 == 0) {
        // 0x5f7dc
        function_5df98(2, "src/level.c", 77, "line is null or 0");
        // 0x5f5f8
        return 0;
    }
    // 0x5f4f4
    int32_t v2; // bp-8224, 0x5f4d8
    memset(&v2, 0, 0x1001);
    int32_t str; // bp-4124, 0x5f4d8
    memset(&str, 0, 0x1001);
    int32_t v3 = &v1; // 0x5f530
    if (sscanf2(a1, " %[^= \t] = %d ,%s", &v2, v3) < 2) {
        // 0x5f800
        function_5df98(2, "src/level.c", 84, "level[%s], syntax wrong");
        // 0x5f5f8
        return 0;
    }
    uint32_t v4 = v1; // 0x5f544
    if (v4 >= 255 == (v4 != 255)) {
        // 0x5f7b8
        function_5df98(2, "src/level.c", 90, "l[%d] not in [0,255], wrong");
        // 0x5f5f8
        return 0;
    }
    int32_t v5 = v2 % 256; // 0x5f550
    if (v5 == 0) {
        // 0x5f77c
        function_5df98(2, "src/level.c", 95, "str[0] = 0");
        // 0x5f5f8
        return 0;
    }
    int32_t result = function_11eb0(1, 2064, v4, v3); // 0x5f564
    if (result == 0) {
        // 0x5f830
        __errno_location();
        function_5df98(2, "src/level.c", 101, "calloc fail, errno[%d]");
        // 0x5f5f8
        return 0;
    }
    // 0x5f570
    *(int32_t *)result = v1;
    if (str % 256 == 0) {
        // 0x5f58c
        *(int32_t *)(result + 2060) = 7;
        goto lab_0x5f594;
    } else {
        // 0x5f608
        if (strcasecmp((char *)&str, "LOG_EMERG") == 0) {
            // 0x5f710
            *(int32_t *)(result + 2060) = 0;
            goto lab_0x5f594;
        } else {
            // 0x5f620
            if (strcasecmp((char *)&str, "LOG_ALERT") == 0) {
                // 0x5f7a0
                *(int32_t *)(result + 2060) = 1;
                goto lab_0x5f594;
            } else {
                // 0x5f638
                if (strcasecmp((char *)&str, "LOG_CRIT") == 0) {
                    // 0x5f824
                    *(int32_t *)(result + 2060) = 2;
                    goto lab_0x5f594;
                } else {
                    // 0x5f650
                    if (strcasecmp((char *)&str, "LOG_ERR") == 0) {
                        // 0x5f7ac
                        *(int32_t *)(result + 2060) = 3;
                        goto lab_0x5f594;
                    } else {
                        // 0x5f668
                        if (strcasecmp((char *)&str, "LOG_WARNING") == 0) {
                            // 0x5f85c
                            *(int32_t *)(result + 2060) = 4;
                            goto lab_0x5f594;
                        } else {
                            // 0x5f680
                            if (strcasecmp((char *)&str, "LOG_NOTICE") == 0) {
                                // 0x5f868
                                *(int32_t *)(result + 2060) = 5;
                                goto lab_0x5f594;
                            } else {
                                // 0x5f698
                                if (strcasecmp((char *)&str, "LOG_INFO") == 0) {
                                    // 0x5f874
                                    *(int32_t *)(result + 2060) = 6;
                                    goto lab_0x5f594;
                                } else {
                                    // 0x5f6b0
                                    if (strcasecmp((char *)&str, "LOG_DEBUG") != 0) {
                                        // 0x5f6c8
                                        function_5df98(2, "src/level.c", 63, "wrong syslog level[%s]");
                                        *(int32_t *)(result + 2060) = -187;
                                        function_5df98(2, "src/level.c", 113, "syslog_level_atoi fail");
                                        // 0x5f74c
                                        function_5df98(2, "src/level.c", 138, "line[%s]");
                                        function_5f474(result);
                                        // 0x5f5f8
                                        return 0;
                                    }
                                    // 0x5f58c
                                    *(int32_t *)(result + 2060) = 7;
                                    goto lab_0x5f594;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
  lab_0x5f594:;
    int32_t * v6 = *__ctype_toupper_loc(); // 0x5f598
    int32_t * v7 = *__ctype_tolower_loc(); // 0x5f5a4
    int32_t v8 = &v2; // 0x5f5b4
    int32_t v9 = 1; // 0x5f5bc
    int32_t v10 = 4 * __asm_sxth(v5); // 0x5f5c4
    int32_t v11 = *(int32_t *)(v10 + (int32_t)v6); // 0x5f5c4
    int32_t v12 = 4 + result; // 0x5f5c8
    *(char *)v12 = (char)v11;
    int32_t v13 = *(int32_t *)(v10 + (int32_t)v7); // 0x5f5cc
    int32_t v14 = 1029 + result; // 0x5f5d0
    *(char *)v14 = (char)v13;
    while (v9 != 1024) {
        int32_t v15 = v8 + 1; // 0x5f5d8
        unsigned char v16 = *(char *)v15; // 0x5f5d8
        v8 = v15;
        if (v16 == 0) {
            goto lab_0x5f5e4;
        }
        v9++;
        v10 = 4 * __asm_sxth((int32_t)v16);
        v11 = *(int32_t *)(v10 + (int32_t)v6);
        v12++;
        *(char *)v12 = (char)v11;
        v13 = *(int32_t *)(v10 + (int32_t)v7);
        v14++;
        *(char *)v14 = (char)v13;
    }
    char v17; // 0x5f4d8
    if (v17 != 0) {
        // 0x5f724
        function_5df98(2, "src/level.c", 126, "not enough space for str, str[%s] > %d");
        // 0x5f74c
        function_5df98(2, "src/level.c", 138, "line[%s]");
        function_5f474(result);
        // 0x5f5f8
        return 0;
    }
  lab_0x5f5e4:;
    int32_t v18 = v9 + result; // 0x5f5e4
    *(char *)(v18 + 4) = 0;
    *(char *)(v18 + 1029) = 0;
    *(int32_t *)(result + 2056) = v9;
    // 0x5f5f8
    return result;
}

// Address range: 0x5f880 - 0x5f884
int32_t function_5f880(void) {
    int32_t result; // 0x5f880
    return result;
}

// Address range: 0x5f884 - 0x5f886
int32_t function_5f884(void) {
    // 0x5f884
    int32_t result; // 0x5f884
    return result;
}

// Address range: 0x5f886 - 0x5fadc
int32_t function_5f886(uint32_t result, uint32_t a2, int32_t a3) {
    // 0x5f886
    bool v1; // 0x5f886
    if (!v1) {
        // 0x5fad2
        return function_60150((int32_t)(result != 0), a2);
    }
    if (result == a2 || result < a2) {
        if (result == a2) {
            __asm_ite();
        }
        return result == a2;
    }
    if ((a3 & a2) == 0) {
        // 0x5fac4
        return result >> (llvm_ctlz_i32(a2, true) ^ 31);
    }
    // 0x5f896
    __asm_adr(16);
    return result;
}

// Address range: 0x5fadc - 0x5faec
int32_t function_5fadc(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x5fadc
    bool v1; // 0x5fadc
    int32_t v2; // 0x5fadc
    if (v1 || false) {
        if (0x40000 * result + (int32_t)((result & 0x4000) == 0) - v2 < 0) {
            __asm_mcr2(7, 6, 0x5faec, 12, 15, 7);
            *(int16_t *)v2 = (int16_t)(v2 / 0x40000 & a4);
            return result;
        }
    } else {
        if (v1) {
            __asm_mcr2(7, 6, 0x5faec, 12, 15, 7);
            *(int16_t *)v2 = (int16_t)(v2 / 0x40000 & a4);
            return result;
        }
    }
    // .thread
    __asm_mcr2(7, 6, 0x5faec, 12, 15, 7);
    return result;
}

// Address range: 0x5faec - 0x5faf6
int32_t function_5faec(int32_t result, int32_t a2, int32_t a3) {
    // 0x5faec
    return result;
}

// Address range: 0x5faf8 - 0x5faf9
int32_t function_5faf8(void) {
    // 0x5faf8
    int32_t result; // 0x5faf8
    return result;
}

// Address range: 0x5fafa - 0x5fd8c
int32_t function_5fafa(int32_t a1, int32_t a2) {
    // 0x5fafa
    bool v1; // 0x5fafa
    if (v1) {
        int32_t v2 = a1; // 0x5fd7c
        if (a1 > 0) {
            v2 = __asm_it();
        }
        int32_t v3 = a1 > 0 ? 0x7fffffff : v2; // 0x5fd82
        if (a1 < 0) {
            v3 = __asm_it();
        }
        return function_60150(a1 >= 0 ? v3 : -0x80000000, a2);
    }
    int32_t v4 = a1; // 0x5fb02
    if (v1) {
        v4 = __asm_it();
    }
    int32_t v5 = a2 ^ a1; // 0x5fafe
    int32_t v6 = v4;
    uint32_t v7 = v1 ? -a2 : a2;
    if (v7 == 1) {
        int32_t v8 = v6; // 0x5fd4e
        if ((v6 ^ v5) < 0) {
            v8 = __asm_it();
        }
        int32_t v9 = v8;
        return (v6 ^ v5) < 0 ? -v9 : v9;
    }
    int32_t v10 = v6; // 0x5fb0e
    if (v6 < 0) {
        v10 = __asm_it();
    }
    uint32_t v11 = v6 < 0 ? -v10 : v6;
    if (v11 == v7 || v11 < v7) {
        int32_t v12 = v10; // 0x5fd54
        if (v11 < v7) {
            v12 = __asm_it();
        }
        int32_t v13 = v11 >= v7 ? v12 : 0; // 0x5fd58
        if (v11 == v7) {
            v13 = __asm_itt();
        }
        return v11 == v7 ? v5 >> 31 | 1 : v13;
    }
    if ((v7 - 1 & v7) != 0) {
        // 0x5fb1e
        __asm_adr(16);
        return 0;
    }
    int32_t v14 = v11 >> (llvm_ctlz_i32(v7, true) ^ 31); // 0x5fd74
    if (v5 < 0) {
        v14 = __asm_it();
    }
    int32_t v15 = v14;
    return v5 < 0 ? -v15 : v15;
}

// Address range: 0x5fd8c - 0x5fd9c
int32_t function_5fd8c(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x5fd8c
    bool v1; // 0x5fd8c
    int32_t v2; // 0x5fd8c
    if (v1 || false) {
        if (0x40000 * result + (int32_t)((result & 0x4000) == 0) - v2 < 0) {
            __asm_mrc2(7, 5, v2, 3, 15, 7);
            *(int16_t *)v2 = (int16_t)(v2 / 0x40000 & a4);
            return result;
        }
    } else {
        if (v1) {
            __asm_mrc2(7, 5, v2, 3, 15, 7);
            *(int16_t *)v2 = (int16_t)(v2 / 0x40000 & a4);
            return result;
        }
    }
    // .thread
    __asm_mrc2(7, 5, v2, 3, 15, 7);
    return result;
}

// Address range: 0x5fd9c - 0x5fda6
int32_t function_5fd9c(int32_t result, int32_t a2, int32_t a3) {
    // 0x5fd9c
    return result;
}

// Address range: 0x5fda8 - 0x5fdb8
int32_t function_5fda8(int32_t a1, int32_t a2) {
    // 0x5fda8
    bool v1; // 0x5fda8
    if (v1) {
        __asm_smlabbmi(a2, a1, 0x5fdb0);
    }
    if (v1) {
        return unknown_83();
    }
    // 0x5fdb4
    return function_144d27c();
}

// Address range: 0x5fdb8 - 0x5fdbc
int32_t function_5fdb8(void) {
    // 0x5fdb8
    return function_1420ec4();
}

// Address range: 0x5fdbc - 0x5fdc0
int32_t function_5fdbc(void) {
    // 0x5fdbc
    return function_fe5612d0();
}

// Address range: 0x5fdc0 - 0x5fdcc
int32_t function_5fdc0(void) {
    bool v1; // 0x5fdc0
    if (v1) {
        __asm_svceq(0x2ea90);
    }
    return function_158fa4c();
}

// Address range: 0x5fdcc - 0x5fdd0
int32_t function_5fdcc(void) {
    // 0x5fdcc
    return function_15a2dd4();
}

// Address range: 0x5fdd0 - 0x5fdd4
int32_t function_5fdd0(void) {
    // 0x5fdd0
    return function_2022de0();
}

// Address range: 0x5fdd4 - 0x5fdd8
int32_t function_5fdd4(void) {
    // 0x5fdd4
    return function_2036f6c();
}

// Address range: 0x5fdd8 - 0x6002a
int32_t function_5fdd8(int32_t a1, uint32_t a2, int32_t a3, uint32_t a4, int32_t a5, int32_t a6) {
    // 0x5fdd8
    int32_t v1; // 0x5fdd8
    uint32_t v2 = v1;
    bool v3; // 0x5fdd8
    if (v3) {
        int32_t result; // 0x5fdd8
        if (v2 > 0xffdfffff) {
            int32_t v4 = __asm_itt(); // 0x60010
            result = v4;
            if ((v4 || 0x1000 * a2) == 0) {
                result = __asm_itte();
            }
            // 0x5fff4
            return result;
        }
        int32_t v5 = __asm_it(); // 0x5ffb2
        if (v2 == (int32_t)*(char *)(v2 + a2)) {
            v5 = __asm_it();
            if (v5 == a3) {
                if (a2 != a4) {
                    __asm_ittt();
                    // 0x5fff4
                    return 0;
                }
                if (v2 < 0x200000) {
                    uint32_t v6 = 2 * a2; // 0x5ffda
                    result = 2 * a3;
                    if (a3 < 0 ? (v6 || (int32_t)(a3 < 0)) <= a2 : v6 < a2) {
                        result = __asm_it();
                    }
                } else {
                    // 0x5ffe4
                    result = 0;
                    if (-1 - v2 >= (int32_t)&g47) {
                        result = __asm_itt();
                    }
                }
                // 0x5fff4
                return result;
            }
        }
        int32_t v7 = v5; // 0x5ffbe
        if ((v5 || v2) == 0) {
            v7 = __asm_itt();
        }
        // 0x5fff4
        return (v5 | v2) == 0 ? a3 : v7;
    }
    int32_t v8 = a1; // 0x5fde6
    if (v2 >= 0x200000) {
        v8 = __asm_it();
    }
    if (v2 >= 0x6c00000 == ((v2 & -0x200000) != 0x6c00000)) {
        // 0x5fff4
        return __asm_it();
    }
    int32_t v9 = a2 % 0x100000 | (int32_t)&g1; // 0x5fe18
    int32_t v10 = v8; // 0x5fe1c
    int32_t v11 = v9; // 0x5fe1c
    if (a2 <= 0xffffffff) {
        // 0x5fe1e
        v10 = -v8;
        v11 = -1 * v9 - (int32_t)(v9 >= 0);
    }
    int32_t v12 = v11;
    int32_t v13 = a4 % 0x100000 | (int32_t)&g1; // 0x5fe2c
    int32_t v14 = a3; // 0x5fe30
    int32_t v15 = v13; // 0x5fe30
    if (a4 <= 0xffffffff) {
        // 0x5fe32
        v14 = -a3;
        v15 = -1 * v13 - (int32_t)(v13 >= 0);
    }
    int32_t v16 = v10; // 0x5ff96
    if (v2 < 0x200000) {
        v16 = __asm_itte();
    }
    uint32_t v17 = v2 / 0x200000; // 0x5fdde
    int32_t v18 = v15 ^ (int32_t)&g1; // 0x5ff92
    int32_t v19 = v2 < 0x200000 ? v12 ^ (int32_t)&g1 : v12;
    uint32_t v20 = v2 < 0x200000 ? 0 : v17 - 1;
    uint32_t v21 = 32 - v20; // 0x5fe44
    int32_t v22; // 0x5fdd8
    int32_t v23; // 0x5fdd8
    int32_t v24; // 0x5fdd8
    if (v20 > 32) {
        int32_t v25 = v16; // 0x5fe74
        if ((v18 & 0x80000000 >> v21 + 31) != 0) {
            v25 = __asm_it();
        }
        int32_t v26 = v18 << v21 + 32; // 0x5fe70
        int32_t v27 = v18 >> v20 - 32; // 0x5fe7a
        v23 = v25 + v27;
        v22 = (v18 & 0x80000000 >> v21 + 31) != 0 ? v26 | 2 : v26;
        v24 = (v27 >> 31) + v19 + (int32_t)((v27 & 0x40000000) != 0);
    } else {
        uint32_t v28 = v16 + (v14 >> v20); // 0x5fe52
        v23 = v28 + (v18 << v21);
        v22 = v14 << v21;
        v24 = (v18 >> v20) + v19 + (int32_t)((v18 & 1 << v20 - 1) != 0) + (int32_t)(v28 < v16);
    }
    int32_t v29 = v22;
    int32_t v30 = v23;
    int32_t v31 = v30; // 0x5fe88
    int32_t v32 = v24; // 0x5fe88
    int32_t v33 = v29; // 0x5fe88
    if (v24 < 0) {
        // 0x5fe8a
        v31 = (int32_t)(v29 != 0) - v30;
        bool v34 = v29 != 0 ? v30 != -1 | v31 != (int32_t)(v29 != 0) : v30 != 0; // 0x5fe92
        v32 = (int32_t)v34 - v24;
        v33 = -v29;
    }
    int32_t v35 = v17 + (int32_t)(v2 < 0x200000);
    int32_t v36 = v33;
    uint32_t v37 = v31;
    bool v38; // 0x5fdd8
    int32_t v39; // 0x5fdd8
    bool v40; // 0x5fdd8
    int32_t v41; // 0x5fdd8
    int32_t v42; // 0x5fdd8
    int32_t v43; // 0x5fdd8
    int32_t v44; // 0x5fdd8
    int32_t v45; // 0x5fdd8
    int32_t v46; // 0x5fdd8
    int32_t v47; // 0x5fdd8
    int32_t v48; // 0x5fed8
    int32_t v49; // 0x5fefe
    if (v32 < (int32_t)&g1) {
        // 0x5fed8
        v48 = 2 * v36;
        uint32_t v50 = 2 * v37; // 0x5fedc
        int32_t v51 = v50 | (int32_t)(v36 < 0); // 0x5fedc
        int32_t v52 = 2 * v32; // 0x5fede
        v44 = v51;
        v41 = v48;
        if ((v52 & (int32_t)&g1) == 0) {
            int32_t v53 = v52 | (int32_t)(v36 < 0 ? v51 <= v37 : v50 < v37); // 0x5fede
            int32_t v54; // 0x5fdd8
            if (v53 == 0) {
                int32_t v55 = __asm_itt(); // 0x5fef0
                v54 = llvm_ctlz_i32(v55, true);
                v47 = v55;
                v42 = __asm_it();
            } else {
                v54 = llvm_ctlz_i32(v53, true);
                v47 = v53;
                v42 = v51;
            }
            int32_t v56 = v54;
            int32_t v57 = v53 == 0 ? v56 | 32 : v56;
            v49 = v57 - 11;
            int32_t v58 = v57 - 43; // 0x5ff02
            v46 = v58;
            v38 = v58 < 0;
            v40 = v49 == 32;
            v39 = v49 & 42 - v57;
            if (v49 > 31) {
                goto lab_0x5ff22;
            } else {
                int32_t v59 = v57 - 31; // 0x5ff08
                if (v59 < 1) {
                    // 0x5ff1e
                    v46 = v49;
                    v38 = v59 != 0;
                    v40 = v59 == 0;
                    v39 = v59 & v57 + 0x7fffffd5;
                    goto lab_0x5ff22;
                } else {
                    // 0x5ff0c
                    v43 = v47 << v49;
                    v45 = v47 >> 43 - v57;
                    goto lab_0x5ff38;
                }
            }
        } else {
            goto lab_0x5fec0;
        }
    } else {
        // 0x5fea0
        v44 = v37;
        v41 = v36;
        if (v32 >= (int32_t)&g8) {
            // 0x5fea6
            v44 = (int32_t)(v32 % 2 != 0) << 32 - v37 | (int32_t)((int64_t)v37 << (int64_t)(33 - v37));
            v41 = (int32_t)((1 << v37 - 1 & v37) != 0) << 32 - v36 | (int32_t)((int64_t)v36 << (int64_t)(33 - v36));
            if (-1 - 0x200000 * v35 < (int32_t)&g47) {
                // 0x5fff4
                return 0;
            }
        }
        goto lab_0x5fec0;
    }
  lab_0x5fec0:;
    int32_t v60 = v41;
    int32_t v61 = v44; // 0x5fec4
    if (v60 == -0x80000000) {
        v61 = __asm_it();
    }
    bool v62 = v60 == -0x80000000 ? v61 % 2 != 0 : v60 <= -1;
    return v61 + (int32_t)v62;
  lab_0x5ff22:;
    bool v63 = v40 | v38 != v39 < 0; // 0x5ff22
    int32_t v64; // 0x5fdd8
    int32_t v65; // 0x5fdd8
    if (v63) {
        v64 = __asm_it() >> 32 - v46;
        v65 = __asm_itt();
    } else {
        v64 = v42 >> v48;
        v65 = v42;
    }
    v43 = v65 << (v63 ? v46 : 0);
    v45 = (v63 ? v64 : 0) | v47 << v46;
    goto lab_0x5ff38;
  lab_0x5ff38:;
    uint32_t v66 = v35 - 2; // 0x5fee6
    if (v66 >= v49) {
        // 0x5fff4
        return __asm_ittt();
    }
    int32_t v67 = v66 - v49; // 0x5ff38
    uint32_t v68 = -32 - v67; // 0x5ff48
    if (v67 < -31) {
        // 0x5ff86
        return v45 >> v68;
    }
    // 0x5ff4c
    if (v68 > -12) {
        // 0x5ff6e
        return v45 << -v68 | v43 >> v68 + 32;
    }
    // 0x5ff50
    return v45 << -v68 | v43 >> v68 + 32;
}

// Address range: 0x6002c - 0x6004a
int32_t function_6002c(int32_t a1) {
    int32_t result = a1; // 0x60030
    if (a1 == 0) {
        result = __asm_itt();
    }
    return result;
}

// Address range: 0x6004c - 0x6006e
int32_t function_6004c(int32_t a1) {
    if (a1 == 0) {
        // .thread
        return __asm_itt();
    }
    int32_t v1 = a1; // 0x60064
    if (a1 < 0) {
        v1 = __asm_it();
    }
    int32_t v2 = v1;
    return a1 < 0 ? -v2 : v2;
}

// Address range: 0x60070 - 0x60074
int32_t function_60070(void) {
    // 0x60070
    return function_1420180();
}

// Address range: 0x60074 - 0x60078
int32_t function_60074(void) {
    // 0x60074
    return function_1420804();
}

// Address range: 0x60078 - 0x6007c
int32_t function_60078(void) {
    // 0x60078
    return function_1420544();
}

// Address range: 0x6007c - 0x600b2
int32_t function_6007c(int32_t a1, int32_t a2, uint32_t a3) {
    // 0x6007c
    *(char *)a1 = (char)a3;
    bool v1; // 0x6007c
    int32_t result; // 0x6007c
    int32_t v2; // 0x6007c
    bool v3; // 0x6007c
    if (v3) {
        // .thread3
        int32_t v4; // 0x6007c
        v1 = v4 == -0x1000000;
        v2 = a1;
        goto lab_0x6008e;
    } else {
        int32_t v5 = __asm_itttt(); // 0x6007e
        result = v5;
        v1 = a3 > 0xfeffffff;
        v2 = v5;
        switch (a3 & -0x1000000) {
            case -0x1000000: {
                goto lab_0x6008e;
            }
            case 0: {
                goto lab_0x6008e;
            }
            default: {
                return result;
            }
        }
    }
  lab_0x6008e:
    if (a3 % 0x1000000 == 0) {
        // .thread
        return __asm_it();
    }
    result = v2;
    if (v1) {
        result = __asm_itt();
    }
    return result;
}

// Address range: 0x600b4 - 0x600bc
int32_t function_600b4(int32_t a1, int32_t a2) {
    // 0x600b4
    bool v1; // 0x600b4
    if (v1) {
        __asm_andeq(a2, 80, 20);
    }
    int32_t v2; // 0x600b4
    return (v1 ? v2 : 0) + a1;
}

// Address range: 0x600bc - 0x600c4
int32_t function_600bc(void) {
    // 0x600bc
    int32_t v1; // 0x600bc
    return function_600da(v1, v1);
}

// Address range: 0x600c4 - 0x600cc
int32_t function_600c4(int64_t a1, int32_t a2) {
    // 0x600c4
    bool v1; // 0x600c4
    if (v1) {
        __asm_andeq(a2, 80, 20);
    }
    int32_t v2; // 0x600c4
    return (v1 ? v2 : 0) + (int32_t)a1;
}

// Address range: 0x600cc - 0x600da
int32_t function_600cc(int32_t a1, uint32_t a2) {
    int32_t v1 = a1; // 0x600d2
    if (a2 >= 0) {
        v1 = function_600da(a1, a2);
    }
    // 0x600d4
    return -v1;
}

// Address range: 0x600da - 0x6011e
int32_t function_600da(int32_t a1, uint32_t a2) {
    // 0x600da
    uint32_t v1; // 0x600fe
    if (a2 < 0x2000000) {
        v1 = 3 + (int32_t)(a2 < 0);
        return a2 << 32 - v1 | a1 >> v1;
    }
    int32_t v2 = __asm_it(); // 0x600fa
    int32_t v3 = 6; // 0x600fa
    if (a2 >= 0x10000000) {
        // .thread
        v2 = __asm_it();
        v3 = 9;
    }
    v1 = v3 + (int32_t)(a2 < 0);
    return a2 << 32 - v1 | v2 >> v1;
}

// Address range: 0x60120 - 0x60138
int32_t function_60120(int32_t result, int32_t a2) {
    // .thread2
    return result;
    int32_t v1; // 0x60120
    *(int32_t *)(v1 - 36) = result;
    *(int32_t *)(v1 - 32) = a2;
    int32_t v2; // 0x60120
    int32_t v3 = &v2;
    *(int32_t *)(v1 - 8) = v3;
    *(int32_t *)(v1 - 4) = 0x60128;
    __asm_svclt(0x82900);
    __asm_svclt(0x1c2800);
    bool v4; // 0x60120
    if (v4) {
        *(int32_t *)(v1 - 4) = v3;
        *(int32_t *)(v1 - 12) = 0x6013c;
    }
    // .thread2
    return result;
}

// Address range: 0x60138 - 0x60150
int32_t function_60138(void) {
    // 0x60138
    int32_t result; // 0x60138
    return result;
}

// Address range: 0x60150 - 0x6015c
int32_t function_60150(int32_t a1, int32_t a2) {
    // 0x60150
    return function_11ec8(8);
}

// Address range: 0x6015c - 0x60168
int32_t function_6015c(void) {
    // 0x6015c
    bool v1; // 0x6015c
    if (v1) {
        function_65b268();
    }
    if (!v1) {
        function_ff09bc3c();
    }
    // 0x60164
    return function_49bd30();
}

// Address range: 0x60168 - 0x60180
int32_t function_60168(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x60168
    bool v1; // 0x60168
    if (v1) {
        // 0x6016e
        return -function_60180(a1, -a2, a3, a4);
    }
    // 0x6016a
    return function_60180(a1, a2, a3, a4);
}

// Address range: 0x60180 - 0x601c8
int32_t function_60180(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x60180
    bool v1; // 0x60180
    if (!v1) {
        function_35b804();
    }
    if (v1) {
        function_61b290();
    }
    if (!v1) {
        function_35b80c();
    }
    if (!v1) {
        function_25ba2c();
        function_ff25bc88();
    }
    if (v1) {
        function_125bc7c();
    }
    if (!v1) {
        function_49b9fc();
    }
    int32_t v2; // 0x60180
    if (v1) {
        // 0x601a0
        v2 = function_11db9b4();
    } else {
        // 0x601a0
        v2 = function_ff21bd98();
    }
    int32_t result = v2; // 0x601a4
    if (v1) {
        result = function_fe49ba08();
    }
    if (v1 == !v1) {
        return result;
    }
    if (!v1) {
        __asm_ldcllo(0, 0, result);
    }
    if (v1 == result > -1 != v1) {
        __asm_svclt(0x84ff0);
    }
    return result ^ (int32_t)v1;
}

// Address range: 0x601c8 - 0x602d6
int32_t function_601c8(uint32_t a1, int32_t a2, uint32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11, int32_t a12) {
    // 0x601c8
    int32_t v1; // 0x601c8
    int32_t v2; // 0x601c8
    int32_t result; // 0x601c8
    int32_t v3; // 0x601c8
    int32_t v4; // 0x601c8
    int32_t v5; // 0x601c8
    if (a1 < a3) {
        __asm_it();
        result = __asm_it();
        v4 = a1;
        v5 = a2;
        goto lab_0x602ae;
    } else {
        if (a4 == 0) {
            int32_t v6 = llvm_ctlz_i32(a3, true) | 32; // 0x602cc
            v3 = llvm_ctlz_i32(a2, true);
            v1 = v6;
            v2 = v6;
            if (a2 == 0) {
                goto lab_0x602bc;
            } else {
                goto lab_0x601f0;
            }
        } else {
            int32_t v7 = llvm_ctlz_i32(a4, true); // 0x601e0
            v3 = llvm_ctlz_i32(a2, true);
            v1 = v7;
            v2 = v7;
            if (a2 == 0) {
                goto lab_0x602bc;
            } else {
                goto lab_0x601f0;
            }
        }
    }
  lab_0x602ae:;
    // 0x602ae
    int32_t v8; // 0x601c8
    if (v8 != 0) {
        // 0x602b4
        *(int32_t *)v8 = v4;
        *(int32_t *)(v8 + 4) = v5;
    }
    // 0x602b8
    return result;
  lab_0x602bc:
    // 0x602bc
    v3 = llvm_ctlz_i32(a1, true) | 32;
    v1 = v2;
    goto lab_0x601f0;
  lab_0x601f0:;
    uint32_t v9 = v1 - v3; // 0x601f0
    uint32_t v10 = v9 - 32; // 0x601f4
    uint32_t v11 = 32 - v9; // 0x60200
    uint32_t v12 = a3 << v10 | a4 << v9 | a3 >> v11; // 0x6020e
    if (v12 == a2) {
        __asm_it();
    }
    uint32_t v13 = a3 << v9; // 0x60208
    int32_t v14; // 0x601c8
    int32_t v15; // 0x601c8
    int32_t v16; // 0x601c8
    if (v12 == a2 ? v13 > a1 : v12 > a2) {
        __asm_itt();
        v14 = 0;
        v15 = a1;
        v16 = a2;
    } else {
        // 0x6021e
        v14 = 1 << v9;
        v15 = a1 - v13;
        v16 = (int32_t)(v9 != 32) + a2 - v12;
    }
    // 0x60234
    result = v14;
    v4 = v15;
    v5 = v16;
    if (v9 != 0) {
        uint32_t v17 = v12 / 2; // 0x6023a
        uint32_t v18 = (int32_t)(v12 % 2 != 0) << 32 - v13 | (int32_t)((int64_t)v13 << (int64_t)(33 - v13)); // 0x6023c
        int32_t v19 = v14; // 0x60242
        int32_t v20 = v9; // 0x60242
        int32_t v21 = v15; // 0x60242
        int32_t v22 = v16; // 0x60242
        int32_t v23; // 0x601c8
        int32_t v24; // 0x601c8
        int32_t v25; // 0x601c8
        while (true) {
            uint32_t v26 = v22;
            uint32_t v27 = v21;
            int32_t v28 = v20;
            int32_t v29 = v19; // 0x6025c
            if (v26 == v17) {
                v29 = __asm_it();
            }
            v23 = v29;
            int32_t v30; // 0x601c8
            int32_t v31; // 0x601c8
            if (v26 == v17 ? v27 < v18 : v26 < v17) {
                int32_t v32 = 2 * v27; // 0x60262
                int32_t v33 = 2 * v26 | (int32_t)(v32 < v27); // 0x60264
                v30 = v32;
                v31 = v33;
                v24 = v32;
                v25 = v33;
                if (v28 == 1) {
                    // break -> 0x6026a
                    break;
                }
            } else {
                uint32_t v34 = v27 - v18; // 0x60244
                uint32_t v35 = 2 * v34; // 0x6024a
                int32_t v36 = 2 * (v26 - v17 + (int32_t)(v27 < v18)) | (int32_t)(v35 < v34); // 0x6024c
                int32_t v37 = v35 | 1; // 0x60250
                v30 = v37;
                v31 = v36;
                v24 = v37;
                v25 = v36;
                if (v28 == 1) {
                    // break -> 0x6026a
                    break;
                }
            }
            // 0x6025a
            v19 = v23;
            v20 = v28 - 1;
            v21 = v30;
            v22 = v31;
        }
        uint32_t v38 = v25;
        int32_t v39 = v38 << v11 | v24 >> v9 | v38 >> v10; // 0x60280
        result = v24 + v23 - (v39 << v9);
        v4 = v39;
        v5 = v38 >> v9;
    }
    goto lab_0x602ae;
}

// Address range: 0x602d8 - 0x6030c
int32_t function_602d8(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = function_11e84(a1, a2, a3, a4); // 0x602e8
    int32_t result = (int32_t)&g7 + 0x602e8 - (int32_t)&g269 >> 2 == 0 ? v1 : a1;
    return result;
}

// Address range: 0x60314 - 0x60316
int32_t function_60314(void) {
    // 0x60314
    int32_t result; // 0x60314
    return result;
}

// Address range: 0x60318 - 0x60324
int32_t function_60318(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = a1; // 0x60318
    bool v2; // 0x60318
    if (v2) {
        v1 = function_1b2f30();
    }
    // 0x6031c
    int32_t v3; // 0x60318
    return v2 ? v1 : v3;
}

// Address range: 0x60326 - 0x6032a
int32_t function_60326(void) {
    // 0x60326
    int32_t v1; // 0x60326
    return __cxa_atexit((void (*)(int32_t *))v1, (int32_t *)v1, (int32_t *)v1);
}

// Address range: 0x6032c - 0x60334
int32_t function_6032c(int32_t result) {
    // 0x6032c
    return result;
}

// Address range: 0x60334 - 0x6033c
int32_t function_60334(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x60334
    return result;
}

// Address range: 0x61bc6 - 0x61bc7
int32_t function_61bc6(void) {
    // 0x61bc6
    int32_t result; // 0x61bc6
    return result;
}

// Address range: 0x61ca6 - 0x61ca7
int32_t function_61ca6(void) {
    // 0x61ca6
    int32_t result; // 0x61ca6
    return result;
}

// Address range: 0x6211a - 0x6211b
int32_t function_6211a(void) {
    // 0x6211a
    int32_t result; // 0x6211a
    return result;
}

// Address range: 0x6317a - 0x6317b
int32_t function_6317a(void) {
    // 0x6317a
    int32_t result; // 0x6317a
    return result;
}

// Address range: 0x64b62 - 0x64b63
int32_t function_64b62(void) {
    // 0x64b62
    int32_t result; // 0x64b62
    return result;
}

// Address range: 0x6c01e - 0x6c01f
int32_t function_6c01e(void) {
    // 0x6c01e
    int32_t result; // 0x6c01e
    return result;
}

// Address range: 0x6de06 - 0x6de07
int32_t function_6de06(void) {
    // 0x6de06
    int32_t result; // 0x6de06
    return result;
}

// Address range: 0x6e60a - 0x6e60b
int32_t function_6e60a(void) {
    // 0x6e60a
    int32_t result; // 0x6e60a
    return result;
}

// Address range: 0x72342 - 0x72343
int32_t function_72342(void) {
    // 0x72342
    int32_t result; // 0x72342
    return result;
}

// Address range: 0x752ca - 0x752cb
int32_t function_752ca(void) {
    // 0x752ca
    int32_t result; // 0x752ca
    return result;
}

// Address range: 0x7539e - 0x7539f
int32_t function_7539e(void) {
    // 0x7539e
    int32_t result; // 0x7539e
    return result;
}

// Address range: 0x75f36 - 0x75f37
int32_t function_75f36(void) {
    // 0x75f36
    int32_t result; // 0x75f36
    return result;
}

// Address range: 0x76236 - 0x76237
int32_t function_76236(void) {
    // 0x76236
    int32_t result; // 0x76236
    return result;
}

// Address range: 0x7631a - 0x7631b
int32_t function_7631a(void) {
    // 0x7631a
    int32_t result; // 0x7631a
    return result;
}

// Address range: 0x76cbe - 0x76cbf
int32_t function_76cbe(void) {
    // 0x76cbe
    int32_t result; // 0x76cbe
    return result;
}

// Address range: 0x76d0a - 0x76d0b
int32_t function_76d0a(void) {
    // 0x76d0a
    int32_t result; // 0x76d0a
    return result;
}

// Address range: 0x76d56 - 0x76d57
int32_t function_76d56(void) {
    // 0x76d56
    int32_t result; // 0x76d56
    return result;
}

// Address range: 0x77e1e - 0x77e1f
int32_t function_77e1e(void) {
    // 0x77e1e
    int32_t result; // 0x77e1e
    return result;
}

// Address range: 0x77e72 - 0x77e73
int32_t function_77e72(void) {
    // 0x77e72
    int32_t result; // 0x77e72
    return result;
}

// Address range: 0x77ebe - 0x77ebf
int32_t function_77ebe(void) {
    // 0x77ebe
    int32_t result; // 0x77ebe
    return result;
}

// Address range: 0x791ea - 0x791eb
int32_t function_791ea(void) {
    // 0x791ea
    int32_t result; // 0x791ea
    return result;
}

// Address range: 0x7aafa - 0x7aafb
int32_t function_7aafa(void) {
    // 0x7aafa
    int32_t result; // 0x7aafa
    return result;
}

// Address range: 0x7acde - 0x7acdf
int32_t function_7acde(void) {
    // 0x7acde
    int32_t result; // 0x7acde
    return result;
}

// Address range: 0x7ad8a - 0x7ad8b
int32_t function_7ad8a(void) {
    // 0x7ad8a
    int32_t result; // 0x7ad8a
    return result;
}

// Address range: 0x7ada6 - 0x7ada7
int32_t function_7ada6(void) {
    // 0x7ada6
    int32_t result; // 0x7ada6
    return result;
}

// Address range: 0x7b1de - 0x7b1df
int32_t function_7b1de(void) {
    // 0x7b1de
    int32_t result; // 0x7b1de
    return result;
}

// Address range: 0x7b526 - 0x7b527
int32_t function_7b526(void) {
    // 0x7b526
    int32_t result; // 0x7b526
    return result;
}

// Address range: 0x86a1a - 0x86a1b
int32_t function_86a1a(void) {
    // 0x86a1a
    int32_t result; // 0x86a1a
    return result;
}

// Address range: 0x89182 - 0x89183
int32_t function_89182(void) {
    // 0x89182
    int32_t result; // 0x89182
    return result;
}

// Address range: 0x9941a - 0x9941b
int32_t function_9941a(void) {
    // 0x9941a
    int32_t result; // 0x9941a
    return result;
}

// Address range: 0xb4d7a - 0xb4d7b
int32_t function_b4d7a(void) {
    // 0xb4d7a
    int32_t result; // 0xb4d7a
    return result;
}

// Address range: 0xc4a3e - 0xc4a3f
int32_t function_c4a3e(void) {
    // 0xc4a3e
    int32_t result; // 0xc4a3e
    return result;
}

// Address range: 0xc4a5e - 0xc4a5f
int32_t function_c4a5e(void) {
    // 0xc4a5e
    int32_t result; // 0xc4a5e
    return result;
}

// Address range: 0xc4a7e - 0xc4a7f
int32_t function_c4a7e(void) {
    // 0xc4a7e
    int32_t result; // 0xc4a7e
    return result;
}

// Address range: 0xc4a9e - 0xc4a9f
int32_t function_c4a9e(void) {
    // 0xc4a9e
    int32_t result; // 0xc4a9e
    return result;
}

// Address range: 0xceaa6 - 0xceaa7
int32_t function_ceaa6(void) {
    // 0xceaa6
    int32_t result; // 0xceaa6
    return result;
}

// Address range: 0xcebe2 - 0xcebe3
int32_t function_cebe2(void) {
    // 0xcebe2
    int32_t result; // 0xcebe2
    return result;
}

// Address range: 0xd07c2 - 0xd07c3
int32_t function_d07c2(void) {
    // 0xd07c2
    int32_t result; // 0xd07c2
    return result;
}

// Address range: 0xd2c3e - 0xd2c3f
int32_t function_d2c3e(void) {
    // 0xd2c3e
    int32_t result; // 0xd2c3e
    return result;
}

// Address range: 0xd30ea - 0xd30eb
int32_t function_d30ea(void) {
    // 0xd30ea
    int32_t result; // 0xd30ea
    return result;
}

// Address range: 0xd3546 - 0xd3547
int32_t function_d3546(void) {
    // 0xd3546
    int32_t result; // 0xd3546
    return result;
}

// Address range: 0xd3bb6 - 0xd3bb7
int32_t function_d3bb6(void) {
    // 0xd3bb6
    int32_t result; // 0xd3bb6
    return result;
}

// Address range: 0xd4332 - 0xd4333
int32_t function_d4332(void) {
    // 0xd4332
    int32_t result; // 0xd4332
    return result;
}

// Address range: 0xd4f36 - 0xd4f37
int32_t function_d4f36(void) {
    // 0xd4f36
    int32_t result; // 0xd4f36
    return result;
}

// Address range: 0xd5236 - 0xd5237
int32_t function_d5236(void) {
    // 0xd5236
    int32_t result; // 0xd5236
    return result;
}

// Address range: 0xd900e - 0xd900f
int32_t function_d900e(void) {
    // 0xd900e
    int32_t result; // 0xd900e
    return result;
}

// Address range: 0xd90f2 - 0xd90f3
int32_t function_d90f2(void) {
    // 0xd90f2
    int32_t result; // 0xd90f2
    return result;
}

// Address range: 0xda562 - 0xda563
int32_t function_da562(void) {
    // 0xda562
    int32_t result; // 0xda562
    return result;
}

// Address range: 0xdeda6 - 0xdeda7
int32_t function_deda6(void) {
    // 0xdeda6
    int32_t result; // 0xdeda6
    return result;
}

// Address range: 0xe00c6 - 0xe00c7
int32_t function_e00c6(void) {
    // 0xe00c6
    int32_t result; // 0xe00c6
    return result;
}

// Address range: 0xe1b4e - 0xe1b4f
int32_t function_e1b4e(void) {
    // 0xe1b4e
    int32_t result; // 0xe1b4e
    return result;
}

// Address range: 0xe2042 - 0xe2043
int32_t function_e2042(void) {
    // 0xe2042
    int32_t result; // 0xe2042
    return result;
}

// Address range: 0xe25de - 0xe25df
int32_t function_e25de(void) {
    // 0xe25de
    int32_t result; // 0xe25de
    return result;
}

// Address range: 0xe2ebe - 0xe2ebf
int32_t function_e2ebe(void) {
    // 0xe2ebe
    int32_t result; // 0xe2ebe
    return result;
}

// Address range: 0xee24e - 0xee24f
int32_t function_ee24e(void) {
    // 0xee24e
    int32_t result; // 0xee24e
    return result;
}

// Address range: 0xf0126 - 0xf0127
int32_t function_f0126(void) {
    // 0xf0126
    int32_t result; // 0xf0126
    return result;
}

// Address range: 0xf120e - 0xf120f
int32_t function_f120e(void) {
    // 0xf120e
    int32_t result; // 0xf120e
    return result;
}

// Address range: 0xf1b3e - 0xf1b3f
int32_t function_f1b3e(void) {
    // 0xf1b3e
    int32_t result; // 0xf1b3e
    return result;
}

// Address range: 0xf230e - 0xf230f
int32_t function_f230e(void) {
    // 0xf230e
    int32_t result; // 0xf230e
    return result;
}

// Address range: 0xf472e - 0xf472f
int32_t function_f472e(void) {
    // 0xf472e
    int32_t result; // 0xf472e
    return result;
}

// Address range: 0xf52ce - 0xf52cf
int32_t function_f52ce(void) {
    // 0xf52ce
    int32_t result; // 0xf52ce
    return result;
}

// Address range: 0xf5842 - 0xf5843
int32_t function_f5842(void) {
    // 0xf5842
    int32_t result; // 0xf5842
    return result;
}

// Address range: 0xf628e - 0xf628f
int32_t function_f628e(void) {
    // 0xf628e
    int32_t result; // 0xf628e
    return result;
}

// Address range: 0xfa83a - 0xfa83b
int32_t function_fa83a(void) {
    // 0xfa83a
    int32_t result; // 0xfa83a
    return result;
}

// Address range: 0xfad8e - 0xfad8f
int32_t function_fad8e(void) {
    // 0xfad8e
    int32_t result; // 0xfad8e
    return result;
}

// Address range: 0xfaf86 - 0xfaf87
int32_t function_faf86(void) {
    // 0xfaf86
    int32_t result; // 0xfaf86
    return result;
}

// Address range: 0xfb2f6 - 0xfb2f7
int32_t function_fb2f6(void) {
    // 0xfb2f6
    int32_t result; // 0xfb2f6
    return result;
}

// Address range: 0x1012ea - 0x1012eb
int32_t function_1012ea(void) {
    // 0x1012ea
    int32_t result; // 0x1012ea
    return result;
}

// Address range: 0x10d996 - 0x10d997
int32_t function_10d996(void) {
    // 0x10d996
    int32_t result; // 0x10d996
    return result;
}

// Address range: 0x1308fe - 0x1308ff
int32_t function_1308fe(void) {
    // 0x1308fe
    int32_t result; // 0x1308fe
    return result;
}

// Address range: 0x13afa2 - 0x13afa3
int32_t function_13afa2(void) {
    // 0x13afa2
    int32_t result; // 0x13afa2
    return result;
}

// Address range: 0x151eb2 - 0x151eb3
int32_t function_151eb2(void) {
    // 0x151eb2
    int32_t result; // 0x151eb2
    return result;
}

// Address range: 0x15f7ba - 0x15f7bb
int32_t function_15f7ba(void) {
    // 0x15f7ba
    int32_t result; // 0x15f7ba
    return result;
}

// Address range: 0x172b12 - 0x172b13
int32_t function_172b12(void) {
    // 0x172b12
    int32_t result; // 0x172b12
    return result;
}

// Address range: 0x173faa - 0x173fab
int32_t function_173faa(void) {
    // 0x173faa
    int32_t result; // 0x173faa
    return result;
}

// Address range: 0x1753a2 - 0x1753a3
int32_t function_1753a2(void) {
    // 0x1753a2
    int32_t result; // 0x1753a2
    return result;
}

// Address range: 0x17ab12 - 0x17ab13
int32_t function_17ab12(void) {
    // 0x17ab12
    int32_t result; // 0x17ab12
    return result;
}

// Address range: 0x17b002 - 0x17b003
int32_t function_17b002(void) {
    // 0x17b002
    int32_t result; // 0x17b002
    return result;
}

// Address range: 0x17b1fe - 0x17b1ff
int32_t function_17b1fe(void) {
    // 0x17b1fe
    int32_t result; // 0x17b1fe
    return result;
}

// Address range: 0x18be3a - 0x18be3b
int32_t function_18be3a(void) {
    // 0x18be3a
    int32_t result; // 0x18be3a
    return result;
}

// Address range: 0x1934e6 - 0x1934e7
int32_t function_1934e6(void) {
    // 0x1934e6
    int32_t result; // 0x1934e6
    return result;
}

// Address range: 0x19d112 - 0x19d113
int32_t function_19d112(void) {
    // 0x19d112
    int32_t result; // 0x19d112
    return result;
}

// Address range: 0x1a181e - 0x1a181f
int32_t function_1a181e(void) {
    // 0x1a181e
    int32_t result; // 0x1a181e
    return result;
}

// Address range: 0x1a1c8a - 0x1a1c8b
int32_t function_1a1c8a(void) {
    // 0x1a1c8a
    int32_t result; // 0x1a1c8a
    return result;
}

// Address range: 0x1ac0de - 0x1ac0df
int32_t function_1ac0de(void) {
    // 0x1ac0de
    int32_t result; // 0x1ac0de
    return result;
}

// Address range: 0x1b124e - 0x1b124f
int32_t function_1b124e(void) {
    // 0x1b124e
    int32_t result; // 0x1b124e
    return result;
}

// Address range: 0x1b2f30 - 0x1b2f31
int32_t function_1b2f30(void) {
    // 0x1b2f30
    int32_t result; // 0x1b2f30
    return result;
}

// Address range: 0x1bb01a - 0x1bb01b
int32_t function_1bb01a(void) {
    // 0x1bb01a
    int32_t result; // 0x1bb01a
    return result;
}

// Address range: 0x1bc296 - 0x1bc297
int32_t function_1bc296(void) {
    // 0x1bc296
    int32_t result; // 0x1bc296
    return result;
}

// Address range: 0x1c49ee - 0x1c49ef
int32_t function_1c49ee(void) {
    // 0x1c49ee
    int32_t result; // 0x1c49ee
    return result;
}

// Address range: 0x1da072 - 0x1da073
int32_t function_1da072(void) {
    // 0x1da072
    int32_t result; // 0x1da072
    return result;
}

// Address range: 0x1de836 - 0x1de837
int32_t function_1de836(void) {
    // 0x1de836
    int32_t result; // 0x1de836
    return result;
}

// Address range: 0x1e0076 - 0x1e0077
int32_t function_1e0076(void) {
    // 0x1e0076
    int32_t result; // 0x1e0076
    return result;
}

// Address range: 0x1e1566 - 0x1e1567
int32_t function_1e1566(void) {
    // 0x1e1566
    int32_t result; // 0x1e1566
    return result;
}

// Address range: 0x1e1bca - 0x1e1bcb
int32_t function_1e1bca(void) {
    // 0x1e1bca
    int32_t result; // 0x1e1bca
    return result;
}

// Address range: 0x1e2256 - 0x1e2257
int32_t function_1e2256(void) {
    // 0x1e2256
    int32_t result; // 0x1e2256
    return result;
}

// Address range: 0x1e255e - 0x1e255f
int32_t function_1e255e(void) {
    // 0x1e255e
    int32_t result; // 0x1e255e
    return result;
}

// Address range: 0x1e285a - 0x1e285b
int32_t function_1e285a(void) {
    // 0x1e285a
    int32_t result; // 0x1e285a
    return result;
}

// Address range: 0x1fa84e - 0x1fa84f
int32_t function_1fa84e(void) {
    // 0x1fa84e
    int32_t result; // 0x1fa84e
    return result;
}

// Address range: 0x1fad86 - 0x1fad87
int32_t function_1fad86(void) {
    // 0x1fad86
    int32_t result; // 0x1fad86
    return result;
}

// Address range: 0x1fb02a - 0x1fb02b
int32_t function_1fb02a(void) {
    // 0x1fb02a
    int32_t result; // 0x1fb02a
    return result;
}

// Address range: 0x1fb032 - 0x1fb033
int32_t function_1fb032(void) {
    // 0x1fb032
    int32_t result; // 0x1fb032
    return result;
}

// Address range: 0x204992 - 0x204993
int32_t function_204992(void) {
    // 0x204992
    int32_t result; // 0x204992
    return result;
}

// Address range: 0x2049b2 - 0x2049b3
int32_t function_2049b2(void) {
    // 0x2049b2
    int32_t result; // 0x2049b2
    return result;
}

// Address range: 0x2049d2 - 0x2049d3
int32_t function_2049d2(void) {
    // 0x2049d2
    int32_t result; // 0x2049d2
    return result;
}

// Address range: 0x20e61a - 0x20e61b
int32_t function_20e61a(void) {
    // 0x20e61a
    int32_t result; // 0x20e61a
    return result;
}

// Address range: 0x2164f2 - 0x2164f3
int32_t function_2164f2(void) {
    // 0x2164f2
    int32_t result; // 0x2164f2
    return result;
}

// Address range: 0x2167d2 - 0x2167d3
int32_t function_2167d2(void) {
    // 0x2167d2
    int32_t result; // 0x2167d2
    return result;
}

// Address range: 0x21965a - 0x21965b
int32_t function_21965a(void) {
    // 0x21965a
    int32_t result; // 0x21965a
    return result;
}

// Address range: 0x21abf6 - 0x21abf7
int32_t function_21abf6(void) {
    // 0x21abf6
    int32_t result; // 0x21abf6
    return result;
}

// Address range: 0x21aec2 - 0x21aec3
int32_t function_21aec2(void) {
    // 0x21aec2
    int32_t result; // 0x21aec2
    return result;
}

// Address range: 0x21b052 - 0x21b053
int32_t function_21b052(void) {
    // 0x21b052
    int32_t result; // 0x21b052
    return result;
}

// Address range: 0x22167a - 0x22167b
int32_t function_22167a(void) {
    // 0x22167a
    int32_t result; // 0x22167a
    return result;
}

// Address range: 0x2216a2 - 0x2216a3
int32_t function_2216a2(void) {
    // 0x2216a2
    int32_t result; // 0x2216a2
    return result;
}

// Address range: 0x2222ee - 0x2222ef
int32_t function_2222ee(void) {
    // 0x2222ee
    int32_t result; // 0x2222ee
    return result;
}

// Address range: 0x222302 - 0x222303
int32_t function_222302(void) {
    // 0x222302
    int32_t result; // 0x222302
    return result;
}

// Address range: 0x2223da - 0x2223db
int32_t function_2223da(void) {
    // 0x2223da
    int32_t result; // 0x2223da
    return result;
}

// Address range: 0x2223f2 - 0x2223f3
int32_t function_2223f2(void) {
    // 0x2223f2
    int32_t result; // 0x2223f2
    return result;
}

// Address range: 0x2246a6 - 0x2246a7
int32_t function_2246a6(void) {
    // 0x2246a6
    int32_t result; // 0x2246a6
    return result;
}

// Address range: 0x224d26 - 0x224d27
int32_t function_224d26(void) {
    // 0x224d26
    int32_t result; // 0x224d26
    return result;
}

// Address range: 0x224d4e - 0x224d4f
int32_t function_224d4e(void) {
    // 0x224d4e
    int32_t result; // 0x224d4e
    return result;
}

// Address range: 0x224f02 - 0x224f03
int32_t function_224f02(void) {
    // 0x224f02
    int32_t result; // 0x224f02
    return result;
}

// Address range: 0x22528a - 0x22528b
int32_t function_22528a(void) {
    // 0x22528a
    int32_t result; // 0x22528a
    return result;
}

// Address range: 0x251db2 - 0x251db3
int32_t function_251db2(void) {
    // 0x251db2
    int32_t result; // 0x251db2
    return result;
}

// Address range: 0x254f9a - 0x254f9b
int32_t function_254f9a(void) {
    // 0x254f9a
    int32_t result; // 0x254f9a
    return result;
}

// Address range: 0x25529a - 0x25529b
int32_t function_25529a(void) {
    // 0x25529a
    int32_t result; // 0x25529a
    return result;
}

// Address range: 0x2552d6 - 0x2552d7
int32_t function_2552d6(void) {
    // 0x2552d6
    int32_t result; // 0x2552d6
    return result;
}

// Address range: 0x2561d6 - 0x2561d7
int32_t function_2561d6(void) {
    // 0x2561d6
    int32_t result; // 0x2561d6
    return result;
}

// Address range: 0x2564b6 - 0x2564b7
int32_t function_2564b6(void) {
    // 0x2564b6
    int32_t result; // 0x2564b6
    return result;
}

// Address range: 0x25ba2c - 0x25ba2d
int32_t function_25ba2c(void) {
    // 0x25ba2c
    int32_t result; // 0x25ba2c
    return result;
}

// Address range: 0x25f0ca - 0x25f0cb
int32_t function_25f0ca(void) {
    // 0x25f0ca
    int32_t result; // 0x25f0ca
    return result;
}

// Address range: 0x2619da - 0x2619db
int32_t function_2619da(void) {
    // 0x2619da
    int32_t result; // 0x2619da
    return result;
}

// Address range: 0x264cfe - 0x264cff
int32_t function_264cfe(void) {
    // 0x264cfe
    int32_t result; // 0x264cfe
    return result;
}

// Address range: 0x277402 - 0x277403
int32_t function_277402(void) {
    // 0x277402
    int32_t result; // 0x277402
    return result;
}

// Address range: 0x277c1a - 0x277c1b
int32_t function_277c1a(void) {
    // 0x277c1a
    int32_t result; // 0x277c1a
    return result;
}

// Address range: 0x27acba - 0x27acbb
int32_t function_27acba(void) {
    // 0x27acba
    int32_t result; // 0x27acba
    return result;
}

// Address range: 0x27acca - 0x27accb
int32_t function_27acca(void) {
    // 0x27acca
    int32_t result; // 0x27acca
    return result;
}

// Address range: 0x27ad56 - 0x27ad57
int32_t function_27ad56(void) {
    // 0x27ad56
    int32_t result; // 0x27ad56
    return result;
}

// Address range: 0x27ad76 - 0x27ad77
int32_t function_27ad76(void) {
    // 0x27ad76
    int32_t result; // 0x27ad76
    return result;
}

// Address range: 0x27ad9a - 0x27ad9b
int32_t function_27ad9a(void) {
    // 0x27ad9a
    int32_t result; // 0x27ad9a
    return result;
}

// Address range: 0x27b1ca - 0x27b1cb
int32_t function_27b1ca(void) {
    // 0x27b1ca
    int32_t result; // 0x27b1ca
    return result;
}

// Address range: 0x27b20a - 0x27b20b
int32_t function_27b20a(void) {
    // 0x27b20a
    int32_t result; // 0x27b20a
    return result;
}

// Address range: 0x294bd6 - 0x294bd7
int32_t function_294bd6(void) {
    // 0x294bd6
    int32_t result; // 0x294bd6
    return result;
}

// Address range: 0x294c76 - 0x294c77
int32_t function_294c76(void) {
    // 0x294c76
    int32_t result; // 0x294c76
    return result;
}

// Address range: 0x2951da - 0x2951db
int32_t function_2951da(void) {
    // 0x2951da
    int32_t result; // 0x2951da
    return result;
}

// Address range: 0x299da6 - 0x299da7
int32_t function_299da6(void) {
    // 0x299da6
    int32_t result; // 0x299da6
    return result;
}

// Address range: 0x2a2332 - 0x2a2333
int32_t function_2a2332(void) {
    // 0x2a2332
    int32_t result; // 0x2a2332
    return result;
}

// Address range: 0x2a32b2 - 0x2a32b3
int32_t function_2a32b2(void) {
    // 0x2a32b2
    int32_t result; // 0x2a32b2
    return result;
}

// Address range: 0x2b2232 - 0x2b2233
int32_t function_2b2232(void) {
    // 0x2b2232
    int32_t result; // 0x2b2232
    return result;
}

// Address range: 0x2b703a - 0x2b703b
int32_t function_2b703a(void) {
    // 0x2b703a
    int32_t result; // 0x2b703a
    return result;
}

// Address range: 0x2b85c6 - 0x2b85c7
int32_t function_2b85c6(void) {
    // 0x2b85c6
    int32_t result; // 0x2b85c6
    return result;
}

// Address range: 0x2ba832 - 0x2ba833
int32_t function_2ba832(void) {
    // 0x2ba832
    int32_t result; // 0x2ba832
    return result;
}

// Address range: 0x2baaaa - 0x2baaab
int32_t function_2baaaa(void) {
    // 0x2baaaa
    int32_t result; // 0x2baaaa
    return result;
}

// Address range: 0x2bacd6 - 0x2bacd7
int32_t function_2bacd6(void) {
    // 0x2bacd6
    int32_t result; // 0x2bacd6
    return result;
}

// Address range: 0x2bad92 - 0x2bad93
int32_t function_2bad92(void) {
    // 0x2bad92
    int32_t result; // 0x2bad92
    return result;
}

// Address range: 0x2d4bd2 - 0x2d4bd3
int32_t function_2d4bd2(void) {
    // 0x2d4bd2
    int32_t result; // 0x2d4bd2
    return result;
}

// Address range: 0x2d4c72 - 0x2d4c73
int32_t function_2d4c72(void) {
    // 0x2d4c72
    int32_t result; // 0x2d4c72
    return result;
}

// Address range: 0x2e23e6 - 0x2e23e7
int32_t function_2e23e6(void) {
    // 0x2e23e6
    int32_t result; // 0x2e23e6
    return result;
}

// Address range: 0x2f812e - 0x2f812f
int32_t function_2f812e(void) {
    // 0x2f812e
    int32_t result; // 0x2f812e
    return result;
}

// Address range: 0x2f967e - 0x2f967f
int32_t function_2f967e(void) {
    // 0x2f967e
    int32_t result; // 0x2f967e
    return result;
}

// Address range: 0x2fada2 - 0x2fada3
int32_t function_2fada2(void) {
    // 0x2fada2
    int32_t result; // 0x2fada2
    return result;
}

// Address range: 0x2fb1ee - 0x2fb1ef
int32_t function_2fb1ee(void) {
    // 0x2fb1ee
    int32_t result; // 0x2fb1ee
    return result;
}

// Address range: 0x314eae - 0x314eaf
int32_t function_314eae(void) {
    // 0x314eae
    int32_t result; // 0x314eae
    return result;
}

// Address range: 0x351102 - 0x351103
int32_t function_351102(void) {
    // 0x351102
    int32_t result; // 0x351102
    return result;
}

// Address range: 0x35b804 - 0x35b805
int32_t function_35b804(void) {
    // 0x35b804
    int32_t result; // 0x35b804
    return result;
}

// Address range: 0x35b80c - 0x35b80d
int32_t function_35b80c(void) {
    // 0x35b80c
    int32_t result; // 0x35b80c
    return result;
}

// Address range: 0x4136d0 - 0x4136d1
int32_t function_4136d0(void) {
    // 0x4136d0
    int32_t result; // 0x4136d0
    return result;
}

// Address range: 0x419af8 - 0x419af9
int32_t function_419af8(void) {
    // 0x419af8
    int32_t result; // 0x419af8
    return result;
}

// Address range: 0x41fce0 - 0x41fce1
int32_t function_41fce0(void) {
    // 0x41fce0
    int32_t result; // 0x41fce0
    return result;
}

// Address range: 0x424686 - 0x424687
int32_t function_424686(void) {
    // 0x424686
    int32_t result; // 0x424686
    return result;
}

// Address range: 0x426238 - 0x426239
int32_t function_426238(void) {
    // 0x426238
    int32_t result; // 0x426238
    return result;
}

// Address range: 0x426880 - 0x426881
int32_t function_426880(void) {
    // 0x426880
    int32_t result; // 0x426880
    return result;
}

// Address range: 0x427cb8 - 0x427cb9
int32_t function_427cb8(void) {
    // 0x427cb8
    int32_t result; // 0x427cb8
    return result;
}

// Address range: 0x427f78 - 0x427f79
int32_t function_427f78(void) {
    // 0x427f78
    int32_t result; // 0x427f78
    return result;
}

// Address range: 0x430bb0 - 0x430bb1
int32_t function_430bb0(void) {
    // 0x430bb0
    int32_t result; // 0x430bb0
    return result;
}

// Address range: 0x430c48 - 0x430c49
int32_t function_430c48(void) {
    // 0x430c48
    int32_t result; // 0x430c48
    return result;
}

// Address range: 0x43fa78 - 0x43fa79
int32_t function_43fa78(void) {
    // 0x43fa78
    int32_t result; // 0x43fa78
    return result;
}

// Address range: 0x440020 - 0x440021
int32_t function_440020(void) {
    // 0x440020
    int32_t result; // 0x440020
    return result;
}

// Address range: 0x444c18 - 0x444c19
int32_t function_444c18(void) {
    // 0x444c18
    int32_t result; // 0x444c18
    return result;
}

// Address range: 0x449768 - 0x449769
int32_t function_449768(void) {
    // 0x449768
    int32_t result; // 0x449768
    return result;
}

// Address range: 0x4498d8 - 0x4498d9
int32_t function_4498d8(void) {
    // 0x4498d8
    int32_t result; // 0x4498d8
    return result;
}

// Address range: 0x44f0d8 - 0x44f0d9
int32_t function_44f0d8(void) {
    // 0x44f0d8
    int32_t result; // 0x44f0d8
    return result;
}

// Address range: 0x44f138 - 0x44f139
int32_t function_44f138(void) {
    // 0x44f138
    int32_t result; // 0x44f138
    return result;
}

// Address range: 0x4534ea - 0x4534eb
int32_t function_4534ea(void) {
    // 0x4534ea
    int32_t result; // 0x4534ea
    return result;
}

// Address range: 0x454f62 - 0x454f63
int32_t function_454f62(void) {
    // 0x454f62
    int32_t result; // 0x454f62
    return result;
}

// Address range: 0x454f6e - 0x454f6f
int32_t function_454f6e(void) {
    // 0x454f6e
    int32_t result; // 0x454f6e
    return result;
}

// Address range: 0x454f7e - 0x454f7f
int32_t function_454f7e(void) {
    // 0x454f7e
    int32_t result; // 0x454f7e
    return result;
}

// Address range: 0x45527a - 0x45527b
int32_t function_45527a(void) {
    // 0x45527a
    int32_t result; // 0x45527a
    return result;
}

// Address range: 0x455292 - 0x455293
int32_t function_455292(void) {
    // 0x455292
    int32_t result; // 0x455292
    return result;
}

// Address range: 0x4552a2 - 0x4552a3
int32_t function_4552a2(void) {
    // 0x4552a2
    int32_t result; // 0x4552a2
    return result;
}

// Address range: 0x45540a - 0x45540b
int32_t function_45540a(void) {
    // 0x45540a
    int32_t result; // 0x45540a
    return result;
}

// Address range: 0x455456 - 0x455457
int32_t function_455456(void) {
    // 0x455456
    int32_t result; // 0x455456
    return result;
}

// Address range: 0x456532 - 0x456533
int32_t function_456532(void) {
    // 0x456532
    int32_t result; // 0x456532
    return result;
}

// Address range: 0x45b07e - 0x45b07f
int32_t function_45b07e(void) {
    // 0x45b07e
    int32_t result; // 0x45b07e
    return result;
}

// Address range: 0x45e360 - 0x45e361
int32_t function_45e360(void) {
    // 0x45e360
    int32_t result; // 0x45e360
    return result;
}

// Address range: 0x46152a - 0x46152b
int32_t function_46152a(void) {
    // 0x46152a
    int32_t result; // 0x46152a
    return result;
}

// Address range: 0x46155e - 0x46155f
int32_t function_46155e(void) {
    // 0x46155e
    int32_t result; // 0x46155e
    return result;
}

// Address range: 0x46156e - 0x46156f
int32_t function_46156e(void) {
    // 0x46156e
    int32_t result; // 0x46156e
    return result;
}

// Address range: 0x461666 - 0x461667
int32_t function_461666(void) {
    // 0x461666
    int32_t result; // 0x461666
    return result;
}

// Address range: 0x46167a - 0x46167b
int32_t function_46167a(void) {
    // 0x46167a
    int32_t result; // 0x46167a
    return result;
}

// Address range: 0x461ca2 - 0x461ca3
int32_t function_461ca2(void) {
    // 0x461ca2
    int32_t result; // 0x461ca2
    return result;
}

// Address range: 0x461ea2 - 0x461ea3
int32_t function_461ea2(void) {
    // 0x461ea2
    int32_t result; // 0x461ea2
    return result;
}

// Address range: 0x462afe - 0x462aff
int32_t function_462afe(void) {
    // 0x462afe
    int32_t result; // 0x462afe
    return result;
}

// Address range: 0x462b9e - 0x462b9f
int32_t function_462b9e(void) {
    // 0x462b9e
    int32_t result; // 0x462b9e
    return result;
}

// Address range: 0x46328e - 0x46328f
int32_t function_46328e(void) {
    // 0x46328e
    int32_t result; // 0x46328e
    return result;
}

// Address range: 0x4632aa - 0x4632ab
int32_t function_4632aa(void) {
    // 0x4632aa
    int32_t result; // 0x4632aa
    return result;
}

// Address range: 0x464ae6 - 0x464ae7
int32_t function_464ae6(void) {
    // 0x464ae6
    int32_t result; // 0x464ae6
    return result;
}

// Address range: 0x464c16 - 0x464c17
int32_t function_464c16(void) {
    // 0x464c16
    int32_t result; // 0x464c16
    return result;
}

// Address range: 0x464f96 - 0x464f97
int32_t function_464f96(void) {
    // 0x464f96
    int32_t result; // 0x464f96
    return result;
}

// Address range: 0x465596 - 0x465597
int32_t function_465596(void) {
    // 0x465596
    int32_t result; // 0x465596
    return result;
}

// Address range: 0x465632 - 0x465633
int32_t function_465632(void) {
    // 0x465632
    int32_t result; // 0x465632
    return result;
}

// Address range: 0x46564e - 0x46564f
int32_t function_46564e(void) {
    // 0x46564e
    int32_t result; // 0x46564e
    return result;
}

// Address range: 0x46565a - 0x46565b
int32_t function_46565a(void) {
    // 0x46565a
    int32_t result; // 0x46565a
    return result;
}

// Address range: 0x4656d6 - 0x4656d7
int32_t function_4656d6(void) {
    // 0x4656d6
    int32_t result; // 0x4656d6
    return result;
}

// Address range: 0x4656fe - 0x4656ff
int32_t function_4656fe(void) {
    // 0x4656fe
    int32_t result; // 0x4656fe
    return result;
}

// Address range: 0x46571a - 0x46571b
int32_t function_46571a(void) {
    // 0x46571a
    int32_t result; // 0x46571a
    return result;
}

// Address range: 0x465776 - 0x465777
int32_t function_465776(void) {
    // 0x465776
    int32_t result; // 0x465776
    return result;
}

// Address range: 0x469226 - 0x469227
int32_t function_469226(void) {
    // 0x469226
    int32_t result; // 0x469226
    return result;
}

// Address range: 0x46c0d6 - 0x46c0d7
int32_t function_46c0d6(void) {
    // 0x46c0d6
    int32_t result; // 0x46c0d6
    return result;
}

// Address range: 0x47222a - 0x47222b
int32_t function_47222a(void) {
    // 0x47222a
    int32_t result; // 0x47222a
    return result;
}

// Address range: 0x474716 - 0x474717
int32_t function_474716(void) {
    // 0x474716
    int32_t result; // 0x474716
    return result;
}

// Address range: 0x477036 - 0x477037
int32_t function_477036(void) {
    // 0x477036
    int32_t result; // 0x477036
    return result;
}

// Address range: 0x4782d2 - 0x4782d3
int32_t function_4782d2(void) {
    // 0x4782d2
    int32_t result; // 0x4782d2
    return result;
}

// Address range: 0x4785be - 0x4785bf
int32_t function_4785be(void) {
    // 0x4785be
    int32_t result; // 0x4785be
    return result;
}

// Address range: 0x47aa6e - 0x47aa6f
int32_t function_47aa6e(void) {
    // 0x47aa6e
    int32_t result; // 0x47aa6e
    return result;
}

// Address range: 0x47acaa - 0x47acab
int32_t function_47acaa(void) {
    // 0x47acaa
    int32_t result; // 0x47acaa
    return result;
}

// Address range: 0x47b196 - 0x47b197
int32_t function_47b196(void) {
    // 0x47b196
    int32_t result; // 0x47b196
    return result;
}

// Address range: 0x47b1b6 - 0x47b1b7
int32_t function_47b1b6(void) {
    // 0x47b1b6
    int32_t result; // 0x47b1b6
    return result;
}

// Address range: 0x47b1ce - 0x47b1cf
int32_t function_47b1ce(void) {
    // 0x47b1ce
    int32_t result; // 0x47b1ce
    return result;
}

// Address range: 0x480036 - 0x480037
int32_t function_480036(void) {
    // 0x480036
    int32_t result; // 0x480036
    return result;
}

// Address range: 0x4878c2 - 0x4878c3
int32_t function_4878c2(void) {
    // 0x4878c2
    int32_t result; // 0x4878c2
    return result;
}

// Address range: 0x487e9a - 0x487e9b
int32_t function_487e9a(void) {
    // 0x487e9a
    int32_t result; // 0x487e9a
    return result;
}

// Address range: 0x4880fe - 0x4880ff
int32_t function_4880fe(void) {
    // 0x4880fe
    int32_t result; // 0x4880fe
    return result;
}

// Address range: 0x488a4e - 0x488a4f
int32_t function_488a4e(void) {
    // 0x488a4e
    int32_t result; // 0x488a4e
    return result;
}

// Address range: 0x489652 - 0x489653
int32_t function_489652(void) {
    // 0x489652
    int32_t result; // 0x489652
    return result;
}

// Address range: 0x48967e - 0x48967f
int32_t function_48967e(void) {
    // 0x48967e
    int32_t result; // 0x48967e
    return result;
}

// Address range: 0x489e0a - 0x489e0b
int32_t function_489e0a(void) {
    // 0x489e0a
    int32_t result; // 0x489e0a
    return result;
}

// Address range: 0x48a4ee - 0x48a4ef
int32_t function_48a4ee(void) {
    // 0x48a4ee
    int32_t result; // 0x48a4ee
    return result;
}

// Address range: 0x48a502 - 0x48a503
int32_t function_48a502(void) {
    // 0x48a502
    int32_t result; // 0x48a502
    return result;
}

// Address range: 0x48a5b2 - 0x48a5b3
int32_t function_48a5b2(void) {
    // 0x48a5b2
    int32_t result; // 0x48a5b2
    return result;
}

// Address range: 0x48be5a - 0x48be5b
int32_t function_48be5a(void) {
    // 0x48be5a
    int32_t result; // 0x48be5a
    return result;
}

// Address range: 0x48bf5a - 0x48bf5b
int32_t function_48bf5a(void) {
    // 0x48bf5a
    int32_t result; // 0x48bf5a
    return result;
}

// Address range: 0x48bf66 - 0x48bf67
int32_t function_48bf66(void) {
    // 0x48bf66
    int32_t result; // 0x48bf66
    return result;
}

// Address range: 0x48bf86 - 0x48bf87
int32_t function_48bf86(void) {
    // 0x48bf86
    int32_t result; // 0x48bf86
    return result;
}

// Address range: 0x49965a - 0x49965b
int32_t function_49965a(void) {
    // 0x49965a
    int32_t result; // 0x49965a
    return result;
}

// Address range: 0x49b9fc - 0x49b9fd
int32_t function_49b9fc(void) {
    // 0x49b9fc
    int32_t result; // 0x49b9fc
    return result;
}

// Address range: 0x49bd30 - 0x49bd31
int32_t function_49bd30(void) {
    // 0x49bd30
    int32_t result; // 0x49bd30
    return result;
}

// Address range: 0x5a4b82 - 0x5a4b83
int32_t function_5a4b82(void) {
    // 0x5a4b82
    int32_t result; // 0x5a4b82
    return result;
}

// Address range: 0x5a4baa - 0x5a4bab
int32_t function_5a4baa(void) {
    // 0x5a4baa
    int32_t result; // 0x5a4baa
    return result;
}

// Address range: 0x5e4bd2 - 0x5e4bd3
int32_t function_5e4bd2(void) {
    // 0x5e4bd2
    int32_t result; // 0x5e4bd2
    return result;
}

// Address range: 0x5e524e - 0x5e524f
int32_t function_5e524e(void) {
    // 0x5e524e
    int32_t result; // 0x5e524e
    return result;
}

// Address range: 0x5e5262 - 0x5e5263
int32_t function_5e5262(void) {
    // 0x5e5262
    int32_t result; // 0x5e5262
    return result;
}

// Address range: 0x60baba - 0x60babb
int32_t function_60baba(void) {
    // 0x60baba
    int32_t result; // 0x60baba
    return result;
}

// Address range: 0x61b290 - 0x61b291
int32_t function_61b290(void) {
    // 0x61b290
    int32_t result; // 0x61b290
    return result;
}

// Address range: 0x624d8e - 0x624d8f
int32_t function_624d8e(void) {
    // 0x624d8e
    int32_t result; // 0x624d8e
    return result;
}

// Address range: 0x624db6 - 0x624db7
int32_t function_624db6(void) {
    // 0x624db6
    int32_t result; // 0x624db6
    return result;
}

// Address range: 0x624dde - 0x624ddf
int32_t function_624dde(void) {
    // 0x624dde
    int32_t result; // 0x624dde
    return result;
}

// Address range: 0x6283f6 - 0x6283f7
int32_t function_6283f6(void) {
    // 0x6283f6
    int32_t result; // 0x6283f6
    return result;
}

// Address range: 0x65b268 - 0x65b269
int32_t function_65b268(void) {
    // 0x65b268
    int32_t result; // 0x65b268
    return result;
}

// Address range: 0x664d76 - 0x664d77
int32_t function_664d76(void) {
    // 0x664d76
    int32_t result; // 0x664d76
    return result;
}

// Address range: 0x665c16 - 0x665c17
int32_t function_665c16(void) {
    // 0x665c16
    int32_t result; // 0x665c16
    return result;
}

// Address range: 0x684bce - 0x684bcf
int32_t function_684bce(void) {
    // 0x684bce
    int32_t result; // 0x684bce
    return result;
}

// Address range: 0x6a465e - 0x6a465f
int32_t function_6a465e(void) {
    // 0x6a465e
    int32_t result; // 0x6a465e
    return result;
}

// Address range: 0x784bae - 0x784baf
int32_t function_784bae(void) {
    // 0x784bae
    int32_t result; // 0x784bae
    return result;
}

// Address range: 0x884b8e - 0x884b8f
int32_t function_884b8e(void) {
    // 0x884b8e
    int32_t result; // 0x884b8e
    return result;
}

// Address range: 0x924636 - 0x924637
int32_t function_924636(void) {
    // 0x924636
    int32_t result; // 0x924636
    return result;
}

// Address range: 0xa0bf02 - 0xa0bf03
int32_t function_a0bf02(void) {
    // 0xa0bf02
    int32_t result; // 0xa0bf02
    return result;
}

// Address range: 0xd76baa - 0xd76bab
int32_t function_d76baa(void) {
    // 0xd76baa
    int32_t result; // 0xd76baa
    return result;
}

// Address range: 0xe34ff6 - 0xe34ff7
int32_t function_e34ff6(void) {
    // 0xe34ff6
    int32_t result; // 0xe34ff6
    return result;
}

// Address range: 0xf76992 - 0xf76993
int32_t function_f76992(void) {
    // 0xf76992
    int32_t result; // 0xf76992
    return result;
}

// Address range: 0x1018036 - 0x1018037
int32_t function_1018036(void) {
    // 0x1018036
    int32_t result; // 0x1018036
    return result;
}

// Address range: 0x1055066 - 0x1055067
int32_t function_1055066(void) {
    // 0x1055066
    int32_t result; // 0x1055066
    return result;
}

// Address range: 0x1055076 - 0x1055077
int32_t function_1055076(void) {
    // 0x1055076
    int32_t result; // 0x1055076
    return result;
}

// Address range: 0x105dac6 - 0x105dac7
int32_t function_105dac6(void) {
    // 0x105dac6
    int32_t result; // 0x105dac6
    return result;
}

// Address range: 0x1062b06 - 0x1062b07
int32_t function_1062b06(void) {
    // 0x1062b06
    int32_t result; // 0x1062b06
    return result;
}

// Address range: 0x10654da - 0x10654db
int32_t function_10654da(void) {
    // 0x10654da
    int32_t result; // 0x10654da
    return result;
}

// Address range: 0x107471e - 0x107471f
int32_t function_107471e(void) {
    // 0x107471e
    int32_t result; // 0x107471e
    return result;
}

// Address range: 0x107832e - 0x107832f
int32_t function_107832e(void) {
    // 0x107832e
    int32_t result; // 0x107832e
    return result;
}

// Address range: 0x113aa82 - 0x113aa83
int32_t function_113aa82(void) {
    // 0x113aa82
    int32_t result; // 0x113aa82
    return result;
}

// Address range: 0x113afb2 - 0x113afb3
int32_t function_113afb2(void) {
    // 0x113afb2
    int32_t result; // 0x113afb2
    return result;
}

// Address range: 0x1178342 - 0x1178343
int32_t function_1178342(void) {
    // 0x1178342
    int32_t result; // 0x1178342
    return result;
}

// Address range: 0x117a842 - 0x117a843
int32_t function_117a842(void) {
    // 0x117a842
    int32_t result; // 0x117a842
    return result;
}

// Address range: 0x119f78a - 0x119f78b
int32_t function_119f78a(void) {
    // 0x119f78a
    int32_t result; // 0x119f78a
    return result;
}

// Address range: 0x11b08e6 - 0x11b08e7
int32_t function_11b08e6(void) {
    // 0x11b08e6
    int32_t result; // 0x11b08e6
    return result;
}

// Address range: 0x11bab0a - 0x11bab0b
int32_t function_11bab0a(void) {
    // 0x11bab0a
    int32_t result; // 0x11bab0a
    return result;
}

// Address range: 0x11bacb6 - 0x11bacb7
int32_t function_11bacb6(void) {
    // 0x11bacb6
    int32_t result; // 0x11bacb6
    return result;
}

// Address range: 0x11c472e - 0x11c472f
int32_t function_11c472e(void) {
    // 0x11c472e
    int32_t result; // 0x11c472e
    return result;
}

// Address range: 0x11c474e - 0x11c474f
int32_t function_11c474e(void) {
    // 0x11c474e
    int32_t result; // 0x11c474e
    return result;
}

// Address range: 0x11c476e - 0x11c476f
int32_t function_11c476e(void) {
    // 0x11c476e
    int32_t result; // 0x11c476e
    return result;
}

// Address range: 0x11d63d2 - 0x11d63d3
int32_t function_11d63d2(void) {
    // 0x11d63d2
    int32_t result; // 0x11d63d2
    return result;
}

// Address range: 0x11d66b2 - 0x11d66b3
int32_t function_11d66b2(void) {
    // 0x11d66b2
    int32_t result; // 0x11d66b2
    return result;
}

// Address range: 0x11db9b4 - 0x11db9b5
int32_t function_11db9b4(void) {
    // 0x11db9b4
    int32_t result; // 0x11db9b4
    return result;
}

// Address range: 0x11e2326 - 0x11e2327
int32_t function_11e2326(void) {
    // 0x11e2326
    int32_t result; // 0x11e2326
    return result;
}

// Address range: 0x11e4b8a - 0x11e4b8b
int32_t function_11e4b8a(void) {
    // 0x11e4b8a
    int32_t result; // 0x11e4b8a
    return result;
}

// Address range: 0x11e4bb2 - 0x11e4bb3
int32_t function_11e4bb2(void) {
    // 0x11e4bb2
    int32_t result; // 0x11e4bb2
    return result;
}

// Address range: 0x11f917e - 0x11f917f
int32_t function_11f917e(void) {
    // 0x11f917e
    int32_t result; // 0x11f917e
    return result;
}

// Address range: 0x11fad6a - 0x11fad6b
int32_t function_11fad6a(void) {
    // 0x11fad6a
    int32_t result; // 0x11fad6a
    return result;
}

// Address range: 0x1200042 - 0x1200043
int32_t function_1200042(void) {
    // 0x1200042
    int32_t result; // 0x1200042
    return result;
}

// Address range: 0x121adfa - 0x121adfb
int32_t function_121adfa(void) {
    // 0x121adfa
    int32_t result; // 0x121adfa
    return result;
}

// Address range: 0x121b0c6 - 0x121b0c7
int32_t function_121b0c6(void) {
    // 0x121b0c6
    int32_t result; // 0x121b0c6
    return result;
}

// Address range: 0x121b256 - 0x121b257
int32_t function_121b256(void) {
    // 0x121b256
    int32_t result; // 0x121b256
    return result;
}

// Address range: 0x122465e - 0x122465f
int32_t function_122465e(void) {
    // 0x122465e
    int32_t result; // 0x122465e
    return result;
}

// Address range: 0x1236dfe - 0x1236dff
int32_t function_1236dfe(void) {
    // 0x1236dfe
    int32_t result; // 0x1236dfe
    return result;
}

// Address range: 0x1237bfa - 0x1237bfb
int32_t function_1237bfa(void) {
    // 0x1237bfa
    int32_t result; // 0x1237bfa
    return result;
}

// Address range: 0x1244bf2 - 0x1244bf3
int32_t function_1244bf2(void) {
    // 0x1244bf2
    int32_t result; // 0x1244bf2
    return result;
}

// Address range: 0x124a4ee - 0x124a4ef
int32_t function_124a4ee(void) {
    // 0x124a4ee
    int32_t result; // 0x124a4ee
    return result;
}

// Address range: 0x124a59e - 0x124a59f
int32_t function_124a59e(void) {
    // 0x124a59e
    int32_t result; // 0x124a59e
    return result;
}

// Address range: 0x125bc7c - 0x125bc7d
int32_t function_125bc7c(void) {
    // 0x125bc7c
    int32_t result; // 0x125bc7c
    return result;
}

// Address range: 0x1261622 - 0x1261623
int32_t function_1261622(void) {
    // 0x1261622
    int32_t result; // 0x1261622
    return result;
}

// Address range: 0x12651ae - 0x12651af
int32_t function_12651ae(void) {
    // 0x12651ae
    int32_t result; // 0x12651ae
    return result;
}

// Address range: 0x12651ca - 0x12651cb
int32_t function_12651ca(void) {
    // 0x12651ca
    int32_t result; // 0x12651ca
    return result;
}

// Address range: 0x1265296 - 0x1265297
int32_t function_1265296(void) {
    // 0x1265296
    int32_t result; // 0x1265296
    return result;
}

// Address range: 0x126562a - 0x126562b
int32_t function_126562a(void) {
    // 0x126562a
    int32_t result; // 0x126562a
    return result;
}

// Address range: 0x1275146 - 0x1275147
int32_t function_1275146(void) {
    // 0x1275146
    int32_t result; // 0x1275146
    return result;
}

// Address range: 0x127aa6a - 0x127aa6b
int32_t function_127aa6a(void) {
    // 0x127aa6a
    int32_t result; // 0x127aa6a
    return result;
}

// Address range: 0x127aa6e - 0x127aa6f
int32_t function_127aa6e(void) {
    // 0x127aa6e
    int32_t result; // 0x127aa6e
    return result;
}

// Address range: 0x127af7e - 0x127af7f
int32_t function_127af7e(void) {
    // 0x127af7e
    int32_t result; // 0x127af7e
    return result;
}

// Address range: 0x127b15e - 0x127b15f
int32_t function_127b15e(void) {
    // 0x127b15e
    int32_t result; // 0x127b15e
    return result;
}

// Address range: 0x127b1da - 0x127b1db
int32_t function_127b1da(void) {
    // 0x127b1da
    int32_t result; // 0x127b1da
    return result;
}

// Address range: 0x127b1fa - 0x127b1fb
int32_t function_127b1fa(void) {
    // 0x127b1fa
    int32_t result; // 0x127b1fa
    return result;
}

// Address range: 0x128c2b2 - 0x128c2b3
int32_t function_128c2b2(void) {
    // 0x128c2b2
    int32_t result; // 0x128c2b2
    return result;
}

// Address range: 0x132233a - 0x132233b
int32_t function_132233a(void) {
    // 0x132233a
    int32_t result; // 0x132233a
    return result;
}

// Address range: 0x1420180 - 0x1420181
int32_t function_1420180(void) {
    // 0x1420180
    int32_t result; // 0x1420180
    return result;
}

// Address range: 0x1420544 - 0x1420545
int32_t function_1420544(void) {
    // 0x1420544
    int32_t result; // 0x1420544
    return result;
}

// Address range: 0x1420804 - 0x1420805
int32_t function_1420804(void) {
    // 0x1420804
    int32_t result; // 0x1420804
    return result;
}

// Address range: 0x1420ec4 - 0x1420ec5
int32_t function_1420ec4(void) {
    // 0x1420ec4
    int32_t result; // 0x1420ec4
    return result;
}

// Address range: 0x144d27c - 0x144d27d
int32_t function_144d27c(void) {
    // 0x144d27c
    int32_t result; // 0x144d27c
    return result;
}

// Address range: 0x14fadae - 0x14fadaf
int32_t function_14fadae(void) {
    // 0x14fadae
    int32_t result; // 0x14fadae
    return result;
}

// Address range: 0x158fa4c - 0x158fa4d
int32_t function_158fa4c(void) {
    // 0x158fa4c
    int32_t result; // 0x158fa4c
    return result;
}

// Address range: 0x15a2dd4 - 0x15a2dd5
int32_t function_15a2dd4(void) {
    // 0x15a2dd4
    int32_t result; // 0x15a2dd4
    return result;
}

// Address range: 0x1726bda - 0x1726bdb
int32_t function_1726bda(void) {
    // 0x1726bda
    int32_t result; // 0x1726bda
    return result;
}

// Address range: 0x1726fe2 - 0x1726fe3
int32_t function_1726fe2(void) {
    // 0x1726fe2
    int32_t result; // 0x1726fe2
    return result;
}

// Address range: 0x172b21e - 0x172b21f
int32_t function_172b21e(void) {
    // 0x172b21e
    int32_t result; // 0x172b21e
    return result;
}

// Address range: 0x175dda2 - 0x175dda3
int32_t function_175dda2(void) {
    // 0x175dda2
    int32_t result; // 0x175dda2
    return result;
}

// Address range: 0x17a7d66 - 0x17a7d67
int32_t function_17a7d66(void) {
    // 0x17a7d66
    int32_t result; // 0x17a7d66
    return result;
}

// Address range: 0x17e8422 - 0x17e8423
int32_t function_17e8422(void) {
    // 0x17e8422
    int32_t result; // 0x17e8422
    return result;
}

// Address range: 0x18153fa - 0x18153fb
int32_t function_18153fa(void) {
    // 0x18153fa
    int32_t result; // 0x18153fa
    return result;
}

// Address range: 0x1a1335e - 0x1a1335f
int32_t function_1a1335e(void) {
    // 0x1a1335e
    int32_t result; // 0x1a1335e
    return result;
}

// Address range: 0x1a137ca - 0x1a137cb
int32_t function_1a137ca(void) {
    // 0x1a137ca
    int32_t result; // 0x1a137ca
    return result;
}

// Address range: 0x1a137fe - 0x1a137ff
int32_t function_1a137fe(void) {
    // 0x1a137fe
    int32_t result; // 0x1a137fe
    return result;
}

// Address range: 0x1a1614e - 0x1a1614f
int32_t function_1a1614e(void) {
    // 0x1a1614e
    int32_t result; // 0x1a1614e
    return result;
}

// Address range: 0x1a192d6 - 0x1a192d7
int32_t function_1a192d6(void) {
    // 0x1a192d6
    int32_t result; // 0x1a192d6
    return result;
}

// Address range: 0x1a48a46 - 0x1a48a47
int32_t function_1a48a46(void) {
    // 0x1a48a46
    int32_t result; // 0x1a48a46
    return result;
}

// Address range: 0x1a5652a - 0x1a5652b
int32_t function_1a5652a(void) {
    // 0x1a5652a
    int32_t result; // 0x1a5652a
    return result;
}

// Address range: 0x1a5a06a - 0x1a5a06b
int32_t function_1a5a06a(void) {
    // 0x1a5a06a
    int32_t result; // 0x1a5a06a
    return result;
}

// Address range: 0x1a9615a - 0x1a9615b
int32_t function_1a9615a(void) {
    // 0x1a9615a
    int32_t result; // 0x1a9615a
    return result;
}

// Address range: 0x1ab6fd2 - 0x1ab6fd3
int32_t function_1ab6fd2(void) {
    // 0x1ab6fd2
    int32_t result; // 0x1ab6fd2
    return result;
}

// Address range: 0x1d62aba - 0x1d62abb
int32_t function_1d62aba(void) {
    // 0x1d62aba
    int32_t result; // 0x1d62aba
    return result;
}

// Address range: 0x1d64b56 - 0x1d64b57
int32_t function_1d64b56(void) {
    // 0x1d64b56
    int32_t result; // 0x1d64b56
    return result;
}

// Address range: 0x1dbaa12 - 0x1dbaa13
int32_t function_1dbaa12(void) {
    // 0x1dbaa12
    int32_t result; // 0x1dbaa12
    return result;
}

// Address range: 0x1de3252 - 0x1de3253
int32_t function_1de3252(void) {
    // 0x1de3252
    int32_t result; // 0x1de3252
    return result;
}

// Address range: 0x1e5e89e - 0x1e5e89f
int32_t function_1e5e89e(void) {
    // 0x1e5e89e
    int32_t result; // 0x1e5e89e
    return result;
}

// Address range: 0x1e6297e - 0x1e6297f
int32_t function_1e6297e(void) {
    // 0x1e6297e
    int32_t result; // 0x1e6297e
    return result;
}

// Address range: 0x1f27d52 - 0x1f27d53
int32_t function_1f27d52(void) {
    // 0x1f27d52
    int32_t result; // 0x1f27d52
    return result;
}

// Address range: 0x2022de0 - 0x2022de1
int32_t function_2022de0(void) {
    // 0x2022de0
    int32_t result; // 0x2022de0
    return result;
}

// Address range: 0x2036f6c - 0x2036f6d
int32_t function_2036f6c(void) {
    // 0x2036f6c
    int32_t result; // 0x2036f6c
    return result;
}

// Address range: 0xe1510003 - 0xe1510004
int32_t function_e1510003(void) {
    // 0xe1510003
    int32_t result; // 0xe1510003
    return result;
}

// Address range: 0xe28cca6b - 0xe28cca6c
int32_t function_e28cca6b(void) {
    // 0xe28cca6b
    int32_t result; // 0xe28cca6b
    return result;
}

// Address range: 0xe28cca6c - 0xe28cca6d
int32_t function_e28cca6c(void) {
    // 0xe28cca6c
    int32_t result; // 0xe28cca6c
    return result;
}

// Address range: 0xe28fc600 - 0xe28fc601
int32_t function_e28fc600(void) {
    // 0xe28fc600
    int32_t result; // 0xe28fc600
    return result;
}

// Address range: 0xe594c000 - 0xe594c001
int32_t function_e594c000(void) {
    // 0xe594c000
    int32_t result; // 0xe594c000
    return result;
}

// Address range: 0xe5bcf000 - 0xe5bcf001
int32_t function_e5bcf000(void) {
    // 0xe5bcf000
    int32_t result; // 0xe5bcf000
    return result;
}

// Address range: 0xe5bcf008 - 0xe5bcf009
int32_t function_e5bcf008(void) {
    // 0xe5bcf008
    int32_t result; // 0xe5bcf008
    return result;
}

// Address range: 0xe5bcf010 - 0xe5bcf011
int32_t function_e5bcf010(void) {
    // 0xe5bcf010
    int32_t result; // 0xe5bcf010
    return result;
}

// Address range: 0xe5bcf018 - 0xe5bcf019
int32_t function_e5bcf018(void) {
    // 0xe5bcf018
    int32_t result; // 0xe5bcf018
    return result;
}

// Address range: 0xe5bcf020 - 0xe5bcf021
int32_t function_e5bcf020(void) {
    // 0xe5bcf020
    int32_t result; // 0xe5bcf020
    return result;
}

// Address range: 0xe5bcf028 - 0xe5bcf029
int32_t function_e5bcf028(void) {
    // 0xe5bcf028
    int32_t result; // 0xe5bcf028
    return result;
}

// Address range: 0xe5bcffb8 - 0xe5bcffb9
int32_t function_e5bcffb8(void) {
    // 0xe5bcffb8
    int32_t result; // 0xe5bcffb8
    return result;
}

// Address range: 0xe5bcffc0 - 0xe5bcffc1
int32_t function_e5bcffc0(void) {
    // 0xe5bcffc0
    int32_t result; // 0xe5bcffc0
    return result;
}

// Address range: 0xe5bcffc8 - 0xe5bcffc9
int32_t function_e5bcffc8(void) {
    // 0xe5bcffc8
    int32_t result; // 0xe5bcffc8
    return result;
}

// Address range: 0xe5bcffd0 - 0xe5bcffd1
int32_t function_e5bcffd0(void) {
    // 0xe5bcffd0
    int32_t result; // 0xe5bcffd0
    return result;
}

// Address range: 0xe5bcffd8 - 0xe5bcffd9
int32_t function_e5bcffd8(void) {
    // 0xe5bcffd8
    int32_t result; // 0xe5bcffd8
    return result;
}

// Address range: 0xe5bcffe0 - 0xe5bcffe1
int32_t function_e5bcffe0(void) {
    // 0xe5bcffe0
    int32_t result; // 0xe5bcffe0
    return result;
}

// Address range: 0xe5bcffe8 - 0xe5bcffe9
int32_t function_e5bcffe8(void) {
    // 0xe5bcffe8
    int32_t result; // 0xe5bcffe8
    return result;
}

// Address range: 0xe5bcfff0 - 0xe5bcfff1
int32_t function_e5bcfff0(void) {
    // 0xe5bcfff0
    int32_t result; // 0xe5bcfff0
    return result;
}

// Address range: 0xe5bcfff8 - 0xe5bcfff9
int32_t function_e5bcfff8(void) {
    // 0xe5bcfff8
    int32_t result; // 0xe5bcfff8
    return result;
}

// Address range: 0xfe05e876 - 0xfe05e877
int32_t function_fe05e876(void) {
    // 0xfe05e876
    int32_t result; // 0xfe05e876
    return result;
}

// Address range: 0xfe0a4636 - 0xfe0a4637
int32_t function_fe0a4636(void) {
    // 0xfe0a4636
    int32_t result; // 0xfe0a4636
    return result;
}

// Address range: 0xfe0a7d2a - 0xfe0a7d2b
int32_t function_fe0a7d2a(void) {
    // 0xfe0a7d2a
    int32_t result; // 0xfe0a7d2a
    return result;
}

// Address range: 0xfe1490c6 - 0xfe1490c7
int32_t function_fe1490c6(void) {
    // 0xfe1490c6
    int32_t result; // 0xfe1490c6
    return result;
}

// Address range: 0xfe20bcf2 - 0xfe20bcf3
int32_t function_fe20bcf2(void) {
    // 0xfe20bcf2
    int32_t result; // 0xfe20bcf2
    return result;
}

// Address range: 0xfe22460e - 0xfe22460f
int32_t function_fe22460e(void) {
    // 0xfe22460e
    int32_t result; // 0xfe22460e
    return result;
}

// Address range: 0xfe227d02 - 0xfe227d03
int32_t function_fe227d02(void) {
    // 0xfe227d02
    int32_t result; // 0xfe227d02
    return result;
}

// Address range: 0xfe26515a - 0xfe26515b
int32_t function_fe26515a(void) {
    // 0xfe26515a
    int32_t result; // 0xfe26515a
    return result;
}

// Address range: 0xfe322992 - 0xfe322993
int32_t function_fe322992(void) {
    // 0xfe322992
    int32_t result; // 0xfe322992
    return result;
}

// Address range: 0xfe32bcde - 0xfe32bcdf
int32_t function_fe32bcde(void) {
    // 0xfe32bcde
    int32_t result; // 0xfe32bcde
    return result;
}

// Address range: 0xfe35e5fe - 0xfe35e5ff
int32_t function_fe35e5fe(void) {
    // 0xfe35e5fe
    int32_t result; // 0xfe35e5fe
    return result;
}

// Address range: 0xfe3a4b5e - 0xfe3a4b5f
int32_t function_fe3a4b5e(void) {
    // 0xfe3a4b5e
    int32_t result; // 0xfe3a4b5e
    return result;
}

// Address range: 0xfe3cbe62 - 0xfe3cbe63
int32_t function_fe3cbe62(void) {
    // 0xfe3cbe62
    int32_t result; // 0xfe3cbe62
    return result;
}

// Address range: 0xfe41d3f2 - 0xfe41d3f3
int32_t function_fe41d3f2(void) {
    // 0xfe41d3f2
    int32_t result; // 0xfe41d3f2
    return result;
}

// Address range: 0xfe453fae - 0xfe453faf
int32_t function_fe453fae(void) {
    // 0xfe453fae
    int32_t result; // 0xfe453fae
    return result;
}

// Address range: 0xfe4556d6 - 0xfe4556d7
int32_t function_fe4556d6(void) {
    // 0xfe4556d6
    int32_t result; // 0xfe4556d6
    return result;
}

// Address range: 0xfe45650e - 0xfe45650f
int32_t function_fe45650e(void) {
    // 0xfe45650e
    int32_t result; // 0xfe45650e
    return result;
}

// Address range: 0xfe45ac22 - 0xfe45ac23
int32_t function_fe45ac22(void) {
    // 0xfe45ac22
    int32_t result; // 0xfe45ac22
    return result;
}

// Address range: 0xfe45dc0a - 0xfe45dc0b
int32_t function_fe45dc0a(void) {
    // 0xfe45dc0a
    int32_t result; // 0xfe45dc0a
    return result;
}

// Address range: 0xfe4601c2 - 0xfe4601c3
int32_t function_fe4601c2(void) {
    // 0xfe4601c2
    int32_t result; // 0xfe4601c2
    return result;
}

// Address range: 0xfe4611b6 - 0xfe4611b7
int32_t function_fe4611b6(void) {
    // 0xfe4611b6
    int32_t result; // 0xfe4611b6
    return result;
}

// Address range: 0xfe4621a6 - 0xfe4621a7
int32_t function_fe4621a6(void) {
    // 0xfe4621a6
    int32_t result; // 0xfe4621a6
    return result;
}

// Address range: 0xfe46243e - 0xfe46243f
int32_t function_fe46243e(void) {
    // 0xfe46243e
    int32_t result; // 0xfe46243e
    return result;
}

// Address range: 0xfe46328e - 0xfe46328f
int32_t function_fe46328e(void) {
    // 0xfe46328e
    int32_t result; // 0xfe46328e
    return result;
}

// Address range: 0xfe4632aa - 0xfe4632ab
int32_t function_fe4632aa(void) {
    // 0xfe4632aa
    int32_t result; // 0xfe4632aa
    return result;
}

// Address range: 0xfe4632d2 - 0xfe4632d3
int32_t function_fe4632d2(void) {
    // 0xfe4632d2
    int32_t result; // 0xfe4632d2
    return result;
}

// Address range: 0xfe468326 - 0xfe468327
int32_t function_fe468326(void) {
    // 0xfe468326
    int32_t result; // 0xfe468326
    return result;
}

// Address range: 0xfe47222a - 0xfe47222b
int32_t function_fe47222a(void) {
    // 0xfe47222a
    int32_t result; // 0xfe47222a
    return result;
}

// Address range: 0xfe4754ea - 0xfe4754eb
int32_t function_fe4754ea(void) {
    // 0xfe4754ea
    int32_t result; // 0xfe4754ea
    return result;
}

// Address range: 0xfe48bcd2 - 0xfe48bcd3
int32_t function_fe48bcd2(void) {
    // 0xfe48bcd2
    int32_t result; // 0xfe48bcd2
    return result;
}

// Address range: 0xfe48bd3e - 0xfe48bd3f
int32_t function_fe48bd3e(void) {
    // 0xfe48bd3e
    int32_t result; // 0xfe48bd3e
    return result;
}

// Address range: 0xfe48bdee - 0xfe48bdef
int32_t function_fe48bdee(void) {
    // 0xfe48bdee
    int32_t result; // 0xfe48bdee
    return result;
}

// Address range: 0xfe49a066 - 0xfe49a067
int32_t function_fe49a066(void) {
    // 0xfe49a066
    int32_t result; // 0xfe49a066
    return result;
}

// Address range: 0xfe49a18a - 0xfe49a18b
int32_t function_fe49a18a(void) {
    // 0xfe49a18a
    int32_t result; // 0xfe49a18a
    return result;
}

// Address range: 0xfe49ba08 - 0xfe49ba09
int32_t function_fe49ba08(void) {
    // 0xfe49ba08
    int32_t result; // 0xfe49ba08
    return result;
}

// Address range: 0xfe5612d0 - 0xfe5612d1
int32_t function_fe5612d0(void) {
    // 0xfe5612d0
    int32_t result; // 0xfe5612d0
    return result;
}

// Address range: 0xfe6dc714 - 0xfe6dc715
int32_t function_fe6dc714(void) {
    // 0xfe6dc714
    int32_t result; // 0xfe6dc714
    return result;
}

// Address range: 0xfe6dc720 - 0xfe6dc721
int32_t function_fe6dc720(void) {
    // 0xfe6dc720
    int32_t result; // 0xfe6dc720
    return result;
}

// Address range: 0xfe71a29e - 0xfe71a29f
int32_t function_fe71a29e(void) {
    // 0xfe71a29e
    int32_t result; // 0xfe71a29e
    return result;
}

// Address range: 0xfe7507aa - 0xfe7507ab
int32_t function_fe7507aa(void) {
    // 0xfe7507aa
    int32_t result; // 0xfe7507aa
    return result;
}

// Address range: 0xfe75e2f6 - 0xfe75e2f7
int32_t function_fe75e2f6(void) {
    // 0xfe75e2f6
    int32_t result; // 0xfe75e2f6
    return result;
}

// Address range: 0xfe775756 - 0xfe775757
int32_t function_fe775756(void) {
    // 0xfe775756
    int32_t result; // 0xfe775756
    return result;
}

// Address range: 0xfe826bee - 0xfe826bef
int32_t function_fe826bee(void) {
    // 0xfe826bee
    int32_t result; // 0xfe826bee
    return result;
}

// Address range: 0xfe82b232 - 0xfe82b233
int32_t function_fe82b232(void) {
    // 0xfe82b232
    int32_t result; // 0xfe82b232
    return result;
}

// Address range: 0xfe84bf9a - 0xfe84bf9b
int32_t function_fe84bf9a(void) {
    // 0xfe84bf9a
    int32_t result; // 0xfe84bf9a
    return result;
}

// Address range: 0xfe85db2e - 0xfe85db2f
int32_t function_fe85db2e(void) {
    // 0xfe85db2e
    int32_t result; // 0xfe85db2e
    return result;
}

// Address range: 0xfe8cbf86 - 0xfe8cbf87
int32_t function_fe8cbf86(void) {
    // 0xfe8cbf86
    int32_t result; // 0xfe8cbf86
    return result;
}

// Address range: 0xfe94bf2e - 0xfe94bf2f
int32_t function_fe94bf2e(void) {
    // 0xfe94bf2e
    int32_t result; // 0xfe94bf2e
    return result;
}

// Address range: 0xfea0bcee - 0xfea0bcef
int32_t function_fea0bcee(void) {
    // 0xfea0bcee
    int32_t result; // 0xfea0bcee
    return result;
}

// Address range: 0xfea889c2 - 0xfea889c3
int32_t function_fea889c2(void) {
    // 0xfea889c2
    int32_t result; // 0xfea889c2
    return result;
}

// Address range: 0xfea9095e - 0xfea9095f
int32_t function_fea9095e(void) {
    // 0xfea9095e
    int32_t result; // 0xfea9095e
    return result;
}

// Address range: 0xfee6c40a - 0xfee6c40b
int32_t function_fee6c40a(void) {
    // 0xfee6c40a
    int32_t result; // 0xfee6c40a
    return result;
}

// Address range: 0xff052fb2 - 0xff052fb3
int32_t function_ff052fb2(void) {
    // 0xff052fb2
    int32_t result; // 0xff052fb2
    return result;
}

// Address range: 0xff05535e - 0xff05535f
int32_t function_ff05535e(void) {
    // 0xff05535e
    int32_t result; // 0xff05535e
    return result;
}

// Address range: 0xff05adf6 - 0xff05adf7
int32_t function_ff05adf6(void) {
    // 0xff05adf6
    int32_t result; // 0xff05adf6
    return result;
}

// Address range: 0xff06bdfa - 0xff06bdfb
int32_t function_ff06bdfa(void) {
    // 0xff06bdfa
    int32_t result; // 0xff06bdfa
    return result;
}

// Address range: 0xff07480a - 0xff07480b
int32_t function_ff07480a(void) {
    // 0xff07480a
    int32_t result; // 0xff07480a
    return result;
}

// Address range: 0xff08a0a6 - 0xff08a0a7
int32_t function_ff08a0a6(void) {
    // 0xff08a0a6
    int32_t result; // 0xff08a0a6
    return result;
}

// Address range: 0xff08a156 - 0xff08a157
int32_t function_ff08a156(void) {
    // 0xff08a156
    int32_t result; // 0xff08a156
    return result;
}

// Address range: 0xff09bc3c - 0xff09bc3d
int32_t function_ff09bc3c(void) {
    // 0xff09bc3c
    int32_t result; // 0xff09bc3c
    return result;
}

// Address range: 0xff0a83e2 - 0xff0a83e3
int32_t function_ff0a83e2(void) {
    // 0xff0a83e2
    int32_t result; // 0xff0a83e2
    return result;
}

// Address range: 0xff102b92 - 0xff102b93
int32_t function_ff102b92(void) {
    // 0xff102b92
    int32_t result; // 0xff102b92
    return result;
}

// Address range: 0xff1683ce - 0xff1683cf
int32_t function_ff1683ce(void) {
    // 0xff1683ce
    int32_t result; // 0xff1683ce
    return result;
}

// Address range: 0xff1783b2 - 0xff1783b3
int32_t function_ff1783b2(void) {
    // 0xff1783b2
    int32_t result; // 0xff1783b2
    return result;
}

// Address range: 0xff17af6e - 0xff17af6f
int32_t function_ff17af6e(void) {
    // 0xff17af6e
    int32_t result; // 0xff17af6e
    return result;
}

// Address range: 0xff1b7d66 - 0xff1b7d67
int32_t function_ff1b7d66(void) {
    // 0xff1b7d66
    int32_t result; // 0xff1b7d66
    return result;
}

// Address range: 0xff1b7d8e - 0xff1b7d8f
int32_t function_ff1b7d8e(void) {
    // 0xff1b7d8e
    int32_t result; // 0xff1b7d8e
    return result;
}

// Address range: 0xff1cbbb6 - 0xff1cbbb7
int32_t function_ff1cbbb6(void) {
    // 0xff1cbbb6
    int32_t result; // 0xff1cbbb6
    return result;
}

// Address range: 0xff1cbdc6 - 0xff1cbdc7
int32_t function_ff1cbdc6(void) {
    // 0xff1cbdc6
    int32_t result; // 0xff1cbdc6
    return result;
}

// Address range: 0xff1d3426 - 0xff1d3427
int32_t function_ff1d3426(void) {
    // 0xff1d3426
    int32_t result; // 0xff1d3426
    return result;
}

// Address range: 0xff1d505a - 0xff1d505b
int32_t function_ff1d505a(void) {
    // 0xff1d505a
    int32_t result; // 0xff1d505a
    return result;
}

// Address range: 0xff1d506a - 0xff1d506b
int32_t function_ff1d506a(void) {
    // 0xff1d506a
    int32_t result; // 0xff1d506a
    return result;
}

// Address range: 0xff1d631a - 0xff1d631b
int32_t function_ff1d631a(void) {
    // 0xff1d631a
    int32_t result; // 0xff1d631a
    return result;
}

// Address range: 0xff1d65fa - 0xff1d65fb
int32_t function_ff1d65fa(void) {
    // 0xff1d65fa
    int32_t result; // 0xff1d65fa
    return result;
}

// Address range: 0xff1e1a6a - 0xff1e1a6b
int32_t function_ff1e1a6a(void) {
    // 0xff1e1a6a
    int32_t result; // 0xff1e1a6a
    return result;
}

// Address range: 0xff1e1ede - 0xff1e1edf
int32_t function_ff1e1ede(void) {
    // 0xff1e1ede
    int32_t result; // 0xff1e1ede
    return result;
}

// Address range: 0xff1e306e - 0xff1e306f
int32_t function_ff1e306e(void) {
    // 0xff1e306e
    int32_t result; // 0xff1e306e
    return result;
}

// Address range: 0xff1faf3e - 0xff1faf3f
int32_t function_ff1faf3e(void) {
    // 0xff1faf3e
    int32_t result; // 0xff1faf3e
    return result;
}

// Address range: 0xff21534e - 0xff21534f
int32_t function_ff21534e(void) {
    // 0xff21534e
    int32_t result; // 0xff21534e
    return result;
}

// Address range: 0xff21a95e - 0xff21a95f
int32_t function_ff21a95e(void) {
    // 0xff21a95e
    int32_t result; // 0xff21a95e
    return result;
}

// Address range: 0xff21adfa - 0xff21adfb
int32_t function_ff21adfa(void) {
    // 0xff21adfa
    int32_t result; // 0xff21adfa
    return result;
}

// Address range: 0xff21bd98 - 0xff21bd99
int32_t function_ff21bd98(void) {
    // 0xff21bd98
    int32_t result; // 0xff21bd98
    return result;
}

// Address range: 0xff221c66 - 0xff221c67
int32_t function_ff221c66(void) {
    // 0xff221c66
    int32_t result; // 0xff221c66
    return result;
}

// Address range: 0xff22329a - 0xff22329b
int32_t function_ff22329a(void) {
    // 0xff22329a
    int32_t result; // 0xff22329a
    return result;
}

// Address range: 0xff2232de - 0xff2232df
int32_t function_ff2232de(void) {
    // 0xff2232de
    int32_t result; // 0xff2232de
    return result;
}

// Address range: 0xff22c386 - 0xff22c387
int32_t function_ff22c386(void) {
    // 0xff22c386
    int32_t result; // 0xff22c386
    return result;
}

// Address range: 0xff22e246 - 0xff22e247
int32_t function_ff22e246(void) {
    // 0xff22e246
    int32_t result; // 0xff22e246
    return result;
}

// Address range: 0xff230622 - 0xff230623
int32_t function_ff230622(void) {
    // 0xff230622
    int32_t result; // 0xff230622
    return result;
}

// Address range: 0xff231ff2 - 0xff231ff3
int32_t function_ff231ff2(void) {
    // 0xff231ff2
    int32_t result; // 0xff231ff2
    return result;
}

// Address range: 0xff232b76 - 0xff232b77
int32_t function_ff232b76(void) {
    // 0xff232b76
    int32_t result; // 0xff232b76
    return result;
}

// Address range: 0xff23810e - 0xff23810f
int32_t function_ff23810e(void) {
    // 0xff23810e
    int32_t result; // 0xff23810e
    return result;
}

// Address range: 0xff238386 - 0xff238387
int32_t function_ff238386(void) {
    // 0xff238386
    int32_t result; // 0xff238386
    return result;
}

// Address range: 0xff23b1ea - 0xff23b1eb
int32_t function_ff23b1ea(void) {
    // 0xff23b1ea
    int32_t result; // 0xff23b1ea
    return result;
}

// Address range: 0xff244646 - 0xff244647
int32_t function_ff244646(void) {
    // 0xff244646
    int32_t result; // 0xff244646
    return result;
}

// Address range: 0xff244666 - 0xff244667
int32_t function_ff244666(void) {
    // 0xff244666
    int32_t result; // 0xff244666
    return result;
}

// Address range: 0xff244686 - 0xff244687
int32_t function_ff244686(void) {
    // 0xff244686
    int32_t result; // 0xff244686
    return result;
}

// Address range: 0xff2446a6 - 0xff2446a7
int32_t function_ff2446a6(void) {
    // 0xff2446a6
    int32_t result; // 0xff2446a6
    return result;
}

// Address range: 0xff249226 - 0xff249227
int32_t function_ff249226(void) {
    // 0xff249226
    int32_t result; // 0xff249226
    return result;
}

// Address range: 0xff24b44e - 0xff24b44f
int32_t function_ff24b44e(void) {
    // 0xff24b44e
    int32_t result; // 0xff24b44e
    return result;
}

// Address range: 0xff24bc3e - 0xff24bc3f
int32_t function_ff24bc3e(void) {
    // 0xff24bc3e
    int32_t result; // 0xff24bc3e
    return result;
}

// Address range: 0xff24bd76 - 0xff24bd77
int32_t function_ff24bd76(void) {
    // 0xff24bd76
    int32_t result; // 0xff24bd76
    return result;
}

// Address range: 0xff25617a - 0xff25617b
int32_t function_ff25617a(void) {
    // 0xff25617a
    int32_t result; // 0xff25617a
    return result;
}

// Address range: 0xff259666 - 0xff259667
int32_t function_ff259666(void) {
    // 0xff259666
    int32_t result; // 0xff259666
    return result;
}

// Address range: 0xff259dae - 0xff259daf
int32_t function_ff259dae(void) {
    // 0xff259dae
    int32_t result; // 0xff259dae
    return result;
}

// Address range: 0xff25bc88 - 0xff25bc89
int32_t function_ff25bc88(void) {
    // 0xff25bc88
    int32_t result; // 0xff25bc88
    return result;
}

// Address range: 0xff26133e - 0xff26133f
int32_t function_ff26133e(void) {
    // 0xff26133e
    int32_t result; // 0xff26133e
    return result;
}

// Address range: 0xff2726b6 - 0xff2726b7
int32_t function_ff2726b6(void) {
    // 0xff2726b6
    int32_t result; // 0xff2726b6
    return result;
}

// Address range: 0xff2a1326 - 0xff2a1327
int32_t function_ff2a1326(void) {
    // 0xff2a1326
    int32_t result; // 0xff2a1326
    return result;
}

// Address range: 0xff2a1446 - 0xff2a1447
int32_t function_ff2a1446(void) {
    // 0xff2a1446
    int32_t result; // 0xff2a1446
    return result;
}

// Address range: 0xff2b2896 - 0xff2b2897
int32_t function_ff2b2896(void) {
    // 0xff2b2896
    int32_t result; // 0xff2b2896
    return result;
}

// Address range: 0xff38bf52 - 0xff38bf53
int32_t function_ff38bf52(void) {
    // 0xff38bf52
    int32_t result; // 0xff38bf52
    return result;
}

// Address range: 0xff464cee - 0xff464cef
int32_t function_ff464cee(void) {
    // 0xff464cee
    int32_t result; // 0xff464cee
    return result;
}

// Address range: 0xff664cda - 0xff664cdb
int32_t function_ff664cda(void) {
    // 0xff664cda
    int32_t result; // 0xff664cda
    return result;
}

// Address range: 0xff6a1bce - 0xff6a1bcf
int32_t function_ff6a1bce(void) {
    // 0xff6a1bce
    int32_t result; // 0xff6a1bce
    return result;
}

// Address range: 0xff81adb6 - 0xff81adb7
int32_t function_ff81adb6(void) {
    // 0xff81adb6
    int32_t result; // 0xff81adb6
    return result;
}

// Address range: 0xff8d2b86 - 0xff8d2b87
int32_t function_ff8d2b86(void) {
    // 0xff8d2b86
    int32_t result; // 0xff8d2b86
    return result;
}

// Address range: 0xff921ba6 - 0xff921ba7
int32_t function_ff921ba6(void) {
    // 0xff921ba6
    int32_t result; // 0xff921ba6
    return result;
}

// Address range: 0xff9cbf72 - 0xff9cbf73
int32_t function_ff9cbf72(void) {
    // 0xff9cbf72
    int32_t result; // 0xff9cbf72
    return result;
}

// Address range: 0xff9e1a32 - 0xff9e1a33
int32_t function_ff9e1a32(void) {
    // 0xff9e1a32
    int32_t result; // 0xff9e1a32
    return result;
}

// Address range: 0xff9e2292 - 0xff9e2293
int32_t function_ff9e2292(void) {
    // 0xff9e2292
    int32_t result; // 0xff9e2292
    return result;
}

// Address range: 0xff9e2cce - 0xff9e2ccf
int32_t function_ff9e2cce(void) {
    // 0xff9e2cce
    int32_t result; // 0xff9e2cce
    return result;
}

// Address range: 0xff9e3052 - 0xff9e3053
int32_t function_ff9e3052(void) {
    // 0xff9e3052
    int32_t result; // 0xff9e3052
    return result;
}

// Address range: 0xff9ee246 - 0xff9ee247
int32_t function_ff9ee246(void) {
    // 0xff9ee246
    int32_t result; // 0xff9ee246
    return result;
}

// Address range: 0xff9f061a - 0xff9f061b
int32_t function_ff9f061a(void) {
    // 0xff9f061a
    int32_t result; // 0xff9f061a
    return result;
}

// Address range: 0xffa15036 - 0xffa15037
int32_t function_ffa15036(void) {
    // 0xffa15036
    int32_t result; // 0xffa15036
    return result;
}

// Address range: 0xffa1b0c2 - 0xffa1b0c3
int32_t function_ffa1b0c2(void) {
    // 0xffa1b0c2
    int32_t result; // 0xffa1b0c2
    return result;
}

// Address range: 0xffa1b252 - 0xffa1b253
int32_t function_ffa1b252(void) {
    // 0xffa1b252
    int32_t result; // 0xffa1b252
    return result;
}

// Address range: 0xffa2129e - 0xffa2129f
int32_t function_ffa2129e(void) {
    // 0xffa2129e
    int32_t result; // 0xffa2129e
    return result;
}

// Address range: 0xffa21c9a - 0xffa21c9b
int32_t function_ffa21c9a(void) {
    // 0xffa21c9a
    int32_t result; // 0xffa21c9a
    return result;
}

// Address range: 0xffa21cb2 - 0xffa21cb3
int32_t function_ffa21cb2(void) {
    // 0xffa21cb2
    int32_t result; // 0xffa21cb2
    return result;
}

// Address range: 0xffa2212a - 0xffa2212b
int32_t function_ffa2212a(void) {
    // 0xffa2212a
    int32_t result; // 0xffa2212a
    return result;
}

// Address range: 0xffa22fea - 0xffa22feb
int32_t function_ffa22fea(void) {
    // 0xffa22fea
    int32_t result; // 0xffa22fea
    return result;
}

// Address range: 0xffa251ae - 0xffa251af
int32_t function_ffa251ae(void) {
    // 0xffa251ae
    int32_t result; // 0xffa251ae
    return result;
}

// Address range: 0xffa31f6a - 0xffa31f6b
int32_t function_ffa31f6a(void) {
    // 0xffa31f6a
    int32_t result; // 0xffa31f6a
    return result;
}

// Address range: 0xffa35962 - 0xffa35963
int32_t function_ffa35962(void) {
    // 0xffa35962
    int32_t result; // 0xffa35962
    return result;
}

// Address range: 0xffa4919e - 0xffa4919f
int32_t function_ffa4919e(void) {
    // 0xffa4919e
    int32_t result; // 0xffa4919e
    return result;
}

// Address range: 0xffa49eea - 0xffa49eeb
int32_t function_ffa49eea(void) {
    // 0xffa49eea
    int32_t result; // 0xffa49eea
    return result;
}

// Address range: 0xffa4bb66 - 0xffa4bb67
int32_t function_ffa4bb66(void) {
    // 0xffa4bb66
    int32_t result; // 0xffa4bb66
    return result;
}

// Address range: 0xffa4bd8e - 0xffa4bd8f
int32_t function_ffa4bd8e(void) {
    // 0xffa4bd8e
    int32_t result; // 0xffa4bd8e
    return result;
}

// Address range: 0xffa629ae - 0xffa629af
int32_t function_ffa629ae(void) {
    // 0xffa629ae
    int32_t result; // 0xffa629ae
    return result;
}

// Address range: 0xffa890a2 - 0xffa890a3
int32_t function_ffa890a2(void) {
    // 0xffa890a2
    int32_t result; // 0xffa890a2
    return result;
}

// Address range: 0xffb6c6b8 - 0xffb6c6b9
int32_t function_ffb6c6b8(void) {
    // 0xffb6c6b8
    int32_t result; // 0xffb6c6b8
    return result;
}

// Address range: 0xffba1b7e - 0xffba1b7f
int32_t function_ffba1b7e(void) {
    // 0xffba1b7e
    int32_t result; // 0xffba1b7e
    return result;
}

// Address range: 0xffc2972c - 0xffc2972d
int32_t function_ffc2972c(void) {
    // 0xffc2972c
    int32_t result; // 0xffc2972c
    return result;
}

// Address range: 0xffc29744 - 0xffc29745
int32_t function_ffc29744(void) {
    // 0xffc29744
    int32_t result; // 0xffc29744
    return result;
}

// Address range: 0xffc29ee4 - 0xffc29ee5
int32_t function_ffc29ee4(void) {
    // 0xffc29ee4
    int32_t result; // 0xffc29ee4
    return result;
}

// ------------------ System-Call Functions -------------------

// int32_t close(int32_t a1);
// int getrusage(__rusage_who_t who, struct rusage * usage);
// ssize_t readv(int fd, const struct iovec * iovec, int count);
// int umount2(const char * special_file, int flags);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.4.3)
// Detected functions: 3726

