//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <arpa/inet.h>
#include <assert.h>
#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <libgen.h>
#include <locale.h>
#include <math.h>
#include <netdb.h>
#include <pthread.h>
#include <sched.h>
#include <semaphore.h>
#include <setjmp.h>
#include <signal.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/prctl.h>
#include <sys/select.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/syslog.h>
#include <sys/time.h>
#include <time.h>
#include <unistd.h>

// ----------------- Float Types Definitions ------------------

typedef float float32_t;
typedef double float64_t;
typedef long double float128_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct _LOCAL___pthread_unwind_buf_t_ {
    int32_t e0;
};

struct _TYPEDEF___pthread_unwind_buf_t {
    struct _LOCAL___pthread_unwind_buf_t_ e0;
    int32_t * e1[4];
};

struct _TYPEDEF___sigset_t {
    int32_t e0[1];
};

struct _TYPEDEF_fd_set {
    int32_t e0[1];
};

struct _TYPEDEF_lldiv_t {
    int64_t e0;
    int64_t e1;
};

struct _TYPEDEF_sigset_t {
    int32_t e0[1];
};

struct __jmp_buf_tag {
    int32_t e0[8];
    int32_t e1;
    struct _TYPEDEF___sigset_t e2;
};

struct addrinfo {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    struct sockaddr * e5;
    char * e6;
    struct addrinfo * e7;
};

struct lconv {
    char * e0;
    char * e1;
    char * e2;
    char * e3;
    char * e4;
    char * e5;
    char * e6;
    char * e7;
    char * e8;
    char * e9;
    char e10;
    char e11;
    char e12;
    char e13;
    char e14;
    char e15;
    char e16;
    char e17;
    char e18;
    char e19;
    char e20;
    char e21;
    char e22;
    char e23;
};

struct sigaction {
    void (*e0)(int32_t);
    int32_t e1;
    void (*e2)();
    struct _TYPEDEF_sigset_t e3;
};

struct sockaddr {
    int32_t e0;
    char e1[14];
};

struct sysinfo {
    int32_t e0;
    int32_t e1[3];
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int16_t e8;
    int16_t e9;
    int32_t e10;
    int32_t e11;
    int32_t e12;
    char e13[1];
};

struct timespec {
    int32_t e0;
    int32_t e1;
};

struct timeval {
    int32_t e0;
    int32_t e1;
};

struct timezone {
    int32_t e0;
    int32_t e1;
};

struct tm {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    char * e10;
};

// ------------------- Function Prototypes --------------------

int32_t entry_point(int32_t a1, int32_t a2);
int32_t fgetc2(struct _IO_FILE * stream);
void free2(int32_t * ptr);
int32_t function_1052c22(void);
int32_t function_1052c7a(void);
int32_t function_1056086(void);
int32_t function_10560de(void);
int32_t function_1060efe(void);
int32_t function_1062e62(void);
int32_t function_1062e6e(void);
int32_t function_1063e52(void);
int32_t function_106400e(void);
int32_t function_1064b82(void);
int32_t function_1064efa(void);
int32_t function_106b28a(void);
int32_t function_10a43aa(void);
int32_t function_11557d6(void);
int32_t function_11af142(void);
int32_t function_11c4bfc(void);
int32_t function_11e0eb6(void);
int32_t function_11e549e(void);
int32_t function_11e54c6(void);
int32_t function_11eb4(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_11ed4(struct sockaddr * sa, int32_t salen, char * host, int32_t hostlen, char * serv, int32_t servlen, int32_t flags);
int32_t function_11ee0(int32_t * rwlock);
int32_t function_11ee7ae(void);
int32_t function_11ee7c6(void);
void function_11eec(int32_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int32_t *, int32_t *));
int32_t function_11ef8(struct _TYPEDEF_sigset_t * set);
int32_t function_11f018a(void);
int32_t function_11f019e(void);
char * function_11f04(int32_t errnum);
int32_t function_11f10(struct _IO_FILE * stream);
int32_t function_11f1c(char * path, int32_t mode);
int32_t function_11f28(struct __jmp_buf_tag env[1], int32_t savemask);
int32_t function_11f2a7a(void);
void function_11f34(void);
int32_t function_11f40(int32_t fd, struct sockaddr * addr, int32_t len);
struct tm * function_11f4c(int32_t * timer);
int32_t function_11f58(int32_t * rwlock);
int32_t function_11f64(int32_t * s1, int32_t * s2, int32_t n);
int32_t function_11f70(int32_t name);
void function_11f7c(int32_t pri, char * fmt, ...);
int32_t function_11f88(int32_t clock_id, struct timespec * tp);
int32_t function_11f94(int32_t main, int32_t argc, char ** ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)());
void (*function_11fa0(int32_t sig, void (*handler)(int32_t)))(int32_t);
void function_11fac(void);
int32_t function_11fc4(char * s, char * format, ...);
int32_t function_11fd0(char * s, int32_t maxlen, char * format, int32_t arg);
int32_t function_11fdc(char * cp);
char * function_11fe8(char * dest, char * src, int32_t n);
int32_t function_11ff4(struct _IO_FILE * stream);
char * function_12000(char * s, int32_t n, struct _IO_FILE * stream);
int32_t function_1200c(int32_t fd, int32_t * buf, int32_t n, int32_t flags);
char * function_12018(char * name);
float64_t function_12024(char * nptr, char ** endptr);
char * function_12030(char * s, int32_t c);
int32_t function_1203c(char * s1, char * s2);
char * function_12048(char * path);
int32_t function_12054(int32_t mask);
int32_t function_12060(struct _IO_FILE * stream);
int32_t function_1206c(int32_t fd, int32_t n);
int32_t * function_12078(int32_t nmemb, int32_t size);
int32_t function_12084(int32_t * cond, int32_t * mutex);
int32_t function_12090(int32_t * sem, int32_t pshared, int32_t value);
char * function_1209c(char * dest, char * src);
int32_t * function_120a8(int32_t * s, int32_t c, int32_t n);
int32_t function_120b4(int32_t * sem);
int32_t function_120c0(int32_t * cond, int32_t * mutex, struct timespec * abstime);
void function_120cc(struct addrinfo * ai);
void function_120d8(char * s);
int64_t function_120e4(char * nptr, char ** endptr, int32_t base);
float64_t function_120f0(float64_t a1);
void function_120fc(char * assertion, char * file, int32_t line, char * function);
int32_t function_12114(int32_t * cond);
int32_t function_12120(int32_t useconds);
int32_t function_1212c(int32_t * mutex);
int32_t function_12144(int32_t fd, int32_t * buf, int32_t nbytes);
int32_t function_12150(int32_t fd, int32_t * buf, int32_t n);
int32_t function_1215c(char * name, int32_t type);
void function_12168(char * ident, int32_t option, int32_t facility);
int32_t function_12174(struct timeval * tv, struct timezone * tz);
int32_t function_12180(int32_t * sem);
int32_t function_1218c(int32_t fd, struct sockaddr * addr, int32_t * addr_len);
int32_t function_12198(void);
int32_t function_121a4(int32_t * mutex);
float64_t function_121b0(float64_t a1);
int32_t function_121bc(int32_t domain, int32_t type, int32_t protocol);
int32_t function_121c8(char * path, char * arg, ...);
int32_t function_121d4(char * name, char * service, struct addrinfo * req, struct addrinfo ** pai);
int32_t function_121e0(struct _IO_FILE * stream);
int32_t function_121ec(int32_t fd);
int32_t function_121f8(int32_t * mutex);
int32_t function_12204(char * s);
int32_t function_1220f0e(void);
int32_t function_1220f66(void);
int32_t function_12210(int32_t * a1, char * a2, int32_t * a3, int32_t a4);
int32_t function_1221c(int32_t * newthread, int32_t * attr, int32_t * (*start_routine)(int32_t *), int32_t * arg);
int32_t function_12228(char * path, char * argv[1]);
struct _TYPEDEF_lldiv_t function_12234(int64_t numer, int64_t denom);
int32_t * function_12240(int32_t * dest, int32_t * src, int32_t n);
int32_t function_12246fa(void);
int32_t function_1224bbe(void);
struct _IO_FILE * function_1224c(char * filename, char * modes);
int32_t function_1224c7a(void);
int32_t function_1224cae(void);
int32_t function_1224f72(void);
int32_t function_12258(int32_t * cond);
int32_t ** function_12264(void);
struct lconv * function_12270(void);
int32_t function_12288(char * nptr, char ** endptr, int32_t base);
char * function_12294(char * dest, char * src);
int32_t function_122a0(int32_t * sem);
int32_t function_122ac(int32_t * cond);
char * function_122b8(char * dest, char * src, int32_t n);
int32_t function_122c4(struct timeval * tv, struct timezone * tz);
int32_t function_122d0(int32_t * mutex);
int32_t function_122dc(char * format, ...);
int32_t function_122e242(void);
int32_t function_122e8(char * file, int32_t oflag, ...);
int32_t function_122ee72(void);
int32_t function_122f4(int32_t sig);
int32_t function_122fc1a(void);
int32_t function_122fd06(void);
void function_12300(int32_t status, char * format, ...);
float32_t function_1230c(char * nptr, char ** endptr);
int32_t function_12318(int32_t * mutex, int32_t * mutexattr);
int32_t function_12324(int32_t fd, int32_t how);
int32_t function_12330(int32_t fd, struct sockaddr * addr, int32_t len);
struct _IO_FILE * function_1233c(int32_t fd, char * modes);
char * function_12348(char * haystack, char * needle);
int32_t function_12354(int32_t inc);
int32_t function_12360(int32_t nfds, struct _TYPEDEF_fd_set * readfds, struct _TYPEDEF_fd_set * writefds, struct _TYPEDEF_fd_set * exceptfds, struct timeval * timeout);
int32_t function_1236c(int32_t fd);
int32_t function_12378(int32_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s);
int32_t function_12384(int32_t * attr, int32_t stacksize);
int32_t function_12390(char * s1, char * s2, int32_t n);
int32_t function_1239c(int32_t * timer);
float64_t function_123a8(float64_t a1);
int16_t ** function_123b4(void);
int32_t function_123c0(struct _IO_FILE * stream, char * format, ...);
int32_t function_123d8(int32_t sig, struct sigaction * act, struct sigaction * oact);
int32_t function_123e4(int32_t * sem, struct timespec * abstime);
int32_t function_123f0(int32_t * attr);
int32_t function_123fc(int32_t c, struct _IO_FILE * stream);
char * function_12408(char * s, char * delim);
int32_t function_12414(int32_t * rwlock);
int32_t function_12420(int32_t seconds);
int32_t function_1242c(int32_t fd, int32_t * buf, int32_t n, int32_t flags);
int32_t function_12435a6(void);
int32_t function_1243656(void);
int32_t function_12438(int32_t * rwlock);
char * function_12444(char * dest, char * src);
int32_t function_1244ec4(void);
int32_t * function_12450(int32_t * dest, int32_t * src, int32_t n);
void function_1245c(void);
struct _IO_FILE * function_12468(char * command, char * modes);
int32_t function_12474(int32_t fd, int32_t fd2);
int32_t function_12480(char * s);
int32_t function_1248c(void);
int32_t function_12498(int32_t option, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5);
int32_t function_124a4(int32_t fd, int32_t cmd, ...);
int32_t function_124b0(void);
void function_124bc(struct _TYPEDEF___pthread_unwind_buf_t * buf);
void function_124c8(struct _TYPEDEF___pthread_unwind_buf_t * buf);
int32_t function_124d4(struct _IO_FILE * s, char * format, int32_t arg);
int32_t function_124e0(char * s, int32_t maxlen, char * format, ...);
int32_t function_124ec(char * s, char * reject);
int32_t function_124f8(int32_t * ptr, int32_t size, int32_t n, struct _IO_FILE * stream);
int32_t function_12504(int32_t * cond, int32_t * cond_attr);
int32_t function_12510(char * s1, char * s2, int32_t n);
int32_t function_1251c(int32_t pid, int32_t sig);
int32_t function_12528(struct timespec * requested_time, struct timespec * remaining);
int32_t function_12534(int32_t th);
int32_t * function_12540(int32_t * ptr, int32_t size);
int32_t function_1254c(int32_t * rwlock);
int32_t function_12558(int32_t state, int32_t * oldstate);
int32_t function_12564(struct sysinfo * info);
int32_t function_12570(int32_t fd, int32_t level, int32_t optname, int32_t * optval, int32_t * optlen);
int32_t function_1257c(int32_t pipedes[2]);
char * function_12588(char * string);
int32_t function_12594(int32_t fd, int32_t level, int32_t optname, int32_t * optval, int32_t optlen);
char * function_125a0(char * s, char * accept2);
int32_t function_125ac(int32_t * sem);
int32_t * function_125b8(int32_t * s, int32_t c, int32_t n);
int32_t function_125c4(char * s1, char * s2);
void function_125d0(int32_t status);
int32_t function_125dc(int32_t type, int32_t * oldtype);
int32_t function_125e8(int32_t clock_id, int32_t flags, struct timespec * req, struct timespec * rem);
int32_t function_125f4(int32_t * rwlock, int32_t * attr);
void function_12600(struct _TYPEDEF___pthread_unwind_buf_t * buf);
int32_t * function_1260c(void);
int32_t function_12618(void);
int32_t function_12624(int32_t th);
int32_t function_1262b5e(void);
int32_t function_1262c1e(void);
int32_t function_1262fb2(void);
int32_t function_12630(char * s, char * format, ...);
int32_t function_1263c(int32_t th, int32_t ** thread_return);
int32_t function_12648(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_126beaa(void);
int32_t function_126eb2a(void);
int32_t function_126ef3e(void);
int32_t function_126ef7a(void);
int32_t function_127d636(void);
int32_t function_127d942(void);
int32_t function_1292f12(void);
int32_t function_1292f6a(void);
int32_t function_12ac7ca(void);
int32_t function_12ec54e(void);
int32_t function_12ef1f6(void);
int32_t function_12ef242(void);
int32_t function_12ef266(void);
int32_t function_12ef5de(void);
int32_t function_12ef61a(void);
int32_t function_136ef5a(void);
int32_t function_13ae48a(void);
int32_t function_13aef76(void);
int32_t function_13d19d2(void);
int32_t function_13edf06(void);
int32_t function_14093c8(void);
int32_t function_140978c(void);
int32_t function_1409a4c(void);
int32_t function_140a10c(void);
int32_t function_14364c4(void);
int32_t function_1558dba(void);
int32_t function_1578c94(void);
int32_t function_158c01c(void);
int32_t function_15e20(int32_t result);
int32_t function_15e2c(void);
int32_t function_15e50(void);
int32_t function_15e56(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_15e74(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_15ea4(int32_t a1);
int32_t function_15eb8(int32_t a1);
int32_t function_16000(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_16188(int32_t a1, int32_t a2);
int32_t function_16305e(void);
int32_t function_16384(int32_t result, int32_t a2);
int32_t function_163fe2(void);
int32_t function_164a0(int32_t a1, int32_t a2);
int32_t function_1655786(void);
int32_t function_166ac(int32_t a1, int32_t a2);
int32_t function_16c18(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11, int32_t a12, int32_t a13, int32_t a14, int32_t a15, int32_t a16, int32_t a17, int32_t a18, int32_t a19, int32_t a20, int32_t a21, int32_t a22, int32_t a23, int32_t a24, int32_t a25, int32_t a26, int32_t a27);
int32_t function_16d1e0e(void);
int32_t function_17666ba(void);
int32_t function_17a631e(void);
int32_t function_17f416a(void);
int32_t function_17f4a86(void);
int32_t function_17f56ee(void);
int32_t function_18552ee(void);
int32_t function_192c72(void);
int32_t function_195e52(void);
int32_t function_19607e(void);
int32_t function_19b3fe(void);
int32_t function_19c41e(void);
int32_t function_19eed7a(void);
int32_t function_1af4b6(void);
int32_t function_1b44c2(void);
int32_t function_1b5732(void);
int32_t function_1b59be(void);
int32_t function_1bfd84a(void);
int32_t function_1cca0(int32_t a1, int32_t a2, uint32_t a3);
int32_t function_1ccd0(int32_t a1, int32_t a2);
int32_t function_1ccec(int32_t a1, int32_t * str2, int32_t a3);
int32_t function_1cecc(int32_t a1);
int32_t function_1cf44(int32_t a1);
int32_t function_1cf4c(void);
int32_t function_1cfcc(void);
int32_t function_1cfd8(int32_t * a1, int32_t a2, int32_t a3);
int32_t function_1d050(void);
int32_t function_1d058(int32_t a1);
int32_t function_1d05e(int32_t a1);
int32_t function_1d060(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9);
int32_t function_1d104(void);
int32_t function_1d108(int32_t result, int32_t a2);
int32_t function_1d118(void);
int32_t function_1d11c(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_1d120(void);
int32_t function_1d122(void);
int32_t function_1d124(int32_t a1);
int32_t function_1d17e(void);
int32_t function_1d180(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_1d188(void);
int32_t function_1d1ca(void);
int32_t function_1d1cc(int32_t a1, int32_t a2, int32_t a3);
int32_t function_1d1f6(void);
int32_t function_1d1f8(int32_t result, int32_t a2, int32_t a3);
int32_t function_1d204(int32_t a1, int32_t a2, int32_t a3);
int32_t function_1d292(void);
int32_t function_1d294(void);
int32_t function_1d298(void);
int32_t function_1d29c(int32_t result);
int32_t function_1d2a6(int32_t result);
int32_t function_1d2ac(int32_t a1);
int32_t function_1d2c16(void);
int32_t function_1d30e(void);
int32_t function_1d310(void);
int32_t function_1d340(int32_t result, int32_t a2);
int32_t function_1d3a2(int32_t a1);
int32_t function_1d3a4(void);
int32_t function_1d3ac(int32_t a1, int32_t a2, int32_t a3);
int32_t function_1d490(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t function_1d4a0(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_1d4b0(void);
int32_t function_1d500(void);
int32_t function_1d504(void);
int32_t function_1d554(void);
int32_t function_1d558(void);
int32_t function_1d5a4(int32_t result, int32_t a2);
int32_t function_1d5ac(void);
int32_t function_1d5aea(void);
int32_t function_1d5c7e(void);
int32_t function_1d5d16(void);
int32_t function_1d5fc(void);
int32_t function_1d602a(void);
int32_t function_1d604(int32_t result, int32_t a2, int32_t a3);
int32_t function_1d60442(void);
int32_t function_1d60da(void);
int32_t function_1d61be(void);
int32_t function_1d800(int32_t * a1);
int32_t function_1d830(int32_t * a1, int32_t a2, uint32_t a3);
int32_t function_1d8dc(int32_t * a1, int32_t a2);
int32_t function_1d9622a(void);
int32_t function_1d9b56(void);
int32_t function_1d9bae(void);
int32_t function_1d9c8(int32_t * a1, int32_t a2, int32_t * a3);
int32_t function_1da28(void);
int32_t function_1da30(int32_t a1, int32_t str2, int32_t a3);
int32_t function_1db83a6(void);
int32_t function_1dc9c(int32_t a1, int32_t sock, int32_t a3);
int32_t function_1dcfb6(void);
int32_t function_1dd00e(void);
int32_t function_1de0bda(void);
int32_t function_1e150(int32_t a1);
int32_t function_1e190(int32_t fd);
int32_t function_1e1b8(uint32_t a1, char a2);
int32_t function_1e24c(int32_t a1, uint32_t a2);
int32_t function_1e2b0(void);
int32_t function_1e2c8(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_1e324(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_1e330(int32_t str2, char * a2, int32_t a3);
int32_t function_1e41da(void);
int32_t function_1e480(int32_t rwlock, char * a2, int32_t a3);
int32_t function_1e4f0(int32_t a1, int32_t a2);
int32_t function_1e4fc(int32_t rwlock, char * a2, int32_t a3);
int32_t function_1e56c(int32_t a1, int32_t a2);
int32_t function_1e578(int32_t mutex, char * a2, int32_t a3);
int32_t function_1e5e8(int32_t a1, int32_t a2);
int32_t function_1e5f4(char * a1, int32_t a2);
int32_t function_1e64c(int32_t a1, int32_t a2);
int32_t function_1e658(int32_t a1);
int32_t function_1e65cd2(void);
int32_t function_1e6e8(int32_t a1, int32_t a2);
int32_t function_1e74c(uint32_t a1, char * a2, char * a3, int32_t a4);
int32_t function_1e7c8(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_1e7d4(int32_t nmemb, uint32_t a2, char * a3, char * a4, int32_t a5);
int32_t function_1e858(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_1e864(int32_t a1, uint32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_1e8e8(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_1e8f8(int32_t a1);
int32_t function_1e944(int32_t * a1, int32_t a2, int32_t a3);
int32_t function_1e9b4(int32_t a1, uint32_t a2);
int32_t function_1ea68(int32_t a1, int32_t a2, int32_t a3);
int32_t function_1ec0c(int32_t * a1, int32_t str);
int32_t function_1ece4(int32_t a1, int32_t a2);
int32_t function_1ed30(int32_t a1, int32_t a2);
int32_t function_1ee1b6(void);
int32_t function_1ef20(void);
int32_t function_1ef7c(int32_t a1);
int32_t function_1efe4(void);
int32_t function_1efec(void);
int32_t function_1eff4(int32_t a1, int32_t a2);
int32_t function_1f0c8(int32_t a1, int32_t abstime);
int32_t function_1f156fa(void);
int32_t function_1f1a8(int32_t a1);
int32_t function_1f1e4(int32_t result, int32_t a2);
int32_t function_1f218(int32_t * a1, int32_t a2);
int32_t function_1f25c(int32_t * a1, int32_t a2);
int32_t function_1f290(int32_t a1, int32_t a2);
int32_t function_1f2c4(int32_t result, int32_t a2);
int32_t function_1f2f4(int32_t result, int32_t a2);
int32_t function_1f310(int32_t a1);
int32_t function_1f348(int32_t * a1);
int32_t function_1f388(int32_t * a1);
int32_t function_1f3c8(int32_t a1);
int32_t function_1f404(int32_t result, int32_t a2);
int32_t function_1f48c(int32_t str, int32_t str2);
int32_t function_1f57c(int32_t str);
int32_t function_1f5c4(int32_t * a1);
int32_t function_1f608(int32_t a1);
int32_t function_1f638(int32_t a1, int32_t a2, int32_t a3);
int32_t function_1f674(int32_t * tp);
int32_t function_1f680(int32_t * a1, int32_t a2);
int32_t function_1f68666(void);
int32_t function_1f740(int32_t * a1);
int32_t function_1f7f8(int32_t a1);
int32_t function_1f824(int32_t a1, int32_t a2);
int32_t function_1f858(void);
int32_t function_1f85c(int32_t result);
int32_t function_1f860(int32_t a1);
int32_t function_1f864(void);
int32_t function_1f868(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_1f8ec(int32_t result, int32_t * a2);
int32_t function_1f90e(void);
int32_t function_1f920(void);
int32_t function_1f924(void);
int32_t function_1f930(int32_t str, int32_t a2, int32_t a3);
int32_t function_1f94f66(void);
int32_t function_1faa4(int32_t result, int32_t a2);
int32_t function_1fb7c(int32_t a1);
int32_t function_1fb9c(int32_t result, uint32_t a2, uint32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_1fc08(int32_t a1, int32_t * a2);
int32_t function_1fcc8(int32_t a1, int32_t a2);
int32_t function_1fd9112(void);
int32_t function_1fe1e86(void);
int32_t function_1ff10(void);
int32_t function_1ff14(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10);
int32_t function_200ae58d(void);
int32_t function_200c028(void);
int32_t function_20201b4(void);
int32_t function_20258(int32_t a1, int32_t a2, int32_t a3);
int32_t function_203bc(int32_t a1, int32_t * a2, int32_t a3);
int32_t function_20770(int32_t a1, int32_t a2, int32_t a3);
int32_t function_20cfc(int32_t a1);
int32_t function_2129e6(void);
int32_t function_21468e(void);
int32_t function_2146de(void);
int32_t function_215dde(void);
int32_t function_21ad4(int32_t a1, int32_t a2);
int32_t function_21bc4(int32_t result, int32_t a2);
int32_t function_21c98(int32_t str2);
int32_t function_21db8(int32_t * a1);
int32_t function_21df8(int32_t sem, char * a2, char * a3, int32_t a4);
int32_t function_21e74(int32_t a1, int32_t * attr, int32_t thread_func, int32_t thread_func_arg);
int32_t function_21ebc(int32_t sem, char * a2, char * a3, int32_t a4);
int32_t function_21ef4(int32_t a1);
int32_t function_21f38(int32_t a1, char * a2, char * a3, int32_t a4);
int32_t function_21fb8(int32_t a1, int32_t a2, char * a3, char * a4, int32_t a5);
int32_t function_21fc76(void);
int32_t function_21fc8a(void);
int32_t function_22108(int32_t sem);
int32_t function_2213c(void);
int32_t function_22140(int32_t a1, int32_t a2, int32_t a3);
int32_t function_221992(void);
int32_t function_2219a6(void);
int32_t function_2220c(int32_t result, int32_t * a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_222c12(void);
int32_t function_2237c(int32_t a1);
int32_t function_22408(int32_t str, int32_t a2);
int32_t function_2251c(int32_t a1, int32_t a2);
int32_t function_22550(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_22563a(void);
int32_t function_225662(void);
int32_t function_225816(void);
int32_t function_225df2(void);
int32_t function_22805a(void);
int32_t function_228096(void);
int32_t function_2280aa(void);
int32_t function_22add2(void);
int32_t function_22eef6(void);
int32_t function_232196(void);
int32_t function_2324b2(void);
int32_t function_233036(void);
int32_t function_234416(void);
int32_t function_234716(void);
int32_t function_234ab6(void);
int32_t function_234d36(void);
int32_t function_236b8(int32_t a1, int32_t sock, int32_t a3);
int32_t function_239536(void);
int32_t function_23974(int32_t a1);
int32_t function_239842(void);
int32_t function_244c74(void);
int32_t function_24a2c(int32_t a1);
int32_t function_24ab8(int32_t a1, int32_t a2);
int32_t function_24d006(void);
int32_t function_24e38e(void);
int32_t function_24e8c(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_25228e(void);
int32_t function_2522c2(void);
int32_t function_2522f6(void);
int32_t function_25232a(void);
int32_t function_252472(void);
int32_t function_2524ca(void);
int32_t function_252862(void);
int32_t function_252d6e(void);
int32_t function_252dc6(void);
int32_t function_253336(void);
int32_t function_25337a(void);
int32_t function_2533be(void);
int32_t function_253896(void);
int32_t function_25391a(void);
int32_t function_25397e(void);
int32_t function_2543fe(void);
int32_t function_25443e(void);
int32_t function_25448e(void);
int32_t function_25451e(void);
int32_t function_2545a2(void);
int32_t function_2546a6(void);
int32_t function_2546f6(void);
int32_t function_2549c6(void);
int32_t function_254d4a(void);
int32_t function_254f42(void);
int32_t function_254f8a(void);
int32_t function_254fb2(void);
int32_t function_254fd2(void);
int32_t function_254ff6(void);
int32_t function_25558a(void);
int32_t function_2555a2(void);
int32_t function_2556c6(void);
int32_t function_255752(void);
int32_t function_2557a2(void);
int32_t function_2557d6(void);
int32_t function_25587e(void);
int32_t function_2558d6(void);
int32_t function_25592e(void);
int32_t function_255a1e(void);
int32_t function_255d0e(void);
int32_t function_255e3a(void);
int32_t function_255e92(void);
int32_t function_255ea2(void);
int32_t function_255ea6(void);
int32_t function_25617e(void);
int32_t function_25632a(void);
int32_t function_25a68(int32_t a1, int32_t a2);
int32_t function_25a7c(int32_t a1);
int32_t function_25c4de(void);
int32_t function_25e74(int32_t a1);
int32_t function_26164(int32_t a1, int32_t a2, int32_t a3);
int32_t function_261e0(int32_t * a1, int32_t a2);
int32_t function_26220(int32_t a1, char a2);
int32_t function_262686(void);
int32_t function_2643a6(void);
int32_t function_26448e(void);
int32_t function_264932(void);
int32_t function_26508(int32_t a1, int32_t a2, int32_t a3);
int32_t function_26578e(void);
int32_t function_2682ee(void);
int32_t function_26ad8e(void);
int32_t function_26adae(void);
int32_t function_26b026(void);
int32_t function_26b28(void);
int32_t function_26b40(int32_t result, int32_t a2);
int32_t function_26b7c(int32_t a1, int32_t a2);
int32_t function_26bd8(int32_t a1, uint32_t a2);
int32_t function_26bfae(void);
int32_t function_26c17a(void);
int32_t function_26cb0(int32_t result, int32_t a2, uint32_t a3);
int32_t function_26cd8(int32_t a1);
int32_t function_26ce8(int32_t a1);
int32_t function_26cf8(int32_t a1);
int32_t function_26d08(int32_t a1);
int32_t function_26d24(void);
int32_t function_26d2c(void);
int32_t function_26d30(void);
int32_t function_26d34(void);
int32_t function_26d3c(void);
int32_t function_26d48(void);
int32_t function_26d50(void);
int32_t function_26d54(void);
int32_t function_26d5c(int32_t result);
int32_t function_26d78(int32_t format, int32_t a2, int32_t a3, int32_t a4);
int32_t function_26dc0(void);
int32_t function_26dd8(void);
int32_t function_26df0(void);
int32_t function_26e08(void);
int32_t function_26e20(void);
int32_t function_26e38(void);
int32_t function_26e50(int32_t a1);
int32_t function_26f072(void);
int32_t function_26f09a(void);
int32_t function_27064(int32_t str);
int32_t function_2711c(int32_t a1);
int32_t function_27174(int32_t a1);
int32_t function_271ac(int32_t a1);
int32_t function_271e0(uint32_t result5, uint32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_27404(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_27410(void);
int32_t function_27418(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t function_2744c(void);
int32_t function_27464(int32_t result2, int32_t a2, int32_t a3, int32_t a4);
int32_t function_27498(void);
int32_t function_2749a(int32_t a1, int32_t a2);
int32_t function_2749ca(void);
int32_t function_274b0(int32_t result, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_2754a(int32_t a1, int32_t a2);
int32_t function_275a0(void);
int32_t function_275ae(int32_t a1, int32_t a2);
int32_t function_275d0(void);
int32_t function_275d4(int32_t result, int32_t a2);
int32_t function_275d8(int32_t result, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_275ee(void);
int32_t function_275f2(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_275fc(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_27608(void);
int32_t function_2761e(int32_t a1, int32_t a2, int32_t a3);
int32_t function_2763c(void);
int32_t function_27640(int32_t a1);
int32_t function_27644(int32_t result);
int32_t function_27648(void);
int32_t function_2764c(int32_t a1);
int32_t function_2768c(int32_t a1);
int32_t function_27704(void);
int32_t function_27820(void);
int32_t function_27834(int32_t a1);
int32_t function_2794c(void);
int32_t function_27952(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9);
int32_t function_27958(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_27970(void);
int32_t function_27986(void);
int32_t function_27988(void);
int32_t function_27998(int32_t result);
int32_t function_279b8(int32_t a1);
int32_t function_279dc(int32_t result);
int32_t function_27a64(int32_t a1);
int32_t function_27aa02(void);
int32_t function_27aa5a(void);
int32_t function_27af0(int32_t a1);
int32_t function_27b58(int32_t a1, int32_t a2, int32_t a3);
int32_t function_27b60(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_27b64(int32_t a1);
int32_t function_27b68(int32_t a1);
int32_t function_27b6c(int32_t a1);
int32_t function_27bc4(int32_t a1);
int32_t function_27c982(void);
int32_t function_27c9ca(void);
int32_t function_27ca12(void);
int32_t function_27ca5a(void);
int32_t function_27cc0(int32_t a1, int32_t a2);
int32_t function_27cf6e(void);
int32_t function_27d4be(void);
int32_t function_27d546(void);
int32_t function_28048(void);
int32_t function_28180(int32_t result, int32_t a2, int32_t a3);
int32_t function_28184(void);
int32_t function_28188(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_281d4(int32_t a1, int32_t a2);
int32_t function_281ea(void);
int32_t function_281f2(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_28274(uint32_t a1, int32_t a2);
int32_t function_28284(void);
int32_t function_283b0(int32_t result2, int32_t a2, int32_t a3, char a4);
int32_t function_28558(int32_t a1);
int32_t function_285a8(void);
int32_t function_28604(int32_t a1);
int32_t function_28640(void);
int32_t function_28688(int32_t a1, uint32_t a2);
int32_t function_286b8(int32_t a1, int32_t a2);
int32_t function_286ec(int32_t a1, int32_t a2);
int32_t function_2871c(int32_t a1, int32_t a2);
int32_t function_2874c(int32_t a1, int32_t a2);
int32_t function_2877c(int32_t a1, int32_t a2);
int32_t function_287ac(int32_t a1, int32_t a2);
int32_t function_287dc(int32_t a1, uint32_t a2);
int32_t function_28808(int32_t a1, uint32_t a2);
int32_t function_28834(int32_t a1, uint32_t a2);
int32_t function_28860(int32_t a1, int32_t a2);
int32_t function_28894(int32_t result, int32_t a2);
int32_t function_28898(int32_t a1);
int32_t function_288bc(int32_t a1, uint32_t a2);
int32_t function_288e8(int32_t a1, int32_t a2);
int32_t function_28918(int32_t a1, uint32_t a2);
int32_t function_28944(int32_t a1, int32_t a2, int32_t a3);
int32_t function_2898c(int32_t a1, int32_t a2, int32_t a3);
int32_t function_28996(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11);
int32_t function_289d6(void);
int32_t function_289d8(void);
int32_t function_289dc(void);
int32_t function_289e4(void);
int32_t function_289ec(void);
int32_t function_289f0(void);
int32_t function_289f4(void);
int32_t function_289f8(void);
int32_t function_28a64(int32_t * str, int32_t size, int32_t * a3);
int32_t function_28afc(void);
int32_t function_28c80(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_28ccc(int32_t a1);
int32_t function_28cd6(int32_t a1);
int32_t function_28cd8(int32_t a1, uint32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_28cfc(int32_t a1, int32_t a2);
int32_t function_28d6c(int32_t a1, int32_t a2);
int32_t function_28e4c(int32_t a1);
int32_t function_28ea8(int32_t a1);
int32_t function_28ee4(int32_t a1, int32_t a2, int32_t a3);
int32_t function_28ffc(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_29082(void);
int32_t function_29088(void);
int32_t function_29090(int32_t result);
int32_t function_290da(int32_t a1, int32_t a2, int32_t a3);
int32_t function_29100(void);
int32_t function_2911c(void);
int32_t function_29144(int32_t a1);
int32_t function_2920c(int32_t result, int32_t a2);
int32_t function_29244(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_292d4(void);
int32_t function_292dc(int32_t a1);
int32_t function_292f8(int32_t * a1, char * a2, char * a3, int32_t a4);
int32_t function_29530(int32_t result);
int32_t function_295ec(void);
int32_t function_295f4(void);
int32_t function_295f8(void);
int32_t function_295fc(int32_t a1);
int32_t function_29600(void);
int32_t function_29604(int32_t result);
int32_t function_29608(void);
int32_t function_2960c(void);
int32_t function_2963c(int32_t result);
int32_t function_2964c(int32_t result);
int32_t function_29650(int32_t a1);
int32_t function_29680(void);
int32_t function_29684(void);
int32_t function_29688(int32_t result);
int32_t function_29690(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_296d8(void);
int32_t function_29720(void);
int32_t function_297ec(void);
int32_t function_297fc(void);
int32_t function_29868(void);
int32_t function_2986c(void);
int32_t function_29870(int32_t a1, int32_t a2);
int32_t function_29874(int32_t a1);
int32_t function_29878(int32_t a1);
int32_t function_2987c(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_29880(int32_t result);
int32_t function_29884(int32_t a1, int32_t a2, int32_t a3);
int32_t function_2988c(int32_t a1, int32_t a2, int32_t a3, uint32_t a4);
int32_t function_29898(int32_t a1, int32_t a2);
int32_t function_2989c(int32_t a1);
int32_t function_298a4(int32_t a1);
int32_t function_298a8(int32_t result);
int32_t function_298ac(int32_t a1, int32_t a2);
int32_t function_298b4(void);
int32_t function_298b8(int32_t result, int32_t a2);
int32_t function_298bc(int32_t a1);
int32_t function_298c4(int32_t a1);
int32_t function_298c8(int32_t result);
int32_t function_298cc(int32_t a1, int32_t a2);
int32_t function_298d4(void);
int32_t function_298d8(int32_t result, int32_t a2);
int32_t function_298dc(int32_t a1);
int32_t function_298e4(int32_t a1);
int32_t function_298e8(int32_t result);
int32_t function_298ec(int32_t a1, int32_t a2);
int32_t function_298f4(int32_t a1, int32_t a2);
int32_t function_298f8(int32_t result, int32_t a2);
int32_t function_298fc(int32_t a1);
int32_t function_29904(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_29908(int32_t result);
int32_t function_2990c(int32_t a1, int32_t a2);
int32_t function_29914(void);
int32_t function_29918(int32_t result, int32_t a2);
int32_t function_2991c(int32_t a1);
int32_t function_29924(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_29928(int32_t a1);
int32_t function_2992c(int32_t a1, int32_t a2);
int32_t function_29936(void);
int32_t function_29938(int32_t a1, int32_t a2);
int32_t function_29942(int32_t a1);
int32_t function_29944(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_29990(int32_t a1);
int32_t function_299a4(void);
int32_t function_299b4(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_299ca(void);
int32_t function_299cc(int32_t a1, int32_t a2, int32_t a3);
int32_t function_29a04(int32_t result, int32_t a2);
int32_t function_29a0c(int32_t a1, int32_t a2);
int32_t function_29a32(int32_t a1);
int32_t function_29a34(int32_t a1);
int32_t function_29a48(void);
int32_t function_29a60(void);
int32_t function_29aa0(void);
int32_t function_29aa4(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_29aa8(void);
int32_t function_29ab8(int32_t a1);
int32_t function_29ac0(void);
int32_t function_29ad0(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t function_29ad8(int32_t a1, int32_t a2, int32_t a3);
int32_t function_29b0e(void);
int32_t function_29b14(void);
int32_t function_29b1c(void);
int32_t function_29b2c(void);
int32_t function_29b42(void);
int32_t function_29b44(void);
int32_t function_29b64(void);
int32_t function_29b80(void);
int32_t function_29ba0(void);
int32_t function_29bc0(void);
int32_t function_29bd2(void);
int32_t function_29bd4(void);
int32_t function_29bd8(int32_t a1);
int32_t function_29bdc(int32_t a1);
int32_t function_29be2(void);
int32_t function_29be4(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_29be8(void);
int32_t function_29bec(void);
int32_t function_29bee(void);
int32_t function_29bf0(int32_t result);
int32_t function_29bf4(int32_t result);
int32_t function_29bfa(int16_t a1);
int32_t function_29bfc(void);
int32_t function_29c00(int32_t a1);
int32_t function_29c04(int32_t a1);
int32_t function_29c08(void);
int32_t function_29c0e(int32_t a1);
int32_t function_29c10(int32_t result, int32_t a2);
int32_t function_29c14(int32_t result);
int32_t function_29c18(void);
int32_t function_29c1c(void);
int32_t function_29c20(int32_t result, int32_t a2, int32_t a3, uint32_t a4, int32_t a5, int32_t a6);
int32_t function_29c6c(int32_t str);
int32_t function_29d68(void);
int32_t function_29dcc(void);
int32_t function_29dce(int32_t a1, int32_t a2);
int32_t function_29e70(void);
int32_t function_29e84(void);
int32_t function_29e86(int32_t a1);
int32_t function_29e8a(void);
int32_t function_29e8c(int32_t result);
int32_t function_29e92(void);
int32_t function_29e94(int32_t a1, int32_t a2);
int32_t function_29eaa(int32_t a1);
int32_t function_29eac(int32_t a1, int32_t a2);
int32_t function_29eb0(int32_t a1);
int32_t function_29eb4(int32_t a1);
int32_t function_29eba(void);
int32_t function_29ebc(void);
int32_t function_29ec8(void);
int32_t function_29eca(void);
int32_t function_29ecc(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t function_29ed4(void);
int32_t function_29ed8(int32_t a1, int32_t a2);
int32_t function_29edc(void);
int32_t function_29ee4(int32_t a1);
int32_t function_29eea(int32_t a1);
int32_t function_29eec(void);
int32_t function_29efa(int32_t a1);
int32_t function_29efe(void);
int32_t function_29f00(void);
int32_t function_29f0a(int32_t a1);
int32_t function_29f0e(int32_t a1);
int32_t function_29f10(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_29f1a(void);
int32_t function_29f1c(int32_t a1);
int32_t function_29f20(int32_t result);
int32_t function_29f26(void);
int32_t function_29f2a(void);
int32_t function_29f30(int32_t a1);
int32_t function_29f36(int32_t a1);
int32_t function_29f3a(void);
int32_t function_29f3e(int16_t a1);
int32_t function_29f40(void);
int32_t function_29f46(void);
int32_t function_29f4a(void);
int32_t function_29f4c(int32_t a1);
int32_t function_29f50(void);
int32_t function_29f54(void);
int32_t function_29f56(int32_t a1);
int32_t function_29f58(void);
int32_t function_29f60(void);
int32_t function_29f66(void);
int32_t function_29f68(void);
int32_t function_29f76(int32_t a1);
int32_t function_29f78(int32_t a1);
int32_t function_29f7c(int32_t result);
int32_t function_29f80(int32_t a1);
int32_t function_29f86(int32_t a1);
int32_t function_29f8c(int32_t a1);
int32_t function_29f90(int32_t result);
int32_t function_29f96(int32_t a1);
int32_t function_29f98(void);
int32_t function_29fa6(void);
int32_t function_29fa8(int32_t a1);
int32_t function_29fac(void);
int32_t function_29fb0(int32_t a1);
int32_t function_29fb6(int32_t a1);
int32_t function_29fb8(void);
int32_t function_29fc4(void);
int32_t function_29fc6(int32_t a1);
int32_t function_29fc8(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_29fcc(void);
int32_t function_29fce(void);
int32_t function_29fd0(int32_t a1);
int32_t function_29fd8(void);
int32_t function_29fdc(int32_t a1);
int32_t function_29fe0(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_29ff2(void);
int32_t function_29ff4(int32_t a1);
int32_t function_29ff8(int32_t a1);
int32_t function_29ffc(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2a024(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2a064(int32_t a1);
int32_t function_2a07c(int32_t * a1, int32_t a2, int32_t a3);
int32_t function_2a084(int32_t result, int32_t a2);
int32_t function_2a088(void);
int32_t function_2a08c(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2a090(int32_t a1, int32_t a2, int32_t a3);
int32_t function_2a094(void);
int32_t function_2a098(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_2a0a4(int32_t result);
int32_t function_2a0b0(void);
int32_t function_2a0b2(int32_t a1);
int32_t function_2a0b8(int32_t a1, int32_t a2);
int32_t function_2a0ba(void);
int32_t function_2a0c2(void);
int32_t function_2a0c4(void);
int32_t function_2a0c8(int32_t a1, int32_t a2);
int32_t function_2a0d0(int32_t result, int32_t a2, int32_t a3);
int32_t function_2a0d4(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2a0e0(int32_t a1);
int32_t function_2a0ec(int32_t a1);
int32_t function_2a0f0(int32_t a1);
int32_t function_2a0f6(int32_t a1);
int32_t function_2a0fc(void);
int32_t function_2a100(void);
int32_t function_2a104(void);
int32_t function_2a108(void);
int32_t function_2a10c(void);
int32_t function_2a110(int32_t result, int32_t a2, int32_t a3);
int32_t function_2a11e(void);
int32_t function_2a120(void);
int32_t function_2a13c(int32_t a1);
int32_t function_2a142(void);
int32_t function_2a144(int32_t a1);
int32_t function_2a150(void);
int32_t function_2a154(int32_t a1, int32_t a2);
int32_t function_2a158(void);
int32_t function_2a15c(int32_t a1);
int32_t function_2a162(int32_t a1);
int32_t function_2a164(void);
int32_t function_2a166(void);
int32_t function_2a168(int32_t a1);
int32_t function_2a16c(int32_t a1, int32_t a2);
int32_t function_2a170(void);
int32_t function_2a18c(int32_t a1, int32_t a2);
int32_t function_2a1ba(void);
int32_t function_2a1bc(int32_t a1);
int32_t function_2a1c0(int32_t a1);
int32_t function_2a1c6(void);
int32_t function_2a1c8(int32_t a1);
int32_t function_2a1cc(int32_t a1, int32_t a2, int32_t a3);
int32_t function_2a1d0(void);
int32_t function_2a1d4(int32_t a1);
int32_t function_2a1d8(void);
int32_t function_2a1dc(void);
int32_t function_2a1e0(void);
int32_t function_2a1e4(void);
int32_t function_2a1e8(void);
int32_t function_2a1ec(void);
int32_t function_2a1ee(void);
int32_t function_2a1f0(int32_t a1);
int32_t function_2a1f4(void);
int32_t function_2a1f6(void);
int32_t function_2a1f8(int32_t a1, int32_t a2);
int32_t function_2a222(void);
int32_t function_2a224(int32_t a1);
int32_t function_2a228(void);
int32_t function_2a22a(void);
int32_t function_2a22c(int32_t result);
int32_t function_2a230(void);
int32_t function_2a234(int32_t a1);
int32_t function_2a238(int32_t result, int32_t a2);
int32_t function_2a240(int32_t result, int32_t a2, int32_t a3);
int32_t function_2a244(void);
int32_t function_2a248(int32_t a1);
int32_t function_2a24e(void);
int32_t function_2a250(int32_t result);
int32_t function_2a254(int32_t result);
int32_t function_2a258(void);
int32_t function_2a25c(int32_t result);
int32_t function_2a264(int32_t result);
int32_t function_2a268(int32_t a1);
int32_t function_2a26c(void);
int32_t function_2a272(int32_t a1);
int32_t function_2a278(int32_t result, int32_t a2, int32_t a3);
int32_t function_2a27c(void);
int32_t function_2a280(void);
int32_t function_2a282(int16_t a1);
int32_t function_2a284(int32_t a1, int32_t a2);
int32_t function_2a28c(int32_t a1);
int32_t function_2a29a(int32_t a1);
int32_t function_2a29c(void);
int32_t function_2a2cc(int32_t a1);
int32_t function_2a2d0(int32_t a1, int32_t a2, int32_t a3);
int32_t function_2a2e0(void);
int32_t function_2a2e6(int32_t a1);
int32_t function_2a2e8(void);
int32_t function_2a2ea(void);
int32_t function_2a2ee(int32_t a1);
int32_t function_2a2f0(void);
int32_t function_2a2f2(void);
int32_t function_2a2f6(void);
int32_t function_2a2f8(void);
int32_t function_2a2fa(int32_t a1);
int32_t function_2a2fc(void);
int32_t function_2a310(int32_t a1);
int32_t function_2a314(int32_t result);
int32_t function_2a318(int32_t result, int32_t a2);
int32_t function_2a31c(void);
int32_t function_2a31e(void);
int32_t function_2a320(void);
int32_t function_2a324(int32_t a1, int32_t a2, int32_t a3);
int32_t function_2a336(void);
int32_t function_2a338(int32_t a1);
int32_t function_2a33c(void);
int32_t function_2a352(int32_t a1);
int32_t function_2a354(int32_t a1);
int32_t function_2a358(int32_t a1);
int32_t function_2a35c(int32_t result);
int32_t function_2a360(void);
int32_t function_2a364(int32_t a1);
int32_t function_2a36a(void);
int32_t function_2a36c(int32_t a1);
int32_t function_2a370(int32_t a1);
int32_t function_2a374(int32_t a1);
int32_t function_2a378(int32_t a1);
int32_t function_2a37c(int32_t size);
int32_t function_2a39a(void);
int32_t function_2a39c(int32_t a1);
int32_t function_2a3b8(int32_t result);
int32_t function_2a3ba(void);
int32_t function_2a3bc(void);
int32_t function_2a3c6(void);
int32_t function_2a3c8(void);
int32_t function_2a3cc(uint32_t a1);
int32_t function_2a3d4(void);
int32_t function_2a3d8(void);
int32_t function_2a3da(void);
int32_t function_2a3dc(void);
int32_t function_2a3e6(void);
int32_t function_2a3e8(int32_t a1);
int32_t function_2a3ec(void);
int32_t function_2a3f8(int32_t a1);
int32_t function_2a3fc(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t function_2a424(void);
int32_t function_2a440(void);
int32_t function_2a442(void);
int32_t function_2a444(void);
int32_t function_2a448(void);
int32_t function_2a44c(int32_t a1, int32_t a2);
int32_t function_2a452(void);
int32_t function_2a454(int32_t result);
int32_t function_2a458(int32_t a1);
int32_t function_2a45c(void);
int32_t function_2a460(void);
int32_t function_2a464(void);
int32_t function_2a466(void);
int32_t function_2a468(int32_t a1);
int32_t function_2a470(int32_t a1, int32_t a2);
int32_t function_2a474(void);
int32_t function_2a478(int32_t a1, int32_t a2);
int32_t function_2a47c(void);
int32_t function_2a480(void);
int32_t function_2a490(int32_t a1, int32_t a2);
int32_t function_2a494(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2a4ac(int32_t a1, int32_t a2);
int32_t function_2a4b4(void);
int32_t function_2a4b8(int32_t a1);
int32_t function_2a4bc(void);
int32_t function_2a4c0(int32_t result);
int32_t function_2a4c4(int32_t a1, int32_t a2);
int32_t function_2a4cc(int32_t result, int32_t a2, int32_t a3);
int32_t function_2a4d0(void);
int32_t function_2a4d6(void);
int32_t function_2a4d8(int32_t result);
int32_t function_2a4dc(void);
int32_t function_2a4e0(int32_t a1, int32_t a2, int32_t a3);
int32_t function_2a4e4(int32_t result, int32_t a2, int32_t a3);
int32_t function_2a4e8(void);
int32_t function_2a4ec(int32_t a1, int32_t a2, int32_t a3);
int32_t function_2a4f0(void);
int32_t function_2a4f4(void);
int32_t function_2a4f6(void);
int32_t function_2a4f8(void);
int32_t function_2a4fa(void);
int32_t function_2a4fc(void);
int32_t function_2a4fe(void);
int32_t function_2a500(int32_t a1);
int32_t function_2a504(void);
int32_t function_2a506(void);
int32_t function_2a508(void);
int32_t function_2a50c(int32_t a1, int32_t a2);
int32_t function_2a512(int32_t a1);
int32_t function_2a514(void);
int32_t function_2a518(int32_t a1, int32_t a2);
int32_t function_2a51c(int32_t a1, int32_t a2);
int32_t function_2a520(int32_t a1);
int32_t function_2a524(int32_t a1);
int32_t function_2a528(void);
int32_t function_2a52c(void);
int32_t function_2a530(int32_t a1);
int32_t function_2a534(int32_t a1);
int32_t function_2a53a(int32_t a1, int32_t a2);
int32_t function_2a53c(int32_t a1);
int32_t function_2a540(int32_t a1);
int32_t function_2a544(void);
int32_t function_2a548(int32_t a1);
int32_t function_2a54c(void);
int32_t function_2a550(int32_t a1);
int32_t function_2a554(int32_t a1);
int32_t function_2a558(int32_t a1);
int32_t function_2a55c(void);
int32_t function_2a560(int32_t a1);
int32_t function_2a566(void);
int32_t function_2a568(int32_t a1);
int32_t function_2a56c(int32_t a1);
int32_t function_2a570(int32_t result, int32_t a2);
int32_t function_2a574(void);
int32_t function_2a578(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2a57c(void);
int32_t function_2a582(int32_t a1, int32_t a2);
int32_t function_2a586(int32_t a1);
int32_t function_2a588(int32_t result);
int32_t function_2a58c(void);
int32_t function_2a58e(int32_t a1, int32_t a2);
int32_t function_2a594(int32_t a1);
int32_t function_2a598(int32_t a1);
int32_t function_2a59c(int32_t a1, int32_t a2, int32_t a3);
int32_t function_2a5a2(int32_t a1);
int32_t function_2a5a6(void);
int32_t function_2a5a8(void);
int32_t function_2a5ac(int32_t a1);
int32_t function_2a5b0(void);
int32_t function_2a5b2(void);
int32_t function_2a5b4(int32_t a1);
int32_t function_2a5ba(int32_t a1);
int32_t function_2a5bc(int32_t result, int32_t a2);
int32_t function_2a5c0(int32_t result, int32_t a2);
int32_t function_2a5c2(int32_t a1);
int32_t function_2a5c4(int32_t a1);
int32_t function_2a5c8(int32_t a1);
int32_t function_2a5cc(int32_t result, int32_t a2);
int32_t function_2a5d0(int32_t a1, int32_t a2);
int32_t function_2a5d4(int32_t a1, int32_t a2, int32_t a3);
int32_t function_2a5d6(int32_t a1, int32_t a2);
int32_t function_2a5d8(int32_t result, int32_t a2);
int32_t function_2a5de(int32_t a1);
int32_t function_2a5e0(void);
int32_t function_2a5e4(int32_t a1);
int32_t function_2a5e8(int32_t a1);
int32_t function_2a5ec(int32_t a1);
int32_t function_2a5f0(int32_t a1, int32_t a2);
int32_t function_2a5f4(void);
int32_t function_2a5f8(int32_t a1);
int32_t function_2a5fe(int32_t a1);
int32_t function_2a600(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2a604(int32_t a1, int32_t a2, int32_t a3);
int32_t function_2a608(int32_t a1);
int32_t function_2a60c(int32_t a1);
int32_t function_2a610(void);
int32_t function_2a612(int32_t a1);
int32_t function_2a614(void);
int32_t function_2a618(void);
int32_t function_2a618a(void);
int32_t function_2a61e(void);
int32_t function_2a622(void);
int32_t function_2a626(void);
int32_t function_2a62a(int32_t a1);
int32_t function_2a62c(int32_t a1, int32_t a2);
int32_t function_2a632(void);
int32_t function_2a6322(void);
int32_t function_2a636(int32_t a1);
int32_t function_2a638(int32_t a1, int32_t a2);
int32_t function_2a63e(int32_t a1);
int32_t function_2a640(int32_t a1);
int32_t function_2a644(int32_t a1);
int32_t function_2a648(int32_t a1);
int32_t function_2a652(int32_t a1, int32_t a2, int32_t a3);
int32_t function_2a664(int32_t result, int32_t a2);
int32_t function_2a668(int32_t result, int32_t a2);
int32_t function_2a66c(int32_t result);
int32_t function_2a66de(void);
int32_t function_2a670(int32_t a1);
int32_t function_2a674(void);
int32_t function_2a676(void);
int32_t function_2a678(int32_t a1);
int32_t function_2a67c(int32_t result, int32_t a2);
int32_t function_2a67e(void);
int32_t function_2a680(int32_t a1, int32_t a2, uint32_t a3, int32_t a4);
int32_t function_2a68c(int32_t a1);
int32_t function_2a68e(void);
int32_t function_2a692(void);
int32_t function_2a696(int32_t a1);
int32_t function_2a69e(void);
int32_t function_2a6a0(int32_t a1, int32_t a2, int32_t a3);
int32_t function_2a6a6(int32_t a1);
int32_t function_2a6a8(void);
int32_t function_2a6b6(void);
int32_t function_2a6b8(int32_t a1);
int32_t function_2a6bc(int32_t result, int32_t a2);
int32_t function_2a6c0(void);
int32_t function_2a6c4(int32_t a1);
int32_t function_2a6c8(void);
int32_t function_2a6cc(int32_t a1);
int32_t function_2a6d0(int32_t a1);
int32_t function_2a6d8(int32_t a1, int32_t a2, int32_t a3);
int32_t function_2a6e0(int32_t a1);
int32_t function_2a6e4(int32_t result, int32_t a2);
int32_t function_2a6e8(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2a6ec(int32_t a1, int32_t a2);
int32_t function_2a6f0(int32_t result);
int32_t function_2a6f4(int32_t a1);
int32_t function_2a6f8(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2a70a(void);
int32_t function_2a70e(int32_t a1);
int32_t function_2a710(void);
int32_t function_2a714(void);
int32_t function_2a716(int32_t a1);
int32_t function_2a71c(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2a720(void);
int32_t function_2a722(void);
int32_t function_2a724(int32_t a1);
int32_t function_2a728(void);
int32_t function_2a72c(int32_t result, int32_t a2);
int32_t function_2a730(int32_t a1, int32_t a2, int32_t a3);
int32_t function_2a734(int32_t result);
int32_t function_2a73a(void);
int32_t function_2a73e(int32_t a1);
int32_t function_2a740(int32_t result);
int32_t function_2a744(int32_t result);
int32_t function_2a748(int32_t a1, int32_t a2, int32_t a3, int32_t result);
int32_t function_2a74c(int32_t a1);
int32_t function_2a750(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_2a758(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2a774(void);
int32_t function_2a778(int32_t result, int32_t a2);
int32_t function_2a77c(int32_t a1);
int32_t function_2a780(int32_t result, int32_t a2);
int32_t function_2a784(int32_t result);
int32_t function_2a788(int32_t result, int32_t a2);
int32_t function_2a790(void);
int32_t function_2a7a2(void);
int32_t function_2a7a6(int32_t a1);
int32_t function_2a7a8(void);
int32_t function_2a7ac(int32_t a1);
int32_t function_2a7b2(int32_t a1);
int32_t function_2a7b4(void);
int32_t function_2a7b8(int32_t a1, int32_t a2, int32_t a3, int32_t result);
int32_t function_2a7be(void);
int32_t function_2a7c0(void);
int32_t function_2a7c4(int32_t a1);
int32_t function_2a7c8(int32_t a1);
int32_t function_2a7cc(int32_t a1);
int32_t function_2a7d0(void);
int32_t function_2a7d4(int32_t a1);
int32_t function_2a7d8(int32_t a1);
int32_t function_2a7de(int32_t a1);
int32_t function_2a7e0(int32_t a1, int32_t a2);
int32_t function_2a7e4(int32_t a1);
int32_t function_2a7e8(int32_t a1, int32_t a2);
int32_t function_2a7ec(void);
int32_t function_2a7f0(int32_t a1, int32_t a2);
int32_t function_2a7f4(void);
int32_t function_2a7fe(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2a804(void);
int32_t function_2a808(int32_t result, int32_t a2);
int32_t function_2a80c(int32_t a1);
int32_t function_2a810(int32_t result);
int32_t function_2a81c(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t function_2a824(void);
int32_t function_2a83e(void);
int32_t function_2a840(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2a844(int32_t result);
int32_t function_2a84a(int32_t a1);
int32_t function_2a850(void);
int32_t function_2a86a(void);
int32_t function_2a86c(void);
int32_t function_2a86e(void);
int32_t function_2a870(int32_t a1);
int32_t function_2a874(int32_t result, int32_t a2);
int32_t function_2a878(int32_t result, int32_t a2);
int32_t function_2a87c(int32_t a1, int32_t a2, int32_t a3);
int32_t function_2a880(int32_t result, int32_t a2);
int32_t function_2a884(int32_t result, int32_t a2);
int32_t function_2a888(int32_t a1, int32_t a2);
int32_t function_2a88c(int32_t a1, int32_t a2);
int32_t function_2a890(int32_t a1, int32_t a2);
int32_t function_2a894(void);
int32_t function_2a898(int32_t a1, int32_t a2);
int32_t function_2a89c(int32_t size, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2a8a6(int32_t a1);
int32_t function_2a8a8(void);
int32_t function_2a8e4(int32_t result);
int32_t function_2a8e8(void);
int32_t function_2a8ec(void);
int32_t function_2a8f2(int32_t a1);
int32_t function_2a8f4(int32_t a1);
int32_t function_2a8fc(int32_t a1);
int32_t function_2a902(void);
int32_t function_2a904(int32_t result, int32_t a2, int32_t a3);
int32_t function_2a908(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2a90c(void);
int32_t function_2a910(int32_t result);
int32_t function_2a914(int32_t a1);
int32_t function_2a916(int32_t a1);
int32_t function_2a918(int32_t n);
int32_t function_2a94e(void);
int32_t function_2a950(void);
int32_t function_2a954(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t function_2a95c(int32_t result);
int32_t function_2a96c(int32_t result);
int32_t function_2a970(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2a97e(int32_t a1);
int32_t function_2a982(int32_t result);
int32_t function_2a988(int32_t result, int32_t a2);
int32_t function_2a9a2(void);
int32_t function_2a9a4(void);
int32_t function_2a9a8(void);
int32_t function_2a9ac(int32_t result, int32_t a2);
int32_t function_2a9b0(int32_t a1, int32_t a2);
int32_t function_2a9b4(int32_t a1);
int32_t function_2a9b8(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2a9ce(void);
int32_t function_2a9d0(int32_t a1);
int32_t function_2a9d4(int32_t a1, int32_t a2, int32_t a3);
int32_t function_2a9da(void);
int32_t function_2a9de(int32_t a1);
int32_t function_2a9e0(int32_t a1, int32_t a2);
int32_t function_2a9ea(int32_t a1);
int32_t function_2a9ec(void);
int32_t function_2a9ee(void);
int32_t function_2a9f0(int32_t a1);
int32_t function_2a9f4(int32_t a1, int32_t a2);
int32_t function_2a9f8(void);
int32_t function_2a9fc(int32_t result);
int32_t function_2aa00(uint32_t a1);
int32_t function_2aa04(void);
int32_t function_2aa06(void);
int32_t function_2aa0a(int32_t a1);
int32_t function_2aa0c(int32_t a1);
int32_t function_2aa12(int32_t a1);
int32_t function_2aa14(int32_t a1, int32_t a2);
int32_t function_2aa18(void);
int32_t function_2aa1c(int32_t a1);
int32_t function_2aa20(void);
int32_t function_2aa22(void);
int32_t function_2aa24(void);
int32_t function_2aa28(int32_t a1);
int32_t function_2aa2c(int32_t a1);
int32_t function_2aa30(int32_t a1);
int32_t function_2aa34(int32_t a1, int32_t a2);
int32_t function_2aa38(void);
int32_t function_2aa3a(void);
int32_t function_2aa3c(void);
int32_t function_2aa3e(void);
int32_t function_2aa40(void);
int32_t function_2aa42(void);
int32_t function_2aa46(void);
int32_t function_2aa48(void);
int32_t function_2aa4c(void);
int32_t function_2aa50(void);
int32_t function_2aa54(void);
int32_t function_2aa56(void);
int32_t function_2aa58(int32_t a1, int32_t a2);
int32_t function_2aa5e(int32_t a1, int32_t a2, int32_t a3);
int32_t function_2aa62(int32_t result);
int32_t function_2aa66(void);
int32_t function_2aa6a(void);
int32_t function_2aa6e(void);
int32_t function_2aa7a(void);
int32_t function_2aa7c(int32_t a1, int32_t a2, int32_t a3);
int32_t function_2aa88(int32_t a1);
int32_t function_2aa8c(int32_t result, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_2aa9c(void);
int32_t function_2aa9e(void);
int32_t function_2aaa2(int32_t a1);
int32_t function_2aaa4(int32_t result, int32_t a2);
int32_t function_2aab0(int32_t a1, int32_t a2);
int32_t function_2aab4(int32_t a1, int32_t a2);
int32_t function_2aab8(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2aac0(int32_t a1, int32_t a2);
int32_t function_2aad6(void);
int32_t function_2aad8(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2aaf0(void);
int32_t function_2aaf2(int32_t a1);
int32_t function_2aaf4(int32_t a1);
int32_t function_2aaf8(void);
int32_t function_2aafc(int32_t a1, int32_t a2);
int32_t function_2ab00(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2ab0c(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_2ab14(void);
int32_t function_2ab18(int32_t a1);
int32_t function_2ab1e(void);
int32_t function_2ab20(int32_t a1);
int32_t function_2ab28(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2ab30(int32_t status, int32_t a2);
int32_t function_2abb0(void);
int32_t function_2ac0c(void);
int32_t function_2ac7c(void);
int32_t function_2ac84(int32_t a1);
int32_t function_2ac86(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2acb2(int32_t result);
int32_t function_2acb8(int32_t result);
int32_t function_2acbe(int32_t a1);
int32_t function_2acd6(void);
int32_t function_2acda(void);
int32_t function_2acdc(int32_t a1, int32_t result);
int32_t function_2ace0(int32_t result, int32_t a2);
int32_t function_2ace4(int32_t result);
int32_t function_2ace6(void);
int32_t function_2ace8(void);
int32_t function_2ad0c(int32_t a1);
int32_t function_2ad10(void);
int32_t function_2ad1a(void);
int32_t function_2ad1c(void);
int32_t function_2ad22(int32_t a1);
int32_t function_2ad24(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2ad3c(void);
int32_t function_2ad40(int32_t a1);
int32_t function_2ad44(void);
int32_t function_2ad4c(void);
int32_t function_2ad50(int32_t a1, int32_t a2, int32_t a3);
int32_t function_2ad58(void);
int32_t function_2ad5c(void);
int32_t function_2ad60(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2ad64(int32_t a1, int32_t a2);
int32_t function_2ad68(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2ad6c(int32_t a1);
int32_t function_2ad70(int32_t result, int32_t a2);
int32_t function_2ad7a(void);
int32_t function_2ad7c(void);
int32_t function_2ad96(int32_t a1);
int32_t function_2ad98(void);
int32_t function_2adbc(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_2adc8(int32_t result, int32_t a2);
int32_t function_2adcc(int32_t a1);
int32_t function_2add0(void);
int32_t function_2add4(int32_t a1);
int32_t function_2add8(int32_t a1);
int32_t function_2addc(int32_t a1);
int32_t function_2ade2(void);
int32_t function_2ade4(void);
int32_t function_2adfe(void);
int32_t function_2ae00(void);
int32_t function_2ae10(int32_t a1);
int32_t function_2ae24(int32_t a1);
int32_t function_2ae68(void);
int32_t function_2aea8(int32_t a1);
int32_t function_2b2b4(int32_t a1, int32_t a2);
int32_t function_2b310(int32_t * mutex, char * a2, int32_t a3);
int32_t function_2b338(int32_t a1, int32_t a2);
int32_t function_2b394(int32_t rwlock, char * a2, int32_t a3);
int32_t function_2b3bc(int32_t * mutex, char * a2, int32_t a3);
int32_t function_2b404(int32_t a1, int32_t a2);
int32_t function_2b460(int32_t a1, int32_t a2);
int32_t function_2b4892(void);
int32_t function_2b4bc(int32_t a1, int32_t a2);
int32_t function_2b518(int32_t a1, int32_t a2);
int32_t function_2b580(int32_t a1, int32_t a2);
int32_t function_2b5fc(int32_t a1, int32_t a2);
int32_t function_2b668(int32_t a1, int32_t a2);
int32_t function_2bccba(void);
int32_t function_2be48(void);
int32_t function_2beb0(int32_t a1, uint32_t a2);
int32_t function_2bfac(int32_t a1, int32_t a2);
int32_t function_2c008(int32_t * rwlock, char * a2, int32_t a3);
int32_t function_2c040(void);
int32_t function_2c0f0(int32_t a1);
int32_t function_2c214(void);
int32_t function_2c2ac(int32_t a1, int32_t a2);
int32_t function_2c2d4(int32_t a1);
int32_t function_2c320(int32_t a1, int32_t a2);
int32_t function_2c38c(int32_t a1, int32_t a2);
int32_t function_2c418(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_2c4c6(int32_t a1);
int32_t function_2c4e0(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_2c5c0(char * a1, int32_t a2);
int32_t function_2c61c(int32_t a1, int32_t a2);
int32_t function_2c6e8(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_2c7a4(int32_t a1, int32_t a2);
int32_t function_2c858(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_2c8f4(int32_t a1);
int32_t function_2c968(void);
int32_t function_2ca26(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2ca5a(uint32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2ca60(void);
int32_t function_2cb5c(int32_t a1);
int32_t function_2cb68(int32_t a1, int32_t a2, int32_t a3, uint32_t a4, int32_t a5);
int32_t function_2cdc2(int32_t a1);
int32_t function_2cdc4(void);
int32_t function_2cdd0(void);
int32_t function_2ce90(int32_t result);
int32_t function_2ce98(int32_t a1);
int32_t function_2ceb0(int32_t a1);
int32_t function_2d062(int32_t a1);
int32_t function_2d064(int32_t a1, int32_t a2, uint32_t a3, int32_t a4);
int32_t function_2d0a0(int32_t a1);
int32_t function_2d0a4(void);
int32_t function_2d0a8(void);
int32_t function_2d0f8(void);
int32_t function_2d134(void);
int32_t function_2d176(int32_t a1);
int32_t function_2d178(void);
int32_t function_2d1bc(void);
int32_t function_2d1e8(void);
int32_t function_2d22c(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2d26c(void);
int32_t function_2d278(void);
int32_t function_2d27c(int32_t a1);
int32_t function_2d280(void);
int32_t function_2d284(void);
int32_t function_2d288(int32_t a1, int32_t a2, int32_t a3);
int32_t function_2d28c(void);
int32_t function_2d292(int32_t a1);
int32_t function_2d294(int32_t a1, int32_t a2, uint32_t a3, int32_t a4);
int32_t function_2d2e4(void);
int32_t function_2d328(void);
int32_t function_2d36c(void);
int32_t function_2d3b0(void);
int32_t function_2d3e8(void);
int32_t function_2d3fc(void);
int32_t function_2d414(void);
int32_t function_2d446(int32_t a1);
int32_t function_2d448(uint32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, uint32_t a6);
int32_t function_2d480(int32_t a1);
int32_t function_2d488(int32_t a1);
int32_t function_2d4a0(void);
int32_t function_2d4b8(void);
int32_t function_2d4fc(void);
int32_t function_2d53c(int32_t format);
int32_t function_2d578(int32_t format);
int32_t function_2d59c(void);
int32_t function_2d5ac(void);
int32_t function_2d5cc(void);
int32_t function_2d60c(int32_t a1);
int32_t function_2d6e6(int32_t a1);
int32_t function_2d6e8(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_2d74c(int32_t a1);
int32_t function_2d754(int32_t result);
int32_t function_2d75a(void);
int32_t function_2d766(int32_t result);
int32_t function_2d770(int32_t a1, int32_t a2, int32_t a3);
int32_t function_2d7c8(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2d7ca(void);
int32_t function_2d7cc(int32_t result);
int32_t function_2d7d0(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11, int32_t a12);
int32_t function_2d838(void);
int32_t function_2d83c(void);
int32_t function_2d840(int32_t a1, int32_t a2, int32_t a3);
int32_t function_2d8e4(void);
int32_t function_2d8f0(void);
int32_t function_2d8fc(void);
int32_t function_2d908(void);
int32_t function_2d914(void);
int32_t function_2d920(void);
int32_t function_2d924(void);
int32_t function_2d928(void);
int32_t function_2d92c(void);
int32_t function_2d938(void);
int32_t function_2d944(void);
int32_t function_2d95c(void);
int32_t function_2d974(void);
int32_t function_2d998(void);
int32_t function_2d9b0(void);
int32_t function_2d9d8(int32_t a1, int32_t a2, int32_t * a3);
int32_t function_2d9ec(void);
int32_t function_2d9f0(void);
int32_t function_2d9f4(int32_t a1, int32_t a2, int32_t a3);
int32_t function_2da04(void);
int32_t function_2da1c(void);
int32_t function_2dab0(void);
int32_t function_2db24(void);
int32_t function_2db98(void);
int32_t function_2dbb4(void);
int32_t function_2dbc0(void);
int32_t function_2dbcc(int32_t a1, int32_t a2);
int32_t function_2dbe6(void);
int32_t function_2dbf4(void);
int32_t function_2dbf8(void);
int32_t function_2dc04(void);
int32_t function_2dc20(void);
int32_t function_2dc3c(void);
int32_t function_2dc58(void);
int32_t function_2dc74(void);
int32_t function_2dc90(void);
int32_t function_2dcac(void);
int32_t function_2dcc8(void);
int32_t function_2dcd4(void);
int32_t function_2dcdc(int32_t result, int32_t a2, int32_t a3);
int32_t function_2dcec(void);
int32_t function_2dd00(void);
int32_t function_2dd0c(void);
int32_t function_2dd18(void);
int32_t function_2dd24(int32_t a1);
int32_t function_2de48(void);
int32_t function_2de4c(void);
int32_t function_2dec2(int32_t a1);
int32_t function_2dec4(void);
int32_t function_2df30(int32_t a1, int32_t a2);
int32_t function_2df34(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_2df50(int32_t a1, int32_t a2);
int32_t function_2df70(void);
int32_t function_2df8c(int32_t a1);
int32_t function_2dffc(void);
int32_t function_2e000(void);
int32_t function_2e014(void);
int32_t function_2e076(int32_t a1);
int32_t function_2e078(int32_t a1);
int32_t function_2e07c(int32_t result, int32_t a2, int32_t a3);
int32_t function_2e0cc(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2e0dc(void);
int32_t function_2e276(void);
int32_t function_2e27a(uint32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2e2a0(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t function_2e2c4(void);
int32_t function_2e300(void);
int32_t function_2e318(void);
int32_t function_2e330(void);
int32_t function_2e348(void);
int32_t function_2e354(void);
int32_t function_2e36c(void);
int32_t function_2e3be(void);
int32_t function_2e3d0(int32_t a1, int32_t a2, uint32_t a3);
int32_t function_2e3e8(void);
int32_t function_2e404(void);
int32_t function_2e40e(void);
int32_t function_2e410(int32_t a1);
int32_t function_2e416(int32_t result);
int32_t function_2e41c(void);
int32_t function_2e448(int32_t result, int32_t a2);
int32_t function_2e44c(void);
int32_t function_2e45c(int32_t a1, int32_t a2, int32_t a3);
int32_t function_2e464(void);
int32_t function_2e47c(void);
int32_t function_2e528(int32_t result);
int32_t function_2e52c(void);
int32_t function_2e530(int32_t result, int32_t a2);
int32_t function_2e534(int32_t a1);
int32_t function_2e53a(void);
int32_t function_2e53c(void);
int32_t function_2e546(int32_t a1);
int32_t function_2e54c(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t function_2e614(void);
int32_t function_2e62ea(void);
int32_t function_2e6bc(void);
int32_t function_2e6c0(int32_t a1);
int32_t function_2e7f8(int32_t a1);
int32_t function_2e888(int32_t a1);
int32_t function_2e8ac(int32_t a1);
int32_t function_2e91a(void);
int32_t function_2e91c(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t function_2e940(void);
int32_t function_2eb8c(void);
int32_t function_2ebba(void);
int32_t function_2ebbc(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2ec5c(int32_t a1, int32_t a2, int32_t a3);
int32_t function_2ec6c(void);
int32_t function_2ec78(int32_t a1);
int32_t function_2ecf4(void);
int32_t function_2ed40(int32_t a1);
int32_t function_2ee2c(int32_t a1);
int32_t function_2ef2fe(void);
int32_t function_2ef5c(int32_t a1);
int32_t function_2efd8(void);
int32_t function_2f0b8(int32_t a1);
int32_t function_2f228(int32_t a1);
int32_t function_2f23e(uint32_t a1);
int32_t function_2f244(int32_t a1, int32_t a2, int32_t a3, uint32_t a4, int32_t a5);
int32_t function_2f62c(int32_t a1);
int32_t function_2f7b4(int32_t a1, int32_t a2);
int32_t function_2f846(int32_t a1);
int32_t function_2f848(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_2f8ac(void);
int32_t function_2f8c4(void);
int32_t function_2f948(int32_t a1);
int32_t function_2f96e(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2f9e8(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_2fbe4(int32_t a1);
int32_t function_2fc18(int32_t a1, int32_t a2);
int32_t function_2fc4e(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2fcb92(void);
int32_t function_2fce4(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_2fce9e(void);
int32_t function_2fd492(void);
int32_t function_2fd79e(void);
int32_t function_2fe44(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2feca(int32_t a1);
int32_t function_2fed0(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2fee4(void);
int32_t function_2ff18(int32_t a1, int32_t a2, int32_t a3);
int32_t function_2ff24(int32_t a1, int32_t a2, int32_t a3);
int32_t function_2ff3c(int32_t a1);
int32_t function_30264(int32_t a1);
int32_t function_306e8(int32_t a1);
int32_t function_30818(void);
int32_t function_31024(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_313ac(void);
int32_t function_313c0(int32_t a1);
int32_t function_31858(int32_t a1);
int32_t function_31ae8(int32_t * a1, int32_t a2);
int32_t function_31d90(int32_t a1, int32_t a2);
int32_t function_32370(int32_t a1, int32_t a2, int32_t a3, int32_t a4, uint64_t a5);
int32_t function_324cc(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_329b4(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11);
int32_t function_32d00(int32_t a1, int32_t a2, int32_t a3);
int32_t function_32d28(int32_t a1);
int32_t function_32da8(int32_t a1);
int32_t function_32e14(void);
int32_t function_33128(void);
int32_t function_3315c(void);
int32_t function_332cc(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11, int32_t a12, int32_t a13, int32_t a14, int32_t a15, int32_t a16, int32_t a17, int32_t a18, int32_t a19, int32_t a20, int32_t a21, int32_t a22, int32_t a23, int32_t a24, int32_t a25, int32_t a26, int32_t a27, int32_t a28, int32_t a29, int32_t a30, int32_t a31, int32_t a32);
int32_t function_344a4c(void);
int32_t function_344a54(void);
int32_t function_34f94a(void);
int32_t function_35436e(void);
int32_t function_3636ca(void);
int32_t function_36399a(void);
int32_t function_36458(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_37471a(void);
int32_t function_37c8f2(void);
int32_t function_37db0(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_3958b2(void);
int32_t function_39848(int32_t a1);
int32_t function_3a014(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_3a768(int32_t a1, int32_t a2);
int32_t function_3a854(int32_t result, int32_t a2, int32_t a3);
int32_t function_3a8e8(int32_t a1);
int32_t function_3a910(int32_t a1, int32_t a2, int32_t a3);
int32_t function_3a940(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_3aadc(int32_t a1);
int32_t function_3aae8(int32_t thread_func_arg, int32_t a2, int32_t a3, int32_t str, int32_t str2);
int32_t function_3abdc(int32_t result);
int32_t function_3ad22(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_3ad36(int32_t a1);
int32_t function_3ad40(int32_t result, int32_t a2, int32_t a3, uint32_t a4);
int32_t function_3ae24(int32_t a1);
int32_t function_3af10(int32_t a1);
int32_t function_3b91c(int32_t a1);
int32_t function_3b980(void);
int32_t function_3ba90(void);
int32_t function_3c280(void);
int32_t function_3c5a0(void);
int32_t function_3cc8c(char * str2, int32_t str);
int32_t function_3ccc8(int32_t a1);
int32_t function_3ccd8(int32_t a1);
int32_t function_3cce8(int32_t a1);
int32_t function_3ccf8(int32_t a1, int32_t a2);
int32_t function_3cd8c(int32_t a1, int32_t a2);
int32_t function_3cdac(int32_t a1, int32_t * a2);
int32_t function_3cdb8(int32_t str, int32_t a2);
int32_t function_3ce40(int32_t str, int32_t * a2);
int32_t function_3cec8(int32_t a1, int32_t a2);
int32_t function_3cef0(int32_t a1, int32_t a2);
int32_t function_3cf40(int32_t a1, int32_t a2);
int32_t function_3cf90(int32_t a1);
int32_t function_3cfa8(void);
int32_t function_3cfc8(int32_t a1);
int32_t function_3d008(void);
int32_t function_3d02c(void);
int32_t function_3d050(int32_t a1, int32_t a2);
int32_t function_3d0b0(int32_t str, int32_t a2);
int32_t function_3d0c4(void);
int32_t function_3d0c6(int32_t a1);
int32_t function_3d0d0(void);
int32_t function_3d0d4(void);
int32_t function_3d0d8(int32_t a1, int32_t a2, int32_t a3);
int32_t function_3d0de(void);
int32_t function_3d0e4(void);
int32_t function_3d0ee(void);
int32_t function_3d0f0(int32_t str, int32_t a2);
int32_t function_3d104(int32_t str, int32_t a2);
int32_t function_3d118(int32_t str, int32_t a2);
int32_t function_3d12c(int32_t a1, int32_t a2);
int32_t function_3d1cc(int32_t a1, int32_t a2);
int32_t function_3d214(int32_t a1, uint32_t a2, int32_t a3);
int32_t function_3d2cc(int32_t * a1);
int32_t function_3d440(int32_t * a1);
int32_t function_3d4a4(int32_t * a1, int32_t * a2);
int32_t function_3d4fc(int32_t a1, int32_t a2, int32_t * a3);
int32_t function_3d554(int32_t * a1);
int32_t function_3d5b4(int32_t a1, int32_t a2);
int32_t function_3d614(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t function_3d658(char (**a1)[15], char * a2);
int32_t function_3d72c(int32_t * a1, int32_t a2, int32_t a3);
int32_t function_3d788(void);
int32_t function_3d7a8(int32_t format, int32_t a2, int32_t a3, int32_t a4);
int32_t function_3d7f0(int32_t format, int32_t a2, int32_t a3, int32_t a4);
int32_t function_3d81e(void);
int32_t function_3d820(void);
int32_t function_3d830(int32_t a1);
int32_t function_3d860(int32_t a1, int32_t a2, int32_t a3);
int32_t function_3d898(int32_t a1, int32_t a2, int32_t * a3, int32_t a4);
int32_t function_3e18c(int32_t result3, char a2, int32_t a3);
int32_t function_3e2a0(int32_t a1, uint32_t a2, int32_t * a3);
int32_t function_3e3b0(int32_t a1, int32_t a2, int32_t str, uint32_t a4);
int32_t function_3e9c4(int32_t a1);
int32_t function_3e9f0(int32_t a1, int32_t a2);
int32_t function_3ebab2(void);
int32_t function_3ec74(int32_t a1);
int32_t function_3ece4(int32_t a1);
int32_t function_3ecf0(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11, int32_t a12, int32_t a13, int32_t a14);
int32_t function_40c38(int32_t a1, int32_t a2);
int32_t function_40cec(int32_t * a1, int32_t a2);
int32_t function_40da8(int32_t a1, int32_t a2);
int32_t function_40e70(int32_t * a1, int32_t a2);
int32_t function_40f44(char * a1, int32_t a2);
int32_t function_41008(void);
int32_t function_41278(int32_t a1);
int32_t function_41474(void);
int32_t function_41570(void);
int32_t function_415b8(void);
int32_t function_41700(char * a1, int32_t a2);
int32_t function_41758(int32_t a1, int32_t a2);
int32_t function_41764(char * a1, int32_t a2);
int32_t function_417bc(int32_t a1, int32_t a2);
int32_t function_417c8(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11);
int32_t function_41f00(void);
int32_t function_41f18(void);
int32_t function_41f28(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_41f30(uint32_t a1);
int32_t function_41f98(void);
int32_t function_42328(int32_t a1, int32_t * a2);
int32_t function_4253c(int32_t a1);
int32_t function_42540(int32_t result);
int32_t function_42544(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t function_42554(void);
int32_t function_425c4(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t function_42638(void);
int32_t function_42688(void);
int32_t function_4268c(void);
int32_t function_426dc(void);
int32_t function_426e0(void);
int32_t function_42730(void);
int32_t function_42734(void);
int32_t function_42784(void);
int32_t function_4278c(int32_t a1);
int32_t function_42980(int32_t a1);
int32_t function_42cb4(int32_t a1);
int32_t function_42f3c(int32_t * a1, int32_t a2);
int32_t function_43190(int32_t a1);
int32_t function_43438(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_43450(char * a1, int32_t buf, int32_t length, int32_t * a4);
int32_t function_4359c(void);
int32_t function_435a4(int32_t a1, int32_t a2, int32_t a3);
int32_t function_435b8(int32_t a1, int32_t a2, uint32_t a3);
int32_t function_435fc(int32_t data, int32_t size, int32_t stream);
int32_t function_43618(int32_t buf, int32_t nbyte, int32_t fd);
int32_t function_43640(int32_t str, int32_t str2);
int32_t function_4364c(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_438d4(uint32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_43984(int32_t a1, int32_t a2, int32_t * str);
int32_t function_439dc(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_441ec(int32_t a1, int32_t a2, int32_t * a3, int32_t a4);
int32_t function_44264(int32_t a1, int32_t a2);
int32_t function_442d0(int32_t a1, int32_t a2, int32_t a3);
int32_t function_4430c(int32_t a1, int32_t a2, int32_t a3);
int32_t function_44320(int32_t a1, int32_t a2, int32_t a3);
int32_t function_44384(int32_t a1, int32_t a2, int32_t a3);
int32_t function_443b0(int32_t a1, int32_t a2, int32_t a3);
int32_t function_448f4(int32_t a1, int32_t a2, int32_t str, int32_t a4);
int32_t function_44968(int32_t result);
int32_t function_449d8(int32_t * a1);
int32_t function_44a54(int32_t * a1);
int32_t function_44a6c(uint32_t a1, int32_t a2, int32_t a3);
int32_t function_44d00(int32_t a1, int32_t str);
int32_t function_44d60(int32_t a1, int32_t * str);
int32_t function_44e80(int32_t a1);
int32_t function_44edc(int32_t a1);
int32_t function_44ef4(int32_t a1, int32_t str);
int32_t function_44f54(int32_t a1, int32_t a2);
int32_t function_44f6c(int32_t a1);
int32_t function_44f74(int32_t a1);
int32_t function_44f7c(int32_t a1, int32_t a2);
int32_t function_44fe8(int32_t result);
int32_t function_450e4(int32_t a1);
int32_t function_45108(int32_t a1);
int32_t function_4512c(int32_t a1);
int32_t function_45188(int32_t a1, int32_t a2, int32_t a3, char * format);
int32_t function_452b8(int32_t * a1);
int32_t function_452f8(int32_t fd);
int32_t function_45324(int32_t a1);
int32_t function_453b8(int32_t result, int32_t a2);
int32_t function_45474(int32_t a1);
int32_t function_455fc(int32_t a1);
int32_t function_4563c(int32_t result, int32_t result2);
int32_t function_45688(int32_t a1, int32_t a2);
int32_t function_458eca(void);
int32_t function_45b3f6(void);
int32_t function_45ea0(int32_t a1, uint32_t a2, int32_t a3);
int32_t function_4622de(void);
int32_t function_4624c6(void);
int32_t function_46259e(void);
int32_t function_46344(int32_t * a1, int32_t a2, int32_t a3);
int32_t function_46448(int32_t * a1, int32_t a2, int32_t * a3);
int32_t function_46510(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_465e4(int32_t a1, int32_t a2, int32_t a3);
int32_t function_466c4(int32_t a1, int32_t a2, int32_t a3);
int32_t function_467a0(int32_t a1, int32_t a2, int32_t * a3);
int32_t function_46858(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_4693c(int32_t size);
int32_t function_46954(int32_t a1);
int32_t function_4696c(int32_t a1, int32_t a2);
int32_t function_469b8(int32_t str);
int32_t function_469d4(int32_t result, int32_t a2);
int32_t function_469e4(int32_t result, int32_t a2);
int32_t function_46a10(int32_t * a1);
int32_t function_46a44(int32_t * a1);
int32_t function_46a70(int32_t result);
int32_t function_46a84(int32_t * a1);
int32_t function_46a8c(int32_t result);
int32_t function_46a9be(void);
int32_t function_46aa0(int32_t a1, int32_t a2, uint32_t a3);
int32_t function_46b6c(int32_t a1, int32_t a2);
int32_t function_46b90(int32_t a1);
int32_t function_46bb8(int32_t a1, int32_t * a2, int32_t a3, int32_t a4);
int32_t function_46ca8(int32_t * str, uint32_t size, int32_t a3);
int32_t function_46de8(int32_t a1, int32_t a2, int32_t * a3);
int32_t function_46e1d6(void);
int32_t function_46ed4(int32_t a1);
int32_t function_46f40(uint32_t a1, int32_t a2, int32_t a3);
int32_t function_46fea6(void);
int32_t function_47028(uint32_t result, uint32_t a2, int32_t * a3);
int32_t function_470a4(int32_t a1, uint32_t a2);
int32_t function_47120(int32_t a1);
int32_t function_47170(int32_t a1, int32_t a2, int32_t a3);
int32_t function_471fc(int32_t a1, int32_t a2, int32_t a3);
int32_t function_47268(void);
int32_t function_472d0(int32_t a1);
int32_t function_472ec(int32_t a1, char * a2);
int32_t function_47314(int32_t a1, int32_t a2);
int32_t function_474f4(int32_t a1, int32_t a2);
int32_t function_4751c(int32_t a1);
int32_t function_47554(int32_t a1);
int32_t function_47578(int32_t a1, int32_t a2);
int32_t function_475a0(int32_t a1, int32_t a2);
int32_t function_475d4(int32_t a1);
int32_t function_475e0(int32_t a1);
int32_t function_475ec(int32_t a1);
int32_t function_475f8(void);
int32_t function_47658(int32_t a1);
int32_t function_47674(int32_t a1, uint32_t a2);
int32_t function_476a8(int32_t a1, int32_t a2);
int32_t function_47780(int32_t str);
int32_t function_477a8(void);
int32_t function_477b0(int32_t a1, int32_t a2);
int32_t function_477b8(int32_t a1, int32_t a2);
int32_t function_477fc(int32_t * str);
int32_t function_47820(int32_t a1);
int32_t function_4783c(int32_t a1);
int32_t function_47858(int32_t a1, int32_t a2, int32_t a3);
int32_t function_478bc(int32_t a1, int32_t str);
int32_t function_478f0(int32_t a1, int32_t a2, int32_t a3);
int32_t function_47934(int32_t a1, int32_t str);
int32_t function_47968(int32_t a1, int32_t * a2);
int32_t function_47a18(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_47a48(int32_t a1, int32_t a2);
int32_t function_47a7c(int32_t a1);
int32_t function_47aa4(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_47acc(void);
int32_t function_47ace(int32_t a1, int32_t a2, int32_t a3, uint32_t a4);
int32_t function_47b1a(void);
int32_t function_47b1c(void);
int32_t function_47b28(int32_t result);
int32_t function_47b4c(void);
int32_t function_47b54(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_47bac(void);
int32_t function_47bb8(int32_t result2);
int32_t function_47c00(void);
int32_t function_47c0c(void);
int32_t function_47c18(void);
int32_t function_47c24(int32_t result);
int32_t function_47cf0(int32_t a1);
int32_t function_47d80(int32_t a1);
int32_t function_47d92(int32_t a1);
int32_t function_47d94(void);
int32_t function_47d98(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_47de8(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_47e18(int32_t a1, uint32_t a2);
int32_t function_47ee4(int32_t a1, int32_t a2, int32_t a3);
int32_t function_47fa0(int32_t a1, int32_t a2);
int32_t function_4808c(int32_t a1, char * str, int32_t a3);
int32_t function_48097a(void);
int32_t function_480f52(void);
int32_t function_48120(int32_t a1, int32_t a2);
int32_t function_48200(int32_t a1, int32_t a2);
int32_t function_48254(void);
int32_t function_4825e(int32_t a1);
int32_t function_48264(int32_t a1, int32_t a2, int32_t a3);
int32_t function_482b8(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t function_482e8(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t function_482f0(int32_t a1, uint32_t a2, int32_t a3);
int32_t function_4843c(int32_t a1);
int32_t function_48440(int32_t a1, uint32_t a2, int32_t a3);
int32_t function_484c44(void);
int32_t function_4854c(int32_t a1, int32_t a2);
int32_t function_48628(int32_t a1, int32_t a2);
int32_t function_48640(int32_t a1);
int32_t function_487fc(int32_t a1);
int32_t function_48960(int32_t a1, int32_t a2);
int32_t function_489c4(int32_t result, char * a2);
int32_t function_48a04(int32_t result, int32_t a2);
int32_t function_48a14(int32_t result, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t format);
int32_t function_48a78(int32_t result, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t format, int32_t a7);
int32_t function_48ac8(void);
int32_t function_48acc(void);
int32_t function_48ace(uint32_t result, uint32_t a2, int32_t a3);
int32_t function_48d24(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_48d34(int32_t result, int32_t a2, int32_t a3);
int32_t function_48d40(void);
int32_t function_48d42(int32_t a1, int32_t a2);
int32_t function_48fd4(int32_t result, int32_t a2);
int32_t function_48ff0(int32_t a1, int32_t a2);
int32_t function_49000(void);
int32_t function_49004(void);
int32_t function_49008(void);
int32_t function_49014(void);
int32_t function_49018(void);
int32_t function_4901c(void);
int32_t function_49020(int32_t a1, uint32_t a2, int32_t a3, uint32_t a4, int32_t a5, int32_t a6);
int32_t function_49274(int32_t a1);
int32_t function_49294(int32_t a1);
int32_t function_492b8(void);
int32_t function_492bc(void);
int32_t function_492c0(void);
int32_t function_492c4(int32_t a1, int32_t a2, uint32_t a3);
int32_t function_492fc(int64_t a1, int64_t a2);
int32_t function_49304(void);
int32_t function_4930c(int32_t a1, int32_t a2);
int32_t function_49314(int32_t a1, uint32_t a2);
int32_t function_49322(int32_t a1, uint32_t a2);
int32_t function_49368(int32_t result, int32_t a2);
int32_t function_49380(void);
int32_t function_49398(int32_t a1, int32_t a2);
int32_t function_493a4(void);
int32_t function_493b0(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_493c8(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_49410(uint32_t a1, int32_t a2, uint32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11, int32_t a12);
int32_t function_49520(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_4955c(void);
int32_t function_49560(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_4a120(void);
int32_t function_4d1f8a(void);
int32_t function_4f4a6e(void);
int32_t function_4f4aae(void);
int32_t function_4f56f6(void);
int32_t function_4f574e(void);
int32_t function_51ea2(void);
int32_t function_5529de(void);
int32_t function_553ee(void);
int32_t function_5552fe(void);
int32_t function_55e4a(void);
int32_t function_55e4e(void);
int32_t function_5694b6(void);
int32_t function_56f07e(void);
int32_t function_57272a(void);
int32_t function_574156(void);
int32_t function_57418a(void);
int32_t function_58c56(void);
int32_t function_5a5496(void);
int32_t function_5a54be(void);
int32_t function_5b33e(void);
int32_t function_5c9d2(void);
int32_t function_5d29e2(void);
int32_t function_5e2bd6(void);
int32_t function_5e2bea(void);
int32_t function_5e48f6(void);
int32_t function_5e490a(void);
int32_t function_5e54e6(void);
int32_t function_5e63a(void);
int32_t function_5e6542(void);
int32_t function_5eaffa(void);
int32_t function_5eb00e(void);
int32_t function_5eb31a(void);
int32_t function_6044d8(void);
int32_t function_60f46(void);
int32_t function_612a16(void);
int32_t function_612a4a(void);
int32_t function_612a7e(void);
int32_t function_612ab2(void);
int32_t function_612bf6(void);
int32_t function_612c4e(void);
int32_t function_613abe(void);
int32_t function_613b02(void);
int32_t function_613b46(void);
int32_t function_61401e(void);
int32_t function_614106(void);
int32_t function_614b86(void);
int32_t function_614baa(void);
int32_t function_614c16(void);
int32_t function_614c26(void);
int32_t function_614ca6(void);
int32_t function_614e2e(void);
int32_t function_614e7e(void);
int32_t function_6156ca(void);
int32_t function_615712(void);
int32_t function_61575a(void);
int32_t function_615986(void);
int32_t function_6159ba(void);
int32_t function_6159ee(void);
int32_t function_615a22(void);
int32_t function_615ac2(void);
int32_t function_615b56(void);
int32_t function_615b6a(void);
int32_t function_615b9e(void);
int32_t function_615bc2(void);
int32_t function_615be6(void);
int32_t function_615d12(void);
int32_t function_615d1a(void);
int32_t function_615d2a(void);
int32_t function_615e4e(void);
int32_t function_615ea6(void);
int32_t function_615eda(void);
int32_t function_615f2a(void);
int32_t function_615f5e(void);
int32_t function_616006(void);
int32_t function_616056(void);
int32_t function_6160ae(void);
int32_t function_6161a6(void);
int32_t function_616a72(void);
int32_t function_616ab6(void);
int32_t function_616f8e(void);
int32_t function_617076(void);
int32_t function_617af6(void);
int32_t function_617b36(void);
int32_t function_617b86(void);
int32_t function_617c16(void);
int32_t function_617c9a(void);
int32_t function_617d86(void);
int32_t function_617d9e(void);
int32_t function_617dee(void);
int32_t function_61863a(void);
int32_t function_618682(void);
int32_t function_6186ca(void);
int32_t function_618c82(void);
int32_t function_618c9a(void);
int32_t function_618dbe(void);
int32_t function_618e4a(void);
int32_t function_618e9a(void);
int32_t function_618ece(void);
int32_t function_618f76(void);
int32_t function_618fce(void);
int32_t function_619026(void);
int32_t function_619116(void);
int32_t function_624cd2(void);
int32_t function_6256a2(void);
int32_t function_6256ca(void);
int32_t function_6256f2(void);
int32_t function_625ade(void);
int32_t function_625d7e(void);
int32_t function_626566(void);
int32_t function_627a8a(void);
int32_t function_627a9e(void);
int32_t function_62948e(void);
int32_t function_62b232(void);
int32_t function_62b56a(void);
int32_t function_62b58a(void);
int32_t function_62b5aa(void);
int32_t function_62e1a2(void);
int32_t function_62e486(void);
int32_t function_62e4a6(void);
int32_t function_62ee76(void);
int32_t function_62ee9e(void);
int32_t function_62f21e(void);
int32_t function_62f29e(void);
int32_t function_62f2c6(void);
int32_t function_62f2ee(void);
int32_t function_631d8e(void);
int32_t function_639aa(void);
int32_t function_63d10a(void);
int32_t function_63d152(void);
int32_t function_63d19a(void);
int32_t function_63d1e2(void);
int32_t function_63d312(void);
int32_t function_63d3fe(void);
int32_t function_63d442(void);
int32_t function_63d61e(void);
int32_t function_64007a(void);
int32_t function_6400c2(void);
int32_t function_64010a(void);
int32_t function_640152(void);
int32_t function_64028a(void);
int32_t function_6403b2(void);
int32_t function_640596(void);
int32_t function_6428a(void);
int32_t function_6429a(void);
int32_t function_643d2(void);
int32_t function_643da(void);
int32_t function_643ea(void);
int32_t function_6444b0(void);
int32_t function_64b86(void);
int32_t function_65476(void);
int32_t function_655f2(void);
int32_t function_66568a(void);
int32_t function_6a201a(void);
int32_t function_6ba66(void);
int32_t function_6bf3e(void);
int32_t function_6c722(void);
int32_t function_6d329e(void);
int32_t function_6e19a(void);
int32_t function_6e7a76(void);
int32_t function_6ee26(void);
int32_t function_6f0ea(void);
int32_t function_6f14a(void);
int32_t function_6f33a(void);
int32_t function_6f3f6(void);
int32_t function_6f576(void);
int32_t function_6fb02(void);
int32_t function_72166(void);
int32_t function_7271e(void);
int32_t function_740b8(void);
int32_t function_74932(void);
int32_t function_74d3e(void);
int32_t function_759c6(void);
int32_t function_75cde(void);
int32_t function_76c24a(void);
int32_t function_76fbda(void);
int32_t function_78bc2(void);
int32_t function_798e96(void);
int32_t function_7b092(void);
int32_t function_7fad2(void);
int32_t function_851f76(void);
int32_t function_8553da(void);
int32_t function_96c55e(void);
int32_t function_9e9d92(void);
int32_t function_a2bf7e(void);
int32_t function_b11a5e(void);
int32_t function_c25d6a(void);
int32_t function_c51fce(void);
int32_t function_c98e46(void);
int32_t function_ce5d56(void);
int32_t function_cf4d2a(void);
int32_t function_cf59b2(void);
int32_t function_d11a3e(void);
int32_t function_d3442(void);
int32_t function_d4afe(void);
int32_t function_d57dd2(void);
int32_t function_d5b5a(void);
int32_t function_d74406(void);
int32_t function_dfb2e(void);
int32_t function_dfcf2(void);
int32_t function_dff66(void);
int32_t function_e1580a(void);
int32_t function_e1a01fc0(void);
int32_t function_e2462(void);
int32_t function_e4462(void);
int32_t function_e4b52(void);
int32_t function_e666ae(void);
int32_t function_e666c6(void);
int32_t function_e6808a(void);
int32_t function_e6809e(void);
int32_t function_e68876(void);
int32_t function_e6e4c6(void);
int32_t function_e7ac2(void);
int32_t function_ec5b2(void);
int32_t function_ec736(void);
int32_t function_ecbae(void);
int32_t function_ee2f86(void);
int32_t function_ef156(void);
int32_t function_f0b26(void);
int32_t function_f11a1e(void);
int32_t function_f22ae(void);
int32_t function_f2b3e(void);
int32_t function_f88ea(void);
int32_t function_fa3a2(void);
int32_t function_fb4fa(void);
int32_t function_fe0e4f4a(void);
int32_t function_fe0e863e(void);
int32_t function_fe264f22(void);
int32_t function_fe268616(void);
int32_t function_fe2ae1d2(void);
int32_t function_fe2e9066(void);
int32_t function_fe3161d2(void);
int32_t function_fe36c5f2(void);
int32_t function_fe3e5472(void);
int32_t function_fe41bd7a(void);
int32_t function_fe42c8c2(void);
int32_t function_fe45c5fe(void);
int32_t function_fe462faa(void);
int32_t function_fe46eec6(void);
int32_t function_fe46ef42(void);
int32_t function_fe46f256(void);
int32_t function_fe46f5e2(void);
int32_t function_fe47d53e(void);
int32_t function_fe484c50(void);
int32_t function_fe4e79d2(void);
int32_t function_fe4eb57a(void);
int32_t function_fe54a518(void);
int32_t function_fe562512(void);
int32_t function_fe56256a(void);
int32_t function_fe563882(void);
int32_t function_fe5638da(void);
int32_t function_fe56aaaa(void);
int32_t function_fe66e18e(void);
int32_t function_fe6af176(void);
int32_t function_fe6d9c8c(void);
int32_t function_fe6d9c98(void);
int32_t function_fe72e17a(void);
int32_t function_fe798c96(void);
int32_t function_fe8d5862(void);
int32_t function_fe918c7e(void);
int32_t function_fe96f636(void);
int32_t function_fe995a52(void);
int32_t function_feaef326(void);
int32_t function_feb2c56a(void);
int32_t function_feb60f2a(void);
int32_t function_febd2b5e(void);
int32_t function_fec2f5fa(void);
int32_t function_feed9022(void);
int32_t function_ff055dda(void);
int32_t function_ff05b11a(void);
int32_t function_ff062c8e(void);
int32_t function_ff06e49e(void);
int32_t function_ff06e4be(void);
int32_t function_ff06e86a(void);
int32_t function_ff06eb3e(void);
int32_t function_ff06eb5e(void);
int32_t function_ff06ebca(void);
int32_t function_ff06ec12(void);
int32_t function_ff06f0ae(void);
int32_t function_ff08315e(void);
int32_t function_ff08320e(void);
int32_t function_ff084e84(void);
int32_t function_ff152e3a(void);
int32_t function_ff1555d6(void);
int32_t function_ff16ee82(void);
int32_t function_ff1d3216(void);
int32_t function_ff1dc2de(void);
int32_t function_ff1ec382(void);
int32_t function_ff1f513e(void);
int32_t function_ff204fe0(void);
int32_t function_ff218f0e(void);
int32_t function_ff2238ca(void);
int32_t function_ff229246(void);
int32_t function_ff2296ce(void);
int32_t function_ff22def2(void);
int32_t function_ff22f12a(void);
int32_t function_ff230936(void);
int32_t function_ff23496a(void);
int32_t function_ff2422de(void);
int32_t function_ff244ed0(void);
int32_t function_ff27d302(void);
int32_t function_ff27d856(void);
int32_t function_ff2d55be(void);
int32_t function_ff352e7e(void);
int32_t function_ff458fca(void);
int32_t function_ff462676(void);
int32_t function_ff552ec2(void);
int32_t function_ff554a46(void);
int32_t function_ff57c4ce(void);
int32_t function_ff655586(void);
int32_t function_ff662662(void);
int32_t function_ff82e20e(void);
int32_t function_ff852ee6(void);
int32_t function_ff895962(void);
int32_t function_ff9d8f72(void);
int32_t function_ff9e8f7a(void);
int32_t function_ff9f45fa(void);
int32_t function_ffa14d9a(void);
int32_t function_ffa1c216(void);
int32_t function_ffa2ceca(void);
int32_t function_ffa2eca2(void);
int32_t function_ffa2f1ee(void);
int32_t function_ffa2f342(void);
int32_t function_ffa3d27e(void);
int32_t function_ffa3d60a(void);
int32_t function_ffa52f06(void);
int32_t function_ffc292e4(void);
int32_t function_ffc2fbec(void);
int32_t function_ffc6db82(void);
int32_t function_ffe1590a(void);
int32_t function_ffe2d01a(void);
int32_t function_ffe43b16(void);
int32_t function_fff6d026(void);
int32_t * malloc2(int32_t size);
int32_t memmem(int32_t result, uint32_t a2, int32_t str, uint32_t a4);
int32_t sched_yield2(void);
int32_t unknown_240(void);
int32_t unknown_41ff68(void);
int32_t unknown_427a90(void);
int32_t unknown_429918(void);
int32_t unknown_42a668(void);
int32_t unknown_4319f0(void);
int32_t unknown_448190(void);
int32_t unknown_4481f0(void);
int32_t unknown_462f76(void);
int32_t unknown_46305e(void);
int32_t unknown_463086(void);
int32_t unknown_4630a2(void);
int32_t unknown_4630ca(void);
int32_t unknown_463dca(void);
int32_t unknown_463de2(void);
int32_t unknown_463e22(void);
int32_t unknown_463e3a(void);
int32_t unknown_464b5e(void);
int32_t unknown_464bb6(void);
int32_t unknown_4658aa(void);
int32_t unknown_46923a(void);
int32_t unknown_4696c2(void);
int32_t unknown_46b486(void);
int32_t unknown_46b726(void);
int32_t unknown_4767fe(void);
int32_t unknown_4835a6(void);
int32_t unknown_4835ba(void);
int32_t unknown_484f78(void);
int32_t unknown_83(void);
int32_t unknown_fe442c54(void);

// --------------------- Global Variables ---------------------

// Detected cryptographic pattern: SHA256_Hash_constant_words_K__0x428a2f98_ (32-bit, little endian)
int32_t SHA256_Hash_constant_words_K__0x428a2f98__at_657bc[64] = {0x428a2f98, 0x71374491, -0x4a3f0431, -0x164a245b, 0x3956c25b, 0x59f111f1, -0x6dc07d5c, -0x54e3a12b, -0x27f85568, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, -0x7f214e02, -0x6423f959, -0x3e640e8c, -0x1b64963f, -0x1041b87a, 0xfc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, -0x67c1aeae, -0x57ce3993, -0x4ffcd838, -0x40a68039, -0x391ff40d, -0x2a586eb9, 0x6ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, -0x7e3d36d2, -0x6d8dd37b, -0x5d40175f, -0x57e599b5, -0x3db47490, -0x3893ae5d, -0x2e6d17e7, -0x2966f9dc, -0xbf1ca7b, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, -0x7b3787ec, -0x7338fdf8, -0x6f410006, -0x5baf9315, -0x41065c09, -0x398e870e}; // 0x657bc
int32_t g1 = -0x1cae0000; // 0x15e3c
int32_t g2 = -0x1c600000; // 0x1da28
int32_t g3 = -0x16d2bff0; // 0x1f1a8
int64_t g4 = 0x38d7ea4c67fff; // 0x27470
int32_t * (*g5)(int32_t *) = (int32_t * (*)(int32_t *))-0x16d2bff0; // 0x27970
int32_t g6 = 0x1a000022; // 0x2f9dc
int32_t g7 = 0x1a00004d; // 0x2fc68
int32_t * (*g8)(int32_t *) = (int32_t * (*)(int32_t *))-0x16d2bfd0; // 0x31858
int32_t * (*g9)(int32_t *) = (int32_t * (*)(int32_t *))-0x16d2b810; // 0x3315c
int32_t g10 = -0x16d2b010; // 0x34b18
int32_t g11 = -0x1cbfdffb; // 0x40000
int32_t * (*g12)(int32_t *) = (int32_t * (*)(int32_t *))-0x16d2b010; // 0x42980
int32_t * (*g13)(int32_t *) = (int32_t * (*)(int32_t *))-0x16d2b010; // 0x42cb4
int32_t g14 = -0x114f9440; // 0x47adc
int16_t * g15 = (int16_t *)0x13a02004; // 0x47b00
char * g16 = "S"; // 0x498a4
int32_t g17 = -1; // 0x4a880
char (*g18)[6] = "http:"; // 0x4ac9c
char * g19; // 0x4b57c
int32_t g20 = 115; // 0x4c0a0
char * g21 = "o"; // 0x4c93c
int32_t g22 = 1; // 0x4cac8
int32_t g23 = 32; // 0x4ff10
int32_t g24 = 120; // 0x51b88
int32_t g25 = 0x40c38; // 0x53e84
int32_t g26 = 0x15eb9; // 0x64ee0
int32_t g27 = 1; // 0x64ee8
char * g28 = "\x05"; // 0x657b8
int32_t g29 = -0x398e870e; // 0x658b8
int32_t g30 = 0x5be0cd19; // 0x658d8
char * g31 = "(\xda\x01"; // 0x658dc
char (*g32)[15] = "--version-file"; // 0x659e0
int32_t g33 = 2; // 0x659e4
char (*g34)[19] = "--logfile-openflag"; // 0x659fc
float64_t g35 = 1.0; // 0x66120
int32_t g36 = 0x3ff00000; // 0x66124
char * g37 = "0"; // 0x66128
char (*g38)[3] = ":D"; // 0x66134
int32_t g39 = 0; // 0x66138
int32_t g40 = 0x3ff00000; // 0x6613c
int32_t g41 = 0; // 0x66140
int32_t g42 = 0x3ff00000; // 0x66144
int32_t g43 = 0; // 0x66148
int32_t g44 = 0x43f00000; // 0x6614c
int32_t g45 = 120; // 0x66150
int32_t g46 = -1; // 0x66154
char g47 = 1; // 0x6615d
int32_t g48 = 100; // 0x66160
char (*g49)[12] = "--config|-c"; // 0x66164
char (*g50)[14] = "cgminer 1.0.0"; // 0x66220
char g51 = 1; // 0x66224
int32_t g52 = 3; // 0x66450
int32_t g53 = 0x61a8; // 0x664c8
int32_t g54 = 0x123cc; // 0x664cc
int32_t g55 = 0x12138; // 0x664d0
int32_t g56 = 5; // 0x664d4
int32_t g57 = 6; // 0x664dc
int32_t g58 = 7; // 0x664e4
int32_t g59 = 0; // 0x664f0
struct _IO_FILE * g60 = NULL; // 0x664f4
struct _IO_FILE * g61 = NULL; // 0x664f8
int32_t g62 = 0; // 0x66500
char * g63; // 0x66518
struct _IO_FILE * g64 = NULL; // 0x6651c
char * g65; // 0x66520
int32_t g66 = 0; // 0x66522
char * g67; // 0x66540
char * g68; // 0x66544
char * g69; // 0x66548
char * g70; // 0x66640
char * g71; // 0x66641
char * g72; // 0x66642
char * g73; // 0x66648
char * g74; // 0x66848
char * g75; // 0x6684c
char * g76; // 0x66850
char * g77; // 0x66854
char * g78; // 0x66858
struct _IO_FILE * g79 = NULL; // 0x6685c
int32_t g80 = 0; // 0x66860
char * g81; // 0x66864
int32_t g82 = 0; // 0x66964
char * g83; // 0x66968
int32_t g84 = 0; // 0x6696c
char g85 = 0; // 0x66970
char * g86; // 0x66974
int32_t g87 = 0; // 0x66a3c
int32_t g88 = 0; // 0x66a40
int32_t g89 = 0; // 0x66a44
char * g90; // 0x66a48
int32_t g91 = 0; // 0x66a4c
int32_t g92 = 0; // 0x66a54
int64_t g93 = 0; // 0x66a60
int32_t g94 = 0; // 0x66a68
int32_t g95 = 0; // 0x66a6c
struct _IO_FILE * g96 = NULL; // 0x66a70
struct _IO_FILE * g97 = NULL; // 0x66a74
struct _IO_FILE * g98 = NULL; // 0x66a78
char g99 = 0; // 0x66a7c
int32_t g100 = 0; // 0x66a80
int32_t g101 = 0; // 0x66a84
int32_t g102 = 0; // 0x66a88
int32_t g103 = 0; // 0x66a90
char * g104; // 0x66a98
int32_t g105 = 0; // 0x66ac4
int32_t g106 = 0; // 0x66ac8
int32_t g107 = 0; // 0x66acc
int32_t g108 = 0; // 0x66ad0
int32_t g109 = 0; // 0x66ad4
char g110 = 0; // 0x66ad8
int32_t g111 = 0; // 0x66adc
int32_t g112 = 0; // 0x66ae0
int32_t g113 = 0; // 0x66ae4
int32_t g114 = 0; // 0x66ae8
int32_t g115 = 0; // 0x66aec
int32_t g116 = 0; // 0x66af0
int32_t g117 = 0; // 0x66af8
int32_t g118 = 0; // 0x66b58
int32_t g119 = 0; // 0x66b5c
int32_t g120 = 0; // 0x66b60
int32_t g121 = 0; // 0x66b78
char g122 = 0; // 0x66ba8
int32_t g123 = 0; // 0x66bac
int32_t g124 = 0; // 0x66bc4
int32_t g125 = 0; // 0x66bc8
int32_t g126 = 0; // 0x66bd0
int32_t g127 = 0; // 0x66bd4
int32_t g128 = 0; // 0x66bec
int32_t g129 = 0; // 0x66bf0
int32_t g130 = 0; // 0x66bf4
int32_t g131 = 0; // 0x66bf8
int32_t g132 = 0; // 0x675f8
int32_t g133 = 0; // 0x68110
int32_t g134 = 0; // 0x68128
int32_t g135 = 0; // 0x68134
int32_t g136 = 0; // 0x68180
int32_t g137 = 0; // 0x68184
int32_t g138 = 0; // 0x68188
char * g139; // 0x68190
int32_t g140 = 0; // 0x681a0
int32_t g141 = 0; // 0x681ac
int32_t g142 = 0; // 0x681b0
char * g143; // 0x681b4
char * g144; // 0x681c0
char * g145; // 0x682b4
int32_t g146 = 0; // 0x683b4
int32_t g147 = 0; // 0x683b8
int32_t g148 = 0; // 0x683bc
int32_t g149 = 0; // 0x683dc
struct _IO_FILE * g150 = NULL; // 0x683e0
struct _IO_FILE * g151 = NULL; // 0x683e4
char g152 = 0; // 0x684e8
int32_t g153 = 0; // 0x684ec
int32_t g154 = 0; // 0x685f0
int32_t g155 = 0; // 0x685f4
int32_t g156 = 0; // 0x685f8
int32_t g157 = 0; // 0x68608
char * g158; // 0x68610
char * g159; // 0x68628
int32_t g160 = 0; // 0x68640
char * g161; // 0x68735
int64_t g162 = 0; // 0x68740
int32_t g163 = 0; // 0x68748
int32_t g164 = 0; // 0x6874c
int32_t g165 = 0; // 0x68750
int32_t g166 = 0; // 0x68754
int32_t g167 = 0; // 0x6876c
int32_t g168 = 0; // 0x68770
int32_t g169 = 0; // 0x6c770
char * g170; // 0x6c774
int32_t g171 = 0; // 0x70000
int32_t g172 = 0; // 0x70b70
char g173 = 0; // 0x70b74
int32_t g174 = 0; // 0x70b78
int32_t g175 = 0; // 0x70bf0
int32_t g176 = 0; // 0x70c68
float64_t g177 = 0.0; // 0x70ce0
int32_t g178 = 0; // 0x70ce4
int32_t g179 = 0; // 0x70ce8
int32_t g180 = 0; // 0x70cec
int32_t g181 = 0; // 0x70d04
char * g182; // 0x70d08
int32_t g183 = 0; // 0x70d14
int32_t g184 = 0; // 0x70d18
int32_t g185 = 0; // 0x70d20
int32_t g186 = 0; // 0x70d24
struct sigaction * g187 = NULL; // 0x70d28
char * g188; // 0x70db8
char g189 = 0; // 0x70dbc
int32_t g190 = 0; // 0x70dc0
int32_t g191 = 0; // 0x70df4
int32_t g192 = 0; // 0x70e18
int32_t g193 = 0; // 0x70e1c
char g194 = 0; // 0x70e20
float64_t g195 = 0.0; // 0x70e28
int32_t g196 = 0; // 0x70e2c
int32_t g197 = 0; // 0x70e30
int32_t g198 = 0; // 0x70e48
int32_t g199 = 0; // 0x70e4c
int32_t g200 = 0; // 0x70e50
int32_t g201 = 0; // 0x70e54
int32_t g202 = 0; // 0x70e5c
int32_t g203 = 0; // 0x70e60
int32_t g204 = 0; // 0x70e64
int32_t g205 = 0; // 0x70e68
int32_t g206 = 0; // 0x70e6c
int32_t g207 = 0; // 0x71e74
int32_t g208 = 0; // 0x71e78
int32_t g209 = 0; // 0x72e7c
float64_t g210 = 0.0; // 0x72e80
int32_t g211 = 0; // 0x72e84
char g212 = 0; // 0x72e88
int32_t g213 = 0; // 0x72e90
int32_t g214 = 0; // 0x72e94
int32_t g215 = 0; // 0x72eb8
char g216 = 0; // 0x72ebd
int32_t g217 = 0; // 0x72ec0
int32_t g218 = 0; // 0x72ec4
char g219 = 0; // 0x72edc
int32_t g220 = 0; // 0x72ee0
int32_t g221 = 0; // 0x72ee4
int32_t g222 = 0; // 0x72ee8
float64_t g223 = 0.0; // 0x72f08
int32_t g224 = 0; // 0x72f0c
int64_t g225 = 0; // 0x72f10
int32_t g226 = 0; // 0x72f14
int32_t g227 = 0; // 0x72f18
char * g228; // 0x72f38
int32_t g229 = 0; // 0x72f3c
char * g230; // 0x72f54
int32_t g231 = 0; // 0x72f60
int32_t g232 = 0; // 0x72f64
char g233 = 0; // 0x72f68
char g234 = 0; // 0x73f6c
int32_t g235 = 0; // 0x73f70
char * g236; // 0x73f88
int32_t g237 = 0; // 0x73f90
int32_t g238 = 0; // 0x73f94
int32_t g239 = 0; // 0x73fb8
int32_t g240 = 0; // 0x73fbc
char g241 = 0; // 0x73fc0
int32_t g242 = 0; // 0x73fc4
char * g243; // 0x73fc8
int32_t g244 = 0; // 0x73fcc
char g245 = 0; // 0x73fd0
char * g246; // 0x73fd2
int32_t g247 = 0; // 0x73fd8
struct sigaction * g248 = NULL; // 0x73fdc
int32_t g249 = 0; // 0x74068
int32_t g250 = 0; // 0x740a0
int32_t g251 = 0; // 0x740ec
int32_t g252 = 0; // 0x740f0
int32_t g253 = 0; // 0x74120
int32_t g254 = 0; // 0x74124
char g255 = 0; // 0x74128
int32_t g256 = 0; // 0x7412c
int32_t g257 = 0; // 0x74130
int32_t g258 = 0; // 0x74134
int32_t g259 = 0; // 0x74138
char * g260; // 0x7413c
int32_t g261 = 0; // 0x74180
char * g262; // 0x74188
char g263 = 0; // 0x7418c
struct sigaction * g264 = NULL; // 0x74190
char * g265; // 0x7421c
int64_t g266 = 0; // 0x74220
int32_t g267 = 0; // 0x74224
int32_t g268 = 0; // 0x74228
int32_t g269 = 0; // 0x7422c
int32_t g270 = 0; // 0x74230
int32_t g271 = 0; // 0x74234
char g272 = 0; // 0x74238
int32_t g273 = 0; // 0x7423c
int32_t g274 = 0; // 0x74240
int32_t g275 = 0; // 0x74244
int32_t g276 = 0; // 0x74248
int32_t g277 = 0; // 0x7424c
char * g278; // 0x74250
int32_t g279 = 0; // 0x74254
int32_t g280 = 0; // 0x74258
int32_t g281 = 0; // 0x74270
int32_t g282 = 0; // 0x74274
int32_t g283 = 0; // 0x74278
char * g284; // 0x7427c
char * g285; // 0x7437c
char * g286; // 0x7438c
char * g287; // 0x7439c
char * g288; // 0x743ac
char * g289; // 0x743bc
int32_t g290 = 0; // 0x743c4
char * g291; // 0x745cc
char * g292; // 0x75c18
int32_t g293 = 0; // 0x75c70
int32_t g294 = 0; // 0x75c74
int32_t g295 = 0; // 0x75c80
int32_t g296;
int32_t g297;
int32_t g298;
int32_t g299;
int32_t g300;
int32_t g301;
int32_t g302;
int32_t g303;
int32_t g304;
int32_t g305;
int32_t g306;
int32_t g307;
int32_t g308;
int32_t g309;
int32_t g310;
int32_t g311;
int32_t g312;
int32_t g313;
int32_t g314;

// ------- Dynamically Linked Functions Without Header --------

void __gmon_start__(void);
int32_t __libc_start_main(int32_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
int32_t __res_init(void);
char * __strdup(char * a1);
void errx(int32_t a1, char * a2, ...);
struct _IO_FILE * fopen64(char * a1, char * a2);
int32_t open64(char * a1, int32_t a2, ...);
int32_t sscanf2(int32_t * a1, char * a2, int32_t * a3, int32_t a4);
int32_t sysinfo(struct sysinfo * a1);

// ------------------------ Functions -------------------------

// Address range: 0x11eb4 - 0x11ec0
int32_t function_11eb4(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x11eb4
    return function_15e2c();
}

// Address range: 0x11ed4 - 0x11ee0
int32_t function_11ed4(struct sockaddr * sa, int32_t salen, char * host, int32_t hostlen, char * serv, int32_t servlen, int32_t flags) {
    // 0x11ed4
    return getnameinfo(sa, salen, host, hostlen, serv, servlen, flags);
}

// Address range: 0x11ee0 - 0x11eec
int32_t function_11ee0(int32_t * rwlock) {
    // 0x11ee0
    return pthread_rwlock_unlock(rwlock);
}

// Address range: 0x11eec - 0x11ef8
void function_11eec(int32_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int32_t *, int32_t *)) {
    // 0x11eec
    qsort(base, nmemb, size, compar);
}

// Address range: 0x11ef8 - 0x11f04
int32_t function_11ef8(struct _TYPEDEF_sigset_t * set) {
    // 0x11ef8
    return sigemptyset(set);
}

// Address range: 0x11f04 - 0x11f10
char * function_11f04(int32_t errnum) {
    // 0x11f04
    return strerror(errnum);
}

// Address range: 0x11f10 - 0x11f1c
int32_t function_11f10(struct _IO_FILE * stream) {
    // 0x11f10
    return fileno(stream);
}

// Address range: 0x11f1c - 0x11f28
int32_t function_11f1c(char * path, int32_t mode) {
    // 0x11f1c
    return mkdir(path, mode);
}

// Address range: 0x11f28 - 0x11f34
int32_t function_11f28(struct __jmp_buf_tag env[1], int32_t savemask) {
    // 0x11f28
    return __sigsetjmp(env, savemask);
}

// Address range: 0x11f34 - 0x11f40
void function_11f34(void) {
    // 0x11f34
    abort();
}

// Address range: 0x11f40 - 0x11f4c
int32_t function_11f40(int32_t fd, struct sockaddr * addr, int32_t len) {
    // 0x11f40
    return connect(fd, addr, len);
}

// Address range: 0x11f4c - 0x11f58
struct tm * function_11f4c(int32_t * timer) {
    // 0x11f4c
    return localtime(timer);
}

// Address range: 0x11f58 - 0x11f64
int32_t function_11f58(int32_t * rwlock) {
    // 0x11f58
    return pthread_rwlock_rdlock(rwlock);
}

// Address range: 0x11f64 - 0x11f70
int32_t function_11f64(int32_t * s1, int32_t * s2, int32_t n) {
    // 0x11f64
    return memcmp(s1, s2, n);
}

// Address range: 0x11f70 - 0x11f7c
int32_t function_11f70(int32_t name) {
    // 0x11f70
    return sysconf(name);
}

// Address range: 0x11f7c - 0x11f88
void function_11f7c(int32_t pri, char * fmt, ...) {
    // 0x11f7c
    syslog(pri, fmt);
}

// Address range: 0x11f88 - 0x11f94
int32_t function_11f88(int32_t clock_id, struct timespec * tp) {
    // 0x11f88
    return clock_gettime(clock_id, tp);
}

// Address range: 0x11f94 - 0x11fa0
int32_t function_11f94(int32_t main, int32_t argc, char ** ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)()) {
    // 0x11f94
    return __libc_start_main(main, argc, ubp_av, init, fini, rtld_fini);
}

// Address range: 0x11fa0 - 0x11fac
void (*function_11fa0(int32_t sig, void (*handler)(int32_t)))(int32_t) {
    // 0x11fa0
    return signal(sig, handler);
}

// Address range: 0x11fac - 0x11fb8
void function_11fac(void) {
    // 0x11fac
    __gmon_start__();
}

// Address range: 0x11fb8 - 0x11fc4
int32_t sched_yield2(void) {
    // 0x11fb8
    return sched_yield();
}

// Address range: 0x11fc4 - 0x11fd0
int32_t function_11fc4(char * s, char * format, ...) {
    // 0x11fc4
    return sscanf(s, format);
}

// Address range: 0x11fd0 - 0x11fdc
int32_t function_11fd0(char * s, int32_t maxlen, char * format, int32_t arg) {
    // 0x11fd0
    return vsnprintf(s, maxlen, format, arg);
}

// Address range: 0x11fdc - 0x11fe8
int32_t function_11fdc(char * cp) {
    // 0x11fdc
    return inet_addr(cp);
}

// Address range: 0x11fe8 - 0x11ff4
char * function_11fe8(char * dest, char * src, int32_t n) {
    // 0x11fe8
    return strncpy(dest, src, n);
}

// Address range: 0x11ff4 - 0x12000
int32_t function_11ff4(struct _IO_FILE * stream) {
    // 0x11ff4
    return fclose(stream);
}

// Address range: 0x12000 - 0x1200c
char * function_12000(char * s, int32_t n, struct _IO_FILE * stream) {
    // 0x12000
    return fgets(s, n, stream);
}

// Address range: 0x1200c - 0x12018
int32_t function_1200c(int32_t fd, int32_t * buf, int32_t n, int32_t flags) {
    // 0x1200c
    return recv(fd, buf, n, flags);
}

// Address range: 0x12018 - 0x12024
char * function_12018(char * name) {
    // 0x12018
    return getenv(name);
}

// Address range: 0x12024 - 0x12030
float64_t function_12024(char * nptr, char ** endptr) {
    // 0x12024
    return strtod(nptr, endptr);
}

// Address range: 0x12030 - 0x1203c
char * function_12030(char * s, int32_t c) {
    // 0x12030
    return strchr(s, c);
}

// Address range: 0x1203c - 0x12048
int32_t function_1203c(char * s1, char * s2) {
    // 0x1203c
    return strcasecmp(s1, s2);
}

// Address range: 0x12048 - 0x12054
char * function_12048(char * path) {
    // 0x12048
    return dirname(path);
}

// Address range: 0x12054 - 0x12060
int32_t function_12054(int32_t mask) {
    // 0x12054
    return setlogmask(mask);
}

// Address range: 0x12060 - 0x1206c
int32_t function_12060(struct _IO_FILE * stream) {
    // 0x12060
    return pclose(stream);
}

// Address range: 0x1206c - 0x12078
int32_t function_1206c(int32_t fd, int32_t n) {
    // 0x1206c
    return listen(fd, n);
}

// Address range: 0x12078 - 0x12084
int32_t * function_12078(int32_t nmemb, int32_t size) {
    // 0x12078
    return calloc(nmemb, size);
}

// Address range: 0x12084 - 0x12090
int32_t function_12084(int32_t * cond, int32_t * mutex) {
    // 0x12084
    return pthread_cond_wait(cond, mutex);
}

// Address range: 0x12090 - 0x1209c
int32_t function_12090(int32_t * sem, int32_t pshared, int32_t value) {
    // 0x12090
    return sem_init(sem, pshared, value);
}

// Address range: 0x1209c - 0x120a8
char * function_1209c(char * dest, char * src) {
    // 0x1209c
    return stpcpy(dest, src);
}

// Address range: 0x120a8 - 0x120b4
int32_t * function_120a8(int32_t * s, int32_t c, int32_t n) {
    // 0x120a8
    return memset(s, c, n);
}

// Address range: 0x120b4 - 0x120c0
int32_t function_120b4(int32_t * sem) {
    // 0x120b4
    return sem_destroy(sem);
}

// Address range: 0x120c0 - 0x120cc
int32_t function_120c0(int32_t * cond, int32_t * mutex, struct timespec * abstime) {
    // 0x120c0
    return pthread_cond_timedwait(cond, mutex, abstime);
}

// Address range: 0x120cc - 0x120d8
void function_120cc(struct addrinfo * ai) {
    // 0x120cc
    freeaddrinfo(ai);
}

// Address range: 0x120d8 - 0x120e4
void function_120d8(char * s) {
    // 0x120d8
    perror(s);
}

// Address range: 0x120e4 - 0x120f0
int64_t function_120e4(char * nptr, char ** endptr, int32_t base) {
    // 0x120e4
    return 0x100000000 * strtoll(nptr, endptr, base) >> 32;
}

// Address range: 0x120f0 - 0x120fc
float64_t function_120f0(float64_t a1) {
    // 0x120f0
    return floor(a1);
}

// Address range: 0x120fc - 0x12108
void function_120fc(char * assertion, char * file, int32_t line, char * function) {
    // 0x120fc
    __assert_fail(assertion, file, line, function);
}

// Address range: 0x12114 - 0x12120
int32_t function_12114(int32_t * cond) {
    // 0x12114
    return pthread_cond_broadcast(cond);
}

// Address range: 0x12120 - 0x1212c
int32_t function_12120(int32_t useconds) {
    // 0x12120
    return usleep(useconds);
}

// Address range: 0x1212c - 0x12138
int32_t function_1212c(int32_t * mutex) {
    // 0x1212c
    return pthread_mutex_trylock(mutex);
}

// Address range: 0x12138 - 0x12144
void free2(int32_t * ptr) {
    // 0x12138
    free(ptr);
}

// Address range: 0x12144 - 0x12150
int32_t function_12144(int32_t fd, int32_t * buf, int32_t nbytes) {
    // 0x12144
    return read(fd, buf, nbytes);
}

// Address range: 0x12150 - 0x1215c
int32_t function_12150(int32_t fd, int32_t * buf, int32_t n) {
    // 0x12150
    return write(fd, buf, n);
}

// Address range: 0x1215c - 0x12168
int32_t function_1215c(char * name, int32_t type) {
    // 0x1215c
    return access(name, type);
}

// Address range: 0x12168 - 0x12174
void function_12168(char * ident, int32_t option, int32_t facility) {
    // 0x12168
    openlog(ident, option, facility);
}

// Address range: 0x12174 - 0x12180
int32_t function_12174(struct timeval * tv, struct timezone * tz) {
    // 0x12174
    return gettimeofday(tv, tz);
}

// Address range: 0x12180 - 0x1218c
int32_t function_12180(int32_t * sem) {
    // 0x12180
    return sem_trywait(sem);
}

// Address range: 0x1218c - 0x12198
int32_t function_1218c(int32_t fd, struct sockaddr * addr, int32_t * addr_len) {
    // 0x1218c
    return accept(fd, addr, addr_len);
}

// Address range: 0x12198 - 0x121a4
int32_t function_12198(void) {
    // 0x12198
    return __res_init();
}

// Address range: 0x121a4 - 0x121b0
int32_t function_121a4(int32_t * mutex) {
    // 0x121a4
    return pthread_mutex_unlock(mutex);
}

// Address range: 0x121b0 - 0x121bc
float64_t function_121b0(float64_t a1) {
    // 0x121b0
    return round(a1);
}

// Address range: 0x121bc - 0x121c8
int32_t function_121bc(int32_t domain, int32_t type, int32_t protocol) {
    // 0x121bc
    return socket(domain, type, protocol);
}

// Address range: 0x121c8 - 0x121d4
int32_t function_121c8(char * path, char * arg, ...) {
    // 0x121c8
    return execl(path, arg);
}

// Address range: 0x121d4 - 0x121e0
int32_t function_121d4(char * name, char * service, struct addrinfo * req, struct addrinfo ** pai) {
    // 0x121d4
    return getaddrinfo(name, service, req, pai);
}

// Address range: 0x121e0 - 0x121ec
int32_t function_121e0(struct _IO_FILE * stream) {
    // 0x121e0
    return fflush(stream);
}

// Address range: 0x121ec - 0x121f8
int32_t function_121ec(int32_t fd) {
    // 0x121ec
    return isatty(fd);
}

// Address range: 0x121f8 - 0x12204
int32_t function_121f8(int32_t * mutex) {
    // 0x121f8
    return pthread_mutex_lock(mutex);
}

// Address range: 0x12204 - 0x12210
int32_t function_12204(char * s) {
    // 0x12204
    return strlen(s);
}

// Address range: 0x12210 - 0x1221c
int32_t function_12210(int32_t * a1, char * a2, int32_t * a3, int32_t a4) {
    // 0x12210
    return sscanf2(a1, a2, a3, a4);
}

// Address range: 0x1221c - 0x12228
int32_t function_1221c(int32_t * newthread, int32_t * attr, int32_t * (*start_routine)(int32_t *), int32_t * arg) {
    // 0x1221c
    return pthread_create(newthread, attr, start_routine, arg);
}

// Address range: 0x12228 - 0x12234
int32_t function_12228(char * path, char * argv[1]) {
    // 0x12228
    return execv(path, argv);
}

// Address range: 0x12234 - 0x12240
struct _TYPEDEF_lldiv_t function_12234(int64_t numer, int64_t denom) {
    struct _TYPEDEF_lldiv_t v1; // 0x1223c
    struct _TYPEDEF_lldiv_t result; // 0x1223c
    // 0x12234
    v1 = lldiv(0x100000000 * numer >> 32, denom);
    result = (struct {int64_t e0; int64_t e1;}){
        .e0 = 0,
        .e1 = 0
    };
    result.e0 = 0x100000000 * v1.e0 >> 32;
    return result;
}

// Address range: 0x12240 - 0x1224c
int32_t * function_12240(int32_t * dest, int32_t * src, int32_t n) {
    // 0x12240
    return memcpy(dest, src, n);
}

// Address range: 0x1224c - 0x12258
struct _IO_FILE * function_1224c(char * filename, char * modes) {
    // 0x1224c
    return fopen64(filename, modes);
}

// Address range: 0x12258 - 0x12264
int32_t function_12258(int32_t * cond) {
    // 0x12258
    return pthread_cond_signal(cond);
}

// Address range: 0x12264 - 0x12270
int32_t ** function_12264(void) {
    // 0x12264
    return __ctype_tolower_loc();
}

// Address range: 0x12270 - 0x1227c
struct lconv * function_12270(void) {
    // 0x12270
    return localeconv();
}

// Address range: 0x1227c - 0x12288
int32_t fgetc2(struct _IO_FILE * stream) {
    // 0x1227c
    return fgetc(stream);
}

// Address range: 0x12288 - 0x12294
int32_t function_12288(char * nptr, char ** endptr, int32_t base) {
    // 0x12288
    return strtol(nptr, endptr, base);
}

// Address range: 0x12294 - 0x122a0
char * function_12294(char * dest, char * src) {
    // 0x12294
    return strcpy(dest, src);
}

// Address range: 0x122a0 - 0x122ac
int32_t function_122a0(int32_t * sem) {
    // 0x122a0
    return sem_post(sem);
}

// Address range: 0x122ac - 0x122b8
int32_t function_122ac(int32_t * cond) {
    // 0x122ac
    return pthread_cond_destroy(cond);
}

// Address range: 0x122b8 - 0x122c4
char * function_122b8(char * dest, char * src, int32_t n) {
    // 0x122b8
    return strncat(dest, src, n);
}

// Address range: 0x122c4 - 0x122d0
int32_t function_122c4(struct timeval * tv, struct timezone * tz) {
    // 0x122c4
    return settimeofday(tv, tz);
}

// Address range: 0x122d0 - 0x122dc
int32_t function_122d0(int32_t * mutex) {
    // 0x122d0
    return pthread_mutex_destroy(mutex);
}

// Address range: 0x122dc - 0x122e8
int32_t function_122dc(char * format, ...) {
    // 0x122dc
    return printf(format);
}

// Address range: 0x122e8 - 0x122f4
int32_t function_122e8(char * file, int32_t oflag, ...) {
    // 0x122e8
    return open64(file, oflag);
}

// Address range: 0x122f4 - 0x12300
int32_t function_122f4(int32_t sig) {
    // 0x122f4
    return raise(sig);
}

// Address range: 0x12300 - 0x1230c
void function_12300(int32_t status, char * format, ...) {
    // 0x12300
    errx(status, format);
}

// Address range: 0x1230c - 0x12318
float32_t function_1230c(char * nptr, char ** endptr) {
    // 0x1230c
    return strtof(nptr, endptr);
}

// Address range: 0x12318 - 0x12324
int32_t function_12318(int32_t * mutex, int32_t * mutexattr) {
    // 0x12318
    return pthread_mutex_init(mutex, mutexattr);
}

// Address range: 0x12324 - 0x12330
int32_t function_12324(int32_t fd, int32_t how) {
    // 0x12324
    return shutdown(fd, how);
}

// Address range: 0x12330 - 0x1233c
int32_t function_12330(int32_t fd, struct sockaddr * addr, int32_t len) {
    // 0x12330
    return bind(fd, addr, len);
}

// Address range: 0x1233c - 0x12348
struct _IO_FILE * function_1233c(int32_t fd, char * modes) {
    // 0x1233c
    return fdopen(fd, modes);
}

// Address range: 0x12348 - 0x12354
char * function_12348(char * haystack, char * needle) {
    // 0x12348
    return strstr(haystack, needle);
}

// Address range: 0x12354 - 0x12360
int32_t function_12354(int32_t inc) {
    // 0x12354
    return nice(inc);
}

// Address range: 0x12360 - 0x1236c
int32_t function_12360(int32_t nfds, struct _TYPEDEF_fd_set * readfds, struct _TYPEDEF_fd_set * writefds, struct _TYPEDEF_fd_set * exceptfds, struct timeval * timeout) {
    // 0x12360
    return select(nfds, readfds, writefds, exceptfds, timeout);
}

// Address range: 0x1236c - 0x12378
int32_t function_1236c(int32_t fd) {
    // 0x1236c
    return close(fd);
}

// Address range: 0x12378 - 0x12384
int32_t function_12378(int32_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s) {
    // 0x12378
    return fwrite(ptr, size, n, s);
}

// Address range: 0x12384 - 0x12390
int32_t function_12384(int32_t * attr, int32_t stacksize) {
    // 0x12384
    return pthread_attr_setstacksize(attr, stacksize);
}

// Address range: 0x12390 - 0x1239c
int32_t function_12390(char * s1, char * s2, int32_t n) {
    // 0x12390
    return strncasecmp(s1, s2, n);
}

// Address range: 0x1239c - 0x123a8
int32_t function_1239c(int32_t * timer) {
    // 0x1239c
    return time(timer);
}

// Address range: 0x123a8 - 0x123b4
float64_t function_123a8(float64_t a1) {
    // 0x123a8
    return log10(a1);
}

// Address range: 0x123b4 - 0x123c0
int16_t ** function_123b4(void) {
    // 0x123b4
    return __ctype_b_loc();
}

// Address range: 0x123c0 - 0x123cc
int32_t function_123c0(struct _IO_FILE * stream, char * format, ...) {
    // 0x123c0
    return fprintf(stream, format);
}

// Address range: 0x123cc - 0x123d8
int32_t * malloc2(int32_t size) {
    // 0x123cc
    return malloc(size);
}

// Address range: 0x123d8 - 0x123e4
int32_t function_123d8(int32_t sig, struct sigaction * act, struct sigaction * oact) {
    // 0x123d8
    return sigaction(sig, act, oact);
}

// Address range: 0x123e4 - 0x123f0
int32_t function_123e4(int32_t * sem, struct timespec * abstime) {
    // 0x123e4
    return sem_timedwait(sem, abstime);
}

// Address range: 0x123f0 - 0x123fc
int32_t function_123f0(int32_t * attr) {
    // 0x123f0
    return pthread_attr_init(attr);
}

// Address range: 0x123fc - 0x12408
int32_t function_123fc(int32_t c, struct _IO_FILE * stream) {
    // 0x123fc
    return fputc(c, stream);
}

// Address range: 0x12408 - 0x12414
char * function_12408(char * s, char * delim) {
    // 0x12408
    return strtok(s, delim);
}

// Address range: 0x12414 - 0x12420
int32_t function_12414(int32_t * rwlock) {
    // 0x12414
    return pthread_rwlock_wrlock(rwlock);
}

// Address range: 0x12420 - 0x1242c
int32_t function_12420(int32_t seconds) {
    // 0x12420
    return sleep(seconds);
}

// Address range: 0x1242c - 0x12438
int32_t function_1242c(int32_t fd, int32_t * buf, int32_t n, int32_t flags) {
    // 0x1242c
    return send(fd, buf, n, flags);
}

// Address range: 0x12438 - 0x12444
int32_t function_12438(int32_t * rwlock) {
    // 0x12438
    return pthread_rwlock_destroy(rwlock);
}

// Address range: 0x12444 - 0x12450
char * function_12444(char * dest, char * src) {
    // 0x12444
    return strcat(dest, src);
}

// Address range: 0x12450 - 0x1245c
int32_t * function_12450(int32_t * dest, int32_t * src, int32_t n) {
    // 0x12450
    return memmove(dest, src, n);
}

// Address range: 0x1245c - 0x12468
void function_1245c(void) {
    // 0x1245c
    pthread_testcancel();
}

// Address range: 0x12468 - 0x12474
struct _IO_FILE * function_12468(char * command, char * modes) {
    // 0x12468
    return popen(command, modes);
}

// Address range: 0x12474 - 0x12480
int32_t function_12474(int32_t fd, int32_t fd2) {
    // 0x12474
    return dup2(fd, fd2);
}

// Address range: 0x12480 - 0x1248c
int32_t function_12480(char * s) {
    // 0x12480
    return puts(s);
}

// Address range: 0x1248c - 0x12498
int32_t function_1248c(void) {
    // 0x1248c
    return getpid();
}

// Address range: 0x12498 - 0x124a4
int32_t function_12498(int32_t option, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5) {
    // 0x12498
    return prctl(option, arg2, arg3, arg4, arg5);
}

// Address range: 0x124a4 - 0x124b0
int32_t function_124a4(int32_t fd, int32_t cmd, ...) {
    // 0x124a4
    return fcntl(fd, cmd);
}

// Address range: 0x124b0 - 0x124bc
int32_t function_124b0(void) {
    // 0x124b0
    return fork();
}

// Address range: 0x124bc - 0x124c8
void function_124bc(struct _TYPEDEF___pthread_unwind_buf_t * buf) {
    // 0x124bc
    __pthread_register_cancel(buf);
}

// Address range: 0x124c8 - 0x124d4
void function_124c8(struct _TYPEDEF___pthread_unwind_buf_t * buf) {
    // 0x124c8
    __pthread_unregister_cancel(buf);
}

// Address range: 0x124d4 - 0x124e0
int32_t function_124d4(struct _IO_FILE * s, char * format, int32_t arg) {
    // 0x124d4
    return vfprintf(s, format, arg);
}

// Address range: 0x124e0 - 0x124ec
int32_t function_124e0(char * s, int32_t maxlen, char * format, ...) {
    // 0x124e0
    return snprintf(s, maxlen, format);
}

// Address range: 0x124ec - 0x124f8
int32_t function_124ec(char * s, char * reject) {
    // 0x124ec
    return strcspn(s, reject);
}

// Address range: 0x124f8 - 0x12504
int32_t function_124f8(int32_t * ptr, int32_t size, int32_t n, struct _IO_FILE * stream) {
    // 0x124f8
    return fread(ptr, size, n, stream);
}

// Address range: 0x12504 - 0x12510
int32_t function_12504(int32_t * cond, int32_t * cond_attr) {
    // 0x12504
    return pthread_cond_init(cond, cond_attr);
}

// Address range: 0x12510 - 0x1251c
int32_t function_12510(char * s1, char * s2, int32_t n) {
    // 0x12510
    return strncmp(s1, s2, n);
}

// Address range: 0x1251c - 0x12528
int32_t function_1251c(int32_t pid, int32_t sig) {
    // 0x1251c
    return kill(pid, sig);
}

// Address range: 0x12528 - 0x12534
int32_t function_12528(struct timespec * requested_time, struct timespec * remaining) {
    // 0x12528
    return nanosleep(requested_time, remaining);
}

// Address range: 0x12534 - 0x12540
int32_t function_12534(int32_t th) {
    // 0x12534
    return pthread_detach(th);
}

// Address range: 0x12540 - 0x1254c
int32_t * function_12540(int32_t * ptr, int32_t size) {
    // 0x12540
    return realloc(ptr, size);
}

// Address range: 0x1254c - 0x12558
int32_t function_1254c(int32_t * rwlock) {
    // 0x1254c
    return pthread_rwlock_trywrlock(rwlock);
}

// Address range: 0x12558 - 0x12564
int32_t function_12558(int32_t state, int32_t * oldstate) {
    // 0x12558
    return pthread_setcancelstate(state, oldstate);
}

// Address range: 0x12564 - 0x12570
int32_t function_12564(struct sysinfo * info) {
    // 0x12564
    return sysinfo(info);
}

// Address range: 0x12570 - 0x1257c
int32_t function_12570(int32_t fd, int32_t level, int32_t optname, int32_t * optval, int32_t * optlen) {
    // 0x12570
    return getsockopt(fd, level, optname, optval, optlen);
}

// Address range: 0x1257c - 0x12588
int32_t function_1257c(int32_t pipedes[2]) {
    // 0x1257c
    return pipe(pipedes);
}

// Address range: 0x12588 - 0x12594
char * function_12588(char * string) {
    // 0x12588
    return __strdup(string);
}

// Address range: 0x12594 - 0x125a0
int32_t function_12594(int32_t fd, int32_t level, int32_t optname, int32_t * optval, int32_t optlen) {
    // 0x12594
    return setsockopt(fd, level, optname, optval, optlen);
}

// Address range: 0x125a0 - 0x125ac
char * function_125a0(char * s, char * accept2) {
    // 0x125a0
    return strpbrk(s, accept2);
}

// Address range: 0x125ac - 0x125b8
int32_t function_125ac(int32_t * sem) {
    // 0x125ac
    return sem_wait(sem);
}

// Address range: 0x125b8 - 0x125c4
int32_t * function_125b8(int32_t * s, int32_t c, int32_t n) {
    // 0x125b8
    return memchr(s, c, n);
}

// Address range: 0x125c4 - 0x125d0
int32_t function_125c4(char * s1, char * s2) {
    // 0x125c4
    return strcmp(s1, s2);
}

// Address range: 0x125d0 - 0x125dc
void function_125d0(int32_t status) {
    // 0x125d0
    exit(status);
}

// Address range: 0x125dc - 0x125e8
int32_t function_125dc(int32_t type, int32_t * oldtype) {
    // 0x125dc
    return pthread_setcanceltype(type, oldtype);
}

// Address range: 0x125e8 - 0x125f4
int32_t function_125e8(int32_t clock_id, int32_t flags, struct timespec * req, struct timespec * rem) {
    // 0x125e8
    return clock_nanosleep(clock_id, flags, req, rem);
}

// Address range: 0x125f4 - 0x12600
int32_t function_125f4(int32_t * rwlock, int32_t * attr) {
    // 0x125f4
    return pthread_rwlock_init(rwlock, attr);
}

// Address range: 0x12600 - 0x1260c
void function_12600(struct _TYPEDEF___pthread_unwind_buf_t * buf) {
    // 0x12600
    __pthread_unwind_next(buf);
}

// Address range: 0x1260c - 0x12618
int32_t * function_1260c(void) {
    // 0x1260c
    return __errno_location();
}

// Address range: 0x12618 - 0x12624
int32_t function_12618(void) {
    // 0x12618
    return pthread_self();
}

// Address range: 0x12624 - 0x12630
int32_t function_12624(int32_t th) {
    // 0x12624
    return pthread_cancel(th);
}

// Address range: 0x12630 - 0x1263c
int32_t function_12630(char * s, char * format, ...) {
    // 0x12630
    return sprintf(s, format);
}

// Address range: 0x1263c - 0x12648
int32_t function_1263c(int32_t th, int32_t ** thread_return) {
    // 0x1263c
    return pthread_join(th, thread_return);
}

// Address range: 0x12648 - 0x15dfc
int32_t function_12648(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t fds[2]; // 0x147e4
    // 0x12648
    float64_t v1; // 0x12648
    __asm_vpush(v1, v1);
    int32_t v2 = a1; // bp-2564, 0x12664
    int32_t result = 0; // bp-2556, 0x1267c
    int32_t attr; // bp-2520, 0x12648
    pthread_attr_init(&attr);
    pthread_attr_setstacksize(&attr, 0x200000);
    *(char *)&g63 = 0;
    int32_t str3; // bp-2344, 0x12648
    memset(&str3, 0, 256);
    int32_t str; // bp-2484, 0x12648
    memset(&str, 0, 64);
    snprintf((char *)&str, 64, "pidof %s", NULL);
    struct _IO_FILE * stream = popen((char *)&str, "r"); // 0x126f4
    int32_t v3; // 0x12648
    int32_t v4; // 0x12648
    int32_t str2; // bp-2088, 0x12648
    if (stream == NULL) {
        // 0x12a20
        if (*(char *)&g71 != 0) {
            char v5 = *(char *)&g179; // 0x12a3c
            if ((*(char *)&g70 || v5) == 0 != g28 < (char *)7) {
                // 0x12a70
                snprintf((char *)&str2, 2048, " app-service:%s Not Found!!!", NULL);
                function_1ccec(7, &str2, 0);
                v4 = &str2;
            }
        }
    } else {
        // 0x12718
        if (fgets((char *)&str3, 256, stream) != NULL) {
            while (true) {
              lab_0x12734:
                // 0x12734
                if (*(char *)&g71 == 0) {
                    goto lab_0x12718;
                } else {
                    // 0x12740
                    if (*(char *)&g179 == 0) {
                        // 0x1274c
                        v3 = (int32_t)&g70;
                        if (*(char *)&g70 == 0 == g28 < (char *)7) {
                            goto lab_0x127d0;
                        } else {
                            goto lab_0x12774;
                        }
                    } else {
                        goto lab_0x12774;
                    }
                }
            }
        }
      lab_0x1282c:
        // 0x1282c
        pclose(stream);
        int32_t len = strlen((char *)&str3); // 0x1287c
        v4 = (int32_t)&g71;
        if (len != 0) {
            int32_t v6 = &str3; // 0x12864
            int32_t v7 = v6; // 0x12648
            int32_t v8 = 0;
            int32_t v9 = 0;
            int32_t v10 = 1;
            int32_t str4; // bp-2552, 0x12648
            memset(&str4, 0, 32);
            int16_t ** v11 = __ctype_b_loc(); // 0x1289c
            unsigned char v12 = *(char *)v7; // 0x128a0
            int32_t v13 = v8; // 0x128b4
            int32_t v14 = v9; // 0x128b4
            uint32_t str_as_l; // 0x128e8
            int32_t v15; // 0x128f8
            char v16; // 0x12918
            if ((*(int16_t *)(2 * (int32_t)v12 + (int32_t)*v11) & 0x2000) != 0) {
                // 0x128b8
                strncpy((char *)&str4, (char *)(v8 + v6), v10 + -1 - v8);
                str_as_l = strtol((char *)&str4, NULL, 10);
                v13 = v10;
                v14 = v9;
                if (str_as_l >= 1) {
                    // 0x128f4
                    v13 = v10;
                    v14 = v9 + 1;
                    if (*(char *)&g71 != 0) {
                        // 0x12904
                        v16 = *(char *)&g70;
                        v13 = v10;
                        v14 = v15;
                        if ((v16 || *(char *)&g179) != 0 || g28 > (char *)6) {
                            // 0x12924
                            snprintf((char *)&str2, 2048, "Parsed proc id is: %d\n", str_as_l);
                            function_1ccec(7, &str2, 0);
                            v13 = v10;
                            v14 = v15;
                        }
                    }
                }
            }
            int32_t v17 = v14;
            int32_t v18 = v10 + 1; // 0x12870
            uint32_t len2 = strlen((char *)&str3); // 0x1287c
            v7++;
            while (len2 >= v18) {
                // 0x12888
                v8 = v13;
                v9 = v17;
                v10 = v18;
                memset(&str4, 0, 32);
                v11 = __ctype_b_loc();
                v12 = *(char *)v7;
                v13 = v8;
                v14 = v9;
                if ((*(int16_t *)(2 * (int32_t)v12 + (int32_t)*v11) & 0x2000) != 0) {
                    // 0x128b8
                    strncpy((char *)&str4, (char *)(v8 + v6), v10 + -1 - v8);
                    str_as_l = strtol((char *)&str4, NULL, 10);
                    v13 = v10;
                    v14 = v9;
                    if (str_as_l >= 1) {
                        // 0x128f4
                        v13 = v10;
                        v14 = v9 + 1;
                        if (*(char *)&g71 != 0) {
                            // 0x12904
                            v16 = *(char *)&g70;
                            v13 = v10;
                            v14 = v15;
                            if ((v16 || *(char *)&g179) != 0 || g28 > (char *)6) {
                                // 0x12924
                                snprintf((char *)&str2, 2048, "Parsed proc id is: %d\n", str_as_l);
                                function_1ccec(7, &str2, 0);
                                v13 = v10;
                                v14 = v15;
                            }
                        }
                    }
                }
                // 0x12870
                v17 = v14;
                v18 = v10 + 1;
                len2 = strlen((char *)&str3);
                v7++;
            }
            // 0x12974
            v4 = (int32_t)&g71;
            if (v17 != 0) {
                char v19 = *(char *)&g70; // 0x12998
                int32_t v20 = (int32_t)&g71; // 0x1298c
                if ((v19 | *(char *)&g179) != 0 || g28 > (char *)2) {
                    // 0x129a4
                    snprintf((char *)&str2, 2048, " %d instance of %s is  already Running on this machine", v17, NULL);
                    function_1ccec(3, &str2, 0);
                    v20 = &str2;
                }
                // 0x129d8
                v4 = v20;
                if (v17 != 1) {
                    // 0x129e0
                    snprintf((char *)&str2, 2048, "%s is forbidden to start twice, will exit immediately!", (char *)2048);
                    function_1ccec(3, &str2, 1);
                    function_2ab30(-1, 0);
                    // UNREACHABLE
                }
            }
        }
    }
    // 0x12aa0
    g69 = (char *)0x676f6c;
    *(char *)&g66 = 0;
    *(int32_t *)&g67 = 0x696d6d62;
    g68 = (char *)0x2e72656e;
    *(int16_t *)&g65 = 0x2b61;
    if (sysconf(_SC_NPROCESSORS_CONF) == 1) {
        *(int32_t *)0x658dc = 0x11fb8;
    }
    int32_t v21 = function_1e74c(4 * v2 + 4, "cgminer.c", "main", 0x2f2c); // 0x12b2c
    g105 = v21;
    if (v2 >= 1) {
        int32_t v22 = 0; // 0x12b50
        int32_t v23 = v21 - 4; // 0x12b50
        int32_t v24 = a2 - 4; // 0x12b50
        v24 += 4;
        v22++;
        char * v25 = __strdup((char *)*(int32_t *)v24); // 0x12b5c
        v23 += 4;
        *(int32_t *)v23 = (int32_t)v25;
        while (v2 > v22) {
            // 0x12b54
            v24 += 4;
            v22++;
            v25 = __strdup((char *)*(int32_t *)v24);
            v23 += 4;
            *(int32_t *)v23 = (int32_t)v25;
        }
    }
    // 0x12b70
    *(int32_t *)(4 * v2 + v21) = 0;
    function_2b310(&g197, "main", 0x2f35);
    function_2b310(&g235, "main", 0x2f36);
    function_2b310(&g229, "main", 0x2f37);
    function_2b3bc(&g250, "main", 0x2f38);
    function_2b310(&g180, "main", 0x2f39);
    function_2b310(&g127, "main", 0x2f3a);
    function_2b3bc(&g249, "main", 0x2f3b);
    function_2b310(&g123, "main", 0x2f3c);
    function_2b394((int32_t)&g160 - 1336, "main", 0x2f3d);
    function_2b394((int32_t)&g191, "main", 0x2f3e);
    function_2b394((int32_t)&g222, "main", 0x2f3f);
    function_2b394((int32_t)&g227, "main", 0x2f40);
    function_2b310(&g120, "main", 0x2f42);
    char * v26; // bp-2072, 0x12648
    char * fd; // bp-2084, 0x12648
    if (pthread_cond_init(&g121, NULL) != 0) {
        // 0x13964
        str2 = 0x6c696146;
        fd = (char *)0x74206465;
        v26 = (char *)0x6f635f64;
        function_1ccec(3, &str2, 1);
        function_2ab30(1, 0);
        // UNREACHABLE
    }
    // 0x12c9c
    function_2b310(&g218, "main", 0x2f49);
    if (pthread_cond_init(&g252, NULL) != 0) {
        // 0x13f18
        str2 = 0x6c696146;
        fd = (char *)0x74206465;
        v26 = (char *)0x6f635f64;
        // 0x13f4c
        function_1ccec(3, &str2, 1);
        function_2ab30(1, 0);
        // UNREACHABLE
    }
    int32_t v27 = pthread_cond_init(&g190, NULL); // 0x12cd4
    char * v28 = (char *)0x6f635f64; // 0x12cdc
    char v29; // 0x12648
    char * v30; // 0x12648
    int32_t v31; // 0x12648
    int32_t v32; // 0x12648
    int32_t v33; // 0x12648
    if (v27 == 0) {
        int32_t v34 = function_1ef20(); // 0x12ce0
        g215 = v34;
        v28 = (char *)0x74656720;
        if (v34 == 0) {
            goto lab_0x13dd0;
        } else {
            // 0x12cfc
            g100 = v34 + 12;
            snprintf((char *)&g81, 256, "%s %s", "cgminer", "1.0.0");
            str = 0x2ac0c;
            int32_t set; // bp-2480, 0x12648
            sigemptyset((struct _TYPEDEF_sigset_t *)&set);
            sigaction(SIGTERM, (struct sigaction *)&str, (struct sigaction *)&g187);
            sigaction(SIGINT, (struct sigaction *)&str, (struct sigaction *)&g248);
            sigaction(SIGABRT, (struct sigaction *)&str, (struct sigaction *)&g264);
            char * v35 = (char *)0x7273752f; // bp-6728, 0x12dc0
            *(int32_t *)&g262 = (int32_t)&v35;
            int32_t v36; // bp-10832, 0x12648
            *(int32_t *)&g243 = (int32_t)&v36;
            char * path = __strdup((char *)a2); // 0x12df0
            strcpy(g243, dirname(path));
            free((int32_t *)path);
            char * str5 = g243; // 0x12e14
            *(int16_t *)(strlen(str5) + (int32_t)str5) = 47;
            g146 = 9;
            int32_t v37 = function_1e7d4(104, 1, "cgminer.c", "main", 0x2f78); // 0x12e50
            char * str6 = (char *)v37; // 0x12e68
            int32_t v38 = 36;
            int32_t len3 = strlen(str6); // 0x12e68
            *(int16_t *)(len3 + v37) = 48;
            int32_t v39 = v38 - 1; // 0x12e74
            while (v38 != 1) {
                // 0x12e64
                v38 = v39;
                len3 = strlen(str6);
                *(int16_t *)(len3 + v37) = 48;
                v39 = v38 - 1;
            }
            int32_t v40 = len3 + 1; // 0x12e78
            int32_t v41 = v37; // 0x12e98
            int32_t v42 = -0x61c88647; // 0x12e98
            int32_t v43 = -0x1124111; // 0x12e98
            int32_t v44 = v4; // 0x12e98
            int32_t v45 = v40; // 0x12e98
            int32_t v46 = -0x61c88647; // 0x12e98
            if (v40 != 11 && v40 >= 11) {
                int32_t v47 = v40; // 0x12e9c
                int32_t v48 = v37 + 12;
                unsigned char v49 = *(char *)(v48 - 6); // 0x12ea0
                v47 -= 12;
                unsigned char v50 = *(char *)(v48 - 2); // 0x12ea8
                unsigned char v51 = *(char *)(v48 - 10); // 0x12eb0
                unsigned char v52 = *(char *)(v48 - 7); // 0x12eb4
                unsigned char v53 = *(char *)(v48 - 3); // 0x12eb8
                unsigned char v54 = *(char *)(v48 - 11); // 0x12ec0
                unsigned char v55 = *(char *)(v48 - 5); // 0x12ecc
                unsigned char v56 = *(char *)(v48 - 8); // 0x12ed4
                unsigned char v57 = *(char *)(v48 - 12); // 0x12edc
                unsigned char v58 = *(char *)(v48 - 4); // 0x12ee4
                unsigned char v59 = *(char *)(v48 - 9); // 0x12eec
                unsigned char v60 = *(char *)(v48 - 1); // 0x12ef4
                int32_t v61 = (256 * (int32_t)v52 | 0x10000 * (int32_t)v49 | (int32_t)v56 | 0x1000000 * (int32_t)v55) - 0x61c88647; // 0x12f04
                uint32_t v62 = (256 * (int32_t)v53 | 0x10000 * (int32_t)v50 | (int32_t)v58 | 0x1000000 * (int32_t)v60) - 0x1124111; // 0x12f14
                int32_t v63 = v48 + 12; // 0x12f18
                int32_t v64 = -0x61c88647 - v61 + (256 * (int32_t)v54 | 0x10000 * (int32_t)v51 | (int32_t)v57 | 0x1000000 * (int32_t)v59) - v62 ^ v62 / 0x2000; // 0x12f28
                uint32_t v65 = v61 - v62 - v64 ^ 256 * v64; // 0x12f34
                uint32_t v66 = v62 - v64 - v65 ^ v65 / 0x2000; // 0x12f40
                int32_t v67 = v64 - v65 - v66 ^ v66 / 0x1000; // 0x12f4c
                uint32_t v68 = v65 - v66 - v67 ^ 0x10000 * v67; // 0x12f58
                uint32_t v69 = v66 - v67 - v68 ^ v68 / 32; // 0x12f64
                int32_t v70 = v67 - v68 - v69 ^ v69 / 8; // 0x12f70
                int32_t v71 = v68 - v69 - v70 ^ 1024 * v70; // 0x12f7c
                int32_t v72 = v69 - v70 - v71 ^ v71 / 0x8000; // 0x12f84
                v41 = v48;
                v42 = v70;
                v43 = v72;
                v44 = v63;
                v45 = v47;
                v46 = v71;
                while ((v71 & 0x4000) != 0 == (v47 != 11)) {
                    // 0x12ea0
                    v48 = v63;
                    v49 = *(char *)(v48 - 6);
                    v47 -= 12;
                    v50 = *(char *)(v48 - 2);
                    v51 = *(char *)(v48 - 10);
                    v52 = *(char *)(v48 - 7);
                    v53 = *(char *)(v48 - 3);
                    v54 = *(char *)(v48 - 11);
                    v55 = *(char *)(v48 - 5);
                    v56 = *(char *)(v48 - 8);
                    v57 = *(char *)(v48 - 12);
                    v58 = *(char *)(v48 - 4);
                    v59 = *(char *)(v48 - 9);
                    v60 = *(char *)(v48 - 1);
                    v61 = (256 * (int32_t)v52 | 0x10000 * (int32_t)v49 | (int32_t)v56 | 0x1000000 * (int32_t)v55) + v71;
                    v62 = (256 * (int32_t)v53 | 0x10000 * (int32_t)v50 | (int32_t)v58 | 0x1000000 * (int32_t)v60) + v72;
                    v63 = v48 + 12;
                    v64 = v70 - v61 + (256 * (int32_t)v54 | 0x10000 * (int32_t)v51 | (int32_t)v57 | 0x1000000 * (int32_t)v59) - v62 ^ v62 / 0x2000;
                    v65 = v61 - v62 - v64 ^ 256 * v64;
                    v66 = v62 - v64 - v65 ^ v65 / 0x2000;
                    v67 = v64 - v65 - v66 ^ v66 / 0x1000;
                    v68 = v65 - v66 - v67 ^ 0x10000 * v67;
                    v69 = v66 - v67 - v68 ^ v68 / 32;
                    v70 = v67 - v68 - v69 ^ v69 / 8;
                    v71 = v68 - v69 - v70 ^ 1024 * v70;
                    v72 = v69 - v70 - v71 ^ v71 / 0x8000;
                    v41 = v48;
                    v42 = v70;
                    v43 = v72;
                    v44 = v63;
                    v45 = v47;
                    v46 = v71;
                }
            }
            int32_t v73 = v46;
            int32_t v74 = v44;
            int32_t v75 = v42;
            int32_t v76 = v41;
            int32_t v77 = v43 + v40; // 0x12f94
            g296 = v45 - 1;
            int32_t v78 = v77; // 0x12f9c
            int32_t v79 = v77; // 0x12f9c
            int32_t v80 = v77; // 0x12f9c
            int32_t v81 = v77; // 0x12f9c
            int32_t v82 = v73; // 0x12f9c
            int32_t v83 = v77; // 0x12f9c
            int32_t v84 = v73; // 0x12f9c
            int32_t v85 = v77; // 0x12f9c
            int32_t v86 = v73; // 0x12f9c
            int32_t v87 = v77; // 0x12f9c
            int32_t v88 = v73; // 0x12f9c
            int32_t v89 = v75; // 0x12f9c
            int32_t v90 = v77; // 0x12f9c
            int32_t v91 = v73; // 0x12f9c
            int32_t v92 = v75; // 0x12f9c
            int32_t v93 = v77; // 0x12f9c
            int32_t v94 = v73; // 0x12f9c
            int32_t v95 = v75; // 0x12f9c
            int32_t v96 = v77; // 0x12f9c
            int32_t v97 = v73; // 0x12f9c
            int32_t v98 = v75; // 0x12f9c
            int32_t v99 = v77; // 0x12f9c
            int32_t v100 = v73; // 0x12f9c
            switch (v45) {
                case 11: {
                    // 0x12fd0
                    v78 = 0x1000000 * (int32_t)*(char *)(v76 + 10) + v77;
                }
                case 10: {
                    // 0x12fd8
                    v79 = 0x10000 * (int32_t)*(char *)(v76 + 9) + v78;
                }
                case 9: {
                    // 0x12fe0
                    v80 = 256 * (int32_t)*(char *)(v76 + 8) + v79;
                }
                case 8: {
                    // 0x12fe8
                    v81 = v80;
                    v82 = 0x1000000 * (int32_t)*(char *)(v76 + 7) + v73;
                }
                case 7: {
                    // 0x12ff0
                    v83 = v81;
                    v84 = 0x10000 * (int32_t)*(char *)(v76 + 6) + v82;
                }
                case 6: {
                    // 0x12ff8
                    v85 = v83;
                    v86 = 256 * (int32_t)*(char *)(v76 + 5) + v84;
                }
                case 5: {
                    // 0x13000
                    v87 = v85;
                    v88 = v86 + (int32_t)*(char *)(v76 + 4);
                }
                case 4: {
                    // 0x13008
                    v90 = v87;
                    v89 = 0x1000000 * (int32_t)*(char *)(v76 + 3) + v75;
                    v91 = v88;
                }
                case 3: {
                    // 0x13010
                    v93 = v90;
                    v92 = 0x10000 * (int32_t)*(char *)(v76 + 2) + v89;
                    v94 = v91;
                }
                case 2: {
                    // 0x13018
                    v96 = v93;
                    v95 = 256 * (int32_t)*(char *)(v76 + 1) + v92;
                    v97 = v94;
                }
                case 1: {
                    // 0x13020
                    v99 = v96;
                    v98 = v95 + (int32_t)*(char *)v76;
                    v100 = v97;
                    // break -> 0x13028
                    break;
                }
            }
            uint32_t v101 = v99;
            *(int32_t *)(v37 + 88) = v37;
            int32_t v102 = v98 - v101 - v100 ^ v101 / 0x2000; // 0x13038
            uint32_t v103 = v100 - v101 - v102 ^ 256 * v102; // 0x13048
            uint32_t v104 = v101 - v102 - v103 ^ v103 / 0x2000; // 0x13054
            int32_t v105 = v102 - v103 - v104 ^ v104 / 0x1000; // 0x13060
            uint32_t v106 = v103 - v104 - v105 ^ 0x10000 * v105; // 0x1306c
            uint32_t v107 = v104 - v105 - v106 ^ v106 / 32; // 0x13078
            int32_t v108 = v105 - v106 - v107 ^ v107 / 8; // 0x13084
            uint32_t v109 = v106 - v107 - v108 ^ 1024 * v108; // 0x13090
            int32_t v110 = v107 - v108 - v109 ^ v109 / 0x8000; // 0x13098
            *(int32_t *)(v37 + 96) = v110;
            *(int32_t *)(v37 + 92) = strlen(str6);
            int32_t v111 = g134; // 0x130ac
            int32_t v112; // 0x12648
            if (v111 == 0) {
                // 0x13de8
                *(int32_t *)(v37 + 76) = 0;
                *(int32_t *)(v37 + 72) = 0;
                g134 = v37;
                int32_t * mem = malloc(44); // 0x13df8
                int32_t v113 = v37 + 68; // 0x13e00
                int32_t * v114 = (int32_t *)v113; // 0x13e00
                *v114 = (int32_t)mem;
                if (mem == NULL) {
                    // 0x13e08
                    exit(-1);
                    // UNREACHABLE
                }
                // 0x13e10
                memset(mem, 0, 44);
                *(int32_t *)(*v114 + 16) = v113;
                *(int32_t *)(*v114 + 4) = 32;
                *(int32_t *)(*v114 + 8) = 5;
                *(int32_t *)(*v114 + 20) = 68;
                *(int32_t *)*v114 = (int32_t)malloc(384);
                int32_t v115 = *(int32_t *)*v114; // 0x13e60
                if (v115 == 0) {
                    // 0x13e08
                    exit(-1);
                    // UNREACHABLE
                }
                // 0x13e6c
                memset((int32_t *)v115, 0, 384);
                *(int32_t *)(*v114 + 40) = -0x5feee01f;
                v112 = v113;
            } else {
                int32_t * v116 = (int32_t *)(v111 + 68); // 0x130b8
                *(int32_t *)(v37 + 76) = 0;
                int32_t v117 = v37 + 68; // 0x130c4
                *(int32_t *)v117 = *v116;
                int32_t v118 = *v116; // 0x130cc
                int32_t v119 = *(int32_t *)(v118 + 20); // 0x130d4
                *(int32_t *)(v37 + 72) = *(int32_t *)(v118 + 16) - v119;
                *(int32_t *)(*(int32_t *)(*v116 + 16) + 8) = v37;
                *(int32_t *)(*v116 + 16) = v117;
                v112 = v117;
            }
            int32_t v120 = v112;
            int32_t * v121 = (int32_t *)(g134 + 68); // 0x13104
            int32_t * v122 = (int32_t *)(*v121 + 12); // 0x13108
            *v122 = *v122 + 1;
            int32_t v123 = *v121; // 0x13114
            int32_t v124 = 12 * (*(int32_t *)(v123 + 4) - 1 & v110); // 0x13124
            int32_t * v125 = (int32_t *)(*(int32_t *)v123 + 4 + v124); // 0x1312c
            *v125 = *v125 + 1;
            *(int32_t *)(v37 + 80) = 0;
            *(int32_t *)(v37 + 84) = *(int32_t *)(*(int32_t *)*v121 + v124);
            int32_t * v126 = (int32_t *)(*(int32_t *)*v121 + v124);
            int32_t v127 = *v126; // 0x13154
            int32_t * v128 = v126; // 0x1315c
            if (v127 != 0) {
                *(int32_t *)(v127 + 12) = v120;
                v128 = (int32_t *)(*(int32_t *)*v121 + v124);
            }
            // .critedge
            *v128 = v120;
            int32_t v129 = *(int32_t *)*v121 + v124; // 0x13178
            int32_t v130 = v74; // 0x1318c
            if (*(int32_t *)(v129 + 4) >= 10 * *(int32_t *)(v129 + 8) + 10) {
                int32_t * v131 = (int32_t *)(v37 + 68); // 0x13190
                int32_t v132 = *v131; // 0x13190
                v130 = v74;
                if (*(int32_t *)(v132 + 36) != 1) {
                    int32_t * mem2 = calloc(24 * *(int32_t *)(v132 + 4), 1); // 0x131b0
                    if (mem2 == NULL) {
                        // 0x13e08
                        exit(-1);
                        // UNREACHABLE
                    }
                    int32_t v133 = (int32_t)mem2; // 0x131b0
                    int32_t v134 = *v131; // 0x131bc
                    int32_t v135 = *(int32_t *)(v134 + 4); // 0x131cc
                    uint32_t v136 = *(int32_t *)(v134 + 12); // 0x131d0
                    int32_t v137 = *(int32_t *)(v134 + 8); // 0x131d4
                    *(int32_t *)(v134 + 24) = (v136 >> v137 + 1) + (int32_t)((2 * v135 - 1 & v136) != 0);
                    *(int32_t *)(*v131 + 28) = 0;
                    int32_t v138 = *v131; // 0x13200
                    int32_t v139 = *(int32_t *)v138; // 0x13204
                    int32_t v140 = 0; // 0x13210
                    int32_t v141 = v139; // 0x13210
                    int32_t v142 = v138; // 0x13210
                    int32_t v143 = v139; // 0x13210
                    if (*(int32_t *)(v138 + 4) != 0) {
                        int32_t v144 = *(int32_t *)(v141 + 12 * v140); // 0x13220
                        int32_t v145 = v142; // 0x13228
                        int32_t v146 = v144; // 0x13228
                        int32_t v147 = v142; // 0x13228
                        int32_t v148; // 0x12648
                        int32_t v149; // 0x1322c
                        int32_t * v150; // 0x13234
                        int32_t v151; // 0x13234
                        int32_t v152; // 0x13248
                        int32_t * v153; // 0x1324c
                        uint32_t v154; // 0x13250
                        int32_t v155; // 0x13258
                        uint32_t v156; // 0x1325c
                        int32_t * v157; // 0x1328c
                        int32_t v158; // 0x13294
                        int32_t * v159; // 0x13268
                        int32_t v160; // 0x132ac
                        if (v144 != 0) {
                            v148 = v146;
                            v149 = *(int32_t *)(v145 + 4);
                            v150 = (int32_t *)(v148 + 16);
                            v151 = *v150;
                            v152 = 12 * (2 * v149 - 1 & *(int32_t *)(v148 + 28)) + v133;
                            v153 = (int32_t *)(v152 + 4);
                            v154 = *v153 + 1;
                            *v153 = v154;
                            v155 = *v131;
                            v156 = *(int32_t *)(v155 + 24);
                            if (v154 != v156 && v154 >= v156) {
                                // 0x13268
                                v159 = (int32_t *)(v155 + 28);
                                *v159 = *v159 + 1;
                                *(int32_t *)(v152 + 8) = function_48ac8();
                            }
                            // 0x13288
                            *(int32_t *)(v148 + 12) = 0;
                            v157 = (int32_t *)v152;
                            *v150 = *v157;
                            v158 = *v157;
                            if (v158 != 0) {
                                *(int32_t *)(v158 + 12) = v148;
                            }
                            *v157 = v148;
                            v160 = *v131;
                            v147 = v160;
                            while (v151 != 0) {
                                // 0x1322c
                                v148 = v151;
                                v149 = *(int32_t *)(v160 + 4);
                                v150 = (int32_t *)(v148 + 16);
                                v151 = *v150;
                                v152 = 12 * (2 * v149 - 1 & *(int32_t *)(v148 + 28)) + v133;
                                v153 = (int32_t *)(v152 + 4);
                                v154 = *v153 + 1;
                                *v153 = v154;
                                v155 = *v131;
                                v156 = *(int32_t *)(v155 + 24);
                                if (v154 != v156 && v154 >= v156) {
                                    // 0x13268
                                    v159 = (int32_t *)(v155 + 28);
                                    *v159 = *v159 + 1;
                                    *(int32_t *)(v152 + 8) = function_48ac8();
                                }
                                // 0x13288
                                *(int32_t *)(v148 + 12) = 0;
                                v157 = (int32_t *)v152;
                                *v150 = *v157;
                                v158 = *v157;
                                if (v158 != 0) {
                                    *(int32_t *)(v158 + 12) = v148;
                                }
                                *v157 = v148;
                                v160 = *v131;
                                v147 = v160;
                            }
                        }
                        int32_t v161 = v140 + 1; // 0x132b8
                        int32_t v162 = *(int32_t *)v147; // 0x13204
                        uint32_t v163 = *(int32_t *)(v147 + 4); // 0x13204
                        v140 = v161;
                        v142 = v147;
                        v143 = v162;
                        while (v163 != v161 && v163 >= v161) {
                            // 0x13214
                            v144 = *(int32_t *)(v162 + 12 * v140);
                            v145 = v142;
                            v146 = v144;
                            v147 = v142;
                            if (v144 != 0) {
                                v148 = v146;
                                v149 = *(int32_t *)(v145 + 4);
                                v150 = (int32_t *)(v148 + 16);
                                v151 = *v150;
                                v152 = 12 * (2 * v149 - 1 & *(int32_t *)(v148 + 28)) + v133;
                                v153 = (int32_t *)(v152 + 4);
                                v154 = *v153 + 1;
                                *v153 = v154;
                                v155 = *v131;
                                v156 = *(int32_t *)(v155 + 24);
                                if (v154 != v156 && v154 >= v156) {
                                    // 0x13268
                                    v159 = (int32_t *)(v155 + 28);
                                    *v159 = *v159 + 1;
                                    *(int32_t *)(v152 + 8) = function_48ac8();
                                }
                                // 0x13288
                                *(int32_t *)(v148 + 12) = 0;
                                v157 = (int32_t *)v152;
                                *v150 = *v157;
                                v158 = *v157;
                                if (v158 != 0) {
                                    *(int32_t *)(v158 + 12) = v148;
                                }
                                *v157 = v148;
                                v160 = *v131;
                                v147 = v160;
                                while (v151 != 0) {
                                    // 0x1322c
                                    v148 = v151;
                                    v149 = *(int32_t *)(v160 + 4);
                                    v150 = (int32_t *)(v148 + 16);
                                    v151 = *v150;
                                    v152 = 12 * (2 * v149 - 1 & *(int32_t *)(v148 + 28)) + v133;
                                    v153 = (int32_t *)(v152 + 4);
                                    v154 = *v153 + 1;
                                    *v153 = v154;
                                    v155 = *v131;
                                    v156 = *(int32_t *)(v155 + 24);
                                    if (v154 != v156 && v154 >= v156) {
                                        // 0x13268
                                        v159 = (int32_t *)(v155 + 28);
                                        *v159 = *v159 + 1;
                                        *(int32_t *)(v152 + 8) = function_48ac8();
                                    }
                                    // 0x13288
                                    *(int32_t *)(v148 + 12) = 0;
                                    v157 = (int32_t *)v152;
                                    *v150 = *v157;
                                    v158 = *v157;
                                    if (v158 != 0) {
                                        *(int32_t *)(v158 + 12) = v148;
                                    }
                                    *v157 = v148;
                                    v160 = *v131;
                                    v147 = v160;
                                }
                            }
                            // 0x132b4
                            v161 = v140 + 1;
                            v162 = *(int32_t *)v147;
                            v163 = *(int32_t *)(v147 + 4);
                            v140 = v161;
                            v142 = v147;
                            v143 = v162;
                        }
                    }
                    // 0x132c4
                    free((int32_t *)v143);
                    int32_t * v164 = (int32_t *)(*v131 + 4); // 0x132cc
                    *v164 = 2 * *v164;
                    int32_t * v165 = (int32_t *)(*v131 + 8); // 0x132dc
                    *v165 = *v165 + 1;
                    *(int32_t *)*v131 = v133;
                    int32_t v166 = *v131; // 0x132f0
                    uint32_t v167 = *(int32_t *)(v166 + 28); // 0x132f4
                    uint32_t v168 = *(int32_t *)(v166 + 12) / 2; // 0x132fc
                    int32_t * v169 = (int32_t *)(v166 + 32);
                    int32_t v170 = v167; // 0x13300
                    if (v167 >= v168 == (v167 != v168)) {
                        v170 = *v169;
                    }
                    int32_t v171 = v167 == v168 | v167 < v168 ? 0 : v170;
                    *v169 = v171 + (int32_t)(v167 >= v168 == (v167 != v168));
                    int32_t v172 = *v131; // 0x13310
                    int32_t v173 = *(int32_t *)(v172 + 32); // 0x13314
                    v130 = 0;
                    if (v173 != 0 == (v173 != 1)) {
                        *(int32_t *)(v172 + 36) = 1;
                        v130 = 0;
                    }
                }
            }
            // 0x13324
            strcpy((char *)&g260, str6);
            g204 = &g204;
            g205 = &g204;
            function_3d658(&g32, "Options for both config file and command line");
            function_3d658((char (**)[15])&g49, "Options for command line only");
            function_3d72c(&v2, a2, 0x26d78);
            if (v2 != 1) {
                // 0x13910
                str2 = 0x78656e55;
                fd = (char *)0x74636570;
                v26 = (char *)0x6d6f6320;
                function_1ccec(3, &str2, 1);
                function_2ab30(1, 0);
                // UNREACHABLE
            }
            int32_t v174 = v130;
            if (g85 == 0) {
                // 0x13fa8
                function_29d68();
            }
            // 0x13398
            g147 = 8;
            int32_t v175 = function_1e7d4(8, 64, "cgminer.c", "main", 0x2f9c); // 0x133c8
            int32_t v176 = v175 + 64; // 0x133d8
            g184 = v175;
            g108 = 1;
            if (function_21e74(v176, &attr, 0x28604, v176) != 0) {
                // 0x13f64
                str2 = 0x20495041;
                fd = (char *)0x65726874;
                v26 = (char *)0x61662065;
                function_1ccec(3, &str2, 1);
                function_2ab30(1, 0);
                // UNREACHABLE
            }
            // 0x13414
            if (g122 == 0 != (g182 == NULL)) {
                int32_t v177 = function_2e940(); // 0x1343c
                int32_t v178 = function_1e74c(255, "cgminer.c", "main", 0x2fad); // 0x13458
                int32_t * v179 = (int32_t *)(v177 + 164); // 0x13464
                *v179 = v178;
                int32_t v180 = g182 == NULL ? (int32_t)" benchfile '%s'" | 0x2230 : (int32_t)" benchfile '%s'" | 0x2224;
                *(int32_t *)v178 = *(int32_t *)v180;
                *(int32_t *)(v178 + 4) = *(int32_t *)(v180 + 4);
                *(int16_t *)(v178 + 8) = *(int16_t *)(v180 + 8);
                int32_t v181 = *v179; // 0x134a0
                *(int32_t *)(v177 + 172) = v181;
                *(int32_t *)(v177 + 176) = v181;
                *(int32_t *)(v177 + 168) = v181;
                *(int32_t *)(v177 + 600) = v181;
                strncpy((char *)(v177 + 48), "?", 7);
                int32_t v182 = v177 + 100; // 0x134bc
                *(char *)(v177 + 55) = 0;
                if (*(int32_t *)v182 != 1) {
                    // 0x13e8c
                    function_27998(v182);
                }
                // 0x134d0
                *(char *)(v177 + 97) = 0;
                *(char *)&g72 = 1;
                int32_t v183 = &g132; // 0x134fc
                int32_t v184 = &g131; // 0x134fc
                int32_t v185 = 0;
                function_1ea68(v184, v185 + (int32_t)"000000029c6bf469abe4ad37605c097a860cff3cf5c1ef4377618f74000000000000000082b1514e7b6565941e5824f084292164ec5f97e7ea20c494bd96e524d478977b536dd2261900896c8b10020000000080000000000000000000000000000000000000000000000000000000000000000000000000000000008002000064e4e3becc01064d808269b330f40f4de82dc92e894d635025daa3e2e2c410b4", 160);
                int32_t v186 = v185 + 324; // 0x13520
                function_1ea68(v183, v185 + (int32_t)"00000002c01f502cb3e9fdb053230ec12a4954c1021a6b35862b5e29000000000000000084d1b83ae44057025e8c5b5756b44f04df5fffe4a7a30e5c12d12a97a7a4c2ea536dce431900896cb6d60e00000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000d08f7e14c50dad77dc238b4db2901a0578e657b1954779ab9cd82a73829edf7f", 160);
                v183 += 160;
                v184 += 160;
                while (v186 != 0x1440) {
                    // 0x13500
                    v185 = v186;
                    function_1ea68(v184, v185 + (int32_t)"000000029c6bf469abe4ad37605c097a860cff3cf5c1ef4377618f74000000000000000082b1514e7b6565941e5824f084292164ec5f97e7ea20c494bd96e524d478977b536dd2261900896c8b10020000000080000000000000000000000000000000000000000000000000000000000000000000000000000000008002000064e4e3becc01064d808269b330f40f4de82dc92e894d635025daa3e2e2c410b4", 160);
                    v186 = v185 + 324;
                    function_1ea68(v183, v185 + (int32_t)"00000002c01f502cb3e9fdb053230ec12a4954c1021a6b35862b5e29000000000000000084d1b83ae44057025e8c5b5756b44f04df5fffe4a7a30e5c12d12a97a7a4c2ea536dce431900896cb6d60e00000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000d08f7e14c50dad77dc238b4db2901a0578e657b1954779ab9cd82a73829edf7f", 160);
                    v183 += 160;
                    v184 += 160;
                }
                // 0x13534
                __asm_vldr(0);
                function_29dcc();
            }
            // 0x13540
            if (g78 != NULL) {
                // 0x13550
                function_3c280();
            }
            // 0x13554
            v31 = v174;
            if (g74 == NULL) {
                goto lab_0x139e8;
            } else {
                // 0x13564
                *(char *)&g63 = 1;
                strcpy((char *)&g67, g74);
                if (g77 != NULL) {
                    // 0x13588
                    strcpy((char *)&g65, g77);
                }
                char v187 = *(char *)&g70; // 0x135b4
                if ((v187 | *(char *)&g179) != 0 || g28 > (char *)2) {
                    // 0x139ac
                    snprintf((char *)&str2, 2048, "Log file path: %s Open flag: %s", (char *)&g67, (char *)&g65);
                    function_1ccec(3, &str2, 0);
                    v31 = &str2;
                    goto lab_0x139e8;
                } else {
                    // 0x135d4
                    v29 = v187;
                    v33 = v174;
                    v30 = g76;
                    v32 = v174;
                    if (g76 == NULL) {
                        goto lab_0x135e4;
                    } else {
                        goto lab_0x139f8;
                    }
                }
            }
        }
    } else {
        goto lab_0x13dd0;
    }
  lab_0x144c8:;
    // 0x144c8
    int32_t v188; // 0x12648
    int32_t v189 = v188;
    char * v190; // 0x12648
    char * v191 = v190; // 0x144cc
    int32_t v192; // 0x12648
    int32_t v193 = v192 + 1; // 0x144c8
    char * v194 = v191; // 0x144d4
    v192 = v193;
    int32_t v195 = v189; // 0x144d4
    if (v193 >= (int32_t)v191) {
        // break -> 0x144d8
        goto lab_0x144d8;
    }
    goto lab_0x14434;
  lab_0x14498:
    // 0x14498
    str2 = 0x6e616c42;
    fd = (char *)0x6f77206b;
    v26 = (char *)0x2e737473;
    function_1ccec(7, &str2, 0);
    v190 = g188;
    int32_t v200; // 0x12648
    v188 = v200;
    goto lab_0x144c8;
  lab_0x14acc:;
    // 0x14acc
    int32_t v201; // 0x12648
    int32_t v202 = v201 + 1; // 0x14acc
    int32_t v203; // 0x149d8
    int32_t v204 = v202 + v203; // 0x149e0
    int32_t v205 = v204; // 0x149e4
    v201 = v202;
    int32_t v206 = v204; // 0x149e4
    int32_t * v207; // 0x149b0
    if (*v207 <= v202) {
        // break -> 0x14ad4
        goto lab_0x14ad4;
    }
    goto lab_0x149e8;
  lab_0x14a8c:;
    // 0x14a8c
    int32_t * v209; // 0x149f0
    snprintf((char *)&str2, 2048, "Pushing sem post to thread %d", *v209);
    function_1ccec(7, &str2, 0);
    // 0x14ab4
    int32_t v208; // 0x149ec
    function_21ebc(v208 + 16, "cgminer.c", "main", 0x30fb);
    goto lab_0x14acc;
  lab_0x15928_2:;
    char * v212 = (char *)0x31ab; // 0x15944
    char * v213 = "main"; // 0x15944
    int32_t * v214 = __errno_location(); // 0x15944
    int32_t format = (int32_t)"WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d"; // 0x15944
    goto lab_0x15954;
  lab_0x15350:;
    // 0x15350
    int32_t v242; // 0x12648
    int32_t v243 = v242 + 1; // 0x15354
    int32_t v244; // 0x12648
    *(int32_t *)(*(int32_t *)(4 * v242 + v244) + 64) = 0;
    v242 = v243;
    int32_t v245; // 0x12648
    if (v245 > v243) {
        goto lab_0x15350;
    }
  lab_0x15598_2:;
    // 0x15598
    int32_t v246; // 0x12648
    int32_t v247 = v246; // 0x155a0
    int32_t v248 = v246; // 0x155a0
    int32_t v249 = v246; // 0x155a0
    int32_t v250 = v246; // 0x155a0
    if (*(char *)&g71 == 0) {
        goto lab_0x155a4;
    } else {
        goto lab_0x151b4;
    }
  lab_0x15444:;
    // 0x15444
    int32_t v251; // 0x12648
    int32_t v252 = v251 + 1; // 0x15448
    int32_t v253; // 0x12648
    *(int32_t *)(*(int32_t *)(4 * v251 + v253) + 64) = 0;
    v251 = v252;
    int32_t v254; // 0x12648
    if (v254 > v252) {
        goto lab_0x15444;
    }
  lab_0x15778_2:;
    // 0x15778
    int32_t v255; // 0x12648
    int32_t v256 = v255; // 0x15780
    int32_t v257 = v255; // 0x15780
    if (*(char *)&g71 == 0) {
        goto lab_0x15784;
    } else {
        goto lab_0x15264;
    }
  lab_0x151a8:;
    // 0x151a8
    int32_t v258; // 0x12648
    v247 = v258;
    int32_t v259; // 0x12648
    v248 = v259;
    int32_t v260 = v258; // 0x151b0
    int32_t v261 = v259; // 0x151b0
    if (*(char *)&g71 == 0) {
        goto lab_0x1520c;
    } else {
        goto lab_0x151b4;
    }
  lab_0x1520c:;
    int32_t v262 = v261;
    int32_t v263 = v260;
    int32_t v264 = v263; // 0x15214
    if (*(char *)(v262 + 97) == 0) {
        // 0x15218
        v264 = v263;
        if (*(int32_t *)(v262 + 100) == 1) {
            goto lab_0x155a4;
        } else {
            goto lab_0x15224;
        }
    } else {
        goto lab_0x15224;
    }
  lab_0x151b4:;
    int32_t v265 = v248;
    if (*(char *)&g179 == 0) {
        // 0x151c4
        v260 = v247;
        v261 = v265;
        if (*(char *)&g70 == 0 == g28 < (char *)7) {
            goto lab_0x1520c;
        } else {
            goto lab_0x151e8;
        }
    } else {
        goto lab_0x151e8;
    }
  lab_0x15224:;
    int32_t v266 = v264;
    function_30264(0);
    int32_t v267 = function_2e47c(); // 0x1522c
    int32_t v268; // 0x12648
    char * v269; // 0x12648
    int32_t v270; // 0x12648
    int32_t v271; // 0x12648
    if (g89 == 4) {
        // 0x157c0
        v270 = v266;
        v271 = function_279dc(v267);
        goto lab_0x15258;
    } else {
        // 0x15244
        v270 = v266;
        v271 = v267;
        if (g89 == 3) {
            int32_t v272 = (int32_t)g188;
            v254 = g89 == 3 ? v272 : v266;
            v253 = g89 == 3 ? g202 : v267;
            int32_t v273 = v272; // 0x15434
            if (v254 > 0) {
                int32_t v274 = 0;
                int32_t v275 = *(int32_t *)(4 * v274 + v253); // 0x15418
                v268 = v272;
                v269 = g188;
                while (*(int32_t *)(v275 + 64) >= *(int32_t *)(v275 + 60)) {
                    int32_t v276 = v274 + 1; // 0x1542c
                    int32_t v277 = v276; // 0x15434
                    v251 = 0;
                    if (v276 >= v254) {
                        goto lab_0x15444;
                    }
                    v274 = v277;
                    v275 = *(int32_t *)(4 * v274 + v253);
                    v268 = v272;
                    v269 = g188;
                }
                goto lab_0x1546c;
            } else {
                int32_t v278 = g156 + 1; // 0x1545c
                g156 = v254 > v278 ? v278 : 0;
                v268 = v273;
                v269 = g188;
                goto lab_0x1546c;
            }
        } else {
            goto lab_0x15258;
        }
    }
  lab_0x151e8:;
    int32_t v279 = *(int32_t *)v265; // 0x151f0
    snprintf((char *)&str2, 2048, "Selecting pool %d for work", v279);
    function_1ccec(7, &str2, 0);
    int32_t v218; // 0x12648
    v260 = v218;
    v261 = v265;
    goto lab_0x1520c;
  lab_0x15378:;
    // 0x15378
    char * v280; // 0x12648
    char * v281 = v280; // 0x153b0
    int32_t v282; // 0x12648
    int32_t v283 = v282; // 0x153b0
    if (v280 > NULL) {
        uint32_t v284 = 1;
        int32_t v285 = *(int32_t *)(g202 + 4 * g156); // 0x153bc
        int32_t * v286 = (int32_t *)(v285 + 64); // 0x153c0
        int32_t v287 = *v286; // 0x153c0
        *v286 = v287 + 1;
        int32_t v288; // 0x15710
        int32_t * v289; // 0x15408
        if (v287 < *(int32_t *)(v285 + 60)) {
            // 0x153d8
            if (*(char *)(v285 + 97) == 0) {
                // 0x153e4
                if (*(int32_t *)(v285 + 100) == 1) {
                    // 0x1570c
                    v288 = function_279b8(v285);
                    v246 = v285;
                    if (v288 == 0) {
                        goto lab_0x15598_2;
                    }
                }
            }
            // 0x153f0
            if (g216 != 0) {
                // 0x15400
                v289 = (int32_t *)(function_27af0(0) + 64);
                *v289 = *v289 - 1;
            }
        }
        int32_t v290 = (int32_t)g188;
        int32_t v291 = g156 + 1; // 0x1538c
        int32_t v292 = v291 < v290 ? v291 : 0;
        g156 = v292;
        v281 = g188;
        v283 = v290;
        int32_t v293 = v284 + 1; // 0x153b0
        while (v284 < v290) {
            // 0x153b4
            v284 = v293;
            v285 = *(int32_t *)(g202 + 4 * v292);
            v286 = (int32_t *)(v285 + 64);
            v287 = *v286;
            *v286 = v287 + 1;
            if (v287 < *(int32_t *)(v285 + 60)) {
                // 0x153d8
                if (*(char *)(v285 + 97) == 0) {
                    // 0x153e4
                    if (*(int32_t *)(v285 + 100) == 1) {
                        // 0x1570c
                        v288 = function_279b8(v285);
                        v246 = v285;
                        if (v288 == 0) {
                            goto lab_0x15598_2;
                        }
                    }
                }
                // 0x153f0
                if (g216 != 0) {
                    // 0x15400
                    v289 = (int32_t *)(function_27af0(0) + 64);
                    *v289 = *v289 - 1;
                }
            }
            // 0x15384
            v290 = (int32_t)g188;
            v291 = g156 + 1;
            v292 = v291 < v290 ? v291 : 0;
            g156 = v292;
            v281 = g188;
            v283 = v290;
            v293 = v284 + 1;
        }
    }
    // 0x15558
    v258 = v283;
    int32_t v294; // 0x152f4
    v259 = v294;
    if (v281 > NULL) {
        int32_t v295 = 0;
        int32_t v296 = function_27af0(v295); // 0x15568
        int32_t v297; // 0x15588
        if (*(char *)(v296 + 97) == 0) {
            // 0x1557c
            if (*(int32_t *)(v296 + 100) == 1) {
                // 0x15588
                v297 = function_279b8(v296);
                v246 = v296;
                if (v297 == 0) {
                    goto lab_0x15598_2;
                }
            }
        }
        int32_t v298 = v295 + 1; // 0x15554
        v258 = v296;
        v259 = v294;
        while (v298 < (int32_t)g188) {
            // 0x15564
            v295 = v298;
            v296 = function_27af0(v295);
            if (*(char *)(v296 + 97) == 0) {
                // 0x1557c
                if (*(int32_t *)(v296 + 100) == 1) {
                    // 0x15588
                    v297 = function_279b8(v296);
                    v246 = v296;
                    if (v297 == 0) {
                        goto lab_0x15598_2;
                    }
                }
            }
            // 0x15554
            v298 = v295 + 1;
            v258 = v296;
            v259 = v294;
        }
    }
    goto lab_0x151a8;
  lab_0x155a4:;
    int32_t v299 = v250;
    int32_t v300 = v249;
    v264 = v300;
    if (function_279b8(v299) == 0) {
        // break -> 0x155b4
        goto lab_0x155b4;
    }
    goto lab_0x15224;
  lab_0x15258:
    // 0x15258
    v256 = v270;
    v257 = v271;
    int32_t v301 = v270; // 0x15260
    int32_t v302 = v271; // 0x15260
    if (*(char *)&g71 == 0) {
        goto lab_0x152bc;
    } else {
        goto lab_0x15264;
    }
  lab_0x152bc:;
    int32_t v303 = v302;
    if (*(char *)(v303 + 97) == 0) {
        // 0x152c8
        if (*(int32_t *)(v303 + 100) == 1) {
            goto lab_0x15784;
        } else {
            goto lab_0x152d4;
        }
    } else {
        goto lab_0x152d4;
    }
  lab_0x15264:;
    int32_t v304 = v257;
    if (*(char *)&g179 == 0) {
        // 0x15274
        v301 = v256;
        v302 = v304;
        if (*(char *)&g70 == 0 == g28 < (char *)7) {
            goto lab_0x152bc;
        } else {
            goto lab_0x15298;
        }
    } else {
        goto lab_0x15298;
    }
  lab_0x152d4:
    // 0x152d4
    pthread_mutex_unlock((int32_t *)((int32_t)&g140 - 12));
    function_1f7f8(11);
    int32_t v305 = v301; // 0x12648
    goto lab_0x152e8_2;
  lab_0x15298:;
    int32_t v314 = *(int32_t *)v304; // 0x152a0
    snprintf((char *)&str2, 2048, "Selecting pool %d for work", v314);
    function_1ccec(7, &str2, 0);
    v301 = v218;
    v302 = v304;
    goto lab_0x152bc;
  lab_0x1546c:;
    char * v315 = v269; // 0x154e0
    int32_t v316 = v268; // 0x154e0
    if (v269 > NULL) {
        uint32_t v317 = 1;
        int32_t v318 = *(int32_t *)(g202 + 4 * g156); // 0x154ec
        int32_t * v319 = (int32_t *)(v318 + 64); // 0x154f0
        int32_t v320 = *v319; // 0x154f0
        *v319 = v320 + 1;
        int32_t v321; // 0x157a8
        int32_t * v322; // 0x15538
        if (v320 < *(int32_t *)(v318 + 60)) {
            // 0x15508
            if (*(char *)(v318 + 97) == 0) {
                // 0x15514
                if (*(int32_t *)(v318 + 100) == 1) {
                    // 0x157a4
                    v321 = function_279b8(v318);
                    v255 = v318;
                    if (v321 == 0) {
                        goto lab_0x15778_2;
                    }
                }
            }
            // 0x15520
            if (g216 != 0) {
                // 0x15530
                v322 = (int32_t *)(function_27af0(0) + 64);
                *v322 = *v322 - 1;
            }
        }
        int32_t v323 = (int32_t)g188;
        int32_t v324 = g156 + 1; // 0x154bc
        int32_t v325 = v324 < v323 ? v324 : 0;
        g156 = v325;
        v315 = g188;
        v316 = v323;
        int32_t v326 = v317 + 1; // 0x154e0
        while (v317 < v323) {
            // 0x154e4
            v317 = v326;
            v318 = *(int32_t *)(g202 + 4 * v325);
            v319 = (int32_t *)(v318 + 64);
            v320 = *v319;
            *v319 = v320 + 1;
            if (v320 < *(int32_t *)(v318 + 60)) {
                // 0x15508
                if (*(char *)(v318 + 97) == 0) {
                    // 0x15514
                    if (*(int32_t *)(v318 + 100) == 1) {
                        // 0x157a4
                        v321 = function_279b8(v318);
                        v255 = v318;
                        if (v321 == 0) {
                            goto lab_0x15778_2;
                        }
                    }
                }
                // 0x15520
                if (g216 != 0) {
                    // 0x15530
                    v322 = (int32_t *)(function_27af0(0) + 64);
                    *v322 = *v322 - 1;
                }
            }
            // 0x154b4
            v323 = (int32_t)g188;
            v324 = g156 + 1;
            v325 = v324 < v323 ? v324 : 0;
            g156 = v325;
            v315 = g188;
            v316 = v323;
            v326 = v317 + 1;
        }
    }
    // 0x15738
    v270 = v316;
    v271 = v267;
    if (v315 > NULL) {
        int32_t v327 = 0;
        int32_t v328 = function_27af0(v327); // 0x15748
        int32_t v329; // 0x15768
        if (*(char *)(v328 + 97) == 0) {
            // 0x1575c
            if (*(int32_t *)(v328 + 100) == 1) {
                // 0x15768
                v329 = function_279b8(v328);
                v255 = v328;
                if (v329 == 0) {
                    goto lab_0x15778_2;
                }
            }
        }
        int32_t v330 = v327 + 1; // 0x15734
        v270 = v328;
        v271 = v267;
        while (v330 < (int32_t)g188) {
            // 0x15744
            v327 = v330;
            v328 = function_27af0(v327);
            if (*(char *)(v328 + 97) == 0) {
                // 0x1575c
                if (*(int32_t *)(v328 + 100) == 1) {
                    // 0x15768
                    v329 = function_279b8(v328);
                    v255 = v328;
                    if (v329 == 0) {
                        goto lab_0x15778_2;
                    }
                }
            }
            // 0x15734
            v330 = v327 + 1;
            v270 = v328;
            v271 = v267;
        }
    }
    goto lab_0x15258;
  lab_0x15784:;
    // 0x15784
    int32_t v331; // 0x12648
    int32_t v332 = v331;
    int32_t v333; // 0x12648
    int32_t v334 = v333;
    if (function_279b8(v332) == 0) {
        // 0x15794
        pthread_mutex_unlock((int32_t *)((int32_t)&g140 - 12));
        int32_t v335 = v334; // 0x157a0
        int32_t v336 = v335;
        v305 = v336;
        goto lab_0x152e8_2;
    } else {
        goto lab_0x152d4;
    }
  lab_0x150f0:
    // 0x150f0
    g241 = 0;
    if (pthread_mutex_lock((int32_t *)g100) != 0) {
        // break -> 0x15968
        goto lab_0x15968;
    }
    // 0x15110
    int32_t v220; // 0x12648
    int32_t v337 = v220;
    int32_t v338 = v337; // 0x1511c
    int32_t v339; // 0x12648
    int32_t v219; // 0x12648
    int32_t v340; // 0x12648
    if (g119 == 0) {
        goto lab_0x15130;
    } else {
        // 0x15120
        v338 = v337;
        if (*(int32_t *)(*(int32_t *)(g119 + 344) + 12) > 1) {
            // 0x15aa4
            pthread_cond_wait(&g190, (int32_t *)g100);
            v338 = g100;
            if (g119 == 0) {
                goto lab_0x15130;
            } else {
                // 0x15ac4
                if (pthread_mutex_unlock((int32_t *)g100) != 0) {
                    goto lab_0x15928_2;
                }
                // 0x15adc
                function_1da28();
                v340 = g100;
                if (*(int32_t *)(*(int32_t *)(g119 + 344) + 12) < 2) {
                    goto lab_0x15154;
                } else {
                    int32_t v341 = function_313c0(0); // 0x15af8
                    result = v341;
                    v339 = g100;
                    if (v341 != 0) {
                        // 0x15b08
                        function_292f8(&result, "cgminer.c", "main", 0x31b7);
                        v339 = (int32_t)"cgminer.c";
                    }
                    // 0x150e0
                    v219 = v339;
                    goto lab_0x150e0_2;
                }
            }
        } else {
            goto lab_0x15130;
        }
    }
  lab_0x15130:
    // 0x15130
    if (pthread_mutex_unlock((int32_t *)g100) != 0) {
        goto lab_0x15928_2;
    }
    // 0x15144
    function_1da28();
    v340 = v338;
    goto lab_0x15154;
  lab_0x159c0:
    // 0x159c0
    str2 = 0x6b726f57;
    fd = (char *)0x64707520;
    v26 = (char *)0x20656761;
    function_1ccec(6, &str2, 0);
    goto lab_0x159f0;
  lab_0x15154:;
    int32_t v342 = v340; // 0x1515c
    if (result != 0) {
        // 0x15160
        function_292f8(&result, "cgminer.c", "main", 0x31bf);
        v342 = (int32_t)"cgminer.c";
    }
    // 0x15180
    result = function_2c214();
    v305 = v342;
    while (true) {
      lab_0x152e8_2:;
        int32_t v306 = v305;
        pthread_mutex_lock((int32_t *)((int32_t)&g140 - 12));
        v294 = function_2e47c();
        if (g89 == 4) {
            // 0x157cc
            v258 = v306;
            v259 = function_279dc(v294);
            goto lab_0x151a8;
        } else {
            // 0x1530c
            v258 = v306;
            v259 = v294;
            if (g89 == 3) {
                int32_t v307 = (int32_t)g188;
                v245 = g89 == 3 ? v307 : v306;
                v244 = g89 == 3 ? g202 : v294;
                int32_t v308 = v307; // 0x15340
                if (v245 > 0) {
                    int32_t v309 = 0;
                    int32_t v310 = *(int32_t *)(4 * v309 + v244); // 0x15324
                    v282 = v307;
                    v280 = g188;
                    while (*(int32_t *)(v310 + 64) >= *(int32_t *)(v310 + 60)) {
                        int32_t v311 = v309 + 1; // 0x15338
                        int32_t v312 = v311; // 0x15340
                        v242 = 0;
                        if (v311 >= v245) {
                            goto lab_0x15350;
                        }
                        v309 = v312;
                        v310 = *(int32_t *)(4 * v309 + v244);
                        v282 = v307;
                        v280 = g188;
                    }
                    goto lab_0x15378;
                } else {
                    int32_t v313 = g156 + 1; // 0x15368
                    g156 = v245 > v313 ? v313 : 0;
                    v282 = v308;
                    v280 = g188;
                    goto lab_0x15378;
                }
            } else {
                goto lab_0x151a8;
            }
        }
    }
  lab_0x155b4:
    // 0x155b4
    g142 = 0;
    pthread_mutex_unlock((int32_t *)((int32_t)&g140 - 12));
    pthread_mutex_lock((int32_t *)((int32_t)&g140 - 12));
    int32_t v343; // 0x12648
    int32_t v344; // 0x12648
    float64_t v217; // 0x150b4
    if (g142 == 1) {
        // 0x157d8
        g142 = 0;
        pthread_mutex_unlock((int32_t *)((int32_t)&g140 - 12));
        // 0x150e0
        v219 = v300;
        goto lab_0x150e0_2;
    } else {
        // 0x155e4
        if (*(char *)(v299 + 640) == 0) {
            // 0x155f0
            pthread_mutex_unlock((int32_t *)((int32_t)&g140 - 12));
            if (g182 != NULL) {
                int32_t v345 = result + 400; // 0x157f0
                function_2aea8(result);
                *(char *)(result + 282) = 1;
                *(int32_t *)(result + 260) = *(int32_t *)g202;
                function_1f5c4((int32_t *)v345);
                function_2251c(result + 408, v345);
                *(char *)(result + 440) = 66;
                return result;
            }
            // 0x1560c
            v339 = v300;
            if (g122 == 0) {
                // 0x150e0
                v219 = v339;
                goto lab_0x150e0_2;
            } else {
                // 0x1561c
                __asm_vstr(v217, *(int32_t *)(result + 376));
                int32_t v346 = result + 400; // 0x15640
                function_2220c(result + 160, &g148, 32, (int32_t)"cgminer.c", (int32_t)"get_benchmark_work", 0x10ca);
                *(char *)(result + 282) = 1;
                *(int32_t *)(result + 244) = 0;
                *(int32_t *)(result + 260) = *(int32_t *)g202;
                function_1f5c4((int32_t *)v346);
                function_2251c(result + 408, v346);
                *(char *)(result + 440) = 66;
                v343 = v346;
                if (*(char *)&g71 == 0) {
                    goto lab_0x156f8;
                } else {
                    // 0x15694
                    if (*(char *)&g179 == 0) {
                        // 0x156a4
                        v343 = v346;
                        if (*(char *)&g70 == 0 == g28 < (char *)7) {
                            goto lab_0x156f8;
                        } else {
                            goto lab_0x156d4;
                        }
                    } else {
                        goto lab_0x156d4;
                    }
                }
            }
        } else {
            int32_t v347 = result; // 0x15888
            function_31d90(v299, v347);
            v344 = v347;
            if (*(char *)&g71 == 0) {
                goto lab_0x15908;
            } else {
                // 0x1589c
                if (*(char *)&g179 == 0) {
                    // 0x158ac
                    v344 = v347;
                    if (*(char *)&g70 == 0 == g28 < (char *)7) {
                        goto lab_0x15908;
                    } else {
                        goto lab_0x158d0;
                    }
                } else {
                    goto lab_0x158d0;
                }
            }
        }
    }
  lab_0x159f0:
    // 0x159f0
    function_1f5c4(&g92);
    if (pthread_rwlock_rdlock(&g222) != 0) {
        // 0x15d10
        v212 = (char *)0x15a3;
        v213 = "signal_work_update";
        v214 = __errno_location();
        format = (int32_t)"WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d";
        goto lab_0x15954;
    }
    int32_t v348 = g261; // 0x15a14
    int32_t v349 = g208; // 0x15a1c
    int32_t v350 = 0; // 0x15a34
    if (v348 > 0) {
        int32_t v351 = v350 + 1; // 0x15a28
        *(char *)(*(int32_t *)(4 * v350 + v349) + 63) = 1;
        v350 = v351;
        while (v351 < v348) {
            // 0x15a24
            v351 = v350 + 1;
            *(char *)(*(int32_t *)(4 * v350 + v349) + 63) = 1;
            v350 = v351;
        }
    }
    // 0x15a38
    if (pthread_rwlock_unlock(&g222) != 0) {
        // 0x15d3c
        v212 = (char *)0x15aa;
        v213 = "signal_work_update";
        v214 = __errno_location();
        format = (int32_t)"WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d";
        goto lab_0x15954;
    }
    // 0x15a4c
    function_1da28();
    v220 = v348;
    goto lab_0x150f0;
  lab_0x15908:
    // 0x15908
    function_39848(result);
    result = 0;
    pthread_mutex_unlock((int32_t *)((int32_t)&g140 - 12));
    // 0x150e0
    v219 = v344;
    goto lab_0x150e0_2;
  lab_0x156f8:
    // 0x156f8
    function_39848(result);
    result = 0;
    // 0x150e0
    v219 = v343;
    goto lab_0x150e0_2;
  lab_0x158d0:
    // 0x158d0
    str2 = 0x656e6547;
    fd = (char *)0x65746172;
    v26 = (char *)0x6f77206d;
    function_1ccec(7, &str2, 0);
    v344 = v218;
    goto lab_0x15908;
  lab_0x156d4:
    // 0x156d4
    str2 = 0x656e6547;
    fd = (char *)0x65746172;
    v26 = (char *)0x206b7261;
    function_1ccec(7, &str2, 0);
    v343 = v218;
    goto lab_0x156f8;
  lab_0x15c48:;
    // 0x15c48
    int32_t v240; // 0x15c28
    int32_t v352 = *(int32_t *)(v240 + 176); // 0x15c48
    int32_t v353 = *(int32_t *)(v240 + 172); // 0x15c60
    int32_t v354 = *(int32_t *)(v240 + 164); // 0x15c68
    int32_t v239; // 0x12648
    snprintf((char *)&str2, 2048, "Pool: %d  URL: %s  User: %s  Password: %s", v239, (char *)v354, (char *)v353, (char *)v352);
    function_1ccec(4, &str2, 0);
    char * v241 = g188; // 0x15c80
    goto lab_0x15c84;
  lab_0x15c84:;
    int32_t v355 = v239 + 1; // 0x15c84
    char * v237 = v241; // 0x15c90
    int32_t v238 = v355; // 0x15c90
    if (v355 >= (int32_t)v241) {
        // break -> 0x15c94
        goto lab_0x15c94;
    }
    goto lab_0x15c18;
  lab_0x14560:
    // 0x14560
    if (*(char *)&g71 == 0) {
        // 0x145c8
        sleep(1);
        goto lab_0x14428;
    } else {
        // 0x1456c
        if (*(char *)&g179 == 0) {
            char v356 = *(char *)&g70; // 0x1457c
            char * v357 = g28; // 0x1458c
            if (v356 == 0 == v357 < (char *)7) {
                // 0x145c8
                sleep(1);
                goto lab_0x14428;
            } else {
                goto lab_0x14598;
            }
        } else {
            goto lab_0x14598;
        }
    }
  lab_0x1451c:
    // 0x1451c
    str2 = 0x76206f4e;
    fd = (char *)0x64696c61;
    v26 = (char *)0x61656c70;
    function_1ccec(5, &str2, 0);
    // 0x14554
    g154 = 1;
    goto lab_0x14560;
  lab_0x14598:
    // 0x14598
    str2 = 0x63656863;
    fd = (char *)0x6f6e206b;
    v26 = (char *)0x73752064;
    function_1ccec(7, &str2, 0);
    // 0x145c8
    sleep(1);
    goto lab_0x14428;
  lab_0x13d14:;
    // 0x13d14
    int32_t v358; // 0x12648
    int32_t v359 = v358 + 1; // 0x13d14
    int32_t v360 = v359; // 0x13d1c
    int32_t v361; // 0x13cb4
    int32_t v362 = v361; // 0x13d1c
    int32_t v363 = (int32_t)&g73; // 0x13d1c
    if (v359 == 65) {
        // break -> 0x13d20
        goto lab_0x13d20_3;
    }
    goto lab_0x13c88;
  lab_0x13c04:
    // 0x13c04
    snprintf((char *)&str2, 2048, "Log work open asic %d file %s", g149, &str3);
    function_1ccec(3, &str2, 0);
    goto lab_0x13c40;
  lab_0x13c40:;
    // 0x13c40
    int32_t v365; // 0x12648
    int32_t v366 = v365 + 1; // 0x13c40
    int32_t v367 = g149; // 0x13c4c
    v365 = v366;
    int32_t v368 = &g160; // 0x13c4c
    if (g149 < v366) {
        // break -> 0x13c50
        goto lab_0x13c50;
    }
    goto lab_0x13ba4;
  lab_0x12718:
    // 0x12718
    if (fgets((char *)&str3, 256, stream) == NULL) {
        // break -> 0x1282c
        goto lab_0x1282c;
    }
    goto lab_0x12734;
  lab_0x12774:
    // 0x12774
    snprintf((char *)&str2, 2048, "pidof %s command result is: %s\n", NULL, &str3);
    function_1ccec(7, &str2, 0);
    if (*(char *)&g71 == 0) {
        goto lab_0x12718;
    } else {
        // 0x127bc
        if (*(char *)&g179 == 0) {
            // 0x127bc
            v3 = 0x66640;
            goto lab_0x127d0;
        } else {
            goto lab_0x127f8;
        }
    }
  lab_0x127d0:
    // 0x127d0
    if (g28 < (char *)7 == *(char *)v3 == 0) {
        goto lab_0x12718;
    } else {
        goto lab_0x127f8;
    }
  lab_0x127f8:;
    int32_t len5 = strlen((char *)&str3); // 0x12800
    snprintf((char *)&str2, 2048, "strlen is: %d\n", len5);
    function_1ccec(7, &str2, 0);
    goto lab_0x12718;
  lab_0x13dd0:
    // 0x13dd0
    str2 = 0x6c696146;
    fd = (char *)0x74206465;
    v26 = v28;
    function_1ccec(3, &str2, 1);
    function_2ab30(1, 0);
    // UNREACHABLE
  lab_0x139e8:
    // 0x139e8
    v30 = g76;
    v32 = v31;
    v363 = v31;
    if (g76 == NULL) {
        goto lab_0x13d20_3;
    } else {
        goto lab_0x139f8;
    }
  lab_0x13d20_3:;
    char v370 = *(char *)&g70; // 0x13d30
    if ((v370 | *(char *)&g179) == 0) {
        // 0x13d20
        v29 = v370;
        v33 = v363;
        goto lab_0x135e4;
    } else {
        goto lab_0x13d3c;
    }
  lab_0x139f8:;
    int32_t v371 = v32;
    memset(&str3, 0, 256);
    int32_t v372; // 0x12648
    int32_t v373; // 0x12648
    int32_t v374; // 0x12648
    if (g75 == NULL) {
        char v375 = *(char *)&g70; // 0x13eb8
        v373 = v371;
        if ((v375 | *(char *)&g179) == 0 != g28 < (char *)3) {
            // 0x13ed8
            snprintf((char *)&str2, 2048, "Log work path: %s", v30);
            function_1ccec(3, &str2, 0);
            v373 = &str2;
        }
        goto lab_0x13acc;
    } else {
        // 0x13a1c
        if (*g75 == 0) {
            // 0x14028
            v372 = (int32_t)"Log work asic num empty";
            v374 = &str2;
            goto lab_0x14038;
        } else {
            int32_t str_as_l2 = strtol(g75, NULL, 10); // 0x13a30
            if (str_as_l2 == 1) {
                // .thread
                g149 = 1;
            } else {
                g149 = str_as_l2;
                if ((str_as_l2 - 32 & -33) != 0) {
                    // 0x142f8
                    str2 = 0x20676f4c;
                    fd = (char *)0x6b726f77;
                    v26 = (char *)0x756d206d;
                    function_1ccec(3, &str2, 1);
                    function_2ab30(1, 1);
                    // UNREACHABLE
                }
            }
            char v376 = *(char *)&g70; // 0x13a70
            v373 = v371;
            if ((v376 | *(char *)&g179) == 0 != g28 < (char *)3) {
                // 0x13a90
                snprintf((char *)&str2, 2048, "Log work path: %s Asic num: %s", g76, g75);
                function_1ccec(3, &str2, 0);
                v373 = &str2;
            }
            goto lab_0x13acc;
        }
    }
  lab_0x13d3c:
    // 0x13d3c
    snprintf((char *)&str2, 2048, "Started %s", (char *)&g81);
    function_1ccec(4, &str2, 0);
    char * v377 = g83; // 0x13d70
    char v378; // 0x12648
    int32_t v379; // 0x12648
    int32_t v380; // 0x12648
    if (v377 == NULL) {
        goto lab_0x136e0;
    } else {
        // 0x13d7c
        v380 = &str2;
        char v381 = *(char *)&g70; // 0x13d8c
        if ((v381 | *(char *)&g179) == 0) {
            // 0x13600
            v379 = v380;
            v378 = v381;
            if (g28 < (char *)5) {
                goto lab_0x142e4;
            } else {
                goto lab_0x13614;
            }
        } else {
            goto lab_0x13614;
        }
    }
  lab_0x135e4:
    // 0x135e4
    if (g28 > (char *)3) {
        goto lab_0x13d3c;
    } else {
        // 0x135f0
        v379 = v33;
        v378 = v29;
        if (g83 == NULL) {
            goto lab_0x136e0;
        } else {
            goto lab_0x142e4;
        }
    }
  lab_0x136e0:;
    char * str7 = g262; // 0x136e4
    *(int16_t *)(strlen(str7) + (int32_t)str7) = 47;
    if (g234 == 0) {
        // 0x13fe8
        if (*(char *)&g70 == 0) {
            // 0x13ff8
            setlogmask(63);
            goto lab_0x13724;
        } else {
            // 0x1371c
            setlogmask(255);
            goto lab_0x13724;
        }
    } else {
        // 0x13710
        *(char *)&g70 = 1;
        // 0x1371c
        setlogmask(255);
        goto lab_0x13724;
    }
  lab_0x13acc:
    // 0x13acc
    sprintf((char *)&str3, "%s.txt", g76);
    g150 = fopen64((char *)&str3, "a+");
    int32_t v382; // 0x12648
    if (*(char *)&g179 == 0) {
        // 0x13b10
        v382 = v373;
        if (*(char *)&g70 == 0 == g28 < (char *)3) {
            goto lab_0x13b68;
        } else {
            goto lab_0x13b34;
        }
    } else {
        goto lab_0x13b34;
    }
  lab_0x13614:
    // 0x13614
    snprintf((char *)&str2, 2048, "Loaded configuration file %s", v377);
    function_1ccec(5, &str2, 0);
    int32_t v383 = v380; // 0x13644
    char v384; // 0x12648
    int32_t v385; // 0x12648
    int32_t v386; // 0x12648
    if (g87 == -1) {
        // 0x140cc
        v386 = v380;
        if (*(char *)&g179 == 0) {
            // 0x140cc
            v384 = *(char *)&g70;
            v385 = v380;
            goto lab_0x140d8;
        } else {
            goto lab_0x1416c;
        }
    } else {
        goto lab_0x13648;
    }
  lab_0x13b34:
    // 0x13b34
    snprintf((char *)&str2, 2048, "Log work open file %s", &str3);
    function_1ccec(3, &str2, 0);
    v382 = &str2;
    goto lab_0x13b68;
  lab_0x14038:
    // 0x14038
    *(int32_t *)v374 = *(int32_t *)v372;
    *(int32_t *)(v374 + 4) = *(int32_t *)(v372 + 4);
    *(int32_t *)(v374 + 8) = *(int32_t *)(v372 + 8);
    *(int32_t *)(v374 + 12) = *(int32_t *)(v372 + 12);
    *(int32_t *)(v374 + 16) = *(int32_t *)(v372 + 16);
    *(int32_t *)(v374 + 20) = *(int32_t *)(v372 + 20);
    // 0x14054
    function_1ccec(3, &str2, 1);
    function_2ab30(1, 1);
    // UNREACHABLE
  lab_0x142e4:
    // 0x142e4
    v383 = v379;
    v384 = v378;
    v385 = v379;
    if (g87 == -1) {
        goto lab_0x140d8;
    } else {
        goto lab_0x13648;
    }
  lab_0x13648:;
    // 0x13648
    int32_t v408; // 0x12648
    int32_t v409; // 0x12648
    int32_t v410; // 0x12648
    if (g87 == 0) {
        char v444 = *(char *)&g70; // 0x13660
        v408 = (int32_t)&g28;
        v410 = v383;
        if ((v444 | *(char *)&g179) != 0 || g28 > (char *)3) {
            int32_t v445 = &str2; // 0x14074
            str2 = 0x61746146;
            fd = (char *)0x534a206c;
            v26 = (char *)0x206e6920;
            function_1ccec(4, &str2, 0);
            v408 = 0x657b8;
            v410 = v445;
            v409 = v445;
            if ((*(char *)&g70 | *(char *)&g179) == 0) {
                goto lab_0x13680;
            } else {
                goto lab_0x13694;
            }
        } else {
            goto lab_0x13680;
        }
    } else {
        goto lab_0x136cc;
    }
  lab_0x13b68:;
    int32_t v387 = v382;
    if (g149 == 1) {
        // 0x14238
        sprintf((char *)&str3, "%s%02d.txt", g76, 1);
        g151 = fopen64((char *)&str3, "a+");
        char v388 = *(char *)&g70; // 0x14280
        v368 = v387;
        if ((v388 | *(char *)&g179) == 0 != g28 < (char *)3) {
            // 0x142a0
            snprintf((char *)&str2, 2048, "Log work open asic %d file %s", g149, &str3);
            function_1ccec(3, &str2, 0);
            v368 = &str2;
        }
    } else {
        // 0x13b78
        v368 = v387;
        if ((g149 - 32 & -33) == 0) {
            // 0x13c44
            v368 = &g160;
            if (g149 >= 0) {
                // 0x13ba4
                v367 = g149;
                v365 = 0;
                while (true) {
                  lab_0x13ba4:
                    // 0x13ba4
                    sprintf((char *)&str3, "%s%02d_%02d.txt", g76, v367, v365);
                    struct _IO_FILE * v369 = fopen64((char *)&str3, "a+"); // 0x13bcc
                    *(int32_t *)(4 * v365 + (int32_t)&g151) = (int32_t)v369;
                    if (*(char *)&g179 == 0) {
                        // 0x13be0
                        if (*(char *)&g70 == 0 == g28 < (char *)3) {
                            goto lab_0x13c40;
                        } else {
                            goto lab_0x13c04;
                        }
                    } else {
                        goto lab_0x13c04;
                    }
                }
            }
        }
    }
  lab_0x13c50:
    // 0x13c50
    v363 = v368;
    if (g152 != 0) {
        // 0x13c88
        v360 = 0;
        v362 = &g152;
        while (true) {
          lab_0x13c88:
            // 0x13c88
            v358 = v360;
            sprintf((char *)&str3, "%s_diff_%02d.txt", g76, v358);
            struct _IO_FILE * v364 = fopen64((char *)&str3, "a+"); // 0x13cac
            v361 = v362 + 4;
            *(int32_t *)v361 = (int32_t)v364;
            if (*(char *)&g179 == 0) {
                // 0x13cc0
                if (*(char *)&g70 == 0 == g28 < (char *)3) {
                    goto lab_0x13d14;
                } else {
                    // 0x13ce4
                    snprintf((char *)&str2, 2048, "Log work open diff file %s", &str3);
                    function_1ccec(3, &str2, 0);
                    goto lab_0x13d14;
                }
            } else {
                // 0x13ce4
                snprintf((char *)&str2, 2048, "Log work open diff file %s", &str3);
                function_1ccec(3, &str2, 0);
                goto lab_0x13d14;
            }
        }
    }
    goto lab_0x13d20_3;
  lab_0x140d8:;
    // 0x140d8
    char * v389; // 0x12648
    int32_t v390; // 0x12648
    if (g28 > (char *)3 || v384 != 0) {
        // 0x14164
        v386 = &str2;
        goto lab_0x1416c;
    } else {
        // 0x140fc
        v389 = g28;
        v390 = v385;
        if (*(char *)&g246 == 0) {
            goto lab_0x136cc;
        } else {
            goto lab_0x14110;
        }
    }
  lab_0x13724:
    // 0x13724
    if (g46 < 0) {
        g46 = 60;
    }
    function_3abdc((int32_t)&g175);
    function_3abdc((int32_t)&g174);
    function_3abdc((int32_t)&g176);
    function_3abdc((int32_t)&g52);
    function_41f98();
    g261 = 0;
    int32_t v391 = 0; // 0x137f4
    char * v392 = g228; // 0x137f4
    int32_t v393 = (int32_t)g228; // 0x137f4
    if (g228 > NULL) {
        int32_t v394 = v391 + 1; // 0x137e4
        function_3ae24(*(int32_t *)(g217 + 4 * v391));
        int32_t v395 = (int32_t)g228; // 0x137ec
        v391 = v394;
        v392 = g228;
        v393 = v395;
        while (v394 < v395) {
            // 0x137dc
            v394 = v391 + 1;
            function_3ae24(*(int32_t *)(g217 + 4 * v391));
            v395 = (int32_t)g228;
            v391 = v394;
            v392 = g228;
            v393 = v395;
        }
    }
    // 0x137f8
    if (v392 == NULL) {
        // 0x141e8
        str2 = 0x206c6c41;
        fd = (char *)0x69766564;
        v26 = (char *)0x64656c62;
        function_1ccec(3, &str2, 1);
        function_2ab30(1, v393);
        // UNREACHABLE
    }
    // 0x13800
    g139 = v392;
    int32_t v396; // 0x12648
    int32_t v397; // 0x12648
    int32_t v398; // 0x12648
    if (g90 == NULL) {
        // 0x14340
        if (pthread_rwlock_rdlock(&g227) != 0) {
            // 0x14ce4
            function_2c5c0("load_temp_cutoffs", 1369);
            // UNREACHABLE
        }
        int32_t v399 = 0; // 0x1438c
        if (g228 > NULL) {
            int32_t * v400 = (int32_t *)(*(int32_t *)(4 * v399 + g217) + 184); // 0x1437c
            if (*v400 == 0) {
                *v400 = 95;
            }
            int32_t v401 = v399 + 1; // 0x14378
            v399 = v401;
            while (v401 < (int32_t)g228) {
                // 0x14374
                v400 = (int32_t *)(*(int32_t *)(4 * v399 + g217) + 184);
                if (*v400 == 0) {
                    *v400 = 95;
                }
                // 0x14388
                v401 = v399 + 1;
                v399 = v401;
            }
        }
        // 0x14390
        function_2c008(&g227, "load_temp_cutoffs", 1378);
        v398 = &g217;
        goto lab_0x143a4;
    } else {
        char * next_token = strtok(g90, ","); // 0x13840
        char * str8 = next_token; // 0x13848
        int32_t v402 = 0; // 0x13848
        v397 = 0;
        v396 = 0;
        if (next_token != NULL) {
            while (v402 < (int32_t)g228) {
                int32_t str_as_l3 = strtol(str8, NULL, 10); // 0x13864
                if (str_as_l3 >= 200 == (str_as_l3 != 200)) {
                    // 0x14788
                    str2 = 0x61766e49;
                    fd = (char *)0x2064696c;
                    v372 = (int32_t)"ssed to set temp cutoff";
                    v374 = (int32_t)&v26;
                    goto lab_0x14038;
                }
                // 0x13874
                if (pthread_rwlock_rdlock(&g227) != 0) {
                    // 0x14c84
                    function_2c5c0("load_temp_cutoffs", 1362);
                    // UNREACHABLE
                }
                // 0x13884
                *(int32_t *)(*(int32_t *)(g217 + 4 * v402) + 184) = str_as_l3;
                if (pthread_rwlock_unlock(&g227) != 0) {
                    int32_t v403 = *__errno_location(); // 0x14d1c
                    snprintf((char *)&str2, 2048, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", v403, "cgminer.c", "load_temp_cutoffs", 1364);
                    goto lab_0x14054;
                }
                int32_t v404 = v402 + 1; // 0x138a4
                function_1da28();
                char * next_token2 = strtok(NULL, ","); // 0x138b8
                str8 = next_token2;
                v402 = v404;
                if (next_token2 == NULL) {
                    // 0x148bc
                    v398 = (int32_t)&g171 | 0x2ec0;
                    v397 = str_as_l3;
                    v396 = v404;
                    if (v404 < 2) {
                        goto lab_0x14d5c;
                    } else {
                        goto lab_0x143a4;
                    }
                }
            }
            // 0x1473c
            str2 = 0x206f6f54;
            fd = (char *)0x796e616d;
            v26 = (char *)0x73736170;
            function_1ccec(3, &str2, 1);
            function_2ab30(1, 1);
            // UNREACHABLE
        }
        goto lab_0x14d5c;
    }
  lab_0x1416c:
    // 0x1416c
    str2 = 0x6f727245;
    fd = (char *)0x6e692072;
    v26 = (char *)0x69746172;
    function_1ccec(4, &str2, 0);
    int32_t v405; // 0x12648
    if (*(char *)&g246 == 0) {
        goto lab_0x136cc;
    } else {
        int32_t v406 = v386;
        v405 = v406;
        if ((*(char *)&g70 | *(char *)&g179) == 0) {
            // 0x141c0
            v389 = g28;
            v390 = v406;
            goto lab_0x14110;
        } else {
            goto lab_0x14124;
        }
    }
  lab_0x136cc:
    // 0x136cc
    free((int32_t *)g83);
    g83 = NULL;
    goto lab_0x136e0;
  lab_0x13680:;
    int32_t v407 = *(int32_t *)v408; // 0x13680
    v409 = (v407 > 3 ? (int32_t)&fd : v410) - 4;
    if (v407 > 3) {
        goto lab_0x13694;
    } else {
        goto lab_0x136cc;
    }
  lab_0x14110:;
    int32_t v411 = v389 > (char *)3 ? (int32_t)&fd : v390;
    v405 = v411 - 4;
    if (v389 > (char *)3) {
        goto lab_0x14124;
    } else {
        goto lab_0x136cc;
    }
  lab_0x143a4:;
    int32_t * v229 = (int32_t *)v398; // 0x143b8
    int32_t v412 = *v229; // 0x143b8
    int32_t v413 = 0; // 0x143d4
    if (g228 > NULL) {
        int32_t v414 = v413 + 1; // 0x143c8
        *(int32_t *)(*(int32_t *)(4 * v413 + v412) + 312) = 0x5f5e0ff;
        v413 = v414;
        while (v414 < (int32_t)g228) {
            // 0x143c4
            v414 = v413 + 1;
            *(int32_t *)(*(int32_t *)(4 * v413 + v412) + 312) = 0x5f5e0ff;
            v413 = v414;
        }
    }
    // 0x143d8
    if (g245 == 0) {
        int32_t v415 = g245 == 0 ? (int32_t)&g160 : 0x5f5e0ff;
        int32_t * v416 = (int32_t *)(v415 - 652);
        *v416 = *(int32_t *)(v415 - 1200) + *v416;
    }
    while (true) {
      lab_0x14428:
        // 0x14428
        v194 = g188;
        v192 = 0;
        v195 = 0;
        if (g188 > NULL) {
            while (true) {
              lab_0x14434:;
                int32_t v196 = v195;
                char * v197 = v194;
                int32_t v198 = *(int32_t *)(g202 + 4 * v192); // 0x14438
                v190 = v197;
                v188 = v196;
                if (*(char *)*(int32_t *)(v198 + 164) == 0) {
                    goto lab_0x144c8;
                } else {
                    char v199 = *(char *)*(int32_t *)(v198 + 172); // 0x14450
                    v200 = v196 + (int32_t)(v199 != 0);
                    v190 = v197;
                    v188 = v200;
                    if (v199 != 0 | *(char *)&g71 == 0) {
                        goto lab_0x144c8;
                    } else {
                        // 0x1446c
                        if (*(char *)&g179 == 0) {
                            // 0x14478
                            v190 = v197;
                            v188 = v200;
                            if (*(char *)&g70 == 0 == g28 < (char *)7) {
                                goto lab_0x144c8;
                            } else {
                                goto lab_0x14498;
                            }
                        } else {
                            goto lab_0x14498;
                        }
                    }
                }
            }
          lab_0x144d8:
            if (v189 != 0) {
                // break -> 0x145d4
                break;
            }
        }
        // 0x144e0
        if (g154 == 0) {
            // 0x144f0
            if (*(char *)&g179 == 0) {
                // 0x144fc
                if (*(char *)&g70 == 0 == g28 < (char *)5) {
                    // 0x14554
                    g154 = 1;
                    goto lab_0x14560;
                } else {
                    goto lab_0x1451c;
                }
            } else {
                goto lab_0x1451c;
            }
        } else {
            goto lab_0x14560;
        }
    }
    if (v191 == NULL) {
        // 0x145dc
        if (*(char *)&g179 == 0) {
            // 0x145e8
            if (*(char *)&g70 == 0 == g28 < (char *)4) {
                goto lab_0x14644;
            } else {
                goto lab_0x1460c;
            }
        } else {
            goto lab_0x1460c;
        }
    } else {
        // 0x146a8
        if (v191 > NULL) {
            int32_t v417 = 0;
            int32_t v418 = *(int32_t *)(4 * v417 + g202); // 0x146bc
            int32_t * v419 = (int32_t *)(v418 + 168); // 0x146c0
            *(int32_t *)(v418 + 404) = 0x5f5e0ff;
            *(int32_t *)(v418 + 440) = 0x5f5e0ff;
            int32_t * str10; // 0x146d4
            int32_t * v420; // 0x146e0
            int32_t str9; // 0x146e0
            int32_t v421; // 0x14c90
            int32_t size; // 0x14704
            int32_t str11; // 0x14714
            int32_t v422; // 0x14718
            int32_t v423; // 0x14730
            if (*v419 == 0) {
                // 0x146d4
                str10 = (int32_t *)(v418 + 176);
                if (*str10 == 0) {
                    // 0x14cd0
                    *str10 = (int32_t)calloc(1, 1);
                }
                // 0x146e0
                v420 = (int32_t *)(v418 + 172);
                str9 = *v420;
                if (str9 == 0) {
                    // 0x14c90
                    v421 = *(int32_t *)(v418 + 164);
                    snprintf((char *)&str2, 2048, "No login credentials supplied for pool %u %s", v417, (char *)v421);
                    function_1ccec(3, &str2, 1);
                    function_2ab30(1, 0);
                    // UNREACHABLE
                }
                // 0x146ec
                size = strlen((char *)str9) + 2 + strlen((char *)*str10);
                str11 = function_1e74c(size, "cgminer.c", "main", 0x30c1);
                v422 = *str10;
                *v419 = str11;
                v423 = *v420;
                snprintf((char *)str11, size, "%s:%s", (char *)v423, (char *)v422);
            }
            int32_t v424 = v417 + 1; // 0x146a4
            while (v424 < (int32_t)g188) {
                // 0x146bc
                v417 = v424;
                v418 = *(int32_t *)(4 * v417 + g202);
                v419 = (int32_t *)(v418 + 168);
                *(int32_t *)(v418 + 404) = 0x5f5e0ff;
                *(int32_t *)(v418 + 440) = 0x5f5e0ff;
                if (*v419 == 0) {
                    // 0x146d4
                    str10 = (int32_t *)(v418 + 176);
                    if (*str10 == 0) {
                        // 0x14cd0
                        *str10 = (int32_t)calloc(1, 1);
                    }
                    // 0x146e0
                    v420 = (int32_t *)(v418 + 172);
                    str9 = *v420;
                    if (str9 == 0) {
                        // 0x14c90
                        v421 = *(int32_t *)(v418 + 164);
                        snprintf((char *)&str2, 2048, "No login credentials supplied for pool %u %s", v417, (char *)v421);
                        function_1ccec(3, &str2, 1);
                        function_2ab30(1, 0);
                        // UNREACHABLE
                    }
                    // 0x146ec
                    size = strlen((char *)str9) + 2 + strlen((char *)*str10);
                    str11 = function_1e74c(size, "cgminer.c", "main", 0x30c1);
                    v422 = *str10;
                    *v419 = str11;
                    v423 = *v420;
                    snprintf((char *)str11, size, "%s:%s", (char *)v423, (char *)v422);
                }
                // 0x146a4
                v424 = v417 + 1;
            }
        }
        // 0x147a4
        g109 = *(int32_t *)g202;
        if (*(char *)&g179 != 0) {
            // 0x147bc
            openlog("cgminer", LOG_PID, LOG_USER);
        }
        // 0x147d0
        if (g155 != 0) {
            // 0x147e0
            fds[0] = &str2;
            if (pipe(fds) < 0) {
                // 0x14e00
                perror("pipe - failed to create pipe for --monitor");
                exit(1);
                // UNREACHABLE
            }
            // 0x147f0
            fflush(g61);
            if (dup2((int32_t)fd, 2) < 0) {
                // 0x14e28
                perror("dup2 - failed to alias stderr to write end of pipe for --monitor");
                exit(1);
                // UNREACHABLE
            }
            // 0x14814
            if (close((int32_t)fd) < 0) {
                // 0x14e14
                perror("close - failed to close write end of pipe for --monitor");
                exit(1);
                // UNREACHABLE
            }
            void (*prev_sig_handler)(int32_t) = signal(SIGPIPE, SIG_IGN); // 0x1482c
            if (prev_sig_handler == (void (*)(int32_t))-1 | signal(SIGPIPE, SIG_IGN) == (void (*)(int32_t))-1) {
                // 0x14dd8
                perror("signal - failed to edit signal mask for --monitor");
                exit(1);
                // UNREACHABLE
            }
            int32_t v425 = fork(); // 0x1484c
            g95 = v425;
            if (v425 < 0) {
                // 0x14dc4
                perror("fork - failed to fork child process for --monitor");
                exit(1);
                // UNREACHABLE
            }
            int32_t fd2 = str2; // 0x14864
            if (v425 == 0) {
                // 0x1486c
                if (dup2(fd2, 0) < 0) {
                    // 0x14dec
                    perror("dup2 - in child, failed to alias read end of pipe to stdin for --monitor");
                    exit(1);
                    // UNREACHABLE
                }
                // 0x1487c
                close(str2);
                execl("/bin/bash", "/bin/bash");
                perror("execl - in child failed to exec user specified command for --monitor");
                exit(1);
                // UNREACHABLE
            }
            // 0x14d3c
            if (close(fd2) < 0) {
                // 0x14d48
                perror("close - failed to close read end of pipe for --monitor");
                exit(1);
                // UNREACHABLE
            }
        }
        int32_t v426 = function_1e7d4(g261, 4, "cgminer.c", "main", 0x30d2); // 0x1490c
        g208 = v426;
        if (g261 > 0) {
            // 0x14920
            *(int32_t *)v426 = function_1e7d4(1, 64, "cgminer.c", "main", 0x30d6);
            int32_t v427 = 1; // 0x14954
            if (g261 > 1) {
                int32_t v428 = function_1e7d4(1, 64, "cgminer.c", "main", 0x30d6); // 0x1493c
                *(int32_t *)(4 * v427 + g208) = v428;
                int32_t v429 = v427 + 1; // 0x14944
                v427 = v429;
                while (g261 > v429) {
                    // 0x14920
                    v428 = function_1e7d4(1, 64, "cgminer.c", "main", 0x30d6);
                    *(int32_t *)(4 * v427 + g208) = v428;
                    v429 = v427 + 1;
                    v427 = v429;
                }
            }
        }
        // 0x14974
        if (g228 > NULL) {
            int32_t v430 = 0; // 0x14adc
            char * v431 = NULL; // 0x12648
            while (true) {
                int32_t v210 = *(int32_t *)(*v229 + 4 * v430); // 0x149ac
                v207 = (int32_t *)(v210 + 148);
                int32_t v432 = function_1e74c(4 * *v207 + 4, "cgminer.c", "main", 0x30df); // 0x149bc
                int32_t * v211 = (int32_t *)(v210 + 152); // 0x149c8
                *v211 = v432;
                *(int32_t *)(4 * *v207 + v432) = 0;
                *(int32_t *)(v210 + 96) = 4;
                v203 = (int32_t)v431;
                v206 = v203;
                if (*v207 > 0) {
                    // 0x149e8
                    v205 = v203;
                    v201 = 0;
                    while (true) {
                      lab_0x149e8:
                        // 0x149e8
                        v208 = function_2df8c(v205);
                        v209 = (int32_t *)v208;
                        *v209 = v205;
                        *(int32_t *)(v208 + 36) = v210;
                        *(int32_t *)(v208 + 4) = v201;
                        if (v208 == 0) {
                            goto lab_0x14acc;
                        } else {
                            // 0x14a14
                            if (function_21e74(v208, &attr, 0x27834, v208) != 0) {
                                // 0x14ae8
                                snprintf((char *)&str2, 2048, "thread %d create failed", *v209);
                                function_1ccec(3, &str2, 1);
                                function_2ab30(1, 0);
                                // UNREACHABLE
                            }
                            // 0x14a34
                            *(int32_t *)(*v211 + 4 * v201) = v208;
                            if (*(int32_t *)(v210 + 32) == 1) {
                                goto lab_0x14acc;
                            } else {
                                // 0x14a48
                                if (*(char *)&g71 == 0) {
                                    // 0x14ab4
                                    function_21ebc(v208 + 16, "cgminer.c", "main", 0x30fb);
                                    goto lab_0x14acc;
                                } else {
                                    // 0x14a58
                                    if (*(char *)&g179 == 0) {
                                        // 0x14a68
                                        if (*(char *)&g70 == 0 == g28 < (char *)7) {
                                            // 0x14ab4
                                            function_21ebc(v208 + 16, "cgminer.c", "main", 0x30fb);
                                            goto lab_0x14acc;
                                        } else {
                                            goto lab_0x14a8c;
                                        }
                                    } else {
                                        goto lab_0x14a8c;
                                    }
                                }
                            }
                        }
                    }
                }
              lab_0x14ad4:
                // 0x14ad4
                v430++;
                v431 = (char *)v206;
                if (v430 >= (int32_t)g228) {
                    // break -> 0x14b1c
                    break;
                }
            }
        }
        // 0x14b1c
        if (g122 == 0 == g182 == NULL) {
            // 0x14e3c
            pthread_mutex_lock((int32_t *)((int32_t)&g140 - 12));
            int32_t v433 = 0; // 0x14e54
            if (g188 > NULL) {
                int32_t v434 = *(int32_t *)(g202 + 4 * v433); // 0x14e60
                int32_t v435 = v434 + 100; // 0x14e64
                if (*(int32_t *)v435 != 1) {
                    // 0x14e74
                    function_27998(v435);
                }
                int32_t v436 = v433 + 1; // 0x14e78
                *(char *)(v434 + 97) = 1;
                v433 = v436;
                while (v436 < (int32_t)g188) {
                    // 0x14e58
                    v434 = *(int32_t *)(g202 + 4 * v433);
                    v435 = v434 + 100;
                    if (*(int32_t *)v435 != 1) {
                        // 0x14e74
                        function_27998(v435);
                    }
                    // 0x14e78
                    v436 = v433 + 1;
                    *(char *)(v434 + 97) = 1;
                    v433 = v436;
                }
            }
            // 0x14e84
            if (*(char *)&g179 == 0) {
                // 0x14e90
                if (*(char *)&g70 == 0 == g28 < (char *)5) {
                    goto lab_0x14ee4;
                } else {
                    goto lab_0x14eb4;
                }
            } else {
                goto lab_0x14eb4;
            }
        } else {
            goto lab_0x14b44;
        }
    }
  lab_0x14d5c:
    // 0x14d5c
    if (pthread_rwlock_rdlock(&g227) != 0) {
        // 0x14db8
        function_2c5c0("load_temp_cutoffs", 1385);
        // UNREACHABLE
    }
    int32_t v437 = v397;
    int32_t v438 = (int32_t)g228; // 0x14d80
    int32_t v439 = *(int32_t *)((int32_t)&g171 | 0x2ec0); // 0x14d84
    int32_t v440 = v396; // 0x14d9c
    if (v396 < v438) {
        int32_t v441 = v440 + 1; // 0x14d90
        *(int32_t *)(*(int32_t *)(4 * v440 + v439) + 184) = v437;
        v440 = v441;
        while (v441 < v438) {
            // 0x14d8c
            v441 = v440 + 1;
            *(int32_t *)(*(int32_t *)(4 * v440 + v439) + 184) = v437;
            v440 = v441;
        }
    }
    // 0x14da0
    function_2c008(&g227, "load_temp_cutoffs", 1391);
    v398 = (int32_t)&g171 | 0x2ec0;
    goto lab_0x143a4;
  lab_0x14124:;
    int32_t * v442 = (int32_t *)v405; // 0x14134
    *v442 = 0x72617453;
    *(int32_t *)(v405 + 4) = 0x67632074;
    *(int32_t *)(v405 + 8) = 0x656e696d;
    *(int32_t *)(v405 + 12) = 0x69772072;
    *(int32_t *)(v405 + 16) = 0x2d206874;
    *(int32_t *)(v405 + 20) = 0x6f742054;
    *(int32_t *)(v405 + 24) = 0x65657320;
    *(int32_t *)(v405 + 28) = 0x61687720;
    *(int32_t *)(v405 + 32) = 0x61662074;
    *(int32_t *)(v405 + 36) = 0x64656c69;
    *(int32_t *)(v405 + 40) = 0x206f7420;
    *(int32_t *)(v405 + 44) = 0x64616f6c;
    *(int16_t *)(v405 + 48) = 46;
    function_1ccec(4, v442, 0);
    goto lab_0x136cc;
  lab_0x13694:;
    int32_t * v443 = (int32_t *)v409; // 0x136a4
    *v443 = 0x666e6f43;
    *(int32_t *)(v409 + 4) = 0x72756769;
    *(int32_t *)(v409 + 8) = 0x6f697461;
    *(int32_t *)(v409 + 12) = 0x6966206e;
    *(int32_t *)(v409 + 16) = 0x6320656c;
    *(int32_t *)(v409 + 20) = 0x646c756f;
    *(int32_t *)(v409 + 24) = 0x746f6e20;
    *(int32_t *)(v409 + 28) = 0x20656220;
    *(int32_t *)(v409 + 32) = 0x64657375;
    *(int16_t *)(v409 + 36) = 46;
    function_1ccec(4, v443, 0);
    goto lab_0x136cc;
  lab_0x1460c:
    // 0x1460c
    str2 = 0x6465654e;
    fd = (char *)0x206f7420;
    v26 = (char *)0x6c207461;
    function_1ccec(4, &str2, 0);
    goto lab_0x14644;
  lab_0x14b44:
    // 0x14b44
    *(int32_t *)&g177 = 0;
    g178 = 0;
    int32_t v226 = &g117; // 0x14b5c
    *(int32_t *)v226 = 0;
    *(int32_t *)(v226 + 4) = 0;
    int32_t v227 = v226 + 8; // 0x14b60
    v226 = v227;
    while (v227 != (int32_t)&g118) {
        // 0x14b60
        *(int32_t *)v226 = 0;
        *(int32_t *)(v226 + 4) = 0;
        v227 = v226 + 8;
        v226 = v227;
    }
    int32_t v228 = *v229; // 0x14b80
    g118 = 0;
    int32_t v230 = 0; // 0x14bac
    if (g228 > NULL) {
        int32_t v231 = *(int32_t *)(4 * v230 + v228); // 0x14b98
        int32_t v232 = v230 + 1; // 0x14b9c
        *(int32_t *)(v231 + 80) = 0;
        *(int32_t *)(v231 + 84) = 0;
        *(int32_t *)(v231 + 48) = 0;
        *(int32_t *)(v231 + 52) = 0;
        v230 = v232;
        while (v232 < (int32_t)g228) {
            // 0x14b98
            v231 = *(int32_t *)(4 * v230 + v228);
            v232 = v230 + 1;
            *(int32_t *)(v231 + 80) = 0;
            *(int32_t *)(v231 + 84) = 0;
            *(int32_t *)(v231 + 48) = 0;
            *(int32_t *)(v231 + 52) = 0;
            v230 = v232;
        }
    }
    // 0x14bb0
    function_1f5c4(&g103);
    function_1f5c4(&g102);
    function_1f5c4(&g116);
    function_28a64((int32_t *)&g104, 40, &g103);
    g106 = 3;
    if (function_21e74(g184 + 192, &attr, 0x30818, 0) != 0) {
        // 0x15a60
        str2 = 0x63746177;
        fd = (char *)0x6f6f7068;
        v26 = (char *)0x65726320;
        function_1ccec(3, &str2, 1);
        function_2ab30(1, 0);
        // UNREACHABLE
    }
    // 0x14c10
    pthread_detach(*(int32_t *)(g184 + 204));
    g107 = 4;
    if (function_21e74(g184 + 256, &attr, (int32_t)&g10, 0) != 0) {
        // 0x14fec
        str2 = 0x63746177;
        fd = (char *)0x676f6468;
        v26 = (char *)0x61657263;
        function_1ccec(3, &str2, 1);
        function_2ab30(1, 0);
        // UNREACHABLE
    }
    // 0x14c50
    pthread_detach(*(int32_t *)(g184 + 268));
    if (g147 != 8) {
        // 0x14c68
        snprintf((char *)&str2, 2048, "incorrect total_control_threads (%d) should be 8", g147);
        // 0x13f4c
        function_1ccec(3, &str2, 1);
        function_2ab30(1, 0);
        // UNREACHABLE
    }
    int32_t v233 = nice(-10); // 0x1502c
    int32_t v216 = &attr; // 0x15034
    if (v233 != 0 | *(char *)&g71 == 0) {
        goto lab_0x150b4;
    } else {
        // 0x1504c
        if (*(char *)&g179 == 0) {
            char v234 = *(char *)&g70; // 0x1505c
            char * v235 = g28; // 0x15070
            int32_t v236; // 0x14c2c
            v216 = v236;
            if (v234 == 0 == v235 < (char *)7) {
                goto lab_0x150b4;
            } else {
                goto lab_0x1507c;
            }
        } else {
            goto lab_0x1507c;
        }
    }
  lab_0x14644:
    // 0x14644
    str2 = 0x6c6f6f50;
    fd = (char *)0x74657320;
    v26 = (char *)100;
    function_1ccec(3, &str2, 1);
    function_2ab30(1, 0);
    // UNREACHABLE
  lab_0x14eb4:
    // 0x14eb4
    str2 = 0x626f7250;
    fd = (char *)0x20676e69;
    v26 = (char *)0x6576696c;
    function_1ccec(5, &str2, 0);
    goto lab_0x14ee4;
  lab_0x150b4:
    // 0x150b4
    v217 = __asm_vldr(0);
    __asm_vldr(0);
    v218 = &str2;
    v219 = v216;
    while (true) {
      lab_0x150e0_2:
        // 0x150e0
        v220 = v219;
        if (g241 == 0) {
            goto lab_0x150f0;
        } else {
            // 0x1598c
            if (*(char *)&g179 == 0) {
                // 0x1599c
                if (*(char *)&g70 == 0 == g28 < (char *)6) {
                    goto lab_0x159f0;
                } else {
                    goto lab_0x159c0;
                }
            } else {
                goto lab_0x159c0;
            }
        }
    }
  lab_0x15968:
    // 0x15968
    v212 = (char *)0x31a0;
    v213 = "main";
    v214 = __errno_location();
    format = (int32_t)"WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d";
    goto lab_0x15954;
  lab_0x14ee4:
    // 0x14ee4
    function_27704();
    pthread_mutex_unlock((int32_t *)((int32_t)&g140 - 12));
    int32_t v221 = 1; // 0x14ef8
    sleep(1);
    unsigned char v222 = *(char *)&g82; // 0x14f04
    int32_t v223 = v221; // 0x14f1c
    while (v221 != 180 && v222 % 2 == 0) {
        // 0x14ef4
        v221 = v223 + 1;
        sleep(1);
        v222 = *(char *)&g82;
        v223 = v221;
    }
    char * v224; // 0x12648
    if (v222 == 0) {
        // 0x14f50
        if (*(char *)&g179 == 0) {
            // 0x15b38
            v224 = g28;
            if (*(char *)&g70 == 0 == g28 < (char *)3) {
                goto lab_0x15cf4;
            } else {
                goto lab_0x15b50;
            }
        } else {
            goto lab_0x15b50;
        }
    } else {
        goto lab_0x15d68;
    }
  lab_0x15954:;
    int32_t v215 = *v214; // 0x15954
    snprintf((char *)&str2, 2048, (char *)format, v215, "cgminer.c", v213, (int32_t)v212);
  lab_0x14054:
    // 0x14054
    function_1ccec(3, &str2, 1);
    function_2ab30(1, 1);
    // UNREACHABLE
  lab_0x1507c:
    // 0x1507c
    str2 = 0x62616e55;
    fd = (char *)0x7420656c;
    v26 = (char *)0x64616572;
    function_1ccec(7, &str2, 0);
    v216 = &str2;
    goto lab_0x150b4;
  lab_0x15d68:
    // 0x15d68
    str3 = 0x6f67;
    int32_t len4; // 0x15de4
    if (*(char *)&g71 == 0) {
        // 0x15ddc
        len4 = strlen((char *)&str3);
        function_40e70(&str3, len4);
        goto lab_0x14b44;
    } else {
        // 0x15d80
        if (*(char *)&g179 == 0) {
            // 0x15d8c
            if (*(char *)&g70 == 0 == g28 < (char *)7) {
                // 0x15ddc
                len4 = strlen((char *)&str3);
                function_40e70(&str3, len4);
                goto lab_0x14b44;
            } else {
                goto lab_0x15db0;
            }
        } else {
            goto lab_0x15db0;
        }
    }
  lab_0x15b50:
    // 0x15b50
    str2 = 0x73206f4e;
    fd = (char *)0x65767265;
    v26 = (char *)0x6e756f66;
    function_1ccec(3, &str2, 0);
    if ((*(char *)&g70 | *(char *)&g179) == 0) {
        // 0x15cf4
        v224 = g28;
        goto lab_0x15cf4;
    } else {
        goto lab_0x15bb0;
    }
  lab_0x15cf4:;
    char * v225 = v224; // 0x15cfc
    if (v224 > (char *)2) {
        goto lab_0x15bb0;
    } else {
        goto lab_0x15d00;
    }
  lab_0x15bb0:
    // 0x15bb0
    memcpy(&str2, (int32_t *)"Please check the details from the list below of the servers you have input", 75);
    function_1ccec(3, &str2, 0);
    if ((*(char *)&g70 | *(char *)&g179) == 0) {
        // 0x15bb0
        v225 = g28;
        goto lab_0x15d00;
    } else {
        // 0x15bec
        memcpy(&str2, (int32_t *)"Most likely you have input the wrong URL, forgotten to add a port, or have not set up workers", 94);
        function_1ccec(3, &str2, 0);
        goto lab_0x15c10;
    }
  lab_0x15db0:
    // 0x15db0
    snprintf((char *)&str2, 2048, "check success, send %s", &str3);
    function_1ccec(7, &str2, 0);
    // 0x15ddc
    len4 = strlen((char *)&str3);
    function_40e70(&str3, len4);
    goto lab_0x14b44;
  lab_0x15d00:
    // 0x15d00
    if (v225 > (char *)2) {
        // 0x15bec
        memcpy(&str2, (int32_t *)"Most likely you have input the wrong URL, forgotten to add a port, or have not set up workers", 94);
        function_1ccec(3, &str2, 0);
        goto lab_0x15c10;
    } else {
        goto lab_0x15c10;
    }
  lab_0x15c10:
    // 0x15c10
    v237 = g188;
    v238 = 0;
    if (g188 > NULL) {
        while (true) {
          lab_0x15c18:
            // 0x15c18
            v239 = v238;
            v240 = *(int32_t *)(g202 + 4 * v239);
            if (*(char *)&g179 == 0) {
                // 0x15c30
                v241 = v237;
                if (*(char *)&g70 == 0 == g28 < (char *)4) {
                    goto lab_0x15c84;
                } else {
                    goto lab_0x15c48;
                }
            } else {
                goto lab_0x15c48;
            }
        }
    }
  lab_0x15c94:
    // 0x15c94
    if (*(char *)&g246 == 0) {
        goto lab_0x14f6c;
    } else {
        // 0x15ca8
        if (*(char *)&g179 == 0) {
            // 0x15cb4
            if (*(char *)&g70 == 0 == g28 < (char *)3) {
                goto lab_0x14fdc;
            } else {
                // 0x15ccc
                memcpy(&str2, (int32_t *)"Press any key to exit, or cgminer will wait indefinitely for an alive pool.", 76);
                function_1ccec(3, &str2, 0);
                goto lab_0x14f60;
            }
        } else {
            // 0x15ccc
            memcpy(&str2, (int32_t *)"Press any key to exit, or cgminer will wait indefinitely for an alive pool.", 76);
            function_1ccec(3, &str2, 0);
            goto lab_0x14f60;
        }
    }
  lab_0x14f6c:
    // 0x14f6c
    if (*(char *)&g71 == 0) {
        goto lab_0x14fdc;
    } else {
        // 0x14f7c
        if (*(char *)&g179 == 0) {
            // 0x14f88
            if (*(char *)&g70 == 0 == g28 < (char *)7) {
                goto lab_0x14fdc;
            } else {
                goto lab_0x14fa0;
            }
        } else {
            goto lab_0x14fa0;
        }
    }
  lab_0x14fdc:
    // 0x14fdc
    function_1f7f8(500);
    if (*(char *)&g82 == 0) {
        goto lab_0x14f60;
    } else {
        goto lab_0x15d68;
    }
  lab_0x14f60:
    // 0x14f60
    if (*(char *)&g246 == 0) {
        goto lab_0x14f6c;
    } else {
        goto lab_0x14fdc;
    }
  lab_0x14fa0:
    // 0x14fa0
    str2 = 0x73206f4e;
    fd = (char *)0x65767265;
    v26 = (char *)0x20656220;
    function_1ccec(7, &str2, 0);
    goto lab_0x14fdc;
}

// Address range: 0x15dfc - 0x15e20
int32_t entry_point(int32_t a1, int32_t a2) {
    // 0x15dfc
    int32_t v1; // 0x15dfc
    __libc_start_main(0x12648, a2, (char **)&v1, (void (*)())0x49521, (void (*)())0x12648, (void (*)())a1);
    abort();
    // UNREACHABLE
}

// Address range: 0x15e20 - 0x15e24
int32_t function_15e20(int32_t result) {
    // 0x15e20
    return result;
}

// Address range: 0x15e2c - 0x15e48
int32_t function_15e2c(void) {
    int32_t v1 = *(int32_t *)((int32_t)&g1 + (int32_t)"0000000000000000000000000000000080020000adc67d38f31f589b18b9d8e531b994ce5733c021a03d88d38611ee6b4c2710a5" + 648); // 0x15e38
    if (v1 == 0) {
        int32_t result; // 0x15e2c
        return result;
    }
    // 0x15e44
    __gmon_start__();
    return &g306;
}

// Address range: 0x15e50 - 0x15e54
int32_t function_15e50(void) {
    // 0x15e50
    int32_t result; // 0x15e50
    return result;
}

// Address range: 0x15e56 - 0x15e72
int32_t function_15e56(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x15e56
    return a1 | 0x60000;
}

// Address range: 0x15e74 - 0x15ea4
int32_t function_15e74(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x15e74
    int32_t v1; // 0x15e74
    int32_t v2 = v1;
    bool v3; // 0x15e74
    if (v3 || v3) {
        return result;
    }
    bool v4 = false; // 0x15e88
    if (!v3) {
        int32_t v5 = 0x100001 * v2 & -1 - 0x400000 * v2; // 0x15e88
        v4 = v5 < 0;
        if (v5 == 0) {
            return unknown_240();
        }
    }
    // 0x15e98
    if (v4 != v3) {
        __asm_svclt(0x4770);
    }
    float64_t v6; // 0x15e74
    __asm_vqrshl_s8(v6, v6);
    return result;
}

// Address range: 0x15ea4 - 0x15eb8
int32_t function_15ea4(int32_t a1) {
    // 0x15ea4
    int32_t v1; // 0x15ea4
    char * v2 = (char *)(v1 | 0x60000); // 0x15eaa
    int32_t result; // 0x15ea4
    if (*v2 == 0) {
        int32_t v3 = function_15e50(); // 0x15eae
        *v2 = 1;
        result = v3;
    }
    // 0x15eb6
    return result;
}

// Address range: 0x15eb8 - 0x16000
int32_t function_15eb8(int32_t a1) {
    int32_t str; // bp-208, 0x15eb8
    memset(&str, 0, 64);
    int32_t str2; // bp-144, 0x15eb8
    memset(&str2, 0, 64);
    int32_t str3; // bp-80, 0x15eb8
    int32_t * set_mem = memset(&str3, 0, 64); // 0x15ef8
    if (a1 == 0) {
        // 0x15fdc
        return (int32_t)set_mem;
    }
    int32_t v1 = function_47268(); // 0x15f04
    snprintf((char *)&str, 64, "%s", (char *)&g159);
    int32_t v2 = function_477fc(&str); // 0x15f2c
    function_4808c(v1, "miner_version", v2);
    snprintf((char *)&str2, 64, "%s", (char *)&g143);
    int32_t v3 = function_477fc(&str2); // 0x15f64
    function_4808c(v1, "CompileTime", v3);
    snprintf((char *)&str3, 64, "%s", (char *)&g145);
    if (*(char *)&g284 != 0) {
        // 0x15fe4
        snprintf((char *)&str3, 64, "%s", (char *)&g284);
    }
    int32_t v4 = function_477fc(&str3); // 0x15fb0
    function_4808c(v1, "type", v4);
    // 0x15fdc
    return function_4808c(a1, "INFO", v1);
}

// Address range: 0x16000 - 0x16188
int32_t function_16000(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = 0; // bp-84, 0x16028
    int32_t str; // bp-80, 0x16000
    int32_t * set_mem = memset(&str, 0, 48); // 0x1602c
    if (a1 == 0 || a4 == 0) {
        // 0x1603c
        return (int32_t)set_mem;
    }
    int32_t v2 = function_475f8(); // 0x16044
    int32_t v3 = function_47268(); // 0x1604c
    v1 = a2 == 0 ? 69 : 83;
    int32_t v4 = function_477fc(&v1); // 0x16068
    function_4808c(v3, "STATUS", v4);
    int32_t v5 = g62; // 0x16088
    function_4808c(v3, "When", function_47a48(v5, v5 >> 31));
    function_4808c(v3, "Code", function_47a48(a3, a3 >> 31));
    snprintf((char *)&str, 48, (char *)(a3 == 7 ? a4 : 0x4b504));
    int32_t v6 = function_477fc(&str); // 0x160fc
    function_4808c(v3, "Msg", v6);
    function_4808c(v3, "Description", function_477fc((int32_t *)g50));
    function_4854c(v2, v3);
    int32_t result = function_4808c(a1, "STATUS", v2); // 0x1615c
    if (a2 != 0) {
        // 0x1603c
        return result;
    }
    // 0x16160
    return function_4808c(a1, "id", function_47a48(1, 0));
}

// Address range: 0x16188 - 0x16384
int32_t function_16188(int32_t a1, int32_t a2) {
    // 0x16188
    int32_t str2; // bp-2128, 0x16188
    int32_t * set_mem = memset(&str2, 0, 64); // 0x161a4
    if (a1 == 0 || a2 == 0) {
        // 0x161b4
        if ((*(char *)&g70 | *(char *)&g179) == 0) {
            // 0x161dc
            if (g28 <= (char *)2) {
                // 0x16224
                return g28 < (char *)3 ? -0x7ffffffe : (int32_t)set_mem;
            }
        }
        // 0x161f4
        int32_t str; // bp-2064, 0x16188
        snprintf((char *)&str, 2048, "%s: input bad api param\n", "get_version_old");
        function_1ccec(3, &str, 0);
        // 0x16224
        return -0x7ffffffe;
    }
    // 0x1622c
    function_16000(a1, 1, 22, *(int32_t *)(a2 + 8));
    int32_t v1 = function_475f8(); // 0x16240
    int32_t v2 = function_47268(); // 0x16248
    function_4808c(v2, "BMMiner", function_477fc((int32_t *)"1.0.0"));
    function_4808c(v2, "API", function_477fc((int32_t *)"3.1"));
    int32_t v3 = function_477fc((int32_t *)&g159); // 0x16298
    function_4808c(v2, "Miner", v3);
    int32_t v4 = function_477fc((int32_t *)&g143); // 0x162b8
    function_4808c(v2, "CompileTime", v4);
    snprintf((char *)&str2, 64, "%s", (char *)&g145);
    if (*(char *)&g284 != 0) {
        // 0x16368
        snprintf((char *)&str2, 64, "%s", (char *)&g284);
    }
    int32_t v5 = function_477fc(&str2); // 0x16304
    function_4808c(v2, "Type", v5);
    function_4854c(v1, v2);
    function_4808c(a1, "VERSION", v1);
    function_4808c(a1, "id", function_47a48(1, 0));
    return 0;
}

// Address range: 0x16384 - 0x164a0
int32_t function_16384(int32_t result, int32_t a2) {
    int32_t str = 0; // bp-48, 0x1639c
    int32_t str2 = 0; // bp-32, 0x163a8
    if (result == 0 || a2 == 0) {
        // 0x163bc
        return result;
    }
    int32_t v1 = function_47268(); // 0x163cc
    int32_t v2 = function_477fc((int32_t *)&g16); // 0x163dc
    function_4808c(v1, "STATUS", v2);
    int32_t v3 = g62; // 0x163fc
    function_4808c(v1, "when", function_47a48(v3, v3 >> 31));
    snprintf((char *)&str, 16, "%s", "when");
    int32_t v4 = function_477fc(&str); // 0x16438
    function_4808c(v1, "Msg", v4);
    snprintf((char *)&str2, 16, "%s", (char *)*(int32_t *)(a2 + 4));
    int32_t v5 = function_477fc(&str2); // 0x1646c
    function_4808c(v1, "api_version", v5);
    return function_4808c(result, "STATUS", v1);
}

// Address range: 0x164a0 - 0x166a8
int32_t function_164a0(int32_t a1, int32_t a2) {
    int16_t v1 = 0; // bp-2084, 0x164c4
    int32_t str; // bp-2080, 0x164a0
    if (a2 == 0) {
        // 0x164cc
        if ((*(char *)&g70 | *(char *)&g179) == 0) {
            // 0x164f4
            if (g28 <= (char *)2) {
                // 0x16538
                return g28 < (char *)3 ? -0x7ffffffe : a1;
            }
        }
        // 0x1650c
        snprintf((char *)&str, 2048, "%s: input bad api param\n", "get_stats");
        function_1ccec(3, &str, 0);
        // 0x16538
        return -0x7ffffffe;
    }
    // 0x16544
    function_40e70((int32_t *)&v1, 1);
    function_16384(a1, a2);
    int32_t v2 = function_475f8(); // 0x16574
    int32_t v3 = 0; // 0x16584
    if (g228 >= (char *)1) {
        int32_t v4 = function_2c8f4(v3); // 0x16590
        int32_t v5; // 0x1659c
        if (v4 != 0) {
            // 0x1659c
            v5 = *(int32_t *)(v4 + 4);
            if (v5 != 0) {
                // 0x165a8
                if (*(int32_t *)(v5 + 28) != 0) {
                    // 0x165b4
                    function_4854c(v2, v4);
                }
            }
        }
        int32_t v6 = v3 + 1; // 0x1658c
        v3 = v6;
        while (v6 < (int32_t)g228) {
            // 0x16588
            v4 = function_2c8f4(v3);
            if (v4 != 0) {
                // 0x1659c
                v5 = *(int32_t *)(v4 + 4);
                if (v5 != 0) {
                    // 0x165a8
                    if (*(int32_t *)(v5 + 28) != 0) {
                        // 0x165b4
                        function_4854c(v2, v4);
                    }
                }
            }
            // 0x165c4
            v6 = v3 + 1;
            v3 = v6;
        }
    }
    // 0x165d0
    if (*(char *)&g71 == 0) {
        // 0x16684
        function_4808c(a1, "STATS", v2);
        return 0;
    }
    char v7 = *(char *)&g70; // 0x16600
    if ((v7 | *(char *)&g179) == 0 == g28 < (char *)7) {
        // 0x16684
        function_4808c(a1, "STATS", v2);
        return 0;
    }
    // 0x16620
    snprintf((char *)&str, 2048, "total_mhashes_done = %lf\n new_total_mhashes_done = %lf\n total_secs = %lf\n, new_total_secs = %lf", (float64_t)(int64_t)(int32_t)&g177, g177, g195, g35);
    function_1ccec(7, &str, 0);
    // 0x16684
    function_4808c(a1, "STATS", v2);
    return 0;
}

// Address range: 0x166ac - 0x16c14
int32_t function_166ac(int32_t a1, int32_t a2) {
    // 0x166ac
    int32_t str2; // bp-2344, 0x166ac
    memset(&str2, 0, 128);
    int32_t str3; // bp-2216, 0x166ac
    int32_t * set_mem = memset(&str3, 0, 128); // 0x166e4
    char * v1 = NULL; // bp-2380, 0x166f8
    int32_t str4 = 0; // bp-2388, 0x16700
    int32_t str5 = 0; // bp-2368, 0x16704
    if (a1 == 0 || a2 == 0) {
        // 0x16724
        if ((*(char *)&g70 | *(char *)&g179) == 0) {
            // 0x1674c
            if (g28 <= (char *)2) {
                // 0x16790
                return g28 < (char *)3 ? -0x7ffffffe : (int32_t)set_mem;
            }
        }
        // 0x16764
        int32_t str; // bp-2088, 0x166ac
        snprintf((char *)&str, 2048, "%s: input bad api param\n", "get_pools");
        function_1ccec(3, &str, 0);
        // 0x16790
        return -0x7ffffffe;
    }
    // 0x1679c
    function_16384(a1, a2);
    int32_t v2 = function_475f8(); // 0x167bc
    if (g188 < (char *)1) {
        // 0x16bc0
        function_4808c(a1, "POOLS", v2);
        return 0;
    }
    int32_t v3 = 0;
    int32_t v4 = *(int32_t *)(g202 + 4 * v3); // 0x16ab8
    char * v5 = g188; // 0x16ac0
    int32_t v6; // 0x16ac4
    int32_t v7; // 0x16afc
    int32_t v8; // 0x16b14
    int32_t v9; // 0x16b40
    int32_t v10; // 0x16b58
    char v11; // 0x16b8c
    int32_t v12; // 0x166ac
    int32_t v13; // 0x16838
    int32_t v14; // 0x16850
    uint64_t v15; // 0x16890
    uint64_t v16; // 0x168ac
    int32_t v17; // 0x1692c
    uint64_t v18; // 0x16944
    int32_t v19; // 0x16964
    int32_t v20; // 0x16984
    int32_t v21; // 0x169a4
    int32_t v22; // 0x169c8
    int32_t * v23; // 0x169e4
    int32_t v24; // 0x16a2c
    uint32_t v25; // 0x16a34
    uint32_t v26; // 0x16a40
    uint32_t v27; // 0x16a48
    uint32_t v28; // 0x16a54
    int32_t v29; // 0x16a70
    if (v4 != 0) {
        // 0x16ac4
        v6 = function_47268();
        function_4808c(v6, "index", function_47a48(v3, 0));
        memset(&str2, 0, 128);
        v7 = *(int32_t *)(v4 + 164);
        snprintf((char *)&str2, 128, "%s", (char *)v7);
        v8 = function_477fc(&str2);
        function_4808c(v6, "url", v8);
        memset(&str3, 0, 128);
        v9 = *(int32_t *)(v4 + 172);
        snprintf((char *)&str3, 128, "%s", (char *)v9);
        v10 = function_477fc(&str3);
        function_4808c(v6, "user", v10);
        v1 = NULL;
        switch (*(int32_t *)(v4 + 100)) {
            case 1: {
                // 0x16b8c
                v11 = *(char *)(v4 + 97);
                v12 = *((v11 == 0 ? (int32_t *)0x49810 : (int32_t *)0x49808));
                v1 = (char *)v12;
                // break -> 0x16830
                break;
            }
            case 0: {
                // 0x16be4
                v1 = (char *)0x61736944;
                // break -> 0x16830
                break;
            }
            case 2: {
                // 0x16818
                v1 = (char *)0x656a6552;
                // break -> 0x16830
                break;
            }
            default: {
                // 0x16c00
                v1 = (char *)0x6e6b6e55;
                // break -> 0x16830
                break;
            }
        }
        // 0x16830
        v13 = function_477fc((int32_t *)&v1);
        function_4808c(v6, "status", v13);
        v14 = *(int32_t *)(v4 + 4);
        function_4808c(v6, "priority", function_47a48(v14, v14 >> 31));
        function_4808c(v6, "getworks", function_47a48(*(int32_t *)(v4 + 116), 0));
        v15 = *(int64_t *)(v4 + 8);
        function_4808c(v6, "accepted", function_47a48((int32_t)(v15 / 0x100000000), (int32_t)v15));
        v16 = *(int64_t *)(v4 + 16);
        function_4808c(v6, "rejected", function_47a48((int32_t)(v16 / 0x100000000), (int32_t)v16));
        function_4808c(v6, "discarded", function_47a48(*(int32_t *)(v4 + 124), 0));
        function_4808c(v6, "stale", function_47a48(*(int32_t *)(v4 + 120), 0));
        str4 = 0;
        snprintf((char *)&str4, 8, "%s", (char *)(v4 + 48));
        v17 = function_477fc(&str4);
        function_4808c(v6, "diff", v17);
        v18 = *(int64_t *)(v4 + 40);
        function_4808c(v6, "diff1", function_47a48((int32_t)(v18 / 0x100000000), (int32_t)v18));
        v19 = function_493a4();
        function_4808c(v6, "diffa", function_47a48(v19, (int32_t)*(int64_t *)(v4 + 72)));
        v20 = function_493a4();
        function_4808c(v6, "diffr", function_47a48(v20, (int32_t)*(int64_t *)(v4 + 80)));
        v21 = function_493a4();
        function_4808c(v6, "diffs", function_47a48(v21, (int32_t)*(int64_t *)(v4 + 88)));
        v22 = function_493a4();
        function_4808c(v6, "lsdiff", function_47a48(v22, (int32_t)*(int64_t *)(v4 + 360)));
        v23 = (int32_t *)(v4 + 352);
        str5 = 0;
        if (*v23 > 0) {
            // 0x16a10
            v24 = time(NULL) - *v23;
            v25 = v24 & (int32_t)(v24 < 0) - 1;
            v26 = v25 / 3600;
            v27 = -3600 * v26 + v25;
            v28 = v27 / 60;
            snprintf((char *)&str5, 24, "%d:%02d:%02d", v26, v28, v27 + 4 * v28);
        } else {
            str5 = 48;
        }
        // 0x16a6c
        v29 = function_477fc(&str5);
        function_4808c(v6, "lstime", v29);
        function_4854c(v2, v6);
        v5 = g188;
    }
    int32_t v30 = v3 + 1; // 0x16a98
    while (v30 < (int32_t)v5) {
        // 0x16aac
        v3 = v30;
        v4 = *(int32_t *)(g202 + 4 * v3);
        if (v4 != 0) {
            // 0x16ac4
            v6 = function_47268();
            function_4808c(v6, "index", function_47a48(v3, 0));
            memset(&str2, 0, 128);
            v7 = *(int32_t *)(v4 + 164);
            snprintf((char *)&str2, 128, "%s", (char *)v7);
            v8 = function_477fc(&str2);
            function_4808c(v6, "url", v8);
            memset(&str3, 0, 128);
            v9 = *(int32_t *)(v4 + 172);
            snprintf((char *)&str3, 128, "%s", (char *)v9);
            v10 = function_477fc(&str3);
            function_4808c(v6, "user", v10);
            v1 = NULL;
            switch (*(int32_t *)(v4 + 100)) {
                case 1: {
                    // 0x16b8c
                    v11 = *(char *)(v4 + 97);
                    v12 = *((v11 == 0 ? (int32_t *)0x49810 : (int32_t *)0x49808));
                    v1 = (char *)v12;
                    // break -> 0x16830
                    break;
                }
                case 0: {
                    // 0x16be4
                    v1 = (char *)0x61736944;
                    // break -> 0x16830
                    break;
                }
                case 2: {
                    // 0x16818
                    v1 = (char *)0x656a6552;
                    // break -> 0x16830
                    break;
                }
                default: {
                    // 0x16c00
                    v1 = (char *)0x6e6b6e55;
                    // break -> 0x16830
                    break;
                }
            }
            // 0x16830
            v13 = function_477fc((int32_t *)&v1);
            function_4808c(v6, "status", v13);
            v14 = *(int32_t *)(v4 + 4);
            function_4808c(v6, "priority", function_47a48(v14, v14 >> 31));
            function_4808c(v6, "getworks", function_47a48(*(int32_t *)(v4 + 116), 0));
            v15 = *(int64_t *)(v4 + 8);
            function_4808c(v6, "accepted", function_47a48((int32_t)(v15 / 0x100000000), (int32_t)v15));
            v16 = *(int64_t *)(v4 + 16);
            function_4808c(v6, "rejected", function_47a48((int32_t)(v16 / 0x100000000), (int32_t)v16));
            function_4808c(v6, "discarded", function_47a48(*(int32_t *)(v4 + 124), 0));
            function_4808c(v6, "stale", function_47a48(*(int32_t *)(v4 + 120), 0));
            str4 = 0;
            snprintf((char *)&str4, 8, "%s", (char *)(v4 + 48));
            v17 = function_477fc(&str4);
            function_4808c(v6, "diff", v17);
            v18 = *(int64_t *)(v4 + 40);
            function_4808c(v6, "diff1", function_47a48((int32_t)(v18 / 0x100000000), (int32_t)v18));
            v19 = function_493a4();
            function_4808c(v6, "diffa", function_47a48(v19, (int32_t)*(int64_t *)(v4 + 72)));
            v20 = function_493a4();
            function_4808c(v6, "diffr", function_47a48(v20, (int32_t)*(int64_t *)(v4 + 80)));
            v21 = function_493a4();
            function_4808c(v6, "diffs", function_47a48(v21, (int32_t)*(int64_t *)(v4 + 88)));
            v22 = function_493a4();
            function_4808c(v6, "lsdiff", function_47a48(v22, (int32_t)*(int64_t *)(v4 + 360)));
            v23 = (int32_t *)(v4 + 352);
            str5 = 0;
            if (*v23 > 0) {
                // 0x16a10
                v24 = time(NULL) - *v23;
                v25 = v24 & (int32_t)(v24 < 0) - 1;
                v26 = v25 / 3600;
                v27 = -3600 * v26 + v25;
                v28 = v27 / 60;
                snprintf((char *)&str5, 24, "%d:%02d:%02d", v26, v28, v27 + 4 * v28);
            } else {
                str5 = 48;
            }
            // 0x16a6c
            v29 = function_477fc(&str5);
            function_4808c(v6, "lstime", v29);
            function_4854c(v2, v6);
            v5 = g188;
        }
        // 0x16a94
        v30 = v3 + 1;
    }
    // 0x16bc0
    function_4808c(a1, "POOLS", v2);
    return 0;
}

// Address range: 0x16c18 - 0x1cca0
int32_t function_16c18(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11, int32_t a12, int32_t a13, int32_t a14, int32_t a15, int32_t a16, int32_t a17, int32_t a18, int32_t a19, int32_t a20, int32_t a21, int32_t a22, int32_t a23, int32_t a24, int32_t a25, int32_t a26, int32_t a27) {
    // 0x16c18
    float64_t v1; // 0x16c18
    float64_t v2 = __asm_vpush(v1, v1); // 0x16c20
    int32_t str2; // bp-2344, 0x16c18
    memset(&str2, 0, 128);
    int32_t str3; // bp-2216, 0x16c18
    memset(&str3, 0, 128);
    char * v3 = NULL; // bp-2380, 0x16c68
    int32_t str5 = 0; // bp-2388, 0x16c70
    int32_t str4 = 0; // bp-2368, 0x16c74
    if (a1 == 0 || a2 == 0) {
        // 0x16c94
        if ((*(char *)&g70 | *(char *)&g179) == 0) {
            // 0x16cbc
            if (g28 <= (char *)2) {
                // 0x16d00
                __asm_vpop_11(v2, v2);
                return g28 < (char *)3 ? -0x7ffffffe : a1;
            }
        }
        // 0x16cd4
        int32_t str; // bp-2088, 0x16c18
        snprintf((char *)&str, 2048, "%s: input bad api param\n", "get_pools_old");
        function_1ccec(3, &str, 0);
        // 0x16d00
        __asm_vpop_11(v2, v2);
        return -0x7ffffffe;
    }
    // 0x16d18
    if (g188 == NULL) {
        int32_t result = (int32_t)g188; // 0x16d20
        function_16000(a1, result, 8, (int32_t)"No pools");
        // 0x16d00
        __asm_vpop_11(v2, v2);
        return result;
    }
    // 0x16d2c
    function_16000(a1, 1, 7, *(int32_t *)(a2 + 8));
    int32_t v4 = function_475f8(); // 0x16d40
    float64_t v5 = v2; // 0x16d50
    if (g188 < (char *)1) {
      lab_0x17404:
        // 0x17404
        function_4808c(a1, "POOLS", v4);
        function_4808c(a1, "id", function_47a48(1, 0));
        // 0x16d00
        __asm_vpop_11(v2, v5);
        return 0;
    }
    // 0x16d54
    v2 = __asm_vldr(0);
    v5 = __asm_vldr(0);
    int32_t v6 = 0;
    int32_t v7 = *(int32_t *)(4 * v6 + g202); // 0x16db4
    while (*(char *)(v7 + 105) != 0) {
        int32_t v8 = v6 + 1; // 0x173ec
        if (v8 >= (int32_t)g188) {
            goto lab_0x17404;
        }
        v6 = v8;
        v7 = *(int32_t *)(4 * v6 + g202);
    }
    int32_t v9 = function_47268(); // 0x16dc4
    function_4808c(v9, "POOL", function_47a48(v6, 0));
    memset(&str2, 0, 128);
    int32_t v10 = *(int32_t *)(v7 + 164); // 0x16df8
    snprintf((char *)&str2, 128, "%s", (char *)v10);
    int32_t v11 = function_477fc(&str2); // 0x16e10
    function_4808c(v9, "URL", v11);
    v3 = NULL;
    switch (*(int32_t *)(v7 + 100)) {
        case 1: {
            char v12 = *(char *)(v7 + 97); // 0x174e8
            int32_t v13 = *((v12 == 0 ? (int32_t *)0x49810 : (int32_t *)0x498bc));
            v3 = (char *)v13;
            // break -> 0x16e5c
            break;
        }
        case 0: {
            // 0x174cc
            v3 = (char *)0x61736944;
            // break -> 0x16e5c
            break;
        }
        case 2: {
            // 0x17460
            v3 = (char *)0x656a6552;
            // break -> 0x16e5c
            break;
        }
        default: {
            // 0x16e4c
            v3 = (char *)0x6e6b6e55;
            // break -> 0x16e5c
            break;
        }
    }
    int32_t v14 = function_477fc((int32_t *)&v3); // 0x16e64
    function_4808c(v9, "Status", v14);
    int32_t v15 = *(int32_t *)(v7 + 4); // 0x16e7c
    function_4808c(v9, "Priority", function_47a48(v15, v15 >> 31));
    int32_t v16 = *(int32_t *)(v7 + 56); // 0x16e9c
    function_4808c(v9, "Quota", function_47a48(v16, v16 >> 31));
    int32_t v17 = *(int32_t *)(v7 + 108) == 0 ? 0x498f0 : 0x498e0;
    function_4808c(v9, "Long Poll", function_477fc((int32_t *)v17));
    function_4808c(v9, "Getworks", function_47a48(*(int32_t *)(v7 + 116), 0));
    uint64_t v18 = *(int64_t *)(v7 + 8); // 0x16f0c
    function_4808c(v9, "Accepted", function_47a48((int32_t)(v18 / 0x100000000), (int32_t)v18));
    uint64_t v19 = *(int64_t *)(v7 + 16); // 0x16f28
    function_4808c(v9, "Rejected", function_47a48((int32_t)(v19 / 0x100000000), (int32_t)v19));
    function_4808c(v9, "Discarded", function_47a48(*(int32_t *)(v7 + 124), 0));
    function_4808c(v9, "Stale", function_47a48(*(int32_t *)(v7 + 120), 0));
    function_4808c(v9, "Get Failures", function_47a48(*(int32_t *)(v7 + 128), 0));
    function_4808c(v9, "Remote Failures", function_47a48(*(int32_t *)(v7 + 132), 0));
    memset(&str3, 0, 128);
    int32_t v20 = *(int32_t *)(v7 + 172); // 0x16fd4
    snprintf((char *)&str3, 128, "%s", (char *)v20);
    int32_t v21 = function_477fc(&str3); // 0x16fec
    function_4808c(v9, "User", v21);
    int32_t * v22 = (int32_t *)(v7 + 352); // 0x17004
    str4 = 0;
    if (*v22 > 0) {
        int32_t v23 = time(NULL) - *v22; // 0x1704c
        uint32_t v24 = v23 & (int32_t)(v23 < 0) - 1; // 0x17050
        uint32_t v25 = v24 / 3600; // 0x1706c
        uint32_t v26 = -3600 * v25 + v24; // 0x17074
        uint32_t v27 = v26 / 60; // 0x17080
        snprintf((char *)&str4, 24, "%d:%02d:%02d", v25, v27, v26 + 4 * v27);
    } else {
        str4 = 48;
    }
    int32_t v28 = function_477fc(&str4); // 0x170b4
    function_4808c(v9, "Last Share Time", v28);
    str5 = 0;
    snprintf((char *)&str5, 8, "%s", (char *)(v7 + 48));
    int32_t v29 = function_477fc(&str5); // 0x170f0
    function_4808c(v9, "Diff", v29);
    uint64_t v30 = *(int64_t *)(v7 + 40); // 0x17108
    function_4808c(v9, "Diff1 Shares", function_47a48((int32_t)(v30 / 0x100000000), (int32_t)v30));
    int32_t * v31 = (int32_t *)(v7 + 184); // 0x17124
    int32_t v32; // 0x16c18
    if (*v31 == 0) {
        int32_t v33 = function_477fc((int32_t *)&g19); // 0x174a8
        function_4808c(v9, "Proxy Type", v33);
        v32 = (int32_t)&g19;
    } else {
        int32_t v34 = function_1e8f8(*(int32_t *)(v7 + 180)); // 0x17134
        function_4808c(v9, "Proxy Type", function_477fc((int32_t *)v34));
        v32 = *v31;
    }
    int32_t result2 = function_4808c(v9, "Proxy", function_477fc((int32_t *)v32)); // 0x17168
    __asm_vldr(*(int32_t *)(v7 + 72));
    return result2;
}

// Address range: 0x1cca0 - 0x1ccd0
int32_t function_1cca0(int32_t a1, int32_t a2, uint32_t a3) {
    // 0x1cca0
    int32_t str; // bp+32, 0x1cca0
    snprintf((char *)&str, 2048, (char *)(a3 % 0x10000 | 0x40000));
    function_1ccec(3, &str, 1);
    function_3aadc(1);
    // UNREACHABLE
}

// Address range: 0x1ccd0 - 0x1cce8
int32_t function_1ccd0(int32_t a1, int32_t a2) {
    // 0x1ccd0
    int32_t v1; // 0x1ccd0
    free((int32_t *)v1);
    return 0;
}

// Address range: 0x1ccec - 0x1cecc
int32_t function_1ccec(int32_t a1, int32_t * str2, int32_t a3) {
    // 0x1ccec
    if (*(char *)&g179 != 0) {
        // 0x1ce6c
        syslog(a1 | 128, "%s", str2);
        return &g306;
    }
    int32_t v1 = 0; // bp-104, 0x1cd18
    function_1f5c4(&v1);
    int32_t timep = v1; // bp-108, 0x1cd48
    struct tm * time_info = localtime(&timep); // 0x1cd50
    int32_t v2 = (int32_t)time_info; // 0x1cd50
    int32_t v3 = *(int32_t *)(v2 + 20); // 0x1cd5c
    int32_t v4 = time_info->e0; // 0x1cd64
    int32_t v5 = *(int32_t *)(v2 + 4); // 0x1cd78
    int32_t v6 = *(int32_t *)(v2 + 8); // 0x1cd88
    int32_t v7 = *(int32_t *)(v2 + 12); // 0x1cd90
    int32_t v8 = *(int32_t *)(v2 + 16); // 0x1cd98
    int32_t str; // bp-96, 0x1ccec
    snprintf((char *)&str, 64, " [%d-%02d-%02d %02d:%02d:%02d.%03d] ", v3 + 1900, v8 + 1, v7, v6, v5, v4, 0);
    int32_t v9 = isatty(fileno(g61)); // 0x1cdb0
    int32_t fflush_rc = v9; // 0x1cdb8
    if (v9 == 0) {
        // 0x1ce88
        fprintf(g61, "%s%s\n", &str, str2);
        fflush_rc = fflush(g61);
    }
    int32_t fflush_rc2 = fflush_rc; // 0x1cdcc
    int32_t stream; // 0x1ceb4
    if (*(char *)&g63 == 0) {
        goto lab_0x1ce34;
    } else {
        // 0x1cdd0
        stream = (int32_t)g64;
        if (g64 == NULL) {
            struct _IO_FILE * v10 = fopen64((char *)&g67, (char *)&g65); // 0x1ceb4
            stream = (int32_t)v10;
            g64 = v10;
            fflush_rc2 = stream;
            if (v10 == NULL) {
                goto lab_0x1ce34;
            } else {
                goto lab_0x1cddc;
            }
        } else {
            goto lab_0x1cddc;
        }
    }
  lab_0x1ce34:;
    int32_t result = fflush_rc2; // 0x1ce50
    if (a1 == 3 || g263 % 2 == 0) {
        // 0x1ce54
        result = function_1cfd8(&str, (int32_t)str2, a3);
    }
    // 0x1ce64
    return result;
  lab_0x1cddc:
    // 0x1cddc
    fwrite(&str, strlen((char *)&str), 1, (struct _IO_FILE *)stream);
    fwrite(str2, strlen((char *)str2), 1, g64);
    fwrite((int32_t *)"\n", 1, 1, g64);
    fflush_rc2 = fflush(g64);
    goto lab_0x1ce34;
}

// Address range: 0x1cecc - 0x1cf44
int32_t function_1cecc(int32_t a1) {
    // 0x1cecc
    if (pthread_mutex_unlock(&g229) == 0) {
        // 0x1ceec
        return 0;
    }
    int32_t v1 = *__errno_location(); // 0x1cefc
    int32_t str; // bp-2056, 0x1cecc
    snprintf((char *)&str, 2048, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", v1, "logging.c", "my_log_curses", a1);
    function_1ccec(3, &str, 1);
    function_3aadc(1);
    // UNREACHABLE
}

// Address range: 0x1cf44 - 0x1cf4c
int32_t function_1cf44(int32_t a1) {
    // 0x1cf44
    int32_t result; // 0x1cf44
    return result;
}

// Address range: 0x1cf4c - 0x1cfcc
int32_t function_1cf4c(void) {
    // 0x1cf4c
    if (pthread_mutex_lock(&g229) == 0) {
        // 0x1cf6c
        return 0;
    }
    int32_t v1 = *__errno_location(); // 0x1cf80
    int32_t str; // bp-2056, 0x1cf4c
    snprintf((char *)&str, 2048, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", v1, "logging.c", "my_log_curses", 52);
    function_1ccec(3, &str, 1);
    function_3aadc(1);
    // UNREACHABLE
}

// Address range: 0x1cfcc - 0x1cfd8
int32_t function_1cfcc(void) {
    // 0x1cfcc
    int32_t result; // 0x1cfcc
    return result;
}

// Address range: 0x1cfd8 - 0x1d050
int32_t function_1cfd8(int32_t * a1, int32_t a2, int32_t a3) {
    if (a3 != 0) {
        // 0x1d028
        pthread_mutex_trylock(&g229);
        function_1cecc(41);
        function_1da28();
    }
    // 0x1cff4
    function_1cf4c();
    printf("%s%s%s", a1, (char *)a2, "                    \n");
    function_1cecc(54);
    return function_1da28();
}

// Address range: 0x1d050 - 0x1d054
int32_t function_1d050(void) {
    // 0x1d050
    int32_t result; // 0x1d050
    return result;
}

// Address range: 0x1d058 - 0x1d05c
int32_t function_1d058(int32_t a1) {
    // 0x1d058
    return a1 + 7;
}

// Address range: 0x1d05e - 0x1d060
int32_t function_1d05e(int32_t a1) {
    // 0x1d05e
    return function_1d3a2(a1);
}

// Address range: 0x1d060 - 0x1d100
int32_t function_1d060(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9) {
    // 0x1d060
    int32_t v1; // 0x1d060
    if ((char)v1 != 0) {
        // 0x1d0c8
        syslog(a1 | 128, "%s", (char *)v1);
        return &g306;
    }
    // 0x1d06c
    if (isatty(fileno(g61)) == 0) {
        // 0x1d0e0
        fprintf(g61, "%s\n", (char *)v1);
        fflush(g61);
    }
    // 0x1d090
    if (a1 == 3 || g263 % 2 == 0) {
        // 0x1d0b0
        return function_1cfd8((int32_t *)&g19, v1, a3);
    }
    return 1;
}

// Address range: 0x1d104 - 0x1d108
int32_t function_1d104(void) {
    // 0x1d104
    __asm_udf(129);
    int32_t v1; // 0x1d104
    return function_1d5a4(v1, v1);
}

// Address range: 0x1d108 - 0x1d118
int32_t function_1d108(int32_t result, int32_t a2) {
    // 0x1d108
    return result;
}

// Address range: 0x1d118 - 0x1d11c
int32_t function_1d118(void) {
    // 0x1d118
    return 0;
}

// Address range: 0x1d11c - 0x1d120
int32_t function_1d11c(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x1d11c
    return result;
}

// Address range: 0x1d120 - 0x1d122
int32_t function_1d120(void) {
    // 0x1d120
    int32_t result; // 0x1d120
    return result;
}

// Address range: 0x1d122 - 0x1d123
int32_t function_1d122(void) {
    // 0x1d122
    int32_t result; // 0x1d122
    return result;
}

// Address range: 0x1d124 - 0x1d17c
int32_t function_1d124(int32_t a1) {
    // 0x1d124
    if (a1 == 0) {
        function_1d188();
        // UNREACHABLE
    }
    // 0x1d130
    *(int32_t *)(a1 + 4) = (int32_t)"Nonces";
    int32_t v1; // 0x1d124
    *(int32_t *)(v1 + 24) = a1;
    *(int32_t *)(a1 + 8) = (int32_t)"Nonces";
    return (int32_t)"Nonces";
}

// Address range: 0x1d17e - 0x1d180
int32_t function_1d17e(void) {
    // 0x1d17e
    int32_t result; // 0x1d17e
    return result;
}

// Address range: 0x1d180 - 0x1d188
int32_t function_1d180(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x1d180
    int32_t result; // 0x1d180
    return result;
}

// Address range: 0x1d188 - 0x1d1c8
int32_t function_1d188(void) {
    // 0x1d188
    int32_t str; // bp+16, 0x1d188
    int32_t v1; // 0x1d188
    snprintf((char *)&str, 2048, "Failed to calloc dupdata in %s %s():%d", "noncedup.c", (char *)v1, 36);
    function_1ccec(3, &str, 1);
    return function_3aadc(1);
}

// Address range: 0x1d1ca - 0x1d1cb
int32_t function_1d1ca(void) {
    // 0x1d1ca
    int32_t result; // 0x1d1ca
    return result;
}

// Address range: 0x1d1cc - 0x1d1f4
int32_t function_1d1cc(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = *(int32_t *)(a1 + 24); // 0x1d1cc
    if (v1 == 0) {
        // 0x1d1f0
        return 0;
    }
    uint64_t v2 = *(int64_t *)(v1 + 16); // 0x1d1dc
    *(int32_t *)a2 = (int32_t)(v2 / 0x100000000);
    *(int32_t *)(a2 + 4) = (int32_t)v2;
    uint64_t v3 = *(int64_t *)(v1 + 24); // 0x1d1e4
    int32_t result = v3 / 0x100000000; // 0x1d1e4
    *(int32_t *)a3 = result;
    *(int32_t *)(a3 + 4) = (int32_t)v3;
    return result;
}

// Address range: 0x1d1f6 - 0x1d1f8
int32_t function_1d1f6(void) {
    // 0x1d1f6
    int32_t result; // 0x1d1f6
    return result;
}

// Address range: 0x1d1f8 - 0x1d204
int32_t function_1d1f8(int32_t result, int32_t a2, int32_t a3) {
    // 0x1d1f8
    int32_t v1; // 0x1d1f8
    *(int32_t *)v1 = result;
    *(int32_t *)(v1 + 4) = a2;
    *(int32_t *)a3 = result;
    *(int32_t *)(a3 + 4) = a2;
    return result;
}

// Address range: 0x1d204 - 0x1d290
int32_t function_1d204(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = *(int32_t *)(a1 + 24); // 0x1d20c
    if (v1 == 0) {
        function_1d490((int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306);
    }
    // 0x1d220
    int32_t v2; // bp-2096, 0x1d204
    function_1f5c4(&v2);
    int32_t * v3 = (int32_t *)(v1 + 16); // 0x1d234
    int32_t v4 = *v3; // 0x1d234
    int32_t * v5 = (int32_t *)(v1 + 20); // 0x1d238
    *v3 = v4 + 1;
    *v5 = *v5 + (int32_t)(v4 == -1);
    int32_t mutex = *(int32_t *)(*(int32_t *)(v1 + 4) + 8); // 0x1d250
    if (pthread_mutex_lock((int32_t *)mutex) != 0) {
        function_1d4b0();
        // UNREACHABLE
    }
    // 0x1d264
    if (pthread_rwlock_wrlock((int32_t *)(mutex + 24)) == 0) {
        // 0x1d274
        return 0;
    }
    function_1d504();
    // UNREACHABLE
}

// Address range: 0x1d292 - 0x1d294
int32_t function_1d292(void) {
    // 0x1d292
    int32_t result; // 0x1d292
    return result;
}

// Address range: 0x1d294 - 0x1d298
int32_t function_1d294(void) {
    // 0x1d294
    return 6;
}

// Address range: 0x1d298 - 0x1d29c
int32_t function_1d298(void) {
    // 0x1d298
    return 20;
}

// Address range: 0x1d29c - 0x1d2a0
int32_t function_1d29c(int32_t result) {
    // 0x1d29c
    return result;
}

// Address range: 0x1d2a6 - 0x1d2ac
int32_t function_1d2a6(int32_t result) {
    // 0x1d2a6
    return result;
}

// Address range: 0x1d2ac - 0x1d30c
int32_t function_1d2ac(int32_t a1) {
    // 0x1d2ac
    int32_t v1; // 0x1d2ac
    bool v2; // 0x1d2ac
    if (v2) {
        v1 = function_1d340((int32_t)&g306, (int32_t)&g306);
    }
    // 0x1d2b0
    int32_t v3; // 0x1d2ac
    int32_t v4 = *(int32_t *)(v3 + 12); // 0x1d2b0
    if (*(int32_t *)v4 != *(int32_t *)(v3 + 340) || *(int32_t *)(v4 + 4) != v3) {
        // 0x1d2c8
        return function_1d29c(v1);
    }
    // 0x1d2dc
    int32_t v5; // bp+32, 0x1d2ac
    int32_t result = &v5; // 0x1d2e8
    if ((char)v3 != 0) {
        // 0x1d30c
        return result;
    }
    int32_t result2 = result; // 0x1d308
    if (*(char *)a1 == 0) {
        result2 = function_1d4a0(result, 2048, v3, (int32_t)&g28);
    }
    // 0x1d30c
    return result2;
}

// Address range: 0x1d30e - 0x1d310
int32_t function_1d30e(void) {
    // 0x1d30e
    int32_t result; // 0x1d30e
    return result;
}

// Address range: 0x1d310 - 0x1d340
int32_t function_1d310(void) {
    // 0x1d310
    int32_t str; // 0x1d310
    snprintf((char *)str, str, (char *)str);
    int32_t v1; // bp+32, 0x1d310
    int32_t v2 = function_1ccec(4, &v1, 0); // 0x1d338
    return function_1d29c(v2);
}

// Address range: 0x1d340 - 0x1d3a0
int32_t function_1d340(int32_t result, int32_t a2) {
    // 0x1d340
    int32_t v1; // 0x1d340
    if (v1 == 0) {
        function_1d3ac(v1, v1, v1);
    }
    int32_t * v2 = (int32_t *)(*(int32_t *)(v1 + 4) + 12); // 0x1d368
    *(int32_t *)*v2 = *(int32_t *)(v1 + 340);
    int32_t v3 = *v2; // 0x1d38c
    *(int32_t *)(v3 + 12) = a2;
    *(int32_t *)(v3 + 8) = result;
    return result;
}

// Address range: 0x1d3a2 - 0x1d3a4
int32_t function_1d3a2(int32_t a1) {
    // 0x1d3a2
    int32_t result; // 0x1d3a2
    return result;
}

// Address range: 0x1d3a4 - 0x1d3ac
int32_t function_1d3a4(void) {
    // 0x1d3a4
    int32_t result; // 0x1d3a4
    return result;
}

// Address range: 0x1d3ac - 0x1d490
int32_t function_1d3ac(int32_t a1, int32_t a2, int32_t a3) {
    // 0x1d3ac
    int32_t v1; // 0x1d3ac
    int32_t v2 = *(int32_t *)(*(int32_t *)(v1 + 8) + 16); // 0x1d3b0
    if (v2 != 0) {
        // 0x1d3bc
        int32_t v3; // bp+24, 0x1d3ac
        int32_t result = function_1f8ec(*(int32_t *)(v2 + 12) + 8, &v3); // 0x1d410
        __asm_vldr_14(v1);
        return result;
    }
    int32_t mutex = *(int32_t *)(*(int32_t *)(v1 + 4) + 8); // 0x1d438
    if (pthread_rwlock_unlock((int32_t *)(mutex + 24)) != 0) {
        function_1d5ac();
        // UNREACHABLE
    }
    // 0x1d44c
    if (pthread_mutex_unlock((int32_t *)mutex) != 0) {
        function_1d558();
    }
    int32_t result2 = function_1da28(); // 0x1d470
    if (v1 != 0) {
        result2 = function_1d490((int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306);
    }
    int32_t * v4 = (int32_t *)(v1 + 24); // 0x1d474
    int32_t v5 = *v4; // 0x1d474
    int32_t * v6 = (int32_t *)(v1 + 28); // 0x1d47c
    *v4 = v5 + 1;
    *v6 = *v6 + (int32_t)(v5 == -1);
    return result2;
}

// Address range: 0x1d490 - 0x1d4a0
int32_t function_1d490(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    // 0x1d490
    int32_t result; // 0x1d490
    return result;
}

// Address range: 0x1d4a0 - 0x1d4b0
int32_t function_1d4a0(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t result = a1; // 0x1d4a8
    if (a4 < 4) {
        result = function_1d29c(a1);
    }
    // 0x1d4ac
    return result;
}

// Address range: 0x1d4b0 - 0x1d500
int32_t function_1d4b0(void) {
    int32_t v1 = *__errno_location(); // 0x1d4bc
    int32_t str; // bp+32, 0x1d4b0
    snprintf((char *)&str, 2048, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", v1, "noncedup.c", "isdupnonce", 70);
    function_1ccec(3, &str, 1);
    function_3aadc(1);
    // UNREACHABLE
}

// Address range: 0x1d500 - 0x1d504
int32_t function_1d500(void) {
    // 0x1d500
    int32_t result; // 0x1d500
    return result;
}

// Address range: 0x1d504 - 0x1d554
int32_t function_1d504(void) {
    int32_t v1 = *__errno_location(); // 0x1d510
    int32_t str; // bp+32, 0x1d504
    snprintf((char *)&str, 2048, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", v1, "noncedup.c", "isdupnonce", 70);
    function_1ccec(3, &str, 1);
    function_3aadc(1);
    // UNREACHABLE
}

// Address range: 0x1d554 - 0x1d558
int32_t function_1d554(void) {
    // 0x1d554
    int32_t result; // 0x1d554
    return result;
}

// Address range: 0x1d558 - 0x1d5a4
int32_t function_1d558(void) {
    int32_t v1 = *__errno_location(); // 0x1d564
    int32_t str; // bp+32, 0x1d558
    snprintf((char *)&str, 2048, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", v1, "noncedup.c", "isdupnonce", 93);
    function_1ccec(3, &str, 1);
    return 1;
}

// Address range: 0x1d5a4 - 0x1d5aa
int32_t function_1d5a4(int32_t result, int32_t a2) {
    // 0x1d5a4
    int32_t v1; // 0x1d5a4
    *(char *)(a2 + 21) = (char)v1;
    return result;
}

// Address range: 0x1d5ac - 0x1d5fc
int32_t function_1d5ac(void) {
    int32_t v1 = *__errno_location(); // 0x1d5b8
    int32_t str; // bp+32, 0x1d5ac
    snprintf((char *)&str, 2048, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", v1, "noncedup.c", "isdupnonce", 93);
    function_1ccec(3, &str, 1);
    function_3aadc(1);
    // UNREACHABLE
}

// Address range: 0x1d5fc - 0x1d600
int32_t function_1d5fc(void) {
    // 0x1d5fc
    int32_t result; // 0x1d5fc
    return result;
}

// Address range: 0x1d604 - 0x1d800
// Used cryptographic patterns:
//  - SHA256_Hash_constant_words_K__0x428a2f98_ (32-bit, little endian)
int32_t function_1d604(int32_t result, int32_t a2, int32_t a3) {
    // 0x1d604
    if (a3 < 1) {
        // 0x1d7f8
        return result;
    }
    int32_t v1 = result + 136; // 0x1d624
    int32_t v2 = result + 168; // bp-332, 0x1d638
    int32_t v3; // bp-296, 0x1d604
    int32_t v4 = &v3; // 0x1d644
    int32_t v5 = &v2; // 0x1d6c4
    int32_t v6 = a2; // 0x1d638
    int32_t v7; // 0x1d604
    int32_t v8; // bp-300, 0x1d604
    while (true) {
      lab_0x1d63c:;
        int32_t v9 = &v8; // 0x1d644
        int32_t v10 = v6; // 0x1d644
        while (true) {
            unsigned char v11 = *(char *)(v10 + 1); // 0x1d648
            unsigned char v12 = *(char *)(v10 + 2); // 0x1d64c
            unsigned char v13 = *(char *)(v10 + 3); // 0x1d650
            unsigned char v14 = *(char *)v10; // 0x1d654
            v9 += 4;
            *(int32_t *)v9 = 256 * (int32_t)v12 | 0x10000 * (int32_t)v11 | (int32_t)v13 | 0x1000000 * (int32_t)v14;
            v10 += 4;
            v7 = v4;
            int32_t v15; // bp-236, 0x1d604
            if (v9 == (int32_t)&v15) {
                goto lab_0x1d678;
            }
        }
        goto lab_0x1d6c0;
    }
  lab_0x1d7f8:;
    // 0x1d7f8
    int32_t result2; // 0x1d604
    return result2;
  lab_0x1d678:;
    uint32_t v16 = *(int32_t *)(v7 + 56); // 0x1d678
    int32_t v17 = v7 + 4; // 0x1d680
    uint32_t v18 = *(int32_t *)v17; // 0x1d680
    int32_t v19 = *(int32_t *)(v7 + 36); // 0x1d688
    int32_t v20 = *(int32_t *)v7; // 0x1d68c
    *(int32_t *)(v7 + 64) = v20 + v19 + ((v16 / 0x20000 | 0x8000 * v16) ^ v16 / 1024 ^ (v16 / 0x80000 | 0x2000 * v16)) + ((v18 / 128 | 0x2000000 * v18) ^ v18 / 8 ^ (v18 / 0x40000 | 0x4000 * v18));
    v7 = v17;
    int32_t v21; // bp-104, 0x1d604
    if (v17 == (int32_t)&v21) {
        goto lab_0x1d6c0;
    } else {
        goto lab_0x1d678;
    }
  lab_0x1d6c0:;
    int32_t v22 = v1 + 4; // 0x1d6d4
    int32_t v23 = v5 + 4; // 0x1d6dc
    *(int32_t *)v23 = *(int32_t *)v1;
    int32_t v24 = v22; // 0x1d6e0
    int32_t v25 = v23; // 0x1d6e0
    while (v2 != v22) {
        // 0x1d6d4
        v22 = v24 + 4;
        v23 = v25 + 4;
        *(int32_t *)v23 = *(int32_t *)v24;
        v24 = v22;
        v25 = v23;
    }
    int32_t v26 = 0; // 0x1d70c
    int32_t v27; // 0x1d604
    int32_t v28 = v27;
    int32_t v29; // 0x1d604
    int32_t v30 = v29;
    int32_t v31; // 0x1d604
    int32_t v32 = v31;
    int32_t v33; // 0x1d604
    int32_t v34 = v33;
    int32_t v35; // 0x1d604
    uint32_t v36 = v35;
    int32_t v37; // 0x1d604
    uint32_t v38 = v37;
    int32_t v39 = 4 * v26; // 0x1d74c
    int32_t v40 = *(int32_t *)(v39 + v4); // 0x1d74c
    int32_t v41 = *(int32_t *)(v39 + (int32_t)&SHA256_Hash_constant_words_K__0x428a2f98__at_657bc); // 0x1d760
    int32_t v42 = v26 + 1; // 0x1d768
    int32_t v43 = ((v38 / 2048 | 0x200000 * v38) ^ (v38 / 64 | 0x4000000 * v38) ^ (v38 / 0x2000000 | 128 * v38)) + v8 + (v28 & v38 | v30 & -1 - v38) + v40 + v41; // 0x1d780
    int32_t v44; // 0x1d604
    int32_t v45 = v43 + v44; // 0x1d788
    int32_t v46 = ((v32 ^ v34) & v36 ^ v32 & v34) + ((v36 / 0x2000 | 0x80000 * v36) ^ (v36 / 4 | 0x40000000 * v36) ^ (v36 / 0x400000 | 1024 * v36)) + v43; // 0x1d78c
    int32_t v47 = v30; // 0x1d798
    v26 = v42;
    int32_t v48 = v32; // 0x1d798
    int32_t v49 = v28; // 0x1d798
    int32_t v50 = v34; // 0x1d798
    while (v42 != 64) {
        // 0x1d728
        v28 = v38;
        v30 = v49;
        v32 = v36;
        v34 = v48;
        v36 = v46;
        v38 = v45;
        v39 = 4 * v26;
        v40 = *(int32_t *)(v39 + v4);
        v41 = *(int32_t *)(v39 + (int32_t)&SHA256_Hash_constant_words_K__0x428a2f98__at_657bc);
        v42 = v26 + 1;
        v43 = ((v38 / 2048 | 0x200000 * v38) ^ (v38 / 64 | 0x4000000 * v38) ^ (v38 / 0x2000000 | 128 * v38)) + v47 + (v28 & v38 | v30 & -1 - v38) + v40 + v41;
        v45 = v43 + v50;
        v46 = ((v32 ^ v34) & v36 ^ v32 & v34) + ((v36 / 0x2000 | 0x80000 * v36) ^ (v36 / 4 | 0x40000000 * v36) ^ (v36 / 0x400000 | 1024 * v36)) + v43;
        v47 = v30;
        v26 = v42;
        v48 = v32;
        v49 = v28;
        v50 = v34;
    }
    // 0x1d79c
    v8 = v30;
    int32_t * v51 = (int32_t *)v1; // 0x1d7c8
    int32_t v52 = *v51; // 0x1d7c8
    int32_t v53 = v5 + 4; // 0x1d7cc
    *v51 = *(int32_t *)v53 + v52;
    int32_t v54 = v1 + 4; // 0x1d7d4
    int32_t v55 = v53; // 0x1d7dc
    int32_t v56 = v54; // 0x1d7dc
    while (v2 != v54) {
        // 0x1d7c8
        v51 = (int32_t *)v56;
        v52 = *v51;
        v53 = v55 + 4;
        *v51 = *(int32_t *)v53 + v52;
        v54 = v56 + 4;
        v55 = v53;
        v56 = v54;
    }
    // 0x1d7e0
    v6 += 64;
    result2 = v52;
    v37 = v45;
    v27 = v38;
    v29 = v28;
    v35 = v46;
    v31 = v36;
    v33 = v32;
    v44 = v34;
    if (64 * a3 + a2 == v6) {
        // break -> 0x1d7f8
        goto lab_0x1d7f8;
    }
    goto lab_0x1d63c;
}

// Address range: 0x1d800 - 0x1d82c
int32_t function_1d800(int32_t * a1) {
    int32_t result = (int32_t)a1;
    int32_t v1 = &g29; // 0x1d808
    int32_t v2 = result + 136; // 0x1d808
    v1 += 4;
    *(int32_t *)v2 = *(int32_t *)v1;
    while (v2 != result + 164) {
        // 0x1d80c
        v2 += 4;
        v1 += 4;
        *(int32_t *)v2 = *(int32_t *)v1;
    }
    // 0x1d81c
    *(int32_t *)(result + 4) = 0;
    *a1 = 0;
    return result;
}

// Address range: 0x1d830 - 0x1d8dc
int32_t function_1d830(int32_t * a1, int32_t a2, uint32_t a3) {
    int32_t v1 = (int32_t)a1;
    int32_t * v2 = (int32_t *)(v1 + 4); // 0x1d838
    int32_t v3 = *v2; // 0x1d838
    uint32_t v4 = 64 - v3; // 0x1d844
    int32_t v5 = v1 + 8;
    int32_t v6 = v4 < a3 ? v4 : a3;
    int32_t * dest_mem = memcpy((int32_t *)(v3 + v5), (int32_t *)a2, v6); // 0x1d860
    uint32_t v7 = *v2 + a3; // 0x1d868
    if (v7 >= 63 != v7 != 63) {
        // 0x1d874
        *v2 = v7;
        return (int32_t)dest_mem;
    }
    uint32_t v8 = a3 - v6; // 0x1d87c
    int32_t v9 = v6 + a2; // 0x1d884
    function_1d604(v1, v5, 1);
    uint32_t v10 = v8 % 64; // 0x1d89c
    function_1d604(v1, v9, v8 / 64);
    int32_t dest_mem2 = (int32_t)memcpy((int32_t *)v5, (int32_t *)((v8 & -64) + v9), v10); // 0x1d8c4
    *v2 = v10;
    *a1 = (v8 + 64 & -64) + dest_mem2;
    return dest_mem2;
}

// Address range: 0x1d8dc - 0x1d9c8
int32_t function_1d8dc(int32_t * a1, int32_t a2) {
    int32_t v1 = (int32_t)a1;
    int32_t * v2 = (int32_t *)(v1 + 4); // 0x1d8e4
    int32_t v3 = *v2; // 0x1d8e4
    int32_t v4 = v1 + 8;
    uint32_t v5 = v3 + v1; // 0x1d90c
    memset((int32_t *)(v3 + v4), 0, ((v3 & 56) == 56 ? 128 : 64) - v3);
    *(char *)(*v2 + v4) = -128;
    *(char *)(((v5 & 0x20000000) != 0 ? 127 : 63) + v4) = 8 * (char)v5;
    *(char *)(((v5 & 0x20000000) != 0 ? 126 : 62) + v4) = (char)(v5 / 32);
    *(char *)(((v5 & 0x20000000) != 0 ? 125 : 61) + v4) = (char)(v5 / 0x2000);
    *(char *)(((v3 & 56) == 56 ? 124 : 60) + v4) = (char)(v5 / 0x200000);
    int32_t result = function_1d604(v1, v4, (v5 & 0x20000000) != 0 ? 2 : 1); // 0x1d988
    int32_t v6 = a2; // 0x1d990
    int32_t v7 = v1 + 136;
    int32_t * v8 = (int32_t *)v7; // 0x1d994
    *(char *)(v6 + 3) = (char)*v8;
    *(char *)(v6 + 2) = (char)(*v8 / 256);
    *(char *)(v6 + 1) = (char)*(int16_t *)(v7 + 2);
    *(char *)v6 = *(char *)(v7 + 3);
    int32_t v9 = v7 + 4; // 0x1d9bc
    v6 += 4;
    while (v1 + 164 != v7) {
        // 0x1d994
        v7 = v9;
        v8 = (int32_t *)v7;
        *(char *)(v6 + 3) = (char)*v8;
        *(char *)(v6 + 2) = (char)(*v8 / 256);
        *(char *)(v6 + 1) = (char)*(int16_t *)(v7 + 2);
        *(char *)v6 = *(char *)(v7 + 3);
        v9 = v7 + 4;
        v6 += 4;
    }
    // 0x1d9c0
    return result;
}

// Address range: 0x1d9c8 - 0x1da24
int32_t function_1d9c8(int32_t * a1, int32_t a2, int32_t * a3) {
    // 0x1d9c8
    int32_t v1; // bp-48, 0x1d9c8
    int32_t v2 = &v1; // 0x1d9dc
    int32_t v3 = &g29; // 0x1d9dc
    v3 += 4;
    *(int32_t *)v2 = *(int32_t *)v3;
    v2 += 4;
    while (v3 != (int32_t)&g30) {
        // 0x1d9e0
        v3 += 4;
        *(int32_t *)v2 = *(int32_t *)v3;
        v2 += 4;
    }
    int32_t v4 = 0; // bp-184, 0x1d9f8
    function_1d830(&v4, (int32_t)a1, a2);
    return function_1d8dc(&v4, (int32_t)a3);
}

// Address range: 0x1da28 - 0x1da30
int32_t function_1da28(void) {
    // 0x1da28
    return 0;
}

// Address range: 0x1da30 - 0x1dc9c
int32_t function_1da30(int32_t a1, int32_t str2, int32_t a3) {
    int32_t * sock = (int32_t *)(a1 + 588); // 0x1da54
    uint32_t v1 = *sock; // 0x1da54
    int32_t str; // bp-2088, 0x1da30
    if (!((g194 == 0 | *(char *)&g71 == 0))) {
        char v2 = *(char *)&g70; // 0x1dc24
        if ((v2 | *(char *)&g179) == 0 != g28 < (char *)7) {
            // 0x1dc30
            snprintf((char *)&str, 2048, "SEND: %s", (char *)str2);
            function_1ccec(7, &str, 0);
        }
    }
    int32_t v3 = a3 + 1; // 0x1da74
    *(int16_t *)(strlen((char *)str2) + str2) = 10;
    int32_t v4 = 0; // 0x1da9c
    int32_t v5 = 0; // 0x1da9c
    if (v3 < 1) {
        goto lab_0x1dbac;
      lab_0x1dbac:;
        int32_t * v6 = (int32_t *)(a1 + 496); // 0x1dbb4
        int32_t v7 = *v6; // 0x1dbb4
        int32_t * v8 = (int32_t *)(a1 + 500); // 0x1dbb8
        int32_t * v9 = (int32_t *)(a1 + 504); // 0x1dbbc
        uint32_t v10 = *v9; // 0x1dbbc
        int32_t * v11 = (int32_t *)(a1 + 508); // 0x1dbc4
        *v6 = v7 + 1;
        int32_t * v12 = (int32_t *)(a1 + 512); // 0x1dbd0
        uint32_t v13 = *v12; // 0x1dbd0
        uint32_t v14 = v10 + v4; // 0x1dbd4
        *v8 = *v8 + (int32_t)(v7 == -1);
        int32_t * v15 = (int32_t *)(a1 + 516); // 0x1dbe0
        uint32_t v16 = v13 + v4; // 0x1dbe4
        *v9 = v14;
        *v11 = *v11 + v5 + (int32_t)(v14 < v10);
        *v12 = v16;
        *v15 = *v15 + v5 + (int32_t)(v16 < v13);
        return 0;
    }
    int32_t v17 = v1 < 0 ? v1 + 31 : v1;
    int32_t v18 = -v1; // 0x1daac
    int32_t v19; // bp-2092, 0x1da30
    int32_t v20 = &v19; // 0x1db08
    int32_t v21; // bp-40, 0x1da30
    int32_t * v22 = (int32_t *)((int32_t)&v21 - 2048 + 4 * (v17 >> 5)); // 0x1db18
    int32_t length = v3; // 0x1dae8
    int32_t v23 = 0; // 0x1dae8
    int32_t result; // 0x1da30
    while (true) {
        v19 = 0;
        int32_t timeout = 1; // bp-2096, 0x1db04
        int32_t v24 = v20; // 0x1db08
        v24 += 4;
        *(int32_t *)v24 = 0;
        int32_t v25; // bp-1964, 0x1da30
        while (v24 != (int32_t)&v25) {
            // 0x1db0c
            v24 += 4;
            *(int32_t *)v24 = 0;
        }
        // 0x1db18
        *v22 = *v22 | 1 << (v18 < 0 ? v1 % 32 : -((v18 % 32)));
        int32_t v26; // 0x1db48
        while (select(v1 + 1, NULL, (struct _TYPEDEF_fd_set *)&str, NULL, (struct timeval *)&timeout) <= 0) {
            // 0x1db44
            v26 = *__errno_location();
            result = 1;
            if (v26 != 4) {
                return result;
            }
            v24 = v20;
            v24 += 4;
            *(int32_t *)v24 = 0;
            while (v24 != (int32_t)&v25) {
                // 0x1db0c
                v24 += 4;
                *(int32_t *)v24 = 0;
            }
            // 0x1db18
            *v22 = *v22 | 1 << (v18 < 0 ? v1 % 32 : -((v18 % 32)));
        }
        uint32_t v27 = send(*sock, (int32_t *)(v23 + str2), length, MSG_NOSIGNAL); // 0x1db7c
        // 0x1daec
        while (v27 < 0) {
            int32_t v28 = *__errno_location(); // 0x1dc64
            result = 2;
            if (v28 != 11) {
                return result;
            }
            v19 = 0;
            timeout = 1;
            v24 = v20;
            v24 += 4;
            *(int32_t *)v24 = 0;
            while (v24 != (int32_t)&v25) {
                // 0x1db0c
                v24 += 4;
                *(int32_t *)v24 = 0;
            }
            // 0x1db18
            *v22 = *v22 | 1 << (v18 < 0 ? v1 % 32 : -((v18 % 32)));
            while (select(v1 + 1, NULL, (struct _TYPEDEF_fd_set *)&str, NULL, (struct timeval *)&timeout) <= 0) {
                // 0x1db44
                v26 = *__errno_location();
                result = 1;
                if (v26 != 4) {
                    return result;
                }
                v24 = v20;
                v24 += 4;
                *(int32_t *)v24 = 0;
                while (v24 != (int32_t)&v25) {
                    // 0x1db0c
                    v24 += 4;
                    *(int32_t *)v24 = 0;
                }
                // 0x1db18
                *v22 = *v22 | 1 << (v18 < 0 ? v1 % 32 : -((v18 % 32)));
            }
            // 0x1db64
            v27 = send(*sock, (int32_t *)(v23 + str2), length, MSG_NOSIGNAL);
        }
        // 0x1db88
        v4 = v27 + v23;
        length -= v27;
        v23 = v4;
        if (length <= 0) {
            // 0x1dba4
            v5 = v4 >> 31;
            goto lab_0x1dbac;
        }
    }
  lab_0x1db58_2:
    // 0x1db58
    return result;
}

// Address range: 0x1dc9c - 0x1e150
int32_t function_1dc9c(int32_t a1, int32_t sock, int32_t a3) {
    char * v1 = (char *)*(int32_t *)(a1 + 584);
    char * v2 = (char *)*(int32_t *)(a1 + 600);
    int32_t str; // bp-3104, 0x1dc9c
    if (a3 == 0) {
        // 0x1dec0
        snprintf((char *)&str, 1024, "CONNECT %s:%s HTTP/1.1\r\nHost: %s:%s\r\n\r\n", v2, v1, v2, v1);
    } else {
        // 0x1dcc0
        snprintf((char *)&str, 1024, "CONNECT %s:%s HTTP/1.0\r\n\r\n", v2, v1);
    }
    // 0x1dcdc
    int32_t str2; // bp-2080, 0x1dc9c
    if (*(char *)&g71 != 0) {
        char v3 = *(char *)&g70; // 0x1dd0c
        if ((v3 | *(char *)&g179) == 0 != g28 < (char *)7) {
            int32_t v4 = *(int32_t *)(a1 + 608); // 0x1dd18
            int32_t v5 = *(int32_t *)(a1 + 604); // 0x1dd24
            snprintf((char *)&str2, 2048, "Sending proxy %s:%s - %s", (char *)v5, (char *)v4, &str);
            function_1ccec(7, &str2, 0);
        }
    }
    // 0x1dd50
    send(sock, &str, strlen((char *)&str), 0);
    int32_t v6 = recv(sock, &str, 12, 0); // 0x1dd7c
    if (v6 < 1) {
        char v7 = *(char *)&g70; // 0x1e02c
        if ((v7 | *(char *)&g179) != 0 || g28 > (char *)3) {
            int32_t v8 = *(int32_t *)(a1 + 608); // 0x1e05c
            int32_t v9 = *(int32_t *)(a1 + 604); // 0x1e064
            snprintf((char *)&str2, 2048, "Couldn't read from proxy %s:%s after sending CONNECT", (char *)v9, (char *)v8);
            function_1ccec(4, &str2, 0);
            return 0;
        }
        // 0x1dff4
        return 0;
    }
    // 0x1dd88
    int32_t v10; // bp-32, 0x1dc9c
    int32_t v11 = (int32_t)&v10 - 3072;
    *(char *)(v6 + v11) = 0;
    if (*(char *)&g71 == 0) {
        goto lab_0x1de04;
    } else {
        // 0x1dda4
        if (*(char *)&g179 == 0) {
            // 0x1ddb8
            if (*(char *)&g70 == 0 == g28 < (char *)7) {
                goto lab_0x1de04;
            } else {
                goto lab_0x1ddcc;
            }
        } else {
            goto lab_0x1ddcc;
        }
    }
  lab_0x1df84:;
    char v12 = *(char *)&g70; // 0x1dfa0
    if ((v12 | *(char *)&g179) == 0 != g28 < (char *)4) {
        int32_t v13 = *(int32_t *)(a1 + 608); // 0x1dfc0
        int32_t v14 = *(int32_t *)(a1 + 604); // 0x1dfc8
        snprintf((char *)&str2, 2048, "Couldn't read HTTP byte from proxy %s:%s", (char *)v14, (char *)v13);
        function_1ccec(4, &str2, 0);
    }
    // 0x1dff4
    return 0;
  lab_0x1de60:
    // 0x1de60
    if (strncmp((char *)&str, "\r\n\r\n", 4) == 0) {
        // 0x1e0cc
    } else {
        // 0x1de88
        int32_t * v15; // 0x1dc9c
        str = 0x1000000 * (int32_t)v15 >> 24;
        if (recv(sock, &str2, 1, 0) == -1) {
            goto lab_0x1df84;
        } else {
            uint32_t v16 = str2 % 256; // 0x1deac
            int32_t * v17; // 0x1dc9c
            v15 = v17;
            int32_t * v18; // 0x1dc9c
            v17 = v18;
            v18 = (int32_t *)v16;
            if (v16 == 255) {
                goto lab_0x1df84;
            } else {
                goto lab_0x1de60;
            }
        }
    }
  lab_0x1de04:
    // 0x1de04
    if (strcmp((char *)&str, "HTTP/1.1 200") != 0) {
        // 0x1dee8
        if (strcmp((char *)&str, "HTTP/1.0 200") != 0) {
            char v19 = *(char *)&g70; // 0x1df1c
            if ((v19 | *(char *)&g179) == 0 == g28 < (char *)4) {
                // 0x1dff4
                return 0;
            }
            int32_t v20 = *(int32_t *)(a1 + 608); // 0x1df3c
            int32_t v21 = *(int32_t *)(a1 + 604); // 0x1df44
            snprintf((char *)&str2, 2048, "HTTP Error from proxy %s:%s - %s", (char *)v21, (char *)v20, &str);
            function_1ccec(4, &str2, 0);
            return 0;
        }
    }
    int32_t v22 = 0;
    while (recv(sock, &str2, 1, 0) != -1) {
        // 0x1de3c
        *(char *)(v22 + (int32_t)&str) = (char)str2;
        if (str2 % 256 == 255) {
            goto lab_0x1df84;
        }
        int32_t v23 = v22 + 1; // 0x1de48
        int32_t v24 = v23; // 0x1de54
        if (v23 == 4) {
            goto lab_0x1de60;
        }
        v22 = v24;
    }
    // 0x1e000
    *(char *)(v22 + v11) = -1;
    goto lab_0x1df84;
  lab_0x1ddcc:;
    int32_t v25 = *(int32_t *)(a1 + 608); // 0x1ddcc
    int32_t v26 = *(int32_t *)(a1 + 604); // 0x1ddd8
    snprintf((char *)&str2, 2048, "Received from proxy %s:%s - %s", (char *)v26, (char *)v25, &str);
    function_1ccec(7, &str2, 0);
    goto lab_0x1de04;
}

// Address range: 0x1e150 - 0x1e190
int32_t function_1e150(int32_t a1) {
    int32_t v1 = *(int32_t *)(a1 + 592); // 0x1e158
    if (v1 != 0) {
        *(char *)v1 = 0;
    }
    int32_t * v2 = (int32_t *)(a1 + 588); // 0x1e16c
    int32_t fd = *v2; // 0x1e16c
    *(char *)(a1 + 643) = 0;
    *(char *)(a1 + 641) = 0;
    int32_t result = 0; // 0x1e17c
    if (fd != 0) {
        // 0x1e180
        result = close(fd);
    }
    // 0x1e184
    *v2 = 0;
    return result;
}

// Address range: 0x1e190 - 0x1e1b8
int32_t function_1e190(int32_t fd) {
    // 0x1e190
    fcntl(fd, F_GETFL);
    return fcntl(fd, F_SETFL);
}

// Address range: 0x1e1b8 - 0x1e24c
int32_t function_1e1b8(uint32_t a1, char a2) {
    int32_t v1 = a2;
    int32_t v2; // bp-140, 0x1e1b8
    int32_t v3 = &v2; // 0x1e1cc
    v3 += 4;
    *(int32_t *)v3 = 0;
    int32_t v4; // bp-12, 0x1e1b8
    while (v3 != (int32_t)&v4) {
        // 0x1e1d0
        v3 += 4;
        *(int32_t *)v3 = 0;
    }
    int32_t v5 = a1 < 0 ? a1 + 31 : a1;
    v2 = 0;
    int32_t v6 = -a1; // 0x1e1f4
    int32_t timeout = (int32_t)(v1 < 0) - 1 & v1; // bp-144, 0x1e1f8
    int32_t v7; // bp-8, 0x1e1b8
    int32_t * v8 = (int32_t *)(4 * (v5 >> 5) - 128 + (int32_t)&v7); // 0x1e208
    *v8 = *v8 | 1 << (v6 < 0 ? a1 % 32 : -((v6 % 32)));
    int32_t readfds; // bp-136, 0x1e1b8
    int32_t v9 = select(a1 + 1, (struct _TYPEDEF_fd_set *)&readfds, NULL, NULL, (struct timeval *)&timeout); // 0x1e234
    return v9 > 0;
}

// Address range: 0x1e24c - 0x1e2b0
int32_t function_1e24c(int32_t a1, uint32_t a2) {
    if (a1 != 1 || (uint32_t)function_47658(1) < a2) {
        // 0x1e2a0
        return 0;
    }
    int32_t v1 = function_47674(1, a2); // 0x1e280
    if (v1 == 0) {
        // 0x1e2a0
        return 0;
    }
    // 0x1e28c
    if (*(int32_t *)v1 == 2) {
        // 0x1e298
        return function_47820(v1);
    }
    // 0x1e2a0
    return 0;
}

// Address range: 0x1e2b0 - 0x1e2c8
int32_t function_1e2b0(void) {
    // 0x1e2b0
    int32_t v1; // 0x1e2b0
    int32_t v2 = function_1e24c(v1, v1); // 0x1e2b4
    if (v2 == 0) {
        return 0;
    }
    // 0x1e2c0
    return (int32_t)__strdup((char *)v2);
}

// Address range: 0x1e2c8 - 0x1e324
int32_t function_1e2c8(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = *__errno_location(); // 0x1e2ec
    int32_t str; // bp-2072, 0x1e2c8
    snprintf((char *)&str, 2048, "Failed to sem_post errno=%d cgsem=0x%p in %s %s():%d", v1, (int32_t *)a1, (char *)a2, (char *)a3, a4);
    function_1ccec(3, &str, 1);
    function_3aadc(1);
    // UNREACHABLE
}

// Address range: 0x1e324 - 0x1e330
int32_t function_1e324(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x1e324
    int32_t result; // 0x1e324
    return result;
}

// Address range: 0x1e330 - 0x1e480
int32_t function_1e330(int32_t str2, char * a2, int32_t a3) {
    int32_t str; // bp-2064, 0x1e330
    if (str2 == 0) {
        // 0x1e41c
        if (*(char *)&g179 == 0) {
            // 0x1e430
            if (*(char *)&g70 == 0 == g28 < (char *)3) {
                // 0x1e408
                return 0;
            }
        }
        // 0x1e458
        snprintf((char *)&str, 2048, "Null string passed to valid_hex from in %s %s():%d", "util.c", a2, a3);
        // 0x1e3f4
        function_1ccec(3, &str, 0);
        // 0x1e408
        return 0;
    }
    uint32_t len = strlen((char *)str2); // 0x1e348
    if (len == 0) {
        // 0x1e408
        return 1;
    }
    int32_t v1 = len % 256; // 0x1e354
    int32_t v2 = v1; // 0x1e330
    if (*(int32_t *)(4 * v1 + (int32_t)&g17) < 0) {
      lab_0x1e390:
        // 0x1e390
        if (*(char *)&g179 == 0) {
            // 0x1e3a4
            if (*(char *)&g70 == 0 == g28 < (char *)3) {
                // 0x1e408
                return 0;
            }
        }
        // 0x1e3cc
        snprintf((char *)&str, 2048, "Invalid char 0x%x passed to valid_hex from in %s %s():%d", v2, "util.c", a2, a3);
        // 0x1e3f4
        function_1ccec(3, &str, 0);
        // 0x1e408
        return 0;
    }
    int32_t v3 = str2; // 0x1e380
    while (v3 != str2 - 1 + len) {
        // 0x1e380
        v3++;
        int32_t v4 = (int32_t)*(char *)v3; // 0x1e380
        v2 = v4;
        if (*(int32_t *)(4 * v4 + (int32_t)&g17) < 0) {
            goto lab_0x1e390;
        }
    }
    // 0x1e408
    return 1;
}

// Address range: 0x1e480 - 0x1e4f0
int32_t function_1e480(int32_t rwlock, char * a2, int32_t a3) {
    // 0x1e480
    if (pthread_rwlock_wrlock((int32_t *)rwlock) == 0) {
        // 0x1e4a0
        return 0;
    }
    int32_t v1 = *__errno_location(); // 0x1e4bc
    int32_t str; // bp-2064, 0x1e480
    snprintf((char *)&str, 2048, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", v1, "util.c", a2, a3);
    function_1ccec(3, &str, 1);
    function_3aadc(1);
    // UNREACHABLE
}

// Address range: 0x1e4f0 - 0x1e4fc
int32_t function_1e4f0(int32_t a1, int32_t a2) {
    // 0x1e4f0
    int32_t result; // 0x1e4f0
    return result;
}

// Address range: 0x1e4fc - 0x1e56c
int32_t function_1e4fc(int32_t rwlock, char * a2, int32_t a3) {
    // 0x1e4fc
    if (pthread_rwlock_unlock((int32_t *)rwlock) == 0) {
        // 0x1e51c
        return 0;
    }
    int32_t v1 = *__errno_location(); // 0x1e538
    int32_t str; // bp-2064, 0x1e4fc
    snprintf((char *)&str, 2048, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", v1, "util.c", a2, a3);
    function_1ccec(3, &str, 1);
    function_3aadc(1);
    // UNREACHABLE
}

// Address range: 0x1e56c - 0x1e578
int32_t function_1e56c(int32_t a1, int32_t a2) {
    // 0x1e56c
    int32_t result; // 0x1e56c
    return result;
}

// Address range: 0x1e578 - 0x1e5e8
int32_t function_1e578(int32_t mutex, char * a2, int32_t a3) {
    // 0x1e578
    if (pthread_mutex_unlock((int32_t *)mutex) == 0) {
        // 0x1e598
        return 0;
    }
    int32_t v1 = *__errno_location(); // 0x1e5b4
    int32_t str; // bp-2064, 0x1e578
    snprintf((char *)&str, 2048, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", v1, "util.c", a2, a3);
    function_1ccec(3, &str, 1);
    function_3aadc(1);
    // UNREACHABLE
}

// Address range: 0x1e5e8 - 0x1e5f4
int32_t function_1e5e8(int32_t a1, int32_t a2) {
    // 0x1e5e8
    int32_t result; // 0x1e5e8
    return result;
}

// Address range: 0x1e5f4 - 0x1e64c
int32_t function_1e5f4(char * a1, int32_t a2) {
    int32_t v1 = *__errno_location(); // 0x1e60c
    int32_t str; // bp-2064, 0x1e5f4
    snprintf((char *)&str, 2048, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", v1, "util.c", a1, a2);
    function_1ccec(3, &str, 1);
    function_3aadc(1);
    // UNREACHABLE
}

// Address range: 0x1e64c - 0x1e658
int32_t function_1e64c(int32_t a1, int32_t a2) {
    // 0x1e64c
    int32_t result; // 0x1e64c
    return result;
}

// Address range: 0x1e658 - 0x1e6e4
int32_t function_1e658(int32_t a1) {
    int32_t mutex = a1 + 704; // 0x1e65c
    if (pthread_mutex_lock((int32_t *)mutex) != 0) {
        // 0x1e6d4
        function_1e5f4("clear_sock", 1788);
        // UNREACHABLE
    }
    int32_t * buf = (int32_t *)(a1 + 592);
    int32_t sock = *(int32_t *)(a1 + 588); // 0x1e688
    while (sock != 0) {
        // 0x1e678
        if (recv(sock, (int32_t *)*buf, 0x1ffc, 0) < 1) {
            // break -> 0x1e6a0
            break;
        }
        sock = *(int32_t *)(a1 + 588);
    }
    // 0x1e6a0
    function_1e578(mutex, "clear_sock", 1797);
    int32_t result = function_1da28(); // 0x1e6bc
    int32_t v1 = *buf; // 0x1e6c0
    if (v1 != 0) {
        *(char *)v1 = 0;
    }
    return result;
}

// Address range: 0x1e6e8 - 0x1e748
int32_t function_1e6e8(int32_t a1, int32_t a2) {
    int32_t mutex = a1 + 12; // 0x1e6ec
    if (pthread_mutex_lock((int32_t *)mutex) != 0) {
        // 0x1e738
        function_1e5f4("tq_freezethaw", 1106);
        // UNREACHABLE
    }
    // 0x1e708
    *(char *)(a1 + 8) = (char)a2;
    pthread_cond_signal((int32_t *)(a1 + 40));
    function_1e578(mutex, "tq_freezethaw", 1109);
    return function_1da28();
}

// Address range: 0x1e74c - 0x1e7c8
int32_t function_1e74c(uint32_t a1, char * a2, char * a3, int32_t a4) {
    int32_t v1 = a1 & -4;
    int32_t size = a1 % 4 == 0 ? v1 : v1 + 4;
    int32_t * mem = malloc(size); // 0x1e774
    if (mem != NULL) {
        // 0x1e780
        return (int32_t)mem;
    }
    // 0x1e78c
    int32_t str; // bp-2072, 0x1e74c
    snprintf((char *)&str, 2048, "Failed to malloc size %d from %s %s:%d", size, a2, a3, a4);
    function_1ccec(3, &str, 1);
    function_3aadc(1);
    // UNREACHABLE
}

// Address range: 0x1e7c8 - 0x1e7d4
int32_t function_1e7c8(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x1e7c8
    int32_t result; // 0x1e7c8
    return result;
}

// Address range: 0x1e7d4 - 0x1e858
int32_t function_1e7d4(int32_t nmemb, uint32_t a2, char * a3, char * a4, int32_t a5) {
    int32_t v1 = a2 & -4;
    int32_t size = a2 % 4 == 0 ? v1 : v1 + 4;
    int32_t * mem = calloc(nmemb, size); // 0x1e7fc
    if (mem != NULL) {
        // 0x1e808
        return (int32_t)mem;
    }
    // 0x1e814
    int32_t str; // bp-2072, 0x1e7d4
    snprintf((char *)&str, 2048, "Failed to calloc memb %d size %d from %s %s:%d", nmemb, size, a3, a4, a5);
    function_1ccec(3, &str, 1);
    function_3aadc(1);
    // UNREACHABLE
}

// Address range: 0x1e858 - 0x1e864
int32_t function_1e858(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x1e858
    int32_t result; // 0x1e858
    return result;
}

// Address range: 0x1e864 - 0x1e8e8
int32_t function_1e864(int32_t a1, uint32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t v1 = a2 & -4;
    int32_t v2 = a2 % 4 == 0 ? v1 : v1 + 4;
    int32_t * mem = realloc((int32_t *)a1, v2); // 0x1e88c
    if (mem != NULL) {
        // 0x1e898
        return (int32_t)mem;
    }
    // 0x1e8a8
    int32_t str; // bp-2072, 0x1e864
    snprintf((char *)&str, 2048, "Failed to realloc size %d from %s %s:%d", v2, (char *)a3, (char *)a4, a5);
    function_1ccec(3, &str, 1);
    function_3aadc(1);
    // UNREACHABLE
}

// Address range: 0x1e8e8 - 0x1e8f8
int32_t function_1e8e8(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x1e8e8
    int32_t result; // 0x1e8e8
    return result;
}

// Address range: 0x1e8f8 - 0x1e940
int32_t function_1e8f8(int32_t a1) {
    // 0x1e8f8
    if (a1 == 0) {
        // 0x1e928
        return (int32_t)"http:";
    }
    // 0x1e90c
    if (*(int32_t *)((int32_t)&g18 + 12) == a1) {
        // 0x1e928
        return (int32_t)"http0:";
    }
    int32_t v1 = (int32_t)&g18; // 0x1e918
    int32_t v2 = *(int32_t *)(v1 + 16); // 0x1e91c
    int32_t result = (int32_t)"invalid"; // 0x1e924
    while (v2 != 0) {
        // 0x1e90c
        result = v2;
        if (*(int32_t *)(v1 + 20) == a1) {
            // break -> 0x1e928
            break;
        }
        v1 += 8;
        v2 = *(int32_t *)(v1 + 16);
        result = (int32_t)"invalid";
    }
    // 0x1e928
    return result;
}

// Address range: 0x1e944 - 0x1e9b4
int32_t function_1e944(int32_t * a1, int32_t a2, int32_t a3) {
    int32_t result = (int32_t)a1;
    if (a3 < 1) {
        // 0x1e9a8
        *(char *)a1 = 0;
        return result;
    }
    int32_t v1 = a2 - 1;
    int32_t v2 = v1; // 0x1e964
    int32_t v3 = result; // 0x1e964
    v2++;
    char * v4 = (char *)v2; // 0x1e968
    unsigned char v5 = *v4; // 0x1e968
    char v6 = *(char *)((int32_t)(v5 / 16) + (int32_t)&g17 + 1108); // 0x1e978
    *(char *)v3 = v6;
    unsigned char v7 = *v4; // 0x1e980
    char v8 = *(char *)((int32_t)(v7 % 16) + (int32_t)&g17 + 1108); // 0x1e98c
    *(char *)(v3 + 1) = v8;
    v3 += 2;
    while (v2 != v1 + a3) {
        // 0x1e968
        v2++;
        v4 = (char *)v2;
        v5 = *v4;
        v6 = *(char *)((int32_t)(v5 / 16) + (int32_t)&g17 + 1108);
        *(char *)v3 = v6;
        v7 = *v4;
        v8 = *(char *)((int32_t)(v7 % 16) + (int32_t)&g17 + 1108);
        *(char *)(v3 + 1) = v8;
        v3 += 2;
    }
    int32_t result2 = 2 * a3 + result; // 0x1e998
    *(char *)result2 = 0;
    return result2;
}

// Address range: 0x1e9b4 - 0x1ea64
int32_t function_1e9b4(int32_t a1, uint32_t a2) {
    int32_t v1 = 2 * a2; // 0x1e9b8
    uint32_t v2 = v1 | 1; // 0x1e9c0
    int32_t v3 = -v2; // 0x1e9c8
    int32_t result = function_1e7d4(v2 + 4 - (v3 < 0 ? v2 % 4 : -((v3 % 4))), 1, "util.c", "bin2hex", 787); // 0x1e9fc
    int32_t v4 = a2 < 1 ? result : v1;
    if (a2 <= 0) {
        // 0x1ea54
        *(char *)v4 = 0;
        return result;
    }
    int32_t v5 = a1 - 1; // 0x1ea0c
    int32_t v6 = v5; // 0x1ea1c
    int32_t v7 = result; // 0x1ea1c
    v6++;
    char * v8 = (char *)v6; // 0x1ea20
    unsigned char v9 = *v8; // 0x1ea20
    char v10 = *(char *)((int32_t)(v9 / 16) + (int32_t)&g17 + 1108); // 0x1ea30
    *(char *)v7 = v10;
    unsigned char v11 = *v8; // 0x1ea38
    char v12 = *(char *)((int32_t)(v11 % 16) + (int32_t)&g17 + 1108); // 0x1ea44
    *(char *)(v7 + 1) = v12;
    v7 += 2;
    while (v6 != v5 + a2) {
        // 0x1ea20
        v6++;
        v8 = (char *)v6;
        v9 = *v8;
        v10 = *(char *)((int32_t)(v9 / 16) + (int32_t)&g17 + 1108);
        *(char *)v7 = v10;
        v11 = *v8;
        v12 = *(char *)((int32_t)(v11 % 16) + (int32_t)&g17 + 1108);
        *(char *)(v7 + 1) = v12;
        v7 += 2;
    }
    // 0x1ea54
    *(char *)(v4 + result) = 0;
    return result;
}

// Address range: 0x1ea68 - 0x1ec0c
int32_t function_1ea68(int32_t a1, int32_t a2, int32_t a3) {
    // 0x1ea68
    if ((char)a2 == 0) {
        // 0x1ebec
        return a3 == 0;
    }
    if (a3 == 0) {
        // 0x1eb64
        return 0;
    }
    unsigned char v1 = *(char *)(a2 + 1); // 0x1ea8c
    char * v2; // bp-2064, 0x1ea68
    if (v1 == 0) {
      lab_0x1eb70:;
        char v3 = *(char *)&g70; // 0x1eb8c
        if ((v3 | *(char *)&g179) == 0 != g28 < (char *)3) {
            // 0x1ebac
            v2 = (char *)0x32786568;
            function_1ccec(3, (int32_t *)&v2, 0);
        }
        // 0x1eb64
        return 0;
    }
    int32_t v4 = *(int32_t *)(4 * (int32_t)v1 + (int32_t)&g17); // 0x1eaa0
    int32_t v5 = *(int32_t *)((4 * a2 & 1020) + (int32_t)&g17); // 0x1eaa4
    if ((v5 || v4) <= 0xffffffff) {
      lab_0x1eaf8:;
        char v6 = *(char *)&g70; // 0x1eb14
        if ((v6 | *(char *)&g179) == 0 != g28 < (char *)3) {
            // 0x1eb34
            v2 = (char *)0x32786568;
            function_1ccec(3, (int32_t *)&v2, 0);
        }
        // 0x1eb64
        return 0;
    }
    int32_t v7 = a2 + 4; // 0x1ea68
    int32_t v8 = a3; // 0x1eabc
    int32_t v9 = a1; // 0x1ea68
    v8--;
    *(char *)v9 = (char)(16 * v5 | v4);
    unsigned char v10 = *(char *)(v7 - 2); // 0x1eac4
    while (v10 != 0) {
        if (v8 == 0) {
            // 0x1eb64
            return 0;
        }
        unsigned char v11 = *(char *)(v7 - 1); // 0x1ead8
        if (v11 == 0) {
            goto lab_0x1eb70;
        }
        int32_t v12 = *(int32_t *)(4 * (int32_t)v10 + (int32_t)&g17); // 0x1eae8
        int32_t v13 = *(int32_t *)(4 * (int32_t)v11 + (int32_t)&g17); // 0x1eaec
        v7 += 2;
        v9++;
        if ((v13 || v12) < 0) {
            goto lab_0x1eaf8;
        }
        v8--;
        *(char *)v9 = (char)(16 * v12 | v13);
        v10 = *(char *)(v7 - 2);
    }
    // 0x1ebec
    return v8 == 0;
}

// Address range: 0x1ec0c - 0x1ece4
int32_t function_1ec0c(int32_t * a1, int32_t str) {
    int32_t v1 = 0; // bp-48, 0x1ec24
    int64_t v2 = 0; // bp-28, 0x1ec3c
    int32_t len = strlen((char *)str); // 0x1ec40
    int32_t v3 = 0; // 0x1ec4c
    if (len != 0) {
        int32_t v4 = str - 1; // 0x1ec50
        int32_t v5; // bp-56, 0x1ec0c
        int32_t v6 = &v5; // 0x1ec64
        int32_t v7 = (int32_t)&v2 - 4; // 0x1ec90
        int32_t v8 = v4; // 0x1ec68
        v8++;
        unsigned char v9 = *(char *)v8; // 0x1ec6c
        uint32_t v10 = *(int32_t *)(4 * (int32_t)v9 + (int32_t)&g17 + 1132); // 0x1ec78
        uint64_t v11 = (int64_t)v10; // 0x1ec8c
        *(int32_t *)&v2 = (int32_t)v11;
        int32_t v12; // 0x1ec0c
        int32_t * v13; // 0x1ec0c
        uint64_t v14; // 0x1ec8c
        int32_t v15; // 0x1ec90
        if (v7 != v6) {
            // 0x1ec80
            v15 = v7;
            v13 = (int32_t *)v15;
            v14 = 58 * (int64_t)*v13 + (int64_t)(int32_t)(v11 / 0x100000000);
            *v13 = (int32_t)v14;
            v15 -= 4;
            v12 = v14 / 0x100000000;
            while (v15 != v6) {
                // 0x1ec80
                v13 = (int32_t *)v15;
                v14 = 58 * (int64_t)*v13 + (int64_t)v12;
                *v13 = (int32_t)v14;
                v15 -= 4;
                v12 = v14 / 0x100000000;
            }
        }
        // 0x1eca0
        while (len + v4 != v8) {
            // 0x1ec6c
            v8++;
            v9 = *(char *)v8;
            v10 = *(int32_t *)(4 * (int32_t)v9 + (int32_t)&g17 + 1132);
            v11 = 58 * (int64_t)(int32_t)v2 + (int64_t)v10;
            *(int32_t *)&v2 = (int32_t)v11;
            if (v7 != v6) {
                // 0x1ec80
                v15 = v7;
                v13 = (int32_t *)v15;
                v14 = 58 * (int64_t)*v13 + (int64_t)(int32_t)(v11 / 0x100000000);
                *v13 = (int32_t)v14;
                v15 -= 4;
                v12 = v14 / 0x100000000;
                while (v15 != v6) {
                    // 0x1ec80
                    v13 = (int32_t *)v15;
                    v14 = 58 * (int64_t)*v13 + (int64_t)v12;
                    *v13 = (int32_t)v14;
                    v15 -= 4;
                    v12 = v14 / 0x100000000;
                }
            }
        }
        // 0x1ecac
        v3 = llvm_bswap_i32(v1);
    }
    int32_t v16 = (int32_t)a1;
    int32_t v17 = v16 + 1; // 0x1ecb8
    *(char *)a1 = 0;
    *(int32_t *)v17 = v3;
    int32_t v18 = &v1; // 0x1ecc8
    int32_t v19 = v17;
    int32_t v20 = v19 + 4; // 0x1ecd0
    v18 += 4;
    int32_t result = llvm_bswap_i32(*(int32_t *)v18); // 0x1eccc
    *(int32_t *)v20 = result;
    while (v19 != v16 + 17) {
        // 0x1ecc8
        v19 = v20;
        v20 = v19 + 4;
        v18 += 4;
        result = llvm_bswap_i32(*(int32_t *)v18);
        *(int32_t *)v20 = result;
    }
    // 0x1ecdc
    return result;
}

// Address range: 0x1ece4 - 0x1ed30
int32_t function_1ece4(int32_t a1, int32_t a2) {
    // 0x1ece4
    if (a2 <= 127) {
        // 0x1ed24
        *(int32_t *)(a1 + 1) = a2;
        int32_t v1; // 0x1ece4
        *(char *)a1 = a2 < 128 ? 1 : (char)v1;
        return 2;
    }
    int32_t v2 = a2 > 0x407f ? 0x407f : 2;
    int32_t result = a2 < 0x4080 ? 3 : a1; // 0x1ed08
    char v3 = v2; // 0x1ed08
    if (a2 > 0x407f) {
        // 0x1ed0c
        v3 = (v2 | 0x200000) < a2 ? 4 : 3;
        result = (v2 | 0x200000) < a2 ? 5 : 4;
    }
    // 0x1ed24
    *(int32_t *)(a1 + 1) = a2;
    *(char *)a1 = v3;
    return result;
}

// Address range: 0x1ed30 - 0x1ef20
int32_t function_1ed30(int32_t a1, int32_t a2) {
    int32_t v1 = a2 + 32; // 0x1ed40
    int32_t v2 = a1 + 32; // 0x1ed40
    v2 -= 4;
    uint32_t v3 = *(int32_t *)v2; // 0x1ed44
    v1 -= 4;
    uint32_t v4 = *(int32_t *)v1; // 0x1ed48
    int32_t result; // 0x1ed30
    while (v3 >= v4 != v3 != v4 && v3 >= v4) {
        // 0x1ed58
        result = 1;
        if (v2 == a1) {
            goto lab_0x1ed64;
        }
        v2 -= 4;
        v3 = *(int32_t *)v2;
        v1 -= 4;
        v4 = *(int32_t *)v1;
    }
    // 0x1ed64
    result = v3 >= v4 != v3 != v4;
  lab_0x1ed64:
    // 0x1ed64
    if (*(char *)&g71 == 0) {
        // 0x1ed78
        return result;
    }
    int32_t v5 = llvm_bswap_i32(*(int32_t *)(a1 + 28)); // bp-2136, 0x1edbc
    int32_t v6 = llvm_bswap_i32(*(int32_t *)(a2 + 28)); // bp-2104, 0x1edfc
    int32_t v7 = function_1e9b4((int32_t)&v5, 32); // 0x1ee4c
    int32_t v8 = function_1e9b4((int32_t)&v6, 32); // 0x1ee5c
    if (*(char *)&g71 == 0) {
        // 0x1eee0
        free((int32_t *)v7);
        free((int32_t *)v8);
        return result;
    }
    char v9 = *(char *)&g70; // 0x1ee8c
    if ((v9 | *(char *)&g179) == 0 != g28 < (char *)7) {
        int32_t v10 = result == 0 ? (int32_t)"no (false positive; hash > target)" : (int32_t)"YES (hash <= target)";
        int32_t str; // bp-2072, 0x1ed30
        snprintf((char *)&str, 2048, " Proof: %s\nTarget: %s\nTrgVal? %s", (char *)v7, (char *)v8, (char *)v10);
        function_1ccec(7, &str, 0);
    }
    // 0x1eee0
    free((int32_t *)v7);
    free((int32_t *)v8);
    return result;
}

// Address range: 0x1ef20 - 0x1ef78
int32_t function_1ef20(void) {
    int32_t result = function_1e7d4(1, 88, "util.c", "tq_new", 1075); // 0x1ef44
    *(int32_t *)result = result;
    *(int32_t *)(result + 4) = result;
    pthread_mutex_init((int32_t *)(result + 12), NULL);
    pthread_cond_init((int32_t *)(result + 40), NULL);
    return result;
}

// Address range: 0x1ef7c - 0x1efe4
int32_t function_1ef7c(int32_t a1) {
    if (a1 == 0) {
        return 0;
    }
    // 0x1efc8
    pthread_cond_destroy((int32_t *)(a1 + 40));
    pthread_mutex_destroy((int32_t *)(a1 + 12));
    free((int32_t *)a1);
    return &g306;
}

// Address range: 0x1efe4 - 0x1efec
int32_t function_1efe4(void) {
    // 0x1efe4
    int32_t v1; // 0x1efe4
    return function_1e6e8(v1, 1);
}

// Address range: 0x1efec - 0x1eff4
int32_t function_1efec(void) {
    // 0x1efec
    int32_t v1; // 0x1efec
    return function_1e6e8(v1, 0);
}

// Address range: 0x1eff4 - 0x1f0c4
int32_t function_1eff4(int32_t a1, int32_t a2) {
    int32_t mutex = a1 + 12; // 0x1f020
    int32_t v1 = function_1e7d4(1, 12, "util.c", "tq_push", 1127); // 0x1f024
    int32_t * v2 = (int32_t *)v1; // 0x1f034
    *v2 = a2;
    int32_t v3 = v1 + 4; // 0x1f034
    int32_t * v4 = (int32_t *)v3; // 0x1f038
    *v4 = v3;
    int32_t * v5 = (int32_t *)(v1 + 8); // 0x1f03c
    *v5 = v3;
    if (pthread_mutex_lock((int32_t *)mutex) != 0) {
        // 0x1f0b4
        function_1e5f4("tq_push", 1131);
        // UNREACHABLE
    }
    // 0x1f04c
    int32_t result; // 0x1eff4
    if (*(char *)(a1 + 8) == 0) {
        int32_t * v6 = (int32_t *)(a1 + 4); // 0x1f058
        int32_t v7 = *v6; // 0x1f058
        *v6 = v3;
        *v4 = a1;
        *v5 = v7;
        *(int32_t *)v7 = v3;
        result = 1;
    } else {
        // 0x1f0a4
        free(v2);
        result = 0;
    }
    // 0x1f070
    pthread_cond_signal((int32_t *)(a1 + 40));
    function_1e578(mutex, "tq_push", 1144);
    function_1da28();
    return result;
}

// Address range: 0x1f0c8 - 0x1f1a4
int32_t function_1f0c8(int32_t a1, int32_t abstime) {
    int32_t v1 = a1 + 12; // 0x1f0cc
    int32_t * mutex = (int32_t *)v1; // 0x1f0dc
    if (pthread_mutex_lock(mutex) != 0) {
        // 0x1f184
        function_1e5f4("tq_pop", 1156);
        // UNREACHABLE
    }
    if (a1 != 0) {
        // 0x1f0f4
        abort();
        // UNREACHABLE
    }
    if (abstime == 0) {
        // 0x1f178
        pthread_cond_wait((int32_t *)40, mutex);
    } else {
        // 0x1f150
        pthread_cond_timedwait((int32_t *)40, mutex, (struct timespec *)abstime);
    }
    // 0x1f11c
    function_1e578(v1, "tq_pop", 1182);
    function_1da28();
    return 0;
}

// Address range: 0x1f1a8 - 0x1f1e4
int32_t function_1f1a8(int32_t a1) {
    if (a1 == 0) {
        return 0;
    }
    int32_t * v1 = (int32_t *)(a1 + 12); // 0x1f1b4
    int32_t thread = *v1; // 0x1f1b4
    if (thread == 0) {
        // 0x1f1c0
        return sem_destroy((int32_t *)(a1 + 16));
    }
    // 0x1f1cc
    pthread_cancel(thread);
    *v1 = 0;
    return sem_destroy((int32_t *)(a1 + 16));
}

// Address range: 0x1f1e4 - 0x1f218
int32_t function_1f1e4(int32_t result, int32_t a2) {
    int32_t * v1 = (int32_t *)(a2 + 4); // 0x1f1e4
    int32_t v2 = result - a2; // 0x1f1ec
    int32_t * v3 = (int32_t *)a2; // 0x1f1f0
    *v3 = v2;
    int32_t v4 = *(int32_t *)(result + 4) - *v1; // 0x1f1f8
    *v1 = v4;
    if (v4 < 0) {
        *v3 = v2 - 1;
        *v1 = v4 + 0xf4240;
    }
    return result;
}

// Address range: 0x1f218 - 0x1f25c
int32_t function_1f218(int32_t * a1, int32_t a2) {
    int32_t result = (int32_t)a1;
    int32_t * v1 = (int32_t *)(a2 + 4); // 0x1f22c
    int32_t v2 = result + a2; // 0x1f230
    int32_t * v3 = (int32_t *)a2; // 0x1f234
    *v3 = v2;
    int32_t v4 = *(int32_t *)(result + 4) + *v1; // 0x1f23c
    *v1 = v4;
    if (v4 > 0xf423f) {
        *v3 = v2 + 1;
        *v1 = v4 - 0xf4240;
    }
    return result;
}

// Address range: 0x1f25c - 0x1f290
int32_t function_1f25c(int32_t * a1, int32_t a2) {
    int32_t v1 = (int32_t)a1;
    if (v1 == a2) {
        // 0x1f278
        return 0;
    }
    // 0x1f26c
    return v1 > a2;
}

// Address range: 0x1f290 - 0x1f2c4
int32_t function_1f290(int32_t a1, int32_t a2) {
    if (a1 == a2) {
        // 0x1f2ac
        return 0;
    }
    // 0x1f2a0
    return (bool)(a1 < a2);
}

// Address range: 0x1f2c4 - 0x1f2f4
int32_t function_1f2c4(int32_t result, int32_t a2) {
    // 0x1f2c4
    *(int32_t *)result = a2;
    *(int32_t *)(result + 4) = *(int32_t *)(a2 + 4) / 1000;
    return result;
}

// Address range: 0x1f2f4 - 0x1f310
int32_t function_1f2f4(int32_t result, int32_t a2) {
    // 0x1f2f4
    *(int32_t *)result = a2;
    *(int32_t *)(result + 4) = 1000 * *(int32_t *)(a2 + 4);
    return result;
}

// Address range: 0x1f310 - 0x1f348
int32_t function_1f310(int32_t a1) {
    struct _TYPEDEF_lldiv_t v1; // 0x1f330
    // 0x1f310
    int32_t v2; // bp-32, 0x1f310
    int32_t v3; // 0x1f310
    v1 = lldiv((int64_t)(int32_t)&v2, (int64_t)v3);
    *(int32_t *)a1 = v2;
    return v1.e0;
}

// Address range: 0x1f348 - 0x1f388
int32_t function_1f348(int32_t * a1) {
    struct _TYPEDEF_lldiv_t v1; // 0x1f368
    // 0x1f348
    int32_t v2; // bp-32, 0x1f348
    int32_t v3; // 0x1f348
    v1 = lldiv((int64_t)(int32_t)&v2, (int64_t)v3);
    *a1 = v2;
    *(int32_t *)((int32_t)a1 + 4) = 1000 * v3;
    return v1.e0;
}

// Address range: 0x1f388 - 0x1f3c8
int32_t function_1f388(int32_t * a1) {
    struct _TYPEDEF_lldiv_t v1; // 0x1f3a4
    // 0x1f388
    int32_t v2; // bp-32, 0x1f388
    int32_t v3; // 0x1f388
    v1 = lldiv((int64_t)(int32_t)&v2, (int64_t)v3);
    *a1 = v2;
    *(int32_t *)((int32_t)a1 + 4) = 0xf4240 * v3;
    return v1.e0;
}

// Address range: 0x1f3c8 - 0x1f404
int32_t function_1f3c8(int32_t a1) {
    struct _TYPEDEF_lldiv_t v1; // 0x1f3e4
    // 0x1f3c8
    int32_t v2; // bp-32, 0x1f3c8
    int32_t v3; // 0x1f3c8
    v1 = lldiv((int64_t)(int32_t)&v2, (int64_t)v3);
    *(int32_t *)a1 = v2;
    *(int32_t *)(a1 + 4) = 1000 * v3;
    return v1.e0;
}

// Address range: 0x1f404 - 0x1f48c
int32_t function_1f404(int32_t result, int32_t a2) {
    int32_t * v1 = (int32_t *)(result + 4); // 0x1f418
    int32_t v2 = *v1; // 0x1f418
    int32_t v3 = a2 + result;
    int32_t * v4 = (int32_t *)result; // 0x1f420
    *v4 = v3;
    int32_t v5 = *(int32_t *)(a2 + 4); // 0x1f424
    int32_t v6 = v5 + v2;
    *v1 = v6;
    if (v6 >= 0x3b9aca00) {
        int32_t v7 = v6 - 0x3b9aca00; // 0x1f444
        *v4 = (v7 > 0x3b9ac9ff ? 2 : 1) + v3;
        *v1 = v7 > 0x3b9ac9ff ? v6 - 0x77359400 : v7;
        return result;
    }
    if (v6 >= 0) {
        return result;
    }
    uint32_t v8 = (-1 - v5 - v2) / 0x3b9aca00;
    *v4 = v3 + -1 - v8;
    *v1 = v6 + 0x3b9aca00 + 0x3b9aca00 * v8;
    return result;
}

// Address range: 0x1f48c - 0x1f57c
int32_t function_1f48c(int32_t str, int32_t str2) {
    if (str == 0 || str2 == 0) {
        // 0x1f568
        return 0;
    }
    uint32_t len = strlen((char *)str); // 0x1f4a8
    uint32_t len2 = strlen((char *)str2); // 0x1f4b4
    if (len == 0) {
        // 0x1f568
        return 0;
    }
    // 0x1f4d8
    int32_t v1; // bp-32, 0x1f48c
    int32_t str3 = (int32_t)&v1 - (len + 14 & -8); // 0x1f4e8
    int32_t v2 = (int32_t)*__ctype_tolower_loc(); // 0x1f4fc
    int32_t v3 = str3 - 1; // 0x1f508
    int32_t v4 = str - 1; // 0x1f508
    int32_t v5 = 0; // 0x1f508
    v4++;
    unsigned char v6 = *(char *)v4; // 0x1f50c
    v5++;
    v3++;
    *(char *)v3 = (char)*(int32_t *)(4 * (int32_t)v6 + v2);
    while (v5 < len) {
        // 0x1f50c
        v4++;
        v6 = *(char *)v4;
        v5++;
        v3++;
        *(char *)v3 = (char)*(int32_t *)(4 * (int32_t)v6 + v2);
    }
    int32_t str4 = str3 - (len2 + 14 & -8); // 0x1f4f0
    int32_t v7 = str4 - 1; // 0x1f52c
    int32_t v8 = str2 - 1; // 0x1f52c
    int32_t v9 = 0; // 0x1f52c
    v8++;
    v9++;
    int32_t v10 = *(int32_t *)(4 * (int32_t)*(char *)v8 + v2); // 0x1f53c
    v7++;
    *(char *)v7 = (char)v10;
    while (v9 < len2) {
        // 0x1f530
        v8++;
        v9++;
        v10 = *(int32_t *)(4 * (int32_t)*(char *)v8 + v2);
        v7++;
        *(char *)v7 = (char)v10;
    }
    char * substr_pos = strstr((char *)str3, (char *)str4); // 0x1f54c
    if (substr_pos == NULL) {
        // 0x1f568
        return 0;
    }
    // 0x1f558
    return str - str3 + (int32_t)substr_pos;
}

// Address range: 0x1f57c - 0x1f5c4
int32_t function_1f57c(int32_t str) {
    // 0x1f57c
    if (str == 0) {
        // 0x1f5b4
        *(int32_t *)str = 0;
        return str;
    }
    // 0x1f590
    int32_t accept2; // 0x1f57c
    char * found_byte_pos = strpbrk((char *)str, (char *)accept2); // 0x1f594
    if (found_byte_pos == NULL) {
        // 0x1f5b4
        *(int32_t *)str = 0;
        return str;
    }
    // 0x1f5ac
    *found_byte_pos = 0;
    *(int32_t *)str = (int32_t)found_byte_pos + 1;
    return str;
}

// Address range: 0x1f5c4 - 0x1f608
int32_t function_1f5c4(int32_t * a1) {
    // 0x1f5c4
    int32_t tp; // bp-16, 0x1f5c4
    clock_gettime(1, (struct timespec *)&tp);
    *a1 = tp;
    int64_t v1; // 0x1f5c4
    *(int32_t *)((int32_t)a1 + 4) = (int32_t)v1 / 1000;
    return 0;
}

// Address range: 0x1f608 - 0x1f638
int32_t function_1f608(int32_t a1) {
    int32_t v1 = *(int32_t *)(a1 + 4); // 0x1f610
    return ((int32_t)(0x431bde83 * (int64_t)v1 / 0x100000000) >> 18) + (1000 * a1 | (int32_t)(v1 < 0));
}

// Address range: 0x1f638 - 0x1f674
int32_t function_1f638(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = a1 - a2; // 0x1f640
    int32_t * v2 = (int32_t *)a3; // 0x1f644
    *v2 = v1;
    int32_t result = *(int32_t *)(a1 + 4) - *(int32_t *)(a2 + 4); // 0x1f650
    if (result < 0) {
        *v2 = v1 - 1;
        *(int32_t *)(a3 + 4) = result + 0x3b9aca00;
    } else {
        *(int32_t *)(a3 + 4) = result;
    }
    // .critedge
    return result;
}

// Address range: 0x1f674 - 0x1f680
int32_t function_1f674(int32_t * tp) {
    // 0x1f674
    return clock_gettime(1, (struct timespec *)tp);
}

// Address range: 0x1f680 - 0x1f740
int32_t function_1f680(int32_t * a1, int32_t a2) {
    // 0x1f680
    int32_t rqtp; // bp-16, 0x1f680
    function_1f388(&rqtp);
    int32_t v1 = *(int32_t *)((int32_t)a1 + 4); // 0x1f6a4
    int32_t v2 = rqtp; // 0x1f6ac
    int32_t v3; // 0x1f680
    int32_t v4 = v1 + v3; // 0x1f6b4
    rqtp = v2 + 0x3b9ac9ff;
    if (v4 < 0x3b9aca00) {
        if (v4 < 0) {
            // 0x1f72c
            rqtp = v2 + 0x3b9ac9fe - (-1 - v3 - v1) / 0x3b9aca00;
        }
    } else {
        // 0x1f6cc
        rqtp = (v4 > 0x773593ff ? 0x3b9aca01 : 0x3b9aca00) + v2;
    }
    int32_t result = clock_nanosleep(1, TIMER_ABSTIME, (struct timespec *)&rqtp, NULL); // 0x1f708
    while (result == 4) {
        // 0x1f6f8
        result = clock_nanosleep(1, TIMER_ABSTIME, (struct timespec *)&rqtp, NULL);
    }
    // 0x1f714
    return result;
}

// Address range: 0x1f740 - 0x1f7f8
int32_t function_1f740(int32_t * a1) {
    // 0x1f740
    int32_t rqtp; // bp-16, 0x1f740
    function_1f348(&rqtp);
    int32_t v1 = *(int32_t *)((int32_t)a1 + 4); // 0x1f75c
    int32_t v2 = rqtp; // 0x1f764
    int32_t v3; // 0x1f740
    int32_t v4 = v1 + v3; // 0x1f76c
    rqtp = v2 + 0x3b9ac9ff;
    if (v4 < 0x3b9aca00) {
        if (v4 < 0) {
            // 0x1f7e4
            rqtp = v2 + 0x3b9ac9fe - (-1 - v3 - v1) / 0x3b9aca00;
        }
    } else {
        // 0x1f784
        rqtp = (v4 > 0x773593ff ? 0x3b9aca01 : 0x3b9aca00) + v2;
    }
    int32_t result = clock_nanosleep(1, TIMER_ABSTIME, (struct timespec *)&rqtp, NULL); // 0x1f7c0
    while (result == 4) {
        // 0x1f7b0
        result = clock_nanosleep(1, TIMER_ABSTIME, (struct timespec *)&rqtp, NULL);
    }
    // 0x1f7cc
    return result;
}

// Address range: 0x1f7f8 - 0x1f824
int32_t function_1f7f8(int32_t a1) {
    // 0x1f7f8
    int32_t tp; // bp-16, 0x1f7f8
    clock_gettime(1, (struct timespec *)&tp);
    return function_1f680(&tp, a1);
}

// Address range: 0x1f824 - 0x1f858
int32_t function_1f824(int32_t a1, int32_t a2) {
    // 0x1f824
    int32_t tp; // bp-24, 0x1f824
    clock_gettime(1, (struct timespec *)&tp);
    return function_1f740(&tp);
}

// Address range: 0x1f858 - 0x1f85c
int32_t function_1f858(void) {
    // 0x1f858
    return 0;
}

// Address range: 0x1f85c - 0x1f860
int32_t function_1f85c(int32_t result) {
    // 0x1f85c
    return result;
}

// Address range: 0x1f860 - 0x1f864
int32_t function_1f860(int32_t a1) {
    // 0x1f860
    int32_t v1; // 0x1f860
    return function_1f8ec(a1 + 2, (int32_t *)v1);
}

// Address range: 0x1f864 - 0x1f868
int32_t function_1f864(void) {
    // 0x1f864
    return function_1ff10();
}

// Address range: 0x1f868 - 0x1f8ec
int32_t function_1f868(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x1f868
    __asm_udf(0);
    __asm_udf(184);
    float64_t v1; // 0x1f868
    __asm_vrhadd_u16(v1, v1);
    return 0;
}

// Address range: 0x1f8ec - 0x1f90c
int32_t function_1f8ec(int32_t result, int32_t * a2) {
    // 0x1f8ec
    __asm_vldr(0);
    __asm_vmov(*(int32_t *)(result + 4) - *(int32_t *)((int32_t)a2 + 4));
    return result;
}

// Address range: 0x1f90e - 0x1f91e
int32_t function_1f90e(void) {
    // 0x1f90e
    int32_t v1; // 0x1f90e
    bool v2; // 0x1f90e
    if (!v2) {
        v1 = function_45b3f6();
    }
    int32_t v3 = v1; // 0x1f912
    if (v2) {
        v3 = function_ff05b11a();
    }
    int32_t v4 = v3; // 0x1f916
    if (v2) {
        v4 = function_19b3fe();
    }
    int32_t result = v4; // 0x1f91a
    if (v2) {
        result = function_5b33e();
    }
    // 0x1f91e
    return result;
}

// Address range: 0x1f920 - 0x1f924
int32_t function_1f920(void) {
    // 0x1f920
    int32_t result; // 0x1f920
    return result;
}

// Address range: 0x1f924 - 0x1f928
int32_t function_1f924(void) {
    // 0x1f924
    return unknown_41ff68();
}

// Address range: 0x1f930 - 0x1faa4
int32_t function_1f930(int32_t str, int32_t a2, int32_t a3) {
    int32_t * v1 = (int32_t *)a2; // 0x1f948
    *v1 = str;
    char * substr_pos = strstr((char *)str, "//"); // 0x1f950
    int32_t v2 = substr_pos == NULL ? str : (int32_t)substr_pos + 2;
    char * str2 = (char *)v2; // 0x1f964
    char * found_char_pos = strchr(str2, 91); // 0x1f964
    char * found_char_pos2 = strchr(str2, 93); // 0x1f974
    int32_t v3 = (int32_t)found_char_pos2; // 0x1f974
    uint32_t v4 = found_char_pos == NULL | found_char_pos >= found_char_pos2 ? 0 : found_char_pos2 == NULL ? v3 : 1;
    int32_t v5 = found_char_pos >= found_char_pos2 ? v4 : v4 % 2;
    char * found_char_pos3 = strchr((char *)(v5 == 0 ? v2 : v3), 58); // 0x1f9a0
    int32_t v6 = (int32_t)found_char_pos3; // 0x1f9a0
    int32_t len = strlen(str2); // 0x1f9ac
    int32_t v7 = len; // 0x1f9b4
    int32_t v8 = v6; // 0x1f9b4
    int32_t v9 = v6; // 0x1f9b4
    if (found_char_pos3 != NULL) {
        // 0x1f9b8
        v7 = v6 - v2;
        v9 = len + -1 - v7;
        v8 = v6 + 1;
        if (v9 <= 0) {
            // 0x1fa88
            return 0;
        }
    }
    int32_t v10 = v7;
    if (v10 < 1) {
        // 0x1fa88
        return 0;
    }
    int32_t v11 = v5 == 0 ? v10 : v10 - 2;
    int32_t str3; // bp-288, 0x1f930
    snprintf((char *)&str3, 254, "%.*s", v11, (char *)(v2 + (int32_t)(v5 != 0)));
    char * str4; // bp-296, 0x1f930
    if (v9 == 0) {
        // 0x1fa04
        str4 = (char *)0x3038;
    } else {
        // 0x1fa48
        snprintf((char *)&str4, 6, "%.*s", v9, (char *)v8);
        char * found_byte_pos = strpbrk((char *)&str4, "/#"); // 0x1fa74
        if (found_byte_pos != NULL) {
            *found_byte_pos = 0;
        }
    }
    // 0x1fa20
    *(int32_t *)a3 = (int32_t)__strdup((char *)&str4);
    *v1 = (int32_t)__strdup((char *)&str3);
    return 1;
}

// Address range: 0x1faa4 - 0x1fb78
int32_t function_1faa4(int32_t result, int32_t a2) {
    int32_t * v1 = (int32_t *)(a2 + 184); // 0x1fac8
    *v1 = 0;
    char * str = (char *)result; // 0x1faf8
    int32_t strncmp_rc = strncmp(str, "http:", 5); // 0x1faf8
    int32_t v2 = 0; // 0x1fb00
    int32_t v3 = (int32_t)&g17 + 1056; // 0x1fb00
    int32_t len = 5; // 0x1fb00
    if (strncmp_rc != 0) {
        v2++;
        int32_t v4 = 8 * v2;
        int32_t v5 = *(int32_t *)(v4 + (int32_t)&g18); // 0x1fad4
        while (v5 != 0) {
            char * str2 = (char *)v5;
            len = strlen(str2);
            if (strncmp(str, str2, len) == 0) {
                // 0x1faec
                v3 = v4 + (int32_t)&g17 + 1056;
                goto lab_0x1fb04;
            }
            v2++;
            v4 = 8 * v2;
            v5 = *(int32_t *)(v4 + (int32_t)&g18);
        }
        // 0x1fb70
        return result;
    }
    goto lab_0x1fb04;
  lab_0x1fb04:;
    char * found_char_pos = strchr(str, 124); // 0x1fb0c
    int32_t result2 = result; // 0x1fb14
    if (found_char_pos != NULL) {
        int32_t v6 = (int32_t)found_char_pos; // 0x1fb0c
        *found_char_pos = 0;
        int32_t str3 = function_1e74c(1 - result - len + v6, "util.c", "get_proxy", 748); // 0x1fb40
        *v1 = str3;
        strcpy((char *)str3, (char *)(len + result));
        function_1f930(*v1, a2 + 604, a2 + 608);
        *(int32_t *)(a2 + 180) = *(int32_t *)v3;
        result2 = v6 + 1;
    }
    // 0x1fb70
    return result2;
}

// Address range: 0x1fb7c - 0x1fb9c
int32_t function_1fb7c(int32_t a1) {
    // 0x1fb7c
    if (*(char *)*(int32_t *)(a1 + 592) == 0) {
        // 0x1fb94
        return function_1e1b8(*(int32_t *)(a1 + 588), 0);
    }
    // 0x1fb8c
    return 1;
}

// Address range: 0x1fb9c - 0x1fc08
int32_t function_1fb9c(int32_t result, uint32_t a2, uint32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x1fb9c
    if (a3 == a2) {
        // 0x1fbe8
        return result;
    }
    int32_t result2 = function_1e864(result, a3, a4, a5, a6); // 0x1fbd8
    *(int32_t *)result = result2;
    if (a3 < a2) {
        // 0x1fbe8
        return result2;
    }
    // 0x1fbf0
    return (int32_t)memset((int32_t *)(result2 + a2), 0, a3 - a2);
}

// Address range: 0x1fc08 - 0x1fcc8
int32_t function_1fc08(int32_t a1, int32_t * a2) {
    int32_t v1 = 0; // bp-40, 0x1fc24
    int32_t v2; // bp-16, 0x1fc08
    int32_t v3 = (int32_t)&v2 - 24;
    uint32_t v4 = 0;
    int32_t v5 = 0;
    if ((1 << v4 & a1) != 0) {
        *(char *)(v3 + v5) = (char)v4;
    }
    uint32_t v6 = v5 + (int32_t)((1 << v4 & a1) != 0);
    int32_t v7 = v4 + 1; // 0x1fc4c
    bool v8 = false; // 0x1fc54
    bool v9 = true; // 0x1fc54
    if (v7 == 31 || v7 < 31) {
        v8 = v6 == 22;
        v9 = v6 >= 22;
    }
    while (v8 || !v9) {
        // 0x1fc38
        v4 = v7;
        v5 = v6;
        if ((1 << v4 & a1) != 0) {
            *(char *)(v3 + v5) = (char)v4;
        }
        v6 = v5 + (int32_t)((1 << v4 & a1) != 0);
        v7 = v4 + 1;
        v8 = false;
        v9 = true;
        if (v7 == 31 || v7 < 31) {
            v8 = v6 == 22;
            v9 = v6 >= 22;
        }
    }
    uint32_t v10 = (int32_t)a2;
    int32_t result = 0; // 0x1fc6c
    if (a2 >= (int32_t *)1 && v6 != 0) {
        int32_t v11 = &v1; // 0x1fc78
        int32_t v12 = 0; // 0x1fc8c
        int32_t v13 = v11 + 1; // 0x1fc98
        v12 |= 1 << (int32_t)*(char *)v11;
        result = v12;
        while (v6 + v11 != v13 && v11 + v10 != v13) {
            int32_t v14 = v13;
            v13 = v14 + 1;
            v12 |= 1 << (int32_t)*(char *)v14;
            result = v12;
        }
    }
    // 0x1fca8
    if (v6 <= v10 == (v6 != v10)) {
        *a2 = v6;
    }
    return result;
}

// Address range: 0x1fcc8 - 0x1ff0c
int32_t function_1fcc8(int32_t a1, int32_t a2) {
    char * v1 = (char *)0x30303030; // bp-2076, 0x1fce4
    char * str = (char *)a2; // 0x1fcf0
    int32_t len = strlen(str); // 0x1fcf0
    int32_t result3 = 0; // bp-2084, 0x1fd00
    int32_t v2 = 3; // bp-2080, 0x1fd00
    int32_t v3; // 0x1fcc8
    if (len == 0) {
        // 0x1fcc8
        v3 = (int32_t)&v1;
    } else {
        int32_t v4 = a2 - 1; // 0x1fd0c
        int32_t v5 = (int32_t)&v1;
        int32_t v6 = v5 + 7 - len; // 0x1fd18
        int32_t v7 = v4; // 0x1fd18
        v7++;
        v6++;
        *(char *)v6 = *(char *)v7;
        v3 = v5;
        while (v7 != len + v4) {
            // 0x1fd1c
            v7++;
            v6++;
            *(char *)v6 = *(char *)v7;
            v3 = v5;
        }
    }
    // 0x1fd2c
    function_1ea68((int32_t)&result3, v3, 4);
    char v8 = *(char *)&g70; // 0x1fd60
    int32_t str2; // bp-2064, 0x1fcc8
    if ((v8 | *(char *)&g179) == 0 != g28 < (char *)6) {
        // 0x1fd6c
        snprintf((char *)&str2, 2048, "mask returned by pool is %s, swaped = 0x%x", str, result3);
        function_1ccec(6, &str2, 0);
    }
    int32_t v9 = result3 & 0xe0ff1f; // 0x1fdac
    int32_t v10 = 0x1000000 * v9 | result3 / 256 & 0xe000 | 256 * v9 & 0xff0000; // 0x1fdc4
    result3 = v10;
    int32_t v11 = function_1fc08(v10, &v2); // 0x1fdd0
    result3 = v11;
    char v12 = *(char *)&g70; // 0x1fdec
    int32_t result; // 0x1fcc8
    if ((v12 | *(char *)&g179) != 0 || g28 > (char *)4) {
        // 0x1fdf8
        snprintf((char *)&str2, 2048, "real mask = 0x%x, bit_num = %d", v11, v2);
        function_1ccec(5, &str2, 0);
        result = result3;
        if (result3 == 0) {
            // 0x1fe34
            if ((*(char *)&g70 | *(char *)&g179) == 0) {
                // 0x1fed8
                goto lab_0x1fed8;
            } else {
                goto lab_0x1fe54;
            }
        } else {
            goto lab_0x1fe9c;
        }
    } else {
        // 0x1fed0
        result = v11;
        if (v11 == 0) {
            goto lab_0x1fed8;
        } else {
            goto lab_0x1fe9c;
        }
    }
  lab_0x1fe9c:
    // 0x1fe9c
    *(char *)(a1 + 644) = 1;
    *(int32_t *)(a1 + 652) = result;
    *(int32_t *)(a1 + 648) = 1 << v2;
    return result;
  lab_0x1fed8:
    // 0x1fed8
    if (g28 <= (char *)4) {
        int32_t result2 = 0; // 0x1fe7c
        *(char *)(a1 + 644) = 0;
        *(int32_t *)(a1 + 648) = 1;
        *(int32_t *)(a1 + 652) = result2;
        return result2;
    }
    // 0x1fed8
    goto lab_0x1fe54;
  lab_0x1fe54:
    // 0x1fe54
    snprintf((char *)&str2, 2048, "Pool %d rolling mask do not match!", 0);
    function_1ccec(5, &str2, 0);
    // 0x1fe7c
    *(char *)(a1 + 644) = 0;
    *(int32_t *)(a1 + 648) = 1;
    *(int32_t *)(a1 + 652) = result3;
    return result3;
}

// Address range: 0x1ff10 - 0x1ff12
int32_t function_1ff10(void) {
    // 0x1ff10
    int32_t result; // 0x1ff10
    return result;
}

// Address range: 0x1ff14 - 0x20258
int32_t function_1ff14(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10) {
    // 0x1ff14
    int32_t v1; // bp-2304, 0x1ff14
    int32_t v2 = function_46448((int32_t *)a2, 0, &v1); // 0x1ff2c
    int32_t str; // bp-2052, 0x1ff14
    if (v2 == 0) {
        // 0x1ffcc
        int32_t v3; // bp-2212, 0x1ff14
        if (*(char *)&g179 != 0) {
            // 0x1fff4
            snprintf((char *)&str, 2048, "JSON decode failed(%d): %s", v1, &v3);
            function_1ccec(6, &str, 0);
            return 0;
        }
        // 0x1ffe0
        if (*(char *)&g70 == 0 == g28 < (char *)6) {
            // 0x1ffbc
            return 0;
        }
        // 0x1fff4
        snprintf((char *)&str, 2048, "JSON decode failed(%d): %s", v1, &v3);
        function_1ccec(6, &str, 0);
        return 0;
    }
    int32_t v4 = &v1; // 0x1ff20
    int32_t v5 = function_472ec(v2, "result"); // 0x1ff40
    int32_t v6 = function_472ec(v2, "error"); // 0x1ff54
    int32_t v7 = v6; // 0x1ff5c
    int32_t v8 = (int32_t)"error"; // 0x1ff5c
    int32_t v9 = v4; // 0x1ff5c
    int32_t result = 0; // 0x1ff5c
    if (v5 == 0) {
        goto lab_0x1ff84_2;
    } else {
        // 0x1ff60
        v7 = v6;
        v8 = (int32_t)"error";
        v9 = v4;
        result = 0;
        if (*(int32_t *)v5 == 7) {
            goto lab_0x1ff84_2;
        } else {
            if (v6 == 0) {
                goto lab_0x20050;
            } else {
                // 0x1ff74
                v7 = v6;
                v8 = (int32_t)"error";
                v9 = v4;
                result = 0;
                if (*(int32_t *)v6 == 7) {
                    goto lab_0x20050;
                } else {
                    goto lab_0x1ff84_2;
                }
            }
        }
    }
  lab_0x1ff84_2:;
    int32_t v10 = v2 + 4; // 0x1ff84
    int32_t * v11 = (int32_t *)v10; // 0x1ff84
    if (*v11 == -1) {
        // 0x1ffbc
        return result;
    }
    // 0x1ff90
    __asm_dmb(v7, v8, v9, v10);
    int32_t v12 = *v11;
    int32_t v13 = v12 - 1; // 0x1ff9c
    while (__asm_strex(v13, v12) != 0) {
        // 0x1ff98
        v12 = *v11;
        v13 = v12 - 1;
    }
    // 0x1ffac
    if (v13 == 0) {
        // 0x1ffb4
        function_47c24(v2);
    }
    // 0x1ffbc
    return result;
  lab_0x20088:;
    // 0x20088
    int32_t v14; // 0x1ff14
    int32_t v15; // 0x1ff14
    int32_t v16; // 0x1ff14
    char * str2; // 0x20144
    if (strcasecmp(str2, "version-rolling.mask") == 0) {
        // 0x2009c
        if (strlen(str2) == 20) {
            // 0x201cc
            function_1fcc8(a1, function_47820(v14));
            v15 = v16;
            goto lab_0x20108;
        } else {
            goto lab_0x200ac;
        }
    } else {
        goto lab_0x200ac;
    }
  lab_0x200ac:;
    char v17 = *(char *)&g70; // 0x200c0
    v15 = v16;
    if ((v17 | *(char *)&g179) == 0 != g28 < (char *)3) {
        // 0x200e0
        snprintf((char *)&str, 2048, "JSON-RPC unexpected mining.configure value: %s", str2);
        function_1ccec(3, &str, 0);
        v15 = 0;
    }
    goto lab_0x20108;
  lab_0x20108:;
    // 0x20108
    int32_t v18; // 0x1ff14
    int32_t v19 = function_475ec(v18); // 0x2010c
    int32_t v20 = function_475d4(function_475a0(v5, v19)); // 0x2011c
    v7 = 0;
    v8 = v19;
    v9 = v15;
    int32_t v21; // 0x1ff14
    result = v21;
    if (v20 == 0) {
        goto lab_0x1ff84_2;
    }
    int32_t v22 = function_475e0(function_475ec(v20)); // 0x20130
    v7 = 0;
    v8 = v19;
    v9 = v15;
    result = v21;
    int32_t v23 = v22; // 0x20138
    v18 = v20;
    int32_t v24 = v15; // 0x20138
    if (v22 == 0) {
        goto lab_0x1ff84_2;
    }
    goto lab_0x2013c;
  lab_0x20050:;
    int32_t v28 = function_475d4(function_47554(v5)); // 0x20058
    v7 = 0;
    v8 = (int32_t)"error";
    v9 = v4;
    result = 0;
    if (v28 != 0) {
        int32_t v29 = function_475e0(function_475ec(v28)); // 0x20130
        v7 = 0;
        v8 = (int32_t)"error";
        v9 = v4;
        result = 0;
        if (v29 != 0) {
            int32_t v27 = &str;
            v23 = v29;
            v21 = 0;
            v18 = v28;
            v24 = v4;
            unsigned char v25; // 0x20164
            char v26; // 0x1ff14
            while (true) {
              lab_0x2013c:
                // 0x2013c
                v16 = v24;
                v14 = v23;
                str2 = (char *)v18;
                if (strcasecmp(str2, "version-rolling") == 0) {
                    // 0x20150
                    if (strlen(str2) == 15) {
                        // 0x20160
                        v25 = *(char *)&g179;
                        v26 = *(char *)&g70;
                        if (*(int32_t *)v14 != 5) {
                            // break -> 0x201e8
                            break;
                        }
                        // 0x20170
                        v15 = v25;
                        if ((v26 || v25) == 0 != g28 < (char *)5) {
                            // 0x201a0
                            snprintf((char *)&str, 2048, "POOL %d support ab mode!", v27);
                            function_1ccec(5, &str, 0);
                            v15 = 0;
                        }
                        goto lab_0x20108;
                    } else {
                        goto lab_0x20088;
                    }
                } else {
                    goto lab_0x20088;
                }
            }
            int32_t v30 = 15; // 0x201ec
            int32_t v31 = (int32_t)"version-rolling"; // 0x201ec
            if ((v26 || v25) == 0 != g28 < (char *)5) {
                // 0x20218
                snprintf((char *)&str, 2048, "Pool %d don't support ab!", v27);
                v30 = function_1ccec(5, &str, 0);
                v31 = v27;
            }
            // 0x20240
            *(char *)(a1 + 644) = 0;
            *(int32_t *)(a1 + 648) = 1;
            v7 = v30;
            v8 = v31;
            v9 = 0;
            result = 1;
        }
    }
    goto lab_0x1ff84_2;
}

// Address range: 0x20258 - 0x203b8
int32_t function_20258(int32_t a1, int32_t a2, int32_t a3) {
    char v1 = *(char *)&g70; // 0x20284
    int32_t str; // bp-2064, 0x20258
    if ((v1 | *(char *)&g179) == 0 != g28 < (char *)6) {
        // 0x20290
        snprintf((char *)&str, 2048, "Closing socket for stratum pool %d", (int32_t)&str);
        function_1ccec(6, &str, 0);
    }
    // 0x202b8
    if (pthread_mutex_lock((int32_t *)(a1 + 704)) == 0) {
        // 0x202cc
        return function_1e150(a1);
    }
    int32_t v2 = *__errno_location(); // 0x20380
    snprintf((char *)&str, 2048, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", v2, "util.c", "suspend_stratum", 3407);
    function_1ccec(3, &str, 1);
    function_3aadc(1);
    // UNREACHABLE
}

// Address range: 0x203bc - 0x2076c
int32_t function_203bc(int32_t a1, int32_t * a2, int32_t a3) {
    // 0x203bc
    char * str; // bp-2072, 0x203bc
    if (!((g194 == 0 | *(char *)&g71 == 0))) {
        char v1 = *(char *)&g70; // 0x2049c
        if ((v1 | *(char *)&g179) == 0 != g28 < (char *)7) {
            // 0x204bc
            snprintf((char *)&str, 2048, "SEND: %s", a2);
            function_1ccec(7, (int32_t *)&str, 0);
        }
    }
    int32_t * mutex = (int32_t *)(a1 + 704); // 0x20404
    if (pthread_mutex_lock(mutex) != 0) {
        int32_t v2 = *__errno_location(); // 0x206ec
        snprintf((char *)&str, 2048, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", v2, "util.c", "stratum_send", 1711);
        function_1ccec(3, (int32_t *)&str, 1);
        function_3aadc(1);
        // UNREACHABLE
    }
    // 0x20410
    if (*(char *)(a1 + 641) == 0) {
        // 0x2041c
        if (pthread_mutex_unlock(mutex) == 0) {
            // 0x204e8
            function_1da28();
            goto lab_0x204f8;
        } else {
            goto lab_0x20430;
        }
    } else {
        int32_t v3 = function_1da30(a1, (int32_t)a2, a3); // 0x2058c
        if (pthread_mutex_unlock(mutex) == 0) {
            // 0x205a4
            function_1da28();
            switch (v3) {
                case 2: {
                    // 0x20650
                    if (*(char *)&g71 == 0) {
                        // 0x20638
                        function_20258(a1, (int32_t)&g306, (int32_t)&g306);
                        // 0x20574
                        return 0;
                    }
                    char v4 = *(char *)&g70; // 0x20680
                    if ((v4 | *(char *)&g179) == 0 && g28 <= (char *)6) {
                        // 0x20638
                        function_20258(a1, (int32_t)&g306, (int32_t)&g306);
                        // 0x20574
                        return 0;
                    }
                    // 0x2068c
                    str = (char *)0x6c696146;
                    function_1ccec(7, (int32_t *)&str, 0);
                    function_20258(a1, (int32_t)&g306, (int32_t)&g306);
                    // 0x20574
                    return 0;
                }
                case 3: {
                    goto lab_0x204f8;
                }
                case 1: {
                    // 0x205d4
                    if (*(char *)&g71 != 0) {
                        char v5 = *(char *)&g70; // 0x20604
                        if ((v5 | *(char *)&g179) != 0 || g28 > (char *)6) {
                            // 0x20610
                            snprintf((char *)&str, 2048, "Write select failed on pool %d sock", (int32_t)&str);
                            function_1ccec(7, (int32_t *)&str, 0);
                        }
                    }
                    // 0x20638
                    function_20258(a1, (int32_t)&g306, (int32_t)&g306);
                    // 0x20574
                    return 0;
                }
                default: {
                    return 0;
                }
            }
        } else {
            goto lab_0x20430;
        }
    }
  lab_0x20430:;
    int32_t v6 = *__errno_location(); // 0x20448
    snprintf((char *)&str, 2048, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", v6, "util.c", "stratum_send", 1717);
    function_1ccec(3, (int32_t *)&str, 1);
    function_3aadc(1);
    // UNREACHABLE
  lab_0x204f8:
    // 0x204f8
    if (*(char *)&g71 == 0) {
        // 0x20574
        return 0;
    }
    // 0x2050c
    if (*(char *)&g179 != 0) {
        // 0x20534
        str = (char *)0x61727453;
        function_1ccec(7, (int32_t *)&str, 0);
        // 0x20574
        return 0;
    }
    // 0x20520
    if (*(char *)&g70 == 0 && g28 <= (char *)6) {
        // 0x20574
        return 0;
    }
    // 0x20534
    str = (char *)0x61727453;
    function_1ccec(7, (int32_t *)&str, 0);
    // 0x20574
    return 0;
}

// Address range: 0x20770 - 0x20cf0
int32_t function_20770(int32_t a1, int32_t a2, int32_t a3) {
    // 0x20770
    float64_t v1; // 0x20770
    float64_t v2 = __asm_vpush_9(v1); // 0x20778
    int32_t * v3 = (int32_t *)(a1 + 592); // 0x20788
    char * str = (char *)*v3;
    char * found_char_pos = strchr(str, 10); // 0x20790
    char * str2 = str; // 0x20798
    float64_t v4 = v2; // 0x20798
    float64_t v5; // 0x20770
    int32_t tp; // bp-8232, 0x20770
    if (found_char_pos == NULL) {
        // 0x208f4
        clock_gettime(1, (struct timespec *)&tp);
        int32_t * sock = (int32_t *)(a1 + 588); // 0x20914
        int32_t v6 = tp; // 0x20918
        if (function_1e1b8(*sock, 60) == 0) {
            // 0x20c5c
            v5 = v2;
            if (*(char *)&g71 != 0) {
                char v7 = *(char *)&g70; // 0x20c8c
                v5 = v2;
                if ((v7 | *(char *)&g179) == 0 != g28 < (char *)7) {
                    // 0x20cac
                    tp = 0x656d6954;
                    function_1ccec(7, &tp, 0);
                    v5 = v2;
                }
            }
            goto lab_0x20b28;
        } else {
            // 0x20934
            v4 = __asm_vldr(0);
            memset(&tp, 0, 0x2000);
            char * tp2; // bp-10280, 0x20770
            if (recv(*sock, &tp, 0x1ffc, 0) != 0) {
                // 0x209bc
                clock_gettime(1, (struct timespec *)&tp2);
                __asm_vmov((int32_t)tp2 - v6);
                return &tp;
            }
            // 0x20bcc
            if (*(char *)&g71 != 0) {
                char v8 = *(char *)&g70; // 0x20bfc
                if ((v8 | *(char *)&g179) == 0 != g28 < (char *)7) {
                    // 0x20c1c
                    tp2 = (char *)0x6b636f53;
                    function_1ccec(7, (int32_t *)&tp2, 0);
                }
            }
            // 0x20bbc
            function_20258(a1, (int32_t)&g306, (int32_t)&g306);
            str2 = (char *)*v3;
            goto lab_0x2079c;
        }
    } else {
        goto lab_0x2079c;
    }
  lab_0x2079c:;
    int32_t len = strlen(str2); // 0x207a0
    char * next_token = strtok(str2, "\n"); // 0x207b4
    if (next_token == NULL) {
        // 0x20a94
        v5 = v4;
        if (*(char *)&g71 != 0) {
            char v9 = *(char *)&g70; // 0x20ac4
            v5 = v4;
            if ((v9 | *(char *)&g179) == 0 != g28 < (char *)7) {
                // 0x20ae4
                tp = 0x6c696146;
                function_1ccec(7, &tp, 0);
                v5 = v4;
            }
        }
        goto lab_0x20b28;
      lab_0x20b28:
        // 0x20b28
        function_1e658(a1);
        // 0x208c8
        __asm_vpop(v5);
        return 0;
    }
    char * str3 = __strdup(next_token); // 0x207c0
    int32_t len2 = strlen(str3); // 0x207c8
    int32_t v10 = len2 + 1; // 0x207cc
    int32_t v11 = *v3;
    if (v10 < len) {
        // 0x208dc
        memmove((int32_t *)v11, (int32_t *)(v11 + v10), len + 1 - len2);
    } else {
        // 0x207dc
        *(char *)v11 = 0;
    }
    int32_t result = (int32_t)str3; // 0x207c0
    int32_t * v12 = (int32_t *)(a1 + 520); // 0x207e8
    int32_t v13 = *v12; // 0x207e8
    int32_t * v14 = (int32_t *)(a1 + 524); // 0x207f0
    int32_t * v15 = (int32_t *)(a1 + 528); // 0x207f4
    uint32_t v16 = *v15; // 0x207f4
    int32_t * v17 = (int32_t *)(a1 + 532); // 0x207fc
    int32_t * v18 = (int32_t *)(a1 + 536); // 0x20804
    uint32_t v19 = *v18; // 0x20804
    uint32_t v20 = v16 + len2; // 0x20808
    *v12 = v13 + 1;
    *v15 = v20;
    *v17 = *v17 + (int32_t)(v20 < v16);
    uint32_t v21 = v19 + len2; // 0x20824
    int32_t * v22 = (int32_t *)(a1 + 540); // 0x2082c
    *v14 = *v14 + (int32_t)(v13 == -1);
    *v18 = v21;
    *v22 = *v22 + (int32_t)(v21 < v19);
    if (g194 == 0 | *(char *)&g71 == 0) {
        // 0x208c8
        __asm_vpop(v4);
        return result;
    }
    char v23 = *(char *)&g70; // 0x20878
    if ((v23 | *(char *)&g179) == 0 != g28 < (char *)7) {
        // 0x20898
        snprintf((char *)&tp, 2048, "RECVD: %s", str3);
        function_1ccec(7, &tp, 0);
    }
    // 0x208c8
    __asm_vpop(v4);
    return result;
}

// Address range: 0x20cfc - 0x21ad0
int32_t function_20cfc(int32_t a1) {
    // 0x20cfc
    function_1e658(a1);
    int32_t * v1 = (int32_t *)(a1 + 636); // 0x20d10
    int32_t v2 = *v1; // 0x20d10
    int32_t v3 = g183;
    g183 = v3 + 1;
    int32_t str; // bp-8232, 0x20cfc
    if (v2 == 0) {
        // 0x21238
        sprintf((char *)&str, "{\"id\": %d, \"method\": \"mining.subscribe\", \"params\": [\"%s/%s\"]}", v3, (char *)&g145, (char *)&g143);
    } else {
        // 0x20d1c
        sprintf((char *)&str, "{\"id\": %d, \"method\": \"mining.subscribe\", \"params\": [\"%s/%s\", \"%s\"]}", v3, (char *)&g145, (char *)&g143, (char *)v2);
    }
    int32_t len = strlen((char *)&str); // 0x20d7c
    int32_t v4 = &str; // 0x20d80
    int32_t v5 = function_1da30(a1, v4, len); // 0x20d8c
    int32_t v6 = 0; // 0x20d94
    int32_t v7 = len; // 0x20d94
    int32_t v8 = v5; // 0x20d94
    int32_t v9; // 0x20cfc
    char * v10; // 0x20cfc
    char v11; // 0x20cfc
    int32_t v12; // 0x20cfc
    int32_t v13; // 0x20cfc
    int32_t v14; // 0x20cfc
    int32_t v15; // 0x20cfc
    int32_t v16; // 0x20cfc
    int32_t v17; // 0x20cfc
    int32_t v18; // 0x20cfc
    int32_t v19; // 0x20cfc
    int32_t v20; // 0x20cfc
    int32_t v21; // 0x20cfc
    int32_t v22; // 0x20cfc
    int32_t v23; // 0x20cfc
    int32_t v24; // 0x20cfc
    int32_t v25; // 0x20cfc
    int32_t v26; // 0x20cfc
    int32_t v27; // 0x20cfc
    int32_t v28; // 0x20cfc
    int32_t str2; // bp-10280, 0x20cfc
    char * v29; // 0x20cfc
    char * v30; // 0x20cfc
    char * v31; // 0x20cfc
    int32_t * mutex; // 0x20cfc
    int32_t * rwlock; // 0x20cfc
    int32_t * v32; // 0x20cfc
    int32_t v33; // 0x21294
    int32_t v34; // 0x212b4
    int32_t v35; // 0x212c8
    int32_t v36; // 0x20d74
    int32_t v37; // 0x20cfc
    if (v5 == 0) {
        // 0x211a0
        int32_t v38; // bp-10532, 0x20cfc
        v36 = &v38;
        v37 = &str2;
        mutex = (int32_t *)(a1 + 212);
        rwlock = (int32_t *)(a1 + 236);
        v32 = (int32_t *)(a1 + 612);
        v9 = len;
        v24 = 0;
        v29 = NULL;
        int32_t v39; // 0x20cfc
        while (true) {
          lab_0x211a0:
            // 0x211a0
            v25 = v24;
            v39 = v9;
            if (function_1e1b8(*(int32_t *)(a1 + 588), 60) == 0) {
                // break -> 0x211b4
                break;
            }
            int32_t v40 = function_20770(a1, 60, v39); // 0x21280
            v13 = 0;
            v17 = 60;
            v21 = v39;
            v27 = v25;
            if (v40 == 0) {
                goto lab_0x21150_2;
            }
            // 0x2128c
            v30 = v29;
            int32_t * v41 = (int32_t *)v40; // 0x21294
            v33 = function_46448(v41, 0, &v38);
            free(v41);
            if (v33 == 0) {
                char * v42 = (char *)((int32_t)v30 ^ 1); // 0x216ac
                char v43 = *(char *)&g70; // 0x216c4
                v31 = v42;
                v14 = &g306;
                v18 = 0;
                v22 = v36;
                if ((v43 | *(char *)&g179) == 0 != g28 < (char *)6) {
                    // 0x216e4
                    int32_t v44; // bp-10440, 0x20cfc
                    snprintf((char *)&str2, 2048, "JSON decode failed(%d): %s", v38, &v44);
                    int32_t v45 = function_1ccec(6, &str2, 0); // 0x21710
                    v31 = v42;
                    v14 = v45;
                    v18 = v37;
                    v22 = 0;
                }
                goto lab_0x21350;
            } else {
                // 0x212ac
                v34 = function_472ec(v33, "result");
                v35 = function_472ec(v33, "error");
                if (v34 == 0) {
                    goto lab_0x214f8;
                } else {
                    // 0x212d4
                    if (*(int32_t *)v34 == 7) {
                        goto lab_0x214f8;
                    } else {
                        if (v35 == 0) {
                            goto lab_0x21718;
                        } else {
                            // 0x212e8
                            if (*(int32_t *)v35 == 7) {
                                goto lab_0x21718;
                            } else {
                                goto lab_0x212f4;
                            }
                        }
                    }
                }
            }
        }
        // 0x211b4
        v12 = 0;
        v16 = 60;
        v20 = v39;
        v26 = v25;
        if (*(char *)&g71 == 0) {
            goto lab_0x20dac;
        } else {
            char v46 = *(char *)&g70; // 0x211e4
            if ((v46 | *(char *)&g179) == 0) {
                // 0x214c0
                v10 = g28;
                v11 = v46;
                v15 = 0;
                v19 = 60;
                v23 = (int32_t)g28;
                v28 = v25;
                if (g28 > (char *)6) {
                    goto lab_0x211f0;
                } else {
                    goto lab_0x214d4;
                }
            } else {
                goto lab_0x211f0;
            }
        }
    } else {
        goto lab_0x20d98;
    }
  lab_0x21150_2:
    // 0x21150
    v12 = v13;
    v16 = v17;
    v20 = v21;
    v26 = v27;
    int32_t v47; // 0x20cfc
    if (*(char *)&g71 == 0) {
        goto lab_0x20dac;
    } else {
        // 0x2115c
        v47 = v27;
        if (*(char *)&g179 == 0) {
            // 0x2115c
            v10 = g28;
            v11 = *(char *)&g70;
            v15 = v13;
            v19 = v17;
            v23 = v21;
            v28 = v27;
            goto lab_0x214d4;
        } else {
            goto lab_0x21170;
        }
    }
  lab_0x20d98:;
    int32_t v48 = v6;
    v12 = v8;
    v16 = v4;
    v20 = v7;
    v26 = v48;
    if (*(char *)&g71 == 0) {
        goto lab_0x20dac;
    } else {
        char v49 = *(char *)&g70; // 0x210f8
        if ((v49 | *(char *)&g179) == 0) {
            // 0x21104
            v10 = g28;
            v11 = v49;
            v15 = v8;
            v19 = v4;
            v23 = (int32_t)g28;
            v28 = v48;
            if (g28 < (char *)7) {
                goto lab_0x214d4;
            } else {
                goto lab_0x21118;
            }
        } else {
            goto lab_0x21118;
        }
    }
  lab_0x21350:;
    int32_t v50 = v22;
    int32_t v51 = v18;
    v13 = v14;
    v17 = v51;
    v21 = v50;
    v27 = v33;
    if (v31 == NULL) {
        goto lab_0x21150_2;
    }
    // 0x2135c
    if (pthread_mutex_lock(mutex) != 0) {
        int32_t v52 = *__errno_location(); // 0x21664
        snprintf((char *)&str2, 2048, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", v52, "util.c", "initiate_stratum", 3637);
        function_1ccec(3, &str2, 1);
        function_3aadc(1);
        // UNREACHABLE
    }
    // 0x21370
    if (pthread_rwlock_wrlock(rwlock) != 0) {
        int32_t v53 = *__errno_location(); // 0x21614
        snprintf((char *)&str2, 2048, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", v53, "util.c", "initiate_stratum", 3637);
        function_1ccec(3, &str2, 1);
        function_3aadc(1);
        // UNREACHABLE
    }
    // 0x21384
    free((int32_t *)*v1);
    free((int32_t *)*v32);
    *v32 = 0;
    *v1 = 0;
    if (pthread_rwlock_unlock(rwlock) != 0) {
        int32_t v54 = *__errno_location(); // 0x215c4
        snprintf((char *)&str2, 2048, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", v54, "util.c", "initiate_stratum", 3641);
        function_1ccec(3, &str2, 1);
        function_3aadc(1);
        // UNREACHABLE
    }
    // 0x213b0
    if (pthread_mutex_unlock(mutex) != 0) {
        int32_t v55 = *__errno_location(); // 0x21574
        snprintf((char *)&str2, 2048, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", v55, "util.c", "initiate_stratum", 3641);
        function_1ccec(3, &str2, 1);
        function_3aadc(1);
        // UNREACHABLE
    }
    int32_t v56 = function_1da28(); // 0x213d4
    int32_t v57 = v56; // 0x213e0
    int32_t v58 = v51; // 0x213e0
    int32_t v59 = v50; // 0x213e0
    if (*(char *)&g71 != 0) {
        char v60 = *(char *)&g70; // 0x213f8
        v57 = v56;
        v58 = v51;
        v59 = v50;
        if ((v60 | *(char *)&g179) == 0 != g28 < (char *)7) {
            // 0x21418
            str2 = 0x6c696146;
            v57 = function_1ccec(7, &str2, 0);
            v58 = v37;
            v59 = 0;
        }
    }
    if (v33 != 0) {
        int32_t v61 = v33 + 4; // 0x21454
        if (*(int32_t *)v61 != -1) {
            // 0x21460
            __asm_dmb(v57, v58, v59, v61);
            int32_t * v62; // 0x21454
            int32_t v63 = *v62;
            int32_t v64 = v63 - 1; // 0x2146c
            while (__asm_strex(v64, v63) != 0) {
                // 0x21468
                v63 = *v62;
                v64 = v63 - 1;
            }
            if (v64 == 0) {
                // 0x21484
                function_47c24(v33);
            }
        }
    }
    // 0x2148c
    function_1e658(a1);
    int32_t v65 = g183; // 0x21494
    g183 = v65 + 1;
    sprintf((char *)&str, "{\"id\": %d, \"method\": \"mining.subscribe\", \"params\": []}", v65);
    int32_t len2 = strlen((char *)&str); // 0x20d7c
    int32_t v66 = function_1da30(a1, v4, len2); // 0x20d8c
    v6 = v33;
    v7 = len2;
    v8 = v66;
    v9 = len2;
    v24 = v33;
    v29 = v31;
    if (v66 != 0) {
        goto lab_0x20d98;
    }
    goto lab_0x211a0;
  lab_0x214f8:;
    int32_t v67; // 0x20cfc
    int32_t v68; // 0x20cfc
    int32_t v69; // 0x20cfc
    if (v35 == 0) {
        int32_t * mem = malloc(17); // 0x21504
        int32_t v70 = (int32_t)mem; // 0x21504
        v67 = (int32_t)"error";
        v68 = v36;
        v69 = v70;
        if (mem != NULL) {
            // 0x21510
            *mem = 0x6b6e7528;
            *(int32_t *)(v70 + 4) = 0x6e776f6e;
            *(int32_t *)(v70 + 8) = 0x61657220;
            *(int32_t *)(v70 + 12) = 0x296e6f73;
            *(char *)(v70 + 16) = 0;
            v67 = 0x6e776f6e;
            v68 = 0x61657220;
            v69 = v70;
        }
        goto lab_0x21300;
    } else {
        goto lab_0x212f4;
    }
  lab_0x212f4:
    // 0x212f4
    v67 = 3;
    v68 = v36;
    v69 = function_44264(v35, 3);
    goto lab_0x21300;
  lab_0x21300:;
    int32_t v71 = v69;
    char v72 = *(char *)&g70; // 0x2131c
    int32_t v73 = v67; // 0x21310
    int32_t v74 = v68; // 0x21310
    if ((v72 | *(char *)&g179) != 0 || g28 > (char *)5) {
        // 0x21530
        snprintf((char *)&str2, 2048, "JSON-RPC decode failed: %s", (char *)v71);
        function_1ccec(6, &str2, 0);
        v73 = v37;
        v74 = 0;
    }
    // 0x2133c
    free((int32_t *)v71);
    v31 = (char *)((int32_t)v30 ^ 1);
    v14 = &g306;
    v18 = v73;
    v22 = v74;
    goto lab_0x21350;
  lab_0x21718:;
    int32_t v75 = function_47674(v34, 0); // 0x21720
    int32_t v76; // 0x20cfc
    if (v75 != 0) {
        // 0x21730
        if (*(int32_t *)v75 == 1) {
            uint32_t v77 = function_47658(v75); // 0x2173c
            if (v77 >= 1) {
                int32_t v78 = 0;
                int32_t v79 = function_47674(v75, v78); // 0x21768
                while (v79 != 0) {
                    // 0x21774
                    if (*(int32_t *)v79 != 1) {
                        // break -> 0x21784
                        break;
                    }
                    int32_t str3 = function_1e24c(v79, 0); // 0x218c8
                    if (str3 != 0) {
                        // 0x218dc
                        if (strncasecmp((char *)str3, "mining.notify", 13) == 0) {
                            int32_t v80 = function_1e2b0(); // 0x219c8
                            v76 = v80;
                            if (v80 == 0) {
                                goto lab_0x21784;
                            } else {
                                goto lab_0x2180c;
                            }
                        }
                    }
                    int32_t v81 = v78 + 1; // 0x218ec
                    int32_t v82 = v81; // 0x218f4
                    if (v77 == v81) {
                        // break -> 0x21784
                        break;
                    }
                    v78 = v82;
                    v79 = function_47674(v75, v78);
                }
            }
        }
    }
    goto lab_0x21784;
  lab_0x21784:
    // 0x21784
    v76 = 0;
    if (*(char *)&g71 == 0) {
        goto lab_0x2180c;
    } else {
        // 0x21798
        if (*(char *)&g179 == 0) {
            // 0x217ac
            v76 = 0;
            if (*(char *)&g70 == 0 == g28 < (char *)7) {
                goto lab_0x2180c;
            } else {
                goto lab_0x217d4;
            }
        } else {
            goto lab_0x217d4;
        }
    }
  lab_0x2180c:;
    int32_t str4 = v76;
    int32_t str6 = function_1e2b0(); // 0x21814
    int32_t v83 = function_1e330(str6, "initiate_stratum", 3579); // 0x21824
    int32_t v84; // 0x2190c
    if (v83 == 0) {
        char v85 = *(char *)&g70; // 0x2184c
        int32_t v86 = (int32_t)"initiate_stratum"; // 0x21840
        int32_t v87 = 3579; // 0x21840
        if ((v85 | *(char *)&g179) == 0 != g28 < (char *)6) {
            // 0x2186c
            str2 = 0x6c696146;
            function_1ccec(6, &str2, 0);
            v86 = v37;
            v87 = 0;
        }
        // 0x218ac
        free((int32_t *)str4);
        v31 = (char *)((int32_t)v30 ^ 1);
        v14 = &g306;
        v18 = v86;
        v22 = v87;
    } else {
        // 0x218fc
        v84 = function_47a7c(function_47674(v34, 2));
        int32_t v88 = v84 - 2; // 0x21910
        if (v88 == 14 || v88 < 14) {
            if (str4 == 0) {
                goto lab_0x20e64;
            } else {
                int32_t str5 = *v1; // 0x20de8
                if (str5 == 0) {
                    goto lab_0x20e64;
                } else {
                    // 0x20df4
                    if (strcmp((char *)str4, (char *)str5) == 0) {
                        char v89 = *(char *)&g70; // 0x20e1c
                        if ((v89 | *(char *)&g179) == 0 == g28 < (char *)5) {
                            goto lab_0x20e64;
                        } else {
                            // 0x20e3c
                            snprintf((char *)&str2, 2048, "Pool %d successfully negotiated resume with the same session ID", v37);
                            function_1ccec(5, &str2, 0);
                            goto lab_0x20e64;
                        }
                    } else {
                        goto lab_0x20e64;
                    }
                }
            }
        }
        char v90 = *(char *)&g70; // 0x2193c
        int32_t v91 = 2; // 0x21930
        int32_t v92 = v88; // 0x21930
        if ((v90 | *(char *)&g179) == 0 != g28 < (char *)6) {
            // 0x2195c
            str2 = 0x6c696146;
            function_1ccec(6, &str2, 0);
            v91 = v37;
            v92 = 0;
        }
        // 0x2199c
        free((int32_t *)str4);
        free((int32_t *)str6);
        v31 = (char *)((int32_t)v30 ^ 1);
        v14 = &g306;
        v18 = v91;
        v22 = v92;
    }
    goto lab_0x21350;
  lab_0x217d4:
    // 0x217d4
    str2 = 0x6c696146;
    function_1ccec(7, &str2, 0);
    v76 = 0;
    goto lab_0x2180c;
  lab_0x20dac:;
    int32_t v93 = v12; // 0x20db4
    int32_t v94 = v16; // 0x20db4
    int32_t v95 = v20; // 0x20db4
    int32_t v96 = v26; // 0x20db4
    int32_t result2 = 0; // 0x20db4
    if (v26 == 0) {
        // 0x20dbc
        return 0;
    }
    goto lab_0x21094;
  lab_0x21094:;
    int32_t v97 = v96 + 4; // 0x21094
    int32_t * v98 = (int32_t *)v97; // 0x21094
    if (*v98 == -1) {
        // 0x20dbc
        int32_t v99; // 0x20cfc
        int32_t result = v99;
        return result;
    }
    // 0x210a0
    __asm_dmb(v93, v94, v95, v97);
    int32_t v100 = *v98;
    int32_t v101 = v100 - 1; // 0x210ac
    while (__asm_strex(v101, v100) != 0) {
        // 0x210a8
        v100 = *v98;
        v101 = v100 - 1;
    }
    // 0x210bc
    if (v101 == 0) {
        // 0x210c4
        function_47c24(v96);
        return result2;
    }
    // 0x20dbc
    return result2;
  lab_0x211f0:
    // 0x211f0
    str2 = 0x656d6954;
    v13 = function_1ccec(7, &str2, 0);
    v17 = v37;
    v21 = 0;
    v27 = v25;
    goto lab_0x21150_2;
  lab_0x21118:
    // 0x21118
    str2 = 0x6c696146;
    v13 = function_1ccec(7, &str2, 0);
    v17 = &str2;
    v21 = 0;
    v27 = v48;
    goto lab_0x21150_2;
  lab_0x214d4:
    // 0x214d4
    v12 = v15;
    v16 = v19;
    v20 = v23;
    v26 = v28;
    v47 = v28;
    if (v10 < (char *)7 == v11 == 0) {
        goto lab_0x20dac;
    } else {
        goto lab_0x21170;
    }
  lab_0x21170:
    // 0x21170
    str2 = 0x74696e49;
    v12 = function_1ccec(7, &str2, 0);
    v16 = &str2;
    v20 = 0;
    v26 = v47;
    goto lab_0x20dac;
  lab_0x20e64:
    // 0x20e64
    if (pthread_mutex_lock(mutex) != 0) {
        // 0x21ab4
        function_1e5f4("initiate_stratum", 3599);
        // UNREACHABLE
    }
    // 0x20e7c
    if (pthread_rwlock_wrlock(rwlock) != 0) {
        int32_t v102 = *__errno_location(); // 0x21a8c
        snprintf((char *)&str2, 2048, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", v102, "util.c", "initiate_stratum", 3599);
        function_1ccec(3, &str2, 1);
        function_3aadc(1);
        // UNREACHABLE
    }
    // 0x20e90
    free((int32_t *)*v32);
    free((int32_t *)*v1);
    *v1 = str4;
    *v32 = str6;
    uint32_t len3 = strlen((char *)str6); // 0x20ebc
    int32_t * v103 = (int32_t *)(a1 + 616); // 0x20ec4
    int32_t * v104 = (int32_t *)(a1 + 1564); // 0x20ec8
    *v104 = len3 / 2;
    free((int32_t *)*v103);
    int32_t v105 = function_1e7d4(*v104, 1, "util.c", "initiate_stratum", 3606); // 0x20eec
    *v103 = v105;
    function_1ea68(v105, *v32, *v104);
    int32_t * v106 = (int32_t *)(a1 + 632); // 0x20f00
    *v106 = v84;
    if (pthread_rwlock_unlock(rwlock) != 0) {
        int32_t v107 = *__errno_location(); // 0x21a38
        snprintf((char *)&str2, 2048, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", v107, "util.c", "initiate_stratum", 3609);
        function_1ccec(3, &str2, 1);
        function_3aadc(1);
        // UNREACHABLE
    }
    // 0x20f14
    if (pthread_mutex_unlock(mutex) != 0) {
        int32_t v108 = *__errno_location(); // 0x219f4
        snprintf((char *)&str2, 2048, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", v108, "util.c", "initiate_stratum", 3609);
        function_1ccec(3, &str2, 1);
        function_3aadc(1);
        // UNREACHABLE
    }
    int32_t v109 = function_1da28(); // 0x20f30
    if (str4 == 0 | *(char *)&g71 == 0) {
        goto lab_0x20fbc;
    } else {
        char v110 = *(char *)&g70; // 0x20f6c
        if ((v110 | *(char *)&g179) == 0 == g28 < (char *)7) {
            goto lab_0x20fbc;
        } else {
            int32_t v111 = *v1; // 0x20f8c
            snprintf((char *)&str2, 2048, "Pool %d stratum session id: %s", v109, (char *)v111);
            function_1ccec(7, &str2, 0);
            goto lab_0x20fbc;
        }
    }
  lab_0x20fbc:;
    int32_t * v112 = (int32_t *)(a1 + 576); // 0x20fbc
    *(char *)(a1 + 641) = 1;
    if (*v112 == 0) {
        *v112 = *(int32_t *)(a1 + 600);
        goto lab_dec_label_pc_0x20fe4;
    } else {
        goto lab_dec_label_pc_0x20fe4;
    }
  lab_dec_label_pc_0x20fe4:
    *(int32_t *)(a1 + 1816) = 0;
    *(int32_t *)(a1 + 1820) = 0;
    *(int32_t *)(a1 + 1824) = 0;
    *(int32_t *)(a1 + 1828) = 0x3ff00000;
    v93 = 0;
    v94 = 0x3ff00000;
    v95 = 0;
    v96 = v33;
    result2 = v83;
    if (g194 == 0) {
        goto lab_0x21094;
    } else {
        int32_t v113 = g194; // 0x20fe4
        unsigned char v114 = *(char *)&g71; // 0x21010
        v93 = 0;
        v94 = 0x3ff00000;
        v95 = v113;
        v96 = v33;
        result2 = v113;
        if (v114 == 0) {
            goto lab_0x21094;
        } else {
            int32_t v115 = v114; // 0x21010
            char v116 = *(char *)&g70; // 0x2103c
            v93 = 0;
            v94 = 0x3ff00000;
            v95 = v113;
            v96 = v33;
            result2 = v115;
            if ((v116 | *(char *)&g179) == 0 == g28 < (char *)7) {
                goto lab_0x21094;
            } else {
                int32_t v117 = *v106; // 0x2105c
                int32_t v118 = *v32; // 0x21064
                snprintf((char *)&str2, 2048, "Pool %d confirmed mining.subscribe with extranonce1 %s extran2size %d", 0, (char *)v118, v117);
                v93 = function_1ccec(7, &str2, 0);
                v94 = v37;
                v95 = 0;
                v96 = v33;
                result2 = v115;
                goto lab_0x21094;
            }
        }
    }
}

// Address range: 0x21ad4 - 0x21bc4
int32_t function_21ad4(int32_t a1, int32_t a2) {
    int32_t time_val = time(NULL); // 0x21ae4
    *(int32_t *)(a1 + 248) = a2;
    *(int32_t *)(a1 + 244) = time_val;
    g301 = a2;
    switch (a2) {
        case 0: {
            int32_t * v1 = (int32_t *)(a1 + 252); // 0x21b34
            *v1 = *v1 + 1;
            return time_val;
        }
        case 1: {
            int32_t * v2 = (int32_t *)(a1 + 256); // 0x21b44
            *v2 = *v2 + 1;
            return time_val;
        }
        case 2: {
            int32_t * v3 = (int32_t *)(a1 + 260); // 0x21b54
            *v3 = *v3 + 1;
            return time_val;
        }
        case 3: {
            int32_t * v4 = (int32_t *)(a1 + 264); // 0x21b64
            *v4 = *v4 + 1;
            return time_val;
        }
        case 4: {
            int32_t * v5 = (int32_t *)(a1 + 268); // 0x21b74
            *v5 = *v5 + 1;
            return time_val;
        }
        case 5: {
            int32_t * v6 = (int32_t *)(a1 + 272); // 0x21b84
            *v6 = *v6 + 1;
            return time_val;
        }
        case 6: {
            int32_t * v7 = (int32_t *)(a1 + 276); // 0x21b94
            *v7 = *v7 + 1;
            return time_val;
        }
        case 7: {
            int32_t * v8 = (int32_t *)(a1 + 280); // 0x21ba4
            *v8 = *v8 + 1;
            return time_val;
        }
        case 8: {
            int32_t * v9 = (int32_t *)(a1 + 284); // 0x21bb4
            *v9 = *v9 + 1;
            return time_val;
        }
        case 9: {
            int32_t * v10 = (int32_t *)(a1 + 288); // 0x21b24
            *v10 = *v10 + 1;
            // break -> 0x21b30
            break;
        }
    }
    // 0x21b30
    return time_val;
}

// Address range: 0x21bc4 - 0x21c94
int32_t function_21bc4(int32_t result, int32_t a2) {
    char * str = (char *)a2; // 0x21bd4
    int32_t len = strlen(str); // 0x21bd4
    if (len == 0) {
        // 0x21c44
        return result;
    }
    uint32_t v1 = len + 1; // 0x21be8
    if (result == 0) {
        int32_t v2 = v1 & -4;
        int32_t str2 = function_1e74c(v1 % 4 == 0 ? v2 : v2 + 4, "util.c", "realloc_strcat", 3735); // 0x21c70
        strcpy((char *)str2, str);
        return str2;
    }
    char * str3 = (char *)result; // 0x21bf4
    uint32_t v3 = strlen(str3) + v1; // 0x21bf8
    int32_t v4 = v3 & -4;
    int32_t str4 = function_1e74c(v3 % 4 == 0 ? v4 : v4 + 4, "util.c", "realloc_strcat", 3735); // 0x21c1c
    sprintf((char *)str4, "%s%s", str3, str);
    free((int32_t *)result);
    // 0x21c44
    return str4;
}

// Address range: 0x21c98 - 0x21db4
int32_t function_21c98(int32_t str2) {
    if (str2 == 0) {
        int32_t * mem = malloc(7); // 0x21d40
        if (mem == NULL) {
            // 0x21d6c
            int32_t str; // bp-2072, 0x21c98
            snprintf((char *)&str, 2048, "Failed to malloc null in %s %s():%d", "util.c", "str_text", 3760);
            function_1ccec(3, &str, 1);
            function_3aadc(1);
            // UNREACHABLE
        }
        int32_t v1 = (int32_t)mem; // 0x21d40
        *mem = 0x6c756e28;
        *(int16_t *)(v1 + 4) = 0x296c;
        *(char *)(v1 + 6) = 0;
    }
    int32_t result = function_1e74c(4 * strlen((char *)str2) + 5, "util.c", "str_text", 3765); // 0x21cd0
    int32_t v2 = result; // 0x21ce4
    int32_t v3 = str2 - 1; // 0x21ce4
    int32_t v4; // 0x21c98
    while (true) {
        int32_t v5 = v2;
        v3++;
        char * v6 = (char *)v3; // 0x21cf4
        unsigned char v7 = *v6; // 0x21cf4
        int32_t v8 = v7; // 0x21cf4
        uint32_t v9 = v8 - 32; // 0x21cf8
        char * str3 = (char *)v5;
        if (v9 == 94 || v9 < 94) {
            // 0x21ce8
            *str3 = v7;
            int32_t v10 = v5 + 1;
            v2 = v10;
            v4 = v10;
            if (*v6 == 0) {
                // break -> 0x21d28
                break;
            }
        } else {
            // 0x21d0c
            sprintf(str3, "0x%02x", v8);
            int32_t v11 = v5 + 4; // 0x21d1c
            v2 = v11;
            v4 = v11;
            if (*v6 == 0) {
                // break -> 0x21d28
                break;
            }
        }
    }
    // 0x21d28
    *(char *)v4 = 0;
    return result;
}

// Address range: 0x21db8 - 0x21df8
int32_t function_21db8(int32_t * a1) {
    // 0x21db8
    int32_t str; // bp-24, 0x21db8
    snprintf((char *)&str, 16, "cg@%s", a1);
    return prctl(PR_SET_NAME, (int32_t)&str, 0, 0, 0);
}

// Address range: 0x21df8 - 0x21e74
int32_t function_21df8(int32_t sem, char * a2, char * a3, int32_t a4) {
    int32_t v1 = sem_init((int32_t *)sem, 0, 0); // 0x21e18
    if (v1 == 0) {
        // 0x21e68
        return 0;
    }
    int32_t v2 = *__errno_location(); // 0x21e38
    int32_t str; // bp-2072, 0x21df8
    snprintf((char *)&str, 2048, "Failed to sem_init ret=%d errno=%d in %s %s():%d", v1, v2, a2, a3, a4);
    function_1ccec(3, &str, 1);
    function_3aadc(1);
    // UNREACHABLE
}

// Address range: 0x21e74 - 0x21eb8
int32_t function_21e74(int32_t a1, int32_t * attr, int32_t thread_func, int32_t thread_func_arg) {
    // 0x21e74
    function_21df8(a1 + 16, "util.c", "thr_info_create", 1189);
    return pthread_create((int32_t *)(a1 + 12), attr, (int32_t * (*)(int32_t *))thread_func, (int32_t *)thread_func_arg);
}

// Address range: 0x21ebc - 0x21ef4
int32_t function_21ebc(int32_t sem, char * a2, char * a3, int32_t a4) {
    // 0x21ebc
    if (sem_post((int32_t *)sem) == 0) {
        return 0;
    }
    // 0x21edc
    return function_1e2c8(sem, (int32_t)a2, (int32_t)a3, a4);
}

// Address range: 0x21ef4 - 0x21f34
int32_t function_21ef4(int32_t a1) {
    // 0x21ef4
    pthread_setcanceltype(1, PTHREAD_CANCEL_DEFERRED);
    function_21ebc(a1, "util.c", "completion_thread", 3991);
    return 0;
}

// Address range: 0x21f38 - 0x21fb8
int32_t function_21f38(int32_t a1, char * a2, char * a3, int32_t a4) {
    int32_t * sem = (int32_t *)a1; // 0x21f58
    while (sem_wait(sem) != 0) {
        int32_t v1 = *__errno_location(); // 0x21f74
        if (v1 != 4) {
            // 0x21f80
            int32_t str; // bp-2072, 0x21f38
            snprintf((char *)&str, 2048, "Failed to sem_wait errno=%d cgsem=0x%p in %s %s():%d", v1, sem, a2, a3, a4);
            function_1ccec(3, &str, 1);
            function_3aadc(1);
            // UNREACHABLE
        }
    }
    // 0x21f64
    return 0;
}

// Address range: 0x21fb8 - 0x22108
int32_t function_21fb8(int32_t a1, int32_t a2, char * a3, char * a4, int32_t a5) {
    // 0x21fb8
    int32_t tp; // bp-2088, 0x21fb8
    clock_gettime(1, (struct timespec *)&tp);
    int64_t v1; // 0x21fb8
    int32_t v2 = v1; // 0x21fe4
    int64_t abs_timeout; // bp-2096, 0x21fb8
    function_1f388((int32_t *)&abs_timeout);
    int32_t * sem = (int32_t *)a1; // 0x2206c
    int32_t result; // 0x21fb8
    while (true) {
      lab_0x22034:;
        uint64_t v3 = 0x100000000 * abs_timeout >> 32; // 0x22034
        int32_t v4 = v3; // 0x22034
        int32_t v5 = v2 - v2 % 1000 + v4; // 0x22038
        int32_t v6 = tp + (int32_t)(v3 / 0x100000000);
        abs_timeout = v6;
        if (v5 > 0x3b9ac9ff) {
            // 0x2204c
            abs_timeout = (v5 > 0x773593ff ? 2 : 1) + v6;
        } else {
            if (v5 < 0) {
                // 0x2209c
                abs_timeout = v6 + -1 - (v4 ^ -512) / 0x3b9aca00;
            }
        }
        int32_t v7 = sem_timedwait(sem, (struct timespec *)&abs_timeout); // 0x2206c
        result = 0;
        if (v7 == 0) {
            // break -> 0x22088
            break;
        }
        int32_t v8 = *__errno_location(); // 0x2207c
        result = 110;
        switch (v8) {
            case 110: {
                return result;
            }
            case 4: {
                goto lab_0x22034;
            }
            default: {
                // 0x220b8
                snprintf((char *)&tp, 2048, "Failed to sem_timedwait errno=%d cgsem=0x%p in %s %s():%d", v8, sem, a3, a4, a5);
                function_1ccec(3, &tp, 1);
                function_3aadc(1);
                // UNREACHABLE
            }
        }
    }
    // 0x22088
    return result;
}

// Address range: 0x22108 - 0x2213c
int32_t function_22108(int32_t sem) {
    // 0x22108
    int32_t * v1; // 0x22128
    while (true) {
        int32_t result = sem_trywait((int32_t *)sem); // 0x2211c
        if (result < 0) {
            // 0x22128
            v1 = __errno_location();
            if (*v1 != 4) {
                // break -> 
                break;
            }
        } else {
            if (result != 0) {
                return result;
            }
        }
    }
    return (int32_t)v1;
}

// Address range: 0x2213c - 0x22140
int32_t function_2213c(void) {
    // 0x2213c
    int32_t sem; // 0x2213c
    return sem_destroy((int32_t *)sem);
}

// Address range: 0x22140 - 0x22208
int32_t function_22140(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = function_1e74c(24, "util.c", "cg_completion_timeout", 4002); // 0x22168
    function_21df8(v1, "util.c", "cg_completion_timeout", 4003);
    *(int32_t *)(v1 + 16) = a1;
    *(int32_t *)(v1 + 20) = a2;
    int32_t * thread_func_arg = (int32_t *)v1; // 0x221a0
    int32_t thread; // bp-28, 0x22140
    pthread_create(&thread, NULL, (int32_t * (*)(int32_t *))0x21ef4, thread_func_arg);
    if (function_21fb8(v1, a3, "util.c", "cg_completion_timeout", 4009) != 0) {
        // 0x221cc
        pthread_cancel(thread);
        return 0;
    }
    // 0x221e4
    pthread_join(thread, NULL);
    free(thread_func_arg);
    return 0;
}

// Address range: 0x2220c - 0x2237c
int32_t function_2220c(int32_t result, int32_t * a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    int32_t format; // 0x2220c
    if (a3 < 1) {
        char v1 = *(char *)&g70; // 0x22268
        format = (int32_t)"ERR: Asked to memcpy %u bytes from %s %s():%d";
        if ((v1 | *(char *)&g179) == 0 == g28 < (char *)3) {
            // 0x222bc
            return result;
        }
    } else {
        if (result == 0) {
            char v2 = *(char *)&g70; // 0x222e0
            format = (int32_t)"ERR: Asked to memcpy %u bytes to NULL from %s %s():%d";
            if ((v2 | *(char *)&g179) == 0 == g28 < (char *)3) {
                // 0x222bc
                return 0;
            }
        } else {
            if (a2 != NULL) {
                // 0x22240
                return (int32_t)memcpy((int32_t *)result, a2, a3);
            }
            char v3 = *(char *)&g70; // 0x2233c
            format = (int32_t)"ERR: Asked to memcpy %u bytes from NULL from %s %s():%d";
            if ((v3 | *(char *)&g179) == 0 == g28 < (char *)3) {
                // 0x222bc
                return result;
            }
        }
    }
    // 0x222a4
    int32_t str; // bp-2064, 0x2220c
    snprintf((char *)&str, 2048, (char *)format, a3, (char *)a4, (char *)a5, a6);
    // 0x222bc
    return function_1ccec(3, &str, 0);
}

// Address range: 0x2237c - 0x22404
int32_t function_2237c(int32_t a1) {
    int32_t v1 = 0; // bp-36, 0x22394
    int32_t v2; // 0x2237c
    function_1ec0c(&v1, v2);
    *(char *)a1 = 118;
    *(char *)(a1 + 1) = -87;
    *(char *)(a1 + 2) = 20;
    int32_t v3; // bp-35, 0x2237c
    int32_t result = function_2220c(a1 + 3, &v3, 20, (int32_t)"util.c", (int32_t)"address_to_pubkeyhash", 964); // 0x223e8
    *(char *)(a1 + 23) = -120;
    *(char *)(a1 + 24) = -84;
    return result;
}

// Address range: 0x22408 - 0x22518
int32_t function_22408(int32_t str, int32_t a2) {
    uint32_t len = strlen((char *)str); // 0x2241c
    int32_t result = function_1e74c(len + 9, "util.c", "ser_string", 994); // 0x22438
    if (len == 252 || len < 252) {
        // 0x224e0
        *(char *)result = (char)len;
        function_2220c(result + 1, (int32_t *)str, len, (int32_t)"util.c", (int32_t)"ser_string", 998);
        *(int32_t *)a2 = len + 1;
        return result;
    }
    if (len < 0x10000) {
        int32_t v1 = __asm_rev16(len); // 0x2249c
        *(char *)result = -3;
        *(int16_t *)(result + 1) = (int16_t)v1;
        function_2220c(result + 3, (int32_t *)str, len, (int32_t)"util.c", (int32_t)"ser_string", 1007);
        *(int32_t *)a2 = len + 3;
        return result;
    }
    int32_t v2 = llvm_bswap_i32(len); // 0x22454
    *(char *)result = -2;
    *(int32_t *)(result + 1) = v2;
    function_2220c(result + 5, (int32_t *)str, len, (int32_t)"util.c", (int32_t)"ser_string", 1017);
    *(int32_t *)a2 = len + 5;
    return result;
}

// Address range: 0x2251c - 0x2254c
int32_t function_2251c(int32_t a1, int32_t a2) {
    // 0x2251c
    return function_2220c(a1, (int32_t *)a2, 8, (int32_t)"util.c", (int32_t)"copy_time", 1234);
}

// Address range: 0x22550 - 0x236b4
int32_t function_22550(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = function_47674(a2, 4); // 0x22570
    if (v1 == 0 || *(int32_t *)v1 != 1) {
        // 0x2258c
        return 0;
    }
    int32_t v2 = function_47658(v1); // 0x22598
    int32_t result2 = 0; // 0x225a0
    int32_t * v3; // 0x22550
    int32_t v4; // 0x22550
    char * str; // bp-2088, 0x22550
    int32_t tp; // bp-2316, 0x22550
    if (v2 < 1) {
        goto lab_0x22724;
    } else {
        // 0x225c0
        memset(&tp, 0, 32);
        int32_t v5 = function_1e2b0(); // 0x225dc
        if (v5 == 0) {
            // 0x2258c
            return 0;
        }
        int32_t v6 = 0;
        v4 = v5;
        int32_t v7 = function_1ea68((int32_t)&tp, v4, 32); // 0x225f8
        while (v7 != 0) {
            int32_t v8 = v6 + 1; // 0x225b0
            free((int32_t *)v4);
            result2 = v7;
            if (v2 == v8) {
                goto lab_0x22724;
            }
            // 0x225c0
            memset(&tp, 0, 32);
            int32_t v9 = function_1e2b0(); // 0x225dc
            int32_t result = v7; // 0x225f4
            if (v9 == 0) {
                // 0x2258c
                return result;
            }
            v6 = v8;
            v4 = v9;
            v7 = function_1ea68((int32_t)&tp, v4, 32);
        }
        char v10 = *(char *)&g70; // 0x22624
        if ((v10 | *(char *)&g179) == 0 == g28 < (char *)3) {
            goto lab_0x22698;
        } else {
            // 0x22630
            snprintf((char *)&str, 2048, "merkle %d: %s", v6, (char *)v4);
            function_1ccec(3, (int32_t *)&str, 0);
            v3 = (int32_t *)&str;
            if ((*(char *)&g70 | *(char *)&g179) == 0) {
                // 0x22698
                goto lab_0x22698;
            } else {
                goto lab_0x226b0;
            }
        }
    }
  lab_0x22724:;
    int32_t str3 = function_1e2b0(); // 0x2272c
    int32_t v11 = function_1e24c(a2, 1); // 0x22740
    int32_t str4 = function_1e2b0(); // 0x22754
    int32_t str5 = function_1e2b0(); // 0x22764
    int32_t v12 = function_1e24c(a2, 5); // 0x22774
    int32_t v13 = function_1e24c(a2, 6); // 0x22784
    int32_t v14 = function_1e24c(a2, 7); // 0x22794
    char * str2 = (char *)v14; // 0x227a0
    int32_t str_as_l = strtol(str2, NULL, 16); // 0x227a4
    if (!((str_as_l == 0 | *(char *)&g161 % 2 != 0))) {
        // 0x22ab8
        tp = 0;
        gettimeofday((struct timeval *)&tp, NULL);
        uint32_t v15 = tp; // 0x22ae4
        if (str_as_l != v15 && str_as_l >= v15) {
            // 0x22af8
            tp = str_as_l;
            settimeofday((struct timeval *)&tp, NULL);
            char v16 = *(char *)&g70; // 0x22b24
            if ((v16 | *(char *)&g179) == 0 != g28 < (char *)5) {
                // 0x22b44
                str = (char *)0x74746573;
                function_1ccec(5, (int32_t *)&str, 0);
            }
            // 0x22b84
            *(char *)&g161 = 1;
        }
    }
    // 0x227c4
    if (function_47674(a2, 8) != 0) {
        // 0x227dc
        function_47674(a2, 8);
    }
    if (str3 == 0) {
        char v17 = *(char *)&g70; // 0x22bac
        if ((v17 | *(char *)&g179) == 0 == g28 < (char *)3) {
            goto lab_0x228bc;
        } else {
            // 0x22bf4
            snprintf((char *)&str, 2048, (char *)(int32_t)"Null string passed to valid_ascii from in %s %s():%d", "util.c", (struct timeval *)"parse_notify", 2027);
            // 0x228a8
            function_1ccec(3, (int32_t *)&str, 0);
            goto lab_0x228bc;
        }
    } else {
        uint32_t len = strlen((char *)str3); // 0x22808
        int32_t v18 = str3; // 0x22814
        if (len == 0) {
            char v19 = *(char *)&g70; // 0x22c1c
            if ((v19 | *(char *)&g179) == 0 == g28 < (char *)3) {
                goto lab_0x228bc;
            } else {
                // 0x22bf4
                snprintf((char *)&str, 2048, (char *)(int32_t)"Zero length string passed to valid_ascii from in %s %s():%d", "util.c", (struct timeval *)"parse_notify", 2027);
                // 0x228a8
                function_1ccec(3, (int32_t *)&str, 0);
                goto lab_0x228bc;
            }
        } else {
            int32_t v20 = (int32_t)*(char *)v18; // 0x22824
            while (v20 == 126 || v20 < 126) {
                int32_t v21 = v18 + 1; // 0x22824
                v18 = v21;
                if (len <= v21 - str3) {
                    // 0x228d8
                    if (function_1e330(v11, "parse_notify", 2027) == 0) {
                        goto lab_0x228bc;
                    } else {
                        // 0x228f4
                        if (function_1e330(str4, "parse_notify", 2027) == 0) {
                            goto lab_0x228bc;
                        } else {
                            // 0x2290c
                            if (function_1e330(str5, "parse_notify", 2028) == 0) {
                                goto lab_0x228bc;
                            } else {
                                // 0x22924
                                if (function_1e330(v12, "parse_notify", 2028) == 0) {
                                    goto lab_0x228bc;
                                } else {
                                    // 0x2293c
                                    if (function_1e330(v13, "parse_notify", 2028) == 0) {
                                        goto lab_0x228bc;
                                    } else {
                                        // 0x22954
                                        if (function_1e330(v14, "parse_notify", 2029) != 0) {
                                            // 0x2296c
                                            if (pthread_mutex_lock((int32_t *)(a1 + 212)) != 0) {
                                                // 0x23650
                                                function_1e5f4("parse_notify", 2038);
                                                // UNREACHABLE
                                            }
                                            // 0x22984
                                            function_1e480(a1 + 236, "parse_notify", 2038);
                                            int32_t * v22 = (int32_t *)(a1 + 672); // 0x229a0
                                            free((int32_t *)*v22);
                                            *v22 = str3;
                                            snprintf((char *)(a1 + 1712), 65, "%s", (char *)v11);
                                            strlen((char *)str4);
                                            strlen((char *)str5);
                                            snprintf((char *)(a1 + 1780), 9, "%s", (char *)v12);
                                            snprintf((char *)(a1 + 1792), 9, "%s", (char *)v13);
                                            int32_t chars_printed = snprintf((char *)(a1 + 1804), 9, "%s", str2); // 0x22a50
                                            *(char *)(a1 + 680) = 0;
                                            __asm_vldr(*(int32_t *)(a1 + 1816));
                                            return chars_printed;
                                        }
                                        goto lab_0x228bc;
                                    }
                                }
                            }
                        }
                    }
                }
                v20 = (int32_t)*(char *)v18;
            }
            char v23 = *(char *)&g70; // 0x22854
            if ((v23 | *(char *)&g179) == 0 == g28 < (char *)3) {
                goto lab_0x228bc;
            } else {
                // 0x22874
                snprintf((char *)&str, 2048, "Invalid char 0x%x passed to valid_ascii from in %s %s():%d", v20, "util.c", "parse_notify", 2027);
                // 0x228a8
                function_1ccec(3, (int32_t *)&str, 0);
                goto lab_0x228bc;
            }
        }
    }
  lab_0x22698:
    // 0x22698
    if (g28 < (char *)3) {
        // 0x226fc
        free((int32_t *)v4);
        // 0x2258c
        return 0;
    }
    // 0x22698
    v3 = (int32_t *)&str;
    goto lab_0x226b0;
  lab_0x228bc:
    // 0x228bc
    free((int32_t *)str3);
    free((int32_t *)str4);
    free((int32_t *)str5);
    // 0x2258c
    return result2;
  lab_0x226b0:;
    int32_t v24 = (int32_t)&str;
    *v3 = 0x6c696146;
    *(int32_t *)(v24 + 4) = 0x74206465;
    *(int32_t *)(v24 + 8) = 0x6f63206f;
    *(int32_t *)(v24 + 12) = 0x7265766e;
    *(int32_t *)(v24 + 16) = 0x656d2074;
    *(int32_t *)(v24 + 20) = 0x656c6b72;
    *(int32_t *)(v24 + 24) = 0x206f7420;
    *(int32_t *)(v24 + 28) = 0x6b72656d;
    *(int32_t *)(v24 + 32) = 0x625f656c;
    *(int32_t *)(v24 + 36) = 0x69206e69;
    *(int32_t *)(v24 + 40) = 0x6170206e;
    *(int32_t *)(v24 + 44) = 0x5f657372;
    *(int32_t *)(v24 + 48) = 0x69746f6e;
    *(int16_t *)(v24 + 52) = 0x7966;
    *(char *)(v24 + 54) = 0;
    function_1ccec(3, v3, 0);
    // 0x226fc
    free((int32_t *)v4);
    // 0x2258c
    return 0;
}

// Address range: 0x236b8 - 0x23970
int32_t function_236b8(int32_t a1, int32_t sock, int32_t a3) {
    int16_t buf = 260; // bp-2596, 0x236d0
    __asm_ubfx(strtol((char *)*(int32_t *)(a1 + 584), NULL, 10), 8, 8);
    int32_t * cp = (int32_t *)(a1 + 600); // 0x23708
    int32_t hints; // bp-2080, 0x236b8
    if (inet_addr((char *)*cp) == -1) {
        // 0x237ec
        int32_t v1; // bp-2628, 0x236b8
        struct addrinfo * addr_info = (struct addrinfo *)&v1; // bp-2632, 0x237fc
        memset(&hints, 0, 32);
        int32_t v2 = getaddrinfo((char *)*cp, NULL, (struct addrinfo *)&hints, &addr_info); // 0x2381c
        if (v2 == 0) {
            int32_t v3 = *(int32_t *)((int32_t)addr_info + 20); // 0x238f4
            freeaddrinfo(addr_info);
            if (*(int32_t *)(v3 + 4) == -1) {
                goto lab_0x2390c;
            } else {
                // 0x2371c
                send(sock, (int32_t *)&buf, 16, 0);
                goto lab_0x2374c;
            }
        } else {
            if (a3 == 0) {
                goto lab_0x2390c;
            } else {
                int32_t str = *cp; // 0x23830
                uint32_t len = strlen((char *)str); // 0x23844
                int32_t v4 = len < 255 ? len : 255;
                int32_t v5; // bp-2580, 0x236b8
                function_2220c((int32_t)&v5, (int32_t *)str, v4, (int32_t)"util.c", (int32_t)"socks4_negotiate", 2981);
                int32_t v6; // bp-32, 0x236b8
                *(char *)((int32_t)&v6 - 2548 + v4) = 0;
                send(sock, (int32_t *)&buf, v4 + 17, 0);
                goto lab_0x2374c;
            }
        }
    } else {
        // 0x2371c
        send(sock, (int32_t *)&buf, 16, 0);
        goto lab_0x2374c;
    }
  lab_0x2374c:
    // 0x2374c
    if (recv(sock, &hints, 1, 0) != -1) {
        // 0x23768
        if (hints % 256 == 0) {
            // 0x238a4
            if (recv(sock, &hints, 1, 0) != -1) {
                // 0x238bc
                if (hints % 256 == 90) {
                    int32_t v7 = 6;
                    recv(sock, &hints, 1, 0);
                    int32_t v8 = v7 - 1; // 0x238e4
                    while (v7 != 1) {
                        // 0x238cc
                        v7 = v8;
                        recv(sock, &hints, 1, 0);
                        v8 = v7 - 1;
                    }
                    // 0x237e4
                    return 1;
                }
            }
        }
    }
    char v9 = *(char *)&g70; // 0x23790
    if ((v9 | *(char *)&g179) == 0 == g28 < (char *)4) {
        // 0x237e4
        return 0;
    }
    int32_t v10 = *(int32_t *)(a1 + 608); // 0x237b0
    int32_t v11 = *(int32_t *)(a1 + 604); // 0x237b8
    snprintf((char *)&hints, 2048, "Bad response from %s:%s SOCKS4 server", (char *)v11, (char *)v10);
    // 0x237d0
    function_1ccec(4, &hints, 0);
    // 0x237e4
    return 0;
  lab_0x2390c:;
    char v12 = *(char *)&g70; // 0x23928
    if ((v12 | *(char *)&g179) == 0 && g28 <= (char *)3) {
        // 0x237e4
        return 0;
    }
    int32_t v13 = *cp; // 0x23958
    snprintf((char *)&hints, 2048, "Invalid IP address specified for socks4 proxy: %s", (char *)v13);
    // 0x237d0
    function_1ccec(4, &hints, 0);
    // 0x237e4
    return 0;
}

// Address range: 0x23974 - 0x24a24
int32_t function_23974(int32_t a1) {
    int32_t v1 = a1 + 704; // 0x23978
    int32_t * mutex = (int32_t *)v1; // 0x2398c
    int32_t str; // bp-8232, 0x23974
    if (pthread_mutex_lock(mutex) != 0) {
        int32_t v2 = *__errno_location(); // 0x244b8
        snprintf((char *)&str, 2048, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", v2, "util.c", "setup_stratum_socket", 3195);
        function_1ccec(3, &str, 1);
        function_3aadc(1);
        // UNREACHABLE
    }
    int32_t * v3 = (int32_t *)(a1 + 588); // 0x239a0
    int32_t fd = *v3; // 0x239a0
    char * v4 = (char *)(a1 + 641); // 0x239a8
    *v4 = 0;
    if (fd != 0) {
        // 0x239b4
        close(fd);
    }
    // 0x239b8
    *v3 = 0;
    if (pthread_mutex_unlock(mutex) != 0) {
        int32_t v5 = *__errno_location(); // 0x24450
        snprintf((char *)&str, 2048, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", v5, "util.c", "setup_stratum_socket", 3213);
        function_1ccec(3, &str, 1);
        function_3aadc(1);
        // UNREACHABLE
    }
    // 0x239d0
    function_1da28();
    int32_t hints; // bp-10312, 0x23974
    memset(&hints, 0, 32);
    int32_t * v6 = (int32_t *)(a1 + 184); // 0x239f0
    int32_t v7; // 0x23974
    int32_t v8; // 0x23974
    if (*v6 == 0) {
        // 0x23f50
        if (g157 == 0) {
            // 0x23f90
            v7 = a1 + 600;
            v8 = a1 + 584;
            goto lab_0x23a14;
        } else {
            int32_t v9 = a1 + 608;
            *v6 = g157;
            int32_t v10 = a1 + 604;
            function_1f930(g157, v10, v9);
            *(int32_t *)(a1 + 180) = 3;
            v7 = v10;
            v8 = v9;
            if (*v6 == 0) {
                // 0x23f90
                v7 = a1 + 600;
                v8 = a1 + 584;
                goto lab_0x23a14;
            } else {
                goto lab_0x23a14;
            }
        }
    } else {
        // 0x239d0
        v7 = a1 + 604;
        v8 = a1 + 608;
        goto lab_0x23a14;
    }
  lab_0x23bdc_2:;
    char v11 = *(char *)&g70; // 0x23bf8
    char * node; // 0x23974
    char * service; // 0x23974
    if ((v11 | *(char *)&g179) != 0 || g28 > (char *)5) {
        // 0x23c04
        snprintf((char *)&str, 2048, "Failed to connect to stratum on %s:%s", node, service);
        function_1ccec(6, &str, 0);
    }
    // 0x23c34
    struct addrinfo * addr_info; // bp-10332, 0x23974
    freeaddrinfo(addr_info);
    goto lab_0x23cac;
  lab_0x23bcc:;
    // 0x23bcc
    int32_t v54; // 0x23974
    int32_t v55 = *(int32_t *)(v54 + 28); // 0x23bcc
    int32_t v56 = v55; // 0x23bd4
    if (v55 == 0) {
        goto lab_0x23bdc_2;
    }
    goto lab_0x23ae0;
  lab_0x23ae0:;
    int32_t v57 = (int32_t)&g71; // 0x23974
    int32_t v58 = v56; // 0x23974
    goto lab_0x23ae0_2;
  lab_0x23d24:;
    // 0x23d24
    int32_t v19; // 0x2399c
    *(int32_t *)v19 = 0x6c696146;
    *(int32_t *)(v19 + 4) = 0x73206465;
    *(int32_t *)(v19 + 8) = 0x656b636f;
    *(int16_t *)(v19 + 12) = 116;
    function_1ccec(7, &str, 0);
    int32_t v70 = *(int32_t *)(v54 + 28); // 0x23d3c
    v56 = v70;
    if (v70 == 0) {
        goto lab_0x23bdc_2;
    }
    goto lab_0x23ae0;
  lab_0x23a14:
    // 0x23a14
    node = (char *)*(int32_t *)v7;
    service = (char *)*(int32_t *)v8;
    int32_t v71 = getaddrinfo(node, service, (struct addrinfo *)&hints, &addr_info); // 0x23a24
    int32_t v53; // 0x23974
    int32_t option_value2; // bp-10280, 0x23974
    int32_t option_value; // bp-10320, 0x23974
    int32_t sock_fd; // 0x23ae4
    if (v71 == 0) {
        // 0x23ab8
        if (addr_info == NULL) {
            goto lab_0x23bdc_2;
        } else {
            // 0x23ac4
            v19 = &str;
            v57 = v1;
            v58 = (int32_t)addr_info;
            while (true) {
              lab_0x23ae0_2:
                // 0x23ae0
                v54 = v58;
                int32_t protocol = *(int32_t *)(v54 + 12); // 0x23ae0
                sock_fd = socket(*(int32_t *)(v54 + 4), *(int32_t *)(v54 + 8), protocol);
                if (sock_fd == -1) {
                    // 0x23ccc
                    if (*(char *)&g71 == 0) {
                        goto lab_0x23bcc;
                    } else {
                        char v59 = *(char *)&g70; // 0x23cf4
                        if ((v59 | *(char *)&g179) == 0 == g28 < (char *)7) {
                            goto lab_0x23bcc;
                        } else {
                            goto lab_0x23d24;
                        }
                    }
                } else {
                    // 0x23af4
                    fcntl(sock_fd, F_GETFL);
                    fcntl(sock_fd, F_SETFL);
                    int32_t addr = *(int32_t *)(v54 + 20); // 0x23b18
                    if (connect(sock_fd, (struct sockaddr *)addr, *(int32_t *)(v54 + 16)) != -1) {
                        // break -> 0x23fc0
                        break;
                    }
                    // 0x23b28
                    option_value = 1;
                    if (*__errno_location() == 115) {
                        int32_t v60; // 0x23974
                        int32_t v61 = v60 + 4; // 0x23d84
                        *(int32_t *)v61 = 0;
                        v60 = v61;
                        // 0x23d80
                        int32_t v62; // 0x23974
                        while (v61 != v62) {
                            // 0x23d84
                            v61 = v60 + 4;
                            *(int32_t *)v61 = 0;
                            v60 = v61;
                        }
                        // 0x23d90
                        int32_t v63; // 0x23d70
                        int32_t * v64; // 0x23d90
                        *v64 = *v64 | v63;
                        int32_t nfds; // 0x23d78
                        uint32_t v65 = select(nfds, NULL, (struct _TYPEDEF_fd_set *)&option_value2, NULL, (struct timeval *)&option_value); // 0x23db4
                        // 0x23d4c
                        while (v65 < 1) {
                            if (v65 == 0) {
                                goto lab_0x23dcc_2;
                            }
                            // 0x23e40
                            int32_t * v66; // 0x23b38
                            if (*v66 != 4) {
                                goto lab_0x23dcc_2;
                            }
                            v61 = v60 + 4;
                            *(int32_t *)v61 = 0;
                            v60 = v61;
                            // 0x23d80
                            while (v61 != v62) {
                                // 0x23d84
                                v61 = v60 + 4;
                                *(int32_t *)v61 = 0;
                                v60 = v61;
                            }
                            // 0x23d90
                            *v64 = *v64 | v63;
                            v65 = select(nfds, NULL, (struct _TYPEDEF_fd_set *)&option_value2, NULL, (struct timeval *)&option_value);
                        }
                        // 0x23dc0
                        if ((*v64 & v63) != 0) {
                            int32_t option_len = 4; // bp-10328, 0x23e6c
                            int32_t option_value3; // bp-10324, 0x23974
                            if ((option_value3 || getsockopt(sock_fd, SO_DEBUG, 4, &option_value3, &option_len)) == 0) {
                                // 0x23e88
                                v53 = (int32_t)&g71;
                                if (*(char *)&g71 == 0) {
                                    goto lab_0x23f0c;
                                } else {
                                    char v67 = *(char *)&g70; // 0x23ebc
                                    v53 = (int32_t)&g71;
                                    if ((v67 || *(char *)&g179) == 0 == g28 < (char *)7) {
                                        goto lab_0x23f0c;
                                    } else {
                                        // 0x23edc
                                        str = 0x63637553;
                                        function_1ccec(7, &str, 0);
                                        v53 = (int32_t)&g71;
                                        goto lab_0x23f0c;
                                    }
                                }
                            }
                        }
                      lab_0x23dcc_2:
                        // 0x23dcc
                        close(sock_fd);
                        if (*(char *)&g71 == 0) {
                            goto lab_0x23bcc;
                        } else {
                            char v68 = *(char *)&g70; // 0x23e00
                            if ((v68 || *(char *)&g179) == 0 == g28 < (char *)7) {
                                goto lab_0x23bcc;
                            } else {
                                // 0x23e20
                                str = 0x656c6553;
                                goto lab_0x23d24;
                            }
                        }
                    } else {
                        // 0x23b4c
                        close(sock_fd);
                        if (*(char *)&g71 != 0) {
                            char v69 = *(char *)&g70; // 0x23b80
                            if ((v69 | *(char *)&g179) == 0 != g28 < (char *)7) {
                                // 0x23ba0
                                str = 0x6c696146;
                                function_1ccec(7, &str, 0);
                            }
                        }
                        goto lab_0x23bcc;
                    }
                }
            }
            char v72 = *(char *)&g70; // 0x23fe0
            v53 = v57;
            if ((v72 | *(char *)&g179) == 0 != g28 < (char *)4) {
                // 0x24000
                str = 0x63637553;
                function_1ccec(4, &str, 0);
                v53 = v57;
            }
            goto lab_0x23f0c;
        }
    } else {
        char * v73 = (char *)(a1 + 99); // 0x23a34
        char v74 = *(char *)&g179; // 0x23a40
        char v75 = *(char *)&g70;
        if (*v73 == 0) {
            if ((v75 || v74) == 0 != g28 < (char *)4) {
                // 0x23a7c
                snprintf((char *)&str, 2048, "Failed to resolve (?wrong URL) %s:%s", node, service);
                function_1ccec(4, &str, 0);
            }
            // 0x23aac
            *v73 = 1;
        } else {
            if ((v75 || v74) == 0 != g28 < (char *)6) {
                // 0x23c70
                snprintf((char *)&str, 2048, "Failed to getaddrinfo for %s:%s", node, service);
                function_1ccec(6, &str, 0);
            }
        }
        // 0x23ca0
        __res_init();
        goto lab_0x23cac;
    }
  lab_0x23cac:;
    int32_t v12 = 0; // 0x23cb4
    if (*(char *)&g71 == 0) {
        // 0x23cbc
        return 0;
    }
    goto lab_0x24264;
  lab_0x23f0c:
    // 0x23f0c
    function_1e190(sock_fd);
    freeaddrinfo(addr_info);
    int32_t v42; // 0x23974
    int32_t v28; // 0x23974
    int32_t v29; // 0x23974
    if (*v6 == 0) {
        goto lab_0x240f0;
    } else {
        int32_t v52 = *(int32_t *)(a1 + 180); // 0x23f28
        g302 = v52;
        v29 = 1;
        v28 = 1;
        switch (v52) {
            case 0: {
                // 0x24770
                v28 = 0;
                goto lab_0x24758;
            }
            case 1: {
                goto lab_0x24758;
            }
            case 2: {
                // 0x2474c
                v29 = 0;
                goto lab_0x245f0;
            }
            case 3: {
                goto lab_0x24610;
            }
            case 4: {
                goto lab_0x245f0;
            }
            case 5: {
                goto lab_0x24610;
            }
            default: {
                // 0x24784
                if ((*(char *)&g70 | *(char *)&g179) == 0) {
                    // 0x247ac
                    v42 = g28 < (char *)4 ? 0x66641 : v53 % 0x10000 | 0x60000;
                    if (g28 > (char *)3) {
                        goto lab_0x247c8;
                    } else {
                        goto lab_0x2430c;
                    }
                } else {
                    goto lab_0x247c8;
                }
            }
        }
    }
  lab_0x24264:;
    char v13 = *(char *)&g70; // 0x24278
    int32_t v14 = v12; // 0x2426c
    int32_t v15 = v12; // 0x2426c
    if ((v13 | *(char *)&g179) != 0 || g28 > (char *)6) {
        goto lab_0x24328;
    } else {
        goto lab_0x24298;
    }
  lab_0x240f0:;
    int32_t * v16 = (int32_t *)(a1 + 592); // 0x240f0
    if (*v16 == 0) {
        // 0x24804
        *v16 = function_1e7d4(0x2000, 1, "util.c", "setup_stratum_socket", 3351);
        *(int32_t *)(a1 + 596) = 0x2000;
    }
    // 0x240fc
    *v3 = sock_fd;
    option_value2 = 45;
    str = 30;
    option_value = 1;
    fcntl(sock_fd, F_GETFL);
    fcntl(sock_fd, F_SETFL);
    setsockopt(sock_fd, SO_DEBUG, 9, &option_value, 4);
    if (g272 == 0) {
        // 0x24168
        fcntl(sock_fd, F_SETFD);
    }
    // 0x24178
    setsockopt(sock_fd, SO_BROADCAST, 1, &option_value, 4);
    setsockopt(sock_fd, SO_BROADCAST, 6, &option_value, 4);
    setsockopt(sock_fd, SO_BROADCAST, 4, &option_value2, 4);
    setsockopt(sock_fd, SO_BROADCAST, 5, &str, 4);
    if (g51 == 0) {
        // branch -> 0x241f0
    } else {
        int32_t v17 = g183; // 0x24414
        g183 = v17 + 1;
        sprintf((char *)&str, "{\"id\":%d, \"method\":\"mining.configure\", \"params\":[[\"version-rolling\"],{\"version-rolling.mask\":\"%08x\",\"version-rolling.min-bit-count\":%d}]}", v17, 0x1fffe000, 3);
        *(int32_t *)(a1 + 648) = 1;
    }
    int32_t len = strlen((char *)&str); // 0x241f4
    int32_t v18; // 0x23974
    if (function_1da30(a1, v19, len) == 0) {
        int32_t result = function_1e1b8(*v3, 60); // 0x24360
        if (result == 0) {
            // 0x2436c
            if (*(char *)&g71 == 0) {
                // 0x242a0
                function_20258(a1, (int32_t)&g306, (int32_t)&g306);
                return 0;
            }
            char v20 = *(char *)&g70; // 0x2439c
            v12 = 1;
            if ((v20 | *(char *)&g179) == 0 == g28 < (char *)7) {
                goto lab_0x24264;
            } else {
                // 0x243bc
                option_value2 = 0x656d6954;
                function_1ccec(7, &option_value2, 0);
                v18 = (int32_t)&g71;
                goto lab_0x242f4;
            }
        } else {
            int32_t v21 = function_20770(a1, 60, len); // 0x244f4
            v18 = 0x66641;
            if (v21 != 0) {
                // 0x24508
                function_1ff10();
                free((int32_t *)v21);
                int32_t * v22 = (int32_t *)(a1 + 576); // 0x2451c
                if (*v22 == 0) {
                    // 0x245e0
                    *v22 = *(int32_t *)(a1 + 600);
                }
                // 0x24528
                *v4 = 1;
                if (g194 == 0) {
                    // 0x23cbc
                    return result;
                }
                char v23 = *(char *)&g71; // 0x2454c
                int32_t result2 = v23 == 0 ? g194 : v23;
                if (v23 == 0) {
                    // 0x23cbc
                    return result2;
                }
                char v24 = *(char *)&g70; // 0x24578
                if ((v24 | *(char *)&g179) == 0 == g28 < (char *)7) {
                    // 0x23cbc
                    return result2;
                }
                int32_t v25 = *(int32_t *)(a1 + 632); // 0x24598
                int32_t v26 = *(int32_t *)(a1 + 612); // 0x245a0
                snprintf((char *)&option_value2, 2048, "Pool %d confirmed mining.subscribe with extranonce1 %s extran2size %d", v25, (char *)v26, v25);
                function_1ccec(7, &option_value2, 0);
                return result2;
            }
            goto lab_0x242f4;
        }
    } else {
        // 0x24210
        if (*(char *)&g71 == 0) {
            // 0x242a0
            function_20258(a1, (int32_t)&g306, (int32_t)&g306);
            return 0;
        }
        char v27 = *(char *)&g70; // 0x24240
        v12 = 1;
        if ((v27 | *(char *)&g179) != 0 || g28 > (char *)6) {
            // 0x242bc
            option_value2 = 0x6c696146;
            function_1ccec(7, &option_value2, 0);
            v18 = (int32_t)&g71;
            goto lab_0x242f4;
        } else {
            goto lab_0x24264;
        }
    }
  lab_0x24328:
    // 0x24328
    option_value2 = 0x74696e49;
    function_1ccec(7, &option_value2, 0);
    v14 = v15;
    goto lab_0x24298;
  lab_0x24298:
    // 0x24298
    if (v14 == 0) {
        // 0x23cbc
        return 0;
    }
    // 0x242a0
    function_20258(a1, (int32_t)&g306, (int32_t)&g306);
    return 0;
  lab_0x24758:
    // 0x24758
    if (function_1dc9c(a1, sock_fd, v28) == 0) {
        goto lab_0x23cac;
    } else {
        goto lab_0x240f0;
    }
  lab_0x24610:
    // 0x24610
    option_value2 = 261;
    if (*(char *)&g71 == 0) {
        goto lab_0x246a0;
    } else {
        // 0x24634
        if (*(char *)&g179 == 0) {
            // 0x24648
            if (*(char *)&g70 == 0 == g28 < (char *)7) {
                goto lab_0x246a0;
            } else {
                goto lab_0x24670;
            }
        } else {
            goto lab_0x24670;
        }
    }
  lab_0x245f0:
    // 0x245f0
    if (function_236b8(a1, sock_fd, v29) == 0) {
        goto lab_0x23cac;
    } else {
        goto lab_0x240f0;
    }
  lab_0x247c8:;
    int32_t v30 = *(int32_t *)(a1 + 608); // 0x247c8
    int32_t v31 = *(int32_t *)(a1 + 604); // 0x247d0
    snprintf((char *)&str, 2048, "Unsupported proxy type for %s:%s", (char *)v31, (char *)v30);
    function_1ccec(4, &str, 0);
    goto lab_0x23cac;
  lab_0x246a0:
    // 0x246a0
    send(sock_fd, &option_value2, 3, 0);
    if (recv(sock_fd, &str, 1, 0) == -1) {
        goto lab_0x246dc;
    } else {
        // 0x246d0
        if (str % 256 == 5) {
            // 0x24834
            if (recv(sock_fd, &str, 1, 0) == -1) {
                goto lab_0x246dc;
            } else {
                // 0x24850
                if ((char)str == 0) {
                    int32_t str2 = *(int32_t *)(a1 + 600); // 0x24860
                    option_value2 = 0x3000105;
                    uint32_t len2 = strlen((char *)str2); // 0x24874
                    int32_t v32 = len2 < 255 ? len2 : 255;
                    int32_t v33; // bp-10275, 0x23974
                    function_2220c((int32_t)&v33, (int32_t *)str2, v32, (int32_t)"util.c", (int32_t)"socks5_negotiate", 2879);
                    int32_t str_as_l = strtol((char *)*(int32_t *)(a1 + 584), NULL, 10); // 0x248bc
                    int32_t v34 = v32 + v19; // 0x248c0
                    int32_t v35 = __asm_ubfx(str_as_l, 8, 8); // 0x248c8
                    *(char *)(v34 - 2042) = (char)str_as_l;
                    *(char *)(v34 - 2043) = (char)v35;
                    send(sock_fd, &option_value2, v32 + 7, 0);
                    if (recv(sock_fd, &str, 1, 0) == -1) {
                        goto lab_0x24910;
                    } else {
                        // 0x24904
                        if (str % 256 == 5) {
                            // 0x24970
                            if (recv(sock_fd, &str, 1, 0) == -1) {
                                goto lab_0x24910;
                            } else {
                                // 0x2498c
                                if (str % 256 == 0) {
                                    // 0x24998
                                    recv(sock_fd, &str, 1, 0);
                                    if (recv(sock_fd, &str, 1, 0) == -1) {
                                        goto lab_0x24910;
                                    } else {
                                        // 0x249c8
                                        int32_t v36; // 0x249c8
                                        switch ((char)v36) {
                                            case 1: {
                                                int32_t v37 = 4;
                                                recv(sock_fd, &str, 1, 0);
                                                int32_t v38 = v37 - 1; // 0x2404c
                                                while (v37 != 1) {
                                                    // 0x24034
                                                    v37 = v38;
                                                    recv(sock_fd, &str, 1, 0);
                                                    v38 = v37 - 1;
                                                }
                                                goto lab_0x24050;
                                            }
                                            case 3: {
                                                int32_t v39 = recv(sock_fd, &str, 1, 0) == -1 ? -1 : str % 256;
                                                if (v39 > 0) {
                                                    int32_t v40 = 1; // 0x24a08
                                                    recv(sock_fd, &str, 1, 0);
                                                    int32_t v41 = v40; // 0x24a18
                                                    while (v40 < v39) {
                                                        // 0x24a1c
                                                        v40 = v41 + 1;
                                                        recv(sock_fd, &str, 1, 0);
                                                        v41 = v40;
                                                    }
                                                }
                                                goto lab_0x24050;
                                            }
                                            default: {
                                                goto lab_0x24910;
                                            }
                                        }
                                    }
                                } else {
                                    goto lab_0x24910;
                                }
                            }
                        } else {
                            goto lab_0x24910;
                        }
                    }
                } else {
                    goto lab_0x246dc;
                }
            }
        } else {
            goto lab_0x246dc;
        }
    }
  lab_0x242f4:
    // 0x242f4
    v12 = 1;
    if (*(char *)v18 == 0) {
        // 0x242a0
        function_20258(a1, (int32_t)&g306, (int32_t)&g306);
        return 0;
    }
    goto lab_0x24264;
  lab_0x2430c:
    // 0x2430c
    v15 = 0;
    if (g28 < (char *)7 | *(char *)v42 == 0) {
        // 0x23cbc
        return 0;
    }
    goto lab_0x24328;
  lab_0x246dc:;
    char v43 = *(char *)&g70; // 0x246f8
    v42 = (int32_t)&g71;
    if ((v43 | *(char *)&g179) == 0 == g28 < (char *)4) {
        goto lab_0x2430c;
    } else {
        goto lab_0x24728;
    }
  lab_0x24670:;
    int32_t v44 = *(int32_t *)(a1 + 608); // 0x24670
    int32_t v45 = *(int32_t *)(a1 + 604); // 0x24678
    snprintf((char *)&str, 2048, "Attempting to negotiate with %s:%s SOCKS5 proxy", (char *)v45, (char *)v44);
    function_1ccec(7, &str, 0);
    goto lab_0x246a0;
  lab_0x24728:;
    int32_t v46 = *(int32_t *)(a1 + 608);
    int32_t v47 = *(int32_t *)(a1 + 604);
    snprintf((char *)&str, 2048, "Bad response from %s:%s SOCKS5 server", (char *)v47, (char *)v46);
    function_1ccec(4, &str, 0);
    goto lab_0x23cac;
  lab_0x24910:;
    char v48 = *(char *)&g70; // 0x2492c
    if ((v48 | *(char *)&g179) == 0 == g28 < (char *)4) {
        goto lab_0x23cac;
    } else {
        goto lab_0x24728;
    }
  lab_0x24050:
    // 0x24050
    recv(sock_fd, &str, 1, 0);
    recv(sock_fd, &str, 1, 0);
    if (*(char *)&g71 != 0) {
        char v49 = *(char *)&g70; // 0x240a0
        if ((v49 | *(char *)&g179) == 0 != g28 < (char *)7) {
            int32_t v50 = *(int32_t *)(a1 + 608); // 0x240c0
            int32_t v51 = *(int32_t *)(a1 + 604); // 0x240cc
            snprintf((char *)&str, 2048, "Success negotiating with %s:%s SOCKS5 proxy", (char *)v51, (char *)v50);
            function_1ccec(7, &str, 0);
        }
    }
    goto lab_0x240f0;
}

// Address range: 0x24a2c - 0x24ab8
int32_t function_24a2c(int32_t a1) {
    // 0x24a2c
    if (*(char *)(a1 + 641) != 0) {
        // 0x24a9c
        int32_t v1; // 0x24a2c
        function_20258(a1, v1, v1);
    }
    // 0x24a40
    if (function_23974(a1) == 0 || function_20cfc(a1) == 0) {
        // 0x24a60
        function_306e8(a1);
        // 0x24a6c
        return 0;
    }
    // 0x24a74
    if (*(char *)(a1 + 580) != 0) {
        // 0x24aa4
        if (function_25a7c(a1) == 0) {
            // 0x24a60
            function_306e8(a1);
            // 0x24a6c
            return 0;
        }
    }
    int32_t result = function_25e74(a1); // 0x24a84
    if (result == 0) {
        // 0x24a60
        function_306e8(a1);
        // 0x24a6c
        return 0;
    }
    // 0x24a90
    function_2e888(a1);
    // 0x24a6c
    return result;
}

// Address range: 0x24ab8 - 0x24e88
int32_t function_24ab8(int32_t a1, int32_t a2) {
    // 0x24ab8
    int32_t str5; // bp-2336, 0x24ab8
    memset(&str5, 0, 255);
    function_47820(function_47674(a2, 0));
    int32_t * v1 = (int32_t *)(a1 + 600);
    int32_t v2 = *v1;
    int32_t str2; // bp-2080, 0x24ab8
    if (v2 != 0) {
        char * str = (char *)v2;
        char * found_char_pos = strchr(str, 46); // 0x24b0c
        if (found_char_pos == NULL) {
            char v3 = *(char *)&g70; // 0x24cb8
            if ((v3 | *(char *)&g179) == 0 == g28 < (char *)3) {
                // 0x24d08
                return 0;
            }
            // 0x24cec
            snprintf((char *)&str2, 2048, (char *)(int32_t)"Denied stratum reconnect request for pool without domain '%s'", str);
            function_1ccec(3, &str2, 0);
            // 0x24d08
            return 0;
        }
        char * str3 = (char *)v2;
        char * found_char_pos2 = strchr(str3, 46); // 0x24b20
        if (found_char_pos2 == NULL) {
            char v4 = *(char *)&g70; // 0x24da0
            if ((v4 | *(char *)&g179) == 0 == g28 < (char *)3) {
                // 0x24d08
                return 0;
            }
            // 0x24cec
            snprintf((char *)&str2, 2048, (char *)(int32_t)"Denied stratum reconnect request to url without domain '%s'", str3);
            function_1ccec(3, &str2, 0);
            // 0x24d08
            return 0;
        }
        // 0x24b2c
        if (strcmp(found_char_pos, found_char_pos2) != 0) {
            char v5 = *(char *)&g70; // 0x24d4c
            if ((v5 | *(char *)&g179) == 0 == g28 < (char *)3) {
                // 0x24d08
                return 0;
            }
            // 0x24cec
            snprintf((char *)&str2, 2048, (char *)(int32_t)"Denied stratum reconnect request to non-matching domain url '%s'", str);
            function_1ccec(3, &str2, 0);
            // 0x24d08
            return 0;
        }
    }
    int32_t v6 = function_47a7c(function_47674(a2, 1)); // 0x24b48
    int32_t v7; // 0x24ab8
    int32_t v8; // 0x24ab8
    if (v6 == 0) {
        // 0x24d14
        int32_t v9; // bp-2360, 0x24ab8
        int32_t v10 = &v9; // 0x24acc
        int32_t v11 = function_47820(function_47674(a2, 1)); // 0x24d20
        v8 = v10;
        v7 = v11;
        if (v11 == 0) {
            v8 = v10;
            v7 = *(int32_t *)(a1 + 584);
        }
    } else {
        // 0x24b54
        int32_t str4; // bp-2608, 0x24ab8
        sprintf((char *)&str4, "%d", v6);
        int32_t v12; // bp-2624, 0x24ab8
        v8 = &v12;
        v7 = &str4;
    }
    int32_t * v13 = (int32_t *)v8; // 0x24b80
    *v13 = v7;
    snprintf((char *)&str5, 254, "%s:%s", (char *)v2);
    int32_t v14 = &str5; // 0x24b9c
    int32_t v15; // bp-2340, 0x24ab8
    int32_t v16; // bp-2344, 0x24ab8
    int32_t v17 = function_1f930(v14, (int32_t)&v16, (int32_t)&v15); // 0x24ba0
    if (v17 == 0) {
        // 0x24d08
        return 0;
    }
    char v18 = *(char *)&g70; // 0x24bc8
    if ((v18 | *(char *)&g179) == 0 != g28 < (char *)4) {
        // 0x24be8
        *v13 = v14;
        int32_t v19; // bp-2068, 0x24ab8
        snprintf((char *)&str2, 2048, "Stratum reconnect requested from pool %d to %s", (int32_t)&v19);
        function_1ccec(4, &str2, 0);
    }
    // 0x24c24
    function_2ff3c(a1);
    int32_t * mutex = (int32_t *)(a1 + 704); // 0x24c34
    if (pthread_mutex_lock(mutex) != 0) {
        int32_t v20 = *__errno_location(); // 0x24de4
        *v13 = (int32_t)"util.c";
        *(int32_t *)(v8 + 4) = (int32_t)"parse_reconnect";
        *(int32_t *)(v8 + 8) = 2452;
        snprintf((char *)&str2, 2048, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", v20);
        function_1ccec(3, &str2, 1);
        function_3aadc(1);
        // UNREACHABLE
    }
    // 0x24c40
    function_1e150(a1);
    *(int32_t *)(a1 + 576) = v16;
    *v1 = v16;
    free((int32_t *)*v1);
    int32_t * v21 = (int32_t *)(a1 + 584); // 0x24c60
    *v21 = v15;
    free((int32_t *)*v21);
    if (pthread_mutex_unlock(mutex) == 0) {
        // 0x24c7c
        function_1da28();
        return function_24a2c(a1);
    }
    int32_t v22 = *__errno_location(); // 0x24e3c
    *v13 = (int32_t)"util.c";
    *(int32_t *)(v8 + 4) = (int32_t)"parse_reconnect";
    *(int32_t *)(v8 + 8) = 2461;
    snprintf((char *)&str2, 2048, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", v22);
    function_1ccec(3, &str2, 1);
    function_3aadc(1);
    // UNREACHABLE
}

// Address range: 0x24e8c - 0x25a60
int32_t function_24e8c(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x24e8c
    float64_t v1; // 0x24e8c
    float64_t v2 = __asm_vpush(v1, v1); // 0x24e94
    int32_t v3; // bp-8484, 0x24e8c
    int32_t v4 = function_46448((int32_t *)a2, 0, &v3); // 0x24eac
    char * str; // bp-8232, 0x24e8c
    if (v4 == 0) {
        // 0x25024
        if (*(char *)&g179 == 0) {
            // 0x25038
            if (*(char *)&g70 == 0 == g28 < (char *)6) {
                // 0x25010
                __asm_vpop_11(v2, v2);
                return 0;
            }
        }
        // 0x25060
        int32_t v5; // bp-8392, 0x24e8c
        snprintf((char *)&str, 2048, "JSON decode failed(%d): %s", v3, &v5);
        function_1ccec(6, (int32_t *)&str, 0);
        // 0x25010
        __asm_vpop_11(v2, v2);
        return 0;
    }
    int32_t v6 = &v3; // 0x24ea4
    int32_t v7 = function_472ec(v4, "method"); // 0x24ec0
    int32_t v8 = 0; // 0x24ec8
    int32_t v9 = (int32_t)"method"; // 0x24ec8
    int32_t v10 = v6; // 0x24ec8
    int32_t result = 0; // 0x24ec8
    int32_t v11; // 0x24e8c
    int32_t v12; // 0x24eec
    if (v7 == 0) {
        goto lab_0x24fe0;
    } else {
        int32_t v13 = function_472ec(v4, "error"); // 0x24ed8
        v12 = function_472ec(v4, "params");
        v11 = a4;
        if (v13 == 0) {
            goto lab_0x24f08;
        } else {
            // 0x24efc
            v11 = 7;
            if (*(int32_t *)v13 == 7) {
                goto lab_0x24f08;
            } else {
                int32_t v14 = function_44264(v13, 3); // 0x250a0
                char v15 = *(char *)&g70; // 0x250c4
                int32_t v16 = 3; // 0x250b8
                int32_t v17 = v6; // 0x250b8
                if ((v15 | *(char *)&g179) == 0 != g28 < (char *)6) {
                    // 0x250d0
                    snprintf((char *)&str, 2048, "JSON-RPC method decode failed: %s", (char *)v14);
                    function_1ccec(6, (int32_t *)&str, 0);
                    v16 = (int32_t)&str;
                    v17 = 0;
                }
                // 0x250f8
                free((int32_t *)v14);
                v8 = &g306;
                v9 = v16;
                v10 = v17;
                result = 0;
                goto lab_0x24fe0;
            }
        }
    }
  lab_0x24fe0:;
    int32_t v18 = v4 + 4; // 0x24fe0
    int32_t * v19 = (int32_t *)v18; // 0x24fe0
    if (*v19 == -1) {
        // 0x25010
        __asm_vpop_11(v2, v2);
        return result;
    }
    // 0x24fec
    __asm_dmb(v8, v9, v10, v18);
    int32_t v20 = *v19;
    int32_t v21 = v20 - 1; // 0x24ff8
    while (__asm_strex(v21, v20) != 0) {
        // 0x24ff4
        v20 = *v19;
        v21 = v20 - 1;
    }
    // 0x25008
    if (v21 == 0) {
        // 0x25108
        function_47c24(v4);
    }
    // 0x25010
    __asm_vpop_11(v2, v2);
    return result;
  lab_0x24f08:;
    int32_t v22 = function_47820(v7); // 0x24f0c
    v8 = 0;
    v9 = (int32_t)"params";
    v10 = v6;
    result = 0;
    int32_t v23; // 0x24e8c
    int32_t v24; // 0x24e8c
    int32_t v25; // 0x24e8c
    int32_t format; // 0x24e8c
    int32_t v26; // 0x24e8c
    int32_t v27; // 0x2530c
    if (v22 == 0) {
        goto lab_0x24fe0;
    } else {
        char * str2 = (char *)v22; // 0x24f24
        if (strncasecmp(str2, "mining.multi_version", 20) == 0) {
            // 0x24f30
            *(char *)(a1 + 644) = 1;
            char v28 = *(char *)&g70; // 0x24f54
            int32_t v29 = 1; // 0x24f48
            if ((v28 | *(char *)&g179) == 0 != g28 < (char *)6) {
                // 0x24f74
                str = (char *)0x6c6f6f50;
                function_1ccec(6, (int32_t *)&str, 0);
                v29 = 0;
            }
            int32_t v30 = function_47658(v12); // 0x24fb4
            v8 = v12;
            v9 = 0;
            v10 = v29;
            result = 1;
            if (v30 != 0) {
                int32_t v31 = a1 + 652; // 0x24e8c
                int32_t v32 = 0;
                int32_t v33 = v32 + 1; // 0x24fc4
                *(int32_t *)v31 = function_47a7c(function_47674(v12, v32));
                uint32_t v34 = function_47658(v12); // 0x24fb4
                v31 += 4;
                v8 = v12;
                v9 = v33;
                v10 = v29;
                result = 1;
                while (v33 < v34) {
                    // 0x24fcc
                    v32 = v33;
                    v33 = v32 + 1;
                    *(int32_t *)v31 = function_47a7c(function_47674(v12, v32));
                    v34 = function_47658(v12);
                    v31 += 4;
                    v8 = v12;
                    v9 = v33;
                    v10 = v29;
                    result = 1;
                }
            }
            goto lab_0x24fe0;
        } else {
            // 0x25114
            if (strncasecmp(str2, "mining.notify", 13) == 0) {
                int32_t v35 = function_22550(a1, v12, 13, v11); // 0x252dc
                v23 = 0;
                v27 = v12;
                v24 = 13;
                v25 = 0;
                if (v35 == 0) {
                    goto lab_0x252f0;
                } else {
                    *(char *)(a1 + 643) = 1;
                    v8 = v35;
                    v9 = v12;
                    v10 = 13;
                    result = v35;
                    goto lab_0x24fe0;
                }
            } else {
                // 0x25130
                if (strncasecmp(str2, "mining.set_version_mask", 23) == 0) {
                    // 0x25300
                    v27 = function_47820(function_47674(v12, 0));
                    v23 = function_1fcc8(a1, v27);
                    v24 = 23;
                    v25 = 1;
                    goto lab_0x252f0;
                } else {
                    // 0x2514c
                    if (strncasecmp(str2, "mining.set_difficulty", 21) == 0) {
                        // 0x25320
                        return function_47bb8(function_47674(v12, 0));
                    }
                    // 0x25168
                    if (strncasecmp(str2, "mining.set_extranonce", 21) == 0) {
                        int32_t str3 = function_1e2b0(); // 0x25448
                        int32_t v36 = function_1e330(str3, "parse_extranonce", 2349); // 0x25458
                        if (v36 == 0) {
                            char v37 = *(char *)&g70; // 0x25480
                            v8 = 0;
                            v9 = (int32_t)"parse_extranonce";
                            v10 = 2349;
                            result = 0;
                            if ((v37 | *(char *)&g179) == 0 != g28 < (char *)6) {
                                // 0x254a0
                                str = (char *)0x6c696146;
                                v8 = function_1ccec(6, (int32_t *)&str, 0);
                                v9 = (int32_t)&str;
                                v10 = 0;
                                result = 0;
                            }
                        } else {
                            int32_t v38 = function_47a7c(function_47674(v12, 1)); // 0x25540
                            if (v38 == 0) {
                                char v39 = *(char *)&g70; // 0x2556c
                                int32_t v40 = 1; // 0x25560
                                int32_t v41 = 2349; // 0x25560
                                if ((v39 | *(char *)&g179) == 0 != g28 < (char *)6) {
                                    // 0x2558c
                                    str = (char *)0x6c696146;
                                    function_1ccec(6, (int32_t *)&str, 0);
                                    v40 = (int32_t)&str;
                                    v41 = 0;
                                }
                                // 0x255cc
                                free((int32_t *)str3);
                                v8 = &g306;
                                v9 = v40;
                                v10 = v41;
                                result = 0;
                            } else {
                                int32_t mutex = a1 + 212; // 0x25740
                                if (pthread_mutex_lock((int32_t *)mutex) != 0) {
                                    // 0x25a50
                                    function_1e5f4("parse_extranonce", 2361);
                                    // UNREACHABLE
                                }
                                int32_t * rwlock = (int32_t *)(a1 + 236); // 0x25764
                                if (pthread_rwlock_wrlock(rwlock) != 0) {
                                    int32_t v42 = *__errno_location(); // 0x25a28
                                    snprintf((char *)&str, 2048, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", v42, "util.c", "parse_extranonce", 2361);
                                    function_1ccec(3, (int32_t *)&str, 1);
                                    function_3aadc(1);
                                    // UNREACHABLE
                                }
                                int32_t * v43 = (int32_t *)(a1 + 612); // 0x25770
                                free((int32_t *)*v43);
                                *v43 = str3;
                                uint32_t len = strlen((char *)str3); // 0x25780
                                int32_t * v44 = (int32_t *)(a1 + 616); // 0x25788
                                int32_t * v45 = (int32_t *)(a1 + 1564); // 0x2578c
                                *v45 = len / 2;
                                free((int32_t *)*v44);
                                int32_t v46 = function_1e7d4(*v45, 1, "util.c", "parse_extranonce", 2366); // 0x257b0
                                *v44 = v46;
                                if (v46 == 0) {
                                    // 0x259c4
                                    snprintf((char *)&str, 2048, "Failed to calloc pool->nonce1bin in %s %s():%d", "util.c", "parse_extranonce", 2368);
                                    function_1ccec(3, (int32_t *)&str, 1);
                                    function_3aadc(1);
                                    // UNREACHABLE
                                }
                                // 0x257c0
                                function_1ea68(v46, *v43, *v45);
                                *(int32_t *)(a1 + 632) = v38;
                                if (pthread_rwlock_unlock(rwlock) != 0) {
                                    int32_t v47 = *__errno_location(); // 0x2599c
                                    snprintf((char *)&str, 2048, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", v47, "util.c", "parse_extranonce", 2371);
                                    function_1ccec(3, (int32_t *)&str, 1);
                                    function_3aadc(1);
                                    // UNREACHABLE
                                }
                                // 0x257e8
                                function_1e578(mutex, "parse_extranonce", 2371);
                                int32_t v48 = function_1da28(); // 0x25804
                                char v49 = *(char *)&g70; // 0x25824
                                v8 = v48;
                                v9 = (int32_t)"parse_extranonce";
                                v10 = 2371;
                                result = 1;
                                if ((v49 | *(char *)&g179) == 0 != g28 < (char *)5) {
                                    // 0x25844
                                    snprintf((char *)&str, 2048, "Pool %d extranonce change requested", v48);
                                    v8 = function_1ccec(5, (int32_t *)&str, 0);
                                    v9 = (int32_t)&str;
                                    v10 = 0;
                                    result = v36;
                                }
                            }
                        }
                        goto lab_0x24fe0;
                    } else {
                        // 0x25184
                        if (strncasecmp(str2, "client.reconnect", 16) == 0) {
                            int32_t v50 = function_24ab8(a1, v12); // 0x254ec
                            v8 = v50;
                            v9 = v12;
                            v10 = 16;
                            result = v50;
                            goto lab_0x24fe0;
                        } else {
                            // 0x251a0
                            if (strncasecmp(str2, "client.get_version", 18) == 0) {
                                // 0x254f8
                                v8 = 0;
                                v9 = (int32_t)"id";
                                v10 = 18;
                                result = 0;
                                if (function_472ec(v4, "id") == 0) {
                                    goto lab_0x24fe0;
                                } else {
                                    // 0x25510
                                    v26 = function_47a7c(function_472ec(v4, "id"));
                                    format = (int32_t)"{\"id\": %d, \"result\": \"cgminer/1.0.0\", \"error\": null}";
                                    goto lab_0x25294;
                                }
                            } else {
                                // 0x251bc
                                if (strncasecmp(str2, "client.show_message", 19) == 0) {
                                    // 0x255dc
                                    v8 = 0;
                                    v9 = (int32_t)"client.show_message";
                                    v10 = 19;
                                    result = 0;
                                    if (v12 != 0) {
                                        // 0x255e4
                                        v8 = 0;
                                        v9 = (int32_t)"client.show_message";
                                        v10 = 19;
                                        result = 0;
                                        if (*(int32_t *)v12 == 1) {
                                            int32_t v51 = function_47820(function_47674(v12, 0)); // 0x255fc
                                            v8 = 0;
                                            v9 = 0;
                                            v10 = 19;
                                            result = 0;
                                            if (v51 != 0) {
                                                char v52 = *(char *)&g70; // 0x25624
                                                v8 = v51;
                                                v9 = 0;
                                                v10 = 19;
                                                result = 1;
                                                if ((v52 | *(char *)&g179) == 0 != g28 < (char *)5) {
                                                    int32_t v53 = (int32_t)&str; // 0x25650
                                                    snprintf((char *)&str, 2048, "Pool %d message: %s", v53);
                                                    v8 = function_1ccec(5, (int32_t *)&str, 0);
                                                    v9 = v53;
                                                    v10 = 0;
                                                    result = 1;
                                                }
                                            }
                                        }
                                    }
                                    goto lab_0x24fe0;
                                } else {
                                    int32_t v54 = strncasecmp(str2, "mining.ping", 11); // 0x251e8
                                    v8 = v54;
                                    v9 = (int32_t)"mining.ping";
                                    v10 = 11;
                                    result = 0;
                                    if (v54 == 0) {
                                        char v55 = *(char *)&g70; // 0x25210
                                        int32_t v56 = 11; // 0x25204
                                        if ((v55 | *(char *)&g179) == 0 != g28 < (char *)6) {
                                            // 0x25230
                                            snprintf((char *)&str, 2048, "Pool %d ping", (int32_t)&str);
                                            function_1ccec(6, (int32_t *)&str, 0);
                                            v56 = 0;
                                        }
                                        // 0x25258
                                        v8 = 0;
                                        v9 = (int32_t)"id";
                                        v10 = v56;
                                        result = 0;
                                        if (function_472ec(v4, "id") == 0) {
                                            goto lab_0x24fe0;
                                        } else {
                                            // 0x25274
                                            v26 = function_47a7c(function_472ec(v4, "id"));
                                            format = (int32_t)"{\"id\": %d, \"result\": \"pong\", \"error\": null}";
                                            goto lab_0x25294;
                                        }
                                    } else {
                                        goto lab_0x24fe0;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
  lab_0x252f0:
    // 0x252f0
    *(char *)(a1 + 643) = (char)v25;
    v8 = v23;
    v9 = v27;
    v10 = v24;
    result = v25;
    goto lab_0x24fe0;
  lab_0x25294:
    // 0x25294
    sprintf((char *)&str, (char *)format, v26);
    int32_t len2 = strlen((char *)&str); // 0x252a0
    int32_t v57 = function_203bc(a1, (int32_t *)&str, len2); // 0x252b0
    v8 = v57;
    v9 = (int32_t)&str;
    v10 = len2;
    result = v57;
    goto lab_0x24fe0;
}

// Address range: 0x25a68 - 0x25a7c
int32_t function_25a68(int32_t a1, int32_t a2) {
    // 0x25a68
    if (a2 == 0) {
        // 0x25a74
        return 0;
    }
    // 0x25a70
    int32_t v1; // 0x25a68
    return function_24e8c(a1, a2, v1, a2, (int32_t)&g306);
}

// Address range: 0x25a7c - 0x25e74
int32_t function_25a7c(int32_t a1) {
    int32_t v1 = g183; // 0x25a94
    g183 = v1 + 1;
    int32_t str; // bp-8216, 0x25a7c
    sprintf((char *)&str, "{\"id\": %d, \"method\": \"mining.extranonce.subscribe\", \"params\": []}", v1);
    int32_t len = strlen((char *)&str); // 0x25abc
    int32_t result2 = function_203bc(a1, &str, len); // 0x25ad0
    if (result2 == 0) {
        // 0x25bb4
        return 0;
    }
    int32_t * v2 = (int32_t *)(a1 + 588); // 0x25b0c
    int32_t v3 = function_1e1b8(*v2, 2); // 0x25b10
    int32_t v4 = v3; // 0x25b1c
    int32_t result; // 0x25a7c
    int32_t v5; // 0x25bd8
    int32_t v6; // 0x25bdc
    int32_t v7; // 0x25c0c
    if (v3 != 0) {
        int32_t v8 = function_20770(a1, 2, len); // 0x25ae0
        result = 0;
        while (v8 != 0) {
            int32_t v9 = function_24e8c(a1, v8, len, (int32_t)&g183, (int32_t)&g306); // 0x25af4
            if (v9 == 0) {
                // 0x25bd8
                int32_t v10; // bp-10516, 0x25a7c
                v5 = &v10;
                int32_t * v11 = (int32_t *)v8; // 0x25bdc
                v6 = function_46448(v11, 0, &v10);
                free(v11);
                int32_t v12 = function_472ec(v6, "result"); // 0x25bf8
                v7 = function_472ec(v6, "error");
                if (v12 == 0) {
                    goto lab_0x25cd8;
                } else {
                    // 0x25c1c
                    if (*(int32_t *)v12 == 6) {
                        goto lab_0x25cd8;
                    } else {
                        if (v7 == 0) {
                            goto lab_0x25dc4;
                        } else {
                            // 0x25c30
                            if (*(int32_t *)v7 == 7) {
                                goto lab_0x25dc4;
                            } else {
                                goto lab_0x25c3c;
                            }
                        }
                    }
                }
            }
            // 0x25b04
            free((int32_t *)v8);
            int32_t v13 = function_1e1b8(*v2, 2); // 0x25b10
            v4 = v13;
            if (v13 == 0) {
                goto lab_0x25b20;
            }
            v8 = function_20770(a1, 2, len);
            result = 0;
        }
      lab_0x25bb4:
        // 0x25bb4
        return result;
    }
  lab_0x25b20:;
    unsigned char v14 = *(char *)&g71; // 0x25b28
    if (v14 == 0) {
        // 0x25bb4
        return result2;
    }
    int32_t result3 = v14; // 0x25b28
    char * str2; // bp-10264, 0x25a7c
    if ((*(char *)&g70 | *(char *)&g179) == 0) {
        // 0x25b5c
        if (g28 <= (char *)6) {
            // 0x25bb4
            return g28 < (char *)7 ? result3 : result2;
        }
        // 0x25b74
        str2 = (char *)0x656d6954;
        function_1ccec(7, (int32_t *)&str2, 0);
        // 0x25bb4
        return result3;
    }
    // 0x25b74
    str2 = (char *)0x656d6954;
    function_1ccec(7, (int32_t *)&str2, 0);
    // 0x25bb4
    return result3;
  lab_0x25cd8:;
    int32_t v15; // 0x25a7c
    int32_t v16; // 0x25a7c
    int32_t v17; // 0x25a7c
    int32_t v18; // 0x25a7c
    if (v7 == 0) {
        int32_t * mem = malloc(17); // 0x25ce4
        int32_t v19 = (int32_t)mem; // 0x25ce4
        v15 = v19;
        v16 = (int32_t)"error";
        v17 = v5;
        v18 = v19;
        if (mem == NULL) {
            goto lab_0x25d0c;
        } else {
            // 0x25cf0
            *mem = 0x6b6e7528;
            *(int32_t *)(v19 + 4) = 0x6e776f6e;
            *(int32_t *)(v19 + 8) = 0x61657220;
            *(int32_t *)(v19 + 12) = 0x296e6f73;
            *(char *)(v19 + 16) = 0;
            v15 = 0x6b6e7528;
            v16 = 0x6e776f6e;
            v17 = 0x61657220;
            v18 = v19;
            goto lab_0x25d0c;
        }
    } else {
        goto lab_0x25c3c;
    }
  lab_0x25c3c:;
    int32_t v20 = function_1e24c(v7, 1); // 0x25c44
    int32_t v21 = v20; // 0x25c4c
    if (v20 == 0) {
        int32_t v22 = function_47820(v7); // 0x25e64
        v21 = v22;
        if (v22 == 0) {
            goto lab_0x25c80;
        } else {
            goto lab_0x25c50;
        }
    } else {
        goto lab_0x25c50;
    }
  lab_0x25d0c:;
    char v23 = *(char *)&g70; // 0x25d28
    int32_t v24 = v16; // 0x25d1c
    int32_t v25 = v17; // 0x25d1c
    if ((v23 | *(char *)&g179) == 0 == g28 < (char *)6) {
        goto lab_0x25d74;
    } else {
        // 0x25d48
        snprintf((char *)&str2, 2048, "Pool %d JSON extranonce subscribe failed: %s", v15, (char *)v18);
        function_1ccec(6, (int32_t *)&str2, 0);
        v24 = (int32_t)&str2;
        v25 = 0;
        goto lab_0x25d74;
    }
  lab_0x25c50:;
    char * str3 = (char *)v21; // 0x25c5c
    int32_t v26 = (int32_t)"Method 'subscribe' not found for service 'mining.extranonce'"; // 0x25c64
    if (strcmp(str3, "Method 'subscribe' not found for service 'mining.extranonce'") == 0) {
        goto lab_0x25c94;
    } else {
        // 0x25c68
        v26 = (int32_t)"Unrecognized request provided";
        if (strcmp(str3, "Unrecognized request provided") == 0) {
            goto lab_0x25c94;
        } else {
            goto lab_0x25c80;
        }
    }
  lab_0x25dc4:;
    char v27 = *(char *)&g70; // 0x25de0
    int32_t v28 = v7; // 0x25dd4
    int32_t v29 = (int32_t)"error"; // 0x25dd4
    int32_t v30 = v5; // 0x25dd4
    int32_t v31 = v4; // 0x25dd4
    if ((v27 | *(char *)&g179) == 0 == g28 < (char *)6) {
        goto lab_0x25d80;
    } else {
        // 0x25e00
        snprintf((char *)&str2, 2048, "Stratum extranonce subscribe for pool %d", v7);
        v28 = function_1ccec(6, (int32_t *)&str2, 0);
        v29 = (int32_t)&str2;
        v30 = 0;
        v31 = v4;
        goto lab_0x25d80;
    }
  lab_0x25d74:
    // 0x25d74
    free((int32_t *)v18);
    v28 = &g306;
    v29 = v24;
    v30 = v25;
    v31 = 0;
    goto lab_0x25d80;
  lab_0x25c80:;
    int32_t v36 = function_44264(v7, 3); // 0x25c88
    v15 = v36;
    v16 = 3;
    v17 = v5;
    v18 = v36;
    goto lab_0x25d0c;
  lab_0x25c94:;
    char v37 = *(char *)&g70; // 0x25cb0
    v28 = 0;
    v29 = v26;
    v30 = v5;
    v31 = v4;
    if ((v37 | *(char *)&g179) != 0 || g28 > (char *)5) {
        // 0x25e30
        snprintf((char *)&str2, 2048, "Cannot subscribe to mining.extranonce for pool %d", 0);
        int32_t v38 = function_1ccec(6, (int32_t *)&str2, 0); // 0x25e58
        v28 = v38;
        v29 = (int32_t)&str2;
        v30 = 0;
        int32_t v39; // 0x25a7c
        v31 = v39;
        goto lab_0x25d80;
    } else {
        goto lab_0x25d80;
    }
  lab_0x25d80:
    // 0x25d80
    result = v31;
    int32_t * v32; // 0x25d88
    if (v6 == 0) {
        goto lab_0x25bb4;
    } else {
        int32_t v33 = v6 + 4; // 0x25d88
        v32 = (int32_t *)v33;
        result = v31;
        if (*v32 == -1) {
            goto lab_0x25bb4;
        } else {
            // 0x25d94
            __asm_dmb(v28, v29, v30, v33);
            goto lab_0x25d9c;
        }
    }
  lab_0x25d9c:;
    int32_t v34 = *v32;
    int32_t v35 = v34 - 1; // 0x25da0
    if (__asm_strex(v35, v34) == 0) {
        // 0x25db0
        result = v31;
        if (v35 == 0) {
            // 0x25db8
            function_47c24(v6);
            result = v31;
            goto lab_0x25bb4;
        } else {
            goto lab_0x25bb4;
        }
    } else {
        goto lab_0x25d9c;
    }
}

// Address range: 0x25e74 - 0x26164
int32_t function_25e74(int32_t a1) {
    int32_t v1 = *(int32_t *)(a1 + 172); // 0x25e7c
    int32_t v2 = *(int32_t *)(a1 + 176); // 0x25e8c
    int32_t v3 = g183; // 0x25e94
    g183 = v3 + 1;
    int32_t str; // bp-8224, 0x25e74
    sprintf((char *)&str, "{\"id\": %d, \"method\": \"mining.authorize\", \"params\": [\"%s\", \"%s\"]}", v3, (char *)v1, (char *)v2);
    int32_t len = strlen((char *)&str); // 0x25ec0
    int32_t v4 = function_203bc(a1, &str, len); // 0x25ed4
    if (v4 == 0) {
        // 0x25f14
        return 0;
    }
    int32_t v5 = &str; // 0x25ecc
    int32_t v6 = function_20770(a1, v5, len); // 0x25efc
    if (v6 == 0) {
        // 0x25f14
        return 0;
    }
    int32_t v7 = v6;
    while (function_24e8c(a1, v7, len, v1, (int32_t)&g306) != 0) {
        // 0x25ef4
        free((int32_t *)v7);
        int32_t v8 = function_20770(a1, v7, len); // 0x25efc
        if (v8 == 0) {
            // 0x25f14
            return 0;
        }
        v7 = v8;
    }
    // 0x25f24
    int32_t v9; // bp-10524, 0x25e74
    int32_t v10 = &v9; // 0x25f24
    int32_t * v11 = (int32_t *)v7; // 0x25f2c
    int32_t v12 = function_46448(v11, 0, &v9); // 0x25f2c
    free(v11);
    int32_t v13 = function_472ec(v12, "result"); // 0x25f48
    int32_t v14 = function_472ec(v12, "error"); // 0x25f5c
    if (v13 == 0) {
        goto lab_0x26024;
    } else {
        // 0x25f68
        if (*(int32_t *)v13 == 6) {
            goto lab_0x26024;
        } else {
            if (v14 == 0) {
                goto lab_0x2608c;
            } else {
                // 0x25f7c
                if (*(int32_t *)v14 == 7) {
                    goto lab_0x2608c;
                } else {
                    goto lab_0x25f88;
                }
            }
        }
    }
  lab_0x26024:;
    int32_t v15; // 0x25e74
    int32_t v16; // 0x25e74
    int32_t v17; // 0x25e74
    int32_t v18; // 0x25e74
    if (v14 == 0) {
        int32_t * mem = malloc(17); // 0x26030
        int32_t v19 = (int32_t)mem; // 0x26030
        v15 = v19;
        v16 = (int32_t)"error";
        v17 = v10;
        v18 = v19;
        if (mem != NULL) {
            // 0x2603c
            *mem = 0x6b6e7528;
            *(int32_t *)(v19 + 4) = 0x6e776f6e;
            *(int32_t *)(v19 + 8) = 0x61657220;
            *(int32_t *)(v19 + 12) = 0x296e6f73;
            *(char *)(v19 + 16) = 0;
            v15 = 0x6b6e7528;
            v16 = 0x6e776f6e;
            v17 = 0x61657220;
            v18 = v19;
        }
        goto lab_0x25f94;
    } else {
        goto lab_0x25f88;
    }
  lab_0x25f88:;
    int32_t v20 = function_44264(v14, 3); // 0x25f8c
    v15 = v20;
    v16 = 3;
    v17 = v10;
    v18 = v20;
    goto lab_0x25f94;
  lab_0x25f94:;
    char v21 = *(char *)&g70; // 0x25fb0
    int32_t v22 = v16; // 0x25fa4
    int32_t v23 = v17; // 0x25fa4
    int32_t str2; // bp-10272, 0x25e74
    if ((v21 | *(char *)&g179) != 0 || g28 > (char *)5) {
        // 0x2605c
        snprintf((char *)&str2, 2048, "pool %d JSON stratum auth failed: %s", v15, (char *)v18);
        function_1ccec(6, &str2, 0);
        v22 = &str2;
        v23 = 0;
    }
    // 0x25fd0
    free((int32_t *)v18);
    int32_t v24 = function_20258(a1, (int32_t)&g306, (int32_t)&g306); // 0x25fdc
    int32_t v25 = v22; // 0x25fdc
    int32_t v26 = v23; // 0x25fdc
    int32_t result = 0; // 0x25fdc
    goto lab_0x25fe0;
  lab_0x2608c:;
    char v31 = *(char *)&g70; // 0x260a8
    int32_t v32 = v14; // 0x2609c
    if ((v31 | *(char *)&g179) == 0 != g28 < (char *)6) {
        // 0x260c8
        snprintf((char *)&str2, 2048, "Stratum authorisation success for pool %d", (int32_t)&str2);
        v32 = function_1ccec(6, &str2, 0);
    }
    // 0x260f0
    *(char *)&g72 = 1;
    *(char *)(a1 + 99) = 1;
    v24 = v32;
    v25 = 1;
    v26 = (int32_t)&g72;
    result = v4;
    if (g259 != 0) {
        int32_t v33 = g183; // 0x2611c
        g183 = v33 + 1;
        sprintf((char *)&str, "{\"id\": %d, \"method\": \"mining.suggest_difficulty\", \"params\": [%d]}", v33, g259);
        int32_t len2 = strlen((char *)&str); // 0x26148
        v24 = function_203bc(a1, &str, len2);
        v25 = v5;
        v26 = len2;
        result = v4;
    }
    goto lab_0x25fe0;
  lab_0x25fe0:
    // 0x25fe0
    if (v12 == 0) {
        // 0x25f14
        return result;
    }
    int32_t v27 = v12 + 4; // 0x25fe8
    int32_t * v28 = (int32_t *)v27; // 0x25fe8
    if (*v28 == -1) {
        // 0x25f14
        return result;
    }
    // 0x25ff4
    __asm_dmb(v24, v25, v26, v27);
    int32_t v29 = *v28;
    int32_t v30 = v29 - 1; // 0x26000
    while (__asm_strex(v30, v29) != 0) {
        // 0x25ffc
        v29 = *v28;
        v30 = v29 - 1;
    }
    // 0x26010
    if (v30 == 0) {
        // 0x26018
        function_47c24(v12);
    }
    // 0x25f14
    return result;
}

// Address range: 0x26164 - 0x261e0
int32_t function_26164(int32_t a1, int32_t a2, int32_t a3) {
    // 0x26164
    if (a3 < a2) {
        // 0x2619c
        return -1;
    }
    int32_t v1 = a3 - a2; // 0x2617c
    int32_t * v2 = (int32_t *)a1; // 0x26180
    *v2 = v1;
    int32_t v3 = *(int32_t *)(a3 + 4) - *(int32_t *)(a2 + 4); // 0x2618c
    int32_t * v4 = (int32_t *)(a1 + 4); // 0x26194
    *v4 = v3;
    if (v3 >= 0) {
        // 0x2619c
        return 0;
    }
    // 0x261a4
    *v2 = v1 - 1;
    *v4 = v3 + 0xf4240;
    return 0;
}

// Address range: 0x261e0 - 0x26220
int32_t function_261e0(int32_t * a1, int32_t a2) {
    int32_t result = (int32_t)a1;
    if (a2 == 1) {
        // 0x2621c
        return result;
    }
    int32_t result2 = result + a2; // 0x261f4
    int32_t v1 = result - 1; // 0x261f4
    int32_t v2 = 0;
    int32_t v3 = v2 + 1; // 0x261f8
    v1++;
    char * v4 = (char *)v1; // 0x261fc
    result2--;
    char * v5 = (char *)result2; // 0x26204
    *v4 = *v5;
    *v5 = *v4;
    while (v3 < a2 - 2 - v2) {
        // 0x261f8
        v2 = v3;
        v3 = v2 + 1;
        v1++;
        v4 = (char *)v1;
        result2--;
        v5 = (char *)result2;
        *v4 = *v5;
        *v5 = *v4;
    }
    // 0x2621c
    return result2;
}

// Address range: 0x26220 - 0x26508
int32_t function_26220(int32_t a1, char a2) {
    int32_t v1 = a2;
    g303 = a1 - 1;
    int32_t result = 1; // 0x26228
    int32_t result2 = 0; // 0x26228
    switch (a1) {
        case 1: {
            return result;
        }
        case 2: {
            // 0x26368
            return (v1 & 128) == 0 ? 1 : 2;
        }
        case 64: {
            uint32_t v2 = v1 + 252 & 252; // 0x26374
            if (v2 >= 248 != v2 != 248) {
                // 0x26380
                return (int32_t)*(char *)(v2 + (int32_t)&g17 + 2248);
            }
            // 0x26368
            return 1;
        }
        case 4: {
            int32_t v3 = v1 & 192; // 0x263a8
            result = 4;
            result2 = 3;
            switch ((char)v3) {
                case -128: {
                    return result2;
                }
                case -64: {
                    return result;
                }
                default: {
                    // 0x26368
                    return v3 == 64 ? 2 : 1;
                }
            }
        }
        case 32: {
            uint32_t v4 = v1 + 248 & 248; // 0x26404
            result = 1;
            if (v4 >= 240 != v4 != 240) {
                // 0x26410
                return (int32_t)*(char *)(v4 + (int32_t)&g17 + 2004);
            }
            // 0x26368
            return result;
        }
        case 16: {
            uint32_t v5 = v1 & 240; // 0x26330
            if (v5 == 128) {
                // 0x26368
                return 9;
            }
            if (v5 < 128) {
                // 0x26340
                if (v5 == 64) {
                    // 0x26368
                    return 5;
                }
                char v6 = v5;
                if (v5 < 64) {
                    // 0x2634c
                    result = 1;
                    result2 = 3;
                    switch (v6) {
                        case 32: {
                            return result2;
                        }
                        case 48: {
                            // 0x26368
                            return 4;
                        }
                        case 16: {
                            // 0x26368
                            return 2;
                        }
                        default: {
                            return result;
                        }
                    }
                } else {
                    // 0x26484
                    result = 1;
                    result2 = 7;
                    switch (v6) {
                        case 96: {
                            return result2;
                        }
                        case 112: {
                            // 0x26368
                            return 8;
                        }
                        case 80: {
                            // 0x26368
                            return 6;
                        }
                        default: {
                            return result;
                        }
                    }
                }
            } else {
                // 0x26438
                if (v5 == 192) {
                    // 0x26368
                    return 13;
                }
                char v7 = v5;
                if (v5 < 192) {
                    // 0x264a0
                    result = 1;
                    result2 = 11;
                    switch (v7) {
                        case -96: {
                            return result2;
                        }
                        case -80: {
                            // 0x26368
                            return 12;
                        }
                        case -112: {
                            // 0x26368
                            return 10;
                        }
                        default: {
                            return result;
                        }
                    }
                } else {
                    // 0x26444
                    result = 16;
                    result2 = 15;
                    switch (v7) {
                        case -32: {
                            return result2;
                        }
                        case -16: {
                            return result;
                        }
                        case -48: {
                            // 0x263f4
                            result2 = 14;
                            // 0x26368
                            return result2;
                        }
                        default: {
                            // 0x26368
                            return 1;
                        }
                    }
                }
            }
        }
        case 8: {
            uint32_t v8 = v1 & 224; // 0x263cc
            if (v8 == 128) {
                // 0x26368
                return 5;
            }
            char v9 = v8;
            if (v8 < 128) {
                // 0x263dc
                result = 1;
                result2 = 3;
                switch (v9) {
                    case 64: {
                        return result2;
                    }
                    case 96: {
                        // 0x26368
                        return 4;
                    }
                    case 32: {
                        // 0x26368
                        return 2;
                    }
                    default: {
                        return result;
                    }
                }
            } else {
                // 0x26464
                result = 8;
                result2 = 7;
                switch (v9) {
                    case -64: {
                        return result2;
                    }
                    case -32: {
                        return result;
                    }
                    case -96: {
                        // 0x26368
                        return 6;
                    }
                    default: {
                        // 0x26368
                        return 1;
                    }
                }
            }
        }
        default: {
            return result2;
        }
    }
}

// Address range: 0x26508 - 0x26b28
int32_t function_26508(int32_t a1, int32_t a2, int32_t a3) {
    // 0x26508
    int32_t str; // bp-3112, 0x26508
    memset(&str, 0, 1024);
    int32_t v1 = 0; // bp-3164, 0x26548
    int32_t v2 = *(int32_t *)(a1 + 128); // bp-3208, 0x26568
    int32_t v3; // bp-3176, 0x26508
    int32_t v4 = &v3; // 0x2657c
    v3 = *(int32_t *)(a1 + 64);
    int32_t v5 = *(int32_t *)(a1 + 192); // bp-3144, 0x265b4
    int32_t v6 = v4; // 0x265cc
    int32_t v7; // bp-3209, 0x26508
    int32_t v8 = &v7; // 0x265cc
    v8++;
    char * v9 = (char *)v8; // 0x265d0
    v6--;
    char * v10 = (char *)v6; // 0x265d4
    *v9 = *v10;
    *v10 = *v9;
    int32_t v11; // bp-3193, 0x26508
    while (v8 != (int32_t)&v11) {
        // 0x265d0
        v8++;
        v9 = (char *)v8;
        v6--;
        v10 = (char *)v6;
        *v9 = *v10;
        *v10 = *v9;
    }
    int32_t v12 = v4; // 0x265f0
    int32_t v13 = &v1; // 0x265f0
    v13--;
    char * v14 = (char *)v13; // 0x265f4
    char * v15 = (char *)v12; // 0x265f8
    *v15 = *v14;
    *v14 = *v15;
    v12++;
    int32_t v16; // bp-3170, 0x26508
    while (v13 != (int32_t)&v16) {
        // 0x265f4
        v13--;
        v14 = (char *)v13;
        v15 = (char *)v12;
        *v15 = *v14;
        *v14 = *v15;
        v12++;
    }
    int32_t v17 = &str; // 0x26614
    int32_t v18; // bp-3145, 0x26508
    int32_t v19 = &v18; // 0x26614
    v19++;
    char * v20 = (char *)v19; // 0x26618
    v17--;
    char * v21 = (char *)v17; // 0x2661c
    *v20 = *v21;
    *v21 = *v20;
    int32_t v22; // bp-3129, 0x26508
    while (v19 != (int32_t)&v22) {
        // 0x26618
        v19++;
        v20 = (char *)v19;
        v17--;
        v21 = (char *)v17;
        *v20 = *v21;
        *v21 = *v20;
    }
    int32_t v23 = function_1e9b4(a1, 128); // 0x26638
    int32_t v24 = function_1e9b4((int32_t)&v2, 32); // 0x2664c
    int32_t v25 = function_1e9b4(v4, 12); // 0x26660
    int32_t v26 = function_1e9b4(a2, 4); // 0x26670
    int32_t v27 = function_1e9b4(a2, 5); // 0x26680
    int32_t v28 = function_1e9b4((int32_t)&v5, 32); // 0x26690
    int32_t v29 = function_29244(a1, 32, v17, (int32_t)&g306); // 0x2669c
    int32_t * v30 = (int32_t *)(a1 + 340); // 0x266bc
    int32_t v31 = *v30; // 0x266bc
    int32_t v32 = a3 == 0 ? (int32_t)&g24 : (int32_t)&g21;
    char * v33 = (char *)v28; // 0x266d8
    char * v34 = (char *)v24; // 0x266e8
    char * v35 = (char *)v32; // 0x266ec
    char * v36 = (char *)v25; // 0x266ec
    char * v37 = (char *)v27; // 0x266ec
    sprintf((char *)&str, "%s %08x midstate %s data %s nonce %s hash %s diff %lld", v35, v31, v34, v36, v37, v33, (int64_t)v29);
    int32_t strcmp_rc = strcmp(g76, "screen"); // 0x26704
    char v38 = *(char *)&g179;
    char v39 = *(char *)&g70;
    int32_t fflush_rc3; // 0x26508
    int32_t str2; // bp-2088, 0x26508
    if (strcmp_rc == 0) {
        // 0x26718
        fflush_rc3 = 0;
        if ((v39 || v38) == 0 != g28 < (char *)3) {
            // 0x26738
            snprintf((char *)&str2, 2048, (char *)&str);
            fflush_rc3 = function_1ccec(3, &str2, 0);
        }
    } else {
        int32_t v40 = strcmp_rc; // 0x267e0
        if ((v39 || v38) == 0 != g28 < (char *)3) {
            // 0x267f8
            snprintf((char *)&str2, 2048, (char *)&str);
            v40 = function_1ccec(3, &str2, 0);
        }
        // 0x26820
        fflush_rc3 = v40;
        if (g150 != NULL) {
            int32_t v41 = *v30; // 0x26848
            sprintf((char *)&str, "%s %08x work %s midstate %s data %s nonce %s hash %s diff %lld", v35, v41, (char *)v23, v34, v36, v37, v33);
            fwrite(&str, strlen((char *)&str), 1, g150);
            fwrite((int32_t *)"\n", 1, 1, g150);
            int32_t fflush_rc = fflush(g150); // 0x268ac
            fflush_rc3 = fflush_rc;
            if (a3 != 0) {
                // 0x268bc
                int32_t fflush_rc2; // 0x26508
                if (g149 == 1) {
                    // 0x26abc
                    sprintf((char *)&str, "midstate %s data %s nonce %s hash %s", v34, v36, (char *)v26, v33);
                    fwrite(&str, strlen((char *)&str), 1, g151);
                    fwrite((int32_t *)"\n", 1, 1, g151);
                    fflush_rc2 = fflush(g151);
                } else {
                    // 0x268d0
                    fflush_rc2 = fflush_rc;
                    if ((g149 - 32 & -33) == 0) {
                        // 0x268dc
                        sprintf((char *)&str, "midstate %s data %s nonce %s hash %s", v34, v36, (char *)v26, v33);
                        int32_t v42; // 0x26508
                        int32_t v43 = function_26220(g149, *(char *)&v42); // 0x26910
                        int32_t len = strlen((char *)&str); // 0x2691c
                        int32_t * stream = (int32_t *)(4 * v43 + (int32_t)&g151); // 0x26920
                        fwrite(&str, len, 1, (struct _IO_FILE *)*stream);
                        fwrite((int32_t *)"\n", 1, 1, (struct _IO_FILE *)*stream);
                        fflush_rc2 = fflush((struct _IO_FILE *)*stream);
                    }
                }
                // 0x26954
                fflush_rc3 = fflush_rc2;
                int32_t v44 = 32; // 0x26964
                int32_t v45 = 0; // 0x26964
                if (g152 != 0) {
                    uint32_t v46 = v29;
                    int32_t v47 = v44 / 2; // 0x26984
                    int32_t v48 = (int32_t)(v44 % 2 != 0) << 32 - v46 | (int32_t)((int64_t)v46 << (int64_t)(33 - v46)); // 0x26988
                    int32_t v49 = v45; // 0x26990
                    while ((v48 || v47) != 0) {
                        int32_t v50 = v45 + 1; // 0x26978
                        v44 = v47;
                        v45 = v50;
                        v49 = 64;
                        if (v50 == 64) {
                            // break -> 0x26994
                            break;
                        }
                        v46 = v48;
                        v47 = v44 / 2;
                        v48 = (int32_t)(v44 % 2 != 0) << 32 - v46 | (int32_t)((int64_t)v46 << (int64_t)(33 - v46));
                        v49 = v45;
                    }
                    // 0x26994
                    if (*(char *)&g71 != 0) {
                        char v51 = *(char *)&g70; // 0x269c0
                        if ((v51 | *(char *)&g179) == 0 != g28 < (char *)7) {
                            // 0x269e0
                            snprintf((char *)&str2, 2048, "work diff %lld diffnum %d", 32, 32);
                            function_1ccec(7, &str2, 0);
                        }
                    }
                    // 0x26a20
                    sprintf((char *)&str, "midstate %s data %s nonce %s hash %s", v34, v36, (char *)v26, v33);
                    int32_t len2 = strlen((char *)&str); // 0x26a50
                    int32_t * stream2 = (int32_t *)(4 * v49 + (int32_t)&g153); // 0x26a54
                    fwrite(&str, len2, 1, (struct _IO_FILE *)*stream2);
                    fwrite((int32_t *)"\n", 1, 1, (struct _IO_FILE *)*stream2);
                    fflush_rc3 = fflush((struct _IO_FILE *)*stream2);
                }
            }
        }
    }
    int32_t v52 = fflush_rc3; // 0x26768
    if (v23 != 0) {
        // 0x2676c
        free((int32_t *)v23);
        v52 = &g306;
    }
    int32_t v53 = v52; // 0x26778
    if (v24 != 0) {
        // 0x2677c
        free((int32_t *)v24);
        v53 = &g306;
    }
    int32_t v54 = v53; // 0x26788
    if (v25 != 0) {
        // 0x2678c
        free((int32_t *)v25);
        v54 = &g306;
    }
    int32_t v55 = v54; // 0x2679c
    if (v26 != 0) {
        // 0x267a0
        free((int32_t *)v26);
        v55 = &g306;
    }
    int32_t v56 = v55; // 0x267ac
    if (v27 != 0) {
        // 0x267b0
        free((int32_t *)v27);
        v56 = &g306;
    }
    int32_t result = v56; // 0x267bc
    if (v28 != 0) {
        // 0x267c0
        free((int32_t *)v28);
        result = &g306;
    }
    // 0x267c8
    return result;
}

// Address range: 0x26b28 - 0x26b40
int32_t function_26b28(void) {
    // 0x26b28
    int32_t result; // 0x26b28
    if (g76 == NULL) {
        return result;
    }
    // 0x26b3c
    return function_26508(result, result, result);
}

// Address range: 0x26b40 - 0x26b7c
int32_t function_26b40(int32_t result, int32_t a2) {
    // 0x26b40
    if (g76 == NULL) {
        return result;
    }
    int32_t v1 = a2; // bp-16, 0x26b68
    int32_t v2; // 0x26b40
    return function_26508(result, (int32_t)&v1, v2);
}

// Address range: 0x26b7c - 0x26bd8
int32_t function_26b7c(int32_t a1, int32_t a2) {
    if (a2 == 0) {
        // 0x26bd0
        return 0xffff;
    }
    int32_t v1 = a1 - 1; // 0x26ba4
    v1++;
    int32_t v2 = 255 ^ (int32_t)*(char *)v1; // 0x26bac
    unsigned char v3 = *(char *)(v2 + (int32_t)&g17 + 2500); // 0x26bb8
    int32_t v4 = 255 ^ (int32_t)v3; // 0x26bbc
    int32_t v5 = (int32_t)*(char *)(v2 + (int32_t)&g17 + 2756); // 0x26bc0
    while ((int32_t)((uint32_t)(a2 + 0xffff) % 0x10000 + a1) != v1) {
        // 0x26ba8
        v1++;
        v2 = v4 ^ (int32_t)*(char *)v1;
        v3 = *(char *)(v2 + (int32_t)&g17 + 2500);
        v4 = v5 ^ (int32_t)v3;
        v5 = (int32_t)*(char *)(v2 + (int32_t)&g17 + 2756);
    }
    // 0x26bc8
    return 256 * v5 | v4;
}

// Address range: 0x26bd8 - 0x26cb0
int32_t function_26bd8(int32_t a1, uint32_t a2) {
    if (a2 == 0) {
        // 0x26c98
        return 31;
    }
    char v1 = *(char *)a1; // 0x26c18
    int32_t v2 = v1 > -1;
    bool v3 = false; // 0x26c64
    int32_t v4 = 1; // 0x26c64
    int32_t v5 = 1; // 0x26c64
    int32_t v6 = a1; // 0x26c64
    if (a2 == 1) {
        // .thread33
        return (v1 > -1 ? 26 : 30) | (int32_t)(v2 != 0);
    }
    int32_t v7 = 128; // 0x26c64
    int32_t v8 = 1;
    int32_t v9 = 1;
    int32_t v10 = v2;
    v6 += (int32_t)v3;
    v7 /= 2;
    int32_t v11 = (1 ^ v2) % 256; // 0x26c5c
    v5 = v3 ? 1 : (v5 + 1) % 256;
    v4++;
    int32_t v12 = 1 ^ (int32_t)((v7 & (int32_t)*(char *)v6) != 0);
    int32_t v13 = v12 % 256; // 0x26c40
    v3 = v5 == 8;
    while (v4 % 256 < a2) {
        int32_t v14 = v8;
        int32_t v15 = v9;
        v8 = v10;
        v9 = v11;
        v10 = v13;
        v6 += (int32_t)v3;
        v7 /= 2;
        v11 = (v14 ^ v12) % 256;
        unsigned char v16 = *(char *)v6; // 0x26c18
        v5 = v3 ? 1 : (v5 + 1) % 256;
        v4++;
        v12 = v15 ^ (int32_t)((v7 & (int32_t)v16) != 0);
        v13 = v12 % 256;
        v3 = v5 == 8;
    }
    int32_t v17 = v11 == 0 ? v9 == 0 ? 0 : 16 : v9 == 0 ? 8 : 24;
    int32_t v18 = v13 == v8 ? v17 : v17 | 4;
    return (v10 == 0 ? v18 : v18 | 2) | (int32_t)(v13 != 0);
}

// Address range: 0x26cb0 - 0x26cd8
int32_t function_26cb0(int32_t result, int32_t a2, uint32_t a3) {
    // 0x26cb0
    if (a3 < 4) {
        // 0x26cd4
        return result;
    }
    int32_t result2 = result - 4; // 0x26cbc
    int32_t v1 = a2 + 4; // 0x26cc0
    int32_t v2 = llvm_bswap_i32(*(int32_t *)a2); // 0x26cc8
    result2 += 4;
    *(int32_t *)result2 = v2;
    while (v1 != (a3 & -4) + a2) {
        int32_t v3 = v1;
        v1 = v3 + 4;
        v2 = llvm_bswap_i32(*(int32_t *)v3);
        result2 += 4;
        *(int32_t *)result2 = v2;
    }
    // 0x26cd4
    return result2;
}

// Address range: 0x26cd8 - 0x26ce8
int32_t function_26cd8(int32_t a1) {
    // 0x26cd8
    *(int32_t *)a1 = 4;
    return 0;
}

// Address range: 0x26ce8 - 0x26cf8
int32_t function_26ce8(int32_t a1) {
    // 0x26ce8
    *(int32_t *)a1 = 3;
    return 0;
}

// Address range: 0x26cf8 - 0x26d08
int32_t function_26cf8(int32_t a1) {
    // 0x26cf8
    *(int32_t *)a1 = 1;
    return 0;
}

// Address range: 0x26d08 - 0x26d24
int32_t function_26d08(int32_t a1) {
    // 0x26d08
    *(char *)a1 = 1;
    *(char *)&g70 = 1;
    return 0;
}

// Address range: 0x26d24 - 0x26d2c
int32_t function_26d24(void) {
    // 0x26d24
    return 0;
}

// Address range: 0x26d2c - 0x26d30
int32_t function_26d2c(void) {
    // 0x26d2c
    int32_t result; // 0x26d2c
    return result;
}

// Address range: 0x26d30 - 0x26d34
int32_t function_26d30(void) {
    // 0x26d30
    int32_t result; // 0x26d30
    return result;
}

// Address range: 0x26d34 - 0x26d3c
int32_t function_26d34(void) {
    // 0x26d34
    return 1;
}

// Address range: 0x26d3c - 0x26d48
int32_t function_26d3c(void) {
    // 0x26d3c
    return -1;
}

// Address range: 0x26d48 - 0x26d50
int32_t function_26d48(void) {
    // 0x26d48
    return 1;
}

// Address range: 0x26d50 - 0x26d54
int32_t function_26d50(void) {
    // 0x26d50
    int32_t result; // 0x26d50
    return result;
}

// Address range: 0x26d54 - 0x26d5c
int32_t function_26d54(void) {
    // 0x26d54
    return 0;
}

// Address range: 0x26d5c - 0x26d78
int32_t function_26d5c(int32_t result) {
    // 0x26d5c
    *(int32_t *)(result + 208) = 0;
    *(int32_t *)(result + 212) = 0;
    *(int32_t *)(result + 44) = 0;
    *(int32_t *)(result + 200) = 0;
    *(int32_t *)(result + 204) = 0;
    return result;
}

// Address range: 0x26d78 - 0x26dc0
int32_t function_26d78(int32_t format, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = a2; // bp-12, 0x26d78
    vsnprintf((char *)&g73, 512, (char *)format, (int32_t)&v1);
    function_1ccec(3, (int32_t *)&g73, 1);
    exit(1);
    // UNREACHABLE
}

// Address range: 0x26dc0 - 0x26dd4
int32_t function_26dc0(void) {
    // 0x26dc0
    int32_t v1; // 0x26dc0
    function_3cdac(v1, (int32_t *)&g74);
    return 0;
}

// Address range: 0x26dd8 - 0x26dec
int32_t function_26dd8(void) {
    // 0x26dd8
    int32_t v1; // 0x26dd8
    function_3cdac(v1, (int32_t *)&g75);
    return 0;
}

// Address range: 0x26df0 - 0x26e04
int32_t function_26df0(void) {
    // 0x26df0
    int32_t v1; // 0x26df0
    function_3cdac(v1, (int32_t *)&g76);
    return 0;
}

// Address range: 0x26e08 - 0x26e1c
int32_t function_26e08(void) {
    // 0x26e08
    int32_t v1; // 0x26e08
    function_3cdac(v1, (int32_t *)&g77);
    return 0;
}

// Address range: 0x26e20 - 0x26e34
int32_t function_26e20(void) {
    // 0x26e20
    int32_t v1; // 0x26e20
    function_3cdac(v1, (int32_t *)&g78);
    return 0;
}

// Address range: 0x26e38 - 0x26e50
int32_t function_26e38(void) {
    // 0x26e38
    int32_t v1; // 0x26e38
    function_3cdac(v1, (int32_t *)&g230);
    return 0;
}

// Address range: 0x26e50 - 0x27064
int32_t function_26e50(int32_t a1) {
    char * endptr = (char *)&g19; // bp-2068, 0x26e6c
    char * str = (char *)a1; // 0x26e74
    int32_t str_as_l = strtol(str, &endptr, 10); // 0x26e74
    char * str2; // bp-2064, 0x26e50
    if (str_as_l < 0 ? str_as_l == 0 : *(char *)&g19 == 0) {
        struct _IO_FILE * v1 = fdopen(str_as_l, "a"); // 0x26f64
        g79 = v1;
        if (v1 != NULL) {
            // 0x26ec4
            return 0;
        }
        char v2 = *(char *)&g70; // 0x26f98
        if ((v2 | *(char *)&g179) == 0 == g28 < (char *)3) {
            // 0x26ec4
            return 0;
        }
        // 0x26f2c
        snprintf((char *)&str2, 2048, (char *)(int32_t)"Failed to open fd %u for share log", str_as_l);
        function_1ccec(3, (int32_t *)&str2, 0);
        return 0;
    }
    if ((char)str_as_l == 45) {
        // 0x26e98
        if (*(char *)(a1 + 1) == 0) {
            // 0x26ea4
            g79 = g60;
            if (g60 != NULL) {
                // 0x26ec4
                return 0;
            }
            char v3 = *(char *)&g70; // 0x26fe4
            if ((v3 | *(char *)&g179) == 0 == g28 < (char *)3) {
                // 0x26ec4
                return 0;
            }
            // 0x27004
            str2 = (char *)0x6e617453;
            function_1ccec(3, (int32_t *)&str2, 0);
            return 0;
        }
    }
    struct _IO_FILE * v4 = fopen64(str, "a"); // 0x26ee0
    g79 = v4;
    if (v4 != NULL) {
        // 0x26ec4
        return 0;
    }
    char v5 = *(char *)&g70; // 0x26f14
    if ((v5 | *(char *)&g179) != 0 || g28 > (char *)2) {
        // 0x26f2c
        snprintf((char *)&str2, 2048, (char *)(int32_t)"Failed to open %s for share log", a1);
        function_1ccec(3, (int32_t *)&str2, 0);
        return 0;
    }
    // 0x26ec4
    return 0;
}

// Address range: 0x27064 - 0x2711c
int32_t function_27064(int32_t str) {
    int32_t result = function_1e74c(2 * strlen((char *)str) | 1, "cgminer.c", "json_escape", 0x1748); // 0x2708c
    int32_t v1 = function_1e74c(8, "cgminer.c", "json_escape", 0x1749); // 0x270ac
    *(int32_t *)v1 = result;
    int32_t v2 = g80; // 0x270bc
    g80 = v1;
    *(int32_t *)(v1 + 4) = v2;
    int32_t v3; // 0x27064
    char v4 = *(char *)&v3; // 0x270cc
    if (v4 == 0) {
        // 0x2710c
        *(char *)result = 0;
        return result;
    }
    // 0x270d8
    v3 = 92;
    char v5 = v4;
    int32_t v6 = result; // 0x27064
    switch (v5) {
        case 92: {
        }
        case 34: {
            *(char *)result = (char)v3;
            v6 = result + 2;
            // break -> 
            break;
        }
    }
    bool v7 = v5 == 34 | v5 == 92;
    int32_t v8 = result + 1; // 0x270e4
    int32_t v9 = v7 ? v6 : v8;
    int32_t v10 = str + 1; // 0x270f8
    *(char *)(v7 ? v8 : v6) = *(char *)str;
    char v11 = *(char *)v10; // 0x27100
    while (v11 != 0) {
        int32_t v12 = v10;
        v5 = v11;
        int32_t v13 = v9;
        v6 = v13;
        switch (v5) {
            case 92: {
            }
            case 34: {
                *(char *)v13 = (char)v3;
                v6 = v13 + 2;
                // break -> 
                break;
            }
        }
        v7 = v5 == 34 | v5 == 92;
        v8 = v13 + 1;
        v9 = v7 ? v6 : v8;
        v10 = v12 + 1;
        *(char *)(v7 ? v8 : v6) = *(char *)v12;
        v11 = *(char *)v10;
    }
    // 0x2710c
    *(char *)v9 = 0;
    return result;
}

// Address range: 0x2711c - 0x27170
int32_t function_2711c(int32_t a1) {
    // 0x2711c
    printf("%s\nBuilt with bitmain_c5 mining support.\n", (char *)&g81);
    printf("%s", g278);
    fflush(g60);
    exit(0);
    return &g306;
}

// Address range: 0x27174 - 0x271ac
int32_t function_27174(int32_t a1) {
    // 0x27174
    *(char *)(a1 + 61) = 1;
    function_1f5c4((int32_t *)(a1 + 44));
    int32_t * v1 = (int32_t *)(a1 + 36); // 0x2718c
    *(int32_t *)(*v1 + 96) = 0;
    int32_t time_val = time(NULL); // 0x271a0
    *(int32_t *)(*v1 + 240) = time_val;
    return time_val;
}

// Address range: 0x271ac - 0x271e0
int32_t function_271ac(int32_t a1) {
    // 0x271ac
    *(char *)(a1 + 61) = 0;
    function_1f5c4((int32_t *)(a1 + 44));
    int32_t * v1 = (int32_t *)(a1 + 36); // 0x271c4
    *(int32_t *)(*v1 + 96) = 0;
    int32_t time_val = time(NULL); // 0x271d4
    *(int32_t *)(*v1 + 240) = time_val;
    return time_val;
}

// Address range: 0x271e0 - 0x27404
int32_t function_271e0(uint32_t result5, uint32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x271e0
    float64_t v1; // 0x271e0
    __asm_vpush_9(v1);
    bool v2 = a2 == -0x589c0001 ? result5 < 0xde0b6b3 : a2 < 0xa763ffff;
    if (result5 == 0xde0b6b3 != (a2 == -0x589c0001) && !v2) {
        int32_t result = function_49368(result5, a2); // 0x2721c
        __asm_vmov(result);
        __asm_vldr(0);
        return result;
    }
    bool v3 = a2 == -0x5b398001 ? result5 < 0x38d7e : a2 < 0xa4c67fff;
    if (result5 == 0x38d7e != (a2 == -0x5b398001) && !v3) {
        int32_t result2 = function_49368(result5, a2); // 0x27314
        __asm_vmov(result2);
        __asm_vldr(0);
        return result2;
    }
    // 0x2733c
    if (!((a2 == -0x2b5af001 ? result5 < 232 : a2 < 0xd4a50fff)) == (result5 == 232 != (a2 == -0x2b5af001))) {
        int32_t result3 = function_49368(result5, a2); // 0x273c0
        __asm_vmov(result3);
        __asm_vldr(0);
        return result3;
    }
    if (result5 == 0 != (a2 == 0x3b9ac9ff) && a2 >= 0x3b9ac9ff) {
        int32_t result4 = function_49368(result5, a2); // 0x27370
        __asm_vmov(result4);
        __asm_vldr(0);
        return result4;
    }
    if (a2 >= 0xf423f != result5 == 0 != (a2 == 0xf423f)) {
        // 0x27280
        __asm_vmov(result5);
        return result5;
    }
    int32_t result6 = function_49368(result5, a2); // 0x273f0
    __asm_vmov(result6);
    __asm_vldr(0);
    return result6;
}

// Address range: 0x27404 - 0x2740c
int32_t function_27404(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x27404
    __asm_mrc(1, 5, a4, 8, 12, 5);
    return result;
}

// Address range: 0x27410 - 0x27418
int32_t function_27410(void) {
    // 0x27410
    int32_t result; // 0x27410
    return result;
}

// Address range: 0x27418 - 0x2744c
int32_t function_27418(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    // 0x27418
    int32_t v1; // bp+28, 0x27418
    int32_t str; // 0x27418
    int32_t chars_printed = snprintf((char *)str, str, "%d%s", a1, &v1); // 0x2743c
    float64_t v2; // 0x27418
    __asm_vpop(v2);
    return chars_printed;
}

// Address range: 0x2744c - 0x27450
int32_t function_2744c(void) {
    // 0x2744c
    return unknown_427a90();
}

// Address range: 0x27464 - 0x27498
int32_t function_27464(int32_t result2, int32_t a2, int32_t a3, int32_t a4) {
    // 0x27464
    int32_t v1; // 0x27464
    uint32_t v2 = v1;
    uint32_t v3 = v1;
    bool v4; // 0x27464
    bool v5; // 0x27464
    if (v5) {
        v4 = (1 << a3 - 1 & (int32_t)&g4) != 0;
    }
    *(char *)v1 = (char)v1;
    if (v5) {
        uint32_t v6 = (v3 >> v2 | v3 << 32 - v2) & a4; // 0x27474
        int32_t result = (v6 / 2 | 0x80000000 * v6) & result2; // 0x2747c
        *(int32_t *)v1 = result;
        if (v6 % 2 != 0) {
            // 0x27494
            return result;
        }
        function_fe6d9c8c();
        // 0x27494
        return function_fe6d9c98();
    }
    if (v4) {
        // 0x27494
        return result2;
    }
    function_fe6d9c8c();
    // 0x27494
    return function_fe6d9c98();
}

// Address range: 0x27498 - 0x27499
int32_t function_27498(void) {
    // 0x27498
    int32_t result; // 0x27498
    return result;
}

// Address range: 0x2749a - 0x274b0
int32_t function_2749a(int32_t a1, int32_t a2) {
    // 0x2749a
    unknown_462f76();
    bool v1; // 0x2749a
    int32_t v2; // 0x2749a
    if ((v1 ? v1 : (v2 & 0x20000) != 0) == !v1) {
        function_dfb2e();
    }
    // 0x274aa
    __asm_stc(0, 13, v2);
    return function_2794c();
}

// Address range: 0x274b0 - 0x27548
int32_t function_274b0(int32_t result, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x274b0
    bool v1; // 0x274b0
    int32_t v2; // 0x274b0
    if (v1) {
        // 0x27534
        __asm_vldr(0);
        int64_t v3 = *(int64_t *)(result + 184); // 0x27538
        int32_t v4 = v3; // 0x27538
        __asm_vmov_8(function_492fc(v3 >> 32, (int64_t)v4), v4);
        return (int32_t)(*(int64_t *)(v2 + 176) / 0x100000000);
    }
    // 0x274b8
    float64_t v5; // 0x274b0
    __asm_vstr(v5, *(int32_t *)(v2 + 376));
    return result;
}

// Address range: 0x2754a - 0x2759e
int32_t function_2754a(int32_t a1, int32_t a2) {
    // 0x2754a
    bool v1; // 0x2754a
    bool v2; // 0x2754a
    int32_t v3; // 0x2754a
    if (v2 == !v2) {
        *(char *)(v3 / 0x10000000 + v3) = (char)v3;
        v1 = (v3 & 0x8000000) != 0;
    }
    if (!v2) {
        function_ce5d56();
    }
    if (v2) {
        function_5e2bd6();
        function_ff662662();
    }
    bool v4 = v1; // 0x2755a
    if (v1 == !v2) {
        function_21fc76();
        *(char *)(v3 + 0x10000000 * v3) = 94;
        v4 = (v3 & 16) != 0;
    }
    // 0x2755e
    if (!v2) {
        function_c25d6a();
    }
    if (v2) {
        function_5e2bea();
        function_ff462676();
    }
    bool v5 = v4; // 0x2756e
    if (v4 == !v2) {
        *(char *)(function_21fc8a() + 0x10000000 * v3) = 114;
        v5 = (v3 & 16) != 0;
    }
    // 0x27572
    if (v2) {
        function_625d7e();
    }
    int32_t v6; // 0x2754a
    if (v2) {
        unknown_46305e();
        v6 = function_9e9d92();
    } else {
        // 0x27582
        function_262686();
        function_1062e62();
        v6 = unknown_46305e();
    }
    int32_t v7 = v6; // 0x2758e
    if (v5 == !v2) {
        v7 = function_222c12();
    }
    int32_t v8 = v7; // 0x27592
    if (v2) {
        v8 = function_1262fb2();
    }
    int32_t v9 = v8; // 0x27596
    v9 = function_16305e();
    int32_t result = v9; // 0x2759a
    if (v2) {
        result = function_46259e();
    }
    // 0x2759e
    return result;
}

// Address range: 0x275a0 - 0x275ac
int32_t function_275a0(void) {
    // 0x275a0
    int32_t v1; // 0x275a0
    int32_t result = function_493c8(v1, v1, v1, v1); // 0x275a0
    float64_t v2; // 0x275a0
    __asm_vstr(v2, *(int32_t *)(v1 + 376));
    return result;
}

// Address range: 0x275ae - 0x275ce
int32_t function_275ae(int32_t a1, int32_t a2) {
    int32_t v1 = unknown_463086(); // 0x275ae
    bool v2; // 0x275ae
    if (v2) {
        int32_t v3; // 0x275ae
        *(int32_t *)(v3 + 4) = 0x275b8;
    }
    if ((v2 || (v1 & 0x1000) != 0) == !v2) {
        function_1d60442();
    }
    if (!v2) {
        // 0x275c6
        function_1de0bda();
        function_1262c1e();
    }
    // 0x275ca
    return unknown_4630a2();
}

// Address range: 0x275d0 - 0x275d4
int32_t function_275d0(void) {
    // 0x275d0
    int32_t result; // 0x275d0
    return result;
}

// Address range: 0x275d4 - 0x275d8
int32_t function_275d4(int32_t result, int32_t a2) {
    // 0x275d4
    return result;
}

// Address range: 0x275d8 - 0x275ec
int32_t function_275d8(int32_t result, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x275d8
    int32_t v1; // 0x275d8
    *(int32_t *)(v1 + 492) = a4 + 1;
    float64_t v2; // 0x275d8
    __asm_vpop(v2);
    return result;
}

// Address range: 0x275ee - 0x275f2
int32_t function_275ee(void) {
    // 0x275ee
    return unknown_4630ca();
}

// Address range: 0x275f2 - 0x275fc
int32_t function_275f2(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x275f2
    __asm_cdp(15, 15, 15, 1, 2, 6);
    return a1 + 1;
}

// Address range: 0x275fc - 0x27608
int32_t function_275fc(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x275fc
    int32_t v1; // 0x275fc
    float64_t v2; // 0x275fc
    __asm_vstr(v2, *(int32_t *)(v1 + 464));
    *(int32_t *)(v1 + 488) = a4;
    return result;
}

// Address range: 0x27608 - 0x27618
int32_t function_27608(void) {
    // 0x27608
    __asm_vldr(0);
    return -1;
}

// Address range: 0x2761e - 0x2763a
int32_t function_2761e(int32_t a1, int32_t a2, int32_t a3) {
    // 0x2761e
    float128_t v1; // 0x2761e
    float64_t v2; // 0x2761e
    __asm_vqrdmulh_s32(v1, v2);
    int32_t v3; // 0x2761e
    return -1 - v3 & a3;
}

// Address range: 0x2763c - 0x27640
int32_t function_2763c(void) {
    // 0x2763c
    int32_t result; // 0x2763c
    return result;
}

// Address range: 0x27640 - 0x27644
int32_t function_27640(int32_t a1) {
    // 0x27640
    return function_27986();
}

// Address range: 0x27644 - 0x27648
int32_t function_27644(int32_t result) {
    // 0x27644
    return result;
}

// Address range: 0x27648 - 0x2764c
int32_t function_27648(void) {
    // 0x27648
    return function_27b68(28);
}

// Address range: 0x2764c - 0x2768c
int32_t function_2764c(int32_t a1) {
    int32_t v1; // 0x2764c
    int32_t v2 = v1 + 4; // 0x27650
    int32_t v3 = llvm_bswap_i32(*(int32_t *)v2); // 0x27654
    int32_t v4; // 0x2764c
    int32_t v5 = v4 + 4; // 0x27658
    *(int32_t *)v5 = v3;
    // 0x2764c
    int32_t v6; // bp+108, 0x2764c
    while (v5 != (int32_t)&v6) {
        // 0x27650
        v2 += 4;
        v3 = llvm_bswap_i32(*(int32_t *)v2);
        v5 += 4;
        *(int32_t *)v5 = v3;
    }
    // 0x27664
    int32_t v7; // 0x2764c
    int32_t v8; // bp+32, 0x2764c
    function_1d9c8(&v8, 80, &v7);
    int32_t v9; // 0x2764c
    return function_1d9c8(&v7, 32, (int32_t *)(v9 + 192));
}

// Address range: 0x2768c - 0x27700
int32_t function_2768c(int32_t a1) {
    int32_t v1 = a1 - 4; // 0x276a0
    int32_t v2; // bp-244, 0x2768c
    int32_t v3 = &v2; // 0x276a0
    v1 += 4;
    int32_t v4 = llvm_bswap_i32(*(int32_t *)v1); // 0x276a8
    v3 += 4;
    *(int32_t *)v3 = v4;
    int32_t v5; // bp-180, 0x2768c
    while (v3 != (int32_t)&v5) {
        // 0x276a4
        v1 += 4;
        v4 = llvm_bswap_i32(*(int32_t *)v1);
        v3 += 4;
        *(int32_t *)v3 = v4;
    }
    // 0x276b8
    int32_t v6; // bp-176, 0x2768c
    function_1d800(&v6);
    int32_t v7; // bp-240, 0x2768c
    function_1d830(&v6, (int32_t)&v7, 64);
    v2 = 2289;
    int32_t v8; // bp-40, 0x2768c
    int32_t result = function_2220c(a1 + 128, &v8, 32, (int32_t)"cgminer.c", (int32_t)"calc_midstate", 2289); // 0x276f4
    return result;
}

// Address range: 0x27704 - 0x27820
int32_t function_27704(void) {
    // 0x27704
    int32_t result; // 0x27704
    if (g188 < (char *)1) {
        // 0x27804
        return result;
    }
    // 0x2775c
    int32_t str; // bp-2080, 0x27704
    int32_t v1 = &str;
    int32_t v2 = 0; // 0x27704
    int32_t v3; // 0x27704
    int32_t v4; // 0x27704
    int32_t v5; // 0x27704
    int32_t v6; // 0x27704
    while (true) {
      lab_0x2775c_2:
        // 0x2775c
        v6 = v2;
        int32_t thread_func_arg = *(int32_t *)(g202 + 4 * v6); // 0x27760
        char * v7 = (char *)(thread_func_arg + 284); // 0x27764
        v3 = v5;
        if ((*(char *)&g82 | *v7) == 0) {
            // 0x2777c
            *v7 = 1;
            pthread_create((int32_t *)(thread_func_arg + 280), NULL, (int32_t * (*)(int32_t *))&g8, (int32_t *)thread_func_arg);
            v3 = v1;
            if (*(char *)&g71 == 0) {
                goto lab_0x2774c;
            } else {
                char v8 = *(char *)&g70; // 0x277cc
                v3 = v1;
                if ((v8 | *(char *)&g179) == 0 == g28 < (char *)7) {
                    goto lab_0x2774c;
                } else {
                    // 0x277e0
                    snprintf((char *)&str, 2048, "create test_pool_thread pool[%d]\n", v6);
                    int32_t v9 = v6 + 1; // 0x277f0
                    int32_t v10 = function_1ccec(7, &str, 0); // 0x277f4
                    v4 = v10;
                    v2 = v9;
                    result = v10;
                    if (v9 >= (int32_t)g188) {
                        // break -> 0x27804
                        break;
                    }
                    goto lab_0x2775c;
                }
            }
        } else {
            goto lab_0x2774c;
        }
    }
    // 0x27804
    return result;
  lab_0x2774c:;
    int32_t v11 = v6 + 1; // 0x27750
    v4 = v3;
    v2 = v11;
    result = v3;
    if (v11 >= (int32_t)g188) {
        return result;
    }
    goto lab_0x2775c;
  lab_0x2775c:
    // 0x2775c
    v5 = v4;
    goto lab_0x2775c_2;
}

// Address range: 0x27820 - 0x27834
int32_t function_27820(void) {
    // 0x27820
    pthread_detach(pthread_self());
    return 0;
}

// Address range: 0x27834 - 0x2794c
int32_t function_27834(int32_t a1) {
    int32_t v1 = *(int32_t *)(a1 + 36); // 0x2783c
    int32_t str; // bp-2080, 0x27834
    snprintf((char *)&str, 16, "%d/Miner", a1);
    function_21db8(&str);
    function_27174(a1);
    if (a1 == 0) {
        // 0x27940
        function_21ad4(v1, 0);
        return 0;
    }
    // 0x27884
    if (*(char *)&g71 != 0) {
        char * v2 = (char *)0x74696157; // bp-2064, 0x278d0
        function_1ccec(7, (int32_t *)&v2, 0);
    }
    // 0x278f8
    function_21f38(a1 + 16, "cgminer.c", "miner_thread", 0x2684);
    *(int32_t *)(v1 + 232) = time(NULL);
    return 0;
}

// Address range: 0x2794c - 0x27950
int32_t function_2794c(void) {
    // 0x2794c
    __asm_udf(129);
    int32_t result; // 0x2794c
    return result;
}

// Address range: 0x27952 - 0x27958
int32_t function_27952(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9) {
    // 0x27952
    int32_t result; // 0x27952
    return result;
}

// Address range: 0x27958 - 0x2796c
int32_t function_27958(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x27958
    return result;
}

// Address range: 0x27970 - 0x27984
int32_t function_27970(void) {
    // 0x27970
    pthread_detach(pthread_self());
    return 1;
}

// Address range: 0x27986 - 0x27987
int32_t function_27986(void) {
    // 0x27986
    int32_t result; // 0x27986
    return result;
}

// Address range: 0x27988 - 0x27998
int32_t function_27988(void) {
    // 0x27988
    sleep(7);
    exit(1);
    return &g306;
}

// Address range: 0x27998 - 0x279b8
int32_t function_27998(int32_t result) {
    // 0x27998
    g209++;
    *(int32_t *)result = 1;
    return result;
}

// Address range: 0x279b8 - 0x279dc
int32_t function_279b8(int32_t a1) {
    char v1 = *(char *)(a1 + 640); // 0x279b8
    if (v1 == 0) {
        // 0x279d4
        return 0;
    }
    char v2 = *(char *)(a1 + 641); // 0x279c4
    char v3 = v1; // 0x279cc
    if (v2 != 0) {
        v3 = *(char *)(a1 + 643);
    }
    return (int32_t)v3 ^ (int32_t)(v2 != 0);
}

// Address range: 0x279dc - 0x27a64
int32_t function_279dc(int32_t result) {
    int32_t * v1 = (int32_t *)(result + 156);
    int32_t v2 = *v1; // 0x279e8
    if (g188 < (char *)1) {
        // 0x27a54
        *v1 = v2 + 1;
        return result;
    }
    int32_t v3 = g202; // 0x27a08
    int32_t v4 = v2;
    int32_t v5 = *(int32_t *)v3; // 0x27a0c
    int32_t v6 = result; // 0x27a18
    int32_t v7 = v4; // 0x27a18
    int32_t v8; // 0x27a38
    if (*(char *)(v5 + 97) == 0) {
        // 0x27a1c
        v6 = result;
        v7 = v4;
        if (*(int32_t *)(v5 + 100) == 1) {
            // 0x27a2c
            v6 = result;
            v7 = v4;
            if (function_279b8(v5) == 0) {
                // 0x27a38
                v8 = *(int32_t *)(v5 + 156);
                v6 = v8 < v4 ? v5 : result;
                v7 = v8 < v4 ? v8 : v4;
            }
        }
    }
    // 0x27a48
    v3 += 4;
    int32_t result2 = v6;
    while (v3 != g202 + 4 * (int32_t)g188) {
        // 0x27a0c
        v4 = v7;
        int32_t v9 = result2;
        v5 = *(int32_t *)v3;
        v6 = v9;
        v7 = v4;
        if (*(char *)(v5 + 97) == 0) {
            // 0x27a1c
            v6 = v9;
            v7 = v4;
            if (*(int32_t *)(v5 + 100) == 1) {
                // 0x27a2c
                v6 = v9;
                v7 = v4;
                if (function_279b8(v5) == 0) {
                    // 0x27a38
                    v8 = *(int32_t *)(v5 + 156);
                    v6 = v8 < v4 ? v5 : v9;
                    v7 = v8 < v4 ? v8 : v4;
                }
            }
        }
        // 0x27a48
        v3 += 4;
        result2 = v6;
    }
    int32_t * v10 = (int32_t *)(result2 + 156);
    // 0x27a54
    *v10 = *v10 + 1;
    return result2;
}

// Address range: 0x27a64 - 0x27af0
int32_t function_27a64(int32_t a1) {
    char v1 = *(char *)&g70; // 0x27a8c
    if ((v1 | *(char *)&g179) == 0 != g28 < (char *)3) {
        // 0x27a98
        int32_t str; // bp-2056, 0x27a64
        snprintf((char *)&str, 2048, "WTF No pool %d found!", a1);
        function_1ccec(3, &str, 0);
    }
    // 0x27ac0
    return *(int32_t *)(g202 + 4 * a1);
}

// Address range: 0x27af0 - 0x27b58
int32_t function_27af0(int32_t a1) {
    // 0x27af0
    if (g188 < (char *)1) {
        // 0x27b48
        return function_27a64(a1);
    }
    int32_t result = *(int32_t *)g202; // 0x27b14
    int32_t v1 = g202; // 0x27b20
    if (*(int32_t *)(result + 4) == a1) {
        // 0x27b50
        return result;
    }
    int32_t v2 = 0; // 0x27b20
    while (v2 + 1 != (int32_t)g188) {
        // 0x27b3c
        v2++;
        // 0x27b2c
        v1 += 4;
        int32_t v3 = *(int32_t *)v1; // 0x27b2c
        int32_t result2 = v3; // 0x27b38
        if (*(int32_t *)(v3 + 4) == a1) {
            // 0x27b50
            return result2;
        }
    }
    // 0x27b48
    return function_27a64(a1);
}

// Address range: 0x27b58 - 0x27b60
int32_t function_27b58(int32_t a1, int32_t a2, int32_t a3) {
    // 0x27b58
    return function_28180(a3 & a1, a2, a3);
}

// Address range: 0x27b60 - 0x27b64
int32_t function_27b60(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x27b60
    return a4 ^ a1;
}

// Address range: 0x27b64 - 0x27b68
int32_t function_27b64(int32_t a1) {
    // 0x27b64
    return function_281ea();
}

// Address range: 0x27b68 - 0x27b6c
int32_t function_27b68(int32_t a1) {
    // 0x27b68
    return a1 + 4;
}

// Address range: 0x27b6c - 0x27bc0
int32_t function_27b6c(int32_t a1) {
    // 0x27b6c
    int32_t v1; // 0x27b6c
    int32_t * v2 = (int32_t *)(v1 + 4); // 0x27b70
    if (sscanf2((int32_t *)v1, (char *)v1, v2, v1) != 2) {
        // 0x27b7c
        return (int32_t)"Invalid time set, should be HH:MM";
    }
    uint32_t v3 = *v2; // 0x27b88
    if (v3 >= 23 == (v3 != 23)) {
        // 0x27b7c
        return (int32_t)"Invalid time set.";
    }
    uint32_t v4 = *(int32_t *)v1; // 0x27b98
    if (v4 == 59 || v4 < 59) {
        // 0x27bb0
        *(char *)(v1 - 8) = 1;
        return 0;
    }
    // 0x27b7c
    return (int32_t)"Invalid time set.";
}

// Address range: 0x27bc4 - 0x27cbc
int32_t function_27bc4(int32_t a1) {
    // 0x27bc4
    if (g83 == NULL) {
        // 0x27cb0
        g83 = __strdup((char *)a1);
    }
    int32_t v1 = g84 + 1; // 0x27be8
    g84 = v1;
    int32_t result = v1 > 10 ? (int32_t)&g11 | 0xf9e8 : (int32_t)&g73;
    if (v1 > 10) {
        // 0x27c00
        return result;
    }
    // 0x27c0c
    int32_t v2; // bp-276, 0x27bc4
    int32_t v3 = function_467a0(a1, 0, &v2); // 0x27c18
    if (v3 != 0) {
        // 0x27c24
        if (*(int32_t *)v3 == 0) {
            // 0x27c90
            *(char *)(result + 808) = 1;
            return function_27cc0(v3, 1);
        }
    }
    char * str = (char *)a1; // 0x27c38
    int32_t str2; // bp-184, 0x27bc4
    int32_t size = strlen(str) + 35 + strlen((char *)&str2); // 0x27c50
    int32_t str3 = function_1e74c(size, "cgminer.c", "load_config", 2156); // 0x27c64
    snprintf((char *)str3, size, "JSON decode of file '%s' failed\n %s", str, &str2);
    return str3;
}

// Address range: 0x27cc0 - 0x28040
int32_t function_27cc0(int32_t a1, int32_t a2) {
    // 0x27cc0
    if (g87 == 0 == (a2 != 0)) {
        g87 = 1;
    }
    // 0x27cf4
    int32_t v1; // 0x27cc0
    int32_t v2; // 0x27cc0
    char * v3; // 0x27cc0
    char * v4; // 0x27cc0
    int32_t v5; // 0x27cc0
    int32_t v6; // 0x27cc0
    int32_t * v7; // 0x27cc0
    int32_t v8; // 0x27da0
    uint32_t v9; // 0x27dac
    int32_t v10; // 0x27db0
    if (g33 != 16) {
        if ((g33 & 8) != 0) {
            // 0x28024
            __assert_fail("!(opt->type & OPT_SUBTABLE)", "cgminer.c", 1988, "parse_config");
            return &g306;
        }
        int32_t v11 = (int32_t)&g34; // 0x27cc0
        while (true) {
            int32_t v12 = v11;
            int32_t v13 = *(int32_t *)(v12 - 28); // 0x27d50
            int32_t v14; // 0x27cc0
            if (v13 == 0) {
                int32_t v15 = *(int32_t *)(v12 + 4); // 0x27d38
                v14 = v15;
                if (v15 == 16) {
                    // break -> 0x27e68
                    break;
                }
            } else {
                char * str = __strdup((char *)v13); // 0x27d5c
                char * next_token = strtok(str, "|"); // 0x27d68
                if (next_token != NULL) {
                    int32_t * v16 = (int32_t *)(v12 - 24);
                    v7 = (int32_t *)(v12 - 8);
                    v3 = next_token;
                    while (true) {
                      lab_0x27d8c:
                        // 0x27d8c
                        v4 = v3;
                        int32_t v17 = (int32_t)v4;
                        if (*(char *)(v17 + 1) == 45) {
                            // 0x27d98
                            v8 = function_472ec(a1, (char *)(v17 + 2));
                            if (v8 == 0) {
                                goto lab_0x27d78_2;
                            } else {
                                // 0x27dac
                                v9 = *v16;
                                v10 = *(int32_t *)v8;
                                if ((v9 & 6) == 0) {
                                    goto lab_0x27dcc;
                                } else {
                                    switch (v10) {
                                        case 2: {
                                            int32_t v18 = function_47820(v8); // 0x27f0c
                                            v1 = v18;
                                            if (*v16 == 4) {
                                                // 0x27f30
                                                function_3cdac(v18, (int32_t *)*v7);
                                                v1 = v18;
                                            }
                                            goto lab_0x27ebc;
                                        }
                                        case 1: {
                                            // 0x27f58
                                            v5 = 0;
                                            if (function_47658(v8) != 0) {
                                                while (true) {
                                                  lab_0x27f7c:
                                                    // 0x27f7c
                                                    v6 = v5;
                                                    int32_t v19 = function_47674(v8, v6); // 0x27f84
                                                    if (v19 == 0) {
                                                        // break -> 0x27d78
                                                        break;
                                                    }
                                                    // 0x27f90
                                                    switch (*(int32_t *)v19) {
                                                        case 2: {
                                                            int32_t v20 = function_47820(v19); // 0x27fc0
                                                            v2 = v20;
                                                            if (*v16 == 4) {
                                                                // 0x2800c
                                                                function_3cdac(v20, (int32_t *)*v7);
                                                                v2 = v20;
                                                            }
                                                            goto lab_0x27fe4;
                                                        }
                                                        case 0: {
                                                            // 0x28000
                                                            v2 = function_27cc0(v19, 0);
                                                            goto lab_0x27fe4;
                                                        }
                                                        default: {
                                                            goto lab_0x27fa4;
                                                        }
                                                    }
                                                }
                                            }
                                            goto lab_0x27d78_2;
                                        }
                                        default: {
                                            goto lab_0x27dcc;
                                        }
                                    }
                                }
                            }
                        } else {
                            goto lab_0x27d78_2;
                        }
                    }
                }
              lab_0x27e54:
                // 0x27e54
                free((int32_t *)str);
                int32_t v21 = *(int32_t *)(v12 + 4); // 0x27e5c
                v14 = v21;
                if (v21 == 16) {
                    // break -> 0x27e68
                    break;
                }
            }
            // 0x27d44
            v11 = v12 + 28;
            if ((v14 & 8) != 0) {
                // 0x28024
                __assert_fail("!(opt->type & OPT_SUBTABLE)", "cgminer.c", 1988, "parse_config");
                return &g306;
            }
        }
    }
    int32_t v22 = function_472ec(a1, "include"); // 0x27e74
    if (v22 == 0) {
        // 0x27efc
        return 0;
    }
    // 0x27e80
    if (*(int32_t *)v22 == 2) {
        // 0x27e8c
        return function_27bc4(function_47820(v22));
    }
    // 0x27efc
    return 0;
  lab_0x27de0:;
    // 0x27de0
    int32_t v23; // 0x27cc0
    int32_t v24 = v23; // 0x27de8
    int32_t v25 = v23; // 0x27de8
    if (a2 == 0) {
        // 0x27ed0
        snprintf((char *)&g86, 200, "Parsing JSON option %s: %s", v4, (char *)v25);
        return (int32_t)&g86;
    }
    goto lab_0x27dec;
  lab_0x27fa4:;
    int32_t v27 = v6 + 1; // 0x27fa4
    uint32_t v28 = function_47658(v8); // 0x27fac
    v5 = v27;
    if (v28 >= v27 != v28 != v27) {
        // break -> 0x27d78
        goto lab_0x27d78_2;
    }
    goto lab_0x27f7c;
  lab_0x27fe4:
    // 0x27fe4
    v23 = v2;
    if (v2 != 0) {
        goto lab_0x27de0;
    }
    goto lab_0x27fa4;
  lab_0x27d78_2:;
    char * next_token2 = strtok(NULL, "|"); // 0x27d80
    v3 = next_token2;
    if (next_token2 == NULL) {
        // break -> 0x27e54
        goto lab_0x27e54;
    }
    goto lab_0x27d8c;
  lab_0x27dcc:;
    int32_t v29 = v10 - 5; // 0x27dcc
    int32_t v30 = v29 != 0 == (v29 != 1) ? 0x4fa20 : v10;
    v23 = v30;
    if (v29 == 1 || v29 == 0) {
        int32_t v31 = *v7; // 0x27ea8
        v1 = v31;
        if (v9 % 2 == 0) {
            if (v30 == 5) {
                // 0x27ff8
                function_3ccc8(v31);
            } else {
                // 0x27f50
                function_3ccd8(v31);
            }
            goto lab_0x27d78_2;
        } else {
            goto lab_0x27ebc;
        }
    } else {
        goto lab_0x27de0;
    }
  lab_0x27ebc:;
    int32_t v32 = v1;
    if (v32 == 0) {
        goto lab_0x27d78_2;
    } else {
        // 0x27ec4
        v24 = v32;
        v25 = v32;
        if (a2 == 0) {
            // 0x27ed0
            snprintf((char *)&g86, 200, "Parsing JSON option %s: %s", v4, (char *)v25);
            return (int32_t)&g86;
        }
        goto lab_0x27dec;
    }
  lab_0x27dec:;
    char v26 = *(char *)&g70; // 0x27e00
    if ((v26 | *(char *)&g179) == 0 != g28 < (char *)3) {
        // 0x27e20
        int32_t str2; // bp-2088, 0x27cc0
        snprintf((char *)&str2, 2048, "Invalid config option %s: %s", v4, (char *)v24);
        function_1ccec(3, &str2, 0);
    }
    // 0x27e48
    g87 = -1;
    goto lab_0x27d78_2;
}

// Address range: 0x28048 - 0x28180
int32_t function_28048(void) {
    // 0x28048
    int32_t v1; // bp-32, 0x28048
    function_1f5c4(&v1);
    int32_t timep = v1; // bp-36, 0x28060
    int32_t time_info = (int32_t)localtime(&timep); // 0x28064
    unsigned char v2 = *(char *)&g236; // 0x28070
    if (v2 == 0) {
        uint32_t v3 = *(int32_t *)(time_info + 8); // 0x280d8
        int32_t result = 1; // 0x280ec
        if (v3 >= g214) {
            // 0x280f0
            result = v3 == g214 == *(int32_t *)(time_info + 4) < g213;
        }
        // 0x280c8
        return result;
    }
    int32_t result2 = g212; // 0x2808c
    int32_t v4 = *(int32_t *)(time_info + 4); // 0x28090
    int32_t v5 = *(int32_t *)(time_info + 8); // 0x28094
    if (g212 == 0) {
        // 0x280a0
        if (g238 > v5) {
            // 0x280c8
            return 0;
        }
        if (g237 > v4 != (g238 == v5)) {
            *(char *)&g236 = 0;
        }
        return g237 > v4 != (g238 == v5) ? (int32_t)v2 : result2;
    }
    int32_t v6 = g214; // 0x28118
    int32_t v7 = time_info; // 0x28124
    int32_t v8; // 0x28048
    if (v6 > g238) {
        v7 = function_28188(time_info, (int32_t)&g212, v8, v6);
    }
    int32_t result3 = v7; // 0x28140
    if (v6 == g238 == g213 > g237) {
        result3 = function_28188(v7, (int32_t)(v6 == g238 == g213 > g237), v8, v6);
    }
    // 0x28144
    if (g238 > v5) {
        // 0x28168
        if (v6 > v5) {
            // 0x280c8
            return result2;
        }
    } else {
        // 0x2814c
        if (g237 > v4 != (g238 == v5) || v6 > v5) {
            // 0x280c8
            return result2;
        }
    }
    // 0x280c8
    return result3;
}

// Address range: 0x28180 - 0x28184
int32_t function_28180(int32_t result, int32_t a2, int32_t a3) {
    // 0x28180
    *(char *)result = (char)a2;
    *(int32_t *)a3 = a2;
    return result;
}

// Address range: 0x28184 - 0x28188
int32_t function_28184(void) {
    // 0x28184
    int32_t result; // 0x28184
    return result;
}

// Address range: 0x28188 - 0x281d4
int32_t function_28188(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x28188
    return result;
}

// Address range: 0x281d4 - 0x281e8
int32_t function_281d4(int32_t a1, int32_t a2) {
    // 0x281d4
    return function_3cdb8(a1, a2);
}

// Address range: 0x281ea - 0x281f2
int32_t function_281ea(void) {
    // 0x281ea
    int32_t result; // 0x281ea
    __asm_vldr_14(*(int32_t *)(result + 48));
    __asm_vldr_14(-0x1cbfcffa);
    return result;
}

// Address range: 0x281f2 - 0x28274
int32_t function_281f2(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x281f2
    int32_t v1; // 0x281f2
    uint32_t v2 = v1;
    unknown_463dca();
    int32_t v3; // 0x281f2
    bool v4; // 0x281f2
    if (v4) {
        *(int32_t *)(v1 + 4) = 0x281fc;
        v3 = v1 - a2;
    }
    if (!v4) {
        function_27aa02();
    }
    if (!v4) {
        function_fe563882();
    }
    if (!v4) {
        function_1220f0e();
    }
    int32_t v5 = v4 ? v1 : v1 & 0xa08200;
    int32_t v6 = unknown_463de2(); // 0x2820a
    int32_t v7 = a4; // 0x2820e
    if (v4) {
        *(int32_t *)a4 = v5;
        *(int32_t *)(a4 + 4) = 0x28214;
        v7 = a4 - a2;
    }
    uint32_t v8 = v7;
    bool v9; // 0x281f2
    bool v10; // 0x281f2
    bool v11; // 0x281f2
    bool v12; // 0x281f2
    bool v13; // 0x281f2
    int32_t v14; // 0x281f2
    if (v4 == !v4) {
        v10 = (v6 & 4) != 0;
        v12 = false;
        v9 = (v6 & 4) != 0;
        v13 = false;
        v11 = false;
        v14 = v6;
        if ((v6 / 8 & v6) == 0) {
            goto lab_dec_label_pc_unknown;
        } else {
            goto lab_0x2821a;
        }
    } else {
        v13 = false;
        v14 = v6;
        if (v4) {
            goto lab_dec_label_pc_unknown;
        } else {
            goto lab_0x2821a;
        }
    }
  lab_dec_label_pc_unknown:
    v9 = v10;
    v13 = true;
    v11 = v12;
    v14 = function_fe562512();
    goto lab_0x2821a;
  lab_0x2821a:;
    int32_t v15 = v14;
    bool v16 = v13;
    bool v17; // 0x281f2
    bool v18; // 0x281f2
    bool v19; // 0x281f2
    int16_t v20; // 0x281f2
    if (v9 == !v16 == !v16) {
        int32_t v21 = v15 >> 6 & v15; // 0x2821e
        v20 = 0;
        v19 = v21 < 0;
        v17 = (v15 & 32) != 0;
        v18 = v21 < 0;
        if (v21 == 0) {
            goto lab_dec_label_pc_unknown_3;
        } else {
            goto lab_dec_label_pc_unknown_4;
        }
    } else {
        v20 = v16 ? v1 & 0x8800 : v5;
        v19 = v11;
        v17 = v9 == !v16;
        v18 = v11;
        if (v16) {
            goto lab_dec_label_pc_unknown_3;
        } else {
            goto lab_dec_label_pc_unknown_4;
        }
    }
  lab_dec_label_pc_unknown_3:
    *(int16_t *)v15 = v20;
    int32_t v22 = v15 - v1; // 0x28222
    int32_t v23 = v22; // 0x2822a
    int32_t v24; // 0x281f2
    int32_t v25; // 0x281f2
    if (v19) {
        goto lab_dec_label_pc_unknown_5;
    } else {
        // .thread31.thread
        __asm_sbcspl(0x28238, 160, 2);
        v25 = v22 & v1 >> 5;
        v24 = v22;
        goto lab_dec_label_pc_unknown_7;
    }
  lab_dec_label_pc_unknown_4:
    v23 = v15;
    bool v26; // 0x281f2
    bool v27; // 0x281f2
    int32_t v28; // 0x281f2
    int32_t v29; // 0x281f2
    if (v18) {
        goto lab_dec_label_pc_unknown_5;
    } else {
        // .thread31
        v27 = false;
        v29 = v15;
        v26 = v17;
        v28 = __asm_sbcspl(0x28238, 160, 2);
        goto lab_dec_label_pc_unknown_8;
    }
  lab_dec_label_pc_unknown_5:;
    int32_t v30 = v2 << 32 - v8 | v2 >> v8; // 0x2822a
    int32_t v31 = v23 & v30; // 0x2822a
    int32_t v32; // 0x281f2
    if (v31 < 0) {
        v27 = v31 == 0;
        v32 = v31;
        v29 = v23;
        v26 = (v1 & 0x20000) != 0;
        v28 = v1 / 0x40000 & a2;
        goto lab_dec_label_pc_unknown_8;
    } else {
        v25 = 0;
        v24 = v23;
        v27 = false;
        v32 = v31;
        v29 = v23;
        v26 = v30 < 0;
        v28 = __asm_sbcspl(0x28238, 160, 2);
        if (v31 == 0) {
            goto lab_dec_label_pc_unknown_7;
        } else {
            goto lab_dec_label_pc_unknown_8;
        }
    }
  lab_dec_label_pc_unknown_7:;
    int32_t v33 = v24;
    v27 = true;
    v32 = v25;
    v29 = v33;
    v26 = (v33 & 1024) != 0;
    v28 = 0x400000 * v33 & v33;
    goto lab_dec_label_pc_unknown_8;
  lab_dec_label_pc_unknown_8:;
    bool v34 = v27; // 0x2823a
    bool v35 = v26; // 0x2823a
    int32_t v36 = v28; // 0x2823a
    if (v26 == !v27) {
        int32_t v37 = v29;
        int32_t v38 = v37 >> v8 & v37; // 0x2823a
        v34 = v38 == 0;
        v35 = (v37 & 1 << v8 - 1) != 0;
        v36 = v38;
    }
    if (!v4) {
        // 0x28242
        function_2e53a();
        function_36399a();
        function_ff2238ca();
    }
    // 0x2824a
    unknown_463e22();
    if (v34) {
        *(int32_t *)v3 = v36;
        *(int32_t *)(v3 + 4) = 0x28254;
    }
    if (!v4) {
        function_27aa5a();
    }
    if (!v35) {
        function_fe5638da();
    }
    if (!v4) {
        function_1220f66();
    }
    int32_t v39 = unknown_463e3a(); // 0x28262
    if (v34) {
        *(int32_t *)v8 = v35 ? v36 : v32 & 0xa09800;
        *(int32_t *)(v8 + 4) = 0x2826c;
    }
    int32_t v40; // 0x2826e
    if (v35 == !v34) {
        if ((v39 / 8 & v39) != 0) {
            // 0x28272
            return function_28894(v39, a2);
        }
        v40 = function_fe56256a();
        // 0x28272
        return function_28894(v40, a2);
    }
    if (!v34) {
        // 0x28272
        return function_28894(v39, a2);
    }
    v40 = function_fe56256a();
    // 0x28272
    return function_28894(v40, a2);
}

// Address range: 0x28274 - 0x2827c
int32_t function_28274(uint32_t a1, int32_t a2) {
    // 0x28274
    return a1 % 0x10000 | 0x40000;
}

// Address range: 0x28284 - 0x283b0
int32_t function_28284(void) {
    // 0x28284
    char * v1; // bp-2056, 0x28284
    if (g88 != 0) {
        char v2 = *(char *)&g70; // 0x282c0
        int32_t result = (int32_t)&g73; // 0x282b4
        if ((v2 | *(char *)&g179) == 0 != g28 < (char *)3) {
            // 0x282e0
            v1 = (char *)0x666e6f63;
            result = function_1ccec(3, (int32_t *)&v1, 0);
        }
        // 0x28314
        return result;
    }
    int32_t v3 = pthread_create(&g88, NULL, (int32_t * (*)(int32_t *))0x3ba90, NULL); // 0x28330
    if (v3 == 0) {
        // 0x28314
        return 0;
    }
    char v4 = *(char *)&g70; // 0x28358
    int32_t result2 = v3; // 0x2834c
    if ((v4 | *(char *)&g179) == 0 != g28 < (char *)3) {
        // 0x28378
        v1 = (char *)0x6c696146;
        result2 = function_1ccec(3, (int32_t *)&v1, 0);
    }
    // 0x28314
    return result2;
}

// Address range: 0x283b0 - 0x28554
int32_t function_283b0(int32_t result2, int32_t a2, int32_t a3, char a4) {
    char v1 = *(char *)&g70; // 0x283e4
    char * str; // bp-2072, 0x283b0
    if ((v1 | *(char *)&g179) == 0 != g28 < (char *)4) {
        // 0x283f0
        snprintf((char *)&str, 2048, "Thread %d being disabled", a2);
        function_1ccec(4, (int32_t *)&str, 0);
    }
    int32_t v2 = *(int32_t *)(result2 + 36); // 0x2841c
    *(int32_t *)(v2 + 48) = 0;
    *(int32_t *)(v2 + 52) = 0;
    if (*(char *)&g71 != 0) {
        char v3 = *(char *)&g179; // 0x2843c
        if ((*(char *)&g70 || v3) == 0 != g28 < (char *)7) {
            // 0x2845c
            str = (char *)0x74696157;
            function_1ccec(7, (int32_t *)&str, 0);
        }
    }
    int32_t result = function_21f38(result2 + 16, "cgminer.c", "mt_disable", 0x23ef); // 0x284a8
    if ((*(char *)&g70 | *(char *)&g179) == 0) {
        // 0x2850c
        return result;
    }
    // 0x284cc
    snprintf((char *)&str, 2048, "Thread %d being re-enabled", a2);
    function_1ccec(4, (int32_t *)&str, 0);
    return result2;
}

// Address range: 0x28558 - 0x285a8
int32_t function_28558(int32_t a1) {
    char * v1 = (char *)0x62616e55; // bp-2056, 0x28574
    return function_1ccec(6, (int32_t *)&v1, 0);
}

// Address range: 0x285a8 - 0x28604
int32_t function_285a8(void) {
    int32_t result = nice(10); // 0x285b0
    if (result != 0) {
        return result;
    }
    char v1 = *(char *)&g70; // 0x285d8
    if ((v1 | *(char *)&g179) != 0 || g28 > (char *)5) {
        // 0x285e4
        return function_28558(0);
    }
    return result;
}

// Address range: 0x28604 - 0x28640
int32_t function_28604(int32_t a1) {
    // 0x28604
    pthread_detach(pthread_self());
    pthread_setcanceltype(1, PTHREAD_CANCEL_DEFERRED);
    function_21db8((int32_t *)"API");
    function_285a8();
    *(int32_t *)(a1 + 12) = 0;
    return 0;
}

// Address range: 0x28640 - 0x28688
int32_t function_28640(void) {
    // 0x28640
    g89 = 2;
    int32_t v1; // 0x28640
    int32_t v2 = function_3cec8(v1, (int32_t)&g207); // 0x28660
    int32_t result = v2; // 0x28668
    if (v2 == 0) {
        uint32_t v3 = g207; // 0x2866c
        result = v3 >= 0x270f == (v3 != 0x270f) ? (int32_t)"Value out of range" : 0;
    }
    return result;
}

// Address range: 0x28688 - 0x286b8
int32_t function_28688(int32_t a1, uint32_t a2) {
    int32_t v1 = function_3cec8(a1, a2); // 0x28690
    int32_t result = v1; // 0x28698
    if (v1 == 0) {
        // 0x2869c
        result = a2 >= 0x270f == (a2 != 0x270f) ? (int32_t)"Value out of range" : 0;
    }
    return result;
}

// Address range: 0x286b8 - 0x286ec
int32_t function_286b8(int32_t a1, int32_t a2) {
    int32_t v1 = function_3cec8(a1, a2); // 0x286c0
    int32_t result = v1; // 0x286c8
    if (v1 == 0) {
        uint32_t v2 = a2 - 1; // 0x286dc
        result = v2 >= 0xfffe == (v2 != 0xfffe) ? (int32_t)"Value out of range" : 0;
    }
    return result;
}

// Address range: 0x286ec - 0x2871c
int32_t function_286ec(int32_t a1, int32_t a2) {
    int32_t v1 = function_3cec8(a1, a2); // 0x286f4
    int32_t result = v1; // 0x286fc
    if (v1 == 0) {
        uint32_t v2 = a2 - 42; // 0x2870c
        result = v2 >= 20 == (v2 != 20) ? (int32_t)"Value out of range" : 0;
    }
    return result;
}

// Address range: 0x2871c - 0x2874c
int32_t function_2871c(int32_t a1, int32_t a2) {
    int32_t v1 = function_3cec8(a1, a2); // 0x28724
    int32_t result = v1; // 0x2872c
    if (v1 == 0) {
        uint32_t v2 = a2 - 22; // 0x2873c
        result = v2 >= 33 == (v2 != 33) ? (int32_t)"Value out of range" : 0;
    }
    return result;
}

// Address range: 0x2874c - 0x2877c
int32_t function_2874c(int32_t a1, int32_t a2) {
    int32_t v1 = function_3cec8(a1, a2); // 0x28754
    int32_t result = v1; // 0x2875c
    if (v1 == 0) {
        uint32_t v2 = a2 - 42; // 0x2876c
        result = v2 >= 43 == (v2 != 43) ? (int32_t)"Value out of range" : 0;
    }
    return result;
}

// Address range: 0x2877c - 0x287ac
int32_t function_2877c(int32_t a1, int32_t a2) {
    int32_t v1 = function_3cec8(a1, a2); // 0x28784
    int32_t result = v1; // 0x2878c
    if (v1 == 0) {
        uint32_t v2 = a2 - 22; // 0x2879c
        result = v2 >= 53 == (v2 != 53) ? (int32_t)"Value out of range" : 0;
    }
    return result;
}

// Address range: 0x287ac - 0x287dc
int32_t function_287ac(int32_t a1, int32_t a2) {
    int32_t v1 = function_3cec8(a1, a2); // 0x287b4
    int32_t result = v1; // 0x287bc
    if (v1 == 0) {
        uint32_t v2 = a2 - 32; // 0x287cc
        result = v2 >= 31 == (v2 != 31) ? (int32_t)"Value out of range" : 0;
    }
    return result;
}

// Address range: 0x287dc - 0x28808
int32_t function_287dc(int32_t a1, uint32_t a2) {
    int32_t v1 = function_3cec8(a1, a2); // 0x287e4
    int32_t result = v1; // 0x287ec
    if (v1 == 0) {
        // 0x287f0
        result = a2 >= 4 == (a2 != 4) ? (int32_t)"Value out of range" : 0;
    }
    return result;
}

// Address range: 0x28808 - 0x28834
int32_t function_28808(int32_t a1, uint32_t a2) {
    int32_t v1 = function_3cec8(a1, a2); // 0x28810
    int32_t result = v1; // 0x28818
    if (v1 == 0) {
        // 0x2881c
        result = a2 >= 200 == (a2 != 200) ? (int32_t)"Value out of range" : 0;
    }
    return result;
}

// Address range: 0x28834 - 0x28860
int32_t function_28834(int32_t a1, uint32_t a2) {
    int32_t v1 = function_3cec8(a1, a2); // 0x2883c
    int32_t result = v1; // 0x28844
    if (v1 == 0) {
        // 0x28848
        result = a2 >= 0x1e00 == (a2 != 0x1e00) ? (int32_t)"Value out of range" : 0;
    }
    return result;
}

// Address range: 0x28860 - 0x28890
int32_t function_28860(int32_t a1, int32_t a2) {
    int32_t v1 = function_3cec8(a1, a2); // 0x28868
    int32_t result = v1; // 0x28870
    if (v1 == 0) {
        uint32_t v2 = a2 - 1; // 0x28880
        result = v2 >= 254 == (v2 != 254) ? (int32_t)"Value out of range" : 0;
    }
    return result;
}

// Address range: 0x28894 - 0x28898
int32_t function_28894(int32_t result, int32_t a2) {
    // 0x28894
    return result;
}

// Address range: 0x28898 - 0x288bc
int32_t function_28898(int32_t a1) {
    // 0x28898
    int32_t v1; // 0x28898
    uint32_t v2 = v1;
    int32_t v3 = function_3cec8(v1, v1); // 0x28898
    int32_t result = v3; // 0x288a0
    if (v3 == 0) {
        // 0x288a4
        result = v2 >= 255 == (v2 != 255) ? (int32_t)"Value out of range" : 0;
    }
    return result;
}

// Address range: 0x288bc - 0x288e8
int32_t function_288bc(int32_t a1, uint32_t a2) {
    int32_t v1 = function_3cec8(a1, a2); // 0x288c4
    int32_t result = v1; // 0x288cc
    if (v1 == 0) {
        // 0x288d0
        result = a2 >= 100 == (a2 != 100) ? (int32_t)"Value out of range" : 0;
    }
    return result;
}

// Address range: 0x288e8 - 0x28918
int32_t function_288e8(int32_t a1, int32_t a2) {
    int32_t v1 = function_3cec8(a1, a2); // 0x288f0
    int32_t result = v1; // 0x288f8
    if (v1 == 0) {
        uint32_t v2 = a2 - 1; // 0x28908
        result = v2 >= 9 == (v2 != 9) ? (int32_t)"Value out of range" : 0;
    }
    return result;
}

// Address range: 0x28918 - 0x28944
int32_t function_28918(int32_t a1, uint32_t a2) {
    int32_t v1 = function_3cec8(a1, a2); // 0x28920
    int32_t result = v1; // 0x28928
    if (v1 == 0) {
        // 0x2892c
        result = a2 >= 10 == (a2 != 10) ? (int32_t)"Value out of range" : 0;
    }
    return result;
}

// Address range: 0x28944 - 0x2898c
int32_t function_28944(int32_t a1, int32_t a2, int32_t a3) {
    // 0x28944
    int32_t str; // bp-2056, 0x28944
    snprintf((char *)&str, 2048, "Free work called with NULL work from %s %s:%d", (char *)a1, (char *)a2, a3);
    return function_1ccec(3, &str, 0);
}

// Address range: 0x2898c - 0x28994
int32_t function_2898c(int32_t a1, int32_t a2, int32_t a3) {
    // 0x2898c
    return function_28cd6(a3 & a1);
}

// Address range: 0x28996 - 0x289d6
int32_t function_28996(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11) {
    // 0x28996
    int32_t v1; // 0x28996
    bool v2; // 0x28996
    if (v2 || !v2) {
        v1 = function_1063e52();
    }
    int32_t v3 = v1; // 0x2899a
    if (v2) {
        v3 = function_e4462();
    }
    int32_t v4 = v3; // 0x2899e
    if (v2 == !v2) {
        v4 = function_10a43aa();
    }
    int32_t v5 = v4; // 0x289a6
    if (v2) {
        v5 = function_639aa();
    }
    int32_t v6 = v5; // 0x289aa
    if (!v2) {
        v6 = function_26448e();
    }
    int32_t v7 = v6; // 0x289ae
    if (v2) {
        v7 = function_643da();
    }
    int32_t v8 = v7; // 0x289b2
    if (!v2) {
        v8 = function_643d2();
    }
    int32_t v9 = v8; // 0x289b6
    if (v2) {
        v9 = function_106400e();
    }
    int32_t v10 = v9; // 0x289ba
    if (!v2) {
        v10 = function_6429a();
    }
    int32_t v11 = v10; // 0x289be
    if (v2) {
        v11 = function_1e41da();
    }
    int32_t v12 = v11; // 0x289c2
    if (v2) {
        function_6428a();
        v12 = function_643ea();
    }
    int32_t result = v12; // 0x289ca
    if (v2 == !v2) {
        result = function_163fe2();
    }
    // 0x289ce
    __asm_ldc(0, 8, a1, 64);
    return result;
}

// Address range: 0x289d6 - 0x289d8
int32_t function_289d6(void) {
    // 0x289d6
    int32_t result; // 0x289d6
    return result;
}

// Address range: 0x289d8 - 0x289dc
int32_t function_289d8(void) {
    // 0x289d8
    int32_t result; // 0x289d8
    return result;
}

// Address range: 0x289dc - 0x289e4
int32_t function_289dc(void) {
    // 0x289dc
    return 1;
}

// Address range: 0x289e4 - 0x289ec
int32_t function_289e4(void) {
    // 0x289e4
    return 1;
}

// Address range: 0x289ec - 0x289f0
int32_t function_289ec(void) {
    // 0x289ec
    int32_t result; // 0x289ec
    return result;
}

// Address range: 0x289f0 - 0x289f4
int32_t function_289f0(void) {
    // 0x289f0
    int32_t result; // 0x289f0
    return result;
}

// Address range: 0x289f4 - 0x289f8
int32_t function_289f4(void) {
    // 0x289f4
    int32_t result; // 0x289f4
    return result;
}

// Address range: 0x289f8 - 0x28a60
int32_t function_289f8(void) {
    // 0x289f8
    int32_t v1; // 0x289f8
    int32_t v2 = sscanf2((int32_t *)v1, "%d:%d", &g238, (int32_t)&g237); // 0x28a10
    if (v2 != 2) {
        // 0x28a1c
        return (int32_t)"Invalid time set, should be HH:MM";
    }
    uint32_t v3 = g238; // 0x28a28
    if (v3 >= 23 == (v3 != 23)) {
        // 0x28a1c
        return (int32_t)"Invalid time set.";
    }
    uint32_t v4 = g237; // 0x28a38
    if (v4 == 59 || v4 < 59) {
        // 0x28a50
        *(char *)&g236 = 1;
        return 0;
    }
    // 0x28a1c
    return (int32_t)"Invalid time set.";
}

// Address range: 0x28a64 - 0x28afc
int32_t function_28a64(int32_t * str, int32_t size, int32_t * a3) {
    int32_t v1 = (int32_t)a3;
    int32_t v2 = *(int32_t *)(v1 + 4); // 0x28a6c
    int32_t timep = v1; // bp-28, 0x28a90
    struct tm * time_info = localtime(&timep); // 0x28a9c
    int32_t v3 = (int32_t)time_info; // 0x28a9c
    int32_t v4 = *(int32_t *)(v3 + 20); // 0x28aa8
    int32_t v5 = time_info->e0; // 0x28ab8
    int32_t v6 = *(int32_t *)(v3 + 4); // 0x28acc
    int32_t v7 = *(int32_t *)(v3 + 8); // 0x28ad4
    int32_t v8 = *(int32_t *)(v3 + 12); // 0x28adc
    int32_t v9 = *(int32_t *)(v3 + 16); // 0x28ae4
    return snprintf((char *)str, size, "[%d-%02d-%02d %02d:%02d:%02d.%03d]", v4 + 1900, v9 + 1, v8, v7, v6, v5, v2 / 1000);
}

// Address range: 0x28afc - 0x28c80
int32_t function_28afc(void) {
    int32_t v1 = 1; // 0x28b18
    int32_t result; // 0x28afc
    if (g188 >= (char *)1) {
        int32_t v2 = g202 + 4 * (int32_t)g188; // 0x28b30
        uint32_t v3 = -1;
        int32_t v4 = g202 + 4; // 0x28b34
        uint32_t v5 = *(int32_t *)(*(int32_t *)g202 + 56); // 0x28b38
        int32_t v6 = v5 == 0 | v5 >= v3 ? v3 : v5;
        while (v2 != v4) {
            int32_t v7 = v4;
            v3 = v6;
            v4 = v7 + 4;
            v5 = *(int32_t *)(*(int32_t *)v7 + 56);
            v6 = v5 == 0 | v5 >= v3 ? v3 : v5;
        }
        // 0x28b50
        v1 = 1;
        if (v6 != -1) {
            int32_t v8 = *(int32_t *)g202; // 0x28b5c
            int32_t v9 = *(int32_t *)(v8 + 56); // 0x28b60
            int32_t v10 = v6; // 0x28b68
            int32_t v11; // 0x28afc
            int32_t v12; // 0x28b80
            if (v9 != 0) {
                // 0x28b6c
                function_48d24(v9, v6, v2, v8);
                v10 = 0;
                if (v6 != 0) {
                    v12 = v6 - 1;
                    function_48d24(v9, v12, v2, v8);
                    v11 = v12;
                    v10 = 0;
                    while (v12 != 0) {
                        // 0x28b80
                        v12 = v11 - 1;
                        function_48d24(v9, v12, v2, v8);
                        v11 = v12;
                        v10 = 0;
                    }
                }
            }
            int32_t v13 = g202 + 4; // 0x28b5c
            int32_t v14 = v13; // 0x28b9c
            v1 = v10;
            while (v2 != v13) {
                int32_t v15 = v10;
                v8 = *(int32_t *)v14;
                v9 = *(int32_t *)(v8 + 56);
                v10 = v15;
                if (v9 != 0) {
                    // 0x28b6c
                    function_48d24(v9, v15, v2, v8);
                    v11 = v15;
                    v10 = 0;
                    if (v15 != 0) {
                        v12 = v11 - 1;
                        function_48d24(v9, v12, v2, v8);
                        v11 = v12;
                        v10 = 0;
                        while (v12 != 0) {
                            // 0x28b80
                            v12 = v11 - 1;
                            function_48d24(v9, v12, v2, v8);
                            v11 = v12;
                            v10 = 0;
                        }
                    }
                }
                // 0x28b98
                v13 = v14 + 4;
                v14 = v13;
                v1 = v10;
            }
        }
        int32_t v16 = g202; // 0x28ba8
        int32_t v17 = *(int32_t *)v16; // 0x28bac
        v16 += 4;
        *(int32_t *)(v17 + 64) = function_48ac8();
        int32_t v18 = function_48ac8(); // 0x28bcc
        *(int32_t *)(v17 + 60) = v18;
        result = v18;
        while (v2 != v16) {
            // 0x28bac
            v17 = *(int32_t *)v16;
            v16 += 4;
            *(int32_t *)(v17 + 64) = function_48ac8();
            v18 = function_48ac8();
            *(int32_t *)(v17 + 60) = v18;
            result = v18;
        }
    }
    // 0x28bdc
    *(int32_t *)((int32_t)&g32 + 1848) = v1;
    if (*(char *)&g71 == 0) {
        // 0x28c44
        return result;
    }
    char v19 = *(char *)&g70; // 0x28c10
    int32_t result2 = result; // 0x28c04
    if ((v19 | *(char *)&g179) != 0 || g28 > (char *)6) {
        // 0x28c1c
        int32_t str; // bp-2080, 0x28afc
        snprintf((char *)&str, 2048, "Global quota greatest common denominator set to %lu", v1);
        result2 = function_1ccec(7, &str, 0);
    }
    // 0x28c44
    return result2;
}

// Address range: 0x28c80 - 0x28ccc
int32_t function_28c80(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = function_3cec8(a1, a2); // 0x28c90
    int32_t result = v1; // 0x28c98
    if (v1 == 0) {
        // 0x28c9c
        result = !((a2 < a3 | a2 > a4)) ? 0 : (int32_t)"Value out of range";
    }
    return result;
}

// Address range: 0x28ccc - 0x28cd4
int32_t function_28ccc(int32_t a1) {
    // 0x28ccc
    int32_t v1; // 0x28ccc
    return v1 ^ a1;
}

// Address range: 0x28cd6 - 0x28cd8
int32_t function_28cd6(int32_t a1) {
    // 0x28cd6
    int32_t v1; // 0x28cd6
    return function_292f8((int32_t *)a1, (char *)v1, (char *)v1, v1);
}

// Address range: 0x28cd8 - 0x28cfc
int32_t function_28cd8(int32_t a1, uint32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x28cd8
    int32_t v1; // 0x28cd8
    int32_t result = sscanf2((int32_t *)a1, (char *)(a2 % 0x10000 | 0x40000), (int32_t *)v1, a3); // 0x28ce8
    if (result == 1) {
        // branch -> 
    }
    return result;
}

// Address range: 0x28cfc - 0x28d6c
int32_t function_28cfc(int32_t a1, int32_t a2) {
    int32_t v1 = a1 + 600; // 0x28d08
    int32_t result = function_1f930(a2, v1, a1 + 584); // 0x28d14
    if (result == 0) {
        // 0x28d40
        return 0;
    }
    char * str = (char *)a2; // 0x28d30
    if (strncasecmp(str, "stratum+tcp://", 14) != 0) {
        // 0x28d40
        return 0;
    }
    // 0x28d48
    *(int32_t *)(a1 + 164) = (int32_t)__strdup(str);
    *(char *)(a1 + 640) = 1;
    *(int32_t *)(a1 + 576) = *(int32_t *)v1;
    return result;
}

// Address range: 0x28d6c - 0x28e48
int32_t function_28d6c(int32_t a1, int32_t a2) {
    int32_t v1 = function_1faa4(a2, a1); // 0x28d7c
    int32_t v2 = function_28cfc(a1, v1); // 0x28d8c
    int32_t * v3 = (int32_t *)(a1 + 164);
    if (v2 != 0) {
        // 0x28d98
        return *v3;
    }
    // 0x28da0
    function_3cdac(v1, v3);
    char * str = (char *)v1; // 0x28dbc
    if (strncmp(str, "http://", 7) == 0) {
        // 0x28d98
        return *v3;
    }
    // 0x28dc8
    if (strncmp(str, "https://", 8) != 0) {
        int32_t str2 = function_1e74c(256, "cgminer.c", "setup_url", 1068); // 0x28df8
        *(int32_t *)str2 = 0x61727473;
        *(int32_t *)(str2 + 4) = 0x2b6d7574;
        *(int32_t *)(str2 + 8) = 0x3a706374;
        *(int16_t *)(str2 + 12) = 0x2f2f;
        *(char *)(str2 + 14) = 0;
        strncat((char *)str2, str, 242);
        function_28cfc(a1, str2);
    }
    // 0x28d98
    return *v3;
}

// Address range: 0x28e4c - 0x28ea8
int32_t function_28e4c(int32_t a1) {
    // 0x28e4c
    if (a1 == 0 || (char)a1 == 0) {
        // 0x28e60
        return (int32_t)"Invalid parameters for set temp cutoff";
    }
    char * str = (char *)a1;
    uint32_t str_as_l = strtol(str, NULL, 10); // 0x28e7c
    if (str_as_l == 200 || str_as_l < 200) {
        // 0x28e94
        g90 = str;
        return 0;
    }
    // 0x28e60
    return (int32_t)"Invalid value passed to set temp cutoff";
}

// Address range: 0x28ea8 - 0x28ee4
int32_t function_28ea8(int32_t a1) {
    // 0x28ea8
    free((int32_t *)*(int32_t *)(a1 + 288));
    free((int32_t *)*(int32_t *)(a1 + 308));
    free((int32_t *)*(int32_t *)(a1 + 328));
    free((int32_t *)*(int32_t *)(a1 + 320));
    return (int32_t)memset((int32_t *)a1, 0, 448);
}

// Address range: 0x28ee4 - 0x28ff8
int32_t function_28ee4(int32_t a1, int32_t a2, int32_t a3) {
    int32_t * v1 = (int32_t *)(a1 + 340); // 0x28ef8
    function_28ea8(a1);
    function_2220c(a1, (int32_t *)a2, 448, (int32_t)"cgminer.c", (int32_t)"_copy_work", 0x1378);
    int32_t v2 = *(int32_t *)(a2 + 288); // 0x28f28
    if (v2 != 0) {
        // 0x28f34
        *(int32_t *)(a1 + 288) = (int32_t)__strdup((char *)v2);
    }
    int32_t v3 = *(int32_t *)(a2 + 320); // 0x28f3c
    if (v3 != 0) {
        // 0x28f48
        *(int32_t *)(a1 + 320) = (int32_t)__strdup((char *)v3);
    }
    int32_t * v4 = (int32_t *)(a2 + 308); // 0x28f50
    int32_t v5 = *v4; // 0x28f50
    if (v5 == 0) {
        if (a3 != 0) {
            int32_t * v6 = (int32_t *)(a1 + 68); // 0x28fe0
            *v6 = llvm_bswap_i32(llvm_bswap_i32(*v6) + a3);
        }
    } else {
        if (a3 == 0) {
            // 0x28f64
            *(int32_t *)(a1 + 308) = (int32_t)__strdup((char *)v5);
        } else {
            int32_t * v7 = (int32_t *)(a1 + 68); // 0x28f90
            int32_t v8; // bp-28, 0x28ee4
            int32_t v9 = &v8; // 0x28f98
            *v7 = llvm_bswap_i32(llvm_bswap_i32(*v7) + a3);
            function_1ea68(v9, *v4, 4);
            v8 = llvm_bswap_i32(llvm_bswap_i32(v8) + a3);
            *(int32_t *)(a1 + 308) = function_1e9b4(v9, 4);
        }
    }
    int32_t v10 = *(int32_t *)(a2 + 328); // 0x28f6c
    int32_t result = 0; // 0x28f74
    if (v10 != 0) {
        // 0x28f78
        result = (int32_t)__strdup((char *)v10);
        *(int32_t *)(a1 + 328) = result;
    }
    // 0x28f80
    *(int32_t *)(a1 + 444) = *(int32_t *)(a2 + 444);
    return result;
}

// Address range: 0x28ffc - 0x29080
int32_t function_28ffc(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    if (a1 == 0) {
        char v1 = *(char *)&g70; // 0x29050
        if ((v1 | *(char *)&g179) == 0 == g28 < (char *)3) {
            return 0;
        }
        // 0x29070
        return function_28944(a2, a3, a4);
    }
    // 0x2900c
    function_28ea8(a1);
    int32_t * v2 = (int32_t *)a1; // 0x2901c
    free(v2);
    *v2 = 0;
    return &g306;
}

// Address range: 0x29082 - 0x29086
int32_t function_29082(void) {
    // 0x29082
    return unknown_464b5e();
}

// Address range: 0x29088 - 0x29090
int32_t function_29088(void) {
    // 0x29088
    bool v1; // 0x29088
    int32_t result; // 0x29088
    if (v1 || !v1) {
        return result;
    }
    // 0x2908c
    return function_2898c(result, result, result);
}

// Address range: 0x29090 - 0x290d8
int32_t function_29090(int32_t result) {
    int32_t * v1 = (int32_t *)(result + 368); // 0x29090
    if (*v1 == 0) {
        // 0x2909c
        return result;
    }
    // 0x290b8
    int32_t v2; // bp-16, 0x29090
    function_1f5c4(&v2);
    return function_1f8ec((int32_t)&v2, v1);
}

// Address range: 0x290da - 0x29100
int32_t function_290da(int32_t a1, int32_t a2, int32_t a3) {
    // 0x290da
    bool v1; // 0x290da
    if (v1) {
        // 0x290fc
        function_1224bbe();
        unknown_464bb6();
        return function_1224cae();
    }
    // 0x290ea
    unknown_464bb6();
    return function_29608();
}

// Address range: 0x29100 - 0x29118
int32_t function_29100(void) {
    // 0x29100
    int32_t v1; // 0x29100
    function_1f5c4((int32_t *)v1);
    int32_t v2; // 0x29100
    return function_1f8ec((int32_t)&v2, &g91);
}

// Address range: 0x2911c - 0x29140
int32_t function_2911c(void) {
    // 0x2911c
    int32_t v1; // bp-16, 0x2911c
    function_1f5c4(&v1);
    return function_1f8ec((int32_t)&v1, &g92);
}

// Address range: 0x29144 - 0x2920c
int32_t function_29144(int32_t a1) {
    int32_t v1 = 0; // 0x29154
    for (int32_t i = 4; i > 0; i--) {
        // 0x29158
        int32_t v2; // 0x29144
        v1 = 256 * v1 | v2 % 256;
        v2 /= 256;
    }
    // 0x2916c
    int32_t v3; // bp-3080, 0x29144
    int32_t result = function_1e944(&v3, a1, 128); // 0x29178
    char v4 = *(char *)&g70; // 0x29198
    if ((v4 | *(char *)&g179) != 0 || g28 > (char *)2) {
        // 0x291a4
        int32_t str; // bp-2056, 0x29144
        snprintf((char *)&str, 2048, "BENCHFILE nonce %u=0x%08x for work=%s", v1, v1, &v3);
        return function_1ccec(3, &str, 0);
    }
    // 0x29200
    return result;
}

// Address range: 0x2920c - 0x29244
int32_t function_2920c(int32_t result, int32_t a2) {
    int32_t * v1 = (int32_t *)(result + 308); // 0x2920c
    int32_t v2 = *v1; // 0x2920c
    int32_t v3 = llvm_bswap_i32(a2); // 0x29210
    int32_t v4 = result + 68; // 0x29214
    *(int32_t *)v4 = v3;
    if (v2 == 0) {
        return result;
    }
    // 0x29220
    free((int32_t *)v2);
    int32_t result2 = function_1e9b4(v4, 4); // 0x29238
    *v1 = result2;
    return result2;
}

// Address range: 0x29244 - 0x292d4
int32_t function_29244(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x29244
    float64_t v1; // 0x29244
    float64_t v2 = __asm_vpush_9(v1); // 0x2924c
    if (a1 == 0) {
        // 0x292c4
        __asm_vpop(v2);
        return 0;
    }
    // 0x29254
    __asm_vldr(0);
    int64_t v3 = *(int64_t *)(a1 + 216); // 0x29258
    int32_t v4 = v3; // 0x29258
    __asm_vmov_8(function_492fc(v3 >> 32, (int64_t)v4), v4);
    return (int32_t)(*(int64_t *)(a1 + 208) / 0x100000000);
}

// Address range: 0x292d4 - 0x292d8
int32_t function_292d4(void) {
    // 0x292d4
    return unknown_429918();
}

// Address range: 0x292dc - 0x292f8
int32_t function_292dc(int32_t a1) {
    int32_t result = a1; // 0x292dc
    bool v1; // 0x292dc
    if (v1) {
        // 0x292e0
        function_ffc292e4();
        __asm_stclmi(15, 15, -0x1a6bcfc8);
        result = -1;
    }
    // 0x292e0
    return result;
}

// Address range: 0x292f8 - 0x29530
int32_t function_292f8(int32_t * a1, char * a2, char * a3, int32_t a4) {
    int32_t v1 = (int32_t)a1;
    char * str; // bp-2072, 0x292f8
    if (a1 == NULL) {
        char v2 = *(char *)&g70; // 0x294dc
        int32_t result = v1; // 0x294d0
        if ((v2 | *(char *)&g179) == 0 != g28 < (char *)3) {
            // 0x294fc
            snprintf((char *)&str, 2048, "Discard work called with NULL work from %s %s:%d", a2, a3, a4);
            result = function_1ccec(3, (int32_t *)&str, 0);
        }
        // 0x29430
        return result;
    }
    // 0x2931c
    if (*(char *)(v1 + 273) == 0) {
        // 0x2932c
        if (*(int32_t *)(v1 + 240) == 0) {
            // 0x29338
            if (*(char *)(v1 + 272) == 0) {
                int32_t * v3 = (int32_t *)(v1 + 260); // 0x29344
                int32_t v4 = *v3; // 0x29344
                if (v4 != 0) {
                    int32_t * v5 = (int32_t *)(v4 + 124); // 0x29350
                    *v5 = *v5 + 1;
                    int32_t * v6 = (int32_t *)(*v3 + 64); // 0x29360
                    *v6 = *v6 - 1;
                    int32_t * v7 = (int32_t *)(*v3 + 68); // 0x29370
                    *v7 = *v7 - 1;
                }
                int32_t v8 = g231; // 0x2938c
                g231 = v8 + 1;
                g232 += (int32_t)(v8 == -1);
                if (*(char *)&g71 == 0) {
                    // 0x29430
                    return function_28ffc(v1, (int32_t)a2, (int32_t)a3, a4);
                }
                char v9 = *(char *)&g70; // 0x293cc
                if ((v9 | *(char *)&g179) == 0 != g28 < (char *)7) {
                    // 0x293ec
                    str = (char *)0x63736944;
                    function_1ccec(7, (int32_t *)&str, 0);
                }
                // 0x29430
                return function_28ffc(v1, (int32_t)a2, (int32_t)a3, a4);
            }
        }
    }
    // 0x2943c
    if (*(char *)&g71 != 0) {
        char v10 = *(char *)&g70; // 0x2946c
        if ((v10 | *(char *)&g179) == 0 != g28 < (char *)7) {
            // 0x29478
            str = (char *)0x63736944;
            function_1ccec(7, (int32_t *)&str, 0);
        }
    }
    // 0x29430
    return function_28ffc(v1, (int32_t)a2, (int32_t)a3, a4);
}

// Address range: 0x29530 - 0x295ec
int32_t function_29530(int32_t result) {
    int32_t v1 = (int32_t)g188; // 0x2953c
    if (g188 >= (char *)1) {
        int32_t v2 = g202; // 0x29558
        int32_t * v3 = (int32_t *)(*(int32_t *)v2 + 4); // 0x29564
        int32_t v4 = *v3; // 0x29564
        if (v4 > *(int32_t *)(result + 4)) {
            *v3 = v4 - 1;
        }
        v2 += 4;
        while (g202 + 4 * v1 != v2) {
            // 0x2955c
            v3 = (int32_t *)(*(int32_t *)v2 + 4);
            v4 = *v3;
            if (v4 > *(int32_t *)(result + 4)) {
                *v3 = v4 - 1;
            }
            v2 += 4;
        }
    }
    int32_t v5 = v1 - 1; // 0x29544
    int32_t v6 = v1; // 0x29584
    if (v5 > result) {
        int32_t v7 = result + 1; // 0x29588
        int32_t v8 = 4 * v7; // 0x29590
        int32_t v9 = g202; // 0x295a0
        int32_t v10 = v8 - 4; // 0x295a4
        *(int32_t *)(v9 + v10) = *(int32_t *)(v9 + v8);
        *(int32_t *)*(int32_t *)(g202 + v10) = result;
        if (v7 != v5) {
            int32_t v11 = v8 + 4; // 0x295b0
            int32_t v12 = v7 + 1; // 0x2959c
            int32_t v13 = g202; // 0x295a0
            *(int32_t *)(v13 + v8) = *(int32_t *)(v13 + v11);
            *(int32_t *)*(int32_t *)(g202 + v8) = v7;
            int32_t v14 = v11; // 0x295c8
            int32_t v15 = v12; // 0x295c8
            while (v12 != v5) {
                // 0x2959c
                v11 = v14 + 4;
                v12 = v15 + 1;
                v13 = g202;
                *(int32_t *)(v13 + v14) = *(int32_t *)(v13 + v11);
                *(int32_t *)*(int32_t *)(g202 + v14) = v15;
                v14 = v11;
                v15 = v12;
            }
        }
        // 0x295cc
        v6 = (int32_t)g188;
    }
    // 0x295d0
    *(int32_t *)result = v6;
    *(char *)(result + 105) = 1;
    *(int32_t *)&g188 = (int32_t)g188 - 1;
    return result;
}

// Address range: 0x295ec - 0x295f4
int32_t function_295ec(void) {
    // 0x295ec
    return function_2a1ba();
}

// Address range: 0x295f4 - 0x295f8
int32_t function_295f4(void) {
    // 0x295f4
    int32_t v1; // 0x295f4
    return function_2a282(*(int16_t *)(v1 + 44));
}

// Address range: 0x295f8 - 0x295fc
int32_t function_295f8(void) {
    // 0x295f8
    return function_29c1c();
}

// Address range: 0x295fc - 0x29600
int32_t function_295fc(int32_t a1) {
    // 0x295fc
    return function_2a5e8(a1 + 5);
}

// Address range: 0x29600 - 0x29604
int32_t function_29600(void) {
    // 0x29600
    bool v1; // 0x29600
    if (v1) {
        int32_t v2; // 0x29600
        function_2964c(v2);
    }
    // 0x29602
    return function_29aa0();
}

// Address range: 0x29604 - 0x29608
int32_t function_29604(int32_t result) {
    // 0x29604
    return result;
}

// Address range: 0x29608 - 0x2960c
int32_t function_29608(void) {
    // 0x29608
    return 13;
}

// Address range: 0x2960c - 0x2963c
int32_t function_2960c(void) {
    // 0x2960c
    int32_t data; // 0x2960c
    fwrite((int32_t *)data, 1, data, (struct _IO_FILE *)data);
    if (*(int32_t *)((uint32_t)data % 0x10000 || (int32_t)&g171) < 1) {
        function_297fc();
    }
    // 0x29624
    return function_29720();
}

// Address range: 0x2963c - 0x2964c
int32_t function_2963c(int32_t result) {
    // 0x2963c
    return result;
}

// Address range: 0x2964c - 0x29650
int32_t function_2964c(int32_t result) {
    // 0x2964c
    return result;
}

// Address range: 0x29650 - 0x2967c
int32_t function_29650(int32_t a1) {
    int32_t v1 = a1; // 0x29650
    bool v2; // 0x29650
    if (v2) {
        v1 = function_297ec();
    }
    // 0x29654
    function_27064(function_1e8f8(*(int32_t *)(v1 + 180)));
    int32_t v3; // 0x29650
    int32_t v4 = *(int32_t *)(v3 + 184); // 0x29664
    int32_t v5 = v4; // 0x2966c
    if (v4 == 0) {
        v5 = function_29bc0();
    }
    // 0x29670
    return function_27064(v5);
}

// Address range: 0x29680 - 0x29684
int32_t function_29680(void) {
    // 0x29680
    return 4;
}

// Address range: 0x29684 - 0x29688
int32_t function_29684(void) {
    // 0x29684
    __asm_adr(0);
    return function_299ca();
}

// Address range: 0x29688 - 0x2968c
int32_t function_29688(int32_t result) {
    // 0x29688
    return result;
}

// Address range: 0x29690 - 0x296d8
int32_t function_29690(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x29690
    int32_t stream; // 0x29690
    int32_t v1 = function_27064(*(int32_t *)(stream + 164)); // 0x2969c
    return fprintf((struct _IO_FILE *)stream, "%s\n\t{\n\t\t\"quota\" : \"%s%s%s%d;%s\",", (char *)stream, (char *)a3, (char *)stream, (char *)(a3 >> 31), a4, (char *)v1);
}

// Address range: 0x296d8 - 0x29720
int32_t function_296d8(void) {
    // 0x296d8
    int32_t v1; // 0x296d8
    struct _IO_FILE * stream = (struct _IO_FILE *)v1; // 0x296f4
    fprintf(stream, "\n\t\t\"user\" : \"%s\",", (char *)function_27064(*(int32_t *)(v1 + 172)));
    int32_t v2 = function_27064(*(int32_t *)(v1 + 176)); // 0x296fc
    return fprintf(stream, "\n\t\t\"pass\" : \"%s\"\n\t}", (char *)v2);
}

// Address range: 0x29720 - 0x297ec
int32_t function_29720(void) {
    // 0x29720
    int32_t v1; // 0x29720
    int32_t v2 = function_27af0(v1); // 0x29724
    int32_t v3 = v2; // 0x29734
    if (*(int32_t *)(v2 + 56) != 1) {
        v3 = function_2963c(v2);
    }
    int32_t v4 = v3; // 0x2974c
    if (*(int32_t *)(v3 + 184) == 0) {
        v4 = function_29b1c();
    }
    int32_t v5 = function_27064(function_1e8f8(*(int32_t *)(v4 + 180))); // 0x29758
    int32_t * v6 = (int32_t *)(v2 + 184); // 0x29760
    int32_t v7 = *v6; // 0x29760
    int32_t v8; // 0x29720
    int32_t v9; // 0x29720
    if (v7 != 0) {
        int32_t v10 = function_27064(v7); // 0x29774
        v9 = *v6 == 0 ? v1 : (int32_t)"|";
        v8 = v10;
    }
    int32_t v11 = v1 == 0 ? v1 : v1;
    int32_t v12 = *(int32_t *)(v2 + 164); // 0x29790
    struct _IO_FILE * stream = (struct _IO_FILE *)v1; // 0x297c0
    fprintf(stream, "%s\n\t{\n\t\t\"url\" : \"%s%s%s%s\",", (char *)v11, (char *)v5, (char *)v8, (char *)v9, (char *)function_27064(v12));
    if (*(char *)(v2 + 580) == 0) {
        function_296d8();
    }
    // 0x297d0
    fwrite((int32_t *)"\n\t\t\"extranonce-subscribe\" : true,", 1, 33, stream);
    return function_296d8();
}

// Address range: 0x297ec - 0x297fc
int32_t function_297ec(void) {
    // 0x297ec
    int32_t v1; // 0x297ec
    return function_29690(v1, v1, v1, v1);
}

// Address range: 0x297fc - 0x29868
int32_t function_297fc(void) {
    // 0x297fc
    int32_t stream; // 0x297fc
    fwrite((int32_t *)"\n]\n", 1, 3, (struct _IO_FILE *)stream);
    if (g33 == 16) {
        function_29a60();
    }
    // 0x29828
    if (strtok(__strdup(g32), "|") != NULL) {
        function_299a4();
    }
    // 0x29864
    return function_29a48();
}

// Address range: 0x29868 - 0x2986c
int32_t function_29868(void) {
    // 0x29868
    return 16;
}

// Address range: 0x2986c - 0x29870
int32_t function_2986c(void) {
    // 0x2986c
    return function_29e8a();
}

// Address range: 0x29870 - 0x29874
int32_t function_29870(int32_t a1, int32_t a2) {
    // 0x29870
    return function_29f4c(0x4000000 * a2);
}

// Address range: 0x29874 - 0x29878
int32_t function_29874(int32_t a1) {
    // 0x29874
    return function_29efa(a1 + 3);
}

// Address range: 0x29878 - 0x2987c
int32_t function_29878(int32_t a1) {
    // 0x29878
    return function_2a5a8();
}

// Address range: 0x2987c - 0x29880
int32_t function_2987c(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x2987c
    int32_t v1; // 0x2987c
    *(int32_t *)v1 = a4;
    return function_29e92();
}

// Address range: 0x29880 - 0x29884
int32_t function_29880(int32_t result) {
    // 0x29880
    return result;
}

// Address range: 0x29884 - 0x2988c
int32_t function_29884(int32_t a1, int32_t a2, int32_t a3) {
    // 0x29884
    *(int32_t *)a1 = a2;
    return function_29ab8(a1 + 4);
}

// Address range: 0x2988c - 0x29898
int32_t function_2988c(int32_t a1, int32_t a2, int32_t a3, uint32_t a4) {
    // 0x2988c
    return function_29eaa(a4 / 16);
}

// Address range: 0x29898 - 0x2989c
int32_t function_29898(int32_t a1, int32_t a2) {
    // 0x29898
    return function_29b42();
}

// Address range: 0x2989c - 0x298a4
int32_t function_2989c(int32_t a1) {
    // 0x2989c
    return function_29f26();
}

// Address range: 0x298a4 - 0x298a8
int32_t function_298a4(int32_t a1) {
    // 0x298a4
    return function_29eba();
}

// Address range: 0x298a8 - 0x298ac
int32_t function_298a8(int32_t result) {
    // 0x298a8
    return result;
}

// Address range: 0x298ac - 0x298b4
int32_t function_298ac(int32_t a1, int32_t a2) {
    // 0x298ac
    *(int32_t *)(a1 + 1) = a2;
    return function_2a5ba(a1 + 5);
}

// Address range: 0x298b4 - 0x298b8
int32_t function_298b4(void) {
    // 0x298b4
    return function_29eca();
}

// Address range: 0x298b8 - 0x298bc
int32_t function_298b8(int32_t result, int32_t a2) {
    // 0x298b8
    return result;
}

// Address range: 0x298bc - 0x298c4
int32_t function_298bc(int32_t a1) {
    // 0x298bc
    return function_2a464();
}

// Address range: 0x298c4 - 0x298c8
int32_t function_298c4(int32_t a1) {
    // 0x298c4
    return a1 + 8;
}

// Address range: 0x298c8 - 0x298cc
int32_t function_298c8(int32_t result) {
    // 0x298c8
    return result;
}

// Address range: 0x298cc - 0x298d4
int32_t function_298cc(int32_t a1, int32_t a2) {
    // 0x298cc
    *(int32_t *)(a1 + 1) = a2;
    return function_2ac84(a1 + 5);
}

// Address range: 0x298d4 - 0x298d8
int32_t function_298d4(void) {
    // 0x298d4
    int32_t v1; // 0x298d4
    return function_2a594((uint32_t)v1 / 2);
}

// Address range: 0x298d8 - 0x298dc
int32_t function_298d8(int32_t result, int32_t a2) {
    // 0x298d8
    return result;
}

// Address range: 0x298dc - 0x298e4
int32_t function_298dc(int32_t a1) {
    // 0x298dc
    return function_29f66();
}

// Address range: 0x298e4 - 0x298e8
int32_t function_298e4(int32_t a1) {
    // 0x298e4
    return function_29efa(a1 + 12);
}

// Address range: 0x298e8 - 0x298ec
int32_t function_298e8(int32_t result) {
    // 0x298e8
    return result;
}

// Address range: 0x298ec - 0x298f4
int32_t function_298ec(int32_t a1, int32_t a2) {
    // 0x298ec
    *(int32_t *)(a1 + 1) = a2;
    return function_2a0b2(a1 + 5);
}

// Address range: 0x298f4 - 0x298f8
int32_t function_298f4(int32_t a1, int32_t a2) {
    // 0x298f4
    return function_29f0a(0);
}

// Address range: 0x298f8 - 0x298fc
int32_t function_298f8(int32_t result, int32_t a2) {
    // 0x298f8
    return result;
}

// Address range: 0x298fc - 0x29904
int32_t function_298fc(int32_t a1) {
    // 0x298fc
    return function_29f86(a1 + 1);
}

// Address range: 0x29904 - 0x29908
int32_t function_29904(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x29904
    int32_t v1; // 0x29904
    *(int32_t *)v1 = a3;
    *(int32_t *)(v1 + 4) = a4;
    return function_2a528();
}

// Address range: 0x29908 - 0x2990c
int32_t function_29908(int32_t result) {
    // 0x29908
    return result;
}

// Address range: 0x2990c - 0x29914
int32_t function_2990c(int32_t a1, int32_t a2) {
    // 0x2990c
    *(int32_t *)(a1 + 1) = a2;
    return function_2a640(a1 + 5);
}

// Address range: 0x29914 - 0x29918
int32_t function_29914(void) {
    // 0x29914
    return function_29f2a();
}

// Address range: 0x29918 - 0x2991c
int32_t function_29918(int32_t result, int32_t a2) {
    // 0x29918
    return result;
}

// Address range: 0x2991c - 0x29924
int32_t function_2991c(int32_t a1) {
    // 0x2991c
    return function_2a2ea();
}

// Address range: 0x29924 - 0x29928
int32_t function_29924(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x29924
    int32_t v1; // 0x29924
    *(int32_t *)v1 = a3;
    *(int32_t *)(v1 + 4) = a4;
    return function_29f3a();
}

// Address range: 0x29928 - 0x2992c
int32_t function_29928(int32_t a1) {
    // 0x29928
    return function_29bd2();
}

// Address range: 0x2992c - 0x29934
int32_t function_2992c(int32_t a1, int32_t a2) {
    // 0x2992c
    *(int32_t *)(a1 + 1) = a2;
    return __asm_adr(a1 + 5);
}

// Address range: 0x29936 - 0x29938
int32_t function_29936(void) {
    // 0x29936
    return function_2a1ba();
}

// Address range: 0x29938 - 0x2993c
int32_t function_29938(int32_t a1, int32_t a2) {
    // 0x29938
    return function_29be2();
}

// Address range: 0x29942 - 0x29944
int32_t function_29942(int32_t a1) {
    // 0x29942
    return function_2a5e8(a1);
}

// Address range: 0x29944 - 0x29990
int32_t function_29944(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x29944
    if (a3 != 0x286ec == ((int32_t)(a3 == 0x2871c || a3 == a1) || a4) == 0) {
        function_29ad8(0x286ec, a2, a3);
    }
    // 0x29974
    int32_t stream; // 0x29944
    int32_t v1 = *(int32_t *)*(int32_t *)(stream - 8); // 0x29988
    return fprintf((struct _IO_FILE *)stream, ",\n\"%s\" : \"%d\"", (char *)(stream + 2), v1);
}

// Address range: 0x29990 - 0x299a4
int32_t function_29990(int32_t a1) {
    // 0x29990
    int32_t delim; // 0x29990
    return (int32_t)strtok(NULL, (char *)delim);
}

// Address range: 0x299a4 - 0x299b0
int32_t function_299a4(void) {
    // 0x299a4
    int32_t result; // 0x299a4
    int32_t v1; // 0x299a4
    if (*(char *)(v1 + 1) != 45) {
        result = function_29990(v1);
    }
    // 0x299b0
    return result;
}

// Address range: 0x299b4 - 0x299c8
int32_t function_299b4(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = a1; // 0x299b8
    int32_t v2; // 0x299b4
    if (v2 == a4) {
        v1 = function_29990(a1);
    }
    uint32_t v3 = *(int32_t *)(v2 - 24); // 0x299bc
    int32_t result = v1; // 0x299c4
    if (v3 % 2 == 0) {
        result = function_29a04(v1, v3);
    }
    // 0x299c8
    return result;
}

// Address range: 0x299ca - 0x299cc
int32_t function_299ca(void) {
    // 0x299ca
    int32_t result; // 0x299ca
    return result;
}

// Address range: 0x299cc - 0x29a04
int32_t function_299cc(int32_t a1, int32_t a2, int32_t a3) {
    int32_t result = 0x3cce8; // 0x299f0
    if ((a3 || 32) != 0x3cce8) {
        result = function_29a04(0x3cce8, a2);
    }
    // 0x299f4
    return result;
}

// Address range: 0x29a04 - 0x29a0c
int32_t function_29a04(int32_t result, int32_t a2) {
    // 0x29a04
    return result;
}

// Address range: 0x29a0c - 0x29a30
int32_t function_29a0c(int32_t a1, int32_t a2) {
    int32_t v1 = a1; // 0x29a10
    if ((a2 & 6) == 0) {
        v1 = function_29990(a1);
    }
    // 0x29a14
    int32_t v2; // 0x29a0c
    int32_t v3 = *(int32_t *)(v2 - 8); // 0x29a14
    if (v3 == v2) {
        function_29990(v1);
    }
    int32_t v4 = *(int32_t *)v3; // 0x29a20
    int32_t v5 = v4; // 0x29a28
    if (v4 == 0) {
        v5 = function_29990(0);
    }
    // 0x29a2c
    return function_27064(v5);
}

// Address range: 0x29a32 - 0x29a34
int32_t function_29a32(int32_t a1) {
    // 0x29a32
    int32_t v1; // 0x29a32
    return function_29f4c(v1);
}

// Address range: 0x29a34 - 0x29a48
int32_t function_29a34(int32_t a1) {
    // 0x29a34
    int32_t stream; // 0x29a34
    return function_29990(fprintf((struct _IO_FILE *)stream, (char *)stream));
}

// Address range: 0x29a48 - 0x29a60
int32_t function_29a48(void) {
    // 0x29a48
    int32_t v1; // 0x29a48
    free((int32_t *)v1);
    return &g306;
}

// Address range: 0x29a60 - 0x29aa0
int32_t function_29a60(void) {
    // 0x29a60
    switch (g89) {
        case 4: {
            // 0x29a74
            function_29ba0();
            // break -> 0x29a8c
            break;
        }
        case 3: {
            // 0x29a7c
            function_29b80();
            // break -> 0x29a8c
            break;
        }
        case 1: {
            // 0x29a84
            function_29b64();
            // break -> 0x29a8c
            break;
        }
        case 2: {
            function_29b44();
            // break -> 0x29a8c
            break;
        }
    }
    // 0x29a8c
    return (int32_t)"\n}\n";
}

// Address range: 0x29aa0 - 0x29aa2
int32_t function_29aa0(void) {
    // 0x29aa0
    __asm_adr(208);
    int32_t result; // 0x29aa0
    return result;
}

// Address range: 0x29aa4 - 0x29aa8
int32_t function_29aa4(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x29aa4
    return result;
}

// Address range: 0x29aa8 - 0x29ab8
int32_t function_29aa8(void) {
    // 0x29aa8
    int32_t result; // 0x29aa8
    *(int32_t *)(result + 536) = 0;
    return result;
}

// Address range: 0x29ab8 - 0x29abe
int32_t function_29ab8(int32_t a1) {
    // 0x29ab8
    int32_t result; // 0x29ab8
    return result;
}

// Address range: 0x29ac0 - 0x29ad0
int32_t function_29ac0(void) {
    // 0x29ac0
    int32_t v1; // 0x29ac0
    free((int32_t *)v1);
    return &g306;
}

// Address range: 0x29ad0 - 0x29ad8
int32_t function_29ad0(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    // 0x29ad0
    int32_t result; // 0x29ad0
    return result;
}

// Address range: 0x29ad8 - 0x29b0c
int32_t function_29ad8(int32_t a1, int32_t a2, int32_t a3) {
    // 0x29ad8
    switch (a3) {
        default: {
            function_29a0c(0x281d4, a2);
        }
        case 0x2822c: {
        }
        case 0x281d4: {
            // 0x29af4
            int32_t result; // 0x29ad8
            __asm_vldr_14(*(int32_t *)*(int32_t *)(result - 8));
            return result;
        }
    }
}

// Address range: 0x29b0e - 0x29b12
int32_t function_29b0e(void) {
    // 0x29b0e
    int32_t result; // 0x29b0e
    bool v1; // 0x29b0e
    if (!v1) {
        result = function_655f2();
    }
    // 0x29b12
    return result;
}

// Address range: 0x29b14 - 0x29b1c
int32_t function_29b14(void) {
    // 0x29b14
    int32_t stream; // 0x29b14
    return function_29990(fprintf((struct _IO_FILE *)stream, (char *)stream));
}

// Address range: 0x29b1c - 0x29b2c
int32_t function_29b1c(void) {
    // 0x29b1c
    int32_t result; // 0x29b1c
    return result;
}

// Address range: 0x29b2c - 0x29b40
int32_t function_29b2c(void) {
    // 0x29b2c
    int32_t stream; // 0x29b2c
    return fprintf((struct _IO_FILE *)stream, ",\n\"%s\" : true", (char *)(stream + 2));
}

// Address range: 0x29b42 - 0x29b43
int32_t function_29b42(void) {
    // 0x29b42
    int32_t result; // 0x29b42
    return result;
}

// Address range: 0x29b44 - 0x29b64
int32_t function_29b44(void) {
    // 0x29b44
    int32_t stream; // 0x29b44
    return fprintf((struct _IO_FILE *)stream, ",\n\"rotate\" : \"%d\"", g207);
}

// Address range: 0x29b64 - 0x29b80
int32_t function_29b64(void) {
    // 0x29b64
    int32_t size; // 0x29b64
    return fwrite((int32_t *)",\n\"round-robin\" : true", size, 22, (struct _IO_FILE *)size);
}

// Address range: 0x29b80 - 0x29ba0
int32_t function_29b80(void) {
    // 0x29b80
    int32_t stream; // 0x29b80
    return fwrite((int32_t *)",\n\"load-balance\" : true", 1, 23, (struct _IO_FILE *)stream);
}

// Address range: 0x29ba0 - 0x29bc0
int32_t function_29ba0(void) {
    // 0x29ba0
    int32_t stream; // 0x29ba0
    return fwrite((int32_t *)",\n\"balance\" : true", 1, 18, (struct _IO_FILE *)stream);
}

// Address range: 0x29bc0 - 0x29bd0
int32_t function_29bc0(void) {
    // 0x29bc0
    int32_t v1; // 0x29bc0
    return function_29690(v1, v1, v1, *(int32_t *)(v1 + 56));
}

// Address range: 0x29bd2 - 0x29bd3
int32_t function_29bd2(void) {
    // 0x29bd2
    int32_t result; // 0x29bd2
    return result;
}

// Address range: 0x29bd4 - 0x29bd5
int32_t function_29bd4(void) {
    // 0x29bd4
    int32_t result; // 0x29bd4
    return result;
}

// Address range: 0x29bd8 - 0x29bdc
int32_t function_29bd8(int32_t a1) {
    // 0x29bd8
    return function_2a31e();
}

// Address range: 0x29bdc - 0x29be0
int32_t function_29bdc(int32_t a1) {
    // 0x29bdc
    return function_29720();
}

// Address range: 0x29be2 - 0x29be4
int32_t function_29be2(void) {
    // 0x29be2
    int32_t v1; // 0x29be2
    return function_2a1f0(v1);
}

// Address range: 0x29be4 - 0x29be8
int32_t function_29be4(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x29be4
    *(int32_t *)(2 * a1) = a4;
    return function_29f2a();
}

// Address range: 0x29be8 - 0x29bec
int32_t function_29be8(void) {
    // 0x29be8
    bool v1; // 0x29be8
    if (v1) {
        int32_t v2; // 0x29be8
        function_29c04(v2);
    }
    // 0x29bea
    return function_2a088();
}

// Address range: 0x29bec - 0x29bee
int32_t function_29bec(void) {
    // 0x29bec
    int32_t result; // 0x29bec
    return result;
}

// Address range: 0x29bee - 0x29bf0
int32_t function_29bee(void) {
    // 0x29bee
    int32_t result; // 0x29bee
    return result;
}

// Address range: 0x29bf0 - 0x29bf4
int32_t function_29bf0(int32_t result) {
    // 0x29bf0
    return result;
}

// Address range: 0x29bf4 - 0x29bf8
int32_t function_29bf4(int32_t result) {
    // 0x29bf4
    return result;
}

// Address range: 0x29bfa - 0x29bfc
int32_t function_29bfa(int16_t a1) {
    // 0x29bfa
    return function_2a282(a1);
}

// Address range: 0x29bfc - 0x29c00
int32_t function_29bfc(void) {
    // 0x29bfc
    int32_t result; // 0x29bfc
    return result;
}

// Address range: 0x29c00 - 0x29c04
int32_t function_29c00(int32_t a1) {
    // 0x29c00
    return function_2a464();
}

// Address range: 0x29c04 - 0x29c08
int32_t function_29c04(int32_t a1) {
    // 0x29c04
    return a1 + 4;
}

// Address range: 0x29c08 - 0x29c0c
int32_t function_29c08(void) {
    // 0x29c08
    return 14;
}

// Address range: 0x29c0e - 0x29c10
int32_t function_29c0e(int32_t a1) {
    // 0x29c0e
    return function_2a696(a1);
}

// Address range: 0x29c10 - 0x29c14
int32_t function_29c10(int32_t result, int32_t a2) {
    // 0x29c10
    *(int32_t *)(a2 + result) = result;
    return result;
}

// Address range: 0x29c14 - 0x29c18
int32_t function_29c14(int32_t result) {
    // 0x29c14
    return result;
}

// Address range: 0x29c18 - 0x29c19
int32_t function_29c18(void) {
    // 0x29c18
    int32_t result; // 0x29c18
    return result;
}

// Address range: 0x29c1c - 0x29c20
int32_t function_29c1c(void) {
    // 0x29c1c
    return function_2a222();
}

// Address range: 0x29c20 - 0x29c64
int32_t function_29c20(int32_t result, int32_t a2, int32_t a3, uint32_t a4, int32_t a5, int32_t a6) {
    uint32_t v1 = *(int32_t *)(a4 % 0x10000 | (int32_t)&g171); // 0x29c24
    int32_t v2; // 0x29c20
    if (v1 <= (uint32_t)v2) {
        // 0x29c5c
        return result;
    }
    int32_t v3 = g202; // 0x29c44
    while (v3 + 4 != g202 + 4 * v1) {
        // 0x29c48
        v3 += 4;
    }
    // 0x29c5c
    return result;
}

// Address range: 0x29c6c - 0x29d68
int32_t function_29c6c(int32_t str) {
    // 0x29c6c
    if (g230 != NULL) {
        // 0x29c88
        if (*g230 != 0) {
            // 0x29d34
            return (int32_t)strcpy((char *)str, g230);
        }
    }
    // 0x29c94
    char * str3; // 0x29c6c
    if (getenv("HOME") == NULL) {
        goto lab_0x29cc0;
    } else {
        // 0x29ca8
        if (*getenv("HOME") == 0) {
            goto lab_0x29cc0;
        } else {
            char * str2 = (char *)str;
            *(int16_t *)stpcpy(str2, getenv("HOME")) = 47;
            str3 = str2;
            goto lab_0x29cc8;
        }
    }
  lab_0x29cc0:;
    char * v1 = (char *)str;
    *v1 = 0;
    str3 = v1;
    goto lab_0x29cc8;
  lab_0x29cc8:;
    int32_t v2 = strlen(str3) + str; // 0x29cd4
    *(int32_t *)v2 = 0x6d6d622e;
    *(int32_t *)(v2 + 4) = 0x72656e69;
    *(int16_t *)(v2 + 8) = 47;
    mkdir(str3, 511);
    int32_t v3 = strlen(str3) + str; // 0x29d0c
    *(int32_t *)v3 = 0x696d6d62;
    *(int32_t *)(v3 + 4) = 0x2e72656e;
    *(char *)(v3 + 12) = 0;
    *(int32_t *)(v3 + 8) = 0x666e6f63;
    return 0x696d6d62;
}

// Address range: 0x29d68 - 0x29dc8
int32_t function_29d68(void) {
    int32_t v1 = function_1e74c(0x1000, "cgminer.c", "load_default_config", 2181); // 0x29d88
    g83 = (char *)v1;
    g84 = 0;
    function_29c6c(v1);
    char * v2 = g83; // 0x29dac
    if (access(g83, R_OK) == 0) {
        // 0x29dc0
        return function_27bc4((int32_t)v2);
    }
    // 0x29db4
    free((int32_t *)v2);
    g83 = NULL;
    return &g306;
}

// Address range: 0x29dcc - 0x29dcd
int32_t function_29dcc(void) {
    // 0x29dcc
    int32_t result; // 0x29dcc
    return result;
}

// Address range: 0x29dce - 0x29e6e
int32_t function_29dce(int32_t a1, int32_t a2) {
    // 0x29dce
    int32_t v1; // 0x29dce
    uint32_t v2 = v1;
    unknown_4658aa();
    bool v3; // 0x29dce
    bool v4; // 0x29dce
    if (v4) {
        __asm_svcmi(0xf0eef1);
    } else {
        // .critedge
        v3 = (v1 & 0x20000) != 0;
    }
    if (v3 == !v4) {
        function_e2462();
    }
    bool v5 = v3; // 0x29dde
    if (v4 || false) {
        __asm_cdple(13, 8, 14, 2, 13, 1);
        v5 = (v1 & 8) != 0;
    }
    int32_t v6; // 0x29dce
    int32_t v7; // 0x29dce
    int32_t v8; // 0x29dce
    int32_t v9; // 0x29dce
    bool v10; // 0x29dce
    bool v11; // 0x29dce
    bool v12; // 0x29dce
    bool v13; // 0x29dce
    if (v4) {
        int32_t v14 = v1 >> 4; // 0x29de6
        v11 = v2 >= v14;
        v13 = v2 == v14;
        v7 = v14;
        v9 = v14;
        v10 = v2 >= v14;
        v12 = v2 == v14;
        v6 = v14;
        v8 = v14;
        if (((v2 - v14 ^ v2) & (v14 ^ v2)) < 0) {
            goto lab_0x29dee;
        } else {
            goto lab_dec_label_pc_unknown_10;
        }
    } else {
        v11 = v5;
        v13 = false;
        v10 = v5;
        v12 = false;
        if (v4) {
            goto lab_0x29dee;
        } else {
            goto lab_dec_label_pc_unknown_10;
        }
    }
  lab_0x29dee:;
    int32_t v15 = v9; // 0x29dce
    int32_t v16; // 0x29dce
    int32_t v17 = v16; // 0x29dce
    int32_t v18 = v7; // 0x29dce
    int32_t v19; // 0x29dce
    int32_t v20 = v19; // 0x29dce
    bool v21 = v13; // 0x29dce
    bool v22 = v11; // 0x29dce
    bool v23 = true; // 0x29dce
    int32_t v24 = function_fe36c5f2(); // 0x29dce
    goto lab_0x29df2;
  lab_dec_label_pc_unknown_10:
    v15 = v8;
    int32_t v29; // 0x29dce
    v17 = v29;
    v18 = v6;
    int32_t v30; // 0x29dce
    v20 = v30;
    v21 = v12;
    v22 = v10;
    v23 = false;
    v24 = function_fe3e5472();
    goto lab_0x29df2;
  lab_0x29df2:;
    bool v25 = v21;
    int32_t v26 = v24; // 0x29df2
    if (v22 == !v25) {
        v26 = function_65476();
    }
    int32_t v27 = v26; // 0x29df6
    if (!v23) {
        v27 = function_225816();
    }
    int32_t result = v27; // 0x29dfa
    if (v25) {
        result = function_6256a2();
    }
    // 0x29dfe
    if (v23) {
        // 0x29e6e
        return result;
    }
    // 0x29e06
    __asm_ldclvc(12, 14, *(int32_t *)(result - 324));
    __asm_ldcvc(1, 14, *(int32_t *)(v1 - 640));
    if (v25) {
        function_5a5496();
    }
    // 0x29e1a
    function_fe264f22();
    if ((result & 4) != 0 == !v25) {
        function_11e549e();
    }
    int32_t result2 = function_22563a(); // 0x29e22
    if (v25) {
        result2 = function_6256ca();
    }
    __asm_stclvc(12, 14, *(int32_t *)(v1 - 324));
    if (v20 < v18) {
        // 0x29e6e
        return result2;
    }
    // 0x29e3a
    __asm_ldcvc(1, 14, *(int32_t *)(result2 - 640));
    if (v25) {
        function_5a54be();
    }
    bool v28 = v17 < v15 ? (result & 4) != 0 : (result2 & 4) != 0;
    function_fe0e4f4a();
    if (v28 == !v25) {
        function_11e54c6();
    }
    int32_t result3 = function_225662(); // 0x29e4a
    if (v25) {
        result3 = function_6256f2();
    }
    __asm_ldclvc(12, 14, *(int32_t *)(v2 - 324));
    if (v25 || !v28) {
        // 0x29e6e
        return result3;
    }
    // 0x29e66
    __asm_stcvc(1, 14, *(int32_t *)(v1 - 640));
    int32_t result4 = function_1f68666(); // 0x29e66
    if (((result3 & 4) != 0 || v28 != !v25) == !v25) {
        result4 = function_1224f72();
    }
    // 0x29e6e
    return result4;
}

// Address range: 0x29e70 - 0x29e84
int32_t function_29e70(void) {
    // 0x29e70
    int32_t v1; // 0x29e70
    return function_493c8(v1, v1, v1, v1);
}

// Address range: 0x29e84 - 0x29e85
int32_t function_29e84(void) {
    // 0x29e84
    int32_t result; // 0x29e84
    return result;
}

// Address range: 0x29e86 - 0x29e88
int32_t function_29e86(int32_t a1) {
    // 0x29e86
    return function_29f4c(a1);
}

// Address range: 0x29e8a - 0x29e8c
int32_t function_29e8a(void) {
    // 0x29e8a
    int32_t result; // 0x29e8a
    return result;
}

// Address range: 0x29e8c - 0x29e90
int32_t function_29e8c(int32_t result) {
    // 0x29e8c
    return result;
}

// Address range: 0x29e92 - 0x29e94
int32_t function_29e92(void) {
    // 0x29e92
    int32_t v1; // 0x29e92
    return function_2a53c(v1);
}

// Address range: 0x29e94 - 0x29ea8
int32_t function_29e94(int32_t a1, int32_t a2) {
    int32_t result = a1; // 0x29e9c
    bool v1; // 0x29e94
    if (!v1) {
        result = function_29ed4();
    }
    // 0x29ea0
    return result;
}

// Address range: 0x29eaa - 0x29eac
int32_t function_29eaa(int32_t a1) {
    // 0x29eaa
    int32_t v1; // 0x29eaa
    return function_2a4cc(a1, v1, v1);
}

// Address range: 0x29eac - 0x29eb0
int32_t function_29eac(int32_t a1, int32_t a2) {
    // 0x29eac
    return function_2a3cc(0);
}

// Address range: 0x29eb0 - 0x29eb4
int32_t function_29eb0(int32_t a1) {
    // 0x29eb0
    return function_2a1f6();
}

// Address range: 0x29eb4 - 0x29eb8
int32_t function_29eb4(int32_t a1) {
    // 0x29eb4
    int32_t v1; // 0x29eb4
    return function_2a582(a1 + 4, v1);
}

// Address range: 0x29eba - 0x29ebb
int32_t function_29eba(void) {
    // 0x29eba
    int32_t result; // 0x29eba
    return result;
}

// Address range: 0x29ebc - 0x29ec8
int32_t function_29ebc(void) {
    // 0x29ebc
    int32_t v1; // 0x29ebc
    int32_t result = function_2220c(v1, (int32_t *)v1, 32, v1, (int32_t)&g306, (int32_t)&g306); // 0x29ec0
    return result;
}

// Address range: 0x29ec8 - 0x29eca
int32_t function_29ec8(void) {
    // 0x29ec8
    int32_t result; // 0x29ec8
    return result;
}

// Address range: 0x29eca - 0x29ecc
int32_t function_29eca(void) {
    // 0x29eca
    int32_t v1; // 0x29eca
    return function_2a3e8(v1);
}

// Address range: 0x29ecc - 0x29ed4
int32_t function_29ecc(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    // 0x29ecc
    float64_t v1; // 0x29ecc
    __asm_vpop(v1);
    int32_t result; // 0x29ecc
    return result;
}

// Address range: 0x29ed4 - 0x29ed8
int32_t function_29ed4(void) {
    // 0x29ed4
    int32_t result; // 0x29ed4
    return result;
}

// Address range: 0x29ed8 - 0x29edc
int32_t function_29ed8(int32_t a1, int32_t a2) {
    // 0x29ed8
    return function_2a3f8(a2);
}

// Address range: 0x29edc - 0x29ee4
int32_t function_29edc(void) {
    // 0x29edc
    int32_t v1; // 0x29edc
    return function_1e9b4(v1, v1);
}

// Address range: 0x29ee4 - 0x29ee8
int32_t function_29ee4(int32_t a1) {
    // 0x29ee4
    *(int32_t *)a1 = a1;
    return function_2a22a();
}

// Address range: 0x29eea - 0x29eec
int32_t function_29eea(int32_t a1) {
    // 0x29eea
    return function_2a594(a1);
}

// Address range: 0x29eec - 0x29ef8
int32_t function_29eec(void) {
    // 0x29eec
    int32_t result; // 0x29eec
    bool v1; // 0x29eec
    if (v1) {
        result = function_29f54();
    }
    // 0x29ef0
    return result;
}

// Address range: 0x29efa - 0x29efc
int32_t function_29efa(int32_t a1) {
    // 0x29efa
    int32_t v1; // 0x29efa
    return function_29aa4(a1, v1, v1, v1);
}

// Address range: 0x29efe - 0x29f00
int32_t function_29efe(void) {
    // 0x29efe
    return function_2a5a8();
}

// Address range: 0x29f00 - 0x29f08
int32_t function_29f00(void) {
    // 0x29f00
    int32_t result; // 0x29f00
    return result;
}

// Address range: 0x29f0a - 0x29f0c
int32_t function_29f0a(int32_t a1) {
    // 0x29f0a
    int32_t v1; // 0x29f0a
    return function_2a58e(a1, v1);
}

// Address range: 0x29f0e - 0x29f10
int32_t function_29f0e(int32_t a1) {
    // 0x29f0e
    return function_29ab8(a1);
}

// Address range: 0x29f10 - 0x29f18
int32_t function_29f10(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x29f10
    return result;
}

// Address range: 0x29f1a - 0x29f1c
int32_t function_29f1a(void) {
    // 0x29f1a
    return function_2a528();
}

// Address range: 0x29f1c - 0x29f20
int32_t function_29f1c(int32_t a1) {
    // 0x29f1c
    return function_2a5a2(a1 + 6);
}

// Address range: 0x29f20 - 0x29f24
int32_t function_29f20(int32_t result) {
    // 0x29f20
    return result;
}

// Address range: 0x29f26 - 0x29f28
int32_t function_29f26(void) {
    // 0x29f26
    int32_t v1; // 0x29f26
    return function_2a5d0(v1, v1);
}

// Address range: 0x29f2a - 0x29f30
int32_t function_29f2a(void) {
    // 0x29f2a
    int32_t v1; // 0x29f2a
    return function_2a550(v1);
}

// Address range: 0x29f30 - 0x29f34
int32_t function_29f30(int32_t a1) {
    // 0x29f30
    return function_2aa04();
}

// Address range: 0x29f36 - 0x29f38
int32_t function_29f36(int32_t a1) {
    // 0x29f36
    return function_2a5ba(a1);
}

// Address range: 0x29f3a - 0x29f3c
int32_t function_29f3a(void) {
    // 0x29f3a
    int32_t v1; // 0x29f3a
    return function_2a458(v1);
}

// Address range: 0x29f3e - 0x29f40
int32_t function_29f3e(int16_t a1) {
    // 0x29f3e
    return function_2a282(a1);
}

// Address range: 0x29f40 - 0x29f44
int32_t function_29f40(void) {
    // 0x29f40
    int32_t str; // 0x29f40
    return snprintf((char *)str, str, (char *)str);
}

// Address range: 0x29f46 - 0x29f48
int32_t function_29f46(void) {
    // 0x29f46
    return function_2a464();
}

// Address range: 0x29f4a - 0x29f4c
int32_t function_29f4a(void) {
    // 0x29f4a
    return function_2a1ba();
}

// Address range: 0x29f4c - 0x29f50
int32_t function_29f4c(int32_t a1) {
    // 0x29f4c
    return function_2ad3c();
}

// Address range: 0x29f50 - 0x29f54
int32_t function_29f50(void) {
    // 0x29f50
    int32_t v1; // 0x29f50
    return function_1ccec(v1, (int32_t *)v1, v1);
}

// Address range: 0x29f54 - 0x29f55
int32_t function_29f54(void) {
    // 0x29f54
    int32_t result; // 0x29f54
    return result;
}

// Address range: 0x29f56 - 0x29f58
int32_t function_29f56(int32_t a1) {
    // 0x29f56
    return function_2ac84(a1);
}

// Address range: 0x29f58 - 0x29f60
int32_t function_29f58(void) {
    // 0x29f58
    int32_t v1; // 0x29f58
    free((int32_t *)v1);
    return &g306;
}

// Address range: 0x29f60 - 0x29f64
int32_t function_29f60(void) {
    // 0x29f60
    return function_2a566();
}

// Address range: 0x29f66 - 0x29f68
int32_t function_29f66(void) {
    // 0x29f66
    int32_t result; // 0x29f66
    return result;
}

// Address range: 0x29f68 - 0x29f74
int32_t function_29f68(void) {
    // 0x29f68
    int32_t result; // 0x29f68
    int32_t v1; // 0x29f68
    if ((char)v1 != 0) {
        result = function_29fc4();
    }
    // 0x29f74
    return result;
}

// Address range: 0x29f76 - 0x29f78
int32_t function_29f76(int32_t a1) {
    // 0x29f76
    return function_2a0b2(a1);
}

// Address range: 0x29f78 - 0x29f7c
int32_t function_29f78(int32_t a1) {
    // 0x29f78
    return function_2aa88(a1 + 6);
}

// Address range: 0x29f7c - 0x29f80
int32_t function_29f7c(int32_t result) {
    // 0x29f7c
    return result;
}

// Address range: 0x29f80 - 0x29f84
int32_t function_29f80(int32_t a1) {
    // 0x29f80
    int32_t v1; // 0x29f80
    return function_2a62c(a1, v1);
}

// Address range: 0x29f86 - 0x29f8c
int32_t function_29f86(int32_t a1) {
    // 0x29f86
    return function_2a598(0);
}

// Address range: 0x29f8c - 0x29f90
int32_t function_29f8c(int32_t a1) {
    // 0x29f8c
    return function_2a13c(a1 + 6);
}

// Address range: 0x29f90 - 0x29f94
int32_t function_29f90(int32_t result) {
    // 0x29f90
    return result;
}

// Address range: 0x29f96 - 0x29f98
int32_t function_29f96(int32_t a1) {
    // 0x29f96
    return function_2a640(a1);
}

// Address range: 0x29f98 - 0x29fa4
int32_t function_29f98(void) {
    // 0x29f98
    bool v1; // 0x29f98
    if (!v1 && true) {
        function_29fc4();
    }
    // 0x29f9c
    return 0;
}

// Address range: 0x29fa6 - 0x29fa8
int32_t function_29fa6(void) {
    // 0x29fa6
    return function_2a2ea();
}

// Address range: 0x29fa8 - 0x29fac
int32_t function_29fa8(int32_t a1) {
    // 0x29fa8
    return function_2a80c(a1);
}

// Address range: 0x29fac - 0x29fb0
int32_t function_29fac(void) {
    // 0x29fac
    return function_2a2f2();
}

// Address range: 0x29fb0 - 0x29fb4
int32_t function_29fb0(int32_t a1) {
    // 0x29fb0
    *(int16_t *)a1 = (int16_t)a1;
    return function_2aa3a();
}

// Address range: 0x29fb6 - 0x29fb8
int32_t function_29fb6(int32_t a1) {
    // 0x29fb6
    return __asm_adr(a1);
}

// Address range: 0x29fb8 - 0x29fc4
int32_t function_29fb8(void) {
    // 0x29fb8
    int32_t result; // 0x29fb8
    return result;
}

// Address range: 0x29fc4 - 0x29fc5
int32_t function_29fc4(void) {
    // 0x29fc4
    int32_t result; // 0x29fc4
    return result;
}

// Address range: 0x29fc6 - 0x29fc8
int32_t function_29fc6(int32_t a1) {
    // 0x29fc6
    int32_t v1; // 0x29fc6
    return function_2a5e8(v1);
}

// Address range: 0x29fc8 - 0x29fcc
int32_t function_29fc8(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x29fc8
    *(int32_t *)a1 = a4;
    return function_2a4e8();
}

// Address range: 0x29fcc - 0x29fce
int32_t function_29fcc(void) {
    // 0x29fcc
    return function_29fd8();
}

// Address range: 0x29fce - 0x29fd0
int32_t function_29fce(void) {
    // 0x29fce
    int32_t v1; // 0x29fce
    return function_2a652(v1, v1, v1);
}

// Address range: 0x29fd0 - 0x29fd4
int32_t function_29fd0(int32_t a1) {
    // 0x29fd0
    *(int32_t *)a1 = a1;
    return function_2a716(a1);
}

// Address range: 0x29fd8 - 0x29fdc
int32_t function_29fd8(void) {
    // 0x29fd8
    int32_t v1; // 0x29fd8
    return function_2a67c(v1, v1);
}

// Address range: 0x29fdc - 0x29fe0
int32_t function_29fdc(int32_t a1) {
    // 0x29fdc
    *(char *)a1 = (char)a1;
    return function_2a722();
}

// Address range: 0x29fe0 - 0x29ff0
int32_t function_29fe0(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x29fe0
    int32_t v1; // 0x29fe0
    int32_t v2 = v1;
    *(int32_t *)v1 = a1;
    *(int32_t *)(v1 + 4) = a2;
    *(int32_t *)(v1 + 8) = a3;
    *(int32_t *)(v1 + 12) = a4;
    int32_t v3 = v1 + 16; // 0x29fe2
    *(int32_t *)v3 = a4;
    *(int32_t *)(v1 + 24) = v3;
    return function_2a50c(v2, *(int32_t *)(v2 + 4));
}

// Address range: 0x29ff2 - 0x29ff4
int32_t function_29ff2(void) {
    // 0x29ff2
    return function_2aa7a();
}

// Address range: 0x29ff4 - 0x29ff8
int32_t function_29ff4(int32_t a1) {
    // 0x29ff4
    return function_2a73a();
}

// Address range: 0x29ff8 - 0x29ffc
int32_t function_29ff8(int32_t a1) {
    // 0x29ff8
    return function_2a272(0);
}

// Address range: 0x29ffc - 0x2a024
int32_t function_29ffc(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x29ffc
    int32_t v1; // 0x29ffc
    *(int16_t *)v1 = (int16_t)a4;
    *(char *)(v1 + 2) = (char)v1;
    function_1ccec(a1, (int32_t *)a2, a3);
    return 0;
}

// Address range: 0x2a024 - 0x2a060
int32_t function_2a024(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x2a024
    unknown_42a668();
    float128_t v1; // 0x2a024
    float64_t v2; // 0x2a024
    __asm_vqrdmulh_s32(v1, v2);
    int32_t v3; // 0x2a024
    return -1 - v3;
}

// Address range: 0x2a064 - 0x2a07c
int32_t function_2a064(int32_t a1) {
    // 0x2a064
    return g247 - *(int32_t *)(a1 + 232);
}

// Address range: 0x2a07c - 0x2a084
int32_t function_2a07c(int32_t * a1, int32_t a2, int32_t a3) {
    // 0x2a07c
    return function_2a3c6();
}

// Address range: 0x2a084 - 0x2a088
int32_t function_2a084(int32_t result, int32_t a2) {
    // 0x2a084
    return result;
}

// Address range: 0x2a088 - 0x2a089
int32_t function_2a088(void) {
    // 0x2a088
    int32_t result; // 0x2a088
    return result;
}

// Address range: 0x2a08c - 0x2a090
int32_t function_2a08c(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x2a08c
    return result;
}

// Address range: 0x2a090 - 0x2a094
int32_t function_2a090(int32_t a1, int32_t a2, int32_t a3) {
    // 0x2a090
    return function_2a374((int32_t)&g306);
}

// Address range: 0x2a094 - 0x2a098
int32_t function_2a094(void) {
    // 0x2a094
    return function_2a3da();
}

// Address range: 0x2a098 - 0x2a0a4
int32_t function_2a098(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x2a098
    *(int16_t *)a3 = (int16_t)a1;
    return function_2a3e6();
}

// Address range: 0x2a0a4 - 0x2a0ac
int32_t function_2a0a4(int32_t result) {
    // 0x2a0a4
    int32_t v1; // 0x2a0a4
    __asm_stc(0, 1, v1);
    return result;
}

// Address range: 0x2a0b0 - 0x2a0b1
int32_t function_2a0b0(void) {
    // 0x2a0b0
    int32_t result; // 0x2a0b0
    return result;
}

// Address range: 0x2a0b2 - 0x2a0b3
int32_t function_2a0b2(int32_t a1) {
    // 0x2a0b2
    int32_t result; // 0x2a0b2
    return result;
}

// Address range: 0x2a0b8 - 0x2a0ba
int32_t function_2a0b8(int32_t a1, int32_t a2) {
    // 0x2a0b8
    return (int32_t)*(char *)(a2 + 12);
}

// Address range: 0x2a0ba - 0x2a0be
int32_t function_2a0ba(void) {
    // 0x2a0ba
    int32_t result; // 0x2a0ba
    bool v1; // 0x2a0ba
    if (v1) {
        result = function_625ade();
    }
    // 0x2a0be
    return result;
}

// Address range: 0x2a0c2 - 0x2a0c3
int32_t function_2a0c2(void) {
    // 0x2a0c2
    int32_t result; // 0x2a0c2
    return result;
}

// Address range: 0x2a0c4 - 0x2a0c8
int32_t function_2a0c4(void) {
    // 0x2a0c4
    return function_2a452();
}

// Address range: 0x2a0c8 - 0x2a0d0
int32_t function_2a0c8(int32_t a1, int32_t a2) {
    // 0x2a0c8
    __asm_ldc(0, 0, a2, 4);
    return function_2a378(a1);
}

// Address range: 0x2a0d0 - 0x2a0d4
int32_t function_2a0d0(int32_t result, int32_t a2, int32_t a3) {
    // 0x2a0d0
    return result;
}

// Address range: 0x2a0d4 - 0x2a0de
int32_t function_2a0d4(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    int16_t v1 = result; // 0x2a0da
    int32_t v2; // 0x2a0d4
    *(int16_t *)(v2 + 28) = v1;
    *(int16_t *)a3 = v1;
    return result;
}

// Address range: 0x2a0e0 - 0x2a0ec
int32_t function_2a0e0(int32_t a1) {
    // 0x2a0e0
    float128_t v1; // 0x2a0e0
    float64_t v2; // 0x2a0e0
    __asm_vmla_f32(v1, v1, v2);
    return function_2a696(a1 + 36);
}

// Address range: 0x2a0ec - 0x2a0f0
int32_t function_2a0ec(int32_t a1) {
    // 0x2a0ec
    return function_29c18();
}

// Address range: 0x2a0f0 - 0x2a0f4
int32_t function_2a0f0(int32_t a1) {
    // 0x2a0f0
    return function_2a39a();
}

// Address range: 0x2a0f6 - 0x2a0fc
int32_t function_2a0f6(int32_t a1) {
    // 0x2a0f6
    return function_2a36a();
}

// Address range: 0x2a0fc - 0x2a100
int32_t function_2a0fc(void) {
    // 0x2a0fc
    return function_29c08();
}

// Address range: 0x2a100 - 0x2a104
int32_t function_2a100(void) {
    // 0x2a100
    int32_t result; // 0x2a100
    return result;
}

// Address range: 0x2a104 - 0x2a108
int32_t function_2a104(void) {
    // 0x2a104
    return function_2a632();
}

// Address range: 0x2a108 - 0x2a10c
int32_t function_2a108(void) {
    // 0x2a108
    return 7;
}

// Address range: 0x2a10c - 0x2a110
int32_t function_2a10c(void) {
    // 0x2a10c
    return 0;
}

// Address range: 0x2a110 - 0x2a11c
int32_t function_2a110(int32_t result, int32_t a2, int32_t a3) {
    // 0x2a110
    return result;
}

// Address range: 0x2a11e - 0x2a120
int32_t function_2a11e(void) {
    // 0x2a11e
    return function_2a2e0();
}

// Address range: 0x2a120 - 0x2a13c
int32_t function_2a120(void) {
    // 0x2a120
    int32_t v1; // 0x2a120
    return (uint32_t)v1 % 256;
}

// Address range: 0x2a13c - 0x2a142
int32_t function_2a13c(int32_t a1) {
    // 0x2a13c
    float64_t v1; // 0x2a13c
    __asm_vrhadd_u16(v1, v1);
    int32_t result; // 0x2a13c
    return result;
}

// Address range: 0x2a142 - 0x2a144
int32_t function_2a142(void) {
    // 0x2a142
    return function_29ba0();
}

// Address range: 0x2a144 - 0x2a150
int32_t function_2a144(int32_t a1) {
    // 0x2a146
    return function_2a5e4(a1);
    int32_t v1 = a1; // 0x2a14c
    bool v2; // 0x2a144
    if (v2) {
        v1 = __asm_adr((int32_t)&g306);
    }
    // 0x2a14e
    return function_2a5ec(v1);
}

// Address range: 0x2a150 - 0x2a154
int32_t function_2a150(void) {
    // 0x2a150
    return function_2a774();
}

// Address range: 0x2a154 - 0x2a158
int32_t function_2a154(int32_t a1, int32_t a2) {
    // 0x2a154
    return function_2a674();
}

// Address range: 0x2a158 - 0x2a15c
int32_t function_2a158(void) {
    // 0x2a158
    return function_2a554(4);
}

// Address range: 0x2a15c - 0x2a160
int32_t function_2a15c(int32_t a1) {
    // 0x2a15c
    return a1 + 8;
}

// Address range: 0x2a162 - 0x2a164
int32_t function_2a162(int32_t a1) {
    // 0x2a162
    return function_2a3b8(a1);
}

// Address range: 0x2a164 - 0x2a165
int32_t function_2a164(void) {
    // 0x2a164
    int32_t result; // 0x2a164
    return result;
}

// Address range: 0x2a166 - 0x2a168
int32_t function_2a166(void) {
    // 0x2a166
    int32_t result; // 0x2a166
    return result;
}

// Address range: 0x2a168 - 0x2a16a
int32_t function_2a168(int32_t a1) {
    // 0x2a168
    return __asm_adr(a1);
}

// Address range: 0x2a16c - 0x2a170
int32_t function_2a16c(int32_t a1, int32_t a2) {
    // 0x2a16c
    return function_2a68c(0);
}

// Address range: 0x2a170 - 0x2a18c
int32_t function_2a170(void) {
    // 0x2a170
    int32_t v1; // 0x2a170
    function_1ccec(6, (int32_t *)v1, 0);
    return 0;
}

// Address range: 0x2a18c - 0x2a1b8
int32_t function_2a18c(int32_t a1, int32_t a2) {
    int32_t result = a1; // 0x2a1b0
    if (g94 == 0) {
        result = function_2a424();
    }
    // 0x2a1b4
    return result;
}

// Address range: 0x2a1ba - 0x2a1bc
int32_t function_2a1ba(void) {
    // 0x2a1ba
    int32_t v1; // 0x2a1ba
    return function_2a6d8(v1, v1, v1);
}

// Address range: 0x2a1bc - 0x2a1c0
int32_t function_2a1bc(int32_t a1) {
    // 0x2a1bc
    return function_2a902();
}

// Address range: 0x2a1c0 - 0x2a1c4
int32_t function_2a1c0(int32_t a1) {
    // 0x2a1c0
    int32_t v1; // 0x2a1c0
    *(int32_t *)(v1 + 4) = a1;
    return function_2a6e0(a1);
}

// Address range: 0x2a1c6 - 0x2a1c7
int32_t function_2a1c6(void) {
    // 0x2a1c6
    int32_t result; // 0x2a1c6
    return result;
}

// Address range: 0x2a1c8 - 0x2a1cc
int32_t function_2a1c8(int32_t a1) {
    // 0x2a1c8
    *(char *)(a1 + 1) = (char)a1;
    int32_t v1; // 0x2a1c8
    return function_2a6d8(a1, v1, v1);
}

// Address range: 0x2a1cc - 0x2a1d0
int32_t function_2a1cc(int32_t a1, int32_t a2, int32_t a3) {
    // 0x2a1cc
    *(int32_t *)a1 = a1;
    *(int32_t *)(a1 + 4) = a3;
    return function_2a512(a1 + 8);
}

// Address range: 0x2a1d0 - 0x2a1d4
int32_t function_2a1d0(void) {
    // 0x2a1d0
    return function_2ae24(0);
}

// Address range: 0x2a1d4 - 0x2a1d8
int32_t function_2a1d4(int32_t a1) {
    // 0x2a1d4
    return function_2a6f4(a1 + 64);
}

// Address range: 0x2a1d8 - 0x2a1dc
int32_t function_2a1d8(void) {
    // 0x2a1d8
    return 60;
}

// Address range: 0x2a1dc - 0x2a1e0
int32_t function_2a1dc(void) {
    // 0x2a1dc
    return 4;
}

// Address range: 0x2a1e0 - 0x2a1e4
int32_t function_2a1e0(void) {
    // 0x2a1e0
    return 8;
}

// Address range: 0x2a1e4 - 0x2a1e8
int32_t function_2a1e4(void) {
    // 0x2a1e4
    return 12;
}

// Address range: 0x2a1e8 - 0x2a1ec
int32_t function_2a1e8(void) {
    // 0x2a1e8
    return 16;
}

// Address range: 0x2a1ec - 0x2a1ed
int32_t function_2a1ec(void) {
    // 0x2a1ec
    int32_t result; // 0x2a1ec
    return result;
}

// Address range: 0x2a1ee - 0x2a1f0
int32_t function_2a1ee(void) {
    // 0x2a1ee
    int32_t result; // 0x2a1ee
    return result;
}

// Address range: 0x2a1f0 - 0x2a1f4
int32_t function_2a1f0(int32_t a1) {
    // 0x2a1f0
    return function_2a70e(a1 + 4);
}

// Address range: 0x2a1f4 - 0x2a1f5
int32_t function_2a1f4(void) {
    // 0x2a1f4
    int32_t result; // 0x2a1f4
    return result;
}

// Address range: 0x2a1f6 - 0x2a1f8
int32_t function_2a1f6(void) {
    // 0x2a1f6
    int32_t result; // 0x2a1f6
    return result;
}

// Address range: 0x2a1f8 - 0x2a220
int32_t function_2a1f8(int32_t a1, int32_t a2) {
    // 0x2a1f8
    int32_t v1; // 0x2a1f8
    *(int32_t *)v1 = a1;
    *(int32_t *)(v1 + 4) = a2;
    *(int32_t *)(v1 + 8) = *(int32_t *)(v1 - 8);
    *(int32_t *)(v1 + 12) = *(int32_t *)(v1 - 4);
    int32_t result = a1; // 0x2a210
    // 0x2a214
    return result;
}

// Address range: 0x2a222 - 0x2a224
int32_t function_2a222(void) {
    // 0x2a222
    int32_t v1; // 0x2a222
    return function_2a740(v1);
}

// Address range: 0x2a224 - 0x2a228
int32_t function_2a224(int32_t a1) {
    // 0x2a224
    return 4 * a1;
}

// Address range: 0x2a228 - 0x2a22a
int32_t function_2a228(void) {
    // 0x2a228
    int32_t v1; // 0x2a228
    return function_2a2cc(v1);
}

// Address range: 0x2a22a - 0x2a22c
int32_t function_2a22a(void) {
    // 0x2a22a
    int32_t v1; // 0x2a22a
    return function_2a748(v1, v1, v1, v1);
}

// Address range: 0x2a22c - 0x2a230
int32_t function_2a22c(int32_t result) {
    // 0x2a22c
    return result;
}

// Address range: 0x2a230 - 0x2a234
int32_t function_2a230(void) {
    // 0x2a230
    return 8;
}

// Address range: 0x2a234 - 0x2a238
int32_t function_2a234(int32_t a1) {
    // 0x2a234
    return a1 + 12;
}

// Address range: 0x2a238 - 0x2a240
int32_t function_2a238(int32_t result, int32_t a2) {
    // 0x2a238
    return result;
}

// Address range: 0x2a240 - 0x2a244
int32_t function_2a240(int32_t result, int32_t a2, int32_t a3) {
    // 0x2a240
    return result;
}

// Address range: 0x2a244 - 0x2a248
int32_t function_2a244(void) {
    // 0x2a244
    return 24;
}

// Address range: 0x2a248 - 0x2a24c
int32_t function_2a248(int32_t a1) {
    // 0x2a248
    return a1 + 28;
}

// Address range: 0x2a24e - 0x2a24f
int32_t function_2a24e(void) {
    // 0x2a24e
    int32_t result; // 0x2a24e
    return result;
}

// Address range: 0x2a250 - 0x2a254
int32_t function_2a250(int32_t result) {
    // 0x2a250
    return result;
}

// Address range: 0x2a254 - 0x2a258
int32_t function_2a254(int32_t result) {
    // 0x2a254
    return result;
}

// Address range: 0x2a258 - 0x2a25c
int32_t function_2a258(void) {
    // 0x2a258
    return 8;
}

// Address range: 0x2a25c - 0x2a264
int32_t function_2a25c(int32_t result) {
    // 0x2a25c
    int32_t v1; // 0x2a25c
    *(int32_t *)(v1 + 4) = result;
    return result;
}

// Address range: 0x2a264 - 0x2a268
int32_t function_2a264(int32_t result) {
    // 0x2a264
    return result;
}

// Address range: 0x2a268 - 0x2a26c
int32_t function_2a268(int32_t a1) {
    // 0x2a268
    return a1 + 12;
}

// Address range: 0x2a26c - 0x2a270
int32_t function_2a26c(void) {
    // 0x2a26c
    return 8;
}

// Address range: 0x2a272 - 0x2a278
int32_t function_2a272(int32_t a1) {
    // 0x2a272
    int32_t result; // 0x2a272
    return result;
}

// Address range: 0x2a278 - 0x2a27c
int32_t function_2a278(int32_t result, int32_t a2, int32_t a3) {
    // 0x2a278
    return result;
}

// Address range: 0x2a27c - 0x2a280
int32_t function_2a27c(void) {
    // 0x2a27c
    return 24;
}

// Address range: 0x2a280 - 0x2a281
int32_t function_2a280(void) {
    // 0x2a280
    int32_t result; // 0x2a280
    return result;
}

// Address range: 0x2a282 - 0x2a284
int32_t function_2a282(int16_t a1) {
    // 0x2a282
    int32_t result; // 0x2a282
    return result;
}

// Address range: 0x2a284 - 0x2a28c
int32_t function_2a284(int32_t a1, int32_t a2) {
    // 0x2a284
    return function_2a9ce();
}

// Address range: 0x2a28c - 0x2a298
int32_t function_2a28c(int32_t a1) {
    // 0x2a28c
    int32_t v1; // bp+112, 0x2a28c
    int32_t v2; // 0x2a28c
    function_261e0(&v1, v2);
    int32_t v3; // bp+16, 0x2a28c
    return &v3;
}

// Address range: 0x2a29a - 0x2a29c
int32_t function_2a29a(int32_t a1) {
    // 0x2a29a
    return function_2ac84(a1);
}

// Address range: 0x2a29c - 0x2a2cc
int32_t function_2a29c(void) {
    // 0x2a29c
    int32_t v1; // 0x2a29c
    function_261e0((int32_t *)v1, v1);
    int32_t v2; // bp+48, 0x2a29c
    function_261e0(&v2, 12);
    int32_t v3; // bp+80, 0x2a29c
    function_261e0(&v3, 32);
    return function_1e9b4(v1, 128);
}

// Address range: 0x2a2cc - 0x2a2d0
int32_t function_2a2cc(int32_t a1) {
    // 0x2a2cc
    return function_2aa12(a1 >> 1);
}

// Address range: 0x2a2d0 - 0x2a2e0
int32_t function_2a2d0(int32_t a1, int32_t a2, int32_t a3) {
    // 0x2a2d0
    return function_1e9b4(a3, a2);
}

// Address range: 0x2a2e0 - 0x2a2e4
int32_t function_2a2e0(void) {
    // 0x2a2e0
    return function_2a150();
}

// Address range: 0x2a2e6 - 0x2a2e8
int32_t function_2a2e6(int32_t a1) {
    // 0x2a2e6
    return function_2a554(a1);
}

// Address range: 0x2a2e8 - 0x2a2ea
int32_t function_2a2e8(void) {
    // 0x2a2e8
    int32_t result; // 0x2a2e8
    return result;
}

// Address range: 0x2a2ea - 0x2a2eb
int32_t function_2a2ea(void) {
    // 0x2a2ea
    int32_t result; // 0x2a2ea
    return result;
}

// Address range: 0x2a2ee - 0x2a2f0
int32_t function_2a2ee(int32_t a1) {
    // 0x2a2ee
    return function_2a80c(a1);
}

// Address range: 0x2a2f0 - 0x2a2f1
int32_t function_2a2f0(void) {
    // 0x2a2f0
    int32_t result; // 0x2a2f0
    return result;
}

// Address range: 0x2a2f2 - 0x2a2f4
int32_t function_2a2f2(void) {
    // 0x2a2f2
    int32_t v1; // 0x2a2f2
    return function_2a3b8(v1);
}

// Address range: 0x2a2f6 - 0x2a2f8
int32_t function_2a2f6(void) {
    // 0x2a2f6
    return function_2aa3a();
}

// Address range: 0x2a2f8 - 0x2a2f9
int32_t function_2a2f8(void) {
    // 0x2a2f8
    int32_t result; // 0x2a2f8
    return result;
}

// Address range: 0x2a2fa - 0x2a2fc
int32_t function_2a2fa(int32_t a1) {
    // 0x2a2fa
    int32_t v1; // 0x2a2fa
    return __asm_adr(v1);
}

// Address range: 0x2a2fc - 0x2a310
int32_t function_2a2fc(void) {
    // 0x2a2fc
    int32_t v1; // 0x2a2fc
    function_1e9b4(v1, v1);
    return function_1e9b4(v1, 4);
}

// Address range: 0x2a310 - 0x2a314
int32_t function_2a310(int32_t a1) {
    // 0x2a310
    return function_2aa56();
}

// Address range: 0x2a314 - 0x2a318
int32_t function_2a314(int32_t result) {
    // 0x2a314
    *(int32_t *)result = result;
    return result;
}

// Address range: 0x2a318 - 0x2a31c
int32_t function_2a318(int32_t result, int32_t a2) {
    // 0x2a318
    return result;
}

// Address range: 0x2a31c - 0x2a31e
int32_t function_2a31c(void) {
    // 0x2a31c
    int32_t result; // 0x2a31c
    return result;
}

// Address range: 0x2a31e - 0x2a31f
int32_t function_2a31e(void) {
    // 0x2a31e
    int32_t result; // 0x2a31e
    return result;
}

// Address range: 0x2a320 - 0x2a324
int32_t function_2a320(void) {
    // 0x2a320
    int32_t v1; // 0x2a320
    return function_2a840(80, v1, v1, v1);
}

// Address range: 0x2a324 - 0x2a334
int32_t function_2a324(int32_t a1, int32_t a2, int32_t a3) {
    // 0x2a324
    return function_1e9b4(a3, 32);
}

// Address range: 0x2a336 - 0x2a338
int32_t function_2a336(void) {
    // 0x2a336
    return function_2aa7a();
}

// Address range: 0x2a338 - 0x2a33c
int32_t function_2a338(int32_t a1) {
    // 0x2a338
    return function_2a67e();
}

// Address range: 0x2a33c - 0x2a350
int32_t function_2a33c(void) {
    // 0x2a33c
    int32_t v1; // 0x2a33c
    return function_1e9b4(v1 + 444, v1);
}

// Address range: 0x2a352 - 0x2a354
int32_t function_2a352(int32_t a1) {
    // 0x2a352
    int32_t v1; // 0x2a352
    return function_2a696(v1);
}

// Address range: 0x2a354 - 0x2a358
int32_t function_2a354(int32_t a1) {
    // 0x2a354
    return function_2a58c();
}

// Address range: 0x2a358 - 0x2a35c
int32_t function_2a358(int32_t a1) {
    // 0x2a358
    return function_2ade2();
}

// Address range: 0x2a35c - 0x2a360
int32_t function_2a35c(int32_t result) {
    // 0x2a35c
    *(int32_t *)result = result;
    return result;
}

// Address range: 0x2a360 - 0x2a364
int32_t function_2a360(void) {
    // 0x2a360
    return function_2aaf2(8);
}

// Address range: 0x2a364 - 0x2a368
int32_t function_2a364(int32_t a1) {
    // 0x2a364
    return function_29e84();
}

// Address range: 0x2a36a - 0x2a36b
int32_t function_2a36a(void) {
    // 0x2a36a
    int32_t result; // 0x2a36a
    return result;
}

// Address range: 0x2a36c - 0x2a370
int32_t function_2a36c(int32_t a1) {
    // 0x2a36c
    int32_t v1; // 0x2a36c
    return function_2a88c(176, v1);
}

// Address range: 0x2a370 - 0x2a374
int32_t function_2a370(int32_t a1) {
    // 0x2a370
    return function_2a6b6();
}

// Address range: 0x2a374 - 0x2a376
int32_t function_2a374(int32_t a1) {
    // 0x2a374
    int32_t result; // 0x2a374
    return result;
}

// Address range: 0x2a378 - 0x2a37c
int32_t function_2a378(int32_t a1) {
    // 0x2a378
    int32_t v1; // 0x2a378
    return function_2a898(a1 + 12, v1);
}

// Address range: 0x2a37c - 0x2a398
int32_t function_2a37c(int32_t size) {
    // 0x2a37c
    int32_t data; // 0x2a37c
    int32_t * stream = (int32_t *)(data + 1056); // 0x2a380
    fwrite((int32_t *)data, size, 1, (struct _IO_FILE *)*stream);
    return fflush((struct _IO_FILE *)*stream);
}

// Address range: 0x2a39a - 0x2a39c
int32_t function_2a39a(void) {
    // 0x2a39a
    int32_t v1; // 0x2a39a
    return function_29ed8(v1, v1);
}

// Address range: 0x2a39c - 0x2a3b8
int32_t function_2a39c(int32_t a1) {
    int32_t v1 = 0; // 0x2a3a0
    if (a1 != 0) {
        // 0x2a3a4
        free((int32_t *)a1);
        v1 = &g306;
    }
    int32_t v2; // 0x2a39c
    if (v2 == 0) {
        function_2a3b8(v1);
    }
    // 0x2a3b0
    free((int32_t *)v2);
    return &g306;
}

// Address range: 0x2a3b8 - 0x2a3ba
int32_t function_2a3b8(int32_t result) {
    // 0x2a3b8
    return result;
}

// Address range: 0x2a3ba - 0x2a3bc
int32_t function_2a3ba(void) {
    // 0x2a3ba
    return function_2aa6e();
}

// Address range: 0x2a3bc - 0x2a3c4
int32_t function_2a3bc(void) {
    // 0x2a3bc
    bool v1; // 0x2a3bc
    if (v1) {
        function_2a3c8();
    }
    // 0x2a3c0
    int32_t result; // 0x2a3bc
    return result;
}

// Address range: 0x2a3c6 - 0x2a3c7
int32_t function_2a3c6(void) {
    // 0x2a3c6
    int32_t result; // 0x2a3c6
    return result;
}

// Address range: 0x2a3c8 - 0x2a3cc
int32_t function_2a3c8(void) {
    // 0x2a3c8
    int32_t result; // 0x2a3c8
    return result;
}

// Address range: 0x2a3cc - 0x2a3d4
int32_t function_2a3cc(uint32_t a1) {
    // 0x2a3cc
    return function_2a716(a1 / 256);
}

// Address range: 0x2a3d4 - 0x2a3d8
int32_t function_2a3d4(void) {
    // 0x2a3d4
    int32_t v1; // 0x2a3d4
    free((int32_t *)v1);
    return &g306;
}

// Address range: 0x2a3d8 - 0x2a3d9
int32_t function_2a3d8(void) {
    // 0x2a3d8
    int32_t result; // 0x2a3d8
    return result;
}

// Address range: 0x2a3da - 0x2a3dc
int32_t function_2a3da(void) {
    // 0x2a3da
    int32_t result; // 0x2a3da
    return result;
}

// Address range: 0x2a3dc - 0x2a3e4
int32_t function_2a3dc(void) {
    // 0x2a3dc
    bool v1; // 0x2a3dc
    int32_t result; // 0x2a3dc
    if (v1) {
        function_2a3e8(result);
    }
    // 0x2a3e0
    return result;
}

// Address range: 0x2a3e6 - 0x2a3e7
int32_t function_2a3e6(void) {
    // 0x2a3e6
    int32_t result; // 0x2a3e6
    return result;
}

// Address range: 0x2a3e8 - 0x2a3ec
int32_t function_2a3e8(int32_t a1) {
    // 0x2a3e8
    return function_2a0ec(a1);
}

// Address range: 0x2a3ec - 0x2a3f8
int32_t function_2a3ec(void) {
    // 0x2a3ec
    bool v1; // 0x2a3ec
    int32_t v2; // 0x2a3ec
    if (v1) {
        function_2a3f8(v2);
    }
    // 0x2a3f0
    free((int32_t *)v2);
    return &g306;
}

// Address range: 0x2a3f8 - 0x2a3fc
int32_t function_2a3f8(int32_t a1) {
    // 0x2a3f8
    int32_t v1; // 0x2a3f8
    return function_2aab0(a1, v1);
}

// Address range: 0x2a3fc - 0x2a424
int32_t function_2a3fc(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    // 0x2a3fc
    int32_t result; // 0x2a3fc
    bool v1; // 0x2a3fc
    int32_t v2; // 0x2a3fc
    if (v2 != 0 && v1) {
        // 0x2a410
        free((int32_t *)v2);
        result = &g306;
    }
    // 0x2a400
    return result;
}

// Address range: 0x2a424 - 0x2a440
int32_t function_2a424(void) {
    int32_t result = (int32_t)fopen64("/nvdata/worklog.txt", "wb"); // 0x2a434
    int32_t v1; // 0x2a424
    *(int32_t *)(v1 + 1056) = result;
    return result;
}

// Address range: 0x2a440 - 0x2a442
int32_t function_2a440(void) {
    // 0x2a440
    int32_t v1; // 0x2a440
    return function_2a44c(v1, v1);
}

// Address range: 0x2a442 - 0x2a444
int32_t function_2a442(void) {
    // 0x2a442
    int32_t result; // 0x2a442
    return result;
}

// Address range: 0x2a444 - 0x2a448
int32_t function_2a444(void) {
    // 0x2a444
    int32_t v1; // 0x2a444
    bool v2; // 0x2a444
    if (v2) {
        v1 = function_2a47c();
    }
    // 0x2a446
    return function_2a8e4(v1);
}

// Address range: 0x2a448 - 0x2a44c
int32_t function_2a448(void) {
    // 0x2a448
    int32_t v1; // 0x2a448
    return function_2a1cc(v1, v1, v1);
}

// Address range: 0x2a44c - 0x2a450
int32_t function_2a44c(int32_t a1, int32_t a2) {
    // 0x2a44c
    return function_2a96c(0);
}

// Address range: 0x2a452 - 0x2a454
int32_t function_2a452(void) {
    // 0x2a452
    int32_t result; // 0x2a452
    return result;
}

// Address range: 0x2a454 - 0x2a458
int32_t function_2a454(int32_t result) {
    // 0x2a454
    return result;
}

// Address range: 0x2a458 - 0x2a45c
int32_t function_2a458(int32_t a1) {
    // 0x2a458
    return function_29ff8(a1 + 4);
}

// Address range: 0x2a45c - 0x2a460
int32_t function_2a45c(void) {
    // 0x2a45c
    int32_t v1; // 0x2a45c
    return function_2a18c(v1, v1);
}

// Address range: 0x2a460 - 0x2a464
int32_t function_2a460(void) {
    // 0x2a460
    int32_t result; // 0x2a460
    bool v1; // 0x2a460
    if (v1) {
        result = function_2a47c();
    }
    // 0x2a462
    return result;
}

// Address range: 0x2a464 - 0x2a465
int32_t function_2a464(void) {
    // 0x2a464
    int32_t result; // 0x2a464
    return result;
}

// Address range: 0x2a466 - 0x2a468
int32_t function_2a466(void) {
    // 0x2a466
    int32_t result; // 0x2a466
    return result;
}

// Address range: 0x2a468 - 0x2a470
int32_t function_2a468(int32_t a1) {
    // 0x2a468
    int32_t v1; // 0x2a468
    return function_2a7b2(v1 & a1);
}

// Address range: 0x2a470 - 0x2a474
int32_t function_2a470(int32_t a1, int32_t a2) {
    // 0x2a470
    return function_2a0b2(a1);
}

// Address range: 0x2a474 - 0x2a478
int32_t function_2a474(void) {
    // 0x2a474
    int32_t v1; // 0x2a474
    bool v2; // 0x2a474
    if (v2) {
        int32_t v3; // 0x2a474
        v1 = function_2a490(v3, v3);
    }
    // 0x2a476
    return function_2a914(v1);
}

// Address range: 0x2a478 - 0x2a47c
int32_t function_2a478(int32_t a1, int32_t a2) {
    // 0x2a478
    *(int32_t *)(2 * a1) = a2;
    return function_2a7be();
}

// Address range: 0x2a47c - 0x2a47d
int32_t function_2a47c(void) {
    // 0x2a47c
    int32_t result; // 0x2a47c
    return result;
}

// Address range: 0x2a480 - 0x2a490
int32_t function_2a480(void) {
    // 0x2a480
    int32_t v1; // 0x2a480
    return *(int32_t *)(v1 + 220) == 0 ? v1 : 0;
}

// Address range: 0x2a490 - 0x2a494
int32_t function_2a490(int32_t a1, int32_t a2) {
    // 0x2a490
    return function_2a9b0(0, a2);
}

// Address range: 0x2a494 - 0x2a4ac
int32_t function_2a494(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x2a494
    int32_t v1; // 0x2a494
    int32_t v2 = llvm_bswap_i32(v1); // 0x2a494
    int32_t v3 = a2 - 8; // 0x2a49c
    *(int32_t *)v3 = v2;
    function_2a18c(v1, v3);
    return 1;
}

// Address range: 0x2a4ac - 0x2a4b4
int32_t function_2a4ac(int32_t a1, int32_t a2) {
    // 0x2a4ac
    int32_t result; // 0x2a4ac
    return result;
}

// Address range: 0x2a4b4 - 0x2a4b5
int32_t function_2a4b4(void) {
    // 0x2a4b4
    int32_t result; // 0x2a4b4
    return result;
}

// Address range: 0x2a4b8 - 0x2a4bc
int32_t function_2a4b8(int32_t a1) {
    // 0x2a4b8
    int32_t v1; // 0x2a4b8
    return function_2a7fe(a1, v1, v1, v1);
}

// Address range: 0x2a4bc - 0x2a4c0
int32_t function_2a4bc(void) {
    // 0x2a4bc
    int32_t result; // 0x2a4bc
    return result;
}

// Address range: 0x2a4c0 - 0x2a4c4
int32_t function_2a4c0(int32_t result) {
    // 0x2a4c0
    return result;
}

// Address range: 0x2a4c4 - 0x2a4cc
int32_t function_2a4c4(int32_t a1, int32_t a2) {
    // 0x2a4c4
    __asm_vhsub_s16((float64_t)(int64_t)a1, (float64_t)(int64_t)a2);
    return function_2aad6();
}

// Address range: 0x2a4cc - 0x2a4d0
int32_t function_2a4cc(int32_t result, int32_t a2, int32_t a3) {
    // 0x2a4cc
    return result;
}

// Address range: 0x2a4d0 - 0x2a4d4
int32_t function_2a4d0(void) {
    // 0x2a4d0
    int32_t v1; // 0x2a4d0
    return function_2aaf4(v1);
}

// Address range: 0x2a4d6 - 0x2a4d8
int32_t function_2a4d6(void) {
    // 0x2a4d6
    return function_2ac84((int32_t)&g306);
}

// Address range: 0x2a4d8 - 0x2a4dc
int32_t function_2a4d8(int32_t result) {
    // 0x2a4d8
    return result;
}

// Address range: 0x2a4dc - 0x2a4e0
int32_t function_2a4dc(void) {
    // 0x2a4dc
    int32_t result; // 0x2a4dc
    return result;
}

// Address range: 0x2a4e0 - 0x2a4e4
int32_t function_2a4e0(int32_t a1, int32_t a2, int32_t a3) {
    // 0x2a4e0
    return function_2aafc(a1, a2);
}

// Address range: 0x2a4e4 - 0x2a4e8
int32_t function_2a4e4(int32_t result, int32_t a2, int32_t a3) {
    // 0x2a4e4
    return result;
}

// Address range: 0x2a4e8 - 0x2a4ec
int32_t function_2a4e8(void) {
    // 0x2a4e8
    int32_t result; // 0x2a4e8
    return result;
}

// Address range: 0x2a4ec - 0x2a4f0
int32_t function_2a4ec(int32_t a1, int32_t a2, int32_t a3) {
    // 0x2a4ec
    *(int32_t *)a2 = a1;
    *(int32_t *)(a2 + 4) = a2;
    *(int32_t *)(a2 + 8) = a3;
    return function_2a0a4(a1);
}

// Address range: 0x2a4f0 - 0x2a4f4
int32_t function_2a4f0(void) {
    // 0x2a4f0
    int32_t v1; // 0x2a4f0
    int32_t result = function_2ab0c(v1, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306); // 0x2a4f2
    return result;
}

// Address range: 0x2a4f4 - 0x2a4f6
int32_t function_2a4f4(void) {
    // 0x2a4f4
    return function_2a7d0();
}

// Address range: 0x2a4f6 - 0x2a4f8
int32_t function_2a4f6(void) {
    // 0x2a4f6
    int32_t result; // 0x2a4f6
    return result;
}

// Address range: 0x2a4f8 - 0x2a4fa
int32_t function_2a4f8(void) {
    // 0x2a4f8
    return function_2a7b4();
}

// Address range: 0x2a4fa - 0x2a4fc
int32_t function_2a4fa(void) {
    // 0x2a4fa
    int32_t result; // 0x2a4fa
    return result;
}

// Address range: 0x2a4fc - 0x2a4fe
int32_t function_2a4fc(void) {
    // 0x2a4fc
    int32_t v1; // 0x2a4fc
    return function_2a7e0(v1, v1);
}

// Address range: 0x2a4fe - 0x2a500
int32_t function_2a4fe(void) {
    // 0x2a4fe
    int32_t result; // 0x2a4fe
    return result;
}

// Address range: 0x2a500 - 0x2a504
int32_t function_2a500(int32_t a1) {
    // 0x2a500
    return function_2a610();
}

// Address range: 0x2a504 - 0x2a506
int32_t function_2a504(void) {
    // 0x2a504
    return function_2a7b4();
}

// Address range: 0x2a506 - 0x2a508
int32_t function_2a506(void) {
    // 0x2a506
    int32_t result; // 0x2a506
    return result;
}

// Address range: 0x2a508 - 0x2a50c
int32_t function_2a508(void) {
    // 0x2a508
    int32_t result; // 0x2a508
    return result;
}

// Address range: 0x2a50c - 0x2a510
int32_t function_2a50c(int32_t a1, int32_t a2) {
    // 0x2a50c
    return function_2a13c(a1);
}

// Address range: 0x2a512 - 0x2a514
int32_t function_2a512(int32_t a1) {
    // 0x2a512
    return function_2a0c8(a1, (int32_t)&g306);
}

// Address range: 0x2a514 - 0x2a518
int32_t function_2a514(void) {
    // 0x2a514
    int32_t v1; // 0x2a514
    bool v2; // 0x2a514
    if (v2) {
        v1 = function_2a530((int32_t)&g306);
    }
    // 0x2a516
    return function_2a9b4(v1);
}

// Address range: 0x2a518 - 0x2a51c
int32_t function_2a518(int32_t a1, int32_t a2) {
    // 0x2a518
    return function_2a61e();
}

// Address range: 0x2a51c - 0x2a520
int32_t function_2a51c(int32_t a1, int32_t a2) {
    // 0x2a51c
    return function_2a622();
}

// Address range: 0x2a520 - 0x2a524
int32_t function_2a520(int32_t a1) {
    // 0x2a520
    return function_2a568(0);
}

// Address range: 0x2a524 - 0x2a528
int32_t function_2a524(int32_t a1) {
    // 0x2a524
    return function_2a5b0();
}

// Address range: 0x2a528 - 0x2a52c
int32_t function_2a528(void) {
    // 0x2a528
    return function_2a5b2();
}

// Address range: 0x2a52c - 0x2a530
int32_t function_2a52c(void) {
    // 0x2a52c
    int32_t v1; // 0x2a52c
    return function_2a578(v1, v1, v1, v1);
}

// Address range: 0x2a530 - 0x2a534
int32_t function_2a530(int32_t a1) {
    // 0x2a530
    return function_2a5ba(3);
}

// Address range: 0x2a534 - 0x2a538
int32_t function_2a534(int32_t a1) {
    // 0x2a534
    int32_t v1; // 0x2a534
    return function_2a5bc(a1, v1);
}

// Address range: 0x2a53a - 0x2a53c
int32_t function_2a53a(int32_t a1, int32_t a2) {
    // 0x2a53a
    return function_2a582(a1, a2);
}

// Address range: 0x2a53c - 0x2a540
int32_t function_2a53c(int32_t a1) {
    // 0x2a53c
    return function_2a5c4(a1);
}

// Address range: 0x2a540 - 0x2a544
int32_t function_2a540(int32_t a1) {
    // 0x2a540
    int32_t v1; // 0x2a540
    return function_2a5cc(a1 + 2, v1);
}

// Address range: 0x2a544 - 0x2a548
int32_t function_2a544(void) {
    // 0x2a544
    return function_2a58c();
}

// Address range: 0x2a548 - 0x2a54c
int32_t function_2a548(int32_t a1) {
    // 0x2a548
    int32_t v1; // 0x2a548
    return function_2a5d4(a1 + 1, v1, v1);
}

// Address range: 0x2a54c - 0x2a550
int32_t function_2a54c(void) {
    // 0x2a54c
    int32_t v1; // 0x2a54c
    return function_2a5d6(1, v1);
}

// Address range: 0x2a550 - 0x2a554
int32_t function_2a550(int32_t a1) {
    // 0x2a550
    int32_t v1; // 0x2a550
    return function_2a59c(a1 - 1, v1, v1);
}

// Address range: 0x2a554 - 0x2a558
int32_t function_2a554(int32_t a1) {
    // 0x2a554
    return function_2ad22(3);
}

// Address range: 0x2a558 - 0x2a55c
int32_t function_2a558(int32_t a1) {
    // 0x2a558
    return function_2a5e0();
}

// Address range: 0x2a55c - 0x2a560
int32_t function_2a55c(void) {
    // 0x2a55c
    return function_2a5a6();
}

// Address range: 0x2a560 - 0x2a564
int32_t function_2a560(int32_t a1) {
    // 0x2a560
    return function_2a5e8(a1);
}

// Address range: 0x2a566 - 0x2a568
int32_t function_2a566(void) {
    // 0x2a566
    int32_t v1; // 0x2a566
    return function_2a5f0(v1, v1);
}

// Address range: 0x2a568 - 0x2a56c
int32_t function_2a568(int32_t a1) {
    // 0x2a568
    return function_2a5b0();
}

// Address range: 0x2a56c - 0x2a570
int32_t function_2a56c(int32_t a1) {
    // 0x2a56c
    return function_2a5f8(a1 + 1);
}

// Address range: 0x2a570 - 0x2a574
int32_t function_2a570(int32_t result, int32_t a2) {
    // 0x2a570
    *(int32_t *)(2 * result) = a2;
    return result;
}

// Address range: 0x2a574 - 0x2a578
int32_t function_2a574(void) {
    // 0x2a574
    int32_t v1; // 0x2a574
    return function_2a5c0(v1, v1);
}

// Address range: 0x2a578 - 0x2a57c
int32_t function_2a578(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x2a578
    *(int32_t *)(2 * a1) = a4;
    return function_2a608(a1);
}

// Address range: 0x2a57c - 0x2a580
int32_t function_2a57c(void) {
    // 0x2a57c
    int32_t v1; // 0x2a57c
    return function_2a5cc(v1, v1);
}

// Address range: 0x2a582 - 0x2a584
int32_t function_2a582(int32_t a1, int32_t a2) {
    // 0x2a582
    int32_t v1; // 0x2a582
    return function_2a098(v1, v1, v1, (int32_t)&g306, (int32_t)&g306);
}

// Address range: 0x2a586 - 0x2a588
int32_t function_2a586(int32_t a1) {
    // 0x2a586
    return function_2a0b2(a1);
}

// Address range: 0x2a588 - 0x2a58c
int32_t function_2a588(int32_t result) {
    // 0x2a588
    return result;
}

// Address range: 0x2a58c - 0x2a58e
int32_t function_2a58c(void) {
    // 0x2a58c
    int32_t result; // 0x2a58c
    return result;
}

// Address range: 0x2a58e - 0x2a594
int32_t function_2a58e(int32_t a1, int32_t a2) {
    // 0x2a58e
    return function_2a0c2();
}

// Address range: 0x2a594 - 0x2a598
int32_t function_2a594(int32_t a1) {
    // 0x2a594
    return function_2acda();
}

// Address range: 0x2a598 - 0x2a59c
int32_t function_2a598(int32_t a1) {
    // 0x2a598
    return function_2a0b0();
}

// Address range: 0x2a59c - 0x2a5a0
int32_t function_2a59c(int32_t a1, int32_t a2, int32_t a3) {
    // 0x2a59c
    return function_2aab4(a1, a2);
}

// Address range: 0x2a5a2 - 0x2a5a4
int32_t function_2a5a2(int32_t a1) {
    // 0x2a5a2
    int32_t v1; // 0x2a5a2
    return function_2a0b8(a1, v1);
}

// Address range: 0x2a5a6 - 0x2a5a8
int32_t function_2a5a6(void) {
    // 0x2a5a6
    int32_t result; // 0x2a5a6
    return result;
}

// Address range: 0x2a5a8 - 0x2a5ac
int32_t function_2a5a8(void) {
    // 0x2a5a8
    int32_t v1; // 0x2a5a8
    return function_2a0d4(v1, 88, v1, v1);
}

// Address range: 0x2a5ac - 0x2a5b0
int32_t function_2a5ac(int32_t a1) {
    // 0x2a5ac
    return a1 + 16;
}

// Address range: 0x2a5b0 - 0x2a5b2
int32_t function_2a5b0(void) {
    // 0x2a5b0
    return 20;
}

// Address range: 0x2a5b2 - 0x2a5b4
int32_t function_2a5b2(void) {
    // 0x2a5b2
    int32_t result; // 0x2a5b2
    return result;
}

// Address range: 0x2a5b4 - 0x2a5b8
int32_t function_2a5b4(int32_t a1) {
    // 0x2a5b4
    return function_2a640(a1 + 2);
}

// Address range: 0x2a5ba - 0x2a5bc
int32_t function_2a5ba(int32_t a1) {
    // 0x2a5ba
    int32_t v1; // 0x2a5ba
    return function_2a0d0(a1, v1, v1);
}

// Address range: 0x2a5bc - 0x2a5c0
int32_t function_2a5bc(int32_t result, int32_t a2) {
    // 0x2a5bc
    return result;
}

// Address range: 0x2a5c0 - 0x2a5c2
int32_t function_2a5c0(int32_t result, int32_t a2) {
    // 0x2a5c0
    return result;
}

// Address range: 0x2a5c2 - 0x2a5c4
int32_t function_2a5c2(int32_t a1) {
    // 0x2a5c2
    return function_2a0ec(a1);
}

// Address range: 0x2a5c4 - 0x2a5c8
int32_t function_2a5c4(int32_t a1) {
    // 0x2a5c4
    return function_2a0f0(a1 + 16);
}

// Address range: 0x2a5c8 - 0x2a5cc
int32_t function_2a5c8(int32_t a1) {
    // 0x2a5c8
    int32_t v1; // 0x2a5c8
    return function_2a0d4(a1, v1, v1, v1);
}

// Address range: 0x2a5cc - 0x2a5d0
int32_t function_2a5cc(int32_t result, int32_t a2) {
    // 0x2a5cc
    return result;
}

// Address range: 0x2a5d0 - 0x2a5d4
int32_t function_2a5d0(int32_t a1, int32_t a2) {
    // 0x2a5d0
    return function_2a0fc();
}

// Address range: 0x2a5d4 - 0x2a5d6
int32_t function_2a5d4(int32_t a1, int32_t a2, int32_t a3) {
    // 0x2a5d4
    return 0;
}

// Address range: 0x2a5d6 - 0x2a5d8
int32_t function_2a5d6(int32_t a1, int32_t a2) {
    // 0x2a5d6
    return function_2a0e0(a1);
}

// Address range: 0x2a5d8 - 0x2a5dc
int32_t function_2a5d8(int32_t result, int32_t a2) {
    // 0x2a5d8
    return result;
}

// Address range: 0x2a5de - 0x2a5e0
int32_t function_2a5de(int32_t a1) {
    // 0x2a5de
    return function_2ad22(a1);
}

// Address range: 0x2a5e0 - 0x2a5e4
int32_t function_2a5e0(void) {
    // 0x2a5e0
    return function_2a10c();
}

// Address range: 0x2a5e4 - 0x2a5e8
int32_t function_2a5e4(int32_t a1) {
    // 0x2a5e4
    return a1 + 12;
}

// Address range: 0x2a5e8 - 0x2a5ec
int32_t function_2a5e8(int32_t a1) {
    // 0x2a5e8
    return function_2aaf4(a1 + 1);
}

// Address range: 0x2a5ec - 0x2a5f0
int32_t function_2a5ec(int32_t a1) {
    // 0x2a5ec
    return function_2a0f6(a1 + 12);
}

// Address range: 0x2a5f0 - 0x2a5f4
int32_t function_2a5f0(int32_t a1, int32_t a2) {
    // 0x2a5f0
    return function_2a2e0();
}

// Address range: 0x2a5f4 - 0x2a5f8
int32_t function_2a5f4(void) {
    // 0x2a5f4
    return function_2a120();
}

// Address range: 0x2a5f8 - 0x2a5fc
int32_t function_2a5f8(int32_t a1) {
    // 0x2a5f8
    return function_2a982(208);
}

// Address range: 0x2a5fe - 0x2a600
int32_t function_2a5fe(int32_t a1) {
    // 0x2a5fe
    return function_2aa88(a1);
}

// Address range: 0x2a600 - 0x2a604
int32_t function_2a600(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x2a600
    *(int32_t *)(2 * a1) = a4;
    return function_2a610();
}

// Address range: 0x2a604 - 0x2a608
int32_t function_2a604(int32_t a1, int32_t a2, int32_t a3) {
    // 0x2a604
    return function_2a714();
}

// Address range: 0x2a608 - 0x2a60c
int32_t function_2a608(int32_t a1) {
    // 0x2a608
    return function_2a94e();
}

// Address range: 0x2a60c - 0x2a610
int32_t function_2a60c(int32_t a1) {
    // 0x2a60c
    return function_2a716(a1 + 5);
}

// Address range: 0x2a610 - 0x2a612
int32_t function_2a610(void) {
    // 0x2a610
    return 4;
}

// Address range: 0x2a612 - 0x2a614
int32_t function_2a612(int32_t a1) {
    // 0x2a612
    return function_2a13c(a1);
}

// Address range: 0x2a614 - 0x2a618
int32_t function_2a614(void) {
    // 0x2a614
    return function_2ab1e();
}

// Address range: 0x2a618 - 0x2a61c
int32_t function_2a618(void) {
    // 0x2a618
    return 4;
}

// Address range: 0x2a61e - 0x2a620
int32_t function_2a61e(void) {
    // 0x2a61e
    int32_t result; // 0x2a61e
    return result;
}

// Address range: 0x2a622 - 0x2a624
int32_t function_2a622(void) {
    // 0x2a622
    int32_t result; // 0x2a622
    return result;
}

// Address range: 0x2a626 - 0x2a628
int32_t function_2a626(void) {
    // 0x2a626
    return function_2a150();
}

// Address range: 0x2a62a - 0x2a62c
int32_t function_2a62a(int32_t a1) {
    // 0x2a62a
    return function_2a554(a1);
}

// Address range: 0x2a62c - 0x2a630
int32_t function_2a62c(int32_t a1, int32_t a2) {
    // 0x2a62c
    return function_2a144(a1);
}

// Address range: 0x2a632 - 0x2a634
int32_t function_2a632(void) {
    // 0x2a632
    int32_t result; // 0x2a632
    return result;
}

// Address range: 0x2a636 - 0x2a638
int32_t function_2a636(int32_t a1) {
    // 0x2a636
    return function_2a3b8(a1);
}

// Address range: 0x2a638 - 0x2a63c
int32_t function_2a638(int32_t a1, int32_t a2) {
    // 0x2a638
    return function_2a164();
}

// Address range: 0x2a63e - 0x2a640
int32_t function_2a63e(int32_t a1) {
    // 0x2a63e
    return __asm_adr(a1);
}

// Address range: 0x2a640 - 0x2a644
int32_t function_2a640(int32_t a1) {
    // 0x2a640
    return function_2a56c(5);
}

// Address range: 0x2a644 - 0x2a648
int32_t function_2a644(int32_t a1) {
    // 0x2a644
    int32_t v1; // 0x2a644
    return function_2a750(a1 + 5, v1, v1, v1, (int32_t)&g306);
}

// Address range: 0x2a648 - 0x2a64c
int32_t function_2a648(int32_t a1) {
    // 0x2a648
    return function_2ad96(a1);
}

// Address range: 0x2a652 - 0x2a664
int32_t function_2a652(int32_t a1, int32_t a2, int32_t a3) {
    // 0x2a652
    return function_2a16c(0, a2 + 88);
}

// Address range: 0x2a664 - 0x2a668
int32_t function_2a664(int32_t result, int32_t a2) {
    // 0x2a664
    return result;
}

// Address range: 0x2a668 - 0x2a66c
int32_t function_2a668(int32_t result, int32_t a2) {
    // 0x2a668
    return result;
}

// Address range: 0x2a66c - 0x2a670
int32_t function_2a66c(int32_t result) {
    // 0x2a66c
    return result;
}

// Address range: 0x2a670 - 0x2a674
int32_t function_2a670(int32_t a1) {
    // 0x2a670
    return function_2a77c(a1);
}

// Address range: 0x2a674 - 0x2a676
int32_t function_2a674(void) {
    // 0x2a674
    return 212;
}

// Address range: 0x2a676 - 0x2a678
int32_t function_2a676(void) {
    // 0x2a676
    return function_2aa04();
}

// Address range: 0x2a678 - 0x2a67c
int32_t function_2a678(int32_t a1) {
    // 0x2a678
    return a1 + 1;
}

// Address range: 0x2a67c - 0x2a67e
int32_t function_2a67c(int32_t result, int32_t a2) {
    // 0x2a67c
    return result;
}

// Address range: 0x2a67e - 0x2a680
int32_t function_2a67e(void) {
    // 0x2a67e
    int32_t v1; // 0x2a67e
    return function_2a788(v1, v1);
}

// Address range: 0x2a680 - 0x2a68c
int32_t function_2a680(int32_t a1, int32_t a2, uint32_t a3, int32_t a4) {
    int32_t result = a1; // 0x2a684
    if (2 * a4 > a3) {
        result = function_2a81c((int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306);
    }
    // 0x2a688
    return result;
}

// Address range: 0x2a68c - 0x2a68e
int32_t function_2a68c(int32_t a1) {
    // 0x2a68c
    return a1 + 36;
}

// Address range: 0x2a68e - 0x2a690
int32_t function_2a68e(void) {
    // 0x2a68e
    return function_2a1ba();
}

// Address range: 0x2a692 - 0x2a694
int32_t function_2a692(void) {
    // 0x2a692
    return function_2ad3c();
}

// Address range: 0x2a696 - 0x2a69c
int32_t function_2a696(int32_t a1) {
    // 0x2a696
    return function_2a1c6();
}

// Address range: 0x2a69e - 0x2a6a0
int32_t function_2a69e(void) {
    // 0x2a69e
    return function_2ade2();
}

// Address range: 0x2a6a0 - 0x2a6a4
int32_t function_2a6a0(int32_t a1, int32_t a2, int32_t a3) {
    // 0x2a6a0
    return function_2acb8(16 * a3);
}

// Address range: 0x2a6a6 - 0x2a6a8
int32_t function_2a6a6(int32_t a1) {
    // 0x2a6a6
    return function_2aaf2(a1);
}

// Address range: 0x2a6a8 - 0x2a6b4
int32_t function_2a6a8(void) {
    // 0x2a6a8
    int32_t nmemb; // 0x2a6a8
    int32_t * mem = calloc(nmemb, nmemb); // 0x2a6a8
    int32_t v1 = (int32_t)mem; // 0x2a6a8
    int32_t result = v1; // 0x2a6b0
    if (mem == NULL) {
        result = function_2a8e4(v1);
    }
    // 0x2a6b4
    return result;
}

// Address range: 0x2a6b6 - 0x2a6b8
int32_t function_2a6b6(void) {
    // 0x2a6b6
    int32_t result; // 0x2a6b6
    return result;
}

// Address range: 0x2a6b8 - 0x2a6bc
int32_t function_2a6b8(int32_t a1) {
    // 0x2a6b8
    *(char *)a1 = (char)a1;
    return function_2adfe();
}

// Address range: 0x2a6bc - 0x2a6c0
int32_t function_2a6bc(int32_t result, int32_t a2) {
    // 0x2a6bc
    return result;
}

// Address range: 0x2a6c0 - 0x2a6c4
int32_t function_2a6c0(void) {
    // 0x2a6c0
    return function_2a1ee();
}

// Address range: 0x2a6c4 - 0x2a6c8
int32_t function_2a6c4(int32_t a1) {
    // 0x2a6c4
    return function_2a530(a1 + 131);
}

// Address range: 0x2a6c8 - 0x2a6cc
int32_t function_2a6c8(void) {
    // 0x2a6c8
    return 1;
}

// Address range: 0x2a6cc - 0x2a6d0
int32_t function_2a6cc(int32_t a1) {
    // 0x2a6cc
    return a1 + 1;
}

// Address range: 0x2a6d0 - 0x2a6d4
int32_t function_2a6d0(int32_t a1) {
    // 0x2a6d0
    return function_2a8fc(a1);
}

// Address range: 0x2a6d8 - 0x2a6e0
int32_t function_2a6d8(int32_t a1, int32_t a2, int32_t a3) {
    // 0x2a6d8
    int32_t v1; // 0x2a6d8
    return function_2a7e8(64 * v1, a2);
}

// Address range: 0x2a6e0 - 0x2a6e4
int32_t function_2a6e0(int32_t a1) {
    // 0x2a6e0
    return function_2a1ee();
}

// Address range: 0x2a6e4 - 0x2a6e8
int32_t function_2a6e4(int32_t result, int32_t a2) {
    // 0x2a6e4
    return result;
}

// Address range: 0x2a6e8 - 0x2a6ec
int32_t function_2a6e8(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x2a6e8
    int32_t v1; // 0x2a6e8
    *(char *)a4 = (char)v1;
    return function_2a1f4();
}

// Address range: 0x2a6ec - 0x2a6f0
int32_t function_2a6ec(int32_t a1, int32_t a2) {
    // 0x2a6ec
    return function_2a224(a1);
}

// Address range: 0x2a6f0 - 0x2a6f4
int32_t function_2a6f0(int32_t result) {
    // 0x2a6f0
    return result;
}

// Address range: 0x2a6f4 - 0x2a6f8
int32_t function_2a6f4(int32_t a1) {
    // 0x2a6f4
    return function_2a804();
}

// Address range: 0x2a6f8 - 0x2a708
int32_t function_2a6f8(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t result = a1; // 0x2a6f8
    bool v1; // 0x2a6f8
    if (v1) {
        result = function_2a7b8(a1, a2, a3, a4);
    }
    // 0x2a6fc
    return result;
}

// Address range: 0x2a70a - 0x2a70c
int32_t function_2a70a(void) {
    // 0x2a70a
    return function_2a632();
}

// Address range: 0x2a70e - 0x2a710
int32_t function_2a70e(int32_t a1) {
    int32_t result = function_2adbc(a1, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306); // 0x2a70e
    return result;
}

// Address range: 0x2a710 - 0x2a714
int32_t function_2a710(void) {
    // 0x2a710
    int32_t result; // 0x2a710
    return result;
}

// Address range: 0x2a714 - 0x2a716
int32_t function_2a714(void) {
    // 0x2a714
    int32_t result; // 0x2a714
    return result;
}

// Address range: 0x2a716 - 0x2a71c
int32_t function_2a716(int32_t a1) {
    // 0x2a716
    return function_2a244();
}

// Address range: 0x2a71c - 0x2a720
int32_t function_2a71c(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x2a71c
    *(int32_t *)(a2 + a1) = a4;
    return function_2aa62(a1);
}

// Address range: 0x2a720 - 0x2a721
int32_t function_2a720(void) {
    // 0x2a720
    int32_t result; // 0x2a720
    return result;
}

// Address range: 0x2a722 - 0x2a724
int32_t function_2a722(void) {
    // 0x2a722
    int32_t v1; // 0x2a722
    return function_2a250(v1);
}

// Address range: 0x2a724 - 0x2a728
int32_t function_2a724(int32_t a1) {
    // 0x2a724
    return function_2aa6a();
}

// Address range: 0x2a728 - 0x2a72c
int32_t function_2a728(void) {
    // 0x2a728
    return function_2a258();
}

// Address range: 0x2a72c - 0x2a730
int32_t function_2a72c(int32_t result, int32_t a2) {
    // 0x2a72c
    return result;
}

// Address range: 0x2a730 - 0x2a734
int32_t function_2a730(int32_t a1, int32_t a2, int32_t a3) {
    // 0x2a730
    return function_2a272(a1);
}

// Address range: 0x2a734 - 0x2a738
int32_t function_2a734(int32_t result) {
    // 0x2a734
    return result;
}

// Address range: 0x2a73a - 0x2a73c
int32_t function_2a73a(void) {
    // 0x2a73a
    int32_t v1; // 0x2a73a
    return function_2a84a(v1);
}

// Address range: 0x2a73e - 0x2a740
int32_t function_2a73e(int32_t a1) {
    // 0x2a73e
    return function_2a272(a1);
}

// Address range: 0x2a740 - 0x2a744
int32_t function_2a740(int32_t result) {
    // 0x2a740
    return result;
}

// Address range: 0x2a744 - 0x2a748
int32_t function_2a744(int32_t result) {
    // 0x2a744
    return result;
}

// Address range: 0x2a748 - 0x2a74c
int32_t function_2a748(int32_t a1, int32_t a2, int32_t a3, int32_t result) {
    // 0x2a748
    return result;
}

// Address range: 0x2a74c - 0x2a750
int32_t function_2a74c(int32_t a1) {
    // 0x2a74c
    int32_t v1; // 0x2a74c
    return function_2a9f4(a1, v1);
}

// Address range: 0x2a750 - 0x2a758
int32_t function_2a750(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x2a750
    return function_2a280();
}

// Address range: 0x2a758 - 0x2a774
int32_t function_2a758(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x2a758
    *(int32_t *)(a4 + 28) = a2 + 1;
    int32_t result = function_48ac8(); // 0x2a76c
    int32_t v1; // 0x2a758
    *(int32_t *)(v1 + 8) = result;
    return result;
}

// Address range: 0x2a774 - 0x2a778
int32_t function_2a774(void) {
    // 0x2a774
    int32_t v1; // 0x2a774
    return function_2a284(__asm_adr(48), v1);
}

// Address range: 0x2a778 - 0x2a77c
int32_t function_2a778(int32_t result, int32_t a2) {
    // 0x2a778
    return result;
}

// Address range: 0x2a77c - 0x2a780
int32_t function_2a77c(int32_t a1) {
    // 0x2a77c
    return function_2a28c(a1 + 16);
}

// Address range: 0x2a780 - 0x2a784
int32_t function_2a780(int32_t result, int32_t a2) {
    // 0x2a780
    return result;
}

// Address range: 0x2a784 - 0x2a788
int32_t function_2a784(int32_t result) {
    // 0x2a784
    return result;
}

// Address range: 0x2a788 - 0x2a790
int32_t function_2a788(int32_t result, int32_t a2) {
    // 0x2a788
    return result;
}

// Address range: 0x2a790 - 0x2a7a0
int32_t function_2a790(void) {
    // 0x2a790
    int32_t result; // 0x2a790
    return result;
}

// Address range: 0x2a7a2 - 0x2a7a4
int32_t function_2a7a2(void) {
    // 0x2a7a2
    return function_2a2e0();
}

// Address range: 0x2a7a6 - 0x2a7a8
int32_t function_2a7a6(int32_t a1) {
    // 0x2a7a6
    return function_2acb8(a1);
}

// Address range: 0x2a7a8 - 0x2a7ac
int32_t function_2a7a8(void) {
    // 0x2a7a8
    return function_2acb2(1);
}

// Address range: 0x2a7ac - 0x2a7b0
int32_t function_2a7ac(int32_t a1) {
    // 0x2a7ac
    return function_2aa56();
}

// Address range: 0x2a7b2 - 0x2a7b4
int32_t function_2a7b2(int32_t a1) {
    // 0x2a7b2
    int32_t v1; // 0x2a7b2
    return function_2a2d0(a1, v1, v1);
}

// Address range: 0x2a7b4 - 0x2a7b5
int32_t function_2a7b4(void) {
    // 0x2a7b4
    int32_t result; // 0x2a7b4
    return result;
}

// Address range: 0x2a7b8 - 0x2a7bc
int32_t function_2a7b8(int32_t a1, int32_t a2, int32_t a3, int32_t result) {
    // 0x2a7b8
    return result;
}

// Address range: 0x2a7be - 0x2a7bf
int32_t function_2a7be(void) {
    // 0x2a7be
    int32_t result; // 0x2a7be
    return result;
}

// Address range: 0x2a7c0 - 0x2a7c4
int32_t function_2a7c0(void) {
    // 0x2a7c0
    return function_2a2f8();
}

// Address range: 0x2a7c4 - 0x2a7c8
int32_t function_2a7c4(int32_t a1) {
    // 0x2a7c4
    return function_2a80c(a1 + 4);
}

// Address range: 0x2a7c8 - 0x2a7cc
int32_t function_2a7c8(int32_t a1) {
    // 0x2a7c8
    return a1 + 131;
}

// Address range: 0x2a7cc - 0x2a7d0
int32_t function_2a7cc(int32_t a1) {
    // 0x2a7cc
    return a1 + 4;
}

// Address range: 0x2a7d0 - 0x2a7d4
int32_t function_2a7d0(void) {
    // 0x2a7d0
    int32_t result; // 0x2a7d0
    return result;
}

// Address range: 0x2a7d4 - 0x2a7d8
int32_t function_2a7d4(int32_t a1) {
    // 0x2a7d4
    return a1 + 8;
}

// Address range: 0x2a7d8 - 0x2a7dc
int32_t function_2a7d8(int32_t a1) {
    // 0x2a7d8
    return function_2ace4(a1 + 1);
}

// Address range: 0x2a7de - 0x2a7e0
int32_t function_2a7de(int32_t a1) {
    // 0x2a7de
    return function_2a554(a1);
}

// Address range: 0x2a7e0 - 0x2a7e4
int32_t function_2a7e0(int32_t a1, int32_t a2) {
    // 0x2a7e0
    return function_2a318(a1, a2 + 88);
}

// Address range: 0x2a7e4 - 0x2a7e8
int32_t function_2a7e4(int32_t a1) {
    // 0x2a7e4
    *(int32_t *)a1 = a1;
    return function_2a2f0();
}

// Address range: 0x2a7e8 - 0x2a7ec
int32_t function_2a7e8(int32_t a1, int32_t a2) {
    // 0x2a7e8
    return function_2a320();
}

// Address range: 0x2a7ec - 0x2a7f0
int32_t function_2a7ec(void) {
    // 0x2a7ec
    int32_t v1; // 0x2a7ec
    return function_2a318(28, v1);
}

// Address range: 0x2a7f0 - 0x2a7f4
int32_t function_2a7f0(int32_t a1, int32_t a2) {
    // 0x2a7f0
    return function_2a31c();
}

// Address range: 0x2a7f4 - 0x2a7f8
int32_t function_2a7f4(void) {
    // 0x2a7f4
    return function_2aa9e();
}

// Address range: 0x2a7fe - 0x2a804
int32_t function_2a7fe(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x2a7fe
    *(int16_t *)21 = (int16_t)a3;
    return 1;
}

// Address range: 0x2a804 - 0x2a808
int32_t function_2a804(void) {
    // 0x2a804
    return function_2a310(32);
}

// Address range: 0x2a808 - 0x2a80c
int32_t function_2a808(int32_t result, int32_t a2) {
    // 0x2a808
    return result;
}

// Address range: 0x2a80c - 0x2a810
int32_t function_2a80c(int32_t a1) {
    // 0x2a80c
    return function_2a338(32);
}

// Address range: 0x2a810 - 0x2a814
int32_t function_2a810(int32_t result) {
    // 0x2a810
    return result;
}

// Address range: 0x2a81c - 0x2a824
int32_t function_2a81c(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    // 0x2a81c
    int32_t result; // 0x2a81c
    return result;
}

// Address range: 0x2a824 - 0x2a83c
int32_t function_2a824(void) {
    int32_t mem = (int32_t)malloc(44); // 0x2a834
    int32_t v1; // 0x2a824
    *(int32_t *)(v1 + 344) = mem;
    return mem;
}

// Address range: 0x2a83e - 0x2a840
int32_t function_2a83e(void) {
    // 0x2a83e
    return function_2a36a();
}

// Address range: 0x2a840 - 0x2a844
int32_t function_2a840(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x2a840
    return function_2a36c(32 * a4);
}

// Address range: 0x2a844 - 0x2a848
int32_t function_2a844(int32_t result) {
    // 0x2a844
    return result;
}

// Address range: 0x2a84a - 0x2a850
int32_t function_2a84a(int32_t a1) {
    // 0x2a84a
    return 44;
}

// Address range: 0x2a850 - 0x2a868
int32_t function_2a850(void) {
    // 0x2a850
    int32_t v1; // 0x2a850
    return (int32_t)memset((int32_t *)v1, v1, v1);
}

// Address range: 0x2a86a - 0x2a86c
int32_t function_2a86a(void) {
    // 0x2a86a
    int32_t result; // 0x2a86a
    return result;
}

// Address range: 0x2a86c - 0x2a86e
int32_t function_2a86c(void) {
    // 0x2a86c
    int32_t v1; // 0x2a86c
    return function_2ab20(v1);
}

// Address range: 0x2a86e - 0x2a870
int32_t function_2a86e(void) {
    // 0x2a86e
    return function_2a3d8();
}

// Address range: 0x2a870 - 0x2a874
int32_t function_2a870(int32_t a1) {
    // 0x2a870
    return a1 + 16;
}

// Address range: 0x2a874 - 0x2a878
int32_t function_2a874(int32_t result, int32_t a2) {
    // 0x2a874
    return result;
}

// Address range: 0x2a878 - 0x2a87c
int32_t function_2a878(int32_t result, int32_t a2) {
    // 0x2a878
    return result;
}

// Address range: 0x2a87c - 0x2a880
int32_t function_2a87c(int32_t a1, int32_t a2, int32_t a3) {
    // 0x2a87c
    *(int32_t *)a1 = a3;
    return a1 + 4;
}

// Address range: 0x2a880 - 0x2a884
int32_t function_2a880(int32_t result, int32_t a2) {
    // 0x2a880
    return result;
}

// Address range: 0x2a884 - 0x2a888
int32_t function_2a884(int32_t result, int32_t a2) {
    // 0x2a884
    return result;
}

// Address range: 0x2a888 - 0x2a88c
int32_t function_2a888(int32_t a1, int32_t a2) {
    // 0x2a888
    return 0;
}

// Address range: 0x2a88c - 0x2a890
int32_t function_2a88c(int32_t a1, int32_t a2) {
    // 0x2a88c
    return function_2aa6e();
}

// Address range: 0x2a890 - 0x2a894
int32_t function_2a890(int32_t a1, int32_t a2) {
    // 0x2a890
    return function_2a3bc();
}

// Address range: 0x2a894 - 0x2a898
int32_t function_2a894(void) {
    // 0x2a894
    return 20;
}

// Address range: 0x2a898 - 0x2a89c
int32_t function_2a898(int32_t a1, int32_t a2) {
    // 0x2a898
    return function_2a3c6();
}

// Address range: 0x2a89c - 0x2a8a4
int32_t function_2a89c(int32_t size, int32_t a2, int32_t a3, int32_t a4) {
    // 0x2a89c
    return (int32_t)malloc(size);
}

// Address range: 0x2a8a6 - 0x2a8a8
int32_t function_2a8a6(int32_t a1) {
    // 0x2a8a6
    int32_t v1; // 0x2a8a6
    return function_2a3b8(v1);
}

// Address range: 0x2a8a8 - 0x2a8e4
int32_t function_2a8a8(void) {
    // 0x2a8a8
    int32_t v1; // 0x2a8a8
    int32_t * v2 = (int32_t *)(v1 + 352); // 0x2a8a8
    int32_t v3 = *(int32_t *)*(int32_t *)(*v2 + 344); // 0x2a8b0
    int32_t v4 = v3; // 0x2a8b8
    if (v3 == 0) {
        v4 = function_2a8e4(0);
    }
    int32_t * set_mem = memset((int32_t *)v4, v1, 384); // 0x2a8c4
    *(int32_t *)(*(int32_t *)(*v2 + 344) + 40) = -0x5feee01f;
    return function_2a5d8((int32_t)set_mem, v1 + 344);
}

// Address range: 0x2a8e4 - 0x2a8e8
int32_t function_2a8e4(int32_t result) {
    // 0x2a8e4
    return result;
}

// Address range: 0x2a8e8 - 0x2a8ec
int32_t function_2a8e8(void) {
    // 0x2a8e8
    int32_t status; // 0x2a8e8
    exit(status);
    // UNREACHABLE
}

// Address range: 0x2a8ec - 0x2a8f0
int32_t function_2a8ec(void) {
    // 0x2a8ec
    int32_t result; // 0x2a8ec
    return result;
}

// Address range: 0x2a8f2 - 0x2a8f4
int32_t function_2a8f2(int32_t a1) {
    // 0x2a8f2
    return function_2ad96(a1);
}

// Address range: 0x2a8f4 - 0x2a8fc
int32_t function_2a8f4(int32_t a1) {
    // 0x2a8f4
    int32_t result; // 0x2a8f4
    return result;
}

// Address range: 0x2a8fc - 0x2a900
int32_t function_2a8fc(int32_t a1) {
    // 0x2a8fc
    bool v1; // 0x2a8fc
    int32_t v2; // 0x2a8fc
    return v2 + a1 + (int32_t)(bool)v1;
}

// Address range: 0x2a902 - 0x2a904
int32_t function_2a902(void) {
    // 0x2a902
    int32_t result; // 0x2a902
    return result;
}

// Address range: 0x2a904 - 0x2a908
int32_t function_2a904(int32_t result, int32_t a2, int32_t a3) {
    // 0x2a904
    *(char *)result = (char)a3;
    return result;
}

// Address range: 0x2a908 - 0x2a90c
int32_t function_2a908(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x2a908
    *(int16_t *)result = (int16_t)a4;
    return result;
}

// Address range: 0x2a90c - 0x2a910
int32_t function_2a90c(void) {
    // 0x2a90c
    return 7;
}

// Address range: 0x2a910 - 0x2a914
int32_t function_2a910(int32_t result) {
    // 0x2a910
    return result;
}

// Address range: 0x2a914 - 0x2a916
int32_t function_2a914(int32_t a1) {
    // 0x2a914
    return 4 * a1;
}

// Address range: 0x2a916 - 0x2a918
int32_t function_2a916(int32_t a1) {
    // 0x2a916
    return function_2ae24(a1);
}

// Address range: 0x2a918 - 0x2a94c
int32_t function_2a918(int32_t n) {
    // 0x2a918
    int32_t str; // 0x2a918
    int32_t str2 = 2 * str; // 0x2a928
    int32_t v1 = str2; // 0x2a92c
    if (memcmp((int32_t *)str, (int32_t *)str, str) == 0) {
        int32_t memcmp_rc = memcmp((int32_t *)str2, (int32_t *)str, n); // 0x2a930
        v1 = memcmp_rc;
        if (memcmp_rc == 0) {
            v1 = function_2a950();
        }
    }
    int32_t result = v1; // 0x2a944
    if (str == 0) {
        result = function_2a954((int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306);
    }
    // 0x2a948
    return result;
}

// Address range: 0x2a94e - 0x2a94f
int32_t function_2a94e(void) {
    // 0x2a94e
    int32_t result; // 0x2a94e
    return result;
}

// Address range: 0x2a950 - 0x2a954
int32_t function_2a950(void) {
    // 0x2a950
    int32_t result; // 0x2a950
    return result;
}

// Address range: 0x2a954 - 0x2a95c
int32_t function_2a954(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    // 0x2a954
    int32_t result; // 0x2a954
    return result;
}

// Address range: 0x2a95c - 0x2a96c
int32_t function_2a95c(int32_t result) {
    // 0x2a95c
    return result;
}

// Address range: 0x2a96c - 0x2a970
int32_t function_2a96c(int32_t result) {
    // 0x2a96c
    return result;
}

// Address range: 0x2a970 - 0x2a97c
int32_t function_2a970(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t result = a1; // 0x2a970
    bool v1; // 0x2a970
    if (a4 != 0 && !v1) {
        result = *(int32_t *)(a4 + 352);
    }
    return result;
}

// Address range: 0x2a97e - 0x2a982
int32_t function_2a97e(int32_t a1) {
    // 0x2a97e
    return 0;
}

// Address range: 0x2a982 - 0x2a988
int32_t function_2a982(int32_t result) {
    // 0x2a982
    return result;
}

// Address range: 0x2a988 - 0x2a9a0
int32_t function_2a988(int32_t result, int32_t a2) {
    // 0x2a988
    bool v1; // 0x2a988
    if (v1) {
        return result;
    }
    // 0x2a990
    return *(int32_t *)(result + 352);
}

// Address range: 0x2a9a2 - 0x2a9a4
int32_t function_2a9a2(void) {
    // 0x2a9a2
    return function_2a804();
}

// Address range: 0x2a9a4 - 0x2a9a8
int32_t function_2a9a4(void) {
    // 0x2a9a4
    int32_t result; // 0x2a9a4
    return result;
}

// Address range: 0x2a9a8 - 0x2a9a9
int32_t function_2a9a8(void) {
    // 0x2a9a8
    int32_t result; // 0x2a9a8
    return result;
}

// Address range: 0x2a9ac - 0x2a9b0
int32_t function_2a9ac(int32_t result, int32_t a2) {
    // 0x2a9ac
    return result;
}

// Address range: 0x2a9b0 - 0x2a9b4
int32_t function_2a9b0(int32_t a1, int32_t a2) {
    // 0x2a9b0
    return function_2a4d6();
}

// Address range: 0x2a9b4 - 0x2a9b8
int32_t function_2a9b4(int32_t a1) {
    // 0x2a9b4
    return a1 + 1;
}

// Address range: 0x2a9b8 - 0x2a9cc
int32_t function_2a9b8(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x2a9b8
    *(int32_t *)(a1 + 360) = a4;
    int32_t result = a1; // 0x2a9c4
    if (*(int32_t *)(a2 + 348) == 0) {
        result = function_2aac0(a1, a2);
    }
    // 0x2a9c8
    return result;
}

// Address range: 0x2a9ce - 0x2a9d0
int32_t function_2a9ce(void) {
    // 0x2a9ce
    int32_t result; // 0x2a9ce
    return result;
}

// Address range: 0x2a9d0 - 0x2a9d4
int32_t function_2a9d0(int32_t a1) {
    // 0x2a9d0
    return function_2a512(a1 + 20);
}

// Address range: 0x2a9d4 - 0x2a9d8
int32_t function_2a9d4(int32_t a1, int32_t a2, int32_t a3) {
    // 0x2a9d4
    return a3 & a1;
}

// Address range: 0x2a9da - 0x2a9dc
int32_t function_2a9da(void) {
    // 0x2a9da
    return function_2a58c();
}

// Address range: 0x2a9de - 0x2a9e0
int32_t function_2a9de(int32_t a1) {
    // 0x2a9de
    return function_2ac84(a1);
}

// Address range: 0x2a9e0 - 0x2a9e8
int32_t function_2a9e0(int32_t a1, int32_t a2) {
    int32_t result = a1; // 0x2a9e0
    bool v1; // 0x2a9e0
    if (v1) {
        result = function_2aa9c();
    }
    // 0x2a9e4
    return result;
}

// Address range: 0x2a9ea - 0x2a9ec
int32_t function_2a9ea(int32_t a1) {
    // 0x2a9ea
    return function_2aaf2(a1);
}

// Address range: 0x2a9ec - 0x2a9ee
int32_t function_2a9ec(void) {
    // 0x2a9ec
    int32_t v1; // 0x2a9ec
    return function_2aa00(v1);
}

// Address range: 0x2a9ee - 0x2a9f0
int32_t function_2a9ee(void) {
    // 0x2a9ee
    return function_2a7b4();
}

// Address range: 0x2a9f0 - 0x2a9f4
int32_t function_2a9f0(int32_t a1) {
    // 0x2a9f0
    bool v1; // 0x2a9f0
    int32_t v2; // 0x2a9f0
    return v2 + a1 + (int32_t)(bool)v1;
}

// Address range: 0x2a9f4 - 0x2a9f8
int32_t function_2a9f4(int32_t a1, int32_t a2) {
    // 0x2a9f4
    return function_2a51c(a1, a2 + 96);
}

// Address range: 0x2a9f8 - 0x2a9fc
int32_t function_2a9f8(void) {
    // 0x2a9f8
    int32_t result; // 0x2a9f8
    return result;
}

// Address range: 0x2a9fc - 0x2aa00
int32_t function_2a9fc(int32_t result) {
    // 0x2a9fc
    return result;
}

// Address range: 0x2aa00 - 0x2aa04
int32_t function_2aa00(uint32_t a1) {
    // 0x2aa00
    return a1 / 256;
}

// Address range: 0x2aa04 - 0x2aa06
int32_t function_2aa04(void) {
    // 0x2aa04
    int32_t v1; // 0x2aa04
    return function_2aa30(v1);
}

// Address range: 0x2aa06 - 0x2aa08
int32_t function_2aa06(void) {
    // 0x2aa06
    int32_t result; // 0x2aa06
    return result;
}

// Address range: 0x2aa0a - 0x2aa0c
int32_t function_2aa0a(int32_t a1) {
    // 0x2aa0a
    return function_2a530(a1);
}

// Address range: 0x2aa0c - 0x2aa10
int32_t function_2aa0c(int32_t a1) {
    // 0x2aa0c
    return function_2ab18(a1 + 14);
}

// Address range: 0x2aa12 - 0x2aa14
int32_t function_2aa12(int32_t a1) {
    // 0x2aa12
    int32_t v1; // 0x2aa12
    return function_2a51c(a1, v1);
}

// Address range: 0x2aa14 - 0x2aa18
int32_t function_2aa14(int32_t a1, int32_t a2) {
    // 0x2aa14
    return function_2a582(a1, a2 + 96);
}

// Address range: 0x2aa18 - 0x2aa1c
int32_t function_2aa18(void) {
    // 0x2aa18
    return function_2a544();
}

// Address range: 0x2aa1c - 0x2aa20
int32_t function_2aa1c(int32_t a1) {
    // 0x2aa1c
    return a1 + 4;
}

// Address range: 0x2aa20 - 0x2aa22
int32_t function_2aa20(void) {
    // 0x2aa20
    int32_t v1; // 0x2aa20
    return function_2ad0c(v1);
}

// Address range: 0x2aa22 - 0x2aa24
int32_t function_2aa22(void) {
    // 0x2aa22
    int32_t v1; // 0x2aa22
    return function_2a548(v1);
}

// Address range: 0x2aa24 - 0x2aa28
int32_t function_2aa24(void) {
    // 0x2aa24
    return 0;
}

// Address range: 0x2aa28 - 0x2aa2c
int32_t function_2aa28(int32_t a1) {
    // 0x2aa28
    return a1 + 1;
}

// Address range: 0x2aa2c - 0x2aa30
int32_t function_2aa2c(int32_t a1) {
    // 0x2aa2c
    return function_2aa38();
}

// Address range: 0x2aa30 - 0x2aa34
int32_t function_2aa30(int32_t a1) {
    // 0x2aa30
    return a1 + 131;
}

// Address range: 0x2aa34 - 0x2aa38
int32_t function_2aa34(int32_t a1, int32_t a2) {
    // 0x2aa34
    return function_2ad7a();
}

// Address range: 0x2aa38 - 0x2aa3a
int32_t function_2aa38(void) {
    // 0x2aa38
    return 3;
}

// Address range: 0x2aa3a - 0x2aa3c
int32_t function_2aa3a(void) {
    // 0x2aa3a
    int32_t result; // 0x2aa3a
    return result;
}

// Address range: 0x2aa3c - 0x2aa3e
int32_t function_2aa3c(void) {
    // 0x2aa3c
    return function_2aa48();
}

// Address range: 0x2aa3e - 0x2aa40
int32_t function_2aa3e(void) {
    // 0x2aa3e
    return function_2a566();
}

// Address range: 0x2aa40 - 0x2aa42
int32_t function_2aa40(void) {
    // 0x2aa40
    return function_2aa46();
}

// Address range: 0x2aa42 - 0x2aa46
int32_t function_2aa42(void) {
    // 0x2aa42
    int32_t result; // 0x2aa42
    return result;
}

// Address range: 0x2aa46 - 0x2aa48
int32_t function_2aa46(void) {
    // 0x2aa46
    int32_t result; // 0x2aa46
    return result;
}

// Address range: 0x2aa48 - 0x2aa4c
int32_t function_2aa48(void) {
    // 0x2aa48
    int32_t result; // 0x2aa48
    return result;
}

// Address range: 0x2aa4c - 0x2aa50
int32_t function_2aa4c(void) {
    // 0x2aa4c
    int32_t result; // 0x2aa4c
    return result;
}

// Address range: 0x2aa50 - 0x2aa54
int32_t function_2aa50(void) {
    // 0x2aa50
    return 0;
}

// Address range: 0x2aa54 - 0x2aa56
int32_t function_2aa54(void) {
    // 0x2aa54
    int32_t v1; // 0x2aa54
    return function_2aa5e(v1, v1, v1);
}

// Address range: 0x2aa56 - 0x2aa58
int32_t function_2aa56(void) {
    // 0x2aa56
    int32_t v1; // 0x2aa56
    return function_2a97e(v1);
}

// Address range: 0x2aa58 - 0x2aa5c
int32_t function_2aa58(int32_t a1, int32_t a2) {
    // 0x2aa58
    return function_2ad1a();
}

// Address range: 0x2aa5e - 0x2aa62
int32_t function_2aa5e(int32_t a1, int32_t a2, int32_t a3) {
    // 0x2aa5e
    *(int32_t *)a1 = a1;
    *(int32_t *)(a1 + 4) = 0x400000 * a3;
    return a1 + 8;
}

// Address range: 0x2aa62 - 0x2aa66
int32_t function_2aa62(int32_t result) {
    // 0x2aa62
    return result;
}

// Address range: 0x2aa66 - 0x2aa68
int32_t function_2aa66(void) {
    // 0x2aa66
    return function_2a58c();
}

// Address range: 0x2aa6a - 0x2aa6c
int32_t function_2aa6a(void) {
    // 0x2aa6a
    int32_t result; // 0x2aa6a
    return result;
}

// Address range: 0x2aa6e - 0x2aa70
int32_t function_2aa6e(void) {
    // 0x2aa6e
    int32_t result; // 0x2aa6e
    return result;
}

// Address range: 0x2aa7a - 0x2aa7c
int32_t function_2aa7a(void) {
    // 0x2aa7a
    int32_t result; // 0x2aa7a
    return result;
}

// Address range: 0x2aa7c - 0x2aa88
int32_t function_2aa7c(int32_t a1, int32_t a2, int32_t a3) {
    // 0x2aa7c
    return 12;
}

// Address range: 0x2aa88 - 0x2aa8c
int32_t function_2aa88(int32_t a1) {
    // 0x2aa88
    int32_t v1; // 0x2aa88
    return function_2a5b4(v1);
}

// Address range: 0x2aa8c - 0x2aa9c
int32_t function_2aa8c(int32_t result, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    int32_t * v1 = (int32_t *)(a3 + 12); // 0x2aa8c
    *v1 = *v1 - 1;
    return result;
}

// Address range: 0x2aa9c - 0x2aa9d
int32_t function_2aa9c(void) {
    // 0x2aa9c
    int32_t result; // 0x2aa9c
    return result;
}

// Address range: 0x2aa9e - 0x2aaa0
int32_t function_2aa9e(void) {
    // 0x2aa9e
    int32_t result; // 0x2aa9e
    return result;
}

// Address range: 0x2aaa2 - 0x2aaa4
int32_t function_2aaa2(int32_t a1) {
    // 0x2aaa2
    return function_2a0ec(a1);
}

// Address range: 0x2aaa4 - 0x2aab0
int32_t function_2aaa4(int32_t result, int32_t a2) {
    // 0x2aaa4
    return result;
}

// Address range: 0x2aab0 - 0x2aab4
int32_t function_2aab0(int32_t a1, int32_t a2) {
    // 0x2aab0
    return function_2a5d6(a1, a2 + 96);
}

// Address range: 0x2aab4 - 0x2aab8
int32_t function_2aab4(int32_t a1, int32_t a2) {
    // 0x2aab4
    return function_2a5e0();
}

// Address range: 0x2aab8 - 0x2aac0
int32_t function_2aab8(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x2aab8
    return result;
}

// Address range: 0x2aac0 - 0x2aad4
int32_t function_2aac0(int32_t a1, int32_t a2) {
    int32_t result = a1; // 0x2aacc
    if (*(int32_t *)(a2 + 352) == 0) {
        result = function_2aaf0();
    }
    // 0x2aad0
    return result;
}

// Address range: 0x2aad6 - 0x2aad8
int32_t function_2aad6(void) {
    // 0x2aad6
    int32_t result; // 0x2aad6
    return result;
}

// Address range: 0x2aad8 - 0x2aaf0
int32_t function_2aad8(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = a1; // 0x2aae4
    int32_t v2; // 0x2aad8
    if (*(int32_t *)(v2 + 16) - a4 == a2) {
        v1 = function_2aa9c();
    }
    // 0x2aae8
    return function_2a9f4(v1, a2);
}

// Address range: 0x2aaf0 - 0x2aaf1
int32_t function_2aaf0(void) {
    // 0x2aaf0
    int32_t result; // 0x2aaf0
    return result;
}

// Address range: 0x2aaf2 - 0x2aaf4
int32_t function_2aaf2(int32_t a1) {
    // 0x2aaf2
    int32_t result; // 0x2aaf2
    return result;
}

// Address range: 0x2aaf4 - 0x2aaf8
int32_t function_2aaf4(int32_t a1) {
    // 0x2aaf4
    return function_2a3b8(a1);
}

// Address range: 0x2aaf8 - 0x2aafc
int32_t function_2aaf8(void) {
    // 0x2aaf8
    int32_t v1; // 0x2aaf8
    free((int32_t *)v1);
    return &g306;
}

// Address range: 0x2aafc - 0x2ab00
int32_t function_2aafc(int32_t a1, int32_t a2) {
    // 0x2aafc
    return function_2a62c(a1, a2 + 96);
}

// Address range: 0x2ab00 - 0x2ab0c
int32_t function_2ab00(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x2ab00
    free((int32_t *)*(int32_t *)(a4 + 344));
    return &g306;
}

// Address range: 0x2ab0c - 0x2ab14
int32_t function_2ab0c(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x2ab0c
    int32_t v1; // 0x2ab0c
    *(int16_t *)(v1 + 2) = (int16_t)a1;
    return function_2a638(a1, v1);
}

// Address range: 0x2ab14 - 0x2ab18
int32_t function_2ab14(void) {
    // 0x2ab14
    int32_t result; // 0x2ab14
    return result;
}

// Address range: 0x2ab18 - 0x2ab1c
int32_t function_2ab18(int32_t a1) {
    // 0x2ab18
    return __asm_adr(32);
}

// Address range: 0x2ab1e - 0x2ab20
int32_t function_2ab1e(void) {
    // 0x2ab1e
    int32_t result; // 0x2ab1e
    return result;
}

// Address range: 0x2ab20 - 0x2ab28
int32_t function_2ab20(int32_t a1) {
    // 0x2ab20
    float64_t v1; // 0x2ab20
    __asm_vrhadd_u16(v1, v1);
    return a1 + 4;
}

// Address range: 0x2ab28 - 0x2ab30
int32_t function_2ab28(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x2ab28
    return result;
}

// Address range: 0x2ab30 - 0x2abb0
int32_t function_2ab30(int32_t status, int32_t a2) {
    // 0x2ab30
    int32_t thread; // bp-12, 0x2ab30
    if (pthread_create(&thread, NULL, (int32_t * (*)(int32_t *))&g5, NULL) != 0) {
        // 0x2aba8
        exit(1);
        // UNREACHABLE
    }
    if (a2 != 0) {
        // 0x2aba0
        function_2dd24(0);
    }
    // 0x2ab68
    if (g95 > 0) {
        // 0x2ab8c
        kill(g95, SIGTERM);
        g95 = 0;
    }
    // 0x2ab7c
    pthread_cancel(thread);
    exit(status);
    // UNREACHABLE
}

// Address range: 0x2abb0 - 0x2ac0c
int32_t function_2abb0(void) {
    // 0x2abb0
    function_22140(0x2e354, 0, 0x1388);
    char * v1 = (char *)0x74756853; // bp-2056, 0x2abe0
    function_1ccec(3, (int32_t *)&v1, 1);
    function_2ab30(0, 1);
    // UNREACHABLE
}

// Address range: 0x2ac0c - 0x2ac7c
int32_t function_2ac0c(void) {
    // 0x2ac0c
    sigaction(SIGTERM, (struct sigaction *)&g187, NULL);
    sigaction(SIGINT, (struct sigaction *)&g248, NULL);
    sigaction(SIGABRT, (struct sigaction *)&g264, NULL);
    float64_t v1; // 0x2ac0c
    __asm_vpush_7(v1, v1, v1);
    function_29090(0);
    return (int32_t)(*(int64_t *)192 / 0x100000000);
}

// Address range: 0x2ac7c - 0x2ac84
int32_t function_2ac7c(void) {
    // 0x2ac7c
    __asm_cdp(0, 11, 11, 0, 8, 1);
    int32_t result; // 0x2ac7c
    return result;
}

// Address range: 0x2ac84 - 0x2ac86
int32_t function_2ac84(int32_t a1) {
    // 0x2ac84
    int32_t v1; // 0x2ac84
    return (int32_t)*(char *)(v1 + 6);
}

// Address range: 0x2ac86 - 0x2acb2
int32_t function_2ac86(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x2ac86
    bool v1; // 0x2ac86
    if (v1) {
        function_62948e();
    }
    bool v2; // 0x2ac86
    bool v3; // 0x2ac86
    int32_t v4; // 0x2ac86
    v3 = v4 == a2 >> 24;
    v2 = (a2 & 0x800000) != 0;
    if (v1) {
        function_3636ca();
    }
    if (v2 == !v3) {
        function_2e62ea();
    }
    if (v3 || !v2) {
        function_17666ba();
    }
    int32_t v5; // 0x2ac86
    if (v1) {
        v5 = function_2a6322();
    } else {
        // 0x2ac9e
        v5 = function_17a631e();
    }
    int32_t v6 = v5; // 0x2aca2
    if (v3) {
        v6 = function_5e6542();
    }
    int32_t result = v6; // 0x2aca6
    if (v2 == !v3) {
        result = function_225df2();
    }
    // 0x2acaa
    if (!v1) {
        *(int32_t *)(v4 + 4) = a4;
        int32_t v7; // 0x2ac86
        *(int32_t *)(v4 + 24) = (int32_t)&v7;
        *(int32_t *)(v4 + 28) = 0x2acaa;
        *(int32_t *)(v4 + 32) = 0x2acb0;
    }
    return result;
}

// Address range: 0x2acb2 - 0x2acb8
int32_t function_2acb2(int32_t result) {
    // 0x2acb2
    int32_t v1; // 0x2acb2
    __asm_ldc_13(0, 8, v1);
    return result;
}

// Address range: 0x2acb8 - 0x2acbc
int32_t function_2acb8(int32_t result) {
    // 0x2acb8
    return result;
}

// Address range: 0x2acbe - 0x2acd6
int32_t function_2acbe(int32_t a1) {
    int32_t v1 = a1; // 0x2acbe
    bool v2; // 0x2acbe
    if (!v2) {
        v1 = function_2a66de();
    }
    int32_t result = v1; // 0x2acc2
    if (v2) {
        result = function_626566();
    }
    if (v2) {
        // 0x2acca
        return result;
    }
    return function_200ae58d();
}

// Address range: 0x2acd6 - 0x2acd8
int32_t function_2acd6(void) {
    // 0x2acd6
    int32_t result; // 0x2acd6
    return result;
}

// Address range: 0x2acda - 0x2acdb
int32_t function_2acda(void) {
    // 0x2acda
    int32_t result; // 0x2acda
    return result;
}

// Address range: 0x2acdc - 0x2ace0
int32_t function_2acdc(int32_t a1, int32_t result) {
    // 0x2acdc
    return result;
}

// Address range: 0x2ace0 - 0x2ace4
int32_t function_2ace0(int32_t result, int32_t a2) {
    // 0x2ace0
    return result;
}

// Address range: 0x2ace4 - 0x2ace6
int32_t function_2ace4(int32_t result) {
    // 0x2ace4
    *(char *)result = (char)result;
    return result;
}

// Address range: 0x2ace6 - 0x2ace8
int32_t function_2ace6(void) {
    // 0x2ace6
    return function_2a804();
}

// Address range: 0x2ace8 - 0x2ad0c
int32_t function_2ace8(void) {
    // 0x2ace8
    int32_t result; // 0x2ace8
    function_271e0(result, result, result, 16, (int32_t)&g306);
    return result;
}

// Address range: 0x2ad0c - 0x2ad10
int32_t function_2ad0c(int32_t a1) {
    // 0x2ad0c
    return a1 + 8;
}

// Address range: 0x2ad10 - 0x2ad18
int32_t function_2ad10(void) {
    // 0x2ad10
    int32_t str; // 0x2ad10
    return snprintf((char *)str, str, (char *)str);
}

// Address range: 0x2ad1a - 0x2ad1c
int32_t function_2ad1a(void) {
    // 0x2ad1a
    int32_t result; // 0x2ad1a
    return result;
}

// Address range: 0x2ad1c - 0x2ad20
int32_t function_2ad1c(void) {
    // 0x2ad1c
    return 4;
}

// Address range: 0x2ad22 - 0x2ad24
int32_t function_2ad22(int32_t a1) {
    // 0x2ad22
    int32_t result; // 0x2ad22
    return result;
}

// Address range: 0x2ad24 - 0x2ad3c
int32_t function_2ad24(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x2ad24
    int32_t str; // 0x2ad24
    return strlen((char *)str);
}

// Address range: 0x2ad3c - 0x2ad40
int32_t function_2ad3c(void) {
    // 0x2ad3c
    return function_2a86a();
}

// Address range: 0x2ad40 - 0x2ad44
int32_t function_2ad40(int32_t a1) {
    // 0x2ad40
    return a1 + 6;
}

// Address range: 0x2ad44 - 0x2ad4c
int32_t function_2ad44(void) {
    // 0x2ad44
    int32_t v1; // 0x2ad44
    __asm_ldc_13(7, 3, *(int32_t *)((int32_t)*(char *)(v1 + 12) + 320));
    return function_2a874(v1, v1);
}

// Address range: 0x2ad4c - 0x2ad50
int32_t function_2ad4c(void) {
    // 0x2ad4c
    int32_t result; // 0x2ad4c
    return result;
}

// Address range: 0x2ad50 - 0x2ad58
int32_t function_2ad50(int32_t a1, int32_t a2, int32_t a3) {
    // 0x2ad50
    __asm_stc(a1, a2, a3);
    return (int32_t)*(int16_t *)(a2 + 24);
}

// Address range: 0x2ad58 - 0x2ad5c
int32_t function_2ad58(void) {
    // 0x2ad58
    return __asm_adr(960);
}

// Address range: 0x2ad5c - 0x2ad60
int32_t function_2ad5c(void) {
    // 0x2ad5c
    return 4;
}

// Address range: 0x2ad60 - 0x2ad64
int32_t function_2ad60(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x2ad60
    return (int32_t)*(int16_t *)(a4 + 38);
}

// Address range: 0x2ad64 - 0x2ad68
int32_t function_2ad64(int32_t a1, int32_t a2) {
    // 0x2ad64
    return 2 * a2;
}

// Address range: 0x2ad68 - 0x2ad6c
int32_t function_2ad68(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x2ad68
    return function_2a888(0, a2);
}

// Address range: 0x2ad6c - 0x2ad70
int32_t function_2ad6c(int32_t a1) {
    // 0x2ad6c
    return a1 >> 1;
}

// Address range: 0x2ad70 - 0x2ad78
int32_t function_2ad70(int32_t result, int32_t a2) {
    // 0x2ad70
    __asm_stc(0, 8, a2);
    return result;
}

// Address range: 0x2ad7a - 0x2ad7b
int32_t function_2ad7a(void) {
    // 0x2ad7a
    int32_t result; // 0x2ad7a
    return result;
}

// Address range: 0x2ad7c - 0x2ad94
int32_t function_2ad7c(void) {
    // 0x2ad7c
    int32_t str; // bp+72, 0x2ad7c
    int32_t v1; // 0x2ad7c
    return strlen((char *)&str) + v1;
}

// Address range: 0x2ad96 - 0x2ad98
int32_t function_2ad96(int32_t a1) {
    // 0x2ad96
    int32_t result; // 0x2ad96
    return result;
}

// Address range: 0x2ad98 - 0x2adbc
int32_t function_2ad98(void) {
    // 0x2ad98
    int32_t str; // 0x2ad98
    strcat((char *)str, (char *)str);
    return str;
}

// Address range: 0x2adbc - 0x2adc8
int32_t function_2adbc(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x2adbc
    __asm_ldc(15, 8, a2, 960);
    int32_t v1; // 0x2adbc
    return function_2a908(a1, v1, a2, v1);
}

// Address range: 0x2adc8 - 0x2adcc
int32_t function_2adc8(int32_t result, int32_t a2) {
    // 0x2adc8
    return result;
}

// Address range: 0x2adcc - 0x2add0
int32_t function_2adcc(int32_t a1) {
    // 0x2adcc
    return a1 - 240;
}

// Address range: 0x2add0 - 0x2add4
int32_t function_2add0(void) {
    // 0x2add0
    int32_t result; // 0x2add0
    return result;
}

// Address range: 0x2add4 - 0x2add8
int32_t function_2add4(int32_t a1) {
    // 0x2add4
    return function_2a8f4((int32_t)&g306);
}

// Address range: 0x2add8 - 0x2addc
int32_t function_2add8(int32_t a1) {
    // 0x2add8
    return a1 + 4;
}

// Address range: 0x2addc - 0x2ade0
int32_t function_2addc(int32_t a1) {
    // 0x2addc
    return function_2a8fc(0);
}

// Address range: 0x2ade2 - 0x2ade4
int32_t function_2ade2(void) {
    // 0x2ade2
    int32_t result; // 0x2ade2
    return result;
}

// Address range: 0x2ade4 - 0x2adfc
int32_t function_2ade4(void) {
    // 0x2ade4
    int32_t str; // bp+136, 0x2ade4
    int32_t format; // 0x2ade4
    snprintf((char *)&str, 2048, (char *)format);
    return 3;
}

// Address range: 0x2adfe - 0x2adff
int32_t function_2adfe(void) {
    // 0x2adfe
    int32_t result; // 0x2adfe
    return result;
}

// Address range: 0x2ae00 - 0x2ae0c
int32_t function_2ae00(void) {
    // 0x2ae00
    function_2ab30(1, 1);
    // UNREACHABLE
}

// Address range: 0x2ae10 - 0x2ae24
int32_t function_2ae10(int32_t a1) {
    // 0x2ae10
    int32_t v1; // 0x2ae10
    bool v2; // 0x2ae10
    int32_t v3; // 0x2ae10
    if (v2) {
        v1 = __asm_smlawbmi(a1, v3, v3);
    }
    if (v2) {
        *(int16_t *)v3 = (int16_t)v3;
    }
    return v2 ? v1 - a1 : a1;
}

// Address range: 0x2ae24 - 0x2ae68
int32_t function_2ae24(int32_t a1) {
    char * v1 = (char *)0x6c696146; // bp-2056, 0x2ae40
    function_1ccec(3, (int32_t *)&v1, 1);
    return function_2ab30(1, 1);
}

// Address range: 0x2ae68 - 0x2aea4
int32_t function_2ae68(void) {
    // 0x2ae68
    function_1f5c4(&g91);
    int32_t thread; // bp-12, 0x2ae68
    if (pthread_create(&thread, NULL, (int32_t * (*)(int32_t *))&g9, NULL) == 0) {
        // 0x2ae98
        return 0;
    }
    // 0x2aea0
    return function_2ae24((int32_t)&g306);
}

// Address range: 0x2aea8 - 0x2b2b4
int32_t function_2aea8(int32_t a1) {
    struct _IO_FILE * stream2 = g96; // 0x2aec0
    int32_t format; // 0x2aea8
    int32_t v1; // 0x2aea8
    char * str4; // bp-2088, 0x2aea8
    int32_t str3; // bp-3112, 0x2aea8
    if (stream2 == NULL) {
        // 0x2afa4
        if (g182 == NULL) {
            // 0x2b224
            str4 = (char *)0x434e4542;
            function_1ccec(3, (int32_t *)&str4, 1);
            function_2ab30(1, 1);
            // UNREACHABLE
        }
        struct _IO_FILE * stream = fopen64(g182, "r"); // 0x2afc0
        g96 = stream;
        format = (int32_t)"BENCHFILE Failed to open benchfile '%s'";
        if (stream == NULL) {
            goto lab_0x2af80;
        } else {
            // 0x2afd4
            g97 = NULL;
            char * str = fgets((char *)&str3, 1024, stream); // 0x2afe4
            format = (int32_t)"BENCHFILE Failed to read benchfile '%s'";
            if (str == NULL) {
                goto lab_0x2af80;
            } else {
                g98 = NULL;
                goto lab_0x2aee8;
            }
        }
    } else {
        char * str2 = fgets((char *)&str3, 1024, stream2); // 0x2aedc
        v1 = (int32_t)str2;
        if (str2 == NULL) {
            goto lab_0x2af34;
        } else {
            goto lab_0x2aee8;
        }
    }
  lab_0x2af34:
    // 0x2af34
    format = (int32_t)"BENCHFILE No work in benchfile '%s'";
    if (g98 != NULL) {
        // 0x2af40
        fclose(g96);
        g96 = (struct _IO_FILE *)v1;
        return function_2aea8(a1);
    }
    goto lab_0x2af80;
  lab_0x2af80:
    // 0x2af80
    snprintf((char *)&str4, 2048, (char *)format, g182);
    // 0x2af88
    function_1ccec(3, (int32_t *)&str4, 1);
    function_2ab30(1, 1);
    // UNREACHABLE
  lab_0x2aee8:;
    char * str5 = (char *)&str3;
    uint32_t v2 = str3 % 256; // 0x2aee8
    int32_t v3 = (int32_t)g97 + 1; // 0x2af00
    uint32_t v4 = v2 == 47 | v2 == 0 ? 0 : v2 == 35 ? v2 - 35 : 1;
    int32_t result = v2 == 47 ? v4 : v4 % 2;
    g97 = (struct _IO_FILE *)v3;
    while (result == 0) {
        // 0x2af1c
        v1 = 0;
        if (fgets(str5, 1024, g96) == NULL) {
            goto lab_0x2af34;
        }
        v2 = str3 % 256;
        v3 = (int32_t)g97 + 1;
        v4 = v2 == 47 | v2 == 0 ? 0 : v2 == 35 ? v2 - 35 : 1;
        result = v2 == 47 ? v4 : v4 % 2;
        g97 = (struct _IO_FILE *)v3;
    }
    char * v5 = str5; // bp-3132, 0x2b024
    int32_t v6 = (int32_t)&v5; // 0x2b024
    int32_t v7 = 0; // 0x2b024
    char * found_char_pos = strchr((char *)(int32_t)&str3, 44); // 0x2b02c
    int32_t v8 = (int32_t)found_char_pos; // 0x2b02c
    int32_t v9 = v6 + 4; // 0x2b034
    int32_t * v10 = (int32_t *)v9; // 0x2b034
    *v10 = v8;
    int32_t v11 = v7 + 1; // 0x2b038
    int32_t v12; // 0x2aea8
    int32_t str8; // 0x2aea8
    char * str6; // 0x2aea8
    int32_t len2; // 0x2b0c0
    int32_t v13; // 0x2b0c8
    int32_t v14; // 0x2aea8
    int32_t v15; // 0x2aea8
    while (found_char_pos != NULL) {
        int32_t v16 = 8 * v7; // 0x2b048
        int32_t v17 = *(int32_t *)(v16 + (int32_t)&g22); // 0x2b048
        int32_t v18 = v8 - *(int32_t *)v6; // 0x2b050
        if (v17 != 0 && v17 != v18) {
            int32_t v19 = *(int32_t *)(v16 + (int32_t)"json_escape" + 160); // 0x2b1e4
            snprintf((char *)&str4, 2048, "BENCHFILE Invalid input file line %d field %d (%s) length is %d but should be %d", v3, v11, (char *)v19, v18, v17);
            goto lab_0x2af88;
        }
        // 0x2b06c
        *found_char_pos = 0;
        int32_t str7 = v8 + 1; // 0x2b074
        *v10 = str7;
        v6 = v9;
        v7 = v11;
        if (v11 == 4) {
            uint32_t len = strlen(str6); // 0x2b090
            if (len == 9 || len < 9) {
                // 0x2b264
                snprintf((char *)&str4, 2048, "BENCHFILE Invalid input file line %d field %d (%s) length is %d but should be least %d", v3, 5, "NonceTime", len, 10);
                goto lab_0x2af88;
            } else {
                // 0x2b09c
                sprintf((char *)&str4, "0000000%c", *v5);
                len2 = strlen((char *)&str4);
                v13 = (int32_t)&str4;
                v14 = len2 + v13;
                v12 = v15 + 56;
                str8 = v14;
                goto lab_0x2b0dc;
            }
        }
        found_char_pos = strchr((char *)str7, 44);
        v8 = (int32_t)found_char_pos;
        v9 = v6 + 4;
        v10 = (int32_t *)v9;
        *v10 = v8;
        v11 = v7 + 1;
    }
    // 0x2b1fc
    snprintf((char *)&str4, 2048, "BENCHFILE Invalid input file line %d - field count is %d but should be %d", v3, v11, 5);
  lab_0x2af88:
    // 0x2af88
    function_1ccec(3, (int32_t *)&str4, 1);
    function_2ab30(1, 1);
    // UNREACHABLE
  lab_0x2b0dc:;
    int32_t v20 = v12;
    sprintf((char *)str8, "%.8s", (char *)v20);
    v12 = v20 - 8;
    str8 += 8;
    int32_t v21; // 0x2aea8
    int32_t str9; // 0x2aea8
    if (v15 == v20) {
        // 0x2b0fc
        v21 = v15 + 56;
        str9 = v14 + 64;
        goto lab_0x2b11c;
    } else {
        goto lab_0x2b0dc;
    }
  lab_0x2b11c:;
    int32_t v22 = v21;
    sprintf((char *)str9, "%.8s", (char *)v22);
    v21 = v22 - 8;
    str9 += 8;
    if (v15 == v22) {
        // 0x2b13c
        sprintf((char *)(v14 + 128), "%08lx", strtol(str6, NULL, 10));
        strcpy((char *)(v14 + 136), str6);
        memset((int32_t *)a1, 0, 448);
        function_1ea68(a1, v13, len2 + 144 >> 1);
        function_2768c(a1);
        g98 = (struct _IO_FILE *)((int32_t)g98 + 1);
        return result;
    }
    goto lab_0x2b11c;
}

// Address range: 0x2b2b4 - 0x2b310
int32_t function_2b2b4(int32_t a1, int32_t a2) {
    int32_t v1 = *__errno_location(); // 0x2b2cc
    int32_t str; // bp-2056, 0x2b2b4
    snprintf((char *)&str, 2048, "Failed to pthread_mutex_init errno=%d in %s %s():%d", v1, "cgminer.c", (char *)a1, a2);
    function_1ccec(3, &str, 1);
    return function_2ab30(1, 1);
}

// Address range: 0x2b310 - 0x2b338
int32_t function_2b310(int32_t * mutex, char * a2, int32_t a3) {
    // 0x2b310
    if (pthread_mutex_init(mutex, NULL) == 0) {
        return 0;
    }
    // 0x2b32c
    function_2b2b4((int32_t)a2, a3);
    // UNREACHABLE
}

// Address range: 0x2b338 - 0x2b394
int32_t function_2b338(int32_t a1, int32_t a2) {
    int32_t v1 = *__errno_location(); // 0x2b350
    int32_t str; // bp-2056, 0x2b338
    snprintf((char *)&str, 2048, "Failed to pthread_rwlock_init errno=%d in %s %s():%d", v1, "cgminer.c", (char *)a1, a2);
    function_1ccec(3, &str, 1);
    return function_2ab30(1, 1);
}

// Address range: 0x2b394 - 0x2b3bc
int32_t function_2b394(int32_t rwlock, char * a2, int32_t a3) {
    // 0x2b394
    if (pthread_rwlock_init((int32_t *)rwlock, NULL) == 0) {
        return 0;
    }
    // 0x2b3b0
    return (int32_t)a2;
}

// Address range: 0x2b3bc - 0x2b404
int32_t function_2b3bc(int32_t * mutex, char * a2, int32_t a3) {
    // 0x2b3bc
    if (pthread_mutex_init(mutex, NULL) != 0) {
        // 0x2b3f8
        function_2b2b4((int32_t)a2, a3);
        // UNREACHABLE
    }
    // 0x2b3dc
    if (pthread_rwlock_init((int32_t *)((int32_t)mutex + 24), NULL) == 0) {
        return 0;
    }
    // 0x2b3f8
    function_2b2b4((int32_t)a2, a3);
    // UNREACHABLE
}

// Address range: 0x2b404 - 0x2b460
int32_t function_2b404(int32_t a1, int32_t a2) {
    int32_t v1 = *__errno_location(); // 0x2b41c
    int32_t str; // bp-2056, 0x2b404
    snprintf((char *)&str, 2048, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", v1, "cgminer.c", (char *)a1, a2);
    function_1ccec(3, &str, 1);
    function_2ab30(1, 1);
    // UNREACHABLE
}

// Address range: 0x2b460 - 0x2b4bc
int32_t function_2b460(int32_t a1, int32_t a2) {
    int32_t v1 = *__errno_location(); // 0x2b478
    int32_t str; // bp-2056, 0x2b460
    snprintf((char *)&str, 2048, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", v1, "cgminer.c", (char *)a1, a2);
    function_1ccec(3, &str, 1);
    function_2ab30(1, 1);
    // UNREACHABLE
}

// Address range: 0x2b4bc - 0x2b518
int32_t function_2b4bc(int32_t a1, int32_t a2) {
    int32_t v1 = *__errno_location(); // 0x2b4d4
    int32_t str; // bp-2056, 0x2b4bc
    snprintf((char *)&str, 2048, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", v1, "cgminer.c", (char *)a1, a2);
    function_1ccec(3, &str, 1);
    function_2ab30(1, 1);
    // UNREACHABLE
}

// Address range: 0x2b518 - 0x2b57c
int32_t function_2b518(int32_t a1, int32_t a2) {
    int32_t * mutex = (int32_t *)(a1 + 188); // 0x2b528
    if (pthread_mutex_lock(mutex) != 0) {
        // 0x2b570
        return (int32_t)"pool_tclear";
    }
    // 0x2b534
    *(char *)a2 = 0;
    if (pthread_mutex_unlock(mutex) != 0) {
        // 0x2b570
        return (int32_t)"pool_tclear";
    }
    // 0x2b54c
    function_1da28();
    int32_t v1; // 0x2b518
    return (uint32_t)v1 % 256;
}

// Address range: 0x2b580 - 0x2b5f8
int32_t function_2b580(int32_t a1, int32_t a2) {
    // 0x2b580
    if (pthread_mutex_lock(&g180) != 0) {
        // 0x2b5ec
        return (int32_t)"inc_dev_status";
    }
    // 0x2b5a0
    g240 = a1;
    g258 = a2;
    if (pthread_mutex_unlock(&g180) == 0) {
        // 0x2b5cc
        return function_1da28();
    }
    // 0x2b5ec
    return (int32_t)"inc_dev_status";
}

// Address range: 0x2b5fc - 0x2b664
int32_t function_2b5fc(int32_t a1, int32_t a2) {
    int32_t * mutex = (int32_t *)(a1 + 188); // 0x2b60c
    if (pthread_mutex_lock(mutex) != 0) {
        // 0x2b658
        return (int32_t)"pool_tset";
    }
    // 0x2b618
    *(char *)a2 = 1;
    if (pthread_mutex_unlock(mutex) != 0) {
        // 0x2b658
        return (int32_t)"pool_tset";
    }
    // 0x2b634
    function_1da28();
    int32_t v1; // 0x2b5fc
    return (uint32_t)v1 % 256;
}

// Address range: 0x2b668 - 0x2be48
int32_t function_2b668(int32_t a1, int32_t a2) {
    char * v1 = (char *)(a1 + 736); // 0x2b670
    char * str; // bp-2072, 0x2b668
    if (*v1 == 0) {
        char v2 = *(char *)&g70; // 0x2bad8
        if ((v2 | *(char *)&g179) == 0 != g28 < (char *)6) {
            int32_t v3 = *(int32_t *)(a1 + 164); // 0x2baf0
            snprintf((char *)&str, 2048, "Testing pool %s", (char *)v3);
            function_1ccec(6, (int32_t *)&str, 0);
        }
    } else {
        // 0x2b684
        if (*(char *)&g71 != 0) {
            char v4 = *(char *)&g70; // 0x2bc14
            if ((v4 | *(char *)&g179) == 0 != g28 < (char *)7) {
                int32_t v5 = *(int32_t *)(a1 + 164); // 0x2bc40
                snprintf((char *)&str, 2048, "Retrieving block template from pool %s", (char *)v5);
                function_1ccec(7, (int32_t *)&str, 0);
            }
        }
    }
    char * v6 = (char *)(a1 + 640); // 0x2b698
    int32_t v7; // 0x2b668
    int32_t v8; // 0x2b668
    if (*v6 == 0) {
        // 0x2b6a4
        if (g38 == NULL) {
            char v9 = *(char *)&g70; // 0x2bd68
            if ((v9 | *(char *)&g179) == 0 == g28 < (char *)3) {
                // 0x2b8fc
                return 0;
            }
            // 0x2bd88
            str = (char *)0x4c525543;
            function_1ccec(3, (int32_t *)&str, 0);
            return 0;
        }
        char * v10 = (char *)(a1 + 99); // 0x2b6b8
        if (*v10 == 0) {
            // 0x2b6c4
            if (*(char *)&g71 == 0) {
                *v10 = 0;
                goto lab_0x2b7b8;
            } else {
                char v11 = *(char *)&g70; // 0x2b6f8
                if ((v11 | *(char *)&g179) != 0 || g28 > (char *)6) {
                    // 0x2b704
                    str = (char *)0x626f7250;
                    function_1ccec(7, (int32_t *)&str, 0);
                    char v12 = *(char *)&g71; // 0x2b738
                    *v10 = 0;
                    if (*v1 == 0) {
                        // 0x2bb10
                        if (*(char *)(a1 + 900) == 0) {
                            if (v12 == 0) {
                                goto lab_0x2b7b8;
                            } else {
                                // 0x2bdd4
                                v8 = (int32_t)"No GBT coinbase + append support found, pool unusable if it has no stratum";
                                v7 = 75;
                                if (*(char *)&g179 == 0) {
                                    goto lab_0x2bbbc;
                                } else {
                                    goto lab_0x2bb68;
                                }
                            }
                        } else {
                            if (v12 == 0) {
                                goto lab_0x2b7b8;
                            } else {
                                goto lab_0x2bb24;
                            }
                        }
                    } else {
                        if (v12 == 0) {
                            goto lab_0x2b7b8;
                        } else {
                            goto lab_0x2b750;
                        }
                    }
                } else {
                    // 0x2bb94
                    *v10 = 0;
                    if (*v1 == 0) {
                        // 0x2bba4
                        if (*(char *)(a1 + 900) == 0) {
                            // 0x2bbb0
                            v8 = (int32_t)"No GBT coinbase + append support found, pool unusable if it has no stratum";
                            v7 = 75;
                            if (*(char *)&g179 == 0) {
                                goto lab_0x2bbbc;
                            } else {
                                goto lab_0x2bb68;
                            }
                        } else {
                            goto lab_0x2bb24;
                        }
                    } else {
                        goto lab_0x2b750;
                    }
                }
            }
        } else {
            goto lab_0x2b7b8;
        }
    } else {
        goto lab_0x2b998;
    }
  lab_0x2b998:
    // 0x2b998
    if (function_2b5fc(a1, a1 + 642) != 0) {
        // 0x2b8fc
        return (int32_t)*(char *)(a1 + 641);
    }
    // 0x2b9b8
    if (function_23974(a1) == 0) {
        // 0x2b8fc
        return 0;
    }
    // 0x2b9c8
    if (*(char *)(a1 + 580) != 0) {
        // 0x2b9d4
        if (function_25a7c(a1) == 0) {
            // 0x2b8fc
            return 0;
        }
    }
    // 0x2b9e4
    if (function_20cfc(a1) == 0) {
        // 0x2b8fc
        return 0;
    }
    int32_t result = function_25e74(a1); // 0x2b9f8
    if (result == 0) {
        // 0x2b8fc
        return 0;
    }
    // 0x2ba04
    *(char *)&g265 = 1;
    int32_t attr; // bp-2108, 0x2b668
    pthread_attr_init(&attr);
    pthread_attr_setstacksize(&attr, 0x100000);
    int32_t * thread_func_arg = (int32_t *)a1; // 0x2ba3c
    int32_t v13 = pthread_create((int32_t *)(a1 + 696), &attr, (int32_t * (*)(int32_t *))0x35370, thread_func_arg); // 0x2ba3c
    int32_t v14 = (int32_t)" benchfile '%s'" | 396; // 0x2ba44
    if (v13 == 0) {
        int32_t v15 = pthread_create((int32_t *)(a1 + 700), &attr, (int32_t * (*)(int32_t *))0x37db0, thread_func_arg); // 0x2ba5c
        v14 = (int32_t)"Failed to create stratum rthread";
        if (v15 == 0) {
            // 0x2b8fc
            return result;
        }
    }
    // 0x2ba74
    str = (char *)*(int32_t *)v14;
    function_1ccec(3, (int32_t *)&str, 1);
    function_2ab30(1, 1);
    // UNREACHABLE
  lab_0x2b7b8:;
    // 0x2b7b8
    int32_t v16; // bp-2124, 0x2b668
    function_1f5c4(&v16);
    int32_t v17; // bp-2116, 0x2b668
    function_1f5c4(&v17);
    int32_t * v18 = (int32_t *)(a1 + 576); // 0x2b7c8
    int32_t v19 = *v18; // 0x2b7c8
    int32_t v20 = v19; // 0x2b7d0
    if (v19 != 0 == g99 == 0) {
        char v21 = *(char *)&g70; // 0x2b804
        int32_t v22 = v19; // 0x2b7f8
        if ((v21 | *(char *)&g179) == 0 != g28 < (char *)6) {
            // 0x2b824
            snprintf((char *)&str, 2048, "Testing pool %d stratum %s", v19, (char *)v19);
            function_1ccec(6, (int32_t *)&str, 0);
            v22 = *v18;
        }
        // 0x2b854
        v20 = 0;
        if (function_1f930(v22, a1 + 600, a1 + 584) == 0) {
            goto lab_0x2b868;
        } else {
            int32_t v23 = function_20cfc(a1); // 0x2b90c
            v20 = 0;
            if (v23 == 0) {
                goto lab_0x2b868;
            } else {
                char v24 = *(char *)&g70; // 0x2b92c
                int32_t * v25; // 0x2b668
                if ((v24 | *(char *)&g179) == 0 == g28 < (char *)5) {
                    // 0x2b918
                    v25 = (int32_t *)(a1 + 164);
                } else {
                    int32_t v26 = *v18; // 0x2b94c
                    int32_t * v27 = (int32_t *)(a1 + 164);
                    int32_t v28 = *v27; // 0x2b954
                    snprintf((char *)&str, 2048, "Switching pool %d %s to %s", v23, (char *)v28, (char *)v26);
                    function_1ccec(5, (int32_t *)&str, 0);
                    v25 = v27;
                }
                // 0x2b984
                if (*v25 == 0) {
                    // 0x2baac
                    *v25 = (int32_t)__strdup((char *)*v18);
                }
                // 0x2b990
                *v6 = 1;
                goto lab_0x2b998;
            }
        }
    } else {
        goto lab_0x2b868;
    }
  lab_0x2b868:
    // 0x2b868
    if (*v6 == 0) {
        // 0x2b874
        if (*(char *)(a1 + 900) == 0) {
            // 0x2b880
            if (*v1 == 0) {
                char v29 = *(char *)&g70; // 0x2b8a8
                if ((v29 | *(char *)&g179) == 0 != g28 < (char *)4) {
                    int32_t v30 = *(int32_t *)(a1 + 164); // 0x2b8c8
                    snprintf((char *)&str, 2048, "No Stratum, GBT or Solo support in pool %d %s unable to use", v20, (char *)v30);
                    function_1ccec(4, (int32_t *)&str, 0);
                }
                // 0x2b8fc
                return 0;
            }
        }
    }
    int32_t v31 = v20; // 0x2bc70
    if (*(char *)&g71 != 0) {
        char v32 = *(char *)&g70; // 0x2bc90
        v31 = v20;
        if ((v32 | *(char *)&g179) == 0 != g28 < (char *)7) {
            int32_t v33 = *(int32_t *)(a1 + 164); // 0x2bcb0
            snprintf((char *)&str, 2048, "FAILED to retrieve work from pool %u %s", v20, (char *)v33);
            v31 = function_1ccec(7, (int32_t *)&str, 0);
        }
    }
    // 0x2bce0
    if (a2 != 0 || *(char *)(a1 + 97) != 0) {
        // 0x2b8fc
        return 0;
    }
    char v34 = *(char *)&g70; // 0x2bd10
    if ((v34 | *(char *)&g179) != 0 || g28 > (char *)3) {
        // 0x2bd1c
        snprintf((char *)&str, 2048, "Pool %u slow/down or URL or credentials invalid", v31);
        function_1ccec(4, (int32_t *)&str, 0);
    }
    // 0x2b8fc
    return 0;
  lab_0x2b750:;
    char v35 = *(char *)&g70; // 0x2b764
    if ((v35 | *(char *)&g179) == 0 != g28 < (char *)7) {
        // 0x2b770
        str = (char *)0x20544247;
        function_1ccec(7, (int32_t *)&str, 0);
    }
    goto lab_0x2b7b8;
  lab_0x2bb24:;
    char v36 = *(char *)&g70; // 0x2bb38
    v8 = (int32_t)"GBT coinbase without append found, switching to GBT solo protocol";
    v7 = 66;
    if ((v36 | *(char *)&g179) == 0 == g28 < (char *)7) {
        goto lab_0x2b7b8;
    } else {
        goto lab_0x2bb68;
    }
  lab_0x2bbbc:
    // 0x2bbbc
    v8 = (int32_t)"No GBT coinbase + append support found, pool unusable if it has no stratum";
    v7 = 75;
    if (*(char *)&g70 == 0 == g28 < (char *)7) {
        goto lab_0x2b7b8;
    } else {
        goto lab_0x2bb68;
    }
  lab_0x2bb68:
    // 0x2bb68
    memcpy((int32_t *)&str, (int32_t *)v8, v7);
    function_1ccec(7, (int32_t *)&str, 0);
    goto lab_0x2b7b8;
}

// Address range: 0x2be48 - 0x2beac
int32_t function_2be48(void) {
    // 0x2be48
    if (pthread_mutex_lock((int32_t *)g100) != 0) {
        // 0x2bea0
        return (int32_t)"wake_gws";
    }
    // 0x2be64
    pthread_cond_signal(&g190);
    if (pthread_mutex_unlock((int32_t *)g100) == 0) {
        // 0x2be80
        return function_1da28();
    }
    // 0x2bea0
    return (int32_t)"wake_gws";
}

// Address range: 0x2beb0 - 0x2bfa8
int32_t function_2beb0(int32_t a1, uint32_t a2) {
    uint32_t v1 = a2 / 1000; // 0x2bed0
    int32_t v2; // bp-32, 0x2beb0
    function_1f5c4(&v2);
    int32_t v3; // 0x2beb0
    int32_t abstime = v1 + (int32_t)(-0xf4240 * v1 + 1000 * a2 + v3 > 0xf423f) + v2; // bp-24, 0x2bf20
    if (pthread_mutex_lock(&g218) != 0) {
        // 0x2bf9c
        return (int32_t)"restart_wait";
    }
    int32_t result = 0; // 0x2bf40
    if (*(char *)(a1 + 62) == 0) {
        // 0x2bf44
        result = pthread_cond_timedwait(&g252, &g218, (struct timespec *)&abstime);
    }
    // 0x2bf60
    if (pthread_mutex_unlock(&g218) != 0) {
        // 0x2bf9c
        return (int32_t)"restart_wait";
    }
    // 0x2bf74
    function_1da28();
    return result;
}

// Address range: 0x2bfac - 0x2c008
int32_t function_2bfac(int32_t a1, int32_t a2) {
    int32_t v1 = *__errno_location(); // 0x2bfc4
    int32_t str; // bp-2056, 0x2bfac
    snprintf((char *)&str, 2048, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", v1, "cgminer.c", (char *)a1, a2);
    function_1ccec(3, &str, 1);
    return function_2ab30(1, 1);
}

// Address range: 0x2c008 - 0x2c040
int32_t function_2c008(int32_t * rwlock, char * a2, int32_t a3) {
    // 0x2c008
    if (pthread_rwlock_unlock(rwlock) == 0) {
        // 0x2c020
        return function_1da28();
    }
    // 0x2c034
    function_2bfac((int32_t)a2, a3);
    // UNREACHABLE
}

// Address range: 0x2c040 - 0x2c0e8
int32_t function_2c040(void) {
    // 0x2c040
    if (pthread_mutex_lock(&g250) != 0 || pthread_rwlock_wrlock((int32_t *)0x740b8) != 0) {
        // 0x2c0d0
        function_2bfac((int32_t)"total_work_inc", 2300);
        // UNREACHABLE
    }
    int32_t result = g101; // 0x2c074
    g101 = result + 1;
    if (pthread_rwlock_unlock((int32_t *)0x740b8) != 0) {
        // 0x2c0d0
        function_2bfac((int32_t)"total_work_inc", 2300);
        // UNREACHABLE
    }
    // 0x2c08c
    if (pthread_mutex_unlock(&g250) != 0) {
        // 0x2c0dc
        return (int32_t)"total_work_inc";
    }
    // 0x2c0a0
    function_1da28();
    return result;
}

// Address range: 0x2c0f0 - 0x2c214
int32_t function_2c0f0(int32_t a1) {
    int32_t * v1 = (int32_t *)(a1 + 68); // 0x2c0f8
    int32_t * v2 = (int32_t *)(a1 + 240); // 0x2c110
    int32_t v3 = llvm_bswap_i32(llvm_bswap_i32(*v1) + 1); // 0x2c128
    int32_t v4 = *v2 + 1; // 0x2c130
    *v1 = v3;
    *v2 = v4;
    *(int32_t *)(a1 + 248) = 0;
    g206++;
    int32_t v5 = v4; // 0x2c14c
    if (*(char *)&g71 == 0) {
        goto lab_0x2c1a8;
    } else {
        // 0x2c150
        if (*(char *)&g179 == 0) {
            // 0x2c164
            v5 = v4;
            if (*(char *)&g70 == 0 == g28 < (char *)7) {
                goto lab_0x2c1a8;
            } else {
                goto lab_0x2c178;
            }
        } else {
            goto lab_0x2c178;
        }
    }
  lab_0x2c1a8:;
    int32_t v6 = *(int32_t *)(a1 + 308); // 0x2c1a8
    int32_t result = v5; // 0x2c1b0
    char * v7; // bp-2064, 0x2c0f0
    if (v6 != 0) {
        int32_t v8 = (int32_t)&v7; // 0x2c1bc
        function_1ea68(v8, v6, 4);
        int32_t v9 = llvm_bswap_i32((int32_t)v7); // 0x2c1d4
        v7 = (char *)llvm_bswap_i32(v9 + 1);
        result = function_1e944((int32_t *)v6, v8, 4);
    }
    // 0x2c1e8
    *(int32_t *)(a1 + 340) = result;
    return result;
  lab_0x2c178:
    // 0x2c178
    v7 = (char *)0x63637553;
    v5 = function_1ccec(7, (int32_t *)&v7, 0);
    goto lab_0x2c1a8;
}

// Address range: 0x2c214 - 0x2c2a8
int32_t function_2c214(void) {
    int32_t result = function_1e7d4(1, 448, "cgminer.c", "make_work", 2307); // 0x2c23c
    if (result != 0) {
        // 0x2c248
        *(int32_t *)(result + 340) = result;
        return result;
    }
    char * v1 = (char *)0x6c696146; // bp-2056, 0x2c270
    function_1ccec(3, (int32_t *)&v1, 1);
    return function_2ab30(1, 1);
}

// Address range: 0x2c2ac - 0x2c2d4
int32_t function_2c2ac(int32_t a1, int32_t a2) {
    int32_t result = function_2c214(); // 0x2c2b8
    function_28ee4(result, a1, a2);
    return result;
}

// Address range: 0x2c2d4 - 0x2c320
int32_t function_2c2d4(int32_t a1) {
    int32_t result = function_2c214(); // 0x2c2dc
    function_28ee4(result, a1, 0);
    *(char *)(result + 273) = 1;
    function_1f5c4((int32_t *)(result + 416));
    int32_t * v1 = (int32_t *)(result + 264); // 0x2c300
    *(char *)(result + 280) = 0;
    *(char *)(result + 282) = 0;
    *v1 = *v1 - 1;
    return result;
}

// Address range: 0x2c320 - 0x2c388
int32_t function_2c320(int32_t a1, int32_t a2) {
    int32_t * rwlock = (int32_t *)(a1 + 320); // 0x2c334
    if (pthread_rwlock_wrlock(rwlock) != 0) {
        // 0x2c37c
        return function_2bfac((int32_t)"add_queued", 0x2519);
    }
    // 0x2c340
    function_2a4b4();
    if (pthread_rwlock_unlock(rwlock) == 0) {
        // 0x2c35c
        return function_1da28();
    }
    // 0x2c37c
    return function_2bfac((int32_t)"add_queued", 0x2519);
}

// Address range: 0x2c38c - 0x2c414
int32_t function_2c38c(int32_t a1, int32_t a2) {
    int32_t v1 = a2; // bp-20, 0x2c3a0
    int32_t * rwlock = (int32_t *)(a1 + 320); // 0x2c3a4
    if (pthread_rwlock_wrlock(rwlock) != 0) {
        // 0x2c408
        return function_2bfac((int32_t)"work_completed", 0x25b1);
    }
    // 0x2c3b0
    function_2a9a8();
    if (pthread_rwlock_unlock(rwlock) != 0) {
        // 0x2c408
        return function_2bfac((int32_t)"work_completed", 0x25b1);
    }
    // 0x2c3cc
    function_1da28();
    int32_t result = function_28ffc((int32_t)&v1, (int32_t)"cgminer.c", (int32_t)"work_completed", 0x25b3); // 0x2c3f0
    return result;
}

// Address range: 0x2c418 - 0x2c4c0
int32_t function_2c418(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    int32_t * rwlock = (int32_t *)(a1 + 320); // 0x2c438
    if (pthread_rwlock_wrlock(rwlock) != 0) {
        // 0x2c4b4
        return function_2bfac((int32_t)"take_queued_work_bymidstate", 0x25c0);
    }
    int32_t result = *(int32_t *)(a1 + 352); // 0x2c450
    if (result != 0) {
        // 0x2c470
        function_2a9a8();
    }
    // 0x2c47c
    if (pthread_rwlock_unlock(rwlock) != 0) {
        // 0x2c4b4
        return function_2bfac((int32_t)"take_queued_work_bymidstate", 0x25c0);
    }
    // 0x2c48c
    function_1da28();
    return result;
}

// Address range: 0x2c4c6 - 0x2c4de
int32_t function_2c4c6(int32_t a1) {
    // 0x2c4c6
    int32_t v1; // 0x2c4c6
    uint32_t v2 = v1;
    bool v3; // 0x2c4c6
    bool v4 = v3 ? (v2 & 0x20000) != 0 : v3;
    int32_t v5 = a1; // 0x2c4ca
    if (v4 == !v3) {
        v5 = function_e4b52();
    }
    bool v6 = true; // 0x2c4ce
    bool v7 = v4; // 0x2c4ce
    if (v3 || false) {
        v7 = (v2 / 0x4000000 & v1) == 0 ? (v2 & 8) != 0 : (v2 & 0x2000000) != 0;
        v6 = (v2 / 0x4000000 & v1) != 0;
    }
    int32_t result = v5; // 0x2c4d6
    if (v7 == v6) {
        __asm_stchi(2, 14, *(int32_t *)(v1 - 564));
        result = function_1064efa();
    }
    // 0x2c4de
    return result;
}

// Address range: 0x2c4e0 - 0x2c5bc
int32_t function_2c4e0(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x2c4e0
    function_1f5c4((int32_t *)a1);
    int32_t v1; // 0x2c4e0
    int32_t * rwlock = (int32_t *)v1; // 0x2c4e8
    if (pthread_rwlock_wrlock(rwlock) != 0) {
        // 0x2c5b0
        return function_2bfac((int32_t)"age_queued_work", 0x25a5);
    }
    int32_t v2 = *(int32_t *)(v1 + 352); // 0x2c4f4
    if (v2 != 0) {
        // 0x2c514
        int32_t v3; // 0x2c4e0
        return function_1f8ec((int32_t)&v3, (int32_t *)(v2 + 424));
    }
    // 0x2c574
    if (pthread_rwlock_unlock(rwlock) != 0) {
        // 0x2c5b0
        return function_2bfac((int32_t)"age_queued_work", 0x25a5);
    }
    // 0x2c584
    function_1da28();
    float64_t v4; // 0x2c4e0
    __asm_vpop(v4);
    return 0;
}

// Address range: 0x2c5c0 - 0x2c61c
int32_t function_2c5c0(char * a1, int32_t a2) {
    int32_t v1 = *__errno_location(); // 0x2c5d8
    int32_t str; // bp-2056, 0x2c5c0
    snprintf((char *)&str, 2048, "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d", v1, "cgminer.c", a1, a2);
    function_1ccec(3, &str, 1);
    function_2ab30(1, 1);
    // UNREACHABLE
}

// Address range: 0x2c61c - 0x2c6e4
int32_t function_2c61c(int32_t a1, int32_t a2) {
    int32_t * rwlock = (int32_t *)(a1 + 320); // 0x2c630
    if (pthread_rwlock_rdlock(rwlock) != 0) {
        // 0x2c6cc
        function_2c5c0("clone_queued_work_byid", 0x2580);
        // UNREACHABLE
    }
    int32_t v1 = *(int32_t *)(a1 + 352); // 0x2c63c
    int32_t result = 0; // 0x2c644
    int32_t v2; // 0x2c61c
    if (v1 == 0) {
        goto lab_0x2c688;
    } else {
        int32_t v3 = *(int32_t *)(v1 + 352); // 0x2c64c
        v2 = v1;
        if (*(int32_t *)(v1 + 340) == a2) {
            goto lab_0x2c6b4;
        } else {
            int32_t v4 = v3; // 0x2c660
            result = 0;
            if (v3 == 0) {
                goto lab_0x2c688;
            } else {
                int32_t v5 = *(int32_t *)(v4 + 352);
                v2 = v4;
                while (*(int32_t *)(v4 + 340) != a2) {
                    // 0x2c680
                    v4 = v5;
                    result = 0;
                    if (v5 == 0) {
                        goto lab_0x2c688;
                    }
                    v5 = *(int32_t *)(v4 + 352);
                    v2 = v4;
                }
                goto lab_0x2c6b4;
            }
        }
    }
  lab_0x2c688:
    // 0x2c688
    if (pthread_rwlock_unlock(rwlock) == 0) {
        // 0x2c698
        function_1da28();
        return result;
    }
    // 0x2c6d8
    return function_2bfac((int32_t)"clone_queued_work_byid", 0x2584);
  lab_0x2c6b4:;
    int32_t v6 = function_2c214(); // 0x2c6b4
    function_28ee4(v6, v2, 0);
    result = v6;
    goto lab_0x2c688;
}

// Address range: 0x2c6e8 - 0x2c7a0
int32_t function_2c6e8(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    int32_t * rwlock = (int32_t *)(a1 + 320); // 0x2c708
    if (pthread_rwlock_rdlock(rwlock) != 0) {
        // 0x2c780
        function_2c5c0("clone_queued_work_bymidstate", 0x2551);
        // UNREACHABLE
    }
    int32_t v1 = *(int32_t *)(a1 + 352); // 0x2c720
    int32_t result = 0; // 0x2c73c
    if (v1 != 0) {
        // 0x2c740
        result = function_2c214();
        function_28ee4(result, v1, 0);
    }
    // 0x2c754
    if (pthread_rwlock_unlock(rwlock) == 0) {
        // 0x2c764
        function_1da28();
        return result;
    }
    // 0x2c78c
    function_2bfac((int32_t)"clone_queued_work_bymidstate", 0x2555);
    // UNREACHABLE
}

// Address range: 0x2c7a4 - 0x2c854
int32_t function_2c7a4(int32_t a1, int32_t a2) {
    int32_t * rwlock = (int32_t *)(a1 + 320); // 0x2c7b8
    if (pthread_rwlock_rdlock(rwlock) != 0) {
        // 0x2c83c
        function_2c5c0("find_queued_work_byid", 0x2574);
        // UNREACHABLE
    }
    int32_t v1 = *(int32_t *)(a1 + 352); // 0x2c7c4
    int32_t result = 0; // 0x2c7cc
    if (v1 != 0) {
        int32_t v2 = *(int32_t *)(v1 + 352); // 0x2c7d4
        result = v1;
        if (*(int32_t *)(v1 + 340) != a2) {
            int32_t v3 = v2; // 0x2c7e4
            result = 0;
            if (v2 != 0) {
                int32_t v4 = *(int32_t *)(v3 + 352);
                result = v3;
                while (*(int32_t *)(v3 + 340) != a2) {
                    // 0x2c804
                    v3 = v4;
                    result = 0;
                    if (v4 == 0) {
                        // break -> 0x2c80c
                        break;
                    }
                    v4 = *(int32_t *)(v3 + 352);
                    result = v3;
                }
            }
        }
    }
    // 0x2c80c
    if (pthread_rwlock_unlock(rwlock) != 0) {
        // 0x2c848
        return function_2bfac((int32_t)"find_queued_work_byid", 0x2576);
    }
    // 0x2c81c
    function_1da28();
    return result;
}

// Address range: 0x2c858 - 0x2c8f0
int32_t function_2c858(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    int32_t * rwlock = (int32_t *)(a1 + 320); // 0x2c878
    if (pthread_rwlock_rdlock(rwlock) != 0) {
        // 0x2c8d8
        function_2c5c0("find_queued_work_bymidstate", 0x2545);
        // UNREACHABLE
    }
    // 0x2c884
    if (pthread_rwlock_unlock(rwlock) != 0) {
        // 0x2c8e4
        return function_2bfac((int32_t)"find_queued_work_bymidstate", 0x2547);
    }
    // 0x2c8bc
    function_1da28();
    return *(int32_t *)(a1 + 352);
}

// Address range: 0x2c8f4 - 0x2c964
int32_t function_2c8f4(int32_t a1) {
    // 0x2c8f4
    if (pthread_rwlock_rdlock(&g227) != 0) {
        // 0x2c94c
        function_2c5c0("get_devices", 634);
        // UNREACHABLE
    }
    // 0x2c910
    if (pthread_rwlock_unlock(&g227) != 0) {
        // 0x2c958
        return function_2bfac((int32_t)"get_devices", 636);
    }
    // 0x2c934
    function_1da28();
    return *(int32_t *)(g217 + 4 * a1);
}

// Address range: 0x2c968 - 0x2ca24
int32_t function_2c968(void) {
    // 0x2c968
    float64_t v1; // 0x2c968
    __asm_vpush_7(v1, v1, v1);
    __asm_vldr(0);
    __asm_vldr((int32_t)(float32_t)g35);
    uint64_t v2 = *(int64_t *)&g198; // 0x2c9e4
    int32_t v3 = v2; // 0x2c9e4
    __asm_vmov_8(function_4930c((int32_t)(v2 / 0x100000000), v3), v3);
    return (int32_t)(*(int64_t *)&g185 / 0x100000000);
}

// Address range: 0x2ca26 - 0x2ca5a
int32_t function_2ca26(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x2ca26
    bool v1; // 0x2ca26
    bool v2; // 0x2ca26
    bool v3; // 0x2ca26
    bool v4; // 0x2ca26
    bool v5; // 0x2ca26
    int32_t v6; // 0x2ca26
    bool v7; // 0x2ca26
    int32_t v8; // 0x2ca26
    if (v7) {
        if (v7) {
            goto lab_0x2ca2e;
        } else {
            bool v9 = (a2 & 0x800000) != 0 | v7;
            v6 = a1;
            v5 = false;
            v2 = v9;
            v1 = v9;
            goto lab_dec_label_pc_unknown_12;
        }
    } else {
        int32_t v10 = v8 ^ 2160; // 0x2ca26
        v4 = v10 < 0;
        if (v10 == 0) {
            goto lab_0x2ca2e;
        } else {
            bool v11 = (a2 & 0x800000) != 0 | v7;
            v6 = function_2a618a();
            v5 = false;
            v3 = v10 < 0;
            v2 = v11;
            v1 = v11;
            goto lab_dec_label_pc_unknown_12;
        }
    }
  lab_0x2ca2e:;
    int32_t v12 = function_62b232(); // 0x2ca2a
    bool v13 = (a2 & 0x800000) != 0 | v7;
    if (v7) {
        // 0x2ca36
        v6 = v12;
        v5 = true;
        v3 = v4;
        v2 = v13;
        v1 = (v8 & 8) != 0;
    } else {
        // 0x2ca36
        v6 = function_2a618a();
        v5 = true;
        v3 = v4;
        v2 = v13;
        v1 = (v8 & 8) != 0;
    }
    goto lab_dec_label_pc_unknown_12;
  lab_dec_label_pc_unknown_12:;
    int32_t v14 = v6; // 0x2ca3a
    if (v3 == v7) {
        v14 = function_26578e();
    }
    int32_t result = v14; // 0x2ca3e
    if (v1 == !v5) {
        result = function_2682ee();
    }
    // 0x2ca42
    if (!((v5 ? (v8 & 0x8000000) != 0 : v2))) {
        *(char *)result = (char)a2;
    }
    if (v5) {
        return result - a4;
    }
    // 0x2ca56
    return result;
}

// Address range: 0x2ca5a - 0x2ca60
int32_t function_2ca5a(uint32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x2ca5a
    *(int32_t *)a4 = a3;
    return function_2d766(a1 / 256);
}

// Address range: 0x2ca60 - 0x2cb5c
int32_t function_2ca60(void) {
    // 0x2ca60
    int32_t v1; // 0x2ca60
    int32_t v2 = *(int32_t *)((uint32_t)v1 % 0x10000 | (int32_t)" benchfile '%s'"); // 0x2ca6c
    int32_t str = v2; // bp+296, 0x2ca70
    function_1ccec(4, &str, 0);
    char v3 = v1;
    if ((*(char *)&g70 || v3) == 0) {
        function_2db98();
    }
    // 0x2cab4
    snprintf((char *)&str, 2048, "Started at %s", (char *)&g104);
    function_1ccec(4, &str, 0);
    if (g188 == (char *)1) {
        function_2dab0();
    }
    // 0x2caf0
    if ((*(char *)&g70 || v3) == 0) {
        function_2d9b0();
    }
    // 0x2cb10
    snprintf((char *)&str, 2048, "Runtime: %d hrs : %d mins : %d secs", v1, v1, v1);
    int32_t result = function_1ccec(4, &str, 0); // 0x2cb40
    __asm_vldr(v1);
    __asm_vldr((int32_t)(float32_t)g177);
    return result;
}

// Address range: 0x2cb5c - 0x2cb68
int32_t function_2cb5c(int32_t a1) {
    // 0x2cb5c
    __asm_cdp(0, 8, 0, 5, 4, 0);
    return function_2d0a0(0);
}

// Address range: 0x2cb68 - 0x2cdc0
int32_t function_2cb68(int32_t a1, int32_t a2, int32_t a3, uint32_t a4, int32_t a5) {
    unsigned char v1 = *(char *)(a4 % 0x10000 | 0x60000); // 0x2cb6c
    if (v1 == 0) {
        function_2dbb4();
    }
    // 0x2cb78
    int32_t v2; // 0x2cb68
    char v3 = v2;
    float64_t v4; // 0x2cb68
    __asm_vstr(v4, a5);
    char * str = (char *)v2; // 0x2cb8c
    snprintf(str, 2048, "Average hashrate: %.1f Mhash/s", (float64_t)(int64_t)v1);
    int32_t * v5 = (int32_t *)v2; // 0x2cb9c
    function_1ccec(4, v5, 0);
    if ((*(char *)&g70 || v3) == 0) {
        function_2dcd4();
    }
    // 0x2cbc0
    snprintf(str, 2048, "Solved blocks: %d", g244);
    function_1ccec(4, v5, 0);
    if ((*(char *)&g70 || v3) == 0) {
        function_2dd00();
    }
    // 0x2cc10
    snprintf(str, 2048, "Best share difficulty: %s", (char *)&g37);
    function_1ccec(4, v5, 0);
    if ((*(char *)&g70 || v3) == 0) {
        function_2db24();
    }
    // 0x2cc58
    snprintf(str, 2048, "Share submissions: %lld", (int64_t)(v2 + (int32_t)g225));
    function_1ccec(4, v5, 0);
    char v6 = v3; // 0x2cca8
    if (v3 == 0) {
        char v7 = *(char *)&g70; // 0x2ccb4
        v6 = v7;
        if (v7 == 0) {
            function_2dbc0();
            v6 = 0;
        }
    }
    // 0x2ccc0
    snprintf(str, 2048, "Accepted shares: %lld", (int64_t)v6);
    function_1ccec(4, v5, 0);
    if ((*(char *)&g70 || v3) == 0) {
        function_2dcc8();
    }
    // 0x2cd0c
    snprintf(str, 2048, "Rejected shares: %lld", (int64_t)(int32_t)&g225);
    function_1ccec(4, v5, 0);
    if ((*(char *)&g70 || v3) == 0) {
        function_2dd0c();
    }
    // 0x2cd7c
    snprintf(str, 2048, "Accepted difficulty shares: %1.f", (float64_t)(int64_t)(int32_t)&g210);
    int32_t result = function_1ccec(4, v5, 0); // 0x2cdb8
    if (v3 != 0) {
        result = function_2cdd0();
    }
    // 0x2cdbc
    return result;
}

// Address range: 0x2cdc2 - 0x2cdc4
int32_t function_2cdc2(int32_t a1) {
    // 0x2cdc2
    return function_2d766(a1);
}

// Address range: 0x2cdc4 - 0x2cdd0
int32_t function_2cdc4(void) {
    // 0x2cdc4
    int32_t result; // 0x2cdc4
    return result;
}

// Address range: 0x2cdd0 - 0x2ce90
int32_t function_2cdd0(void) {
    // 0x2cdd0
    int32_t str; // 0x2cdd0
    snprintf((char *)str, 2048, "Rejected difficulty shares: %1.f", (float64_t)(int64_t)(int32_t)&g223);
    function_1ccec(4, (int32_t *)str, 0);
    int32_t v1; // 0x2cdd0
    uint64_t v2 = *(int64_t *)&v1; // 0x2ce04
    int32_t v3 = v2; // 0x2ce04
    uint64_t v4 = v2 / 0x100000000; // 0x2ce04
    v1 = v3;
    if ((int32_t)(v4 || v2) == 0) {
        function_2d1bc();
    }
    // 0x2ce10
    if ((*(char *)&g70 || (char)str) == 0) {
        function_2dbf8();
    }
    uint32_t v5 = (int32_t)g225; // 0x2ce3c
    int32_t v6 = g226; // 0x2ce3c
    uint32_t v7 = 2 * v5; // 0x2ce40
    uint32_t v8 = 3 * v5; // 0x2ce48
    int32_t v9 = v6 + (int32_t)(v8 < v7) + (2 * v6 | (int32_t)(v7 < v5)); // 0x2ce4c
    uint32_t v10 = 100 * v5; // 0x2ce64
    int32_t v11 = v6 + (int32_t)(v10 < 99 * v5) + (int32_t)((v8 & 0x4000000) != 0) + v9 + (32 * v9 | v8 / 0x8000000); // 0x2ce68
    __asm_vmov_8(function_4930c(v10, v11), v11);
    uint32_t v12 = v5 + (int32_t)v4; // 0x2ce74
    int32_t v13 = v6 + v3 + (int32_t)(v12 < v5); // 0x2ce78
    int32_t result = function_4930c(v12, v13); // 0x2ce7c
    __asm_vmov_8(result, v13);
    return result;
}

// Address range: 0x2ce90 - 0x2ce98
int32_t function_2ce90(int32_t result) {
    // 0x2ce90
    __asm_cdp(0, 8, 0, 9, 5, 0);
    return result;
}

// Address range: 0x2ce98 - 0x2ceb0
int32_t function_2ce98(int32_t a1) {
    // 0x2ce98
    float64_t v1; // 0x2ce98
    __asm_vstr(v1, a1);
    int32_t str; // 0x2ce98
    snprintf((char *)str, str, (char *)str);
    return function_1ccec(4, (int32_t *)str, 0);
}

// Address range: 0x2ceb0 - 0x2d060
int32_t function_2ceb0(int32_t a1) {
    // 0x2ceb0
    int32_t v1; // 0x2ceb0
    char v2 = v1;
    if ((*(char *)&g70 || v2) == 0) {
        function_2da1c();
    }
    // 0x2ced0
    int32_t str; // bp+296, 0x2ceb0
    snprintf((char *)&str, 2048, "Hardware errors: %d", g239);
    function_1ccec(4, &str, 0);
    if ((*(char *)&g70 || v2) == 0) {
        function_2dc90();
    }
    // 0x2cf24
    float64_t v3; // 0x2ceb0
    __asm_vstr(v3, a1);
    snprintf((char *)&str, 2048, "Utility (accepted shares / min): %.2f/min");
    function_1ccec(4, &str, 0);
    if ((*(char *)&g70 || v2) == 0) {
        function_2dcac();
    }
    // 0x2cf6c
    __asm_vstr(v3, a1);
    snprintf((char *)&str, 2048, "Work Utility (diff1 shares solved / min): %.2f/min\n");
    function_1ccec(4, &str, 0);
    if ((*(char *)&g70 || v2) == 0) {
        function_2dc20();
    }
    // 0x2cfb4
    snprintf((char *)&str, 2048, "Stale submissions discarded due to new blocks: %lld", (int64_t)(int32_t)&g266);
    function_1ccec(4, &str, 0);
    if ((*(char *)&g70 || v2) == 0) {
        function_2dc3c();
    }
    // 0x2d008
    snprintf((char *)&str, 2048, "Unable to get work from server occasions: %d", g203);
    int32_t result = function_1ccec(4, &str, 0); // 0x2d040
    if ((*(char *)&g70 || v2) == 0) {
        result = function_2dc58();
    }
    // 0x2d058
    return result;
}

// Address range: 0x2d062 - 0x2d064
int32_t function_2d062(int32_t a1) {
    // 0x2d062
    return function_2d766(a1);
}

// Address range: 0x2d064 - 0x2d0a0
int32_t function_2d064(int32_t a1, int32_t a2, uint32_t a3, int32_t a4) {
    // 0x2d064
    int32_t str; // 0x2d064
    snprintf((char *)str, 2048, (char *)(a3 % 0x10000 | (int32_t)" benchfile '%s'"));
    int32_t result = function_1ccec(4, (int32_t *)str, 0); // 0x2d090
    if ((char)str != 0) {
        result = function_2d0a8();
    }
    // 0x2d094
    return result;
}

// Address range: 0x2d0a0 - 0x2d0a4
int32_t function_2d0a0(int32_t a1) {
    // 0x2d0a0
    return function_2d74c(a1);
}

// Address range: 0x2d0a4 - 0x2d0a8
int32_t function_2d0a4(void) {
    // 0x2d0a4
    int32_t result; // 0x2d0a4
    return result;
}

// Address range: 0x2d0a8 - 0x2d0f8
int32_t function_2d0a8(void) {
    // 0x2d0a8
    int32_t str; // 0x2d0a8
    snprintf((char *)str, 2048, "Submitting work remotely delay occasions: %d", g181);
    int32_t result = function_1ccec(4, (int32_t *)str, 0); // 0x2d0e0
    if ((char)str != 0) {
        result = function_2d0f8();
    }
    // 0x2d0e4
    return result;
}

// Address range: 0x2d0f8 - 0x2d134
int32_t function_2d0f8(void) {
    // 0x2d0f8
    int32_t str; // 0x2d0f8
    snprintf((char *)str, 2048, "New blocks detected on network: %d\n", g257);
    return function_1ccec(4, (int32_t *)str, 0);
}

// Address range: 0x2d134 - 0x2d174
int32_t function_2d134(void) {
    // 0x2d134
    int32_t result; // 0x2d134
    return result;
}

// Address range: 0x2d176 - 0x2d178
int32_t function_2d176(int32_t a1) {
    // 0x2d176
    return function_2d0a0(a1);
}

// Address range: 0x2d178 - 0x2d1bc
int32_t function_2d178(void) {
    // 0x2d178
    int32_t v1; // 0x2d178
    bool v2; // 0x2d178
    if (!v2) {
        v1 = function_2d1e8();
    }
    int32_t v3 = v1; // 0x2d184
    int32_t v4; // 0x2d178
    if ((char)v4 != 0) {
        v3 = function_2d1e8();
    }
    int32_t v5 = v3; // 0x2d198
    if (g28 > (char *)3) {
        v5 = function_2d1e8();
    }
    int32_t v6 = *(int32_t *)(v4 + 32); // 0x2d19c
    int32_t v7 = v5; // 0x2d1a4
    if (v6 == 0) {
        v7 = function_2d278();
    }
    int32_t v8 = (int32_t)g28; // 0x2d1a8
    int32_t v9 = v7; // 0x2d1b0
    if (g28 < (char *)4) {
        v9 = function_2d840(v7, v8, (int32_t)&g28);
    }
    // 0x2d1b4
    return function_2d22c(v9, v8, (int32_t)&g28, v6);
}

// Address range: 0x2d1bc - 0x2d1e8
int32_t function_2d1bc(void) {
    uint64_t v1 = g225; // 0x2d1c4
    int32_t result; // 0x2d1bc
    if ((int32_t)(v1 / 0x100000000 || v1) == 0) {
        result = function_2ceb0((int32_t)&g306);
    }
    // 0x2d1d0
    return result;
}

// Address range: 0x2d1e8 - 0x2d22c
int32_t function_2d1e8(void) {
    // 0x2d1e8
    int32_t v1; // 0x2d1e8
    int32_t v2 = *(int32_t *)(v1 + 164); // 0x2d1f0
    int32_t str; // bp+296, 0x2d1e8
    snprintf((char *)&str, 2048, "Pool: %s", (char *)v2);
    int32_t result = function_1ccec(4, &str, 0); // 0x2d21c
    if (*(int32_t *)(v1 + 32) == 0) {
        result = function_2d26c();
    }
    // 0x2d220
    return result;
}

// Address range: 0x2d22c - 0x2d26c
int32_t function_2d22c(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = a4 < 2 ? (int32_t)&g19 : (int32_t)&g16;
    int32_t str; // 0x2d22c
    snprintf((char *)str, 2048, "SOLVED %d BLOCK%s!", a4, (char *)v1);
    return function_1ccec(4, (int32_t *)str, 0);
}

// Address range: 0x2d26c - 0x2d278
int32_t function_2d26c(void) {
    // 0x2d26c
    int32_t result; // 0x2d26c
    return result;
}

// Address range: 0x2d278 - 0x2d27c
int32_t function_2d278(void) {
    // 0x2d278
    int32_t result; // 0x2d278
    return result;
}

// Address range: 0x2d27c - 0x2d280
int32_t function_2d27c(int32_t a1) {
    // 0x2d27c
    return function_2d928();
}

// Address range: 0x2d280 - 0x2d284
int32_t function_2d280(void) {
    // 0x2d280
    int32_t result; // 0x2d280
    return result;
}

// Address range: 0x2d284 - 0x2d288
int32_t function_2d284(void) {
    // 0x2d284
    int32_t result; // 0x2d284
    return result;
}

// Address range: 0x2d288 - 0x2d28c
int32_t function_2d288(int32_t a1, int32_t a2, int32_t a3) {
    // 0x2d288
    return 0;
}

// Address range: 0x2d28c - 0x2d290
int32_t function_2d28c(void) {
    // 0x2d28c
    int32_t result; // 0x2d28c
    return result;
}

// Address range: 0x2d292 - 0x2d294
int32_t function_2d292(int32_t a1) {
    // 0x2d292
    return function_2d766(a1);
}

// Address range: 0x2d294 - 0x2d2e4
int32_t function_2d294(int32_t a1, int32_t a2, uint32_t a3, int32_t a4) {
    // 0x2d294
    int32_t str; // 0x2d294
    snprintf((char *)str, 2048, (char *)(a3 % 0x10000 | (int32_t)" benchfile '%s'"));
    int32_t result = function_1ccec(4, (int32_t *)str, 0); // 0x2d2d4
    if ((char)str != 0) {
        result = function_2d2e4();
    }
    // 0x2d2d8
    return result;
}

// Address range: 0x2d2e4 - 0x2d328
int32_t function_2d2e4(void) {
    // 0x2d2e4
    int32_t str; // 0x2d2e4
    snprintf((char *)str, 2048, " Accepted shares: %lld", (int64_t)str);
    int32_t result = function_1ccec(4, (int32_t *)str, 0); // 0x2d318
    if ((char)str != 0) {
        result = function_2d328();
    }
    // 0x2d31c
    return result;
}

// Address range: 0x2d328 - 0x2d36c
int32_t function_2d328(void) {
    // 0x2d328
    int32_t str; // 0x2d328
    snprintf((char *)str, 2048, " Rejected shares: %lld", (int64_t)str);
    int32_t result = function_1ccec(4, (int32_t *)str, 0); // 0x2d35c
    if ((char)str != 0) {
        result = function_2d36c();
    }
    // 0x2d360
    return result;
}

// Address range: 0x2d36c - 0x2d3b0
int32_t function_2d36c(void) {
    // 0x2d36c
    int32_t str; // 0x2d36c
    snprintf((char *)str, 2048, " Accepted difficulty shares: %1.f", (float64_t)(int64_t)str);
    int32_t result = function_1ccec(4, (int32_t *)str, 0); // 0x2d3a0
    if ((char)str != 0) {
        result = function_2d3b0();
    }
    // 0x2d3a4
    return result;
}

// Address range: 0x2d3b0 - 0x2d3e8
int32_t function_2d3b0(void) {
    // 0x2d3b0
    int32_t str; // 0x2d3b0
    snprintf((char *)str, 2048, " Rejected difficulty shares: %1.f", (float64_t)(int64_t)str);
    return function_1ccec(4, (int32_t *)str, 0);
}

// Address range: 0x2d3e8 - 0x2d3fc
int32_t function_2d3e8(void) {
    // 0x2d3e8
    int32_t v1; // 0x2d3e8
    uint64_t v2 = *(int64_t *)(v1 + 16); // 0x2d3e8
    int32_t result; // 0x2d3e8
    if ((int32_t)(v2 / 0x100000000 || v2) == 0) {
        result = function_2d4a0();
    }
    // 0x2d3f4
    return result;
}

// Address range: 0x2d3fc - 0x2d414
int32_t function_2d3fc(void) {
    // 0x2d3fc
    int32_t result; // 0x2d3fc
    int32_t v1; // 0x2d3fc
    if ((char)v1 != 0) {
        result = function_2d414();
    }
    // 0x2d408
    return result;
}

// Address range: 0x2d414 - 0x2d444
int32_t function_2d414(void) {
    // 0x2d414
    int32_t v1; // 0x2d414
    return 99 * *(int32_t *)(v1 + 16);
}

// Address range: 0x2d446 - 0x2d448
int32_t function_2d446(int32_t a1) {
    // 0x2d446
    int32_t v1; // 0x2d446
    return function_2d766(v1);
}

// Address range: 0x2d448 - 0x2d480
int32_t function_2d448(uint32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, uint32_t a6) {
    uint32_t v1 = a4 + a1; // 0x2d44c
    bool v2; // 0x2d448
    int32_t v3; // 0x2d448
    int32_t v4 = a3 + a2 + (int32_t)(v1 < a1) + (int32_t)(bool)v2 + v3; // 0x2d450
    __asm_vmov_8(function_4930c(v1, v4), v4);
    uint32_t v5 = v3 + a6; // 0x2d464
    int32_t v6 = v3 + a5 + (int32_t)(v5 < a6); // 0x2d468
    int32_t result = function_4930c(v5, v6); // 0x2d46c
    __asm_vmov_8(result, v6);
    return result;
}

// Address range: 0x2d480 - 0x2d488
int32_t function_2d480(int32_t a1) {
    // 0x2d480
    __asm_cdp(0, 8, 0, 8, 5, 0);
    return function_2d7ca();
}

// Address range: 0x2d488 - 0x2d4a0
int32_t function_2d488(int32_t a1) {
    // 0x2d488
    float64_t v1; // 0x2d488
    __asm_vstr(v1, a1);
    int32_t str; // 0x2d488
    snprintf((char *)str, str, (char *)str);
    return function_1ccec(4, (int32_t *)str, 0);
}

// Address range: 0x2d4a0 - 0x2d4b8
int32_t function_2d4a0(void) {
    // 0x2d4a0
    int32_t result; // 0x2d4a0
    int32_t v1; // 0x2d4a0
    if ((char)v1 != 0) {
        result = function_2d4b8();
    }
    // 0x2d4ac
    return result;
}

// Address range: 0x2d4b8 - 0x2d4fc
int32_t function_2d4b8(void) {
    // 0x2d4b8
    int32_t str; // bp+296, 0x2d4b8
    int32_t v1; // 0x2d4b8
    snprintf((char *)&str, 2048, " Items worked on: %d", *(int32_t *)(v1 + 68));
    int32_t result = function_1ccec(4, &str, 0); // 0x2d4ec
    if ((char)v1 != 0) {
        result = function_2d4fc();
    }
    // 0x2d4f0
    return result;
}

// Address range: 0x2d4fc - 0x2d53c
int32_t function_2d4fc(void) {
    // 0x2d4fc
    int32_t str; // 0x2d4fc
    int32_t v1 = *(int32_t *)(str + 120); // 0x2d500
    snprintf((char *)str, 2048, " Stale submissions discarded due to new blocks: %d", v1);
    int32_t result = function_1ccec(4, (int32_t *)str, 0); // 0x2d52c
    if ((char)str != 0) {
        result = function_2d53c((int32_t)&g306);
    }
    // 0x2d530
    return result;
}

// Address range: 0x2d53c - 0x2d578
int32_t function_2d53c(int32_t format) {
    // 0x2d53c
    int32_t str; // 0x2d53c
    snprintf((char *)str, 2048, (char *)format);
    int32_t result = function_1ccec(4, (int32_t *)str, 0); // 0x2d568
    if ((char)str != 0) {
        result = function_2d578((int32_t)&g306);
    }
    // 0x2d56c
    return result;
}

// Address range: 0x2d578 - 0x2d59c
int32_t function_2d578(int32_t format) {
    // 0x2d578
    int32_t str; // 0x2d578
    snprintf((char *)str, 2048, (char *)format);
    return function_1ccec(4, (int32_t *)str, 0);
}

// Address range: 0x2d59c - 0x2d5ac
int32_t function_2d59c(void) {
    // 0x2d59c
    int32_t result; // 0x2d59c
    return result;
}

// Address range: 0x2d5ac - 0x2d5cc
int32_t function_2d5ac(void) {
    // 0x2d5ac
    int32_t result; // 0x2d5ac
    int32_t v1; // 0x2d5ac
    if ((char)v1 != 0) {
        result = function_2d5cc();
    }
    // 0x2d5b8
    return result;
}

// Address range: 0x2d5cc - 0x2d60c
int32_t function_2d5cc(void) {
    char * v1 = (char *)0x6d6d7553; // bp+296, 0x2d5e0
    return function_1ccec(4, (int32_t *)&v1, 0);
}

// Address range: 0x2d60c - 0x2d6e4
int32_t function_2d60c(int32_t a1) {
    // 0x2d60c
    if (g228 < (char *)1) {
        // 0x2d6dc
        int32_t result; // 0x2d60c
        return result;
    }
    int32_t v1 = 0; // 0x2d66c
    int32_t * v2 = (int32_t *)(function_2c8f4(v1) + 4); // 0x2d664
    *(int32_t *)(*v2 + 20) = 0x26d30;
    *(int32_t *)(*v2 + 24) = 0x289d4;
    char v3 = *(char *)&g70; // 0x2d6a0
    int32_t str; // bp+296, 0x2d60c
    int32_t result2 = &str; // 0x2d69c
    int32_t v4; // 0x2d60c
    int32_t v5; // bp+40, 0x2d60c
    if ((v3 | *(char *)&v4) == 0 != g28 < (char *)4) {
        // 0x2d6bc
        snprintf((char *)&str, 2048, "%s", &v5);
        result2 = function_1ccec(4, &str, 0);
    }
    // 0x2d6d0
    v1++;
    while (v1 < (int32_t)g228) {
        // 0x2d650
        v2 = (int32_t *)(function_2c8f4(v1) + 4);
        *(int32_t *)(*v2 + 20) = 0x26d30;
        *(int32_t *)(*v2 + 24) = 0x289d4;
        v3 = *(char *)&g70;
        result2 = &str;
        if ((v3 | *(char *)&v4) == 0 != g28 < (char *)4) {
            // 0x2d6bc
            snprintf((char *)&str, 2048, "%s", &v5);
            result2 = function_1ccec(4, &str, 0);
        }
        // 0x2d6d0
        v1++;
    }
    // 0x2d6dc
    return result2;
}

// Address range: 0x2d6e6 - 0x2d6e8
int32_t function_2d6e6(int32_t a1) {
    // 0x2d6e6
    return function_2d766(a1);
}

// Address range: 0x2d6e8 - 0x2d74c
int32_t function_2d6e8(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t v1 = a1; // 0x2d6ec
    if (a2 == 0) {
        v1 = function_2d7d0(a1, 0, a3, a4, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306);
    }
    float64_t v2 = __asm_vldr((int32_t)(float32_t)g210); // 0x2d6fc
    int32_t str; // bp+296, 0x2d6e8
    if (a4 != 0) {
        // 0x2d718
        __asm_vstr(v2, a5);
        snprintf((char *)&str, 2048, "Mined %.0f accepted shares of %d requested\n", (float64_t)(int64_t)a4);
        return function_1ccec(4, &str, 0);
    }
    // 0x2d704
    if (*(char *)&g70 == 0) {
        function_2dbcc(v1, a2);
    }
    int32_t v3 = (int32_t)&g70;
    __asm_vstr(v2, a5);
    snprintf((char *)&str, 2048, "Mined %.0f accepted shares of %d requested\n", (float64_t)(int64_t)v3);
    return function_1ccec(4, &str, 0);
}

// Address range: 0x2d74c - 0x2d754
int32_t function_2d74c(int32_t a1) {
    // 0x2d74c
    int32_t v1; // 0x2d74c
    __asm_ldc_13(4, 1, *(int32_t *)(v1 + 480));
    return function_2d27c((int32_t)*(char *)(a1 + 12));
}

// Address range: 0x2d754 - 0x2d758
int32_t function_2d754(int32_t result) {
    // 0x2d754
    return result;
}

// Address range: 0x2d75a - 0x2d766
int32_t function_2d75a(void) {
    // 0x2d75a
    bool v1; // 0x2d75a
    if (v1) {
        // 0x2d75e
        function_ff9e8f7a();
        function_ff229246();
    }
    // 0x2d762
    return unknown_46923a();
}

// Address range: 0x2d766 - 0x2d770
int32_t function_2d766(int32_t result) {
    // 0x2d766
    __asm_mrc(0, 7, result, 1, 8, 0);
    return result;
}

// Address range: 0x2d770 - 0x2d7c8
int32_t function_2d770(int32_t a1, int32_t a2, int32_t a3) {
    // 0x2d770
    int32_t v1; // 0x2d770
    int32_t str; // bp+296, 0x2d770
    bool v2; // 0x2d770
    float64_t v3; // 0x2d770
    if (!v2) {
        // 0x2d7a0
        __asm_vstr(v3, a3);
        snprintf((char *)&str, 2048, "WARNING - Mined only %.0f shares of %d requested.", (float64_t)(int64_t)v1);
        return 4;
    }
    unsigned char v4 = *(char *)&g70; // 0x2d77c
    v1 = v4;
    if (v4 == 0) {
        // 0x2d788
        v1 = (int32_t)g28;
    }
    // 0x2d7a0
    __asm_vstr(v3, a3);
    snprintf((char *)&str, 2048, "WARNING - Mined only %.0f shares of %d requested.", (float64_t)(int64_t)v1);
    return 4;
}

// Address range: 0x2d7c8 - 0x2d7ca
int32_t function_2d7c8(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x2d7c8
    return result;
}

// Address range: 0x2d7ca - 0x2d7cb
int32_t function_2d7ca(void) {
    // 0x2d7ca
    int32_t result; // 0x2d7ca
    return result;
}

// Address range: 0x2d7cc - 0x2d7d0
int32_t function_2d7cc(int32_t result) {
    // 0x2d7cc
    return result;
}

// Address range: 0x2d7d0 - 0x2d838
int32_t function_2d7d0(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11, int32_t a12) {
    // 0x2d7d0
    if (a4 == 0 == *(char *)&g70 == 0) {
        function_2da04();
    }
    int32_t v1 = 32; // bp+296, 0x2d800
    function_1ccec(4, &v1, 0);
    fflush(g61);
    int32_t fflush_rc = fflush(g60); // 0x2d824
    float64_t v2; // 0x2d7d0
    __asm_vpop_12(v2, v2, v2);
    return fflush_rc;
}

// Address range: 0x2d838 - 0x2d83c
int32_t function_2d838(void) {
    // 0x2d838
    return function_2de48();
}

// Address range: 0x2d83c - 0x2d840
int32_t function_2d83c(void) {
    // 0x2d83c
    return function_2e546(6);
}

// Address range: 0x2d840 - 0x2d8e4
int32_t function_2d840(int32_t a1, int32_t a2, int32_t a3) {
    // 0x2d840
    if (a3 > 3) {
        function_2d284();
        function_2d2e4();
        function_2d328();
        function_2d36c();
        function_2d3b0();
    }
    // 0x2d88c
    int32_t v1; // 0x2d840
    uint64_t v2 = *(int64_t *)(v1 + 8); // 0x2d88c
    if ((int32_t)(v2 / 0x100000000 || v2) == 0) {
        function_2d3e8();
    }
    if (a3 > 3) {
        function_2d414();
        function_2d4b8();
        function_2d4fc();
        function_2d53c((int32_t)&g306);
        function_2d578((int32_t)&g306);
    }
    // 0x2d8e0
    return function_2d59c();
}

// Address range: 0x2d8e4 - 0x2d8f0
int32_t function_2d8e4(void) {
    // 0x2d8e4
    int32_t result; // 0x2d8e4
    return result;
}

// Address range: 0x2d8f0 - 0x2d8fc
int32_t function_2d8f0(void) {
    // 0x2d8f0
    int32_t result; // 0x2d8f0
    return result;
}

// Address range: 0x2d8fc - 0x2d908
int32_t function_2d8fc(void) {
    // 0x2d8fc
    int32_t result; // 0x2d8fc
    return result;
}

// Address range: 0x2d908 - 0x2d914
int32_t function_2d908(void) {
    // 0x2d908
    int32_t result; // 0x2d908
    return result;
}

// Address range: 0x2d914 - 0x2d920
int32_t function_2d914(void) {
    // 0x2d914
    int32_t result; // 0x2d914
    return result;
}

// Address range: 0x2d920 - 0x2d924
int32_t function_2d920(void) {
    // 0x2d920
    int32_t v1; // 0x2d920
    return function_2df30(v1, v1);
}

// Address range: 0x2d924 - 0x2d928
int32_t function_2d924(void) {
    // 0x2d924
    return 6;
}

// Address range: 0x2d928 - 0x2d929
int32_t function_2d928(void) {
    // 0x2d928
    int32_t result; // 0x2d928
    return result;
}

// Address range: 0x2d92c - 0x2d938
int32_t function_2d92c(void) {
    // 0x2d92c
    int32_t result; // 0x2d92c
    return result;
}

// Address range: 0x2d938 - 0x2d944
int32_t function_2d938(void) {
    // 0x2d938
    int32_t result; // 0x2d938
    return result;
}

// Address range: 0x2d944 - 0x2d95c
int32_t function_2d944(void) {
    // 0x2d944
    return function_2d414();
}

// Address range: 0x2d95c - 0x2d974
int32_t function_2d95c(void) {
    // 0x2d95c
    int32_t v1; // 0x2d95c
    uint32_t v2 = v1;
    int32_t result; // 0x2d95c
    if ((char)v2 != 0) {
        result = function_2d22c(v1, v1, v2 % 256, v1);
    }
    // 0x2d968
    return result;
}

// Address range: 0x2d974 - 0x2d998
int32_t function_2d974(void) {
    // 0x2d974
    int32_t result; // 0x2d974
    return result;
}

// Address range: 0x2d998 - 0x2d9b0
int32_t function_2d998(void) {
    // 0x2d998
    int32_t result; // 0x2d998
    return result;
}

// Address range: 0x2d9b0 - 0x2d9d4
int32_t function_2d9b0(void) {
    // 0x2d9b0
    int32_t result; // 0x2d9b0
    __asm_vldr(result);
    __asm_vldr((int32_t)(float32_t)g177);
    return result;
}

// Address range: 0x2d9d8 - 0x2d9ec
int32_t function_2d9d8(int32_t a1, int32_t a2, int32_t * a3) {
    int32_t result = a1; // 0x2d9e0
    if (a3 < (int32_t *)4) {
        result = function_2dcdc(a1, a2, (int32_t)a3);
    }
    // 0x2d9e4
    return result;
}

// Address range: 0x2d9ec - 0x2d9f0
int32_t function_2d9ec(void) {
    // 0x2d9ec
    return function_2dffc();
}

// Address range: 0x2d9f0 - 0x2d9f4
int32_t function_2d9f0(void) {
    // 0x2d9f0
    return function_2e416(6);
}

// Address range: 0x2d9f4 - 0x2da04
int32_t function_2d9f4(int32_t a1, int32_t a2, int32_t a3) {
    if (a3 > 3) {
        function_2d5cc();
    }
    // 0x2da00
    return function_2d60c((int32_t)&g306);
}

// Address range: 0x2da04 - 0x2da1c
int32_t function_2da04(void) {
    // 0x2da04
    int32_t result; // 0x2da04
    return result;
}

// Address range: 0x2da1c - 0x2dab0
int32_t function_2da1c(void) {
    // 0x2da1c
    int32_t v1; // 0x2da1c
    if (g28 > (char *)3) {
        v1 = function_2d0a8();
    }
    int32_t v2 = v1; // 0x2da9c
    if (g28 > (char *)3) {
        v2 = function_2d0f8();
    }
    int32_t v3 = v2; // 0x2daa8
    int32_t v4; // 0x2da1c
    if (v4 > 1) {
        v3 = function_2d134();
    }
    // 0x2daac
    return function_2d9f4(v3, v4, (int32_t)&g28);
}

// Address range: 0x2dab0 - 0x2db24
int32_t function_2dab0(void) {
    int32_t v1 = *(int32_t *)(*(int32_t *)g202 + 164); // 0x2db08
    int32_t str; // bp+296, 0x2dab0
    snprintf((char *)&str, 2048, "Pool: %s", (char *)v1);
    return function_1ccec(4, &str, 0);
}

// Address range: 0x2db24 - 0x2db98
int32_t function_2db24(void) {
    // 0x2db24
    int32_t v1; // 0x2db24
    if (g28 > (char *)3) {
        v1 = function_2cdd0();
    }
    // 0x2db7c
    int32_t v2; // 0x2db24
    uint64_t v3 = *(int64_t *)&v2; // 0x2db7c
    int32_t result = v1; // 0x2db84
    if ((int32_t)(v3 / 0x100000000 || v3) == 0) {
        result = function_2d1bc();
    }
    // 0x2db88
    return result;
}

// Address range: 0x2db98 - 0x2dbb4
int32_t function_2db98(void) {
    // 0x2db98
    return function_2d998();
}

// Address range: 0x2dbb4 - 0x2dbc0
int32_t function_2dbb4(void) {
    // 0x2dbb4
    int32_t v1; // 0x2dbb4
    return function_2d9d8(v1, v1, (int32_t *)&g28);
}

// Address range: 0x2dbc0 - 0x2dbcc
int32_t function_2dbc0(void) {
    // 0x2dbc0
    int32_t result; // 0x2dbc0
    return result;
}

// Address range: 0x2dbcc - 0x2dbe4
int32_t function_2dbcc(int32_t a1, int32_t a2) {
    // 0x2dbcc
    __asm_vmov(a2);
    return (int32_t)g28;
}

// Address range: 0x2dbe6 - 0x2dbf2
int32_t function_2dbe6(void) {
    // 0x2dbe6
    bool v1; // 0x2dbe6
    if (v1) {
        function_ff2296ce();
    }
    int32_t result = unknown_4696c2(); // 0x2dbea
    __asm_mcr2(14, 7, 0x2dbea, 1, 1, 7);
    return result;
}

// Address range: 0x2dbf4 - 0x2dbf8
int32_t function_2dbf4(void) {
    // 0x2dbf4
    int32_t result; // 0x2dbf4
    return result;
}

// Address range: 0x2dbf8 - 0x2dc04
int32_t function_2dbf8(void) {
    // 0x2dbf8
    int32_t result; // 0x2dbf8
    return result;
}

// Address range: 0x2dc04 - 0x2dc20
int32_t function_2dc04(void) {
    // 0x2dc04
    int32_t result; // 0x2dc04
    if (g28 > (char *)3) {
        result = function_2d0f8();
    }
    // 0x2dc1c
    return result;
}

// Address range: 0x2dc20 - 0x2dc3c
int32_t function_2dc20(void) {
    // 0x2dc20
    int32_t result; // 0x2dc20
    return result;
}

// Address range: 0x2dc3c - 0x2dc58
int32_t function_2dc3c(void) {
    // 0x2dc3c
    int32_t result; // 0x2dc3c
    return result;
}

// Address range: 0x2dc58 - 0x2dc74
int32_t function_2dc58(void) {
    // 0x2dc58
    int32_t result; // 0x2dc58
    return result;
}

// Address range: 0x2dc74 - 0x2dc90
int32_t function_2dc74(void) {
    // 0x2dc74
    int32_t result; // 0x2dc74
    if (g28 > (char *)3) {
        result = function_2d0a8();
    }
    // 0x2dc8c
    return result;
}

// Address range: 0x2dc90 - 0x2dcac
int32_t function_2dc90(void) {
    // 0x2dc90
    int32_t result; // 0x2dc90
    return result;
}

// Address range: 0x2dcac - 0x2dcc8
int32_t function_2dcac(void) {
    // 0x2dcac
    int32_t result; // 0x2dcac
    return result;
}

// Address range: 0x2dcc8 - 0x2dcd4
int32_t function_2dcc8(void) {
    // 0x2dcc8
    int32_t result; // 0x2dcc8
    return result;
}

// Address range: 0x2dcd4 - 0x2dcdc
int32_t function_2dcd4(void) {
    // 0x2dcd4
    int32_t result; // 0x2dcd4
    return result;
}

// Address range: 0x2dcdc - 0x2dd00
int32_t function_2dcdc(int32_t result, int32_t a2, int32_t a3) {
    // 0x2dcdc
    return result;
}

// Address range: 0x2dcec - 0x2dced
int32_t function_2dcec(void) {
    // 0x2dcec
    int32_t result; // 0x2dcec
    return result;
}

// Address range: 0x2dd00 - 0x2dd0c
int32_t function_2dd00(void) {
    // 0x2dd00
    return function_2dcec();
}

// Address range: 0x2dd0c - 0x2dd18
int32_t function_2dd0c(void) {
    // 0x2dd0c
    int32_t result; // 0x2dd0c
    return result;
}

// Address range: 0x2dd18 - 0x2dd24
int32_t function_2dd18(void) {
    // 0x2dd18
    int32_t result; // 0x2dd18
    return result;
}

// Address range: 0x2dd24 - 0x2de48
int32_t function_2dd24(int32_t a1) {
    // 0x2dd24
    int32_t result3; // 0x2dd24
    int32_t v1; // bp-2128, 0x2dd24
    if (sysinfo((struct sysinfo *)&v1) == 0) {
        // 0x2ddd8
        g256 = v1;
        int32_t result = function_1f5c4(&g102); // 0x2ddec
        result3 = result;
        if (a1 != 0) {
            // 0x2ddcc
            return result;
        }
    } else {
        char v2 = *(char *)&g70; // 0x2dd60
        if ((v2 | *(char *)&g179) == 0 != g28 < (char *)6) {
            int32_t err_num = *__errno_location(); // 0x2dd70
            char * err_str = strerror(err_num); // 0x2dd78
            int32_t str; // bp-2064, 0x2dd24
            snprintf((char *)&str, 2048, "Failed to get sysinfo, errno:%u, reason:%s\n", err_num, err_str);
            function_1ccec(6, &str, 0);
        }
        // 0x2dda8
        g256 = time(NULL);
        int32_t result2 = function_1f5c4(&g102); // 0x2ddc0
        result3 = result2;
        if (a1 != 0) {
            // 0x2ddcc
            return result2;
        }
    }
    // 0x2ddf8
    if (!((g255 != 0 | *(char *)&g72 == 0))) {
        // 0x2de20
        return function_2c968();
    }
    // 0x2ddcc
    return result3;
}

// Address range: 0x2de48 - 0x2de49
int32_t function_2de48(void) {
    // 0x2de48
    int32_t result; // 0x2de48
    return result;
}

// Address range: 0x2de4c - 0x2dec0
int32_t function_2de4c(void) {
    // 0x2de4c
    if ((*(char *)&g70 | *(char *)&g179) == 0) {
        function_2df70();
    }
    // 0x2de80
    int32_t str; // bp-2064, 0x2de4c
    snprintf((char *)&str, 2048, "Attempting to restart %s", (char *)&g81);
    function_1ccec(4, &str, 0);
    return function_22140(0x2e354, 0, 0x1388);
}

// Address range: 0x2dec2 - 0x2dec4
int32_t function_2dec2(int32_t a1) {
    // 0x2dec2
    return function_2e546(a1);
}

// Address range: 0x2dec4 - 0x2df30
int32_t function_2dec4(void) {
    char * exec_argv[1]; // 0x2def0
    // 0x2dec4
    function_2dd24(1);
    int32_t v1; // 0x2dec4
    int32_t * v2 = (int32_t *)(v1 + 1060); // 0x2decc
    int32_t pid = *v2; // 0x2decc
    char v3; // 0x2dec4
    if (pid < 1) {
        // 0x2dec4
        v3 = v1;
    } else {
        // 0x2ded8
        kill(pid, SIGTERM);
        *v2 = 0;
        int32_t v4; // 0x2dec4
        v3 = *(char *)&v4;
    }
    int32_t path = *(int32_t *)(v1 + 1148); // 0x2dee8
    exec_argv[0] = (char *)path;
    execv((char *)*(int32_t *)path, exec_argv);
    if ((*(char *)&g70 || v3) == 0) {
        function_2df50((int32_t)&g306, (int32_t)&g306);
    }
    // 0x2df14
    return 0x70612074;
}

// Address range: 0x2df30 - 0x2df34
int32_t function_2df30(int32_t a1, int32_t a2) {
    // 0x2df30
    return function_2e276();
}

// Address range: 0x2df34 - 0x2df50
int32_t function_2df34(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x2df34
    int32_t v1; // 0x2df34
    *(int16_t *)v1 = (int16_t)a4;
    return function_1ccec(4, (int32_t *)a2, 0);
}

// Address range: 0x2df50 - 0x2df70
int32_t function_2df50(int32_t a1, int32_t a2) {
    // 0x2df50
    int32_t result; // 0x2df50
    return result;
}

// Address range: 0x2df70 - 0x2df88
int32_t function_2df70(void) {
    // 0x2df70
    int32_t result; // 0x2df70
    return result;
}

// Address range: 0x2df8c - 0x2dffc
int32_t function_2df8c(int32_t a1) {
    // 0x2df8c
    if (pthread_rwlock_rdlock(&g222) != 0) {
        // 0x2dfe4
        function_2c5c0("get_thread", 614);
        // UNREACHABLE
    }
    // 0x2dfa8
    if (pthread_rwlock_unlock(&g222) != 0) {
        // 0x2dff0
        return function_2bfac((int32_t)"get_thread", 616);
    }
    // 0x2dfcc
    function_1da28();
    return *(int32_t *)(g208 + 4 * a1);
}

// Address range: 0x2dffc - 0x2dffd
int32_t function_2dffc(void) {
    // 0x2dffc
    int32_t result; // 0x2dffc
    return result;
}

// Address range: 0x2e000 - 0x2e014
int32_t function_2e000(void) {
    // 0x2e000
    int32_t v1; // 0x2e000
    return *(int32_t *)(*(int32_t *)(function_2df8c(v1) + 36) + 8);
}

// Address range: 0x2e014 - 0x2e074
int32_t function_2e014(void) {
    // 0x2e014
    if ((*(char *)&g70 | *(char *)&g179) == 0) {
        function_2e2c4();
    }
    // 0x2e044
    return 6;
}

// Address range: 0x2e076 - 0x2e078
int32_t function_2e076(int32_t a1) {
    // 0x2e076
    return function_2e416(a1);
}

// Address range: 0x2e078 - 0x2e07c
int32_t function_2e078(int32_t a1) {
    // 0x2e078
    return function_2e3be();
}

// Address range: 0x2e07c - 0x2e0cc
int32_t function_2e07c(int32_t result, int32_t a2, int32_t a3) {
    // 0x2e07c
    if (a3 == 0) {
        // 0x2e07e
        return result;
    }
    // 0x2e0c6
    int32_t v1; // 0x2e07c
    *(int32_t *)v1 = a3;
    return function_2e91a();
}

// Address range: 0x2e0cc - 0x2e0dc
int32_t function_2e0cc(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x2e0cc
    int32_t v1; // 0x2e0cc
    *(char *)v1 = (char)a4;
    return function_1ccec(7, (int32_t *)a2, 1);
}

// Address range: 0x2e0dc - 0x2e274
int32_t function_2e0dc(void) {
    // 0x2e0dc
    function_22140((int32_t)&g3, 64 * g106 + g184, 1000);
    int32_t v1; // 0x2e0dc
    char v2 = v1;
    if (v2 == 0) {
        // 0x2e1d8
        function_22140((int32_t)&g3, 64 * g107 + g184, 1000);
    } else {
        char v3 = v1;
        if ((*(char *)&g70 || v3) == 0) {
            function_2e300();
        }
        char * v4 = (char *)0x6c6c694b; // 0x2e144
        function_1ccec(7, (int32_t *)&v4, 1);
        function_22140((int32_t)&g3, 64 * g107 + g184, 1000);
        if ((*(char *)&g70 || v3) == 0) {
            function_2e318();
        }
        // 0x2e1a8
        v4 = (char *)0x74756853;
        function_1ccec(7, (int32_t *)&v4, 1);
    }
    int32_t v5 = 0; // 0x2e1e8
    char v6 = v2; // 0x2e1e8
    if (g261 >= 1) {
        int32_t v7 = function_2df8c(v5); // 0x2e1fc
        int32_t v8; // 0x2e208
        if (v7 != 0) {
            // 0x2e208
            v8 = *(int32_t *)(v7 + 36);
            if (v8 != 0) {
                *(char *)(v8 + 364) = 1;
            }
        }
        // 0x2e214
        v5++;
        while (v5 < g261) {
            // 0x2e1f4
            v7 = function_2df8c(v5);
            if (v7 != 0) {
                // 0x2e208
                v8 = *(int32_t *)(v7 + 36);
                if (v8 != 0) {
                    *(char *)(v8 + 364) = 1;
                }
            }
            // 0x2e214
            v5++;
        }
        // 0x2e220
        int32_t v9; // 0x2e0dc
        v6 = *(char *)&v9;
    }
    // 0x2e220
    sleep(1);
    int32_t result = function_22140(0x2e36c, 0, 3000); // 0x2e244
    if (v6 == 0) {
        result = function_2e2a0((int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306);
    }
    // 0x2e248
    int32_t v10; // 0x2e0dc
    if ((*(char *)&g70 | *(char *)&v10) == 0) {
        // 0x2e268
        return function_2e330();
    }
    // 0x2e268
    return result;
}

// Address range: 0x2e276 - 0x2e27a
int32_t function_2e276(void) {
    // 0x2e276
    int32_t result; // 0x2e276
    return result;
}

// Address range: 0x2e27a - 0x2e29e
int32_t function_2e27a(uint32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    bool v1 = false; // 0x2e27a
    int32_t v2; // 0x2e27a
    bool v3; // 0x2e27a
    int32_t v4; // 0x2e27a
    if (v3) {
        v2 = v4 / 0x20000 & a2;
        v1 = (v4 & 0x10000) != 0;
    }
    int32_t v5; // 0x2e27a
    if (v3) {
        v5 = v4 & 512 * v4;
        if ((v4 & 0x800000) == 0) {
            goto lab_dec_label_pc_unknown_14;
        } else {
            goto lab__thread2;
        }
    } else {
        v5 = v2;
        if (v1) {
            goto lab__thread3;
        } else {
            goto lab_dec_label_pc_unknown_14;
        }
    }
  lab_dec_label_pc_unknown_14:;
    int32_t v6; // 0x2e27a
    *(int32_t *)(a2 - 16) = (int32_t)&v6;
    *(int32_t *)(a2 - 20) = v5;
    *(int32_t *)(a2 - 24) = 0x2e290;
    if (v3) {
        goto lab__thread2;
    } else {
        goto lab__thread3;
    }
  lab__thread2:;
    int32_t result = a1; // 0x2e29a
    bool v7; // 0x2e27a
    bool v8; // 0x2e27a
    if (v7 != v8) {
        result = function_fe4e79d2();
    }
    // 0x2e29e
    return result;
  lab__thread3:;
    int32_t v9 = (a1 & 4) != 0; // 0x2e28e
    int32_t v10 = a1 / 8 + a3 + v9; // 0x2e28e
    v7 = v10 < 0;
    v8 = (v10 + v9 & -a3) < 0;
    goto lab__thread2;
}

// Address range: 0x2e2a0 - 0x2e2c4
int32_t function_2e2a0(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    // 0x2e2a0
    int32_t v1; // 0x2e2a0
    int32_t v2 = *(int32_t *)(v1 + 1160); // 0x2e2a0
    return function_22140((int32_t)&g3, 64 * v2 + v1, 1000);
}

// Address range: 0x2e2c4 - 0x2e300
int32_t function_2e2c4(void) {
    // 0x2e2c4
    if (*(char *)&g71 == 0) {
        function_2e0dc();
    }
    // 0x2e2ec
    return function_2e0dc();
}

// Address range: 0x2e300 - 0x2e318
int32_t function_2e300(void) {
    // 0x2e300
    int32_t result; // 0x2e300
    return result;
}

// Address range: 0x2e318 - 0x2e330
int32_t function_2e318(void) {
    // 0x2e318
    int32_t result; // 0x2e318
    return result;
}

// Address range: 0x2e330 - 0x2e348
int32_t function_2e330(void) {
    // 0x2e330
    int32_t result; // 0x2e330
    if (g28 < (char *)7) {
        int32_t v1 = function_2e2a0((int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306); // 0x2e340
        result = v1;
    }
    // 0x2e344
    return result;
}

// Address range: 0x2e348 - 0x2e354
int32_t function_2e348(void) {
    // 0x2e348
    int32_t result; // 0x2e348
    return result;
}

// Address range: 0x2e354 - 0x2e36c
int32_t function_2e354(void) {
    // 0x2e354
    if (*(char *)&g72 == 0) {
        int32_t result; // 0x2e354
        return result;
    }
    // 0x2e368
    return function_2e014();
}

// Address range: 0x2e36c - 0x2e3bc
int32_t function_2e36c(void) {
    // 0x2e36c
    int32_t v1; // 0x2e36c
    if (*(char *)&g71 == 0) {
        v1 = function_2e3e8();
    }
    int32_t result = v1; // 0x2e398
    if ((*(char *)&g70 | *(char *)&g179) == 0) {
        result = function_2e464();
    }
    // 0x2e3b0
    return result;
}

// Address range: 0x2e3be - 0x2e3d0
int32_t function_2e3be(void) {
    // 0x2e3be
    int32_t v1; // 0x2e3be
    int32_t v2 = *(int32_t *)(v1 + 8); // 0x2e3be
    *(int32_t *)(v1 + 8) = v2;
    int32_t v3 = v1 + 12; // 0x2e3c2
    int32_t result = *(int32_t *)(v1 + 16); // 0x2e3c6
    *(int32_t *)v3 = result;
    *(int32_t *)(v1 + 16) = v2;
    *(int32_t *)(v1 + 20) = *(int32_t *)(v1 + 12);
    *(int32_t *)(v1 + 24) = v3;
    return result;
}

// Address range: 0x2e3d0 - 0x2e3e8
int32_t function_2e3d0(int32_t a1, int32_t a2, uint32_t a3) {
    // 0x2e3d0
    int32_t v1; // 0x2e3d0
    *(int16_t *)v1 = (int16_t)a3;
    *(char *)(v1 + 2) = (char)(a3 / 0x10000);
    return function_1ccec(7, (int32_t *)a2, 1);
}

// Address range: 0x2e3e8 - 0x2e404
int32_t function_2e3e8(void) {
    // 0x2e3e8
    int32_t result; // 0x2e3e8
    if (g261 < 1) {
        int32_t v1 = function_2e45c((int32_t)&g306, (int32_t)&g306, (int32_t)&g306); // 0x2e3f8
        result = v1;
    }
    // 0x2e3fc
    return result;
}

// Address range: 0x2e404 - 0x2e40c
int32_t function_2e404(void) {
    // 0x2e404
    int32_t v1; // 0x2e404
    return function_1f1a8(v1);
}

// Address range: 0x2e40e - 0x2e410
int32_t function_2e40e(void) {
    // 0x2e40e
    return function_2e91a();
}

// Address range: 0x2e410 - 0x2e414
int32_t function_2e410(int32_t a1) {
    // 0x2e410
    return function_2e6bc();
}

// Address range: 0x2e416 - 0x2e41c
int32_t function_2e416(int32_t result) {
    // 0x2e416
    return result;
}

// Address range: 0x2e41c - 0x2e448
int32_t function_2e41c(void) {
    // 0x2e41c
    int32_t v1; // 0x2e41c
    int32_t v2 = function_2df8c(v1); // 0x2e41c
    int32_t v3 = v2; // 0x2e424
    if (v2 == 0) {
        v3 = function_2e404();
    }
    int32_t * v4 = (int32_t *)(v2 + 12); // 0x2e428
    int32_t v5 = v3; // 0x2e430
    if (*v4 == 0) {
        v5 = function_2e404();
    }
    // 0x2e434
    function_1f1a8(v5);
    return *v4;
}

// Address range: 0x2e448 - 0x2e44c
int32_t function_2e448(int32_t result, int32_t a2) {
    // 0x2e448
    return result;
}

// Address range: 0x2e44c - 0x2e45c
int32_t function_2e44c(void) {
    // 0x2e44c
    int32_t thread; // 0x2e44c
    return pthread_join(thread, (int32_t **)thread);
}

// Address range: 0x2e45c - 0x2e464
int32_t function_2e45c(int32_t a1, int32_t a2, int32_t a3) {
    // 0x2e45c
    int32_t result; // 0x2e45c
    return result;
}

// Address range: 0x2e464 - 0x2e47c
int32_t function_2e464(void) {
    // 0x2e464
    int32_t result; // 0x2e464
    if (g28 < (char *)7) {
        result = function_2e3e8();
    }
    // 0x2e478
    return result;
}

// Address range: 0x2e47c - 0x2e51c
int32_t function_2e47c(void) {
    // 0x2e47c
    if (pthread_mutex_lock(&g250) != 0 || pthread_rwlock_rdlock((int32_t *)0x740b8) != 0) {
        // 0x2e4f8
        function_2c5c0("current_pool", 843);
        // UNREACHABLE
    }
    // 0x2e4a4
    if (pthread_mutex_unlock(&g250) != 0 || pthread_rwlock_unlock((int32_t *)0x740b8) != 0) {
        // 0x2e510
        return function_2bfac((int32_t)"current_pool", 847);
    }
    // 0x2e4d4
    function_1da28();
    return g109;
}

// Address range: 0x2e528 - 0x2e52c
int32_t function_2e528(int32_t result) {
    // 0x2e528
    *(char *)result = (char)result;
    return result;
}

// Address range: 0x2e52c - 0x2e530
int32_t function_2e52c(void) {
    // 0x2e52c
    int32_t result; // 0x2e52c
    return result;
}

// Address range: 0x2e530 - 0x2e534
int32_t function_2e530(int32_t result, int32_t a2) {
    // 0x2e530
    *(int32_t *)result = a2;
    return result;
}

// Address range: 0x2e534 - 0x2e538
int32_t function_2e534(int32_t a1) {
    // 0x2e534
    return function_2ebba();
}

// Address range: 0x2e53a - 0x2e53c
int32_t function_2e53a(void) {
    // 0x2e53a
    int32_t result; // 0x2e53a
    return result;
}

// Address range: 0x2e53c - 0x2e544
int32_t function_2e53c(void) {
    // 0x2e53c
    int32_t mutex; // 0x2e53c
    return pthread_mutex_lock((int32_t *)mutex);
}

// Address range: 0x2e546 - 0x2e54c
int32_t function_2e546(int32_t a1) {
    // 0x2e546
    int32_t v1; // 0x2e546
    return function_2e07c(0, v1, v1);
}

// Address range: 0x2e54c - 0x2e610
int32_t function_2e54c(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    // 0x2e54c
    int32_t v1; // 0x2e54c
    int32_t v2 = v1 >> 31; // 0x2e554
    uint32_t v3 = g185; // 0x2e558
    int32_t * v4 = (int32_t *)(a2 + 192); // 0x2e55c
    uint32_t v5 = *v4; // 0x2e55c
    int32_t * v6 = (int32_t *)(a2 + 196); // 0x2e560
    int32_t v7 = v3 + v1; // 0x2e564
    uint32_t v8 = v5 + v1; // 0x2e56c
    g185 = v7;
    g186 = g186 + v2 + (int32_t)(v7 < v3);
    *v4 = v8;
    *v6 = *v6 + v2 + (int32_t)(v8 < v5);
    if (v1 == 0) {
        int32_t v9 = function_2e47c(); // 0x2e5d8
        int32_t * v10 = (int32_t *)(v9 + 40); // 0x2e5dc
        uint32_t v11 = *v10; // 0x2e5dc
        int32_t * v12 = (int32_t *)(v9 + 44); // 0x2e5e0
        uint32_t v13 = v11 + v1; // 0x2e5e4
        *v10 = v13;
        *v12 = *v12 + v2 + (int32_t)(v13 < v11);
    } else {
        int32_t * v14 = (int32_t *)(v1 + 40); // 0x2e588
        uint32_t v15 = *v14; // 0x2e588
        int32_t * v16 = (int32_t *)(v1 + 44); // 0x2e58c
        uint32_t v17 = v15 + v1; // 0x2e590
        *v14 = v17;
        *v16 = *v16 + v2 + (int32_t)(v17 < v15);
    }
    // 0x2e5a0
    *(int32_t *)(*(int32_t *)(v1 + 36) + 232) = time(NULL);
    if (pthread_mutex_unlock(&g180) == 0) {
        // 0x2e5c4
        return function_1da28();
    }
    // 0x2e604
    return (int32_t)"inc_work_stats";
}

// Address range: 0x2e614 - 0x2e6b8
int32_t function_2e614(void) {
    // 0x2e614
    if (pthread_mutex_lock(&g250) != 0 || pthread_rwlock_rdlock((int32_t *)0x740b8) != 0) {
        // 0x2e694
        function_2c5c0("cp_prio", 0x1d21);
        // UNREACHABLE
    }
    // 0x2e63c
    if (pthread_mutex_unlock(&g250) != 0 || pthread_rwlock_unlock((int32_t *)0x740b8) != 0) {
        // 0x2e6ac
        return function_2bfac((int32_t)"cp_prio", 0x1d23);
    }
    // 0x2e670
    function_1da28();
    return *(int32_t *)(g109 + 4);
}

// Address range: 0x2e6bc - 0x2e6bd
int32_t function_2e6bc(void) {
    // 0x2e6bc
    int32_t result; // 0x2e6bc
    return result;
}

// Address range: 0x2e6c0 - 0x2e7f8
int32_t function_2e6c0(int32_t a1) {
    // 0x2e6c0
    *(int32_t *)(a1 + 28) = 0;
    int32_t result = a1; // 0x2e6e8
    int32_t str; // bp-2064, 0x2e6c0
    if (g89 == 0) {
        // 0x2e770
        result = function_2e614();
        if (*(int32_t *)(a1 + 4) < result) {
            char v1 = *(char *)&g70; // 0x2e79c
            if ((v1 | *(char *)&g179) == 0 == g28 < (char *)4) {
                // 0x2e744
                return result;
            }
            int32_t v2 = *(int32_t *)(a1 + 164); // 0x2e7bc
            snprintf((char *)&str, 2048, "Pool %d %s alive, testing stability", result, (char *)v2);
            return function_1ccec(4, &str, 0);
        }
    }
    char v3 = *(char *)&g70; // 0x2e708
    int32_t result2 = result; // 0x2e6fc
    if ((v3 | *(char *)&g179) != 0 || g28 > (char *)5) {
        int32_t v4 = *(int32_t *)(a1 + 164); // 0x2e714
        snprintf((char *)&str, 2048, "Pool %d %s alive", result, (char *)v4);
        result2 = function_1ccec(6, &str, 0);
    }
    // 0x2e744
    return result2;
}

// Address range: 0x2e7f8 - 0x2e888
int32_t function_2e7f8(int32_t a1) {
    char v1 = *(char *)&g70; // 0x2e820
    if ((v1 | *(char *)&g179) != 0 || g28 > (char *)5) {
        // 0x2e82c
        int32_t str; // bp-2056, 0x2e7f8
        snprintf((char *)&str, 2048, "Stratum connection to pool %d resumed", a1);
        function_1ccec(6, &str, 0);
        return function_2e6c0(a1);
    }
    // 0x2e878
    return function_2e6c0(a1);
}

// Address range: 0x2e888 - 0x2e8ac
int32_t function_2e888(int32_t a1) {
    if (a1 == 0) {
        return 0;
    }
    // 0x2e8a0
    return function_2e7f8(a1);
}

// Address range: 0x2e8ac - 0x2e918
int32_t function_2e8ac(int32_t a1) {
    // 0x2e8ac
    if (*(int32_t *)(a1 + 100) != 1) {
        // 0x2e8b8
        return 0;
    }
    int32_t v1 = g89 - 3; // 0x2e8d0
    if (v1 != 0 != v1 != 1) {
        // 0x2e8b8
        return 1;
    }
    // 0x2e8e4
    if (*(char *)(a1 + 640) != 0) {
        // 0x2e8f0
        if (*(char *)(a1 + 97) != 0) {
            // 0x2e8b8
            return 1;
        }
    }
    int32_t v2 = function_2e47c(); // 0x2e900
    if (v2 != a1) {
        // 0x2e90c
        return *(int32_t *)(a1 + 732) == 0 ? v2 : 1;
    }
    // 0x2e8b8
    return 1;
}

// Address range: 0x2e91a - 0x2e91c
int32_t function_2e91a(void) {
    // 0x2e91a
    int32_t v1; // 0x2e91a
    return function_2e448(v1, v1);
}

// Address range: 0x2e91c - 0x2e940
int32_t function_2e91c(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    // 0x2e91c
    int32_t v1; // 0x2e91c
    if (a4 != 0) {
        // 0x2e924
        return (int32_t)*(char *)(v1 + 1168);
    }
    int32_t result = function_2e614(); // 0x2e930
    if (*(int32_t *)(v1 + 4) < result) {
        // 0x2e93c
        return result;
    }
    // 0x2e924
    return (int32_t)*(char *)(v1 + 1168);
}

// Address range: 0x2e940 - 0x2eb88
int32_t function_2e940(void) {
    int32_t result = function_1e7d4(1848, 1, "cgminer.c", "add_pool", 767); // 0x2e978
    int32_t v1 = (int32_t)g188; // 0x2e97c
    *(int32_t *)result = v1;
    *(char *)(result + 644) = 0;
    *(int32_t *)(result + 4) = v1;
    int32_t v2 = function_1e864(g202, 4 * (int32_t)g188 + 8, (int32_t)"cgminer.c", (int32_t)"add_pool", 779); // 0x2e9bc
    int32_t v3 = (int32_t)g188; // 0x2e9c0
    g202 = v2;
    *(int32_t *)&g188 = v3 + 1;
    *(int32_t *)(4 * v3 + v2) = result;
    int32_t v4; // 0x2e940
    int32_t format; // 0x2e940
    int32_t * v5; // 0x2e940
    char * str; // bp-2080, 0x2e940
    if (pthread_mutex_init((int32_t *)(result + 188), NULL) == 0) {
        // 0x2e9ec
        if (pthread_cond_init((int32_t *)(result + 296), NULL) != 0) {
            // 0x2eaf4
            str = (char *)0x6c696146;
            // 0x2eac4
            function_1ccec(3, (int32_t *)&str, 1);
            function_2ab30(1, 1);
            // UNREACHABLE
        }
        // 0x2e9fc
        if (pthread_mutex_init((int32_t *)(result + 212), NULL) == 0) {
            // 0x2ea0c
            if (pthread_rwlock_init((int32_t *)(result + 236), NULL) == 0) {
                // 0x2ea1c
                if (pthread_mutex_init((int32_t *)(result + 704), NULL) == 0) {
                    // 0x2ea2c
                    if (pthread_mutex_init((int32_t *)(result + 740), NULL) == 0) {
                        // 0x2ea3c
                        if (pthread_rwlock_init((int32_t *)(result + 764), NULL) == 0) {
                            int32_t v6 = result + 344; // 0x2ea50
                            *(int32_t *)(result + 136) = -1;
                            *(int32_t *)(result + 184) = 0;
                            *(int32_t *)(result + 160) = (int32_t)"{\"method\": \"getwork\", \"params\": [], \"id\":0}\n";
                            *(int32_t *)v6 = v6;
                            *(int32_t *)(result + 348) = v6;
                            *(int32_t *)(result + 56) = 1;
                            function_28afc();
                            *(char *)(result + 580) = 0;
                            return result;
                        }
                        // 0x2ea90
                        v4 = 791;
                        format = (int32_t)"Failed to pthread_rwlock_init errno=%d in %s %s():%d";
                        v5 = __errno_location();
                    } else {
                        // 0x2eb6c
                        v4 = 791;
                        format = (int32_t)"Failed to pthread_mutex_init errno=%d in %s %s():%d";
                        v5 = __errno_location();
                    }
                } else {
                    // 0x2eb50
                    v4 = 790;
                    format = (int32_t)"Failed to pthread_mutex_init errno=%d in %s %s():%d";
                    v5 = __errno_location();
                }
            } else {
                // 0x2eb40
                v4 = 789;
                format = (int32_t)"Failed to pthread_rwlock_init errno=%d in %s %s():%d";
                v5 = __errno_location();
            }
        } else {
            // 0x2eb24
            v4 = 789;
            format = (int32_t)"Failed to pthread_mutex_init errno=%d in %s %s():%d";
            v5 = __errno_location();
        }
    } else {
        // 0x2ead8
        v4 = 782;
        format = (int32_t)"Failed to pthread_mutex_init errno=%d in %s %s():%d";
        v5 = __errno_location();
    }
    int32_t v7 = *v5;
    snprintf((char *)&str, 2048, (char *)format, v7, "cgminer.c", "add_pool", v4);
    // 0x2eac4
    function_1ccec(3, (int32_t *)&str, 1);
    function_2ab30(1, 1);
    // UNREACHABLE
}

// Address range: 0x2eb8c - 0x2ebb8
int32_t function_2eb8c(void) {
    // 0x2eb8c
    int32_t v1; // 0x2eb8c
    if (g111 != 0) {
        int32_t v2 = function_2ec5c((int32_t)&g306, (int32_t)&g306, (int32_t)&g306); // 0x2eba0
        v1 = v2;
    }
    int32_t result = v1; // 0x2ebac
    if (g112 != 0) {
        result = function_2ec5c((int32_t)&g306, (int32_t)&g306, (int32_t)&g306);
    }
    // 0x2ebb0
    return result;
}

// Address range: 0x2ebba - 0x2ebbc
int32_t function_2ebba(void) {
    // 0x2ebba
    int32_t v1; // 0x2ebba
    return function_2f23e(v1);
}

// Address range: 0x2ebbc - 0x2ec5c
int32_t function_2ebbc(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = a4 + 1; // 0x2ebc4
    int32_t v2; // 0x2ebbc
    *(int32_t *)(v2 + 1180) = v1;
    if (v1 > a3) {
        function_2ec6c();
    }
    int32_t v3 = *(int32_t *)(4 * v1 - 4 + g202); // 0x2ebe8
    char * str = __strdup((char *)a1); // 0x2ebec
    function_3cdac(a1, (int32_t *)(v3 + 168));
    *(int32_t *)(v3 + 172) = (int32_t)strtok(str, ":");
    char * next_token = strtok(NULL, ":"); // 0x2ec30
    int32_t * v4 = (int32_t *)(v3 + 176); // 0x2ec3c
    *v4 = (int32_t)next_token;
    int32_t mem = (int32_t)calloc(1, 1); // 0x2ec50
    *v4 = mem;
    return mem;
}

// Address range: 0x2ec5c - 0x2ec6c
int32_t function_2ec5c(int32_t a1, int32_t a2, int32_t a3) {
    // 0x2ec5c
    return (int32_t)"Use only user + pass or userpass, but not both";
}

// Address range: 0x2ec6c - 0x2ec78
int32_t function_2ec6c(void) {
    // 0x2ec6c
    return function_2e940();
}

// Address range: 0x2ec78 - 0x2ecf4
int32_t function_2ec78(int32_t a1) {
    // 0x2ec78
    if (g113 != 0) {
        // 0x2ec90
        return (int32_t)"Use only user + pass or userpass, but not both";
    }
    int32_t v1 = g111 + 1; // 0x2ecb0
    g111 = v1;
    int32_t v2 = v1; // 0x2ecbc
    if (v1 > (int32_t)g188) {
        // 0x2ece8
        function_2e940();
        v2 = g111;
    }
    // 0x2ecc0
    function_3cdac(a1, (int32_t *)(*(int32_t *)(4 * v2 - 4 + g202) + 172));
    return 0;
}

// Address range: 0x2ecf4 - 0x2ed40
int32_t function_2ecf4(void) {
    int32_t v1 = g114 + 1; // 0x2ed10
    g114 = v1;
    int32_t v2 = v1; // 0x2ed1c
    if (v1 > (int32_t)g188) {
        // 0x2ed20
        function_2e940();
        v2 = g114;
    }
    // 0x2ed28
    return *(int32_t *)(4 * v2 - 4 + g202);
}

// Address range: 0x2ed40 - 0x2ee2c
int32_t function_2ed40(int32_t a1) {
    int32_t v1 = function_2ecf4(); // 0x2ed50
    function_28d6c(v1, a1);
    char * str = (char *)*(int32_t *)(v1 + 164); // 0x2ed70
    if (strstr(str, ".nicehash.com") == NULL) {
        // 0x2edf8
        if (strstr(str, "#xnsub") == NULL) {
            // 0x2ede8
            return 0;
        }
    }
    // 0x2ed7c
    *(char *)(v1 + 580) = 1;
    if (*(char *)&g71 == 0) {
        // 0x2ede8
        return 0;
    }
    char v2 = *(char *)&g70; // 0x2edb4
    if ((v2 | *(char *)&g179) != 0 || g28 > (char *)6) {
        int32_t v3 = *(int32_t *)v1; // 0x2edcc
        int32_t str2; // bp-2064, 0x2ed40
        snprintf((char *)&str2, 2048, "Pool %d extranonce subscribing enabled.", v3);
        function_1ccec(7, &str2, 0);
    }
    // 0x2ede8
    return 0;
}

// Address range: 0x2ee2c - 0x2ef5c
int32_t function_2ee2c(int32_t a1) {
    char * str = (char *)a1; // 0x2ee40
    char * found_char_pos = strchr(str, 59); // 0x2ee40
    if (found_char_pos == NULL) {
        // 0x2eeb0
        return (int32_t)"No semicolon separated quota;URL pair found";
    }
    int32_t len = strlen(str); // 0x2ee54
    *found_char_pos = 0;
    int32_t len2 = strlen(str); // 0x2ee64
    if (len2 == 0) {
        // 0x2eeb0
        return (int32_t)" benchfile '%s'" | 2828;
    }
    int32_t v1 = len2 + 1; // 0x2ee78
    if (len - v1 <= 0) {
        // 0x2eeb0
        return (int32_t)" benchfile '%s'" | 2860;
    }
    int32_t str_as_l = strtol(str, NULL, 10); // 0x2ee9c
    if (str_as_l < 0) {
        // 0x2eeb0
        return (int32_t)" benchfile '%s'" | 2888;
    }
    int32_t v2 = function_2ecf4(); // 0x2eed4
    function_28d6c(v2, v1 + a1);
    *(int32_t *)(v2 + 56) = str_as_l;
    if (*(char *)&g179 == 0) {
        // 0x2eefc
        if (*(char *)&g70 == 0 == g28 < (char *)6) {
            // 0x2ef50
            function_28afc();
            // 0x2eeb0
            return 0;
        }
    }
    int32_t v3 = *(int32_t *)v2; // 0x2ef28
    int32_t str2; // bp-2072, 0x2ee2c
    snprintf((char *)&str2, 2048, "Setting pool %d to quota %d", v3, str_as_l);
    function_1ccec(6, &str2, 0);
    // 0x2ef50
    function_28afc();
    // 0x2eeb0
    return 0;
}

// Address range: 0x2ef5c - 0x2efd8
int32_t function_2ef5c(int32_t a1) {
    // 0x2ef5c
    if (g113 != 0) {
        // 0x2ef74
        return (int32_t)"Use only user + pass or userpass, but not both";
    }
    int32_t v1 = g112 + 1; // 0x2ef94
    g112 = v1;
    int32_t v2 = v1; // 0x2efa0
    if (v1 > (int32_t)g188) {
        // 0x2efcc
        function_2e940();
        v2 = g112;
    }
    // 0x2efa4
    function_3cdac(a1, (int32_t *)(*(int32_t *)(4 * v2 - 4 + g202) + 176));
    return 0;
}

// Address range: 0x2efd8 - 0x2f0b8
int32_t function_2efd8(void) {
    int32_t v1 = g115 + 1; // 0x2eff8
    g115 = v1;
    int32_t v2 = v1; // 0x2f004
    if (v1 > (int32_t)g188) {
        // 0x2f094
        function_2e940();
        v2 = g115;
    }
    int32_t v3 = *(int32_t *)(4 * v2 - 4 + g202); // 0x2f028
    if (*(char *)&g71 == 0) {
        // 0x2f080
        function_3ccc8(v3 + 580);
        return 0;
    }
    char v4 = *(char *)&g70; // 0x2f04c
    if ((v4 | *(char *)&g179) != 0 || g28 > (char *)6) {
        int32_t v5 = *(int32_t *)v3; // 0x2f068
        int32_t str; // bp-2056, 0x2efd8
        snprintf((char *)&str, 2048, "Enable extranonce subscribe on %d", v5);
        function_1ccec(7, &str, 0);
    }
    // 0x2f080
    function_3ccc8(v3 + 580);
    return 0;
}

// Address range: 0x2f0b8 - 0x2f224
int32_t function_2f0b8(int32_t a1) {
    int32_t v1 = 0; // bp-2068, 0x2f0cc
    if (a1 == 0) {
        // 0x2f0e8
        return 0;
    }
    int32_t * rwlock = (int32_t *)(a1 + 320); // 0x2f0dc
    int32_t result = pthread_rwlock_trywrlock(rwlock); // 0x2f0dc
    if (result != 0) {
        // 0x2f0e8
        return result;
    }
    int32_t * v2 = (int32_t *)(a1 + 356); // 0x2f0f4
    int32_t v3 = *v2; // 0x2f0f4
    *v2 = 0;
    v1 = v3;
    char * str; // bp-2064, 0x2f0b8
    if (pthread_rwlock_unlock(rwlock) != 0) {
        int32_t v4 = *__errno_location(); // 0x2f1ec
        snprintf((char *)&str, 2048, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", v4, "cgminer.c", "flush_queue", 0x25d7);
        function_1ccec(3, (int32_t *)&str, 1);
        return function_2ab30(1, 1);
    }
    int32_t result2 = function_1da28(); // 0x2f128
    if (v3 == 0) {
        // 0x2f0e8
        return result2;
    }
    int32_t result3 = function_28ffc((int32_t)&v1, (int32_t)"cgminer.c", (int32_t)"flush_queue", 0x25db); // 0x2f140
    if (*(char *)&g71 == 0) {
        // 0x2f0e8
        return result3;
    }
    char v5 = *(char *)&g70; // 0x2f174
    int32_t result4 = result3; // 0x2f168
    if ((v5 | *(char *)&g179) != 0 || g28 > (char *)6) {
        // 0x2f180
        str = (char *)0x63736944;
        result4 = function_1ccec(7, (int32_t *)&str, 0);
    }
    // 0x2f0e8
    return result4;
}

// Address range: 0x2f228 - 0x2f23c
int32_t function_2f228(int32_t a1) {
    // 0x2f228
    int32_t v1; // bp-2144, 0x2f228
    return sysinfo((struct sysinfo *)&v1);
}

// Address range: 0x2f23e - 0x2f244
int32_t function_2f23e(uint32_t a1) {
    // 0x2f23e
    return function_2feca(a1 / 256);
}

// Address range: 0x2f244 - 0x2f61c
int32_t function_2f244(int32_t a1, int32_t a2, int32_t a3, uint32_t a4, int32_t a5) {
    char v1 = *(char *)(a4 % 0x10000 | (int32_t)&g171); // 0x2f248
    int32_t str; // bp+80, 0x2f244
    if ((*(char *)&g70 || v1) == 0 != g28 < (char *)6) {
        int32_t err_num = *__errno_location(); // 0x2f26c
        snprintf((char *)&str, 2048, "Failed to get sysinfo, errno:%u, reason:%s\n", err_num, strerror(err_num));
        function_1ccec(6, &str, 0);
    }
    // 0x2f2a4
    g251 = time(NULL);
    function_1f5c4(&g103);
    function_2251c((int32_t)&g116, (int32_t)&g103);
    g253 = 0;
    g254 = 0;
    g270 = 0;
    g271 = 0;
    g268 = 0;
    g269 = 0;
    g192 = 0;
    g193 = 0;
    *(int32_t *)&g177 = 0;
    g178 = 0;
    *(int32_t *)&g195 = 0;
    g196 = 0;
    int32_t v2 = &g117; // 0x2f33c
    *(int32_t *)v2 = 0;
    *(int32_t *)(v2 + 4) = 0;
    v2 += 8;
    while (v2 != (int32_t)&g118) {
        // 0x2f340
        *(int32_t *)v2 = 0;
        *(int32_t *)(v2 + 4) = 0;
        v2 += 8;
    }
    // 0x2f34c
    g41 = 0;
    g42 = 0x3ff00000;
    *(int32_t *)&g35 = 0;
    g36 = 0x3ff00000;
    g39 = 0;
    g40 = 0x3ff00000;
    g239 = 0;
    g118 = 0;
    g240 = 0;
    g258 = 0;
    g206 = 0;
    g244 = 0;
    g203 = 0;
    g181 = 0;
    g220 = 0;
    g221 = 0;
    g198 = 0;
    g199 = 0;
    *(int32_t *)&g225 = 0;
    g226 = 0;
    *(int32_t *)&g266 = 0;
    g267 = 0;
    g231 = 0;
    g232 = 0;
    g185 = 0;
    g186 = 0;
    *(int32_t *)&g210 = 0;
    g211 = 0;
    *(int32_t *)&g223 = 0;
    g224 = 0;
    g200 = 0;
    g201 = 0;
    if (g188 >= (char *)1) {
        int32_t v3 = g202; // 0x2f46c
        int32_t v4 = *(int32_t *)v3; // 0x2f470
        v3 += 4;
        *(int32_t *)(v4 + 116) = 0;
        *(int32_t *)(v4 + 8) = 0;
        *(int32_t *)(v4 + 12) = 0;
        *(int32_t *)(v4 + 16) = 0;
        *(int32_t *)(v4 + 20) = 0;
        *(int32_t *)(v4 + 120) = 0;
        *(int32_t *)(v4 + 124) = 0;
        *(int32_t *)(v4 + 128) = 0;
        *(int32_t *)(v4 + 132) = 0;
        *(int32_t *)(v4 + 352) = 0;
        *(int32_t *)(v4 + 40) = 0;
        *(int32_t *)(v4 + 44) = 0;
        *(int32_t *)(v4 + 72) = 0;
        *(int32_t *)(v4 + 76) = 0;
        *(int32_t *)(v4 + 80) = 0;
        *(int32_t *)(v4 + 84) = 0;
        *(int32_t *)(v4 + 88) = 0;
        *(int32_t *)(v4 + 92) = 0;
        *(int32_t *)(v4 + 360) = 0;
        *(int32_t *)(v4 + 364) = 0;
        while (g202 + 4 * (int32_t)g188 != v3) {
            // 0x2f470
            v4 = *(int32_t *)v3;
            v3 += 4;
            *(int32_t *)(v4 + 116) = 0;
            *(int32_t *)(v4 + 8) = 0;
            *(int32_t *)(v4 + 12) = 0;
            *(int32_t *)(v4 + 16) = 0;
            *(int32_t *)(v4 + 20) = 0;
            *(int32_t *)(v4 + 120) = 0;
            *(int32_t *)(v4 + 124) = 0;
            *(int32_t *)(v4 + 128) = 0;
            *(int32_t *)(v4 + 132) = 0;
            *(int32_t *)(v4 + 352) = 0;
            *(int32_t *)(v4 + 40) = 0;
            *(int32_t *)(v4 + 44) = 0;
            *(int32_t *)(v4 + 72) = 0;
            *(int32_t *)(v4 + 76) = 0;
            *(int32_t *)(v4 + 80) = 0;
            *(int32_t *)(v4 + 84) = 0;
            *(int32_t *)(v4 + 88) = 0;
            *(int32_t *)(v4 + 92) = 0;
            *(int32_t *)(v4 + 360) = 0;
            *(int32_t *)(v4 + 364) = 0;
        }
    }
    int32_t result = function_29bd4(); // 0x2f4bc
    if (g228 < (char *)1) {
        // 0x2f57c
        return result;
    }
    int32_t v5 = 0; // 0x2f4c8
    int32_t v6 = function_2c8f4(v5); // 0x2f4e8
    function_2251c(v6 + 368, (int32_t)&g103);
    int32_t format; // 0x2f244
    int32_t * v7; // 0x2f244
    int32_t v8; // 0x2f244
    while (pthread_mutex_lock(&g197) == 0) {
        // 0x2f50c
        *(int32_t *)(v6 + 80) = 0;
        *(int32_t *)(v6 + 84) = 0;
        *(int32_t *)(v6 + 36) = 0;
        *(int32_t *)(v6 + 40) = 0;
        *(int32_t *)(v6 + 44) = 0;
        *(int32_t *)(v6 + 88) = 0;
        *(int32_t *)(v6 + 92) = 0;
        *(int32_t *)(v6 + 220) = 0;
        *(int32_t *)(v6 + 200) = 0;
        *(int32_t *)(v6 + 204) = 0;
        *(int32_t *)(v6 + 208) = 0;
        *(int32_t *)(v6 + 212) = 0;
        *(int32_t *)(v6 + 224) = 0;
        *(int32_t *)(v6 + 228) = 0;
        *(int32_t *)(v6 + 192) = 0;
        *(int32_t *)(v6 + 196) = 0;
        if (pthread_mutex_unlock(&g197) != 0) {
            // 0x2f5d4
            format = (int32_t)"WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d";
            v7 = __errno_location();
            v8 = 0x1853;
            goto lab_0x2f5b0;
        }
        // 0x2f54c
        v5++;
        function_1da28();
        int32_t result2 = v6; // 0x2f578
        if (v5 >= (int32_t)g228) {
            // 0x2f57c
            return result2;
        }
        v6 = function_2c8f4(v5);
        function_2251c(v6 + 368, (int32_t)&g103);
    }
    // 0x2f584
    format = (int32_t)"WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d";
    v7 = __errno_location();
    v8 = 0x1846;
    goto lab_0x2f5b0;
  lab_0x2f5b0:;
    int32_t v9 = *v7;
    snprintf((char *)&str, 2048, (char *)format, v9, (struct timeval *)"cgminer.c", "zero_stats", v8);
    function_1ccec(3, &str, 1);
    function_2ab30(1, 1);
    // UNREACHABLE
}

// Address range: 0x2f62c - 0x2f7b0
int32_t function_2f62c(int32_t a1) {
    char v1 = *(char *)&g70; // 0x2f654
    int32_t str; // bp-2056, 0x2f62c
    if ((v1 | *(char *)&g179) == 0 != g28 < (char *)6) {
        int32_t v2 = *(int32_t *)(a1 + 36); // 0x2f660
        int32_t v3 = *(int32_t *)(v2 + 8); // 0x2f678
        int32_t v4 = *(int32_t *)(*(int32_t *)(v2 + 4) + 8); // 0x2f67c
        snprintf((char *)&str, 2048, "%s %d: invalid nonce - HW error", (char *)v4, v3);
        function_1ccec(6, &str, 0);
    }
    // 0x2f698
    int32_t format; // 0x2f62c
    int32_t * v5; // 0x2f62c
    int32_t v6; // 0x2f62c
    if (pthread_mutex_lock(&g180) == 0) {
        int32_t * v7 = (int32_t *)(a1 + 36); // 0x2f6ac
        int32_t * v8 = (int32_t *)(*v7 + 44); // 0x2f6c4
        g239++;
        *v8 = *v8 + 1;
        if (pthread_mutex_unlock(&g180) == 0) {
            // 0x2f6e4
            return *(int32_t *)(*(int32_t *)(*v7 + 4) + 84) == 0 ? function_1da28() : a1;
        }
        // 0x2f780
        format = (int32_t)"WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d";
        v5 = __errno_location();
        v6 = 0x2268;
    } else {
        // 0x2f730
        format = (int32_t)"WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d";
        v5 = __errno_location();
        v6 = 0x2265;
    }
    int32_t v9 = *v5;
    snprintf((char *)&str, 2048, (char *)format, v9, (struct timeval *)"cgminer.c", "inc_hw_errors", v6);
    function_1ccec(3, &str, 1);
    function_2ab30(1, 1);
    // UNREACHABLE
}

// Address range: 0x2f7b4 - 0x2f844
int32_t function_2f7b4(int32_t a1, int32_t a2) {
    // 0x2f7b4
    if ((*(char *)&g70 | *(char *)&g179) == 0) {
        function_2f8ac();
    }
    int32_t v1 = *(int32_t *)(a1 + 36); // 0x2f7f0
    int32_t v2 = *(int32_t *)(v1 + 8); // 0x2f808
    int32_t v3 = *(int32_t *)(*(int32_t *)(v1 + 4) + 8); // 0x2f80c
    int32_t str; // bp-2064, 0x2f7b4
    snprintf((char *)&str, 2048, "%s%d: invalid nonce - HW error", (char *)v3, v2);
    function_1ccec(3, &str, 0);
    if (pthread_mutex_lock(&g180) == 0) {
        // 0x2f83c
        return 0;
    }
    function_2f8c4();
    // UNREACHABLE
}

// Address range: 0x2f846 - 0x2f848
int32_t function_2f846(int32_t a1) {
    // 0x2f846
    return function_2feca(a1);
}

// Address range: 0x2f848 - 0x2f8ac
int32_t function_2f848(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x2f848
    int32_t v1; // 0x2f848
    int32_t * v2 = (int32_t *)(v1 + 44); // 0x2f854
    *(int32_t *)a4 = v1 + a4;
    *v2 = *v2 + v1;
    pthread_mutex_unlock(&g180);
    int32_t v3 = function_1da28(); // 0x2f880
    int32_t v4 = *(int32_t *)(*(int32_t *)(v1 + 36) + 4); // 0x2f888
    return *(int32_t *)(v4 + 84) == 0 ? v3 : v1;
}

// Address range: 0x2f8ac - 0x2f8c4
int32_t function_2f8ac(void) {
    // 0x2f8ac
    int32_t result; // 0x2f8ac
    return result;
}

// Address range: 0x2f8c4 - 0x2f944
int32_t function_2f8c4(void) {
    int32_t v1 = *__errno_location(); // 0x2f8d0
    int32_t str; // bp+16, 0x2f8c4
    snprintf((char *)&str, 2048, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", v1, (struct timeval *)"cgminer.c", "inc_hw_errors_with_diff", 0x2273);
    function_1ccec(3, &str, 1);
    function_2ab30(1, 1);
    // UNREACHABLE
}

// Address range: 0x2f948 - 0x2f96c
int32_t function_2f948(int32_t a1) {
    // 0x2f948
    float64_t v1; // 0x2f948
    __asm_vpush_9(v1);
    __asm_vldr(0);
    int64_t v2 = *(int64_t *)(a1 + 216); // 0x2f95c
    int32_t v3 = v2; // 0x2f95c
    __asm_vmov_8(function_492fc(v2 >> 32, (int64_t)v3), v3);
    return (int32_t)(*(int64_t *)(a1 + 208) / 0x100000000);
}

// Address range: 0x2f96e - 0x2f9e6
int32_t function_2f96e(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x2f96e
    bool v1; // 0x2f96e
    bool v2; // 0x2f96e
    int32_t v3; // 0x2f96e
    if (v2) {
        // .thread
        *(char *)a2 = (char)v3;
        v1 = (v3 & 0x8000000) != 0;
    } else {
        function_fe72e17a();
    }
    // 0x2f976
    if (v2) {
        function_5eaffa();
        __asm_ldcleq(12, 14, v3, 65);
    }
    if (v1 == !v2) {
        function_228096();
    }
    if (!v2) {
        function_fe66e18e();
    }
    if (v2) {
        __asm_ldcleq(12, 14, function_5eb00e(), 65);
    }
    bool v4 = v2 ? (v3 & 16) != 0 : v1;
    if (v4 == !v2) {
        function_2280aa();
    }
    if (v2) {
        // 0x2f99e
        function_62e1a2();
        function_fe56aaaa();
    }
    int32_t v5; // 0x2f96e
    if (v4 == !v2) {
        function_26b026();
        function_106b28a();
        unknown_46b486();
        v5 = function_fe4eb57a();
    } else {
        // 0x2f9aa
        v5 = unknown_46b486();
    }
    int32_t result = v5; // 0x2f9b2
    if (v2) {
        result = function_233036();
    }
    // 0x2f9b6
    if (v4 == !v2) {
        // 0x2f9e6
        return result;
    }
    int32_t v6 = result; // 0x2f9ba
    if (v2) {
        v6 = function_46a9be();
    }
    int32_t result2 = v6;
    if (v2) {
        // .thread5
        __asm_pkhtbvs(result2, a2 >> 24);
        // 0x2f9e6
        return result2;
    }
    bool v7 = false; // 0x2f9c6
    bool v8; // 0x2f96e
    bool v9; // 0x2f96e
    int32_t v10; // 0x2f96e
    if (v2) {
        uint32_t v11 = result2 / 8 + result2; // 0x2f9c6
        int32_t v12 = (result2 & 4) != 0; // 0x2f9c6
        int32_t v13 = v11 + v12; // 0x2f9c6
        if (v13 == 0) {
            v7 = true;
            v9 = true;
            v10 = 64 * v3 & v3;
            v8 = (v3 & 0x4000000) != 0;
            if ((v13 + v12 & -result2) < 0) {
                goto lab_dec_label_pc_unknown_15;
            } else {
                goto lab__thread9;
            }
        } else {
            v7 = false;
            v9 = false;
            v10 = v13;
            v8 = (result2 & 4) != 0 ? v13 <= result2 : v11 < result2;
            if ((v13 + v12 & -result2) < 0) {
                goto lab_dec_label_pc_unknown_15;
            } else {
                goto lab__thread9;
            }
        }
    } else {
        goto lab__thread9;
    }
  lab__thread9:
    // .thread9
    v9 = v7;
    v10 = result2 >> 6 & a2;
    v8 = (result2 & 32) != 0;
    goto lab_dec_label_pc_unknown_15;
  lab_dec_label_pc_unknown_15:;
    int32_t v14 = result2; // 0x2f9d2
    if (v8 == !v9) {
        v14 = function_22805a();
    }
    bool v15 = v8; // 0x2f9d6
    int32_t v16 = v14; // 0x2f9d6
    if (v9) {
        *(int32_t *)v14 = v10;
        *(int32_t *)(v14 + 4) = (int32_t)&g6;
        int32_t v17 = v14 - (int32_t)&g6; // 0x2f9d6
        __asm_eoreq(v17, 0, 20);
        v15 = (v17 & 1 << a4 - 1) != 0;
        v16 = v17;
    }
    int32_t result3 = v16; // 0x2f9e2
    if (v15 == !v9) {
        result3 = function_fe2e9066();
    }
    // 0x2f9e6
    return result3;
}

// Address range: 0x2f9e8 - 0x2fbe0
int32_t function_2f9e8(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x2f9e8
    int32_t result; // 0x2f9e8
    uint32_t v1 = result;
    int32_t format; // 0x2f9e8
    int32_t * v2; // 0x2f9e8
    int32_t v3; // 0x2f9e8
    int32_t v4; // 0x2f9e8
    if (a1 == 0) {
        uint64_t v5 = g93; // 0x2f9f4
        uint32_t v6 = (int32_t)v5; // 0x2f9f4
        if (v1 == v6) {
            v3 = 0;
            if (result > (int32_t)(v5 / 0x100000000)) {
                goto lab_0x2faec;
            } else {
                goto lab_0x2fa04;
            }
        } else {
            v3 = 0;
            if (v1 > v6) {
                goto lab_0x2faec;
            } else {
                goto lab_0x2fa04;
            }
        }
    } else {
        // 0x2fabc
        v4 = 0x143f;
        format = (int32_t)"WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d";
        v2 = __errno_location();
        goto lab_0x2fa98;
    }
  lab_0x2fa98:;
    int32_t v7 = *v2;
    int32_t str; // bp+16, 0x2f9e8
    snprintf((char *)&str, 2048, (char *)format, v7, (struct timeval *)"cgminer.c", "share_diff", v4);
    function_1ccec(3, &str, 1);
    function_2ab30(1, 1);
    // UNREACHABLE
  lab_0x2faec:
    // 0x2faec
    g93 = result;
    function_271e0(result, v1, (int32_t)&g37, 8, 0);
    v3 = 1;
    goto lab_0x2fa04;
  lab_0x2fa04:;
    uint64_t v8 = *(int64_t *)(*(int32_t *)(result + 260) + 368); // 0x2fa0c
    uint32_t v9 = (int32_t)v8; // 0x2fa0c
    if (v1 == v9) {
        if (result > (int32_t)(v8 / 0x100000000)) {
            // 0x2fb10
            goto lab_0x2fa1c;
        } else {
            goto lab_0x2fa1c;
        }
    } else {
        if (v1 > v9) {
            // 0x2fb10
            goto lab_0x2fa1c;
        } else {
            goto lab_0x2fa1c;
        }
    }
  lab_0x2fa1c:
    // 0x2fa1c
    if (pthread_rwlock_unlock((int32_t *)0x740b8) == 0) {
        // 0x2fa2c
        if (pthread_mutex_unlock(&g250) == 0) {
            // 0x2fa40
            function_1da28();
            float64_t v10; // 0x2f9e8
            if (v3 == 0) {
                // 0x2fa58
                __asm_vpop(v10);
                return result;
            }
            char v11 = *(char *)&g70; // 0x2fb94
            if ((v11 | *(char *)&g179) == 0 != g28 < (char *)6) {
                // 0x2fbb4
                snprintf((char *)&str, 2048, "New best share: %s", (char *)&g37);
                function_1ccec(6, &str, 0);
            }
            // 0x2fa58
            __asm_vpop(v10);
            return result;
        }
        // 0x2fb48
        v4 = 0x144d;
        format = (int32_t)"WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d";
        v2 = __errno_location();
    } else {
        // 0x2fb18
        v4 = 0x144d;
        format = (int32_t)"WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d";
        v2 = __errno_location();
    }
    goto lab_0x2fa98;
}

// Address range: 0x2fbe4 - 0x2fc08
int32_t function_2fbe4(int32_t a1) {
    int32_t result = a1; // 0x2fbe4
    bool v1; // 0x2fbe4
    if (v1) {
        // 0x2fbe8
        function_ffc2fbec();
        __asm_stclmi(15, 15, 0xa000007);
        result = -1;
    }
    // 0x2fbe8
    return result;
}

// Address range: 0x2fc18 - 0x2fc4c
int32_t function_2fc18(int32_t a1, int32_t a2) {
    // 0x2fc18
    float64_t v1; // 0x2fc18
    __asm_vpush_9(v1);
    __asm_vldr(g43);
    int32_t v2 = function_2f948(a2); // 0x2fc3c
    *(int32_t *)(a2 + 232) = v2;
    *(int32_t *)(a2 + 236) = a2;
    int32_t result = function_492fc((int64_t)v2, (int64_t)a2); // 0x2fc44
    __asm_vmov_8(result, a2);
    return result;
}

// Address range: 0x2fc4e - 0x2fce2
int32_t function_2fc4e(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = unknown_46b726(); // 0x2fc4e
    bool v2; // 0x2fc4e
    int32_t v3; // 0x2fc4e
    int32_t v4; // 0x2fc4e
    bool v5; // 0x2fc4e
    float32_t v6; // 0x2fc4e
    int32_t v7; // 0x2fc4e
    if (v5) {
        v3 = __asm_vstmiaeq(v7, v6);
        v4 = 64 * v1 & v7;
        v2 = (v1 & 0x4000000) != 0;
    }
    int32_t v8; // 0x2fc4e
    if (v2 == !v5) {
        int32_t v9; // 0x2fc4e
        *(int32_t *)(v7 - 12) = (int32_t)&v9;
        *(int32_t *)(v7 - 8) = v4;
        *(int32_t *)(v7 - 4) = 0x2fc64;
        v8 = v7 - 24;
    }
    int32_t v10 = v1; // 0x2fc62
    if (!v5) {
        *(int32_t *)v1 = v4;
        *(int32_t *)(v1 + 4) = (int32_t)&g7;
        v10 = v1 - (int32_t)&g7;
    }
    bool v11 = v2; // 0x2fc66
    if (v5) {
        v11 = (v10 & 1 << a3 - 1) != 0;
    }
    int32_t v12 = v10; // 0x2fc6a
    if (!v5) {
        v12 = __asm_vstmdbpl(v10, v6);
    }
    int32_t v13 = v12; // 0x2fc6e
    if (v11 == !v5) {
        v13 = function_e68876();
    }
    int32_t result2 = v13;
    bool v14; // 0x2fc4e
    if (v5) {
        int32_t v15 = result2 >> 6; // 0x2fc76
        int32_t v16 = result2 - v15 + (int32_t)((result2 & 32) == 0); // 0x2fc76
        if (((v16 - (int32_t)((result2 & 32) == 0) ^ result2) & (v15 ^ result2)) < 0) {
            *(int32_t *)(a3 + 453) = v16;
            if (v16 == 0) {
                // .thread52
                function_62e486();
                int32_t result = function_62b56a(); // 0x2fc86
                *(char *)(v8 + 3153) = -118;
                // 0x2fcd6
                return result;
            }
            *(char *)(v8 + 3153) = -118;
            if (v16 < 0) {
                // 0x2fcd6
                return result2;
            }
            // .thread71
            __asm_smlabtpl(v7, a2, *(int32_t *)(v3 + 3153));
            // 0x2fcd6
            return result2;
        }
        v14 = v16 < 0;
        if (v16 == 0) {
            // .thread46
            function_62e486();
            function_26ad8e();
            // 0x2fcd6
            return function_62b56a();
        }
    } else {
        if (v5) {
            // .thread72
            *(int32_t *)(a3 + 453) = 0x2fc72;
            *(char *)(v8 + 3153) = -118;
            if (v5) {
                // 0x2fcd6
                return result2;
            }
            // .thread71
            __asm_smlabtpl(v7, a2, *(int32_t *)(v3 + 3153));
            // 0x2fcd6
            return result2;
        }
    }
    // .thread13
    function_26ad8e();
    function_26adae();
    if (!v14) {
        __asm_smlabtpl(v7, a2, 0x2fcaa);
    }
    // .thread69
    function_e6e4c6();
    // 0x2fcd6
    return function_22add2();
}

// Address range: 0x2fce4 - 0x2fe3c
int32_t function_2fce4(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x2fce4
    int32_t v1; // 0x2fce4
    *(int32_t *)(v1 + 232) = a1;
    if (pthread_mutex_unlock(&g180) == 0) {
        int32_t result = function_1da28(); // 0x2fd08
        float64_t v2; // 0x2fce4
        __asm_vpop(v2);
        return result;
    }
    int32_t v3 = *__errno_location(); // 0x2fe0c
    int32_t str; // bp+16, 0x2fce4
    snprintf((char *)&str, 2048, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", v3, (struct timeval *)"cgminer.c", "update_work_stats", 0x22ba);
    function_1ccec(3, &str, 1);
    function_2ab30(1, 1);
    // UNREACHABLE
}

// Address range: 0x2fe44 - 0x2fec8
int32_t function_2fe44(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    if (a4 != 0) {
        *(int32_t *)a4 = 0;
    }
    *(int32_t *)(a2 + 76) = a3;
    if (*(int32_t *)(a2 + 220) != 0) {
        function_2ff24((int32_t)&g306, (int32_t)&g306, (int32_t)&g306);
    }
    // 0x2fe78
    function_2fc18(a1 + 36, a2);
    int32_t v1 = 0; // 0x2fe94
    if (function_1ed30(a2 + 192, a2 + 160) != 0) {
        v1 = function_2ff18((int32_t)&g306, (int32_t)&g306, (int32_t)&g306);
    }
    // 0x2fe98
    if (a4 != 0) {
        *(int32_t *)a4 = 1;
    }
    int32_t result = v1; // 0x2feb4
    if (*(char *)&g179 != 0) {
        result = function_2fee4();
    }
    // 0x2feb8
    return result;
}

// Address range: 0x2feca - 0x2fed0
int32_t function_2feca(int32_t a1) {
    // 0x2feca
    return 0;
}

// Address range: 0x2fed0 - 0x2fee4
int32_t function_2fed0(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x2fed0
    return result;
}

// Address range: 0x2fee4 - 0x2ff18
int32_t function_2fee4(void) {
    char * v1 = (char *)0x72616853; // 0x2fef8
    return function_1ccec(6, (int32_t *)&v1, 0);
}

// Address range: 0x2ff18 - 0x2ff24
int32_t function_2ff18(int32_t a1, int32_t a2, int32_t a3) {
    // 0x2ff18
    int32_t result; // 0x2ff18
    return result;
}

// Address range: 0x2ff24 - 0x2ff3c
int32_t function_2ff24(int32_t a1, int32_t a2, int32_t a3) {
    // 0x2ff24
    int32_t v1; // 0x2ff24
    function_2f62c(v1);
    return 0;
}

// Address range: 0x2ff3c - 0x30260
int32_t function_2ff3c(int32_t a1) {
    // 0x2ff3c
    int32_t v1; // 0x2ff3c
    int32_t format; // 0x2ff3c
    int32_t v2; // 0x2ff3c
    int32_t * v3; // 0x2ff3c
    int32_t v4; // 0x2ff3c
    int32_t v5; // 0x2ff3c
    int32_t v6; // 0x2ff3c
    int32_t v7; // bp-2084, 0x2ff3c
    int32_t v8; // 0x2ff3c
    if (pthread_mutex_lock((int32_t *)g100) == 0) {
        // 0x2ff64
        v7 = g119;
        if (g119 == 0) {
            // 0x30178
            if (pthread_mutex_unlock((int32_t *)g100) == 0) {
                // 0x30188
                return function_1da28();
            }
            goto lab_0x3020c;
        } else {
            int32_t v9 = *(int32_t *)(g119 + 352); // 0x2ff78
            v4 = v9;
            v5 = 0;
            v2 = g119;
            v1 = v9;
            v6 = 0;
            if (*(int32_t *)(g119 + 260) == a1) {
                goto lab_0x2ffa8;
            } else {
                goto lab_0x2ff88;
            }
        }
    } else {
        // 0x301bc
        format = (int32_t)"WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d";
        v3 = __errno_location();
        v8 = 0x1d0d;
        goto lab_0x301e8;
    }
  lab_0x301e8:;
    int32_t v10 = *v3;
    int32_t str; // bp-2080, 0x2ff3c
    snprintf((char *)&str, 2048, (char *)format, v10, (struct timeval *)"cgminer.c", "clear_pool_work", v8);
    function_1ccec(3, &str, 1);
    function_2ab30(1, 1);
    // UNREACHABLE
  lab_0x3020c:
    // 0x3020c
    format = (int32_t)"WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d";
    v3 = __errno_location();
    v8 = 0x1d17;
    goto lab_0x301e8;
  lab_0x2ffa8:;
    int32_t v11 = v1; // 0x30128
    int32_t v12 = v2;
    int32_t v13 = g119; // 0x2ffac
    int32_t * v14 = (int32_t *)(v12 + 348); // 0x2ffa8
    int32_t v15 = *v14; // 0x2ffa8
    int32_t * v16 = (int32_t *)(v13 + 344);
    int32_t v17 = *v16; // 0x2ffb4
    int32_t * v18; // 0x2ff3c
    int32_t v19; // 0x2ff3c
    int32_t v20; // 0x2ff3c
    int32_t v21; // 0x2ff3c
    int32_t v22; // 0x2ff3c
    int32_t v23; // 0x2ff3c
    int32_t v24; // 0x2ff3c
    int32_t v25; // 0x2ff3c
    if (v15 == 0) {
        if (v11 == 0) {
            // 0x3023c
            free((int32_t *)*(int32_t *)v17);
            free((int32_t *)*(int32_t *)(g119 + 344));
            g119 = 0;
            goto lab_0x30074;
        } else {
            int32_t v26 = *(int32_t *)(v17 + 20); // 0x30134
            int32_t v27 = v12 + 344; // 0x30138
            int32_t * v28 = (int32_t *)(v17 + 16);
            v24 = v11;
            v20 = v27;
            v18 = v28;
            v23 = v26;
            v21 = v27;
            if (v12 == *v28 - v26) {
                goto lab_0x30158;
            } else {
                goto lab_0x3014c;
            }
        }
    } else {
        int32_t v29 = *(int32_t *)(v17 + 20); // 0x2ffbc
        int32_t v30 = v12 + 344; // 0x2ffc0
        int32_t * v31 = (int32_t *)(v17 + 16);
        v22 = v29;
        v25 = v15;
        v19 = v30;
        v18 = v31;
        v23 = v29;
        v21 = v30;
        if (v12 == *v31 - v29) {
            goto lab_0x30158;
        } else {
            goto lab_0x2ffd4;
        }
    }
  lab_0x2ff88:
    // 0x2ff88
    v7 = v4;
    int32_t v32 = v4; // 0x2ff90
    int32_t v33 = v5; // 0x2ff90
    int32_t v34 = v5; // 0x2ff90
    if (v4 == 0) {
        goto lab_0x3009c;
    } else {
        goto lab_0x2ff94;
    }
  lab_0x3009c:
    // 0x3009c
    if (pthread_mutex_unlock((int32_t *)g100) == 0) {
        int32_t result = function_1da28(); // 0x300b8
        if (v34 == 0) {
            // 0x3011c
            return result;
        }
        char v35 = *(char *)&g70; // 0x300e0
        int32_t result2 = result; // 0x300d4
        if ((v35 | *(char *)&g179) != 0 || g28 > (char *)5) {
            // 0x300ec
            snprintf((char *)&str, 2048, "Cleared %d work items due to stratum disconnect on pool %d", v34, result);
            result2 = function_1ccec(6, &str, 0);
        }
        // 0x3011c
        return result2;
    }
    goto lab_0x3020c;
  lab_0x2ff94:;
    int32_t v36 = v33;
    int32_t v37 = v32;
    int32_t v38 = *(int32_t *)(v37 + 352); // 0x2ff98
    v4 = v38;
    v5 = v36;
    if (*(int32_t *)(v37 + 260) == a1) {
        // 0x2ff94
        v2 = v37;
        v1 = v38;
        v6 = v36;
        goto lab_0x2ffa8;
    } else {
        goto lab_0x2ff88;
    }
  lab_0x30158:;
    int32_t v39 = v21;
    *v18 = v23 + v15;
    int32_t v40 = *v14; // 0x30160
    if (v40 == 0) {
        // 0x30258
        v24 = *(int32_t *)(v12 + 352);
        v20 = v39;
        goto lab_0x3014c;
    } else {
        // 0x3016c
        v22 = *(int32_t *)(*v16 + 20);
        v25 = v40;
        v19 = v39;
        goto lab_0x2ffd4;
    }
  lab_0x2ffd4:;
    int32_t * v41 = (int32_t *)(v12 + 352); // 0x2ffd4
    *(int32_t *)(v22 + 8 + v25) = *v41;
    int32_t * v42 = v16; // 0x2ffe0
    int32_t v43 = v13; // 0x2ffe0
    int32_t v44 = *v41; // 0x2ffe0
    int32_t v45 = v19; // 0x2ffe0
    goto lab_0x2ffe4;
  lab_0x30074:;
    int32_t v64 = v6 + 1; // 0x30088
    function_28ffc((int32_t)&v7, (int32_t)"cgminer.c", (int32_t)"clear_pool_work", 0x1d13);
    v7 = v11;
    v32 = v11;
    v33 = v64;
    v34 = v64;
    if (v11 == 0) {
        goto lab_0x3009c;
    } else {
        goto lab_0x2ff94;
    }
  lab_0x3014c:
    // 0x3014c
    g119 = v24;
    v42 = (int32_t *)(v24 + 344);
    v43 = v24;
    v44 = v24;
    v45 = v20;
    goto lab_0x2ffe4;
  lab_0x2ffe4:;
    int32_t v46 = v44;
    int32_t * v47 = v42;
    int32_t v48 = *v47; // 0x2ffe4
    int32_t v49 = v48; // 0x2ffec
    if (v46 != 0) {
        *(int32_t *)(v46 + 4 + *(int32_t *)(v48 + 20)) = *v14;
        v49 = *v47;
    }
    int32_t v50 = 12 * (*(int32_t *)(v49 + 4) - 1 & *(int32_t *)(v12 + 372)); // 0x30018
    int32_t * v51 = (int32_t *)(*(int32_t *)v49 + 4 + v50); // 0x3001c
    *v51 = *v51 - 1;
    int32_t * v52 = (int32_t *)(*(int32_t *)*v47 + v50); // 0x30030
    int32_t v53 = *v52; // 0x30030
    int32_t * v54 = (int32_t *)(v12 + 360);
    int32_t v55 = v43; // 0x30038
    if (v53 == v45) {
        int32_t v56 = *v54; // 0x30038
        *v52 = v56;
        v55 = v56;
    }
    int32_t * v57 = (int32_t *)(v12 + 356); // 0x30040
    int32_t v58 = *v57; // 0x30040
    int32_t v59 = *v54; // 0x30044
    int32_t v60 = v59; // 0x30050
    if (v58 != 0) {
        *(int32_t *)(v58 + 16) = v59;
        v60 = *v54;
    }
    int32_t v61 = v60;
    if (v61 != 0) {
        *(int32_t *)(v61 + 12) = *v57;
    }
    int32_t v62 = v53 == v45 ? g119 : v55;
    int32_t * v63 = (int32_t *)(*(int32_t *)(v62 + 344) + 12); // 0x30068
    *v63 = *v63 - 1;
    goto lab_0x30074;
}

// Address range: 0x30264 - 0x306c4
int32_t function_30264(int32_t a1) {
    // 0x30264
    int32_t v1; // 0x30264
    int32_t v2; // 0x30264
    int32_t v3; // 0x30264
    int32_t v4; // 0x30264
    int32_t format; // 0x30264
    int32_t * v5; // 0x30264
    int32_t v6; // 0x30264
    int32_t v7; // 0x302a4
    int32_t v8; // 0x302ac
    if (pthread_mutex_lock(&g250) == 0) {
        // 0x30288
        if (pthread_rwlock_wrlock((int32_t *)0x740b8) == 0) {
            // 0x30298
            v7 = g109;
            int32_t v9 = g89; // 0x302a8
            v8 = *(int32_t *)v7;
            if (a1 == 0) {
                // 0x303c8
                g309 = v9;
                switch (v9) {
                    case 0: {
                        goto lab_0x30354;
                    }
                    case 1: {
                        // 0x30520
                        v3 = g202;
                        goto lab_0x3052c;
                    }
                    case 2: {
                        // 0x30520
                        v3 = g202;
                        goto lab_0x3052c;
                    }
                    case 3: {
                        goto lab_0x30354;
                    }
                    case 4: {
                        goto lab_0x30354;
                    }
                    default: {
                        goto lab_0x303e8;
                    }
                }
            } else {
                int32_t * v10 = (int32_t *)(a1 + 4); // 0x302b4
                int32_t v11 = *v10; // 0x302b4
                if (v11 == 0) {
                    // 0x30334
                    g308 = v9;
                    switch (v9) {
                        case 0: {
                            goto lab_0x30354;
                        }
                        case 1: {
                            goto lab_0x304fc;
                        }
                        case 2: {
                            goto lab_0x304fc;
                        }
                        case 3: {
                            goto lab_0x30354;
                        }
                        case 4: {
                            goto lab_0x30354;
                        }
                        default: {
                            goto lab_0x303e8;
                        }
                    }
                } else {
                    // 0x302c0
                    if (g188 < (char *)1) {
                        // 0x306b4
                        *v10 = 0;
                        if (v9 == 4 || v9 < 4) {
                            return 0;
                        }
                        goto lab_0x303e8;
                    } else {
                        int32_t v12 = g202; // 0x302e8
                        int32_t v13 = *(int32_t *)v12; // 0x302f0
                        int32_t * v14 = (int32_t *)(v13 + 4); // 0x302f4
                        int32_t v15 = *v14; // 0x302f4
                        if (v15 < v11) {
                            *v14 = v15 + 1;
                        }
                        v12 += 4;
                        while (g202 + 4 * (int32_t)g188 != v12) {
                            // 0x302ec
                            v13 = *(int32_t *)v12;
                            v14 = (int32_t *)(v13 + 4);
                            v15 = *v14;
                            if (v15 < *v10) {
                                *v14 = v15 + 1;
                            }
                            v12 += 4;
                        }
                        // 0x3030c
                        *v10 = 0;
                        g307 = v9;
                        v1 = v13;
                        v2 = g202;
                        v4 = g202;
                        switch (v9) {
                            case 0: {
                                goto lab_0x30370;
                            }
                            case 1: {
                                goto lab_0x30508;
                            }
                            case 2: {
                                goto lab_0x30508;
                            }
                            case 3: {
                                goto lab_0x30370;
                            }
                            case 4: {
                                goto lab_0x30370;
                            }
                            default: {
                                goto lab_0x30594;
                            }
                        }
                    }
                }
            }
        } else {
            // 0x305ec
            v6 = 0x149c;
            format = (int32_t)"WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d";
            v5 = __errno_location();
            goto lab_0x305c8;
        }
    } else {
        // 0x3059c
        v6 = 0x149c;
        format = (int32_t)"WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d";
        v5 = __errno_location();
        goto lab_0x305c8;
    }
  lab_0x303f8:;
    // 0x303f8
    int32_t v16; // 0x30264
    g109 = v16;
    int32_t str; // bp-2088, 0x30264
    if (pthread_rwlock_unlock((int32_t *)0x740b8) == 0) {
        // 0x3040c
        if (pthread_mutex_unlock(&g250) == 0) {
            // 0x30420
            function_1da28();
            if (v7 != v16) {
                int32_t v17 = g89 - 3; // 0x3043c
                if (v17 != 0 == (v17 != 1)) {
                    char v18 = *(char *)&g70; // 0x304a0
                    if ((v18 | *(char *)&g179) == 0 != g28 < (char *)4) {
                        int32_t v19 = *(int32_t *)(v16 + 164); // 0x304c0
                        int32_t v20 = *(int32_t *)v16; // 0x304c8
                        snprintf((char *)&str, 2048, "Switching to pool %d %s", v20, (char *)v19);
                        function_1ccec(4, &str, 0);
                    }
                    // 0x304f0
                    function_2ff3c(v7);
                }
            }
            // 0x30448
            if (pthread_mutex_lock(&g120) == 0) {
                // 0x30458
                pthread_cond_broadcast(&g121);
                if (pthread_mutex_unlock(&g120) == 0) {
                    // 0x30470
                    return function_1da28();
                }
                // 0x30698
                v6 = 0x14f7;
                format = (int32_t)"WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d";
                v5 = __errno_location();
            } else {
                // 0x3067c
                v6 = 0x14f5;
                format = (int32_t)"WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d";
                v5 = __errno_location();
            }
        } else {
            // 0x3064c
            v6 = 0x14ed;
            format = (int32_t)"WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d";
            v5 = __errno_location();
        }
    } else {
        // 0x3061c
        v6 = 0x14ed;
        format = (int32_t)"WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d";
        v5 = __errno_location();
    }
    goto lab_0x305c8;
  lab_0x305c8:;
    int32_t v21 = *v5;
    snprintf((char *)&str, 2048, (char *)format, v21, (struct timeval *)"cgminer.c", "switch_pools", v6);
    function_1ccec(3, &str, 1);
    function_2ab30(1, 1);
    // UNREACHABLE
  lab_0x30354:
    // 0x30354
    if (g188 < (char *)1) {
        goto lab_0x303e8;
    } else {
        goto lab_0x30370;
    }
  lab_0x303e8:
    // 0x303e8
    v16 = *(int32_t *)(g202 + 4 * v8);
    goto lab_0x303f8;
  lab_0x30370:;
    int32_t v22 = 0; // 0x30264
    int32_t v23 = function_27af0(v22); // 0x30374
    if (*(char *)(v23 + 97) == 0) {
        // 0x30388
        if (*(int32_t *)(v23 + 100) == 1) {
            // 0x30394
            if (function_279b8(v23) == 0) {
                // .thread16
                v16 = *(int32_t *)(g202 + 4 * *(int32_t *)v23);
                goto lab_0x303f8;
            }
        }
    }
    int32_t v24 = v22 + 1; // 0x303b0
    v22 = v24;
    while (v24 < (int32_t)g188) {
        // 0x30370
        v23 = function_27af0(v22);
        if (*(char *)(v23 + 97) == 0) {
            // 0x30388
            if (*(int32_t *)(v23 + 100) == 1) {
                // 0x30394
                if (function_279b8(v23) == 0) {
                    // .thread16
                    v16 = *(int32_t *)(g202 + 4 * *(int32_t *)v23);
                    goto lab_0x303f8;
                }
            }
        }
        // 0x303ac
        v24 = v22 + 1;
        v22 = v24;
    }
    // 0x303bc
    v16 = *(int32_t *)(g202 + 4 * v8);
    goto lab_0x303f8;
  lab_0x3052c:
    // 0x3052c
    v4 = v3;
    if (g188 > (char *)1) {
        int32_t v25; // 0x30264
        int32_t v26 = v25 + 1; // 0x30548
        int32_t v27; // 0x30264
        int32_t v28; // 0x30534
        int32_t v29 = *(int32_t *)((v26 < v28 ? 4 * v26 : 0) + v27); // 0x3055c
        int32_t v30; // 0x3057c
        if (*(char *)(v29 + 97) == 0) {
            int32_t v31 = *(int32_t *)(v29 + 100); // 0x3056c
            if (v31 == 1) {
                // 0x30578
                v30 = function_279b8(v29);
                v16 = v29;
                if (v30 == 0) {
                    goto lab_0x303f8;
                }
            }
        }
        // 0x30588
        int32_t v32; // 0x30264
        int32_t v33 = v32 + 1; // 0x30588
        v4 = v27;
        while (v33 != v28) {
            // 0x30548
            v26 = (v26 < v28 ? v26 : 0) + 1;
            v29 = *(int32_t *)((v26 < v28 ? 4 * v26 : 0) + v27);
            if (*(char *)(v29 + 97) == 0) {
                // 0x3056c
                if (*(int32_t *)(v29 + 100) == 1) {
                    // 0x30578
                    v30 = function_279b8(v29);
                    v16 = v29;
                    if (v30 == 0) {
                        goto lab_0x303f8;
                    }
                }
            }
            // 0x30588
            v33++;
            v4 = v27;
        }
    }
    goto lab_0x30594;
  lab_0x304fc:
    // 0x304fc
    v1 = 0;
    v2 = g202;
    goto lab_0x30508;
  lab_0x30594:
    // 0x30594
    v16 = *(int32_t *)(v4 + 4 * v8);
    goto lab_0x303f8;
  lab_0x30508:
    // 0x30508
    v3 = v2;
    if (*(char *)(a1 + 97) == 0) {
        // 0x30514
        v16 = *(int32_t *)(v2 + 4 * v1);
        goto lab_0x303f8;
    } else {
        goto lab_0x3052c;
    }
}

// Address range: 0x306e8 - 0x30818
int32_t function_306e8(int32_t a1) {
    int32_t result = function_2b5fc(a1, a1 + 97); // 0x306fc
    if (result != 0) {
        // 0x30708
        return result;
    }
    // 0x30714
    function_1f5c4((int32_t *)(a1 + 136));
    int32_t result2 = function_2e47c(); // 0x3071c
    char v1 = *(char *)&g179; // 0x3072c
    char v2 = *(char *)&g70;
    int32_t str; // bp-2056, 0x306e8
    if (result2 == a1) {
        // 0x307a0
        if (g28 > (char *)3 || (v2 || v1) != 0) {
            int32_t v3 = *(int32_t *)(a1 + 164); // 0x307bc
            snprintf((char *)&str, 2048, "Pool %d %s not responding!", a1, (char *)v3);
            function_1ccec(4, &str, 0);
        }
        // 0x307ec
        return function_30264(0);
    }
    // 0x30734
    if ((v2 || v1) == 0 == g28 < (char *)6) {
        // 0x30708
        return result2;
    }
    int32_t v4 = *(int32_t *)(a1 + 164); // 0x30764
    snprintf((char *)&str, 2048, "Pool %d %s failed to return work", result2, (char *)v4);
    return function_1ccec(6, &str, 0);
}

// Address range: 0x30818 - 0x31024
int32_t function_30818(void) {
    // 0x30818
    float64_t v1; // 0x30818
    __asm_vpush(v1, v1);
    pthread_setcanceltype(1, PTHREAD_CANCEL_DEFERRED);
    function_21db8((int32_t *)"Watchpool");
    __asm_vldr(-0x3d70a3d7);
    function_285a8();
    __asm_vldr(-0x1eb851ec);
    int32_t v2; // bp-2112, 0x30818
    function_1f674(&v2);
    int32_t v3 = 0; // 0x3089c
    int32_t v4; // 0x30818
    int32_t * v5; // 0x30818
    int32_t v6; // 0x30818
    int32_t format; // 0x30818
    int32_t v7; // 0x30818
    int32_t v8; // 0x30818
    int32_t v9; // 0x30818
    int32_t v10; // 0x30818
    int32_t v11; // 0x30818
    int32_t str; // bp-2088, 0x30818
    int32_t v12; // bp-2104, 0x30818
    int32_t v13; // 0x30818
    int32_t v14; // 0x30818
    int32_t v15; // 0x30818
    int32_t v16; // 0x30818
    int32_t v17; // 0x30818
    char * v18; // 0x30818
    int32_t v19; // 0x30910
    int32_t time_val; // 0x30b78
    while (true) {
        // 0x308a0
        int32_t v20; // 0x30818
        int32_t v21 = v20;
        int32_t v22 = v3 + 1; // 0x308a0
        v3 = v22 > 120 ? 0 : v22;
        function_1f5c4(&v12);
        v15 = v21;
        if (g188 >= (char *)1) {
            // 0x30904
            v13 = v21;
            v7 = 0;
            while (true) {
              lab_0x30904:;
                int32_t v23 = v7;
                int32_t v24 = v13;
                v19 = *(int32_t *)(g202 + 4 * v23);
                v14 = v24;
                v8 = v23;
                if (g122 == 0 == g182 == NULL) {
                    // 0x30a78
                    int32_t v25; // bp-2096, 0x30818
                    function_1f5c4(&v25);
                    int32_t * mutex = (int32_t *)(v19 + 188); // 0x30a90
                    if (pthread_mutex_lock(mutex) != 0) {
                        // break (via goto) -> 0x30f34
                        goto lab_0x30f34;
                    }
                    int32_t v26 = v19 + 344; // 0x30aa0
                    int32_t v27 = *(int32_t *)v26; // 0x30aa0
                    int32_t v28; // 0x30818
                    if (v26 == v27) {
                        // 0x30b58
                        v28 = v23;
                        if (pthread_mutex_unlock(mutex) != 0) {
                            goto lab_0x30fe4_2;
                        }
                    } else {
                        int32_t * v29 = (int32_t *)(v19 + 288); // 0x30ab8
                        int32_t v30 = *v29; // 0x30ab8
                        int32_t v31 = v30 > 1 ? v23 : v24;
                        int32_t v32 = v30 > 1 ? v26 : 0;
                        int32_t v33 = v30; // 0x30acc
                        int32_t v34 = v27; // 0x30acc
                        v28 = v23;
                        if (v30 > 1) {
                            int32_t v35 = v34;
                            int32_t v36 = 0;
                            int32_t * v37 = (int32_t *)v35;
                            int32_t v38 = *v37;
                            int32_t v39 = v36; // 0x30b0c
                            int32_t v40; // 0x30b20
                            int32_t v41; // 0x30b20
                            if (v25 - *(int32_t *)(v35 + 8) >= 301) {
                                // 0x30b10
                                *v29 = v33 - 1;
                                v40 = *v37;
                                v41 = *(int32_t *)(v35 + 4);
                                *(int32_t *)(v40 + 4) = v41;
                                *(int32_t *)v41 = v40;
                                free((int32_t *)(v35 - 4));
                                v39 = v36 + 1;
                            }
                            int32_t v42 = v39;
                            while (v32 != v38) {
                                int32_t v43 = *v29; // 0x30ae8
                                v33 = v43;
                                int32_t v44 = v42; // 0x30af4
                                v34 = v38;
                                v28 = v31;
                                if (v43 < 2) {
                                    goto lab_0x30b74;
                                }
                                v35 = v34;
                                v36 = v44;
                                v37 = (int32_t *)v35;
                                v38 = *v37;
                                v39 = v36;
                                if (v25 - *(int32_t *)(v35 + 8) >= 301) {
                                    // 0x30b10
                                    *v29 = v33 - 1;
                                    v40 = *v37;
                                    v41 = *(int32_t *)(v35 + 4);
                                    *(int32_t *)(v40 + 4) = v41;
                                    *(int32_t *)v41 = v40;
                                    free((int32_t *)(v35 - 4));
                                    v39 = v36 + 1;
                                }
                                // 0x30ad4
                                v42 = v39;
                            }
                            // 0x30dd4
                            if (pthread_mutex_unlock(mutex) != 0) {
                                goto lab_0x30fe4_2;
                            }
                            // 0x30dec
                            v28 = v31;
                            if (!((v42 == 0 | *(char *)&g71 == 0))) {
                                char v45 = *(char *)&g70; // 0x30e30
                                v28 = v31;
                                if ((v45 | *(char *)&g179) != 0 || g28 > (char *)6) {
                                    int32_t v46 = *(int32_t *)v19; // 0x30e3c
                                    int32_t v47 = v42 == 1 ? (int32_t)&g19 : (int32_t)&g20;
                                    snprintf((char *)&str, 2048, "Reaped %d curl%s from pool %d", v42, (char *)v47, v46);
                                    function_1ccec(7, &str, 0);
                                    v28 = v31;
                                }
                            }
                        }
                    }
                  lab_0x30b74:
                    // 0x30b74
                    time_val = time(NULL);
                    if (pthread_mutex_lock(&g123) != 0) {
                        // 0x30f84
                        v18 = "prune_stratum_shares";
                        v5 = __errno_location();
                        v6 = 0x280d;
                        format = (int32_t)"WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d";
                        goto lab_0x30f54;
                    }
                    // 0x30b94
                    v9 = v28;
                    if (g124 == 0) {
                        int32_t v48 = pthread_mutex_unlock(&g123); // 0x30e98
                        v14 = 0;
                        v8 = v9;
                        if (v48 != 0) {
                            goto lab_0x30fa8_2;
                        }
                        goto lab_0x30928;
                    } else {
                        int32_t v49 = *(int32_t *)(g124 + 8); // 0x30ba4
                        v16 = 0;
                        v11 = v49;
                        v17 = 0;
                        v10 = g124;
                        v4 = v49;
                        if (v19 == *(int32_t *)(*(int32_t *)(g124 + 36) + 260)) {
                            goto lab_0x30be0;
                        } else {
                            goto lab_0x30bc0;
                        }
                    }
                } else {
                    goto lab_0x30928;
                }
            }
        }
      lab_0x309a4:
        // 0x309a4
        if (*(char *)(function_2e47c() + 97) != 0) {
            // 0x30dc8
            function_30264(0);
        }
        // 0x309b4
        if (g89 == 2) {
            // 0x30d90
            if (v12 - g125 > 60 * g207) {
                // 0x30db4
                function_1f5c4(&g125);
                function_30264(0);
            }
        }
        // 0x309c0
        function_1f680(&v2, 0x1388);
        function_1f674(&v2);
        v20 = v15;
    }
  lab_0x30f34:
    // 0x30f34
    v18 = "reap_curl";
    v5 = __errno_location();
    v6 = 0x27e9;
    format = (int32_t)"WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d";
    goto lab_0x30f54;
  lab_0x30fe4_2:;
    int32_t * v52 = __errno_location(); // 0x30ff8
    int32_t v51 = (int32_t)"reap_curl"; // 0x30ff8
    int32_t v53 = 0x27fb; // 0x30ff8
    goto lab_0x30fbc;
  lab_0x30fa8_2:
    // 0x30fa8
    v52 = __errno_location();
    v51 = (int32_t)"prune_stratum_shares";
    v53 = 0x281a;
    goto lab_0x30fbc;
  lab_0x30928:
    if (v3 == 120) {
        int32_t * v54 = (int32_t *)(v19 + 152); // 0x30930
        int32_t v55 = *v54; // 0x30930
        uint64_t v56 = *(int64_t *)(v19 + 40); // 0x30934
        int32_t v57 = v56 / 0x100000000; // 0x30934
        int32_t v58 = (int32_t)v56 - (v55 >> 31) + (int32_t)((v55 & 0x40000000) == 0); // 0x3093c
        int32_t result = function_4930c(v57 - v55, v58); // 0x30948
        __asm_vldr(*(int32_t *)(v19 + 144));
        __asm_vmov_8(result, v58);
        *v54 = v57;
        return result;
    }
    // 0x3096c
    if (*(int32_t *)(v19 + 100) != 0) {
        // 0x30978
        if (*(char *)(v19 + 284) == 0) {
            // 0x30984
            if (function_2b668(v19, 1) == 0) {
                // 0x30998
                function_1f5c4((int32_t *)(v19 + 136));
            } else {
                if (v19 != 0) {
                    // 0x30a6c
                    function_2e6c0(v19);
                }
            }
            // 0x308dc
            if (*(char *)(v19 + 97) == 0 == g89 == 0) {
                // 0x309d8
                if (*(int32_t *)(v19 + 4) < function_2e614()) {
                    // 0x309e8
                    if (v12 - *(int32_t *)(v19 + 136) > g45) {
                        char v59 = *(char *)&g179; // 0x30a0c
                        char v60 = *(char *)&g70; // 0x30a20
                        char * v61 = g28; // 0x30f24
                        if ((v60 || v59) == 0 != v61 < (char *)4) {
                            int32_t v62 = *(int32_t *)v19; // 0x30a2c
                            int32_t v63 = *(int32_t *)(v19 + 164); // 0x30a3c
                            int32_t v64; // 0x309f4
                            snprintf((char *)&str, 2048, "Pool %d %s stable for >%d seconds", v62, (char *)v63, v64);
                            function_1ccec(4, &str, 0);
                        }
                        // 0x30a60
                        function_30264(0);
                    }
                }
            }
        }
    }
    int32_t v65 = v8 + 1; // 0x308f8
    v13 = v14;
    v7 = v65;
    v15 = v14;
    if (v65 >= (int32_t)g188) {
        // break -> 0x309a4
        goto lab_0x309a4;
    }
    goto lab_0x30904;
  lab_0x30be0:;
    int32_t v66 = v4; // 0x30eb4
    int32_t v67 = v10;
    int32_t v68 = v17;
    v16 = v68;
    v11 = v66;
    int32_t * v69; // 0x30818
    int32_t * v70; // 0x30818
    int32_t v71; // 0x30818
    int32_t v72; // 0x30818
    int32_t v73; // 0x30818
    int32_t v74; // 0x30818
    int32_t * v75; // 0x30bf4
    int32_t v76; // 0x30bf4
    int32_t * v77; // 0x30818
    if (time_val > *(int32_t *)(v67 + 44) + 120) {
        // 0x30bf4
        v75 = (int32_t *)(v67 + 4);
        v76 = *v75;
        v77 = (int32_t *)g124;
        int32_t v78 = *v77; // 0x30c00
        if (v76 == 0) {
            if (v66 == 0) {
                // 0x30ffc
                free((int32_t *)*(int32_t *)v78);
                free((int32_t *)*v77);
                g124 = 0;
                goto lab_0x30cb4;
            } else {
                // 0x30ec0
                v69 = (int32_t *)(v67 + 8);
                v72 = v66;
                if (v67 == *(int32_t *)(v78 + 16) - *(int32_t *)(v78 + 20)) {
                    goto lab_0x30ee0;
                } else {
                    goto lab_0x30ed4;
                }
            }
        } else {
            int32_t v79 = *(int32_t *)(v78 + 20); // 0x30c08
            int32_t * v80 = (int32_t *)(v78 + 16);
            v71 = v76;
            v73 = v79;
            v70 = v80;
            v74 = v79;
            if (v67 == *v80 - v79) {
                goto lab_0x30ee0;
            } else {
                goto lab_0x30c1c;
            }
        }
    } else {
        goto lab_0x30bc0;
    }
  lab_0x30bc0:;
    int32_t v81 = v16; // 0x30bc4
    int32_t v82 = v11; // 0x30bc4
    int32_t v83 = v16; // 0x30bc4
    if (v11 == 0) {
        goto lab_0x30ce4;
    } else {
        goto lab_0x30bc8;
    }
  lab_0x30ce4:
    // 0x30ce4
    if (pthread_mutex_unlock(&g123) != 0) {
        goto lab_0x30fa8_2;
    }
    int32_t v84 = v83;
    v14 = 0;
    v8 = v9;
    if (v84 != 0) {
        char v85 = *(char *)&g70; // 0x30d28
        if ((v85 | *(char *)&g179) == 0 != g28 < (char *)4) {
            int32_t v86 = *(int32_t *)v19; // 0x30d34
            snprintf((char *)&str, 2048, "Lost %d shares due to no stratum share response from pool %d", v84, v86);
            function_1ccec(4, &str, 0);
        }
        int32_t * v87 = (int32_t *)(v19 + 120); // 0x30d70
        *v87 = *v87 + v84;
        *(int32_t *)&g266 = v84 + (int32_t)(g266 / 0x100000000);
        g267 = (v84 >> 31) + (int32_t)((v84 & 0x40000000) != 0) + (int32_t)g266;
        v14 = v84;
        v8 = v9;
    }
    goto lab_0x30928;
  lab_0x30bc8:;
    int32_t v88 = *(int32_t *)(v82 + 8); // 0x30bcc
    v16 = v81;
    v11 = v88;
    v17 = v81;
    v10 = v82;
    v4 = v88;
    if (v19 == *(int32_t *)(*(int32_t *)(v82 + 36) + 260)) {
        goto lab_0x30be0;
    } else {
        goto lab_0x30bc0;
    }
  lab_0x30ee0:
    // 0x30ee0
    *v70 = v74 + v76;
    int32_t v89 = *v75; // 0x30ee8
    if (v89 == 0) {
        int32_t * v90 = (int32_t *)(v67 + 8);
        v69 = v90;
        v72 = *v90;
        goto lab_0x30ed4;
    } else {
        // 0x30ef8
        v71 = v89;
        v73 = *(int32_t *)(*v77 + 20);
        goto lab_0x30c1c;
    }
  lab_0x30c1c:;
    int32_t * v91 = (int32_t *)(v67 + 8);
    *(int32_t *)(v71 + 8 + v73) = *v91;
    int32_t * v92 = v77; // 0x30c24
    int32_t * v93 = v91; // 0x30c24
    goto lab_0x30c28;
  lab_0x30cb4:;
    int32_t v105 = v68 + 1; // 0x30cc4
    function_28ffc(v67 + 36, (int32_t)"cgminer.c", (int32_t)"prune_stratum_shares", 0x2814);
    free((int32_t *)v67);
    v81 = v105;
    v82 = v66;
    v83 = v105;
    if (v66 == 0) {
        goto lab_0x30ce4;
    } else {
        goto lab_0x30bc8;
    }
  lab_0x30ed4:
    // 0x30ed4
    g124 = v72;
    v92 = (int32_t *)v72;
    v93 = v69;
    goto lab_0x30c28;
  lab_0x30c28:;
    int32_t * v94 = v92;
    int32_t v95 = *v93; // 0x30c28
    if (v95 != 0) {
        *(int32_t *)(v95 + 4 + *(int32_t *)(*v94 + 20)) = *v75;
    }
    int32_t v96 = *v94; // 0x30c44
    int32_t v97 = 12 * (*(int32_t *)(v96 + 4) - 1 & *(int32_t *)(v67 + 28)); // 0x30c5c
    int32_t * v98 = (int32_t *)(*(int32_t *)v96 + 4 + v97); // 0x30c60
    *v98 = *v98 - 1;
    int32_t * v99 = (int32_t *)(*(int32_t *)*v94 + v97); // 0x30c74
    int32_t * v100 = (int32_t *)(v67 + 16);
    if (*v99 == v67) {
        *v99 = *v100;
    }
    int32_t * v101 = (int32_t *)(v67 + 12); // 0x30c84
    int32_t v102 = *v101; // 0x30c84
    if (v102 != 0) {
        *(int32_t *)(v102 + 16) = *v100;
    }
    int32_t v103 = *v100; // 0x30c94
    if (v103 != 0) {
        *(int32_t *)(v103 + 12) = *v101;
    }
    int32_t * v104 = (int32_t *)(*v94 + 12); // 0x30ca8
    *v104 = *v104 - 1;
    goto lab_0x30cb4;
  lab_0x30f54:;
    int32_t v50 = *v5; // 0x30f5c
    snprintf((char *)&str, 2048, (char *)format, v50, (struct timeval *)"cgminer.c", v18, v6);
    function_1ccec(3, &str, 1);
    function_2ab30(1, 1);
    // UNREACHABLE
  lab_0x30fbc:
    // 0x30fbc
    v18 = (char *)v51;
    v5 = v52;
    v6 = v53;
    format = (int32_t)"WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d";
    goto lab_0x30f54;
}

// Address range: 0x31024 - 0x313ac
int32_t function_31024(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x31024
    float64_t v1; // 0x31024
    float64_t v2 = __asm_vpush_9(v1); // 0x3102c
    int32_t format; // 0x31024
    int32_t * v3; // 0x31024
    int32_t v4; // 0x31024
    int32_t v5; // 0x31024
    if (pthread_mutex_lock(&g123) == 0) {
        // 0x31048
        if (g124 == 0) {
            // 0x312b8
            if (pthread_mutex_unlock(&g123) == 0) {
                int32_t result = function_1da28(); // 0x312d4
                __asm_vpop(v2);
                return result;
            }
            goto lab_0x31350;
        } else {
            float64_t v6 = __asm_vldr(0); // 0x3106c
            int32_t v7 = *(int32_t *)(g124 + 8); // 0x3107c
            v4 = g124;
            if (*(int32_t *)(*(int32_t *)(g124 + 36) + 260) == a1) {
                goto lab_0x310a0;
            } else {
                int32_t v8 = v7;
                while (v8 != 0) {
                    // 0x31088
                    v4 = v8;
                    if (*(int32_t *)(*(int32_t *)(v8 + 36) + 260) == a1) {
                        goto lab_0x310a0;
                    }
                    v8 += 8;
                }
                // 0x3119c
                if (pthread_mutex_unlock(&g123) == 0) {
                    int32_t result2 = function_1da28(); // 0x311b8
                    __asm_vpop(v6);
                    return result2;
                }
                goto lab_0x31350;
            }
        }
    } else {
        // 0x31300
        format = (int32_t)"WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d";
        v3 = __errno_location();
        v5 = 0x1cee;
        goto lab_0x3132c;
    }
  lab_0x310a0:;
    int32_t * v9 = (int32_t *)(v4 + 4); // 0x310a0
    int32_t v10 = *v9; // 0x310a0
    int32_t * v11 = (int32_t *)g124;
    int32_t v12 = *v11; // 0x310ac
    int32_t * v13; // 0x31024
    int32_t v14; // 0x31024
    int32_t v15; // 0x31024
    int32_t v16; // 0x31024
    int32_t v17; // 0x31024
    int32_t result3; // 0x31164
    if (v10 == 0) {
        int32_t v18 = *(int32_t *)(v4 + 8); // 0x31270
        if (v18 == 0) {
            // 0x31380
            free((int32_t *)*(int32_t *)v12);
            free((int32_t *)*v11);
            g124 = 0;
            // 0x3115c
            result3 = v4 + 36;
            __asm_vldr(*(int32_t *)(*(int32_t *)result3 + 376));
            return result3;
        }
        int32_t v19 = *(int32_t *)(v12 + 20); // 0x3127c
        int32_t * v20 = (int32_t *)(v12 + 16);
        v13 = v20;
        v17 = v19;
        v15 = v18;
        if (v4 == *v20 - v19) {
            goto lab_0x31290;
        } else {
            goto lab_0x312a8;
        }
    } else {
        int32_t v21 = v12 + 16;
        uint64_t v22 = *(int64_t *)v21; // 0x310b4
        int32_t v23 = v22; // 0x310b4
        v14 = v10;
        v16 = v23;
        if (v4 == (int32_t)(v22 / 0x100000000) - v23) {
            // 0x310b4
            v13 = (int32_t *)v21;
            v17 = v23;
            goto lab_0x31290;
        } else {
            goto lab_0x310c4;
        }
    }
  lab_0x3132c:;
    int32_t v24 = *v3;
    int32_t str; // bp-2088, 0x31024
    snprintf((char *)&str, 2048, (char *)format, v24, (struct timeval *)"cgminer.c", "clear_stratum_shares", v5);
    function_1ccec(3, &str, 1);
    function_2ab30(1, 1);
    // UNREACHABLE
  lab_0x31350:
    // 0x31350
    format = (int32_t)"WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d";
    v3 = __errno_location();
    v5 = 0x1cfc;
    goto lab_0x3132c;
  lab_0x31290:
    // 0x31290
    *v13 = v17 + v10;
    int32_t v25 = *v9; // 0x31298
    if (v25 == 0) {
        // 0x312a4
        v15 = *(int32_t *)(v4 + 8);
        goto lab_0x312a8;
    } else {
        // 0x313a0
        v14 = v25;
        v16 = *(int32_t *)(*v11 + 20);
        goto lab_0x310c4;
    }
  lab_0x312a8:
    // 0x312a8
    g124 = v15;
    int32_t * v26 = (int32_t *)v15; // 0x312b4
    int32_t v27 = v15; // 0x312b4
    goto lab_0x310d4;
  lab_0x310c4:;
    int32_t * v39 = (int32_t *)(v4 + 8); // 0x310c4
    *(int32_t *)(v14 + 8 + v16) = *v39;
    v26 = v11;
    v27 = *v39;
    goto lab_0x310d4;
  lab_0x310d4:;
    int32_t v28 = *v26; // 0x310d4
    int32_t v29 = v28; // 0x310dc
    if (v27 != 0) {
        *(int32_t *)(v27 + 4 + *(int32_t *)(v28 + 20)) = *v9;
        v29 = *v26;
    }
    int32_t v30 = 12 * (*(int32_t *)(v29 + 4) - 1 & *(int32_t *)(v4 + 28)); // 0x31108
    int32_t * v31 = (int32_t *)(*(int32_t *)v29 + 4 + v30); // 0x3110c
    *v31 = *v31 - 1;
    int32_t * v32 = (int32_t *)(*(int32_t *)*v26 + v30); // 0x31120
    if (*v32 == v4) {
        *v32 = *(int32_t *)(v4 + 16);
    }
    int32_t v33 = v4 + 12; // 0x31130
    uint64_t v34 = *(int64_t *)v33; // 0x31130
    int32_t v35 = v34; // 0x31130
    int32_t v36 = v34 / 0x100000000; // 0x31130
    int32_t v37 = v35; // 0x31138
    if (v36 != 0) {
        *(int32_t *)(v36 + 16) = v35;
        v37 = *(int32_t *)(v4 + 16);
    }
    // .critedge6
    if (v37 != 0) {
        *(int32_t *)(v37 + 12) = *(int32_t *)v33;
    }
    int32_t * v38 = (int32_t *)(*v26 + 12); // 0x31150
    *v38 = *v38 - 1;
    // 0x3115c
    result3 = v4 + 36;
    __asm_vldr(*(int32_t *)(*(int32_t *)result3 + 376));
    return result3;
}

// Address range: 0x313ac - 0x313b0
int32_t function_313ac(void) {
    // 0x313ac
    return unknown_4319f0();
}

// Address range: 0x313c0 - 0x31854
int32_t function_313c0(int32_t a1) {
    // 0x313c0
    int32_t v1; // 0x313c0
    int32_t format; // 0x313c0
    int32_t * v2; // 0x313c0
    int32_t v3; // 0x313c0
    int32_t v4; // 0x313c0
    if (pthread_mutex_lock((int32_t *)g100) == 0) {
        int32_t v5 = g119; // 0x313e4
        if (v5 == 0) {
            goto lab_0x31400;
        } else {
            // 0x313f0
            v1 = v5;
            v3 = a1;
            if (*(int32_t *)(*(int32_t *)(v5 + 344) + 12) == 0) {
                goto lab_0x31400;
            } else {
                goto lab_0x314ec;
            }
        }
    } else {
        // 0x317b0
        format = (int32_t)"WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d";
        v2 = __errno_location();
        v4 = 0x2027;
        goto lab_0x317dc;
    }
  lab_0x316f8:
    // 0x316f8
    __asm_udf(0);
    int32_t v6; // 0x313c0
    int32_t v7 = v6; // 0x31700
    int32_t v8; // 0x313c0
    int32_t v9 = v8; // 0x31700
    int32_t v10 = *(int32_t *)348; // 0x31700
    int32_t v11; // 0x313c0
    int32_t v12 = v11; // 0x31700
    goto lab_0x31704;
  lab_0x31400:;
    int32_t result = 0; // 0x31404
    char * str; // bp-2072, 0x313c0
    if (a1 == 0) {
        goto lab_0x31640;
    } else {
        while (true) {
            // 0x31428
            int32_t v81; // bp-2080, 0x313c0
            function_1f5c4(&v81);
            int32_t v82 = v81; // 0x31438
            int32_t abstime = v82 + 10; // bp-2088, 0x31448
            pthread_cond_signal(&g190);
            int32_t v83 = g215; // 0x31450
            int32_t mutex = g100; // 0x31458
            int32_t v84 = pthread_cond_timedwait((int32_t *)(v83 + 40), (int32_t *)mutex, (struct timespec *)&abstime); // 0x31460
            char v85 = g110; // 0x3146c
            if (v84 != 0 == v85 == 0) {
                char v86 = *(char *)&g179; // 0x31478
                g110 = 1;
                char v87 = *(char *)&g70; // 0x3148c
                char * v88 = g28; // 0x31674
                if ((v87 || v86) == 0 != v88 < (char *)4) {
                    // 0x31498
                    str = (char *)0x74696157;
                    function_1ccec(4, (int32_t *)&str, 0);
                }
            }
            int32_t v89 = g119; // 0x314d0
            if (v89 != 0) {
                int32_t v90 = *(int32_t *)(v89 + 344); // 0x314dc
                int32_t v91 = *(int32_t *)(v90 + 12); // 0x314e0
                v1 = v89;
                v3 = &g190;
                if (v91 != 0) {
                    // break -> 0x314ec
                    break;
                }
            }
        }
        goto lab_0x314ec;
    }
  lab_0x317dc:;
    int32_t v65 = *v2;
    snprintf((char *)&str, 2048, (char *)format, v65, (struct timeval *)"cgminer.c", "hash_pop", v4);
    function_1ccec(3, (int32_t *)&str, 1);
    function_2ab30(1, 1);
    // UNREACHABLE
  lab_0x31640:
    // 0x31640
    if (pthread_mutex_unlock((int32_t *)g100) == 0) {
        // 0x31650
        function_1da28();
        return result;
    }
    // 0x31800
    format = (int32_t)"WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d";
    v2 = __errno_location();
    v4 = 0x206f;
    goto lab_0x317dc;
  lab_0x314ec:;
    int32_t v66 = v1; // 0x314f4
    if (g110 == 0) {
        goto lab_0x314fc;
    } else {
        char v67 = *(char *)&g70; // 0x316a0
        if ((v67 | *(char *)&g179) == 0 == g28 < (char *)4) {
            // 0x316e4
            g110 = 0;
            v66 = v1;
            goto lab_0x314fc;
        } else {
            // 0x316e4
            str = (char *)0x6b726f57;
            function_1ccec(4, (int32_t *)&str, 0);
            g110 = 0;
            v66 = g119;
            v6 = (int32_t)&str;
            v8 = 0;
            v11 = v3;
            if (g119 == 0) {
                goto lab_0x316f8;
            } else {
                goto lab_0x314fc;
            }
        }
    }
  lab_0x314fc:;
    int32_t v68 = v66;
    int32_t v69 = *(int32_t *)(v68 + 344); // 0x314fc
    int32_t v70 = v68; // 0x3150c
    if (*(int32_t *)(v69 + 12) > g126) {
        // 0x31510
        v70 = v68;
        if (*(char *)(v68 + 273) == 0) {
            // 0x31754
            v70 = v68;
            if (*(int32_t *)(v68 + 276) == 0) {
                goto lab_0x31520;
            } else {
                int32_t v71 = *(int32_t *)(v68 + 352); // 0x31760
                v6 = v69;
                v8 = v68;
                v11 = 0;
                int32_t v72 = v71; // 0x31768
                if (v71 == 0) {
                    goto lab_0x316f8;
                } else {
                    int32_t v73 = v72;
                    v70 = v73;
                    while (*(char *)(v73 + 273) == 0) {
                        int32_t v74 = *(int32_t *)(v73 + 352); // 0x3177c
                        v70 = v73;
                        if (*(int32_t *)(v73 + 276) == 0) {
                            // break -> 0x31520
                            break;
                        }
                        // 0x31788
                        v6 = v69;
                        v8 = v68;
                        v11 = 0;
                        v72 = v74;
                        if (v74 == 0) {
                            goto lab_0x316f8;
                        }
                        v73 = v72;
                        v70 = v73;
                    }
                    goto lab_0x31520;
                }
            }
        } else {
            goto lab_0x31520;
        }
    } else {
        goto lab_0x31520;
    }
  lab_0x31520:;
    int32_t v75 = v70;
    int32_t * v76 = (int32_t *)(v75 + 348);
    int32_t v77 = *v76; // 0x31520
    v7 = v69;
    v9 = v68;
    v10 = 0;
    v12 = v75;
    int32_t * v24; // 0x313c0
    int32_t * v23; // 0x313c0
    int32_t v33; // 0x313c0
    int32_t v37; // 0x313c0
    int32_t v29; // 0x313c0
    int32_t v34; // 0x313c0
    int32_t v25; // 0x313c0
    int32_t v26; // 0x313c0
    int32_t v35; // 0x313c0
    int32_t v27; // 0x313c0
    int32_t v36; // 0x313c0
    int32_t v28; // 0x313c0
    if (v77 == 0) {
        goto lab_0x31704;
    } else {
        int32_t v78 = *(int32_t *)(v69 + 20); // 0x3152c
        int32_t v79 = v75 + 344; // 0x31530
        int32_t * v80 = (int32_t *)(v69 + 16);
        v33 = v68;
        v34 = v79;
        v35 = v77;
        v36 = v75;
        v37 = v78;
        v23 = v76;
        v24 = v80;
        v25 = v79;
        v26 = v68;
        v27 = v77;
        v28 = v75;
        v29 = v78;
        if (v75 == *v80 - v78) {
            goto lab_0x31734;
        } else {
            goto lab_0x31544;
        }
    }
  lab_0x31704:;
    int32_t v13 = v12;
    int32_t v14 = v7;
    int32_t v15 = *(int32_t *)(v13 + 352); // 0x31704
    int32_t v16; // 0x313c0
    int32_t v17; // 0x313c0
    int32_t v18; // 0x313c0
    int32_t v19; // 0x313c0
    if (v15 == 0) {
        // 0x31830
        free((int32_t *)*(int32_t *)v14);
        free((int32_t *)*(int32_t *)(g119 + 344));
        g119 = 0;
        v17 = v13;
        goto lab_0x315ec;
    } else {
        int32_t v20 = *(int32_t *)(v14 + 20); // 0x31710
        int32_t v21 = v13 + 344; // 0x31714
        int32_t * v22 = (int32_t *)(v14 + 16);
        v16 = v21;
        v18 = v13;
        v19 = v15;
        if (v13 == *v22 - v20) {
            // 0x31710
            v23 = (int32_t *)(v13 + 348);
            v24 = v22;
            v25 = v21;
            v26 = v9;
            v27 = v10;
            v28 = v13;
            v29 = v20;
            goto lab_0x31734;
        } else {
            goto lab_0x31728;
        }
    }
  lab_0x31734:;
    int32_t v30 = v28;
    int32_t v31 = v25;
    *v24 = v29 + v27;
    int32_t v32 = *v23; // 0x3173c
    if (v32 == 0) {
        // 0x3184c
        v16 = v31;
        v18 = v30;
        v19 = *(int32_t *)(v30 + 352);
        goto lab_0x31728;
    } else {
        // 0x31748
        v33 = g119;
        v34 = v31;
        v35 = v32;
        v36 = v30;
        v37 = *(int32_t *)(*(int32_t *)(v26 + 344) + 20);
        goto lab_0x31544;
    }
  lab_0x31544:;
    int32_t * v38 = (int32_t *)(v36 + 352); // 0x31544
    *(int32_t *)(v35 + 8 + v37) = *v38;
    int32_t v39 = v34; // 0x31554
    int32_t v40 = v33; // 0x31554
    int32_t v41 = v36; // 0x31554
    int32_t v42 = *v38; // 0x31554
    goto lab_0x31558;
  lab_0x315ec:;
    int32_t v64 = v17;
    if (*(char *)(v64 + 273) == 0) {
        // 0x315f8
        if (*(int32_t *)(v64 + 276) != 0) {
            g126--;
        }
    }
    // 0x3160c
    pthread_cond_signal(&g190);
    pthread_cond_signal((int32_t *)(g215 + 40));
    g247 = time(NULL);
    result = v64;
    goto lab_0x31640;
  lab_0x31728:
    // 0x31728
    g119 = v19;
    v39 = v16;
    v40 = v19;
    v41 = v18;
    v42 = v19;
    goto lab_0x31558;
  lab_0x31558:;
    int32_t * v43 = (int32_t *)(v40 + 344); // 0x31558
    if (v42 != 0) {
        int32_t v44; // 0x31558
        int32_t v45 = *(int32_t *)(v44 + 20); // 0x31560
        int32_t v46; // 0x313c0
        int32_t v47 = *(int32_t *)(v46 + 348); // 0x31564
        int32_t v48; // 0x313c0
        *(int32_t *)(v48 + 4 + v45) = v47;
    }
    int32_t v49 = *v43;
    int32_t v50 = 12 * (*(int32_t *)(v49 + 4) - 1 & *(int32_t *)(v41 + 372)); // 0x3158c
    int32_t * v51 = (int32_t *)(*(int32_t *)v49 + 4 + v50); // 0x31594
    *v51 = *v51 - 1;
    int32_t * v52 = (int32_t *)(*(int32_t *)*v43 + v50); // 0x315a8
    int32_t v53 = *v52; // 0x315a8
    int32_t * v54 = (int32_t *)(v41 + 360);
    int32_t v55 = v40; // 0x315b0
    if (v53 == v39) {
        int32_t v56 = *v54; // 0x315b0
        *v52 = v56;
        v55 = v56;
    }
    int32_t * v57 = (int32_t *)(v41 + 356); // 0x315b8
    int32_t v58 = *v57; // 0x315b8
    int32_t v59 = *v54; // 0x315bc
    int32_t v60 = v59; // 0x315c8
    if (v58 != 0) {
        *(int32_t *)(v58 + 16) = v59;
        v60 = *v54;
    }
    int32_t v61 = v60;
    if (v61 != 0) {
        *(int32_t *)(v61 + 12) = *v57;
    }
    int32_t v62 = v53 == v39 ? g119 : v55;
    int32_t * v63 = (int32_t *)(*(int32_t *)(v62 + 344) + 12); // 0x315e0
    *v63 = *v63 - 1;
    v17 = v41;
    goto lab_0x315ec;
}

// Address range: 0x31858 - 0x31ae0
int32_t function_31858(int32_t a1) {
    char * v1 = (char *)(a1 + 107); // 0x31860
    if (*v1 == 0) {
        // 0x31968
        pthread_detach(pthread_self());
    }
    char * v2 = (char *)(a1 + 105); // 0x31874
    unsigned char v3 = *v2; // 0x31874
    if (v3 != 0) {
        // 0x31958
        return 0;
    }
    while (function_2b668(a1, 0) == 0) {
        // 0x31884
        function_306e8(a1);
        if (*v1 != 0) {
            goto lab_0x31950;
        }
        // 0x31898
        sleep(30);
        if (*v2 != 0) {
            // 0x31958
            return 0;
        }
    }
    // 0x318c0
    int32_t format; // 0x31858
    int32_t * v4; // 0x31858
    int32_t str; // bp-2064, 0x31858
    int32_t v5; // 0x31858
    if (pthread_mutex_lock(&g250) == 0) {
        // 0x318e0
        if (pthread_rwlock_wrlock((int32_t *)0x740b8) == 0) {
            int32_t v6 = v3; // 0x31900
            if (*(char *)&g82 == 0) {
                // 0x31974
                g109 = a1;
                *(char *)&g82 = 1;
                v6 = 0;
            }
            // 0x31904
            if (pthread_rwlock_unlock((int32_t *)0x740b8) == 0) {
                // 0x31914
                if (pthread_mutex_unlock(&g250) == 0) {
                    int32_t v7 = function_1da28(); // 0x31934
                    if (v6 != 0) {
                        char v8 = *(char *)&g70; // 0x319ac
                        if ((v8 | *(char *)&g179) == 0 != g28 < (char *)5) {
                            int32_t v9 = *(int32_t *)(a1 + 164); // 0x319cc
                            snprintf((char *)&str, 2048, "Switching to pool %d %s - first alive pool", v7, (char *)v9);
                            function_1ccec(5, &str, 0);
                        }
                    }
                    // 0x31940
                    function_2e6c0(a1);
                    function_30264(0);
                  lab_0x31950:
                    // 0x31950
                    *(char *)(a1 + 284) = 0;
                    // 0x31958
                    return 0;
                }
                // 0x31ab0
                v5 = 0x2a62;
                format = (int32_t)"WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d";
                v4 = __errno_location();
            } else {
                // 0x31a80
                v5 = 0x2a62;
                format = (int32_t)"WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d";
                v4 = __errno_location();
            }
        } else {
            // 0x31a50
            v5 = 0x2a54;
            format = (int32_t)"WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d";
            v4 = __errno_location();
        }
    } else {
        // 0x31a00
        v5 = 0x2a54;
        format = (int32_t)"WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d";
        v4 = __errno_location();
    }
    int32_t v10 = *v4;
    snprintf((char *)&str, 2048, (char *)format, v10, (struct timeval *)"cgminer.c", "test_pool_thread", v5);
    function_1ccec(3, &str, 1);
    function_2ab30(1, 1);
    // UNREACHABLE
}

// Address range: 0x31ae8 - 0x31d88
int32_t function_31ae8(int32_t * a1, int32_t a2) {
    // 0x31ae8
    if (g79 == NULL) {
        // 0x31c9c
        return (int32_t)a1;
    }
    int32_t v1 = *(int32_t *)(a2 + 256); // 0x31b08
    int32_t v2 = function_2df8c(v1); // 0x31b1c
    int32_t v3 = *(int32_t *)(a2 + 432); // 0x31b20
    int32_t v4 = *(int32_t *)(v2 + 36); // 0x31b28
    int32_t v5 = function_1e9b4(a2 + 160, 32); // 0x31b38
    int32_t v6 = function_1e9b4(a2 + 192, 32); // 0x31b48
    int32_t v7 = function_1e9b4(a2, 128); // 0x31b58
    int32_t v8 = *(int32_t *)(v4 + 8); // 0x31b78
    int32_t v9 = *(int32_t *)(*(int32_t *)(v4 + 4) + 8); // 0x31b90
    int32_t v10 = *(int32_t *)(*(int32_t *)(a2 + 260) + 164); // 0x31b98
    int32_t str; // bp-3112, 0x31ae8
    int32_t chars_printed = snprintf((char *)&str, 1024, "%lu,%s,%s,%s,%s%u,%u,%s,%s\n", v3, a1, (char *)v5, (char *)v10, (char *)v9, v8, v1, (char *)v6, (char *)v7); // 0x31ba0
    free((int32_t *)v5);
    free((int32_t *)v6);
    free((int32_t *)v7);
    int32_t format; // 0x31ae8
    int32_t * v11; // 0x31ae8
    int32_t v12; // 0x31ae8
    int32_t v13; // 0x31ae8
    if (chars_printed < 0) {
        char v14 = *(char *)&g70; // 0x31ccc
        v13 = (int32_t)"sharelog printf error";
        if ((v14 | *(char *)&g179) == 0 == g28 < (char *)3) {
            // 0x31c9c
            return &g306;
        }
        goto lab_0x31c6c;
    } else {
        // 0x31bd0
        if (pthread_mutex_lock(&g127) == 0) {
            int32_t items_written = fwrite(&str, chars_printed, 1, g79); // 0x31bf0
            fflush(g79);
            if (pthread_mutex_unlock(&g127) == 0) {
                int32_t result = function_1da28(); // 0x31c1c
                if (items_written == 1) {
                    // 0x31c9c
                    return result;
                }
                char v15 = *(char *)&g70; // 0x31c44
                v13 = (int32_t)"sharelog fwrite error";
                if ((v15 | *(char *)&g179) == 0 == g28 < (char *)3) {
                    // 0x31c9c
                    return result;
                }
                goto lab_0x31c6c;
            } else {
                // 0x31d54
                v12 = 685;
                format = (int32_t)"WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d";
                v11 = __errno_location();
                goto lab_0x31d2c;
            }
        } else {
            // 0x31cfc
            v12 = 682;
            format = (int32_t)"WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d";
            v11 = __errno_location();
            goto lab_0x31d2c;
        }
    }
  lab_0x31c6c:;
    int32_t str2 = *(int32_t *)v13; // bp-2088, 0x31c78
    // 0x31c9c
    return function_1ccec(3, &str2, 0);
  lab_0x31d2c:;
    int32_t v16 = *v11;
    snprintf((char *)&str2, 2048, (char *)format, v16, (struct timeval *)"cgminer.c", "sharelog", v12);
    function_1ccec(3, &str2, 1);
    function_2ab30(1, 1);
    // UNREACHABLE
}

// Address range: 0x31d90 - 0x3236c
int32_t function_31d90(int32_t a1, int32_t a2) {
    int32_t * mutex = (int32_t *)(a1 + 212); // 0x31dac
    char * v1; // 0x31d90
    char v2; // 0x31d90
    int32_t format; // 0x31d90
    int32_t * v3; // 0x31d90
    int32_t str; // bp-2088, 0x31d90
    int32_t v4; // 0x31d90
    int32_t v5; // 0x31e34
    int32_t * v6; // 0x31fa8
    int32_t * v7; // 0x31fb8
    int32_t * v8; // 0x31fd4
    int32_t v9; // 0x320c4
    int32_t v10; // 0x320d4
    if (pthread_mutex_lock(mutex) == 0) {
        int32_t * rwlock = (int32_t *)(a1 + 236); // 0x31dc0
        if (pthread_rwlock_wrlock(rwlock) == 0) {
            int32_t v11 = a1 + 624; // 0x31dcc
            int32_t * v12 = (int32_t *)(a1 + 632); // 0x31dd0
            int32_t v13 = *v12; // 0x31dd0
            uint64_t v14 = *(int64_t *)v11; // 0x31dd4
            int32_t * v15 = (int32_t *)(a1 + 1568); // 0x31ddc
            int32_t v16 = *v15; // 0x31ddc
            int32_t v17 = *(int32_t *)(a1 + 1576); // 0x31de4
            int32_t v18 = v14 / 0x100000000; // bp-2192, 0x31df4
            int32_t v19 = v14; // bp-2188, 0x31df4
            function_2220c(v17 + v16, &v18, v13, (int32_t)"cgminer.c", (int32_t)"gen_stratum_work", 0x20de);
            int32_t * v20 = (int32_t *)v11; // 0x31e18
            int32_t v21 = *v20; // 0x31e18
            int32_t * v22 = (int32_t *)(a1 + 628); // 0x31e20
            int32_t v23 = *v22; // 0x31e20
            *v20 = v21 + 1;
            *v22 = v23 + (int32_t)(v21 == -1);
            v5 = a2 + 296;
            *(int32_t *)v5 = v21;
            *(int32_t *)(a2 + 300) = v23;
            *(int32_t *)(a2 + 304) = *v12;
            if (pthread_rwlock_unlock(rwlock) == 0) {
                // 0x31e50
                if (pthread_rwlock_rdlock(rwlock) == 0) {
                    // 0x31e60
                    if (pthread_mutex_unlock(mutex) == 0) {
                        // 0x31e70
                        function_1d9c8((int32_t *)*v15, *(int32_t *)(a1 + 1572), &str);
                        int32_t v24; // bp-2184, 0x31d90
                        function_1d9c8(&str, 32, &v24);
                        int32_t v25; // bp-2152, 0x31d90
                        int32_t v26 = &v25; // 0x31e9c
                        function_2220c(v26, &v24, 32, (int32_t)"cgminer.c", (int32_t)"gen_stratum_work", 0x20e8);
                        int32_t * v27 = (int32_t *)(a1 + 1708); // 0x31eb0
                        if (*v27 >= 1) {
                            // 0x31ec4
                            int32_t v28; // bp-2120, 0x31d90
                            int32_t v29 = &v28; // 0x31ed0
                            int32_t v30 = 0; // 0x31ed8
                            int32_t v31 = *(int32_t *)(*(int32_t *)(a1 + 676) + 4 * v30); // 0x31ed4
                            v30++;
                            function_2220c(v29, (int32_t *)v31, 32, (int32_t)"cgminer.c", (int32_t)"gen_stratum_work", 0x20ec);
                            function_1d9c8(&v25, 64, &str);
                            function_1d9c8(&str, 32, &v24);
                            function_2220c(v26, &v24, 32, (int32_t)"cgminer.c", (int32_t)"gen_stratum_work", 0x20ee);
                            while (*v27 > v30) {
                                // 0x31ec4
                                v31 = *(int32_t *)(*(int32_t *)(a1 + 676) + 4 * v30);
                                v30++;
                                function_2220c(v29, (int32_t *)v31, 32, (int32_t)"cgminer.c", (int32_t)"gen_stratum_work", 0x20ec);
                                function_1d9c8(&v25, 64, &str);
                                function_1d9c8(&str, 32, &v24);
                                function_2220c(v26, &v24, 32, (int32_t)"cgminer.c", (int32_t)"gen_stratum_work", 0x20ee);
                            }
                        }
                        int32_t v32 = &v19; // 0x31f3c
                        int32_t v33; // bp-2156, 0x31d90
                        int32_t v34 = &v33; // 0x31f3c
                        v34 += 4;
                        int32_t v35 = llvm_bswap_i32(*(int32_t *)v34); // 0x31f48
                        v32 += 4;
                        *(int32_t *)v32 = v35;
                        int32_t v36; // bp-2124, 0x31d90
                        while (v34 != (int32_t)&v36) {
                            // 0x31f40
                            v34 += 4;
                            v35 = llvm_bswap_i32(*(int32_t *)v34);
                            v32 += 4;
                            *(int32_t *)v32 = v35;
                        }
                        // 0x31f54
                        function_2220c(a2, (int32_t *)(a1 + 1580), 112, (int32_t)"cgminer.c", (int32_t)"gen_stratum_work", 0x20f7);
                        function_2220c(a2 + 36, &v24, 32, (int32_t)"cgminer.c", (int32_t)"gen_stratum_work", 0x20f8);
                        uint64_t v37 = *(int64_t *)(a1 + 1824); // 0x31fa4
                        v6 = (int32_t *)(a2 + 312);
                        *v6 = (int32_t)(v37 / 0x100000000);
                        *(int32_t *)(a2 + 316) = (int32_t)v37;
                        char * v38 = __strdup((char *)*(int32_t *)(a1 + 672)); // 0x31fb4
                        v7 = (int32_t *)(a2 + 288);
                        *v7 = (int32_t)v38;
                        char * v39 = __strdup((char *)*(int32_t *)(a1 + 612)); // 0x31fc0
                        *(int32_t *)(a2 + 320) = (int32_t)v39;
                        char * v40 = __strdup((char *)(a1 + 1804)); // 0x31fd0
                        v8 = (int32_t *)(a2 + 308);
                        *v8 = (int32_t)v40;
                        if (pthread_rwlock_unlock(rwlock) == 0) {
                            // 0x31fe8
                            function_1da28();
                            if (*(char *)&g71 == 0) {
                                goto lab_0x3200c;
                            } else {
                                // 0x320bc
                                v9 = function_1e9b4(a2, 112);
                                v10 = function_1e9b4((int32_t)&v24, 32);
                                if (*(char *)&g71 == 0) {
                                    // 0x3221c
                                    free((int32_t *)v9);
                                    free((int32_t *)v10);
                                    goto lab_0x3200c;
                                } else {
                                    char v41 = *(char *)&g70; // 0x32104
                                    v1 = g28;
                                    v2 = v41;
                                    if ((v41 | *(char *)&g179) == 0 == g28 < (char *)7) {
                                        goto lab_0x32158;
                                    } else {
                                        // 0x32110
                                        snprintf((char *)&str, 2048, "Generated stratum merkle %s", (char *)v10);
                                        function_1ccec(7, &str, 0);
                                        if (*(char *)&g71 == 0) {
                                            // 0x3221c
                                            free((int32_t *)v9);
                                            free((int32_t *)v10);
                                            goto lab_0x3200c;
                                        } else {
                                            // 0x32144
                                            if (*(char *)&g179 == 0) {
                                                // 0x32144
                                                v1 = g28;
                                                v2 = *(char *)&g70;
                                                goto lab_0x32158;
                                            } else {
                                                goto lab_0x32178;
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            // 0x32328
                            v4 = 0x2103;
                            format = (int32_t)"WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d";
                            v3 = __errno_location();
                            goto lab_0x32260;
                        }
                    } else {
                        // 0x32300
                        v4 = 0x20e4;
                        format = (int32_t)"WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d";
                        v3 = __errno_location();
                        goto lab_0x32260;
                    }
                } else {
                    // 0x322d8
                    v4 = 0x20e4;
                    format = (int32_t)"WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d";
                    v3 = __errno_location();
                    goto lab_0x32260;
                }
            } else {
                // 0x322b0
                v4 = 0x20e4;
                format = (int32_t)"WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d";
                v3 = __errno_location();
                goto lab_0x32260;
            }
        } else {
            // 0x32280
            v4 = 0x20d9;
            format = (int32_t)"WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d";
            v3 = __errno_location();
            goto lab_0x32260;
        }
    } else {
        // 0x32230
        v4 = 0x20d9;
        format = (int32_t)"WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d";
        v3 = __errno_location();
        goto lab_0x32260;
    }
  lab_0x32260:;
    int32_t v42 = *v3;
    snprintf((char *)&str, 2048, (char *)format, v42, (struct timeval *)"cgminer.c", "gen_stratum_work", v4);
    function_1ccec(3, &str, 1);
    function_2ab30(1, 1);
    // UNREACHABLE
  lab_0x3200c:
    // 0x3200c
    function_2768c(a2);
    __asm_vldr(*v6);
    function_29dcc();
    g206++;
    if (time(NULL) - g128 > 5) {
        // 0x320a4
        g128 = time(NULL);
        g129 = g206;
    }
    // 0x32054
    *(char *)(a2 + 284) = 1;
    *(int32_t *)(a2 + 336) = g130;
    *(int32_t *)(a2 + 248) = 0;
    *(char *)(a2 + 280) = 0;
    *(char *)(a2 + 440) = 83;
    *(int32_t *)(a2 + 244) = 60;
    __asm_vldr(*v6);
    *(int32_t *)(a2 + 260) = a1;
    function_27498();
    return function_1f5c4((int32_t *)(a2 + 264));
  lab_0x32158:;
    char * v43 = v1; // 0x32160
    bool v44 = true; // 0x32160
    if (v1 < (char *)7 == v2 == 0) {
        goto lab_0x321c0;
    } else {
        // 0x32158
        goto lab_0x32178;
    }
  lab_0x321c0:;
    // 0x321c0
    char * str3; // 0x31d90
    if (v44 == v43 < (char *)7) {
        // 0x3221c
        free((int32_t *)v9);
        free((int32_t *)v10);
        goto lab_0x3200c;
    } else {
        // 0x321c0
        str3 = (char *)&str;
        goto lab_0x321e0;
    }
  lab_0x32178:;
    char * str2 = (char *)&str;
    snprintf(str2, 2048, "Generated stratum header %s", (char *)v9);
    function_1ccec(7, &str, 0);
    if (*(char *)&g71 == 0) {
        // 0x3221c
        free((int32_t *)v9);
        free((int32_t *)v10);
        goto lab_0x3200c;
    } else {
        // 0x321ac
        str3 = str2;
        if (*(char *)&g179 == 0) {
            // 0x321ac
            v43 = g28;
            v44 = *(char *)&g70 == 0;
            goto lab_0x321c0;
        } else {
            goto lab_0x321e0;
        }
    }
  lab_0x321e0:;
    int32_t v45 = *v8; // 0x321e8
    int32_t v46 = *v7; // 0x321f0
    int64_t v47 = *(int64_t *)v5; // 0x321f4
    snprintf(str3, 2048, "Work job_id %s nonce2 %llu ntime %s", (char *)v46, v47 >> 32, (char *)v45);
    function_1ccec(7, &str, 0);
    // 0x3221c
    free((int32_t *)v9);
    free((int32_t *)v10);
    goto lab_0x3200c;
}

// Address range: 0x32370 - 0x324c8
int32_t function_32370(int32_t a1, int32_t a2, int32_t a3, int32_t a4, uint64_t a5) {
    int32_t v1 = a3 + 212; // 0x32380
    *(int32_t *)a2 = function_2c214();
    int32_t * mutex = (int32_t *)v1; // 0x323a0
    int32_t v2; // 0x32370
    if (pthread_mutex_lock(mutex) != 0) {
        // 0x324b0
        function_2bfac(v2, 0x20bf);
        // UNREACHABLE
    }
    int32_t * rwlock = (int32_t *)(a3 + 236); // 0x323b4
    if (pthread_rwlock_wrlock(rwlock) != 0) {
        // 0x324b0
        function_2bfac(v2, 0x20bf);
        // UNREACHABLE
    }
    // 0x323c0
    int32_t v3; // 0x32370
    int32_t v4 = llvm_bswap_i32(v3); // 0x323d8
    *(int32_t *)(a3 + 624) = (int32_t)(a5 / 0x100000000);
    *(int32_t *)(a3 + 628) = (int32_t)a5;
    v3 = v4;
    function_2220c(a3 + 1580, &v3, 4, (int32_t)"cgminer.c", (int32_t)"get_work_by_nonce2", 0x20be);
    if (pthread_rwlock_unlock(rwlock) != 0) {
        // 0x324b0
        function_2bfac((int32_t)"get_work_by_nonce2", 0x20bf);
        // UNREACHABLE
    }
    // 0x32410
    if (pthread_mutex_unlock(mutex) != 0) {
        // 0x324bc
        return (int32_t)"get_work_by_nonce2";
    }
    int32_t v5 = &v3; // 0x323e8
    function_1da28();
    function_31d90(a3, v5);
    *(int32_t *)(v5 + 260) = a4;
    int32_t v6 = v3; // 0x3245c
    *(int32_t *)(v5 + 256) = v1;
    *(int32_t *)(v6 + 336) = g130;
    int32_t * v7 = (int32_t *)(*(int32_t *)(v6 + 260) + 68); // 0x32474
    *v7 = *v7 + 1;
    *(char *)(v6 + 272) = 1;
    *(int32_t *)(v6 + 444) = v6;
    return 1;
}

// Address range: 0x324cc - 0x329b0
int32_t function_324cc(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x324cc
    if (g122 == 0 != (g182 == NULL)) {
        // 0x32500
        return 0;
    }
    // 0x32524
    char * str2; // bp-2088, 0x324cc
    if (*(int32_t *)(a1 + 336) != g130) {
        unsigned char result = *(char *)&g71; // 0x32544
        if (result == 0) {
            // 0x32500
            return 1;
        }
        char v1 = *(char *)&g70; // 0x3256c
        if ((v1 | *(char *)&g179) == 0 != g28 < (char *)7) {
            // 0x3258c
            str2 = (char *)0x6b726f57;
            function_1ccec(7, (int32_t *)&str2, 0);
        }
        // 0x32500
        return result;
    }
    int32_t v2 = *(int32_t *)(a1 + 260); // 0x325d8
    int32_t v3; // bp-2096, 0x324cc
    if (a2 != 0 || *(char *)(v2 + 640) == 0) {
        // 0x326c4
        __asm_vldr(*(int32_t *)(v2 + 448));
        return &v3;
    }
    // 0x325fc
    int32_t result2; // 0x324cc
    if (*(char *)(v2 + 641) != 0) {
        // 0x32608
        if (*(char *)(v2 + 643) != 0) {
            int32_t * mutex = (int32_t *)(v2 + 212); // 0x3285c
            if (pthread_mutex_lock(mutex) != 0) {
                // 0x3292c
                function_2c5c0("stale_work", 0x1402);
                // UNREACHABLE
            }
            int32_t * rwlock = (int32_t *)(v2 + 236); // 0x32870
            if (pthread_rwlock_rdlock(rwlock) != 0) {
                // 0x3292c
                function_2c5c0("stale_work", 0x1402);
                // UNREACHABLE
            }
            // 0x3287c
            int32_t v4; // 0x324cc
            int32_t * v5; // 0x324cc
            int32_t format; // 0x324cc
            if (pthread_mutex_unlock(mutex) == 0) {
                int32_t str = *(int32_t *)(a1 + 288); // 0x32890
                int32_t strcmp_rc = strcmp((char *)str, (char *)*(int32_t *)(v2 + 672)); // 0x32894
                int32_t v6 = pthread_rwlock_unlock(rwlock);
                if (strcmp_rc == 0) {
                    if (v6 == 0) {
                        // 0x326b4
                        function_1da28();
                        // 0x326c4
                        __asm_vldr(*(int32_t *)(v2 + 448));
                        return &v3;
                    }
                } else {
                    if (v6 == 0) {
                        // 0x328b0
                        function_1da28();
                        unsigned char v7 = *(char *)&g71; // 0x328c8
                        if (v7 == 0) {
                            // 0x32500
                            return 1;
                        }
                        char v8 = *(char *)&g70; // 0x328f0
                        result2 = 1;
                        if ((v8 | *(char *)&g179) == 0 != g28 < (char *)7) {
                            // 0x32910
                            str2 = (char *)0x6b726f57;
                            function_1ccec(7, (int32_t *)&str2, 0);
                            result2 = v7;
                        }
                        // 0x32500
                        return result2;
                    }
                }
                // 0x32938
                v5 = __errno_location();
                format = (int32_t)"WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d";
                v4 = 0x1409;
            } else {
                // 0x3298c
                v5 = __errno_location();
                format = (int32_t)"WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d";
                v4 = 0x1402;
            }
            int32_t v9 = *v5; // 0x32964
            snprintf((char *)&str2, 2048, (char *)format, v9, (struct timeval *)"cgminer.c", "stale_work", v4);
            function_1ccec(3, (int32_t *)&str2, 1);
            function_2ab30(1, 1);
            // UNREACHABLE
        }
    }
    unsigned char v10 = *(char *)&g71; // 0x3261c
    if (v10 == 0) {
        // 0x32500
        return 1;
    }
    char v11 = *(char *)&g70; // 0x32644
    result2 = 1;
    if ((v11 | *(char *)&g179) == 0 != g28 < (char *)7) {
        // 0x32664
        str2 = (char *)0x6b726f57;
        function_1ccec(7, (int32_t *)&str2, 0);
        result2 = v10;
    }
    // 0x32500
    return result2;
}

// Address range: 0x329b4 - 0x32cf4
int32_t function_329b4(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11) {
    int32_t result = 0; // bp-2084, 0x329cc
    int32_t v1 = *(int32_t *)(a1 + 36); // 0x329d4
    function_27174(a1);
    int32_t v2 = a3; // 0x329e4
    int32_t v3 = 0; // 0x329e4
    if (*(char *)&g71 == 0) {
        goto lab_0x32a44;
    } else {
        // 0x329e8
        if ((*(char *)&g70 | *(char *)&g179) == 0) {
            // 0x32c94
            v2 = a3;
            v3 = (int32_t)g28;
            if (g28 < (char *)7) {
                goto lab_0x32a44;
            } else {
                goto lab_0x32a10;
            }
        } else {
            goto lab_0x32a10;
        }
    }
  lab_0x32a44:;
    int32_t time_val = time(NULL); // 0x32a4c
    int32_t v4 = v2; // 0x32a54
    int32_t v5 = v3; // 0x32a54
    while (true) {
        if (result != 0) {
            // break (via goto) -> 0x32a80
            goto lab_0x32a80;
        }
        int32_t v6 = function_313c0(1); // 0x32a58
        result = v6;
        // 0x32a70
        while (function_324cc(v6, 0, v4, v5, v6) == 0) {
            // 0x32a70
            if (result != 0) {
                // break (via goto) -> 0x32a80
                goto lab_0x32a80;
            }
            // 0x32a58
            v6 = function_313c0(1);
            result = v6;
        }
        // 0x32aec
        function_292f8(&result, "cgminer.c", "get_work", 0x21f5);
        function_2be48();
        v4 = (int32_t)"get_work";
        v5 = 0x21f5;
    }
  lab_0x32a80:;
    int32_t v7 = time(NULL) - time_val; // 0x32a88
    char v8 = *(char *)&g71; // 0x32a8c
    char v9 = v8; // 0x32a94
    char * str; // bp-2080, 0x329b4
    if (v7 < 1) {
        goto lab_0x32b44;
    } else {
        if (v8 == 0) {
            int32_t * v10 = (int32_t *)(v1 + 232); // 0x32c0c
            *v10 = *v10 + v7;
            goto lab_0x32b9c;
        } else {
            char v11 = *(char *)&g70; // 0x32abc
            if ((v11 | *(char *)&g179) != 0 || g28 > (char *)6) {
                // 0x32b0c
                snprintf((char *)&str, 2048, "Get work blocked for %ld seconds", v7);
                function_1ccec(7, (int32_t *)&str, 0);
                int32_t * v12 = (int32_t *)(v1 + 232); // 0x32b34
                *v12 = *v12 + v7;
                v9 = *(char *)&g71;
                goto lab_0x32b44;
            } else {
                int32_t * v13 = (int32_t *)(v1 + 232); // 0x32adc
                *v13 = *v13 + v7;
                goto lab_0x32b54;
            }
        }
    }
  lab_0x32b44:
    // 0x32b44
    if (v9 == 0) {
        goto lab_0x32b9c;
    } else {
        goto lab_0x32b54;
    }
  lab_0x32a10:
    // 0x32a10
    str = (char *)0x70706f50;
    function_1ccec(7, (int32_t *)&str, 0);
    v2 = 0;
    v3 = 0x67206f74;
    goto lab_0x32a44;
  lab_0x32b9c:
    // 0x32b9c
    *(int32_t *)(result + 256) = a2;
    if (g122 == 0) {
        goto lab_0x32bb8;
    } else {
        int32_t * v14 = (int32_t *)(v1 + 380); // 0x32c1c
        int32_t * v15 = (int32_t *)(v1 + 384); // 0x32c20
        int32_t v16 = *v15 + *v14; // 0x32c24
        *v14 = v16;
        int32_t v17 = v16 < 1 ? 1 : (int32_t)&g73;
        if (v16 > 0) {
            if (v16 < 16) {
                // 0x32cc4
                function_2220c(result, (int32_t *)(160 * v16 + (int32_t)&g132), 160, (int32_t)"cgminer.c", (int32_t)"set_benchmark_work", 0x21e2);
                goto lab_0x32bb8;
            } else {
                int32_t * v18 = (int32_t *)(v1 + 376); // 0x32c44
                *v15 = -1;
                int32_t v19 = *v18 + 1; // 0x32c54
                int32_t v20; // 0x329b4
                int32_t v21; // 0x329b4
                if (v19 > 15) {
                    *v18 = 0;
                    v21 = 0;
                    v20 = v17 + 1456;
                } else {
                    *v18 = v19;
                    v21 = v17 + 1456;
                    v20 = 5 * v19;
                }
                int32_t v22 = v20;
                int32_t v23 = v19 > 15 ? v22 : 32 * v22 + v21;
                function_2220c(result, (int32_t *)v23, 160, (int32_t)"cgminer.c", (int32_t)"set_benchmark_work", 0x21de);
                goto lab_0x32bb8;
            }
        } else {
            // .thread
            *v15 = v17;
            // 0x32cc4
            function_2220c(result, (int32_t *)(160 * v16 + (int32_t)&g132), 160, (int32_t)"cgminer.c", (int32_t)"set_benchmark_work", 0x21e2);
            goto lab_0x32bb8;
        }
    }
  lab_0x32b54:;
    char v24 = *(char *)&g70; // 0x32b68
    if ((v24 | *(char *)&g179) == 0 != g28 < (char *)7) {
        // 0x32b74
        snprintf((char *)&str, 2048, "Got work from get queue to get work for thread %d", a2);
        function_1ccec(7, (int32_t *)&str, 0);
    }
    goto lab_0x32b9c;
  lab_0x32bb8:
    // 0x32bb8
    function_271ac(a1);
    *(char *)(result + 272) = 1;
    __asm_vldr(*(int32_t *)(result + 376));
    __asm_vldr(*(int32_t *)(*(int32_t *)(v1 + 4) + 104));
    return result;
}

// Address range: 0x32d00 - 0x32d28
int32_t function_32d00(int32_t a1, int32_t a2, int32_t a3) {
    // 0x32d00
    int32_t v1; // 0x32d00
    int32_t result = function_329b4(a1, a3, a3, v1, v1, v1, v1, v1, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306); // 0x32d0c
    function_2c320(a2, result);
    return result;
}

// Address range: 0x32d28 - 0x32da4
int32_t function_32d28(int32_t a1) {
    int32_t * v1 = (int32_t *)(a1 + 356); // 0x32d28
    int32_t v2 = *v1; // 0x32d28
    if (v2 == 0) {
        // 0x32d7c
        return 0;
    }
    int32_t result = v2; // bp-12, 0x32d48
    int32_t v3; // 0x32d28
    if (function_324cc(v2, 0, v3, v2, v2) == 0) {
        // 0x32d58
        function_2a4b4();
    } else {
        // 0x32d84
        function_292f8(&result, "cgminer.c", "__get_queued", 0x24f9);
        function_2be48();
    }
    // 0x32d64
    *v1 = 0;
    return result;
}

// Address range: 0x32da8 - 0x32e10
int32_t function_32da8(int32_t a1) {
    int32_t * rwlock = (int32_t *)(a1 + 320); // 0x32db8
    if (pthread_rwlock_wrlock(rwlock) != 0) {
        // 0x32e04
        return function_2bfac((int32_t)"get_queued", 0x2510);
    }
    int32_t result = function_32d28(a1); // 0x32dc8
    if (pthread_rwlock_unlock(rwlock) != 0) {
        // 0x32e04
        return function_2bfac((int32_t)"get_queued", 0x2510);
    }
    // 0x32de0
    function_1da28();
    return result;
}

// Address range: 0x32e14 - 0x33124
int32_t function_32e14(void) {
    // 0x32e14
    int32_t str; // bp-2080, 0x32e14
    if (pthread_mutex_lock((int32_t *)g100) != 0) {
        int32_t v1 = *__errno_location(); // 0x330dc
        snprintf((char *)&str, 2048, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", v1, "cgminer.c", "discard_stale", 0x1523);
        function_1ccec(3, &str, 1);
        function_2ab30(1, 1);
        // UNREACHABLE
    }
    int32_t v2 = g119; // 0x32e38
    int32_t v3 = v2; // bp-2084, 0x32e40
    if (v2 == 0) {
        // 0x3307c
        pthread_cond_signal(&g190);
        if (pthread_mutex_unlock((int32_t *)g100) != 0) {
            function_33128();
        }
        // 0x33098
        return function_1da28();
    }
    // 0x32e48
    int32_t v4; // 0x32e14
    int32_t v5 = function_324cc(v2, 0, v4, v4, v2); // 0x32e50
    v3 = v2;
    int32_t v6 = 0; // 0x32e5c
    int32_t v7 = *(int32_t *)(v2 + 352); // 0x32e5c
    int32_t v8 = 0; // 0x32e5c
    if (v5 == 0) {
        goto lab_0x32f4c;
    } else {
        goto lab_0x32e60_2;
    }
  lab_0x32f4c:
    // 0x32f4c
    v6 = v8;
    int32_t v9 = v7;
    v3 = v9;
    int32_t v10; // 0x32e14
    int32_t v11; // 0x32e14
    while (v9 != 0) {
        // 0x32f58
        v7 = *(int32_t *)(v9 + 352);
        int32_t v12 = v7; // 0x32f6c
        if (function_324cc(v9, 0, v10, v11, v9) != 0) {
            // 0x32e60
            goto lab_0x32e60_2;
        }
        v9 = v12;
        v3 = v9;
    }
    // 0x32fc4
    pthread_cond_signal(&g190);
    if (pthread_mutex_unlock((int32_t *)g100) != 0) {
        function_33128();
    }
    int32_t result = function_1da28(); // 0x32fec
    if (v6 == 0 | *(char *)&g71 == 0) {
        // 0x33070
        return result;
    }
    char v13 = *(char *)&g70; // 0x33028
    int32_t result2 = result; // 0x3301c
    if ((v13 | *(char *)&g179) == 0 != g28 < (char *)7) {
        // 0x33048
        snprintf((char *)&str, 2048, "Discarded %d stales that didn't match current hash", v6);
        result2 = function_1ccec(7, &str, 0);
    }
    // 0x33070
    return result2;
  lab_0x32e60_2:;
    int32_t v14 = v3; // 0x32e60
    int32_t v15 = g119; // 0x32e64
    int32_t * v16 = (int32_t *)(v14 + 348); // 0x32e68
    int32_t v17 = *v16; // 0x32e68
    int32_t * v18 = (int32_t *)(v15 + 344);
    int32_t v19 = *v18; // 0x32e6c
    int32_t v20; // 0x32e14
    int32_t * v21; // 0x32e14
    int32_t * v22; // 0x32e14
    int32_t v23; // 0x32e14
    int32_t v24; // 0x32e14
    int32_t v25; // 0x32e14
    int32_t v26; // 0x32e14
    int32_t v27; // 0x32e14
    int32_t v28; // 0x32e14
    int32_t v29; // 0x32e14
    int32_t v30; // 0x32e14
    if (v17 == 0) {
        int32_t v31 = *(int32_t *)(v14 + 352); // 0x32f74
        if (v31 == 0) {
            // 0x330b4
            free((int32_t *)*(int32_t *)v19);
            free((int32_t *)*(int32_t *)(g119 + 344));
            g119 = 0;
            goto lab_0x32f30;
        } else {
            int32_t v32 = *(int32_t *)(v19 + 20); // 0x32f80
            int32_t v33 = v14 + 344; // 0x32f84
            int32_t * v34 = (int32_t *)(v19 + 16);
            v21 = v34;
            v28 = v32;
            v25 = v33;
            if (v14 == *v34 - v32) {
                goto lab_0x32fa4;
            } else {
                g119 = v31;
                int32_t * v35 = (int32_t *)(v31 + 344); // 0x32ea0
                v20 = *v35;
                v26 = v31;
                v29 = v31;
                v24 = v33;
                v22 = v35;
                goto lab__thread19;
            }
        }
    } else {
        int32_t v36 = *(int32_t *)(v19 + 20); // 0x32e78
        int32_t v37 = v14 + 344; // 0x32e7c
        int32_t * v38 = (int32_t *)(v19 + 16);
        v27 = v36;
        v30 = v17;
        v23 = v37;
        v21 = v38;
        v28 = v36;
        v25 = v37;
        if (v14 == *v38 - v36) {
            goto lab_0x32fa4;
        } else {
            goto lab_0x32ea0;
        }
    }
  lab_0x32fa4:
    // 0x32fa4
    *v21 = v28 + v17;
    int32_t v39 = *v16; // 0x32fac
    result2 = v19;
    if (v39 == 0) {
        // 0x33070
        return result2;
    }
    // 0x32fb8
    v27 = *(int32_t *)(*v18 + 20);
    v30 = v39;
    v23 = v25;
    goto lab_0x32ea0;
  lab_0x32ea0:;
    int32_t * v40 = (int32_t *)(v14 + 352); // 0x32e90
    *(int32_t *)(v27 + 8 + v30) = *v40;
    int32_t v41 = *v40; // 0x32e9c
    int32_t v42 = *v18; // 0x32ea0
    v20 = v42;
    v26 = v15;
    v29 = v41;
    v24 = v23;
    v22 = v18;
    int32_t * v43 = v18; // 0x32ea8
    int32_t v44 = v23; // 0x32ea8
    int32_t v45 = v15; // 0x32ea8
    int32_t v46 = v42; // 0x32ea8
    if (v41 == 0) {
        goto lab__critedge;
    } else {
        goto lab__thread19;
    }
  lab_0x32f30:
    // 0x32f30
    function_292f8(&v3, "cgminer.c", "discard_stale", 0x152a);
    v10 = (int32_t)"discard_stale";
    v11 = 0x152a;
    v8 = v6 + 1;
    goto lab_0x32f4c;
  lab__critedge:;
    int32_t v47 = 12 * (*(int32_t *)(v46 + 4) - 1 & *(int32_t *)(v14 + 372)); // 0x32ed4
    int32_t * v48 = (int32_t *)(*(int32_t *)v46 + 4 + v47); // 0x32ed8
    *v48 = *v48 - 1;
    int32_t * v49 = (int32_t *)(*(int32_t *)*v43 + v47); // 0x32eec
    int32_t v50 = *v49; // 0x32eec
    int32_t * v51 = (int32_t *)(v14 + 360);
    int32_t v52 = v45; // 0x32ef4
    if (v50 == v44) {
        int32_t v53 = *v51; // 0x32ef4
        *v49 = v53;
        v52 = v53;
    }
    int32_t * v54 = (int32_t *)(v14 + 356); // 0x32efc
    int32_t v55 = *v54; // 0x32efc
    int32_t v56 = *v51; // 0x32f00
    int32_t v57 = v56; // 0x32f0c
    if (v55 != 0) {
        *(int32_t *)(v55 + 16) = v56;
        v57 = *v51;
    }
    int32_t v58 = v57;
    if (v58 != 0) {
        *(int32_t *)(v58 + 12) = *v54;
    }
    int32_t v59 = v50 == v44 ? g119 : v52;
    int32_t * v60 = (int32_t *)(*(int32_t *)(v59 + 344) + 12); // 0x32f24
    *v60 = *v60 - 1;
    goto lab_0x32f30;
  lab__thread19:
    // .thread19
    *(int32_t *)(v29 + 4 + *(int32_t *)(v20 + 20)) = *v16;
    v43 = v22;
    v44 = v24;
    v45 = v26;
    v46 = *v22;
    goto lab__critedge;
}

// Address range: 0x33128 - 0x33158
int32_t function_33128(void) {
    // 0x33128
    __errno_location();
    int32_t v1; // bp+24, 0x33128
    return &v1;
}

// Address range: 0x3315c - 0x332c8
int32_t function_3315c(void) {
    // 0x3315c
    pthread_detach(pthread_self());
    function_32e14();
    if (pthread_rwlock_rdlock(&g222) != 0) {
        // 0x332a4
        function_2c5c0("restart_thread", 0x1565);
        // UNREACHABLE
    }
    // 0x33180
    if (pthread_rwlock_unlock(&g222) != 0) {
        // 0x332b0
        function_2bfac((int32_t)"restart_thread", 0x1567);
        // UNREACHABLE
    }
    // 0x331a0
    function_1da28();
    int32_t v1 = 0; // 0x331b4
    if (g261 >= 1) {
        int32_t v2 = *(int32_t *)(g208 + 4 * v1); // 0x331d0
        int32_t v3 = *(int32_t *)(v2 + 36); // 0x331d4
        if (v3 != 0) {
            // 0x331e0
            if (*(int32_t *)(v3 + 32) == 0) {
                // 0x331ec
                *(char *)(v2 + 62) = 1;
                function_2f0b8(v3);
                if (pthread_mutex_lock(&g235) != 0 || pthread_mutex_unlock(&g235) != 0) {
                    // 0x332a4
                    function_2c5c0("restart_thread", 0x1565);
                    // UNREACHABLE
                }
                // 0x33228
                function_1da28();
            }
        }
        // 0x33230
        v1++;
        while (g261 != v1) {
            // 0x331cc
            v2 = *(int32_t *)(g208 + 4 * v1);
            v3 = *(int32_t *)(v2 + 36);
            if (v3 != 0) {
                // 0x331e0
                if (*(int32_t *)(v3 + 32) == 0) {
                    // 0x331ec
                    *(char *)(v2 + 62) = 1;
                    function_2f0b8(v3);
                    if (pthread_mutex_lock(&g235) != 0 || pthread_mutex_unlock(&g235) != 0) {
                        // 0x332a4
                        function_2c5c0("restart_thread", 0x1565);
                        // UNREACHABLE
                    }
                    // 0x33228
                    function_1da28();
                }
            }
            // 0x33230
            v1++;
        }
    }
    // 0x3323c
    if (pthread_mutex_lock(&g218) != 0) {
        // 0x332a4
        function_2c5c0("restart_thread", 0x1565);
        // UNREACHABLE
    }
    // 0x33250
    pthread_cond_broadcast(&g252);
    if (pthread_mutex_unlock(&g218) != 0) {
        // 0x332bc
        return (int32_t)"restart_thread";
    }
    // 0x33270
    function_1da28();
    return 0;
}

// Address range: 0x332cc - 0x36458
int32_t function_332cc(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11, int32_t a12, int32_t a13, int32_t a14, int32_t a15, int32_t a16, int32_t a17, int32_t a18, int32_t a19, int32_t a20, int32_t a21, int32_t a22, int32_t a23, int32_t a24, int32_t a25, int32_t a26, int32_t a27, int32_t a28, int32_t a29, int32_t a30, int32_t a31, int32_t a32) {
    // 0x332cc
    float64_t v1; // 0x332cc
    __asm_vpush_16(v1, v1, v1, v1, v1, v1);
    int32_t v2; // bp-2152, 0x332cc
    if (sysinfo((struct sysinfo *)&v2) == 0) {
        // 0x33384
        g256 = v2;
        function_1f5c4(&g102);
        return function_1f8ec((int32_t)&g102, &g116);
    }
    char v3 = *(char *)&g70; // 0x33310
    if ((v3 | *(char *)&g179) == 0 != g28 < (char *)6) {
        int32_t err_num = *__errno_location(); // 0x33320
        char * err_str = strerror(err_num); // 0x3332c
        int32_t str; // bp-2088, 0x332cc
        snprintf((char *)&str, 2048, "Failed to get sysinfo, errno:%u, reason:%s\n", err_num, err_str);
        function_1ccec(6, &str, 0);
    }
    // 0x33384
    g256 = time(NULL);
    function_1f5c4(&g102);
    return function_1f8ec((int32_t)&g102, &g116);
}

// Address range: 0x36458 - 0x37db0
int32_t function_36458(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x36458
    float64_t v1; // 0x36458
    float64_t v2 = __asm_vpush_9(v1); // 0x36460
    int32_t * v3 = (int32_t *)(a1 + 260); // 0x3646c
    int32_t v4 = *v3; // 0x3646c
    unsigned char v5 = *(char *)(a1 + 282); // 0x36470
    int32_t v6 = 0; // bp-2192, 0x36474
    int32_t v7 = *(int32_t *)(v4 + 1568); // 0x36478
    char * v8 = (char *)(int32_t)v5; // 0x36484
    unsigned char v9 = *(char *)(v7 + 42); // 0x36488
    char * v10 = v8; // 0x3648c
    if (v5 != 0) {
      lab_0x36490:
        // 0x36490
        __asm_vpop(v2);
        return (int32_t)v10;
    }
    int32_t str3 = (int32_t)*(int64_t *)(a1 + 28); // bp-2188, 0x364b8
    int32_t str; // bp-2156, 0x36458
    function_1e944(&str, (int32_t)&str3, 32);
    if (v9 == 4 || v9 < 4) {
        // 0x369b0
        function_2220c((int32_t)&v6, (int32_t *)(v7 + 43), (int32_t)v9, (int32_t)"cgminer.c", (int32_t)"test_work_current", 0x1632);
        v6--;
    }
    int32_t * mutex = (int32_t *)(v4 + 212); // 0x36508
    int32_t * v11; // 0x36458
    int32_t v12; // 0x36458
    int32_t v13; // 0x36458
    int32_t v14; // 0x36458
    int32_t v15; // 0x36458
    int32_t v16; // 0x36458
    int32_t v17; // 0x36458
    int32_t v18; // 0x36458
    int32_t v19; // 0x36458
    int32_t v20; // 0x36458
    int32_t v21; // 0x36458
    int32_t v22; // 0x36458
    int32_t v23; // 0x36458
    int32_t v24; // 0x36458
    int32_t v25; // 0x36458
    int32_t format; // 0x36458
    int32_t v26; // 0x36458
    int32_t v27; // 0x36458
    int32_t v28; // 0x36458
    int32_t v29; // 0x36458
    int32_t v30; // 0x36458
    int32_t v31; // 0x36458
    int32_t * v32; // 0x36458
    int32_t v33; // 0x36458
    int32_t v34; // 0x36458
    int32_t v35; // 0x36458
    int32_t v36; // 0x36458
    int32_t v37; // 0x36458
    int32_t v38; // 0x36458
    int32_t v39; // 0x36458
    int32_t v40; // 0x36458
    int32_t v41; // 0x36458
    int32_t v42; // 0x36458
    int32_t v43; // 0x36458
    int32_t v44; // 0x36458
    int32_t v45; // 0x36458
    int32_t v46; // 0x36458
    char * str4; // bp-2088, 0x36458
    char * v47; // 0x36458
    int32_t v48; // 0x36458
    char * v49; // 0x36458
    int32_t v50; // 0x36458
    int32_t * v51; // 0x36458
    int32_t v52; // 0x36458
    int32_t v53; // 0x36bf0
    int32_t * v54; // 0x36bf8
    int32_t v55; // 0x36bf8
    int32_t v56; // 0x36a04
    char * str5; // 0x36a1c
    int32_t * v57; // 0x36a4c
    if (pthread_mutex_lock(mutex) == 0) {
        int32_t * rwlock = (int32_t *)(v4 + 236); // 0x36520
        if (pthread_rwlock_wrlock(rwlock) == 0) {
            char * v58 = (char *)(v4 + 680); // 0x36530
            if (*v58 != 0) {
                *v58 = 0;
                *(char *)(a1 + 280) = 1;
            }
            // .critedge
            if (pthread_rwlock_unlock(rwlock) == 0) {
                // 0x36554
                if (pthread_mutex_unlock(mutex) == 0) {
                    // 0x36564
                    function_1da28();
                    if (pthread_rwlock_wrlock((int32_t *)((int32_t)&g133 - 8)) == 0) {
                        int32_t len = strlen((char *)&str); // 0x36598
                        int32_t v59; // 0x36458
                        int32_t v60; // 0x36458
                        int32_t v61; // 0x36458
                        int32_t v62; // 0x36458
                        int32_t v63; // 0x36458
                        if (len == 11 || len < 11) {
                            // 0x37434
                            v60 = -0x61c88647;
                            v61 = -0x1124111;
                            v62 = &str;
                            v63 = -0x61c88647;
                            v59 = len;
                        } else {
                            int32_t v64 = len; // 0x365bc
                            int32_t v65; // bp-2144, 0x36458
                            int32_t v66 = &v65;
                            unsigned char v67 = *(char *)(v66 - 6); // 0x365c0
                            v64 -= 12;
                            unsigned char v68 = *(char *)(v66 - 2); // 0x365c8
                            unsigned char v69 = *(char *)(v66 - 10); // 0x365d0
                            unsigned char v70 = *(char *)(v66 - 7); // 0x365d4
                            unsigned char v71 = *(char *)(v66 - 3); // 0x365d8
                            unsigned char v72 = *(char *)(v66 - 11); // 0x365e0
                            unsigned char v73 = *(char *)(v66 - 5); // 0x365ec
                            unsigned char v74 = *(char *)(v66 - 8); // 0x365f4
                            unsigned char v75 = *(char *)(v66 - 12); // 0x365fc
                            unsigned char v76 = *(char *)(v66 - 4); // 0x36604
                            unsigned char v77 = *(char *)(v66 - 9); // 0x3660c
                            unsigned char v78 = *(char *)(v66 - 1); // 0x36614
                            int32_t v79 = (256 * (int32_t)v70 | 0x10000 * (int32_t)v67 | (int32_t)v74 | 0x1000000 * (int32_t)v73) - 0x61c88647; // 0x36624
                            uint32_t v80 = (256 * (int32_t)v71 | 0x10000 * (int32_t)v68 | (int32_t)v76 | 0x1000000 * (int32_t)v78) - 0x1124111; // 0x36634
                            int32_t v81 = -0x61c88647 - v79 + (256 * (int32_t)v72 | 0x10000 * (int32_t)v69 | (int32_t)v75 | 0x1000000 * (int32_t)v77) - v80 ^ v80 / 0x2000; // 0x36648
                            uint32_t v82 = v79 - v80 - v81 ^ 256 * v81; // 0x36654
                            uint32_t v83 = v80 - v81 - v82 ^ v82 / 0x2000; // 0x36660
                            int32_t v84 = v81 - v82 - v83 ^ v83 / 0x1000; // 0x3666c
                            uint32_t v85 = v82 - v83 - v84 ^ 0x10000 * v84; // 0x36678
                            uint32_t v86 = v83 - v84 - v85 ^ v85 / 32; // 0x36684
                            int32_t v87 = v84 - v85 - v86 ^ v86 / 8; // 0x36690
                            int32_t v88 = v85 - v86 - v87 ^ 1024 * v87; // 0x3669c
                            int32_t v89 = v86 - v87 - v88 ^ v88 / 0x8000; // 0x366a4
                            int32_t v90 = v66 + 12; // 0x366a8
                            v60 = v87;
                            v61 = v89;
                            v62 = v66;
                            v63 = v88;
                            v59 = v64;
                            while ((v88 & 0x4000) != 0 == (v64 != 11)) {
                                // 0x365c0
                                v66 = v90;
                                v67 = *(char *)(v66 - 6);
                                v64 -= 12;
                                v68 = *(char *)(v66 - 2);
                                v69 = *(char *)(v66 - 10);
                                v70 = *(char *)(v66 - 7);
                                v71 = *(char *)(v66 - 3);
                                v72 = *(char *)(v66 - 11);
                                v73 = *(char *)(v66 - 5);
                                v74 = *(char *)(v66 - 8);
                                v75 = *(char *)(v66 - 12);
                                v76 = *(char *)(v66 - 4);
                                v77 = *(char *)(v66 - 9);
                                v78 = *(char *)(v66 - 1);
                                v79 = (256 * (int32_t)v70 | 0x10000 * (int32_t)v67 | (int32_t)v74 | 0x1000000 * (int32_t)v73) + v88;
                                v80 = (256 * (int32_t)v71 | 0x10000 * (int32_t)v68 | (int32_t)v76 | 0x1000000 * (int32_t)v78) + v89;
                                v81 = v87 - v79 + (256 * (int32_t)v72 | 0x10000 * (int32_t)v69 | (int32_t)v75 | 0x1000000 * (int32_t)v77) - v80 ^ v80 / 0x2000;
                                v82 = v79 - v80 - v81 ^ 256 * v81;
                                v83 = v80 - v81 - v82 ^ v82 / 0x2000;
                                v84 = v81 - v82 - v83 ^ v83 / 0x1000;
                                v85 = v82 - v83 - v84 ^ 0x10000 * v84;
                                v86 = v83 - v84 - v85 ^ v85 / 32;
                                v87 = v84 - v85 - v86 ^ v86 / 8;
                                v88 = v85 - v86 - v87 ^ 1024 * v87;
                                v89 = v86 - v87 - v88 ^ v88 / 0x8000;
                                v90 = v66 + 12;
                                v60 = v87;
                                v61 = v89;
                                v62 = v66;
                                v63 = v88;
                                v59 = v64;
                            }
                        }
                        int32_t v91 = v61 + len; // 0x366b0
                        g310 = v59 - 1;
                        int32_t v92 = v91; // 0x366b8
                        int32_t v93 = v91; // 0x366b8
                        int32_t v94 = v91; // 0x366b8
                        int32_t v95 = v91; // 0x366b8
                        int32_t v96 = v63; // 0x366b8
                        int32_t v97 = v91; // 0x366b8
                        int32_t v98 = v63; // 0x366b8
                        int32_t v99 = v91; // 0x366b8
                        int32_t v100 = v63; // 0x366b8
                        int32_t v101 = v91; // 0x366b8
                        int32_t v102 = v63; // 0x366b8
                        int32_t v103 = v60; // 0x366b8
                        int32_t v104 = v91; // 0x366b8
                        int32_t v105 = v63; // 0x366b8
                        int32_t v106 = v60; // 0x366b8
                        int32_t v107 = v91; // 0x366b8
                        int32_t v108 = v63; // 0x366b8
                        int32_t v109 = v60; // 0x366b8
                        int32_t v110 = v91; // 0x366b8
                        int32_t v111 = v63; // 0x366b8
                        int32_t v112 = v60; // 0x366b8
                        int32_t v113 = v91; // 0x366b8
                        int32_t v114 = v63; // 0x366b8
                        switch (v59) {
                            case 11: {
                                // 0x366ec
                                v92 = 0x1000000 * (int32_t)*(char *)(v62 + 10) + v91;
                            }
                            case 10: {
                                // 0x366f4
                                v93 = 0x10000 * (int32_t)*(char *)(v62 + 9) + v92;
                            }
                            case 9: {
                                // 0x366fc
                                v94 = 256 * (int32_t)*(char *)(v62 + 8) + v93;
                            }
                            case 8: {
                                // 0x36704
                                v95 = v94;
                                v96 = 0x1000000 * (int32_t)*(char *)(v62 + 7) + v63;
                            }
                            case 7: {
                                // 0x3670c
                                v97 = v95;
                                v98 = 0x10000 * (int32_t)*(char *)(v62 + 6) + v96;
                            }
                            case 6: {
                                // 0x36714
                                v99 = v97;
                                v100 = 256 * (int32_t)*(char *)(v62 + 5) + v98;
                            }
                            case 5: {
                                // 0x3671c
                                v101 = v99;
                                v102 = v100 + (int32_t)*(char *)(v62 + 4);
                            }
                            case 4: {
                                // 0x36724
                                v104 = v101;
                                v103 = 0x1000000 * (int32_t)*(char *)(v62 + 3) + v60;
                                v105 = v102;
                            }
                            case 3: {
                                // 0x3672c
                                v107 = v104;
                                v106 = 0x10000 * (int32_t)*(char *)(v62 + 2) + v103;
                                v108 = v105;
                            }
                            case 2: {
                                // 0x36734
                                v110 = v107;
                                v109 = 256 * (int32_t)*(char *)(v62 + 1) + v106;
                                v111 = v108;
                            }
                            case 1: {
                                // 0x3673c
                                v113 = v110;
                                v112 = v109 + (int32_t)*(char *)v62;
                                v114 = v111;
                                // break -> 0x36744
                                break;
                            }
                        }
                        int32_t v115 = g134; // 0x3675c
                        if (v115 != 0) {
                            uint32_t v116 = v113;
                            int32_t v117 = v112 - v116 - v114 ^ v116 / 0x2000; // 0x36754
                            uint32_t v118 = v114 - v116 - v117 ^ 256 * v117; // 0x36768
                            uint32_t v119 = v116 - v117 - v118 ^ v118 / 0x2000; // 0x3677c
                            int32_t v120 = v117 - v118 - v119 ^ v119 / 0x1000; // 0x36788
                            uint32_t v121 = v118 - v119 - v120 ^ 0x10000 * v120; // 0x36794
                            uint32_t v122 = v119 - v120 - v121 ^ v121 / 32; // 0x367a0
                            int32_t v123 = v120 - v121 - v122 ^ v122 / 8; // 0x367ac
                            uint32_t v124 = v121 - v122 - v123 ^ 1024 * v123; // 0x367b8
                            int32_t v125 = v122 - v123 - v124 ^ v124 / 0x8000; // 0x367c0
                            int32_t v126 = *(int32_t *)(v115 + 68); // 0x367c8
                            int32_t v127 = *(int32_t *)(v126 + 4); // 0x367cc
                            int32_t v128 = *(int32_t *)(12 * (v127 - 1 & v125) + *(int32_t *)v126); // 0x367dc
                            if (v128 != 0) {
                                int32_t v129 = *(int32_t *)(v126 + 20); // 0x367e8
                                int32_t v130 = v128 - v129; // 0x367f0
                                if (v130 != 0) {
                                    int32_t v131; // 0x36458
                                    int32_t str2; // 0x3685c
                                    int32_t memcmp_rc; // 0x36874
                                    int32_t v132; // 0x37954
                                    char v133; // 0x37464
                                    int32_t v134; // 0x3749c
                                    char v135; // 0x368d0
                                    int32_t v136; // 0x37bd4
                                    if (v125 == *(int32_t *)(v130 + 96)) {
                                        // 0x3681c
                                        if (len == *(int32_t *)(v130 + 92)) {
                                            // 0x36828
                                            if (memcmp((int32_t *)*(int32_t *)(v130 + 88), &str, len) == 0) {
                                                // 0x36840
                                                if (pthread_rwlock_unlock((int32_t *)((int32_t)&g133 - 8)) == 0) {
                                                    // 0x36854
                                                    str2 = v4 + 544;
                                                    memcmp_rc = memcmp((int32_t *)str2, &str3, 32);
                                                    v131 = memcmp_rc == 0 ? 1 : (int32_t)&g2;
                                                    v47 = (char *)v131;
                                                    if (memcmp_rc == 0) {
                                                        goto lab_0x368f8;
                                                    } else {
                                                        // 0x36888
                                                        if (memcmp(&str3, &g135, 32) == 0) {
                                                            // 0x37448
                                                            v133 = *(char *)&g70;
                                                            if ((v133 | *(char *)&g179) == 0 == g28 < (char *)6) {
                                                                // 0x374b8
                                                                function_2220c(str2, &str3, 32, (int32_t)"cgminer.c", (int32_t)"test_work_current", 0x1679);
                                                                v47 = (char *)1;
                                                                goto lab_0x368f8;
                                                            } else {
                                                                // 0x37484
                                                                v134 = *(int32_t *)v4;
                                                                snprintf((char *)&str4, 2048, "Pool %d now up to date at height %d", v134, v6);
                                                                function_1ccec(6, (int32_t *)&str4, 0);
                                                                // 0x374b8
                                                                function_2220c(str2, &str3, 32, (int32_t)"cgminer.c", (int32_t)"test_work_current", 0x1679);
                                                                v47 = (char *)1;
                                                                goto lab_0x368f8;
                                                            }
                                                        } else {
                                                            // 0x368a0
                                                            v47 = NULL;
                                                            if (*(char *)&g71 == 0) {
                                                                goto lab_0x368f8;
                                                            } else {
                                                                // 0x368b4
                                                                v135 = *(char *)&g70;
                                                                v47 = NULL;
                                                                if ((v135 | *(char *)&g179) != 0 || g28 > (char *)6) {
                                                                    // 0x37bbc
                                                                    v136 = *(int32_t *)v4;
                                                                    snprintf((char *)&str4, 2048, "Stale data from pool %d at height %d", v136, v6);
                                                                    function_1ccec(7, (int32_t *)&str4, 0);
                                                                    v47 = v8;
                                                                    goto lab_0x368f8;
                                                                } else {
                                                                    goto lab_0x368f8;
                                                                }
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    // 0x37948
                                                    v132 = *__errno_location();
                                                    snprintf((char *)&str4, 2048, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", v132, "block_exists", (char *)0x160e);
                                                    goto lab_0x376f4;
                                                }
                                            }
                                        }
                                    }
                                    int32_t v137 = *(int32_t *)(v130 + 84); // 0x367fc
                                    while (v137 != 0) {
                                        int32_t v138 = v137 - v129; // 0x36808
                                        if (v138 == 0) {
                                            // break -> 0x369e8
                                            break;
                                        }
                                        int32_t v139 = v138;
                                        if (v125 == *(int32_t *)(v139 + 96)) {
                                            // 0x3681c
                                            if (len == *(int32_t *)(v139 + 92)) {
                                                // 0x36828
                                                if (memcmp((int32_t *)*(int32_t *)(v139 + 88), &str, len) == 0) {
                                                    // 0x36840
                                                    if (pthread_rwlock_unlock((int32_t *)((int32_t)&g133 - 8)) == 0) {
                                                        // 0x36854
                                                        str2 = v4 + 544;
                                                        memcmp_rc = memcmp((int32_t *)str2, &str3, 32);
                                                        v131 = memcmp_rc == 0 ? 1 : (int32_t)&g2;
                                                        v47 = (char *)v131;
                                                        if (memcmp_rc == 0) {
                                                            goto lab_0x368f8;
                                                        } else {
                                                            // 0x36888
                                                            if (memcmp(&str3, &g135, 32) == 0) {
                                                                // 0x37448
                                                                v133 = *(char *)&g70;
                                                                if ((v133 | *(char *)&g179) == 0 == g28 < (char *)6) {
                                                                    // 0x374b8
                                                                    function_2220c(str2, &str3, 32, (int32_t)"cgminer.c", (int32_t)"test_work_current", 0x1679);
                                                                    v47 = (char *)1;
                                                                    goto lab_0x368f8;
                                                                } else {
                                                                    // 0x37484
                                                                    v134 = *(int32_t *)v4;
                                                                    snprintf((char *)&str4, 2048, "Pool %d now up to date at height %d", v134, v6);
                                                                    function_1ccec(6, (int32_t *)&str4, 0);
                                                                    // 0x374b8
                                                                    function_2220c(str2, &str3, 32, (int32_t)"cgminer.c", (int32_t)"test_work_current", 0x1679);
                                                                    v47 = (char *)1;
                                                                    goto lab_0x368f8;
                                                                }
                                                            } else {
                                                                // 0x368a0
                                                                v47 = NULL;
                                                                if (*(char *)&g71 == 0) {
                                                                    goto lab_0x368f8;
                                                                } else {
                                                                    // 0x368b4
                                                                    v135 = *(char *)&g70;
                                                                    v47 = NULL;
                                                                    if ((v135 | *(char *)&g179) != 0 || g28 > (char *)6) {
                                                                        // 0x37bbc
                                                                        v136 = *(int32_t *)v4;
                                                                        snprintf((char *)&str4, 2048, "Stale data from pool %d at height %d", v136, v6);
                                                                        function_1ccec(7, (int32_t *)&str4, 0);
                                                                        v47 = v8;
                                                                        goto lab_0x368f8;
                                                                    } else {
                                                                        goto lab_0x368f8;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    } else {
                                                        // 0x37948
                                                        v132 = *__errno_location();
                                                        snprintf((char *)&str4, 2048, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", v132, "block_exists", (char *)0x160e);
                                                        goto lab_0x376f4;
                                                    }
                                                }
                                            }
                                        }
                                        // 0x367fc
                                        v137 = *(int32_t *)(v139 + 84);
                                    }
                                }
                            }
                        }
                        // 0x369e8
                        v56 = function_1e7d4(104, 1, "cgminer.c", "block_exists", 0x15ec);
                        if (v56 == 0) {
                            // 0x37bf4
                            str4 = (char *)0x636f6c62;
                            function_1ccec(3, (int32_t *)&str4, 1);
                            function_2ab30(1, 1);
                            // UNREACHABLE
                        }
                        // 0x36a10
                        str5 = (char *)v56;
                        strcpy(str5, (char *)&str);
                        int32_t v140 = g134; // 0x36a30
                        *(int32_t *)(v56 + 100) = g257;
                        g257++;
                        v39 = 0;
                        if (v140 == 0) {
                            goto lab_0x36cd4;
                        } else {
                            int32_t v141 = v140 + 68; // 0x36a4c
                            v57 = (int32_t *)v141;
                            uint32_t v142 = *(int32_t *)(*v57 + 12); // 0x36a50
                            v39 = v140;
                            if (v142 == 3 || v142 < 3) {
                                goto lab_0x36cd4;
                            } else {
                                int32_t v143 = 1;
                                int32_t v144 = 0; // 0x36a70
                                int32_t v145 = v141; // 0x36a70
                                int32_t v146 = 0x4130; // 0x36a70
                                int32_t v147 = 0; // 0x36a70
                                int32_t v148 = 0; // 0x36a70
                                int32_t v149; // 0x36458
                                int32_t v150; // 0x36458
                                int32_t v151; // 0x36458
                                int32_t v152; // 0x36458
                                int32_t v153; // 0x36458
                                int32_t v154; // 0x36458
                                int32_t v155; // 0x36458
                                int32_t v156; // 0x36458
                                int32_t v157; // 0x36a78
                                int32_t v158; // 0x36a80
                                int32_t v159; // 0x36a90
                                int32_t v160; // 0x36a94
                                int32_t v161; // 0x36aa4
                                int32_t v162; // 0x36aa8
                                int32_t v163; // 0x36ab4
                                while (true) {
                                    // 0x36a74
                                    v153 = v145;
                                    v149 = v144;
                                    v152 = 0;
                                    v156 = v153;
                                    if (v143 != 0) {
                                        // 0x36a80
                                        v158 = *(int32_t *)(v153 + 8);
                                        v152 = 1;
                                        v156 = 0;
                                        if (v158 != 0) {
                                            // 0x36a8c
                                            v159 = *(int32_t *)(*v57 + 20);
                                            v160 = v159 + v158;
                                            v150 = 1;
                                            v154 = v160;
                                            v152 = 1;
                                            v156 = 0;
                                            if (v160 != 0) {
                                                v155 = v154;
                                                v151 = v150;
                                                v152 = v143;
                                                v156 = v155;
                                                while (v151 != v143) {
                                                    // 0x36aa4
                                                    v161 = *(int32_t *)(v155 + 8);
                                                    v162 = v151 + 1;
                                                    v152 = v162;
                                                    v156 = 0;
                                                    if (v161 == 0) {
                                                        // break -> 0x36ac8
                                                        break;
                                                    }
                                                    // 0x36ab4
                                                    v163 = v161 + v159;
                                                    v150 = v162;
                                                    v154 = v163;
                                                    v152 = v162;
                                                    v156 = 0;
                                                    if (v163 == 0) {
                                                        // break -> 0x36ac8
                                                        break;
                                                    }
                                                    v155 = v154;
                                                    v151 = v150;
                                                    v152 = v143;
                                                    v156 = v155;
                                                }
                                            }
                                        }
                                    }
                                    // 0x36ac8
                                    v157 = v149 + 1;
                                    while (true) {
                                        // 0x36ad0
                                        v21 = v143;
                                        v26 = v156;
                                        v36 = v146;
                                        v41 = v153;
                                        v44 = v147;
                                        v13 = v148;
                                        v16 = v143;
                                        v23 = v152;
                                        v28 = v156;
                                        v30 = v156;
                                        v42 = v153;
                                        v46 = v147;
                                        v15 = v148;
                                        if (v152 == 0) {
                                            goto lab_0x36ad8;
                                        } else {
                                            goto lab_0x36b50;
                                        }
                                    }
                                    // 0x36bb8
                                    v144 = v157;
                                    v145 = v27;
                                    v146 = v37;
                                    v147 = v45;
                                    v148 = v14;
                                    if (v27 == 0) {
                                        // break -> 0x36bc0
                                        break;
                                    }
                                }
                                if (v14 != 0) {
                                    *(int32_t *)(v14 + 8) = 0;
                                }
                                int32_t v164 = v14; // 0x36bcc
                                while (v149 != 0 && v157 != 0) {
                                    int32_t v165 = v37; // 0x36bd8
                                    int32_t v166 = 2 * v143; // 0x36bd8
                                    int32_t v167 = v45; // 0x36bd8
                                    v164 = 0;
                                    if (v45 == 0) {
                                        // break -> 0x36be0
                                        break;
                                    }
                                    v143 = v166;
                                    v144 = 0;
                                    v145 = v167;
                                    v146 = v165;
                                    v147 = 0;
                                    v148 = 0;
                                    while (true) {
                                        // 0x36a74
                                        v153 = v145;
                                        v149 = v144;
                                        v152 = 0;
                                        v156 = v153;
                                        if (v143 != 0) {
                                            // 0x36a80
                                            v158 = *(int32_t *)(v153 + 8);
                                            v152 = 1;
                                            v156 = 0;
                                            if (v158 != 0) {
                                                // 0x36a8c
                                                v159 = *(int32_t *)(*v57 + 20);
                                                v160 = v159 + v158;
                                                v150 = 1;
                                                v154 = v160;
                                                v152 = 1;
                                                v156 = 0;
                                                if (v160 != 0) {
                                                    v155 = v154;
                                                    v151 = v150;
                                                    v152 = v143;
                                                    v156 = v155;
                                                    while (v151 != v143) {
                                                        // 0x36aa4
                                                        v161 = *(int32_t *)(v155 + 8);
                                                        v162 = v151 + 1;
                                                        v152 = v162;
                                                        v156 = 0;
                                                        if (v161 == 0) {
                                                            // break -> 0x36ac8
                                                            break;
                                                        }
                                                        // 0x36ab4
                                                        v163 = v161 + v159;
                                                        v150 = v162;
                                                        v154 = v163;
                                                        v152 = v162;
                                                        v156 = 0;
                                                        if (v163 == 0) {
                                                            // break -> 0x36ac8
                                                            break;
                                                        }
                                                        v155 = v154;
                                                        v151 = v150;
                                                        v152 = v143;
                                                        v156 = v155;
                                                    }
                                                }
                                            }
                                        }
                                        // 0x36ac8
                                        v157 = v149 + 1;
                                        v20 = v143;
                                        v22 = v152;
                                        v25 = v156;
                                        v29 = v156;
                                        v35 = v146;
                                        v40 = v153;
                                        v43 = v147;
                                        v12 = v148;
                                        while (true) {
                                            // 0x36ad0
                                            v21 = v20;
                                            v26 = v25;
                                            v36 = v35;
                                            v41 = v40;
                                            v44 = v43;
                                            v13 = v12;
                                            v16 = v20;
                                            v23 = v22;
                                            v28 = v25;
                                            v30 = v29;
                                            v42 = v40;
                                            v46 = v43;
                                            v15 = v12;
                                            if (v22 == 0) {
                                                goto lab_0x36ad8;
                                            } else {
                                                goto lab_0x36b50;
                                            }
                                        }
                                        // 0x36bb8
                                        v144 = v157;
                                        v145 = v27;
                                        v146 = v37;
                                        v147 = v45;
                                        v148 = v14;
                                        if (v27 == 0) {
                                            // break -> 0x36bc0
                                            break;
                                        }
                                    }
                                    if (v14 != 0) {
                                        *(int32_t *)(v14 + 8) = 0;
                                    }
                                    v164 = v14;
                                }
                                // 0x36be0
                                *(int32_t *)(*v57 + 16) = v164;
                                v53 = v45 - *(int32_t *)(*v57 + 20);
                                v54 = (int32_t *)(v53 + 72);
                                v55 = *v54;
                                g134 = v53;
                                if (v55 == 0) {
                                    int32_t v168 = *(int32_t *)(v53 + 76); // 0x37cb8
                                    int32_t v169 = v53 + 68; // 0x37cbc
                                    int32_t * v170 = (int32_t *)v169; // 0x37cbc
                                    int32_t v171 = *v170; // 0x37cbc
                                    if (v168 == 0) {
                                        // 0x37d7c
                                        free((int32_t *)*(int32_t *)v171);
                                        free((int32_t *)*v170);
                                        g134 = 0;
                                        v38 = 0;
                                        goto lab_0x36ccc;
                                    } else {
                                        int32_t v172 = *(int32_t *)(v171 + 20); // 0x37cc8
                                        int32_t * v173 = (int32_t *)(v171 + 16);
                                        v11 = v173;
                                        v18 = v169;
                                        v33 = v172;
                                        v19 = v169;
                                        v34 = v168;
                                        if (v53 == *v173 - v172) {
                                            goto lab_0x37ce0;
                                        } else {
                                            goto lab_0x37cf8;
                                        }
                                    }
                                } else {
                                    int32_t v174 = v53 + 68; // 0x36c10
                                    int32_t v175 = *(int32_t *)v174; // 0x36c10
                                    int32_t v176 = *(int32_t *)(v175 + 20); // 0x36c18
                                    int32_t * v177 = (int32_t *)(v175 + 16);
                                    v17 = v174;
                                    v24 = v55;
                                    v31 = v176;
                                    v11 = v177;
                                    v18 = v174;
                                    v33 = v176;
                                    if (v53 == *v177 - v176) {
                                        goto lab_0x37ce0;
                                    } else {
                                        goto lab_0x36c2c;
                                    }
                                }
                            }
                        }
                    } else {
                        // 0x37928
                        v50 = (int32_t)"block_exists";
                        v51 = __errno_location();
                        v52 = 0x15e8;
                        goto lab_0x377f8;
                    }
                } else {
                    // 0x37840
                    v49 = "test_work_current";
                    v48 = 0x163f;
                    format = (int32_t)"WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d";
                    v32 = __errno_location();
                    goto lab_0x377d0;
                }
            } else {
                // 0x37810
                v49 = "test_work_current";
                v48 = 0x163f;
                format = (int32_t)"WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d";
                v32 = __errno_location();
                goto lab_0x377d0;
            }
        } else {
            // 0x377e0
            v50 = (int32_t)"test_work_current";
            v51 = __errno_location();
            v52 = 0x1637;
            goto lab_0x377f8;
        }
    } else {
        // 0x377a4
        v49 = "test_work_current";
        v48 = 0x1637;
        format = (int32_t)"WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d";
        v32 = __errno_location();
        goto lab_0x377d0;
    }
  lab_0x36ad8:
    // 0x36ad8
    v14 = v13;
    v45 = v44;
    v37 = v36;
    v27 = v26;
    int32_t v178 = v21;
    if (v178 == 0 || v27 == 0) {
        // break -> 0x36bb8
        goto lab_0x36bb8;
    }
    int32_t v179 = *(int32_t *)(v27 + 8); // 0x36ae4
    int32_t v180 = v37; // 0x36aec
    if (v179 != 0) {
        v180 = *(int32_t *)(*v57 + 20);
    }
    int32_t v181 = v178; // 0x36458
    int32_t v182 = 0; // 0x36458
    int32_t v183 = v27; // 0x36458
    int32_t v184 = (v179 == 0 ? 0 : v180) + v179; // 0x36458
    int32_t v185 = v180; // 0x36458
    int32_t v186 = v41; // 0x36458
    int32_t v187 = v45; // 0x36458
    int32_t v188 = v14; // 0x36458
    goto lab_0x36afc;
  lab_0x36b50:;
    int32_t v234 = v15;
    int32_t v236 = v46;
    int32_t v233 = v42;
    int32_t v231 = v28;
    int32_t v229 = v23;
    int32_t v230 = v16;
    int32_t v232; // 0x36458
    int32_t v227; // 0x36458
    if (v230 == 0 || v231 == 0) {
        int32_t v400 = v30;
        v232 = v400;
        v227 = 0;
        if (v233 != 0) {
            int32_t v401 = *(int32_t *)(v233 + 8); // 0x36b64
            int32_t v402 = v400; // 0x36b6c
            if (v401 != 0) {
                v402 = *(int32_t *)(*v57 + 20);
            }
            // .thread51
            v232 = v402;
            v227 = v401 == 0 ? 0 : v402 + v401;
        }
        goto lab_0x36b78;
    } else {
        int32_t v403 = *(int32_t *)(*v57 + 20); // 0x37728
        int32_t v404 = *(int32_t *)(v233 + 100 - v403); // 0x37738
        if (v404 - *(int32_t *)(v231 + 100 - v403) < 1) {
            // 0x37764
            v232 = v404;
            v227 = 0;
            if (v233 != 0) {
                int32_t v405 = *(int32_t *)(v233 + 8); // 0x3776c
                v232 = v405;
                v227 = v405 == 0 ? 0 : v405 + v403;
            }
            goto lab_0x36b78;
        } else {
            int32_t v406 = *(int32_t *)(v231 + 8); // 0x3774c
            v181 = v230;
            v182 = v229;
            v183 = v231;
            v184 = v406 == 0 ? 0 : v406 + v403;
            v185 = v403;
            v186 = v233;
            v187 = v236;
            v188 = v234;
            goto lab_0x36afc;
        }
    }
  lab_0x36afc:;
    int32_t v189 = v188;
    int32_t v190 = v186;
    int32_t v191 = v184;
    int32_t v192 = v183;
    int32_t v193 = v182;
    int32_t v194 = v181 - 1; // 0x36b00
    int32_t v195 = v194; // 0x36b0c
    int32_t v196 = v193; // 0x36b0c
    int32_t v197 = v191; // 0x36b0c
    int32_t v198 = v191; // 0x36b0c
    int32_t v199 = v185; // 0x36b0c
    int32_t v200 = v190; // 0x36b0c
    int32_t v201 = v192; // 0x36b0c
    int32_t v202; // 0x36458
    int32_t v203; // 0x36458
    int32_t v204; // 0x36458
    int32_t v205; // 0x36458
    int32_t v206; // 0x36458
    int32_t v207; // 0x36458
    int32_t v208; // 0x36458
    int32_t v209; // 0x36458
    int32_t v210; // 0x36458
    int32_t v211; // 0x36458
    int32_t v212; // 0x36458
    int32_t v213; // 0x36458
    int32_t v214; // 0x36458
    int32_t v215; // 0x36458
    if (v189 == 0) {
        goto lab_0x37714;
    } else {
        int32_t v216 = v189 == 0 ? v191 : v192;
        int32_t v217 = v216 - *(int32_t *)(*v57 + 20); // 0x36b1c
        *(int32_t *)(v189 + 8) = v217;
        v204 = v194;
        v205 = v193;
        v207 = v191;
        v209 = v191;
        v211 = v217;
        v212 = v190;
        v214 = v187;
        v203 = v194;
        v206 = v193;
        v208 = v192;
        v210 = v191;
        v213 = v190;
        v215 = v187;
        v202 = v189;
        if (v216 == 0) {
            goto lab_0x36ad0;
        } else {
            goto lab_0x36b30;
        }
    }
  lab_0x37714:
    // 0x37714
    v204 = v195;
    v205 = v196;
    v207 = v197;
    v209 = v198;
    v211 = v199;
    v212 = v200;
    v214 = 0;
    int32_t v218 = v195; // 0x3771c
    int32_t v219 = v196; // 0x3771c
    int32_t v220 = v197; // 0x3771c
    int32_t v221 = v198; // 0x3771c
    int32_t v222 = 0; // 0x3771c
    int32_t v223 = v200; // 0x3771c
    int32_t v224 = v201; // 0x3771c
    int32_t v225 = v201; // 0x3771c
    if (v201 == 0) {
        goto lab_0x36ad0;
    } else {
        goto lab_0x36b44;
    }
  lab_0x36b78:;
    int32_t v226 = v227;
    int32_t v228 = v229 - 1; // 0x36b7c
    v195 = v230;
    v196 = v228;
    v197 = v231;
    v198 = v232;
    v199 = v226;
    v200 = v226;
    v201 = v233;
    if (v234 == 0) {
        goto lab_0x37714;
    } else {
        if (v233 == 0) {
            *(int32_t *)(v234 + 8) = 0;
            v204 = v230;
            v205 = v228;
            v207 = v231;
            int32_t v235; // 0x36458
            v209 = v235;
            v211 = v226;
            v212 = v226;
            v214 = v236;
            goto lab_0x36ad0;
        } else {
            // 0x36b98
            *(int32_t *)(v234 + 8) = v233 - *(int32_t *)(*v57 + 20);
            v203 = v230;
            v206 = v228;
            v208 = v233;
            v210 = v231;
            v213 = v226;
            v215 = v236;
            v202 = v234;
            goto lab_0x36b30;
        }
    }
  lab_0x36ad0:
    // 0x36ad0
    v20 = v204;
    v22 = v205;
    v25 = v207;
    v29 = v209;
    v35 = v211;
    v40 = v212;
    v43 = v214;
    v12 = 0;
    goto lab_0x36ad0_2;
  lab_0x36b44:
    // 0x36b44
    *(int32_t *)(v225 + 4) = v222;
    v21 = v218;
    v26 = v220;
    v36 = v222;
    v41 = v223;
    v44 = v224;
    v13 = v225;
    v16 = v218;
    v23 = v219;
    v28 = v220;
    v30 = v221;
    v42 = v223;
    v46 = v224;
    v15 = v225;
    if (v219 == 0) {
        goto lab_0x36ad8;
    } else {
        goto lab_0x36b50;
    }
  lab_0x36b30:
    // 0x36b30
    v218 = v203;
    v219 = v206;
    v220 = v210;
    v221 = v210;
    v222 = v202 - *(int32_t *)(*v57 + 20);
    v223 = v213;
    v224 = v215;
    v225 = v208;
    goto lab_0x36b44;
  lab_0x377d0:;
    int32_t v237 = *v32;
    snprintf((char *)&str4, 2048, (char *)format, v237, (struct timeval *)"cgminer.c", v49, v48);
  lab_0x376f4:
    // 0x376f4
    function_1ccec(3, (int32_t *)&str4, 1);
    function_2ab30(1, 1);
    // UNREACHABLE
  lab_0x377f8:
    // 0x377f8
    v49 = (char *)v50;
    v48 = v52;
    format = (int32_t)"WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d";
    v32 = v51;
    goto lab_0x377d0;
  lab_0x36cd4:;
    int32_t len2 = strlen(str5); // 0x36cdc
    int32_t v238 = len2; // 0x36cec
    int32_t v239 = -0x1124111; // 0x36cec
    int32_t v240 = -0x61c88647; // 0x36cec
    int32_t v241 = -0x61c88647; // 0x36cec
    int32_t v242 = v56; // 0x36cec
    if (len2 != 11 && len2 >= 11) {
        int32_t v243 = v56 + 12;
        unsigned char v244 = *(char *)(v56 + 6); // 0x36d0c
        int32_t v245 = len2 - 12; // 0x36d10
        unsigned char v246 = *(char *)(v56 + 2); // 0x36d14
        unsigned char v247 = *(char *)(v56 + 5); // 0x36d1c
        unsigned char v248 = *(char *)(v56 + 1); // 0x36d20
        unsigned char v249 = *(char *)(v56 + 10); // 0x36d24
        unsigned char v250 = *(char *)(v56 + 9); // 0x36d30
        unsigned char v251 = *(char *)(v56 + 4); // 0x36d38
        unsigned char v252 = *(char *)v56; // 0x36d40
        unsigned char v253 = *(char *)(v56 + 7); // 0x36d48
        unsigned char v254 = *(char *)(v56 + 3); // 0x36d50
        unsigned char v255 = *(char *)(v56 + 8); // 0x36d5c
        unsigned char v256 = *(char *)(v56 + 11); // 0x36d60
        int32_t v257 = (256 * (int32_t)v247 | 0x10000 * (int32_t)v244 | (int32_t)v251 | 0x1000000 * (int32_t)v253) - 0x61c88647; // 0x36d74
        uint32_t v258 = (256 * (int32_t)v250 | 0x10000 * (int32_t)v249 | (int32_t)v255 | 0x1000000 * (int32_t)v256) - 0x1124111; // 0x36d84
        int32_t v259 = -0x61c88647 - v257 + (256 * (int32_t)v248 | 0x10000 * (int32_t)v246 | (int32_t)v252 | 0x1000000 * (int32_t)v254) - v258 ^ v258 / 0x2000; // 0x36d94
        uint32_t v260 = v257 - v258 - v259 ^ 256 * v259; // 0x36da0
        uint32_t v261 = v258 - v259 - v260 ^ v260 / 0x2000; // 0x36dac
        int32_t v262 = v259 - v260 - v261 ^ v261 / 0x1000; // 0x36db8
        uint32_t v263 = v260 - v261 - v262 ^ 0x10000 * v262; // 0x36dc4
        uint32_t v264 = v261 - v262 - v263 ^ v263 / 32; // 0x36dd0
        int32_t v265 = v262 - v263 - v264 ^ v264 / 8; // 0x36ddc
        int32_t v266 = v263 - v264 - v265 ^ 1024 * v265; // 0x36de8
        int32_t v267 = v264 - v265 - v266 ^ v266 / 0x8000; // 0x36df0
        int32_t v268 = v245; // 0x36df4
        int32_t v269 = v243; // 0x36df4
        v238 = v245;
        v239 = v267;
        v240 = v265;
        v241 = v266;
        v242 = v243;
        while ((v266 & 0x4000) != 0 == (v245 != 11)) {
            // 0x36d0c
            v243 = v269 + 12;
            v244 = *(char *)(v269 + 6);
            v245 = v268 - 12;
            v246 = *(char *)(v269 + 2);
            v247 = *(char *)(v269 + 5);
            v248 = *(char *)(v269 + 1);
            v249 = *(char *)(v269 + 10);
            v250 = *(char *)(v269 + 9);
            v251 = *(char *)(v269 + 4);
            v252 = *(char *)v269;
            v253 = *(char *)(v269 + 7);
            v254 = *(char *)(v269 + 3);
            v255 = *(char *)(v269 + 8);
            v256 = *(char *)(v269 + 11);
            v257 = (256 * (int32_t)v247 | 0x10000 * (int32_t)v244 | (int32_t)v251 | 0x1000000 * (int32_t)v253) + v266;
            v258 = (256 * (int32_t)v250 | 0x10000 * (int32_t)v249 | (int32_t)v255 | 0x1000000 * (int32_t)v256) + v267;
            v259 = v265 - v257 + (256 * (int32_t)v248 | 0x10000 * (int32_t)v246 | (int32_t)v252 | 0x1000000 * (int32_t)v254) - v258 ^ v258 / 0x2000;
            v260 = v257 - v258 - v259 ^ 256 * v259;
            v261 = v258 - v259 - v260 ^ v260 / 0x2000;
            v262 = v259 - v260 - v261 ^ v261 / 0x1000;
            v263 = v260 - v261 - v262 ^ 0x10000 * v262;
            v264 = v261 - v262 - v263 ^ v263 / 32;
            v265 = v262 - v263 - v264 ^ v264 / 8;
            v266 = v263 - v264 - v265 ^ 1024 * v265;
            v267 = v264 - v265 - v266 ^ v266 / 0x8000;
            v268 = v245;
            v269 = v243;
            v238 = v245;
            v239 = v267;
            v240 = v265;
            v241 = v266;
            v242 = v243;
        }
    }
    int32_t v270 = v239 + len2; // 0x36e08
    g311 = v238 - 1;
    int32_t v271 = v270; // 0x36e10
    int32_t v272 = v270; // 0x36e10
    int32_t v273 = v270; // 0x36e10
    int32_t v274 = v270; // 0x36e10
    int32_t v275 = v241; // 0x36e10
    int32_t v276 = v270; // 0x36e10
    int32_t v277 = v241; // 0x36e10
    int32_t v278 = v270; // 0x36e10
    int32_t v279 = v241; // 0x36e10
    int32_t v280 = v270; // 0x36e10
    int32_t v281 = v241; // 0x36e10
    int32_t v282 = v270; // 0x36e10
    int32_t v283 = v240; // 0x36e10
    int32_t v284 = v241; // 0x36e10
    int32_t v285 = v270; // 0x36e10
    int32_t v286 = v240; // 0x36e10
    int32_t v287 = v241; // 0x36e10
    int32_t v288 = v270; // 0x36e10
    int32_t v289 = v240; // 0x36e10
    int32_t v290 = v241; // 0x36e10
    int32_t v291 = v270; // 0x36e10
    int32_t v292 = v240; // 0x36e10
    int32_t v293 = v241; // 0x36e10
    switch (v238) {
        case 11: {
            // 0x36e44
            v271 = 0x1000000 * (int32_t)*(char *)(v242 + 10) + v270;
        }
        case 10: {
            // 0x36e4c
            v272 = 0x10000 * (int32_t)*(char *)(v242 + 9) + v271;
        }
        case 9: {
            // 0x36e54
            v273 = 256 * (int32_t)*(char *)(v242 + 8) + v272;
        }
        case 8: {
            // 0x36e5c
            v274 = v273;
            v275 = 0x1000000 * (int32_t)*(char *)(v242 + 7) + v241;
        }
        case 7: {
            // 0x36e64
            v276 = v274;
            v277 = 0x10000 * (int32_t)*(char *)(v242 + 6) + v275;
        }
        case 6: {
            // 0x36e6c
            v278 = v276;
            v279 = 256 * (int32_t)*(char *)(v242 + 5) + v277;
        }
        case 5: {
            // 0x36e74
            v280 = v278;
            v281 = v279 + (int32_t)*(char *)(v242 + 4);
        }
        case 4: {
            // 0x36e7c
            v282 = v280;
            v283 = 0x1000000 * (int32_t)*(char *)(v242 + 3) + v240;
            v284 = v281;
        }
        case 3: {
            // 0x36e84
            v285 = v282;
            v286 = 0x10000 * (int32_t)*(char *)(v242 + 2) + v283;
            v287 = v284;
        }
        case 2: {
            // 0x36e8c
            v288 = v285;
            v289 = 256 * (int32_t)*(char *)(v242 + 1) + v286;
            v290 = v287;
        }
        case 1: {
            // 0x36e94
            v291 = v288;
            v292 = v289 + (int32_t)*(char *)v242;
            v293 = v290;
            // break -> 0x36e9c
            break;
        }
    }
    uint32_t v294 = v291;
    *(int32_t *)(v56 + 88) = v56;
    int32_t v295 = v292 - v294 - v293 ^ v294 / 0x2000; // 0x36eac
    uint32_t v296 = v293 - v294 - v295 ^ 256 * v295; // 0x36ebc
    uint32_t v297 = v294 - v295 - v296 ^ v296 / 0x2000; // 0x36ec8
    int32_t v298 = v295 - v296 - v297 ^ v297 / 0x1000; // 0x36ed4
    uint32_t v299 = v296 - v297 - v298 ^ 0x10000 * v298; // 0x36ee0
    uint32_t v300 = v297 - v298 - v299 ^ v299 / 32; // 0x36eec
    int32_t v301 = v298 - v299 - v300 ^ v300 / 8; // 0x36ef8
    uint32_t v302 = v299 - v300 - v301 ^ 1024 * v301; // 0x36f04
    int32_t v303 = v300 - v301 - v302 ^ v302 / 0x8000; // 0x36f0c
    *(int32_t *)(v56 + 96) = v303;
    *(int32_t *)(v56 + 92) = strlen(str5);
    int32_t * v304; // 0x36458
    int32_t v305; // 0x36458
    if (v39 == 0) {
        // 0x37a08
        *(int32_t *)(v56 + 76) = 0;
        *(int32_t *)(v56 + 72) = 0;
        g134 = v56;
        int32_t * mem = malloc(44); // 0x37a1c
        int32_t v306 = v56 + 68;
        int32_t * v307 = (int32_t *)v306;
        *v307 = (int32_t)mem;
        if (mem == NULL) {
            // 0x37d9c
            exit(-1);
            // UNREACHABLE
        }
        // 0x37a2c
        memset(mem, 0, 44);
        *(int32_t *)(*v307 + 16) = v306;
        *(int32_t *)(*v307 + 4) = 32;
        *(int32_t *)(*v307 + 8) = 5;
        *(int32_t *)(*v307 + 20) = 68;
        *(int32_t *)*v307 = (int32_t)malloc(384);
        int32_t v308 = *(int32_t *)*v307; // 0x37a7c
        if (v308 == 0) {
            // 0x37d9c
            exit(-1);
            // UNREACHABLE
        }
        // 0x37a88
        memset((int32_t *)v308, 0, 384);
        *(int32_t *)(*v307 + 40) = -0x5feee01f;
        v304 = v307;
        v305 = v306;
    } else {
        int32_t * v309 = (int32_t *)(v39 + 68);
        *(int32_t *)(v56 + 76) = 0;
        int32_t v310 = v56 + 68; // 0x36f30
        *(int32_t *)v310 = *v309;
        int32_t v311 = *v309; // 0x36f38
        int32_t v312 = *(int32_t *)(v311 + 20); // 0x36f40
        *(int32_t *)(v56 + 72) = *(int32_t *)(v311 + 16) - v312;
        *(int32_t *)(*(int32_t *)(*v309 + 16) + 8) = v56;
        *(int32_t *)(*v309 + 16) = v310;
        v304 = v309;
        v305 = v310;
    }
    int32_t * v313 = (int32_t *)(*v304 + 12); // 0x36f68
    *v313 = *v313 + 1;
    uint64_t v314 = *(int64_t *)*v304; // 0x36f78
    int32_t v315 = 12 * ((int32_t)v314 - 1 & v303); // 0x36f88
    int32_t v316 = v315 + 4;
    int32_t * v317 = (int32_t *)(v316 + (int32_t)(v314 / 0x100000000)); // 0x36f90
    *v317 = *v317 + 1;
    int32_t v318 = *(int32_t *)*v304; // 0x36fa0
    *(int32_t *)(v56 + 80) = 0;
    *(int32_t *)(v56 + 84) = *(int32_t *)(v318 + v315);
    int32_t v319 = *(int32_t *)*v304 + v315; // 0x36fb8
    int32_t v320 = *(int32_t *)v319; // 0x36fb8
    int32_t v321 = v319; // 0x36fc4
    if (v320 != 0) {
        *(int32_t *)(v320 + 12) = v305;
        v321 = *(int32_t *)*v304;
    }
    // .critedge38.thread
    *(int32_t *)(v321 + (v320 == 0 ? 0 : v315)) = v305;
    uint64_t v322 = *(int64_t *)(*(int32_t *)*v304 + v316); // 0x36fe4
    if (10 * (int32_t)v322 + 10 <= (int32_t)(v322 / 0x100000000)) {
        int32_t * v323 = (int32_t *)(v56 + 68); // 0x36ff8
        int32_t v324 = *v323; // 0x36ff8
        if (*(int32_t *)(v324 + 36) != 1) {
            int32_t * mem2 = calloc(24 * *(int32_t *)(v324 + 4), 1); // 0x37524
            if (mem2 == NULL) {
                // 0x37d9c
                exit(-1);
                // UNREACHABLE
            }
            int32_t v325 = (int32_t)mem2; // 0x37524
            int32_t v326 = *v323; // 0x37530
            int32_t v327 = *(int32_t *)(v326 + 4); // 0x37538
            uint64_t v328 = *(int64_t *)(v326 + 8); // 0x3753c
            uint32_t v329 = (int32_t)v328; // 0x3753c
            *(int32_t *)(v326 + 24) = (v329 >> (int32_t)(v328 / 0x100000000) + 1) + (int32_t)((2 * v327 - 1 & v329) != 0);
            *(int32_t *)(*v323 + 28) = 0;
            int32_t v330 = *v323; // 0x37568
            int32_t v331 = *(int32_t *)(v330 + 4); // 0x3756c
            int32_t v332 = 0; // 0x37574
            int32_t v333 = v330; // 0x37574
            if (v331 != 0) {
                int32_t v334 = *(int32_t *)(*(int32_t *)v330 + v332); // 0x37588
                int32_t v335 = v334; // 0x37590
                int32_t v336 = v330; // 0x37590
                int32_t v337 = v331; // 0x37590
                int32_t v338; // 0x36458
                int32_t * v339; // 0x375ac
                int32_t v340; // 0x375ac
                int32_t v341; // 0x375bc
                int32_t * v342; // 0x375c0
                uint32_t v343; // 0x375c4
                int32_t v344; // 0x375cc
                uint32_t v345; // 0x375d0
                int32_t * v346; // 0x37600
                int32_t v347; // 0x37608
                int32_t * v348; // 0x375dc
                int32_t v349; // 0x36458
                int32_t v350; // 0x36458
                if (v334 != 0) {
                    v338 = v335;
                    v339 = (int32_t *)(v338 + 16);
                    v340 = *v339;
                    v341 = 12 * (2 * v331 - 1 & *(int32_t *)(v338 + 28)) + v325;
                    v342 = (int32_t *)(v341 + 4);
                    v343 = *v342 + 1;
                    *v342 = v343;
                    v344 = *v323;
                    v345 = *(int32_t *)(v344 + 24);
                    if (v343 != v345 && v343 >= v345) {
                        // 0x375dc
                        v348 = (int32_t *)(v344 + 28);
                        *v348 = *v348 + 1;
                        *(int32_t *)(v341 + 8) = function_48ac8();
                    }
                    // 0x375fc
                    *(int32_t *)(v338 + 12) = 0;
                    v346 = (int32_t *)v341;
                    *v339 = *v346;
                    v347 = *v346;
                    if (v347 != 0) {
                        *(int32_t *)(v347 + 12) = v338;
                    }
                    *v346 = v338;
                    v349 = *v323;
                    v350 = *(int32_t *)(v349 + 4);
                    v336 = v349;
                    v337 = v350;
                    while (v340 != 0) {
                        // 0x375a4
                        v338 = v340;
                        v339 = (int32_t *)(v338 + 16);
                        v340 = *v339;
                        v341 = 12 * (2 * v350 - 1 & *(int32_t *)(v338 + 28)) + v325;
                        v342 = (int32_t *)(v341 + 4);
                        v343 = *v342 + 1;
                        *v342 = v343;
                        v344 = *v323;
                        v345 = *(int32_t *)(v344 + 24);
                        if (v343 != v345 && v343 >= v345) {
                            // 0x375dc
                            v348 = (int32_t *)(v344 + 28);
                            *v348 = *v348 + 1;
                            *(int32_t *)(v341 + 8) = function_48ac8();
                        }
                        // 0x375fc
                        *(int32_t *)(v338 + 12) = 0;
                        v346 = (int32_t *)v341;
                        *v339 = *v346;
                        v347 = *v346;
                        if (v347 != 0) {
                            *(int32_t *)(v347 + 12) = v338;
                        }
                        *v346 = v338;
                        v349 = *v323;
                        v350 = *(int32_t *)(v349 + 4);
                        v336 = v349;
                        v337 = v350;
                    }
                }
                int32_t v351 = 1; // 0x37630
                int32_t v352 = v351; // 0x3763c
                int32_t v353 = v336; // 0x3763c
                int32_t v354 = v337; // 0x3763c
                v332 += 12;
                v333 = v336;
                while (v351 < v337) {
                    // 0x37584
                    v334 = *(int32_t *)(*(int32_t *)v353 + v332);
                    int32_t v355 = v354; // 0x37590
                    v335 = v334;
                    v336 = v353;
                    v337 = v354;
                    if (v334 != 0) {
                        v338 = v335;
                        v339 = (int32_t *)(v338 + 16);
                        v340 = *v339;
                        v341 = 12 * (2 * v355 - 1 & *(int32_t *)(v338 + 28)) + v325;
                        v342 = (int32_t *)(v341 + 4);
                        v343 = *v342 + 1;
                        *v342 = v343;
                        v344 = *v323;
                        v345 = *(int32_t *)(v344 + 24);
                        if (v343 != v345 && v343 >= v345) {
                            // 0x375dc
                            v348 = (int32_t *)(v344 + 28);
                            *v348 = *v348 + 1;
                            *(int32_t *)(v341 + 8) = function_48ac8();
                        }
                        // 0x375fc
                        *(int32_t *)(v338 + 12) = 0;
                        v346 = (int32_t *)v341;
                        *v339 = *v346;
                        v347 = *v346;
                        if (v347 != 0) {
                            *(int32_t *)(v347 + 12) = v338;
                        }
                        *v346 = v338;
                        v349 = *v323;
                        v350 = *(int32_t *)(v349 + 4);
                        v336 = v349;
                        v337 = v350;
                        while (v340 != 0) {
                            // 0x375a4
                            v338 = v340;
                            v339 = (int32_t *)(v338 + 16);
                            v340 = *v339;
                            v341 = 12 * (2 * v350 - 1 & *(int32_t *)(v338 + 28)) + v325;
                            v342 = (int32_t *)(v341 + 4);
                            v343 = *v342 + 1;
                            *v342 = v343;
                            v344 = *v323;
                            v345 = *(int32_t *)(v344 + 24);
                            if (v343 != v345 && v343 >= v345) {
                                // 0x375dc
                                v348 = (int32_t *)(v344 + 28);
                                *v348 = *v348 + 1;
                                *(int32_t *)(v341 + 8) = function_48ac8();
                            }
                            // 0x375fc
                            *(int32_t *)(v338 + 12) = 0;
                            v346 = (int32_t *)v341;
                            *v339 = *v346;
                            v347 = *v346;
                            if (v347 != 0) {
                                *(int32_t *)(v347 + 12) = v338;
                            }
                            *v346 = v338;
                            v349 = *v323;
                            v350 = *(int32_t *)(v349 + 4);
                            v336 = v349;
                            v337 = v350;
                        }
                    }
                    // 0x37628
                    v351 = v352 + 1;
                    v352 = v351;
                    v353 = v336;
                    v354 = v337;
                    v332 += 12;
                    v333 = v336;
                }
            }
            // 0x37644
            free((int32_t *)*(int32_t *)v333);
            int32_t * v356 = (int32_t *)(*v323 + 4); // 0x37650
            *v356 = 2 * *v356;
            int32_t * v357 = (int32_t *)(*v323 + 8); // 0x37660
            *v357 = *v357 + 1;
            *(int32_t *)*v323 = v325;
            int32_t v358 = *v323; // 0x37674
            uint32_t v359 = *(int32_t *)(v358 + 28); // 0x37678
            uint32_t v360 = *(int32_t *)(v358 + 12) / 2; // 0x37680
            int32_t * v361 = (int32_t *)(v358 + 32);
            int32_t v362 = v359; // 0x37684
            if (v359 >= v360 == (v359 != v360)) {
                v362 = *v361;
            }
            int32_t v363 = v359 == v360 | v359 < v360 ? 0 : v362;
            *v361 = v363 + (int32_t)(v359 >= v360 == (v359 != v360));
            int32_t v364 = *v323; // 0x37694
            int32_t v365 = *(int32_t *)(v364 + 32); // 0x37698
            if (v365 != 0 == (v365 != 1)) {
                *(int32_t *)(v364 + 36) = 1;
            }
        }
    }
    int32_t v366 = a1 + 72; // 0x37008
    int32_t v367 = 232 - 8 * (int32_t)*(char *)v366; // 0x37020
    int32_t v368 = llvm_bswap_i32(*(int32_t *)v366 & -256);
    uint32_t v369 = v367 > 8 ? v367 : 8;
    int32_t v370 = 0xffff << v369 - 32 | 0xffff >> 32 - v369; // 0x37044
    int32_t result = function_492fc((int64_t)(0xffff << v369), (int64_t)v370); // 0x37048
    __asm_vmov(v368);
    __asm_vmov_8(result, v370);
    return result;
  lab_0x37ce0:
    // 0x37ce0
    *v11 = v33 + v55;
    int32_t v371 = *v54; // 0x37ce8
    if (v371 == 0) {
        // .thread64
        v19 = v18;
        v34 = *(int32_t *)(v53 + 76);
        goto lab_0x37cf8;
    } else {
        // 0x37da4
        v17 = v18;
        v24 = v371;
        v31 = *(int32_t *)(*(int32_t *)(v53 + 68) + 20);
        goto lab_0x36c2c;
    }
  lab_0x36c2c:;
    int32_t * v372 = (int32_t *)(v53 + 76); // 0x36c2c
    *(int32_t *)(v24 + 8 + v31) = *v372;
    int32_t v373 = v17; // 0x36c3c
    int32_t v374 = *v372; // 0x36c3c
    int32_t v375 = v53; // 0x36c3c
    goto lab_0x36c40;
  lab_0x36ccc:
    // 0x36ccc
    free((int32_t *)v53);
    v39 = v38;
    goto lab_0x36cd4;
  lab_0x37cf8:
    // 0x37cf8
    g134 = v34;
    v373 = v19;
    v374 = v34;
    v375 = v34;
    goto lab_0x36c40;
  lab_0x36c40:;
    int32_t * v376 = (int32_t *)(v375 + 68); // 0x36c40
    if (v374 != 0) {
        int32_t v377 = *v54; // 0x36c48
        int32_t v378; // 0x36c40
        int32_t v379 = *(int32_t *)(v378 + 20); // 0x36c4c
        int32_t v380; // 0x36458
        *(int32_t *)(v380 + 4 + v379) = v377;
    }
    int32_t v381 = *v376;
    int32_t v382 = 12 * (*(int32_t *)(v381 + 4) - 1 & *(int32_t *)(v53 + 96)); // 0x36c74
    int32_t * v383 = (int32_t *)(*(int32_t *)v381 + 4 + v382); // 0x36c7c
    *v383 = *v383 - 1;
    int32_t * v384 = (int32_t *)(*(int32_t *)*v376 + v382); // 0x36c90
    if (*v384 == v373) {
        *v384 = *(int32_t *)(v53 + 84);
    }
    int32_t v385 = v53 + 80; // 0x36ca0
    uint64_t v386 = *(int64_t *)v385; // 0x36ca0
    int32_t v387 = v386; // 0x36ca0
    int32_t v388 = v386 / 0x100000000; // 0x36ca0
    int32_t v389 = v387; // 0x36ca8
    if (v388 != 0) {
        *(int32_t *)(v388 + 16) = v387;
        v389 = *(int32_t *)(v53 + 84);
    }
    int32_t v390 = v389;
    if (v390 != 0) {
        *(int32_t *)(v390 + 12) = *(int32_t *)v385;
    }
    int32_t * v391 = (int32_t *)(*v376 + 12); // 0x36cc0
    *v391 = *v391 - 1;
    v38 = v375;
    goto lab_0x36ccc;
  lab_0x368f8:;
    char * v392 = (char *)(a1 + 280); // 0x368f8
    if (*v392 == 0) {
        // 0x369a4
        *v392 = 0;
        v10 = v47;
        goto lab_0x36490;
    } else {
        int32_t v393 = g89 - 3; // 0x36914
        int32_t v394 = g130 + 1; // 0x3691c
        g130 = v394;
        *(int32_t *)(a1 + 336) = v394;
        if (v393 != 0 == (v393 != 1)) {
            // 0x376ac
            if (*v3 == function_2e47c()) {
                goto lab_0x3692c;
            } else {
                // 0x369a4
                *v392 = 0;
                v10 = v47;
                goto lab_0x36490;
            }
        } else {
            goto lab_0x3692c;
        }
    }
  lab_0x3692c:;
    char v395 = *(char *)&g179; // 0x36938
    char v396 = *(char *)&g70;
    if (*(char *)(a1 + 284) == 0) {
        if ((v396 || v395) == 0 == g28 < (char *)5) {
            goto lab_0x369a0;
        } else {
            int32_t v397 = *(int32_t *)*v3; // 0x379cc
            char * v398 = *(char *)(a1 + 324) == 0 ? (char *)&g19 : "GBT "; // 0x379f0
            snprintf((char *)&str4, 2048, "%sLONGPOLL from pool %d requested work restart", v398, v397);
            function_1ccec(5, (int32_t *)&str4, 0);
            goto lab_0x369a0;
        }
    } else {
        if ((v396 || v395) == 0 == g28 < (char *)5) {
            goto lab_0x369a0;
        } else {
            int32_t v399 = *(int32_t *)v4; // 0x36988
            snprintf((char *)&str4, 2048, "Stratum from pool %d requested work restart", v399);
            function_1ccec(5, (int32_t *)&str4, 0);
            goto lab_0x369a0;
        }
    }
  lab_0x369a0:
    // 0x369a0
    function_2ae68();
    // 0x369a4
    *v392 = 0;
    v10 = v47;
    goto lab_0x36490;
}

// Address range: 0x37db0 - 0x39840
int32_t function_37db0(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x37db0
    float64_t v1; // 0x37db0
    float64_t v2 = __asm_vpush(v1, v1); // 0x37db8
    int32_t str; // bp-2636, 0x37db0
    snprintf((char *)&str, 16, "%d/RStratum", pthread_detach(pthread_self()));
    float64_t v3 = __asm_vldr(0); // 0x37e10
    function_21db8(&str);
    char * v4 = (char *)(a1 + 105); // 0x37e24
    if (*v4 != 0) {
        // 0x37f28
        function_20258(a1, (int32_t)&g306, (int32_t)&g306);
        // 0x37f2c
        __asm_vpop_11(v2, v3);
        return 0;
    }
    int32_t * v5 = (int32_t *)(a1 + 588);
    int32_t v6; // bp-40, 0x37db0
    int32_t v7 = &v6;
    int32_t v8; // bp-2340, 0x37db0
    int32_t v9 = &v8;
    int32_t str4; // bp-2648, 0x37db0
    int32_t v10 = &str4;
    int32_t str2; // bp-2088, 0x37db0
    int32_t v11 = &str2;
    char * v12 = (char *)(a1 + 680);
    int32_t * v13 = (int32_t *)(a1 + 128);
    int32_t * mutex = (int32_t *)(a1 + 212);
    int32_t * rwlock = (int32_t *)(a1 + 236);
    int32_t v14 = -0x112410d;
    int32_t v15 = -0x60b6453a;
    int32_t v16 = (int32_t)"%d/RStratum"; // 0x3806c
    int32_t v17 = 16; // 0x38064
    int64_t v18; // 0x37db0
    int32_t v19 = v18;
    int32_t * v20; // 0x37db0
    int32_t * v21; // 0x37db0
    int32_t * v22; // 0x37db0
    int32_t * v23; // 0x37db0
    int32_t v24; // 0x37db0
    int32_t v25; // 0x37db0
    int32_t v26; // 0x37db0
    int32_t v27; // 0x37db0
    int32_t v28; // 0x37db0
    int32_t v29; // 0x37db0
    int32_t v30; // 0x37db0
    int32_t v31; // 0x37db0
    int32_t v32; // 0x37db0
    int32_t v33; // 0x37db0
    int32_t v34; // 0x37db0
    int32_t v35; // 0x37db0
    int32_t v36; // 0x37db0
    int32_t v37; // 0x37db0
    int32_t v38; // 0x37db0
    int32_t v39; // 0x37db0
    int32_t v40; // 0x37db0
    int32_t v41; // 0x37db0
    int32_t v42; // 0x37db0
    int32_t v43; // 0x37db0
    int32_t v44; // 0x37db0
    int32_t v45; // 0x37db0
    char v46; // 0x37db0
    int32_t v47; // 0x37db0
    int32_t v48; // 0x37db0
    int32_t v49; // 0x37db0
    int32_t v50; // 0x37db0
    int32_t v51; // 0x37db0
    int32_t v52; // 0x37db0
    int32_t v53; // 0x37db0
    int32_t v54; // 0x37db0
    int32_t v55; // 0x37db0
    int32_t v56; // 0x37db0
    int32_t v57; // 0x37db0
    int32_t v58; // 0x37db0
    int32_t v59; // 0x37db0
    int32_t v60; // 0x37db0
    int32_t v61; // 0x37db0
    int32_t v62; // 0x37db0
    int32_t v63; // 0x37db0
    int32_t v64; // 0x37db0
    int32_t v65; // 0x37db0
    int32_t v66; // 0x37db0
    int32_t v67; // 0x37db0
    int32_t v68; // 0x37db0
    int32_t v69; // 0x37db0
    int32_t v70; // 0x37db0
    int32_t v71; // 0x37db0
    int32_t v72; // 0x37db0
    int32_t v73; // 0x37db0
    int32_t v74; // 0x37db0
    int32_t v75; // 0x37db0
    int32_t v76; // 0x37db0
    int32_t v77; // 0x37db0
    int32_t v78; // 0x37db0
    int32_t v79; // 0x37db0
    int32_t v80; // 0x37db0
    int32_t v81; // 0x37db0
    int32_t v82; // 0x37db0
    int32_t v83; // 0x37db0
    char * v84; // 0x37db0
    char * v85; // 0x37db0
    char * v86; // 0x37db0
    char * v87; // 0x37db0
    char * v88; // 0x37db0
    char * v89; // 0x37db0
    char * v90; // 0x37db0
    char * v91; // 0x37db0
    char * v92; // 0x37db0
    int32_t v93; // 0x37db0
    int32_t v94; // 0x37db0
    int32_t v95; // 0x37db0
    int32_t v96; // 0x37db0
    int32_t v97; // 0x37db0
    int32_t * v98; // 0x37db0
    int32_t v99; // 0x37db0
    int32_t v100; // 0x386b4
    int32_t v101; // 0x38720
    char * v102; // 0x38730
    int32_t v103; // 0x38748
    int32_t v104; // 0x3874c
    int32_t v105; // 0x37edc
    int32_t v106; // 0x3814c
    int32_t v107; // 0x38164
    int32_t v108; // 0x3817c
    while (true) {
      lab_0x37e34_2:
        // 0x37e34
        v87 = v84;
        v79 = v78;
        v93 = v19;
        v37 = v17;
        v41 = v16;
        v54 = v52;
        v63 = v60;
        v70 = v15;
        v74 = v14;
        v28 = v24;
        int32_t v109; // 0x37ecc
        while (true) {
          lab_0x37e34:
            // 0x37e34
            v29 = v28;
            v14 = v74;
            v15 = v70;
            v64 = v63;
            int32_t v110 = v54;
            v19 = v93;
            v80 = v79;
            v88 = v87;
            int32_t v111 = v110; // 0x37e3c
            if (function_1fb7c(a1) == 0) {
                // 0x37f40
                v111 = v110;
                if (function_2e8ac(a1) == 0) {
                    // 0x37f50
                    function_20258(a1, (int32_t)&g306, (int32_t)&g306);
                    function_31024(a1, v37, v41, 0);
                    function_2ff3c(a1);
                    if (function_2e8ac(a1) == 0) {
                        int32_t v112; // 0x37fa4
                        if (*(int32_t *)(a1 + 100) != 0) {
                            // 0x37f94
                            if (function_2e47c() == a1) {
                                // break -> 0x38388
                                break;
                            }
                            // 0x37fa0
                            v112 = g89 - 3;
                            if (v112 == 1 || v112 == 0) {
                                // break -> 0x38388
                                break;
                            }
                        }
                        // 0x37fb0
                        if (pthread_mutex_lock(&g120) != 0) {
                            // break (via goto) -> 0x38604
                            goto lab_0x38604;
                        }
                        // 0x37fc0
                        pthread_cond_wait(&g121, &g120);
                        if (pthread_mutex_unlock(&g120) != 0) {
                            // 0x38620
                            v99 = (int32_t)"wait_lpcurrent";
                            v98 = __errno_location();
                            v97 = 0x26f6;
                            goto lab_0x385bc;
                        }
                        // 0x37fdc
                        function_1da28();
                        while (function_2e8ac(a1) == 0) {
                            // 0x37f88
                            if (*(int32_t *)(a1 + 100) != 0) {
                                // 0x37f94
                                if (function_2e47c() == a1) {
                                    // break -> 0x38388
                                    break;
                                }
                                // 0x37fa0
                                v112 = g89 - 3;
                                if (v112 == 1 || v112 == 0) {
                                    // break -> 0x38388
                                    break;
                                }
                            }
                            // 0x37fb0
                            if (pthread_mutex_lock(&g120) != 0) {
                                // break (via goto) -> 0x38604
                                goto lab_0x38604;
                            }
                            // 0x37fc0
                            pthread_cond_wait(&g121, &g120);
                            if (pthread_mutex_unlock(&g120) != 0) {
                                // 0x38620
                                v99 = (int32_t)"wait_lpcurrent";
                                v98 = __errno_location();
                                v97 = 0x26f6;
                                goto lab_0x385bc;
                            }
                            // 0x37fdc
                            function_1da28();
                        }
                    }
                    int32_t v113 = function_24a2c(a1); // 0x3838c
                    v111 = (int32_t)&g73;
                    if (v113 == 0) {
                        function_306e8(a1);
                        if (*v4 != 0) {
                            // 0x37f2c
                            __asm_vpop_11(v2, v3);
                            return 0;
                        }
                        // 0x38380
                        function_1f7f8(0x1388);
                        int32_t v114 = function_24a2c(a1); // 0x3838c
                        v111 = (int32_t)&g73;
                        while (v114 == 0) {
                            // 0x38398
                            function_306e8(a1);
                            if (*v4 != 0) {
                                // 0x37f2c
                                __asm_vpop_11(v2, v3);
                                return 0;
                            }
                            // 0x38380
                            function_1f7f8(0x1388);
                            v114 = function_24a2c(a1);
                            v111 = (int32_t)&g73;
                        }
                    }
                }
            }
            // 0x37e40
            v55 = v111;
            int32_t v115; // bp-2472, 0x37db0
            int32_t v116 = &v115; // 0x37e48
            v116 += 4;
            *(int32_t *)v116 = 0;
            int32_t v117; // bp-2344, 0x37db0
            while (v116 != (int32_t)&v117) {
                // 0x37e4c
                v116 += 4;
                *(int32_t *)v116 = 0;
            }
            uint32_t v118 = *v5; // 0x37e58
            int32_t timeout = 90; // bp-2644, 0x37e68
            int32_t v119 = -v118; // 0x37e7c
            int32_t v120 = 4 * (v118 < 0 ? v118 + 31 : v118) / 32 + v7; // 0x37e8c
            int32_t * v121 = (int32_t *)(v120 - 2428); // 0x37e98
            int32_t v122 = *v121; // 0x37e98
            *v121 = 1 << (v119 < 0 ? v118 % 32 : -((v119 % 32))) | v122;
            int32_t v123 = v122; // 0x37eb0
            int32_t v124 = v120; // 0x37eb0
            if (function_1fb7c(a1) == 0) {
                int32_t v125 = *v5; // 0x37eb4
                int32_t readfds; // bp-2468, 0x37db0
                v109 = select(v125 + 1, (struct _TYPEDEF_fd_set *)&readfds, NULL, NULL, (struct timeval *)&timeout);
                v123 = &readfds;
                v124 = 0;
                if (v109 < 1) {
                    // break -> 0x3844c
                    break;
                }
            }
            int32_t v126 = v124;
            v105 = function_20770(a1, v123, v126);
            if (v105 == 0) {
                // 0x37ff8
                v46 = *(char *)&g179;
                goto lab_0x38004;
            }
            // 0x37ee8
            function_2e888(a1);
            int32_t v127 = function_25a68(a1, v105); // 0x37ef8
            v89 = v88;
            v81 = v80;
            v94 = v19;
            v38 = v127;
            v42 = v126;
            v48 = v105;
            v56 = v55;
            v65 = v64;
            v71 = v15;
            v75 = v14;
            v32 = v29;
            if (v127 == 0) {
                // 0x38144
                v106 = function_46448((int32_t *)v105, 0, &v8);
                if (v106 == 0) {
                    char v128 = *(char *)&g70; // 0x382c0
                    v91 = v88;
                    v83 = v80;
                    v96 = v19;
                    v44 = v9;
                    v50 = v105;
                    v58 = v55;
                    v67 = v64;
                    v73 = v15;
                    v77 = v14;
                    v34 = v29;
                    if ((v128 | *(char *)&g179) == 0 != g28 < (char *)6) {
                        // 0x382cc
                        int32_t v129; // bp-2248, 0x37db0
                        snprintf((char *)&str2, 2048, "JSON decode failed(%d): %s", v8, &v129);
                        function_1ccec(6, &str2, 0);
                        v91 = v88;
                        v83 = v80;
                        v96 = v19;
                        v44 = 0;
                        v50 = v105;
                        v58 = v55;
                        v67 = v64;
                        v73 = v15;
                        v77 = v14;
                        v34 = v11;
                    }
                    goto lab_0x38300;
                } else {
                    // 0x3815c
                    v107 = function_472ec(v106, "result");
                    v108 = function_472ec(v106, "error");
                    int32_t v130 = function_472ec(v106, "id"); // 0x38190
                    if (v130 == 0) {
                        goto lab_0x383b0;
                    } else {
                        // 0x3819c
                        if (*(int32_t *)v130 == 7) {
                            goto lab_0x383b0;
                        } else {
                            int32_t v131 = function_472ec(v107, "version-rolling.mask"); // 0x381b4
                            char * v132 = v88; // 0x381bc
                            int32_t v133 = v80; // 0x381bc
                            int32_t v134 = v19; // 0x381bc
                            int32_t v135 = v131; // 0x381bc
                            int32_t v136 = (int32_t)"version-rolling.mask"; // 0x381bc
                            int32_t v137 = v9; // 0x381bc
                            int32_t v138 = v105; // 0x381bc
                            int32_t v139 = v55; // 0x381bc
                            int32_t v140 = v64; // 0x381bc
                            int32_t v141 = v15; // 0x381bc
                            int32_t v142 = v14; // 0x381bc
                            int32_t v143 = v29; // 0x381bc
                            if (v131 == 0) {
                                char * str3 = (char *)v105; // 0x38648
                                char * substr_pos = strstr(str3, "mining.configure"); // 0x38648
                                v132 = v88;
                                v133 = v80;
                                v134 = v19;
                                v135 = (int32_t)substr_pos;
                                v136 = (int32_t)"mining.configure";
                                v137 = v9;
                                v138 = v105;
                                v139 = v55;
                                v140 = v64;
                                v141 = v15;
                                v142 = v14;
                                v143 = v29;
                                if (substr_pos == NULL) {
                                    char * substr_pos2 = strstr(str3, "mining.set_version_mask"); // 0x38660
                                    v132 = v88;
                                    v133 = v80;
                                    v134 = v19;
                                    v135 = (int32_t)substr_pos2;
                                    v136 = (int32_t)"mining.set_version_mask";
                                    v137 = v9;
                                    v138 = v105;
                                    v139 = v55;
                                    v140 = v64;
                                    v141 = v15;
                                    v142 = v14;
                                    v143 = v29;
                                    if (substr_pos2 == NULL) {
                                        int32_t v144 = function_47a7c(v130); // 0x38670
                                        str4 = v144;
                                        int32_t v145 = pthread_mutex_lock(&g123); // 0x38680
                                        char * v146 = v88; // 0x38688
                                        int32_t v147 = v80; // 0x38688
                                        int32_t v148 = v19; // 0x38688
                                        int32_t v149 = 0x1ca3; // 0x38688
                                        int32_t v150 = v9; // 0x38688
                                        int32_t v151 = v144; // 0x38688
                                        int32_t v152 = v144; // 0x38688
                                        int32_t v153 = v55; // 0x38688
                                        int32_t v154 = v64; // 0x38688
                                        int32_t v155 = v14; // 0x38688
                                        int32_t v156 = v19; // 0x38688
                                        int32_t v157 = v29; // 0x38688
                                        if (v145 == 0) {
                                            int32_t v158 = v144 & 0xff00; // 0x3869c
                                            v100 = g124;
                                            int32_t v159 = (v144 & -0xffff01) + 0x112410d + (v144 & 0xff0000) + v158 ^ ((int32_t)&g171 | 0xf76d); // 0x386b8
                                            uint32_t v160 = v15 - v159 ^ 256 * v159; // 0x386c4
                                            uint32_t v161 = v14 - v159 - v160 ^ v160 / 0x2000; // 0x386d4
                                            int32_t v162 = v159 - v160 - v161 ^ v161 / 0x1000; // 0x386e0
                                            uint32_t v163 = v160 - v161 - v162 ^ 0x10000 * v162; // 0x386ec
                                            uint32_t v164 = v161 - v162 - v163 ^ v163 / 32; // 0x386f8
                                            int32_t v165 = v162 - v163 - v164 ^ v164 / 8; // 0x38704
                                            int32_t v166 = v164 - v165; // 0x3870c
                                            uint32_t v167 = v163 - v164 - v165 ^ 1024 * v165; // 0x38710
                                            int32_t v168 = v166 - v167; // 0x38714
                                            v146 = v88;
                                            v147 = v80;
                                            v148 = v19;
                                            v149 = v166;
                                            v150 = v168;
                                            v151 = v105;
                                            v152 = v158;
                                            v153 = v55;
                                            v154 = v64;
                                            v155 = v15;
                                            v156 = v14;
                                            v157 = 0;
                                            if (v100 != 0) {
                                                int32_t v169 = v168 ^ v167 / 0x8000; // 0x38718
                                                v101 = *(int32_t *)v100;
                                                int32_t v170 = *(int32_t *)v101; // 0x38728
                                                v102 = (char *)v170;
                                                int32_t v171 = *(int32_t *)(12 * (*(int32_t *)(v101 + 4) - 1 & v169) + v170); // 0x3873c
                                                v146 = v102;
                                                v147 = v80;
                                                v148 = v19;
                                                v149 = 12;
                                                v150 = 0;
                                                v151 = v105;
                                                v152 = v101;
                                                v153 = v55;
                                                v154 = v64;
                                                v155 = v15;
                                                v156 = v14;
                                                v157 = v100;
                                                if (v171 != 0) {
                                                    int32_t * v172 = (int32_t *)(v101 + 20);
                                                    v103 = *v172;
                                                    v104 = -v103;
                                                    int32_t v173 = v171 - v103; // 0x38754
                                                    int32_t v174 = v103; // 0x38758
                                                    int32_t v175 = v173; // 0x38758
                                                    v146 = v102;
                                                    v147 = v103;
                                                    v148 = v19;
                                                    v149 = v103;
                                                    v150 = v171;
                                                    v151 = v105;
                                                    v152 = v101;
                                                    v153 = v104;
                                                    v154 = 0;
                                                    v155 = v15;
                                                    v156 = v14;
                                                    v157 = v100;
                                                    if (v173 != 0) {
                                                        v68 = v175;
                                                        int32_t v176 = v174;
                                                        int32_t v177 = *(int32_t *)(v68 + 28); // 0x38788
                                                        int32_t v178 = v176; // 0x38790
                                                        int32_t v179 = v177; // 0x38790
                                                        int32_t v180; // 0x38794
                                                        int32_t memcmp_rc; // 0x387a8
                                                        int32_t * v181; // 0x37db0
                                                        int32_t v182; // 0x387b4
                                                        int32_t * v183; // 0x37db0
                                                        if (v169 == v177) {
                                                            // 0x38794
                                                            v180 = *(int32_t *)(v68 + 24);
                                                            v178 = v176;
                                                            v179 = v180;
                                                            if (v180 == 4) {
                                                                // 0x387a0
                                                                memcmp_rc = memcmp((int32_t *)*(int32_t *)(v68 + 20), &str4, 4);
                                                                v178 = v10;
                                                                v179 = 4;
                                                                if (memcmp_rc == 0) {
                                                                    // 0x387b4
                                                                    v181 = (int32_t *)(v68 + 4);
                                                                    v182 = *v181;
                                                                    if (v182 == 0) {
                                                                        goto lab_0x3927c;
                                                                    } else {
                                                                        // 0x387d0
                                                                        v183 = (int32_t *)(v101 + 16);
                                                                        v22 = v172;
                                                                        v92 = v102;
                                                                        v47 = v182;
                                                                        v69 = v68;
                                                                        v25 = v100;
                                                                        v23 = v181;
                                                                        v21 = v183;
                                                                        v86 = v102;
                                                                        v45 = v182;
                                                                        v62 = v68;
                                                                        v31 = v100;
                                                                        if (v68 == *v183 - v103) {
                                                                            goto lab_0x392d4;
                                                                        } else {
                                                                            goto lab_0x387e0;
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        int32_t v184 = v179;
                                                        int32_t v185 = v178;
                                                        int32_t v186 = *(int32_t *)(v68 + 16); // 0x38774
                                                        v146 = v102;
                                                        v147 = v103;
                                                        v148 = v14;
                                                        v149 = v185;
                                                        v150 = v184;
                                                        v151 = v105;
                                                        v152 = v105;
                                                        v153 = v104;
                                                        v154 = 0;
                                                        v155 = v15;
                                                        v156 = v14;
                                                        v157 = v100;
                                                        while (v186 != 0) {
                                                            int32_t v187 = v186 - v103; // 0x38780
                                                            v174 = v185;
                                                            v175 = v187;
                                                            v146 = v102;
                                                            v147 = v103;
                                                            v148 = v14;
                                                            v149 = v185;
                                                            v150 = v184;
                                                            v151 = v105;
                                                            v152 = v105;
                                                            v153 = v104;
                                                            v154 = 0;
                                                            v155 = v15;
                                                            v156 = v14;
                                                            v157 = v100;
                                                            if (v187 == 0) {
                                                                // break -> 0x38fb0
                                                                break;
                                                            }
                                                            v68 = v175;
                                                            v176 = v174;
                                                            v177 = *(int32_t *)(v68 + 28);
                                                            v178 = v176;
                                                            v179 = v177;
                                                            if (v169 == v177) {
                                                                // 0x38794
                                                                v180 = *(int32_t *)(v68 + 24);
                                                                v178 = v176;
                                                                v179 = v180;
                                                                if (v180 == 4) {
                                                                    // 0x387a0
                                                                    memcmp_rc = memcmp((int32_t *)*(int32_t *)(v68 + 20), &str4, 4);
                                                                    v178 = v10;
                                                                    v179 = 4;
                                                                    if (memcmp_rc == 0) {
                                                                        // 0x387b4
                                                                        v181 = (int32_t *)(v68 + 4);
                                                                        v182 = *v181;
                                                                        if (v182 == 0) {
                                                                            goto lab_0x3927c;
                                                                        } else {
                                                                            // 0x387d0
                                                                            v183 = (int32_t *)(v101 + 16);
                                                                            v22 = v172;
                                                                            v92 = v102;
                                                                            v47 = v182;
                                                                            v69 = v68;
                                                                            v25 = v100;
                                                                            v23 = v181;
                                                                            v21 = v183;
                                                                            v86 = v102;
                                                                            v45 = v182;
                                                                            v62 = v68;
                                                                            v31 = v100;
                                                                            if (v68 == *v183 - v103) {
                                                                                goto lab_0x392d4;
                                                                            } else {
                                                                                goto lab_0x387e0;
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                            // 0x38774
                                                            v184 = v179;
                                                            v185 = v178;
                                                            v186 = *(int32_t *)(v68 + 16);
                                                            v146 = v102;
                                                            v147 = v103;
                                                            v148 = v14;
                                                            v149 = v185;
                                                            v150 = v184;
                                                            v151 = v105;
                                                            v152 = v105;
                                                            v153 = v104;
                                                            v154 = 0;
                                                            v155 = v15;
                                                            v156 = v14;
                                                            v157 = v100;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        int32_t v188 = v157;
                                        int32_t v189 = v154;
                                        int32_t v190 = v150;
                                        int32_t v191 = pthread_mutex_unlock(&g123); // 0x38fb4
                                        v85 = v146;
                                        v40 = v190;
                                        v61 = v189;
                                        v30 = v188;
                                        if (v191 != 0) {
                                            goto lab_0x392a4;
                                        }
                                        // 0x38fc0
                                        v53 = v153;
                                        int32_t v192 = function_1da28(); // 0x38fd0
                                        v132 = (char *)&g31;
                                        v133 = v147;
                                        v134 = v148;
                                        v135 = v192;
                                        v136 = v149;
                                        v137 = v190;
                                        v138 = v151;
                                        v139 = v53;
                                        v140 = v189;
                                        v141 = v155;
                                        v142 = v156;
                                        v143 = v188;
                                        if (v107 != 0) {
                                            // 0x38fe0
                                            v36 = (int32_t)"parse_stratum_response";
                                            v51 = v152;
                                            v59 = v53;
                                            if (pthread_mutex_lock(mutex) == 0) {
                                                // 0x38ff4
                                                if (pthread_rwlock_rdlock(rwlock) != 0 || pthread_mutex_unlock(mutex) != 0) {
                                                    // 0x39258
                                                    function_2c5c0("parse_stratum_response", 0x1cb7);
                                                    // UNREACHABLE
                                                }
                                                int32_t v193 = *(int32_t *)(a1 + 1824); // 0x39028
                                                __asm_vldr(v193);
                                                function_2c008(rwlock, "parse_stratum_response", 0x1cb9);
                                                int32_t v194 = *(int32_t *)v107; // 0x39034
                                                char v195 = *(char *)&g179; // 0x39044
                                                char v196 = *(char *)&g70;
                                                if (v194 == 5) {
                                                    if ((v196 || v195) == 0) {
                                                        char * v197 = g28; // 0x39168
                                                        v27 = v188;
                                                        if (v197 < (char *)5) {
                                                            goto lab_0x391a0;
                                                        } else {
                                                            goto lab_0x39174;
                                                        }
                                                    } else {
                                                        goto lab_0x39174;
                                                    }
                                                } else {
                                                    if ((v196 || v195) == 0) {
                                                        char * v198 = g28; // 0x39070
                                                        v26 = v188;
                                                        if (v198 < (char *)5) {
                                                            goto lab_0x390a8;
                                                        } else {
                                                            goto lab_0x3907c;
                                                        }
                                                    } else {
                                                        goto lab_0x3907c;
                                                    }
                                                }
                                            } else {
                                                goto lab_0x38960;
                                            }
                                        }
                                    }
                                }
                            }
                            int32_t * v199 = (int32_t *)(v106 + 4);
                            v20 = v199;
                            v90 = v132;
                            v82 = v133;
                            v95 = v134;
                            v35 = v135;
                            v39 = v136;
                            v43 = v137;
                            v49 = v138;
                            v57 = v139;
                            v66 = v140;
                            v72 = v141;
                            v76 = v142;
                            v33 = v143;
                            v91 = v132;
                            v83 = v133;
                            v96 = v134;
                            v44 = v137;
                            v50 = v138;
                            v58 = v139;
                            v67 = v140;
                            v73 = v141;
                            v77 = v142;
                            v34 = v143;
                            if (*v199 == -1) {
                                goto lab_0x38300;
                            } else {
                                goto lab_0x381d0;
                            }
                        }
                    }
                }
            } else {
                goto lab_0x37f04;
            }
        }
        char v200 = *(char *)&g179; // 0x38460
        v46 = v200;
        if (*(char *)&g71 == 0) {
            goto lab_0x38004;
        } else {
            // 0x3846c
            if ((*(char *)&g70 || v200) == 0 == g28 < (char *)7) {
                goto lab_0x38294_2;
            } else {
                // 0x3849c
                snprintf((char *)&str2, 2048, "Stratum select failed on pool %d with value %d", v109, v109);
                function_1ccec(7, &str2, 0);
                v46 = *(char *)&g179;
                goto lab_0x38004;
            }
        }
    }
  lab_0x38604:;
    int32_t v201 = (int32_t)"wait_lpcurrent"; // 0x3861c
    int32_t * v202 = __errno_location(); // 0x3861c
    int32_t v203 = 0x26f4; // 0x3861c
    goto lab_0x3853c;
  lab_0x392a4:;
    char * v208 = v85; // 0x392ac
    int32_t v210 = v40; // 0x392ac
    int32_t v214 = v61; // 0x392ac
    int32_t v209 = v30; // 0x392ac
    goto lab_0x392b0;
  lab_0x37f04:;
    int32_t v307 = v75;
    int32_t v308 = v71;
    int32_t v309 = v65;
    int32_t v310 = v56;
    int32_t v311 = v48;
    int32_t v312 = v94;
    int32_t v313 = v81;
    char * v314 = v89;
    char * v315 = v314; // 0x37f0c
    int32_t v316 = v313; // 0x37f0c
    int32_t v317 = v312; // 0x37f0c
    int32_t v318 = v38; // 0x37f0c
    int32_t v319 = v42; // 0x37f0c
    int32_t v320 = v311; // 0x37f0c
    int32_t v321 = v310; // 0x37f0c
    int32_t v322 = v309; // 0x37f0c
    int32_t v323 = v308; // 0x37f0c
    int32_t v324 = v307; // 0x37f0c
    int32_t v325 = v32; // 0x37f0c
    if (*v12 != 0) {
        int32_t v326 = function_2c214(); // 0x38238
        *v12 = 0;
        str2 = v326;
        function_31d90(a1, v326);
        *(char *)(str2 + 280) = 1;
        function_36458(str2, v326, 0, 1, (int32_t)&g306);
        function_28ffc(v11, (int32_t)"cgminer.c", (int32_t)"stratum_rthread", 0x1dd8);
        v315 = v314;
        v316 = v313;
        v317 = v312;
        v318 = (int32_t)"cgminer.c";
        v319 = (int32_t)"stratum_rthread";
        v320 = v311;
        v321 = v310;
        v322 = v309;
        v323 = v308;
        v324 = v307;
        v325 = v11;
    }
    goto lab_0x37f10;
  lab_0x37f10:
    // 0x37f10
    free((int32_t *)v320);
    v87 = v315;
    v79 = v316;
    v93 = v317;
    v37 = v318;
    v41 = v319;
    v54 = v321;
    v63 = v322;
    v70 = v323;
    v74 = v324;
    v28 = v325;
    if (*v4 != 0) {
        // 0x37f28
        function_20258(a1, (int32_t)&g306, (int32_t)&g306);
        // 0x37f2c
        __asm_vpop_11(v2, v3);
        return 0;
    }
    goto lab_0x37e34;
  lab_0x38300:;
    int32_t v327 = v34;
    int32_t v328 = v77;
    int32_t v329 = v73;
    int32_t v330 = v67;
    int32_t v331 = v58;
    int32_t v332 = v50;
    int32_t v333 = v44;
    int32_t v334 = v96;
    int32_t v335 = v83;
    char * v336 = v91;
    v89 = v336;
    v81 = v335;
    v94 = v334;
    v38 = v332;
    v42 = v333;
    v48 = v332;
    v56 = v331;
    v65 = v330;
    v71 = v329;
    v75 = v328;
    v32 = v327;
    if (function_1ff10() == 0) {
        char v337 = *(char *)&g70; // 0x38330
        v315 = v336;
        v316 = v335;
        v317 = v334;
        v318 = v332;
        v319 = v333;
        v320 = v332;
        v321 = v331;
        v322 = v330;
        v323 = v329;
        v324 = v328;
        v325 = v327;
        if ((v337 | *(char *)&g179) == 0 != g28 < (char *)6) {
            // 0x38350
            snprintf((char *)&str2, 2048, "Unknown stratum msg: %s", (char *)v332);
            function_1ccec(6, &str2, 0);
            v315 = v336;
            v316 = v335;
            v317 = v334;
            v318 = v11;
            v319 = 0;
            v320 = v332;
            v321 = v331;
            v322 = v330;
            v323 = v329;
            v324 = v328;
            v325 = v11;
        }
        goto lab_0x37f10;
    } else {
        goto lab_0x37f04;
    }
  lab_0x383b0:;
    int32_t v338; // 0x37db0
    int32_t v339; // 0x37db0
    int32_t v340; // 0x37db0
    if (v108 == 0) {
        int32_t * mem = malloc(17); // 0x384f0
        int32_t v341 = (int32_t)mem; // 0x384f0
        v338 = (int32_t)"id";
        v339 = v9;
        v340 = v341;
        if (mem != NULL) {
            // 0x384fc
            *mem = 0x6b6e7528;
            *(int32_t *)(v341 + 4) = 0x6e776f6e;
            *(int32_t *)(v341 + 8) = 0x61657220;
            *(int32_t *)(v341 + 12) = 0x296e6f73;
            *(char *)(v341 + 16) = 0;
            v338 = 0x6e776f6e;
            v339 = 0x61657220;
            v340 = v341;
        }
    } else {
        // 0x383bc
        v338 = 3;
        v339 = v9;
        v340 = function_44264(v108, 3);
    }
    int32_t v342 = v340;
    char v343 = *(char *)&g70; // 0x383e4
    int32_t v344 = v338; // 0x383d8
    int32_t v345 = v339; // 0x383d8
    int32_t v346 = v29; // 0x383d8
    if ((v343 | *(char *)&g179) == 0 != g28 < (char *)6) {
        // 0x38404
        snprintf((char *)&str2, 2048, "JSON-RPC non method decode failed: %s", (char *)v342);
        function_1ccec(6, &str2, 0);
        v344 = v11;
        v345 = 0;
        v346 = v11;
    }
    // 0x38430
    free((int32_t *)v342);
    int32_t * v347 = (int32_t *)(v106 + 4);
    v20 = v347;
    v90 = v88;
    v82 = v80;
    v95 = v19;
    v35 = &g306;
    v39 = v344;
    v43 = v345;
    v49 = v105;
    v57 = v55;
    v66 = v64;
    v72 = v15;
    v76 = v14;
    v33 = v346;
    v91 = v88;
    v83 = v80;
    v96 = v19;
    v44 = v345;
    v50 = v105;
    v58 = v55;
    v67 = v64;
    v73 = v15;
    v77 = v14;
    v34 = v346;
    if (*v347 == -1) {
        goto lab_0x38300;
    } else {
        goto lab_0x381d0;
    }
  lab_0x381d0:;
    int32_t v348 = v33;
    int32_t v349 = v76;
    int32_t v350 = v72;
    int32_t v351 = v66;
    int32_t v352 = v57;
    int32_t v353 = v49;
    int32_t v354 = v95;
    int32_t v355 = v82;
    char * v356 = v90;
    __asm_dmb(v35, v39, v43, v106);
    int32_t v357 = *v20;
    int32_t v358 = v357 - 1; // 0x381e0
    while (__asm_strex(v358, v357) != 0) {
        // 0x381dc
        v357 = *v20;
        v358 = v357 - 1;
    }
    // 0x381f0
    v91 = v356;
    v83 = v355;
    v96 = v354;
    v44 = v358;
    v50 = v353;
    v58 = v352;
    v67 = v351;
    v73 = v350;
    v77 = v349;
    v34 = v348;
    if (v358 == 0) {
        // 0x381f8
        function_47c24(v106);
        v91 = v356;
        v83 = v355;
        v96 = v354;
        v44 = 0;
        v50 = v353;
        v58 = v352;
        v67 = v351;
        v73 = v350;
        v77 = v349;
        v34 = v348;
    }
    goto lab_0x38300;
  lab_0x38004:
    // 0x38004
    if ((*(char *)&g70 || v46) == 0) {
        // 0x38294
        goto lab_0x38294_2;
    } else {
        goto lab_0x38020;
    }
  lab_0x38020:
    // 0x38020
    snprintf((char *)&str2, 2048, "Stratum connection to pool %d interrupted", v11);
    function_1ccec(5, &str2, 0);
    goto lab_0x3804c;
  lab_0x38294_2:;
    // 0x38294
    char * v359; // 0x37db0
    char * v360 = v359;
    if (v360 > (char *)4) {
        goto lab_0x38020;
    } else {
        goto lab_0x3804c;
    }
  lab_0x3804c:
    // 0x3804c
    v17 = *v13 + 1;
    *v13 = v17;
    v16 = g203 + 1;
    g203 = v16;
    if (pthread_mutex_lock(mutex) != 0) {
        // 0x38524
        v201 = (int32_t)"supports_resume";
        v202 = __errno_location();
        v203 = 0x1d62;
        goto lab_0x3853c;
    }
    // 0x38080
    int32_t format; // 0x37db0
    int32_t * v206; // 0x37db0
    int32_t v205; // 0x37db0
    char * v204; // 0x37db0
    if (pthread_rwlock_rdlock(rwlock) != 0) {
        // 0x38574
        v204 = "supports_resume";
        v205 = 0x1d62;
        format = (int32_t)"WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d";
        v206 = __errno_location();
        goto lab_0x38550;
    }
    // 0x38094
    if (pthread_mutex_unlock(mutex) != 0) {
        // 0x385a4
        v99 = (int32_t)"supports_resume";
        v98 = __errno_location();
        v97 = 0x1d62;
        goto lab_0x385bc;
    }
    // 0x380a4
    if (pthread_rwlock_unlock(rwlock) != 0) {
        // 0x385d4
        v204 = "supports_resume";
        v205 = 0x1d64;
        format = (int32_t)"WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d";
        v206 = __errno_location();
        goto lab_0x38550;
    }
    // 0x380b8
    function_1da28();
    if (*(int32_t *)(a1 + 636) == 0) {
        // 0x38138
        function_31024(a1, v17, v16, (int32_t)&g2);
        goto lab_0x380e4;
    } else {
        // 0x380d0
        if (g219 == 0) {
            goto lab_0x380e4;
        } else {
            // 0x38138
            function_31024(a1, v17, v16, (int32_t)g219);
            goto lab_0x380e4;
        }
    }
  lab_0x380e4:
    // 0x380e4
    function_2ff3c(a1);
    if (function_2e47c() == a1) {
        // 0x3851c
        function_2ae68();
    }
    // 0x380f8
    if (function_24a2c(a1) == 0) {
        function_306e8(a1);
        if (*v4 != 0) {
            // 0x37f2c
            __asm_vpop_11(v2, v3);
            return 0;
        }
        // 0x3811c
        function_1f7f8(0x1388);
        while (function_24a2c(a1) == 0) {
            // 0x38108
            function_306e8(a1);
            if (*v4 != 0) {
                // 0x37f2c
                __asm_vpop_11(v2, v3);
                return 0;
            }
            // 0x3811c
            function_1f7f8(0x1388);
        }
    }
    // 0x37e24
    v24 = v11;
    v60 = v64;
    v52 = v55;
    v78 = v80;
    v84 = v88;
    if (*v4 != 0) {
        // 0x37f28
        function_20258(a1, (int32_t)&g306, (int32_t)&g306);
        // 0x37f2c
        __asm_vpop_11(v2, v3);
        return 0;
    }
    goto lab_0x37e34_2;
  lab_0x3853c:
    // 0x3853c
    v204 = (char *)v201;
    v205 = v203;
    format = (int32_t)"WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d";
    v206 = v202;
    goto lab_0x38550;
  lab_0x38550:;
    int32_t v207 = *v206;
    snprintf((char *)&str2, 2048, (char *)format, v207, (struct timeval *)"cgminer.c", v204, v205);
  lab_0x3855c:
    // 0x3855c
    function_1ccec(3, &str2, 1);
    function_2ab30(1, 1);
    // UNREACHABLE
  lab_0x392b0:
    // 0x392b0
    free((int32_t *)v208);
    free((int32_t *)*(int32_t *)v209);
    g124 = v210;
    char * v211 = v208; // 0x392d0
    int32_t v212 = v210; // 0x392d0
    int32_t v213 = v214; // 0x392d0
    int32_t v215 = v209; // 0x392d0
    goto lab_0x3888c;
  lab_0x38960:
    // 0x38960
    str2 = llvm_bswap_i32(*(int32_t *)(v51 + 220));
    int32_t v256 = v11; // 0x389c4
    int32_t v257 = v59; // 0x389c4
    goto lab_0x389d4;
  lab_0x389d4:;
    int32_t v258 = v256 + 1; // 0x389d4
    int32_t v259 = v257; // 0x389dc
    if (*(char *)v256 == 0) {
        int32_t v260 = v257 + 1; // 0x389c8
        v256 = v258;
        v257 = v260;
        v259 = 29;
        if (v260 == 29) {
            goto lab_0x389e0;
        } else {
            goto lab_0x389d4;
        }
    } else {
        goto lab_0x389e0;
    }
  lab_0x389e0:;
    int32_t * v261 = (int32_t *)(v51 + 376); // 0x389e4
    float64_t v262 = __asm_vldr(*v261); // 0x389e4
    int32_t v263 = *(int32_t *)(v7 - 2048 + v259); // 0x389f0
    int32_t v264 = llvm_bswap_i32(v263); // 0x389f4
    round((float64_t)(int64_t)v36);
    int32_t v265 = __asm_vmov_10(v262); // 0x389fc
    function_493c8(v265, v265, v258, v263);
    uint64_t v266 = *(int64_t *)(v51 + 232); // 0x38a10
    int32_t v267; // bp-2568, 0x37db0
    function_271e0((int32_t)(v266 / 0x100000000), (int32_t)v266, (int32_t)&v267, 16, 0);
    int32_t str5; // bp-2532, 0x37db0
    snprintf((char *)&str5, 64, "%08lx Diff %s/%llu%s", v264, &v267);
    int32_t v268 = *(int32_t *)(v51 + 260); // 0x38a70
    int32_t v269 = *(int32_t *)(function_2df8c(*(int32_t *)(v51 + 256)) + 36); // 0x38a7c
    if (v107 == 0) {
        goto lab_0x38aac;
    } else {
        int32_t v270 = *(int32_t *)v107; // 0x38a8c
        if (v270 == 5) {
            goto lab_0x393cc;
        } else {
            // 0x38a98
            if (v270 == 7 == (*(char *)(v51 + 324) != 0)) {
                goto lab_0x393cc;
            } else {
                goto lab_0x38aac;
            }
        }
    }
  lab_0x38aac:
    // 0x38aac
    if (pthread_mutex_lock(&g180) == 0) {
        int32_t v271 = g225; // 0x38ad0
        int32_t * v272 = (int32_t *)(v269 + 40); // 0x38ad8
        __asm_vldr((int32_t)(float32_t)g223);
        *v272 = *v272 + 1;
        int32_t * v273 = (int32_t *)(v268 + 16); // 0x38af0
        int32_t v274 = *v273; // 0x38af0
        *(int32_t *)&g225 = v271 + 1;
        int32_t * v275 = (int32_t *)(v268 + 20); // 0x38afc
        g226 += (int32_t)(v271 == -1);
        *v273 = v274 + 1;
        *v275 = *v275 + (int32_t)(v274 == -1);
        __asm_vldr(*(int32_t *)(v269 + 208));
        __asm_vldr(*v261);
        return &g180;
    }
    int32_t * v276 = __errno_location(); // 0x393c8
    char * v277 = (char *)3624; // 0x393c8
    goto lab_0x3936c;
  lab_0x39174:
    // 0x39174
    snprintf((char *)&str2, 2048, "Accepted untracked stratum share from pool %d", v11);
    function_1ccec(5, &str2, 0);
    v27 = v11;
    goto lab_0x391a0;
  lab_0x3907c:
    // 0x3907c
    snprintf((char *)&str2, 2048, "Rejected untracked stratum share from pool %d", v11);
    function_1ccec(5, &str2, 0);
    v26 = v11;
    goto lab_0x390a8;
  lab_0x393cc:
    // 0x393cc
    if (pthread_mutex_lock(&g180) == 0) {
        int32_t v302 = g198; // 0x393ec
        int32_t * v303 = (int32_t *)(v269 + 36); // 0x393f0
        g198 = v302 + 1;
        *v303 = *v303 + 1;
        g199 += (int32_t)(v302 == -1);
        int32_t * v304 = (int32_t *)(v268 + 8); // 0x39414
        int32_t v305 = *v304; // 0x39414
        int32_t * v306 = (int32_t *)(v268 + 12); // 0x3941c
        __asm_vldr((int32_t)(float32_t)g210);
        *v304 = v305 + 1;
        *v306 = *v306 + (int32_t)(v305 == -1);
        __asm_vldr(*(int32_t *)(v269 + 200));
        __asm_vldr(*v261);
        return &g180;
    }
    // 0x3981c
    v276 = __errno_location();
    v277 = (char *)3561;
    goto lab_0x3936c;
  lab_0x391a0:;
    int32_t v285 = v27;
    int32_t v286 = pthread_mutex_lock(&g180); // 0x391a8
    char * v287 = (char *)&g31; // 0x391b0
    int32_t v288; // 0x37db0
    int32_t v289 = v288; // 0x391b0
    int32_t v290; // 0x37db0
    int32_t v291 = v290; // 0x391b0
    int32_t v292 = v53; // 0x391b0
    int32_t v293; // 0x37db0
    int32_t v294 = v293; // 0x391b0
    int32_t v295 = v285; // 0x391b0
    if (v286 == 0) {
        int32_t v296 = *(int32_t *)(a1 + 72); // 0x391c0
        __asm_vldr(v296);
        int32_t result = g199; // 0x391cc
        float64_t v297 = g210; // 0x391d0
        __asm_vldr((int32_t)(float32_t)v297);
        return result;
    }
    goto lab_0x3927c;
  lab_0x390a8:;
    int32_t v298 = v26;
    int32_t v299 = pthread_mutex_lock(&g180); // 0x390b0
    v287 = (char *)&g31;
    v289 = v288;
    v291 = v290;
    v292 = v53;
    v294 = v293;
    v295 = v298;
    if (v299 == 0) {
        int32_t v300 = *(int32_t *)(a1 + 80); // 0x390d0
        __asm_vldr(v300);
        float64_t v301 = g223; // 0x390d4
        __asm_vldr((int32_t)(float32_t)v301);
        int32_t result2 = *(int32_t *)(a1 + 20); // 0x390e0
        return result2;
    }
    goto lab_0x3927c;
  lab_0x3936c:;
    int32_t v278 = *v276; // 0x39374
    snprintf((char *)&str2, 2048, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", v278, v277);
    goto lab_0x3855c;
  lab_0x3927c:;
    int32_t v279 = v100;
    int32_t v280 = v68;
    char * v281 = v102;
    int32_t * v282 = (int32_t *)(v280 + 8);
    int32_t v283 = *v282; // 0x3927c
    v208 = v281;
    v210 = 0;
    v214 = v280;
    v209 = v279;
    int32_t * v225; // 0x37db0
    int32_t v232; // 0x37db0
    int32_t v223; // 0x37db0
    int32_t v230; // 0x37db0
    char * v228; // 0x37db0
    if (v283 == 0) {
        goto lab_0x392b0;
    } else {
        int32_t * v284 = (int32_t *)(v101 + 16);
        v225 = v282;
        v228 = v281;
        v223 = v283;
        v230 = v280;
        v232 = v279;
        if (v280 == *v284 + v104) {
            // 0x39288
            v23 = (int32_t *)(v280 + 4);
            v21 = v284;
            v86 = v281;
            v45 = 0;
            v62 = v280;
            v31 = v279;
            goto lab_0x392d4;
        } else {
            goto lab_0x39298;
        }
    }
  lab_0x3888c:;
    int32_t v216 = v213;
    int32_t * v217 = (int32_t *)(a1 + 732); // 0x3888c
    *v217 = *v217 - 1;
    int32_t v218 = pthread_mutex_unlock(&g123); // 0x3889c
    v85 = v211;
    v40 = v212;
    v61 = v216;
    v30 = v215;
    if (v218 == 0) {
        // 0x388a8
        function_1da28();
        int32_t v219 = *(int32_t *)(v216 + 36); // 0x388cc
        int32_t v220 = time(NULL) - *(int32_t *)(v216 + 48); // 0x388dc
        v36 = v220;
        v51 = v219;
        v59 = 0;
        if (*(char *)&g71 == 0 == v220 < 1) {
            goto lab_0x38960;
        } else {
            char v221 = *(char *)&g70; // 0x3890c
            v36 = v220;
            v51 = v219;
            v59 = 0;
            if ((v221 | *(char *)&g179) == 0 == g28 < (char *)6) {
                goto lab_0x38960;
            } else {
                int32_t v222 = *(int32_t *)*(int32_t *)(v219 + 260); // 0x38948
                snprintf((char *)&str2, 2048, "Pool %d stratum share result lag time %d seconds", v222, v220);
                v36 = function_1ccec(6, &str2, 0);
                v51 = v219;
                v59 = 0;
                goto lab_0x38960;
            }
        }
    } else {
        goto lab_0x392a4;
    }
  lab_0x39298:
    // 0x39298
    g124 = v223;
    int32_t * v224 = v225; // 0x392a0
    int32_t v226 = v223; // 0x392a0
    char * v227 = v228; // 0x392a0
    int32_t v229 = v230; // 0x392a0
    int32_t v231 = v232; // 0x392a0
    goto lab_0x387f0;
  lab_0x392d4:;
    int32_t v251 = v31;
    int32_t v252 = v62;
    char * v253 = v86;
    *v21 = v45 + v103;
    int32_t v254 = *v23; // 0x392e0
    if (v254 == 0) {
        int32_t * v255 = (int32_t *)(v252 + 8);
        v225 = v255;
        v228 = v253;
        v223 = *v255;
        v230 = v252;
        v232 = v251;
        goto lab_0x39298;
    } else {
        // 0x392f0
        v22 = (int32_t *)(*(int32_t *)v251 + 20);
        v92 = v253;
        v47 = v254;
        v69 = v252;
        v25 = v251;
        goto lab_0x387e0;
    }
  lab_0x387f0:;
    int32_t v233 = v229;
    int32_t v234 = *v224; // 0x387f4
    int32_t * v235 = (int32_t *)v226; // 0x38800
    int32_t v236 = *v235; // 0x38800
    int32_t v237 = v236; // 0x38804
    if (v234 == 0) {
        goto lab__critedge_2;
    } else {
        int32_t v238 = *(int32_t *)(v233 + 4); // 0x38808
        *(int32_t *)(v234 + 4 + *(int32_t *)(v236 + 20)) = v238;
        v237 = *v235;
        goto lab__critedge_2;
    }
  lab__critedge_2:;
    int32_t v239 = 12 * (*(int32_t *)(v237 + 4) - 1 & *(int32_t *)(v233 + 28)); // 0x38830
    int32_t * v240 = (int32_t *)(*(int32_t *)v237 + 4 + v239); // 0x38838
    *v240 = *v240 - 1;
    int32_t * v241 = (int32_t *)(*(int32_t *)*v235 + v239); // 0x3884c
    int32_t * v242 = (int32_t *)(v233 + 16);
    if (*v241 == v233) {
        *v241 = *v242;
        goto lab__critedge__crit_edge;
    } else {
        goto lab__critedge__crit_edge;
    }
  lab_0x387e0:;
    int32_t * v243 = (int32_t *)(v69 + 8);
    *(int32_t *)(v47 + 8 + *v22) = *v243;
    v224 = v243;
    v226 = g124;
    v227 = v92;
    v229 = v69;
    v231 = v25;
    goto lab_0x387f0;
  lab__critedge__crit_edge:;
    int32_t * v244 = (int32_t *)(v233 + 12); // 0x3885c
    int32_t v245 = *v244; // 0x3885c
    int32_t v246 = *v242; // 0x38860
    int32_t v247 = v246; // 0x38868
    if (v245 == 0) {
        goto lab__critedge72;
    } else {
        *(int32_t *)(v245 + 16) = v246;
        v247 = *v242;
        goto lab__critedge72;
    }
  lab__critedge72:;
    int32_t v248 = v247;
    if (v248 == 0) {
        goto lab__thread79;
    } else {
        *(int32_t *)(v248 + 12) = *v244;
        goto lab__thread79;
    }
  lab__thread79:;
    int32_t v249 = *v235; // 0x3887c
    int32_t * v250 = (int32_t *)(v249 + 12); // 0x38880
    *v250 = *v250 - 1;
    v211 = v227;
    v212 = v249;
    v213 = v233;
    v215 = v231;
    goto lab_0x3888c;
  lab_0x385bc:
    // 0x385bc
    v204 = (char *)v99;
    v205 = v97;
    format = (int32_t)"WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d";
    v206 = v98;
    goto lab_0x38550;
}

// Address range: 0x39848 - 0x3a010
int32_t function_39848(int32_t a1) {
    // 0x39848
    int32_t v1; // 0x39848
    int32_t v2; // 0x39848
    int32_t str; // bp-2088, 0x39848
    if (*(char *)&g71 != 0) {
        char v3 = *(char *)&g70; // 0x39888
        if ((v3 | *(char *)&g179) == 0 != g28 < (char *)7) {
            int32_t v4 = *(int32_t *)*(int32_t *)(a1 + 260); // 0x398bc
            snprintf((char *)&str, 2048, "Pushing work from pool %d to hash queue", v4);
            function_1ccec(7, &str, 0);
            v1 = &str;
            v2 = 0;
        }
    }
    // 0x398d4
    *(int32_t *)(a1 + 336) = g130;
    int32_t v5; // 0x39848
    function_36458(a1, v1, v2, g130, v5);
    int32_t * v6 = (int32_t *)(*(int32_t *)(a1 + 260) + 68); // 0x398f4
    *v6 = *v6 + 1;
    int32_t v7; // 0x39848
    int32_t format; // 0x39848
    int32_t * v8; // 0x39848
    int32_t v9; // 0x39848
    if (pthread_mutex_lock((int32_t *)g100) == 0) {
        // 0x3990c
        if (*(char *)(a1 + 273) == 0) {
            // 0x39ef0
            if (*(int32_t *)(a1 + 276) != 0) {
                g126++;
            }
        }
        unsigned char v10 = *(char *)(g215 + 8); // 0x39928
        v7 = g215;
        if (v10 == 0) {
            int32_t v11 = a1 + 340; // 0x39934
            unsigned char v12 = *(char *)v11; // 0x39934
            unsigned char v13 = *(char *)(a1 + 343); // 0x3993c
            unsigned char v14 = *(char *)(a1 + 342); // 0x39944
            unsigned char v15 = *(char *)(a1 + 341); // 0x39950
            int32_t v16 = g119; // 0x39958
            int32_t v17 = (int32_t)v12 + 0x112410d + 0x1000000 * (int32_t)v13 + 0x10000 * (int32_t)v14 + 256 * (int32_t)v15 ^ ((int32_t)&g171 | 0xf76d); // 0x3997c
            uint32_t v18 = -0x60b6453a - v17 ^ 256 * v17; // 0x3998c
            *(int32_t *)(a1 + 364) = v11;
            uint32_t v19 = -0x112410d - v17 - v18 ^ v18 / 0x2000; // 0x399a0
            *(int32_t *)(a1 + 368) = 4;
            int32_t v20 = v17 - v18 - v19 ^ v19 / 0x1000; // 0x399b0
            uint32_t v21 = v18 - v19 - v20 ^ 0x10000 * v20; // 0x399bc
            uint32_t v22 = v19 - v20 - v21 ^ v21 / 32; // 0x399c8
            int32_t v23 = v20 - v21 - v22 ^ v22 / 8; // 0x399d4
            uint32_t v24 = v21 - v22 - v23 ^ 1024 * v23; // 0x399e0
            int32_t v25 = v22 - v23 - v24 ^ v24 / 0x8000; // 0x399e8
            *(int32_t *)(a1 + 372) = v25;
            int32_t * v26; // 0x39848
            int32_t * v27; // 0x39848
            int32_t v28; // 0x39848
            int32_t v29; // 0x39848
            if (v16 == 0) {
                // 0x39f08
                *(int32_t *)(a1 + 352) = 0;
                *(int32_t *)(a1 + 348) = 0;
                g119 = a1;
                int32_t * mem = malloc(44); // 0x39f18
                int32_t v30 = (int32_t)mem; // 0x39f18
                int32_t v31 = a1 + 344;
                int32_t * v32 = (int32_t *)v31;
                *v32 = v30;
                if (mem == NULL) {
                    // 0x3a008
                    exit(-1);
                    return &g306;
                }
                int32_t * v33 = (int32_t *)(v30 + 12);
                memset(v33, 0, 32);
                *(int32_t *)(v30 + 4) = 32;
                *(int32_t *)(v30 + 16) = v31;
                *(int32_t *)(v30 + 8) = 5;
                *(int32_t *)(v30 + 20) = 344;
                int32_t * mem2 = calloc(384, 1); // 0x39f64
                *mem = (int32_t)mem2;
                if (mem2 == NULL) {
                    // 0x3a008
                    exit(-1);
                    return &g306;
                }
                // 0x39f74
                *(int32_t *)(v30 + 40) = -0x5feee01f;
                v27 = v32;
                v26 = v33;
                v28 = v31;
                v29 = v30;
            } else {
                int32_t * v34 = (int32_t *)(v16 + 344);
                int32_t v35 = a1 + 344; // 0x399f8
                *(int32_t *)(a1 + 352) = (int32_t)v10;
                *(int32_t *)v35 = *v34;
                int32_t v36 = *v34; // 0x39a04
                int32_t v37 = *(int32_t *)(v36 + 20); // 0x39a0c
                *(int32_t *)(a1 + 348) = *(int32_t *)(v36 + 16) - v37;
                *(int32_t *)(*(int32_t *)(*v34 + 16) + 8) = a1;
                *(int32_t *)(*v34 + 16) = v35;
                int32_t v38 = *v34; // 0x39a2c
                v27 = v34;
                v26 = (int32_t *)(v38 + 12);
                v28 = v35;
                v29 = v38;
            }
            int32_t * v39 = v26;
            *v39 = *v39 + 1;
            uint64_t v40 = *(int64_t *)*v27; // 0x39a44
            int32_t v41 = 12 * ((int32_t)v40 - 1 & v25); // 0x39a54
            int32_t v42 = v41 + 4;
            int32_t * v43 = (int32_t *)(v42 + (int32_t)(v40 / 0x100000000)); // 0x39a5c
            *v43 = *v43 + 1;
            int32_t v44 = *(int32_t *)*v27; // 0x39a6c
            *(int32_t *)(a1 + 356) = 0;
            *(int32_t *)(a1 + 360) = *(int32_t *)(v44 + v41);
            int32_t v45 = *(int32_t *)*v27 + v41; // 0x39a84
            int32_t v46 = *(int32_t *)v45; // 0x39a84
            int32_t v47 = v45; // 0x39a90
            if (v46 != 0) {
                *(int32_t *)(v46 + 12) = v28;
                v47 = *(int32_t *)*v27;
            }
            // .critedge.thread
            *(int32_t *)(v47 + (v46 == 0 ? 0 : v41)) = v28;
            uint64_t v48 = *(int64_t *)(*(int32_t *)*(int32_t *)(g119 + 344) + v42); // 0x39ab4
            if (10 * (int32_t)v48 + 10 > (int32_t)(v48 / 0x100000000)) {
                goto lab_0x39c88;
            } else {
                int32_t * v49 = (int32_t *)(a1 + 344); // 0x39ac8
                int32_t v50 = *v49; // 0x39ac8
                if (*(int32_t *)(v50 + 36) == 1) {
                    goto lab_0x39c88;
                } else {
                    int32_t * v51 = (int32_t *)(v50 + 4); // 0x39ad8
                    int32_t * mem3 = calloc(24 * *v51, 1); // 0x39ae8
                    if (mem3 == NULL) {
                        // 0x3a008
                        exit(-1);
                        return &g306;
                    }
                    int32_t v52 = (int32_t)mem3; // 0x39ae8
                    int32_t v53 = *v51; // 0x39af4
                    uint32_t v54 = *(int32_t *)(v50 + 12); // 0x39afc
                    int32_t v55 = *(int32_t *)(v50 + 8); // 0x39b00
                    *(int32_t *)(v50 + 24) = (v54 >> v55 + 1) + (int32_t)((2 * v53 - 1 & v54) != 0);
                    *(int32_t *)(*v49 + 28) = 0;
                    int32_t v56 = *v49; // 0x39b2c
                    int32_t v57 = *(int32_t *)(v56 + 4); // 0x39b30
                    int32_t v58 = 0; // 0x39b38
                    int32_t v59 = v56; // 0x39b38
                    if (v57 != 0) {
                        int32_t v60 = *(int32_t *)(*(int32_t *)v56 + v58); // 0x39b4c
                        int32_t v61 = v60; // 0x39b54
                        int32_t v62 = v56; // 0x39b54
                        int32_t v63 = v57; // 0x39b54
                        int32_t v64 = v29; // 0x39b54
                        int32_t v65; // 0x39848
                        int32_t v66; // 0x39848
                        int32_t * v67; // 0x39b70
                        int32_t v68; // 0x39b70
                        int32_t v69; // 0x39b80
                        int32_t * v70; // 0x39b84
                        uint32_t v71; // 0x39b88
                        uint32_t v72; // 0x39b90
                        int32_t * v73; // 0x39bc0
                        int32_t v74; // 0x39bc8
                        int32_t * v75; // 0x39b9c
                        int32_t v76; // 0x39bdc
                        int32_t v77; // 0x39848
                        if (v60 != 0) {
                            v66 = v61;
                            v67 = (int32_t *)(v66 + 16);
                            v68 = *v67;
                            v69 = 12 * (2 * v57 - 1 & *(int32_t *)(v66 + 28)) + v52;
                            v70 = (int32_t *)(v69 + 4);
                            v71 = *v70 + 1;
                            *v70 = v71;
                            v72 = *(int32_t *)(v56 + 24);
                            if (v71 != v72 && v71 >= v72) {
                                // 0x39b9c
                                v75 = (int32_t *)(v56 + 28);
                                *v75 = *v75 + 1;
                                *(int32_t *)(v69 + 8) = function_48ac8();
                            }
                            // 0x39bbc
                            *(int32_t *)(v66 + 12) = 0;
                            v73 = (int32_t *)v69;
                            *v67 = *v73;
                            v74 = *v73;
                            if (v74 != 0) {
                                *(int32_t *)(v74 + 12) = v66;
                            }
                            *v73 = v66;
                            v76 = *v49;
                            v77 = *(int32_t *)(v76 + 4);
                            v62 = v76;
                            v63 = v77;
                            v64 = 0;
                            while (v68 != 0) {
                                // 0x39b68
                                v66 = v68;
                                v65 = v76;
                                v67 = (int32_t *)(v66 + 16);
                                v68 = *v67;
                                v69 = 12 * (2 * v77 - 1 & *(int32_t *)(v66 + 28)) + v52;
                                v70 = (int32_t *)(v69 + 4);
                                v71 = *v70 + 1;
                                *v70 = v71;
                                v72 = *(int32_t *)(v65 + 24);
                                if (v71 != v72 && v71 >= v72) {
                                    // 0x39b9c
                                    v75 = (int32_t *)(v65 + 28);
                                    *v75 = *v75 + 1;
                                    *(int32_t *)(v69 + 8) = function_48ac8();
                                }
                                // 0x39bbc
                                *(int32_t *)(v66 + 12) = 0;
                                v73 = (int32_t *)v69;
                                *v67 = *v73;
                                v74 = *v73;
                                if (v74 != 0) {
                                    *(int32_t *)(v74 + 12) = v66;
                                }
                                *v73 = v66;
                                v76 = *v49;
                                v77 = *(int32_t *)(v76 + 4);
                                v62 = v76;
                                v63 = v77;
                                v64 = 0;
                            }
                        }
                        int32_t v78 = 1; // 0x39bf0
                        int32_t v79 = v78; // 0x39bfc
                        int32_t v80 = v62; // 0x39bfc
                        int32_t v81 = v63; // 0x39bfc
                        int32_t v82 = v64; // 0x39bfc
                        v58 += 12;
                        v59 = v62;
                        while (v78 < v63) {
                            // 0x39b48
                            v60 = *(int32_t *)(*(int32_t *)v80 + v58);
                            int32_t v83 = v80; // 0x39b54
                            int32_t v84 = v81; // 0x39b54
                            v61 = v60;
                            v62 = v80;
                            v63 = v81;
                            v64 = v82;
                            if (v60 != 0) {
                                v66 = v61;
                                v65 = v83;
                                v67 = (int32_t *)(v66 + 16);
                                v68 = *v67;
                                v69 = 12 * (2 * v84 - 1 & *(int32_t *)(v66 + 28)) + v52;
                                v70 = (int32_t *)(v69 + 4);
                                v71 = *v70 + 1;
                                *v70 = v71;
                                v72 = *(int32_t *)(v65 + 24);
                                if (v71 != v72 && v71 >= v72) {
                                    // 0x39b9c
                                    v75 = (int32_t *)(v65 + 28);
                                    *v75 = *v75 + 1;
                                    *(int32_t *)(v69 + 8) = function_48ac8();
                                }
                                // 0x39bbc
                                *(int32_t *)(v66 + 12) = 0;
                                v73 = (int32_t *)v69;
                                *v67 = *v73;
                                v74 = *v73;
                                if (v74 != 0) {
                                    *(int32_t *)(v74 + 12) = v66;
                                }
                                *v73 = v66;
                                v76 = *v49;
                                v77 = *(int32_t *)(v76 + 4);
                                v62 = v76;
                                v63 = v77;
                                v64 = 0;
                                while (v68 != 0) {
                                    // 0x39b68
                                    v66 = v68;
                                    v65 = v76;
                                    v67 = (int32_t *)(v66 + 16);
                                    v68 = *v67;
                                    v69 = 12 * (2 * v77 - 1 & *(int32_t *)(v66 + 28)) + v52;
                                    v70 = (int32_t *)(v69 + 4);
                                    v71 = *v70 + 1;
                                    *v70 = v71;
                                    v72 = *(int32_t *)(v65 + 24);
                                    if (v71 != v72 && v71 >= v72) {
                                        // 0x39b9c
                                        v75 = (int32_t *)(v65 + 28);
                                        *v75 = *v75 + 1;
                                        *(int32_t *)(v69 + 8) = function_48ac8();
                                    }
                                    // 0x39bbc
                                    *(int32_t *)(v66 + 12) = 0;
                                    v73 = (int32_t *)v69;
                                    *v67 = *v73;
                                    v74 = *v73;
                                    if (v74 != 0) {
                                        *(int32_t *)(v74 + 12) = v66;
                                    }
                                    *v73 = v66;
                                    v76 = *v49;
                                    v77 = *(int32_t *)(v76 + 4);
                                    v62 = v76;
                                    v63 = v77;
                                    v64 = 0;
                                }
                            }
                            // 0x39be8
                            v78 = v79 + 1;
                            v79 = v78;
                            v80 = v62;
                            v81 = v63;
                            v82 = v64;
                            v58 += 12;
                            v59 = v62;
                        }
                    }
                    // 0x39c04
                    free((int32_t *)*(int32_t *)v59);
                    int32_t * v85 = (int32_t *)(*v49 + 4); // 0x39c10
                    *v85 = 2 * *v85;
                    int32_t * v86 = (int32_t *)(*v49 + 8); // 0x39c20
                    *v86 = *v86 + 1;
                    *(int32_t *)*v49 = v52;
                    int32_t v87 = *v49; // 0x39c34
                    uint32_t v88 = *(int32_t *)(v87 + 28); // 0x39c3c
                    uint32_t v89 = *(int32_t *)(v87 + 12) / 2; // 0x39c44
                    int32_t * v90 = (int32_t *)(v87 + 32);
                    int32_t v91 = v88; // 0x39c48
                    if (v88 >= v89 == (v88 != v89)) {
                        v91 = *v90;
                    }
                    int32_t v92 = v88 == v89 | v88 < v89 ? 0 : v91;
                    *v90 = v92 + (int32_t)(v88 >= v89 == (v88 != v89));
                    int32_t v93 = *v49; // 0x39c58
                    int32_t v94 = *(int32_t *)(v93 + 32); // 0x39c5c
                    if (v94 != 0 == (v94 != 1)) {
                        *(int32_t *)(v93 + 36) = 1;
                    }
                    v7 = g215;
                    if (g119 == 0) {
                        goto lab_0x39e98;
                    } else {
                        // .dec_label_pc_39c88_crit_edge
                        goto lab_0x39c88;
                    }
                }
            }
        } else {
            goto lab_0x39e98;
        }
    } else {
        // 0x39fd8
        format = (int32_t)"WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d";
        v8 = __errno_location();
        v9 = 0x16b1;
        goto lab_0x39fb4;
    }
  lab_0x39d04:;
    // 0x39d04
    int32_t v95; // 0x39848
    int32_t v96 = v95;
    int32_t v97; // 0x39848
    int32_t v98 = v97;
    int32_t v99; // 0x39848
    int32_t v100 = v99;
    int32_t v101; // 0x39848
    int32_t v102 = v101;
    int32_t v103; // 0x39848
    int32_t v104 = v103;
    if (v104 == 0 || v100 == 0) {
        // break -> 0x39e58
        goto lab_0x39e58;
    }
    // 0x39d10
    int32_t v105; // 0x39848
    int32_t v106 = v105;
    int32_t v107 = *(int32_t *)(v100 + 8); // 0x39d10
    int32_t v108 = v96; // 0x39d18
    int32_t * v109; // 0x39848
    if (v107 != 0) {
        int32_t v110 = *v109; // 0x39d18
        int32_t v111 = *(int32_t *)(v110 + 20); // 0x39d20
        v108 = v111;
    }
    int32_t v112 = v108;
    int32_t v113 = v107 == 0 ? 0 : v112;
    int32_t v114 = v104; // 0x39848
    int32_t v115 = v102; // 0x39848
    int32_t v116 = 0; // 0x39848
    int32_t v117 = v100; // 0x39848
    int32_t v118 = v98; // 0x39848
    int32_t v119 = v112; // 0x39848
    int32_t v120 = v106; // 0x39848
    int32_t v121 = v113 + v107; // 0x39848
    goto lab_0x39d28;
  lab_0x39d7c:;
    // 0x39d7c
    int32_t v212; // 0x39848
    int32_t v178 = v212;
    int32_t v211; // 0x39848
    int32_t v181 = v211;
    int32_t v210; // 0x39848
    int32_t v179 = v210;
    int32_t v209; // 0x39848
    int32_t v176 = v209;
    int32_t v208; // 0x39848
    int32_t v180 = v208;
    int32_t v207; // 0x39848
    int32_t v177 = v207;
    int32_t v172; // 0x39848
    int32_t v213; // 0x39848
    int32_t v174; // 0x39848
    if (v177 == 0 || v179 == 0) {
        int32_t v270 = v213;
        v174 = 0;
        v172 = v270;
        if (v178 != 0) {
            int32_t v271 = *(int32_t *)(v178 + 8); // 0x39d90
            int32_t v272 = v270; // 0x39d98
            if (v271 != 0) {
                int32_t v273 = *v109; // 0x39d98
                int32_t v274 = *(int32_t *)(v273 + 20); // 0x39d9c
                v272 = v274;
            }
            int32_t v275 = v272;
            int32_t v276 = v271 == 0 ? 0 : v275 + v271;
            v174 = v276;
            v172 = v275;
        }
        goto lab_0x39da4;
    } else {
        int32_t v277 = *v109; // 0x39dfc
        int32_t v278 = *(int32_t *)(v277 + 20); // 0x39e00
        int32_t v279 = *(int32_t *)(v178 + 264 - v278); // 0x39e10
        int32_t v280 = *(int32_t *)(v179 + 264 - v278); // 0x39e14
        if (v279 - v280 < 1) {
            // 0x39e3c
            v174 = 0;
            v172 = v279;
            if (v178 != 0) {
                int32_t v281 = *(int32_t *)(v178 + 8); // 0x39e44
                int32_t v282 = v281 == 0 ? 0 : v281 + v278;
                v174 = v282;
                v172 = v281;
            }
            goto lab_0x39da4;
        } else {
            int32_t v283 = *(int32_t *)(v179 + 8); // 0x39e24
            int32_t v284 = v283 == 0 ? 0 : v283 + v278;
            v114 = v177;
            v115 = v180;
            v116 = v176;
            v117 = v179;
            v118 = v181;
            v119 = v278;
            v120 = v178;
            v121 = v284;
            goto lab_0x39d28;
        }
    }
  lab_0x39d28:;
    int32_t v122 = v121;
    int32_t v123 = v120;
    int32_t v124 = v119;
    int32_t v125 = v117;
    int32_t v126 = v116;
    int32_t v127 = v115;
    int32_t v128 = v114;
    int32_t v129 = v128 - 1; // 0x39d2c
    int32_t v130 = v129; // 0x39d38
    int32_t v131 = v125; // 0x39d38
    int32_t v132 = v126; // 0x39d38
    int32_t v133 = v122; // 0x39d38
    int32_t v134 = v124; // 0x39d38
    int32_t v135 = v123; // 0x39d38
    int32_t v136 = v122; // 0x39d38
    int32_t v137; // 0x39848
    int32_t v138; // 0x39848
    int32_t v139; // 0x39848
    int32_t v140; // 0x39848
    int32_t v141; // 0x39848
    int32_t v142; // 0x39848
    int32_t v143; // 0x39848
    int32_t v144; // 0x39848
    int32_t v145; // 0x39848
    int32_t v146; // 0x39848
    int32_t v147; // 0x39848
    int32_t v148; // 0x39848
    int32_t v149; // 0x39848
    int32_t v150; // 0x39848
    if (v127 == 0) {
        goto lab_0x39dec;
    } else {
        int32_t v151 = v118;
        int32_t v152 = v127 == 0 ? v122 : v125;
        int32_t v153 = *v109; // 0x39d3c
        int32_t v154 = *(int32_t *)(v153 + 20); // 0x39d44
        int32_t v155 = v152 - v154; // 0x39d48
        *(int32_t *)(v127 + 8) = v155;
        v139 = v129;
        v142 = v126;
        v145 = v122;
        v146 = v151;
        v148 = v155;
        v149 = v123;
        v137 = v122;
        v140 = v129;
        v141 = v127;
        v143 = v126;
        v144 = v125;
        v147 = v151;
        v150 = v123;
        v138 = v122;
        if (v152 == 0) {
            goto lab_0x39cfc;
        } else {
            goto lab_0x39d5c;
        }
    }
  lab_0x39dec:;
    int32_t v156 = v136;
    int32_t v157 = v135;
    int32_t v158 = v134;
    int32_t v159 = v133;
    int32_t v160 = v132;
    int32_t v161 = v131;
    int32_t v162 = v130;
    v139 = v162;
    v142 = v160;
    v145 = v159;
    v146 = 0;
    v148 = v158;
    v149 = v157;
    v137 = v156;
    int32_t v163 = v162; // 0x39df4
    int32_t v164 = v161; // 0x39df4
    int32_t v165 = v160; // 0x39df4
    int32_t v166 = v159; // 0x39df4
    int32_t v167 = v161; // 0x39df4
    int32_t v168 = 0; // 0x39df4
    int32_t v169 = v157; // 0x39df4
    int32_t v170 = v156; // 0x39df4
    if (v161 == 0) {
        goto lab_0x39cfc;
    } else {
        goto lab_0x39d70;
    }
  lab_0x39da4:;
    int32_t v171 = v172;
    int32_t v173 = v174;
    int32_t v175 = v176 - 1; // 0x39da8
    v130 = v177;
    v131 = v178;
    v132 = v175;
    v133 = v179;
    v134 = v173;
    v135 = v173;
    v136 = v171;
    if (v180 == 0) {
        goto lab_0x39dec;
    } else {
        if (v178 == 0) {
            *(int32_t *)(v180 + 8) = 0;
            v139 = v177;
            v142 = v175;
            v145 = v179;
            v146 = v181;
            v148 = v173;
            v149 = v173;
            v137 = v171;
            goto lab_0x39cfc;
        } else {
            int32_t v182 = *v109; // 0x39dc4
            int32_t v183 = *(int32_t *)(v182 + 20); // 0x39dd0
            *(int32_t *)(v180 + 8) = v178 - v183;
            v140 = v177;
            v141 = v180;
            v143 = v175;
            v144 = v178;
            v147 = v181;
            v150 = v173;
            v138 = v179;
            goto lab_0x39d5c;
        }
    }
  lab_0x39cfc:;
    int32_t v184 = v137;
    int32_t v185 = v149;
    int32_t v186 = v148;
    int32_t v187 = v146;
    int32_t v188 = v145;
    int32_t v189 = v142;
    int32_t v190 = v139;
    int32_t v191 = v190; // 0x39848
    int32_t v192 = 0; // 0x39848
    int32_t v193 = v189; // 0x39848
    int32_t v194 = v188; // 0x39848
    int32_t v195 = v187; // 0x39848
    int32_t v196 = v186; // 0x39848
    int32_t v197 = v185; // 0x39848
    int32_t v198 = v184; // 0x39848
    goto lab_0x39cfc_2;
  lab_0x39d70:;
    int32_t v214 = v170;
    int32_t v215 = v169;
    int32_t v216 = v168;
    int32_t v217 = v167;
    int32_t v218 = v166;
    int32_t v219 = v165;
    int32_t v220 = v164;
    int32_t v221 = v163;
    *(int32_t *)(v220 + 4) = v216;
    v103 = v221;
    v101 = v220;
    v99 = v218;
    v97 = v217;
    v95 = v216;
    v105 = v215;
    v207 = v221;
    v208 = v220;
    v209 = v219;
    v210 = v218;
    v211 = v217;
    v212 = v215;
    v213 = v214;
    if (v219 == 0) {
        goto lab_0x39d04;
    } else {
        goto lab_0x39d7c;
    }
  lab_0x39d5c:;
    int32_t v222 = v138;
    int32_t v223 = v150;
    int32_t v224 = v147;
    int32_t v225 = v144;
    int32_t v226 = v143;
    int32_t v227 = v141;
    int32_t v228 = v140;
    int32_t v229 = *v109; // 0x39d5c
    int32_t v230 = *(int32_t *)(v229 + 20); // 0x39d60
    v163 = v228;
    v164 = v225;
    v165 = v226;
    v166 = v222;
    v167 = v224;
    v168 = v227 - v230;
    v169 = v223;
    v170 = v222;
    goto lab_0x39d70;
  lab_0x39e98:
    // 0x39e98
    pthread_cond_broadcast((int32_t *)(v7 + 40));
    if (pthread_mutex_unlock((int32_t *)g100) == 0) {
        // 0x39eb0
        return function_1da28();
    }
    // 0x39f88
    format = (int32_t)"WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d";
    v8 = __errno_location();
    v9 = 0x16c3;
    goto lab_0x39fb4;
  lab_0x39fb4:;
    int32_t v231 = *v8;
    snprintf((char *)&str, 2048, (char *)format, v231, (struct timeval *)"cgminer.c", "hash_push", v9);
    function_1ccec(3, &str, 1);
    function_2ab30(1, 1);
    // UNREACHABLE
    // 0x39c80
    goto lab_0x39c88;
  lab_0x39c88:;
    // 0x39c88
    int32_t v232; // 0x39848
    while (true) {
        // 0x39c90
        int32_t v233; // 0x39848
        int32_t v234 = v233;
        int32_t v235; // 0x39848
        int32_t v236 = v235;
        int32_t v237; // 0x39848
        int32_t v238 = v237;
        int32_t v239 = 0; // 0x39c9c
        int32_t v240 = v236; // 0x39c9c
        int32_t v241 = 0; // 0x39c9c
        int32_t v242 = 0; // 0x39c9c
        int32_t v243 = v234; // 0x39c9c
        int32_t v244; // 0x39848
        int32_t v245; // 0x39ca4
        while (true) {
            int32_t v246 = v243;
            v244 = v242;
            int32_t v247 = v241;
            int32_t v248 = v240;
            int32_t v249 = v239;
            int32_t v250 = 0; // 0x39ca8
            int32_t v251 = v248; // 0x39ca8
            if (v238 != 0) {
                int32_t v252 = *(int32_t *)(v248 + 8); // 0x39cac
                v250 = 1;
                v251 = 0;
                if (v252 != 0) {
                    int32_t v253 = *v109; // 0x39cb8
                    int32_t v254 = *(int32_t *)(v253 + 20); // 0x39cbc
                    int32_t v255 = v254 + v252; // 0x39cc0
                    int32_t v256 = 1; // 0x39cc4
                    int32_t v257 = v255; // 0x39cc4
                    v250 = 1;
                    v251 = 0;
                    if (v255 != 0) {
                        int32_t v258 = v257;
                        int32_t v259 = v256;
                        v250 = v238;
                        v251 = v258;
                        while (v259 != v238) {
                            int32_t v260 = *(int32_t *)(v258 + 8); // 0x39cd0
                            int32_t v261 = v259 + 1; // 0x39cd4
                            v250 = v261;
                            v251 = 0;
                            if (v260 == 0) {
                                // break -> 0x39cf4
                                break;
                            }
                            int32_t v262 = v260 + v254; // 0x39ce0
                            v256 = v261;
                            v257 = v262;
                            v250 = v261;
                            v251 = 0;
                            if (v262 == 0) {
                                // break -> 0x39cf4
                                break;
                            }
                            v258 = v257;
                            v259 = v256;
                            v250 = v238;
                            v251 = v258;
                        }
                    }
                }
            }
            // 0x39cf4
            v245 = v244 + 1;
            int32_t v263 = v251;
            int32_t v264 = v250;
            v191 = v238;
            v192 = v249;
            v193 = v264;
            v194 = v263;
            v195 = v247;
            v196 = v246;
            v197 = v248;
            v198 = v263;
            while (true) {
              lab_0x39cfc_2:;
                int32_t v199 = v198;
                int32_t v200 = v197;
                int32_t v201 = v196;
                int32_t v202 = v195;
                int32_t v203 = v194;
                int32_t v204 = v193;
                int32_t v205 = v192;
                int32_t v206 = v191;
                v103 = v206;
                v101 = v205;
                v99 = v203;
                v97 = v202;
                v95 = v201;
                v105 = v200;
                v207 = v206;
                v208 = v205;
                v209 = v204;
                v210 = v203;
                v211 = v202;
                v212 = v200;
                v213 = v199;
                if (v204 == 0) {
                    goto lab_0x39d04;
                } else {
                    goto lab_0x39d7c;
                }
            }
          lab_0x39e58:
            // 0x39e58
            v239 = v102;
            v240 = v100;
            v241 = v98;
            v242 = v245;
            v243 = v96;
            if (v100 == 0) {
                // break -> 0x39e60
                break;
            }
        }
        if (v102 != 0) {
            *(int32_t *)(v102 + 8) = 0;
        }
        v232 = v102;
        if (v244 == 0 || v245 == 0) {
            // break -> 0x39e80
            break;
        }
        // 0x39e70
        v237 = 2 * v238;
        v235 = v98;
        v233 = v96;
        v232 = 0;
        if (v98 == 0) {
            // break -> 0x39e80
            break;
        }
    }
    int32_t v265 = v232;
    int32_t v266 = *v109; // 0x39e80
    *(int32_t *)(v266 + 16) = v265;
    int32_t v267 = *v109; // 0x39e88
    int32_t v268 = *(int32_t *)(v267 + 20); // 0x39e8c
    g119 = v98 - v268;
    int32_t v269; // 0x39848
    v7 = v269;
    goto lab_0x39e98;
}

// Address range: 0x3a014 - 0x3a764
int32_t function_3a014(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t v1 = a1; // bp-2076, 0x3a020
    int32_t v2 = *(int32_t *)(a1 + 260); // 0x3a028
    function_1f5c4((int32_t *)(a1 + 432));
    char * str; // bp-2064, 0x3a014
    if (g122 != 0) {
        int32_t v3 = *(int32_t *)(function_2df8c(*(int32_t *)(a1 + 256)) + 36); // 0x3a050
        if (pthread_mutex_lock(&g180) != 0) {
            int32_t v4 = *__errno_location(); // 0x3a550
            snprintf((char *)&str, 2048, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", v4);
            // 0x3a57c
            function_1ccec(3, (int32_t *)&str, 1);
            function_2ab30(1, 1);
            // UNREACHABLE
        }
        int32_t * v5 = (int32_t *)(v3 + 36); // 0x3a06c
        int32_t v6 = g198; // 0x3a078
        *v5 = *v5 + 1;
        g198 = v6 + 1;
        g199 += (int32_t)(v6 == -1);
        int32_t * v7 = (int32_t *)(v2 + 8); // 0x3a0a4
        int32_t v8 = *v7; // 0x3a0a4
        int32_t * v9 = (int32_t *)(v2 + 12); // 0x3a0ac
        __asm_vldr((int32_t)(float32_t)g210);
        *v7 = v8 + 1;
        *v9 = *v9 + (int32_t)(v8 == -1);
        __asm_vldr(*(int32_t *)(v1 + 376));
        __asm_vldr(*(int32_t *)(v3 + 200));
        return &g180;
    }
    int32_t v10 = function_324cc(a1, 1, a3, 0, (int32_t)&g306); // 0x3a180
    int32_t v11 = a1; // 0x3a188
    int32_t v12; // 0x3a014
    if (v10 != 0) {
        // 0x3a230
        int32_t v13; // 0x3a014
        if (g47 == 0) {
            char v14 = *(char *)&g179; // 0x3a4cc
            char v15 = *(char *)&g70;
            if (*(char *)(v2 + 104) == 0) {
                int32_t v16 = a1; // 0x3a598
                if (g28 > (char *)4 || (v15 || v14) != 0) {
                    int32_t v17 = *(int32_t *)v2; // 0x3a5dc
                    snprintf((char *)&str, 2048, "Pool %d stale share detected, discarding", v17);
                    function_1ccec(5, (int32_t *)&str, 0);
                    v16 = v1;
                }
                // 0x3a5f4
                function_31ae8((int32_t *)"discard", v16);
                if (pthread_mutex_lock(&g180) != 0) {
                    int32_t v18 = *__errno_location(); // 0x3a6f0
                    snprintf((char *)&str, 2048, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", v18, "submit_work_async", (char *)0x223d);
                    // 0x3a57c
                    function_1ccec(3, (int32_t *)&str, 1);
                    function_2ab30(1, 1);
                    // UNREACHABLE
                }
                int32_t * v19 = (int32_t *)(v2 + 120); // 0x3a618
                __asm_vldr(*(int32_t *)(v2 + 88));
                __asm_vldr(g200);
                *v19 = *v19 + 1;
                __asm_vldr(*(int32_t *)(v1 + 376));
                return &g180;
            }
            // 0x3a4d8
            if ((v15 || v14) == 0 != g28 < (char *)5) {
                int32_t v20 = *(int32_t *)v2; // 0x3a51c
                snprintf((char *)&str, 2048, "Pool %d stale share detected, submitting as pool requested", v20);
                function_1ccec(5, (int32_t *)&str, 0);
                v13 = (int32_t)&str;
            }
        } else {
            // 0x3a244
            if (*(char *)&g71 != 0) {
                char v21 = *(char *)&g70; // 0x3a274
                if ((v21 | *(char *)&g179) == 0 != g28 < (char *)7) {
                    int32_t v22 = *(int32_t *)v2; // 0x3a2a4
                    snprintf((char *)&str, 2048, "Pool %d stale share detected, submitting as user requested", v22);
                    function_1ccec(7, (int32_t *)&str, 0);
                    v13 = (int32_t)&str;
                }
            }
        }
        // 0x3a534
        v11 = v1;
        *(char *)(v11 + 281) = 1;
        v12 = v13;
    }
    // 0x3a190
    int32_t v23; // 0x3a014
    int32_t v24; // 0x3a014
    int32_t v25; // 0x3a014
    int32_t thread_func_arg; // 0x3a014
    int32_t v26; // 0x3a014
    if (*(char *)(v11 + 284) == 0) {
        // 0x3a3c8
        if ((*(char *)&g70 | *(char *)&g179) == 0) {
            int32_t v27 = (int32_t)&str;
            v23 = v27;
            thread_func_arg = v11;
            v26 = g28 < (char *)5 ? v27 : v12;
            if (g28 > (char *)4) {
                goto lab_0x3a408;
            } else {
                goto lab_0x3a44c;
            }
        } else {
            // 0x3a3c8
            v23 = (int32_t)&str;
            goto lab_0x3a408;
        }
    } else {
        // 0x3a19c
        if (*(char *)&g71 == 0) {
            goto lab_0x3a2f0;
        } else {
            char v28 = *(char *)&g70; // 0x3a1cc
            if ((v28 | *(char *)&g179) != 0 || g28 > (char *)6) {
                int32_t v29 = *(int32_t *)v2; // 0x3a2d8
                snprintf((char *)&str, 2048, "Pushing pool %d work to stratum queue", v29);
                function_1ccec(7, (int32_t *)&str, 0);
                goto lab_0x3a2f0;
            } else {
                int32_t v30 = *(int32_t *)(v2 + 728); // 0x3a1ec
                v24 = v30;
                v25 = v11;
                if (v30 == 0) {
                    goto lab_0x3a1f8;
                } else {
                    goto lab_0x3a300;
                }
            }
        }
    }
  lab_0x3a2f0:;
    int32_t v31 = *(int32_t *)(v2 + 728); // 0x3a2f0
    v24 = v31;
    v25 = v1;
    if (v31 == 0) {
        goto lab_0x3a310;
    } else {
        goto lab_0x3a300;
    }
  lab_0x3a408:
    // 0x3a408
    str = (char *)0x68737550;
    function_1ccec(5, (int32_t *)&str, 0);
    thread_func_arg = v1;
    v26 = v23;
    goto lab_0x3a44c;
  lab_0x3a44c:
    // 0x3a44c
    if (pthread_create((int32_t *)(v26 - 4), NULL, (int32_t * (*)(int32_t *))0x27820, (int32_t *)thread_func_arg) != 0) {
        int32_t * v32 = (int32_t *)v26; // 0x3a478
        *v32 = 0x6c696146;
        *(int32_t *)(v26 + 4) = 0x74206465;
        *(int32_t *)(v26 + 8) = 0x7263206f;
        *(int32_t *)(v26 + 12) = 0x65746165;
        *(int32_t *)(v26 + 16) = 0x62757320;
        *(int32_t *)(v26 + 20) = 0x5f74696d;
        *(int32_t *)(v26 + 24) = 0x6b726f77;
        *(int32_t *)(v26 + 28) = 0x7268745f;
        *(int32_t *)(v26 + 32) = 0x646165;
        function_1ccec(3, v32, 1);
        function_2ab30(1, 1);
        // UNREACHABLE
    }
    // 0x3a170
    return 0;
  lab_0x3a310:
    // 0x3a310
    if ((*(char *)&g70 | *(char *)&g179) == 0) {
        // 0x3a310
        goto lab_0x3a1f8;
    } else {
        goto lab_0x3a338;
    }
  lab_0x3a300:;
    int32_t result = function_1eff4(v24, v25); // 0x3a304
    if (result != 0) {
        // 0x3a170
        return result;
    }
    goto lab_0x3a310;
  lab_0x3a338:
    // 0x3a338
    str = (char *)0x63736944;
    function_1ccec(4, (int32_t *)&str, 0);
    int32_t result2; // 0x3a228
    if (*(int32_t *)(v2 + 728) != 0) {
        // 0x3a214
        result2 = function_28ffc((int32_t)&v1, (int32_t)"cgminer.c", (int32_t)"submit_work_async", 0x2254);
        // 0x3a170
        return result2;
    }
    // 0x3a37c
    if ((*(char *)&g70 | *(char *)&g179) == 0) {
        // 0x3a37c
        goto lab_0x3a754;
    } else {
        goto lab_0x3a39c;
    }
  lab_0x3a1f8:
    // 0x3a1f8
    if (g28 > (char *)3) {
        goto lab_0x3a338;
    } else {
        // 0x3a204
        if (*(int32_t *)(v2 + 728) != 0) {
            // 0x3a214
            result2 = function_28ffc((int32_t)&v1, (int32_t)"cgminer.c", (int32_t)"submit_work_async", 0x2254);
            // 0x3a170
            return result2;
        }
        goto lab_0x3a754;
    }
  lab_0x3a39c:;
    int32_t v33 = *(int32_t *)v2; // 0x3a3a0
    snprintf((char *)&str, 2048, "Pushing pool %d work to stratum queue", v33);
    function_1ccec(5, (int32_t *)&str, 0);
    // 0x3a214
    result2 = function_28ffc((int32_t)&v1, (int32_t)"cgminer.c", (int32_t)"submit_work_async", 0x2254);
    // 0x3a170
    return result2;
  lab_0x3a754:
    // 0x3a754
    if (g28 <= (char *)4) {
        // 0x3a214
        result2 = function_28ffc((int32_t)&v1, (int32_t)"cgminer.c", (int32_t)"submit_work_async", 0x2254);
        // 0x3a170
        return result2;
    }
    // 0x3a754
    goto lab_0x3a39c;
}

// Address range: 0x3a768 - 0x3a850
int32_t function_3a768(int32_t a1, int32_t a2) {
    int32_t v1 = a1 + 36; // 0x3a77c
    function_2fc18(v1, a2);
    int32_t result = function_1ed30(a2 + 192, a2 + 160); // 0x3a78c
    if (result != 0) {
        int32_t v2 = function_2c214(); // 0x3a824
        function_28ee4(v2, a2, 0);
        int32_t v3; // 0x3a768
        function_3a014(v2, a2, 0, v3, (int32_t)&g306);
        return result;
    }
    char v4 = *(char *)&g70; // 0x3a7b4
    if ((v4 | *(char *)&g179) == 0 != g28 < (char *)6) {
        int32_t v5 = *(int32_t *)v1; // 0x3a7d4
        int32_t v6 = *(int32_t *)(v5 + 8); // 0x3a7ec
        int32_t v7 = *(int32_t *)(*(int32_t *)(v5 + 4) + 8); // 0x3a7f8
        int32_t str; // bp-2064, 0x3a768
        snprintf((char *)&str, 2048, "%s %s %d: Share above target", "submit_tested_work", (char *)v7, v6);
        function_1ccec(6, &str, 0);
    }
    // 0x3a814
    return 0;
}

// Address range: 0x3a854 - 0x3a8e8
int32_t function_3a854(int32_t result, int32_t a2, int32_t a3) {
    if (result == 0) {
        // 0x3a88c
        function_2f62c(result);
        // 0x3a898
        return 0;
    }
    // 0x3a874
    *(int32_t *)(a2 + 76) = a3;
    if (*(int32_t *)(a2 + 220) != 0) {
        // 0x3a88c
        function_2f62c(result);
        // 0x3a898
        return 0;
    }
    // 0x3a8a0
    function_3a768(result, a2);
    if (g182 == NULL) {
        // 0x3a898
        return result;
    }
    int32_t result2 = result; // 0x3a8d0
    if (g189 != 0) {
        // 0x3a8d4
        function_29144(a2);
        result2 = g189;
    }
    // 0x3a898
    return result2;
}

// Address range: 0x3a8e8 - 0x3a910
int32_t function_3a8e8(int32_t a1) {
    int32_t v1 = function_2c214(); // 0x3a8f0
    function_28ee4(v1, a1, 0);
    int32_t v2; // 0x3a8e8
    return function_3a014(v1, a1, 0, v2, (int32_t)&g306);
}

// Address range: 0x3a910 - 0x3a940
int32_t function_3a910(int32_t a1, int32_t a2, int32_t a3) {
    // 0x3a910
    *(int32_t *)(a2 + 76) = a3;
    int32_t v1 = function_2c214(); // 0x3a91c
    function_28ee4(v1, a2, 0);
    int32_t v2; // 0x3a910
    function_3a014(v1, a2, 0, v2, (int32_t)&g306);
    return 1;
}

// Address range: 0x3a940 - 0x3aad8
int32_t function_3a940(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = function_2c214();
    int32_t v2 = v1; // bp-2076, 0x3a968
    function_28ee4(v1, a2, a4);
    *(int32_t *)(v1 + 76) = a3;
    if (*(int32_t *)(v1 + 220) != 0) {
        // 0x3aa8c
        function_28ffc((int32_t)&v2, (int32_t)"cgminer.c", (int32_t)"submit_noffset_nonce", 0x23c5);
        function_2f62c(a1);
        return 0;
    }
    int32_t v3 = a1 + 36; // 0x3a990
    function_2fc18(v3, v2);
    int32_t v4 = (int32_t)g182; // 0x3a9a8
    int32_t v5; // 0x3a940
    int32_t v6; // 0x3a940
    if (g182 == NULL) {
        goto lab_0x3aa84;
    } else {
        // 0x3a9ac
        v5 = v2;
        v6 = 0;
        if (g189 == 0) {
            goto lab_0x3a9c4;
        } else {
            // 0x3aa7c
            function_29144(v2);
            v4 = g189;
            goto lab_0x3aa84;
        }
    }
  lab_0x3aa84:
    // 0x3aa84
    v5 = v2;
    v6 = v4;
    goto lab_0x3a9c4;
  lab_0x3a9c4:;
    int32_t v7 = v5 + 160; // 0x3a9c4
    int32_t result = function_1ed30(v5 + 192, v7); // 0x3a9cc
    if (result != 0) {
        // 0x3aac0
        function_3a014(v2, v7, a4, v6, (int32_t)&g306);
        return result;
    }
    // 0x3a9d8
    function_28ffc((int32_t)&v2, (int32_t)"cgminer.c", (int32_t)"submit_noffset_nonce", 0x23d5);
    if ((*(char *)&g70 | *(char *)&g179) == 0) {
        // 0x3aa18
        if (g28 <= (char *)5) {
            // 0x3aa6c
            return g28 < (char *)6;
        }
    }
    int32_t v8 = *(int32_t *)v3; // 0x3aa30
    int32_t v9 = *(int32_t *)(v8 + 8); // 0x3aa4c
    int32_t v10 = *(int32_t *)(*(int32_t *)(v8 + 4) + 8); // 0x3aa50
    int32_t str; // bp-2072, 0x3a940
    snprintf((char *)&str, 2048, "%s %d: Share above target", (char *)v10, v9);
    function_1ccec(6, &str, 0);
    // 0x3aa6c
    return 1;
}

// Address range: 0x3aadc - 0x3aae8
int32_t function_3aadc(int32_t a1) {
    // 0x3aadc
    function_2ab30(a1, 1);
    // UNREACHABLE
}

// Address range: 0x3aae8 - 0x3abd8
int32_t function_3aae8(int32_t thread_func_arg, int32_t a2, int32_t a3, int32_t str, int32_t str2) {
    int32_t v1 = function_1faa4(a3, thread_func_arg); // 0x3ab08
    int32_t * v2 = (int32_t *)(thread_func_arg + 172); // 0x3ab0c
    *v2 = str;
    *(int32_t *)(thread_func_arg + 164) = v1;
    int32_t * v3 = (int32_t *)(thread_func_arg + 176); // 0x3ab18
    *v3 = str2;
    int32_t size = strlen((char *)str) + 2 + strlen((char *)str2); // 0x3ab34
    int32_t str3 = function_1e74c(size, "cgminer.c", "add_pool_details", 0x2a88); // 0x3ab48
    *(int32_t *)(thread_func_arg + 168) = str3;
    snprintf((char *)str3, size, "%s:%s", (char *)*v2, (char *)*v3);
    int32_t v4 = thread_func_arg + 100; // 0x3ab6c
    *(char *)(thread_func_arg + 284) = 1;
    *(char *)(thread_func_arg + 107) = (char)a2 ^ 1;
    *(char *)(thread_func_arg + 97) = 1;
    if (*(int32_t *)v4 != 1) {
        // 0x3ab8c
        function_27998(v4);
    }
    int32_t * thread = (int32_t *)(thread_func_arg + 280); // 0x3aba8
    pthread_create(thread, NULL, (int32_t * (*)(int32_t *))&g8, (int32_t *)thread_func_arg);
    int32_t result = a2; // 0x3abb0
    if (a2 == 0) {
        // 0x3abb4
        pthread_join(*thread, NULL);
        result = (int32_t)*(char *)&g82;
    }
    // 0x3abcc
    return result;
}

// Address range: 0x3abdc - 0x3ad20
int32_t function_3abdc(int32_t result) {
    int32_t * v1 = (int32_t *)(result + 12); // 0x3abdc
    if (*v1 == 0) {
        *v1 = 0x26d50;
    }
    int32_t * v2 = (int32_t *)(result + 16); // 0x3abf0
    if (*v2 == 0) {
        *v2 = 0x26d2c;
    }
    int32_t * v3 = (int32_t *)(result + 20); // 0x3ac04
    if (*v3 == 0) {
        *v3 = 0x26d30;
    }
    int32_t * v4 = (int32_t *)(result + 24); // 0x3ac18
    if (*v4 == 0) {
        *v4 = 0x289d4;
    }
    int32_t * v5 = (int32_t *)(result + 32); // 0x3ac2c
    if (*v5 == 0) {
        *v5 = 0x26d34;
    }
    int32_t * v6 = (int32_t *)(result + 44); // 0x3ac40
    if (*v6 == 0) {
        *v6 = 0x289dc;
    }
    int32_t * v7 = (int32_t *)(result + 52); // 0x3ac54
    if (*v7 == 0) {
        *v7 = 0x289e4;
    }
    int32_t * v8 = (int32_t *)(result + 56); // 0x3ac68
    if (*v8 == 0) {
        *v8 = 0x26d48;
    }
    int32_t * v9 = (int32_t *)(result + 84); // 0x3ac7c
    if (*v9 == 0) {
        *v9 = 0x289ec;
    }
    int32_t * v10 = (int32_t *)(result + 88); // 0x3ac90
    if (*v10 == 0) {
        *v10 = 0x289f0;
    }
    int32_t * v11 = (int32_t *)(result + 92); // 0x3aca4
    if (*v11 == 0) {
        *v11 = 0x289f4;
    }
    int32_t * v12 = (int32_t *)(result + 60); // 0x3acb8
    if (*v12 == 0) {
        *v12 = 0x34454;
    }
    int32_t * v13 = (int32_t *)(result + 76); // 0x3accc
    if (*v13 == 0) {
        *v13 = 0x26d2c;
    }
    int32_t * v14 = (int32_t *)(result + 80); // 0x3ace0
    if (*v14 == 0) {
        *v14 = 0x26d2c;
    }
    int32_t * v15 = (int32_t *)(result + 72); // 0x3acf4
    if (*v15 == 0) {
        *v15 = 0x26d34;
    }
    int32_t * v16 = (int32_t *)(result + 96); // 0x3ad08
    if (*v16 == 0) {
        *v16 = 0x26d5c;
    }
    __asm_vldr(*(int32_t *)(result + 104));
    return result;
}

// Address range: 0x3ad22 - 0x3ad36
int32_t function_3ad22(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    uint32_t v1 = unknown_4767fe(); // 0x3ad22
    bool v2; // 0x3ad22
    if (!v2) {
        // .thread2
        *(int32_t *)(v1 + 4) = 0x3ad2c;
        __asm_svclo(0xf003a0);
        return v1 - a2;
    }
    if ((v1 & 64) != 0) {
        // .critedge
        int32_t v3; // 0x3ad22
        return v3 % 256;
    }
    __asm_svclo(0xf003a0);
    return v1 / 128 & v1;
}

// Address range: 0x3ad36 - 0x3ad40
int32_t function_3ad36(int32_t a1) {
    // 0x3ad36
    float64_t v1; // 0x3ad36
    __asm_vrhadd_u16(v1, v1);
    return 128 * a1;
}

// Address range: 0x3ad40 - 0x3ae24
int32_t function_3ad40(int32_t result, int32_t a2, int32_t a3, uint32_t a4) {
    // 0x3ad40
    *(int32_t *)(result + 28) = a4 % 0x10000 | 0x20000;
    *(int32_t *)(result + 12) = 0x26d50;
    *(int32_t *)(result + 20) = 0x26d30;
    *(int32_t *)(result + 24) = 0x289d4;
    *(int32_t *)(result + 40) = 0;
    *(int32_t *)(result + 44) = 0x289dc;
    *(int32_t *)(result + 48) = 0x26d3c;
    *(int32_t *)(result + 52) = 0x289e4;
    *(int32_t *)(result + 56) = 0x26d48;
    *(int32_t *)(result + 60) = 0x289d8;
    *(int32_t *)(result + 84) = 0x289ec;
    *(int32_t *)(result + 88) = 0x289f0;
    *(int32_t *)(result + 92) = 0x289f4;
    *(int32_t *)(result + 96) = 0x26d5c;
    *(int32_t *)(result + 16) = 0x26d2c;
    *(int32_t *)(result + 36) = 0x26d2c;
    *(int32_t *)(result + 76) = 0x26d2c;
    *(int32_t *)(result + 80) = 0x26d2c;
    *(int32_t *)(result + 32) = 0x26d34;
    *(int32_t *)(result + 72) = 0x26d34;
    *(int32_t *)(result + 104) = 0;
    *(int32_t *)(result + 108) = 0x3ff00000;
    *(int32_t *)(result + 112) = 0;
    *(int32_t *)(result + 116) = 0x3ff00000;
    return result;
}

// Address range: 0x3ae24 - 0x3af0c
int32_t function_3ae24(int32_t a1) {
    // 0x3ae24
    *(int32_t *)(a1 + 32) = 0;
    if (pthread_rwlock_wrlock(&g227) != 0) {
        // 0x3aef4
        function_2bfac((int32_t)"enable_device", 0x2c24);
        // UNREACHABLE
    }
    // 0x3ae48
    *(int32_t *)a1 = g136;
    *(int32_t *)(4 * g136 + g217) = a1;
    g136++;
    if (pthread_rwlock_unlock(&g227) != 0) {
        // 0x3aef4
        function_2bfac((int32_t)"enable_device", 0x2c24);
        // UNREACHABLE
    }
    // 0x3ae84
    function_1da28();
    if (g233 == 0) {
        int32_t v1 = *(int32_t *)((int32_t)&g171 | 0x4180); // 0x3aeb8
        int32_t v2 = *(int32_t *)(a1 + 148); // 0x3aebc
        *(int32_t *)((int32_t)&g171 | 0x4180) = v2 + v1;
    } else {
        g137 += *(int32_t *)(a1 + 148);
    }
    if (pthread_rwlock_init((int32_t *)(a1 + 320), NULL) != 0) {
        // 0x3af00
        return (int32_t)"enable_device";
    }
    // 0x3aee0
    *(int32_t *)(a1 + 352) = 0;
    return 0;
}

// Address range: 0x3af10 - 0x3b918
int32_t function_3af10(int32_t a1) {
    int32_t * v1 = (int32_t *)(a1 + 4); // 0x3af18
    int32_t str = *(int32_t *)(*v1 + 8); // 0x3af28
    int32_t len = strlen((char *)str); // 0x3af34
    int32_t v2 = len; // 0x3af4c
    int32_t v3 = -0x61c88647; // 0x3af4c
    int32_t v4 = -0x1124111; // 0x3af4c
    int32_t v5 = -0x61c88647; // 0x3af4c
    int32_t v6 = len; // 0x3af4c
    int32_t v7 = str; // 0x3af4c
    int32_t v8; // 0x3af10
    if (len != 11 && len >= 11) {
        int32_t v9 = str + 12;
        unsigned char v10 = *(char *)(str + 6); // 0x3af58
        v2 -= 12;
        unsigned char v11 = *(char *)(str + 10); // 0x3af60
        unsigned char v12 = *(char *)(str + 2); // 0x3af68
        unsigned char v13 = *(char *)(str + 5); // 0x3af70
        unsigned char v14 = *(char *)(str + 9); // 0x3af78
        unsigned char v15 = *(char *)(str + 1); // 0x3af80
        unsigned char v16 = *(char *)(str + 7); // 0x3af8c
        unsigned char v17 = *(char *)(str + 4); // 0x3af94
        unsigned char v18 = *(char *)str; // 0x3af9c
        unsigned char v19 = *(char *)(str + 8); // 0x3afa4
        unsigned char v20 = *(char *)(str + 3); // 0x3afac
        int32_t v21 = (int32_t)*(char *)(str + 11); // 0x3afb4
        int32_t v22 = (256 * (int32_t)v13 | 0x10000 * (int32_t)v10 | (int32_t)v17 | 0x1000000 * (int32_t)v16) - 0x61c88647; // 0x3afc4
        uint32_t v23 = (256 * (int32_t)v14 | 0x10000 * (int32_t)v11 | (int32_t)v19 | 0x1000000 * v21) - 0x1124111; // 0x3afd0
        int32_t v24 = -0x61c88647 - v22 + (256 * (int32_t)v15 | 0x10000 * (int32_t)v12 | (int32_t)v18 | 0x1000000 * (int32_t)v20) - v23 ^ v23 / 0x2000; // 0x3afe0
        uint32_t v25 = v22 - v23 - v24 ^ 256 * v24; // 0x3afec
        uint32_t v26 = v23 - v24 - v25 ^ v25 / 0x2000; // 0x3aff8
        int32_t v27 = v24 - v25 - v26 ^ v26 / 0x1000; // 0x3b004
        uint32_t v28 = v25 - v26 - v27 ^ 0x10000 * v27; // 0x3b010
        uint32_t v29 = v26 - v27 - v28 ^ v28 / 32; // 0x3b01c
        int32_t v30 = v27 - v28 - v29 ^ v29 / 8; // 0x3b028
        int32_t v31 = v28 - v29 - v30 ^ 1024 * v30; // 0x3b034
        int32_t v32 = v29 - v30 - v31 ^ v31 / 0x8000; // 0x3b03c
        v3 = v30;
        v4 = v32;
        v5 = v31;
        v6 = v2;
        v7 = v9;
        v8 = v21;
        while ((v31 & 0x4000) != 0 == (v2 != 11)) {
            int32_t v33 = v9;
            v9 = v33 + 12;
            v10 = *(char *)(v33 + 6);
            v2 -= 12;
            v11 = *(char *)(v33 + 10);
            v12 = *(char *)(v33 + 2);
            v13 = *(char *)(v33 + 5);
            v14 = *(char *)(v33 + 9);
            v15 = *(char *)(v33 + 1);
            v16 = *(char *)(v33 + 7);
            v17 = *(char *)(v33 + 4);
            v18 = *(char *)v33;
            v19 = *(char *)(v33 + 8);
            v20 = *(char *)(v33 + 3);
            v21 = (int32_t)*(char *)(v33 + 11);
            v22 = (256 * (int32_t)v13 | 0x10000 * (int32_t)v10 | (int32_t)v17 | 0x1000000 * (int32_t)v16) + v31;
            v23 = (256 * (int32_t)v14 | 0x10000 * (int32_t)v11 | (int32_t)v19 | 0x1000000 * v21) + v32;
            v24 = v30 - v22 + (256 * (int32_t)v15 | 0x10000 * (int32_t)v12 | (int32_t)v18 | 0x1000000 * (int32_t)v20) - v23 ^ v23 / 0x2000;
            v25 = v22 - v23 - v24 ^ 256 * v24;
            v26 = v23 - v24 - v25 ^ v25 / 0x2000;
            v27 = v24 - v25 - v26 ^ v26 / 0x1000;
            v28 = v25 - v26 - v27 ^ 0x10000 * v27;
            v29 = v26 - v27 - v28 ^ v28 / 32;
            v30 = v27 - v28 - v29 ^ v29 / 8;
            v31 = v28 - v29 - v30 ^ 1024 * v30;
            v32 = v29 - v30 - v31 ^ v31 / 0x8000;
            v3 = v30;
            v4 = v32;
            v5 = v31;
            v6 = v2;
            v7 = v9;
            v8 = v21;
        }
    }
    int32_t v34 = v4 + len; // 0x3b048
    g312 = v6 - 1;
    int32_t v35 = v34; // 0x3b050
    int32_t v36 = v34; // 0x3b050
    int32_t v37 = v5; // 0x3b050
    int32_t v38 = v5; // 0x3b050
    int32_t v39 = v5; // 0x3b050
    int32_t v40 = v3; // 0x3b050
    int32_t v41 = v3; // 0x3b050
    int32_t v42 = v3; // 0x3b050
    int32_t v43 = v3; // 0x3b050
    int32_t v44 = v34; // 0x3b050
    int32_t v45 = v5; // 0x3b050
    switch (v6) {
        case 11: {
            // 0x3b084
            v35 = 0x1000000 * (int32_t)*(char *)(v7 + 10) + v34;
        }
        case 10: {
            // 0x3b08c
            v36 = 0x10000 * (int32_t)*(char *)(v7 + 9) + v35;
        }
        case 9: {
            // 0x3b094
            v44 = 256 * (int32_t)*(char *)(v7 + 8) + v36;
        }
        case 8: {
            // 0x3b09c
            v37 = 0x1000000 * (int32_t)*(char *)(v7 + 7) + v5;
        }
        case 7: {
            // 0x3b0a4
            v38 = 0x10000 * (int32_t)*(char *)(v7 + 6) + v37;
        }
        case 6: {
            // 0x3b0ac
            v39 = 256 * (int32_t)*(char *)(v7 + 5) + v38;
        }
        case 5: {
            // 0x3b0b4
            v45 = v39 + (int32_t)*(char *)(v7 + 4);
        }
        case 4: {
            // 0x3b0bc
            v40 = 0x1000000 * (int32_t)*(char *)(v7 + 3) + v3;
        }
        case 3: {
            // 0x3b0c4
            v41 = 0x10000 * (int32_t)*(char *)(v7 + 2) + v40;
        }
        case 2: {
            // 0x3b0cc
            v42 = 256 * (int32_t)*(char *)(v7 + 1) + v41;
        }
        case 1: {
            // 0x3b0d4
            v43 = v42 + (int32_t)*(char *)v7;
            // break -> 0x3b0dc
            break;
        }
    }
    // 0x3b0dc
    int32_t v46; // 0x3af10
    int32_t v47; // 0x3af10
    if (g138 != 0) {
        uint32_t v48 = v44;
        int32_t v49 = v43 - v48 - v45 ^ v48 / 0x2000; // 0x3b0ec
        uint32_t v50 = v45 - v48 - v49 ^ 256 * v49; // 0x3b100
        uint32_t v51 = v48 - v49 - v50 ^ v50 / 0x2000; // 0x3b110
        int32_t v52 = v49 - v50 - v51 ^ v51 / 0x1000; // 0x3b11c
        uint32_t v53 = v50 - v51 - v52 ^ 0x10000 * v52; // 0x3b128
        uint32_t v54 = v51 - v52 - v53 ^ v53 / 32; // 0x3b134
        int32_t v55 = v52 - v53 - v54 ^ v54 / 8; // 0x3b140
        uint32_t v56 = v53 - v54 - v55 ^ 1024 * v55; // 0x3b14c
        int32_t v57 = v54 - v55 - v56 ^ v56 / 0x8000; // 0x3b154
        int32_t v58 = *(int32_t *)(g138 + 8); // 0x3b15c
        uint64_t v59 = *(int64_t *)v58; // 0x3b160
        int32_t v60 = *(int32_t *)(12 * ((int32_t)v59 - 1 & v57) + (int32_t)(v59 / 0x100000000)); // 0x3b170
        if (v60 != 0) {
            int32_t v61 = *(int32_t *)(v58 + 20); // 0x3b17c
            int32_t v62 = v60 - v61; // 0x3b184
            if (v62 != 0) {
                // 0x3b1a8
                int32_t * v63; // 0x3b1d8
                int32_t v64; // 0x3b1e0
                if (*(int32_t *)(v62 + 36) == v57) {
                    // 0x3b1b4
                    if (*(int32_t *)(v62 + 32) == len) {
                        // 0x3b1c0
                        if (memcmp((int32_t *)*(int32_t *)(v62 + 28), (int32_t *)str, len) == 0) {
                            // 0x3b1d8
                            v63 = (int32_t *)(v62 + 4);
                            v64 = *v63 + 1;
                            *v63 = v64;
                            *(int32_t *)(a1 + 8) = v64;
                            v47 = str;
                            v46 = v8;
                            goto lab_0x3b1ec;
                        }
                    }
                }
                int32_t v65 = *(int32_t *)(v62 + 24); // 0x3b194
                while (v65 != 0) {
                    int32_t v66 = v65 - v61; // 0x3b1a0
                    if (v66 == 0) {
                        // break -> 0x3b310
                        break;
                    }
                    int32_t v67 = v66;
                    if (*(int32_t *)(v67 + 36) == v57) {
                        // 0x3b1b4
                        if (*(int32_t *)(v67 + 32) == len) {
                            // 0x3b1c0
                            if (memcmp((int32_t *)*(int32_t *)(v67 + 28), (int32_t *)str, len) == 0) {
                                // 0x3b1d8
                                v63 = (int32_t *)(v67 + 4);
                                v64 = *v63 + 1;
                                *v63 = v64;
                                *(int32_t *)(a1 + 8) = v64;
                                v47 = str;
                                v46 = v8;
                                goto lab_0x3b1ec;
                            }
                        }
                    }
                    // 0x3b194
                    v65 = *(int32_t *)(v67 + 24);
                }
            }
        }
    }
    int32_t str2 = function_1e74c(40, "cgminer.c", "add_cgpu", 0x2c51); // 0x3b328
    int32_t v68 = *(int32_t *)(*v1 + 8); // 0x3b344
    function_2220c(str2, (int32_t *)v68, 4, (int32_t)"cgminer.c", (int32_t)"add_cgpu", 0x2c52);
    *(int32_t *)(str2 + 4) = 0;
    *(int32_t *)(a1 + 8) = 0;
    int32_t len2 = strlen((char *)str2); // 0x3b36c
    int32_t v69 = len2; // 0x3b38c
    int32_t v70 = len2; // 0x3b38c
    int32_t v71 = -0x61c88647; // 0x3b38c
    int32_t v72 = str2; // 0x3b38c
    int32_t v73 = -0x61c88647; // 0x3b38c
    v46 = -0x1124111;
    int32_t v74; // 0x3af10
    int32_t v75; // 0x3af10
    int32_t v76; // 0x3af10
    int32_t v77; // 0x3af10
    int32_t v78; // 0x3af10
    int32_t v79; // 0x3af10
    int32_t v80; // 0x3af10
    if (len2 == 11 || len2 < 11) {
        goto lab_0x3b904;
    } else {
        int32_t v81 = str2 + 12;
        unsigned char v82 = *(char *)(str2 + 6); // 0x3b394
        v69 -= 12;
        unsigned char v83 = *(char *)(str2 + 10); // 0x3b39c
        unsigned char v84 = *(char *)(str2 + 2); // 0x3b3a4
        unsigned char v85 = *(char *)(str2 + 5); // 0x3b3a8
        unsigned char v86 = *(char *)(str2 + 9); // 0x3b3ac
        unsigned char v87 = *(char *)(str2 + 1); // 0x3b3b4
        unsigned char v88 = *(char *)(str2 + 7); // 0x3b3c0
        unsigned char v89 = *(char *)(str2 + 4); // 0x3b3c8
        unsigned char v90 = *(char *)str2; // 0x3b3d0
        unsigned char v91 = *(char *)(str2 + 8); // 0x3b3d8
        unsigned char v92 = *(char *)(str2 + 3); // 0x3b3e0
        unsigned char v93 = *(char *)(str2 + 11); // 0x3b3e8
        int32_t v94 = (256 * (int32_t)v85 | 0x10000 * (int32_t)v82 | (int32_t)v89 | 0x1000000 * (int32_t)v88) - 0x61c88647; // 0x3b3f8
        uint32_t v95 = (256 * (int32_t)v86 | 0x10000 * (int32_t)v83 | (int32_t)v91 | 0x1000000 * (int32_t)v93) - 0x1124111; // 0x3b408
        int32_t v96 = -0x61c88647 - v94 + (256 * (int32_t)v87 | 0x10000 * (int32_t)v84 | (int32_t)v90 | 0x1000000 * (int32_t)v92) - v95 ^ v95 / 0x2000; // 0x3b41c
        uint32_t v97 = v94 - v95 - v96 ^ 256 * v96; // 0x3b428
        uint32_t v98 = v95 - v96 - v97 ^ v97 / 0x2000; // 0x3b434
        int32_t v99 = v96 - v97 - v98 ^ v98 / 0x1000; // 0x3b440
        uint32_t v100 = v97 - v98 - v99 ^ 0x10000 * v99; // 0x3b44c
        uint32_t v101 = v98 - v99 - v100 ^ v100 / 32; // 0x3b458
        int32_t v102 = v99 - v100 - v101 ^ v101 / 8; // 0x3b464
        int32_t v103 = v100 - v101 - v102 ^ 1024 * v102; // 0x3b470
        int32_t v104 = v101 - v102 - v103 ^ v103 / 0x8000; // 0x3b478
        v80 = len2;
        v76 = v81;
        v77 = v102;
        v78 = str2;
        v79 = v103;
        v74 = v69;
        v75 = v104;
        while ((v103 & 0x4000) != 0 == (v69 != 11)) {
            int32_t v105 = v81;
            v81 = v105 + 12;
            v82 = *(char *)(v105 + 6);
            v69 -= 12;
            v83 = *(char *)(v105 + 10);
            v84 = *(char *)(v105 + 2);
            v85 = *(char *)(v105 + 5);
            v86 = *(char *)(v105 + 9);
            v87 = *(char *)(v105 + 1);
            v88 = *(char *)(v105 + 7);
            v89 = *(char *)(v105 + 4);
            v90 = *(char *)v105;
            v91 = *(char *)(v105 + 8);
            v92 = *(char *)(v105 + 3);
            v93 = *(char *)(v105 + 11);
            v94 = (256 * (int32_t)v85 | 0x10000 * (int32_t)v82 | (int32_t)v89 | 0x1000000 * (int32_t)v88) + v103;
            v95 = (256 * (int32_t)v86 | 0x10000 * (int32_t)v83 | (int32_t)v91 | 0x1000000 * (int32_t)v93) + v104;
            v96 = v102 - v94 + (256 * (int32_t)v87 | 0x10000 * (int32_t)v84 | (int32_t)v90 | 0x1000000 * (int32_t)v92) - v95 ^ v95 / 0x2000;
            v97 = v94 - v95 - v96 ^ 256 * v96;
            v98 = v95 - v96 - v97 ^ v97 / 0x2000;
            v99 = v96 - v97 - v98 ^ v98 / 0x1000;
            v100 = v97 - v98 - v99 ^ 0x10000 * v99;
            v101 = v98 - v99 - v100 ^ v100 / 32;
            v102 = v99 - v100 - v101 ^ v101 / 8;
            v103 = v100 - v101 - v102 ^ 1024 * v102;
            v104 = v101 - v102 - v103 ^ v103 / 0x8000;
            v80 = len2;
            v76 = v81;
            v77 = v102;
            v78 = str2;
            v79 = v103;
            v74 = v69;
            v75 = v104;
        }
        goto lab_0x3b480;
    }
  lab_0x3b904:
    // 0x3b904
    v80 = v70;
    v76 = v72;
    v77 = v71;
    v78 = v72;
    v79 = v73;
    v74 = v70;
    v75 = v46;
    goto lab_0x3b480;
  lab_0x3b480:;
    int32_t v106 = v79;
    int32_t str3 = v78;
    int32_t v107 = v77;
    int32_t v108 = v76;
    int32_t v109 = v80;
    int32_t v110 = v75 + v109; // 0x3b488
    g313 = v74 - 1;
    int32_t v111 = v110; // 0x3b490
    int32_t v112 = v110; // 0x3b490
    int32_t v113 = v110; // 0x3b490
    int32_t v114 = v106; // 0x3b490
    int32_t v115 = v110; // 0x3b490
    int32_t v116 = v106; // 0x3b490
    int32_t v117 = v110; // 0x3b490
    int32_t v118 = v106; // 0x3b490
    int32_t v119 = v110; // 0x3b490
    int32_t v120 = v106; // 0x3b490
    int32_t v121 = v110; // 0x3b490
    int32_t v122 = v107; // 0x3b490
    int32_t v123 = v106; // 0x3b490
    int32_t v124 = v110; // 0x3b490
    int32_t v125 = v107; // 0x3b490
    int32_t v126 = v106; // 0x3b490
    int32_t v127 = v110; // 0x3b490
    int32_t v128 = v107; // 0x3b490
    int32_t v129 = v106; // 0x3b490
    int32_t v130 = v110; // 0x3b490
    int32_t v131 = v107; // 0x3b490
    int32_t v132 = v106; // 0x3b490
    int32_t v133 = v110; // 0x3b490
    switch (v74) {
        case 11: {
            // 0x3b4c4
            v111 = 0x1000000 * (int32_t)*(char *)(v108 + 10) + v110;
        }
        case 10: {
            // 0x3b4cc
            v112 = 0x10000 * (int32_t)*(char *)(v108 + 9) + v111;
        }
        case 9: {
            // 0x3b4d4
            v113 = 256 * (int32_t)*(char *)(v108 + 8) + v112;
        }
        case 8: {
            // 0x3b4dc
            v114 = 0x1000000 * (int32_t)*(char *)(v108 + 7) + v106;
            v115 = v113;
        }
        case 7: {
            // 0x3b4e4
            v116 = 0x10000 * (int32_t)*(char *)(v108 + 6) + v114;
            v117 = v115;
        }
        case 6: {
            // 0x3b4ec
            v118 = 256 * (int32_t)*(char *)(v108 + 5) + v116;
            v119 = v117;
        }
        case 5: {
            // 0x3b4f4
            v120 = v118 + (int32_t)*(char *)(v108 + 4);
            v121 = v119;
        }
        case 4: {
            // 0x3b4fc
            v122 = 0x1000000 * (int32_t)*(char *)(v108 + 3) + v107;
            v123 = v120;
            v124 = v121;
        }
        case 3: {
            // 0x3b504
            v125 = 0x10000 * (int32_t)*(char *)(v108 + 2) + v122;
            v126 = v123;
            v127 = v124;
        }
        case 2: {
            // 0x3b50c
            v128 = 256 * (int32_t)*(char *)(v108 + 1) + v125;
            v129 = v126;
            v130 = v127;
        }
        case 1: {
            // 0x3b514
            v131 = v128 + (int32_t)*(char *)v108;
            v132 = v129;
            v133 = v130;
            // break -> 0x3b51c
            break;
        }
    }
    uint32_t v134 = v133;
    *(int32_t *)(str3 + 28) = str3;
    int32_t v135 = v131 - v132 - v134 ^ v134 / 0x2000; // 0x3b52c
    int32_t v136 = v134 - v135; // 0x3b538
    uint32_t v137 = v132 - v134 - v135 ^ 256 * v135; // 0x3b53c
    uint32_t v138 = v136 - v137 ^ v137 / 0x2000; // 0x3b548
    int32_t v139 = v135 - v137 - v138 ^ v138 / 0x1000; // 0x3b554
    uint32_t v140 = v137 - v138 - v139 ^ 0x10000 * v139; // 0x3b560
    uint32_t v141 = v138 - v139 - v140 ^ v140 / 32; // 0x3b56c
    int32_t v142 = v139 - v140 - v141 ^ v141 / 8; // 0x3b578
    uint32_t v143 = v140 - v141 - v142 ^ 1024 * v142; // 0x3b584
    int32_t v144 = v141 - v142 - v143 ^ v143 / 0x8000; // 0x3b58c
    *(int32_t *)(str3 + 36) = v144;
    int32_t len3 = strlen((char *)str3); // 0x3b594
    int32_t v145 = *(int32_t *)((int32_t)&g160 - 1208); // 0x3b598
    *(int32_t *)(str3 + 32) = len3;
    int32_t v146 = v109; // 0x3b5a4
    int32_t v147 = str3; // 0x3b5a4
    int32_t v148 = v144; // 0x3b5a4
    int32_t v149 = 0; // 0x3b5a4
    int32_t * v150; // 0x3af10
    int32_t v151; // 0x3af10
    int32_t v152; // 0x3af10
    int32_t v153; // 0x3af10
    int32_t v154; // 0x3af10
    int32_t v155; // 0x3af10
    if (v145 == 0) {
        goto lab_0x3b858;
    } else {
        int32_t * v156 = (int32_t *)(v145 + 8);
        *(int32_t *)(str3 + 16) = 0;
        int32_t v157 = str3 + 8; // 0x3b5b4
        *(int32_t *)v157 = *v156;
        int32_t v158 = *v156; // 0x3b5bc
        int32_t v159 = *(int32_t *)(v158 + 20); // 0x3b5c4
        *(int32_t *)(str3 + 12) = *(int32_t *)(v158 + 16) - v159;
        *(int32_t *)(*(int32_t *)(*v156 + 16) + 8) = str3;
        *(int32_t *)(*v156 + 16) = v157;
        v150 = v156;
        v155 = v109;
        v152 = str3;
        v153 = v144;
        v154 = v157;
        v151 = v136;
        goto lab_0x3b5e4;
    }
  lab_0x3b858:
    // 0x3b858
    *(int32_t *)(v147 + 16) = v149;
    *(int32_t *)(v147 + 12) = v149;
    *(int32_t *)((int32_t)&g160 - 1208) = v147;
    int32_t * mem = malloc(44); // 0x3b868
    int32_t v160 = v147 + 8;
    int32_t * v161 = (int32_t *)v160;
    *v161 = (int32_t)mem;
    if (mem == NULL) {
        // 0x3b910
        exit(-1);
        return &g306;
    }
    // 0x3b878
    memset(mem, v149, 44);
    *(int32_t *)(*v161 + 16) = v160;
    *(int32_t *)(*v161 + 4) = 32;
    *(int32_t *)(*v161 + 8) = 5;
    *(int32_t *)(*v161 + 20) = 8;
    *(int32_t *)*v161 = (int32_t)malloc(384);
    int32_t v162 = *(int32_t *)*v161; // 0x3b8c8
    if (v162 == 0) {
        // 0x3b910
        exit(-1);
        return &g306;
    }
    // 0x3b8d4
    memset((int32_t *)v162, v149, 384);
    *(int32_t *)(*v161 + 40) = -0x5feee01f;
    v150 = v161;
    v155 = v146;
    v152 = v147;
    v153 = v148;
    v154 = v160;
    v151 = 32;
    goto lab_0x3b5e4;
  lab_0x3b5e4:;
    int32_t v163 = v151;
    int32_t v164 = v154;
    int32_t v165 = v152;
    int32_t v166 = v155;
    int32_t * v167 = v150;
    int32_t * v168 = (int32_t *)(*v167 + 12); // 0x3b5ec
    *v168 = *v168 + 1;
    uint64_t v169 = *(int64_t *)*v167; // 0x3b5fc
    int32_t v170 = 12 * ((int32_t)v169 - 1 & v153); // 0x3b60c
    int32_t v171 = v170 + 4;
    int32_t * v172 = (int32_t *)(v171 + (int32_t)(v169 / 0x100000000)); // 0x3b614
    *v172 = *v172 + 1;
    int32_t v173 = *(int32_t *)*v167; // 0x3b624
    *(int32_t *)(v165 + 20) = 0;
    *(int32_t *)(v165 + 24) = *(int32_t *)(v173 + v170);
    int32_t v174 = *(int32_t *)*v167 + v170; // 0x3b63c
    int32_t v175 = *(int32_t *)v174; // 0x3b63c
    int32_t v176 = v174; // 0x3b648
    if (v175 != 0) {
        *(int32_t *)(v175 + 12) = v164;
        v176 = *(int32_t *)*v167;
    }
    // .critedge4.thread
    *(int32_t *)(v176 + (v175 == 0 ? 0 : v170)) = v164;
    uint64_t v177 = *(int64_t *)(*(int32_t *)*v167 + v171); // 0x3b668
    v47 = v166;
    v46 = v163;
    if (10 * (int32_t)v177 + 10 <= (int32_t)(v177 / 0x100000000)) {
        int32_t * v178 = (int32_t *)(v165 + 8); // 0x3b67c
        int32_t v179 = *v178; // 0x3b67c
        v47 = v166;
        v46 = v163;
        if (*(int32_t *)(v179 + 36) != 1) {
            int32_t * mem2 = calloc(24 * *(int32_t *)(v179 + 4), 1); // 0x3b69c
            if (mem2 == NULL) {
                // 0x3b910
                exit(-1);
                return &g306;
            }
            int32_t v180 = (int32_t)mem2; // 0x3b69c
            int32_t v181 = *v178; // 0x3b6a8
            int32_t v182 = *(int32_t *)(v181 + 4); // 0x3b6b0
            uint32_t v183 = *(int32_t *)(v181 + 12); // 0x3b6b4
            int32_t v184 = *(int32_t *)(v181 + 8); // 0x3b6b8
            *(int32_t *)(v181 + 24) = (v183 >> v184 + 1) + (int32_t)((2 * v182 - 1 & v183) != 0);
            *(int32_t *)(*v178 + 28) = 0;
            int32_t v185 = *v178; // 0x3b6e4
            int32_t v186 = *(int32_t *)(v185 + 4); // 0x3b6e8
            int32_t v187 = v185; // 0x3b6f0
            int32_t v188 = v186; // 0x3b6f0
            int32_t v189 = 0; // 0x3b6f0
            int32_t v190 = v166; // 0x3b6f0
            int32_t v191 = v185; // 0x3b6f0
            if (v186 != 0) {
                int32_t v192 = *(int32_t *)(*(int32_t *)v187 + v189); // 0x3b704
                int32_t v193 = v188; // 0x3b70c
                int32_t v194 = v192; // 0x3b70c
                int32_t v195 = v187; // 0x3b70c
                int32_t v196 = v188; // 0x3b70c
                int32_t v197; // 0x3af10
                int32_t * v198; // 0x3b728
                int32_t v199; // 0x3b728
                int32_t v200; // 0x3b738
                int32_t * v201; // 0x3b73c
                uint32_t v202; // 0x3b740
                int32_t v203; // 0x3b748
                uint32_t v204; // 0x3b74c
                int32_t * v205; // 0x3b77c
                int32_t v206; // 0x3b784
                int32_t * v207; // 0x3b758
                int32_t v208; // 0x3b798
                int32_t v209; // 0x3af10
                if (v192 != 0) {
                    v197 = v194;
                    v198 = (int32_t *)(v197 + 16);
                    v199 = *v198;
                    v200 = 12 * (2 * v193 - 1 & *(int32_t *)(v197 + 28)) + v180;
                    v201 = (int32_t *)(v200 + 4);
                    v202 = *v201 + 1;
                    *v201 = v202;
                    v203 = *v178;
                    v204 = *(int32_t *)(v203 + 24);
                    if (v202 != v204 && v202 >= v204) {
                        // 0x3b758
                        v207 = (int32_t *)(v203 + 28);
                        *v207 = *v207 + 1;
                        *(int32_t *)(v200 + 8) = function_48ac8();
                    }
                    // 0x3b778
                    *(int32_t *)(v197 + 12) = 0;
                    v205 = (int32_t *)v200;
                    *v198 = *v205;
                    v206 = *v205;
                    if (v206 != 0) {
                        *(int32_t *)(v206 + 12) = v197;
                    }
                    *v205 = v197;
                    v208 = *v178;
                    v209 = *(int32_t *)(v208 + 4);
                    v195 = v208;
                    v196 = v209;
                    while (v199 != 0) {
                        // 0x3b720
                        v197 = v199;
                        v198 = (int32_t *)(v197 + 16);
                        v199 = *v198;
                        v200 = 12 * (2 * v209 - 1 & *(int32_t *)(v197 + 28)) + v180;
                        v201 = (int32_t *)(v200 + 4);
                        v202 = *v201 + 1;
                        *v201 = v202;
                        v203 = *v178;
                        v204 = *(int32_t *)(v203 + 24);
                        if (v202 != v204 && v202 >= v204) {
                            // 0x3b758
                            v207 = (int32_t *)(v203 + 28);
                            *v207 = *v207 + 1;
                            *(int32_t *)(v200 + 8) = function_48ac8();
                        }
                        // 0x3b778
                        *(int32_t *)(v197 + 12) = 0;
                        v205 = (int32_t *)v200;
                        *v198 = *v205;
                        v206 = *v205;
                        if (v206 != 0) {
                            *(int32_t *)(v206 + 12) = v197;
                        }
                        *v205 = v197;
                        v208 = *v178;
                        v209 = *(int32_t *)(v208 + 4);
                        v195 = v208;
                        v196 = v209;
                    }
                }
                int32_t v210 = 1; // 0x3b7ac
                int32_t v211 = v210; // 0x3b7b8
                v187 = v195;
                v188 = v196;
                v189 += 12;
                v190 = v210;
                v191 = v195;
                while (v210 < v196) {
                    // 0x3b700
                    v192 = *(int32_t *)(*(int32_t *)v187 + v189);
                    v193 = v188;
                    v194 = v192;
                    v195 = v187;
                    v196 = v188;
                    if (v192 != 0) {
                        v197 = v194;
                        v198 = (int32_t *)(v197 + 16);
                        v199 = *v198;
                        v200 = 12 * (2 * v193 - 1 & *(int32_t *)(v197 + 28)) + v180;
                        v201 = (int32_t *)(v200 + 4);
                        v202 = *v201 + 1;
                        *v201 = v202;
                        v203 = *v178;
                        v204 = *(int32_t *)(v203 + 24);
                        if (v202 != v204 && v202 >= v204) {
                            // 0x3b758
                            v207 = (int32_t *)(v203 + 28);
                            *v207 = *v207 + 1;
                            *(int32_t *)(v200 + 8) = function_48ac8();
                        }
                        // 0x3b778
                        *(int32_t *)(v197 + 12) = 0;
                        v205 = (int32_t *)v200;
                        *v198 = *v205;
                        v206 = *v205;
                        if (v206 != 0) {
                            *(int32_t *)(v206 + 12) = v197;
                        }
                        *v205 = v197;
                        v208 = *v178;
                        v209 = *(int32_t *)(v208 + 4);
                        v195 = v208;
                        v196 = v209;
                        while (v199 != 0) {
                            // 0x3b720
                            v197 = v199;
                            v198 = (int32_t *)(v197 + 16);
                            v199 = *v198;
                            v200 = 12 * (2 * v209 - 1 & *(int32_t *)(v197 + 28)) + v180;
                            v201 = (int32_t *)(v200 + 4);
                            v202 = *v201 + 1;
                            *v201 = v202;
                            v203 = *v178;
                            v204 = *(int32_t *)(v203 + 24);
                            if (v202 != v204 && v202 >= v204) {
                                // 0x3b758
                                v207 = (int32_t *)(v203 + 28);
                                *v207 = *v207 + 1;
                                *(int32_t *)(v200 + 8) = function_48ac8();
                            }
                            // 0x3b778
                            *(int32_t *)(v197 + 12) = 0;
                            v205 = (int32_t *)v200;
                            *v198 = *v205;
                            v206 = *v205;
                            if (v206 != 0) {
                                *(int32_t *)(v206 + 12) = v197;
                            }
                            *v205 = v197;
                            v208 = *v178;
                            v209 = *(int32_t *)(v208 + 4);
                            v195 = v208;
                            v196 = v209;
                        }
                    }
                    // 0x3b7a4
                    v210 = v211 + 1;
                    v211 = v210;
                    v187 = v195;
                    v188 = v196;
                    v189 += 12;
                    v190 = v210;
                    v191 = v195;
                }
            }
            int32_t v212 = v190;
            free((int32_t *)*(int32_t *)v191);
            int32_t * v213 = (int32_t *)(*v178 + 4); // 0x3b7cc
            *v213 = 2 * *v213;
            int32_t * v214 = (int32_t *)(*v178 + 8); // 0x3b7dc
            *v214 = *v214 + 1;
            *(int32_t *)*v178 = v180;
            int32_t v215 = *v178; // 0x3b7f0
            uint32_t v216 = *(int32_t *)(v215 + 28); // 0x3b7f4
            uint32_t v217 = *(int32_t *)(v215 + 12) / 2; // 0x3b7fc
            int32_t * v218 = (int32_t *)(v215 + 32);
            int32_t v219 = v216; // 0x3b800
            if (v216 >= v217 == (v216 != v217)) {
                v219 = *v218;
            }
            int32_t v220 = v216 == v217 | v216 < v217 ? 0 : v219;
            *v218 = v220 + (int32_t)(v216 >= v217 == (v216 != v217));
            int32_t v221 = *v178; // 0x3b810
            int32_t v222 = *(int32_t *)(v221 + 32); // 0x3b814
            v47 = v212;
            v46 = v163;
            if (v222 != 0 == (v222 != 1)) {
                *(int32_t *)(v221 + 36) = 1;
                v47 = v212;
                v46 = v163;
            }
        }
    }
    goto lab_0x3b1ec;
  lab_0x3b1ec:
    // 0x3b1ec
    if (pthread_rwlock_wrlock(&g227) != 0) {
        // 0x3b840
        function_2bfac((int32_t)"add_cgpu", 0x2c59);
        // UNREACHABLE
    }
    int32_t v223 = *(int32_t *)((int32_t)&g160 - 1204); // 0x3b204
    g217 = function_1e864(g217, 4 * (v223 + (int32_t)g228) + 8, (int32_t)"cgminer.c", (int32_t)"add_cgpu", 0x2c58);
    if (pthread_rwlock_unlock(&g227) != 0) {
        // 0x3b840
        function_2bfac((int32_t)"add_cgpu", 0x2c59);
        // UNREACHABLE
    }
    // 0x3b258
    v70 = v47;
    function_1da28();
    int32_t v224 = pthread_mutex_lock(&g180); // 0x3b270
    v146 = v70;
    v147 = (int32_t)&g31;
    v148 = (int32_t)&g228;
    v149 = &g217;
    if (v224 == 0) {
        // 0x3b27c
        *(int32_t *)(a1 + 232) = time(NULL);
        int32_t v225 = pthread_mutex_unlock(&g180); // 0x3b290
        v71 = a1;
        v72 = (int32_t)&g31;
        v73 = &g217;
        if (v225 == 0) {
            // 0x3b29c
            function_1da28();
            int32_t v226; // 0x3af10
            int32_t v227; // 0x3af10
            if (g233 == 0) {
                int32_t v228 = (int32_t)g228;
                *(int32_t *)&g228 = v228 + 1;
                v227 = v228;
                v226 = v228;
            } else {
                int32_t v229 = *(int32_t *)((int32_t)&g160 - 1204); // 0x3b2b4
                *(int32_t *)((int32_t)&g160 - 1204) = v229 + 1;
                v227 = v229;
                v226 = (int32_t)g228;
            }
            int32_t v230 = g233 == 0 ? g217 : g217;
            *(int32_t *)(4 * ((g233 == 0 ? 0 : v226) + v227) + v230) = a1;
            int32_t v231 = (int32_t)g228 - g242; // 0x3b2fc
            if (v231 > *(int32_t *)((int32_t)&g160 - 1200)) {
                *(int32_t *)((int32_t)&g160 - 1200) = v231;
            }
            return 1;
        }
        goto lab_0x3b904;
    } else {
        goto lab_0x3b858;
    }
}

// Address range: 0x3b91c - 0x3b97c
int32_t function_3b91c(int32_t a1) {
    int32_t result = function_1e74c(120, "cgminer.c", "copy_drv", 0x2c75); // 0x3b944
    function_2220c(result, (int32_t *)a1, 120, (int32_t)"cgminer.c", (int32_t)"copy_drv", 0x2c76);
    *(char *)(result + 100) = 1;
    return result;
}

// Address range: 0x3b980 - 0x3ba90
int32_t function_3b980(void) {
    // 0x3b980
    int32_t str; // bp-2056, 0x3b980
    int32_t v1; // bp-2376, 0x3b980
    if (sysinfo((struct sysinfo *)&v1) != 0) {
        int32_t err_num = *__errno_location(); // 0x3ba28
        sprintf((char *)&str, "Failed to get sysinfo, errno:%u, reason:%s\n", err_num, strerror(err_num));
        int32_t time_val = time(NULL); // 0x3ba50
        g251 = time_val;
        g256 = time_val + 1;
        return time_val;
    }
    int32_t v2 = v1 + 1; // 0x3b9b0
    g251 = v1;
    g256 = v2;
    int32_t str2; // bp-2312, 0x3b980
    int32_t chars_printed = sprintf((char *)&str2, "set_start_time_point total_tv_start_sys=%ld total_tv_end_sys=%ld\n", v1, v2); // 0x3b9c8
    char v3 = *(char *)&g70; // 0x3b9e8
    int32_t result = chars_printed; // 0x3b9dc
    if ((v3 | *(char *)&g179) != 0 || g28 > (char *)4) {
        // 0x3b9f4
        snprintf((char *)&str, 2048, "%s", &str2);
        result = function_1ccec(5, &str, 0);
    }
    // 0x3ba1c
    return result;
}

// Address range: 0x3ba90 - 0x3c27c
int32_t function_3ba90(void) {
    // 0x3ba90
    pthread_detach(pthread_self());
    pthread_mutex_lock((int32_t *)((int32_t)&g140 - 12));
    int32_t v1 = g184 + 64 * g106; // 0x3bad8
    int32_t v2 = 0; // 0x3bae8
    if (*(int32_t *)(v1 + 12) != 0) {
        // 0x3c198
        function_22140((int32_t)&g3, v1, 1000);
        usleep(0x186a0);
        v2 = 1;
    }
    // 0x3baec
    if (g83 != NULL) {
        // 0x3baf8
        free((int32_t *)g83);
    }
    int32_t v3 = (int32_t)g188; // 0x3bb04
    char * str; // bp-2088, 0x3ba90
    if (g188 >= (char *)1) {
        int32_t v4 = 0;
        char v5; // 0x3bb54
        int32_t v6; // 0x3bb84
        int32_t v7; // 0x3bb88
        int32_t v8; // 0x3bb8c
        if (*(char *)&g71 != 0) {
            // 0x3bb40
            v5 = *(char *)&g70;
            if ((v5 | *(char *)&g179) == 0 != g28 < (char *)7) {
                // 0x3bb74
                v6 = *(int32_t *)(g202 + 4 * v4);
                v7 = *(int32_t *)v6;
                v8 = *(int32_t *)(v6 + 164);
                snprintf((char *)&str, 2048, "before add pool, pool->pool_no = %d, pool->rpc_url = %s\n", v7, (char *)v8);
                function_1ccec(7, (int32_t *)&str, 0);
            }
        }
        int32_t v9 = v4 + 1; // 0x3bba8
        while (v9 != v3) {
            // 0x3bb34
            v4 = v9;
            if (*(char *)&g71 != 0) {
                // 0x3bb40
                v5 = *(char *)&g70;
                if ((v5 | *(char *)&g179) == 0 != g28 < (char *)7) {
                    // 0x3bb74
                    v6 = *(int32_t *)(g202 + 4 * v4);
                    v7 = *(int32_t *)v6;
                    v8 = *(int32_t *)(v6 + 164);
                    snprintf((char *)&str, 2048, "before add pool, pool->pool_no = %d, pool->rpc_url = %s\n", v7, (char *)v8);
                    function_1ccec(7, (int32_t *)&str, 0);
                }
            }
            // 0x3bba8
            v9 = v4 + 1;
        }
    }
    // 0x3bbb4
    function_29d68();
    int32_t str2; // bp-2124, 0x3ba90
    if (g188 == g188) {
        char v10 = *(char *)&g70; // 0x3c044
        if ((v10 | *(char *)&g179) == 0 != g28 < (char *)3) {
            // 0x3c050
            str = (char *)0x75706e49;
            function_1ccec(3, (int32_t *)&str, 0);
        }
        // 0x3c080
        pthread_mutex_unlock((int32_t *)((int32_t)&g140 - 12));
    } else {
        // 0x3bbc4
        *(char *)&g82 = 0;
        int32_t v11 = (int32_t)g188; // 0x3bbcc
        if (g188 > g188) {
            int32_t v12 = v3; // 0x3bbe0
            int32_t v13 = 4 * v3; // 0x3bbe0
            int32_t v14 = *(int32_t *)(g202 + v13); // 0x3bbe8
            int32_t v15 = v14 + 100; // 0x3bbec
            if (*(int32_t *)v15 != 1) {
                // 0x3bbf8
                function_27998(v15);
            }
            int32_t v16 = (int32_t)g188; // 0x3bc00
            v12++;
            *(char *)(v14 + 97) = 1;
            v13 += 4;
            v11 = v16;
            while (v12 < v16) {
                // 0x3bbe4
                v14 = *(int32_t *)(g202 + v13);
                v15 = v14 + 100;
                if (*(int32_t *)v15 != 1) {
                    // 0x3bbf8
                    function_27998(v15);
                }
                // 0x3bc00
                v16 = (int32_t)g188;
                v12++;
                *(char *)(v14 + 97) = 1;
                v13 += 4;
                v11 = v16;
            }
        }
        // 0x3bc18
        if (*(char *)&g71 != 0) {
            char v17 = *(char *)&g70; // 0x3bf48
            if ((v17 | *(char *)&g179) == 0 != g28 < (char *)7) {
                // 0x3bf54
                snprintf((char *)&str, 2048, "total_pools = %d, need to remove %d pools\n", v11, v3);
                function_1ccec(7, (int32_t *)&str, 0);
            }
        }
        // 0x3bc30
        if (g188 >= (char *)1) {
            int32_t v18 = 0;
            char v19; // 0x3bc7c
            int32_t v20; // 0x3bcac
            int32_t v21; // 0x3bcb0
            int32_t v22; // 0x3bcb4
            if (*(char *)&g71 != 0) {
                // 0x3bc68
                v19 = *(char *)&g70;
                if ((v19 | *(char *)&g179) == 0 != g28 < (char *)7) {
                    // 0x3bc9c
                    v20 = *(int32_t *)(g202 + 4 * v18);
                    v21 = *(int32_t *)v20;
                    v22 = *(int32_t *)(v20 + 164);
                    snprintf((char *)&str, 2048, "after add pool, pool->pool_no = %d, pool->rpc_url = %s\n", v21, (char *)v22);
                    function_1ccec(7, (int32_t *)&str, 0);
                }
            }
            char * v23 = g188; // 0x3bcd0
            int32_t v24 = v18 + 1; // 0x3bcd4
            while (v24 < (int32_t)v23) {
                // 0x3bc5c
                v18 = v24;
                char * v25 = v23;
                char * v26 = v25; // 0x3bc64
                if (*(char *)&g71 != 0) {
                    // 0x3bc68
                    v19 = *(char *)&g70;
                    v26 = v25;
                    if ((v19 | *(char *)&g179) == 0 != g28 < (char *)7) {
                        // 0x3bc9c
                        v20 = *(int32_t *)(g202 + 4 * v18);
                        v21 = *(int32_t *)v20;
                        v22 = *(int32_t *)(v20 + 164);
                        snprintf((char *)&str, 2048, "after add pool, pool->pool_no = %d, pool->rpc_url = %s\n", v21, (char *)v22);
                        function_1ccec(7, (int32_t *)&str, 0);
                        v26 = g188;
                    }
                }
                // 0x3bcd0
                v23 = v26;
                v24 = v18 + 1;
            }
        }
        // 0x3bce0
        if (g188 >= (char *)1) {
            int32_t v27 = *(int32_t *)g202; // 0x3bd50
            if (v27 == function_2e47c()) {
                // 0x3bd60
                function_30264(0);
            }
            int32_t v28 = 1; // 0x3bd08
            *(int32_t *)(v27 + 100) = 0;
            g209--;
            g112--;
            g111--;
            g114--;
            function_29530(v27);
            int32_t v29 = v28; // 0x3bd48
            while (v28 != v3) {
                // 0x3bd4c
                v27 = *(int32_t *)g202;
                if (v27 == function_2e47c()) {
                    // 0x3bd60
                    function_30264(0);
                }
                // 0x3bd04
                v28 = v29 + 1;
                *(int32_t *)(v27 + 100) = 0;
                g209--;
                g112--;
                g111--;
                g114--;
                function_29530(v27);
                v29 = v28;
            }
        }
        // 0x3bd6c
        if (*(char *)&g71 != 0) {
            char v30 = *(char *)&g70; // 0x3bef4
            if ((v30 | *(char *)&g179) == 0 != g28 < (char *)7) {
                // 0x3bf00
                snprintf((char *)&str, 2048, "total_pools after removed = %d\n", (int32_t)g188);
                function_1ccec(7, (int32_t *)&str, 0);
            }
        }
        // 0x3bd7c
        if (g188 >= (char *)1) {
            char * v31 = g188; // 0x3be0c
            for (int32_t i = 0; i < (int32_t)v31; i++) {
                int32_t v32 = *(int32_t *)(g202 + 4 * i); // 0x3bdc0
                char v33 = *(char *)&g70; // 0x3bdc8
                char * v34 = v31; // 0x3bdc4
                if ((v33 | *(char *)&g179) == 0 != g28 < (char *)5) {
                    int32_t v35 = *(int32_t *)(v32 + 164); // 0x3bde0
                    int32_t v36 = *(int32_t *)v32; // 0x3bde8
                    snprintf((char *)&str, 2048, "after reload pool, pool->pool_no = %d, pool->rpc_url = %s\n", v36, (char *)v35);
                    function_1ccec(5, (int32_t *)&str, 0);
                    v34 = g188;
                }
                // 0x3be0c
                v31 = v34;
            }
        }
        // 0x3be1c
        function_27704();
        int32_t v37 = 0; // 0x3be20
        v37++;
        sleep(1);
        while (!((v37 == 8 | *(char *)&g82 % 2 != 0))) {
            // 0x3be24
            v37++;
            sleep(1);
        }
        // 0x3be4c
        function_3b980();
        str2 = 0x6572;
        if (*(char *)&g71 != 0) {
            char v38 = *(char *)&g70; // 0x3bf9c
            if ((v38 | *(char *)&g179) != 0 || g28 > (char *)6) {
                // 0x3bfa8
                snprintf((char *)&str, 2048, "pool change success, send %s", &str2);
                function_1ccec(7, (int32_t *)&str, 0);
            }
        }
        int32_t len = strlen((char *)&str2); // 0x3be70
        function_40e70(&str2, len);
        if (*(char *)&g82 == 0) {
            char v39 = *(char *)&g70; // 0x3c0ac
            if ((v39 | *(char *)&g179) == 0 != g28 < (char *)3) {
                // 0x3c0b8
                str = (char *)0x6f727265;
                function_1ccec(3, (int32_t *)&str, 0);
            }
            // 0x3c0e4
            if (g188 >= (char *)1) {
                char * v40 = g188; // 0x3c17c
                for (int32_t i = 0; i < (int32_t)v40; i++) {
                    int32_t v41 = *(int32_t *)(g202 + 4 * i); // 0x3c120
                    char v42 = *(char *)&g70; // 0x3c128
                    char * v43 = v40; // 0x3c124
                    if ((v42 | *(char *)&g179) == 0 != g28 < (char *)3) {
                        int32_t v44 = *(int32_t *)(v41 + 176); // 0x3c140
                        int32_t v45 = *(int32_t *)v41; // 0x3c148
                        int32_t v46 = *(int32_t *)(v41 + 172); // 0x3c158
                        int32_t v47 = *(int32_t *)(v41 + 164); // 0x3c160
                        snprintf((char *)&str, 2048, "pool%d, url = %s, user = %s, pass = %s\n", v45, (char *)v47, (char *)v46, (char *)v44);
                        function_1ccec(3, (int32_t *)&str, 0);
                        v43 = g188;
                    }
                    // 0x3c17c
                    v40 = v43;
                }
            }
        } else {
            // 0x3be8c
            g141 = 1;
        }
        // 0x3be9c
        *(int32_t *)((int32_t)&g160 - 1168) = 1;
        pthread_mutex_unlock((int32_t *)((int32_t)&g140 - 12));
    }
    int32_t result; // 0x3bec0
    if (v2 == 0) {
        // 0x3bebc
        result = sleep(1);
        g88 = 0;
        return result;
    }
    int32_t v48 = 64 * g106 + g184; // 0x3bfe8
    pthread_attr_init(&str2);
    pthread_attr_setstacksize(&str2, 0x200000);
    if (function_21e74(v48, &str2, 0x30818, 0) != 0) {
        // 0x3c238
        str = (char *)0x63746177;
        function_1ccec(3, (int32_t *)&str, 1);
        return function_2ab30(1, 0);
    }
    // 0x3c01c
    pthread_detach(*(int32_t *)(v48 + 12));
    // 0x3bebc
    result = sleep(1);
    g88 = 0;
    return result;
}

// Address range: 0x3c280 - 0x3c594
int32_t function_3c280(void) {
    struct _IO_FILE * stream = fopen64(g78, "rb"); // 0x3c2a4
    int32_t data; // bp-2328, 0x3c280
    int32_t * set_mem = memset(&data, 0, 256); // 0x3c2b8
    int32_t v1; // 0x3c280
    int32_t result; // 0x3c280
    int32_t v2; // 0x3c280
    int32_t str; // bp-2072, 0x3c280
    if (stream == NULL) {
        char v3 = *(char *)&g70; // 0x3c430
        result = (int32_t)set_mem;
        if ((v3 | *(char *)&g179) == 0 == g28 < (char *)3) {
            goto lab_0x3c4c8;
        } else {
            // 0x3c43c
            snprintf((char *)&str, 2048, "Open miner version file %s error", g78);
            v1 = function_1ccec(3, &str, 0);
            v2 = &g179;
            goto lab_0x3c464;
        }
    } else {
        int32_t items_read = fread(&data, 1, 256, stream); // 0x3c2d4
        if (items_read < 1) {
            char v4 = *(char *)&g70; // 0x3c4fc
            result = items_read;
            if ((v4 | *(char *)&g179) == 0 == g28 < (char *)3) {
                goto lab_0x3c4c8;
            } else {
                // 0x3c51c
                snprintf((char *)&str, 2048, "Read miner version file %s error %d", g78, items_read);
                v1 = function_1ccec(3, &str, 0);
                v2 = &g179;
                goto lab_0x3c464;
            }
        } else {
            char * found_char_pos = strchr((char *)&data, 10); // 0x3c2e8
            int32_t v5; // 0x3c280
            if (found_char_pos == NULL) {
                // 0x3c57c
                strcpy((char *)((int32_t)&g144 - 12), (char *)&data);
                v5 = (int32_t)&g144;
            } else {
                int32_t v6 = &data; // 0x3c2a0
                int32_t v7 = (int32_t)found_char_pos; // 0x3c2e8
                function_2220c((int32_t)&g160 - 1164, &data, v7 - v6, (int32_t)"cgminer.c", (int32_t)"read_version_file", 0x2d5c);
                char * v8 = stpcpy((char *)&data, (char *)(v7 + 1)); // 0x3c330
                char * found_char_pos2 = strchr((char *)&data, 10); // 0x3c340
                if (found_char_pos2 == NULL) {
                    // 0x3c564
                    memcpy((int32_t *)((int32_t)&g160 - 908), &data, 1 - v6 + (int32_t)v8);
                    v5 = (int32_t)&g160 - 1152;
                } else {
                    // 0x3c34c
                    function_2220c((int32_t)&g160 - 908, &data, (int32_t)found_char_pos2 - v6, (int32_t)"cgminer.c", (int32_t)"read_version_file", 0x2d65);
                    v5 = (int32_t)&g160 - 1152;
                }
            }
            char * str2 = (char *)(v5 - 12); // 0x3c378
            int32_t len = strlen(str2); // 0x3c378
            char * v9 = (char *)(len + (int32_t)&g160 - 1165); // 0x3c384
            char v10 = *v9; // 0x3c384
            int32_t len2 = len; // 0x3c38c
            char v11 = v10; // 0x3c38c
            if (v10 == 10) {
                // 0x3c390
                *v9 = 0;
                len2 = strlen(str2);
                v11 = *(char *)(len2 + (int32_t)&g160 - 1165);
            }
            // 0x3c3ac
            if (v11 == 13) {
                *(char *)(len2 + (int32_t)&g160 - 1165) = 0;
            }
            int32_t len3 = strlen((char *)&g145); // 0x3c3c0
            char * v12 = (char *)(len3 + (int32_t)&g160 - 909); // 0x3c3cc
            char v13 = *v12; // 0x3c3cc
            int32_t len4 = len3; // 0x3c3d4
            char v14 = v13; // 0x3c3d4
            if (v13 == 10) {
                // 0x3c3d8
                *v12 = 0;
                len4 = strlen((char *)&g145);
                v14 = *(char *)(len4 + (int32_t)&g160 - 909);
            }
            int32_t v15 = len4 - 1;
            v1 = v15;
            v2 = &g179;
            if (v14 == 13) {
                *(char *)(len4 + (int32_t)&g160 - 909) = 0;
                v1 = v15;
                v2 = (int32_t)&g171 | 3304;
            }
            goto lab_0x3c464;
        }
    }
  lab_0x3c4c8:
    // 0x3c4c8
    if (g28 <= (char *)2) {
        // 0x3c4d4
        return result;
    }
    // 0x3c484
    snprintf((char *)&str, 2048, "Miner compile time: %s type: %s", (char *)((int32_t)&g145 - 256), (char *)&g145);
    return function_1ccec(3, &str, 0);
  lab_0x3c464:
    // 0x3c464
    if ((*(char *)&g70 | *(char *)v2) != 0) {
        // 0x3c484
        snprintf((char *)&str, 2048, "Miner compile time: %s type: %s", (char *)((int32_t)&g145 - 256), (char *)&g145);
        return function_1ccec(3, &str, 0);
    }
    // 0x3c4c8
    result = v1;
    goto lab_0x3c4c8;
}

// Address range: 0x3c5a0 - 0x3cc80
int32_t function_3c5a0(void) {
    // 0x3c5a0
    int32_t str; // bp-2344, 0x3c5a0
    if (*(char *)&g71 != 0) {
        char v1 = *(char *)&g70; // 0x3c5dc
        if ((v1 | *(char *)&g179) == 0 != g28 < (char *)7) {
            // 0x3c5e8
            snprintf((char *)&str, 2048, "START %s", "load_default_config_without_restart");
            function_1ccec(7, &str, 0);
        }
    }
    char * v2 = g83; // 0x3c61c
    if (v2 != NULL) {
        // 0x3c628
        free((int32_t *)v2);
    }
    int32_t v3 = function_1e74c(0x1000, "cgminer.c", "load_default_config_without_restart", 0x2e95); // 0x3c640
    g83 = (char *)v3;
    function_29c6c(v3);
    if (access(g83, R_OK) != 0) {
        // 0x3c798
        free((int32_t *)g83);
        g83 = NULL;
        // 0x3c7a8
        return &g306;
    }
    // 0x3c660
    if (*(char *)&g71 != 0) {
        char v4 = *(char *)&g70; // 0x3c748
        if ((v4 | *(char *)&g179) == 0 != g28 < (char *)7) {
            // 0x3c768
            snprintf((char *)&str, 2048, "start %s\n", "judge_load_config");
            function_1ccec(7, &str, 0);
        }
    }
    int32_t * set_mem = memset(&str, 0, 2304); // 0x3c680
    int32_t str2; // bp-4392, 0x3c5a0
    if (g83 == NULL) {
        char v5 = *(char *)&g70; // 0x3c7d0
        if ((v5 | *(char *)&g179) == 0 == g28 < (char *)3) {
            // 0x3c7a8
            return (int32_t)set_mem;
        }
        // 0x3c7f0
        snprintf((char *)&str2, 2048, "%s: bad param", "judge_load_config");
        return function_1ccec(3, &str2, 0);
    }
    // 0x3c68c
    int32_t v6; // bp-4644, 0x3c5a0
    int32_t result2 = function_467a0((int32_t)g83, 0, &v6); // 0x3c698
    if (result2 != 0) {
        // 0x3c6a4
        if (*(int32_t *)result2 == 0) {
            int32_t v7 = &v6; // 0x3c690
            int32_t v8 = v7; // 0x3c844
            if (*(char *)&g71 != 0) {
                char v9 = *(char *)&g70; // 0x3c864
                v8 = v7;
                if ((v9 | *(char *)&g179) == 0 != g28 < (char *)7) {
                    // 0x3c884
                    snprintf((char *)&str2, 2048, "%s: after json_load_file\n", "judge_load_config");
                    function_1ccec(7, &str2, 0);
                    v8 = 0;
                }
            }
            int32_t v10 = function_472ec(result2, "pools"); // 0x3c8b8
            int32_t v11 = v8; // 0x3c8c0
            int32_t v12 = 0; // 0x3c8c0
            if (v10 != 0) {
                // 0x3c8c4
                v11 = v8;
                v12 = 0;
                if (*(int32_t *)v10 == 1) {
                    int32_t v13 = function_47658(v10); // 0x3c9fc
                    int32_t v14 = &str; // 0x3ca28
                    if (function_47658(v10) != 0) {
                        int32_t v15 = 0; // 0x3cba0
                        int32_t v16 = v14; // 0x3c5a0
                        int32_t v17 = function_47674(v10, v15); // 0x3ca4c
                        while (v17 != 0) {
                            // 0x3ca58
                            if (*(int32_t *)v17 != 0) {
                                // break -> 0x3cbb8
                                break;
                            }
                            int32_t v18 = function_472ec(v17, "url"); // 0x3ca7c
                            if (v18 == 0) {
                                // break -> 0x3cbb8
                                break;
                            }
                            // 0x3ca88
                            if (*(int32_t *)v18 != 2) {
                                // break -> 0x3cbb8
                                break;
                            }
                            char * str3 = (char *)v16; // 0x3caa8
                            snprintf(str3, 256, "%s", (char *)function_47820(v18));
                            int32_t v19 = function_472ec(v17, "user"); // 0x3cab4
                            if (v19 == 0) {
                                // break -> 0x3cbb8
                                break;
                            }
                            // 0x3cac0
                            if (*(int32_t *)v19 != 2) {
                                // break -> 0x3cbb8
                                break;
                            }
                            char * str4 = (char *)(v16 + 256); // 0x3cae4
                            snprintf(str4, 256, "%s", (char *)function_47820(v19));
                            int32_t v20 = function_472ec(v17, "pass"); // 0x3caf4
                            if (v20 == 0) {
                                // break -> 0x3cbb8
                                break;
                            }
                            // 0x3cb00
                            if (*(int32_t *)v20 != 2) {
                                // break -> 0x3cbb8
                                break;
                            }
                            char * str5 = (char *)(v16 + 512); // 0x3cb24
                            snprintf(str5, 256, "%s", (char *)function_47820(v20));
                            if (*(char *)&g71 != 0) {
                                char v21 = *(char *)&g70; // 0x3cb50
                                if ((v21 | *(char *)&g179) == 0 != g28 < (char *)7) {
                                    // 0x3cb70
                                    snprintf((char *)&str2, 2048, "%s\n%s\n%s\n", str3, str4, str5);
                                    function_1ccec(7, &str2, 0);
                                }
                            }
                            // 0x3cba0
                            v15++;
                            uint32_t v22 = function_47658(v10); // 0x3cba8
                            v16 += 768;
                            if (v22 >= v15 != v22 != v15) {
                                // break -> 0x3cbb8
                                break;
                            }
                            v17 = function_47674(v10, v15);
                        }
                    }
                    // 0x3cbb8
                    v11 = v13;
                    v12 = 1;
                    if (v13 == (int32_t)g188) {
                        // 0x3cc0c
                        v11 = v13;
                        v12 = 0;
                        if (v13 >= 1) {
                            int32_t str6 = v14; // 0x3cc28
                            int32_t v23 = 0; // 0x3cc28
                            int32_t v24 = g202 - 4; // 0x3cc28
                            v24 += 4;
                            int32_t v25 = *(int32_t *)v24; // 0x3cc5c
                            v11 = v13;
                            v12 = 1;
                            while (strcmp((char *)*(int32_t *)(v25 + 164), (char *)str6) == 0) {
                                int32_t str7 = *(int32_t *)(v25 + 172); // 0x3cc2c
                                v11 = v13;
                                v12 = 1;
                                if (strcmp((char *)str7, (char *)(str6 + 256)) != 0) {
                                    // break -> 0x3c8d4
                                    break;
                                }
                                int32_t str8 = *(int32_t *)(v25 + 176); // 0x3cc44
                                v11 = v13;
                                v12 = 1;
                                if (strcmp((char *)str8, (char *)(str6 + 512)) != 0) {
                                    // break -> 0x3c8d4
                                    break;
                                }
                                // 0x3cc54
                                v23++;
                                v11 = v13;
                                v12 = 0;
                                str6 += 768;
                                if (v13 == v23) {
                                    // break -> 0x3c8d4
                                    break;
                                }
                                v24 += 4;
                                v25 = *(int32_t *)v24;
                                v11 = v13;
                                v12 = 1;
                            }
                        }
                    }
                }
            }
            int32_t v26 = function_472ec(result2, "bitmain-freq-level"); // 0x3c8e0
            int32_t v27 = 0; // 0x3c8e8
            int32_t v28 = (int32_t)"bitmain-freq-level"; // 0x3c8e8
            int32_t v29 = v11; // 0x3c8e8
            int32_t v30 = v12; // 0x3c8e8
            if (v26 != 0) {
                // 0x3c8ec
                v27 = v26;
                v28 = (int32_t)"bitmain-freq-level";
                v29 = v11;
                v30 = v12;
                if (*(int32_t *)v26 == 2) {
                    int32_t str_as_l = strtol((char *)function_47820(v26), NULL, 10); // 0x3cbec
                    int32_t v31 = g48; // 0x3cbf8
                    v27 = str_as_l;
                    v28 = 0;
                    v29 = str_as_l;
                    v30 = v12;
                    if (str_as_l != v31) {
                        g48 = str_as_l;
                        v27 = str_as_l;
                        v28 = 0;
                        v29 = v31;
                        v30 = v12 | 2;
                    }
                }
            }
            int32_t v32 = result2 + 4; // 0x3c8f8
            int32_t * v33 = (int32_t *)v32; // 0x3c8f8
            int32_t v34 = v27; // 0x3c900
            if (*v33 != -1) {
                int32_t v35 = __asm_dmb(v27, v28, v29, v32); // 0x3c9c8
                int32_t v36 = *v33;
                int32_t v37 = v36 - 1; // 0x3c9d0
                while (__asm_strex(v37, v36) != 0) {
                    // 0x3c9cc
                    v36 = *v33;
                    v37 = v36 - 1;
                }
                // 0x3c9e0
                v34 = v35;
                if (v37 == 0) {
                    // 0x3c9e8
                    v34 = function_47c24(result2);
                }
            }
            int32_t result = v34; // 0x3c90c
            if (*(char *)&g71 != 0) {
                char v38 = *(char *)&g70; // 0x3c92c
                result = v34;
                if ((v38 | *(char *)&g179) == 0 != g28 < (char *)7) {
                    // 0x3c94c
                    snprintf((char *)&str2, 2048, "ret = 0x%x", v30);
                    result = function_1ccec(7, &str2, 0);
                }
            }
            // 0x3c974
            switch (v30) {
                case 2: {
                    // 0x3c9ac
                    return function_40e70(&g48, 4);
                }
                case 3: {
                    // 0x3c990
                    function_40e70(&g48, 4);
                    // 0x3c99c
                    return function_28284();
                }
                case 1: {
                    // 0x3c99c
                    return function_28284();
                }
            }
            // 0x3c7a8
            return result;
        }
    }
    char v39 = *(char *)&g70; // 0x3c6cc
    if ((v39 | *(char *)&g179) == 0 == g28 < (char *)3) {
        // 0x3c7a8
        return result2;
    }
    // 0x3c6ec
    int32_t v40; // bp-4552, 0x3c5a0
    snprintf((char *)&str2, 2048, "%s: JSON decode of file '%s' failed\n %s", "judge_load_config", g83, &v40);
    return function_1ccec(3, &str2, 0);
}

// Address range: 0x3cc8c - 0x3ccc8
int32_t function_3cc8c(char * str2, int32_t str) {
    int32_t * mem = malloc(strlen((char *)str) + strlen(str2)); // 0x3ccac
    sprintf((char *)mem, str2);
    return (int32_t)mem;
}

// Address range: 0x3ccc8 - 0x3ccd8
int32_t function_3ccc8(int32_t a1) {
    // 0x3ccc8
    *(char *)a1 = 1;
    return 0;
}

// Address range: 0x3ccd8 - 0x3cce8
int32_t function_3ccd8(int32_t a1) {
    // 0x3ccd8
    *(char *)a1 = 0;
    return 0;
}

// Address range: 0x3cce8 - 0x3ccf8
int32_t function_3cce8(int32_t a1) {
    // 0x3cce8
    *(char *)a1 = 0;
    return 0;
}

// Address range: 0x3ccf8 - 0x3cd8c
int32_t function_3ccf8(int32_t a1, int32_t a2) {
    char * str = (char *)a1; // 0x3cd0c
    if (strcasecmp(str, "yes") == 0 || strcasecmp(str, "true") == 0) {
        // 0x3cd7c
        *(char *)a2 = 1;
        return 0;
    }
    // 0x3cd30
    if (strcasecmp(str, "no") == 0) {
        // 0x3cd6c
        *(char *)a2 = 0;
        return 0;
    }
    // 0x3cd48
    if (strcasecmp(str, "false") != 0) {
        // 0x3cd60
        return function_3d830(a1);
    }
    // 0x3cd6c
    *(char *)a2 = 0;
    return 0;
}

// Address range: 0x3cd8c - 0x3cdac
int32_t function_3cd8c(int32_t a1, int32_t a2) {
    int32_t result = function_3ccf8(a1, a2); // 0x3cd94
    if (result == 0) {
        int32_t v1; // 0x3cd8c
        *(char *)a2 = (char)v1 ^ 1;
    }
    return result;
}

// Address range: 0x3cdac - 0x3cdb8
int32_t function_3cdac(int32_t a1, int32_t * a2) {
    // 0x3cdac
    *a2 = a1;
    return 0;
}

// Address range: 0x3cdb8 - 0x3ce40
int32_t function_3cdb8(int32_t str, int32_t a2) {
    int32_t * v1 = __errno_location(); // 0x3cdc8
    *v1 = 0;
    char * endptr; // bp-20, 0x3cdb8
    strtof((char *)str, &endptr);
    float32_t v2; // 0x3cdb8
    __asm_vstr_15(v2, (int32_t)&endptr);
    int32_t v3; // 0x3cdb8
    if ((char)v3 == 0 | *endptr != 0) {
        // 0x3ce38
        return function_3cc8c("'%s' is not a number", str);
    }
    // 0x3ce04
    if (*v1 == 0) {
        // 0x3ce38
        return 0;
    }
    // 0x3ce10
    return function_3cc8c("'%s' is out of range", str);
}

// Address range: 0x3ce40 - 0x3cec8
int32_t function_3ce40(int32_t str, int32_t * a2) {
    int32_t * v1 = __errno_location(); // 0x3ce50
    *v1 = 0;
    char * endptr; // bp-20, 0x3ce40
    *a2 = strtol((char *)str, &endptr, 0);
    int32_t v2; // 0x3ce40
    if ((char)v2 == 0 | *endptr != 0) {
        // 0x3cec0
        return function_3cc8c("'%s' is not a number", str);
    }
    // 0x3ce8c
    if (*v1 == 0) {
        // 0x3cec0
        return 0;
    }
    // 0x3ce98
    return function_3cc8c("'%s' is out of range", str);
}

// Address range: 0x3cec8 - 0x3cef0
int32_t function_3cec8(int32_t a1, int32_t a2) {
    // 0x3cec8
    int32_t v1; // bp-12, 0x3cec8
    int32_t result = function_3ce40(a1, &v1); // 0x3ced8
    if (result == 0) {
        *(int32_t *)a2 = v1;
    }
    return result;
}

// Address range: 0x3cef0 - 0x3cf40
int32_t function_3cef0(int32_t a1, int32_t a2) {
    // 0x3cef0
    int32_t v1; // bp-20, 0x3cef0
    int32_t result = function_3ce40(a1, &v1); // 0x3cf04
    if (result != 0) {
        // 0x3cf10
        return result;
    }
    // 0x3cf18
    if (v1 < 0) {
        // 0x3cf28
        return function_3cc8c("'%s' is negative", a1);
    }
    // .thread
    *(int32_t *)a2 = v1;
    // 0x3cf10
    return result;
}

// Address range: 0x3cf40 - 0x3cf90
int32_t function_3cf40(int32_t a1, int32_t a2) {
    // 0x3cf40
    int32_t v1; // bp-20, 0x3cf40
    int32_t result = function_3ce40(a1, &v1); // 0x3cf54
    if (result != 0) {
        // 0x3cf60
        return result;
    }
    // 0x3cf68
    *(int32_t *)a2 = v1;
    if (v1 < 0) {
        // 0x3cf78
        return function_3cc8c("'%s' is negative", a1);
    }
    // 0x3cf60
    return result;
}

// Address range: 0x3cf90 - 0x3cfa8
int32_t function_3cf90(int32_t a1) {
    // 0x3cf90
    *(int32_t *)a1 = 1;
    return 0;
}

// Address range: 0x3cfa8 - 0x3cfc8
int32_t function_3cfa8(void) {
    // 0x3cfa8
    int32_t str; // 0x3cfa8
    puts((char *)str);
    fflush(g60);
    exit(0);
    // UNREACHABLE
}

// Address range: 0x3cfc8 - 0x3d008
int32_t function_3cfc8(int32_t a1) {
    // 0x3cfc8
    printf("%s", g278);
    fflush(g60);
    exit(0);
    // UNREACHABLE
}

// Address range: 0x3d008 - 0x3d02c
int32_t function_3d008(void) {
    // 0x3d008
    int32_t str; // 0x3d008
    char * str2 = (char)str == 0 ? "false" : "true"; // 0x3d028
    return (int32_t)strncpy((char *)str, str2, 80);
}

// Address range: 0x3d02c - 0x3d050
int32_t function_3d02c(void) {
    // 0x3d02c
    int32_t str; // 0x3d02c
    char * str2 = (char)str == 0 ? "true" : "false"; // 0x3d04c
    return (int32_t)strncpy((char *)str, str2, 80);
}

// Address range: 0x3d050 - 0x3d0b0
int32_t function_3d050(int32_t a1, int32_t a2) {
    char * str = (char *)a2; // 0x3d064
    uint32_t len = strlen(str); // 0x3d064
    *(char *)a1 = 34;
    int32_t str2 = a1 + 1; // 0x3d074
    if (len >= 78 == (len != 78)) {
        char * dest_str = strncpy((char *)str2, str, 78); // 0x3d0a4
        *(char *)(a1 + 79) = 34;
        return (int32_t)dest_str;
    }
    int32_t v1 = len + a1; // 0x3d084
    char * dest_str2 = strncpy((char *)str2, str, len); // 0x3d088
    *(char *)(v1 + 1) = 34;
    if (len != 78) {
        *(char *)(v1 + 2) = 0;
    }
    return (int32_t)dest_str2;
}

// Address range: 0x3d0b0 - 0x3d0c4
int32_t function_3d0b0(int32_t str, int32_t a2) {
    // 0x3d0b0
    return snprintf((char *)str, 80, "%i", a2);
}

// Address range: 0x3d0c4 - 0x3d0c6
int32_t function_3d0c4(void) {
    // 0x3d0c4
    return function_3d0d0();
}

// Address range: 0x3d0c6 - 0x3d0ce
int32_t function_3d0c6(int32_t a1) {
    // 0x3d0c6
    bool v1; // 0x3d0c6
    if (v1) {
        int32_t v2; // 0x3d0c6
        __asm_mrrchs(5, 2, v2, a1, 13);
    }
    int32_t result = a1; // 0x3d0ca
    if (!v1) {
        result = function_75cde();
    }
    // 0x3d0ce
    return result;
}

// Address range: 0x3d0d0 - 0x3d0d4
int32_t function_3d0d0(void) {
    // 0x3d0d0
    int32_t result; // 0x3d0d0
    return result;
}

// Address range: 0x3d0d4 - 0x3d0d8
int32_t function_3d0d4(void) {
    // 0x3d0d4
    return 5;
}

// Address range: 0x3d0d8 - 0x3d0dc
int32_t function_3d0d8(int32_t a1, int32_t a2, int32_t a3) {
    // 0x3d0d8
    return function_3d81e();
}

// Address range: 0x3d0de - 0x3d0e2
int32_t function_3d0de(void) {
    // 0x3d0de
    int32_t result; // 0x3d0de
    bool v1; // 0x3d0de
    if (!v1) {
        result = function_78bc2();
    }
    // 0x3d0e2
    return result;
}

// Address range: 0x3d0e4 - 0x3d0ec
int32_t function_3d0e4(void) {
    // 0x3d0e4
    int32_t str; // 0x3d0e4
    return snprintf((char *)str, str, (char *)str);
}

// Address range: 0x3d0ee - 0x3d0f0
int32_t function_3d0ee(void) {
    // 0x3d0ee
    int32_t result; // 0x3d0ee
    return result;
}

// Address range: 0x3d0f0 - 0x3d104
int32_t function_3d0f0(int32_t str, int32_t a2) {
    // 0x3d0f0
    return snprintf((char *)str, 80, "%u", a2);
}

// Address range: 0x3d104 - 0x3d118
int32_t function_3d104(int32_t str, int32_t a2) {
    // 0x3d104
    return snprintf((char *)str, 80, "%li", a2);
}

// Address range: 0x3d118 - 0x3d12c
int32_t function_3d118(int32_t str, int32_t a2) {
    // 0x3d118
    return snprintf((char *)str, 80, "%lu", a2);
}

// Address range: 0x3d12c - 0x3d1cc
int32_t function_3d12c(int32_t a1, int32_t a2) {
    int32_t * v1 = (int32_t *)a1; // 0x3d13c
    *v1 = 0;
    if (g275 == 0) {
        // 0x3d184
        return 0;
    }
    int32_t v2 = g277; // 0x3d160
    int32_t v3 = 28; // 0x3d160
    if (*(int32_t *)(g277 + 4) != 8) {
      lab_0x3d164:;
        int32_t str = *(int32_t *)v2 + 1; // 0x3d174
        *(int32_t *)a2 = strcspn((char *)str, "|= ");
        // 0x3d184
        return str;
    }
    uint32_t v4 = 1;
    *v1 = v4;
    while (g275 != v4 && g275 >= v4) {
        int32_t v5 = g277 + v3; // 0x3d1ac
        v2 = v5;
        v3 += 28;
        if (*(int32_t *)(v5 + 4) != 8) {
            goto lab_0x3d164;
        }
        v4++;
        *v1 = v4;
    }
    // 0x3d184
    return 0;
}

// Address range: 0x3d1cc - 0x3d214
int32_t function_3d1cc(int32_t a1, int32_t a2) {
    int32_t v1 = a2 + a1; // 0x3d1d4
    int32_t str = 0; // 0x3d1f4
    switch (*(char *)v1) {
        default: {
            // 0x3d1f0
            str = v1 + 2;
            *(int32_t *)a2 = strcspn((char *)str, "|= ");
        }
        case 61: {
        }
        case 32: {
        }
        case 0: {
            // 0x3d20c
            return str;
        }
    }
}

// Address range: 0x3d214 - 0x3d2cc
int32_t function_3d214(int32_t a1, uint32_t a2, int32_t a3) {
    // 0x3d214
    if ((uint32_t)g275 <= a2) {
        // 0x3d290
        return 0;
    }
    int32_t v1 = g277 + 28 * a2; // 0x3d254
    int32_t v2 = a1; // 0x3d260
    int32_t v3 = a2; // 0x3d260
    int32_t v4; // 0x3d26c
    int32_t str; // 0x3d2a8
    if (*(int32_t *)(v1 + 4) != 8) {
        if (a1 == 0) {
            // 0x3d29c
            str = *(int32_t *)v1 + 1;
            *(int32_t *)a3 = strcspn((char *)str, "|= ");
            return str;
        }
        // 0x3d26c
        v4 = function_3d1cc(a1, a3);
        v2 = 0;
        v3 = a3;
        if (v4 != 0) {
            // break -> 0x3d290
            break;
        }
    }
    int32_t v5 = v3 + 1; // 0x3d27c
    *(int32_t *)a2 = v5;
    int32_t result = 0; // 0x3d28c
    while (v5 < g275) {
        int32_t v6 = v2;
        v1 = g277 + 28 * v5;
        v2 = v6;
        v3 = v5;
        if (*(int32_t *)(v1 + 4) != 8) {
            if (v6 == 0) {
                // 0x3d29c
                str = *(int32_t *)v1 + 1;
                *(int32_t *)a3 = strcspn((char *)str, "|= ");
                return str;
            }
            // 0x3d26c
            v4 = function_3d1cc(v6, a3);
            v2 = 0;
            v3 = a3;
            result = v4;
            if (v4 != 0) {
                // break -> 0x3d290
                break;
            }
        }
        // 0x3d27c
        v5 = v3 + 1;
        *(int32_t *)a2 = v5;
        result = 0;
    }
    // 0x3d290
    return result;
}

// Address range: 0x3d2cc - 0x3d440
int32_t function_3d2cc(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    uint64_t v2 = *(int64_t *)&v1; // 0x3d2d4
    int32_t v3 = v2;
    int32_t v4 = v2 / 0x100000000; // 0x3d2d4
    int32_t v5 = v3 - 1; // 0x3d2d8
    if (!((v3 == 4 ? v3 < 4 : v5 == 0)) == (v3 != 4 && v5 != 1)) {
        // 0x3d430
        errx(1, "Option %s: unknown entry type %u", (char *)v4, v3);
        return &g306;
    }
    char * v6 = (char *)v4;
    char * v7 = v6; // 0x3d2f4
    int32_t v8 = 0; // 0x3d2f4
    int32_t v9; // 0x3d2cc
    int32_t v10; // 0x3d2cc
    int32_t v11; // 0x3d2cc
    int32_t v12; // 0x3d2cc
    int32_t v13; // 0x3d2cc
    int32_t v14; // 0x3d2cc
    int32_t v15; // 0x3d2cc
    int32_t v16; // 0x3d2cc
    char * v17; // bp-28, 0x3d2cc
    unsigned char v18; // 0x3d2f8
    if (*(int32_t *)(v3 + 24) == 0) {
        goto lab_0x3d420;
    } else {
        // 0x3d2f8
        v18 = *v6;
        if (v18 == 45) {
            int32_t str = v4 + 1; // 0x3d304
            int32_t ini_seg_bytes = strcspn((char *)str, "|= "); // 0x3d324
            v1 = ini_seg_bytes;
            v17 = (char *)ini_seg_bytes;
            int32_t * v19 = (int32_t *)(v3 + 4);
            v9 = ini_seg_bytes;
            v14 = str;
            while (true) {
              lab_0x3d394:
                // 0x3d394
                v15 = v14;
                int32_t v20 = v9; // 0x3d36c
                int32_t v21; // 0x3d2cc
                if (*(char *)v15 == 45) {
                    // 0x3d3a0
                    if (v20 == 1) {
                        // break -> 0x3d400
                        break;
                    }
                    // 0x3d3a8
                    g273++;
                    v21 = *v19;
                } else {
                    if (v20 != 1) {
                        int32_t v22 = v15 - 1; // 0x3d3c4
                        errx(1, "Option %s: invalid short option '%.*s'", (char *)v20, v20 + 1, (char *)v22);
                        v1 = &g306;
                        v10 = &g306;
                        v16 = v22;
                        v13 = v12;
                        goto lab_0x3d3e4;
                    }
                    int32_t v23 = *v19; // 0x3d340
                    g274++;
                    v21 = v23;
                    if ((v23 - 2 & -3) == 0) {
                        g276++;
                        v21 = v23;
                    }
                }
                // 0x3d364
                v11 = v21;
                if (v11 == 1) {
                    // 0x3d36c
                    v10 = v20;
                    v16 = v15;
                    v13 = 1;
                    switch (*(char *)(v15 + v20)) {
                        case 61: {
                            goto lab_0x3d3e4;
                        }
                        case 32: {
                            goto lab_0x3d3e4;
                        }
                        default: {
                            goto lab_0x3d37c;
                        }
                    }
                } else {
                    goto lab_0x3d37c;
                }
            }
        } else {
            goto lab_0x3d410;
        }
    }
  lab_0x3d37c:;
    int32_t v24 = function_3d1cc(v15, (int32_t)&v17); // 0x3d384
    v1 = v24;
    if (v24 == 0) {
        // 0x3d3bc
        return 0;
    }
    int32_t v25 = (int32_t)v17; // 0x3d390
    v1 = v25;
    v9 = v25;
    v14 = v24;
    v12 = v11;
    goto lab_0x3d394;
  lab_0x3d3e4:;
    int32_t v26 = v10 + 1 + v16; // 0x3d3ec
    errx(v13, "Option %s: does not take arguments '%s'", (char *)v10, (char *)v26);
    v1 = &g306;
    goto lab_0x3d400;
  lab_0x3d420:
    // 0x3d420
    errx(1, "Option %s: description cannot be NULL", v7);
    // 0x3d430
    errx(1, "Option %s: unknown entry type %u", v7, v8);
    return &g306;
  lab_0x3d410:
    // 0x3d410
    v8 = v18;
    v7 = v6;
    errx(1, "Option %s: does not begin with '-'", v7);
    goto lab_0x3d420;
  lab_0x3d400:;
    // 0x3d400
    int32_t v27; // 0x3d2cc
    int32_t v28 = v27;
    char * v29 = (char *)v28;
    errx(v28, "Option %s: invalid long option '--'", v29);
    goto lab_0x3d410;
}

// Address range: 0x3d440 - 0x3d4a4
int32_t function_3d440(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    int32_t mem = (int32_t)realloc((int32_t *)g277, 28 * g275 + 28); // 0x3d46c
    int32_t v2 = g275; // 0x3d470
    g277 = mem;
    g275 = v2 + 1;
    int32_t v3 = 28 * v2 + mem; // 0x3d490
    *(int32_t *)v3 = mem;
    *(int32_t *)(v3 + 4) = *(int32_t *)(v1 + 4);
    *(int32_t *)(v3 + 8) = *(int32_t *)(v1 + 8);
    *(int32_t *)(v3 + 12) = *(int32_t *)(v1 + 12);
    int32_t result = *(int32_t *)(v1 + 16); // 0x3d498
    *(int32_t *)(v3 + 16) = result;
    *(int32_t *)(v3 + 20) = *(int32_t *)(v1 + 20);
    *(int32_t *)(v3 + 24) = *(int32_t *)(v1 + 24);
    return result;
}

// Address range: 0x3d4a4 - 0x3d4fc
int32_t function_3d4a4(int32_t * a1, int32_t * a2) {
    int32_t v1 = (int32_t)a2;
    int32_t v2 = (int32_t)a1;
    int32_t v3 = function_3d12c(v2, v1); // 0x3d4b0
    if (v3 == 0) {
        // 0x3d4f4
        return 0;
    }
    int32_t v4 = v3; // 0x3d4dc
    if (*(char *)v3 == 45) {
        // 0x3d4e0
        *a2 = v1 - 1;
        return v3 + 1;
    }
    v4 = function_3d214(v4, v2, v1);
    while (v4 != 0) {
        int32_t v5 = v4; // 0x3d4dc
        if (*(char *)v4 == 45) {
            // 0x3d4e0
            *a2 = v2 - 1;
            return v5 + 1;
        }
        v4 = function_3d214(v4, v2, v1);
    }
    // 0x3d4f4
    return 0;
}

// Address range: 0x3d4fc - 0x3d554
int32_t function_3d4fc(int32_t a1, int32_t a2, int32_t * a3) {
    int32_t v1 = (int32_t)a3;
    int32_t v2 = function_3d214(a1, a2, v1); // 0x3d508
    if (v2 == 0) {
        // 0x3d54c
        return 0;
    }
    int32_t v3 = v2;
    while (*(char *)v3 != 45) {
        int32_t v4 = function_3d214(v3, a2, v1); // 0x3d520
        if (v4 == 0) {
            // 0x3d54c
            return 0;
        }
        v3 = v4;
    }
    // 0x3d538
    *a3 = v1 - 1;
    return v3 + 1;
}

// Address range: 0x3d554 - 0x3d5b4
int32_t function_3d554(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    int32_t v2 = 0; // bp-20, 0x3d568
    int32_t v3 = &v2; // 0x3d56c
    int32_t v4 = function_3d12c(v1, v3); // 0x3d570
    if (v4 == 0) {
        // 0x3d5a0
        return 0;
    }
    int32_t v5 = v4; // 0x3d578
    int32_t result = v5; // 0x3d59c
    while (*(char *)v5 == 45) {
        // 0x3d580
        v5 = function_3d214(v5, v1, v3);
        result = 0;
        if (v5 == 0) {
            // break -> 0x3d5a0
            break;
        }
        result = v5;
    }
    // 0x3d5a0
    return result;
}

// Address range: 0x3d5b4 - 0x3d614
int32_t function_3d5b4(int32_t a1, int32_t a2) {
    int32_t v1 = 1; // bp-20, 0x3d5c8
    int32_t v2 = &v1; // 0x3d5cc
    int32_t v3 = function_3d214(a1, a2, v2); // 0x3d5d0
    if (v3 == 0) {
        // 0x3d600
        return 0;
    }
    int32_t v4 = v3; // 0x3d5d8
    int32_t result = v4; // 0x3d5fc
    while (*(char *)v4 == 45) {
        // 0x3d5e0
        v4 = function_3d214(v4, a2, v2);
        result = 0;
        if (v4 == 0) {
            // break -> 0x3d600
            break;
        }
        result = v4;
    }
    // 0x3d600
    return result;
}

// Address range: 0x3d614 - 0x3d658
int32_t function_3d614(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    int32_t v1 = a1; // bp-36, 0x3d62c
    function_3d2cc(&v1);
    return function_3d440(&v1);
}

// Address range: 0x3d658 - 0x3d72c
int32_t function_3d658(char (**a1)[15], char * a2) {
    int32_t result = (int32_t)a1;
    int32_t v1 = g275; // 0x3d670
    int32_t v2; // 0x3d658
    if (a2 == NULL) {
        int32_t v3 = *(int32_t *)(result + 4); // 0x3d708
        v2 = v3;
        if (v3 == 16) {
            // 0x3d700
            return result;
        }
        goto lab_0x3d6b0;
    } else {
        int32_t v4 = 0; // bp-52, 0x3d684
        function_3d440(&v4);
        int32_t v5 = *(int32_t *)(result + 4); // 0x3d6a4
        v2 = v5;
        if (v5 == 16) {
            goto lab_0x3d6e0;
        } else {
            goto lab_0x3d6b0;
        }
    }
  lab_0x3d6b0:;
    // 0x3d6b0
    int32_t result2; // 0x3d658
    int32_t * v6; // 0x3d6bc
    int32_t v7; // 0x3d71c
    if (v2 == 8) {
        // 0x3d71c
        v7 = *(int32_t *)(result + 24);
        result2 = function_3d658((char (**)[15])*(int32_t *)result, (char *)v7);
    } else {
        // 0x3d6bc
        v6 = (int32_t *)result;
        function_3d2cc(v6);
        result2 = function_3d440(v6);
    }
    int32_t v8 = *(int32_t *)(result + 32); // 0x3d6cc
    int32_t v9 = result + 28; // 0x3d6d4
    while (v8 != 16) {
        int32_t v10 = v9;
        if (v8 == 8) {
            // 0x3d71c
            v7 = *(int32_t *)(v10 + 24);
            int32_t v11 = *(int32_t *)v10; // 0x3d720
            result2 = function_3d658((char (**)[15])v11, (char *)v7);
        } else {
            // 0x3d6bc
            v6 = (int32_t *)v10;
            function_3d2cc(v6);
            result2 = function_3d440(v6);
        }
        // 0x3d6c8
        v8 = *(int32_t *)(v10 + 32);
        v9 = v10 + 28;
    }
    // 0x3d6d8
    if (a2 == NULL) {
        // 0x3d700
        return result2;
    }
    goto lab_0x3d6e0;
  lab_0x3d6e0:
    // 0x3d6e0
    *(int32_t *)(28 * v1 + 20 + g277) = g275 - v1;
    // 0x3d700
    return 7 * v1;
}

// Address range: 0x3d72c - 0x3d788
int32_t function_3d72c(int32_t * a1, int32_t a2, int32_t a3) {
    // 0x3d72c
    *(int32_t *)&g278 = a2;
    int32_t v1 = 0; // bp-28, 0x3d758
    while (function_3d898((int32_t)a1, a2, &v1, a3) == 1) {
        // continue -> 0x3d75c
    }
    // 0x3d778
    return 0;
}

// Address range: 0x3d788 - 0x3d7a8
int32_t function_3d788(void) {
    // 0x3d788
    free((int32_t *)g277);
    g277 = 0;
    return &g306;
}

// Address range: 0x3d7a8 - 0x3d7f0
int32_t function_3d7a8(int32_t format, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = a2; // bp-12, 0x3d7a8
    vfprintf(g61, (char *)format, (int32_t)&v1);
    return fputc(10, g61);
}

// Address range: 0x3d7f0 - 0x3d81c
int32_t function_3d7f0(int32_t format, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = a2; // bp-12, 0x3d7f0
    return vfprintf(g61, (char *)format, (int32_t)&v1);
}

// Address range: 0x3d81e - 0x3d820
int32_t function_3d81e(void) {
    // 0x3d81e
    int32_t result; // 0x3d81e
    return result;
}

// Address range: 0x3d820 - 0x3d830
int32_t function_3d820(void) {
    // 0x3d820
    int32_t stream; // 0x3d820
    fputc(10, (struct _IO_FILE *)stream);
    exit(1);
    return &g306;
}

// Address range: 0x3d830 - 0x3d860
int32_t function_3d830(int32_t a1) {
    char * str = (char *)a1; // 0x3d838
    int32_t * mem = malloc(strlen(str) + 22); // 0x3d840
    sprintf((char *)mem, "Invalid argument '%s'", str);
    return (int32_t)mem;
}

// Address range: 0x3d860 - 0x3d898
int32_t function_3d860(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = 4 * a3 + a2;
    int32_t dest_mem = (int32_t)memmove((int32_t *)v1, (int32_t *)(v1 + 4), 4 * (a1 - a3)); // 0x3d884
    *(int32_t *)a1 = dest_mem - 1;
    return dest_mem;
}

// Address range: 0x3d898 - 0x3e18c
int32_t function_3d898(int32_t a1, int32_t a2, int32_t * a3, int32_t a4) {
    int32_t v1 = (int32_t)a3;
    char * env_val = getenv("POSIXLY_CORRECT"); // 0x3d8b8
    int32_t v2 = a2 + 4;
    int32_t v3 = *(int32_t *)v2; // 0x3d8c0
    int32_t v4; // 0x3d898
    int32_t v5; // 0x3d898
    int32_t v6; // 0x3d898
    int32_t v7; // 0x3d898
    int32_t v8; // 0x3d898
    int32_t v9; // 0x3d898
    int32_t v10; // 0x3d898
    if (env_val == NULL) {
        // 0x3d8ec
        if (v3 == 0) {
            // 0x3d8e4
            return 0;
        }
        int32_t v11 = v3; // 0x3d8fc
        int32_t v12 = v1; // 0x3d8fc
        int32_t v13 = 1; // 0x3d8fc
        int32_t v14 = v2; // 0x3d8fc
        if (*(char *)v3 != 45) {
            int32_t v15 = 1; // 0x3d908
            int32_t v16 = a2 + 8;
            int32_t v17 = *(int32_t *)v16; // 0x3d91c
            while (v17 != 0) {
                // 0x3d90c
                v15++;
                v11 = v17;
                v12 = 45;
                v13 = v15;
                v14 = v16;
                if (*(char *)v17 == 45) {
                    goto lab_0x3d938;
                }
                v16 += 4;
                v17 = *(int32_t *)v16;
            }
        }
      lab_0x3d938:
        // 0x3d938
        v5 = v12;
        v7 = v13;
        v9 = v14;
        v4 = v11;
        v6 = v12;
        v8 = v13;
        v10 = v14;
        if (*(char *)(v11 + 1) == 45) {
            goto lab_0x3da04;
        } else {
            goto lab_0x3d944;
        }
    } else {
        // 0x3d8c8
        if (v3 == 0 || *(char *)v3 != 45) {
            // 0x3d8e4
            return 0;
        }
        // 0x3da28
        v5 = v1;
        v7 = 1;
        v9 = v2;
        v4 = v3;
        v6 = v1;
        v8 = 1;
        v10 = v2;
        if (*(char *)(v3 + 1) == 45) {
            goto lab_0x3da04;
        } else {
            goto lab_0x3d944;
        }
    }
  lab_0x3d97c:;
    // 0x3d97c
    int32_t v18; // 0x3d968
    *a3 = v18;
    int32_t v19 = 2; // bp-44, 0x3d9a0
    int32_t v20; // bp-48, 0x3d898
    int32_t v21 = 28 * v20; // 0x3d9a4
    int32_t v22 = g277 + v21; // 0x3d9a8
    int32_t v23 = v22; // 0x3d9b4
    int32_t v24 = v7; // 0x3d9b4
    int32_t v25 = v9; // 0x3d9b4
    int32_t * v26; // 0x3d898
    int32_t v27; // 0x3d898
    int32_t v28; // 0x3d898
    int32_t v29; // 0x3d898
    int32_t v30; // 0x3d898
    int32_t v31; // 0x3d898
    int32_t v32; // 0x3d898
    int32_t v33; // 0x3d898
    int32_t v34; // 0x3d898
    int32_t v35; // 0x3d898
    int32_t v36; // 0x3d898
    int32_t v37; // 0x3d898
    int32_t * v38; // 0x3d898
    if (*(int32_t *)(v22 + 4) == 1) {
        goto lab_0x3db48;
    } else {
        // 0x3d9b8
        v28 = v20;
        v37 = v9;
        v35 = v7;
        v33 = &g277;
        v31 = v21;
        v26 = v38;
        v27 = v20;
        v36 = v9;
        v34 = v7;
        v32 = &g277;
        v30 = v21;
        v29 = v18;
        if (v18 == 0) {
            goto lab_0x3d9c0;
        } else {
            goto lab_0x3dbb4;
        }
    }
  lab_0x3db10:;
    // 0x3db10
    int32_t str; // 0x3d898
    strlen((char *)*(int32_t *)str);
    // 0x3d8e4
    return -1;
  lab_0x3daf8:;
    // 0x3daf8
    int32_t str2; // 0x3d898
    int32_t v39 = function_3d4fc(str2, (int32_t)&v20, &v19); // 0x3db04
    str2 = v39;
    str = v10;
    if (v39 == 0) {
        goto lab_0x3db10;
    }
    goto lab_0x3da74;
  lab_0x3da04:
    // 0x3da04
    if (*(char *)(v4 + 2) == 0) {
        // 0x3da10
        function_3d860(a1, a2, v8);
        // 0x3d8e4
        return 0;
    }
    // 0x3da3c
    if (v6 != 0) {
        // 0x3dd28
        __assert_fail("*offset == 0", "ccan/opt/parse.c", 59, "parse_one");
        int32_t v45 = strlen((char *)&g306) + 20 + g274 + strlen("ccan/opt/parse.c"); // 0x3dd90
        int32_t size = v45; // 0x3dd94
        if (g275 != 0) {
            int32_t v46 = g277; // 0x3ddb4
            int32_t v47 = v45; // 0x3ddb4
            int32_t v48 = 0; // 0x3ddb4
            while (true) {
                int32_t v49 = v48;
                int32_t v50 = v47;
                int32_t str4 = v46;
                int32_t str3 = *(int32_t *)(str4 + 24); // 0x3de08
                int32_t v51; // 0x3d898
                int32_t v52; // 0x3d898
                if (*(int32_t *)(str4 + 4) == 8) {
                    int32_t v53 = v49 + 1; // 0x3de18
                    int32_t v54 = v50 + 3 + strlen((char *)str3); // 0x3de28
                    v51 = v54;
                    v52 = v53;
                    size = v54;
                    if (v53 >= g275) {
                        // break -> 0x3de38
                        break;
                    }
                } else {
                    int32_t v55 = v50; // 0x3ddbc
                    if (str3 != (int32_t)&g279) {
                        int32_t len = strlen((char *)*(int32_t *)str4); // 0x3ddc4
                        int32_t len2 = strlen((char *)str3); // 0x3ddd0
                        int32_t v56 = *(int32_t *)(str4 + 16); // 0x3ddd4
                        v55 = v50 + 7 + len + len2 + (v56 == 0 ? 21 : 118);
                    }
                    int32_t v57 = v49 + 1; // 0x3ddf0
                    v51 = v55;
                    v52 = v57;
                    size = v55;
                    if (v57 >= g275) {
                        // break -> 0x3de38
                        break;
                    }
                }
                // 0x3de00
                v46 = str4 + 28;
                v47 = v51;
                v48 = v52;
            }
        }
        int32_t * mem = malloc(size); // 0x3de3c
        int32_t result = (int32_t)mem; // 0x3de3c
        if (mem == NULL) {
            // 0x3d8e4
            return result;
        }
        int32_t v58 = sprintf((char *)mem, "Usage: %s", (char *)&g306) + result; // 0x3de6c
        *(int32_t *)v58 = 0x2d5b20;
        int32_t v59; // bp-188, 0x3d898
        int32_t v60 = function_3d554(&v59); // 0x3de80
        int32_t v61 = v58; // 0x3de88
        if (v60 != 0) {
            int32_t v62 = v58 + 3; // 0x3de74
            int32_t v63 = 0;
            int32_t v64 = *(int32_t *)(28 * v59 + 24 + g277); // 0x3deb8
            if (v64 != (int32_t)&g279) {
                *(char *)(v63 + v62) = *(char *)v60;
            }
            int32_t v65 = v63 + (int32_t)(v64 != (int32_t)&g279);
            int32_t v66 = function_3d5b4(v60, (int32_t)&v59); // 0x3decc
            while (v66 != 0) {
                int32_t v67 = v66;
                v63 = v65;
                v64 = *(int32_t *)(28 * v59 + 24 + g277);
                if (v64 != (int32_t)&g279) {
                    *(char *)(v63 + v62) = *(char *)v67;
                }
                // .thread
                v65 = v63 + (int32_t)(v64 != (int32_t)&g279);
                v66 = function_3d5b4(v67, (int32_t)&v59);
            }
            // 0x3ded8
            v61 = v58;
            if (v65 != 0) {
                int32_t v68 = v65 + v62; // 0x3e0fc
                *(int16_t *)v68 = 93;
                v61 = v68 + 1;
            }
        }
        int32_t str5 = v61;
        int32_t v69 = sprintf((char *)str5, " %s", "ccan/opt/parse.c") + str5; // 0x3df00
        int32_t v70 = v69 + 1; // 0x3df08
        *(int16_t *)v69 = 10;
        int32_t v71 = v70; // 0x3df18
        if (g275 != 0) {
            int32_t v72 = 0;
            int32_t str6 = v70;
            int32_t v73 = g277 + v72; // 0x3e014
            int32_t v74 = *(int32_t *)(v73 + 24); // 0x3e018
            int32_t v75 = str6; // 0x3e020
            int32_t v76; // 0x3d898
            int32_t v77; // 0x3d898
            int32_t str8; // 0x3d898
            int32_t v78; // 0x3d898
            int32_t v79; // 0x3d898
            uint32_t v80; // 0x3d898
            int32_t v81; // 0x3d898
            int32_t chars_printed; // 0x3e03c
            int32_t v82; // 0x3e048
            int32_t v83; // 0x3e04c
            int32_t v84; // 0x3e05c
            char * str7; // 0x3e070
            int32_t str9; // 0x3d898
            int32_t v85; // 0x3df8c
            int32_t str10; // 0x3d898
            int32_t v86; // 0x3e0a4
            if (v74 != (int32_t)&g279) {
                // 0x3e024
                if (*(int32_t *)(v73 + 4) == 8) {
                    // 0x3e0e0
                    v75 = sprintf((char *)str6, "%s:\n", (char *)v74) + str6;
                } else {
                    // 0x3e030
                    chars_printed = sprintf((char *)str6, "%s", (char *)*(int32_t *)v73);
                    v82 = chars_printed + str6;
                    v83 = g277 + v72;
                    v77 = g277;
                    str8 = v82;
                    v79 = chars_printed;
                    if (*(int32_t *)(v83 + 4) == 2) {
                        // 0x3e05c
                        v84 = *(int32_t *)v83;
                        str7 = (char *)v84;
                        v77 = v84;
                        str8 = v82;
                        v79 = chars_printed;
                        if (strchr(str7, 32) == NULL) {
                            // 0x3e084
                            v77 = v84;
                            str8 = v82;
                            v79 = chars_printed;
                            if (strchr(str7, 61) == NULL) {
                                // 0x3e0a0
                                v86 = chars_printed + 6;
                                *(int32_t *)v82 = 0x72613c20;
                                *(int16_t *)(v82 + 4) = 0x3e67;
                                *(char *)(v82 + 6) = 0;
                                v77 = 0;
                                str8 = v86 + str6;
                                v79 = v86;
                            }
                        }
                    }
                    // 0x3df58
                    v80 = v79;
                    v81 = v80 == 19 | v80 < 19 ? 20 - v80 : v77;
                    v76 = v80 >= 19 == (v80 != 19) ? 1 : v81;
                    str9 = sprintf((char *)str8, "%.*s", v76, "                    ") + v80 + str6;
                    v85 = *(int32_t *)(v72 + 24 + g277);
                    str10 = str9 + sprintf((char *)str9, "%s", (char *)v85);
                    v78 = str10;
                    if (*(int32_t *)(v72 + 16 + g277) != 0) {
                        // 0x3dfb0
                        v78 = sprintf((char *)str10, " (default: %s)", &v59) + str10;
                    }
                    // 0x3dfec
                    *(int16_t *)v78 = 10;
                    v75 = v78 + 1;
                }
            }
            uint32_t v87 = g275; // 0x3dffc
            int32_t v88 = 1; // 0x3e000
            int32_t v89 = v72 + 28; // 0x3e00c
            int32_t v90 = v88; // 0x3e00c
            v71 = v75;
            while (v87 != v88 && v87 >= v88) {
                // 0x3e010
                v72 = v89;
                str6 = v75;
                v73 = g277 + v72;
                v74 = *(int32_t *)(v73 + 24);
                v75 = str6;
                if (v74 != (int32_t)&g279) {
                    // 0x3e024
                    if (*(int32_t *)(v73 + 4) == 8) {
                        // 0x3e0e0
                        v75 = sprintf((char *)str6, "%s:\n", (char *)v74) + str6;
                    } else {
                        // 0x3e030
                        chars_printed = sprintf((char *)str6, "%s", (char *)*(int32_t *)v73);
                        v82 = chars_printed + str6;
                        v83 = g277 + v72;
                        v77 = g277;
                        str8 = v82;
                        v79 = chars_printed;
                        if (*(int32_t *)(v83 + 4) == 2) {
                            // 0x3e05c
                            v84 = *(int32_t *)v83;
                            str7 = (char *)v84;
                            v77 = v84;
                            str8 = v82;
                            v79 = chars_printed;
                            if (strchr(str7, 32) == NULL) {
                                // 0x3e084
                                v77 = v84;
                                str8 = v82;
                                v79 = chars_printed;
                                if (strchr(str7, 61) == NULL) {
                                    // 0x3e0a0
                                    v86 = chars_printed + 6;
                                    *(int32_t *)v82 = 0x72613c20;
                                    *(int16_t *)(v82 + 4) = 0x3e67;
                                    *(char *)(v82 + 6) = 0;
                                    v77 = 0;
                                    str8 = v86 + str6;
                                    v79 = v86;
                                }
                            }
                        }
                        // 0x3df58
                        v80 = v79;
                        v81 = v80 == 19 | v80 < 19 ? 20 - v80 : v77;
                        v76 = v80 >= 19 == (v80 != 19) ? 1 : v81;
                        str9 = sprintf((char *)str8, "%.*s", v76, "                    ") + v80 + str6;
                        v85 = *(int32_t *)(v72 + 24 + g277);
                        str10 = str9 + sprintf((char *)str9, "%s", (char *)v85);
                        v78 = str10;
                        if (*(int32_t *)(v72 + 16 + g277) != 0) {
                            // 0x3dfb0
                            v78 = sprintf((char *)str10, " (default: %s)", &v59) + str10;
                        }
                        // 0x3dfec
                        *(int16_t *)v78 = 10;
                        v75 = v78 + 1;
                    }
                }
                // 0x3dffc
                v87 = g275;
                v88 = v90 + 1;
                v89 = v72 + 28;
                v90 = v88;
                v71 = v75;
            }
        }
        // 0x3e0cc
        *(char *)v71 = 0;
        // 0x3d8e4
        return result;
    }
    int32_t v91 = function_3d4a4(&v20, &v19); // 0x3da58
    str = v10;
    int32_t v92; // 0x3d898
    int32_t v93; // 0x3d898
    int32_t v94; // 0x3d898
    int32_t v95; // 0x3d898
    int32_t v96; // 0x3d898
    int32_t v97; // 0x3d898
    if (v91 == 0) {
        goto lab_0x3db10;
    } else {
        int32_t * v41 = (int32_t *)v10;
        str2 = v91;
        int32_t v40; // 0x3da74
        int32_t n; // 0x3da7c
        int32_t v42; // 0x3da94
        while (true) {
          lab_0x3da74:
            // 0x3da74
            v40 = *v41;
            n = v19;
            if (strncmp((char *)(v40 + 2), (char *)str2, n) == 0) {
                // 0x3da94
                v42 = n + 2;
                switch (*(char *)(v42 + v40)) {
                    case 61: {
                        goto lab_0x3dc68;
                    }
                    case 0: {
                        int32_t v43 = 28 * v20; // 0x3dad8
                        v19 = v42;
                        int32_t v44 = *(int32_t *)((int32_t)&g171 | 0x424c) + v43; // 0x3dae0
                        v23 = v44;
                        v24 = v8;
                        v25 = v10;
                        v26 = v41;
                        v27 = v20;
                        v36 = v10;
                        v34 = v8;
                        v32 = (int32_t)&g171 | 0x424c;
                        v30 = v43;
                        v29 = (int32_t)&g171 | 0x424c;
                        if (*(int32_t *)(v44 + 4) == 1) {
                            goto lab_0x3db48;
                        } else {
                            goto lab_0x3dbb4;
                        }
                    }
                    default: {
                        goto lab_0x3daf8;
                    }
                }
            } else {
                goto lab_0x3daf8;
            }
        }
      lab_0x3dc68:;
        int32_t v98 = 28 * v20; // 0x3dc98
        int32_t v99 = v40 + 3 + n; // 0x3dc9c
        v19 = v42;
        int32_t v100 = *(int32_t *)((int32_t)&g171 | 0x424c) + v98; // 0x3dcac
        if (*(int32_t *)(v100 + 4) == 1) {
            // 0x3dcf4
            v23 = v100;
            v24 = v8;
            v25 = v10;
            if (v99 != 0) {
                // 0x3d8e4
                return -1;
            }
            goto lab_0x3db48;
        } else {
            // 0x3dcbc
            v93 = v98;
            v94 = (int32_t)&g171 | 0x424c;
            v95 = v8;
            v96 = v10;
            v97 = v99;
            v92 = v20;
            v26 = v41;
            v27 = v20;
            v36 = v10;
            v34 = v8;
            v32 = (int32_t)&g171 | 0x424c;
            v30 = v98;
            v29 = (int32_t)&g171 | 0x424c;
            if (v99 == 0) {
                goto lab_0x3dbb4;
            } else {
                goto lab_0x3d9d0;
            }
        }
    }
  lab_0x3d944:;
    int32_t v101 = function_3d554(&v20); // 0x3d950
    str = v9;
    if (v101 == 0) {
        goto lab_0x3db10;
    } else {
        // 0x3d95c
        v38 = (int32_t *)v9;
        char v102 = *(char *)v101; // 0x3d964
        v18 = v5 + 1;
        char v103 = *(char *)(*v38 + v18); // 0x3d96c
        char v104 = v102; // 0x3d978
        if (v102 == v103) {
            goto lab_0x3d97c;
        } else {
            int32_t v105; // 0x3d898
            int32_t v106 = function_3d5b4(v101, v102 == v103 ? v105 : (int32_t)&v20); // 0x3dbdc
            while (v106 != 0) {
                char v107 = *(char *)(*v38 + (int32_t)v104 + 1); // 0x3dbf8
                v104 = v107;
                if (v107 == *(char *)v106) {
                    goto lab_0x3d97c;
                }
                v106 = function_3d5b4(v106, v102 == v103 ? v105 : (int32_t)&v20);
            }
            goto lab_0x3db10;
        }
    }
  lab_0x3db48:;
    int32_t v108 = v23 + 8; // 0x3db58
    int32_t v109 = v24; // 0x3db58
    int32_t v110 = v25; // 0x3db58
    int32_t v111 = 0; // 0x3db58
    int32_t v112 = *(int32_t *)(v23 + 20); // 0x3db58
    goto lab_0x3db5c;
  lab_0x3dbb4:;
    int32_t v115 = v29 + 1 + *v26; // 0x3dbbc
    v28 = v27;
    v37 = v36;
    v35 = v34;
    v33 = v32;
    v31 = v30;
    if (*(char *)v115 == 0) {
        goto lab_0x3d9c0;
    } else {
        *a3 = 0;
        v93 = v30;
        v94 = v32;
        v95 = v34;
        v96 = v36;
        v97 = v115;
        v92 = v27;
        goto lab_0x3d9d0;
    }
  lab_0x3d9d0:;
    int32_t * v116 = (int32_t *)v94; // 0x3d9d0
    int32_t v117 = *v116; // 0x3d9d0
    int32_t v118 = v117 + v93; // 0x3d9d4
    int32_t v119 = v117; // 0x3d9e0
    int32_t v120 = v92; // 0x3d9e0
    if (*(int32_t *)(v118 + 4) == 4) {
        // 0x3dc48
        function_3cdac(v97, (int32_t *)*(int32_t *)(v118 + 20));
        v119 = *v116;
        v120 = v20;
    }
    // 0x3d9e4
    v108 = v119 + 12 + 28 * v120;
    v109 = v95;
    v110 = v96;
    v111 = v97;
    v112 = v97;
    goto lab_0x3db5c;
  lab_0x3db5c:
    // 0x3db5c
    if (v112 != 0) {
        // 0x3dc1c
        free((int32_t *)v112);
        // 0x3d8e4
        return -1;
    }
    int32_t v113 = *(int32_t *)v108;
    if (v113 != 0) {
        // 0x3db70
        if (*(char *)(v113 + 1 + *(int32_t *)v110) != 0) {
            // 0x3d8e4
            return 1;
        }
        // 0x3db84
        *a3 = 0;
    }
    // 0x3db88
    function_3d860(a1, a2, v109);
    if (v111 == 0) {
        // 0x3d8e4
        return 1;
    }
    // 0x3dba0
    if (*(int32_t *)v110 == v111) {
        // 0x3dc08
        function_3d860(a1, a2, v109);
    }
    // 0x3d8e4
    return 1;
  lab_0x3d9c0:;
    int32_t v114 = *(int32_t *)(4 * v35 + v2); // 0x3d9c4
    v93 = v31;
    v94 = v33;
    v95 = v35;
    v96 = v37;
    v97 = v114;
    v92 = v28;
    if (v114 == 0) {
        // 0x3d8e4
        return -1;
    }
    goto lab_0x3d9d0;
}

// Address range: 0x3e18c - 0x3e2a0
int32_t function_3e18c(int32_t result3, char a2, int32_t a3) {
    // 0x3e18c
    if (a3 == 0) {
        // 0x3e1dc
        return 0;
    }
    int32_t result = result3; // 0x3e1a0
    int32_t v1 = a3; // 0x3e1a0
    int32_t result2; // 0x3e18c
    if (result3 % 4 == 0) {
      lab_0x3e260:
        // 0x3e260
        if (*(char *)result == a2) {
            // 0x3e1dc
            return result;
        }
        int32_t v2 = result; // 0x3e274
        v2++;
        result2 = 0;
        while (v2 != v1 + result) {
            // 0x3e278
            result2 = v2;
            if (*(char *)v2 == a2) {
                // break -> 0x3e1dc
                break;
            }
            v2++;
            result2 = 0;
        }
        // 0x3e1dc
        return result2;
    }
    int32_t v3 = a3; // 0x3e1ac
    if ((char)result3 == a2) {
        // 0x3e1dc
        return result3;
    }
    int32_t v4 = result3; // 0x3e1ac
    result2 = 0;
    while (v3 != 1) {
        // 0x3e1b8
        v4++;
        v3--;
        result = v4;
        v1 = v3;
        if (v4 % 4 == 0) {
            goto lab_0x3e260;
        }
        // 0x3e1c4
        result2 = v4;
        if (*(char *)v4 == a2) {
            // break -> 0x3e1dc
            break;
        }
        result2 = 0;
    }
    // 0x3e1dc
    return result2;
}

// Address range: 0x3e2a0 - 0x3e3b0
int32_t function_3e2a0(int32_t a1, uint32_t a2, int32_t * a3) {
    int32_t v1 = 1; // 0x3e2c0
    int32_t v2 = 0; // 0x3e2c0
    int32_t v3 = -1; // 0x3e2c0
    int32_t v4 = -1; // 0x3e2c0
    int32_t v5 = 1; // 0x3e2c0
    if (a2 > 1) {
        int32_t v6; // 0x3e2a0
        int32_t v7; // 0x3e2a0
        while (true) {
            // 0x3e2c4
            v6 = v3;
            int32_t v8 = v6 + a1;
            char * v9 = (char *)(v8 + 1);
            int32_t v10 = 1;
            unsigned char v11 = *(char *)(v10 + v8); // 0x3e2c4
            unsigned char v12 = *(char *)(v1 + a1); // 0x3e2c8
            int32_t v13 = v1; // 0x3e2d0
            int32_t v14 = v1; // 0x3e2d0
            int32_t v15 = v2; // 0x3e2d0
            int32_t v16 = 1; // 0x3e2d0
            int32_t v17 = v10; // 0x3e2d0
            char v18 = v11; // 0x3e2d0
            char v19 = v12; // 0x3e2d0
            unsigned char v20; // 0x3e2c4
            unsigned char v21; // 0x3e2c8
            int32_t v22; // 0x3e2e0
            if (v12 < v11) {
                v7 = v13;
                v22 = v7 + 1;
                if (v22 >= a2) {
                    // break (via goto) -> 0x3e2f0
                    goto lab_0x3e2f0;
                }
                // 0x3e2c4
                v20 = *v9;
                v21 = *(char *)(v22 + a1);
                while (v21 < v20) {
                    // 0x3e2d4
                    v7 = v22;
                    v22 = v7 + 1;
                    if (v22 >= a2) {
                        // break (via goto) -> 0x3e2f0
                        goto lab_0x3e2f0;
                    }
                    // 0x3e2c4
                    v20 = *v9;
                    v21 = *(char *)(v22 + a1);
                }
                // 0x3e358
                v14 = v22;
                v15 = v7;
                v16 = v7 - v6;
                v17 = 1;
                v18 = v20;
                v19 = v21;
            }
            // 0x3e358
            v3 = v15;
            while (v19 == v18) {
                int32_t v23 = v17;
                int32_t v24 = v23 == v16 ? v14 : v3;
                v10 = v23 == v16 ? 1 : v23 + 1;
                int32_t v25 = v10 + v24; // 0x3e2b4
                v4 = v6;
                v5 = v16;
                if (v25 >= a2) {
                    goto lab_0x3e2f0_3;
                }
                v11 = *(char *)(v10 + v8);
                v12 = *(char *)(v25 + a1);
                v13 = v25;
                v14 = v25;
                v15 = v24;
                v17 = v10;
                v18 = v11;
                v19 = v12;
                if (v12 < v11) {
                    v7 = v13;
                    v22 = v7 + 1;
                    if (v22 >= a2) {
                        // break (via goto) -> 0x3e2f0
                        goto lab_0x3e2f0;
                    }
                    // 0x3e2c4
                    v20 = *v9;
                    v21 = *(char *)(v22 + a1);
                    while (v21 < v20) {
                        // 0x3e2d4
                        v7 = v22;
                        v22 = v7 + 1;
                        if (v22 >= a2) {
                            // break (via goto) -> 0x3e2f0
                            goto lab_0x3e2f0;
                        }
                        // 0x3e2c4
                        v20 = *v9;
                        v21 = *(char *)(v22 + a1);
                    }
                    // 0x3e358
                    v14 = v22;
                    v15 = v7;
                    v16 = v7 - v6;
                    v17 = 1;
                    v18 = v20;
                    v19 = v21;
                }
                // 0x3e358
                v3 = v15;
            }
            // 0x3e35c
            v1 = v3 + 2;
            v2 = v3 + 1;
            v4 = v3;
            v5 = 1;
            if (v1 >= a2) {
                goto lab_0x3e2f0_3;
            }
        }
      lab_0x3e2f0:
        // 0x3e2f0
        v4 = v6;
        v5 = v7 - v6;
    }
  lab_0x3e2f0_3:
    // 0x3e2f0
    *a3 = v5;
    int32_t v26 = 1; // 0x3e310
    int32_t v27 = -1; // 0x3e310
    int32_t v28 = 0; // 0x3e310
    int32_t v29 = -1; // 0x3e310
    int32_t v30 = 1; // 0x3e310
    if (a2 != 1 && a2 != 0) {
        int32_t v31; // 0x3e2a0
        int32_t v32; // 0x3e2a0
        while (true) {
            // 0x3e314
            v32 = v27;
            int32_t v33 = v32 + a1;
            char * v34 = (char *)(v33 + 1);
            int32_t v35 = v26; // 0x3e304
            int32_t v36 = 1;
            int32_t v37 = 1; // 0x3e2a0
            int32_t v38 = v28; // 0x3e2a0
            int32_t v39; // 0x3e2a0
            while (true) {
                int32_t v40 = v36;
                int32_t v41 = v35;
                unsigned char v42 = *(char *)(v40 + v33); // 0x3e314
                unsigned char v43 = *(char *)(v41 + a1); // 0x3e318
                int32_t v44 = v41; // 0x3e320
                int32_t v45; // 0x3e2a0
                int32_t v46; // 0x3e2a0
                int32_t v47; // 0x3e2a0
                int32_t v48; // 0x3e2a0
                if (v43 == v42 || v43 < v42) {
                    // 0x3e370
                    v39 = v38;
                    v45 = v40;
                    v48 = v37;
                    v47 = v38;
                    v46 = v41;
                    if (v43 != v42) {
                        // break -> 0x3e374
                        break;
                    }
                } else {
                    v31 = v44;
                    int32_t v49 = v31 + 1; // 0x3e330
                    if (v49 <= a2 != v49 != a2) {
                        // break (via goto) -> 0x3e340
                        goto lab_0x3e340;
                    }
                    unsigned char v50 = *v34; // 0x3e314
                    unsigned char v51 = *(char *)(v49 + a1); // 0x3e318
                    while (v51 != v50 && v51 >= v50) {
                        // 0x3e324
                        v31 = v49;
                        v49 = v31 + 1;
                        if (v49 <= a2 != v49 != a2) {
                            // break (via goto) -> 0x3e340
                            goto lab_0x3e340;
                        }
                        // 0x3e314
                        v50 = *v34;
                        v51 = *(char *)(v49 + a1);
                    }
                    // 0x3e370
                    v39 = v31;
                    v45 = 1;
                    v48 = v31 - v32;
                    v47 = v31;
                    v46 = v49;
                    if (v51 != v50) {
                        // break -> 0x3e374
                        break;
                    }
                }
                int32_t v52 = v45;
                int32_t v53 = v52 == v48 ? v46 : v47;
                v36 = v52 == v48 ? 1 : v52 + 1;
                v35 = v36 + v53;
                v37 = v48;
                v38 = v53;
                v29 = v32;
                v30 = v48;
                if (v35 == a2 || v35 > a2) {
                    goto lab_0x3e340_3;
                }
            }
            int32_t v54 = v39 + 2; // 0x3e304
            v26 = v54;
            v27 = v39;
            v28 = v39 + 1;
            v29 = v39;
            v30 = 1;
            if (v54 == a2 || v54 > a2) {
                goto lab_0x3e340_3;
            }
        }
      lab_0x3e340:
        // 0x3e340
        v29 = v32;
        v30 = v31 - v32;
    }
  lab_0x3e340_3:;
    uint32_t v55 = v4 + 1; // 0x3e340
    uint32_t v56 = v29 + 1; // 0x3e344
    if (v56 >= v55) {
        *a3 = v30;
    }
    return v56 >= v55 ? v56 : v55;
}

// Address range: 0x3e3b0 - 0x3e6dc
int32_t function_3e3b0(int32_t a1, int32_t a2, int32_t str, uint32_t a4) {
    uint32_t v1 = a4 - 1; // 0x3e3d0
    int32_t v2; // 0x3e3b0
    int32_t v3; // bp-1068, 0x3e3b0
    int32_t v4; // 0x3e3b0
    if (a4 >= 2 == (a4 != 2)) {
        int32_t v5 = function_3e2a0(str, a4, &v3); // 0x3e6b8
        v4 = v3;
        v2 = v5;
    } else {
        // 0x3e3d8
        v3 = 1;
        v4 = 1;
        v2 = v1;
    }
    int32_t n = v2;
    int32_t v6 = &v3; // 0x3e3f4
    v6 += 4;
    *(int32_t *)v6 = a4;
    int32_t v7; // bp-44, 0x3e3b0
    while (v6 != (int32_t)&v7) {
        // 0x3e3f8
        v6 += 4;
        *(int32_t *)v6 = a4;
    }
    int32_t v8; // bp-40, 0x3e3b0
    if (a4 != 0) {
        int32_t v9 = (int32_t)&v8 - 1024; // 0x3e41c
        int32_t v10 = str - 1; // 0x3e410
        int32_t v11 = v1;
        v10++;
        *(int32_t *)(v9 + 4 * (int32_t)*(char *)v10) = v11;
        int32_t v12 = v11 - 1; // 0x3e428
        while (v11 != 0) {
            // 0x3e414
            v11 = v12;
            v10++;
            *(int32_t *)(v9 + 4 * (int32_t)*(char *)v10) = v11;
            v12 = v11 - 1;
        }
    }
    // 0x3e42c
    int32_t v13; // 0x3e3b0
    uint32_t v14; // 0x3e3b0
    int32_t v15; // 0x3e3b0
    int32_t v16; // 0x3e3b0
    int32_t v17; // 0x3e3b0
    int32_t v18; // 0x3e3b0
    int32_t v19; // 0x3e3b0
    int32_t v20; // 0x3e3b0
    int32_t v21; // 0x3e454
    int32_t v22; // 0x3e45c
    uint32_t v23; // 0x3e5a8
    int32_t v24; // 0x3e5ac
    uint32_t v25; // 0x3e5b4
    int32_t v26; // 0x3e5c8
    int32_t v27; // 0x3e3b0
    int32_t v28; // 0x3e3b0
    int32_t v29; // 0x3e448
    uint32_t v30; // 0x3e44c
    if (memcmp((int32_t *)str, (int32_t *)(v4 + str), n) == 0) {
        // 0x3e448
        v29 = n - 1;
        v30 = a2 - a4;
        v21 = v29 + str;
        v22 = a4 - v4;
        int32_t v31 = 1 - n; // 0x3e464
        int32_t v32 = (int32_t)&v8 - 1024; // 0x3e4a8
        v13 = 0;
        v15 = 0;
        while (true) {
          lab_0x3e49c_2:
            // 0x3e49c
            v16 = v15;
            v14 = v13;
            v27 = v16 + a1;
            uint32_t v33 = *(int32_t *)(v32 + 4 * (int32_t)*(char *)(v27 + v1)); // 0x3e4ac
            if (v33 == 0) {
                int32_t v34 = n >= v14 ? n : v14;
                if (v34 < v1) {
                    int32_t v35 = v34 + str; // 0x3e4d0
                    int32_t v36 = v34 + v27; // 0x3e4d4
                    int32_t v37 = v35; // 0x3e4e4
                    int32_t v38 = v34; // 0x3e4e4
                    int32_t v39 = v36; // 0x3e4e4
                    int32_t v40 = v34; // 0x3e4e4
                    if (*(char *)v36 == *(char *)v35) {
                        int32_t v41 = v38 + 1; // 0x3e4fc
                        while (v41 < v1) {
                            int32_t v42 = v37 + 1; // 0x3e4ec
                            int32_t v43 = v39 + 1; // 0x3e4f0
                            v37 = v42;
                            v38 = v41;
                            v39 = v43;
                            v40 = v41;
                            if (*(char *)v42 != *(char *)v43) {
                                // 0x3e594
                                v20 = v31 + v16 + v40;
                                goto lab_0x3e490;
                            }
                            v41 = v38 + 1;
                        }
                        goto lab_0x3e508;
                    } else {
                        // 0x3e594
                        v20 = v31 + v16 + v40;
                        goto lab_0x3e490;
                    }
                } else {
                    goto lab_0x3e508;
                }
            } else {
                int32_t v44 = v14 == 0 | v33 >= v4 ? v33 : v22;
                v20 = v44 + v16;
                goto lab_0x3e490;
            }
        }
    } else {
        // 0x3e5a8
        v23 = a4 - n;
        v24 = n - 1;
        v25 = a2 - a4;
        int32_t v45 = n + str; // 0x3e5c4
        v26 = v24 + str;
        int32_t v46 = 1 - n; // 0x3e5d0
        int32_t v47 = (int32_t)&v8 - 1024; // 0x3e5e8
        v17 = 0;
        while (true) {
          lab_0x3e5dc:
            // 0x3e5dc
            v18 = v17;
            v28 = v18 + a1;
            int32_t v48 = *(int32_t *)(v47 + 4 * (int32_t)*(char *)(v28 + v1)); // 0x3e5ec
            int32_t v49 = v48; // 0x3e5f4
            if (v48 == 0) {
                if (n < v1) {
                    int32_t v50 = v28 + n; // 0x3e608
                    int32_t v51 = v50; // 0x3e618
                    int32_t v52 = v45; // 0x3e618
                    if (*(char *)v50 == *(char *)v45) {
                        int32_t v53 = n + 1; // 0x3e638
                        while (v53 < v1) {
                            int32_t v54 = v52 + 1; // 0x3e628
                            int32_t v55 = v51 + 1; // 0x3e62c
                            v51 = v55;
                            int32_t v56 = v53; // 0x3e634
                            v52 = v54;
                            int32_t v57 = v53; // 0x3e634
                            if (*(char *)v54 != *(char *)v55) {
                                // 0x3e698
                                v19 = v46 + v18 + v57;
                                goto lab_0x3e68c;
                            }
                            v53 = v56 + 1;
                        }
                        goto lab_0x3e644;
                    } else {
                        // 0x3e698
                        v19 = v46 + v18 + n;
                        goto lab_0x3e68c;
                    }
                } else {
                    goto lab_0x3e644;
                }
            } else {
                // 0x3e688
                v19 = v49 + v18;
                goto lab_0x3e68c;
            }
        }
    }
  lab_0x3e588_6:;
    // 0x3e588
    int32_t result; // 0x3e3b0
    return result;
  lab_0x3e508:;
    int32_t v58 = n; // 0x3e514
    if (n != v14 && n >= v14) {
        int32_t v59 = v27 + v29; // 0x3e520
        int32_t v60 = v59; // 0x3e530
        int32_t v61 = v21; // 0x3e530
        v58 = n;
        if (*(char *)v21 == *(char *)v59) {
            int32_t v62 = v29;
            v58 = v14;
            while (v62 != v14) {
                int32_t v63 = v61 - 1; // 0x3e540
                int32_t v64 = v60 - 1; // 0x3e544
                int32_t v65 = v62 - 1; // 0x3e54c
                v60 = v64;
                v61 = v63;
                v58 = v62;
                if (*(char *)v63 != *(char *)v64) {
                    // break -> 0x3e560
                    break;
                }
                v62 = v65;
                v58 = v14;
            }
        }
    }
    uint32_t v66 = v58;
    uint32_t v67 = v14 + 1; // 0x3e560
    result = v27;
    if (v67 >= v66 == (v67 != v66)) {
        // break -> 0x3e588
        goto lab_0x3e588_6;
    }
    int32_t v68 = v16 + v4; // 0x3e574
    int32_t v69 = v22; // 0x3e580
    int32_t v70 = v68; // 0x3e580
    result = 0;
    if (v30 < v68) {
        // break -> 0x3e588
        goto lab_0x3e588_6;
    }
    goto lab_0x3e49c;
  lab_0x3e490:
    // 0x3e490
    v69 = 0;
    v70 = v20;
    if (v30 < v20) {
        // break -> 0x3e588
        goto lab_0x3e588_6;
    }
    goto lab_0x3e49c;
  lab_0x3e49c:
    // 0x3e49c
    v13 = v69;
    v15 = v70;
    goto lab_0x3e49c_2;
  lab_0x3e644:
    // 0x3e644
    result = v28;
    if (n == 0) {
        // break -> 0x3e588
        goto lab_0x3e588_6;
    }
    int32_t v71 = v28 + v24; // 0x3e654
    int32_t v72 = v71; // 0x3e664
    if (*(char *)v71 == *(char *)v26) {
        result = v28;
        if (v26 == str) {
            // break (via goto) -> 0x3e588
            goto lab_0x3e588_6;
        }
        int32_t v73 = v26 - 1; // 0x3e674
        int32_t v74 = v72 - 1; // 0x3e678
        int32_t v75 = v73; // 0x3e680
        v72 = v74;
        while (*(char *)v73 == *(char *)v74) {
            // 0x3e66c
            result = v28;
            if (v75 == str) {
                // break (via goto) -> 0x3e588
                goto lab_0x3e588_6;
            }
            // 0x3e674
            v73 = v75 - 1;
            v74 = v72 - 1;
            v75 = v73;
            v72 = v74;
        }
    }
    // 0x3e688
    v19 = (v23 < n ? n : v23) + 1 + v18;
    goto lab_0x3e68c;
  lab_0x3e68c:;
    int32_t v76 = v19;
    v17 = v76;
    if (v76 != v25 && v76 >= v25) {
        // break -> 0x3e588
        goto lab_0x3e588_6;
    }
    goto lab_0x3e5dc;
}

// Address range: 0x3e6dc - 0x3e9c4
int32_t memmem(int32_t result, uint32_t a2, int32_t str, uint32_t a4) {
    // 0x3e6dc
    if (a4 == 0) {
        // 0x3e870
        return result;
    }
    // 0x3e6f4
    if (a4 >= a2 == (a4 != a2)) {
        // 0x3e870
        return 0;
    }
    if (a4 >= 31 == (a4 != 31)) {
        // 0x3e890
        return function_3e3b0(result, a2, str, a4);
    }
    int32_t result2 = function_3e18c(result, (char)str, a2); // 0x3e714
    if (result2 == 0) {
        // 0x3e870
        return result2;
    }
    uint32_t v1 = result - result2 + a2; // 0x3e73c
    if (v1 <= a4 == (v1 != a4)) {
        // 0x3e870
        return 0;
    }
    int32_t v2; // 0x3e6dc
    char * v3; // bp-44, 0x3e6dc
    char * v4; // 0x3e6dc
    if (a4 >= 2 == (a4 != 2)) {
        int32_t v5 = function_3e2a0(str, a4, (int32_t *)&v3); // 0x3e9a0
        v4 = v3;
        v2 = v5;
    } else {
        // 0x3e750
        v3 = (char *)1;
        v4 = (char *)1;
        v2 = a4 - 1;
    }
    int32_t n = v2;
    int32_t v6 = (int32_t)v4; // 0x3e760
    int32_t v7; // 0x3e6dc
    uint32_t v8; // 0x3e6dc
    int32_t v9; // 0x3e6dc
    int32_t v10; // 0x3e6dc
    int32_t v11; // 0x3e6dc
    int32_t v12; // 0x3e788
    int32_t v13; // 0x3e77c
    if (memcmp((int32_t *)str, (int32_t *)(v6 + str), n) == 0) {
        // 0x3e77c
        v13 = n - 1;
        v12 = v13 + str;
        v9 = 0;
        v7 = 0;
        while (true) {
          lab_0x3e7a4:
            // 0x3e7a4
            v8 = v7;
            v10 = v9;
            v11 = n >= v8 ? n : v8;
            if (v11 == a4 || v11 > a4) {
                goto lab_0x3e7f4;
            } else {
                // 0x3e7b8
                if (*(char *)(v11 + str) == *(char *)(v10 + result2 + v11)) {
                    int32_t v14; // 0x3e6dc
                    while (v14 + 1 != a4) {
                        // 0x3e7d8
                        int32_t v15; // 0x3e6dc
                        int32_t v16 = v15;
                        int32_t v17; // 0x3e6dc
                        int32_t v18 = v17;
                        int32_t v19 = v18 + 1; // 0x3e7d8
                        char v20 = *(char *)v19; // 0x3e7d8
                        int32_t v21 = v16 + 1; // 0x3e7dc
                        char v22 = *(char *)v21; // 0x3e7dc
                        v17 = v19;
                        v15 = v21;
                        int32_t v23; // 0x3e7e8
                        v14 = v23;
                        if (v20 != v22) {
                            goto lab_0x3e87c;
                        }
                        int32_t v24 = v14;
                        v23 = v24 + 1;
                    }
                    goto lab_0x3e7f4;
                } else {
                    goto lab_0x3e87c;
                }
            }
        }
      lab_0x3e9bc:
        // 0x3e870
        return v10 + result2;
    }
    uint32_t v25 = a4 - n; // 0x3e8a4
    int32_t v26 = n - 1; // 0x3e8a8
    uint32_t v27 = v1 - a4; // 0x3e8b0
    int32_t v28 = n + str; // 0x3e8bc
    int32_t v29 = 1 - n; // 0x3e8c0
    int32_t v30 = (v25 < n ? n : v25) + 1; // 0x3e8c8
    char * v31 = (char *)(v26 + str); // 0x3e8cc
    bool v32 = n == a4 | n > a4; // 0x3e8d8
    char * v33 = (char *)v28;
    int32_t v34 = 0; // 0x3e8d0
    int32_t v35; // 0x3e6dc
    int32_t v36; // 0x3e6dc
    int32_t v37; // 0x3e6dc
    while (true) {
      lab_0x3e8d4_2:
        // 0x3e8d4
        v36 = v34;
        if (v32) {
            // 0x3e8d4
            v35 = v36 + result2;
            goto lab_0x3e920;
        } else {
            int32_t v38 = v36 + result2;
            int32_t v39 = v38 + n; // 0x3e8e4
            int32_t v40 = v39; // 0x3e8f4
            int32_t v41 = v28; // 0x3e8f4
            if (*(char *)v39 == *v33) {
                int32_t v42 = n + 1; // 0x3e914
                v35 = v38;
                while (v42 != a4) {
                    int32_t v43 = v41 + 1; // 0x3e904
                    int32_t v44 = v40 + 1; // 0x3e908
                    v40 = v44;
                    v41 = v43;
                    int32_t v45 = v42; // 0x3e910
                    int32_t v46 = v42; // 0x3e910
                    if (*(char *)v43 != *(char *)v44) {
                        // 0x3e974
                        v37 = v29 + v36 + v46;
                        goto lab_0x3e97c;
                    }
                    v42 = v45 + 1;
                    v35 = v38;
                }
                goto lab_0x3e920;
            } else {
                // 0x3e974
                v37 = v29 + v36 + n;
                goto lab_0x3e97c;
            }
        }
    }
  lab_0x3e870_3:;
    // 0x3e870
    int32_t result3; // 0x3e6dc
    return result3;
  lab_0x3e87c:;
    int32_t v47 = 0; // 0x3e88c
    int32_t v48 = 1 - n + v10 + v11; // 0x3e88c
    goto lab_0x3e864;
  lab_0x3e7f4:;
    int32_t v53 = n; // 0x3e800
    if (n != v8 && n >= v8) {
        int32_t v54 = v10 + result2 + v13; // 0x3e80c
        int32_t v55 = v54; // 0x3e81c
        int32_t v56 = v12; // 0x3e81c
        v53 = n;
        if (*(char *)v12 == *(char *)v54) {
            int32_t v57 = v13;
            v53 = v8;
            while (v57 != v8) {
                int32_t v58 = v56 - 1; // 0x3e82c
                int32_t v59 = v55 - 1; // 0x3e830
                int32_t v60 = v57 - 1; // 0x3e838
                v55 = v59;
                v56 = v58;
                v53 = v57;
                if (*(char *)v58 != *(char *)v59) {
                    // break -> 0x3e84c
                    break;
                }
                v57 = v60;
                v53 = v8;
            }
        }
    }
    uint32_t v61 = v53;
    uint32_t v62 = v8 + 1; // 0x3e84c
    if (v62 >= v61 == (v62 != v61)) {
        // break -> 0x3e9bc
        goto lab_0x3e9bc;
    }
    // 0x3e858
    v47 = a4 - v6;
    v48 = v10 + v6;
    goto lab_0x3e864;
  lab_0x3e864:
    // 0x3e864
    v9 = v48;
    v7 = v47;
    if (v1 - a4 < v48) {
      lab_0x3e870_3:
        // 0x3e870
        return 0;
    }
    goto lab_0x3e7a4;
  lab_0x3e920:
    // 0x3e920
    result3 = v35;
    if (n == 0) {
        // break -> 0x3e870
        goto lab_0x3e870_3;
    }
    // 0x3e928
    if (*(char *)(v35 + v26) == *v31) {
        int32_t v49; // 0x3e6dc
        if (v49 == str) {
            // break (via goto) -> 0x3e870
            goto lab_0x3e870_3;
        }
        int32_t v50 = v49 - 1; // 0x3e94c
        int32_t v51; // 0x3e6dc
        int32_t v52 = v51 - 1; // 0x3e950
        v49 = v50;
        v51 = v52;
        while (*(char *)v50 == *(char *)v52) {
            // 0x3e95c
            if (v49 == str) {
                // break (via goto) -> 0x3e870
                goto lab_0x3e870_3;
            }
            // 0x3e94c
            v50 = v49 - 1;
            v52 = v51 - 1;
            v49 = v50;
            v51 = v52;
        }
    }
    // 0x3e988
    v37 = v30 + v36;
    goto lab_0x3e97c;
  lab_0x3e97c:
    // 0x3e97c
    v34 = v37;
    result3 = 0;
    if (v27 < v34) {
        // break -> 0x3e870
        goto lab_0x3e870_3;
    }
    goto lab_0x3e8d4_2;
}

// Address range: 0x3e9c4 - 0x3e9f0
int32_t function_3e9c4(int32_t a1) {
    int32_t v1 = a1 + 4; // 0x3e9c8
    int32_t v2; // 0x3e9c4
    int32_t result = __asm_dmb(a1, v2, v2, v1); // 0x3e9cc
    int32_t v3 = *(int32_t *)v1;
    int32_t v4 = v3 - 1; // 0x3e9d4
    while (__asm_strex(v4, v3) != 0) {
        // 0x3e9d0
        v3 = *(int32_t *)v1;
        v4 = v3 - 1;
    }
    if (v4 == 0) {
        // 0x3e9ec
        return function_47c24(result);
    }
    return result;
}

// Address range: 0x3e9f0 - 0x3ec74
int32_t function_3e9f0(int32_t a1, int32_t a2) {
    // 0x3e9f0
    int32_t str; // bp-2080, 0x3e9f0
    if (*(char *)&g71 != 0) {
        char v1 = *(char *)&g70; // 0x3ea2c
        if ((v1 | *(char *)&g179) == 0 != g28 < (char *)7) {
            // 0x3ea38
            snprintf((char *)&str, 2048, "got nonce sz %d", a2);
            function_1ccec(7, &str, 0);
        }
    }
    // 0x3ea60
    int32_t v2; // bp-2528, 0x3e9f0
    memcpy(&v2, (int32_t *)(a1 + 5), 448);
    int32_t size = (int32_t)*(char *)(a1 + 453); // 0x3ea7c
    int32_t v3 = a1 + 454; // 0x3ea80
    memcpy(calloc(1, size), (int32_t *)v3, size);
    int32_t v4 = v3 + size; // 0x3eaa4
    int32_t size2 = (int32_t)*(char *)v4; // 0x3eaa4
    int32_t v5 = v4 + 1; // 0x3eab0
    memcpy(calloc(1, size2), (int32_t *)v5, size2);
    int32_t v6 = v5 + size2; // 0x3ead0
    int32_t size3 = (int32_t)*(char *)v6; // 0x3ead0
    memcpy(calloc(1, size3), (int32_t *)(v6 + 1), size3);
    calloc(1, 1);
    int32_t v7 = *(int32_t *)g208; // 0x3eb3c
    int32_t v8 = 0; // 0x3eb48
    if (v7 != 0) {
        // 0x3eb4c
        if (function_2a07c(&v2, *(int32_t *)(a1 + 1), *(int32_t *)v7) != 0) {
            int32_t v9 = &v2; // 0x3eb64
            function_3a768(*(int32_t *)g208, v9);
            if (g182 == NULL || g189 == 0) {
                // 0x3eb98
                if (*(char *)&g71 == 0) {
                    // 0x3ebf8
                    function_28ea8(v9);
                    // 0x3ec04
                    return 0;
                }
            } else {
                // 0x3ec0c
                function_29144(v9);
                if (*(char *)&g71 == 0) {
                    // 0x3ebf8
                    function_28ea8(v9);
                    // 0x3ec04
                    return 0;
                }
            }
            char v10 = *(char *)&g70; // 0x3ebc0
            if ((v10 | *(char *)&g179) == 0 != g28 < (char *)7) {
                // 0x3ebcc
                snprintf((char *)&str, 2048, "%s nonce submited", "cb_bitmain_submit_nonce");
                function_1ccec(7, &str, 0);
            }
            // 0x3ebf8
            function_28ea8(v9);
            // 0x3ec04
            return 0;
        }
        // 0x3eb4c
        v8 = *(int32_t *)g208;
    }
    // 0x3ec58
    function_2f62c(v8);
    function_28ea8((int32_t)&v2);
    // 0x3ec04
    return -1;
}

// Address range: 0x3ec74 - 0x3ece4
int32_t function_3ec74(int32_t a1) {
    // 0x3ec74
    if (pthread_mutex_unlock(&g280) == 0) {
        // 0x3ec94
        return 0;
    }
    int32_t v1 = *__errno_location(); // 0x3ecb0
    int32_t str; // bp-2056, 0x3ec74
    snprintf((char *)&str, 2048, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", v1, "socketa_api.c", "cb_bitmain_api_stats", a1);
    function_1ccec(3, &str, 1);
    function_3aadc(1);
    // UNREACHABLE
}

// Address range: 0x3ece4 - 0x3ecec
int32_t function_3ece4(int32_t a1) {
    // 0x3ece4
    int32_t result; // 0x3ece4
    return result;
}

// Address range: 0x3ecf0 - 0x40c38
int32_t function_3ecf0(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11, int32_t a12, int32_t a13, int32_t a14) {
    // 0x3ecf0
    int32_t str; // bp-2088, 0x3ecf0
    if (*(char *)&g71 != 0) {
        char v1 = *(char *)&g70; // 0x3ed30
        if ((v1 | *(char *)&g179) == 0 != g28 < (char *)7) {
            // 0x3ed3c
            snprintf((char *)&str, 2048, "%s(%d) : %s", "cb_bitmain_api_stats", a2, (char *)a1);
            function_1ccec(7, &str, 0);
        }
    }
    // 0x3ed6c
    int32_t v2; // bp-2340, 0x3ecf0
    int32_t result = function_46448((int32_t *)a1, 0, &v2); // 0x3ed78
    int32_t v3; // 0x3ecf0
    int32_t v4; // 0x3ecf0
    if (result == 0) {
        goto lab_0x3ed90;
    } else {
        // 0x3ed84
        if (*(int32_t *)result == 0) {
            // 0x3ee10
            if (pthread_mutex_lock(&g280) != 0) {
                int32_t v5 = *__errno_location(); // 0x3f044
                snprintf((char *)&str, 2048, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", v5, "socketa_api.c", "cb_bitmain_api_stats", 153);
                function_1ccec(3, &str, 1);
                function_3aadc(1);
                // UNREACHABLE
            }
            // 0x3ee24
            memset(&g281, 0, 0x1a10);
            int32_t v6 = function_472ec(result, "inited"); // 0x3ee48
            if (v6 == 0) {
                goto lab_0x3ee60;
            } else {
                // 0x3ee54
                if (*(int32_t *)v6 == 3) {
                    // 0x3ef4c
                    g283 = function_47a7c(v6);
                    int32_t v7 = function_472ec(result, "chain_num"); // 0x3ef60
                    if (v7 != 0) {
                        // 0x3ef6c
                        if (*(int32_t *)v7 == 3) {
                            // 0x3f0cc
                            g282 = function_47a7c(v7);
                            int32_t v8 = function_472ec(result, "real_miner_type"); // 0x3f0e0
                            if (v8 != 0) {
                                // 0x3f0ec
                                if (*(int32_t *)v8 == 2) {
                                    int32_t v9 = function_47820(v8); // 0x3f2c0
                                    snprintf((char *)&g284, 256, "%s", (char *)v9);
                                }
                            }
                            int32_t v10 = function_472ec(result, "rate_5s"); // 0x3f104
                            if (v10 != 0) {
                                // 0x3f110
                                if (*(int32_t *)v10 == 2) {
                                    int32_t v11 = function_47820(v10); // 0x3f210
                                    snprintf((char *)&g285, 16, "%s", (char *)v11);
                                    int32_t v12 = function_472ec(result, "rate_30m"); // 0x3f238
                                    if (v12 != 0) {
                                        // 0x3f244
                                        if (*(int32_t *)v12 == 2) {
                                            int32_t v13 = function_47820(v12); // 0x3f334
                                            snprintf((char *)&g286, 16, "%s", (char *)v13);
                                            int32_t v14 = function_472ec(result, "rate_avg"); // 0x3f35c
                                            if (v14 != 0) {
                                                // 0x3f368
                                                if (*(int32_t *)v14 == 2) {
                                                    int32_t v15 = function_47820(v14); // 0x3f3e0
                                                    snprintf((char *)&g287, 16, "%s", (char *)v15);
                                                    strncpy((char *)&g158, (char *)&g287, 16);
                                                    int32_t v16 = function_472ec(result, "rate_ideal"); // 0x3f41c
                                                    if (v16 != 0) {
                                                        // 0x3f428
                                                        if (*(int32_t *)v16 == 2) {
                                                            int32_t v17 = function_47820(v16); // 0x3f4a0
                                                            snprintf((char *)&g288, 16, "%s", (char *)v17);
                                                            int32_t v18 = function_472ec(result, "rate_unit"); // 0x3f4c8
                                                            if (v18 != 0) {
                                                                // 0x3f4d4
                                                                if (*(int32_t *)v18 == 2) {
                                                                    int32_t v19 = function_47820(v18); // 0x3f54c
                                                                    snprintf((char *)&g289, 8, "%s", (char *)v19);
                                                                    int32_t v20 = function_472ec(result, "fan_num"); // 0x3f574
                                                                    if (v20 != 0) {
                                                                        // 0x3f580
                                                                        if (*(int32_t *)v20 == 3) {
                                                                            // 0x3f5f8
                                                                            g290 = function_47a7c(v20);
                                                                            int32_t v21 = function_472ec(result, "fan"); // 0x3f60c
                                                                            if (v21 != 0) {
                                                                                // 0x3f618
                                                                                if (*(int32_t *)v21 == 1) {
                                                                                    int32_t v22 = function_47658(v21); // 0x3f69c
                                                                                    int32_t v23 = 1; // 0x3f6b0
                                                                                    int32_t v24 = &g290; // 0x3f6b0
                                                                                    if (v22 != 0) {
                                                                                        int32_t v25 = function_47674(v21, 0); // 0x3f6b4
                                                                                        while (v25 != 0) {
                                                                                            // 0x3f6c0
                                                                                            if (*(int32_t *)v25 != 3) {
                                                                                                char v26 = *(char *)&g70; // 0x3f78c
                                                                                                v3 = 199;
                                                                                                if ((v26 | *(char *)&g179) == 0 == g28 < (char *)3) {
                                                                                                    goto lab_0x3f2b8;
                                                                                                } else {
                                                                                                    // 0x3f7ac
                                                                                                    snprintf((char *)&str, 2048, "%s: load json failed", "cb_bitmain_api_stats");
                                                                                                    function_1ccec(3, &str, 0);
                                                                                                    v3 = 199;
                                                                                                    goto lab_0x3f2b8;
                                                                                                }
                                                                                            }
                                                                                            int32_t v27 = v23;
                                                                                            int32_t v28 = function_47a7c(v25); // 0x3f6cc
                                                                                            int32_t v29 = v24 + 4; // 0x3f6d0
                                                                                            *(int32_t *)v29 = v28;
                                                                                            uint32_t v30 = function_47658(v21); // 0x3f69c
                                                                                            v23 = v27 + 1;
                                                                                            v24 = v29;
                                                                                            if (v30 == v27 || v30 < v27) {
                                                                                                // break -> 0x3f6d8
                                                                                                break;
                                                                                            }
                                                                                            v25 = function_47674(v21, v27);
                                                                                        }
                                                                                    }
                                                                                    int32_t v31 = function_472ec(result, "chain"); // 0x3f6e4
                                                                                    if (v31 != 0) {
                                                                                        // 0x3f6f4
                                                                                        if (*(int32_t *)v31 == 1) {
                                                                                            // 0x3f7dc
                                                                                            g239 = 0;
                                                                                            int32_t v32 = function_47658(v31); // 0x3f824
                                                                                            int32_t v33 = (int32_t)&g291; // 0x3f82c
                                                                                            if (v32 != 0) {
                                                                                                uint32_t v34 = 0;
                                                                                                int32_t v35 = function_47674(v31, v34); // 0x3f838
                                                                                                while (v34 != 4 && v35 != 0) {
                                                                                                    // 0x3f84c
                                                                                                    if (*(int32_t *)v35 != 0) {
                                                                                                        char v36 = *(char *)&g70; // 0x40be8
                                                                                                        v3 = 210;
                                                                                                        if ((v36 | *(char *)&g179) == 0 == g28 < (char *)3) {
                                                                                                            goto lab_0x3f2b8;
                                                                                                        } else {
                                                                                                            // 0x40c08
                                                                                                            snprintf((char *)&str, 2048, "%s: load json failed", "cb_bitmain_api_stats");
                                                                                                            function_1ccec(3, &str, 0);
                                                                                                            v3 = 210;
                                                                                                            goto lab_0x3f2b8;
                                                                                                        }
                                                                                                    }
                                                                                                    int32_t v37 = function_472ec(v35, "index"); // 0x3f85c
                                                                                                    if (v37 == 0) {
                                                                                                        goto lab_0x40ae8_2;
                                                                                                    }
                                                                                                    // 0x3f868
                                                                                                    if (*(int32_t *)v37 != 3) {
                                                                                                        goto lab_0x40ae8_2;
                                                                                                    }
                                                                                                    int32_t str2 = v33;
                                                                                                    *(int32_t *)(str2 - 500) = function_47a7c(v37);
                                                                                                    int32_t v38 = function_472ec(v35, "freq_avg"); // 0x3f884
                                                                                                    if (v38 == 0) {
                                                                                                        goto lab_0x40b58_2;
                                                                                                    }
                                                                                                    // 0x3f890
                                                                                                    if (*(int32_t *)v38 != 3) {
                                                                                                        goto lab_0x40b58_2;
                                                                                                    }
                                                                                                    // 0x3f89c
                                                                                                    *(int32_t *)(str2 - 496) = function_47a7c(v38);
                                                                                                    int32_t v39 = function_472ec(v35, "rate_ideal"); // 0x3f8ac
                                                                                                    if (v39 == 0) {
                                                                                                        goto lab_0x40688_2;
                                                                                                    }
                                                                                                    // 0x3f8b8
                                                                                                    if (*(int32_t *)v39 != 2) {
                                                                                                        goto lab_0x40688_2;
                                                                                                    }
                                                                                                    // 0x3f8c4
                                                                                                    snprintf((char *)(str2 - 492), 16, "%s", (char *)function_47820(v39));
                                                                                                    int32_t v40 = function_472ec(v35, "rate_real"); // 0x3f8ec
                                                                                                    if (v40 == 0) {
                                                                                                        goto lab_0x40a78_2;
                                                                                                    }
                                                                                                    // 0x3f8f8
                                                                                                    if (*(int32_t *)v40 != 2) {
                                                                                                        goto lab_0x40a78_2;
                                                                                                    }
                                                                                                    // 0x3f904
                                                                                                    snprintf((char *)(str2 - 476), 16, "%s", (char *)function_47820(v40));
                                                                                                    int32_t v41 = function_472ec(v35, "asic_num"); // 0x3f92c
                                                                                                    if (v41 == 0) {
                                                                                                        goto lab_0x40998_2;
                                                                                                    }
                                                                                                    // 0x3f938
                                                                                                    if (*(int32_t *)v41 != 3) {
                                                                                                        goto lab_0x40998_2;
                                                                                                    }
                                                                                                    // 0x3f944
                                                                                                    *(int32_t *)(str2 - 460) = function_47a7c(v41);
                                                                                                    int32_t v42 = function_472ec(v35, "asic"); // 0x3f958
                                                                                                    if (v42 == 0) {
                                                                                                        goto lab_0x40a08_2;
                                                                                                    }
                                                                                                    // 0x3f964
                                                                                                    if (*(int32_t *)v42 != 2) {
                                                                                                        goto lab_0x40a08_2;
                                                                                                    }
                                                                                                    // 0x3f970
                                                                                                    snprintf((char *)(str2 - 456), 256, "%s", (char *)function_47820(v42));
                                                                                                    int32_t v43 = function_472ec(v35, "temp_pic"); // 0x3f998
                                                                                                    if (v43 == 0) {
                                                                                                        goto lab_0x405a8_2;
                                                                                                    }
                                                                                                    // 0x3f9a4
                                                                                                    if (*(int32_t *)v43 != 1) {
                                                                                                        goto lab_0x405a8_2;
                                                                                                    }
                                                                                                    // 0x3f9b0
                                                                                                    if (function_47658(v43) != 0) {
                                                                                                        int32_t v44 = str2 - 204; // 0x3f9f8
                                                                                                        uint32_t v45 = 0;
                                                                                                        int32_t v46 = function_47674(v43, v45); // 0x3f9d0
                                                                                                        while (v45 != 4 && v46 != 0) {
                                                                                                            // 0x3f9e8
                                                                                                            if (*(int32_t *)v46 != 3) {
                                                                                                                char v47 = *(char *)&g70; // 0x3fab4
                                                                                                                v3 = 241;
                                                                                                                if ((v47 | *(char *)&g179) == 0 == g28 < (char *)3) {
                                                                                                                    goto lab_0x3f2b8;
                                                                                                                } else {
                                                                                                                    // 0x3fad4
                                                                                                                    snprintf((char *)&str, 2048, "%s: load json failed", "cb_bitmain_api_stats");
                                                                                                                    function_1ccec(3, &str, 0);
                                                                                                                    v3 = 241;
                                                                                                                    goto lab_0x3f2b8;
                                                                                                                }
                                                                                                            }
                                                                                                            int32_t v48 = v45 + 1; // 0x3f9e0
                                                                                                            int32_t v49 = function_47a7c(v46); // 0x3f9f4
                                                                                                            v44 += 4;
                                                                                                            *(int32_t *)v44 = v49;
                                                                                                            uint32_t v50 = function_47658(v43); // 0x3f9bc
                                                                                                            if (v50 == v48 || v50 <= v45) {
                                                                                                                // break -> 0x3fbdc
                                                                                                                break;
                                                                                                            }
                                                                                                            v45 = v48;
                                                                                                            v46 = function_47674(v43, v45);
                                                                                                        }
                                                                                                    }
                                                                                                    int32_t v51 = function_472ec(v35, "temp_pcb"); // 0x3fbe8
                                                                                                    if (v51 == 0) {
                                                                                                        goto lab_0x3fda8_2;
                                                                                                    }
                                                                                                    // 0x3fbf4
                                                                                                    if (*(int32_t *)v51 != 1) {
                                                                                                        goto lab_0x3fda8_2;
                                                                                                    }
                                                                                                    // 0x3fc00
                                                                                                    if (function_47658(v51) != 0) {
                                                                                                        int32_t v52 = str2 - 188; // 0x3fc48
                                                                                                        uint32_t v53 = 0;
                                                                                                        int32_t v54 = function_47674(v51, v53); // 0x3fc20
                                                                                                        while (v53 != 4 && v54 != 0) {
                                                                                                            // 0x3fc38
                                                                                                            if (*(int32_t *)v54 != 3) {
                                                                                                                char v55 = *(char *)&g70; // 0x40308
                                                                                                                v3 = 250;
                                                                                                                if ((v55 | *(char *)&g179) == 0 == g28 < (char *)3) {
                                                                                                                    goto lab_0x3f2b8;
                                                                                                                } else {
                                                                                                                    // 0x40328
                                                                                                                    snprintf((char *)&str, 2048, "%s: load json failed", "cb_bitmain_api_stats");
                                                                                                                    function_1ccec(3, &str, 0);
                                                                                                                    v3 = 250;
                                                                                                                    goto lab_0x3f2b8;
                                                                                                                }
                                                                                                            }
                                                                                                            int32_t v56 = v53 + 1; // 0x3fc30
                                                                                                            int32_t v57 = function_47a7c(v54); // 0x3fc44
                                                                                                            v52 += 4;
                                                                                                            *(int32_t *)v52 = v57;
                                                                                                            uint32_t v58 = function_47658(v51); // 0x3fc0c
                                                                                                            if (v58 == v56 || v58 <= v53) {
                                                                                                                // break -> 0x3fd34
                                                                                                                break;
                                                                                                            }
                                                                                                            v53 = v56;
                                                                                                            v54 = function_47674(v51, v53);
                                                                                                        }
                                                                                                    }
                                                                                                    int32_t v59 = function_472ec(v35, "temp_chip"); // 0x3fd40
                                                                                                    if (v59 == 0) {
                                                                                                        goto lab_0x3ff48_2;
                                                                                                    }
                                                                                                    // 0x3fd4c
                                                                                                    if (*(int32_t *)v59 != 1) {
                                                                                                        goto lab_0x3ff48_2;
                                                                                                    }
                                                                                                    // 0x3fd58
                                                                                                    if (function_47658(v59) != 0) {
                                                                                                        int32_t v60 = str2 - 172; // 0x3fda0
                                                                                                        uint32_t v61 = 0;
                                                                                                        int32_t v62 = function_47674(v59, v61); // 0x3fd78
                                                                                                        while (v61 != 4 && v62 != 0) {
                                                                                                            // 0x3fd90
                                                                                                            if (*(int32_t *)v62 != 3) {
                                                                                                                char v63 = *(char *)&g70; // 0x3fe38
                                                                                                                v3 = 259;
                                                                                                                if ((v63 | *(char *)&g179) == 0 == g28 < (char *)3) {
                                                                                                                    goto lab_0x3f2b8;
                                                                                                                } else {
                                                                                                                    // 0x3fe58
                                                                                                                    snprintf((char *)&str, 2048, "%s: load json failed", "cb_bitmain_api_stats");
                                                                                                                    function_1ccec(3, &str, 0);
                                                                                                                    v3 = 259;
                                                                                                                    goto lab_0x3f2b8;
                                                                                                                }
                                                                                                            }
                                                                                                            int32_t v64 = v61 + 1; // 0x3fd88
                                                                                                            int32_t v65 = function_47a7c(v62); // 0x3fd9c
                                                                                                            v60 += 4;
                                                                                                            *(int32_t *)v60 = v65;
                                                                                                            uint32_t v66 = function_47658(v59); // 0x3fd64
                                                                                                            if (v66 == v64 || v66 <= v61) {
                                                                                                                // break -> 0x3fe88
                                                                                                                break;
                                                                                                            }
                                                                                                            v61 = v64;
                                                                                                            v62 = function_47674(v59, v61);
                                                                                                        }
                                                                                                    }
                                                                                                    int32_t v67 = function_472ec(v35, "hw"); // 0x3fe94
                                                                                                    if (v67 == 0) {
                                                                                                        goto lab_0x40444_2;
                                                                                                    }
                                                                                                    // 0x3fea0
                                                                                                    if (*(int32_t *)v67 != 3) {
                                                                                                        goto lab_0x40444_2;
                                                                                                    }
                                                                                                    int32_t v68 = function_47a7c(v67); // 0x3feac
                                                                                                    int32_t v69 = str2 - 152; // 0x3fec0
                                                                                                    *(int32_t *)v69 = v68;
                                                                                                    g294 = 0;
                                                                                                    g239 += v68;
                                                                                                    int32_t v70 = function_472ec(v35, "rate_array"); // 0x3fee0
                                                                                                    if (v70 == 0) {
                                                                                                        goto lab_0x40278_2;
                                                                                                    }
                                                                                                    // 0x3feec
                                                                                                    if (*(int32_t *)v70 != 1) {
                                                                                                        goto lab_0x40278_2;
                                                                                                    }
                                                                                                    int32_t v71 = 1; // 0x3ff14
                                                                                                    int32_t v72 = v69; // 0x3ff14
                                                                                                    if (function_47658(v70) != 0) {
                                                                                                        int32_t v73 = function_47674(v70, 0); // 0x3ff18
                                                                                                        while (v73 != 0) {
                                                                                                            // 0x3ff24
                                                                                                            if (*(int32_t *)v73 != 3) {
                                                                                                                char v74 = *(char *)&g70; // 0x3ffd8
                                                                                                                v3 = 272;
                                                                                                                if ((v74 | *(char *)&g179) == 0 == g28 < (char *)3) {
                                                                                                                    goto lab_0x3f2b8;
                                                                                                                } else {
                                                                                                                    // 0x3fff8
                                                                                                                    snprintf((char *)&str, 2048, "%s: load json failed", "cb_bitmain_api_stats");
                                                                                                                    function_1ccec(3, &str, 0);
                                                                                                                    v3 = 272;
                                                                                                                    goto lab_0x3f2b8;
                                                                                                                }
                                                                                                            }
                                                                                                            int32_t v75 = v71;
                                                                                                            int32_t v76 = function_47a7c(v73); // 0x3ff30
                                                                                                            int32_t v77 = v72 + 4; // 0x3ff34
                                                                                                            *(int32_t *)v77 = v76;
                                                                                                            g294++;
                                                                                                            uint32_t v78 = function_47658(v70); // 0x3ff00
                                                                                                            v71 = v75 + 1;
                                                                                                            v72 = v77;
                                                                                                            int32_t v79 = v75; // 0x3ff14
                                                                                                            if (v78 == v75 || v78 < v75) {
                                                                                                                // break -> 0x40028
                                                                                                                break;
                                                                                                            }
                                                                                                            v73 = function_47674(v70, v79);
                                                                                                        }
                                                                                                    }
                                                                                                    int32_t v80 = function_472ec(v35, "nonce"); // 0x40034
                                                                                                    if (v80 == 0) {
                                                                                                        goto lab_0x40928_2;
                                                                                                    }
                                                                                                    // 0x40040
                                                                                                    if (*(int32_t *)v80 != 3) {
                                                                                                        goto lab_0x40928_2;
                                                                                                    }
                                                                                                    int32_t v81 = function_47a7c(v80); // 0x4004c
                                                                                                    *(int32_t *)(str2 - 52) = v81;
                                                                                                    g293 += v81;
                                                                                                    int32_t v82 = function_472ec(v35, "eeprom"); // 0x40070
                                                                                                    if (v82 == 0) {
                                                                                                        goto lab_0x40848_2;
                                                                                                    }
                                                                                                    int32_t v83 = *(int32_t *)v82 - 5; // 0x40080
                                                                                                    if (v83 != 0 == (v83 != 1)) {
                                                                                                        goto lab_0x40848_2;
                                                                                                    }
                                                                                                    // 0x4008c
                                                                                                    *(char *)(str2 - 48) = 0;
                                                                                                    int32_t v84 = function_472ec(v35, "sn"); // 0x400a8
                                                                                                    if (v84 == 0) {
                                                                                                        goto lab_0x408b8_2;
                                                                                                    }
                                                                                                    // 0x400b4
                                                                                                    if (*(int32_t *)v84 != 2) {
                                                                                                        goto lab_0x408b8_2;
                                                                                                    }
                                                                                                    // 0x400c0
                                                                                                    snprintf((char *)(str2 - 47), 32, "%s", (char *)function_47820(v84));
                                                                                                    int32_t v85 = function_472ec(v35, "eeprom_vol"); // 0x400e8
                                                                                                    if (v85 == 0) {
                                                                                                        goto lab_0x40618_2;
                                                                                                    }
                                                                                                    // 0x400f4
                                                                                                    if (*(int32_t *)v85 != 3) {
                                                                                                        goto lab_0x40618_2;
                                                                                                    }
                                                                                                    // 0x40100
                                                                                                    *(int32_t *)(str2 - 8) = function_47a7c(v85);
                                                                                                    int32_t v86 = function_472ec(v35, "eeprom_freq"); // 0x40114
                                                                                                    if (v86 == 0) {
                                                                                                        goto lab_0x407d8_2;
                                                                                                    }
                                                                                                    // 0x40120
                                                                                                    if (*(int32_t *)v86 != 3) {
                                                                                                        goto lab_0x407d8_2;
                                                                                                    }
                                                                                                    // 0x4012c
                                                                                                    *(int32_t *)(str2 - 12) = function_47a7c(v86);
                                                                                                    int32_t v87 = function_472ec(v35, "eeprom_bin"); // 0x40140
                                                                                                    if (v87 == 0) {
                                                                                                        goto lab_0x406f8_2;
                                                                                                    }
                                                                                                    // 0x4014c
                                                                                                    if (*(int32_t *)v87 != 3) {
                                                                                                        goto lab_0x406f8_2;
                                                                                                    }
                                                                                                    // 0x40158
                                                                                                    *(int32_t *)(str2 - 4) = function_47a7c(v87);
                                                                                                    int32_t v88 = function_472ec(v35, "eeprom_ft"); // 0x4016c
                                                                                                    if (v88 == 0) {
                                                                                                        goto lab_0x40768_2;
                                                                                                    }
                                                                                                    // 0x40178
                                                                                                    if (*(int32_t *)v88 != 2) {
                                                                                                        goto lab_0x40768_2;
                                                                                                    }
                                                                                                    // 0x40184
                                                                                                    snprintf((char *)str2, 16, "%s", (char *)function_47820(v88));
                                                                                                    int32_t v89 = function_472ec(v35, "eeprom_code"); // 0x401ac
                                                                                                    if (v89 == 0) {
                                                                                                        goto lab_0x40538_2;
                                                                                                    }
                                                                                                    // 0x401b8
                                                                                                    if (*(int32_t *)v89 != 3) {
                                                                                                        goto lab_0x40538_2;
                                                                                                    }
                                                                                                    // 0x401c4
                                                                                                    *(int32_t *)(str2 + 16) = function_47a7c(v89);
                                                                                                    int32_t v90 = function_472ec(v35, "tpl"); // 0x401d8
                                                                                                    if (v90 != 0) {
                                                                                                        // 0x401e4
                                                                                                        *(int32_t *)(str2 + 20) = function_47658(v90);
                                                                                                        if (function_47658(v90) != 0) {
                                                                                                            int32_t v91 = 388 * v34; // 0x401ec
                                                                                                            int32_t * v92 = (int32_t *)(str2 + 24);
                                                                                                            int32_t v93 = 0;
                                                                                                            int32_t v94 = function_47674(v90, v93); // 0x40210
                                                                                                            while (v94 != 0) {
                                                                                                                // 0x4021c
                                                                                                                if (*(int32_t *)v94 != 1) {
                                                                                                                    char v95 = *(char *)&g70; // 0x404d4
                                                                                                                    v3 = 317;
                                                                                                                    if ((v95 | *(char *)&g179) == 0 == g28 < (char *)3) {
                                                                                                                        goto lab_0x3f2b8;
                                                                                                                    } else {
                                                                                                                        // 0x404f4
                                                                                                                        snprintf((char *)&str, 2048, "%s: load json failed", "cb_bitmain_api_stats");
                                                                                                                        function_1ccec(3, &str, 0);
                                                                                                                        v3 = 317;
                                                                                                                        goto lab_0x3f2b8;
                                                                                                                    }
                                                                                                                }
                                                                                                                // 0x40228
                                                                                                                *v92 = function_47658(v94);
                                                                                                                if (function_47658(v94) != 0) {
                                                                                                                    int32_t v96 = 0;
                                                                                                                    int32_t v97 = function_47674(v94, v96); // 0x4024c
                                                                                                                    while (v97 != 0) {
                                                                                                                        int32_t v98 = function_47a7c(v97); // 0x40258
                                                                                                                        int32_t v99 = *v92; // 0x4025c
                                                                                                                        int32_t v100 = v96 + 1; // 0x40264
                                                                                                                        *(int32_t *)(4 * (v96 + v91 + v99 * v93) + (int32_t)&g281 + 888) = v98;
                                                                                                                        uint32_t v101 = function_47658(v94); // 0x40238
                                                                                                                        int32_t v102 = v100; // 0x40248
                                                                                                                        if (v101 == v100 || v101 < v100) {
                                                                                                                            // break -> 0x40524
                                                                                                                            break;
                                                                                                                        }
                                                                                                                        v96 = v102;
                                                                                                                        v97 = function_47674(v94, v96);
                                                                                                                    }
                                                                                                                }
                                                                                                                int32_t v103 = v93 + 1; // 0x40524
                                                                                                                uint32_t v104 = function_47658(v90); // 0x401fc
                                                                                                                if (v104 == v103 || v104 < v103) {
                                                                                                                    // break -> 0x4052c
                                                                                                                    break;
                                                                                                                }
                                                                                                                v93 = v103;
                                                                                                                v94 = function_47674(v90, v93);
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                    int32_t v105 = v34 + 1; // 0x4052c
                                                                                                    uint32_t v106 = function_47658(v31); // 0x3f824
                                                                                                    v33 = str2 + 1552;
                                                                                                    if (v106 == v105 || v106 <= v34) {
                                                                                                        // break -> 0x3fa00
                                                                                                        break;
                                                                                                    }
                                                                                                    v34 = v105;
                                                                                                    v35 = function_47674(v31, v34);
                                                                                                }
                                                                                            }
                                                                                            int32_t v107 = function_472ec(result, "miner_version"); // 0x3fa10
                                                                                            if (v107 != 0) {
                                                                                                // 0x3fa1c
                                                                                                if (*(int32_t *)v107 == 2) {
                                                                                                    int32_t v108 = function_47820(v107); // 0x3fb04
                                                                                                    snprintf((char *)&g292, 48, "%s", (char *)v108);
                                                                                                    if (strcmp((char *)&g292, (char *)&g159) != 0) {
                                                                                                        // 0x3fb38
                                                                                                        strncpy((char *)&g159, (char *)&g292, 256);
                                                                                                    }
                                                                                                    int32_t v109 = function_472ec(result, "total_hash"); // 0x3fb58
                                                                                                    if (v109 != 0) {
                                                                                                        // 0x3fb64
                                                                                                        if (*(int32_t *)v109 == 4) {
                                                                                                            // 0x3fc50
                                                                                                            function_47b28(v109);
                                                                                                            __asm_vldr(0);
                                                                                                            return result;
                                                                                                        }
                                                                                                    }
                                                                                                    char v110 = *(char *)&g70; // 0x3fb8c
                                                                                                    if ((v110 | *(char *)&g179) == 0 != g28 < (char *)3) {
                                                                                                        // 0x3fbac
                                                                                                        snprintf((char *)&str, 2048, "%s: load json failed", "cb_bitmain_api_stats");
                                                                                                        function_1ccec(3, &str, 0);
                                                                                                    }
                                                                                                    // 0x3f2b8
                                                                                                    function_3ec74(332);
                                                                                                    // 0x3f194
                                                                                                    function_1da28();
                                                                                                    return -3;
                                                                                                }
                                                                                            }
                                                                                            char v111 = *(char *)&g70; // 0x3fa44
                                                                                            if ((v111 | *(char *)&g179) == 0 != g28 < (char *)3) {
                                                                                                // 0x3fa64
                                                                                                snprintf((char *)&str, 2048, "%s: load json failed", "cb_bitmain_api_stats");
                                                                                                function_1ccec(3, &str, 0);
                                                                                            }
                                                                                            // 0x3f2b8
                                                                                            function_3ec74(326);
                                                                                            // 0x3f194
                                                                                            function_1da28();
                                                                                            return -3;
                                                                                        }
                                                                                    }
                                                                                    char v112 = *(char *)&g70; // 0x3f720
                                                                                    if ((v112 | *(char *)&g179) == 0 != g28 < (char *)3) {
                                                                                        // 0x3f740
                                                                                        snprintf((char *)&str, 2048, "%s: load json failed", "cb_bitmain_api_stats");
                                                                                        function_1ccec(3, &str, 0);
                                                                                    }
                                                                                    // 0x3f2b8
                                                                                    function_3ec74(204);
                                                                                    // 0x3f194
                                                                                    function_1da28();
                                                                                    return -3;
                                                                                }
                                                                            }
                                                                            char v113 = *(char *)&g70; // 0x3f648
                                                                            v3 = 197;
                                                                            if ((v113 | *(char *)&g179) == 0 != g28 < (char *)3) {
                                                                                // 0x3f668
                                                                                snprintf((char *)&str, 2048, "%s: load json failed", "cb_bitmain_api_stats");
                                                                                function_1ccec(3, &str, 0);
                                                                                v3 = 197;
                                                                            }
                                                                          lab_0x3f2b8:
                                                                            // 0x3f2b8
                                                                            function_3ec74(v3);
                                                                            // 0x3f194
                                                                            function_1da28();
                                                                            return -3;
                                                                        }
                                                                    }
                                                                    char v114 = *(char *)&g70; // 0x3f5a8
                                                                    if ((v114 | *(char *)&g179) == 0 != g28 < (char *)3) {
                                                                        // 0x3f5c8
                                                                        snprintf((char *)&str, 2048, "%s: load json failed", "cb_bitmain_api_stats");
                                                                        function_1ccec(3, &str, 0);
                                                                    }
                                                                    // 0x3f2b8
                                                                    function_3ec74(193);
                                                                    // 0x3f194
                                                                    function_1da28();
                                                                    return -3;
                                                                }
                                                            }
                                                            char v115 = *(char *)&g70; // 0x3f4fc
                                                            if ((v115 | *(char *)&g179) == 0 != g28 < (char *)3) {
                                                                // 0x3f51c
                                                                snprintf((char *)&str, 2048, "%s: load json failed", "cb_bitmain_api_stats");
                                                                function_1ccec(3, &str, 0);
                                                            }
                                                            // 0x3f2b8
                                                            function_3ec74(189);
                                                            // 0x3f194
                                                            function_1da28();
                                                            return -3;
                                                        }
                                                    }
                                                    char v116 = *(char *)&g70; // 0x3f450
                                                    if ((v116 | *(char *)&g179) == 0 != g28 < (char *)3) {
                                                        // 0x3f470
                                                        snprintf((char *)&str, 2048, "%s: load json failed", "cb_bitmain_api_stats");
                                                        function_1ccec(3, &str, 0);
                                                    }
                                                    // 0x3f2b8
                                                    function_3ec74(185);
                                                    // 0x3f194
                                                    function_1da28();
                                                    return -3;
                                                }
                                            }
                                            char v117 = *(char *)&g70; // 0x3f390
                                            if ((v117 | *(char *)&g179) == 0 != g28 < (char *)3) {
                                                // 0x3f3b0
                                                snprintf((char *)&str, 2048, "%s: load json failed", "cb_bitmain_api_stats");
                                                function_1ccec(3, &str, 0);
                                            }
                                            // 0x3f2b8
                                            function_3ec74(180);
                                            // 0x3f194
                                            function_1da28();
                                            return -3;
                                        }
                                    }
                                    char v118 = *(char *)&g70; // 0x3f26c
                                    if ((v118 | *(char *)&g179) == 0 != g28 < (char *)3) {
                                        // 0x3f28c
                                        snprintf((char *)&str, 2048, "%s: load json failed", "cb_bitmain_api_stats");
                                        function_1ccec(3, &str, 0);
                                    }
                                    // 0x3f2b8
                                    function_3ec74(176);
                                    // 0x3f194
                                    function_1da28();
                                    return -3;
                                }
                            }
                            char v119 = *(char *)&g70; // 0x3f138
                            if ((v119 | *(char *)&g179) == 0 != g28 < (char *)3) {
                                // 0x3f158
                                snprintf((char *)&str, 2048, "%s: load json failed", "cb_bitmain_api_stats");
                                function_1ccec(3, &str, 0);
                            }
                            // 0x3f180
                            if (pthread_mutex_unlock(&g280) == 0) {
                                // 0x3f194
                                function_1da28();
                                return -3;
                            }
                            int32_t v120 = *__errno_location(); // 0x3f30c
                            snprintf((char *)&str, 2048, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", v120, "socketa_api.c", "cb_bitmain_api_stats", 172);
                            function_1ccec(3, &str, 1);
                            function_3aadc(1);
                            // UNREACHABLE
                        }
                    }
                    char v121 = *(char *)&g70; // 0x3ef94
                    int32_t v122 = (int32_t)"chain_num"; // 0x3ef88
                    int32_t v123 = 0x1a10; // 0x3ef88
                    if ((v121 | *(char *)&g179) == 0 != g28 < (char *)3) {
                        // 0x3efb4
                        snprintf((char *)&str, 2048, "%s: load json failed", "cb_bitmain_api_stats");
                        function_1ccec(3, &str, 0);
                        v122 = &str;
                        v123 = 0;
                    }
                    // 0x3efdc
                    if (pthread_mutex_unlock(&g280) != 0) {
                        int32_t v124 = *__errno_location(); // 0x3f1d8
                        snprintf((char *)&str, 2048, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", v124, "socketa_api.c", "cb_bitmain_api_stats", 162);
                        function_1ccec(3, &str, 1);
                        function_3aadc(1);
                        // UNREACHABLE
                    }
                    int32_t v125 = function_1da28(); // 0x3effc
                    int32_t v126 = result + 4; // 0x3f000
                    int32_t * v127 = (int32_t *)v126; // 0x3f000
                    if (*v127 == -1) {
                        // 0x3ee04
                        return -3;
                    }
                    // 0x3f00c
                    __asm_dmb(v125, v122, v123, v126);
                    int32_t v128 = *v127;
                    int32_t v129 = v128 - 1; // 0x3f018
                    int32_t v130 = __asm_strex(v129, v128); // 0x3f01c
                    v4 = v129;
                    while (v130 != 0) {
                        // 0x3f014
                        v128 = *v127;
                        v129 = v128 - 1;
                        v130 = __asm_strex(v129, v128);
                        v4 = v129;
                    }
                    goto lab_0x3eee8;
                } else {
                    goto lab_0x3ee60;
                }
            }
        } else {
            goto lab_0x3ed90;
        }
    }
  lab_0x40ae8_2:;
    char v131 = *(char *)&g70; // 0x40b08
    v3 = 213;
    if ((v131 | *(char *)&g179) == 0 == g28 < (char *)3) {
        goto lab_0x3f2b8;
    } else {
        // 0x40b28
        snprintf((char *)&str, 2048, "%s: load json failed", "cb_bitmain_api_stats");
        function_1ccec(3, &str, 0);
        v3 = 213;
        goto lab_0x3f2b8;
    }
  lab_0x40b58_2:;
    char v132 = *(char *)&g70; // 0x40b78
    v3 = 217;
    if ((v132 | *(char *)&g179) == 0 == g28 < (char *)3) {
        goto lab_0x3f2b8;
    } else {
        // 0x40b98
        snprintf((char *)&str, 2048, "%s: load json failed", "cb_bitmain_api_stats");
        function_1ccec(3, &str, 0);
        v3 = 217;
        goto lab_0x3f2b8;
    }
  lab_0x40688_2:;
    char v133 = *(char *)&g70; // 0x406a8
    v3 = 221;
    if ((v133 | *(char *)&g179) == 0 == g28 < (char *)3) {
        goto lab_0x3f2b8;
    } else {
        // 0x406c8
        snprintf((char *)&str, 2048, "%s: load json failed", "cb_bitmain_api_stats");
        function_1ccec(3, &str, 0);
        v3 = 221;
        goto lab_0x3f2b8;
    }
  lab_0x40a78_2:;
    char v134 = *(char *)&g70; // 0x40a98
    v3 = 225;
    if ((v134 | *(char *)&g179) == 0 == g28 < (char *)3) {
        goto lab_0x3f2b8;
    } else {
        // 0x40ab8
        snprintf((char *)&str, 2048, "%s: load json failed", "cb_bitmain_api_stats");
        function_1ccec(3, &str, 0);
        v3 = 225;
        goto lab_0x3f2b8;
    }
  lab_0x40998_2:;
    char v135 = *(char *)&g70; // 0x409b8
    v3 = 229;
    if ((v135 | *(char *)&g179) == 0 == g28 < (char *)3) {
        goto lab_0x3f2b8;
    } else {
        // 0x409d8
        snprintf((char *)&str, 2048, "%s: load json failed", "cb_bitmain_api_stats");
        function_1ccec(3, &str, 0);
        v3 = 229;
        goto lab_0x3f2b8;
    }
  lab_0x40a08_2:;
    char v136 = *(char *)&g70; // 0x40a28
    v3 = 233;
    if ((v136 | *(char *)&g179) == 0 == g28 < (char *)3) {
        goto lab_0x3f2b8;
    } else {
        // 0x40a48
        snprintf((char *)&str, 2048, "%s: load json failed", "cb_bitmain_api_stats");
        function_1ccec(3, &str, 0);
        v3 = 233;
        goto lab_0x3f2b8;
    }
  lab_0x405a8_2:;
    char v137 = *(char *)&g70; // 0x405c8
    v3 = 237;
    if ((v137 | *(char *)&g179) == 0 == g28 < (char *)3) {
        goto lab_0x3f2b8;
    } else {
        // 0x405e8
        snprintf((char *)&str, 2048, "%s: load json failed", "cb_bitmain_api_stats");
        function_1ccec(3, &str, 0);
        v3 = 237;
        goto lab_0x3f2b8;
    }
  lab_0x3fda8_2:;
    char v138 = *(char *)&g70; // 0x3fdc8
    v3 = 246;
    if ((v138 | *(char *)&g179) == 0 == g28 < (char *)3) {
        goto lab_0x3f2b8;
    } else {
        // 0x3fde8
        snprintf((char *)&str, 2048, "%s: load json failed", "cb_bitmain_api_stats");
        function_1ccec(3, &str, 0);
        v3 = 246;
        goto lab_0x3f2b8;
    }
  lab_0x3ff48_2:;
    char v139 = *(char *)&g70; // 0x3ff68
    v3 = 255;
    if ((v139 | *(char *)&g179) == 0 == g28 < (char *)3) {
        goto lab_0x3f2b8;
    } else {
        // 0x3ff88
        snprintf((char *)&str, 2048, "%s: load json failed", "cb_bitmain_api_stats");
        function_1ccec(3, &str, 0);
        v3 = 255;
        goto lab_0x3f2b8;
    }
  lab_0x40444_2:;
    char v140 = *(char *)&g70; // 0x40464
    v3 = 264;
    if ((v140 | *(char *)&g179) == 0 == g28 < (char *)3) {
        goto lab_0x3f2b8;
    } else {
        // 0x40484
        snprintf((char *)&str, 2048, "%s: load json failed", "cb_bitmain_api_stats");
        function_1ccec(3, &str, 0);
        v3 = 264;
        goto lab_0x3f2b8;
    }
  lab_0x40278_2:;
    char v141 = *(char *)&g70; // 0x40298
    v3 = 270;
    if ((v141 | *(char *)&g179) == 0 == g28 < (char *)3) {
        goto lab_0x3f2b8;
    } else {
        // 0x402b8
        snprintf((char *)&str, 2048, "%s: load json failed", "cb_bitmain_api_stats");
        function_1ccec(3, &str, 0);
        v3 = 270;
        goto lab_0x3f2b8;
    }
  lab_0x40928_2:;
    char v142 = *(char *)&g70; // 0x40948
    v3 = 278;
    if ((v142 | *(char *)&g179) == 0 != g28 < (char *)3) {
        // 0x40968
        snprintf((char *)&str, 2048, "%s: load json failed", "cb_bitmain_api_stats");
        function_1ccec(3, &str, 0);
        v3 = 278;
    }
    goto lab_0x3f2b8;
  lab_0x40848_2:;
    char v143 = *(char *)&g70; // 0x40868
    v3 = 283;
    if ((v143 | *(char *)&g179) == 0 == g28 < (char *)3) {
        goto lab_0x3f2b8;
    } else {
        // 0x40888
        snprintf((char *)&str, 2048, "%s: load json failed", "cb_bitmain_api_stats");
        function_1ccec(3, &str, 0);
        v3 = 283;
        goto lab_0x3f2b8;
    }
  lab_0x408b8_2:;
    char v144 = *(char *)&g70; // 0x408d8
    v3 = 287;
    if ((v144 | *(char *)&g179) == 0 == g28 < (char *)3) {
        goto lab_0x3f2b8;
    } else {
        // 0x408f8
        snprintf((char *)&str, 2048, "%s: load json failed", "cb_bitmain_api_stats");
        function_1ccec(3, &str, 0);
        v3 = 287;
        goto lab_0x3f2b8;
    }
  lab_0x40618_2:;
    char v145 = *(char *)&g70; // 0x40638
    v3 = 291;
    if ((v145 | *(char *)&g179) == 0 == g28 < (char *)3) {
        goto lab_0x3f2b8;
    } else {
        // 0x40658
        snprintf((char *)&str, 2048, "%s: load json failed", "cb_bitmain_api_stats");
        function_1ccec(3, &str, 0);
        v3 = 291;
        goto lab_0x3f2b8;
    }
  lab_0x407d8_2:;
    char v146 = *(char *)&g70; // 0x407f8
    v3 = 295;
    if ((v146 | *(char *)&g179) == 0 == g28 < (char *)3) {
        goto lab_0x3f2b8;
    } else {
        // 0x40818
        snprintf((char *)&str, 2048, "%s: load json failed", "cb_bitmain_api_stats");
        function_1ccec(3, &str, 0);
        v3 = 295;
        goto lab_0x3f2b8;
    }
  lab_0x406f8_2:;
    char v147 = *(char *)&g70; // 0x40718
    v3 = 299;
    if ((v147 | *(char *)&g179) == 0 == g28 < (char *)3) {
        goto lab_0x3f2b8;
    } else {
        // 0x40738
        snprintf((char *)&str, 2048, "%s: load json failed", "cb_bitmain_api_stats");
        function_1ccec(3, &str, 0);
        v3 = 299;
        goto lab_0x3f2b8;
    }
  lab_0x40768_2:;
    char v148 = *(char *)&g70; // 0x40788
    v3 = 303;
    if ((v148 | *(char *)&g179) == 0 == g28 < (char *)3) {
        goto lab_0x3f2b8;
    } else {
        // 0x407a8
        snprintf((char *)&str, 2048, "%s: load json failed", "cb_bitmain_api_stats");
        function_1ccec(3, &str, 0);
        v3 = 303;
        goto lab_0x3f2b8;
    }
  lab_0x40538_2:;
    char v149 = *(char *)&g70; // 0x40558
    v3 = 307;
    if ((v149 | *(char *)&g179) == 0 == g28 < (char *)3) {
        goto lab_0x3f2b8;
    } else {
        // 0x40578
        snprintf((char *)&str, 2048, "%s: load json failed", "cb_bitmain_api_stats");
        function_1ccec(3, &str, 0);
        v3 = 307;
        goto lab_0x3f2b8;
    }
  lab_0x3ed90:
    // 0x3ed90
    if ((*(char *)&g70 | *(char *)&g179) == 0) {
        // 0x3edb8
        if (g28 <= (char *)2) {
            // 0x3ee04
            return g28 < (char *)3 ? -2 : result;
        }
    }
    // 0x3edd0
    int32_t v150; // bp-2248, 0x3ecf0
    snprintf((char *)&str, 2048, "%s: load data is failed(%s)", "cb_bitmain_api_stats", &v150);
    function_1ccec(3, &str, 0);
    // 0x3ee04
    return -2;
  lab_0x3ee60:;
    char v151 = *(char *)&g70; // 0x3ee7c
    int32_t v152 = (int32_t)"inited"; // 0x3ee70
    int32_t v153 = 0x1a10; // 0x3ee70
    if ((v151 | *(char *)&g179) != 0 || g28 > (char *)2) {
        // 0x3ef20
        snprintf((char *)&str, 2048, "%s: load json failed", "cb_bitmain_api_stats");
        function_1ccec(3, &str, 0);
        v152 = &str;
        v153 = 0;
    }
    // 0x3ee9c
    if (pthread_mutex_unlock(&g280) != 0) {
        int32_t v154 = *__errno_location(); // 0x3f094
        snprintf((char *)&str, 2048, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", v154, "socketa_api.c", "cb_bitmain_api_stats", 158);
        function_1ccec(3, &str, 1);
        function_3aadc(1);
        // UNREACHABLE
    }
    int32_t v155 = function_1da28(); // 0x3eebc
    int32_t v156 = result + 4; // 0x3eec0
    int32_t * v157 = (int32_t *)v156; // 0x3eec0
    if (*v157 == -1) {
        // 0x3ee04
        return -3;
    }
    // 0x3eecc
    __asm_dmb(v155, v152, v153, v156);
    int32_t v158 = *v157;
    int32_t v159 = v158 - 1; // 0x3eed8
    int32_t v160 = __asm_strex(v159, v158); // 0x3eedc
    v4 = v159;
    while (v160 != 0) {
        // 0x3eed4
        v158 = *v157;
        v159 = v158 - 1;
        v160 = __asm_strex(v159, v158);
        v4 = v159;
    }
    goto lab_0x3eee8;
  lab_0x3eee8:
    // 0x3eee8
    if (v4 == 0) {
        // 0x3eef0
        function_47c24(result);
    }
    // 0x3ee04
    return -3;
}

// Address range: 0x40c38 - 0x40ce8
int32_t function_40c38(int32_t a1, int32_t a2) {
    // 0x40c38
    if (a1 != 0 && a2 != 0) {
        // 0x40cd8
        int32_t v1; // 0x40c38
        int32_t result = function_3ecf0(a1, a2, v1, v1, v1, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306); // 0x40cd8
        // 0x40cdc
        return result;
    }
    // 0x40c50
    int32_t str; // bp-2056, 0x40c38
    if ((*(char *)&g70 | *(char *)&g179) != 0) {
        // 0x40c98
        snprintf((char *)&str, 2048, "%s input err: data @ %p, len is %d", "cb_bitmain_api_stats", (int32_t *)a1, a2);
        function_1ccec(3, &str, 0);
        return -1;
    }
    // 0x40c80
    if (g28 <= (char *)2) {
        // 0x40cdc
        return g28 < (char *)3 ? -1 : a1;
    }
    // 0x40c98
    snprintf((char *)&str, 2048, "%s input err: data @ %p, len is %d", "cb_bitmain_api_stats", (int32_t *)a1, a2);
    function_1ccec(3, &str, 0);
    return -1;
}

// Address range: 0x40cec - 0x40da8
int32_t function_40cec(int32_t * a1, int32_t a2) {
    char v1 = *(char *)&g70; // 0x40d1c
    char * v2; // bp-2064, 0x40cec
    if ((v1 | *(char *)&g179) != 0 || g28 > (char *)4) {
        // 0x40d28
        v2 = (char *)0x756f6261;
        function_1ccec(5, (int32_t *)&v2, 0);
    }
    int32_t * v3 = (int32_t *)&v2;
    return function_43450("bitmain_api_detect", (int32_t)a1, a2, v3);
}

// Address range: 0x40da8 - 0x40e6c
int32_t function_40da8(int32_t a1, int32_t a2) {
    // 0x40da8
    int32_t str; // bp-2064, 0x40da8
    if (*(char *)&g71 == 0) {
        // 0x40e40
        return function_43450("bitmain_update_job", a1, a2, &str);
    }
    char v1 = *(char *)&g70; // 0x40dec
    if ((v1 | *(char *)&g179) != 0 || g28 > (char *)6) {
        // 0x40df8
        snprintf((char *)&str, 2048, "about to send job, size is %d", a2);
        function_1ccec(7, &str, 0);
    }
    // 0x40e40
    return function_43450("bitmain_update_job", a1, a2, &str);
}

// Address range: 0x40e70 - 0x40f40
int32_t function_40e70(int32_t * a1, int32_t a2) {
    // 0x40e70
    char * v1; // bp-2064, 0x40e70
    if (*(char *)&g71 == 0) {
        // 0x40f14
        return function_43450("bitmain_flush_api", (int32_t)a1, a2, (int32_t *)&v1);
    }
    char v2 = *(char *)&g70; // 0x40eb4
    if ((v2 | *(char *)&g179) != 0 || g28 > (char *)6) {
        // 0x40ec0
        v1 = (char *)0x756f6261;
        function_1ccec(7, (int32_t *)&v1, 0);
    }
    // 0x40f14
    return function_43450("bitmain_flush_api", (int32_t)a1, a2, (int32_t *)&v1);
}

// Address range: 0x40f44 - 0x41004
int32_t function_40f44(char * a1, int32_t a2) {
    char v1 = *(char *)&g70; // 0x40f74
    char * v2; // bp-2064, 0x40f44
    if ((v1 | *(char *)&g179) != 0 || g28 > (char *)4) {
        // 0x40f80
        v2 = (char *)0x756f6261;
        function_1ccec(5, (int32_t *)&v2, 0);
    }
    // 0x40fbc
    return function_43450("bitmain_shutdown", (int32_t)a1, a2, (int32_t *)&v2);
}

// Address range: 0x41008 - 0x41268
int32_t function_41008(void) {
    // 0x41008
    int32_t str; // bp-2080, 0x41008
    if (pthread_mutex_init(&g280, NULL) != 0) {
        int32_t v1 = *__errno_location(); // 0x411e0
        snprintf((char *)&str, 2048, "Failed to pthread_mutex_init errno=%d in %s %s():%d", v1, "socketa_api.c", "cgminer_socket_init", 506);
        function_1ccec(3, &str, 1);
        function_3aadc(1);
        // UNREACHABLE
    }
    // 0x41028
    if (pthread_mutex_init(&g295, NULL) != 0) {
        int32_t v2 = *__errno_location(); // 0x41230
        snprintf((char *)&str, 2048, "Failed to pthread_mutex_init errno=%d in %s %s():%d", v2, "socketa_api.c", "cgminer_socket_init", 507);
        function_1ccec(3, &str, 1);
        function_3aadc(1);
        // UNREACHABLE
    }
    int32_t result = function_42f3c(&g25, 2); // 0x41048
    if (result != 0) {
        char v3 = *(char *)&g70; // 0x41170
        if ((v3 | *(char *)&g179) == 0 != g28 < (char *)3) {
            // 0x41190
            snprintf((char *)&str, 2048, "%s trans init failed: %d", "cgminer_socket_init", result);
            function_1ccec(3, &str, 0);
        }
        // 0x411bc
        return result;
    }
    int32_t v4 = (int32_t)"bitmain_api_detect";
    int32_t v5 = function_43190(v4); // 0x4108c
    char v6 = *(char *)&g70; // 0x410a8
    if ((v6 | *(char *)&g179) == 0 != g28 < (char *)5) {
        // 0x410c8
        snprintf((char *)&str, 2048, "%s reg %s return: %d", "cgminer_socket_init", (char *)v4, v5);
        function_1ccec(5, &str, 0);
    }
    int32_t v7 = v4 + 132; // 0x410e0
    int32_t v8 = v5; // 0x410e8
    while (v7 != (int32_t)&g52) {
        // 0x41080
        v4 = v7;
        v5 = function_43190(v4) | v8;
        v6 = *(char *)&g70;
        if ((v6 | *(char *)&g179) == 0 != g28 < (char *)5) {
            // 0x410c8
            snprintf((char *)&str, 2048, "%s reg %s return: %d", "cgminer_socket_init", (char *)v4, v5);
            function_1ccec(5, &str, 0);
        }
        // 0x410e0
        v7 = v4 + 132;
        v8 = v5;
    }
    while (v5 != 0) {
        // 0x410f4
        sleep(5);
        char v9 = *(char *)&g70; // 0x41108
        if ((v9 | *(char *)&g179) == 0 != g28 < (char *)3) {
            // 0x41128
            snprintf((char *)&str, 2048, "%s reg failed wait 5s", "cgminer_socket_init");
            function_1ccec(3, &str, 0);
        }
        v4 = (int32_t)"bitmain_api_detect";
        v5 = function_43190(v4);
        v6 = *(char *)&g70;
        if ((v6 | *(char *)&g179) == 0 != g28 < (char *)5) {
            // 0x410c8
            snprintf((char *)&str, 2048, "%s reg %s return: %d", "cgminer_socket_init", (char *)v4, v5);
            function_1ccec(5, &str, 0);
        }
        // 0x410e0
        v7 = v4 + 132;
        v8 = v5;
        while (v7 != (int32_t)&g52) {
            // 0x41080
            v4 = v7;
            v5 = function_43190(v4) | v8;
            v6 = *(char *)&g70;
            if ((v6 | *(char *)&g179) == 0 != g28 < (char *)5) {
                // 0x410c8
                snprintf((char *)&str, 2048, "%s reg %s return: %d", "cgminer_socket_init", (char *)v4, v5);
                function_1ccec(5, &str, 0);
            }
            // 0x410e0
            v7 = v4 + 132;
            v8 = v5;
        }
    }
    // 0x411bc
    return 0;
}

// Address range: 0x41278 - 0x41474
int32_t function_41278(int32_t a1) {
    // 0x41278
    int32_t v1; // bp-2460, 0x41278
    memset(&v1, 0, 128);
    int32_t v2 = &v1; // 0x41298
    function_29c6c(v2);
    int32_t v3; // bp-2332, 0x41278
    int32_t v4 = function_467a0(v2, 0, &v3); // 0x412ac
    int32_t v5; // 0x41278
    int32_t v6; // 0x41278
    int32_t v7; // 0x41278
    int32_t v8; // 0x41278
    if (v4 == 0) {
        goto lab_0x412c4;
    } else {
        // 0x412b8
        if (*(int32_t *)v4 == 0) {
            int32_t v9 = &v3; // 0x412a4
            int32_t v10 = function_472ec(v4, "bitmain-work-mode"); // 0x413a0
            int32_t v11 = v9; // 0x413a8
            int32_t v12 = -1; // 0x413a8
            int32_t v13 = -1; // 0x413a8
            if (v10 != 0) {
                // 0x413ac
                v11 = v9;
                v12 = -1;
                v13 = -1;
                if (*(int32_t *)v10 == 2) {
                    int32_t str_as_l = strtol((char *)function_47820(v10), NULL, 10); // 0x41464
                    v11 = 10;
                    v12 = str_as_l;
                    v13 = str_as_l >> 31;
                }
            }
            int32_t v14 = function_472ec(v4, "bitmain-freq-level"); // 0x413cc
            int32_t v15 = 0; // 0x413d4
            int32_t v16 = (int32_t)"bitmain-freq-level"; // 0x413d4
            int32_t v17 = v11; // 0x413d4
            int32_t v18 = -1; // 0x413d4
            int32_t v19 = -1; // 0x413d4
            if (v14 != 0) {
                // 0x413d8
                v15 = v14;
                v16 = (int32_t)"bitmain-freq-level";
                v17 = v11;
                v18 = -1;
                v19 = -1;
                if (*(int32_t *)v14 == 2) {
                    int32_t str_as_l2 = strtol((char *)function_47820(v14), NULL, 10); // 0x41448
                    v15 = str_as_l2;
                    v16 = 0;
                    v17 = 10;
                    v18 = str_as_l2;
                    v19 = str_as_l2 >> 31;
                }
            }
            int32_t v20 = v4 + 4; // 0x413ec
            int32_t * v21 = (int32_t *)v20; // 0x413ec
            v5 = v18;
            v6 = v19;
            v7 = v12;
            v8 = v13;
            if (*v21 != -1) {
                // 0x413f8
                __asm_dmb(v15, v16, v17, v20);
                int32_t v22 = *v21;
                int32_t v23 = v22 - 1; // 0x41404
                while (__asm_strex(v23, v22) != 0) {
                    // 0x41400
                    v22 = *v21;
                    v23 = v22 - 1;
                }
                // 0x41414
                v5 = v18;
                v6 = v19;
                v7 = v12;
                v8 = v13;
                if (v23 == 0) {
                    // 0x4141c
                    function_47c24(v4);
                    v5 = v18;
                    v6 = v19;
                    v7 = v12;
                    v8 = v13;
                }
            }
            goto lab_0x4134c;
        } else {
            goto lab_0x412c4;
        }
    }
  lab_0x412c4:;
    char v24 = *(char *)&g70; // 0x412e0
    v5 = -1;
    v6 = -1;
    v7 = -1;
    v8 = -1;
    if ((v24 | *(char *)&g179) == 0 != g28 < (char *)3) {
        // 0x41300
        int32_t str; // bp-2080, 0x41278
        int32_t v25; // bp-2240, 0x41278
        snprintf((char *)&str, 2048, "%s: JSON decode of file '%s' failed\n %s", "load_conf_info", &v1, &v25);
        function_1ccec(3, &str, 0);
        v5 = -1;
        v6 = -1;
        v7 = -1;
        v8 = -1;
    }
    goto lab_0x4134c;
  lab_0x4134c:
    // 0x4134c
    function_4808c(a1, "miner-mode", function_47a48(v7, v8));
    return function_4808c(a1, "freq-level", function_47a48(v5, v6));
}

// Address range: 0x41474 - 0x4156c
int32_t function_41474(void) {
    char v1 = *(char *)&g70; // 0x41498
    char * str; // bp-2056, 0x41474
    if ((v1 | *(char *)&g179) == 0 != g28 < (char *)5) {
        // 0x414a4
        str = (char *)0x696d6763;
        function_1ccec(5, (int32_t *)&str, 0);
    }
    int32_t v2 = function_40f44("shutdown", 8); // 0x414e0
    if (v2 == 0) {
        // 0x41534
        return 0;
    }
    char v3 = *(char *)&g70; // 0x41500
    int32_t result = v2; // 0x414f4
    if ((v3 | *(char *)&g179) != 0 || g28 > (char *)2) {
        // 0x4150c
        snprintf((char *)&str, 2048, "%s: bitmain_shutdown failed.", "bitmain_c5_shutdown");
        result = function_1ccec(3, (int32_t *)&str, 0);
    }
    // 0x41534
    return result;
}

// Address range: 0x41570 - 0x415b4
int32_t function_41570(void) {
    // 0x41570
    int32_t str; // bp-2056, 0x41570
    snprintf((char *)&str, 2048, "%s: api detect failed.", "bitmain_c5_prepare");
    function_1ccec(3, &str, 0);
    return 0;
}

// Address range: 0x415b8 - 0x41700
int32_t function_415b8(void) {
    // 0x415b8
    int32_t str; // bp-108, 0x415b8
    memset(&str, 0, 40);
    int32_t str2; // bp-68, 0x415b8
    memset(&str2, 0, 59);
    int32_t v1; // bp-140, 0x415b8
    memset(&v1, 0, 32);
    int32_t timep; // bp-180, 0x415b8
    function_1f5c4(&timep);
    struct tm * time_info = localtime(&timep); // 0x41600
    int32_t v2 = (int32_t)time_info; // 0x41600
    int32_t v3 = time_info->e0; // 0x4160c
    int32_t v4 = *(int32_t *)(v2 + 20); // 0x41614
    int32_t v5 = *(int32_t *)(v2 + 4); // 0x41620
    int32_t v6 = *(int32_t *)(v2 + 8); // 0x41634
    int32_t v7 = *(int32_t *)(v2 + 12); // 0x4163c
    int32_t v8 = *(int32_t *)(v2 + 16); // 0x41644
    snprintf((char *)&str, 40, "[%d-%02d-%02d %02d:%02d:%02d]", v4 + 1900, v8 + 1, v7, v6, v5, v3);
    snprintf((char *)&str2, 59, "%s%s", "BITMAIN_OPENSOURCE", &str);
    function_1d9c8(&str2, 59, &v1);
    int32_t v9; // bp-172, 0x415b8
    function_1d9c8(&v1, 32, &v9);
    if (function_40cec(&v9, 32) == 0) {
        // 0x416f0
        function_3b980();
        return 1;
    }
    // 0x416a8
    if (*(char *)&g179 != 0) {
        // 0x416e8
        return function_41570();
    }
    // 0x416bc
    if (*(char *)&g70 == 0 == g28 < (char *)3) {
        // 0x416e8
        return 0;
    }
    // 0x416e8
    return function_41570();
}

// Address range: 0x41700 - 0x41758
int32_t function_41700(char * a1, int32_t a2) {
    int32_t v1 = *__errno_location(); // 0x41718
    int32_t str; // bp-2064, 0x41700
    snprintf((char *)&str, 2048, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", v1, "driver-btm-c5_socketa.c", a1, a2);
    function_1ccec(3, &str, 1);
    function_3aadc(1);
    // UNREACHABLE
}

// Address range: 0x41758 - 0x41764
int32_t function_41758(int32_t a1, int32_t a2) {
    // 0x41758
    int32_t result; // 0x41758
    return result;
}

// Address range: 0x41764 - 0x417bc
int32_t function_41764(char * a1, int32_t a2) {
    int32_t v1 = *__errno_location(); // 0x4177c
    int32_t str; // bp-2064, 0x41764
    snprintf((char *)&str, 2048, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", v1, "driver-btm-c5_socketa.c", a1, a2);
    function_1ccec(3, &str, 1);
    function_3aadc(1);
    // UNREACHABLE
}

// Address range: 0x417bc - 0x417c8
int32_t function_417bc(int32_t a1, int32_t a2) {
    // 0x417bc
    int32_t result; // 0x417bc
    return result;
}

// Address range: 0x417c8 - 0x41f00
int32_t function_417c8(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11) {
    // 0x417c8
    float64_t v1; // 0x417c8
    __asm_vpush_7(v1, v1, v1);
    int32_t v2 = 0; // bp-88, 0x417e8
    if (pthread_mutex_lock(&g280) != 0) {
        // 0x41ee0
        function_41764("bitmain_api_stats", 433);
        // UNREACHABLE
    }
    int32_t v3 = function_47268(); // 0x41810
    int32_t v4 = function_493a4(); // 0x4182c
    function_4808c(v3, "elapsed", function_47a48(v4, (int32_t)(int64_t)g35));
    int32_t result = sscanf2((int32_t *)&g285, "%lf", &v2, (int32_t)&g35); // 0x41858
    __asm_vldr(0);
    __asm_vldr(v2);
    return result;
}

// Address range: 0x41f00 - 0x41f28
int32_t function_41f00(void) {
    // 0x41f00
    function_1f7f8(2);
    return (uint64_t)g162 / 0x100000000;
}

// Address range: 0x41f18 - 0x41f19
int32_t function_41f18(void) {
    // 0x41f18
    int32_t result; // 0x41f18
    return result;
}

// Address range: 0x41f28 - 0x41f30
int32_t function_41f28(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x41f28
    *(int16_t *)(a3 + 6) = (int16_t)a1;
    return function_4253c(a1);
}

// Address range: 0x41f30 - 0x41f94
int32_t function_41f30(uint32_t a1) {
    // 0x41f30
    if (pthread_mutex_lock((int32_t *)(a1 % 0x10000 || (int32_t)&g171)) != 0) {
        // 0x41f74
        function_41764("bitmain_c5_scanhash", 184);
        // UNREACHABLE
    }
    // 0x41f40
    int32_t v1; // 0x41f30
    *(int32_t *)v1 = 0;
    *(int32_t *)(v1 + 4) = 0;
    if (pthread_mutex_unlock(&g295) == 0) {
        // 0x41f60
        function_1da28();
        return function_41f18();
    }
    // 0x41f84
    function_41700("bitmain_c5_scanhash", 186);
    // UNREACHABLE
}

// Address range: 0x41f98 - 0x42320
int32_t function_41f98(void) {
    int32_t * mem = calloc(1, 392); // 0x41fac
    if (mem == NULL) {
        // 0x422e8
        __assert_fail("cgpu", "driver-btm-c5_socketa.c", 51, "bitmain_c5_detect");
        // 0x42304
        __assert_fail("add_cgpu(cgpu)", "driver-btm-c5_socketa.c", 85, "bitmain_c5_detect");
        return &g306;
    }
    int32_t v1 = (int32_t)mem; // 0x41fac
    *(int32_t *)(v1 + 4) = (int32_t)&g52;
    *(int32_t *)(v1 + 32) = 0;
    *(int32_t *)(v1 + 148) = 1;
    int32_t v2 = function_41008(); // 0x41fdc
    char v3 = *(char *)&g179; // 0x41fe4
    char v4 = *(char *)&g70;
    char * str; // bp-2088, 0x41f98
    if (v2 == 0) {
        if ((v4 || v3) != 0 || g28 > (char *)5) {
            // 0x42008
            str = (char *)0x696d6763;
            function_1ccec(6, (int32_t *)&str, 0);
        }
    } else {
        if ((v4 || v3) != 0 || g28 > (char *)2) {
            // 0x42160
            str = (char *)0x696d6763;
            function_1ccec(3, (int32_t *)&str, 0);
        }
    }
    // 0x4203c
    if (g78 != NULL) {
        // 0x42050
        function_3c280();
    }
    char v5 = 0; // bp-2092, 0x42084
    function_1f7f8(2000);
    function_40e70((int32_t *)&v5, 1);
    function_1f7f8(1000);
    if (pthread_mutex_lock(&g280) != 0) {
      lab_0x421c8:;
        int32_t v6 = *__errno_location(); // 0x421cc
        snprintf((char *)&str, 2048, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", v6, "driver-btm-c5_socketa.c", "bitmain_c5_detect", 77);
        function_1ccec(3, (int32_t *)&str, 1);
        function_3aadc(1);
        // UNREACHABLE
    }
    int32_t v7 = pthread_mutex_unlock(&g280);
    while (g283 == 0) {
        if (v7 != 0) {
            int32_t v8 = *__errno_location(); // 0x42218
            snprintf((char *)&str, 2048, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", v8, "driver-btm-c5_socketa.c", "bitmain_c5_detect", 83);
            function_1ccec(3, (int32_t *)&str, 1);
            function_3aadc(1);
            // UNREACHABLE
        }
        // 0x420a0
        function_1da28();
        function_40e70((int32_t *)&v5, 1);
        function_1f7f8(1000);
        if (pthread_mutex_lock(&g280) != 0) {
            goto lab_0x421c8;
        }
        v7 = pthread_mutex_unlock(&g280);
    }
    if (v7 != 0) {
        int32_t v9 = *__errno_location(); // 0x422a0
        snprintf((char *)&str, 2048, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", v9, "driver-btm-c5_socketa.c", "bitmain_c5_detect", 79);
        function_1ccec(3, (int32_t *)&str, 1);
        function_3aadc(1);
        // UNREACHABLE
    }
    // 0x420ec
    function_1da28();
    char v10 = *(char *)&g70; // 0x42108
    if ((v10 | *(char *)&g179) != 0 || g28 > (char *)4) {
        // 0x42194
        str = (char *)0x696d6d62;
        function_1ccec(5, (int32_t *)&str, 0);
    }
    int32_t result = function_3af10(v1); // 0x4212c
    if (result != 0) {
        // 0x42138
        return result;
    }
    // 0x42304
    __assert_fail("add_cgpu(cgpu)", "driver-btm-c5_socketa.c", 85, "bitmain_c5_detect");
    return &g306;
}

// Address range: 0x42328 - 0x4253c
int32_t function_42328(int32_t a1, int32_t * a2) {
    int32_t v1 = 0; // bp-2096, 0x4234c
    int32_t * mutex = (int32_t *)(a1 + 212); // 0x42350
    if (pthread_mutex_lock(mutex) != 0) {
        function_426e0();
        // UNREACHABLE
    }
    int32_t * rwlock = (int32_t *)(a1 + 236); // 0x42364
    if (pthread_rwlock_rdlock(rwlock) != 0) {
        function_42734();
        // UNREACHABLE
    }
    // 0x42370
    if (pthread_mutex_unlock(mutex) != 0) {
        function_4268c();
        // UNREACHABLE
    }
    int32_t v2 = *(int32_t *)(a1 + 672); // 0x42380
    uint32_t v3 = *(int32_t *)(a1 + 1708); // 0x42384
    int32_t v4 = *(int32_t *)(a1 + 1572); // 0x42388
    char * str = (char *)v2; // 0x42390
    int32_t len = strlen(str); // 0x42390
    int32_t v5 = *(int32_t *)(a1 + 612); // 0x42394
    int32_t v6 = 32 * v3; // 0x42398
    char * str2 = (char *)v5; // 0x423ac
    int32_t * mem = calloc(1, v4 + 1866 + v6 + len + strlen(str2)); // 0x423cc
    int32_t v7 = (int32_t)mem; // 0x423cc
    int32_t v8 = v7; // 0x423d4
    if (mem == NULL) {
        v8 = function_425c4((int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306);
    }
    // 0x423d8
    memcpy((int32_t *)v8, (int32_t *)a1, 1848);
    memcpy((int32_t *)(v7 + 1848), (int32_t *)*(int32_t *)(a1 + 1568), v4);
    int32_t v9 = v4 + 1848; // 0x42404
    int32_t v10 = v9; // 0x42410
    if (v3 >= 1) {
        int32_t v11 = *(int32_t *)(a1 + 676); // 0x42414
        int32_t v12 = v9 + v7; // 0x4241c
        int32_t v13 = v11; // 0x4241c
        int32_t v14 = *(int32_t *)v13; // 0x42420
        v13 += 4;
        *(int32_t *)v12 = *(int32_t *)v14;
        *(int32_t *)(v12 + 4) = *(int32_t *)(v14 + 4);
        *(int32_t *)(v12 + 8) = *(int32_t *)(v14 + 8);
        *(int32_t *)(v12 + 12) = *(int32_t *)(v14 + 12);
        *(int32_t *)(v12 + 16) = *(int32_t *)(v14 + 16);
        *(int32_t *)(v12 + 20) = *(int32_t *)(v14 + 20);
        *(int32_t *)(v12 + 24) = *(int32_t *)(v14 + 24);
        *(int32_t *)(v12 + 28) = *(int32_t *)(v14 + 28);
        v12 += 32;
        while (v11 + 4 * v3 != v13) {
            // 0x42420
            v14 = *(int32_t *)v13;
            v13 += 4;
            *(int32_t *)v12 = *(int32_t *)v14;
            *(int32_t *)(v12 + 4) = *(int32_t *)(v14 + 4);
            *(int32_t *)(v12 + 8) = *(int32_t *)(v14 + 8);
            *(int32_t *)(v12 + 12) = *(int32_t *)(v14 + 12);
            *(int32_t *)(v12 + 16) = *(int32_t *)(v14 + 16);
            *(int32_t *)(v12 + 20) = *(int32_t *)(v14 + 20);
            *(int32_t *)(v12 + 24) = *(int32_t *)(v14 + 24);
            *(int32_t *)(v12 + 28) = *(int32_t *)(v14 + 28);
            v12 += 32;
        }
        // 0x42470
        v10 = (v6 >> 31) + v6;
    }
    int32_t v15 = strlen(str) + 1; // 0x42480
    memcpy((int32_t *)(v10 + v7), (int32_t *)v2, v15);
    int32_t len2 = strlen(str2); // 0x4249c
    int32_t v16 = v15 + v10 + v7;
    memcpy((int32_t *)v16, (int32_t *)v5, len2 + 1);
    if (pthread_rwlock_unlock(rwlock) != 0) {
        function_42638();
        // UNREACHABLE
    }
    // 0x424cc
    function_1da28();
    sscanf2((int32_t *)&g158, "%.2lf", &v1, (int32_t)&g2);
    int32_t v17 = v16 + len2;
    *(int32_t *)(v17 + 1) = v1;
    *(int32_t *)(v17 + 5) = 0;
    *(int32_t *)(v17 + 9) = g43;
    *(int32_t *)(v17 + 13) = g44;
    return g43;
}

// Address range: 0x4253c - 0x42540
int32_t function_4253c(int32_t a1) {
    // 0x4253c
    return a1 + 20;
}

// Address range: 0x42540 - 0x42544
int32_t function_42540(int32_t result) {
    // 0x42540
    return result;
}

// Address range: 0x42544 - 0x42554
int32_t function_42544(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    // 0x42544
    int32_t result; // 0x42544
    return result;
}

// Address range: 0x42554 - 0x425c4
int32_t function_42554(void) {
    char v1 = *(char *)&g70; // 0x42570
    int32_t v2; // 0x42554
    if ((v1 | *(char *)&g179) == 0 == g28 < (char *)7) {
        function_4253c(v2);
    }
    // 0x42590
    int32_t str; // bp+40, 0x42554
    snprintf((char *)&str, 2048, "job buf total len:%d, offset:%d\n", v2, v2 + 17);
    int32_t v3 = function_1ccec(7, &str, 0); // 0x425bc
    return function_4253c(v3);
}

// Address range: 0x425c4 - 0x42638
int32_t function_425c4(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    char v1 = *(char *)&g70; // 0x425e0
    if ((v1 | *(char *)&g179) == 0 == g28 < (char *)3) {
        function_42544((int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306);
    }
    // 0x42600
    int32_t str; // bp+40, 0x425c4
    int32_t result; // 0x425c4
    snprintf((char *)&str, 2048, "malloc temp job data buf failed: %d\n", result);
    function_1ccec(3, &str, 0);
    return result;
}

// Address range: 0x42638 - 0x42688
int32_t function_42638(void) {
    int32_t v1 = *__errno_location(); // 0x42644
    int32_t str; // bp+40, 0x42638
    snprintf((char *)&str, 2048, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", v1, "driver-btm-c5_socketa.c", "rebuild_job_buf", 258);
    function_1ccec(3, &str, 1);
    function_3aadc(1);
    // UNREACHABLE
}

// Address range: 0x42688 - 0x4268c
int32_t function_42688(void) {
    // 0x42688
    int32_t result; // 0x42688
    return result;
}

// Address range: 0x4268c - 0x426dc
int32_t function_4268c(void) {
    int32_t v1 = *__errno_location(); // 0x42698
    int32_t str; // bp+40, 0x4268c
    snprintf((char *)&str, 2048, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", v1, "driver-btm-c5_socketa.c", "rebuild_job_buf", 222);
    function_1ccec(3, &str, 1);
    function_3aadc(1);
    // UNREACHABLE
}

// Address range: 0x426dc - 0x426e0
int32_t function_426dc(void) {
    // 0x426dc
    int32_t result; // 0x426dc
    return result;
}

// Address range: 0x426e0 - 0x42730
int32_t function_426e0(void) {
    int32_t v1 = *__errno_location(); // 0x426ec
    int32_t str; // bp+40, 0x426e0
    snprintf((char *)&str, 2048, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", v1, "driver-btm-c5_socketa.c", "rebuild_job_buf", 222);
    function_1ccec(3, &str, 1);
    function_3aadc(1);
    // UNREACHABLE
}

// Address range: 0x42730 - 0x42734
int32_t function_42730(void) {
    // 0x42730
    int32_t result; // 0x42730
    return result;
}

// Address range: 0x42734 - 0x42784
int32_t function_42734(void) {
    int32_t v1 = *__errno_location(); // 0x42740
    int32_t str; // bp+40, 0x42734
    snprintf((char *)&str, 2048, "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d", v1, "driver-btm-c5_socketa.c", "rebuild_job_buf", 222);
    function_1ccec(3, &str, 1);
    function_3aadc(1);
    // UNREACHABLE
}

// Address range: 0x42784 - 0x42788
int32_t function_42784(void) {
    // 0x42784
    int32_t result; // 0x42784
    return result;
}

// Address range: 0x4278c - 0x42978
int32_t function_4278c(int32_t a1) {
    int32_t v1 = *(int32_t *)(a1 + 152); // 0x42798
    int32_t v2 = *(int32_t *)v1; // 0x427a8
    int32_t v3 = v1; // 0x427b0
    char * str; // bp-2064, 0x4278c
    if (*(char *)&g71 != 0) {
        char v4 = *(char *)&g70; // 0x427d0
        v3 = v1;
        if ((v4 | *(char *)&g179) != 0 || g28 > (char *)6) {
            // 0x427dc
            str = (char *)0x61647075;
            function_1ccec(7, (int32_t *)&str, 0);
            v3 = 0;
        }
    }
    int32_t v5 = *(int32_t *)v2; // 0x42830
    *(char *)(v2 + 63) = 0;
    *(char *)(v2 + 62) = 0;
    int32_t v6 = function_329b4(v2, v5, v3, 0, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306); // 0x42840
    int32_t v7 = v6; // bp-2072, 0x4284c
    function_292f8(&v7, "driver-btm-c5_socketa.c", "bitmain_c5_update", 288);
    int32_t v8 = function_2e47c(); // 0x42860
    if (*(char *)(v8 + 640) == 0) {
        // 0x42938
        str = (char *)0x6d746942;
        function_1ccec(3, (int32_t *)&str, 1);
        function_3aadc(1);
        // UNREACHABLE
    }
    // 0x42874
    if (g141 != 0) {
        *(char *)(v8 + 680) = 1;
        g141 = 0;
    }
    // .critedge
    int32_t v9; // bp-2068, 0x4278c
    int32_t v10 = function_42328(v8, &v9); // 0x4289c
    if (v9 == 0 || function_40da8(v10, v9) == 0) {
        // 0x428b0
        free((int32_t *)v10);
        return &g306;
    }
    char v11 = *(char *)&g70; // 0x428ec
    if ((v11 | *(char *)&g179) == 0 != g28 < (char *)3) {
        // 0x4290c
        snprintf((char *)&str, 2048, "%s: update job failed.", "bitmain_c5_update");
        function_1ccec(3, (int32_t *)&str, 0);
    }
    // 0x428b0
    free((int32_t *)v10);
    return &g306;
}

// Address range: 0x42980 - 0x42cb0
int32_t function_42980(int32_t a1) {
    // 0x42980
    pthread_detach(pthread_self());
    char * v1 = (char *)0x615f7463; // bp-540, 0x429c8
    int16_t v2 = 110; // bp-532, 0x429d0
    prctl(PR_SET_NAME, (int32_t)&v1, 110, (int32_t)&v2, 0x615f7463);
    int32_t attr; // bp-460, 0x42980
    pthread_attr_init(&attr);
    pthread_attr_setstacksize(&attr, 0x100000);
    int32_t sock = *(int32_t *)(a1 + 8); // 0x429f0
    int32_t buf = 0; // bp-424, 0x42a04
    int32_t v3; // bp-420, 0x42980
    memset(&v3, 0, 124);
    if (recv(sock, &buf, 128, 0) < 1) {
        // 0x42c2c
        return 0;
    }
    int32_t v4; // bp-292, 0x42980
    int32_t str4; // bp-296, 0x42980
    int32_t str2; // bp-524, 0x42980
    int32_t * mem; // 0x42acc
    while (true) {
      lab_0x42a28:
        // 0x42a28
        str2 = 0;
        int32_t str = 0; // bp-492, 0x42a48
        int32_t v5 = 0; // bp-548, 0x42a50
        sscanf((char *)&buf, "%x%s%s", &v5, &str, &str2);
        if (strcmp((char *)&str, "regist") == 0) {
            // 0x42ac4
            mem = calloc(152, 1);
            if (g164 == 0) {
                goto lab_0x42c38;
            } else {
                int32_t v6; // 0x42980
                int32_t str3; // 0x42980
                int32_t v7; // 0x42ad0
                while (strcmp((char *)&str2, (char *)str3) != 0) {
                    // 0x42ae8
                    int32_t v8; // 0x42980
                    int32_t v9 = v8 + 1; // 0x42ae8
                    v6 = v9;
                    int32_t v10; // 0x42980
                    str3 = v10 + 136;
                    if (v9 == v7) {
                        goto lab_0x42c38;
                    }
                    v10 = str3;
                    v8 = v6;
                }
                int32_t v11 = 136 * v6; // 0x42b18
                int32_t v12 = *(int32_t *)(v11 + (int32_t)&g169 + 132); // 0x42b20
                int32_t v13; // 0x42acc
                *(int32_t *)(v13 + 12) = *(int32_t *)(v11 + (int32_t)&g169);
                *(int32_t *)(v13 + 148) = v12;
                if (v7 == v6) {
                    goto lab_0x42c38;
                } else {
                    // 0x42b34
                    *mem = g53;
                    memcpy((int32_t *)(v13 + 16), &str2, strlen((char *)&str2) + 1);
                    int32_t * v14 = (int32_t *)(v13 + 144); // 0x42b78
                    *v14 = 0;
                    int32_t thread; // bp-544, 0x42980
                    pthread_create(&thread, &attr, (int32_t * (*)(int32_t *))&g13, mem);
                    if (*v14 == 0) {
                        usleep(0x2710);
                        while (*v14 == 0) {
                            // 0x42b8c
                            usleep(0x2710);
                        }
                    }
                    int32_t v15 = *mem; // 0x42ba0
                    str4 = 0;
                    if (v15 != g53) {
                        g53 = v15;
                    }
                    memset(&v4, 0, 252);
                    sprintf((char *)&str4, "%x %d %s %s %s", 63, v15, "reg_resp", "OK", &str2);
                    send(sock, &str4, strlen((char *)&str4) + 1, 0);
                    g53++;
                    goto lab_0x429f4;
                }
            }
        } else {
            // 0x42a9c
            memcpy((int32_t *)(128 * g163 + (int32_t)&g168), &buf, 128);
            g163++;
            goto lab_0x429f4;
        }
    }
  lab_0x42c2c:
    // 0x42c2c
    return 0;
  lab_0x42c38:
    // 0x42c38
    str4 = 0;
    memset(&v4, 0, 252);
    sprintf((char *)&str4, "%x %d %s %s %s", 63, 0, "reg_resp", "no_name", &str2);
    send(sock, &str4, strlen((char *)&str4) + 1, 0);
    free(mem);
    goto lab_0x429f4;
  lab_0x429f4:
    // 0x429f4
    buf = 0;
    memset(&v3, 0, 124);
    if (recv(sock, &buf, 128, 0) < 1) {
        // break -> 0x42c2c
        goto lab_0x42c2c;
    }
    goto lab_0x42a28;
}

// Address range: 0x42cb4 - 0x42f3c
int32_t function_42cb4(int32_t a1) {
    int32_t v1 = pthread_detach(pthread_self()); // 0x42ccc
    int32_t str = 0; // bp-600, 0x42ce0
    sprintf((char *)&str, "ct_a/fcb/%d", v1);
    int32_t v2; // 0x42cb4
    prctl(PR_SET_NAME, (int32_t)&str, v1, v2, (int32_t)&g306);
    int16_t addr = 2; // bp-584, 0x42d04
    inet_addr("127.0.0.1");
    int32_t sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP); // 0x42d20
    if (sock_fd < 0) {
        // 0x42f14
        perror("socket error");
        return 0;
    }
    int32_t option_value = 1; // bp-608, 0x42d38
    int32_t v3 = setsockopt(sock_fd, SO_DEBUG, 2, &option_value, 4); // 0x42d44
    if (v3 < 0) {
        // 0x42efc
        perror("set sockopt err");
        return 0;
    }
    // 0x42d5c
    __asm_rev16(v3);
    if (bind(sock_fd, (struct sockaddr *)&addr, 16) < 0) {
        perror("bind error");
        *(int32_t *)a1 = (int32_t)&g306 + 1;
        __asm_rev16((int32_t)&g306 + 1);
        // 0x42d80
        while (bind(sock_fd, (struct sockaddr *)&addr, 16) < 0) {
            // 0x42d80
            perror("bind error");
            *(int32_t *)a1 = (int32_t)&g306 + 1;
            __asm_rev16((int32_t)&g306 + 1);
        }
    }
    // 0x42d94
    if (listen(sock_fd, 5) < 0) {
        // 0x42ee4
        perror("listen error");
        // 0x42ef0
        return 0;
    }
    int32_t addr_len = 16; // bp-604, 0x42db4
    *(int32_t *)(a1 + 144) = 1;
    int32_t addr2; // bp-568, 0x42cb4
    int32_t accepted_sock_fd = accept(sock_fd, (struct sockaddr *)&addr2, &addr_len); // 0x42dc4
    if (accepted_sock_fd < 0) {
        // 0x42f2c
        perror("accept error");
        // 0x42ef0
        return 0;
    }
    int32_t str2 = 0; // bp-552, 0x42de0
    int32_t v4; // bp-548, 0x42cb4
    memset(&v4, 0, 252);
    char * v5 = (char *)(a1 + 16); // 0x42e04
    sprintf((char *)&str2, "%x %s\n", 63, v5);
    send(accepted_sock_fd, &str2, strlen((char *)&str2) + 1, 0);
    int32_t * length = (int32_t *)(a1 + 148); // 0x42e28
    int32_t size = *length; // 0x42e28
    int32_t * mem = malloc(size); // 0x42e40
    recv(accepted_sock_fd, mem, size, 0);
    int32_t v6 = 0; // 0x42e58
    while (true) {
        int32_t v7 = recv(accepted_sock_fd, mem, *length, 0); // 0x42e6c
        int32_t v8 = v7 < 1 ? 0 : v6; // 0x42e7c
        if (v7 > 0) {
            // 0x42e80
            v8 = *(int32_t *)(a1 + 12) == 0 ? 0 : (int32_t)mem;
        }
        // 0x42e94
        v6 = v8;
        int32_t str3 = 0; // bp-296, 0x42ea0
        int32_t v9; // bp-292, 0x42cb4
        memset(&v9, 0, 252);
        sprintf((char *)&str3, "%x %d %s %s", 63, v6, v5, "OK");
        send(accepted_sock_fd, &str3, strlen((char *)&str3) + 1, 0);
    }
}

// Address range: 0x42f3c - 0x4318c
int32_t function_42f3c(int32_t * a1, int32_t a2) {
    // 0x42f3c
    if (g165 != 0) {
        // 0x43164
        return -1;
    }
    // 0x42f58
    int32_t attr; // bp-828, 0x42f3c
    pthread_attr_init(&attr);
    pthread_attr_setstacksize(&attr, 0x100000);
    pthread_mutex_init(&g166, NULL);
    if (a2 != 0) {
        int32_t v1 = (int32_t)a1 + 4; // 0x42f8c
        int32_t v2 = (int32_t)&g170; // 0x42f94
        int32_t dest_mem = (int32_t)memcpy((int32_t *)v2, (int32_t *)v1, 128); // 0x42fa4
        int32_t v3 = v1 + 136; // 0x42fa8
        *(int32_t *)(dest_mem + 128) = *(int32_t *)(v1 + 128);
        *(int32_t *)(dest_mem - 4) = *(int32_t *)(v1 - 4);
        v2 = dest_mem + 136;
        while (v3 != v1 + 136 * a2) {
            int32_t v4 = v3;
            dest_mem = (int32_t)memcpy((int32_t *)v2, (int32_t *)v4, 128);
            v3 = v4 + 136;
            *(int32_t *)(dest_mem + 128) = *(int32_t *)(v4 + 128);
            *(int32_t *)(dest_mem - 4) = *(int32_t *)(v4 - 4);
            v2 = dest_mem + 136;
        }
    }
    // 0x42fcc
    g164 = a2;
    int16_t addr = 2; // bp-844, 0x42ff0
    inet_addr("127.0.0.1");
    int32_t sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP); // 0x43010
    if (sock_fd < 0) {
        // 0x43178
        perror("socket err:");
        // 0x43164
        return -4;
    }
    // 0x43034
    if (connect(sock_fd, (struct sockaddr *)&addr, 16) < 0) {
        perror("connect err:");
        sleep(1);
        while (connect(sock_fd, (struct sockaddr *)&addr, 16) < 0) {
            // 0x43028
            perror("connect err:");
            sleep(1);
        }
    }
    int32_t buf = 0; // bp-536, 0x43060
    int32_t v5; // bp-532, 0x42f3c
    memset(&v5, 0, 508);
    int32_t v6 = recv(sock_fd, &buf, 256, 0); // 0x43078
    int32_t v7; // bp-24, 0x42f3c
    int32_t v8 = &v7;
    if (v6 > 0) {
        *(char *)(v8 - 512 + v6) = 0;
    }
    int32_t buf2 = 0x636e7566; // bp-792, 0x4309c
    int32_t v9; // bp-768, 0x42f3c
    memset(&v9, 0, 232);
    send(sock_fd, &buf2, 24, 0);
    int32_t v10 = recv(sock_fd, &buf, 256, 0); // 0x430dc
    if (v10 > 0) {
        *(char *)(v8 - 512 + v10) = 0;
    }
    buf2 = 0x68206633;
    send(sock_fd, &buf2, 21, 0);
    g167 = sock_fd;
    int32_t * mem = malloc(12); // 0x43130
    *(int32_t *)((int32_t)mem + 8) = sock_fd;
    *mem = 0x560a;
    int32_t thread; // bp-848, 0x42f3c
    pthread_create(&thread, &attr, (int32_t * (*)(int32_t *))&g12, mem);
    g165 = 1;
    // 0x43164
    return 0;
}

// Address range: 0x43190 - 0x43438
int32_t function_43190(int32_t a1) {
    // 0x43190
    if (g165 == 0) {
        // 0x433f4
        return -1;
    }
    int32_t * mem = malloc(36); // 0x431bc
    pthread_mutex_init(mem, NULL);
    int32_t str = 0; // bp-800, 0x431dc
    int32_t v1; // bp-796, 0x43190
    memset(&v1, 0, 252);
    sprintf((char *)&str, "%x regist %s", 63, (char *)a1);
    send(g167, &str, strlen((char *)&str) + 1, 0);
    int32_t str2 = 0; // bp-1056, 0x43228
    int32_t v2; // bp-1052, 0x43190
    memset(&v2, 0, 124);
    usleep(1000);
    while (true) {
        // 0x4323c
        usleep(1000);
    }
    // 0x43250
    memcpy(&str2, (int32_t *)(128 * g163 + (int32_t)&g168), 128);
    int32_t v3 = 0; // bp-1176, 0x43298
    int32_t v4 = 0; // bp-1172, 0x4329c
    int32_t v5 = 0; // bp-1152, 0x432a0
    int32_t v6 = 0; // bp-1120, 0x432a8
    int32_t v7 = 0; // bp-1088, 0x432b0
    sscanf((char *)&str2, "%x%d%s%s%s", &v4, &v3, &v5, &v6, &v7);
    if (v3 == 0) {
        // 0x433f4
        return -4;
    }
    int16_t addr = 2; // bp-1168, 0x4331c
    inet_addr("127.0.0.1");
    __asm_rev16(v3);
    int32_t sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP); // 0x43350
    if (sock_fd < 0) {
        // 0x43424
        perror("socket err:");
        // 0x433f4
        return -4;
    }
    // 0x4335c
    if (connect(sock_fd, (struct sockaddr *)&addr, 16) < 0) {
        // 0x43410
        perror("connect err:");
        // 0x433f4
        return -3;
    }
    int32_t buf = 0; // bp-544, 0x4337c
    int32_t v8; // bp-540, 0x43190
    memset(&v8, 0, 508);
    int32_t v9 = recv(sock_fd, &buf, 512, 0); // 0x43394
    if (v9 > 0) {
        int32_t v10; // bp-40, 0x43190
        *(char *)((int32_t)&v10 - 504 + v9) = 0;
    }
    int32_t v11 = (int32_t)mem; // 0x431bc
    int32_t v12; // bp-924, 0x43190
    memset(&v12, 0, 124);
    int32_t buf2 = 0x214b4f; // bp-928, 0x433d8
    send(sock_fd, &buf2, 4, 0);
    *(int32_t *)(v11 + 32) = sock_fd;
    *(int32_t *)(a1 + 128) = v11;
    *(int32_t *)(v11 + 24) = v3;
    // 0x433f4
    return 0;
}

// Address range: 0x43438 - 0x43450
int32_t function_43438(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x43438
    return 0;
}

// Address range: 0x43450 - 0x4359c
int32_t function_43450(char * a1, int32_t buf, int32_t length, int32_t * a4) {
    // 0x43450
    if (g165 == 0) {
        // 0x4353c
        return -1;
    }
    int32_t v1 = *(int32_t *)((int32_t)a1 + 128); // 0x4346c
    if (v1 == 0) {
        // 0x4353c
        return -2;
    }
    int32_t * mutex = (int32_t *)v1; // 0x43488
    if (pthread_mutex_trylock(mutex) != 0) {
        // 0x4353c
        return -3;
    }
    int32_t * sock = (int32_t *)(v1 + 32); // 0x434a0
    if (send(*sock, (int32_t *)buf, length, 0) < 1) {
        // 0x4358c
        pthread_mutex_unlock(mutex);
        // 0x4353c
        return -4;
    }
    int32_t buf2 = 0; // bp-280, 0x434bc
    int32_t v2; // bp-276, 0x43450
    memset(&v2, 0, 252);
    int32_t v3 = recv(*sock, &buf2, 256, 0); // 0x434d4
    int32_t v4 = 0; // bp-352, 0x434dc
    int32_t v5 = 0; // bp-348, 0x434e0
    int32_t v6 = 0; // bp-344, 0x434e4
    int32_t v7 = 0; // bp-312, 0x434ec
    if (v3 > 0) {
        // 0x43548
        sscanf((char *)&buf2, "%x%d%s%s", &v4, &v5, &v6, &v7);
    }
    if (a4 != NULL) {
        *a4 = v5;
    }
    pthread_mutex_unlock(mutex);
    // 0x4353c
    return 0;
}

// Address range: 0x4359c - 0x435a4
int32_t function_4359c(void) {
    // 0x4359c
    return 0;
}

// Address range: 0x435a4 - 0x435b8
int32_t function_435a4(int32_t a1, int32_t a2, int32_t a3) {
    // 0x435a4
    return function_46aa0(a3, a1, a2);
}

// Address range: 0x435b8 - 0x435fc
int32_t function_435b8(int32_t a1, int32_t a2, uint32_t a3) {
    int32_t * v1 = (int32_t *)(a3 + 4); // 0x435c0
    int32_t v2 = *v1; // 0x435c0
    int32_t v3 = v2 + a2; // 0x435c4
    int32_t v4 = v3; // 0x435cc
    if (v3 >= a3 != v3 != a3) {
        // 0x435d0
        memcpy((int32_t *)(*(int32_t *)(a3 + 8) + v2), (int32_t *)a1, a2);
        v4 = *v1 + a2;
    }
    // 0x435f0
    *v1 = v4;
    return 0;
}

// Address range: 0x435fc - 0x43618
int32_t function_435fc(int32_t data, int32_t size, int32_t stream) {
    int32_t items_written = fwrite((int32_t *)data, size, 1, (struct _IO_FILE *)stream); // 0x43608
    return items_written == 1 ? items_written - 1 : -1;
}

// Address range: 0x43618 - 0x43640
int32_t function_43618(int32_t buf, int32_t nbyte, int32_t fd) {
    int32_t v1 = write(fd, (int32_t *)buf, nbyte); // 0x43630
    return v1 == nbyte ? nbyte - v1 : -1;
}

// Address range: 0x43640 - 0x4364c
int32_t function_43640(int32_t str, int32_t str2) {
    // 0x43640
    return strcmp((char *)str, (char *)str2);
}

// Address range: 0x4364c - 0x438d4
int32_t function_4364c(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x4364c
    return -1;
}

// Address range: 0x438d4 - 0x43984
int32_t function_438d4(uint32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x438d4
    if (a1 % 32 != 0) {
        // 0x4394c
        return -1;
    }
    // 0x4395c
    if (a3 == 0) {
        // 0x4394c
        return 0;
    }
    // 0x43964
    return (a1 & 32) == 0 ? (int32_t)&g23 : 0;
}

// Address range: 0x43984 - 0x439dc
int32_t function_43984(int32_t a1, int32_t a2, int32_t * str) {
    int32_t v1 = (int32_t)str;
    snprintf((char *)str, 11, "%p", (int32_t *)a2);
    if (function_44d00(a1, v1) != 0) {
        // 0x439d4
        return -1;
    }
    // 0x439bc
    return function_44a6c(a1, v1, function_47c18());
}

// Address range: 0x439dc - 0x441e8
int32_t function_439dc(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x439dc
    if (a1 == 0) {
        // 0x43a7c
        return -1;
    }
    int32_t v1 = a2 & -0x10001; // 0x439f8
    g300 = a1;
    int32_t str; // bp-140, 0x439dc
    int32_t v2; // 0x43ad0
    switch (a1) {
        case 7: {
            // 0x43a7c
            return (int32_t)"null";
        }
        case 1: {
            // 0x43ab0
            if (function_43984(a4, 1, &str) != 0) {
                // 0x43a7c
                return -1;
            }
            // 0x43acc
            v2 = function_47658(1);
            if ((a2 & 0x10000) == 0) {
                // 0x43a7c
                return -1;
            }
            // break -> 0x43ed0
            break;
        }
        case 2: {
            int32_t v3 = function_47820(2); // 0x43b3c
            return function_4364c(v3, function_4783c(2), a5, a6, v1);
        }
        case 3: {
            // 0x43b74
            function_47a7c(3);
            snprintf((char *)&str, 100, "%lld", 3);
            return &str;
        }
        case 4: {
            // 0x43bb8
            function_47b28(4);
            int32_t v4 = __asm_ubfx(v1, 11, 5); // 0x43bc4
            if (function_46ca8(&str, 100, v4) >= 0) {
                // 0x43bd8
                return &str;
            }
            // 0x43a7c
            return -1;
        }
        case 5: {
            // 0x43a7c
            return (int32_t)"true";
        }
        case 6: {
            // 0x43a7c
            return (int32_t)"false";
        }
        default: {
            // 0x43a7c
            return -1;
        }
    }
    if (v2 == 0) {
        // 0x43edc
        function_44d60(a4, &str);
        // 0x43a7c
        return 0;
    }
    int32_t v5 = a3 + 1; // 0x43dbc
    if (function_438d4(v1, v5, 0, a5, a6) != 0) {
        // 0x43a7c
        return -1;
    }
    int32_t v6 = function_47674(1, 0); // 0x43e14
    if (v2 == 1 != (function_439dc(v6, v1, v5, a4, a5, a6) == 0) || function_438d4(v1, a3, 0, a5, a6) != 0) {
        // 0x43a7c
        return -1;
    }
    // 0x43e94
    function_44d60(a4, &str);
    return 0;
}

// Address range: 0x441ec - 0x44264
int32_t function_441ec(int32_t a1, int32_t a2, int32_t * a3, int32_t a4) {
    // 0x441ec
    if (a1 != 1 && (a4 & 512) == 0) {
        // 0x44250
        return -1;
    }
    // 0x44210
    int32_t v1; // bp-52, 0x441ec
    int32_t v2 = function_449d8(&v1); // 0x44224
    int32_t result = -1; // 0x4422c
    if (v2 == 0) {
        // 0x44230
        result = function_439dc(a1, a4, 0, (int32_t)&v1, a2, (int32_t)a3);
        function_44a54(&v1);
    }
    // 0x44250
    return result;
}

// Address range: 0x44264 - 0x442d0
int32_t function_44264(int32_t a1, int32_t a2) {
    // 0x44264
    int32_t v1; // bp-28, 0x44264
    if (function_46a10(&v1) != 0) {
        // 0x442b0
        return 0;
    }
    int32_t v2 = function_441ec(a1, 0x435a4, &v1, a2); // 0x4429c
    int32_t result = 0; // 0x442a4
    if (v2 == 0) {
        int32_t v3 = function_46a84(&v1); // 0x442c0
        result = function_469b8(v3);
    }
    // 0x442a8
    function_46a44(&v1);
    // 0x442b0
    return result;
}

// Address range: 0x442d0 - 0x4430c
int32_t function_442d0(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = a3; // bp-20, 0x442e8
    int32_t v2; // 0x442d0
    function_441ec(a1, 0x435b8, &v1, v2);
    return 0;
}

// Address range: 0x4430c - 0x44320
int32_t function_4430c(int32_t a1, int32_t a2, int32_t a3) {
    // 0x4430c
    return function_441ec(a1, 0x435fc, (int32_t *)a2, a3);
}

// Address range: 0x44320 - 0x44384
int32_t function_44320(int32_t a1, int32_t a2, int32_t a3) {
    struct _IO_FILE * file = fopen64((char *)a2, "w"); // 0x4433c
    if (file != NULL) {
        int32_t result = function_441ec(a1, 0x435fc, &file->e0, a3); // 0x4435c
        if (fclose(file) == 0) {
            // 0x44374
            return result;
        }
    }
    // 0x44374
    return -1;
}

// Address range: 0x44384 - 0x443b0
int32_t function_44384(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = a2; // bp-12, 0x44394
    return function_441ec(a1, 0x43618, &v1, a3);
}

// Address range: 0x443b0 - 0x448f4
int32_t function_443b0(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = a2 - 0x21524111 + a3; // 0x443c4
    int32_t v2; // 0x443b0
    int32_t v3; // 0x443b0
    int32_t v4; // 0x443b0
    int32_t v5; // 0x443b0
    int32_t v6; // 0x443b0
    int32_t v7; // 0x443b0
    int32_t v8; // 0x443b0
    int32_t v9; // 0x443b0
    int32_t v10; // 0x443b0
    int32_t v11; // 0x443b0
    int32_t v12; // 0x443b0
    int32_t v13; // 0x443b0
    int32_t v14; // 0x443b0
    int32_t v15; // 0x443b0
    int32_t v16; // 0x443b0
    int32_t v17; // 0x443b0
    int32_t v18; // 0x443b0
    int32_t v19; // 0x443b0
    int32_t v20; // 0x443b0
    int32_t v21; // 0x443b0
    int32_t v22; // 0x443b0
    int32_t v23; // 0x443b0
    int32_t v24; // 0x443b0
    int32_t v25; // 0x443b0
    int32_t v26; // 0x443b0
    int32_t v27; // 0x443b0
    int32_t v28; // 0x443b0
    int32_t v29; // 0x443b0
    int32_t v30; // 0x443b0
    int32_t v31; // 0x443b0
    int32_t v32; // 0x443b0
    int32_t v33; // 0x443b0
    int32_t v34; // 0x443b0
    int32_t v35; // 0x443b0
    int32_t v36; // 0x443b0
    int32_t v37; // 0x443b0
    int32_t result; // 0x443b0
    int32_t v38; // 0x443b0
    int32_t v39; // 0x443b0
    int32_t v40; // 0x443b0
    int32_t v41; // 0x443b0
    int32_t v42; // 0x443b0
    int32_t v43; // 0x443b0
    int32_t v44; // 0x443b0
    int32_t v45; // 0x443b0
    int32_t v46; // 0x443b0
    if (a1 % 4 == 0) {
        // 0x443cc
        v18 = v1;
        v24 = a1;
        int32_t v47 = a2; // 0x443d0
        v38 = v1;
        v3 = v1;
        if (a2 != 12 && a2 >= 12) {
            int32_t v48 = a1 + 12;
            int32_t v49 = a2 - 12; // 0x443e4
            uint32_t v50 = *(int32_t *)(a1 + 8) + v1; // 0x443f8
            int32_t v51 = *(int32_t *)(a1 + 4) + v1; // 0x44408
            uint32_t v52 = v1 - v50 + *(int32_t *)a1 ^ (v50 / 0x10000000 | 16 * v50); // 0x4440c
            int32_t v53 = v51 + v50; // 0x44410
            int32_t v54 = v52 + v53; // 0x44418
            uint32_t v55 = (v52 / 0x4000000 | 64 * v52) ^ v51 - v52; // 0x4441c
            int32_t v56 = v55 + v54; // 0x44424
            uint32_t v57 = (v55 / 0x1000000 | 256 * v55) ^ v53 - v55; // 0x44428
            int32_t v58 = v57 + v56; // 0x44430
            uint32_t v59 = (v57 / 0x10000 | 0x10000 * v57) ^ v54 - v57; // 0x44434
            int32_t v60 = v59 + v58; // 0x4443c
            uint32_t v61 = (v59 / 0x2000 | 0x80000 * v59) ^ v56 - v59; // 0x44440
            int32_t v62 = v61 + v60; // 0x44448
            int32_t v63 = (v61 / 0x10000000 | 16 * v61) ^ v58 - v61; // 0x4444c
            int32_t v64 = v49; // 0x44450
            int32_t v65 = v48; // 0x44450
            v18 = v62;
            v24 = v48;
            v47 = v49;
            v38 = v63;
            v3 = v60;
            while ((v61 & 0x8000000) != 0 == (v49 != 12)) {
                // 0x443e0
                v48 = v65 + 12;
                v49 = v64 - 12;
                v50 = *(int32_t *)(v65 + 8) + v63;
                v51 = *(int32_t *)(v65 + 4) + v62;
                v52 = v60 - v50 + *(int32_t *)v65 ^ (v50 / 0x10000000 | 16 * v50);
                v53 = v51 + v50;
                v54 = v52 + v53;
                v55 = (v52 / 0x4000000 | 64 * v52) ^ v51 - v52;
                v56 = v55 + v54;
                v57 = (v55 / 0x1000000 | 256 * v55) ^ v53 - v55;
                v58 = v57 + v56;
                v59 = (v57 / 0x10000 | 0x10000 * v57) ^ v54 - v57;
                v60 = v59 + v58;
                v61 = (v59 / 0x2000 | 0x80000 * v59) ^ v56 - v59;
                v62 = v61 + v60;
                v63 = (v61 / 0x10000000 | 16 * v61) ^ v58 - v61;
                v64 = v49;
                v65 = v48;
                v18 = v62;
                v24 = v48;
                v47 = v49;
                v38 = v63;
                v3 = v60;
            }
        }
        // 0x44454
        g314 = v47 - 1;
        v13 = v18;
        v27 = v24;
        v36 = v38;
        v8 = v3;
        result = v38;
        v15 = v18;
        v28 = v24;
        v39 = v38;
        v2 = v3;
        switch (v47) {
            case 1: {
                goto lab_0x446f8;
            }
            case 2: {
                goto lab_0x44754;
            }
            case 3: {
                // 0x447fc
                v14 = v18;
                v37 = v38;
                v9 = *(int32_t *)v24 % 0x1000000 + v3;
                goto lab_0x44700;
            }
            case 4: {
                // 0x44760
                v14 = v18;
                v37 = v38;
                v9 = *(int32_t *)v24 + v3;
                goto lab_0x44700;
            }
            case 5: {
                // 0x447ac
                v14 = v18 + (int32_t)*(char *)(v24 + 4);
                v37 = v38;
                v9 = *(int32_t *)v24 + v3;
                goto lab_0x44700;
            }
            case 6: {
                // 0x447c0
                v14 = v18 + (int32_t)*(int16_t *)(v24 + 4);
                v37 = v38;
                v9 = *(int32_t *)v24 + v3;
                goto lab_0x44700;
            }
            case 7: {
                // 0x447d4
                v14 = *(int32_t *)(v24 + 4) % 0x1000000 + v18;
                v37 = v38;
                v9 = *(int32_t *)v24 + v3;
                goto lab_0x44700;
            }
            case 8: {
                // 0x447e8
                v14 = *(int32_t *)(v24 + 4) + v18;
                v37 = v38;
                v9 = *(int32_t *)v24 + v3;
                goto lab_0x44700;
            }
            case 9: {
                // 0x4476c
                v46 = (int32_t)*(char *)(v24 + 8);
                goto lab_0x44770;
            }
            case 10: {
                // 0x44788
                v46 = (int32_t)*(int16_t *)(v24 + 8);
                goto lab_0x44770;
            }
            case 11: {
                // 0x44790
                v14 = *(int32_t *)(v24 + 4) + v18;
                v37 = *(int32_t *)(v24 + 8) % 0x1000000 + v38;
                v9 = *(int32_t *)v24 + v3;
                goto lab_0x44700;
            }
            case 12: {
                // 0x448b8
                v46 = *(int32_t *)(v24 + 8);
                goto lab_0x44770;
            }
            default: {
                return result;
            }
        }
    } else {
        bool v66 = a2 == 12 | a2 < 12;
        if (a1 % 2 == 0) {
            // 0x4449c
            v19 = v1;
            v25 = a1;
            int32_t v67 = a2; // 0x444a0
            v42 = v1;
            v4 = v1;
            if (!v66) {
                int32_t v68 = a1 + 12;
                int32_t v69 = a2 - 12; // 0x444b4
                uint16_t v70 = *(int16_t *)(a1 + 8); // 0x444b8
                uint16_t v71 = *(int16_t *)(a1 + 2); // 0x444c0
                uint16_t v72 = *(int16_t *)a1; // 0x444c8
                uint32_t v73 = (0x10000 * (int32_t)*(int16_t *)(a1 + 10) | (int32_t)v70) + v1; // 0x444d8
                uint16_t v74 = *(int16_t *)(a1 + 4); // 0x444dc
                uint32_t v75 = v1 - v73 + (0x10000 * (int32_t)v71 | (int32_t)v72) ^ (v73 / 0x10000000 | 16 * v73); // 0x444f0
                int32_t v76 = (0x10000 * (int32_t)*(int16_t *)(a1 + 6) | (int32_t)v74) + v1; // 0x444f4
                int32_t v77 = v76 + v73; // 0x444fc
                uint32_t v78 = (v75 / 0x4000000 | 64 * v75) ^ v76 - v75; // 0x44500
                int32_t v79 = v77 + v75; // 0x44504
                int32_t v80 = v78 + v79; // 0x4450c
                uint32_t v81 = (v78 / 0x1000000 | 256 * v78) ^ v77 - v78; // 0x44510
                int32_t v82 = v81 + v80; // 0x44518
                uint32_t v83 = (v81 / 0x10000 | 0x10000 * v81) ^ v79 - v81; // 0x4451c
                int32_t v84 = v83 + v82; // 0x44524
                uint32_t v85 = (v83 / 0x2000 | 0x80000 * v83) ^ v80 - v83; // 0x44528
                int32_t v86 = v85 + v84; // 0x44530
                int32_t v87 = (v85 / 0x10000000 | 16 * v85) ^ v82 - v85; // 0x44534
                int32_t v88 = v69; // 0x44538
                int32_t v89 = v68; // 0x44538
                v19 = v86;
                v25 = v68;
                v67 = v69;
                v42 = v87;
                v4 = v84;
                while ((v85 & 0x8000000) != 0 == (v69 != 12)) {
                    // 0x444b0
                    v68 = v89 + 12;
                    uint16_t v90 = *(int16_t *)(v89 + 10); // 0x444b0
                    v69 = v88 - 12;
                    v70 = *(int16_t *)(v89 + 8);
                    v71 = *(int16_t *)(v89 + 2);
                    v72 = *(int16_t *)v89;
                    uint16_t v91 = *(int16_t *)(v89 + 6); // 0x444d4
                    v73 = (0x10000 * (int32_t)v90 | (int32_t)v70) + v87;
                    v74 = *(int16_t *)(v89 + 4);
                    v75 = v84 - v73 + (0x10000 * (int32_t)v71 | (int32_t)v72) ^ (v73 / 0x10000000 | 16 * v73);
                    v76 = (0x10000 * (int32_t)v91 | (int32_t)v74) + v86;
                    v77 = v76 + v73;
                    v78 = (v75 / 0x4000000 | 64 * v75) ^ v76 - v75;
                    v79 = v77 + v75;
                    v80 = v78 + v79;
                    v81 = (v78 / 0x1000000 | 256 * v78) ^ v77 - v78;
                    v82 = v81 + v80;
                    v83 = (v81 / 0x10000 | 0x10000 * v81) ^ v79 - v81;
                    v84 = v83 + v82;
                    v85 = (v83 / 0x2000 | 0x80000 * v83) ^ v80 - v83;
                    v86 = v85 + v84;
                    v87 = (v85 / 0x10000000 | 16 * v85) ^ v82 - v85;
                    v88 = v69;
                    v89 = v68;
                    v19 = v86;
                    v25 = v68;
                    v67 = v69;
                    v42 = v87;
                    v4 = v84;
                }
            }
            // 0x4453c
            g297 = v67 - 1;
            v13 = v19;
            v27 = v25;
            v36 = v42;
            v8 = v4;
            result = v42;
            v15 = v19;
            v28 = v25;
            v39 = v42;
            v2 = v4;
            v16 = v19;
            v40 = v42;
            v41 = v42;
            v17 = v19;
            switch (v67) {
                case 1: {
                    goto lab_0x446f8;
                }
                case 2: {
                    goto lab_0x44754;
                }
                case 3: {
                    // 0x4474c
                    v15 = v19;
                    v28 = v25;
                    v39 = v42;
                    v2 = 0x10000 * (int32_t)*(char *)(v25 + 2) + v4;
                    goto lab_0x44754;
                }
                case 4: {
                    goto lab_0x44898;
                }
                case 5: {
                    // 0x44890
                    v17 = v19 + (int32_t)*(char *)(v25 + 4);
                    goto lab_0x44898;
                }
                case 6: {
                    goto lab_0x44814;
                }
                case 7: {
                    // 0x4480c
                    v16 = 0x10000 * (int32_t)*(char *)(v25 + 6) + v19;
                    goto lab_0x44814;
                }
                case 8: {
                    goto lab_0x44838;
                }
                case 9: {
                    // 0x44830
                    v40 = v42 + (int32_t)*(char *)(v25 + 8);
                    goto lab_0x44838;
                }
                case 10: {
                    goto lab_0x44864;
                }
                case 11: {
                    // 0x4485c
                    v41 = 0x10000 * (int32_t)*(char *)(v25 + 10) + v42;
                    goto lab_0x44864;
                }
                case 12: {
                    uint16_t v92 = *(int16_t *)(v25 + 8); // 0x448c0
                    uint16_t v93 = *(int16_t *)(v25 + 10); // 0x448c4
                    uint16_t v94 = *(int16_t *)(v25 + 4); // 0x448c8
                    uint16_t v95 = *(int16_t *)(v25 + 6); // 0x448d0
                    uint16_t v96 = *(int16_t *)v25; // 0x448d4
                    uint16_t v97 = *(int16_t *)(v25 + 2); // 0x448d8
                    v14 = v19 + (int32_t)v94 + 0x10000 * (int32_t)v95;
                    v37 = v42 + (int32_t)v92 + 0x10000 * (int32_t)v93;
                    v9 = v4 + (int32_t)v96 + 0x10000 * (int32_t)v97;
                    goto lab_0x44700;
                }
                default: {
                    return result;
                }
            }
        } else {
            // 0x4457c
            v20 = v1;
            v26 = a1;
            int32_t v98 = a2; // 0x44588
            int32_t v99 = v1; // 0x44588
            v5 = v1;
            if (!v66) {
                int32_t v100 = a1 + 12;
                unsigned char v101 = *(char *)(a1 + 10); // 0x44598
                int32_t v102 = a2 - 12; // 0x4459c
                unsigned char v103 = *(char *)(a1 + 2); // 0x445a0
                unsigned char v104 = *(char *)(a1 + 9); // 0x445a8
                unsigned char v105 = *(char *)(a1 + 1); // 0x445b0
                unsigned char v106 = *(char *)(a1 + 6); // 0x445bc
                unsigned char v107 = *(char *)a1; // 0x445c4
                unsigned char v108 = *(char *)(a1 + 8); // 0x445cc
                unsigned char v109 = *(char *)(a1 + 11); // 0x445d4
                unsigned char v110 = *(char *)(a1 + 3); // 0x445e0
                unsigned char v111 = *(char *)(a1 + 5); // 0x445ec
                uint32_t v112 = (256 * (int32_t)v104 | 0x10000 * (int32_t)v101 | (int32_t)v108 | 0x1000000 * (int32_t)v109) + v1; // 0x445f0
                unsigned char v113 = *(char *)(a1 + 7); // 0x445f8
                unsigned char v114 = *(char *)(a1 + 4); // 0x445fc
                uint32_t v115 = v1 - v112 + (256 * (int32_t)v105 | 0x10000 * (int32_t)v103 | (int32_t)v107 | 0x1000000 * (int32_t)v110) ^ (v112 / 0x10000000 | 16 * v112); // 0x44610
                int32_t v116 = (256 * (int32_t)v111 | 0x10000 * (int32_t)v106 | (int32_t)v114 | 0x1000000 * (int32_t)v113) + v1; // 0x44618
                int32_t v117 = v116 + v112; // 0x44620
                uint32_t v118 = v116 - v115 ^ (v115 / 0x4000000 | 64 * v115); // 0x44624
                int32_t v119 = v117 + v115; // 0x44628
                int32_t v120 = v118 + v119; // 0x44630
                uint32_t v121 = (v118 / 0x1000000 | 256 * v118) ^ v117 - v118; // 0x44634
                int32_t v122 = v121 + v120; // 0x4463c
                uint32_t v123 = (v121 / 0x10000 | 0x10000 * v121) ^ v119 - v121; // 0x44640
                int32_t v124 = v123 + v122; // 0x44648
                uint32_t v125 = (v123 / 0x2000 | 0x80000 * v123) ^ v120 - v123; // 0x4464c
                int32_t v126 = v125 + v124; // 0x44654
                int32_t v127 = (v125 / 0x10000000 | 16 * v125) ^ v122 - v125; // 0x44658
                int32_t v128 = v102; // 0x4465c
                int32_t v129 = v100; // 0x4465c
                v20 = v126;
                v26 = v100;
                v98 = v102;
                v99 = v127;
                v5 = v124;
                while ((v125 & 0x8000000) != 0 == (v102 != 12)) {
                    // 0x44598
                    v100 = v129 + 12;
                    v101 = *(char *)(v129 + 10);
                    v102 = v128 - 12;
                    v103 = *(char *)(v129 + 2);
                    v104 = *(char *)(v129 + 9);
                    v105 = *(char *)(v129 + 1);
                    v106 = *(char *)(v129 + 6);
                    v107 = *(char *)v129;
                    v108 = *(char *)(v129 + 8);
                    v109 = *(char *)(v129 + 11);
                    v110 = *(char *)(v129 + 3);
                    v111 = *(char *)(v129 + 5);
                    v112 = (256 * (int32_t)v104 | 0x10000 * (int32_t)v101 | (int32_t)v108 | 0x1000000 * (int32_t)v109) + v127;
                    v113 = *(char *)(v129 + 7);
                    v114 = *(char *)(v129 + 4);
                    v115 = v124 - v112 + (256 * (int32_t)v105 | 0x10000 * (int32_t)v103 | (int32_t)v107 | 0x1000000 * (int32_t)v110) ^ (v112 / 0x10000000 | 16 * v112);
                    v116 = (256 * (int32_t)v111 | 0x10000 * (int32_t)v106 | (int32_t)v114 | 0x1000000 * (int32_t)v113) + v126;
                    v117 = v116 + v112;
                    v118 = v116 - v115 ^ (v115 / 0x4000000 | 64 * v115);
                    v119 = v117 + v115;
                    v120 = v118 + v119;
                    v121 = (v118 / 0x1000000 | 256 * v118) ^ v117 - v118;
                    v122 = v121 + v120;
                    v123 = (v121 / 0x10000 | 0x10000 * v121) ^ v119 - v121;
                    v124 = v123 + v122;
                    v125 = (v123 / 0x2000 | 0x80000 * v123) ^ v120 - v123;
                    v126 = v125 + v124;
                    v127 = (v125 / 0x10000000 | 16 * v125) ^ v122 - v125;
                    v128 = v102;
                    v129 = v100;
                    v20 = v126;
                    v26 = v100;
                    v98 = v102;
                    v99 = v127;
                    v5 = v124;
                }
            }
            // 0x44660
            g298 = v98 - 1;
            v43 = v99;
            v44 = v99;
            v45 = v99;
            v29 = v99;
            v21 = v20;
            v30 = v99;
            v22 = v20;
            v31 = v99;
            v23 = v20;
            v32 = v99;
            v10 = v20;
            v33 = v99;
            v11 = v20;
            v34 = v99;
            v6 = v5;
            v12 = v20;
            v35 = v99;
            v7 = v5;
            v13 = v20;
            v27 = v26;
            v36 = v99;
            v8 = v5;
            result = v99;
            switch (v98) {
                case 1: {
                    goto lab_0x446f8;
                }
                case 2: {
                    goto lab_0x446f0;
                }
                case 3: {
                    goto lab_0x446e8;
                }
                case 4: {
                    goto lab_0x446e0;
                }
                case 5: {
                    goto lab_0x446d8;
                }
                case 6: {
                    goto lab_0x446d0;
                }
                case 7: {
                    goto lab_0x446c8;
                }
                case 8: {
                    goto lab_0x446c0;
                }
                case 9: {
                    goto lab_0x446b8;
                }
                case 10: {
                    goto lab_0x446b0;
                }
                case 11: {
                    goto lab_0x446a8;
                }
                case 12: {
                    // 0x446a0
                    v43 = 0x1000000 * (int32_t)*(char *)(v26 + 11) + v99;
                    goto lab_0x446a8;
                }
                default: {
                    return result;
                }
            }
        }
    }
  lab_0x446f8:
    // 0x446f8
    v14 = v13;
    v37 = v36;
    v9 = v8 + (int32_t)*(char *)v27;
    goto lab_0x44700;
  lab_0x44754:
    // 0x44754
    v14 = v15;
    v37 = v39;
    v9 = v2 + (int32_t)*(int16_t *)v28;
    goto lab_0x44700;
  lab_0x44700:;
    uint32_t v130 = v14;
    uint32_t v131 = (v37 ^ v130) - (v130 / 0x40000 | 0x4000 * v130); // 0x44704
    uint32_t v132 = (v131 ^ v9) - (v131 / 0x200000 | 2048 * v131); // 0x4470c
    uint32_t v133 = (v132 ^ v130) - (v132 / 128 | 0x2000000 * v132); // 0x44714
    uint32_t v134 = (v133 ^ v131) - (v133 / 0x10000 | 0x10000 * v133); // 0x4471c
    uint32_t v135 = (v134 ^ v132) - (v134 / 0x10000000 | 16 * v134); // 0x44724
    uint32_t v136 = (v135 ^ v133) - (v135 / 0x40000 | 0x4000 * v135); // 0x4472c
    result = (v136 ^ v134) - (v136 / 256 | 0x1000000 * v136);
    // 0x44738
    return result;
  lab_0x44770:
    // 0x44770
    v14 = *(int32_t *)(v24 + 4) + v18;
    v37 = v46 + v38;
    v9 = *(int32_t *)v24 + v3;
    goto lab_0x44700;
  lab_0x44898:;
    uint16_t v137 = *(int16_t *)v25; // 0x44898
    uint16_t v138 = *(int16_t *)(v25 + 2); // 0x4489c
    v14 = v17;
    v37 = v42;
    v9 = v4 + (int32_t)v137 + 0x10000 * (int32_t)v138;
    goto lab_0x44700;
  lab_0x44814:;
    uint16_t v139 = *(int16_t *)v25; // 0x44814
    uint16_t v140 = *(int16_t *)(v25 + 2); // 0x44818
    v14 = v16 + (int32_t)*(int16_t *)(v25 + 4);
    v37 = v42;
    v9 = v4 + (int32_t)v139 + 0x10000 * (int32_t)v140;
    goto lab_0x44700;
  lab_0x44838:;
    uint16_t v141 = *(int16_t *)(v25 + 4); // 0x44838
    uint16_t v142 = *(int16_t *)(v25 + 6); // 0x4483c
    uint16_t v143 = *(int16_t *)v25; // 0x44840
    uint16_t v144 = *(int16_t *)(v25 + 2); // 0x44844
    v14 = v19 + (int32_t)v141 + 0x10000 * (int32_t)v142;
    v37 = v40;
    v9 = v4 + (int32_t)v143 + 0x10000 * (int32_t)v144;
    goto lab_0x44700;
  lab_0x44864:;
    uint16_t v145 = *(int16_t *)(v25 + 4); // 0x44864
    uint16_t v146 = *(int16_t *)(v25 + 6); // 0x44868
    uint16_t v147 = *(int16_t *)v25; // 0x4486c
    uint16_t v148 = *(int16_t *)(v25 + 2); // 0x44870
    v14 = v19 + (int32_t)v145 + 0x10000 * (int32_t)v146;
    v37 = v41 + (int32_t)*(int16_t *)(v25 + 8);
    v9 = v4 + (int32_t)v147 + 0x10000 * (int32_t)v148;
    goto lab_0x44700;
  lab_0x446f0:
    // 0x446f0
    v13 = v12;
    v27 = v26;
    v36 = v35;
    v8 = 256 * (int32_t)*(char *)(v26 + 1) + v7;
    goto lab_0x446f8;
  lab_0x446e8:
    // 0x446e8
    v12 = v11;
    v35 = v34;
    v7 = 0x10000 * (int32_t)*(char *)(v26 + 2) + v6;
    goto lab_0x446f0;
  lab_0x446e0:
    // 0x446e0
    v11 = v10;
    v34 = v33;
    v6 = 0x1000000 * (int32_t)*(char *)(v26 + 3) + v5;
    goto lab_0x446e8;
  lab_0x446d8:
    // 0x446d8
    v10 = v23 + (int32_t)*(char *)(v26 + 4);
    v33 = v32;
    goto lab_0x446e0;
  lab_0x446d0:
    // 0x446d0
    v23 = 256 * (int32_t)*(char *)(v26 + 5) + v22;
    v32 = v31;
    goto lab_0x446d8;
  lab_0x446c8:
    // 0x446c8
    v22 = 0x10000 * (int32_t)*(char *)(v26 + 6) + v21;
    v31 = v30;
    goto lab_0x446d0;
  lab_0x446c0:
    // 0x446c0
    v21 = 0x1000000 * (int32_t)*(char *)(v26 + 7) + v20;
    v30 = v29;
    goto lab_0x446c8;
  lab_0x446b8:
    // 0x446b8
    v29 = v45 + (int32_t)*(char *)(v26 + 8);
    goto lab_0x446c0;
  lab_0x446b0:
    // 0x446b0
    v45 = 256 * (int32_t)*(char *)(v26 + 9) + v44;
    goto lab_0x446b8;
  lab_0x446a8:
    // 0x446a8
    v44 = 0x10000 * (int32_t)*(char *)(v26 + 10) + v43;
    goto lab_0x446b0;
}

// Address range: 0x448f4 - 0x44968
int32_t function_448f4(int32_t a1, int32_t a2, int32_t str, int32_t a4) {
    int32_t * v1 = (int32_t *)(a2 + 4);
    if (a1 + 12 == a2) {
        // 0x44950
        if (*v1 == a2) {
            // 0x44948
            return 0;
        }
    }
    int32_t v2 = a2;
    if (*(int32_t *)(v2 + 16) == a4) {
        // 0x44934
        if (strcmp((char *)(v2 + 24), (char *)str) == 0) {
            // break -> 0x44948
            break;
        }
    }
    int32_t result = 0; // 0x44920
    while (*v1 != v2) {
        // 0x44924
        v2 += 4;
        if (*(int32_t *)(v2 + 16) == a4) {
            int32_t strcmp_rc = strcmp((char *)(v2 + 24), (char *)str); // 0x4493c
            result = v2;
            if (strcmp_rc == 0) {
                // break -> 0x44948
                break;
            }
        }
        // 0x44918
        result = 0;
    }
    // 0x44948
    return result;
}

// Address range: 0x44968 - 0x449d8
int32_t function_44968(int32_t result) {
    int32_t v1 = result + 12; // 0x4496c
    int32_t v2 = *(int32_t *)(result + 16); // 0x44970
    if (v2 == v1) {
        // 0x449d4
        return result;
    }
    int32_t v3 = *(int32_t *)(v2 + 20); // 0x4497c
    int32_t v4 = *(int32_t *)(v2 + 4); // 0x44980
    int32_t v5; // 0x44968
    int32_t v6 = v5; // 0x44988
    int32_t v7; // 0x44968
    int32_t v8; // 0x449a4
    int32_t v9; // 0x4498c
    int32_t * v10; // 0x4498c
    int32_t v11; // 0x4498c
    int32_t v12; // 0x4499c
    if (v3 != 0) {
        // 0x4498c
        v9 = v3 + 4;
        v10 = (int32_t *)v9;
        v11 = *v10;
        v6 = v5;
        if (v11 != -1) {
            // 0x4499c
            v12 = __asm_dmb(v3, v5, v11, v9);
            v7 = *v10;
            v8 = v7 - 1;
            while (__asm_strex(v8, v7) != 0) {
                // 0x449a0
                v7 = *v10;
                v8 = v7 - 1;
            }
            // 0x449b4
            v6 = 0;
            if (v8 == 0) {
                // 0x449bc
                function_47c24(v12);
                v6 = 0;
            }
        }
    }
    int32_t result2 = function_46954(v2); // 0x449d0
    while (v4 != v1) {
        int32_t v13 = v4;
        int32_t v14 = v6;
        v3 = *(int32_t *)(v13 + 20);
        v4 = *(int32_t *)(v13 + 4);
        v6 = v14;
        if (v3 != 0) {
            // 0x4498c
            v9 = v3 + 4;
            v10 = (int32_t *)v9;
            v11 = *v10;
            v6 = v14;
            if (v11 != -1) {
                // 0x4499c
                v12 = __asm_dmb(v3, v14, v11, v9);
                v7 = *v10;
                v8 = v7 - 1;
                while (__asm_strex(v8, v7) != 0) {
                    // 0x449a0
                    v7 = *v10;
                    v8 = v7 - 1;
                }
                // 0x449b4
                v6 = 0;
                if (v8 == 0) {
                    // 0x449bc
                    function_47c24(v12);
                    v6 = 0;
                }
            }
        }
        // 0x449c0
        result2 = function_46954(v13);
    }
    // 0x449d4
    return result2;
}

// Address range: 0x449d8 - 0x44a54
int32_t function_449d8(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    *a1 = 0;
    int32_t * v2 = (int32_t *)(v1 + 8); // 0x449ec
    *v2 = 3;
    int32_t v3 = function_4693c(64); // 0x449f4
    *(int32_t *)(v1 + 4) = v3;
    if (v3 == 0) {
        // 0x44a44
        return -1;
    }
    int32_t v4 = v1 + 12; // 0x44a0c
    int32_t v5 = v1 + 20; // 0x44a10
    *(int32_t *)(v1 + 16) = v4;
    *(int32_t *)v4 = v4;
    *(int32_t *)(v1 + 24) = v5;
    *(int32_t *)v5 = v5;
    int32_t v6 = v3; // 0x44a30
    *(int32_t *)(v6 + 4) = v4;
    *(int32_t *)v6 = v4;
    v6 += 8;
    while (v6 != (8 << *v2) + v3) {
        // 0x44a34
        *(int32_t *)(v6 + 4) = v4;
        *(int32_t *)v6 = v4;
        v6 += 8;
    }
    // 0x44a44
    return 0;
}

// Address range: 0x44a54 - 0x44a6c
int32_t function_44a54(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    function_44968(v1);
    return function_46954(*(int32_t *)(v1 + 4));
}

// Address range: 0x44a6c - 0x44d00
int32_t function_44a6c(uint32_t a1, int32_t a2, int32_t a3) {
    int32_t * v1 = (int32_t *)(a1 + 8); // 0x44a74
    uint32_t v2 = *v1; // 0x44a74
    int32_t v3; // 0x44a6c
    int32_t v4; // 0x44a6c
    int32_t v5; // 0x44a6c
    int32_t v6; // 0x44a6c
    int32_t v7; // 0x44ac0
    int32_t * v8; // 0x44b2c
    int32_t v9; // 0x44b2c
    int32_t * v10; // 0x44b34
    int32_t v11; // 0x44b34
    if (a1 >> v2 == 0) {
        // 0x44b90
        v5 = *(int32_t *)(a1 + 4);
        v6 = -1 - (-1 << v2);
    } else {
        uint32_t v12 = v2 + 1; // 0x44a8c
        int32_t v13 = 8 << v12; // 0x44a94
        int32_t v14 = function_4693c(v13); // 0x44aa4
        if (v14 == 0) {
            // 0x44cf8
            return -1;
        }
        int32_t * v15 = (int32_t *)(a1 + 4); // 0x44ab0
        function_46954(*v15);
        *v15 = v14;
        *v1 = v12;
        v7 = a1 + 12;
        int32_t v16 = v14; // 0x44acc
        *(int32_t *)(v16 + 4) = v7;
        *(int32_t *)v16 = v7;
        v16 += 8;
        while (v14 + v13 != v16) {
            // 0x44ad0
            *(int32_t *)(v16 + 4) = v7;
            *(int32_t *)v16 = v7;
            v16 += 8;
        }
        int32_t * v17 = (int32_t *)(a1 + 16); // 0x44ae0
        int32_t v18 = *v17; // 0x44ae0
        int32_t * v19 = (int32_t *)v7; // 0x44ae8
        *v19 = v7;
        int32_t v20 = -1 - (-1 << v12); // 0x44aec
        *v17 = v7;
        v3 = v18;
        v5 = v14;
        v6 = v20;
        if (v18 != v7) {
            while (true) {
              lab_0x44b28_2:
                // 0x44b28
                v4 = v3;
                v8 = (int32_t *)(v4 + 4);
                v9 = *v8;
                int32_t v21 = 8 * (*(int32_t *)(v4 + 16) & v20) + v14; // 0x44b34
                v10 = (int32_t *)v21;
                v11 = *v10;
                if (v11 == v7) {
                    int32_t * v22 = (int32_t *)(v21 + 4); // 0x44b44
                    if (v7 == *v22) {
                        // 0x44b50
                        *v8 = v7;
                        *(int32_t *)v4 = *v19;
                        *(int32_t *)(*v19 + 4) = v4;
                        *v19 = v4;
                        *v22 = v4;
                        *v10 = v4;
                        if (v9 == v7) {
                            // break -> 0x44b7c
                            break;
                        }
                        // 0x44b28
                        v3 = v9;
                        goto lab_0x44b28_2;
                    } else {
                        goto lab_0x44b00;
                    }
                } else {
                    goto lab_0x44b00;
                }
            }
          lab_0x44b7c:
            // 0x44b7c
            v5 = *v15;
            v6 = -1 - (-1 << *v1);
        }
    }
    char * str = (char *)a2; // 0x44ba0
    int32_t len = strlen(str); // 0x44ba0
    int32_t v23 = function_443b0(a2, len, g172); // 0x44bbc
    int32_t v24 = 8 * (v23 & v6) + v5; // 0x44bd0
    int32_t v25 = function_448f4(a1, v24, a2, v23); // 0x44bdc
    if (v25 != 0) {
        int32_t * v26 = (int32_t *)(v25 + 20); // 0x44be8
        int32_t v27 = *v26; // 0x44be8
        if (v27 == 0) {
            // 0x44c24
            *v26 = a3;
            return 0;
        }
        int32_t v28 = v27 + 4; // 0x44bf4
        int32_t * v29 = (int32_t *)v28; // 0x44bf4
        if (*v29 == -1) {
            // 0x44c24
            *v26 = a3;
            return 0;
        }
        int32_t v30 = __asm_dmb(v27, v24, a2, v28); // 0x44c04
        int32_t v31 = *v29;
        int32_t v32 = v31 - 1; // 0x44c0c
        while (__asm_strex(v32, v31) != 0) {
            // 0x44c08
            v31 = *v29;
            v32 = v31 - 1;
        }
        if (v32 == 0) {
            // 0x44c30
            function_47c24(v30);
        }
        // 0x44c24
        *v26 = a3;
        return 0;
    }
    int32_t v33 = function_4693c(len + 25); // 0x44c3c
    if (v33 == 0) {
        // 0x44cf8
        return -1;
    }
    // 0x44c48
    *(int32_t *)(v33 + 16) = v23;
    char * dest_str = strncpy((char *)(v33 + 24), str, len + 1); // 0x44c58
    int32_t * v34 = (int32_t *)v24; // 0x44c5c
    int32_t v35 = *v34; // 0x44c5c
    int32_t v36 = a1 + 12; // 0x44c60
    int32_t v37 = v33 + 8; // 0x44c64
    *(int32_t *)(v33 + 20) = a3;
    int32_t * v38 = (int32_t *)(v33 + 4); // 0x44c6c
    *v38 = v33;
    int32_t * v39 = (int32_t *)v33; // 0x44c74
    *v39 = v33;
    int32_t * v40 = (int32_t *)(v33 + 12); // 0x44c78
    *v40 = v37;
    int32_t * v41 = (int32_t *)v37; // 0x44c7c
    *v41 = v37;
    if (v35 == v36) {
        int32_t * v42 = (int32_t *)(v24 + 4); // 0x44ccc
        if (v36 == *v42) {
            int32_t * v43 = (int32_t *)v36; // 0x44cd8
            *v39 = *v43;
            *v38 = v36;
            *(int32_t *)(*v43 + 4) = v33;
            *v43 = v33;
            *v42 = v33;
            goto lab_0x44c9c;
        } else {
            goto lab_0x44c84;
        }
    } else {
        goto lab_0x44c84;
    }
  lab_0x44b00:;
    int32_t * v44 = (int32_t *)v11; // 0x44b00
    *v8 = v11;
    *(int32_t *)v4 = *v44;
    *(int32_t *)(*v44 + 4) = v4;
    *v44 = v4;
    *v10 = v4;
    if (v9 == v7) {
        // break -> 0x44b7c
        goto lab_0x44b7c;
    }
    // 0x44b28
    v3 = v9;
    goto lab_0x44b28_2;
  lab_0x44c84:;
    int32_t * v45 = (int32_t *)v35; // 0x44c84
    *v39 = *v45;
    *v38 = v35;
    *(int32_t *)(*v45 + 4) = v33;
    *v45 = v33;
    goto lab_0x44c9c;
  lab_0x44c9c:
    // 0x44c9c
    *v34 = v33;
    int32_t v46 = a1 + 20; // 0x44c9c
    int32_t * v47 = (int32_t *)v46; // 0x44c9c
    *v40 = v46;
    *v41 = *v47;
    *(int32_t *)(*v47 + 4) = v37;
    *v47 = v37;
    *(int32_t *)a1 = (int32_t)dest_str + 1;
    return 0;
}

// Address range: 0x44d00 - 0x44d60
int32_t function_44d00(int32_t a1, int32_t str) {
    int32_t v1 = function_443b0(str, strlen((char *)str), g172); // 0x44d2c
    uint32_t v2 = *(int32_t *)(a1 + 8); // 0x44d30
    int32_t v3 = *(int32_t *)(a1 + 4); // 0x44d38
    int32_t v4 = function_448f4(a1, 8 * ((-1 << v2 ^ 0x1fffffff) & v1) + v3, str, v1); // 0x44d50
    int32_t result = 0; // 0x44d58
    if (v4 != 0) {
        result = *(int32_t *)(v4 + 20);
    }
    return result;
}

// Address range: 0x44d60 - 0x44e80
int32_t function_44d60(int32_t a1, int32_t * str) {
    int32_t v1 = (int32_t)str;
    int32_t v2 = function_443b0(v1, strlen((char *)str), g172); // 0x44d8c
    int32_t v3 = *(int32_t *)(a1 + 4); // 0x44d98
    int32_t v4 = 8 * ((-1 << *(int32_t *)(a1 + 8) ^ 0x1fffffff) & v2) + v3; // 0x44dac
    int32_t v5 = function_448f4(a1, v4, v1, v2); // 0x44db4
    if (v5 == 0) {
        // 0x44e78
        return -1;
    }
    int32_t * v6 = (int32_t *)v4; // 0x44dc0
    int32_t * v7 = (int32_t *)(v4 + 4); // 0x44dc4
    int32_t v8 = *v7; // 0x44dc4
    int32_t * v9 = (int32_t *)(v5 + 4); // 0x44dc8
    int32_t v10 = *v9; // 0x44dc8
    int32_t v11 = *(int32_t *)v5; // 0x44dd0
    if (v5 == *v6) {
        if (v5 == v8) {
            int32_t v12 = v5 == v8 ? a1 + 12 : v8;
            *v7 = v12;
            *v6 = v12;
        } else {
            *v6 = v10;
        }
    } else {
        if (v5 == v8) {
            *v7 = v11;
        }
    }
    // 0x44de0
    *(int32_t *)(v11 + 4) = v10;
    int32_t v13 = *v9; // 0x44de4
    int32_t * v14 = (int32_t *)(v5 + 12); // 0x44de8
    int32_t v15 = *(int32_t *)(v5 + 20); // 0x44dec
    *(int32_t *)v13 = v11;
    int32_t v16 = *(int32_t *)(v5 + 8); // 0x44df4
    *(int32_t *)(v16 + 4) = *v14;
    int32_t v17 = *v14; // 0x44e00
    *(int32_t *)v17 = v16;
    if (v15 == 0) {
        // 0x44e18
        *(int32_t *)a1 = function_46954(v5) - 1;
        return 0;
    }
    int32_t v18 = v15 + 4; // 0x44e0c
    int32_t * v19 = (int32_t *)v18; // 0x44e0c
    if (*v19 == -1) {
        // 0x44e18
        *(int32_t *)a1 = function_46954(v5) - 1;
        return 0;
    }
    int32_t v20 = __asm_dmb(v15, v13, v17, v18); // 0x44e38
    int32_t v21 = *v19;
    int32_t v22 = v21 - 1; // 0x44e40
    while (__asm_strex(v22, v21) != 0) {
        // 0x44e3c
        v21 = *v19;
        v22 = v21 - 1;
    }
    if (v22 == 0) {
        // 0x44e58
        function_47c24(v20);
    }
    // 0x44e18
    *(int32_t *)a1 = function_46954(v5) - 1;
    return 0;
}

// Address range: 0x44e80 - 0x44edc
int32_t function_44e80(int32_t a1) {
    // 0x44e80
    function_44968(a1);
    int32_t v1 = a1 + 12; // 0x44e90
    uint32_t result = *(int32_t *)(a1 + 8); // 0x44e94
    int32_t v2 = *(int32_t *)(a1 + 4); // 0x44ea0
    int32_t v3 = v2; // 0x44ea8
    *(int32_t *)(v3 + 4) = v1;
    *(int32_t *)v3 = v1;
    v3 += 8;
    while (v3 != v2 + (8 << result)) {
        // 0x44eac
        *(int32_t *)(v3 + 4) = v1;
        *(int32_t *)v3 = v1;
        v3 += 8;
    }
    int32_t v4 = a1 + 20; // 0x44ebc
    *(int32_t *)(a1 + 16) = v1;
    *(int32_t *)v1 = v1;
    *(int32_t *)(a1 + 24) = v4;
    *(int32_t *)v4 = v4;
    *(int32_t *)a1 = 0;
    return result;
}

// Address range: 0x44edc - 0x44ef4
int32_t function_44edc(int32_t a1) {
    int32_t v1 = *(int32_t *)(a1 + 24); // 0x44edc
    return v1 == a1 + 20 ? 0 : v1;
}

// Address range: 0x44ef4 - 0x44f54
int32_t function_44ef4(int32_t a1, int32_t str) {
    int32_t v1 = function_443b0(str, strlen((char *)str), g172); // 0x44f20
    uint32_t v2 = *(int32_t *)(a1 + 8); // 0x44f24
    int32_t v3 = *(int32_t *)(a1 + 4); // 0x44f2c
    int32_t v4 = function_448f4(a1, 8 * ((-1 << v2 ^ 0x1fffffff) & v1) + v3, str, v1); // 0x44f44
    return v4 == 0 ? 0 : v4 + 8;
}

// Address range: 0x44f54 - 0x44f6c
int32_t function_44f54(int32_t a1, int32_t a2) {
    int32_t v1 = *(int32_t *)(a2 + 4); // 0x44f54
    return v1 == a1 + 20 ? 0 : v1;
}

// Address range: 0x44f6c - 0x44f74
int32_t function_44f6c(int32_t a1) {
    // 0x44f6c
    return a1 + 16;
}

// Address range: 0x44f74 - 0x44f7c
int32_t function_44f74(int32_t a1) {
    // 0x44f74
    return *(int32_t *)(a1 + 12);
}

// Address range: 0x44f7c - 0x44fe8
int32_t function_44f7c(int32_t a1, int32_t a2) {
    int32_t * v1 = (int32_t *)(a1 + 12); // 0x44f84
    int32_t result = *v1; // 0x44f84
    if (result == 0) {
        // 0x44fc4
        *v1 = a2;
        return 0;
    }
    int32_t v2 = result + 4; // 0x44f94
    int32_t * v3 = (int32_t *)v2; // 0x44f94
    if (*v3 == -1) {
        // 0x44fc4
        *v1 = a2;
        return result;
    }
    // 0x44fa0
    int32_t v4; // 0x44f7c
    int32_t result2 = __asm_dmb(result, a2, v4, v2); // 0x44fa4
    int32_t v5 = *v3;
    int32_t v6 = v5 - 1; // 0x44fac
    while (__asm_strex(v6, v5) != 0) {
        // 0x44fa8
        v5 = *v3;
        v6 = v5 - 1;
    }
    // 0x44fbc
    if (v6 != 0) {
        // 0x44fc4
        *v1 = a2;
        return result2;
    }
    int32_t result3 = function_47c24(result2); // 0x44fd4
    *v1 = a2;
    return result3;
}

// Address range: 0x44fe8 - 0x450e4
int32_t function_44fe8(int32_t result) {
    // 0x44fe8
    if (g172 != 0) {
        // 0x45004
        return result;
    }
    while (__asm_strexb(1, (int32_t)g173) != 0) {
        // continue -> 0x45018
    }
    // 0x45028
    if (g173 != 0) {
        int32_t result2 = __asm_dmb(sched_yield(), result, (int32_t)g173, g172); // 0x45058
        while (g172 == 0) {
            // 0x45048
            result2 = __asm_dmb(sched_yield(), result, (int32_t)g173, g172);
        }
        // 0x45004
        return result2;
    }
    int32_t v1 = 1; // 0x45034
    int32_t v2 = result; // 0x45034
    int32_t v3 = 0; // 0x45034
    int32_t v4 = &g173; // 0x45034
    int32_t v5; // 0x44fe8
    int32_t buf; // bp-32, 0x44fe8
    int32_t v6; // 0x44fe8
    if (result == 0) {
        int32_t fd = open64("/dev/urandom", 0); // 0x4506c
        v5 = 0;
        if (fd == -1) {
            goto lab_0x450bc;
        } else {
            int32_t v7 = read(fd, &buf, 4); // 0x45084
            close(fd);
            v5 = 4;
            if (v7 == 4) {
                int32_t v8 = buf % 256; // 0x4509c
                char v9; // 0x44fe8
                int32_t v10 = 256 * v8 | (int32_t)v9; // 0x450ac
                int32_t v11 = 256 * v10 | (int32_t)v9; // 0x450b0
                v1 = v8;
                v3 = v10;
                v4 = v11;
                v6 = 256 * v11 | (int32_t)v9;
                goto lab_0x450d8;
            } else {
                goto lab_0x450bc;
            }
        }
    } else {
        goto lab_0x45038;
    }
  lab_0x45038:;
    int32_t result3 = __asm_dmb(v1, v2, v3, v4); // 0x45038
    g172 = v2;
    return result3;
  lab_0x450bc:
    // 0x450bc
    gettimeofday((struct timeval *)&buf, NULL);
    int32_t pid = getpid(); // 0x450d0
    v1 = pid;
    v3 = v5;
    v4 = &g173;
    int32_t v12; // 0x44fe8
    v6 = buf ^ v12 ^ pid;
    goto lab_0x450d8;
  lab_0x450d8:;
    int32_t v13 = v6;
    v2 = v13 == 0 ? 1 : v13;
    goto lab_0x45038;
}

// Address range: 0x450e4 - 0x45108
int32_t function_450e4(int32_t a1) {
    int32_t * v1 = (int32_t *)(a1 + 4); // 0x450e4
    int32_t v2 = *v1; // 0x450e4
    unsigned char v3 = *(char *)(v2 + a1); // 0x450ec
    if (v3 != 0) {
        *v1 = v2 + 1;
    }
    return v3 == 0 ? -1 : (int32_t)v3;
}

// Address range: 0x45108 - 0x4512c
int32_t function_45108(int32_t a1) {
    uint64_t v1 = *(int64_t *)(a1 + 4); // 0x45108
    uint32_t v2 = (int32_t)v1; // 0x45108
    int32_t v3 = v2; // 0x45118
    if (v2 < (int32_t)(v1 / 0x100000000)) {
        *(int32_t *)(a1 + 8) = v2 + 1;
        v3 = (int32_t)*(char *)(v2 + a1);
    }
    // .thread
    return v2 >= (int32_t)(v1 / 0x100000000) ? -1 : v3;
}

// Address range: 0x4512c - 0x45188
int32_t function_4512c(int32_t a1) {
    int32_t * v1 = (int32_t *)(a1 + 1028); // 0x4512c
    uint32_t v2 = *v1; // 0x4512c
    int32_t * v3 = (int32_t *)(a1 + 1024); // 0x45130
    if (v2 < *v3) {
        // 0x45170
        *v1 = v2 + 1;
        return (int32_t)*(char *)(v2 + a1);
    }
    // 0x45144
    *v1 = 0;
    *v3 = a1;
    uint32_t v4 = a1 + 2; // 0x45164
    if (v4 < a1 - 1 == (v4 != 0)) {
        // 0x45180
        return -1;
    }
    int32_t v5 = *v1;
    *v1 = v5 + 1;
    return (int32_t)*(char *)(v5 + a1);
}

// Address range: 0x45188 - 0x452b8
int32_t function_45188(int32_t a1, int32_t a2, int32_t a3, char * format) {
    // 0x45188
    if (a1 == 0) {
        // 0x45244
        return 0;
    }
    // 0x4519c
    int32_t v1; // 0x45188
    int32_t str; // bp-360, 0x45188
    vsnprintf((char *)&str, 160, format, (int32_t)&v1);
    int32_t v2 = a3; // 0x451cc
    int32_t v3 = -1; // 0x451cc
    int32_t v4 = -1; // 0x451cc
    int32_t v5 = 0; // 0x451cc
    int32_t str2; // bp-200, 0x45188
    int32_t v6; // 0x451dc
    int32_t v7; // 0x451e0
    int32_t v8; // 0x451e4
    if (a2 == 0) {
        return function_48a14(a1, v4, v3, v5, v2, (int32_t)"%s");
    } else {
        int32_t v9 = function_46a84((int32_t *)(a2 + 40)); // 0x451d4
        v6 = *(int32_t *)(a2 + 24);
        v7 = *(int32_t *)(a2 + 28);
        v8 = *(int32_t *)(a2 + 36);
        if (v9 == 0) {
            goto lab_0x45254;
        } else {
            char * v10 = (char *)v9; // 0x451ec
            if (*v10 == 0) {
                goto lab_0x45254;
            } else {
                uint32_t v11 = *(int32_t *)(a2 + 44); // 0x451f8
                v2 = a3;
                v3 = v7;
                v4 = v6;
                v5 = v8;
                if (v11 == 20 || v11 < 20) {
                    // 0x45290
                    snprintf((char *)&str2, 160, "%s near '%s'", &str, v10);
                    v2 = a3;
                    v3 = v7;
                    v4 = v6;
                    v5 = v8;
                }
                return function_48a14(a1, v4, v3, v5, v2, (int32_t)"%s");
            }
        }
    }
    // 0x45244
    return function_48a14(a1, v4, v3, v5, v2, (int32_t)"%s");
  lab_0x45254:;
    int32_t v12 = a3 == 8 ? 6 : a3;
    v2 = v12;
    v3 = v7;
    v4 = v6;
    v5 = v8;
    if (*(int32_t *)(a2 + 20) != -2) {
        // 0x45268
        snprintf((char *)&str2, 160, "%s near end of file", &str);
        v2 = v12;
        v3 = v7;
        v4 = v6;
        v5 = v8;
    }
    return function_48a14(a1, v4, v3, v5, v2, (int32_t)"%s");
}

// Address range: 0x452b8 - 0x452f8
int32_t function_452b8(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    if (*(int32_t *)(v1 + 60) != 256) {
        // 0x452cc
        return function_46a44((int32_t *)(v1 + 40));
    }
    int32_t * v2 = (int32_t *)(v1 + 64); // 0x452d8
    function_46954(*v2);
    *v2 = 0;
    *(int32_t *)(v1 + 68) = 0;
    return function_46a44((int32_t *)(v1 + 40));
}

// Address range: 0x452f8 - 0x45324
int32_t function_452f8(int32_t fd) {
    // 0x452f8
    int32_t buf; // bp-9, 0x452f8
    return read(fd, &buf, 1) == 1 ? buf % 256 : -1;
}

// Address range: 0x45324 - 0x453b8
int32_t function_45324(int32_t a1) {
    if ((char)a1 != 117) {
        // 0x45398
        __assert_fail("str[0] == 'u'", "load.c", 309, "decode_unicode_escape");
        return &g306;
    }
    int32_t v1 = a1;
    int32_t v2 = v1 + 1; // 0x45340
    unsigned char v3 = *(char *)v2; // 0x45340
    int32_t v4 = v3; // 0x45340
    int32_t v5 = 0; // 0x45344
    unsigned char v6 = v3 - 48;
    int32_t v7; // 0x45324
    int32_t v8; // 0x45324
    uint32_t v9; // 0x4535c
    bool v10; // 0x45364
    uint32_t v11; // 0x45370
    if (v6 == 9 || v6 < 9) {
        // .thread4
        v7 = v5 - 48 + v4;
    } else {
        // 0x4535c
        v9 = v4 - 97;
        v10 = v9 == 25 | v9 < 25;
        v8 = v10 ? v4 - 87 : v4;
        if (v10) {
            // .thread5
            v7 = v8 + v5;
        } else {
            // 0x45370
            v11 = v8 - 65;
            if (v11 >= 25 == (v11 != 25)) {
                // break -> 0x4538c
                break;
            }
            // 0x4537c
            v7 = v8 + v5 - 55;
        }
    }
    int32_t v12 = v7; // 0x4538c
    int32_t result = v12; // 0x45388
    while (v1 != a1 + 3) {
        // 0x45340
        v1 = v2;
        v2 = v1 + 1;
        v3 = *(char *)v2;
        v4 = v3;
        v5 = 16 * v12;
        v6 = v3 - 48;
        if (v6 == 9 || v6 < 9) {
            // .thread4
            v7 = v5 - 48 + v4;
        } else {
            // 0x4535c
            v9 = v4 - 97;
            v10 = v9 == 25 | v9 < 25;
            v8 = v10 ? v4 - 87 : v4;
            if (v10) {
                // .thread5
                v7 = v8 + v5;
            } else {
                // 0x45370
                v11 = v8 - 65;
                result = -1;
                if (v11 >= 25 == (v11 != 25)) {
                    // break -> 0x4538c
                    break;
                }
                // 0x4537c
                v7 = v8 + v5 - 55;
            }
        }
        // 0x45384
        v12 = v7;
        result = v12;
    }
    // 0x4538c
    return result;
}

// Address range: 0x453b8 - 0x45470
int32_t function_453b8(int32_t result, int32_t a2) {
    int32_t v1 = a2 + 2; // 0x453b8
    if (v1 == 1 || v1 == 0) {
        return result;
    }
    int32_t * v2 = (int32_t *)(result + 36); // 0x453c4
    *v2 = *v2 - 1;
    int32_t v3 = a2; // 0x453e0
    int32_t v4; // 0x453b8
    if (a2 == 10) {
        int32_t * v5 = (int32_t *)(result + 24); // 0x453e4
        *v5 = *v5 - 1;
        *(int32_t *)(result + 28) = *(int32_t *)(result + 32);
        v4 = result;
        goto lab_0x453f8;
    } else {
        goto lab_0x45438;
    }
  lab_0x45438:;
    int32_t v6 = function_46ed4(v3 % 256); // 0x4543c
    if (v6 != 0) {
        int32_t * v7 = (int32_t *)(result + 28);
        *v7 = *v7 - 1;
    }
    // .thread
    v4 = v6;
    goto lab_0x453f8;
  lab_0x453f8:;
    int32_t * v8 = (int32_t *)(result + 16); // 0x453f8
    int32_t v9 = *v8; // 0x453f8
    if (v9 == 0) {
        // 0x45454
        __assert_fail("stream->buffer_pos > 0", "load.c", 238, "stream_unget");
        return &g306;
    }
    int32_t v10 = v9 - 1; // 0x45404
    *v8 = v10;
    int32_t result2 = v4; // 0x45418
    if ((int32_t)*(char *)(result + 8 + v10) == a2) {
        return result2;
    }
    // 0x4541c
    __assert_fail("stream->buffer[stream->buffer_pos] == c", "load.c", 240, "stream_unget");
    v3 = (int32_t)"load.c";
    goto lab_0x45438;
}

// Address range: 0x45474 - 0x455f8
int32_t function_45474(int32_t a1) {
    int32_t * v1 = (int32_t *)(a1 + 16); // 0x45474
    int32_t v2 = *v1; // 0x45474
    int32_t v3 = v2 + a1; // 0x45484
    unsigned char v4 = *(char *)(v3 + 8); // 0x45488
    int32_t v5 = v2 + 1;
    int32_t v6 = v5; // 0x45494
    int32_t v7 = v3; // 0x45494
    if (v4 == 0) {
        int32_t * v8 = (int32_t *)(a1 + 4); // 0x454a0
        uint32_t v9 = *v8; // 0x454a0
        if (v9 == -1) {
            *(int32_t *)(a1 + 20) = -1;
            // 0x45510
            return -1;
        }
        uint32_t v10 = v9 - 128; // 0x454b8
        *v1 = (int32_t)v4;
        int32_t v11 = a1 + 8;
        *(char *)v11 = (char)v9;
        if (v10 >= 127 == (v10 != 127)) {
            *(char *)(a1 + 9) = 0;
        }
        int32_t v12; // 0x45474
        int32_t v13 = v4 == 0 ? v12 : v5;
        v6 = v10 >= 127 == (v10 != 127) ? 1 : v13;
        v7 = v10 >= 127 == (v10 != 127) ? a1 : v10;
        if (v10 == 127 || v10 < 127) {
            int32_t v14 = function_46ed4(v9 % 256); // 0x45544
            if (v14 == 0) {
                // 0x455b0
                *(int32_t *)(a1 + 20) = -2;
                function_45188(v13, a1, 5, "unable to decode byte 0x%x");
                // 0x45510
                return -2;
            }
            if (v14 == 1) {
                // 0x455dc
                __assert_fail("count >= 2", "load.c", 189, "stream_get");
                return &g306;
            }
            int32_t v15 = v14 + v11;
            int32_t v16 = a1 + 9; // 0x45570
            *(char *)v16 = (char)*v8;
            v16++;
            while ((v14 == 1 ? v12 : v15) != v16) {
                // 0x45564
                *(char *)v16 = (char)*v8;
                v16++;
            }
            // 0x4557c
            if (function_46f40(v14 == 1 ? v12 : v11, v14, 0) == 0) {
                // 0x455b0
                *(int32_t *)(a1 + 20) = -2;
                function_45188(v13, a1, 5, "unable to decode byte 0x%x");
                // 0x45510
                return -2;
            }
            // 0x45594
            *(char *)v15 = 0;
            int32_t v17 = *v1; // 0x455a0
            v6 = v17 + 1;
            v7 = v17 + a1;
        }
    }
    // 0x454dc
    *v1 = v6;
    unsigned char v18 = *(char *)(v7 + 8); // 0x454e0
    int32_t * v19 = (int32_t *)(a1 + 36); // 0x454e4
    *v19 = *v19 + 1;
    if (v18 != 10) {
        int32_t result = v18; // 0x454e0
        if (function_46ed4(result) != 0) {
            int32_t * v20 = (int32_t *)(a1 + 28);
            *v20 = *v20 + 1;
        }
        // 0x45510
        return result;
    }
    int32_t * v21 = (int32_t *)(a1 + 24); // 0x4551c
    int32_t * v22 = (int32_t *)(a1 + 28); // 0x45524
    *v22 = 0;
    *v21 = *v21 + 1;
    *(int32_t *)(a1 + 32) = *v22;
    return 10;
}

// Address range: 0x455fc - 0x4563c
int32_t function_455fc(int32_t a1) {
    int32_t v1 = *(int32_t *)(a1 + 20); // 0x45604
    int32_t result = v1; // 0x4560c
    if (v1 == 0) {
        // 0x45630
        result = function_45474(a1);
    }
    int32_t v2 = result + 2; // 0x45610
    if (v2 != 1 && v2 != 0) {
        // 0x4561c
        function_46b6c(a1 + 40, result % 256);
    }
    // 0x45628
    return result;
}

// Address range: 0x4563c - 0x45684
int32_t function_4563c(int32_t result, int32_t result2) {
    int32_t v1 = result2 + 2; // 0x4563c
    if (v1 == 1 || v1 == 0) {
        return result;
    }
    // 0x45648
    function_453b8(result, result2);
    if (function_46b90(result + 40) == result2) {
        return result2;
    }
    // 0x45668
    __assert_fail("c == d", "load.c", 282, "lex_unget_unsave");
    return &g306;
}

// Address range: 0x45688 - 0x45e98
int32_t function_45688(int32_t a1, int32_t a2) {
    int32_t v1 = a1 + 40; // 0x4568c
    function_46a70(v1);
    int32_t * v2 = (int32_t *)(a1 + 60); // 0x456a4
    if (*v2 == 256) {
        int32_t * v3 = (int32_t *)(a1 + 64); // 0x4580c
        function_46954(*v3);
        *v3 = 0;
        *(int32_t *)(a1 + 68) = 0;
    }
    int32_t * v4 = (int32_t *)(a1 + 20); // 0x456b0
    int32_t v5 = *v4; // 0x456b0
    int32_t v6 = v5; // 0x456b8
    if (v5 == 0) {
        // 0x457e4
        v6 = function_45474(a1);
    }
    int32_t result = v6;
    int32_t v7 = result - 9; // 0x456bc
    while (result == 13 || result == 32 | v7 == 1 || (result == 32 ? result < 32 : v7 == 0)) {
        // 0x456b0
        v5 = *v4;
        v6 = v5;
        if (v5 == 0) {
            // 0x457e4
            v6 = function_45474(a1);
        }
        // 0x456bc
        result = v6;
        v7 = result - 9;
    }
    switch (result) {
        case -1: {
            // .thread
            *v2 = 0;
            // 0x457d8
            return 0;
        }
        case -2: {
            // 0x457d0
            *v2 = -1;
            // 0x457d8
            return -1;
        }
    }
    // 0x456f4
    function_46b6c(v1, result % 256);
    int32_t v8 = result & -33; // 0x45700
    if ((v8 - 91 & -3) == 0) {
        // 0x457fc
        *v2 = result;
        return result;
    }
    int32_t result2 = result; // 0x45688
    int32_t v9; // 0x45688
    char v10; // 0x45688
    int32_t v11; // 0x45688
    char v12; // 0x45688
    int32_t v13; // 0x45688
    int32_t v14; // 0x45688
    int32_t v15; // 0x45688
    int32_t v16; // 0x45688
    int32_t v17; // 0x45688
    int32_t v18; // 0x45688
    int64_t endptr; // bp-48, 0x45688
    uint32_t v19; // 0x4572c
    int32_t * v20; // 0x45828
    switch (result) {
        case 58: {
            goto lab_0x457fc;
        }
        case 44: {
            goto lab_0x457fc;
        }
        case 34: {
            // 0x45824
            v20 = (int32_t *)(a1 + 64);
            *v20 = 0;
            *v2 = -1;
            while (true) {
                int32_t v21; // 0x45870
                while (true) {
                  lab_0x45838:;
                    int32_t v22 = function_455fc(a1); // 0x4583c
                    while (true) {
                      lab_0x45840:;
                        uint32_t v23 = v22;
                        switch (v23) {
                            case 34: {
                                goto lab_0x45b3c;
                            }
                            case -2: {
                                goto lab_0x458c4;
                            }
                            case -1: {
                                // 0x45d1c
                                function_45188(a2, a1, 6, "premature end of input");
                                goto lab_0x458c4;
                            }
                            default: {
                                if (v23 == 31 || v23 < 31) {
                                    // 0x45b08
                                    function_4563c(a1, v23);
                                    if (v23 == 10) {
                                        // 0x45d38
                                        function_45188(a2, a1, 8, "unexpected newline");
                                        goto lab_0x458c4;
                                    } else {
                                        // 0x45b1c
                                        function_45188(a2, a1, 8, "control character 0x%x");
                                        goto lab_0x458c4;
                                    }
                                }
                                if (v23 == 92) {
                                    // 0x45870
                                    v21 = function_455fc(a1);
                                    switch (v21) {
                                        case 117: {
                                            int32_t v24 = function_455fc(a1); // 0x45a80
                                            int32_t v25 = 4; // 0x45a80
                                            while (true) {
                                              lab_0x45a84:;
                                                int32_t v26 = v25;
                                                int32_t v27 = v24;
                                                uint32_t v28 = (v27 & -33) - 65; // 0x45a8c
                                                bool v29 = v28 == 5; // 0x45a94
                                                bool v30 = v28 >= 5; // 0x45a94
                                                if (v28 >= 5 == (v28 != 5)) {
                                                    uint32_t v31 = v27 - 48; // 0x45a88
                                                    v29 = v31 == 9;
                                                    v30 = v31 >= 9;
                                                }
                                                if (v30 == !v29) {
                                                    // 0x458ac
                                                    function_45188(a2, a1, 8, "invalid escape");
                                                    goto lab_0x458c4;
                                                }
                                                // 0x45a9c
                                                v24 = function_455fc(a1);
                                                v22 = v24;
                                                v25 = v26 - 1;
                                                if (v26 == 1) {
                                                    goto lab_0x45840;
                                                } else {
                                                    goto lab_0x45a84;
                                                }
                                            }
                                        }
                                        case 98: {
                                            goto lab_0x45830;
                                        }
                                        case 92: {
                                            goto lab_0x45830;
                                        }
                                        case 34: {
                                            goto lab_0x45830;
                                        }
                                        case 110: {
                                            goto lab_0x45830;
                                        }
                                        case 102: {
                                            goto lab_0x45830;
                                        }
                                        case 47: {
                                            goto lab_0x45830;
                                        }
                                        default: {
                                            goto lab_0x458a0;
                                        }
                                    }
                                } else {
                                    goto lab_0x45838;
                                }
                            }
                        }
                    }
                }
              lab_0x458a0:
                if ((v21 - 114 & -3) != 0) {
                    // 0x458ac
                    function_45188(a2, a1, 8, "invalid escape");
                    goto lab_0x458c4;
                }
              lab_0x45830:;
            }
          lab_0x45b3c:;
            int32_t v32 = function_4693c(*(int32_t *)(a1 + 44) + 1); // 0x45b44
            if (v32 != 0) {
                // 0x45b50
                *v20 = v32;
                int32_t v33 = function_46a84((int32_t *)v1) + 1; // 0x45b60
                char v34 = *(char *)v33; // 0x45b6c
                v18 = v32;
                if (v34 == 34) {
                  lab_0x45d54:
                    // 0x45d54
                    *(char *)v18 = 0;
                    *v2 = 256;
                    *(int32_t *)(a1 + 68) = v18 - *v20;
                    // 0x457d8
                    return 256;
                }
                // 0x45b78
                v10 = v34;
                v16 = v32;
                v13 = v33;
                while (true) {
                  lab_0x45b78:
                    // 0x45b78
                    v14 = v13;
                    v17 = v16;
                    char v35 = v10;
                    int32_t v36 = v14 + 1;
                    if (v35 == 92) {
                        char v37 = *(char *)v36; // 0x45b90
                        switch (v37) {
                            case 117: {
                                int32_t v38 = function_45324(v36); // 0x45bd8
                                if (v38 < 0) {
                                    // break -> 0x45d94
                                    break;
                                }
                                uint32_t v39 = v38 - 0xd800; // 0x45be4
                                int32_t v40 = v14 + 6; // 0x45be8
                                int32_t v41; // 0x45688
                                int32_t v42; // 0x45688
                                if (v39 < 1024) {
                                    // 0x45bf8
                                    if (*(char *)v40 != 92) {
                                        // 0x45de8
                                        function_45188(a2, a1, 8, "invalid Unicode '\\u%04X'");
                                        goto lab_0x458c4;
                                    }
                                    int32_t v43 = v14 + 7; // 0x45c08
                                    if (*(char *)v43 != 117) {
                                        // 0x45de8
                                        function_45188(a2, a1, 8, "invalid Unicode '\\u%04X'");
                                        goto lab_0x458c4;
                                    }
                                    int32_t v44 = function_45324(v43); // 0x45c18
                                    if (v44 < 0) {
                                        // break -> 0x45d94
                                        break;
                                    }
                                    uint32_t v45 = v44 - 0xdc00; // 0x45c2c
                                    if (v45 >= 1024) {
                                        // 0x45e74
                                        function_45188(a2, a1, 8, "invalid Unicode '\\u%04X\\u%04X'");
                                        goto lab_0x458c4;
                                    }
                                    // 0x45c3c
                                    v42 = v14 + 12;
                                    v41 = 1024 * v39 + 0x10000 + v45;
                                } else {
                                    // 0x45d78
                                    v42 = v40;
                                    v41 = v38;
                                    if ((v38 & -1024) == 0xdc00) {
                                        // 0x45de8
                                        function_45188(a2, a1, 8, "invalid Unicode '\\u%04X'");
                                        goto lab_0x458c4;
                                    }
                                }
                                // 0x45c44
                                if (function_46de8(v41, v17, (int32_t *)&endptr) != 0) {
                                    // 0x45e58
                                    __assert_fail("0", "load.c", 452, "lex_scan_string");
                                    // 0x45e74
                                    function_45188(a2, a1, 8, "invalid Unicode '\\u%04X\\u%04X'");
                                    goto lab_0x458c4;
                                }
                                // 0x45c5c
                                v15 = v42;
                                v9 = endptr;
                                goto lab_0x45b6c;
                            }
                            case 98: {
                                // 0x45d14
                                *(char *)v17 = 8;
                                // 0x45bcc
                                v15 = v14 + 2;
                                v9 = 1;
                                goto lab_0x45b6c;
                            }
                            default: {
                                if (v37 < 98) {
                                    // 0x45ce0
                                    v12 = v37;
                                    switch (v37) {
                                        case 92: {
                                            goto lab_0x45cd0;
                                        }
                                        case 47: {
                                            goto lab_0x45cd0;
                                        }
                                        case 34: {
                                            goto lab_0x45cd0;
                                        }
                                        default: {
                                            goto lab_0x45cf8;
                                        }
                                    }
                                } else {
                                    if (v37 == 110) {
                                        // 0x45cd8
                                        *(char *)v17 = 10;
                                        // 0x45bcc
                                        v15 = v14 + 2;
                                        v9 = 1;
                                        goto lab_0x45b6c;
                                    } else {
                                        if (v37 < 110) {
                                            // 0x45cc4
                                            v12 = 12;
                                            if (v37 == 102) {
                                                goto lab_0x45cd0;
                                            } else {
                                                goto lab_0x45cf8;
                                            }
                                        } else {
                                            switch (v37) {
                                                case 114: {
                                                    // 0x45cbc
                                                    *(char *)v17 = 13;
                                                    // 0x45bcc
                                                    v15 = v14 + 2;
                                                    v9 = 1;
                                                    goto lab_0x45b6c;
                                                }
                                                case 116: {
                                                    // 0x45bc4
                                                    *(char *)v17 = 9;
                                                    // 0x45bcc
                                                    v15 = v14 + 2;
                                                    v9 = 1;
                                                    goto lab_0x45b6c;
                                                }
                                                default: {
                                                    goto lab_0x45cf8;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        *(char *)v17 = v35;
                        v15 = v36;
                        v9 = 1;
                        goto lab_0x45b6c;
                    }
                }
                // 0x45d94
                function_45188(a2, a1, 8, "invalid Unicode escape '%.6s'");
            }
            goto lab_0x458c4;
        }
        default: {
            // 0x4572c
            v19 = result - 48;
            if (result != 45 && v19 != 9 && !((result == 45 ? result < 45 : v19 < 9))) {
                uint32_t v46 = v8 - 65; // 0x4573c
                if (v46 >= 25 == (v46 != 25)) {
                    int32_t * v47 = (int32_t *)(a1 + 16); // 0x45994
                    int32_t v48 = a1 + 8;
                    char v49 = *(char *)(*v47 + v48); // 0x4599c
                    if (v49 == 0) {
                        // 0x457d0
                        *v2 = -1;
                        // 0x457d8
                        return -1;
                    }
                    int32_t * v50 = (int32_t *)(a1 + 36);
                    function_46b6c(v1, (int32_t)v49);
                    int32_t v51 = *v47 + 1; // 0x459b8
                    *v47 = v51;
                    *v50 = *v50 + 1;
                    char v52 = *(char *)(v51 + v48); // 0x459cc
                    while (v52 != 0) {
                        // 0x459a8
                        function_46b6c(v1, (int32_t)v52);
                        v51 = *v47 + 1;
                        *v47 = v51;
                        *v50 = *v50 + 1;
                        v52 = *(char *)(v51 + v48);
                    }
                    // 0x457d0
                    *v2 = -1;
                    // 0x457d8
                    return -1;
                }
                int32_t v53 = function_455fc(a1); // 0x45750
                while ((v53 & -33) == 90 || (v53 & -33) < 90) {
                    // 0x45748
                    v53 = function_455fc(a1);
                }
                // 0x45764
                function_4563c(a1, v53);
                int32_t str = function_46a84((int32_t *)v1); // 0x45774
                int32_t strcmp_rc = strcmp((char *)str, "true"); // 0x45784
                int32_t v54 = strcmp_rc == 0 ? 259 : str;
                if (strcmp_rc == 0) {
                    *v2 = v54;
                    // 0x457d8
                    return 259;
                }
                char * str2 = (char *)v54; // 0x457a4
                result2 = 260;
                if (strcmp(str2, "false") == 0) {
                  lab_0x457fc:
                    // 0x457fc
                    *v2 = result2;
                    return result2;
                }
                // 0x457b0
                if (strcmp(str2, "null") != 0) {
                    // 0x457d0
                    *v2 = -1;
                    // 0x457d8
                    return -1;
                }
                *v2 = 261;
                // 0x457d8
                return 261;
            }
            // 0x458e0
            *v2 = -1;
            switch (result) {
                case 45: {
                    int32_t v55 = function_455fc(a1); // 0x45c9c
                    if (v55 == 48) {
                        goto lab_0x45c68;
                    } else {
                        uint32_t v56 = v55 - 48; // 0x45cac
                        v11 = v55;
                        if (v56 == 9 || v56 < 9) {
                            goto lab_generated_0;
                        } else {
                            goto lab_0x45c84;
                        }
                    }
                }
                case 48: {
                    goto lab_0x45c68;
                }
                default: {
                    goto lab_generated_1;
                }
            }
        }
    }
  lab_0x45b6c:;
    int32_t v57 = v9 + v17;
    char v58 = *(char *)v15; // 0x45b6c
    v10 = v58;
    v16 = v57;
    v13 = v15;
    v18 = v57;
    if (v58 == 34) {
        goto lab_0x45d54;
    }
    goto lab_0x45b78;
  lab_0x45cd0:
    // 0x45cd0
    *(char *)v17 = v12;
    // 0x45bcc
    v15 = v14 + 2;
    v9 = 1;
    goto lab_0x45b6c;
  lab_0x45cf8:
    // 0x45cf8
    __assert_fail("0", "load.c", 464, "lex_scan_string");
    // 0x45d14
    *(char *)v17 = 8;
    // 0x45bcc
    v15 = v14 + 2;
    v9 = 1;
    goto lab_0x45b6c;
  lab_0x458c4:
    // 0x458c4
    function_46954(*v20);
    *v20 = 0;
    *(int32_t *)(a1 + 68) = 0;
    // 0x457d8
    return *v2;
  lab_0x45c68:;
    int32_t v59 = function_455fc(a1); // 0x45c70
    uint32_t v60 = v59 - 48; // 0x45c74
    int32_t v61 = v59; // 0x45c7c
    v11 = v59;
    if (v60 >= 9 == (v60 != 9)) {
        goto lab_0x45910;
    } else {
        goto lab_0x45c84;
    }
  lab_generated_2:;
    int32_t v62 = function_455fc(a1); // 0x45900
    uint32_t v63 = v62 - 48; // 0x45904
    v61 = v62;
    while (v63 == 9 || v63 < 9) {
        // 0x458f8
        v62 = function_455fc(a1);
        v63 = v62 - 48;
        v61 = v62;
    }
    goto lab_0x45910;
  lab_0x45910:;
    // 0x45910
    int32_t v64; // 0x45688
    if ((*(int32_t *)(a1 + 52) & 8) == 0) {
        switch (v61) {
            case 101: {
                goto lab_0x45a24;
            }
            case 46: {
                goto lab_0x45ab8;
            }
            case 69: {
                goto lab_0x45a24;
            }
            default: {
                // 0x45930
                function_4563c(a1, v61);
                int32_t str3 = function_46a84((int32_t *)v1); // 0x45940
                int32_t * v65 = __errno_location(); // 0x45948
                *v65 = 0;
                int32_t v66 = &endptr; // 0x4595c
                int64_t str_as_ll = strtoll((char *)str3, (char **)&endptr, 10); // 0x45960
                int32_t v67 = v66; // 0x4596c
                if (*v65 != 34) {
                    // 0x45970
                    if (*(int32_t *)(a1 + 44) + str3 == (int32_t)endptr) {
                        // 0x45984
                        *(int32_t *)(a1 + 64) = (int32_t)str_as_ll;
                        *(int32_t *)(a1 + 68) = v66;
                        *v2 = 257;
                        // 0x457d8
                        return 257;
                    }
                    // 0x45e08
                    __assert_fail("end == saved_text + lex->saved_text.length", "load.c", 541, "lex_scan_number");
                    v67 = (int32_t)"load.c";
                }
                int32_t v68 = v67 % 2 == 0 ? (int32_t)" benchfile '%s'" | 0x493c : (int32_t)" benchfile '%s'" | 0x4920;
                function_45188(a2, a1, 15, (char *)v68);
                // 0x457d8
                return *v2;
            }
        }
    } else {
        // 0x459dc
        v64 = v61;
        if (v61 == 46) {
            goto lab_0x45ab8;
        } else {
            goto lab_0x459e4;
        }
    }
  lab_0x45c84:
    // 0x45c84
    function_4563c(a1, v11);
    // 0x457d8
    return *v2;
  lab_0x45a24:;
    int32_t v69 = function_455fc(a1); // 0x45a2c
    int32_t v70 = v69; // 0x45a38
    if ((v69 - 43 & -3) == 0) {
        // 0x45a3c
        v70 = function_455fc(a1);
    }
    uint32_t v71 = v70 - 48; // 0x45a48
    v11 = v70;
    int32_t v72; // 0x45688
    int32_t v73; // 0x45688
    if (v71 >= 9 == (v71 != 9)) {
        goto lab_0x45c84;
    } else {
        int32_t v74 = function_455fc(a1); // 0x45a5c
        int32_t v75 = v74 - 48; // 0x45a60
        v72 = v74;
        v73 = v75;
        while (v75 == 9 || v75 < 9) {
            // 0x45a54
            v74 = function_455fc(a1);
            v75 = v74 - 48;
            v72 = v74;
            v73 = v75;
        }
        goto lab_0x459f0;
    }
  lab_0x45ab8:;
    int32_t v76 = *v4; // 0x45ab8
    int32_t v77 = v76; // 0x45ac0
    if (v76 == 0) {
        // 0x45ac4
        v77 = function_45474(a1);
    }
    uint32_t v78 = v77 - 48; // 0x45ad4
    if (v78 >= 9 == (v78 != 9)) {
        // 0x45dac
        function_453b8(a1, v77);
        // 0x457d8
        return *v2;
    }
    // 0x45ae0
    function_46b6c(v1, v77 % 256);
    int32_t v79 = function_455fc(a1); // 0x45af4
    uint32_t v80 = v79 - 48; // 0x45af8
    v64 = v79;
    while (v80 == 9 || v80 < 9) {
        // 0x45aec
        v79 = function_455fc(a1);
        v80 = v79 - 48;
        v64 = v79;
    }
    goto lab_0x459e4;
  lab_0x459e4:;
    int32_t v81 = v64 & -33; // 0x459e4
    v72 = v64;
    v73 = v81;
    if (v81 == 69) {
        goto lab_0x45a24;
    } else {
        goto lab_0x459f0;
    }
  lab_0x459f0:
    // 0x459f0
    function_4563c(a1, v72);
    int32_t result3; // 0x45688
    if (function_46bb8(v1, (int32_t *)&endptr, v19, v73) == 0) {
        uint64_t v82 = 0x100000000 * endptr >> 32; // 0x45a10
        *v2 = 258;
        *(int32_t *)(a1 + 64) = (int32_t)(v82 / 0x100000000);
        *(int32_t *)(a1 + 68) = (int32_t)v82;
        result3 = 258;
    } else {
        // 0x45dbc
        function_45188(a2, a1, 15, "real number overflow");
        result3 = *v2;
    }
    // 0x457d8
    return result3;
}

// Address range: 0x45ea0 - 0x46344
int32_t function_45ea0(int32_t a1, uint32_t a2, int32_t a3) {
    int32_t * v1 = (int32_t *)(a1 + 56); // 0x45ea0
    uint32_t v2 = *v1 + 1; // 0x45eb0
    *v1 = v2;
    if (v2 >= 2048 == (v2 != 2048)) {
        // 0x46244
        function_45188(a3, a1, 2, "maximum parsing depth reached");
        // 0x45f14
        return 0;
    }
    int32_t * v3 = (int32_t *)(a1 + 60); // 0x45ec0
    uint32_t v4 = *v3; // 0x45ec0
    int32_t v5; // 0x45ea0
    int32_t v6; // 0x45ea0
    int32_t v7; // 0x45ea0
    int32_t v8; // 0x45ea0
    int32_t v9; // 0x45ea0
    int32_t v10; // 0x45ea0
    int32_t v11; // 0x45ea0
    int32_t result; // 0x45ea0
    int32_t v12; // 0x46140
    int32_t v13; // 0x45f90
    if (v4 == 257) {
        uint64_t v14 = *(int64_t *)(a1 + 64); // 0x46130
        v11 = function_47a48((int32_t)(v14 / 0x100000000), (int32_t)v14);
        goto lab_0x45f00;
    } else {
        if (v4 > 257) {
            // 0x45ed4
        } else {
            if (v4 == 91) {
                // 0x46140
                v12 = function_475f8();
                if (v12 == 0) {
                    // 0x45f14
                    return 0;
                }
                // 0x4614c
                function_45688(a1, a3);
                result = v12;
                switch (*v3) {
                    case 93: {
                        goto lab_0x45f08;
                    }
                    case 0: {
                        goto lab_0x4626c;
                    }
                    default: {
                        while (true) {
                          lab_0x461ac:;
                            int32_t v15 = function_45ea0(a1, a2, a3); // 0x461b8
                            v6 = v12;
                            v8 = 0;
                            v10 = a3;
                            if (v15 == 0) {
                                // break -> 0x461c8
                                break;
                            }
                            // 0x46170
                            v6 = a1;
                            v8 = a3;
                            v10 = a3;
                            if (function_4854c(v12, v15) != 0) {
                                // break -> 0x461c8
                                break;
                            }
                            // 0x46184
                            function_45688(a1, a3);
                            result = v12;
                            switch (*v3) {
                                case 44: {
                                    // 0x4619c
                                    function_45688(a1, a3);
                                    if (*v3 == 0) {
                                        goto lab_0x4626c;
                                    }
                                    goto lab_0x461ac;
                                }
                                case 93: {
                                    goto lab_0x45f08;
                                }
                                default: {
                                    goto lab_0x4626c;
                                }
                            }
                        }
                        goto lab_0x461c8;
                    }
                }
            } else {
                if (v4 <= 91) {
                    if (v4 == -1) {
                        // 0x46104
                        function_45188(a3, a1, 8, "invalid token");
                        // 0x45f14
                        return 0;
                    }
                  lab_0x46208:
                    // 0x46208
                    function_45188(a3, a1, 8, "unexpected token");
                    // 0x45f14
                    return 0;
                }
                switch (v4) {
                    case 123: {
                        // 0x45f90
                        v13 = function_47268();
                        if (v13 == 0) {
                            // 0x45f14
                            return 0;
                        }
                        // 0x45f9c
                        function_45688(a1, a3);
                        result = v13;
                        switch (*v3) {
                            case 125: {
                                goto lab_0x45f08;
                            }
                            case 256: {
                                int32_t * v16 = (int32_t *)(a1 + 64); // 0x45fbc
                                int32_t v17 = *v16; // 0x45fbc
                                int32_t * v18 = (int32_t *)(a1 + 68); // 0x45fc4
                                *v16 = 0;
                                *v18 = 0;
                                if (v17 == 0) {
                                    // 0x45f14
                                    return 0;
                                }
                                int32_t n = *v18; // 0x45fdc
                                int32_t v19 = v17; // 0x45fdc
                                int32_t str; // 0x45ea0
                                while (true) {
                                  lab_0x46094:
                                    // 0x46094
                                    str = v19;
                                    if (memchr((int32_t *)str, 0, n) != NULL) {
                                        // break -> 0x460b0
                                        break;
                                    }
                                    if (a2 % 2 != 0) {
                                        // 0x45fe8
                                        if (function_472ec(v13, (char *)str) != 0) {
                                            // 0x46320
                                            function_46954(str);
                                            v5 = function_45188(a3, a1, 14, "duplicate object key");
                                            v7 = a1;
                                            v9 = 14;
                                            goto lab_0x460d0;
                                        }
                                    }
                                    // 0x45ff4
                                    function_45688(a1, a3);
                                    if (*v3 != 58) {
                                        // 0x462a4
                                        function_46954(str);
                                        v5 = function_45188(a3, a1, 8, "':' expected");
                                        v7 = a1;
                                        v9 = 8;
                                        goto lab_0x460d0;
                                    }
                                    // 0x46014
                                    function_45688(a1, a3);
                                    int32_t v20 = function_45ea0(a1, a2, a3); // 0x46024
                                    if (v20 == 0) {
                                        // 0x462c8
                                        v5 = function_46954(str);
                                        v7 = str;
                                        v9 = 0;
                                        goto lab_0x460d0;
                                    }
                                    int32_t v21 = function_47ee4(v13, str, v20); // 0x46038
                                    v5 = function_46954(str);
                                    v7 = str;
                                    v9 = v20;
                                    if (v21 != 0) {
                                        goto lab_0x460d0;
                                    }
                                    // 0x46048
                                    function_45688(a1, a3);
                                    result = v13;
                                    switch (*v3) {
                                        case 44: {
                                            // 0x4606c
                                            function_45688(a1, a3);
                                            if (*v3 != 256) {
                                                goto lab_0x46288;
                                            }
                                            int32_t v22 = *v16; // 0x4607c
                                            *v16 = 0;
                                            *v18 = 0;
                                            n = *v18;
                                            v19 = v22;
                                            if (v22 == 0) {
                                                // 0x45f14
                                                return 0;
                                            }
                                            goto lab_0x46094;
                                        }
                                        case 125: {
                                            goto lab_0x45f08;
                                        }
                                        default: {
                                            // 0x462e4
                                            v5 = function_45188(a3, a1, 8, "'}' expected");
                                            v7 = a1;
                                            v9 = 8;
                                            goto lab_0x460d0;
                                        }
                                    }
                                }
                                // 0x460b0
                                function_46954(str);
                                v5 = function_45188(a3, a1, 13, "NUL byte in object key not supported");
                                v7 = a1;
                                v9 = 13;
                                goto lab_0x460d0;
                            }
                            default: {
                                goto lab_0x46288;
                            }
                        }
                    }
                    case 256: {
                        int32_t * v23 = (int32_t *)(a1 + 64); // 0x45f40
                        int32_t str2 = *v23; // 0x45f40
                        int32_t * v24 = (int32_t *)(a1 + 68); // 0x45f44
                        int32_t n2 = *v24; // 0x45f44
                        if ((a2 & 16) == 0) {
                            // 0x45f4c
                            if (memchr((int32_t *)str2, 0, n2) != NULL) {
                                // 0x46300
                                function_45188(a3, a1, 11, "\\u0000 is not allowed without JSON_ALLOW_NUL");
                            }
                        }
                        int32_t v25 = function_477b0(str2, n2); // 0x45f6c
                        *v23 = 0;
                        *v24 = 0;
                        v11 = v25;
                        goto lab_0x45f00;
                    }
                    default: {
                        goto lab_0x46208;
                    }
                }
            }
        }
    }
  lab_0x4626c:
    // 0x4626c
    v6 = function_45188(a3, a1, 8, "']' expected");
    v8 = a1;
    v10 = 8;
    goto lab_0x461c8;
  lab_0x45f08:
    // 0x45f08
    *v1 = *v1 - 1;
    // 0x45f14
    return result;
  lab_0x460d0:;
    int32_t v33 = v13 + 4; // 0x460d0
    int32_t * v34 = (int32_t *)v33; // 0x460d0
    if (*v34 == -1) {
        // 0x45f14
        return 0;
    }
    // 0x460dc
    __asm_dmb(v5, v7, v9, v33);
    int32_t v35 = *v34;
    int32_t v36 = v35 - 1; // 0x460e8
    int32_t v37 = __asm_strex(v36, v35); // 0x460ec
    int32_t v31 = v36; // 0x460f4
    int32_t v32 = v13; // 0x460f4
    while (v37 != 0) {
        // 0x460e4
        v35 = *v34;
        v36 = v35 - 1;
        v37 = __asm_strex(v36, v35);
        v31 = v36;
        v32 = v13;
    }
    goto lab_0x461f0;
  lab_0x46288:
    // 0x46288
    v5 = function_45188(a3, a1, 8, "string or '}' expected");
    v7 = a1;
    v9 = 8;
    goto lab_0x460d0;
  lab_0x45f00:
    // 0x45f00
    result = v11;
    if (v11 == 0) {
        // 0x45f14
        return 0;
    }
    goto lab_0x45f08;
  lab_0x461c8:;
    int32_t v26 = v12 + 4; // 0x461c8
    int32_t * v27 = (int32_t *)v26; // 0x461c8
    if (*v27 == -1) {
        // 0x45f14
        return 0;
    }
    // 0x461d4
    __asm_dmb(v6, v8, v10, v26);
    int32_t v28 = *v27;
    int32_t v29 = v28 - 1; // 0x461e0
    int32_t v30 = __asm_strex(v29, v28); // 0x461e4
    v31 = v29;
    v32 = v12;
    while (v30 != 0) {
        // 0x461dc
        v28 = *v27;
        v29 = v28 - 1;
        v30 = __asm_strex(v29, v28);
        v31 = v29;
        v32 = v12;
    }
    goto lab_0x461f0;
  lab_0x461f0:
    // 0x461f0
    if (v31 == 0) {
        // 0x461f8
        function_47c24(v32);
    }
    // 0x45f14
    return 0;
}

// Address range: 0x46344 - 0x46448
int32_t function_46344(int32_t * a1, int32_t a2, int32_t a3) {
    int32_t v1 = (int32_t)a1;
    *(int32_t *)(v1 + 56) = 0;
    function_45688(v1, a3);
    if ((a2 & 4) == 0) {
        // 0x4636c
        if ((*(int32_t *)(v1 + 60) & -33) != 91) {
            // 0x4642c
            function_45188(a3, v1, 8, "'[' or '{' expected");
            // 0x463a8
            return 0;
        }
    }
    int32_t result = function_45ea0(v1, a2, a3); // 0x46388
    if (result == 0) {
        // 0x463a8
        return 0;
    }
    if ((a2 & 2) == 0) {
        // 0x463b0
        function_45688(v1, a3);
        if (*(int32_t *)(v1 + 60) != 0) {
            int32_t v2 = function_45188(a3, v1, 7, "end of file expected"); // 0x463dc
            int32_t v3 = result + 4; // 0x463e0
            int32_t * v4 = (int32_t *)v3; // 0x463e0
            if (*v4 == -1) {
                // 0x463a8
                return 0;
            }
            // 0x463f8
            __asm_dmb(v2, v1, 7, v3);
            int32_t v5 = *v4;
            int32_t v6 = v5 - 1; // 0x46404
            while (__asm_strex(v6, v5) != 0) {
                // 0x46400
                v5 = *v4;
                v6 = v5 - 1;
            }
            // 0x46414
            if (v6 == 0) {
                // 0x4641c
                function_47c24(result);
            }
            // 0x463a8
            return 0;
        }
    }
    // 0x4639c
    if (a3 != 0) {
        *(int32_t *)(a3 + 8) = *(int32_t *)(v1 + 36);
    }
    // 0x463a8
    return result;
}

// Address range: 0x46448 - 0x46510
int32_t function_46448(int32_t * a1, int32_t a2, int32_t * a3) {
    int32_t v1 = (int32_t)a3;
    function_489c4(v1, "<string>");
    if (a1 == NULL) {
        int32_t result = (int32_t)a1;
        function_45188(v1, result, 4, "wrong arguments");
        // 0x464e4
        return result;
    }
    int32_t v2 = 0x450e4; // bp-96, 0x4648c
    int32_t v3; // bp-56, 0x46448
    int32_t v4 = function_46a10(&v3); // 0x464b0
    int32_t result2 = 0; // 0x464b8
    if (v4 == 0) {
        // 0x464bc
        result2 = function_46344(&v2, a2, v1);
        function_452b8(&v2);
    }
    // 0x464e4
    return result2;
}

// Address range: 0x46510 - 0x465e4
int32_t function_46510(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x46510
    function_489c4(a4, "<buffer>");
    if (a1 == 0) {
        // 0x465c4
        function_45188(a4, 0, 4, "wrong arguments");
        // 0x465b8
        return 0;
    }
    int32_t v1 = 0x45108; // bp-96, 0x46560
    int32_t v2; // bp-56, 0x46510
    int32_t v3 = function_46a10(&v2); // 0x46584
    int32_t result = 0; // 0x4658c
    if (v3 == 0) {
        // 0x46590
        result = function_46344(&v1, a3, a4);
        function_452b8(&v1);
    }
    // 0x465b8
    return result;
}

// Address range: 0x465e4 - 0x466c4
int32_t function_465e4(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = g59 == a1 ? (int32_t)"<stdin>" : (int32_t)"<stream>";
    function_489c4(a3, (char *)v1);
    if (a1 == 0) {
        // 0x466a4
        function_45188(a3, 0, 4, "wrong arguments");
        // 0x46698
        return 0;
    }
    int32_t v2 = 0x1227c; // bp-96, 0x46648
    int32_t v3; // bp-56, 0x465e4
    int32_t v4 = function_46a10(&v3); // 0x46664
    int32_t result = 0; // 0x4666c
    if (v4 == 0) {
        // 0x46670
        result = function_46344(&v2, a2, a3);
        function_452b8(&v2);
    }
    // 0x46698
    return result;
}

// Address range: 0x466c4 - 0x467a0
int32_t function_466c4(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = a1 == 0 ? (int32_t)"<stdin>" : (int32_t)"<stream>";
    function_489c4(a3, (char *)v1);
    if (a1 < 0) {
        // 0x46780
        function_45188(a3, 0, 4, "wrong arguments");
        // 0x46774
        return 0;
    }
    int32_t v2 = 0x452f8; // bp-88, 0x46720
    int32_t v3; // bp-48, 0x466c4
    int32_t v4 = function_46a10(&v3); // 0x46740
    int32_t result = 0; // 0x46748
    if (v4 == 0) {
        // 0x4674c
        result = function_46344(&v2, a2, a3);
        function_452b8(&v2);
    }
    // 0x46774
    return result;
}

// Address range: 0x467a0 - 0x46858
int32_t function_467a0(int32_t a1, int32_t a2, int32_t * a3) {
    int32_t v1 = (int32_t)a3;
    char * v2 = (char *)a1; // 0x467bc
    function_489c4(v1, v2);
    if (a1 == 0) {
        // 0x46804
        function_45188(v1, 0, 4, "wrong arguments");
        // 0x467f8
        return 0;
    }
    struct _IO_FILE * file = fopen64(v2, "rb"); // 0x467d4
    int32_t v3 = (int32_t)file; // 0x467d4
    int32_t result; // 0x467a0
    if (file == NULL) {
        // 0x46824
        strerror(*__errno_location());
        function_45188(v1, v3, 3, "unable to open %s: %s");
        result = v3;
    } else {
        int32_t v4 = function_465e4(v3, a2, v1); // 0x467e8
        fclose(file);
        result = v4;
    }
    // 0x467f8
    return result;
}

// Address range: 0x46858 - 0x4693c
int32_t function_46858(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x46858
    int32_t v1; // bp-1064, 0x46858
    memset(&v1, 0, 1040);
    function_489c4(a4, "<callback>");
    if (a1 == 0) {
        // 0x46920
        function_45188(a4, 0, 4, "wrong arguments");
        // 0x46910
        return 0;
    }
    int32_t v2 = 0x4512c; // bp-1136, 0x468c0
    int32_t v3; // bp-1096, 0x46858
    int32_t v4 = function_46a10(&v3); // 0x468dc
    int32_t result = 0; // 0x468e4
    if (v4 == 0) {
        // 0x468e8
        result = function_46344(&v2, a3, a4);
        function_452b8(&v2);
    }
    // 0x46910
    return result;
}

// Address range: 0x4693c - 0x46954
int32_t function_4693c(int32_t size) {
    if (size == 0) {
        return 0;
    }
    // 0x46944
    return (int32_t)malloc(size);
}

// Address range: 0x46954 - 0x4696c
int32_t function_46954(int32_t a1) {
    if (a1 == 0) {
        return 0;
    }
    // 0x4695c
    free((int32_t *)a1);
    return &g306;
}

// Address range: 0x4696c - 0x469b8
int32_t function_4696c(int32_t a1, int32_t a2) {
    int32_t size = a2 + 1; // 0x46970
    if (size == 0) {
        // 0x469b0
        return 0;
    }
    int32_t * mem = malloc(size); // 0x46990
    int32_t result = (int32_t)mem; // 0x46990
    if (mem != NULL) {
        // 0x4699c
        memcpy(mem, (int32_t *)a1, a2);
        *(char *)(result + a2) = 0;
    }
    // 0x469b0
    return result;
}

// Address range: 0x469b8 - 0x469d4
int32_t function_469b8(int32_t str) {
    // 0x469b8
    return function_4696c(str, strlen((char *)str));
}

// Address range: 0x469d4 - 0x469e4
int32_t function_469d4(int32_t result, int32_t a2) {
    // 0x469d4
    g54 = result;
    g55 = a2;
    return result;
}

// Address range: 0x469e4 - 0x46a10
int32_t function_469e4(int32_t result, int32_t a2) {
    if (result != 0) {
        *(int32_t *)result = g54;
    }
    if (a2 != 0) {
        *(int32_t *)a2 = *(int32_t *)0x664d0;
    }
    // .thread3
    return result;
}

// Address range: 0x46a10 - 0x46a44
int32_t function_46a10(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    *(int32_t *)(v1 + 8) = 16;
    *(int32_t *)(v1 + 4) = 0;
    int32_t v2 = function_4693c(16); // 0x46a28
    *a1 = v2;
    if (v2 != 0) {
        *(char *)v2 = 0;
    }
    return v2 == 0;
}

// Address range: 0x46a44 - 0x46a70
int32_t function_46a44(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    int32_t result = v1; // 0x46a54
    if (a1 != NULL) {
        // 0x46a58
        result = function_46954(v1);
    }
    // 0x46a5c
    *(int32_t *)(v1 + 8) = 0;
    *(int32_t *)(v1 + 4) = 0;
    *a1 = 0;
    return result;
}

// Address range: 0x46a70 - 0x46a84
int32_t function_46a70(int32_t result) {
    // 0x46a70
    *(int32_t *)(result + 4) = 0;
    *(char *)result = 0;
    return result;
}

// Address range: 0x46a84 - 0x46a8c
int32_t function_46a84(int32_t * a1) {
    // 0x46a84
    return (int32_t)a1;
}

// Address range: 0x46a8c - 0x46aa0
int32_t function_46a8c(int32_t result) {
    // 0x46a8c
    *(int32_t *)result = 0;
    return result;
}

// Address range: 0x46aa0 - 0x46b6c
int32_t function_46aa0(int32_t a1, int32_t a2, uint32_t a3) {
    int32_t * v1 = (int32_t *)(a1 + 8); // 0x46aa8
    int32_t v2 = *v1; // 0x46aa8
    int32_t * v3 = (int32_t *)(a1 + 4); // 0x46ab4
    int32_t v4 = *v3; // 0x46ab4
    uint32_t v5 = v2 - v4; // 0x46ab8
    int32_t v6 = v4; // 0x46ac4
    int32_t v7 = v4; // 0x46ac4
    if (v5 >= a3 != v5 != a3) {
        if (-2 - a3 < v4 || v2 < 0 || a3 == -1) {
            // 0x46b64
            return -1;
        }
        uint32_t v8 = 2 * v2; // 0x46af0
        uint32_t v9 = a3 + 1 + v4; // 0x46af8
        int32_t v10 = v9 < v8 ? v8 : v9;
        v7 = function_4693c(v10);
        if (v7 == 0) {
            // 0x46b64
            return -1;
        }
        int32_t * v11 = (int32_t *)v7; // 0x46b1c
        function_46954((int32_t)memcpy(v11, v11, *v3));
        v6 = *v3;
        *(int32_t *)a1 = v7;
        *v1 = v10;
    }
    int32_t * dest_mem = memcpy((int32_t *)(v7 + v6), (int32_t *)a2, a3); // 0x46b40
    int32_t v12 = *v3 + a3; // 0x46b54
    *v3 = v12;
    *(char *)(v12 + (int32_t)dest_mem) = 0;
    return 0;
}

// Address range: 0x46b6c - 0x46b90
int32_t function_46b6c(int32_t a1, int32_t a2) {
    int32_t v1 = 0x1000000 * a2 >> 24; // bp-9, 0x46b7c
    return function_46aa0(a1, (int32_t)&v1, 1);
}

// Address range: 0x46b90 - 0x46bb8
int32_t function_46b90(int32_t a1) {
    int32_t * v1 = (int32_t *)(a1 + 4); // 0x46b90
    int32_t v2 = *v1; // 0x46b90
    int32_t result = 0; // 0x46ba4
    if (v2 != 0) {
        int32_t v3 = v2 == 0 ? 0 : v2 - 1;
        *v1 = v3;
        char * v4 = (char *)(v3 + a1);
        *v4 = 0;
        result = (int32_t)*v4;
    }
    // .critedge.thread
    return result;
}

// Address range: 0x46bb8 - 0x46c98
int32_t function_46bb8(int32_t a1, int32_t * a2, int32_t a3, int32_t a4) {
    struct lconv * locale_info = localeconv(); // 0x46bc8
    int32_t v1 = (int32_t)locale_info; // 0x46bc8
    char v2 = *(char *)*(int32_t *)locale_info; // 0x46bd4
    int32_t str = v1; // 0x46bdc
    if (v2 != 46) {
        char * found_char_pos = strchr((char *)locale_info, 46); // 0x46be8
        if (found_char_pos != NULL) {
            *found_char_pos = v2;
        }
        str = found_char_pos == NULL ? v1 : (int32_t)found_char_pos;
    }
    // 0x46bf8
    *__errno_location() = 0;
    int32_t endptr; // bp-28, 0x46bb8
    float64_t str_as_d = strtod((char *)str, (char **)&endptr); // 0x46c10
    if (endptr == *(int32_t *)(a1 + 4) + (int32_t)(float32_t)str_as_d) {
        // 0x46c2c
        __asm_vldr(-1);
        return (float32_t)str_as_d;
    }
    // 0x46c74
    __assert_fail("end == strbuffer->value + strbuffer->length", "strconv.c", 78, "jsonp_strtod");
    return __asm_nop((int32_t)&g306);
}

// Address range: 0x46ca8 - 0x46de8
int32_t function_46ca8(int32_t * str, uint32_t size, int32_t a3) {
    // 0x46ca8
    float64_t v1; // 0x46ca8
    int32_t v2; // 0x46ca8
    __asm_vstr(v1, v2);
    int32_t chars_printed = snprintf((char *)str, size, "%.*g", a3 == 0 ? 17 : a3); // 0x46cd0
    if (chars_printed == size || chars_printed > size) {
        // 0x46d88
        return -1;
    }
    unsigned char c = *(char *)*(int32_t *)localeconv(); // 0x46ce8
    if (c != 46) {
        char * found_char_pos = strchr((char *)str, (int32_t)c); // 0x46cf8
        if (found_char_pos != NULL) {
            *found_char_pos = 46;
        }
    }
    int32_t v3 = (int32_t)str;
    char * found_char_pos2 = strchr((char *)str, 46); // 0x46d10
    char * found_char_pos3 = strchr((char *)str, 101); // 0x46d20
    int32_t v4 = (int32_t)found_char_pos3; // 0x46d20
    int32_t found_char_pos4 = v4; // 0x46d28
    int32_t result = chars_printed; // 0x46d28
    int32_t v5; // 0x46ca8
    int32_t result2; // 0x46ca8
    if (found_char_pos2 == NULL) {
        // 0x46da0
        v5 = v4;
        result2 = chars_printed;
        if (found_char_pos3 == NULL) {
            // 0x46da8
            if (chars_printed + 3 >= size) {
                // 0x46d88
                return -1;
            }
            int32_t v6 = chars_printed + v3; // 0x46dbc
            *(char *)v6 = 46;
            result = chars_printed + 2;
            *(char *)(v6 + 1) = 48;
            *(char *)(result + v3) = (char)v4;
            found_char_pos4 = (int32_t)strchr((char *)str, 101);
            goto lab_0x46d2c;
        } else {
            goto lab_0x46d34;
        }
    } else {
        goto lab_0x46d2c;
    }
  lab_0x46d2c:
    // 0x46d2c
    v5 = found_char_pos4;
    result2 = result;
    if (found_char_pos4 == 0) {
        // 0x46d88
        return result;
    }
    goto lab_0x46d34;
  lab_0x46d34:;
    int32_t v7 = v5 + 1; // 0x46d34
    int32_t v8 = v5 + 2; // 0x46d38
    char v9 = *(char *)v8; // 0x46d3c
    int32_t v10; // 0x46ca8
    int32_t v11; // 0x46ca8
    int32_t v12; // 0x46ca8
    if (*(char *)v7 == 45) {
        // 0x46d90
        v11 = v8;
        if (v9 != 48) {
            // 0x46d88
            return result2;
        }
        goto lab_0x46d54;
    } else {
        // 0x46d48
        v11 = v7;
        v12 = v7;
        v10 = v8;
        if (v9 == 48) {
            goto lab_0x46d54;
        } else {
            goto lab_0x46d68;
        }
    }
  lab_0x46d54:;
    int32_t v13 = v8 + 1; // 0x46d54
    int32_t v14 = v13; // 0x46d5c
    while (*(char *)v13 == 48) {
        // 0x46d54
        v13 = v14 + 1;
        v14 = v13;
    }
    // 0x46d60
    v12 = v11;
    v10 = v13;
    if (v11 == v13) {
        // 0x46d88
        return result2;
    }
    goto lab_0x46d68;
  lab_0x46d68:;
    int32_t v15 = v10;
    memmove((int32_t *)v12, (int32_t *)v15, result2 + v3 - v15);
    // 0x46d88
    return v12 + result2 - v15;
}

// Address range: 0x46de8 - 0x46ed4
int32_t function_46de8(int32_t a1, int32_t a2, int32_t * a3) {
    if (a1 < 0) {
        // 0x46ec4
        return -1;
    }
    if (a1 < 128) {
        // 0x46e7c
        *(char *)a2 = (char)a1;
        *a3 = 1;
        return 0;
    }
    if (a1 < 2048) {
        // 0x46e54
        *(char *)a2 = (char)((uint32_t)a1 / 64) - 64;
        *(char *)(a2 + 1) = (char)a1 % 64 | -128;
        *a3 = 2;
        return 0;
    }
    if (a1 < 0x10000) {
        int32_t v1 = __asm_ubfx(a1, 6, 6); // 0x46e94
        *(char *)a2 = (char)(a1 / 0x1000) - 32;
        *(char *)(a2 + 1) = (char)v1 ^ -128;
        *(char *)(a2 + 2) = (char)a1 % 64 | -128;
        *a3 = 3;
        return 0;
    }
    if (a1 > 0x10ffff) {
        // 0x46ec4
        return -1;
    }
    int32_t v2 = __asm_ubfx(a1, 12, 6); // 0x46e18
    int32_t v3 = __asm_ubfx(a1, 6, 6); // 0x46e1c
    *(char *)a2 = (char)(a1 / 0x40000) - 16;
    *(char *)(a2 + 1) = (char)v2 ^ -128;
    *(char *)(a2 + 2) = (char)v3 ^ -128;
    *(char *)(a2 + 3) = (char)a1 % 64 | -128;
    *a3 = 4;
    return 0;
}

// Address range: 0x46ed4 - 0x46f40
int32_t function_46ed4(int32_t a1) {
    // 0x46ed4
    if ((a1 & 128) == 0) {
        // 0x46edc
        return 1;
    }
    uint32_t v1 = a1 ^ 128; // 0x46ee4
    if (v1 == 65 || v1 < 65) {
        // 0x46edc
        return 0;
    }
    uint32_t v2 = (a1 + 62) % 256; // 0x46ef4
    if (v2 == 29 || v2 < 29) {
        // 0x46edc
        return 2;
    }
    uint32_t v3 = (a1 + 32) % 256; // 0x46f04
    int32_t result = 3; // 0x46f0c
    if (v3 != 15 && v3 >= 15) {
        uint32_t v4 = (a1 + 16) % 256; // 0x46f14
        result = v4 == 4 | v4 < 4 ? 4 : v4 >= 4 == (v4 != 4) ? 0 : v4;
    }
    // 0x46edc
    return result;
}

// Address range: 0x46f40 - 0x47028
int32_t function_46f40(uint32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = (uint32_t)(a1 % 32);
    int32_t v2 = v1; // 0x46f54
    if (a2 != 2) {
        uint32_t v3 = a2 == 2 ? v1 : a1 % 256;
        v2 = v3 % 16;
        if (a2 != 3) {
            // 0x46f64
            v2 = v3 % 8;
            if (a2 != 4) {
                // 0x46f70
                return 0;
            }
        }
    }
    int32_t v4 = a1 + 1; // 0x46f78
    int32_t v5 = (int32_t)*(char *)v4; // 0x46f78
    uint32_t v6 = v5 ^ 128; // 0x46f7c
    int32_t v7 = v4; // 0x46f84
    if (v6 >= 63 == (v6 != 63)) {
        // 0x46f70
        return 0;
    }
    int32_t v8 = 1; // 0x46f84
    int32_t v9 = v2;
    v8++;
    int32_t v10 = v5 % 64 | 64 * v9; // 0x46fb0
    while ((v9 & 0x4000000) != 0 == (v8 != a2)) {
        // 0x46f94
        v7++;
        int32_t v11 = (int32_t)*(char *)v7; // 0x46f94
        uint32_t v12 = v11 ^ 128; // 0x46f98
        if (v12 >= 63 == (v12 != 63)) {
            // 0x46f70
            return 0;
        }
        v9 = v10;
        v8++;
        v10 = v11 % 64 | 64 * v9;
    }
    // 0x46fb8
    if ((v9 & 0x3ffffe0) == 864 || v10 > 0x10ffff || (v10 < 128 ? a2 == 2 : v10 == 127)) {
        // 0x46f70
        return 0;
    }
    // .critedge
    if (a3 != 0) {
        *(int32_t *)a3 = v10;
    }
    // 0x46f70
    return 1;
}

// Address range: 0x47028 - 0x470a4
int32_t function_47028(uint32_t result, uint32_t a2, int32_t * a3) {
    // 0x47028
    if (a2 == 0) {
        // 0x47098
        return result;
    }
    int32_t v1 = result % 256; // 0x47038
    uint32_t v2 = function_46ed4(v1); // 0x47048
    int32_t v3; // bp-20, 0x47028
    switch (v2) {
        case 0: {
            // 0x47098
            return 0;
        }
        case 1: {
            v3 = v1;
            // break -> 0x47080
            break;
        }
        default: {
            // 0x47060
            if (v2 > a2 || function_46f40(result, v2, (int32_t)&v3) == 0) {
                // 0x47098
                return 0;
            }
            // break -> 0x47080
            break;
        }
    }
    // 0x47080
    if (a3 != NULL) {
        *a3 = v3;
    }
    // 0x47098
    return v2 + result;
}

// Address range: 0x470a4 - 0x47120
int32_t function_470a4(int32_t a1, uint32_t a2) {
    int32_t v1 = 0; // 0x470ac
    int32_t result = 1; // 0x470ac
    if (a2 == 0) {
        // 0x47110
        return result;
    }
    int32_t v2; // 0x470a4
    while (true) {
      lab_0x470ec:;
        int32_t v3 = v1;
        int32_t v4 = v3 + a1; // 0x470ec
        uint32_t v5 = function_46ed4((int32_t)*(char *)v4); // 0x470f4
        v2 = v3;
        result = 0;
        switch (v5) {
            case 0: {
                return result;
            }
            case 1: {
                goto lab_0x470e0;
            }
            default: {
                // 0x470c4
                if (a2 - v3 < v5) {
                    // break -> 0x47110
                    break;
                }
                int32_t v6 = function_46f40(v4, v5, 0); // 0x470cc
                v2 = v3 - 1 + v5;
                if (v6 == 0) {
                    // break -> 0x47110
                    break;
                }
                goto lab_0x470e0;
            }
        }
    }
    // 0x47110
    return 1;
  lab_0x470e0:
    // 0x470e0
    v1 = v2 + 1;
    if (v1 == a2 || v1 > a2) {
        return 1;
    }
    goto lab_0x470ec;
}

// Address range: 0x47120 - 0x47170
int32_t function_47120(int32_t a1) {
    int32_t v1 = 0; // 0x47128
    int32_t v2 = 0; // 0x47128
    if (a1 == 3) {
        uint64_t v3 = *(int64_t *)11; // 0x47168
        v1 = v3 / 0x100000000;
        v2 = v3;
    }
    int32_t result = function_4693c(16); // 0x47144
    if (result == 0) {
        return 0;
    }
    // 0x47150
    *(int32_t *)(result + 8) = v1;
    *(int32_t *)(result + 12) = v2;
    *(int32_t *)result = 3;
    *(int32_t *)(result + 4) = 1;
    return result;
}

// Address range: 0x47170 - 0x471fc
int32_t function_47170(int32_t a1, int32_t a2, int32_t a3) {
    int32_t * v1 = (int32_t *)(a1 + 12); // 0x47170
    int32_t * v2 = (int32_t *)(a1 + 8); // 0x47174
    uint32_t v3 = *v2; // 0x47174
    uint32_t v4 = *v1 + a2; // 0x4717c
    int32_t * v5 = (int32_t *)(a1 + 16); // 0x47180
    int32_t result = *v5; // 0x47180
    if (v4 >= v3 != v4 != v3) {
        // 0x4718c
        return result;
    }
    uint32_t v6 = 2 * v3; // 0x47194
    uint32_t v7 = v3 + a2; // 0x47198
    int32_t v8 = v6 < v7 ? v7 : v6;
    int32_t v9 = function_4693c(4 * v8); // 0x471b4
    if (v9 == 0) {
        // 0x4718c
        return 0;
    }
    // 0x471c0
    *v2 = v8;
    *v5 = v9;
    if (a3 == 0) {
        // 0x4718c
        return result;
    }
    // 0x471d0
    memcpy((int32_t *)v9, (int32_t *)result, 4 * *v1);
    function_46954(result);
    return *v5;
}

// Address range: 0x471fc - 0x47268
int32_t function_471fc(int32_t a1, int32_t a2, int32_t a3) {
    if (a1 == 0) {
        // 0x47250
        return 0;
    }
    int32_t v1 = a1; // 0x47210
    if (a3 == 0) {
        // 0x47244
        v1 = function_4696c(a1, a2);
        if (v1 == 0) {
            // 0x47250
            return 0;
        }
    }
    int32_t result = function_4693c(16); // 0x47218
    if (result == 0) {
        // 0x47258
        function_46954(v1);
        return 0;
    }
    // 0x47224
    *(int32_t *)(result + 8) = v1;
    *(int32_t *)(result + 12) = a2;
    *(int32_t *)result = 2;
    *(int32_t *)(result + 4) = 1;
    return result;
}

// Address range: 0x47268 - 0x472d0
int32_t function_47268(void) {
    int32_t v1 = function_4693c(36); // 0x47270
    if (v1 == 0) {
        // 0x472b0
        return 0;
    }
    // 0x4727c
    if (g172 == 0) {
        // 0x472b8
        function_44fe8(0);
    }
    // 0x47290
    *(int32_t *)(v1 + 4) = 1;
    *(int32_t *)v1 = 0;
    int32_t v2 = function_449d8((int32_t *)(v1 + 8)); // 0x472a4
    int32_t result = v1; // 0x472ac
    if (v2 != 0) {
        // 0x472c0
        function_46954(v1);
        result = 0;
    }
    // 0x472b0
    return result;
}

// Address range: 0x472d0 - 0x472ec
int32_t function_472d0(int32_t a1) {
    // 0x472d0
    return 0;
}

// Address range: 0x472ec - 0x47314
int32_t function_472ec(int32_t a1, char * a2) {
    // 0x472ec
    return 0;
}

// Address range: 0x47314 - 0x474f4
int32_t function_47314(int32_t a1, int32_t a2) {
    // 0x47314
    return (bool)(a1 == a2);
}

// Address range: 0x474f4 - 0x4751c
int32_t function_474f4(int32_t a1, int32_t a2) {
    // 0x474f4
    return -1;
}

// Address range: 0x4751c - 0x47554
int32_t function_4751c(int32_t a1) {
    // 0x4751c
    return -1;
}

// Address range: 0x47554 - 0x47578
int32_t function_47554(int32_t a1) {
    // 0x47554
    return 0;
}

// Address range: 0x47578 - 0x475a0
int32_t function_47578(int32_t a1, int32_t a2) {
    // 0x47578
    return 0;
}

// Address range: 0x475a0 - 0x475d4
int32_t function_475a0(int32_t a1, int32_t a2) {
    // 0x475a0
    return 0;
}

// Address range: 0x475d4 - 0x475e0
int32_t function_475d4(int32_t a1) {
    if (a1 == 0) {
        return 0;
    }
    // 0x475dc
    return function_44f6c(a1);
}

// Address range: 0x475e0 - 0x475ec
int32_t function_475e0(int32_t a1) {
    if (a1 == 0) {
        return 0;
    }
    // 0x475e8
    return function_44f74(a1);
}

// Address range: 0x475ec - 0x475f8
int32_t function_475ec(int32_t a1) {
    // 0x475ec
    return a1 == 0 ? 0 : a1 - 16;
}

// Address range: 0x475f8 - 0x47658
int32_t function_475f8(void) {
    int32_t v1 = function_4693c(20); // 0x47600
    if (v1 == 0) {
        // 0x47640
        return 0;
    }
    // 0x4760c
    *(int32_t *)v1 = 1;
    *(int32_t *)(v1 + 4) = 1;
    *(int32_t *)(v1 + 12) = 0;
    *(int32_t *)(v1 + 8) = 8;
    int32_t v2 = function_4693c(32); // 0x4762c
    *(int32_t *)(v1 + 16) = v2;
    int32_t result = v1; // 0x4763c
    if (v2 == 0) {
        // 0x47648
        function_46954(v1);
        result = 0;
    }
    // 0x47640
    return result;
}

// Address range: 0x47658 - 0x47674
int32_t function_47658(int32_t a1) {
    // 0x47658
    if (a1 == 0) {
        return 0;
    }
    int32_t v1 = a1; // 0x47668
    if (a1 == 1) {
        v1 = *(int32_t *)13;
    }
    return a1 == 1 ? v1 : 0;
}

// Address range: 0x47674 - 0x476a8
int32_t function_47674(int32_t a1, uint32_t a2) {
    if (a1 != 1) {
        // 0x476a0
        return 0;
    }
    uint32_t v1 = *(int32_t *)13; // 0x47688
    if (v1 == a2 || v1 < a2) {
        // 0x476a0
        return 0;
    }
    // 0x47694
    return *(int32_t *)(*(int32_t *)17 + 4 * a2);
}

// Address range: 0x476a8 - 0x47780
int32_t function_476a8(int32_t a1, int32_t a2) {
    if (a1 == 0) {
        // 0x47778
        return -1;
    }
    if (a1 == 1 != (a2 == 1) || function_47170(1, *(int32_t *)13, 1) == 0) {
        // 0x47778
        return -1;
    }
    uint64_t v1 = *(int64_t *)13; // 0x476f4
    int32_t v2 = v1 / 0x100000000; // 0x476f4
    int32_t v3 = v1; // 0x47700
    int32_t v4 = 0; // 0x47700
    if (v2 != 0) {
        int32_t v5 = 0;
        int32_t v6 = v3;
        int32_t v7 = *(int32_t *)(4 * v5 + v6); // 0x47708
        int32_t v8 = v2; // 0x47710
        int32_t v9 = v6; // 0x47710
        int32_t v10; // 0x476a8
        int32_t v11; // 0x476a8
        int32_t v12; // 0x47714
        int32_t * v13; // 0x47714
        int32_t v14; // 0x47714
        int32_t v15; // 0x47728
        int32_t v16; // 0x4772c
        uint64_t v17; // 0x4773c
        int32_t v18; // 0x47728
        int32_t v19; // 0x4772c
        if (v7 != 0) {
            // 0x47714
            v12 = v7 + 4;
            v13 = (int32_t *)v12;
            v14 = *v13;
            v8 = v2;
            v9 = v6;
            if (v14 != -1) {
                // 0x47724
                v15 = v14 + 1;
                v16 = __asm_strex(v15, v14);
                v10 = v15;
                if (v16 != 0) {
                    v11 = *v13;
                    v18 = v11 + 1;
                    v19 = __asm_strex(v18, v11);
                    v10 = v18;
                    while (v19 != 0) {
                        // 0x47724
                        v11 = *v13;
                        v18 = v11 + 1;
                        v19 = __asm_strex(v18, v11);
                        v10 = v18;
                    }
                }
                // 0x47738
                __asm_dmb(0, v10, v12, v5);
                v17 = *(int64_t *)13;
                v8 = v17 / 0x100000000;
                v9 = v17;
            }
        }
        // 0x47740
        v3 = v9;
        int32_t v20 = v8;
        int32_t v21 = v5 + 1; // 0x47740
        while (v20 >= v21 == (v20 != v21)) {
            // 0x47708
            v5 = v21;
            v6 = v3;
            int32_t v22 = v20;
            v7 = *(int32_t *)(4 * v5 + v6);
            v8 = v22;
            v9 = v6;
            if (v7 != 0) {
                // 0x47714
                v12 = v7 + 4;
                v13 = (int32_t *)v12;
                v14 = *v13;
                v8 = v22;
                v9 = v6;
                if (v14 != -1) {
                    // 0x47724
                    v15 = v14 + 1;
                    v16 = __asm_strex(v15, v14);
                    v10 = v15;
                    if (v16 != 0) {
                        v11 = *v13;
                        v18 = v11 + 1;
                        v19 = __asm_strex(v18, v11);
                        v10 = v18;
                        while (v19 != 0) {
                            // 0x47724
                            v11 = *v13;
                            v18 = v11 + 1;
                            v19 = __asm_strex(v18, v11);
                            v10 = v18;
                        }
                    }
                    // 0x47738
                    __asm_dmb(0, v10, v12, v5);
                    v17 = *(int64_t *)13;
                    v8 = v17 / 0x100000000;
                    v9 = v17;
                }
            }
            // 0x47740
            v3 = v9;
            v20 = v8;
            v21 = v5 + 1;
        }
        // 0x4774c
        v4 = 4 * v20;
    }
    int32_t v23 = *(int32_t *)17; // 0x47750
    int32_t v24 = *(int32_t *)13; // 0x47754
    memcpy((int32_t *)(4 * v24 + v23), (int32_t *)v3, v4);
    *(int32_t *)13 = 2 * *(int32_t *)13;
    return 0;
}

// Address range: 0x47780 - 0x477a8
int32_t function_47780(int32_t str) {
    if (str == 0) {
        return 0;
    }
    // 0x47788
    return function_471fc(str, strlen((char *)str), 0);
}

// Address range: 0x477a8 - 0x477b0
int32_t function_477a8(void) {
    // 0x477a8
    int32_t v1; // 0x477a8
    return function_471fc(v1, v1, 0);
}

// Address range: 0x477b0 - 0x477b8
int32_t function_477b0(int32_t a1, int32_t a2) {
    // 0x477b0
    return function_471fc(a1, a2, 1);
}

// Address range: 0x477b8 - 0x477fc
int32_t function_477b8(int32_t a1, int32_t a2) {
    if (a1 == 0 || function_470a4(a1, a2) == 0) {
        // 0x477ec
        return 0;
    }
    // 0x477d8
    return function_471fc(a1, a2, 0);
}

// Address range: 0x477fc - 0x47820
int32_t function_477fc(int32_t * str) {
    int32_t result = (int32_t)str;
    if (str == NULL) {
        return result;
    }
    // 0x47804
    return function_477b8(result, strlen((char *)str));
}

// Address range: 0x47820 - 0x4783c
int32_t function_47820(int32_t a1) {
    // 0x47820
    if (a1 == 0) {
        return 0;
    }
    int32_t v1 = a1; // 0x47830
    if (a1 == 2) {
        v1 = *(int32_t *)10;
    }
    return a1 == 2 ? v1 : 0;
}

// Address range: 0x4783c - 0x47858
int32_t function_4783c(int32_t a1) {
    // 0x4783c
    if (a1 == 0) {
        return 0;
    }
    int32_t v1 = a1; // 0x4784c
    if (a1 == 2) {
        v1 = *(int32_t *)14;
    }
    return a1 == 2 ? v1 : 0;
}

// Address range: 0x47858 - 0x478bc
int32_t function_47858(int32_t a1, int32_t a2, int32_t a3) {
    if (a1 != 2) {
        // 0x478b4
        return -1;
    }
    int32_t v1 = function_4696c(a2, a3); // 0x47890
    if (v1 == 0) {
        // 0x478b4
        return -1;
    }
    // 0x4789c
    function_46954(*(int32_t *)10);
    *(int32_t *)10 = v1;
    *(int32_t *)14 = a3;
    return 0;
}

// Address range: 0x478bc - 0x478f0
int32_t function_478bc(int32_t a1, int32_t str) {
    if (str == 0) {
        // 0x478e8
        return -1;
    }
    // 0x478c8
    return function_47858(a1, str, strlen((char *)str));
}

// Address range: 0x478f0 - 0x47934
int32_t function_478f0(int32_t a1, int32_t a2, int32_t a3) {
    if (a2 == 0 || function_470a4(a2, a3) == 0) {
        // 0x4792c
        return -1;
    }
    // 0x47918
    return function_47858(a1, a2, a3);
}

// Address range: 0x47934 - 0x47968
int32_t function_47934(int32_t a1, int32_t str) {
    if (str == 0) {
        // 0x47960
        return -1;
    }
    // 0x47940
    return function_478f0(a1, str, strlen((char *)str));
}

// Address range: 0x47968 - 0x47a18
int32_t function_47968(int32_t a1, int32_t * a2) {
    int32_t v1 = (int32_t)a2;
    char * format = (char *)a1; // 0x4798c
    int32_t chars_printed = vsnprintf(NULL, 0, format, v1); // 0x4798c
    if (chars_printed == 0) {
        // 0x479e8
        return function_477b8((int32_t)&g19, 0);
    }
    int32_t size = chars_printed + 1; // 0x47998
    int32_t str = function_4693c(size); // 0x479a0
    if (str == 0) {
        // 0x479e0
        return 0;
    }
    // 0x479ac
    vsnprintf((char *)str, size, format, v1);
    int32_t result; // 0x47968
    if (function_470a4(str, chars_printed) == 0) {
        // 0x47a08
        function_46954(str);
        result = 0;
    } else {
        // 0x479d0
        result = function_471fc(str, chars_printed, 1);
    }
    // 0x479e0
    return result;
}

// Address range: 0x47a18 - 0x47a48
int32_t function_47a18(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = a2; // bp-12, 0x47a18
    return function_47968(a1, &v1);
}

// Address range: 0x47a48 - 0x47a7c
int32_t function_47a48(int32_t a1, int32_t a2) {
    int32_t result = function_4693c(16); // 0x47a58
    if (result == 0) {
        return 0;
    }
    // 0x47a64
    *(int32_t *)(result + 8) = a1;
    *(int32_t *)(result + 12) = a2;
    *(int32_t *)result = 3;
    *(int32_t *)(result + 4) = 1;
    return result;
}

// Address range: 0x47a7c - 0x47aa4
int32_t function_47a7c(int32_t a1) {
    if (a1 == 3) {
        // 0x47a9c
        return (int32_t)(*(int64_t *)11 / 0x100000000);
    }
    // 0x47a90
    return 0;
}

// Address range: 0x47aa4 - 0x47acc
int32_t function_47aa4(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    if (a1 != 3) {
        // 0x47ac4
        return -1;
    }
    // 0x47ab8
    *(int32_t *)11 = a3;
    *(int32_t *)15 = a4;
    return 0;
}

// Address range: 0x47acc - 0x47acd
int32_t function_47acc(void) {
    // 0x47acc
    int32_t result; // 0x47acc
    return result;
}

// Address range: 0x47ace - 0x47b1a
int32_t function_47ace(int32_t a1, int32_t a2, int32_t a3, uint32_t a4) {
    // 0x47ace
    int32_t v1; // 0x47ace
    uint32_t v2 = v1;
    int32_t result = unknown_4835a6(); // 0x47ace
    bool v3; // 0x47ace
    if (v3) {
        g14 = 0x47ad8;
        return result;
    }
    if (v3) {
        // 0x47ade
        function_ff08315e();
        function_12435a6();
    } else {
        // 0x47ada
        function_4622de();
    }
    uint32_t v4 = unknown_4835ba(); // 0x47ae2
    bool v5; // 0x47ace
    bool v6; // 0x47ace
    bool v7; // 0x47ace
    bool v8; // 0x47ace
    bool v9; // 0x47ace
    bool v10; // 0x47ace
    int32_t v11; // 0x47ace
    int32_t v12; // 0x47ace
    int32_t v13; // 0x47ace
    int32_t v14; // 0x47ace
    if (v3) {
        uint32_t v15 = 0x100000 * v4; // 0x47aea
        if (v15 == v4) {
            int32_t v16 = unknown_fe442c54(); // 0x47af6
            if ((v4 & v1 / 0x40000) == 0) {
                *(int32_t *)v16 = 0x47af6;
                *(int32_t *)(v16 + 4) = 0x47b00;
                int32_t v17 = v16 - (int32_t)&g15; // 0x47afa
                v11 = v17;
                v9 = true;
                v7 = false;
                v13 = v17;
                v8 = true;
                if ((v1 & 0x20000) != 0) {
                    goto lab_dec_label_pc_unknown_20;
                } else {
                    goto lab__thread17;
                }
            } else {
                v11 = v16;
                v9 = false;
                v7 = false;
                v13 = v16;
                v8 = false;
                if ((v1 & 0x20000) != 0) {
                    goto lab_dec_label_pc_unknown_20;
                } else {
                    goto lab__thread17;
                }
            }
        } else {
            if (0xfffff * v4 < 0) {
                function_48097a();
            }
            int32_t v18 = unknown_fe442c54(); // 0x47af6
            v11 = v18;
            v9 = false;
            v7 = 0xfffff * v4 < 0;
            if (v15 < v4) {
                v5 = (v18 & 64) != 0;
                v12 = v18;
                v14 = v18;
                v10 = false;
                v6 = (v18 & 64) != 0;
                if (0xfffff * v4 < 0) {
                    goto lab_dec_label_pc_unknown_21;
                } else {
                    goto lab_dec_label_pc_unknown_22;
                }
            } else {
                goto lab_dec_label_pc_unknown_20;
            }
        }
    } else {
        int32_t v19 = unknown_fe442c54(); // 0x47af6
        v11 = v19;
        v9 = false;
        v7 = false;
        v13 = v19;
        v8 = false;
        if (v3) {
            goto lab_dec_label_pc_unknown_20;
        } else {
            goto lab__thread17;
        }
    }
  lab_dec_label_pc_unknown_20:
    v5 = (v11 & 64) != 0;
    v12 = v11;
    v14 = v11;
    v10 = v9;
    v6 = (v11 & (1 << a4 - 1 | 64)) != 0;
    if (v7) {
        goto lab_dec_label_pc_unknown_21;
    } else {
        goto lab_dec_label_pc_unknown_22;
    }
  lab__thread17:
    // .thread17
    v14 = v13;
    v10 = v8;
    v6 = (v13 & 64) != 0;
    goto lab_dec_label_pc_unknown_22;
  lab_dec_label_pc_unknown_21:;
    bool v24 = v5;
    uint32_t v25 = v12 / 128; // 0x47b06
    int32_t v26 = v25 - v2 + (int32_t)!v24; // 0x47b06
    bool v27 = !v24 ? v2 != -1 | v25 < v26 - (int32_t)!v24 : v25 < v2; // 0x47b06
    v14 = v12;
    v10 = v26 == 0;
    v6 = !v27;
    goto lab_dec_label_pc_unknown_22;
  lab_dec_label_pc_unknown_22:;
    bool v20 = v10;
    int32_t result2 = v14;
    bool v21 = ((result2 & 0x200000) != 0 | v6 == ((result2 & 4) != 0)) == !v20 ? 2048 * result2 == result2 : v20;
    if (v21) {
        int16_t v22; // 0x47ace
        int16_t v23 = v22;
        *(int16_t *)result2 = v23;
    }
    return result2;
}

// Address range: 0x47b1a - 0x47b1c
int32_t function_47b1a(void) {
    // 0x47b1a
    int32_t v1; // 0x47b1a
    return function_4825e(v1);
}

// Address range: 0x47b1c - 0x47b20
int32_t function_47b1c(void) {
    // 0x47b1c
    int32_t result; // 0x47b1c
    return result;
}

// Address range: 0x47b28 - 0x47b4c
int32_t function_47b28(int32_t result) {
    if (result == 4) {
        // 0x47b44
        __asm_vldr(*(int32_t *)12);
        return 4;
    }
    // 0x47b3c
    __asm_vldr(0);
    return result;
}

// Address range: 0x47b4c - 0x47b50
int32_t function_47b4c(void) {
    // 0x47b4c
    return unknown_448190();
}

// Address range: 0x47b54 - 0x47bac
int32_t function_47b54(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x47b54
    return a1 == 0 ? -1 : a1;
}

// Address range: 0x47bac - 0x47bb0
int32_t function_47bac(void) {
    // 0x47bac
    return unknown_4481f0();
}

// Address range: 0x47bb8 - 0x47bf8
int32_t function_47bb8(int32_t result2) {
    switch (result2) {
        case 4: {
            // 0x47bdc
            __asm_vldr(*(int32_t *)12);
            return 4;
        }
        case 3: {
            uint64_t v1 = *(int64_t *)11; // 0x47be8
            int32_t v2 = v1; // 0x47be8
            int32_t result = function_4930c((int32_t)(v1 / 0x100000000), v2); // 0x47bec
            __asm_vmov_8(result, v2);
            return result;
        }
    }
    // 0x47bd4
    __asm_vldr(0);
    return result2;
}

// Address range: 0x47c00 - 0x47c0c
int32_t function_47c00(void) {
    // 0x47c00
    return &g56;
}

// Address range: 0x47c0c - 0x47c14
int32_t function_47c0c(void) {
    // 0x47c0c
    return &g57;
}

// Address range: 0x47c18 - 0x47c20
int32_t function_47c18(void) {
    // 0x47c18
    return &g58;
}

// Address range: 0x47c24 - 0x47cf0
int32_t function_47c24(int32_t result) {
    if (result == 0) {
        return result;
    }
    // 0x47c30
    g299 = result;
    int32_t v1; // 0x47c24
    switch (result) {
        case 4: {
        }
        case 3: {
            // 0x47c5c
            return function_46954(result);
        }
        case 1: {
            int32_t v2 = *(int32_t *)13; // 0x47c80
            int32_t v3 = *(int32_t *)17; // 0x47c84
            v1 = v3;
            int32_t v4 = 0; // 0x47c90
            if (v2 != 0) {
                int32_t v5 = *(int32_t *)(4 * v4 + v3); // 0x47c94
                int32_t v6 = v3; // 0x47c9c
                int32_t v7 = v2; // 0x47c9c
                int32_t v8; // 0x47c24
                int32_t v9; // 0x47cb8
                int32_t v10; // 0x47ca0
                int32_t * v11; // 0x47ca0
                if (v5 != 0) {
                    // 0x47ca0
                    v10 = v5 + 4;
                    v11 = (int32_t *)v10;
                    v6 = v3;
                    v7 = v2;
                    if (*v11 != -1) {
                        // 0x47cb0
                        __asm_dmb(v3, v2, v10, v5);
                        v8 = *v11;
                        v9 = v8 - 1;
                        while (__asm_strex(v9, v8) != 0) {
                            // 0x47cb4
                            v8 = *v11;
                            v9 = v8 - 1;
                        }
                        if (v9 == 0) {
                            // 0x47cd0
                            function_47c24(v5);
                        }
                        // 0x47cd8
                        v6 = *(int32_t *)17;
                        v7 = *(int32_t *)13;
                    }
                }
                int32_t v12 = v4 + 1; // 0x47ce0
                v1 = v6;
                v4 = v12;
                while (v12 < v7) {
                    int32_t v13 = v7;
                    int32_t v14 = v6;
                    v5 = *(int32_t *)(4 * v4 + v14);
                    v6 = v14;
                    v7 = v13;
                    if (v5 != 0) {
                        // 0x47ca0
                        v10 = v5 + 4;
                        v11 = (int32_t *)v10;
                        v6 = v14;
                        v7 = v13;
                        if (*v11 != -1) {
                            // 0x47cb0
                            __asm_dmb(v14, v13, v10, v5);
                            v8 = *v11;
                            v9 = v8 - 1;
                            while (__asm_strex(v9, v8) != 0) {
                                // 0x47cb4
                                v8 = *v11;
                                v9 = v8 - 1;
                            }
                            if (v9 == 0) {
                                // 0x47cd0
                                function_47c24(v5);
                            }
                            // 0x47cd8
                            v6 = *(int32_t *)17;
                            v7 = *(int32_t *)13;
                        }
                    }
                    // 0x47ce0
                    v12 = v4 + 1;
                    v1 = v6;
                    v4 = v12;
                }
            }
            // break -> 0x47c58
            break;
        }
        case 2: {
            // 0x47c58
            function_46954(*(int32_t *)10);
            // 0x47c5c
            return function_46954(result);
        }
        default: {
            return result;
        }
    }
    // 0x47c58
    function_46954(v1);
    // 0x47c5c
    return function_46954(result);
}

// Address range: 0x47cf0 - 0x47d80
int32_t function_47cf0(int32_t a1) {
    if (a1 != 1) {
        // 0x47d78
        return -1;
    }
    int32_t v1 = *(int32_t *)13; // 0x47d08
    int32_t v2 = 0; // 0x47d10
    if (v1 == 0) {
        // 0x47d6c
        *(int32_t *)13 = 0;
        return 0;
    }
    int32_t v3 = *(int32_t *)(*(int32_t *)17 + 4 * v2); // 0x47d1c
    int32_t v4 = v1; // 0x47d24
    int32_t v5; // 0x47d40
    int32_t v6; // 0x47d28
    int32_t * v7; // 0x47d28
    int32_t v8; // 0x47d28
    int32_t v9; // 0x47d38
    int32_t v10; // 0x47cf0
    if (v3 != 0) {
        // 0x47d28
        v6 = v3 + 4;
        v7 = (int32_t *)v6;
        v8 = *v7;
        v4 = v1;
        if (v8 != -1) {
            // 0x47d38
            v9 = __asm_dmb(v3, v8, v1, v6);
            v10 = *v7;
            v5 = v10 - 1;
            while (__asm_strex(v5, v10) != 0) {
                // 0x47d3c
                v10 = *v7;
                v5 = v10 - 1;
            }
            if (v5 == 0) {
                // 0x47d58
                function_47c24(v9);
            }
            // 0x47d5c
            v4 = *(int32_t *)13;
        }
    }
    // 0x47d60
    v2++;
    while (v4 >= v2 == (v4 != v2)) {
        int32_t v11 = v4;
        v3 = *(int32_t *)(*(int32_t *)17 + 4 * v2);
        v4 = v11;
        if (v3 != 0) {
            // 0x47d28
            v6 = v3 + 4;
            v7 = (int32_t *)v6;
            v8 = *v7;
            v4 = v11;
            if (v8 != -1) {
                // 0x47d38
                v9 = __asm_dmb(v3, v8, v11, v6);
                v10 = *v7;
                v5 = v10 - 1;
                while (__asm_strex(v5, v10) != 0) {
                    // 0x47d3c
                    v10 = *v7;
                    v5 = v10 - 1;
                }
                if (v5 == 0) {
                    // 0x47d58
                    function_47c24(v9);
                }
                // 0x47d5c
                v4 = *(int32_t *)13;
            }
        }
        // 0x47d60
        v2++;
    }
    // 0x47d6c
    *(int32_t *)13 = 0;
    return 0;
}

// Address range: 0x47d80 - 0x47d90
int32_t function_47d80(int32_t a1) {
    int32_t result = a1; // 0x47d88
    if (a1 == 0) {
        int32_t v1; // 0x47d80
        result = function_47d98(0, v1, v1, (int32_t)&g306);
    }
    // 0x47d8c
    return result;
}

// Address range: 0x47d92 - 0x47d94
int32_t function_47d92(int32_t a1) {
    // 0x47d92
    return function_4843c(a1);
}

// Address range: 0x47d94 - 0x47d98
int32_t function_47d94(void) {
    // 0x47d94
    int32_t result; // 0x47d94
    return result;
}

// Address range: 0x47d98 - 0x47de8
int32_t function_47d98(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    if (a3 == 0) {
        // 0x47dac
        return -1;
    }
    int32_t v1 = a3 + 4; // 0x47da0
    int32_t * v2 = (int32_t *)v1; // 0x47da0
    if (*v2 == -1) {
        // 0x47dac
        return -1;
    }
    // 0x47db4
    __asm_dmb(a1, a2, a3, v1);
    int32_t v3 = *v2;
    int32_t v4 = v3 - 1; // 0x47dc0
    while (__asm_strex(v4, v3) != 0) {
        // 0x47dbc
        v3 = *v2;
        v4 = v3 - 1;
    }
    if (v4 != 0) {
        // 0x47dac
        return -1;
    }
    // 0x47dd8
    function_47c24(a3);
    return -1;
}

// Address range: 0x47de8 - 0x47e18
int32_t function_47de8(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = a2; // 0x47e04
    if (a2 == 0) {
        v1 = function_47d98(a2, a2, a3, (int32_t)&g306);
    }
    // 0x47e08
    function_44f7c(v1, a3);
    return a2 == 0;
}

// Address range: 0x47e18 - 0x47ee4
int32_t function_47e18(int32_t a1, uint32_t a2) {
    // 0x47e18
    if (a1 != 1) {
        // 0x47edc
        return -1;
    }
    uint32_t v1 = *(int32_t *)13; // 0x47e30
    if (v1 == a2 || v1 < a2) {
        // 0x47edc
        return -1;
    }
    int32_t v2 = 4 * a2; // 0x47e44
    int32_t v3 = *(int32_t *)17 + v2;
    int32_t * v4 = (int32_t *)v3;
    int32_t v5 = *v4; // 0x47e48
    int32_t * v6; // 0x47e18
    int32_t v7; // 0x47e18
    int32_t v8; // 0x47e18
    if (v5 == 0) {
        goto lab_0x47e60;
    } else {
        int32_t v9 = v5 + 4; // 0x47e54
        int32_t * v10 = (int32_t *)v9; // 0x47e54
        if (*v10 == -1) {
            goto lab_0x47e60;
        } else {
            // 0x47e78
            int32_t v11; // 0x47e18
            int32_t v12 = __asm_dmb(v5, a2, v11, v9); // 0x47e7c
            int32_t v13 = *v10;
            int32_t v14 = v13 - 1; // 0x47e84
            while (__asm_strex(v14, v13) != 0) {
                // 0x47e80
                v13 = *v10;
                v14 = v13 - 1;
            }
            if (v14 == 0) {
                // 0x47e9c
                function_47c24(v12);
            }
            int32_t v15 = *(int32_t *)13; // 0x47ea0
            int32_t v16 = v15 - 1; // 0x47ea4
            if (v16 == a2 || v16 < a2) {
                // 0x47e6c
                *(int32_t *)13 = v16;
                return 0;
            }
            int32_t v17 = *(int32_t *)17 + v2;
            v6 = (int32_t *)v17;
            v7 = v17;
            v8 = v15;
            goto lab_0x47eb0;
        }
    }
  lab_0x47e60:;
    int32_t v18 = v1 - 1; // 0x47e60
    v6 = v4;
    v7 = v3;
    v8 = v1;
    if (v18 >= a2 != v18 != a2) {
        // 0x47e6c
        *(int32_t *)13 = v18;
        return 0;
    }
    goto lab_0x47eb0;
  lab_0x47eb0:
    // 0x47eb0
    memmove(v6, (int32_t *)(v7 + 4), 4 * (v8 + (a2 ^ 0x3fffffff)));
    // 0x47e6c
    *(int32_t *)13 = *(int32_t *)13 - 1;
    return 0;
}

// Address range: 0x47ee4 - 0x47fa0
int32_t function_47ee4(int32_t a1, int32_t a2, int32_t a3) {
    if (a3 == 0) {
        // 0x47f08
        return -1;
    }
    int32_t v1 = a3 + 4; // 0x47efc
    int32_t * v2 = (int32_t *)v1; // 0x47efc
    if (*v2 == -1) {
        // 0x47f08
        return -1;
    }
    // 0x47f6c
    __asm_dmb(a1, a2, a3, v1);
    int32_t v3 = *v2;
    int32_t v4 = v3 - 1; // 0x47f78
    while (__asm_strex(v4, v3) != 0) {
        // 0x47f74
        v3 = *v2;
        v4 = v3 - 1;
    }
    if (v4 != 0) {
        // 0x47f08
        return -1;
    }
    // 0x47f90
    function_47c24(a3);
    return -1;
}

// Address range: 0x47fa0 - 0x4808c
int32_t function_47fa0(int32_t a1, int32_t a2) {
    // 0x47fa0
    return -1;
}

// Address range: 0x4808c - 0x48120
int32_t function_4808c(int32_t a1, char * str, int32_t a3) {
    int32_t v1 = (int32_t)str;
    int32_t v2 = a1; // 0x48098
    int32_t len = v1; // 0x48098
    if (str != NULL) {
        // 0x4809c
        len = strlen(str);
        v2 = 0;
        if (function_470a4(v1, len) != 0) {
            // 0x4810c
            return function_47ee4(a1, v1, a3);
        }
    }
    if (a3 == 0) {
        // 0x480d0
        return -1;
    }
    int32_t v3 = a3 + 4; // 0x480c4
    int32_t * v4 = (int32_t *)v3; // 0x480c4
    if (*v4 == -1) {
        // 0x480d0
        return -1;
    }
    // 0x480d8
    __asm_dmb(v2, len, a3, v3);
    int32_t v5 = *v4;
    int32_t v6 = v5 - 1; // 0x480e4
    while (__asm_strex(v6, v5) != 0) {
        // 0x480e0
        v5 = *v4;
        v6 = v5 - 1;
    }
    if (v6 != 0) {
        // 0x480d0
        return -1;
    }
    // 0x480fc
    function_47c24(a3);
    return -1;
}

// Address range: 0x48120 - 0x48200
int32_t function_48120(int32_t a1, int32_t a2) {
    // 0x48120
    return -1;
}

// Address range: 0x48200 - 0x48254
int32_t function_48200(int32_t a1, int32_t a2) {
    if (a1 == 0) {
        int32_t v1 = function_482e8((int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306); // 0x48208
        if (v1 == 0) {
            goto lab_0x48228;
        } else {
            // 0x4820c
            function_482e8((int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306);
            goto lab_0x48228;
        }
    } else {
        // 0x4820c
        function_482e8((int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306);
        goto lab_0x48228;
    }
  lab_0x48228:
    if (a2 != 0) {
        function_482e8((int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306);
    }
    // 0x48234
    if (function_44edc(a2 + 8) != 0) {
        function_482b8((int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306, (int32_t)&g306);
    }
    // 0x4824c
    return 0;
}

// Address range: 0x48254 - 0x4825c
int32_t function_48254(void) {
    // 0x48254
    int32_t v1; // 0x48254
    return function_472ec(v1, (char *)v1);
}

// Address range: 0x4825e - 0x48264
int32_t function_4825e(int32_t a1) {
    // 0x4825e
    return function_4843c(4);
}

// Address range: 0x48264 - 0x482b8
int32_t function_48264(int32_t a1, int32_t a2, int32_t a3) {
    // 0x48264
    int32_t v1; // 0x48264
    if (a3 == -1) {
        // 0x48288
        function_47ee4(v1, v1, v1);
        return function_44f54(v1, v1);
    }
    int32_t v2 = v1 + 4; // 0x48264
    int32_t v3 = *(int32_t *)v2;
    int32_t v4 = v3 + 1; // 0x48274
    while (__asm_strex(v4, v3) != 0) {
        // 0x48270
        v3 = *(int32_t *)v2;
        v4 = v3 + 1;
    }
    // 0x48284
    __asm_dmb(a1, 0, v4, v2);
    // 0x48288
    function_47ee4(v1, v1, v1);
    return function_44f54(v1, v1);
}

// Address range: 0x482b8 - 0x482e8
int32_t function_482b8(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    // 0x482b8
    int32_t v1; // 0x482b8
    int32_t v2 = function_44f6c(v1); // 0x482b8
    if (function_44f74(v2 - 16) != 0) {
        function_48254();
    }
    // 0x482e0
    return 0;
}

// Address range: 0x482e8 - 0x482f0
int32_t function_482e8(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    // 0x482e8
    return -1;
}

// Address range: 0x482f0 - 0x4843c
int32_t function_482f0(int32_t a1, uint32_t a2, int32_t a3) {
    if (a3 == 0) {
        // 0x48338
        return -1;
    }
    int32_t v1 = a3; // 0x482f0
    int32_t v2; // 0x482f0
    switch (a1) {
        case 0: {
            goto lab_0x4832c;
        }
        case 1: {
            // 0x48374
            v1 = 0;
            if (*(int32_t *)13 < a2) {
                goto lab_0x4832c;
            } else {
                int32_t v3 = function_47170(1, 1, 0); // 0x48384
                if (v3 != 0) {
                    int32_t v4 = *(int32_t *)17; // 0x48390
                    int32_t v5 = 4 * a2; // 0x48394
                    int32_t v6 = v5 + 4; // 0x48398
                    int32_t v7 = v3 + v5; // 0x483a4
                    if (v4 == v3) {
                        int32_t v8 = *(int32_t *)13; // 0x48424
                        return (int32_t)memmove((int32_t *)(v3 + v6), (int32_t *)v7, 4 * (v8 - a2));
                    }
                    // 0x483ac
                    memcpy((int32_t *)v4, (int32_t *)v3, v5);
                    int32_t v9 = *(int32_t *)13; // 0x483b8
                    int32_t v10 = *(int32_t *)17; // 0x483c0
                    memcpy((int32_t *)(v10 + v6), (int32_t *)v7, 4 * (v9 - a2));
                    function_46954(v3);
                    *(int32_t *)(*(int32_t *)17 + v5) = a3;
                    *(int32_t *)13 = *(int32_t *)13 + 1;
                    return 0;
                }
                int32_t v11 = a3 + 4; // 0x483f8
                int32_t * v12 = (int32_t *)v11; // 0x483f8
                if (*v12 == -1) {
                    // 0x48338
                    return -1;
                }
                // 0x48404
                __asm_dmb(0, 1, 0, v11);
                int32_t v13 = *v12;
                int32_t v14 = v13 - 1; // 0x48410
                int32_t v15 = __asm_strex(v14, v13); // 0x48414
                v2 = v14;
                while (v15 != 0) {
                    // 0x4840c
                    v13 = *v12;
                    v14 = v13 - 1;
                    v15 = __asm_strex(v14, v13);
                    v2 = v14;
                }
                goto lab_0x4835c;
            }
        }
        default: {
            v1 = 1;
            goto lab_0x4832c;
        }
    }
  lab_0x4832c:;
    int32_t v16 = a3 + 4; // 0x4832c
    int32_t * v17 = (int32_t *)v16; // 0x4832c
    if (*v17 == -1) {
        // 0x48338
        return -1;
    }
    // 0x48340
    __asm_dmb(a1, a2, v1, v16);
    int32_t v18 = *v17;
    int32_t v19 = v18 - 1; // 0x4834c
    int32_t v20 = __asm_strex(v19, v18); // 0x48350
    v2 = v19;
    while (v20 != 0) {
        // 0x48348
        v18 = *v17;
        v19 = v18 - 1;
        v20 = __asm_strex(v19, v18);
        v2 = v19;
    }
    goto lab_0x4835c;
  lab_0x4835c:
    // 0x4835c
    if (v2 != 0) {
        // 0x48338
        return -1;
    }
    // 0x48364
    function_47c24(a3);
    return -1;
}

// Address range: 0x4843c - 0x4843d
int32_t function_4843c(int32_t a1) {
    // 0x4843c
    int32_t result; // 0x4843c
    return result;
}

// Address range: 0x48440 - 0x4854c
int32_t function_48440(int32_t a1, uint32_t a2, int32_t a3) {
    // 0x48440
    if (a3 == 0) {
        // 0x4848c
        return -1;
    }
    if (a1 == 1) {
        uint32_t v1 = *(int32_t *)13; // 0x484c4
        if (v1 != a2 && v1 >= a2) {
            int32_t v2 = 4 * a2; // 0x484d4
            int32_t v3 = *(int32_t *)17 + v2; // 0x484d8
            int32_t v4 = *(int32_t *)v3; // 0x484d8
            if (v4 == 0) {
                // 0x484f4
                *(int32_t *)v3 = a3;
                // 0x4848c
                return 0;
            }
            int32_t v5 = v4 + 4; // 0x484e8
            int32_t * v6 = (int32_t *)v5; // 0x484e8
            int32_t v7 = *v6; // 0x484e8
            if (v7 == -1) {
                // 0x484f4
                *(int32_t *)v3 = a3;
                // 0x4848c
                return 0;
            }
            int32_t v8 = __asm_dmb(v4, v7, a3, v5); // 0x48504
            int32_t v9 = *v6;
            int32_t v10 = v9 - 1; // 0x4850c
            while (__asm_strex(v10, v9) != 0) {
                // 0x48508
                v9 = *v6;
                v10 = v9 - 1;
            }
            if (v10 == 0) {
                // 0x4852c
                function_47c24(v8);
            }
            // 0x484f4
            *(int32_t *)(*(int32_t *)17 + v2) = a3;
            // 0x4848c
            return 0;
        }
    }
    int32_t v11 = a3 + 4; // 0x4847c
    int32_t * v12 = (int32_t *)v11; // 0x4847c
    if (*v12 == -1) {
        // 0x4848c
        return -1;
    }
    // 0x48494
    __asm_dmb(a1, a2, a3, v11);
    int32_t v13 = *v12;
    int32_t v14 = v13 - 1; // 0x484a0
    while (__asm_strex(v14, v13) != 0) {
        // 0x4849c
        v13 = *v12;
        v14 = v13 - 1;
    }
    // 0x484b0
    if (v14 == 0) {
        // 0x484b8
        function_47c24(a3);
    }
    // 0x4848c
    return -1;
}

// Address range: 0x4854c - 0x48628
int32_t function_4854c(int32_t a1, int32_t a2) {
    // 0x4854c
    if (a2 == 0) {
        // 0x48590
        return -1;
    }
    int32_t v1; // 0x4854c
    if (a1 == 1) {
        // 0x485cc
        if (function_47170(1, 1, 1) != 0) {
            int32_t v2 = *(int32_t *)13; // 0x485e0
            *(int32_t *)(*(int32_t *)17 + 4 * v2) = a2;
            *(int32_t *)13 = v2 + 1;
            return 0;
        }
        int32_t v3 = a2 + 4; // 0x485fc
        int32_t * v4 = (int32_t *)v3; // 0x485fc
        if (*v4 == -1) {
            // 0x48590
            return -1;
        }
        // 0x48608
        __asm_dmb(0, 1, 1, v3);
        int32_t v5 = *v4;
        int32_t v6 = v5 - 1; // 0x48614
        int32_t v7 = __asm_strex(v6, v5); // 0x48618
        v1 = v6;
        while (v7 != 0) {
            // 0x48610
            v5 = *v4;
            v6 = v5 - 1;
            v7 = __asm_strex(v6, v5);
            v1 = v6;
        }
    } else {
        int32_t v8 = a2 + 4; // 0x48584
        int32_t * v9 = (int32_t *)v8; // 0x48584
        if (*v9 == -1) {
            // 0x48590
            return -1;
        }
        // 0x48598
        int32_t v10; // 0x4854c
        __asm_dmb(a1, a2, v10, v8);
        int32_t v11 = *v9;
        int32_t v12 = v11 - 1; // 0x485a4
        int32_t v13 = __asm_strex(v12, v11); // 0x485a8
        v1 = v12;
        while (v13 != 0) {
            // 0x485a0
            v11 = *v9;
            v12 = v11 - 1;
            v13 = __asm_strex(v12, v11);
            v1 = v12;
        }
    }
    // 0x485b4
    if (v1 != 0) {
        // 0x48590
        return -1;
    }
    // 0x485bc
    function_47c24(a2);
    return -1;
}

// Address range: 0x48628 - 0x48640
int32_t function_48628(int32_t a1, int32_t a2) {
    if (a1 == 0 || a2 == 0) {
        // 0x48638
        return 0;
    }
    // 0x48634
    return function_47314(a1, a2);
}

// Address range: 0x48640 - 0x487fc
int32_t function_48640(int32_t a1) {
    if (a1 == 0) {
        // 0x48680
        return 0;
    }
    // 0x4864c
    g304 = a1;
    int32_t result = a1; // 0x48654
    switch (a1) {
        case 7: {
            return result;
        }
        case 1: {
            int32_t v1 = function_475f8(); // 0x48730
            result = v1;
            switch (v1) {
                case 0: {
                    return 0;
                }
                case 1: {
                    int32_t v2 = *(int32_t *)13; // 0x48748
                    if (v2 == 0) {
                        // 0x48680
                        return 1;
                    }
                    uint32_t v3 = 0;
                    uint32_t v4 = v2;
                    int32_t v5 = 0; // 0x48774
                    int32_t v6; // 0x48640
                    int32_t v7; // 0x48640
                    int32_t v8; // 0x4877c
                    int32_t v9; // 0x48784
                    int32_t * v10; // 0x4878c
                    int32_t v11; // 0x4878c
                    int32_t v12; // 0x4879c
                    int32_t v13; // 0x487a0
                    int32_t v14; // 0x4879c
                    int32_t v15; // 0x487a0
                    if (v4 != v3 && v4 >= v3) {
                        // 0x48778
                        v8 = *(int32_t *)(*(int32_t *)17 + 4 * v3);
                        v5 = 0;
                        if (v8 != 0) {
                            // 0x4878c
                            v9 = v8 + 4;
                            v10 = (int32_t *)v9;
                            v11 = *v10;
                            v5 = v8;
                            if (v11 != -1) {
                                // 0x48798
                                v12 = v11 + 1;
                                v13 = __asm_strex(v12, v11);
                                v6 = v12;
                                if (v13 != 0) {
                                    v7 = *v10;
                                    v14 = v7 + 1;
                                    v15 = __asm_strex(v14, v7);
                                    v6 = v14;
                                    while (v15 != 0) {
                                        // 0x48798
                                        v7 = *v10;
                                        v14 = v7 + 1;
                                        v15 = __asm_strex(v14, v7);
                                        v6 = v14;
                                    }
                                }
                                // 0x487ac
                                __asm_dmb(0, v8, v9, v6);
                                v5 = v8;
                            }
                        }
                    }
                    // 0x487b0
                    result = 1;
                    while (function_4854c(1, v5) == 1) {
                        uint32_t v16 = *(int32_t *)13; // 0x4875c
                        int32_t v17 = v3 + 1; // 0x48760
                        result = 1;
                        if (v17 >= v16) {
                            // break -> 0x48680
                            break;
                        }
                        v3 = v17;
                        v4 = v16;
                        v5 = 0;
                        if (v4 != v3 && v4 >= v3) {
                            // 0x48778
                            v8 = *(int32_t *)(*(int32_t *)17 + 4 * v3);
                            v5 = 0;
                            if (v8 != 0) {
                                // 0x4878c
                                v9 = v8 + 4;
                                v10 = (int32_t *)v9;
                                v11 = *v10;
                                v5 = v8;
                                if (v11 != -1) {
                                    // 0x48798
                                    v12 = v11 + 1;
                                    v13 = __asm_strex(v12, v11);
                                    v6 = v12;
                                    if (v13 != 0) {
                                        v7 = *v10;
                                        v14 = v7 + 1;
                                        v15 = __asm_strex(v14, v7);
                                        v6 = v14;
                                        while (v15 != 0) {
                                            // 0x48798
                                            v7 = *v10;
                                            v14 = v7 + 1;
                                            v15 = __asm_strex(v14, v7);
                                            v6 = v14;
                                        }
                                    }
                                    // 0x487ac
                                    __asm_dmb(0, v8, v9, v6);
                                    v5 = v8;
                                }
                            }
                        }
                        // 0x487b0
                        result = 1;
                    }
                    // 0x48680
                    return result;
                }
                default: {
                    return result;
                }
            }
        }
        case 2: {
            uint64_t v18 = *(int64_t *)10; // 0x487cc
            return function_471fc((int32_t)(v18 / 0x100000000), (int32_t)v18, 0);
        }
        case 3: {
            // 0x487dc
            return function_47120(3);
        }
        case 4: {
            // 0x487e8
            __asm_vldr(*(int32_t *)12);
            return function_47acc();
        }
        case 5: {
            return result;
        }
        case 6: {
            return result;
        }
        default: {
            return 0;
        }
    }
}

// Address range: 0x487fc - 0x48960
int32_t function_487fc(int32_t a1) {
    if (a1 == 0) {
        // 0x4883c
        return 0;
    }
    // 0x48808
    g305 = a1;
    int32_t result = a1; // 0x48810
    switch (a1) {
        case 7: {
            return result;
        }
        case 1: {
            int32_t v1 = function_475f8(); // 0x488c0
            result = v1;
            switch (v1) {
                case 0: {
                    return 0;
                }
                case 1: {
                    int32_t v2 = *(int32_t *)13; // 0x488d8
                    if (v2 == 0) {
                        // 0x4883c
                        return 1;
                    }
                    uint32_t v3 = 0;
                    uint32_t v4 = v2;
                    int32_t v5 = 0; // 0x48904
                    if (v4 >= v3 == (v4 != v3)) {
                        v5 = *(int32_t *)(*(int32_t *)17 + 4 * v3);
                    }
                    int32_t v6 = function_487fc(v5); // 0x4890c
                    result = 1;
                    while (function_4854c(1, v6) == 1) {
                        uint32_t v7 = *(int32_t *)13; // 0x488ec
                        int32_t v8 = v3 + 1; // 0x488f0
                        result = 1;
                        if (v8 >= v7) {
                            // break -> 0x4883c
                            break;
                        }
                        v3 = v8;
                        v4 = v7;
                        v5 = 0;
                        if (v4 >= v3 == (v4 != v3)) {
                            v5 = *(int32_t *)(*(int32_t *)17 + 4 * v3);
                        }
                        v6 = function_487fc(v5);
                        result = 1;
                    }
                    // 0x4883c
                    return result;
                }
                default: {
                    return result;
                }
            }
        }
        case 2: {
            uint64_t v9 = *(int64_t *)10; // 0x48930
            return function_471fc((int32_t)(v9 / 0x100000000), (int32_t)v9, 0);
        }
        case 3: {
            // 0x48940
            return function_47120(3);
        }
        case 4: {
            // 0x4894c
            __asm_vldr(*(int32_t *)12);
            return function_47acc();
        }
        case 5: {
            return result;
        }
        case 6: {
            return result;
        }
        default: {
            return 0;
        }
    }
}

// Address range: 0x48960 - 0x489c4
int32_t function_48960(int32_t a1, int32_t a2) {
    char * str = (char *)a2; // 0x48970
    uint32_t len = strlen(str); // 0x48970
    if (len == 79 || len < 79) {
        // 0x489b0
        return (int32_t)strncpy((char *)(a1 + 12), str, len + 1);
    }
    // 0x48980
    *(int16_t *)(a1 + 12) = 0x2e2e;
    *(char *)(a1 + 14) = *(char *)((int32_t)"..." + 2);
    return (int32_t)strncpy((char *)(a1 + 15), (char *)(a2 - 76 + len), 77);
}

// Address range: 0x489c4 - 0x48a04
int32_t function_489c4(int32_t result, char * a2) {
    if (result == 0) {
        return 0;
    }
    int32_t v1 = (int32_t)a2;
    *(char *)(result + 92) = 0;
    *(int32_t *)(result + 8) = 0;
    *(int32_t *)result = -1;
    *(int32_t *)(result + 4) = -1;
    if (a2 != NULL) {
        // 0x489fc
        return function_48960(result, v1);
    }
    // 0x489f4
    *(char *)(result + 12) = (char)v1;
    return result;
}

// Address range: 0x48a04 - 0x48a14
int32_t function_48a04(int32_t result, int32_t a2) {
    if (result == 0 || a2 == 0) {
        return result;
    }
    // 0x48a10
    return function_48960(result, a2);
}

// Address range: 0x48a14 - 0x48a78
int32_t function_48a14(int32_t result, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t format) {
    if (result == 0) {
        // 0x48a38
        return result;
    }
    char * str = (char *)(result + 92); // 0x48a2c
    if (*str != 0) {
        // 0x48a38
        return result;
    }
    // 0x48a40
    *(int32_t *)result = a2;
    *(int32_t *)(result + 4) = a3;
    *(int32_t *)(result + 8) = a4;
    int32_t v1; // 0x48a14
    int32_t chars_printed = vsnprintf(str, 159, (char *)format, (int32_t)&v1); // 0x48a60
    *(char *)(result + 250) = 0;
    *(char *)(result + 251) = (char)a5;
    return chars_printed;
}

// Address range: 0x48a78 - 0x48ac4
int32_t function_48a78(int32_t result, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t format, int32_t a7) {
    if (result == 0) {
        return result;
    }
    char * str = (char *)(result + 92); // 0x48a84
    if (*str != 0) {
        return result;
    }
    // 0x48a90
    *(int32_t *)result = a2;
    *(int32_t *)(result + 4) = a3;
    *(int32_t *)(result + 8) = a4;
    int32_t chars_printed = vsnprintf(str, 159, (char *)format, a7); // 0x48ab0
    *(char *)(result + 250) = 0;
    *(char *)(result + 251) = (char)a5;
    return chars_printed;
}

// Address range: 0x48ac8 - 0x48acc
int32_t function_48ac8(void) {
    int32_t result; // 0x48ac8
    return result;
}

// Address range: 0x48acc - 0x48ace
int32_t function_48acc(void) {
    // 0x48acc
    int32_t result; // 0x48acc
    return result;
}

// Address range: 0x48ace - 0x48d24
int32_t function_48ace(uint32_t result, uint32_t a2, int32_t a3) {
    // 0x48ace
    bool v1; // 0x48ace
    if (!v1) {
        // 0x48d1a
        return function_49398((int32_t)(result != 0), a2);
    }
    if (result == a2 || result < a2) {
        if (result == a2) {
            __asm_ite();
        }
        return result == a2;
    }
    if ((a3 & a2) == 0) {
        // 0x48d0c
        return result >> (llvm_ctlz_i32(a2, true) ^ 31);
    }
    // 0x48ade
    __asm_adr(16);
    return result;
}

// Address range: 0x48d24 - 0x48d34
int32_t function_48d24(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x48d24
    bool v1; // 0x48d24
    int32_t v2; // 0x48d24
    if (v1 || false) {
        if (0x40000 * result + (int32_t)((result & 0x4000) == 0) - v2 < 0) {
            __asm_mcr2(7, 6, 0x48d34, 12, 15, 7);
            *(int16_t *)v2 = (int16_t)(v2 / 0x40000 & a4);
            return result;
        }
    } else {
        if (v1) {
            __asm_mcr2(7, 6, 0x48d34, 12, 15, 7);
            *(int16_t *)v2 = (int16_t)(v2 / 0x40000 & a4);
            return result;
        }
    }
    // .thread
    __asm_mcr2(7, 6, 0x48d34, 12, 15, 7);
    return result;
}

// Address range: 0x48d34 - 0x48d3e
int32_t function_48d34(int32_t result, int32_t a2, int32_t a3) {
    // 0x48d34
    return result;
}

// Address range: 0x48d40 - 0x48d41
int32_t function_48d40(void) {
    // 0x48d40
    int32_t result; // 0x48d40
    return result;
}

// Address range: 0x48d42 - 0x48fd4
int32_t function_48d42(int32_t a1, int32_t a2) {
    // 0x48d42
    bool v1; // 0x48d42
    if (v1) {
        int32_t v2 = a1; // 0x48fc4
        if (a1 > 0) {
            v2 = __asm_it();
        }
        int32_t v3 = a1 > 0 ? 0x7fffffff : v2; // 0x48fca
        if (a1 < 0) {
            v3 = __asm_it();
        }
        return function_49398(a1 >= 0 ? v3 : -0x80000000, a2);
    }
    int32_t v4 = a1; // 0x48d4a
    if (v1) {
        v4 = __asm_it();
    }
    int32_t v5 = a2 ^ a1; // 0x48d46
    int32_t v6 = v4;
    uint32_t v7 = v1 ? -a2 : a2;
    if (v7 == 1) {
        int32_t v8 = v6; // 0x48f96
        if ((v6 ^ v5) < 0) {
            v8 = __asm_it();
        }
        int32_t v9 = v8;
        return (v6 ^ v5) < 0 ? -v9 : v9;
    }
    int32_t v10 = v6; // 0x48d56
    if (v6 < 0) {
        v10 = __asm_it();
    }
    uint32_t v11 = v6 < 0 ? -v10 : v6;
    if (v11 == v7 || v11 < v7) {
        int32_t v12 = v10; // 0x48f9c
        if (v11 < v7) {
            v12 = __asm_it();
        }
        int32_t v13 = v11 >= v7 ? v12 : 0; // 0x48fa0
        if (v11 == v7) {
            v13 = __asm_itt();
        }
        return v11 == v7 ? v5 >> 31 | 1 : v13;
    }
    if ((v7 - 1 & v7) != 0) {
        // 0x48d66
        __asm_adr(16);
        return 0;
    }
    int32_t v14 = v11 >> (llvm_ctlz_i32(v7, true) ^ 31); // 0x48fbc
    if (v5 < 0) {
        v14 = __asm_it();
    }
    int32_t v15 = v14;
    return v5 < 0 ? -v15 : v15;
}

// Address range: 0x48fd4 - 0x48fee
int32_t function_48fd4(int32_t result, int32_t a2) {
    // 0x48fd4
    return result;
}

// Address range: 0x48ff0 - 0x49000
int32_t function_48ff0(int32_t a1, int32_t a2) {
    // 0x48ff0
    bool v1; // 0x48ff0
    if (v1) {
        __asm_smlabbmi(a2, a1, 0x48ff8);
    }
    if (v1) {
        return unknown_83();
    }
    // 0x48ffc
    return function_14364c4();
}

// Address range: 0x49000 - 0x49004
int32_t function_49000(void) {
    // 0x49000
    return function_140a10c();
}

// Address range: 0x49004 - 0x49008
int32_t function_49004(void) {
    // 0x49004
    return function_fe54a518();
}

// Address range: 0x49008 - 0x49014
int32_t function_49008(void) {
    bool v1; // 0x49008
    if (v1) {
        __asm_svceq(0x2ea90);
    }
    return function_1578c94();
}

// Address range: 0x49014 - 0x49018
int32_t function_49014(void) {
    // 0x49014
    return function_158c01c();
}

// Address range: 0x49018 - 0x4901c
int32_t function_49018(void) {
    // 0x49018
    return function_200c028();
}

// Address range: 0x4901c - 0x49020
int32_t function_4901c(void) {
    // 0x4901c
    return function_20201b4();
}

// Address range: 0x49020 - 0x49272
int32_t function_49020(int32_t a1, uint32_t a2, int32_t a3, uint32_t a4, int32_t a5, int32_t a6) {
    // 0x49020
    int32_t v1; // 0x49020
    uint32_t v2 = v1;
    bool v3; // 0x49020
    if (v3) {
        int32_t result; // 0x49020
        if (v2 > 0xffdfffff) {
            int32_t v4 = __asm_itt(); // 0x49258
            result = v4;
            if ((v4 || 0x1000 * a2) == 0) {
                result = __asm_itte();
            }
            // 0x4923c
            return result;
        }
        int32_t v5 = __asm_it(); // 0x491fa
        if (v2 == (int32_t)*(char *)(v2 + a2)) {
            v5 = __asm_it();
            if (v5 == a3) {
                if (a2 != a4) {
                    __asm_ittt();
                    // 0x4923c
                    return 0;
                }
                if (v2 < 0x200000) {
                    uint32_t v6 = 2 * a2; // 0x49222
                    result = 2 * a3;
                    if (a3 < 0 ? (v6 || (int32_t)(a3 < 0)) <= a2 : v6 < a2) {
                        result = __asm_it();
                    }
                } else {
                    // 0x4922c
                    result = 0;
                    if ((v2 ^ -0x400000) >= 0x400000) {
                        result = __asm_itt();
                    }
                }
                // 0x4923c
                return result;
            }
        }
        int32_t v7 = v5; // 0x49206
        if ((v5 || v2) == 0) {
            v7 = __asm_itt();
        }
        // 0x4923c
        return (v5 | v2) == 0 ? a3 : v7;
    }
    int32_t v8 = a1; // 0x4902e
    if (v2 >= 0x200000) {
        v8 = __asm_it();
    }
    if (v2 >= 0x6c00000 == ((v2 & -0x200000) != 0x6c00000)) {
        // 0x4923c
        return __asm_it();
    }
    int32_t v9 = a2 % 0x100000 | 0x100000; // 0x49060
    int32_t v10 = v8; // 0x49064
    int32_t v11 = v9; // 0x49064
    if (a2 <= 0xffffffff) {
        // 0x49066
        v10 = -v8;
        v11 = -1 * v9 - 1;
    }
    int32_t v12 = v11;
    int32_t v13 = a4 % 0x100000 | 0x100000; // 0x49074
    int32_t v14 = a3; // 0x49078
    int32_t v15 = v13; // 0x49078
    if (a4 <= 0xffffffff) {
        // 0x4907a
        v14 = -a3;
        v15 = -1 * v13 - 1;
    }
    int32_t v16 = v10; // 0x491de
    if (v2 < 0x200000) {
        v16 = __asm_itte();
    }
    uint32_t v17 = v2 / 0x200000; // 0x49026
    int32_t v18 = v15 ^ 0x100000; // 0x491da
    int32_t v19 = v2 < 0x200000 ? v12 ^ 0x100000 : v12;
    uint32_t v20 = v2 < 0x200000 ? 0 : v17 - 1;
    uint32_t v21 = 32 - v20; // 0x4908c
    int32_t v22; // 0x49020
    int32_t v23; // 0x49020
    int32_t v24; // 0x49020
    if (v20 > 32) {
        int32_t v25 = v16; // 0x490bc
        if ((v18 & 0x80000000 >> v21 + 31) != 0) {
            v25 = __asm_it();
        }
        int32_t v26 = v18 << v21 + 32; // 0x490b8
        int32_t v27 = v18 >> v20 - 32; // 0x490c2
        v23 = v25 + v27;
        v22 = (v18 & 0x80000000 >> v21 + 31) != 0 ? v26 | 2 : v26;
        v24 = (v27 >> 31) + v19 + (int32_t)((v27 & 0x40000000) != 0);
    } else {
        uint32_t v28 = v16 + (v14 >> v20); // 0x4909a
        v23 = v28 + (v18 << v21);
        v22 = v14 << v21;
        v24 = (v18 >> v20) + v19 + (int32_t)((v18 & 1 << v20 - 1) != 0) + (int32_t)(v28 < v16);
    }
    int32_t v29 = v22;
    int32_t v30 = v23;
    int32_t v31 = v30; // 0x490d0
    int32_t v32 = v24; // 0x490d0
    int32_t v33 = v29; // 0x490d0
    if (v24 < 0) {
        // 0x490d2
        v31 = (int32_t)(v29 != 0) - v30;
        bool v34 = v29 != 0 ? v30 != -1 | v31 != (int32_t)(v29 != 0) : v30 != 0; // 0x490da
        v32 = (int32_t)v34 - v24;
        v33 = -v29;
    }
    int32_t v35 = v17 + (int32_t)(v2 < 0x200000);
    int32_t v36 = v33;
    uint32_t v37 = v31;
    bool v38; // 0x49020
    int32_t v39; // 0x49020
    bool v40; // 0x49020
    int32_t v41; // 0x49020
    int32_t v42; // 0x49020
    int32_t v43; // 0x49020
    int32_t v44; // 0x49020
    int32_t v45; // 0x49020
    int32_t v46; // 0x49020
    int32_t v47; // 0x49020
    int32_t v48; // 0x49120
    int32_t v49; // 0x49146
    if (v32 < 0x100000) {
        // 0x49120
        v48 = 2 * v36;
        uint32_t v50 = 2 * v37; // 0x49124
        int32_t v51 = v50 | (int32_t)(v36 < 0); // 0x49124
        v44 = v51;
        v41 = v48;
        if ((v32 & 0x80000) == 0) {
            bool v52 = v36 < 0 ? v51 <= v37 : v50 < v37; // 0x49124
            int32_t v53 = 2 * v32 | (int32_t)v52; // 0x49126
            int32_t v54; // 0x49020
            if (v53 == 0) {
                int32_t v55 = __asm_itt(); // 0x49138
                v54 = llvm_ctlz_i32(v55, true);
                v47 = v55;
                v42 = __asm_it();
            } else {
                v54 = llvm_ctlz_i32(v53, true);
                v47 = v53;
                v42 = v51;
            }
            int32_t v56 = v54;
            int32_t v57 = v53 == 0 ? v56 | 32 : v56;
            v49 = v57 - 11;
            int32_t v58 = v57 - 43; // 0x4914a
            v46 = v58;
            v38 = v58 < 0;
            v40 = v49 == 32;
            v39 = v49 & 42 - v57;
            if (v49 > 31) {
                goto lab_0x4916a;
            } else {
                int32_t v59 = v57 - 31; // 0x49150
                if (v59 < 1) {
                    // 0x49166
                    v46 = v49;
                    v38 = v59 != 0;
                    v40 = v59 == 0;
                    v39 = v59 & v57 + 0x7fffffd5;
                    goto lab_0x4916a;
                } else {
                    // 0x49154
                    v43 = v47 << v49;
                    v45 = v47 >> 43 - v57;
                    goto lab_0x49180;
                }
            }
        } else {
            goto lab_0x49108;
        }
    } else {
        // 0x490e8
        v44 = v37;
        v41 = v36;
        if (v32 >= 0x200000) {
            // 0x490ee
            v44 = (int32_t)(v32 % 2 != 0) << 32 - v37 | (int32_t)((int64_t)v37 << (int64_t)(33 - v37));
            v41 = (int32_t)((1 << v37 - 1 & v37) != 0) << 32 - v36 | (int32_t)((int64_t)v36 << (int64_t)(33 - v36));
            if ((0x200000 * v35 ^ -0x400000) < 0x400000) {
                // 0x4923c
                return 0;
            }
        }
        goto lab_0x49108;
    }
  lab_0x49108:;
    int32_t v60 = v41;
    int32_t v61 = v44; // 0x4910c
    if (v60 == -0x80000000) {
        v61 = __asm_it();
    }
    bool v62 = v60 == -0x80000000 ? v61 % 2 != 0 : v60 <= -1;
    return v61 + (int32_t)v62;
  lab_0x4916a:;
    bool v63 = v40 | v38 != v39 < 0; // 0x4916a
    int32_t v64; // 0x49020
    int32_t v65; // 0x49020
    if (v63) {
        v64 = __asm_it() >> 32 - v46;
        v65 = __asm_itt();
    } else {
        v64 = v42 >> v48;
        v65 = v42;
    }
    v43 = v65 << (v63 ? v46 : 0);
    v45 = (v63 ? v64 : 0) | v47 << v46;
    goto lab_0x49180;
  lab_0x49180:;
    uint32_t v66 = v35 - 2; // 0x4912e
    if (v66 >= v49) {
        // 0x4923c
        return __asm_ittt();
    }
    int32_t v67 = v66 - v49; // 0x49180
    uint32_t v68 = -32 - v67; // 0x49190
    if (v67 < -31) {
        // 0x491ce
        return v45 >> v68;
    }
    // 0x49194
    if (v68 > -12) {
        // 0x491b6
        return v45 << -v68 | v43 >> v68 + 32;
    }
    // 0x49198
    return v45 << -v68 | v43 >> v68 + 32;
}

// Address range: 0x49274 - 0x49292
int32_t function_49274(int32_t a1) {
    int32_t result = a1; // 0x49278
    if (a1 == 0) {
        result = __asm_itt();
    }
    return result;
}

// Address range: 0x49294 - 0x492b6
int32_t function_49294(int32_t a1) {
    if (a1 == 0) {
        // .thread
        return __asm_itt();
    }
    int32_t v1 = a1; // 0x492ac
    if (a1 < 0) {
        v1 = __asm_it();
    }
    int32_t v2 = v1;
    return a1 < 0 ? -v2 : v2;
}

// Address range: 0x492b8 - 0x492bc
int32_t function_492b8(void) {
    // 0x492b8
    return function_14093c8();
}

// Address range: 0x492bc - 0x492c0
int32_t function_492bc(void) {
    // 0x492bc
    return function_1409a4c();
}

// Address range: 0x492c0 - 0x492c4
int32_t function_492c0(void) {
    // 0x492c0
    return function_140978c();
}

// Address range: 0x492c4 - 0x492fa
int32_t function_492c4(int32_t a1, int32_t a2, uint32_t a3) {
    // 0x492c4
    *(char *)a1 = (char)a3;
    bool v1; // 0x492c4
    int32_t result; // 0x492c4
    int32_t v2; // 0x492c4
    bool v3; // 0x492c4
    if (v3) {
        // .thread3
        int32_t v4; // 0x492c4
        v1 = v4 == -0x1000000;
        v2 = a1;
        goto lab_0x492d6;
    } else {
        int32_t v5 = __asm_itttt(); // 0x492c6
        result = v5;
        v1 = a3 > 0xfeffffff;
        v2 = v5;
        switch (a3 & -0x1000000) {
            case -0x1000000: {
                goto lab_0x492d6;
            }
            case 0: {
                goto lab_0x492d6;
            }
            default: {
                return result;
            }
        }
    }
  lab_0x492d6:
    if (a3 % 0x1000000 == 0) {
        // .thread
        return __asm_it();
    }
    result = v2;
    if (v1) {
        result = __asm_itt();
    }
    return result;
}

// Address range: 0x492fc - 0x49304
int32_t function_492fc(int64_t a1, int64_t a2) {
    // 0x492fc
    bool v1; // 0x492fc
    if (v1) {
        __asm_andeq((int32_t)a2, 80, 20);
    }
    int32_t v2; // 0x492fc
    return (v1 ? v2 : 0) + (int32_t)a1;
}

// Address range: 0x49304 - 0x4930c
int32_t function_49304(void) {
    // 0x49304
    int32_t v1; // 0x49304
    return function_49322(v1, v1);
}

// Address range: 0x4930c - 0x49314
int32_t function_4930c(int32_t a1, int32_t a2) {
    // 0x4930c
    bool v1; // 0x4930c
    if (v1) {
        __asm_andeq(a2, 80, 20);
    }
    int32_t v2; // 0x4930c
    return (v1 ? v2 : 0) + a1;
}

// Address range: 0x49314 - 0x49322
int32_t function_49314(int32_t a1, uint32_t a2) {
    int32_t v1 = a1; // 0x4931a
    if (a2 >= 0) {
        v1 = function_49322(a1, a2);
    }
    // 0x4931c
    return -v1;
}

// Address range: 0x49322 - 0x49366
int32_t function_49322(int32_t a1, uint32_t a2) {
    // 0x49322
    uint32_t v1; // 0x49346
    if (a2 < 0x2000000) {
        v1 = 3 + (int32_t)(a2 < 0);
        return a2 << 32 - v1 | a1 >> v1;
    }
    int32_t v2 = __asm_it(); // 0x49342
    int32_t v3 = 6; // 0x49342
    if (a2 >= 0x10000000) {
        // .thread
        v2 = __asm_it();
        v3 = 9;
    }
    v1 = v3 + (int32_t)(a2 < 0);
    return a2 << 32 - v1 | v2 >> v1;
}

// Address range: 0x49368 - 0x49380
int32_t function_49368(int32_t result, int32_t a2) {
    // .thread2
    return result;
    int32_t v1; // 0x49368
    *(int32_t *)(v1 - 36) = result;
    *(int32_t *)(v1 - 32) = a2;
    int32_t v2; // 0x49368
    int32_t v3 = &v2;
    *(int32_t *)(v1 - 8) = v3;
    *(int32_t *)(v1 - 4) = 0x49370;
    __asm_svclt(0x82900);
    __asm_svclt(0x1c2800);
    bool v4; // 0x49368
    if (v4) {
        *(int32_t *)(v1 - 4) = v3;
        *(int32_t *)(v1 - 12) = 0x49384;
    }
    // .thread2
    return result;
}

// Address range: 0x49380 - 0x49398
int32_t function_49380(void) {
    // 0x49380
    int32_t result; // 0x49380
    return result;
}

// Address range: 0x49398 - 0x493a4
int32_t function_49398(int32_t a1, int32_t a2) {
    // 0x49398
    return raise(8);
}

// Address range: 0x493a4 - 0x493b0
int32_t function_493a4(void) {
    // 0x493a4
    bool v1; // 0x493a4
    if (v1) {
        function_6444b0();
    }
    if (!v1) {
        function_ff084e84();
    }
    // 0x493ac
    return unknown_484f78();
}

// Address range: 0x493b0 - 0x493c8
int32_t function_493b0(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x493b0
    bool v1; // 0x493b0
    if (v1) {
        // 0x493b6
        return -function_493c8(a1, -a2, a3, a4);
    }
    // 0x493b2
    return function_493c8(a1, a2, a3, a4);
}

// Address range: 0x493c8 - 0x49410
int32_t function_493c8(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x493c8
    bool v1; // 0x493c8
    if (!v1) {
        function_344a4c();
    }
    if (v1) {
        function_6044d8();
    }
    if (!v1) {
        function_344a54();
    }
    if (!v1) {
        function_244c74();
        function_ff244ed0();
    }
    if (v1) {
        function_1244ec4();
    }
    if (!v1) {
        function_484c44();
    }
    int32_t v2; // 0x493c8
    if (v1) {
        // 0x493e8
        v2 = function_11c4bfc();
    } else {
        // 0x493e8
        v2 = function_ff204fe0();
    }
    int32_t result = v2; // 0x493ec
    if (v1) {
        result = function_fe484c50();
    }
    if (v1 == !v1) {
        return result;
    }
    if (!v1) {
        __asm_ldcllo(0, 0, result);
    }
    if (v1 == result > -1 != v1) {
        __asm_svclt(0x84ff0);
    }
    return result ^ (int32_t)v1;
}

// Address range: 0x49410 - 0x4951e
int32_t function_49410(uint32_t a1, int32_t a2, uint32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11, int32_t a12) {
    // 0x49410
    int32_t v1; // 0x49410
    int32_t v2; // 0x49410
    int32_t result; // 0x49410
    int32_t v3; // 0x49410
    int32_t v4; // 0x49410
    int32_t v5; // 0x49410
    if (a1 < a3) {
        __asm_it();
        result = __asm_it();
        v4 = a1;
        v5 = a2;
        goto lab_0x494f6;
    } else {
        if (a4 == 0) {
            int32_t v6 = llvm_ctlz_i32(a3, true) | 32; // 0x49514
            v3 = llvm_ctlz_i32(a2, true);
            v1 = v6;
            v2 = v6;
            if (a2 == 0) {
                goto lab_0x49504;
            } else {
                goto lab_0x49438;
            }
        } else {
            int32_t v7 = llvm_ctlz_i32(a4, true); // 0x49428
            v3 = llvm_ctlz_i32(a2, true);
            v1 = v7;
            v2 = v7;
            if (a2 == 0) {
                goto lab_0x49504;
            } else {
                goto lab_0x49438;
            }
        }
    }
  lab_0x494f6:;
    // 0x494f6
    int32_t v8; // 0x49410
    if (v8 != 0) {
        // 0x494fc
        *(int32_t *)v8 = v4;
        *(int32_t *)(v8 + 4) = v5;
    }
    // 0x49500
    return result;
  lab_0x49504:
    // 0x49504
    v3 = llvm_ctlz_i32(a1, true) | 32;
    v1 = v2;
    goto lab_0x49438;
  lab_0x49438:;
    uint32_t v9 = v1 - v3; // 0x49438
    uint32_t v10 = v9 - 32; // 0x4943c
    uint32_t v11 = 32 - v9; // 0x49448
    uint32_t v12 = a3 << v10 | a4 << v9 | a3 >> v11; // 0x49456
    if (v12 == a2) {
        __asm_it();
    }
    uint32_t v13 = a3 << v9; // 0x49450
    int32_t v14; // 0x49410
    int32_t v15; // 0x49410
    int32_t v16; // 0x49410
    if (v12 == a2 ? v13 > a1 : v12 > a2) {
        __asm_itt();
        v14 = 0;
        v15 = a1;
        v16 = a2;
    } else {
        // 0x49466
        v14 = 1 << v9;
        v15 = a1 - v13;
        v16 = (int32_t)(v9 != 32) + a2 - v12;
    }
    // 0x4947c
    result = v14;
    v4 = v15;
    v5 = v16;
    if (v9 != 0) {
        uint32_t v17 = v12 / 2; // 0x49482
        uint32_t v18 = (int32_t)(v12 % 2 != 0) << 32 - v13 | (int32_t)((int64_t)v13 << (int64_t)(33 - v13)); // 0x49484
        int32_t v19 = v14; // 0x4948a
        int32_t v20 = v9; // 0x4948a
        int32_t v21 = v15; // 0x4948a
        int32_t v22 = v16; // 0x4948a
        int32_t v23; // 0x49410
        int32_t v24; // 0x49410
        int32_t v25; // 0x49410
        while (true) {
            uint32_t v26 = v22;
            uint32_t v27 = v21;
            int32_t v28 = v20;
            int32_t v29 = v19; // 0x494a4
            if (v26 == v17) {
                v29 = __asm_it();
            }
            v23 = v29;
            int32_t v30; // 0x49410
            int32_t v31; // 0x49410
            if (v26 == v17 ? v27 < v18 : v26 < v17) {
                int32_t v32 = 2 * v27; // 0x494aa
                int32_t v33 = 2 * v26 | (int32_t)(v32 < v27); // 0x494ac
                v30 = v32;
                v31 = v33;
                v24 = v32;
                v25 = v33;
                if (v28 == 1) {
                    // break -> 0x494b2
                    break;
                }
            } else {
                uint32_t v34 = v27 - v18; // 0x4948c
                uint32_t v35 = 2 * v34; // 0x49492
                int32_t v36 = 2 * (v26 - v17 + (int32_t)(v27 < v18)) | (int32_t)(v35 < v34); // 0x49494
                int32_t v37 = v35 | 1; // 0x49498
                v30 = v37;
                v31 = v36;
                v24 = v37;
                v25 = v36;
                if (v28 == 1) {
                    // break -> 0x494b2
                    break;
                }
            }
            // 0x494a2
            v19 = v23;
            v20 = v28 - 1;
            v21 = v30;
            v22 = v31;
        }
        uint32_t v38 = v25;
        int32_t v39 = v38 << v11 | v24 >> v9 | v38 >> v10; // 0x494c8
        result = v24 + v23 - (v39 << v9);
        v4 = v39;
        v5 = v38 >> v9;
    }
    goto lab_0x494f6;
}

// Address range: 0x49520 - 0x49554
int32_t function_49520(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = function_11eb4(a1, a2, a3, a4); // 0x49530
    return 0x64ee2 - (int32_t)&g26 >> 2 == 0 ? v1 : a1;
}

// Address range: 0x4955c - 0x4955e
int32_t function_4955c(void) {
    // 0x4955c
    int32_t result; // 0x4955c
    return result;
}

// Address range: 0x49560 - 0x49568
int32_t function_49560(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x49560
    return result;
}

// Address range: 0x4a120 - 0x4a121
int32_t function_4a120(void) {
    // 0x4a120
    int32_t result; // 0x4a120
    return result;
}

// Address range: 0x51ea2 - 0x51ea3
int32_t function_51ea2(void) {
    // 0x51ea2
    int32_t result; // 0x51ea2
    return result;
}

// Address range: 0x553ee - 0x553ef
int32_t function_553ee(void) {
    // 0x553ee
    int32_t result; // 0x553ee
    return result;
}

// Address range: 0x55e4a - 0x55e4b
int32_t function_55e4a(void) {
    // 0x55e4a
    int32_t result; // 0x55e4a
    return result;
}

// Address range: 0x55e4e - 0x55e4f
int32_t function_55e4e(void) {
    // 0x55e4e
    int32_t result; // 0x55e4e
    return result;
}

// Address range: 0x58c56 - 0x58c57
int32_t function_58c56(void) {
    // 0x58c56
    int32_t result; // 0x58c56
    return result;
}

// Address range: 0x5b33e - 0x5b33f
int32_t function_5b33e(void) {
    // 0x5b33e
    int32_t result; // 0x5b33e
    return result;
}

// Address range: 0x5c9d2 - 0x5c9d3
int32_t function_5c9d2(void) {
    // 0x5c9d2
    int32_t result; // 0x5c9d2
    return result;
}

// Address range: 0x5e63a - 0x5e63b
int32_t function_5e63a(void) {
    // 0x5e63a
    int32_t result; // 0x5e63a
    return result;
}

// Address range: 0x60f46 - 0x60f47
int32_t function_60f46(void) {
    // 0x60f46
    int32_t result; // 0x60f46
    return result;
}

// Address range: 0x639aa - 0x639ab
int32_t function_639aa(void) {
    // 0x639aa
    int32_t result; // 0x639aa
    return result;
}

// Address range: 0x6428a - 0x6428b
int32_t function_6428a(void) {
    // 0x6428a
    int32_t result; // 0x6428a
    return result;
}

// Address range: 0x6429a - 0x6429b
int32_t function_6429a(void) {
    // 0x6429a
    int32_t result; // 0x6429a
    return result;
}

// Address range: 0x643d2 - 0x643d3
int32_t function_643d2(void) {
    // 0x643d2
    int32_t result; // 0x643d2
    return result;
}

// Address range: 0x643da - 0x643db
int32_t function_643da(void) {
    // 0x643da
    int32_t result; // 0x643da
    return result;
}

// Address range: 0x643ea - 0x643eb
int32_t function_643ea(void) {
    // 0x643ea
    int32_t result; // 0x643ea
    return result;
}

// Address range: 0x64b86 - 0x64b87
int32_t function_64b86(void) {
    // 0x64b86
    int32_t result; // 0x64b86
    return result;
}

// Address range: 0x65476 - 0x65477
int32_t function_65476(void) {
    // 0x65476
    int32_t result; // 0x65476
    return result;
}

// Address range: 0x655f2 - 0x655f3
int32_t function_655f2(void) {
    // 0x655f2
    int32_t result; // 0x655f2
    return result;
}

// Address range: 0x6ba66 - 0x6ba67
int32_t function_6ba66(void) {
    // 0x6ba66
    int32_t result; // 0x6ba66
    return result;
}

// Address range: 0x6bf3e - 0x6bf3f
int32_t function_6bf3e(void) {
    // 0x6bf3e
    int32_t result; // 0x6bf3e
    return result;
}

// Address range: 0x6c722 - 0x6c723
int32_t function_6c722(void) {
    // 0x6c722
    int32_t result; // 0x6c722
    return result;
}

// Address range: 0x6e19a - 0x6e19b
int32_t function_6e19a(void) {
    // 0x6e19a
    int32_t result; // 0x6e19a
    return result;
}

// Address range: 0x6ee26 - 0x6ee27
int32_t function_6ee26(void) {
    // 0x6ee26
    int32_t result; // 0x6ee26
    return result;
}

// Address range: 0x6f0ea - 0x6f0eb
int32_t function_6f0ea(void) {
    // 0x6f0ea
    int32_t result; // 0x6f0ea
    return result;
}

// Address range: 0x6f14a - 0x6f14b
int32_t function_6f14a(void) {
    // 0x6f14a
    int32_t result; // 0x6f14a
    return result;
}

// Address range: 0x6f33a - 0x6f33b
int32_t function_6f33a(void) {
    // 0x6f33a
    int32_t result; // 0x6f33a
    return result;
}

// Address range: 0x6f3f6 - 0x6f3f7
int32_t function_6f3f6(void) {
    // 0x6f3f6
    int32_t result; // 0x6f3f6
    return result;
}

// Address range: 0x6f576 - 0x6f577
int32_t function_6f576(void) {
    // 0x6f576
    int32_t result; // 0x6f576
    return result;
}

// Address range: 0x6fb02 - 0x6fb03
int32_t function_6fb02(void) {
    // 0x6fb02
    int32_t result; // 0x6fb02
    return result;
}

// Address range: 0x72166 - 0x72167
int32_t function_72166(void) {
    // 0x72166
    int32_t result; // 0x72166
    return result;
}

// Address range: 0x7271e - 0x7271f
int32_t function_7271e(void) {
    // 0x7271e
    int32_t result; // 0x7271e
    return result;
}

// Address range: 0x740b8 - 0x740b9
int32_t function_740b8(void) {
    // 0x740b8
    int32_t result; // 0x740b8
    return result;
}

// Address range: 0x74932 - 0x74933
int32_t function_74932(void) {
    // 0x74932
    int32_t result; // 0x74932
    return result;
}

// Address range: 0x74d3e - 0x74d3f
int32_t function_74d3e(void) {
    // 0x74d3e
    int32_t result; // 0x74d3e
    return result;
}

// Address range: 0x759c6 - 0x759c7
int32_t function_759c6(void) {
    // 0x759c6
    int32_t result; // 0x759c6
    return result;
}

// Address range: 0x75cde - 0x75cdf
int32_t function_75cde(void) {
    // 0x75cde
    int32_t result; // 0x75cde
    return result;
}

// Address range: 0x78bc2 - 0x78bc3
int32_t function_78bc2(void) {
    // 0x78bc2
    int32_t result; // 0x78bc2
    return result;
}

// Address range: 0x7b092 - 0x7b093
int32_t function_7b092(void) {
    // 0x7b092
    int32_t result; // 0x7b092
    return result;
}

// Address range: 0x7fad2 - 0x7fad3
int32_t function_7fad2(void) {
    // 0x7fad2
    int32_t result; // 0x7fad2
    return result;
}

// Address range: 0xd3442 - 0xd3443
int32_t function_d3442(void) {
    // 0xd3442
    int32_t result; // 0xd3442
    return result;
}

// Address range: 0xd4afe - 0xd4aff
int32_t function_d4afe(void) {
    // 0xd4afe
    int32_t result; // 0xd4afe
    return result;
}

// Address range: 0xd5b5a - 0xd5b5b
int32_t function_d5b5a(void) {
    // 0xd5b5a
    int32_t result; // 0xd5b5a
    return result;
}

// Address range: 0xdfb2e - 0xdfb2f
int32_t function_dfb2e(void) {
    // 0xdfb2e
    int32_t result; // 0xdfb2e
    return result;
}

// Address range: 0xdfcf2 - 0xdfcf3
int32_t function_dfcf2(void) {
    // 0xdfcf2
    int32_t result; // 0xdfcf2
    return result;
}

// Address range: 0xdff66 - 0xdff67
int32_t function_dff66(void) {
    // 0xdff66
    int32_t result; // 0xdff66
    return result;
}

// Address range: 0xe2462 - 0xe2463
int32_t function_e2462(void) {
    // 0xe2462
    int32_t result; // 0xe2462
    return result;
}

// Address range: 0xe4462 - 0xe4463
int32_t function_e4462(void) {
    // 0xe4462
    int32_t result; // 0xe4462
    return result;
}

// Address range: 0xe4b52 - 0xe4b53
int32_t function_e4b52(void) {
    // 0xe4b52
    int32_t result; // 0xe4b52
    return result;
}

// Address range: 0xe7ac2 - 0xe7ac3
int32_t function_e7ac2(void) {
    // 0xe7ac2
    int32_t result; // 0xe7ac2
    return result;
}

// Address range: 0xec5b2 - 0xec5b3
int32_t function_ec5b2(void) {
    // 0xec5b2
    int32_t result; // 0xec5b2
    return result;
}

// Address range: 0xec736 - 0xec737
int32_t function_ec736(void) {
    // 0xec736
    int32_t result; // 0xec736
    return result;
}

// Address range: 0xecbae - 0xecbaf
int32_t function_ecbae(void) {
    // 0xecbae
    int32_t result; // 0xecbae
    return result;
}

// Address range: 0xef156 - 0xef157
int32_t function_ef156(void) {
    // 0xef156
    int32_t result; // 0xef156
    return result;
}

// Address range: 0xf0b26 - 0xf0b27
int32_t function_f0b26(void) {
    // 0xf0b26
    int32_t result; // 0xf0b26
    return result;
}

// Address range: 0xf22ae - 0xf22af
int32_t function_f22ae(void) {
    // 0xf22ae
    int32_t result; // 0xf22ae
    return result;
}

// Address range: 0xf2b3e - 0xf2b3f
int32_t function_f2b3e(void) {
    // 0xf2b3e
    int32_t result; // 0xf2b3e
    return result;
}

// Address range: 0xf88ea - 0xf88eb
int32_t function_f88ea(void) {
    // 0xf88ea
    int32_t result; // 0xf88ea
    return result;
}

// Address range: 0xfa3a2 - 0xfa3a3
int32_t function_fa3a2(void) {
    // 0xfa3a2
    int32_t result; // 0xfa3a2
    return result;
}

// Address range: 0xfb4fa - 0xfb4fb
int32_t function_fb4fa(void) {
    // 0xfb4fa
    int32_t result; // 0xfb4fa
    return result;
}

// Address range: 0x16305e - 0x16305f
int32_t function_16305e(void) {
    // 0x16305e
    int32_t result; // 0x16305e
    return result;
}

// Address range: 0x163fe2 - 0x163fe3
int32_t function_163fe2(void) {
    // 0x163fe2
    int32_t result; // 0x163fe2
    return result;
}

// Address range: 0x192c72 - 0x192c73
int32_t function_192c72(void) {
    // 0x192c72
    int32_t result; // 0x192c72
    return result;
}

// Address range: 0x195e52 - 0x195e53
int32_t function_195e52(void) {
    // 0x195e52
    int32_t result; // 0x195e52
    return result;
}

// Address range: 0x19607e - 0x19607f
int32_t function_19607e(void) {
    // 0x19607e
    int32_t result; // 0x19607e
    return result;
}

// Address range: 0x19b3fe - 0x19b3ff
int32_t function_19b3fe(void) {
    // 0x19b3fe
    int32_t result; // 0x19b3fe
    return result;
}

// Address range: 0x19c41e - 0x19c41f
int32_t function_19c41e(void) {
    // 0x19c41e
    int32_t result; // 0x19c41e
    return result;
}

// Address range: 0x1af4b6 - 0x1af4b7
int32_t function_1af4b6(void) {
    // 0x1af4b6
    int32_t result; // 0x1af4b6
    return result;
}

// Address range: 0x1b44c2 - 0x1b44c3
int32_t function_1b44c2(void) {
    // 0x1b44c2
    int32_t result; // 0x1b44c2
    return result;
}

// Address range: 0x1b5732 - 0x1b5733
int32_t function_1b5732(void) {
    // 0x1b5732
    int32_t result; // 0x1b5732
    return result;
}

// Address range: 0x1b59be - 0x1b59bf
int32_t function_1b59be(void) {
    // 0x1b59be
    int32_t result; // 0x1b59be
    return result;
}

// Address range: 0x1d2c16 - 0x1d2c17
int32_t function_1d2c16(void) {
    // 0x1d2c16
    int32_t result; // 0x1d2c16
    return result;
}

// Address range: 0x1d5aea - 0x1d5aeb
int32_t function_1d5aea(void) {
    // 0x1d5aea
    int32_t result; // 0x1d5aea
    return result;
}

// Address range: 0x1d5c7e - 0x1d5c7f
int32_t function_1d5c7e(void) {
    // 0x1d5c7e
    int32_t result; // 0x1d5c7e
    return result;
}

// Address range: 0x1d5d16 - 0x1d5d17
int32_t function_1d5d16(void) {
    // 0x1d5d16
    int32_t result; // 0x1d5d16
    return result;
}

// Address range: 0x1d602a - 0x1d602b
int32_t function_1d602a(void) {
    // 0x1d602a
    int32_t result; // 0x1d602a
    return result;
}

// Address range: 0x1d60da - 0x1d60db
int32_t function_1d60da(void) {
    // 0x1d60da
    int32_t result; // 0x1d60da
    return result;
}

// Address range: 0x1d61be - 0x1d61bf
int32_t function_1d61be(void) {
    // 0x1d61be
    int32_t result; // 0x1d61be
    return result;
}

// Address range: 0x1d9b56 - 0x1d9b57
int32_t function_1d9b56(void) {
    // 0x1d9b56
    int32_t result; // 0x1d9b56
    return result;
}

// Address range: 0x1d9bae - 0x1d9baf
int32_t function_1d9bae(void) {
    // 0x1d9bae
    int32_t result; // 0x1d9bae
    return result;
}

// Address range: 0x1dcfb6 - 0x1dcfb7
int32_t function_1dcfb6(void) {
    // 0x1dcfb6
    int32_t result; // 0x1dcfb6
    return result;
}

// Address range: 0x1dd00e - 0x1dd00f
int32_t function_1dd00e(void) {
    // 0x1dd00e
    int32_t result; // 0x1dd00e
    return result;
}

// Address range: 0x1e41da - 0x1e41db
int32_t function_1e41da(void) {
    // 0x1e41da
    int32_t result; // 0x1e41da
    return result;
}

// Address range: 0x1ee1b6 - 0x1ee1b7
int32_t function_1ee1b6(void) {
    // 0x1ee1b6
    int32_t result; // 0x1ee1b6
    return result;
}

// Address range: 0x2129e6 - 0x2129e7
int32_t function_2129e6(void) {
    // 0x2129e6
    int32_t result; // 0x2129e6
    return result;
}

// Address range: 0x21468e - 0x21468f
int32_t function_21468e(void) {
    // 0x21468e
    int32_t result; // 0x21468e
    return result;
}

// Address range: 0x2146de - 0x2146df
int32_t function_2146de(void) {
    // 0x2146de
    int32_t result; // 0x2146de
    return result;
}

// Address range: 0x215dde - 0x215ddf
int32_t function_215dde(void) {
    // 0x215dde
    int32_t result; // 0x215dde
    return result;
}

// Address range: 0x21fc76 - 0x21fc77
int32_t function_21fc76(void) {
    // 0x21fc76
    int32_t result; // 0x21fc76
    return result;
}

// Address range: 0x21fc8a - 0x21fc8b
int32_t function_21fc8a(void) {
    // 0x21fc8a
    int32_t result; // 0x21fc8a
    return result;
}

// Address range: 0x221992 - 0x221993
int32_t function_221992(void) {
    // 0x221992
    int32_t result; // 0x221992
    return result;
}

// Address range: 0x2219a6 - 0x2219a7
int32_t function_2219a6(void) {
    // 0x2219a6
    int32_t result; // 0x2219a6
    return result;
}

// Address range: 0x222c12 - 0x222c13
int32_t function_222c12(void) {
    // 0x222c12
    int32_t result; // 0x222c12
    return result;
}

// Address range: 0x22563a - 0x22563b
int32_t function_22563a(void) {
    // 0x22563a
    int32_t result; // 0x22563a
    return result;
}

// Address range: 0x225662 - 0x225663
int32_t function_225662(void) {
    // 0x225662
    int32_t result; // 0x225662
    return result;
}

// Address range: 0x225816 - 0x225817
int32_t function_225816(void) {
    // 0x225816
    int32_t result; // 0x225816
    return result;
}

// Address range: 0x225df2 - 0x225df3
int32_t function_225df2(void) {
    // 0x225df2
    int32_t result; // 0x225df2
    return result;
}

// Address range: 0x22805a - 0x22805b
int32_t function_22805a(void) {
    // 0x22805a
    int32_t result; // 0x22805a
    return result;
}

// Address range: 0x228096 - 0x228097
int32_t function_228096(void) {
    // 0x228096
    int32_t result; // 0x228096
    return result;
}

// Address range: 0x2280aa - 0x2280ab
int32_t function_2280aa(void) {
    // 0x2280aa
    int32_t result; // 0x2280aa
    return result;
}

// Address range: 0x22add2 - 0x22add3
int32_t function_22add2(void) {
    // 0x22add2
    int32_t result; // 0x22add2
    return result;
}

// Address range: 0x22eef6 - 0x22eef7
int32_t function_22eef6(void) {
    // 0x22eef6
    int32_t result; // 0x22eef6
    return result;
}

// Address range: 0x232196 - 0x232197
int32_t function_232196(void) {
    // 0x232196
    int32_t result; // 0x232196
    return result;
}

// Address range: 0x2324b2 - 0x2324b3
int32_t function_2324b2(void) {
    // 0x2324b2
    int32_t result; // 0x2324b2
    return result;
}

// Address range: 0x233036 - 0x233037
int32_t function_233036(void) {
    // 0x233036
    int32_t result; // 0x233036
    return result;
}

// Address range: 0x234416 - 0x234417
int32_t function_234416(void) {
    // 0x234416
    int32_t result; // 0x234416
    return result;
}

// Address range: 0x234716 - 0x234717
int32_t function_234716(void) {
    // 0x234716
    int32_t result; // 0x234716
    return result;
}

// Address range: 0x234ab6 - 0x234ab7
int32_t function_234ab6(void) {
    // 0x234ab6
    int32_t result; // 0x234ab6
    return result;
}

// Address range: 0x234d36 - 0x234d37
int32_t function_234d36(void) {
    // 0x234d36
    int32_t result; // 0x234d36
    return result;
}

// Address range: 0x239536 - 0x239537
int32_t function_239536(void) {
    // 0x239536
    int32_t result; // 0x239536
    return result;
}

// Address range: 0x239842 - 0x239843
int32_t function_239842(void) {
    // 0x239842
    int32_t result; // 0x239842
    return result;
}

// Address range: 0x244c74 - 0x244c75
int32_t function_244c74(void) {
    // 0x244c74
    int32_t result; // 0x244c74
    return result;
}

// Address range: 0x24d006 - 0x24d007
int32_t function_24d006(void) {
    // 0x24d006
    int32_t result; // 0x24d006
    return result;
}

// Address range: 0x24e38e - 0x24e38f
int32_t function_24e38e(void) {
    // 0x24e38e
    int32_t result; // 0x24e38e
    return result;
}

// Address range: 0x25228e - 0x25228f
int32_t function_25228e(void) {
    // 0x25228e
    int32_t result; // 0x25228e
    return result;
}

// Address range: 0x2522c2 - 0x2522c3
int32_t function_2522c2(void) {
    // 0x2522c2
    int32_t result; // 0x2522c2
    return result;
}

// Address range: 0x2522f6 - 0x2522f7
int32_t function_2522f6(void) {
    // 0x2522f6
    int32_t result; // 0x2522f6
    return result;
}

// Address range: 0x25232a - 0x25232b
int32_t function_25232a(void) {
    // 0x25232a
    int32_t result; // 0x25232a
    return result;
}

// Address range: 0x252472 - 0x252473
int32_t function_252472(void) {
    // 0x252472
    int32_t result; // 0x252472
    return result;
}

// Address range: 0x2524ca - 0x2524cb
int32_t function_2524ca(void) {
    // 0x2524ca
    int32_t result; // 0x2524ca
    return result;
}

// Address range: 0x252862 - 0x252863
int32_t function_252862(void) {
    // 0x252862
    int32_t result; // 0x252862
    return result;
}

// Address range: 0x252d6e - 0x252d6f
int32_t function_252d6e(void) {
    // 0x252d6e
    int32_t result; // 0x252d6e
    return result;
}

// Address range: 0x252dc6 - 0x252dc7
int32_t function_252dc6(void) {
    // 0x252dc6
    int32_t result; // 0x252dc6
    return result;
}

// Address range: 0x253336 - 0x253337
int32_t function_253336(void) {
    // 0x253336
    int32_t result; // 0x253336
    return result;
}

// Address range: 0x25337a - 0x25337b
int32_t function_25337a(void) {
    // 0x25337a
    int32_t result; // 0x25337a
    return result;
}

// Address range: 0x2533be - 0x2533bf
int32_t function_2533be(void) {
    // 0x2533be
    int32_t result; // 0x2533be
    return result;
}

// Address range: 0x253896 - 0x253897
int32_t function_253896(void) {
    // 0x253896
    int32_t result; // 0x253896
    return result;
}

// Address range: 0x25391a - 0x25391b
int32_t function_25391a(void) {
    // 0x25391a
    int32_t result; // 0x25391a
    return result;
}

// Address range: 0x25397e - 0x25397f
int32_t function_25397e(void) {
    // 0x25397e
    int32_t result; // 0x25397e
    return result;
}

// Address range: 0x2543fe - 0x2543ff
int32_t function_2543fe(void) {
    // 0x2543fe
    int32_t result; // 0x2543fe
    return result;
}

// Address range: 0x25443e - 0x25443f
int32_t function_25443e(void) {
    // 0x25443e
    int32_t result; // 0x25443e
    return result;
}

// Address range: 0x25448e - 0x25448f
int32_t function_25448e(void) {
    // 0x25448e
    int32_t result; // 0x25448e
    return result;
}

// Address range: 0x25451e - 0x25451f
int32_t function_25451e(void) {
    // 0x25451e
    int32_t result; // 0x25451e
    return result;
}

// Address range: 0x2545a2 - 0x2545a3
int32_t function_2545a2(void) {
    // 0x2545a2
    int32_t result; // 0x2545a2
    return result;
}

// Address range: 0x2546a6 - 0x2546a7
int32_t function_2546a6(void) {
    // 0x2546a6
    int32_t result; // 0x2546a6
    return result;
}

// Address range: 0x2546f6 - 0x2546f7
int32_t function_2546f6(void) {
    // 0x2546f6
    int32_t result; // 0x2546f6
    return result;
}

// Address range: 0x2549c6 - 0x2549c7
int32_t function_2549c6(void) {
    // 0x2549c6
    int32_t result; // 0x2549c6
    return result;
}

// Address range: 0x254d4a - 0x254d4b
int32_t function_254d4a(void) {
    // 0x254d4a
    int32_t result; // 0x254d4a
    return result;
}

// Address range: 0x254f42 - 0x254f43
int32_t function_254f42(void) {
    // 0x254f42
    int32_t result; // 0x254f42
    return result;
}

// Address range: 0x254f8a - 0x254f8b
int32_t function_254f8a(void) {
    // 0x254f8a
    int32_t result; // 0x254f8a
    return result;
}

// Address range: 0x254fb2 - 0x254fb3
int32_t function_254fb2(void) {
    // 0x254fb2
    int32_t result; // 0x254fb2
    return result;
}

// Address range: 0x254fd2 - 0x254fd3
int32_t function_254fd2(void) {
    // 0x254fd2
    int32_t result; // 0x254fd2
    return result;
}

// Address range: 0x254ff6 - 0x254ff7
int32_t function_254ff6(void) {
    // 0x254ff6
    int32_t result; // 0x254ff6
    return result;
}

// Address range: 0x25558a - 0x25558b
int32_t function_25558a(void) {
    // 0x25558a
    int32_t result; // 0x25558a
    return result;
}

// Address range: 0x2555a2 - 0x2555a3
int32_t function_2555a2(void) {
    // 0x2555a2
    int32_t result; // 0x2555a2
    return result;
}

// Address range: 0x2556c6 - 0x2556c7
int32_t function_2556c6(void) {
    // 0x2556c6
    int32_t result; // 0x2556c6
    return result;
}

// Address range: 0x255752 - 0x255753
int32_t function_255752(void) {
    // 0x255752
    int32_t result; // 0x255752
    return result;
}

// Address range: 0x2557a2 - 0x2557a3
int32_t function_2557a2(void) {
    // 0x2557a2
    int32_t result; // 0x2557a2
    return result;
}

// Address range: 0x2557d6 - 0x2557d7
int32_t function_2557d6(void) {
    // 0x2557d6
    int32_t result; // 0x2557d6
    return result;
}

// Address range: 0x25587e - 0x25587f
int32_t function_25587e(void) {
    // 0x25587e
    int32_t result; // 0x25587e
    return result;
}

// Address range: 0x2558d6 - 0x2558d7
int32_t function_2558d6(void) {
    // 0x2558d6
    int32_t result; // 0x2558d6
    return result;
}

// Address range: 0x25592e - 0x25592f
int32_t function_25592e(void) {
    // 0x25592e
    int32_t result; // 0x25592e
    return result;
}

// Address range: 0x255a1e - 0x255a1f
int32_t function_255a1e(void) {
    // 0x255a1e
    int32_t result; // 0x255a1e
    return result;
}

// Address range: 0x255d0e - 0x255d0f
int32_t function_255d0e(void) {
    // 0x255d0e
    int32_t result; // 0x255d0e
    return result;
}

// Address range: 0x255e3a - 0x255e3b
int32_t function_255e3a(void) {
    // 0x255e3a
    int32_t result; // 0x255e3a
    return result;
}

// Address range: 0x255e92 - 0x255e93
int32_t function_255e92(void) {
    // 0x255e92
    int32_t result; // 0x255e92
    return result;
}

// Address range: 0x255ea2 - 0x255ea3
int32_t function_255ea2(void) {
    // 0x255ea2
    int32_t result; // 0x255ea2
    return result;
}

// Address range: 0x255ea6 - 0x255ea7
int32_t function_255ea6(void) {
    // 0x255ea6
    int32_t result; // 0x255ea6
    return result;
}

// Address range: 0x25617e - 0x25617f
int32_t function_25617e(void) {
    // 0x25617e
    int32_t result; // 0x25617e
    return result;
}

// Address range: 0x25632a - 0x25632b
int32_t function_25632a(void) {
    // 0x25632a
    int32_t result; // 0x25632a
    return result;
}

// Address range: 0x25c4de - 0x25c4df
int32_t function_25c4de(void) {
    // 0x25c4de
    int32_t result; // 0x25c4de
    return result;
}

// Address range: 0x262686 - 0x262687
int32_t function_262686(void) {
    // 0x262686
    int32_t result; // 0x262686
    return result;
}

// Address range: 0x2643a6 - 0x2643a7
int32_t function_2643a6(void) {
    // 0x2643a6
    int32_t result; // 0x2643a6
    return result;
}

// Address range: 0x26448e - 0x26448f
int32_t function_26448e(void) {
    // 0x26448e
    int32_t result; // 0x26448e
    return result;
}

// Address range: 0x264932 - 0x264933
int32_t function_264932(void) {
    // 0x264932
    int32_t result; // 0x264932
    return result;
}

// Address range: 0x26578e - 0x26578f
int32_t function_26578e(void) {
    // 0x26578e
    int32_t result; // 0x26578e
    return result;
}

// Address range: 0x2682ee - 0x2682ef
int32_t function_2682ee(void) {
    // 0x2682ee
    int32_t result; // 0x2682ee
    return result;
}

// Address range: 0x26ad8e - 0x26ad8f
int32_t function_26ad8e(void) {
    // 0x26ad8e
    int32_t result; // 0x26ad8e
    return result;
}

// Address range: 0x26adae - 0x26adaf
int32_t function_26adae(void) {
    // 0x26adae
    int32_t result; // 0x26adae
    return result;
}

// Address range: 0x26b026 - 0x26b027
int32_t function_26b026(void) {
    // 0x26b026
    int32_t result; // 0x26b026
    return result;
}

// Address range: 0x26bfae - 0x26bfaf
int32_t function_26bfae(void) {
    // 0x26bfae
    int32_t result; // 0x26bfae
    return result;
}

// Address range: 0x26c17a - 0x26c17b
int32_t function_26c17a(void) {
    // 0x26c17a
    int32_t result; // 0x26c17a
    return result;
}

// Address range: 0x26f072 - 0x26f073
int32_t function_26f072(void) {
    // 0x26f072
    int32_t result; // 0x26f072
    return result;
}

// Address range: 0x26f09a - 0x26f09b
int32_t function_26f09a(void) {
    // 0x26f09a
    int32_t result; // 0x26f09a
    return result;
}

// Address range: 0x2749ca - 0x2749cb
int32_t function_2749ca(void) {
    // 0x2749ca
    int32_t result; // 0x2749ca
    return result;
}

// Address range: 0x27aa02 - 0x27aa03
int32_t function_27aa02(void) {
    // 0x27aa02
    int32_t result; // 0x27aa02
    return result;
}

// Address range: 0x27aa5a - 0x27aa5b
int32_t function_27aa5a(void) {
    // 0x27aa5a
    int32_t result; // 0x27aa5a
    return result;
}

// Address range: 0x27c982 - 0x27c983
int32_t function_27c982(void) {
    // 0x27c982
    int32_t result; // 0x27c982
    return result;
}

// Address range: 0x27c9ca - 0x27c9cb
int32_t function_27c9ca(void) {
    // 0x27c9ca
    int32_t result; // 0x27c9ca
    return result;
}

// Address range: 0x27ca12 - 0x27ca13
int32_t function_27ca12(void) {
    // 0x27ca12
    int32_t result; // 0x27ca12
    return result;
}

// Address range: 0x27ca5a - 0x27ca5b
int32_t function_27ca5a(void) {
    // 0x27ca5a
    int32_t result; // 0x27ca5a
    return result;
}

// Address range: 0x27cf6e - 0x27cf6f
int32_t function_27cf6e(void) {
    // 0x27cf6e
    int32_t result; // 0x27cf6e
    return result;
}

// Address range: 0x27d4be - 0x27d4bf
int32_t function_27d4be(void) {
    // 0x27d4be
    int32_t result; // 0x27d4be
    return result;
}

// Address range: 0x27d546 - 0x27d547
int32_t function_27d546(void) {
    // 0x27d546
    int32_t result; // 0x27d546
    return result;
}

// Address range: 0x2a618a - 0x2a618b
int32_t function_2a618a(void) {
    // 0x2a618a
    int32_t result; // 0x2a618a
    return result;
}

// Address range: 0x2a6322 - 0x2a6323
int32_t function_2a6322(void) {
    // 0x2a6322
    int32_t result; // 0x2a6322
    return result;
}

// Address range: 0x2a66de - 0x2a66df
int32_t function_2a66de(void) {
    // 0x2a66de
    int32_t result; // 0x2a66de
    return result;
}

// Address range: 0x2b4892 - 0x2b4893
int32_t function_2b4892(void) {
    // 0x2b4892
    int32_t result; // 0x2b4892
    return result;
}

// Address range: 0x2bccba - 0x2bccbb
int32_t function_2bccba(void) {
    // 0x2bccba
    int32_t result; // 0x2bccba
    return result;
}

// Address range: 0x2e62ea - 0x2e62eb
int32_t function_2e62ea(void) {
    // 0x2e62ea
    int32_t result; // 0x2e62ea
    return result;
}

// Address range: 0x2ef2fe - 0x2ef2ff
int32_t function_2ef2fe(void) {
    // 0x2ef2fe
    int32_t result; // 0x2ef2fe
    return result;
}

// Address range: 0x2fcb92 - 0x2fcb93
int32_t function_2fcb92(void) {
    // 0x2fcb92
    int32_t result; // 0x2fcb92
    return result;
}

// Address range: 0x2fce9e - 0x2fce9f
int32_t function_2fce9e(void) {
    // 0x2fce9e
    int32_t result; // 0x2fce9e
    return result;
}

// Address range: 0x2fd492 - 0x2fd493
int32_t function_2fd492(void) {
    // 0x2fd492
    int32_t result; // 0x2fd492
    return result;
}

// Address range: 0x2fd79e - 0x2fd79f
int32_t function_2fd79e(void) {
    // 0x2fd79e
    int32_t result; // 0x2fd79e
    return result;
}

// Address range: 0x344a4c - 0x344a4d
int32_t function_344a4c(void) {
    // 0x344a4c
    int32_t result; // 0x344a4c
    return result;
}

// Address range: 0x344a54 - 0x344a55
int32_t function_344a54(void) {
    // 0x344a54
    int32_t result; // 0x344a54
    return result;
}

// Address range: 0x34f94a - 0x34f94b
int32_t function_34f94a(void) {
    // 0x34f94a
    int32_t result; // 0x34f94a
    return result;
}

// Address range: 0x35436e - 0x35436f
int32_t function_35436e(void) {
    // 0x35436e
    int32_t result; // 0x35436e
    return result;
}

// Address range: 0x3636ca - 0x3636cb
int32_t function_3636ca(void) {
    // 0x3636ca
    int32_t result; // 0x3636ca
    return result;
}

// Address range: 0x36399a - 0x36399b
int32_t function_36399a(void) {
    // 0x36399a
    int32_t result; // 0x36399a
    return result;
}

// Address range: 0x37471a - 0x37471b
int32_t function_37471a(void) {
    // 0x37471a
    int32_t result; // 0x37471a
    return result;
}

// Address range: 0x37c8f2 - 0x37c8f3
int32_t function_37c8f2(void) {
    // 0x37c8f2
    int32_t result; // 0x37c8f2
    return result;
}

// Address range: 0x3958b2 - 0x3958b3
int32_t function_3958b2(void) {
    // 0x3958b2
    int32_t result; // 0x3958b2
    return result;
}

// Address range: 0x3ebab2 - 0x3ebab3
int32_t function_3ebab2(void) {
    // 0x3ebab2
    int32_t result; // 0x3ebab2
    return result;
}

// Address range: 0x458eca - 0x458ecb
int32_t function_458eca(void) {
    // 0x458eca
    int32_t result; // 0x458eca
    return result;
}

// Address range: 0x45b3f6 - 0x45b3f7
int32_t function_45b3f6(void) {
    // 0x45b3f6
    int32_t result; // 0x45b3f6
    return result;
}

// Address range: 0x4622de - 0x4622df
int32_t function_4622de(void) {
    // 0x4622de
    int32_t result; // 0x4622de
    return result;
}

// Address range: 0x4624c6 - 0x4624c7
int32_t function_4624c6(void) {
    // 0x4624c6
    int32_t result; // 0x4624c6
    return result;
}

// Address range: 0x46259e - 0x46259f
int32_t function_46259e(void) {
    // 0x46259e
    int32_t result; // 0x46259e
    return result;
}

// Address range: 0x46a9be - 0x46a9bf
int32_t function_46a9be(void) {
    // 0x46a9be
    int32_t result; // 0x46a9be
    return result;
}

// Address range: 0x46e1d6 - 0x46e1d7
int32_t function_46e1d6(void) {
    // 0x46e1d6
    int32_t result; // 0x46e1d6
    return result;
}

// Address range: 0x46fea6 - 0x46fea7
int32_t function_46fea6(void) {
    // 0x46fea6
    int32_t result; // 0x46fea6
    return result;
}

// Address range: 0x48097a - 0x48097b
int32_t function_48097a(void) {
    // 0x48097a
    int32_t result; // 0x48097a
    return result;
}

// Address range: 0x480f52 - 0x480f53
int32_t function_480f52(void) {
    // 0x480f52
    int32_t result; // 0x480f52
    return result;
}

// Address range: 0x484c44 - 0x484c45
int32_t function_484c44(void) {
    // 0x484c44
    int32_t result; // 0x484c44
    return result;
}

// Address range: 0x4d1f8a - 0x4d1f8b
int32_t function_4d1f8a(void) {
    // 0x4d1f8a
    int32_t result; // 0x4d1f8a
    return result;
}

// Address range: 0x4f4a6e - 0x4f4a6f
int32_t function_4f4a6e(void) {
    // 0x4f4a6e
    int32_t result; // 0x4f4a6e
    return result;
}

// Address range: 0x4f4aae - 0x4f4aaf
int32_t function_4f4aae(void) {
    // 0x4f4aae
    int32_t result; // 0x4f4aae
    return result;
}

// Address range: 0x4f56f6 - 0x4f56f7
int32_t function_4f56f6(void) {
    // 0x4f56f6
    int32_t result; // 0x4f56f6
    return result;
}

// Address range: 0x4f574e - 0x4f574f
int32_t function_4f574e(void) {
    // 0x4f574e
    int32_t result; // 0x4f574e
    return result;
}

// Address range: 0x5529de - 0x5529df
int32_t function_5529de(void) {
    // 0x5529de
    int32_t result; // 0x5529de
    return result;
}

// Address range: 0x5552fe - 0x5552ff
int32_t function_5552fe(void) {
    // 0x5552fe
    int32_t result; // 0x5552fe
    return result;
}

// Address range: 0x5694b6 - 0x5694b7
int32_t function_5694b6(void) {
    // 0x5694b6
    int32_t result; // 0x5694b6
    return result;
}

// Address range: 0x56f07e - 0x56f07f
int32_t function_56f07e(void) {
    // 0x56f07e
    int32_t result; // 0x56f07e
    return result;
}

// Address range: 0x57272a - 0x57272b
int32_t function_57272a(void) {
    // 0x57272a
    int32_t result; // 0x57272a
    return result;
}

// Address range: 0x574156 - 0x574157
int32_t function_574156(void) {
    // 0x574156
    int32_t result; // 0x574156
    return result;
}

// Address range: 0x57418a - 0x57418b
int32_t function_57418a(void) {
    // 0x57418a
    int32_t result; // 0x57418a
    return result;
}

// Address range: 0x5a5496 - 0x5a5497
int32_t function_5a5496(void) {
    // 0x5a5496
    int32_t result; // 0x5a5496
    return result;
}

// Address range: 0x5a54be - 0x5a54bf
int32_t function_5a54be(void) {
    // 0x5a54be
    int32_t result; // 0x5a54be
    return result;
}

// Address range: 0x5d29e2 - 0x5d29e3
int32_t function_5d29e2(void) {
    // 0x5d29e2
    int32_t result; // 0x5d29e2
    return result;
}

// Address range: 0x5e2bd6 - 0x5e2bd7
int32_t function_5e2bd6(void) {
    // 0x5e2bd6
    int32_t result; // 0x5e2bd6
    return result;
}

// Address range: 0x5e2bea - 0x5e2beb
int32_t function_5e2bea(void) {
    // 0x5e2bea
    int32_t result; // 0x5e2bea
    return result;
}

// Address range: 0x5e48f6 - 0x5e48f7
int32_t function_5e48f6(void) {
    // 0x5e48f6
    int32_t result; // 0x5e48f6
    return result;
}

// Address range: 0x5e490a - 0x5e490b
int32_t function_5e490a(void) {
    // 0x5e490a
    int32_t result; // 0x5e490a
    return result;
}

// Address range: 0x5e54e6 - 0x5e54e7
int32_t function_5e54e6(void) {
    // 0x5e54e6
    int32_t result; // 0x5e54e6
    return result;
}

// Address range: 0x5e6542 - 0x5e6543
int32_t function_5e6542(void) {
    // 0x5e6542
    int32_t result; // 0x5e6542
    return result;
}

// Address range: 0x5eaffa - 0x5eaffb
int32_t function_5eaffa(void) {
    // 0x5eaffa
    int32_t result; // 0x5eaffa
    return result;
}

// Address range: 0x5eb00e - 0x5eb00f
int32_t function_5eb00e(void) {
    // 0x5eb00e
    int32_t result; // 0x5eb00e
    return result;
}

// Address range: 0x5eb31a - 0x5eb31b
int32_t function_5eb31a(void) {
    // 0x5eb31a
    int32_t result; // 0x5eb31a
    return result;
}

// Address range: 0x6044d8 - 0x6044d9
int32_t function_6044d8(void) {
    // 0x6044d8
    int32_t result; // 0x6044d8
    return result;
}

// Address range: 0x612a16 - 0x612a17
int32_t function_612a16(void) {
    // 0x612a16
    int32_t result; // 0x612a16
    return result;
}

// Address range: 0x612a4a - 0x612a4b
int32_t function_612a4a(void) {
    // 0x612a4a
    int32_t result; // 0x612a4a
    return result;
}

// Address range: 0x612a7e - 0x612a7f
int32_t function_612a7e(void) {
    // 0x612a7e
    int32_t result; // 0x612a7e
    return result;
}

// Address range: 0x612ab2 - 0x612ab3
int32_t function_612ab2(void) {
    // 0x612ab2
    int32_t result; // 0x612ab2
    return result;
}

// Address range: 0x612bf6 - 0x612bf7
int32_t function_612bf6(void) {
    // 0x612bf6
    int32_t result; // 0x612bf6
    return result;
}

// Address range: 0x612c4e - 0x612c4f
int32_t function_612c4e(void) {
    // 0x612c4e
    int32_t result; // 0x612c4e
    return result;
}

// Address range: 0x613abe - 0x613abf
int32_t function_613abe(void) {
    // 0x613abe
    int32_t result; // 0x613abe
    return result;
}

// Address range: 0x613b02 - 0x613b03
int32_t function_613b02(void) {
    // 0x613b02
    int32_t result; // 0x613b02
    return result;
}

// Address range: 0x613b46 - 0x613b47
int32_t function_613b46(void) {
    // 0x613b46
    int32_t result; // 0x613b46
    return result;
}

// Address range: 0x61401e - 0x61401f
int32_t function_61401e(void) {
    // 0x61401e
    int32_t result; // 0x61401e
    return result;
}

// Address range: 0x614106 - 0x614107
int32_t function_614106(void) {
    // 0x614106
    int32_t result; // 0x614106
    return result;
}

// Address range: 0x614b86 - 0x614b87
int32_t function_614b86(void) {
    // 0x614b86
    int32_t result; // 0x614b86
    return result;
}

// Address range: 0x614baa - 0x614bab
int32_t function_614baa(void) {
    // 0x614baa
    int32_t result; // 0x614baa
    return result;
}

// Address range: 0x614c16 - 0x614c17
int32_t function_614c16(void) {
    // 0x614c16
    int32_t result; // 0x614c16
    return result;
}

// Address range: 0x614c26 - 0x614c27
int32_t function_614c26(void) {
    // 0x614c26
    int32_t result; // 0x614c26
    return result;
}

// Address range: 0x614ca6 - 0x614ca7
int32_t function_614ca6(void) {
    // 0x614ca6
    int32_t result; // 0x614ca6
    return result;
}

// Address range: 0x614e2e - 0x614e2f
int32_t function_614e2e(void) {
    // 0x614e2e
    int32_t result; // 0x614e2e
    return result;
}

// Address range: 0x614e7e - 0x614e7f
int32_t function_614e7e(void) {
    // 0x614e7e
    int32_t result; // 0x614e7e
    return result;
}

// Address range: 0x6156ca - 0x6156cb
int32_t function_6156ca(void) {
    // 0x6156ca
    int32_t result; // 0x6156ca
    return result;
}

// Address range: 0x615712 - 0x615713
int32_t function_615712(void) {
    // 0x615712
    int32_t result; // 0x615712
    return result;
}

// Address range: 0x61575a - 0x61575b
int32_t function_61575a(void) {
    // 0x61575a
    int32_t result; // 0x61575a
    return result;
}

// Address range: 0x615986 - 0x615987
int32_t function_615986(void) {
    // 0x615986
    int32_t result; // 0x615986
    return result;
}

// Address range: 0x6159ba - 0x6159bb
int32_t function_6159ba(void) {
    // 0x6159ba
    int32_t result; // 0x6159ba
    return result;
}

// Address range: 0x6159ee - 0x6159ef
int32_t function_6159ee(void) {
    // 0x6159ee
    int32_t result; // 0x6159ee
    return result;
}

// Address range: 0x615a22 - 0x615a23
int32_t function_615a22(void) {
    // 0x615a22
    int32_t result; // 0x615a22
    return result;
}

// Address range: 0x615ac2 - 0x615ac3
int32_t function_615ac2(void) {
    // 0x615ac2
    int32_t result; // 0x615ac2
    return result;
}

// Address range: 0x615b56 - 0x615b57
int32_t function_615b56(void) {
    // 0x615b56
    int32_t result; // 0x615b56
    return result;
}

// Address range: 0x615b6a - 0x615b6b
int32_t function_615b6a(void) {
    // 0x615b6a
    int32_t result; // 0x615b6a
    return result;
}

// Address range: 0x615b9e - 0x615b9f
int32_t function_615b9e(void) {
    // 0x615b9e
    int32_t result; // 0x615b9e
    return result;
}

// Address range: 0x615bc2 - 0x615bc3
int32_t function_615bc2(void) {
    // 0x615bc2
    int32_t result; // 0x615bc2
    return result;
}

// Address range: 0x615be6 - 0x615be7
int32_t function_615be6(void) {
    // 0x615be6
    int32_t result; // 0x615be6
    return result;
}

// Address range: 0x615d12 - 0x615d13
int32_t function_615d12(void) {
    // 0x615d12
    int32_t result; // 0x615d12
    return result;
}

// Address range: 0x615d1a - 0x615d1b
int32_t function_615d1a(void) {
    // 0x615d1a
    int32_t result; // 0x615d1a
    return result;
}

// Address range: 0x615d2a - 0x615d2b
int32_t function_615d2a(void) {
    // 0x615d2a
    int32_t result; // 0x615d2a
    return result;
}

// Address range: 0x615e4e - 0x615e4f
int32_t function_615e4e(void) {
    // 0x615e4e
    int32_t result; // 0x615e4e
    return result;
}

// Address range: 0x615ea6 - 0x615ea7
int32_t function_615ea6(void) {
    // 0x615ea6
    int32_t result; // 0x615ea6
    return result;
}

// Address range: 0x615eda - 0x615edb
int32_t function_615eda(void) {
    // 0x615eda
    int32_t result; // 0x615eda
    return result;
}

// Address range: 0x615f2a - 0x615f2b
int32_t function_615f2a(void) {
    // 0x615f2a
    int32_t result; // 0x615f2a
    return result;
}

// Address range: 0x615f5e - 0x615f5f
int32_t function_615f5e(void) {
    // 0x615f5e
    int32_t result; // 0x615f5e
    return result;
}

// Address range: 0x616006 - 0x616007
int32_t function_616006(void) {
    // 0x616006
    int32_t result; // 0x616006
    return result;
}

// Address range: 0x616056 - 0x616057
int32_t function_616056(void) {
    // 0x616056
    int32_t result; // 0x616056
    return result;
}

// Address range: 0x6160ae - 0x6160af
int32_t function_6160ae(void) {
    // 0x6160ae
    int32_t result; // 0x6160ae
    return result;
}

// Address range: 0x6161a6 - 0x6161a7
int32_t function_6161a6(void) {
    // 0x6161a6
    int32_t result; // 0x6161a6
    return result;
}

// Address range: 0x616a72 - 0x616a73
int32_t function_616a72(void) {
    // 0x616a72
    int32_t result; // 0x616a72
    return result;
}

// Address range: 0x616ab6 - 0x616ab7
int32_t function_616ab6(void) {
    // 0x616ab6
    int32_t result; // 0x616ab6
    return result;
}

// Address range: 0x616f8e - 0x616f8f
int32_t function_616f8e(void) {
    // 0x616f8e
    int32_t result; // 0x616f8e
    return result;
}

// Address range: 0x617076 - 0x617077
int32_t function_617076(void) {
    // 0x617076
    int32_t result; // 0x617076
    return result;
}

// Address range: 0x617af6 - 0x617af7
int32_t function_617af6(void) {
    // 0x617af6
    int32_t result; // 0x617af6
    return result;
}

// Address range: 0x617b36 - 0x617b37
int32_t function_617b36(void) {
    // 0x617b36
    int32_t result; // 0x617b36
    return result;
}

// Address range: 0x617b86 - 0x617b87
int32_t function_617b86(void) {
    // 0x617b86
    int32_t result; // 0x617b86
    return result;
}

// Address range: 0x617c16 - 0x617c17
int32_t function_617c16(void) {
    // 0x617c16
    int32_t result; // 0x617c16
    return result;
}

// Address range: 0x617c9a - 0x617c9b
int32_t function_617c9a(void) {
    // 0x617c9a
    int32_t result; // 0x617c9a
    return result;
}

// Address range: 0x617d86 - 0x617d87
int32_t function_617d86(void) {
    // 0x617d86
    int32_t result; // 0x617d86
    return result;
}

// Address range: 0x617d9e - 0x617d9f
int32_t function_617d9e(void) {
    // 0x617d9e
    int32_t result; // 0x617d9e
    return result;
}

// Address range: 0x617dee - 0x617def
int32_t function_617dee(void) {
    // 0x617dee
    int32_t result; // 0x617dee
    return result;
}

// Address range: 0x61863a - 0x61863b
int32_t function_61863a(void) {
    // 0x61863a
    int32_t result; // 0x61863a
    return result;
}

// Address range: 0x618682 - 0x618683
int32_t function_618682(void) {
    // 0x618682
    int32_t result; // 0x618682
    return result;
}

// Address range: 0x6186ca - 0x6186cb
int32_t function_6186ca(void) {
    // 0x6186ca
    int32_t result; // 0x6186ca
    return result;
}

// Address range: 0x618c82 - 0x618c83
int32_t function_618c82(void) {
    // 0x618c82
    int32_t result; // 0x618c82
    return result;
}

// Address range: 0x618c9a - 0x618c9b
int32_t function_618c9a(void) {
    // 0x618c9a
    int32_t result; // 0x618c9a
    return result;
}

// Address range: 0x618dbe - 0x618dbf
int32_t function_618dbe(void) {
    // 0x618dbe
    int32_t result; // 0x618dbe
    return result;
}

// Address range: 0x618e4a - 0x618e4b
int32_t function_618e4a(void) {
    // 0x618e4a
    int32_t result; // 0x618e4a
    return result;
}

// Address range: 0x618e9a - 0x618e9b
int32_t function_618e9a(void) {
    // 0x618e9a
    int32_t result; // 0x618e9a
    return result;
}

// Address range: 0x618ece - 0x618ecf
int32_t function_618ece(void) {
    // 0x618ece
    int32_t result; // 0x618ece
    return result;
}

// Address range: 0x618f76 - 0x618f77
int32_t function_618f76(void) {
    // 0x618f76
    int32_t result; // 0x618f76
    return result;
}

// Address range: 0x618fce - 0x618fcf
int32_t function_618fce(void) {
    // 0x618fce
    int32_t result; // 0x618fce
    return result;
}

// Address range: 0x619026 - 0x619027
int32_t function_619026(void) {
    // 0x619026
    int32_t result; // 0x619026
    return result;
}

// Address range: 0x619116 - 0x619117
int32_t function_619116(void) {
    // 0x619116
    int32_t result; // 0x619116
    return result;
}

// Address range: 0x624cd2 - 0x624cd3
int32_t function_624cd2(void) {
    // 0x624cd2
    int32_t result; // 0x624cd2
    return result;
}

// Address range: 0x6256a2 - 0x6256a3
int32_t function_6256a2(void) {
    // 0x6256a2
    int32_t result; // 0x6256a2
    return result;
}

// Address range: 0x6256ca - 0x6256cb
int32_t function_6256ca(void) {
    // 0x6256ca
    int32_t result; // 0x6256ca
    return result;
}

// Address range: 0x6256f2 - 0x6256f3
int32_t function_6256f2(void) {
    // 0x6256f2
    int32_t result; // 0x6256f2
    return result;
}

// Address range: 0x625ade - 0x625adf
int32_t function_625ade(void) {
    // 0x625ade
    int32_t result; // 0x625ade
    return result;
}

// Address range: 0x625d7e - 0x625d7f
int32_t function_625d7e(void) {
    // 0x625d7e
    int32_t result; // 0x625d7e
    return result;
}

// Address range: 0x626566 - 0x626567
int32_t function_626566(void) {
    // 0x626566
    int32_t result; // 0x626566
    return result;
}

// Address range: 0x627a8a - 0x627a8b
int32_t function_627a8a(void) {
    // 0x627a8a
    int32_t result; // 0x627a8a
    return result;
}

// Address range: 0x627a9e - 0x627a9f
int32_t function_627a9e(void) {
    // 0x627a9e
    int32_t result; // 0x627a9e
    return result;
}

// Address range: 0x62948e - 0x62948f
int32_t function_62948e(void) {
    // 0x62948e
    int32_t result; // 0x62948e
    return result;
}

// Address range: 0x62b232 - 0x62b233
int32_t function_62b232(void) {
    // 0x62b232
    int32_t result; // 0x62b232
    return result;
}

// Address range: 0x62b56a - 0x62b56b
int32_t function_62b56a(void) {
    // 0x62b56a
    int32_t result; // 0x62b56a
    return result;
}

// Address range: 0x62b58a - 0x62b58b
int32_t function_62b58a(void) {
    // 0x62b58a
    int32_t result; // 0x62b58a
    return result;
}

// Address range: 0x62b5aa - 0x62b5ab
int32_t function_62b5aa(void) {
    // 0x62b5aa
    int32_t result; // 0x62b5aa
    return result;
}

// Address range: 0x62e1a2 - 0x62e1a3
int32_t function_62e1a2(void) {
    // 0x62e1a2
    int32_t result; // 0x62e1a2
    return result;
}

// Address range: 0x62e486 - 0x62e487
int32_t function_62e486(void) {
    // 0x62e486
    int32_t result; // 0x62e486
    return result;
}

// Address range: 0x62e4a6 - 0x62e4a7
int32_t function_62e4a6(void) {
    // 0x62e4a6
    int32_t result; // 0x62e4a6
    return result;
}

// Address range: 0x62ee76 - 0x62ee77
int32_t function_62ee76(void) {
    // 0x62ee76
    int32_t result; // 0x62ee76
    return result;
}

// Address range: 0x62ee9e - 0x62ee9f
int32_t function_62ee9e(void) {
    // 0x62ee9e
    int32_t result; // 0x62ee9e
    return result;
}

// Address range: 0x62f21e - 0x62f21f
int32_t function_62f21e(void) {
    // 0x62f21e
    int32_t result; // 0x62f21e
    return result;
}

// Address range: 0x62f29e - 0x62f29f
int32_t function_62f29e(void) {
    // 0x62f29e
    int32_t result; // 0x62f29e
    return result;
}

// Address range: 0x62f2c6 - 0x62f2c7
int32_t function_62f2c6(void) {
    // 0x62f2c6
    int32_t result; // 0x62f2c6
    return result;
}

// Address range: 0x62f2ee - 0x62f2ef
int32_t function_62f2ee(void) {
    // 0x62f2ee
    int32_t result; // 0x62f2ee
    return result;
}

// Address range: 0x631d8e - 0x631d8f
int32_t function_631d8e(void) {
    // 0x631d8e
    int32_t result; // 0x631d8e
    return result;
}

// Address range: 0x63d10a - 0x63d10b
int32_t function_63d10a(void) {
    // 0x63d10a
    int32_t result; // 0x63d10a
    return result;
}

// Address range: 0x63d152 - 0x63d153
int32_t function_63d152(void) {
    // 0x63d152
    int32_t result; // 0x63d152
    return result;
}

// Address range: 0x63d19a - 0x63d19b
int32_t function_63d19a(void) {
    // 0x63d19a
    int32_t result; // 0x63d19a
    return result;
}

// Address range: 0x63d1e2 - 0x63d1e3
int32_t function_63d1e2(void) {
    // 0x63d1e2
    int32_t result; // 0x63d1e2
    return result;
}

// Address range: 0x63d312 - 0x63d313
int32_t function_63d312(void) {
    // 0x63d312
    int32_t result; // 0x63d312
    return result;
}

// Address range: 0x63d3fe - 0x63d3ff
int32_t function_63d3fe(void) {
    // 0x63d3fe
    int32_t result; // 0x63d3fe
    return result;
}

// Address range: 0x63d442 - 0x63d443
int32_t function_63d442(void) {
    // 0x63d442
    int32_t result; // 0x63d442
    return result;
}

// Address range: 0x63d61e - 0x63d61f
int32_t function_63d61e(void) {
    // 0x63d61e
    int32_t result; // 0x63d61e
    return result;
}

// Address range: 0x64007a - 0x64007b
int32_t function_64007a(void) {
    // 0x64007a
    int32_t result; // 0x64007a
    return result;
}

// Address range: 0x6400c2 - 0x6400c3
int32_t function_6400c2(void) {
    // 0x6400c2
    int32_t result; // 0x6400c2
    return result;
}

// Address range: 0x64010a - 0x64010b
int32_t function_64010a(void) {
    // 0x64010a
    int32_t result; // 0x64010a
    return result;
}

// Address range: 0x640152 - 0x640153
int32_t function_640152(void) {
    // 0x640152
    int32_t result; // 0x640152
    return result;
}

// Address range: 0x64028a - 0x64028b
int32_t function_64028a(void) {
    // 0x64028a
    int32_t result; // 0x64028a
    return result;
}

// Address range: 0x6403b2 - 0x6403b3
int32_t function_6403b2(void) {
    // 0x6403b2
    int32_t result; // 0x6403b2
    return result;
}

// Address range: 0x640596 - 0x640597
int32_t function_640596(void) {
    // 0x640596
    int32_t result; // 0x640596
    return result;
}

// Address range: 0x6444b0 - 0x6444b1
int32_t function_6444b0(void) {
    // 0x6444b0
    int32_t result; // 0x6444b0
    return result;
}

// Address range: 0x66568a - 0x66568b
int32_t function_66568a(void) {
    // 0x66568a
    int32_t result; // 0x66568a
    return result;
}

// Address range: 0x6a201a - 0x6a201b
int32_t function_6a201a(void) {
    // 0x6a201a
    int32_t result; // 0x6a201a
    return result;
}

// Address range: 0x6d329e - 0x6d329f
int32_t function_6d329e(void) {
    // 0x6d329e
    int32_t result; // 0x6d329e
    return result;
}

// Address range: 0x6e7a76 - 0x6e7a77
int32_t function_6e7a76(void) {
    // 0x6e7a76
    int32_t result; // 0x6e7a76
    return result;
}

// Address range: 0x76c24a - 0x76c24b
int32_t function_76c24a(void) {
    // 0x76c24a
    int32_t result; // 0x76c24a
    return result;
}

// Address range: 0x76fbda - 0x76fbdb
int32_t function_76fbda(void) {
    // 0x76fbda
    int32_t result; // 0x76fbda
    return result;
}

// Address range: 0x798e96 - 0x798e97
int32_t function_798e96(void) {
    // 0x798e96
    int32_t result; // 0x798e96
    return result;
}

// Address range: 0x851f76 - 0x851f77
int32_t function_851f76(void) {
    // 0x851f76
    int32_t result; // 0x851f76
    return result;
}

// Address range: 0x8553da - 0x8553db
int32_t function_8553da(void) {
    // 0x8553da
    int32_t result; // 0x8553da
    return result;
}

// Address range: 0x96c55e - 0x96c55f
int32_t function_96c55e(void) {
    // 0x96c55e
    int32_t result; // 0x96c55e
    return result;
}

// Address range: 0x9e9d92 - 0x9e9d93
int32_t function_9e9d92(void) {
    // 0x9e9d92
    int32_t result; // 0x9e9d92
    return result;
}

// Address range: 0xa2bf7e - 0xa2bf7f
int32_t function_a2bf7e(void) {
    // 0xa2bf7e
    int32_t result; // 0xa2bf7e
    return result;
}

// Address range: 0xb11a5e - 0xb11a5f
int32_t function_b11a5e(void) {
    // 0xb11a5e
    int32_t result; // 0xb11a5e
    return result;
}

// Address range: 0xc25d6a - 0xc25d6b
int32_t function_c25d6a(void) {
    // 0xc25d6a
    int32_t result; // 0xc25d6a
    return result;
}

// Address range: 0xc51fce - 0xc51fcf
int32_t function_c51fce(void) {
    // 0xc51fce
    int32_t result; // 0xc51fce
    return result;
}

// Address range: 0xc98e46 - 0xc98e47
int32_t function_c98e46(void) {
    // 0xc98e46
    int32_t result; // 0xc98e46
    return result;
}

// Address range: 0xce5d56 - 0xce5d57
int32_t function_ce5d56(void) {
    // 0xce5d56
    int32_t result; // 0xce5d56
    return result;
}

// Address range: 0xcf4d2a - 0xcf4d2b
int32_t function_cf4d2a(void) {
    // 0xcf4d2a
    int32_t result; // 0xcf4d2a
    return result;
}

// Address range: 0xcf59b2 - 0xcf59b3
int32_t function_cf59b2(void) {
    // 0xcf59b2
    int32_t result; // 0xcf59b2
    return result;
}

// Address range: 0xd11a3e - 0xd11a3f
int32_t function_d11a3e(void) {
    // 0xd11a3e
    int32_t result; // 0xd11a3e
    return result;
}

// Address range: 0xd57dd2 - 0xd57dd3
int32_t function_d57dd2(void) {
    // 0xd57dd2
    int32_t result; // 0xd57dd2
    return result;
}

// Address range: 0xd74406 - 0xd74407
int32_t function_d74406(void) {
    // 0xd74406
    int32_t result; // 0xd74406
    return result;
}

// Address range: 0xe1580a - 0xe1580b
int32_t function_e1580a(void) {
    // 0xe1580a
    int32_t result; // 0xe1580a
    return result;
}

// Address range: 0xe666ae - 0xe666af
int32_t function_e666ae(void) {
    // 0xe666ae
    int32_t result; // 0xe666ae
    return result;
}

// Address range: 0xe666c6 - 0xe666c7
int32_t function_e666c6(void) {
    // 0xe666c6
    int32_t result; // 0xe666c6
    return result;
}

// Address range: 0xe6808a - 0xe6808b
int32_t function_e6808a(void) {
    // 0xe6808a
    int32_t result; // 0xe6808a
    return result;
}

// Address range: 0xe6809e - 0xe6809f
int32_t function_e6809e(void) {
    // 0xe6809e
    int32_t result; // 0xe6809e
    return result;
}

// Address range: 0xe68876 - 0xe68877
int32_t function_e68876(void) {
    // 0xe68876
    int32_t result; // 0xe68876
    return result;
}

// Address range: 0xe6e4c6 - 0xe6e4c7
int32_t function_e6e4c6(void) {
    // 0xe6e4c6
    int32_t result; // 0xe6e4c6
    return result;
}

// Address range: 0xee2f86 - 0xee2f87
int32_t function_ee2f86(void) {
    // 0xee2f86
    int32_t result; // 0xee2f86
    return result;
}

// Address range: 0xf11a1e - 0xf11a1f
int32_t function_f11a1e(void) {
    // 0xf11a1e
    int32_t result; // 0xf11a1e
    return result;
}

// Address range: 0x1052c22 - 0x1052c23
int32_t function_1052c22(void) {
    // 0x1052c22
    int32_t result; // 0x1052c22
    return result;
}

// Address range: 0x1052c7a - 0x1052c7b
int32_t function_1052c7a(void) {
    // 0x1052c7a
    int32_t result; // 0x1052c7a
    return result;
}

// Address range: 0x1056086 - 0x1056087
int32_t function_1056086(void) {
    // 0x1056086
    int32_t result; // 0x1056086
    return result;
}

// Address range: 0x10560de - 0x10560df
int32_t function_10560de(void) {
    // 0x10560de
    int32_t result; // 0x10560de
    return result;
}

// Address range: 0x1060efe - 0x1060eff
int32_t function_1060efe(void) {
    // 0x1060efe
    int32_t result; // 0x1060efe
    return result;
}

// Address range: 0x1062e62 - 0x1062e63
int32_t function_1062e62(void) {
    // 0x1062e62
    int32_t result; // 0x1062e62
    return result;
}

// Address range: 0x1062e6e - 0x1062e6f
int32_t function_1062e6e(void) {
    // 0x1062e6e
    int32_t result; // 0x1062e6e
    return result;
}

// Address range: 0x1063e52 - 0x1063e53
int32_t function_1063e52(void) {
    // 0x1063e52
    int32_t result; // 0x1063e52
    return result;
}

// Address range: 0x106400e - 0x106400f
int32_t function_106400e(void) {
    // 0x106400e
    int32_t result; // 0x106400e
    return result;
}

// Address range: 0x1064b82 - 0x1064b83
int32_t function_1064b82(void) {
    // 0x1064b82
    int32_t result; // 0x1064b82
    return result;
}

// Address range: 0x1064efa - 0x1064efb
int32_t function_1064efa(void) {
    // 0x1064efa
    int32_t result; // 0x1064efa
    return result;
}

// Address range: 0x106b28a - 0x106b28b
int32_t function_106b28a(void) {
    // 0x106b28a
    int32_t result; // 0x106b28a
    return result;
}

// Address range: 0x10a43aa - 0x10a43ab
int32_t function_10a43aa(void) {
    // 0x10a43aa
    int32_t result; // 0x10a43aa
    return result;
}

// Address range: 0x11557d6 - 0x11557d7
int32_t function_11557d6(void) {
    // 0x11557d6
    int32_t result; // 0x11557d6
    return result;
}

// Address range: 0x11af142 - 0x11af143
int32_t function_11af142(void) {
    // 0x11af142
    int32_t result; // 0x11af142
    return result;
}

// Address range: 0x11c4bfc - 0x11c4bfd
int32_t function_11c4bfc(void) {
    // 0x11c4bfc
    int32_t result; // 0x11c4bfc
    return result;
}

// Address range: 0x11e0eb6 - 0x11e0eb7
int32_t function_11e0eb6(void) {
    // 0x11e0eb6
    int32_t result; // 0x11e0eb6
    return result;
}

// Address range: 0x11e549e - 0x11e549f
int32_t function_11e549e(void) {
    // 0x11e549e
    int32_t result; // 0x11e549e
    return result;
}

// Address range: 0x11e54c6 - 0x11e54c7
int32_t function_11e54c6(void) {
    // 0x11e54c6
    int32_t result; // 0x11e54c6
    return result;
}

// Address range: 0x11ee7ae - 0x11ee7af
int32_t function_11ee7ae(void) {
    // 0x11ee7ae
    int32_t result; // 0x11ee7ae
    return result;
}

// Address range: 0x11ee7c6 - 0x11ee7c7
int32_t function_11ee7c6(void) {
    // 0x11ee7c6
    int32_t result; // 0x11ee7c6
    return result;
}

// Address range: 0x11f018a - 0x11f018b
int32_t function_11f018a(void) {
    // 0x11f018a
    int32_t result; // 0x11f018a
    return result;
}

// Address range: 0x11f019e - 0x11f019f
int32_t function_11f019e(void) {
    // 0x11f019e
    int32_t result; // 0x11f019e
    return result;
}

// Address range: 0x11f2a7a - 0x11f2a7b
int32_t function_11f2a7a(void) {
    // 0x11f2a7a
    int32_t result; // 0x11f2a7a
    return result;
}

// Address range: 0x1220f0e - 0x1220f0f
int32_t function_1220f0e(void) {
    // 0x1220f0e
    int32_t result; // 0x1220f0e
    return result;
}

// Address range: 0x1220f66 - 0x1220f67
int32_t function_1220f66(void) {
    // 0x1220f66
    int32_t result; // 0x1220f66
    return result;
}

// Address range: 0x12246fa - 0x12246fb
int32_t function_12246fa(void) {
    // 0x12246fa
    int32_t result; // 0x12246fa
    return result;
}

// Address range: 0x1224bbe - 0x1224bbf
int32_t function_1224bbe(void) {
    // 0x1224bbe
    int32_t result; // 0x1224bbe
    return result;
}

// Address range: 0x1224c7a - 0x1224c7b
int32_t function_1224c7a(void) {
    // 0x1224c7a
    int32_t result; // 0x1224c7a
    return result;
}

// Address range: 0x1224cae - 0x1224caf
int32_t function_1224cae(void) {
    // 0x1224cae
    int32_t result; // 0x1224cae
    return result;
}

// Address range: 0x1224f72 - 0x1224f73
int32_t function_1224f72(void) {
    // 0x1224f72
    int32_t result; // 0x1224f72
    return result;
}

// Address range: 0x122e242 - 0x122e243
int32_t function_122e242(void) {
    // 0x122e242
    int32_t result; // 0x122e242
    return result;
}

// Address range: 0x122ee72 - 0x122ee73
int32_t function_122ee72(void) {
    // 0x122ee72
    int32_t result; // 0x122ee72
    return result;
}

// Address range: 0x122fc1a - 0x122fc1b
int32_t function_122fc1a(void) {
    // 0x122fc1a
    int32_t result; // 0x122fc1a
    return result;
}

// Address range: 0x122fd06 - 0x122fd07
int32_t function_122fd06(void) {
    // 0x122fd06
    int32_t result; // 0x122fd06
    return result;
}

// Address range: 0x12435a6 - 0x12435a7
int32_t function_12435a6(void) {
    // 0x12435a6
    int32_t result; // 0x12435a6
    return result;
}

// Address range: 0x1243656 - 0x1243657
int32_t function_1243656(void) {
    // 0x1243656
    int32_t result; // 0x1243656
    return result;
}

// Address range: 0x1244ec4 - 0x1244ec5
int32_t function_1244ec4(void) {
    // 0x1244ec4
    int32_t result; // 0x1244ec4
    return result;
}

// Address range: 0x1262b5e - 0x1262b5f
int32_t function_1262b5e(void) {
    // 0x1262b5e
    int32_t result; // 0x1262b5e
    return result;
}

// Address range: 0x1262c1e - 0x1262c1f
int32_t function_1262c1e(void) {
    // 0x1262c1e
    int32_t result; // 0x1262c1e
    return result;
}

// Address range: 0x1262fb2 - 0x1262fb3
int32_t function_1262fb2(void) {
    // 0x1262fb2
    int32_t result; // 0x1262fb2
    return result;
}

// Address range: 0x126beaa - 0x126beab
int32_t function_126beaa(void) {
    // 0x126beaa
    int32_t result; // 0x126beaa
    return result;
}

// Address range: 0x126eb2a - 0x126eb2b
int32_t function_126eb2a(void) {
    // 0x126eb2a
    int32_t result; // 0x126eb2a
    return result;
}

// Address range: 0x126ef3e - 0x126ef3f
int32_t function_126ef3e(void) {
    // 0x126ef3e
    int32_t result; // 0x126ef3e
    return result;
}

// Address range: 0x126ef7a - 0x126ef7b
int32_t function_126ef7a(void) {
    // 0x126ef7a
    int32_t result; // 0x126ef7a
    return result;
}

// Address range: 0x127d636 - 0x127d637
int32_t function_127d636(void) {
    // 0x127d636
    int32_t result; // 0x127d636
    return result;
}

// Address range: 0x127d942 - 0x127d943
int32_t function_127d942(void) {
    // 0x127d942
    int32_t result; // 0x127d942
    return result;
}

// Address range: 0x1292f12 - 0x1292f13
int32_t function_1292f12(void) {
    // 0x1292f12
    int32_t result; // 0x1292f12
    return result;
}

// Address range: 0x1292f6a - 0x1292f6b
int32_t function_1292f6a(void) {
    // 0x1292f6a
    int32_t result; // 0x1292f6a
    return result;
}

// Address range: 0x12ac7ca - 0x12ac7cb
int32_t function_12ac7ca(void) {
    // 0x12ac7ca
    int32_t result; // 0x12ac7ca
    return result;
}

// Address range: 0x12ec54e - 0x12ec54f
int32_t function_12ec54e(void) {
    // 0x12ec54e
    int32_t result; // 0x12ec54e
    return result;
}

// Address range: 0x12ef1f6 - 0x12ef1f7
int32_t function_12ef1f6(void) {
    // 0x12ef1f6
    int32_t result; // 0x12ef1f6
    return result;
}

// Address range: 0x12ef242 - 0x12ef243
int32_t function_12ef242(void) {
    // 0x12ef242
    int32_t result; // 0x12ef242
    return result;
}

// Address range: 0x12ef266 - 0x12ef267
int32_t function_12ef266(void) {
    // 0x12ef266
    int32_t result; // 0x12ef266
    return result;
}

// Address range: 0x12ef5de - 0x12ef5df
int32_t function_12ef5de(void) {
    // 0x12ef5de
    int32_t result; // 0x12ef5de
    return result;
}

// Address range: 0x12ef61a - 0x12ef61b
int32_t function_12ef61a(void) {
    // 0x12ef61a
    int32_t result; // 0x12ef61a
    return result;
}

// Address range: 0x136ef5a - 0x136ef5b
int32_t function_136ef5a(void) {
    // 0x136ef5a
    int32_t result; // 0x136ef5a
    return result;
}

// Address range: 0x13ae48a - 0x13ae48b
int32_t function_13ae48a(void) {
    // 0x13ae48a
    int32_t result; // 0x13ae48a
    return result;
}

// Address range: 0x13aef76 - 0x13aef77
int32_t function_13aef76(void) {
    // 0x13aef76
    int32_t result; // 0x13aef76
    return result;
}

// Address range: 0x13d19d2 - 0x13d19d3
int32_t function_13d19d2(void) {
    // 0x13d19d2
    int32_t result; // 0x13d19d2
    return result;
}

// Address range: 0x13edf06 - 0x13edf07
int32_t function_13edf06(void) {
    // 0x13edf06
    int32_t result; // 0x13edf06
    return result;
}

// Address range: 0x14093c8 - 0x14093c9
int32_t function_14093c8(void) {
    // 0x14093c8
    int32_t result; // 0x14093c8
    return result;
}

// Address range: 0x140978c - 0x140978d
int32_t function_140978c(void) {
    // 0x140978c
    int32_t result; // 0x140978c
    return result;
}

// Address range: 0x1409a4c - 0x1409a4d
int32_t function_1409a4c(void) {
    // 0x1409a4c
    int32_t result; // 0x1409a4c
    return result;
}

// Address range: 0x140a10c - 0x140a10d
int32_t function_140a10c(void) {
    // 0x140a10c
    int32_t result; // 0x140a10c
    return result;
}

// Address range: 0x14364c4 - 0x14364c5
int32_t function_14364c4(void) {
    // 0x14364c4
    int32_t result; // 0x14364c4
    return result;
}

// Address range: 0x1558dba - 0x1558dbb
int32_t function_1558dba(void) {
    // 0x1558dba
    int32_t result; // 0x1558dba
    return result;
}

// Address range: 0x1578c94 - 0x1578c95
int32_t function_1578c94(void) {
    // 0x1578c94
    int32_t result; // 0x1578c94
    return result;
}

// Address range: 0x158c01c - 0x158c01d
int32_t function_158c01c(void) {
    // 0x158c01c
    int32_t result; // 0x158c01c
    return result;
}

// Address range: 0x1655786 - 0x1655787
int32_t function_1655786(void) {
    // 0x1655786
    int32_t result; // 0x1655786
    return result;
}

// Address range: 0x16d1e0e - 0x16d1e0f
int32_t function_16d1e0e(void) {
    // 0x16d1e0e
    int32_t result; // 0x16d1e0e
    return result;
}

// Address range: 0x17666ba - 0x17666bb
int32_t function_17666ba(void) {
    // 0x17666ba
    int32_t result; // 0x17666ba
    return result;
}

// Address range: 0x17a631e - 0x17a631f
int32_t function_17a631e(void) {
    // 0x17a631e
    int32_t result; // 0x17a631e
    return result;
}

// Address range: 0x17f416a - 0x17f416b
int32_t function_17f416a(void) {
    // 0x17f416a
    int32_t result; // 0x17f416a
    return result;
}

// Address range: 0x17f4a86 - 0x17f4a87
int32_t function_17f4a86(void) {
    // 0x17f4a86
    int32_t result; // 0x17f4a86
    return result;
}

// Address range: 0x17f56ee - 0x17f56ef
int32_t function_17f56ee(void) {
    // 0x17f56ee
    int32_t result; // 0x17f56ee
    return result;
}

// Address range: 0x18552ee - 0x18552ef
int32_t function_18552ee(void) {
    // 0x18552ee
    int32_t result; // 0x18552ee
    return result;
}

// Address range: 0x19eed7a - 0x19eed7b
int32_t function_19eed7a(void) {
    // 0x19eed7a
    int32_t result; // 0x19eed7a
    return result;
}

// Address range: 0x1bfd84a - 0x1bfd84b
int32_t function_1bfd84a(void) {
    // 0x1bfd84a
    int32_t result; // 0x1bfd84a
    return result;
}

// Address range: 0x1d60442 - 0x1d60443
int32_t function_1d60442(void) {
    // 0x1d60442
    int32_t result; // 0x1d60442
    return result;
}

// Address range: 0x1d9622a - 0x1d9622b
int32_t function_1d9622a(void) {
    // 0x1d9622a
    int32_t result; // 0x1d9622a
    return result;
}

// Address range: 0x1db83a6 - 0x1db83a7
int32_t function_1db83a6(void) {
    // 0x1db83a6
    int32_t result; // 0x1db83a6
    return result;
}

// Address range: 0x1de0bda - 0x1de0bdb
int32_t function_1de0bda(void) {
    // 0x1de0bda
    int32_t result; // 0x1de0bda
    return result;
}

// Address range: 0x1e65cd2 - 0x1e65cd3
int32_t function_1e65cd2(void) {
    // 0x1e65cd2
    int32_t result; // 0x1e65cd2
    return result;
}

// Address range: 0x1f156fa - 0x1f156fb
int32_t function_1f156fa(void) {
    // 0x1f156fa
    int32_t result; // 0x1f156fa
    return result;
}

// Address range: 0x1f68666 - 0x1f68667
int32_t function_1f68666(void) {
    // 0x1f68666
    int32_t result; // 0x1f68666
    return result;
}

// Address range: 0x1f94f66 - 0x1f94f67
int32_t function_1f94f66(void) {
    // 0x1f94f66
    int32_t result; // 0x1f94f66
    return result;
}

// Address range: 0x1fd9112 - 0x1fd9113
int32_t function_1fd9112(void) {
    // 0x1fd9112
    int32_t result; // 0x1fd9112
    return result;
}

// Address range: 0x1fe1e86 - 0x1fe1e87
int32_t function_1fe1e86(void) {
    // 0x1fe1e86
    int32_t result; // 0x1fe1e86
    return result;
}

// Address range: 0x200c028 - 0x200c029
int32_t function_200c028(void) {
    // 0x200c028
    int32_t result; // 0x200c028
    return result;
}

// Address range: 0x20201b4 - 0x20201b5
int32_t function_20201b4(void) {
    // 0x20201b4
    int32_t result; // 0x20201b4
    return result;
}

// Address range: 0x200ae58d - 0x200ae58e
int32_t function_200ae58d(void) {
    // 0x200ae58d
    int32_t result; // 0x200ae58d
    return result;
}

// Address range: 0xe1a01fc0 - 0xe1a01fc1
int32_t function_e1a01fc0(void) {
    // 0xe1a01fc0
    int32_t result; // 0xe1a01fc0
    return result;
}

// Address range: 0xfe0e4f4a - 0xfe0e4f4b
int32_t function_fe0e4f4a(void) {
    // 0xfe0e4f4a
    int32_t result; // 0xfe0e4f4a
    return result;
}

// Address range: 0xfe0e863e - 0xfe0e863f
int32_t function_fe0e863e(void) {
    // 0xfe0e863e
    int32_t result; // 0xfe0e863e
    return result;
}

// Address range: 0xfe264f22 - 0xfe264f23
int32_t function_fe264f22(void) {
    // 0xfe264f22
    int32_t result; // 0xfe264f22
    return result;
}

// Address range: 0xfe268616 - 0xfe268617
int32_t function_fe268616(void) {
    // 0xfe268616
    int32_t result; // 0xfe268616
    return result;
}

// Address range: 0xfe2ae1d2 - 0xfe2ae1d3
int32_t function_fe2ae1d2(void) {
    // 0xfe2ae1d2
    int32_t result; // 0xfe2ae1d2
    return result;
}

// Address range: 0xfe2e9066 - 0xfe2e9067
int32_t function_fe2e9066(void) {
    // 0xfe2e9066
    int32_t result; // 0xfe2e9066
    return result;
}

// Address range: 0xfe3161d2 - 0xfe3161d3
int32_t function_fe3161d2(void) {
    // 0xfe3161d2
    int32_t result; // 0xfe3161d2
    return result;
}

// Address range: 0xfe36c5f2 - 0xfe36c5f3
int32_t function_fe36c5f2(void) {
    // 0xfe36c5f2
    int32_t result; // 0xfe36c5f2
    return result;
}

// Address range: 0xfe3e5472 - 0xfe3e5473
int32_t function_fe3e5472(void) {
    // 0xfe3e5472
    int32_t result; // 0xfe3e5472
    return result;
}

// Address range: 0xfe41bd7a - 0xfe41bd7b
int32_t function_fe41bd7a(void) {
    // 0xfe41bd7a
    int32_t result; // 0xfe41bd7a
    return result;
}

// Address range: 0xfe42c8c2 - 0xfe42c8c3
int32_t function_fe42c8c2(void) {
    // 0xfe42c8c2
    int32_t result; // 0xfe42c8c2
    return result;
}

// Address range: 0xfe45c5fe - 0xfe45c5ff
int32_t function_fe45c5fe(void) {
    // 0xfe45c5fe
    int32_t result; // 0xfe45c5fe
    return result;
}

// Address range: 0xfe462faa - 0xfe462fab
int32_t function_fe462faa(void) {
    // 0xfe462faa
    int32_t result; // 0xfe462faa
    return result;
}

// Address range: 0xfe46eec6 - 0xfe46eec7
int32_t function_fe46eec6(void) {
    // 0xfe46eec6
    int32_t result; // 0xfe46eec6
    return result;
}

// Address range: 0xfe46ef42 - 0xfe46ef43
int32_t function_fe46ef42(void) {
    // 0xfe46ef42
    int32_t result; // 0xfe46ef42
    return result;
}

// Address range: 0xfe46f256 - 0xfe46f257
int32_t function_fe46f256(void) {
    // 0xfe46f256
    int32_t result; // 0xfe46f256
    return result;
}

// Address range: 0xfe46f5e2 - 0xfe46f5e3
int32_t function_fe46f5e2(void) {
    // 0xfe46f5e2
    int32_t result; // 0xfe46f5e2
    return result;
}

// Address range: 0xfe47d53e - 0xfe47d53f
int32_t function_fe47d53e(void) {
    // 0xfe47d53e
    int32_t result; // 0xfe47d53e
    return result;
}

// Address range: 0xfe484c50 - 0xfe484c51
int32_t function_fe484c50(void) {
    // 0xfe484c50
    int32_t result; // 0xfe484c50
    return result;
}

// Address range: 0xfe4e79d2 - 0xfe4e79d3
int32_t function_fe4e79d2(void) {
    // 0xfe4e79d2
    int32_t result; // 0xfe4e79d2
    return result;
}

// Address range: 0xfe4eb57a - 0xfe4eb57b
int32_t function_fe4eb57a(void) {
    // 0xfe4eb57a
    int32_t result; // 0xfe4eb57a
    return result;
}

// Address range: 0xfe54a518 - 0xfe54a519
int32_t function_fe54a518(void) {
    // 0xfe54a518
    int32_t result; // 0xfe54a518
    return result;
}

// Address range: 0xfe562512 - 0xfe562513
int32_t function_fe562512(void) {
    // 0xfe562512
    int32_t result; // 0xfe562512
    return result;
}

// Address range: 0xfe56256a - 0xfe56256b
int32_t function_fe56256a(void) {
    // 0xfe56256a
    int32_t result; // 0xfe56256a
    return result;
}

// Address range: 0xfe563882 - 0xfe563883
int32_t function_fe563882(void) {
    // 0xfe563882
    int32_t result; // 0xfe563882
    return result;
}

// Address range: 0xfe5638da - 0xfe5638db
int32_t function_fe5638da(void) {
    // 0xfe5638da
    int32_t result; // 0xfe5638da
    return result;
}

// Address range: 0xfe56aaaa - 0xfe56aaab
int32_t function_fe56aaaa(void) {
    // 0xfe56aaaa
    int32_t result; // 0xfe56aaaa
    return result;
}

// Address range: 0xfe66e18e - 0xfe66e18f
int32_t function_fe66e18e(void) {
    // 0xfe66e18e
    int32_t result; // 0xfe66e18e
    return result;
}

// Address range: 0xfe6af176 - 0xfe6af177
int32_t function_fe6af176(void) {
    // 0xfe6af176
    int32_t result; // 0xfe6af176
    return result;
}

// Address range: 0xfe6d9c8c - 0xfe6d9c8d
int32_t function_fe6d9c8c(void) {
    // 0xfe6d9c8c
    int32_t result; // 0xfe6d9c8c
    return result;
}

// Address range: 0xfe6d9c98 - 0xfe6d9c99
int32_t function_fe6d9c98(void) {
    // 0xfe6d9c98
    int32_t result; // 0xfe6d9c98
    return result;
}

// Address range: 0xfe72e17a - 0xfe72e17b
int32_t function_fe72e17a(void) {
    // 0xfe72e17a
    int32_t result; // 0xfe72e17a
    return result;
}

// Address range: 0xfe798c96 - 0xfe798c97
int32_t function_fe798c96(void) {
    // 0xfe798c96
    int32_t result; // 0xfe798c96
    return result;
}

// Address range: 0xfe8d5862 - 0xfe8d5863
int32_t function_fe8d5862(void) {
    // 0xfe8d5862
    int32_t result; // 0xfe8d5862
    return result;
}

// Address range: 0xfe918c7e - 0xfe918c7f
int32_t function_fe918c7e(void) {
    // 0xfe918c7e
    int32_t result; // 0xfe918c7e
    return result;
}

// Address range: 0xfe96f636 - 0xfe96f637
int32_t function_fe96f636(void) {
    // 0xfe96f636
    int32_t result; // 0xfe96f636
    return result;
}

// Address range: 0xfe995a52 - 0xfe995a53
int32_t function_fe995a52(void) {
    // 0xfe995a52
    int32_t result; // 0xfe995a52
    return result;
}

// Address range: 0xfeaef326 - 0xfeaef327
int32_t function_feaef326(void) {
    // 0xfeaef326
    int32_t result; // 0xfeaef326
    return result;
}

// Address range: 0xfeb2c56a - 0xfeb2c56b
int32_t function_feb2c56a(void) {
    // 0xfeb2c56a
    int32_t result; // 0xfeb2c56a
    return result;
}

// Address range: 0xfeb60f2a - 0xfeb60f2b
int32_t function_feb60f2a(void) {
    // 0xfeb60f2a
    int32_t result; // 0xfeb60f2a
    return result;
}

// Address range: 0xfebd2b5e - 0xfebd2b5f
int32_t function_febd2b5e(void) {
    // 0xfebd2b5e
    int32_t result; // 0xfebd2b5e
    return result;
}

// Address range: 0xfec2f5fa - 0xfec2f5fb
int32_t function_fec2f5fa(void) {
    // 0xfec2f5fa
    int32_t result; // 0xfec2f5fa
    return result;
}

// Address range: 0xfeed9022 - 0xfeed9023
int32_t function_feed9022(void) {
    // 0xfeed9022
    int32_t result; // 0xfeed9022
    return result;
}

// Address range: 0xff055dda - 0xff055ddb
int32_t function_ff055dda(void) {
    // 0xff055dda
    int32_t result; // 0xff055dda
    return result;
}

// Address range: 0xff05b11a - 0xff05b11b
int32_t function_ff05b11a(void) {
    // 0xff05b11a
    int32_t result; // 0xff05b11a
    return result;
}

// Address range: 0xff062c8e - 0xff062c8f
int32_t function_ff062c8e(void) {
    // 0xff062c8e
    int32_t result; // 0xff062c8e
    return result;
}

// Address range: 0xff06e49e - 0xff06e49f
int32_t function_ff06e49e(void) {
    // 0xff06e49e
    int32_t result; // 0xff06e49e
    return result;
}

// Address range: 0xff06e4be - 0xff06e4bf
int32_t function_ff06e4be(void) {
    // 0xff06e4be
    int32_t result; // 0xff06e4be
    return result;
}

// Address range: 0xff06e86a - 0xff06e86b
int32_t function_ff06e86a(void) {
    // 0xff06e86a
    int32_t result; // 0xff06e86a
    return result;
}

// Address range: 0xff06eb3e - 0xff06eb3f
int32_t function_ff06eb3e(void) {
    // 0xff06eb3e
    int32_t result; // 0xff06eb3e
    return result;
}

// Address range: 0xff06eb5e - 0xff06eb5f
int32_t function_ff06eb5e(void) {
    // 0xff06eb5e
    int32_t result; // 0xff06eb5e
    return result;
}

// Address range: 0xff06ebca - 0xff06ebcb
int32_t function_ff06ebca(void) {
    // 0xff06ebca
    int32_t result; // 0xff06ebca
    return result;
}

// Address range: 0xff06ec12 - 0xff06ec13
int32_t function_ff06ec12(void) {
    // 0xff06ec12
    int32_t result; // 0xff06ec12
    return result;
}

// Address range: 0xff06f0ae - 0xff06f0af
int32_t function_ff06f0ae(void) {
    // 0xff06f0ae
    int32_t result; // 0xff06f0ae
    return result;
}

// Address range: 0xff08315e - 0xff08315f
int32_t function_ff08315e(void) {
    // 0xff08315e
    int32_t result; // 0xff08315e
    return result;
}

// Address range: 0xff08320e - 0xff08320f
int32_t function_ff08320e(void) {
    // 0xff08320e
    int32_t result; // 0xff08320e
    return result;
}

// Address range: 0xff084e84 - 0xff084e85
int32_t function_ff084e84(void) {
    // 0xff084e84
    int32_t result; // 0xff084e84
    return result;
}

// Address range: 0xff152e3a - 0xff152e3b
int32_t function_ff152e3a(void) {
    // 0xff152e3a
    int32_t result; // 0xff152e3a
    return result;
}

// Address range: 0xff1555d6 - 0xff1555d7
int32_t function_ff1555d6(void) {
    // 0xff1555d6
    int32_t result; // 0xff1555d6
    return result;
}

// Address range: 0xff16ee82 - 0xff16ee83
int32_t function_ff16ee82(void) {
    // 0xff16ee82
    int32_t result; // 0xff16ee82
    return result;
}

// Address range: 0xff1d3216 - 0xff1d3217
int32_t function_ff1d3216(void) {
    // 0xff1d3216
    int32_t result; // 0xff1d3216
    return result;
}

// Address range: 0xff1dc2de - 0xff1dc2df
int32_t function_ff1dc2de(void) {
    // 0xff1dc2de
    int32_t result; // 0xff1dc2de
    return result;
}

// Address range: 0xff1ec382 - 0xff1ec383
int32_t function_ff1ec382(void) {
    // 0xff1ec382
    int32_t result; // 0xff1ec382
    return result;
}

// Address range: 0xff1f513e - 0xff1f513f
int32_t function_ff1f513e(void) {
    // 0xff1f513e
    int32_t result; // 0xff1f513e
    return result;
}

// Address range: 0xff204fe0 - 0xff204fe1
int32_t function_ff204fe0(void) {
    // 0xff204fe0
    int32_t result; // 0xff204fe0
    return result;
}

// Address range: 0xff218f0e - 0xff218f0f
int32_t function_ff218f0e(void) {
    // 0xff218f0e
    int32_t result; // 0xff218f0e
    return result;
}

// Address range: 0xff2238ca - 0xff2238cb
int32_t function_ff2238ca(void) {
    // 0xff2238ca
    int32_t result; // 0xff2238ca
    return result;
}

// Address range: 0xff229246 - 0xff229247
int32_t function_ff229246(void) {
    // 0xff229246
    int32_t result; // 0xff229246
    return result;
}

// Address range: 0xff2296ce - 0xff2296cf
int32_t function_ff2296ce(void) {
    // 0xff2296ce
    int32_t result; // 0xff2296ce
    return result;
}

// Address range: 0xff22def2 - 0xff22def3
int32_t function_ff22def2(void) {
    // 0xff22def2
    int32_t result; // 0xff22def2
    return result;
}

// Address range: 0xff22f12a - 0xff22f12b
int32_t function_ff22f12a(void) {
    // 0xff22f12a
    int32_t result; // 0xff22f12a
    return result;
}

// Address range: 0xff230936 - 0xff230937
int32_t function_ff230936(void) {
    // 0xff230936
    int32_t result; // 0xff230936
    return result;
}

// Address range: 0xff23496a - 0xff23496b
int32_t function_ff23496a(void) {
    // 0xff23496a
    int32_t result; // 0xff23496a
    return result;
}

// Address range: 0xff2422de - 0xff2422df
int32_t function_ff2422de(void) {
    // 0xff2422de
    int32_t result; // 0xff2422de
    return result;
}

// Address range: 0xff244ed0 - 0xff244ed1
int32_t function_ff244ed0(void) {
    // 0xff244ed0
    int32_t result; // 0xff244ed0
    return result;
}

// Address range: 0xff27d302 - 0xff27d303
int32_t function_ff27d302(void) {
    // 0xff27d302
    int32_t result; // 0xff27d302
    return result;
}

// Address range: 0xff27d856 - 0xff27d857
int32_t function_ff27d856(void) {
    // 0xff27d856
    int32_t result; // 0xff27d856
    return result;
}

// Address range: 0xff2d55be - 0xff2d55bf
int32_t function_ff2d55be(void) {
    // 0xff2d55be
    int32_t result; // 0xff2d55be
    return result;
}

// Address range: 0xff352e7e - 0xff352e7f
int32_t function_ff352e7e(void) {
    // 0xff352e7e
    int32_t result; // 0xff352e7e
    return result;
}

// Address range: 0xff458fca - 0xff458fcb
int32_t function_ff458fca(void) {
    // 0xff458fca
    int32_t result; // 0xff458fca
    return result;
}

// Address range: 0xff462676 - 0xff462677
int32_t function_ff462676(void) {
    // 0xff462676
    int32_t result; // 0xff462676
    return result;
}

// Address range: 0xff552ec2 - 0xff552ec3
int32_t function_ff552ec2(void) {
    // 0xff552ec2
    int32_t result; // 0xff552ec2
    return result;
}

// Address range: 0xff554a46 - 0xff554a47
int32_t function_ff554a46(void) {
    // 0xff554a46
    int32_t result; // 0xff554a46
    return result;
}

// Address range: 0xff57c4ce - 0xff57c4cf
int32_t function_ff57c4ce(void) {
    // 0xff57c4ce
    int32_t result; // 0xff57c4ce
    return result;
}

// Address range: 0xff655586 - 0xff655587
int32_t function_ff655586(void) {
    // 0xff655586
    int32_t result; // 0xff655586
    return result;
}

// Address range: 0xff662662 - 0xff662663
int32_t function_ff662662(void) {
    // 0xff662662
    int32_t result; // 0xff662662
    return result;
}

// Address range: 0xff82e20e - 0xff82e20f
int32_t function_ff82e20e(void) {
    // 0xff82e20e
    int32_t result; // 0xff82e20e
    return result;
}

// Address range: 0xff852ee6 - 0xff852ee7
int32_t function_ff852ee6(void) {
    // 0xff852ee6
    int32_t result; // 0xff852ee6
    return result;
}

// Address range: 0xff895962 - 0xff895963
int32_t function_ff895962(void) {
    // 0xff895962
    int32_t result; // 0xff895962
    return result;
}

// Address range: 0xff9d8f72 - 0xff9d8f73
int32_t function_ff9d8f72(void) {
    // 0xff9d8f72
    int32_t result; // 0xff9d8f72
    return result;
}

// Address range: 0xff9e8f7a - 0xff9e8f7b
int32_t function_ff9e8f7a(void) {
    // 0xff9e8f7a
    int32_t result; // 0xff9e8f7a
    return result;
}

// Address range: 0xff9f45fa - 0xff9f45fb
int32_t function_ff9f45fa(void) {
    // 0xff9f45fa
    int32_t result; // 0xff9f45fa
    return result;
}

// Address range: 0xffa14d9a - 0xffa14d9b
int32_t function_ffa14d9a(void) {
    // 0xffa14d9a
    int32_t result; // 0xffa14d9a
    return result;
}

// Address range: 0xffa1c216 - 0xffa1c217
int32_t function_ffa1c216(void) {
    // 0xffa1c216
    int32_t result; // 0xffa1c216
    return result;
}

// Address range: 0xffa2ceca - 0xffa2cecb
int32_t function_ffa2ceca(void) {
    // 0xffa2ceca
    int32_t result; // 0xffa2ceca
    return result;
}

// Address range: 0xffa2eca2 - 0xffa2eca3
int32_t function_ffa2eca2(void) {
    // 0xffa2eca2
    int32_t result; // 0xffa2eca2
    return result;
}

// Address range: 0xffa2f1ee - 0xffa2f1ef
int32_t function_ffa2f1ee(void) {
    // 0xffa2f1ee
    int32_t result; // 0xffa2f1ee
    return result;
}

// Address range: 0xffa2f342 - 0xffa2f343
int32_t function_ffa2f342(void) {
    // 0xffa2f342
    int32_t result; // 0xffa2f342
    return result;
}

// Address range: 0xffa3d27e - 0xffa3d27f
int32_t function_ffa3d27e(void) {
    // 0xffa3d27e
    int32_t result; // 0xffa3d27e
    return result;
}

// Address range: 0xffa3d60a - 0xffa3d60b
int32_t function_ffa3d60a(void) {
    // 0xffa3d60a
    int32_t result; // 0xffa3d60a
    return result;
}

// Address range: 0xffa52f06 - 0xffa52f07
int32_t function_ffa52f06(void) {
    // 0xffa52f06
    int32_t result; // 0xffa52f06
    return result;
}

// Address range: 0xffc292e4 - 0xffc292e5
int32_t function_ffc292e4(void) {
    // 0xffc292e4
    int32_t result; // 0xffc292e4
    return result;
}

// Address range: 0xffc2fbec - 0xffc2fbed
int32_t function_ffc2fbec(void) {
    // 0xffc2fbec
    int32_t result; // 0xffc2fbec
    return result;
}

// Address range: 0xffc6db82 - 0xffc6db83
int32_t function_ffc6db82(void) {
    // 0xffc6db82
    int32_t result; // 0xffc6db82
    return result;
}

// Address range: 0xffe1590a - 0xffe1590b
int32_t function_ffe1590a(void) {
    // 0xffe1590a
    int32_t result; // 0xffe1590a
    return result;
}

// Address range: 0xffe2d01a - 0xffe2d01b
int32_t function_ffe2d01a(void) {
    // 0xffe2d01a
    int32_t result; // 0xffe2d01a
    return result;
}

// Address range: 0xffe43b16 - 0xffe43b17
int32_t function_ffe43b16(void) {
    // 0xffe43b16
    int32_t result; // 0xffe43b16
    return result;
}

// Address range: 0xfff6d026 - 0xfff6d027
int32_t function_fff6d026(void) {
    // 0xfff6d026
    int32_t result; // 0xfff6d026
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.4.3)
// Detected functions: 2365

