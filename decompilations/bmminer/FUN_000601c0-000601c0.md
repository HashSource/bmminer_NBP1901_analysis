```c
// Performs a multi-word division, where dividend and divisor are given as pairs of uints. The result
// is the quotient and the remainder is stored in the output parameter 'remainder' if provided.
// param_1 and param_2 are the low and high uints of the dividend, respectively.
// param_3 and param_4 are the low and high uints of the divisor, respectively.
// remainder is a pointer to an array where the remainder will be stored if not null.
// The function returns a 64-bit integer, which is the quotient of the division.
uint64_t DivideMultiword(
    uint dividendLow, uint dividendHigh,
    uint divisorLow, uint divisorHigh,
    uint *remainder) {

  uint quotientLow, quotientHigh, tempLow, tempHigh, subtractorLow, subtractorHigh;
  int leadingZerosDivisor, leadingZerosDividend, shiftCount;
  uint resultLow, resultHigh, compareLow, compareHigh;
  int bitPos;
  bool carry;

  // Check if divisor is less than or equal to the dividend.
  bool isDivisorLessOrEqual = divisorHigh <= dividendHigh;
  if (dividendHigh == divisorHigh) {
    isDivisorLessOrEqual = divisorLow <= dividendLow;
  }

  if (isDivisorLessOrEqual) {
    leadingZerosDivisor = CountLeadingZeros(divisorHigh);
    if (divisorHigh == 0) {
      leadingZerosDivisor = CountLeadingZeros(divisorLow) + 32;
    }

    leadingZerosDividend = CountLeadingZeros(dividendHigh);
    if (dividendHigh == 0) {
      leadingZerosDividend = CountLeadingZeros(dividendLow) + 32;
    }

    // Compute the difference in leading zeros to align divisor with dividend.
    shiftCount = leadingZerosDivisor - leadingZerosDividend;

    // Calculate the initial subtractor used to estimate the quotient.
    subtractorHigh = (divisorHigh << shiftCount) |
                     (divisorLow << (shiftCount - 32 & 0xff)) |
                     (divisorLow >> (32 - shiftCount & 0xff));
    subtractorLow = divisorLow << (shiftCount & 0xff);

    // Check if divisor is less than or equal to the dividend for subtraction.
    isDivisorLessOrEqual = (subtractorHigh < dividendHigh) ||
                           (subtractorHigh == dividendHigh && subtractorLow <= dividendLow);

    // Subtract divisor from dividend, and shift bits for the quotient.
    if (isDivisorLessOrEqual) {
      quotientLow = 1 << (shiftCount & 0xff);
      quotientHigh = 1 << (shiftCount - 32 & 0xff) | 1U >> (32 - shiftCount & 0xff);
      carry = dividendLow < subtractorLow;
      dividendLow -= subtractorLow;
      dividendHigh -= subtractorHigh + carry;
    }
    else {
      quotientLow = 0;
      quotientHigh = quotientLow;
    }

    // Continue subtracting divisor and counting quotient bits until all bits are processed.
    if (shiftCount != 0) {
      bitPos = shiftCount;
      do {

        // Shift subtractor to divide through bits.
        subtractorLow = (subtractorLow >> 1) | ((subtractorHigh & 1) << 31);
        subtractorHigh >>= 1;

        // Compare divisor and dividend to continue subtraction.
        isDivisorLessOrEqual = (subtractorHigh < dividendHigh) ||
                               (subtractorHigh == dividendHigh && subtractorLow <= dividendLow);

        if (isDivisorLessOrEqual) {
          carry = dividendLow < subtractorLow;
          tempLow = (dividendLow - subtractorLow) << 1 | 1;
          tempHigh = (dividendHigh - subtractorHigh - carry) << 1 |
                     (carry << 31) | (dividendLow >> 31);
          dividendLow = tempLow;
          dividendHigh = tempHigh;
          quotientLow |= 1 << (bitPos - 1);
        }
        else {
          dividendLow <<= 1;
          dividendHigh = (dividendHigh << 1) | (dividendLow >> 31);
        }
        bitPos--;

      // Continue until all bits have been processed.
      } while (bitPos != 0);
    }

    // Calculate final quotient and remainder.
    resultLow = quotientLow - (dividendLow << shiftCount);
    resultHigh = quotientHigh - ((dividendHigh << shiftCount) | (dividendLow >> (32 - shiftCount)));
    carry = quotientLow < (dividendLow << shiftCount);
    dividendLow = dividendLow >> shiftCount | (dividendHigh << (32 - shiftCount));
    dividendHigh >>= shiftCount;
  }
  else {
    resultLow = 0;
    resultHigh = resultLow;
  }

  // If remainder is not null, store remainder.
  if (remainder != NULL) {
    remainder[0] = dividendLow;
    remainder[1] = dividendHigh;
  }

  // Return quotient.
  return ((uint64_t)resultHigh << 32) | resultLow;
}
```