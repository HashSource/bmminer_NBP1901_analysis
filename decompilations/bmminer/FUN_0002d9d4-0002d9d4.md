```c
int dequeuePacket(int queueContext)
{
  int packetNodePtr;
  int nextPacketNodePtr;
  
  packetNodePtr = *(int *)(queueContext + 0xc);
  if (packetNodePtr == 0) {
    if (*(char *)(queueContext + 4) == '\0') {
      // Attempt to reset or populate the queue if it's currently empty and the flag is unset
      processQueueReset();
      packetNodePtr = *(int *)(queueContext + 0xc);
      if (packetNodePtr != 0) goto handleDequeue;
    }
    // Queue is still empty after processing, exit
    return 0;
  }
handleDequeue:
  // Grab the next packet node pointer from the current node
  nextPacketNodePtr = *(int *)(packetNodePtr + 8);
  // Update the queue context to point to the next node as the first node
  *(int *)(queueContext + 0xc) = nextPacketNodePtr;
  if (nextPacketNodePtr == 0) {
    // If there are no more packets in the queue and certain condition is met, reset a queue related field
    if (*(char *)(queueContext + 0x2c) != '\0') {
      *(undefined4 *)(queueContext + 0x10) = 0;
    }
  }
  else {
    // If there's a next packet, update its previous node pointer to NULL
    *(undefined4 *)(nextPacketNodePtr + 4) = 0;
  }
  // Now that the node has been dequeued, clear its next and previous pointers
  *(undefined4 *)(packetNodePtr + 8) = 0;
  *(undefined4 *)(packetNodePtr + 4) = 0;
  // Decrement the packet count in the queue context
  *(int *)(queueContext + 0x1c) = *(int *)(queueContext + 0x1c) - 1;
  
  // Return the dequeued packet node pointer
  return packetNodePtr;
}
```