```c
void RemoveAndReinsertNode(int **listHead, int **nodeToMove)
{
  int **prevNodeOfTarget;
  int *nextNodeOfTarget;
  int **currentNode;
  int **nextNode;
  
  // Find the previous node of the target node to move
  currentNode = (int **)(*nodeToMove)[1];
  nextNode = listHead + 1;
  prevNodeOfTarget = (int **)(*currentNode);
  
  // Update the previous node's forward link
  (*nodeToMove)[1] = (int *)prevNodeOfTarget;
  if (prevNodeOfTarget != nextNode) {
    prevNodeOfTarget[2] = (int *)nodeToMove;
  }
  
  // Update the previous node's backward link
  nextNodeOfTarget = (*nodeToMove)[2];
  if (nextNode != currentNode) {
    currentNode[2] = nextNodeOfTarget;
  }
  
  // If this is the first node, we need to update the list head
  if (nextNodeOfTarget == NULL) {
    *listHead = (int *)currentNode;
  }
  else if ((int **)(*nextNodeOfTarget) == nodeToMove) {
    *nextNodeOfTarget = (int)currentNode;
  }
  else {
    nextNodeOfTarget[1] = (int)currentNode;
  }
  
  // Finalize the position of the moved node
  *currentNode = (int *)nodeToMove;
  
  // If node to move was not the head, update backward link
  if (nextNode != nodeToMove) {
    (*nodeToMove)[2] = (int *)currentNode;
  }

  // Function finished, moved node is reinserted
  return;
}
```

Comments have been added to explain the purpose of each step in this function, which appears to operate on a doubly-linked list. The function `RemoveAndReinsertNode` removes a given node from its current position in the list and reinserts it after its previous node, thus potentially moving it to the front of the list (if the reinserted position is the first node). The function ensures that all forward and backward links are appropriately maintained.