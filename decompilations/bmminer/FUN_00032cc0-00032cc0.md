```c
/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

size_t build_packet_for_device(void **output_packet_buffer, int device_context, undefined4 nonce)
{
  undefined2 calculated_crc;
  void *temp_buffer;
  undefined4 temp_var_A;
  undefined4 *device_data_ptr;
  undefined4 temp_var_B;
  undefined4 *calc_ptr;
  size_t data_length;
  size_t malloc_size;
  void *malloc_pointer;
  int device_offset_base;
  int total_data_length;
  undefined4 extra_variable;
  int *device_data_array;
  int *current_data_ptr;
  bool overflow_flag;
  undefined4 error_message_array;
  undefined4 uStack_error_message_suffix;
  undefined2 message_header_data[2];
  int message_data_length;
  undefined message_header_type;
  byte msg_control_byte;
  undefined message_reserved;
  undefined4 custom_nonce;
  undefined auStack_nonce_buffer[4];
  undefined hashboard_data[32];
  undefined hashboard_temperature_data[4];
  undefined hashboard_status_data[4];
  undefined2 temperature_high;
  undefined2 temperature_low;
  undefined2 hash_rate_high;
  undefined2 hash_rate_low;
  undefined4 header_var_1;
  undefined4 header_var_2;
  undefined init_byte;
  undefined4 header_var_3;
  undefined4 header_var_4;
  undefined4 firmware_version_var_1;
  undefined4 firmware_version_var_2;
  undefined4 firmware_version_var_3;
  undefined4 firmware_version_var_4;
  undefined4 serial_number_part_1;
  undefined4 serial_number_part_2;
  undefined init_zero_byte;
  int *device_data_iter;

  // Device-related control parameters
  msg_control_byte = msg_control_byte & 0xfe | *(byte *)(device_context + 0x2a8) & 1 | 2;
  message_header_type = (undefined)DAT_00482a80;
  message_header_data[0] = 0x52; // fixed message start code
  error_message_array = 0;
  uStack_error_message_suffix = 0;
  message_reserved = 0xf;

  // Header-related variables
  if (DAT_00482a88 != '\0')
  {
    init_byte = *(undefined *)(device_context + 0x284);
    header_var_3 = *(undefined4 *)(device_context + 0x288);
    header_var_4 = *(undefined4 *)(device_context + 0x28c);
  }
  custom_nonce = nonce;

  // Copying static data from the device context to local structures
  fetch_data_from_context(auStack_nonce_buffer, device_context + 0x6f4);
  fetch_data_from_context(hashboard_data, device_context + 0x6b0, 0x20);
  fetch_data_from_context(hashboard_status_data, device_context + 0x700, 4);
  fetch_data_from_context(hashboard_temperature_data, device_context + 0x70c, 4);

  // Pointers and lengths for processing
  malloc_pointer = *(void **)(device_context + 0x620);
  data_length = *(size_t *)(device_context + 0x624);
  device_data_ptr = (undefined4 *)((int)malloc_pointer + *(int *)(device_context + 0x628));
  temperature_low = (undefined2)*(int *)(device_context + 0x628);
  temperature_high = (undefined2)data_length;
  hash_rate_high = (undefined2)*(size_t *)(device_context + 0x278);
  header_var_1 = *device_data_ptr;
  header_var_2 = device_data_ptr[1];
  error_message_array = *(undefined4 *)(device_context + 0x270);
  uStack_error_message_suffix = *(undefined4 *)(device_context + 0x274);
  memcpy(&header_var_1, &error_message_array, *(size_t *)(device_context + 0x278));

  // Calculating the overall data size for message construction
  device_offset_base = *(int *)(device_context + 0x6ac);
  hash_rate_low = (undefined2)device_offset_base;
  total_data_length = data_length + device_offset_base * 0x20; // 0x20 is likely the size of each data segment
  malloc_size = total_data_length + 0x62; // additional bytes for packet overhead
  temp_buffer = malloc(malloc_size);

  if (temp_buffer == (void *)0x0)
  {
    // Allocation failed, so log the error and abort operation
    populate_error_message(&error_message_array); // This would be a detailed implementation
    log_error_message(3, &error_message_array, 1); // Function for logging to the system
    shut_down_due_to_error(1); // Handling error shutdown procedure
    device_offset_base = *(int *)(device_context + 0x6ac);
    malloc_pointer = *(void **)(device_context + 0x620);
    data_length = *(size_t *)(device_context + 0x624);
  }

  // Building the main packet
  message_data_length = total_data_length + 0x5a;
  memset(temp_buffer, 0, malloc_size);
  memcpy(temp_buffer, message_header_data, 0x60);
  memcpy((void *)((int)temp_buffer + 0x60), malloc_pointer, data_length);

  if (0 < device_offset_base)
  {
    device_data_array = *(int **)(device_context + 0x2a4);
    calc_ptr = (undefined4 *)((int)temp_buffer + data_length + 0x60);
    current_data_ptr = device_data_array;

    do
    {
      device_data_iter = current_data_ptr + 1;
      calc_ptr = append_device_data_to_packet(calc_ptr, *current_data_ptr); // Appends each data chunk
      current_data_ptr = device_data_iter;
    } while (device_data_iter != device_data_array + device_offset_base);
  }

  // CRC calculation and appending it to the end of the packet
  calculated_crc = calculate_packet_crc(temp_buffer, total_data_length + 0x60U & 0xffff);
  *(undefined2 *)((int)temp_buffer + total_data_length + 0x60) = calculated_crc;

  // Global counters, possibly for packet sequencing or ID purposes
  overflow_flag = 0xfffffffe < DAT_00482a80;
  DAT_00482a80 = DAT_00482a80 + 1;
  DAT_00482a84 = DAT_00482a84 + (uint)overflow_flag;

  // Allocating the output buffer and copying the constructed packet to it
  malloc_pointer = malloc(malloc_size);
  *output_packet_buffer = malloc_pointer;
  memcpy(malloc_pointer, temp_buffer, malloc_size);

  // Free the temporary buffer
  free(temp_buffer);

  return malloc_size; // The size of the constructed packet
}
```