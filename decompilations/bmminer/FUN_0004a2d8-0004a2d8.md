```c
#define STATUS_OK 0
#define STATUS_ERROR_MUTEX_LOCK_FAILED -4
#define COMMAND_TYPE 0x703 // Assuming 0x703 is a specific command type

// Global variables have been renamed based on assumed functionality
pthread_mutex_t globalI2cMutex = DAT_005051a8;
void **globalI2cDeviceHandleList = DAT_005051a4;
pthread_mutex_t *alternateMutexLock = DAT_0004a3e8;

// Function pointer types for I2C operations
typedef int (*I2cOperation)(void);
typedef void *(*I2cGetDevice)(void);
typedef int (*I2cSendCommand)(void **, void *, int);

// Send an I2C command to the device with the matching ID
int SendI2cCommandToDevice(int deviceId, int commandType, int commandValue) {
  int mutexLockResult;
  void **deviceHandle;
  I2cOperation findNextDevice;
  I2cGetDevice getCommandData;
  I2cSendCommand sendCommand;
  int result;
  int commandData[2]; // Assuming these are parts of the command to be sent
  
  // Try to gain exclusive access to the I2C devices
  mutexLockResult = pthread_mutex_lock(&globalI2cMutex);
  if (mutexLockResult == 0) {
    // Get the first I2C device handle from the global list
    deviceHandle = (void **)globalI2cDeviceHandleList;
    findNextDevice = (I2cOperation)deviceHandle[0];
    result = findNextDevice();
    
    while (result != 0) {
      // Check if current device matches the target ID
      if (*(*(int ***)(deviceHandle[5] + 0x10)) == deviceId) {
        getCommandData = (I2cGetDevice)deviceHandle[2];
        sendCommand = (I2cSendCommand)deviceHandle[1];
        
        // If the command type matches the predefined command,
        // prepare the command data to be sent
        if (commandType == COMMAND_TYPE) {
          commandData[0] = getCommandData(); // Get existing command from device
          commandData[1] = commandValue;    // Update command with the new value
          // Send the updated command to the I2C device
          sendCommand(deviceHandle, &commandData, sizeof(commandData));
          free(getCommandData); // Free the memory allocated for the command data
        }
        break; // Exit the loop after handling the device
      }
      // Move to the next I2C device link in the list
      result = findNextDevice(deviceHandle);
    }

    free(deviceHandle); // Free the memory allocated for the device handle
    pthread_mutex_unlock(&alternateMutexLock); // Unlock the alternative mutex
    return STATUS_OK; // Return success status
  } else {
    // Handle the error case where mutex lock failed
    // Note: The error message is assuming logs are output elsewhere
    LogErrorMessage("Failed to lock I2C mutex");
    return STATUS_ERROR_MUTEX_LOCK_FAILED; // Return mutex lock error status
  }
}
```