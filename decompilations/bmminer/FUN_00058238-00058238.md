```c
void removeFromHashtable(int **hashtablePtr, int key)
{
  int *hashtable;
  undefined4 hashValue;
  int hashIndex;
  int hashOffset;
  int hashOffsetAfter;
  undefined4 *entryPtr;
  int nextEntry;
  
  hashtable = *hashtablePtr;
  if (key == 0 || hashtable == (int *)0x0) {
    logError(2, "src/zc_hashtable.c", 0xf0, 
             "The hashtable [%p] or the key [%p] is NULL, just do nothing",
             hashtable, key);
  }
  else {
    // Compute the hash value for the given key
    hashValue = ((getHashForKeyFunction)hashtable[3])(key);
    
    // Convert the hash value into an index within the hashtable's range
    hashIndex = calculateHashIndex(hashValue, hashtable[2]);
    
    // Retrieve a pointer to the first entry at the computed hashtable index
    entryPtr = *(undefined4 **)(hashtable[1] + hashIndex * 4);
    
    // Iterate through the linked list of entries at this index
    while (true) {
      if (entryPtr == (undefined4 *)0x0) {
        logError(2, "src/zc_hashtable.c", 0xfb, 
                 "Entry [%p] not found in hashtable", 0);
        return;
      }
      // Check if this entry matches the given key
      hashOffset = ((compareKeysFunction)hashtable[4])(key, entryPtr[1]);
      if (hashOffset != 0) break;
      entryPtr = (undefined4 *)entryPtr[4]; // Move to the next entry
    }
    
    // If there's a destructor for key, use it to free key resources
    if ((destructorForKeyFunction)hashtable[5] != (destructorForKeyFunction)0x0) {
      ((destructorForKeyFunction)hashtable[5])(entryPtr[1]);
    }
    
    // If there's a destructor for value, use it to free value resources
    if ((destructorForValueFunction)hashtable[6] != (destructorForValueFunction)0x0) {
      ((destructorForValueFunction)hashtable[6])(entryPtr[2]);
    }
    
    // Connect neighboring entries to bypass the entry being removed
    nextEntry = entryPtr[4];
    hashOffsetAfter = entryPtr[3];
    if (nextEntry != 0) {
      *(int *)(nextEntry + 0xc) = hashOffsetAfter;
      hashOffsetAfter = entryPtr[3];
    }
    if (hashOffsetAfter == 0) {
      // This is the first entry in the list, adjust the head pointer
      calculateHashIndex(*entryPtr, hashtable[2]);
      *(int *)(hashtable[1] + hashIndex * 4) = nextEntry;
    }
    else {
      // This is not the first entry, adjust the previous entry's next pointer
      *(int *)(hashOffsetAfter + 0x10) = nextEntry;
    }
    
    // Free the memory allocated for this entry
    free(entryPtr);
    
    // Decrement the count of entries in the hashtable
    *hashtable = *hashtable - 1;
  }
  return;
}
```