```c
/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void ProcessNonceData(byte *nonceData)
{
  byte statusByte;
  undefined4 calculatedValue;
  uint nonceValue;
  uint extraNonce2Length;
  int minerChainIndex;
  int minerChipIndex;
  int minerCoreIndex;
  int bufIndex;
  uint extraNonce2;
  int errorCountForChain;
  undefined8 hashResult;
  undefined4 nonceTimespaceValue;
  undefined4 localBuffer[514]; // Local buffer to store error messages

  if (_isProcessingNonceDataEnabled == '\0') {
    return;
  }
  statusByte = *nonceData;
  if ((statusByte & 0x80) == 0) {
    // Nonce is invalid
    if (3 < logLevel) {
      localBuffer[0] = errorNonceInvalid[0];
      localBuffer[1] = errorNonceInvalid[1];
      localBuffer[2] = errorNonceInvalid[2];
      localBuffer[3] = errorNonceInvalid[3];
      LogMessage(3, localBuffer, 0);
      return;
    }
  }
  else {
    if ((statusByte & 0x40) != 0) {
      // Nonce has CRC error
      if (3 < logLevel) {
        localBuffer[0] = errorNonceCrc[0];
        localBuffer[1] = errorNonceCrc[1];
        localBuffer[2] = errorNonceCrc[2];
        localBuffer[3] = errorNonceCrc[3];
        localBuffer[4] = errorNonceCrc[4];
        // The original code here is strange, possibly a bug:
        // localBuffer[5] = CONCAT31(localBuffer[5]._1_3_, (char)ramValue);
        LogMessage(3, localBuffer, 0);
      }
      crcErrorCount++;
      return;
    }
    
    // Lock the mutex for thread-safe access to global variables
    pthread_mutex_lock((pthread_mutex_t *)&globalMutex);

    nonceValue = globalNonceCounter;
    if (globalNoncesCount < 0x1ff) {
      // Get the nonce related information
      extraNonce2 = *(ushort *)(nonceData + 2) & 0x7fff;
      minerChainIndex = globalNonceCounter * 0x3c;
      *(uint *)(nonceArrayStart + minerChainIndex) = extraNonce2;
      *(undefined4 *)(nonceArrayStart2 + minerChainIndex) = *(undefined4 *)(nonceData + 4);
      *(uint *)(nonceData + minerChainIndex) = *nonceData & 0xf;
      calculatedValue = CalculateSomething(extraNonce2);
      extraNonce2Length = logLevel;
      *(undefined4 *)(nonceArrayStart3 + minerChainIndex) = calculatedValue;
      
      if (4 < extraNonce2Length) {
        snprintf((char *)&localBuffer, 0x800, "blk ver = 0x%x\n", (uint)*(ushort *)(nonceData + 9));
        LogMessage(4, localBuffer, statusByte & 0x40);
      }
      
      // More calculations and storage into the miner nonce data structures
      minerChainIndex = nonceValue * 0x3c;
      calculatedValue = AnotherCalculation(extraNonce2);
      *(undefined4 *)(nonceArrayStart4 + minerChainIndex) = calculatedValue;
      hashResult = ComputeHash(extraNonce2);
      *(undefined8 *)(nonceArrayStart5 + minerChainIndex) = hashResult;
      CopyDataFunction(extraNonce2, nonceArrayStart6 + minerChainIndex, 0x20);
      
      // Check for buffer errors and log if verbosity level is high enough
      minerChipIndex = *(int *)(nonceArrayStart2 + minerChainIndex);
      minerCoreIndex = *(int *)(nonceArrayStart + minerChainIndex);
      nonceValue = CheckBuffer(minerChipIndex);
      nonceTimespaceValue = GetNonceTimespace();
      extraNonce2Length = CheckBufferErrorCode(minerChipIndex, nonceTimespaceValue);
      
      if (((minerCoreIndex < 4) && (extraNonce2 = GetSomeLimit(), extraNonce2Length < extraNonce2)) && 
          (extraNonce2 = GetSomeOtherLimit(), minerChipIndex != 0 && nonceValue < extraNonce2)) {
        bufIndex = extraNonce2Length + minerCoreIndex * 0x100;
        errorCountForChain = bufIndex + 4;
        errorCountForChain = *(int *)(errorCountStart + errorCountForChain * 4);
        minerCoreIndex = nonceValue + bufIndex * 0x400 + 0x404;
        bufIndex = *(int *)(errorCountStart + minerCoreIndex * 4);
        *(int *)(errorCountStart + minerCoreIndex * 4) = bufIndex + 1;
        *(int *)(errorCountStart + errorCountForChain * 4) = errorCountForChain + 1;
      }
      else if (4 < logLevel) {
        snprintf((char *)&localBuffer, 0x800, "buf [%x] is error!\n", minerChipIndex);
        LogMessage(4, localBuffer, 0);
        if (4 < logLevel) {
          snprintf((char *)&localBuffer, 0x800, "chain = %d, chip = %d, core = %d\n", minerCoreIndex, extraNonce2Length, nonceValue);
          LogMessage(4, localBuffer, 0);
        }
      }
      
      globalNonceCounter++;
      nonceValue = globalNonceCounter;
      if (0x1fe < globalNonceCounter) {
        nonceValue = 0;
      }
      globalNoncesCount++;
      if (0x1fe < globalNonceCounter) {
        globalNonceCounter = nonceValue;
      }
      globalBufferFullFlag = 0;
    }
    else if (globalBufferFullFlag == 0) {
      // Buffer is full, log message
      if (3 < logLevel) {
        memcpy(localBuffer, bufferFullMessage, sizeof(bufferFullMessage));
        LogMessage(3, localBuffer, 0);
      }
      globalBufferFullFlag = 1;
    }
    
    // Unlock the mutex after accessing global variables
    pthread_mutex_unlock((pthread_mutex_t *)&globalMutex);
  }
  return;
}
```