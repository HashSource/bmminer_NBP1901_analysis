```c
uint GetMinimumFrequency(int chainIndex, int frequencyArrayOffset)
{
  int minerIndex;
  uint *frequencyPtr;
  int numOfMiners;
  int minerCounter;
  uint minFrequency;
  char logBuffer[2048];
  
  minFrequency = 0xffffff; // Initialize with a high value, assuming frequencies are lower
  minerIndex = 0;
  do {
    // Check if this miner (minerIndex) is available
    int minerAvailable = CheckMinerAvailability(minerIndex);
    // If the miner is available and either we're looking at all chains or the specific chain
    if ((minerAvailable != 0) && (chainIndex == 0xff || chainIndex == minerIndex)) {
      minerCounter = 0;
      numOfMiners = GetMinerCount();
      if (numOfMiners != 0) {
        // Calculate the pointer to the frequency array for this miner
        frequencyPtr = (uint *)(frequencyArrayOffset + -4 + minerIndex * 0x400);
        do {
          // Move to the next frequency in the array
          frequencyPtr = frequencyPtr + 1;
          minerCounter = minerCounter + 1;
          // If the current frequency is less than the current minFrequency, update minFrequency
          if (*frequencyPtr <= minFrequency) {
            minFrequency = *frequencyPtr;
          }
        // Continue until we've checked all miners
        } while (numOfMiners != minerCounter);
      }
    }
    // Move to the next miner
    minerIndex = minerIndex + 1;
  // Loop until we've checked all possible miners (assumed 4 miners total here)
  } while (minerIndex != 4);
  
  // If verbose logging is enabled, log the information
  if (4 < VerboseLoggingLevel) {
    snprintf(logBuffer, 0x800, "chain = %d, freq_min = %d\n", chainIndex, minFrequency);
    LogMessage(4, logBuffer, 0);
  }
  return minFrequency;
}
```