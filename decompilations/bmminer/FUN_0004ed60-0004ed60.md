```c
#include "atomic_helpers.h"

// Function: RemoveTask
// This function is used to remove a task from an array of task pointers given its index.
//
// Parameters:
//   taskArrayPtr - Pointer to the task array object
//   taskIndex - Index of the task to remove
//
// Return:
//   On success, returns 0.
//   If taskArrayPtr is NULL, the array is uninitialized, or taskIndex is out of bounds, returns -1.
//
// Note:
//   This function assumes a specific structure of the task array object where:
//   - The first integer at *taskArrayPtr indicates if the array is initialized (has to be 1)
//   - The fourth integer at taskArrayPtr[3] stores the current count of tasks in the array
//   - The task pointers are stored starting from the address at taskArrayPtr[4]

undefined4 RemoveTask(int *taskArrayPtr, uint taskIndex) {
  int *taskCounterPtr;
  int taskToRemove;
  bool taskIsExclusive;
  uint totalTasks;
  uint newTotalTasks;

  // Check if the task array pointer is valid, if the array is initialized, and the index is within range
  if ((taskArrayPtr != NULL) && (*taskArrayPtr == 1)) {
    totalTasks = taskArrayPtr[3]; // Total number of tasks
    if (taskIndex < totalTasks) {
      taskToRemove = *(int *)(taskArrayPtr[4] + taskIndex * 4); // Pointer to the task to remove
      if ((taskToRemove != 0) && (*(int *)(taskToRemove + 4) != -1)) { // Validate the task exists and is active
        taskCounterPtr = (int *)(taskToRemove + 4);
        DataMemoryBarrier(0xb); // Data memory barrier used for synchronization (using a specific barrier type, which should be clarified with proper constants or documentation)

        // Atomically decrement the reference count of the task
        do {
          taskToRemove = *taskCounterPtr;
          taskIsExclusive = (bool)hasExclusiveAccess(taskCounterPtr);
        } while (!taskIsExclusive);
        *taskCounterPtr = taskToRemove - 1;

        // If the reference count is now zero, perform clean-up
        if (taskToRemove - 1 == 0) {
          CleanUpTask(); // Needs to be renamed to the actual function name that performs the clean-up
        }

        // Get new total tasks after potential clean-up
        totalTasks = taskArrayPtr[3];
      }

      // Compute new total after removal
      newTotalTasks = totalTasks - 1;

      // Shift the tasks in the array to fill the gap
      if (taskIndex < newTotalTasks) {
        memmove(
          (void *)(taskArrayPtr[4] + taskIndex * 4),
          (void *)(taskArrayPtr[4] + taskIndex * 4 + 4),
          (newTotalTasks - taskIndex) * 4
        );
        newTotalTasks = taskArrayPtr[3] - 1;
      }

      // Update the total number of tasks in the array
      taskArrayPtr[3] = newTotalTasks;
      return 0;
    }
  }
  return 0xffffffff; // Return error if taskArrayPtr is NULL or not initialized, or taskIndex is out of bounds
}
```