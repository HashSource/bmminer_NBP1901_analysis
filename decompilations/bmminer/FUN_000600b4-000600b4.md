```c
ulonglong ConvertDoublePrecision(uint higherBits, uint lowerBits)
{
  byte tempByte;
  uint tempUInt1;
  uint tempUInt2;
  uint shiftedValue;
  int exponent;
  uint fractionMSB;
  bool condition1;
  bool condition2;
  bool condition3;
  
  // Check for zero input, which would result in zero output for double precision
  if ((higherBits | lowerBits) == 0) {
    return CONCAT44(lowerBits, higherBits);
  }

  exponent = 0x432; // Set the default exponent part value for normalization
  fractionMSB = lowerBits >> 0x16;

  if (fractionMSB != 0) {
    exponent = 3;
    if (lowerBits >> 0x19 != 0) {
      exponent = 6;
    }
    if (lowerBits >> 0x1c != 0) {
      exponent += 3;
    }
    shiftedValue = exponent - ((int)lowerBits >> 0x1f);
    fractionMSB = higherBits << (32 - shiftedValue & 0xff);
    higherBits = (higherBits >> (shiftedValue & 0xff)) | (lowerBits << (32 - shiftedValue & 0xff));
    lowerBits = lowerBits >> (shiftedValue & 0xff);
    exponent += 0x432;
  }

  // Normalize if the high part of the fraction is too large
  if (0xfffff < lowerBits) {
    if (0x1fffff < lowerBits) {
      shiftedValue = lowerBits & 1;
      lowerBits = lowerBits >> 1;
      tempByte = (byte)higherBits;
      higherBits = (higherBits >> 1) | (shiftedValue << 31);
      fractionMSB = (fractionMSB >> 1) | ((tempByte & 1) << 31);
      exponent++;
      if (0xffbfffff < exponent * 0x200000) {
        return 0x7ff0000000000000; // Return double precision infinity
      }
    }
    // Go to common path after normalization
    goto NormalizeFraction;
  }

  // Continue normalization if needed
  condition1 = (fractionMSB & 0x80000000) != 0;
  fractionMSB <<= 1;
  shiftedValue = higherBits << 1;
  condition2 = __carry(higherBits, higherBits);
  higherBits = (higherBits << 1) + condition1;
  lowerBits = (lowerBits << 1) + (condition2 || __carry(shiftedValue, condition1));
  exponent--;

  if ((lowerBits & 0x100000) != 0) goto NormalizeFraction;
  tempUInt1 = higherBits;
  tempUInt2 = lowerBits;
  if (lowerBits == 0) {
    tempUInt1 = 0;
    tempUInt2 = higherBits;
  }
  // Count leading zeros for normalization
  int leadingZeros = __builtin_clz(tempUInt2);
  if (lowerBits == 0) {
    leadingZeros += 32;
  }
  uint leadingZerosCount = leadingZeros - 11;
  condition3 = leadingZerosCount < 32;
  int shiftAmount = leadingZeros - 43;
  condition2 = shiftAmount < 0;
  condition1 = shiftAmount == 0;

  if (condition3) {
    // Normalize using the number of leading zeros
    if (!condition1 && condition2 == condition3) {
      higherBits = tempUInt2 << (leadingZerosCount & 0xff);
      lowerBits = tempUInt2 >> (12 - leadingZerosCount & 0xff);
      goto AdjustedExponent;
    }
  }
  if (condition1 || condition2 != condition3) {
    fractionMSB = 32 - shiftAmount;
  }
  lowerBits = tempUInt2 << (shiftAmount & 0xff);
  if (condition1 || condition2 != condition3) {
    lowerBits |= tempUInt1 >> (fractionMSB & 0xff);
  }
  if (condition1 || condition2 != condition3) {
    higherBits = tempUInt1 << (shiftAmount & 0xff);
  }

AdjustedExponent:
  // Adjust the double precision value based on the exponent
  if (leadingZerosCount <= exponent) {
    return CONCAT44(lowerBits + (exponent - leadingZerosCount) * 0x100000, higherBits);
  }
  int adjustedExponent = ~(exponent - leadingZerosCount);
  if (adjustedExponent > 31) {
    // Shift for small exponent values
    return (ulonglong)(lowerBits >> (adjustedExponent - 31 & 0xff));
  }
  exponent = adjustedExponent - 19;
  if (exponent == 0 || exponent < 0 != __borrow(adjustedExponent - 31, 12)) {
    adjustedExponent++;
    return CONCAT44(lowerBits >> (adjustedExponent & 0xff), higherBits >> (adjustedExponent & 0xff) | lowerBits << (32 - adjustedExponent & 0xff));
  }
  return (ulonglong)(higherBits >> (32 - (12 - exponent) & 0xff) | lowerBits << (12 - exponent & 0xff));

NormalizeFraction:
  condition2 = 0x7fffffff < fractionMSB;
  if (fractionMSB == 0x80000000) {
    condition2 = (higherBits & 1) != 0;
  }
  return CONCAT44(lowerBits + exponent * 0x100000 + __carry(higherBits, condition2), higherBits + condition2);
}
```

Please note that I replaced `CARRY4` with `__carry` and `SBORROW4` with `__borrow` which are supposed to represent pseudo functions or macros to perform the carry and borrow operations respectively because ARM assembly typically includes instructions that set flags for these conditions. In C, there are no direct equivalents to these ARM instructions, and depending on the context, compiler intrinsics or custom macros might be used. If you have specific functions or macros used in your environment to handle these, make sure to replace them accordingly. Additionally, the `LZCOUNT` function is assumed to be a leading zero count which is mimicked by `__builtin_clz` in GCC. If a different implementation is needed, please use the appropriate function for your compiler or environment.