```c
#include <pthread.h> // Include pthread library for pthread_rwlock_t

// Forward declarations of other functions that are being called
extern void logErrorMessage(int level, const char *file, int line, const char *message, ...);
extern int addNewLogRecord(const char *ruleName, const char *outputRecord);
extern int addRecordToHashTable(int hashTable, int recordKey, int recordValue);
extern void deleteLogRecord(int record);
extern int getRecordCount();

// Global variables
extern pthread_rwlock_t logLock;   // Read-write lock for log access
extern int *logHashTable;          // Pointer to the hash table for logs
extern int logInitialized;         // Flag to indicate if logging is initialized
extern int logIndex;               // An index or key related to logging

// Helper function to write a new log according to rule name and output record
int writeLog(const char *ruleName, const char *outputRecord) {
  int writeLockResult;
  int logRecord;
  int *logIndexList;
  int returnCode;

  // Check for NULL ruleName or outputRecord
  if (ruleName == NULL) {
    logErrorMessage(2, "src/zlog.c", 0x3d2, "ruleName is null or 0");
    returnCode = -1;
  }
  else if (outputRecord == NULL) {
    logErrorMessage(2, "src/zlog.c", 0x3d3, "outputRecord is null or 0");
    returnCode = -1;
  }
  else {
    // Attempt to acquire the write lock
    writeLockResult = pthread_rwlock_wrlock(&logLock);
    if (writeLockResult == 0) {
      // Check if the log has been initialized
      if (logInitialized == 0) {
        logErrorMessage(2, "src/zlog.c", 0x3dc, "never call zlog_init() or dzlog_init() before");
        returnCode = 0;
      }
      else {
        // Try to create a new log record
        logRecord = addNewLogRecord(ruleName, outputRecord);
        if (logRecord == 0) {
          logErrorMessage(2, "src/zlog.c", 0x3e3, "addNewLogRecord failed");
          returnCode = -1;
        }
        else {
          // Add the record to the hash table
          returnCode = addRecordToHashTable(logHashTable, logIndex, logRecord);
          if (returnCode == 0) {
            // Retrieve the list of log indexes
            logIndexList = logHashTable; 
            // Iterate over the list and update all indexes accordingly
            if (0 < getRecordCount()) {
              for (int i = 0; i < getRecordCount(); i++) {
                logErrorMessage(*(logIndexList + i), logHashTable);
                // In the original decompiled binary, they fetched logHashTable again, replicated here
                logIndexList = logHashTable; 
              }
            }
          }
          else {
            // If adding to the hash table failed, delete the record and log an error
            deleteLogRecord(logRecord);
            logErrorMessage(2, "src/zlog.c", 0x3ea, "addRecordToHashTable failed");
          }
        }
      }
      // Release the write lock
      writeLockResult = pthread_rwlock_unlock(&logLock);
      if (writeLockResult != 0) {
        returnCode = -1;
        logErrorMessage(2, "src/zlog.c", 0x3f5, "pthread_rwlock_unlock failed, code=[%d]", writeLockResult);
      }
    }
    else {
      returnCode = -1;
      logErrorMessage(2, "src/zlog.c", 0x3d7, "pthread_rwlock_wrlock failed, code[%d]", writeLockResult);
    }
  }
  return returnCode;
}
```

I have replaced the names of variables and functions to make them more descriptive and meaningful. The overall structure of the code remains the same. Some data types have also been inferred, like the `pthread_rwlock_t` for `logLock`. Please note that in a real-world scenario, the actual variable and function types would need to match their definitions elsewhere in your codebase.