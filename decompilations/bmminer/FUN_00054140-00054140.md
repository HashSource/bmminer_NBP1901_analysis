```c
/* WARNING: Restarted to delay deadcode elimination for space: ram */

#include <pthread.h>
#include "zlog.h"

void logEvent(int category, undefined4 file, undefined4 line, undefined4 function,
              undefined4 message, undefined4 hexdump, uint hexdumpLen, undefined4 mdc,
              undefined4 properties)
{
  int *threadCache;
  int result;
  uint realHexdumpLen;
  uint byteOffset;
  
  realHexdumpLen = hexdumpLen + 7;
  if (-1 < (int)hexdumpLen) {
    realHexdumpLen = hexdumpLen;
  }
  byteOffset = hexdumpLen & 7;
  if ((int)hexdumpLen < 1) {
    byteOffset = -(-hexdumpLen & 7);
  }
  // Check if the bit for this event in the category is set, if not then return early
  if (((int)(uint)*(byte *)(category + ((int)realHexdumpLen >> 3) + 0x408) >> (7 - byteOffset & 0xff) & 1U) == 0) {
    return;
  }
  pthread_rwlock_rdlock((pthread_rwlock_t *)&lockVariable);
  if (uninitializedFlag == 0) {
    logInternalError(2,"src/zlog.c",0x287,"never call zlog_init() or dzlog_init() before");
    goto cleanup_and_exit;
  }
  threadCache = (int *)pthread_getspecific(threadKey);
  if (threadCache == (int *)0x0) {
    threadCache = (int *)createThreadCache(memoryAllocationParam1,*(undefined4 *)(globalParams + 0x41c),
                                           *(undefined4 *)(globalParams + 0x420),
                                           *(undefined4 *)(globalParams + 0x244c));
    if (threadCache == (int *)0x0) {
      logInternalError(2,"src/zlog.c",0x28b,"zlog_thread_new fail");
      goto cleanup_and_exit;
    }
    result = pthread_setspecific(threadKey, threadCache);
    if (result != 0) {
      releaseThreadCache(threadCache);
      logInternalError(2,"src/zlog.c",0x28b,"pthread_setspecific fail, rd[%d]", result);
      goto cleanup_and_exit;
    }
  }
  if (*threadCache != memoryAllocationParam1) {
    result = resizeThreadCache(threadCache,*(undefined4 *)(globalParams + 0x41c),
                               *(undefined4 *)(globalParams + 0x420));
    if ((result != 0) ||
       (result = resizeThreadCacheBuffer(threadCache,*(undefined4 *)(globalParams + 0x244c)), result != 0)) {
      logInternalError(2,"src/zlog.c",0x28b,"zlog_thread_resize_msg_buf fail, rd[%d]", result);
      goto cleanup_and_exit;
    }
    *threadCache = memoryAllocationParam1;
  }
  formatLogEntry(threadCache[2],category,*(undefined4 *)(category + 0x404),file,line,function,message,
               hexdump,hexdumpLen,mdc,properties);
  result = pushLogToOutput(category, threadCache);
  if (result == 0) {
    if ((*(uint *)(globalParams + 0x243c) != 0) &&
       (reloadCount = reloadCount + 1, *(uint *)(globalParams + 0x243c) < reloadCount)) {
      pthread_rwlock_unlock(mutexLock);
      result = reloadConfiguration(0xffffffff);
      if (result == 0) {
        return;
      }
      logInternalError(2,"src/zlog.c",0x2a4,
                       "reach reload-conf-period but zlog_reload fail, zlog-chk-conf [file] see detail")
      ;
      return;
    }
  }
  else {
    logInternalError(2,"src/zlog.c",0x293,"zlog_output fail, srcfile[%s], srcline[%ld]",file,line)
    ;
  }
cleanup_and_exit:
  pthread_rwlock_unlock(mutexLock);
  return;
}
```