```c
#include <pthread.h> // Required for pthread mutex and rwlock functions
#include <stdio.h>   // Required for snprintf
#include <stdlib.h>  // Required for free()

// Function prototype declarations (assuming these functions exist and are used for logging and exiting)
void logError(int level, const char* message, int errorCode);
void applicationExit(int statusCode);

// Standard unsigned 32-bit type definition
typedef unsigned int uint32_t;

// Function that releases allocated memory for a list
uint32_t releaseListMemory(uint32_t *listInfo, uint32_t unknownParam2, uint32_t unknownParam3, uint32_t unknownParam4) {
  int index;
  int position;
  pthread_mutex_t *listMutex;
  char logMessageBuffer[2052]; // Buffer for log message
  
  // If the 'initialized' flag (at offset 4 bytes) is non-zero, do not proceed and log an error
  if (*(char *)(listInfo + 1) != '\0') {
    snprintf(logMessageBuffer, 0x800,
             "List %s cannot %s() a store - from %s %s() line %d in %s %s():%d",
             *listInfo, "unknown_function", unknownParam2, unknownParam3,
             unknownParam4, "klist.c", "unknown_function", 400);
    logError(3, logMessageBuffer, 1);
    applicationExit(1);
  }

  // Check if there are elements in the first array and free them
  if (0 < (int)listInfo[12]) {
    index = 0;
    do {
      position = index * 4;
      index++;
      free(*(void **)(listInfo[13] + position));
    } while (index < (int)listInfo[12]);
  }
  
  // Free the first array
  free((void *)listInfo[13]);
  
  // Check if there are elements in the second array and free them
  if (0 < (int)listInfo[14]) {
    index = 0;
    do {
      position = index * 4;
      index++;
      free(*(void **)(listInfo[15] + position));
    } while (index < (int)listInfo[14]);
  }
  
  // Free the second array
  free((void *)listInfo[15]);
  
  // Destroying the locks associated with the list
  listMutex = (pthread_mutex_t *)listInfo[2];
  pthread_rwlock_destroy((pthread_rwlock_t *)(listMutex + 1)); // Destroy read/write lock
  pthread_mutex_destroy(listMutex); // Destroy mutex lock
  
  // Free lock memory
  free((void *)listInfo[2]);

  // Finally, free the memory allocated for the list itself
  free(listInfo);
  
  return 0;
}
```