```c
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>

// Writes a log message to the log file associated with the log context
int WriteLogMessage(int log_context, int msg_buffer_context) {
  int file_descriptor;
  ssize_t write_result;
  int *error_number_ptr;
  uint sync_counter;
  void *message_buffer;
  char *log_filename;
  int return_code;
  struct stat file_info; // local variables to hold stat information

  // This might be a function that sets up the message formatting
  int format_result = SetupMessageFormatting(*(int *)(log_context + 0x1878));
  if (format_result != 0) {
    // Log an error message if formatting fails
    LogError(2, "src/rule.c", 0x54, "zlog_format_gen_msg fail");
    return -1;
  }

  // Get the filename for the log file from the log context
  log_filename = (char *)(log_context + 0x1030);
  // Get the file status info and store it in file_info
  int stat_result = stat(log_filename, &file_info);
  if (stat_result == 0) {
    // Retrieve the stored file descriptor for the log file from the log context
    file_descriptor = *(int *)(log_context + 0x1438);

    // Check whether the stat information matches the stored values in the log context, if so, we continue writing to the file
    if (file_info.st_mtime == *(time_t *)(log_context + 0x144c)
        && file_info.st_ctime == *(time_t *)(log_context + 0x1448)
        && file_info.st_ino == *(ino_t *)(log_context + 0x1444)
        && file_info.st_dev == *(dev_t *)(log_context + 0x1440)) {
      goto proceed_with_write;
    }

    // If the stat information does not match or if the file was not opened before, try opening/reopening the file
    close(file_descriptor);
    file_descriptor = open(log_filename, *(uint *)(log_context + 0x102c) | O_CREAT | O_RDWR | O_APPEND, *(mode_t *)(log_context + 0x1028));
    *(int *)(log_context + 0x1438) = file_descriptor;

    if (file_descriptor < 0) {
      error_number_ptr = __errno_location();
      goto log_open_error;
    }
  } else {
    // If stat failed, check the errno
    error_number_ptr = __errno_location();
    if (*error_number_ptr != ENOENT) { // ENOENT means no such file or directory
      LogError(2, "src/rule.c", 0x5b, "stat fail on [%s], errno[%d]", log_filename, *error_number_ptr);
      return -1;
    }

    // If the file does not exist, open the file
    close(*(int *)(log_context + 0x1438));
    file_descriptor = open(log_filename, *(uint *)(log_context + 0x102c) | O_CREAT | O_RDWR | O_APPEND, *(mode_t *)(log_context + 0x1028));
    *(int *)(log_context + 0x1438) = file_descriptor;

    if (file_descriptor < 0) {
log_open_error:
      LogError(2, "src/rule.c", 0x6b, "open file [%s] fail, errno[%d]", log_filename, *error_number_ptr);
      return -1;
    }

    // Perform a stat operation again to fetch fresh file info
    stat_result = stat(log_filename, &file_info);
    if (stat_result != 0) {
      LogError(2, "src/rule.c", 0x72, "stat fail on new file [%s], errno[%d]", log_filename, *error_number_ptr);
      return -1;
    }

    // Use the fresh descriptor from opening the new file
    file_descriptor = *(int *)(log_context + 0x1438);
  }

  // Update the log context with the fetched file stat info
  *(dev_t *)(log_context + 0x1440) = file_info.st_dev;
  *(ino_t *)(log_context + 0x1444) = file_info.st_ino;
  *(time_t *)(log_context + 0x1448) = file_info.st_ctime;
  *(time_t *)(log_context + 0x144c) = file_info.st_mtime;

proceed_with_write:
  // Proceed to write the log message to the file
  message_buffer = **(void ***)(msg_buffer_context + 0x1c);
  write_result = write(file_descriptor, message_buffer, (size_t)(*(void ***)(msg_buffer_context + 0x1c))[1] - (size_t)message_buffer);

  if (write_result < 0) {
    // If write operation failed, log the error
    error_number_ptr = __errno_location();
    LogError(2, "src/rule.c", 0x7d, "write fail, errno[%d]", *error_number_ptr);
    return_code = -1;
  } else {
    return_code = 0;
    // Implement write counting and possibly syncing to disk after a certain number of writes
    if (*(uint *)(log_context + 0x1868) != 0) {
      sync_counter = *(int *)(log_context + 0x186c) + 1;
      if (sync_counter < *(uint *)(log_context + 0x1868)) {
        *(uint *)(log_context + 0x186c) = sync_counter;
      } else {
        // Reset the counter and perform an fsync to ensure the logs are flushed to disk
        *(uint *)(log_context + 0x186c) = 0;
        int fsync_result = fsync(file_descriptor);
        if (fsync_result != 0) {
          error_number_ptr = __errno_location();
          LogError(2, "src/rule.c", 0x85, "fsync fail on file descriptor [%d], errno[%d]", file_descriptor, *error_number_ptr);
        }
      }
    }
  }
  
  return return_code;
}
```