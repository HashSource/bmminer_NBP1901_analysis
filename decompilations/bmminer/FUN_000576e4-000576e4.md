```c
byte * parseFormatLine(char *line, undefined4 maxPatternSize)
{
  byte currentChar;
  byte *buffer;
  int sscanfResult;
  ushort **charTypeTable;
  char *strEndPtr;
  int listNewResult;
  int *errnoPtr;
  byte *patternPtr;
  uint charIndex;
  uint isSpecialChar;
  char *patternEndPtr;
  byte *parseCursor [2];
  
  // Check for a null line pointer
  if (line == (char *)0x0) {
    logError(2, "src/format.c", 0x41, "line is null or 0");
  }
  else {
    // Allocate buffer memory
    buffer = (byte *)calloc(1, 0x2008);
    if (buffer == (byte *)0x0) {
      errnoPtr = __errno_location();
      logError(2, "src/format.c", 0x45, "calloc fail, errno[%d]", *errnoPtr);
    }
    else {
      // Clear first half of the buffer
      memset(buffer, 0, 0x1001);
      sscanfResult = __isoc99_sscanf(line, " %[^= \t] = %n", buffer);
      if (sscanfResult == 1) {
        if (*line == '\"') {
          charIndex = (uint)*buffer;
          if (charIndex != 0) {
            charTypeTable = __ctype_b_loc();
            patternPtr = buffer;
            // Validate each character of the name
            do {
              isSpecialChar = charIndex - 0x5f;
              if (isSpecialChar != 0) {
                isSpecialChar = 1;
              }
              if ((isSpecialChar & ((*charTypeTable)[charIndex] ^ 8) >> 3) != 0) {
                logError(2, "src/format.c", 0x5c,
                         "format name[%s] contains invalid character", buffer);
                goto freeBufferAndReturnNull;
              }
              patternPtr = patternPtr + 1;
              charIndex = (uint)*patternPtr;
            } while (charIndex != 0);
          }
          // Find pattern end
          patternEndPtr = line + 1;
          strEndPtr = strrchr(patternEndPtr, 0x22);
          if (strEndPtr == (char *)0x0) {
            logError(2,"src/format.c",100,"missing ending quote (\") in pattern, line[%s]", line);
          }
          else if ((uint)(strEndPtr - patternEndPtr) < 0x1001) {
            patternPtr = buffer + 0x1001;
            memset(patternPtr, 0, 0x1001);
            memcpy(patternPtr, patternEndPtr, strEndPtr - patternEndPtr);
            sscanfResult = verifyPattern(patternPtr, 0x1001);
            if (sscanfResult == 0) {
              // Create list to hold parsed elements
              listNewResult = arrayListNew(customFreeFunction);
              *(int *)(buffer + 0x2004) = listNewResult;
              if (listNewResult == 0) {
                logError(2, "src/format.c", 0x77, "array list creation failed");
              }
              else {
                currentChar = buffer[0x1001];
                while (true) {
                  if (currentChar == 0) {
                    finalizeParse(buffer, 0);
                    return buffer;
                  }
                  sscanfResult = parsePattern(patternPtr, parseCursor, maxPatternSize);
                  if (sscanfResult == 0) break;
                  listNewResult = arrayListAdd(*(undefined4 *)(buffer + 0x2004), sscanfResult);
                  if (listNewResult != 0) {
                    customFreeFunction(sscanfResult);
                    logError(2, "src/format.c", 0x84, "array list addition failed");
                    goto freeBufferAndReturnNull;
                  }
                  currentChar = *parseCursor[0];
                  patternPtr = parseCursor[0];
                }
                logError(2, "src/format.c", 0x7e, "pattern parse error");
              }
            }
            else {
              logError(2, "src/format.c", 0x70, "environment variable replacement in pattern failed");
            }
          }
          else {
            logError(2, "src/format.c", 0x69, "pattern length exceeds maximum limit");
          }
        }
        else {
          logError(2, "src/format.c", 0x56, "first character of pattern is not (\") quote, line+nread[%s]",
                   line);
        }
      }
      else {
        logError(2, "src/format.c", 0x51, "format[%s] syntax error", line);
      }
freeBufferAndReturnNull:
      freeBuffer(buffer);
    }
  }
  return (byte *)0x0;
}
```