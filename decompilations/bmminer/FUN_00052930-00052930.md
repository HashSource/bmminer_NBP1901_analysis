```c
#include <pthread.h> // Needed for the mutex types
#include <stddef.h> // Needed for size_t

// Function prototypes might be needed for malloc, strlen, sprintf, send,
// usleep, memcpy, sscanf, inet_addr, socket, connect, perror, recv, and other library functions.

#define MUTEX_SIZE 0x24 // Size of the mutex to be allocated

int RegisterWithServer(int clientDataPointer) {
  pthread_mutex_t *clientMutex;
  size_t strLen;
  in_addr_t addr;
  int socketFD, connectResult;
  ssize_t numBytesReceived;
  int returnCode;
  uint portNumber;
  int commandResponseCode;
  struct sockaddr serverAddress;
  char commandBuffer[80];
  char receivedDataBuffer[80];
  char serverResponseBuffer[512];
  
  if (globalVariable_1 == 0) {
    // If some global condition is not met, return with an error.
    returnCode = -1;
  } else {
    // Allocate a mutex for this client
    clientMutex = (pthread_mutex_t *)malloc(MUTEX_SIZE);
    pthread_mutex_init(clientMutex, NULL); // Initialize the mutex without any specific attributes

    socketFD = globalSocketFD;
    // Clear command buffer and build the registration command
    memset(commandBuffer, 0, sizeof(commandBuffer));
    sprintf(commandBuffer, "%x regist %s", 0x3f, clientDataPointer);
    
    // Send the registration command to the server
    strLen = strlen(commandBuffer);
    send(socketFD, commandBuffer, strLen + 1, 0);

    // Wait for a response from the server by polling
    while (globalVariable_2 == globalVariable_3) { // Some condition for receiving data
      usleep(1000); // Wait for some time (1ms) before polling again
    }

    // After receiving a response, copy it into the response buffer
    memcpy(receivedDataBuffer, (void *)(globalVariable_2 * 0x80 + someGlobalDataOffset), 0x80);

    // Clear variables and buffers in preparation for handling the response
    portNumber = 0;
    commandResponseCode = 0;
    memset(serverResponseBuffer, 0, sizeof(serverResponseBuffer));

    // Parse the server's response
    sscanf(receivedDataBuffer, "%x%d%s%s%s", &commandResponseCode, &portNumber, &serverAddress, &someBuffer, &anotherBuffer);

    if (portNumber == 0) { // Check if the server provided a port number
      returnCode = -4;
    } else {
      // Initialize server address structure
      serverAddress.sa_family = 2;
      memset(&serverAddress.sa_data, '\0', sizeof(serverAddress.sa_data)); // Clear the address data

      // Set the IP address and port for the server
      addr = inet_addr("127.0.0.1"); // Localhost
      serverAddress.sa_data[2] = (char)addr; // Set the low byte of the IP address
      serverAddress.sa_data[3] = (char)(addr >> 8); // Set the high byte of the IP address
      serverAddress.sa_data[0] = (char)((portNumber & 0xff) << 8); // Set the low byte of the port
      serverAddress.sa_data[1] = (char)(portNumber >> 8); // Set the high byte of the port

      // Create a socket to connect to the server
      int clientSocket = socket(AF_INET, SOCK_STREAM, 0);
      if (clientSocket < 0) {
        perror("socket err:");
        returnCode = -4;
      } else {
        // Attempt to connect to the server's socket
        connectResult = connect(clientSocket, &serverAddress, sizeof(serverAddress));
        if (connectResult < 0) {
          perror("connect err:");
          returnCode = -3;
        } else {
          // If connection is successful, handle server messaging
          memset(serverResponseBuffer, 0, sizeof(serverResponseBuffer));
          numBytesReceived = recv(clientSocket, serverResponseBuffer, sizeof(serverResponseBuffer), 0);
          if (numBytesReceived > 0) {
            serverResponseBuffer[numBytesReceived - 1] = '\0';
          }

          // Send some data to the server (details are missing in the provided code)
          send(clientSocket, someDataToSend, someDataLength, 0);

          // Set return code to indicate successful execution
          returnCode = 0;

          // Store the client socket in the mutex and link it with client data
          *((int *)(clientMutex + 1)) = clientSocket; // Store the socket in the mutex (not a typical use of mutex)
          *((pthread_mutex_t **)(clientDataPointer + SOMEOFFSET)) = clientMutex; // Associate the mutex with client data
          clientMutex[1].__data.__lock = portNumber; // Store the port number (not typical use of __lock)
        }
      }
    }
  }

  // Return the result of the registration
  return returnCode;
}
```

Here's the modified code that includes comments and improved symbol naming for understandability. The code assumes some symbol imports will be present, as suggested by the comment at the beginning, which are required for the various library functions used within the function. Additionally, the structure of the original code is preserved, and the changes focus on improving variable naming and adding comments to clarify the steps taken during the registration process.

Please note that there are some unusual uses of the `pthread_mutex_t` structure where socket and port number are being stored. These are not typical or recommended uses of a `pthread_mutex_t`, which is normally used exclusively for thread synchronization. This modification has been preserved from the original code, but it's not a standard practice. The placeholder `SOMEOFFSET`, `someGlobalDataOffset`, `someDataToSend`, and `someDataLength`, are also included to represent values or operations that are not clear from the original decompiled code and would need to be determined by understanding the specific context in which this code is used.