```c
#include <pthread.h>
/* Global variables, renamed for clarity */
extern int g_logInitFlag;
extern pthread_key_t g_threadKey;
extern int g_logBufferSize;
extern unsigned int g_logReloadInterval;
extern unsigned int g_logReloadCounter;

/* Static data, needs contextual naming */
static pthread_rwlock_t *s_rwlockPtr; // Placeholder name, requires context for better naming
static int *s_threadLockPtr; // Placeholder name, requires context for better naming

/* Function prototypes, need to be named based on their functionality */
extern void InitiateLog(int level, const char *file, int line, const char *message);
extern int GetLogThreadData();
extern int UpdateLogThreadBuffer();
extern int OutputLogMessage();
extern void FreeLogThreadData();
extern int ReloadLogConfig(unsigned int forceFlag);
extern void DelayedFunction(); // Placeholder name, requires context for better naming
extern void LogErrorMessage(int level, const char *file, int line, const char *format, ...);

/* Renamed function to convey its functionality */
void LogMessageIfCondition(
  int bufferIndex,        // Index to the specific log buffer
  unsigned int param_2,   // Parameter requires contextual info for renaming
  unsigned int param_3,   // Parameter requires contextual info for renaming
  unsigned int param_4,   // Parameter requires contextual info for renaming
  unsigned int param_5,   // Parameter requires contextual info for renaming
  unsigned int srcLine,   // Source code line number where log is being called
  uint conditionBitIndex, // Bit index representing specific condition
  unsigned int param_8,   // Parameter requires contextual info for renaming
  unsigned int param_9    // Parameter requires contextual info for renaming
) {
  int *localThreadData;
  int funcResult;
  uint bufferBitPosition;
  uint bufferByteOffset;

  bufferByteOffset = conditionBitIndex + 7;
  if (conditionBitIndex >= 0) {
    bufferByteOffset = conditionBitIndex;
  }
  bufferBitPosition = conditionBitIndex & 7;
  if ((int)conditionBitIndex < 0) {
    bufferBitPosition = -(-conditionBitIndex & 7);
  }
  
  // Check the specified condition bit; return if not set
  if (((int)(uint)*(byte *)(bufferIndex + (bufferByteOffset >> 3) + 0x408) >> 
      (7 - bufferBitPosition & 0xff) & 1U) == 0) {
    return;
  }
  
  // Lock for thread-safe operations
  pthread_rwlock_rdlock(s_rwlockPtr);

  if (g_logInitFlag == 0) {
    // Log init function has never been called
    LogErrorMessage(2, "src/zlog.c", 0x2b6, "never call zlog_init() or dzlog_init() before");
    goto UnlockAndReturn;
  }

  // Get per-thread data specifically for logging
  localThreadData = (int *)pthread_getspecific(g_threadKey);
  if (localThreadData == NULL) {
    localThreadData = (int *)GetLogThreadData();
    if (localThreadData == NULL) {
      LogErrorMessage(2, "src/zlog.c", 0x2ba, "zlog_thread_new fail");
      goto UnlockAndReturn;
    }
	  
    funcResult = pthread_setspecific(g_threadKey, localThreadData);
    if (funcResult != 0) {
      FreeLogThreadData(localThreadData);
      LogErrorMessage(2, "src/zlog.c", 0x2ba, "pthread_setspecific fail, rd[%d]", funcResult);
      goto UnlockAndReturn;
    }
  }
  
  if (*localThreadData != g_logBufferSize) {
    funcResult = UpdateLogThreadBuffer(localThreadData);
    if (funcResult != 0) {
      LogErrorMessage(2, "src/zlog.c", 0x2ba, 
        "zlog_thread_resize_msg_buf fail, rd[%d]", funcResult);
      goto UnlockAndReturn;
    }
    *localThreadData = g_logBufferSize;
  }

  // Process and prepare log message
  OutputLogMessage(localThreadData[2], bufferIndex, *(unsigned int *)(bufferIndex + 0x404), 
                   param_2, param_3, param_4, param_5, srcLine, conditionBitIndex, param_8, param_9);

  // Output the log message
  funcResult = OutputLogMessage(bufferIndex, localThreadData);
  if (funcResult == 0) {
    if (g_logReloadInterval != 0 && 
        (++g_logReloadCounter >= g_logReloadInterval)) {
      pthread_rwlock_unlock(s_threadLockPtr);
      funcResult = ReloadLogConfig(0xffffffff);
      if (funcResult == 0) {
        return;
      }
      LogErrorMessage(2, "src/zlog.c", 0x2d3,
        "reach reload-conf-period but zlog_reload fail, zlog-chk-conf [file] see detail");
      return;
    }
  } else {
    // Log an error if the output fails
    LogErrorMessage(2, "src/zlog.c", 0x2c2, "zlog_output fail, srcfile[%s], srcline[%ld]", param_2, srcLine);
  }

UnlockAndReturn:
  // Unlock the thread lock
  pthread_rwlock_unlock(s_threadLockPtr);
}
```