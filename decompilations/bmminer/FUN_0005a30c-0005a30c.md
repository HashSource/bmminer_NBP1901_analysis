```c
#include <errno.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

#define MAX_PATH_SIZE 4096 // assuming the buffer size is 4096, you may need to adjust this value

// Write formatted log message to file and handle log rotation
int writeLogMessageToFileAndUpdateState(int loggerState, int formattingState) {
  int *logRule;
  int outputCount;
  char *outputBuffer;
  ssize_t bytesWritten;
  int fileDescriptor;
  unsigned int logSize;
  int *errorNumberPtr;
  void *formattedMessage;
  unsigned int messageSize;
  int fileState;
  struct stat64 fileInfo;
  bool needLogRotation;
  int rotationResult;
  char logFilePath[MAX_PATH_SIZE];
  
  logRule = *(int **)(loggerState + 0x1434); // Rule information offset
  outputCount = logRule[1];
  outputBuffer = (char *)**(int **)(formattingState + 0x10); // Assuming output buffer offset
  fileDescriptor = -1;
  
  // Initialize the output buffer
  (*(int **)(formattingState + 0x10))[1] = (int)outputBuffer;
  
  // Generate paths for all outputs
  for (int i = 0; i < outputCount; i++) {
    int outputFunctionPtr = *(int *)(*logRule + i * 4);
    int result = (*(int (**)(int, int))(outputFunctionPtr + 0x242C))(outputFunctionPtr, formattingState);
    if (result != 0) {
      logErrorEvent(2, "logWrite.c", 0x11d, "Failed to generate log path");
      return -1; // return error code
    }
  }
  
  outputBuffer = *(char **)(*(int *)(formattingState + 0x10) + 4);
  *outputBuffer = '\0'; // Add end of string
  
  // Format the log message
  fileState = formatLogMessage(*(int *)(loggerState + 0x1878), formattingState);
  if (fileState == 0) {
    char *filePath = **(char ***)(formattingState + 0x10); // Get file path from the formatting state
    fileDescriptor = open64(filePath, *(uint *)(loggerState + 0x102c) | O_CREAT | O_WRONLY | O_APPEND,
                             *(mode_t *)(loggerState + 0x1028)); // gain write permission
    if (fileDescriptor < 0) {
      errorNumberPtr = __errno_location();
      logErrorEvent(2, "logWrite.c", 0x127, "Failed to open file %s, errno: %d",
                    **(int **)(formattingState + 0x10), *errorNumberPtr);
      return -1; // error code
    }
    
    formattedMessage = **(void ***)(formattingState + 0x1c); // Assuming formatted message offset
    messageSize = *(uint *)((int)formattedMessage + 4) - (unsigned int)formattedMessage;
    bytesWritten = write(fileDescriptor, formattedMessage, messageSize);
    if (bytesWritten < 0) {
      errorNumberPtr = __errno_location();
      logErrorEvent(2, "logWrite.c", 0x12d, "Failed to write to file, errno: %d", *errorNumberPtr);
      close(fileDescriptor);
      return -1; // error code
    }
    
    // Check and perform log rotation based on configuration and written size
    handleLogRotation(loggerState, fileDescriptor, bytesWritten);
    
    if (close(fileDescriptor) < 0) {
      errorNumberPtr = __errno_location();
      logErrorEvent(2, "logWrite.c", 0x138, "Failed to close file after writing, errno: %d",
                    *errorNumberPtr);
      return -1; // error code
    }
    
    // Check if the message size is greater than the max log file size configuration
    if (*(uint *)(loggerState + 0x1450) < messageSize) {
      logErrorEvent(0, "logWrite.c", 0x13e,
                    "Single message length %ld is greater than the maximum allowed log size %ld",
                    messageSize, *(uint *)(loggerState + 0x1450));
      return 0;
    }
    
    // Get file information for log rotation
    if (__xstat64(3, filePath, &fileInfo) == 0) {
      logSize = *(uint *)(loggerState + 0x1450);
      int sizeWithMessage = fileInfo.st_size + messageSize;
      needLogRotation = sizeWithMessage >= logSize;
      
      if (needLogRotation) {
        rotationResult = rotateLog(loggerState, formattingState, filePath, messageSize);
        if (rotationResult != 0) {
          logErrorEvent(2, "logWrite.c", 0x14f, "Log rotation failed");
          return -1; // error code
        }
      }
      
      return 0; // Success
    }
    
    // Error obtaining file information
    errorNumberPtr = __errno_location();
    logErrorEvent(1, "logWrite.c", 0x143, "Stat failed for%s, errno: %d", filePath, *errorNumberPtr);
    return 0; // Not an error that should stop the program
  } else {
    logErrorEvent(2, "logWrite.c", 0x120, "Log message formatting failed");
    return -1; // error code
  }
}
```

This code has been refactored with more descriptive function and variable naming, and comments have been introduced to clarify intent where appropriate. It's important to note that decompiled code may not always provide the full context of original source code, and some assumptions had to be made, such as buffer sizes and offset values. Adjust them to fit the original software environment accurately.