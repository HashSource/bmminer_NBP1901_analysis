```c
/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */
/* Send and receive data to/from Bitmain Antminer's power controller */

#include <pthread.h>
#include <stdint.h>
#include <stdio.h>
#include <unistd.h>

typedef uint8_t byte;

// Define the result type for the operation
typedef enum {
  SUCCESS = 0,
  FAILURE_RETRYABLE = 0x80000300,
  FAILURE = 0xFFFFFFFF,
} PowerControllerResult;

// This mutex is used to ensure exclusive access to the power controller interface
extern pthread_mutex_t powerControllerMutex;

// Prototypes for functions not shown in the snippet that are used for communication with the power controller
extern void sendPowerControllerCommand(uint32_t controllerId, byte *commandBuffer, uint32_t commandLength, char *responseBuffer, uint32_t responseLength);
extern void readPowerControllerResponse(uint32_t controllerId, byte *commandBuffer, uint32_t commandLength, char *responseBuffer, uint32_t responseLength);

// Common function used to log messages
extern void logDebugMessage(char *format, ...);

PowerControllerResult exchangeDataWithPowerController(uint32_t controllerId, char *commandBuffer, uint32_t commandLength, char *responseBuffer, uint32_t responseLength) {
  byte checksumCommand = 0x11; // Command used to calculate checksum
  uint32_t retryCount = 0; // Counter for retries
  uint32_t calculatedChecksum, receivedChecksum;
  PowerControllerResult result = FAILURE_RETRYABLE;
  uint32_t i;
  char logBuffer[2048]; // Buffer for logging

  pthread_mutex_lock(&powerControllerMutex);

  while (retryCount < 3) {
    // Send command to the power controller
    for (i = 0; i < commandLength; ++i) {
      sendPowerControllerCommand(controllerId, &checksumCommand, 1, &commandBuffer[i], 1);
    }

    usleep(400000);

    // Read response from the power controller
    for (i = 0; i < responseLength; ++i) {
      readPowerControllerResponse(controllerId, &checksumCommand, 1, &responseBuffer[i], 1);
    }

    usleep(100000);

    // Calculate the checksum of the received data
    for (i = 1, calculatedChecksum = 0; i < responseLength - 2; ++i) {
      calculatedChecksum += responseBuffer[i];
    }
    calculatedChecksum &= 0xFFFF;

    // Extract the received checksum from the response
    receivedChecksum = ((byte)responseBuffer[responseLength - 2] + ((byte)responseBuffer[responseLength - 1] << 8)) & 0xFFFF;

    if (calculatedChecksum == receivedChecksum) {
      // If the checksums match, validate the rest of the response
      if ((commandBuffer[0] == responseBuffer[0]) &&
          (commandBuffer[1] == responseBuffer[1]) &&
          (commandBuffer[3] == responseBuffer[3]) &&
          (responseLength == (byte)responseBuffer[2] + 2)) {
        result = SUCCESS;
        break;
      }
      logDebugMessage("Power reply: bad data");
    } else {
      logDebugMessage("Power reply: bad CRC, CRC = 0x%04x, CRC read = 0x%04x", calculatedChecksum, receivedChecksum);
    }

    // Log the received data
    for (i = 1; i < responseLength; ++i) {
      logDebugMessage("read_back_data[%d] = 0x%02x", i - 1, (uint8_t)responseBuffer[i]);
    }

    // Log the retry attempt
    logDebugMessage("Send power cmd (0x%02x) failed, retry %d", (byte)commandBuffer[3], retryCount);
    ++retryCount;
  }

  pthread_mutex_unlock(&powerControllerMutex);

  return result;
}
```