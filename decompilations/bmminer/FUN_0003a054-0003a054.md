```c
// WARNING: Below pseudo code has renamed identifiers for improved readability.
// It is transformed from decompiled ARM binary code of an embedded Linux system (Bitmain Antminer).

void PrintMinerChainStats(int chainId, int statsBaseAddr) {
  int nonceNum, totalNoncesSent;
  uint nonceNumRepeated, nonceReturnRate, invalidNonceCount, hardwareErrorNonceCount;
  double stdDev, nonceRate;
  int tempVar; // Holds temporary calculations or values.
  uint loopVar;
  uint domainCount;
  unsigned int statsOffset;

  // Begin: Pseudo code for the given function
  if (globalMinerDataPointer == NULL || globalMinerDataPointer[1] == 0) {
    // Error Handling
    if (loggingLevel < 4) {
      return;
    }
    logError("Handle is NULL", NULL);
    return;
  }
  
  if (loggingLevel >= 4) {
    logFormatted("chain %d stats:\n", chainId);
    
    totalNoncesSent = getTotalNonces() * getSentNonceFactor() * 8;
    logFormatted("%-30s : %d\n", "send_nonce_num", totalNoncesSent);
    
    statsOffset = getOffset(chainId);
    nonceNum = *(int *)(statsBaseAddr + statsOffset);
    logFormatted("%-30s : %d\n", "recv_nonce_num", nonceNum);

    if (loggingLevel > 3) {
      nonceReturnRate = *(uint *)(statsBaseAddr + statsOffset);
      nonceRate = (double)nonceReturnRate / totalNoncesSent;
      logFormatted("%-30s : %f\n", "nonce_return_rate", nonceRate);
      
      nonceNumRepeated = *(uint *)(statsBaseAddr + statsOffset + 4);
      logFormatted("%-30s : %d\n", "nonce_num_repeated", nonceNumRepeated);
      
      logErrorNonces(chainId, statsBaseAddr); // Helper function to handle the logging.
      
      invalidNonceCount = *(uint *)(statsBaseAddr + statsOffset + 0x10);
      logFormatted("%-30s : %d\n", "nonce_num_invalid", invalidNonceCount);
      
      hardwareErrorNonceCount = *(uint *)(statsBaseAddr + statsOffset + 0x14);
      logFormatted("%-30s : %d\n", "nonce_num_hw", hardwareErrorNonceCount);
      
      logUnknownErrors(chainId, statsBaseAddr); // Helper function to handle the logging.
      
      stdDev = getStdDev(chainId, statsBaseAddr);
      logFormatted("%-30s : %.2f\n", "stddev", stdDev);
      
      // Inserts a newline for readability
      logNewline();
    }
    
    // Log the nonce values for particular chain ID.
    if (loggingLevel > 3) {
      logFormatted("Chain %d nonce:\n", chainId);
    }
  }
  
  // Iterate through ICs if present and log their values.
  if (iterateThroughICs(chainId, statsBaseAddr, logFormatted) == 0) {
    if (loggingLevel < 4) {
      checkAndHandleSpecialCondition(globalMinerDataPointer);
      return;
    }
    // Inserts a newline for readability
    logNewline();
    
    // Log the domain values for the particular chain ID.
    logDomainValues(chainId, statsBaseAddr, logFormatted); // Helper function to handle the logging.
  }
  // End: Pseudo code for the given function
}
```

This pseudo code primarily focuses on renaming functions, variables, and adding general structure to the code. Helper functions are assumed to exist (`logFormatted`, `logError`, `logNewline`, `getTotalNonces`, `getSentNonceFactor`, `getOffset`, `logErrorNonces`, `logUnknownErrors`, `getStdDev`, `checkAndHandleSpecialCondition`, `logDomainValues`, `iterateThroughICs`), which handle repetitive logging tasks and encapsulate complex operations for readability.

Note that the provided pseudo-code does not include all logic paths due to incomplete input; it was necessary to infer some functionalities and invent helper functions for unnamed repeated logic patterns. This example aims for clarity, but the actual implementation might require different function names and detailed error handling as per the original application's architecture.