```c
// Global variables indicating states (note: actual names of these variables would depend on their usage in the wider codebase)
extern char g_DebugFlag1;
extern char g_DebugFlag2;
extern int g_DebugLevel;

extern char g_Hex2BinStrTruncated[];
extern char g_HexCharToBinMap[];
extern int g_UnkGlobalHexConst;
extern char g_Hex2BinScanFailed[];

// Converts a string of hexadecimal characters into their binary representation
// param_1: Destination buffer where the binary data will be stored.
// param_2: Source buffer containing the hexadecimal string.
// param_3: The maximum number of bytes to convert.
// Returns 1 for success, 0 for failure.
int ConvertHexStringToBinary(byte *destinationBuffer, byte *sourceHexString, int maxConvertBytes) {
  byte *hexCharPtr;
  byte *nextHexCharPtr;
  uint binValue1; // binary value for first hexadecimal character
  uint binValue2; // binary value for second hexadecimal character
  int status = 0;

  // Initialize all local variables with zeros
  byte localBuffer[20] = {0};
  
  // If the hex string is empty or length to convert is zero, return success
  if (*sourceHexString == 0 || maxConvertBytes == 0) {
    status = 1;
  }
  // If the length to convert is not zero and hex string is not empty
  else if (maxConvertBytes != 0) {
    // If the hex string has only one character
    if (sourceHexString[1] == 0) {
      goto LogTruncatedHexString;
    }
    else {
      // Convert hexadecimal characters to their binary representation using a lookup table
      binValue1 = *(uint *)(g_HexCharToBinMap + (uint)sourceHexString[1] * 4);
      binValue2 = *(uint *)(g_HexCharToBinMap + (uint)*sourceHexString * 4);
      // Check for valid hexadecimal characters
      if (binValue1 >= 0 && binValue2 >= 0) {
        sourceHexString += 4;
        do {
          maxConvertBytes -= 1;
          *destinationBuffer = (byte)binValue1 | (byte)(binValue2 << 4);
          hexCharPtr = sourceHexString - 2;
          if (*hexCharPtr == 0) {
            if (maxConvertBytes != 0) {
              status = 0;
            }
            status = 1;
          }
          if (maxConvertBytes == 0) {
            status = 0;
          }
          nextHexCharPtr = sourceHexString - 1;
          sourceHexString += 2;
          if (*nextHexCharPtr == 0) goto LogTruncatedHexString;
          binValue2 = *(uint *)(g_HexCharToBinMap + (uint)*hexCharPtr * 4);
          binValue1 = *(uint *)(g_HexCharToBinMap + (uint)*nextHexCharPtr * 4);
          destinationBuffer += 1;
        } while (binValue2 >= 0 && binValue1 >= 0);
      }
      if (g_DebugFlag1 != '\0' || g_DebugFlag2 != '\0' || g_DebugLevel > 2) {
        memcpy(localBuffer, g_Hex2BinScanFailed, 20);
        LogDebugMessage(3, localBuffer, 0);
        return 0;
      }
    }
  }
  return status;

LogTruncatedHexString:
  if (g_DebugFlag1 != '\0' || g_DebugFlag2 != '\0' || g_DebugLevel > 2) {
    memcpy(localBuffer, g_Hex2BinStrTruncated, 20);
    LogDebugMessage(3, localBuffer, 0);
  }
  return 0;
}
```

Please note that in this example, the `memcpy` and `LogDebugMessage` functions are generally assumed to exist based on the decompiled code provided. Since the code snippets include references to debugging logs, it's presumed that there's some form of logging functionality included in other parts of the system. The names of the log-related functions, as well as external variables like `g_HexCharToBinMap`, `g_DebugFlag1`, `g_DebugFlag2`, and `g_DebugLevel`, have been chosen to be descriptive, but their names would ultimately depend on their actual usage in the context of the application from which this function was decompiled.