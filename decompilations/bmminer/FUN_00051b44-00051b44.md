```c
#include <pthread.h>

// Define the type for better readability for return values
typedef unsigned int ResultCode;

// Global mutex and data arrays used in synchronization and storage
extern pthread_mutex_t globalDataMutex;
extern uint32_t registerDataMap[];
extern uint32_t individualRegisterValues[];

// Constants that represent error codes
const ResultCode ERROR_INVALID_CHAIN = 0xffffffff;
const ResultCode ERROR_INVALID_ASIC = 0xfffffffe;
const ResultCode ERROR_INVALID_REGISTER = 0xfffffffd;
const ResultCode ERROR_INVALID_LEVEL_OR_CHAIN_MISMATCH = 0xfffffffc;
const ResultCode ERROR_INVALID_ASIC_MISMATCH = 0xfffffffb;
const ResultCode ERROR_INVALID_OPERATION = 0xfffffffa;

// Function to update ASIC register value safely with mutex
ResultCode UpdateASICRegister(int level, uint chainIndex, uint asicIndex, uint registerAddress, uint32_t newValue) {
  uint registerIndexBase;
  uint arrayOffset;
  uint arrayIndex;
  
  // Constraints for valid register updates
  if (chainIndex < 4) {
    if (asicIndex < 0x100) {
      registerIndexBase = registerAddress >> 2;
      if (registerIndexBase < 0x41) {
        // Lock mutex before modifying shared data
        pthread_mutex_lock(&globalDataMutex);
        
        if (level == 0) {
          arrayIndex = registerIndexBase + chainIndex * 0x40;
          if (registerDataMap[arrayIndex] == registerAddress) {
            arrayOffset = registerIndexBase + chainIndex * 0x4000;
            individualRegisterValues[arrayOffset] = newValue;
            
            uint8_t *bytePtr = (uint8_t *)&individualRegisterValues[arrayOffset];
            // Update all associated register values
            do {
              *((uint32_t *)(bytePtr + 4)) = newValue;
              bytePtr += 0x200;
            } while (bytePtr != (uint8_t *)(arrayOffset + (uint8_t *)&individualRegisterValues + 0x20000));
            
            // Unlock mutex
            pthread_mutex_unlock(&globalDataMutex);
            return 0; // Success
          }
          // Unlock mutex and return error if register address mismatch
          pthread_mutex_unlock(&globalDataMutex);
          return ERROR_INVALID_LEVEL_OR_CHAIN_MISMATCH;
        }
        else if (level == 1) {
          arrayIndex = registerIndexBase + (asicIndex + chainIndex * 0x100) * 0x40;
          if (individualRegisterValues[arrayIndex] == registerAddress) {
            *(uint32_t *)((uint8_t *)&individualRegisterValues + arrayIndex * 8) = newValue;
            pthread_mutex_unlock(&globalDataMutex);
            return 0; // Success
          }
          pthread_mutex_unlock(&globalDataMutex);
          return ERROR_INVALID_ASIC_MISMATCH;
        }
        else {
          pthread_mutex_unlock(&globalDataMutex);
          return ERROR_INVALID_OPERATION;
        }
        // Uncomment the next line if you want to print error information
        //printf("[%s] level::%d, chainIndex::%u, asicIndex::%u, registerAddress::%02x failed.\r\n", someErrorContextVar, level, chainIndex, asicIndex, registerAddress);
      }
      else {
        return ERROR_INVALID_REGISTER;
      }
    }
    else {
      return ERROR_INVALID_ASIC;
    }
  }
  else {
    return ERROR_INVALID_CHAIN;
  }
}
```