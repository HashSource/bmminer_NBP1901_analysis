```c
int processStatusServiceRequest(int socket_fd)
{
  char *buffer;
  char *search_str;
  size_t buffer_len;
  int bytes_received;
  int total_bytes_received;
  size_t response_len;
  ssize_t send_result;
  int *error_num_ptr;
  int ret_val;
  uint bytes_sent;
  char *response_ptr;
  char http_header_template[15];
  socklen_t timeout_len;
  struct timeval recv_timeout;
  struct timeval send_timeout;
  struct sockaddr_in client_addr;
  char recv_buffer[10240];
  char statusLogFormat[2048];
  char insignificant;
  
  ret_val = 0;
  recv_timeout.tv_sec = 3;
  recv_timeout.tv_usec = 0;
  buffer = (char *)calloc(1,0x6000); // Allocate buffer for the response
  response_ptr = recv_buffer;
  http_header_template[0] = '\r';    // HTTP header template
  http_header_template[1] = '\n';
  http_header_template[13] = '\r';
  http_header_template[14] = '\n';
  timeout_len = 0;
  insignificant = 0;
  memset(response_ptr,0,0x2800);
  do {
    if (_GLOBAL_IS_SHUTDOWN != '\0') goto handle_shutdown;
    send_result = recvfrom(socket_fd,response_ptr,0x27ff - total_bytes_received,0,&client_addr,&timeout_len);
    total_bytes_received += send_result;
    if (send_result < 1) {
      close(socket_fd);
      if ((_LOGGING_ENABLED != '\0') &&
         ((_INTERNAL_LOGGING_FLAG != '\0' || (_LOGGING_FLAG != '\0')) || (6 < _GLOBAL_LOG_LEVEL))) {
        constructStatusServiceThreadRecvfromLog(statusLogFormat); // Use a function to construct log message
        logStatus(7, statusLogFormat); // Log status if level higher than 6
      }
      goto exit_cleanup;
    }
    response_ptr = recv_buffer + total_bytes_received;
    if (0x27fe < total_bytes_received) { // Check if buffer is too small
      close(socket_fd);
      constructErrorMsgBufferTooSmall(statusLogFormat);
      logStatus(7, statusLogFormat);
      goto exit_cleanup;
    }
    search_str = strstr(recv_buffer, http_header_template); // Search for the end of HTTP header
  } while (search_str == (char *)0x0);
  if (_LOGGING_ENABLED != '\0') {
    if ((_INTERNAL_LOGGING_FLAG == '\0') && (_LOGGING_FLAG == '\0') && (_GLOBAL_LOG_LEVEL < 7)) {
go_directly_to_logging:
      if ((_LOGGING_FLAG != '\0') || (_GLOBAL_LOG_LEVEL > 6)) {
go_to_internal_logging_check:
        snprintf(statusLogFormat, 0x800, "get http=%s", recv_buffer);
        logStatus(7, statusLogFormat);
      }
    }
    else {
      constructStatusServiceThreadFindHttpRequestEndFlagLog(statusLogFormat);
      logStatus(7, statusLogFormat);
handle_shutdown:
      if (_LOGGING_ENABLED != '\0') {
        if (_INTERNAL_LOGGING_FLAG == '\0') goto go_directly_to_logging;
        goto go_to_internal_logging_check;
      }
    }
  }
  // Validate HTTP request type, only 'GET' is supported
  if ((recv_buffer[0] != 'G') || (recv_buffer[1] != 'E') || (recv_buffer[2] != 'T') || (recv_buffer[3] != ' ')) {
    close(socket_fd);
    if ((_LOGGING_ENABLED != '\0') &&
       ((_INTERNAL_LOGGING_FLAG != '\0' || (_LOGGING_FLAG != '\0')) || (_GLOBAL_LOG_LEVEL > 6))) {
      constructStatusServiceThreadNotSupportHTTPMethodLog(statusLogFormat);
      logStatus(7, statusLogFormat);
    }
    goto exit_cleanup;
  }
  // Set socket options for timeouts
  ret_val = setsockopt(socket_fd, SOL_SOCKET, SO_RCVTIMEO, &recv_timeout, sizeof(recv_timeout));
  if (ret_val == 0) {
    ret_val = setsockopt(socket_fd, SOL_SOCKET, SO_SNDTIMEO, &send_timeout, sizeof(send_timeout));
    if (ret_val == 0) {
      if (_HANDLE_HTTP_REQUEST == (void *)0x0) { // No handler function for HTTP request
        if ((_LOGGING_ENABLED != '\0') &&
           ((_INTERNAL_LOGGING_FLAG != '\0' || (_LOGGING_FLAG != '\0')) || (_GLOBAL_LOG_LEVEL > 6))) {
          constructNoTestCaseFoundLog(statusLogFormat);
          logStatus(7, statusLogFormat);
        }
      }
      else {
        ret_val = _HANDLE_HTTP_REQUEST(recv_buffer, buffer, 0x6000); // Process the HTTP request
        if (ret_val != 0) { // Handler returns non-zero for error
          close(socket_fd);
          if ((_LOGGING_ENABLED != '\0') &&
             ((_INTERNAL_LOGGING_FLAG != '\0' || (_LOGGING_FLAG != '\0')) || (_GLOBAL_LOG_LEVEL > 6))) {
            constructStatusServiceThreadExitForErrorLog(statusLogFormat);
            logStatus(7, statusLogFormat);
          }
          goto exit_cleanup;
        }
      }
      // Prepare and send HTTP response
      response_len = strlen(buffer);
      ret_val = constructHTTPResponseHeaders(statusLogFormat, "HTTP/1.0  200  OK", response_len, http_header_template);
      if (_LOGGING_ENABLED == '\0') {
        if (_GLOBAL_IS_SHUTDOWN == '\0') goto send_http_headers;
      }
      else {
        if ((_INTERNAL_LOGGING_FLAG == '\0') && (_LOGGING_FLAG == '\0') && (_GLOBAL_LOG_LEVEL < 7)) {
          if (_GLOBAL_IS_SHUTDOWN == '\0') {
send_http_headers:
            sendHTTPRequestHeaders(socket_fd, statusLogFormat, ret_val);
            goto send_response_data;
          }
        }
        else {
          snprintf(statusLogFormat, sizeof(statusLogFormat), "send http response");
          logStatus(7, statusLogFormat);
          if (_GLOBAL_IS_SHUTDOWN == '\0') goto send_http_headers;
send_response_data:
          if (_LOGGING_ENABLED == '\0') goto send_http_data;
        }
        if ((_INTERNAL_LOGGING_FLAG != '\0') || (_LOGGING_FLAG != '\0') || (_GLOBAL_LOG_LEVEL > 6)) {
          snprintf(statusLogFormat, sizeof(statusLogFormat), "send http data");
          logStatus(7, statusLogFormat);
        }
      }
send_http_data:
      ret_val = 0;
      // Send the response data
      while (true) {
        send_result = send(socket_fd, buffer + ret_val, response_len - ret_val, 0);
        if ((_LOGGING_ENABLED != '\0') &&
           ((_INTERNAL_LOGGING_FLAG != '\0' || (_LOGGING_FLAG != '\0')) || (_GLOBAL_LOG_LEVEL > 6))) {
          snprintf(statusLogFormat, sizeof(statusLogFormat), "send http data ret=%d", send_result);
          logStatus(7, statusLogFormat);
        }
        if (send_result < 1) break; // Error encountered or data fully sent
        ret_val += send_result;
        if ((int)response_len <= ret_val || _GLOBAL_IS_SHUTDOWN != '\0') goto handle_client_disconnected;
      }
      if (_LOGGING_ENABLED == '\0') goto handle_client_exit;
      if ((_INTERNAL_LOGGING_FLAG == '\0') && (_LOGGING_FLAG == '\0') && (_GLOBAL_LOG_LEVEL < 7))
      goto handle_client_exit_label;
      constructStatusServiceThreadSendHttpDataLog(statusLogFormat);
      logStatus(7, statusLogFormat);
handle_client_disconnected:
      if (_LOGGING_ENABLED != '\0') {
        if (_INTERNAL_LOGGING_FLAG == '\0') {
handle_client_exit_label:
          if ((_LOGGING_FLAG == '\0') && (_GLOBAL_LOG_LEVEL < 7)) goto handle_client_exit;
        }
        snprintf(statusLogFormat, sizeof(statusLogFormat), "one client disconnected");
        logStatus(7, statusLogFormat);
      }
handle_client_exit:
      close(socket_fd);
      free(buffer);
      return ret_val;
    }
    close(socket_fd);
    if ((_LOGGING_ENABLED == '\0') ||
       ((_INTERNAL_LOGGING_FLAG == '\0') && (_LOGGING_FLAG == '\0') && (_GLOBAL_LOG_LEVEL < 7)))
    goto exit_cleanup;
    response_ptr = "setsockopt SO_RCVTIMEO failed";
  }
  else {
    close(socket_fd);
    if ((_LOGGING_ENABLED == '\0') ||
       ((_INTERNAL_LOGGING_FLAG == '\0') && (_LOGGING_FLAG == '\0') && (_GLOBAL_LOG_LEVEL < 7)))
    goto exit_cleanup;
    response_ptr = "setsockopt SO_SNDTIMEO failed";
  }
  snprintf(statusLogFormat, sizeof(statusLogFormat), "%s", response_ptr);
  logStatus(7, statusLogFormat);
exit_cleanup:
  if (buffer != (char *)0x0) {
free_and_exit:
    free(buffer);
  }
  return 0;
}
```

I've replaced pseudo names and tokens with more understandable equivalents, assuming the purposes based on their usage within the code. Comments have also been added to provide context about each step, and helper functions have been suggested where the original code seems to be forming log entries or sending responses. 

As we cannot see the full code base or definitions of functions and globals, I made assumptions about their purpose and names. The general flow of the code, however, should now be clearer to understand.