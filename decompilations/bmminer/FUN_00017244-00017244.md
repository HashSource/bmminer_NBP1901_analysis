```c
// Global logging level
extern uint LoggingLevel;

void PrintHexDump(uint32_t chainIndex, int memoryPointer, uint bufferSize)
{
  uint currentByteIndex;
  uint numBytesPrinted;
  uint numLineBreaks;
  char buffer[0x800];
  char byteValue;

  // Check logging level. If lower than 4, return immediately if the buffer is empty.
  if (LoggingLevel < 4) {
    if (bufferSize == 0) {
      return;
    }
  }
  else {
    // We have something to log and the logging level is high enough
    // Print out the "chain" message with the index of the chain
    snprintf(buffer, sizeof(buffer), "[chain %d]\n", chainIndex);
    WriteToLog(3, buffer, 0); // Write the buffer to the log
    if (bufferSize == 0) goto FinishLogging;
  }

  // Initialize variables for iterating over bytes
  currentByteIndex = 0;

  // Iterate over each byte in the buffer and print its hex value
  while (currentByteIndex < bufferSize) {
    // Get current line break count by masking byte index to max of 15 (0xF)
    numLineBreaks = currentByteIndex & 0xf;

    // If we are at the start of a new line
    if (numLineBreaks == 0) {
      // Print the line starting address if logging level allows
      if (LoggingLevel > 3) {
        snprintf(buffer, sizeof(buffer), "0x%04X ", currentByteIndex);
        WriteToLog(3, buffer, 0);
      }
    }

    // If logging level allows, print the current byte in hexadecimal
    if (LoggingLevel > 3) {
      // Get the current byte from memory and print it
      byteValue = *(byte *)(memoryPointer + currentByteIndex);
      snprintf(buffer, sizeof(buffer), "%02X ", (uint)byteValue);
      WriteToLog(3, buffer, 0);

      // If we are at the end of a line, print a newline
      if ((numLineBreaks == 0xf) && (LoggingLevel > 3)) {
        currentByteIndex++;
        buffer[0] = 10; // Newline character
        WriteToLog(3, buffer, 0);
        if (bufferSize <= currentByteIndex) break; // Check if it's the end
        continue; // Continue printing the next line
      }
    }

    // If the current byteIndex is half of the max line length (16 bytes), print the separator
    if (numLineBreaks == 8 && LoggingLevel > 3) {
      uint16_t separator = 0x20; // ASCII for space ' '
      *((uint16_t*)buffer) = separator;
      WriteToLog(3, buffer, 0);
    }

    // Move to the next byte
    currentByteIndex++;
  }

FinishLogging:
  // Finish logging if the current log level is lower than 4
  if (LoggingLevel < 4) {
    return;
  }

  // Print final newline character
  buffer[0] = 10; // Newline character
  WriteToLog(3, buffer, 0);
}
```