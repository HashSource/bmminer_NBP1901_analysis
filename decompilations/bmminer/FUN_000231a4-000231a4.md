```c
void updateHashState(uint *hashStateBuffer, void *inputData, uint inputDataLength) {
  uint currentBufferLength;
  uint totalBufferLength;
  void *destBuffer;
  size_t bytesToCopy;
  void *currentInputPtr;
  uint remainingDataLength;
  bool lengthOverflow;
  
  currentBufferLength = *hashStateBuffer;
  lengthOverflow = CARRY4(currentBufferLength, inputDataLength); // Check if adding inputDataLength overflows uint
  totalBufferLength = currentBufferLength + inputDataLength;  // Calculate total length after adding inputData
  remainingDataLength = currentBufferLength & 0x3f; // Get the remaining length to complete a 64 byte block (since SHA-256 processes 64-byte blocks)
  
  if (lengthOverflow) {
    currentBufferLength = hashStateBuffer[1];  // Get the high part of the 64-bit length counter
  }

  bytesToCopy = 0x40 - remainingDataLength;  // Calculate the number of bytes to copy to fill a block
  *hashStateBuffer = totalBufferLength; // Updates the low part of the 64-bit length counter

  if (lengthOverflow) {
    hashStateBuffer[1] = currentBufferLength + 1;  // Update the high part of the 64-bit length counter
  }

  if (remainingDataLength != 0 && (int)bytesToCopy <= (int)inputDataLength) {
    inputDataLength -= bytesToCopy;  // Update inputDataLength after the initial copy
    memcpy((void *)((int)(hashStateBuffer + 10) + remainingDataLength), inputData, bytesToCopy); // Copy to hashStateBuffer starting from the offset
    inputData = (void *)((int)inputData + bytesToCopy); // Move inputData pointer forward
    remainingDataLength = 0; // Clear the remaining data length as we've just completed a block
    processBlock(hashStateBuffer, hashStateBuffer + 10); // Process the completed block using SHA-256
  }

  if (0x3f < (int)inputDataLength) {
    uint numFullBlocks = (inputDataLength - 0x40) >> 6; // Calculate the number of full 64-byte blocks in the inputData
    currentInputPtr = (void *)((int)inputData + (numFullBlocks + 1) * 0x40); // Calculate pointer to end of the last full block

    for (destBuffer = inputData; destBuffer != currentInputPtr; destBuffer = (void *)((int)destBuffer + 0x40)) {
      processBlock(hashStateBuffer, destBuffer); // Process each full 64-byte block
    }
    
    inputDataLength = (inputDataLength - 0x40) + numFullBlocks * -0x40; // Update inputDataLength for the potential last incomplete block
  }

  if (0 < (int)inputDataLength) {
    // Copy any remaining data that doesn't form a complete block into hashStateBuffer
    memcpy((void *)((int)hashStateBuffer + remainingDataLength + 0x28), inputData, inputDataLength);
  }
  
  // No return statement needed because the function returns void
}
```