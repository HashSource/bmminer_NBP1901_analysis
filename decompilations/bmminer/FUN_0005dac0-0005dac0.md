```c
#define HASH_TABLE_ERROR -1
#define HASH_TABLE_SUCCESS 0

typedef struct Entry {
  uint32_t hashValue;      // Hash value of the key
  uint32_t key;            // Key
  uint32_t value;          // Value
  struct Entry *next;      // Pointer to the next entry in the same bucket
  struct Entry *prev;      // Pointer to the previous entry in the same bucket
} Entry;

typedef struct HashTable {
  uint32_t size;           // Current number of elements in the hash table
  uint32_t capacity;       // Capacity of the hash table
  Entry **buckets;         // Array of bucket pointers
  code *hashFunc;          // Pointer to the hash function
  code *compareFunc;       // Pointer to the compare function
  code *keyDestructor;     // Pointer to the function to destroy keys
  code *valueDestructor;   // Pointer to the function to destroy values
} HashTable;

// Function that adds a key-value pair to a hash table, rehashing if necessary
int HashTable_Add(HashTable *hashTable, uint32_t key, uint32_t value) {
  size_t newCapacity;
  int errnoValue;
  Entry *tempEntryPtr;
  Entry *newEntry;
  uint32_t hash;
  int bucketIndex;
  Entry *currentEntry;
  Entry *endEntry;
  
  // Calculate hash for the given key
  hash = hashTable->hashFunc(key);
  bucketIndex = hash % hashTable->capacity;

  // Search for an existing entry with the same key
  currentEntry = hashTable->buckets[bucketIndex];
  while (currentEntry != NULL) {
    if (hashTable->compareFunc(key, currentEntry->key)) {
      // Key match found, update the entry
      if (hashTable->keyDestructor) {
        hashTable->keyDestructor(currentEntry->key);
      }
      if (hashTable->valueDestructor) {
        hashTable->valueDestructor(currentEntry->value);
      }
      currentEntry->key = key;
      currentEntry->value = value;
      return HASH_TABLE_SUCCESS;
    }
    currentEntry = currentEntry->next;
  }

  // No existing entry found, check if rehash is needed
  double loadFactor = (double)hashTable->size * HASH_LOAD_FACTOR;
  double rehashThreshold = (double)hashTable->capacity;

  // Compare load factor to ensure it doesn't exceed the threshold
  if (loadFactor != rehashThreshold && (loadFactor < rehashThreshold || isnan(loadFactor) || isnan(rehashThreshold))) {
    // Rehash is needed: double the capacity of the hash table
    newCapacity = hashTable->capacity << 1;
    Entry **newBuckets = calloc(newCapacity, sizeof(Entry*));
    if (newBuckets == NULL) {
      errnoValue = *__errno_location();
      // Log and handle calloc failure
      return HASH_TABLE_ERROR;
    }
    
    // Rehash entries in the table
    for (int i = 0; i < hashTable->capacity; ++i) {
      tempEntryPtr = hashTable->buckets[i];
      while (tempEntryPtr != NULL) {
        
        Entry *nextEntry = tempEntryPtr->next; // Store next entry
        
        // Reset next/prev pointers
        tempEntryPtr->prev = NULL;
        tempEntryPtr->next = NULL;
        
        // Calculate new bucket index
        bucketIndex = tempEntryPtr->hashValue % newCapacity;
        
        // Insert into new bucket
        endEntry = newBuckets[bucketIndex];

        // Handle collision
        if (endEntry != NULL) {
          endEntry->prev = tempEntryPtr;
          tempEntryPtr->next = endEntry;
        }
        newBuckets[bucketIndex] = tempEntryPtr;
        tempEntryPtr = nextEntry;
      }
    }
    
    // Replace old buckets with new ones
    free(hashTable->buckets);
    hashTable->buckets = newBuckets;
    hashTable->capacity = newCapacity;
  }

  // Create new entry
  newEntry = (Entry *)calloc(1, sizeof(Entry));
  if (newEntry == NULL) {
    errnoValue = *__errno_location();
    // Log and handle calloc failure
    return HASH_TABLE_ERROR;
  }

  // Initialize new entry with provided key and value
  newEntry->hashValue = hashTable->hashFunc(key);
  newEntry->key = key;
  newEntry->value = value;
  newEntry->prev = NULL;
  newEntry->next = NULL;

  // Insert new entry into appropriate bucket
  bucketIndex = newEntry->hashValue % hashTable->capacity;
  endEntry = hashTable->buckets[bucketIndex];

  // Handle collision
  if (endEntry != NULL) {
    endEntry->prev = newEntry;
    newEntry->next = endEntry;
  }

  hashTable->buckets[bucketIndex] = newEntry;
  hashTable->size++;

  return HASH_TABLE_SUCCESS;
}
```

In this modified code, I've added struct definitions for better understanding and readability, replaced the magic numbers with appropriate constants for error and success, and renamed functions, variables, and parameters to reflect their purpose within the context of a hash table implementation. Additionally, I have included comments that explain the logic and the steps performed in the HashTable_Add function.