```c
int CheckPowerStatus(int requested_voltage)
{
  double voltage_conversion_factor;
  double lower_voltage_threshold_factor;
  double upper_voltage_threshold_factor;
  uint power_version;
  int check_result;
  int attempt;
  char logging_buffer[2080]; // Assuming 0x800 is 2080 based on snprintf usage
  
  // Function to get the power control version
  power_version = GetPowerControlVersion();
  
  if (logging_level < LOG_LEVEL_DEBUG) {
    snprintf(logging_buffer, sizeof(logging_buffer), "power type version: 0x%04x\n", power_version);
    LogMessage(LOG_LEVEL_DEBUG, logging_buffer);
  }
  
  check_result = CheckPowerVersionCompatibility(power_version & 0xffff);
  if (check_result == 0) {
    // If power version is not compatible
    if (logging_level < LOG_LEVEL_DEBUG) {
      LogMessage(LOG_LEVEL_ERROR, "power type version error.\n");
      return -1;
    }
  }
  else {
    // If power version is compatible
    if (logging_level < LOG_LEVEL_DEBUG) {
      LogMessage(LOG_LEVEL_INFO, "Enter sleep to make sure power resets correctly.");
    }
    
    PowerControlReset();
    sleep(1);
    InitializePowerControl();
    
    check_result = ConfigurePowerControlForVoltage(requested_voltage);
    if (check_result < 0) {
      // If configuring the power control failed
      if (logging_level >= LOG_LEVEL_INFO) {
        snprintf(logging_buffer, sizeof(logging_buffer), "%s power iic error.\n", power_control_name);
        LogMessage(LOG_LEVEL_ERROR, logging_buffer);
      }
      return check_result;
    }
    
    DisablePowerControl();
    sleep(1);
    
    voltage_conversion_factor = voltage_conversion_global;
    lower_voltage_threshold_factor = lower_voltage_threshold_global;
    upper_voltage_threshold_factor = upper_voltage_threshold_global;
    
    if (power_version - POWER_VERSION_OFFSET < POWER_VERSION_RANGE) {
      attempt = 3;
      do {
        sleep(1);
        double feedback_voltage = GetFeedbackVoltage(0);
        
        if (feedback_voltage < 0.0) {
          if (logging_level < LOG_LEVEL_DEBUG) {
            LogMessage(LOG_LEVEL_ERROR, "read feedback voltage failed");
          }
          check_result = 0;
          LogWarning("power voltage read failed, pls check!");
          goto Cleanup;
        }
        
        feedback_voltage *= voltage_conversion_factor;
        double adjusted_requested_voltage = (double)requested_voltage * lower_voltage_threshold_factor;
        
        if ((feedback_voltage == adjusted_requested_voltage ||
             feedback_voltage < adjusted_requested_voltage != IS_NAN(feedback_voltage, adjusted_requested_voltage)) &&
            (feedback_voltage >= (double)requested_voltage * upper_voltage_threshold_factor)) {
          check_result = 0;
          goto Cleanup;
        }
        
        // If voltage is not within the expected range
        AttemptLoggingVoltageIssues(feedback_voltage, requested_voltage);
        --attempt;
      } while (attempt != 0);
      check_result = -1;
    }
    else {
      attempt = 3;
      do {
        sleep(1);
        double current_voltage = GetCurrentVoltage();
        
        if (((double)requested_voltage * 0.75) / voltage_conversion_factor <= current_voltage) {
          return 0;
        }
        
        // If voltage is not within the expected range
        LogMessage(LOG_LEVEL_ERROR, "power voltage cannot meet the threshold");
        --attempt;
      } while (attempt != 0);
    }
  }
  
Cleanup:
  // Wait until power status is OK or timeout
  for (uint retry_count = 0; retry_count < 20; ++retry_count) {
    check_result = CheckPowerStatusFromHardware();
    if (check_result == 0) {
      return check_result;
    }
    
    // Log every 5 attempts
    if ((retry_count % 5 == 0) && (logging_level < LOG_LEVEL_DEBUG)) {
      LogMessage(LOG_LEVEL_WARNING, "bitmain get power status failed, retrying...");
    }
    
    sleep(3);
  }
  
  return -1;
}

// Helper function to log voltage issues, it uses global level < LOG_LEVEL_DEBUG and a macro to check NaN
void AttemptLoggingVoltageIssues(double feedback_voltage, int requested_voltage)
{
  char *message;
  if (feedback_voltage != 0 && feedback_voltage < 0 != IS_NAN(feedback_voltage)) {
    message = "less than";
  } else if (feedback_voltage == 0 || feedback_voltage < 0 != IS_NAN(feedback_voltage)) {
    message = "greater than or equal to";
  }
  
  snprintf(logging_buffer, sizeof(logging_buffer), "Chain average voltage %s from %d to %.2f", message, requested_voltage);
  LogMessage(LOG_LEVEL_DEBUG, logging_buffer);
  LogMessage(LOG_LEVEL_ERROR, "power voltage cannot meet the target");
}
```