```c
#include <stdio.h>
#include <unistd.h>
#include <pthread.h>

// Constants (you'll have to replace these with the actual values or define them accordingly)
#define UART_SEND_FIFO_SPACE_INFO_ADDR (0x504ce8) // Example address 

// Forward declarations of used functions (you'll have to replace these names with the actual function names)
void LockMutex(pthread_mutex_t *mutex);
void UnlockMutex(pthread_mutex_t *mutex);
int GetUartSendAddressInfo(int chain_id, uint *send_fifo_space, undefined4 *param_2, undefined4 *param_3, undefined4 *param_4);
void SomeFunctionWithParamAndShift(undefined4 param, uint *value_to_shift);
void AnotherFunctionWithParam(uint value);
int PrintFormattedLog(int logLevel, char *message, int param);

// Example global data (should be named properly according to its purpose in the actual binary/library)
extern undefined4 gSomeGlobalData;

// Function to wait for enough space in UART send FIFO
void WaitForUartSendFifoSpace(int chain_id) {
    // Local variables initialization
    pthread_mutex_t *pUartMutex;
    undefined4 uart_param_2 = 0;
    undefined4 uart_param_3 = 0;
    undefined4 uart_param_4 = 0;
    uint send_fifo_space = 0;
    uint send_fifo_available = 0;
    char logMessageBuffer[2048]; // Log message buffer

    // Calculate the mutex address for the specific UART chain
    pUartMutex = (pthread_mutex_t *)(chain_id * 0x18 + UART_SEND_FIFO_SPACE_INFO_ADDR);

    // Lock the UART mutex
    LockMutex(pUartMutex);

    // Attempt to get the UART send address information
    if (GetUartSendAddressInfo(chain_id, &send_fifo_available, &uart_param_2, &uart_param_3, &uart_param_4) == 0) {
        // Try multiple times to check if there is enough space in send FIFO
        int retries = 0x15; // Number of retries
        do {
            // Check the send FIFO space
            SomeFunctionWithParamAndShift(uart_param_2, &send_fifo_space);
            send_fifo_space >>= (send_fifo_available & 0xff);
            send_fifo_space &= 0xff;

            // Exit if send FIFO is full (0xff indicates full FIFO)
            if (send_fifo_space == 0xff) {
                UnlockMutex(pUartMutex);
                return;
            }

            // Log that we are waiting for space to clear
            printf("%s: waiting for FPGA UART%d to clear send FIFO space...\n", gSomeGlobalData, chain_id);

            // Set the value to send and wait
            AnotherFunctionWithParam(send_fifo_space | 0x80000000);
            usleep(3000); // Wait for 3 milliseconds

            retries--;
        } while (retries != 0);

        // If here, there was always not enough send FIFO space
        snprintf(logMessageBuffer, sizeof(logMessageBuffer),
                 "%s: UART%d does not have enough send FIFO space, breaking\n",
                 gSomeGlobalData, chain_id);
    } else {
        // If info could not be retrieved, log the error
        snprintf(logMessageBuffer, sizeof(logMessageBuffer),
                 "GetUartSendAddressInfo error, chain_id = %d\n", chain_id);
    }

    // Log the message (level 0 assumed, adjust as needed)
    PrintFormattedLog(0, logMessageBuffer, 0);

    // Unlock the mutex before exiting
    UnlockMutex(pUartMutex);
}
```