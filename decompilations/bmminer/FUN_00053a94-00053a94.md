```c
#include <pthread.h>

// Global data, possibly representing a lock or shared state
extern pthread_rwlock_t global_rwlock;
extern int global_init_flag;
extern pthread_key_t thread_specific_key;
extern int global_some_value;

// Function prototypes for logging, thread management and locking
void log_error(int level, const char *file, int line, const char *msg, ...);
void *create_thread_data(int, int, int, int);
void delete_thread_data(void *);
int update_thread_data_if_needed(void *, int, int);
int put_mdc_value(int context, int key, int value);
int unlock_rwlock(pthread_rwlock_t *);

// Rename and rewrite the function with more meaningful names and comments
int put_key_value_pair(int key, int value)
{
    // Check if key is null or zero
    if (key == 0) {
        log_error(2,"src/zlog.c",0x1ce,"key is null or 0");
        return -1;
    }
  
    // Check if value is null or zero
    if (value == 0) {
        log_error(2,"src/zlog.c",0x1cf,"value is null or 0");
        return -1;
    }
  
    // Attempt to acquire read lock on the global data
    int lock_result = pthread_rwlock_rdlock(&global_rwlock);
    if (lock_result != 0) {
        log_error(2,"src/zlog.c",0x1d3,"pthread_rwlock_wrlock fail, rc[%d]", lock_result);
        return -1;
    }
  
    // Check if global initialization flag is not set
    if (global_init_flag == 0) {
        log_error(2,"src/zlog.c",0x1d8,"never call zlog_init() or dzlog_init() before");
        goto end;
    }
  
    // Get thread-specific data
    int *thread_data = (int *)pthread_getspecific(thread_specific_key);
    if (thread_data == NULL) {
        thread_data = (int *)create_thread_data(global_some_value, /* other parameters */);
        if (thread_data == NULL) {
            log_error(2,"src/zlog.c",0x1dc,"zlog_thread_new fail");
            goto end;
        }
        
        int set_result = pthread_setspecific(thread_specific_key, thread_data);
        if (set_result != 0) {
            delete_thread_data(thread_data);
            log_error(2,"src/zlog.c",0x1dc,"pthread_setspecific fail, rd[%d]", set_result);
            goto end;
        }
    }
  
    // Check if the thread data needs to be updated and update it if necessary
    if (*thread_data != global_some_value) {
        int update_result = update_thread_data_if_needed(thread_data, /* other parameters */);
        if (update_result != 0) {
            log_error(2,"src/zlog.c",0x1dc,"zlog_thread_resize_msg_buf fail, rd[%d]", update_result);
            goto end;
        }
        
        *thread_data = global_some_value;
    }
  
    // Attempt to put the key-value pair into the context
    int put_result = put_mdc_value(thread_data[1], key, value);
    if (put_result == 0) {
        // Successfully put the key-value pair, now unlock and return success (0)
        return unlock_rwlock(&global_rwlock) == 0 ? 0 : -1;
    }
  
    log_error(2,"src/zlog.c",0x1df,"zlog_mdc_put fail, key[%s], value[%s]",key,value);

end: // Label for common unlock and return error path
    // Unlock the lock before returning the error code
    lock_result = unlock_rwlock(&global_rwlock);
    if (lock_result != 0) {
        log_error(2,"src/zlog.c",0x1ec,"pthread_rwlock_unlock fail, rc=[%d]", lock_result);
    }
    return -1;
}
```