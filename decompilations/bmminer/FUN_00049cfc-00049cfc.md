```c
/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

int writeI2CData(uint32_t i2c_context, int i2c_address, int write_size)
{
  byte dataByte;
  int *i2cBuffer;
  int initializationCheck;
  int writeStatus;
  uint additionalData;
  byte *dataPointer;
  uint32_t combined_message[2];
  int *buffer;
  uint32_t errorMessage;
  uint32_t uStack_814;
  uint32_t uStack_810;
  uint32_t uStack_80c;
  uint32_t local_808;
  uint16_t uStack_804;
  byte local_802;
  
  combined_message[0] = i2c_context;
  buffer = (int *)pthread_mutex_lock((pthread_mutex_t *)&DATA_I2C_MUTEX);
  if (buffer == (int *)0x0) {
    initializationCheck = initializeI2C(DATA_I2C_REGISTER, combined_message, &buffer);
    i2cBuffer = buffer;
    if (initializationCheck == 1) {
      if (write_size != 0) {
        dataPointer = (byte *)(i2c_address - 1);
        do {
          additionalData = i2cBuffer[1];
          dataPointer = dataPointer + 1;
          dataByte = *dataPointer;
          writeStatus = checkDataReady();
          if (writeStatus == 0) {
            free(buffer);
            setErrorMessage("iic_not_ready_4_write");
            logError(0, &errorMessage, 0);
            pthread_mutex_unlock(MUTEX_I2C_LOCK);
            return -2;
          }
          // Send the actual I2C message
          sendI2CMessage(12, (uint)dataByte | (additionalData >> 4) << 20 | *i2cBuffer << 26 | (additionalData & 14) << 15);
        } while ((byte *)(i2c_address + write_size - 1) != dataPointer);
      }
      free(buffer);
      pthread_mutex_unlock(MUTEX_I2C_LOCK);
      return write_size;
    }
    snprintf(errorMessageBuffer, 0x800, "ctx %d not inited\n", combined_message[0]);
    logError(0, &errorMessage, 0);
    pthread_mutex_unlock((pthread_mutex_t *)&DATA_I2C_MUTEX);
    initializationCheck = -2;
  }
  else {
    setErrorMessage("failed_to_i2c_lock");
    logError(0, &errorMessage);
    initializationCheck = -1;
  }
  return initializationCheck;
}

// Helper functions  
void setErrorMessage(char* message) {
    // Omitted: Implementation to populate the error message into the global error structure
}

void logError(uint32_t errorCode, uint32_t* messagePointer, int flag) {
    // Omitted: Implementation to log the error message
}

int initializeI2C(uint32_t registerAddress, uint32_t *combined_message, int *buffer) {
    // Omitted: Implementation of the I2C initialization check
    return 0;
}

int checkDataReady() {
    // Omitted: Implementation to check if I2C data is ready to be written
    return 0;
}

void sendI2CMessage(int commandType, uint32_t message) {
    // Omitted: Implementation to send a message over I2C
}
```
Please note that since the actual implementations of functions `initializeI2C`, `checkDataReady`, and `sendI2CMessage` as well as the error logging function `logError` and error message setup `setErrorMessage` are not included in the original code snippet, these details are omitted and should be provided for a complete understanding and implementation of the code. Additionally, variable names and structures used in the helper functions are illustrative and may need to be adjusted to fit the actual application architecture and data structures.