```c
/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

uint QueryPowerSupplyVersion(void)
{
  undefined4 logBufferPrefix;
  undefined4 additionalLogInfo;
  char powerReadStatus;
  uint errorCode;
  int readAttemptCounter;
  int readSuccess;
  undefined4 i2cDataBuffer;
  undefined2 i2cDataSize;
  uint hardwareVersionLowPart;
  uint hardwareVersionHighPart;
  undefined4 i2cCommandBuffer;
  undefined4 i2cCommandBuffer1;
  undefined4 i2cCommandBuffer2;
  undefined4 i2cCommandBuffer3;
  undefined4 i2cCommandBuffer4;
  undefined2 i2cCommandSize;
  
  if ((PowerSupplyInitializedFlag == 0) && (errorCode = InitializePowerSupply(), (int)errorCode < 0)) {
    snprintf((char *)&logBufferPrefix, 0x800,
             "%s: auto exec bitmain_power_open, but open power failed\n",
             "bitmain_power_version");
    OutputDebugLog(0, &logBufferPrefix, 0);
  }
  else {
    additionalLogInfo = I2CBusAddress;
    logBufferPrefix = DebugFormatString;
    readAttemptCounter = 10;
    do {
      i2cDataBuffer = CONCAT31(i2cDataBuffer._1_3_, 0xff);
      hardwareVersionLowPart = hardwareVersionLowPart & 0xffffff00;
      pthread_mutex_lock((pthread_mutex_t *)&I2CMutex);
      readSuccess = ReadI2CData(additionalLogInfo, &hardwareVersionLowPart, 1, &i2cDataBuffer, 1);
      if (readSuccess == 1) {
        powerReadStatus = (char)i2cDataBuffer;
        pthread_mutex_unlock((pthread_mutex_t *)&I2CMutex);
        if (powerReadStatus == -0x0b) break;
      }
      else {
        snprintf((char *)&logBufferPrefix, 0x800, "%s: iic read is failed\n", logBufferPrefix);
        OutputDebugLog(0, &logBufferPrefix, 0);
        pthread_mutex_unlock((pthread_mutex_t *)&I2CMutex);
      }
      usleep(100000); // Wait for 100ms before the next attempt
      readAttemptCounter--;
    } while (readAttemptCounter != 0);
    
    // Command buffer to request hardware version
    i2cDataBuffer = 0x204aa55;
    hardwareVersionLowPart = 0;
    hardwareVersionHighPart = 0;
    i2cDataSize = 6;
    // Request hardware version from power supply
    readSuccess = ExecuteI2CCommand(additionalLogInfo, &i2cDataBuffer,
                                    6, &hardwareVersionLowPart, 8);
    if (readSuccess == 0) {
      // Lower 16 bits of the version are valid, use them
      errorCode = hardwareVersionHighPart & 0xffff;
      if (errorCode != 0) {
        PowerSupplyHardwareVersion = errorCode;
      }
    }
    else {
      // Failed to get power version, report error
      errorCode = 0x80000300;  // Custom error code for version failure
      memcpy(&logBufferPrefix, "get_power_version_failed", 24); // Error message
      OutputDebugLog(0, &logBufferPrefix, 0);
    }
  }
  return errorCode;
}
```