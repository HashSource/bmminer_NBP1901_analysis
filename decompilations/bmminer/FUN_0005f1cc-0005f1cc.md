```c
void * BufferResizeAndCopy(int *bufferMeta, void *sourceData, uint dataToCopySize, int padToRight, int padCharType, uint outputSize, uint padSize)
{
  void *currentBufferPtr;
  int resizeResult;
  uint additionalSizeNeeded;
  size_t paddingSize;
  size_t effectivePadSize;
  
  // Check if buffer is initialized
  if (*bufferMeta == 0) {
    LogError(2, "src/buf.c", 0x232, "pre-use of buffer_resize fail, so can't convert");
    return (void *)0xffffffff;
  }
  
  currentBufferPtr = (void *)bufferMeta[1]; // Current position in the buffer
  
  // Determine the actual size to pad
  if (padSize == 0 || dataToCopySize < padSize) {
    padSize = dataToCopySize;
  }
  
  // If no specific output size is provided or it is smaller than padSize, use padSize
  if (outputSize == 0 || outputSize <= padSize) {
    paddingSize = 0;
    outputSize = padSize;
  } else {
    paddingSize = outputSize - padSize;
  }
  
  // Check if there's enough room in the buffer for outputSize
  if ((uint)(bufferMeta[2] - (int)currentBufferPtr) < outputSize) {
    additionalSizeNeeded = outputSize - (bufferMeta[2] - (int)currentBufferPtr);
    resizeResult = ResizeBuffer(bufferMeta, additionalSizeNeeded);
    
    if (resizeResult > 0) {
      LogError(2,"src/buf.c",0x250,"conf limit to %ld, can't extend, so output", bufferMeta[5]);
      currentBufferPtr = (void *)bufferMeta[1]; // Reset current buffer pointer
      effectivePadSize = bufferMeta[2] - (int)currentBufferPtr;
      
      if (padToRight == 0) {
        if (paddingSize < effectivePadSize) {
          additionalSizeNeeded = effectivePadSize - paddingSize;
        }
        else {
          additionalSizeNeeded = 0;
          paddingSize = effectivePadSize;
        }
        if (paddingSize != 0) {
          memset(currentBufferPtr, (padCharType == 0) ? 0x20 : 0x30, paddingSize); // Fill padding with spaces (0x20) or zeros (0x30)
          currentBufferPtr = (void *)bufferMeta[1]; // Reset current buffer pointer
        }
        currentBufferPtr = memcpy((void *)((int)currentBufferPtr + paddingSize), sourceData, additionalSizeNeeded);
      }
      else { 
        // If padding to right, pad with spaces after the copied data
        effectivePadSize = effectivePadSize;
        if (padSize < effectivePadSize) {
          memset((void *)((int)currentBufferPtr + padSize), 0x20, effectivePadSize - padSize);
          currentBufferPtr = (void *)bufferMeta[1]; // Reset current buffer pointer
          effectivePadSize = padSize;
        }
        currentBufferPtr = memcpy(currentBufferPtr, sourceData, effectivePadSize);
      }
      
      // Update buffer position and possibly flush if necessary
      bufferMeta[1] += effectivePadSize;
      if (*(char *)(bufferMeta + 7) != '\0') {
        BufferFlush(bufferMeta);
      }
      return (void *)0x1;
    }
    if (resizeResult != 0) {
      LogError(2, "src/buf.c", 0x270, "buffer_resize fail");
      return (void *)0xffffffff;
    }
    currentBufferPtr = (void *)bufferMeta[1]; // Reset current buffer pointer
  }
  
  // If there's no padding to the right, handle padding and copying
  if (padToRight == 0) {
    if (paddingSize != 0) {
      memset(currentBufferPtr, (padCharType == 0) ? 0x20 : 0x30, paddingSize); // Fill padding with spaces (0x20) or zeros (0x30)
      currentBufferPtr = (void *)bufferMeta[1]; // Reset current buffer pointer
    }
    memcpy((void *)((int)currentBufferPtr + paddingSize), sourceData, padSize); // Copy source data after padding
  }
  else {
    // If padding to right, handle padding after copying the data
    if (paddingSize != 0) {
      memset((void *)((int)currentBufferPtr + padSize), 0x20, paddingSize); // Fill padding with spaces only (0x20)
      currentBufferPtr = (void *)bufferMeta[1]; // Reset current buffer pointer
    }
    memcpy(currentBufferPtr, sourceData, padSize); // Copy source data before padding
  }
  
  bufferMeta[1] += outputSize; // Update buffer position
  return (void *)0x0; // Indicate successful operation
}
```