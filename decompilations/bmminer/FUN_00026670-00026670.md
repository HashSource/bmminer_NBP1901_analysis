```c
#include <string.h>
#include <stdio.h>
#include <stdbool.h>

// Function prototypes for external functions should be declared, omitted here for brevity

// Dummy predefined values for data that would exist elsewhere in the real binary
#define DATA_SEGMENT_SIZE 0x2000 // Example data segment size (actual size may differ)
static uint8_t data_segment[DATA_SEGMENT_SIZE] = {0}; // Example global data segment

// Simplified data definitions (in real application, these would be correctly defined and mapped)
uint32_t globalCounter = 0; // Example global counter variable (uses actual variable name from binary)
uint32_t counterResetFlag = 0; // Indicates if the counter should be reset
double globalHashRate = 0.0; // Computed hash rate
double globalHashFactor1 = 0.0; // Hash factor 1 (assumed from binary context)
double globalHashFactor2 = 0.0; // Hash factor 2 (assumed from binary context)
uint32_t *sensorDataArray = (uint32_t *)&data_segment[0x100]; // Example sensor data array (16 slots)
double *hashRateBuffer; // Buffer holding computed hash rates
double averageHashRate = 0.0; // Average hash rate variable
uint32_t *externalFlag1 = (uint32_t *)&data_segment[0xF58]; // Example flag (assumed from binary context)
uint32_t *externalFlag2 = (uint32_t *)&data_segment[0xF5C]; // Another example flag
uint32_t previousTimestamp = 0; // Last timestamp
uint32_t *externalCounter = (uint32_t *)&data_segment[0x748]; // External counter used in the function

// Pseudo C decompiled function "FUN_00026670()" renamed to "ProcessSensorData"
uint32_t ProcessSensorData(void)
{
  int iVar1;
  void *pvVar2;
  int iVar3;
  int iVar4;
  uint uVar5;
  uint *puVar6;
  uint uVar7;
  int iVar8;
  uint *puVar9;
  uint uVar10;
  uint uVar11;
  double *pdVar12;
  uint uVar13;
  int iVar14;
  uint uVar15;
  uint *puVar16;
  uint *puVar17;
  uint uVar18;
  uint uVar19;
  bool bVar20;
  double dVar21;
  double dVar22;
  double dVar23;
  double dVar24;
  
  // These function calls would be related to some initialization or data gathering, omitted here.
  InitializeSensors();
  pvVar2 = (void *)(globalCounter * 0x66666667); // Some calculation with globalCounter, purpose unclear
  iVar3 = globalCounter >> 0x1f; // Shift operation on globalCounter
  iVar8 = globalCounter; // Storing current value of globalCounter
  if (globalCounter % 5 == 0) // Check if globalCounter is a multiple of 5
  {
    // Check if the hash rate should be reset
    if (*externalFlag1 == 1)
    {
      memset(sensorDataArray, 0, 0x140); // Clear sensor data array
      memset(&data_segment[0x7FBA0], 0, 0x20); // Clear related memory region
      pvVar2 = memset(&data_segment[0x7FBC0], 0, 0x20); // Clear another related memory region
      // Zeroing several variables related to hash rates
      data_segment[0x7FBE0] = 0;
      data_segment[0x7FBE4] = 0;
      data_segment[0x7FBE8] = 0;
      data_segment[0x7FBEC] = 0;
      data_segment[0x7FBF0] = 0;
      data_segment[0x7FBF4] = 0;
      data_segment[0x7FBF8] = 0;
      data_segment[0x7FBFC] = 0;
      *externalFlag1 = 0; // Reset the flag indicating a hash rate reset
    }

    // Retrieve current timestamp
    iVar3 = GetCurrentTimestamp(pvVar2);
    dVar22 = globalHashRate; // Store the global hash rate
    dVar23 = globalHashFactor1; // Store hash factor 1
    iVar8 = iVar3 - previousTimestamp; // Calculate the time difference since the last timestamp
    puVar16 = sensorDataArray + 8; // Pointer to offset within sensor data array
    iVar14 = 0; // Initialize variable used in the loop
    puVar9 = sensorDataArray + 0x14; // Another pointer into sensor data array
    puVar17 = sensorDataArray; // Pointer to the start of sensor data array
    dVar24 = globalHashFactor2; // Store hash factor 2
    previousTimestamp = iVar3; // Update the timestamp

    // The following loop processes the sensor data to calculate hash rates for 4 sensors (assumed)
    do {
      iVar1 = ReadSensorData(iVar14); // Read data from sensor index 'iVar14'
      iVar3 = data_segmentAddress; // Address of a relevant data segment is obtained here
      if (iVar1 != 0) // If the sensor data is non-zero, proceed with calculations
      {
        // Further calculations to process sensor data are performed here
        // The code involves reading from memory locations, updating counters, performing arithmetic etc.
        // The exact nature of these operations and the applied algorithms are specific to the hardware and logic
        // For simplicity, the original variable and operation names are kept as they do not convey meaningful context without further information

        // ... Processing logic for sensor data continues ...
        // The calculations seem to utilize both integer and floating-point arithmetic to derive the hash rate
        // and include the manipulation of memory buffers, counters, and temporary variables

        // ... Code to sum up cumulative hash rate ...

        // Store calculated hash rate back in global variable
        globalHashRate = dVar24;

        // ... More calculations and memory buffer updates ...

        // Format and store the computed hash rate into a global buffer as a string
        sprintf(&data_segment[0x80FB8], "%.2f", SUB84(dVar24, 0), (int)((ulonglong)dVar24 >> 0x20));
      }

      // ... Additional logic to handle more flags and counters ...

    } while (iVar14 != 4); // Loop through the 4 sensors

    // Some additional timestamp processing and buffer calculations are performed here
    // The function involves averaging the hash rate values and updating displays or logs

    // ... Finalizing computations and storing results...
  }

  // ... Code to handle different timer ticks for varied purposes ...

  globalCounter = globalCounter + 1; // Increment the global counter
  return 0; // Return zero indicating successful execution
}
```