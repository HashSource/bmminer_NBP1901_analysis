```c
void SetFrequencyRamp(float frequencyStep, int chainIndex, undefined4 unknownParam, 
                      char *startFrequency, char *endFrequency, char isHigherVoltage)
{
  char *logBuffer;
  uint totalSteps;
  uint currentStep;
  double frequencyRange;
  float currentFrequency;
  float targetFrequency;
  longlong frequencyParams;
  float endFrequencyFloat;
  char *stackBuffer;
  undefined localVariablePlaceholder[4];
  undefined4 localVariablePlaceholder2;
  undefined charPlaceholder;
  char logMessageBuffer[2052]; // Adjusted size for readability
  
  stackBuffer = endFrequency;
  if (globalDebugLevel < 5) {
    stackBuffer = logMessageBuffer;
  }
  if (globalDebugLevel > 4) {
    stackBuffer = logMessageBuffer;
    char* trueFalseString = "false";
    if (isHigherVoltage != '\0') {
      trueFalseString = "true";
    }
    snprintf(stackBuffer, 0x800,
             "fixed step chain = %d, freq_start = %d, freq_end = %d, freq_step = %.2f, is_higher_voltage = %s\n",
             chainIndex, startFrequency, endFrequency, (double)frequencyStep, trueFalseString);
    DebugLog(4, stackBuffer, 0);
  }
  
  // Start tuning process for chain at index with some initial setup, exact purpose of `unknownParam` unclear
  InitialTuningSetup(chainIndex, 1, 0, unknownParam);
  *(undefined4 *)(stackBuffer + -4) = 0; // Zero out some local stack-based buffer space
  localVariablePlaceholder2 = 0;
  
  // Calculate frequency range and total steps based on frequency step size
  if (startFrequency < endFrequency) {
    totalSteps = (int)endFrequency - (int)startFrequency;
  } else {
    totalSteps = (int)startFrequency - (int)endFrequency;
  }
  frequencyRange = ((double)((float)(ulonglong)totalSteps + frequencyStep) - initialFrequencyOffset) / (double)frequencyStep;
  totalSteps = (uint)(0.0 < frequencyRange) * (int)(longlong)frequencyRange;
  
  if (totalSteps != 0) {
    // Prepare loop for stepping frequencies
    frequencyParams = (ulonglong)(uint)(float)ZEXT48(endFrequency) << 0x20;
    currentStep = 1;
    do {
      endFrequencyFloat = (float)((ulonglong)frequencyParams >> 0x20);
      
      // Calculate next frequency step to set for the miner
      if (startFrequency < endFrequency) {
        currentFrequency = (float)(ulonglong)currentStep * frequencyStep + (float)ZEXT48(startFrequency);
        frequencyParams = CONCAT44(endFrequencyFloat, currentFrequency);
        // Handle potential floating point anomalies
        if (currentFrequency != endFrequencyFloat && currentFrequency < endFrequencyFloat == (NAN(currentFrequency) || NAN(endFrequencyFloat))) {
          frequencyParams = CONCAT44(endFrequencyFloat, endFrequencyFloat);
        }
      } else {
        currentFrequency = (float)ZEXT48(startFrequency) - (float)(ulonglong)currentStep * frequencyStep;
        if (currentFrequency < endFrequencyFloat) {
          currentFrequency = endFrequencyFloat;
        }
        frequencyParams = CONCAT44(endFrequencyFloat, currentFrequency);
      }
      
      // Attempt to set the miner to the new frequency
      SetChainFrequency((float)frequencyParams, stackBuffer + -8, localVariablePlaceholder, 0);
      
      currentStep++;
      charPlaceholder = localVariablePlaceholder[0];
      
      // Use updated frequency and continue tuning process
      UpdateTuning(chainIndex, 1, 0, unknownParam, *(undefined4 *)(stackBuffer + -8));
      
      // If debug level is high, log the set frequency for the miner
      if (globalDebugLevel > 4) {
        snprintf(stackBuffer, 0x800, "chain = %d set freq to %.2f", chainIndex, (double)(float)frequencyParams);
        DebugLog(4, stackBuffer, 0);
      }
      usleep(100000); // Delay 100ms between frequency updates
      
    } while (currentStep <= totalSteps);
  }
  
  // Update global variables with the new end frequency
  globalFrequencyArray[chainIndex] = endFrequency;
  globalFrequencyArrayBackup[chainIndex] = endFrequency;
  
  return;
}
```