```c
int CalculateIdealHashRate(HashRateCalcData *hashRateData, undefined4 initParam, undefined4 roundNumber) {
  int initStatus;
  int chipIndex;
  int chainIndex;
  int hwErrorCount;
  int *currentChainData;
  uint *freqConfig;
  int hashRateSum;
  uint minFreq = UINT_MAX; // Initialize to maximum uint value
  uint maxFreq = 0;
  int chainHashRate;
  int localIdealHashRateTotal;
  uint idealFreqRange; // Renamed from local_82c
  undefined4 localLogBuffer; // Used for logging, renamed from local_828
  undefined4 logTail; // Variables uStack_824, uStack_820, uStack_81c, local_818
  // used to construct log messages.
  
  // Logging verbosity level check
  if (VERBOSE_LEVEL > 3) {
    localLogBuffer = CONCAT22(localLogBuffer._2_2_, 10);
    LogString(3, &localLogBuffer, 0);
    if (VERBOSE_LEVEL > 3) {
      snprintf((char *)&localLogBuffer, 0x800,">>>> Get ideal hash rate, round %d.\n", roundNumber);
      LogString(3, &localLogBuffer, 0);
    }
  }

  // Initialize hardware and get status
  initStatus = InitializeHardware(initParam);
  if (initStatus == 0) {
    PrepareHardwareForComputation();
    currentChainData = *hashRateData;
    GLOBAL_MIN_HASHRATE = *currentChainData;
    if (currentChainData[4] < GLOBAL_MIN_HASHRATE) {
      *currentChainData = currentChainData[4];
      GLOBAL_MIN_HASHRATE = **hashRateData;
    }
    UpdateHashrateData((float)(longlong)THRSHLD_VOLTAGE, GLOBAL_DAT_004fcb28 + 0xc, DAT_00482a70,
                       *(undefined *)(*(int *)(GLOBAL_DAT_004fcb28 + 8) + 8));
    chainHashRate = GetComputedChainHashRate();
    if ((chainHashRate != GLOBAL_MIN_HASHRATE) && (chainHashRate = CheckForHardwareErrors(GLOBAL_MIN_HASHRATE), chainHashRate != 0)) {
      return chainHashRate;
    }

    // Find minimum frequency among all chips
    chipIndex = 0;
    do {
      hwErrorCount = GetHardwareErrorCount(chipIndex);
      if ((hwErrorCount != 0) && (hwErrorCount = GetRealErrorCount(), hwErrorCount != 0)) {
        freqConfig = (uint *)(GLOBAL_DAT_004fcb28 + chipIndex * 0x400 + 8);
        while (freqConfig++, *freqConfig <= minFreq) {
          minFreq = *freqConfig;
        }
      }
      chipIndex++;
    } while (chipIndex != 4);

    // Log min frequency
    if (VERBOSE_LEVEL > 3) {
      snprintf((char *)&localLogBuffer, 0x800,"chain = %d, freq_min = %d\n", 0xff, minFreq);
      LogString(3, &localLogBuffer, 0);
    }

    // Find maximum frequency among all chips
    chipIndex = 0;
    do {
      hwErrorCount = GetHardwareErrorCount(chipIndex);
      if ((hwErrorCount != 0) && (hwErrorCount = GetRealErrorCount(), hwErrorCount != 0)) {
        freqConfig = (uint *)(GLOBAL_DAT_004fcb28 + chipIndex * 0x400 + 8);
        while (freqConfig++, maxFreq < *freqConfig) {
          maxFreq = *freqConfig;
        }
      }
      chipIndex++;
    } while (chipIndex != 4);

    // Log max frequency
    if (VERBOSE_LEVEL > 3) {
      snprintf((char *)&localLogBuffer, 0x800,"chain = %d, freq_max = %d\n",0xff, maxFreq);
      LogString(3, &localLogBuffer, 0);
    }

    // Configure mining boards/chains with ideal frequency
    chainIndex = 0;
    idealFreqRange = maxFreq;
    ConfigureFrequencyRangeForBoards(minFreq, IDEAL_FREQ_SET_POINT, 0x14);
    while (chainIndex < 4) {
      hwErrorCount = GetHardwareErrorCount(chainIndex);
      if (hwErrorCount != 0) {
        SetChainActive(chainIndex, 1);
      }
      chainIndex++;
    }

    chainIndex = 0;
    CommitConfigurationForChains(&idealFreqRange);
    SetPLLParametersForChains();
    while (chainIndex < 4) {
      hwErrorCount = GetHardwareErrorCount(chainIndex);
      if (hwErrorCount != 0) {
        ApplyChainPllConfig(chainIndex, GetIdealVoltageSetting());
      }
      chainIndex++;
    }

    // Calculate the ideal hash rate for all chains
    chainIndex = 0;
    localIdealHashRateTotal = 0;
    do {
      hwErrorCount = GetHardwareErrorCount(chainIndex);
      if (hwErrorCount != 0) {
        hwErrorCount = GetRealErrorCount();
        if (hwErrorCount != 0) {
          currentChainData = (int *)(GLOBAL_DAT_004fcb28 + chainIndex * 0x400 + 8);
          freqConfig = (uint *)(SOME_OFFSET_DATA + chainIndex * 0x400 + GetIdealVoltageSetting());
          chainHashRate = 0;
          while ((currentChainData++, freqConfig++, currentChainData) != (int *)(GLOBAL_DAT_004fcb28 + 8 + (hwErrorCount + chainIndex * 0x100) * 4)) {
            chainHashRate += (*freqConfig * *currentChainData) / 8000;
          }
          localIdealHashRateTotal += chainHashRate;
        }

        // Store computed hash rate per chain
        *(int *)(GLOBAL_DAT_004fcb28 + (chainIndex + 0x402) * 4 + 4) = chainHashRate;
        if (VERBOSE_LEVEL > 3) {
          snprintf((char *)&localLogBuffer, 0x800, "chain = %d, ideal_hash_rate_GH = %d\n",chainIndex,chainHashRate);
          LogString(3, &localLogBuffer, 0);
        }
      }
      chainIndex++;
    } while (chainIndex != 4);

    // Log total ideal hash rate
    if (VERBOSE_LEVEL > 3) {
      snprintf((char *)&localLogBuffer, 0x800,"hash_rate_total_GH = %d\n", localIdealHashRateTotal);
      LogString(3, &localLogBuffer, 0);
    }
  } else if (VERBOSE_LEVEL > 3) {
    LogString(3, BoardInitFailMessage, 0); // Message stored at `s_Board_init_failed__00067448`
    return initStatus;
  }

  return initStatus;
}
```

Please note that this is an attempt to refactor the decompiled code to make it more readable. The initial decompiled code might already have inaccuracies due to the decompilation process, and this refactoring assumes that the original code's functionality is preserved. Comments were added based on the context and the names of the variables suggest their purpose, but only someone with knowledge of the specific codebase can confirm their accuracy.