```c
void ReadMinerVersion(void)
{
  int operationResult;
  FILE *filePointer;
  size_t readSize;
  char *newlinePosition;
  char *nextLineStart;
  char endChar;
  char endCharNextLine;
  char versionBuffer[256];
  char logBuffer[2052];
  
  // Open the version file
  filePointer = fopen64(minerVersionFilePath,"rb");
  memset(versionBuffer, 0, 0x100); // Clear version buffer
  if (filePointer == NULL) // Failed to open version file
  {
    // Log if enabled and verbosity level is met
    if (((loggingEnabled != false) || (alternativeLoggingEnabled != false)) || (verbosityLevel > 2)) {
      snprintf(logBuffer,0x800,"Open miner version file %s error", minerVersionFilePath);
      Log(3, logBuffer, 0);
    }
  }
  else
  {
    // Read version information from file
    readSize = fread(versionBuffer, 1, 0x100, filePointer);
    if ((int)readSize < 1) // Failed to read version file
    {
      if (((loggingEnabled != false) || (alternativeLoggingEnabled != false)) || (verbosityLevel > 2)) {
        snprintf(logBuffer,0x800,"Read miner version file %s error %d", minerVersionFilePath, readSize);
        Log(3, logBuffer, 0);
      }
    }
    else
    {
      // Extract compile time from the version buffer
      newlinePosition = strchr(versionBuffer, '\n');
      operationResult = someGlobalResult;
      if (newlinePosition == NULL)
      {
        strcpy(globalCompileTimeBuffer, versionBuffer);
      }
      else
      {
        CopyAndLog(globalCompileTimeBuffer, versionBuffer, 
                   (int)newlinePosition - (int)versionBuffer, "bmminer.c",
                   someGlobalResult, 0x5eb);
        newlinePosition++; // Point to start of the next line
        nextLineStart = stpcpy(versionBuffer, newlinePosition);
        newlinePosition = strchr(versionBuffer, '\n'); // Find next newline
        if (newlinePosition == NULL)
        {
          memcpy(globalMinerTypeBuffer, versionBuffer, 
                 (size_t)(nextLineStart - versionBuffer));
        }
        else
        {
          CopyAndLog(globalMinerTypeBuffer, versionBuffer, 
                     (int)newlinePosition - (int)versionBuffer, "bmminer.c", 
                     operationResult, 0x5f4);
        }
      }

      // Remove newlines and carriage returns from compile time
      TrimNewlinesAndCarriage(globalCompileTimeBuffer);
      TrimNewlinesAndCarriage(globalMinerTypeBuffer);
    }
  }
  
  // Open the serial number file
  filePointer = fopen64("/config/sn","rb");
  if (filePointer == NULL) // Failed to open serial number file
  {
    if (((loggingEnabled != false) || (alternativeLoggingEnabled != false)) || (endCharNextLine = '\0', verbosityLevel > 2)) {
      snprintf(logBuffer,0x800,"Open miner serial number file %s error", "/config/sn");
      Log(3, logBuffer, 0);
      endCharNextLine = loggingEnabled;
    }
  }
  else
  {
    memset(versionBuffer, 0, 0x100); // Clear buffer before reading serial number
    readSize = fread(versionBuffer, 1, 0xfa, filePointer);
    if ((int)readSize < 1) // Failed to read serial number file
    {
      if (((loggingEnabled != false) || (alternativeLoggingEnabled != false)) || (verbosityLevel > 2)) {
        snprintf(logBuffer,0x800,"Read miner serial number file %s error %d", "/config/sn", readSize);
        Log(3, logBuffer, 0);
      }
    }
    else
    {
      // Extract serial number from buffer
      ExtractSerialNumber(versionBuffer, globalSerialNumberBuffer, &filePointer);
    }
    fclose(filePointer); // Always close the file after use
    endCharNextLine = loggingEnabled;
  }
  
  // Remove newlines and carriage returns from the serial number
  TrimNewlinesAndCarriage(globalSerialNumberBuffer);
  
  // If logging is enabled, log the version, type, and serial number
  if (((endCharNextLine != false) || (alternativeLoggingEnabled != false)) || (verbosityLevel > 2)) {
    snprintf(logBuffer,0x800,"Miner compile time: %s type: %s sn :%s",
             globalCompileTimeBuffer, globalMinerTypeBuffer, globalSerialNumberBuffer);
    Log(3, logBuffer, 0);
  }
  return;
}

// Helper function to remove newline and carriage return characters from a string
void TrimNewlinesAndCarriage(char *str)
{
  size_t len = strlen(str);
  char charAtEnd = str[len];
  if (charAtEnd == '\n')
  {
    str[len] = '\0';
    len = strlen(str);
    charAtEnd = str[len];
  }
  if (charAtEnd == '\r')
  {
    str[len] = '\0';
  }
}

// Helper function to extract serial number from buffer and copy to a global buffer
void ExtractSerialNumber(char *sourceBuffer, char *destinationBuffer, FILE **filePointer)
{
  char *crlfPosition = strstr(sourceBuffer, "\r\n");
  if (crlfPosition == NULL)
  {
    strcpy(destinationBuffer, sourceBuffer);
  }
  else
  {
    CopyAndLog(destinationBuffer, sourceBuffer, 
               (int)crlfPosition - (int)sourceBuffer, "bmminer.c",
               someGlobalResult, 0x624);
  }
}
```

I've added two helper functions (`TrimNewlinesAndCarriage` and `ExtractSerialNumber`) to organize the code more clearly, renamed variables and function names for better readability, and added comments for documentation. The structure and core functionality of the code are unchanged.