```c
int CheckPicStatus(unsigned int chainIndex)
{
  int status;
  char *errorMsg;
  int errorCode;
  uint32_t i2cBusId;
  uint16_t readData;
  uint32_t magicNumber;
  uint32_t unused1;
  uint32_t unused2;
  uint32_t unused3;
  char logBuffer[2052];
  
  // Check if the chain index is greater than 15 (0xf), which is invalid
  if (chainIndex > 0xf) {
    snprintf(logBuffer, 0x800, "%s: Bad pic param, input chain is %d\n", globalErrorMsgStore, chainIndex);
    LogError(0, logBuffer);
    return -0x7ffffdff; // Return an error code for invalid chain index
  }
  
  // Check if the chain's I2C bus is initialized, attempt to initialize if not
  if ((*(int *)(I2cBusStatusTable + chainIndex * 8) == 0) && ((status = InitializeI2CBus()) < 0)) {
    snprintf(logBuffer, 0x800, "%s: auto exec open_pic, but chain %d open eeprom failed\n",
             globalErrorMsgStore, chainIndex);
    LogError(0, logBuffer, 0);
    return status; // Return the error from initializing I2C bus
  }
  
  // Get the I2C bus ID for the corresponding chain index
  i2cBusId = *(uint32_t *)(I2cBusIdTable + chainIndex * 8);

  // Default error code to be returned if checks fail
  errorCode = 0;
  
  // Lock mutex before communicating with the PIC
  pthread_mutex_lock((pthread_mutex_t *)&PicMutex);
  
  // Set up a magic number and unused variables for I2C communication
  magicNumber = 0x1505aa55;
  unused1 = 0;
  unused3 = 0;
  readData = 0;
  unused2 = 0x1a0000;
  
  // Send a command to the PIC and check the response
  status = SendPicCommand(i2cBusId);
  if (status == 7) {
    usleep(300000); // Wait for 300 milliseconds
    
    // Read data from the PIC and check if the read operation was successful
    status = ReadPicData(i2cBusId, &readData, 2);
    if (status != 2) {
      errorMsg = "%s read iic err\n";
      goto LogErrorAndExit;
    }
    
    // Validate the data read from the PIC
    if (((byte)readData == 0x15) && (readData._1_1_ == 1)) goto CheckPassed;
    
    // Log error if the read data is not as expected
    snprintf(logBuffer, 0x800,
             "%s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
             globalErrorMsgStore, (uint)(byte)readData, (uint)readData._1_1_);
    LogError(0, logBuffer);
  }
  else {
    errorMsg = "%s write iic err\n"; // Set the error message for a failed write operation
LogErrorAndExit:
    snprintf(logBuffer, 0x800, errorMsg);
    LogError(0, logBuffer, 0);
  }
  
  // Set the error code for failed PIC check
  errorCode = -0x7ffffe00;

CheckPassed:
  // Unlock mutex after PIC communication
  pthread_mutex_unlock((pthread_mutex_t *)&PicMutex);
  
  return errorCode; // Return the error code or 0 if check passed
}
```