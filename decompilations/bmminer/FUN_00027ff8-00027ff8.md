```c
/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void CancelMinerThread(void)
{
  pthread_t currentThreadId;
  void *minerThreadData;
  char logMessage[1024]; // Assuming logMessage buffer is 1024 bytes
  pthread_t minerThreadId;
  
  minerThreadData = globalMinerThreadData; // Rename DAT_00080758 to globalMinerThreadData for clarity
  if (globalMinerThreadData != NULL)
  {
    currentThreadId = pthread_self(); // Get the ID of the calling thread
    minerThreadId = *(pthread_t *)((int)minerThreadData + 0xc); // Get the miner thread ID from the data structure 
    if (minerThreadId != currentThreadId) // Check if calling thread is not the miner thread
    {
      if (verbosityLevel > 3) // Rename DAT_0007eb9c to verbosityLevel for clarity
      {
        // Prepare a log message "cancel thread" (assuming the characters form this string)
        memcpy(logMessage, "cancel thread", 13); // Could consider coping the full string using a safer function
        logMessage[13] = '\0'; // Ensure the string is null-terminated
        // Log the message using a function that accepts a verbosity level, message, and an unknown argument (0)
        LogWithVerbosity(3, logMessage, 0); // Rename FUN_0002e584 to LogWithVerbosity for clarity
        // Note: the original log message building could be simplified, but we are asked to keep the structure same
        minerThreadData = globalMinerThreadData; // Refresh pointer in case it was changed by the log function
      }
      // Cancel the thread using some cleanup function (needs proper renaming)
      CleanupThread(minerThreadData); // Rename FUN_0002fe84 to CleanupThread for better readability
      // After cleanup, free the data structure and reset the global pointer
      free(globalMinerThreadData);
      globalMinerThreadData = NULL;
    }
  }
  return;
}
```