```c
void ClearHashTable(void *hashTable)
{
  void *bucketArray;
  uint totalBuckets;
  void *entryPtr;
  uint currentBucketIndex;
  
  // If the hash table pointer is NULL, log an error and exit the function
  if (hashTable == NULL) {
    LogError(2,"src/zc_hashtable.c",0x44,"hashTable[%p] is NULL, just do nothing",0);
    return;
  }

  // Retrieve the bucket array and total number of buckets from the hash table data structure
  bucketArray = *((void **)((int)hashTable + 4));
  totalBuckets = *((uint *)((int)hashTable + 8));
  
  // If there are buckets, iterate over them to free the entries
  if (totalBuckets != 0) {
    currentBucketIndex = 0;
    do {
      // Get the first entry in the current bucket
      entryPtr = *((void **)((int)bucketArray + currentBucketIndex * 4));
      
      // If the entry is present, free it and move to the next
      if (entryPtr != NULL) {
        do {
          bucketArray = *((void **)((int)entryPtr + 0x10)); // Next entry in bucket link
          
          // NULL check to make sure the key destructor function is present before calling it
          if (*((code **)((int)hashTable + 0x14)) != NULL) {
            // Call the key destructor function
            (*((code **)((int)hashTable + 0x14))(*((undefined4 *)((int)entryPtr + 4))));
          }
          
          // NULL check to make sure the value destructor function is present before calling it
          if (*((code **)((int)hashTable + 0x18)) != NULL) {
            // Call the value destructor function
            (*((code **)((int)hashTable + 0x18))(*((undefined4 *)((int)entryPtr + 8))));
          }
          
          // Free the current entry and move to the next
          free(entryPtr);
          entryPtr = bucketArray;
        } while (bucketArray != NULL); // Continue until the end of the bucket's list
        
        // Re-fetch bucket list and total count in case they are updated during iteration
        bucketArray = *((void **)((int)hashTable + 4));
        totalBuckets = *((uint *)((int)hashTable + 8));
      }
      // Move to the next bucket
      currentBucketIndex ++;
    } while (currentBucketIndex < totalBuckets); // Continue until all buckets are processed
  }
  
  // If there is a bucket array, free it
  if (bucketArray != NULL) {
    free(bucketArray);
  }
  
  // Free the hash table itself
  free(hashTable);
  return;
}
```