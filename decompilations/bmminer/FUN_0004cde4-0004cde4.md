```c
int ParseJsonValue(int parserPtr, uint options, undefined4 errorCode)
{
  bool success;
  void *keyPtr;
  int valueResult;
  uint depth;
  int currentElementType;
  int *refCounterPtr;
  void *newKeyPtr;
  size_t keyLength;
  
  depth = *(int *)(parserPtr + 0x38) + 1;
  *(uint *)(parserPtr + 0x38) = depth;
  // Check if maximum parsing depth has been reached
  if (0x800 < depth) {
    ReportError(errorCode, parserPtr, 2, "maximum parsing depth reached");
    return 0;
  }
  currentElementType = *(int *)(parserPtr + 0x3c);
  // Switch depending on the current element type
  if (currentElementType == JSON_STRING) {
    valueResult = ParseString(*(undefined4 *)(parserPtr + 0x40), *(undefined4 *)(parserPtr + 0x44));
  }
  else if (currentElementType < JSON_OBJECT) {
    if (currentElementType == JSON_ARRAY) {
      valueResult = BeginArray();
      if (valueResult == 0) {
        return 0;
      }
      ReadNextToken(parserPtr, errorCode);
      currentElementType = *(int *)(parserPtr + 0x3c);
      if (currentElementType != JSON_ARRAY_END) {
        while (currentElementType != 0) {
          currentElementType = ParseJsonValue(parserPtr, options, errorCode);
          if ((currentElementType == 0) || (currentElementType = AddArrayElement(valueResult), currentElementType != 0)) goto ErrorHandling;
          ReadNextToken(parserPtr, errorCode);
          if (*(int *)(parserPtr + 0x3c) != JSON_COMMA) {
            if (*(int *)(parserPtr + 0x3c) == JSON_ARRAY_END) goto ArrayEndReached;
            break;
          }
          ReadNextToken(parserPtr, errorCode);
          currentElementType = *(int *)(parserPtr + 0x3c);
        }
        ReportError(errorCode, parserPtr, 8, "']' expected");
ErrorHandling:
        if (*(int *)(valueResult + 4) == -1) {
          return 0;
        }
        refCounterPtr = (int *)(valueResult + 4);
        DataMemoryBarrier(0xb);
        do {
          currentElementType = *refCounterPtr + -1;
          success = (bool)hasExclusiveAccess(refCounterPtr);
        } while (!success);
        *refCounterPtr = currentElementType;
DecrementRefCounter:
        if (currentElementType == 0) {
          FreeArray(valueResult);
          return 0;
        }
        return 0;
      }
      goto ArrayEndReached;
    }
    if (currentElementType < JSON_ARRAY) {
      if (currentElementType == JSON_UNDEFINED) {
        ReportError(errorCode, parserPtr, 8, "invalid token");
        return 0;
      }
      goto UnexpectedToken;
    }
    if (currentElementType == JSON_OBJECT) {
      valueResult = BeginObject();
      if (valueResult == 0) {
        return 0;
      }
      ReadNextToken(parserPtr, errorCode);
      if (*(int *)(parserPtr + 0x3c) != JSON_OBJECT_END) {
        if (*(int *)(parserPtr + 0x3c) == JSON_STRING) {
          newKeyPtr = *(void **)(parserPtr + 0x40);
          keyLength = *(size_t *)(parserPtr + 0x44);
          *(undefined4 *)(parserPtr + 0x40) = 0;
          *(undefined4 *)(parserPtr + 0x44) = 0;
          if (newKeyPtr == NULL) {
            return 0;
          }
          while(true) {
            keyPtr = memchr(newKeyPtr, 0, keyLength);
            if (keyPtr != NULL) {
              FreeMemory(newKeyPtr);
              ReportError(errorCode, parserPtr, 0xd, "NUL byte in object key not supported");
              goto ObjectKeyError;
            }
            if (((options & ALLOW_DUPLICATE_KEYS) != 0) && (valueResult = CheckForDuplicateKey(valueResult, newKeyPtr), valueResult != 0)) {
              FreeMemory(newKeyPtr);
              ReportError(errorCode, parserPtr, 0xe, "duplicate object key");
              goto ObjectKeyError;
            }
            ReadNextToken(parserPtr, errorCode);
            if (*(int *)(parserPtr + 0x3c) != JSON_COLON) {
              FreeMemory(newKeyPtr, errorCode);
              ReportError(errorCode, parserPtr, 8, "':' expected");
              goto ObjectKeyError;
            }
            ReadNextToken(parserPtr);
            currentElementType = ParseJsonValue(parserPtr, options, errorCode);
            if (currentElementType == 0) {
              FreeMemory(newKeyPtr, newKeyPtr);
              goto ObjectKeyError;
            }
            valueResult = AddObjectKey(valueResult);
            if (valueResult != 0) {
              FreeMemory(newKeyPtr);
              goto ObjectKeyError;
            }
            FreeMemory(newKeyPtr);
            ReadNextToken(parserPtr, errorCode);
            if (*(int *)(parserPtr + 0x3c) != JSON_COMMA) break;
            ReadNextToken(parserPtr, errorCode);
            if (*(int *)(parserPtr + 0x3c) != JSON_STRING) goto UnexpectedStringOrEndOfObject;
            newKeyPtr = *(void **)(parserPtr + 0x40);
            keyLength = *(size_t *)(parserPtr + 0x44);
            *(undefined4 *)(parserPtr + 0x40) = 0;
            *(undefined4 *)(parserPtr + 0x44) = 0;
            if (newKeyPtr == NULL) {
              return 0;
            }
          }
          if (*(int *)(parserPtr + 0x3c) == JSON_OBJECT_END) goto ArrayEndReached;
          ReportError(errorCode, parserPtr, 8, "'}' expected");
        }
        else {
UnexpectedStringOrEndOfObject:
          ReportError(errorCode, parserPtr, 8, "string or '}' expected");
        }
ObjectKeyError:
        if (*(int *)(valueResult + 4) == -1) {
          return 0;
        }
        refCounterPtr = (int *)(valueResult + 4);
        DataMemoryBarrier(0xb);
        do {
          currentElementType = *refCounterPtr + -1;
          success = (bool)hasExclusiveAccess(refCounterPtr);
        } while (!success);
        *refCounterPtr = currentElementType;
        goto DecrementRefCounter;
      }
      goto ArrayEndReached;
    }
    if (currentElementType != JSON_STRING_RAW) goto UnexpectedToken;
    newKeyPtr = *(void **)(parserPtr + 0x40);
    keyLength = *(size_t *)(parserPtr + 0x44);
    // Validate the absence of NUL bytes if option not set
    if (((options & JSON_ALLOW_NUL) == 0) && (keyPtr = memchr(newKeyPtr, 0, keyLength), keyPtr != NULL)) {
      ReportError(errorCode, parserPtr, 0xb, "\\u0000 is not allowed without JSON_ALLOW_NUL");
      return 0;
    }
    valueResult = ParseRawString(newKeyPtr, keyLength);
    *(undefined4 *)(parserPtr + 0x40) = 0;
    *(undefined4 *)(parserPtr + 0x44) = 0;
  }
  else if (currentElementType == JSON_TRUE) {
    valueResult = ParseTrue();
  }
  else if (currentElementType < JSON_TRUE) {
    valueResult = ParseNumber((int)*(undefined8 *)(parserPtr + 0x40));
  }
  else if (currentElementType == JSON_FALSE) {
    valueResult = ParseFalse();
  }
  else {
    if (currentElementType != JSON_NULL) goto UnexpectedToken;
    valueResult = ParseNull();
  }
  if (valueResult == 0) {
    return 0;
  }
ArrayEndReached:
  // Decrement depth as we return from parsing a container
  *(int *)(parserPtr + 0x38) = *(int *)(parserPtr + 0x38) - 1;
  return valueResult;

UnexpectedToken:
  ReportError(errorCode, parserPtr, 8, "unexpected token");
  return 0;
}
```

To make the code more understandable, I have renamed the functions, variables, and symbolic constants to reflect their purpose based on the context. For example, `FUN_0004eb48` might have been renamed to `ParseTrue`, and `*piVar6` to `*refCounterPtr`, assuming that the decompiled code is parsing JSON and the numeric constants correspond to token types like strings, booleans etc. Iâ€™ve added comments as well to explain the logic and connect it to familiar JSON parsing patterns. Note that without more context or the original source, I've made educated guesses for some names and thus the names might not accurately reflect their original intent.