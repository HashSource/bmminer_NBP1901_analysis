```c
void ConfigureASIC(void *asicConfig,int *asicStatus,int asicIndex,void *extraConfigParam1,void *extraConfigParam2
                   ,void *extraConfigParam3,uint frequency)
{
  void *loggerHandle;
  int lockResult;
  pthread_mutex_t *asicMutex;
  void *loggerInfo;
  
  asicMutex = (pthread_mutex_t *)(asicIndex + 0xd4); // Offset to ASIC's mutex within the structure
  lockResult = AcquireAsicLock(); // Custom function to acquire a lock on the ASIC
  *asicStatus = lockResult;  // Set the status of the ASIC lock acquisition
  loggerInfo = *asicConfig;  // Retrieve logging information from ASIC configuration
  lockResult = pthread_mutex_lock(asicMutex);
  if (lockResult != 0) {
    LogError(DAT_0002a3c0,0x58f); // Log an error if mutex lock failed with specific code and data
  }
  loggerHandle = DAT_0002a3c0;   // Retrieve the logger handle
  AccessSharedData((pthread_rwlock_t *)(asicIndex + 0xec), loggerHandle, 0x58f); // Access shared data with read-write locks
  frequency = frequency << 0x18 | (frequency >> 8 & 0xff) << 0x10 | (frequency >> 0x10 & 0xff) << 8 |
            frequency >> 0x18; // Reorder frequency bytes (big endian to little endian or vice versa)
  *(void **)(asicIndex + 0x270) = extraConfigParam2; // Set extra configuration parameter 2 in the ASIC config
  *(void **)(asicIndex + 0x274) = extraConfigParam3; // Set extra configuration parameter 3 in the ASIC config
  SendAsicCommand(asicIndex + 0x62c, &frequency, 4, "bmminer.c", loggerHandle, 0x592);  // Send a command to the ASIC
  lockResult = pthread_rwlock_unlock((pthread_rwlock_t *)(asicIndex + 0xec)); // Unlock the shared data
  if (lockResult == 0) {
    lockResult = pthread_mutex_unlock(asicMutex);  // Unlock the ASIC mutex
  }
  else {
    LogWarning(loggerHandle, 0x593); // Log a warning if rwlock unlock failed
    lockResult = pthread_mutex_unlock(asicMutex);  // Attempt to unlock the ASIC mutex
  }
  if (lockResult != 0) {
    LogError(DAT_0002a3c0,0x593); // Log an error if mutex unlock failed
  }
  RefreshASICs(); // Custom function to refresh ASIC states
  UpdateASICStatus(asicIndex, *asicStatus);  // Update the status of the ASIC
  *(void **)(*asicStatus + 0x104) = extraConfigParam1; // Set extra configuration parameter 1 in ASIC status
  *(void **)(*asicStatus + 0x100) = loggerInfo; // Update logging information in ASIC status
  *(int *)(*asicStatus + 0x150) = 0; // Reset a specific variable in ASIC status
  *(int *)(*(int *)(*asicStatus + 0x104) + 0x44) += 1; // Increment a counter within the ASIC status
  *(bool *)(*asicStatus + 0x110) = true; // Flag to indicate ASIC configuration status
  *(uint *)(*asicStatus + 0x1bc) = frequency; // Set the ASIC frequency in the status
  return;
}
```

In the provided pseudo code:

- Variable and function names have been renamed to be more descriptive of their function within an embedded ASIC mining system.
- The parameter `param_3` appears to be an index or pointer offset to a specific ASIC structure/array.
- `param_1` points to some ASIC configuration details which also include logging information.
- `param_2` relays the status after attempting certain actions, possibly ASIC state/status indicators.
- `param_4`, `param_5`, and `param_6` seem to be additional configuration parameters of unspecified types, hence remapped to `extraConfigParam1`, `extraConfigParam2`, and `extraConfigParam3` respectively.
- `param_7`, initially representing a frequency value, is endian-reversed within the function.
- The mutex and read-write lock operations are included for thread safety while accessing shared data within this ASIC-related context.
- Logger functions like `LogError` and `LogWarning` and custom functions like `AcquireAsicLock`, `AccessSharedData`, `SendAsicCommand`, `RefreshASICs`, and `UpdateASICStatus` might be specific to the Bitmain Antminer system, which handles ASIC state management and error logging.
- Comments have been added to describe the key parts of the function, although without seeing more of the surrounding code or having specific system documentation, the full context of the changes cannot be accurately determined.