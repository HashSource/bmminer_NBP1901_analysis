```c
void * writeFormattedNumberToBuffer(int *bufferInfo, undefined4 unusedParam, uint number, int highOrderBits, uint paddingLength)
{
  void *currentPosition;
  int resizeResult;
  uint numberLength;
  char digit;
  size_t paddingAmount;
  undefined4 highOrderBitsCopy;
  char *numberStartPointer;
  char *tempPointer;
  uint actualPadding;
  size_t actualPaddingLength;
  uint totalLength;
  longlong combinedNumberAndHighOrderBits;
  char numberAsStringBuffer[9];
  
  combinedNumberAndHighOrderBits = CONCAT44(highOrderBits,number);
  
  if (*bufferInfo == 0) {
    logError(2,"src/buf.c",0x156,"pre-use of zlog_buf_resize fail, so can't convert");
    return (void *)0xffffffff;
  }

  tempPointer = numberAsStringBuffer + 1;
  numberStartPointer = tempPointer;

  if ((highOrderBits != 0 || 0xfffffffe < number) && (highOrderBits != 0 || number != 0xffffffff)) {
    do {
      highOrderBitsCopy = (undefined4)((ulonglong)combinedNumberAndHighOrderBits >> 0x20);
      digit = '\n';
      divideNumberBy10((int)combinedNumberAndHighOrderBits, highOrderBitsCopy, 10, 0);
      numberStartPointer = numberStartPointer - 1;
      *numberStartPointer = digit + '0';
      combinedNumberAndHighOrderBits = divideNumberBy10((int)combinedNumberAndHighOrderBits, highOrderBitsCopy, 10, 0);
    } while (combinedNumberAndHighOrderBits != 0);
  }
  else {
    do {
      uint quotient = number / 10;
      numberStartPointer = numberStartPointer - 1;
      *numberStartPointer = (char)(number % 10) + '0';
      number = quotient;
    } while (quotient != 0);
  }

  numberLength = (int)tempPointer - (int)numberStartPointer;
  currentPosition = (void *)bufferInfo[1];
  uint bufferUsedLength = bufferInfo[2];

  if (numberLength < paddingLength) {
    totalLength = (int)currentPosition + paddingLength;
    paddingAmount = paddingLength - numberLength;
    if (bufferUsedLength < totalLength) goto LAB_0005ee24;
  }
  else {
    totalLength = (int)currentPosition + numberLength;
    if (totalLength <= bufferUsedLength) {
      paddingAmount = 0;
      goto LAB_0005eda4;
    }
    paddingAmount = 0;
    paddingLength = numberLength;
LAB_0005ee24:
    resizeResult = expandBufferIfNeeded(bufferInfo, paddingLength - (bufferUsedLength - (int)currentPosition));
    if (0 < resizeResult) {
      logError(2,"src/buf.c",0x189,"conf limit to %ld, can't extend, so output",bufferInfo[5]);
      currentPosition = (void *)bufferInfo[1];
      bufferUsedLength = bufferInfo[2] - (int)currentPosition;
      actualPaddingLength = bufferUsedLength < paddingAmount ? bufferUsedLength - paddingAmount : 0;
      actualPadding = bufferUsedLength;

      if (paddingAmount != 0) {
        memset(currentPosition, 0x30, paddingAmount);
        currentPosition = (void *)bufferInfo[1];
      }

      currentPosition = memcpy((void *)((int)currentPosition + paddingAmount), numberStartPointer, actualPaddingLength);

      if (*(char *)(bufferInfo + 7) == '\0') {
        currentPosition = (void *)0x1;
      }
      
      bufferInfo[1] = bufferInfo[1] + bufferUsedLength;
      
      if (*(char *)(bufferInfo + 7) == '\0') {
        return currentPosition;
      }
      
      flushBuffer(bufferInfo);
      return (void *)0x1;
    }
    
    if (resizeResult != 0) {
      logError(2,"src/buf.c",0x199,"zlog_buf_resize fail");
      return (void *)0xffffffff;
    }
    
    currentPosition = (void *)bufferInfo[1];
    totalLength = (int)currentPosition + paddingLength;
  }

  if (paddingAmount != 0) {
    memset(currentPosition, 0x30, paddingAmount);
    currentPosition = (void *)bufferInfo[1];
  }
  
LAB_0005eda4:
  memcpy((void *)((int)currentPosition + paddingAmount), numberStartPointer, numberLength);
  bufferInfo[1] = totalLength;
  
  return (void *)0x0;
}
```