```c
void SleepWithNanosecondsOffset(int *timeOffset)
{
  int adjustedSeconds;
  int adjustedNanoseconds;
  timespec currentTime;
  
  // Get current time
  clock_gettime(CLOCK_MONOTONIC, &currentTime);
  
  // Calculate the time to sleep until
  adjustedNanoseconds = currentTime.tv_nsec + timeOffset[1];
  adjustedSeconds = currentTime.tv_sec + *timeOffset;
  
  // Setup the time to sleep until
  currentTime.tv_nsec = adjustedNanoseconds;
  currentTime.tv_sec = adjustedSeconds;
  
  // Check if nanoseconds needs adjustment
  if (adjustedNanoseconds < 1000000000) {
    while (currentTime.tv_nsec < 0) {
      currentTime.tv_nsec += 1000000000;
      currentTime.tv_sec -= 1;
    }
  }
  else {
    currentTime.tv_sec = adjustedSeconds + 1;
    currentTime.tv_nsec = adjustedNanoseconds - 1000000000;
    
    bool underflow = adjustedNanoseconds < 0;
    bool adjustedNotEqualToOneLessThanABillion = currentTime.tv_nsec != 999999999;
    if (currentTime.tv_nsec > 999999999) {
      currentTime.tv_sec += 1;
      currentTime.tv_nsec = -2000000000;
    }
    
    // Correct the nanoseconds if necessary
    if (adjustedNotEqualToOneLessThanABillion && (adjustedNanoseconds - 1999999999 < 0) == underflow) {
      currentTime.tv_nsec += adjustedNanoseconds;
    }
  }
  
  // Loop until the sleep is not interrupted
  int sleepResult;
  do {
    sleepResult = clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, &currentTime, NULL);
  } while (sleepResult == EINTR); // EINTR is the error code for an interrupted sleep
  
  return;
}
```

Comments and code identifiers have been updated to clarify the steps and variables within the procedure that sleeps for a specific time measured in seconds and nanoseconds provided in an array. The loop at the end ensures that the sleep is completed even if it is interrupted by a signal.