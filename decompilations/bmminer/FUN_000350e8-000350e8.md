```c
#include <unistd.h>
#include <stdio.h>
#include <string.h>

#define MAX_LOG_MESSAGE_SIZE 2048

// Initial variable for comparison with the change in voltage, used for hysteresis
static unsigned char temperatureThreshold = 0xff;

// Number of consecutive measurements where voltage needed modification
static int voltageAdjustmentCount = 0;

// Last known good voltage level for comparison
static int lastKnownGoodVoltage = 0;

// Flag indicating if compensation has been applied at least once
static int hasCompensationBeenApplied = 0;

// Current temperature threshold level to trigger actions
static int currentTemperatureThreshold = 0;

// Current operational temperature threshold
static short operationalTemperatureThreshold = 0;

// Get the most recent temperature reading
unsigned short getTemperature(void);

// Adjust the voltage level to the miner hardware
void adjustVoltage(int newVoltage);

// Get the current voltage level from the miner hardware
int getCurrentVoltage(void);

// Log a message with a specific debug level
void logMessage(int debugLevel, char *message, int unused);

// Get the hardware model of the miner
const char* getHardwareModel(void);

// Main function responsible for managing voltage based on temperature
unsigned int ManageVoltageBasedOnTemperature(void) {
  short temperatureDelta;
  short currentTemperature;
  unsigned short temperatureReading;
  int currentVoltage;
  int newVoltage;
  char logMessageBuffer[MAX_LOG_MESSAGE_SIZE];

  // Get the current temperature
  temperatureReading = getTemperature();
  currentTemperature = temperatureReading - 10;  // Apply offset to the raw temperature value
  temperatureDelta = currentTemperature;

  // Update temperatureThreshold and reset voltageAdjustmentCount if conditions are met
  if (temperatureThreshold == 0xff || temperatureThreshold - currentTemperature < 6) {
    temperatureThreshold = temperatureDelta;
    voltageAdjustmentCount = 0;
  } else {
    voltageAdjustmentCount++;
  }

  // If there hasn't been a temperature threshold set, exit early
  if (currentTemperatureThreshold < 1) {
    return 0;
  }

  // If compensation has already been applied once, exit early
  if (hasCompensationBeenApplied == 1) {
    return 0;
  }

  // If the temperature is low or voltage was recently adjusted, calculate the voltage compensation
  if (currentTemperature < 20 || (voltageAdjustmentCount > 1 && temperatureReading - 21 < 9)) {
    // Calculate the new voltage
    currentVoltage = getCurrentVoltage();
    newVoltage = 100; // Start with a default compensation value

    int voltageCompensation = (20 - currentTemperature) * 100;
    if (voltageCompensation < 4000) {
      newVoltage = voltageCompensation / 40;
    }

    if (operationalTemperatureThreshold > 4) {
      int absoluteVoltageDifference = (currentVoltage - lastKnownGoodVoltage) + newVoltage;
      if (absoluteVoltageDifference < 0) {
        absoluteVoltageDifference = -absoluteVoltageDifference;
      }
      snprintf(logMessageBuffer, MAX_LOG_MESSAGE_SIZE,
               "curr_vol = %d, g_voltage = %d, compensate_voltage = %d, abs = %d",
               currentVoltage, lastKnownGoodVoltage, newVoltage, absoluteVoltageDifference);
      logMessage(4, logMessageBuffer, 0);
    }

    int targetVoltage = newVoltage + lastKnownGoodVoltage;
    int voltageDifference = currentVoltage - targetVoltage;
    if (voltageDifference < 0) {
      voltageDifference = -voltageDifference;
    }

    // If the voltage difference is small enough, no action is needed, exit early
    if (voltageDifference < 20) {
      temperatureThreshold = currentTemperature;
      return 0;
    }

    // Incrementally adjust voltage up to the target value
    newVoltage = currentVoltage + 49;
    if (newVoltage < targetVoltage) {
      do {
        int actualVoltage = getCurrentVoltage();
        int targetVoltageWithMargin = newVoltage + 20;
        if (actualVoltage <= newVoltage) {
          targetVoltage = newVoltage + lastKnownGoodVoltage;
          break;
        }
        currentVoltage += 20;
        adjustVoltage(currentVoltage);
        usleep(200000); // Delay for adjustments to take effect
        targetVoltage = newVoltage + lastKnownGoodVoltage;
        newVoltage = targetVoltageWithMargin;
      } while (targetVoltageWithMargin < targetVoltage);
    }
    
    // If we've met our target voltage, exit early
    if (currentVoltage == targetVoltage) {
      temperatureThreshold = currentTemperature;
      return 0;
    }
  } 
  else if (temperatureReading - 30 < 22) {
    // Adjust voltage downwards in case the temperature exceeds higher thresholds
    newVoltage = getCurrentVoltage();
    if (lastKnownGoodVoltage < newVoltage - 19) {
      do {
        newVoltage -= 20;
        adjustVoltage(newVoltage);
        usleep(200000); // Delay for adjustments to take effect
        currentVoltage = newVoltage - 23;
      } while (lastKnownGoodVoltage < currentVoltage);
    }

    targetVoltage = lastKnownGoodVoltage;
    // If we've achieved the target voltage, exit early
    if (lastKnownGoodVoltage == newVoltage) {
      temperatureThreshold = currentTemperature;
      return 0;
    }
  }
  else {
    // Check for specific miner hardware models that affect voltage adjustment behavior
    const char* hardwareModel = getHardwareModel();
    int hardwareModelComparisonResult = strcmp(hardwareModel, "NBS1902L");
    if (hardwareModelComparisonResult != 0) {
      currentTemperature += 10;
    }

    // Action is not needed if temperature is within an acceptable range
    if (currentTemperature < 50) {
      temperatureThreshold = currentTemperature;
      return 0;
    }

    // Get the voltage we want to reach
    newVoltage = getCurrentVoltage();
    targetVoltage = lastKnownGoodVoltage - 20;

    // If our current voltage is already at the target, exit early
    if (targetVoltage == newVoltage) {
      temperatureThreshold = currentTemperature;
      return 0;
    }
  }

  // Finally, adjust the voltage to the desired level and update the temperature threshold
  adjustVoltage(targetVoltage);
  temperatureThreshold = currentTemperature;
  return 0;
}
```