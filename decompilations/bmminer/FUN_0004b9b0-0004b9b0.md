```c
// Function to insert or update an entry in a hashmap with string keys and uint values
uint32_t InsertOrUpdateEntry(uint32_t *hashMap, char *key, uint32_t *value)
{
    bool entryUpdated;
    uint32_t **entry;
    size_t keyLength;
    uint32_t *hashedKey;
    int32_t newEntryIndex;
    int32_t oldValueIndex;
    uint32_t **tempEntry;
    uint32_t **currentEntry;
    uint32_t **nextEntry;
    int *valueRefCount;
    uint32_t numEntries;
    uint32_t **firstFreeSlot;
    
    numEntries = hashMap[2];
    if (*hashMap >> (numEntries & 0xff) == 0) {
        entry = (uint32_t **)hashMap[1];
        numEntries = ~(-1 << (numEntries & 0xff));
    }
    else {
        numEntries = numEntries + 1;
        newEntryIndex = 8 << (numEntries & 0xff);
        entry = (uint32_t **)AllocateMemory(newEntryIndex); // Replace with actual memory allocation function
        if (entry == NULL) {
            return -1; // Allocation failed
        }
        FreeMemory(hashMap[1]); // Replace with actual memory free function
        hashMap[1] = (uint32_t)entry;
        hashMap[2] = numEntries;
        firstFreeSlot = (uint32_t **)(hashMap + 3);
        
        // Initialize memory if needed
        if (1 << (numEntries & 0xff) != 0) {
            currentEntry = entry;
            do {
                currentEntry[1] = (uint32_t *)firstFreeSlot;
                tempEntry = currentEntry + 2;
                *currentEntry = (uint32_t *)firstFreeSlot;
                currentEntry = tempEntry;
            } while ((uint32_t **)(newEntryIndex + (int32_t)entry) != tempEntry);
        }

        // Rehash existing entries
        currentEntry = (uint32_t **)hashMap[4];
        hashMap[3] = (uint32_t)firstFreeSlot;
        numEntries = ~(-1 << (numEntries & 0xff));
        hashMap[4] = (uint32_t)firstFreeSlot;
        if (currentEntry != firstFreeSlot) {
            // Rehashing loop
            do {
                nextEntry = (uint32_t **)currentEntry[1];
                entry = (uint32_t **)entry[((uint32_t)currentEntry[4] & numEntries) * 2];
                tempEntry = entry + ((uint32_t)currentEntry[4] & numEntries) * 2;

                // Either relocate the entry, or place it in its new position
                if (entry == firstFreeSlot && firstFreeSlot == (uint32_t **)tempEntry[1]) {
                    hashedKey = (uint32_t *)hashMap[3];
                    currentEntry[1] = (uint32_t *)firstFreeSlot;
                    *currentEntry = hashedKey;
                    *(uint32_t ***)(hashMap[3] + 4) = currentEntry;
                    hashMap[3] = (uint32_t)currentEntry;
                    tempEntry[1] = (uint32_t *)currentEntry;
                    *tempEntry = (uint32_t *)currentEntry;
                    currentEntry = nextEntry;
                    if (nextEntry == firstFreeSlot) goto HandleInsertion;
                }
                else {
                    hashedKey = *entry;
                    currentEntry[1] = (uint32_t *)entry;
                    *currentEntry = hashedKey;
                    (*entry)[1] = (uint32_t)currentEntry;
                    *entry = (uint32_t *)currentEntry;
                    *tempEntry = (uint32_t *)currentEntry;
                    currentEntry = nextEntry;
                }
            } while (nextEntry != firstFreeSlot);
HandleInsertion:
            entry = (uint32_t **)hashMap[1];
            numEntries = ~(-1 << (hashMap[2] & 0xff));
        }
    }

    // Get hashed key for the given key string
    keyLength = strlen(key);
    hashedKey = (uint32_t *)HashString(key, keyLength, ConstantGlobalHashSeed); // Replace with seed variable
    entry = entry + (numEntries & (uint32_t)hashedKey) * 2;
    newEntryIndex = FindEntry(hashMap, entry, key, hashedKey); // Replace with hash lookup function

    // If entry already exists, update its value
    if (newEntryIndex != 0) {
        oldValueIndex = *(int32_t *)(newEntryIndex + 0x14);
        if ((oldValueIndex != 0) && (*(int32_t *)(oldValueIndex + 4) != -1)) {
            valueRefCount = (int *)(oldValueIndex + 4);
            DataMemoryBarrier(0xb);
            do {
                oldValueIndex = *valueRefCount;
                entryUpdated = hasExclusiveAccess(valueRefCount); // Replace with actual atomic locking function
            } while (!entryUpdated);
            *valueRefCount = oldValueIndex - 1;
            if (oldValueIndex - 1 == 0) {
                ReleaseValue(); // Replace with actual release function
            }
        }
        *(uint32_t **)(newEntryIndex + 0x14) = value;
        return 0;
    }

    // Insert new entry
    tempEntry = (uint32_t **)AllocateMemory(keyLength + 0x19); // Allocate space for new entry
    if (tempEntry == NULL) {
        return -1; // Allocation failed
    }

    tempEntry[4] = hashedKey;
    strncpy((char *)(tempEntry + 6), key, keyLength + 1); // Copy key string to new entry
    tempEntry[5] = value; // Assign value to new entry
    currentEntry = (uint32_t **) * entry;
    nextEntry = tempEntry + 2;

    // Prepare new entry for insertion
    tempEntry[1] = (uint32_t *)tempEntry;
    *tempEntry = (uint32_t *)tempEntry;
    tempEntry[3] = (uint32_t *)nextEntry;
    tempEntry[2] = (uint32_t *)nextEntry;

    // Insert new entry into hashmap
    if (currentEntry == (uint32_t **)(hashMap + 3) && currentEntry == (uint32_t **)entry[1]) {
        *tempEntry = (uint32_t *)hashMap[3];
        tempEntry[1] = (uint32_t *)currentEntry;
        *(uint32_t ***)(hashMap[3] + 4) = tempEntry;
        hashMap[3] = (uint32_t)tempEntry;
        entry[1] = (uint32_t *)tempEntry;
        *entry = (uint32_t *)tempEntry;
    }
    else {
        *tempEntry = *currentEntry;
        tempEntry[1] = (uint32_t *)currentEntry;
        (*currentEntry)[1] = (uint32_t)tempEntry;
        *currentEntry = (uint32_t *)tempEntry;
        *entry = (uint32_t *)tempEntry;
    }

    // Maintain linked list of entries
    hashedKey = (uint32_t *)hashMap[5];
    numEntries = *hashMap;
    tempEntry[3] = hashMap + 5;
    tempEntry[2] = hashedKey;
    *(uint32_t ***)(hashMap[5] + 4) = nextEntry;
    hashMap[5] = (uint32_t)nextEntry;
    *hashMap = numEntries + 1;
    
    return 0;
}
```

Comments have been added, and all variable and function names have been changed to more meaningful names. One should replace placeholder names such as `AllocateMemory`, `FreeMemory`, `HashString`, `FindEntry`, `hasExclusiveAccess`, `DataMemoryBarrier`, and `ReleaseValue` with the actual functions used in your environment. Additionally, magic numbers like `0x14` should be defined as constants to improve clarity, and `ConstantGlobalHashSeed` replaced with your defined seed value for string hashing.