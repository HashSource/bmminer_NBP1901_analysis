```c
ulonglong NormalizeFloatingPoint(uint mantissa, uint exponent)
{
  byte byteCheck;
  uint tempVar1, tempVar2, tempVar3;
  uint finalExponent;
  int exponentAdjust;
  uint rightShiftCount;
  uint leftShiftCount;
  bool carryFlag;
  bool roundingBit;
  bool roundingCheck;

  // If both the mantissa and the exponent are zero, return the packed 64-bit result directly
  if ((mantissa | exponent) == 0) {
    return CONCAT44(exponent, mantissa);
  }
  
  // Determine the sign of the number based on the highest bit of the exponent and adjust 
  // the exponent and mantissa accordingly to ensure they are non-negative
  rightShiftCount = exponent & 0x80000000;
  tempVar2 = exponent;
  if ((int)rightShiftCount < 0) {
    roundingCheck = mantissa != 0;
    mantissa = -mantissa;
    tempVar2 = -exponent - (uint)roundingCheck;
  }

  // Set the initial adjusted exponent value
  exponentAdjust = 0x432;
  leftShiftCount = tempVar2 >> 22;
  if (leftShiftCount != 0) {
    exponentAdjust = 3;
    if (tempVar2 >> 25 != 0) {
      exponentAdjust = 6;
    }
    if (tempVar2 >> 28 != 0) {
      exponentAdjust = exponentAdjust + 3;
    }
    tempVar3 = exponentAdjust - ((int)tempVar2 >> 31);
    leftShiftCount = mantissa << (32 - tempVar3 & 0xff);
    mantissa = mantissa >> (tempVar3 & 0xff) | tempVar2 << (32 - tempVar3 & 0xff);
    tempVar2 = tempVar2 >> (tempVar3 & 0xff);
    exponentAdjust = tempVar3 + 0x432;
  }

  // Check if the bit length of the mantissa exceeds the limit
  if (tempVar2 > 0xfffff) {
    if (tempVar2 > 0x1fffff) {
      tempVar3 = tempVar2 & 1;
      tempVar2 = tempVar2 >> 1;
      byteCheck = (byte)mantissa;
      mantissa = (uint)(tempVar3 != 0) << 31 | mantissa >> 1;
      leftShiftCount = (uint)(byteCheck & 1) << 31 | leftShiftCount >> 1;
      exponentAdjust = exponentAdjust + 1;
      
      // Check if the exponent is too large and if so, return infinity
      if ((uint)(exponentAdjust * 0x200000) > 0xffbfffff) {
        return (ulonglong)(rightShiftCount | 0x7ff00000) << 32;
      }
    }
    goto NormalizeMantissa;
  }

  carryFlag = (leftShiftCount & 0x80000000) != 0;
  leftShiftCount = leftShiftCount << 1;
  tempVar3 = mantissa * 2;
  roundingCheck = CARRY4(mantissa, mantissa);
  mantissa = mantissa * 2 + (uint)carryFlag;
  tempVar2 = tempVar2 * 2 + (uint)(roundingCheck || CARRY4(tempVar3, (uint)carryFlag));
  exponentAdjust = exponentAdjust - 1;

  if ((tempVar2 & 0x100000) != 0)
    goto NormalizeMantissa;

  tempVar1 = mantissa;
  tempVar3 = tempVar2;

  if (tempVar2 == 0) {
    tempVar1 = 0;
    tempVar3 = mantissa;
  }

  // Leading zero count to adjust the exponent and mantissa
  finalExponent = LZCOUNT(tempVar3);

  // If there is no mantissa, adjust the leading zero count accordingly
  if (tempVar2 == 0) {
    finalExponent = finalExponent + 0x20;
  }
  
  rightShiftCount = finalExponent - 11; // Adjust right shift count based on the number of leading zeros
  roundingCheck = SBORROW4(rightShiftCount, 0x20); // Check if we need to round
  tempVar2 = finalExponent - 43;
  roundingBit = (int)tempVar2 < 0;
  carryFlag = tempVar2 == 0;

  // Check the range to determine how to normalize the mantissa
  if ((int)rightShiftCount < 0x20) {
    roundingCheck = SCARRY4(tempVar2, 12);
    finalExponent = finalExponent - 31;
    roundingBit = finalExponent < 0;
    carryFlag = finalExponent == 0;
    tempVar2 = rightShiftCount;

    // Perform normalization based on the adjusted exponent and the leading zero count
    if (!carryFlag && roundingBit == roundingCheck) {
      tempVar1 = tempVar3 << (rightShiftCount & 0xff);
      tempVar3 = tempVar3 >> (12U - finalExponent & 0xff);

      NormalizeShifted:
      if ((int)rightShiftCount <= exponentAdjust) {
        return CONCAT44(tempVar3 + (exponentAdjust - rightShiftCount) * 0x100000 | rightShiftCount, tempVar1);
      }

      tempVar2 = ~(exponentAdjust - rightShiftCount);
      
      if (0x1e < (int)tempVar2) {
        return CONCAT44(exponent, tempVar3 >> (tempVar2 - 31 & 0xff)) & 0x80000000ffffffff;
      }

      exponentAdjust = tempVar2 - 19;
      if (exponentAdjust == 0 || exponentAdjust < 0 != SCARRY4(tempVar2 - 31, 12)) {
        tempVar2 = tempVar2 + 1;
        return CONCAT44(rightShiftCount | tempVar3 >> (tempVar2 & 0xff),
                        tempVar1 >> (tempVar2 & 0xff) | tempVar3 << (32 - tempVar2 & 0xff));
      }

      // Apply final normalization and return the packed 64-bit result
      return CONCAT44(exponent, tempVar1 >> (32 - (12U - exponentAdjust) & 0xff) | tempVar3 << (12U - exponentAdjust & 0xff))
             & 0x80000000ffffffff;
    }
  }
  
  if (carryFlag || roundingBit != roundingCheck) {
    leftShiftCount = 32 - tempVar2;
  }
  tempVar3 = tempVar3 << (tempVar2 & 0xff);

  if (carryFlag || roundingBit != roundingCheck) {
    tempVar3 = tempVar3 | tempVar1 >> (leftShiftCount & 0xff);
  }

  if (carryFlag || roundingBit != roundingCheck) {
    tempVar1 = tempVar1 << (tempVar2 & 0xff);
  }

  goto NormalizeShifted;
}
```