```c
/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

// Function declaration adjusted for better readability
int loadVoltageFrequencyConfig(void) {
  bool configReleaseAccess; // Renamed for clarity: bVar1
  void *configJSON; // Renamed for clarity: pvVar2
  int opsStatus;   // Renamed for clarity: iVar3
  int *configFileHandle; // Renamed for clarity: piVar4
  int *minerTypeJSONObject; // Renamed for clarity: piVar5
  uint counter; // Renamed for clarity: uVar6
  int voltageValue; // Renamed for clarity: uVar7
  char *errorMessage; // Renamed for clarity: pcVar8
  int i;  // Renamed for clarity: iVar9
  int levelIndex;  // Renamed for clarity: iVar10
  int result;  // Renamed for clarity: uVar11
  uint levelCounter; // Renamed for clarity: uVar12
  uint index; // Renamed for clarity: uVar13
  int64_t jsonObject; // Renamed for clarity: uVar14
  
  levelIndex = 0;
  // Attempt to reset and check all 4 hashing boards.
  do {
    opsStatus = checkHashingBoard(levelIndex);
    if (opsStatus != 0) {
      resetHashingBoard(levelIndex);
      delay(10);
    }
    levelIndex++;
  } while (levelIndex != 4);
  
  // Clear the previous global configuration array
  memset(globalVoltageFrequencyConfig, 0, 0xa0);
  
  // Open the levels JSON configuration file.
  configFileHandle = openJSONConfigFile("/etc/levels.json", 0, fileReadBuffer);
  if ((configFileHandle == NULL) || (*configFileHandle != 0)) {
    // If the verbosity level is less than 4, return failure.
    if (verbosityLevel < 4) {
      return -1;
    }
    errorMessage = "load vol-freq config file %s failed\n";
    logError(3, errorMessage, "/etc/levels.json");
    return -1;
  }
  
  // Attempt to retrieve the 'miner' type from the file.
  minerTypeJSONObject = getJSONObjectByKey(configFileHandle, "miner");
  if ((minerTypeJSONObject == NULL) || (*minerTypeJSONObject != JSON_OBJECT)) {
    if (verbosityLevel < 5) {
      return -2;
    }
    errorMessage = "failed to get miner type in %s\n";
    logError(4, errorMessage, "/etc/levels.json");
  } else {
    // Output miner type if verbosity >= 5
    if (verbosityLevel >= 5) {
      result = getJSONStringValue();
      logMinerType(4, "/etc/levels.json", result);
    }
    // Check if miner type from JSON matches known types
    errorMessage = (char *)getJSONStringValue(minerTypeJSONObject);
    errorMessage = strstr(knownMinerTypes, errorMessage); // check if miner type is recognized
    if (errorMessage != NULL) {
      jsonObjName = (char *)getJSONStringValue(minerTypeJSONObject);
      matchResult = strcasecmp(errorMessage, jsonObjName); // compare miner types case-insensitively
      if (matchResult == 0) {
        jsonObject = getJSONObjectByKey(configFileHandle, "levels");
        minerTypeJSONObject = (int *)jsonObject;
        // Check if 'levels' object is valid and is an array
        if ((minerTypeJSONObject != NULL) && (*minerTypeJSONObject == JSON_ARRAY)) {
          errorMessage = (char *)((uint64_t)jsonObject >> 32);
          levelCounter = 0;
          levelIndex = 0;
          // Populate global configuration array with levels information
          while (true) {
            counter = getJSONArrayLength(minerTypeJSONObject, errorMessage);
            configJSON = globalVoltageFrequencyConfig;
            index = levelCounter + 1;
            if (MAX_LEVEL_INDEX < levelIndex || counter <= levelCounter) break;
            result = getJSONArrayItem(minerTypeJSONObject, levelCounter);
            errorMessage = "frequency";
            levelCounter = index;
            if (*configFileHandle == 0) {
              jsonObject = getJSONObjectByKey();
              errorMessage = (char *)((uint64_t)jsonObject >> 32);
              if (((int *)jsonObject != NULL) && (*(int *)jsonObject == JSON_VALUE)) {
                voltageValue = parseIntValue();
                voltageConfigArray[levelIndex * 2] = voltageValue;
                jsonObject = getJSONObjectByKey(result, "voltage");
                errorMessage = (char *)((uint64_t)jsonObject >> 32);
                if (((int *)jsonObject != NULL) && (*(int *)jsonObject == JSON_VALUE)) {
                  jsonObject = parseIntValue();
                  errorMessage = (char *)((uint64_t)jsonObject >> 32);
                  frequencyConfigArray[levelIndex * 2] = (int)jsonObject;
                  levelIndex++;
                }
              }
            }
          }
          // Logging each level, if verbosity >= 5
          levelIndex = 0;
          do {
            voltage = voltageFrequencyConfigArray[levelIndex].voltage;
            frequency = voltageFrequencyConfigArray[levelIndex].frequency;
            levelIndex++;
            if ((voltage != 0 && frequency != 0) && (verbosityLevel >= 5)) {
              logConfigLevel(4, levelIndex, voltage, frequency);
            }
          } while (levelIndex != MAX_CONFIG_LEVELS);
          if (configFileHandle[1] == -1) {
            return 0;
          }
          configReleasePointer = configFileHandle + 1;
          // Ensure the configuration file is safely released
          memoryBarrier(0xb);
          do {
            releaseCounter = *configReleasePointer;
            configReleaseAccess = (bool)hasExclusiveAccess(configReleasePointer);
          } while (!configReleaseAccess);
          *configReleasePointer = releaseCounter - 1;
          if (releaseCounter - 1 != 0) {
            return 0;
          }
          // Clean up by closing the JSON configuration file
          closeJSONConfigFile(configFileHandle);
          return 0;
        }
        if (verbosityLevel < 5) {
          return -2;
        }
        errorMessage = "failed to get levels in %s\n";
        logError(4, errorMessage, "/etc/levels.json");
      }
    }
    // If miner type is incorrect and verbosity >= 4, log the error
    if (verbosityLevel >= 4) {
      result = -3;
      char *typeMisMatchMsg = "miner type does not match known types";
      logError(3, typeMisMatchMsg);
    } else {
      result = -3;
    }
  }
  return result;
}
```