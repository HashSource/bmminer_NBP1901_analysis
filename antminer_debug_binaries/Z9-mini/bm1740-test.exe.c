/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

int init_proc();
void sub_8DB8();
// int pthread_mutex_unlock(pthread_mutex_t *mutex);
// void *calloc(size_t nmemb, size_t size);
// char *strstr(const char *haystack, const char *needle);
// int raise(int sig);
// void setbuf(FILE *stream, char *buf);
// int printf(const char *format, ...);
// int _isoc99_fscanf(_DWORD, const char *, ...); weak
// FILE *fopen(const char *filename, const char *modes);
// ssize_t read(int fd, void *buf, size_t nbytes);
// int pthread_mutex_destroy(pthread_mutex_t *mutex);
// int fflush(FILE *stream);
// void free(void *ptr);
// char *fgets(char *s, int n, FILE *stream);
// int pthread_mutex_lock(pthread_mutex_t *mutex);
// int pthread_detach(pthread_t th);
// pthread_t pthread_self(void);
// void *memcpy(void *dest, const void *src, size_t n);
// int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);
// __off_t lseek(int fd, __off_t offset, int whence);
// int pthread_mutex_trylock(pthread_mutex_t *mutex);
// int memcmp(const void *s1, const void *s2, size_t n);
// unsigned int sleep(unsigned int seconds);
// int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *cond_attr);
// int pthread_cond_destroy(pthread_cond_t *cond);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int usleep(__useconds_t useconds);
// char *strcpy(char *dest, const char *src);
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// int pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
// int puts(const char *s);
// void *malloc(size_t size);
// int __fastcall _libc_start_main(int (__fastcall *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end);
// char *strerror(int errnum);
// int system(const char *command);
// struct tm *localtime(const time_t *timer);
int j___gmon_start__();
// int _gmon_start__(void); weak
// int open(const char *file, int oflag, ...);
// void exit(int status);
// unsigned int strtoul(const char *nptr, char **endptr, int base);
// size_t strlen(const char *s);
// void *mmap(void *addr, size_t len, int prot, int flags, int fd, __off_t offset);
// int fprintf(FILE *stream, const char *format, ...);
// int *_errno_location(void);
// int snprintf(char *s, size_t maxlen, const char *format, ...);
// int _isoc99_sscanf(_DWORD, const char *, ...); weak
// void *memset(void *s, int c, size_t n);
// int putchar(int c);
// int pthread_cancel(pthread_t th);
// ssize_t write(int fd, const void *buf, size_t n);
// int fileno(FILE *stream);
// int fclose(FILE *stream);
// int munmap(void *addr, size_t len);
// uint32_t htonl(uint32_t hostlong);
// int pthread_join(pthread_t th, void **thread_return);
// int sprintf(char *s, const char *format, ...);
// int _isoc99_scanf(const char *, ...); weak
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
// int fseek(FILE *stream, int off, int whence);
// int isatty(int fd);
// int pthread_cond_signal(pthread_cond_t *cond);
// void abort(void);
// int close(int fd);
// void _assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
void __noreturn start(void (*)(void), int, int, int, ...); // idb
int call_gmon_start();
void *deregister_tm_clones();
__int64 register_tm_clones();
void *_do_global_dtors_aux();
__int64 frame_dummy();
int __cdecl main(int argc, const char **argv, const char **envp);
unsigned __int64 __fastcall load64(unsigned __int8 *a1);
_DWORD *__fastcall store32(_DWORD *result, int a2);
_DWORD *__fastcall store64(_DWORD *result, int a2, int a3, int a4);
unsigned __int64 __fastcall rotr64(unsigned __int64 a1, char a2);
int __fastcall secure_zero_memory(int a1, int a2);
int __fastcall blake2b_set_lastnode(int a1);
bool __fastcall blake2b_is_lastblock(int a1);
int __fastcall blake2b_set_lastblock(int a1);
int __fastcall blake2b_increment_counter(int a1, unsigned __int64 a2);
int __fastcall blake2b_init0(void *a1);
int __fastcall blake2b_init_param(void *a1, int a2);
int __fastcall blake2b_init(void *a1, unsigned __int8 a2);
int __fastcall blake2b_init_key(void *a1, unsigned __int8 a2, const void *a3, unsigned __int8 a4);
int __fastcall blake2b_compress(_QWORD *a1, int a2);
int __fastcall blake2b_update(int a1, char *a2, unsigned __int64 a3);
int __fastcall blake2b_final(int a1, void *a2, unsigned __int8 a3);
int __fastcall blake2b(void *a1, char *a2, const void *a3, unsigned __int8 a4, unsigned __int64 a5, unsigned __int8 a6);
unsigned int __fastcall midd_send_work_to_hardware(unsigned __int8 a1, unsigned __int8 *a2, int a3);
int __fastcall midd_recv_work(char *a1, unsigned int a2);
int __fastcall midd_recv_regdata(char *a1, unsigned int a2);
int __fastcall midd_recv_comm_from_rb(char *a1, unsigned int a2);
unsigned int __fastcall midd_ioctl(unsigned __int8 a1, int a2, char *a3);
__int64 now();
int __fastcall target_zero_cal(int a1);
int __fastcall targetValidator(const void *a1, const void *a2);
int __fastcall bm1740_handle_nonce(unsigned __int8 *a1);
int __fastcall bm1740_verify_nonce_integrality(_BYTE *a1);
int __fastcall bm1740_combine_one_nonce(_BYTE *a1, _BYTE *a2, unsigned __int8 a3);
void __noreturn bm1740_get_nonce(); // weak
void __noreturn bm1740_get_reg(); // weak
unsigned int __fastcall i2c_status(unsigned __int8 a1, unsigned __int8 a2);
int __fastcall i2c_recv(unsigned __int8 a1, unsigned __int8 a2, char a3, char a4, _BYTE *a5);
unsigned int __fastcall i2c_send(unsigned __int8 a1, char a2, char a3, char a4, char a5);
int asic_num_calculate();
int __fastcall calculate_asic_number(unsigned int a1);
int asic_addr_interval();
int __fastcall set_frequency(int result);
int __fastcall set_ticket_mask(int result);
int set_address();
int __fastcall set_core_timeout(int result);
unsigned int __fastcall set_timeout(unsigned int result);
int set_i2c_enable();
void __fastcall __noreturn midd_recv_comm(int a1);
void __fastcall __noreturn midd_dispatch_packet(int a1);
int bm1740_app_init();
void bm1740_app_exit();
unsigned int send_work_example();
int read_sensor_test();
int bm1740_app_test();
int __fastcall get_reg_auto_test(char a1);
int bm1740_app_test_manual();
int __fastcall get_bt8d_from_baud(int a1);
int __fastcall bm1740_pack_work_pkg(int a1, int a2);
int __fastcall bm1740_makeup_set_address_cmd(int a1, unsigned int a2, char a3);
int __fastcall bm1740_makeup_set_config_cmd(int a1, unsigned int a2, char a3, char a4, char a5, unsigned int a6);
int __fastcall bm1740_makeup_get_status_cmd(int a1, unsigned int a2, char a3, char a4, char a5);
int __fastcall bm1740_makeup_chain_inactive_cmd(int a1, unsigned int a2);
int __fastcall bm1740_makeup_bist_setup_cmd(char a1, char a2, int a3, unsigned int a4);
int __fastcall bm1740_makeup_bist_write_wait_cmd(char a1, char a2, int a3, char a4, int a5, unsigned int a6);
int __fastcall bm1740_makeup_bist_write_wait_read_cmd(char a1, char a2, int a3, int a4, unsigned int a5);
int __fastcall bm1740_makeup_bist_wait_cmd(char a1, char a2, int a3, int a4, unsigned int a5);
int __fastcall bm1740_makeup_bist_read_cmd(char a1, char a2, int a3, unsigned int a4);
int __fastcall bm1740_makeup_bist_disable_cmd(char a1, char a2, int a3, unsigned int a4);
int __fastcall bm1740_set_reg_table(char a1, int a2);
int __fastcall bm1740_get_reg_table(char a1, void *a2);
int __fastcall bm1740_parse_nonce_respond(const void *a1, size_t a2, void *a3, unsigned int a4);
int __fastcall bm1740_parse_reg_respond(unsigned __int8 *a1, size_t a2, void *a3, unsigned int a4);
int __fastcall bm1740_parse_pmonitor_respond(int a1, size_t a2, void *a3, unsigned int a4);
int __fastcall bm1740_parse_bist_respond(int a1, size_t a2, void *a3, unsigned int a4);
int __fastcall bm1740_parse_respond_len(_BYTE *a1, int a2, _DWORD *a3);
int __fastcall bm1740_parse_respond_pkg(_BYTE *a1, size_t a2, _DWORD *a3, void *a4, unsigned int a5);
int __fastcall bm1740_get_plldata(int result, _DWORD *a2);
int __fastcall bm1740_ioctl_regtable(int a1, int a2);
int __fastcall bm1740_pack_ioctl_pkg(int a1, unsigned int a2, int a3, char *a4);
int bm1740_soc_init();
int bm1740_soc_exit();
int __fastcall my_log_curses(int result, const char *a2, const char *a3, char a4);
int __fastcall applog(int a1, const char *a2);
int __fastcall simplelog(int a1, const char *a2, char a3);
int __fastcall add_reg_item(int a1, int a2, int a3);
int __fastcall read_reg_item(unsigned __int8 *a1);
void __noreturn reg_scan_aging();
int reg_scan_init();
int reg_scan_exit();
int __fastcall rt_ringbuffer_get_size(int a1);
int __fastcall rt_ringbuffer_status(int a1);
int __fastcall rt_ringbuffer_data_len(_WORD *a1);
int __fastcall rt_ringbuffer_init(int a1, int a2, __int16 a3, int a4);
int __fastcall rt_ringbuffer_lock_destory(int a1);
int __fastcall rt_ringbuffer_put(int a1, char *a2, unsigned __int16 a3);
int __fastcall rt_ringbuffer_put_force(int a1, char *a2, unsigned __int16 a3);
int __fastcall rt_ringbuffer_get(int a1, char *a2, unsigned __int16 a3);
int __fastcall rt_ringbuffer_prefetch(_WORD *a1, char *a2, unsigned __int16 a3);
int __fastcall Sha256_Init(int result);
int *__fastcall Sha256_Transform(int *result, int a2);
int *__fastcall Sha256_WriteByteBlock(int *a1);
int *__fastcall Sha256_Update(int *result, _BYTE *a2, int a3);
int __fastcall Sha256_Final(int a1, _BYTE *a2);
int __fastcall Sha256_Onestep(_BYTE *a1, int a2, _BYTE *a3);
unsigned int __fastcall compressArray(int a1, int a2, int a3, unsigned int a4, unsigned int a5, int a6);
unsigned int __fastcall expandArray(int a1, unsigned int a2, int a3, int a4, unsigned int a5, unsigned int a6);
unsigned int __fastcall getIndices(int a1, int a2, int a3, int a4, int a5, unsigned int a6);
int __fastcall isZero(int a1, unsigned int a2);
int __fastcall generateHash(const void *a1, int a2, void *a3, unsigned __int8 a4);
int __fastcall compareSR(const void *a1, const void *a2);
int __fastcall sort_pair(int result, unsigned int a2);
int __fastcall sortValidator(int *a1, int a2);
void *__fastcall zcashPerson(_DWORD *a1, int a2, int a3);
int __fastcall digestInit(void *a1, int a2, int a3);
void __cdecl _bin2hex(unsigned __int8 *s, const unsigned __int8 *p, size_t len);
unsigned __int8 *__fastcall bin2hex(const unsigned __int8 *a1, size_t a2);
int __fastcall hex2bin(_BYTE *a1, unsigned __int8 *a2, int a3);
int __fastcall swap_bit(unsigned __int8 a1);
void __fastcall dump_str(FILE *a1, const char *a2, const unsigned __int8 *a3, size_t a4);
int __fastcall bit_read(int a1, int a2);
int __fastcall get_BM1385_plldata(int a1, _DWORD *a2, unsigned __int16 *a3, _DWORD *a4);
unsigned int __fastcall read_BM1385_asic_register(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, char a4);
int __fastcall set_BM1385_freq(unsigned __int8 a1, char a2, int a3, char a4);
void *__fastcall check_BM1385_asic_reg(unsigned __int8 a1, int a2, unsigned __int8 a3, char a4);
int __fastcall BM1385_chain_inactive(unsigned __int8 a1);
unsigned int __fastcall BM1385_set_address(unsigned __int8 a1, unsigned __int8 a2);
unsigned int __fastcall BM1385_set_baud(unsigned __int8 a1, char a2, char a3, char a4);
int __fastcall BM1385_set_gateblk(unsigned __int8 a1, int a2, char a3);
int reset_single_BM1385_global_arg();
unsigned int single_BM1385_calculate_timeout_and_baud();
unsigned int __fastcall BM1722_set_address_all(unsigned __int8); // idb
int __fastcall single_BM1385_set_baud(unsigned __int8 a1, unsigned __int8 a2);
int __fastcall single_BM1385_open_core(unsigned __int8 a1);
int __fastcall single_BM1385_get_result(unsigned __int8 a1);
unsigned int __fastcall single_asic_print_lcd(int a1, char a2);
void __fastcall __noreturn single_BM1385_show_status_func(unsigned __int8 *a1);
bool __fastcall is_nonce_or_reg_value(char); // idb
int __fastcall single_BM1385_check_nonce(unsigned __int8 a1, unsigned __int8 *a2);
int __fastcall single_BM1385_check_register_value(char a1, int a2);
int __fastcall single_BM1385_send_func(unsigned __int8 *a1);
int __fastcall single_BM1385_receive_func(unsigned __int8 *a1);
int singleAsicTest_BM1385();
int read_config();
unsigned __int8 __cdecl CRC5(unsigned __int8 *ptr, unsigned __int8 len);
uint16_t __cdecl CRC16(const unsigned __int8 *p_data, uint16_t w_len);
int bitmain_axi_init();
int bitmain_axi_close();
int __fastcall read_axi_fpga(int a1);
int __fastcall write_axi_fpga(int result, int a2);
int init_fpga();
int __fastcall get_return_nonce(int *a1);
int __fastcall set_BC_command_buffer(int *a1);
int get_BC_write_command();
int __fastcall set_BC_write_command(int a1);
int __fastcall set_TW_write_command(int *a1);
int __fastcall set_fpga_baud(unsigned __int8 a1);
int cgpu_init();
void Hardware_close();
void *malloc_register_buf();
int configMiner(); // idb
ssize_t display_arguments();
void *clear_register_value_buf();
int __fastcall calculate_core_number(unsigned int a1);
int __fastcall asic_baud_to_fpga_baud(unsigned __int8 a1);
int __fastcall calculate_how_many_nonce_per_asic_get(unsigned __int8 a1, unsigned __int8 a2, unsigned int a3);
int display_level_result_on_lcd(); // idb
void *reset_global_arg();
int __fastcall rev(int result, char); // idb
int __fastcall check_hw(_DWORD *a1, unsigned int a2, char a3);
int __fastcall i2c_write(int a1);
int __fastcall i2c_read(int a1);
int __fastcall check_how_many_uart_data_in_fpga(unsigned __int8 a1);
int __fastcall read_uart_data_in_fpga(unsigned __int8 a1, int a2, unsigned int a3);
unsigned int __fastcall uart_send(unsigned __int8 a1, unsigned __int8 *a2, size_t a3);
int __fastcall uart_receive(unsigned __int8 a1, int a2, unsigned int a3);
int __fastcall clear_uart_send_fifo(unsigned __int8 a1);
int __fastcall clear_uart_rx_fifo(unsigned __int8 a1);
int open_key();
int close_key();
int __fastcall read_key(char a1);
int open_lcd();
int close_lcd();
unsigned int __fastcall write_lcd(unsigned int result, int a2, unsigned int a3);
unsigned int __fastcall write_lcd_no_memset(unsigned int result, int a2, unsigned int a3);
int open_red_led();
int close_red_led();
ssize_t red_led_on();
ssize_t red_led_off();
int open_green_led();
int close_green_led();
ssize_t green_led_on();
ssize_t green_led_off();
int __fastcall c2hex(unsigned __int8); // idb
unsigned __int8 __cdecl twoc2hex(unsigned __int8 high, unsigned __int8 low);
int __fastcall s2hex(_BYTE *, _BYTE *, int); // idb
int print_works();
int __fastcall get_work(int a1, int a2);
unsigned int __fastcall get_work_hash_board(int a1, int a2, FILE *a3, unsigned int a4);
int get_works();
int clear_nonce_return_flag();
int __fastcall write_pic(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3);
int __fastcall read_pic(unsigned __int8 a1, unsigned __int8 a2);
int __fastcall set_PIC16F1704_flash_point32_ter(char, char, unsigned __int8, unsigned __int8); // idb
int __fastcall send_data_to_PIC16F1704(char, char, int); // idb
int __fastcall read_PIC16F1704_flash_point32_ter(char, char, unsigned __int8 *, unsigned __int8 *); // idb
int __fastcall read_PIC16F1704_flash_data(char, char, int); // idb
int __fastcall erase_PIC16F1704_flash(unsigned __int8 a1, unsigned __int8 a2);
int __fastcall write_data_into_PIC16F1704_flash(unsigned __int8 a1, unsigned __int8 a2);
int __fastcall jump_from_loader_to_app_PIC16F1704(char, char); // idb
int __fastcall reset_PIC16F1704_pic(unsigned __int8 a1, unsigned __int8 a2);
int __fastcall set_PIC16F1704_voltage(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3);
int __fastcall write_hash_ID_PIC16F1704(unsigned __int8 a1, unsigned __int8 a2, int a3);
int __fastcall read_hash_id_PIC16F1704(unsigned __int8 a1, unsigned __int8 a2, int a3);
int __fastcall enable_PIC16F1704_dc_dc(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3);
int __fastcall heart_beat_PIC16F1704(char, char); // idb
void __fastcall __noreturn pic_heart_beat_func(char *); // idb
int __fastcall get_PIC16F1704_software_version(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 *a3);
int __fastcall get_PIC16F1704_voltage(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 *a3);
int __fastcall write_temperature_offset_PIC16F1704(unsigned __int8 a1, unsigned __int8 a2, int a3);
int __fastcall read_temperature_offset_PIC16F1704(unsigned __int8 a1, unsigned __int8 a2, int a3);
int __fastcall erase_PIC16F1704_app_flash(char, char); // idb
int __fastcall PIC1704_update_pic_app_program(char, char); // idb
int __fastcall save_freq_PIC16F1704(unsigned __int8 a1, unsigned __int8 a2, unsigned __int16 a3);
int __fastcall get_PIC16F1704_freq(unsigned __int8 a1, unsigned __int8 a2, unsigned __int16 *a3);
int __fastcall set_temperature_offset_value(char, char, int); // idb
int __fastcall write_sensor_info_into_pic(char a1, char a2);
int __fastcall write_PIC16F1705_iic_slave(unsigned __int8 a1, unsigned __int8 a2, int a3, unsigned __int8 a4);
int __fastcall read_PIC16F1705_iic_slave(unsigned __int8 a1, unsigned __int8 a2, int a3, unsigned __int8 a4);
int check_chain();
int get_fan_speed();
int __fastcall set_fan_speed(int a1);
int __fastcall fan_control(char a1);
int reset_hash_board();
void __cdecl sha256_transf(sha256_ctx *ctx, const unsigned __int8 *message, unsigned int block_nb);
void __cdecl sha256(const unsigned __int8 *message, unsigned int len, unsigned __int8 *digest);
void __cdecl sha256_init(sha256_ctx *ctx);
void __cdecl sha256_update(sha256_ctx *ctx, const unsigned __int8 *message, unsigned int len);
void __cdecl sha256_final(sha256_ctx *ctx, unsigned __int8 *digest);
void __cdecl sha2_starts(sha2_context *ctx);
void __cdecl sha2_process(sha2_context *ctx, const unsigned __int8 *data);
void __cdecl sha2_update(sha2_context *ctx, const unsigned __int8 *input, int ilen);
void __cdecl sha2_finish(sha2_context *ctx, unsigned __int8 *output);
void __cdecl sha2(const unsigned __int8 *input, int ilen, unsigned __int8 *output);
unsigned int __fastcall swab32(unsigned int a1);
void __cdecl flip_swab(void *dest_p, const void *src_p, unsigned int length);
void __cdecl flip32(void *dest_p, const void *src_p);
int __fastcall read_temperature_from_fpga_register(unsigned __int8 a1);
int __fastcall read_temperature_through_fpga_iic_register(unsigned __int8 a1, int a2);
void *reset_V9_global_arg();
int __fastcall V9_set_voltage(unsigned __int8 a1, unsigned __int8 a2, char a3);
int V9_calculate_timeout_and_baud();
int __fastcall V9_set_address(unsigned __int8 a1);
int __fastcall V9_set_baud(unsigned __int8 a1, unsigned __int8 a2);
int __fastcall V9_open_core(unsigned __int8 a1);
int __fastcall V9_get_result(unsigned __int8 a1);
unsigned int __fastcall V9_print_lcd(char a1);
void __fastcall __noreturn V9_show_status_func(unsigned __int8 *a1);
int __fastcall v9_check_nonce(unsigned __int8 a1, unsigned __int8 *a2);
int __fastcall V9_check_register_value(char a1, int a2);
int __fastcall V9_send_func(unsigned __int8 *a1);
int __fastcall V9_receive_func(unsigned __int8 *a1);
int singleBoardTest_V9_BM1385_45();
int singleBoardTest_V9_BM1740();
int __fastcall divsi3_skip_div0_test(int result, unsigned int); // idb
int _aeabi_ldiv0();
__int64 init();
int _libc_csu_fini(); // weak
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

void *jpt_1F90E[10] =
{
  (void *)0x1F93D,
  (void *)0x1F94B,
  (void *)0x1F959,
  (void *)0x1F967,
  (void *)0x1F975,
  (void *)0x1F983,
  (void *)0x1F991,
  (void *)0x1F99F,
  (void *)0x1F9AD,
  (void *)0x1F9BB
}; // weak
void *jpt_1FC10[10] =
{
  (void *)0x1FC3D,
  (void *)0x1FC5D,
  (void *)0x1FC7D,
  (void *)0x1FC9D,
  (void *)0x1FCBD,
  (void *)0x1FCDD,
  (void *)0x1FCFD,
  (void *)0x1FD1D,
  (void *)0x1FD3D,
  (void *)0x1FD5D
}; // weak
void *jpt_29C76[9] =
{
  (void *)0x29CA1,
  (void *)0x29CB1,
  (void *)0x29CC1,
  (void *)0x29CD1,
  (void *)0x29CE1,
  (void *)0x29CF1,
  (void *)0x29D01,
  (void *)0x29D11,
  (void *)0x29D21
}; // weak
_UNKNOWN loc_2B7A8; // weak
_QWORD blake2b_IV[8] =
{
  7640891576956012808LL,
  -4942790177534073029LL,
  4354685564936845355LL,
  -6534734903238641935LL,
  5840696475078001361LL,
  -7276294671716946913LL,
  2270897969802886507LL,
  6620516959819538809LL
}; // weak
char blake2b_sigma = '\0'; // weak
char byte_2C6C8[4] = { '\0', '\0', '\0', '\0' }; // weak
_DWORD K[64] =
{
  1116352408,
  1899447441,
  -1245643825,
  -373957723,
  961987163,
  1508970993,
  -1841331548,
  -1424204075,
  -670586216,
  310598401,
  607225278,
  1426881987,
  1925078388,
  -2132889090,
  -1680079193,
  -1046744716,
  -459576895,
  -272742522,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  -1740746414,
  -1473132947,
  -1341970488,
  -1084653625,
  -958395405,
  -710438585,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  -2117940946,
  -1838011259,
  -1564481375,
  -1474664885,
  -1035236496,
  -949202525,
  -778901479,
  -694614492,
  -200395387,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  -2067236844,
  -1933114872,
  -1866530822,
  -1538233109,
  -1090935817,
  -965641998
}; // weak
_DWORD hex2bin_tbl[256] =
{
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  11,
  12,
  13,
  14,
  15,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  11,
  12,
  13,
  14,
  15,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1
}; // weak
char hex_5140[50] = "0123456789abcdef/mnt/card/single-BM1385-ASIC-test"; // weak
_BYTE chCRCHTalbe[256] =
{
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64
}; // weak
_BYTE chCRCLTalbe[256] =
{
  0,
  -64,
  -63,
  1,
  -61,
  3,
  2,
  -62,
  -58,
  6,
  7,
  -57,
  5,
  -59,
  -60,
  4,
  -52,
  12,
  13,
  -51,
  15,
  -49,
  -50,
  14,
  10,
  -54,
  -53,
  11,
  -55,
  9,
  8,
  -56,
  -40,
  24,
  25,
  -39,
  27,
  -37,
  -38,
  26,
  30,
  -34,
  -33,
  31,
  -35,
  29,
  28,
  -36,
  20,
  -44,
  -43,
  21,
  -41,
  23,
  22,
  -42,
  -46,
  18,
  19,
  -45,
  17,
  -47,
  -48,
  16,
  -16,
  48,
  49,
  -15,
  51,
  -13,
  -14,
  50,
  54,
  -10,
  -9,
  55,
  -11,
  53,
  52,
  -12,
  60,
  -4,
  -3,
  61,
  -1,
  63,
  62,
  -2,
  -6,
  58,
  59,
  -5,
  57,
  -7,
  -8,
  56,
  40,
  -24,
  -23,
  41,
  -21,
  43,
  42,
  -22,
  -18,
  46,
  47,
  -17,
  45,
  -19,
  -20,
  44,
  -28,
  36,
  37,
  -27,
  39,
  -25,
  -26,
  38,
  34,
  -30,
  -29,
  35,
  -31,
  33,
  32,
  -32,
  -96,
  96,
  97,
  -95,
  99,
  -93,
  -94,
  98,
  102,
  -90,
  -89,
  103,
  -91,
  101,
  100,
  -92,
  108,
  -84,
  -83,
  109,
  -81,
  111,
  110,
  -82,
  -86,
  106,
  107,
  -85,
  105,
  -87,
  -88,
  104,
  120,
  -72,
  -71,
  121,
  -69,
  123,
  122,
  -70,
  -66,
  126,
  127,
  -65,
  125,
  -67,
  -68,
  124,
  -76,
  116,
  117,
  -75,
  119,
  -73,
  -74,
  118,
  114,
  -78,
  -77,
  115,
  -79,
  113,
  112,
  -80,
  80,
  -112,
  -111,
  81,
  -109,
  83,
  82,
  -110,
  -106,
  86,
  87,
  -105,
  85,
  -107,
  -108,
  84,
  -100,
  92,
  93,
  -99,
  95,
  -97,
  -98,
  94,
  90,
  -102,
  -101,
  91,
  -103,
  89,
  88,
  -104,
  -120,
  72,
  73,
  -119,
  75,
  -117,
  -118,
  74,
  78,
  -114,
  -113,
  79,
  -115,
  77,
  76,
  -116,
  68,
  -124,
  -123,
  69,
  -121,
  71,
  70,
  -122,
  -126,
  66,
  67,
  -125,
  65,
  -127,
  128,
  64
}; // weak
unsigned __int8 sha2_padding[64] =
{
  128u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // weak
int (__fastcall *memset_v_4649)(_DWORD, _DWORD, _DWORD) = &memset; // weak
int addr_interval = 64; // weak
int g_tm = 10; // weak
_UNKNOWN baud_BT8D_values; // weak
_DWORD freq_pll[400] =
{
  100,
  131136,
  1056,
  2097729,
  125,
  163904,
  1056,
  2622017,
  150,
  196672,
  1056,
  3146305,
  175,
  229440,
  1056,
  3670593,
  200,
  262208,
  1056,
  4194881,
  225,
  294976,
  1056,
  4719169,
  250,
  327744,
  1056,
  5243457,
  275,
  360512,
  1056,
  5767745,
  300,
  393280,
  1056,
  6292033,
  325,
  426048,
  1056,
  6816321,
  350,
  458816,
  1056,
  7340609,
  375,
  491584,
  1056,
  7864897,
  400,
  524352,
  1056,
  8389185,
  404,
  397376,
  800,
  6357553,
  406,
  266304,
  544,
  4260385,
  408,
  401472,
  800,
  6423089,
  412,
  270400,
  544,
  4325921,
  416,
  409664,
  800,
  6554161,
  418,
  274496,
  544,
  4391457,
  420,
  413760,
  800,
  6619697,
  425,
  278592,
  544,
  4456993,
  429,
  421952,
  800,
  6750769,
  431,
  282688,
  544,
  4522529,
  433,
  426048,
  800,
  6816305,
  437,
  286784,
  544,
  4588065,
  441,
  434240,
  800,
  6947377,
  443,
  290880,
  544,
  4653601,
  445,
  438336,
  800,
  7012913,
  450,
  294976,
  544,
  4719137,
  454,
  446528,
  800,
  7143985,
  456,
  299072,
  544,
  4784673,
  458,
  450624,
  800,
  7209521,
  462,
  303168,
  544,
  4850209,
  466,
  458816,
  800,
  7340593,
  468,
  307264,
  544,
  4915745,
  470,
  462912,
  800,
  7406129,
  475,
  311360,
  544,
  4981281,
  479,
  471104,
  800,
  7537201,
  481,
  315456,
  544,
  5046817,
  483,
  475200,
  800,
  7602737,
  487,
  319552,
  544,
  5112353,
  491,
  483392,
  800,
  7733809,
  493,
  323648,
  544,
  5177889,
  495,
  487488,
  800,
  7799345,
  500,
  327744,
  544,
  5243425,
  504,
  495680,
  800,
  7930417,
  506,
  331840,
  544,
  5308961,
  508,
  499776,
  800,
  7995953,
  512,
  335936,
  544,
  5374497,
  516,
  507968,
  800,
  8127025,
  518,
  340032,
  544,
  5440033,
  520,
  512064,
  800,
  8192561,
  525,
  344128,
  544,
  5505569,
  529,
  520256,
  800,
  8323633,
  531,
  348224,
  544,
  5571105,
  533,
  524352,
  800,
  8389169,
  537,
  352320,
  544,
  5636641,
  543,
  356416,
  544,
  5702177,
  550,
  360512,
  544,
  5767713,
  556,
  364608,
  544,
  5833249,
  562,
  368704,
  544,
  5898785,
  568,
  372800,
  544,
  5964321,
  575,
  376896,
  544,
  6029857,
  581,
  380992,
  544,
  6095393,
  587,
  385088,
  544,
  6160929,
  593,
  389184,
  544,
  6226465,
  600,
  393280,
  544,
  6292001,
  606,
  397376,
  544,
  6357537,
  612,
  401472,
  544,
  6423073,
  618,
  405568,
  544,
  6488609,
  625,
  409664,
  544,
  6554145,
  631,
  413760,
  544,
  6619681,
  637,
  417856,
  544,
  6685217,
  643,
  421952,
  544,
  6750753,
  650,
  426048,
  544,
  6816289,
  656,
  430144,
  544,
  6881825,
  662,
  434240,
  544,
  6947361,
  668,
  438336,
  544,
  7012897,
  675,
  442432,
  544,
  7078433,
  681,
  446528,
  544,
  7143969,
  687,
  450624,
  544,
  7209505,
  693,
  454720,
  544,
  7275041,
  700,
  458816,
  544,
  7340577,
  706,
  462912,
  544,
  7406113,
  712,
  467008,
  544,
  7471649,
  718,
  471104,
  544,
  7537185,
  725,
  475200,
  544,
  7602721,
  731,
  479296,
  544,
  7668257,
  737,
  483392,
  544,
  7733793,
  743,
  487488,
  544,
  7799329,
  750,
  491584,
  544,
  7864865,
  756,
  495680,
  544,
  7930401,
  762,
  499776,
  544,
  7995937,
  768,
  503872,
  544,
  8061473,
  775,
  507968,
  544,
  8127009,
  781,
  512064,
  544,
  8192545,
  787,
  516160,
  544,
  8258081,
  793,
  520256,
  544,
  8323617,
  800,
  524352,
  544,
  8389153,
  825,
  270400,
  288,
  4325905
}; // weak
int opt_log_level = 3; // weak
int compare_size = 3; // weak
void *Single_BM1385_WorkDataPathPrefix = (void *)0x2CDB8; // weak
char *freq_pll_1385 = "19"; // weak
_UNKNOWN unk_30D40; // weak
char *BTC_WorkDataFilePrefix = "/btc-core-"; // weak
char gChain = '\xFF'; // weak
_BYTE lcd_buffer[16] = { 32, 32, 32, 76, 101, 118, 101, 108, 58, 32, 32, 32, 32, 32, 32, 32 }; // weak
char lcd_output[2] = " "; // weak
char s[16] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_310B0[32] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
_DWORD sha256_h0[8] =
{
  1779033703,
  -1150833019,
  1013904242,
  -1521486534,
  1359893119,
  -1694144372,
  528734635,
  1541459225
}; // weak
_DWORD sha256_k[64] =
{
  1116352408,
  1899447441,
  -1245643825,
  -373957723,
  961987163,
  1508970993,
  -1841331548,
  -1424204075,
  -670586216,
  310598401,
  607225278,
  1426881987,
  1925078388,
  -2132889090,
  -1680079193,
  -1046744716,
  -459576895,
  -272742522,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  -1740746414,
  -1473132947,
  -1341970488,
  -1084653625,
  -958395405,
  -710438585,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  -2117940946,
  -1838011259,
  -1564481375,
  -1474664885,
  -1035236496,
  -949202525,
  -778901479,
  -694614492,
  -200395387,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  -2067236844,
  -1933114872,
  -1866530822,
  -1538233109,
  -1090935817,
  -965641998
}; // weak
char *V9_WorkDataPathPrefix = "/mnt/card/minertest64-BM1385/btc-asic-"; // weak
_UNKNOWN _TMC_END__; // weak
int stderr; // weak
int stdin; // weak
char completed_8605; // weak
_DWORD nonce_num_each_asic[4]; // weak
int asic_num[]; // weak
int sensor_chip_addr[]; // weak
int dword_31220; // weak
int g_txok_en; // weak
int inited; // weak
int nonce_ok; // weak
int sensor_ok; // weak
int retransmit_6460; // weak
int asic_nonce_6391; // weak
_UNKNOWN time_first_6394; // weak
int k_6393; // weak
int asic_nonce_table_6392[]; // weak
int dword_31250; // weak
int dword_31254; // weak
int dword_31258; // weak
int dword_3125C; // weak
int dword_31260; // weak
int dword_31264; // weak
int dword_31268; // weak
int dword_3126C; // weak
int dword_31270; // weak
pthread_mutex_t g_reg_table_mutex; // weak
int state_6104; // weak
char use_syslog; // weak
char opt_quiet; // weak
char opt_debug; // weak
char opt_log_output; // weak
int reg_scan_items[300]; // weak
pthread_mutex_t reg_scan_mutex; // weak
int p_reg_scan; // weak
int fpga_mem_addr; // weak
int axi_fpga_addr; // weak
char gHashBoard_V9; // weak
char gHashBoard_S9; // weak
char gHashBoard_T9; // weak
char gHashBoard_T9_plus; // weak
char gHashBoard_R4; // weak
char gHashBoard_S11; // weak
_BYTE gChain_exist[4]; // weak
_UNKNOWN gChain_fd; // weak
char gI2c; // weak
int gPic_addr_high_4_bit; // weak
int gSensor_i2c_addr_high_4_bit; // weak
char gHowManyVoltageLevel; // weak
char pattern_test_time; // weak
int time_counter; // weak
int gName_len; // weak
int gSensor_number; // weak
int gHighest_Temp; // weak
int gChain_Asic_Interval; // weak
int gPattern_number; // weak
char gStartTest; // weak
char gBegin_Get_Nonce; // weak
char gIsOpenCoreEnd; // weak
char gIsOpeningCore; // weak
char gHigherThanAlarmTemp; // weak
char start_receive; // weak
int gValid_Nonce_Num[]; // weak
int gHw_Nonce_Num[]; // weak
_DWORD gSend_Work_Num[1]; // weak
_DWORD gAsic_Core_Nonce_Num[16384]; // weak
_DWORD gRepeated_Nonce_Id[1]; // weak
_BYTE gSensor_OK[4]; // weak
char gWork_Num_For_Hw_Check; // weak
pthread_mutex_t reg_mutex; // weak
pthread_mutex_t HW_check_mutex[1]; // weak
pthread_mutex_t uart_send_mutex[1]; // weak
pthread_mutex_t uart_receive_mutex[1]; // weak
int key_fd; // weak
int lcd_fd; // weak
int red_led_fd; // weak
int green_led_fd; // weak
pthread_mutex_t i2c_mutex; // weak
_UNKNOWN cgpu; // weak
_UNKNOWN unk_493E0; // weak
pthread_t dword_51848; // idb
pthread_t dword_5184C; // idb
pthread_t newthread; // idb
int dword_51870; // weak
char dest[64]; // idb
char byte_518B4[576]; // idb
int dword_51AF4; // weak
_UNKNOWN unk_61A80; // weak
int dword_61AF4; // weak
int dword_61B34; // weak
_UNKNOWN unk_61B3C; // weak
_UNKNOWN unk_61B44; // weak
int dword_61B4C; // weak
_UNKNOWN chain_info; // weak
_UNKNOWN unk_61B59; // weak
int reg_value_buf; // weak
_UNKNOWN Conf; // weak
int dword_61BA0; // weak
int dword_61BA4; // weak
int dword_61BA8; // weak
int dword_61BAC; // weak
int dword_61BB0; // weak
int dword_61BB4; // weak
int dword_61BB8; // weak
int dword_61BBC; // weak
int dword_61BC0; // weak
int dword_61BC4; // weak
int dword_61BC8; // weak
int dword_61BCC; // weak
int dword_61BD0; // weak
int dword_61BD4; // weak
int dword_61BFC; // weak
int dword_61C00; // weak
int dword_61C04; // weak
int dword_61C08; // weak
int dword_61C0C; // weak
int dword_61C10; // weak
int dword_61C14; // weak
int dword_61C18; // weak
int dword_61C1C; // weak
int dword_61C20; // weak
int dword_61C24; // weak
int dword_61C2C; // weak
int dword_61C30; // weak
int dword_61C34; // weak
int dword_61C38; // weak
char byte_61C3C; // weak
char byte_61C3D; // weak
char byte_61C3E; // weak
char byte_61C40; // weak
char byte_61C42; // weak
int dword_61C50; // weak
int dword_61C54; // weak
int dword_61C58; // weak
int dword_61C5C; // weak
int dword_61C60; // weak
char byte_61C64; // weak
int dword_61C68; // weak
int dword_61C6C; // weak
_UNKNOWN g_test_header; // weak
int g_chain[10]; // weak
unsigned __int8 g_nonce_list[1366]; // weak
char byte_62282; // weak
char byte_62283; // weak
char byte_62284; // weak
_UNKNOWN unk_62285; // weak
char byte_622CD; // weak
_UNKNOWN unk_622CE; // weak
_UNKNOWN unk_622D6; // weak
int rb_reg; // weak
int p_get_reg_back; // weak
_WORD bm_nonce_rb[4]; // weak
int dword_622F0; // weak
int rb_nonce; // weak
int rb_comm; // weak
_WORD bm_comm_rb[4]; // weak
int dword_62388; // weak
int p_get_nonce_back; // weak
_WORD bm_reg_rb[4]; // weak
int dword_62420; // weak
int g_crc16_err_enable; // weak
int g_reg_table; // weak
int dword_624B0; // weak
int dword_624B4; // weak
int dword_624B8; // weak
int dword_624BC; // weak
int dword_624C0; // weak
int dword_624C4; // weak
int dword_624C8; // weak
int dword_624CC; // weak
int dword_624D0; // weak
int dword_624D4; // weak
int dword_624D8; // weak
int dword_624DC; // weak
int dword_624E0; // weak
int dword_624E4; // weak
int g_crc5_err_enable; // weak
int fl; // weak
pthread_mutex_t console_lock; // weak
int fd_fpga_mem; // weak
_DWORD gWorks_For_Hw_Check[140]; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (00008DAC) --------------------------------------------------------
int init_proc()
{
  return call_gmon_start();
}

//----- (00008DB8) --------------------------------------------------------
void sub_8DB8()
{
  JUMPOUT(0);
}
// 8DC4: control flows out of bounds to 0

//----- (00008F70) --------------------------------------------------------
// attributes: thunk
int j___gmon_start__()
{
  return _gmon_start__();
}
// 8F74: using guessed type int _gmon_start__(void);

//----- (000090D0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __noreturn start(void (*a1)(void), int a2, int a3, int a4, ...)
{
  int v4; // [sp-4h] [bp-4h]
  va_list va; // [sp+0h] [bp+0h] BYREF

  va_start(va, a4);
  _libc_start_main(
    (int (__fastcall *)(int, char **, char **))main,
    v4,
    (char **)va,
    (void (*)(void))init,
    (void (*)(void))_libc_csu_fini,
    a1,
    va);
  abort();
}
// 90DC: positive sp value 4 has been found
// 90F2: variable 'v4' is possibly undefined
// 2BA1C: using guessed type int init();
// 2BA60: using guessed type int _libc_csu_fini();

//----- (00009108) --------------------------------------------------------
int call_gmon_start()
{
  int result; // r0

  if ( &__gmon_start__ )
    return j___gmon_start__();
  return result;
}

//----- (00009120) --------------------------------------------------------
void *deregister_tm_clones()
{
  return &_TMC_END__;
}

//----- (00009144) --------------------------------------------------------
__int64 register_tm_clones()
{
  __int64 result; // r0

  LODWORD(result) = &_TMC_END__;
  HIDWORD(result) = 0;
  return result;
}

//----- (00009170) --------------------------------------------------------
void *_do_global_dtors_aux()
{
  void *result; // r0

  if ( !completed_8605 )
  {
    result = deregister_tm_clones();
    completed_8605 = 1;
  }
  return result;
}
// 31204: using guessed type char completed_8605;

//----- (00009188) --------------------------------------------------------
__int64 frame_dummy()
{
  return register_tm_clones();
}

//----- (000091A8) --------------------------------------------------------
int __cdecl main(int argc, const char **argv, const char **envp)
{
  _BYTE v4[64]; // [sp+0h] [bp+0h] BYREF
  int v5; // [sp+40h] [bp+40h]
  int v6; // [sp+44h] [bp+44h]

  v6 = -1;
  memset(v4, 0, sizeof(v4));
  v5 = cgpu_init();
  if ( v5 >= 0 )
  {
    display_arguments();
    while ( 1 )
    {
      lseek(key_fd, 0, 0);
      v5 = read(key_fd, v4, 0x40u);
      if ( v5 > 0 )
      {
        puts("\nBegin singleAsicTest_BM1740\n");
        singleBoardTest_V9_BM1740();
      }
      sleep(1u);
    }
  }
  return v5;
}
// 41820: using guessed type int key_fd;

//----- (0000922C) --------------------------------------------------------
unsigned __int64 __fastcall load64(unsigned __int8 *a1)
{
  __int64 v2; // [sp+0h] [bp+0h]
  __int64 v3; // [sp+8h] [bp+8h]
  __int64 v4; // [sp+10h] [bp+10h]
  __int64 v5; // [sp+18h] [bp+18h]

  HIDWORD(v5) = a1[4];
  LODWORD(v5) = 0;
  HIDWORD(v4) = a1[5] << 8;
  LODWORD(v4) = 0;
  HIDWORD(v3) = a1[6] << 16;
  LODWORD(v3) = 0;
  HIDWORD(v2) = a1[7] << 24;
  LODWORD(v2) = 0;
  return *a1 | (unsigned __int64)(a1[1] << 8) | (a1[2] << 16) | (a1[3] << 24) | v5 | v4 | v3 | v2;
}

//----- (00009384) --------------------------------------------------------
_DWORD *__fastcall store32(_DWORD *result, int a2)
{
  *result = a2;
  return result;
}

//----- (000093E8) --------------------------------------------------------
_DWORD *__fastcall store64(_DWORD *result, int a2, int a3, int a4)
{
  *result = a3;
  result[1] = a4;
  return result;
}

//----- (00009520) --------------------------------------------------------
unsigned __int64 __fastcall rotr64(unsigned __int64 a1, char a2)
{
  __int64 v2; // r4

  HIDWORD(v2) = (HIDWORD(a1) << (64 - a2)) | ((_DWORD)a1 << (32 - a2)) | ((unsigned int)a1 >> (a2 - 32));
  LODWORD(v2) = (_DWORD)a1 << (64 - a2);
  return v2 | (a1 >> a2);
}

//----- (00009594) --------------------------------------------------------
int __fastcall secure_zero_memory(int a1, int a2)
{
  return memset_v_4649(a1, 0, a2);
}
// 30214: using guessed type int (__fastcall *memset_v_4649)(_DWORD, _DWORD, _DWORD);

//----- (000095B8) --------------------------------------------------------
int __fastcall blake2b_set_lastnode(int a1)
{
  *(_QWORD *)(a1 + 88) = -1LL;
  return 0;
}

//----- (000095DC) --------------------------------------------------------
bool __fastcall blake2b_is_lastblock(int a1)
{
  return *(_QWORD *)(a1 + 80) != 0LL;
}

//----- (00009604) --------------------------------------------------------
int __fastcall blake2b_set_lastblock(int a1)
{
  if ( *(_BYTE *)(a1 + 356) )
    blake2b_set_lastnode(a1);
  *(_QWORD *)(a1 + 80) = -1LL;
  return 0;
}

//----- (00009638) --------------------------------------------------------
int __fastcall blake2b_increment_counter(int a1, unsigned __int64 a2)
{
  *(_QWORD *)(a1 + 64) += a2;
  *(_QWORD *)(a1 + 72) += *(_QWORD *)(a1 + 64) < a2;
  return 0;
}

//----- (00009698) --------------------------------------------------------
int __fastcall blake2b_init0(void *a1)
{
  int i; // [sp+Ch] [bp+Ch]

  memset(a1, 0, 0x168u);
  for ( i = 0; i <= 7; ++i )
    *((_QWORD *)a1 + i) = blake2b_IV[i];
  return 0;
}
// 2BA98: using guessed type _QWORD blake2b_IV[8];

//----- (000096E8) --------------------------------------------------------
int __fastcall blake2b_init_param(void *a1, int a2)
{
  __int64 v2; // r4
  unsigned int i; // [sp+Ch] [bp+Ch]

  blake2b_init0(a1);
  for ( i = 0; i <= 7; ++i )
  {
    v2 = *((_QWORD *)a1 + i);
    *((_QWORD *)a1 + i) = load64((unsigned __int8 *)(a2 + 8 * i)) ^ v2;
  }
  return 0;
}

//----- (0000974C) --------------------------------------------------------
int __fastcall blake2b_init(void *a1, unsigned __int8 a2)
{
  int v3; // r1
  char v6[4]; // [sp+8h] [bp+8h] BYREF
  int v7; // [sp+Ch] [bp+Ch] BYREF
  int v8; // [sp+10h] [bp+10h] BYREF
  char v9; // [sp+18h] [bp+18h]
  char v10; // [sp+19h] [bp+19h]
  _BYTE v11[46]; // [sp+1Ah] [bp+1Ah] BYREF

  if ( !a2 || a2 > 0x40u )
    return -1;
  v6[0] = a2;
  v6[1] = 0;
  v6[2] = 1;
  v6[3] = 1;
  store32(&v7, 0);
  store64(&v8, v3, 0, 0);
  v9 = 0;
  v10 = 0;
  memset(v11, 0, sizeof(v11));
  return blake2b_init_param(a1, (int)v6);
}
// 9798: variable 'v3' is possibly undefined

//----- (000097EC) --------------------------------------------------------
int __fastcall blake2b_init_key(void *a1, unsigned __int8 a2, const void *a3, unsigned __int8 a4)
{
  int v5; // r1
  char v10[128]; // [sp+10h] [bp+10h] BYREF
  char v11[4]; // [sp+90h] [bp+90h] BYREF
  int v12; // [sp+94h] [bp+94h] BYREF
  int v13; // [sp+98h] [bp+98h] BYREF
  char v14; // [sp+A0h] [bp+A0h]
  char v15; // [sp+A1h] [bp+A1h]
  _BYTE v16[46]; // [sp+A2h] [bp+A2h] BYREF

  if ( !a2 || a2 > 0x40u )
    return -1;
  if ( !a3 || !a4 || a4 > 0x40u )
    return -1;
  v11[0] = a2;
  v11[1] = a4;
  v11[2] = 1;
  v11[3] = 1;
  store32(&v12, 0);
  store64(&v13, v5, 0, 0);
  v14 = 0;
  v15 = 0;
  memset(v16, 0, sizeof(v16));
  if ( blake2b_init_param(a1, (int)v11) < 0 )
    return -1;
  memset(v10, 0, sizeof(v10));
  memcpy(v10, a3, a4);
  blake2b_update((int)a1, v10, 0x80uLL);
  secure_zero_memory((int)v10, 128);
  return 0;
}
// 985C: variable 'v5' is possibly undefined

//----- (00009900) --------------------------------------------------------
int __fastcall blake2b_compress(_QWORD *a1, int a2)
{
  unsigned __int64 v2; // r0
  __int64 v6; // [sp+8h] [bp+8h]
  __int64 v7; // [sp+10h] [bp+10h]
  __int64 v8; // [sp+18h] [bp+18h]
  __int64 v9; // [sp+20h] [bp+20h]
  unsigned __int64 v10; // [sp+28h] [bp+28h]
  unsigned __int64 v11; // [sp+30h] [bp+30h]
  unsigned __int64 v12; // [sp+38h] [bp+38h]
  unsigned __int64 v13; // [sp+40h] [bp+40h]
  __int64 v14; // [sp+48h] [bp+48h]
  __int64 v15; // [sp+50h] [bp+50h]
  __int64 v16; // [sp+58h] [bp+58h]
  __int64 v17; // [sp+60h] [bp+60h]
  unsigned __int64 v18; // [sp+68h] [bp+68h]
  unsigned __int64 v19; // [sp+70h] [bp+70h]
  unsigned __int64 v20; // [sp+78h] [bp+78h]
  unsigned __int64 v21; // [sp+80h] [bp+80h]
  __int64 v22; // [sp+88h] [bp+88h]
  __int64 v23; // [sp+90h] [bp+90h]
  __int64 v24; // [sp+98h] [bp+98h]
  __int64 v25; // [sp+A0h] [bp+A0h]
  __int64 v26; // [sp+A8h] [bp+A8h]
  __int64 v27; // [sp+B0h] [bp+B0h]
  __int64 v28; // [sp+B8h] [bp+B8h]
  __int64 v29; // [sp+C0h] [bp+C0h]
  __int64 v30; // [sp+C8h] [bp+C8h]
  __int64 v31; // [sp+D0h] [bp+D0h]
  __int64 v32; // [sp+D8h] [bp+D8h]
  __int64 v33; // [sp+E0h] [bp+E0h]
  __int64 v34; // [sp+E8h] [bp+E8h]
  __int64 v35; // [sp+F0h] [bp+F0h]
  __int64 v36; // [sp+F8h] [bp+F8h]
  __int64 v37; // [sp+100h] [bp+100h]
  int i; // [sp+10Ch] [bp+10Ch]

  for ( i = 0; i <= 15; ++i )
  {
    v2 = load64((unsigned __int8 *)(a2 + 8 * i));
    *(&v22 + i) = v2;
  }
  for ( i = 0; i <= 7; ++i )
    *(&v6 + i) = a1[i];
  v14 = blake2b_IV[0];
  v15 = blake2b_IV[1];
  v16 = blake2b_IV[2];
  v17 = blake2b_IV[3];
  v18 = blake2b_IV[4] ^ a1[8];
  v19 = blake2b_IV[5] ^ a1[9];
  v20 = blake2b_IV[6] ^ a1[10];
  v21 = blake2b_IV[7] ^ a1[11];
  v6 += *(&v22 + (unsigned __int8)blake2b_sigma) + v10;
  v18 = rotr64(v6 ^ v18, 32);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 24);
  v6 += v23 + v10;
  v18 = rotr64(v6 ^ v18, 16);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 63);
  v7 += v24 + v11;
  v19 = rotr64(v7 ^ v19, 32);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 24);
  v7 += v25 + v11;
  v19 = rotr64(v7 ^ v19, 16);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 63);
  v8 += v26 + v12;
  v20 = rotr64(v8 ^ v20, 32);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 24);
  v8 += v27 + v12;
  v20 = rotr64(v8 ^ v20, 16);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 63);
  v9 += v28 + v13;
  v21 = rotr64(v9 ^ v21, 32);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 24);
  v9 += v29 + v13;
  v21 = rotr64(v9 ^ v21, 16);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 63);
  v6 += v30 + v11;
  v21 = rotr64(v6 ^ v21, 32);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 24);
  v6 += v31 + v11;
  v21 = rotr64(v6 ^ v21, 16);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 63);
  v7 += v32 + v12;
  v18 = rotr64(v7 ^ v18, 32);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 24);
  v7 += v33 + v12;
  v18 = rotr64(v7 ^ v18, 16);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 63);
  v8 += v34 + v13;
  v19 = rotr64(v8 ^ v19, 32);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 24);
  v8 += v35 + v13;
  v19 = rotr64(v8 ^ v19, 16);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 63);
  v9 += v36 + v10;
  v20 = rotr64(v9 ^ v20, 32);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 24);
  v9 += v37 + v10;
  v20 = rotr64(v9 ^ v20, 16);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 63);
  v6 += v36 + v10;
  v18 = rotr64(v6 ^ v18, 32);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 24);
  v6 += v32 + v10;
  v18 = rotr64(v6 ^ v18, 16);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 63);
  v7 += v26 + v11;
  v19 = rotr64(v7 ^ v19, 32);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 24);
  v7 += v30 + v11;
  v19 = rotr64(v7 ^ v19, 16);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 63);
  v8 += v31 + v12;
  v20 = rotr64(v8 ^ v20, 32);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 24);
  v8 += v37 + v12;
  v20 = rotr64(v8 ^ v20, 16);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 63);
  v9 += v35 + v13;
  v21 = rotr64(v9 ^ v21, 32);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 24);
  v9 += v28 + v13;
  v21 = rotr64(v9 ^ v21, 16);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 63);
  v6 += v23 + v11;
  v21 = rotr64(v6 ^ v21, 32);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 24);
  v6 += v34 + v11;
  v21 = rotr64(v6 ^ v21, 16);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 63);
  v7 += v22 + v12;
  v18 = rotr64(v7 ^ v18, 32);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 24);
  v7 += v24 + v12;
  v18 = rotr64(v7 ^ v18, 16);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 63);
  v8 += v33 + v13;
  v19 = rotr64(v8 ^ v19, 32);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 24);
  v8 += v29 + v13;
  v19 = rotr64(v8 ^ v19, 16);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 63);
  v9 += v27 + v10;
  v20 = rotr64(v9 ^ v20, 32);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 24);
  v9 += v25 + v10;
  v20 = rotr64(v9 ^ v20, 16);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 63);
  v6 += v33 + v10;
  v18 = rotr64(v6 ^ v18, 32);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 24);
  v6 += v30 + v10;
  v18 = rotr64(v6 ^ v18, 16);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 63);
  v7 += v34 + v11;
  v19 = rotr64(v7 ^ v19, 32);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 24);
  v7 += v22 + v11;
  v19 = rotr64(v7 ^ v19, 16);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 63);
  v8 += v27 + v12;
  v20 = rotr64(v8 ^ v20, 32);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 24);
  v8 += v24 + v12;
  v20 = rotr64(v8 ^ v20, 16);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 63);
  v9 += v37 + v13;
  v21 = rotr64(v9 ^ v21, 32);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 24);
  v9 += v35 + v13;
  v21 = rotr64(v9 ^ v21, 16);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 63);
  v6 += v32 + v11;
  v21 = rotr64(v6 ^ v21, 32);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 24);
  v6 += v36 + v11;
  v21 = rotr64(v6 ^ v21, 16);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 63);
  v7 += v25 + v12;
  v18 = rotr64(v7 ^ v18, 32);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 24);
  v7 += v28 + v12;
  v18 = rotr64(v7 ^ v18, 16);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 63);
  v8 += v29 + v13;
  v19 = rotr64(v8 ^ v19, 32);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 24);
  v8 += v23 + v13;
  v19 = rotr64(v8 ^ v19, 16);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 63);
  v9 += v31 + v10;
  v20 = rotr64(v9 ^ v20, 32);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 24);
  v9 += v26 + v10;
  v20 = rotr64(v9 ^ v20, 16);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 63);
  v6 += v29 + v10;
  v18 = rotr64(v6 ^ v18, 32);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 24);
  v6 += v31 + v10;
  v18 = rotr64(v6 ^ v18, 16);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 63);
  v7 += v25 + v11;
  v19 = rotr64(v7 ^ v19, 32);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 24);
  v7 += v23 + v11;
  v19 = rotr64(v7 ^ v19, 16);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 63);
  v8 += v35 + v12;
  v20 = rotr64(v8 ^ v20, 32);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 24);
  v8 += v34 + v12;
  v20 = rotr64(v8 ^ v20, 16);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 63);
  v9 += v33 + v13;
  v21 = rotr64(v9 ^ v21, 32);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 24);
  v9 += v36 + v13;
  v21 = rotr64(v9 ^ v21, 16);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 63);
  v6 += v24 + v11;
  v21 = rotr64(v6 ^ v21, 32);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 24);
  v6 += v28 + v11;
  v21 = rotr64(v6 ^ v21, 16);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 63);
  v7 += v27 + v12;
  v18 = rotr64(v7 ^ v18, 32);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 24);
  v7 += v32 + v12;
  v18 = rotr64(v7 ^ v18, 16);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 63);
  v8 += v26 + v13;
  v19 = rotr64(v8 ^ v19, 32);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 24);
  v8 += v22 + v13;
  v19 = rotr64(v8 ^ v19, 16);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 63);
  v9 += v37 + v10;
  v20 = rotr64(v9 ^ v20, 32);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 24);
  v9 += v30 + v10;
  v20 = rotr64(v9 ^ v20, 16);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 63);
  v6 += v31 + v10;
  v18 = rotr64(v6 ^ v18, 32);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 24);
  v6 += v22 + v10;
  v18 = rotr64(v6 ^ v18, 16);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 63);
  v7 += v27 + v11;
  v19 = rotr64(v7 ^ v19, 32);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 24);
  v7 += v29 + v11;
  v19 = rotr64(v7 ^ v19, 16);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 63);
  v8 += v24 + v12;
  v20 = rotr64(v8 ^ v20, 32);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 24);
  v8 += v26 + v12;
  v20 = rotr64(v8 ^ v20, 16);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 63);
  v9 += v32 + v13;
  v21 = rotr64(v9 ^ v21, 32);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 24);
  v9 += v37 + v13;
  v21 = rotr64(v9 ^ v21, 16);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 63);
  v6 += v36 + v11;
  v21 = rotr64(v6 ^ v21, 32);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 24);
  v6 += v23 + v11;
  v21 = rotr64(v6 ^ v21, 16);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 63);
  v7 += v33 + v12;
  v18 = rotr64(v7 ^ v18, 32);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 24);
  v7 += v34 + v12;
  v18 = rotr64(v7 ^ v18, 16);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 63);
  v8 += v28 + v13;
  v19 = rotr64(v8 ^ v19, 32);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 24);
  v8 += v30 + v13;
  v19 = rotr64(v8 ^ v19, 16);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 63);
  v9 += v25 + v10;
  v20 = rotr64(v9 ^ v20, 32);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 24);
  v9 += v35 + v10;
  v20 = rotr64(v9 ^ v20, 16);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 63);
  v6 += v24 + v10;
  v18 = rotr64(v6 ^ v18, 32);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 24);
  v6 += v34 + v10;
  v18 = rotr64(v6 ^ v18, 16);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 63);
  v7 += v28 + v11;
  v19 = rotr64(v7 ^ v19, 32);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 24);
  v7 += v32 + v11;
  v19 = rotr64(v7 ^ v19, 16);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 63);
  v8 += v22 + v12;
  v20 = rotr64(v8 ^ v20, 32);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 24);
  v8 += v33 + v12;
  v20 = rotr64(v8 ^ v20, 16);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 63);
  v9 += v30 + v13;
  v21 = rotr64(v9 ^ v21, 32);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 24);
  v9 += v25 + v13;
  v21 = rotr64(v9 ^ v21, 16);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 63);
  v6 += v26 + v11;
  v21 = rotr64(v6 ^ v21, 32);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 24);
  v6 += v35 + v11;
  v21 = rotr64(v6 ^ v21, 16);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 63);
  v7 += v29 + v12;
  v18 = rotr64(v7 ^ v18, 32);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 24);
  v7 += v27 + v12;
  v18 = rotr64(v7 ^ v18, 16);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 63);
  v8 += v37 + v13;
  v19 = rotr64(v8 ^ v19, 32);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 24);
  v8 += v36 + v13;
  v19 = rotr64(v8 ^ v19, 16);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 63);
  v9 += v23 + v10;
  v20 = rotr64(v9 ^ v20, 32);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 24);
  v9 += v31 + v10;
  v20 = rotr64(v9 ^ v20, 16);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 63);
  v6 += v34 + v10;
  v18 = rotr64(v6 ^ v18, 32);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 24);
  v6 += v27 + v10;
  v18 = rotr64(v6 ^ v18, 16);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 63);
  v7 += v23 + v11;
  v19 = rotr64(v7 ^ v19, 32);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 24);
  v7 += v37 + v11;
  v19 = rotr64(v7 ^ v19, 16);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 63);
  v8 += v36 + v12;
  v20 = rotr64(v8 ^ v20, 32);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 24);
  v8 += v35 + v12;
  v20 = rotr64(v8 ^ v20, 16);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 63);
  v9 += v26 + v13;
  v21 = rotr64(v9 ^ v21, 32);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 24);
  v9 += v32 + v13;
  v21 = rotr64(v9 ^ v21, 16);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 63);
  v6 += v22 + v11;
  v21 = rotr64(v6 ^ v21, 32);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 24);
  v6 += v29 + v11;
  v21 = rotr64(v6 ^ v21, 16);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 63);
  v7 += v28 + v12;
  v18 = rotr64(v7 ^ v18, 32);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 24);
  v7 += v25 + v12;
  v18 = rotr64(v7 ^ v18, 16);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 63);
  v8 += v31 + v13;
  v19 = rotr64(v8 ^ v19, 32);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 24);
  v8 += v24 + v13;
  v19 = rotr64(v8 ^ v19, 16);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 63);
  v9 += v30 + v10;
  v20 = rotr64(v9 ^ v20, 32);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 24);
  v9 += v33 + v10;
  v20 = rotr64(v9 ^ v20, 16);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 63);
  v6 += v35 + v10;
  v18 = rotr64(v6 ^ v18, 32);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 24);
  v6 += v33 + v10;
  v18 = rotr64(v6 ^ v18, 16);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 63);
  v7 += v29 + v11;
  v19 = rotr64(v7 ^ v19, 32);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 24);
  v7 += v36 + v11;
  v19 = rotr64(v7 ^ v19, 16);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 63);
  v8 += v34 + v12;
  v20 = rotr64(v8 ^ v20, 32);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 24);
  v8 += v23 + v12;
  v20 = rotr64(v8 ^ v20, 16);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 63);
  v9 += v25 + v13;
  v21 = rotr64(v9 ^ v21, 32);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 24);
  v9 += v31 + v13;
  v21 = rotr64(v9 ^ v21, 16);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 63);
  v6 += v27 + v11;
  v21 = rotr64(v6 ^ v21, 32);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 24);
  v6 += v22 + v11;
  v21 = rotr64(v6 ^ v21, 16);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 63);
  v7 += v37 + v12;
  v18 = rotr64(v7 ^ v18, 32);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 24);
  v7 += v26 + v12;
  v18 = rotr64(v7 ^ v18, 16);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 63);
  v8 += v30 + v13;
  v19 = rotr64(v8 ^ v19, 32);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 24);
  v8 += v28 + v13;
  v19 = rotr64(v8 ^ v19, 16);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 63);
  v9 += v24 + v10;
  v20 = rotr64(v9 ^ v20, 32);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 24);
  v9 += v32 + v10;
  v20 = rotr64(v9 ^ v20, 16);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 63);
  v6 += v28 + v10;
  v18 = rotr64(v6 ^ v18, 32);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 24);
  v6 += v37 + v10;
  v18 = rotr64(v6 ^ v18, 16);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 63);
  v7 += v36 + v11;
  v19 = rotr64(v7 ^ v19, 32);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 24);
  v7 += v31 + v11;
  v19 = rotr64(v7 ^ v19, 16);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 63);
  v8 += v33 + v12;
  v20 = rotr64(v8 ^ v20, 32);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 24);
  v8 += v25 + v12;
  v20 = rotr64(v8 ^ v20, 16);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 63);
  v9 += v22 + v13;
  v21 = rotr64(v9 ^ v21, 32);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 24);
  v9 += v30 + v13;
  v21 = rotr64(v9 ^ v21, 16);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 63);
  v6 += v34 + v11;
  v21 = rotr64(v6 ^ v21, 32);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 24);
  v6 += v24 + v11;
  v21 = rotr64(v6 ^ v21, 16);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 63);
  v7 += v35 + v12;
  v18 = rotr64(v7 ^ v18, 32);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 24);
  v7 += v29 + v12;
  v18 = rotr64(v7 ^ v18, 16);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 63);
  v8 += v23 + v13;
  v19 = rotr64(v8 ^ v19, 32);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 24);
  v8 += v26 + v13;
  v19 = rotr64(v8 ^ v19, 16);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 63);
  v9 += v32 + v10;
  v20 = rotr64(v9 ^ v20, 32);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 24);
  v9 += v27 + v10;
  v20 = rotr64(v9 ^ v20, 16);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 63);
  v6 += v32 + v10;
  v18 = rotr64(v6 ^ v18, 32);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 24);
  v6 += v24 + v10;
  v18 = rotr64(v6 ^ v18, 16);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 63);
  v7 += v30 + v11;
  v19 = rotr64(v7 ^ v19, 32);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 24);
  v7 += v26 + v11;
  v19 = rotr64(v7 ^ v19, 16);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 63);
  v8 += v29 + v12;
  v20 = rotr64(v8 ^ v20, 32);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 24);
  v8 += v28 + v12;
  v20 = rotr64(v8 ^ v20, 16);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 63);
  v9 += v23 + v13;
  v21 = rotr64(v9 ^ v21, 32);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 24);
  v9 += v27 + v13;
  v21 = rotr64(v9 ^ v21, 16);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 63);
  v6 += v37 + v11;
  v21 = rotr64(v6 ^ v21, 32);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 24);
  v6 += v33 + v11;
  v21 = rotr64(v6 ^ v21, 16);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 63);
  v7 += v31 + v12;
  v18 = rotr64(v7 ^ v18, 32);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 24);
  v7 += v36 + v12;
  v18 = rotr64(v7 ^ v18, 16);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 63);
  v8 += v25 + v13;
  v19 = rotr64(v8 ^ v19, 32);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 24);
  v8 += v34 + v13;
  v19 = rotr64(v8 ^ v19, 16);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 63);
  v9 += v35 + v10;
  v20 = rotr64(v9 ^ v20, 32);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 24);
  v9 += v22 + v10;
  v20 = rotr64(v9 ^ v20, 16);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 63);
  v6 += v22 + v10;
  v18 = rotr64(v6 ^ v18, 32);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 24);
  v6 += v23 + v10;
  v18 = rotr64(v6 ^ v18, 16);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 63);
  v7 += v24 + v11;
  v19 = rotr64(v7 ^ v19, 32);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 24);
  v7 += v25 + v11;
  v19 = rotr64(v7 ^ v19, 16);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 63);
  v8 += v26 + v12;
  v20 = rotr64(v8 ^ v20, 32);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 24);
  v8 += v27 + v12;
  v20 = rotr64(v8 ^ v20, 16);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 63);
  v9 += v28 + v13;
  v21 = rotr64(v9 ^ v21, 32);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 24);
  v9 += v29 + v13;
  v21 = rotr64(v9 ^ v21, 16);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 63);
  v6 += v30 + v11;
  v21 = rotr64(v6 ^ v21, 32);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 24);
  v6 += v31 + v11;
  v21 = rotr64(v6 ^ v21, 16);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 63);
  v7 += v32 + v12;
  v18 = rotr64(v7 ^ v18, 32);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 24);
  v7 += v33 + v12;
  v18 = rotr64(v7 ^ v18, 16);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 63);
  v8 += v34 + v13;
  v19 = rotr64(v8 ^ v19, 32);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 24);
  v8 += v35 + v13;
  v19 = rotr64(v8 ^ v19, 16);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 63);
  v9 += v36 + v10;
  v20 = rotr64(v9 ^ v20, 32);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 24);
  v9 += v37 + v10;
  v20 = rotr64(v9 ^ v20, 16);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 63);
  v6 += v36 + v10;
  v18 = rotr64(v6 ^ v18, 32);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 24);
  v6 += v32 + v10;
  v18 = rotr64(v6 ^ v18, 16);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 63);
  v7 += v26 + v11;
  v19 = rotr64(v7 ^ v19, 32);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 24);
  v7 += v30 + v11;
  v19 = rotr64(v7 ^ v19, 16);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 63);
  v8 += v31 + v12;
  v20 = rotr64(v8 ^ v20, 32);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 24);
  v8 += v37 + v12;
  v20 = rotr64(v8 ^ v20, 16);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 63);
  v9 += v35 + v13;
  v21 = rotr64(v9 ^ v21, 32);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 24);
  v9 += v28 + v13;
  v21 = rotr64(v9 ^ v21, 16);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 63);
  v6 += v23 + v11;
  v21 = rotr64(v6 ^ v21, 32);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 24);
  v6 += v34 + v11;
  v21 = rotr64(v6 ^ v21, 16);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 63);
  v7 += v22 + v12;
  v18 = rotr64(v7 ^ v18, 32);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 24);
  v7 += v24 + v12;
  v18 = rotr64(v7 ^ v18, 16);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 63);
  v8 += v33 + v13;
  v19 = rotr64(v8 ^ v19, 32);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 24);
  v8 += v29 + v13;
  v19 = rotr64(v8 ^ v19, 16);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 63);
  v9 += v27 + v10;
  v20 = rotr64(v9 ^ v20, 32);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 24);
  v9 += v25 + v10;
  v20 = rotr64(v9 ^ v20, 16);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 63);
  for ( i = 0; i <= 7; ++i )
    a1[i] ^= *(&v6 + i + 8) ^ *(&v6 + i);
  return 0;
}
// 2BA98: using guessed type _QWORD blake2b_IV[8];
// 2BAA0: using guessed type _QWORD;
// 2BAA8: using guessed type _QWORD;
// 2BAB0: using guessed type _QWORD;
// 2BAD8: using guessed type char blake2b_sigma;

//----- (000124A4) --------------------------------------------------------
int __fastcall blake2b_update(int a1, char *a2, unsigned __int64 a3)
{
  size_t n; // [sp+10h] [bp+10h]
  int v8; // [sp+14h] [bp+14h]

  while ( a3 )
  {
    v8 = *(_DWORD *)(a1 + 352);
    n = 256 - v8;
    if ( (unsigned int)(256 - v8) >= a3 )
    {
      memcpy((void *)(a1 + v8 + 96), a2, a3);
      *(_DWORD *)(a1 + 352) += a3;
      a2 += a3;
      a3 = 0LL;
    }
    else
    {
      memcpy((void *)(a1 + v8 + 96), a2, n);
      *(_DWORD *)(a1 + 352) += n;
      blake2b_increment_counter(a1, 0x80uLL);
      blake2b_compress((_QWORD *)a1, a1 + 96);
      memcpy((void *)(a1 + 96), (const void *)(a1 + 224), 0x80u);
      *(_DWORD *)(a1 + 352) -= 128;
      a2 += n;
      a3 -= n;
    }
  }
  return 0;
}

//----- (000125A4) --------------------------------------------------------
int __fastcall blake2b_final(int a1, void *a2, unsigned __int8 a3)
{
  _QWORD v8[8]; // [sp+14h] [bp+14h] BYREF
  int i; // [sp+54h] [bp+54h]

  memset(v8, 0, sizeof(v8));
  if ( !a2 || !a3 || a3 > 0x40u )
    return -1;
  if ( blake2b_is_lastblock(a1) )
    return -1;
  if ( *(_DWORD *)(a1 + 352) > 0x80u )
  {
    blake2b_increment_counter(a1, 0x80uLL);
    blake2b_compress((_QWORD *)a1, a1 + 96);
    *(_DWORD *)(a1 + 352) -= 128;
    memcpy((void *)(a1 + 96), (const void *)(a1 + 224), *(_DWORD *)(a1 + 352));
  }
  blake2b_increment_counter(a1, *(unsigned int *)(a1 + 352));
  blake2b_set_lastblock(a1);
  memset((void *)(a1 + *(_DWORD *)(a1 + 352) + 96), 0, 256 - *(_DWORD *)(a1 + 352));
  blake2b_compress((_QWORD *)a1, a1 + 96);
  for ( i = 0; i <= 7; ++i )
    store64(&v8[i], (int)&v8[i], *(_DWORD *)(a1 + 8 * i), *(_DWORD *)(a1 + 8 * i + 4));
  memcpy(a2, v8, a3);
  return 0;
}

//----- (000126C8) --------------------------------------------------------
int __fastcall blake2b(void *a1, char *a2, const void *a3, unsigned __int8 a4, unsigned __int64 a5, unsigned __int8 a6)
{
  _BYTE v11[364]; // [sp+10h] [bp+10h] BYREF

  if ( !a2 && a5 )
    return -1;
  if ( !a1 )
    return -1;
  if ( !a3 && a6 )
    return -1;
  if ( !a4 || a4 > 0x40u )
    return -1;
  if ( a6 <= 0x40u )
  {
    if ( a6 )
    {
      if ( blake2b_init_key(v11, a4, a3, a6) < 0 )
        return -1;
    }
    else if ( blake2b_init(v11, a4) < 0 )
    {
      return -1;
    }
    blake2b_update((int)v11, a2, a5);
    blake2b_final((int)v11, a1, a4);
    return 0;
  }
  return -1;
}
// 126C8: using guessed type unsigned __int64 anonymous_0;

//----- (000127D0) --------------------------------------------------------
unsigned int __fastcall midd_send_work_to_hardware(unsigned __int8 a1, unsigned __int8 *a2, int a3)
{
  int v7; // [sp+14h] [bp+14h]

  v7 = bm1740_pack_work_pkg((int)a2, a3);
  if ( v7 <= 0 )
    return -1;
  else
    return uart_send(a1, a2, v7);
}

//----- (00012814) --------------------------------------------------------
int __fastcall midd_recv_work(char *a1, unsigned int a2)
{
  unsigned int v6; // [sp+Ch] [bp+Ch]

  if ( dword_622F0 && (v6 = rt_ringbuffer_data_len(bm_nonce_rb), v6 < a2) )
    return v6;
  else
    return rt_ringbuffer_get((int)bm_nonce_rb, a1, a2);
}
// 622E8: using guessed type _WORD bm_nonce_rb[4];
// 622F0: using guessed type int dword_622F0;

//----- (00012880) --------------------------------------------------------
int __fastcall midd_recv_regdata(char *a1, unsigned int a2)
{
  unsigned int v6; // [sp+Ch] [bp+Ch]

  if ( dword_62420 && (v6 = rt_ringbuffer_data_len(bm_reg_rb), v6 < a2) )
    return v6;
  else
    return rt_ringbuffer_get((int)bm_reg_rb, a1, a2);
}
// 62418: using guessed type _WORD bm_reg_rb[4];
// 62420: using guessed type int dword_62420;

//----- (000128EC) --------------------------------------------------------
int __fastcall midd_recv_comm_from_rb(char *a1, unsigned int a2)
{
  unsigned int v6; // [sp+Ch] [bp+Ch]

  if ( dword_62388 && (v6 = rt_ringbuffer_data_len(bm_comm_rb), v6 < a2) )
    return v6;
  else
    return rt_ringbuffer_get((int)bm_comm_rb, a1, a2);
}
// 62380: using guessed type _WORD bm_comm_rb[4];
// 62388: using guessed type int dword_62388;

//----- (00012958) --------------------------------------------------------
unsigned int __fastcall midd_ioctl(unsigned __int8 a1, int a2, char *a3)
{
  unsigned __int8 v8[256]; // [sp+14h] [bp+14h] BYREF
  int v9; // [sp+114h] [bp+114h]

  memset(v8, 0, sizeof(v8));
  v9 = bm1740_pack_ioctl_pkg((int)v8, 0x100u, a2, a3);
  if ( v9 >= 0 )
    return uart_send(a1, v8, v9);
  else
    return v9;
}

//----- (000129D4) --------------------------------------------------------
__int64 now()
{
  struct timeval v1; // [sp+0h] [bp+0h] BYREF

  gettimeofday(&v1, 0);
  return v1.tv_usec + 1000000LL * v1.tv_sec;
}

//----- (00012A28) --------------------------------------------------------
int __fastcall target_zero_cal(int a1)
{
  _BYTE v3[32]; // [sp+8h] [bp+8h] BYREF
  int k; // [sp+28h] [bp+28h]
  int j; // [sp+2Ch] [bp+2Ch]
  int i; // [sp+30h] [bp+30h]
  int v7; // [sp+34h] [bp+34h]

  v7 = 0;
  memset(v3, 0, sizeof(v3));
  for ( i = 0; i <= 31; ++i )
    v3[i] = *(_BYTE *)(a1 + 31 - i);
  for ( j = 0; j <= 31; ++j )
  {
    for ( k = 7; k >= 0; --k )
    {
      if ( bit_read((int)&v3[j], k) )
        return v7;
      ++v7;
    }
  }
  return v7;
}

//----- (00012AE0) --------------------------------------------------------
int __fastcall targetValidator(const void *a1, const void *a2)
{
  _BYTE v5[32]; // [sp+Ch] [bp+Ch] BYREF
  _BYTE v6[32]; // [sp+2Ch] [bp+2Ch] BYREF
  _WORD v7[745]; // [sp+4Ch] [bp+4Ch] BYREF
  char v8; // [sp+61Eh] [bp+61Eh]

  v7[744] = 16637;
  v8 = 5;
  memset(v7, 0, 0x5CFu);
  memset(v6, 0, sizeof(v6));
  memset(v5, 0, sizeof(v5));
  memcpy(v7, a1, 0x8Cu);
  v7[70] = 16637;
  LOBYTE(v7[71]) = 5;
  memcpy((char *)&v7[71] + 1, a2, 0x540u);
  Sha256_Onestep(v7, 1487, v6);
  Sha256_Onestep(v6, 32, v5);
  return target_zero_cal((int)v5);
}

//----- (00012BF8) --------------------------------------------------------
int __fastcall bm1740_handle_nonce(unsigned __int8 *a1)
{
  int v1; // r2
  char v4[100]; // [sp+28h] [bp+8h] BYREF
  char v5[256]; // [sp+8Ch] [bp+6Ch] BYREF
  int v6[3]; // [sp+18Ch] [bp+16Ch] BYREF
  _BYTE v7[364]; // [sp+198h] [bp+178h] BYREF
  _BYTE v8[1344]; // [sp+304h] [bp+2E4h] BYREF
  char v9[140]; // [sp+844h] [bp+824h] BYREF
  __int64 v10; // [sp+8D0h] [bp+8B0h]
  int v11; // [sp+8DCh] [bp+8BCh]
  int v12; // [sp+8E0h] [bp+8C0h]
  int v13; // [sp+8E4h] [bp+8C4h]
  int v14; // [sp+8E8h] [bp+8C8h]
  int m; // [sp+8ECh] [bp+8CCh]
  int k; // [sp+8F0h] [bp+8D0h]
  int v17; // [sp+8F4h] [bp+8D4h]
  int j; // [sp+8F8h] [bp+8D8h]
  int i; // [sp+8FCh] [bp+8DCh]

  memset(v8, 0, sizeof(v8));
  v14 = 0;
  memcpy(v9, &g_test_header, sizeof(v9));
  memcpy(&v9[116], a1 + 1352, 4u);
  memcpy(v8, a1, sizeof(v8));
  v6[0] = 200;
  v6[1] = 9;
  v6[2] = (int)v7;
  digestInit(v7, 200, 9);
  blake2b_update((int)v7, v9, 0x8CuLL);
  v13 = now();
  v14 = sortValidator(v6, (int)v8);
  v12 = now();
  v11 = targetValidator(v9, v8);
  if ( v14 || v11 < g_tm )
  {
    printf("valid = %d, ticket mask=%d\n", v14, v11);
  }
  else
  {
    printf("receive a valid nonce tm=%d\n", v11);
    ++asic_nonce_6391;
    v10 = now();
    if ( (unsigned __int64)(v10 - time_first_6394) > 0x39386FF )
    {
      time_first_6394 = v10;
      v1 = k_6393;
      asic_nonce_table_6392[k_6393] = asic_nonce_6391;
      k_6393 = v1 + 1;
      if ( v1 + 1 > 9 )
        k_6393 = 0;
      memset(v4, 0, sizeof(v4));
      sprintf(
        v4,
        "hashrate-table:%d %d %d %d %d %d %d %d %d %d",
        asic_nonce_table_6392[0],
        dword_31250,
        dword_31254,
        dword_31258,
        dword_3125C,
        dword_31260,
        dword_31264,
        dword_31268,
        dword_3126C,
        dword_31270);
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf(v5, 0x100u, "%s\n", v4);
        applog(3, v5);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf(v5, 0x100u, "cpu calcute diff time = %d\n", v12 - v13);
        applog(3, v5);
      }
      asic_nonce_6391 = 0;
    }
    for ( i = 0; i <= 0; ++i )
    {
      for ( j = 0; j <= 3; ++j )
      {
        if ( a1[1344] == addr_interval * j )
          ++nonce_num_each_asic[4 * i + j];
      }
    }
    v17 = 0;
    for ( k = 0; k <= 0; ++k )
    {
      for ( m = 0; m <= 3; ++m )
      {
        if ( use_syslog || opt_log_output || opt_log_level >= 0 )
        {
          snprintf(v5, 0x100u, "receive a valid chainid=%d asicid=%d nonce=%d\n", k, m, nonce_num_each_asic[4 * k + m]);
          applog(0, v5);
        }
        if ( nonce_num_each_asic[4 * k + m] > 5u )
          ++v17;
      }
    }
    if ( v17 > 3 )
      nonce_ok = 1;
  }
  return 0;
}
// 30218: using guessed type int addr_interval;
// 3021C: using guessed type int g_tm;
// 3089C: using guessed type int opt_log_level;
// 31208: using guessed type _DWORD nonce_num_each_asic[4];
// 31230: using guessed type int nonce_ok;
// 3123C: using guessed type int asic_nonce_6391;
// 31248: using guessed type int k_6393;
// 3124C: using guessed type int asic_nonce_table_6392[];
// 31250: using guessed type int dword_31250;
// 31254: using guessed type int dword_31254;
// 31258: using guessed type int dword_31258;
// 3125C: using guessed type int dword_3125C;
// 31260: using guessed type int dword_31260;
// 31264: using guessed type int dword_31264;
// 31268: using guessed type int dword_31268;
// 3126C: using guessed type int dword_3126C;
// 31270: using guessed type int dword_31270;
// 31294: using guessed type char use_syslog;
// 31297: using guessed type char opt_log_output;

//----- (000130D8) --------------------------------------------------------
int __fastcall bm1740_verify_nonce_integrality(_BYTE *a1)
{
  char v4[258]; // [sp+14h] [bp+Ch] BYREF
  unsigned __int16 v5; // [sp+116h] [bp+10Eh] BYREF
  int ii; // [sp+118h] [bp+110h]
  void *dest; // [sp+11Ch] [bp+114h]
  int n; // [sp+120h] [bp+118h]
  int m; // [sp+124h] [bp+11Ch]
  int k; // [sp+128h] [bp+120h]
  int j; // [sp+12Ch] [bp+124h]
  int i; // [sp+130h] [bp+128h]
  int v13; // [sp+134h] [bp+12Ch]

  v13 = 0;
  for ( i = 0; i <= 15; ++i )
  {
    v5 = CRC16(&g_nonce_list[91 * i], 0x59u);
    v5 = HIBYTE(v5) | (v5 << 8);
    if ( memcmp(&v5, &g_nonce_list[91 * i + 89], 2u) )
    {
      if ( use_syslog || opt_log_output || opt_log_level >= 0 )
      {
        snprintf(
          v4,
          0x100u,
          "%s CRC error. cal-crc=%x, chip-crc=%x\n",
          "bm1740_verify_nonce_integrality",
          v5,
          g_nonce_list[91 * i + 89]);
        applog(0, v4);
      }
      v13 |= 1 << i;
    }
  }
  for ( j = 0; j <= 15; ++j )
  {
    if ( (g_nonce_list[91 * j] & 0xF) != j )
    {
      if ( use_syslog || opt_log_output || opt_log_level >= 0 )
      {
        snprintf(v4, 0x100u, "nonce is not continous i=%d\n", j);
        applog(0, v4);
      }
      return -1;
    }
  }
  for ( k = 0; k <= 14; ++k )
  {
    if ( g_nonce_list[91 * k + 1] != g_nonce_list[91 * k + 92] )
    {
      if ( use_syslog || opt_log_output || opt_log_level >= 0 )
      {
        snprintf(
          v4,
          0x100u,
          "chip_addr is different %02x != %02x\n",
          g_nonce_list[91 * k + 1],
          g_nonce_list[91 * k + 92]);
        applog(0, v4);
      }
      return -1;
    }
  }
  for ( m = 0; m <= 14; ++m )
  {
    if ( g_nonce_list[91 * m + 2] != g_nonce_list[91 * m + 93] )
    {
      if ( use_syslog || opt_log_output || opt_log_level >= 0 )
      {
        snprintf(v4, 0x100u, "workID is different %02x != %02x\n", g_nonce_list[91 * m + 2], g_nonce_list[91 * m + 93]);
        applog(0, v4);
      }
      return -1;
    }
  }
  for ( n = 0; ; ++n )
  {
    if ( n > 14 )
    {
      dest = a1;
      for ( ii = 0; ii <= 14; ++ii )
      {
        memcpy(dest, &g_nonce_list[91 * ii + 4], 0x55u);
        dest = (char *)dest + 85;
      }
      memcpy(dest, &unk_62285, 0x45u);
      memcpy(a1 + 1352, &unk_622D6, 4u);
      a1[1344] = byte_62282;
      a1[1345] = byte_62283;
      a1[1346] = byte_62284;
      a1[1347] = byte_622CD;
      memcpy(a1 + 1348, &unk_622CE, 4u);
      return v13;
    }
    if ( g_nonce_list[91 * n + 3] != g_nonce_list[91 * n + 94] )
      break;
  }
  if ( use_syslog || opt_log_output || opt_log_level >= 0 )
  {
    snprintf(v4, 0x100u, "nonceID is different %02x != %02x\n", g_nonce_list[91 * n + 3], g_nonce_list[91 * n + 94]);
    applog(0, v4);
  }
  return -1;
}
// 3089C: using guessed type int opt_log_level;
// 31294: using guessed type char use_syslog;
// 31297: using guessed type char opt_log_output;
// 61D2C: using guessed type unsigned __int8 g_nonce_list[1366];
// 62282: using guessed type char byte_62282;
// 62283: using guessed type char byte_62283;
// 62284: using guessed type char byte_62284;
// 622CD: using guessed type char byte_622CD;

//----- (00013614) --------------------------------------------------------
int __fastcall bm1740_combine_one_nonce(_BYTE *a1, _BYTE *a2, unsigned __int8 a3)
{
  char v8[256]; // [sp+10h] [bp+10h] BYREF
  char v9[4]; // [sp+110h] [bp+110h] BYREF
  int v10; // [sp+114h] [bp+114h]
  char v11; // [sp+11Ah] [bp+11Ah]
  unsigned __int8 v12; // [sp+11Bh] [bp+11Bh]
  int v13; // [sp+11Ch] [bp+11Ch]

  v12 = *a2 & 0xF;
  v11 = a2[3];
  v13 = 1;
  if ( v11 == a1[1346] || retransmit_6460 != 1 )
  {
    memcpy(&g_nonce_list[91 * v12], a2, 0x5Bu);
    if ( v12 == 15 && !retransmit_6460 )
    {
      v13 = bm1740_verify_nonce_integrality(a1);
      if ( v13 > 0 && g_txok_en == 1 )
      {
        v9[1] = 0;
        v9[0] = a1[1344];
        v10 = v13;
        midd_ioctl(g_chain[10 * a3], 12, v9);
        retransmit_6460 = 1;
        if ( use_syslog || opt_log_output || opt_log_level > 2 )
        {
          strcpy(v8, "enable retransmit\n");
          applog(3, v8);
        }
      }
    }
    return v13;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      strcpy(v8, "retransmit == 1\n");
      applog(3, v8);
    }
    retransmit_6460 = 0;
    v13 = bm1740_verify_nonce_integrality(a1);
    memcpy(&g_nonce_list[91 * v12], a2, 0x5Bu);
    return v13;
  }
}
// 3089C: using guessed type int opt_log_level;
// 31224: using guessed type int g_txok_en;
// 31238: using guessed type int retransmit_6460;
// 31294: using guessed type char use_syslog;
// 31297: using guessed type char opt_log_output;
// 61D04: using guessed type int g_chain[10];
// 61D2C: using guessed type unsigned __int8 g_nonce_list[1366];

//----- (00013820) --------------------------------------------------------
void __noreturn bm1740_get_nonce()
{
  pthread_t v0; // r0
  char v1[259]; // [sp+4h] [bp+4h] BYREF
  unsigned __int8 v2; // [sp+107h] [bp+107h] BYREF
  char v3[200]; // [sp+108h] [bp+108h] BYREF
  unsigned __int8 v4[1356]; // [sp+1D0h] [bp+1D0h] BYREF
  int v5; // [sp+71Ch] [bp+71Ch]

  memset(v3, 0, sizeof(v3));
  v5 = 0;
  v0 = pthread_self();
  pthread_detach(v0);
  while ( 1 )
  {
    while ( 1 )
    {
      midd_recv_work(v3, 0x5Du);
      midd_recv_work((char *)&v2, 1u);
      v5 = bm1740_combine_one_nonce(v4, &v3[2], v2);
      if ( v5 )
        break;
      bm1740_handle_nonce(v4);
    }
    if ( v5 < 0 && (use_syslog || opt_log_output || opt_log_level > 0) )
    {
      strcpy(v1, "receive a error nonce\n");
      applog(1, v1);
    }
  }
}
// 13820: using guessed type void __noreturn bm1740_get_nonce();
// 3089C: using guessed type int opt_log_level;
// 31294: using guessed type char use_syslog;
// 31297: using guessed type char opt_log_output;

//----- (000138FC) --------------------------------------------------------
void __noreturn bm1740_get_reg()
{
  int *v0; // r0
  char *v1; // r0
  pthread_t v2; // r0
  char v3[259]; // [sp+10h] [bp+0h] BYREF
  char v4; // [sp+113h] [bp+103h] BYREF
  int v5; // [sp+114h] [bp+104h]
  int v6; // [sp+118h] [bp+108h]
  int v7; // [sp+11Ch] [bp+10Ch]
  char v8[2]; // [sp+120h] [bp+110h] BYREF
  unsigned __int8 v9; // [sp+122h] [bp+112h]
  unsigned int v10; // [sp+123h] [bp+113h]
  unsigned __int8 v11; // [sp+127h] [bp+117h]
  FILE *stream; // [sp+12Ch] [bp+11Ch]

  stream = fopen("freg.txt", "a+");
  if ( !stream )
  {
    if ( use_syslog || opt_log_output || opt_log_level >= 0 )
    {
      v0 = _errno_location();
      v1 = strerror(*v0);
      snprintf(v3, 0x100u, "open freg failed %s\n", v1);
      applog(0, v3);
    }
    exit(1);
  }
  v2 = pthread_self();
  pthread_detach(v2);
  while ( 1 )
  {
    midd_recv_regdata(v8, 9u);
    midd_recv_regdata(&v4, 1u);
    v7 = 3;
    LOBYTE(v5) = v4;
    BYTE1(v5) = v11;
    BYTE2(v5) = v9;
    v6 = _byteswap_ulong(v10);
    add_reg_item(v5, v6, 3);
    fprintf(
      stream,
      "addr:%02x data=%02x%02x%02x%02x chip=%02x\n",
      v9,
      (unsigned __int8)v10,
      BYTE1(v10),
      BYTE2(v10),
      HIBYTE(v10),
      v11);
    fflush(stream);
  }
}
// 138FC: using guessed type void __noreturn bm1740_get_reg();
// 3089C: using guessed type int opt_log_level;
// 31294: using guessed type char use_syslog;
// 31297: using guessed type char opt_log_output;
// 138FC: using guessed type char anonymous_0[2];

//----- (00013A34) --------------------------------------------------------
unsigned int __fastcall i2c_status(unsigned __int8 a1, unsigned __int8 a2)
{
  unsigned __int8 v7[4]; // [sp+8h] [bp+8h] BYREF
  int v8; // [sp+Ch] [bp+Ch]
  char v9[8]; // [sp+14h] [bp+14h] BYREF
  int v10; // [sp+1Ch] [bp+1Ch]

  v10 = 0;
  v9[1] = 0;
  v9[0] = a2;
  v9[2] = 32;
  midd_ioctl(g_chain[10 * a1], 0, v9);
  usleep((__useconds_t)&unk_30D40);
  v7[0] = a1;
  v7[1] = a2;
  v7[2] = 32;
  do
  {
    usleep(0x186A0u);
    if ( read_reg_item(v7) > 0 )
      return v8 & 0x80000000;
  }
  while ( v10++ <= 2 );
  return -1;
}
// 61D04: using guessed type int g_chain[10];

//----- (00013AD8) --------------------------------------------------------
int __fastcall i2c_recv(unsigned __int8 a1, unsigned __int8 a2, char a3, char a4, _BYTE *a5)
{
  char v12[256]; // [sp+10h] [bp+8h] BYREF
  unsigned __int8 v13[12]; // [sp+110h] [bp+108h] BYREF
  char v14[8]; // [sp+11Ch] [bp+114h] BYREF
  char v15[4]; // [sp+124h] [bp+11Ch] BYREF
  int v16; // [sp+128h] [bp+120h]
  int v17; // [sp+12Ch] [bp+124h]

  v17 = 0;
  v16 = i2c_status(a1, a2);
  if ( v16 <= 0 )
  {
    if ( v16 >= 0 )
    {
      if ( use_syslog || opt_log_output || opt_log_level >= 0 )
      {
        snprintf(v12, 0x100u, "%s[%d]i2c is idle\n", "i2c_recv", 470);
        applog(0, v12);
      }
      v15[1] = 0;
      v15[0] = a2;
      v15[2] = a3;
      v15[3] = a4;
      midd_ioctl(g_chain[10 * a1], 7, v15);
      usleep((__useconds_t)&unk_493E0);
      v16 = i2c_status(a1, a2);
      if ( v16 <= 0 )
      {
        if ( v16 >= 0 )
        {
          if ( use_syslog || opt_log_output || opt_log_level >= 0 )
          {
            snprintf(v12, 0x100u, "%s[%d]-i2c is idle\n", "i2c_recv", 489);
            applog(0, v12);
          }
          v14[1] = 0;
          v14[0] = a2;
          v14[2] = 32;
          midd_ioctl(g_chain[10 * a1], 0, v14);
          usleep(0x7A120u);
          v13[0] = a1;
          v13[1] = a2;
          v13[2] = 32;
          do
          {
            usleep(0x186A0u);
            if ( read_reg_item(v13) > 0 )
            {
              *a5 = v13[4];
              return 1;
            }
          }
          while ( v17++ <= 2 );
          return -1;
        }
        else
        {
          if ( use_syslog || opt_log_output || opt_log_level >= 0 )
          {
            snprintf(v12, 0x100u, "%s[%d]-not received the i2c response\n", "i2c_recv", 486);
            applog(0, v12);
          }
          return -1;
        }
      }
      else
      {
        if ( use_syslog || opt_log_output || opt_log_level >= 0 )
        {
          snprintf(v12, 0x100u, "%s[%d]-i2c is busy\n", "i2c_recv", 483);
          applog(0, v12);
        }
        return -1;
      }
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level >= 0 )
      {
        snprintf(v12, 0x100u, "%s[%d]not received the i2c response\n", "i2c_recv", 467);
        applog(0, v12);
      }
      return -1;
    }
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level >= 0 )
    {
      snprintf(v12, 0x100u, "%s[%d]i2c is busy\n", "i2c_recv", 464);
      applog(0, v12);
    }
    return -1;
  }
}
// 3089C: using guessed type int opt_log_level;
// 31294: using guessed type char use_syslog;
// 31297: using guessed type char opt_log_output;
// 61D04: using guessed type int g_chain[10];

//----- (00013E88) --------------------------------------------------------
unsigned int __fastcall i2c_send(unsigned __int8 a1, char a2, char a3, char a4, char a5)
{
  char v6[8]; // [sp+8h] [bp+8h] BYREF

  v6[1] = 0;
  v6[0] = a2;
  v6[2] = a3;
  v6[3] = a4;
  v6[4] = a5;
  return midd_ioctl(g_chain[10 * a1], 8, v6);
}
// 61D04: using guessed type int g_chain[10];

//----- (00013ED8) --------------------------------------------------------
int asic_num_calculate()
{
  int result; // r0
  char v1[8]; // [sp+4h] [bp+4h] BYREF
  unsigned __int8 v2[4]; // [sp+Ch] [bp+Ch] BYREF
  int v3; // [sp+10h] [bp+10h]
  int j; // [sp+18h] [bp+18h]
  int i; // [sp+1Ch] [bp+1Ch]

  v1[1] = 1;
  v1[0] = 0;
  v1[2] = 0;
  for ( i = 0; i <= 0; ++i )
    midd_ioctl(g_chain[10 * i], 0, v1);
  result = usleep(0xF4240u);
  for ( i = 0; i <= 0; ++i )
  {
    v2[0] = i;
    v2[1] = 0;
    v2[2] = 0;
    v3 = 0;
    for ( j = 0; j <= 3; ++j )
    {
      result = read_reg_item(v2);
      if ( result > 0 )
      {
        ++asic_num[i];
        result = printf("chain_id %d, asic_id %d, value %08x\n", i, j, v3);
      }
    }
  }
  return result;
}
// 31218: using guessed type int asic_num[];
// 61D04: using guessed type int g_chain[10];

//----- (00013FAC) --------------------------------------------------------
int __fastcall calculate_asic_number(unsigned int a1)
{
  char v3[256]; // [sp+Ch] [bp+Ch] BYREF
  int v4; // [sp+10Ch] [bp+10Ch]

  v4 = 0;
  if ( a1 == 1 )
    return 1;
  if ( a1 == 2 )
    return 2;
  if ( a1 > 2 && a1 <= 4 )
    return 4;
  if ( a1 > 4 && a1 <= 8 )
    return 8;
  if ( a1 > 8 && a1 <= 0x10 )
    return 16;
  if ( a1 > 0x10 && a1 <= 0x20 )
    return 32;
  if ( a1 > 0x20 && a1 <= 0x40 )
    return 64;
  if ( a1 > 0x40 && a1 <= 0x80 )
    return 128;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 3) )
  {
    snprintf(v3, 0x100u, "actual_asic_number = %d, but it is error\n", a1);
    applog(4, v3);
  }
  return -1;
}
// 3089C: using guessed type int opt_log_level;
// 31294: using guessed type char use_syslog;
// 31296: using guessed type char opt_debug;
// 31297: using guessed type char opt_log_output;

//----- (000140E0) --------------------------------------------------------
int asic_addr_interval()
{
  int result; // r0
  char v1[256]; // [sp+4h] [bp+4h] BYREF
  int v2; // [sp+104h] [bp+104h]

  v2 = calculate_asic_number(4u);
  result = 256 / v2;
  addr_interval = 256 / v2;
  sensor_chip_addr = 0;
  dword_31220 = 3 * (256 / v2);
  if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    snprintf(v1, 0x100u, "addr-interval %d\n", addr_interval);
    return applog(3, v1);
  }
  return result;
}
// 30218: using guessed type int addr_interval;
// 3089C: using guessed type int opt_log_level;
// 3121C: using guessed type int sensor_chip_addr;
// 31220: using guessed type int dword_31220;
// 31294: using guessed type char use_syslog;
// 31297: using guessed type char opt_log_output;

//----- (0001418C) --------------------------------------------------------
int __fastcall set_frequency(int result)
{
  int v1; // [sp+Ch] [bp+4h]
  char v2[256]; // [sp+14h] [bp+Ch] BYREF
  char v3[4]; // [sp+114h] [bp+10Ch] BYREF
  int v4; // [sp+118h] [bp+110h]
  int i; // [sp+11Ch] [bp+114h]

  v1 = result;
  v3[1] = 1;
  v3[0] = 0;
  v4 = result;
  for ( i = 0; i <= 0; ++i )
  {
    result = midd_ioctl(g_chain[10 * i], 25, v3);
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf(v2, 0x100u, "chain %d freq %u\n", i, v1);
      result = applog(3, v2);
    }
  }
  return result;
}
// 3089C: using guessed type int opt_log_level;
// 31294: using guessed type char use_syslog;
// 31297: using guessed type char opt_log_output;
// 61D04: using guessed type int g_chain[10];

//----- (00014250) --------------------------------------------------------
int __fastcall set_ticket_mask(int result)
{
  int v1; // [sp+Ch] [bp+4h]
  char v2[256]; // [sp+14h] [bp+Ch] BYREF
  char v3[4]; // [sp+114h] [bp+10Ch] BYREF
  int v4; // [sp+118h] [bp+110h]
  int i; // [sp+11Ch] [bp+114h]

  v1 = result;
  v3[1] = 1;
  v3[0] = 0;
  v4 = result;
  g_tm = result;
  for ( i = 0; i <= 0; ++i )
  {
    result = midd_ioctl(g_chain[10 * i], 9, v3);
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf(v2, 0x100u, "chain %d ticket-mask %08x\n", i, v1);
      result = applog(3, v2);
    }
  }
  return result;
}
// 3021C: using guessed type int g_tm;
// 3089C: using guessed type int opt_log_level;
// 31294: using guessed type char use_syslog;
// 31297: using guessed type char opt_log_output;
// 61D04: using guessed type int g_chain[10];

//----- (00014324) --------------------------------------------------------
int set_address()
{
  int result; // r0
  char v1[256]; // [sp+Ch] [bp+4h] BYREF
  int v2; // [sp+10Ch] [bp+104h] BYREF
  int j; // [sp+110h] [bp+108h]
  int i; // [sp+114h] [bp+10Ch]

  v2 = 0;
  j = 0;
  for ( i = 0; i <= 0; ++i )
  {
    midd_ioctl(g_chain[10 * i], 20, 0);
    result = usleep(0x186A0u);
    for ( j = 0; j <= 3; ++j )
    {
      v2 = j * addr_interval;
      midd_ioctl(g_chain[10 * i], 19, (char *)&v2);
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf(v1, 0x100u, "chain %d chip %d addres %08x\n", i, j, v2);
        applog(3, v1);
      }
      result = usleep(0xC350u);
    }
  }
  return result;
}
// 30218: using guessed type int addr_interval;
// 3089C: using guessed type int opt_log_level;
// 31294: using guessed type char use_syslog;
// 31297: using guessed type char opt_log_output;
// 61D04: using guessed type int g_chain[10];

//----- (00014444) --------------------------------------------------------
int __fastcall set_core_timeout(int result)
{
  int v1; // [sp+Ch] [bp+4h]
  char v2[256]; // [sp+14h] [bp+Ch] BYREF
  char v3[4]; // [sp+114h] [bp+10Ch] BYREF
  int v4; // [sp+118h] [bp+110h]
  int i; // [sp+11Ch] [bp+114h]

  v1 = result;
  v3[1] = 1;
  v3[0] = 0;
  v4 = result;
  for ( i = 0; i <= 0; ++i )
  {
    result = midd_ioctl(g_chain[10 * i], 14, v3);
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf(v2, 0x100u, "chain %d core-timeout %08x\n", i, v1);
      result = applog(3, v2);
    }
  }
  return result;
}
// 3089C: using guessed type int opt_log_level;
// 31294: using guessed type char use_syslog;
// 31297: using guessed type char opt_log_output;
// 61D04: using guessed type int g_chain[10];

//----- (00014508) --------------------------------------------------------
unsigned int __fastcall set_timeout(unsigned int result)
{
  unsigned __int16 v1; // [sp+Eh] [bp+6h]
  char v2[256]; // [sp+14h] [bp+Ch] BYREF
  char v3[4]; // [sp+114h] [bp+10Ch] BYREF
  int v4; // [sp+118h] [bp+110h]
  int i; // [sp+11Ch] [bp+114h]

  v1 = result;
  v3[1] = 1;
  v3[0] = 0;
  v4 = (unsigned __int16)result;
  for ( i = 0; i <= 0; ++i )
  {
    result = midd_ioctl(g_chain[10 * i], 31, v3);
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf(v2, 0x100u, "chain %d timeout %08x\n", i, v1);
      result = applog(3, v2);
    }
  }
  return result;
}
// 3089C: using guessed type int opt_log_level;
// 31294: using guessed type char use_syslog;
// 31297: using guessed type char opt_log_output;
// 61D04: using guessed type int g_chain[10];

//----- (000145D0) --------------------------------------------------------
int set_i2c_enable()
{
  int result; // r0
  char v1[256]; // [sp+Ch] [bp+4h] BYREF
  char v2[4]; // [sp+10Ch] [bp+104h] BYREF
  int j; // [sp+110h] [bp+108h]
  int i; // [sp+114h] [bp+10Ch]

  j = 0;
  for ( i = 0; i <= 0; ++i )
  {
    for ( j = 0; j <= 1; ++j )
    {
      v2[1] = 0;
      v2[0] = sensor_chip_addr[j];
      midd_ioctl(g_chain[10 * i], 5, v2);
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf(v1, 0x100u, "enable i2c, chain %d sensor %08x\n", i, j);
        applog(3, v1);
      }
      result = usleep(0xC350u);
    }
  }
  return result;
}
// 3089C: using guessed type int opt_log_level;
// 3121C: using guessed type int sensor_chip_addr[];
// 31294: using guessed type char use_syslog;
// 31297: using guessed type char opt_log_output;
// 61D04: using guessed type int g_chain[10];

//----- (000146BC) --------------------------------------------------------
void __fastcall __noreturn midd_recv_comm(int a1)
{
  pthread_t v1; // r0
  char v2[1024]; // [sp+8h] [bp+8h] BYREF
  int v3; // [sp+408h] [bp+408h]
  int v4; // [sp+40Ch] [bp+40Ch]

  v4 = a1;
  memset(v2, 0, sizeof(v2));
  v1 = pthread_self();
  pthread_detach(v1);
  while ( 1 )
  {
    usleep(0xBB8u);
    v3 = uart_receive(g_chain[10 * *(unsigned __int8 *)(v4 + 4)], (int)v2, 1u);
    rt_ringbuffer_put((int)&bm_comm_rb, v2, v3);
  }
}
// 61D04: using guessed type int g_chain[10];

//----- (00014748) --------------------------------------------------------
void __fastcall __noreturn midd_dispatch_packet(int a1)
{
  pthread_t v1; // r0
  int v3; // [sp+14h] [bp+Ch] BYREF
  int v4; // [sp+18h] [bp+10h] BYREF
  char v5[1024]; // [sp+1Ch] [bp+14h] BYREF
  _BYTE v6[1024]; // [sp+41Ch] [bp+414h] BYREF
  char v7[2048]; // [sp+81Ch] [bp+814h] BYREF
  int v8; // [sp+101Ch] [bp+1014h]
  int v9; // [sp+1020h] [bp+1018h]
  int v10; // [sp+1024h] [bp+101Ch]
  int v11; // [sp+1028h] [bp+1020h]
  int v12; // [sp+102Ch] [bp+1024h]
  int v13; // [sp+1030h] [bp+1028h]
  char *v14; // [sp+1034h] [bp+102Ch]

  memset(v7, 0, sizeof(v7));
  memset(v6, 0, sizeof(v6));
  v14 = v6;
  memset(v5, 0, sizeof(v5));
  v12 = a1;
  v11 = *(unsigned __int8 *)(a1 + 4);
  v10 = 0;
  v4 = 0;
  v13 = 1;
  v3 = 1;
  v9 = 0;
  v1 = pthread_self();
  pthread_detach(v1);
  while ( 1 )
  {
    do
    {
      usleep(0x2710u);
      v8 = midd_recv_comm_from_rb(v7, v13);
    }
    while ( v8 != v13 );
    v9 = bm1740_parse_respond_len(v7, v13, &v3);
    if ( v9 )
    {
      if ( v9 == 1 )
      {
        memcpy(v14, v7, v13);
        v14 += v13;
        v13 = v3;
      }
      else
      {
        memcpy(v14, v7, v13);
        v14 += v13;
        v10 = bm1740_parse_respond_pkg(v6, v14 - v6, &v4, v5, 0x400u);
        if ( v10 > 0 )
        {
          v5[v10++] = *(_BYTE *)(v12 + 4);
          if ( v4 )
          {
            if ( v4 == 2 )
              rt_ringbuffer_put((int)bm_reg_rb, v5, v10);
            else
              printf("unknow receive type %d\n", v4);
          }
          else
          {
            rt_ringbuffer_put((int)bm_nonce_rb, v5, v10);
          }
        }
        v14 = v6;
        v13 = 1;
      }
    }
    else
    {
      v13 = 1;
      v14 = v6;
    }
  }
}
// 622E8: using guessed type _WORD bm_nonce_rb[4];
// 62418: using guessed type _WORD bm_reg_rb[4];

//----- (00014A40) --------------------------------------------------------
int bm1740_app_init()
{
  int v0; // r1
  int i; // [sp+10h] [bp+10h]
  int j; // [sp+14h] [bp+14h]

  inited = 1;
  init_fpga();
  check_chain();
  for ( i = 0; i <= 0; ++i )
  {
    if ( !gChain_exist[i] )
    {
      printf("chain %d can't find\n", v0);
      exit(1);
    }
  }
  reset_hash_board();
  bm1740_soc_init();
  rb_nonce = (int)malloc(0x24540u);
  rb_reg = (int)malloc(0x384u);
  rb_comm = (int)malloc(0x5000u);
  if ( !rb_nonce || !rb_reg || !rb_comm )
  {
    printf("%s malloc failed\n", "bm1740_app_init");
    exit(1);
  }
  memset((void *)rb_nonce, 0, 0x24540u);
  memset((void *)rb_reg, 0, 0x384u);
  memset((void *)rb_comm, 0, 0x5000u);
  rt_ringbuffer_init((int)&bm_nonce_rb, rb_nonce, 17728, 0);
  rt_ringbuffer_init((int)&bm_reg_rb, rb_reg, 900, 0);
  rt_ringbuffer_init((int)&bm_comm_rb, rb_comm, 20480, 0);
  reg_scan_init();
  if ( pthread_create((pthread_t *)&p_get_nonce_back, 0, (void *(*)(void *))bm1740_get_nonce, 0) )
  {
    puts("create get_nonce_back thread failed");
    return -1;
  }
  else if ( pthread_create((pthread_t *)&p_get_reg_back, 0, (void *(*)(void *))bm1740_get_reg, 0) )
  {
    puts("create get_reg_back thread failed");
    return -1;
  }
  else
  {
    for ( j = 0; j <= 0; ++j )
    {
      g_chain[10 * j] = *((unsigned __int8 *)&gChain_fd + j);
      LOBYTE(g_chain[10 * j + 1]) = j;
      if ( pthread_create(
             (pthread_t *)&g_chain[10 * j + 6],
             0,
             (void *(*)(void *))midd_dispatch_packet,
             &g_chain[10 * j]) )
      {
        puts("create p_dispatch failed");
        return -1;
      }
      if ( pthread_create((pthread_t *)&g_chain[10 * j + 7], 0, (void *(*)(void *))midd_recv_comm, &g_chain[10 * j]) )
      {
        puts("create p_read_comm failed");
        return -1;
      }
    }
    return 0;
  }
}
// 14A94: variable 'v0' is possibly undefined
// 13820: using guessed type void __noreturn bm1740_get_nonce();
// 138FC: using guessed type void __noreturn bm1740_get_reg();
// 146BC: using guessed type void __noreturn midd_recv_comm();
// 14748: using guessed type void __noreturn midd_dispatch_packet();
// 3122C: using guessed type int inited;
// 31774: using guessed type _BYTE gChain_exist[4];
// 61D04: using guessed type int g_chain[10];
// 622DC: using guessed type int rb_reg;
// 622E0: using guessed type int p_get_reg_back;
// 62378: using guessed type int rb_nonce;
// 6237C: using guessed type int rb_comm;
// 62410: using guessed type int p_get_nonce_back;

//----- (00014D50) --------------------------------------------------------
void bm1740_app_exit()
{
  int i; // [sp+4h] [bp+4h]

  reg_scan_exit();
  for ( i = 0; i <= 0; ++i )
  {
    pthread_cancel(p_get_reg_back);
    pthread_cancel(p_get_nonce_back);
    pthread_cancel(g_chain[10 * i + 6]);
    pthread_cancel(g_chain[10 * i + 7]);
  }
  rt_ringbuffer_lock_destory((int)bm_nonce_rb);
  rt_ringbuffer_lock_destory((int)bm_reg_rb);
  rt_ringbuffer_lock_destory((int)bm_comm_rb);
  free((void *)rb_nonce);
  free((void *)rb_reg);
  free((void *)rb_comm);
}
// 61D04: using guessed type int g_chain[10];
// 622DC: using guessed type int rb_reg;
// 622E0: using guessed type int p_get_reg_back;
// 622E8: using guessed type _WORD bm_nonce_rb[4];
// 62378: using guessed type int rb_nonce;
// 6237C: using guessed type int rb_comm;
// 62380: using guessed type _WORD bm_comm_rb[4];
// 62410: using guessed type int p_get_nonce_back;
// 62418: using guessed type _WORD bm_reg_rb[4];

//----- (00014E24) --------------------------------------------------------
unsigned int send_work_example()
{
  _BYTE v1[140]; // [sp+0h] [bp+0h] BYREF
  unsigned __int8 v2[2]; // [sp+8Ch] [bp+8Ch] BYREF
  char v3; // [sp+8Eh] [bp+8Eh]
  char v4; // [sp+8Fh] [bp+8Fh]
  _BYTE v5[140]; // [sp+90h] [bp+90h] BYREF
  unsigned __int8 v6[280]; // [sp+120h] [bp+120h] BYREF

  memcpy(
    v6,
    "040000005a0995c5fe39ee678b290a2636ec3c32e26bfafb5711ee687ad3750e00000000bbd08c45cf29d96c4f1e5b9d136f2f0ffc22d6be511e"
    "204773afee519a2478db00000000000000000000000000000000000000000000000000000000000000008dc7205ab0f0131c0000000000000000"
    "aaaaaaaa27c5d2a66bda09d1000000000000000000000000",
    sizeof(v6));
  v3 &= 0xEEu;
  v4 = 0;
  memset(v1, 0, sizeof(v1));
  hex2bin(v1, v6, 140);
  memcpy(v5, v1, sizeof(v5));
  memcpy(&g_test_header, v1, 0x8Cu);
  return midd_send_work_to_hardware(g_chain[0], v2, 146);
}
// 61D04: using guessed type int g_chain[10];
// 14E24: using guessed type unsigned __int8 anonymous_0[2];

//----- (00014ED8) --------------------------------------------------------
int read_sensor_test()
{
  int result; // r0
  unsigned __int8 v1; // [sp+Fh] [bp+7h] BYREF
  int j; // [sp+10h] [bp+8h]
  int i; // [sp+14h] [bp+Ch]

  set_i2c_enable();
  result = usleep(0x7A120u);
  v1 = 0;
  for ( i = 0; i <= 0; ++i )
  {
    for ( j = 0; j <= 1; ++j )
    {
      result = i2c_recv(i, sensor_chip_addr[j], 76, 1, &v1);
      if ( v1 )
      {
        ++sensor_ok;
        result = printf("i2c i2c_reg_addr=%02x\n", v1);
      }
    }
  }
  return result;
}
// 3121C: using guessed type int sensor_chip_addr[];
// 31234: using guessed type int sensor_ok;

//----- (00014F70) --------------------------------------------------------
int bm1740_app_test()
{
  const char *v1; // r2
  const char *v2; // r3
  int v4; // [sp+4h] [bp+4h]

  v4 = 10;
  asic_num[0] = 0;
  set_core_timeout(0x100000);
  asic_num_calculate();
  asic_addr_interval();
  set_address();
  asic_num[0] = 0;
  sleep(3u);
  asic_num_calculate();
  sleep(1u);
  puts("Send Work Test...\n");
  send_work_example();
  nonce_ok = 0;
  memset(&nonce_num_each_asic, 0, 0x10u);
  puts("Tempture Sensor Test...\n");
  sensor_ok = 0;
  do
  {
    sleep(1u);
    printf("waiting %d seconds\n", v4);
    if ( nonce_ok == 1 && sensor_ok == 1 )
      break;
  }
  while ( v4-- > 0 );
  if ( nonce_ok )
    v1 = "yes";
  else
    v1 = "no";
  if ( sensor_ok )
    v2 = "yes";
  else
    v2 = "no";
  printf("nonce sensor [%s %s]\n", v1, v2);
  return 0;
}
// 31218: using guessed type int asic_num[];
// 31230: using guessed type int nonce_ok;
// 31234: using guessed type int sensor_ok;

//----- (000150A0) --------------------------------------------------------
int __fastcall get_reg_auto_test(char a1)
{
  int v1; // r3
  char v3[4]; // [sp+8h] [bp+8h] BYREF
  int v4; // [sp+Ch] [bp+Ch]

  v3[1] = 1;
  v3[0] = 0;
  v3[2] = a1;
  v4 = 0;
  midd_ioctl(g_chain[0], 0, v3);
  usleep((__useconds_t)&unk_493E0);
  return v1;
}
// 150DE: variable 'v1' is possibly undefined
// 61D04: using guessed type int g_chain[10];

//----- (000150E8) --------------------------------------------------------
int bm1740_app_test_manual()
{
  _BYTE v2[140]; // [sp+4h] [bp+4h] BYREF
  unsigned __int8 v3[2]; // [sp+90h] [bp+90h] BYREF
  char v4; // [sp+92h] [bp+92h]
  char v5; // [sp+93h] [bp+93h]
  _BYTE v6[140]; // [sp+94h] [bp+94h] BYREF
  char v7[280]; // [sp+124h] [bp+124h] BYREF
  char v8[4]; // [sp+23Ch] [bp+23Ch] BYREF
  int v9; // [sp+240h] [bp+240h]
  unsigned __int8 v10[4]; // [sp+244h] [bp+244h] BYREF
  int v11; // [sp+248h] [bp+248h]
  int v12; // [sp+250h] [bp+250h] BYREF
  char v13[4]; // [sp+254h] [bp+254h] BYREF
  int v14; // [sp+258h] [bp+258h]
  int v15; // [sp+25Ch] [bp+25Ch] BYREF
  int v16; // [sp+260h] [bp+260h] BYREF
  int v17; // [sp+264h] [bp+264h] BYREF
  __int16 v18; // [sp+268h] [bp+268h] BYREF
  int v19; // [sp+26Ch] [bp+26Ch]
  int i; // [sp+270h] [bp+270h]
  int v21; // [sp+274h] [bp+274h]

  v21 = 1;
  while ( v21 )
  {
    v18 = 0;
    sleep(1u);
    setbuf((FILE *)stdin, 0);
    printf("\nInput test paramter:");
    _isoc99_fscanf(stdin, "%s", &v18);
    switch ( (char)v18 )
    {
      case 'a':
        asic_num_calculate();
        asic_addr_interval();
        set_address();
        sleep(1u);
        asic_num_calculate();
        break;
      case 'c':
        set_core_timeout(0x100000);
        usleep((__useconds_t)&unk_30D40);
        send_work_example();
        break;
      case 'g':
        puts("write reg: input reg [regaddr]");
        _isoc99_scanf("%x", &v12);
        v8[1] = 1;
        v8[0] = 0;
        v8[2] = v12;
        v9 = 0;
        midd_ioctl(g_chain[0], 0, v8);
        usleep((__useconds_t)&unk_493E0);
        v10[0] = 0;
        v10[1] = 0;
        v10[2] = v12;
        v11 = 0;
        read_reg_item(v10);
        printf("Reg Value=%08x\n", v11);
        break;
      case 'h':
        puts("no usage right now");
        break;
      case 'k':
        v19 = 100;
        while ( v19-- > 0 )
        {
          get_reg_auto_test(0);
          sleep(2u);
        }
        break;
      case 'm':
        puts("Input Frequenfy:");
        _isoc99_scanf("%d", &v17);
        if ( v17 > 99 && v17 <= 825 )
          set_frequency(v17);
        else
          puts("Frequency: [100, 825]");
        break;
      case 'p':
        read_sensor_test();
        break;
      case 'q':
        v21 = 0;
        break;
      case 's':
        puts("read reg: input reg [address data]");
        _isoc99_scanf("%x %x", &v16, &v15);
        v13[1] = 1;
        v13[0] = 0;
        v13[2] = v16;
        v14 = v15;
        midd_ioctl(g_chain[0], 1, v13);
        break;
      case 't':
        bm1740_app_test();
        break;
      case 'w':
        memset(v7, 0, sizeof(v7));
        puts("input [work]");
        _isoc99_scanf("%s", v7);
        if ( strlen(v7) > 0x117 )
        {
          v4 |= 0x10u;
          v4 &= ~1u;
          v5 = 0;
          memset(v2, 0, sizeof(v2));
          hex2bin(v2, (unsigned __int8 *)v7, 140);
          memcpy(v6, v2, sizeof(v6));
          memcpy(&g_test_header, v2, 0x8Cu);
          for ( i = 0; i <= 0; ++i )
            midd_send_work_to_hardware(g_chain[10 * i], v3, 146);
        }
        else
        {
          puts("wrong header");
        }
        break;
      default:
        puts("unknow command");
        break;
    }
  }
  return 0;
}
// 8E14: using guessed type int _isoc99_fscanf(_DWORD, const char *, ...);
// 9064: using guessed type int _isoc99_scanf(const char *, ...);
// 31200: using guessed type int stdin;
// 61D04: using guessed type int g_chain[10];
// 150E8: using guessed type unsigned __int8 anonymous_0[2];

//----- (000154A0) --------------------------------------------------------
int __fastcall get_bt8d_from_baud(int a1)
{
  char v3[256]; // [sp+8h] [bp+8h] BYREF
  unsigned int v4; // [sp+108h] [bp+108h]
  unsigned int i; // [sp+10Ch] [bp+10Ch]

  v4 = 5;
  for ( i = 0; ; ++i )
  {
    if ( i >= v4 )
    {
      if ( i != v4 )
        return 255;
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        strcpy(v3, "get bt8d value failed!!!,use default to continue\n");
        applog(3, v3);
      }
      return get_bt8d_from_baud(115200);
    }
    if ( *((_DWORD *)&baud_BT8D_values + 3 * i) == a1 )
      break;
  }
  if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    snprintf(v3, 0x100u, "get bt8d %d\n", *((unsigned __int8 *)&baud_BT8D_values + 12 * i + 4));
    applog(3, v3);
  }
  return *((unsigned __int8 *)&baud_BT8D_values + 12 * i + 4);
}
// 3089C: using guessed type int opt_log_level;
// 31294: using guessed type char use_syslog;
// 31297: using guessed type char opt_log_output;

//----- (000155EC) --------------------------------------------------------
int __fastcall bm1740_pack_work_pkg(int a1, int a2)
{
  char v4[258]; // [sp+8h] [bp+8h] BYREF
  uint16_t v5; // [sp+10Ah] [bp+10Ah]
  int v6; // [sp+10Ch] [bp+10Ch]

  if ( a2 == 146 )
  {
    v6 = a1;
    *(_BYTE *)(a1 + 2) = *(_BYTE *)(a1 + 2) & 0x1F | 0x20;
    *(_BYTE *)v6 = 85;
    *(_BYTE *)(v6 + 1) = -86;
    v5 = CRC16((const unsigned __int8 *)(a1 + 2), 0x8Eu);
    *(_WORD *)(v6 + 144) = HIBYTE(v5) | (v5 << 8);
    if ( g_crc16_err_enable )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf(v4, 0x100u, "true crc16 = %x\n", *(unsigned __int16 *)(v6 + 144));
        applog(3, v4);
      }
      ++*(_WORD *)(v6 + 144);
    }
    return 146;
  }
  else
  {
    printf("%s wrong work\n", "bm1740_pack_work_pkg");
    return -1;
  }
}
// 3089C: using guessed type int opt_log_level;
// 31294: using guessed type char use_syslog;
// 31297: using guessed type char opt_log_output;
// 624A8: using guessed type int g_crc16_err_enable;

//----- (000156FC) --------------------------------------------------------
int __fastcall bm1740_makeup_set_address_cmd(int a1, unsigned int a2, char a3)
{
  unsigned __int8 v4; // r0
  char v8[256]; // [sp+18h] [bp+10h] BYREF
  _DWORD v9[2]; // [sp+118h] [bp+110h] BYREF

  if ( a2 > 6 )
  {
    memset(v9, 0, 5u);
    LOBYTE(v9[0]) = v9[0] & 0x1F | 0x40;
    LOBYTE(v9[0]) &= ~0x10u;
    LOBYTE(v9[0]) &= 0xF0u;
    BYTE1(v9[0]) = 5;
    BYTE2(v9[0]) = a3;
    v4 = CRC5((unsigned __int8 *)v9, 0x20u);
    LOBYTE(v9[1]) = v9[1] & 0xE0 | v4 & 0x1F;
    *(_BYTE *)a1 = 85;
    *(_BYTE *)(a1 + 1) = -86;
    *(_DWORD *)(a1 + 2) = v9[0];
    *(_BYTE *)(a1 + 6) = v9[1];
    return 7;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level >= 0 )
    {
      snprintf(v8, 0x100u, "%s input param error: str length = %u\n", "bm1740_makeup_set_address_cmd", 7);
      applog(0, v8);
    }
    return -1;
  }
}
// 3089C: using guessed type int opt_log_level;
// 31294: using guessed type char use_syslog;
// 31297: using guessed type char opt_log_output;

//----- (00015814) --------------------------------------------------------
int __fastcall bm1740_makeup_set_config_cmd(int a1, unsigned int a2, char a3, char a4, char a5, unsigned int a6)
{
  unsigned __int8 v7; // r0
  int v8; // r1
  char v13[256]; // [sp+18h] [bp+10h] BYREF
  _DWORD v14[4]; // [sp+11Ch] [bp+114h] BYREF

  if ( a2 > 0xA )
  {
    memset(v14, 0, 9u);
    LOBYTE(v14[0]) = v14[0] & 0x1F | 0x40;
    LOBYTE(v14[0]) = v14[0] & 0xEF | (16 * (a3 & 1));
    LOBYTE(v14[0]) = v14[0] & 0xF0 | 1;
    BYTE1(v14[0]) = 9;
    BYTE2(v14[0]) = a4;
    HIBYTE(v14[0]) = a5;
    v14[1] = bswap32(a6);
    v7 = CRC5((unsigned __int8 *)v14, 0x40u);
    LOBYTE(v14[2]) = v14[2] & 0xE0 | v7 & 0x1F;
    *(_BYTE *)a1 = 85;
    *(_BYTE *)(a1 + 1) = -86;
    v8 = v14[1];
    *(_DWORD *)(a1 + 2) = v14[0];
    *(_DWORD *)(a1 + 6) = v8;
    *(_BYTE *)(a1 + 10) = v14[2];
    return 11;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level >= 0 )
    {
      snprintf(v13, 0x100u, "%s input param error: str length = %u\n", "bm1740_makeup_set_config_cmd", 11);
      applog(0, v13);
    }
    return -1;
  }
}
// 3089C: using guessed type int opt_log_level;
// 31294: using guessed type char use_syslog;
// 31297: using guessed type char opt_log_output;

//----- (00015960) --------------------------------------------------------
int __fastcall bm1740_makeup_get_status_cmd(int a1, unsigned int a2, char a3, char a4, char a5)
{
  unsigned __int8 v6; // r0
  char v11[256]; // [sp+18h] [bp+10h] BYREF
  _DWORD v12[3]; // [sp+118h] [bp+110h] BYREF

  if ( a2 > 6 )
  {
    memset(v12, 0, 5u);
    LOBYTE(v12[0]) = v12[0] & 0x1F | 0x40;
    LOBYTE(v12[0]) = v12[0] & 0xEF | (16 * (a3 & 1));
    LOBYTE(v12[0]) = v12[0] & 0xF0 | 2;
    BYTE1(v12[0]) = 5;
    BYTE2(v12[0]) = a4;
    HIBYTE(v12[0]) = a5;
    v6 = CRC5((unsigned __int8 *)v12, 0x20u);
    LOBYTE(v12[1]) = v12[1] & 0xE0 | v6 & 0x1F;
    if ( g_crc5_err_enable )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf(v11, 0x100u, "true crc5 = %x\n", v12[1] & 0x1F);
        applog(3, v11);
      }
      LOBYTE(v12[1]) = v12[1] & 0xE0 | ((v12[1] & 0x1F) + 1) & 0x1F;
    }
    *(_BYTE *)a1 = 85;
    *(_BYTE *)(a1 + 1) = -86;
    *(_DWORD *)(a1 + 2) = v12[0];
    *(_BYTE *)(a1 + 6) = v12[1];
    return 7;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level >= 0 )
    {
      snprintf(v11, 0x100u, "%s input param error: str length = %u\n", "bm1740_makeup_get_status_cmd", 7);
      applog(0, v11);
    }
    return -1;
  }
}
// 3089C: using guessed type int opt_log_level;
// 31294: using guessed type char use_syslog;
// 31297: using guessed type char opt_log_output;
// 624E8: using guessed type int g_crc5_err_enable;

//----- (00015B1C) --------------------------------------------------------
int __fastcall bm1740_makeup_chain_inactive_cmd(int a1, unsigned int a2)
{
  unsigned __int8 v3; // r0
  char v6[256]; // [sp+10h] [bp+8h] BYREF
  _DWORD v7[2]; // [sp+110h] [bp+108h] BYREF

  if ( a2 > 6 )
  {
    memset(v7, 0, 5u);
    LOBYTE(v7[0]) = v7[0] & 0x1F | 0x40;
    LOBYTE(v7[0]) |= 0x10u;
    LOBYTE(v7[0]) = v7[0] & 0xF0 | 3;
    BYTE1(v7[0]) = 5;
    v3 = CRC5((unsigned __int8 *)v7, 0x20u);
    LOBYTE(v7[1]) = v7[1] & 0xE0 | v3 & 0x1F;
    *(_BYTE *)a1 = 85;
    *(_BYTE *)(a1 + 1) = -86;
    *(_DWORD *)(a1 + 2) = v7[0];
    *(_BYTE *)(a1 + 6) = v7[1];
    return 7;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level >= 0 )
    {
      snprintf(v6, 0x100u, "%s input param error: str length = %u\n", "bm1740_makeup_chain_inactive_cmd", 7);
      applog(0, v6);
    }
    return -1;
  }
}
// 3089C: using guessed type int opt_log_level;
// 31294: using guessed type char use_syslog;
// 31297: using guessed type char opt_log_output;

//----- (00015C20) --------------------------------------------------------
int __fastcall bm1740_makeup_bist_setup_cmd(char a1, char a2, int a3, unsigned int a4)
{
  unsigned __int8 v5; // r0
  char v10[256]; // [sp+18h] [bp+10h] BYREF
  _DWORD v11[3]; // [sp+118h] [bp+110h] BYREF

  if ( a4 > 6 )
  {
    memset(v11, 0, 5u);
    LOBYTE(v11[0]) = v11[0] & 0x1F | 0x40;
    LOBYTE(v11[0]) = v11[0] & 0xEF | (16 * (a1 & 1));
    LOBYTE(v11[0]) &= 0xF0u;
    BYTE1(v11[0]) = 5;
    BYTE2(v11[0]) = a2;
    v5 = CRC5((unsigned __int8 *)v11, 0x20u);
    LOBYTE(v11[1]) = v11[1] & 0xE0 | v5 & 0x1F;
    *(_BYTE *)a3 = 85;
    *(_BYTE *)(a3 + 1) = -86;
    *(_DWORD *)(a3 + 2) = v11[0];
    *(_BYTE *)(a3 + 6) = v11[1];
    return 7;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level >= 0 )
    {
      snprintf(v10, 0x100u, "%s input param error: str length = %u\n", "bm1740_makeup_bist_setup_cmd", 7);
      applog(0, v10);
    }
    return -1;
  }
}
// 3089C: using guessed type int opt_log_level;
// 31294: using guessed type char use_syslog;
// 31297: using guessed type char opt_log_output;

//----- (00015D50) --------------------------------------------------------
int __fastcall bm1740_makeup_bist_write_wait_cmd(char a1, char a2, int a3, char a4, int a5, unsigned int a6)
{
  unsigned __int8 v7; // r0
  int v8; // r1
  char v9; // r3
  char v15[256]; // [sp+14h] [bp+Ch] BYREF
  _DWORD v16[4]; // [sp+114h] [bp+10Ch] BYREF

  if ( a6 > 0xC )
  {
    memset(v16, 0, 0xBu);
    LOBYTE(v16[0]) = v16[0] & 0x1F | 0x60;
    LOBYTE(v16[0]) = v16[0] & 0xEF | (16 * (a1 & 1));
    LOBYTE(v16[0]) = v16[0] & 0xF0 | 1;
    BYTE1(v16[0]) = 11;
    BYTE2(v16[0]) = a2;
    *(_DWORD *)((char *)v16 + 3) = *(_DWORD *)a3;
    *(_WORD *)((char *)&v16[1] + 3) = *(_WORD *)(a3 + 4);
    BYTE1(v16[2]) = a4;
    v7 = CRC5((unsigned __int8 *)v16, 0x50u);
    BYTE2(v16[2]) = BYTE2(v16[2]) & 0xE0 | v7 & 0x1F;
    *(_BYTE *)a5 = 85;
    *(_BYTE *)(a5 + 1) = -86;
    v8 = v16[1];
    *(_DWORD *)(a5 + 2) = v16[0];
    *(_DWORD *)(a5 + 6) = v8;
    v9 = BYTE2(v16[2]);
    *(_WORD *)(a5 + 10) = v16[2];
    *(_BYTE *)(a5 + 12) = v9;
    return 13;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level >= 0 )
    {
      snprintf(v15, 0x100u, "%s input param error: str length = %u\n", "bm1740_makeup_bist_write_wait_cmd", 13);
      applog(0, v15);
    }
    return -1;
  }
}
// 3089C: using guessed type int opt_log_level;
// 31294: using guessed type char use_syslog;
// 31297: using guessed type char opt_log_output;

//----- (00015E90) --------------------------------------------------------
int __fastcall bm1740_makeup_bist_write_wait_read_cmd(char a1, char a2, int a3, int a4, unsigned int a5)
{
  unsigned __int8 v6; // r0
  int v7; // r1
  char v8; // r3
  char v14[256]; // [sp+1Ch] [bp+14h] BYREF
  _DWORD v15[4]; // [sp+11Ch] [bp+114h] BYREF

  if ( a5 > 0xC )
  {
    memset(v15, 0, 0xBu);
    LOBYTE(v15[0]) = v15[0] & 0x1F | 0x60;
    LOBYTE(v15[0]) = v15[0] & 0xEF | (16 * (a1 & 1));
    LOBYTE(v15[0]) = v15[0] & 0xF0 | 2;
    BYTE1(v15[0]) = 11;
    BYTE2(v15[0]) = a2;
    *(_DWORD *)((char *)v15 + 3) = *(_DWORD *)a3;
    *(_WORD *)((char *)&v15[1] + 3) = *(_WORD *)(a3 + 4);
    v6 = CRC5((unsigned __int8 *)v15, 0x50u);
    BYTE2(v15[2]) = BYTE2(v15[2]) & 0xE0 | v6 & 0x1F;
    *(_BYTE *)a4 = 85;
    *(_BYTE *)(a4 + 1) = -86;
    v7 = v15[1];
    *(_DWORD *)(a4 + 2) = v15[0];
    *(_DWORD *)(a4 + 6) = v7;
    v8 = BYTE2(v15[2]);
    *(_WORD *)(a4 + 10) = v15[2];
    *(_BYTE *)(a4 + 12) = v8;
    return 13;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level >= 0 )
    {
      snprintf(v14, 0x100u, "%s input param error: str length = %u\n", "bm1740_makeup_bist_write_wait_read_cmd", 13);
      applog(0, v14);
    }
    return -1;
  }
}
// 3089C: using guessed type int opt_log_level;
// 31294: using guessed type char use_syslog;
// 31297: using guessed type char opt_log_output;

//----- (00015FD4) --------------------------------------------------------
int __fastcall bm1740_makeup_bist_wait_cmd(char a1, char a2, int a3, int a4, unsigned int a5)
{
  unsigned __int8 v6; // r0
  int v7; // r1
  char v13[256]; // [sp+1Ch] [bp+14h] BYREF
  _DWORD v14[4]; // [sp+11Ch] [bp+114h] BYREF

  if ( a5 > 0xA )
  {
    memset(v14, 0, 9u);
    LOBYTE(v14[0]) = v14[0] & 0x1F | 0x60;
    LOBYTE(v14[0]) = v14[0] & 0xEF | (16 * (a1 & 1));
    LOBYTE(v14[0]) = v14[0] & 0xF0 | 3;
    BYTE1(v14[0]) = 9;
    BYTE2(v14[0]) = a2;
    *(_DWORD *)((char *)v14 + 3) = *(_DWORD *)a3;
    HIBYTE(v14[1]) = *(_BYTE *)(a3 + 4);
    v6 = CRC5((unsigned __int8 *)v14, 0x40u);
    LOBYTE(v14[2]) = v14[2] & 0xE0 | v6 & 0x1F;
    *(_BYTE *)a4 = 85;
    *(_BYTE *)(a4 + 1) = -86;
    v7 = v14[1];
    *(_DWORD *)(a4 + 2) = v14[0];
    *(_DWORD *)(a4 + 6) = v7;
    *(_BYTE *)(a4 + 10) = v14[2];
    return 11;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level >= 0 )
    {
      snprintf(v13, 0x100u, "%s input param error: str length = %u\n", "bm1740_makeup_bist_wait_cmd", 11);
      applog(0, v13);
    }
    return -1;
  }
}
// 3089C: using guessed type int opt_log_level;
// 31294: using guessed type char use_syslog;
// 31297: using guessed type char opt_log_output;

//----- (00016114) --------------------------------------------------------
int __fastcall bm1740_makeup_bist_read_cmd(char a1, char a2, int a3, unsigned int a4)
{
  unsigned __int8 v5; // r0
  char v10[256]; // [sp+18h] [bp+10h] BYREF
  _DWORD v11[3]; // [sp+118h] [bp+110h] BYREF

  if ( a4 > 6 )
  {
    memset(v11, 0, 5u);
    LOBYTE(v11[0]) = v11[0] & 0x1F | 0x60;
    LOBYTE(v11[0]) = v11[0] & 0xEF | (16 * (a1 & 1));
    LOBYTE(v11[0]) = v11[0] & 0xF0 | 4;
    BYTE1(v11[0]) = 5;
    BYTE2(v11[0]) = a2;
    v5 = CRC5((unsigned __int8 *)v11, 0x20u);
    LOBYTE(v11[1]) = v11[1] & 0xE0 | v5 & 0x1F;
    *(_BYTE *)a3 = 85;
    *(_BYTE *)(a3 + 1) = -86;
    *(_DWORD *)(a3 + 2) = v11[0];
    *(_BYTE *)(a3 + 6) = v11[1];
    return 7;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level >= 0 )
    {
      snprintf(v10, 0x100u, "%s input param error: str length = %u\n", "bm1740_makeup_bist_read_cmd", 7);
      applog(0, v10);
    }
    return -1;
  }
}
// 3089C: using guessed type int opt_log_level;
// 31294: using guessed type char use_syslog;
// 31297: using guessed type char opt_log_output;

//----- (00016244) --------------------------------------------------------
int __fastcall bm1740_makeup_bist_disable_cmd(char a1, char a2, int a3, unsigned int a4)
{
  unsigned __int8 v5; // r0
  char v10[256]; // [sp+18h] [bp+10h] BYREF
  _DWORD v11[3]; // [sp+118h] [bp+110h] BYREF

  if ( a4 > 6 )
  {
    memset(v11, 0, 5u);
    LOBYTE(v11[0]) = v11[0] & 0x1F | 0x60;
    LOBYTE(v11[0]) = v11[0] & 0xEF | (16 * (a1 & 1));
    LOBYTE(v11[0]) = v11[0] & 0xF0 | 5;
    BYTE1(v11[0]) = 5;
    BYTE2(v11[0]) = a2;
    v5 = CRC5((unsigned __int8 *)v11, 0x20u);
    LOBYTE(v11[1]) = v11[1] & 0xE0 | v5 & 0x1F;
    *(_BYTE *)a3 = 85;
    *(_BYTE *)(a3 + 1) = -86;
    *(_DWORD *)(a3 + 2) = v11[0];
    *(_BYTE *)(a3 + 6) = v11[1];
    return 7;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level >= 0 )
    {
      snprintf(v10, 0x100u, "%s input param error: str length = %u\n", "bm1740_makeup_bist_disable_cmd", 7);
      applog(0, v10);
    }
    return -1;
  }
}
// 3089C: using guessed type int opt_log_level;
// 31294: using guessed type char use_syslog;
// 31297: using guessed type char opt_log_output;

//----- (00016374) --------------------------------------------------------
int __fastcall bm1740_set_reg_table(char a1, int a2)
{
  char v5[256]; // [sp+8h] [bp+8h] BYREF

  pthread_mutex_lock(&g_reg_table_mutex);
  switch ( a1 )
  {
    case 0:
      g_reg_table = a2;
      break;
    case 8:
      dword_624B0 = a2;
      break;
    case 12:
      dword_624B4 = a2;
      break;
    case 20:
      dword_624B8 = a2;
      break;
    case 28:
      dword_624BC = a2;
      break;
    case 32:
      dword_624C0 = a2;
      break;
    case 36:
      dword_624C4 = a2;
      break;
    case 40:
      dword_624C8 = a2;
      break;
    case 48:
      dword_624CC = a2;
      break;
    case 52:
      dword_624D0 = a2;
      break;
    case 56:
      dword_624D4 = a2;
      break;
    case 60:
      dword_624D8 = a2;
      break;
    case 64:
      dword_624DC = a2;
      break;
    case 84:
      dword_624E0 = a2;
      break;
    case 88:
      dword_624E4 = a2;
      break;
    default:
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf(v5, 0x100u, "error: %s unknow reg type\n", "bm1740_set_reg_table");
        applog(3, v5);
      }
      break;
  }
  return pthread_mutex_unlock(&g_reg_table_mutex);
}
// 3089C: using guessed type int opt_log_level;
// 31278: using guessed type pthread_mutex_t g_reg_table_mutex;
// 31294: using guessed type char use_syslog;
// 31297: using guessed type char opt_log_output;
// 624AC: using guessed type int g_reg_table;
// 624B0: using guessed type int dword_624B0;
// 624B4: using guessed type int dword_624B4;
// 624B8: using guessed type int dword_624B8;
// 624BC: using guessed type int dword_624BC;
// 624C0: using guessed type int dword_624C0;
// 624C4: using guessed type int dword_624C4;
// 624C8: using guessed type int dword_624C8;
// 624CC: using guessed type int dword_624CC;
// 624D0: using guessed type int dword_624D0;
// 624D4: using guessed type int dword_624D4;
// 624D8: using guessed type int dword_624D8;
// 624DC: using guessed type int dword_624DC;
// 624E0: using guessed type int dword_624E0;
// 624E4: using guessed type int dword_624E4;

//----- (00016660) --------------------------------------------------------
int __fastcall bm1740_get_reg_table(char a1, void *a2)
{
  char v5[256]; // [sp+8h] [bp+8h] BYREF

  pthread_mutex_lock(&g_reg_table_mutex);
  switch ( a1 )
  {
    case 0:
      memcpy(a2, &g_reg_table, 4u);
      break;
    case 8:
      memcpy(a2, &dword_624B0, 4u);
      break;
    case 12:
      memcpy(a2, &dword_624B4, 4u);
      break;
    case 20:
      memcpy(a2, &dword_624B8, 4u);
      break;
    case 28:
      memcpy(a2, &dword_624BC, 4u);
      break;
    case 32:
      memcpy(a2, &dword_624C0, 4u);
      break;
    case 36:
      memcpy(a2, &dword_624C4, 4u);
      break;
    case 40:
      memcpy(a2, &dword_624C8, 4u);
      break;
    case 48:
      memcpy(a2, &dword_624CC, 4u);
      break;
    case 52:
      memcpy(a2, &dword_624D0, 4u);
      break;
    case 56:
      memcpy(a2, &dword_624D4, 4u);
      break;
    case 60:
      memcpy(a2, &dword_624D8, 4u);
      break;
    case 64:
      memcpy(a2, &dword_624DC, 4u);
      break;
    case 84:
      memcpy(a2, &dword_624E0, 4u);
      break;
    case 88:
      memcpy(a2, &dword_624E4, 4u);
      break;
    default:
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf(v5, 0x100u, "error: %s unknow reg type\n", "bm1740_get_reg_table");
        applog(3, v5);
      }
      break;
  }
  return pthread_mutex_unlock(&g_reg_table_mutex);
}
// 3089C: using guessed type int opt_log_level;
// 31278: using guessed type pthread_mutex_t g_reg_table_mutex;
// 31294: using guessed type char use_syslog;
// 31297: using guessed type char opt_log_output;
// 624AC: using guessed type int g_reg_table;
// 624B0: using guessed type int dword_624B0;
// 624B4: using guessed type int dword_624B4;
// 624B8: using guessed type int dword_624B8;
// 624BC: using guessed type int dword_624BC;
// 624C0: using guessed type int dword_624C0;
// 624C4: using guessed type int dword_624C4;
// 624C8: using guessed type int dword_624C8;
// 624CC: using guessed type int dword_624CC;
// 624D0: using guessed type int dword_624D0;
// 624D4: using guessed type int dword_624D4;
// 624D8: using guessed type int dword_624D8;
// 624DC: using guessed type int dword_624DC;
// 624E0: using guessed type int dword_624E0;
// 624E4: using guessed type int dword_624E4;

//----- (0001696C) --------------------------------------------------------
int __fastcall bm1740_parse_nonce_respond(const void *a1, size_t a2, void *a3, unsigned int a4)
{
  char v6[260]; // [sp+18h] [bp+10h] BYREF

  if ( a2 == 93 && a4 >= 0x5D )
  {
    memcpy(a3, a1, a2);
    return 93;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level >= 0 )
    {
      snprintf(v6, 0x100u, "%s input str len error, input len=%d\n", "bm1740_parse_nonce_respond", a2);
      applog(0, v6);
    }
    return -1;
  }
}
// 3089C: using guessed type int opt_log_level;
// 31294: using guessed type char use_syslog;
// 31297: using guessed type char opt_log_output;

//----- (00016A24) --------------------------------------------------------
int __fastcall bm1740_parse_reg_respond(unsigned __int8 *a1, size_t a2, void *a3, unsigned int a4)
{
  char v9[256]; // [sp+18h] [bp+10h] BYREF
  unsigned __int8 *v10; // [sp+118h] [bp+110h]
  unsigned __int8 v11; // [sp+11Fh] [bp+117h]

  v11 = 0;
  v10 = a1;
  if ( a2 == 9 && a4 > 8 )
  {
    v11 = CRC5(a1 + 2, 0x33u);
    if ( v11 == (v10[8] & 0x1F) )
    {
      memcpy(a3, a1, a2);
      return a2;
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level >= 0 )
      {
        snprintf(v9, 0x100u, "%s CRC error crc = %02x\n", "bm1740_parse_reg_respond", v11);
        applog(0, v9);
      }
      return -1;
    }
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level >= 0 )
    {
      snprintf(v9, 0x100u, "%s length error\n", "bm1740_parse_reg_respond");
      applog(0, v9);
    }
    return -1;
  }
}
// 3089C: using guessed type int opt_log_level;
// 31294: using guessed type char use_syslog;
// 31297: using guessed type char opt_log_output;

//----- (00016B6C) --------------------------------------------------------
int __fastcall bm1740_parse_pmonitor_respond(int a1, size_t a2, void *a3, unsigned int a4)
{
  int v8; // [sp+14h] [bp+Ch] BYREF
  char v9[259]; // [sp+18h] [bp+10h] BYREF
  unsigned __int8 v10; // [sp+11Bh] [bp+113h]
  int v11; // [sp+11Ch] [bp+114h]

  v8 = a1;
  v11 = a1;
  if ( a2 == 9 && a4 > 8 )
  {
    v10 = CRC5((unsigned __int8 *)(v8 + 2), 0x33u);
    if ( v10 == (*(_BYTE *)(v11 + 8) & 0x1F) )
    {
      memcpy(a3, &v8, a2);
      return a2;
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level >= 0 )
      {
        snprintf(
          v9,
          0x100u,
          "%s CRC error. cal-crc=%x, chip-crc=%x\n",
          "bm1740_parse_pmonitor_respond",
          v10,
          *(_BYTE *)(v11 + 8) & 0x1F);
        applog(0, v9);
      }
      return -1;
    }
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level >= 0 )
    {
      snprintf(v9, 0x100u, "%s length error\n", "bm1740_parse_pmonitor_respond");
      applog(0, v9);
    }
    return -1;
  }
}
// 3089C: using guessed type int opt_log_level;
// 31294: using guessed type char use_syslog;
// 31297: using guessed type char opt_log_output;

//----- (00016CC0) --------------------------------------------------------
int __fastcall bm1740_parse_bist_respond(int a1, size_t a2, void *a3, unsigned int a4)
{
  int v8; // [sp+14h] [bp+Ch] BYREF
  char v9[259]; // [sp+18h] [bp+10h] BYREF
  unsigned __int8 v10; // [sp+11Bh] [bp+113h]
  int v11; // [sp+11Ch] [bp+114h]

  v8 = a1;
  v11 = a1;
  if ( a2 == 11 && a4 > 0xA )
  {
    v10 = CRC5((unsigned __int8 *)(v8 + 2), 0x43u);
    if ( v10 == (*(_BYTE *)(v11 + 10) & 0x1F) )
    {
      memcpy(a3, &v8, a2);
      return a2;
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level >= 0 )
      {
        snprintf(
          v9,
          0x100u,
          "%s CRC error. cal-crc=%x, chip-crc=%x\n",
          "bm1740_parse_bist_respond",
          v10,
          *(_BYTE *)(v11 + 10) & 0x1F);
        applog(0, v9);
      }
      return -1;
    }
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level >= 0 )
    {
      snprintf(v9, 0x100u, "%s length error\n", "bm1740_parse_bist_respond");
      applog(0, v9);
    }
    return -1;
  }
}
// 3089C: using guessed type int opt_log_level;
// 31294: using guessed type char use_syslog;
// 31297: using guessed type char opt_log_output;

//----- (00016E14) --------------------------------------------------------
int __fastcall bm1740_parse_respond_len(_BYTE *a1, int a2, _DWORD *a3)
{
  int v4; // [sp+14h] [bp+14h]

  switch ( state_6104 )
  {
    case 0:
      if ( a2 > 0 && (unsigned __int8)*a1 == 170 )
      {
        state_6104 = 1;
        v4 = 1;
      }
      else
      {
        v4 = 0;
      }
      *a3 = 1;
      break;
    case 1:
      if ( a2 > 0 && *a1 == 85 )
      {
        state_6104 = 2;
        v4 = 1;
      }
      else
      {
        state_6104 = 0;
        v4 = 0;
      }
      *a3 = 1;
      break;
    case 2:
      if ( a2 <= 0 )
      {
        *a3 = 1;
        v4 = 0;
        state_6104 = 0;
      }
      else
      {
        if ( (*a1 & 0xF0) == 224 )
          *a3 = 90;
        else
          *a3 = 6;
        v4 = 1;
        state_6104 = 3;
      }
      break;
    case 3:
      v4 = 2;
      *a3 = 1;
      state_6104 = 0;
      break;
    default:
      v4 = 0;
      *a3 = 1;
      state_6104 = 0;
      break;
  }
  return v4;
}
// 31290: using guessed type int state_6104;

//----- (00016F44) --------------------------------------------------------
int __fastcall bm1740_parse_respond_pkg(_BYTE *a1, size_t a2, _DWORD *a3, void *a4, unsigned int a5)
{
  char v7[256]; // [sp+1Ch] [bp+14h] BYREF
  int v8; // [sp+11Ch] [bp+114h]

  v8 = 0;
  if ( (a1[2] & 0xF0) == 224 )
  {
    *a3 = 0;
    return bm1740_parse_nonce_respond(a1, a2, a4, a5);
  }
  if ( (unsigned __int8)a1[2] == 204 )
  {
    *a3 = 1;
    return bm1740_parse_pmonitor_respond((int)a1, a2, a4, a5);
  }
  if ( (unsigned __int8)a1[2] == 187 )
  {
    *a3 = 3;
    return bm1740_parse_bist_respond((int)a1, a2, a4, a5);
  }
  if ( (char)a1[2] >= 0 )
  {
    *a3 = 2;
    return bm1740_parse_reg_respond(a1, a2, a4, a5);
  }
  *a3 = 4;
  if ( use_syslog || opt_log_output || opt_log_level >= 0 )
  {
    snprintf(v7, 0x100u, "%s unknow respond type %02x\n", "bm1740_parse_respond_pkg", (unsigned __int8)a1[2]);
    applog(0, v7);
  }
  return -1;
}
// 3089C: using guessed type int opt_log_level;
// 31294: using guessed type char use_syslog;
// 31297: using guessed type char opt_log_output;

//----- (000170C4) --------------------------------------------------------
int __fastcall bm1740_get_plldata(int result, _DWORD *a2)
{
  unsigned int i; // [sp+Ch] [bp+Ch]

  for ( i = 0; i <= 0x63 && freq_pll[4 * i] != result; ++i )
    ;
  if ( i == 100 )
    i = 4;
  *a2 = freq_pll[4 * i + 3];
  return result;
}
// 3025C: using guessed type _DWORD freq_pll[400];

//----- (00017124) --------------------------------------------------------
int __fastcall bm1740_ioctl_regtable(int a1, int a2)
{
  char v4[256]; // [sp+8h] [bp+8h] BYREF
  int v5; // [sp+108h] [bp+108h]
  int v6; // [sp+10Ch] [bp+10Ch]

  if ( !a1 )
  {
    v6 = a2;
    bm1740_get_reg_table(*(_BYTE *)(a2 + 2), (void *)(a2 + 4));
    return 0;
  }
  if ( a1 == 1 )
  {
    v5 = a2;
    bm1740_set_reg_table(*(_BYTE *)(a2 + 2), *(_DWORD *)(a2 + 4));
    return 0;
  }
  if ( use_syslog || opt_log_output || opt_log_level > 0 )
  {
    snprintf(v4, 0x100u, "%s failed\n", "bm1740_ioctl_regtable");
    applog(1, v4);
  }
  return 1;
}
// 3089C: using guessed type int opt_log_level;
// 31294: using guessed type char use_syslog;
// 31297: using guessed type char opt_log_output;

//----- (000171E4) --------------------------------------------------------
int __fastcall bm1740_pack_ioctl_pkg(int a1, unsigned int a2, int a3, char *a4)
{
  char bt8d_from_baud; // r0
  int status_cmd; // r3
  char v9[256]; // [sp+1Ch] [bp+14h] BYREF
  unsigned int v10; // [sp+11Ch] [bp+114h] BYREF
  unsigned int v11; // [sp+120h] [bp+118h] BYREF
  unsigned int v12; // [sp+124h] [bp+11Ch] BYREF
  unsigned int v13; // [sp+128h] [bp+120h] BYREF
  unsigned int v14; // [sp+12Ch] [bp+124h] BYREF
  unsigned int v15; // [sp+130h] [bp+128h] BYREF
  int v16; // [sp+134h] [bp+12Ch] BYREF
  unsigned int v17; // [sp+138h] [bp+130h] BYREF
  unsigned int v18; // [sp+13Ch] [bp+134h] BYREF
  unsigned int v19; // [sp+140h] [bp+138h] BYREF
  unsigned int v20; // [sp+144h] [bp+13Ch] BYREF
  int v21; // [sp+148h] [bp+140h] BYREF
  unsigned int v22; // [sp+14Ch] [bp+144h] BYREF
  unsigned int v23; // [sp+150h] [bp+148h] BYREF
  unsigned int v24; // [sp+154h] [bp+14Ch] BYREF
  unsigned int v25; // [sp+158h] [bp+150h] BYREF
  int v26[2]; // [sp+15Ch] [bp+154h] BYREF
  int v27; // [sp+164h] [bp+15Ch] BYREF
  unsigned int v28; // [sp+168h] [bp+160h] BYREF
  unsigned int v29; // [sp+16Ch] [bp+164h] BYREF
  int v30[7]; // [sp+170h] [bp+168h] BYREF
  char *v31; // [sp+18Ch] [bp+184h]
  char *v32; // [sp+190h] [bp+188h]
  char *v33; // [sp+194h] [bp+18Ch]
  char *v34; // [sp+198h] [bp+190h]
  char *v35; // [sp+19Ch] [bp+194h]
  char *v36; // [sp+1A0h] [bp+198h]
  char *v37; // [sp+1A4h] [bp+19Ch]
  char *v38; // [sp+1A8h] [bp+1A0h]
  char *v39; // [sp+1ACh] [bp+1A4h]
  char *v40; // [sp+1B0h] [bp+1A8h]
  char *v41; // [sp+1B4h] [bp+1ACh]
  char *v42; // [sp+1B8h] [bp+1B0h]
  char *v43; // [sp+1BCh] [bp+1B4h]
  char *v44; // [sp+1C0h] [bp+1B8h]
  char *v45; // [sp+1C4h] [bp+1BCh]
  char *v46; // [sp+1C8h] [bp+1C0h]
  char *v47; // [sp+1CCh] [bp+1C4h]
  char *v48; // [sp+1D0h] [bp+1C8h]
  char *v49; // [sp+1D4h] [bp+1CCh]
  char *v50; // [sp+1D8h] [bp+1D0h]
  char *v51; // [sp+1DCh] [bp+1D4h]
  char *v52; // [sp+1E0h] [bp+1D8h]
  char *v53; // [sp+1E4h] [bp+1DCh]
  char *v54; // [sp+1E8h] [bp+1E0h]
  char *v55; // [sp+1ECh] [bp+1E4h]
  char *v56; // [sp+1F0h] [bp+1E8h]
  char *v57; // [sp+1F4h] [bp+1ECh]
  char *v58; // [sp+1F8h] [bp+1F0h]
  char *v59; // [sp+1FCh] [bp+1F4h]
  char *v60; // [sp+200h] [bp+1F8h]
  char *v61; // [sp+204h] [bp+1FCh]

  switch ( a3 )
  {
    case 0:
      v56 = a4;
      status_cmd = bm1740_makeup_get_status_cmd(a1, a2, a4[1], *a4, a4[2]);
      break;
    case 1:
      v55 = a4;
      bm1740_set_reg_table(a4[2], *((_DWORD *)a4 + 1));
      status_cmd = bm1740_makeup_set_config_cmd(a1, a2, v55[1], *v55, v55[2], *((_DWORD *)v55 + 1));
      break;
    case 2:
      v61 = a4;
      bm1740_get_reg_table(28, v30);
      bt8d_from_baud = get_bt8d_from_baud(*((_DWORD *)v61 + 1));
      v30[0] = v30[0] & 0xFFFFE0FF | ((bt8d_from_baud & 0x1F) << 8);
      bm1740_set_reg_table(28, v30[0]);
      status_cmd = bm1740_makeup_set_config_cmd(a1, a2, v61[1], *v61, 28, v30[0]);
      break;
    case 3:
      v60 = a4;
      status_cmd = bm1740_makeup_get_status_cmd(a1, a2, a4[1], *a4, 28);
      break;
    case 4:
      v33 = a4;
      bm1740_get_reg_table(64, &v12);
      v12 = v12 & 0xFFFFFFF8 | v33[2] & 7;
      bm1740_set_reg_table(64, v12);
      status_cmd = bm1740_makeup_set_config_cmd(a1, a2, v33[1], *v33, 64, v12);
      break;
    case 5:
      v47 = a4;
      bm1740_get_reg_table(28, &v24);
      v24 |= 0x4000u;
      v24 |= 0x60u;
      bm1740_set_reg_table(28, v24);
      status_cmd = bm1740_makeup_set_config_cmd(a1, a2, v47[1], *v47, 28, v24);
      break;
    case 7:
      v46 = a4;
      bm1740_get_reg_table(32, &v23);
      v23 |= 0x1000000u;
      v23 &= ~0x10000u;
      v23 = v23 & 0xFF01FFFF | ((v46[2] & 0x7F) << 17);
      v23 = v23 & 0xFFFF00FF | ((unsigned __int8)v46[3] << 8);
      bm1740_set_reg_table(32, v23);
      status_cmd = bm1740_makeup_set_config_cmd(a1, a2, v46[1], *v46, 32, v23);
      break;
    case 8:
      v45 = a4;
      bm1740_get_reg_table(32, &v22);
      v22 |= 0x10000u;
      v22 = v22 & 0xFF01FFFF | ((v45[2] & 0x7F) << 17);
      v22 = v22 & 0xFFFF00FF | ((unsigned __int8)v45[3] << 8);
      v22 = v22 & 0xFFFFFF00 | (unsigned __int8)v45[4];
      bm1740_set_reg_table(32, v22);
      status_cmd = bm1740_makeup_set_config_cmd(a1, a2, v45[1], *v45, 32, v22);
      break;
    case 9:
      v49 = a4;
      bm1740_get_reg_table(20, &v25);
      v25 = v25 & 0xFFFFFF00 | (unsigned __int8)*((_DWORD *)v49 + 1);
      bm1740_set_reg_table(20, v25);
      status_cmd = bm1740_makeup_set_config_cmd(a1, a2, v49[1], *v49, 20, v25);
      break;
    case 10:
      v48 = a4;
      status_cmd = bm1740_makeup_get_status_cmd(a1, a2, a4[1], *a4, 20);
      break;
    case 11:
      v44 = a4;
      bm1740_get_reg_table(36, &v21);
      v21 = v21 & 0x7FFFFFFF | ((v44[4] & 1) << 31);
      bm1740_set_reg_table(36, v21);
      status_cmd = bm1740_makeup_set_config_cmd(a1, a2, v44[1], *v44, 36, v21);
      break;
    case 12:
      v43 = a4;
      bm1740_get_reg_table(36, &v20);
      LOWORD(v20) = *((_DWORD *)v43 + 1);
      bm1740_set_reg_table(36, v20);
      status_cmd = bm1740_makeup_set_config_cmd(a1, a2, v43[1], *v43, 36, v20);
      break;
    case 14:
      v41 = a4;
      bm1740_get_reg_table(40, &v19);
      v19 = *((_DWORD *)v41 + 1);
      bm1740_set_reg_table(40, v19);
      status_cmd = bm1740_makeup_set_config_cmd(a1, a2, v41[1], *v41, 40, v19);
      break;
    case 15:
    case 16:
      v59 = a4;
      status_cmd = bm1740_makeup_get_status_cmd(a1, a2, a4[1], *a4, 28);
      break;
    case 17:
      v58 = a4;
      bm1740_get_reg_table(28, &v29);
      v29 = v29 & 0xFFFFDFFF | ((*((_DWORD *)v58 + 1) & 1) << 13);
      bm1740_set_reg_table(28, v29);
      status_cmd = bm1740_makeup_set_config_cmd(a1, a2, v58[1], *v58, 28, v29);
      break;
    case 18:
      v57 = a4;
      bm1740_get_reg_table(28, &v28);
      v28 = v28 & 0xFFFFFFFC | *((_DWORD *)v57 + 1) & 3;
      bm1740_set_reg_table(28, v28);
      status_cmd = bm1740_makeup_set_config_cmd(a1, a2, v57[1], *v57, 28, v28);
      break;
    case 19:
      v54 = a4;
      bm1740_get_reg_table(0, &v27);
      v27 = v27 & 0xFFFFFF00 | (unsigned __int8)*v54;
      bm1740_set_reg_table(0, v27);
      status_cmd = bm1740_makeup_set_address_cmd(a1, a2, *v54);
      break;
    case 20:
      status_cmd = bm1740_makeup_chain_inactive_cmd(a1, a2);
      break;
    case 21:
    case 22:
      v53 = a4;
      status_cmd = bm1740_makeup_get_status_cmd(a1, a2, a4[1], *a4, 0);
      break;
    case 23:
      v52 = a4;
      v26[1] = 0;
      status_cmd = bm1740_makeup_set_config_cmd(a1, a2, a4[1], *a4, 8, 0);
      break;
    case 24:
      v51 = a4;
      status_cmd = bm1740_makeup_get_status_cmd(a1, a2, a4[1], *a4, 8);
      break;
    case 25:
      v50 = a4;
      bm1740_get_reg_table(12, v26);
      bm1740_get_plldata(*((_DWORD *)v50 + 1), v26);
      bm1740_set_reg_table(12, v26[0]);
      status_cmd = bm1740_makeup_set_config_cmd(a1, a2, v50[1], *v50, 12, v26[0]);
      break;
    case 26:
      v42 = a4;
      status_cmd = bm1740_makeup_get_status_cmd(a1, a2, a4[1], *a4, 36);
      break;
    case 27:
      v40 = a4;
      bm1740_get_reg_table(48, &v18);
      v18 = v18 & 0xF0FFFFFF | ((v40[2] & 0xF) << 24);
      v18 = v18 & 0xFF0FFFFF | ((v40[3] & 0xF) << 20);
      v18 = v18 & 0xFFF0FFFF | ((v40[4] & 0xF) << 16);
      v18 = v18 & 0xFFFF0FFF | ((v40[5] & 0xF) << 12);
      v18 = v18 & 0xFFFFF0FF | ((v40[6] & 0xF) << 8);
      v18 = v18 & 0xFFFFFF0F | (16 * (v40[7] & 0xF));
      v18 = v18 & 0xFFFFFFF0 | v40[8] & 0xF;
      bm1740_set_reg_table(48, v18);
      status_cmd = bm1740_makeup_set_config_cmd(a1, a2, v40[1], *v40, 48, v18);
      break;
    case 28:
      v39 = a4;
      bm1740_get_reg_table(52, &v17);
      if ( *((_DWORD *)v39 + 1) )
        v17 |= 0x80000000;
      else
        v17 &= ~0x80000000;
      bm1740_set_reg_table(52, v17);
      status_cmd = bm1740_makeup_set_config_cmd(a1, a2, v39[1], *v39, 52, v17);
      break;
    case 29:
      v38 = a4;
      status_cmd = bm1740_makeup_get_status_cmd(a1, a2, a4[1], *a4, 52);
      break;
    case 30:
      v37 = a4;
      bm1740_get_reg_table(56, &v16);
      v16 = (unsigned __int16)v16 | ((unsigned __int16)*((_DWORD *)v37 + 1) << 16);
      bm1740_set_reg_table(56, v16);
      status_cmd = bm1740_makeup_set_config_cmd(a1, a2, v37[1], *v37, 56, v16);
      break;
    case 31:
      v36 = a4;
      bm1740_get_reg_table(56, &v15);
      LOWORD(v15) = *((_DWORD *)v36 + 1);
      bm1740_set_reg_table(56, v15);
      status_cmd = bm1740_makeup_set_config_cmd(a1, a2, v36[1], *v36, 56, v15);
      break;
    case 32:
      v35 = a4;
      bm1740_get_reg_table(60, &v14);
      v14 = v14 & 0xFFFFFF3F | ((v35[2] & 3) << 6);
      bm1740_set_reg_table(60, v14);
      status_cmd = bm1740_makeup_set_config_cmd(a1, a2, v35[1], *v35, 60, v14);
      break;
    case 33:
      v34 = a4;
      bm1740_get_reg_table(60, &v13);
      v13 = v13 & 0xFFFFFFC0 | v34[2] & 0x3F;
      bm1740_set_reg_table(60, v13);
      status_cmd = bm1740_makeup_set_config_cmd(a1, a2, v34[1], *v34, 60, v13);
      break;
    case 34:
      v32 = a4;
      bm1740_get_reg_table(84, &v11);
      v11 = *((_DWORD *)v32 + 1);
      bm1740_set_reg_table(84, v11);
      status_cmd = bm1740_makeup_set_config_cmd(a1, a2, v32[1], *v32, 84, v11);
      break;
    case 35:
      v31 = a4;
      bm1740_get_reg_table(88, &v10);
      v10 = v10 & 0xFFFFFFFD | (2 * (*((_DWORD *)v31 + 1) & 1));
      v10 = v10 & 0xFFFFFFFE | *((_DWORD *)v31 + 2) & 1;
      bm1740_set_reg_table(88, v10);
      status_cmd = bm1740_makeup_set_config_cmd(a1, a2, v31[1], *v31, 88, v10);
      break;
    case 36:
      v30[6] = (int)a4;
      status_cmd = bm1740_makeup_bist_setup_cmd(a4[1], *a4, a1, a2);
      break;
    case 37:
      v30[5] = (int)a4;
      status_cmd = bm1740_makeup_bist_write_wait_cmd(a4[1], *a4, (int)(a4 + 2), a4[8], a1, a2);
      break;
    case 38:
      v30[4] = (int)a4;
      status_cmd = bm1740_makeup_bist_write_wait_read_cmd(a4[1], *a4, (int)(a4 + 2), a1, a2);
      break;
    case 39:
      v30[3] = (int)a4;
      status_cmd = bm1740_makeup_bist_wait_cmd(a4[1], *a4, (int)(a4 + 2), a1, a2);
      break;
    case 40:
      v30[2] = (int)a4;
      status_cmd = bm1740_makeup_bist_read_cmd(a4[1], *a4, a1, a2);
      break;
    case 41:
      v30[1] = (int)a4;
      status_cmd = bm1740_makeup_bist_disable_cmd(a4[1], *a4, a1, a2);
      break;
    default:
      if ( use_syslog || opt_log_output || opt_log_level >= 0 )
      {
        snprintf(v9, 0x100u, "unknow ioctl type %d\n", a3);
        applog(0, v9);
      }
      status_cmd = 0;
      break;
  }
  return status_cmd;
}
// 3089C: using guessed type int opt_log_level;
// 31294: using guessed type char use_syslog;
// 31297: using guessed type char opt_log_output;

//----- (00017F18) --------------------------------------------------------
int bm1740_soc_init()
{
  g_reg_table = 390070272;
  dword_624B0 = 0x80000000;
  dword_624B4 = -2144337391;
  dword_624B8 = 5;
  dword_624BC = 117455361;
  dword_624C0 = 0;
  dword_624C4 = 0;
  dword_624C8 = -1;
  dword_624CC = 34677009;
  dword_624D0 = 983040;
  dword_624D4 = -1;
  dword_624D8 = 0;
  dword_624DC = 0;
  dword_624E0 = 0;
  dword_624E4 = 3;
  return 0;
}
// 624AC: using guessed type int g_reg_table;
// 624B0: using guessed type int dword_624B0;
// 624B4: using guessed type int dword_624B4;
// 624B8: using guessed type int dword_624B8;
// 624BC: using guessed type int dword_624BC;
// 624C0: using guessed type int dword_624C0;
// 624C4: using guessed type int dword_624C4;
// 624C8: using guessed type int dword_624C8;
// 624CC: using guessed type int dword_624CC;
// 624D0: using guessed type int dword_624D0;
// 624D4: using guessed type int dword_624D4;
// 624D8: using guessed type int dword_624D8;
// 624DC: using guessed type int dword_624DC;
// 624E0: using guessed type int dword_624E0;
// 624E4: using guessed type int dword_624E4;

//----- (00018038) --------------------------------------------------------
int bm1740_soc_exit()
{
  return 0;
}

//----- (00018048) --------------------------------------------------------
int __fastcall my_log_curses(int result, const char *a2, const char *a3, char a4)
{
  if ( !opt_quiet || !result )
  {
    if ( a4 )
    {
      pthread_mutex_trylock(&console_lock);
      pthread_mutex_unlock(&console_lock);
    }
    pthread_mutex_lock(&console_lock);
    fprintf((FILE *)stderr, "%s%s", a2, a3);
    return pthread_mutex_unlock(&console_lock);
  }
  return result;
}
// 311F8: using guessed type int stderr;
// 31295: using guessed type char opt_quiet;
// 624F0: using guessed type pthread_mutex_t console_lock;

//----- (000180C8) --------------------------------------------------------
int __fastcall applog(int a1, const char *a2)
{
  int v2; // r0
  int result; // r0
  char v5[64]; // [sp+2Ch] [bp+14h] BYREF
  time_t tv_sec; // [sp+6Ch] [bp+54h] BYREF
  struct timeval v7; // [sp+70h] [bp+58h] BYREF
  struct tm *v8; // [sp+78h] [bp+60h]
  int v9; // [sp+7Ch] [bp+64h]

  v7.tv_sec = 0;
  v7.tv_usec = 0;
  gettimeofday(&v7, 0);
  tv_sec = v7.tv_sec;
  v9 = v7.tv_usec / 1000;
  v8 = localtime(&tv_sec);
  snprintf(
    v5,
    0x40u,
    " [%d-%02d-%02d %02d:%02d:%02d.%03d] ",
    v8->tm_year + 1900,
    v8->tm_mon + 1,
    v8->tm_mday,
    v8->tm_hour,
    v8->tm_min,
    v8->tm_sec,
    v9);
  v2 = fileno((FILE *)fl);
  result = isatty(v2);
  if ( !result )
  {
    fprintf((FILE *)fl, "%s%s", v5, a2);
    return fflush((FILE *)fl);
  }
  return result;
}
// 624EC: using guessed type int fl;

//----- (000181A8) --------------------------------------------------------
int __fastcall simplelog(int a1, const char *a2, char a3)
{
  int v3; // r0

  v3 = fileno((FILE *)stderr);
  if ( !isatty(v3) )
  {
    fprintf((FILE *)stderr, "%s\n", a2);
    fflush((FILE *)stderr);
  }
  return my_log_curses(a1, byte_2C6C8, a2, a3);
}
// 311F8: using guessed type int stderr;

//----- (00018218) --------------------------------------------------------
int __fastcall add_reg_item(int a1, int a2, int a3)
{
  int *v3; // r3
  int i; // [sp+18h] [bp+10h]
  int v9; // [sp+1Ch] [bp+14h]

  v9 = -1;
  pthread_mutex_lock(&reg_scan_mutex);
  for ( i = 0; i <= 99; ++i )
  {
    if ( reg_scan_items[3 * i + 2] <= 0 )
    {
      v3 = &reg_scan_items[3 * i];
      *v3 = a1;
      v3[1] = a2;
      v3[2] = a3;
      printf(
        "ADD: chainid=%02x chipaddr=%02x regaddr=%02x regdata=%08x age=%d\n",
        (unsigned __int8)a1,
        BYTE1(a1),
        BYTE2(a1),
        a2,
        a3);
      v9 = 1;
      break;
    }
  }
  pthread_mutex_unlock(&reg_scan_mutex);
  return v9;
}
// 31298: using guessed type int reg_scan_items[300];
// 31748: using guessed type pthread_mutex_t reg_scan_mutex;

//----- (000182BC) --------------------------------------------------------
int __fastcall read_reg_item(unsigned __int8 *a1)
{
  int i; // [sp+8h] [bp+8h]
  int v4; // [sp+Ch] [bp+Ch]

  v4 = -1;
  pthread_mutex_lock(&reg_scan_mutex);
  for ( i = 0; i <= 99; ++i )
  {
    if ( LOBYTE(reg_scan_items[3 * i]) == *a1
      && BYTE1(reg_scan_items[3 * i]) == a1[1]
      && BYTE2(reg_scan_items[3 * i]) == a1[2]
      && reg_scan_items[3 * i + 2] >= 0 )
    {
      *((_DWORD *)a1 + 1) = reg_scan_items[3 * i + 1];
      reg_scan_items[3 * i + 2] = -1;
      v4 = 1;
      break;
    }
  }
  pthread_mutex_unlock(&reg_scan_mutex);
  return v4;
}
// 31298: using guessed type int reg_scan_items[300];
// 31748: using guessed type pthread_mutex_t reg_scan_mutex;

//----- (000183B4) --------------------------------------------------------
void __noreturn reg_scan_aging()
{
  pthread_t v0; // r0
  int i; // [sp+4h] [bp+4h]

  v0 = pthread_self();
  pthread_detach(v0);
  while ( 1 )
  {
    sleep(1u);
    pthread_mutex_lock(&reg_scan_mutex);
    for ( i = 0; i <= 99; ++i )
    {
      if ( reg_scan_items[3 * i + 2] >= 0 )
        --reg_scan_items[3 * i + 2];
    }
    pthread_mutex_unlock(&reg_scan_mutex);
  }
}
// 31298: using guessed type int reg_scan_items[300];
// 31748: using guessed type pthread_mutex_t reg_scan_mutex;

//----- (00018448) --------------------------------------------------------
int reg_scan_init()
{
  int result; // r0
  char v1[256]; // [sp+0h] [bp+0h] BYREF
  int v2; // [sp+100h] [bp+100h]
  int i; // [sp+104h] [bp+104h]

  memset(reg_scan_items, 0, sizeof(reg_scan_items));
  for ( i = 0; i <= 99; ++i )
    reg_scan_items[3 * i + 2] = -1;
  pthread_mutex_init(&reg_scan_mutex, 0);
  result = pthread_create((pthread_t *)&p_reg_scan, 0, (void *(*)(void *))reg_scan_aging, 0);
  v2 = result;
  if ( result && (use_syslog || opt_log_output || opt_log_level > 2) )
  {
    strcpy(v1, "create pthread failed\n");
    return applog(3, v1);
  }
  return result;
}
// 3089C: using guessed type int opt_log_level;
// 31294: using guessed type char use_syslog;
// 31297: using guessed type char opt_log_output;
// 31298: using guessed type int reg_scan_items[300];
// 31748: using guessed type pthread_mutex_t reg_scan_mutex;
// 31760: using guessed type int p_reg_scan;

//----- (0001852C) --------------------------------------------------------
int reg_scan_exit()
{
  pthread_cancel(p_reg_scan);
  pthread_join(p_reg_scan, 0);
  return pthread_mutex_destroy(&reg_scan_mutex);
}
// 31748: using guessed type pthread_mutex_t reg_scan_mutex;
// 31760: using guessed type int p_reg_scan;

//----- (00018560) --------------------------------------------------------
int __fastcall rt_ringbuffer_get_size(int a1)
{
  return *(unsigned __int16 *)(a1 + 12);
}

//----- (00018578) --------------------------------------------------------
int __fastcall rt_ringbuffer_status(int a1)
{
  if ( *(_WORD *)(a1 + 4) >> 1 == *(_WORD *)(a1 + 6) >> 1 )
    return (*(_BYTE *)(a1 + 4) & 1) != (*(_BYTE *)(a1 + 6) & 1);
  else
    return 2;
}

//----- (000185C8) --------------------------------------------------------
int __fastcall rt_ringbuffer_data_len(_WORD *a1)
{
  int v1; // r0

  v1 = rt_ringbuffer_status((int)a1);
  if ( !v1 )
    return 0;
  if ( v1 == 1 )
    return (unsigned __int16)a1[6];
  if ( a1[3] >> 1 <= a1[2] >> 1 )
    return (unsigned __int16)(a1[6] + (a1[3] >> 1) - (a1[2] >> 1));
  return (unsigned __int16)((a1[3] >> 1) - (a1[2] >> 1));
}

//----- (00018650) --------------------------------------------------------
int __fastcall rt_ringbuffer_init(int a1, int a2, __int16 a3, int a4)
{
  int result; // r0

  *(_WORD *)(a1 + 4) &= 1u;
  *(_BYTE *)(a1 + 4) = *(_BYTE *)(a1 + 4) & 0xFE | ((*(_WORD *)(a1 + 4) & 2) != 0);
  *(_WORD *)(a1 + 6) &= 1u;
  *(_BYTE *)(a1 + 6) = *(_BYTE *)(a1 + 6) & 0xFE | ((*(_WORD *)(a1 + 6) & 2) != 0);
  *(_DWORD *)a1 = a2;
  *(_WORD *)(a1 + 12) = a3 & 0xFFFC;
  *(_DWORD *)(a1 + 136) = a4;
  result = pthread_mutex_init((pthread_mutex_t *)(a1 + 16), 0);
  if ( !*(_DWORD *)(a1 + 136) )
  {
    pthread_cond_init((pthread_cond_t *)(a1 + 40), 0);
    return pthread_cond_init((pthread_cond_t *)(a1 + 88), 0);
  }
  return result;
}

//----- (000186FC) --------------------------------------------------------
int __fastcall rt_ringbuffer_lock_destory(int a1)
{
  int result; // r0

  result = pthread_mutex_destroy((pthread_mutex_t *)(a1 + 16));
  if ( !*(_DWORD *)(a1 + 136) )
  {
    pthread_cond_destroy((pthread_cond_t *)(a1 + 40));
    return pthread_cond_destroy((pthread_cond_t *)(a1 + 88));
  }
  return result;
}

//----- (00018734) --------------------------------------------------------
int __fastcall rt_ringbuffer_put(int a1, char *a2, unsigned __int16 a3)
{
  __int16 v3; // r4
  __int16 v5; // r4
  unsigned __int16 v10; // [sp+16h] [bp+16h]

  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  v3 = *(_WORD *)(a1 + 12);
  v10 = v3 - rt_ringbuffer_data_len((_WORD *)a1);
  if ( *(_DWORD *)(a1 + 136) == 1 )
  {
    if ( !v10 )
    {
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
      return 0;
    }
    if ( v10 < (unsigned int)a3 )
      a3 = v10;
  }
  else if ( !*(_DWORD *)(a1 + 136) )
  {
    while ( v10 < (unsigned int)a3 )
    {
      pthread_cond_wait((pthread_cond_t *)(a1 + 40), (pthread_mutex_t *)(a1 + 16));
      v5 = *(_WORD *)(a1 + 12);
      v10 = v5 - rt_ringbuffer_data_len((_WORD *)a1);
    }
  }
  if ( *(unsigned __int16 *)(a1 + 12) - (*(_WORD *)(a1 + 6) >> 1) <= a3 )
  {
    memcpy(
      (void *)(*(_DWORD *)a1 + (*(_WORD *)(a1 + 6) >> 1)),
      a2,
      *(unsigned __int16 *)(a1 + 12) - (*(_WORD *)(a1 + 6) >> 1));
    memcpy(
      *(void **)a1,
      &a2[*(unsigned __int16 *)(a1 + 12) - (*(_WORD *)(a1 + 6) >> 1)],
      a3 + (*(_WORD *)(a1 + 6) >> 1) - *(unsigned __int16 *)(a1 + 12));
    *(_BYTE *)(a1 + 6) = *(_BYTE *)(a1 + 6) & 0xFE | ((*(_BYTE *)(a1 + 6) & 1) == 0);
    *(_WORD *)(a1 + 6) = *(_WORD *)(a1 + 6) & 1 | (2 * (((*(_WORD *)(a1 + 6) >> 1) - *(_WORD *)(a1 + 12) + a3) & 0x7FFF));
  }
  else
  {
    memcpy((void *)(*(_DWORD *)a1 + (*(_WORD *)(a1 + 6) >> 1)), a2, a3);
    *(_WORD *)(a1 + 6) = *(_WORD *)(a1 + 6) & 1 | (2 * (((*(_WORD *)(a1 + 6) >> 1) + a3) & 0x7FFF));
  }
  pthread_cond_signal((pthread_cond_t *)(a1 + 88));
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
  return a3;
}

//----- (000188FC) --------------------------------------------------------
int __fastcall rt_ringbuffer_put_force(int a1, char *a2, unsigned __int16 a3)
{
  __int16 v3; // r4
  unsigned __int16 v8; // [sp+16h] [bp+16h]

  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  v3 = *(_WORD *)(a1 + 12);
  v8 = v3 - rt_ringbuffer_data_len((_WORD *)a1);
  if ( a3 > (unsigned int)v8 )
    a3 = *(_WORD *)(a1 + 12);
  if ( *(unsigned __int16 *)(a1 + 12) - (*(_WORD *)(a1 + 6) >> 1) <= a3 )
  {
    memcpy(
      (void *)(*(_DWORD *)a1 + (*(_WORD *)(a1 + 6) >> 1)),
      a2,
      *(unsigned __int16 *)(a1 + 12) - (*(_WORD *)(a1 + 6) >> 1));
    memcpy(
      *(void **)a1,
      &a2[*(unsigned __int16 *)(a1 + 12) - (*(_WORD *)(a1 + 6) >> 1)],
      a3 + (*(_WORD *)(a1 + 6) >> 1) - *(unsigned __int16 *)(a1 + 12));
    *(_BYTE *)(a1 + 6) = *(_BYTE *)(a1 + 6) & 0xFE | ((*(_BYTE *)(a1 + 6) & 1) == 0);
    *(_WORD *)(a1 + 6) = *(_WORD *)(a1 + 6) & 1 | (2 * (((*(_WORD *)(a1 + 6) >> 1) - *(_WORD *)(a1 + 12) + a3) & 0x7FFF));
    if ( a3 > (unsigned int)v8 )
    {
      *(_BYTE *)(a1 + 4) = *(_BYTE *)(a1 + 4) & 0xFE | ((*(_BYTE *)(a1 + 4) & 1) == 0);
      *(_WORD *)(a1 + 4) = *(_WORD *)(a1 + 4) & 1 | (2 * ((*(_WORD *)(a1 + 6) >> 1) & 0x7FFF));
    }
  }
  else
  {
    memcpy((void *)(*(_DWORD *)a1 + (*(_WORD *)(a1 + 6) >> 1)), a2, a3);
    *(_WORD *)(a1 + 6) = *(_WORD *)(a1 + 6) & 1 | (2 * (((*(_WORD *)(a1 + 6) >> 1) + a3) & 0x7FFF));
    if ( a3 > (unsigned int)v8 )
      *(_WORD *)(a1 + 4) = *(_WORD *)(a1 + 4) & 1 | (2 * ((*(_WORD *)(a1 + 6) >> 1) & 0x7FFF));
  }
  pthread_cond_signal((pthread_cond_t *)(a1 + 88));
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
  return a3;
}

//----- (00018AC4) --------------------------------------------------------
int __fastcall rt_ringbuffer_get(int a1, char *a2, unsigned __int16 a3)
{
  unsigned int v8; // [sp+14h] [bp+14h]

  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  v8 = rt_ringbuffer_data_len((_WORD *)a1);
  if ( *(_DWORD *)(a1 + 136) == 1 )
  {
    if ( !v8 )
    {
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
      return 0;
    }
    if ( a3 > v8 )
      a3 = v8;
  }
  else if ( !*(_DWORD *)(a1 + 136) )
  {
    while ( a3 > v8 )
    {
      pthread_cond_wait((pthread_cond_t *)(a1 + 88), (pthread_mutex_t *)(a1 + 16));
      v8 = rt_ringbuffer_data_len((_WORD *)a1);
    }
  }
  if ( *(unsigned __int16 *)(a1 + 12) - (*(_WORD *)(a1 + 4) >> 1) <= a3 )
  {
    memcpy(
      a2,
      (const void *)(*(_DWORD *)a1 + (*(_WORD *)(a1 + 4) >> 1)),
      *(unsigned __int16 *)(a1 + 12) - (*(_WORD *)(a1 + 4) >> 1));
    memcpy(
      &a2[*(unsigned __int16 *)(a1 + 12) - (*(_WORD *)(a1 + 4) >> 1)],
      *(const void **)a1,
      a3 + (*(_WORD *)(a1 + 4) >> 1) - *(unsigned __int16 *)(a1 + 12));
    *(_BYTE *)(a1 + 4) = *(_BYTE *)(a1 + 4) & 0xFE | ((*(_BYTE *)(a1 + 4) & 1) == 0);
    *(_WORD *)(a1 + 4) = *(_WORD *)(a1 + 4) & 1 | (2 * (((*(_WORD *)(a1 + 4) >> 1) - *(_WORD *)(a1 + 12) + a3) & 0x7FFF));
    pthread_cond_signal((pthread_cond_t *)(a1 + 40));
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
  }
  else
  {
    memcpy(a2, (const void *)(*(_DWORD *)a1 + (*(_WORD *)(a1 + 4) >> 1)), a3);
    *(_WORD *)(a1 + 4) = *(_WORD *)(a1 + 4) & 1 | (2 * (((*(_WORD *)(a1 + 4) >> 1) + a3) & 0x7FFF));
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
    pthread_cond_signal((pthread_cond_t *)(a1 + 40));
  }
  return a3;
}

//----- (00018C80) --------------------------------------------------------
int __fastcall rt_ringbuffer_prefetch(_WORD *a1, char *a2, unsigned __int16 a3)
{
  unsigned int v8; // [sp+14h] [bp+14h]

  v8 = rt_ringbuffer_data_len(a1);
  if ( !v8 )
    return 0;
  if ( a3 > v8 )
    a3 = v8;
  if ( (unsigned __int16)a1[6] - (a1[2] >> 1) <= a3 )
  {
    memcpy(a2, (const void *)(*(_DWORD *)a1 + (a1[2] >> 1)), (unsigned __int16)a1[6] - (a1[2] >> 1));
    memcpy(&a2[(unsigned __int16)a1[6] - (a1[2] >> 1)], *(const void **)a1, a3 + (a1[2] >> 1) - (unsigned __int16)a1[6]);
  }
  else
  {
    memcpy(a2, (const void *)(*(_DWORD *)a1 + (a1[2] >> 1)), a3);
  }
  return a3;
}

//----- (00018D58) --------------------------------------------------------
int __fastcall Sha256_Init(int result)
{
  *(_DWORD *)result = 1779033703;
  *(_DWORD *)(result + 4) = -1150833019;
  *(_DWORD *)(result + 8) = 1013904242;
  *(_DWORD *)(result + 12) = -1521486534;
  *(_DWORD *)(result + 16) = 1359893119;
  *(_DWORD *)(result + 20) = -1694144372;
  *(_DWORD *)(result + 24) = 528734635;
  *(_DWORD *)(result + 28) = 1541459225;
  *(_QWORD *)(result + 32) = 0LL;
  return result;
}

//----- (00018DD8) --------------------------------------------------------
int *__fastcall Sha256_Transform(int *result, int a2)
{
  int v2; // r1
  int v3; // r0
  int v4; // r4
  unsigned int v5; // r2
  int v6; // r3
  int *v8; // [sp+4h] [bp+4h]
  _DWORD v9[24]; // [sp+8h] [bp+8h]
  unsigned int j; // [sp+68h] [bp+68h]
  unsigned int i; // [sp+6Ch] [bp+6Ch]
  int v12; // [sp+70h] [bp+70h] BYREF

  v8 = result;
  for ( i = 0; i <= 7; ++i )
  {
    result = &v12;
    v9[i] = v8[i];
  }
  for ( i = 0; i <= 0x3F; i += 16 )
  {
    for ( j = 0; j <= 0xF; ++j )
    {
      v2 = (7 - (_BYTE)j) & 7;
      v3 = v9[v2];
      v4 = (__ROR4__(*(&v12 + ((4 - (_BYTE)j) & 7) - 26), 6) ^ __ROR4__(*(&v12 + ((4 - (_BYTE)j) & 7) - 26), 11) ^ __ROR4__(*(&v12 + ((4 - (_BYTE)j) & 7) - 26), 25))
         + ((*(&v12 + ((6 - (_BYTE)j) & 7) - 26) ^ *(&v12 + ((5 - (_BYTE)j) & 7) - 26)) & *(&v12
                                                                                          + ((4 - (_BYTE)j) & 7)
                                                                                          - 26) ^ *(&v12
                                                                                                  + ((6 - (_BYTE)j) & 7)
                                                                                                  - 26))
         + K[j + i];
      if ( i )
      {
        v5 = j;
        *(&v12 + j - 18) = *(&v12 + (j & 0xF) - 18)
                         + (__ROR4__(*(&v12 + (((_BYTE)j - 2) & 0xF) - 18), 17) ^ __ROR4__(
                                                                                    *(&v12 + (((_BYTE)j - 2) & 0xF) - 18),
                                                                                    19) ^ ((unsigned int)*(&v12 + (((_BYTE)j - 2) & 0xF) - 18) >> 10))
                         + *(&v12 + (((_BYTE)j - 7) & 0xF) - 18)
                         + (__ROR4__(*(&v12 + (((_BYTE)j - 15) & 0xF) - 18), 7) ^ __ROR4__(
                                                                                    *(&v12 + (((_BYTE)j - 15) & 0xF)
                                                                                           - 18),
                                                                                    18) ^ ((unsigned int)*(&v12 + (((_BYTE)j - 15) & 0xF) - 18) >> 3));
        v6 = v9[v5 + 8];
      }
      else
      {
        *(&v12 + j - 18) = *(_DWORD *)(a2 + 4 * j);
        v6 = *(&v12 + j - 18);
      }
      v9[v2] = v3 + v4 + v6;
      *(&v12 + ((3 - (_BYTE)j) & 7) - 26) = v9[(3 - (_BYTE)j) & 7] + *(&v12 + ((7 - (_BYTE)j) & 7) - 26);
      result = &v12;
      v9[(7 - (_BYTE)j) & 7] += (__ROR4__(*(&v12 + (-j & 7) - 26), 2) ^ __ROR4__(*(&v12 + (-j & 7) - 26), 13) ^ __ROR4__(*(&v12 + (-j & 7) - 26), 22))
                              + ((*(&v12 + ((1 - (_BYTE)j) & 7) - 26) | *(&v12 + (-j & 7) - 26)) & *(&v12 + ((2 - (_BYTE)j) & 7) - 26) | *(&v12 + (-j & 7) - 26) & *(&v12 + ((1 - (_BYTE)j) & 7) - 26));
    }
  }
  for ( i = 0; i <= 7; ++i )
    v8[i] += *(&v12 + i - 26);
  return result;
}
// 18F08: masking with 0xF was optimized away because %var_C.4 <= 0xF
// 2C728: using guessed type _DWORD K[64];

//----- (000191B0) --------------------------------------------------------
int *__fastcall Sha256_WriteByteBlock(int *a1)
{
  _DWORD v2[16]; // [sp+Ch] [bp+Ch] BYREF
  unsigned int i; // [sp+4Ch] [bp+4Ch]

  for ( i = 0; i <= 0xF; ++i )
    v2[i] = (LOBYTE(a1[i + 10]) << 24) + (BYTE1(a1[i + 10]) << 16) + (BYTE2(a1[i + 10]) << 8) + HIBYTE(a1[i + 10]);
  return Sha256_Transform(a1, (int)v2);
}

//----- (00019230) --------------------------------------------------------
int *__fastcall Sha256_Update(int *result, _BYTE *a2, int a3)
{
  int *v5; // [sp+Ch] [bp+Ch]
  int v6; // [sp+14h] [bp+14h]

  v5 = result;
  v6 = *((_QWORD *)result + 4) & 0x3F;
  while ( a3 )
  {
    *((_BYTE *)v5 + v6++ + 40) = *a2++;
    ++*((_QWORD *)v5 + 4);
    --a3;
    if ( v6 == 64 )
    {
      v6 = 0;
      result = Sha256_WriteByteBlock(v5);
    }
  }
  return result;
}

//----- (0001929C) --------------------------------------------------------
int __fastcall Sha256_Final(int a1, _BYTE *a2)
{
  _BYTE *v4; // [sp+0h] [bp+0h]
  unsigned int j; // [sp+8h] [bp+8h]
  unsigned int k; // [sp+8h] [bp+8h]
  int v8; // [sp+Ch] [bp+Ch]
  int i; // [sp+Ch] [bp+Ch]
  int v10; // [sp+Ch] [bp+Ch]
  __int64 v11; // [sp+10h] [bp+10h]

  v11 = 8LL * *(_QWORD *)(a1 + 32);
  v8 = *(_QWORD *)(a1 + 32) & 0x3F;
  *(_BYTE *)(a1 + v8 + 40) = 0x80;
  for ( i = v8 + 1; i != 56; i = v10 + 1 )
  {
    v10 = i & 0x3F;
    if ( !v10 )
      Sha256_WriteByteBlock((int *)a1);
    *(_BYTE *)(a1 + v10 + 40) = 0;
  }
  for ( j = 0; j <= 7; ++j )
  {
    *(_BYTE *)(a1 + i++ + 40) = HIBYTE(v11);
    v11 <<= 8;
  }
  Sha256_WriteByteBlock((int *)a1);
  for ( k = 0; k <= 7; ++k )
  {
    *a2 = HIBYTE(*(_DWORD *)(a1 + 4 * k));
    v4 = a2 + 1;
    *v4++ = BYTE2(*(_DWORD *)(a1 + 4 * k));
    *v4++ = BYTE1(*(_DWORD *)(a1 + 4 * k));
    *v4 = *(_DWORD *)(a1 + 4 * k);
    a2 = v4 + 1;
  }
  return Sha256_Init(a1);
}

//----- (000193C8) --------------------------------------------------------
int __fastcall Sha256_Onestep(_BYTE *a1, int a2, _BYTE *a3)
{
  int v7[26]; // [sp+10h] [bp+10h] BYREF

  Sha256_Init((int)v7);
  Sha256_Update(v7, a1, a2);
  return Sha256_Final((int)v7, a3);
}

//----- (00019400) --------------------------------------------------------
unsigned int __fastcall compressArray(int a1, int a2, int a3, unsigned int a4, unsigned int a5, int a6)
{
  unsigned int result; // r0
  unsigned int v8; // [sp+18h] [bp+18h]
  unsigned int j; // [sp+1Ch] [bp+1Ch]
  unsigned int i; // [sp+20h] [bp+20h]
  int v11; // [sp+24h] [bp+24h]
  unsigned int v12; // [sp+28h] [bp+28h]
  unsigned int v13; // [sp+2Ch] [bp+2Ch]

  if ( a5 <= 7 )
    _assert_fail("bit_len >= 8", "bm1740/sort-verify.c", 0x15u, "compressArray");
  if ( a5 + 7 > 0x20 )
    _assert_fail("8 * sizeof(uint32_t) >= 7 + bit_len", "bm1740/sort-verify.c", 0x16u, "compressArray");
  v8 = ((a5 + 7) >> 3) + a6;
  result = a2 * a5 / (8 * v8);
  if ( result != a4 )
    _assert_fail("out_len == bit_len * in_len / (8 * in_width)", "bm1740/sort-verify.c", 0x19u, "compressArray");
  v13 = 0;
  v12 = 0;
  v11 = 0;
  for ( i = 0; i < a4; ++i )
  {
    if ( v13 <= 7 )
    {
      v12 <<= a5;
      for ( j = a6; j < v8; ++j )
        v12 |= (((unsigned int)((1 << a5) - 1) >> (8 * (v8 - j - 1))) & *(_BYTE *)(a1 + v11 + j)) << (8 * (v8 - j - 1));
      v11 += v8;
      v13 += a5;
    }
    v13 -= 8;
    *(_BYTE *)(a3 + i) = v12 >> v13;
  }
  return result;
}

//----- (00019560) --------------------------------------------------------
unsigned int __fastcall expandArray(int a1, unsigned int a2, int a3, int a4, unsigned int a5, unsigned int a6)
{
  unsigned int result; // r0
  unsigned int v8; // [sp+14h] [bp+14h]
  unsigned int k; // [sp+18h] [bp+18h]
  unsigned int j; // [sp+1Ch] [bp+1Ch]
  unsigned int i; // [sp+20h] [bp+20h]
  int v12; // [sp+24h] [bp+24h]
  unsigned int v13; // [sp+28h] [bp+28h]
  unsigned int v14; // [sp+2Ch] [bp+2Ch]

  if ( a5 <= 7 )
    _assert_fail("bit_len >= 8", "bm1740/sort-verify.c", 0x3Fu, "expandArray");
  if ( a5 + 7 > 0x20 )
    _assert_fail("8 * sizeof(uint32_t) >= 7 + bit_len", "bm1740/sort-verify.c", 0x40u, "expandArray");
  v8 = ((a5 + 7) >> 3) + a6;
  result = 8 * a2 * v8 / a5;
  if ( result != a4 )
    _assert_fail("out_len == 8 * out_width * in_len / bit_len", "bm1740/sort-verify.c", 0x43u, "expandArray");
  v14 = 0;
  v13 = 0;
  v12 = 0;
  for ( i = 0; i < a2; ++i )
  {
    v13 = *(unsigned __int8 *)(a1 + i) | (v13 << 8);
    v14 += 8;
    if ( v14 >= a5 )
    {
      v14 -= a5;
      for ( j = 0; j < a6; ++j )
        *(_BYTE *)(a3 + v12 + j) = 0;
      for ( k = a6; k < v8; ++k )
      {
        result = (1 << a5) - 1;
        *(_BYTE *)(a3 + v12 + k) = (result >> (8 * (v8 - k - 1))) & (v13 >> (8 * (v8 - k - 1) + v14));
      }
      v12 += v8;
    }
  }
  return result;
}

//----- (000196D8) --------------------------------------------------------
unsigned int __fastcall getIndices(int a1, int a2, int a3, int a4, int a5, unsigned int a6)
{
  if ( (unsigned int)(a4 + 8) > 0x27 )
    _assert_fail("((cBitLen + 1) + 7) / 8 <= sizeof(uint32_t)", "bm1740/sort-verify.c", 0x6Du, "getIndices");
  if ( (unsigned int)(a3 * (a4 + 1)) >> 5 > a6 )
    return -1;
  if ( a5 )
    compressArray(a1 + a2, a3, a5, (unsigned int)(a3 * (a4 + 1)) >> 5, a4 + 1, 4 - ((unsigned int)(a4 + 8) >> 3));
  return (unsigned int)(a3 * (a4 + 1)) >> 5;
}

//----- (00019764) --------------------------------------------------------
int __fastcall isZero(int a1, unsigned int a2)
{
  unsigned int i; // [sp+Ch] [bp+Ch]

  for ( i = 0; i < a2; ++i )
  {
    if ( *(_BYTE *)(a1 + i) )
      return 0;
  }
  return 1;
}

//----- (000197A0) --------------------------------------------------------
int __fastcall generateHash(const void *a1, int a2, void *a3, unsigned __int8 a4)
{
  _BYTE v7[364]; // [sp+10h] [bp+10h] BYREF
  int v8; // [sp+17Ch] [bp+17Ch] BYREF

  v8 = a2;
  memcpy(v7, a1, 0x168u);
  blake2b_update((int)v7, (char *)&v8, 4uLL);
  return blake2b_final((int)v7, a3, a4);
}

//----- (00019818) --------------------------------------------------------
int __fastcall compareSR(const void *a1, const void *a2)
{
  return memcmp(a1, a2, compare_size);
}
// 308A0: using guessed type int compare_size;

//----- (00019844) --------------------------------------------------------
int __fastcall sort_pair(int result, unsigned int a2)
{
  int v2; // [sp+8h] [bp+8h]
  int v3; // [sp+Ch] [bp+Ch]
  unsigned int i; // [sp+10h] [bp+10h]
  int v5; // [sp+14h] [bp+14h]

  v3 = result + 4 * a2;
  v5 = 0;
  for ( i = 0; i < a2; ++i )
  {
    if ( v5 || *(_DWORD *)(result + 4 * i) > *(_DWORD *)(v3 + 4 * i) )
    {
      v5 = 1;
      v2 = *(_DWORD *)(result + 4 * i);
      *(_DWORD *)(result + 4 * i) = *(_DWORD *)(v3 + 4 * i);
      *(_DWORD *)(v3 + 4 * i) = v2;
    }
    else if ( *(_DWORD *)(result + 4 * i) < *(_DWORD *)(v3 + 4 * i) )
    {
      return result;
    }
  }
  return result;
}

//----- (000198E8) --------------------------------------------------------
int __fastcall sortValidator(int *a1, int a2)
{
  int v2; // r3
  int v3; // r1
  int v4; // r2
  int v5; // r3
  int v6; // r1
  int v7; // r2
  char v9[256]; // [sp+10h] [bp+8h] BYREF
  int v10; // [sp+110h] [bp+108h] BYREF
  _BYTE v11[32]; // [sp+114h] [bp+10Ch] BYREF
  _BYTE v12[32]; // [sp+134h] [bp+12Ch] BYREF
  unsigned __int8 v13[3392]; // [sp+154h] [bp+14Ch] BYREF
  _BYTE v14[28]; // [sp+E94h] [bp+E8Ch] BYREF
  __int16 v15; // [sp+EB0h] [bp+EA8h]
  _DWORD v16[8]; // [sp+EB4h] [bp+EACh] BYREF
  _DWORD v17[512]; // [sp+ED4h] [bp+ECCh] BYREF
  char *v18; // [sp+16D4h] [bp+16CCh]
  char *v19; // [sp+16D8h] [bp+16D0h]
  int v20; // [sp+16DCh] [bp+16D4h]
  unsigned __int8 *v21; // [sp+16E0h] [bp+16D8h]
  int v22; // [sp+16E4h] [bp+16DCh]
  int v23; // [sp+16E8h] [bp+16E0h]
  int v24; // [sp+16ECh] [bp+16E4h]
  int v25; // [sp+16F0h] [bp+16E8h]
  unsigned int v26; // [sp+16F4h] [bp+16ECh]
  int v27; // [sp+16F8h] [bp+16F0h]
  int v28; // [sp+16FCh] [bp+16F4h]
  const void *v29; // [sp+1700h] [bp+16F8h]
  int v30; // [sp+1704h] [bp+16FCh]
  int v31; // [sp+1708h] [bp+1700h]
  int *v32; // [sp+170Ch] [bp+1704h]
  unsigned int i3; // [sp+1710h] [bp+1708h]
  unsigned int i2; // [sp+1714h] [bp+170Ch]
  int i1; // [sp+1718h] [bp+1710h]
  int nn; // [sp+171Ch] [bp+1714h]
  int mm; // [sp+1720h] [bp+1718h]
  unsigned int kk; // [sp+1724h] [bp+171Ch]
  int jj; // [sp+1728h] [bp+1720h]
  unsigned int ii; // [sp+172Ch] [bp+1724h]
  unsigned int n; // [sp+1730h] [bp+1728h]
  int m; // [sp+1734h] [bp+172Ch]
  unsigned int k; // [sp+1738h] [bp+1730h]
  int j; // [sp+173Ch] [bp+1734h]
  int i; // [sp+1740h] [bp+1738h]
  int v46; // [sp+1744h] [bp+173Ch]
  size_t v47; // [sp+1748h] [bp+1740h]
  char *v48; // [sp+174Ch] [bp+1744h]
  char *v49; // [sp+1750h] [bp+1748h]
  int v50; // [sp+1754h] [bp+174Ch]
  size_t v51; // [sp+1758h] [bp+1750h]
  size_t v52; // [sp+175Ch] [bp+1754h]

  v32 = a1;
  v31 = *a1;
  v30 = a1[1];
  v29 = (const void *)a1[2];
  v28 = v31 / (v30 + 1);
  v2 = v28 + 7;
  if ( v28 + 7 < 0 )
    v2 = v28 + 14;
  v27 = v2 >> 3;
  v26 = (v2 >> 3) * (v30 + 1);
  v25 = 512 / v31;
  v24 = v31 * (512 / v31) / 8;
  v23 = ((v31 / (v30 + 1) + 1) << v30) / 8;
  v22 = 512;
  v52 = 4;
  v51 = 512;
  v50 = 0;
  compare_size = 3;
  expandArray(a2, v23, (int)v17, 2048, v28 + 1, 1u);
  memset(v16, 0, 0x1Eu);
  v49 = (char *)malloc(0x4400u);
  v48 = (char *)malloc(0x4400u);
  v21 = 0;
  v47 = 0;
  memset(v14, 0, sizeof(v14));
  v15 = 0;
  v46 = 0;
LABEL_14:
  if ( v46 < v22 )
  {
    for ( i = v46 + 1; ; ++i )
    {
      if ( i >= v22 )
      {
        ++v46;
        goto LABEL_14;
      }
      if ( v17[v46] == v17[i] )
        break;
    }
    if ( use_syslog || opt_log_output || opt_log_level >= 0 )
    {
      strcpy(v9, "error: dup index\n");
      applog(0, v9);
    }
    v50 = 1;
  }
  else
  {
    for ( j = 0; j < v22; ++j )
    {
      v20 = bswap32(v17[j]);
      generateHash(v29, v20 / v25, v9, v24);
      expandArray((int)&v9[v31 * (v20 % v25) / 8], v31 / 8, (int)v12, v26, v28, 0);
      for ( k = 0; k < v26; ++k )
        *((_BYTE *)v16 + k) ^= v12[k];
      memcpy(&v49[j * (v26 + v52)], v12, v26);
      memcpy(&v49[j * (v26 + v52) + v26], &v17[j], v52);
    }
    if ( isZero((int)v16, 0x1Eu) )
    {
      memset(v16, 0, 0x1Eu);
      for ( m = 0; m <= 8; ++m )
      {
        qsort(v49, v51, v26 + v52, compareSR);
        v47 = 0;
        for ( n = 0; n < v51; n += 2 )
        {
          for ( ii = 0; ii < v26; ++ii )
            v14[ii] = v49[(n + 1) * (v26 + v52) + ii] ^ v49[n * (v26 + v52) + ii];
          memcpy(&v48[(n >> 1) * (2 * v52 + v26)], v14, v26);
          memcpy(&v48[(n >> 1) * (2 * v52 + v26) + v26], &v49[n * (v26 + v52) + v26], v52);
          memcpy(&v48[(n >> 1) * (2 * v52 + v26) + v26 + v52], &v49[(n + 1) * (v26 + v52) + v26], v52);
          ++v47;
        }
        v52 *= 2;
        v19 = v49;
        v49 = v48;
        v48 = v19;
        v51 = v47;
        compare_size += 3;
      }
      for ( jj = 0; jj <= 511; ++jj )
        *(_DWORD *)&v13[4 * jj + 1344] = bswap32(*(_DWORD *)&v49[4 * jj + v26]);
      for ( kk = 0; kk <= 8; ++kk )
      {
        for ( mm = 0; mm <= 511; mm += 2 << kk )
          sort_pair((int)&v13[4 * mm + 1344], 1 << kk);
      }
      v52 = 4;
      v51 = 512;
      for ( nn = 0; nn < v22; ++nn )
      {
        v10 = *(_DWORD *)&v13[4 * nn + 1344];
        generateHash(v29, v10 / v25, v9, v24);
        expandArray((int)&v9[v31 * (v10 % v25) / 8], v31 / 8, (int)v11, v26, v28, 0);
        v10 = bswap32(*(_DWORD *)&v13[4 * nn + 1344]);
        memcpy(&v49[nn * (v26 + v52)], v11, v26);
        memcpy(&v49[nn * (v26 + v52) + v26], &v10, v52);
        v21 = bin2hex((const unsigned __int8 *)&v49[nn * (v26 + v52)], 0x22u);
        free(v21);
      }
      for ( i1 = 0; i1 <= 8; ++i1 )
      {
        v47 = 0;
        for ( i2 = 0; i2 < v51; i2 += 2 )
        {
          for ( i3 = 0; i3 < v26; ++i3 )
            v14[i3] = v49[(i2 + 1) * (v26 + v52) + i3] ^ v49[i2 * (v26 + v52) + i3];
          memcpy(&v48[(i2 >> 1) * (2 * v52 + v26)], v14, v26);
          memcpy(&v48[(i2 >> 1) * (2 * v52 + v26) + v26], &v49[i2 * (v26 + v52) + v26], v52);
          memcpy(&v48[(i2 >> 1) * (2 * v52 + v26) + v26 + v52], &v49[(i2 + 1) * (v26 + v52) + v26], v52);
          ++v47;
        }
        v52 *= 2;
        v18 = v49;
        v49 = v48;
        v48 = v18;
        v51 = v47;
        compare_size += 3;
      }
      getIndices((int)v49, v26, 2048, 20, (int)v13, 0x540u);
      v21 = bin2hex(v13, 0x540u);
      free(v21);
      v21 = bin2hex((const unsigned __int8 *)v49, v26 + v52);
      free(v21);
      v3 = *((_DWORD *)v49 + 1);
      v4 = *((_DWORD *)v49 + 2);
      v5 = *((_DWORD *)v49 + 3);
      v16[0] = *(_DWORD *)v49;
      v16[1] = v3;
      v16[2] = v4;
      v16[3] = v5;
      v6 = *((_DWORD *)v49 + 5);
      v7 = *((_DWORD *)v49 + 6);
      v16[4] = *((_DWORD *)v49 + 4);
      v16[5] = v6;
      v16[6] = v7;
      LOWORD(v16[7]) = *((_WORD *)v49 + 14);
      if ( !isZero((int)v16, 0x1Eu) )
      {
        if ( use_syslog || opt_log_output || opt_log_level >= 0 )
        {
          snprintf(v9, 0x100u, "error: %s valid falied\n", "sortValidator");
          applog(0, v9);
        }
        v50 = 3;
      }
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level >= 0 )
      {
        snprintf(v9, 0x100u, "error: %s xor vHash = 0\n", "sortValidator");
        applog(0, v9);
      }
      v50 = 2;
    }
  }
  free(v49);
  free(v48);
  return v50;
}
// 3089C: using guessed type int opt_log_level;
// 308A0: using guessed type int compare_size;
// 31294: using guessed type char use_syslog;
// 31297: using guessed type char opt_log_output;

//----- (0001AAF4) --------------------------------------------------------
void *__fastcall zcashPerson(_DWORD *a1, int a2, int a3)
{
  void *result; // r0

  result = memcpy(a1, "ZcashPoW", 8u);
  a1[2] = a2;
  a1[3] = a3;
  return result;
}

//----- (0001AB28) --------------------------------------------------------
int __fastcall digestInit(void *a1, int a2, int a3)
{
  _DWORD v7[16]; // [sp+10h] [bp+10h] BYREF

  memset(v7, 0, sizeof(v7));
  HIWORD(v7[0]) = 257;
  LOBYTE(v7[0]) = a2 * (512 / a2) / 8;
  zcashPerson(&v7[12], a2, a3);
  return blake2b_init_param(a1, (int)v7);
}

//----- (0001AB90) --------------------------------------------------------
void __cdecl _bin2hex(unsigned __int8 *s, const unsigned __int8 *p, size_t len)
{
  unsigned __int8 *v4; // [sp+Ch] [bp+Ch]
  signed int i; // [sp+14h] [bp+14h]

  for ( i = 0; (int)len > i; ++i )
  {
    *s = hex_5140[p[i] >> 4];
    v4 = s + 1;
    *v4 = hex_5140[p[i] & 0xF];
    s = v4 + 1;
  }
  *s = 0;
}

//----- (0001AC08) --------------------------------------------------------
unsigned __int8 *__fastcall bin2hex(const unsigned __int8 *a1, size_t a2)
{
  unsigned __int8 *v5; // [sp+8h] [bp+8h]
  int nmemb; // [sp+Ch] [bp+Ch]

  nmemb = 2 * a2 + 1;
  if ( (nmemb & 3) != 0 )
    nmemb = (nmemb & 0xFFFFFFFC) + 4;
  v5 = (unsigned __int8 *)calloc(nmemb, 1u);
  if ( !v5 )
    fwrite("Failed to calloc", 1u, 0x10u, (FILE *)stderr);
  _bin2hex(v5, a1, a2);
  return v5;
}
// 311F8: using guessed type int stderr;

//----- (0001AC70) --------------------------------------------------------
int __fastcall hex2bin(_BYTE *a1, unsigned __int8 *a2, int a3)
{
  unsigned __int8 *v7; // [sp+8h] [bp+8h]
  int v9; // [sp+10h] [bp+10h]
  int v10; // [sp+14h] [bp+14h]
  unsigned __int8 v11; // [sp+1Bh] [bp+1Bh]
  unsigned __int8 v12; // [sp+1Bh] [bp+1Bh]
  int v13; // [sp+1Ch] [bp+1Ch]

  v13 = 0;
  while ( *a2 && a3 )
  {
    if ( !a2[1] )
      return 0;
    v11 = *a2;
    v7 = a2 + 1;
    v10 = hex2bin_tbl[v11];
    v12 = *v7;
    a2 = v7 + 1;
    v9 = hex2bin_tbl[v12];
    if ( v10 < 0 || v9 < 0 )
      return 0;
    *a1++ = v9 | (16 * v10);
    --a3;
  }
  if ( !a3 && !*a2 )
    return 1;
  return v13;
}
// 2C99C: using guessed type _DWORD hex2bin_tbl[256];

//----- (0001AD28) --------------------------------------------------------
int __fastcall swap_bit(unsigned __int8 a1)
{
  int i; // [sp+8h] [bp+8h]
  unsigned __int8 v3; // [sp+Fh] [bp+Fh]

  v3 = 0;
  for ( i = 0; i <= 7; ++i )
  {
    if ( (((int)a1 >> i) & 1) != 0 )
      v3 |= 1 << (7 - i);
  }
  return v3;
}

//----- (0001AD7C) --------------------------------------------------------
void __fastcall dump_str(FILE *a1, const char *a2, const unsigned __int8 *a3, size_t a4)
{
  unsigned __int8 *ptr; // [sp+14h] [bp+14h]

  ptr = bin2hex(a3, a4);
  if ( a2 )
    fprintf(a1, "%s %s\n", a2, (const char *)ptr);
  else
    fprintf(a1, "%s\n", (const char *)ptr);
  fflush(a1);
  free(ptr);
}

//----- (0001ADD4) --------------------------------------------------------
int __fastcall bit_read(int a1, int a2)
{
  int v2; // r3

  switch ( a2 % 8 )
  {
    case 0:
      v2 = (*(_BYTE *)(a1 + a2 / 8) & 1) != 0;
      break;
    case 1:
      v2 = (*(_BYTE *)(a1 + a2 / 8) & 2) != 0;
      break;
    case 2:
      v2 = (*(_BYTE *)(a1 + a2 / 8) & 4) != 0;
      break;
    case 3:
      v2 = (*(_BYTE *)(a1 + a2 / 8) & 8) != 0;
      break;
    case 4:
      v2 = (*(_BYTE *)(a1 + a2 / 8) & 0x10) != 0;
      break;
    case 5:
      v2 = (*(_BYTE *)(a1 + a2 / 8) & 0x20) != 0;
      break;
    case 6:
      v2 = (*(_BYTE *)(a1 + a2 / 8) & 0x40) != 0;
      break;
    case 7:
      v2 = *(_BYTE *)(a1 + a2 / 8) >> 7;
      break;
    default:
      v2 = 0;
      break;
  }
  return v2;
}

//----- (0001AF30) --------------------------------------------------------
int __fastcall get_BM1385_plldata(int a1, _DWORD *a2, unsigned __int16 *a3, _DWORD *a4)
{
  char v8[32]; // [sp+18h] [bp+10h] BYREF
  char v9[32]; // [sp+38h] [bp+30h] BYREF
  char v10[32]; // [sp+58h] [bp+50h] BYREF
  char v11[12]; // [sp+78h] [bp+70h] BYREF
  unsigned int i; // [sp+84h] [bp+7Ch]

  memset(v10, 0, sizeof(v10));
  memset(v9, 0, sizeof(v9));
  memset(v8, 0, sizeof(v8));
  sprintf(v11, "%d", a1);
  for ( i = 0; i <= 0x7B && memcmp((&freq_pll_1385)[4 * i], v11, 4u); ++i )
    ;
  printf("%s: i = %d, sizeof(freq_pll_1385)/sizeof(freq_pll_1385[0]) = %d\n", "get_BM1385_plldata", i, 124);
  if ( i == 124 )
  {
    printf("%s: Freq set Err!!!!\n", "get_BM1385_plldata");
    printf("%s: Using 200M\n", "get_BM1385_plldata");
    i = 4;
  }
  sprintf(v10, "%08x", (&freq_pll_1385)[4 * i + 1]);
  sprintf(v9, "%04x", (&freq_pll_1385)[4 * i + 2]);
  sprintf(v8, "%04x", (&freq_pll_1385)[4 * i + 3]);
  printf("%s: Freq %s, PLL1 %s, PLL2 %s, vilpll %s\n", "get_BM1385_plldata", v11, v10, v9, v8);
  *a2 = (&freq_pll_1385)[4 * i + 1];
  *a3 = (unsigned __int16)(&freq_pll_1385)[4 * i + 2];
  *a4 = (&freq_pll_1385)[4 * i + 3];
  return printf("%s: PLL1 %#x, PLL2 %#x, vilpll %#x\n", "get_BM1385_plldata", *a2, *a3, *a4);
}
// 308A8: using guessed type char *freq_pll_1385;

//----- (0001B17C) --------------------------------------------------------
unsigned int __fastcall read_BM1385_asic_register(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, char a4)
{
  unsigned __int8 v6; // [sp+1Ch] [bp+14h] BYREF
  unsigned __int8 v7; // [sp+1Dh] [bp+15h]
  unsigned __int8 v8; // [sp+1Eh] [bp+16h]
  unsigned __int8 v9; // [sp+1Fh] [bp+17h]

  v9 = 0;
  v6 = 4;
  v7 = a2;
  v8 = a3;
  if ( a4 )
    v6 |= 0x80u;
  v9 = CRC5(&v6, 0x1Bu);
  printf("%s: buf[0]=0x%x, buf[1]=0x%x, buf[2]=0x%x, buf[3]=0x%x\n", "read_BM1385_asic_register", v6, v7, v8, v9);
  return uart_send(a1, &v6, 4u);
}

//----- (0001B210) --------------------------------------------------------
int __fastcall set_BM1385_freq(unsigned __int8 a1, char a2, int a3, char a4)
{
  char v4; // r4
  char v5; // r4
  unsigned __int16 v11; // [sp+Eh] [bp+Eh] BYREF
  int v12; // [sp+10h] [bp+10h] BYREF
  int v13[4]; // [sp+14h] [bp+14h] BYREF
  char v14[4]; // [sp+24h] [bp+24h] BYREF
  int v15; // [sp+28h] [bp+28h]
  int v16; // [sp+2Ch] [bp+2Ch]

  v14[0] = 0;
  v14[1] = 0;
  v14[2] = 0;
  v14[3] = 0;
  memset(v13, 0, sizeof(v13));
  v12 = 0;
  v16 = 0;
  v15 = 0;
  v11 = 0;
  printf("\n--- %s\n", "set_BM1385_freq");
  get_BM1385_plldata(a3, v13, &v11, &v12);
  v14[0] = 7;
  v14[1] = BYTE2(v13[0]);
  v14[2] = BYTE1(v13[0]);
  v14[3] = v13[0];
  v4 = v13[0];
  v14[3] = CRC5((unsigned __int8 *)v14, 0x1Bu) | v4;
  uart_send(a1, (unsigned __int8 *)v14, 4u);
  usleep(0xBB8u);
  memset(v14, 0, sizeof(v14));
  memset(&v13[1], 0, 0xCu);
  if ( a4 )
    v14[0] |= 0x80u;
  v14[0] |= 2u;
  v14[1] = a2;
  v14[2] = HIBYTE(v11);
  v14[3] = v11;
  v5 = v11;
  v14[3] = CRC5((unsigned __int8 *)v14, 0x1Bu) | v5;
  uart_send(a1, (unsigned __int8 *)v14, 4u);
  return usleep(0x1388u);
}

//----- (0001B368) --------------------------------------------------------
void *__fastcall check_BM1385_asic_reg(unsigned __int8 a1, int a2, unsigned __int8 a3, char a4)
{
  int v4; // r0
  char v9[8]; // [sp+Ch] [bp+Ch] BYREF
  unsigned int v10; // [sp+14h] [bp+14h]
  unsigned int i; // [sp+18h] [bp+18h]
  unsigned int v12; // [sp+1Ch] [bp+1Ch]

  v9[0] = 0;
  v9[1] = 0;
  v9[2] = 0;
  v9[3] = 0;
  v9[4] = 0;
  v12 = 0;
  v10 = 0;
  i = 0;
  clear_register_value_buf();
  printf("%s: check chain J%d \n", "check_BM1385_asic_reg", a1 + 1);
  read_BM1385_asic_register(a1, 0, a3, a4);
  if ( !a3 )
    *((_BYTE *)&cgpu + a1 + 131836) = 0;
  while ( v12 <= 2 )
  {
    usleep((__useconds_t)&unk_493E0);
    pthread_mutex_lock(&reg_mutex);
    v10 = *(_DWORD *)(reg_value_buf + 8);
    pthread_mutex_unlock(&reg_mutex);
    if ( v10 )
    {
      v12 = 0;
      for ( i = 0; i < v10; ++i )
      {
        pthread_mutex_lock(&reg_mutex);
        if ( a1 == *(unsigned __int8 *)(reg_value_buf + 8 * (*(_DWORD *)(reg_value_buf + 4) + 2) + 5) )
        {
          memset(v9, 0, 5u);
          v9[3] = *(_DWORD *)(reg_value_buf + 8 * (*(_DWORD *)(reg_value_buf + 4) + 2));
          v9[2] = BYTE1(*(_DWORD *)(reg_value_buf + 8 * (*(_DWORD *)(reg_value_buf + 4) + 2)));
          v9[1] = BYTE2(*(_DWORD *)(reg_value_buf + 8 * (*(_DWORD *)(reg_value_buf + 4) + 2)));
          v9[0] = HIBYTE(*(_DWORD *)(reg_value_buf + 8 * (*(_DWORD *)(reg_value_buf + 4) + 2)));
          if ( CRC5((unsigned __int8 *)v9, 0x23u) == *(unsigned __int8 *)(reg_value_buf
                                                                        + 8 * (*(_DWORD *)(reg_value_buf + 4) + 2)
                                                                        + 4) )
          {
            if ( !a3 )
              ++*((_BYTE *)&cgpu + a1 + 131836);
            if ( a3 == 12 )
              printf(
                "%s: the asic freq is 0x%08x\n",
                "check_BM1385_asic_reg",
                *(_DWORD *)(reg_value_buf + 8 * (*(_DWORD *)(reg_value_buf + 4) + 2)));
            ++*(_DWORD *)(reg_value_buf + 4);
            --*(_DWORD *)(reg_value_buf + 8);
            if ( *(_DWORD *)(reg_value_buf + 4) == 512 )
              *(_DWORD *)(reg_value_buf + 4) = 0;
            pthread_mutex_unlock(&reg_mutex);
          }
          else
          {
            ++*(_DWORD *)(reg_value_buf + 4);
            --*(_DWORD *)(reg_value_buf + 8);
            if ( *(_DWORD *)(reg_value_buf + 4) == 512 )
              *(_DWORD *)(reg_value_buf + 4) = 0;
            v4 = CRC5((unsigned __int8 *)v9, 0x23u);
            printf(
              "%s: crc is 0x%x, but it should be 0x%x\n",
              "check_BM1385_asic_reg",
              v4,
              *(unsigned __int8 *)(reg_value_buf + 8 * (*(_DWORD *)(reg_value_buf + 4) + 2) + 4));
            pthread_mutex_unlock(&reg_mutex);
          }
        }
        else
        {
          ++*(_DWORD *)(reg_value_buf + 4);
          --*(_DWORD *)(reg_value_buf + 8);
          if ( *(_DWORD *)(reg_value_buf + 4) == 512 )
            *(_DWORD *)(reg_value_buf + 4) = 0;
          printf(
            "%s: the return data is from chain%d, but it should be from chain%d\n",
            "check_BM1385_asic_reg",
            *(unsigned __int8 *)(reg_value_buf + 8 * (*(_DWORD *)(reg_value_buf + 4) + 2) + 5),
            a1);
          pthread_mutex_unlock(&reg_mutex);
        }
      }
    }
    else
    {
      usleep(0x186A0u);
      printf("%s: no asic address register come back for %d time.\n", "check_BM1385_asic_reg", ++v12);
    }
  }
  v12 = 0;
  if ( !a3 )
  {
    if ( *((unsigned __int8 *)&cgpu + a1 + 131836) > (unsigned int)dword_61B4C )
      dword_61B4C = *((unsigned __int8 *)&cgpu + a1 + 131836);
    printf("%s: chain J%d has %d ASIC\n", "check_BM1385_asic_reg", a1 + 1, *((unsigned __int8 *)&cgpu + a1 + 131836));
  }
  return clear_register_value_buf();
}
// 417C0: using guessed type pthread_mutex_t reg_mutex;
// 61B4C: using guessed type int dword_61B4C;
// 61B5C: using guessed type int reg_value_buf;

//----- (0001B7CC) --------------------------------------------------------
int __fastcall BM1385_chain_inactive(unsigned __int8 a1)
{
  unsigned __int8 v3[3]; // [sp+14h] [bp+14h] BYREF
  unsigned __int8 v4; // [sp+17h] [bp+17h]

  v4 = 0;
  v3[0] = -123;
  v3[1] = 0;
  v3[2] = 0;
  v4 = CRC5(v3, 0x1Bu);
  uart_send(a1, v3, 4u);
  return usleep(0x1388u);
}

//----- (0001B830) --------------------------------------------------------
unsigned int __fastcall BM1385_set_address(unsigned __int8 a1, unsigned __int8 a2)
{
  unsigned __int8 v4[3]; // [sp+14h] [bp+14h] BYREF
  unsigned __int8 v5; // [sp+17h] [bp+17h]

  v5 = 0;
  v4[0] = 1;
  v4[1] = a2;
  v4[2] = 0;
  v5 = CRC5(v4, 0x1Bu);
  return uart_send(a1, v4, 4u);
}

//----- (0001B890) --------------------------------------------------------
unsigned int __fastcall BM1385_set_baud(unsigned __int8 a1, char a2, char a3, char a4)
{
  unsigned __int8 v6; // [sp+14h] [bp+14h] BYREF
  char v7; // [sp+15h] [bp+15h]
  char v8; // [sp+16h] [bp+16h]
  unsigned __int8 v9; // [sp+17h] [bp+17h]

  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  if ( a4 )
    v6 |= 0x80u;
  v6 |= 6u;
  v7 = a2;
  v8 = a3 & 0x1F;
  v9 = CRC5(&v6, 0x1Bu);
  return uart_send(a1, &v6, 4u);
}

//----- (0001B90C) --------------------------------------------------------
int __fastcall BM1385_set_gateblk(unsigned __int8 a1, int a2, char a3)
{
  unsigned __int8 v5; // [sp+18h] [bp+18h] BYREF
  char v6; // [sp+19h] [bp+19h]
  char v7; // [sp+1Ah] [bp+1Ah]
  char v8; // [sp+1Bh] [bp+1Bh]
  char v9; // [sp+1Fh] [bp+1Fh]

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  if ( a3 )
    v5 |= 0x80u;
  v5 |= 6u;
  v6 = 0;
  v7 = dword_61C6C | 0x80;
  v8 = 0;
  v9 = CRC5(&v5, 0x1Bu) & 0x1F;
  v8 |= v9;
  uart_send(a1, &v5, 4u);
  return usleep(0x2710u);
}
// 61C6C: using guessed type int dword_61C6C;

//----- (0001B9B4) --------------------------------------------------------
int reset_single_BM1385_global_arg()
{
  int result; // r0
  int v1; // [sp+8h] [bp+8h]
  unsigned int v2; // [sp+14h] [bp+14h]
  unsigned int v3; // [sp+18h] [bp+18h]
  unsigned int v4; // [sp+1Ch] [bp+1Ch]
  unsigned int v5; // [sp+20h] [bp+20h]
  unsigned int v6; // [sp+24h] [bp+24h]
  unsigned int k; // [sp+28h] [bp+28h]
  unsigned int i; // [sp+2Ch] [bp+2Ch]
  unsigned int m; // [sp+30h] [bp+30h]
  int j; // [sp+34h] [bp+34h]

  v6 = 0;
  v5 = dword_61C2C;
  v4 = dword_61C30;
  v3 = dword_61C34;
  v2 = dword_61C38;
  reset_global_arg();
  result = printf("\n--- %s\n", "reset_single_BM1385_global_arg");
  for ( i = 0; i <= 0x1F; ++i )
  {
    if ( (v5 & 1) != 0 )
      ++v6;
    v5 >>= 1;
    if ( (v4 & 1) != 0 )
      ++v6;
    v4 >>= 1;
    if ( (v3 & 1) != 0 )
      ++v6;
    v3 >>= 1;
    if ( (v2 & 1) != 0 )
      ++v6;
    v2 >>= 1;
  }
  for ( j = 0; !j; j = 1 )
  {
    unk_61B44 = 0;
    gRepeated_Nonce_Id[0] = 0;
    gValid_Nonce_Num[0] = 0;
    gSend_Work_Num[0] = 0;
    for ( k = 0; k < v6; ++k )
    {
      v1 = *((_DWORD *)&cgpu + k + 16427);
      for ( m = 0; dword_61BA0 > m; ++m )
        *(_DWORD *)(v1 + 56 * m + 52) = 0;
      gAsic_Core_Nonce_Num[k] = 0;
    }
  }
  return result;
}
// 317A8: using guessed type int gValid_Nonce_Num[];
// 317B0: using guessed type _DWORD gSend_Work_Num[1];
// 317B4: using guessed type _DWORD gAsic_Core_Nonce_Num[16384];
// 417B4: using guessed type _DWORD gRepeated_Nonce_Id[1];
// 61BA0: using guessed type int dword_61BA0;
// 61C2C: using guessed type int dword_61C2C;
// 61C30: using guessed type int dword_61C30;
// 61C34: using guessed type int dword_61C34;
// 61C38: using guessed type int dword_61C38;

//----- (0001BB74) --------------------------------------------------------
unsigned int single_BM1385_calculate_timeout_and_baud()
{
  unsigned int result; // r0
  unsigned int v1; // [sp+4h] [bp+4h]
  unsigned int v2; // [sp+Ch] [bp+Ch]

  v2 = 0;
  printf("\n--- %s\n", "single_BM1385_calculate_timeout_and_baud");
  v1 = calculate_core_number(0x32u);
  switch ( pattern_test_time )
  {
    case 0:
      v2 = dword_61BA8;
      break;
    case 1:
      v2 = dword_61BAC;
      break;
    case 2:
      v2 = dword_61BB0;
      break;
    case 3:
      v2 = dword_61BB4;
      break;
    case 4:
      v2 = dword_61BB8;
      break;
    case 5:
      v2 = dword_61BBC;
      break;
    case 6:
      v2 = dword_61BC0;
      break;
    case 7:
      v2 = dword_61BC4;
      break;
    case 8:
      v2 = dword_61BC8;
      break;
    default:
      printf(
        "%s: pattern_test_time = %d, error!!! \n",
        "single_BM1385_calculate_timeout_and_baud",
        (unsigned __int8)pattern_test_time);
      break;
  }
  dword_61C24 = 95 * (gChain_Asic_Interval * (0x1000000 / v1) / v2) / 0x64;
  result = 0x2FAF08 / ((0x196E6Au / dword_61C24) << 9);
  dword_61C6C = result - 1;
  if ( result - 1 > 0x1A )
    dword_61C6C = 26;
  dword_61BA4 = v2;
  dword_61C24 = 10000;
  return result;
}
// 31785: using guessed type char pattern_test_time;
// 31798: using guessed type int gChain_Asic_Interval;
// 61BA4: using guessed type int dword_61BA4;
// 61BA8: using guessed type int dword_61BA8;
// 61BAC: using guessed type int dword_61BAC;
// 61BB0: using guessed type int dword_61BB0;
// 61BB4: using guessed type int dword_61BB4;
// 61BB8: using guessed type int dword_61BB8;
// 61BBC: using guessed type int dword_61BBC;
// 61BC0: using guessed type int dword_61BC0;
// 61BC4: using guessed type int dword_61BC4;
// 61BC8: using guessed type int dword_61BC8;
// 61C24: using guessed type int dword_61C24;
// 61C6C: using guessed type int dword_61C6C;

//----- (0001BD48) --------------------------------------------------------
unsigned int __fastcall BM1722_set_address_all(unsigned __int8 a1)
{
  unsigned int result; // r0
  unsigned int i; // [sp+8h] [bp+8h]
  int v4; // [sp+Ch] [bp+Ch]

  v4 = 0;
  printf("\n--- %s: Chain : %d\n", "single_BM1385_set_address", a1);
  BM1385_chain_inactive(a1);
  for ( i = 0; ; ++i )
  {
    result = 0x100u / gChain_Asic_Interval;
    if ( 0x100u / gChain_Asic_Interval <= i )
      break;
    BM1385_set_address(a1, v4);
    v4 += gChain_Asic_Interval;
    usleep(0x1388u);
  }
  return result;
}
// 31798: using guessed type int gChain_Asic_Interval;

//----- (0001BDD4) --------------------------------------------------------
int __fastcall single_BM1385_set_baud(unsigned __int8 a1, unsigned __int8 a2)
{
  printf("\n--- %s: Chain : %d, baud = %d\n", "single_BM1385_set_baud", a1, a2);
  BM1385_set_baud(a1, 0, a2, 1);
  usleep(0xC350u);
  return set_fpga_baud(a2);
}

//----- (0001BE24) --------------------------------------------------------
int __fastcall single_BM1385_open_core(unsigned __int8 a1)
{
  int result; // r0
  char v3[64]; // [sp+Ch] [bp+Ch] BYREF
  int v4; // [sp+4Ch] [bp+4Ch]
  int v5; // [sp+50h] [bp+50h]
  int v6; // [sp+54h] [bp+54h]
  int v7; // [sp+58h] [bp+58h]
  int v8; // [sp+5Ch] [bp+5Ch]
  int v9; // [sp+60h] [bp+60h]
  int v10; // [sp+64h] [bp+64h]
  int v11; // [sp+68h] [bp+68h]
  unsigned int v12; // [sp+6Ch] [bp+6Ch]
  unsigned int v13; // [sp+70h] [bp+70h]
  unsigned int i; // [sp+74h] [bp+74h]

  i = 0;
  v11 = 0;
  v10 = 0;
  v9 = 0;
  v8 = 0;
  v7 = 0;
  v6 = 0;
  memset(v3, 0, sizeof(v3));
  v3[0] = -1;
  v13 = dword_61C2C;
  v12 = dword_61C30;
  v5 = dword_61C34;
  v4 = dword_61C38;
  printf("\n--- %s: Chain : %d\n", "single_BM1385_open_core", a1);
  gIsOpenCoreEnd = 0;
  memset(v3, 0, sizeof(v3));
  BM1385_set_gateblk(a1, 0, 1);
  for ( i = 0; i <= 0x31; ++i )
  {
    uart_send(a1, (unsigned __int8 *)v3, 0x40u);
    usleep(dword_61C20);
  }
  memset(v3, 0, sizeof(v3));
  result = BM1385_set_gateblk(a1, 0, 1);
  for ( i = 0; i <= 0x31; ++i )
  {
    if ( i > 0x1F )
    {
      if ( (v12 & 1) != 0 )
        v3[52] = -1;
      v12 >>= 1;
    }
    else
    {
      if ( (v13 & 1) != 0 )
        v3[52] = -1;
      v13 >>= 1;
    }
    uart_send(a1, (unsigned __int8 *)v3, 0x40u);
    result = usleep(dword_61C20);
  }
  gIsOpenCoreEnd = 1;
  return result;
}
// 1BF4A: conditional instruction was optimized away because %var_4.4 is in (20..31)
// 1BF50: conditional instruction was optimized away because %var_4.4 is in (20..31)
// 317A2: using guessed type char gIsOpenCoreEnd;
// 61C20: using guessed type int dword_61C20;
// 61C2C: using guessed type int dword_61C2C;
// 61C30: using guessed type int dword_61C30;
// 61C34: using guessed type int dword_61C34;
// 61C38: using guessed type int dword_61C38;

//----- (0001BFC4) --------------------------------------------------------
int __fastcall single_BM1385_get_result(unsigned __int8 a1)
{
  int v3; // [sp+10h] [bp+10h]
  int v4; // [sp+10h] [bp+10h]
  unsigned int v5; // [sp+28h] [bp+28h]
  unsigned int v6; // [sp+2Ch] [bp+2Ch]
  int v7; // [sp+30h] [bp+30h]
  int v8; // [sp+34h] [bp+34h]
  unsigned int m; // [sp+38h] [bp+38h]
  unsigned int k; // [sp+38h] [bp+38h]
  unsigned int i; // [sp+3Ch] [bp+3Ch]
  unsigned int j; // [sp+3Ch] [bp+3Ch]

  v8 = 0;
  v7 = 1;
  v6 = dword_61C2C;
  v5 = dword_61C30;
  puts("\n\n------------------------------------------------------------------------------------------------------\n");
  printf("every CORE require nonce number: %lu\n\n", dword_61BA0);
  printf("Open core number : Conf.OpenCoreNum1 = %u = 0x%08x\n", dword_61C2C, dword_61C2C);
  printf("Open core number : Conf.OpenCoreNum2 = %u = 0x%08x\n", dword_61C30, dword_61C30);
  printf("Open core number : Conf.OpenCoreNum3 = %u = 0x%08x\n", dword_61C34, dword_61C34);
  printf("Open core number : Conf.OpenCoreNum4 = %u = 0x%08x\n\n", dword_61C38, dword_61C38);
  for ( i = 0; i <= 0x31; ++i )
  {
    if ( !(i % 0xA) )
      putchar(10);
    printf("core[%02d]=%02d\t", i, gAsic_Core_Nonce_Num[0x4000 * a1 + i]);
  }
  puts("\n\n");
  for ( j = 0; j <= 0x31; ++j )
  {
    if ( j > 0x1F )
    {
      if ( (v5 & 1) != 0 )
      {
        v4 = *((_DWORD *)&cgpu + v8 + 16427);
        if ( gAsic_Core_Nonce_Num[0x4000 * a1 + j] < (unsigned int)dword_61BA0 )
        {
          v7 &= ~1u;
          printf("core[%02d] = %d,      lost these nonce : ", j, gAsic_Core_Nonce_Num[0x4000 * a1 + j]);
          for ( k = 0; dword_61BA0 > k; ++k )
          {
            if ( !*(_DWORD *)(v4 + 56 * k + 4 * (a1 + 12) + 4) )
              printf("%d  ", k);
          }
          putchar(10);
        }
        v5 >>= 1;
        ++v8;
      }
      else
      {
        v5 >>= 1;
      }
    }
    else if ( (v6 & 1) != 0 )
    {
      v3 = *((_DWORD *)&cgpu + v8 + 16427);
      if ( gAsic_Core_Nonce_Num[0x4000 * a1 + j] < (unsigned int)dword_61BA0 )
      {
        v7 &= ~1u;
        printf("core[%02d] = %d,      lost these nonce : ", j, gAsic_Core_Nonce_Num[0x4000 * a1 + j]);
        for ( m = 0; dword_61BA0 > m; ++m )
        {
          if ( !*(_DWORD *)(v3 + 56 * m + 4 * (a1 + 12) + 4) )
            printf("%d  ", m);
        }
        putchar(10);
      }
      v6 >>= 1;
      ++v8;
    }
    else
    {
      v6 >>= 1;
    }
  }
  puts("\n------------------------------------------------------------------------------------------------------\n");
  printf("Chain%d total valid nonce number: %d\n\n", a1, gValid_Nonce_Num[a1]);
  if ( (v7 & 1) != 0 )
    puts("Pattern OK\n");
  else
    puts("Pattern NG\n");
  printf("HW number = %d\n\n", gHw_Nonce_Num[a1]);
  return v7;
}
// 1C244: conditional instruction was optimized away because %var_4.4 is in (20..31)
// 1C24A: conditional instruction was optimized away because %var_4.4 is in (20..31)
// 317A8: using guessed type int gValid_Nonce_Num[];
// 317AC: using guessed type int gHw_Nonce_Num[];
// 317B4: using guessed type _DWORD gAsic_Core_Nonce_Num[16384];
// 61BA0: using guessed type int dword_61BA0;
// 61C2C: using guessed type int dword_61C2C;
// 61C30: using guessed type int dword_61C30;
// 61C34: using guessed type int dword_61C34;
// 61C38: using guessed type int dword_61C38;

//----- (0001C3CC) --------------------------------------------------------
unsigned int __fastcall single_asic_print_lcd(int a1, char a2)
{
  char v4[20]; // [sp+8h] [bp+8h] BYREF

  qmemcpy(v4, "      HW        ", 16);
  display_level_result_on_lcd();
  if ( (a2 & 1) != 0 )
    write_lcd_no_memset(2u, (int)"   Pattern OK   ", 0x10u);
  else
    write_lcd_no_memset(2u, (int)"   Pattern NG   ", 0x10u);
  sprintf(&v4[10], "%d", gHw_Nonce_Num[(unsigned __int8)gChain]);
  return write_lcd_no_memset(1u, (int)v4, 0x10u);
}
// 3106C: using guessed type char gChain;
// 317AC: using guessed type int gHw_Nonce_Num[];

//----- (0001C464) --------------------------------------------------------
void __fastcall __noreturn single_BM1385_show_status_func(unsigned __int8 *a1)
{
  unsigned __int8 v1; // [sp+Bh] [bp+Bh]

  v1 = *a1;
  time_counter = 0;
  while ( 1 )
  {
    memset(&lcd_output, 32, 0x40u);
    sprintf(s, "   time %ds", time_counter);
    sprintf(byte_310B0, "   nonce=%d", gValid_Nonce_Num[v1]);
    ++time_counter;
    write(lcd_fd, &lcd_output, 0x40u);
    set_fan_speed(10);
    usleep(0xF4240u);
  }
}
// 31788: using guessed type int time_counter;
// 317A8: using guessed type int gValid_Nonce_Num[];
// 41824: using guessed type int lcd_fd;

//----- (0001C518) --------------------------------------------------------
bool __fastcall is_nonce_or_reg_value(char a1)
{
  return a1 < 0;
}

//----- (0001C53C) --------------------------------------------------------
int __fastcall single_BM1385_check_nonce(unsigned __int8 a1, unsigned __int8 *a2)
{
  int v6; // [sp+1Ch] [bp+14h]
  unsigned int v7; // [sp+24h] [bp+1Ch]
  unsigned int v8; // [sp+2Ch] [bp+24h]
  unsigned int v9; // [sp+30h] [bp+28h]
  unsigned int v10; // [sp+34h] [bp+2Ch]
  unsigned int v11; // [sp+3Ch] [bp+34h]
  unsigned int v12; // [sp+40h] [bp+38h]
  int v13; // [sp+44h] [bp+3Ch]
  int v14; // [sp+48h] [bp+40h]
  unsigned int j; // [sp+4Ch] [bp+44h]
  unsigned int k; // [sp+4Ch] [bp+44h]
  unsigned int i; // [sp+4Ch] [bp+44h]
  unsigned int m; // [sp+4Ch] [bp+44h]

  v14 = 0;
  v13 = 0;
  v7 = _byteswap_ulong(*(_DWORD *)a2);
  v10 = *a2 / (unsigned int)gChain_Asic_Interval;
  v9 = a2[3] & 0x3F;
  v8 = a2[4] & 0x7F;
  if ( v10 )
  {
    printf("%s: received ASIC%02d nonce. error!!!\t", "single_BM1385_check_nonce", v10);
    printf(",received data is : 0x%02x%02x%02x%02x%02x\n", *a2, a2[1], a2[2], a2[3], a2[4]);
    return -1;
  }
  else if ( v9 <= 0x31 )
  {
    if ( dword_61BA0 > v8 )
    {
      v12 = dword_61C2C;
      v11 = dword_61C30;
      if ( v9 <= 0x1F )
      {
        for ( i = 0; v9 + 1 > i; ++i )
        {
          if ( (v12 & 1) != 0 )
            ++v14;
          v12 >>= 1;
        }
      }
      else
      {
        for ( j = 0; j <= 0x1F; ++j )
        {
          if ( (v12 & 1) != 0 )
            ++v14;
          v12 >>= 1;
        }
        for ( k = 0; v9 - 31 > k; ++k )
        {
          if ( (v11 & 1) != 0 )
            ++v14;
          v11 >>= 1;
        }
      }
      v6 = *((_DWORD *)&cgpu + v14 + 16426) + 56 * v8;
      if ( v7 == *(_DWORD *)(v6 + 4) )
      {
        if ( *(_DWORD *)(v6 + 4 * (a1 + 12) + 4) )
        {
          ++gRepeated_Nonce_Id[a1];
          ++*(_DWORD *)(v6 + 4 * (a1 + 12) + 4);
        }
        else
        {
          ++*(_DWORD *)(v6 + 4 * (a1 + 12) + 4);
          ++gValid_Nonce_Num[a1];
          ++gAsic_Core_Nonce_Num[0x4000 * a1 + v9];
        }
      }
      else
      {
        pthread_mutex_lock(&HW_check_mutex[a1]);
        for ( m = 0; (unsigned __int8)gWork_Num_For_Hw_Check > m; ++m )
        {
          v13 = check_hw(&gWorks_For_Hw_Check[140 * a1 + 14 * m], v7, 0);
          if ( !v13 )
            break;
        }
        pthread_mutex_unlock(&HW_check_mutex[a1]);
        if ( v13 == 1 )
        {
          ++gHw_Nonce_Num[a1];
          printf("%s: Find a HW. Chain%d ASIC%d Core%d : nonce = 0x%08x.\n", "single_BM1385_check_nonce", a1, 0, v9, v7);
        }
      }
      return 0;
    }
    else
    {
      printf("%s: received work_id = %02d nonce. error!!!\t", "single_BM1385_check_nonce", v8);
      printf(",received data is : 0x%02x%02x%02x%02x%02x\n", *a2, a2[1], a2[2], a2[3], a2[4]);
      return -1;
    }
  }
  else
  {
    printf("%s: received core%02d nonce. error!!!\t", "single_BM1385_check_nonce", v9);
    printf(",received data is : 0x%02x%02x%02x%02x%02x\n", *a2, a2[1], a2[2], a2[3], a2[4]);
    return -1;
  }
}
// 31798: using guessed type int gChain_Asic_Interval;
// 317A8: using guessed type int gValid_Nonce_Num[];
// 317AC: using guessed type int gHw_Nonce_Num[];
// 317B4: using guessed type _DWORD gAsic_Core_Nonce_Num[16384];
// 417B4: using guessed type _DWORD gRepeated_Nonce_Id[1];
// 417BC: using guessed type char gWork_Num_For_Hw_Check;
// 417D8: using guessed type pthread_mutex_t HW_check_mutex[1];
// 61BA0: using guessed type int dword_61BA0;
// 61C2C: using guessed type int dword_61C2C;
// 61C30: using guessed type int dword_61C30;
// 61C34: using guessed type int dword_61C34;
// 61C38: using guessed type int dword_61C38;
// 6250C: using guessed type _DWORD gWorks_For_Hw_Check[140];

//----- (0001C984) --------------------------------------------------------
int __fastcall single_BM1385_check_register_value(char a1, int a2)
{
  if ( *(_DWORD *)(reg_value_buf + 8) > 0x1FEu )
  {
    printf("%s: reg_value_buf buffer is full!\n", "single_BM1385_check_register_value");
    return -1;
  }
  else
  {
    *(_DWORD *)(reg_value_buf + 8 * (*(_DWORD *)reg_value_buf + 2)) = _byteswap_ulong(*(_DWORD *)a2);
    *(_BYTE *)(reg_value_buf + 8 * (*(_DWORD *)reg_value_buf + 2) + 4) = *(_BYTE *)(a2 + 4) & 0x1F;
    *(_BYTE *)(reg_value_buf + 8 * (*(_DWORD *)reg_value_buf + 2) + 5) = a1;
    ++*(_DWORD *)reg_value_buf;
    ++*(_DWORD *)(reg_value_buf + 8);
    if ( *(_DWORD *)reg_value_buf > 0x1FFu )
      *(_DWORD *)reg_value_buf = 0;
    return 0;
  }
}
// 61B5C: using guessed type int reg_value_buf;

//----- (0001CA94) --------------------------------------------------------
int __fastcall single_BM1385_send_func(unsigned __int8 *a1)
{
  int v1; // r3
  char v3[64]; // [sp+14h] [bp+Ch] BYREF
  void *src; // [sp+54h] [bp+4Ch]
  int v5; // [sp+58h] [bp+50h]
  int v6; // [sp+5Ch] [bp+54h]
  int v7; // [sp+60h] [bp+58h]
  int v8; // [sp+64h] [bp+5Ch]
  int v9; // [sp+68h] [bp+60h]
  int v10; // [sp+6Ch] [bp+64h]
  unsigned __int8 v11; // [sp+73h] [bp+6Bh]
  unsigned __int8 *v12; // [sp+74h] [bp+6Ch]
  int i; // [sp+78h] [bp+70h]
  unsigned int v14; // [sp+7Ch] [bp+74h]
  unsigned int v15; // [sp+80h] [bp+78h]
  unsigned int v16; // [sp+84h] [bp+7Ch]
  unsigned int v17; // [sp+88h] [bp+80h]
  unsigned int j; // [sp+8Ch] [bp+84h]
  unsigned int v19; // [sp+90h] [bp+88h]
  unsigned int k; // [sp+94h] [bp+8Ch]

  v12 = a1;
  v11 = *a1;
  v10 = 0;
  v9 = 0;
  k = 0;
  v19 = 0;
  j = 0;
  memset(v3, 0, sizeof(v3));
  v3[0] = -1;
  v8 = 0;
  v7 = 0;
  v6 = 0;
  v17 = dword_61C2C;
  v16 = dword_61C30;
  v15 = dword_61C34;
  v14 = dword_61C38;
  for ( i = 0; i <= 31; ++i )
  {
    if ( (v17 & 1) != 0 )
      ++v19;
    v17 >>= 1;
    if ( (v16 & 1) != 0 )
      ++v19;
    v16 >>= 1;
    if ( (v15 & 1) != 0 )
      ++v19;
    v15 >>= 1;
    if ( (v14 & 1) != 0 )
      ++v19;
    v14 >>= 1;
  }
  printf("%s: There are %d cores should be test\n\n", "single_BM1385_send_func", v19);
  for ( j = 0; j < v19; ++j )
  {
    v5 = *((_DWORD *)&cgpu + j + 16427);
    for ( k = 0; dword_61BA0 > k; ++k )
    {
      src = (void *)(v5 + 56 * k);
      memset(v3, 0, sizeof(v3));
      for ( i = 0; i <= 31; ++i )
        v3[i] = *((_BYTE *)src + i + 20);
      v6 = *((_DWORD *)src + 1);
      v3[44] = HIBYTE(v6);
      v3[45] = BYTE2(v6);
      v3[46] = BYTE1(v6);
      v3[47] = v6;
      v3[51] = k;
      for ( i = 0; i <= 11; ++i )
        v3[i + 52] = *((_BYTE *)src + i + 8);
      uart_send(v11, (unsigned __int8 *)v3, 0x40u);
      pthread_mutex_lock(&HW_check_mutex[v11]);
      for ( i = 8; i >= 0; --i )
        memcpy(
          (char *)&gWorks_For_Hw_Check + 560 * v11 + 56 * i + 56,
          (char *)&gWorks_For_Hw_Check + 560 * v11 + 56 * i,
          0x38u);
      if ( (unsigned __int8)++gWork_Num_For_Hw_Check > 8u )
        gWork_Num_For_Hw_Check = 9;
      memcpy((char *)&gWorks_For_Hw_Check + 560 * v11, src, 0x38u);
      pthread_mutex_unlock(&HW_check_mutex[v11]);
      ++gSend_Work_Num[v11];
      usleep(dword_61C24);
    }
  }
  while ( gSend_Work_Num[v11] < v19 * dword_61BA0 )
    printf(
      "\n\n---%s: Chain%d send work num : %d, less than %d\n",
      "single_BM1385_send_func",
      v11,
      gSend_Work_Num[v11],
      50 * dword_61BA0);
  printf("\n\n---%s: Chain%d send work num : %d\n", "single_BM1385_send_func", v11, gSend_Work_Num[v11]);
  puts("\nsend test pattern done");
  system("date");
  putchar(10);
  usleep(0xC350u);
  start_receive = 0;
  puts("to stop receive");
  return v1;
}
// 1CEBC: variable 'v1' is possibly undefined
// 317A5: using guessed type char start_receive;
// 317B0: using guessed type _DWORD gSend_Work_Num[1];
// 417BC: using guessed type char gWork_Num_For_Hw_Check;
// 417D8: using guessed type pthread_mutex_t HW_check_mutex[1];
// 61BA0: using guessed type int dword_61BA0;
// 61C24: using guessed type int dword_61C24;
// 61C2C: using guessed type int dword_61C2C;
// 61C30: using guessed type int dword_61C30;
// 61C34: using guessed type int dword_61C34;
// 61C38: using guessed type int dword_61C38;

//----- (0001CEC8) --------------------------------------------------------
int __fastcall single_BM1385_receive_func(unsigned __int8 *a1)
{
  _DWORD v2[2]; // [sp+Ch] [bp+Ch] BYREF
  _BYTE v3[500]; // [sp+14h] [bp+14h] BYREF
  _BYTE v4[1000]; // [sp+208h] [bp+208h] BYREF
  int v5; // [sp+5F0h] [bp+5F0h]
  unsigned int v6; // [sp+5F4h] [bp+5F4h]
  unsigned int v7; // [sp+5F8h] [bp+5F8h]
  unsigned int v8; // [sp+5FCh] [bp+5FCh]
  unsigned __int8 v9; // [sp+602h] [bp+602h]
  unsigned __int8 v10; // [sp+603h] [bp+603h]
  unsigned __int8 *v11; // [sp+604h] [bp+604h]
  unsigned int k; // [sp+608h] [bp+608h]
  unsigned int j; // [sp+60Ch] [bp+60Ch]
  unsigned int i; // [sp+610h] [bp+610h]
  int v15; // [sp+614h] [bp+614h]
  unsigned int v16; // [sp+618h] [bp+618h]
  unsigned int v17; // [sp+61Ch] [bp+61Ch]

  v11 = a1;
  v10 = *a1;
  v9 = a1[1];
  memset(v4, 0, sizeof(v4));
  memset(v3, 0, sizeof(v3));
  v2[0] = 0;
  LOBYTE(v2[1]) = 0;
  v8 = 0;
  v17 = 0;
  v16 = 0;
  v15 = 0;
  v7 = 0;
  v6 = 0;
  i = 0;
  j = 0;
  k = 0;
  v5 = 0;
  printf("%s: which_chain = %d, which_i2c = %d\n", "single_BM1385_receive_func", v10, v9);
  clear_uart_rx_fifo(v10);
LABEL_28:
  while ( start_receive )
  {
    usleep(0x1388u);
    for ( i = 0; i <= 0x4C4B3F; ++i )
    {
      memset(v4, 0, sizeof(v4));
      v8 = uart_receive(v10, (int)v4, 0x3E8u);
      if ( v8 && v17 <= 2 )
      {
        for ( j = 0; j < v8; ++j )
          v3[v16++] = v4[j];
        if ( v16 > 4 )
        {
          v7 = v16 / 5;
          for ( j = 0; j < v7; ++j )
          {
            memset(v2, 0, 5u);
            for ( k = 0; k <= 4; ++k )
              *((_BYTE *)v2 + k) = v3[v15++];
            if ( is_nonce_or_reg_value(v2[1]) )
            {
              if ( gStartTest )
              {
                if ( gIsOpenCoreEnd )
                {
                  v5 = single_BM1385_check_nonce(v10, (unsigned __int8 *)v2);
                  if ( v5 == -1 )
                    ++v17;
                }
              }
            }
            else
            {
              v5 = single_BM1385_check_register_value(v10, (int)v2);
              if ( v5 == -1 )
                ++v17;
            }
          }
          v6 = v16 - v15;
          for ( k = 0; k < v6; ++k )
            v3[k] = v3[v15++];
          v16 = v6;
          v15 = 0;
          v7 = 0;
        }
        goto LABEL_28;
      }
    }
  }
  return (unsigned __int8)start_receive;
}
// 317A0: using guessed type char gStartTest;
// 317A2: using guessed type char gIsOpenCoreEnd;
// 317A5: using guessed type char start_receive;

//----- (0001D1BC) --------------------------------------------------------
int singleAsicTest_BM1385()
{
  int v1[5]; // [sp+4h] [bp+4h] BYREF
  int v2; // [sp+18h] [bp+18h]
  int v3; // [sp+1Ch] [bp+1Ch]

  v3 = 0;
  v2 = 0;
  v1[4] = 123456;
  qmemcpy(v1, "                ", 16);
  printf("\nBegin %s test\n", "singleAsicTest_BM1385");
  system("date");
  putchar(10);
  memset(&lcd_output, 32, 0x40u);
  if ( lcd_fd > 0 )
  {
    lseek(lcd_fd, 0, 0);
    write(lcd_fd, &lcd_output, 0x40u);
  }
  init_fpga();
  reset_single_BM1385_global_arg();
  check_chain();
  if ( (unsigned __int8)gChain == 255 )
  {
    write_lcd(1u, (int)"  no hash board ", 0x10u);
    pthread_cancel(dword_5184C);
    pthread_cancel(newthread);
    return puts("\nNo hash board, please plug in it");
  }
  else
  {
    pthread_create(
      &newthread,
      0,
      (void *(*)(void *))single_BM1385_show_status_func,
      (char *)&chain_info + 2 * (unsigned __int8)gChain);
    reset_hash_board();
    start_receive = 1;
    pthread_create(
      &dword_5184C,
      0,
      (void *(*)(void *))single_BM1385_receive_func,
      (char *)&chain_info + 2 * (unsigned __int8)gChain);
    puts("\n--- check asic number");
    check_BM1385_asic_reg(gChain, 0, 0, 1);
    printf("\n--- check chain: asicNum = %d\n", *((unsigned __int8 *)&cgpu + (unsigned __int8)gChain + 131836));
    if ( *((unsigned __int8 *)&cgpu + (unsigned __int8)gChain + 131836) == dword_61BCC )
    {
      single_BM1385_calculate_timeout_and_baud();
      set_BM1385_freq(gChain, 0, dword_61BA4, 1);
      BM1722_set_address_all(gChain);
      check_BM1385_asic_reg(gChain, 0, 0, 1);
      single_BM1385_set_baud(gChain, dword_61C6C);
      single_BM1385_open_core(gChain);
      puts("\nBegin send test pattern");
      system("date");
      putchar(10);
      gStartTest = 1;
      pthread_create(
        &dword_51848,
        0,
        (void *(*)(void *))single_BM1385_send_func,
        (char *)&chain_info + 2 * (unsigned __int8)gChain);
      pthread_join(dword_51848, 0);
      pthread_join(dword_5184C, 0);
      pthread_cancel(newthread);
      LOBYTE(v2) = single_BM1385_get_result(gChain);
      single_asic_print_lcd((unsigned __int8)gChain, v2);
      set_fan_speed(0);
      return usleep(0x7A120u);
    }
    else
    {
      pthread_cancel(dword_5184C);
      pthread_cancel(newthread);
      sprintf((char *)&v1[1] + 3, "%d", *((unsigned __int8 *)&cgpu + (unsigned __int8)gChain + 131836));
      write_lcd(0, (int)"   Only have    ", 0x10u);
      write_lcd_no_memset(1u, (int)v1, 0x10u);
      write_lcd_no_memset(2u, (int)"      ASIC      ", 0x10u);
      printf(
        "\n\n---%s: Only have %d ASIC\n",
        "singleAsicTest_BM1385",
        *((unsigned __int8 *)&cgpu + (unsigned __int8)gChain + 131836));
      return puts("----------------------------\n\n");
    }
  }
}
// 3106C: using guessed type char gChain;
// 317A0: using guessed type char gStartTest;
// 317A5: using guessed type char start_receive;
// 41824: using guessed type int lcd_fd;
// 61BA4: using guessed type int dword_61BA4;
// 61BCC: using guessed type int dword_61BCC;
// 61C6C: using guessed type int dword_61C6C;

//----- (0001D5CC) --------------------------------------------------------
int read_config()
{
  int v1; // [sp+0h] [bp+0h] BYREF
  char v2[1024]; // [sp+4h] [bp+4h] BYREF
  FILE *stream; // [sp+404h] [bp+404h]
  int v4; // [sp+408h] [bp+408h]
  _BYTE *v5; // [sp+40Ch] [bp+40Ch]
  int i; // [sp+410h] [bp+410h]
  char *v7; // [sp+414h] [bp+414h]

  v5 = &Conf;
  memset(v2, 0, sizeof(v2));
  v4 = 0;
  v1 = 0;
  stream = fopen("/mnt/card/Config.ini", "r");
  while ( fgets(v2, 1023, stream) )
  {
    if ( v2[0] != 35 && v2[1] != 35 )
    {
      v7 = strstr(v2, "Name=");
      if ( v7 )
      {
        v7 += 5;
        for ( i = 0; i <= 63; ++i )
        {
          v5[i] = *v7;
          if ( *++v7 == 10 || *v7 == 13 )
            break;
        }
        gName_len = ++i;
        v5[i] = 0;
        gHashBoard_S9 = 0;
        gHashBoard_T9 = 0;
        gHashBoard_T9_plus = 0;
        gHashBoard_R4 = 0;
        gHashBoard_V9 = 0;
        if ( *v5 == 82 && v5[1] == 52 )
        {
          gHashBoard_R4 = 1;
          printf("\n---%s: gHashBoard_R4\n\n", "read_config");
        }
        if ( *v5 == 84 && v5[1] == 57 && v5[2] == 43 )
        {
          gHashBoard_T9_plus = 1;
          printf("\n---%s: gHashBoard_T9_plus\n\n", "read_config");
        }
        if ( *v5 == 84 && v5[1] == 57 && gHashBoard_T9_plus != 1 )
        {
          gHashBoard_T9 = 1;
          printf("\n---%s: gHashBoard_T9\n\n", "read_config");
        }
        if ( *v5 == 83 && v5[1] == 57 )
        {
          gHashBoard_S9 = 1;
          printf("\n---%s: gHashBoard_S9\n\n", "read_config");
        }
        if ( *v5 == 83 && v5[1] == 49 && v5[2] == 49 )
        {
          gHashBoard_S11 = 1;
          printf("\n---%s: gHashBoard_S11\n\n", "read_config");
        }
        if ( *v5 == 86 && v5[1] == 57 )
        {
          gHashBoard_V9 = 1;
          printf("\n---%s: gHashBoard_V9\n\n", "read_config");
        }
      }
      else
      {
        v7 = strstr(v2, "pattern_number=");
        if ( v7 )
        {
          v7 += 15;
          _isoc99_sscanf(v7, "%d", v5 + 64);
          gPattern_number = *((_DWORD *)v5 + 16);
        }
        else
        {
          v7 = strstr(v2, "AsicNum=");
          if ( v7 )
          {
            v7 += 8;
            _isoc99_sscanf(v7, "%d", v5 + 108);
            if ( *((_DWORD *)v5 + 27) == 1 )
              gChain_Asic_Interval = 256;
          }
          else
          {
            v7 = strstr(v2, "AsicType=");
            if ( v7 )
            {
              v7 += 9;
              _isoc99_sscanf(v7, "%d", v5 + 116);
            }
            else
            {
              v7 = strstr(v2, "Freq1=");
              if ( v7 )
              {
                v7 += 6;
                _isoc99_sscanf(v7, "%d", v5 + 72);
              }
              else
              {
                v7 = strstr(v2, "Freq2=");
                if ( v7 )
                {
                  v7 += 6;
                  _isoc99_sscanf(v7, "%d", v5 + 76);
                }
                else
                {
                  v7 = strstr(v2, "Freq3=");
                  if ( v7 )
                  {
                    v7 += 6;
                    _isoc99_sscanf(v7, "%d", v5 + 80);
                  }
                  else
                  {
                    v7 = strstr(v2, "Freq4=");
                    if ( v7 )
                    {
                      v7 += 6;
                      _isoc99_sscanf(v7, "%d", v5 + 84);
                    }
                    else
                    {
                      v7 = strstr(v2, "Freq5=");
                      if ( v7 )
                      {
                        v7 += 6;
                        _isoc99_sscanf(v7, "%d", v5 + 88);
                      }
                      else
                      {
                        v7 = strstr(v2, "Freq6=");
                        if ( v7 )
                        {
                          v7 += 6;
                          _isoc99_sscanf(v7, "%d", v5 + 92);
                        }
                        else
                        {
                          v7 = strstr(v2, "Freq7=");
                          if ( v7 )
                          {
                            v7 += 6;
                            _isoc99_sscanf(v7, "%d", v5 + 96);
                          }
                          else
                          {
                            v7 = strstr(v2, "Freq8=");
                            if ( v7 )
                            {
                              v7 += 6;
                              _isoc99_sscanf(v7, "%d", v5 + 100);
                            }
                            else
                            {
                              v7 = strstr(v2, "Freq9=");
                              if ( v7 )
                              {
                                v7 += 6;
                                _isoc99_sscanf(v7, "%d", v5 + 104);
                              }
                              else
                              {
                                v7 = strstr(v2, "Voltage1=");
                                if ( v7 )
                                {
                                  v7 += 9;
                                  _isoc99_sscanf(v7, "%d", v5 + 156);
                                  if ( *((_DWORD *)v5 + 39) )
                                    ++gHowManyVoltageLevel;
                                }
                                else
                                {
                                  v7 = strstr(v2, "Voltage2=");
                                  if ( v7 )
                                  {
                                    v7 += 9;
                                    _isoc99_sscanf(v7, "%d", v5 + 160);
                                    if ( *((_DWORD *)v5 + 40) )
                                      ++gHowManyVoltageLevel;
                                  }
                                  else
                                  {
                                    v7 = strstr(v2, "Voltage3=");
                                    if ( v7 )
                                    {
                                      v7 += 9;
                                      _isoc99_sscanf(v7, "%d", v5 + 164);
                                      if ( *((_DWORD *)v5 + 41) )
                                        ++gHowManyVoltageLevel;
                                    }
                                    else
                                    {
                                      v7 = strstr(v2, "Voltage4=");
                                      if ( v7 )
                                      {
                                        v7 += 9;
                                        _isoc99_sscanf(v7, "%d", v5 + 168);
                                        if ( *((_DWORD *)v5 + 42) )
                                          ++gHowManyVoltageLevel;
                                      }
                                      else
                                      {
                                        v7 = strstr(v2, "Voltage5=");
                                        if ( v7 )
                                        {
                                          v7 += 9;
                                          _isoc99_sscanf(v7, "%d", v5 + 172);
                                          if ( *((_DWORD *)v5 + 43) )
                                            ++gHowManyVoltageLevel;
                                        }
                                        else
                                        {
                                          v7 = strstr(v2, "Voltage6=");
                                          if ( v7 )
                                          {
                                            v7 += 9;
                                            _isoc99_sscanf(v7, "%d", v5 + 176);
                                            if ( *((_DWORD *)v5 + 44) )
                                              ++gHowManyVoltageLevel;
                                          }
                                          else
                                          {
                                            v7 = strstr(v2, "Voltage7=");
                                            if ( v7 )
                                            {
                                              v7 += 9;
                                              _isoc99_sscanf(v7, "%d", v5 + 180);
                                              if ( *((_DWORD *)v5 + 45) )
                                                ++gHowManyVoltageLevel;
                                            }
                                            else
                                            {
                                              v7 = strstr(v2, "Voltage8=");
                                              if ( v7 )
                                              {
                                                v7 += 9;
                                                _isoc99_sscanf(v7, "%d", v5 + 184);
                                                if ( *((_DWORD *)v5 + 46) )
                                                  ++gHowManyVoltageLevel;
                                              }
                                              else
                                              {
                                                v7 = strstr(v2, "Voltage9=");
                                                if ( v7 )
                                                {
                                                  v7 += 9;
                                                  _isoc99_sscanf(v7, "%d", v5 + 188);
                                                  if ( *((_DWORD *)v5 + 47) )
                                                    ++gHowManyVoltageLevel;
                                                }
                                                else
                                                {
                                                  v7 = strstr(v2, "OpenCoreGap=");
                                                  if ( v7 )
                                                  {
                                                    v7 += 12;
                                                    _isoc99_sscanf(v7, "%d", v5 + 192);
                                                  }
                                                  else
                                                  {
                                                    v7 = strstr(v2, "CheckTemp=");
                                                    if ( v7 )
                                                    {
                                                      v7 += 10;
                                                      _isoc99_sscanf(v7, "%d", v5 + 200);
                                                    }
                                                    else
                                                    {
                                                      v7 = strstr(v2, "Open_Core_Num1=");
                                                      if ( v7 )
                                                      {
                                                        v7 += 15;
                                                        _isoc99_sscanf(v7, "%x", v5 + 204);
                                                      }
                                                      else
                                                      {
                                                        v7 = strstr(v2, "Open_Core_Num2=");
                                                        if ( v7 )
                                                        {
                                                          v7 += 15;
                                                          _isoc99_sscanf(v7, "%x", v5 + 208);
                                                        }
                                                        else
                                                        {
                                                          v7 = strstr(v2, "Open_Core_Num3=");
                                                          if ( v7 )
                                                          {
                                                            v7 += 15;
                                                            _isoc99_sscanf(v7, "%x", v5 + 212);
                                                          }
                                                          else
                                                          {
                                                            v7 = strstr(v2, "Open_Core_Num4=");
                                                            if ( v7 )
                                                            {
                                                              v7 += 15;
                                                              _isoc99_sscanf(v7, "%x", v5 + 216);
                                                            }
                                                            else
                                                            {
                                                              v7 = strstr(v2, "sensor_model=");
                                                              if ( v7 )
                                                              {
                                                                v7 += 13;
                                                                _isoc99_sscanf(v7, "%ud", v5 + 260);
                                                                if ( v5[260] == 6 )
                                                                {
                                                                  gSensor_i2c_addr_high_4_bit = 10092544;
                                                                }
                                                                else if ( v5[260] == 7 )
                                                                {
                                                                  gSensor_i2c_addr_high_4_bit = 10223616;
                                                                }
                                                                else
                                                                {
                                                                  gSensor_i2c_addr_high_4_bit = 9961472;
                                                                }
                                                              }
                                                              else
                                                              {
                                                                v7 = strstr(v2, "remote_local_gap=");
                                                                if ( v7 )
                                                                {
                                                                  v7 += 17;
                                                                  _isoc99_sscanf(v7, "%ud", v5 + 264);
                                                                }
                                                                else
                                                                {
                                                                  v7 = strstr(v2, "TempSensor1=");
                                                                  if ( v7 )
                                                                  {
                                                                    v7 += 12;
                                                                    _isoc99_sscanf(v7, "%ud", v5 + 220);
                                                                    if ( v5[220] )
                                                                      ++gSensor_number;
                                                                  }
                                                                  else
                                                                  {
                                                                    v7 = strstr(v2, "TempSensor2=");
                                                                    if ( v7 )
                                                                    {
                                                                      v7 += 12;
                                                                      _isoc99_sscanf(v7, "%ud", v5 + 221);
                                                                      if ( v5[221] )
                                                                        ++gSensor_number;
                                                                    }
                                                                    else
                                                                    {
                                                                      v7 = strstr(v2, "TempSensor3=");
                                                                      if ( v7 )
                                                                      {
                                                                        v7 += 12;
                                                                        _isoc99_sscanf(v7, "%ud", v5 + 222);
                                                                        if ( v5[222] )
                                                                          ++gSensor_number;
                                                                      }
                                                                      else
                                                                      {
                                                                        v7 = strstr(v2, "StartSensor=");
                                                                        if ( v7 )
                                                                        {
                                                                          v7 += 12;
                                                                          _isoc99_sscanf(v7, "%d", v5 + 223);
                                                                        }
                                                                        else
                                                                        {
                                                                          v7 = strstr(v2, "StartTemp=");
                                                                          if ( v7 )
                                                                          {
                                                                            v7 += 10;
                                                                            _isoc99_sscanf(v7, "%d", v5 + 224);
                                                                            _isoc99_sscanf(v7, "%d", &v1);
                                                                            if ( v1 >= 0 )
                                                                            {
                                                                              v5[224] = v1;
                                                                            }
                                                                            else
                                                                            {
                                                                              v1 = -v1;
                                                                              v5[224] = v1;
                                                                              v5[224] = -v5[224];
                                                                            }
                                                                          }
                                                                          else
                                                                          {
                                                                            v7 = strstr(v2, "TargetTemp=");
                                                                            if ( v7 )
                                                                            {
                                                                              v7 += 11;
                                                                              _isoc99_sscanf(v7, "%d", v5 + 225);
                                                                            }
                                                                            else
                                                                            {
                                                                              v7 = strstr(
                                                                                     v2,
                                                                                     "add_voltage_after_test_ok=");
                                                                              if ( v7 )
                                                                              {
                                                                                v7 += 26;
                                                                                _isoc99_sscanf(v7, "%d", v5 + 236);
                                                                              }
                                                                              else
                                                                              {
                                                                                v7 = strstr(v2, "add_voltage_value=");
                                                                                if ( v7 )
                                                                                {
                                                                                  v7 += 18;
                                                                                  _isoc99_sscanf(v7, "%d", v5 + 240);
                                                                                }
                                                                                else
                                                                                {
                                                                                  v7 = strstr(v2, "AlarmTemp=");
                                                                                  if ( v7 )
                                                                                  {
                                                                                    v7 += 10;
                                                                                    _isoc99_sscanf(v7, "%d", v5 + 226);
                                                                                  }
                                                                                  else
                                                                                  {
                                                                                    v7 = strstr(v2, "HeatingUpTime=");
                                                                                    if ( v7 )
                                                                                    {
                                                                                      v7 += 14;
                                                                                      _isoc99_sscanf(v7, "%d", v5 + 228);
                                                                                    }
                                                                                    else
                                                                                    {
                                                                                      v7 = strstr(v2, "MaxTempGap=");
                                                                                      if ( v7 )
                                                                                      {
                                                                                        v7 += 11;
                                                                                        _isoc99_sscanf(
                                                                                          v7,
                                                                                          "%d",
                                                                                          v5 + 232);
                                                                                      }
                                                                                      else
                                                                                      {
                                                                                        v7 = strstr(
                                                                                               v2,
                                                                                               "Invalid_Asic_Num=");
                                                                                        if ( v7 )
                                                                                        {
                                                                                          v7 += 17;
                                                                                          _isoc99_sscanf(
                                                                                            v7,
                                                                                            "%d",
                                                                                            v5 + 244);
                                                                                        }
                                                                                        else
                                                                                        {
                                                                                          v7 = strstr(
                                                                                                 v2,
                                                                                                 "Invalid_Core_Num=");
                                                                                          if ( v7 )
                                                                                          {
                                                                                            v7 += 17;
                                                                                            _isoc99_sscanf(
                                                                                              v7,
                                                                                              "%d",
                                                                                              v5 + 248);
                                                                                          }
                                                                                          else
                                                                                          {
                                                                                            v7 = strstr(
                                                                                                   v2,
                                                                                                   "Least_nonce_per_core=");
                                                                                            if ( v7 )
                                                                                            {
                                                                                              v7 += 21;
                                                                                              _isoc99_sscanf(
                                                                                                v7,
                                                                                                "%d",
                                                                                                v5 + 252);
                                                                                            }
                                                                                            else
                                                                                            {
                                                                                              v7 = strstr(
                                                                                                     v2,
                                                                                                     "Most_HW_Num=");
                                                                                              if ( v7 )
                                                                                              {
                                                                                                v7 += 12;
                                                                                                _isoc99_sscanf(
                                                                                                  v7,
                                                                                                  "%d",
                                                                                                  v5 + 256);
                                                                                              }
                                                                                              else
                                                                                              {
                                                                                                v7 = strstr(v2, "close_power_delay=");
                                                                                                if ( v7 )
                                                                                                {
                                                                                                  v7 += 18;
                                                                                                  _isoc99_sscanf(
                                                                                                    v7,
                                                                                                    "%d",
                                                                                                    v5 + 272);
                                                                                                }
                                                                                              }
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      if ( *((_DWORD *)v5 + 27) == 1 && *((_DWORD *)v5 + 29) == 1385 )
      {
        strcpy(dest, (const char *)Single_BM1385_WorkDataPathPrefix);
        strcpy(byte_518B4, BTC_WorkDataFilePrefix);
        *((_DWORD *)v5 + 28) = 50;
      }
      if ( gHashBoard_V9 )
      {
        strcpy(dest, V9_WorkDataPathPrefix);
        strcpy(byte_518B4, BTC_WorkDataFilePrefix);
        *((_DWORD *)v5 + 27) = 4;
        *((_DWORD *)v5 + 28) = 50;
        *((_DWORD *)v5 + 29) = 1385;
        gPic_addr_high_4_bit = 10485760;
        gChain_Asic_Interval = 4;
      }
    }
  }
  return 0;
}
// 8FE0: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);
// 308A4: using guessed type void *Single_BM1385_WorkDataPathPrefix;
// 31068: using guessed type char *BTC_WorkDataFilePrefix;
// 311F0: using guessed type char *V9_WorkDataPathPrefix;
// 3176C: using guessed type char gHashBoard_V9;
// 3176D: using guessed type char gHashBoard_S9;
// 3176E: using guessed type char gHashBoard_T9;
// 3176F: using guessed type char gHashBoard_T9_plus;
// 31770: using guessed type char gHashBoard_R4;
// 31771: using guessed type char gHashBoard_S11;
// 3177C: using guessed type int gPic_addr_high_4_bit;
// 31780: using guessed type int gSensor_i2c_addr_high_4_bit;
// 31784: using guessed type char gHowManyVoltageLevel;
// 3178C: using guessed type int gName_len;
// 31790: using guessed type int gSensor_number;
// 31798: using guessed type int gChain_Asic_Interval;
// 3179C: using guessed type int gPattern_number;

//----- (0001E740) --------------------------------------------------------
unsigned __int8 __cdecl CRC5(unsigned __int8 *ptr, unsigned __int8 len)
{
  _BYTE v4[5]; // [sp+Ch] [bp+Ch]
  int v5; // [sp+14h] [bp+14h]
  char v6; // [sp+18h] [bp+18h]
  bool v7; // [sp+1Bh] [bp+1Bh]
  unsigned __int8 v8; // [sp+1Ch] [bp+1Ch]
  char v9; // [sp+1Dh] [bp+1Dh]
  unsigned __int8 v10; // [sp+1Eh] [bp+1Eh]
  unsigned __int8 i; // [sp+1Fh] [bp+1Fh]

  v5 = 16843009;
  v6 = 1;
  v10 = 0x80;
  v9 = 0;
  for ( i = 0; i < (unsigned int)len; ++i )
  {
    v7 = (v10 & *ptr) != 0;
    v4[0] = v7 ^ v6;
    v4[1] = v5;
    v4[2] = v7 ^ v6 ^ BYTE1(v5);
    *(_WORD *)&v4[3] = HIWORD(v5);
    v10 >>= 1;
    if ( ++v9 == 8 )
    {
      v10 = 0x80;
      v9 = 0;
      ++ptr;
    }
    v5 = *(_DWORD *)v4;
    v6 = v4[4];
  }
  v8 = 0;
  if ( v6 )
    v8 = 16;
  if ( HIBYTE(v5) )
    v8 |= 8u;
  if ( BYTE2(v5) )
    v8 |= 4u;
  if ( BYTE1(v5) )
    v8 |= 2u;
  if ( (_BYTE)v5 )
    v8 |= 1u;
  return v8;
}

//----- (0001E860) --------------------------------------------------------
uint16_t __cdecl CRC16(const unsigned __int8 *p_data, uint16_t w_len)
{
  unsigned __int16 v6; // [sp+Ch] [bp+Ch]
  unsigned __int8 v7; // [sp+Eh] [bp+Eh]
  unsigned __int8 v8; // [sp+Fh] [bp+Fh]

  v8 = -1;
  v7 = -1;
  while ( w_len-- != 0 )
  {
    v6 = (unsigned __int8)(v7 ^ *p_data++);
    v7 = v8 ^ chCRCHTalbe[v6];
    v8 = chCRCLTalbe[v6];
  }
  return v7 | (v8 << 8);
}
// 2DD10: using guessed type _BYTE chCRCHTalbe[256];
// 2DE10: using guessed type _BYTE chCRCLTalbe[256];

//----- (0001E8E0) --------------------------------------------------------
int bitmain_axi_init()
{
  dword_51870 = open("/dev/axi_fpga_dev", 2);
  if ( dword_51870 >= 0 )
  {
    axi_fpga_addr = (int)mmap(0, 0x1200u, 3, 1, dword_51870, 0);
    if ( axi_fpga_addr )
    {
      printf("mmap axi_fpga_addr = 0x%x\n", axi_fpga_addr);
      printf("axi_fpga_addr data = 0x%x\n", (unsigned __int16)*(_DWORD *)axi_fpga_addr);
      fd_fpga_mem = open("/dev/fpga_mem", 2);
      if ( fd_fpga_mem >= 0 )
      {
        fpga_mem_addr = (int)mmap(0, 0x1000000u, 3, 1, fd_fpga_mem, 0);
        if ( fpga_mem_addr )
        {
          printf("mmap fpga_mem_addr = 0x%x\n", fpga_mem_addr);
          return 0;
        }
        else
        {
          printf("mmap fpga_mem_addr failed. fpga_mem_addr = 0x%x\n", fpga_mem_addr);
          return -1;
        }
      }
      else
      {
        printf("/dev/fpga_mem open failed. fd_fpga_mem = %d\n", fd_fpga_mem);
        return -1;
      }
    }
    else
    {
      printf("mmap axi_fpga_addr failed. axi_fpga_addr = 0x%x\n", axi_fpga_addr);
      return -1;
    }
  }
  else
  {
    printf("/dev/axi_fpga_dev open failed. fd = %d\n", dword_51870);
    return -1;
  }
}
// 31764: using guessed type int fpga_mem_addr;
// 31768: using guessed type int axi_fpga_addr;
// 51870: using guessed type int dword_51870;
// 62508: using guessed type int fd_fpga_mem;

//----- (0001EA94) --------------------------------------------------------
int bitmain_axi_close()
{
  int v0; // r3

  printf("\n\n--- %s\n", "bitmain_axi_close");
  if ( munmap((void *)axi_fpga_addr, 0x1200u) < 0 )
    puts("munmap failed!");
  if ( munmap((void *)fpga_mem_addr, 0x1000000u) < 0 )
    puts("munmap failed!");
  close(dword_51870);
  close(fd_fpga_mem);
  return v0;
}
// 1EB28: variable 'v0' is possibly undefined
// 31764: using guessed type int fpga_mem_addr;
// 31768: using guessed type int axi_fpga_addr;
// 51870: using guessed type int dword_51870;
// 62508: using guessed type int fd_fpga_mem;

//----- (0001EB34) --------------------------------------------------------
int __fastcall read_axi_fpga(int a1)
{
  return *(_DWORD *)(axi_fpga_addr + 4 * a1);
}
// 31768: using guessed type int axi_fpga_addr;

//----- (0001EB64) --------------------------------------------------------
int __fastcall write_axi_fpga(int result, int a2)
{
  *(_DWORD *)(axi_fpga_addr + 4 * result) = a2;
  return result;
}
// 31768: using guessed type int axi_fpga_addr;

//----- (0001EB8C) --------------------------------------------------------
int init_fpga()
{
  printf("\n--- %s\n", "init_fpga");
  write_axi_fpga(32, -2147450880);
  while ( read_axi_fpga(32) < 0 )
    usleep(0x2710u);
  return usleep(0x186A0u);
}

//----- (0001EBE0) --------------------------------------------------------
int __fastcall get_return_nonce(int *a1)
{
  int result; // r0

  *a1 = read_axi_fpga(4);
  result = read_axi_fpga(5);
  a1[1] = result;
  return result;
}

//----- (0001EC10) --------------------------------------------------------
int __fastcall set_BC_command_buffer(int *a1)
{
  write_axi_fpga(49, *a1);
  write_axi_fpga(50, a1[1]);
  return write_axi_fpga(51, a1[2]);
}

//----- (0001EC48) --------------------------------------------------------
int get_BC_write_command()
{
  return read_axi_fpga(48);
}

//----- (0001EC68) --------------------------------------------------------
int __fastcall set_BC_write_command(int a1)
{
  char v3; // [sp+Fh] [bp+Fh]

  v3 = 0;
  if ( a1 < 0 )
  {
    while ( get_BC_write_command() < 0 )
    {
      usleep(0x3E8u);
      if ( (unsigned __int8)++v3 > 0x64u )
      {
        printf("\n%s: timeout\n\n", "set_BC_write_command");
        return write_axi_fpga(48, a1);
      }
    }
  }
  return write_axi_fpga(48, a1);
}

//----- (0001ECC4) --------------------------------------------------------
int __fastcall set_TW_write_command(int *a1)
{
  int result; // r0
  unsigned int i; // [sp+Ch] [bp+Ch]

  result = write_axi_fpga(16, *a1);
  for ( i = 1; i <= 0xC; ++i )
    result = write_axi_fpga(17, a1[i]);
  return result;
}

//----- (0001ED04) --------------------------------------------------------
int __fastcall set_fpga_baud(unsigned __int8 a1)
{
  int v2; // [sp+Bh] [bp+Bh]

  v2 = (unsigned __int8)asic_baud_to_fpga_baud(a1);
  return write_axi_fpga(15, (unsigned __int8)v2);
}

//----- (0001ED30) --------------------------------------------------------
int cgpu_init()
{
  printf("\n\n--- %s\n", "cgpu_init");
  memset(&cgpu, 0, 0x20310u);
  if ( open_lcd() <= 0 )
  {
    printf("!!! %s: open lcd driver error\n", "cgpu_init");
LABEL_15:
    close_lcd();
    return -1;
  }
  memset(&lcd_output, 32, 0x40u);
  write(lcd_fd, &lcd_output, 0x40u);
  if ( open_key() <= 0 )
  {
    printf("!!! %s: open start key error\n", "cgpu_init");
LABEL_14:
    close_key();
    goto LABEL_15;
  }
  if ( open_red_led() <= 0 )
  {
    printf("!!! %s: open red led error\n", "cgpu_init");
LABEL_13:
    close_red_led();
    goto LABEL_14;
  }
  if ( open_green_led() <= 0 )
  {
    printf("!!! %s: open green led error\n", "cgpu_init");
LABEL_12:
    close_green_led();
    goto LABEL_13;
  }
  if ( bitmain_axi_init() < 0 )
  {
    bitmain_axi_close();
    goto LABEL_12;
  }
  return 0;
}
// 41824: using guessed type int lcd_fd;

//----- (0001EE4C) --------------------------------------------------------
void Hardware_close()
{
  ;
}

//----- (0001EE58) --------------------------------------------------------
void *malloc_register_buf()
{
  reg_value_buf = (int)malloc(0x1008u);
  if ( reg_value_buf )
    return memset((void *)reg_value_buf, 0, 0x1008u);
  else
    return (void *)printf("%s: malloc reg_value_buf failed\n", "malloc_register_buf");
}
// 61B5C: using guessed type int reg_value_buf;

//----- (0001EEB0) --------------------------------------------------------
int configMiner()
{
  read_config();
  if ( get_works() < 0 )
    return -14;
  malloc_register_buf();
  return 0;
}

//----- (0001EEDC) --------------------------------------------------------
ssize_t display_arguments()
{
  char v1[64]; // [sp+0h] [bp+0h] BYREF

  memset(v1, 0, sizeof(v1));
  lseek(lcd_fd, 0, 0);
  memset(v1, 32, sizeof(v1));
  memcpy(v1, &Conf, gName_len);
  sprintf(&v1[16], "IC:%2d P:%2d", dword_61BCC, dword_61BA0);
  sprintf(&v1[32], "FREQ: %d", dword_61BA8);
  sprintf(&v1[48], "Voltage: %d", dword_61BFC);
  return write(lcd_fd, v1, 0x40u);
}
// 3178C: using guessed type int gName_len;
// 41824: using guessed type int lcd_fd;
// 61BA0: using guessed type int dword_61BA0;
// 61BA8: using guessed type int dword_61BA8;
// 61BCC: using guessed type int dword_61BCC;
// 61BFC: using guessed type int dword_61BFC;

//----- (0001EFB0) --------------------------------------------------------
void *clear_register_value_buf()
{
  pthread_mutex_lock(&reg_mutex);
  *(_DWORD *)reg_value_buf = 0;
  *(_DWORD *)(reg_value_buf + 4) = 0;
  *(_DWORD *)(reg_value_buf + 8) = 0;
  *(_DWORD *)(reg_value_buf + 12) = 0;
  pthread_mutex_unlock(&reg_mutex);
  return memset((void *)(reg_value_buf + 16), 0, 0xFF8u);
}
// 417C0: using guessed type pthread_mutex_t reg_mutex;
// 61B5C: using guessed type int reg_value_buf;

//----- (0001F020) --------------------------------------------------------
int __fastcall calculate_core_number(unsigned int a1)
{
  if ( a1 == 1 )
    return 1;
  if ( a1 == 2 )
    return 2;
  if ( a1 > 2 && a1 <= 4 )
    return 4;
  if ( a1 > 4 && a1 <= 8 )
    return 8;
  if ( a1 > 8 && a1 <= 0x10 )
    return 16;
  if ( a1 > 0x10 && a1 <= 0x20 )
    return 32;
  if ( a1 > 0x20 && a1 <= 0x40 )
    return 64;
  if ( a1 > 0x40 && a1 <= 0x80 )
    return 128;
  printf("%s: actual_core_number = %d, but it is error\n", "calculate_core_number", a1);
  return -1;
}

//----- (0001F0D8) --------------------------------------------------------
int __fastcall asic_baud_to_fpga_baud(unsigned __int8 a1)
{
  int v1; // r3

  switch ( a1 )
  {
    case 0u:
      v1 = 1;
      break;
    case 1u:
      v1 = 3;
      break;
    case 2u:
      v1 = 5;
      break;
    case 6u:
      v1 = 13;
      break;
    case 0x1Au:
      v1 = 53;
      break;
    default:
      printf("%s: Don't support ASIC baud = %d, error!!!\n", "asic_baud_to_fpga_baud", a1);
      v1 = 53;
      break;
  }
  return v1;
}

//----- (0001F194) --------------------------------------------------------
int __fastcall calculate_how_many_nonce_per_asic_get(unsigned __int8 a1, unsigned __int8 a2, unsigned int a3)
{
  unsigned int i; // [sp+8h] [bp+8h]
  int v5; // [sp+Ch] [bp+Ch]

  v5 = 0;
  for ( i = 0; i < a3; ++i )
    v5 += gAsic_Core_Nonce_Num[128 * ((a1 << 7) + a2) + i];
  return v5;
}
// 317B4: using guessed type _DWORD gAsic_Core_Nonce_Num[16384];

//----- (0001F1F0) --------------------------------------------------------
int display_level_result_on_lcd()
{
  char v1[8]; // [sp+4h] [bp+4h] BYREF
  unsigned int i; // [sp+Ch] [bp+Ch]

  qmemcpy(v1, "     ", 5);
  sprintf(v1, "%2d", (unsigned __int8)pattern_test_time + 1);
  for ( i = 0; i <= 2; ++i )
    lcd_buffer[i + 10] = v1[i];
  write_lcd(0, (int)lcd_buffer, 0x10u);
  return printf("Level: %d\n\n", (unsigned __int8)pattern_test_time + 1);
}
// 31070: using guessed type _BYTE lcd_buffer[16];
// 31785: using guessed type char pattern_test_time;

//----- (0001F284) --------------------------------------------------------
void *reset_global_arg()
{
  int i; // [sp+14h] [bp+14h]

  printf("\n--- %s\n", "reset_global_arg");
  time_counter = 0;
  gHighest_Temp = 0;
  gChain = -1;
  gWork_Num_For_Hw_Check = 0;
  gIsOpenCoreEnd = 0;
  gStartTest = 0;
  gBegin_Get_Nonce = 0;
  gValid_Nonce_Num[0] = 0;
  gHw_Nonce_Num[0] = 0;
  memset((void *)reg_value_buf, 0, 0x1008u);
  memset(gWorks_For_Hw_Check, 0, sizeof(gWorks_For_Hw_Check));
  memset(&lcd_output, 32, 0x40u);
  write(lcd_fd, &lcd_output, 0x40u);
  pthread_mutex_init(&reg_mutex, 0);
  for ( i = 0; !i; i = 1 )
  {
    pthread_mutex_init(uart_send_mutex, 0);
    pthread_mutex_init(uart_receive_mutex, 0);
    pthread_mutex_init(HW_check_mutex, 0);
  }
  return clear_register_value_buf();
}
// 3106C: using guessed type char gChain;
// 31788: using guessed type int time_counter;
// 31794: using guessed type int gHighest_Temp;
// 317A0: using guessed type char gStartTest;
// 317A1: using guessed type char gBegin_Get_Nonce;
// 317A2: using guessed type char gIsOpenCoreEnd;
// 317A8: using guessed type int gValid_Nonce_Num[];
// 317AC: using guessed type int gHw_Nonce_Num[];
// 417BC: using guessed type char gWork_Num_For_Hw_Check;
// 417C0: using guessed type pthread_mutex_t reg_mutex;
// 417D8: using guessed type pthread_mutex_t HW_check_mutex[1];
// 417F0: using guessed type pthread_mutex_t uart_send_mutex[1];
// 41808: using guessed type pthread_mutex_t uart_receive_mutex[1];
// 41824: using guessed type int lcd_fd;
// 61B5C: using guessed type int reg_value_buf;
// 6250C: using guessed type _DWORD gWorks_For_Hw_Check[140];

//----- (0001F3F0) --------------------------------------------------------
int __fastcall rev(int result, char a2)
{
  char v2; // [sp+Dh] [bp+Dh]
  unsigned __int8 i; // [sp+Eh] [bp+Eh]
  unsigned __int8 v4; // [sp+Fh] [bp+Fh]

  v4 = 0;
  for ( i = a2 - 1; v4 < (unsigned int)i; --i )
  {
    v2 = *(_BYTE *)(result + v4);
    *(_BYTE *)(result + v4) = *(_BYTE *)(result + i);
    *(_BYTE *)(result + i) = v2;
    ++v4;
  }
  return result;
}

//----- (0001F44C) --------------------------------------------------------
int __fastcall check_hw(_DWORD *a1, unsigned int a2, char a3)
{
  int v3; // r1
  int v4; // r2
  int v5; // r3
  int v6; // r1
  int v7; // r2
  int v8; // r3
  _DWORD v14[58]; // [sp+14h] [bp+14h] BYREF
  unsigned int v15; // [sp+FCh] [bp+FCh] BYREF
  unsigned __int8 v16[32]; // [sp+100h] [bp+100h] BYREF
  unsigned __int8 v17[32]; // [sp+120h] [bp+120h] BYREF
  unsigned __int8 *v18; // [sp+140h] [bp+140h]
  unsigned int i; // [sp+144h] [bp+144h]

  i = 0;
  memset(v17, 0, sizeof(v17));
  memset(v16, 0, sizeof(v16));
  v18 = v17;
  v15 = (a2 << 24) | HIBYTE(a2) | ((a2 & 0xFF0000) >> 8) | ((a2 & 0xFF00) << 8);
  v3 = a1[6];
  v4 = a1[7];
  v5 = a1[8];
  v14[2] = a1[5];
  v14[3] = v3;
  v14[4] = v4;
  v14[5] = v5;
  v6 = a1[10];
  v7 = a1[11];
  v8 = a1[12];
  v14[6] = a1[9];
  v14[7] = v6;
  v14[8] = v7;
  v14[9] = v8;
  rev((int)&v14[2], 32);
  v14[0] = 80;
  v14[1] = 0;
  memcpy(v17, a1 + 2, 0xCu);
  rev((int)v17, 12);
  flip_swab(&v14[10], v17, 0xCu);
  memcpy(v17, &v15, 4u);
  rev((int)v17, 4);
  flip_swab(&v14[13], v17, 4u);
  sha2_finish((sha2_context *)v14, v17);
  memset(v14, 0, sizeof(v14));
  sha2(v17, 32, v16);
  flip32(v17, v16);
  if ( !*((_DWORD *)v18 + 7) )
    return 0;
  if ( a3 )
  {
    printf("\n%s: Got a HW!\n", "check_hw");
    printf("hash1=0x");
    for ( i = 0; i <= 0x1F; ++i )
      printf("%02x", v17[i]);
    putchar(10);
    printf("midstate=0x");
    for ( i = 0; i <= 0x1F; ++i )
      printf("%02x", *((unsigned __int8 *)a1 + i + 20));
    printf("\tdata2=0x");
    for ( i = 0; i <= 0xB; ++i )
      printf("%02x", *((unsigned __int8 *)a1 + i + 8));
    printf("\treturn nonce=0x%08x, but it should be nonce=0x%08x\n", a2, a1[1]);
  }
  return 1;
}

//----- (0001F718) --------------------------------------------------------
int __fastcall i2c_write(int a1)
{
  while ( read_axi_fpga(12) >= 0 )
    usleep(0x1388u);
  return write_axi_fpga(12, a1);
}
// 1F732: conditional instruction was optimized away because %var_4.4==0

//----- (0001F768) --------------------------------------------------------
int __fastcall i2c_read(int a1)
{
  int axi_fpga; // [sp+8h] [bp+8h]

  i2c_write(a1 | 0x2000000);
  do
  {
    usleep(0x1388u);
    axi_fpga = read_axi_fpga(12);
  }
  while ( axi_fpga >= 0 );
  return (unsigned __int8)axi_fpga;
}
// 1F7A4: conditional instruction was optimized away because %var_4.4==0

//----- (0001F7CC) --------------------------------------------------------
int __fastcall check_how_many_uart_data_in_fpga(unsigned __int8 a1)
{
  int v1; // r3

  switch ( a1 )
  {
    case 0u:
      v1 = (read_axi_fpga(1088) >> 16) & 0x3FF;
      break;
    case 1u:
      v1 = read_axi_fpga(1088) & 0x3FF;
      break;
    case 2u:
      v1 = (read_axi_fpga(1089) >> 16) & 0x3FF;
      break;
    case 3u:
      v1 = read_axi_fpga(1089) & 0x3FF;
      break;
    case 4u:
      v1 = (read_axi_fpga(1090) >> 16) & 0x3FF;
      break;
    case 5u:
      v1 = read_axi_fpga(1090) & 0x3FF;
      break;
    case 6u:
      v1 = (read_axi_fpga(1091) >> 16) & 0x3FF;
      break;
    case 7u:
      v1 = read_axi_fpga(1091) & 0x3FF;
      break;
    case 8u:
      v1 = (read_axi_fpga(1092) >> 16) & 0x3FF;
      break;
    case 9u:
      v1 = read_axi_fpga(1092) & 0x3FF;
      break;
    default:
      printf("%s: The uart%d is not supported!!!\n", "check_how_many_uart_data_in_fpga", a1);
      v1 = 0;
      break;
  }
  return v1;
}

//----- (0001F8DC) --------------------------------------------------------
int __fastcall read_uart_data_in_fpga(unsigned __int8 a1, int a2, unsigned int a3)
{
  int v3; // r3
  int axi_fpga; // r0
  int v9; // [sp+14h] [bp+14h]
  unsigned int v10; // [sp+18h] [bp+18h]
  int v11; // [sp+18h] [bp+18h]
  int v12; // [sp+20h] [bp+20h]
  unsigned int i; // [sp+24h] [bp+24h]
  int v14; // [sp+28h] [bp+28h]
  int v15; // [sp+2Ch] [bp+2Ch]

  switch ( a1 )
  {
    case 0u:
      v15 = 1100;
      v14 = 1101;
      goto LABEL_13;
    case 1u:
      v15 = 1102;
      v14 = 1103;
      goto LABEL_13;
    case 2u:
      v15 = 1104;
      v14 = 1105;
      goto LABEL_13;
    case 3u:
      v15 = 1106;
      v14 = 1107;
      goto LABEL_13;
    case 4u:
      v15 = 1108;
      v14 = 1109;
      goto LABEL_13;
    case 5u:
      v15 = 1110;
      v14 = 1111;
      goto LABEL_13;
    case 6u:
      v15 = 1112;
      v14 = 1113;
      goto LABEL_13;
    case 7u:
      v15 = 1114;
      v14 = 1115;
      goto LABEL_13;
    case 8u:
      v15 = 1116;
      v14 = 1117;
      goto LABEL_13;
    case 9u:
      v15 = 1118;
      v14 = 1119;
LABEL_13:
      write_axi_fpga(v15, a3 & 0x3FF | 0x80000000);
      v10 = a3 >> 2;
      for ( i = 0; i < v10; ++i )
      {
        axi_fpga = read_axi_fpga(v14);
        *(_BYTE *)(a2 + 4 * i) = HIBYTE(axi_fpga);
        *(_BYTE *)(a2 + 4 * i + 1) = BYTE2(axi_fpga);
        *(_BYTE *)(a2 + 4 * i + 2) = BYTE1(axi_fpga);
        *(_BYTE *)(a2 + 4 * i + 3) = axi_fpga;
      }
      v12 = 4 * v10;
      v11 = a3 & 3;
      if ( (a3 & 3) != 0 )
      {
        v9 = read_axi_fpga(v14);
        switch ( v11 )
        {
          case 2:
            *(_BYTE *)(a2 + 4 * i) = HIBYTE(v9);
            *(_BYTE *)(a2 + 4 * i + 1) = BYTE2(v9);
            v12 += 2;
            break;
          case 3:
            *(_BYTE *)(a2 + 4 * i) = HIBYTE(v9);
            *(_BYTE *)(a2 + 4 * i + 1) = BYTE2(v9);
            *(_BYTE *)(a2 + 4 * i + 2) = BYTE1(v9);
            v12 += 3;
            break;
          case 1:
            *(_BYTE *)(a2 + 4 * i) = HIBYTE(v9);
            ++v12;
            break;
          default:
            printf("%s: the uart%d left data is 4*N length, error!!!\n", "read_uart_data_in_fpga", a1);
            break;
        }
      }
      v3 = v12;
      break;
    default:
      printf("%s: The uart%d is not supported!!!\n", "read_uart_data_in_fpga", jpt_1F90E);
      v3 = 0;
      break;
  }
  return v3;
}
// 1F914: using guessed type void *jpt_1F90E[10];

//----- (0001FB2C) --------------------------------------------------------
unsigned int __fastcall uart_send(unsigned __int8 a1, unsigned __int8 *a2, size_t a3)
{
  int axi_fpga; // r0
  _BYTE v9[512]; // [sp+14h] [bp+14h] BYREF
  unsigned int v10; // [sp+214h] [bp+214h]
  unsigned int v11; // [sp+218h] [bp+218h]
  int v12; // [sp+21Ch] [bp+21Ch]
  int v13; // [sp+220h] [bp+220h]
  int v14; // [sp+224h] [bp+224h]
  unsigned int i; // [sp+228h] [bp+228h]
  int v16; // [sp+22Ch] [bp+22Ch]
  int v17; // [sp+230h] [bp+230h]
  int v18; // [sp+234h] [bp+234h]
  int v19; // [sp+238h] [bp+238h]
  int v20; // [sp+23Ch] [bp+23Ch]
  int j; // [sp+240h] [bp+240h]
  int v22; // [sp+244h] [bp+244h]

  v14 = 0;
  v22 = 0;
  v13 = 0;
  j = 0;
  v12 = 0;
  memset(v9, 0, sizeof(v9));
  v11 = a3;
  v20 = 0;
  v19 = 0;
  v18 = 0;
  v17 = 0;
  v10 = 0;
  v16 = 0;
  pthread_mutex_lock(&uart_send_mutex[a1]);
  for ( i = 0; i < a3; ++i )
    printf("%02x", a2[i]);
  putchar(10);
  switch ( a1 )
  {
    case 0u:
      v16 = 24;
      v19 = 1024;
      v18 = 1028;
      v17 = 1029;
      goto LABEL_16;
    case 1u:
      v16 = 16;
      v19 = 1024;
      v18 = 1030;
      v17 = 1031;
      goto LABEL_16;
    case 2u:
      v16 = 8;
      v19 = 1024;
      v18 = 1032;
      v17 = 1033;
      goto LABEL_16;
    case 3u:
      v16 = 0;
      v19 = 1024;
      v18 = 1034;
      v17 = 1035;
      goto LABEL_16;
    case 4u:
      v16 = 24;
      v19 = 1025;
      v18 = 1036;
      v17 = 1037;
      goto LABEL_16;
    case 5u:
      v16 = 16;
      v19 = 1025;
      v18 = 1038;
      v17 = 1039;
      goto LABEL_16;
    case 6u:
      v16 = 8;
      v19 = 1025;
      v18 = 1040;
      v17 = 1041;
      goto LABEL_16;
    case 7u:
      v16 = 0;
      v19 = 1025;
      v18 = 1042;
      v17 = 1043;
      goto LABEL_16;
    case 8u:
      v16 = 24;
      v19 = 1026;
      v18 = 1044;
      v17 = 1045;
      goto LABEL_16;
    case 9u:
      v16 = 16;
      v19 = 1026;
      v18 = 1046;
      v17 = 1047;
LABEL_16:
      v22 = 0;
      break;
    default:
      printf("%s: The uart%d is not supported!!!\n", "uart_send", jpt_1FC10);
      return 0;
  }
  while ( 1 )
  {
    axi_fpga = read_axi_fpga(v19);
    v10 = (unsigned __int8)(axi_fpga >> v16);
    if ( v10 >= a3 )
      break;
    usleep(0xBB8u);
    if ( ++v22 > 20 )
    {
      pthread_mutex_unlock(&uart_send_mutex[a1]);
      printf("%s: uart%d always dose not has enough send fifo space, break\n", "uart_send", a1);
      return 0;
    }
  }
  v22 = 0;
  while ( read_axi_fpga(v18) < 0 )
  {
    if ( v22 > 20 )
    {
      pthread_mutex_unlock(&uart_send_mutex[a1]);
      printf("%s: uart%d always busy, break\n", "uart_send", a1);
      return 0;
    }
    ++v22;
    usleep(0xBB8u);
  }
  memcpy(v9, a2, a3);
  v13 = v11 >> 2;
  for ( j = 0; j < v13; ++j )
  {
    v20 = (unsigned __int8)v9[4 * j + 3] | ((unsigned __int8)v9[4 * j] << 24) | ((unsigned __int8)v9[4 * j + 1] << 16) | ((unsigned __int8)v9[4 * j + 2] << 8);
    write_axi_fpga(v17, v20);
  }
  v13 = v11 & 3;
  if ( (v11 & 3) != 0 )
  {
    switch ( v13 )
    {
      case 2:
        v20 = ((unsigned __int8)v9[4 * j + 1] << 16) | ((unsigned __int8)v9[4 * j] << 24);
        break;
      case 3:
        v20 = ((unsigned __int8)v9[4 * j + 2] << 8) | ((unsigned __int8)v9[4 * j] << 24) | ((unsigned __int8)v9[4 * j + 1] << 16);
        break;
      case 1:
        v20 = (unsigned __int8)v9[4 * j] << 24;
        break;
      default:
        printf("%s: the uart%d send left data is 4*N length, error!!!\n", "uart_send", a1);
        break;
    }
    write_axi_fpga(v17, v20);
  }
  write_axi_fpga(v18, v11 | 0x80000000);
  pthread_mutex_unlock(&uart_send_mutex[a1]);
  return v11;
}
// 1FC14: using guessed type void *jpt_1FC10[10];
// 417F0: using guessed type pthread_mutex_t uart_send_mutex[1];

//----- (00020018) --------------------------------------------------------
int __fastcall uart_receive(unsigned __int8 a1, int a2, unsigned int a3)
{
  unsigned int v8; // [sp+14h] [bp+14h]
  int uart_data_in_fpga; // [sp+18h] [bp+18h]
  unsigned int i; // [sp+1Ch] [bp+1Ch]

  pthread_mutex_lock(&uart_receive_mutex[a1]);
  v8 = check_how_many_uart_data_in_fpga(a1);
  if ( v8 < a3 )
  {
    pthread_mutex_unlock(&uart_receive_mutex[a1]);
    return 0;
  }
  else
  {
    uart_data_in_fpga = read_uart_data_in_fpga(a1, a2, v8);
    for ( i = 0; i < v8; ++i )
      printf("%02x", *(unsigned __int8 *)(a2 + i));
    printf(" --- len = %d\n", uart_data_in_fpga);
    pthread_mutex_unlock(&uart_receive_mutex[a1]);
    return uart_data_in_fpga;
  }
}
// 41808: using guessed type pthread_mutex_t uart_receive_mutex[1];

//----- (00020104) --------------------------------------------------------
int __fastcall clear_uart_send_fifo(unsigned __int8 a1)
{
  int v4; // [sp+8h] [bp+8h]
  unsigned int v5; // [sp+14h] [bp+14h]
  char v6; // [sp+18h] [bp+18h]
  int v7; // [sp+1Ch] [bp+1Ch]

  printf("--- %s\n", "clear_uart_send_fifo");
  pthread_mutex_lock(&uart_send_mutex[a1]);
  switch ( a1 )
  {
    case 0u:
      v6 = 24;
      v7 = 1024;
      goto LABEL_13;
    case 1u:
      v6 = 16;
      v7 = 1024;
      goto LABEL_13;
    case 2u:
      v6 = 8;
      v7 = 1024;
      goto LABEL_13;
    case 3u:
      v6 = 0;
      v7 = 1024;
      goto LABEL_13;
    case 4u:
      v6 = 24;
      v7 = 1025;
      goto LABEL_13;
    case 5u:
      v6 = 16;
      v7 = 1025;
      goto LABEL_13;
    case 6u:
      v6 = 8;
      v7 = 1025;
      goto LABEL_13;
    case 7u:
      v6 = 0;
      v7 = 1025;
      goto LABEL_13;
    case 8u:
      v6 = 24;
      v7 = 1026;
      goto LABEL_13;
    case 9u:
      v6 = 16;
      v7 = 1026;
LABEL_13:
      v5 = 0;
      break;
    default:
      printf("%s: The uart%d is not supported!!!\n", "clear_uart_send_fifo", a1);
      pthread_mutex_unlock(&uart_send_mutex[a1]);
      return 1;
  }
  do
  {
    v4 = (unsigned __int8)(read_axi_fpga(v7) >> v6);
    if ( v4 == 255 )
    {
      pthread_mutex_unlock(&uart_send_mutex[a1]);
      return 0;
    }
    printf("%s: waiting fpga uart%d clear send fifo space ...\n", "clear_uart_send_fifo", a1);
    usleep(0xBB8u);
    ++v5;
  }
  while ( v5 <= 0x14 );
  printf("%s: uart%d always dose not has enough send fifo space, break\n", "clear_uart_send_fifo", a1);
  pthread_mutex_unlock(&uart_send_mutex[a1]);
  return v4;
}
// 417F0: using guessed type pthread_mutex_t uart_send_mutex[1];

//----- (0002035C) --------------------------------------------------------
int __fastcall clear_uart_rx_fifo(unsigned __int8 a1)
{
  void *ptr; // [sp+14h] [bp+Ch]
  int size; // [sp+18h] [bp+10h]
  int uart_data_in_fpga; // [sp+1Ch] [bp+14h]

  printf("--- %s\n", "clear_uart_rx_fifo");
  pthread_mutex_lock(&uart_receive_mutex[a1]);
  size = check_how_many_uart_data_in_fpga(a1);
  if ( size )
  {
    ptr = malloc(size);
    if ( ptr )
    {
      uart_data_in_fpga = read_uart_data_in_fpga(a1, (int)ptr, size);
      if ( uart_data_in_fpga != size )
        printf(
          "%s: uart%d clear rx fifo error. nbytes = %d, len = %d\n",
          "clear_uart_rx_fifo",
          a1,
          size,
          uart_data_in_fpga);
      free(ptr);
      usleep(0x2710u);
      pthread_mutex_unlock(&uart_receive_mutex[a1]);
      return 1;
    }
    else
    {
      printf("%s: uart%d malloc buffer error\n", "clear_uart_rx_fifo", a1);
      usleep(0x7A120u);
      pthread_mutex_unlock(&uart_receive_mutex[a1]);
      return 1;
    }
  }
  else
  {
    pthread_mutex_unlock(&uart_receive_mutex[a1]);
    return 0;
  }
}
// 41808: using guessed type pthread_mutex_t uart_receive_mutex[1];

//----- (000204C0) --------------------------------------------------------
int open_key()
{
  key_fd = open("/sys/class/gpio/gpio943/value", 2048);
  if ( key_fd < 0 )
    puts("open key failed!!!");
  return key_fd;
}
// 41820: using guessed type int key_fd;

//----- (00020508) --------------------------------------------------------
int close_key()
{
  close(key_fd);
  return puts("key closed!!!");
}
// 41820: using guessed type int key_fd;

//----- (0002052C) --------------------------------------------------------
int __fastcall read_key(char a1)
{
  char v3[5]; // [sp+7h] [bp+7h] BYREF
  ssize_t v4; // [sp+Ch] [bp+Ch]

  v3[0] = a1;
  v4 = 0;
  lseek(key_fd, 0, 0);
  v4 = read(key_fd, v3, 1u);
  if ( v4 == 1 )
    return 1;
  printf("%s: can't read out key value\n", "read_key");
  return -1;
}
// 41820: using guessed type int key_fd;
// 2052C: using guessed type char var_9[5];

//----- (00020594) --------------------------------------------------------
int open_lcd()
{
  lcd_fd = open("/dev/bitmain-lcd", 2178);
  if ( lcd_fd <= 0 )
    puts("open lcd failed!!!");
  return lcd_fd;
}
// 41824: using guessed type int lcd_fd;

//----- (000205DC) --------------------------------------------------------
int close_lcd()
{
  int v1; // [sp+4h] [bp+4h]

  v1 = close(lcd_fd);
  if ( v1 )
    puts("lcd close failed!!!");
  else
    puts("lcd closed!!!");
  return v1;
}
// 41824: using guessed type int lcd_fd;

//----- (00020628) --------------------------------------------------------
unsigned int __fastcall write_lcd(unsigned int result, int a2, unsigned int a3)
{
  _DWORD *v3; // r3
  int v4; // r0
  int v5; // r1
  int v6; // r2
  size_t n; // [sp+4h] [bp+4h]
  unsigned int v9; // [sp+Ch] [bp+Ch]
  int v10; // [sp+14h] [bp+14h]

  v9 = result;
  n = a3;
  v10 = 0;
  if ( a2 && lcd_fd > 0 )
  {
    if ( result <= 3 && a3 <= 0x40 )
    {
      lseek(lcd_fd, 0, 0);
      memset(&lcd_output, 32, 0x40u);
      while ( n )
      {
        if ( n <= 0x10 )
        {
          memcpy((char *)&lcd_output + 16 * v9, (const void *)(a2 + v10), n);
          return write(lcd_fd, &lcd_output, 0x40u);
        }
        v3 = (_DWORD *)((char *)&lcd_output + 16 * v9);
        v4 = *(_DWORD *)(a2 + v10 + 4);
        v5 = *(_DWORD *)(a2 + v10 + 8);
        v6 = *(_DWORD *)(a2 + v10 + 12);
        *v3 = *(_DWORD *)(a2 + v10);
        v3[1] = v4;
        v3[2] = v5;
        v3[3] = v6;
        ++v9;
        n -= 16;
        v10 += 16;
      }
      return write(lcd_fd, &lcd_output, 0x40u);
    }
    else
    {
      return printf("%s: write_lcd's arg is overflow\n", "write_lcd");
    }
  }
  return result;
}
// 41824: using guessed type int lcd_fd;

//----- (00020724) --------------------------------------------------------
unsigned int __fastcall write_lcd_no_memset(unsigned int result, int a2, unsigned int a3)
{
  _DWORD *v3; // r3
  int v4; // r0
  int v5; // r1
  int v6; // r2
  size_t n; // [sp+4h] [bp+4h]
  unsigned int v9; // [sp+Ch] [bp+Ch]
  int v10; // [sp+14h] [bp+14h]

  v9 = result;
  n = a3;
  v10 = 0;
  if ( a2 && lcd_fd > 0 )
  {
    if ( result <= 3 && a3 <= 0x40 )
    {
      while ( n )
      {
        if ( n <= 0x10 )
        {
          memcpy((char *)&lcd_output + 16 * v9, (const void *)(a2 + v10), n);
          return write(lcd_fd, &lcd_output, 0x40u);
        }
        v3 = (_DWORD *)((char *)&lcd_output + 16 * v9);
        v4 = *(_DWORD *)(a2 + v10 + 4);
        v5 = *(_DWORD *)(a2 + v10 + 8);
        v6 = *(_DWORD *)(a2 + v10 + 12);
        *v3 = *(_DWORD *)(a2 + v10);
        v3[1] = v4;
        v3[2] = v5;
        v3[3] = v6;
        ++v9;
        n -= 16;
        v10 += 16;
      }
      return write(lcd_fd, &lcd_output, 0x40u);
    }
    else
    {
      return printf("%s: write_lcd's arg is overflow\n", "write_lcd_no_memset");
    }
  }
  return result;
}
// 41824: using guessed type int lcd_fd;

//----- (000207FC) --------------------------------------------------------
int open_red_led()
{
  red_led_fd = open("/sys/class/gpio/gpio941/value", 2049);
  if ( red_led_fd < 0 )
    puts("open red led failed!!!");
  return red_led_fd;
}
// 41828: using guessed type int red_led_fd;

//----- (00020844) --------------------------------------------------------
int close_red_led()
{
  close(red_led_fd);
  return puts("red led closed!!!");
}
// 41828: using guessed type int red_led_fd;

//----- (00020868) --------------------------------------------------------
ssize_t red_led_on()
{
  return write(red_led_fd, "1", 1u);
}
// 41828: using guessed type int red_led_fd;

//----- (00020888) --------------------------------------------------------
ssize_t red_led_off()
{
  return write(red_led_fd, "0", 1u);
}
// 41828: using guessed type int red_led_fd;

//----- (000208A8) --------------------------------------------------------
int open_green_led()
{
  green_led_fd = open("/sys/class/gpio/gpio942/value", 2049);
  if ( green_led_fd < 0 )
    puts("open green led failed!!!");
  return green_led_fd;
}
// 4182C: using guessed type int green_led_fd;

//----- (000208F0) --------------------------------------------------------
int close_green_led()
{
  close(green_led_fd);
  return puts("green led closed!!!");
}
// 4182C: using guessed type int green_led_fd;

//----- (00020914) --------------------------------------------------------
ssize_t green_led_on()
{
  return write(green_led_fd, "1", 1u);
}
// 4182C: using guessed type int green_led_fd;

//----- (00020934) --------------------------------------------------------
ssize_t green_led_off()
{
  return write(green_led_fd, "0", 1u);
}
// 4182C: using guessed type int green_led_fd;

//----- (00020954) --------------------------------------------------------
int __fastcall c2hex(unsigned __int8 a1)
{
  unsigned __int8 v2; // [sp+Fh] [bp+Fh]

  v2 = -1;
  if ( a1 <= 0x2Fu || a1 > 0x39u )
  {
    switch ( a1 )
    {
      case 'a':
      case 'A':
        return 10;
      case 'b':
      case 'B':
        return 11;
      case 'c':
      case 'C':
        return 12;
      case 'd':
      case 'D':
        return 13;
      case 'e':
      case 'E':
        return 14;
      case 'f':
      case 'F':
        return 15;
      default:
        printf("input value error: %c\n", a1);
        break;
    }
  }
  else
  {
    return a1 & 0xF;
  }
  return v2;
}

//----- (00020A00) --------------------------------------------------------
unsigned __int8 __cdecl twoc2hex(unsigned __int8 high, unsigned __int8 low)
{
  char v4; // [sp+7h] [bp+7h]

  v4 = c2hex(high);
  return c2hex(low) ^ (16 * v4);
}

//----- (00020A44) --------------------------------------------------------
int __fastcall s2hex(_BYTE *a1, _BYTE *a2, int a3)
{
  int v7; // [sp+14h] [bp+14h]
  int v8; // [sp+18h] [bp+18h]
  int i; // [sp+1Ch] [bp+1Ch]

  if ( a2 && a3 > 0 && a1 )
  {
    v8 = a3 / 2;
    v7 = a3 % 2;
    for ( i = 0; i < v8; ++i )
      a1[i] = twoc2hex(a2[2 * i], a2[2 * i + 1]);
    if ( v7 )
      a1[i] = twoc2hex(a2[2 * i], 0);
    return v8 + v7;
  }
  else
  {
    printf("s2hex para error dst(%p), src(%p), inlen(%d)\n", a1, a2, a3);
    return -1;
  }
}

//----- (00020B1C) --------------------------------------------------------
int print_works()
{
  int v0; // r3
  int v2; // [sp+0h] [bp+0h]
  int v3; // [sp+0h] [bp+0h]
  int v4; // [sp+0h] [bp+0h]
  int v5; // [sp+0h] [bp+0h]
  int v6; // [sp+0h] [bp+0h]
  int v7; // [sp+4h] [bp+4h]
  int v8; // [sp+4h] [bp+4h]
  int v9; // [sp+4h] [bp+4h]
  int v10; // [sp+4h] [bp+4h]
  int v11; // [sp+4h] [bp+4h]
  unsigned int j; // [sp+8h] [bp+8h]
  unsigned int ii; // [sp+8h] [bp+8h]
  unsigned int nn; // [sp+8h] [bp+8h]
  unsigned int i4; // [sp+8h] [bp+8h]
  unsigned int i9; // [sp+8h] [bp+8h]
  int v17; // [sp+Ch] [bp+Ch]
  unsigned int i8; // [sp+Ch] [bp+Ch]
  unsigned int i7; // [sp+10h] [bp+10h]
  unsigned int v20; // [sp+14h] [bp+14h]
  unsigned int v21; // [sp+18h] [bp+18h]
  unsigned int v22; // [sp+1Ch] [bp+1Ch]
  unsigned int v23; // [sp+20h] [bp+20h]
  int v24; // [sp+24h] [bp+24h]
  int i; // [sp+28h] [bp+28h]
  int n; // [sp+28h] [bp+28h]
  int mm; // [sp+28h] [bp+28h]
  int i3; // [sp+28h] [bp+28h]
  int k; // [sp+2Ch] [bp+2Ch]
  int m; // [sp+2Ch] [bp+2Ch]
  int jj; // [sp+2Ch] [bp+2Ch]
  int kk; // [sp+2Ch] [bp+2Ch]
  int i1; // [sp+2Ch] [bp+2Ch]
  int i2; // [sp+2Ch] [bp+2Ch]
  int i5; // [sp+2Ch] [bp+2Ch]
  int i6; // [sp+2Ch] [bp+2Ch]
  int i10; // [sp+2Ch] [bp+2Ch]
  int i11; // [sp+2Ch] [bp+2Ch]

  v24 = 0;
  v23 = dword_61C2C;
  v22 = dword_61C30;
  v21 = dword_61C34;
  v20 = dword_61C38;
  v17 = 0;
  printf("\n--- %s begin\n\n", "print_works");
  if ( dword_61BCC == 1 )
  {
    for ( i = 0; i <= 31; ++i )
    {
      if ( (v23 & 1) != 0 )
      {
        v7 = *((_DWORD *)&cgpu + v24 + 16427);
        for ( j = 0; dword_61BA0 > j; ++j )
        {
          v2 = v7 + 56 * j;
          printf("core[%02d][%02d].midstate=0x", v17, j);
          for ( k = 0; k <= 31; ++k )
            printf("%02x", *(unsigned __int8 *)(v2 + k + 20));
          printf(" data2=");
          for ( m = 0; m <= 11; ++m )
            printf("%02x", *(unsigned __int8 *)(v2 + m + 8));
          printf(" nonce=0x%08x\n", *(_DWORD *)(v2 + 4));
        }
        putchar(10);
        ++v24;
      }
      v23 >>= 1;
      ++v17;
    }
    for ( n = 0; n <= 31; ++n )
    {
      if ( (v22 & 1) != 0 )
      {
        v8 = *((_DWORD *)&cgpu + v24 + 16427);
        for ( ii = 0; dword_61BA0 > ii; ++ii )
        {
          v3 = v8 + 56 * ii;
          printf("core[%02d][%02d].midstate=0x", v17, ii);
          for ( jj = 0; jj <= 31; ++jj )
            printf("%02x", *(unsigned __int8 *)(v3 + jj + 20));
          printf(" data2=");
          for ( kk = 0; kk <= 11; ++kk )
            printf("%02x", *(unsigned __int8 *)(v3 + kk + 8));
          printf(" nonce=0x%08x\n", *(_DWORD *)(v3 + 4));
        }
        putchar(10);
        ++v24;
      }
      v22 >>= 1;
      ++v17;
    }
    for ( mm = 0; mm <= 31; ++mm )
    {
      if ( (v21 & 1) != 0 )
      {
        v9 = *((_DWORD *)&cgpu + v24 + 16427);
        for ( nn = 0; dword_61BA0 > nn; ++nn )
        {
          v4 = v9 + 56 * nn;
          printf("core[%02d][%02d].midstate=0x", v17, nn);
          for ( i1 = 0; i1 <= 31; ++i1 )
            printf("%02x", *(unsigned __int8 *)(v4 + i1 + 20));
          printf(" data2=");
          for ( i2 = 0; i2 <= 11; ++i2 )
            printf("%02x", *(unsigned __int8 *)(v4 + i2 + 8));
          printf(" nonce=0x%08x\n", *(_DWORD *)(v4 + 4));
        }
        putchar(10);
        ++v24;
      }
      v21 >>= 1;
      ++v17;
    }
    for ( i3 = 0; i3 <= 31; ++i3 )
    {
      if ( (v20 & 1) != 0 )
      {
        v10 = *((_DWORD *)&cgpu + v24 + 16427);
        for ( i4 = 0; dword_61BA0 > i4; ++i4 )
        {
          v5 = v10 + 56 * i4;
          printf("core[%02d][%02d].midstate=0x", v17, i4);
          for ( i5 = 0; i5 <= 31; ++i5 )
            printf("%02x", *(unsigned __int8 *)(v5 + i5 + 20));
          printf(" data2=");
          for ( i6 = 0; i6 <= 11; ++i6 )
            printf("%02x", *(unsigned __int8 *)(v5 + i6 + 8));
          printf(" nonce=0x%08x\n", *(_DWORD *)(v5 + 4));
        }
        putchar(10);
        ++v24;
      }
      v20 >>= 1;
      ++v17;
    }
  }
  else
  {
    for ( i7 = 0; dword_61BCC > i7; ++i7 )
    {
      v11 = *((_DWORD *)&cgpu + i7 + 16427);
      for ( i8 = 0; dword_61BD0 > i8; ++i8 )
      {
        for ( i9 = 0; dword_61BA0 > i9; ++i9 )
        {
          v6 = v11 + 56 * (i8 * dword_61BA0 + i9);
          printf("asic[%02d][%02d][%02d].midstate=0x", i7, i8, i9);
          for ( i10 = 0; i10 <= 31; ++i10 )
            printf("%02x", *(unsigned __int8 *)(v6 + i10 + 20));
          printf(" data2=");
          for ( i11 = 0; i11 <= 11; ++i11 )
            printf("%02x", *(unsigned __int8 *)(v6 + i11 + 8));
          printf(" nonce=0x%08x\n", *(_DWORD *)(v6 + 4));
        }
      }
      putchar(10);
    }
  }
  printf("\n--- %s end\n\n", "print_works");
  return v0;
}
// 210BA: variable 'v0' is possibly undefined
// 61BA0: using guessed type int dword_61BA0;
// 61BCC: using guessed type int dword_61BCC;
// 61BD0: using guessed type int dword_61BD0;
// 61C2C: using guessed type int dword_61C2C;
// 61C30: using guessed type int dword_61C30;
// 61C34: using guessed type int dword_61C34;
// 61C38: using guessed type int dword_61C38;

//----- (000210C4) --------------------------------------------------------
int __fastcall get_work(int a1, int a2)
{
  uint32_t v3; // r0
  char v7[1024]; // [sp+Ch] [bp+Ch] BYREF
  void *ptr; // [sp+40Ch] [bp+40Ch]
  int v9; // [sp+410h] [bp+410h]
  int i; // [sp+414h] [bp+414h]
  int v11; // [sp+418h] [bp+418h]
  char *v12; // [sp+41Ch] [bp+41Ch]

  memset(v7, 0, sizeof(v7));
  v11 = 0;
  v9 = 0;
  i = 0;
  *((_DWORD *)&cgpu + a1 + 16427) = malloc(56 * a2);
  if ( *((_DWORD *)&cgpu + a1 + 16427) )
  {
    while ( 1 )
    {
      if ( !fgets(v7, 1023, *((FILE **)&cgpu + a1)) || v11 >= a2 )
        return v11;
      ptr = (void *)(*((_DWORD *)&cgpu + a1 + 16427) + 56 * v11);
      v12 = strstr(v7, "nonce");
      if ( !v12 )
        break;
      for ( v12 += 5; *v12 == 32; ++v12 )
        ;
      s2hex((_BYTE *)ptr + 4, v12, 8);
      v3 = htonl(*((_DWORD *)ptr + 1));
      *((_DWORD *)ptr + 1) = v3;
      v12 = strstr(v7, "midstate");
      if ( !v12 )
        break;
      for ( v12 += 8; *v12 == 32; ++v12 )
        ;
      s2hex((_BYTE *)ptr + 20, v12, 64);
      v12 = strstr(v7, "data");
      if ( !v12 )
        break;
      for ( v12 += 4; *v12 == 32; ++v12 )
        ;
      s2hex((_BYTE *)ptr + 8, v12, 24);
      for ( i = 0; i <= 0; ++i )
        *((_DWORD *)ptr + i + 13) = 0;
      *(_DWORD *)ptr = v11++;
    }
    free(ptr);
    puts("get work err");
    return v11;
  }
  else
  {
    puts("malloc struct work err");
    return 0;
  }
}

//----- (00021338) --------------------------------------------------------
unsigned int __fastcall get_work_hash_board(int a1, int a2, FILE *a3, unsigned int a4)
{
  uint32_t v4; // r0
  char v11[1024]; // [sp+14h] [bp+14h] BYREF
  void *ptr; // [sp+414h] [bp+414h]
  int v13; // [sp+418h] [bp+418h]
  int i; // [sp+41Ch] [bp+41Ch]
  unsigned int v15; // [sp+420h] [bp+420h]
  char *v16; // [sp+424h] [bp+424h]

  memset(v11, 0, sizeof(v11));
  v15 = 0;
  v13 = 0;
  i = 0;
  while ( 1 )
  {
    if ( !fgets(v11, 1023, a3) || a4 <= v15 )
      return v15;
    ptr = (void *)(*((_DWORD *)&cgpu + a1 + 16427) + 56 * (a4 * a2 + v15));
    v16 = strstr(v11, "nonce");
    if ( !v16 )
      break;
    for ( v16 += 5; *v16 == 32; ++v16 )
      ;
    s2hex((_BYTE *)ptr + 4, v16, 8);
    v4 = htonl(*((_DWORD *)ptr + 1));
    *((_DWORD *)ptr + 1) = v4;
    v16 = strstr(v11, "midstate");
    if ( !v16 )
      break;
    for ( v16 += 8; *v16 == 32; ++v16 )
      ;
    s2hex((_BYTE *)ptr + 20, v16, 64);
    v16 = strstr(v11, "data");
    if ( !v16 )
      break;
    for ( v16 += 4; *v16 == 32; ++v16 )
      ;
    s2hex((_BYTE *)ptr + 8, v16, 24);
    for ( i = 0; i <= 0; ++i )
      *((_DWORD *)ptr + i + 13) = 0;
    *(_DWORD *)ptr = v15++;
  }
  free(ptr);
  puts("get work err");
  return v15;
}

//----- (00021564) --------------------------------------------------------
int get_works()
{
  FILE *v0; // r0
  int work; // r0
  unsigned int v3; // r4
  unsigned int v4; // r4
  char v6[64]; // [sp+Ch] [bp+4h] BYREF
  int v7; // [sp+4Ch] [bp+44h]
  int v8; // [sp+50h] [bp+48h]
  unsigned int v9; // [sp+54h] [bp+4Ch]
  unsigned int v10; // [sp+58h] [bp+50h]
  unsigned int v11; // [sp+5Ch] [bp+54h]
  unsigned int v12; // [sp+60h] [bp+58h]
  unsigned int k; // [sp+64h] [bp+5Ch]
  unsigned int m; // [sp+68h] [bp+60h]
  int v15; // [sp+6Ch] [bp+64h]
  int v16; // [sp+70h] [bp+68h]
  unsigned int v17; // [sp+74h] [bp+6Ch]
  unsigned int v18; // [sp+78h] [bp+70h]
  int v19; // [sp+7Ch] [bp+74h]
  int i; // [sp+80h] [bp+78h]
  int j; // [sp+84h] [bp+7Ch]

  memset(v6, 0, sizeof(v6));
  v8 = 0;
  v18 = 0;
  v17 = 0;
  v16 = 0;
  v15 = 0;
  m = 0;
  k = 0;
  v7 = 0;
  v12 = dword_61C2C;
  v11 = dword_61C30;
  v10 = dword_61C34;
  v9 = dword_61C38;
  printf("\n--- %s\n", "get_works");
  if ( dword_61BCC == 1 )
  {
    for ( i = 0; i <= 31; ++i )
    {
      if ( (v12 & 1) != 0 )
        ++v16;
      v12 >>= 1;
      if ( (v11 & 1) != 0 )
        ++v16;
      v11 >>= 1;
      if ( (v10 & 1) != 0 )
        ++v16;
      v10 >>= 1;
      if ( (v9 & 1) != 0 )
        ++v16;
      v9 >>= 1;
    }
    printf("%s: single ASIC : we need test %d cores\n\n", "get_works", v16);
  }
  v12 = dword_61C2C;
  v11 = dword_61C30;
  v10 = dword_61C34;
  v9 = dword_61C38;
  if ( dword_61BD4 == 1385 )
    v17 = 50;
  if ( gHashBoard_V9 )
    v18 = 4;
  v15 = 0;
  if ( dword_61BCC == 1 )
  {
    for ( j = 0; j < v16; ++j )
    {
      while ( v15 < (int)v17 )
      {
        if ( v15 > 31 )
        {
          if ( v15 > 63 )
          {
            if ( v15 > 95 )
            {
              if ( (v9 & 1) != 0 )
              {
                sprintf(v6, "%s%s%02i.txt", dest, byte_518B4, v15++);
                v9 >>= 1;
                break;
              }
              v9 >>= 1;
            }
            else
            {
              if ( (v10 & 1) != 0 )
              {
                sprintf(v6, "%s%s%02i.txt", dest, byte_518B4, v15++);
                v10 >>= 1;
                break;
              }
              v10 >>= 1;
            }
          }
          else
          {
            if ( (v11 & 1) != 0 )
            {
              sprintf(v6, "%s%s%02i.txt", dest, byte_518B4, v15++);
              v11 >>= 1;
              break;
            }
            v11 >>= 1;
          }
        }
        else
        {
          if ( (v12 & 1) != 0 )
          {
            sprintf(v6, "%s%s%02i.txt", dest, byte_518B4, v15++);
            v12 >>= 1;
            break;
          }
          v12 >>= 1;
        }
        ++v15;
      }
      v0 = fopen(v6, "r");
      *((_DWORD *)&cgpu + j) = v0;
      if ( !*((_DWORD *)&cgpu + j) )
        goto LABEL_38;
      work = get_work(j, dword_61BA0);
      *((_DWORD *)&cgpu + j + 16555) = work;
      fclose(*((FILE **)&cgpu + j));
    }
  }
  else
  {
    for ( k = 0; v18 > k; ++k )
    {
      *((_DWORD *)&cgpu + k + 16427) = malloc(56 * v17 * dword_61BA0);
      if ( !*((_DWORD *)&cgpu + k + 16427) )
      {
        printf("%s: malloc struct work err!\n", "get_works");
        return -1;
      }
      for ( m = 0; v17 > m; ++m )
      {
        sprintf(v6, "%s%02i%s%02i.txt", dest, k, byte_518B4, m);
        v3 = k * v17 + m;
        *((_DWORD *)&cgpu + v3) = fopen(v6, "r");
        if ( !*((_DWORD *)&cgpu + k * v17 + m) )
        {
LABEL_38:
          printf("%s: Open test file %s error\n", "get_works", v6);
          return -1;
        }
        v4 = k * v17 + m;
        *((_DWORD *)&cgpu + v4 + 16555) = get_work_hash_board(k, m, *((FILE **)&cgpu + v4), dword_61BA0);
        fclose(*((FILE **)&cgpu + k * v17 + m));
      }
    }
  }
  dword_61AF4 = dword_51AF4;
  v19 = 0;
  if ( dword_61BCC == 1 )
  {
    for ( j = 0; j < v16; ++j )
    {
      if ( dword_61AF4 > *((_DWORD *)&cgpu + j + 16555) )
      {
        dword_61AF4 = *((_DWORD *)&cgpu + j + 16555);
        v19 = j;
      }
    }
  }
  else
  {
    for ( j = 0; (int)(v17 * v18) > j; ++j )
    {
      if ( dword_61AF4 > *((_DWORD *)&cgpu + j + 16555) )
      {
        dword_61AF4 = *((_DWORD *)&cgpu + j + 16555);
        v19 = j;
      }
    }
  }
  if ( dword_61BA0 <= (unsigned int)dword_61AF4 )
    return 0;
  write_lcd(1u, (int)"Get Less Work", 0xDu);
  printf("%s: cgpu.subid[%d] = %d, is the least pattern number\n", "get_works", v19, dword_61AF4);
  return -1;
}
// 2172E: conditional instruction was optimized away because %var_20.4>=20
// 21772: conditional instruction was optimized away because %var_20.4>=40
// 3176C: using guessed type char gHashBoard_V9;
// 51AF4: using guessed type int dword_51AF4;
// 61AF4: using guessed type int dword_61AF4;
// 61BA0: using guessed type int dword_61BA0;
// 61BCC: using guessed type int dword_61BCC;
// 61BD4: using guessed type int dword_61BD4;
// 61C2C: using guessed type int dword_61C2C;
// 61C30: using guessed type int dword_61C30;
// 61C34: using guessed type int dword_61C34;
// 61C38: using guessed type int dword_61C38;

//----- (00021BA0) --------------------------------------------------------
int clear_nonce_return_flag()
{
  int result; // r0
  int v1; // [sp+4h] [bp+4h]
  unsigned int v2; // [sp+Ch] [bp+Ch]
  unsigned int v3; // [sp+10h] [bp+10h]
  unsigned int v4; // [sp+14h] [bp+14h]
  unsigned int v5; // [sp+18h] [bp+18h]
  unsigned int k; // [sp+1Ch] [bp+1Ch]
  unsigned int jj; // [sp+1Ch] [bp+1Ch]
  unsigned int ii; // [sp+20h] [bp+20h]
  unsigned int n; // [sp+24h] [bp+24h]
  int m; // [sp+28h] [bp+28h]
  int kk; // [sp+28h] [bp+28h]
  unsigned int v12; // [sp+2Ch] [bp+2Ch]
  unsigned int v13; // [sp+30h] [bp+30h]
  int v14; // [sp+34h] [bp+34h]
  int i; // [sp+38h] [bp+38h]
  int j; // [sp+3Ch] [bp+3Ch]

  v14 = 0;
  v13 = 0;
  v12 = 0;
  v5 = dword_61C2C;
  v4 = dword_61C30;
  v3 = dword_61C34;
  v2 = dword_61C38;
  result = puts("clear_nonce_return_flag");
  if ( dword_61BCC == 1 )
  {
    for ( i = 0; i <= 31; ++i )
    {
      if ( (v5 & 1) != 0 )
        ++v14;
      v5 >>= 1;
      if ( (v4 & 1) != 0 )
        ++v14;
      v4 >>= 1;
      if ( (v3 & 1) != 0 )
        ++v14;
      v3 >>= 1;
      if ( (v2 & 1) != 0 )
        ++v14;
      v2 >>= 1;
    }
    result = printf("%s: single ASIC get_pattern_loop = %d\n", "clear_nonce_return_flag", v14);
  }
  if ( dword_61BD4 == 1385 )
    v12 = 50;
  if ( gHashBoard_V9 )
    v13 = 4;
  if ( dword_61BCC == 1 )
  {
    for ( j = 0; j < v14; ++j )
    {
      for ( k = 0; dword_61BA0 > k; ++k )
      {
        for ( m = 0; !m; m = 1 )
          *(_DWORD *)(*((_DWORD *)&cgpu + j + 16427) + 56 * k + 52) = 0;
      }
    }
  }
  else
  {
    for ( n = 0; v13 > n; ++n )
    {
      v1 = *((_DWORD *)&cgpu + n + 16427);
      for ( ii = 0; v12 > ii; ++ii )
      {
        for ( jj = 0; dword_61BA0 > jj; ++jj )
        {
          for ( kk = 0; !kk; kk = 1 )
            *(_DWORD *)(v1 + 56 * (ii * dword_61BA0 + jj) + 52) = 0;
        }
      }
    }
  }
  return result;
}
// 3176C: using guessed type char gHashBoard_V9;
// 61BA0: using guessed type int dword_61BA0;
// 61BCC: using guessed type int dword_61BCC;
// 61BD4: using guessed type int dword_61BD4;
// 61C2C: using guessed type int dword_61C2C;
// 61C30: using guessed type int dword_61C30;
// 61C34: using guessed type int dword_61C34;
// 61C38: using guessed type int dword_61C38;

//----- (00021DE8) --------------------------------------------------------
int __fastcall write_pic(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3)
{
  return i2c_write(a3 | (a1 << 26) | 0xA00000 | (a2 << 16));
}

//----- (00021E20) --------------------------------------------------------
int __fastcall read_pic(unsigned __int8 a1, unsigned __int8 a2)
{
  return (unsigned __int8)i2c_read((a2 << 16) | (a1 << 26) | 0xA00000);
}

//----- (00021E58) --------------------------------------------------------
int __fastcall set_PIC16F1704_flash_point32_ter(char a1, char a2, unsigned __int8 a3, unsigned __int8 a4)
{
  __int16 v4; // r3
  int v5; // r4
  int v11; // [sp+Ch] [bp+Ch]
  unsigned __int8 v12; // [sp+10h] [bp+10h]
  unsigned __int8 v13; // [sp+11h] [bp+11h]
  char v14; // [sp+12h] [bp+12h]
  char v15; // [sp+13h] [bp+13h]
  __int16 v16[2]; // [sp+14h] [bp+14h]
  char v17; // [sp+18h] [bp+18h]
  char v18; // [sp+19h] [bp+19h]
  __int16 v19; // [sp+1Ch] [bp+1Ch]
  char v20; // [sp+1Eh] [bp+1Eh]
  unsigned __int8 i; // [sp+1Fh] [bp+1Fh]

  v20 = 6;
  v16[0] = 255;
  v11 = 17214037;
  v4 = a3 + 6 + a4;
  v19 = v4 + 1;
  v17 = (unsigned __int16)(v4 + 1) >> 8;
  v18 = v4 + 1;
  v12 = a3;
  v13 = a4;
  v14 = v17;
  v15 = v4 + 1;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 7u; ++i )
    write_pic(a1, a2, *((_BYTE *)&v11 + i));
  usleep(0x186A0u);
  for ( i = 0; i <= 1u; ++i )
  {
    v5 = i;
    *((_BYTE *)v16 + v5) = read_pic(a1, a2);
  }
  pthread_mutex_unlock(&i2c_mutex);
  if ( LOBYTE(v16[0]) == 1 && HIBYTE(v16[0]) == 1 )
  {
    printf("\n--- %s ok\n\n", "set_PIC16F1704_flash_pointer");
    return 1;
  }
  else
  {
    printf(
      "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "set_PIC16F1704_flash_pointer",
      LOBYTE(v16[0]),
      HIBYTE(v16[0]));
    return 0;
  }
}
// 41830: using guessed type pthread_mutex_t i2c_mutex;

//----- (00021F9C) --------------------------------------------------------
int __fastcall send_data_to_PIC16F1704(char a1, char a2, int a3)
{
  int v3; // r4
  _WORD v8[10]; // [sp+14h] [bp+14h] BYREF
  __int16 v9; // [sp+28h] [bp+28h]
  __int16 v10[2]; // [sp+2Ch] [bp+2Ch]
  __int16 v11; // [sp+30h] [bp+30h]
  char v12; // [sp+34h] [bp+34h]
  unsigned __int8 i; // [sp+35h] [bp+35h]
  __int16 v14; // [sp+36h] [bp+36h]

  v12 = 20;
  v11 = 255;
  v10[0] = 255;
  memset(v8, 0, sizeof(v8));
  v9 = 0;
  v14 = 22;
  for ( i = 0; i <= 0xFu; ++i )
    v14 += *(unsigned __int8 *)(a3 + i);
  LOBYTE(v11) = HIBYTE(v14);
  HIBYTE(v11) = v14;
  v8[0] = -21931;
  LOBYTE(v8[1]) = v12;
  HIBYTE(v8[1]) = 2;
  for ( i = 0; i <= 0xFu; ++i )
    *((_BYTE *)&v8[2] + i) = *(_BYTE *)(a3 + i);
  v9 = v11;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 0x15u; ++i )
    write_pic(a1, a2, *((_BYTE *)v8 + i));
  usleep(0x186A0u);
  for ( i = 0; i <= 1u; ++i )
  {
    v3 = i;
    *((_BYTE *)v10 + v3) = read_pic(a1, a2);
  }
  pthread_mutex_unlock(&i2c_mutex);
  if ( LOBYTE(v10[0]) == 2 && HIBYTE(v10[0]) == 1 )
  {
    printf("\n--- %s ok\n\n", "send_data_to_PIC16F1704");
    return 1;
  }
  else
  {
    printf(
      "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "send_data_to_PIC16F1704",
      LOBYTE(v10[0]),
      HIBYTE(v10[0]));
    return 0;
  }
}
// 41830: using guessed type pthread_mutex_t i2c_mutex;

//----- (00022178) --------------------------------------------------------
int __fastcall read_PIC16F1704_flash_point32_ter(char a1, char a2, unsigned __int8 *a3, unsigned __int8 *a4)
{
  int v4; // r4
  int v11; // [sp+20h] [bp+10h]
  char v12; // [sp+24h] [bp+14h]
  char v13; // [sp+25h] [bp+15h]
  int v14; // [sp+28h] [bp+18h]
  __int16 v15; // [sp+2Ch] [bp+1Ch]
  __int16 v16; // [sp+30h] [bp+20h]
  __int16 v17; // [sp+34h] [bp+24h]
  char v18; // [sp+36h] [bp+26h]
  unsigned __int8 i; // [sp+37h] [bp+27h]

  v18 = 4;
  v16 = 3072;
  v14 = 255;
  v15 = 0;
  v11 = 134523477;
  v17 = 12;
  v12 = 0;
  v13 = 12;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(a1, a2, *((_BYTE *)&v11 + i));
  usleep(0x186A0u);
  for ( i = 0; i <= 5u; ++i )
  {
    v4 = i;
    *((_BYTE *)&v14 + v4) = read_pic(a1, a2);
  }
  pthread_mutex_unlock(&i2c_mutex);
  if ( BYTE1(v14) == 8
    && (unsigned __int8)v14 == 6
    && (v17 = (unsigned __int8)v14 + BYTE1(v14) + BYTE2(v14) + HIBYTE(v14), HIBYTE(v17) == (unsigned __int8)v15)
    && (unsigned __int8)v17 == HIBYTE(v15) )
  {
    *a3 = BYTE2(v14);
    *a4 = HIBYTE(v14);
    printf("\n--- %s ok! flash_addr_h = 0x%02x, flash_addr_l = 0x%02x\n\n", "read_PIC16F1704_flash_pointer", *a3, *a4);
    return 1;
  }
  else
  {
    printf(
      "\n"
      "--- %s failed! read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0"
      "x%x, read_back_data[4] = 0x%x, read_back_data[5] = 0x%x\n"
      "\n",
      "read_PIC16F1704_flash_pointer",
      (unsigned __int8)v14,
      BYTE1(v14),
      BYTE2(v14),
      HIBYTE(v14),
      (unsigned __int8)v15,
      HIBYTE(v15));
    return 0;
  }
}
// 41830: using guessed type pthread_mutex_t i2c_mutex;

//----- (0002235C) --------------------------------------------------------
int __fastcall read_PIC16F1704_flash_data(char a1, char a2, int a3)
{
  int v3; // r4
  int v9; // [sp+74h] [bp+2Ch]
  char v10; // [sp+78h] [bp+30h]
  char v11; // [sp+79h] [bp+31h]
  int v12; // [sp+7Ch] [bp+34h]
  int v13; // [sp+80h] [bp+38h]
  int v14; // [sp+84h] [bp+3Ch]
  int v15; // [sp+88h] [bp+40h]
  int v16; // [sp+8Ch] [bp+44h]
  __int16 v17; // [sp+90h] [bp+48h]
  unsigned __int16 v18; // [sp+94h] [bp+4Ch]
  char v19; // [sp+96h] [bp+4Eh]
  unsigned __int8 i; // [sp+97h] [bp+4Fh]

  v19 = 4;
  v17 = 1792;
  v12 = 255;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v9 = 50637397;
  v18 = 7;
  v10 = 0;
  v11 = 7;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(a1, a2, *((_BYTE *)&v9 + i));
  usleep((__useconds_t)&unk_493E0);
  for ( i = 0; i <= 0x13u; ++i )
  {
    v3 = i;
    *((_BYTE *)&v12 + v3) = read_pic(a1, a2);
  }
  pthread_mutex_unlock(&i2c_mutex);
  printf(
    "--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, \t\t"
    "read_back_data[4] = 0x%x, read_back_data[5] = 0x%x, read_back_data[6] = 0x%x, read_back_data[7] = 0x%x, \t\tread_bac"
    "k_data[8] = 0x%x, read_back_data[9] = 0x%x, read_back_data[10] = 0x%x, read_back_data[11] = 0x%x, \t\tread_back_data"
    "[12] = 0x%x, read_back_data[13] = 0x%x, read_back_data[14] = 0x%x, read_back_data[15] = 0x%x, \t\tread_back_data[16]"
    " = 0x%x, read_back_data[17] = 0x%x, read_back_data[18] = 0x%x, read_back_data[19] = 0x%x\n",
    "read_PIC16F1704_flash_data",
    (unsigned __int8)v12,
    BYTE1(v12),
    BYTE2(v12),
    HIBYTE(v12),
    (unsigned __int8)v13,
    BYTE1(v13),
    BYTE2(v13),
    HIBYTE(v13),
    (unsigned __int8)v14,
    BYTE1(v14),
    BYTE2(v14),
    HIBYTE(v14),
    (unsigned __int8)v15,
    BYTE1(v15),
    BYTE2(v15),
    HIBYTE(v15),
    (unsigned __int8)v16,
    BYTE1(v16),
    BYTE2(v16),
    HIBYTE(v16));
  usleep(0x186A0u);
  if ( BYTE1(v12) == 3 && (unsigned __int8)v12 == 20 )
  {
    v18 = (unsigned __int8)v12
        + BYTE1(v12)
        + BYTE2(v12)
        + HIBYTE(v12)
        + (unsigned __int8)v13
        + BYTE1(v13)
        + BYTE2(v13)
        + HIBYTE(v13)
        + (unsigned __int8)v14
        + BYTE1(v14)
        + BYTE2(v14)
        + HIBYTE(v14)
        + (unsigned __int8)v15
        + BYTE1(v15)
        + BYTE2(v15)
        + HIBYTE(v15)
        + (unsigned __int8)v16
        + BYTE1(v16);
    if ( HIBYTE(v18) == BYTE2(v16) && (unsigned __int8)v18 == HIBYTE(v16) )
    {
      for ( i = 0; i <= 0xFu; ++i )
        *(_BYTE *)(a3 + i) = *((_BYTE *)&v12 + i + 2);
      printf("\n--- %s ok\n\n", "read_PIC16F1704_flash_data");
      return 1;
    }
    else
    {
      printf("\n--- %s failed! crc = 0x%04x\n\n", "read_PIC16F1704_flash_data", v18);
      return 0;
    }
  }
  else
  {
    printf("\n--- %s failed!\n\n", "read_PIC16F1704_flash_data");
    return 0;
  }
}
// 41830: using guessed type pthread_mutex_t i2c_mutex;

//----- (000226C0) --------------------------------------------------------
int __fastcall erase_PIC16F1704_flash(unsigned __int8 a1, unsigned __int8 a2)
{
  int v2; // r4
  int v7; // [sp+Ch] [bp+Ch]
  char v8; // [sp+10h] [bp+10h]
  char v9; // [sp+11h] [bp+11h]
  __int16 v10[5]; // [sp+14h] [bp+14h]
  char v11; // [sp+1Eh] [bp+1Eh]
  unsigned __int8 i; // [sp+1Fh] [bp+1Fh]

  v11 = 4;
  v10[2] = 2048;
  v10[0] = 255;
  v7 = 67414613;
  v10[4] = 8;
  v8 = 0;
  v9 = 8;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(a1, a2, *((_BYTE *)&v7 + i));
  usleep(0x186A0u);
  for ( i = 0; i <= 1u; ++i )
  {
    v2 = i;
    *((_BYTE *)v10 + v2) = read_pic(a1, a2);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep((__useconds_t)&unk_30D40);
  if ( LOBYTE(v10[0]) == 4 && HIBYTE(v10[0]) == 1 )
  {
    printf("\n--- %s ok\n\n", "erase_PIC16F1704_flash");
    return 1;
  }
  else
  {
    printf(
      "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "erase_PIC16F1704_flash",
      LOBYTE(v10[0]),
      HIBYTE(v10[0]));
    return 0;
  }
}
// 41830: using guessed type pthread_mutex_t i2c_mutex;

//----- (000227F4) --------------------------------------------------------
int __fastcall write_data_into_PIC16F1704_flash(unsigned __int8 a1, unsigned __int8 a2)
{
  int v2; // r4
  int v7; // [sp+Ch] [bp+Ch]
  char v8; // [sp+10h] [bp+10h]
  char v9; // [sp+11h] [bp+11h]
  __int16 v10[5]; // [sp+14h] [bp+14h]
  char v11; // [sp+1Eh] [bp+1Eh]
  unsigned __int8 i; // [sp+1Fh] [bp+1Fh]

  v11 = 4;
  v10[2] = 2304;
  v10[0] = 255;
  v7 = 84191829;
  v10[4] = 9;
  v8 = 0;
  v9 = 9;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(a1, a2, *((_BYTE *)&v7 + i));
  usleep((__useconds_t)&unk_30D40);
  for ( i = 0; i <= 1u; ++i )
  {
    v2 = i;
    *((_BYTE *)v10 + v2) = read_pic(a1, a2);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep((__useconds_t)&unk_30D40);
  if ( LOBYTE(v10[0]) == 5 && HIBYTE(v10[0]) == 1 )
  {
    printf("\n--- %s ok\n\n", "write_data_into_PIC16F1704_flash");
    return 1;
  }
  else
  {
    printf(
      "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "write_data_into_PIC16F1704_flash",
      LOBYTE(v10[0]),
      HIBYTE(v10[0]));
    return 0;
  }
}
// 41830: using guessed type pthread_mutex_t i2c_mutex;

//----- (00022928) --------------------------------------------------------
int __fastcall jump_from_loader_to_app_PIC16F1704(char a1, char a2)
{
  int v2; // r4
  int v7; // [sp+Ch] [bp+Ch]
  char v8; // [sp+10h] [bp+10h]
  char v9; // [sp+11h] [bp+11h]
  __int16 v10[5]; // [sp+14h] [bp+14h]
  char v11; // [sp+1Eh] [bp+1Eh]
  unsigned __int8 i; // [sp+1Fh] [bp+1Fh]

  v11 = 4;
  v10[2] = 2560;
  v10[0] = 255;
  v7 = 100969045;
  v10[4] = 10;
  v8 = 0;
  v9 = 10;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(a2, a1, *((_BYTE *)&v7 + i));
  usleep(0x186A0u);
  for ( i = 0; i <= 1u; ++i )
  {
    v2 = i;
    *((_BYTE *)v10 + v2) = read_pic(a2, a1);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep((__useconds_t)&unk_493E0);
  if ( LOBYTE(v10[0]) == 6 && HIBYTE(v10[0]) == 1 )
  {
    printf("\n--- %s ok\n\n", "jump_from_loader_to_app_PIC16F1704");
    return 1;
  }
  else
  {
    printf(
      "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "jump_from_loader_to_app_PIC16F1704",
      LOBYTE(v10[0]),
      HIBYTE(v10[0]));
    return 0;
  }
}
// 41830: using guessed type pthread_mutex_t i2c_mutex;

//----- (00022A5C) --------------------------------------------------------
int __fastcall reset_PIC16F1704_pic(unsigned __int8 a1, unsigned __int8 a2)
{
  int v2; // r4
  int v7; // [sp+Ch] [bp+Ch]
  char v8; // [sp+10h] [bp+10h]
  char v9; // [sp+11h] [bp+11h]
  __int16 v10[5]; // [sp+14h] [bp+14h]
  char v11; // [sp+1Eh] [bp+1Eh]
  unsigned __int8 i; // [sp+1Fh] [bp+1Fh]

  v11 = 4;
  v10[2] = 2816;
  v10[0] = 255;
  v7 = 117746261;
  v10[4] = 11;
  v8 = 0;
  v9 = 11;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(a2, a1, *((_BYTE *)&v7 + i));
  usleep(0x186A0u);
  for ( i = 0; i <= 1u; ++i )
  {
    v2 = i;
    *((_BYTE *)v10 + v2) = read_pic(a2, a1);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep(0xF4240u);
  if ( LOBYTE(v10[0]) == 7 && HIBYTE(v10[0]) == 1 )
  {
    printf("\n--- %s ok\n\n", "reset_PIC16F1704_pic");
    return 1;
  }
  else
  {
    printf(
      "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "reset_PIC16F1704_pic",
      LOBYTE(v10[0]),
      HIBYTE(v10[0]));
    return 0;
  }
}
// 41830: using guessed type pthread_mutex_t i2c_mutex;

//----- (00022B90) --------------------------------------------------------
int __fastcall set_PIC16F1704_voltage(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3)
{
  int v3; // r4
  char v9[8]; // [sp+Ch] [bp+Ch]
  __int16 v10[2]; // [sp+14h] [bp+14h]
  char v11; // [sp+18h] [bp+18h]
  char v12; // [sp+19h] [bp+19h]
  __int16 v13; // [sp+1Ch] [bp+1Ch]
  char v14; // [sp+1Eh] [bp+1Eh]
  unsigned __int8 i; // [sp+1Fh] [bp+1Fh]

  v14 = 5;
  v10[0] = 255;
  printf("\n--- %s\n", "set_PIC16F1704_voltage");
  v13 = a3 + 21;
  v11 = HIBYTE(v13);
  v12 = a3 + 21;
  v9[0] = 85;
  v9[1] = -86;
  v9[2] = 5;
  v9[3] = 16;
  v9[4] = a3;
  v9[5] = HIBYTE(v13);
  v9[6] = a3 + 21;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 6u; ++i )
    write_pic(a2, a1, v9[i]);
  usleep((__useconds_t)&unk_30D40);
  for ( i = 0; i <= 1u; ++i )
  {
    v3 = i;
    *((_BYTE *)v10 + v3) = read_pic(a2, a1);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep((__useconds_t)&unk_30D40);
  if ( LOBYTE(v10[0]) == 16 && HIBYTE(v10[0]) == 1 )
  {
    printf("\n--- %s ok\n\n", "set_PIC16F1704_voltage");
    return 1;
  }
  else
  {
    printf(
      "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "set_PIC16F1704_voltage",
      LOBYTE(v10[0]),
      HIBYTE(v10[0]));
    return 0;
  }
}
// 41830: using guessed type pthread_mutex_t i2c_mutex;

//----- (00022CF8) --------------------------------------------------------
int __fastcall write_hash_ID_PIC16F1704(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  int v3; // r4
  int v8[4]; // [sp+10h] [bp+10h] BYREF
  __int16 v9; // [sp+20h] [bp+20h]
  __int16 v10[2]; // [sp+24h] [bp+24h]
  __int16 v11; // [sp+28h] [bp+28h]
  char v12; // [sp+2Ch] [bp+2Ch]
  unsigned __int8 i; // [sp+2Dh] [bp+2Dh]
  __int16 v14; // [sp+2Eh] [bp+2Eh]

  v12 = 16;
  v11 = 255;
  v10[0] = 255;
  memset(v8, 0, sizeof(v8));
  v9 = 0;
  v14 = 34;
  for ( i = 0; i <= 0xBu; ++i )
    v14 += *(unsigned __int8 *)(a3 + i);
  LOBYTE(v11) = HIBYTE(v14);
  HIBYTE(v11) = v14;
  LOWORD(v8[0]) = -21931;
  BYTE2(v8[0]) = v12;
  HIBYTE(v8[0]) = 18;
  for ( i = 0; i <= 0xBu; ++i )
    *((_BYTE *)&v8[1] + i) = *(_BYTE *)(a3 + i);
  v9 = v11;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 0x11u; ++i )
    write_pic(a2, a1, *((_BYTE *)v8 + i));
  usleep((__useconds_t)&unk_61A80);
  for ( i = 0; i <= 1u; ++i )
  {
    v3 = i;
    *((_BYTE *)v10 + v3) = read_pic(a2, a1);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep((__useconds_t)&unk_30D40);
  if ( LOBYTE(v10[0]) == 18 && HIBYTE(v10[0]) == 1 )
  {
    printf("\n--- %s ok\n\n", "write_hash_ID_PIC16F1704");
    return 1;
  }
  else
  {
    printf(
      "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "write_hash_ID_PIC16F1704",
      LOBYTE(v10[0]),
      HIBYTE(v10[0]));
    return 0;
  }
}
// 41830: using guessed type pthread_mutex_t i2c_mutex;

//----- (00022EDC) --------------------------------------------------------
int __fastcall read_hash_id_PIC16F1704(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  int v3; // r4
  int v9; // [sp+50h] [bp+18h]
  char v10; // [sp+54h] [bp+1Ch]
  char v11; // [sp+55h] [bp+1Dh]
  int v12; // [sp+58h] [bp+20h]
  int v13; // [sp+5Ch] [bp+24h]
  int v14; // [sp+60h] [bp+28h]
  int v15; // [sp+64h] [bp+2Ch]
  __int16 v16; // [sp+68h] [bp+30h]
  unsigned __int16 v17; // [sp+6Ch] [bp+34h]
  char v18; // [sp+6Eh] [bp+36h]
  unsigned __int8 i; // [sp+6Fh] [bp+37h]

  v18 = 4;
  v16 = 5888;
  v12 = 255;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v9 = 319072853;
  v17 = 23;
  v10 = 0;
  v11 = 23;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(a1, a2, *((_BYTE *)&v9 + i));
  usleep((__useconds_t)&unk_30D40);
  for ( i = 0; i <= 0xFu; ++i )
  {
    v3 = i;
    *((_BYTE *)&v12 + v3) = read_pic(a1, a2);
  }
  pthread_mutex_unlock(&i2c_mutex);
  printf(
    "--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x,\t\tr"
    "ead_back_data[4] = 0x%x, read_back_data[5] = 0x%x, read_back_data[6] = 0x%x, read_back_data[7] = 0x%x,\t\tread_back_"
    "data[8] = 0x%x, read_back_data[9] = 0x%x, read_back_data[10] = 0x%x, read_back_data[11] = 0x%x,\t\tread_back_data[12"
    "] = 0x%x, read_back_data[13] = 0x%x, read_back_data[14] = 0x%x, read_back_data[15] = 0x%x\n",
    "read_hash_id_PIC16F1704",
    (unsigned __int8)v12,
    BYTE1(v12),
    BYTE2(v12),
    HIBYTE(v12),
    (unsigned __int8)v13,
    BYTE1(v13),
    BYTE2(v13),
    HIBYTE(v13),
    (unsigned __int8)v14,
    BYTE1(v14),
    BYTE2(v14),
    HIBYTE(v14),
    (unsigned __int8)v15,
    BYTE1(v15),
    BYTE2(v15),
    HIBYTE(v15));
  if ( BYTE1(v12) == 19 && (unsigned __int8)v12 == 16 )
  {
    v17 = (unsigned __int8)v12
        + BYTE1(v12)
        + BYTE2(v12)
        + HIBYTE(v12)
        + (unsigned __int8)v13
        + BYTE1(v13)
        + BYTE2(v13)
        + HIBYTE(v13)
        + (unsigned __int8)v14
        + BYTE1(v14)
        + BYTE2(v14)
        + HIBYTE(v14)
        + (unsigned __int8)v15
        + BYTE1(v15);
    if ( HIBYTE(v17) == BYTE2(v15) && (unsigned __int8)v17 == HIBYTE(v15) )
    {
      for ( i = 0; i <= 0xBu; ++i )
        *(_BYTE *)(a3 + i) = *((_BYTE *)&v12 + i + 2);
      printf("\n--- %s ok\n\n", "read_hash_id_PIC16F1704");
      return 1;
    }
    else
    {
      printf("\n--- %s failed! crc = 0x%04x\n\n", "read_hash_id_PIC16F1704", v17);
      return 0;
    }
  }
  else
  {
    printf("\n--- %s failed!\n\n", "read_hash_id_PIC16F1704");
    return 0;
  }
}
// 41830: using guessed type pthread_mutex_t i2c_mutex;

//----- (000231C4) --------------------------------------------------------
int __fastcall enable_PIC16F1704_dc_dc(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3)
{
  int v3; // r4
  char v9[8]; // [sp+Ch] [bp+Ch]
  __int16 v10[2]; // [sp+14h] [bp+14h]
  char v11; // [sp+18h] [bp+18h]
  char v12; // [sp+19h] [bp+19h]
  __int16 v13; // [sp+1Ch] [bp+1Ch]
  char v14; // [sp+1Eh] [bp+1Eh]
  unsigned __int8 i; // [sp+1Fh] [bp+1Fh]

  v14 = 5;
  v10[0] = 255;
  printf("\n--- %s\n", "enable_PIC16F1704_dc_dc");
  v13 = a3 + 26;
  v11 = HIBYTE(v13);
  v12 = a3 + 26;
  v9[0] = 85;
  v9[1] = -86;
  v9[2] = 5;
  v9[3] = 21;
  v9[4] = a3;
  v9[5] = HIBYTE(v13);
  v9[6] = a3 + 26;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 6u; ++i )
    write_pic(a2, a1, v9[i]);
  usleep(0x186A0u);
  for ( i = 0; i <= 1u; ++i )
  {
    v3 = i;
    *((_BYTE *)v10 + v3) = read_pic(a2, a1);
  }
  pthread_mutex_unlock(&i2c_mutex);
  if ( LOBYTE(v10[0]) == 21 && HIBYTE(v10[0]) == 1 )
  {
    printf("\n--- %s ok\n\n", "enable_PIC16F1704_dc_dc");
    usleep(0x7A120u);
    return 1;
  }
  else
  {
    printf(
      "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "enable_PIC16F1704_dc_dc",
      LOBYTE(v10[0]),
      HIBYTE(v10[0]));
    return 0;
  }
}
// 41830: using guessed type pthread_mutex_t i2c_mutex;

//----- (0002332C) --------------------------------------------------------
int __fastcall heart_beat_PIC16F1704(char a1, char a2)
{
  int v2; // r4
  int v7; // [sp+8h] [bp+8h]
  char v8; // [sp+Ch] [bp+Ch]
  char v9; // [sp+Dh] [bp+Dh]
  int v10; // [sp+10h] [bp+10h]
  __int16 v11; // [sp+14h] [bp+14h]
  __int16 v12; // [sp+18h] [bp+18h]
  __int16 v13; // [sp+1Ch] [bp+1Ch]
  char v14; // [sp+1Eh] [bp+1Eh]
  unsigned __int8 i; // [sp+1Fh] [bp+1Fh]

  v14 = 4;
  v12 = 6656;
  v10 = 255;
  v11 = 0;
  v7 = 369404501;
  v13 = 26;
  v8 = 0;
  v9 = 26;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(a2, a1, *((_BYTE *)&v7 + i));
  usleep(0x186A0u);
  for ( i = 0; i <= 5u; ++i )
  {
    v2 = i;
    *((_BYTE *)&v10 + v2) = read_pic(a2, a1);
  }
  pthread_mutex_unlock(&i2c_mutex);
  if ( BYTE1(v10) == 22 && BYTE2(v10) == 1 )
  {
    printf("\n--- %s ok\n\n", "heart_beat_PIC16F1704");
    return 1;
  }
  else
  {
    printf("\n--- %s failed!\n\n", "heart_beat_PIC16F1704");
    return 0;
  }
}
// 41830: using guessed type pthread_mutex_t i2c_mutex;

//----- (00023454) --------------------------------------------------------
void __fastcall __noreturn pic_heart_beat_func(char *a1)
{
  char v1; // [sp+Ah] [bp+Ah]
  char v2; // [sp+Bh] [bp+Bh]

  v2 = *a1;
  v1 = a1[1];
  while ( 1 )
  {
    heart_beat_PIC16F1704(v2, v1);
    sleep(0xAu);
  }
}

//----- (00023480) --------------------------------------------------------
int __fastcall get_PIC16F1704_software_version(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 *a3)
{
  int v3; // r4
  int v9; // [sp+20h] [bp+10h]
  char v10; // [sp+24h] [bp+14h]
  char v11; // [sp+25h] [bp+15h]
  int v12; // [sp+28h] [bp+18h]
  unsigned __int8 v13; // [sp+2Ch] [bp+1Ch]
  __int16 v14; // [sp+30h] [bp+20h]
  unsigned __int16 v15; // [sp+34h] [bp+24h]
  char v16; // [sp+36h] [bp+26h]
  unsigned __int8 i; // [sp+37h] [bp+27h]

  v16 = 4;
  v14 = 6912;
  v12 = 255;
  v13 = 0;
  v9 = 386181717;
  v15 = 27;
  v10 = 0;
  v11 = 27;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(a1, a2, *((_BYTE *)&v9 + i));
  usleep((__useconds_t)&unk_30D40);
  for ( i = 0; i <= 4u; ++i )
  {
    v3 = i;
    *((_BYTE *)&v12 + v3) = read_pic(a1, a2);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep((__useconds_t)&unk_30D40);
  printf(
    "--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, read"
    "_back_data[4] = 0x%x\n",
    "get_PIC16F1704_software_version",
    (unsigned __int8)v12,
    BYTE1(v12),
    BYTE2(v12),
    HIBYTE(v12),
    v13);
  if ( BYTE1(v12) == 23 && (unsigned __int8)v12 == 5 )
  {
    v15 = (unsigned __int8)v12 + BYTE1(v12) + BYTE2(v12);
    if ( HIBYTE(v15) == HIBYTE(v12) && (unsigned __int8)v15 == v13 )
    {
      *a3 = BYTE2(v12);
      printf("\n--- %s ok, version = 0x%02x\n\n", "get_PIC16F1704_software_version", *a3);
      return 1;
    }
    else
    {
      printf("\n--- %s failed! crc = 0x%04x\n\n", "get_PIC16F1704_software_version", v15);
      return 0;
    }
  }
  else
  {
    printf("\n--- %s failed!\n\n", "get_PIC16F1704_software_version");
    return 0;
  }
}
// 41830: using guessed type pthread_mutex_t i2c_mutex;

//----- (00023654) --------------------------------------------------------
int __fastcall get_PIC16F1704_voltage(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 *a3)
{
  int v3; // r4
  int v9; // [sp+20h] [bp+10h]
  char v10; // [sp+24h] [bp+14h]
  char v11; // [sp+25h] [bp+15h]
  int v12; // [sp+28h] [bp+18h]
  unsigned __int8 v13; // [sp+2Ch] [bp+1Ch]
  __int16 v14; // [sp+30h] [bp+20h]
  unsigned __int16 v15; // [sp+34h] [bp+24h]
  char v16; // [sp+36h] [bp+26h]
  unsigned __int8 i; // [sp+37h] [bp+27h]

  v16 = 4;
  v14 = 7168;
  v12 = 255;
  v13 = 0;
  v9 = 402958933;
  v15 = 28;
  v10 = 0;
  v11 = 28;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(a1, a2, *((_BYTE *)&v9 + i));
  usleep((__useconds_t)&unk_30D40);
  for ( i = 0; i <= 4u; ++i )
  {
    v3 = i;
    *((_BYTE *)&v12 + v3) = read_pic(a1, a2);
  }
  pthread_mutex_unlock(&i2c_mutex);
  printf(
    "--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, read"
    "_back_data[4] = 0x%x\n",
    "get_PIC16F1704_voltage",
    (unsigned __int8)v12,
    BYTE1(v12),
    BYTE2(v12),
    HIBYTE(v12),
    v13);
  if ( BYTE1(v12) == 24 && (unsigned __int8)v12 == 5 )
  {
    v15 = (unsigned __int8)v12 + BYTE1(v12) + BYTE2(v12);
    if ( HIBYTE(v15) == HIBYTE(v12) && (unsigned __int8)v15 == v13 )
    {
      *a3 = BYTE2(v12);
      printf("\n--- %s ok, voltage = 0x%02x\n\n", "get_PIC16F1704_voltage", *a3);
      return 1;
    }
    else
    {
      printf("\n--- %s failed! crc = 0x%04x\n\n", "get_PIC16F1704_voltage", v15);
      return 0;
    }
  }
  else
  {
    printf("\n--- %s failed!\n\n", "get_PIC16F1704_voltage");
    return 0;
  }
}
// 41830: using guessed type pthread_mutex_t i2c_mutex;

//----- (0002381C) --------------------------------------------------------
int __fastcall write_temperature_offset_PIC16F1704(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  int v3; // r4
  int v8[3]; // [sp+14h] [bp+14h] BYREF
  __int16 v9; // [sp+20h] [bp+20h]
  __int16 v10[2]; // [sp+24h] [bp+24h]
  __int16 v11; // [sp+28h] [bp+28h]
  char v12; // [sp+2Ch] [bp+2Ch]
  unsigned __int8 i; // [sp+2Dh] [bp+2Dh]
  __int16 v14; // [sp+2Eh] [bp+2Eh]

  v12 = 12;
  v11 = 255;
  v10[0] = 255;
  memset(v8, 0, sizeof(v8));
  v9 = 0;
  v14 = 46;
  for ( i = 0; i <= 7u; ++i )
    v14 += *(unsigned __int8 *)(a3 + i);
  LOBYTE(v11) = HIBYTE(v14);
  HIBYTE(v11) = v14;
  LOWORD(v8[0]) = -21931;
  BYTE2(v8[0]) = v12;
  HIBYTE(v8[0]) = 34;
  for ( i = 0; i <= 7u; ++i )
    *((_BYTE *)&v8[1] + i) = *(_BYTE *)(a3 + i);
  v9 = v11;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 0xDu; ++i )
    write_pic(a1, a2, *((_BYTE *)v8 + i));
  usleep((__useconds_t)&unk_30D40);
  for ( i = 0; i <= 1u; ++i )
  {
    v3 = i;
    *((_BYTE *)v10 + v3) = read_pic(a1, a2);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep((__useconds_t)&unk_30D40);
  if ( LOBYTE(v10[0]) == 34 && HIBYTE(v10[0]) == 1 )
  {
    printf("\n--- %s ok\n\n", "write_temperature_offset_PIC16F1704");
    return 1;
  }
  else
  {
    printf(
      "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "write_temperature_offset_PIC16F1704",
      LOBYTE(v10[0]),
      HIBYTE(v10[0]));
    return 0;
  }
}
// 41830: using guessed type pthread_mutex_t i2c_mutex;

//----- (000239F8) --------------------------------------------------------
int __fastcall read_temperature_offset_PIC16F1704(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  int v3; // r4
  int v9; // [sp+3Ch] [bp+14h]
  char v10; // [sp+40h] [bp+18h]
  char v11; // [sp+41h] [bp+19h]
  int v12; // [sp+44h] [bp+1Ch]
  int v13; // [sp+48h] [bp+20h]
  int v14; // [sp+4Ch] [bp+24h]
  __int16 v15; // [sp+50h] [bp+28h]
  unsigned __int16 v16; // [sp+54h] [bp+2Ch]
  char v17; // [sp+56h] [bp+2Eh]
  unsigned __int8 i; // [sp+57h] [bp+2Fh]

  v17 = 4;
  v15 = 9984;
  v12 = 255;
  v13 = 0;
  v14 = 0;
  v9 = 587508309;
  v16 = 39;
  v10 = 0;
  v11 = 39;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(a1, a2, *((_BYTE *)&v9 + i));
  usleep((__useconds_t)&unk_30D40);
  for ( i = 0; i <= 0xBu; ++i )
  {
    v3 = i;
    *((_BYTE *)&v12 + v3) = read_pic(a1, a2);
  }
  pthread_mutex_unlock(&i2c_mutex);
  printf(
    "--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, \t\t"
    "read_back_data[4] = 0x%x, read_back_data[5] = 0x%x, read_back_data[6] = 0x%x, read_back_data[7] = 0x%x, \t\tread_bac"
    "k_data[8] = 0x%x, read_back_data[9] = 0x%x, read_back_data[10] = 0x%x, read_back_data[11] = 0x%x\n",
    "read_temperature_offset_PIC16F1704",
    (unsigned __int8)v12,
    BYTE1(v12),
    BYTE2(v12),
    HIBYTE(v12),
    (unsigned __int8)v13,
    BYTE1(v13),
    BYTE2(v13),
    HIBYTE(v13),
    (unsigned __int8)v14,
    BYTE1(v14),
    BYTE2(v14),
    HIBYTE(v14));
  if ( BYTE1(v12) == 35 && (unsigned __int8)v12 == 12 )
  {
    v16 = (unsigned __int8)v12
        + BYTE1(v12)
        + BYTE2(v12)
        + HIBYTE(v12)
        + (unsigned __int8)v13
        + BYTE1(v13)
        + BYTE2(v13)
        + HIBYTE(v13)
        + (unsigned __int8)v14
        + BYTE1(v14);
    if ( HIBYTE(v16) == BYTE2(v14) && (unsigned __int8)v16 == HIBYTE(v14) )
    {
      for ( i = 0; i <= 7u; ++i )
        *(_BYTE *)(a3 + i) = *((_BYTE *)&v12 + i + 2);
      printf("\n--- %s ok\n\n", "read_temperature_offset_PIC16F1704");
      return 1;
    }
    else
    {
      printf("\n--- %s failed! crc = 0x%04x\n\n", "read_temperature_offset_PIC16F1704", v16);
      return 0;
    }
  }
  else
  {
    printf("\n--- %s failed!\n\n", "read_temperature_offset_PIC16F1704");
    return 0;
  }
}
// 41830: using guessed type pthread_mutex_t i2c_mutex;

//----- (00023C7C) --------------------------------------------------------
int __fastcall erase_PIC16F1704_app_flash(char a1, char a2)
{
  unsigned int i; // [sp+1Ch] [bp+1Ch]

  set_PIC16F1704_flash_point32_ter(a1, a2, 6u, 0);
  printf("%s: erase_loop = %d\n", "erase_PIC16F1704_app_flash", 76);
  for ( i = 0; i < 0x4C; ++i )
    erase_PIC16F1704_flash(a1, a2);
  return 76;
}

//----- (00023D10) --------------------------------------------------------
int __fastcall PIC1704_update_pic_app_program(char a1, char a2)
{
  int v2; // r3
  int *v3; // r3
  int v4; // r0
  int v5; // r1
  int v6; // r2
  int v7; // r3
  int v11; // [sp+60h] [bp+60h] BYREF
  int v12; // [sp+64h] [bp+64h]
  int v13; // [sp+68h] [bp+68h]
  int v14; // [sp+6Ch] [bp+6Ch]
  char v15[8]; // [sp+70h] [bp+70h] BYREF
  _BYTE v16[5000]; // [sp+78h] [bp+78h] BYREF
  FILE *v17; // [sp+1400h] [bp+1400h]
  int v18; // [sp+1404h] [bp+1404h]
  unsigned int v19; // [sp+1408h] [bp+1408h]
  unsigned __int8 v20; // [sp+140Ch] [bp+140Ch]
  unsigned __int8 v21; // [sp+140Dh] [bp+140Dh]
  unsigned __int8 v22; // [sp+140Eh] [bp+140Eh]
  unsigned __int8 v23; // [sp+140Fh] [bp+140Fh]
  _DWORD v24[2]; // [sp+1410h] [bp+1410h]
  unsigned int i; // [sp+1418h] [bp+1418h]
  _DWORD v26[2]; // [sp+141Ch] [bp+141Ch]

  memset(v16, 0, sizeof(v16));
  v24[1] = 0;
  v26[0] = 0;
  v15[0] = 0;
  v15[1] = 0;
  v15[2] = 0;
  v15[3] = 0;
  v15[4] = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v24[0] = 0;
  v23 = 6;
  v22 = 0;
  v21 = 15;
  v20 = 127;
  v19 = 0;
  v18 = 0;
  puts("\n--- update pic program");
  v17 = fopen("/mnt/card/pic16f1704_app.txt", "r");
  if ( v17 )
  {
    fseek(v17, 0, 0);
    memset(v16, 0, sizeof(v16));
    v19 = (v21 << 8) + v20 - ((v23 << 8) + v22) + 1;
    printf("pic_flash_length = %d\n", v19);
    for ( v26[0] = 0; v26[0] < v19; ++v26[0] )
    {
      fgets(v15, 1023, v17);
      v24[0] = strtoul(v15, 0, 16);
      v16[2 * v26[0]] = BYTE1(v24[0]);
      v16[2 * v26[0] + 1] = v24[0];
    }
    fclose(v17);
    v18 = reset_PIC16F1704_pic(a1, a2);
    if ( v18 )
    {
      v18 = erase_PIC16F1704_app_flash(a1, a2);
      if ( v18 )
      {
        v18 = set_PIC16F1704_flash_point32_ter(a1, a2, 6u, 0);
        if ( v18 )
        {
          for ( v26[0] = 0; 4 * (v19 >> 5) > v26[0]; ++v26[0] )
          {
            v3 = (int *)&v16[16 * v26[0]];
            v4 = *v3;
            v5 = v3[1];
            v6 = v3[2];
            v7 = v3[3];
            v11 = v4;
            v12 = v5;
            v13 = v6;
            v14 = v7;
            printf("send pic program time: %d\n", v26[0]);
            for ( i = 0; i <= 0xF; ++i )
              printf("buf[%d] = 0x%02x\n", i, *((unsigned __int8 *)&v11 + i));
            putchar(10);
            send_data_to_PIC16F1704(a1, a2, (int)&v11);
            write_data_into_PIC16F1704_flash(a1, a2);
          }
          v18 = reset_PIC16F1704_pic(a1, a2);
          if ( v18 )
          {
            return 1;
          }
          else
          {
            printf("!!! %s: reset pic error!\n\n", "PIC1704_update_pic_app_program");
            return 0;
          }
        }
        else
        {
          printf("!!! %s: set flash pointer error!\n\n", "PIC1704_update_pic_app_program");
          return 0;
        }
      }
      else
      {
        printf("!!! %s: erase flash error!\n\n", "PIC1704_update_pic_app_program");
        return 0;
      }
    }
    else
    {
      printf("!!! %s: reset pic error!\n\n", "PIC1704_update_pic_app_program");
      return 0;
    }
  }
  else
  {
    printf("\n%s: open pic16f1704_app.txt failed\n", "PIC1704_update_pic_app_program");
  }
  return v2;
}
// 2419A: variable 'v2' is possibly undefined
// 23D10: using guessed type _DWORD anonymous_13[2];

//----- (000241A8) --------------------------------------------------------
int __fastcall save_freq_PIC16F1704(unsigned __int8 a1, unsigned __int8 a2, unsigned __int16 a3)
{
  __int16 v3; // r2
  int v4; // r4
  int v10; // [sp+Ch] [bp+Ch]
  char v11; // [sp+10h] [bp+10h]
  char v12; // [sp+11h] [bp+11h]
  char v13; // [sp+12h] [bp+12h]
  char v14; // [sp+13h] [bp+13h]
  __int16 v15[2]; // [sp+14h] [bp+14h]
  char v16; // [sp+18h] [bp+18h]
  char v17; // [sp+19h] [bp+19h]
  __int16 v18; // [sp+1Ch] [bp+1Ch]
  char v19; // [sp+1Eh] [bp+1Eh]
  unsigned __int8 i; // [sp+1Fh] [bp+1Fh]

  v19 = 6;
  v15[0] = 255;
  v10 = 604416597;
  v3 = HIBYTE(a3) + 6;
  v18 = v3 + (unsigned __int8)a3 + 36;
  v16 = HIBYTE(v18);
  v17 = v3 + a3 + 36;
  v11 = HIBYTE(a3);
  v12 = a3;
  v13 = HIBYTE(v18);
  v14 = v17;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 7u; ++i )
    write_pic(a2, a1, *((_BYTE *)&v10 + i));
  usleep((__useconds_t)&unk_493E0);
  for ( i = 0; i <= 1u; ++i )
  {
    v4 = i;
    *((_BYTE *)v15 + v4) = read_pic(a2, a1);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep((__useconds_t)&unk_30D40);
  if ( LOBYTE(v15[0]) == 36 && HIBYTE(v15[0]) == 1 )
  {
    printf("\n--- %s ok\n\n", "save_freq_PIC16F1704");
    return 1;
  }
  else
  {
    printf(
      "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "save_freq_PIC16F1704",
      LOBYTE(v15[0]),
      HIBYTE(v15[0]));
    return 0;
  }
}
// 41830: using guessed type pthread_mutex_t i2c_mutex;

//----- (00024304) --------------------------------------------------------
int __fastcall get_PIC16F1704_freq(unsigned __int8 a1, unsigned __int8 a2, unsigned __int16 *a3)
{
  int v3; // r4
  int v9; // [sp+20h] [bp+10h]
  char v10; // [sp+24h] [bp+14h]
  char v11; // [sp+25h] [bp+15h]
  int v12; // [sp+28h] [bp+18h]
  __int16 v13; // [sp+2Ch] [bp+1Ch]
  __int16 v14; // [sp+30h] [bp+20h]
  unsigned __int16 v15; // [sp+34h] [bp+24h]
  char v16; // [sp+36h] [bp+26h]
  unsigned __int8 i; // [sp+37h] [bp+27h]

  v16 = 4;
  v14 = 10496;
  v12 = 255;
  v13 = 0;
  v9 = 621062741;
  v15 = 41;
  v10 = 0;
  v11 = 41;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(a2, a1, *((_BYTE *)&v9 + i));
  usleep((__useconds_t)&unk_493E0);
  for ( i = 0; i <= 5u; ++i )
  {
    v3 = i;
    *((_BYTE *)&v12 + v3) = read_pic(a2, a1);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep((__useconds_t)&unk_30D40);
  printf(
    "--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, read"
    "_back_data[4] = 0x%x, read_back_data[5] = 0x%x\n",
    "get_PIC16F1704_freq",
    (unsigned __int8)v12,
    BYTE1(v12),
    BYTE2(v12),
    HIBYTE(v12),
    (unsigned __int8)v13,
    HIBYTE(v13));
  if ( BYTE1(v12) == 37 && (unsigned __int8)v12 == 6 )
  {
    v15 = (unsigned __int8)v12 + BYTE1(v12) + BYTE2(v12) + HIBYTE(v12);
    if ( HIBYTE(v15) == (unsigned __int8)v13 && (unsigned __int8)v15 == HIBYTE(v13) )
    {
      *a3 = _byteswap_ushort(HIWORD(v12));
      printf("\n--- %s ok, freq = %d\n\n", "get_PIC16F1704_freq", *a3);
      return 1;
    }
    else
    {
      printf("\n--- %s failed! crc = 0x%04x\n\n", "get_PIC16F1704_freq", v15);
      return 0;
    }
  }
  else
  {
    printf("\n--- %s failed!\n\n", "get_PIC16F1704_freq");
    return 0;
  }
}
// 41830: using guessed type pthread_mutex_t i2c_mutex;

//----- (000244F0) --------------------------------------------------------
int __fastcall set_temperature_offset_value(char a1, char a2, int a3)
{
  printf("\n--- %s\n", "set_temperature_offset_value");
  write_temperature_offset_PIC16F1704(a1, a2, a3);
  return usleep(0x186A0u);
}

//----- (00024534) --------------------------------------------------------
int __fastcall write_sensor_info_into_pic(char a1, char a2)
{
  char v5[8]; // [sp+8h] [bp+8h] BYREF

  printf("\n--- %s\n", "write_sensor_info_into_pic");
  v5[0] = byte_61C3C;
  v5[1] = 0;
  v5[2] = byte_61C3D;
  v5[3] = 0;
  v5[4] = byte_61C3E;
  v5[5] = 0;
  v5[6] = byte_61C64 | 0x20;
  v5[7] = dword_61C68;
  return set_temperature_offset_value(a1, a2, (int)v5);
}
// 61C3C: using guessed type char byte_61C3C;
// 61C3D: using guessed type char byte_61C3D;
// 61C3E: using guessed type char byte_61C3E;
// 61C64: using guessed type char byte_61C64;
// 61C68: using guessed type int dword_61C68;

//----- (000245F0) --------------------------------------------------------
int __fastcall write_PIC16F1705_iic_slave(unsigned __int8 a1, unsigned __int8 a2, int a3, unsigned __int8 a4)
{
  int v4; // r4
  char v11[100]; // [sp+24h] [bp+14h] BYREF
  int v12; // [sp+88h] [bp+78h]
  unsigned __int8 v13; // [sp+8Ch] [bp+7Ch]
  __int16 v14; // [sp+90h] [bp+80h]
  unsigned __int8 v15; // [sp+94h] [bp+84h]
  unsigned __int8 i; // [sp+95h] [bp+85h]
  __int16 v17; // [sp+96h] [bp+86h]

  v15 = a4 + 4;
  v14 = 255;
  v12 = 255;
  v13 = 0;
  v17 = 0;
  memset(v11, 0, sizeof(v11));
  printf("\n--- %s\n", "write_PIC16F1705_iic_slave");
  v17 = v15 + 38;
  for ( i = 0; i < (unsigned int)a4; ++i )
    v17 += *(unsigned __int8 *)(a3 + i);
  LOBYTE(v14) = HIBYTE(v17);
  HIBYTE(v14) = v17;
  printf(
    "--- %s: crc_data[0] = 0x%x, crc_data[1] = 0x%x\n",
    "write_PIC16F1705_iic_slave",
    HIBYTE(v17),
    (unsigned __int8)v17);
  v11[0] = 85;
  v11[1] = -86;
  v11[2] = v15;
  v11[3] = 38;
  for ( i = 0; i < (unsigned int)a4; ++i )
    v11[i + 4] = *(_BYTE *)(a3 + i);
  v11[a4 + 4] = v14;
  v11[a4 + 5] = HIBYTE(v14);
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i < v15 + 2; ++i )
    write_pic(a1, a2, v11[i]);
  usleep((__useconds_t)&unk_30D40);
  for ( i = 0; i <= 4u; ++i )
  {
    v4 = i;
    *((_BYTE *)&v12 + v4) = read_pic(a1, a2);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep((__useconds_t)&unk_30D40);
  if ( BYTE1(v12) == 38 && BYTE2(v12) == 1 )
  {
    printf("\n--- %s ok\n\n", "write_PIC16F1705_iic_slave");
    return 1;
  }
  else
  {
    printf(
      "\n"
      "--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x, read_back_data[2] = 0x%02x, read_back_data["
      "3] = 0x%02x, read_back_data[4] = 0x%02x\n"
      "\n",
      "write_PIC16F1705_iic_slave",
      (unsigned __int8)v12,
      BYTE1(v12),
      BYTE2(v12),
      HIBYTE(v12),
      v13);
    return 0;
  }
}
// 41830: using guessed type pthread_mutex_t i2c_mutex;

//----- (00024840) --------------------------------------------------------
int __fastcall read_PIC16F1705_iic_slave(unsigned __int8 a1, unsigned __int8 a2, int a3, unsigned __int8 a4)
{
  int v4; // r4
  char v11[100]; // [sp+10h] [bp+10h] BYREF
  char v12[100]; // [sp+74h] [bp+74h] BYREF
  __int16 v13; // [sp+D8h] [bp+D8h]
  unsigned __int8 v14; // [sp+DCh] [bp+DCh]
  unsigned __int8 i; // [sp+DDh] [bp+DDh]
  __int16 v16; // [sp+DEh] [bp+DEh]

  v14 = a4 + 4;
  v13 = 255;
  memset(v12, 0, sizeof(v12));
  v12[0] = -1;
  v16 = 0;
  memset(v11, 0, sizeof(v11));
  printf("\n--- %s\n", "read_PIC16F1705_iic_slave");
  v16 = v14 + 38;
  for ( i = 0; i < (unsigned int)a4; ++i )
    v16 += *(unsigned __int8 *)(a3 + i);
  LOBYTE(v13) = HIBYTE(v16);
  HIBYTE(v13) = v16;
  printf(
    "--- %s: crc_data[0] = 0x%x, crc_data[1] = 0x%x\n",
    "read_PIC16F1705_iic_slave",
    HIBYTE(v16),
    (unsigned __int8)v16);
  v11[0] = 85;
  v11[1] = -86;
  v11[2] = v14;
  v11[3] = 38;
  for ( i = 0; i < (unsigned int)a4; ++i )
    v11[i + 4] = *(_BYTE *)(a3 + i);
  v11[a4 + 4] = v13;
  v11[a4 + 5] = HIBYTE(v13);
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i < v14 + 2; ++i )
    write_pic(a1, a2, v11[i]);
  usleep((__useconds_t)&unk_30D40);
  for ( i = 0; i < *(unsigned __int8 *)(a3 + 2) + 3; ++i )
  {
    v4 = i;
    v12[v4] = read_pic(a1, a2);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep((__useconds_t)&unk_30D40);
  if ( v12[1] == 38 && v12[2] == 1 )
  {
    printf("\n--- %s ok\n\n", "read_PIC16F1705_iic_slave");
    return 1;
  }
  else
  {
    for ( i = 0; i < *(unsigned __int8 *)(a3 + 2) + 3; ++i )
      printf(
        "\n--- %s failed! read_back_data[%d] = 0x%02x\n\n",
        "read_PIC16F1705_iic_slave",
        i,
        (unsigned __int8)v12[i]);
    return 0;
  }
}
// 41830: using guessed type pthread_mutex_t i2c_mutex;

//----- (00024AB0) --------------------------------------------------------
int check_chain()
{
  int axi_fpga; // [sp+0h] [bp+0h]
  char i; // [sp+7h] [bp+7h]

  printf("\n--- %s\n", "check_chain");
  dword_61B34 = 0;
  axi_fpga = read_axi_fpga(2);
  if ( axi_fpga == 1 || axi_fpga == 2 || axi_fpga == 4 || axi_fpga == 8 )
  {
    for ( i = 0; !i; i = 1 )
    {
      chain_info = 0;
      unk_61B59 = 0;
      if ( (axi_fpga & 1) != 0 )
      {
        unk_61B3C = 1;
        ++dword_61B34;
        gChain_exist = 1;
        gChain_fd = 0;
        gChain = 0;
        gI2c = 0;
        chain_info = 0;
        unk_61B59 = 0;
        printf("%s: gChain = %d, gI2c = %d\n", "check_chain", 0, 0);
      }
      else
      {
        unk_61B3C = 0;
      }
    }
    return 0;
  }
  else
  {
    printf("%s: Test zhiju only support 1 plug, but now is 0x%08x\n", "check_chain", axi_fpga);
    return -1;
  }
}
// 3106C: using guessed type char gChain;
// 31779: using guessed type char gI2c;
// 61B34: using guessed type int dword_61B34;

//----- (00024C58) --------------------------------------------------------
int get_fan_speed()
{
  return read_axi_fpga(1);
}

//----- (00024C68) --------------------------------------------------------
int __fastcall set_fan_speed(int a1)
{
  return write_axi_fpga(33, a1);
}

//----- (00024C80) --------------------------------------------------------
int __fastcall fan_control(char a1)
{
  int result; // r0

  switch ( a1 )
  {
    case 0:
      result = set_fan_speed(100);
      break;
    case 1:
      result = set_fan_speed(655450);
      break;
    case 2:
      result = set_fan_speed(1310800);
      break;
    case 3:
      result = set_fan_speed(1966150);
      break;
    case 4:
      result = set_fan_speed(2621500);
      break;
    case 5:
      result = set_fan_speed(3276850);
      break;
    case 6:
      result = set_fan_speed(3932200);
      break;
    case 7:
      result = set_fan_speed(4587550);
      break;
    case 8:
      result = set_fan_speed(5242900);
      break;
    case 9:
      result = set_fan_speed(5898250);
      break;
    default:
      result = set_fan_speed(6553600);
      break;
  }
  return result;
}

//----- (00024D44) --------------------------------------------------------
int reset_hash_board()
{
  write_axi_fpga(13, 0xFFFF);
  usleep((__useconds_t)&unk_493E0);
  write_axi_fpga(13, 0);
  return usleep((__useconds_t)&unk_493E0);
}

//----- (00024D80) --------------------------------------------------------
void __cdecl sha256_transf(sha256_ctx *ctx, const unsigned __int8 *message, unsigned int block_nb)
{
  unsigned int wv[8]; // [sp+14h] [bp+14h]
  unsigned int w[64]; // [sp+34h] [bp+34h]
  unsigned int v5; // [sp+134h] [bp+134h]
  unsigned int v6; // [sp+138h] [bp+138h]
  const unsigned __int8 *v7; // [sp+13Ch] [bp+13Ch]
  int j; // [sp+140h] [bp+140h]
  int i; // [sp+144h] [bp+144h]

  for ( i = 0; (int)block_nb > i; ++i )
  {
    v7 = &message[64 * i];
    for ( j = 0; j <= 15; ++j )
      w[j] = v7[4 * j + 3] | (v7[4 * j + 2] << 8) | (v7[4 * j + 1] << 16) | (v7[4 * j] << 24);
    for ( j = 16; j <= 63; ++j )
      w[j] = (__ROR4__(w[j - 2], 17) ^ __ROR4__(w[j - 2], 19) ^ (w[j - 2] >> 10))
           + w[j - 7]
           + ((w[j - 15] >> 3) ^ __ROR4__(w[j - 15], 7) ^ __ROR4__(w[j - 15], 18))
           + w[j - 16];
    for ( j = 0; j <= 7; ++j )
      wv[j] = *((_DWORD *)ctx + j + 34);
    for ( j = 0; j <= 63; ++j )
    {
      v6 = wv[7]
         + (__ROR4__(wv[4], 25) ^ __ROR4__(wv[4], 6) ^ __ROR4__(wv[4], 11))
         + (wv[6] & ~wv[4] ^ wv[4] & wv[5])
         + sha256_k[j]
         + w[j];
      v5 = (__ROR4__(wv[0], 2) ^ __ROR4__(wv[0], 13) ^ __ROR4__(wv[0], 22))
         + (wv[2] & wv[1] ^ wv[0] & wv[1] ^ wv[2] & wv[0]);
      wv[7] = wv[6];
      wv[6] = wv[5];
      wv[5] = wv[4];
      wv[4] = wv[3] + v6;
      wv[3] = wv[2];
      wv[2] = wv[1];
      wv[1] = wv[0];
      wv[0] = v6 + v5;
    }
    for ( j = 0; j <= 7; ++j )
      *((_DWORD *)ctx + j + 34) += wv[j];
  }
}
// 310F0: using guessed type _DWORD sha256_k[64];

//----- (000250D0) --------------------------------------------------------
void __cdecl sha256(const unsigned __int8 *message, unsigned int len, unsigned __int8 *digest)
{
  char ctx[168]; // [sp+10h] [bp+10h] BYREF

  sha256_init((sha256_ctx *)ctx);
  sha256_update((sha256_ctx *)ctx, message, len);
  sha256_final((sha256_ctx *)ctx, digest);
}

//----- (00025108) --------------------------------------------------------
void __cdecl sha256_init(sha256_ctx *ctx)
{
  int i; // [sp+Ch] [bp+Ch]

  for ( i = 0; i <= 7; ++i )
    *((_DWORD *)ctx + i + 34) = sha256_h0[i];
  *((_DWORD *)ctx + 1) = 0;
  *(_DWORD *)ctx = 0;
}
// 310D0: using guessed type _DWORD sha256_h0[8];

//----- (00025150) --------------------------------------------------------
void __cdecl sha256_update(sha256_ctx *ctx, const unsigned __int8 *message, unsigned int len)
{
  unsigned int v3; // r3
  const unsigned __int8 *v7; // [sp+14h] [bp+14h]
  unsigned int v8; // [sp+18h] [bp+18h]
  size_t n; // [sp+20h] [bp+20h]
  unsigned int na; // [sp+20h] [bp+20h]

  v3 = len;
  if ( 64 - *((_DWORD *)ctx + 1) < len )
    v3 = 64 - *((_DWORD *)ctx + 1);
  n = v3;
  memcpy((char *)ctx + *((_DWORD *)ctx + 1) + 8, message, v3);
  if ( *((_DWORD *)ctx + 1) + len > 0x3F )
  {
    v8 = (len - n) >> 6;
    v7 = &message[n];
    sha256_transf(ctx, (const unsigned __int8 *)ctx + 8, 1u);
    sha256_transf(ctx, &message[n], v8);
    na = (len - n) & 0x3F;
    memcpy((char *)ctx + 8, &v7[64 * v8], na);
    *((_DWORD *)ctx + 1) = na;
    *(_DWORD *)ctx += (v8 + 1) << 6;
  }
  else
  {
    *((_DWORD *)ctx + 1) += len;
  }
}

//----- (0002520C) --------------------------------------------------------
void __cdecl sha256_final(sha256_ctx *ctx, unsigned __int8 *digest)
{
  int v2; // r3
  int v5; // [sp+8h] [bp+8h]
  int v6; // [sp+Ch] [bp+Ch]
  unsigned int v7; // [sp+10h] [bp+10h]
  int i; // [sp+14h] [bp+14h]

  if ( (*((_DWORD *)ctx + 1) & 0x3Fu) <= 0x37 )
    v2 = 1;
  else
    v2 = 2;
  v7 = v2;
  v6 = 8 * (*(_DWORD *)ctx + *((_DWORD *)ctx + 1));
  v5 = v2 << 6;
  memset((char *)ctx + *((_DWORD *)ctx + 1) + 8, 0, (v2 << 6) - *((_DWORD *)ctx + 1));
  *((_BYTE *)ctx + *((_DWORD *)ctx + 1) + 8) = 0x80;
  *((_BYTE *)ctx + v5 + 7) = v6;
  *((_BYTE *)ctx + v5 + 6) = BYTE1(v6);
  *((_BYTE *)ctx + v5 + 5) = BYTE2(v6);
  *((_BYTE *)ctx + v5 + 4) = HIBYTE(v6);
  sha256_transf(ctx, (const unsigned __int8 *)ctx + 8, v7);
  for ( i = 0; i <= 7; ++i )
  {
    digest[4 * i + 3] = *((_DWORD *)ctx + i + 34);
    digest[4 * i + 2] = BYTE1(*((_DWORD *)ctx + i + 34));
    digest[4 * i + 1] = BYTE2(*((_DWORD *)ctx + i + 34));
    digest[4 * i] = HIBYTE(*((_DWORD *)ctx + i + 34));
  }
}

//----- (00025330) --------------------------------------------------------
void __cdecl sha2_starts(sha2_context *ctx)
{
  *(_DWORD *)ctx = 0;
  *((_DWORD *)ctx + 1) = 0;
  *((_DWORD *)ctx + 2) = 1779033703;
  *((_DWORD *)ctx + 3) = -1150833019;
  *((_DWORD *)ctx + 4) = 1013904242;
  *((_DWORD *)ctx + 5) = -1521486534;
  *((_DWORD *)ctx + 6) = 1359893119;
  *((_DWORD *)ctx + 7) = -1694144372;
  *((_DWORD *)ctx + 8) = 528734635;
  *((_DWORD *)ctx + 9) = 1541459225;
}

//----- (000253B0) --------------------------------------------------------
void __cdecl sha2_process(sha2_context *ctx, const unsigned __int8 *data)
{
  unsigned int W; // [sp+8h] [bp+8h]
  unsigned int W_4; // [sp+Ch] [bp+Ch]
  unsigned int W_8; // [sp+10h] [bp+10h]
  unsigned int W_12; // [sp+14h] [bp+14h]
  unsigned int W_16; // [sp+18h] [bp+18h]
  unsigned int W_20; // [sp+1Ch] [bp+1Ch]
  unsigned int W_24; // [sp+20h] [bp+20h]
  unsigned int W_28; // [sp+24h] [bp+24h]
  unsigned int W_32; // [sp+28h] [bp+28h]
  unsigned int W_36; // [sp+2Ch] [bp+2Ch]
  unsigned int W_40; // [sp+30h] [bp+30h]
  unsigned int W_44; // [sp+34h] [bp+34h]
  unsigned int W_48; // [sp+38h] [bp+38h]
  unsigned int W_52; // [sp+3Ch] [bp+3Ch]
  unsigned int W_56; // [sp+40h] [bp+40h]
  unsigned int W_60; // [sp+44h] [bp+44h]
  unsigned int W_64; // [sp+48h] [bp+48h]
  unsigned int W_68; // [sp+4Ch] [bp+4Ch]
  unsigned int W_72; // [sp+50h] [bp+50h]
  unsigned int W_76; // [sp+54h] [bp+54h]
  unsigned int W_80; // [sp+58h] [bp+58h]
  unsigned int W_84; // [sp+5Ch] [bp+5Ch]
  unsigned int W_88; // [sp+60h] [bp+60h]
  unsigned int W_92; // [sp+64h] [bp+64h]
  unsigned int W_96; // [sp+68h] [bp+68h]
  unsigned int W_100; // [sp+6Ch] [bp+6Ch]
  unsigned int W_104; // [sp+70h] [bp+70h]
  unsigned int W_108; // [sp+74h] [bp+74h]
  unsigned int W_112; // [sp+78h] [bp+78h]
  unsigned int W_116; // [sp+7Ch] [bp+7Ch]
  unsigned int W_120; // [sp+80h] [bp+80h]
  unsigned int W_124; // [sp+84h] [bp+84h]
  unsigned int W_128; // [sp+88h] [bp+88h]
  unsigned int W_132; // [sp+8Ch] [bp+8Ch]
  unsigned int W_136; // [sp+90h] [bp+90h]
  unsigned int W_140; // [sp+94h] [bp+94h]
  unsigned int W_144; // [sp+98h] [bp+98h]
  unsigned int W_148; // [sp+9Ch] [bp+9Ch]
  unsigned int W_152; // [sp+A0h] [bp+A0h]
  unsigned int W_156; // [sp+A4h] [bp+A4h]
  unsigned int W_160; // [sp+A8h] [bp+A8h]
  unsigned int W_164; // [sp+ACh] [bp+ACh]
  unsigned int W_168; // [sp+B0h] [bp+B0h]
  unsigned int W_172; // [sp+B4h] [bp+B4h]
  unsigned int W_176; // [sp+B8h] [bp+B8h]
  unsigned int W_180; // [sp+BCh] [bp+BCh]
  unsigned int W_184; // [sp+C0h] [bp+C0h]
  unsigned int W_188; // [sp+C4h] [bp+C4h]
  unsigned int W_192; // [sp+C8h] [bp+C8h]
  unsigned int W_196; // [sp+CCh] [bp+CCh]
  unsigned int W_200; // [sp+D0h] [bp+D0h]
  unsigned int W_204; // [sp+D4h] [bp+D4h]
  unsigned int W_208; // [sp+D8h] [bp+D8h]
  unsigned int W_212; // [sp+DCh] [bp+DCh]
  unsigned int W_216; // [sp+E0h] [bp+E0h]
  unsigned int W_220; // [sp+E4h] [bp+E4h]
  unsigned int W_224; // [sp+E8h] [bp+E8h]
  unsigned int W_228; // [sp+ECh] [bp+ECh]
  unsigned int W_232; // [sp+F0h] [bp+F0h]
  unsigned int W_236; // [sp+F4h] [bp+F4h]
  unsigned int W_240; // [sp+F8h] [bp+F8h]
  unsigned int W_244; // [sp+FCh] [bp+FCh]
  int v64; // [sp+10Ch] [bp+10Ch]
  int v65; // [sp+10Ch] [bp+10Ch]
  int v66; // [sp+10Ch] [bp+10Ch]
  int v67; // [sp+10Ch] [bp+10Ch]
  int v68; // [sp+10Ch] [bp+10Ch]
  int v69; // [sp+10Ch] [bp+10Ch]
  int v70; // [sp+10Ch] [bp+10Ch]
  int v71; // [sp+10Ch] [bp+10Ch]
  int v72; // [sp+10Ch] [bp+10Ch]
  int v73; // [sp+10Ch] [bp+10Ch]
  int v74; // [sp+10Ch] [bp+10Ch]
  int v75; // [sp+10Ch] [bp+10Ch]
  int v76; // [sp+10Ch] [bp+10Ch]
  int v77; // [sp+10Ch] [bp+10Ch]
  int v78; // [sp+10Ch] [bp+10Ch]
  int v79; // [sp+10Ch] [bp+10Ch]
  int v80; // [sp+10Ch] [bp+10Ch]
  int v81; // [sp+10Ch] [bp+10Ch]
  int v82; // [sp+10Ch] [bp+10Ch]
  int v83; // [sp+10Ch] [bp+10Ch]
  int v84; // [sp+10Ch] [bp+10Ch]
  int v85; // [sp+10Ch] [bp+10Ch]
  int v86; // [sp+10Ch] [bp+10Ch]
  int v87; // [sp+10Ch] [bp+10Ch]
  int v88; // [sp+10Ch] [bp+10Ch]
  int v89; // [sp+10Ch] [bp+10Ch]
  int v90; // [sp+10Ch] [bp+10Ch]
  int v91; // [sp+10Ch] [bp+10Ch]
  int v92; // [sp+10Ch] [bp+10Ch]
  int v93; // [sp+10Ch] [bp+10Ch]
  int v94; // [sp+10Ch] [bp+10Ch]
  int v95; // [sp+10Ch] [bp+10Ch]
  int v96; // [sp+10Ch] [bp+10Ch]
  int v97; // [sp+10Ch] [bp+10Ch]
  int v98; // [sp+10Ch] [bp+10Ch]
  int v99; // [sp+10Ch] [bp+10Ch]
  int v100; // [sp+10Ch] [bp+10Ch]
  int v101; // [sp+10Ch] [bp+10Ch]
  int v102; // [sp+10Ch] [bp+10Ch]
  int v103; // [sp+10Ch] [bp+10Ch]
  int v104; // [sp+10Ch] [bp+10Ch]
  int v105; // [sp+10Ch] [bp+10Ch]
  int v106; // [sp+10Ch] [bp+10Ch]
  int v107; // [sp+10Ch] [bp+10Ch]
  int v108; // [sp+10Ch] [bp+10Ch]
  int v109; // [sp+10Ch] [bp+10Ch]
  int v110; // [sp+10Ch] [bp+10Ch]
  int v111; // [sp+10Ch] [bp+10Ch]
  int v112; // [sp+10Ch] [bp+10Ch]
  int v113; // [sp+10Ch] [bp+10Ch]
  int v114; // [sp+10Ch] [bp+10Ch]
  int v115; // [sp+10Ch] [bp+10Ch]
  int v116; // [sp+10Ch] [bp+10Ch]
  int v117; // [sp+10Ch] [bp+10Ch]
  int v118; // [sp+10Ch] [bp+10Ch]
  int v119; // [sp+10Ch] [bp+10Ch]
  int v120; // [sp+10Ch] [bp+10Ch]
  int v121; // [sp+10Ch] [bp+10Ch]
  int v122; // [sp+10Ch] [bp+10Ch]
  int v123; // [sp+10Ch] [bp+10Ch]
  int v124; // [sp+10Ch] [bp+10Ch]
  int v125; // [sp+10Ch] [bp+10Ch]
  int v126; // [sp+10Ch] [bp+10Ch]
  int v127; // [sp+10Ch] [bp+10Ch]
  int v128; // [sp+110h] [bp+110h]
  int v129; // [sp+110h] [bp+110h]
  int v130; // [sp+110h] [bp+110h]
  int v131; // [sp+110h] [bp+110h]
  int v132; // [sp+110h] [bp+110h]
  int v133; // [sp+110h] [bp+110h]
  int v134; // [sp+110h] [bp+110h]
  int v135; // [sp+110h] [bp+110h]
  int v136; // [sp+110h] [bp+110h]
  int v137; // [sp+110h] [bp+110h]
  int v138; // [sp+110h] [bp+110h]
  int v139; // [sp+110h] [bp+110h]
  int v140; // [sp+110h] [bp+110h]
  int v141; // [sp+110h] [bp+110h]
  int v142; // [sp+110h] [bp+110h]
  int v143; // [sp+110h] [bp+110h]
  int v144; // [sp+114h] [bp+114h]
  int v145; // [sp+114h] [bp+114h]
  int v146; // [sp+114h] [bp+114h]
  int v147; // [sp+114h] [bp+114h]
  int v148; // [sp+114h] [bp+114h]
  int v149; // [sp+114h] [bp+114h]
  int v150; // [sp+114h] [bp+114h]
  int v151; // [sp+114h] [bp+114h]
  int v152; // [sp+114h] [bp+114h]
  int v153; // [sp+114h] [bp+114h]
  int v154; // [sp+114h] [bp+114h]
  int v155; // [sp+114h] [bp+114h]
  int v156; // [sp+114h] [bp+114h]
  int v157; // [sp+114h] [bp+114h]
  int v158; // [sp+114h] [bp+114h]
  int v159; // [sp+114h] [bp+114h]
  int v160; // [sp+114h] [bp+114h]
  int v161; // [sp+118h] [bp+118h]
  int v162; // [sp+118h] [bp+118h]
  int v163; // [sp+118h] [bp+118h]
  int v164; // [sp+118h] [bp+118h]
  int v165; // [sp+118h] [bp+118h]
  int v166; // [sp+118h] [bp+118h]
  int v167; // [sp+118h] [bp+118h]
  int v168; // [sp+118h] [bp+118h]
  int v169; // [sp+118h] [bp+118h]
  int v170; // [sp+118h] [bp+118h]
  int v171; // [sp+118h] [bp+118h]
  int v172; // [sp+118h] [bp+118h]
  int v173; // [sp+118h] [bp+118h]
  int v174; // [sp+118h] [bp+118h]
  int v175; // [sp+118h] [bp+118h]
  int v176; // [sp+118h] [bp+118h]
  int v177; // [sp+118h] [bp+118h]
  int v178; // [sp+11Ch] [bp+11Ch]
  int v179; // [sp+11Ch] [bp+11Ch]
  int v180; // [sp+11Ch] [bp+11Ch]
  int v181; // [sp+11Ch] [bp+11Ch]
  int v182; // [sp+11Ch] [bp+11Ch]
  int v183; // [sp+11Ch] [bp+11Ch]
  int v184; // [sp+11Ch] [bp+11Ch]
  int v185; // [sp+11Ch] [bp+11Ch]
  int v186; // [sp+11Ch] [bp+11Ch]
  int v187; // [sp+11Ch] [bp+11Ch]
  int v188; // [sp+11Ch] [bp+11Ch]
  int v189; // [sp+11Ch] [bp+11Ch]
  int v190; // [sp+11Ch] [bp+11Ch]
  int v191; // [sp+11Ch] [bp+11Ch]
  int v192; // [sp+11Ch] [bp+11Ch]
  int v193; // [sp+11Ch] [bp+11Ch]
  int v194; // [sp+120h] [bp+120h]
  int v195; // [sp+120h] [bp+120h]
  int v196; // [sp+120h] [bp+120h]
  int v197; // [sp+120h] [bp+120h]
  int v198; // [sp+120h] [bp+120h]
  int v199; // [sp+120h] [bp+120h]
  int v200; // [sp+120h] [bp+120h]
  int v201; // [sp+120h] [bp+120h]
  int v202; // [sp+120h] [bp+120h]
  int v203; // [sp+120h] [bp+120h]
  int v204; // [sp+120h] [bp+120h]
  int v205; // [sp+120h] [bp+120h]
  int v206; // [sp+120h] [bp+120h]
  int v207; // [sp+120h] [bp+120h]
  int v208; // [sp+120h] [bp+120h]
  int v209; // [sp+120h] [bp+120h]
  int v210; // [sp+124h] [bp+124h]
  int v211; // [sp+124h] [bp+124h]
  int v212; // [sp+124h] [bp+124h]
  int v213; // [sp+124h] [bp+124h]
  int v214; // [sp+124h] [bp+124h]
  int v215; // [sp+124h] [bp+124h]
  int v216; // [sp+124h] [bp+124h]
  int v217; // [sp+124h] [bp+124h]
  int v218; // [sp+124h] [bp+124h]
  int v219; // [sp+124h] [bp+124h]
  int v220; // [sp+124h] [bp+124h]
  int v221; // [sp+124h] [bp+124h]
  int v222; // [sp+124h] [bp+124h]
  int v223; // [sp+124h] [bp+124h]
  int v224; // [sp+124h] [bp+124h]
  int v225; // [sp+124h] [bp+124h]
  int v226; // [sp+124h] [bp+124h]
  int v227; // [sp+128h] [bp+128h]
  int v228; // [sp+128h] [bp+128h]
  int v229; // [sp+128h] [bp+128h]
  int v230; // [sp+128h] [bp+128h]
  int v231; // [sp+128h] [bp+128h]
  int v232; // [sp+128h] [bp+128h]
  int v233; // [sp+128h] [bp+128h]
  int v234; // [sp+128h] [bp+128h]
  int v235; // [sp+128h] [bp+128h]
  int v236; // [sp+128h] [bp+128h]
  int v237; // [sp+128h] [bp+128h]
  int v238; // [sp+128h] [bp+128h]
  int v239; // [sp+128h] [bp+128h]
  int v240; // [sp+128h] [bp+128h]
  int v241; // [sp+128h] [bp+128h]
  int v242; // [sp+128h] [bp+128h]
  int v243; // [sp+128h] [bp+128h]
  int v244; // [sp+12Ch] [bp+12Ch]
  int v245; // [sp+12Ch] [bp+12Ch]
  int v246; // [sp+12Ch] [bp+12Ch]
  int v247; // [sp+12Ch] [bp+12Ch]
  int v248; // [sp+12Ch] [bp+12Ch]
  int v249; // [sp+12Ch] [bp+12Ch]
  int v250; // [sp+12Ch] [bp+12Ch]
  int v251; // [sp+12Ch] [bp+12Ch]
  int v252; // [sp+12Ch] [bp+12Ch]
  int v253; // [sp+12Ch] [bp+12Ch]
  int v254; // [sp+12Ch] [bp+12Ch]
  int v255; // [sp+12Ch] [bp+12Ch]
  int v256; // [sp+12Ch] [bp+12Ch]
  int v257; // [sp+12Ch] [bp+12Ch]
  int v258; // [sp+12Ch] [bp+12Ch]
  int v259; // [sp+12Ch] [bp+12Ch]

  W = _byteswap_ulong(*(_DWORD *)data);
  W_4 = _byteswap_ulong(*((_DWORD *)data + 1));
  W_8 = _byteswap_ulong(*((_DWORD *)data + 2));
  W_12 = _byteswap_ulong(*((_DWORD *)data + 3));
  W_16 = _byteswap_ulong(*((_DWORD *)data + 4));
  W_20 = _byteswap_ulong(*((_DWORD *)data + 5));
  W_24 = _byteswap_ulong(*((_DWORD *)data + 6));
  W_28 = _byteswap_ulong(*((_DWORD *)data + 7));
  W_32 = _byteswap_ulong(*((_DWORD *)data + 8));
  W_36 = _byteswap_ulong(*((_DWORD *)data + 9));
  W_40 = _byteswap_ulong(*((_DWORD *)data + 10));
  W_44 = _byteswap_ulong(*((_DWORD *)data + 11));
  W_48 = _byteswap_ulong(*((_DWORD *)data + 12));
  W_52 = _byteswap_ulong(*((_DWORD *)data + 13));
  W_56 = _byteswap_ulong(*((_DWORD *)data + 14));
  W_60 = _byteswap_ulong(*((_DWORD *)data + 15));
  v244 = *((_DWORD *)ctx + 2);
  v227 = *((_DWORD *)ctx + 3);
  v210 = *((_DWORD *)ctx + 4);
  v178 = *((_DWORD *)ctx + 6);
  v161 = *((_DWORD *)ctx + 7);
  v144 = *((_DWORD *)ctx + 8);
  v64 = (__ROR4__(v178, 6) ^ __ROR4__(v178, 11) ^ __ROR4__(v178, 25))
      + *((_DWORD *)ctx + 9)
      + (v144 ^ (v161 ^ v144) & v178)
      + W
      + 1116352408;
  v194 = *((_DWORD *)ctx + 5) + v64;
  v128 = v64 + (__ROR4__(v244, 2) ^ __ROR4__(v244, 13) ^ __ROR4__(v244, 22)) + (v210 & (v244 | v227) | v244 & v227);
  v65 = (__ROR4__(v194, 6) ^ __ROR4__(v194, 11) ^ __ROR4__(v194, 25))
      + v144
      + (v161 ^ (v178 ^ v161) & v194)
      + W_4
      + 1899447441;
  v211 = v210 + v65;
  v145 = v65 + (__ROR4__(v128, 2) ^ __ROR4__(v128, 13) ^ __ROR4__(v128, 22)) + (v227 & (v128 | v244) | v128 & v244);
  v66 = (__ROR4__(v211, 6) ^ __ROR4__(v211, 11) ^ __ROR4__(v211, 25))
      + v161
      + (v178 ^ (v194 ^ v178) & v211)
      + W_8
      - 1245643825;
  v228 = v227 + v66;
  v162 = v66 + (__ROR4__(v145, 2) ^ __ROR4__(v145, 13) ^ __ROR4__(v145, 22)) + (v244 & (v145 | v128) | v145 & v128);
  v67 = (__ROR4__(v228, 6) ^ __ROR4__(v228, 11) ^ __ROR4__(v228, 25))
      + v178
      + (v194 ^ (v211 ^ v194) & v228)
      + W_12
      - 373957723;
  v245 = v244 + v67;
  v179 = v67 + (__ROR4__(v162, 2) ^ __ROR4__(v162, 13) ^ __ROR4__(v162, 22)) + (v128 & (v162 | v145) | v162 & v145);
  v68 = (__ROR4__(v245, 6) ^ __ROR4__(v245, 11) ^ __ROR4__(v245, 25))
      + v194
      + (v211 ^ (v228 ^ v211) & v245)
      + W_16
      + 961987163;
  v129 = v128 + v68;
  v195 = v68 + (__ROR4__(v179, 2) ^ __ROR4__(v179, 13) ^ __ROR4__(v179, 22)) + (v145 & (v179 | v162) | v179 & v162);
  v69 = (__ROR4__(v129, 6) ^ __ROR4__(v129, 11) ^ __ROR4__(v129, 25))
      + v211
      + (v228 ^ (v245 ^ v228) & v129)
      + W_20
      + 1508970993;
  v146 = v145 + v69;
  v212 = v69 + (__ROR4__(v195, 2) ^ __ROR4__(v195, 13) ^ __ROR4__(v195, 22)) + (v162 & (v195 | v179) | v195 & v179);
  v70 = (__ROR4__(v146, 6) ^ __ROR4__(v146, 11) ^ __ROR4__(v146, 25))
      + v228
      + (v245 ^ (v129 ^ v245) & v146)
      + W_24
      - 1841331548;
  v163 = v162 + v70;
  v229 = v70 + (__ROR4__(v212, 2) ^ __ROR4__(v212, 13) ^ __ROR4__(v212, 22)) + (v179 & (v212 | v195) | v212 & v195);
  v71 = (__ROR4__(v163, 6) ^ __ROR4__(v163, 11) ^ __ROR4__(v163, 25))
      + v245
      + (v129 ^ (v146 ^ v129) & v163)
      + W_28
      - 1424204075;
  v180 = v179 + v71;
  v246 = v71 + (__ROR4__(v229, 2) ^ __ROR4__(v229, 13) ^ __ROR4__(v229, 22)) + (v195 & (v229 | v212) | v229 & v212);
  v72 = (__ROR4__(v180, 6) ^ __ROR4__(v180, 11) ^ __ROR4__(v180, 25))
      + v129
      + (v146 ^ (v163 ^ v146) & v180)
      + W_32
      - 670586216;
  v196 = v195 + v72;
  v130 = v72 + (__ROR4__(v246, 2) ^ __ROR4__(v246, 13) ^ __ROR4__(v246, 22)) + (v212 & (v246 | v229) | v246 & v229);
  v73 = (__ROR4__(v196, 6) ^ __ROR4__(v196, 11) ^ __ROR4__(v196, 25))
      + v146
      + (v163 ^ (v180 ^ v163) & v196)
      + W_36
      + 310598401;
  v213 = v212 + v73;
  v147 = v73 + (__ROR4__(v130, 2) ^ __ROR4__(v130, 13) ^ __ROR4__(v130, 22)) + (v229 & (v130 | v246) | v130 & v246);
  v74 = (__ROR4__(v213, 6) ^ __ROR4__(v213, 11) ^ __ROR4__(v213, 25))
      + v163
      + (v180 ^ (v196 ^ v180) & v213)
      + W_40
      + 607225278;
  v230 = v229 + v74;
  v164 = v74 + (__ROR4__(v147, 2) ^ __ROR4__(v147, 13) ^ __ROR4__(v147, 22)) + (v246 & (v147 | v130) | v147 & v130);
  v75 = (__ROR4__(v230, 6) ^ __ROR4__(v230, 11) ^ __ROR4__(v230, 25))
      + v180
      + (v196 ^ (v213 ^ v196) & v230)
      + W_44
      + 1426881987;
  v247 = v246 + v75;
  v181 = v75 + (__ROR4__(v164, 2) ^ __ROR4__(v164, 13) ^ __ROR4__(v164, 22)) + (v130 & (v164 | v147) | v164 & v147);
  v76 = (__ROR4__(v247, 6) ^ __ROR4__(v247, 11) ^ __ROR4__(v247, 25))
      + v196
      + (v213 ^ (v230 ^ v213) & v247)
      + W_48
      + 1925078388;
  v131 = v130 + v76;
  v197 = v76 + (__ROR4__(v181, 2) ^ __ROR4__(v181, 13) ^ __ROR4__(v181, 22)) + (v147 & (v181 | v164) | v181 & v164);
  v77 = (__ROR4__(v131, 6) ^ __ROR4__(v131, 11) ^ __ROR4__(v131, 25))
      + v213
      + (v230 ^ (v247 ^ v230) & v131)
      + W_52
      - 2132889090;
  v148 = v147 + v77;
  v214 = v77 + (__ROR4__(v197, 2) ^ __ROR4__(v197, 13) ^ __ROR4__(v197, 22)) + (v164 & (v197 | v181) | v197 & v181);
  v78 = (__ROR4__(v148, 6) ^ __ROR4__(v148, 11) ^ __ROR4__(v148, 25))
      + v230
      + (v247 ^ (v131 ^ v247) & v148)
      + W_56
      - 1680079193;
  v165 = v164 + v78;
  v231 = v78 + (__ROR4__(v214, 2) ^ __ROR4__(v214, 13) ^ __ROR4__(v214, 22)) + (v181 & (v214 | v197) | v214 & v197);
  v79 = (__ROR4__(v165, 6) ^ __ROR4__(v165, 11) ^ __ROR4__(v165, 25))
      + v247
      + (v131 ^ (v148 ^ v131) & v165)
      + W_60
      - 1046744716;
  v182 = v181 + v79;
  v248 = v79 + (__ROR4__(v231, 2) ^ __ROR4__(v231, 13) ^ __ROR4__(v231, 22)) + (v197 & (v231 | v214) | v231 & v214);
  W_64 = (__ROR4__(W_56, 17) ^ __ROR4__(W_56, 19) ^ (W_56 >> 10))
       + W_36
       + ((W_4 >> 3) ^ __ROR4__(W_4, 7) ^ __ROR4__(W_4, 18))
       + W;
  v80 = (__ROR4__(v182, 6) ^ __ROR4__(v182, 11) ^ __ROR4__(v182, 25))
      + v131
      + (v148 ^ (v165 ^ v148) & v182)
      + W_64
      - 459576895;
  v198 = v197 + v80;
  v132 = v80 + (__ROR4__(v248, 2) ^ __ROR4__(v248, 13) ^ __ROR4__(v248, 22)) + (v214 & (v248 | v231) | v248 & v231);
  W_68 = (__ROR4__(W_60, 17) ^ __ROR4__(W_60, 19) ^ (W_60 >> 10))
       + W_40
       + ((W_8 >> 3) ^ __ROR4__(W_8, 7) ^ __ROR4__(W_8, 18))
       + W_4;
  v81 = (__ROR4__(v198, 6) ^ __ROR4__(v198, 11) ^ __ROR4__(v198, 25))
      + v148
      + (v165 ^ (v182 ^ v165) & v198)
      + W_68
      - 272742522;
  v215 = v214 + v81;
  v149 = v81 + (__ROR4__(v132, 2) ^ __ROR4__(v132, 13) ^ __ROR4__(v132, 22)) + (v231 & (v132 | v248) | v132 & v248);
  W_72 = (__ROR4__(W_64, 17) ^ __ROR4__(W_64, 19) ^ (W_64 >> 10))
       + W_44
       + ((W_12 >> 3) ^ __ROR4__(W_12, 7) ^ __ROR4__(W_12, 18))
       + W_8;
  v82 = (__ROR4__(v215, 6) ^ __ROR4__(v215, 11) ^ __ROR4__(v215, 25))
      + v165
      + (v182 ^ (v198 ^ v182) & v215)
      + W_72
      + 264347078;
  v232 = v231 + v82;
  v166 = v82 + (__ROR4__(v149, 2) ^ __ROR4__(v149, 13) ^ __ROR4__(v149, 22)) + (v248 & (v149 | v132) | v149 & v132);
  W_76 = (__ROR4__(W_68, 17) ^ __ROR4__(W_68, 19) ^ (W_68 >> 10))
       + W_48
       + ((W_16 >> 3) ^ __ROR4__(W_16, 7) ^ __ROR4__(W_16, 18))
       + W_12;
  v83 = (__ROR4__(v232, 6) ^ __ROR4__(v232, 11) ^ __ROR4__(v232, 25))
      + v182
      + (v198 ^ (v215 ^ v198) & v232)
      + W_76
      + 604807628;
  v249 = v248 + v83;
  v183 = v83 + (__ROR4__(v166, 2) ^ __ROR4__(v166, 13) ^ __ROR4__(v166, 22)) + (v132 & (v166 | v149) | v166 & v149);
  W_80 = (__ROR4__(W_72, 17) ^ __ROR4__(W_72, 19) ^ (W_72 >> 10))
       + W_52
       + ((W_20 >> 3) ^ __ROR4__(W_20, 7) ^ __ROR4__(W_20, 18))
       + W_16;
  v84 = (__ROR4__(v249, 6) ^ __ROR4__(v249, 11) ^ __ROR4__(v249, 25))
      + v198
      + (v215 ^ (v232 ^ v215) & v249)
      + W_80
      + 770255983;
  v133 = v132 + v84;
  v199 = v84 + (__ROR4__(v183, 2) ^ __ROR4__(v183, 13) ^ __ROR4__(v183, 22)) + (v149 & (v183 | v166) | v183 & v166);
  W_84 = (__ROR4__(W_76, 17) ^ __ROR4__(W_76, 19) ^ (W_76 >> 10))
       + W_56
       + ((W_24 >> 3) ^ __ROR4__(W_24, 7) ^ __ROR4__(W_24, 18))
       + W_20;
  v85 = (__ROR4__(v133, 6) ^ __ROR4__(v133, 11) ^ __ROR4__(v133, 25))
      + v215
      + (v232 ^ (v249 ^ v232) & v133)
      + W_84
      + 1249150122;
  v150 = v149 + v85;
  v216 = v85 + (__ROR4__(v199, 2) ^ __ROR4__(v199, 13) ^ __ROR4__(v199, 22)) + (v166 & (v199 | v183) | v199 & v183);
  W_88 = (__ROR4__(W_80, 17) ^ __ROR4__(W_80, 19) ^ (W_80 >> 10))
       + W_60
       + ((W_28 >> 3) ^ __ROR4__(W_28, 7) ^ __ROR4__(W_28, 18))
       + W_24;
  v86 = (__ROR4__(v150, 6) ^ __ROR4__(v150, 11) ^ __ROR4__(v150, 25))
      + v232
      + (v249 ^ (v133 ^ v249) & v150)
      + W_88
      + 1555081692;
  v167 = v166 + v86;
  v233 = v86 + (__ROR4__(v216, 2) ^ __ROR4__(v216, 13) ^ __ROR4__(v216, 22)) + (v183 & (v216 | v199) | v216 & v199);
  W_92 = (__ROR4__(W_84, 17) ^ __ROR4__(W_84, 19) ^ (W_84 >> 10))
       + W_64
       + ((W_32 >> 3) ^ __ROR4__(W_32, 7) ^ __ROR4__(W_32, 18))
       + W_28;
  v87 = (__ROR4__(v167, 6) ^ __ROR4__(v167, 11) ^ __ROR4__(v167, 25))
      + v249
      + (v133 ^ (v150 ^ v133) & v167)
      + W_92
      + 1996064986;
  v184 = v183 + v87;
  v250 = v87 + (__ROR4__(v233, 2) ^ __ROR4__(v233, 13) ^ __ROR4__(v233, 22)) + (v199 & (v233 | v216) | v233 & v216);
  W_96 = (__ROR4__(W_88, 17) ^ __ROR4__(W_88, 19) ^ (W_88 >> 10))
       + W_68
       + ((W_36 >> 3) ^ __ROR4__(W_36, 7) ^ __ROR4__(W_36, 18))
       + W_32;
  v88 = (__ROR4__(v184, 6) ^ __ROR4__(v184, 11) ^ __ROR4__(v184, 25))
      + v133
      + (v150 ^ (v167 ^ v150) & v184)
      + W_96
      - 1740746414;
  v200 = v199 + v88;
  v134 = v88 + (__ROR4__(v250, 2) ^ __ROR4__(v250, 13) ^ __ROR4__(v250, 22)) + (v216 & (v250 | v233) | v250 & v233);
  W_100 = (__ROR4__(W_92, 17) ^ __ROR4__(W_92, 19) ^ (W_92 >> 10))
        + W_72
        + ((W_40 >> 3) ^ __ROR4__(W_40, 7) ^ __ROR4__(W_40, 18))
        + W_36;
  v89 = (__ROR4__(v200, 6) ^ __ROR4__(v200, 11) ^ __ROR4__(v200, 25))
      + v150
      + (v167 ^ (v184 ^ v167) & v200)
      + W_100
      - 1473132947;
  v217 = v216 + v89;
  v151 = v89 + (__ROR4__(v134, 2) ^ __ROR4__(v134, 13) ^ __ROR4__(v134, 22)) + (v233 & (v134 | v250) | v134 & v250);
  W_104 = (__ROR4__(W_96, 17) ^ __ROR4__(W_96, 19) ^ (W_96 >> 10))
        + W_76
        + ((W_44 >> 3) ^ __ROR4__(W_44, 7) ^ __ROR4__(W_44, 18))
        + W_40;
  v90 = (__ROR4__(v217, 6) ^ __ROR4__(v217, 11) ^ __ROR4__(v217, 25))
      + v167
      + (v184 ^ (v200 ^ v184) & v217)
      + W_104
      - 1341970488;
  v234 = v233 + v90;
  v168 = v90 + (__ROR4__(v151, 2) ^ __ROR4__(v151, 13) ^ __ROR4__(v151, 22)) + (v250 & (v151 | v134) | v151 & v134);
  W_108 = (__ROR4__(W_100, 17) ^ __ROR4__(W_100, 19) ^ (W_100 >> 10))
        + W_80
        + ((W_48 >> 3) ^ __ROR4__(W_48, 7) ^ __ROR4__(W_48, 18))
        + W_44;
  v91 = (__ROR4__(v234, 6) ^ __ROR4__(v234, 11) ^ __ROR4__(v234, 25))
      + v184
      + (v200 ^ (v217 ^ v200) & v234)
      + W_108
      - 1084653625;
  v251 = v250 + v91;
  v185 = v91 + (__ROR4__(v168, 2) ^ __ROR4__(v168, 13) ^ __ROR4__(v168, 22)) + (v134 & (v168 | v151) | v168 & v151);
  W_112 = (__ROR4__(W_104, 17) ^ __ROR4__(W_104, 19) ^ (W_104 >> 10))
        + W_84
        + ((W_52 >> 3) ^ __ROR4__(W_52, 7) ^ __ROR4__(W_52, 18))
        + W_48;
  v92 = (__ROR4__(v251, 6) ^ __ROR4__(v251, 11) ^ __ROR4__(v251, 25))
      + v200
      + (v217 ^ (v234 ^ v217) & v251)
      + W_112
      - 958395405;
  v135 = v134 + v92;
  v201 = v92 + (__ROR4__(v185, 2) ^ __ROR4__(v185, 13) ^ __ROR4__(v185, 22)) + (v151 & (v185 | v168) | v185 & v168);
  W_116 = (__ROR4__(W_108, 17) ^ __ROR4__(W_108, 19) ^ (W_108 >> 10))
        + W_88
        + ((W_56 >> 3) ^ __ROR4__(W_56, 7) ^ __ROR4__(W_56, 18))
        + W_52;
  v93 = (__ROR4__(v135, 6) ^ __ROR4__(v135, 11) ^ __ROR4__(v135, 25))
      + v217
      + (v234 ^ (v251 ^ v234) & v135)
      + W_116
      - 710438585;
  v152 = v151 + v93;
  v218 = v93 + (__ROR4__(v201, 2) ^ __ROR4__(v201, 13) ^ __ROR4__(v201, 22)) + (v168 & (v201 | v185) | v201 & v185);
  W_120 = (__ROR4__(W_112, 17) ^ __ROR4__(W_112, 19) ^ (W_112 >> 10))
        + W_92
        + ((W_60 >> 3) ^ __ROR4__(W_60, 7) ^ __ROR4__(W_60, 18))
        + W_56;
  v94 = (__ROR4__(v152, 6) ^ __ROR4__(v152, 11) ^ __ROR4__(v152, 25))
      + v234
      + (v251 ^ (v135 ^ v251) & v152)
      + W_120
      + 113926993;
  v169 = v168 + v94;
  v235 = v94 + (__ROR4__(v218, 2) ^ __ROR4__(v218, 13) ^ __ROR4__(v218, 22)) + (v185 & (v218 | v201) | v218 & v201);
  W_124 = (__ROR4__(W_116, 17) ^ __ROR4__(W_116, 19) ^ (W_116 >> 10))
        + W_96
        + ((W_64 >> 3) ^ __ROR4__(W_64, 7) ^ __ROR4__(W_64, 18))
        + W_60;
  v95 = (__ROR4__(v169, 6) ^ __ROR4__(v169, 11) ^ __ROR4__(v169, 25))
      + v251
      + (v135 ^ (v152 ^ v135) & v169)
      + W_124
      + 338241895;
  v186 = v185 + v95;
  v252 = v95 + (__ROR4__(v235, 2) ^ __ROR4__(v235, 13) ^ __ROR4__(v235, 22)) + (v201 & (v235 | v218) | v235 & v218);
  W_128 = (__ROR4__(W_120, 17) ^ __ROR4__(W_120, 19) ^ (W_120 >> 10))
        + W_100
        + ((W_68 >> 3) ^ __ROR4__(W_68, 7) ^ __ROR4__(W_68, 18))
        + W_64;
  v96 = (__ROR4__(v186, 6) ^ __ROR4__(v186, 11) ^ __ROR4__(v186, 25))
      + v135
      + (v152 ^ (v169 ^ v152) & v186)
      + W_128
      + 666307205;
  v202 = v201 + v96;
  v136 = v96 + (__ROR4__(v252, 2) ^ __ROR4__(v252, 13) ^ __ROR4__(v252, 22)) + (v218 & (v252 | v235) | v252 & v235);
  W_132 = (__ROR4__(W_124, 17) ^ __ROR4__(W_124, 19) ^ (W_124 >> 10))
        + W_104
        + ((W_72 >> 3) ^ __ROR4__(W_72, 7) ^ __ROR4__(W_72, 18))
        + W_68;
  v97 = (__ROR4__(v202, 6) ^ __ROR4__(v202, 11) ^ __ROR4__(v202, 25))
      + v152
      + (v169 ^ (v186 ^ v169) & v202)
      + W_132
      + 773529912;
  v219 = v218 + v97;
  v153 = v97 + (__ROR4__(v136, 2) ^ __ROR4__(v136, 13) ^ __ROR4__(v136, 22)) + (v235 & (v136 | v252) | v136 & v252);
  W_136 = (__ROR4__(W_128, 17) ^ __ROR4__(W_128, 19) ^ (W_128 >> 10))
        + W_108
        + ((W_76 >> 3) ^ __ROR4__(W_76, 7) ^ __ROR4__(W_76, 18))
        + W_72;
  v98 = (__ROR4__(v219, 6) ^ __ROR4__(v219, 11) ^ __ROR4__(v219, 25))
      + v169
      + (v186 ^ (v202 ^ v186) & v219)
      + W_136
      + 1294757372;
  v236 = v235 + v98;
  v170 = v98 + (__ROR4__(v153, 2) ^ __ROR4__(v153, 13) ^ __ROR4__(v153, 22)) + (v252 & (v153 | v136) | v153 & v136);
  W_140 = (__ROR4__(W_132, 17) ^ __ROR4__(W_132, 19) ^ (W_132 >> 10))
        + W_112
        + ((W_80 >> 3) ^ __ROR4__(W_80, 7) ^ __ROR4__(W_80, 18))
        + W_76;
  v99 = (__ROR4__(v236, 6) ^ __ROR4__(v236, 11) ^ __ROR4__(v236, 25))
      + v186
      + (v202 ^ (v219 ^ v202) & v236)
      + W_140
      + 1396182291;
  v253 = v252 + v99;
  v187 = v99 + (__ROR4__(v170, 2) ^ __ROR4__(v170, 13) ^ __ROR4__(v170, 22)) + (v136 & (v170 | v153) | v170 & v153);
  W_144 = (__ROR4__(W_136, 17) ^ __ROR4__(W_136, 19) ^ (W_136 >> 10))
        + W_116
        + ((W_84 >> 3) ^ __ROR4__(W_84, 7) ^ __ROR4__(W_84, 18))
        + W_80;
  v100 = (__ROR4__(v253, 6) ^ __ROR4__(v253, 11) ^ __ROR4__(v253, 25))
       + v202
       + (v219 ^ (v236 ^ v219) & v253)
       + W_144
       + 1695183700;
  v137 = v136 + v100;
  v203 = v100 + (__ROR4__(v187, 2) ^ __ROR4__(v187, 13) ^ __ROR4__(v187, 22)) + (v153 & (v187 | v170) | v187 & v170);
  W_148 = (__ROR4__(W_140, 17) ^ __ROR4__(W_140, 19) ^ (W_140 >> 10))
        + W_120
        + ((W_88 >> 3) ^ __ROR4__(W_88, 7) ^ __ROR4__(W_88, 18))
        + W_84;
  v101 = (__ROR4__(v137, 6) ^ __ROR4__(v137, 11) ^ __ROR4__(v137, 25))
       + v219
       + (v236 ^ (v253 ^ v236) & v137)
       + W_148
       + 1986661051;
  v154 = v153 + v101;
  v220 = v101 + (__ROR4__(v203, 2) ^ __ROR4__(v203, 13) ^ __ROR4__(v203, 22)) + (v170 & (v203 | v187) | v203 & v187);
  W_152 = (__ROR4__(W_144, 17) ^ __ROR4__(W_144, 19) ^ (W_144 >> 10))
        + W_124
        + ((W_92 >> 3) ^ __ROR4__(W_92, 7) ^ __ROR4__(W_92, 18))
        + W_88;
  v102 = (__ROR4__(v154, 6) ^ __ROR4__(v154, 11) ^ __ROR4__(v154, 25))
       + v236
       + (v253 ^ (v137 ^ v253) & v154)
       + W_152
       - 2117940946;
  v171 = v170 + v102;
  v237 = v102 + (__ROR4__(v220, 2) ^ __ROR4__(v220, 13) ^ __ROR4__(v220, 22)) + (v187 & (v220 | v203) | v220 & v203);
  W_156 = (__ROR4__(W_148, 17) ^ __ROR4__(W_148, 19) ^ (W_148 >> 10))
        + W_128
        + ((W_96 >> 3) ^ __ROR4__(W_96, 7) ^ __ROR4__(W_96, 18))
        + W_92;
  v103 = (__ROR4__(v171, 6) ^ __ROR4__(v171, 11) ^ __ROR4__(v171, 25))
       + v253
       + (v137 ^ (v154 ^ v137) & v171)
       + W_156
       - 1838011259;
  v188 = v187 + v103;
  v254 = v103 + (__ROR4__(v237, 2) ^ __ROR4__(v237, 13) ^ __ROR4__(v237, 22)) + (v203 & (v237 | v220) | v237 & v220);
  W_160 = (__ROR4__(W_152, 17) ^ __ROR4__(W_152, 19) ^ (W_152 >> 10))
        + W_132
        + ((W_100 >> 3) ^ __ROR4__(W_100, 7) ^ __ROR4__(W_100, 18))
        + W_96;
  v104 = (__ROR4__(v188, 6) ^ __ROR4__(v188, 11) ^ __ROR4__(v188, 25))
       + v137
       + (v154 ^ (v171 ^ v154) & v188)
       + W_160
       - 1564481375;
  v204 = v203 + v104;
  v138 = v104 + (__ROR4__(v254, 2) ^ __ROR4__(v254, 13) ^ __ROR4__(v254, 22)) + (v220 & (v254 | v237) | v254 & v237);
  W_164 = (__ROR4__(W_156, 17) ^ __ROR4__(W_156, 19) ^ (W_156 >> 10))
        + W_136
        + ((W_104 >> 3) ^ __ROR4__(W_104, 7) ^ __ROR4__(W_104, 18))
        + W_100;
  v105 = (__ROR4__(v204, 6) ^ __ROR4__(v204, 11) ^ __ROR4__(v204, 25))
       + v154
       + (v171 ^ (v188 ^ v171) & v204)
       + W_164
       - 1474664885;
  v221 = v220 + v105;
  v155 = v105 + (__ROR4__(v138, 2) ^ __ROR4__(v138, 13) ^ __ROR4__(v138, 22)) + (v237 & (v138 | v254) | v138 & v254);
  W_168 = (__ROR4__(W_160, 17) ^ __ROR4__(W_160, 19) ^ (W_160 >> 10))
        + W_140
        + ((W_108 >> 3) ^ __ROR4__(W_108, 7) ^ __ROR4__(W_108, 18))
        + W_104;
  v106 = (__ROR4__(v221, 6) ^ __ROR4__(v221, 11) ^ __ROR4__(v221, 25))
       + v171
       + (v188 ^ (v204 ^ v188) & v221)
       + W_168
       - 1035236496;
  v238 = v237 + v106;
  v172 = v106 + (__ROR4__(v155, 2) ^ __ROR4__(v155, 13) ^ __ROR4__(v155, 22)) + (v254 & (v155 | v138) | v155 & v138);
  W_172 = (__ROR4__(W_164, 17) ^ __ROR4__(W_164, 19) ^ (W_164 >> 10))
        + W_144
        + ((W_112 >> 3) ^ __ROR4__(W_112, 7) ^ __ROR4__(W_112, 18))
        + W_108;
  v107 = (__ROR4__(v238, 6) ^ __ROR4__(v238, 11) ^ __ROR4__(v238, 25))
       + v188
       + (v204 ^ (v221 ^ v204) & v238)
       + W_172
       - 949202525;
  v255 = v254 + v107;
  v189 = v107 + (__ROR4__(v172, 2) ^ __ROR4__(v172, 13) ^ __ROR4__(v172, 22)) + (v138 & (v172 | v155) | v172 & v155);
  W_176 = (__ROR4__(W_168, 17) ^ __ROR4__(W_168, 19) ^ (W_168 >> 10))
        + W_148
        + ((W_116 >> 3) ^ __ROR4__(W_116, 7) ^ __ROR4__(W_116, 18))
        + W_112;
  v108 = (__ROR4__(v255, 6) ^ __ROR4__(v255, 11) ^ __ROR4__(v255, 25))
       + v204
       + (v221 ^ (v238 ^ v221) & v255)
       + W_176
       - 778901479;
  v139 = v138 + v108;
  v205 = v108 + (__ROR4__(v189, 2) ^ __ROR4__(v189, 13) ^ __ROR4__(v189, 22)) + (v155 & (v189 | v172) | v189 & v172);
  W_180 = (__ROR4__(W_172, 17) ^ __ROR4__(W_172, 19) ^ (W_172 >> 10))
        + W_152
        + ((W_120 >> 3) ^ __ROR4__(W_120, 7) ^ __ROR4__(W_120, 18))
        + W_116;
  v109 = (__ROR4__(v139, 6) ^ __ROR4__(v139, 11) ^ __ROR4__(v139, 25))
       + v221
       + (v238 ^ (v255 ^ v238) & v139)
       + W_180
       - 694614492;
  v156 = v155 + v109;
  v222 = v109 + (__ROR4__(v205, 2) ^ __ROR4__(v205, 13) ^ __ROR4__(v205, 22)) + (v172 & (v205 | v189) | v205 & v189);
  W_184 = (__ROR4__(W_176, 17) ^ __ROR4__(W_176, 19) ^ (W_176 >> 10))
        + W_156
        + ((W_124 >> 3) ^ __ROR4__(W_124, 7) ^ __ROR4__(W_124, 18))
        + W_120;
  v110 = (__ROR4__(v156, 6) ^ __ROR4__(v156, 11) ^ __ROR4__(v156, 25))
       + v238
       + (v255 ^ (v139 ^ v255) & v156)
       + W_184
       - 200395387;
  v173 = v172 + v110;
  v239 = v110 + (__ROR4__(v222, 2) ^ __ROR4__(v222, 13) ^ __ROR4__(v222, 22)) + (v189 & (v222 | v205) | v222 & v205);
  W_188 = (__ROR4__(W_180, 17) ^ __ROR4__(W_180, 19) ^ (W_180 >> 10))
        + W_160
        + ((W_128 >> 3) ^ __ROR4__(W_128, 7) ^ __ROR4__(W_128, 18))
        + W_124;
  v111 = (__ROR4__(v173, 6) ^ __ROR4__(v173, 11) ^ __ROR4__(v173, 25))
       + v255
       + (v139 ^ (v156 ^ v139) & v173)
       + W_188
       + 275423344;
  v190 = v189 + v111;
  v256 = v111 + (__ROR4__(v239, 2) ^ __ROR4__(v239, 13) ^ __ROR4__(v239, 22)) + (v205 & (v239 | v222) | v239 & v222);
  W_192 = (__ROR4__(W_184, 17) ^ __ROR4__(W_184, 19) ^ (W_184 >> 10))
        + W_164
        + ((W_132 >> 3) ^ __ROR4__(W_132, 7) ^ __ROR4__(W_132, 18))
        + W_128;
  v112 = (__ROR4__(v190, 6) ^ __ROR4__(v190, 11) ^ __ROR4__(v190, 25))
       + v139
       + (v156 ^ (v173 ^ v156) & v190)
       + W_192
       + 430227734;
  v206 = v205 + v112;
  v140 = v112 + (__ROR4__(v256, 2) ^ __ROR4__(v256, 13) ^ __ROR4__(v256, 22)) + (v222 & (v256 | v239) | v256 & v239);
  W_196 = (__ROR4__(W_188, 17) ^ __ROR4__(W_188, 19) ^ (W_188 >> 10))
        + W_168
        + ((W_136 >> 3) ^ __ROR4__(W_136, 7) ^ __ROR4__(W_136, 18))
        + W_132;
  v113 = (__ROR4__(v206, 6) ^ __ROR4__(v206, 11) ^ __ROR4__(v206, 25))
       + v156
       + (v173 ^ (v190 ^ v173) & v206)
       + W_196
       + 506948616;
  v223 = v222 + v113;
  v157 = v113 + (__ROR4__(v140, 2) ^ __ROR4__(v140, 13) ^ __ROR4__(v140, 22)) + (v239 & (v140 | v256) | v140 & v256);
  W_200 = (__ROR4__(W_192, 17) ^ __ROR4__(W_192, 19) ^ (W_192 >> 10))
        + W_172
        + ((W_140 >> 3) ^ __ROR4__(W_140, 7) ^ __ROR4__(W_140, 18))
        + W_136;
  v114 = (__ROR4__(v223, 6) ^ __ROR4__(v223, 11) ^ __ROR4__(v223, 25))
       + v173
       + (v190 ^ (v206 ^ v190) & v223)
       + W_200
       + 659060556;
  v240 = v239 + v114;
  v174 = v114 + (__ROR4__(v157, 2) ^ __ROR4__(v157, 13) ^ __ROR4__(v157, 22)) + (v256 & (v157 | v140) | v157 & v140);
  W_204 = (__ROR4__(W_196, 17) ^ __ROR4__(W_196, 19) ^ (W_196 >> 10))
        + W_176
        + ((W_144 >> 3) ^ __ROR4__(W_144, 7) ^ __ROR4__(W_144, 18))
        + W_140;
  v115 = (__ROR4__(v240, 6) ^ __ROR4__(v240, 11) ^ __ROR4__(v240, 25))
       + v190
       + (v206 ^ (v223 ^ v206) & v240)
       + W_204
       + 883997877;
  v257 = v256 + v115;
  v191 = v115 + (__ROR4__(v174, 2) ^ __ROR4__(v174, 13) ^ __ROR4__(v174, 22)) + (v140 & (v174 | v157) | v174 & v157);
  W_208 = (__ROR4__(W_200, 17) ^ __ROR4__(W_200, 19) ^ (W_200 >> 10))
        + W_180
        + ((W_148 >> 3) ^ __ROR4__(W_148, 7) ^ __ROR4__(W_148, 18))
        + W_144;
  v116 = (__ROR4__(v257, 6) ^ __ROR4__(v257, 11) ^ __ROR4__(v257, 25))
       + v206
       + (v223 ^ (v240 ^ v223) & v257)
       + W_208
       + 958139571;
  v141 = v140 + v116;
  v207 = v116 + (__ROR4__(v191, 2) ^ __ROR4__(v191, 13) ^ __ROR4__(v191, 22)) + (v157 & (v191 | v174) | v191 & v174);
  W_212 = (__ROR4__(W_204, 17) ^ __ROR4__(W_204, 19) ^ (W_204 >> 10))
        + W_184
        + ((W_152 >> 3) ^ __ROR4__(W_152, 7) ^ __ROR4__(W_152, 18))
        + W_148;
  v117 = (__ROR4__(v141, 6) ^ __ROR4__(v141, 11) ^ __ROR4__(v141, 25))
       + v223
       + (v240 ^ (v257 ^ v240) & v141)
       + W_212
       + 1322822218;
  v158 = v157 + v117;
  v224 = v117 + (__ROR4__(v207, 2) ^ __ROR4__(v207, 13) ^ __ROR4__(v207, 22)) + (v174 & (v207 | v191) | v207 & v191);
  W_216 = (__ROR4__(W_208, 17) ^ __ROR4__(W_208, 19) ^ (W_208 >> 10))
        + W_188
        + ((W_156 >> 3) ^ __ROR4__(W_156, 7) ^ __ROR4__(W_156, 18))
        + W_152;
  v118 = (__ROR4__(v158, 6) ^ __ROR4__(v158, 11) ^ __ROR4__(v158, 25))
       + v240
       + (v257 ^ (v141 ^ v257) & v158)
       + W_216
       + 1537002063;
  v175 = v174 + v118;
  v241 = v118 + (__ROR4__(v224, 2) ^ __ROR4__(v224, 13) ^ __ROR4__(v224, 22)) + (v191 & (v224 | v207) | v224 & v207);
  W_220 = (__ROR4__(W_212, 17) ^ __ROR4__(W_212, 19) ^ (W_212 >> 10))
        + W_192
        + ((W_160 >> 3) ^ __ROR4__(W_160, 7) ^ __ROR4__(W_160, 18))
        + W_156;
  v119 = (__ROR4__(v175, 6) ^ __ROR4__(v175, 11) ^ __ROR4__(v175, 25))
       + v257
       + (v141 ^ (v158 ^ v141) & v175)
       + W_220
       + 1747873779;
  v192 = v191 + v119;
  v258 = v119 + (__ROR4__(v241, 2) ^ __ROR4__(v241, 13) ^ __ROR4__(v241, 22)) + (v207 & (v241 | v224) | v241 & v224);
  W_224 = (__ROR4__(W_216, 17) ^ __ROR4__(W_216, 19) ^ (W_216 >> 10))
        + W_196
        + ((W_164 >> 3) ^ __ROR4__(W_164, 7) ^ __ROR4__(W_164, 18))
        + W_160;
  v120 = (__ROR4__(v192, 6) ^ __ROR4__(v192, 11) ^ __ROR4__(v192, 25))
       + v141
       + (v158 ^ (v175 ^ v158) & v192)
       + W_224
       + 1955562222;
  v208 = v207 + v120;
  v142 = v120 + (__ROR4__(v258, 2) ^ __ROR4__(v258, 13) ^ __ROR4__(v258, 22)) + (v224 & (v258 | v241) | v258 & v241);
  W_228 = (__ROR4__(W_220, 17) ^ __ROR4__(W_220, 19) ^ (W_220 >> 10))
        + W_200
        + ((W_168 >> 3) ^ __ROR4__(W_168, 7) ^ __ROR4__(W_168, 18))
        + W_164;
  v121 = (__ROR4__(v208, 6) ^ __ROR4__(v208, 11) ^ __ROR4__(v208, 25))
       + v158
       + (v175 ^ (v192 ^ v175) & v208)
       + W_228
       + 2024104815;
  v225 = v224 + v121;
  v159 = v121 + (__ROR4__(v142, 2) ^ __ROR4__(v142, 13) ^ __ROR4__(v142, 22)) + (v241 & (v142 | v258) | v142 & v258);
  W_232 = (__ROR4__(W_224, 17) ^ __ROR4__(W_224, 19) ^ (W_224 >> 10))
        + W_204
        + ((W_172 >> 3) ^ __ROR4__(W_172, 7) ^ __ROR4__(W_172, 18))
        + W_168;
  v122 = (__ROR4__(v225, 6) ^ __ROR4__(v225, 11) ^ __ROR4__(v225, 25))
       + v175
       + (v192 ^ (v208 ^ v192) & v225)
       + W_232
       - 2067236844;
  v242 = v241 + v122;
  v176 = v122 + (__ROR4__(v159, 2) ^ __ROR4__(v159, 13) ^ __ROR4__(v159, 22)) + (v258 & (v159 | v142) | v159 & v142);
  W_236 = (__ROR4__(W_228, 17) ^ __ROR4__(W_228, 19) ^ (W_228 >> 10))
        + W_208
        + ((W_176 >> 3) ^ __ROR4__(W_176, 7) ^ __ROR4__(W_176, 18))
        + W_172;
  v123 = (__ROR4__(v242, 6) ^ __ROR4__(v242, 11) ^ __ROR4__(v242, 25))
       + v192
       + (v208 ^ (v225 ^ v208) & v242)
       + W_236
       - 1933114872;
  v259 = v258 + v123;
  v193 = v123 + (__ROR4__(v176, 2) ^ __ROR4__(v176, 13) ^ __ROR4__(v176, 22)) + (v142 & (v176 | v159) | v176 & v159);
  W_240 = (__ROR4__(W_232, 17) ^ __ROR4__(W_232, 19) ^ (W_232 >> 10))
        + W_212
        + ((W_180 >> 3) ^ __ROR4__(W_180, 7) ^ __ROR4__(W_180, 18))
        + W_176;
  v124 = (__ROR4__(v259, 6) ^ __ROR4__(v259, 11) ^ __ROR4__(v259, 25))
       + v208
       + (v225 ^ (v242 ^ v225) & v259)
       + W_240
       - 1866530822;
  v143 = v142 + v124;
  v209 = v124 + (__ROR4__(v193, 2) ^ __ROR4__(v193, 13) ^ __ROR4__(v193, 22)) + (v159 & (v193 | v176) | v193 & v176);
  W_244 = (__ROR4__(W_236, 17) ^ __ROR4__(W_236, 19) ^ (W_236 >> 10))
        + W_216
        + ((W_184 >> 3) ^ __ROR4__(W_184, 7) ^ __ROR4__(W_184, 18))
        + W_180;
  v125 = (__ROR4__(v143, 6) ^ __ROR4__(v143, 11) ^ __ROR4__(v143, 25))
       + v225
       + (v242 ^ (v259 ^ v242) & v143)
       + W_244
       - 1538233109;
  v160 = v159 + v125;
  v226 = v125 + (__ROR4__(v209, 2) ^ __ROR4__(v209, 13) ^ __ROR4__(v209, 22)) + (v176 & (v209 | v193) | v209 & v193);
  v126 = (__ROR4__(v160, 6) ^ __ROR4__(v160, 11) ^ __ROR4__(v160, 25))
       + v242
       + (v259 ^ (v143 ^ v259) & v160)
       + (__ROR4__(W_240, 17) ^ __ROR4__(W_240, 19) ^ (W_240 >> 10))
       + W_220
       + ((W_188 >> 3) ^ __ROR4__(W_188, 7) ^ __ROR4__(W_188, 18))
       + W_184
       - 1090935817;
  v177 = v176 + v126;
  v243 = v126 + (__ROR4__(v226, 2) ^ __ROR4__(v226, 13) ^ __ROR4__(v226, 22)) + (v193 & (v226 | v209) | v226 & v209);
  v127 = (__ROR4__(v177, 6) ^ __ROR4__(v177, 11) ^ __ROR4__(v177, 25))
       + v259
       + (v143 ^ (v160 ^ v143) & v177)
       + (__ROR4__(W_244, 17) ^ __ROR4__(W_244, 19) ^ (W_244 >> 10))
       + W_224
       + ((W_192 >> 3) ^ __ROR4__(W_192, 7) ^ __ROR4__(W_192, 18))
       + W_188
       - 965641998;
  *((_DWORD *)ctx + 2) += v127
                        + (__ROR4__(v243, 2) ^ __ROR4__(v243, 13) ^ __ROR4__(v243, 22))
                        + (v209 & (v243 | v226) | v243 & v226);
  *((_DWORD *)ctx + 3) += v243;
  *((_DWORD *)ctx + 4) += v226;
  *((_DWORD *)ctx + 5) += v209;
  *((_DWORD *)ctx + 6) += v193 + v127;
  *((_DWORD *)ctx + 7) += v177;
  *((_DWORD *)ctx + 8) += v160;
  *((_DWORD *)ctx + 9) += v143;
}

//----- (000294B4) --------------------------------------------------------
void __cdecl sha2_update(sha2_context *ctx, const unsigned __int8 *input, int ilen)
{
  int v3; // [sp+4h] [bp+4h]
  const unsigned __int8 *src; // [sp+8h] [bp+8h]
  int n; // [sp+10h] [bp+10h]
  int v7; // [sp+14h] [bp+14h]

  src = input;
  v3 = ilen;
  if ( ilen > 0 )
  {
    v7 = *(_DWORD *)ctx & 0x3F;
    n = 64 - v7;
    *(_DWORD *)ctx += ilen;
    *(_DWORD *)ctx = *(_DWORD *)ctx;
    if ( *(_DWORD *)ctx < (unsigned int)ilen )
      ++*((_DWORD *)ctx + 1);
    if ( v7 && ilen >= n )
    {
      memcpy((char *)ctx + v7 + 40, input, n);
      sha2_process(ctx, (const unsigned __int8 *)ctx + 40);
      src += n;
      v3 -= n;
      v7 = 0;
    }
    while ( v3 > 63 )
    {
      sha2_process(ctx, src);
      src += 64;
      v3 -= 64;
    }
    if ( v3 > 0 )
      memcpy((char *)ctx + v7 + 40, src, v3);
  }
}

//----- (00029584) --------------------------------------------------------
void __cdecl sha2_finish(sha2_context *ctx, unsigned __int8 *output)
{
  int v2; // r3
  unsigned __int8 v5[8]; // [sp+8h] [bp+8h] BYREF
  int v6; // [sp+10h] [bp+10h]
  unsigned int v7; // [sp+14h] [bp+14h]
  __int64 v8; // [sp+18h] [bp+18h]

  v8 = 8LL * *(_QWORD *)ctx;
  v5[0] = HIBYTE(v8);
  v5[1] = BYTE6(v8);
  v5[2] = BYTE5(v8);
  v5[3] = BYTE4(v8);
  v5[4] = BYTE3(v8);
  v5[5] = BYTE2(v8);
  v5[6] = BYTE1(v8);
  v5[7] = v8;
  v7 = *(_DWORD *)ctx & 0x3F;
  if ( v7 > 0x37 )
    v2 = 120 - v7;
  else
    v2 = 56 - v7;
  v6 = v2;
  sha2_update(ctx, sha2_padding, v2);
  sha2_update(ctx, v5, 8);
  *output = HIBYTE(*((_DWORD *)ctx + 2));
  output[1] = BYTE2(*((_DWORD *)ctx + 2));
  output[2] = BYTE1(*((_DWORD *)ctx + 2));
  output[3] = *((_DWORD *)ctx + 2);
  output[4] = HIBYTE(*((_DWORD *)ctx + 3));
  output[5] = BYTE2(*((_DWORD *)ctx + 3));
  output[6] = BYTE1(*((_DWORD *)ctx + 3));
  output[7] = *((_DWORD *)ctx + 3);
  output[8] = HIBYTE(*((_DWORD *)ctx + 4));
  output[9] = BYTE2(*((_DWORD *)ctx + 4));
  output[10] = BYTE1(*((_DWORD *)ctx + 4));
  output[11] = *((_DWORD *)ctx + 4);
  output[12] = HIBYTE(*((_DWORD *)ctx + 5));
  output[13] = BYTE2(*((_DWORD *)ctx + 5));
  output[14] = BYTE1(*((_DWORD *)ctx + 5));
  output[15] = *((_DWORD *)ctx + 5);
  output[16] = HIBYTE(*((_DWORD *)ctx + 6));
  output[17] = BYTE2(*((_DWORD *)ctx + 6));
  output[18] = BYTE1(*((_DWORD *)ctx + 6));
  output[19] = *((_DWORD *)ctx + 6);
  output[20] = HIBYTE(*((_DWORD *)ctx + 7));
  output[21] = BYTE2(*((_DWORD *)ctx + 7));
  output[22] = BYTE1(*((_DWORD *)ctx + 7));
  output[23] = *((_DWORD *)ctx + 7);
  output[24] = HIBYTE(*((_DWORD *)ctx + 8));
  output[25] = BYTE2(*((_DWORD *)ctx + 8));
  output[26] = BYTE1(*((_DWORD *)ctx + 8));
  output[27] = *((_DWORD *)ctx + 8);
  output[28] = HIBYTE(*((_DWORD *)ctx + 9));
  output[29] = BYTE2(*((_DWORD *)ctx + 9));
  output[30] = BYTE1(*((_DWORD *)ctx + 9));
  output[31] = *((_DWORD *)ctx + 9);
}
// 2F6C0: using guessed type unsigned __int8 sha2_padding[64];

//----- (000297D8) --------------------------------------------------------
void __cdecl sha2(const unsigned __int8 *input, int ilen, unsigned __int8 *output)
{
  char ctx[232]; // [sp+10h] [bp+10h] BYREF

  sha2_starts((sha2_context *)ctx);
  sha2_update((sha2_context *)ctx, input, ilen);
  sha2_finish((sha2_context *)ctx, output);
  memset(ctx, 0, sizeof(ctx));
}

//----- (00029820) --------------------------------------------------------
unsigned int __fastcall swab32(unsigned int a1)
{
  return bswap32(a1);
}

//----- (00029838) --------------------------------------------------------
void __cdecl flip_swab(void *dest_p, const void *src_p, unsigned int length)
{
  unsigned int i; // [sp+1Ch] [bp+1Ch]

  for ( i = 0; i < length >> 2; ++i )
    *((_DWORD *)dest_p + i) = swab32(*((_DWORD *)src_p + i));
}

//----- (00029888) --------------------------------------------------------
void __cdecl flip32(void *dest_p, const void *src_p)
{
  int i; // [sp+14h] [bp+14h]

  for ( i = 0; i <= 7; ++i )
    *((_DWORD *)dest_p + i) = swab32(*((_DWORD *)src_p + i));
}

//----- (000298D0) --------------------------------------------------------
int __fastcall read_temperature_from_fpga_register(unsigned __int8 a1)
{
  unsigned __int8 v3; // [sp+Fh] [bp+Fh]

  v3 = 0;
  switch ( a1 )
  {
    case 0u:
    case 1u:
    case 2u:
    case 3u:
      v3 = (unsigned int)read_axi_fpga(8) >> (8 * a1);
      break;
    case 4u:
    case 5u:
    case 6u:
    case 7u:
      v3 = (unsigned int)read_axi_fpga(9) >> (8 * (a1 - 4));
      break;
    case 8u:
    case 9u:
    case 0xAu:
    case 0xBu:
      v3 = (unsigned int)read_axi_fpga(10) >> (8 * (a1 - 8));
      break;
    case 0xCu:
    case 0xDu:
    case 0xEu:
    case 0xFu:
      v3 = (unsigned int)read_axi_fpga(11) >> (8 * (a1 - 12));
      break;
    default:
      printf(
        "%s: which_chain = %d, but it is wrong! \n",
        "read_temperature_from_fpga_register",
        (unsigned __int8)gChain);
      break;
  }
  printf("\n%s: Chain%d temperature is %d\n\n", "read_temperature_from_fpga_register", a1, v3);
  if ( v3 )
    gSensor_OK[4 * a1] = 1;
  if ( v3 >= byte_61C40 )
    gStartTest = 1;
  if ( v3 > byte_61C42 )
    gHigherThanAlarmTemp = 1;
  return v3;
}
// 3106C: using guessed type char gChain;
// 317A0: using guessed type char gStartTest;
// 317A4: using guessed type char gHigherThanAlarmTemp;
// 417B8: using guessed type _BYTE gSensor_OK[4];
// 61C40: using guessed type char byte_61C40;
// 61C42: using guessed type char byte_61C42;

//----- (00029A34) --------------------------------------------------------
int __fastcall read_temperature_through_fpga_iic_register(unsigned __int8 a1, int a2)
{
  unsigned __int8 v4; // [sp+Fh] [bp+Fh]
  int v5; // [sp+10h] [bp+10h]
  unsigned __int8 v6; // [sp+17h] [bp+17h]

  v6 = 0;
  if ( gHashBoard_V9 && byte_61C64 == 1 )
    v6 = 9;
  v5 = (a2 << 26) | (v6 << 20) | (a1 << 16) | 0x1000000;
  pthread_mutex_lock(&i2c_mutex);
  v4 = i2c_read(v5);
  i2c_read(v5);
  pthread_mutex_unlock(&i2c_mutex);
  if ( v4 )
    gSensor_OK[4 * a1] = 1;
  if ( v4 >= byte_61C40 )
    gStartTest = 1;
  if ( v4 > byte_61C42 )
    gHigherThanAlarmTemp = 1;
  return v4;
}
// 3176C: using guessed type char gHashBoard_V9;
// 317A0: using guessed type char gStartTest;
// 317A4: using guessed type char gHigherThanAlarmTemp;
// 417B8: using guessed type _BYTE gSensor_OK[4];
// 41830: using guessed type pthread_mutex_t i2c_mutex;
// 61C40: using guessed type char byte_61C40;
// 61C42: using guessed type char byte_61C42;
// 61C64: using guessed type char byte_61C64;

//----- (00029B20) --------------------------------------------------------
void *reset_V9_global_arg()
{
  void *result; // r0
  int v1; // [sp+4h] [bp+4h]
  unsigned int m; // [sp+8h] [bp+8h]
  unsigned int k; // [sp+Ch] [bp+Ch]
  unsigned int j; // [sp+10h] [bp+10h]
  int i; // [sp+14h] [bp+14h]

  result = reset_global_arg();
  for ( i = 0; !i; i = 1 )
  {
    unk_61B44 = 0;
    gRepeated_Nonce_Id[0] = 0;
    gValid_Nonce_Num[0] = 0;
    gSend_Work_Num[0] = 0;
    for ( j = 0; j <= 3; ++j )
    {
      v1 = *((_DWORD *)&cgpu + j + 16427);
      for ( k = 0; k <= 0x31; ++k )
      {
        gAsic_Core_Nonce_Num[128 * j + k] = 0;
        for ( m = 0; dword_61BA0 > m; ++m )
          *(_DWORD *)(v1 + 56 * (k * dword_61BA0 + m) + 52) = 0;
      }
    }
  }
  return result;
}
// 317A8: using guessed type int gValid_Nonce_Num[];
// 317B0: using guessed type _DWORD gSend_Work_Num[1];
// 317B4: using guessed type _DWORD gAsic_Core_Nonce_Num[16384];
// 417B4: using guessed type _DWORD gRepeated_Nonce_Id[1];
// 61BA0: using guessed type int dword_61BA0;

//----- (00029C40) --------------------------------------------------------
int __fastcall V9_set_voltage(unsigned __int8 a1, unsigned __int8 a2, char a3)
{
  unsigned int v7; // [sp+2Ch] [bp+1Ch]

  switch ( pattern_test_time )
  {
    case 0:
      v7 = dword_61BFC;
      break;
    case 1:
      v7 = dword_61C00;
      break;
    case 2:
      v7 = dword_61C04;
      break;
    case 3:
      v7 = dword_61C08;
      break;
    case 4:
      v7 = dword_61C0C;
      break;
    case 5:
      v7 = dword_61C10;
      break;
    case 6:
      v7 = dword_61C14;
      break;
    case 7:
      v7 = dword_61C18;
      break;
    case 8:
      v7 = dword_61C1C;
      break;
    default:
      v7 = dword_61BFC;
      printf("\n--- %s: Can't find voltage%d\n", (const char *)(unsigned __int8)pattern_test_time, jpt_29C76);
      break;
  }
  if ( a3 )
    v7 += dword_61C50;
  printf(
    "\n--- %s: real voltage = %d, temp_voltage = %.6f, Pic_Voltage = %d\n",
    "V9_set_voltage",
    v7,
    1742.06996 - (double)v7 * 152.134146 / 100.0,
    (unsigned int)(1742.06996 - (double)v7 * 152.134146 / 100.0));
  set_PIC16F1704_voltage(a1, a2, (unsigned int)(1742.06996 - (double)v7 * 152.134146 / 100.0));
  return usleep(0x186A0u);
}
// 29C7C: using guessed type void *jpt_29C76[9];
// 31785: using guessed type char pattern_test_time;
// 61BFC: using guessed type int dword_61BFC;
// 61C00: using guessed type int dword_61C00;
// 61C04: using guessed type int dword_61C04;
// 61C08: using guessed type int dword_61C08;
// 61C0C: using guessed type int dword_61C0C;
// 61C10: using guessed type int dword_61C10;
// 61C14: using guessed type int dword_61C14;
// 61C18: using guessed type int dword_61C18;
// 61C1C: using guessed type int dword_61C1C;
// 61C50: using guessed type int dword_61C50;

//----- (00029E00) --------------------------------------------------------
int V9_calculate_timeout_and_baud()
{
  int result; // r0
  unsigned int v1; // [sp+Ch] [bp+4h]
  unsigned int v2; // [sp+14h] [bp+Ch]

  v2 = 0;
  v1 = calculate_core_number(0x32u);
  switch ( pattern_test_time )
  {
    case 0:
      v2 = dword_61BA8;
      break;
    case 1:
      v2 = dword_61BAC;
      break;
    case 2:
      v2 = dword_61BB0;
      break;
    case 3:
      v2 = dword_61BB4;
      break;
    case 4:
      v2 = dword_61BB8;
      break;
    case 5:
      v2 = dword_61BBC;
      break;
    case 6:
      v2 = dword_61BC0;
      break;
    case 7:
      v2 = dword_61BC4;
      break;
    case 8:
      v2 = dword_61BC8;
      break;
    default:
      printf(
        "%s: pattern_test_time = %d, error!!! \n",
        "V9_calculate_timeout_and_baud",
        (unsigned __int8)pattern_test_time);
      break;
  }
  dword_61C24 = 95 * (gChain_Asic_Interval * (0x1000000 / v1) / v2) / 0x64;
  dword_61C6C = 0x2FAF08 / ((0x196E6Au / dword_61C24) << 9) - 1;
  if ( (unsigned int)dword_61C6C > 0x1A )
    dword_61C6C = 26;
  if ( (unsigned int)dword_61C6C <= 0x1A )
    dword_61C6C = dword_61C6C != 0;
  result = printf(
             "\n--- %s: baud = %d, timeout = 0x%08x = %d\n",
             "V9_calculate_timeout_and_baud",
             dword_61C6C,
             dword_61C24,
             dword_61C24);
  dword_61BA4 = v2;
  return result;
}
// 31785: using guessed type char pattern_test_time;
// 31798: using guessed type int gChain_Asic_Interval;
// 61BA4: using guessed type int dword_61BA4;
// 61BA8: using guessed type int dword_61BA8;
// 61BAC: using guessed type int dword_61BAC;
// 61BB0: using guessed type int dword_61BB0;
// 61BB4: using guessed type int dword_61BB4;
// 61BB8: using guessed type int dword_61BB8;
// 61BBC: using guessed type int dword_61BBC;
// 61BC0: using guessed type int dword_61BC0;
// 61BC4: using guessed type int dword_61BC4;
// 61BC8: using guessed type int dword_61BC8;
// 61C24: using guessed type int dword_61C24;
// 61C6C: using guessed type int dword_61C6C;

//----- (0002A01C) --------------------------------------------------------
int __fastcall V9_set_address(unsigned __int8 a1)
{
  int result; // r0
  unsigned __int8 i; // [sp+Eh] [bp+Eh]
  unsigned __int8 v4; // [sp+Fh] [bp+Fh]

  v4 = 0;
  printf("\n--- %s: Chain : %d\n", "V9_set_address", a1);
  result = BM1385_chain_inactive(a1);
  for ( i = 0; i <= 3u; ++i )
  {
    BM1385_set_address(a1, v4);
    v4 += gChain_Asic_Interval;
    result = usleep(0x1388u);
  }
  return result;
}
// 31798: using guessed type int gChain_Asic_Interval;

//----- (0002A090) --------------------------------------------------------
int __fastcall V9_set_baud(unsigned __int8 a1, unsigned __int8 a2)
{
  printf("\n--- %s: Chain : %d, baud = %d\n", "V9_set_baud", a1, a2);
  BM1385_set_baud(a1, 0, a2, 1);
  usleep(0xC350u);
  return set_fpga_baud(a2);
}

//----- (0002A0E0) --------------------------------------------------------
int __fastcall V9_open_core(unsigned __int8 a1)
{
  int result; // r0
  char v3[64]; // [sp+Ch] [bp+Ch] BYREF
  int v4; // [sp+4Ch] [bp+4Ch]
  int v5; // [sp+50h] [bp+50h]
  int v6; // [sp+54h] [bp+54h]
  unsigned int j; // [sp+58h] [bp+58h]
  unsigned int i; // [sp+5Ch] [bp+5Ch]

  i = 0;
  v6 = 0;
  v5 = 0;
  j = 0;
  v4 = 0;
  memset(v3, 0, sizeof(v3));
  v3[0] = -1;
  printf("\n--- %s: Chain : %d\n", "V9_open_core", a1);
  gIsOpenCoreEnd = 0;
  gIsOpeningCore = 1;
  memset(v3, 0, sizeof(v3));
  BM1385_set_gateblk(a1, 0, 1);
  for ( i = 0; i <= 0x31; ++i )
  {
    uart_send(a1, (unsigned __int8 *)v3, 0x40u);
    usleep(dword_61C20);
  }
  memset(v3, 0, sizeof(v3));
  for ( j = 0; j <= 0x33; ++j )
    v3[j] = j;
  v3[52] = -1;
  BM1385_set_gateblk(a1, 0, 1);
  for ( i = 0; i <= 0x3B; ++i )
  {
    uart_send(a1, (unsigned __int8 *)v3, 0x40u);
    usleep(dword_61C20);
  }
  result = clear_uart_rx_fifo(a1);
  gIsOpeningCore = 0;
  gIsOpenCoreEnd = 1;
  return result;
}
// 317A2: using guessed type char gIsOpenCoreEnd;
// 317A3: using guessed type char gIsOpeningCore;
// 61C20: using guessed type int dword_61C20;

//----- (0002A22C) --------------------------------------------------------
int __fastcall V9_get_result(unsigned __int8 a1)
{
  int v3; // [sp+10h] [bp+10h]
  unsigned int v4; // [sp+14h] [bp+14h]
  unsigned int v5; // [sp+14h] [bp+14h]
  int v6; // [sp+18h] [bp+18h]
  int v7; // [sp+1Ch] [bp+1Ch]
  int v8; // [sp+20h] [bp+20h]
  unsigned int m; // [sp+24h] [bp+24h]
  unsigned int k; // [sp+28h] [bp+28h]
  unsigned int i; // [sp+2Ch] [bp+2Ch]
  unsigned int j; // [sp+2Ch] [bp+2Ch]

  v8 = 0;
  v6 = 7;
  puts("\n\n------------------------------------------------------------------------------------------------------\n");
  printf("every ASIC require nonce number: %lu\n", 50 * dword_61BA0);
  for ( i = 0; i <= 3; ++i )
  {
    if ( !(i % 9) )
      putchar(10);
    v4 = calculate_how_many_nonce_per_asic_get(a1, i, 0x32u);
    printf("asic[%02d]=%d\t", i, v4);
    if ( 50 * dword_61BA0 > v4 && dword_61C54 < (unsigned int)++v8 )
      v6 &= ~1u;
  }
  puts("\n");
  for ( j = 0; j <= 3; ++j )
  {
    v5 = calculate_how_many_nonce_per_asic_get(a1, j, 0x32u);
    if ( 50 * dword_61BA0 > v5 )
    {
      printf("asic[%02d] = %d\n", j, v5);
      v3 = *((_DWORD *)&cgpu + j + 16427);
      v7 = 0;
      for ( k = 0; k <= 0x31; ++k )
      {
        if ( gAsic_Core_Nonce_Num[128 * ((a1 << 7) + j) + k] < (unsigned int)dword_61BA0 )
        {
          if ( dword_61C58 < (unsigned int)++v7 )
            v6 &= ~1u;
          if ( gAsic_Core_Nonce_Num[128 * ((a1 << 7) + j) + k] < (unsigned int)dword_61C5C )
            v6 &= ~1u;
          printf("core[%02d] = %d,      lost these nonce : ", k, gAsic_Core_Nonce_Num[128 * ((a1 << 7) + j) + k]);
          for ( m = 0; dword_61BA0 > m; ++m )
          {
            if ( !*(_DWORD *)(v3 + 56 * (k * dword_61BA0 + m) + 4 * (a1 + 12) + 4) )
              printf("%d  ", m);
          }
          putchar(10);
        }
      }
      puts("\n");
    }
  }
  if ( gHw_Nonce_Num[a1] > (unsigned int)dword_61C60 )
  {
    v6 &= ~1u;
    printf("ret = %d\n", v6);
  }
  puts("\n------------------------------------------------------------------------------------------------------\n");
  if ( gSensor_OK[4 * a1] != 1 )
    v6 &= ~2u;
  if ( gHigherThanAlarmTemp )
    v6 &= ~4u;
  printf("Chain%d total valid nonce number: %d\n\n", a1, gValid_Nonce_Num[a1]);
  if ( (v6 & 1) != 0 )
    puts("Pattern OK\n");
  else
    puts("Pattern NG\n");
  if ( (v6 & 2) != 0 )
    puts("Sensor OK\n");
  else
    puts("Sensor NG\n");
  if ( (v6 & 4) != 0 )
    puts("Temperature OK\n");
  else
    puts("Temperature NG\n");
  printf("HW number = %d\n\n", gHw_Nonce_Num[a1]);
  return v6;
}
// 317A4: using guessed type char gHigherThanAlarmTemp;
// 317A8: using guessed type int gValid_Nonce_Num[];
// 317AC: using guessed type int gHw_Nonce_Num[];
// 317B4: using guessed type _DWORD gAsic_Core_Nonce_Num[16384];
// 417B8: using guessed type _BYTE gSensor_OK[4];
// 61BA0: using guessed type int dword_61BA0;
// 61C54: using guessed type int dword_61C54;
// 61C58: using guessed type int dword_61C58;
// 61C5C: using guessed type int dword_61C5C;
// 61C60: using guessed type int dword_61C60;

//----- (0002A5CC) --------------------------------------------------------
unsigned int __fastcall V9_print_lcd(char a1)
{
  display_level_result_on_lcd();
  if ( (a1 & 1) != 0 )
  {
    write_lcd_no_memset(1u, (int)"   Pattern OK   ", 0x10u);
    pattern_test_time = 0;
  }
  else
  {
    write_lcd_no_memset(1u, (int)"   Pattern NG   ", 0x10u);
    ++pattern_test_time;
  }
  if ( (a1 & 2) != 0 )
    write_lcd_no_memset(2u, (int)"   Sensor OK    ", 0x10u);
  else
    write_lcd_no_memset(2u, (int)"   Sensor NG    ", 0x10u);
  if ( (a1 & 4) != 0 )
    return write_lcd_no_memset(3u, (int)" Temperature OK ", 0x10u);
  else
    return write_lcd_no_memset(3u, (int)" Temperature NG ", 0x10u);
}
// 31785: using guessed type char pattern_test_time;

//----- (0002A688) --------------------------------------------------------
void __fastcall __noreturn V9_show_status_func(unsigned __int8 *a1)
{
  int temperature_through_fpga_iic_register; // [sp+Ch] [bp+Ch]
  unsigned __int8 v2; // [sp+12h] [bp+12h]
  unsigned __int8 v3; // [sp+13h] [bp+13h]

  v3 = *a1;
  v2 = a1[1];
  time_counter = 0;
  while ( 1 )
  {
    memset(lcd_output, 32, 0x40u);
    temperature_through_fpga_iic_register = read_temperature_through_fpga_iic_register(v3, v2);
    sprintf(lcd_output, "   time %ds", time_counter);
    sprintf(s, "   nonce=%d", gValid_Nonce_Num[v3]);
    sprintf(byte_310B0, "   temp %d `C", temperature_through_fpga_iic_register);
    if ( temperature_through_fpga_iic_register > (unsigned int)gHighest_Temp )
      gHighest_Temp = temperature_through_fpga_iic_register;
    ++time_counter;
    write(lcd_fd, lcd_output, 0x40u);
    if ( byte_61C40 > temperature_through_fpga_iic_register )
    {
      if ( gStartTest != 1 )
        printf(
          "\nHash Board temperature is %d, waiting it raise to start temperature %d\n",
          temperature_through_fpga_iic_register,
          byte_61C40);
    }
    else
    {
      if ( gStartTest != 1 )
        printf("\nBegin test!!! Hash Board temperature is %d\n", temperature_through_fpga_iic_register);
      gStartTest = 1;
    }
    set_fan_speed(0);
    printf(
      "\nChain%d get valid nonce number : %d. temperature is %d\n",
      v3,
      gValid_Nonce_Num[v3],
      temperature_through_fpga_iic_register);
    usleep(0xF4240u);
  }
}
// 31788: using guessed type int time_counter;
// 31794: using guessed type int gHighest_Temp;
// 317A0: using guessed type char gStartTest;
// 317A8: using guessed type int gValid_Nonce_Num[];
// 41824: using guessed type int lcd_fd;
// 61C40: using guessed type char byte_61C40;

//----- (0002A818) --------------------------------------------------------
int __fastcall v9_check_nonce(unsigned __int8 a1, unsigned __int8 *a2)
{
  unsigned int v2; // r0
  int v7; // [sp+10h] [bp+8h]
  unsigned int v8; // [sp+18h] [bp+10h]
  unsigned int v9; // [sp+20h] [bp+18h]
  unsigned int v10; // [sp+24h] [bp+1Ch]
  unsigned int v11; // [sp+28h] [bp+20h]
  int i; // [sp+30h] [bp+28h]
  int v13; // [sp+34h] [bp+2Ch]

  v13 = 0;
  v8 = _byteswap_ulong(*(_DWORD *)a2);
  v2 = *a2 / (unsigned int)gChain_Asic_Interval;
  v11 = v2;
  v10 = a2[3] & 0x3F;
  v9 = a2[4] & 0x7F;
  if ( v2 > 3 )
    return -1;
  if ( v10 <= 0x31 )
  {
    if ( dword_61BA0 > v9 )
    {
      v7 = *((_DWORD *)&cgpu + v2 + 16427) + 56 * (v10 * dword_61BA0 + v9);
      if ( v8 == *(_DWORD *)(v7 + 4) )
      {
        if ( *(_DWORD *)(v7 + 4 * (a1 + 12) + 4) )
        {
          ++gRepeated_Nonce_Id[a1];
          ++*(_DWORD *)(v7 + 4 * (a1 + 12) + 4);
        }
        else
        {
          ++*(_DWORD *)(v7 + 4 * (a1 + 12) + 4);
          ++gValid_Nonce_Num[a1];
          ++gAsic_Core_Nonce_Num[128 * ((a1 << 7) + v2) + v10];
        }
      }
      else
      {
        pthread_mutex_lock(&HW_check_mutex[a1]);
        for ( i = 0; (unsigned __int8)gWork_Num_For_Hw_Check > i; ++i )
        {
          v13 = check_hw(&gWorks_For_Hw_Check[140 * a1 + 14 * i], v8, 0);
          if ( !v13 )
            break;
        }
        pthread_mutex_unlock(&HW_check_mutex[a1]);
        if ( v13 == 1 )
        {
          ++gHw_Nonce_Num[a1];
          printf("%s: Find a HW. Chain%d ASIC%d Core%d : nonce = 0x%08x.\n", "v9_check_nonce", a1, v11, v10, v8);
        }
      }
      return 0;
    }
    else
    {
      printf("%s: received work_id = %02d nonce. error!!!\t", "v9_check_nonce", v9);
      printf(",received data is : 0x%02x%02x%02x%02x%02x\n", *a2, a2[1], a2[2], a2[3], a2[4]);
      return -1;
    }
  }
  else
  {
    printf("%s: received core%02d nonce. error!!!\t", "v9_check_nonce", v10);
    printf(",received data is : 0x%02x%02x%02x%02x%02x\n", *a2, a2[1], a2[2], a2[3], a2[4]);
    return -1;
  }
}
// 31798: using guessed type int gChain_Asic_Interval;
// 317A8: using guessed type int gValid_Nonce_Num[];
// 317AC: using guessed type int gHw_Nonce_Num[];
// 317B4: using guessed type _DWORD gAsic_Core_Nonce_Num[16384];
// 417B4: using guessed type _DWORD gRepeated_Nonce_Id[1];
// 417BC: using guessed type char gWork_Num_For_Hw_Check;
// 417D8: using guessed type pthread_mutex_t HW_check_mutex[1];
// 61BA0: using guessed type int dword_61BA0;
// 6250C: using guessed type _DWORD gWorks_For_Hw_Check[140];

//----- (0002AB44) --------------------------------------------------------
int __fastcall V9_check_register_value(char a1, int a2)
{
  if ( *(_DWORD *)(reg_value_buf + 8) > 0x1FEu )
  {
    printf("%s: reg_value_buf buffer is full!\n", "V9_check_register_value");
    return -1;
  }
  else
  {
    *(_DWORD *)(reg_value_buf + 8 * (*(_DWORD *)reg_value_buf + 2)) = _byteswap_ulong(*(_DWORD *)a2);
    *(_BYTE *)(reg_value_buf + 8 * (*(_DWORD *)reg_value_buf + 2) + 4) = *(_BYTE *)(a2 + 4) & 0x1F;
    *(_BYTE *)(reg_value_buf + 8 * (*(_DWORD *)reg_value_buf + 2) + 5) = a1;
    ++*(_DWORD *)reg_value_buf;
    ++*(_DWORD *)(reg_value_buf + 8);
    if ( *(_DWORD *)reg_value_buf > 0x1FFu )
      *(_DWORD *)reg_value_buf = 0;
    return 0;
  }
}
// 61B5C: using guessed type int reg_value_buf;

//----- (0002AC54) --------------------------------------------------------
int __fastcall V9_send_func(unsigned __int8 *a1)
{
  int v1; // r3
  char v3[64]; // [sp+14h] [bp+Ch] BYREF
  void *src; // [sp+54h] [bp+4Ch]
  int v5; // [sp+58h] [bp+50h]
  int v6; // [sp+5Ch] [bp+54h]
  int v7; // [sp+60h] [bp+58h]
  int v8; // [sp+64h] [bp+5Ch]
  unsigned __int8 v9; // [sp+6Bh] [bp+63h]
  unsigned __int8 *v10; // [sp+6Ch] [bp+64h]
  int m; // [sp+70h] [bp+68h]
  unsigned int k; // [sp+74h] [bp+6Ch]
  unsigned int j; // [sp+78h] [bp+70h]
  unsigned int i; // [sp+7Ch] [bp+74h]

  v10 = a1;
  v9 = *a1;
  j = 0;
  k = 0;
  v8 = 0;
  v7 = 0;
  v6 = 0;
  m = 0;
  memset(v3, 0, sizeof(v3));
  for ( i = 0; i <= 3; ++i )
  {
    v5 = *((_DWORD *)&cgpu + i + 16427);
    for ( j = 0; j <= 0x31; ++j )
    {
      for ( k = 0; dword_61BA0 > k; ++k )
      {
        src = (void *)(v5 + 56 * (j * dword_61BA0 + k));
        for ( m = 0; m <= 31; ++m )
          v3[m] = *((_BYTE *)src + m + 20);
        v6 = *((_DWORD *)src + 1);
        v3[44] = HIBYTE(v6);
        v3[45] = BYTE2(v6);
        v3[46] = BYTE1(v6);
        v3[47] = v6;
        v3[51] = k;
        for ( m = 0; m <= 11; ++m )
          v3[m + 52] = *((_BYTE *)src + m + 8);
        uart_send(v9, (unsigned __int8 *)v3, 0x40u);
        pthread_mutex_lock(&HW_check_mutex[v9]);
        for ( m = 8; m >= 0; --m )
          memcpy(&gWorks_For_Hw_Check[140 * v9 + 14 + 14 * m], &gWorks_For_Hw_Check[140 * v9 + 14 * m], 0x38u);
        if ( (unsigned __int8)++gWork_Num_For_Hw_Check > 8u )
          gWork_Num_For_Hw_Check = 9;
        memcpy(&gWorks_For_Hw_Check[140 * v9], src, 0x38u);
        pthread_mutex_unlock(&HW_check_mutex[v9]);
        ++gSend_Work_Num[v9];
        usleep(0x7D0u);
      }
    }
  }
  while ( gSend_Work_Num[v9] < (unsigned int)(200 * dword_61BA0) )
    printf(
      "\n\n---%s: Chain%d send work num : %d, less than %d\n",
      "V9_send_func",
      v9,
      gSend_Work_Num[v9],
      200 * dword_61BA0);
  printf("\n\n---%s: Chain%d send work num : %d\n", "V9_send_func", v9, gSend_Work_Num[v9]);
  puts("\nsend test pattern done");
  system("date");
  putchar(10);
  usleep(0x9C40u);
  start_receive = 0;
  puts("to stop receive");
  return v1;
}
// 2AF9C: variable 'v1' is possibly undefined
// 317A5: using guessed type char start_receive;
// 317B0: using guessed type _DWORD gSend_Work_Num[1];
// 417BC: using guessed type char gWork_Num_For_Hw_Check;
// 417D8: using guessed type pthread_mutex_t HW_check_mutex[1];
// 61BA0: using guessed type int dword_61BA0;
// 6250C: using guessed type _DWORD gWorks_For_Hw_Check[140];

//----- (0002AFA8) --------------------------------------------------------
int __fastcall V9_receive_func(unsigned __int8 *a1)
{
  _DWORD v2[2]; // [sp+8h] [bp+8h] BYREF
  _BYTE v3[500]; // [sp+10h] [bp+10h] BYREF
  _BYTE v4[1052]; // [sp+204h] [bp+204h] BYREF
  int v5; // [sp+620h] [bp+620h]
  unsigned int v6; // [sp+624h] [bp+624h]
  unsigned int v7; // [sp+628h] [bp+628h]
  unsigned int v8; // [sp+62Ch] [bp+62Ch]
  unsigned __int8 v9; // [sp+632h] [bp+632h]
  unsigned __int8 v10; // [sp+633h] [bp+633h]
  unsigned __int8 *v11; // [sp+634h] [bp+634h]
  unsigned int k; // [sp+638h] [bp+638h]
  unsigned int j; // [sp+63Ch] [bp+63Ch]
  unsigned int i; // [sp+640h] [bp+640h]
  int v15; // [sp+644h] [bp+644h]
  unsigned int v16; // [sp+648h] [bp+648h]
  int v17; // [sp+64Ch] [bp+64Ch]

  v11 = a1;
  v10 = *a1;
  v9 = a1[1];
  memset(v4, 0, 0x41Au);
  memset(v3, 0, sizeof(v3));
  v2[0] = 0;
  LOBYTE(v2[1]) = 0;
  v8 = 0;
  v17 = 0;
  v16 = 0;
  v15 = 0;
  v7 = 0;
  v6 = 0;
  i = 0;
  j = 0;
  k = 0;
  v5 = 0;
  printf("%s: which_chain = %d, which_i2c = %d\n", "V9_receive_func", v10, v9);
  clear_uart_rx_fifo(v10);
LABEL_29:
  while ( start_receive )
  {
    usleep(0x1388u);
    for ( i = 0; i <= 0x4C4B3F; ++i )
    {
      while ( gIsOpeningCore )
        usleep(0x4E20u);
      memset(v4, 0, 0x41Au);
      v8 = uart_receive(v10, (int)v4, 0x3E8u);
      if ( v8 )
      {
        for ( j = 0; j < v8; ++j )
          v3[v16++] = v4[j];
        if ( v16 > 4 )
        {
          v7 = v16 / 5;
          for ( j = 0; j < v7; ++j )
          {
            memset(v2, 0, 5u);
            for ( k = 0; k <= 4; ++k )
              *((_BYTE *)v2 + k) = v3[v15++];
            if ( is_nonce_or_reg_value(v2[1]) )
            {
              if ( gStartTest )
              {
                if ( gIsOpenCoreEnd )
                {
                  v5 = v9_check_nonce(v10, (unsigned __int8 *)v2);
                  if ( v5 == -1 )
                    ++v17;
                }
              }
            }
            else
            {
              v5 = V9_check_register_value(v10, (int)v2);
              if ( v5 == -1 )
                ++v17;
            }
          }
          v6 = v16 - v15;
          for ( k = 0; k < v6; ++k )
            v3[k] = v3[v15++];
          v16 = v6;
          v15 = 0;
          v7 = 0;
        }
        goto LABEL_29;
      }
    }
  }
  return (unsigned __int8)start_receive;
}
// 317A0: using guessed type char gStartTest;
// 317A2: using guessed type char gIsOpenCoreEnd;
// 317A3: using guessed type char gIsOpeningCore;
// 317A5: using guessed type char start_receive;

//----- (0002B2A8) --------------------------------------------------------
int singleBoardTest_V9_BM1385_45()
{
  __int16 v1; // [sp+18h] [bp+10h] BYREF
  char v2; // [sp+1Ah] [bp+12h]
  int v3; // [sp+1Ch] [bp+14h]
  int v4; // [sp+20h] [bp+18h]
  int v5; // [sp+24h] [bp+1Ch]
  int v6; // [sp+28h] [bp+20h]
  int v7[8]; // [sp+2Ch] [bp+24h] BYREF

  v7[6] = 0;
  v7[5] = 0;
  v7[4] = 123456;
  qmemcpy(v7, "                ", 16);
  v3 = *(_DWORD *)"";
  v4 = 117835012;
  v5 = 185207048;
  v6 = 252579084;
  v1 = 8864;
  v2 = 16;
  printf("\nBegin %s test\n", "singleBoardTest_V9_BM1385_45");
  system("date");
  putchar(10);
  memset(lcd_output, 32, 0x40u);
  if ( lcd_fd > 0 )
  {
    lseek(lcd_fd, 0, 0);
    write(lcd_fd, lcd_output, 0x40u);
  }
  init_fpga();
  set_fpga_baud(0x1Au);
  reset_V9_global_arg();
  check_chain();
  if ( (unsigned __int8)gChain == 255 )
  {
    pthread_cancel(dword_5184C);
    pthread_cancel(newthread);
    usleep(0x7A120u);
    write_lcd(1u, (int)" no hash board  ", 0x10u);
    return puts("\nNo hash board, please plug in it");
  }
  else
  {
    write_axi_fpga(13, 0xFFFF);
    usleep((__useconds_t)&unk_493E0);
    reset_PIC16F1704_pic(gChain, gI2c);
    jump_from_loader_to_app_PIC16F1704(gChain, gI2c);
    return read_PIC16F1705_iic_slave(gChain, gI2c, (int)&v1, 3u);
  }
}
// 3106C: using guessed type char gChain;
// 31779: using guessed type char gI2c;
// 41824: using guessed type int lcd_fd;

//----- (0002B488) --------------------------------------------------------
int singleBoardTest_V9_BM1740()
{
  if ( inited )
    goto LABEL_5;
  fl = (int)fopen("/tmp/bm1740.log", "w+");
  if ( fl )
  {
    bm1740_app_init();
LABEL_5:
    bm1740_app_test_manual();
    return 1;
  }
  puts("open log file error");
  return 0;
}
// 3122C: using guessed type int inited;
// 624EC: using guessed type int fl;

//----- (0002B766) --------------------------------------------------------
int __fastcall divsi3_skip_div0_test(int result, unsigned int a2)
{
  char v2; // nf
  signed int v3; // r12
  unsigned int v4; // r3

  v3 = result ^ a2;
  if ( v2 )
    a2 = -a2;
  if ( a2 == 1 )
  {
    if ( (v3 ^ result) < 0 )
      return -result;
  }
  else
  {
    v4 = result;
    if ( result < 0 )
      v4 = -result;
    if ( v4 <= a2 )
    {
      if ( v4 < a2 )
        result = 0;
      if ( v4 == a2 )
        return (v3 >> 31) | 1;
    }
    else if ( (a2 & (a2 - 1)) != 0 )
    {
      return ((int (__fastcall *)(_DWORD))((char *)&loc_2B7A8 + 16 * (31 - (__clz(a2) - __clz(v4)))))(0);
    }
    else
    {
      result = v4 >> (31 - __clz(a2));
      if ( v3 < 0 )
        return -result;
    }
  }
  return result;
}
// 2B76A: variable 'v2' is possibly undefined

//----- (0002BA10) --------------------------------------------------------
int _aeabi_ldiv0()
{
  return raise(8);
}

//----- (0002BA1C) --------------------------------------------------------
__int64 init()
{
  unsigned int v0; // r5
  int i; // r4
  __int64 (__fastcall *v2)(); // t1
  __int64 result; // r0

  init_proc();
  v0 = 0x2FFFCu;
  for ( i = 0; i != 1; ++i )
  {
    v2 = *(__int64 (__fastcall **)())(v0 + 4);
    v0 += 4;
    result = v2();
  }
  return result;
}

//----- (0002BA64) --------------------------------------------------------
void term_proc()
{
  ;
}

// nfuncs=405 queued=272 decompiled=272 lumina nreq=0 worse=0 better=0
// ALL OK, 272 function(s) have been successfully decompiled
