/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

int init_proc();
void sub_88B0();
// int pthread_mutex_unlock(pthread_mutex_t *mutex);
// char *strstr(const char *haystack, const char *needle);
// int raise(int sig);
// int printf(const char *format, ...);
// FILE *fopen(const char *filename, const char *modes);
// ssize_t read(int fd, void *buf, size_t nbytes);
// void free(void *ptr);
// char *fgets(char *s, int n, FILE *stream);
// int pthread_mutex_lock(pthread_mutex_t *mutex);
// void *memcpy(void *dest, const void *src, size_t n);
// int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);
// __off_t lseek(int fd, __off_t offset, int whence);
// int memcmp(const void *s1, const void *s2, size_t n);
// unsigned int sleep(unsigned int seconds);
// int usleep(__useconds_t useconds);
// char *strcpy(char *dest, const char *src);
// int pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
// int puts(const char *s);
// void *malloc(size_t size);
// int __fastcall _libc_start_main(int (__fastcall *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end);
// int system(const char *command);
int j___gmon_start__();
// int _gmon_start__(void); weak
// int open(const char *file, int oflag, ...);
// unsigned int strtoul(const char *nptr, char **endptr, int base);
// void *mmap(void *addr, size_t len, int prot, int flags, int fd, __off_t offset);
// int _isoc99_sscanf(_DWORD, const char *, ...); weak
// void *memset(void *s, int c, size_t n);
// int putchar(int c);
// int pthread_cancel(pthread_t th);
// ssize_t write(int fd, const void *buf, size_t n);
// int fclose(FILE *stream);
// int munmap(void *addr, size_t len);
// uint32_t htonl(uint32_t hostlong);
// int pthread_join(pthread_t th, void **thread_return);
// int sprintf(char *s, const char *format, ...);
// int fseek(FILE *stream, int off, int whence);
// void abort(void);
// int close(int fd);
void __noreturn start(void (*)(void), int, int, int, ...); // idb
int call_gmon_start();
char *deregister_tm_clones();
__int64 register_tm_clones();
char *_do_global_dtors_aux();
__int64 frame_dummy();
int __cdecl main(int argc, const char **argv, const char **envp);
int __fastcall get_BM1385_plldata(int, _DWORD *, unsigned __int16 *, _DWORD *); // idb
unsigned int __fastcall read_BM1385_asic_register(unsigned __int8, unsigned __int8, unsigned __int8, char); // idb
int __fastcall set_BM1385_freq(unsigned __int8, char, int, char); // idb
void *__fastcall check_BM1385_asic_reg(unsigned __int8 a1, int a2, unsigned __int8 a3, char a4);
int __fastcall BM1385_chain_inactive(unsigned __int8); // idb
unsigned int __fastcall BM1385_set_address(unsigned __int8, unsigned __int8); // idb
unsigned int __fastcall BM1385_set_baud(unsigned __int8, char, char, char); // idb
int __fastcall BM1385_set_gateblk(unsigned __int8 a1, int a2, char a3);
int reset_single_BM1385_global_arg();
unsigned int single_BM1385_calculate_timeout_and_baud();
unsigned int __fastcall BM1722_set_address_all(unsigned __int8); // idb
int __fastcall single_BM1385_set_baud(unsigned __int8, unsigned __int8); // idb
int __fastcall single_BM1385_open_core(unsigned __int8); // idb
int __fastcall single_BM1385_get_result(unsigned __int8 a1);
unsigned int __fastcall single_asic_print_lcd(int, char); // idb
void __fastcall __noreturn single_BM1385_show_status_func(unsigned __int8 *a1);
bool __fastcall is_nonce_or_reg_value(char); // idb
int __fastcall single_BM1385_check_nonce(unsigned __int8 a1, unsigned __int8 *a2);
int __fastcall single_BM1385_check_register_value(char, int); // idb
int __fastcall single_BM1385_send_func(unsigned __int8 *a1);
int __fastcall single_BM1385_receive_func(unsigned __int8 *a1);
int singleAsicTest_BM1385();
int read_config();
unsigned __int8 __cdecl CRC5(unsigned __int8 *ptr, unsigned __int8 len);
uint16_t __cdecl CRC16(const unsigned __int8 *p_data, uint16_t w_len);
int bitmain_axi_init();
int bitmain_axi_close();
int __fastcall read_axi_fpga(int); // idb
int __fastcall write_axi_fpga(int result, int); // idb
int init_fpga(); // idb
int __fastcall get_return_nonce(int *); // idb
int __fastcall set_BC_command_buffer(int *); // idb
int get_BC_write_command(); // idb
int __fastcall set_BC_write_command(int); // idb
int __fastcall set_TW_write_command(int *); // idb
int __fastcall set_fpga_baud(unsigned __int8); // idb
int cgpu_init();
void Hardware_close();
void *malloc_register_buf(); // idb
int configMiner(); // idb
ssize_t display_arguments(); // idb
void *clear_register_value_buf(); // idb
int __fastcall calculate_core_number(unsigned int); // idb
int __fastcall asic_baud_to_fpga_baud(unsigned __int8); // idb
int __fastcall calculate_how_many_nonce_per_asic_get(unsigned __int8, unsigned __int8, unsigned int); // idb
int display_level_result_on_lcd(); // idb
void *reset_global_arg();
int __fastcall rev(int result, char); // idb
int __fastcall check_hw(_DWORD *, unsigned int, char); // idb
int __fastcall i2c_write(int); // idb
int __fastcall i2c_read(int); // idb
int __fastcall check_how_many_uart_data_in_fpga(unsigned __int8); // idb
int __fastcall read_uart_data_in_fpga(unsigned __int8, int, unsigned int); // idb
unsigned int __fastcall uart_send(unsigned __int8 a1, const void *a2, size_t a3);
int __fastcall uart_receive(unsigned __int8 a1, int a2, unsigned int a3);
int __fastcall clear_uart_send_fifo(unsigned __int8); // idb
int __fastcall clear_uart_rx_fifo(unsigned __int8 a1);
int open_key(); // idb
int close_key(); // idb
int __fastcall read_key(char); // idb
int open_lcd(); // idb
int close_lcd(); // idb
unsigned int __fastcall write_lcd(unsigned int result, int, unsigned int); // idb
unsigned int __fastcall write_lcd_no_memset(unsigned int result, int, unsigned int); // idb
int open_red_led(); // idb
int close_red_led();
ssize_t red_led_on(); // idb
ssize_t red_led_off();
int open_green_led();
int close_green_led();
ssize_t green_led_on();
ssize_t green_led_off();
int __fastcall c2hex(unsigned __int8); // idb
unsigned __int8 __cdecl twoc2hex(unsigned __int8 high, unsigned __int8 low);
int __fastcall s2hex(_BYTE *, _BYTE *, int); // idb
int print_works();
int __fastcall get_work(int a1, int a2);
unsigned int __fastcall get_work_hash_board(int a1, int a2, FILE *a3, unsigned int a4);
int get_works();
int clear_nonce_return_flag();
int __fastcall write_pic(unsigned __int8, unsigned __int8, unsigned __int8); // idb
int __fastcall read_pic(unsigned __int8, unsigned __int8); // idb
int __fastcall set_PIC16F1704_flash_point32_ter(char, char, unsigned __int8, unsigned __int8); // idb
int __fastcall send_data_to_PIC16F1704(char, char, int); // idb
int __fastcall read_PIC16F1704_flash_point32_ter(char, char, unsigned __int8 *, unsigned __int8 *); // idb
int __fastcall read_PIC16F1704_flash_data(char, char, int); // idb
int __fastcall erase_PIC16F1704_flash(unsigned __int8, unsigned __int8); // idb
int __fastcall write_data_into_PIC16F1704_flash(unsigned __int8, unsigned __int8); // idb
int __fastcall jump_from_loader_to_app_PIC16F1704(char, char); // idb
int __fastcall reset_PIC16F1704_pic(char, char); // idb
int __fastcall set_PIC16F1704_voltage(unsigned __int8, unsigned __int8, unsigned __int8); // idb
int __fastcall write_hash_ID_PIC16F1704(unsigned __int8, unsigned __int8, int); // idb
int __fastcall read_hash_id_PIC16F1704(unsigned __int8, unsigned __int8, int); // idb
int __fastcall enable_PIC16F1704_dc_dc(char, char, unsigned __int8); // idb
int __fastcall heart_beat_PIC16F1704(char, char); // idb
void __fastcall __noreturn pic_heart_beat_func(char *); // idb
int __fastcall get_PIC16F1704_software_version(unsigned __int8, unsigned __int8, unsigned __int8 *); // idb
int __fastcall get_PIC16F1704_voltage(unsigned __int8, unsigned __int8, unsigned __int8 *); // idb
int __fastcall write_temperature_offset_PIC16F1704(unsigned __int8, unsigned __int8, int); // idb
int __fastcall read_temperature_offset_PIC16F1704(unsigned __int8, unsigned __int8, int); // idb
int __fastcall erase_PIC16F1704_app_flash(char, char); // idb
int __fastcall PIC1704_update_pic_app_program(char, char); // idb
int __fastcall save_freq_PIC16F1704(unsigned __int8, unsigned __int8, unsigned __int16); // idb
int __fastcall get_PIC16F1704_freq(unsigned __int8, unsigned __int8, unsigned __int16 *); // idb
int __fastcall set_temperature_offset_value(char, char, int); // idb
int __fastcall write_sensor_info_into_pic(char a1, char a2);
int check_chain();
int get_fan_speed();
int __fastcall set_fan_speed(int a1);
int __fastcall fan_control(char); // idb
int reset_hash_board(); // idb
void __cdecl sha256_transf(sha256_ctx *ctx, const unsigned __int8 *message, unsigned int block_nb);
void __cdecl sha256(const unsigned __int8 *message, unsigned int len, unsigned __int8 *digest);
void __cdecl sha256_init(sha256_ctx *ctx);
void __cdecl sha256_update(sha256_ctx *ctx, const unsigned __int8 *message, unsigned int len);
void __cdecl sha256_final(sha256_ctx *ctx, unsigned __int8 *digest);
void __cdecl sha2_starts(sha2_context *ctx);
void __cdecl sha2_process(sha2_context *ctx, const unsigned __int8 *data);
void __cdecl sha2_update(sha2_context *ctx, const unsigned __int8 *input, int ilen);
void __cdecl sha2_finish(sha2_context *ctx, unsigned __int8 *output);
void __cdecl sha2(const unsigned __int8 *input, int ilen, unsigned __int8 *output);
unsigned int __fastcall swab32(unsigned int a1);
void __cdecl flip_swab(void *dest_p, const void *src_p, unsigned int length);
void __cdecl flip32(void *dest_p, const void *src_p);
int __fastcall read_temperature_from_fpga_register(unsigned __int8); // idb
int __fastcall read_temperature_through_fpga_iic_register(unsigned __int8 a1, int a2);
void *reset_V9_global_arg();
int __fastcall V9_set_voltage(unsigned __int8, unsigned __int8, char); // idb
int V9_calculate_timeout_and_baud();
int __fastcall V9_set_address(unsigned __int8 a1);
int __fastcall V9_set_baud(unsigned __int8 a1, unsigned __int8 a2);
int __fastcall V9_open_core(unsigned __int8); // idb
int __fastcall V9_get_result(unsigned __int8 a1);
unsigned int __fastcall V9_print_lcd(char); // idb
void __fastcall __noreturn V9_show_status_func(unsigned __int8 *a1);
int __fastcall v9_check_nonce(unsigned __int8 a1, unsigned __int8 *a2);
int __fastcall V9_check_register_value(char a1, int a2);
int __fastcall V9_send_func(unsigned __int8 *a1);
int __fastcall V9_receive_func(unsigned __int8 *); // idb
unsigned int singleBoardTest_V9_BM1385_45();
int _aeabi_ldiv0();
__int64 init();
int _libc_csu_fini(); // weak
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

void *jpt_D59A[10] =
{
  (void *)0xD5C9,
  (void *)0xD5D7,
  (void *)0xD5E5,
  (void *)0xD5F3,
  (void *)0xD601,
  (void *)0xD60F,
  (void *)0xD61D,
  (void *)0xD62B,
  (void *)0xD639,
  (void *)0xD647
}; // weak
void *jpt_D85C[10] =
{
  (void *)0xD889,
  (void *)0xD8A9,
  (void *)0xD8C9,
  (void *)0xD8E9,
  (void *)0xD909,
  (void *)0xD929,
  (void *)0xD949,
  (void *)0xD969,
  (void *)0xD989,
  (void *)0xD9A9
}; // weak
void *jpt_173C6[9] =
{
  (void *)0x173F1,
  (void *)0x17401,
  (void *)0x17411,
  (void *)0x17421,
  (void *)0x17431,
  (void *)0x17441,
  (void *)0x17451,
  (void *)0x17461,
  (void *)0x17471
}; // weak
_BYTE chCRCHTalbe[256] =
{
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64
}; // weak
_BYTE chCRCLTalbe[256] =
{
  0,
  -64,
  -63,
  1,
  -61,
  3,
  2,
  -62,
  -58,
  6,
  7,
  -57,
  5,
  -59,
  -60,
  4,
  -52,
  12,
  13,
  -51,
  15,
  -49,
  -50,
  14,
  10,
  -54,
  -53,
  11,
  -55,
  9,
  8,
  -56,
  -40,
  24,
  25,
  -39,
  27,
  -37,
  -38,
  26,
  30,
  -34,
  -33,
  31,
  -35,
  29,
  28,
  -36,
  20,
  -44,
  -43,
  21,
  -41,
  23,
  22,
  -42,
  -46,
  18,
  19,
  -45,
  17,
  -47,
  -48,
  16,
  -16,
  48,
  49,
  -15,
  51,
  -13,
  -14,
  50,
  54,
  -10,
  -9,
  55,
  -11,
  53,
  52,
  -12,
  60,
  -4,
  -3,
  61,
  -1,
  63,
  62,
  -2,
  -6,
  58,
  59,
  -5,
  57,
  -7,
  -8,
  56,
  40,
  -24,
  -23,
  41,
  -21,
  43,
  42,
  -22,
  -18,
  46,
  47,
  -17,
  45,
  -19,
  -20,
  44,
  -28,
  36,
  37,
  -27,
  39,
  -25,
  -26,
  38,
  34,
  -30,
  -29,
  35,
  -31,
  33,
  32,
  -32,
  -96,
  96,
  97,
  -95,
  99,
  -93,
  -94,
  98,
  102,
  -90,
  -89,
  103,
  -91,
  101,
  100,
  -92,
  108,
  -84,
  -83,
  109,
  -81,
  111,
  110,
  -82,
  -86,
  106,
  107,
  -85,
  105,
  -87,
  -88,
  104,
  120,
  -72,
  -71,
  121,
  -69,
  123,
  122,
  -70,
  -66,
  126,
  127,
  -65,
  125,
  -67,
  -68,
  124,
  -76,
  116,
  117,
  -75,
  119,
  -73,
  -74,
  118,
  114,
  -78,
  -77,
  115,
  -79,
  113,
  112,
  -80,
  80,
  -112,
  -111,
  81,
  -109,
  83,
  82,
  -110,
  -106,
  86,
  87,
  -105,
  85,
  -107,
  -108,
  84,
  -100,
  92,
  93,
  -99,
  95,
  -97,
  -98,
  94,
  90,
  -102,
  -101,
  91,
  -103,
  89,
  88,
  -104,
  -120,
  72,
  73,
  -119,
  75,
  -117,
  -118,
  74,
  78,
  -114,
  -113,
  79,
  -115,
  77,
  76,
  -116,
  68,
  -124,
  -123,
  69,
  -121,
  71,
  70,
  -122,
  -126,
  66,
  67,
  -125,
  65,
  -127,
  128,
  64
}; // weak
unsigned __int8 sha2_padding[64] =
{
  128u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // weak
char *Single_BM1385_WorkDataPathPrefix[2] = { "/mnt/card/single-BM1385-ASIC-test", "19" }; // weak
char *freq_pll_1385 = "19"; // weak
char *BTC_WorkDataFilePrefix = "/btc-core-"; // weak
char gChain = '\xFF'; // weak
_BYTE lcd_buffer[16] = { 32, 32, 32, 76, 101, 118, 101, 108, 58, 32, 32, 32, 32, 32, 32, 32 }; // weak
char lcd_output[2] = " "; // weak
char s[16] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_259B8[32] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
_DWORD sha256_h0[8] =
{
  1779033703,
  -1150833019,
  1013904242,
  -1521486534,
  1359893119,
  -1694144372,
  528734635,
  1541459225
}; // weak
_DWORD sha256_k[64] =
{
  1116352408,
  1899447441,
  -1245643825,
  -373957723,
  961987163,
  1508970993,
  -1841331548,
  -1424204075,
  -670586216,
  310598401,
  607225278,
  1426881987,
  1925078388,
  -2132889090,
  -1680079193,
  -1046744716,
  -459576895,
  -272742522,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  -1740746414,
  -1473132947,
  -1341970488,
  -1084653625,
  -958395405,
  -710438585,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  -2117940946,
  -1838011259,
  -1564481375,
  -1474664885,
  -1035236496,
  -949202525,
  -778901479,
  -694614492,
  -200395387,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  -2067236844,
  -1933114872,
  -1866530822,
  -1538233109,
  -1090935817,
  -965641998
}; // weak
char *V9_WorkDataPathPrefix = "/mnt/card/minertest64-BM1385/btc-asic-"; // weak
char completed_8605; // weak
char run_status; // weak
int fpga_mem_addr; // weak
int axi_fpga_addr; // weak
char gHashBoard_V9; // weak
char gHashBoard_S9; // weak
char gHashBoard_T9; // weak
char gHashBoard_T9_plus; // weak
char gHashBoard_R4; // weak
char gHashBoard_S11; // weak
char gI2c; // weak
int gPic_addr_high_4_bit; // weak
int gSensor_i2c_addr_high_4_bit; // weak
char gHowManyVoltageLevel; // weak
char pattern_test_time; // weak
int time_counter; // weak
int gName_len; // weak
int gSensor_number; // weak
int gHighest_Temp; // weak
int gChain_Asic_Interval; // weak
int gPattern_number; // weak
char gStartTest; // weak
char gBegin_Get_Nonce; // weak
char gIsOpenCoreEnd; // weak
char gIsOpeningCore; // weak
char gHigherThanAlarmTemp; // weak
char start_receive; // weak
_DWORD gValid_Nonce_Num[16]; // weak
_DWORD gHw_Nonce_Num[16]; // weak
_DWORD gSend_Work_Num[16]; // weak
_DWORD gAsic_Core_Nonce_Num[11345]; // weak
_UNKNOWN unk_30D40; // weak
_UNKNOWN unk_493E0; // weak
_UNKNOWN unk_61A80; // weak
_UNKNOWN unk_7A120; // weak
_UNKNOWN unk_F4240; // weak
_DWORD gRepeated_Nonce_Id[16]; // weak
_BYTE gSensor_OK[64]; // weak
char gWork_Num_For_Hw_Check; // weak
pthread_mutex_t reg_mutex; // weak
pthread_mutex_t HW_check_mutex[16]; // weak
pthread_mutex_t uart_send_mutex[16]; // weak
pthread_mutex_t uart_receive_mutex[16]; // weak
int key_fd; // weak
int lcd_fd; // weak
int red_led_fd; // weak
int green_led_fd; // weak
pthread_mutex_t i2c_mutex; // weak
_UNKNOWN cgpu; // weak
pthread_t dword_136140; // idb
pthread_t dword_136144; // idb
pthread_t newthread; // idb
pthread_t dword_13614C; // idb
int dword_136168; // weak
char dest[64]; // idb
char byte_1361AC[576]; // idb
int dword_1363EC; // weak
int dword_1463EC; // weak
int dword_14642C; // weak
int dword_14648C; // weak
_BYTE chain_info[32]; // weak
int reg_value_buf; // weak
_UNKNOWN Conf; // weak
int dword_1464FC; // weak
int dword_146500; // weak
int dword_146504; // weak
int dword_146508; // weak
int dword_14650C; // weak
int dword_146510; // weak
int dword_146514; // weak
int dword_146518; // weak
int dword_14651C; // weak
int dword_146520; // weak
int dword_146524; // weak
int dword_146528; // weak
int dword_14652C; // weak
int dword_146530; // weak
int dword_146558; // weak
int dword_14655C; // weak
int dword_146560; // weak
int dword_146564; // weak
int dword_146568; // weak
int dword_14656C; // weak
int dword_146570; // weak
int dword_146574; // weak
int dword_146578; // weak
int dword_14657C; // weak
int dword_146580; // weak
int dword_146588; // weak
int dword_14658C; // weak
int dword_146590; // weak
int dword_146594; // weak
char byte_146598; // weak
char byte_146599; // weak
char byte_14659A; // weak
char byte_14659C; // weak
char byte_14659E; // weak
int dword_1465A0; // weak
char byte_1465A8; // weak
int dword_1465AC; // weak
int dword_1465B0; // weak
char byte_1465B4; // weak
int dword_1465B8; // weak
int dword_1465BC; // weak
int fd_fpga_mem; // weak
_DWORD gWorks_For_Hw_Check[4640]; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (000088A4) --------------------------------------------------------
int init_proc()
{
  return call_gmon_start();
}

//----- (000088B0) --------------------------------------------------------
void sub_88B0()
{
  JUMPOUT(0);
}
// 88BC: control flows out of bounds to 0

//----- (000089C0) --------------------------------------------------------
// attributes: thunk
int j___gmon_start__()
{
  return _gmon_start__();
}
// 89C4: using guessed type int _gmon_start__(void);

//----- (00008A90) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __noreturn start(void (*a1)(void), int a2, int a3, int a4, ...)
{
  int v4; // [sp-4h] [bp-4h]
  va_list va; // [sp+0h] [bp+0h] BYREF

  va_start(va, a4);
  _libc_start_main(
    (int (__fastcall *)(int, char **, char **))main,
    v4,
    (char **)va,
    (void (*)(void))init,
    (void (*)(void))_libc_csu_fini,
    a1,
    va);
  abort();
}
// 8A9C: positive sp value 4 has been found
// 8AB2: variable 'v4' is possibly undefined
// 19434: using guessed type int init();
// 19478: using guessed type int _libc_csu_fini();

//----- (00008AC8) --------------------------------------------------------
int call_gmon_start()
{
  int result; // r0

  if ( &__gmon_start__ )
    return j___gmon_start__();
  return result;
}

//----- (00008AE0) --------------------------------------------------------
char *deregister_tm_clones()
{
  return &completed_8605;
}
// 25AFC: using guessed type char completed_8605;

//----- (00008B04) --------------------------------------------------------
__int64 register_tm_clones()
{
  __int64 result; // r0

  LODWORD(result) = &completed_8605;
  HIDWORD(result) = 0;
  return result;
}
// 25AFC: using guessed type char completed_8605;

//----- (00008B30) --------------------------------------------------------
char *_do_global_dtors_aux()
{
  char *result; // r0

  if ( !completed_8605 )
  {
    result = deregister_tm_clones();
    completed_8605 = 1;
  }
  return result;
}
// 25AFC: using guessed type char completed_8605;

//----- (00008B48) --------------------------------------------------------
__int64 frame_dummy()
{
  return register_tm_clones();
}

//----- (00008B68) --------------------------------------------------------
int __cdecl main(int argc, const char **argv, const char **envp)
{
  char v5[64]; // [sp+0h] [bp+0h] BYREF
  int v6; // [sp+40h] [bp+40h]
  int v7; // [sp+44h] [bp+44h]

  v7 = -1;
  memset(v5, 0, sizeof(v5));
  v6 = cgpu_init();
  if ( v6 < 0 )
    return v6;
  v6 = configMiner();
  if ( v6 >= 0 )
  {
    run_status = 0;
    display_arguments();
    while ( 1 )
    {
      while ( 1 )
      {
        lseek(key_fd, 0, 0);
        v6 = read(key_fd, v5, 0x40u);
        if ( dword_146528 != 1 )
          break;
        if ( v6 > 0 && v5[0] == 48 )
        {
          if ( dword_146530 == 1385 )
          {
            puts("\nBegin singleAsicTest_BM1385\n");
            singleAsicTest_BM1385();
          }
          else
          {
            printf("Single ASIC test: Can't find ASIC type!!! AsicType = %d\n", dword_146530);
          }
        }
      }
      if ( v6 > 0 && v5[0] == 48
        || (unsigned __int8)pattern_test_time < (unsigned int)(unsigned __int8)gHowManyVoltageLevel && pattern_test_time )
      {
        usleep(0x2710u);
        if ( gHashBoard_V9 )
          singleBoardTest_V9_BM1385_45();
        else
          printf("%s: Please config HashBoard name in Config.ini\n", "main");
      }
      if ( (unsigned __int8)pattern_test_time >= (unsigned int)(unsigned __int8)gHowManyVoltageLevel )
        pattern_test_time = 0;
    }
  }
  return v6;
}
// 25AFD: using guessed type char run_status;
// 25B08: using guessed type char gHashBoard_V9;
// 25B18: using guessed type char gHowManyVoltageLevel;
// 25B19: using guessed type char pattern_test_time;
// 126118: using guessed type int key_fd;
// 146528: using guessed type int dword_146528;
// 146530: using guessed type int dword_146530;

//----- (00008CD0) --------------------------------------------------------
int __fastcall get_BM1385_plldata(int a1, _DWORD *a2, unsigned __int16 *a3, _DWORD *a4)
{
  char v8[32]; // [sp+18h] [bp+10h] BYREF
  char v9[32]; // [sp+38h] [bp+30h] BYREF
  char v10[32]; // [sp+58h] [bp+50h] BYREF
  char v11[12]; // [sp+78h] [bp+70h] BYREF
  unsigned int i; // [sp+84h] [bp+7Ch]

  memset(v10, 0, sizeof(v10));
  memset(v9, 0, sizeof(v9));
  memset(v8, 0, sizeof(v8));
  sprintf(v11, "%d", a1);
  for ( i = 0; i <= 0x7B && memcmp((&freq_pll_1385)[4 * i], v11, 4u); ++i )
    ;
  printf("%s: i = %d, sizeof(freq_pll_1385)/sizeof(freq_pll_1385[0]) = %d\n", "get_BM1385_plldata", i, 124);
  if ( i == 124 )
  {
    printf("%s: Freq set Err!!!!\n", "get_BM1385_plldata");
    printf("%s: Using 200M\n", "get_BM1385_plldata");
    i = 4;
  }
  sprintf(v10, "%08x", (&freq_pll_1385)[4 * i + 1]);
  sprintf(v9, "%04x", (&freq_pll_1385)[4 * i + 2]);
  sprintf(v8, "%04x", (&freq_pll_1385)[4 * i + 3]);
  printf("%s: Freq %s, PLL1 %s, PLL2 %s, vilpll %s\n", "get_BM1385_plldata", v11, v10, v9, v8);
  *a2 = (&freq_pll_1385)[4 * i + 1];
  *a3 = (unsigned __int16)(&freq_pll_1385)[4 * i + 2];
  *a4 = (&freq_pll_1385)[4 * i + 3];
  return printf("%s: PLL1 %#x, PLL2 %#x, vilpll %#x\n", "get_BM1385_plldata", *a2, *a3, *a4);
}
// 251B0: using guessed type char *freq_pll_1385;

//----- (00008F1C) --------------------------------------------------------
unsigned int __fastcall read_BM1385_asic_register(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, char a4)
{
  unsigned __int8 v6; // [sp+1Ch] [bp+14h] BYREF
  unsigned __int8 v7; // [sp+1Dh] [bp+15h]
  unsigned __int8 v8; // [sp+1Eh] [bp+16h]
  unsigned __int8 v9; // [sp+1Fh] [bp+17h]

  v9 = 0;
  v6 = 4;
  v7 = a2;
  v8 = a3;
  if ( a4 )
    v6 |= 0x80u;
  v9 = CRC5(&v6, 0x1Bu);
  printf("%s: buf[0]=0x%x, buf[1]=0x%x, buf[2]=0x%x, buf[3]=0x%x\n", "read_BM1385_asic_register", v6, v7, v8, v9);
  return uart_send(a1, &v6, 4u);
}

//----- (00008FB0) --------------------------------------------------------
int __fastcall set_BM1385_freq(unsigned __int8 a1, char a2, int a3, char a4)
{
  char v4; // r4
  char v5; // r4
  unsigned __int16 v11; // [sp+Eh] [bp+Eh] BYREF
  int v12; // [sp+10h] [bp+10h] BYREF
  int v13[4]; // [sp+14h] [bp+14h] BYREF
  char v14[4]; // [sp+24h] [bp+24h] BYREF
  int v15; // [sp+28h] [bp+28h]
  int v16; // [sp+2Ch] [bp+2Ch]

  v14[0] = 0;
  v14[1] = 0;
  v14[2] = 0;
  v14[3] = 0;
  memset(v13, 0, sizeof(v13));
  v12 = 0;
  v16 = 0;
  v15 = 0;
  v11 = 0;
  printf("\n--- %s\n", "set_BM1385_freq");
  get_BM1385_plldata(a3, v13, &v11, &v12);
  v14[0] = 7;
  v14[1] = BYTE2(v13[0]);
  v14[2] = BYTE1(v13[0]);
  v14[3] = v13[0];
  v4 = v13[0];
  v14[3] = CRC5((unsigned __int8 *)v14, 0x1Bu) | v4;
  uart_send(a1, v14, 4u);
  usleep(0xBB8u);
  memset(v14, 0, sizeof(v14));
  memset(&v13[1], 0, 0xCu);
  if ( a4 )
    v14[0] |= 0x80u;
  v14[0] |= 2u;
  v14[1] = a2;
  v14[2] = HIBYTE(v11);
  v14[3] = v11;
  v5 = v11;
  v14[3] = CRC5((unsigned __int8 *)v14, 0x1Bu) | v5;
  uart_send(a1, v14, 4u);
  return usleep(0x1388u);
}

//----- (00009108) --------------------------------------------------------
void *__fastcall check_BM1385_asic_reg(unsigned __int8 a1, int a2, unsigned __int8 a3, char a4)
{
  int v4; // r0
  char v9[8]; // [sp+Ch] [bp+Ch] BYREF
  unsigned int v10; // [sp+14h] [bp+14h]
  unsigned int i; // [sp+18h] [bp+18h]
  unsigned int v12; // [sp+1Ch] [bp+1Ch]

  v9[0] = 0;
  v9[1] = 0;
  v9[2] = 0;
  v9[3] = 0;
  v9[4] = 0;
  v12 = 0;
  v10 = 0;
  i = 0;
  clear_register_value_buf();
  printf("%s: check chain J%d \n", "check_BM1385_asic_reg", a1 + 1);
  read_BM1385_asic_register(a1, 0, a3, a4);
  if ( !a3 )
    *((_BYTE *)&cgpu + a1 + 131896) = 0;
  while ( v12 <= 2 )
  {
    usleep((__useconds_t)&unk_493E0);
    pthread_mutex_lock(&reg_mutex);
    v10 = *(_DWORD *)(reg_value_buf + 8);
    pthread_mutex_unlock(&reg_mutex);
    if ( v10 )
    {
      v12 = 0;
      for ( i = 0; i < v10; ++i )
      {
        pthread_mutex_lock(&reg_mutex);
        if ( a1 == *(unsigned __int8 *)(reg_value_buf + 8 * (*(_DWORD *)(reg_value_buf + 4) + 2) + 5) )
        {
          memset(v9, 0, 5u);
          v9[3] = *(_DWORD *)(reg_value_buf + 8 * (*(_DWORD *)(reg_value_buf + 4) + 2));
          v9[2] = BYTE1(*(_DWORD *)(reg_value_buf + 8 * (*(_DWORD *)(reg_value_buf + 4) + 2)));
          v9[1] = BYTE2(*(_DWORD *)(reg_value_buf + 8 * (*(_DWORD *)(reg_value_buf + 4) + 2)));
          v9[0] = HIBYTE(*(_DWORD *)(reg_value_buf + 8 * (*(_DWORD *)(reg_value_buf + 4) + 2)));
          if ( CRC5((unsigned __int8 *)v9, 0x23u) == *(unsigned __int8 *)(reg_value_buf
                                                                        + 8 * (*(_DWORD *)(reg_value_buf + 4) + 2)
                                                                        + 4) )
          {
            if ( !a3 )
              ++*((_BYTE *)&cgpu + a1 + 131896);
            if ( a3 == 12 )
              printf(
                "%s: the asic freq is 0x%08x\n",
                "check_BM1385_asic_reg",
                *(_DWORD *)(reg_value_buf + 8 * (*(_DWORD *)(reg_value_buf + 4) + 2)));
            ++*(_DWORD *)(reg_value_buf + 4);
            --*(_DWORD *)(reg_value_buf + 8);
            if ( *(_DWORD *)(reg_value_buf + 4) == 512 )
              *(_DWORD *)(reg_value_buf + 4) = 0;
            pthread_mutex_unlock(&reg_mutex);
          }
          else
          {
            ++*(_DWORD *)(reg_value_buf + 4);
            --*(_DWORD *)(reg_value_buf + 8);
            if ( *(_DWORD *)(reg_value_buf + 4) == 512 )
              *(_DWORD *)(reg_value_buf + 4) = 0;
            v4 = CRC5((unsigned __int8 *)v9, 0x23u);
            printf(
              "%s: crc is 0x%x, but it should be 0x%x\n",
              "check_BM1385_asic_reg",
              v4,
              *(unsigned __int8 *)(reg_value_buf + 8 * (*(_DWORD *)(reg_value_buf + 4) + 2) + 4));
            pthread_mutex_unlock(&reg_mutex);
          }
        }
        else
        {
          ++*(_DWORD *)(reg_value_buf + 4);
          --*(_DWORD *)(reg_value_buf + 8);
          if ( *(_DWORD *)(reg_value_buf + 4) == 512 )
            *(_DWORD *)(reg_value_buf + 4) = 0;
          printf(
            "%s: the return data is from chain%d, but it should be from chain%d\n",
            "check_BM1385_asic_reg",
            *(unsigned __int8 *)(reg_value_buf + 8 * (*(_DWORD *)(reg_value_buf + 4) + 2) + 5),
            a1);
          pthread_mutex_unlock(&reg_mutex);
        }
      }
    }
    else
    {
      usleep(0x186A0u);
      printf("%s: no asic address register come back for %d time.\n", "check_BM1385_asic_reg", ++v12);
    }
  }
  v12 = 0;
  if ( !a3 )
  {
    if ( *((unsigned __int8 *)&cgpu + a1 + 131896) > (unsigned int)dword_14648C )
      dword_14648C = *((unsigned __int8 *)&cgpu + a1 + 131896);
    printf("%s: chain J%d has %d ASIC\n", "check_BM1385_asic_reg", a1 + 1, *((unsigned __int8 *)&cgpu + a1 + 131896));
  }
  return clear_register_value_buf();
}
// 125C80: using guessed type pthread_mutex_t reg_mutex;
// 14648C: using guessed type int dword_14648C;
// 1464B8: using guessed type int reg_value_buf;

//----- (0000956C) --------------------------------------------------------
int __fastcall BM1385_chain_inactive(unsigned __int8 a1)
{
  unsigned __int8 v3[3]; // [sp+14h] [bp+14h] BYREF
  unsigned __int8 v4; // [sp+17h] [bp+17h]

  v4 = 0;
  v3[0] = -123;
  v3[1] = 0;
  v3[2] = 0;
  v4 = CRC5(v3, 0x1Bu);
  uart_send(a1, v3, 4u);
  return usleep(0x1388u);
}

//----- (000095D0) --------------------------------------------------------
unsigned int __fastcall BM1385_set_address(unsigned __int8 a1, unsigned __int8 a2)
{
  unsigned __int8 v4[3]; // [sp+14h] [bp+14h] BYREF
  unsigned __int8 v5; // [sp+17h] [bp+17h]

  v5 = 0;
  v4[0] = 1;
  v4[1] = a2;
  v4[2] = 0;
  v5 = CRC5(v4, 0x1Bu);
  return uart_send(a1, v4, 4u);
}

//----- (00009630) --------------------------------------------------------
unsigned int __fastcall BM1385_set_baud(unsigned __int8 a1, char a2, char a3, char a4)
{
  unsigned __int8 v6; // [sp+14h] [bp+14h] BYREF
  char v7; // [sp+15h] [bp+15h]
  char v8; // [sp+16h] [bp+16h]
  unsigned __int8 v9; // [sp+17h] [bp+17h]

  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  if ( a4 )
    v6 |= 0x80u;
  v6 |= 6u;
  v7 = a2;
  v8 = a3 & 0x1F;
  v9 = CRC5(&v6, 0x1Bu);
  return uart_send(a1, &v6, 4u);
}

//----- (000096AC) --------------------------------------------------------
int __fastcall BM1385_set_gateblk(unsigned __int8 a1, int a2, char a3)
{
  unsigned __int8 v5; // [sp+18h] [bp+18h] BYREF
  char v6; // [sp+19h] [bp+19h]
  char v7; // [sp+1Ah] [bp+1Ah]
  char v8; // [sp+1Bh] [bp+1Bh]
  char v9; // [sp+1Fh] [bp+1Fh]

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  if ( a3 )
    v5 |= 0x80u;
  v5 |= 6u;
  v6 = 0;
  v7 = dword_1465BC | 0x80;
  v8 = 0;
  v9 = CRC5(&v5, 0x1Bu) & 0x1F;
  v8 |= v9;
  uart_send(a1, &v5, 4u);
  return usleep(0x2710u);
}
// 1465BC: using guessed type int dword_1465BC;

//----- (00009754) --------------------------------------------------------
int reset_single_BM1385_global_arg()
{
  int result; // r0
  int v1; // [sp+8h] [bp+8h]
  unsigned int v2; // [sp+14h] [bp+14h]
  unsigned int v3; // [sp+18h] [bp+18h]
  unsigned int v4; // [sp+1Ch] [bp+1Ch]
  unsigned int v5; // [sp+20h] [bp+20h]
  unsigned int v6; // [sp+24h] [bp+24h]
  unsigned int k; // [sp+28h] [bp+28h]
  unsigned int i; // [sp+2Ch] [bp+2Ch]
  unsigned int m; // [sp+30h] [bp+30h]
  unsigned int j; // [sp+34h] [bp+34h]

  v6 = 0;
  v5 = dword_146588;
  v4 = dword_14658C;
  v3 = dword_146590;
  v2 = dword_146594;
  reset_global_arg();
  result = printf("\n--- %s\n", "reset_single_BM1385_global_arg");
  for ( i = 0; i <= 0x1F; ++i )
  {
    if ( (v5 & 1) != 0 )
      ++v6;
    v5 >>= 1;
    if ( (v4 & 1) != 0 )
      ++v6;
    v4 >>= 1;
    if ( (v3 & 1) != 0 )
      ++v6;
    v3 >>= 1;
    if ( (v2 & 1) != 0 )
      ++v6;
    v2 >>= 1;
  }
  for ( j = 0; j <= 0xF; ++j )
  {
    *((_BYTE *)&cgpu + j + 131896) = 0;
    gRepeated_Nonce_Id[j] = 0;
    gValid_Nonce_Num[j] = 0;
    gSend_Work_Num[j] = 0;
    for ( k = 0; k < v6; ++k )
    {
      v1 = *((_DWORD *)&cgpu + k + 16427);
      for ( m = 0; dword_1464FC > m; ++m )
        *(_DWORD *)(v1 + 116 * m + 4 * (j + 12) + 4) = 0;
      gAsic_Core_Nonce_Num[0x4000 * j + k] = 0;
    }
  }
  return result;
}
// 25B3C: using guessed type _DWORD gValid_Nonce_Num[16];
// 25BBC: using guessed type _DWORD gSend_Work_Num[16];
// 25BFC: using guessed type _DWORD gAsic_Core_Nonce_Num[11345];
// 125BFC: using guessed type _DWORD gRepeated_Nonce_Id[16];
// 1464FC: using guessed type int dword_1464FC;
// 146588: using guessed type int dword_146588;
// 14658C: using guessed type int dword_14658C;
// 146590: using guessed type int dword_146590;
// 146594: using guessed type int dword_146594;

//----- (00009914) --------------------------------------------------------
unsigned int single_BM1385_calculate_timeout_and_baud()
{
  unsigned int result; // r0
  unsigned int v1; // [sp+4h] [bp+4h]
  unsigned int v2; // [sp+Ch] [bp+Ch]

  v2 = 0;
  printf("\n--- %s\n", "single_BM1385_calculate_timeout_and_baud");
  v1 = calculate_core_number(0x32u);
  switch ( pattern_test_time )
  {
    case 0:
      v2 = dword_146504;
      break;
    case 1:
      v2 = dword_146508;
      break;
    case 2:
      v2 = dword_14650C;
      break;
    case 3:
      v2 = dword_146510;
      break;
    case 4:
      v2 = dword_146514;
      break;
    case 5:
      v2 = dword_146518;
      break;
    case 6:
      v2 = dword_14651C;
      break;
    case 7:
      v2 = dword_146520;
      break;
    case 8:
      v2 = dword_146524;
      break;
    default:
      printf(
        "%s: pattern_test_time = %d, error!!! \n",
        "single_BM1385_calculate_timeout_and_baud",
        (unsigned __int8)pattern_test_time);
      break;
  }
  dword_146580 = 95 * (gChain_Asic_Interval * (0x1000000 / v1) / v2) / 0x64;
  result = 0x2FAF08 / ((0x196E6Au / dword_146580) << 9);
  dword_1465BC = result - 1;
  if ( result - 1 > 0x1A )
    dword_1465BC = 26;
  dword_146500 = v2;
  dword_146580 = 10000;
  return result;
}
// 25B19: using guessed type char pattern_test_time;
// 25B2C: using guessed type int gChain_Asic_Interval;
// 146500: using guessed type int dword_146500;
// 146504: using guessed type int dword_146504;
// 146508: using guessed type int dword_146508;
// 14650C: using guessed type int dword_14650C;
// 146510: using guessed type int dword_146510;
// 146514: using guessed type int dword_146514;
// 146518: using guessed type int dword_146518;
// 14651C: using guessed type int dword_14651C;
// 146520: using guessed type int dword_146520;
// 146524: using guessed type int dword_146524;
// 146580: using guessed type int dword_146580;
// 1465BC: using guessed type int dword_1465BC;

//----- (00009AE8) --------------------------------------------------------
unsigned int __fastcall BM1722_set_address_all(unsigned __int8 a1)
{
  unsigned int result; // r0
  unsigned int i; // [sp+8h] [bp+8h]
  int v4; // [sp+Ch] [bp+Ch]

  v4 = 0;
  printf("\n--- %s: Chain : %d\n", "single_BM1385_set_address", a1);
  BM1385_chain_inactive(a1);
  for ( i = 0; ; ++i )
  {
    result = 0x100u / gChain_Asic_Interval;
    if ( 0x100u / gChain_Asic_Interval <= i )
      break;
    BM1385_set_address(a1, v4);
    v4 += gChain_Asic_Interval;
    usleep(0x1388u);
  }
  return result;
}
// 25B2C: using guessed type int gChain_Asic_Interval;

//----- (00009B74) --------------------------------------------------------
int __fastcall single_BM1385_set_baud(unsigned __int8 a1, unsigned __int8 a2)
{
  printf("\n--- %s: Chain : %d, baud = %d\n", "single_BM1385_set_baud", a1, a2);
  BM1385_set_baud(a1, 0, a2, 1);
  usleep(0xC350u);
  return set_fpga_baud(a2);
}

//----- (00009BC4) --------------------------------------------------------
int __fastcall single_BM1385_open_core(unsigned __int8 a1)
{
  int result; // r0
  char v3[64]; // [sp+Ch] [bp+Ch] BYREF
  int v4; // [sp+4Ch] [bp+4Ch]
  int v5; // [sp+50h] [bp+50h]
  int v6; // [sp+54h] [bp+54h]
  int v7; // [sp+58h] [bp+58h]
  int v8; // [sp+5Ch] [bp+5Ch]
  int v9; // [sp+60h] [bp+60h]
  int v10; // [sp+64h] [bp+64h]
  int v11; // [sp+68h] [bp+68h]
  unsigned int v12; // [sp+6Ch] [bp+6Ch]
  unsigned int v13; // [sp+70h] [bp+70h]
  unsigned int i; // [sp+74h] [bp+74h]

  i = 0;
  v11 = 0;
  v10 = 0;
  v9 = 0;
  v8 = 0;
  v7 = 0;
  v6 = 0;
  memset(v3, 0, sizeof(v3));
  v3[0] = -1;
  v13 = dword_146588;
  v12 = dword_14658C;
  v5 = dword_146590;
  v4 = dword_146594;
  printf("\n--- %s: Chain : %d\n", "single_BM1385_open_core", a1);
  gIsOpenCoreEnd = 0;
  memset(v3, 0, sizeof(v3));
  BM1385_set_gateblk(a1, 0, 1);
  for ( i = 0; i <= 0x31; ++i )
  {
    uart_send(a1, v3, 0x40u);
    usleep(dword_14657C);
  }
  memset(v3, 0, sizeof(v3));
  result = BM1385_set_gateblk(a1, 0, 1);
  for ( i = 0; i <= 0x31; ++i )
  {
    if ( i > 0x1F )
    {
      if ( (v12 & 1) != 0 )
        v3[52] = -1;
      v12 >>= 1;
    }
    else
    {
      if ( (v13 & 1) != 0 )
        v3[52] = -1;
      v13 >>= 1;
    }
    uart_send(a1, v3, 0x40u);
    result = usleep(dword_14657C);
  }
  gIsOpenCoreEnd = 1;
  return result;
}
// 9CEA: conditional instruction was optimized away because %var_4.4 is in (20..31)
// 9CF0: conditional instruction was optimized away because %var_4.4 is in (20..31)
// 25B36: using guessed type char gIsOpenCoreEnd;
// 14657C: using guessed type int dword_14657C;
// 146588: using guessed type int dword_146588;
// 14658C: using guessed type int dword_14658C;
// 146590: using guessed type int dword_146590;
// 146594: using guessed type int dword_146594;

//----- (00009D64) --------------------------------------------------------
int __fastcall single_BM1385_get_result(unsigned __int8 a1)
{
  int v3; // [sp+10h] [bp+10h]
  int v4; // [sp+10h] [bp+10h]
  unsigned int v5; // [sp+28h] [bp+28h]
  unsigned int v6; // [sp+2Ch] [bp+2Ch]
  int v7; // [sp+30h] [bp+30h]
  int v8; // [sp+34h] [bp+34h]
  unsigned int m; // [sp+38h] [bp+38h]
  unsigned int k; // [sp+38h] [bp+38h]
  unsigned int i; // [sp+3Ch] [bp+3Ch]
  unsigned int j; // [sp+3Ch] [bp+3Ch]

  v8 = 0;
  v7 = 1;
  v6 = dword_146588;
  v5 = dword_14658C;
  puts("\n\n------------------------------------------------------------------------------------------------------\n");
  printf("every CORE require nonce number: %lu\n\n", dword_1464FC);
  printf("Open core number : Conf.OpenCoreNum1 = %u = 0x%08x\n", dword_146588, dword_146588);
  printf("Open core number : Conf.OpenCoreNum2 = %u = 0x%08x\n", dword_14658C, dword_14658C);
  printf("Open core number : Conf.OpenCoreNum3 = %u = 0x%08x\n", dword_146590, dword_146590);
  printf("Open core number : Conf.OpenCoreNum4 = %u = 0x%08x\n\n", dword_146594, dword_146594);
  for ( i = 0; i <= 0x31; ++i )
  {
    if ( !(i % 0xA) )
      putchar(10);
    printf("core[%02d]=%02d\t", i, *((_DWORD *)&gAsic_Core_Nonce_Num + 0x4000 * a1 + i));
  }
  puts("\n\n");
  for ( j = 0; j <= 0x31; ++j )
  {
    if ( j > 0x1F )
    {
      if ( (v5 & 1) != 0 )
      {
        v4 = *((_DWORD *)&cgpu + v8 + 16427);
        if ( *((_DWORD *)&gAsic_Core_Nonce_Num + 0x4000 * a1 + j) < (unsigned int)dword_1464FC )
        {
          v7 &= ~1u;
          printf("core[%02d] = %d,      lost these nonce : ", j, *((_DWORD *)&gAsic_Core_Nonce_Num + 0x4000 * a1 + j));
          for ( k = 0; dword_1464FC > k; ++k )
          {
            if ( !*(_DWORD *)(v4 + 116 * k + 4 * (a1 + 12) + 4) )
              printf("%d  ", k);
          }
          putchar(10);
        }
        v5 >>= 1;
        ++v8;
      }
      else
      {
        v5 >>= 1;
      }
    }
    else if ( (v6 & 1) != 0 )
    {
      v3 = *((_DWORD *)&cgpu + v8 + 16427);
      if ( *((_DWORD *)&gAsic_Core_Nonce_Num + 0x4000 * a1 + j) < (unsigned int)dword_1464FC )
      {
        v7 &= ~1u;
        printf("core[%02d] = %d,      lost these nonce : ", j, *((_DWORD *)&gAsic_Core_Nonce_Num + 0x4000 * a1 + j));
        for ( m = 0; dword_1464FC > m; ++m )
        {
          if ( !*(_DWORD *)(v3 + 116 * m + 4 * (a1 + 12) + 4) )
            printf("%d  ", m);
        }
        putchar(10);
      }
      v6 >>= 1;
      ++v8;
    }
    else
    {
      v6 >>= 1;
    }
  }
  puts("\n------------------------------------------------------------------------------------------------------\n");
  printf("Chain%d total valid nonce number: %d\n\n", a1, gValid_Nonce_Num[a1]);
  if ( (v7 & 1) != 0 )
    puts("Pattern OK\n");
  else
    puts("Pattern NG\n");
  printf("HW number = %d\n\n", gHw_Nonce_Num[a1]);
  return v7;
}
// 9FE2: conditional instruction was optimized away because %var_4.4 is in (20..31)
// 9FE8: conditional instruction was optimized away because %var_4.4 is in (20..31)
// 25B3C: using guessed type _DWORD gValid_Nonce_Num[16];
// 25B7C: using guessed type _DWORD gHw_Nonce_Num[16];
// 1464FC: using guessed type int dword_1464FC;
// 146588: using guessed type int dword_146588;
// 14658C: using guessed type int dword_14658C;
// 146590: using guessed type int dword_146590;
// 146594: using guessed type int dword_146594;

//----- (0000A168) --------------------------------------------------------
unsigned int __fastcall single_asic_print_lcd(int a1, char a2)
{
  char v4[20]; // [sp+8h] [bp+8h] BYREF

  qmemcpy(v4, "      HW        ", 16);
  display_level_result_on_lcd();
  if ( (a2 & 1) != 0 )
    write_lcd_no_memset(2u, (int)"   Pattern OK   ", 0x10u);
  else
    write_lcd_no_memset(2u, (int)"   Pattern NG   ", 0x10u);
  sprintf(&v4[10], "%d", gHw_Nonce_Num[(unsigned __int8)gChain]);
  return write_lcd_no_memset(1u, (int)v4, 0x10u);
}
// 25974: using guessed type char gChain;
// 25B7C: using guessed type _DWORD gHw_Nonce_Num[16];

//----- (0000A200) --------------------------------------------------------
void __fastcall __noreturn single_BM1385_show_status_func(unsigned __int8 *a1)
{
  unsigned __int8 v1; // [sp+Bh] [bp+Bh]

  v1 = *a1;
  time_counter = 0;
  while ( 1 )
  {
    memset(&lcd_output, 32, 0x40u);
    sprintf(s, "   time %ds", time_counter);
    sprintf(byte_259B8, "   nonce=%d", gValid_Nonce_Num[v1]);
    ++time_counter;
    write(lcd_fd, &lcd_output, 0x40u);
    set_fan_speed(10);
    usleep((__useconds_t)&unk_F4240);
  }
}
// 25B1C: using guessed type int time_counter;
// 25B3C: using guessed type _DWORD gValid_Nonce_Num[16];
// 12611C: using guessed type int lcd_fd;

//----- (0000A2B4) --------------------------------------------------------
bool __fastcall is_nonce_or_reg_value(char a1)
{
  return a1 < 0;
}

//----- (0000A2D8) --------------------------------------------------------
int __fastcall single_BM1385_check_nonce(unsigned __int8 a1, unsigned __int8 *a2)
{
  int v6; // [sp+1Ch] [bp+14h]
  unsigned int v7; // [sp+24h] [bp+1Ch]
  unsigned int v8; // [sp+2Ch] [bp+24h]
  unsigned int v9; // [sp+30h] [bp+28h]
  unsigned int v10; // [sp+34h] [bp+2Ch]
  unsigned int v11; // [sp+3Ch] [bp+34h]
  unsigned int v12; // [sp+40h] [bp+38h]
  int v13; // [sp+44h] [bp+3Ch]
  int v14; // [sp+48h] [bp+40h]
  unsigned int j; // [sp+4Ch] [bp+44h]
  unsigned int k; // [sp+4Ch] [bp+44h]
  unsigned int i; // [sp+4Ch] [bp+44h]
  unsigned int m; // [sp+4Ch] [bp+44h]

  v14 = 0;
  v13 = 0;
  v7 = _byteswap_ulong(*(_DWORD *)a2);
  v10 = *a2 / (unsigned int)gChain_Asic_Interval;
  v9 = a2[3] & 0x3F;
  v8 = a2[4] & 0x7F;
  if ( v10 )
  {
    printf("%s: received ASIC%02d nonce. error!!!\t", "single_BM1385_check_nonce", v10);
    printf(",received data is : 0x%02x%02x%02x%02x%02x\n", *a2, a2[1], a2[2], a2[3], a2[4]);
    return -1;
  }
  else if ( v9 <= 0x31 )
  {
    if ( dword_1464FC > v8 )
    {
      v12 = dword_146588;
      v11 = dword_14658C;
      if ( v9 <= 0x1F )
      {
        for ( i = 0; v9 + 1 > i; ++i )
        {
          if ( (v12 & 1) != 0 )
            ++v14;
          v12 >>= 1;
        }
      }
      else
      {
        for ( j = 0; j <= 0x1F; ++j )
        {
          if ( (v12 & 1) != 0 )
            ++v14;
          v12 >>= 1;
        }
        for ( k = 0; v9 - 31 > k; ++k )
        {
          if ( (v11 & 1) != 0 )
            ++v14;
          v11 >>= 1;
        }
      }
      v6 = *((_DWORD *)&cgpu + v14 + 16426) + 116 * v8;
      if ( v7 == *(_DWORD *)(v6 + 4) )
      {
        if ( *(_DWORD *)(v6 + 4 * (a1 + 12) + 4) )
        {
          ++gRepeated_Nonce_Id[a1];
          ++*(_DWORD *)(v6 + 4 * (a1 + 12) + 4);
        }
        else
        {
          ++*(_DWORD *)(v6 + 4 * (a1 + 12) + 4);
          ++gValid_Nonce_Num[a1];
          ++gAsic_Core_Nonce_Num[0x4000 * a1 + v9];
        }
      }
      else
      {
        pthread_mutex_lock(&HW_check_mutex[a1]);
        for ( m = 0; (unsigned __int8)gWork_Num_For_Hw_Check > m; ++m )
        {
          v13 = check_hw(&gWorks_For_Hw_Check[290 * a1 + 29 * m], v7, 0);
          if ( !v13 )
            break;
        }
        pthread_mutex_unlock(&HW_check_mutex[a1]);
        if ( v13 == 1 )
        {
          ++gHw_Nonce_Num[a1];
          printf("%s: Find a HW. Chain%d ASIC%d Core%d : nonce = 0x%08x.\n", "single_BM1385_check_nonce", a1, 0, v9, v7);
        }
      }
      return 0;
    }
    else
    {
      printf("%s: received work_id = %02d nonce. error!!!\t", "single_BM1385_check_nonce", v8);
      printf(",received data is : 0x%02x%02x%02x%02x%02x\n", *a2, a2[1], a2[2], a2[3], a2[4]);
      return -1;
    }
  }
  else
  {
    printf("%s: received core%02d nonce. error!!!\t", "single_BM1385_check_nonce", v9);
    printf(",received data is : 0x%02x%02x%02x%02x%02x\n", *a2, a2[1], a2[2], a2[3], a2[4]);
    return -1;
  }
}
// 25B2C: using guessed type int gChain_Asic_Interval;
// 25B3C: using guessed type _DWORD gValid_Nonce_Num[16];
// 25B7C: using guessed type _DWORD gHw_Nonce_Num[16];
// 25BFC: using guessed type _DWORD gAsic_Core_Nonce_Num[11345];
// 125BFC: using guessed type _DWORD gRepeated_Nonce_Id[16];
// 125C7C: using guessed type char gWork_Num_For_Hw_Check;
// 125C98: using guessed type pthread_mutex_t HW_check_mutex[16];
// 1464FC: using guessed type int dword_1464FC;
// 146588: using guessed type int dword_146588;
// 14658C: using guessed type int dword_14658C;
// 146590: using guessed type int dword_146590;
// 146594: using guessed type int dword_146594;
// 1465C4: using guessed type _DWORD gWorks_For_Hw_Check[4640];

//----- (0000A71C) --------------------------------------------------------
int __fastcall single_BM1385_check_register_value(char a1, int a2)
{
  if ( *(_DWORD *)(reg_value_buf + 8) > 0x1FEu )
  {
    printf("%s: reg_value_buf buffer is full!\n", "single_BM1385_check_register_value");
    return -1;
  }
  else
  {
    *(_DWORD *)(reg_value_buf + 8 * (*(_DWORD *)reg_value_buf + 2)) = _byteswap_ulong(*(_DWORD *)a2);
    *(_BYTE *)(reg_value_buf + 8 * (*(_DWORD *)reg_value_buf + 2) + 4) = *(_BYTE *)(a2 + 4) & 0x1F;
    *(_BYTE *)(reg_value_buf + 8 * (*(_DWORD *)reg_value_buf + 2) + 5) = a1;
    ++*(_DWORD *)reg_value_buf;
    ++*(_DWORD *)(reg_value_buf + 8);
    if ( *(_DWORD *)reg_value_buf > 0x1FFu )
      *(_DWORD *)reg_value_buf = 0;
    return 0;
  }
}
// 1464B8: using guessed type int reg_value_buf;

//----- (0000A82C) --------------------------------------------------------
int __fastcall single_BM1385_send_func(unsigned __int8 *a1)
{
  int v1; // r3
  char v3[64]; // [sp+14h] [bp+Ch] BYREF
  void *src; // [sp+54h] [bp+4Ch]
  int v5; // [sp+58h] [bp+50h]
  int v6; // [sp+5Ch] [bp+54h]
  int v7; // [sp+60h] [bp+58h]
  int v8; // [sp+64h] [bp+5Ch]
  int v9; // [sp+68h] [bp+60h]
  int v10; // [sp+6Ch] [bp+64h]
  unsigned __int8 v11; // [sp+73h] [bp+6Bh]
  unsigned __int8 *v12; // [sp+74h] [bp+6Ch]
  int i; // [sp+78h] [bp+70h]
  unsigned int v14; // [sp+7Ch] [bp+74h]
  unsigned int v15; // [sp+80h] [bp+78h]
  unsigned int v16; // [sp+84h] [bp+7Ch]
  unsigned int v17; // [sp+88h] [bp+80h]
  unsigned int j; // [sp+8Ch] [bp+84h]
  unsigned int v19; // [sp+90h] [bp+88h]
  unsigned int k; // [sp+94h] [bp+8Ch]

  v12 = a1;
  v11 = *a1;
  v10 = 0;
  v9 = 0;
  k = 0;
  v19 = 0;
  j = 0;
  memset(v3, 0, sizeof(v3));
  v3[0] = -1;
  v8 = 0;
  v7 = 0;
  v6 = 0;
  v17 = dword_146588;
  v16 = dword_14658C;
  v15 = dword_146590;
  v14 = dword_146594;
  for ( i = 0; i <= 31; ++i )
  {
    if ( (v17 & 1) != 0 )
      ++v19;
    v17 >>= 1;
    if ( (v16 & 1) != 0 )
      ++v19;
    v16 >>= 1;
    if ( (v15 & 1) != 0 )
      ++v19;
    v15 >>= 1;
    if ( (v14 & 1) != 0 )
      ++v19;
    v14 >>= 1;
  }
  printf("%s: There are %d cores should be test\n\n", "single_BM1385_send_func", v19);
  for ( j = 0; j < v19; ++j )
  {
    v5 = *((_DWORD *)&cgpu + j + 16427);
    for ( k = 0; dword_1464FC > k; ++k )
    {
      src = (void *)(v5 + 116 * k);
      memset(v3, 0, sizeof(v3));
      for ( i = 0; i <= 31; ++i )
        v3[i] = *((_BYTE *)src + i + 20);
      v6 = *((_DWORD *)src + 1);
      v3[44] = HIBYTE(v6);
      v3[45] = BYTE2(v6);
      v3[46] = BYTE1(v6);
      v3[47] = v6;
      v3[51] = k;
      for ( i = 0; i <= 11; ++i )
        v3[i + 52] = *((_BYTE *)src + i + 8);
      uart_send(v11, v3, 0x40u);
      pthread_mutex_lock(&HW_check_mutex[v11]);
      for ( i = 8; i >= 0; --i )
        memcpy(
          (char *)&gWorks_For_Hw_Check + 1160 * v11 + 116 * i + 116,
          (char *)&gWorks_For_Hw_Check + 1160 * v11 + 116 * i,
          0x74u);
      if ( (unsigned __int8)++gWork_Num_For_Hw_Check > 8u )
        gWork_Num_For_Hw_Check = 9;
      memcpy((char *)&gWorks_For_Hw_Check + 1160 * v11, src, 0x74u);
      pthread_mutex_unlock(&HW_check_mutex[v11]);
      ++gSend_Work_Num[v11];
      usleep(dword_146580);
    }
  }
  while ( gSend_Work_Num[v11] < v19 * dword_1464FC )
    printf(
      "\n\n---%s: Chain%d send work num : %d, less than %d\n",
      "single_BM1385_send_func",
      v11,
      gSend_Work_Num[v11],
      50 * dword_1464FC);
  printf("\n\n---%s: Chain%d send work num : %d\n", "single_BM1385_send_func", v11, gSend_Work_Num[v11]);
  puts("\nsend test pattern done");
  system("date");
  putchar(10);
  usleep(0xC350u);
  start_receive = 0;
  puts("to stop receive");
  return v1;
}
// AC4E: variable 'v1' is possibly undefined
// 25B39: using guessed type char start_receive;
// 25BBC: using guessed type _DWORD gSend_Work_Num[16];
// 125C7C: using guessed type char gWork_Num_For_Hw_Check;
// 125C98: using guessed type pthread_mutex_t HW_check_mutex[16];
// 1464FC: using guessed type int dword_1464FC;
// 146580: using guessed type int dword_146580;
// 146588: using guessed type int dword_146588;
// 14658C: using guessed type int dword_14658C;
// 146590: using guessed type int dword_146590;
// 146594: using guessed type int dword_146594;

//----- (0000AC58) --------------------------------------------------------
int __fastcall single_BM1385_receive_func(unsigned __int8 *a1)
{
  _DWORD v2[2]; // [sp+Ch] [bp+Ch] BYREF
  _BYTE v3[500]; // [sp+14h] [bp+14h] BYREF
  _BYTE v4[1000]; // [sp+208h] [bp+208h] BYREF
  int v5; // [sp+5F0h] [bp+5F0h]
  unsigned int v6; // [sp+5F4h] [bp+5F4h]
  unsigned int v7; // [sp+5F8h] [bp+5F8h]
  unsigned int v8; // [sp+5FCh] [bp+5FCh]
  unsigned __int8 v9; // [sp+602h] [bp+602h]
  unsigned __int8 v10; // [sp+603h] [bp+603h]
  unsigned __int8 *v11; // [sp+604h] [bp+604h]
  unsigned int k; // [sp+608h] [bp+608h]
  unsigned int j; // [sp+60Ch] [bp+60Ch]
  unsigned int i; // [sp+610h] [bp+610h]
  int v15; // [sp+614h] [bp+614h]
  unsigned int v16; // [sp+618h] [bp+618h]
  unsigned int v17; // [sp+61Ch] [bp+61Ch]

  v11 = a1;
  v10 = *a1;
  v9 = a1[1];
  memset(v4, 0, sizeof(v4));
  memset(v3, 0, sizeof(v3));
  v2[0] = 0;
  LOBYTE(v2[1]) = 0;
  v8 = 0;
  v17 = 0;
  v16 = 0;
  v15 = 0;
  v7 = 0;
  v6 = 0;
  i = 0;
  j = 0;
  k = 0;
  v5 = 0;
  printf("%s: which_chain = %d, which_i2c = %d\n", "single_BM1385_receive_func", v10, v9);
  clear_uart_rx_fifo(v10);
LABEL_28:
  while ( start_receive )
  {
    usleep(0x1388u);
    for ( i = 0; i <= 0x4C4B3F; ++i )
    {
      memset(v4, 0, sizeof(v4));
      v8 = uart_receive(v10, (int)v4, 0x3E8u);
      if ( v8 && v17 <= 2 )
      {
        for ( j = 0; j < v8; ++j )
          v3[v16++] = v4[j];
        if ( v16 > 4 )
        {
          v7 = v16 / 5;
          for ( j = 0; j < v7; ++j )
          {
            memset(v2, 0, 5u);
            for ( k = 0; k <= 4; ++k )
              *((_BYTE *)v2 + k) = v3[v15++];
            if ( is_nonce_or_reg_value(v2[1]) )
            {
              if ( gStartTest )
              {
                if ( gIsOpenCoreEnd )
                {
                  v5 = single_BM1385_check_nonce(v10, (unsigned __int8 *)v2);
                  if ( v5 == -1 )
                    ++v17;
                }
              }
            }
            else
            {
              v5 = single_BM1385_check_register_value(v10, (int)v2);
              if ( v5 == -1 )
                ++v17;
            }
          }
          v6 = v16 - v15;
          for ( k = 0; k < v6; ++k )
            v3[k] = v3[v15++];
          v16 = v6;
          v15 = 0;
          v7 = 0;
        }
        goto LABEL_28;
      }
    }
  }
  return (unsigned __int8)start_receive;
}
// 25B34: using guessed type char gStartTest;
// 25B36: using guessed type char gIsOpenCoreEnd;
// 25B39: using guessed type char start_receive;

//----- (0000AF4C) --------------------------------------------------------
int singleAsicTest_BM1385()
{
  int v1[5]; // [sp+4h] [bp+4h] BYREF
  int v2; // [sp+18h] [bp+18h]
  int v3; // [sp+1Ch] [bp+1Ch]

  v3 = 0;
  v2 = 0;
  v1[4] = 123456;
  qmemcpy(v1, "                ", 16);
  printf("\nBegin %s test\n", "singleAsicTest_BM1385");
  system("date");
  putchar(10);
  memset(&lcd_output, 32, 0x40u);
  if ( lcd_fd > 0 )
  {
    lseek(lcd_fd, 0, 0);
    write(lcd_fd, &lcd_output, 0x40u);
  }
  init_fpga();
  reset_single_BM1385_global_arg();
  check_chain();
  if ( (unsigned __int8)gChain == 255 )
  {
    write_lcd(1u, (int)"  no hash board ", 0x10u);
    pthread_cancel(dword_136144);
    pthread_cancel(newthread);
    return puts("\nNo hash board, please plug in it");
  }
  else
  {
    pthread_create(
      &newthread,
      0,
      (void *(*)(void *))single_BM1385_show_status_func,
      &chain_info[2 * (unsigned __int8)gChain]);
    reset_hash_board();
    start_receive = 1;
    pthread_create(
      &dword_136144,
      0,
      (void *(*)(void *))single_BM1385_receive_func,
      &chain_info[2 * (unsigned __int8)gChain]);
    puts("\n--- check asic number");
    check_BM1385_asic_reg(gChain, 0, 0, 1);
    printf("\n--- check chain: asicNum = %d\n", *((unsigned __int8 *)&cgpu + (unsigned __int8)gChain + 131896));
    if ( *((unsigned __int8 *)&cgpu + (unsigned __int8)gChain + 131896) == dword_146528 )
    {
      single_BM1385_calculate_timeout_and_baud();
      set_BM1385_freq(gChain, 0, dword_146500, 1);
      BM1722_set_address_all(gChain);
      check_BM1385_asic_reg(gChain, 0, 0, 1);
      single_BM1385_set_baud(gChain, dword_1465BC);
      single_BM1385_open_core(gChain);
      puts("\nBegin send test pattern");
      system("date");
      putchar(10);
      gStartTest = 1;
      pthread_create(
        &dword_136140,
        0,
        (void *(*)(void *))single_BM1385_send_func,
        &chain_info[2 * (unsigned __int8)gChain]);
      pthread_join(dword_136140, 0);
      pthread_join(dword_136144, 0);
      pthread_cancel(newthread);
      LOBYTE(v2) = single_BM1385_get_result(gChain);
      single_asic_print_lcd((unsigned __int8)gChain, v2);
      set_fan_speed(0);
      return usleep((__useconds_t)&unk_7A120);
    }
    else
    {
      pthread_cancel(dword_136144);
      pthread_cancel(newthread);
      sprintf((char *)&v1[1] + 3, "%d", *((unsigned __int8 *)&cgpu + (unsigned __int8)gChain + 131896));
      write_lcd(0, (int)"   Only have    ", 0x10u);
      write_lcd_no_memset(1u, (int)v1, 0x10u);
      write_lcd_no_memset(2u, (int)"      ASIC      ", 0x10u);
      printf(
        "\n\n---%s: Only have %d ASIC\n",
        "singleAsicTest_BM1385",
        *((unsigned __int8 *)&cgpu + (unsigned __int8)gChain + 131896));
      return puts("----------------------------\n\n");
    }
  }
}
// A200: using guessed type void __noreturn single_BM1385_show_status_func();
// A82C: using guessed type int single_BM1385_send_func();
// AC58: using guessed type int single_BM1385_receive_func();
// 25974: using guessed type char gChain;
// 25B34: using guessed type char gStartTest;
// 25B39: using guessed type char start_receive;
// 12611C: using guessed type int lcd_fd;
// 146498: using guessed type _BYTE chain_info[32];
// 146500: using guessed type int dword_146500;
// 146528: using guessed type int dword_146528;
// 1465BC: using guessed type int dword_1465BC;

//----- (0000B35C) --------------------------------------------------------
int read_config()
{
  int v1; // [sp+0h] [bp+0h] BYREF
  char v2[1024]; // [sp+4h] [bp+4h] BYREF
  FILE *stream; // [sp+404h] [bp+404h]
  int v4; // [sp+408h] [bp+408h]
  _BYTE *v5; // [sp+40Ch] [bp+40Ch]
  int i; // [sp+410h] [bp+410h]
  char *v7; // [sp+414h] [bp+414h]

  v5 = &Conf;
  memset(v2, 0, sizeof(v2));
  v4 = 0;
  v1 = 0;
  stream = fopen("/mnt/card/Config.ini", "r");
  while ( fgets(v2, 1023, stream) )
  {
    if ( v2[0] != 35 && v2[1] != 35 )
    {
      v7 = strstr(v2, "Name=");
      if ( v7 )
      {
        v7 += 5;
        for ( i = 0; i <= 63; ++i )
        {
          v5[i] = *v7;
          if ( *++v7 == 10 || *v7 == 13 )
            break;
        }
        gName_len = ++i;
        v5[i] = 0;
        gHashBoard_S9 = 0;
        gHashBoard_T9 = 0;
        gHashBoard_T9_plus = 0;
        gHashBoard_R4 = 0;
        gHashBoard_V9 = 0;
        if ( *v5 == 82 && v5[1] == 52 )
        {
          gHashBoard_R4 = 1;
          printf("\n---%s: gHashBoard_R4\n\n", "read_config");
        }
        if ( *v5 == 84 && v5[1] == 57 && v5[2] == 43 )
        {
          gHashBoard_T9_plus = 1;
          printf("\n---%s: gHashBoard_T9_plus\n\n", "read_config");
        }
        if ( *v5 == 84 && v5[1] == 57 && gHashBoard_T9_plus != 1 )
        {
          gHashBoard_T9 = 1;
          printf("\n---%s: gHashBoard_T9\n\n", "read_config");
        }
        if ( *v5 == 83 && v5[1] == 57 )
        {
          gHashBoard_S9 = 1;
          printf("\n---%s: gHashBoard_S9\n\n", "read_config");
        }
        if ( *v5 == 83 && v5[1] == 49 && v5[2] == 49 )
        {
          gHashBoard_S11 = 1;
          printf("\n---%s: gHashBoard_S11\n\n", "read_config");
        }
        if ( *v5 == 86 && v5[1] == 57 )
        {
          gHashBoard_V9 = 1;
          printf("\n---%s: gHashBoard_V9\n\n", "read_config");
        }
      }
      else
      {
        v7 = strstr(v2, "pattern_number=");
        if ( v7 )
        {
          v7 += 15;
          _isoc99_sscanf(v7, "%d", v5 + 64);
          gPattern_number = *((_DWORD *)v5 + 16);
        }
        else
        {
          v7 = strstr(v2, "AsicNum=");
          if ( v7 )
          {
            v7 += 8;
            _isoc99_sscanf(v7, "%d", v5 + 108);
            if ( *((_DWORD *)v5 + 27) == 1 )
              gChain_Asic_Interval = 256;
          }
          else
          {
            v7 = strstr(v2, "AsicType=");
            if ( v7 )
            {
              v7 += 9;
              _isoc99_sscanf(v7, "%d", v5 + 116);
            }
            else
            {
              v7 = strstr(v2, "Freq1=");
              if ( v7 )
              {
                v7 += 6;
                _isoc99_sscanf(v7, "%d", v5 + 72);
              }
              else
              {
                v7 = strstr(v2, "Freq2=");
                if ( v7 )
                {
                  v7 += 6;
                  _isoc99_sscanf(v7, "%d", v5 + 76);
                }
                else
                {
                  v7 = strstr(v2, "Freq3=");
                  if ( v7 )
                  {
                    v7 += 6;
                    _isoc99_sscanf(v7, "%d", v5 + 80);
                  }
                  else
                  {
                    v7 = strstr(v2, "Freq4=");
                    if ( v7 )
                    {
                      v7 += 6;
                      _isoc99_sscanf(v7, "%d", v5 + 84);
                    }
                    else
                    {
                      v7 = strstr(v2, "Freq5=");
                      if ( v7 )
                      {
                        v7 += 6;
                        _isoc99_sscanf(v7, "%d", v5 + 88);
                      }
                      else
                      {
                        v7 = strstr(v2, "Freq6=");
                        if ( v7 )
                        {
                          v7 += 6;
                          _isoc99_sscanf(v7, "%d", v5 + 92);
                        }
                        else
                        {
                          v7 = strstr(v2, "Freq7=");
                          if ( v7 )
                          {
                            v7 += 6;
                            _isoc99_sscanf(v7, "%d", v5 + 96);
                          }
                          else
                          {
                            v7 = strstr(v2, "Freq8=");
                            if ( v7 )
                            {
                              v7 += 6;
                              _isoc99_sscanf(v7, "%d", v5 + 100);
                            }
                            else
                            {
                              v7 = strstr(v2, "Freq9=");
                              if ( v7 )
                              {
                                v7 += 6;
                                _isoc99_sscanf(v7, "%d", v5 + 104);
                              }
                              else
                              {
                                v7 = strstr(v2, "Voltage1=");
                                if ( v7 )
                                {
                                  v7 += 9;
                                  _isoc99_sscanf(v7, "%d", v5 + 156);
                                  if ( *((_DWORD *)v5 + 39) )
                                    ++gHowManyVoltageLevel;
                                }
                                else
                                {
                                  v7 = strstr(v2, "Voltage2=");
                                  if ( v7 )
                                  {
                                    v7 += 9;
                                    _isoc99_sscanf(v7, "%d", v5 + 160);
                                    if ( *((_DWORD *)v5 + 40) )
                                      ++gHowManyVoltageLevel;
                                  }
                                  else
                                  {
                                    v7 = strstr(v2, "Voltage3=");
                                    if ( v7 )
                                    {
                                      v7 += 9;
                                      _isoc99_sscanf(v7, "%d", v5 + 164);
                                      if ( *((_DWORD *)v5 + 41) )
                                        ++gHowManyVoltageLevel;
                                    }
                                    else
                                    {
                                      v7 = strstr(v2, "Voltage4=");
                                      if ( v7 )
                                      {
                                        v7 += 9;
                                        _isoc99_sscanf(v7, "%d", v5 + 168);
                                        if ( *((_DWORD *)v5 + 42) )
                                          ++gHowManyVoltageLevel;
                                      }
                                      else
                                      {
                                        v7 = strstr(v2, "Voltage5=");
                                        if ( v7 )
                                        {
                                          v7 += 9;
                                          _isoc99_sscanf(v7, "%d", v5 + 172);
                                          if ( *((_DWORD *)v5 + 43) )
                                            ++gHowManyVoltageLevel;
                                        }
                                        else
                                        {
                                          v7 = strstr(v2, "Voltage6=");
                                          if ( v7 )
                                          {
                                            v7 += 9;
                                            _isoc99_sscanf(v7, "%d", v5 + 176);
                                            if ( *((_DWORD *)v5 + 44) )
                                              ++gHowManyVoltageLevel;
                                          }
                                          else
                                          {
                                            v7 = strstr(v2, "Voltage7=");
                                            if ( v7 )
                                            {
                                              v7 += 9;
                                              _isoc99_sscanf(v7, "%d", v5 + 180);
                                              if ( *((_DWORD *)v5 + 45) )
                                                ++gHowManyVoltageLevel;
                                            }
                                            else
                                            {
                                              v7 = strstr(v2, "Voltage8=");
                                              if ( v7 )
                                              {
                                                v7 += 9;
                                                _isoc99_sscanf(v7, "%d", v5 + 184);
                                                if ( *((_DWORD *)v5 + 46) )
                                                  ++gHowManyVoltageLevel;
                                              }
                                              else
                                              {
                                                v7 = strstr(v2, "Voltage9=");
                                                if ( v7 )
                                                {
                                                  v7 += 9;
                                                  _isoc99_sscanf(v7, "%d", v5 + 188);
                                                  if ( *((_DWORD *)v5 + 47) )
                                                    ++gHowManyVoltageLevel;
                                                }
                                                else
                                                {
                                                  v7 = strstr(v2, "OpenCoreGap=");
                                                  if ( v7 )
                                                  {
                                                    v7 += 12;
                                                    _isoc99_sscanf(v7, "%d", v5 + 192);
                                                  }
                                                  else
                                                  {
                                                    v7 = strstr(v2, "CheckTemp=");
                                                    if ( v7 )
                                                    {
                                                      v7 += 10;
                                                      _isoc99_sscanf(v7, "%d", v5 + 200);
                                                    }
                                                    else
                                                    {
                                                      v7 = strstr(v2, "Open_Core_Num1=");
                                                      if ( v7 )
                                                      {
                                                        v7 += 15;
                                                        _isoc99_sscanf(v7, "%x", v5 + 204);
                                                      }
                                                      else
                                                      {
                                                        v7 = strstr(v2, "Open_Core_Num2=");
                                                        if ( v7 )
                                                        {
                                                          v7 += 15;
                                                          _isoc99_sscanf(v7, "%x", v5 + 208);
                                                        }
                                                        else
                                                        {
                                                          v7 = strstr(v2, "Open_Core_Num3=");
                                                          if ( v7 )
                                                          {
                                                            v7 += 15;
                                                            _isoc99_sscanf(v7, "%x", v5 + 212);
                                                          }
                                                          else
                                                          {
                                                            v7 = strstr(v2, "Open_Core_Num4=");
                                                            if ( v7 )
                                                            {
                                                              v7 += 15;
                                                              _isoc99_sscanf(v7, "%x", v5 + 216);
                                                            }
                                                            else
                                                            {
                                                              v7 = strstr(v2, "sensor_model=");
                                                              if ( v7 )
                                                              {
                                                                v7 += 13;
                                                                _isoc99_sscanf(v7, "%ud", v5 + 248);
                                                                if ( v5[248] == 6 )
                                                                {
                                                                  gSensor_i2c_addr_high_4_bit = 10092544;
                                                                }
                                                                else if ( v5[248] == 7 )
                                                                {
                                                                  gSensor_i2c_addr_high_4_bit = 10223616;
                                                                }
                                                                else
                                                                {
                                                                  gSensor_i2c_addr_high_4_bit = 9961472;
                                                                }
                                                              }
                                                              else
                                                              {
                                                                v7 = strstr(v2, "remote_local_gap=");
                                                                if ( v7 )
                                                                {
                                                                  v7 += 17;
                                                                  _isoc99_sscanf(v7, "%ud", v5 + 252);
                                                                }
                                                                else
                                                                {
                                                                  v7 = strstr(v2, "TempSensor1=");
                                                                  if ( v7 )
                                                                  {
                                                                    v7 += 12;
                                                                    _isoc99_sscanf(v7, "%ud", v5 + 220);
                                                                    if ( v5[220] )
                                                                      ++gSensor_number;
                                                                  }
                                                                  else
                                                                  {
                                                                    v7 = strstr(v2, "TempSensor2=");
                                                                    if ( v7 )
                                                                    {
                                                                      v7 += 12;
                                                                      _isoc99_sscanf(v7, "%ud", v5 + 221);
                                                                      if ( v5[221] )
                                                                        ++gSensor_number;
                                                                    }
                                                                    else
                                                                    {
                                                                      v7 = strstr(v2, "TempSensor3=");
                                                                      if ( v7 )
                                                                      {
                                                                        v7 += 12;
                                                                        _isoc99_sscanf(v7, "%ud", v5 + 222);
                                                                        if ( v5[222] )
                                                                          ++gSensor_number;
                                                                      }
                                                                      else
                                                                      {
                                                                        v7 = strstr(v2, "StartSensor=");
                                                                        if ( v7 )
                                                                        {
                                                                          v7 += 12;
                                                                          _isoc99_sscanf(v7, "%d", v5 + 223);
                                                                        }
                                                                        else
                                                                        {
                                                                          v7 = strstr(v2, "StartTemp=");
                                                                          if ( v7 )
                                                                          {
                                                                            v7 += 10;
                                                                            _isoc99_sscanf(v7, "%d", v5 + 224);
                                                                            _isoc99_sscanf(v7, "%d", &v1);
                                                                            if ( v1 >= 0 )
                                                                            {
                                                                              v5[224] = v1;
                                                                            }
                                                                            else
                                                                            {
                                                                              v1 = -v1;
                                                                              v5[224] = v1;
                                                                              v5[224] = -v5[224];
                                                                            }
                                                                          }
                                                                          else
                                                                          {
                                                                            v7 = strstr(v2, "TargetTemp=");
                                                                            if ( v7 )
                                                                            {
                                                                              v7 += 11;
                                                                              _isoc99_sscanf(v7, "%d", v5 + 225);
                                                                            }
                                                                            else
                                                                            {
                                                                              v7 = strstr(
                                                                                     v2,
                                                                                     "add_voltage_after_test_ok=");
                                                                              if ( v7 )
                                                                              {
                                                                                v7 += 26;
                                                                                _isoc99_sscanf(v7, "%d", v5 + 236);
                                                                              }
                                                                              else
                                                                              {
                                                                                v7 = strstr(v2, "add_voltage_value=");
                                                                                if ( v7 )
                                                                                {
                                                                                  v7 += 18;
                                                                                  _isoc99_sscanf(v7, "%d", v5 + 240);
                                                                                }
                                                                                else
                                                                                {
                                                                                  v7 = strstr(v2, "AlarmTemp=");
                                                                                  if ( v7 )
                                                                                  {
                                                                                    v7 += 10;
                                                                                    _isoc99_sscanf(v7, "%d", v5 + 226);
                                                                                  }
                                                                                  else
                                                                                  {
                                                                                    v7 = strstr(v2, "HeatingUpTime=");
                                                                                    if ( v7 )
                                                                                    {
                                                                                      v7 += 14;
                                                                                      _isoc99_sscanf(v7, "%d", v5 + 228);
                                                                                    }
                                                                                    else
                                                                                    {
                                                                                      v7 = strstr(v2, "MaxTempGap=");
                                                                                      if ( v7 )
                                                                                      {
                                                                                        v7 += 11;
                                                                                        _isoc99_sscanf(
                                                                                          v7,
                                                                                          "%d",
                                                                                          v5 + 232);
                                                                                      }
                                                                                      else
                                                                                      {
                                                                                        v7 = strstr(
                                                                                               v2,
                                                                                               "Invalid_Core_Num=");
                                                                                        if ( v7 )
                                                                                        {
                                                                                          v7 += 17;
                                                                                          _isoc99_sscanf(
                                                                                            v7,
                                                                                            "%d",
                                                                                            v5 + 244);
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      if ( *((_DWORD *)v5 + 27) == 1 && *((_DWORD *)v5 + 29) == 1385 )
      {
        strcpy(dest, Single_BM1385_WorkDataPathPrefix[0]);
        strcpy(byte_1361AC, BTC_WorkDataFilePrefix);
        *((_DWORD *)v5 + 28) = 50;
      }
      if ( gHashBoard_V9 )
      {
        strcpy(dest, V9_WorkDataPathPrefix);
        strcpy(byte_1361AC, BTC_WorkDataFilePrefix);
        *((_DWORD *)v5 + 27) = 45;
        *((_DWORD *)v5 + 28) = 50;
        *((_DWORD *)v5 + 29) = 1385;
        gPic_addr_high_4_bit = 10485760;
        gChain_Asic_Interval = 4;
      }
    }
  }
  return 0;
}
// 89F4: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);
// 251AC: using guessed type char *Single_BM1385_WorkDataPathPrefix[2];
// 25970: using guessed type char *BTC_WorkDataFilePrefix;
// 25AF8: using guessed type char *V9_WorkDataPathPrefix;
// 25B08: using guessed type char gHashBoard_V9;
// 25B09: using guessed type char gHashBoard_S9;
// 25B0A: using guessed type char gHashBoard_T9;
// 25B0B: using guessed type char gHashBoard_T9_plus;
// 25B0C: using guessed type char gHashBoard_R4;
// 25B0D: using guessed type char gHashBoard_S11;
// 25B10: using guessed type int gPic_addr_high_4_bit;
// 25B14: using guessed type int gSensor_i2c_addr_high_4_bit;
// 25B18: using guessed type char gHowManyVoltageLevel;
// 25B20: using guessed type int gName_len;
// 25B24: using guessed type int gSensor_number;
// 25B2C: using guessed type int gChain_Asic_Interval;
// 25B30: using guessed type int gPattern_number;

//----- (0000C3C4) --------------------------------------------------------
unsigned __int8 __cdecl CRC5(unsigned __int8 *ptr, unsigned __int8 len)
{
  _BYTE v4[5]; // [sp+Ch] [bp+Ch]
  int v5; // [sp+14h] [bp+14h]
  char v6; // [sp+18h] [bp+18h]
  bool v7; // [sp+1Bh] [bp+1Bh]
  unsigned __int8 v8; // [sp+1Ch] [bp+1Ch]
  char v9; // [sp+1Dh] [bp+1Dh]
  unsigned __int8 v10; // [sp+1Eh] [bp+1Eh]
  unsigned __int8 i; // [sp+1Fh] [bp+1Fh]

  v5 = 16843009;
  v6 = 1;
  v10 = 0x80;
  v9 = 0;
  for ( i = 0; i < (unsigned int)len; ++i )
  {
    v7 = (v10 & *ptr) != 0;
    v4[0] = v7 ^ v6;
    v4[1] = v5;
    v4[2] = v7 ^ v6 ^ BYTE1(v5);
    *(_WORD *)&v4[3] = HIWORD(v5);
    v10 >>= 1;
    if ( ++v9 == 8 )
    {
      v10 = 0x80;
      v9 = 0;
      ++ptr;
    }
    v5 = *(_DWORD *)v4;
    v6 = v4[4];
  }
  v8 = 0;
  if ( v6 )
    v8 = 16;
  if ( HIBYTE(v5) )
    v8 |= 8u;
  if ( BYTE2(v5) )
    v8 |= 4u;
  if ( BYTE1(v5) )
    v8 |= 2u;
  if ( (_BYTE)v5 )
    v8 |= 1u;
  return v8;
}

//----- (0000C4E4) --------------------------------------------------------
uint16_t __cdecl CRC16(const unsigned __int8 *p_data, uint16_t w_len)
{
  unsigned __int16 v6; // [sp+Ch] [bp+Ch]
  unsigned __int8 v7; // [sp+Eh] [bp+Eh]
  unsigned __int8 v8; // [sp+Fh] [bp+Fh]

  v8 = -1;
  v7 = -1;
  while ( w_len-- != 0 )
  {
    v6 = (unsigned __int8)(v7 ^ *p_data++);
    v7 = v8 ^ chCRCHTalbe[v6];
    v8 = chCRCLTalbe[v6];
  }
  return v7 | (v8 << 8);
}
// 1A424: using guessed type _BYTE chCRCHTalbe[256];
// 1A524: using guessed type _BYTE chCRCLTalbe[256];

//----- (0000C564) --------------------------------------------------------
int bitmain_axi_init()
{
  dword_136168 = open("/dev/axi_fpga_dev", 2);
  if ( dword_136168 >= 0 )
  {
    axi_fpga_addr = (int)mmap(0, 0x1200u, 3, 1, dword_136168, 0);
    if ( axi_fpga_addr )
    {
      printf("mmap axi_fpga_addr = 0x%x\n", axi_fpga_addr);
      printf("axi_fpga_addr data = 0x%x\n", (unsigned __int16)*(_DWORD *)axi_fpga_addr);
      fd_fpga_mem = open("/dev/fpga_mem", 2);
      if ( fd_fpga_mem >= 0 )
      {
        fpga_mem_addr = (int)mmap(0, 0x1000000u, 3, 1, fd_fpga_mem, 0);
        if ( fpga_mem_addr )
        {
          printf("mmap fpga_mem_addr = 0x%x\n", fpga_mem_addr);
          return 0;
        }
        else
        {
          printf("mmap fpga_mem_addr failed. fpga_mem_addr = 0x%x\n", fpga_mem_addr);
          return -1;
        }
      }
      else
      {
        printf("/dev/fpga_mem open failed. fd_fpga_mem = %d\n", fd_fpga_mem);
        return -1;
      }
    }
    else
    {
      printf("mmap axi_fpga_addr failed. axi_fpga_addr = 0x%x\n", axi_fpga_addr);
      return -1;
    }
  }
  else
  {
    printf("/dev/axi_fpga_dev open failed. fd = %d\n", dword_136168);
    return -1;
  }
}
// 25B00: using guessed type int fpga_mem_addr;
// 25B04: using guessed type int axi_fpga_addr;
// 136168: using guessed type int dword_136168;
// 1465C0: using guessed type int fd_fpga_mem;

//----- (0000C718) --------------------------------------------------------
int bitmain_axi_close()
{
  int v0; // r3

  printf("\n\n--- %s\n", "bitmain_axi_close");
  if ( munmap((void *)axi_fpga_addr, 0x1200u) < 0 )
    puts("munmap failed!");
  if ( munmap((void *)fpga_mem_addr, 0x1000000u) < 0 )
    puts("munmap failed!");
  close(dword_136168);
  close(fd_fpga_mem);
  return v0;
}
// C7AC: variable 'v0' is possibly undefined
// 25B00: using guessed type int fpga_mem_addr;
// 25B04: using guessed type int axi_fpga_addr;
// 136168: using guessed type int dword_136168;
// 1465C0: using guessed type int fd_fpga_mem;

//----- (0000C7B8) --------------------------------------------------------
int __fastcall read_axi_fpga(int a1)
{
  return *(_DWORD *)(axi_fpga_addr + 4 * a1);
}
// 25B04: using guessed type int axi_fpga_addr;

//----- (0000C7E8) --------------------------------------------------------
int __fastcall write_axi_fpga(int result, int a2)
{
  *(_DWORD *)(axi_fpga_addr + 4 * result) = a2;
  return result;
}
// 25B04: using guessed type int axi_fpga_addr;

//----- (0000C810) --------------------------------------------------------
int init_fpga()
{
  printf("\n--- %s\n", "init_fpga");
  write_axi_fpga(32, -2147450880);
  while ( read_axi_fpga(32) < 0 )
    usleep(0x2710u);
  return usleep(0x186A0u);
}

//----- (0000C864) --------------------------------------------------------
int __fastcall get_return_nonce(int *a1)
{
  int result; // r0

  *a1 = read_axi_fpga(4);
  result = read_axi_fpga(5);
  a1[1] = result;
  return result;
}

//----- (0000C894) --------------------------------------------------------
int __fastcall set_BC_command_buffer(int *a1)
{
  write_axi_fpga(49, *a1);
  write_axi_fpga(50, a1[1]);
  return write_axi_fpga(51, a1[2]);
}

//----- (0000C8CC) --------------------------------------------------------
int get_BC_write_command()
{
  return read_axi_fpga(48);
}

//----- (0000C8EC) --------------------------------------------------------
int __fastcall set_BC_write_command(int a1)
{
  char v3; // [sp+Fh] [bp+Fh]

  v3 = 0;
  if ( a1 < 0 )
  {
    while ( get_BC_write_command() < 0 )
    {
      usleep(0x3E8u);
      if ( (unsigned __int8)++v3 > 0x64u )
      {
        printf("\n%s: timeout\n\n", "set_BC_write_command");
        return write_axi_fpga(48, a1);
      }
    }
  }
  return write_axi_fpga(48, a1);
}

//----- (0000C948) --------------------------------------------------------
int __fastcall set_TW_write_command(int *a1)
{
  int result; // r0
  unsigned int i; // [sp+Ch] [bp+Ch]

  result = write_axi_fpga(16, *a1);
  for ( i = 1; i <= 0xC; ++i )
    result = write_axi_fpga(17, a1[i]);
  return result;
}

//----- (0000C988) --------------------------------------------------------
int __fastcall set_fpga_baud(unsigned __int8 a1)
{
  int v2; // [sp+Bh] [bp+Bh]

  v2 = (unsigned __int8)asic_baud_to_fpga_baud(a1);
  return write_axi_fpga(15, (unsigned __int8)v2);
}

//----- (0000C9B4) --------------------------------------------------------
int cgpu_init()
{
  printf("\n\n--- %s\n", "cgpu_init");
  memset(&cgpu, 0, 0x20358u);
  if ( open_lcd() <= 0 )
  {
    printf("!!! %s: open lcd driver error\n", "cgpu_init");
LABEL_15:
    close_lcd();
    return -1;
  }
  memset(&lcd_output, 32, 0x40u);
  write(lcd_fd, &lcd_output, 0x40u);
  if ( open_key() <= 0 )
  {
    printf("!!! %s: open start key error\n", "cgpu_init");
LABEL_14:
    close_key();
    goto LABEL_15;
  }
  if ( open_red_led() <= 0 )
  {
    printf("!!! %s: open red led error\n", "cgpu_init");
LABEL_13:
    close_red_led();
    goto LABEL_14;
  }
  if ( open_green_led() <= 0 )
  {
    printf("!!! %s: open green led error\n", "cgpu_init");
LABEL_12:
    close_green_led();
    goto LABEL_13;
  }
  if ( bitmain_axi_init() < 0 )
  {
    bitmain_axi_close();
    goto LABEL_12;
  }
  return 0;
}
// 12611C: using guessed type int lcd_fd;

//----- (0000CAD0) --------------------------------------------------------
void Hardware_close()
{
  ;
}

//----- (0000CADC) --------------------------------------------------------
void *malloc_register_buf()
{
  reg_value_buf = (int)malloc(0x1008u);
  if ( reg_value_buf )
    return memset((void *)reg_value_buf, 0, 0x1008u);
  else
    return (void *)printf("%s: malloc reg_value_buf failed\n", "malloc_register_buf");
}
// 1464B8: using guessed type int reg_value_buf;

//----- (0000CB34) --------------------------------------------------------
int configMiner()
{
  read_config();
  if ( get_works() < 0 )
    return -14;
  malloc_register_buf();
  return 0;
}

//----- (0000CB60) --------------------------------------------------------
ssize_t display_arguments()
{
  char v1[64]; // [sp+0h] [bp+0h] BYREF

  memset(v1, 0, sizeof(v1));
  lseek(lcd_fd, 0, 0);
  memset(v1, 32, sizeof(v1));
  memcpy(v1, &Conf, gName_len);
  sprintf(&v1[16], "IC:%2d P:%2d", dword_146528, dword_1464FC);
  sprintf(&v1[32], "FREQ: %d", dword_146504);
  sprintf(&v1[48], "Voltage: %d", dword_146558);
  return write(lcd_fd, v1, 0x40u);
}
// 25B20: using guessed type int gName_len;
// 12611C: using guessed type int lcd_fd;
// 1464FC: using guessed type int dword_1464FC;
// 146504: using guessed type int dword_146504;
// 146528: using guessed type int dword_146528;
// 146558: using guessed type int dword_146558;

//----- (0000CC34) --------------------------------------------------------
void *clear_register_value_buf()
{
  pthread_mutex_lock(&reg_mutex);
  *(_DWORD *)reg_value_buf = 0;
  *(_DWORD *)(reg_value_buf + 4) = 0;
  *(_DWORD *)(reg_value_buf + 8) = 0;
  *(_DWORD *)(reg_value_buf + 12) = 0;
  pthread_mutex_unlock(&reg_mutex);
  return memset((void *)(reg_value_buf + 16), 0, 0xFF8u);
}
// 125C80: using guessed type pthread_mutex_t reg_mutex;
// 1464B8: using guessed type int reg_value_buf;

//----- (0000CCA4) --------------------------------------------------------
int __fastcall calculate_core_number(unsigned int a1)
{
  if ( a1 == 1 )
    return 1;
  if ( a1 == 2 )
    return 2;
  if ( a1 > 2 && a1 <= 4 )
    return 4;
  if ( a1 > 4 && a1 <= 8 )
    return 8;
  if ( a1 > 8 && a1 <= 0x10 )
    return 16;
  if ( a1 > 0x10 && a1 <= 0x20 )
    return 32;
  if ( a1 > 0x20 && a1 <= 0x40 )
    return 64;
  if ( a1 > 0x40 && a1 <= 0x80 )
    return 128;
  printf("%s: actual_core_number = %d, but it is error\n", "calculate_core_number", a1);
  return -1;
}

//----- (0000CD5C) --------------------------------------------------------
int __fastcall asic_baud_to_fpga_baud(unsigned __int8 a1)
{
  int v1; // r3

  switch ( a1 )
  {
    case 0u:
      v1 = 1;
      break;
    case 1u:
      v1 = 3;
      break;
    case 2u:
      v1 = 5;
      break;
    case 6u:
      v1 = 13;
      break;
    case 0x1Au:
      v1 = 53;
      break;
    default:
      printf("%s: Don't support ASIC baud = %d, error!!!\n", "asic_baud_to_fpga_baud", a1);
      v1 = 53;
      break;
  }
  return v1;
}

//----- (0000CE18) --------------------------------------------------------
int __fastcall calculate_how_many_nonce_per_asic_get(unsigned __int8 a1, unsigned __int8 a2, unsigned int a3)
{
  unsigned int i; // [sp+8h] [bp+8h]
  int v5; // [sp+Ch] [bp+Ch]

  v5 = 0;
  for ( i = 0; i < a3; ++i )
    v5 += gAsic_Core_Nonce_Num[128 * ((a1 << 7) + a2) + i];
  return v5;
}
// 25BFC: using guessed type _DWORD gAsic_Core_Nonce_Num[11345];

//----- (0000CE74) --------------------------------------------------------
int display_level_result_on_lcd()
{
  char v1[8]; // [sp+4h] [bp+4h] BYREF
  unsigned int i; // [sp+Ch] [bp+Ch]

  qmemcpy(v1, "     ", 5);
  sprintf(v1, "%2d", (unsigned __int8)pattern_test_time + 1);
  for ( i = 0; i <= 2; ++i )
    lcd_buffer[i + 10] = v1[i];
  write_lcd(0, (int)lcd_buffer, 0x10u);
  return printf("Level: %d\n\n", (unsigned __int8)pattern_test_time + 1);
}
// 25978: using guessed type _BYTE lcd_buffer[16];
// 25B19: using guessed type char pattern_test_time;

//----- (0000CF08) --------------------------------------------------------
void *reset_global_arg()
{
  unsigned int i; // [sp+14h] [bp+14h]

  printf("\n--- %s\n", "reset_global_arg");
  time_counter = 0;
  gHighest_Temp = 0;
  gChain = -1;
  gWork_Num_For_Hw_Check = 0;
  gIsOpenCoreEnd = 0;
  gStartTest = 0;
  gBegin_Get_Nonce = 0;
  memset(gValid_Nonce_Num, 0, sizeof(gValid_Nonce_Num));
  memset(gHw_Nonce_Num, 0, sizeof(gHw_Nonce_Num));
  memset((void *)reg_value_buf, 0, 0x1008u);
  memset(&gWorks_For_Hw_Check, 0, 0x488u);
  memset(&lcd_output, 32, 0x40u);
  write(lcd_fd, &lcd_output, 0x40u);
  pthread_mutex_init(&reg_mutex, 0);
  for ( i = 0; i <= 0xF; ++i )
  {
    pthread_mutex_init(&uart_send_mutex[i], 0);
    pthread_mutex_init(&uart_receive_mutex[i], 0);
    pthread_mutex_init(&HW_check_mutex[i], 0);
  }
  return clear_register_value_buf();
}
// 25974: using guessed type char gChain;
// 25B1C: using guessed type int time_counter;
// 25B28: using guessed type int gHighest_Temp;
// 25B34: using guessed type char gStartTest;
// 25B35: using guessed type char gBegin_Get_Nonce;
// 25B36: using guessed type char gIsOpenCoreEnd;
// 25B3C: using guessed type _DWORD gValid_Nonce_Num[16];
// 25B7C: using guessed type _DWORD gHw_Nonce_Num[16];
// 125C7C: using guessed type char gWork_Num_For_Hw_Check;
// 125C80: using guessed type pthread_mutex_t reg_mutex;
// 125C98: using guessed type pthread_mutex_t HW_check_mutex[16];
// 125E18: using guessed type pthread_mutex_t uart_send_mutex[16];
// 125F98: using guessed type pthread_mutex_t uart_receive_mutex[16];
// 12611C: using guessed type int lcd_fd;
// 1464B8: using guessed type int reg_value_buf;

//----- (0000D07C) --------------------------------------------------------
int __fastcall rev(int result, char a2)
{
  char v2; // [sp+Dh] [bp+Dh]
  unsigned __int8 i; // [sp+Eh] [bp+Eh]
  unsigned __int8 v4; // [sp+Fh] [bp+Fh]

  v4 = 0;
  for ( i = a2 - 1; v4 < (unsigned int)i; --i )
  {
    v2 = *(_BYTE *)(result + v4);
    *(_BYTE *)(result + v4) = *(_BYTE *)(result + i);
    *(_BYTE *)(result + i) = v2;
    ++v4;
  }
  return result;
}

//----- (0000D0D8) --------------------------------------------------------
int __fastcall check_hw(_DWORD *a1, unsigned int a2, char a3)
{
  int v3; // r1
  int v4; // r2
  int v5; // r3
  int v6; // r1
  int v7; // r2
  int v8; // r3
  _DWORD v14[58]; // [sp+14h] [bp+14h] BYREF
  unsigned int v15; // [sp+FCh] [bp+FCh] BYREF
  unsigned __int8 v16[32]; // [sp+100h] [bp+100h] BYREF
  unsigned __int8 v17[32]; // [sp+120h] [bp+120h] BYREF
  unsigned __int8 *v18; // [sp+140h] [bp+140h]
  unsigned int i; // [sp+144h] [bp+144h]

  i = 0;
  memset(v17, 0, sizeof(v17));
  memset(v16, 0, sizeof(v16));
  v18 = v17;
  v15 = (a2 << 24) | HIBYTE(a2) | ((a2 & 0xFF0000) >> 8) | ((a2 & 0xFF00) << 8);
  v3 = a1[6];
  v4 = a1[7];
  v5 = a1[8];
  v14[2] = a1[5];
  v14[3] = v3;
  v14[4] = v4;
  v14[5] = v5;
  v6 = a1[10];
  v7 = a1[11];
  v8 = a1[12];
  v14[6] = a1[9];
  v14[7] = v6;
  v14[8] = v7;
  v14[9] = v8;
  rev((int)&v14[2], 32);
  v14[0] = 80;
  v14[1] = 0;
  memcpy(v17, a1 + 2, 0xCu);
  rev((int)v17, 12);
  flip_swab(&v14[10], v17, 0xCu);
  memcpy(v17, &v15, 4u);
  rev((int)v17, 4);
  flip_swab(&v14[13], v17, 4u);
  sha2_finish((sha2_context *)v14, v17);
  memset(v14, 0, sizeof(v14));
  sha2(v17, 32, v16);
  flip32(v17, v16);
  if ( !*((_DWORD *)v18 + 7) )
    return 0;
  if ( a3 )
  {
    printf("\n%s: Got a HW!\n", "check_hw");
    printf("hash1=0x");
    for ( i = 0; i <= 0x1F; ++i )
      printf("%02x", v17[i]);
    putchar(10);
    printf("midstate=0x");
    for ( i = 0; i <= 0x1F; ++i )
      printf("%02x", *((unsigned __int8 *)a1 + i + 20));
    printf("\tdata2=0x");
    for ( i = 0; i <= 0xB; ++i )
      printf("%02x", *((unsigned __int8 *)a1 + i + 8));
    printf("\treturn nonce=0x%08x, but it should be nonce=0x%08x\n", a2, a1[1]);
  }
  return 1;
}

//----- (0000D3A4) --------------------------------------------------------
int __fastcall i2c_write(int a1)
{
  while ( read_axi_fpga(12) >= 0 )
    usleep(0x1388u);
  return write_axi_fpga(12, a1);
}
// D3BE: conditional instruction was optimized away because %var_4.4==0

//----- (0000D3F4) --------------------------------------------------------
int __fastcall i2c_read(int a1)
{
  int axi_fpga; // [sp+8h] [bp+8h]

  i2c_write(a1 | 0x2000000);
  do
  {
    usleep(0x1388u);
    axi_fpga = read_axi_fpga(12);
  }
  while ( axi_fpga >= 0 );
  return (unsigned __int8)axi_fpga;
}
// D430: conditional instruction was optimized away because %var_4.4==0

//----- (0000D458) --------------------------------------------------------
int __fastcall check_how_many_uart_data_in_fpga(unsigned __int8 a1)
{
  int v1; // r3

  switch ( a1 )
  {
    case 0u:
      v1 = (read_axi_fpga(1088) >> 16) & 0x3FF;
      break;
    case 1u:
      v1 = read_axi_fpga(1088) & 0x3FF;
      break;
    case 2u:
      v1 = (read_axi_fpga(1089) >> 16) & 0x3FF;
      break;
    case 3u:
      v1 = read_axi_fpga(1089) & 0x3FF;
      break;
    case 4u:
      v1 = (read_axi_fpga(1090) >> 16) & 0x3FF;
      break;
    case 5u:
      v1 = read_axi_fpga(1090) & 0x3FF;
      break;
    case 6u:
      v1 = (read_axi_fpga(1091) >> 16) & 0x3FF;
      break;
    case 7u:
      v1 = read_axi_fpga(1091) & 0x3FF;
      break;
    case 8u:
      v1 = (read_axi_fpga(1092) >> 16) & 0x3FF;
      break;
    case 9u:
      v1 = read_axi_fpga(1092) & 0x3FF;
      break;
    default:
      printf("%s: The uart%d is not supported!!!\n", "check_how_many_uart_data_in_fpga", a1);
      v1 = 0;
      break;
  }
  return v1;
}

//----- (0000D568) --------------------------------------------------------
int __fastcall read_uart_data_in_fpga(unsigned __int8 a1, int a2, unsigned int a3)
{
  int v3; // r3
  int axi_fpga; // r0
  int v9; // [sp+14h] [bp+14h]
  unsigned int v10; // [sp+18h] [bp+18h]
  unsigned int v11; // [sp+18h] [bp+18h]
  int v12; // [sp+20h] [bp+20h]
  unsigned int i; // [sp+24h] [bp+24h]
  int v14; // [sp+28h] [bp+28h]
  int v15; // [sp+2Ch] [bp+2Ch]

  switch ( a1 )
  {
    case 0u:
      v15 = 1100;
      v14 = 1101;
      goto LABEL_13;
    case 1u:
      v15 = 1102;
      v14 = 1103;
      goto LABEL_13;
    case 2u:
      v15 = 1104;
      v14 = 1105;
      goto LABEL_13;
    case 3u:
      v15 = 1106;
      v14 = 1107;
      goto LABEL_13;
    case 4u:
      v15 = 1108;
      v14 = 1109;
      goto LABEL_13;
    case 5u:
      v15 = 1110;
      v14 = 1111;
      goto LABEL_13;
    case 6u:
      v15 = 1112;
      v14 = 1113;
      goto LABEL_13;
    case 7u:
      v15 = 1114;
      v14 = 1115;
      goto LABEL_13;
    case 8u:
      v15 = 1116;
      v14 = 1117;
      goto LABEL_13;
    case 9u:
      v15 = 1118;
      v14 = 1119;
LABEL_13:
      write_axi_fpga(v15, a3 & 0x3FF | 0x80000000);
      v10 = a3 >> 2;
      for ( i = 0; i < v10; ++i )
      {
        axi_fpga = read_axi_fpga(v14);
        *(_BYTE *)(a2 + 4 * i) = HIBYTE(axi_fpga);
        *(_BYTE *)(a2 + 4 * i + 1) = BYTE2(axi_fpga);
        *(_BYTE *)(a2 + 4 * i + 2) = BYTE1(axi_fpga);
        *(_BYTE *)(a2 + 4 * i + 3) = axi_fpga;
      }
      v12 = 4 * v10;
      v11 = a3 & 3;
      if ( (a3 & 3) != 0 )
      {
        v9 = read_axi_fpga(v14);
        switch ( v11 )
        {
          case 2u:
            *(_BYTE *)(a2 + 4 * i) = HIBYTE(v9);
            *(_BYTE *)(a2 + 4 * i + 1) = BYTE2(v9);
            v12 += 2;
            break;
          case 3u:
            *(_BYTE *)(a2 + 4 * i) = HIBYTE(v9);
            *(_BYTE *)(a2 + 4 * i + 1) = BYTE2(v9);
            *(_BYTE *)(a2 + 4 * i + 2) = BYTE1(v9);
            v12 += 3;
            break;
          case 1u:
            *(_BYTE *)(a2 + 4 * i) = HIBYTE(v9);
            ++v12;
            break;
          default:
            printf("%s: the uart%d left data is 4*N length, error!!!\n", "read_uart_data_in_fpga", a1);
            break;
        }
      }
      v3 = v12;
      break;
    default:
      printf("%s: The uart%d is not supported!!!\n", "read_uart_data_in_fpga", jpt_D59A);
      v3 = 0;
      break;
  }
  return v3;
}
// D5A0: using guessed type void *jpt_D59A[10];

//----- (0000D7B8) --------------------------------------------------------
unsigned int __fastcall uart_send(unsigned __int8 a1, const void *a2, size_t a3)
{
  int axi_fpga; // r0
  _BYTE v9[512]; // [sp+10h] [bp+10h] BYREF
  unsigned int v10; // [sp+210h] [bp+210h]
  unsigned int v11; // [sp+214h] [bp+214h]
  int v12; // [sp+218h] [bp+218h]
  int v13; // [sp+21Ch] [bp+21Ch]
  int v14; // [sp+220h] [bp+220h]
  int v15; // [sp+224h] [bp+224h]
  int v16; // [sp+228h] [bp+228h]
  int v17; // [sp+22Ch] [bp+22Ch]
  int v18; // [sp+230h] [bp+230h]
  int v19; // [sp+234h] [bp+234h]
  int i; // [sp+238h] [bp+238h]
  int v21; // [sp+23Ch] [bp+23Ch]

  v14 = 0;
  v21 = 0;
  v13 = 0;
  i = 0;
  v12 = 0;
  memset(v9, 0, sizeof(v9));
  v11 = a3;
  v19 = 0;
  v18 = 0;
  v17 = 0;
  v16 = 0;
  v10 = 0;
  v15 = 0;
  pthread_mutex_lock(&uart_send_mutex[a1]);
  switch ( a1 )
  {
    case 0u:
      v15 = 24;
      v18 = 1024;
      v17 = 1028;
      v16 = 1029;
      goto LABEL_13;
    case 1u:
      v15 = 16;
      v18 = 1024;
      v17 = 1030;
      v16 = 1031;
      goto LABEL_13;
    case 2u:
      v15 = 8;
      v18 = 1024;
      v17 = 1032;
      v16 = 1033;
      goto LABEL_13;
    case 3u:
      v15 = 0;
      v18 = 1024;
      v17 = 1034;
      v16 = 1035;
      goto LABEL_13;
    case 4u:
      v15 = 24;
      v18 = 1025;
      v17 = 1036;
      v16 = 1037;
      goto LABEL_13;
    case 5u:
      v15 = 16;
      v18 = 1025;
      v17 = 1038;
      v16 = 1039;
      goto LABEL_13;
    case 6u:
      v15 = 8;
      v18 = 1025;
      v17 = 1040;
      v16 = 1041;
      goto LABEL_13;
    case 7u:
      v15 = 0;
      v18 = 1025;
      v17 = 1042;
      v16 = 1043;
      goto LABEL_13;
    case 8u:
      v15 = 24;
      v18 = 1026;
      v17 = 1044;
      v16 = 1045;
      goto LABEL_13;
    case 9u:
      v15 = 16;
      v18 = 1026;
      v17 = 1046;
      v16 = 1047;
LABEL_13:
      v21 = 0;
      break;
    default:
      printf("%s: The uart%d is not supported!!!\n", "uart_send", jpt_D85C);
      return 0;
  }
  while ( 1 )
  {
    axi_fpga = read_axi_fpga(v18);
    v10 = (unsigned __int8)(axi_fpga >> v15);
    if ( v10 >= a3 )
      break;
    usleep(0xBB8u);
    if ( ++v21 > 20 )
    {
      pthread_mutex_unlock(&uart_send_mutex[a1]);
      printf("%s: uart%d always dose not has enough send fifo space, break\n", "uart_send", a1);
      return 0;
    }
  }
  v21 = 0;
  while ( read_axi_fpga(v17) < 0 )
  {
    if ( v21 > 20 )
    {
      pthread_mutex_unlock(&uart_send_mutex[a1]);
      printf("%s: uart%d always busy, break\n", "uart_send", a1);
      return 0;
    }
    ++v21;
    usleep(0xBB8u);
  }
  memcpy(v9, a2, a3);
  v13 = v11 >> 2;
  for ( i = 0; i < v13; ++i )
  {
    v19 = (unsigned __int8)v9[4 * i + 3] | ((unsigned __int8)v9[4 * i] << 24) | ((unsigned __int8)v9[4 * i + 1] << 16) | ((unsigned __int8)v9[4 * i + 2] << 8);
    write_axi_fpga(v16, v19);
  }
  v13 = v11 & 3;
  if ( (v11 & 3) != 0 )
  {
    switch ( v13 )
    {
      case 2:
        v19 = ((unsigned __int8)v9[4 * i + 1] << 16) | ((unsigned __int8)v9[4 * i] << 24);
        break;
      case 3:
        v19 = ((unsigned __int8)v9[4 * i + 2] << 8) | ((unsigned __int8)v9[4 * i] << 24) | ((unsigned __int8)v9[4 * i + 1] << 16);
        break;
      case 1:
        v19 = (unsigned __int8)v9[4 * i] << 24;
        break;
      default:
        printf("%s: the uart%d send left data is 4*N length, error!!!\n", "uart_send", a1);
        break;
    }
    write_axi_fpga(v16, v19);
  }
  write_axi_fpga(v17, v11 | 0x80000000);
  pthread_mutex_unlock(&uart_send_mutex[a1]);
  return v11;
}
// D860: using guessed type void *jpt_D85C[10];
// 125E18: using guessed type pthread_mutex_t uart_send_mutex[16];

//----- (0000DC64) --------------------------------------------------------
int __fastcall uart_receive(unsigned __int8 a1, int a2, unsigned int a3)
{
  int uart_data_in_fpga; // [sp+14h] [bp+14h]
  unsigned int v9; // [sp+18h] [bp+18h]
  unsigned int v10; // [sp+1Ch] [bp+1Ch]

  v9 = 0;
  pthread_mutex_lock(&uart_receive_mutex[a1]);
  if ( dword_146530 == 1385 )
    v9 = 5;
  v10 = check_how_many_uart_data_in_fpga(a1);
  if ( v10 > a3 )
  {
    v10 = a3;
    printf("%s: nbytes > buf_length\n", "uart_receive");
  }
  if ( v10 < v9 )
  {
    pthread_mutex_unlock(&uart_receive_mutex[a1]);
    return 0;
  }
  else
  {
    uart_data_in_fpga = read_uart_data_in_fpga(a1, a2, v9 * (v10 / v9));
    pthread_mutex_unlock(&uart_receive_mutex[a1]);
    return uart_data_in_fpga;
  }
}
// 125F98: using guessed type pthread_mutex_t uart_receive_mutex[16];
// 146530: using guessed type int dword_146530;

//----- (0000DD4C) --------------------------------------------------------
int __fastcall clear_uart_send_fifo(unsigned __int8 a1)
{
  int v4; // [sp+8h] [bp+8h]
  unsigned int v5; // [sp+14h] [bp+14h]
  char v6; // [sp+18h] [bp+18h]
  int v7; // [sp+1Ch] [bp+1Ch]

  printf("--- %s\n", "clear_uart_send_fifo");
  pthread_mutex_lock(&uart_send_mutex[a1]);
  switch ( a1 )
  {
    case 0u:
      v6 = 24;
      v7 = 1024;
      goto LABEL_13;
    case 1u:
      v6 = 16;
      v7 = 1024;
      goto LABEL_13;
    case 2u:
      v6 = 8;
      v7 = 1024;
      goto LABEL_13;
    case 3u:
      v6 = 0;
      v7 = 1024;
      goto LABEL_13;
    case 4u:
      v6 = 24;
      v7 = 1025;
      goto LABEL_13;
    case 5u:
      v6 = 16;
      v7 = 1025;
      goto LABEL_13;
    case 6u:
      v6 = 8;
      v7 = 1025;
      goto LABEL_13;
    case 7u:
      v6 = 0;
      v7 = 1025;
      goto LABEL_13;
    case 8u:
      v6 = 24;
      v7 = 1026;
      goto LABEL_13;
    case 9u:
      v6 = 16;
      v7 = 1026;
LABEL_13:
      v5 = 0;
      break;
    default:
      printf("%s: The uart%d is not supported!!!\n", "clear_uart_send_fifo", a1);
      pthread_mutex_unlock(&uart_send_mutex[a1]);
      return 1;
  }
  do
  {
    v4 = (unsigned __int8)(read_axi_fpga(v7) >> v6);
    if ( v4 == 255 )
    {
      pthread_mutex_unlock(&uart_send_mutex[a1]);
      return 0;
    }
    printf("%s: waiting fpga uart%d clear send fifo space ...\n", "clear_uart_send_fifo", a1);
    usleep(0xBB8u);
    ++v5;
  }
  while ( v5 <= 0x14 );
  printf("%s: uart%d always dose not has enough send fifo space, break\n", "clear_uart_send_fifo", a1);
  pthread_mutex_unlock(&uart_send_mutex[a1]);
  return v4;
}
// 125E18: using guessed type pthread_mutex_t uart_send_mutex[16];

//----- (0000DFA4) --------------------------------------------------------
int __fastcall clear_uart_rx_fifo(unsigned __int8 a1)
{
  void *ptr; // [sp+14h] [bp+Ch]
  int size; // [sp+18h] [bp+10h]
  int uart_data_in_fpga; // [sp+1Ch] [bp+14h]

  printf("--- %s\n", "clear_uart_rx_fifo");
  pthread_mutex_lock(&uart_receive_mutex[a1]);
  size = check_how_many_uart_data_in_fpga(a1);
  if ( size )
  {
    ptr = malloc(size);
    if ( ptr )
    {
      uart_data_in_fpga = read_uart_data_in_fpga(a1, (int)ptr, size);
      if ( uart_data_in_fpga != size )
        printf(
          "%s: uart%d clear rx fifo error. nbytes = %d, len = %d\n",
          "clear_uart_rx_fifo",
          a1,
          size,
          uart_data_in_fpga);
      free(ptr);
      usleep(0x2710u);
      pthread_mutex_unlock(&uart_receive_mutex[a1]);
      return 1;
    }
    else
    {
      printf("%s: uart%d malloc buffer error\n", "clear_uart_rx_fifo", a1);
      usleep((__useconds_t)&unk_7A120);
      pthread_mutex_unlock(&uart_receive_mutex[a1]);
      return 1;
    }
  }
  else
  {
    pthread_mutex_unlock(&uart_receive_mutex[a1]);
    return 0;
  }
}
// 125F98: using guessed type pthread_mutex_t uart_receive_mutex[16];

//----- (0000E108) --------------------------------------------------------
int open_key()
{
  key_fd = open("/sys/class/gpio/gpio943/value", 2048);
  if ( key_fd < 0 )
    puts("open key failed!!!");
  return key_fd;
}
// 126118: using guessed type int key_fd;

//----- (0000E150) --------------------------------------------------------
int close_key()
{
  close(key_fd);
  return puts("key closed!!!");
}
// 126118: using guessed type int key_fd;

//----- (0000E174) --------------------------------------------------------
int __fastcall read_key(char a1)
{
  char v3[5]; // [sp+7h] [bp+7h] BYREF
  ssize_t v4; // [sp+Ch] [bp+Ch]

  v3[0] = a1;
  v4 = 0;
  lseek(key_fd, 0, 0);
  v4 = read(key_fd, v3, 1u);
  if ( v4 == 1 )
    return 1;
  printf("%s: can't read out key value\n", "read_key");
  return -1;
}
// 126118: using guessed type int key_fd;
// E174: using guessed type char var_9[5];

//----- (0000E1DC) --------------------------------------------------------
int open_lcd()
{
  lcd_fd = open("/dev/bitmain-lcd", 2178);
  if ( lcd_fd <= 0 )
    puts("open lcd failed!!!");
  return lcd_fd;
}
// 12611C: using guessed type int lcd_fd;

//----- (0000E224) --------------------------------------------------------
int close_lcd()
{
  int v1; // [sp+4h] [bp+4h]

  v1 = close(lcd_fd);
  if ( v1 )
    puts("lcd close failed!!!");
  else
    puts("lcd closed!!!");
  return v1;
}
// 12611C: using guessed type int lcd_fd;

//----- (0000E270) --------------------------------------------------------
unsigned int __fastcall write_lcd(unsigned int result, int a2, unsigned int a3)
{
  _DWORD *v3; // r3
  int v4; // r0
  int v5; // r1
  int v6; // r2
  unsigned int n; // [sp+4h] [bp+4h]
  unsigned int v9; // [sp+Ch] [bp+Ch]
  int v10; // [sp+14h] [bp+14h]

  v9 = result;
  n = a3;
  v10 = 0;
  if ( a2 && lcd_fd > 0 )
  {
    if ( result <= 3 && a3 <= 0x40 )
    {
      lseek(lcd_fd, 0, 0);
      memset(&lcd_output, 32, 0x40u);
      while ( n )
      {
        if ( n <= 0x10 )
        {
          memcpy((char *)&lcd_output + 16 * v9, (const void *)(a2 + v10), n);
          return write(lcd_fd, &lcd_output, 0x40u);
        }
        v3 = (_DWORD *)((char *)&lcd_output + 16 * v9);
        v4 = *(_DWORD *)(a2 + v10 + 4);
        v5 = *(_DWORD *)(a2 + v10 + 8);
        v6 = *(_DWORD *)(a2 + v10 + 12);
        *v3 = *(_DWORD *)(a2 + v10);
        v3[1] = v4;
        v3[2] = v5;
        v3[3] = v6;
        ++v9;
        n -= 16;
        v10 += 16;
      }
      return write(lcd_fd, &lcd_output, 0x40u);
    }
    else
    {
      return printf("%s: write_lcd's arg is overflow\n", "write_lcd");
    }
  }
  return result;
}
// 12611C: using guessed type int lcd_fd;

//----- (0000E36C) --------------------------------------------------------
unsigned int __fastcall write_lcd_no_memset(unsigned int result, int a2, unsigned int a3)
{
  _DWORD *v3; // r3
  int v4; // r0
  int v5; // r1
  int v6; // r2
  unsigned int n; // [sp+4h] [bp+4h]
  unsigned int v9; // [sp+Ch] [bp+Ch]
  int v10; // [sp+14h] [bp+14h]

  v9 = result;
  n = a3;
  v10 = 0;
  if ( a2 && lcd_fd > 0 )
  {
    if ( result <= 3 && a3 <= 0x40 )
    {
      while ( n )
      {
        if ( n <= 0x10 )
        {
          memcpy((char *)&lcd_output + 16 * v9, (const void *)(a2 + v10), n);
          return write(lcd_fd, &lcd_output, 0x40u);
        }
        v3 = (_DWORD *)((char *)&lcd_output + 16 * v9);
        v4 = *(_DWORD *)(a2 + v10 + 4);
        v5 = *(_DWORD *)(a2 + v10 + 8);
        v6 = *(_DWORD *)(a2 + v10 + 12);
        *v3 = *(_DWORD *)(a2 + v10);
        v3[1] = v4;
        v3[2] = v5;
        v3[3] = v6;
        ++v9;
        n -= 16;
        v10 += 16;
      }
      return write(lcd_fd, &lcd_output, 0x40u);
    }
    else
    {
      return printf("%s: write_lcd's arg is overflow\n", "write_lcd_no_memset");
    }
  }
  return result;
}
// 12611C: using guessed type int lcd_fd;

//----- (0000E444) --------------------------------------------------------
int open_red_led()
{
  red_led_fd = open("/sys/class/gpio/gpio941/value", 2049);
  if ( red_led_fd < 0 )
    puts("open red led failed!!!");
  return red_led_fd;
}
// 126120: using guessed type int red_led_fd;

//----- (0000E48C) --------------------------------------------------------
int close_red_led()
{
  close(red_led_fd);
  return puts("red led closed!!!");
}
// 126120: using guessed type int red_led_fd;

//----- (0000E4B0) --------------------------------------------------------
ssize_t red_led_on()
{
  return write(red_led_fd, "1", 1u);
}
// 126120: using guessed type int red_led_fd;

//----- (0000E4D0) --------------------------------------------------------
ssize_t red_led_off()
{
  return write(red_led_fd, "0", 1u);
}
// 126120: using guessed type int red_led_fd;

//----- (0000E4F0) --------------------------------------------------------
int open_green_led()
{
  green_led_fd = open("/sys/class/gpio/gpio942/value", 2049);
  if ( green_led_fd < 0 )
    puts("open green led failed!!!");
  return green_led_fd;
}
// 126124: using guessed type int green_led_fd;

//----- (0000E538) --------------------------------------------------------
int close_green_led()
{
  close(green_led_fd);
  return puts("green led closed!!!");
}
// 126124: using guessed type int green_led_fd;

//----- (0000E55C) --------------------------------------------------------
ssize_t green_led_on()
{
  return write(green_led_fd, "1", 1u);
}
// 126124: using guessed type int green_led_fd;

//----- (0000E57C) --------------------------------------------------------
ssize_t green_led_off()
{
  return write(green_led_fd, "0", 1u);
}
// 126124: using guessed type int green_led_fd;

//----- (0000E59C) --------------------------------------------------------
int __fastcall c2hex(unsigned __int8 a1)
{
  unsigned __int8 v2; // [sp+Fh] [bp+Fh]

  v2 = -1;
  if ( a1 <= 0x2Fu || a1 > 0x39u )
  {
    switch ( a1 )
    {
      case 'a':
      case 'A':
        return 10;
      case 'b':
      case 'B':
        return 11;
      case 'c':
      case 'C':
        return 12;
      case 'd':
      case 'D':
        return 13;
      case 'e':
      case 'E':
        return 14;
      case 'f':
      case 'F':
        return 15;
      default:
        printf("input value error: %c\n", a1);
        break;
    }
  }
  else
  {
    return a1 & 0xF;
  }
  return v2;
}

//----- (0000E648) --------------------------------------------------------
unsigned __int8 __cdecl twoc2hex(unsigned __int8 high, unsigned __int8 low)
{
  char v4; // [sp+7h] [bp+7h]

  v4 = c2hex(high);
  return c2hex(low) ^ (16 * v4);
}

//----- (0000E68C) --------------------------------------------------------
int __fastcall s2hex(_BYTE *a1, _BYTE *a2, int a3)
{
  int v7; // [sp+14h] [bp+14h]
  int v8; // [sp+18h] [bp+18h]
  int i; // [sp+1Ch] [bp+1Ch]

  if ( a2 && a3 > 0 && a1 )
  {
    v8 = a3 / 2;
    v7 = a3 % 2;
    for ( i = 0; i < v8; ++i )
      a1[i] = twoc2hex(a2[2 * i], a2[2 * i + 1]);
    if ( v7 )
      a1[i] = twoc2hex(a2[2 * i], 0);
    return v8 + v7;
  }
  else
  {
    printf("s2hex para error dst(%p), src(%p), inlen(%d)\n", a1, a2, a3);
    return -1;
  }
}

//----- (0000E764) --------------------------------------------------------
int print_works()
{
  int v0; // r3
  int v2; // [sp+0h] [bp+0h]
  int v3; // [sp+0h] [bp+0h]
  int v4; // [sp+0h] [bp+0h]
  int v5; // [sp+0h] [bp+0h]
  int v6; // [sp+0h] [bp+0h]
  int v7; // [sp+4h] [bp+4h]
  int v8; // [sp+4h] [bp+4h]
  int v9; // [sp+4h] [bp+4h]
  int v10; // [sp+4h] [bp+4h]
  int v11; // [sp+4h] [bp+4h]
  unsigned int j; // [sp+8h] [bp+8h]
  unsigned int ii; // [sp+8h] [bp+8h]
  unsigned int nn; // [sp+8h] [bp+8h]
  unsigned int i4; // [sp+8h] [bp+8h]
  unsigned int i9; // [sp+8h] [bp+8h]
  int v17; // [sp+Ch] [bp+Ch]
  unsigned int i8; // [sp+Ch] [bp+Ch]
  unsigned int i7; // [sp+10h] [bp+10h]
  unsigned int v20; // [sp+14h] [bp+14h]
  unsigned int v21; // [sp+18h] [bp+18h]
  unsigned int v22; // [sp+1Ch] [bp+1Ch]
  unsigned int v23; // [sp+20h] [bp+20h]
  int v24; // [sp+24h] [bp+24h]
  int i; // [sp+28h] [bp+28h]
  int n; // [sp+28h] [bp+28h]
  int mm; // [sp+28h] [bp+28h]
  int i3; // [sp+28h] [bp+28h]
  int k; // [sp+2Ch] [bp+2Ch]
  int m; // [sp+2Ch] [bp+2Ch]
  int jj; // [sp+2Ch] [bp+2Ch]
  int kk; // [sp+2Ch] [bp+2Ch]
  int i1; // [sp+2Ch] [bp+2Ch]
  int i2; // [sp+2Ch] [bp+2Ch]
  int i5; // [sp+2Ch] [bp+2Ch]
  int i6; // [sp+2Ch] [bp+2Ch]
  int i10; // [sp+2Ch] [bp+2Ch]
  int i11; // [sp+2Ch] [bp+2Ch]

  v24 = 0;
  v23 = dword_146588;
  v22 = dword_14658C;
  v21 = dword_146590;
  v20 = dword_146594;
  v17 = 0;
  printf("\n--- %s begin\n\n", "print_works");
  if ( dword_146528 == 1 )
  {
    for ( i = 0; i <= 31; ++i )
    {
      if ( (v23 & 1) != 0 )
      {
        v7 = *((_DWORD *)&cgpu + v24 + 16427);
        for ( j = 0; dword_1464FC > j; ++j )
        {
          v2 = v7 + 116 * j;
          printf("core[%02d][%02d].midstate=0x", v17, j);
          for ( k = 0; k <= 31; ++k )
            printf("%02x", *(unsigned __int8 *)(v2 + k + 20));
          printf(" data2=");
          for ( m = 0; m <= 11; ++m )
            printf("%02x", *(unsigned __int8 *)(v2 + m + 8));
          printf(" nonce=0x%08x\n", *(_DWORD *)(v2 + 4));
        }
        putchar(10);
        ++v24;
      }
      v23 >>= 1;
      ++v17;
    }
    for ( n = 0; n <= 31; ++n )
    {
      if ( (v22 & 1) != 0 )
      {
        v8 = *((_DWORD *)&cgpu + v24 + 16427);
        for ( ii = 0; dword_1464FC > ii; ++ii )
        {
          v3 = v8 + 116 * ii;
          printf("core[%02d][%02d].midstate=0x", v17, ii);
          for ( jj = 0; jj <= 31; ++jj )
            printf("%02x", *(unsigned __int8 *)(v3 + jj + 20));
          printf(" data2=");
          for ( kk = 0; kk <= 11; ++kk )
            printf("%02x", *(unsigned __int8 *)(v3 + kk + 8));
          printf(" nonce=0x%08x\n", *(_DWORD *)(v3 + 4));
        }
        putchar(10);
        ++v24;
      }
      v22 >>= 1;
      ++v17;
    }
    for ( mm = 0; mm <= 31; ++mm )
    {
      if ( (v21 & 1) != 0 )
      {
        v9 = *((_DWORD *)&cgpu + v24 + 16427);
        for ( nn = 0; dword_1464FC > nn; ++nn )
        {
          v4 = v9 + 116 * nn;
          printf("core[%02d][%02d].midstate=0x", v17, nn);
          for ( i1 = 0; i1 <= 31; ++i1 )
            printf("%02x", *(unsigned __int8 *)(v4 + i1 + 20));
          printf(" data2=");
          for ( i2 = 0; i2 <= 11; ++i2 )
            printf("%02x", *(unsigned __int8 *)(v4 + i2 + 8));
          printf(" nonce=0x%08x\n", *(_DWORD *)(v4 + 4));
        }
        putchar(10);
        ++v24;
      }
      v21 >>= 1;
      ++v17;
    }
    for ( i3 = 0; i3 <= 31; ++i3 )
    {
      if ( (v20 & 1) != 0 )
      {
        v10 = *((_DWORD *)&cgpu + v24 + 16427);
        for ( i4 = 0; dword_1464FC > i4; ++i4 )
        {
          v5 = v10 + 116 * i4;
          printf("core[%02d][%02d].midstate=0x", v17, i4);
          for ( i5 = 0; i5 <= 31; ++i5 )
            printf("%02x", *(unsigned __int8 *)(v5 + i5 + 20));
          printf(" data2=");
          for ( i6 = 0; i6 <= 11; ++i6 )
            printf("%02x", *(unsigned __int8 *)(v5 + i6 + 8));
          printf(" nonce=0x%08x\n", *(_DWORD *)(v5 + 4));
        }
        putchar(10);
        ++v24;
      }
      v20 >>= 1;
      ++v17;
    }
  }
  else
  {
    for ( i7 = 0; dword_146528 > i7; ++i7 )
    {
      v11 = *((_DWORD *)&cgpu + i7 + 16427);
      for ( i8 = 0; dword_14652C > i8; ++i8 )
      {
        for ( i9 = 0; dword_1464FC > i9; ++i9 )
        {
          v6 = v11 + 116 * (i8 * dword_1464FC + i9);
          printf("asic[%02d][%02d][%02d].midstate=0x", i7, i8, i9);
          for ( i10 = 0; i10 <= 31; ++i10 )
            printf("%02x", *(unsigned __int8 *)(v6 + i10 + 20));
          printf(" data2=");
          for ( i11 = 0; i11 <= 11; ++i11 )
            printf("%02x", *(unsigned __int8 *)(v6 + i11 + 8));
          printf(" nonce=0x%08x\n", *(_DWORD *)(v6 + 4));
        }
      }
      putchar(10);
    }
  }
  printf("\n--- %s end\n\n", "print_works");
  return v0;
}
// ECF8: variable 'v0' is possibly undefined
// 1464FC: using guessed type int dword_1464FC;
// 146528: using guessed type int dword_146528;
// 14652C: using guessed type int dword_14652C;
// 146588: using guessed type int dword_146588;
// 14658C: using guessed type int dword_14658C;
// 146590: using guessed type int dword_146590;
// 146594: using guessed type int dword_146594;

//----- (0000ED04) --------------------------------------------------------
int __fastcall get_work(int a1, int a2)
{
  uint32_t v3; // r0
  char v7[1024]; // [sp+Ch] [bp+Ch] BYREF
  void *ptr; // [sp+40Ch] [bp+40Ch]
  int v9; // [sp+410h] [bp+410h]
  int i; // [sp+414h] [bp+414h]
  int v11; // [sp+418h] [bp+418h]
  char *v12; // [sp+41Ch] [bp+41Ch]

  memset(v7, 0, sizeof(v7));
  v11 = 0;
  v9 = 0;
  i = 0;
  *((_DWORD *)&cgpu + a1 + 16427) = malloc(116 * a2);
  if ( *((_DWORD *)&cgpu + a1 + 16427) )
  {
    while ( 1 )
    {
      if ( !fgets(v7, 1023, *((FILE **)&cgpu + a1)) || v11 >= a2 )
        return v11;
      ptr = (void *)(*((_DWORD *)&cgpu + a1 + 16427) + 116 * v11);
      v12 = strstr(v7, "nonce");
      if ( !v12 )
        break;
      for ( v12 += 5; *v12 == 32; ++v12 )
        ;
      s2hex((_BYTE *)ptr + 4, v12, 8);
      v3 = htonl(*((_DWORD *)ptr + 1));
      *((_DWORD *)ptr + 1) = v3;
      v12 = strstr(v7, "midstate");
      if ( !v12 )
        break;
      for ( v12 += 8; *v12 == 32; ++v12 )
        ;
      s2hex((_BYTE *)ptr + 20, v12, 64);
      v12 = strstr(v7, "data");
      if ( !v12 )
        break;
      for ( v12 += 4; *v12 == 32; ++v12 )
        ;
      s2hex((_BYTE *)ptr + 8, v12, 24);
      for ( i = 0; i <= 15; ++i )
        *((_DWORD *)ptr + i + 13) = 0;
      *(_DWORD *)ptr = v11++;
    }
    free(ptr);
    puts("get work err");
    return v11;
  }
  else
  {
    puts("malloc struct work err");
    return 0;
  }
}

//----- (0000EF74) --------------------------------------------------------
unsigned int __fastcall get_work_hash_board(int a1, int a2, FILE *a3, unsigned int a4)
{
  uint32_t v4; // r0
  char v11[1024]; // [sp+14h] [bp+14h] BYREF
  void *ptr; // [sp+414h] [bp+414h]
  int v13; // [sp+418h] [bp+418h]
  int i; // [sp+41Ch] [bp+41Ch]
  unsigned int v15; // [sp+420h] [bp+420h]
  char *v16; // [sp+424h] [bp+424h]

  memset(v11, 0, sizeof(v11));
  v15 = 0;
  v13 = 0;
  i = 0;
  while ( 1 )
  {
    if ( !fgets(v11, 1023, a3) || a4 <= v15 )
      return v15;
    ptr = (void *)(*((_DWORD *)&cgpu + a1 + 16427) + 116 * (a4 * a2 + v15));
    v16 = strstr(v11, "nonce");
    if ( !v16 )
      break;
    for ( v16 += 5; *v16 == 32; ++v16 )
      ;
    s2hex((_BYTE *)ptr + 4, v16, 8);
    v4 = htonl(*((_DWORD *)ptr + 1));
    *((_DWORD *)ptr + 1) = v4;
    v16 = strstr(v11, "midstate");
    if ( !v16 )
      break;
    for ( v16 += 8; *v16 == 32; ++v16 )
      ;
    s2hex((_BYTE *)ptr + 20, v16, 64);
    v16 = strstr(v11, "data");
    if ( !v16 )
      break;
    for ( v16 += 4; *v16 == 32; ++v16 )
      ;
    s2hex((_BYTE *)ptr + 8, v16, 24);
    for ( i = 0; i <= 15; ++i )
      *((_DWORD *)ptr + i + 13) = 0;
    *(_DWORD *)ptr = v15++;
  }
  free(ptr);
  puts("get work err");
  return v15;
}

//----- (0000F19C) --------------------------------------------------------
int get_works()
{
  FILE *v0; // r0
  int work; // r0
  unsigned int v3; // r4
  unsigned int v4; // r4
  char v6[64]; // [sp+Ch] [bp+4h] BYREF
  int v7; // [sp+4Ch] [bp+44h]
  int v8; // [sp+50h] [bp+48h]
  unsigned int v9; // [sp+54h] [bp+4Ch]
  unsigned int v10; // [sp+58h] [bp+50h]
  unsigned int v11; // [sp+5Ch] [bp+54h]
  unsigned int v12; // [sp+60h] [bp+58h]
  unsigned int k; // [sp+64h] [bp+5Ch]
  unsigned int m; // [sp+68h] [bp+60h]
  int v15; // [sp+6Ch] [bp+64h]
  int v16; // [sp+70h] [bp+68h]
  unsigned int v17; // [sp+74h] [bp+6Ch]
  unsigned int v18; // [sp+78h] [bp+70h]
  int v19; // [sp+7Ch] [bp+74h]
  int i; // [sp+80h] [bp+78h]
  int j; // [sp+84h] [bp+7Ch]

  memset(v6, 0, sizeof(v6));
  v8 = 0;
  v18 = 0;
  v17 = 0;
  v16 = 0;
  v15 = 0;
  m = 0;
  k = 0;
  v7 = 0;
  v12 = dword_146588;
  v11 = dword_14658C;
  v10 = dword_146590;
  v9 = dword_146594;
  printf("\n--- %s\n", "get_works");
  if ( dword_146528 == 1 )
  {
    for ( i = 0; i <= 31; ++i )
    {
      if ( (v12 & 1) != 0 )
        ++v16;
      v12 >>= 1;
      if ( (v11 & 1) != 0 )
        ++v16;
      v11 >>= 1;
      if ( (v10 & 1) != 0 )
        ++v16;
      v10 >>= 1;
      if ( (v9 & 1) != 0 )
        ++v16;
      v9 >>= 1;
    }
    printf("%s: single ASIC : we need test %d cores\n\n", "get_works", v16);
  }
  v12 = dword_146588;
  v11 = dword_14658C;
  v10 = dword_146590;
  v9 = dword_146594;
  if ( dword_146530 == 1385 )
    v17 = 50;
  if ( gHashBoard_V9 )
    v18 = 45;
  v15 = 0;
  if ( dword_146528 == 1 )
  {
    for ( j = 0; j < v16; ++j )
    {
      while ( v15 < (int)v17 )
      {
        if ( v15 > 31 )
        {
          if ( v15 > 63 )
          {
            if ( v15 > 95 )
            {
              if ( (v9 & 1) != 0 )
              {
                sprintf(v6, "%s%s%02i.txt", dest, byte_1361AC, v15++);
                v9 >>= 1;
                break;
              }
              v9 >>= 1;
            }
            else
            {
              if ( (v10 & 1) != 0 )
              {
                sprintf(v6, "%s%s%02i.txt", dest, byte_1361AC, v15++);
                v10 >>= 1;
                break;
              }
              v10 >>= 1;
            }
          }
          else
          {
            if ( (v11 & 1) != 0 )
            {
              sprintf(v6, "%s%s%02i.txt", dest, byte_1361AC, v15++);
              v11 >>= 1;
              break;
            }
            v11 >>= 1;
          }
        }
        else
        {
          if ( (v12 & 1) != 0 )
          {
            sprintf(v6, "%s%s%02i.txt", dest, byte_1361AC, v15++);
            v12 >>= 1;
            break;
          }
          v12 >>= 1;
        }
        ++v15;
      }
      v0 = fopen(v6, "r");
      *((_DWORD *)&cgpu + j) = v0;
      if ( !*((_DWORD *)&cgpu + j) )
        goto LABEL_38;
      work = get_work(j, dword_1464FC);
      *((_DWORD *)&cgpu + j + 16555) = work;
      fclose(*((FILE **)&cgpu + j));
    }
  }
  else
  {
    for ( k = 0; v18 > k; ++k )
    {
      *((_DWORD *)&cgpu + k + 16427) = malloc(116 * v17 * dword_1464FC);
      if ( !*((_DWORD *)&cgpu + k + 16427) )
      {
        printf("%s: malloc struct work err!\n", "get_works");
        return -1;
      }
      for ( m = 0; v17 > m; ++m )
      {
        sprintf(v6, "%s%02i%s%02i.txt", dest, k, byte_1361AC, m);
        v3 = k * v17 + m;
        *((_DWORD *)&cgpu + v3) = fopen(v6, "r");
        if ( !*((_DWORD *)&cgpu + k * v17 + m) )
        {
LABEL_38:
          printf("%s: Open test file %s error\n", "get_works", v6);
          return -1;
        }
        v4 = k * v17 + m;
        *((_DWORD *)&cgpu + v4 + 16555) = get_work_hash_board(k, m, *((FILE **)&cgpu + v4), dword_1464FC);
        fclose(*((FILE **)&cgpu + k * v17 + m));
      }
    }
  }
  dword_1463EC = dword_1363EC;
  v19 = 0;
  if ( dword_146528 == 1 )
  {
    for ( j = 0; j < v16; ++j )
    {
      if ( dword_1463EC > *((_DWORD *)&cgpu + j + 16555) )
      {
        dword_1463EC = *((_DWORD *)&cgpu + j + 16555);
        v19 = j;
      }
    }
  }
  else
  {
    for ( j = 0; (int)(v17 * v18) > j; ++j )
    {
      if ( dword_1463EC > *((_DWORD *)&cgpu + j + 16555) )
      {
        dword_1463EC = *((_DWORD *)&cgpu + j + 16555);
        v19 = j;
      }
    }
  }
  if ( dword_1464FC <= (unsigned int)dword_1463EC )
    return 0;
  write_lcd(1u, (int)"Get Less Work", 0xDu);
  printf("%s: cgpu.subid[%d] = %d, is the least pattern number\n", "get_works", v19, dword_1463EC);
  return -1;
}
// F366: conditional instruction was optimized away because %var_20.4>=20
// F3AA: conditional instruction was optimized away because %var_20.4>=40
// 25B08: using guessed type char gHashBoard_V9;
// 1363EC: using guessed type int dword_1363EC;
// 1463EC: using guessed type int dword_1463EC;
// 1464FC: using guessed type int dword_1464FC;
// 146528: using guessed type int dword_146528;
// 146530: using guessed type int dword_146530;
// 146588: using guessed type int dword_146588;
// 14658C: using guessed type int dword_14658C;
// 146590: using guessed type int dword_146590;
// 146594: using guessed type int dword_146594;

//----- (0000F7D4) --------------------------------------------------------
int clear_nonce_return_flag()
{
  int result; // r0
  int v1; // [sp+4h] [bp+4h]
  unsigned int v2; // [sp+Ch] [bp+Ch]
  unsigned int v3; // [sp+10h] [bp+10h]
  unsigned int v4; // [sp+14h] [bp+14h]
  unsigned int v5; // [sp+18h] [bp+18h]
  unsigned int k; // [sp+1Ch] [bp+1Ch]
  unsigned int jj; // [sp+1Ch] [bp+1Ch]
  unsigned int ii; // [sp+20h] [bp+20h]
  unsigned int n; // [sp+24h] [bp+24h]
  unsigned int m; // [sp+28h] [bp+28h]
  unsigned int kk; // [sp+28h] [bp+28h]
  unsigned int v12; // [sp+2Ch] [bp+2Ch]
  unsigned int v13; // [sp+30h] [bp+30h]
  int v14; // [sp+34h] [bp+34h]
  int i; // [sp+38h] [bp+38h]
  int j; // [sp+3Ch] [bp+3Ch]

  v14 = 0;
  v13 = 0;
  v12 = 0;
  v5 = dword_146588;
  v4 = dword_14658C;
  v3 = dword_146590;
  v2 = dword_146594;
  result = puts("clear_nonce_return_flag");
  if ( dword_146528 == 1 )
  {
    for ( i = 0; i <= 31; ++i )
    {
      if ( (v5 & 1) != 0 )
        ++v14;
      v5 >>= 1;
      if ( (v4 & 1) != 0 )
        ++v14;
      v4 >>= 1;
      if ( (v3 & 1) != 0 )
        ++v14;
      v3 >>= 1;
      if ( (v2 & 1) != 0 )
        ++v14;
      v2 >>= 1;
    }
    result = printf("%s: single ASIC get_pattern_loop = %d\n", "clear_nonce_return_flag", v14);
  }
  if ( dword_146530 == 1385 )
    v12 = 50;
  if ( gHashBoard_V9 )
    v13 = 45;
  if ( dword_146528 == 1 )
  {
    for ( j = 0; j < v14; ++j )
    {
      for ( k = 0; dword_1464FC > k; ++k )
      {
        for ( m = 0; m <= 0xF; ++m )
          *(_DWORD *)(*((_DWORD *)&cgpu + j + 16427) + 116 * k + 4 * (m + 12) + 4) = 0;
      }
    }
  }
  else
  {
    for ( n = 0; v13 > n; ++n )
    {
      v1 = *((_DWORD *)&cgpu + n + 16427);
      for ( ii = 0; v12 > ii; ++ii )
      {
        for ( jj = 0; dword_1464FC > jj; ++jj )
        {
          for ( kk = 0; kk <= 0xF; ++kk )
            *(_DWORD *)(v1 + 116 * (ii * dword_1464FC + jj) + 4 * (kk + 12) + 4) = 0;
        }
      }
    }
  }
  return result;
}
// 25B08: using guessed type char gHashBoard_V9;
// 1464FC: using guessed type int dword_1464FC;
// 146528: using guessed type int dword_146528;
// 146530: using guessed type int dword_146530;
// 146588: using guessed type int dword_146588;
// 14658C: using guessed type int dword_14658C;
// 146590: using guessed type int dword_146590;
// 146594: using guessed type int dword_146594;

//----- (0000FA18) --------------------------------------------------------
int __fastcall write_pic(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3)
{
  return i2c_write(a3 | (a1 << 26) | 0xA00000 | (a2 << 16));
}

//----- (0000FA50) --------------------------------------------------------
int __fastcall read_pic(unsigned __int8 a1, unsigned __int8 a2)
{
  return (unsigned __int8)i2c_read((a2 << 16) | (a1 << 26) | 0xA00000);
}

//----- (0000FA88) --------------------------------------------------------
int __fastcall set_PIC16F1704_flash_point32_ter(char a1, char a2, unsigned __int8 a3, unsigned __int8 a4)
{
  __int16 v4; // r3
  int v5; // r4
  int v11; // [sp+Ch] [bp+Ch]
  unsigned __int8 v12; // [sp+10h] [bp+10h]
  unsigned __int8 v13; // [sp+11h] [bp+11h]
  char v14; // [sp+12h] [bp+12h]
  char v15; // [sp+13h] [bp+13h]
  __int16 v16[2]; // [sp+14h] [bp+14h]
  char v17; // [sp+18h] [bp+18h]
  char v18; // [sp+19h] [bp+19h]
  __int16 v19; // [sp+1Ch] [bp+1Ch]
  char v20; // [sp+1Eh] [bp+1Eh]
  unsigned __int8 i; // [sp+1Fh] [bp+1Fh]

  v20 = 6;
  v16[0] = 255;
  v11 = 17214037;
  v4 = a3 + 6 + a4;
  v19 = v4 + 1;
  v17 = (unsigned __int16)(v4 + 1) >> 8;
  v18 = v4 + 1;
  v12 = a3;
  v13 = a4;
  v14 = v17;
  v15 = v4 + 1;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 7u; ++i )
    write_pic(a1, a2, *((_BYTE *)&v11 + i));
  usleep(0x186A0u);
  for ( i = 0; i <= 1u; ++i )
  {
    v5 = i;
    *((_BYTE *)v16 + v5) = read_pic(a1, a2);
  }
  pthread_mutex_unlock(&i2c_mutex);
  if ( LOBYTE(v16[0]) == 1 && HIBYTE(v16[0]) == 1 )
  {
    printf("\n--- %s ok\n\n", "set_PIC16F1704_flash_pointer");
    return 1;
  }
  else
  {
    printf(
      "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "set_PIC16F1704_flash_pointer",
      LOBYTE(v16[0]),
      HIBYTE(v16[0]));
    return 0;
  }
}
// 126128: using guessed type pthread_mutex_t i2c_mutex;

//----- (0000FBCC) --------------------------------------------------------
int __fastcall send_data_to_PIC16F1704(char a1, char a2, int a3)
{
  int v3; // r4
  _WORD v8[10]; // [sp+14h] [bp+14h] BYREF
  __int16 v9; // [sp+28h] [bp+28h]
  __int16 v10[2]; // [sp+2Ch] [bp+2Ch]
  __int16 v11; // [sp+30h] [bp+30h]
  char v12; // [sp+34h] [bp+34h]
  unsigned __int8 i; // [sp+35h] [bp+35h]
  __int16 v14; // [sp+36h] [bp+36h]

  v12 = 20;
  v11 = 255;
  v10[0] = 255;
  memset(v8, 0, sizeof(v8));
  v9 = 0;
  v14 = 22;
  for ( i = 0; i <= 0xFu; ++i )
    v14 += *(unsigned __int8 *)(a3 + i);
  LOBYTE(v11) = HIBYTE(v14);
  HIBYTE(v11) = v14;
  v8[0] = -21931;
  LOBYTE(v8[1]) = v12;
  HIBYTE(v8[1]) = 2;
  for ( i = 0; i <= 0xFu; ++i )
    *((_BYTE *)&v8[2] + i) = *(_BYTE *)(a3 + i);
  v9 = v11;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 0x15u; ++i )
    write_pic(a1, a2, *((_BYTE *)v8 + i));
  usleep(0x186A0u);
  for ( i = 0; i <= 1u; ++i )
  {
    v3 = i;
    *((_BYTE *)v10 + v3) = read_pic(a1, a2);
  }
  pthread_mutex_unlock(&i2c_mutex);
  if ( LOBYTE(v10[0]) == 2 && HIBYTE(v10[0]) == 1 )
  {
    printf("\n--- %s ok\n\n", "send_data_to_PIC16F1704");
    return 1;
  }
  else
  {
    printf(
      "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "send_data_to_PIC16F1704",
      LOBYTE(v10[0]),
      HIBYTE(v10[0]));
    return 0;
  }
}
// 126128: using guessed type pthread_mutex_t i2c_mutex;

//----- (0000FDA8) --------------------------------------------------------
int __fastcall read_PIC16F1704_flash_point32_ter(char a1, char a2, unsigned __int8 *a3, unsigned __int8 *a4)
{
  int v4; // r4
  int v11; // [sp+20h] [bp+10h]
  char v12; // [sp+24h] [bp+14h]
  char v13; // [sp+25h] [bp+15h]
  int v14; // [sp+28h] [bp+18h]
  __int16 v15; // [sp+2Ch] [bp+1Ch]
  __int16 v16; // [sp+30h] [bp+20h]
  __int16 v17; // [sp+34h] [bp+24h]
  char v18; // [sp+36h] [bp+26h]
  unsigned __int8 i; // [sp+37h] [bp+27h]

  v18 = 4;
  v16 = 3072;
  v14 = 255;
  v15 = 0;
  v11 = 134523477;
  v17 = 12;
  v12 = 0;
  v13 = 12;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(a1, a2, *((_BYTE *)&v11 + i));
  usleep(0x186A0u);
  for ( i = 0; i <= 5u; ++i )
  {
    v4 = i;
    *((_BYTE *)&v14 + v4) = read_pic(a1, a2);
  }
  pthread_mutex_unlock(&i2c_mutex);
  if ( BYTE1(v14) == 8
    && (unsigned __int8)v14 == 6
    && (v17 = (unsigned __int8)v14 + BYTE1(v14) + BYTE2(v14) + HIBYTE(v14), HIBYTE(v17) == (unsigned __int8)v15)
    && (unsigned __int8)v17 == HIBYTE(v15) )
  {
    *a3 = BYTE2(v14);
    *a4 = HIBYTE(v14);
    printf("\n--- %s ok! flash_addr_h = 0x%02x, flash_addr_l = 0x%02x\n\n", "read_PIC16F1704_flash_pointer", *a3, *a4);
    return 1;
  }
  else
  {
    printf(
      "\n"
      "--- %s failed! read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0"
      "x%x, read_back_data[4] = 0x%x, read_back_data[5] = 0x%x\n"
      "\n",
      "read_PIC16F1704_flash_pointer",
      (unsigned __int8)v14,
      BYTE1(v14),
      BYTE2(v14),
      HIBYTE(v14),
      (unsigned __int8)v15,
      HIBYTE(v15));
    return 0;
  }
}
// 126128: using guessed type pthread_mutex_t i2c_mutex;

//----- (0000FF8C) --------------------------------------------------------
int __fastcall read_PIC16F1704_flash_data(char a1, char a2, int a3)
{
  int v3; // r4
  int v9; // [sp+74h] [bp+2Ch]
  char v10; // [sp+78h] [bp+30h]
  char v11; // [sp+79h] [bp+31h]
  int v12; // [sp+7Ch] [bp+34h]
  int v13; // [sp+80h] [bp+38h]
  int v14; // [sp+84h] [bp+3Ch]
  int v15; // [sp+88h] [bp+40h]
  int v16; // [sp+8Ch] [bp+44h]
  __int16 v17; // [sp+90h] [bp+48h]
  unsigned __int16 v18; // [sp+94h] [bp+4Ch]
  char v19; // [sp+96h] [bp+4Eh]
  unsigned __int8 i; // [sp+97h] [bp+4Fh]

  v19 = 4;
  v17 = 1792;
  v12 = 255;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v9 = 50637397;
  v18 = 7;
  v10 = 0;
  v11 = 7;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(a1, a2, *((_BYTE *)&v9 + i));
  usleep((__useconds_t)&unk_493E0);
  for ( i = 0; i <= 0x13u; ++i )
  {
    v3 = i;
    *((_BYTE *)&v12 + v3) = read_pic(a1, a2);
  }
  pthread_mutex_unlock(&i2c_mutex);
  printf(
    "--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, \t\t"
    "read_back_data[4] = 0x%x, read_back_data[5] = 0x%x, read_back_data[6] = 0x%x, read_back_data[7] = 0x%x, \t\tread_bac"
    "k_data[8] = 0x%x, read_back_data[9] = 0x%x, read_back_data[10] = 0x%x, read_back_data[11] = 0x%x, \t\tread_back_data"
    "[12] = 0x%x, read_back_data[13] = 0x%x, read_back_data[14] = 0x%x, read_back_data[15] = 0x%x, \t\tread_back_data[16]"
    " = 0x%x, read_back_data[17] = 0x%x, read_back_data[18] = 0x%x, read_back_data[19] = 0x%x\n",
    "read_PIC16F1704_flash_data",
    (unsigned __int8)v12,
    BYTE1(v12),
    BYTE2(v12),
    HIBYTE(v12),
    (unsigned __int8)v13,
    BYTE1(v13),
    BYTE2(v13),
    HIBYTE(v13),
    (unsigned __int8)v14,
    BYTE1(v14),
    BYTE2(v14),
    HIBYTE(v14),
    (unsigned __int8)v15,
    BYTE1(v15),
    BYTE2(v15),
    HIBYTE(v15),
    (unsigned __int8)v16,
    BYTE1(v16),
    BYTE2(v16),
    HIBYTE(v16));
  usleep(0x186A0u);
  if ( BYTE1(v12) == 3 && (unsigned __int8)v12 == 20 )
  {
    v18 = (unsigned __int8)v12
        + BYTE1(v12)
        + BYTE2(v12)
        + HIBYTE(v12)
        + (unsigned __int8)v13
        + BYTE1(v13)
        + BYTE2(v13)
        + HIBYTE(v13)
        + (unsigned __int8)v14
        + BYTE1(v14)
        + BYTE2(v14)
        + HIBYTE(v14)
        + (unsigned __int8)v15
        + BYTE1(v15)
        + BYTE2(v15)
        + HIBYTE(v15)
        + (unsigned __int8)v16
        + BYTE1(v16);
    if ( HIBYTE(v18) == BYTE2(v16) && (unsigned __int8)v18 == HIBYTE(v16) )
    {
      for ( i = 0; i <= 0xFu; ++i )
        *(_BYTE *)(a3 + i) = *((_BYTE *)&v12 + i + 2);
      printf("\n--- %s ok\n\n", "read_PIC16F1704_flash_data");
      return 1;
    }
    else
    {
      printf("\n--- %s failed! crc = 0x%04x\n\n", "read_PIC16F1704_flash_data", v18);
      return 0;
    }
  }
  else
  {
    printf("\n--- %s failed!\n\n", "read_PIC16F1704_flash_data");
    return 0;
  }
}
// 126128: using guessed type pthread_mutex_t i2c_mutex;

//----- (000102F0) --------------------------------------------------------
int __fastcall erase_PIC16F1704_flash(unsigned __int8 a1, unsigned __int8 a2)
{
  int v2; // r4
  int v7; // [sp+Ch] [bp+Ch]
  char v8; // [sp+10h] [bp+10h]
  char v9; // [sp+11h] [bp+11h]
  __int16 v10[5]; // [sp+14h] [bp+14h]
  char v11; // [sp+1Eh] [bp+1Eh]
  unsigned __int8 i; // [sp+1Fh] [bp+1Fh]

  v11 = 4;
  v10[2] = 2048;
  v10[0] = 255;
  v7 = 67414613;
  v10[4] = 8;
  v8 = 0;
  v9 = 8;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(a1, a2, *((_BYTE *)&v7 + i));
  usleep(0x186A0u);
  for ( i = 0; i <= 1u; ++i )
  {
    v2 = i;
    *((_BYTE *)v10 + v2) = read_pic(a1, a2);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep((__useconds_t)&unk_30D40);
  if ( LOBYTE(v10[0]) == 4 && HIBYTE(v10[0]) == 1 )
  {
    printf("\n--- %s ok\n\n", "erase_PIC16F1704_flash");
    return 1;
  }
  else
  {
    printf(
      "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "erase_PIC16F1704_flash",
      LOBYTE(v10[0]),
      HIBYTE(v10[0]));
    return 0;
  }
}
// 126128: using guessed type pthread_mutex_t i2c_mutex;

//----- (00010424) --------------------------------------------------------
int __fastcall write_data_into_PIC16F1704_flash(unsigned __int8 a1, unsigned __int8 a2)
{
  int v2; // r4
  int v7; // [sp+Ch] [bp+Ch]
  char v8; // [sp+10h] [bp+10h]
  char v9; // [sp+11h] [bp+11h]
  __int16 v10[5]; // [sp+14h] [bp+14h]
  char v11; // [sp+1Eh] [bp+1Eh]
  unsigned __int8 i; // [sp+1Fh] [bp+1Fh]

  v11 = 4;
  v10[2] = 2304;
  v10[0] = 255;
  v7 = 84191829;
  v10[4] = 9;
  v8 = 0;
  v9 = 9;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(a1, a2, *((_BYTE *)&v7 + i));
  usleep((__useconds_t)&unk_30D40);
  for ( i = 0; i <= 1u; ++i )
  {
    v2 = i;
    *((_BYTE *)v10 + v2) = read_pic(a1, a2);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep((__useconds_t)&unk_30D40);
  if ( LOBYTE(v10[0]) == 5 && HIBYTE(v10[0]) == 1 )
  {
    printf("\n--- %s ok\n\n", "write_data_into_PIC16F1704_flash");
    return 1;
  }
  else
  {
    printf(
      "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "write_data_into_PIC16F1704_flash",
      LOBYTE(v10[0]),
      HIBYTE(v10[0]));
    return 0;
  }
}
// 126128: using guessed type pthread_mutex_t i2c_mutex;

//----- (00010558) --------------------------------------------------------
int __fastcall jump_from_loader_to_app_PIC16F1704(char a1, char a2)
{
  int v2; // r4
  int v7; // [sp+Ch] [bp+Ch]
  char v8; // [sp+10h] [bp+10h]
  char v9; // [sp+11h] [bp+11h]
  __int16 v10[5]; // [sp+14h] [bp+14h]
  char v11; // [sp+1Eh] [bp+1Eh]
  unsigned __int8 i; // [sp+1Fh] [bp+1Fh]

  v11 = 4;
  v10[2] = 2560;
  v10[0] = 255;
  v7 = 100969045;
  v10[4] = 10;
  v8 = 0;
  v9 = 10;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(a2, a1, *((_BYTE *)&v7 + i));
  usleep(0x186A0u);
  for ( i = 0; i <= 1u; ++i )
  {
    v2 = i;
    *((_BYTE *)v10 + v2) = read_pic(a2, a1);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep((__useconds_t)&unk_493E0);
  if ( LOBYTE(v10[0]) == 6 && HIBYTE(v10[0]) == 1 )
  {
    printf("\n--- %s ok\n\n", "jump_from_loader_to_app_PIC16F1704");
    return 1;
  }
  else
  {
    printf(
      "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "jump_from_loader_to_app_PIC16F1704",
      LOBYTE(v10[0]),
      HIBYTE(v10[0]));
    return 0;
  }
}
// 126128: using guessed type pthread_mutex_t i2c_mutex;

//----- (0001068C) --------------------------------------------------------
int __fastcall reset_PIC16F1704_pic(char a1, char a2)
{
  int v2; // r4
  int v7; // [sp+Ch] [bp+Ch]
  char v8; // [sp+10h] [bp+10h]
  char v9; // [sp+11h] [bp+11h]
  __int16 v10[5]; // [sp+14h] [bp+14h]
  char v11; // [sp+1Eh] [bp+1Eh]
  unsigned __int8 i; // [sp+1Fh] [bp+1Fh]

  v11 = 4;
  v10[2] = 2816;
  v10[0] = 255;
  v7 = 117746261;
  v10[4] = 11;
  v8 = 0;
  v9 = 11;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(a2, a1, *((_BYTE *)&v7 + i));
  usleep(0x186A0u);
  for ( i = 0; i <= 1u; ++i )
  {
    v2 = i;
    *((_BYTE *)v10 + v2) = read_pic(a2, a1);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep((__useconds_t)&unk_F4240);
  if ( LOBYTE(v10[0]) == 7 && HIBYTE(v10[0]) == 1 )
  {
    printf("\n--- %s ok\n\n", "reset_PIC16F1704_pic");
    return 1;
  }
  else
  {
    printf(
      "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "reset_PIC16F1704_pic",
      LOBYTE(v10[0]),
      HIBYTE(v10[0]));
    return 0;
  }
}
// 126128: using guessed type pthread_mutex_t i2c_mutex;

//----- (000107C0) --------------------------------------------------------
int __fastcall set_PIC16F1704_voltage(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3)
{
  int v3; // r4
  char v9[8]; // [sp+Ch] [bp+Ch]
  __int16 v10[2]; // [sp+14h] [bp+14h]
  char v11; // [sp+18h] [bp+18h]
  char v12; // [sp+19h] [bp+19h]
  __int16 v13; // [sp+1Ch] [bp+1Ch]
  char v14; // [sp+1Eh] [bp+1Eh]
  unsigned __int8 i; // [sp+1Fh] [bp+1Fh]

  v14 = 5;
  v10[0] = 255;
  printf("\n--- %s\n", "set_PIC16F1704_voltage");
  v13 = a3 + 21;
  v11 = HIBYTE(v13);
  v12 = a3 + 21;
  v9[0] = 85;
  v9[1] = -86;
  v9[2] = 5;
  v9[3] = 16;
  v9[4] = a3;
  v9[5] = HIBYTE(v13);
  v9[6] = a3 + 21;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 6u; ++i )
    write_pic(a2, a1, v9[i]);
  usleep((__useconds_t)&unk_30D40);
  for ( i = 0; i <= 1u; ++i )
  {
    v3 = i;
    *((_BYTE *)v10 + v3) = read_pic(a2, a1);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep((__useconds_t)&unk_30D40);
  if ( LOBYTE(v10[0]) == 16 && HIBYTE(v10[0]) == 1 )
  {
    printf("\n--- %s ok\n\n", "set_PIC16F1704_voltage");
    return 1;
  }
  else
  {
    printf(
      "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "set_PIC16F1704_voltage",
      LOBYTE(v10[0]),
      HIBYTE(v10[0]));
    return 0;
  }
}
// 126128: using guessed type pthread_mutex_t i2c_mutex;

//----- (00010928) --------------------------------------------------------
int __fastcall write_hash_ID_PIC16F1704(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  int v3; // r4
  _WORD v8[8]; // [sp+10h] [bp+10h] BYREF
  __int16 v9; // [sp+20h] [bp+20h]
  __int16 v10[2]; // [sp+24h] [bp+24h]
  __int16 v11; // [sp+28h] [bp+28h]
  char v12; // [sp+2Ch] [bp+2Ch]
  unsigned __int8 i; // [sp+2Dh] [bp+2Dh]
  __int16 v14; // [sp+2Eh] [bp+2Eh]

  v12 = 16;
  v11 = 255;
  v10[0] = 255;
  memset(v8, 0, sizeof(v8));
  v9 = 0;
  v14 = 34;
  for ( i = 0; i <= 0xBu; ++i )
    v14 += *(unsigned __int8 *)(a3 + i);
  LOBYTE(v11) = HIBYTE(v14);
  HIBYTE(v11) = v14;
  v8[0] = -21931;
  LOBYTE(v8[1]) = v12;
  HIBYTE(v8[1]) = 18;
  for ( i = 0; i <= 0xBu; ++i )
    *((_BYTE *)&v8[2] + i) = *(_BYTE *)(a3 + i);
  v9 = v11;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 0x11u; ++i )
    write_pic(a2, a1, *((_BYTE *)v8 + i));
  usleep((__useconds_t)&unk_61A80);
  for ( i = 0; i <= 1u; ++i )
  {
    v3 = i;
    *((_BYTE *)v10 + v3) = read_pic(a2, a1);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep((__useconds_t)&unk_30D40);
  if ( LOBYTE(v10[0]) == 18 && HIBYTE(v10[0]) == 1 )
  {
    printf("\n--- %s ok\n\n", "write_hash_ID_PIC16F1704");
    return 1;
  }
  else
  {
    printf(
      "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "write_hash_ID_PIC16F1704",
      LOBYTE(v10[0]),
      HIBYTE(v10[0]));
    return 0;
  }
}
// 126128: using guessed type pthread_mutex_t i2c_mutex;

//----- (00010B0C) --------------------------------------------------------
int __fastcall read_hash_id_PIC16F1704(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  int v3; // r4
  int v9; // [sp+50h] [bp+18h]
  char v10; // [sp+54h] [bp+1Ch]
  char v11; // [sp+55h] [bp+1Dh]
  int v12; // [sp+58h] [bp+20h]
  int v13; // [sp+5Ch] [bp+24h]
  int v14; // [sp+60h] [bp+28h]
  int v15; // [sp+64h] [bp+2Ch]
  __int16 v16; // [sp+68h] [bp+30h]
  unsigned __int16 v17; // [sp+6Ch] [bp+34h]
  char v18; // [sp+6Eh] [bp+36h]
  unsigned __int8 i; // [sp+6Fh] [bp+37h]

  v18 = 4;
  v16 = 5888;
  v12 = 255;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v9 = 319072853;
  v17 = 23;
  v10 = 0;
  v11 = 23;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(a1, a2, *((_BYTE *)&v9 + i));
  usleep((__useconds_t)&unk_30D40);
  for ( i = 0; i <= 0xFu; ++i )
  {
    v3 = i;
    *((_BYTE *)&v12 + v3) = read_pic(a1, a2);
  }
  pthread_mutex_unlock(&i2c_mutex);
  printf(
    "--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x,\t\tr"
    "ead_back_data[4] = 0x%x, read_back_data[5] = 0x%x, read_back_data[6] = 0x%x, read_back_data[7] = 0x%x,\t\tread_back_"
    "data[8] = 0x%x, read_back_data[9] = 0x%x, read_back_data[10] = 0x%x, read_back_data[11] = 0x%x,\t\tread_back_data[12"
    "] = 0x%x, read_back_data[13] = 0x%x, read_back_data[14] = 0x%x, read_back_data[15] = 0x%x\n",
    "read_hash_id_PIC16F1704",
    (unsigned __int8)v12,
    BYTE1(v12),
    BYTE2(v12),
    HIBYTE(v12),
    (unsigned __int8)v13,
    BYTE1(v13),
    BYTE2(v13),
    HIBYTE(v13),
    (unsigned __int8)v14,
    BYTE1(v14),
    BYTE2(v14),
    HIBYTE(v14),
    (unsigned __int8)v15,
    BYTE1(v15),
    BYTE2(v15),
    HIBYTE(v15));
  if ( BYTE1(v12) == 19 && (unsigned __int8)v12 == 16 )
  {
    v17 = (unsigned __int8)v12
        + BYTE1(v12)
        + BYTE2(v12)
        + HIBYTE(v12)
        + (unsigned __int8)v13
        + BYTE1(v13)
        + BYTE2(v13)
        + HIBYTE(v13)
        + (unsigned __int8)v14
        + BYTE1(v14)
        + BYTE2(v14)
        + HIBYTE(v14)
        + (unsigned __int8)v15
        + BYTE1(v15);
    if ( HIBYTE(v17) == BYTE2(v15) && (unsigned __int8)v17 == HIBYTE(v15) )
    {
      for ( i = 0; i <= 0xBu; ++i )
        *(_BYTE *)(a3 + i) = *((_BYTE *)&v12 + i + 2);
      printf("\n--- %s ok\n\n", "read_hash_id_PIC16F1704");
      return 1;
    }
    else
    {
      printf("\n--- %s failed! crc = 0x%04x\n\n", "read_hash_id_PIC16F1704", v17);
      return 0;
    }
  }
  else
  {
    printf("\n--- %s failed!\n\n", "read_hash_id_PIC16F1704");
    return 0;
  }
}
// 126128: using guessed type pthread_mutex_t i2c_mutex;

//----- (00010DF4) --------------------------------------------------------
int __fastcall enable_PIC16F1704_dc_dc(char a1, char a2, unsigned __int8 a3)
{
  int v3; // r4
  char v9[8]; // [sp+Ch] [bp+Ch]
  __int16 v10[2]; // [sp+14h] [bp+14h]
  char v11; // [sp+18h] [bp+18h]
  char v12; // [sp+19h] [bp+19h]
  __int16 v13; // [sp+1Ch] [bp+1Ch]
  char v14; // [sp+1Eh] [bp+1Eh]
  unsigned __int8 i; // [sp+1Fh] [bp+1Fh]

  v14 = 5;
  v10[0] = 255;
  printf("\n--- %s\n", "enable_PIC16F1704_dc_dc");
  v13 = a3 + 26;
  v11 = HIBYTE(v13);
  v12 = a3 + 26;
  v9[0] = 85;
  v9[1] = -86;
  v9[2] = 5;
  v9[3] = 21;
  v9[4] = a3;
  v9[5] = HIBYTE(v13);
  v9[6] = a3 + 26;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 6u; ++i )
    write_pic(a2, a1, v9[i]);
  usleep(0x186A0u);
  for ( i = 0; i <= 1u; ++i )
  {
    v3 = i;
    *((_BYTE *)v10 + v3) = read_pic(a2, a1);
  }
  pthread_mutex_unlock(&i2c_mutex);
  if ( LOBYTE(v10[0]) == 21 && HIBYTE(v10[0]) == 1 )
  {
    printf("\n--- %s ok\n\n", "enable_PIC16F1704_dc_dc");
    usleep((__useconds_t)&unk_7A120);
    return 1;
  }
  else
  {
    printf(
      "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "enable_PIC16F1704_dc_dc",
      LOBYTE(v10[0]),
      HIBYTE(v10[0]));
    return 0;
  }
}
// 126128: using guessed type pthread_mutex_t i2c_mutex;

//----- (00010F5C) --------------------------------------------------------
int __fastcall heart_beat_PIC16F1704(char a1, char a2)
{
  int v2; // r4
  int v7; // [sp+8h] [bp+8h]
  char v8; // [sp+Ch] [bp+Ch]
  char v9; // [sp+Dh] [bp+Dh]
  int v10; // [sp+10h] [bp+10h]
  __int16 v11; // [sp+14h] [bp+14h]
  __int16 v12; // [sp+18h] [bp+18h]
  __int16 v13; // [sp+1Ch] [bp+1Ch]
  char v14; // [sp+1Eh] [bp+1Eh]
  unsigned __int8 i; // [sp+1Fh] [bp+1Fh]

  v14 = 4;
  v12 = 6656;
  v10 = 255;
  v11 = 0;
  v7 = 369404501;
  v13 = 26;
  v8 = 0;
  v9 = 26;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(a2, a1, *((_BYTE *)&v7 + i));
  usleep(0x186A0u);
  for ( i = 0; i <= 5u; ++i )
  {
    v2 = i;
    *((_BYTE *)&v10 + v2) = read_pic(a2, a1);
  }
  pthread_mutex_unlock(&i2c_mutex);
  if ( BYTE1(v10) == 22 && BYTE2(v10) == 1 )
  {
    printf("\n--- %s ok\n\n", "heart_beat_PIC16F1704");
    return 1;
  }
  else
  {
    printf("\n--- %s failed!\n\n", "heart_beat_PIC16F1704");
    return 0;
  }
}
// 126128: using guessed type pthread_mutex_t i2c_mutex;

//----- (00011084) --------------------------------------------------------
void __fastcall __noreturn pic_heart_beat_func(char *a1)
{
  char v1; // [sp+Ah] [bp+Ah]
  char v2; // [sp+Bh] [bp+Bh]

  v2 = *a1;
  v1 = a1[1];
  while ( 1 )
  {
    heart_beat_PIC16F1704(v2, v1);
    sleep(0xAu);
  }
}

//----- (000110B0) --------------------------------------------------------
int __fastcall get_PIC16F1704_software_version(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 *a3)
{
  int v3; // r4
  int v9; // [sp+20h] [bp+10h]
  char v10; // [sp+24h] [bp+14h]
  char v11; // [sp+25h] [bp+15h]
  int v12; // [sp+28h] [bp+18h]
  unsigned __int8 v13; // [sp+2Ch] [bp+1Ch]
  __int16 v14; // [sp+30h] [bp+20h]
  unsigned __int16 v15; // [sp+34h] [bp+24h]
  char v16; // [sp+36h] [bp+26h]
  unsigned __int8 i; // [sp+37h] [bp+27h]

  v16 = 4;
  v14 = 6912;
  v12 = 255;
  v13 = 0;
  v9 = 386181717;
  v15 = 27;
  v10 = 0;
  v11 = 27;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(a1, a2, *((_BYTE *)&v9 + i));
  usleep((__useconds_t)&unk_30D40);
  for ( i = 0; i <= 4u; ++i )
  {
    v3 = i;
    *((_BYTE *)&v12 + v3) = read_pic(a1, a2);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep((__useconds_t)&unk_30D40);
  printf(
    "--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, read"
    "_back_data[4] = 0x%x\n",
    "get_PIC16F1704_software_version",
    (unsigned __int8)v12,
    BYTE1(v12),
    BYTE2(v12),
    HIBYTE(v12),
    v13);
  if ( BYTE1(v12) == 23 && (unsigned __int8)v12 == 5 )
  {
    v15 = (unsigned __int8)v12 + BYTE1(v12) + BYTE2(v12);
    if ( HIBYTE(v15) == HIBYTE(v12) && (unsigned __int8)v15 == v13 )
    {
      *a3 = BYTE2(v12);
      printf("\n--- %s ok, version = 0x%02x\n\n", "get_PIC16F1704_software_version", *a3);
      return 1;
    }
    else
    {
      printf("\n--- %s failed! crc = 0x%04x\n\n", "get_PIC16F1704_software_version", v15);
      return 0;
    }
  }
  else
  {
    printf("\n--- %s failed!\n\n", "get_PIC16F1704_software_version");
    return 0;
  }
}
// 126128: using guessed type pthread_mutex_t i2c_mutex;

//----- (00011284) --------------------------------------------------------
int __fastcall get_PIC16F1704_voltage(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 *a3)
{
  int v3; // r4
  int v9; // [sp+20h] [bp+10h]
  char v10; // [sp+24h] [bp+14h]
  char v11; // [sp+25h] [bp+15h]
  int v12; // [sp+28h] [bp+18h]
  unsigned __int8 v13; // [sp+2Ch] [bp+1Ch]
  __int16 v14; // [sp+30h] [bp+20h]
  unsigned __int16 v15; // [sp+34h] [bp+24h]
  char v16; // [sp+36h] [bp+26h]
  unsigned __int8 i; // [sp+37h] [bp+27h]

  v16 = 4;
  v14 = 7168;
  v12 = 255;
  v13 = 0;
  v9 = 402958933;
  v15 = 28;
  v10 = 0;
  v11 = 28;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(a1, a2, *((_BYTE *)&v9 + i));
  usleep((__useconds_t)&unk_30D40);
  for ( i = 0; i <= 4u; ++i )
  {
    v3 = i;
    *((_BYTE *)&v12 + v3) = read_pic(a1, a2);
  }
  pthread_mutex_unlock(&i2c_mutex);
  printf(
    "--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, read"
    "_back_data[4] = 0x%x\n",
    "get_PIC16F1704_voltage",
    (unsigned __int8)v12,
    BYTE1(v12),
    BYTE2(v12),
    HIBYTE(v12),
    v13);
  if ( BYTE1(v12) == 24 && (unsigned __int8)v12 == 5 )
  {
    v15 = (unsigned __int8)v12 + BYTE1(v12) + BYTE2(v12);
    if ( HIBYTE(v15) == HIBYTE(v12) && (unsigned __int8)v15 == v13 )
    {
      *a3 = BYTE2(v12);
      printf("\n--- %s ok, voltage = 0x%02x\n\n", "get_PIC16F1704_voltage", *a3);
      return 1;
    }
    else
    {
      printf("\n--- %s failed! crc = 0x%04x\n\n", "get_PIC16F1704_voltage", v15);
      return 0;
    }
  }
  else
  {
    printf("\n--- %s failed!\n\n", "get_PIC16F1704_voltage");
    return 0;
  }
}
// 126128: using guessed type pthread_mutex_t i2c_mutex;

//----- (0001144C) --------------------------------------------------------
int __fastcall write_temperature_offset_PIC16F1704(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  int v3; // r4
  _WORD v8[6]; // [sp+14h] [bp+14h] BYREF
  __int16 v9; // [sp+20h] [bp+20h]
  __int16 v10[2]; // [sp+24h] [bp+24h]
  __int16 v11; // [sp+28h] [bp+28h]
  char v12; // [sp+2Ch] [bp+2Ch]
  unsigned __int8 i; // [sp+2Dh] [bp+2Dh]
  __int16 v14; // [sp+2Eh] [bp+2Eh]

  v12 = 12;
  v11 = 255;
  v10[0] = 255;
  memset(v8, 0, sizeof(v8));
  v9 = 0;
  v14 = 46;
  for ( i = 0; i <= 7u; ++i )
    v14 += *(unsigned __int8 *)(a3 + i);
  LOBYTE(v11) = HIBYTE(v14);
  HIBYTE(v11) = v14;
  v8[0] = -21931;
  LOBYTE(v8[1]) = v12;
  HIBYTE(v8[1]) = 34;
  for ( i = 0; i <= 7u; ++i )
    *((_BYTE *)&v8[2] + i) = *(_BYTE *)(a3 + i);
  v9 = v11;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 0xDu; ++i )
    write_pic(a1, a2, *((_BYTE *)v8 + i));
  usleep((__useconds_t)&unk_30D40);
  for ( i = 0; i <= 1u; ++i )
  {
    v3 = i;
    *((_BYTE *)v10 + v3) = read_pic(a1, a2);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep((__useconds_t)&unk_30D40);
  if ( LOBYTE(v10[0]) == 34 && HIBYTE(v10[0]) == 1 )
  {
    printf("\n--- %s ok\n\n", "write_temperature_offset_PIC16F1704");
    return 1;
  }
  else
  {
    printf(
      "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "write_temperature_offset_PIC16F1704",
      LOBYTE(v10[0]),
      HIBYTE(v10[0]));
    return 0;
  }
}
// 126128: using guessed type pthread_mutex_t i2c_mutex;

//----- (00011628) --------------------------------------------------------
int __fastcall read_temperature_offset_PIC16F1704(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  int v3; // r4
  int v9; // [sp+3Ch] [bp+14h]
  char v10; // [sp+40h] [bp+18h]
  char v11; // [sp+41h] [bp+19h]
  int v12; // [sp+44h] [bp+1Ch]
  int v13; // [sp+48h] [bp+20h]
  int v14; // [sp+4Ch] [bp+24h]
  __int16 v15; // [sp+50h] [bp+28h]
  unsigned __int16 v16; // [sp+54h] [bp+2Ch]
  char v17; // [sp+56h] [bp+2Eh]
  unsigned __int8 i; // [sp+57h] [bp+2Fh]

  v17 = 4;
  v15 = 9984;
  v12 = 255;
  v13 = 0;
  v14 = 0;
  v9 = 587508309;
  v16 = 39;
  v10 = 0;
  v11 = 39;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(a1, a2, *((_BYTE *)&v9 + i));
  usleep((__useconds_t)&unk_30D40);
  for ( i = 0; i <= 0xBu; ++i )
  {
    v3 = i;
    *((_BYTE *)&v12 + v3) = read_pic(a1, a2);
  }
  pthread_mutex_unlock(&i2c_mutex);
  printf(
    "--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, \t\t"
    "read_back_data[4] = 0x%x, read_back_data[5] = 0x%x, read_back_data[6] = 0x%x, read_back_data[7] = 0x%x, \t\tread_bac"
    "k_data[8] = 0x%x, read_back_data[9] = 0x%x, read_back_data[10] = 0x%x, read_back_data[11] = 0x%x\n",
    "read_temperature_offset_PIC16F1704",
    (unsigned __int8)v12,
    BYTE1(v12),
    BYTE2(v12),
    HIBYTE(v12),
    (unsigned __int8)v13,
    BYTE1(v13),
    BYTE2(v13),
    HIBYTE(v13),
    (unsigned __int8)v14,
    BYTE1(v14),
    BYTE2(v14),
    HIBYTE(v14));
  if ( BYTE1(v12) == 35 && (unsigned __int8)v12 == 12 )
  {
    v16 = (unsigned __int8)v12
        + BYTE1(v12)
        + BYTE2(v12)
        + HIBYTE(v12)
        + (unsigned __int8)v13
        + BYTE1(v13)
        + BYTE2(v13)
        + HIBYTE(v13)
        + (unsigned __int8)v14
        + BYTE1(v14);
    if ( HIBYTE(v16) == BYTE2(v14) && (unsigned __int8)v16 == HIBYTE(v14) )
    {
      for ( i = 0; i <= 7u; ++i )
        *(_BYTE *)(a3 + i) = *((_BYTE *)&v12 + i + 2);
      printf("\n--- %s ok\n\n", "read_temperature_offset_PIC16F1704");
      return 1;
    }
    else
    {
      printf("\n--- %s failed! crc = 0x%04x\n\n", "read_temperature_offset_PIC16F1704", v16);
      return 0;
    }
  }
  else
  {
    printf("\n--- %s failed!\n\n", "read_temperature_offset_PIC16F1704");
    return 0;
  }
}
// 126128: using guessed type pthread_mutex_t i2c_mutex;

//----- (000118AC) --------------------------------------------------------
int __fastcall erase_PIC16F1704_app_flash(char a1, char a2)
{
  unsigned int i; // [sp+1Ch] [bp+1Ch]

  set_PIC16F1704_flash_point32_ter(a1, a2, 6u, 0);
  printf("%s: erase_loop = %d\n", "erase_PIC16F1704_app_flash", 76);
  for ( i = 0; i < 0x4C; ++i )
    erase_PIC16F1704_flash(a1, a2);
  return 76;
}

//----- (00011940) --------------------------------------------------------
int __fastcall PIC1704_update_pic_app_program(char a1, char a2)
{
  int v2; // r3
  int *v3; // r3
  int v4; // r0
  int v5; // r1
  int v6; // r2
  int v7; // r3
  int v11; // [sp+60h] [bp+60h] BYREF
  int v12; // [sp+64h] [bp+64h]
  int v13; // [sp+68h] [bp+68h]
  int v14; // [sp+6Ch] [bp+6Ch]
  char v15[8]; // [sp+70h] [bp+70h] BYREF
  _BYTE v16[5000]; // [sp+78h] [bp+78h] BYREF
  FILE *v17; // [sp+1400h] [bp+1400h]
  int v18; // [sp+1404h] [bp+1404h]
  unsigned int v19; // [sp+1408h] [bp+1408h]
  unsigned __int8 v20; // [sp+140Ch] [bp+140Ch]
  unsigned __int8 v21; // [sp+140Dh] [bp+140Dh]
  unsigned __int8 v22; // [sp+140Eh] [bp+140Eh]
  unsigned __int8 v23; // [sp+140Fh] [bp+140Fh]
  _DWORD v24[2]; // [sp+1410h] [bp+1410h]
  unsigned int i; // [sp+1418h] [bp+1418h]
  _DWORD v26[2]; // [sp+141Ch] [bp+141Ch]

  memset(v16, 0, sizeof(v16));
  v24[1] = 0;
  v26[0] = 0;
  v15[0] = 0;
  v15[1] = 0;
  v15[2] = 0;
  v15[3] = 0;
  v15[4] = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v24[0] = 0;
  v23 = 6;
  v22 = 0;
  v21 = 15;
  v20 = 127;
  v19 = 0;
  v18 = 0;
  puts("\n--- update pic program");
  v17 = fopen("/mnt/card/pic16f1704_app.txt", "r");
  if ( v17 )
  {
    fseek(v17, 0, 0);
    memset(v16, 0, sizeof(v16));
    v19 = (v21 << 8) + v20 - ((v23 << 8) + v22) + 1;
    printf("pic_flash_length = %d\n", v19);
    for ( v26[0] = 0; v26[0] < v19; ++v26[0] )
    {
      fgets(v15, 1023, v17);
      v24[0] = strtoul(v15, 0, 16);
      v16[2 * v26[0]] = BYTE1(v24[0]);
      v16[2 * v26[0] + 1] = v24[0];
    }
    fclose(v17);
    v18 = reset_PIC16F1704_pic(a1, a2);
    if ( v18 )
    {
      v18 = erase_PIC16F1704_app_flash(a1, a2);
      if ( v18 )
      {
        v18 = set_PIC16F1704_flash_point32_ter(a1, a2, 6u, 0);
        if ( v18 )
        {
          for ( v26[0] = 0; 4 * (v19 >> 5) > v26[0]; ++v26[0] )
          {
            v3 = (int *)&v16[16 * v26[0]];
            v4 = *v3;
            v5 = v3[1];
            v6 = v3[2];
            v7 = v3[3];
            v11 = v4;
            v12 = v5;
            v13 = v6;
            v14 = v7;
            printf("send pic program time: %d\n", v26[0]);
            for ( i = 0; i <= 0xF; ++i )
              printf("buf[%d] = 0x%02x\n", i, *((unsigned __int8 *)&v11 + i));
            putchar(10);
            send_data_to_PIC16F1704(a1, a2, (int)&v11);
            write_data_into_PIC16F1704_flash(a1, a2);
          }
          v18 = reset_PIC16F1704_pic(a1, a2);
          if ( v18 )
          {
            return 1;
          }
          else
          {
            printf("!!! %s: reset pic error!\n\n", "PIC1704_update_pic_app_program");
            return 0;
          }
        }
        else
        {
          printf("!!! %s: set flash pointer error!\n\n", "PIC1704_update_pic_app_program");
          return 0;
        }
      }
      else
      {
        printf("!!! %s: erase flash error!\n\n", "PIC1704_update_pic_app_program");
        return 0;
      }
    }
    else
    {
      printf("!!! %s: reset pic error!\n\n", "PIC1704_update_pic_app_program");
      return 0;
    }
  }
  else
  {
    printf("\n%s: open pic16f1704_app.txt failed\n", "PIC1704_update_pic_app_program");
  }
  return v2;
}
// 11DCA: variable 'v2' is possibly undefined

//----- (00011DD8) --------------------------------------------------------
int __fastcall save_freq_PIC16F1704(unsigned __int8 a1, unsigned __int8 a2, unsigned __int16 a3)
{
  __int16 v3; // r2
  int v4; // r4
  int v10; // [sp+Ch] [bp+Ch]
  char v11; // [sp+10h] [bp+10h]
  char v12; // [sp+11h] [bp+11h]
  char v13; // [sp+12h] [bp+12h]
  char v14; // [sp+13h] [bp+13h]
  __int16 v15[2]; // [sp+14h] [bp+14h]
  char v16; // [sp+18h] [bp+18h]
  char v17; // [sp+19h] [bp+19h]
  __int16 v18; // [sp+1Ch] [bp+1Ch]
  char v19; // [sp+1Eh] [bp+1Eh]
  unsigned __int8 i; // [sp+1Fh] [bp+1Fh]

  v19 = 6;
  v15[0] = 255;
  v10 = 604416597;
  v3 = HIBYTE(a3) + 6;
  v18 = v3 + (unsigned __int8)a3 + 36;
  v16 = HIBYTE(v18);
  v17 = v3 + a3 + 36;
  v11 = HIBYTE(a3);
  v12 = a3;
  v13 = HIBYTE(v18);
  v14 = v17;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 7u; ++i )
    write_pic(a2, a1, *((_BYTE *)&v10 + i));
  usleep((__useconds_t)&unk_493E0);
  for ( i = 0; i <= 1u; ++i )
  {
    v4 = i;
    *((_BYTE *)v15 + v4) = read_pic(a2, a1);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep((__useconds_t)&unk_30D40);
  if ( LOBYTE(v15[0]) == 36 && HIBYTE(v15[0]) == 1 )
  {
    printf("\n--- %s ok\n\n", "save_freq_PIC16F1704");
    return 1;
  }
  else
  {
    printf(
      "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "save_freq_PIC16F1704",
      LOBYTE(v15[0]),
      HIBYTE(v15[0]));
    return 0;
  }
}
// 126128: using guessed type pthread_mutex_t i2c_mutex;

//----- (00011F34) --------------------------------------------------------
int __fastcall get_PIC16F1704_freq(unsigned __int8 a1, unsigned __int8 a2, unsigned __int16 *a3)
{
  int v3; // r4
  int v9; // [sp+20h] [bp+10h]
  char v10; // [sp+24h] [bp+14h]
  char v11; // [sp+25h] [bp+15h]
  int v12; // [sp+28h] [bp+18h]
  __int16 v13; // [sp+2Ch] [bp+1Ch]
  __int16 v14; // [sp+30h] [bp+20h]
  unsigned __int16 v15; // [sp+34h] [bp+24h]
  char v16; // [sp+36h] [bp+26h]
  unsigned __int8 i; // [sp+37h] [bp+27h]

  v16 = 4;
  v14 = 10496;
  v12 = 255;
  v13 = 0;
  v9 = 621062741;
  v15 = 41;
  v10 = 0;
  v11 = 41;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(a2, a1, *((_BYTE *)&v9 + i));
  usleep((__useconds_t)&unk_493E0);
  for ( i = 0; i <= 5u; ++i )
  {
    v3 = i;
    *((_BYTE *)&v12 + v3) = read_pic(a2, a1);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep((__useconds_t)&unk_30D40);
  printf(
    "--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, read"
    "_back_data[4] = 0x%x, read_back_data[5] = 0x%x\n",
    "get_PIC16F1704_freq",
    (unsigned __int8)v12,
    BYTE1(v12),
    BYTE2(v12),
    HIBYTE(v12),
    (unsigned __int8)v13,
    HIBYTE(v13));
  if ( BYTE1(v12) == 37 && (unsigned __int8)v12 == 6 )
  {
    v15 = (unsigned __int8)v12 + BYTE1(v12) + BYTE2(v12) + HIBYTE(v12);
    if ( HIBYTE(v15) == (unsigned __int8)v13 && (unsigned __int8)v15 == HIBYTE(v13) )
    {
      *a3 = _byteswap_ushort(HIWORD(v12));
      printf("\n--- %s ok, freq = %d\n\n", "get_PIC16F1704_freq", *a3);
      return 1;
    }
    else
    {
      printf("\n--- %s failed! crc = 0x%04x\n\n", "get_PIC16F1704_freq", v15);
      return 0;
    }
  }
  else
  {
    printf("\n--- %s failed!\n\n", "get_PIC16F1704_freq");
    return 0;
  }
}
// 126128: using guessed type pthread_mutex_t i2c_mutex;

//----- (00012120) --------------------------------------------------------
int __fastcall set_temperature_offset_value(char a1, char a2, int a3)
{
  printf("\n--- %s\n", "set_temperature_offset_value");
  write_temperature_offset_PIC16F1704(a1, a2, a3);
  return usleep(0x186A0u);
}

//----- (00012164) --------------------------------------------------------
int __fastcall write_sensor_info_into_pic(char a1, char a2)
{
  char v5[8]; // [sp+8h] [bp+8h] BYREF

  printf("\n--- %s\n", "write_sensor_info_into_pic");
  v5[0] = byte_146598;
  v5[1] = 0;
  v5[2] = byte_146599;
  v5[3] = 0;
  v5[4] = byte_14659A;
  v5[5] = 0;
  v5[6] = byte_1465B4 | 0x20;
  v5[7] = dword_1465B8;
  return set_temperature_offset_value(a1, a2, (int)v5);
}
// 146598: using guessed type char byte_146598;
// 146599: using guessed type char byte_146599;
// 14659A: using guessed type char byte_14659A;
// 1465B4: using guessed type char byte_1465B4;
// 1465B8: using guessed type int dword_1465B8;

//----- (00012220) --------------------------------------------------------
int check_chain()
{
  int axi_fpga; // [sp+0h] [bp+0h]
  unsigned __int8 i; // [sp+7h] [bp+7h]

  printf("\n--- %s\n", "check_chain");
  dword_14642C = 0;
  axi_fpga = read_axi_fpga(2);
  if ( axi_fpga == 1 || axi_fpga == 2 || axi_fpga == 4 || axi_fpga == 8 )
  {
    for ( i = 0; i <= 0xFu; ++i )
    {
      chain_info[2 * i] = 0;
      chain_info[2 * i + 1] = 0;
      if ( ((axi_fpga >> i) & 1) != 0 )
      {
        *((_DWORD *)&cgpu + i + 32957) = 1;
        ++dword_14642C;
        gChain = i;
        gI2c = 0;
        chain_info[2 * i] = i;
        chain_info[2 * i + 1] = gI2c;
        printf("%s: gChain = %d, gI2c = %d\n", "check_chain", (unsigned __int8)gChain, (unsigned __int8)gI2c);
      }
      else
      {
        *((_DWORD *)&cgpu + i + 32957) = 0;
      }
    }
    return 0;
  }
  else
  {
    printf("%s: Test zhiju only support 1 plug, but now is 0x%08x\n", "check_chain", axi_fpga);
    return -1;
  }
}
// 25974: using guessed type char gChain;
// 25B0E: using guessed type char gI2c;
// 14642C: using guessed type int dword_14642C;
// 146498: using guessed type _BYTE chain_info[32];

//----- (000123AC) --------------------------------------------------------
int get_fan_speed()
{
  return read_axi_fpga(1);
}

//----- (000123BC) --------------------------------------------------------
int __fastcall set_fan_speed(int a1)
{
  return write_axi_fpga(33, a1);
}

//----- (000123D4) --------------------------------------------------------
int __fastcall fan_control(char a1)
{
  int result; // r0

  switch ( a1 )
  {
    case 0:
      result = set_fan_speed(100);
      break;
    case 1:
      result = set_fan_speed(655450);
      break;
    case 2:
      result = set_fan_speed(1310800);
      break;
    case 3:
      result = set_fan_speed(1966150);
      break;
    case 4:
      result = set_fan_speed(2621500);
      break;
    case 5:
      result = set_fan_speed(3276850);
      break;
    case 6:
      result = set_fan_speed(3932200);
      break;
    case 7:
      result = set_fan_speed(4587550);
      break;
    case 8:
      result = set_fan_speed(5242900);
      break;
    case 9:
      result = set_fan_speed(5898250);
      break;
    default:
      result = set_fan_speed(6553600);
      break;
  }
  return result;
}

//----- (00012498) --------------------------------------------------------
int reset_hash_board()
{
  write_axi_fpga(13, 0xFFFF);
  usleep((__useconds_t)&unk_493E0);
  write_axi_fpga(13, 0);
  return usleep((__useconds_t)&unk_493E0);
}

//----- (000124D4) --------------------------------------------------------
void __cdecl sha256_transf(sha256_ctx *ctx, const unsigned __int8 *message, unsigned int block_nb)
{
  unsigned int wv[8]; // [sp+14h] [bp+14h]
  unsigned int w[64]; // [sp+34h] [bp+34h]
  unsigned int v5; // [sp+134h] [bp+134h]
  unsigned int v6; // [sp+138h] [bp+138h]
  const unsigned __int8 *v7; // [sp+13Ch] [bp+13Ch]
  int j; // [sp+140h] [bp+140h]
  int i; // [sp+144h] [bp+144h]

  for ( i = 0; (int)block_nb > i; ++i )
  {
    v7 = &message[64 * i];
    for ( j = 0; j <= 15; ++j )
      w[j] = v7[4 * j + 3] | (v7[4 * j + 2] << 8) | (v7[4 * j + 1] << 16) | (v7[4 * j] << 24);
    for ( j = 16; j <= 63; ++j )
      w[j] = (__ROR4__(w[j - 2], 17) ^ __ROR4__(w[j - 2], 19) ^ (w[j - 2] >> 10))
           + w[j - 7]
           + ((w[j - 15] >> 3) ^ __ROR4__(w[j - 15], 7) ^ __ROR4__(w[j - 15], 18))
           + w[j - 16];
    for ( j = 0; j <= 7; ++j )
      wv[j] = *((_DWORD *)ctx + j + 34);
    for ( j = 0; j <= 63; ++j )
    {
      v6 = wv[7]
         + (__ROR4__(wv[4], 25) ^ __ROR4__(wv[4], 6) ^ __ROR4__(wv[4], 11))
         + (wv[6] & ~wv[4] ^ wv[4] & wv[5])
         + sha256_k[j]
         + w[j];
      v5 = (__ROR4__(wv[0], 2) ^ __ROR4__(wv[0], 13) ^ __ROR4__(wv[0], 22))
         + (wv[2] & wv[1] ^ wv[0] & wv[1] ^ wv[2] & wv[0]);
      wv[7] = wv[6];
      wv[6] = wv[5];
      wv[5] = wv[4];
      wv[4] = wv[3] + v6;
      wv[3] = wv[2];
      wv[2] = wv[1];
      wv[1] = wv[0];
      wv[0] = v6 + v5;
    }
    for ( j = 0; j <= 7; ++j )
      *((_DWORD *)ctx + j + 34) += wv[j];
  }
}
// 259F8: using guessed type _DWORD sha256_k[64];

//----- (00012824) --------------------------------------------------------
void __cdecl sha256(const unsigned __int8 *message, unsigned int len, unsigned __int8 *digest)
{
  char ctx[168]; // [sp+10h] [bp+10h] BYREF

  sha256_init((sha256_ctx *)ctx);
  sha256_update((sha256_ctx *)ctx, message, len);
  sha256_final((sha256_ctx *)ctx, digest);
}

//----- (0001285C) --------------------------------------------------------
void __cdecl sha256_init(sha256_ctx *ctx)
{
  int i; // [sp+Ch] [bp+Ch]

  for ( i = 0; i <= 7; ++i )
    *((_DWORD *)ctx + i + 34) = sha256_h0[i];
  *((_DWORD *)ctx + 1) = 0;
  *(_DWORD *)ctx = 0;
}
// 259D8: using guessed type _DWORD sha256_h0[8];

//----- (000128A4) --------------------------------------------------------
void __cdecl sha256_update(sha256_ctx *ctx, const unsigned __int8 *message, unsigned int len)
{
  unsigned int v3; // r3
  const unsigned __int8 *v7; // [sp+14h] [bp+14h]
  unsigned int v8; // [sp+18h] [bp+18h]
  size_t n; // [sp+20h] [bp+20h]
  unsigned int na; // [sp+20h] [bp+20h]

  v3 = len;
  if ( 64 - *((_DWORD *)ctx + 1) < len )
    v3 = 64 - *((_DWORD *)ctx + 1);
  n = v3;
  memcpy((char *)ctx + *((_DWORD *)ctx + 1) + 8, message, v3);
  if ( *((_DWORD *)ctx + 1) + len > 0x3F )
  {
    v8 = (len - n) >> 6;
    v7 = &message[n];
    sha256_transf(ctx, (const unsigned __int8 *)ctx + 8, 1u);
    sha256_transf(ctx, &message[n], v8);
    na = (len - n) & 0x3F;
    memcpy((char *)ctx + 8, &v7[64 * v8], na);
    *((_DWORD *)ctx + 1) = na;
    *(_DWORD *)ctx += (v8 + 1) << 6;
  }
  else
  {
    *((_DWORD *)ctx + 1) += len;
  }
}

//----- (00012960) --------------------------------------------------------
void __cdecl sha256_final(sha256_ctx *ctx, unsigned __int8 *digest)
{
  int v2; // r3
  int v5; // [sp+8h] [bp+8h]
  int v6; // [sp+Ch] [bp+Ch]
  unsigned int v7; // [sp+10h] [bp+10h]
  int i; // [sp+14h] [bp+14h]

  if ( (*((_DWORD *)ctx + 1) & 0x3Fu) <= 0x37 )
    v2 = 1;
  else
    v2 = 2;
  v7 = v2;
  v6 = 8 * (*(_DWORD *)ctx + *((_DWORD *)ctx + 1));
  v5 = v2 << 6;
  memset((char *)ctx + *((_DWORD *)ctx + 1) + 8, 0, (v2 << 6) - *((_DWORD *)ctx + 1));
  *((_BYTE *)ctx + *((_DWORD *)ctx + 1) + 8) = 0x80;
  *((_BYTE *)ctx + v5 + 7) = v6;
  *((_BYTE *)ctx + v5 + 6) = BYTE1(v6);
  *((_BYTE *)ctx + v5 + 5) = BYTE2(v6);
  *((_BYTE *)ctx + v5 + 4) = HIBYTE(v6);
  sha256_transf(ctx, (const unsigned __int8 *)ctx + 8, v7);
  for ( i = 0; i <= 7; ++i )
  {
    digest[4 * i + 3] = *((_DWORD *)ctx + i + 34);
    digest[4 * i + 2] = BYTE1(*((_DWORD *)ctx + i + 34));
    digest[4 * i + 1] = BYTE2(*((_DWORD *)ctx + i + 34));
    digest[4 * i] = HIBYTE(*((_DWORD *)ctx + i + 34));
  }
}

//----- (00012A84) --------------------------------------------------------
void __cdecl sha2_starts(sha2_context *ctx)
{
  *(_DWORD *)ctx = 0;
  *((_DWORD *)ctx + 1) = 0;
  *((_DWORD *)ctx + 2) = 1779033703;
  *((_DWORD *)ctx + 3) = -1150833019;
  *((_DWORD *)ctx + 4) = 1013904242;
  *((_DWORD *)ctx + 5) = -1521486534;
  *((_DWORD *)ctx + 6) = 1359893119;
  *((_DWORD *)ctx + 7) = -1694144372;
  *((_DWORD *)ctx + 8) = 528734635;
  *((_DWORD *)ctx + 9) = 1541459225;
}

//----- (00012B04) --------------------------------------------------------
void __cdecl sha2_process(sha2_context *ctx, const unsigned __int8 *data)
{
  unsigned int W; // [sp+8h] [bp+8h]
  unsigned int W_4; // [sp+Ch] [bp+Ch]
  unsigned int W_8; // [sp+10h] [bp+10h]
  unsigned int W_12; // [sp+14h] [bp+14h]
  unsigned int W_16; // [sp+18h] [bp+18h]
  unsigned int W_20; // [sp+1Ch] [bp+1Ch]
  unsigned int W_24; // [sp+20h] [bp+20h]
  unsigned int W_28; // [sp+24h] [bp+24h]
  unsigned int W_32; // [sp+28h] [bp+28h]
  unsigned int W_36; // [sp+2Ch] [bp+2Ch]
  unsigned int W_40; // [sp+30h] [bp+30h]
  unsigned int W_44; // [sp+34h] [bp+34h]
  unsigned int W_48; // [sp+38h] [bp+38h]
  unsigned int W_52; // [sp+3Ch] [bp+3Ch]
  unsigned int W_56; // [sp+40h] [bp+40h]
  unsigned int W_60; // [sp+44h] [bp+44h]
  unsigned int W_64; // [sp+48h] [bp+48h]
  unsigned int W_68; // [sp+4Ch] [bp+4Ch]
  unsigned int W_72; // [sp+50h] [bp+50h]
  unsigned int W_76; // [sp+54h] [bp+54h]
  unsigned int W_80; // [sp+58h] [bp+58h]
  unsigned int W_84; // [sp+5Ch] [bp+5Ch]
  unsigned int W_88; // [sp+60h] [bp+60h]
  unsigned int W_92; // [sp+64h] [bp+64h]
  unsigned int W_96; // [sp+68h] [bp+68h]
  unsigned int W_100; // [sp+6Ch] [bp+6Ch]
  unsigned int W_104; // [sp+70h] [bp+70h]
  unsigned int W_108; // [sp+74h] [bp+74h]
  unsigned int W_112; // [sp+78h] [bp+78h]
  unsigned int W_116; // [sp+7Ch] [bp+7Ch]
  unsigned int W_120; // [sp+80h] [bp+80h]
  unsigned int W_124; // [sp+84h] [bp+84h]
  unsigned int W_128; // [sp+88h] [bp+88h]
  unsigned int W_132; // [sp+8Ch] [bp+8Ch]
  unsigned int W_136; // [sp+90h] [bp+90h]
  unsigned int W_140; // [sp+94h] [bp+94h]
  unsigned int W_144; // [sp+98h] [bp+98h]
  unsigned int W_148; // [sp+9Ch] [bp+9Ch]
  unsigned int W_152; // [sp+A0h] [bp+A0h]
  unsigned int W_156; // [sp+A4h] [bp+A4h]
  unsigned int W_160; // [sp+A8h] [bp+A8h]
  unsigned int W_164; // [sp+ACh] [bp+ACh]
  unsigned int W_168; // [sp+B0h] [bp+B0h]
  unsigned int W_172; // [sp+B4h] [bp+B4h]
  unsigned int W_176; // [sp+B8h] [bp+B8h]
  unsigned int W_180; // [sp+BCh] [bp+BCh]
  unsigned int W_184; // [sp+C0h] [bp+C0h]
  unsigned int W_188; // [sp+C4h] [bp+C4h]
  unsigned int W_192; // [sp+C8h] [bp+C8h]
  unsigned int W_196; // [sp+CCh] [bp+CCh]
  unsigned int W_200; // [sp+D0h] [bp+D0h]
  unsigned int W_204; // [sp+D4h] [bp+D4h]
  unsigned int W_208; // [sp+D8h] [bp+D8h]
  unsigned int W_212; // [sp+DCh] [bp+DCh]
  unsigned int W_216; // [sp+E0h] [bp+E0h]
  unsigned int W_220; // [sp+E4h] [bp+E4h]
  unsigned int W_224; // [sp+E8h] [bp+E8h]
  unsigned int W_228; // [sp+ECh] [bp+ECh]
  unsigned int W_232; // [sp+F0h] [bp+F0h]
  unsigned int W_236; // [sp+F4h] [bp+F4h]
  unsigned int W_240; // [sp+F8h] [bp+F8h]
  unsigned int W_244; // [sp+FCh] [bp+FCh]
  int v64; // [sp+10Ch] [bp+10Ch]
  int v65; // [sp+10Ch] [bp+10Ch]
  int v66; // [sp+10Ch] [bp+10Ch]
  int v67; // [sp+10Ch] [bp+10Ch]
  int v68; // [sp+10Ch] [bp+10Ch]
  int v69; // [sp+10Ch] [bp+10Ch]
  int v70; // [sp+10Ch] [bp+10Ch]
  int v71; // [sp+10Ch] [bp+10Ch]
  int v72; // [sp+10Ch] [bp+10Ch]
  int v73; // [sp+10Ch] [bp+10Ch]
  int v74; // [sp+10Ch] [bp+10Ch]
  int v75; // [sp+10Ch] [bp+10Ch]
  int v76; // [sp+10Ch] [bp+10Ch]
  int v77; // [sp+10Ch] [bp+10Ch]
  int v78; // [sp+10Ch] [bp+10Ch]
  int v79; // [sp+10Ch] [bp+10Ch]
  int v80; // [sp+10Ch] [bp+10Ch]
  int v81; // [sp+10Ch] [bp+10Ch]
  int v82; // [sp+10Ch] [bp+10Ch]
  int v83; // [sp+10Ch] [bp+10Ch]
  int v84; // [sp+10Ch] [bp+10Ch]
  int v85; // [sp+10Ch] [bp+10Ch]
  int v86; // [sp+10Ch] [bp+10Ch]
  int v87; // [sp+10Ch] [bp+10Ch]
  int v88; // [sp+10Ch] [bp+10Ch]
  int v89; // [sp+10Ch] [bp+10Ch]
  int v90; // [sp+10Ch] [bp+10Ch]
  int v91; // [sp+10Ch] [bp+10Ch]
  int v92; // [sp+10Ch] [bp+10Ch]
  int v93; // [sp+10Ch] [bp+10Ch]
  int v94; // [sp+10Ch] [bp+10Ch]
  int v95; // [sp+10Ch] [bp+10Ch]
  int v96; // [sp+10Ch] [bp+10Ch]
  int v97; // [sp+10Ch] [bp+10Ch]
  int v98; // [sp+10Ch] [bp+10Ch]
  int v99; // [sp+10Ch] [bp+10Ch]
  int v100; // [sp+10Ch] [bp+10Ch]
  int v101; // [sp+10Ch] [bp+10Ch]
  int v102; // [sp+10Ch] [bp+10Ch]
  int v103; // [sp+10Ch] [bp+10Ch]
  int v104; // [sp+10Ch] [bp+10Ch]
  int v105; // [sp+10Ch] [bp+10Ch]
  int v106; // [sp+10Ch] [bp+10Ch]
  int v107; // [sp+10Ch] [bp+10Ch]
  int v108; // [sp+10Ch] [bp+10Ch]
  int v109; // [sp+10Ch] [bp+10Ch]
  int v110; // [sp+10Ch] [bp+10Ch]
  int v111; // [sp+10Ch] [bp+10Ch]
  int v112; // [sp+10Ch] [bp+10Ch]
  int v113; // [sp+10Ch] [bp+10Ch]
  int v114; // [sp+10Ch] [bp+10Ch]
  int v115; // [sp+10Ch] [bp+10Ch]
  int v116; // [sp+10Ch] [bp+10Ch]
  int v117; // [sp+10Ch] [bp+10Ch]
  int v118; // [sp+10Ch] [bp+10Ch]
  int v119; // [sp+10Ch] [bp+10Ch]
  int v120; // [sp+10Ch] [bp+10Ch]
  int v121; // [sp+10Ch] [bp+10Ch]
  int v122; // [sp+10Ch] [bp+10Ch]
  int v123; // [sp+10Ch] [bp+10Ch]
  int v124; // [sp+10Ch] [bp+10Ch]
  int v125; // [sp+10Ch] [bp+10Ch]
  int v126; // [sp+10Ch] [bp+10Ch]
  int v127; // [sp+10Ch] [bp+10Ch]
  int v128; // [sp+110h] [bp+110h]
  int v129; // [sp+110h] [bp+110h]
  int v130; // [sp+110h] [bp+110h]
  int v131; // [sp+110h] [bp+110h]
  int v132; // [sp+110h] [bp+110h]
  int v133; // [sp+110h] [bp+110h]
  int v134; // [sp+110h] [bp+110h]
  int v135; // [sp+110h] [bp+110h]
  int v136; // [sp+110h] [bp+110h]
  int v137; // [sp+110h] [bp+110h]
  int v138; // [sp+110h] [bp+110h]
  int v139; // [sp+110h] [bp+110h]
  int v140; // [sp+110h] [bp+110h]
  int v141; // [sp+110h] [bp+110h]
  int v142; // [sp+110h] [bp+110h]
  int v143; // [sp+110h] [bp+110h]
  int v144; // [sp+114h] [bp+114h]
  int v145; // [sp+114h] [bp+114h]
  int v146; // [sp+114h] [bp+114h]
  int v147; // [sp+114h] [bp+114h]
  int v148; // [sp+114h] [bp+114h]
  int v149; // [sp+114h] [bp+114h]
  int v150; // [sp+114h] [bp+114h]
  int v151; // [sp+114h] [bp+114h]
  int v152; // [sp+114h] [bp+114h]
  int v153; // [sp+114h] [bp+114h]
  int v154; // [sp+114h] [bp+114h]
  int v155; // [sp+114h] [bp+114h]
  int v156; // [sp+114h] [bp+114h]
  int v157; // [sp+114h] [bp+114h]
  int v158; // [sp+114h] [bp+114h]
  int v159; // [sp+114h] [bp+114h]
  int v160; // [sp+114h] [bp+114h]
  int v161; // [sp+118h] [bp+118h]
  int v162; // [sp+118h] [bp+118h]
  int v163; // [sp+118h] [bp+118h]
  int v164; // [sp+118h] [bp+118h]
  int v165; // [sp+118h] [bp+118h]
  int v166; // [sp+118h] [bp+118h]
  int v167; // [sp+118h] [bp+118h]
  int v168; // [sp+118h] [bp+118h]
  int v169; // [sp+118h] [bp+118h]
  int v170; // [sp+118h] [bp+118h]
  int v171; // [sp+118h] [bp+118h]
  int v172; // [sp+118h] [bp+118h]
  int v173; // [sp+118h] [bp+118h]
  int v174; // [sp+118h] [bp+118h]
  int v175; // [sp+118h] [bp+118h]
  int v176; // [sp+118h] [bp+118h]
  int v177; // [sp+118h] [bp+118h]
  int v178; // [sp+11Ch] [bp+11Ch]
  int v179; // [sp+11Ch] [bp+11Ch]
  int v180; // [sp+11Ch] [bp+11Ch]
  int v181; // [sp+11Ch] [bp+11Ch]
  int v182; // [sp+11Ch] [bp+11Ch]
  int v183; // [sp+11Ch] [bp+11Ch]
  int v184; // [sp+11Ch] [bp+11Ch]
  int v185; // [sp+11Ch] [bp+11Ch]
  int v186; // [sp+11Ch] [bp+11Ch]
  int v187; // [sp+11Ch] [bp+11Ch]
  int v188; // [sp+11Ch] [bp+11Ch]
  int v189; // [sp+11Ch] [bp+11Ch]
  int v190; // [sp+11Ch] [bp+11Ch]
  int v191; // [sp+11Ch] [bp+11Ch]
  int v192; // [sp+11Ch] [bp+11Ch]
  int v193; // [sp+11Ch] [bp+11Ch]
  int v194; // [sp+120h] [bp+120h]
  int v195; // [sp+120h] [bp+120h]
  int v196; // [sp+120h] [bp+120h]
  int v197; // [sp+120h] [bp+120h]
  int v198; // [sp+120h] [bp+120h]
  int v199; // [sp+120h] [bp+120h]
  int v200; // [sp+120h] [bp+120h]
  int v201; // [sp+120h] [bp+120h]
  int v202; // [sp+120h] [bp+120h]
  int v203; // [sp+120h] [bp+120h]
  int v204; // [sp+120h] [bp+120h]
  int v205; // [sp+120h] [bp+120h]
  int v206; // [sp+120h] [bp+120h]
  int v207; // [sp+120h] [bp+120h]
  int v208; // [sp+120h] [bp+120h]
  int v209; // [sp+120h] [bp+120h]
  int v210; // [sp+124h] [bp+124h]
  int v211; // [sp+124h] [bp+124h]
  int v212; // [sp+124h] [bp+124h]
  int v213; // [sp+124h] [bp+124h]
  int v214; // [sp+124h] [bp+124h]
  int v215; // [sp+124h] [bp+124h]
  int v216; // [sp+124h] [bp+124h]
  int v217; // [sp+124h] [bp+124h]
  int v218; // [sp+124h] [bp+124h]
  int v219; // [sp+124h] [bp+124h]
  int v220; // [sp+124h] [bp+124h]
  int v221; // [sp+124h] [bp+124h]
  int v222; // [sp+124h] [bp+124h]
  int v223; // [sp+124h] [bp+124h]
  int v224; // [sp+124h] [bp+124h]
  int v225; // [sp+124h] [bp+124h]
  int v226; // [sp+124h] [bp+124h]
  int v227; // [sp+128h] [bp+128h]
  int v228; // [sp+128h] [bp+128h]
  int v229; // [sp+128h] [bp+128h]
  int v230; // [sp+128h] [bp+128h]
  int v231; // [sp+128h] [bp+128h]
  int v232; // [sp+128h] [bp+128h]
  int v233; // [sp+128h] [bp+128h]
  int v234; // [sp+128h] [bp+128h]
  int v235; // [sp+128h] [bp+128h]
  int v236; // [sp+128h] [bp+128h]
  int v237; // [sp+128h] [bp+128h]
  int v238; // [sp+128h] [bp+128h]
  int v239; // [sp+128h] [bp+128h]
  int v240; // [sp+128h] [bp+128h]
  int v241; // [sp+128h] [bp+128h]
  int v242; // [sp+128h] [bp+128h]
  int v243; // [sp+128h] [bp+128h]
  int v244; // [sp+12Ch] [bp+12Ch]
  int v245; // [sp+12Ch] [bp+12Ch]
  int v246; // [sp+12Ch] [bp+12Ch]
  int v247; // [sp+12Ch] [bp+12Ch]
  int v248; // [sp+12Ch] [bp+12Ch]
  int v249; // [sp+12Ch] [bp+12Ch]
  int v250; // [sp+12Ch] [bp+12Ch]
  int v251; // [sp+12Ch] [bp+12Ch]
  int v252; // [sp+12Ch] [bp+12Ch]
  int v253; // [sp+12Ch] [bp+12Ch]
  int v254; // [sp+12Ch] [bp+12Ch]
  int v255; // [sp+12Ch] [bp+12Ch]
  int v256; // [sp+12Ch] [bp+12Ch]
  int v257; // [sp+12Ch] [bp+12Ch]
  int v258; // [sp+12Ch] [bp+12Ch]
  int v259; // [sp+12Ch] [bp+12Ch]

  W = _byteswap_ulong(*(_DWORD *)data);
  W_4 = _byteswap_ulong(*((_DWORD *)data + 1));
  W_8 = _byteswap_ulong(*((_DWORD *)data + 2));
  W_12 = _byteswap_ulong(*((_DWORD *)data + 3));
  W_16 = _byteswap_ulong(*((_DWORD *)data + 4));
  W_20 = _byteswap_ulong(*((_DWORD *)data + 5));
  W_24 = _byteswap_ulong(*((_DWORD *)data + 6));
  W_28 = _byteswap_ulong(*((_DWORD *)data + 7));
  W_32 = _byteswap_ulong(*((_DWORD *)data + 8));
  W_36 = _byteswap_ulong(*((_DWORD *)data + 9));
  W_40 = _byteswap_ulong(*((_DWORD *)data + 10));
  W_44 = _byteswap_ulong(*((_DWORD *)data + 11));
  W_48 = _byteswap_ulong(*((_DWORD *)data + 12));
  W_52 = _byteswap_ulong(*((_DWORD *)data + 13));
  W_56 = _byteswap_ulong(*((_DWORD *)data + 14));
  W_60 = _byteswap_ulong(*((_DWORD *)data + 15));
  v244 = *((_DWORD *)ctx + 2);
  v227 = *((_DWORD *)ctx + 3);
  v210 = *((_DWORD *)ctx + 4);
  v178 = *((_DWORD *)ctx + 6);
  v161 = *((_DWORD *)ctx + 7);
  v144 = *((_DWORD *)ctx + 8);
  v64 = (__ROR4__(v178, 6) ^ __ROR4__(v178, 11) ^ __ROR4__(v178, 25))
      + *((_DWORD *)ctx + 9)
      + (v144 ^ (v161 ^ v144) & v178)
      + W
      + 1116352408;
  v194 = *((_DWORD *)ctx + 5) + v64;
  v128 = v64 + (__ROR4__(v244, 2) ^ __ROR4__(v244, 13) ^ __ROR4__(v244, 22)) + (v210 & (v244 | v227) | v244 & v227);
  v65 = (__ROR4__(v194, 6) ^ __ROR4__(v194, 11) ^ __ROR4__(v194, 25))
      + v144
      + (v161 ^ (v178 ^ v161) & v194)
      + W_4
      + 1899447441;
  v211 = v210 + v65;
  v145 = v65 + (__ROR4__(v128, 2) ^ __ROR4__(v128, 13) ^ __ROR4__(v128, 22)) + (v227 & (v128 | v244) | v128 & v244);
  v66 = (__ROR4__(v211, 6) ^ __ROR4__(v211, 11) ^ __ROR4__(v211, 25))
      + v161
      + (v178 ^ (v194 ^ v178) & v211)
      + W_8
      - 1245643825;
  v228 = v227 + v66;
  v162 = v66 + (__ROR4__(v145, 2) ^ __ROR4__(v145, 13) ^ __ROR4__(v145, 22)) + (v244 & (v145 | v128) | v145 & v128);
  v67 = (__ROR4__(v228, 6) ^ __ROR4__(v228, 11) ^ __ROR4__(v228, 25))
      + v178
      + (v194 ^ (v211 ^ v194) & v228)
      + W_12
      - 373957723;
  v245 = v244 + v67;
  v179 = v67 + (__ROR4__(v162, 2) ^ __ROR4__(v162, 13) ^ __ROR4__(v162, 22)) + (v128 & (v162 | v145) | v162 & v145);
  v68 = (__ROR4__(v245, 6) ^ __ROR4__(v245, 11) ^ __ROR4__(v245, 25))
      + v194
      + (v211 ^ (v228 ^ v211) & v245)
      + W_16
      + 961987163;
  v129 = v128 + v68;
  v195 = v68 + (__ROR4__(v179, 2) ^ __ROR4__(v179, 13) ^ __ROR4__(v179, 22)) + (v145 & (v179 | v162) | v179 & v162);
  v69 = (__ROR4__(v129, 6) ^ __ROR4__(v129, 11) ^ __ROR4__(v129, 25))
      + v211
      + (v228 ^ (v245 ^ v228) & v129)
      + W_20
      + 1508970993;
  v146 = v145 + v69;
  v212 = v69 + (__ROR4__(v195, 2) ^ __ROR4__(v195, 13) ^ __ROR4__(v195, 22)) + (v162 & (v195 | v179) | v195 & v179);
  v70 = (__ROR4__(v146, 6) ^ __ROR4__(v146, 11) ^ __ROR4__(v146, 25))
      + v228
      + (v245 ^ (v129 ^ v245) & v146)
      + W_24
      - 1841331548;
  v163 = v162 + v70;
  v229 = v70 + (__ROR4__(v212, 2) ^ __ROR4__(v212, 13) ^ __ROR4__(v212, 22)) + (v179 & (v212 | v195) | v212 & v195);
  v71 = (__ROR4__(v163, 6) ^ __ROR4__(v163, 11) ^ __ROR4__(v163, 25))
      + v245
      + (v129 ^ (v146 ^ v129) & v163)
      + W_28
      - 1424204075;
  v180 = v179 + v71;
  v246 = v71 + (__ROR4__(v229, 2) ^ __ROR4__(v229, 13) ^ __ROR4__(v229, 22)) + (v195 & (v229 | v212) | v229 & v212);
  v72 = (__ROR4__(v180, 6) ^ __ROR4__(v180, 11) ^ __ROR4__(v180, 25))
      + v129
      + (v146 ^ (v163 ^ v146) & v180)
      + W_32
      - 670586216;
  v196 = v195 + v72;
  v130 = v72 + (__ROR4__(v246, 2) ^ __ROR4__(v246, 13) ^ __ROR4__(v246, 22)) + (v212 & (v246 | v229) | v246 & v229);
  v73 = (__ROR4__(v196, 6) ^ __ROR4__(v196, 11) ^ __ROR4__(v196, 25))
      + v146
      + (v163 ^ (v180 ^ v163) & v196)
      + W_36
      + 310598401;
  v213 = v212 + v73;
  v147 = v73 + (__ROR4__(v130, 2) ^ __ROR4__(v130, 13) ^ __ROR4__(v130, 22)) + (v229 & (v130 | v246) | v130 & v246);
  v74 = (__ROR4__(v213, 6) ^ __ROR4__(v213, 11) ^ __ROR4__(v213, 25))
      + v163
      + (v180 ^ (v196 ^ v180) & v213)
      + W_40
      + 607225278;
  v230 = v229 + v74;
  v164 = v74 + (__ROR4__(v147, 2) ^ __ROR4__(v147, 13) ^ __ROR4__(v147, 22)) + (v246 & (v147 | v130) | v147 & v130);
  v75 = (__ROR4__(v230, 6) ^ __ROR4__(v230, 11) ^ __ROR4__(v230, 25))
      + v180
      + (v196 ^ (v213 ^ v196) & v230)
      + W_44
      + 1426881987;
  v247 = v246 + v75;
  v181 = v75 + (__ROR4__(v164, 2) ^ __ROR4__(v164, 13) ^ __ROR4__(v164, 22)) + (v130 & (v164 | v147) | v164 & v147);
  v76 = (__ROR4__(v247, 6) ^ __ROR4__(v247, 11) ^ __ROR4__(v247, 25))
      + v196
      + (v213 ^ (v230 ^ v213) & v247)
      + W_48
      + 1925078388;
  v131 = v130 + v76;
  v197 = v76 + (__ROR4__(v181, 2) ^ __ROR4__(v181, 13) ^ __ROR4__(v181, 22)) + (v147 & (v181 | v164) | v181 & v164);
  v77 = (__ROR4__(v131, 6) ^ __ROR4__(v131, 11) ^ __ROR4__(v131, 25))
      + v213
      + (v230 ^ (v247 ^ v230) & v131)
      + W_52
      - 2132889090;
  v148 = v147 + v77;
  v214 = v77 + (__ROR4__(v197, 2) ^ __ROR4__(v197, 13) ^ __ROR4__(v197, 22)) + (v164 & (v197 | v181) | v197 & v181);
  v78 = (__ROR4__(v148, 6) ^ __ROR4__(v148, 11) ^ __ROR4__(v148, 25))
      + v230
      + (v247 ^ (v131 ^ v247) & v148)
      + W_56
      - 1680079193;
  v165 = v164 + v78;
  v231 = v78 + (__ROR4__(v214, 2) ^ __ROR4__(v214, 13) ^ __ROR4__(v214, 22)) + (v181 & (v214 | v197) | v214 & v197);
  v79 = (__ROR4__(v165, 6) ^ __ROR4__(v165, 11) ^ __ROR4__(v165, 25))
      + v247
      + (v131 ^ (v148 ^ v131) & v165)
      + W_60
      - 1046744716;
  v182 = v181 + v79;
  v248 = v79 + (__ROR4__(v231, 2) ^ __ROR4__(v231, 13) ^ __ROR4__(v231, 22)) + (v197 & (v231 | v214) | v231 & v214);
  W_64 = (__ROR4__(W_56, 17) ^ __ROR4__(W_56, 19) ^ (W_56 >> 10))
       + W_36
       + ((W_4 >> 3) ^ __ROR4__(W_4, 7) ^ __ROR4__(W_4, 18))
       + W;
  v80 = (__ROR4__(v182, 6) ^ __ROR4__(v182, 11) ^ __ROR4__(v182, 25))
      + v131
      + (v148 ^ (v165 ^ v148) & v182)
      + W_64
      - 459576895;
  v198 = v197 + v80;
  v132 = v80 + (__ROR4__(v248, 2) ^ __ROR4__(v248, 13) ^ __ROR4__(v248, 22)) + (v214 & (v248 | v231) | v248 & v231);
  W_68 = (__ROR4__(W_60, 17) ^ __ROR4__(W_60, 19) ^ (W_60 >> 10))
       + W_40
       + ((W_8 >> 3) ^ __ROR4__(W_8, 7) ^ __ROR4__(W_8, 18))
       + W_4;
  v81 = (__ROR4__(v198, 6) ^ __ROR4__(v198, 11) ^ __ROR4__(v198, 25))
      + v148
      + (v165 ^ (v182 ^ v165) & v198)
      + W_68
      - 272742522;
  v215 = v214 + v81;
  v149 = v81 + (__ROR4__(v132, 2) ^ __ROR4__(v132, 13) ^ __ROR4__(v132, 22)) + (v231 & (v132 | v248) | v132 & v248);
  W_72 = (__ROR4__(W_64, 17) ^ __ROR4__(W_64, 19) ^ (W_64 >> 10))
       + W_44
       + ((W_12 >> 3) ^ __ROR4__(W_12, 7) ^ __ROR4__(W_12, 18))
       + W_8;
  v82 = (__ROR4__(v215, 6) ^ __ROR4__(v215, 11) ^ __ROR4__(v215, 25))
      + v165
      + (v182 ^ (v198 ^ v182) & v215)
      + W_72
      + 264347078;
  v232 = v231 + v82;
  v166 = v82 + (__ROR4__(v149, 2) ^ __ROR4__(v149, 13) ^ __ROR4__(v149, 22)) + (v248 & (v149 | v132) | v149 & v132);
  W_76 = (__ROR4__(W_68, 17) ^ __ROR4__(W_68, 19) ^ (W_68 >> 10))
       + W_48
       + ((W_16 >> 3) ^ __ROR4__(W_16, 7) ^ __ROR4__(W_16, 18))
       + W_12;
  v83 = (__ROR4__(v232, 6) ^ __ROR4__(v232, 11) ^ __ROR4__(v232, 25))
      + v182
      + (v198 ^ (v215 ^ v198) & v232)
      + W_76
      + 604807628;
  v249 = v248 + v83;
  v183 = v83 + (__ROR4__(v166, 2) ^ __ROR4__(v166, 13) ^ __ROR4__(v166, 22)) + (v132 & (v166 | v149) | v166 & v149);
  W_80 = (__ROR4__(W_72, 17) ^ __ROR4__(W_72, 19) ^ (W_72 >> 10))
       + W_52
       + ((W_20 >> 3) ^ __ROR4__(W_20, 7) ^ __ROR4__(W_20, 18))
       + W_16;
  v84 = (__ROR4__(v249, 6) ^ __ROR4__(v249, 11) ^ __ROR4__(v249, 25))
      + v198
      + (v215 ^ (v232 ^ v215) & v249)
      + W_80
      + 770255983;
  v133 = v132 + v84;
  v199 = v84 + (__ROR4__(v183, 2) ^ __ROR4__(v183, 13) ^ __ROR4__(v183, 22)) + (v149 & (v183 | v166) | v183 & v166);
  W_84 = (__ROR4__(W_76, 17) ^ __ROR4__(W_76, 19) ^ (W_76 >> 10))
       + W_56
       + ((W_24 >> 3) ^ __ROR4__(W_24, 7) ^ __ROR4__(W_24, 18))
       + W_20;
  v85 = (__ROR4__(v133, 6) ^ __ROR4__(v133, 11) ^ __ROR4__(v133, 25))
      + v215
      + (v232 ^ (v249 ^ v232) & v133)
      + W_84
      + 1249150122;
  v150 = v149 + v85;
  v216 = v85 + (__ROR4__(v199, 2) ^ __ROR4__(v199, 13) ^ __ROR4__(v199, 22)) + (v166 & (v199 | v183) | v199 & v183);
  W_88 = (__ROR4__(W_80, 17) ^ __ROR4__(W_80, 19) ^ (W_80 >> 10))
       + W_60
       + ((W_28 >> 3) ^ __ROR4__(W_28, 7) ^ __ROR4__(W_28, 18))
       + W_24;
  v86 = (__ROR4__(v150, 6) ^ __ROR4__(v150, 11) ^ __ROR4__(v150, 25))
      + v232
      + (v249 ^ (v133 ^ v249) & v150)
      + W_88
      + 1555081692;
  v167 = v166 + v86;
  v233 = v86 + (__ROR4__(v216, 2) ^ __ROR4__(v216, 13) ^ __ROR4__(v216, 22)) + (v183 & (v216 | v199) | v216 & v199);
  W_92 = (__ROR4__(W_84, 17) ^ __ROR4__(W_84, 19) ^ (W_84 >> 10))
       + W_64
       + ((W_32 >> 3) ^ __ROR4__(W_32, 7) ^ __ROR4__(W_32, 18))
       + W_28;
  v87 = (__ROR4__(v167, 6) ^ __ROR4__(v167, 11) ^ __ROR4__(v167, 25))
      + v249
      + (v133 ^ (v150 ^ v133) & v167)
      + W_92
      + 1996064986;
  v184 = v183 + v87;
  v250 = v87 + (__ROR4__(v233, 2) ^ __ROR4__(v233, 13) ^ __ROR4__(v233, 22)) + (v199 & (v233 | v216) | v233 & v216);
  W_96 = (__ROR4__(W_88, 17) ^ __ROR4__(W_88, 19) ^ (W_88 >> 10))
       + W_68
       + ((W_36 >> 3) ^ __ROR4__(W_36, 7) ^ __ROR4__(W_36, 18))
       + W_32;
  v88 = (__ROR4__(v184, 6) ^ __ROR4__(v184, 11) ^ __ROR4__(v184, 25))
      + v133
      + (v150 ^ (v167 ^ v150) & v184)
      + W_96
      - 1740746414;
  v200 = v199 + v88;
  v134 = v88 + (__ROR4__(v250, 2) ^ __ROR4__(v250, 13) ^ __ROR4__(v250, 22)) + (v216 & (v250 | v233) | v250 & v233);
  W_100 = (__ROR4__(W_92, 17) ^ __ROR4__(W_92, 19) ^ (W_92 >> 10))
        + W_72
        + ((W_40 >> 3) ^ __ROR4__(W_40, 7) ^ __ROR4__(W_40, 18))
        + W_36;
  v89 = (__ROR4__(v200, 6) ^ __ROR4__(v200, 11) ^ __ROR4__(v200, 25))
      + v150
      + (v167 ^ (v184 ^ v167) & v200)
      + W_100
      - 1473132947;
  v217 = v216 + v89;
  v151 = v89 + (__ROR4__(v134, 2) ^ __ROR4__(v134, 13) ^ __ROR4__(v134, 22)) + (v233 & (v134 | v250) | v134 & v250);
  W_104 = (__ROR4__(W_96, 17) ^ __ROR4__(W_96, 19) ^ (W_96 >> 10))
        + W_76
        + ((W_44 >> 3) ^ __ROR4__(W_44, 7) ^ __ROR4__(W_44, 18))
        + W_40;
  v90 = (__ROR4__(v217, 6) ^ __ROR4__(v217, 11) ^ __ROR4__(v217, 25))
      + v167
      + (v184 ^ (v200 ^ v184) & v217)
      + W_104
      - 1341970488;
  v234 = v233 + v90;
  v168 = v90 + (__ROR4__(v151, 2) ^ __ROR4__(v151, 13) ^ __ROR4__(v151, 22)) + (v250 & (v151 | v134) | v151 & v134);
  W_108 = (__ROR4__(W_100, 17) ^ __ROR4__(W_100, 19) ^ (W_100 >> 10))
        + W_80
        + ((W_48 >> 3) ^ __ROR4__(W_48, 7) ^ __ROR4__(W_48, 18))
        + W_44;
  v91 = (__ROR4__(v234, 6) ^ __ROR4__(v234, 11) ^ __ROR4__(v234, 25))
      + v184
      + (v200 ^ (v217 ^ v200) & v234)
      + W_108
      - 1084653625;
  v251 = v250 + v91;
  v185 = v91 + (__ROR4__(v168, 2) ^ __ROR4__(v168, 13) ^ __ROR4__(v168, 22)) + (v134 & (v168 | v151) | v168 & v151);
  W_112 = (__ROR4__(W_104, 17) ^ __ROR4__(W_104, 19) ^ (W_104 >> 10))
        + W_84
        + ((W_52 >> 3) ^ __ROR4__(W_52, 7) ^ __ROR4__(W_52, 18))
        + W_48;
  v92 = (__ROR4__(v251, 6) ^ __ROR4__(v251, 11) ^ __ROR4__(v251, 25))
      + v200
      + (v217 ^ (v234 ^ v217) & v251)
      + W_112
      - 958395405;
  v135 = v134 + v92;
  v201 = v92 + (__ROR4__(v185, 2) ^ __ROR4__(v185, 13) ^ __ROR4__(v185, 22)) + (v151 & (v185 | v168) | v185 & v168);
  W_116 = (__ROR4__(W_108, 17) ^ __ROR4__(W_108, 19) ^ (W_108 >> 10))
        + W_88
        + ((W_56 >> 3) ^ __ROR4__(W_56, 7) ^ __ROR4__(W_56, 18))
        + W_52;
  v93 = (__ROR4__(v135, 6) ^ __ROR4__(v135, 11) ^ __ROR4__(v135, 25))
      + v217
      + (v234 ^ (v251 ^ v234) & v135)
      + W_116
      - 710438585;
  v152 = v151 + v93;
  v218 = v93 + (__ROR4__(v201, 2) ^ __ROR4__(v201, 13) ^ __ROR4__(v201, 22)) + (v168 & (v201 | v185) | v201 & v185);
  W_120 = (__ROR4__(W_112, 17) ^ __ROR4__(W_112, 19) ^ (W_112 >> 10))
        + W_92
        + ((W_60 >> 3) ^ __ROR4__(W_60, 7) ^ __ROR4__(W_60, 18))
        + W_56;
  v94 = (__ROR4__(v152, 6) ^ __ROR4__(v152, 11) ^ __ROR4__(v152, 25))
      + v234
      + (v251 ^ (v135 ^ v251) & v152)
      + W_120
      + 113926993;
  v169 = v168 + v94;
  v235 = v94 + (__ROR4__(v218, 2) ^ __ROR4__(v218, 13) ^ __ROR4__(v218, 22)) + (v185 & (v218 | v201) | v218 & v201);
  W_124 = (__ROR4__(W_116, 17) ^ __ROR4__(W_116, 19) ^ (W_116 >> 10))
        + W_96
        + ((W_64 >> 3) ^ __ROR4__(W_64, 7) ^ __ROR4__(W_64, 18))
        + W_60;
  v95 = (__ROR4__(v169, 6) ^ __ROR4__(v169, 11) ^ __ROR4__(v169, 25))
      + v251
      + (v135 ^ (v152 ^ v135) & v169)
      + W_124
      + 338241895;
  v186 = v185 + v95;
  v252 = v95 + (__ROR4__(v235, 2) ^ __ROR4__(v235, 13) ^ __ROR4__(v235, 22)) + (v201 & (v235 | v218) | v235 & v218);
  W_128 = (__ROR4__(W_120, 17) ^ __ROR4__(W_120, 19) ^ (W_120 >> 10))
        + W_100
        + ((W_68 >> 3) ^ __ROR4__(W_68, 7) ^ __ROR4__(W_68, 18))
        + W_64;
  v96 = (__ROR4__(v186, 6) ^ __ROR4__(v186, 11) ^ __ROR4__(v186, 25))
      + v135
      + (v152 ^ (v169 ^ v152) & v186)
      + W_128
      + 666307205;
  v202 = v201 + v96;
  v136 = v96 + (__ROR4__(v252, 2) ^ __ROR4__(v252, 13) ^ __ROR4__(v252, 22)) + (v218 & (v252 | v235) | v252 & v235);
  W_132 = (__ROR4__(W_124, 17) ^ __ROR4__(W_124, 19) ^ (W_124 >> 10))
        + W_104
        + ((W_72 >> 3) ^ __ROR4__(W_72, 7) ^ __ROR4__(W_72, 18))
        + W_68;
  v97 = (__ROR4__(v202, 6) ^ __ROR4__(v202, 11) ^ __ROR4__(v202, 25))
      + v152
      + (v169 ^ (v186 ^ v169) & v202)
      + W_132
      + 773529912;
  v219 = v218 + v97;
  v153 = v97 + (__ROR4__(v136, 2) ^ __ROR4__(v136, 13) ^ __ROR4__(v136, 22)) + (v235 & (v136 | v252) | v136 & v252);
  W_136 = (__ROR4__(W_128, 17) ^ __ROR4__(W_128, 19) ^ (W_128 >> 10))
        + W_108
        + ((W_76 >> 3) ^ __ROR4__(W_76, 7) ^ __ROR4__(W_76, 18))
        + W_72;
  v98 = (__ROR4__(v219, 6) ^ __ROR4__(v219, 11) ^ __ROR4__(v219, 25))
      + v169
      + (v186 ^ (v202 ^ v186) & v219)
      + W_136
      + 1294757372;
  v236 = v235 + v98;
  v170 = v98 + (__ROR4__(v153, 2) ^ __ROR4__(v153, 13) ^ __ROR4__(v153, 22)) + (v252 & (v153 | v136) | v153 & v136);
  W_140 = (__ROR4__(W_132, 17) ^ __ROR4__(W_132, 19) ^ (W_132 >> 10))
        + W_112
        + ((W_80 >> 3) ^ __ROR4__(W_80, 7) ^ __ROR4__(W_80, 18))
        + W_76;
  v99 = (__ROR4__(v236, 6) ^ __ROR4__(v236, 11) ^ __ROR4__(v236, 25))
      + v186
      + (v202 ^ (v219 ^ v202) & v236)
      + W_140
      + 1396182291;
  v253 = v252 + v99;
  v187 = v99 + (__ROR4__(v170, 2) ^ __ROR4__(v170, 13) ^ __ROR4__(v170, 22)) + (v136 & (v170 | v153) | v170 & v153);
  W_144 = (__ROR4__(W_136, 17) ^ __ROR4__(W_136, 19) ^ (W_136 >> 10))
        + W_116
        + ((W_84 >> 3) ^ __ROR4__(W_84, 7) ^ __ROR4__(W_84, 18))
        + W_80;
  v100 = (__ROR4__(v253, 6) ^ __ROR4__(v253, 11) ^ __ROR4__(v253, 25))
       + v202
       + (v219 ^ (v236 ^ v219) & v253)
       + W_144
       + 1695183700;
  v137 = v136 + v100;
  v203 = v100 + (__ROR4__(v187, 2) ^ __ROR4__(v187, 13) ^ __ROR4__(v187, 22)) + (v153 & (v187 | v170) | v187 & v170);
  W_148 = (__ROR4__(W_140, 17) ^ __ROR4__(W_140, 19) ^ (W_140 >> 10))
        + W_120
        + ((W_88 >> 3) ^ __ROR4__(W_88, 7) ^ __ROR4__(W_88, 18))
        + W_84;
  v101 = (__ROR4__(v137, 6) ^ __ROR4__(v137, 11) ^ __ROR4__(v137, 25))
       + v219
       + (v236 ^ (v253 ^ v236) & v137)
       + W_148
       + 1986661051;
  v154 = v153 + v101;
  v220 = v101 + (__ROR4__(v203, 2) ^ __ROR4__(v203, 13) ^ __ROR4__(v203, 22)) + (v170 & (v203 | v187) | v203 & v187);
  W_152 = (__ROR4__(W_144, 17) ^ __ROR4__(W_144, 19) ^ (W_144 >> 10))
        + W_124
        + ((W_92 >> 3) ^ __ROR4__(W_92, 7) ^ __ROR4__(W_92, 18))
        + W_88;
  v102 = (__ROR4__(v154, 6) ^ __ROR4__(v154, 11) ^ __ROR4__(v154, 25))
       + v236
       + (v253 ^ (v137 ^ v253) & v154)
       + W_152
       - 2117940946;
  v171 = v170 + v102;
  v237 = v102 + (__ROR4__(v220, 2) ^ __ROR4__(v220, 13) ^ __ROR4__(v220, 22)) + (v187 & (v220 | v203) | v220 & v203);
  W_156 = (__ROR4__(W_148, 17) ^ __ROR4__(W_148, 19) ^ (W_148 >> 10))
        + W_128
        + ((W_96 >> 3) ^ __ROR4__(W_96, 7) ^ __ROR4__(W_96, 18))
        + W_92;
  v103 = (__ROR4__(v171, 6) ^ __ROR4__(v171, 11) ^ __ROR4__(v171, 25))
       + v253
       + (v137 ^ (v154 ^ v137) & v171)
       + W_156
       - 1838011259;
  v188 = v187 + v103;
  v254 = v103 + (__ROR4__(v237, 2) ^ __ROR4__(v237, 13) ^ __ROR4__(v237, 22)) + (v203 & (v237 | v220) | v237 & v220);
  W_160 = (__ROR4__(W_152, 17) ^ __ROR4__(W_152, 19) ^ (W_152 >> 10))
        + W_132
        + ((W_100 >> 3) ^ __ROR4__(W_100, 7) ^ __ROR4__(W_100, 18))
        + W_96;
  v104 = (__ROR4__(v188, 6) ^ __ROR4__(v188, 11) ^ __ROR4__(v188, 25))
       + v137
       + (v154 ^ (v171 ^ v154) & v188)
       + W_160
       - 1564481375;
  v204 = v203 + v104;
  v138 = v104 + (__ROR4__(v254, 2) ^ __ROR4__(v254, 13) ^ __ROR4__(v254, 22)) + (v220 & (v254 | v237) | v254 & v237);
  W_164 = (__ROR4__(W_156, 17) ^ __ROR4__(W_156, 19) ^ (W_156 >> 10))
        + W_136
        + ((W_104 >> 3) ^ __ROR4__(W_104, 7) ^ __ROR4__(W_104, 18))
        + W_100;
  v105 = (__ROR4__(v204, 6) ^ __ROR4__(v204, 11) ^ __ROR4__(v204, 25))
       + v154
       + (v171 ^ (v188 ^ v171) & v204)
       + W_164
       - 1474664885;
  v221 = v220 + v105;
  v155 = v105 + (__ROR4__(v138, 2) ^ __ROR4__(v138, 13) ^ __ROR4__(v138, 22)) + (v237 & (v138 | v254) | v138 & v254);
  W_168 = (__ROR4__(W_160, 17) ^ __ROR4__(W_160, 19) ^ (W_160 >> 10))
        + W_140
        + ((W_108 >> 3) ^ __ROR4__(W_108, 7) ^ __ROR4__(W_108, 18))
        + W_104;
  v106 = (__ROR4__(v221, 6) ^ __ROR4__(v221, 11) ^ __ROR4__(v221, 25))
       + v171
       + (v188 ^ (v204 ^ v188) & v221)
       + W_168
       - 1035236496;
  v238 = v237 + v106;
  v172 = v106 + (__ROR4__(v155, 2) ^ __ROR4__(v155, 13) ^ __ROR4__(v155, 22)) + (v254 & (v155 | v138) | v155 & v138);
  W_172 = (__ROR4__(W_164, 17) ^ __ROR4__(W_164, 19) ^ (W_164 >> 10))
        + W_144
        + ((W_112 >> 3) ^ __ROR4__(W_112, 7) ^ __ROR4__(W_112, 18))
        + W_108;
  v107 = (__ROR4__(v238, 6) ^ __ROR4__(v238, 11) ^ __ROR4__(v238, 25))
       + v188
       + (v204 ^ (v221 ^ v204) & v238)
       + W_172
       - 949202525;
  v255 = v254 + v107;
  v189 = v107 + (__ROR4__(v172, 2) ^ __ROR4__(v172, 13) ^ __ROR4__(v172, 22)) + (v138 & (v172 | v155) | v172 & v155);
  W_176 = (__ROR4__(W_168, 17) ^ __ROR4__(W_168, 19) ^ (W_168 >> 10))
        + W_148
        + ((W_116 >> 3) ^ __ROR4__(W_116, 7) ^ __ROR4__(W_116, 18))
        + W_112;
  v108 = (__ROR4__(v255, 6) ^ __ROR4__(v255, 11) ^ __ROR4__(v255, 25))
       + v204
       + (v221 ^ (v238 ^ v221) & v255)
       + W_176
       - 778901479;
  v139 = v138 + v108;
  v205 = v108 + (__ROR4__(v189, 2) ^ __ROR4__(v189, 13) ^ __ROR4__(v189, 22)) + (v155 & (v189 | v172) | v189 & v172);
  W_180 = (__ROR4__(W_172, 17) ^ __ROR4__(W_172, 19) ^ (W_172 >> 10))
        + W_152
        + ((W_120 >> 3) ^ __ROR4__(W_120, 7) ^ __ROR4__(W_120, 18))
        + W_116;
  v109 = (__ROR4__(v139, 6) ^ __ROR4__(v139, 11) ^ __ROR4__(v139, 25))
       + v221
       + (v238 ^ (v255 ^ v238) & v139)
       + W_180
       - 694614492;
  v156 = v155 + v109;
  v222 = v109 + (__ROR4__(v205, 2) ^ __ROR4__(v205, 13) ^ __ROR4__(v205, 22)) + (v172 & (v205 | v189) | v205 & v189);
  W_184 = (__ROR4__(W_176, 17) ^ __ROR4__(W_176, 19) ^ (W_176 >> 10))
        + W_156
        + ((W_124 >> 3) ^ __ROR4__(W_124, 7) ^ __ROR4__(W_124, 18))
        + W_120;
  v110 = (__ROR4__(v156, 6) ^ __ROR4__(v156, 11) ^ __ROR4__(v156, 25))
       + v238
       + (v255 ^ (v139 ^ v255) & v156)
       + W_184
       - 200395387;
  v173 = v172 + v110;
  v239 = v110 + (__ROR4__(v222, 2) ^ __ROR4__(v222, 13) ^ __ROR4__(v222, 22)) + (v189 & (v222 | v205) | v222 & v205);
  W_188 = (__ROR4__(W_180, 17) ^ __ROR4__(W_180, 19) ^ (W_180 >> 10))
        + W_160
        + ((W_128 >> 3) ^ __ROR4__(W_128, 7) ^ __ROR4__(W_128, 18))
        + W_124;
  v111 = (__ROR4__(v173, 6) ^ __ROR4__(v173, 11) ^ __ROR4__(v173, 25))
       + v255
       + (v139 ^ (v156 ^ v139) & v173)
       + W_188
       + 275423344;
  v190 = v189 + v111;
  v256 = v111 + (__ROR4__(v239, 2) ^ __ROR4__(v239, 13) ^ __ROR4__(v239, 22)) + (v205 & (v239 | v222) | v239 & v222);
  W_192 = (__ROR4__(W_184, 17) ^ __ROR4__(W_184, 19) ^ (W_184 >> 10))
        + W_164
        + ((W_132 >> 3) ^ __ROR4__(W_132, 7) ^ __ROR4__(W_132, 18))
        + W_128;
  v112 = (__ROR4__(v190, 6) ^ __ROR4__(v190, 11) ^ __ROR4__(v190, 25))
       + v139
       + (v156 ^ (v173 ^ v156) & v190)
       + W_192
       + 430227734;
  v206 = v205 + v112;
  v140 = v112 + (__ROR4__(v256, 2) ^ __ROR4__(v256, 13) ^ __ROR4__(v256, 22)) + (v222 & (v256 | v239) | v256 & v239);
  W_196 = (__ROR4__(W_188, 17) ^ __ROR4__(W_188, 19) ^ (W_188 >> 10))
        + W_168
        + ((W_136 >> 3) ^ __ROR4__(W_136, 7) ^ __ROR4__(W_136, 18))
        + W_132;
  v113 = (__ROR4__(v206, 6) ^ __ROR4__(v206, 11) ^ __ROR4__(v206, 25))
       + v156
       + (v173 ^ (v190 ^ v173) & v206)
       + W_196
       + 506948616;
  v223 = v222 + v113;
  v157 = v113 + (__ROR4__(v140, 2) ^ __ROR4__(v140, 13) ^ __ROR4__(v140, 22)) + (v239 & (v140 | v256) | v140 & v256);
  W_200 = (__ROR4__(W_192, 17) ^ __ROR4__(W_192, 19) ^ (W_192 >> 10))
        + W_172
        + ((W_140 >> 3) ^ __ROR4__(W_140, 7) ^ __ROR4__(W_140, 18))
        + W_136;
  v114 = (__ROR4__(v223, 6) ^ __ROR4__(v223, 11) ^ __ROR4__(v223, 25))
       + v173
       + (v190 ^ (v206 ^ v190) & v223)
       + W_200
       + 659060556;
  v240 = v239 + v114;
  v174 = v114 + (__ROR4__(v157, 2) ^ __ROR4__(v157, 13) ^ __ROR4__(v157, 22)) + (v256 & (v157 | v140) | v157 & v140);
  W_204 = (__ROR4__(W_196, 17) ^ __ROR4__(W_196, 19) ^ (W_196 >> 10))
        + W_176
        + ((W_144 >> 3) ^ __ROR4__(W_144, 7) ^ __ROR4__(W_144, 18))
        + W_140;
  v115 = (__ROR4__(v240, 6) ^ __ROR4__(v240, 11) ^ __ROR4__(v240, 25))
       + v190
       + (v206 ^ (v223 ^ v206) & v240)
       + W_204
       + 883997877;
  v257 = v256 + v115;
  v191 = v115 + (__ROR4__(v174, 2) ^ __ROR4__(v174, 13) ^ __ROR4__(v174, 22)) + (v140 & (v174 | v157) | v174 & v157);
  W_208 = (__ROR4__(W_200, 17) ^ __ROR4__(W_200, 19) ^ (W_200 >> 10))
        + W_180
        + ((W_148 >> 3) ^ __ROR4__(W_148, 7) ^ __ROR4__(W_148, 18))
        + W_144;
  v116 = (__ROR4__(v257, 6) ^ __ROR4__(v257, 11) ^ __ROR4__(v257, 25))
       + v206
       + (v223 ^ (v240 ^ v223) & v257)
       + W_208
       + 958139571;
  v141 = v140 + v116;
  v207 = v116 + (__ROR4__(v191, 2) ^ __ROR4__(v191, 13) ^ __ROR4__(v191, 22)) + (v157 & (v191 | v174) | v191 & v174);
  W_212 = (__ROR4__(W_204, 17) ^ __ROR4__(W_204, 19) ^ (W_204 >> 10))
        + W_184
        + ((W_152 >> 3) ^ __ROR4__(W_152, 7) ^ __ROR4__(W_152, 18))
        + W_148;
  v117 = (__ROR4__(v141, 6) ^ __ROR4__(v141, 11) ^ __ROR4__(v141, 25))
       + v223
       + (v240 ^ (v257 ^ v240) & v141)
       + W_212
       + 1322822218;
  v158 = v157 + v117;
  v224 = v117 + (__ROR4__(v207, 2) ^ __ROR4__(v207, 13) ^ __ROR4__(v207, 22)) + (v174 & (v207 | v191) | v207 & v191);
  W_216 = (__ROR4__(W_208, 17) ^ __ROR4__(W_208, 19) ^ (W_208 >> 10))
        + W_188
        + ((W_156 >> 3) ^ __ROR4__(W_156, 7) ^ __ROR4__(W_156, 18))
        + W_152;
  v118 = (__ROR4__(v158, 6) ^ __ROR4__(v158, 11) ^ __ROR4__(v158, 25))
       + v240
       + (v257 ^ (v141 ^ v257) & v158)
       + W_216
       + 1537002063;
  v175 = v174 + v118;
  v241 = v118 + (__ROR4__(v224, 2) ^ __ROR4__(v224, 13) ^ __ROR4__(v224, 22)) + (v191 & (v224 | v207) | v224 & v207);
  W_220 = (__ROR4__(W_212, 17) ^ __ROR4__(W_212, 19) ^ (W_212 >> 10))
        + W_192
        + ((W_160 >> 3) ^ __ROR4__(W_160, 7) ^ __ROR4__(W_160, 18))
        + W_156;
  v119 = (__ROR4__(v175, 6) ^ __ROR4__(v175, 11) ^ __ROR4__(v175, 25))
       + v257
       + (v141 ^ (v158 ^ v141) & v175)
       + W_220
       + 1747873779;
  v192 = v191 + v119;
  v258 = v119 + (__ROR4__(v241, 2) ^ __ROR4__(v241, 13) ^ __ROR4__(v241, 22)) + (v207 & (v241 | v224) | v241 & v224);
  W_224 = (__ROR4__(W_216, 17) ^ __ROR4__(W_216, 19) ^ (W_216 >> 10))
        + W_196
        + ((W_164 >> 3) ^ __ROR4__(W_164, 7) ^ __ROR4__(W_164, 18))
        + W_160;
  v120 = (__ROR4__(v192, 6) ^ __ROR4__(v192, 11) ^ __ROR4__(v192, 25))
       + v141
       + (v158 ^ (v175 ^ v158) & v192)
       + W_224
       + 1955562222;
  v208 = v207 + v120;
  v142 = v120 + (__ROR4__(v258, 2) ^ __ROR4__(v258, 13) ^ __ROR4__(v258, 22)) + (v224 & (v258 | v241) | v258 & v241);
  W_228 = (__ROR4__(W_220, 17) ^ __ROR4__(W_220, 19) ^ (W_220 >> 10))
        + W_200
        + ((W_168 >> 3) ^ __ROR4__(W_168, 7) ^ __ROR4__(W_168, 18))
        + W_164;
  v121 = (__ROR4__(v208, 6) ^ __ROR4__(v208, 11) ^ __ROR4__(v208, 25))
       + v158
       + (v175 ^ (v192 ^ v175) & v208)
       + W_228
       + 2024104815;
  v225 = v224 + v121;
  v159 = v121 + (__ROR4__(v142, 2) ^ __ROR4__(v142, 13) ^ __ROR4__(v142, 22)) + (v241 & (v142 | v258) | v142 & v258);
  W_232 = (__ROR4__(W_224, 17) ^ __ROR4__(W_224, 19) ^ (W_224 >> 10))
        + W_204
        + ((W_172 >> 3) ^ __ROR4__(W_172, 7) ^ __ROR4__(W_172, 18))
        + W_168;
  v122 = (__ROR4__(v225, 6) ^ __ROR4__(v225, 11) ^ __ROR4__(v225, 25))
       + v175
       + (v192 ^ (v208 ^ v192) & v225)
       + W_232
       - 2067236844;
  v242 = v241 + v122;
  v176 = v122 + (__ROR4__(v159, 2) ^ __ROR4__(v159, 13) ^ __ROR4__(v159, 22)) + (v258 & (v159 | v142) | v159 & v142);
  W_236 = (__ROR4__(W_228, 17) ^ __ROR4__(W_228, 19) ^ (W_228 >> 10))
        + W_208
        + ((W_176 >> 3) ^ __ROR4__(W_176, 7) ^ __ROR4__(W_176, 18))
        + W_172;
  v123 = (__ROR4__(v242, 6) ^ __ROR4__(v242, 11) ^ __ROR4__(v242, 25))
       + v192
       + (v208 ^ (v225 ^ v208) & v242)
       + W_236
       - 1933114872;
  v259 = v258 + v123;
  v193 = v123 + (__ROR4__(v176, 2) ^ __ROR4__(v176, 13) ^ __ROR4__(v176, 22)) + (v142 & (v176 | v159) | v176 & v159);
  W_240 = (__ROR4__(W_232, 17) ^ __ROR4__(W_232, 19) ^ (W_232 >> 10))
        + W_212
        + ((W_180 >> 3) ^ __ROR4__(W_180, 7) ^ __ROR4__(W_180, 18))
        + W_176;
  v124 = (__ROR4__(v259, 6) ^ __ROR4__(v259, 11) ^ __ROR4__(v259, 25))
       + v208
       + (v225 ^ (v242 ^ v225) & v259)
       + W_240
       - 1866530822;
  v143 = v142 + v124;
  v209 = v124 + (__ROR4__(v193, 2) ^ __ROR4__(v193, 13) ^ __ROR4__(v193, 22)) + (v159 & (v193 | v176) | v193 & v176);
  W_244 = (__ROR4__(W_236, 17) ^ __ROR4__(W_236, 19) ^ (W_236 >> 10))
        + W_216
        + ((W_184 >> 3) ^ __ROR4__(W_184, 7) ^ __ROR4__(W_184, 18))
        + W_180;
  v125 = (__ROR4__(v143, 6) ^ __ROR4__(v143, 11) ^ __ROR4__(v143, 25))
       + v225
       + (v242 ^ (v259 ^ v242) & v143)
       + W_244
       - 1538233109;
  v160 = v159 + v125;
  v226 = v125 + (__ROR4__(v209, 2) ^ __ROR4__(v209, 13) ^ __ROR4__(v209, 22)) + (v176 & (v209 | v193) | v209 & v193);
  v126 = (__ROR4__(v160, 6) ^ __ROR4__(v160, 11) ^ __ROR4__(v160, 25))
       + v242
       + (v259 ^ (v143 ^ v259) & v160)
       + (__ROR4__(W_240, 17) ^ __ROR4__(W_240, 19) ^ (W_240 >> 10))
       + W_220
       + ((W_188 >> 3) ^ __ROR4__(W_188, 7) ^ __ROR4__(W_188, 18))
       + W_184
       - 1090935817;
  v177 = v176 + v126;
  v243 = v126 + (__ROR4__(v226, 2) ^ __ROR4__(v226, 13) ^ __ROR4__(v226, 22)) + (v193 & (v226 | v209) | v226 & v209);
  v127 = (__ROR4__(v177, 6) ^ __ROR4__(v177, 11) ^ __ROR4__(v177, 25))
       + v259
       + (v143 ^ (v160 ^ v143) & v177)
       + (__ROR4__(W_244, 17) ^ __ROR4__(W_244, 19) ^ (W_244 >> 10))
       + W_224
       + ((W_192 >> 3) ^ __ROR4__(W_192, 7) ^ __ROR4__(W_192, 18))
       + W_188
       - 965641998;
  *((_DWORD *)ctx + 2) += v127
                        + (__ROR4__(v243, 2) ^ __ROR4__(v243, 13) ^ __ROR4__(v243, 22))
                        + (v209 & (v243 | v226) | v243 & v226);
  *((_DWORD *)ctx + 3) += v243;
  *((_DWORD *)ctx + 4) += v226;
  *((_DWORD *)ctx + 5) += v209;
  *((_DWORD *)ctx + 6) += v193 + v127;
  *((_DWORD *)ctx + 7) += v177;
  *((_DWORD *)ctx + 8) += v160;
  *((_DWORD *)ctx + 9) += v143;
}

//----- (00016C08) --------------------------------------------------------
void __cdecl sha2_update(sha2_context *ctx, const unsigned __int8 *input, int ilen)
{
  int v3; // [sp+4h] [bp+4h]
  const unsigned __int8 *src; // [sp+8h] [bp+8h]
  int n; // [sp+10h] [bp+10h]
  int v7; // [sp+14h] [bp+14h]

  src = input;
  v3 = ilen;
  if ( ilen > 0 )
  {
    v7 = *(_DWORD *)ctx & 0x3F;
    n = 64 - v7;
    *(_DWORD *)ctx += ilen;
    *(_DWORD *)ctx = *(_DWORD *)ctx;
    if ( *(_DWORD *)ctx < (unsigned int)ilen )
      ++*((_DWORD *)ctx + 1);
    if ( v7 && ilen >= n )
    {
      memcpy((char *)ctx + v7 + 40, input, n);
      sha2_process(ctx, (const unsigned __int8 *)ctx + 40);
      src += n;
      v3 -= n;
      v7 = 0;
    }
    while ( v3 > 63 )
    {
      sha2_process(ctx, src);
      src += 64;
      v3 -= 64;
    }
    if ( v3 > 0 )
      memcpy((char *)ctx + v7 + 40, src, v3);
  }
}

//----- (00016CD8) --------------------------------------------------------
void __cdecl sha2_finish(sha2_context *ctx, unsigned __int8 *output)
{
  int v2; // r3
  unsigned __int8 v5[8]; // [sp+8h] [bp+8h] BYREF
  int v6; // [sp+10h] [bp+10h]
  unsigned int v7; // [sp+14h] [bp+14h]
  __int64 v8; // [sp+18h] [bp+18h]

  v8 = 8LL * *(_QWORD *)ctx;
  v5[0] = HIBYTE(v8);
  v5[1] = BYTE6(v8);
  v5[2] = BYTE5(v8);
  v5[3] = BYTE4(v8);
  v5[4] = BYTE3(v8);
  v5[5] = BYTE2(v8);
  v5[6] = BYTE1(v8);
  v5[7] = v8;
  v7 = *(_DWORD *)ctx & 0x3F;
  if ( v7 > 0x37 )
    v2 = 120 - v7;
  else
    v2 = 56 - v7;
  v6 = v2;
  sha2_update(ctx, sha2_padding, v2);
  sha2_update(ctx, v5, 8);
  *output = HIBYTE(*((_DWORD *)ctx + 2));
  output[1] = BYTE2(*((_DWORD *)ctx + 2));
  output[2] = BYTE1(*((_DWORD *)ctx + 2));
  output[3] = *((_DWORD *)ctx + 2);
  output[4] = HIBYTE(*((_DWORD *)ctx + 3));
  output[5] = BYTE2(*((_DWORD *)ctx + 3));
  output[6] = BYTE1(*((_DWORD *)ctx + 3));
  output[7] = *((_DWORD *)ctx + 3);
  output[8] = HIBYTE(*((_DWORD *)ctx + 4));
  output[9] = BYTE2(*((_DWORD *)ctx + 4));
  output[10] = BYTE1(*((_DWORD *)ctx + 4));
  output[11] = *((_DWORD *)ctx + 4);
  output[12] = HIBYTE(*((_DWORD *)ctx + 5));
  output[13] = BYTE2(*((_DWORD *)ctx + 5));
  output[14] = BYTE1(*((_DWORD *)ctx + 5));
  output[15] = *((_DWORD *)ctx + 5);
  output[16] = HIBYTE(*((_DWORD *)ctx + 6));
  output[17] = BYTE2(*((_DWORD *)ctx + 6));
  output[18] = BYTE1(*((_DWORD *)ctx + 6));
  output[19] = *((_DWORD *)ctx + 6);
  output[20] = HIBYTE(*((_DWORD *)ctx + 7));
  output[21] = BYTE2(*((_DWORD *)ctx + 7));
  output[22] = BYTE1(*((_DWORD *)ctx + 7));
  output[23] = *((_DWORD *)ctx + 7);
  output[24] = HIBYTE(*((_DWORD *)ctx + 8));
  output[25] = BYTE2(*((_DWORD *)ctx + 8));
  output[26] = BYTE1(*((_DWORD *)ctx + 8));
  output[27] = *((_DWORD *)ctx + 8);
  output[28] = HIBYTE(*((_DWORD *)ctx + 9));
  output[29] = BYTE2(*((_DWORD *)ctx + 9));
  output[30] = BYTE1(*((_DWORD *)ctx + 9));
  output[31] = *((_DWORD *)ctx + 9);
}
// 1BCB0: using guessed type unsigned __int8 sha2_padding[64];

//----- (00016F2C) --------------------------------------------------------
void __cdecl sha2(const unsigned __int8 *input, int ilen, unsigned __int8 *output)
{
  char ctx[232]; // [sp+10h] [bp+10h] BYREF

  sha2_starts((sha2_context *)ctx);
  sha2_update((sha2_context *)ctx, input, ilen);
  sha2_finish((sha2_context *)ctx, output);
  memset(ctx, 0, sizeof(ctx));
}

//----- (00016F74) --------------------------------------------------------
unsigned int __fastcall swab32(unsigned int a1)
{
  return bswap32(a1);
}

//----- (00016F8C) --------------------------------------------------------
void __cdecl flip_swab(void *dest_p, const void *src_p, unsigned int length)
{
  unsigned int i; // [sp+1Ch] [bp+1Ch]

  for ( i = 0; i < length >> 2; ++i )
    *((_DWORD *)dest_p + i) = swab32(*((_DWORD *)src_p + i));
}

//----- (00016FDC) --------------------------------------------------------
void __cdecl flip32(void *dest_p, const void *src_p)
{
  int i; // [sp+14h] [bp+14h]

  for ( i = 0; i <= 7; ++i )
    *((_DWORD *)dest_p + i) = swab32(*((_DWORD *)src_p + i));
}

//----- (00017024) --------------------------------------------------------
int __fastcall read_temperature_from_fpga_register(unsigned __int8 a1)
{
  unsigned __int8 v3; // [sp+Fh] [bp+Fh]

  v3 = 0;
  switch ( a1 )
  {
    case 0u:
    case 1u:
    case 2u:
    case 3u:
      v3 = (unsigned int)read_axi_fpga(8) >> (8 * a1);
      break;
    case 4u:
    case 5u:
    case 6u:
    case 7u:
      v3 = (unsigned int)read_axi_fpga(9) >> (8 * (a1 - 4));
      break;
    case 8u:
    case 9u:
    case 0xAu:
    case 0xBu:
      v3 = (unsigned int)read_axi_fpga(10) >> (8 * (a1 - 8));
      break;
    case 0xCu:
    case 0xDu:
    case 0xEu:
    case 0xFu:
      v3 = (unsigned int)read_axi_fpga(11) >> (8 * (a1 - 12));
      break;
    default:
      printf(
        "%s: which_chain = %d, but it is wrong! \n",
        "read_temperature_from_fpga_register",
        (unsigned __int8)gChain);
      break;
  }
  printf("\n%s: Chain%d temperature is %d\n\n", "read_temperature_from_fpga_register", a1, v3);
  if ( v3 )
    gSensor_OK[4 * a1] = 1;
  if ( v3 >= byte_14659C )
    gStartTest = 1;
  if ( v3 > byte_14659E )
    gHigherThanAlarmTemp = 1;
  return v3;
}
// 25974: using guessed type char gChain;
// 25B34: using guessed type char gStartTest;
// 25B38: using guessed type char gHigherThanAlarmTemp;
// 125C3C: using guessed type _BYTE gSensor_OK[64];
// 14659C: using guessed type char byte_14659C;
// 14659E: using guessed type char byte_14659E;

//----- (00017188) --------------------------------------------------------
int __fastcall read_temperature_through_fpga_iic_register(unsigned __int8 a1, int a2)
{
  unsigned __int8 v5; // [sp+Fh] [bp+Fh]
  unsigned __int8 v6; // [sp+17h] [bp+17h]

  v6 = 0;
  if ( gHashBoard_V9 && byte_1465B4 == 1 )
    v6 = 9;
  pthread_mutex_lock(&i2c_mutex);
  v5 = i2c_read((a2 << 26) | (v6 << 20) | (a1 << 16) | 0x1000000);
  pthread_mutex_unlock(&i2c_mutex);
  if ( v5 )
    gSensor_OK[4 * a1] = 1;
  if ( v5 >= byte_14659C )
    gStartTest = 1;
  if ( v5 > byte_14659E )
    gHigherThanAlarmTemp = 1;
  return v5;
}
// 25B08: using guessed type char gHashBoard_V9;
// 25B34: using guessed type char gStartTest;
// 25B38: using guessed type char gHigherThanAlarmTemp;
// 125C3C: using guessed type _BYTE gSensor_OK[64];
// 126128: using guessed type pthread_mutex_t i2c_mutex;
// 14659C: using guessed type char byte_14659C;
// 14659E: using guessed type char byte_14659E;
// 1465B4: using guessed type char byte_1465B4;

//----- (00017270) --------------------------------------------------------
void *reset_V9_global_arg()
{
  void *result; // r0
  int v1; // [sp+4h] [bp+4h]
  unsigned int m; // [sp+8h] [bp+8h]
  unsigned int k; // [sp+Ch] [bp+Ch]
  unsigned int j; // [sp+10h] [bp+10h]
  unsigned int i; // [sp+14h] [bp+14h]

  result = reset_global_arg();
  for ( i = 0; i <= 0xF; ++i )
  {
    *((_BYTE *)&cgpu + i + 131896) = 0;
    gRepeated_Nonce_Id[i] = 0;
    gValid_Nonce_Num[i] = 0;
    gSend_Work_Num[i] = 0;
    for ( j = 0; j <= 0x2C; ++j )
    {
      v1 = *((_DWORD *)&cgpu + j + 16427);
      for ( k = 0; k <= 0x31; ++k )
      {
        gAsic_Core_Nonce_Num[128 * ((i << 7) + j) + k] = 0;
        for ( m = 0; dword_1464FC > m; ++m )
          *(_DWORD *)(v1 + 116 * (k * dword_1464FC + m) + 4 * (i + 12) + 4) = 0;
      }
    }
  }
  return result;
}
// 25B3C: using guessed type _DWORD gValid_Nonce_Num[16];
// 25BBC: using guessed type _DWORD gSend_Work_Num[16];
// 25BFC: using guessed type _DWORD gAsic_Core_Nonce_Num[11345];
// 125BFC: using guessed type _DWORD gRepeated_Nonce_Id[16];
// 1464FC: using guessed type int dword_1464FC;

//----- (00017390) --------------------------------------------------------
int __fastcall V9_set_voltage(unsigned __int8 a1, unsigned __int8 a2, char a3)
{
  unsigned int v7; // [sp+2Ch] [bp+1Ch]

  switch ( pattern_test_time )
  {
    case 0:
      v7 = dword_146558;
      break;
    case 1:
      v7 = dword_14655C;
      break;
    case 2:
      v7 = dword_146560;
      break;
    case 3:
      v7 = dword_146564;
      break;
    case 4:
      v7 = dword_146568;
      break;
    case 5:
      v7 = dword_14656C;
      break;
    case 6:
      v7 = dword_146570;
      break;
    case 7:
      v7 = dword_146574;
      break;
    case 8:
      v7 = dword_146578;
      break;
    default:
      v7 = dword_146558;
      printf("\n--- %s: Can't find voltage%d\n", (const char *)(unsigned __int8)pattern_test_time, jpt_173C6);
      break;
  }
  if ( a3 )
    v7 += dword_1465AC;
  printf(
    "\n--- %s: real voltage = %d, temp_voltage = %.6f, Pic_Voltage = %d\n",
    "V9_set_voltage",
    v7,
    1742.06996 - (double)v7 * 152.134146 / 100.0,
    (unsigned int)(1742.06996 - (double)v7 * 152.134146 / 100.0));
  set_PIC16F1704_voltage(a1, a2, (unsigned int)(1742.06996 - (double)v7 * 152.134146 / 100.0));
  return usleep(0x186A0u);
}
// 173CC: using guessed type void *jpt_173C6[9];
// 25B19: using guessed type char pattern_test_time;
// 146558: using guessed type int dword_146558;
// 14655C: using guessed type int dword_14655C;
// 146560: using guessed type int dword_146560;
// 146564: using guessed type int dword_146564;
// 146568: using guessed type int dword_146568;
// 14656C: using guessed type int dword_14656C;
// 146570: using guessed type int dword_146570;
// 146574: using guessed type int dword_146574;
// 146578: using guessed type int dword_146578;
// 1465AC: using guessed type int dword_1465AC;

//----- (00017550) --------------------------------------------------------
int V9_calculate_timeout_and_baud()
{
  int result; // r0
  unsigned int v1; // [sp+Ch] [bp+4h]
  unsigned int v2; // [sp+14h] [bp+Ch]

  v2 = 0;
  v1 = calculate_core_number(0x32u);
  switch ( pattern_test_time )
  {
    case 0:
      v2 = dword_146504;
      break;
    case 1:
      v2 = dword_146508;
      break;
    case 2:
      v2 = dword_14650C;
      break;
    case 3:
      v2 = dword_146510;
      break;
    case 4:
      v2 = dword_146514;
      break;
    case 5:
      v2 = dword_146518;
      break;
    case 6:
      v2 = dword_14651C;
      break;
    case 7:
      v2 = dword_146520;
      break;
    case 8:
      v2 = dword_146524;
      break;
    default:
      printf(
        "%s: pattern_test_time = %d, error!!! \n",
        "V9_calculate_timeout_and_baud",
        (unsigned __int8)pattern_test_time);
      break;
  }
  dword_146580 = 95 * (gChain_Asic_Interval * (0x1000000 / v1) / v2) / 0x64;
  dword_1465BC = 0x2FAF08 / ((0x196E6Au / dword_146580) << 9) - 1;
  if ( (unsigned int)dword_1465BC > 0x1A )
    dword_1465BC = 26;
  if ( (unsigned int)dword_1465BC <= 0x1A )
    dword_1465BC = dword_1465BC != 0;
  result = printf(
             "\n--- %s: baud = %d, timeout = 0x%08x = %d\n",
             "V9_calculate_timeout_and_baud",
             dword_1465BC,
             dword_146580,
             dword_146580);
  dword_146500 = v2;
  return result;
}
// 25B19: using guessed type char pattern_test_time;
// 25B2C: using guessed type int gChain_Asic_Interval;
// 146500: using guessed type int dword_146500;
// 146504: using guessed type int dword_146504;
// 146508: using guessed type int dword_146508;
// 14650C: using guessed type int dword_14650C;
// 146510: using guessed type int dword_146510;
// 146514: using guessed type int dword_146514;
// 146518: using guessed type int dword_146518;
// 14651C: using guessed type int dword_14651C;
// 146520: using guessed type int dword_146520;
// 146524: using guessed type int dword_146524;
// 146580: using guessed type int dword_146580;
// 1465BC: using guessed type int dword_1465BC;

//----- (0001776C) --------------------------------------------------------
int __fastcall V9_set_address(unsigned __int8 a1)
{
  int result; // r0
  unsigned __int8 i; // [sp+Eh] [bp+Eh]
  unsigned __int8 v4; // [sp+Fh] [bp+Fh]

  v4 = 0;
  printf("\n--- %s: Chain : %d\n", "V9_set_address", a1);
  result = BM1385_chain_inactive(a1);
  for ( i = 0; i <= 0x2Cu; ++i )
  {
    BM1385_set_address(a1, v4);
    v4 += gChain_Asic_Interval;
    result = usleep(0x1388u);
  }
  return result;
}
// 25B2C: using guessed type int gChain_Asic_Interval;

//----- (000177E0) --------------------------------------------------------
int __fastcall V9_set_baud(unsigned __int8 a1, unsigned __int8 a2)
{
  printf("\n--- %s: Chain : %d, baud = %d\n", "V9_set_baud", a1, a2);
  BM1385_set_baud(a1, 0, a2, 1);
  usleep(0xC350u);
  return set_fpga_baud(a2);
}

//----- (00017830) --------------------------------------------------------
int __fastcall V9_open_core(unsigned __int8 a1)
{
  int result; // r0
  char v3[64]; // [sp+Ch] [bp+Ch] BYREF
  int v4; // [sp+4Ch] [bp+4Ch]
  int v5; // [sp+50h] [bp+50h]
  int v6; // [sp+54h] [bp+54h]
  unsigned int j; // [sp+58h] [bp+58h]
  unsigned int i; // [sp+5Ch] [bp+5Ch]

  i = 0;
  v6 = 0;
  v5 = 0;
  j = 0;
  v4 = 0;
  memset(v3, 0, sizeof(v3));
  v3[0] = -1;
  printf("\n--- %s: Chain : %d\n", "V9_open_core", a1);
  gIsOpenCoreEnd = 0;
  gIsOpeningCore = 1;
  memset(v3, 0, sizeof(v3));
  BM1385_set_gateblk(a1, 0, 1);
  for ( i = 0; i <= 0x31; ++i )
  {
    uart_send(a1, v3, 0x40u);
    usleep(dword_14657C);
  }
  memset(v3, 0, sizeof(v3));
  for ( j = 0; j <= 0x33; ++j )
    v3[j] = j;
  v3[52] = -1;
  BM1385_set_gateblk(a1, 0, 1);
  for ( i = 0; i <= 0x3B; ++i )
  {
    uart_send(a1, v3, 0x40u);
    usleep(dword_14657C);
  }
  result = clear_uart_rx_fifo(a1);
  gIsOpeningCore = 0;
  gIsOpenCoreEnd = 1;
  return result;
}
// 25B36: using guessed type char gIsOpenCoreEnd;
// 25B37: using guessed type char gIsOpeningCore;
// 14657C: using guessed type int dword_14657C;

//----- (0001797C) --------------------------------------------------------
int __fastcall V9_get_result(unsigned __int8 a1)
{
  int v3; // [sp+Ch] [bp+Ch]
  unsigned int v4; // [sp+10h] [bp+10h]
  unsigned int v5; // [sp+10h] [bp+10h]
  int v6; // [sp+14h] [bp+14h]
  int v7; // [sp+18h] [bp+18h]
  unsigned int m; // [sp+1Ch] [bp+1Ch]
  unsigned int k; // [sp+20h] [bp+20h]
  unsigned int i; // [sp+24h] [bp+24h]
  unsigned int j; // [sp+24h] [bp+24h]

  v7 = 0;
  v6 = 7;
  puts("\n\n------------------------------------------------------------------------------------------------------\n");
  printf("every ASIC require nonce number: %lu\n", 50 * dword_1464FC);
  for ( i = 0; i <= 0x2C; ++i )
  {
    if ( !(i % 9) )
      putchar(10);
    v4 = calculate_how_many_nonce_per_asic_get(a1, i, 0x32u);
    printf("asic[%02d]=%d\t", i, v4);
    if ( 50 * dword_1464FC > v4 && dword_1465B0 < (unsigned int)++v7 )
      v6 &= ~1u;
  }
  puts("\n");
  for ( j = 0; j <= 0x2C; ++j )
  {
    v5 = calculate_how_many_nonce_per_asic_get(a1, j, 0x32u);
    if ( 50 * dword_1464FC > v5 )
    {
      printf("asic[%02d] = %d\n", j, v5);
      v3 = *((_DWORD *)&cgpu + j + 16427);
      for ( k = 0; k <= 0x31; ++k )
      {
        if ( gAsic_Core_Nonce_Num[128 * ((a1 << 7) + j) + k] < (unsigned int)dword_1464FC )
        {
          printf("core[%02d] = %d,      lost these nonce : ", k, gAsic_Core_Nonce_Num[128 * ((a1 << 7) + j) + k]);
          for ( m = 0; dword_1464FC > m; ++m )
          {
            if ( !*(_DWORD *)(v3 + 116 * (k * dword_1464FC + m) + 4 * (a1 + 12) + 4) )
              printf("%d  ", m);
          }
          putchar(10);
        }
      }
      puts("\n");
    }
  }
  puts("\n------------------------------------------------------------------------------------------------------\n");
  if ( gSensor_OK[4 * a1] != 1 )
    v6 &= ~2u;
  if ( gHigherThanAlarmTemp )
    v6 &= ~4u;
  printf("Chain%d total valid nonce number: %d\n\n", a1, gValid_Nonce_Num[a1]);
  if ( (v6 & 1) != 0 )
    puts("Pattern OK\n");
  else
    puts("Pattern NG\n");
  if ( (v6 & 2) != 0 )
    puts("Sensor OK\n");
  else
    puts("Sensor NG\n");
  if ( (v6 & 4) != 0 )
    puts("Temperature OK\n");
  else
    puts("Temperature NG\n");
  printf("HW number = %d\n\n", gHw_Nonce_Num[a1]);
  return v6;
}
// 25B38: using guessed type char gHigherThanAlarmTemp;
// 25B3C: using guessed type _DWORD gValid_Nonce_Num[16];
// 25B7C: using guessed type _DWORD gHw_Nonce_Num[16];
// 25BFC: using guessed type _DWORD gAsic_Core_Nonce_Num[11345];
// 125C3C: using guessed type _BYTE gSensor_OK[64];
// 1464FC: using guessed type int dword_1464FC;
// 1465B0: using guessed type int dword_1465B0;

//----- (00017C88) --------------------------------------------------------
unsigned int __fastcall V9_print_lcd(char a1)
{
  display_level_result_on_lcd();
  if ( (a1 & 1) != 0 )
  {
    write_lcd_no_memset(1u, (int)"   Pattern OK   ", 0x10u);
    pattern_test_time = 0;
  }
  else
  {
    write_lcd_no_memset(1u, (int)"   Pattern NG   ", 0x10u);
    ++pattern_test_time;
  }
  if ( (a1 & 2) != 0 )
    write_lcd_no_memset(2u, (int)"   Sensor OK    ", 0x10u);
  else
    write_lcd_no_memset(2u, (int)"   Sensor NG    ", 0x10u);
  if ( (a1 & 4) != 0 )
    return write_lcd_no_memset(3u, (int)" Temperature OK ", 0x10u);
  else
    return write_lcd_no_memset(3u, (int)" Temperature NG ", 0x10u);
}
// 25B19: using guessed type char pattern_test_time;

//----- (00017D44) --------------------------------------------------------
void __fastcall __noreturn V9_show_status_func(unsigned __int8 *a1)
{
  int temperature_through_fpga_iic_register; // [sp+Ch] [bp+Ch]
  unsigned __int8 v2; // [sp+12h] [bp+12h]
  unsigned __int8 v3; // [sp+13h] [bp+13h]

  v3 = *a1;
  v2 = a1[1];
  time_counter = 0;
  while ( 1 )
  {
    memset(lcd_output, 32, 0x40u);
    temperature_through_fpga_iic_register = read_temperature_through_fpga_iic_register(v3, v2);
    sprintf(lcd_output, "   time %ds", time_counter);
    sprintf(s, "   nonce=%d", gValid_Nonce_Num[v3]);
    sprintf(byte_259B8, "   temp %d `C", temperature_through_fpga_iic_register);
    if ( temperature_through_fpga_iic_register > (unsigned int)gHighest_Temp )
      gHighest_Temp = temperature_through_fpga_iic_register;
    ++time_counter;
    write(lcd_fd, lcd_output, 0x40u);
    if ( byte_14659C > temperature_through_fpga_iic_register )
    {
      if ( gStartTest != 1 )
        printf(
          "\nHash Board temperature is %d, waiting it raise to start temperature %d\n",
          temperature_through_fpga_iic_register,
          byte_14659C);
    }
    else
    {
      if ( gStartTest != 1 )
        printf("\nBegin test!!! Hash Board temperature is %d\n", temperature_through_fpga_iic_register);
      gStartTest = 1;
    }
    set_fan_speed(10);
    printf(
      "\nChain%d get valid nonce number : %d. temperature is %d\n",
      v3,
      gValid_Nonce_Num[v3],
      temperature_through_fpga_iic_register);
    usleep((__useconds_t)&unk_F4240);
  }
}
// 25B1C: using guessed type int time_counter;
// 25B28: using guessed type int gHighest_Temp;
// 25B34: using guessed type char gStartTest;
// 25B3C: using guessed type _DWORD gValid_Nonce_Num[16];
// 12611C: using guessed type int lcd_fd;
// 14659C: using guessed type char byte_14659C;

//----- (00017ED4) --------------------------------------------------------
int __fastcall v9_check_nonce(unsigned __int8 a1, unsigned __int8 *a2)
{
  unsigned int v2; // r0
  int v7; // [sp+10h] [bp+8h]
  unsigned int v8; // [sp+18h] [bp+10h]
  unsigned int v9; // [sp+20h] [bp+18h]
  unsigned int v10; // [sp+24h] [bp+1Ch]
  unsigned int v11; // [sp+28h] [bp+20h]
  int i; // [sp+30h] [bp+28h]
  int v13; // [sp+34h] [bp+2Ch]

  v13 = 0;
  v8 = _byteswap_ulong(*(_DWORD *)a2);
  v2 = *a2 / (unsigned int)gChain_Asic_Interval;
  v11 = v2;
  v10 = a2[3] & 0x3F;
  v9 = a2[4] & 0x7F;
  if ( v2 > 0x2C )
    return -1;
  if ( v10 <= 0x31 )
  {
    if ( dword_1464FC > v9 )
    {
      v7 = *((_DWORD *)&cgpu + v2 + 16427) + 116 * (v10 * dword_1464FC + v9);
      if ( v8 == *(_DWORD *)(v7 + 4) )
      {
        if ( *(_DWORD *)(v7 + 4 * (a1 + 12) + 4) )
        {
          ++gRepeated_Nonce_Id[a1];
          ++*(_DWORD *)(v7 + 4 * (a1 + 12) + 4);
        }
        else
        {
          ++*(_DWORD *)(v7 + 4 * (a1 + 12) + 4);
          ++gValid_Nonce_Num[a1];
          ++gAsic_Core_Nonce_Num[128 * ((a1 << 7) + v2) + v10];
        }
      }
      else
      {
        pthread_mutex_lock(&HW_check_mutex[a1]);
        for ( i = 0; (unsigned __int8)gWork_Num_For_Hw_Check > i; ++i )
        {
          v13 = check_hw(&gWorks_For_Hw_Check[290 * a1 + 29 * i], v8, 0);
          if ( !v13 )
            break;
        }
        pthread_mutex_unlock(&HW_check_mutex[a1]);
        if ( v13 == 1 )
        {
          ++gHw_Nonce_Num[a1];
          printf("%s: Find a HW. Chain%d ASIC%d Core%d : nonce = 0x%08x.\n", "v9_check_nonce", a1, v11, v10, v8);
        }
      }
      return 0;
    }
    else
    {
      printf("%s: received work_id = %02d nonce. error!!!\t", "v9_check_nonce", v9);
      printf(",received data is : 0x%02x%02x%02x%02x%02x\n", *a2, a2[1], a2[2], a2[3], a2[4]);
      return -1;
    }
  }
  else
  {
    printf("%s: received core%02d nonce. error!!!\t", "v9_check_nonce", v10);
    printf(",received data is : 0x%02x%02x%02x%02x%02x\n", *a2, a2[1], a2[2], a2[3], a2[4]);
    return -1;
  }
}
// 25B2C: using guessed type int gChain_Asic_Interval;
// 25B3C: using guessed type _DWORD gValid_Nonce_Num[16];
// 25B7C: using guessed type _DWORD gHw_Nonce_Num[16];
// 25BFC: using guessed type _DWORD gAsic_Core_Nonce_Num[11345];
// 125BFC: using guessed type _DWORD gRepeated_Nonce_Id[16];
// 125C7C: using guessed type char gWork_Num_For_Hw_Check;
// 125C98: using guessed type pthread_mutex_t HW_check_mutex[16];
// 1464FC: using guessed type int dword_1464FC;
// 1465C4: using guessed type _DWORD gWorks_For_Hw_Check[4640];

//----- (000181FC) --------------------------------------------------------
int __fastcall V9_check_register_value(char a1, int a2)
{
  if ( *(_DWORD *)(reg_value_buf + 8) > 0x1FEu )
  {
    printf("%s: reg_value_buf buffer is full!\n", "V9_check_register_value");
    return -1;
  }
  else
  {
    *(_DWORD *)(reg_value_buf + 8 * (*(_DWORD *)reg_value_buf + 2)) = _byteswap_ulong(*(_DWORD *)a2);
    *(_BYTE *)(reg_value_buf + 8 * (*(_DWORD *)reg_value_buf + 2) + 4) = *(_BYTE *)(a2 + 4) & 0x1F;
    *(_BYTE *)(reg_value_buf + 8 * (*(_DWORD *)reg_value_buf + 2) + 5) = a1;
    ++*(_DWORD *)reg_value_buf;
    ++*(_DWORD *)(reg_value_buf + 8);
    if ( *(_DWORD *)reg_value_buf > 0x1FFu )
      *(_DWORD *)reg_value_buf = 0;
    return 0;
  }
}
// 1464B8: using guessed type int reg_value_buf;

//----- (0001830C) --------------------------------------------------------
int __fastcall V9_send_func(unsigned __int8 *a1)
{
  int v1; // r3
  char v3[64]; // [sp+14h] [bp+Ch] BYREF
  void *src; // [sp+54h] [bp+4Ch]
  int v5; // [sp+58h] [bp+50h]
  int v6; // [sp+5Ch] [bp+54h]
  int v7; // [sp+60h] [bp+58h]
  int v8; // [sp+64h] [bp+5Ch]
  unsigned __int8 v9; // [sp+6Bh] [bp+63h]
  unsigned __int8 *v10; // [sp+6Ch] [bp+64h]
  int m; // [sp+70h] [bp+68h]
  unsigned int k; // [sp+74h] [bp+6Ch]
  unsigned int j; // [sp+78h] [bp+70h]
  unsigned int i; // [sp+7Ch] [bp+74h]

  v10 = a1;
  v9 = *a1;
  j = 0;
  k = 0;
  v8 = 0;
  v7 = 0;
  v6 = 0;
  m = 0;
  memset(v3, 0, sizeof(v3));
  for ( i = 0; i <= 0x2C; ++i )
  {
    v5 = *((_DWORD *)&cgpu + i + 16427);
    for ( j = 0; j <= 0x31; ++j )
    {
      for ( k = 0; dword_1464FC > k; ++k )
      {
        src = (void *)(v5 + 116 * (j * dword_1464FC + k));
        for ( m = 0; m <= 31; ++m )
          v3[m] = *((_BYTE *)src + m + 20);
        v6 = *((_DWORD *)src + 1);
        v3[44] = HIBYTE(v6);
        v3[45] = BYTE2(v6);
        v3[46] = BYTE1(v6);
        v3[47] = v6;
        v3[51] = k;
        for ( m = 0; m <= 11; ++m )
          v3[m + 52] = *((_BYTE *)src + m + 8);
        uart_send(v9, v3, 0x40u);
        pthread_mutex_lock(&HW_check_mutex[v9]);
        for ( m = 8; m >= 0; --m )
          memcpy(&gWorks_For_Hw_Check[290 * v9 + 29 + 29 * m], &gWorks_For_Hw_Check[290 * v9 + 29 * m], 0x74u);
        if ( (unsigned __int8)++gWork_Num_For_Hw_Check > 8u )
          gWork_Num_For_Hw_Check = 9;
        memcpy(&gWorks_For_Hw_Check[290 * v9], src, 0x74u);
        pthread_mutex_unlock(&HW_check_mutex[v9]);
        ++gSend_Work_Num[v9];
        usleep(0x7D0u);
      }
    }
  }
  while ( gSend_Work_Num[v9] < (unsigned int)(2250 * dword_1464FC) )
    printf(
      "\n\n---%s: Chain%d send work num : %d, less than %d\n",
      "V9_send_func",
      v9,
      gSend_Work_Num[v9],
      2250 * dword_1464FC);
  printf("\n\n---%s: Chain%d send work num : %d\n", "V9_send_func", v9, gSend_Work_Num[v9]);
  puts("\nsend test pattern done");
  system("date");
  putchar(10);
  usleep(0x9C40u);
  start_receive = 0;
  puts("to stop receive");
  return v1;
}
// 18652: variable 'v1' is possibly undefined
// 25B39: using guessed type char start_receive;
// 25BBC: using guessed type _DWORD gSend_Work_Num[16];
// 125C7C: using guessed type char gWork_Num_For_Hw_Check;
// 125C98: using guessed type pthread_mutex_t HW_check_mutex[16];
// 1464FC: using guessed type int dword_1464FC;
// 1465C4: using guessed type _DWORD gWorks_For_Hw_Check[4640];

//----- (0001865C) --------------------------------------------------------
int __fastcall V9_receive_func(unsigned __int8 *a1)
{
  _DWORD v2[2]; // [sp+8h] [bp+8h] BYREF
  _BYTE v3[500]; // [sp+10h] [bp+10h] BYREF
  _BYTE v4[1052]; // [sp+204h] [bp+204h] BYREF
  int v5; // [sp+620h] [bp+620h]
  unsigned int v6; // [sp+624h] [bp+624h]
  unsigned int v7; // [sp+628h] [bp+628h]
  unsigned int v8; // [sp+62Ch] [bp+62Ch]
  unsigned __int8 v9; // [sp+632h] [bp+632h]
  unsigned __int8 v10; // [sp+633h] [bp+633h]
  unsigned __int8 *v11; // [sp+634h] [bp+634h]
  unsigned int k; // [sp+638h] [bp+638h]
  unsigned int j; // [sp+63Ch] [bp+63Ch]
  unsigned int i; // [sp+640h] [bp+640h]
  int v15; // [sp+644h] [bp+644h]
  unsigned int v16; // [sp+648h] [bp+648h]
  int v17; // [sp+64Ch] [bp+64Ch]

  v11 = a1;
  v10 = *a1;
  v9 = a1[1];
  memset(v4, 0, 0x41Au);
  memset(v3, 0, sizeof(v3));
  v2[0] = 0;
  LOBYTE(v2[1]) = 0;
  v8 = 0;
  v17 = 0;
  v16 = 0;
  v15 = 0;
  v7 = 0;
  v6 = 0;
  i = 0;
  j = 0;
  k = 0;
  v5 = 0;
  printf("%s: which_chain = %d, which_i2c = %d\n", "V9_receive_func", v10, v9);
  clear_uart_rx_fifo(v10);
LABEL_29:
  while ( start_receive )
  {
    usleep(0x1388u);
    for ( i = 0; i <= 0x4C4B3F; ++i )
    {
      while ( gIsOpeningCore )
        usleep(0x4E20u);
      memset(v4, 0, 0x41Au);
      v8 = uart_receive(v10, (int)v4, 0x3E8u);
      if ( v8 )
      {
        for ( j = 0; j < v8; ++j )
          v3[v16++] = v4[j];
        if ( v16 > 4 )
        {
          v7 = v16 / 5;
          for ( j = 0; j < v7; ++j )
          {
            memset(v2, 0, 5u);
            for ( k = 0; k <= 4; ++k )
              *((_BYTE *)v2 + k) = v3[v15++];
            if ( is_nonce_or_reg_value(v2[1]) )
            {
              if ( gStartTest )
              {
                if ( gIsOpenCoreEnd )
                {
                  v5 = v9_check_nonce(v10, (unsigned __int8 *)v2);
                  if ( v5 == -1 )
                    ++v17;
                }
              }
            }
            else
            {
              v5 = V9_check_register_value(v10, (int)v2);
              if ( v5 == -1 )
                ++v17;
            }
          }
          v6 = v16 - v15;
          for ( k = 0; k < v6; ++k )
            v3[k] = v3[v15++];
          v16 = v6;
          v15 = 0;
          v7 = 0;
        }
        goto LABEL_29;
      }
    }
  }
  return (unsigned __int8)start_receive;
}
// 25B34: using guessed type char gStartTest;
// 25B36: using guessed type char gIsOpenCoreEnd;
// 25B37: using guessed type char gIsOpeningCore;
// 25B39: using guessed type char start_receive;

//----- (0001895C) --------------------------------------------------------
unsigned int singleBoardTest_V9_BM1385_45()
{
  unsigned int result; // r0
  char v1[16]; // [sp+4h] [bp+4h] BYREF
  int v2; // [sp+14h] [bp+14h]
  int v3; // [sp+18h] [bp+18h]
  int v4; // [sp+1Ch] [bp+1Ch]

  v4 = 0;
  v3 = 0;
  v2 = 123456;
  qmemcpy(v1, "                ", sizeof(v1));
  printf("\nBegin %s test\n", "singleBoardTest_V9_BM1385_45");
  system("date");
  putchar(10);
  memset(&lcd_output, 32, 0x40u);
  if ( lcd_fd > 0 )
  {
    lseek(lcd_fd, 0, 0);
    write(lcd_fd, &lcd_output, 0x40u);
  }
  init_fpga();
  set_fpga_baud(0x1Au);
  reset_V9_global_arg();
  check_chain();
  if ( (unsigned __int8)gChain == 255 )
  {
    pthread_cancel(dword_136144);
    pthread_cancel(newthread);
    usleep((__useconds_t)&unk_7A120);
    write_lcd(1u, (int)" no hash board  ", 0x10u);
    return puts("\nNo hash board, please plug in it");
  }
  else
  {
    pthread_create(&newthread, 0, (void *(*)(void *))V9_show_status_func, &chain_info[2 * (unsigned __int8)gChain]);
    reset_PIC16F1704_pic(gChain, gI2c);
    jump_from_loader_to_app_PIC16F1704(gChain, gI2c);
    V9_set_voltage(gChain, gI2c, 0);
    enable_PIC16F1704_dc_dc(gChain, gI2c, 1u);
    pthread_create(&dword_13614C, 0, (void *(*)(void *))pic_heart_beat_func, &chain_info[2 * (unsigned __int8)gChain]);
    reset_hash_board();
    start_receive = 1;
    pthread_create(&dword_136144, 0, (void *(*)(void *))V9_receive_func, &chain_info[2 * (unsigned __int8)gChain]);
    puts("\n--- V9 check asic number");
    check_BM1385_asic_reg(gChain, 0, 0, 1);
    printf(
      "\n--- check chain: J%d has asicNum = %d\n",
      (unsigned __int8)gChain,
      *((unsigned __int8 *)&cgpu + (unsigned __int8)gChain + 131896));
    if ( *((unsigned __int8 *)&cgpu + (unsigned __int8)gChain + 131896) == dword_146528
      && (V9_set_baud(gChain, 1u),
          reset_hash_board(),
          set_fpga_baud(0x1Au),
          *((_BYTE *)&cgpu + (unsigned __int8)gChain + 131896) = 0,
          puts("\n--- double check asic number"),
          check_BM1385_asic_reg(gChain, 0, 0, 1),
          printf(
            "\n--- check chain: J%d has asicNum = %d\n",
            (unsigned __int8)gChain + 1,
            *((unsigned __int8 *)&cgpu + (unsigned __int8)gChain + 131896)),
          *((unsigned __int8 *)&cgpu + (unsigned __int8)gChain + 131896) == dword_146528) )
    {
      V9_calculate_timeout_and_baud();
      set_BM1385_freq(gChain, 0, dword_146500, 1);
      V9_set_address(gChain);
      V9_set_baud(gChain, dword_1465BC);
      V9_open_core(gChain);
      puts("\nBegin send test pattern");
      while ( gStartTest != 1 )
      {
        if ( dword_1465A0 <= (unsigned int)time_counter )
        {
          pthread_cancel(dword_136144);
          pthread_cancel(newthread);
          pthread_cancel(dword_13614C);
          puts("Can't open core, change to next voltage and freq");
          write_lcd(0, (int)"Can't open core ", 0x10u);
          write_lcd_no_memset(1u, (int)"change  to  next", 0x10u);
          result = write_lcd_no_memset(2u, (int)"voltage and freq", 0x10u);
          ++pattern_test_time;
          return result;
        }
        usleep(0x2710u);
      }
      pthread_create(&dword_136140, 0, (void *(*)(void *))V9_send_func, &chain_info[2 * (unsigned __int8)gChain]);
      pthread_join(dword_136140, 0);
      pthread_cancel(newthread);
      v2 = pthread_join(dword_136144, 0);
      v3 = V9_get_result(gChain);
      V9_print_lcd(v3);
      if ( v3 == 7 && byte_1465A8 )
        V9_set_voltage(gChain, gI2c, 1);
      if ( (v3 & 1) != 0 || (unsigned __int8)pattern_test_time >= (unsigned int)(unsigned __int8)gHowManyVoltageLevel )
        enable_PIC16F1704_dc_dc(gChain, gI2c, 0);
      pthread_mutex_lock(&i2c_mutex);
      pthread_cancel(dword_13614C);
      pthread_mutex_unlock(&i2c_mutex);
      set_fan_speed(0);
      return usleep((__useconds_t)&unk_7A120);
    }
    else
    {
      enable_PIC16F1704_dc_dc(gChain, gI2c, 0);
      pthread_cancel(dword_136144);
      pthread_cancel(newthread);
      pthread_mutex_lock(&i2c_mutex);
      pthread_cancel(dword_13614C);
      pthread_mutex_unlock(&i2c_mutex);
      sprintf(&v1[7], "%d", *((unsigned __int8 *)&cgpu + (unsigned __int8)gChain + 131896));
      write_lcd(0, (int)"   Only have    ", 0x10u);
      write_lcd_no_memset(1u, (int)v1, 0x10u);
      write_lcd_no_memset(2u, (int)"      ASIC      ", 0x10u);
      printf(
        "\n\n---%s: Only have %d ASIC\n",
        "singleBoardTest_V9_BM1385_45",
        *((unsigned __int8 *)&cgpu + (unsigned __int8)gChain + 131896));
      return puts("----------------------------\n\n");
    }
  }
}
// 17D44: using guessed type void __noreturn V9_show_status_func();
// 1830C: using guessed type int V9_send_func();
// 25974: using guessed type char gChain;
// 25B0E: using guessed type char gI2c;
// 25B18: using guessed type char gHowManyVoltageLevel;
// 25B19: using guessed type char pattern_test_time;
// 25B1C: using guessed type int time_counter;
// 25B34: using guessed type char gStartTest;
// 25B39: using guessed type char start_receive;
// 12611C: using guessed type int lcd_fd;
// 126128: using guessed type pthread_mutex_t i2c_mutex;
// 146498: using guessed type _BYTE chain_info[32];
// 146500: using guessed type int dword_146500;
// 146528: using guessed type int dword_146528;
// 1465A0: using guessed type int dword_1465A0;
// 1465A8: using guessed type char byte_1465A8;
// 1465BC: using guessed type int dword_1465BC;
// 1895C: using guessed type char anonymous_0[16];

//----- (00019428) --------------------------------------------------------
int _aeabi_ldiv0()
{
  return raise(8);
}

//----- (00019434) --------------------------------------------------------
__int64 init()
{
  unsigned int v0; // r5
  int i; // r4
  __int64 (__fastcall *v2)(); // t1
  __int64 result; // r0

  init_proc();
  v0 = 0x24FFCu;
  for ( i = 0; i != 1; ++i )
  {
    v2 = *(__int64 (__fastcall **)())(v0 + 4);
    v0 += 4;
    result = v2();
  }
  return result;
}

//----- (0001947C) --------------------------------------------------------
void term_proc()
{
  ;
}

// nfuncs=232 queued=153 decompiled=153 lumina nreq=0 worse=0 better=0
// ALL OK, 153 function(s) have been successfully decompiled
